/* 当前文件是./CINT2000\255.vortex\src\bmt0.c*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <signal.h>
#include <ctype.h>
#include <time.h>
#include <limits.h>
#include <errno.h>
#define  __DISPLAY_TIME__
#define  MAIN
#define  BMT0
#ifdef __DISPLAY_TIME__
#endif
/* 当前文件是./CINT2000\255.vortex\src\defines.h*/

//#ifndef DEFINES_H
#define DEFINES_H
#define    __UNIX__
#define    __BMT01__
#define      OPTIMIZE
#define    __SWAP_GRP_POS__
#undef     __INCLUDE_MTRX__
#define  ENV01
#define  EXT_ENUM          999999999L
#define  CHUNK_CONSTANT    0x55555555
#define  CORE_CONSTANT     0x55555555
#define  CORE_LIMIT        6000000L
#undef   CORE_LIMIT
#undef   ALIGN_BYTES
#define  CORE_BLOCK_ALIGN  4
#undef   CORE_BLOCK_ALIGN
#undef   SYSTEM_ALLOC
#undef   SYSTEM_FREESTORE
#undef   DEBUG_CORE0
#define  CORE_CRC_CHECK
#define  MCSTAT
#define  DEBUG             True_Status
#define  __STDOUT__
#undef   __MACROIZE_MEM__
#undef   VALIDATE_MEM_CHUNKS
#define  __FREEZE_VCHUNKS__
#undef   __FREEZE_GRP_PACKETS__
#define  FLUSH_FILES
#undef   __TRACK_FILE_READS__
#define  INCLUDE_ALL_CODE
#define  INCLUDE_DELETE_CODE
#undef   API_INCLUDE
#define  BE_CAREFUL
#undef   OLDWAY
#undef   NOTUSED
#undef   PAGE_SPACE
#undef   __NOSTR__
#undef   LEAVE_NO_TRACE
#undef   NULL_TRACE_STRS
#undef   CLOCK_IS_LONG
#undef   __DISPLAY_TIME__
#undef   NULL
#ifdef   LPTR
#define  NULL              0L
#else
#define  NULL              0
#endif
#define  False_Status      1
#define  True_Status       0
#define  LARGE
#define  MSGFILE          -1
#undef     __SWAP_VCHUNKS__
#undef     INCLUDE_KEYEDSET_CODE
#undef     INCLUDE_TBL_CODE
#undef     INCLUDE_DBE_CODE
#undef     FREEZE_SETNODE_CLASS
#define  UPPER_VALUE        16777215L
#undef   BE_CAREFUL
#define  __FREEZE_GRP_PACKETS__
#define  __MINIMIZE_TREE_CACHE__
#undef   __TRACK_FILE_READS__
#undef   DEBUG_CORE0
#undef   NO_DISKCACHE
#define USE_HPP_STYLE_HDRS
#ifdef    __UNIX__
#define  TIME(t1)  time((time_t *)t1)
#undef   __STDOUT__
#define  USE_H_STYLE_HDRS
#define  ALIGN_BYTES
#define  CORE_BLOCK_ALIGN  8
#define  SYSTEM_ALLOC
#define  SYSTEM_FREESTORE
#undef   NO_DISKCACHE
#define  __FREEZE_GRP_PACKETS__
#define  CORE_LIMIT     20971520L
#endif
#define    __RISC__
#ifdef     __HP__
#define ALIGN_BYTES
#endif
typedef size_t    SIZE_T;
#if defined(SPEC_CPU2000_LP64) || defined(SPEC_CPU2000_P64)
#undef  STRUC_ALIGN_BY8
#undef  STRUC_ALIGN_BY64
#undef  IMAGE_WITH_THAT
#else
#define STRUC_ALIGN_BY8
#undef  STRUC_ALIGN_BY64
#undef  IMAGE_WITH_THAT
#endif
#ifdef    __BMT01__
#undef   MCSTAT
#undef   DEBUG
#define  TRACKBACK
#define  LEAVE_NO_TRACE
#undef   VALIDATE_MEM_CHUNKS
#undef   INCLUDE_ALL_CODE
#undef   __USER_SUPPLIED__
#endif
#define  RANDOM_FUNC     Ut_Random
#ifdef  OPTIMIZE
#undef   DEBUG
#undef   DEBUG_CORE0
#undef   DEBUG_RISC
#undef   MCSTAT
#undef   FLUSH_FILES
#undef   __TRACK_FILE_READS__
#undef   CORE_CRC_CHECK
#define  __MACROIZE_MEM__
#undef   VALIDATE_MEM_CHUNKS
#define __MACROIZE_HM__
#undef   TRACKBACK
#define  LEAVE_NO_TRACE
#undef   NULL_TRACE_STRS
#undef   TREE_TIME
#undef   TREE_BUG
#undef   __DISPLAY_CORE__
#undef   __DISPLAY_ERRORS__
#undef   __DISPLAY_TIME__
#else
#define  DEBUG             True_Status
#undef   DEBUG_CORE0
#undef   DEBUG_RISC
#define  MCSTAT
#define  FLUSH_FILES
#define __TRACK_FILE_READS__
#define  CORE_CRC_CHECK
#define  __MACROIZE_MEM__
#define  VALIDATE_MEM_CHUNKS
#define  TRACKBACK
#undef   LEAVE_NO_TRACE
#undef   NULL_TRACE_STRS
#undef   TREE_TIME
#undef   TREE_BUG
#define  INCLUDE_ALL_CODE
#undef   __DISPLAY_CORE__
#define  __DISPLAY_ERRORS__
#define  __DISPLAY_TIME__
#endif
#ifdef    __WATCOMC__
#define __WTC__
#endif
#ifdef    __WTC__
#define TWOBYTE_BOOL
#define ONEBYTE_BOOL
#endif
#ifdef    __BORLANDC__
#define __BCC__
#endif
#ifdef   __BCC__
#undef  LARGE
#define USE_H_STYLE_HDRS
#define NULL_TRACE_STRS
#define CLOCK_IS_LONG
#endif
#ifdef    FAR_MEM
#define  GET_MEM           farcalloc
#define  FREE_MEM          farfree
#else
#define  GET_MEM           calloc
#define  FREE_MEM          free
#endif
#ifdef    __MAC__
#define  __GUI__
#define  __ZTC__
#define clock(void)   time(&NullTime)
#endif
#ifdef __ZTC__
#define NO_DISKCACHE
#endif
#ifdef    LARGE
#define             CorePage_Size            384000L
#else
#define             CorePage_Size            64000L
#endif
#define  NullPtr           NULL
#define  Null_DbId         (idtype )0
#define  Null_Handle       (handletype )0
#define  Null_ObjNum       (numtype )0xFFFF
#define  Null_Token        {0,0,0}
#define  MAXNAME           32
#define  MAXLINE           132
#define  MAXSTRING         1024
#define  MAXPATHNAME       1024
#define  RECORDLENGTH      512
#define  FILENAMELENGTH    1024
#define  AsciiEof          NULL
#define  AsciiEob          '\n'
#define  AsciiEow          '\0'
#define  Eow               '\0'
#define  Env_Objs          (indextype )286
#define  Extend_DbObjNums  (indextype )50
#define  Alloc_DbObjs      (indextype )286
#define  Extend_DbObjs     (indextype )50
#define  Env_Attrs         (indextype )600
#define  Alloc_Attrs       (indextype )600
#define  Extend_DbAttrNums (indextype )100
#define  Alloc_TxtTkns     (indextype )108
#define  Extend_TxtTkns    (indextype )108
#define  Alloc_ObjBitFields (indextype)36
#define  Extend_BitField    (indextype)10
#define  Alloc_Grps        (indextype )64
#define  Extend_Grps       (indextype )64
#define  Alloc_ObjectObjs  (indextype )286
#define  Extend_Objects    (indextype )50
#define  Alloc_ExObjects   (indextype )1001
#define  Extend_ExObjects  (indextype )1000
#define  Alloc_DbAttrs     (indextype )600
#define  Alloc_Fields      (chunkindextype )42
#define  Extend_Fields     (chunkindextype )16
#define  Alloc_RootFields  (chunkindextype )11
#define  Alloc_FieldRefs   (chunkindextype )108
#define  Extend_FieldRefs  (chunkindextype )20
#define        That_AttrNum           (numtype )1
#define        Handle_AttrNum         (numtype )2
#define        DbId_AttrNum           (numtype )3
#define        CoreDbId_AttrNum       (numtype )4
#define        ObjNum_AttrNum         (numtype )5
#define        TypeNum_AttrNum        (numtype )6
#define        ValueNum_AttrNum       (numtype )7
#define        StrucNum_AttrNum       (numtype )8
#define        AttrNum_AttrNum        (numtype )9
#define        SetNum_SetNum          (numtype )10
#define        SetNum_AttrNum         (numtype )10
#define        MatrixNum_AttrNum      (numtype )11
#define        TupleNum_AttrNum       (numtype )12
#define        SlotNum_AttrNum        (numtype )13
#define        SchemaNum_AttrNum      (numtype )14
#define        ViewNum_AttrNum        (numtype )15
#define        ShellNum_AttrNum       (numtype )16
#define        CodeNum_AttrNum        (numtype )17
#define        DbNum_AttrNum          (numtype )18
#define        Nam_AttrNum            (numtype )19
#define        EnvType_AttrNum        (numtype )20
#define        UnitChunk_AttrNum      (numtype )59
#define        Asm_Apl                (numtype )0
#define        C_Apl                  (numtype )1
#define        Cpp_Apl                (numtype )2
#define        F77_Apl                (numtype )3
#define        Pas_Apl                (numtype )4
#define        Api_Apl                (numtype )5
#define  Env_Normal                 0
#define  Env_CoreNoMore             1
#define  Env_OutOfMem               2
#define  Env_OryExists              3
#define  Env_BadDbPrimal            4
#define  Env_ZeroAllocQty           5
#define  Env_Less                   6
#define  Env_Gtr                    7
#define  Env_Installed             -8
#define  Env_BlackIII               9
#define  Env_EnumSizeConflict      10
#define  Env_WatchChangedValue     11
#define  Env_Break                -12
#define  Env_ObjNoHdr              13
#define  Env_BadDbId               14
#define  Env_SuppliedByShellApp    14
#define  Env_IdErrata              15
#define  Env_NullPtr               16
#define  Nuc_NullOp                17
#define  Core_SegmentSizeExceeded  18
#define  Core_RequestGtrPageSize   19
#define  Core_NotInAlignment       20
#define  Core_DuplicateFree        21
#define  Core_NULLCoreAddrOfFree   22
#define  Core_CRCoverWritten       23
#define  Mem_BitIndexGtrByteCount  30
#define  Ut_TraceLevelOutOfRange   41
#define  Lex_BadSyntax            101
#define  Lex_Eof                 -102
#define  Dbe_Exit                -200
#define  Dbe_Quit                -201
#define  Stack_EndOfStack        -300
#define  Stack_OutOfRange         301
#define  Err_BadDesign           1000
#define  Err_EmptyChunk          1001
#define  Err_NotEnufOnStack      1002
#define  Err_BadUnitType         1003
#define  Err_BadChunk            1004
#define  Err_IndexOutOfRange     1005
#define  Err_NoBytesMoved        1006
#define  Err_BadUnitSize         1007
#define  Err_BadStackMath        1008
#define  Err_NotImplemented      1009
#define  Mem_FoundGap           -1010
#define  Mem_NoFreeSpace         1011
#define  Info_NotExpanded        1012
#define  Mem_ChunkWasExpanded   -1013
#define  Mem_NullSwapVbn         1014
#define  Mem_ChunkCRCisBad       1015
#define  Core_GapFound          -1022
#define  Core_NullFreeSpacePut   1023
#define  Core_BadGap             1024
#define  Dump_NullObjectAddr     1030
#define  File_BadXblkWrite       1050
#define  File_BadXblkRead        1051
#define  File_EndOfFile          1052
#define  File_ChunkNotLoaded    -1053
#define  File_EmptyOutChunk      1054
#define  File_BadXblkSeek        1055
#define  Env_NullObjHdr          2000
#define  Env0_Corrupted          2001
#define  Env0_NullRegionQty      2002
#define  Env0_NoPrimalIntegrity  2003
#define  Env01_BadObjNumMap      2004
#define  Hm_BadHandlesStack      3000
#define  Hm_NoRoomForObject      3001
#define  Hm_ObjNotInSchema       3002
#define  Hm_BadHandle            3003
#define  Hm_ObjectNotPaired     -3004
#define  Hm_ObjectWasDeleted    -3005
#define  Hm_NoFreeHandles       -3006
#define  Hm_GtrHandleUnits       3007
#define  Tm_ObjectNotPaired     -4001
#define  Tm_NullDb               4002
#define  Tm_DbIdOutOfRange       4003
#define  Grp_BadGrpCount         4100
#define  Grp_GrpHdrNotExist      4101
#define  Grp_PacketNotExist      4102
#define  Grp_PacketNotLoaded     4103
#define  Grp_BaseRgnNotNew       4104
#define  Grp_BadSwapChunks       4105
#define  Grp_NullRegionChunk     4106
#define  Grp_RgnNotResident      4107
#define  Grp_IndexOutOfRange     4108
#define  Grp_NoBaseRegion        4109
#define  Grp_AllRgnsAreFrozen   -4110
#define  Grp_NullDb              4111
#define  Grp_BadExEntryTable     4112
#define  Grp_CanNotSwapBaseRgn  -4113
#define  Grp_PermaFrostReached   4114
#define  Grp_RgnNotMatched       4114
#define  Vgrp_DeletedIndex       4200
#define  Vgrp_IndexGtrCount      4201
#define  Om_ObjNotInSchema       5001
#define  Om_ObjHdrExists         5002
#define  Om_ObjHdrNotExist       5003
#define  Om_NewIndex            -5004
#define  Om_BadRegion            5005
#define  Om_NullRegionChunk      5006
#define  Om_BadAddr              5007
#define  Om_IndexOutOfRange     -5008
#define  Om_BadSwapChunks        5009
#define  Om_BadHandleObjPair     5010
#define  Om_ObjectHasBeenDeleted 5011
#define  Oa_VchunkNotExist       5053
#define  Oa_VchunkIndexTooLarge  5054
#define  Oa_ValueNoFindInVchunk  5055
#define  Oa_ValueAlreadyInVchunk 5056
#define  Oa_NullObjHdr           5059
#define  Oa_NewObjHdr            5060
#define  Oa_ObjClassNotLoaded    5063
#define  Oa_NotInCreateMode      5064
#define  Oa_VchunkNoAccess       5065
#define  Oa_ObjNotInImageForm    5066
#define  Oa_BadObjStacks         5067
#define  Oa_ObjectHasBeenDeleted 5069
#define  Oa_AttrNotInDbmsClassDef 5070
#define  Oa_FieldSizeTooLarge    5071
#define List01_NullNode            7001
#define List01_NoNodeMem           7002
#define List01_NotaListNode        7003
#define List01_NotaListHead        7004
#define List01_AttrNotOfObjCestors 7005
#define List01_EndOfList          -7006
#define List01_AlreadyInList       7007
#define List01_NotFound            7008
#define List01_NullListTkn         7009
#define List01_BadPrevNode         7010
#define List01_EndOfPrevList      -7011
#define List01_EmptyList          -7012
#define List01_AttrNotOfObjCestrs  7013
#define List01_InvalidListHead     7014
#define List01_GRPisFrosted        7015
#define List01_NodeNotOfSameList   7016
#define  BitVec_CoreNoMore       7021
#define  BitVec_OutOfRange       7022
#define List00_NullNode            7001
#define List00_NoNodeMem           7002
#define List00_NotaListNode        7003
#define List00_NotaListHead        7004
#define List00_AttrNotOfObjCestors 7005
#define List00_EndOfList          -7006
#define List00_AlreadyInList       7007
#define List00_NotFound            7008
#define List00_NullListTkn         7009
#define List00_BadPrevNode         7010
#define List00_EndOfPrevList      -7011
#define List00_EmptyList          -7012
#define List00_AttrNotOfObjCestrs  7013
#define List00_InvalidListHead     7014
#define List00_GRPisFrosted        7015
#define List00_DirCorrupted        7016
#define List00_DuplicateSetName    7017
#define  Set_EmptySet           -10008
#define  Set_EndOfSet           -10009
#define  Set_Found              -10010
#define  Set_NotFound            10011
#define  Set_BadSet              10012
#define  Set_AlreadyInSet        10013
#define  Set_LessThen           -10014
#define  Set_GtrThen            -10015
#define  Set_InSerted           -10016
#define  Set_IndexGtrAllocRoots  10017
#define  Set_StartOfSet         -10020
#define  Set_AddInto             10025
#define  Set_KeyFound            10026
#define  Set_NullKeyName         10027
#define  Set_OutOfRange          10028
#define  Set_IllegalKeyType      10029
#define  Set_IllegalKeyString    10030
#define  Key_UnmatchedDirIndex   10031
#define  Key_DuplicateSetName    10032
#define Set_2aryKeyExpected      10033
#define  Tree_GRPisFrosted       10040
#define  Tree_UnmatchedDirIndex  10041
#define  Tree_DuplicateSetName   10042
#define  Tree_UnmatchedParent    10043
#define  Tbl_GRPisFrosted        10050
#define  Tbl_UnmatchedDirIndex   10051
#define  Tbl_DuplicateSetName    10052
#define  Mtrx_Mated              10100
#define  Mtrx_NullRowHead        10101
#define  Mtrx_NullColHead        10102
#define  Mtrx_NullMateNode       10103
#define  Mtrx_OutOfRange         10104
#define  Mtrx_AlreadyMated       10105
#define  Mtrx_GRPisFrosted       10106
#define  Mtrx_NotMated           10107
#define  Mtrx_NullPointNode      10108
#define  Mtrx_NotInRange        -10109
#define  Mtrx_EndOfRange        -10110
#define  Mtrx_NullFirstMate      10111
#define  Mtrx_UnmatchedDirIndex  10112
#define  Mtrx_DuplicateSetName   10113
#define  Mtrx_NullMatrix         10114
#define  Matrix_RowColSetsUnMatched 10115
#define  Stack_UnmatchedDirIndex 10121
#define  Stack_DuplicateSetName  10122
#define  Vchunk_NotSameUnitSize  11100
#define  Vchunk_NullToken        11101
#define  File_BadDiskWrite       12000
#define  File_BadDiskRead        12001
#define  File_BadFilePtr         12002
#define  File_WrongAccessType    12003
#define  File_NotFound           12004
#define  File_BlksNotContiguous  12005
#define  File_WontOpen           12006
#define  File_NoName             12007
#define  File_ZeroFileBlkSize    12008
#define  File_ResolveBlkBoundary 12009
#define  File_BadDiskSeek        12010
#define  File_BytesSizeExceeded  12011
#define  File_DbWasNotCommitted  12012
#define  DBM_OvlDbHdr           -13001
#define  Dbm_ObjHdrNotExist      13002
#define  Dbm_RgnBlkNotLoaded    -13003
#define  Dbm_GrpHdrNotExist      13004
#define  Dbm_GrpNullSwapAddr     13005
#define  Dbm_NullGrpHdrDirVbn    13006
#define  Dbm_BadHandleInRegion   13007
#define  Odbm_BadSwapChunks      13011
#define  Code_NotAnObjDesc       14001
#define  Code_ClassNotMember     14013
#define  Kernl_IamNot            15000
#define  Iterate_Begin          -16000
#define  Iterate_EndOf          -16001
#define  XmemBlk_GapSpace  64
#define  Dbe_Dbe                 -202
#define  Dbe_Init                -203
#define  Oa_NullClassId          5072
#define  ValidAddr(Address)  (Address != PtrToVoid && Address != NullPtr)
#define  McFZ
#define  McStat           0,0,Status
#define  McStatPtr        0,0,&Status
#define  ShellMcStat      0,0,&ShellStatus
#define  ViStruc_McStat   0,0,&ViStruc->Status
#define  Dump_Status      0,0,&DumpStatus
#define  Normal(Status)   (Status == Env_Normal)
#ifdef  DEBUG
#define TREE_TIME
#undef  TREE_TIME
#define TREE_BUG
#undef  __MACROIZE_MEM__
#endif
#ifdef MCSTAT
#ifdef DEBUG
#define  STAT (Test= *Status == 0 ? \
Ut_VoidTrack (F, Z, Status) : Ut_PrintErr(F, Z, *Status))
#define TRACKBACK
#else
#define  STAT (Test= *Status == 0 ?  True : Ut_PrintErr(F, Z, *Status))
#endif
#ifdef TRACKBACK
#define  TRACK(string1,string2)     if(*Status) strcpy(string1,string2)
#else
#define  TRACK(string1,string2)
#endif
#define  SHELL_STAT (Test= ShellStatus == 0 ? \
True : PrintErr(__FILE__, __LINE__, ShellStatus))
#else
#ifdef  DEBUG
#define  STAT (Test= *Status == 0 ? \
Ut_VoidTrack (NULL, 0, Status) : Ut_PrintErr(NULL, 0, *Status))
#define TRACKBACK
#else
#define  STAT (Test= *Status == 0 ?  True : Ut_PrintErr (F, Z, *Status))
#endif
#define  SHELL_STAT (Test= ShellStatus == 0 ? \
True : False)
#endif
#define  TEST_STAT (Test= *Status == 0 ? \
True : Ut_PrintErr(__FILE__, __LINE__, *Status))
#ifdef TRACKBACK
#define  TRACK(string1,string2)       if(*Status) strcpy(string1,string2)
#else
#define  TRACK(string1,string2)
#endif
#define  NullTerminateString(str) \
{int i=0; while((str[i]) != '@') && (str[i] != NULL)) i++; str[i] = NULL;}
//#endif
/* 当前文件是./CINT2000\255.vortex\src\typedefs.h*/

#ifndef TYPEDEFS_01
#define TYPEDEFS_01
typedef  void              *AddrType;
typedef  void              *voidptr;
#if defined(SPEC_CPU2000_LP64) || defined(SPEC_CPU2000_P64)
typedef  int                lt64;
typedef  unsigned int       FarLongType;
#else
typedef  long               lt64;
typedef  unsigned long      FarLongType;
#endif
typedef  size_t             longaddr;
typedef  FarLongType        farlongtype;
typedef  char            *cstringtype;
typedef  cstringtype      cstring;
typedef  char             nametype[MAXNAME];
typedef  unsigned char    bitfieldtype;
typedef  unsigned char    bittype;
typedef  bittype          BitType;
typedef  bittype          BitArray[];
typedef  unsigned char    bytetype;
typedef  bytetype         ByteType;
typedef  ByteType         byte;
typedef  ByteType         ByteArray[];
#ifdef TWOBYTE_BOOL
#ifdef ONEBYTE_BOOL
typedef  unsigned char    twobytetype[3];
#else
typedef  unsigned char    twobytetype[2];
#endif
#endif
typedef  char             sbytetype;
typedef           short   shorttype;
typedef  unsigned short   unshorttype;
#ifdef LARGE
typedef  unshorttype      idtype;
typedef  unshorttype      id;
typedef  unsigned int     wordtype;
#define MAX_UNIT_LENGTH   999999L
#else
typedef  bytetype         idtype;
typedef  bytetype         id;
typedef  unsigned short   wordtype;
#define MAX_UNIT_LENGTH   64000
#endif
typedef  wordtype         word;
typedef  wordtype         WordType;
typedef  wordtype         numtype;
typedef  wordtype         bytessizetype;
typedef  wordtype         bytessize;
typedef  wordtype         sizeinbytestype;
typedef  wordtype         sizeinbytes;
typedef  wordtype         sizeinblockstype;
typedef  wordtype         sizeinblocks;
typedef  wordtype         sizetype;
typedef  wordtype         size;
typedef  wordtype         typesizetype;
typedef  wordtype         typesize;
#ifdef LARGE
typedef  int              typeunsize;
#else
typedef  short            typeunsize;
#endif
typedef  wordtype         regionoffsettype;
typedef  wordtype         regionoffset;
typedef  numtype          num;
typedef  numtype          objnumtype;
typedef  numtype          objnum;
typedef  numtype          vbntype;
typedef  numtype          vbn;
typedef  numtype          localnumtype;
typedef  numtype          localobjnum;
typedef  numtype          localattrtype;
typedef  numtype          localattrnum;
#ifdef LARGE
typedef  int              swordtype;
#else
typedef  short            swordtype;
#endif
typedef  swordtype        SWordType;
typedef  swordtype        counttype;
typedef  swordtype        CountType;
typedef  counttype        count;
typedef  counttype        CountArray[];
typedef  swordtype        sword;
typedef  wordtype         indextype;
typedef  indextype        IndexType;
typedef  indextype        IndexArray[];
typedef  swordtype        sindextype;
typedef  int              inttype;
typedef  farlongtype      longtype;
typedef  longtype         LongType;
typedef  farlongtype      longwordtype;
typedef  double           doubletype;
typedef  AddrType         addrtype;
typedef  addrtype         addr;
typedef  addrtype         AddrArray[];
typedef  enum             TypeBoolean
{False,         True,   aNonBool=EXT_ENUM }
booleantype;
typedef  booleantype      boolean;
typedef  int              statustype;
#ifdef MCSTAT
typedef  char            *ft;
#else
typedef  unsigned int     ft;
#endif
typedef  unsigned int     lt;
typedef  statustype       zz;
typedef  numtype          chunknumtype;
typedef  chunknumtype     chunknum;
typedef  vbntype          regionnumtype;
typedef  regionnumtype    regionnum;
typedef  indextype        chunkindextype;
typedef  indextype        chunkindex;
typedef  indextype        regionindextype;
typedef  regionindextype  regionindex;
typedef  chunkindextype   handletype;
typedef  struct           TypeToken
{
handletype      Handle;
idtype          DbId;
idtype          CoreDbId;
}                         tokentype;
typedef  tokentype        dbchunktkntype;
typedef  tokentype       *tokenptr;
typedef  struct           TypeQuad
{
handletype      Lower;
handletype      Upper;
}                         QuadType;
typedef  handletype       strhandletype;
typedef  strhandletype    strhandle;
typedef  struct           TypeStrToken
{
tokentype       Token;
strhandletype   StrHandle;
}                         strtokentype;
typedef  strtokentype     strtoken;
typedef  regionindextype  fieldindextype;
typedef  fieldindextype   fieldindex;
typedef  regionoffsettype fieldoffsettype;
typedef  fieldoffsettype  fieldoffset;
typedef  struct           TypeFldToken
{
fieldindextype  Index;
fieldoffset     Offset;
}                         FldTokenType;
typedef  FldTokenType     fieldtokentype;
typedef  fieldtokentype   fieldtoken;
typedef  struct           TypeFieldSpec
{
indextype       AttrId;
indextype       Index;
}                         fieldspectype;
typedef  fieldspectype    fieldspec;
typedef  struct           TypeFieldStruc
{
char            FieldName[128];
fieldspec      *FieldTkns;
indextype       SubLevel;
boolean         IsIndexed;
}                         fieldstructype;
typedef  fieldstructype   fieldstruc;
typedef struct            TypeBlkTkn
{
farlongtype     Offset;
indextype       Owner;
}                         blktkntype;
typedef  struct           TypeDbmsString
{
bytessizetype   Size;
booleantype     IsaString;
#ifdef TWOBYTE_BOOL
twobytetype     FieldExtender01;
#endif
	union           string_or_int
{
handletype   StringValue;
longtype     IntValue;
	}                      Value;
}                         dbmsstringtype;
typedef  dbmsstringtype   dbmsstring;
typedef char             *varyingtype;
typedef struct            TypeRefTkn
{
farlongtype     FieldNum;
indextype       CppAlign;
}                         reftkntype;
typedef struct            TypeItrator
{
numtype         SeqNum;
numtype         LocalObjNum;
tokentype       CurrentTkn;
}                         itrator;
typedef  void   *(*funcptrtype)    (void);
typedef void     (*dumpentryptr)   (addrtype      Entry);
typedef boolean  (*ptr_func)       (addrtype      Object);
typedef int      (*ptr_cmp )       (addrtype      Value,    addrtype   Object);
typedef boolean  (*iteratetype )   (tokentype    *MemberTkn,indextype  ItNum,
ft F,lt Z,zz *Status);
typedef boolean  (*treeiterfunc)   (tokentype    *Token,    indextype  ItNum,
ft F,lt Z,zz *Status);
typedef int      (*ptr_TblCompare) (char         *Value1,   char      *Value2);
typedef ptr_TblCompare    tblcompfunc;
typedef enum              TypeTypeTypeDesc
{aString,      aInteger,      aReal,         aLink,
aEnum,        aBoolean,      aChunk,        aDbmsString,
aValue,       aAddr,         aRefObj,
aNonTypeType=EXT_ENUM }
typetype;
typedef enum              TypeValueClassType
{aVoid,
aBitField,  aChar,         aUnChar,
aShort,     aUnShort,      aInt,          aUnInt,
aLong,      aUnLong,       aQuad,         aOctet,
aVoidPtr,   aFloat,        aDouble,
aEnumType,  aStruct,       aUnion,
aComplex,   aObject,       aOid,   aNonValueClass=EXT_ENUM}
valueclasstype;
typedef valueclasstype    valueclass;
typedef enum              TypeAttrType
{aAttr,         aObjRefAttr,   aMapRefAttr,   aPortRefAttr,
aTknRefAttr,   aStrHndlAttr,
aSetHeadAttr,  aSetNodeAttr,
aMtrxHeadAttr, aRowHeadAttr,  aColHeadAttr,
aMateNodeAttr, aPointNodeAttr,
aSlotHndlAttr, aSlotTokenAttr,
aChunkAttr,    aVchunkAttr,
aArrayAttr,    aVarrayAttr,   aDblPtrAttr,
aGrpAttr,      aVgrpAttr,
aNonTypeAttr=EXT_ENUM      }             attrtype;
typedef enum              TypeCppAttrType
{aPublic,      aPrivate,      aProtected, aNonCppAttr=EXT_ENUM}
cppattrtype;
typedef enum              TypeDeleteType
{dbFree,       dbCommit,      dbDelete,   aNonDelete=EXT_ENUM}
deletetype;
typedef enum              TypeDbPutType
{Put_NoFree,   Put_Release,   Put_Deep,   aNonDbPut=EXT_ENUM}
dbputtype;
typedef enum              KeyedSetType
{aKeyedSet,    aMtrxHeadSet,  aNonKeyedSet=EXT_ENUM}
keyedsettype;
typedef enum              ComparisonOpType
{aEQ,                aLT,           aGT,
aGTE,               aLTE,          aNEQ,
aModEQ0,            aNonCompareOp=EXT_ENUM   } compareoptype;
typedef compareoptype     compareop;
typedef struct            TypeClassMapType
{
handletype        Handle;
numtype           ObjNum;
indextype         NumMapFields;
indextype         NumArrayAttrs;
typesize          ClassSize;
typesize          ImageSize;
boolean           PureDbStruc;
indextype         ThatIndex;
typesize         *DbOffsets;
typesize         *CppOffsets;
typesize         *FieldSizes;
attrtype         *FieldAttrTypes;
numtype          *FieldAttrIds;
numtype          *RefObjNums;
numtype          *ArrayAttrs;
typetype         *FieldTypeTypes;
}                         classmaptype;
typedef classmaptype      classmap;
typedef struct            TypePortMapType
{
handletype        Handle;
numtype           ObjNum;
typesize          ImageSize;
indextype         FieldCount;
numtype          *FieldAttrIds;
attrtype         *FieldAttrTypes;
typetype         *FieldTypeTypes;
sizetype         *FieldSizes;
numtype          *FieldRefObjNums;
sizetype         *VfieldUnitSizes;
indextype        *VfieldUnitCounts;
sizetype          PortImageSize;
sizetype          MapTokenSize;
indextype         AttrCount;
numtype          *PortFields;
sizetype         *PortOffsets;
addrtype          PortMapTkns;
funcptrtype       ExportCode;
funcptrtype       ImportCode;
}                         portmaptype;
typedef void             *foidtype;
typedef struct            TypeChunkStruc
{
numtype           CRC;
bytessize         UnitSize;
indextype         UnitCount;
indextype         StackPtr;
numtype           StringText;
sizeinbytes       MaxUnitLength;
indextype         ExtendQty;
valueclass        UnitType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
}                         chunkstruc;
typedef chunkstruc        vchunkstruc;
typedef tokentype         vchunktoken;
typedef tokentype         grptype;
typedef tokentype         vgrptype;
typedef numtype           vchunknum;
typedef numtype           grpnum;
typedef numtype           vgrpnum;
typedef struct            prttypetype
{
		unsigned int  Low;
		unsigned int  High;
}                         prttype;
typedef	 union prtaddrtype
{
		prttype       Parts;
addrtype      Address;
}                         prtaddr;
#define Prt_Addr(Addr) (printf("%X:%X", Addr.Parts.High, Addr.Parts.Low))
typedef enum              TypeAccessType
{Read_Write,     Shared_Write,
Read_Only,      No_Access,       Unknown_Access=EXT_ENUM }
accesstype;
typedef accesstype        dbaccesstype;
typedef  enum             TypeFileAccess
{R,              W,               B,   aNonFileAccess=EXT_ENUM}
fileaccesstype;
typedef  FILE            *FilePtrType;
typedef  FilePtrType      filetokentype;
typedef  enum             TypeDbeFile
{aHistoryType,   aInputType,      aNonDbeFile=EXT_ENUM}
DbeFileType;
typedef  char             filename[MAXPATHNAME];
typedef struct            TypeFileIndex
{
count            SeqNum;
count            OffSet;
count            Size;
}                         FileIndexType;
typedef struct            TypeRecIndex
{
count            SeqNum;
count            Size;
}                         RecIndexType;
//ifdef UT
boolean      SWAP                   = False;
boolean      DO_NOT_CREATE          = False;
boolean      FREEZE_GRP_PACKETS     = False;
longtype     VOID_BOUNDARY          = 20000000L;
longtype     VOID_RESERVE           =  1000000L;
char        *BoolStr[2]             = { "False",      "True" };
char        *DbAccessStr[5]         = { "Read_Write", "Shared_Write",
"Read_Only",  "No_Access",
"Unknown_Access" };
char        *AplStr[3]              = { "ASM", "'C'", "'C++'" };
char        *DeleteStr[3]           = { "dbFree",     "dbCommit",
"dbDelete" };
tokentype    NullToken              = {0, 0, 0};
handletype   NullHandle             = 0;
idtype       NullDbId               = 0;
numtype      NullObjNum             = 0;
char        *NullStr                = {"\0"};
addrtype     NullAddr               = NULL;
boolean      Test                   = True;
count        Trace1                 = 0;
boolean      CppSyntax              = False;
boolean      CoreBug                = False;
boolean      Core0Bug               = False;
boolean      Core1Bug               = False;
boolean      PageBug                = False;
boolean      SwapBug                = False;
boolean      ChunkBug               = False;
boolean      MemBug                 = False;
boolean      GrpBug                 = False;
boolean      FileBug                = False;
boolean      DbmBug                 = False;
boolean      LexBug                 = False;
boolean      StackBug               = False;
boolean      OaBug                  = False;
boolean      SetBug                 = False;
boolean      MtrxBug                = False;
boolean      ClassBug               = False;
boolean      AdminBug               = False;
boolean      ListBug                = False;
boolean      LibBug                 = False;
numtype      QueBug                 = 100;
int          DeBug                  = 0;
int          DeBug0                 = 0;
int          DeBug1                 = 0;
char         TrackBak[MAXLINE]      = "Env_Normal\n";
char         Msg[256]               = " ";
static sizetype     MsgMaxIndex            = 255;
boolean      WriteHdr               = False;
boolean      Print_Msg              = False;
sizetype     Byte_Alignment          = 1;
sizetype     Byte2Alignment         = 1;
sizetype     Byte4Alignment         = 1;
sizetype     Byte8Alignment         = 1;
sizetype     BytePtrAlignment       = 1;
sizetype     StrucAlignment         = 1;
sizetype     CppAlignment           = 1;
char        *AccessStr[5]           = { "Read_Write", "Shared_Write",
"Read_Only",  "No_Access",
"Unknown"                    };
char        *CompareOpName[7]       = {"aEQ",      "aLT",   "aGT",
"aGTE",     "aLTE",  "aNEQ",
"aModEQ0" };
//#else

//#endif

boolean      Renv_Modified          = False;
boolean      Build_Env              = False;
boolean      Admin_Run              = False;
boolean      Dbe_Run                = False;
boolean      Dri_Env                = False;
boolean      Install_Env            = False;
boolean      Reload_Env             = False;
boolean      Reload_Wenv            = False;
boolean      Commit_Env             = False;
boolean      Create_Wenv            = False;
boolean      Gen_Shell              = False;

/**/
tokentype        FirstRect  = Null_Token;
numtype    LibRectangles_Set        = 0;
numtype    OwnerLibRectangles_Attr  = 0;
numtype    MemberLibRectangles_Attr = 0;
numtype    DrawObjs_Set           = 0;
numtype    OwnerDrawObjs_Attr     = 0;
numtype    MemberDrawObjs_Attr    = 0;
numtype    NamedDrawObjs_Set        = 0;
numtype    OwnerNamedDrawObjs_Attr  = 0;
numtype    MemberNamedDrawObjs_Attr = 0;
numtype    DrawObjDir_Attr        = 0;
numtype    VdrawObjDir_Attr       = 0;
numtype    VpartsDir_Attr         = 0;
numtype    Id_Attr                = 0;
numtype    Nam_Attr               = Nam_AttrNum;
numtype    VlinksDir_Attr         = 0;
numtype    VpartLinkDir_Attr      = 0;
numtype    DrawPart_Tupl          = 0;
numtype    DrawObj_Slot           = 0;
numtype    PartObj_Slot           = 0;
numtype    xCoord_Attr            = 0;
numtype    yCoord_Attr            = 0;
numtype    Theta_Attr             = 0;
numtype    Radius_Attr            = 0;
numtype    Origin_Attr            = 0;
numtype    Extent_Attr            = 0;
numtype    XyOrigin_Attr          = 0;
numtype    XyExtent_Attr          = 0;
numtype    PortHole_Attr          = 0;
numtype    PortId_Attr            = 0;
numtype    MemberAplPorts_Attr    = 0;
numtype    Port_XyOrigin_Attr     = 0;
numtype    Port_XyExtent_Attr     = 0;
numtype    Xarray_Attr            = 0;
numtype    Yarray_Attr            = 0;
numtype    xVarray_Attr           = 0;
numtype    yVarray_Attr           = 0;
numtype    Xcoords_Attr           = 0;
numtype    Ycoords_Attr           = 0;
numtype    XyCoords_Attr          = 0;
numtype    XyDir_Attr             = 0;
numtype    Name_Attr              = 0;
numtype    RefOrigin_Attr         = 0;
numtype    RefExtent_Attr         = 0;
numtype    DrawId_Attr            = 0;
numtype    Point_Class            = 0;
numtype    CartesianPoint_Class   = 0;
numtype    PolarPoint_Class       = 0;
numtype    DrawObj_Class          = 0;
numtype    NamedDrawObj_Class     = 0;
numtype    Rectangle_Class        = 0;
numtype    DrawLib_Class          = 0;
numtype    XyPoint_Class          = 0;
numtype    XyRect_Class           = 0;
numtype    NamedXyRect_Class      = 0;
numtype    ArrayRect_Class        = 0;
numtype    VarrayRect_Class       = 0;
numtype    IntChunkRect_Class     = 0;
numtype    DblPtrRect_Class       = 0;
numtype    VchunkRect_Class       = 0;
numtype    PortRect_Class         = 0;
numtype    AplObj_Class           = 0;
numtype    PortObj_Class          = 0;
numtype    RefRect_Class          = 0;
numtype    DbmsToken_Class        = 0;
numtype     TestObj_Class                 = 0;
numtype     Char_Scalar_Attr              = 0;
numtype     Char_InStruct_Attr            = 0;
numtype     Char_Array_Attr               = 0;
numtype     Char_PtrArray_Array_Attr      = 0;
numtype     Short_Scalar_Attr             = 0;
numtype     ShortU_Scalar_Attr            = 0;
numtype     Int_Scalar_Attr               = 0;
numtype     IntU_Scalar_Attr              = 0;
numtype     Long_Scalar_Attr              = 0;
numtype     LongU_Scalar_Attr             = 0;
numtype     Float_Scalar_Attr             = 0;
numtype     Double_Scalar_Attr            = 0;
numtype     Token_Scalar_Attr             = 0;
numtype     Handle_Scalar_Attr            = 0;
numtype     Void_Ptr_Attr                 = 0;
numtype     Color_Attr                    = 0;
numtype     IsActive_Attr                 = 0;
numtype     xArray07_Attr                 = 0;
numtype     Points_Attr                   = 0;
numtype     Char_String_Attr              = 0;
numtype     Byte_Array_Attr               = 0;
numtype     BitMap_Attr                   = 0;
numtype     Connection_Class              = 0;
numtype     link_Attr                     = 0;
numtype     to_Attr                       = 0;
numtype     type_Attr                     = 0;
numtype     length_Attr                   = 0;
numtype     VconnectsDir_Attr             = 0;
numtype    Person_Class           = 0;
numtype    PersonId_Attr          = 0;
numtype    LastName_Attr          = 0;
numtype    FirstName_Attr         = 0;
numtype    Gender_Attr            = 0;
numtype    Residence_Attr         = 0;
numtype    InputDate_Attr         = 0;
numtype    InputTime_Attr         = 0;
numtype    BirthDate_Attr         = 0;
numtype    MaritalStatus_Attr     = 0;
numtype    PersonalAssoc_Attr     = 0;
numtype    Children_Attr          = 0;
numtype    Address_Class          = 0;
numtype    OwnerTkn_Attr          = 0;
numtype    AddressType_Attr       = 0;
numtype    Street_Attr            = 0;
numtype    Suite_Attr             = 0;
numtype    City_Attr              = 0;
numtype    District_Attr          = 0;
numtype    State_Attr             = 0;
numtype    Country_Attr           = 0;
numtype    ZipCode_Attr           = 0;
numtype    Phone_Attr             = 0;
numtype    Fax_Attr               = 0;
numtype    PersonParts_Set        = 0;
numtype    OwnerPersonParts_Attr  = 0;
numtype    MemberPersonParts_Attr = 0;
/* 当前文件是./CINT2000\255.vortex\src\ut.h*/

#ifndef UT_01
#define UT_01

static char         III[9]                 = "VORTEx ";
voidptr      PtrToVoid              = (voidptr )&III;
static char         TrackBack              = 1;
static boolean      Watch_Set              = False;
static boolean      Break_Set              = False;
static char        *WatchAddr              = NullPtr;
static sizetype     WatchSize              = NullPtr;
static char         WatchWord[MAXLINE]     = " ";

#define        PrintErr            Ut_PrintErr
#define        SetBreak            Ut_SetBreak
#define        SetWatch            Ut_SetWatch
#define        StopWatch           Ut_StopWatch
#define        VoidTrack           Ut_VoidTrack
#define        PrintTrack          Ut_PrintTrack
#define        StackTrack          Ut_StackTrack
#define        TraceMsg            Ut_TraceMsg
#define        SendMsg             Ut_SendMsg
#define        TraceBytes          Ut_TraceBytes
#define        TraceField          Ut_TraceField
#define        AlignMember         Ut_AlignMember
#define        AlignStruc          Ut_AlignStruc
#define        StrToUpper          Ut_StrToUpper
#define        StrToLower          Ut_StrToLower
void    Ut_SetBreak
(boolean       Break);
boolean Ut_SetWatch
(addrtype      VoidAddr,  sizetype      WordSize);
boolean Ut_StopWatch
(addrtype      VoidAddr);
boolean Ut_VoidTrack
(ft F,lt Z,zz *Status);
void    Ut_StackTrack
(char         *ProgNam);
boolean Ut_PrintErr
(ft F,lt Z,zz  Status);
boolean Ut_TraceMsg
(int           TraceLevel,char         *Line);
boolean Ut_SendMsg
(int           MsgLevel,  char         *Line);
boolean Ut_TraceBytes
(int           TraceLevel,addrtype      SomeBytes,
sizetype      Size);
boolean Ut_TraceField
(int           TraceLevel,addrtype      FieldAddr,
sizetype      Size,      typetype      Type);
boolean Ut_TraceValue
(int           TraceLevel,addrtype      Value,
valueclass    ValueClass,sizetype      ValueSize,
numtype       ValueObj);
char   *Ut_StrToUpper
(char         *pc);
char   *Ut_StrToLower
(char         *pc);
void    Ut_ReverseStr
(char          Str[]);
void    Ut_IntToStr
(int           IntNum,    char          Str[]);
boolean Ut_FindInList
(char         *Word,      char        **List,
numtype       MaxList,   int          *Index);
boolean Ut_CompareWild
(char         *VarValue,  compareop     CompOp,
char         *WildSpec,  ft F,lt Z,zz *Status);
int     Ut_CompareString
(char         *CompValue, char         *ValuePtr);
int     Ut_Random ( void );
#ifndef CORE_01
#define        MoveBytes           Ut_MoveBytes
#define        CompareBytes        Ut_CompareBytes
void    Ut_MoveBytes
(addrtype      Source,    addrtype      Target,
bytessize     ByteCount);
int     Ut_CompareBytes
(addrtype      Source,    addrtype      BytesAddr,
bytessizetype ByteCount, ft F,lt Z,zz *Status);
#endif
boolean  Ut_PrintTrack
(ft F,lt Z);
void     Ut_AlignMember
(typetype      Type_Type,
sizetype      Size,      sizetype     *Offset);
void     Ut_AlignStruc
(sizetype     *Offset);
#ifndef CORE_01
#define        VoidExtendCore      Void_ExtendCore
#define        VoidFreeCore        Void_FreeCore
addrtype
VoidExtendCore
(farlongtype  *SizeInBytes);
void    VoidFreeCore
(addrtype     *CoreAddr,  farlongtype   SizeInBytes);
#define        Core0_FreeCore      Core0_FreeCoreSpace
boolean Core0_MoreCore
(bytessizetype Size,
ft F,lt Z,zz *Status,    addrtype     *Addr);
boolean Core0_FreeCoreSpace
(addrtype     *CoreAddr,  bytessize     SizeInBytes,
ft F,lt Z,zz *Status);
#endif
#endif
#endif
/* 当前文件是./CINT2000\255.vortex\src\files.h*/

#ifndef FILES_H
#define FILES_H
char           UserName[MAXNAME]      = "SCAN";
char           InFileName[MAXNAME]    = " ";
FilePtrType    InFilePtr              = NullPtr;
DbeFileType    InFileType             = aHistoryType;
FilePtrType    MsgFilePtr             = NullPtr;
FilePtrType    OutFilePtr             = NullPtr;
FilePtrType    XmemFilePtr            = NullPtr;
char           MsgFile[MAXNAME]       = " ";
char           OutFile[MAXNAME]       = " ";
char           XmemFile[MAXNAME]      = " ";
FilePtrType    LogFilePtr             = NullPtr;
FilePtrType    DiskFilePtr            = NULL;
FilePtrType    TmpFilePtr             = NullPtr;
FilePtrType    EnvFilePtr             = NullPtr;
char           LogFile[MAXNAME]       = " ";
char           DiskFile[MAXNAME]      = " ";
char           DbeDbName[MAXNAME]     = " ";
char           DbFileName[MAXNAME]    = "Renv.db";
#define  SetInFile(Iread) (InFilePtr = Iread)
#endif
/* 当前文件是./CINT2000\255.vortex\src\core01.h*/

#ifndef CORE_01
#define CORE_01
typedef struct TypeCorePageSpace
{
addrtype       CoreAddr;
farlongtype    FreeSize;
}                         pagespacetype;
static   numtype       KrnlFreeAddrChunk          = 0;
static   addrtype     *KrnlFreeAddr               = NullPtr;
static   addrtype     *KrnlFreeAddr0              = NullPtr;
static   numtype       KrnlFreeSizeChunk          = 0;
static   numtype      *KrnlFreeSize               = NullPtr;
static   numtype       KrnlChunkUnits             = 0;
static   indextype     KrnlHeadFreeGaps           = 0;
static   numtype       Regions                    = 0;
static   count         Num1Regions                = 0;
static   addrtype      CoreBlock01                = NullPtr;
static   farlongtype   Core_PageSize              = CorePage_Size;
static   farlongtype   Core_MaxEntrySize          = CorePage_Size;
static   farlongtype   Core1BlockElems            = 0;
static   addrtype      CoreBlock1                 = NULL;
static   addrtype      CoreBlock1Base             = NULL;
static   farlongtype   CurrBlock1Size             = 0;
static   count         Core1Blocks                = 0;
static   pagespacetype PageSpace[100];
static   booleantype   FirstTry                   = True;
static   farlongtype   Alloc_Amount               = sizeof (int)
== 2 ? 512000L : 1024000L;
static   farlongtype   CoreFreeStoreSize          = (farlongtype )0;
static   addrtype      VoidLowestAddr             = NullPtr;
static   farlongtype   VoidAllocated              = (farlongtype )0;
static   farlongtype   VoidDeAllocated            = (farlongtype )0;
static   farlongtype   VoidUsed                   = (farlongtype )0;
static   farlongtype   VoidMaxUsed                = (farlongtype )0;
static   farlongtype   VoidBlksAllocated          = (farlongtype )0;
static   farlongtype   VoidBlksDeAllocated        = (farlongtype )0;
static   farlongtype   CoreBlksRequested          = (farlongtype )0;
static   farlongtype   CoreBlksFreeed             = (farlongtype )0;
static   farlongtype   CoreBlksReclaimed          = (farlongtype )0;
static   farlongtype   CoreBlksExactReclaimed     = (farlongtype )0;
static   farlongtype   CoreBlksGapReclaimed       = (farlongtype )0;
static   farlongtype   CoreBlksPageSpaceReclaimed = (farlongtype )0;
static   farlongtype   CoreBlksReGapped           = (farlongtype )0;
static   farlongtype   Core1Size                  = 0;
static   farlongtype   Core1Freeed                = (farlongtype )0;
static   farlongtype   Core1Reclaimed             = (farlongtype )0;
static   farlongtype   Core1Used                  = (farlongtype )0;
farlongtype   CoreBlk_GapSpace           = (farlongtype )64;

#define VoidExtendCore           Void_ExtendCore
#define VoidFreeCore             Void_FreeCore
#define SysFarCoreLeft           Void_SysFarCoreLeft
#define CoreShowStats            Core_ShowStats
#define CoreMoreCore             Core_MoreCore
#define Core0MoreCore            Core0_MoreCore
#define CoreFreeCoreSpace        Core_FreeCoreSpace
#define Core0FreeCoreSpace       Core0_FreeCoreSpace
#define Core0_FreeCore           Core0_FreeCoreSpace
#define CoreAddGap               Core_AddGap
#define CoreGetFreeSpace         Core_GetFreeSpace
#define CoreGetPageSpace         Core_GetPageSpace
#define CoreGetGapSpace          Core_GetGapSpace
#define CoreReGap                Core_ReGap
#define CoreReGapFreeAddrs       Core_ReGapFreeAddrs
#define CoreMoveBytes            Core_MoveBytes
#define MoveBytes                Ut_MoveBytes
#define CompareBytes             Ut_CompareBytes
addrtype
VoidExtendCore (farlongtype  *SizeInBytes);
void    VoidFreeCore   (addrtype *CoreAddr,  farlongtype SizeInBytes);
farlongtype
SysFarCoreLeft (void);
void    Core_SetPageSize
(farlongtype   PageSize,
farlongtype   MaxEntrySize);
void    Core_AssignChunks
(numtype       AddrChunk, addrtype *FreeAddrs,
numtype       SizeChunk, numtype  *FreeSizes);
void    CoreShowStats  (void);
boolean CoreMoreCore   (bytessizetype Size,
ft F,lt Z,zz *Status,    addrtype *Addr);
boolean Core0MoreCore  (bytessizetype Size,
ft F,lt Z,zz *Status,    addrtype *Addr);
boolean CoreFreeCoreSpace
(addrtype     *CoreAddr,  bytessize SizeInBytes,
ft F,lt Z,zz *Status);
boolean Core0FreeCoreSpace
(addrtype     *CoreAddr,  bytessize SizeInBytes,
ft F,lt Z,zz *Status);
boolean Core0_AllocString
(sizetype      StrSize,
ft F,lt Z,zz *Status,    char        **String);
boolean Core0_FreeString
(char         *String,    ft F,lt Z,zz *Status);
void    MoveBytes      (addrtype      Source,    addrtype  Target,
bytessize     ByteCount);
int     CompareBytes   (addrtype      Source,    addrtype  CmpVal,
bytessize     ByteCount,
ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\domain.h*/

#ifndef DOMAIN01_H
#define DOMAIN01_H
#ifdef  Alloc_Grps
#undef  Alloc_Grps
#undef  Extend_Grps
#endif
#ifdef  Alloc_TxtTkns
#undef  Alloc_TxtTkns
#undef  Extend_TxtTkns
#endif

indextype    Alloc_Vchunks          = 1801;
indextype    Extend_Vchunks         = 200;
static indextype    Alloc_Grps             = 100;
static indextype    Extend_Grps            = 20;
static indextype    Alloc_TxtTkns          = 0;
static indextype    Extend_TxtTkns         = 0;
indextype    Alloc_Handles          = 10000;
indextype    Extend_Handles         = 1000;
indextype    Alloc_SwapHandles      = 20;
indextype    DbXmemBlocks_AllocQty  = 6000;
indextype    DbXmemBlocks_ExtendQty = 1000;
boolean      Align_Bytes            = False;
boolean      Align_CppStruc         = False;

typedef     enum    {               Domaya,         Shelldom,
Objdom,         Coredom,        Kingdom,
EmminentDomain, VirtualDomain,  VirtualImage,
III_View,       ManifestView,   aNonKeydom=EXT_ENUM }
keydomtype;
typedef     enum    {               IOdomdom,       Knight,
Bishop,         CastleKeep,     PrimeMinister,
InvisibleKing,  Sourceeror,     Artesian,
Manifest,       UnManifest,     aNonPatronage=EXT_ENUM }
patronage;
#define  EnvImplodeVoid            Domain_ImplodeMemory
#define  ImplodeMemory             Domain_ImplodeMemory
#define  EnvBeHereNow              Domain_BeHereNow
#define  BeHereNow                 Domain_BeHereNow
#define  EnterDomain               Domain_Enter
#define  ExitDomain                Domain_Exit
#ifdef DOMAIN01
boolean Domain_ImplodeMemory
(ft F,lt Z,zz *Status);
boolean Domain_BeHereNow
(ft F,lt Z,zz *Status);
#endif
boolean Domain_MmiInvoke
(char         *Dat_File,         char         *Msg_File,
char         *Out_File,         char         *Xmem_File,
farlongtype   CorePageSize,     farlongtype   CoreMaxOnPage,
indextype     AllocFreeAddrs,   indextype     ExtendFreeAddrs,
indextype     AllocChunks,      indextype     ExtendChunks,
indextype     AllocXmemBlocks,  indextype     ExtendXmemBlocks,
ft F,lt Z,zz *Status);
boolean Domain_Omi0Invoke
(char         *Dat_File,         char         *Msg_File,
char         *Out_File,         char         *Mem_File,
farlongtype   CorePageSize,     farlongtype   CoreMaxOnPage,
indextype     AllocFreeAddrs,   indextype     ExtendFreeAddrs,
indextype     AllocChunks,      indextype     ExtendChunks,
indextype     AllocXmemBlocks,  indextype     ExtendXmemBlocks,
indextype     AllocHandles,     indextype     ExtendHandles,
indextype     AllocVchunks,     indextype     ExtendVchunks,
indextype     AllocGrps,        indextype     ExtendGrps,
indextype     AllocDbBlocks,    indextype     ExtendDbBlocks,
char         *ParmsBuf,         ft F,lt Z,zz *Status);
boolean Domain_OmiInvoke
(char         *Dat_File,         char         *Msg_File,
char         *Out_File,         char         *Mem_File,
farlongtype   CorePageSize,     farlongtype   CoreMaxOnPage,
indextype     AllocFreeAddrs,   indextype     ExtendFreeAddrs,
indextype     AllocChunks,      indextype     ExtendChunks,
indextype     AllocXmemBlocks,  indextype     ExtendXmemBlocks,
indextype     AllocHandles,     indextype     ExtendHandles,
indextype     AllocVchunks,     indextype     ExtendVchunks,
indextype     AllocGrps,        indextype     ExtendGrps,
indextype     AllocDbBlocks,    indextype     ExtendDbBlocks,
ft F,lt Z,zz *Status);
boolean Domain_Enter
(char         *Subject,   keydomtype    KeyToRealm,
ft F,lt Z,zz *Status);
boolean Domain_Exit
(ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\env0.h*/

#define ENV0_H
typedef struct PrimalImage
{
addrtype       InTheOry;
addrtype       InCore;
}              imagetype;
typedef struct BaseObjTypeDesc
{
handletype     Handle;
numtype        ObjNum;
}              objtype;
typedef struct CppObjTypeDesc
{
#ifdef IMAGE_WITH_THAT
addrtype        That;
#endif
handletype      Handle;
idtype          DbId;
idtype      CoreDbId;
}              cppobjtype;
typedef struct CppObjectTypeDesc
{
addrtype        That;
tokentype       Token;
}              cppobjecttype;
static  imagetype   *Image01                  = NullPtr;
static  prtaddr      SysBaseAddr;
idtype       RenvId                   = 1;
char         RenvNam[MAXNAME]         = "Renv0";
char         RenvFileName[MAXNAME]    = "f:\\renv.hic";
char         RenvSchemaNam[MAXNAME]   = "RenvSchema";
dbaccesstype RenvDbAccess             = Read_Write;
tokentype    RenvTkn                  = {1, 1, 1};
tokentype    PrimeToken               = {1, 1, 1};
tokentype   *RenvTknPtr               = &PrimeToken;
idtype       WenvId                   = 2;
char         WenvNam[MAXNAME]         = "Wenv1";
char         WenvSchemaNam[MAXNAME]   = "WenvSchema";
char         WenvFileName[MAXNAME]    = "f:\\wenv.hic";
dbaccesstype WenvDbAccess             = Read_Write;
tokentype    WenvTkn                  = {1, 2, 2};
idtype       PrimalId                 = 3;
char         PrimalNam[MAXNAME]       = "Primal01";
char         PrimalFileName[MAXNAME]  = "f:\\primal.hic";
char         PrimalSchemaNam[MAXNAME] = "PrimalSchema";
dbaccesstype PrimalDbAccess           = Read_Write;
tokentype    PrimalTkn                = {1, 3, 3};
char        *TypeTypeStrs[]           =
{"aString",  "aInteger",  "aReal",       "aLink",  "aEnum",
"aBoolean", "aChunk",    "aDbmsString", "aValue", "aAddr",
"aRefObj"};

#ifdef ENV0
void    CoreSetPageSize
(farlongtype   Size);
boolean VORTEx       (ft F,lt Z,zz *Status);
boolean CreateImage   (ft F,lt Z,zz *Status,    imagetype   **Image);
boolean ImplodeTheOry (imagetype    *Image,     ft F,lt Z,zz *Status);
boolean CreateKernel  (imagetype    *Image,     ft F,lt Z,zz *Status,
dbheader    **Image0,    dbheader    **Image1);
boolean LoadKernel    (imagetype    *Image,     ft F,lt Z,zz *Status,
dbheader    **Image0,    dbheader    **Image1);
boolean LoadEnv0      (ft F,lt Z,zz *Status);
boolean LoadObj0      (ft F,lt Z,zz *Status);
#endif

/* 当前文件是./CINT2000\255.vortex\src\primal.h*/

#ifndef PRIMAL01_H
#define PRIMAL01_H


boolean Primal_CreateDb
(char         *SchemaName,char         *DbName,
char         *DbFileName,dbaccesstype  AccessType,
numtype       HndlRgns,  numtype       RgnHndls,
numtype       VhndlRgns, numtype       RgnVhndls,
numtype       XmemRgns,  numtype       RgnXmems,
ft F,lt Z,zz *Status,    tokentype    *PrimalTkn);
boolean Primal_ActivateDbByName
(char         *DbName,    char         *DbFileName,
dbaccesstype  AccessType,
ft F,lt Z,zz *Status,    tokentype    *PrimalTkn);
boolean Primal_ActivateDbByToken
(tokentype    *PrimalTkn, char         *DbFileName,
dbaccesstype  AccessType,ft F,lt Z,zz *Status);
boolean Primal_FreeDb
(tokentype    *PrimalTkn, ft F,lt Z,zz *Status);
boolean Primal_CommitDb
(tokentype    *PrimalTkn, char         *DbFileName,
boolean       Release,   ft F,lt Z,zz *Status);
boolean Primal_DeleteDb
(tokentype    *PrimalTkn, ft F,lt Z,zz *Status);
boolean Primal_ConfigYourClass
(tokentype    *PrimalTkn, numtype       ClassId,
numtype       RgnEntrys,
numtype       AllocRgns, numtype       ExtendRgns,
numtype       AllocXs,   numtype       ExtendXs,
accesstype    AccessType,boolean       DiskCache,
numtype       CacheLimit,numtype       CacheLoad,
ft F,lt Z,zz *Status);
boolean Primal_GetClassObjectCount
(tokentype    *PrimalTkn, numtype       ClassId,
ft F,lt Z,zz *Status,    numtype      *Count);
boolean Primal_IterateOnClassObjects
(tokentype    *PrimalTkn, numtype       ClassId,
ft F,lt Z,zz *Status,
tokentype    *ItorTkn,   tokentype    *Token);
boolean Primal_FreezeClass
(tokentype    *PrimalTkn, numtype       ClassId,
ft F,lt Z,zz *Status);
boolean Primal_FreeClass
(tokentype    *Token,     numtype       ClassId,
ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\bmt01.h*/

#ifndef BMT_01
#define BMT_01
/* 当前文件是./CINT2000\255.vortex\src\obj01.h*/

#ifndef OBJ01_H
#define OBJ01_H
/* 当前文件是./CINT2000\255.vortex\src\env01.h*/

#ifndef CSH01_H
#define CSH01_H
#ifndef IMAGE01_HPP
/* 当前文件是./CINT2000\255.vortex\src\envdefs.h*/

#ifndef  ENVDEFS_H
#define ENVDEFS_H
#define  Extend_Codes      (indextype )101
#ifndef BLDDEFS_H
#define        Image01_ObjNum      (objnumtype )149
#define        That_AttrNum           (numtype )1
#define        Token_Attr             (numtype )2
#define        Handle_AttrNum         (numtype )2
#define        DbId_AttrNum           (numtype )3
#define        CoreDbId_AttrNum       (numtype )4
#define        ObjNum_AttrNum         (numtype )5
#define        Id_AttrNum             (numtype )144
#define        Renv0_Hndl             (handletype )1
#define        Renv_Hndl              (handletype )2
#define        RenvTypes_Hndl         (handletype )702
#endif
typedef handletype   memberhandle;
typedef handletype   ownerhandle;
typedef tokentype    membertoken;
typedef tokentype    ownertoken;
typedef tokentype    slottokentype;
typedef tokentype    slottoken;
typedef enum   TypeEnvClass
{aEnvDb,   aEnvObj,    aEnvType,   aEnvStruc,  aEnvAttr,
aEnvSet,  aEnvMatrix, aEnvPair,   aEnvTuple,  aEnvSchema,
aEnvView, aEnvCode,   aEnvHead,   aEnvNode,   aEnvSlot,
aEnvValue,aEnvArg,    aEnvPort,   aEnvShell,
aNonEnvClass=EXT_ENUM                           } envclass;
#ifndef TYPEDEFS_01
typedef enum              TypeTypeTypeDesc
{aString,      aInteger,      aReal,         aLink,
aEnum,        aBoolean,      aChunk,        aDbmsString,
aValue,       aAddr,         aRefObj,
aNonTypeType=EXT_ENUM }
typetype;
typedef enum              TypeValueClassType
{aVoid,
aBitField,  aChar,         aUnChar,
aShort,     aUnShort,      aInt,          aUnInt,
aLong,      aUnLong,       aQuad,         aOctet,
aVoidPtr,   aFloat,        aDouble,
aEnumType,  aStruct,       aUnion,
aComplex,   aObject,       aOid,   aNonValueClass=EXT_ENUM}
valueclasstype;
typedef valueclasstype    valueclass;
typedef enum              TypeAttrType
{aAttr,         aObjRefAttr,   aMapRefAttr,   aPortRefAttr,
aTknRefAttr,   aStrHndlAttr,
aSetHeadAttr,  aSetNodeAttr,
aMtrxHeadAttr, aRowHeadAttr,  aColHeadAttr,
aMateNodeAttr, aPointNodeAttr,
aSlotHndlAttr, aSlotTokenAttr,
aChunkAttr,    aVchunkAttr,
aArrayAttr,    aVarrayAttr,   aDblPtrAttr,
aGrpAttr,      aVgrpAttr,
aNonTypeAttr=EXT_ENUM      }             attrtype;
typedef enum              TypeCppAttrType
{aPublic,      aPrivate,      aProtected, aNonCppAttr=EXT_ENUM}
cppattrtype;
#endif
typedef enum   TypeDescTypeDesc
{aDesc,      aObjDesc,    aPrimalDesc, aMasterDesc,
aHeadDesc,  aNodeDesc,   axNodeDesc,  aPointDesc ,
aSlotDesc,  aPortDesc,   aRefObjDesc,
aNonDesc=EXT_ENUM                            } desctype;
typedef enum   TypeSetType
{aLocalSet,          aGlobalSet,
aLocalKeyedSet,     aGlobalKeyedSet,
aLocalKeyed2arySet, aGlobalKeyed2arySet,
aLocalTableSet,     aGlobalTableSet,
aLocalTreeSet,      aGlobalTreeSet,
aIndexedSet,        aSpecialSet,    aNonSet=EXT_ENUM
} settype;
#ifndef TYPEDEFS_01
typedef enum   KeyedSetType
{aKeyedSet,    aMtrxHeadSet,  aNonKeyedSet=EXT_ENUM
} keyedsettype;
#endif
typedef enum   TypeSetHeadType
{aLSetHead,          aGSetHead,
aLKeyedSetHead,     aGKeyedSetHead,
aLKeyed2arySetHead, aGKeyed2arySetHead,
aLTableSetHead,     aGTableSetHead,
aLTreeSetHead,      aGTreeSetHead,
aIndexedSetHead,    aSpclSetHead,
aLSetNode,          aGSetNode,      aNonSetHead=EXT_ENUM
} setheadtype;
typedef enum   TypeRowColType
{aRowType,           aColType,       aNonRowCol=EXT_ENUM
} rowcoltype;
typedef enum   EnvNodeEnumType
{alSetNode,          agSetNode,
aBaseNode,          aRenvNode,
alSetPointNode,     agSetPointNode,
alSetPairedNode,    agSetPairedNode,
alSetLinkedNode,    agSetLinkedNode,
alTableNode,        agTableNode,
alTreeNode,         agTreeNode,     aNonEnvNode=EXT_ENUM
} envnodetype;
typedef enum   LinkNodeEnumType
{aNodeLink,          aPointLink,
aEnvNodeLink,       aAppNodeLink,   aNonLinkNode=EXT_ENUM
} linknodetype;
typedef enum   {aMatrix,            aLocalMatrix,
aGlobalMatrix,      aSingularMatrix, aRadicalMatrix,
aLsMatrix,          aLrMatrix,
aGsMatrix,          aGrMatrix,      aNonMatrix=EXT_ENUM
} matrixtype;
typedef enum
{aLMatrixHead,       aGMatrixHead,   aNonMatrixHead=EXT_ENUM
} matrixheadtype;
typedef enum   TypeTupleType
{aLocalTuple,        aGlobalTuple,
aLocalPair,         aGlobalPair,    aNonTuple=EXT_ENUM
} tupletype;
typedef enum   TypeSlotType
{aLTupleSlot,        aGTupleSlot,
aLPairSlot,         aGPairSlot,     aNonSlot=EXT_ENUM
} slottype;
typedef enum   TypeDependType
{aIndependent,       aMaster,
aSlave,             aDependent,     aNonDepend=EXT_ENUM
} dependtype;
typedef enum   TypeCodeType
{aCreateCode,        aDeleteCode,
aPutObjCode,        aGetObjCode,
aPutAttrCode,       aGetAttrCode,
aCompAttrCode,      aSpclCode,
aObjCode,           aKernelCode,
aShellCode,         aVirtualCode,
aOvrloadCode,       aDbeCode,
aDbmsCode,          aNonCodeType=EXT_ENUM    } codetypetype;
typedef enum   ClassArgType
{aVoidClass,         aObjClass,
aTypeClass,         aFuncClass,     aNonClassArg=EXT_ENUM
} argclasstype;
typedef enum   QualArgType
{aOfThisType,        aPtrToType,
aDblPtrToType,      aRefToType,     aNonQualArg=EXT_ENUM
} argqualtype;
typedef enum   TypeF77DataType
{aNonF77type,
aF77String,         aF77Integer,
aF77Real,           aF77Double,     aNonF77DataType=EXT_ENUM
} f77datatype;
typedef enum   TypeF77ClassType
{aNonF77Class,       aF77Sclar,
aF77NumericArray,   aF77CharArray,  aNonF77ClassType=EXT_ENUM
} f77classtype;
#ifndef TYPEDEFS_01
typedef enum   ComparisonOpType
{aEQ,                aLT,           aGT,
aGTE,               aLTE,          aNEQ,
aModEQ0,            aNonCompareOp=EXT_ENUM   } compareoptype;
typedef compareoptype      compareop;
#endif
typedef enum   SortOrderType
{aAscending,         aDescending,   aNonSortOIrder=EXT_ENUM
} sortordertype;
typedef sortordertype      sortorder;
typedef enum   BooleanOpsType
{aNullBoolOp,        aAND,     aOR,   aExOR,
aNOT,               aNAND,    aNOR,  aNxOR,
aNonBoolOp=EXT_ENUM                          } booleanoptype;
typedef booleanoptype      booleanop;
typedef struct TypeAttrObj
{
char                  AttrName[MAXNAME];
attrtype              AttrType;
cppattrtype           CppType;
char                  TypeName[MAXNAME];
typetype              TypeType;
bytessize             Size;
boolean               aSigned;
numtype               EnumValue;
bytessize             ChunkUnitSize;
tokentype             ObjRefTkn;
}  attrobjtype;
typedef attrobjtype     attrinfotype;
typedef struct    KrnlObjectType
{
addrtype    That;
tokentype   Token;
}                       krnlobjtype;
typedef krnlobjtype    *referencetype;
typedef struct TypeF77TokenType
{
f77datatype          F77Type;
f77classtype         F77Class;
numtype              ArrayNum;
numtype              ArrayIndex;
}  f77tokentype;
numtype      Global_Apl             = C_Apl;
numtype      EOS_ObjNum             = 131;
indextype    Alloc_ObjRegions       = 80;
indextype    Alloc_RegionObjs       = 5;
indextype    Alloc_Regions          = 10;
indextype    Extend_Regions         = 10;
indextype    Region_Objects         = 100;
indextype    Alloc_ObjDescRgns      = 10;
indextype    Alloc_ObjDescSectors   = 40;
indextype    Alloc_ObjDescRgnObjs   = 10;
numtype      C_ObjMapDir            = 0;
numtype      C_ImageMapDir          = 0;
numtype      CppObjMapDir           = 0;
numtype      F77ObjMapDir           = 0;
numtype      F77StructDir           = 0;
numtype      ApiStructDir           = 0;
char        *DescNam[11]  = {"Desc",        "ObjDesc",    "PrimalDesc",
"MasterDesc",  "HeadDesc",   "NodeDesc",
"xNodeDesc",   "PointDesc",  "SlotDesc",
"PortDesc",    "RefObjDesc"   };
char        *LowDescNam[11]
= {"desc",        "objdesc",    "primaldesc",
"masterdesc",  "headdesc",   "nodedesc",
"xnodedesc",   "pointdesc",  "slotdesc",
"portdesc",    "refobjdesc"             };
char        *LowTypeNam[11]
= {"stringdesc",  "integerdesc",
"realdesc",    "linkdesc",
"enumdesc",    "booleandesc",
"chunkdesc",   "dbmsstringdesc",
"valuedesc",   "addrdesc",
"refobjdesc"                     };
char        *CppQualName[3]     = {
"public",      "private",     "protected" };
char        *ArgClassName[4]    = {
"aVoidClass",    "aObjClass",   "aTypeClass",
"aFuncClass" };
char        *ArgQualName[4]     = {
"aOfThisType",  "aPtrToType",  "aDblPtrToType",
"aRefToType"                                    };
char        *ArgQualLex[4]      = {   "  ",  " *",  "**", " &"   };
#ifndef TYPEDEFS_01
char        *CompareOpName[7]   = {"aEQ",      "aLT",   "aGT",
"aGTE",     "aLTE",  "aNEQ",
"aModEQ0" };
#endif
char        *CompareOpLex[7]    = {"==",    "<",     ">",
">=",    "<=",    "!=",
"%"                     };
char        *SortOrderName[2]   = {"aAscending", "aDescending" };
char        *BooleanOpName[8]   = {"aNullBoolOp",
"aAND",  "aOR",   "aExOR",
"aNOT",  "aNAND", "aNOR",
"aNxOR"  };
char        *BooleanOpLex[8]    = {"??", "&&",    "||",    "^",
"!",  "^&",    "|",     "^|"  };
char        *DbPutStr[3]        = { "Put_NoFree",
"Put_Release", "Put_Deep"};
char        *HeapStr[2]         = { "FreeStore",   "HeapSpace"};
char        *TypeTypeNam[11]    = {"aString",  "aInteger",  "aReal",
"aLink",    "aEnum",     "aBoolean",
"aChunk",
"aDbmsString",           "aValue",
"aAddr",    "aRefObj"};
char        *ValueClassNam[21]  = {"aVoid",
"aBitField", "aChar",    "aUnChar",
"aShort",  "aUnShort",  "aInt",     "aUnInt",
"aLong",   "aUnLong",   "aQuad",    "aOctet",
"aVoidPtr",  "aFloat",   "aDouble",
"aEnumType", "aStruct",  "aUnion",
"aComplex",  "aObject",  "aOid"  };
char        *AttrTypeNam[22]    = {"Attr",
"ObjRefAttr",     "MapRefAttr",
"PortRefAttr",    "TknRefAttr",
"StrHndlAttr",
"SetHeadAttr",    "SetNodeAttr",
"MtrxHeadAttr",
"RowHeadAttr",    "ColHeadAttr",
"MateNodeAttr",   "PointNodeAttr",
"SlotHndlAttr",   "SlotTokenAttr",
"ChunkAttr",
"VchunkAttr",     "ArrayAttr",
"VarrayAttr",     "DblPtrAttr",
"GrpAttr",        "VgrpAttr"     };
char        *CodeEnumName[15]   = {"aCreateCode",    "aDeleteCode",
"aPutObjCode",    "aGetObjCode",
"aPutAttrCode",   "aGetAttrCode",
"aCompAttrCode",  "aSpclCode",
"aObjCode",       "aKernelCode",
"aShellCode",     "aVirtualCode",
"aOvrloadCode",   "aDbeCode",
"aDbmsCode" };
char        *SetTypeNam[11]     = {"LocalSet",          "GlobalSet",
"LocalKeyedSet",     "GlobalKeyedSet",
"LocalKeyed2arySet", "GlobalKeyed2arySet",
"LocalTableSet",     "GlobalTableSet",
"LocalTreeSet",      "GlobalTreeSet",
"IndexedSet"};
char        *TupleTypeNam[4]     = {"LocalTuple",  "GlobalTuple",
"LocalPair",   "GlobalPair"};
char        *SlotTypeNam[4]      = {"lTupleSlot",  "gTupleSlot",
"lPairSlot",   "gPairSlot" };
char        *DependTypeNam[4]    = {"aIndependent", "aMaster",
"aSlave",       "aDependent"};

typedef struct TypeChunk
{
numtype      ChunkNum;
addrtype     Addr;
sizeinbytes  UnitSize;
indextype    StackPtr;
indextype    UnitCount;
indextype    BlockUnits;
indextype    ExtendQty;
sizeinbytes  MaxUnitLen;
boolean      IsCPP;
boolean      IsPtrs;
boolean      IsVary;
boolean      IsData;
boolean      IsString;
boolean      IsText;
boolean      IsSameSize;
boolean      IsInCore;
boolean      IsActive;
boolean      IsClean;
boolean      IsFrozen;
boolean      IsGrown;
}                         chunk;
typedef	struct ChunkHdrType
{
tokentype    ThisToken;
numtype      ChunkCount;
chunk      **Chunks;
indextype    ChunkQty;
indextype    GrowQty;
indextype    BlockUnits;
chunk       *FreeChunks;
} ChunkHdr;
typedef struct Ory
{
addrtype    *ChunkAddr;
numtype     *NextChunk;
longtype  *Flags;
sizeinbytes *UnitSize;
indextype   *UnitCount;
indextype   *StackPtr;
numtype     *StringText;
indextype   *ExtendQty;
sizeinbytes *MaxUnitLen;
indextype    NextFree;
} OryType;
typedef struct TypeBlkHdr
{
filetokentype BlkFile;
#ifdef STRUC_ALIGN_BY8
filetokentype BlkFile_64;
#endif
idtype        DbId;
idtype        CoreDbId;
numtype       HeadFreeVbns;
numtype       BlkDirChunk;
numtype       HeadFreeBlks;
numtype       HeadNullBlks;
numtype       BlkTknChunk;
numtype       BlkSizeChunk;
farlongtype   EofMark;
} blkhdrtype;
typedef  struct   TypeStrucHdr
{
numtype       TextChunk;
vbntype       TextVbn;
indextype     FirstFreeGap;
} struchdr;
typedef  struct   TypeStringStruc
{
indextype      TextOffset;
sizetype       TextSize;
indextype      NextFreeGap;
} stringstruc;
typedef  struct   TypeVaryStruc
{
indextype      ChunkOffset;
sizetype       VarySize;
indextype      NextFreeGap;
typetype       VaryType;
} varystruc;
OryType           *Theory               = NULL;
numtype            Mem_ChunkExpanded    = 0;
boolean            ClearChunk           = False;
boolean            SetGetSwi            = False;
static   indextype          Alloc_Chunks         = 3001;
static   indextype          Extend_Chunks        = 300;
indextype          KrnlBlocks_AllocQty  = 2806;
indextype          KrnlBlocks_ExtendQty = 1806;
static   indextype          XmemBlocks_AllocQty  = 300;
static   indextype          XmemBlocks_ExtendQty = 100;
static   numtype            ChunkAddrChunk       = 0;
static   numtype            NumChunkChunks       = 3;
numtype            NumChunks            = 3;
static   word               ChunksAllocated      = 0;
numtype            ChunksFreeed         = 0;
static   numtype            ChunksReclaimed      = 0;
static   addrtype          *ChunkTheoryAddr      = NullPtr;
static  char               *ValueClassNam[21]    = {"aVoid",
"aBitField", "aChar",    "aUnChar",
"aShort",  "aUnShort",  "aInt",     "aUnInt",
"aLong",   "aUnLong",   "aQuad",    "aOctet",
"aVoidPtr",  "aFloat",   "aDouble",
"aEnumType", "aStruct",  "aUnion",
"aComplex",  "aObject",  "aOid"  };
#define  Env_AttrNotInAplClassDef  -21
#define  Env_AttrNotInDbmsClassDef -22
#define  Dbe_Exit                -200
#define  Dbe_InvalidType          201
#define  Dbe_VarNameReq           202
#define  Dbe_SemiReq              203
#define  Dbe_BadSyntax            204
#define  Dbe_UnMatchedBrace       205
#define  Dbe_NotFound            -206
#define  Dbe_EndOfExpression     -207
#define  Dbe_EndOfStatement      -208
#define  Dbe_EndOfDeclaration    -209
#define  Dbe_EndOfFunction       -210
#define  Dbe_EndOfArgument       -211
#define  Dbe_EndOfElement        -212
#define  Dbe_UnmatchedArgType     213
#define  Dbe_NotAnObjDesc         214
#define  Dbe_NullHandle           215
#define  Dbe_BadDbId              216
#define  Dbe_UnmatchedBracket     217
#define  Dbe_BadArraySyntax       218
#define Env01_BadDescTypeType    2005
#define Oa_ObjNoThisAttr         5050
#define Oa_LessThen             -5051
#define Oa_GtrThen              -5052
#define Oa_ObjNoThisField        5057
#define Oa_DbNoThisAttr          5058
#define Oa_AttrNotPresent        5061
#define Oa_NullStringIndex       5062
#define Oa_BadDbToken            5068
#define Set_NotAnObjDesc        10001
#define Set_SetNameReq          10002
#define Set_DupObjName          10003
#define Set_DupSetName          10003
#define Set_BadDescName         10004
#define Set_DescNameReq         10005
#define Set_SetLinkSizeReq      10006
#define Set_NotAnAttrDesc       10007
#define Set_IsAnIndexedSet     -10018
#define Set_BadQuickPickSet     10019
#define Set_SetNodeNameReq      10021
#define Set_SetNodeDescReq      10022
#define Set_SetNotOfObjCestrs   10023
#define Set_KeyNotOfObjCestrs   10024
#define Set_NotAnOwnerClass     10025
#define Spcl_NullKeyName        10050
#define Mtrx_DupMtrxName             10061
#define Mtrx_MtrxNameReq             10062
#define Mtrx_BadDescName             10063
#define Mtrx_DescNameReq             10064
#define Mtrx_OwnerObjReq             10065
#define Mtrx_RowHeadNameNotFound     10066
#define Mtrx_RowHeadNameReq          10067
#define Mtrx_RowHeadKeyNotAnAttrDesc 10068
#define Mtrx_RowHeadKeyNameReq       10069
#define Mtrx_ColHeadNameNotFound     10070
#define Mtrx_ColHeadNameReq          10071
#define Mtrx_ColHeadKeyNotAnAttrDesc 10072
#define Mtrx_ColHeadKeyNameReq       10073
#define Mtrx_PointNodeNameNotFound   10074
#define Mtrx_PointNodeNameReq        10075
#define Mtrx_InvalidAttrField        10076
#define Mtrx_AlreadyExists           10077
#define Mtrx_RowColNotOfSameMatrix   10080
#define Map_NoPortForThisObj    15011
#define Trans_NullMap           16000
#define Trans_NullAttrNum       16001
#define Trans_ArrayNotOfClass   16002
#define Trans_MixedArraySize    16003
#define Trans_NullBaseArray     16004
#define Trans_NullBaseArraySize 16005
#define Trans_AttrNotOfClass    16006
#define Trans_ThatNotOfClass    16007
#define Trans_NullObjSize       16008
#define Trans_CoreNoMore        16009
#define Trans_IndexOutOfRange   16010
#define Trans_AttrNotInClassDef 16011
#define Trans_CppShellNotInvoked 16012
#define Image_AttrNotArrayType      16020
#define Image_AttrNotDblPtrType     16021
#define Image_ArrayIndexOutOfRange  16022
#define Image_ArrayWasNotCreated    16023
#define Image_AttrNotRefTknType     16024
#define Image_AttrNotObjRefType     16025
#define Image_AttrNotStringType     16026
#define Image_AttrNotPutArrayType   16027
#define Attr_TransientNotPut        16040
#define Attr_TransientNotCreate     16041
#define Attr_ArrayIsActive          16042
#define Attr_NullArray              16043
#define Attr_NullSubArray           16044
#define Attr_ImageIsActive         -16045
#define Query_NotAnQueryOnArray     16050
#define Query_AttrNotArrayType      16051
#define Query_ArrayNotOfValueType   16052
#define Query_NotAnValueQuery       16053
#define Query_ArrayNotApplicable    16054
#define Query_SetOrTupleNotAllowed  16055
#define Query_InvalidTknCompare     16056
#define Query_MustBeValueQuery      16057
#define Query_UnitTypeNotHandle     16058
#define Query_AttrNotReference      16059
#define Query_BadSubQueryClassId    16060
#define Query_AttrMustBeSetOrArray  16061
#define Query_BadArrayQueryClass    16062
#define Cpp_ObjectNotActivated  17000
#define Cpp_NotOfThisClass      17001
#define Cpp_DbNotActivated      17002
#define Cpp_InvalidToken        17003
#define pShell_NullOffsetDir    17010
#define pShell_NullClassSizeDir 17011
#define pShell_NullTransImageDir    17012
#define pShell_NullTknCodeDir   17013
#define pShell_NullCastCodeDir  17014
#define pShell_NullNewCodeDir   17014
#define pShell_NewCodeMissing   17015
#define Image01_ThatUnassigned       17100
#define Image01_NullAddr             17101
#define Image01_CanNotDownCast       17102
#define Image01_ConstructorMissMatch 17103
#define Image01_NullTokenPtr         17104
#define Image01_NullToken            17105
#define Image01_BadCastInCode        17106
#define Image01_MixedTokensInNew     17107
#define Csh_DbAlreadyExists    -18000
#define Primal_NullDbName       18010
#define Primal_NullDbFileName   18011
#define Primal_NotOfSameDb      18012
#define IntChunk_NullVtoken     19000
#define IntChunk_IndexGtrStack  19001
#endif
#define  EnvShowStats              Env_ShowStats
#define  EnvGetClassId             Env_GetClassId
#define  EnvGetMemberId            Env_GetAttrId
#define  EnvGetSetId               Env_GetSetId
#define  EnvInitClassMap           Env_InitClassMap
#define  EnvAppendToMap            Env_AppendToMap
#define  EnvInvokeMap              Env_InvokeMap
#define  EnvGetClassMap            Env_GetClassMap
#define  EnvGetApiToken            Env_GetApiToken
#define  EnvGetMapId               Env_GetApiMapId
#define  EnvGetFieldId             Env_GetApiFieldId
#define  EnvFetchTransPortLib      Env_FetchApiPortLib
#define  EnvLoadPortCode           Env_LoadApiPortCode
#define  EnvImportDb               Env_ImportDb
#define  EnvExportDb               Env_ExportDb
tokentype      Random_Tkn            = {31, 2, 0};
int           *Random_Dir            = NullPtr;
indextype      Random_Limit          = 0;
indextype      Random_ItNum          = 0;
numtype      WenvGroups_Hndl         = 0;
numtype      WenvSubjects_Hndl       = 0;
numtype      WenvCodes_Hndl          = 0;
numtype      GroupId_AttrNum         = 0;
numtype      SubjectId_AttrNum       = 0;
numtype      CodeId_AttrNum          = 0;
numtype      AplNum_AttrNum          = 0;
numtype      ApiNum_AttrNum          = 0;
numtype      MapNum_AttrNum          = 0;
numtype      FieldNum_AttrNum        = 0;
numtype      MapIndex_AttrNum        = 0;
numtype      TransMapNames_Hndl      = 0;
numtype      TransPortMaps_Hndl      = 0;
numtype      TransFieldNames_Hndl    = 0;
numtype      TransPortFields_Hndl    = 0;
numtype      PortMapFields_Hndl      = 0;
numtype      PrimalGroupSlotAttr_Attr = 0;

#endif
boolean Env_GetTypeId
(char         *TypeName,
ft F,lt Z,zz *Status,    numtype      *TypeId);
boolean Env_GetClassId
(char         *ClassName,
ft F,lt Z,zz *Status,    numtype      *ClassId);
boolean Env_GetAttrId
(char         *AttrName,
ft F,lt Z,zz *Status,    numtype      *AttrId);
boolean Env_NewFieldStruc
(char         *FieldName,
ft F,lt Z,zz *Status,    fieldstruc  **FieldStruc);
boolean Env_GetFieldStruc
(char         *FieldName,
ft F,lt Z,zz *Status,    fieldstruc   *FieldStruc);
boolean Env_DeleteFieldStruc
(ft F,lt Z,zz *Status,    fieldstruc  **FieldStruc);
boolean Env_GetSetId
(char         *SetName,
ft F,lt Z,zz *Status,    numtype      *SetId);
boolean Env_GetTupleId
(char         *TupleName,
ft F,lt Z,zz *Status,    numtype      *TupleId);
boolean Env_GetMatrixId
(char         *MatrixName,
ft F,lt Z,zz *Status,    numtype      *MatrixId);
boolean Env_LoadCreateCode
(numtype       ClassId,    funcptrtype   CodePtr,
ft F,lt Z,zz *Status);
boolean Env_LoadGetTknCode
(numtype       ClassId,    funcptrtype   CodePtr,
ft F,lt Z,zz *Status);
boolean Env_InitClassMap
(numtype       ClassId,   size_t        ObjSize,
numtype       AplId,     ft F,lt Z,zz *Status);
boolean Env_AppendToMap
(numtype       AttrId,    size_t        Offset,
ft F,lt Z,zz *Status);
boolean Env_InvokeMap
(numtype       AplId,     ft F,lt Z,zz *Status);
boolean Env_GetClassMap
(numtype       ClassId,   numtype       AplId,
ft F,lt Z,zz *Status,    classmaptype *ClassMap);
boolean Env_GetAttrInfo
(numtype       AttrId,
ft F,lt Z,zz *Status,    attrinfotype *AttrInfo);
boolean Env_IsValidToken
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean Env_TokenIsEquiv
(tokentype    *Token0,    tokentype    *Token1);
boolean Env_ReclaimHandles
(tokentype    *Token,     ft F,lt Z,zz *Status);
void    Env_ShowStats
(void);
boolean Env_GenerateRandomNumbers
(indextype     Count,     ft F,lt Z,zz *Status);
int     Env_Random
(numtype       Limit);
#endif
#ifndef PSH01_HPP



typedef  addrtype      versionref;
typedef  funcptrtype   cppfuncptr;
typedef  tokentype     porttype;
#define array(type)        type  *
#define varray(type)       Varray_##type
#define vchunk(type)       Vchunk_##type
#define Reference(class)   Ref##class
#define refobjtype(class)  Ref##class
#define refobj(class)      Ref##class
#define portobj(baseclass) porttype
#define Port(baseclass)    porttype
#define reftoken(class)    tokentype
#define refhandle(class)   tokentype
#define GRP(type)          grptype
#define grp(type)          grptype
#define VGRP(type)         vgrptype
#define vgrp(type)         vgrptype
#define for_IterateOn_Set(SetId,OwnerTkn,ItNum,F,Z,Status,NodeTkn,Token) \
for(ItNum=0;(ItNum=Owner_SetIterateOn(SetId,ItNum,F,Z,Status,NodeTkn,Token))>0;)
typedef struct TypeObject
{
tokentype             Token;
}  Object;
typedef struct TypeImage01
{
addrtype              That;
tokentype             Token;
}  Image011;
#ifndef ENV1_H
typedef struct TypeObjRef
{
addrtype              ObjAddr;
tokentype             ObjTkn;
}  RefObj;
#endif
typedef struct TypeApiObj
{
addrtype              That;
tokentype             Token;
addrtype              PortHead;
ownerhandle           OwnerApiPorts;
}  ApiObj;
typedef struct TypePortObj
{
addrtype              That;
tokentype             Token;
addrtype              PortHole;
numtype               PortId;
memberhandle          MemberApiPorts;
}  PortObj;
#ifndef ENV1_H

typedef struct TypeVchunk
{
tokentype             VchunkTkn;
indextype             Vsize;
void                 *Varray;
indextype             VstackPtr;
}  vchunktype;
#endif
typedef struct ShortArray
{
tokentype             VchunkTkn;
indextype             Vsize;
short                *Varray;
}ShortArray;
typedef ShortArray  shortarraytype;
typedef struct IntArray
{
tokentype             VchunkTkn;
indextype             Vsize;
int                  *Varray;
}IntArray;
typedef IntArray   intarraytype;
typedef struct IntChunk
{
tokentype              VchunkTkn;
indextype              Vsize;
int                   *Varray;
indextype              VstackPtr;
}IntChunk;
typedef IntChunk  intchunktype;
#endif
boolean Object_Create
(tokentype    *Anchor,    numtype       ClassId,
ft F,lt Z,zz *Status,    tokentype    *Token);
void    Object_Dump
(tokentype    *Token);
numtype Object_IsA
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean Object_IsKindOf
(tokentype    *Token,     numtype       ClassId,
ft F,lt Z,zz *Status);
boolean Object_Delete
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean Object_NewImage
(tokentype    *Anchor,    numtype       ClassId,
ft F,lt Z,zz *Status,
tokentype    *Token,     addrtype     *Image);
boolean Object_GetImage
(tokentype    *Token,
ft F,lt Z,zz *Status,    addrtype     *Image);
boolean Object_ImageIsActive
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean Object_PutImage
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean Object_FreeImage
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean Object_CommitImage
(tokentype    *Token,     boolean       Release,
ft F,lt Z,zz *Status);
void    Image_DumpPseudo
(tokentype    *Anchor,    numtype       ClassId,
addrtype      Pseudo);
boolean Attr_ValuePut
(tokentype    *Token,     numtype       AttrId,
addrtype      Value,     ft F,lt Z,zz *Status);
boolean Attr_ValueGet
(tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,    addrtype      Value);
int     Attr_ValueCompare
(tokentype    *Token,     numtype       AttrId,
addrtype      CompValue, ptr_cmp       CmpCode,
ft F,lt Z,zz *Status);
boolean Attr_ObjTknPut
(tokentype    *Token,     numtype       AttrId,
tokentype    *ObjTkn,    ft F,lt Z,zz *Status);
boolean Attr_ObjTknGet
(tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,    tokentype    *ObjTkn);
boolean Attr_TokenToRef
(tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,    addrtype     *RefObject);
boolean Attr_RefTknPut
(tokentype    *Token,     numtype       AttrId,
tokentype    *RefTkn,    ft F,lt Z,zz *Status);
boolean Attr_StringCreate
(tokentype    *Token,     numtype       AttrId,
sizetype      AllocSize,
ft F,lt Z,zz *Status,    cstring      *String);
boolean Attr_StringGet
(tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,
boolean      *StrCpyIsA, cstring      *String);
boolean Attr_StrCpyGet
(tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,    cstring      *String);
boolean Attr_StrCpyFree
(ft F,lt Z,zz *Status,    cstring      *String);
boolean Attr_ArrayCreate
(tokentype    *Token,     numtype       AttrId,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,    addrtype     *Array);
boolean Attr_SubArrayCreate
(tokentype    *Token,
numtype       AttrId,    indextype     ArrayIndex,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,    addrtype     *Array);
boolean Attr0_ArrayActivate
(tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,    numtype      *UnitCount,
sizetype     *UnitSize,  addrtype     *Array);
boolean Attr0_ArrayDeActivate
(tokentype    *Token,     numtype       AttrId,
deletetype    Action,    ft F,lt Z,zz *Status);
boolean Attr_ArrayGetSize
(tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,
numtype      *UnitCount, sizetype     *UnitSize);
boolean Attr_SubArrayGetSize
(tokentype    *Token,     numtype       AttrId,
indextype     Index,
ft F,lt Z,zz *Status,    numtype      *UnitCount);
boolean Attr_ArrayAssertSize
(tokentype    *Token,     numtype       AttrId,
numtype       UnitCount,
ft F,lt Z,zz *Status,    addrtype     *Array);
boolean Attr_SubArrayAssertSize
(tokentype    *Token,     numtype       AttrId,
indextype     Index,     numtype       UnitCount,
ft F,lt Z,zz *Status,    addrtype     *Array);
boolean Attr_ArrayDelete
(tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status);
boolean Attr_SubArrayDelete
(tokentype    *Token,     numtype       AttrId,
indextype     Index,     ft F,lt Z,zz *Status);
boolean Field_ValuePut
(tokentype    *Token,     fieldstruc   *FieldStruc,
addrtype      Value,     ft F,lt Z,zz *Status);
boolean Field_ValueGet
(tokentype    *Token,     fieldstruc   *FieldStruc,
ft F,lt Z,zz *Status,    addrtype      Value);
#ifndef PSH01_HPP
inttype Owner_SetIterateOn
(numtype       SetId,     tokentype    *OwnerTkn,
inttype       ItNum,     ft F,lt Z,zz *Status,
tokentype    *NodeTkn,   tokentype    *Token);
boolean Owner_SetFirstOf
(numtype       SetId,     tokentype    *OwnerTkn,
ft F,lt Z,zz *Status,    tokentype    *NodeTkn,
tokentype    *FirstTkn);
boolean Owner_KeySetFindIn
(numtype       SetId,     tokentype    *OwnerTkn,
addrtype      KeyValue,
ft F,lt Z,zz *Status,    tokentype    *MemberTkn);
boolean Owner_KeySetFindInBy2aryKey
(numtype       SetId,     tokentype    *OwnerTkn,
addrtype      KeyValue,
ft F,lt Z,zz *Status,    tokentype    *MemberTkn);
boolean Member_SetOwnerOf
(numtype       SetId,     tokentype    *MemberTkn,
ft F,lt Z,zz *Status,    tokentype    *OwnerTkn);
boolean Member_SetPrevOf
(handletype    SetId,     tokentype    *MemberTkn,
ft F,lt Z,zz *Status,
tokentype    *NodeTkn,   tokentype    *PrevTkn);
boolean Member_SetNextOf
(handletype    SetId,     tokentype    *MemberTkn,
ft F,lt Z,zz *Status,
tokentype    *NodeTkn,   tokentype    *NextTkn);
boolean Member_KeySetAddInto
(numtype       SetId,     tokentype    *OwnerTkn,
tokentype    *MemberTkn, ft F,lt Z,zz *Status);
boolean Set_Create
(handletype    SetDesc,   tokentype    *OwnerTkn,
numtype       AllocSize, numtype       Order,
ft F,lt Z,zz *Status);
boolean Tree_Create
(handletype    SetDescHndl,  tokentype     *OwnerTkn,
numtype       TreeOrder,    numtype        AllocKeys,
sizetype      KeySize,      typetype       KeyType,
ft F,lt Z,zz *Status,       tokentype     *TreeTkn);
#ifdef     __INCLUDE_MTRX__
#endif
#endif
#endif
/* 当前文件是./CINT2000\255.vortex\src\vchunk.h*/

#ifndef VCHUNK01_H
#define VCHUNK01_H


typedef struct TypeVchunk01
{
addrtype              That;
tokentype             Token;
typetype              TypeType;
handletype            TypeObj;
sizetype              UnitSize;
handletype            UnitChunk;
handletype            lOwnerObject;
}  Vchunk01;
#define VchunkCreate       Vchunk_Create
#define VchunkGetVstruc    Vchunk_GetVstruc
#define VchunkDumpVstruc   Vchunk_DumpVstruc
#define VchunkFreeze       Vchunk_Freeze
#define VchunkThaw         Vchunk_Thaw
#define VchunkDefrost      Vchunk_Defrost
#define VchunkSetDirty     Vchunk_SetDirty
#define VchunkSetClean     Vchunk_SetClean
#define VchunkSwapOut      Vchunk_SwapOut
#define VchunkSwapIn       Vchunk_SwapIn
#define VchunkGetAddress   Vchunk_GetAddress
#define VchunkPutAddress   Vchunk_PutAddress
#define VchunkGetStackPtr  Vchunk_GetStackPtr
#define VchunkPutStackPtr  Vchunk_PutStackPtr
#define VchunkPushUnit     Vchunk_PushUnit
#define VchunkPutUnit      Vchunk_PutUnit
#define VchunkPopUnit      Vchunk_PopUnit
#define VchunkGetUnit      Vchunk_GetUnit
#define VchunkInsertUnit   Vchunk_InsertUnit
#define VchunkExtractUnit  Vchunk_ExtractUnit
#define VchunkFindIn       Vchunk_FindIn
#define VchunkAddInto      Vchunk_AddInto
#define VchunkCopy         Vchunk_Copy
#define VchunkDump         Vchunk_Dump
#define VchunkCommit       Vchunk_Commit
#define VchunkDelete       Vchunk_Delete
#define BitFieldCreate     BitField_Create
#define BitFieldDelete     BitField_Delete
#define BitFieldPut        BitField_Put
#define BitFieldGet        BitField_Get
#define BitFieldFirstOf    BitField_FirstOf
#define BitFieldNextOf     BitField_NextOf
boolean Vchunk_Create
(tokentype    *Anchor,    sizetype      UnitSize,
indextype     UnitCount, indextype     ExtendQty,
ft F,lt Z,zz *Status,    tokentype    *Vtoken);
boolean Vchunk_IsValidToken
(tokentype    *Vtoken,    ft F,lt Z,zz *Status);
boolean Vchunk_GetVstruc
(tokentype    *Vtoken,    ft F,lt Z,zz *Status,
chunkstruc   *VchunkStruc);
boolean Vchunk_DumpVstruc
(tokentype    *Vtoken,    ft F,lt Z,zz *Status);
boolean Vchunk_Freeze
(tokentype    *Vtoken,    ft F,lt Z,zz *Status);
boolean Vchunk_GetAddress
(tokentype    *Vtoken,
ft F,lt Z,zz *Status,    addrtype     *Chunk);
boolean Vchunk_PutAddress
(tokentype    *Vtoken,    addrtype      ChunkAddr,
ft F,lt Z,zz *Status);
boolean Vchunk_GetStackPtr
(tokentype    *Vtoken,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Vchunk_PutStackPtr
(tokentype    *Vtoken,    indextype     StackPtr,
ft F,lt Z,zz *Status,    addrtype     *Varray);
boolean Vchunk_GetChunkSize
(tokentype    *Vtoken,    ft F,lt Z,zz *Status,
indextype    *UnitCount, sizetype     *UnitSize);
boolean Vchunk_Copy
(tokentype    *Vtoken0,   tokentype    *Vtoken1,
ft F,lt Z,zz *Status);
boolean Vchunk_Dump
(tokentype    *Vtoken,    ft F,lt Z,zz *Status);
boolean Vchunk_DumpPartial
(tokentype    *Vtoken,
numtype       Ilow,      numtype       Ihigh,
ft F,lt Z,zz *Status);
boolean Vchunk_Free
(tokentype    *Vtoken,    ft F,lt Z,zz *Status);
boolean Vchunk_Commit
(tokentype    *Vtoken,    boolean       Release,
ft F,lt Z,zz *Status);
boolean Vchunk_Delete
(tokentype    *Vtoken,    ft F,lt Z,zz *Status);
boolean Vchunk_PushUnit
(tokentype    *Vtoken,    addrtype      SomeBytes,
ft F,lt Z,zz *Status,    indextype    *Index);
boolean Vchunk_PutUnit
(tokentype    *Vtoken,    indextype     Index,
addrtype      SomeBytes, ft F,lt Z,zz *Status);
boolean Vchunk_PopUnit
(tokentype    *Vtoken,
ft F,lt Z,zz *Status,    addrtype      SomeBytes,
indextype    *StackPtr);
boolean Vchunk_GetUnit
(tokentype    *Vtoken,    indextype     Index,
ft F,lt Z,zz *Status,    addrtype      SomeBytes);
boolean BitField_Create
(tokentype    *Anchor,    sizetype      AllocBits,
ft F,lt Z,zz *Status,    tokentype    *BitFldTkn);
boolean BitField_Put
(tokentype    *BitFldTkn, indextype     BitNum,
bytetype      BitValue,  ft F,lt Z,zz *Status);
boolean BitField_Get
(tokentype    *BitFldTkn, indextype     BitNum,
ft F,lt Z,zz *Status,    bytetype     *BitValue);
#endif
/* 当前文件是./CINT2000\255.vortex\src\grp.h*/

#ifndef GRP01_H
#define GRP01_H
#ifndef HM00_H
typedef struct TypeGrpHdr
{
wordtype    EnvObjType;
accesstype  PacketAccess;
boolean     DiskCache;
indextype   GrpNum;
valueclass  UnitType;
numtype     UnitObj;
sizeinbytes EntrySize;
indextype   EntryCount;
numtype     RegionEntrys;
numtype     RegionCount;
numtype     RegionsAllocd;
indextype   RegionIndex;
boolean     NoRgnsInCore;
numtype     FreezePacket;
numtype     RegionChunkDir;
numtype     RegionSwapDir;
numtype     DirtyRegionDir;
numtype     RegionFreezeDir;
numtype     RgnBuffNumDir;
numtype     RgnAccessedDir;
numtype     RegionVbnDir;
vbntype     RegionVbnDirVbn;
indextype   ExEntryCount;
numtype     ExEntryTbl;
vbntype     ExEntryTblVbn;
numtype     NextEx;
indextype   NextEntry;
indextype   BaseIndex;
numtype     BaseRegion;
indextype   CacheLimit;
indextype   CacheLoad;
numtype     NumBuffRgns;
indextype   RgnBuffCount;
numtype     BuffRgnsDir;
numtype     BuffNodesDir;
indextype   HeadRgnBuffs;
indextype   LastRgnBuff;
indextype   RgnStatusDir;
indextype   RgnStatusDirVbn;
numtype     RgnBuffIdsDir;
indextype   GrpIndexDir;
indextype   GrpIndexDirVbn;
indextype   GrpDirCount;
lt64        HeadExIndexs;
numtype    *FrozenRgns;
numtype    *RgnBuffNums;
numtype    *RgnAccessArray;
indextype  *RgnBuffRgns;
indextype  *RgnBuffNodes;
indextype  *RgnStats;
indextype  *RgnBuffIds;
lt64       *GrpDirAddr;
#if !defined(SPEC_CPU2000_LP64) && !defined(SPEC_CPU2000_P64)
numtype    *FrozenRgns_64;
numtype    *RgnBuffNums_64;
numtype    *RgnAccessArray_64;
indextype  *RgnBuffRgns_64;
indextype  *RgnBuffNodes_64;
indextype  *RgnStats_64;
indextype  *RgnBuffIds_64;
lt64       *GrpDirAddr_64;
#endif
}                         grpheader;
#endif
#define GrpMakeHdrChunks            Grp_MakeHdrChunks
#define GrpTestPacket               Grp_TestPacket
#define GrpNewPacket                Grp_NewPacket
#define GrpGetPacket                Grp_GetPacket
#define GrpSetPacketCache           Grp_SetPacketCache
#define GrpSetPacketAccess          Grp_SetPacketAccess
#define GrpFreezePacket             Grp_FreezePacket
#define GrpThawPacket               Grp_ThawPacket
#define GrpDefrostPacket            Grp_DefrostPacket
#define GrpFreePacket               Grp_FreePacket
#define GrpDeletePacket             Grp_DeletePacket
#define GrpGetRgnBuffer             Grp_GetRgnBuffer
#define GrpSwapOutBuffRgn           Grp_SwapOutBuffRgn
#define GrpNewRegion                Grp_NewRegion
#define GrpGetRegion                Grp_GetRegion
#define GrpCreateEntry              Grp_CreateEntry
#define GrpNewEntry                 Grp_NewEntry
#define GrpPutNewEntry              Grp_PutNewEntry
#define GrpPutEntry                 Grp_PutEntry
#define GrpGetEntry                 Grp_GetEntry
#define GrpDeleteEntry              Grp_DeleteEntry
#define GrpShowStats                Grp_ShowStats
#ifdef LARGE
#define GRP_EOL              -999999L
#else
#define GRP_EOL               6053
#endif

numtype   CacheAtRgnChunks  = 0;
numtype   FileInRgnChunks   = 0;
numtype   FileOutRgnChunks  = 0;
numtype   CopyInRgnChunks   = 0;
numtype   CopyOutRgnChunks  = 0;
numtype   CleanRgnChunks    = 0;

boolean Grp_MakeHdrChunks
(tokentype    *Anchor,    grpheader    *GrpHdr,
numtype       AllocRgns, numtype       AllocXs,
ft F,lt Z,zz *Status);
boolean Grp_GetPacket
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status,    grpheader   **GrpHdr);
#ifdef GRP_C
boolean GrpNewRegion
(dbheader     *CoreDb,    grpheader    *GrpHdr,
indextype     Index,     indextype     RgnIndex,
ft F,lt Z,zz *Status,
numtype      *RgnChunk,  addrtype     *RgnAddr);
boolean Grp_GetRegion
(dbheader     *CoreDb,    grpheader    *GrpHdr,
indextype     RgnIndex,  ft F,lt Z,zz *Status,
numtype      *RgnChunk,  addrtype     *RgnAddr);
boolean Grp_CleanRgnChunks
(dbheader     *CoreDb,    grpheader    *GrpHdr,
indextype     RgnIndex,  numtype       RgnChunk,
ft F,lt Z,zz *Status);
boolean Grp_DeleteRgn
(dbheader     *CoreDb,    grpheader    *GrpHdr,
indextype     RgnIndex,  numtype       RgnChunk,
ft F,lt Z,zz *Status);
boolean Grp_RgnSwapTopAndPop
(dbheader     *CoreDb,    grpheader    *GrpHdr,
indextype     RgnIndex,  numtype       RgnChunk,
ft F,lt Z,zz *Status);
#endif
boolean Grp_NewPacket
(tokentype    *Anchor,    sizetype      EntrySize,
numtype       AllocRgns, numtype       RgnEntrys,
numtype       AllocXs,   numtype       BaseIndex,
accesstype    AccessType,boolean       DiskCache,
numtype       CacheLimit,numtype       CacheLoad,
numtype       BuffRgns,
ft F,lt Z,zz *Status,    numtype      *GrpNum,
grpheader   **GrpHdr,    numtype      *BaseRegion);
boolean Grp_SetPacketCache
(tokentype    *Anchor,    numtype       GrpNum,
boolean       DiskCache, ft F,lt Z,zz *Status);
boolean Grp_SetPacketAccess
(tokentype    *Anchor,    numtype       GrpNum,
accesstype    AccessType,ft F,lt Z,zz *Status);
boolean Grp_FreezePacket
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status);
boolean Grp_ThawPacket
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status);
boolean Grp_DefrostPacket
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status);
boolean Grp_FreePacket
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status);
boolean Grp_CommitPacket
(tokentype    *Anchor,    numtype       GrpNum,
boolean       Release,   ft F,lt Z,zz *Status);
boolean Grp_DeletePacket
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status);
boolean Grp_ShowStats
(tokentype    *Token,     numtype       GrpNum,
ft F,lt Z,zz *Status);
boolean Grp_DumpStruct
(tokentype    *Token,     numtype       GrpNum,
ft F,lt Z,zz *Status);
boolean Grp_DumpEntrys
(tokentype    *Token,     numtype       GrpNum,
indextype     Low,       indextype     High,
indextype     Limit,     dumpentryptr  DumpEntryPtr,
ft F,lt Z,zz *Status);
boolean Grp_EntryCount
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status,    indextype    *Count);
boolean Grp_CreateEntry
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status,    indextype    *Index);
boolean Grp_NewEntry
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status,    indextype    *Index,
addrtype      Entry);
boolean Grp_PutNewEntry
(tokentype    *Anchor,    numtype       GrpNum,
addrtype      Entry,
ft F,lt Z,zz *Status,    indextype    *Index);
boolean Grp_PutEntry
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,     addrtype      Entry,
ft F,lt Z,zz *Status);
boolean Grp_GetBaseRegion
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status,    addrtype     *BaseRgn);
boolean Grp_GetEntry
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,
ft F,lt Z,zz *Status,    addrtype      Entry);
boolean Grp_GetInLineEntry
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,
ft F,lt Z,zz *Status,    addrtype     *Entry);
boolean Grp_GetFrozenEntry
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,
ft F,lt Z,zz *Status,    addrtype     *Entry);
boolean Grp_FreezeEntry
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,     ft F,lt Z,zz *Status);
boolean Grp_DefrostEntry
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,     ft F,lt Z,zz *Status);
boolean Grp_EntryIsFrosted
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,     ft F,lt Z,zz *Status);
boolean Grp_FrostStatus
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status);
boolean Grp_DeleteEntry
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,     ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\query.h*/

#ifndef QUERY_H
#define QUERY_H
/* 当前文件是./CINT2000\255.vortex\src\bitvec.h*/

#ifndef BITVEC_H
#define BITVERC_H
typedef struct BitVec
{
indextype    AllocBits;
indextype    ExtendBits;
indextype    BitLength;
indextype    HighestBitSet;
bytetype    *BitField;
}              BitVec;
typedef BitVec        bitvectype;
boolean BitVec_Create
(indextype     AllocBits, indextype     ExtendBits,
ft F,lt Z,zz *Status,    bitvectype  **BitStruc);
boolean BitVec_PutBit
(bitvectype   *BitStruc,  indextype     BitNum,
bytetype      BitValue,  ft F,lt Z,zz *Status);
boolean BitVec_GetBit
(bitvectype   *BitStruc,  indextype     BitNum,
ft F,lt Z,zz *Status,    bytetype     *BitValue);
#endif
#ifndef ENV1_H
typedef struct TypeTypeDesc
{
handletype     Handle;
numtype        TypeNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
char           AliasNam[MAXNAME];
numtype        DescNum;
typetype       TypeType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
bytessize      Size;
valueclasstype ValueClass;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender03;
#endif
}              typedesctype;
#endif
#define  EXCLUSIVE   False
#define  INCLUSIVE   True
typedef enum   ScopeOpType
{aEXclusive,         aINclusive,
aNonScopeOp=EXT_ENUM                          } scopeoptype;
typedef scopeoptype      scopeop;
typedef enum   QueryOpType
{aIsA,               aIsKindOf,
aCompareOp,         aSubQuery,
aBooleanOp,
aPushBool,          aPopBool,
aJumpSwi,           aEndQuery,       aClearStack,
aBeginExp,          aEndExp,
aNonQueryOp=EXT_ENUM                          } queryoptype;
typedef queryoptype      queryop;
typedef struct QuerySortType
{
indextype      SeqNum;
numtype        BaseAttr;
sizetype       BaseOffset0;
sizetype       BaseOffset1;
numtype        FieldAttr;
sizetype       FieldOffset0;
sizetype       FieldOffset1;
attrtype       AttrType;
typetype       UnitType;
sizetype       UnitSize;
valueclass     ValueClass;
sortorder      SortOrder;
}             querysort;
typedef struct QueryFieldType
{
indextype      SeqNum;
numtype        BaseAttr;
sizetype       BaseOffset0;
sizetype       BaseOffset1;
numtype        FieldAttr;
sizetype       FieldOffset0;
sizetype       FieldOffset1;
attrtype       AttrType;
typetype       UnitType;
sizetype       UnitSize;
valueclass     ValueClass;
compareop      CompOp;
sizetype       ValueOffset;
boolean        IsValueAssert;
}             queryfield;
typedef struct QueryComdType
{
indextype      SeqNum;
queryop        ComdType;
numtype        QueryField;
booleanop      BoolOp;
numtype        TrueJump;
numtype        FalseJump;
}             querycomd;
typedef struct DbmsQueryType
{
typedesctype  *EnvType;
numtype        ClassId;
boolean        MapIsActive;
boolean        CendentsOk;
numtype        ClassStack;
numtype        NumClasses;
numtype       *ClassSet;
numtype        SortStack;
numtype        NumSorts;
querysort     *SortSet;
numtype        ComdStack;
numtype        NumComds;
querycomd     *ComdSet;
numtype        FieldStack;
numtype        NumFields;
queryfield    *Fields;
numtype        ValueStack;
numtype        NumValues;
bytetype      *Values;
numtype        NumOpens;
numtype        OpenComds[10];
numtype        NumCloses;
numtype        CloseComds[10];
bitvectype    *LocalBitVec;
tokentype      ResultsDir;
numtype        NumResults;
numtype        SortTknsDir;
}              dbmsquery;
typedef  dbmsquery  valuequery;
static  fieldstruc   EnvField;
static  char        *FieldOps          = {".["};
static  boolean      Query_TypeIsToken = False;
char        *ScopeOpName[ 2]   = {
"aEXclusive",       "aINclusive" };
char        *QueryOpName[12]  = {
"aIsA",             "aIsKindOf",
"aCompareOp",       "aSubQuery",
"aBooleanOp",
"aPushBool",        "aPopBool",
"aJumpSwi",         "aEndQuery",
"aClearStack",      "aBeginExp",
"aEndExp"      };
static   wordtype    OprVsStateTbl[10][20] = {
{0, 0, 0, 0, 0,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0},
{0, 0, 0, 0, 0,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0},
{0, 0,10, 0, 0,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0},
{0, 0, 0, 0, 0,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0},
{0, 0, 0, 0, 0,   1, 1, 1, 1, 1,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0},
{0, 0,10, 0, 0,   1, 1, 1, 1, 1,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0},
{0, 0, 0, 0, 0,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0},
{0, 0,10, 0, 0,   1, 1, 1, 1, 1,   1, 1, 1, 1, 1,   1, 1, 0, 0, 0},
{0, 0, 7, 0, 0,   1, 1, 1, 1, 1,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0},
{0, 0, 6, 0, 0,   1, 1, 1, 1, 1,   0, 0, 0, 0, 0,   0, 0, 0, 0, 0} };

boolean    Query_Create
(ft F,lt Z,zz  *Status,      dbmsquery    **Query);
boolean    Query_BeginBuild
(dbmsquery     *Query,       ft F,lt Z,zz  *Status);
boolean    Query_ScopeOn
(dbmsquery     *Query,       char          *Class,
boolean        CendentsOk,  ft F,lt Z,zz  *Status);
boolean    Query1_ScopeOn
(dbmsquery     *Query,       numtype        ClassId,
boolean        CendentsOk,  ft F,lt Z,zz  *Status);
boolean    Query_ScopeOnValue
(valuequery    *Query,       char          *Type,
ft F,lt Z,zz  *Status);
boolean    Query1_ScopeOnValue
(valuequery    *Query,       numtype        TypeId,
ft F,lt Z,zz  *Status);
boolean    Query_DeScope
(dbmsquery     *Query,       char          *Class,
boolean        CendentsOk,  ft F,lt Z,zz  *Status);
boolean    Query1_DeScope
(dbmsquery     *Query,       numtype        ClassId,
boolean        CendentsOk,  ft F,lt Z,zz  *Status);
boolean    Query_SortBy
(dbmsquery     *Query,       char          *Member,
sortorder      SortOrder,   ft F,lt Z,zz  *Status);
boolean    Query1_SortBy
(dbmsquery     *Query,       numtype        AttrId,
sortorder      SortOrder,   ft F,lt Z,zz  *Status);
boolean    Query2_SortBy
(dbmsquery     *Query,       fieldspec      FieldTkns[],
numtype        SubLevel,    sortorder      SortOrder,
ft F,lt Z,zz  *Status);
boolean    Query_OpenParen
(dbmsquery     *Query,       ft F,lt Z,zz  *Status);
boolean    Query_AffixIsA
(dbmsquery     *Query,       char          *Class,
ft F,lt Z,zz  *Status);
boolean    Query1_AffixIsA
(dbmsquery     *Query,       numtype        ClassId,
ft F,lt Z,zz  *Status);
boolean    Query_AffixIsKindOf
(dbmsquery     *Query,       char          *Class,
ft F,lt Z,zz  *Status);
boolean    Query1_AffixIsKindOf
(dbmsquery     *Query,       numtype        ClassId,
ft F,lt Z,zz  *Status);
boolean    Query_AffixCompare
(dbmsquery     *Query,       char          *Member,
compareop      CompOp,      addrtype       Value,
ft F,lt Z,zz  *Status);
boolean    Query1_AffixCompare
(dbmsquery     *Query,       numtype        AttrId,
compareop      CompOp,      addrtype       Value,
ft F,lt Z,zz  *Status);
boolean    Query2_AffixCompare
(dbmsquery     *Query,       fieldspec      FieldTkns[],
numtype        SubLevel,
compareop      CompOp,      addrtype       Value,
ft F,lt Z,zz  *Status);
boolean    Query_AffixRefQuery
(dbmsquery     *Query,       char          *Member,
dbmsquery     *SubQuery,    ft F,lt Z,zz  *Status);
boolean    Query1_AffixRefQuery
(dbmsquery     *Query,       numtype        AttrId,
dbmsquery     *SubQuery,    ft F,lt Z,zz  *Status);
boolean    Query2_AffixRefQuery
(dbmsquery     *Query,       fieldspec      FieldTkns[],
numtype        SubLevel,    dbmsquery     *SubQuery,
ft F,lt Z,zz  *Status);
boolean    Query_AffixBoolOp
(dbmsquery     *Query,       booleanop      BoolOp,
ft F,lt Z,zz  *Status);
boolean    Query_CloseParen
(dbmsquery     *Query,       ft F,lt Z,zz  *Status);
boolean    Query_EndBuild
(dbmsquery     *Query,       ft F,lt Z,zz  *Status);
void       Query_Dump
(dbmsquery     *Query);
boolean    Query_AssertOnObject
(tokentype     *Token,       dbmsquery     *Query,
ft F,lt Z,zz  *Status);
boolean    Query_AssertOnDb
(tokentype     *Anchor,      dbmsquery     *Query,
ft F,lt Z,zz  *Status,
numtype       *NumEntrys,   tokentype     *Vtoken);
boolean    Query_Delete
(ft F,lt Z,zz *Status,       dbmsquery    **Query);
#ifdef QUERY
boolean    Query_CheckType
(numtype       ClassId,      numtype       AttrId,
attrtype      AttrType,     addrtype      Value,
compareop     CompOp,       ft F,lt Z,zz *Status);
boolean    Query_GetClassList
(tokentype     *DbToken,     dbmsquery     *Query,
ft F,lt Z,zz  *Status,      numtype       *LocalObjNum);
void       Query_DumpSortObj
(querysort     *SortObj);
void       Query_DumpComdObj
(querycomd     *ComdObj);
void       Query_DumpFieldObj
(dbmsquery     *Query,       queryfield    *FieldObj);
boolean    Query_CompareValue
(attrtype       AttrType,    typetype       UnitType,
sizetype       UnitSize,    valueclass     ValueClass,
addrtype       VarValue,    compareop      CompOp,
addrtype       CompValue,   ft F,lt Z,zz  *Status);
boolean    Query_CompareWild
(char          *VarValue,    compareop      CompOp,
char          *WildSpec,    ft F,lt Z,zz  *Status);
boolean    Query_AppendAssert
(dbmsquery     *Query,       tokentype     *Token,
ft F,lt Z,zz  *Status);
#endif
#endif
#define DRAWLIB_IN_LINK
typedef   longtype        partidtype;
typedef   char            parttype[10];
typedef   longtype        datetype;
#define   Random(Limit)   (RANDOM_FUNC () % Limit)
typedef struct TypePartToken
{
handletype            Handle;
handletype            FromList;
}  parttkntype;
typedef struct PartLib_Type
{
addrtype      That;
tokentype     Token;
numtype       DbNum;
envclass      EnvType;
numtype       DescNum;
slottoken     PrimalSlotAttr;
slottoken     PrimalGroupSlotAttr;
intarraytype  PartsListHead;
numtype       VpartsDir;
numtype       VlinksDir;
ownertoken    OwnerTosFroms;
} PartLib;
typedef struct Connection_Type
{
partidtype    to;
parttype      type;
longtype      length;
} Connection;
typedef struct Part2
{
addrtype      That;
tokentype     Token;
partidtype    id;
parttype      type;
longtype      xx;
longtype      yy;
datetype      build;
Connection    link[3];
tokentype     FromList;
ownertoken    RowHeadTosFroms;
ownertoken    ColHeadTosFroms;
slottoken     DrawObjSlotAttr;
membertoken   MemberPersonParts;
} Part2;
typedef struct TypePartLink
{
indextype      NextLink;
partidtype     id;
}  partlinktype;
static dbmsquery *Query0             = NullPtr;
static numtype    val0               = 5;
static numtype    Exports            = 0;
static dbmsquery *Query2             = NullPtr;
static char      *StateNam1          = "CA";
static char      *StateNam2          = "T*";
static dbmsquery *Query1             = NullPtr;
static char      *NameComp0          = "H*";
static char      *NameComp1          = "P*";
numtype    Person_Asserts     = 0;
numtype    Person_NullAsserts = 0;
static dbmsquery *Query3             = NullPtr;
static numtype    GTEval1            = 3;
static numtype    GTEval2            = 4;
static numtype    GTEval3            = 5;
static numtype    LTEval             = 10;
numtype    DrawObj_Asserts    = 0;
numtype    DrawObj_NullAsserts= 0;
static dbmsquery *Query4             = NullPtr;
static char      *GTEnam1            = "Pre*";
static char      *GTEnam2            = "??Mid???";
static char      *GTEnam3            = "Pre??Mid??";
static char      *GTEnam4            = "??Post";
static char      *GTEnam5            = "Pre??Post";
static char      *GTEnam6            = "??Mid???Post";
static char      *GTEnam7            = "Pre??Mid???Post";
static numtype    LTEnames           = 7;
numtype    NamedObj_Asserts   = 0;
numtype    NamedObj_NullAsserts = 0;

boolean   DeleteDrawObjects   = False;
boolean   DeletePartObjects   = False;
numtype   id_Attr0            = 0;
numtype   PartLib_Class       = 0;
numtype   PartsListHead_Attr  = 0;
numtype   VpartsDir_Attr      = 0;
numtype   VlinksDir_Attr      = 0;
numtype   DrawPart_Tupl       = 0;
numtype   DrawObj_Slot        = 0;
numtype   PartObj_Slot        = 0;
numtype   Connection_Class    = 0;
numtype   to_Attr             = 0;
numtype   type_Attr           = 0;
numtype   length_Attr         = 0;
numtype   MemberPersonParts_Attr = 0;
numtype   Part_Class          = 0;
numtype   xx_Attr             = 0;
numtype   yy_Attr             = 0;
numtype   build_Attr          = 0;
numtype   c1_Attr             = 0;
numtype   c2_Attr             = 0;
numtype   c3_Attr             = 0;
numtype   FromList_Attr       = 0;
numtype   TosFroms_Mtrx       = 0;
numtype   OwnerTosFroms_Attr  = 0;
numtype   RowHeadTosFroms_Attr= 0;
numtype   ColHeadTosFroms_Attr= 0;
numtype   DrawObjSlotAttr_Attr= 0;
numtype   PartLink_Class      = 0;
numtype   NextLink_Attr       = 0;
numtype   Part_Map            = 0;
numtype   PartId_Field        = 0;
numtype   type_Field          = 0;
numtype   x_Field             = 0;
numtype   y_Field             = 0;
numtype   date_Field          = 0;
numtype   c1To_Field          = 0;
numtype   c1Type_Field        = 0;
numtype   c1Len_Field         = 0;
numtype   c2To_Field          = 0;
numtype   c2Type_Field        = 0;
numtype   c2Len_Field         = 0;
numtype   c3To_Field          = 0;
numtype   c3Type_Field        = 0;
numtype   c3Len_Field         = 0;
numtype   FromList_Field      = 0;
PartLib  *PartLib01           = NullPtr;
tokentype LibTkn              = Null_Token;
int      *PartsTbl            = NullPtr;
tokentype PartTblTkn          = Null_Token;
numtype   VlinksDir           = 0;
tokentype VlistTkn            = Null_Token;
indextype NumVlists           = 0;
numtype  *Vlists              = NullPtr;
#ifndef DRAWLIB_IN_LINK
numtype   VpartsDir           = 0;
longtype  PartCount           = 0;
#endif
tokentype ApiTestTkn      = Null_Token;
tokentype GenLibTkn       = Null_Token;
PartLib  *PortLib01       = NullPtr;
tokentype PortLibTkn      = Null_Token;
int      *PortsTbl        = NullPtr;
tokentype PortTblTkn      = Null_Token;
longtype  PortCount       = 0;
char     *ConnectType     = { "contype00" };
char     *TypeName[]      = {"parttype0",  "parttype1",  "parttype2",
"parttype3",  "parttype4",  "parttype7",
"parttype6",  "parttype7",  "parttype8",
"parttype9"};
indextype AllocParts      = 0;
indextype FromCount       = 10;
indextype ExtendQty       = 5;
boolean   SwapType        = False;
longtype  MaxParts        = 0;
longtype  OneCent         = 0;
longtype  HalfCent        = 0;
longtype  Traverse_Limit  = 7;
unsigned  int   CurrentId = 0;
indextype OldParts        = 0;
unsigned int   StartCommit= 0;
longtype  LookUp_Asserts  = 0;
longtype  LookUp_NullAsserts  = 0;
longtype  Part_Asserts    = 0;
longtype  Part_NullAsserts= 0;
longtype  TestObj_Asserts = 0;
longtype  TestObj_NullAsserts = 0;
boolean   ExportParts     = False;
boolean   ExportGeneric   = False;
numtype   NumPersons      = 0;
numtype   Parts           = 0;
numtype   DrawObjs        = 0;
numtype   NamedObjs       = 0;
numtype   Points          = 0;
numtype   Persons         = 0;
static numtype   Iter1_Count     = 0;
static numtype   Iter2_Count     = 0;
static numtype   Iter3_Count     = 0;
static numtype   Iter4_Count     = 0;
boolean PartLib_Init
(ft F,lt Z,zz *Status);
void    PartLib_Topology
(void);
boolean PartLib_Create
(char         *DbName,    char         *DbFileName,
dbaccesstype  DbAccess,  boolean       UseVparts,
numtype       HndlRgns,  numtype       RgnHndls,
numtype       VhndlRgns, numtype       RgnVhndls,
numtype       XmemRgns,  numtype       RgnXmems,
ft F,lt Z,zz *Status,
tokentype    *PrimalTkn, PartLib     **PrimalObj);
boolean PartLib_ActivateDb
(tokentype    *PrimalTkn, char         *DbFileName,
ft F,lt Z,zz *Status,    PartLib     **PrimalObj);
boolean DrawPartPair_InitClass
(ft F,lt Z,zz *Status);
boolean Part_InitClass
(ft F,lt Z,zz *Status);
void    Part_Topology
(void);
boolean Part_Create
(tokentype    *AnchorTkn,
partidtype    Id,      longtype    X,
longtype      Y,       longtype    TypeNum,
ft F,lt Z,zz *Status,  tokentype  *PartTkn);
boolean Part_GetToken
(tokentype    *Anchor,  partidtype    PartId,
ft F,lt Z,zz *Status,  tokentype    *Token);
boolean Part_Connect
(tokentype    *PartTkn, partidtype  FromPart,
ft F,lt Z,zz *Status);
boolean Part_Traverse
(tokentype    *PartTkn, longtype    Level,
ft F,lt Z,zz *Status);
boolean Part_Reverse
(tokentype    *PartTkn, longtype    Level,
ft F,lt Z,zz *Status);
boolean Part_ExportTo
(tokentype    *PartTkn,
tokentype    *ApiTkn,  void         *FOId,
ft F,lt Z,zz *Status);
boolean Part_ImportFrom
(tokentype    *ApiTkn,  void         *FOId,
tokentype    *PartTkn, ft F,lt Z,zz *Status);
boolean Part_DisConnect
(tokentype    *PartTkn, ft F,lt Z,zz *Status);
boolean Part_Delete
(tokentype    *PartTkn, ft F,lt Z,zz *Status);
boolean BMT_Test
(char         *EdbName, char         *EdbFileName,
char         *DrwName, char         *DrwFileName,
char         *EmpName, char         *EmpFileName,
int           Count,   int           Loop,
int           Samples,
int           LookUps, int           Deletes,
int           Stuffs,  int           TraverseLimit,
int           PartPct, int           LookUpPct,
int          DeletePct,int           StuffPct,
int        DeleteDraws,int           DeleteParts,
boolean      CommitDbs,ft F,lt Z,zz *Status);
boolean BMT_Init
(char         *EdbName, char         *EdbFileName,
char         *DrwName, char         *DrwFileName,
char         *EmpName, char         *EmpFileName,
longtype      Count,   ft F,lt Z,zz *Status);
boolean BMT_ConfigAllClasses
(numtype       RgnEntrys,
numtype       AllocRgns, numtype       ExtendRgns,
numtype       AllocXs,   numtype       ExtendXs,
accesstype    AccessType,boolean       DiskCache,
numtype       CacheLimit,numtype       CacheLoad,
ft F,lt Z,zz *Status);
boolean BMT_CreateParts
(longtype      Count,   ft F,lt Z,zz *Status);
boolean BMT_LookUpParts
(longtype      LookUps, ft F,lt Z,zz *Status);
boolean BMT_DeleteParts
(longtype      Deletes, ft F,lt Z,zz *Status);
boolean BMT_CommitParts
(boolean       Release, ft F,lt Z,zz *Status);
boolean BMT_DeleteAllObjects
(ft F,lt Z,zz *Status);
boolean BMT_DeleteTestObjs
(ft F,lt Z,zz *Status);
boolean BMT_Validate
(tokentype    *PartTkn, ft F,lt Z,zz *Status);
boolean BMT_ValidateNamedDrawObjs
(ft F,lt Z,zz *Status);
boolean BMT_QueryOn
(tokentype    *PartTkn, boolean       TraceOn,
ft F,lt Z,zz *Status);
boolean BMT_DbTransaction
(ft F,lt Z,zz *Status);
boolean BMT_CommitPartDrawObj
(tokentype    *PartTkn, boolean       Release,
ft F,lt Z,zz *Status);
boolean BMT_DeletePartDrawObj
(tokentype    *PartTkn, ft F,lt Z,zz *Status);
boolean BMT_TraverseSets
(ft F,lt Z,zz *Status);
boolean BMT_Iter1
(tokentype    *Token,   numtype       ItNum,
ft F,lt Z,zz *Status);
boolean BMT_Iter2
(tokentype    *Token,   numtype       ItNum,
ft F,lt Z,zz *Status);
boolean BMT_Iter3
(tokentype    *Token,   numtype       ItNum,
ft F,lt Z,zz *Status);
boolean BMT_Iter4
(tokentype    *Token,   numtype       ItNum,
ft F,lt Z,zz *Status);
boolean BMT_ExportPart
(longtype      X,       longtype      Y,
parttype      Type,    ft F,lt Z,zz *Status);
boolean BMT_ImportPart
(longtype     *X,       longtype     *Y,
ft F,lt Z,zz *Status);
boolean BMT_BuildPersonLib
(tokentype    *LibToken,numtype       MaxPersons,
ft F,lt Z,zz *Status);
boolean BMT_InitQuerys
(ft F,lt Z,zz *Status);
#endif
#define null 0




longtype  Ctest_Count    = 0;
#define  PARMS_EXPECTED  30

/* 当前文件是./CINT2000\255.vortex\src\bitvec.c*/

#define  BITVEC_C
boolean BitVec_Create    (sizetype      AllocBits, indextype     ExtendBits,
ft F,lt Z,zz *Status,    bitvectype  **BitStruc)
{
farlongtype   ByteCount     = ((AllocBits | 7)+1) / 8;
static farlongtype   SizeOfBitVec  = (farlongtype )sizeof (BitVec);
if (DeBug)
if (sprintf  (Msg, "\n    BitVec_Create:: AllocBits=%3u; ExtendBits=%4u;\n",
AllocBits, ExtendBits))
TraceMsg (0,   Msg);
if (( *BitStruc            = (bitvectype *)VoidExtendCore (&SizeOfBitVec))
!= NULL)
if (((*BitStruc)->BitField = (bytetype   *)VoidExtendCore (&ByteCount))
!= NULL)
{
(*BitStruc)->AllocBits      = AllocBits;
(*BitStruc)->ExtendBits     = ExtendBits;
(*BitStruc)->BitLength      = AllocBits;
(*BitStruc)->HighestBitSet  = 0;
} else
*Status    = BitVec_CoreNoMore;
return(STAT);
}
boolean BitVec_PutBit    (bitvectype   *BitStruc,  indextype     BitNum,
bytetype      BitValue,  ft F,lt Z,zz *Status)
{
indextype        ByteNum   = BitNum >> 3;
BitValue   = BitValue ? 1 : 0;
if (BitNum > BitStruc->BitLength)
{
sprintf  (Msg,
"\n BitVec_PutBit:: BitNum=%2d > BitLength=%2d; BitValue= %3u\n",
BitNum, BitStruc->BitLength, BitValue);
TraceMsg (0,   Msg);
*Status = BitVec_OutOfRange;
} else  {
if (BitValue)
BitStruc->BitField[ ByteNum ] |= BitValue << (BitNum & 7);
else
BitStruc->BitField[ ByteNum ] &= ~(1 << (BitNum & 7));
}
if (BitStruc->HighestBitSet  < BitNum)
BitStruc->HighestBitSet  = BitNum;
if (DeBug)
if (sprintf  (Msg, "\n    BitVec_PutBit:: BitNum[%4d]=%2d;\n",
BitNum, BitValue))
TraceMsg (0,   Msg);
return(STAT);
}
boolean BitVec_GetBit    (bitvectype   *BitStruc,  indextype     BitNum,
ft F,lt Z,zz *Status,    bytetype     *BitValue)
{
indextype        ByteNum   = BitNum >> 3;
*BitValue    =  0;
if (BitNum  > BitStruc->BitLength)
{
sprintf  (Msg,
"\n BitVec_GetBit:: BitNum=%2d > BitCount=%2d; BitValue= %3u\n",
BitNum, BitStruc->BitLength, *BitValue);
TraceMsg (0,   Msg);
*Status   =  BitVec_OutOfRange;
} else
*BitValue =  (BitStruc->BitField[ ByteNum ] & 1 << (BitNum & 7)) ? 1: 0;
if (DeBug)
if (sprintf  (Msg, "\n    BitVec_GetBit:: BitNum=%2d; BitValue= %3u\n",
BitNum, *BitValue))
TraceMsg (0,   Msg);
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\bmt.c*/

#ifdef    DEBUG
#define  __DISPLAY_TIME__
#define  __DISPLAY_CORE__
#endif
#define BMT_C
#ifdef __DISPLAY_TIME__
#endif
/* 当前文件是./CINT2000\255.vortex\src\rects.h*/

#ifndef RECTS_01
#define RECTS_01
/* 当前文件是./CINT2000\255.vortex\src\rect.h*/

#ifndef RECT_01
#define RECT_01
/* 当前文件是./CINT2000\255.vortex\src\drawlib.h*/

#ifndef DRAWLIB_01
#define DRAWLIB_01
/* 当前文件是./CINT2000\255.vortex\src\sm.h*/

#ifndef SM_H
#define SM_H

indextype  CurrVchunkIndex  = 0;


#define Set_InitSet    SetInitSet
boolean SetDescGet (numtype       SetId,
ft F,lt Z,zz *Status,    handletype   *SetDesc);
boolean SetInitSet (handletype    SetDesc,   tokentype    *OwnerTkn,
numtype       AllocSize, numtype       Order,
ft F,lt Z,zz *Status);
boolean SetAddInto (handletype    SetDesc,   tokentype    *OwnerTkn,
tokentype    *MemberTkn, ft F,lt Z,zz *Status);
boolean SetOwnerOf (handletype    SetDesc,   tokentype    *MemberTkn,
ft F,lt Z,zz *Status,    tokentype    *OwnerTkn);
boolean SetFindIn  (handletype    SetDesc,   tokentype    *OwnerTkn,
addrtype      KeyValue,
ft F,lt Z,zz *Status,    tokentype    *MemberTkn);
boolean SetIterateOn
(handletype    SetDesc,   tokentype    *OwnerTkn,
iteratetype   Method,    ft F,lt Z,zz *Status);
boolean SetDeleteFrom
(handletype    SetDesc,
tokentype    *Member,    ft F,lt Z,zz *Status);
boolean SetDeleteSet
(handletype    SetDesc,
tokentype    *Owner,     ft F,lt Z,zz *Status);
boolean SetFirstOf (handletype    SetDesc,   tokentype    *OwnerTkn,
ft F,lt Z,zz *Status,    tokentype    *NodeTkn,
tokentype    *FirstTkn);
boolean SetNextOf  (handletype    SetDesc,   tokentype    *CurrentNode,
ft F,lt Z,zz *Status,
tokentype    *NodeTkn,   tokentype    *NextTkn);
#endif
/* 当前文件是./CINT2000\255.vortex\src\spcl.h*/

#ifndef SPCL_01
#define SPCL_01
#ifdef SPCL
typedef struct lTableSetHeadType
{
handletype     Handle;
handletype     BuildDesc;
handletype     lOwnerObject;
handletype     BucketDir;
indextype      MaxBuckets;
numtype        Entries;
}             ltablesethead;
typedef struct lTableNodeType
{
handletype     Handle;
inttype        lPrevLink;
inttype        lNextLink;
handletype     lMemberObject;
}             ltablenode;
#endif
boolean    SpclAddIntoTable
(handletype    SetDescHndl,
tokentype    *OwnerTkn,     tokentype     *MemberTkn,
ft F,lt Z,zz *Status,       tokentype     *NodeTkn);
boolean    SpclFindInTable
(handletype     SetDescHndl,
tokentype     *OwnerTkn,    addrtype       KeyValue,
ft F,lt Z,zz  *Status,
tokentype     *NodeTkn,     tokentype     *MemberTkn);
boolean    SpclDeleteFromTable
(handletype     SetDescHndl,
tokentype     *MemberTkn,   ft F,lt Z,zz  *Status);
boolean    SpclDeleteTableSet
(handletype     SetDescHndl, tokentype     *OwnerTkn,
ft F,lt Z,zz  *Status);
#ifdef SPCL
numtype    SpclTableGetBucket
(char          *KeyName,     numtype        MaxBuckets,
ft F,lt Z,zz *Status);
#endif
#endif
#define        Dbl_Pie   (double )3.1415927
#ifdef DRAWLIB

#else
































































#endif
typedef struct TypeDrawLib
{
addrtype          That;
tokentype         Token;
numtype           DbNum;
wordtype          EnvType;
numtype           DescNum;
slottokentype     PrimalSlotAttr;
slottoken         PrimalGroupSlotAttr;
numtype           DrawId;
grp(tokentype)    DrawObjDir;
vgrp(tokentype)   VdrawObjDir;
ownerhandle       OwnerDrawObjs;
ownerhandle       OwnerNamedDrawObjs;
ownerhandle       OwnerLibRectangles;
} DrawLib;
DrawLib   *DrawLib01              = NullPtr;
tokentype  LibTkn010              = Null_Token;
tokentype  VchunkTkn00            = Null_Token;
numtype    VpartsDir              = 0;
longtype   PartCount              = 0;
boolean    DrawBug                = False;
tokentype  RectListTkn            = Null_Token;

boolean DrawLib_InitLibrary
(ft F,lt Z,zz *Status);
boolean DrawLib_InitClass
(ft F,lt Z,zz *Status);
boolean DrawLib_InitDb
(char         *DbName,  char         *DbFileName,
numtype       Option,
ft F,lt Z,zz *Status,  tokentype    *PrimalTkn);
boolean DrawLib_QueryDb
(char         *DbName,
ft F,lt Z,zz *Status,    boolean      *Active);
boolean DrawLib_CreateDb
(char         *DbName,    char         *DbFileName,
dbaccesstype  DbAccess,
numtype       HndlRgns,  numtype       RgnHndls,
numtype       VhndlRgns, numtype       RgnVhndls,
numtype       XmemRgns,  numtype       RgnXmems,
ft F,lt Z,zz *Status,
tokentype    *PrimalTkn, DrawLib     **PrimalObj);
boolean DrawLib_ActivateDbByName
(char         *DbName,    char         *DbFileName,
dbaccesstype  AccessType,
ft F,lt Z,zz *Status,    DrawLib     **PrimalObj);
boolean DrawLib_ActivateDbByToken
(tokentype    *PrimalTkn, char         *DbFileName,
dbaccesstype  AccessType,
ft F,lt Z,zz *Status,    DrawLib     **PrimalObj);
boolean DrawLib_DeleteDb
(tokentype    *PrimalTkn, ft F,lt Z,zz *Status);
numtype DrawLib_NewId
(ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\drawobj.h*/

#ifndef DRAWOBJ_01
#define DRAWOBJ_01
#ifndef DRAWLIB_01
#ifdef DRAWOBJ
numtype    MemberNamedDrawObjs_Attr = 0;
numtype    Id_Attr                = 0;
numtype    Nam_Attr               = Nam_AttrNum;
numtype    DrawObj_Class          = 0;
numtype    NamedDrawObj_Class     = 0;
#else





#endif
#endif
typedef struct DrawObj
{
addrtype          That;
tokentype         Token;
numtype           Id;
memberhandle      MemberDrawObjs;
slottoken         PartObjSlotAttr;
boolean      (*draw)     (struct DrawObj  *This,  ft F,lt Z,zz *Status);
lt64         (*area)     (struct DrawObj  *This,  ft F,lt Z,zz *Status);
boolean      (*destruct) (struct DrawObj **This,  deletetype    DbEvent,
ft F,lt Z,zz *Status);
}DrawObj;
typedef struct NamedDrawObj
{
addrtype          That;
tokentype         Token;
numtype           Id;
memberhandle      MemberDrawObjs;
slottoken         PartObjSlotAttr;
boolean      (*draw)    (struct NamedDrawObj  *This, ft F,lt Z,zz *Status);
lt64         (*area)    (struct NamedDrawObj  *This, ft F,lt Z,zz *Status);
boolean      (*destruct)(struct NamedDrawObj **This, deletetype    DbEvent,
ft F,lt Z,zz *Status);
nametype          Nam;
memberhandle      MemberNamedDrawObjs;
}NamedDrawObj;
boolean DrawObj_InitClass
(ft F,lt Z,zz *Status);
DrawObj *DrawObj_new0
(tokentype    *AnchorTkn, ft F,lt Z,zz *Status);
DrawObj *DrawObj_new1
(tokentype    *AnchorTkn, numtype       ClassId,
ft F,lt Z,zz *Status);
DrawObj *DrawObj_new2
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
boolean DrawObj_export
(DrawObj      *This,      ft F,lt Z,zz *Status);
boolean DrawObj_draw
(DrawObj      *This,      ft F,lt Z,zz *Status);
lt64    DrawObj_area
(DrawObj      *This,      ft F,lt Z,zz *Status);
boolean DrawObj_delete
(DrawObj     **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
boolean DrawObj_Create0
(tokentype    *Anchor,
ft F,lt Z,zz *Status,    tokentype    *Token);
boolean DrawObj_Create1
(tokentype    *Anchor,    numtype       ClassId,
ft F,lt Z,zz *Status,    tokentype    *Token);
boolean DrawObj_Import
(tokentype    *DrawTkn,   ft F,lt Z,zz *Status);
boolean DrawObj_Export
(tokentype    *DrawTkn,   ft F,lt Z,zz *Status);
boolean DrawObjs_InitClass
(ft F,lt Z,zz *Status);
boolean OwnerOfDrawObjs
(tokentype    *Member,
ft F,lt Z,zz *Status,    tokentype    *Owner);
boolean DrawObjs_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status);
boolean DrawObjs_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn);
inttype DrawObjs_IterateOn
(tokentype    *OwnerTkn,  inttype       ItNum,
ft F,lt Z,zz *Status,
tokentype    *NodeTkn,   tokentype    *Token);
boolean NamedDrawObj_InitClass
(ft F,lt Z,zz *Status);
NamedDrawObj *NamedDrawObj_new0
(tokentype    *AnchorTkn, ft F,lt Z,zz *Status);
NamedDrawObj *NamedDrawObj_new1
(tokentype    *AnchorTkn, numtype       ClassId,
ft F,lt Z,zz *Status);
NamedDrawObj *NamedDrawObj_new2
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
boolean NamedDrawObj_Create0
(tokentype    *Anchor,
ft F,lt Z,zz *Status,    tokentype    *Token);
boolean NamedDrawObj_Create1
(tokentype    *Anchor,    numtype       ClassId,
nametype      Nam,
ft F,lt Z,zz *Status,    tokentype    *Token);
boolean NamedDrawObj_ExportFunc
(tokentype    *Token,     indextype     IterNum,
ft F,lt Z,zz *Status);
boolean NamedDrawObj_delete
(NamedDrawObj **This,     deletetype    DbEvent,
ft F,lt Z,zz *Status);
boolean NamedDrawObjs_InitClass
(ft F,lt Z,zz *Status);
boolean NamedDrawObjs_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status);
boolean NamedDrawObjs_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn);
boolean NamedDrawObjs_IterateOn
(tokentype    *OwnerTkn,  treeiterfunc  IterFunc,
ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\tree01.h*/

#ifndef SPCL1_01
#define SPCL1_01
numtype    bTreeSetHead_Class = 0;
static numtype    TempKeys_Attr      = 0;
static numtype    TempHandles_Attr   = 0;
static numtype    TempLeafs_Attr     = 0;
boolean    SpclAddIntoTree
(handletype    SetDescHndl,
tokentype    *OwnerTkn,     tokentype     *MemberTkn,
ft F,lt Z,zz *Status,       tokentype     *NodeTkn);
boolean    SpclFindInTree
(handletype     SetDescHndl,
tokentype     *OwnerTkn,    addrtype       KeyValue,
ft F,lt Z,zz  *Status,
tokentype     *NodeTkn,     tokentype     *MemberTkn);
boolean    SpclFindIn2aryTree
(handletype     SetDescHndl, tokentype     *OwnerTkn,
addrtype       KeyValue,    addrtype       Key2aryVal,
ft F,lt Z,zz  *Status,
tokentype     *NodeTkn,     tokentype     *MemberTkn);
boolean    SpclTraverseTree
(handletype     SetDescHndl, tokentype     *OwnerTkn,
treeiterfunc   IterFunc,    ft F,lt Z,zz  *Status);
boolean    Spcl_TreeIterateOn
(numtype        SetId,       tokentype     *OwnerTkn,
ft F,lt Z,zz  *Status,      indextype     *KeyPos,
numtype       *ItNum,       tokentype     *MemberTkn,
addrtype      *SetHead,     indextype     *LeafNode);
boolean    SpclDeleteFromTree
(handletype     SetDescHndl,
tokentype     *MemberTkn,   ft F,lt Z,zz  *Status);
boolean    SpclDeleteTree
(handletype     SetDescHndl, tokentype     *OwnerTkn,
ft F,lt Z,zz  *Status);
boolean    Tree_Create
(handletype    SetDescHndl,  tokentype     *OwnerTkn,
numtype       TreeOrder,    numtype        AllocKeys,
sizetype      KeySize,      typetype       KeyType,
ft F,lt Z,zz *Status,       tokentype     *TreeTkn);
#ifdef TREE01
boolean    Tree_Compare2aryKey
(ltreesethead *SetHead,      handletype    ObjHandle,
ft F,lt Z,zz *Status);
#endif
#endif
/* 当前文件是./CINT2000\255.vortex\src\point.h*/

#ifndef POINT_01
#define POINT_01
#ifndef DRAWLIB_01
#ifdef POINT
numtype    xCoord_Attr            = 0;
numtype    yCoord_Attr            = 0;
numtype    Theta_Attr             = 0;
numtype    Radius_Attr            = 0;
numtype    Point_Class            = 0;
numtype    CartesianPoint_Class   = 0;
numtype    PolarPoint_Class       = 0;
#else







#endif
#endif
typedef struct Point
{
addrtype          That;
tokentype         Token;
short            (*Point_x)      (struct Point   *This);
short            (*Point_y)      (struct Point   *This);
doubletype       (*Point_Theta)  (struct Point   *This);
doubletype       (*Point_Radius) (struct Point   *This);
} Point;
typedef struct CartesianPoint
{
addrtype          That;
tokentype         Token;
short            (*Point_x)      (struct CartesianPoint *This);
short            (*Point_y)      (struct CartesianPoint *This);
doubletype       (*Point_Theta)  (struct CartesianPoint *This);
doubletype       (*Point_Radius) (struct CartesianPoint *This);
shorttype         xCoord;
shorttype         yCoord;
} CartesianPoint;
typedef struct PolarPoint
{
addrtype          That;
tokentype         Token;
short            (*Point_x)      (struct PolarPoint     *This);
short            (*Point_y)      (struct PolarPoint     *This);
doubletype       (*Point_Theta)  (struct PolarPoint     *This);
doubletype       (*Point_Radius) (struct PolarPoint     *This);
doubletype        Theta;
doubletype        Radius;
} PolarPoint;
boolean     Point_InitClass
(ft F,lt Z,zz *Status);
tokentype   Point_GetToken(Point   *This);
short   Point_x   (Point        *This);
short   Point_y   (Point        *This);
double  Point_Theta
(Point        *This);
double  Point_Radius
(Point        *This);
boolean CartesianPoint_InitClass
(ft F,lt Z,zz *Status);
CartesianPoint *CartesianPoint_New
(size_t        ClassSize);
CartesianPoint *CartesianPoint_new0
(tokentype    *AnchorTkn,
short         x,         short         y,
ft F,lt Z,zz *Status);
CartesianPoint *CartesianPoint_new1
(tokentype    *PointTkn,  ft F,lt Z,zz *Status);
short   CartesianPoint_x
(CartesianPoint *This);
short   CartesianPoint_y
(CartesianPoint *This);
double  CartesianPoint_Theta
(CartesianPoint *This);
double  CartesianPoint_Radius
(CartesianPoint *This);
void    CartesianPoint_show
(CartesianPoint *This);
boolean CartesianPoint_delete
(CartesianPoint **This,   deletetype    DbEvent,
ft F,lt Z,zz    *Status);
boolean PolarPoint_InitClass
(ft F,lt Z,zz *Status);
PolarPoint *PolarPoint_New
(size_t        ClassSize);
PolarPoint *PolarPoint_new0
(tokentype    *AnchorTkn,
double        Theta,     double        Radius,
ft F,lt Z,zz *Status);
PolarPoint *PolarPoint_new1
(tokentype    *PointTkn,  ft F,lt Z,zz *Status);
short   PolarPoint_x
(PolarPoint   *This);
short   PolarPoint_y
(PolarPoint   *This);
double  PolarPoint_Theta
(PolarPoint   *This);
double  PolarPoint_Radius
(PolarPoint   *This);
void    PolarPoint_show
(PolarPoint   *This);
boolean PolarPoint_delete
(PolarPoint  **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
#endif
#ifndef DRAWLIB_01
#ifdef RECT
numtype    MemberLibRectangles_Attr = 0;
numtype    Id_Attr                = 0;
numtype    Nam_Attr               = Nam_AttrNum;
numtype    Origin_Attr            = 0;
numtype    Extent_Attr            = 0;
numtype    XyOrigin_Attr          = 0;
numtype    XyExtent_Attr          = 0;
numtype    Xcoords_Attr           = 0;
numtype    Ycoords_Attr           = 0;
numtype    XyCoords_Attr          = 0;
numtype    XyDir_Attr             = 0;
numtype    Name_Attr              = 0;
numtype    RefOrigin_Attr         = 0;
numtype    RefExtent_Attr         = 0;
numtype    PortHole_Attr          = 0;
numtype    PortId_Attr            = 0;
numtype    MemberAplPorts_Attr    = 0;
numtype    Port_XyOrigin_Attr     = 0;
numtype    Port_XyExtent_Attr     = 0;
numtype    Xarray_Attr            = 0;
numtype    Yarray_Attr            = 0;
numtype    xVarray_Attr           = 0;
numtype    yVarray_Attr           = 0;
numtype    Rectangle_Class        = 0;
numtype    XyRect_Class           = 0;
numtype    NamedXyRect_Class      = 0;
numtype    ArrayRect_Class        = 0;
numtype    DblPtrRect_Class       = 0;
numtype    VarrayRect_Class       = 0;
numtype    IntChunkRect_Class     = 0;
numtype    VchunkRect_Class       = 0;
numtype    RefRect_Class          = 0;
numtype    PortRect_Class         = 0;
numtype    AplObj_Class           = 0;
numtype    PortObj_Class          = 0;
numtype    DbmsToken_Class        = 0;
#else




































#endif
#endif
typedef  enum             TypeDrawObj
{aRectangle,  aXyRect,      aNamedXyRect,  aArrayRect,
aDblPtrRect, aVarrayRect,  aIntChunkRect,
aRefRect,    aVchunkRect,
aNonDrawObj =EXT_ENUM                   } drawobjtype;
typedef struct Rectangle
{
addrtype              That;
tokentype             Token;
numtype               Id;
memberhandle          MemberDrawObjs;
slottoken             PartObjSlotAttr;
boolean  (*draw)     (struct Rectangle       *This,  ft F,lt Z,zz *Status);
lt64     (*area)     (struct Rectangle       *This,  ft F,lt Z,zz *Status);
boolean  (*destruct) (struct Rectangle      **This,  deletetype    DbEvent,
ft F,lt Z,zz *Status);
Point                *Origin;
Point                *Extent;
memberhandle          MemberLibRectangles;
} Rectangle;
boolean Rectangle_InitClass
(ft F,lt Z,zz *Status);
Rectangle  *Rectangle_new0
(tokentype    *AnchorTkn,
short         i0,        short         i1,
short         i01,       ft F,lt Z,zz *Status);
Rectangle  *Rectangle_new1
(tokentype    *AnchorTkn,
Point        *o,         Point        *e,
ft F,lt Z,zz *Status);
Rectangle  *Rectangle_new2
(tokentype    *AnchorTkn,
Point        *o,         Point        *e,
ft F,lt Z,zz *Status);
Rectangle  *Rectangle_new3
(tokentype    *AnchorTkn,
tokentype    *oTkn,      tokentype    *eTkn,
ft F,lt Z,zz *Status);
Rectangle  *Rectangle_new4
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
lt64    Rectangle_area
(Rectangle    *This,      ft F,lt Z,zz *Status);
boolean Rectangle_draw
(Rectangle    *This,      ft F,lt Z,zz *Status);
void    Rectangle_show
(Rectangle    *This);
boolean Rectangle_error
(Rectangle    *This,      char         *msg,
ft F,lt Z,zz *Status);
boolean Rectangle_delete
(Rectangle   **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
boolean LibRectangles_InitClass
(ft F,lt Z,zz *Status);
boolean OwnerOfLibRectangles
(tokentype    *Member,
ft F,lt Z,zz *Status,    tokentype    *Owner);
boolean LibRectangles_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status);
boolean LibRectangles_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn);
boolean LibRectangles_IterateOn
(tokentype    *OwnerTkn,  treeiterfunc  IterFunc,
ft F,lt Z,zz *Status);
#endif
typedef struct XyPoint
{
shorttype             xCoord;
shorttype             yCoord;
} XyPoint;
typedef struct XyRect
{
addrtype              That;
tokentype             Token;
numtype               Id;
memberhandle          MemberDrawObjs;
slottoken             PartObjSlotAttr;
boolean  (*draw)     (struct XyRect          *This,  ft F,lt Z,zz *Status);
lt64     (*area)     (struct XyRect          *This,  ft F,lt Z,zz *Status);
boolean  (*destruct) (struct XyRect         **This,  deletetype    DbEvent,
ft F,lt Z,zz *Status);
XyPoint               XyOrigin;
XyPoint               XyExtent;
} XyRect;
typedef struct NamedXyRect
{
addrtype             That;
tokentype            Token;
numtype              Id;
memberhandle         MemberDrawObjs;
slottoken            PartObjSlotAttr;
boolean  (*draw)     (struct NamedXyRect     *This,  ft F,lt Z,zz *Status);
lt64     (*area)     (struct NamedXyRect     *This,  ft F,lt Z,zz *Status);
boolean  (*destruct) (struct NamedXyRect    **This,  deletetype    DbEvent,
ft F,lt Z,zz *Status);
nametype             Nam;
memberhandle         MemberNamedDrawObjs;
XyPoint              XyOrigin;
XyPoint              XyExtent;
char                *Name;
} NamedXyRect;
typedef struct ArrayRect
{
addrtype              That;
tokentype             Token;
numtype               Id;
memberhandle          MemberDrawObjs;
slottoken             PartObjSlotAttr;
boolean  (*draw)     (struct ArrayRect       *This,  ft F,lt Z,zz *Status);
lt64     (*area)     (struct ArrayRect       *This,  ft F,lt Z,zz *Status);
boolean  (*destruct) (struct ArrayRect      **This,  deletetype    DbEvent,
ft F,lt Z,zz *Status);
shorttype            *Xarray;
shorttype            *Yarray;
} ArrayRect;
typedef struct DblPtrRect
{
addrtype              That;
tokentype             Token;
numtype               Id;
memberhandle          MemberDrawObjs;
slottoken             PartObjSlotAttr;
boolean  (*draw)     (struct DblPtrRect      *This,  ft F,lt Z,zz *Status);
lt64     (*area)     (struct DblPtrRect      *This,  ft F,lt Z,zz *Status);
boolean  (*destruct) (struct DblPtrRect     **This,  deletetype    DbEvent,
ft F,lt Z,zz *Status);
short               **XyCoords;
} DblPtrRect;
typedef struct VarrayRect
{
addrtype              That;
tokentype             Token;
numtype               Id;
memberhandle          MemberDrawObjs;
slottoken             PartObjSlotAttr;
boolean  (*draw)     (struct VarrayRect      *This,  ft F,lt Z,zz *Status);
lt64     (*area)     (struct VarrayRect      *This,  ft F,lt Z,zz *Status);
boolean  (*destruct) (struct VarrayRect     **This,  deletetype    DbEvent,
ft F,lt Z,zz *Status);
ShortArray            xVarray;
ShortArray            yVarray;
} VarrayRect;
typedef struct IntChunkRect
{
addrtype              That;
tokentype             Token;
numtype               Id;
memberhandle          MemberDrawObjs;
slottoken             PartObjSlotAttr;
boolean  (*draw)     (struct IntChunkRect    *This,  ft F,lt Z,zz *Status);
lt64     (*area)     (struct IntChunkRect    *This,  ft F,lt Z,zz *Status);
boolean  (*destruct) (struct IntChunkRect   **This,  deletetype    DbEvent,
ft F,lt Z,zz *Status);
IntChunk              Xcoords;
IntChunk              Ycoords;
} IntChunkRect;
typedef struct VchunkRect
{
addrtype              That;
tokentype             Token;
numtype               Id;
memberhandle          MemberDrawObjs;
slottoken             PartObjSlotAttr;
boolean  (*draw)     (struct VchunkRect      *This,  ft F,lt Z,zz *Status);
lt64     (*area)     (struct VchunkRect      *This,  ft F,lt Z,zz *Status);
boolean  (*destruct) (struct VchunkRect     **This,  deletetype    DbEvent,
ft F,lt Z,zz *Status);
vchunktoken           XyDir;
} VchunkRect;
typedef struct RefPoint
{
Point                *ObjAddr;
tokentype             ObjTkn;
} RefPoint;
typedef struct RefRect
{
addrtype              That;
tokentype             Token;
numtype               Id;
memberhandle          MemberDrawObjs;
slottoken             PartObjSlotAttr;
boolean  (*draw)     (struct RefRect         *This,  ft F,lt Z,zz *Status);
lt64     (*area)     (struct RefRect         *This,  ft F,lt Z,zz *Status);
boolean  (*destruct) (struct RefRect        **This,  deletetype    DbEvent,
ft F,lt Z,zz *Status);
Reference(Point)      RefOrigin;
Reference(Point)      RefExtent;
} RefRect;
typedef struct PortRect
{
addrtype              That;
tokentype             Token;
numtype               Id;
memberhandle          MemberDrawObjs;
slottoken             PartObjSlotAttr;
boolean  (*draw)     (struct PortRect        *This,  ft F,lt Z,zz *Status);
lt64     (*area)     (struct PortRect        *This,  ft F,lt Z,zz *Status);
boolean  (*destruct) (struct PortRect       **This,  deletetype    DbEvent,
ft F,lt Z,zz *Status);
addrtype              PortHole;
numtype               PortId;
memberhandle          MemberAplPorts;
Port(CartesianPoint)  Port_XyOrigin;
Port(CartesianPoint)  Port_XyExtent;
} PortRect;
boolean Rects_InitLibrary
(ft F,lt Z,zz *Status);
boolean XyRect_InitClass
(ft F,lt Z,zz *Status);
XyRect
*XyRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status);
XyRect
*XyRect_new1
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
lt64    XyRect_area
(XyRect       *This,      ft F,lt Z,zz *Status);
boolean XyRect_draw
(XyRect       *This,      ft F,lt Z,zz *Status);
boolean XyRect_dump
(XyRect       *This,      ft F,lt Z,zz *Status);
void    XyRect_show
(XyRect       *This);
boolean XyRect_delete
(XyRect      **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
boolean NamedXyRect_InitClass
(ft F,lt Z,zz *Status);
NamedXyRect
*NamedXyRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status);
NamedXyRect
*NamedXyRect_new1
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
lt64    NamedXyRect_area
(NamedXyRect  *This,      ft F,lt Z,zz *Status);
boolean NamedXyRect_draw
(NamedXyRect  *This,      ft F,lt Z,zz *Status);
boolean NamedXyRect_dump
(NamedXyRect  *This,      ft F,lt Z,zz *Status);
void    NamedXyRect_show
(NamedXyRect  *This);
boolean NamedXyRect_delete
(NamedXyRect **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
boolean ArrayRect_InitClass
(ft F,lt Z,zz *Status);
ArrayRect
*ArrayRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status);
ArrayRect
*ArrayRect_new1
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
lt64    ArrayRect_area
(ArrayRect    *This,      ft F,lt Z,zz *Status);
boolean ArrayRect_draw
(ArrayRect    *This,      ft F,lt Z,zz *Status);
boolean ArrayRect_dump
(ArrayRect    *This,      ft F,lt Z,zz *Status);
void    ArrayRect_show
(ArrayRect    *This);
boolean ArrayRect_delete
(ArrayRect   **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
boolean DblPtrRect_InitClass
(ft F,lt Z,zz *Status);
DblPtrRect
*DblPtrRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status);
DblPtrRect
*DblPtrRect_new1
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
lt64    DblPtrRect_area
(DblPtrRect   *This,      ft F,lt Z,zz *Status);
boolean DblPtrRect_draw
(DblPtrRect   *This,      ft F,lt Z,zz *Status);
boolean DblPtrRect_dump
(DblPtrRect   *This,      ft F,lt Z,zz *Status);
void    DblPtrRect_show
(DblPtrRect   *This);
boolean DblPtrRect_delete
(DblPtrRect  **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
boolean VarrayRect_InitClass
(ft F,lt Z,zz *Status);
VarrayRect
*VarrayRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status);
VarrayRect
*VarrayRect_new1
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
lt64    VarrayRect_area
(VarrayRect   *This,      ft F,lt Z,zz *Status);
boolean VarrayRect_draw
(VarrayRect   *This,      ft F,lt Z,zz *Status);
boolean VarrayRect_dump
(VarrayRect   *This,      ft F,lt Z,zz *Status);
void    VarrayRect_show
(VarrayRect   *This);
boolean VarrayRect_delete
(VarrayRect  **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
boolean IntChunkRect_InitClass
(ft F,lt Z,zz *Status);
IntChunkRect
*IntChunkRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status);
IntChunkRect
*IntChunkRect_new1
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
lt64    IntChunkRect_area
(IntChunkRect *This,      ft F,lt Z,zz *Status);
boolean IntChunkRect_draw
(IntChunkRect *This,      ft F,lt Z,zz *Status);
boolean IntChunkRect_dump
(IntChunkRect *This,      ft F,lt Z,zz *Status);
void    IntChunkRect_show
(IntChunkRect *This);
boolean IntChunkRect_delete
(IntChunkRect **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
boolean VchunkRect_InitClass
(ft F,lt Z,zz *Status);
VchunkRect
*VchunkRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status);
VchunkRect
*VchunkRect_new1
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
lt64    VchunkRect_area
(VchunkRect   *This,      ft F,lt Z,zz *Status);
boolean VchunkRect_draw
(VchunkRect   *This,      ft F,lt Z,zz *Status);
boolean VchunkRect_dump
(VchunkRect   *This,      ft F,lt Z,zz *Status);
void    VchunkRect_show
(VchunkRect   *This);
boolean VchunkRect_delete
(VchunkRect  **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
boolean RefRect_InitClass
(ft F,lt Z,zz *Status);
RefRect
*RefRect_new0
(tokentype    *AnchorTkn,
short         i0,        short         i1,
short         i01,       ft F,lt Z,zz *Status);
RefRect
*RefRect_new1
(tokentype    *AnchorTkn,
Point        *o,         Point        *e,
ft F,lt Z,zz *Status);
RefRect
*RefRect_new2
(tokentype    *AnchorTkn,
tokentype    *oTkn,      tokentype    *eTkn,
ft F,lt Z,zz *Status);
RefRect
*RefRect_new3
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
lt64    RefRect_area
(RefRect      *This,      ft F,lt Z,zz *Status);
boolean RefRect_draw
(RefRect      *This,      ft F,lt Z,zz *Status);
boolean RefRect_dump
(RefRect      *This,      ft F,lt Z,zz *Status);
void    RefRect_show
(RefRect      *This);
boolean RefRect_delete
(RefRect     **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
boolean PortRect_InitClass
(ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\emplib.h*/

#ifndef PERSONLIB_01
#define PERSONLIB_01

numtype    PersonLib_Class           = 0;
numtype    Descriptor_Attr           = 0;
numtype    MaxId_Attr                = 0;
numtype    PersonObjs_Set            = 0;
numtype    OwnerPersonObjs_Attr      = 0;
numtype    MemberPersonObjs_Attr     = 0;
numtype    PersonNames_Set           = 0;
numtype    OwnerPersonNames_Attr     = 0;
numtype    MemberPersonNames_Attr    = 0;
numtype    CompanyDB_Class           = 0;
numtype    CompanyName_Attr          = 0;
numtype    AddressTkn_Attr           = 0;

typedef struct TypePersonLib
{
addrtype              That;
tokentype             Token;
numtype               DbNum;
wordtype              EnvType;
numtype               DescNum;
slottokentype         PrimalSlotAttr;
slottoken             PrimalGroupSlotAttr;
char                 *Descriptor;
numtype               MaxId;
ownerhandle           OwnerPersonObjs;
ownerhandle           OwnerPersonNames;
} PersonLib;
typedef struct Company
{
addrtype              That;
tokentype             Token;
numtype               DbNum;
wordtype              EnvType;
numtype               DescNum;
slottokentype         PrimalSlotAttr;
slottoken             PrimalGroupSlotAttr;
char                 *Descriptor;
numtype               MaxId;
ownerhandle           OwnerPersonObjs;
ownerhandle           OwnerPersonNames;
char                  CompanyName[128];
tokentype             AddressTkn;
} Company;
PersonLib *PersonLib01               = NullPtr;
tokentype  EmpTkn010                 = Null_Token;
longtype   PersonCount               = 0;
boolean    PersonBug                 = False;
boolean PersonLib_InitLibrary
(ft F,lt Z,zz *Status);
boolean PersonLib_InitClass
(ft F,lt Z,zz *Status);
#ifdef INCLUDE_ALL_CODE
void    PersonLib_Topology
(void);
#endif
boolean Person_InitDb
(char         *DbName,  char         *DbFileName,
numtype       Option,
ft F,lt Z,zz *Status,  tokentype    *PrimalTkn);
boolean PersonLib_QueryDb
(char         *DbName,
ft F,lt Z,zz *Status,    boolean      *Active);
boolean PersonLib_CreateDb
(char         *DbName,    char         *DbFileName,
dbaccesstype  DbAccess,
numtype       HndlRgns,  numtype       RgnHndls,
numtype       VhndlRgns, numtype       RgnVhndls,
numtype       XmemRgns,  numtype       RgnXmems,
ft F,lt Z,zz *Status,
tokentype    *PrimalTkn, PersonLib   **PrimalObj);
boolean PersonLib_ActivateDbByName
(char         *DbName,    char         *DbFileName,
dbaccesstype  AccessType,
ft F,lt Z,zz *Status,    PersonLib   **PrimalObj);
boolean PersonLib_ActivateDbByToken
(tokentype    *PrimalTkn, char         *DbFileName,
dbaccesstype  AccessType,
ft F,lt Z,zz *Status,    PersonLib   **PrimalObj);
boolean PersonLib_DeleteDb
(tokentype    *PrimalTkn, ft F,lt Z,zz *Status);
boolean PersonObjs_InitClass
(ft F,lt Z,zz *Status);
boolean PersonObjs_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status);
boolean PersonObjs_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn);
boolean PersonObjs_IterateOn
(tokentype    *OwnerTkn,  treeiterfunc  IterFunc,
ft F,lt Z,zz *Status);
boolean PersonNames_InitClass
(ft F,lt Z,zz *Status);
boolean PersonNames_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status);
boolean PersonNames_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn);
boolean PersonNames_IterateOn
(tokentype    *OwnerTkn,  treeiterfunc  IterFunc,
ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\empobj.h*/

#ifndef PERSON_01
#define PERSON_01
typedef     enum  {aResidence,      aBusiness,
aMailDrop,       aNonAddressType=EXT_ENUM}   addresstype;
#ifndef BMT_01
typedef     longtype   datetype;
#endif
typedef     longtype   timetype;

typedef struct ImportSpecType
{
numtype               ClassId;
numtype               AttrId;
} importspec;
typedef char           inputline[MAXLINE+1];
typedef struct Address
{
addrtype              That;
tokentype             Token;
tokentype             OwnerTkn;
addresstype           AddressType;
varyingtype           Street;
varyingtype           Suite;
nametype              City;
nametype              District;
nametype              State;
nametype              Country;
lt64                  ZipCode;
char                  Phone[12];
char                  Fax[12];
} Address;
typedef struct RefAddress
{
Address          *ObjAddr;
tokentype         ObjTkn;
}RefAddress;
typedef struct Person
{
addrtype              That;
tokentype             Token;
numtype               PersonId;
nametype              LastName;
nametype              FirstName;
char                  Gender;
Reference(Address)    Residence;
	datetype              InputDate;
	timetype              InputTime;
	datetype              BirthDate;
	int                   MaritalStatus;
char                 *Descriptor;
nametype              PersonalAssoc;
	handletype	         *Children;
memberhandle          MemberPersonObjs;
memberhandle          MemberPersonNames;
ownertoken            OwnerPersonParts;
} Person;
boolean Address_InitClass
(ft F,lt Z,zz *Status);
boolean Person_InitClass
(ft F,lt Z,zz *Status);
Person *Person_new0
(tokentype    *Anchor,    ft F,lt Z,zz *Status);
Person *Person_new1
(tokentype    *Anchor,    numtype       ClassId,
ft F,lt Z,zz *Status);
Person *Person_new2
(tokentype    *PersonTkn, ft F,lt Z,zz *Status);
boolean Person_Create0
(tokentype    *Anchor,
ft F,lt Z,zz *Status,    tokentype    *Token);
boolean Person_Create1
(tokentype    *Anchor,    numtype       ClassId,
ft F,lt Z,zz *Status,    tokentype    *Token);
boolean Person_Import
(tokentype    *LibTkn,     char         *ImportField,
importspec   *TabFields,  numtype       TabCount,
ft F,lt Z,zz *Status,     tokentype    *PersonTkn);
boolean Person_Export
(tokentype    *PersonTkn, filename      OutputFile,
ft F,lt Z,zz *Status);
boolean Person_delete
(Person      **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
#ifdef INCLUDE_ALL_CODE
void    Person_Topology   (void);
void    Address_Topology  (void);
#endif
boolean PersonParts_InitClass
(ft F,lt Z,zz *Status);
boolean PersonParts_OwnerOf
(tokentype    *Member,
ft F,lt Z,zz *Status,    tokentype    *Owner);
boolean PersonParts_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status);
boolean PersonParts_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn);
inttype PersonParts_IterateOn
(tokentype    *OwnerTkn,  inttype       ItNum,
ft F,lt Z,zz *Status,
tokentype    *NodeTkn,   tokentype    *Token);
#endif
/* 当前文件是./CINT2000\255.vortex\src\list01.h*/

#ifndef LIST01_H
#define LIST01_H
typedef struct DbListHeadDesc
{
addrtype      That;
handletype    Handle;
idtype        DbId;
idtype        CoreDbId;
nametype      ListName;
tokentype     OwnerTkn;
handletype    FirstNode;
handletype    LastNode;
handletype    CurrentNode;
numtype       NodeCount;
numtype       NodeClass;
}              listheadtype;
typedef struct DbListNodeDesc
{
handletype    Handle;
handletype    PrevNode;
handletype    NextNode;
tokentype     NodeObject;
}              listnodetype;

numtype  DbListHead_Class = 0;
numtype  DbListNode_Class = 0;

boolean List01_Init
(ft F,lt Z,zz *Status);
boolean List01_Create
(tokentype    *Anchor,    tokentype    *Owner,
char         *NameOfList,
numtype       CompCode,  numtype       WithinCode,
ft F,lt Z,zz *Status,    tokentype    *ListTkn);
boolean List01_FindListHead
(tokentype    *Anchor,    char         *NameOfList,
ft F,lt Z,zz *Status,    tokentype    *ListTkn);
boolean List01_CreateNode
(tokentype    *ListTkn,
ft F,lt Z,zz *Status,    tokentype    *NodeTkn);
boolean Is_List01Head
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean Is_List01Node
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean Is_List01Member
(tokentype    *ListTkn,   tokentype    *MemberTkn,
ft F,lt Z,zz *Status,    tokentype    *NodeTkn);
boolean List01_GetCount
(tokentype    *ListTkn,
ft F,lt Z,zz *Status,    numtype      *ItemCount);
boolean List01_Reset
(tokentype    *ListTkn,   ft F,lt Z,zz *Status);
boolean List01_SetCurrent
(tokentype    *ListTkn,   tokentype    *NodeTkn,
ft F,lt Z,zz *Status);
boolean List01_GetCurrent
(tokentype    *ListTkn,
ft F,lt Z,zz *Status,    tokentype    *NodeTkn);
boolean List01_IsEmpty
(tokentype    *ListTkn,   ft F,lt Z,zz *Status);
boolean List01_Append
(tokentype    *ListTkn,   tokentype    *MemberTkn,
ft F,lt Z,zz *Status);
boolean List01_FirstIn
(tokentype    *ListTkn,
ft F,lt Z,zz *Status,    tokentype    *NodeTkn,
tokentype    *MemberTkn);
boolean List01_NextIn
(tokentype    *ListTkn,   tokentype    *CurrTkn,
ft F,lt Z,zz *Status,    tokentype    *NodeTkn,
tokentype    *MemberTkn);
boolean List01_IterateOn
(tokentype    *ListTkn,
iteratetype   Method,    ft F,lt Z,zz *Status);
#endif

typedef struct TypeObjHeader
{
wordtype    EnvObjType;
accesstype  LocalAccess;
boolean     DiskCache;
indextype   LocalObjNum;
valueclass  UnitType;
numtype     UnitObj;
sizeinbytes ObjSize;
indextype   ObjectCount;
numtype     RegionObjects;
numtype     RegionCount;
numtype     RegionsAllocd;
indextype   RegionIndex;
boolean     NoRegionsInCore;
numtype     FreezeClass;
numtype     RegionChunkDir;
numtype     RegionSwapDir;
numtype     DirtyRegionDir;
numtype     RegionFreezeDir;
numtype     RgnBuffNumDir;
numtype     RgnAccessedDir;
numtype     RegionVbnDir;
vbntype     RegionVbnDirVbn;
indextype   ExObjectCount;
numtype     ExObjectTbl;
vbntype     ExObjectTblVbn;
numtype     NextEx;
indextype   NextEntry;
indextype   BaseIndex;
numtype     BaseRegion;
indextype   CacheLimit;
indextype   CacheLoad;
numtype     NumBuffRgns;
indextype   RgnBuffCount;
numtype     BuffRgnsDir;
numtype     BuffNodesDir;
indextype   HeadRgnBuffs;
indextype   LastRgnBuff;
indextype   RgnStatusDir;
indextype   RgnStatusDirVbn;
numtype     RgnBuffIdsDir;
indextype   GrpIndexDir;
indextype   GrpIndexDirVbn;
indextype   GrpDirCount;
lt64        HeadExIndexs;
numtype    *FrozenRgns;
numtype    *RgnBuffNums;
numtype    *RgnAccessArray;
indextype  *RgnBuffRgns;
indextype  *RgnBuffNodes;
indextype  *RgnStats;
indextype  *RgnBuffIds;
lt64       *GrpDirAddr;
#if !defined(SPEC_CPU2000_LP64) && !defined(SPEC_CPU2000_P64)
numtype    *FrozenRgns_64;
numtype    *RgnBuffNums_64;
numtype    *RgnAccessArray_64;
indextype  *RgnBuffRgns_64;
indextype  *RgnBuffNodes_64;
indextype  *RgnStats_64;
indextype  *RgnBuffIds_64;
lt64       *GrpDirAddr_64;
#endif
indextype   ObjectLockDir;
indextype   ObjectLockDirVbn;
sizeinbytes PsudoSize;
numtype     ObjNum;
indextype   NextObject;
SWordType   HandleOffset;
numtype     FieldNumMap;
vbntype     FieldNumMapVbn;
numtype     LocalAttrNumMap;
vbntype     LocalAttrNumMapVbn;
indextype   FieldCount;
numtype     FieldOffsetDir;
vbntype     FieldOffsetDirVbn;
numtype     ClassOffsetDir;
vbntype     ClassOffsetDirVbn;
indextype   FieldRefCount;
numtype     FieldRefDir;
vbntype     FieldRefDirVbn;
indextype   FieldMapCount;
numtype     FieldMapDir;
vbntype     FieldMapDirVbn;
indextype   FieldArrayCount;
numtype     FieldArrayDir;
vbntype     FieldArrayDirVbn;
indextype   StringCount;
indextype   TextChunk;
vbntype     TextChunkVbn;
}                         objheader;
typedef struct TypeDbHeader
{
idtype      DbId;
idtype      CoreDbId;
indextype   NextHandle;
indextype   HandleExQty;
indextype   HandleUnits;
filename    DbFileName;
filename    ActiveFileName;
accesstype  LocalAccess;
boolean     DiskCache;
blkhdrtype  BlkHdr;
indextype   GrpCount;
numtype     GrpHdrDir;
vbntype     GrpHdrDirVbn;
vbntype     GrpVbnDir;
vbntype     GrpVbnDirVbn;
indextype   HeadFreeGrps;
numtype     VchunkCommitDir;
numtype     VchunkSwapDir;
vbntype     VbnDeleteDir;
vbntype     FreeVchunkVbn;
indextype   VchunkGrpNum;
indextype   VchunkBaseIndex;
indextype   HandleCount;
indextype   HandleBaseIndex;
numtype     ObjectAddrDir;
vbntype     ObjectAddrDirVbn;
farlongtype ObjectAddrDirOffset;
indextype   ObjectAddrGrpNum;
numtype     ObjectMemLocDir;
numtype     ObjectMemRefDir;
numtype     ObjectIndexDir;
vbntype     ObjectIndexDirVbn;
farlongtype ObjectIndexDirOffset;
indextype   ObjectIndexGrpNum;
numtype     LocalObjNumDir;
vbntype     LocalObjNumDirVbn;
farlongtype LocalObjNumDirOffset;
indextype   LocalObjNumGrpNum;
indextype   LastEnvObjCount;
numtype     LocalObjNumMap;
vbntype     LocalObjNumMapVbn;
numtype     ObjHandleDir;
numtype     ObjHandleDirVbn;
indextype   LocalObjCount;
numtype     ObjNumMap;
vbntype     ObjNumMapDirVbn;
numtype     ObjTimeStampDir;
numtype     ObjTimeStampVbn;
numtype     ObjHdrDir;
vbntype     ObjHdrDirVbn;
numtype     ObjVbnDir;
vbntype     ObjVbnDirVbn;
indextype   LastEnvAttrCount;
numtype     LocalAttrNumMap;
vbntype     LocalAttrMapVbn;
numtype     AttrHandleDir;
vbntype     AttrHandleDirVbn;
indextype   LocalAttrCount;
numtype     AttrNumMap;
vbntype     AttrNumMapVbn;
numtype     LocalAttrSizeTbl;
vbntype     LocalAttrSizeVbn;
numtype     TextTokenDir;
numtype     TextTknDirVbn;
numtype     FreeTxtTknStack;
vbntype     FreeTxtTknVbn;
indextype   FutureHandles;
indextype   CurrentHandles;
indextype   AvailHandles;
numtype     NewHandles;
vbntype     NewHandlesVbn;
indextype   NextFree;
numtype     StackHeadDir;
handletype  StackNames;
numtype     ListHeadDir;
handletype  ListNames;
numtype     TblHeadDir;
handletype  TblNames;
numtype     TreeHeadDir;
handletype  TreeNames;
numtype     lKeyHeadDir;
handletype  lKeyNames;
numtype     MtrxHeadDir;
handletype  MtrxNames;
addrtype    PrimalHdr;
sizetype    PrimalHdrSize;
vbntype     PrimalHdrVbn;
vbntype     EOFVbn;
indextype   BlkBlksBaseIndex;
indextype   BlkBlksExtendQty;
vbntype     BlkDirVbn;
indextype   BlkDirUnits;
farlongtype BlkDirOffset;
indextype   BlkDirGrpNum;
vbntype     BlkTknVbn;
indextype   BlkTknUnits;
farlongtype BlkTknOffset;
indextype   BlkTknGrpNum;
vbntype     BlkSizeVbn;
farlongtype BlkSizeOffset;
indextype   BlkSizeGrpNum;
indextype   FreeRegionCount;
numtype     FreeRegionDir;
numtype     FreeRegionLengths;
handletype  SchemaHndl;
grpheader **GrpHdrs;
grpheader  *VchunkGrpHdr;
#if !defined(SPEC_CPU2000_LP64) && !defined(SPEC_CPU2000_P64)
grpheader **GrpHdrs_64;
grpheader  *VchunkGrpHdr_64;
#endif
}                          dbheader;




typedef Part2  Part;
#ifdef __DISPLAY_CORE__


#endif

boolean BMT_Test         (char         *EdbName, char         *EdbFileName,
char         *DrwName, char         *DrwFileName,
char         *EmpName, char         *EmpFileName,
int             Count, int           MaxOuterLoop,
int     MaxInnerLoops,
int           LookUps, int           Deletes,
int        StuffParts, int           TraverseLimit,
int        NewPartPct, int           LookUpPct,
int         DeletePct, int           StuffPct,
int       DeleteDraws, int           DeleteParts,
boolean     CommitDbs, ft F,lt Z,zz *Status)
{
#ifdef __DISPLAY_TIME__
time_t         NullTime     = 0;
time_t         Elapsed      = 0;
float          Seconds      = 0;
time_t         InitStartTime  = 0;
time_t         OuterStartTime = 0;
time_t         InnerStartTime = 0;
time_t         InitEndTime    = 0;
time_t         OuterEndTime   = 0;
time_t         InnerEndTime   = 0;
#endif
longtype       Level        = 0;
boolean        Release      = False;
unsigned       Seed         = 1008;
numtype        NewParts     = 0;
numtype        RgnEntries   = 0;
numtype        RgnEntrys    = 0;
numtype        AllocRgns    = 0;
numtype        ExtendRgns   = 0;
numtype        AllocXs      = 0;
numtype        ExtendXs     = 0;
numtype        CacheLimit   = 0;
numtype        CacheLoad    = 0;
int            OuterLoop    = 0;
int            InnerLoop    = 0;
int            FreeCount    = 0;
tokentype      PartTkn      = NullToken;
partidtype     FromPart     = 0;
parttkntype    PartToken;
tokentype      ItorTkn      = NullToken;
boolean        CommitOnExit = False;
numtype        NumObjects   = 0;
numtype        StackPtr     = 0;
static tokentype WatchTkn   = {0, 6, 6};
#ifdef __DISPLAY_TIME__
InitStartTime = clock();
#endif
if (CommitDbs)
{
fprintf(stderr,"CommitDbs = True\n");
fflush(stderr);
} else
DrawBug   = False;
if (DeleteDraws       >= 1)
DeleteDrawObjects   = True;
else
DeleteDrawObjects   = False;
if (DeleteParts       >= 1)
DeletePartObjects   = True;
else
DeletePartObjects   = False;
Traverse_Limit = TraverseLimit;
TraceMsg (0, "\n\n BMT TEST :: files...\n");
sprintf (Msg, "      EdbName           := %s\n", EdbName);
TraceMsg (0, Msg);
sprintf (Msg, "      EdbFileName       := %s\n", EdbFileName);
TraceMsg (0, Msg);
sprintf (Msg, "      DrwName           := %s\n", DrwName);
TraceMsg (0, Msg);
sprintf (Msg, "      DrwFileName       := %s\n", DrwFileName);
TraceMsg (0, Msg);
sprintf (Msg, "      EmpName           := %s\n", EmpName);
TraceMsg (0, Msg);
sprintf (Msg, "      EmpFileName       := %s\n", EmpFileName);
TraceMsg (0, Msg);
sprintf (Msg, "\n      Swap to DiskCache := %s\n", BoolStr[SWAP]);
TraceMsg (0, Msg);
sprintf (Msg, "      Freeze the cache  := %s\n", BoolStr[FREEZE_GRP_PACKETS]);
TraceMsg (0, Msg);
TraceMsg (0, "\n\n BMT TEST :: parms...\n");
sprintf (Msg, "      DeBug modulo      := %-8u\n", QueBug);
TraceMsg (0, Msg);
sprintf (Msg, "      Create Parts count:= %-8u\n", Count);
TraceMsg (0, Msg);
sprintf (Msg, "      Outer Loops       := %-8u\n", MaxOuterLoop);
TraceMsg (0, Msg);
sprintf (Msg, "      Inner Loops       := %-8u\n", MaxInnerLoops);
TraceMsg (0, Msg);
sprintf (Msg, "      Look Ups          := %-8u\n", LookUps);
TraceMsg (0, Msg);
sprintf (Msg, "      Delete Parts      := %-8u\n", Deletes);
TraceMsg (0, Msg);
sprintf (Msg, "      Stuff Parts       := %-8u\n", StuffParts);
TraceMsg (0, Msg);
sprintf (Msg, "      Traverse Limit    := %-8u\n", Traverse_Limit);
TraceMsg (0, Msg);
sprintf (Msg, "      Delete Draws      := %s\n", BoolStr[DeleteDrawObjects]);
TraceMsg (0, Msg);
sprintf (Msg, "      Delete Parts      := %s\n", BoolStr[DeletePartObjects]);
TraceMsg (0, Msg);
sprintf (Msg, "      Delete ALL Parts  := after every <mod %2u>Outer Loop\n",
DeleteParts);
TraceMsg (0, Msg);
#ifdef __INCLUDE_RANDOM__
Env_GenerateRandomNumbers  (Count * 3 * MaxOuterLoop * MaxInnerLoops * LookUps, McStat);
sprintf (Msg, "\n      Random Numbers    := %lu\n", Random_Limit);
TraceMsg (0, Msg);
#else
srand( 1008 );
#endif
#ifdef __DISPLAY_CORE__
get_proc_mem_status("INITIALIZE LIBRARY ::\n");
#endif
TraceMsg (0, "\n INITIALIZE LIBRARY ::\n");
if (Normal(*Status))
BMT_Init          (EdbName, EdbFileName,
DrwName, DrwFileName,
EmpName, EmpFileName, Count,   McStat);
Seed          = 1008;
MaxParts      = OldParts;
RgnEntries    = OldParts + (Count * MaxOuterLoop)
+ (MaxOuterLoop * (MaxInnerLoops * (LookUps + StuffParts)));
#ifdef     __INCLUDE_MTRX__
if (RgnEntries > 65535)
{
fprintf(stderr,"ERROR: RgnEntries (%d) > 65535 : ", RgnEntries);
fprintf(stderr,"%d + (%d * %d) + (%d * (%d * (%d + %d)))\n",
OldParts, Count, MaxOuterLoop, MaxOuterLoop,
MaxInnerLoops, LookUps, StuffParts);
exit(1);
}
#endif
sprintf (Msg, "      SEED          :=%8u; Swap     = %s; RgnEntries =%6u\n",
Seed, BoolStr[SwapType], RgnEntries);
TraceMsg (0, Msg);
if (Normal(*Status))
if (MaxParts == 0)
{
if (RgnEntries   < 20000)
RgnEntries   =  20000;
if ((RgnEntrys   = RgnEntries / 100)       <  100)
RgnEntrys        = 100;
if ((AllocRgns   = RgnEntries / RgnEntrys) <  100)
AllocRgns        = 100;
ExtendRgns       = 100;
AllocXs          = 1000;
ExtendXs         = 1000;
if ((CacheLimit  = AllocRgns  / 10)        <  7)
CacheLimit       = 10;
CacheLoad        = CacheLimit;
BMT_ConfigAllClasses (RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, False,
CacheLimit,  CacheLoad,   McStat);
}
#ifdef __DISPLAY_CORE__
get_proc_mem_status("CORE Specs for INITIAL load ::\n");
TraceMsg (MSGFILE, "\n CORE Specs for INITIAL load ::\n");
Core_ShowStats ();
#endif
#ifdef __DISPLAY_TIME__
NullTime     = clock();
#endif
PartTkn.DbId = LibTkn.DbId;
NewParts     = Count;
OuterLoop    = 0;
if (Env_IsValidToken (&WatchTkn,  McStat))
Object_Dump    (&WatchTkn);
while (++OuterLoop  <= MaxOuterLoop
&&     Normal(*Status))
{
#ifdef __DISPLAY_TIME__
OuterStartTime = clock();
#endif
if (OuterLoop  > 1)
{
if (NewParts     > 1000)
{
NewParts       = (NewParts   * NewPartPct)  / 100;
LookUps       += (LookUps    * LookUpPct)  / 100;
Deletes       += (Deletes    * DeletePct) / 100;
StuffParts    += (StuffParts * StuffPct) / 100;
} else if (Count  != 1000)
NewParts       = StuffParts;
}
sprintf (Msg, "\n OUTER LOOP [%3u] :  NewParts = %d LookUps = %d StuffParts = %d.\n", OuterLoop, NewParts, LookUps, StuffParts);
TraceMsg (0, Msg);
if (StuffParts
||  MaxParts   == 0)
{
MaxParts += Count;
#ifdef __DISPLAY_TIME__
NullTime = clock();
#endif
BMT_CreateParts    (NewParts,  McStat);
#ifdef __DISPLAY_CORE__
get_proc_mem_status("CORE Specs after Outer Loop CreateParts ::\n");
TraceMsg (MSGFILE, "\n CORE Specs after Outer Loop CreateParts::\n");
Core_ShowStats ();
#endif
if (Normal(*Status))
BMT_TraverseSets   (McStat);
if (Normal(*Status))
if (MaxInnerLoops  == 0
&&  MaxOuterLoop     == 1)
{
CommitOnExit = True;
sprintf (Msg, "\n COMMIT %6u NewParts and FREE all Image's.\n",
NewParts);
TraceMsg (0, Msg);
#ifdef __DISPLAY_TIME__
NullTime = clock();
#endif
if (!Primal_CommitDb    (&LibTkn,     "\0",  True,     McStat))
*Status = 1;
if (Normal(*Status))
if (!Primal_CommitDb    (&EmpTkn010,  "\0",  True,     McStat))
*Status = 1;
if (Normal(*Status))
if (!Primal_CommitDb    (&LibTkn010,  "\0",  True,     McStat))
*Status = 1;
#ifdef __DISPLAY_TIME__
Elapsed  = clock() - NullTime;
Seconds  = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,
"\n COMMIT Parts DB (release)... Time = %4.2f sec\n",
Seconds);
TraceMsg (MSGFILE,   Msg);
#else
#endif
sprintf  (Msg, "\n COMMIT Parts DB (release)... \n");
TraceMsg (0,   Msg);
} else if (StuffParts)
BMT_CommitParts  (True,  McStat);
#ifdef __DISPLAY_CORE__
get_proc_mem_status("CORE Specs after Outer Loop commit image's::\n");
TraceMsg (MSGFILE, "\n CORE Specs after Outer Loop commit image's::\n");
Core_ShowStats ();
#endif
}
StartCommit  = CurrentId;
#ifdef __DISPLAY_TIME__
InitEndTime = clock();
Elapsed  = InitEndTime - InitStartTime;
Seconds  = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,"\n INITIAL STARTUP RUN TIME = %4.2f sec\n", Seconds);
TraceMsg (MSGFILE, Msg);
#endif
InnerLoop      = 0;
if (Normal(*Status))
if (MaxInnerLoops)
if (TraceMsg (0, "\n BEGIN  Inner Loop Sequence::.\n"))
while (Normal(*Status)
&&   ++InnerLoop <= MaxInnerLoops)
{
#ifdef __DISPLAY_TIME__
InnerStartTime = clock();
#endif
sprintf  (Msg, "\n INNER LOOP [%4u:%4u] :\n", OuterLoop, InnerLoop);
TraceMsg (0, Msg);
if (Normal(*Status))
BMT_LookUpParts                (LookUps,   McStat);
if (Normal(*Status))
if (Deletes)
{
#ifdef __DISPLAY_TIME__
NullTime     = clock();
#endif
BMT_DeleteParts   (Deletes,   McStat);
#ifdef __DISPLAY_TIME__
Elapsed      = clock() - NullTime;
Seconds      = (float )Elapsed / CLOCKS_PER_SEC;
sprintf    (Msg, "\n Delete Parts Time = %4.2f sec, for Count=%6u\n",
Seconds, Deletes);
TraceMsg (MSGFILE, Msg);
#else
#endif
sprintf  (Msg, "\n Traverse Count=%6u\n", PartCount);
TraceMsg (0, Msg);
}
PartCount    = 0;
FromPart     = Random(NumVlists);
FromPart     = Vlists[FromPart];
sprintf (Msg,
"\n TRAVERSE PartId[%6u] and all Connections to %2u Levels\n",
FromPart, Traverse_Limit);
TraceMsg (0,   Msg);
Level        = 0;
#ifdef __DISPLAY_TIME__
NullTime     = clock();
#endif
if (Normal(*Status))
if (Part_GetToken  (&LibTkn,               FromPart,
McStat,               &PartTkn))
Part_Traverse   (&PartTkn,  Level,      McStat);
#ifdef __DISPLAY_TIME__
Elapsed      = clock() - NullTime;
Seconds      = (float )Elapsed / CLOCKS_PER_SEC;
#endif
if (Normal(*Status))
if (DrawBug)
Object_Dump       (&PartTkn);
#ifdef __DISPLAY_TIME__
sprintf  (Msg, "\n Traverse Time = %4.2f sec, for Count=%6u\n",
Seconds, PartCount);
TraceMsg (MSGFILE, Msg);
#else
#endif
sprintf  (Msg, "\n Traverse Count=%6u\n", PartCount);
TraceMsg (0, Msg);
sprintf  (Msg, "       Traverse    Asserts =%6lu. True Tests =%6lu\n",
LookUp_Asserts + LookUp_NullAsserts,  LookUp_Asserts);
TraceMsg (0,   Msg);
sprintf (Msg,  " <%6u> DrawObj         objects  DELETED.\n", DrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  "                 <%6u> are Named.\n", NamedObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " <%6u> Point           objects  DELETED.\n", Points);
TraceMsg (0, Msg);
LookUp_Asserts      = 0;
LookUp_NullAsserts  = 0;
for (StackPtr       = 0;
StackPtr       < 2  && Normal(*Status); )
{
FromPart     = Random(NumVlists);
FromPart     = Vlists[FromPart];
if (Grp_GetEntry             (&LibTkn,   VpartsDir,  FromPart,
McStat,   (addrtype  )&PartToken))
{
PartTkn.Handle          = PartToken.Handle;
ItorTkn.DbId            = LibTkn.DbId;
ItorTkn.Handle          = PartToken.FromList;
if (Vchunk_IsValidToken  (&ItorTkn,     McStat))
Vchunk_GetStackPtr   (&ItorTkn,     McStat, &StackPtr);
}
}
#ifdef __REVERSE_TRAVERSE__
sprintf (Msg,
"\n REVERSE Traverse FROM PartId[%6u] Chain to %2u Levels\n",
FromPart, Traverse_Limit);
TraceMsg (0,   Msg);
PartCount    = 0;
Level        = 0;
#ifdef __DISPLAY_TIME__
NullTime     = clock();
#endif
if (Normal(*Status))
Part_Reverse    (&PartTkn,     Level,   McStat);
#ifdef __DISPLAY_TIME__
Elapsed      = clock() - NullTime;
Seconds      = (float )Elapsed / CLOCKS_PER_SEC;
#endif
if (Normal(*Status))
if (DrawBug)
Object_Dump      (&PartTkn);
#ifdef __DISPLAY_TIME__
sprintf  (Msg, "\n Reverse Time = %4.2f sec, for Count=%6u\n",
Seconds, PartCount);
TraceMsg (MSGFILE, Msg);
#else
#endif
sprintf  (Msg, "\n Reverse Count=%6u\n", PartCount);
TraceMsg (0, Msg);
sprintf  (Msg, "       Reverse     Asserts =%6lu. True Tests =%6lu\n",
LookUp_Asserts + LookUp_NullAsserts,  LookUp_Asserts);
TraceMsg (0,   Msg);
sprintf (Msg,  " <%6u> DrawObj         objects  Deleted.\n", DrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  "                 <%6u> are Named.\n", NamedObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " <%6u> Point           objects  Deleted.\n", Points);
TraceMsg (0, Msg);
#endif
LookUp_Asserts  = 0;
LookUp_NullAsserts  = 0;
if (StuffParts)
{
sprintf (Msg, "\n CREATE %u Additional Parts\n",
StuffParts);
TraceMsg (0,   Msg);
if (Normal(*Status))
BMT_CreateParts  (StuffParts,  McStat);
if (Normal(*Status))
if (CommitDbs)
{
CommitOnExit = True;
TraceMsg (0, "\n COMMIT Parts and FREE all Image's.\n");
sprintf (Msg, "\n COMMIT %6u Parts to temp DB; Release=%s\n",
MaxParts - StartCommit, BoolStr[Release]);
TraceMsg (0,   Msg);
#ifdef __DISPLAY_TIME__
NullTime = clock();
#endif
if (Normal(*Status))
if (Object_CommitImage  (&LibTkn,    False,            McStat))
if (!Primal_CommitDb    (&LibTkn,     "\0",  Release,  McStat))
*Status = 1;
if (Normal(*Status))
if (Object_CommitImage  (&EmpTkn010, False,            McStat))
if (!Primal_CommitDb    (&EmpTkn010,  "\0",  Release,  McStat))
*Status = 1;
if (Normal(*Status))
if (Object_CommitImage  (&LibTkn010, False,            McStat))
if (!Primal_CommitDb    (&LibTkn010,  "\0",  Release,  McStat))
*Status = 1;
#ifdef __DISPLAY_TIME__
Elapsed  = clock() - NullTime;
Seconds  = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg, "\n Commit Parts to DB... Time = %4.2f sec\n",
Seconds);
TraceMsg (MSGFILE,   Msg);
#else
#endif
sprintf  (Msg, "\n Commit Parts to DB...\n");
TraceMsg (0,   Msg);
Object_Dump    (&FirstRect);
} else if (DrawBug)
Object_Dump    (&FirstRect);
if (Release)
if (InnerLoop  <  MaxInnerLoops
&&  OuterLoop  >  1)
if (Normal(*Status))
if (PartLib_ActivateDb (&LibTkn,        EdbFileName,
McStat,        &PartLib01))
if (PersonLib_ActivateDbByToken
(&EmpTkn010,     EmpFileName, Read_Write,
McStat,        &PersonLib01))
if (DrawLib_ActivateDbByToken
(&LibTkn010,     DrwFileName, Read_Write,
McStat,        &DrawLib01))
PartsTbl = PartLib01->PartsListHead.Varray;
}
if (Normal(*Status))
if (!CommitDbs)
BMT_CommitParts        (True,           McStat);
if (Normal(*Status))
if (Primal_GetClassObjectCount
(&PrimalTkn,     TestObj_Class,
McStat,        &NumObjects))
if (NumObjects >= 10)
{
Release      = True;
BMT_DeleteTestObjs  (McStat);
}
#ifdef __DISPLAY_CORE__
if (Normal(*Status))
{
sprintf (Msg, "\n CORE Specs After INNER Loop[%4u] BEFORE Dbm_DeCacheDbs::\n", InnerLoop);
get_proc_mem_status( Msg );
TraceMsg (MSGFILE, Msg);
Core_ShowStats ();
}
#endif
if ( Normal(*Status) )
{
	  if ( Env_ReclaimHandles( &EmpTkn010, McStat ) )
	  if ( Env_ReclaimHandles( &LibTkn010, McStat ) )
	     Env_ReclaimHandles( &PrimalTkn, McStat ) ;
}
#ifndef __DECACHE_DBS__
if (Normal(*Status))
Dbm_DeCacheDbs     (McStat);
#endif
#ifdef __DISPLAY_CORE__
if (Normal(*Status))
{
sprintf (Msg, "\n CORE Specs After INNER Loop[%4u] AFTER Dbm_DeCacheDbs::\n", InnerLoop);
get_proc_mem_status( Msg );
TraceMsg (MSGFILE, Msg);
Core_ShowStats ();
}
#endif
#ifdef __DISPLAY_TIME__
InnerEndTime = clock();
Elapsed  = InnerEndTime - InnerStartTime;
Seconds  = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,"\n INNER LOOP RUN TIME = %4.2f sec\n", Seconds);
TraceMsg (MSGFILE, Msg);
#endif
FreeCount           = 0;
sprintf  (Msg, "\n END INNER LOOP [%4u:%4u].\n", OuterLoop, InnerLoop);
TraceMsg (0, Msg);
}
#ifndef __BMT01__
if (Normal(*Status))
BMT_TraverseSets   (McStat);
#endif
if (*Status  == Env_CoreNoMore)
{
*Status   = Env_Normal;
TraceMsg (0, "\n  ***WARNING*** CORE LIMIT EXCEEDED!!\n");
TraceMsg (0, "  ...  NOTE ... Well attempt to recover!!\n");
}
if (Normal(*Status))
{
BMT_DeleteTestObjs  (McStat);
#ifdef __DISPLAY_CORE__
sprintf (Msg, "\n CORE Specs after DELETE of ALL TestObjs ::\n");
get_proc_mem_status( Msg );
TraceMsg (MSGFILE, "\n CORE specs after DELETE of ALL TestObjs ::\n");
Core_ShowStats ();
#endif
}
Release               = False;
#ifdef __DISPLAY_TIME__
NullTime              = clock();
#endif
if (Normal(*Status))
if (MaxInnerLoops)
if (CommitDbs)
if (TraceMsg (0, "\n FREE ALL databases...\n"))
if (TraceMsg (0, "\n FREE the Part   DB...\n"))
if (Primal_FreeDb     (&LibTkn,      McStat))
if (TraceMsg (0, "\n FREE the Person DB...\n"))
if (Primal_FreeDb     (&EmpTkn010,   McStat))
if (TraceMsg (0, "\n FREE the Draw   DB...\n"))
if (Primal_FreeDb     (&LibTkn010,   McStat))
{
#ifdef __DISPLAY_TIME__
Elapsed  = clock() - NullTime;
Seconds  = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,
"\n Free DB... Time = %4.2f sec\n",
Seconds);
TraceMsg (MSGFILE,   Msg);
#else
#endif
sprintf  (Msg, "\n Free DB...\n");
TraceMsg (0,   Msg);
}
if (Normal(*Status))
if (OuterLoop       != MaxOuterLoop)
if (CommitDbs)
{
if (PartLib_ActivateDb (&LibTkn,        EdbFileName,
McStat,        &PartLib01))
if (PersonLib_ActivateDbByToken
(&EmpTkn010,     EmpFileName, Read_Write,
McStat,        &PersonLib01))
if (DrawLib_ActivateDbByToken
(&LibTkn010,     DrwFileName, Read_Write,
McStat,        &DrawLib01))
PartsTbl = PartLib01->PartsListHead.Varray;
}
if (Normal(*Status))
if (DeleteParts && OuterLoop % DeleteParts == 0)
{
BMT_DeleteAllObjects   (McStat);
#ifdef __DISPLAY_CORE__
sprintf(Msg," Outer Loop %2d CORE after DELETE OBJECTS\n", OuterLoop );
get_proc_mem_status( Msg );
TraceMsg (MSGFILE, "\n CORE Specs after DELETE ALL OBJECTS!! ::\n");
Core_ShowStats ();
#endif
}
#ifdef __DISPLAY_TIME__
OuterEndTime = clock();
Elapsed  = OuterEndTime - OuterStartTime;
Seconds  = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,"\n OUTER LOOP RUN TIME = %4.2f sec\n", Seconds);
TraceMsg (MSGFILE, Msg);
#endif
}
PageBug = True;
#ifndef __BMT01__
if (Normal(*Status))
if (!CommitOnExit)
{
if (Primal_DeleteDb     (&LibTkn,         McStat))
if (Primal_DeleteDb     (&EmpTkn010,      McStat))
Primal_DeleteDb     (&LibTkn010,      McStat);
if (*Status  == Err_NotImplemented)
*Status   = Env_Normal;
}
#endif
PageBug = True;
if (Normal(*Status))
if (CommitOnExit)
BMT_DeleteTestObjs      (McStat);
if (!CommitOnExit)
{
#ifdef __DISPLAY_CORE__
get_proc_mem_status("CORE Specs after FINAL COMMIT\n") ;
TraceMsg (MSGFILE, "\n CORE Specs after FINAL COMMIT ::\n");
Core_ShowStats ();
#endif
*Status  = Dbe_Quit;
}
LexBug = False;
TRACK(TrackBak,"BMT_Test\n");
return (STAT);
}
boolean BMT_Init         (char         *EdbName, char         *EdbFileName,
char         *DrwName, char         *DrwFileName,
char         *EmpName, char         *EmpFileName,
longtype      Count,   ft F,lt Z,zz *Status)
{
static numtype       HndlRgns           = 0;
static numtype       RgnHndls           = 0;
static numtype       VhndlRgns          = 0;
static numtype       RgnVhndls          = 0;
static numtype       XmemRgns           = 0;
static numtype       RgnXmems           = 0;
static boolean       UseVparts          = True;
grpheader           *GrpHdr             = NullPtr;
numtype              MaxPersons         = 131072;
TraceMsg (0, "\n INITIALIZE SCHEMA ::\n");
PartLib_Init         (McStat);
if (Normal(*Status))
{
AllocParts   = Count  + 1001;
if (AllocParts > 10000) {
RgnHndls       = AllocParts + 1000;
HndlRgns       = 10001;
RgnVhndls      = 24003;
VhndlRgns      = 10003;
RgnXmems       = AllocParts + 5009;
XmemRgns       = 10010;
} else {
RgnHndls       = 10401;
HndlRgns       = 10001;
RgnVhndls      = 15403;
VhndlRgns      = 10003;
RgnXmems       = 24010;
XmemRgns       = 10010;
}
}
RgnHndls              = AllocParts + 1000;
RgnXmems              = AllocParts + 5009;
RgnVhndls             = 1;
VhndlRgns             = 1;
if (PartLib_Create  (EdbName,      EdbFileName,Read_Write,    UseVparts,
HndlRgns,     RgnHndls,   VhndlRgns,
RgnVhndls,    XmemRgns,   RgnXmems,
McStat,      &LibTkn,    &PartLib01))
if (Grp_GetPacket   (&LibTkn,                  VpartsDir,
McStat,                  &GrpHdr))
OldParts  = GrpHdr->EntryCount;
sprintf (Msg, "\n Part Count=%8u\n", OldParts);
TraceMsg (0, Msg);
if (OldParts > 0)
OldParts--;
else
OldParts   = 0;
MaxParts     = Count + OldParts;
CurrentId    = OldParts;
StartCommit  = OldParts;
OneCent      = MaxParts / 128;
if (OneCent == 0)
OneCent = 2;
HalfCent     = MaxParts / 256;
if (HalfCent == 0)
HalfCent = 2;
if (Normal(*Status))
if (DrawLib_InitDb   (DrwName,  DrwFileName,  Count,  McStat, &LibTkn010))
List01_FindListHead
(&LibTkn010, "DbRectangles",    McStat, &RectListTkn);
if (*Status  == List01_NotFound)
{
*Status      = Env_Normal;
List01_Create  (&LibTkn010, &NullToken,    "DbRectangles",  0, 0,
McStat,     &RectListTkn);
}
if (Normal(*Status))
Person_InitDb     (EmpName,     EmpFileName,            Count,
McStat,                             &EmpTkn010);
if (Normal(*Status))
if (Primal_GetClassObjectCount
(&EmpTkn010,  Person_Class, McStat,  &NumPersons))
if (NumPersons == 0)
{
BMT_BuildPersonLib (&EmpTkn010,  MaxPersons,   McStat);
}
if (Normal(*Status))
BMT_InitQuerys     (McStat);
TRACK(TrackBak,"BMT_Init\n");
return (STAT);
}
boolean BMT_ConfigAllClasses
(numtype       RgnEntrys,
numtype       AllocRgns, numtype       ExtendRgns,
numtype       AllocXs,   numtype       ExtendXs,
accesstype    AccessType,boolean       DiskCache,
numtype       CacheLimit,numtype       CacheLoad,
ft F,lt Z,zz *Status)
{
numtype      MediumSize  = 4096;
numtype      LargeSize   = 8192;
bytessize    ObjSize     = 0;
numtype      AllocEntrys = RgnEntrys * 100;
if (EnvFetchObjSize (Part_Class,          McStat,     &ObjSize))
{
RgnEntrys      = MediumSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = CacheLoad;
if (CacheLimit > 10)
CacheLimit     = 10;
if (CacheLoad  > 10)
CacheLoad      = 10;
Primal_ConfigYourClass
(&LibTkn,     Part_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
if (Normal(*Status))
if (EnvFetchObjSize (Rectangle_Class,      McStat,     &ObjSize))
{
RgnEntrys      = LargeSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = AllocRgns;
if (CacheLimit > 10)
CacheLimit     = 10;
if (CacheLoad  > 10)
CacheLoad      = 10;
Primal_ConfigYourClass
(&LibTkn010,  Rectangle_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
if (Normal(*Status))
if (EnvFetchObjSize (XyRect_Class,         McStat,     &ObjSize))
{
RgnEntrys      = LargeSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = AllocRgns;
Primal_ConfigYourClass
(&LibTkn010,  XyRect_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
if (Normal(*Status))
if (EnvFetchObjSize (NamedXyRect_Class,    McStat,     &ObjSize))
{
RgnEntrys      = LargeSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = AllocRgns;
Primal_ConfigYourClass
(&LibTkn010,  NamedXyRect_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
if (Normal(*Status))
if (EnvFetchObjSize (ArrayRect_Class,      McStat,     &ObjSize))
{
RgnEntrys      = LargeSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = AllocRgns;
Primal_ConfigYourClass
(&LibTkn010,  ArrayRect_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
if (Normal(*Status))
if (EnvFetchObjSize (DblPtrRect_Class,     McStat,     &ObjSize))
{
RgnEntrys      = LargeSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = AllocRgns;
Primal_ConfigYourClass
(&LibTkn010,  DblPtrRect_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
if (Normal(*Status))
if (EnvFetchObjSize (VarrayRect_Class,     McStat,     &ObjSize))
{
RgnEntrys      = LargeSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = AllocRgns;
Primal_ConfigYourClass
(&LibTkn010,  VarrayRect_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
if (Normal(*Status))
if (EnvFetchObjSize (IntChunkRect_Class,       McStat,     &ObjSize))
{
RgnEntrys      = LargeSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = AllocRgns;
Primal_ConfigYourClass
(&LibTkn010,  IntChunkRect_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
if (Normal(*Status))
if (EnvFetchObjSize (VchunkRect_Class,         McStat,     &ObjSize))
{
RgnEntrys      = LargeSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = AllocRgns;
Primal_ConfigYourClass
(&LibTkn010,  VchunkRect_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
if (Normal(*Status))
if (EnvFetchObjSize (RefRect_Class,            McStat,     &ObjSize))
{
RgnEntrys      = LargeSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = AllocRgns;
Primal_ConfigYourClass
(&LibTkn010,  RefRect_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
if (Normal(*Status))
if (EnvFetchObjSize (CartesianPoint_Class,     McStat,     &ObjSize))
{
RgnEntrys      = LargeSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = AllocRgns;
Primal_ConfigYourClass
(&LibTkn010,  CartesianPoint_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
if (Normal(*Status))
if (EnvFetchObjSize (TestObj_Class,            McStat,     &ObjSize))
{
RgnEntrys      = LargeSize   / ObjSize;
AllocRgns      = AllocEntrys / RgnEntrys;
CacheLoad      = AllocRgns * 6 / 10;
CacheLimit     = AllocRgns;
if (CacheLimit > 10)
CacheLimit     = 10;
if (CacheLoad  > 10)
CacheLoad      = 10;
Primal_ConfigYourClass
(&PrimalTkn,  TestObj_Class,
RgnEntrys,   AllocRgns,   ExtendRgns,
AllocXs,     ExtendXs,    Read_Write, True,
CacheLimit,  CacheLoad,   McStat);
}
LibBug = False;
TRACK(TrackBak,"BMT_ConfigAllClasses\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\bmt01.c*/

#define  __DISPLAY_TIME__
#define BMT01
typedef Part2  Part;
boolean Draw7     (tokentype    *Anchor,  boolean       TestBug,
numtype       Option,  ft F,lt Z,zz *Status);

boolean BMT_CreateParts    (longtype      Count,  ft F,lt Z,zz *Status)
{
tokentype         PersonTkn      = NullToken;
tokentype         PartTkn        = NullToken;
unsigned int      id             = 0;
unsigned int      i              = 0;
#ifdef __DISPLAY_TIME__
time_t            NullTime       = 0;
time_t            Elapsed        = 0;
float             Seconds        = 0;
#endif
longtype          X              = 0;
longtype          Y              = 0;
longtype          TypeNum        = 0;
numtype           DrawType       = 0;
numtype           PersonId       = 0;
short             x0             = 0;
short             y0             = 0;
short             x1             = 0;
short             y1             = 0;
CartesianPoint   *c3             = NullPtr;
CartesianPoint   *c4             = NullPtr;
Rectangle        *r0             = NullPtr;
tokentype        RecTkn          = NullToken;
XyPoint          c8;
XyPoint          c9;
IntChunkRect    *IntChunk01      = NullPtr;
XyRect          *Xy01            = NullPtr;
NamedXyRect     *Xy02            = NullPtr;
ArrayRect       *Array01         = NullPtr;
DblPtrRect      *DblPtr01        = NullPtr;
VarrayRect      *Varray01        = NullPtr;
VchunkRect      *Vchunk01        = NullPtr;
RefRect         *ref0            = NullPtr;
DrawObj         *BaseObj         = NullPtr;
Part            *PartObj         = NullPtr;
static boolean   FirstTime       = True;
PartTkn.DbId        = LibTkn.DbId;
sprintf (Msg, "\n Create %u New Parts\n", Count);
TraceMsg (0,   Msg);
#ifdef __DISPLAY_TIME__
NullTime = clock();
#endif
i           = 0;
id          = CurrentId;
while (Normal(*Status)
&&     ++i <= Count)
{
X        = Random(512);
Y        = Random(1024);
TypeNum  = Random(8);
DrawType = Random(8);
x0       = (short )X;
y0       = (short )Y;
x1       = x0 + (short )Random(16) + 1;
y1       = y0 + (short )Random(16) + 1;
c8.xCoord = x0;
c8.yCoord = y0;
c9.xCoord = x1;
c9.yCoord = y1;
PersonId = Random(PersonLib01->MaxId) + 1;
if (PersonObjs_FindIn (&EmpTkn010,  (addrtype )&PersonId,
McStat,                 &PersonTkn))
{
Part_Create        (&LibTkn,     ++CurrentId,  X,  Y,  TypeNum,
McStat,                           &PartTkn);
if (ClassBug || DeBug || i % QueBug == 1)
if (sprintf (Msg, " Create Part %6u. Token[%3u:%8u].\n",
CurrentId, PartTkn.DbId, PartTkn.Handle))
if (TraceMsg (0, Msg))
if (i == Count)
if (DrawBug)
Object_Dump (&PartTkn);
if (Normal(*Status))
if (Object_GetImage     (&PartTkn,     McStat,   (addrtype *)&PartObj))
if (PersonParts_AddInto (&PersonTkn,  &PartTkn,  McStat))
switch (DrawType)
{
case   aRectangle    :
if ((c3 = CartesianPoint_new0
(&LibTkn010,  x0,         y0,
McStat)) != NullPtr)
if ((c4 = CartesianPoint_new0
(&LibTkn010,  x1,         y1,
McStat)) != NullPtr)
if ((r0 = Rectangle_new1
(&LibTkn010, (Point *)c3,(Point *)c4,
McStat)) != NullPtr)
RecTkn      = r0->Token;
BaseObj         = (DrawObj *)r0;
if (Normal(*Status))
List01_Append     (&RectListTkn,  &RecTkn,  McStat);
break;
case   aXyRect       :
if ((Xy01  = XyRect_new0 (&LibTkn010, &c8,  &c9,
McStat)) != NullPtr)
RecTkn = Xy01->Token;
BaseObj         = (DrawObj *)Xy01;
break;
case   aNamedXyRect  :
if (FirstTime)
{
FirstRect   = RecTkn;
FirstTime   = False;
if (DrawBug)
if (TraceMsg (0, "\n First <NamedXyRect>::\n"))
Object_Dump (&RecTkn);
}
if ((Xy02  = NamedXyRect_new0 (&LibTkn010, &c8,  &c9,
McStat)) != NullPtr)
RecTkn = Xy02->Token;
BaseObj         = (DrawObj *)Xy02;
break;
case   aArrayRect    :
if ((Array01  = ArrayRect_new0 (&LibTkn010, &c8,  &c9,
McStat)) != NullPtr)
RecTkn = Array01->Token;
BaseObj         = (DrawObj *)Array01;
break;
case   aDblPtrRect   :
if ((DblPtr01 = DblPtrRect_new0 (&LibTkn010, &c8,  &c9,
McStat)) != NullPtr)
RecTkn = DblPtr01->Token;
BaseObj         = (DrawObj *)DblPtr01;
break;
case   aVarrayRect   :
if ((Varray01  = VarrayRect_new0 (&LibTkn010, &c8,  &c9,
McStat)) != NullPtr)
RecTkn = Varray01->Token;
BaseObj         = (DrawObj *)Varray01;
if (FirstTime)
{
FirstRect   = RecTkn;
FirstTime   = False;
if (DrawBug)
if (TraceMsg (0, "\n First RECTANGLE::\n"))
Object_Dump (&RecTkn);
}
break;
case   aIntChunkRect :
if ((IntChunk01  = IntChunkRect_new0 (&LibTkn010, &c8,  &c9,
McStat)) != NullPtr)
RecTkn = IntChunk01->Token;
BaseObj         = (DrawObj *)IntChunk01;
break;
case   aVchunkRect   :
if ((Vchunk01  = VchunkRect_new0 (&LibTkn010, &c8,  &c9,
McStat)) != NullPtr)
RecTkn = Vchunk01->Token;
BaseObj         = (DrawObj *)Vchunk01;
break;
case   aRefRect      :
if ((c3 = CartesianPoint_new0
(&LibTkn010,  x0,         y0,
McStat)) != NullPtr)
if ((c4 = CartesianPoint_new0
(&LibTkn010,  x1,         y1,
McStat)) != NullPtr)
if ((ref0 = RefRect_new1
(&LibTkn010, (Point *)c3,(Point *)c4,
McStat)) != NullPtr)
RecTkn      = ref0->Token;
BaseObj         = (DrawObj *)ref0;
break;
default              :
*Status  = Err_BadDesign;
BaseObj         = NullPtr;
break;
}
if (Normal(*Status))
{
BaseObj->PartObjSlotAttr  = PartTkn;
PartObj->DrawObjSlotAttr  = RecTkn;
}
} else if (*Status == Set_NotFound)  {
*Status  = Env_Normal;
sprintf (Msg,
" Entry %6u. PersonsObjs for Key: Id = <%6u>. NOT FOUND\n",
i, PersonId);
TraceMsg (0, Msg);
i--;
}
}
#ifdef __DISPLAY_TIME__
Elapsed    = clock() - NullTime;
Seconds    = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,
"\n Create Time = %4.2f sec, for %d Parts. CurrentId=%6u\n",
Seconds,  Count, CurrentId);
TraceMsg (MSGFILE, Msg);
#else
#endif
sprintf  (Msg,
"\n  <%6d> Parts Created. CurrentId=%6u\n",
Count, CurrentId);
TraceMsg (0, Msg);
TraceMsg (0, "\n Connect each instantiated Part TO 3 unique Parts\n");
#ifdef __DISPLAY_TIME__
NullTime = clock();
#endif
MaxParts    = CurrentId;
OneCent     = MaxParts / 100;
if (OneCent == 0)
OneCent = 1;
HalfCent     = MaxParts / 200;
if (HalfCent == 0)
HalfCent = 1;
if (Normal(*Status))
Vchunk_GetAddress   (&VlistTkn,   McStat,   (addrtype *)&Vlists);
while (Normal(*Status)
&&     ++id <= MaxParts)
{
Part_GetToken     (&LibTkn,                 id,
McStat,                 &PartTkn);
if (ClassBug || DeBug || id % QueBug == 1)
if (sprintf (Msg, " Connect Part %6u. Token[%3u:%8u]\n",
id, PartTkn.DbId, PartTkn.Handle))
TraceMsg (0, Msg);
if (Normal(*Status))
Part_Connect  (&PartTkn,    id,         McStat);
if (id == 100)
if (DrawBug)
Object_Dump    (&PartTkn);
}
#ifdef __DISPLAY_TIME__
Elapsed    = clock() - NullTime;
Seconds    = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,
"\n Connect Time = %4.2f sec\n",
Seconds);
TraceMsg (MSGFILE, Msg);
#endif
TRACK(TrackBak,"BMT_CreateParts\n");
return (STAT);
}
boolean      BMT_Validate
(tokentype    *PartTkn, ft F,lt Z,zz *Status)
{
Part            *PartObj        = NullPtr;
Part             PartObj0;
tokentype        ToTkn          = NullToken;
boolean          TempClassBug   = ClassBug;
boolean          TempMtrxBug    = MtrxBug;
boolean          TempSetBug     = SetBug;
tokentype        FoundTkn       = NullToken;
tokentype        PersonTkn      = NullToken;
Person          *EmpObj         = NullPtr;
tokentype        AddressTkn     = NullToken;
Address         *AddressObj     = NullPtr;
tokentype        c3Tkn          = NullToken;
tokentype        c4Tkn          = NullToken;
Rectangle       *r0             = NullPtr;
tokentype        RectTkn        = NullToken;
IntChunkRect    *IntChunk01     = NullPtr;
XyRect          *Xy01           = NullPtr;
NamedXyRect     *Xy02           = NullPtr;
ArrayRect       *Array01        = NullPtr;
DblPtrRect      *DblPtr01       = NullPtr;
VarrayRect      *Varray01       = NullPtr;
VchunkRect      *Vchunk01       = NullPtr;
RefRect         *ref0           = NullPtr;
DrawObj         *BaseObj        = NullPtr;
numtype          DrawClass      = 0;
tokentype        NextNode       = NullToken;
tokentype        NextTkn        = NullToken;
tokentype        CurrentNode    = NullToken;
tokentype        CurrentTkn     = NullToken;
boolean          NotFound       = True;
#ifdef     __INCLUDE_MTRX__
matrixitor       Itrator;
#endif
static numtype   NumExports1    = 0;
boolean          TempDrawBug    = DrawBug;
NextNode.DbId    = LibTkn010.DbId;
NextTkn.DbId     = LibTkn010.DbId;
CurrentNode.DbId = LibTkn010.DbId;
CurrentTkn.DbId  = LibTkn010.DbId;
++NumExports1;
if (DrawBug && NumExports1 % QueBug == 0)
if (sprintf (Msg, " BMT_Validate %8u.  Token[%3u:%8u]\n",
NumExports1, PartTkn->DbId, PartTkn->Handle))
TraceMsg (0, Msg);
if (Normal(*Status))
if (Object_GetImage (PartTkn,      McStat, (addrtype *)&PartObj))
{
strcpy (PartObj0.type,  PartObj->type);
PartObj0.xx           = PartObj->xx;
PartObj0.yy           = PartObj->yy;
PartObj0.build        = PartObj->xx;
PartObj0.link[0]      = PartObj->link[0];
PartObj0.link[1]      = PartObj->link[1];
PartObj0.link[2]      = PartObj->link[2];
ToTkn.DbId            = PartTkn->DbId;
#ifdef     __INCLUDE_MTRX__
for (ItNum = -1; ++ItNum < 3 && Normal(*Status); )
{
ToPart             = PartObj->link[ItNum].to;
if (Grp_GetEntry     (PartTkn,  VpartsDir,  ToPart,
McStat,  (addrtype *)&PartToken))
ToTkn.Handle    =  PartToken.Handle;
if (Normal(*Status))
if (Env_IsValidToken (&ToTkn,                  McStat))
Matrix_WhosAt (TosFroms_Mtrx,     PartTkn, &ToTkn,
McStat,           &Itrator, &NodeTkn);
if (*Status == Mtrx_NotMated)
{
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"\n ***ERROR*** From[%4u:%6u] To[%4u:%6u] not MATE'D in TosFroms.\n",
PartTkn->DbId,   PartTkn->Handle,
ToTkn.DbId,      ToTkn.Handle);
TraceMsg (0, Msg);
TraceMsg (0, "\n TO   Token::\n");
Object_Dump  (PartTkn);
TraceMsg (0, "\n FROM Token::\n");
Object_Dump  (&ToTkn);
#endif
*Status   = Env_Normal;
}
}
#endif
}
if (Normal(*Status))
BMT_DbTransaction  (McStat);
if (Normal(*Status))
{
RectTkn   = PartObj->DrawObjSlotAttr;
if (Env_IsValidToken (&RectTkn,   McStat))
if ((DrawClass = Object_IsA (&RectTkn,  McStat)) > 0)
if (DrawClass         == Rectangle_Class)
{
if ((r0  = Rectangle_new4   (&RectTkn,     McStat)) != NullPtr)
{
FoundTkn = r0->Token;
c3Tkn    = r0->Origin->Token;
c4Tkn    = r0->Extent->Token;
if (ClassBug)
Rectangle_show  (r0);
}
if (Normal(*Status))
if (List01_Reset     (&RectListTkn,  McStat))
if (List01_FirstIn   (&RectListTkn,  McStat,
&CurrentNode, &CurrentTkn))
if (Normal(*Status))
{
do
{
if (CurrentTkn.DbId    == RectTkn.DbId
&&  CurrentTkn.Handle  == RectTkn.Handle)
NotFound   = False;
else {
if (List01_NextIn    (&RectListTkn, &CurrentNode,
McStat,       &NextNode,    &NextTkn))
{
CurrentNode.Handle = NextNode.Handle;
CurrentTkn.Handle  = NextTkn.Handle;
}
}
} while (Normal(*Status) && NotFound);
}
if (*Status == List01_EndOfList  || *Status == List01_EmptyList)
*Status = Env_Normal;
if (NotFound
|| !Normal(*Status))
{
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"\n ***ERROR*** Rectangle[%4u:%6u] not found in LIST. Id=%6u\n",
RectTkn.DbId,   RectTkn.Handle, r0->Id);
TraceMsg (0, Msg);
Object_Dump  (&RectTkn);
#endif
if (Normal(*Status))
*Status  = Err_BadDesign;
}
if (Normal(*Status))
LibRectangles_FindIn  (&LibTkn010,  (addrtype )&r0->Id,
McStat,                 &FoundTkn);
if (*Status  == Set_NotFound)
{
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"\n ***ERROR*** Rectangle[%4u:%6u] not found in LibRectangles. Id=%6u\n",
RectTkn.DbId,   RectTkn.Handle, r0->Id);
TraceMsg (0, Msg);
Object_Dump  (&RectTkn);
#endif
*Status  = Err_BadDesign;
}
} else if (DrawClass  == XyRect_Class)       {
if ((Xy01  = XyRect_new1   (&RectTkn,     McStat)) != NullPtr)
FoundTkn = Xy01->Token;
} else if (DrawClass  == NamedXyRect_Class)  {
if ((Xy02  = NamedXyRect_new1   (&RectTkn,     McStat)) != NullPtr)
FoundTkn = Xy02->Token;
NamedDrawObjs_FindIn  (&LibTkn010,  (addrtype )Xy02->Nam,
McStat,                &FoundTkn);
if (*Status  == Set_NotFound)
{
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"\n ***ERROR*** NamedXyRect[%4u:%6u] not found in NamedDrawObjs. Nam= <%s>\n",
RectTkn.DbId,   RectTkn.Handle, Xy02->Nam);
TraceMsg (0, Msg);
Object_Dump  (&RectTkn);
#endif
*Status  = Env_Normal;
}
} else if (DrawClass  == ArrayRect_Class)    {
if ((Array01  = ArrayRect_new1   (&RectTkn,     McStat)) != NullPtr)
FoundTkn = Array01->Token;
} else if (DrawClass  == DblPtrRect_Class)   {
if ((DblPtr01  = DblPtrRect_new1   (&RectTkn,     McStat)) != NullPtr)
FoundTkn = DblPtr01->Token;
} else if (DrawClass  == VarrayRect_Class)   {
if ((Varray01  = VarrayRect_new1   (&RectTkn,     McStat)) != NullPtr)
FoundTkn = Varray01->Token;
} else if (DrawClass  == IntChunkRect_Class) {
if ((IntChunk01  = IntChunkRect_new1   (&RectTkn,     McStat)) != NullPtr)
FoundTkn = IntChunk01->Token;
} else if (DrawClass  == VchunkRect_Class)   {
if ((Vchunk01  = VchunkRect_new1   (&RectTkn,     McStat)) != NullPtr)
FoundTkn = Vchunk01->Token;
} else if (DrawClass  == RefRect_Class)      {
if ((ref0  = RefRect_new3   (&RectTkn,     McStat)) != NullPtr)
{
FoundTkn = ref0->Token;
c3Tkn    = ref0->RefOrigin.ObjTkn;
c4Tkn    = ref0->RefExtent.ObjTkn;
}
}
}
if (Normal(*Status))
{
if (PersonParts_OwnerOf (PartTkn,      McStat,           &PersonTkn))
{
if (Object_GetImage  (&PersonTkn,   McStat,   (addrtype *)&EmpObj))
AddressTkn       = EmpObj->Residence.ObjTkn;
if (Normal(*Status))
if (Env_IsValidToken (&AddressTkn,   McStat))
Object_GetImage   (&AddressTkn,
McStat,             (addrtype *)&AddressObj);
} else {
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"\n ***ERROR*** Owner of PersonParts for Part[%4u:%6u] not found. id= <%6u>\n",
PartTkn->DbId,   PartTkn->Handle, PartObj->id);
TraceMsg (0, Msg);
Object_Dump  (PartTkn);
#endif
EmpObj  = NullPtr;
*Status  = Env_Normal;
}
if (Normal(*Status))
if (EmpObj  != NullPtr)
{
PersonObjs_FindIn    (&EmpTkn010,  (addrtype )&EmpObj->PersonId,
McStat,                &FoundTkn);
if (*Status  == Set_NotFound)
{
*Status  = Env_Normal;
if (DrawBug)
{
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"\n ***ERROR*** PersonObjs[%4u:%6u] not found. PersonId= <%6u>\n",
EmpObj->Token.DbId,   EmpObj->Token.Handle,
EmpObj->PersonId);
TraceMsg (0, Msg);
Object_Dump  (&EmpObj->Token);
#endif
}
}
}
}
if (Normal(*Status))
if (Env_IsValidToken  (&RectTkn,     McStat))
{
Object_GetImage    (&RectTkn,     McStat,  (addrtype *)&BaseObj);
DrawBug    = False;
if (Normal(*Status))
(*BaseObj->area) (BaseObj,  McStat);
if (Normal(*Status))
if (Exports % QueBug == 0)
(*BaseObj->draw) (BaseObj,  McStat);
DrawBug    = TempDrawBug;
}
if (Normal(*Status))
if (NumExports1  % 10 && NumExports1 > 2)
BMT_QueryOn        (PartTkn,     False,        McStat);
else
Draw7              (&PrimalTkn,  False,    0,  McStat);
if (Normal(*Status))
if (EmpObj   != NullPtr)
{
PersonNames_FindIn   (&EmpTkn010,  (addrtype )EmpObj->LastName,
McStat,                &FoundTkn);
if (*Status  == Set_NotFound)
{
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"\n ***ERROR*** PersonNames[%4u:%6u] not found. LastName= <%s>\n",
EmpObj->Token.DbId,   EmpObj->Token.Handle,
EmpObj->LastName);
TraceMsg (0, Msg);
Object_Dump  (&EmpObj->Token);
#endif
*Status  = Env_Normal;
}
}
if (Normal(*Status))
if (Env_IsValidToken  (&RectTkn,     McStat))
{
DrawObjs_FindIn  (&LibTkn010,  (addrtype )&BaseObj->Id,
McStat,                 &FoundTkn);
if (*Status  == Set_NotFound)
{
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"\n ***ERROR*** DrawObj[%6u:%6u] not found in DrawObjs. Nam= <%s>\n",
RectTkn.DbId,   RectTkn.Handle, BaseObj->Id);
TraceMsg (0, Msg);
Object_Dump  (&RectTkn);
#endif
*Status  = Env_Normal;
}
}
MtrxBug  = TempMtrxBug;
SetBug   = TempSetBug;
ClassBug = TempClassBug;
Exports++;
if (!Normal(*Status))
{
TraceMsg (0, "\n BMT_Validate:: Part Object\n");
Object_Dump   (PartTkn);
}
TRACK(TrackBak,"BMT_Validate\n");
return (STAT);
}
boolean      BMT_ValidateNamedDrawObjs
(ft F,lt Z,zz *Status)
{
int              j              = 0;
tokentype        CurrentTkn     = NullToken;
tokentype        FoundTkn       = NullToken;
tokentype        ItorTkn        = NullToken;
boolean          TempSetBug     = SetBug;
nametype         Name;
if (Normal(*Status))
{
TraceMsg (0, "\n   VALIDATE NamedDrawObjs   in <DrawLib > DB.\n");
*Status  = Iterate_Begin;
j = 0;
do
{
j++;
Primal_IterateOnClassObjects (&LibTkn010,  NamedXyRect_Class,
McStat,     &ItorTkn,  &CurrentTkn);
if (Normal(*Status))
if (Attr_ValueGet            (&CurrentTkn,  Nam_Attr,
McStat,      (addrtype *)&Name))
NamedDrawObjs_FindIn      (&LibTkn010,  (addrtype )Name,
McStat,                &FoundTkn);
if (*Status  != Iterate_EndOf)
if (j == 0 || j % QueBug == 0)
{
sprintf (Msg,
" ItNum %6u. Token[%3u:%8u]. <%-16s>: Validated.\n",
j, CurrentTkn.DbId, CurrentTkn.Handle, Name);
TraceMsg (0, Msg);
}
if (*Status  == Set_NotFound)
{
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"\n ***ERROR NamedXyRect[%4u:%6u] NOT in NamedDrawObjs. Nam= <%s>\n",
CurrentTkn.DbId,   CurrentTkn.Handle, Name);
TraceMsg (0, Msg);
#endif
}
SetBug   = TempSetBug;
} while (Normal(*Status));
if (*Status  == Iterate_EndOf)
*Status   = Env_Normal;
sprintf (Msg,
" <%6u> NamedXyRects Validated in <NamedDrawObjs> set.\n", j-1);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"BMT_ValidateNamedDrawObjs\n");
return (STAT);
}
boolean      BMT_QueryOn (tokentype    *PartTkn, boolean       TraceOn,
ft F,lt Z,zz *Status)
{
numtype          ClassId        = 0;
tokentype        RectTkn        = NullToken;
tokentype        PersonTkn      = NullToken;
numtype          QueryType      = 0;
boolean          Assert         = False;
longtype         TempAsserts    = TestObj_Asserts;
longtype         TempNullAsserts= TestObj_NullAsserts;
if (!Env_IsValidToken         (PartTkn,   McStat))
{
sprintf (Msg, " BMT_Query.  Part Token[%3u:%8u] is Invalid!\n",
PartTkn->DbId, PartTkn->Handle);
TraceMsg (0, Msg);
return (STAT);
}
QueryType        = Random (4);
switch (QueryType)
{
case   0 :
if (TraceOn)
TraceMsg (0, "  Assert Query on a TestObj.\n");
TestObj_Asserts      = 0;
TestObj_NullAsserts  = 0;
Draw7  (&PrimalTkn,  False,    0,  McStat);
if (TestObj_Asserts)
Assert  = True;
TestObj_Asserts     += TempAsserts;
TestObj_NullAsserts += TempNullAsserts;
break;
case   1 :
if (TraceOn)
TraceMsg (0, "  Assert Query on a Part.\n");
Assert       = Query_AssertOnObject
(PartTkn,        Query0,          McStat);
if (Assert)
++Part_Asserts;
else
++Part_NullAsserts;
break;
case   2 :
if (Attr_ValueGet            (PartTkn,     DrawObjSlotAttr_Attr,
McStat,      (addrtype *)&RectTkn))
if (Env_IsValidToken         (&RectTkn,   McStat))
if ((ClassId    = Object_IsA (&RectTkn,   McStat)) > 0)
{
if (ClassId   == NamedXyRect_Class)
{
if (TraceOn)
TraceMsg (0, "  Assert Query on a NamedXyRect.\n");
Assert = Query_AssertOnObject
(&RectTkn,        Query4,         McStat);
if (Assert)
++NamedObj_Asserts;
else
++NamedObj_NullAsserts;
} else {
if (TraceOn)
TraceMsg (0, "  Assert Query on a DrawObj.\n");
Assert = Query_AssertOnObject
(&RectTkn,        Query3,         McStat);
if (Assert)
++DrawObj_Asserts;
else
++DrawObj_NullAsserts;
}
} else {
sprintf (Msg, " BMT_Query.  DrawPart Token[%3u:%8u] is Invalid!\n",
RectTkn.DbId, RectTkn.Handle);
TraceMsg (0, Msg);
}
break;
case   3 :
if (!PersonParts_OwnerOf (PartTkn,    McStat,     &PersonTkn))
{
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"\n ***ERROR*** Owner of PersonParts for Part[%4u:%6u] not found.\n",
PartTkn->DbId,   PartTkn->Handle);
TraceMsg (0, Msg);
Object_Dump  (PartTkn);
#endif
*Status  = Env_Normal;
} else {
if (TraceOn)
TraceMsg (0, "  Assert Query on a Person && Address.\n");
Assert    = Query_AssertOnObject
(&PersonTkn,      Query1,         McStat);
if (Assert)
++Person_Asserts;
else
++Person_NullAsserts;
}
break;
}
if (Assert)
++LookUp_Asserts;
else
++LookUp_NullAsserts;
if (TraceOn)
if (sprintf (Msg, " BMT_Query.  Token[%3u:%8u]   Assert  = %s\n",
PartTkn->DbId, PartTkn->Handle, BoolStr[Assert]))
TraceMsg (0, Msg);
if (!Normal(*Status))
{
TraceMsg (0, "\n BMT_Query:: Part Object\n");
Object_Dump   (PartTkn);
}
TRACK(TrackBak,"BMT_QueryOn\n");
return (STAT);
}
boolean      BMT_DbTransaction
(ft F,lt Z,zz *Status)
{
numtype        Option    = 0;
static numtype NumHits   = 0;
if (NumHits++ % 2)
return (STAT);
if (LibBug)
TraceMsg (0,   "\n Initiate DB TRANSACTION's of class <TestObj>\n");
Option  = Random(4) ;
switch (Option)
{
case 1:
Draw7  (&PrimalTkn,  False,    1,       McStat);
break;
case 3:
Draw7  (&PrimalTkn,  False,    3,       McStat);
break;
case 4:
Draw7  (&PrimalTkn,  False,    Option,  McStat);
break;
case 0:
default:
Draw7  (&PrimalTkn,  False,    1,       McStat);
break;
}
TRACK(TrackBak,"BMT_DbTransaction\n");
return (STAT);
}
boolean BMT_CommitPartDrawObj
(tokentype    *PartTkn,  boolean     Release,
ft F,lt Z,zz *Status)
{
boolean          TempClassBug   = ClassBug;
tokentype        c3Tkn          = NullToken;
tokentype        c4Tkn          = NullToken;
Rectangle       *r0             = NullPtr;
RefRect         *ref0           = NullPtr;
tokentype        FoundTkn       = NullToken;
tokentype        RectTkn        = NullToken;
numtype          DrawClass      = 0;
if (Env_IsValidToken     (PartTkn,              McStat))
{
if (ClassBug)
if (sprintf (Msg, "  Commit Draw Object of this part [%4u:%8u]\n",
PartTkn->DbId, PartTkn->Handle))
TraceMsg (0,   Msg);
if (ClassBug)
Object_Dump        (PartTkn);
Attr_ValueGet         (PartTkn,     DrawObjSlotAttr_Attr,
McStat,      (addrtype *)&RectTkn);
if (Normal(*Status))
if (Env_IsValidToken           (&RectTkn,     McStat))
if ((DrawClass = Object_IsA    (&RectTkn,     McStat)) > 0)
if (DrawClass         == Rectangle_Class)
{
if ((r0  = Rectangle_new4   (&RectTkn,     McStat)) != NullPtr)
{
FoundTkn                = r0->Token;
c3Tkn                   = r0->Origin->Token;
c4Tkn                   = r0->Extent->Token;
}
if (Normal(*Status))
if (Object_CommitImage      (&RectTkn,     Release,   McStat))
if (Object_CommitImage      (&c3Tkn,       Release,   McStat))
Object_CommitImage      (&c4Tkn,       Release,   McStat);
DrawObjs++;
Points      += 2;
} else if (DrawClass == RefRect_Class) {
if ((ref0  = RefRect_new3   (&RectTkn,     McStat)) != NullPtr)
{
FoundTkn               = ref0->Token;
c3Tkn                  = ref0->RefOrigin.ObjTkn;
c4Tkn                  = ref0->RefExtent.ObjTkn;
}
if (Normal(*Status))
if (Object_CommitImage      (&RectTkn,     Release,   McStat))
if (Object_CommitImage      (&c3Tkn,       Release,   McStat))
Object_CommitImage      (&c4Tkn,       Release,   McStat);
DrawObjs++;
Points      += 2;
} else {
Object_CommitImage          (&RectTkn,     Release,   McStat);
DrawObjs++;
}
}
ClassBug   = TempClassBug;
TRACK(TrackBak,"BMT_CommitPartDrawObj\n");
return (STAT);
}
boolean BMT_DeletePartDrawObj
(tokentype    *PartTkn,   ft F,lt Z,zz *Status)
{
boolean          TempClassBug   = ClassBug;
tokentype        c3Tkn          = NullToken;
tokentype        c4Tkn          = NullToken;
Rectangle       *r0             = NullPtr;
RefRect         *ref0           = NullPtr;
tokentype        FoundTkn       = NullToken;
tokentype        RectTkn        = NullToken;
numtype          DrawClass      = 0;
numtype          Id             = 0;
nametype         DrawName;
DrawName[0]            = '\0';
if (DeleteDrawObjects)
if (Normal(*Status))
if (Env_IsValidToken     (PartTkn,              McStat))
{
if (ClassBug)
if (sprintf (Msg, "  UnPair From <Part > Object[%4u:%8u]\n",
PartTkn->DbId, PartTkn->Handle))
TraceMsg (0,   Msg);
if (ClassBug)
Object_Dump        (PartTkn);
if (Attr_ValueGet     (PartTkn,     DrawObjSlotAttr_Attr,
McStat,      (addrtype *)&RectTkn))
if (Attr_ValuePut     (PartTkn,     DrawObjSlotAttr_Attr,
(addrtype *)&NullToken,   McStat))
if (Env_IsValidToken  (&RectTkn,                 McStat))
{
if (Attr_ValueGet     (&RectTkn,    Id_Attr,
McStat,      (addrtype *)&Id))
DrawClass = Object_IsA        (&RectTkn,     McStat);
if (Normal(*Status))
if (Env_IsValidToken           (&RectTkn,     McStat))
if (DrawClass         == Rectangle_Class)
{
if ((r0  = Rectangle_new4   (&RectTkn,     McStat)) != NullPtr)
{
FoundTkn                = r0->Token;
c3Tkn                   = r0->Origin->Token;
c4Tkn                   = r0->Extent->Token;
}
if (Normal(*Status))
if (Object_Delete           (&RectTkn,     McStat))
if (Object_Delete           (&c3Tkn,       McStat))
Object_Delete           (&c4Tkn,       McStat);
DrawObjs++;
Points      += 2;
if (Normal(*Status))
{
LibRectangles_FindIn     (&LibTkn010,  (addrtype )&Id,
McStat,                 &FoundTkn);
if (*Status  == Set_NotFound
||  *Status  == Set_EmptySet)
*Status   = Env_Normal;
else {
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"  ***ERROR*** [%4u:%8u] Still In Set <LibRectangles>;  Id =<%6u>.\n",
RectTkn.DbId, RectTkn.Handle,  Id);
TraceMsg (0,   Msg);
#endif
*Status  = Env_Normal;
}
}
} else if (DrawClass == RefRect_Class) {
if ((ref0  = RefRect_new3   (&RectTkn,     McStat)) != NullPtr)
{
FoundTkn               = ref0->Token;
c3Tkn                  = ref0->RefOrigin.ObjTkn;
c4Tkn                  = ref0->RefExtent.ObjTkn;
}
if (Normal(*Status))
if (Object_Delete           (&RectTkn,     McStat))
if (Object_Delete           (&c3Tkn,       McStat))
Object_Delete           (&c4Tkn,       McStat);
DrawObjs++;
Points      += 2;
} else if (DrawClass == NamedXyRect_Class) {
if (Attr_ValueGet     (&RectTkn,    Nam_Attr,
McStat,      (addrtype *)&DrawName))
#ifndef __BAD_CODE__
Object_Delete     (&RectTkn,     McStat);
#endif
if (Normal(*Status))
{
NamedDrawObjs_FindIn     (&LibTkn010,  (addrtype )&DrawName,
McStat,                 &FoundTkn);
if (*Status  == Set_NotFound
||  *Status  == Set_EmptySet)
*Status   = Env_Normal;
else {
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"  ***ERROR*** <Draw >[%4u:%8u] Still In Set <NamedDrawObjs>;  Id =<%6u>.\n",
RectTkn.DbId, RectTkn.Handle,  Id);
TraceMsg (0,   Msg);
#endif
*Status  = Env_Normal;
}
}
DrawObjs++;
NamedObjs++;
} else {
Object_Delete               (&RectTkn,     McStat);
DrawObjs++;
}
if (Normal(*Status))
{
DrawObjs_FindIn            (&LibTkn010,  (addrtype )&Id,
McStat,                 &FoundTkn);
if (*Status  == Set_NotFound
||  *Status  == Set_EmptySet)
*Status   = Env_Normal;
else {
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,
"  ***ERROR*** [%4u:%8u] Still In Set <DrawObjs>;  Id =<%6u>.\n",
RectTkn.DbId, RectTkn.Handle,  Id);
TraceMsg (0,   Msg);
#endif
*Status  = Env_Normal;
}
}
}
}
ClassBug   = TempClassBug;
TRACK(TrackBak,"BMT_DeletePartDrawObj\n");
return (STAT);
}
boolean      BMT_TraverseSets
(ft F,lt Z,zz *Status)
{
tokentype        NextNode       = NullToken;
tokentype        NextTkn        = NullToken;
tokentype        CurrentNode    = NullToken;
tokentype        CurrentTkn     = NullToken;
int              ItNum          = 0;
numtype          TempQueBug     = QueBug;
treeiterfunc     IterNamesFunc  = (treeiterfunc )BMT_Iter2;
NextNode.DbId    = LibTkn010.DbId;
NextTkn.DbId     = LibTkn010.DbId;
CurrentNode.DbId = LibTkn010.DbId;
CurrentTkn.DbId  = LibTkn010.DbId;
if (Normal(*Status))
{
TraceMsg (0, "\n SET  <DrawObjs>    entries::\n");
for (ItNum = 0;
(ItNum =  DrawObjs_IterateOn (&LibTkn010,             ItNum,
McStat,  &CurrentNode, &CurrentTkn))
>= 0  && Normal(*Status);)
{
BMT_Iter3   (&CurrentTkn,  ItNum,  McStat);
}
sprintf (Msg, "   Iteration count =%6u\n",  Iter3_Count);
TraceMsg (0, Msg);
}
if (Normal(*Status))
{
TraceMsg (0, "\n SET  <NamedDrawObjs>  entries::\n");
NamedDrawObjs_IterateOn (&LibTkn010,     BMT_Iter4,  McStat);
	if( *Status == Iterate_EndOf )
	   *Status = Env_Normal;
sprintf (Msg, "   Iteration count =%6u\n",  Iter4_Count);
TraceMsg (0, Msg);
QueBug = TempQueBug;
}
if (Normal(*Status))
{
TraceMsg (0, "\n SET  <LibRectangles>  entries::\n");
LibRectangles_IterateOn (&LibTkn010,     BMT_Iter3,  McStat);
	if( *Status == Iterate_EndOf )
	   *Status = Env_Normal;
sprintf (Msg, "   Iteration count =%6u\n",  Iter3_Count);
TraceMsg (0, Msg);
}
if (Normal(*Status))
{
TraceMsg (0, "\n LIST <DbRectangles>   entries::\n");
List01_IterateOn        (&RectListTkn,   BMT_Iter1,  McStat);
	if( *Status == Iterate_EndOf )
	   *Status = Env_Normal;
sprintf (Msg, "   Iteration count =%6u\n",  Iter1_Count);
TraceMsg (0, Msg);
}
if (Normal(*Status))
{
TraceMsg (0, "\n SET  <PersonNames  >  entries::\n");
PersonNames_IterateOn (&EmpTkn010,     IterNamesFunc,   McStat);
	if( *Status == Iterate_EndOf )
	   *Status = Env_Normal;
sprintf (Msg, "   Iteration count =%6u\n",  Iter2_Count);
TraceMsg (0, Msg);
}
QueBug = TempQueBug;
#ifdef     __INCLUDE_MTRX__
if (!Normal(*Status))
{
TraceMsg (0, "\n MATRIX <TosFroms>       entries::\n");
TraceMsg (0, "\n");
}
#endif
TRACK(TrackBak,"BMT_TraverseSets\n");
return (STAT);
}
boolean BMT_Iter1        (tokentype    *Token,   numtype       ItNum,
ft F,lt Z,zz *Status)
{
if (ItNum        == 1)
Iter1_Count    = 1;
else
Iter1_Count++;
if ((ItNum - 1) % QueBug == 0)
{
sprintf (Msg, "  %6u. [%4u:%6u]\n",
ItNum, Token->DbId, Token->Handle);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"BMT_Iter1\n");
return (STAT);
}
boolean  BMT_Iter2       (tokentype    *Token,     indextype     ItNum,
ft F,lt Z,zz *Status)
{
boolean             IsValid = False;
numtype             j      = ItNum;
Person             *P010   = NullPtr;
if (ItNum        == 1)
Iter2_Count    = 1;
else
Iter2_Count++;
if (Env_IsValidToken             (Token,        McStat))
if (Object_GetImage (Token,       McStat,       (addrtype *)&P010))
IsValid                     = True;
if ((ItNum-1) % QueBug == 0)
{
if (j == 0 || j % QueBug == 0
||  (P010->LastName[0] > 'Q'
&& P010->LastName[0] < 'S'))
{
sprintf (Msg, " %6d. [%3u:%8u] Name:= <%-16s>, %-16s",
ItNum, Token->DbId, Token->Handle,
P010->LastName, P010->FirstName);
TraceMsg (0, Msg);
if (!IsValid)
TraceMsg (0, "   IN_VALID.\n");
else
TraceMsg (0, "\n");
}
} else if (IsValid  == False) {
sprintf (Msg, " %6d. [%3u:%8u]   IN_VALID.\n",
ItNum, Token->DbId, Token->Handle);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"BMT_Iter2\n");
return (STAT);
}
boolean  BMT_Iter3       (tokentype    *Token,     indextype     ItNum,
ft F,lt Z,zz *Status)
{
boolean             IsValid = False;
numtype             Id      = 0;
tokentype           NodeTkn = NullToken;
if (ItNum        == 1)
Iter3_Count    = 1;
else
Iter3_Count++;
NodeTkn.DbId                = Token->DbId;
if (Env_IsValidToken         (Token,                    McStat))
if (Attr_ValueGet            (Token,                    Id_Attr,
McStat,      (addrtype *)&Id))
if (Attr_ValueGet            (Token,        MemberDrawObjs_Attr,
McStat,      (addrtype *)&NodeTkn))
IsValid                  = True;
if ((ItNum-1) % QueBug == 0  || IsValid  == False)
{
sprintf (Msg, " %6d. [%3u:%8u]  := <%-8u>; @[:%6u]",
ItNum, Token->DbId, Token->Handle,
Id, NodeTkn.Handle);
TraceMsg (0, Msg);
if (!IsValid)
TraceMsg (0, "   IN_VALID.\n");
else
TraceMsg (0, "\n");
}
TRACK(TrackBak,"BMT_Iter3\n");
return (STAT);
}
boolean  BMT_Iter4       (tokentype    *Token,     indextype     ItNum,
ft F,lt Z,zz *Status)
{
boolean             IsValid = False;
nametype            Name;
if (ItNum        == 1)
Iter4_Count    = 1;
else
Iter4_Count++;
if (Env_IsValidToken         (Token,        McStat))
if (Attr_ValueGet            (Token,        Nam_Attr,
McStat,      (addrtype *)&Name))
IsValid                  = True;
if ((ItNum-1) % QueBug == 0  || IsValid  == False)
{
sprintf (Msg, " %6d. [%3u:%8u]  := <%-8s>;",
ItNum, Token->DbId, Token->Handle, Name);
TraceMsg (0, Msg);
if (!IsValid)
TraceMsg (0, "   IN_VALID.\n");
else
TraceMsg (0, "\n");
}
TRACK(TrackBak,"BMT_Iter4\n");
return (STAT);
}
boolean BMT_ExportPart   (longtype      X,       longtype      Y,
parttype      Type,    ft F,lt Z,zz *Status)
{
static  numtype   NumExports2   = 0;
if (ClassBug)
if (sprintf (Msg, "  BMT_ExportPart:: X=%d,  Y=%d; PartType=%u\n",
X, Y, Type))
TraceMsg (0,   Msg);
NumExports2++;
TRACK(TrackBak,"BMT_ExportPart\n");
return (STAT);
}
boolean BMT_ImportPart   (longtype     *X,       longtype     *Y,
ft F,lt Z,zz *Status)
{
if (ClassBug)
if (sprintf (Msg, "  BMT_ImportPart:: X=%d,  Y=%d;\n",
X, Y))
TraceMsg (0,   Msg);
TRACK(TrackBak,"BMT_ImportPart\n");
return (STAT);
}
boolean BMT_BuildPersonLib
(tokentype    *LibToken,  numtype       MaxPersons,
ft F,lt Z,zz *Status)
{
#ifdef __DISPLAY_TIME__
time_t              NullTime           = 0;
time_t              CurrTime           = 0;
time_t              Elapsed            = 0;
float                Seconds            = 0.0;
#endif
int                  j                  = -1;
tokentype            PersonTkn          = NullToken;
Person              *Person             = NullPtr;
tokentype            AddressTkn         = NullToken;
static char          TabStr[MAXLINE+1]  = " ";
char                *TabStrPtr          = TabStr;
FilePtrType          TabFilePtr         = NullPtr;
numtype              TabCount           = 15;
importspec           TabFields[15];
TraceMsg (0, "\n ***NOTE***  Persons Library Extended!\n");
sprintf (Msg, "\n Create <%5u> Persons.\n",
MaxPersons);
TraceMsg (0, Msg);
if ( (TabFilePtr = InFilePtr)                  == NULL)
{
fprintf (stderr, "***ERROR... Can't open TAB file <%s>\n",
InFileName);
*Status   = Err_NotImplemented;
} else {
TabFields[0].ClassId   = 0;
TabFields[0].AttrId    = 0;
TabFields[1].ClassId   = Address_Class;
TabFields[1].AttrId    = Street_Attr;
TabFields[2].ClassId   = Address_Class;
TabFields[2].AttrId    = Suite_Attr;
TabFields[3].ClassId   = Address_Class;
TabFields[3].AttrId    = City_Attr;
TabFields[4].ClassId   = Address_Class;
TabFields[4].AttrId    = State_Attr;
TabFields[5].ClassId   = Address_Class;
TabFields[5].AttrId    = Country_Attr;
TabFields[6].ClassId   = Address_Class;
TabFields[6].AttrId    = ZipCode_Attr;
TabFields[7].ClassId   = 0;
TabFields[7].AttrId    = 0;
TabFields[8].ClassId   = Address_Class;
TabFields[8].AttrId    = Phone_Attr;
TabFields[9].ClassId   = Address_Class;
TabFields[9].AttrId    = Fax_Attr;
TabFields[10].ClassId  = 0;
TabFields[10].AttrId   = 0;
TabFields[11].ClassId  = 0;
TabFields[11].AttrId   = 0;
TabFields[12].ClassId  = 0;
TabFields[12].AttrId   = 0;
TabFields[13].ClassId  = Person_Class;
TabFields[13].AttrId   = FirstName_Attr;
TabFields[14].ClassId  = Person_Class;
TabFields[14].AttrId   = LastName_Attr;
}
#ifdef __DISPLAY_TIME__
NullTime = clock();
#endif
j   = -1;
while (Normal(*Status)
&&     ++j < MaxPersons
&&     (TabStrPtr  = fgets (TabStr,  MAXLINE,  TabFilePtr)) != NULL)
{
Person_Import    (&EmpTkn010,    TabStrPtr,   TabFields,  TabCount,
McStat,       &PersonTkn);
if (*Status  == Set_AlreadyInSet)
{
--j;
*Status    = Env_Normal;
} else if (Normal(*Status)) {
if (Object_GetImage    (&PersonTkn,  McStat,     (addrtype *)&Person))
{
AddressTkn    = Person->Residence.ObjTkn;
if (j == 0 || j % QueBug == 0)
{
sprintf (Msg,
" ItNum %6u. Person[%3u:%8u]. Name= %-16s, %-16s;\n",
j, PersonTkn.DbId, PersonTkn.Handle,
Person->LastName, Person->FirstName);
TraceMsg (0, Msg);
}
}
if (Normal(*Status))
if (Object_CommitImage (&PersonTkn,   False, McStat))
Object_CommitImage (&AddressTkn,  False, McStat);
}
}
if (Normal(*Status))
{
TraceMsg (0, "\n LAST Person Read::\n");
sprintf (Msg, " ItNum %6u. Person[%3u:%8u]. Name= %-16s, %-16s;\n",
j, PersonTkn.DbId, PersonTkn.Handle,
Person->LastName, Person->FirstName);
TraceMsg (0, Msg);
if (DrawBug)
{
Object_Dump (&PersonTkn);
Object_Dump (&AddressTkn);
}
}
#ifdef __DISPLAY_TIME__
Elapsed    = clock() - NullTime;
Seconds    = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg, "\n Instantiate/Commit Time = %4.2f sec, for %u Person's\n",
Seconds, j);
TraceMsg (MSGFILE, Msg);
#endif
TRACK(TrackBak,"BMT_BuildPersonLib\n");
return (STAT);
}
boolean      BMT_InitQuerys
(ft F,lt Z,zz *Status)
{
if (Query0 == NullPtr)
{
TraceMsg (0, "\n BUILD <Query0>   for <Part2>  class::\n");
sprintf  (Msg, "\n  if (link[1].length %s  %3u) ::\n",
CompareOpLex[aGTE], val0);
TraceMsg (0, Msg);
if (Query_Create         (McStat,      &Query0))
if (Query_BeginBuild     (Query0,       McStat))
if (Query_ScopeOn        (Query0,      "Part2",  True,  McStat))
if (Query_OpenParen      (Query0,       McStat))
if (Query_AffixCompare   (Query0,     "c1.length",      aGTE,
(addrtype )&val0,        McStat))
if (Query_AffixBoolOp    (Query0,      aAND,       McStat))
if (Query_AffixCompare   (Query0,     "c2.length",      aGTE,
(addrtype )&val0,        McStat))
if (Query_AffixBoolOp    (Query0,      aAND,       McStat))
if (Query_AffixCompare   (Query0,     "c3.length",      aGTE,
(addrtype )&val0,        McStat))
if (Query_CloseParen     (Query0,       McStat))
if (Query_EndBuild       (Query0,       McStat))
if (ClassBug)
Query_Dump           (Query0);
}
if (Normal(*Status))
if (Query2 == NullPtr)
{
TraceMsg (0, "\n Build Query2 for <Address>   class::\n");
sprintf (Msg, "\n  if (State == %s || State == %s)\n",
StateNam1,  StateNam2);
TraceMsg (0, Msg);
if (Query_Create         (McStat,     &Query2))
if (Query_BeginBuild     (Query2,      McStat))
if (Query_ScopeOn        (Query2,     "Address",
INCLUSIVE,   McStat))
if (Query_OpenParen      (Query2,      McStat))
if (Query_AffixCompare   (Query2,     "State",    aEQ,
(addrtype )&StateNam1,  McStat))
if (Query_AffixBoolOp    (Query2,     aOR,        McStat))
if (Query_AffixCompare   (Query2,     "State",    aEQ,
(addrtype )&StateNam2,  McStat))
if (Query_CloseParen     (Query2,      McStat))
if (Query_EndBuild       (Query2,      McStat))
if (ClassBug)
{
Query_Dump           (Query2);
}
}
if (Normal(*Status))
if (Query1 == NullPtr)
{
TraceMsg (0, "\n Build Query1 for <Person>    class::\n");
sprintf (Msg,
"\n  if (LastName  >= %s && LastName <= %s && Query0(Residence)) ::\n",
NameComp0, NameComp1);
TraceMsg (0, Msg);
if (Query_Create         (McStat,      &Query1))
if (Query_BeginBuild     (Query1,       McStat))
if (Query_ScopeOn        (Query1,      "Person",   True,        McStat))
if (Query_SortBy         (Query1,      "LastName", aAscending,  McStat))
if (Query_OpenParen      (Query1,       McStat))
if (Query_AffixCompare   (Query1,      "LastName", aGTE,
(addrtype )&NameComp0,   McStat))
if (Query_AffixBoolOp    (Query1,       aAND,      McStat))
if (Query_AffixCompare   (Query1,      "LastName", aLTE,
(addrtype )&NameComp1,   McStat))
if (Query_AffixBoolOp    (Query1,       aAND,      McStat))
if (Query_AffixRefQuery  (Query1,      "Residence",
Query2,       McStat))
if (Query_CloseParen     (Query1,       McStat))
if (Query_EndBuild       (Query1,       McStat))
if (ClassBug)
Query_Dump           (Query1);
}
if (Normal(*Status))
if (Query3 == NullPtr)
{
GTEval1 = 3 * QueBug;
GTEval2 = GTEval1     + 1;
GTEval3 = GTEval1     + 2;
LTEval  = 7 * QueBug;
TraceMsg (0,  "\n BUILD <Query3> for <DrawObj>    class::\n");
sprintf (Msg, "\n  if (Id  >= %3u \n", GTEval1);
TraceMsg (0, Msg);
sprintf (Msg,   "  &&  (Id >= %3u && Id <= %3u)\n",
GTEval1,  GTEval2,  LTEval);
TraceMsg (0, Msg);
sprintf (Msg,   "  &&  Id >= %3u)\n",
GTEval3);
TraceMsg (0, Msg);
if (Query_Create         (McStat,     &Query3))
if (Query_BeginBuild     (Query3,       McStat))
if (Query_ScopeOn        (Query3,      "DrawObj",  True,        McStat))
if (Query_SortBy         (Query3,      "Id",       aAscending,  McStat))
if (Query_OpenParen      (Query3,       McStat))
if (Query_AffixCompare   (Query3,      "Id",       aGTE,
(addrtype )&GTEval1,     McStat))
if (Query_AffixBoolOp    (Query3,      aAND,       McStat))
if (Query_OpenParen      (Query3,       McStat))
if (Query_AffixCompare   (Query3,      "Id",       aGTE,
(addrtype )&GTEval2,     McStat))
if (Query_AffixBoolOp    (Query3,      aAND,       McStat))
if (Query_AffixCompare   (Query3,      "Id",       aLTE,
(addrtype )&LTEval,      McStat))
if (Query_CloseParen     (Query3,       McStat))
if (Query_AffixBoolOp    (Query3,      aAND,       McStat))
if (Query_AffixCompare   (Query3,      "Id",       aGTE,
(addrtype )&GTEval3,    McStat))
if (Query_CloseParen     (Query3,       McStat))
if (Query_EndBuild       (Query3,       McStat))
if (ClassBug)
Query_Dump           (Query3);
}
if (Normal(*Status))
if (Query4 == NullPtr)
{
TraceMsg (0, "\n BUILD <Query4> for <NamedDrawObj>   class::\n");
sprintf (Msg, "\n  if (Nam == %10s\n",
GTEnam1);
TraceMsg (0, Msg);
sprintf (Msg,   "  || (Nam == %10s  || == %10s   || == %10s\n",
GTEnam2,  GTEnam3, GTEnam4);
TraceMsg (0, Msg);
sprintf (Msg,   "       || == %10s  || == %10s   || == %10s)\n",
GTEnam5,  GTEnam6,  GTEnam7);
TraceMsg (0, Msg);
sprintf (Msg,   "  && Id <= %u)\n",
LTEnames);
TraceMsg (0, Msg);
if (Query_Create         (McStat,     &Query4))
if (Query_BeginBuild     (Query4,      McStat))
if (Query_ScopeOn        (Query4,     "NamedDrawObj",
INCLUSIVE,   McStat))
if (Query_SortBy         (Query4,     "Id",       aAscending,  McStat))
if (Query_OpenParen      (Query4,      McStat))
if (Query_AffixCompare   (Query4,     "Nam",      aEQ,
(addrtype )&GTEnam1,    McStat))
if (Query_AffixBoolOp    (Query4,     aOR,        McStat))
if (Query_OpenParen      (Query4,      McStat))
if (Query_AffixCompare   (Query4,     "Nam",      aEQ,
(addrtype )&GTEnam2,     McStat))
if (Query_AffixBoolOp    (Query4,     aOR,        McStat))
if (Query_AffixCompare   (Query4,     "Nam",      aEQ,
(addrtype )&GTEnam3,     McStat))
if (Query_AffixBoolOp    (Query4,     aOR,        McStat))
if (Query_AffixCompare   (Query4,     "Nam",      aEQ,
(addrtype )&GTEnam4,     McStat))
if (Query_AffixBoolOp    (Query4,     aOR,        McStat))
if (Query_AffixCompare   (Query4,     "Nam",      aEQ,
(addrtype )&GTEnam5,     McStat))
if (Query_AffixBoolOp    (Query4,     aOR,        McStat))
if (Query_AffixCompare   (Query4,     "Nam",      aEQ,
(addrtype )&GTEnam6,     McStat))
if (Query_AffixBoolOp    (Query4,     aOR,        McStat))
if (Query_AffixCompare   (Query4,     "Nam",      aEQ,
(addrtype )&GTEnam7,     McStat))
if (Query_CloseParen     (Query4,      McStat))
if (Query_AffixBoolOp    (Query4,     aAND,       McStat))
if (Query_AffixCompare   (Query4,     "Id",       aLTE,
(addrtype )&LTEnames,   McStat))
if (Query_CloseParen     (Query4,      McStat))
if (Query_EndBuild       (Query4,      McStat))
if (ClassBug)
{
WriteHdr   = True;
Query_Dump           (Query4);
WriteHdr   = False;
}
}
TRACK(TrackBak,"BMT_InitQuerys\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\bmt10.c*/

#define  __DISPLAY_TIME__
#define BMT_C
#ifdef __DISPLAY_TIME__
#endif


typedef Part2  Part;

boolean BMT_LookUpParts    (longtype      LookUps,  ft F,lt Z,zz *Status)
{
tokentype      PartTkn      = NullToken;
unsigned int   i            = 0;
#ifdef __DISPLAY_TIME__
time_t        NullTime     = 0;
time_t        Elapsed      = 0;
float          Seconds      = 0;
#endif
partidtype     FromPart     = 0;
boolean        TempClassBug = ClassBug;
boolean        TempDbmBug   = DbmBug;
PartTkn.DbId          = LibTkn.DbId;
LookUp_Asserts        = 0;
Part_Asserts          = 0;
DrawObj_Asserts       = 0;
NamedObj_Asserts      = 0;
Person_Asserts        = 0;
TestObj_Asserts       = 0;
LookUp_NullAsserts    = 0;
Part_NullAsserts      = 0;
DrawObj_NullAsserts   = 0;
NamedObj_NullAsserts  = 0;
Person_NullAsserts    = 0;
TestObj_NullAsserts   = 0;
sprintf  (Msg, "\n LOOK UP %6u Random Parts and Export each Part.\n",
LookUps);
TraceMsg (0,   Msg);
#ifdef __DISPLAY_TIME__
NullTime = clock();
#endif
i = 0;
while (Normal(*Status)
&&     ++i   <= LookUps)
{
FromPart          = Random(NumVlists);
FromPart          = Vlists[FromPart];
if (Part_GetToken  (&LibTkn,                 FromPart,
McStat,                 &PartTkn))
if (PartTkn.Handle)
BMT_Validate   (&PartTkn,                McStat);
if (ClassBug          || OaBug
||  PartTkn.Handle    == 0
||  i % 100           == 0)
if (sprintf (Msg, " Set %6u. Part# %8u Handle= %8u.\n",
i, FromPart,  PartTkn.Handle))
if (TraceMsg (0, Msg))
if (DrawBug)
if (ClassBug || i == 100)
if (PartTkn.Handle)
Object_Dump    (&PartTkn);
}
ClassBug   = TempClassBug;
DbmBug     = TempDbmBug;
#ifdef __DISPLAY_TIME__
Elapsed    = clock() - NullTime;
Seconds    = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,
"\n LookUp Time = %4.2f sec; for %6u parts; Asserts =%6lu\n",
Seconds, i, LookUp_Asserts);
TraceMsg (MSGFILE, Msg);
#else
#endif
sprintf  (Msg, "\n LookUp for %6u parts; Asserts =%6lu\n",
i, LookUp_Asserts);
TraceMsg (0, Msg);
sprintf  (Msg,
"       <Part2    >  Asserts =%6lu; NULL Asserts =%6lu.\n",
Part_Asserts, Part_NullAsserts);
TraceMsg (0, Msg);
sprintf  (Msg,
"       <DrawObj  >  Asserts =%6lu; NULL Asserts =%6lu.\n",
DrawObj_Asserts, DrawObj_NullAsserts);
TraceMsg (0, Msg);
sprintf  (Msg,
"       <NamedObj >  Asserts =%6lu; NULL Asserts =%6lu.\n",
NamedObj_Asserts, NamedObj_NullAsserts);
TraceMsg (0, Msg);
sprintf  (Msg,
"       <Person   >  Asserts =%6lu; NULL Asserts =%6lu.\n",
Person_Asserts, Person_NullAsserts);
TraceMsg (0, Msg);
sprintf  (Msg,
"       <TestObj  >  Asserts =%6lu; NULL Asserts =%6lu.\n",
TestObj_Asserts, TestObj_NullAsserts);
TraceMsg (0, Msg);
LookUp_Asserts        = 0;
Part_Asserts          = 0;
DrawObj_Asserts       = 0;
NamedObj_Asserts      = 0;
Person_Asserts        = 0;
TestObj_Asserts       = 0;
LookUp_NullAsserts    = 0;
Part_NullAsserts      = 0;
DrawObj_NullAsserts   = 0;
NamedObj_NullAsserts  = 0;
Person_NullAsserts    = 0;
TestObj_NullAsserts   = 0;
TRACK(TrackBak,"BMT_LookUpParts\n");
return (STAT);
}
boolean BMT_CommitParts    (boolean       Release, ft F,lt Z,zz *Status)
{
tokentype        PartTkn        = NullToken;
numtype          PartId         = 0;
int              i              = 0;
#ifdef __DISPLAY_TIME__
time_t           NullTime       = 0;
time_t           Elapsed        = 0;
float            Seconds        = 0;
#endif
tokentype        FOIdTkn        = NullToken;
boolean          TempClassBug   = ClassBug;
tokentype        PersonTkn      = NullToken;
static boolean   FirstTime      = True;
int              j              = 0;
tokentype        CurrentTkn     = NullToken;
tokentype        ItorTkn        = NullToken;
Parts          = 0;
DrawObjs       = 0;
NamedObjs      = 0;
Points         = 0;
Persons        = 0;
PartTkn.DbId        = LibTkn.DbId;
sprintf (Msg, "\n COMMIT All Image copies:: Release=<%s>; Max Parts=%4u\n",
BoolStr[Release], MaxParts);
TraceMsg (0,   Msg);
#ifdef __DISPLAY_TIME__
NullTime = clock();
#endif
if (FirstTime)
{
FirstTime = False;
}
i           = -1;
while (Normal(*Status)
&&    ++i   < NumVlists)
{
PartId                 = Vlists[i];
if (Part_GetToken        (&LibTkn,               PartId,
McStat,               &PartTkn))
if (Env_IsValidToken     (&PartTkn,              McStat))
{
if (ClassBug)
if (sprintf (Msg, "  Commit part= %u\n", PartId))
TraceMsg (0,   Msg);
if (ExportGeneric)
Part_ImportFrom    (&ApiTestTkn,  (void *)&FOIdTkn,
&PartTkn,              McStat);
else if (ExportParts)
Part_ExportTo      (&PartTkn,            &ApiTestTkn,
(void *)&FOIdTkn,     McStat);
if (ClassBug)
Object_Dump        (&PartTkn);
if (Normal(*Status))
if (Object_ImageIsActive       (&PartTkn,     McStat))
BMT_CommitPartDrawObj       (&PartTkn,     Release,    McStat);
if (Normal(*Status))
if (PersonParts_OwnerOf        (&PartTkn,     McStat,    &PersonTkn))
if (Env_IsValidToken           (&PersonTkn,   McStat))
if (Object_ImageIsActive       (&PersonTkn,   McStat))
{
Object_CommitImage          (&PersonTkn,   Release,    McStat);
Persons++;
}
if (Normal(*Status))
if (Object_ImageIsActive       (&PartTkn,     McStat))
{
Object_CommitImage          (&PartTkn,     Release,    McStat);
Parts++;
}
}
ClassBug   = TempClassBug;
}
sprintf (Msg,  " <%6u> Part            images'  Committed.\n", Parts);
TraceMsg (0, Msg);
sprintf (Msg,  " <%6u> DrawObj         images'  Committed.\n", DrawObjs);
sprintf (Msg,  "                 <%6u> are Named.\n", NamedObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " <%6u> Point           images'  Committed.\n", Points);
TraceMsg (0, Msg);
sprintf (Msg,  " <%6u> Person          images'  Committed.\n", Persons);
TraceMsg (0, Msg);
#ifdef __DISPLAY_TIME__
Elapsed    = clock() - NullTime;
Seconds    = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,
"\n COMMIT Parts(* %8d)::  Time = %4.2f sec;\n",
i, Seconds);
TraceMsg (MSGFILE, Msg);
#else
#endif
sprintf  (Msg, "\n COMMIT Parts(* %8d)\n", i);
TraceMsg (0, Msg);
if (Normal(*Status))
{
TraceMsg (0, "\n Commit TestObj_Class        in <Primal> DB.\n");
*Status  = Iterate_Begin;
j = 0;
do
{
if (Primal_IterateOnClassObjects (&PrimalTkn,  TestObj_Class,
McStat,     &ItorTkn,  &CurrentTkn))
if (*Status  != Iterate_EndOf)
if (Object_ImageIsActive         (&CurrentTkn, McStat))
Object_CommitImage           (&CurrentTkn, Release,   McStat);
if (j == 0 || j % QueBug == 0)
{
sprintf (Msg,
" ItNum %6u. Token[%3u:%8u]. TestObj        Committed.\n",
j, CurrentTkn.DbId, CurrentTkn.Handle);
TraceMsg (0, Msg);
}
j++;
ClassBug   = TempClassBug;
} while (Normal(*Status));
if (*Status  == Iterate_EndOf)
*Status   = Env_Normal;
sprintf (Msg,  " <%6u> TestObj         images'  Committed.\n", j-1);
TraceMsg (0, Msg);
}
if (Normal(*Status))
{
TraceMsg (0, "\n Commit CartesianPoint_Class in <Primal> DB.\n");
*Status  = Iterate_Begin;
j = 0;
do
{
if (Primal_IterateOnClassObjects (&PrimalTkn,  CartesianPoint_Class,
McStat,     &ItorTkn,  &CurrentTkn))
if (*Status  != Iterate_EndOf)
if (Object_ImageIsActive         (&CurrentTkn, McStat))
Object_CommitImage            (&CurrentTkn, Release,   McStat);
if (j == 0 || j % QueBug == 0)
{
sprintf (Msg,
" ItNum %6u. Token[%3u:%8u]. CartesianPoint Committed.\n",
j, CurrentTkn.DbId, CurrentTkn.Handle);
TraceMsg (0, Msg);
}
j++;
} while (Normal(*Status));
if (*Status  == Iterate_EndOf)
*Status   = Env_Normal;
sprintf (Msg,  " <%6u> CartesianPoint  images'  Committed.\n", j-1);
TraceMsg (0, Msg);
}
ClassBug   = TempClassBug;
TRACK(TrackBak,"BMT_CommitParts\n");
return (STAT);
}
boolean BMT_DeleteParts    (longtype      Deletes,  ft F,lt Z,zz *Status)
{
tokentype      PartTkn      = NullToken;
unsigned int   i            = 0;
#ifdef __DISPLAY_TIME__
time_t         NullTime     = 0;
time_t         Elapsed      = 0;
float          Seconds      = 0;
#endif
partidtype     FromPart     = 0;
boolean        TempClassBug = ClassBug;
static boolean FirstTime    = True;
DeleteDrawObjects = True;
PartTkn.DbId          = LibTkn.DbId;
sprintf  (Msg, "\n DELETE  %6u Random Parts.\n",
Deletes);
TraceMsg (0,   Msg);
#ifdef __DISPLAY_TIME__
NullTime = clock();
#endif
if (Deletes >= NumVlists)
Deletes  = NumVlists / 2;
i = 0;
while (Normal(*Status)
&&     ++i   <= Deletes)
{
FromPart          = Random(NumVlists);
FromPart          = Vlists[FromPart];
if (Part_GetToken         (&LibTkn,             FromPart,
McStat,             &PartTkn))
if (ClassBug
||  PartTkn.Handle    == 0
||  i % QueBug        == 0)
if (sprintf (Msg, " Delete %6u. Part# %8u Handle= %8u.\n",
i, FromPart,  PartTkn.Handle))
TraceMsg (0, Msg);
if (Normal(*Status))
if (Env_IsValidToken      (&PartTkn,            McStat))
if (BMT_DeletePartDrawObj (&PartTkn,            McStat))
Part_Delete           (&PartTkn,            McStat);
ClassBug   = TempClassBug;
}
FirstTime  = False;
#ifdef __DISPLAY_TIME__
Elapsed    = clock() - NullTime;
Seconds    = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,
"\n Delete Time = %4.2f sec; for %6u parts;\n", Seconds, i);
TraceMsg(MSGFILE,Msg);
#else
#endif
sprintf  (Msg, "\n Delete for %6u parts;\n", i);
TraceMsg (0, Msg);
TRACK(TrackBak,"BMT_DeleteParts\n");
return (STAT);
}
boolean BMT_DeleteAllObjects
(ft F,lt Z,zz *Status)
{
bytessize        BlkSize1       = NumVlists * sizeof (int);
int             *FreeParts      = NullPtr;
tokentype        PartTkn        = NullToken;
numtype          PartId         = 0;
tokentype        ToTkn          = NullToken;
int              i              = 0;
#ifdef __DISPLAY_TIME__
time_t           NullTime       = 0;
time_t           Elapsed        = 0;
float            Seconds        = 0;
#endif
boolean          TempClassBug   = ClassBug;
static boolean   FirstTime      = True;
boolean          TempDeleteDraws= DeleteDrawObjects;
if (DeletePartObjects == False)
return (STAT);
DeleteDrawObjects = True;
Parts          = 0;
DrawObjs       = 0;
NamedObjs      = 0;
Points         = 0;
Persons        = 0;
ToTkn.DbId     = LibTkn.DbId;
PartTkn.DbId   = LibTkn.DbId;
sprintf (Msg, "\n DELETE All objects; Max Parts=%4u\n",
MaxParts);
TraceMsg (0,   Msg);
TraceMsg (0,
"    <Part>, <*DrawObj>, <*Point>, <Person>, <Address> && <TestObj>;\n");
#ifdef __DISPLAY_TIME__
NullTime = clock();
#endif
if (FirstTime)
{
ClassBug  = False;
}
if (Core0_MoreCore     (BlkSize1,    McStat,   (addrtype *)&FreeParts))
for (i       = -1;  ++i < NumVlists; )
{
FreeParts[i]       = Vlists[i];
}
i            = NumVlists;
while (Normal(*Status)
&&   --i    >= 0)
{
PartId                  = FreeParts[i];
if (ClassBug || i % QueBug == 0)
if (sprintf (Msg, "  Delete %6d. PartId =%8u.\n",
i, PartId))
TraceMsg (0,   Msg);
if (Part_GetToken        (&LibTkn,               PartId,
McStat,               &PartTkn))
if (Env_IsValidToken     (&PartTkn,              McStat))
{
if (ClassBug || i % QueBug == 0)
if (sprintf (Msg, "  Delete %6d. object[%4u:%8u]\n",
i, PartTkn.DbId, PartTkn.Handle))
TraceMsg (0,   Msg);
if (ClassBug)
Object_Dump        (&PartTkn);
if (BMT_DeletePartDrawObj      (&PartTkn,       McStat))
if (Normal(*Status))
Part_Delete                (&PartTkn,       McStat);
Parts++;
}
ClassBug   = TempClassBug;
FirstTime  = False;
}
i            = MaxParts + 1;
while (Normal(*Status)
&&   --i    >= 0)
{
PartId           = i;
if (ClassBug || i % QueBug == 0)
if (sprintf (Msg, "  Delete %6d. Entry[PartId :=%8u].\n",
i, PartId))
TraceMsg (0,   Msg);
Grp_DeleteEntry   (&PartTkn,  VpartsDir,  PartId,        McStat);
}
if (Normal(*Status))
Grp_PutEntry      (&LibTkn,   VpartsDir,  0, (addrtype )&NullToken,
McStat);
MaxParts     = 0;
CurrentId    = 0;
StartCommit  = 0;
NumVlists    = 0;
if (Normal(*Status))
if (Core0_FreeCoreSpace
((addrtype *)&FreeParts,     BlkSize1,  McStat))
VchunkPutStackPtr (&VlistTkn,                  0,
McStat,        (addrtype *)&Vlists);
sprintf (Msg,  " <%6u> Part            objects  Deleted.\n", Parts);
TraceMsg (0, Msg);
sprintf (Msg,  " <%6u> DrawObj         objects  Deleted.\n", DrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  "                 <%6u> are Named.\n", NamedObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " <%6u> Point           objects  Deleted.\n", Points);
TraceMsg (0, Msg);
#ifdef __DISPLAY_TIME__
Elapsed    = clock() - NullTime;
Seconds    = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,
"\n DELETE Objects Time = %4.2f sec;\n",
Seconds);
TraceMsg (MSGFILE, Msg);
#else
#endif
sprintf  (Msg, "\n DELETE Objects ...\n");
TraceMsg (0, Msg);
if (Normal(*Status))
BMT_DeleteTestObjs   (McStat);
ClassBug   = TempClassBug;
DeleteDrawObjects= TempDeleteDraws;
TRACK(TrackBak,"BMT_DeleteAllObjects\n");
return (STAT);
}
boolean BMT_DeleteTestObjs
(ft F,lt Z,zz *Status)
{
#ifdef __DISPLAY_TIME__
time_t           NullTime       = 0;
time_t           Elapsed        = 0;
float            Seconds        = 0;
#endif
int              j              = 0;
tokentype        CurrentTkn     = NullToken;
tokentype        ItorTkn        = NullToken;
static boolean   FirstTime      = True;
boolean          TempClassBug   = ClassBug;
TraceMsg (0, "\n DELETE All TestObj objects;\n");
#ifndef __BMT01__
FirstTime = False;
#endif
#ifdef __DISPLAY_TIME__
NullTime = clock();
#endif
if (Normal(*Status))
{
TraceMsg (0, "\n Delete TestObj_Class        in <Primal> DB.\n");
*Status  = Iterate_Begin;
j = 0;
do
{
if (Primal_IterateOnClassObjects (&PrimalTkn,  TestObj_Class,
McStat,     &ItorTkn,  &CurrentTkn))
{
if (FirstTime  || CurrentTkn.Handle == 0)
{
FirstTime = False;
}
if (ClassBug)
Object_Dump  (&CurrentTkn);
Object_Delete                 (&CurrentTkn, McStat);
}
if (*Status  != Iterate_EndOf)
if (j == 0 || j % QueBug == 0  || !Normal(*Status))
{
sprintf (Msg,
" ItNum %6u. Token[%3u:%8u]. TestObj        Deleted.\n",
j, CurrentTkn.DbId, CurrentTkn.Handle);
TraceMsg (0, Msg);
}
j++;
ClassBug = TempClassBug;
} while (Normal(*Status));
if (*Status  == Iterate_EndOf)
*Status   = Env_Normal;
sprintf (Msg,  " <%6u> TestObj         objects  Deleted.\n", j-1);
TraceMsg (0, Msg);
}
if (Normal(*Status))
{
TraceMsg (0, "\n Commit CartesianPoint_Class in <Primal> DB.\n");
*Status  = Iterate_Begin;
j = 0;
do
{
if (Primal_IterateOnClassObjects (&PrimalTkn,  CartesianPoint_Class,
McStat,     &ItorTkn,  &CurrentTkn))
Object_Delete                 (&CurrentTkn, McStat);
if (*Status  != Iterate_EndOf)
if (j == 0 || j % QueBug == 0)
{
sprintf (Msg,
" ItNum %6u. Token[%3u:%8u]. CartesianPoint Deleted.\n",
j, CurrentTkn.DbId, CurrentTkn.Handle);
TraceMsg (0, Msg);
}
j++;
} while (Normal(*Status));
if (*Status  == Iterate_EndOf)
*Status   = Env_Normal;
sprintf (Msg,  " <%6u> CartesianPoint  objects  Deleted.\n", j-1);
TraceMsg (0, Msg);
}
#ifdef __DISPLAY_TIME__
Elapsed  = clock() - NullTime;
Seconds  = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg,
"\n DELETE TestObj and Point objects... Time = %4.2f sec\n",
Seconds);
TraceMsg (MSGFILE,   Msg);
#else
#endif
sprintf  (Msg, "\n DELETE TestObj and Point objects... \n");
TraceMsg (0,   Msg);
TRACK(TrackBak,"BMT_DeleteTestObjs\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\bmtlib.c*/

#define BMTLIB
typedef Part2  Part;

boolean PartLib_Init     (ft F,lt Z,zz *Status)
{
if (PartLib_Class == 0)
{
if (Env_GetClassId      ("PartLib",            McStat,  &PartLib_Class))
if (Env_GetAttrId       ("PartsListHead",      McStat,  &PartsListHead_Attr))
if (Env_GetAttrId       ("VpartsDir",          McStat,  &VpartsDir_Attr))
if (Env_GetAttrId       ("VlinksDir",          McStat,  &VlinksDir_Attr))
if (Env_GetAttrId       ("OwnerTosFroms",      McStat,  &OwnerTosFroms_Attr))
Env_GetMatrixId     ("TosFroms",           McStat,  &TosFroms_Mtrx);
if (Normal(*Status))
if (Env_InitClassMap    (PartLib_Class,        sizeof(PartLib),
C_Apl,                McStat))
if (Normal(*Status))
Env_InvokeMap       (C_Apl,                McStat);
if (Normal(*Status))
if (DrawPartPair_InitClass                    (McStat))
Part_InitClass                            (McStat);
}
TRACK(TrackBak,"PartLib_Init\n");
return (STAT);
}
boolean PartLib_Create   (char         *DbName,    char         *DbFileName,
dbaccesstype  DbAccess,  boolean       UseVparts,
numtype       HndlRgns,  numtype       RgnHndls,
numtype       VhndlRgns, numtype       RgnVhndls,
numtype       XmemRgns,  numtype       RgnXmems,
ft F,lt Z,zz *Status,
tokentype    *PrimalTkn, PartLib     **PrimalObj)
{
addrtype      IntVarray    = NullPtr;
numtype       GrpNum       = 0;
grpheader    *GrpHdr       = NullPtr;
sizetype      EntrySize    = sizeof (parttkntype);
numtype       AllocRgns    = (RgnHndls / 125) + 27;
numtype       RgnEntrys    = 125;
numtype       AllocXs      = 1000;
numtype       BaseIndex    = 2;
accesstype    AccessType   = Read_Write;
boolean       DiskCache    = False;
numtype       CacheLimit   = AllocRgns;
numtype       CacheLoad    = AllocRgns;
numtype       NumBuffRgns  = AllocRgns;
numtype       BaseRegion   = 0;
parttkntype   PartToken;
indextype     Index        = 0;
boolean      TempClassBug  = ClassBug;
VlinksDir             = 0;
if (ClassBug)
if (sprintf(Msg, "  PartLib_Create:: Db= '%32s'; AllocRgns=%6u\n",
DbName,  AllocRgns))
TraceMsg (0, Msg);
Primal_CreateDb     ("PartSchema", DbName,     DbFileName,  DbAccess,
HndlRgns,     RgnHndls,   VhndlRgns,   RgnVhndls,
XmemRgns,     RgnXmems,   McStat,      PrimalTkn);
OaDumpObject( 0, PrimalTkn, McStat ) ;
if (Normal(*Status))
{
if (Object_GetImage(PrimalTkn,    McStat,    (addrtype *)PrimalObj))
if (Grp_NewPacket  (PrimalTkn, EntrySize,   AllocRgns,   RgnEntrys,
AllocXs,   BaseIndex,   AccessType,  DiskCache,
CacheLimit,CacheLoad,   NumBuffRgns,
McStat,   &GrpNum,     &GrpHdr,     &BaseRegion))
if (Grp_NewEntry   (PrimalTkn, GrpNum,
McStat,    &Index,       (addrtype )&PartToken))
{
GrpHdr->EnvObjType    = EnvType_AttrNum;
VlinksDir             = 0;
}
#ifdef     __INCLUDE_MTRX__
if (Normal(*Status))
{
MultiMate              = False;
AllocMates             = 30000;
AllocPoints            = 0;
RgnEntrys              = 1000;
AllocRgns              = 10;
AllocXs                = 1000;
BaseIndex              = 0;
AccessType             = Read_Write;
DiskCache              = False;
CacheLimit             = 10;
CacheLoad              = 5;
NumBuffRgns            = 10;
MaxBuckets             = 2000;
Divisor                = 10;
KeyType                = aInteger;
KeySize                = sizeof (partidtype);
Matrix_Create      (TosFroms_Mtrx,               PrimalTkn,
AllocKeys,     MaxBuckets,   Divisor,
AllocKeys,     MaxBuckets,   Divisor,
AllocMates,    AllocPoints,
AllocRgns,     RgnEntrys,    AllocXs,
DiskCache,     CacheLimit,   CacheLoad,
NumBuffRgns,   McStat,      &MtrxTkn);
}
#endif
if (Normal(*Status))
if (UseVparts)
{
if (Attr_ArrayCreate (PrimalTkn,                  PartsListHead_Attr,
AllocParts,                 sizeof(int),
McStat,                    &IntVarray))
{
VlistTkn.DbId     = PrimalTkn->DbId;
VlistTkn          = (*PrimalObj)->PartsListHead.VchunkTkn;
NumVlists         = 0;
VchunkPutStackPtr (&VlistTkn,                  0,
McStat,        (addrtype *)&Vlists);
}
}
if (Normal(*Status))
if (UseVparts)
{
(*PrimalObj)->VpartsDir      = GrpNum;
VpartsDir                  = GrpNum;
}
if (sprintf(Msg, "   PartLibCreate:: Db[%3u]; VpartsDir=%4u\n",
PrimalTkn->DbId,  VpartsDir))
TraceMsg (0, Msg);
if (Normal(*Status))
if (Object_CommitImage  (PrimalTkn,    False,                 McStat))
{
Print_Msg           = True;
WriteHdr            = False;
}
} else if (*Status == Csh_DbAlreadyExists) {
*Status = Env_Normal;
if (Object_GetImage     (PrimalTkn,    McStat,    (addrtype *)PrimalObj))
if (UseVparts)
if ((*PrimalObj)->VpartsDir == 0)
{
if (Grp_NewPacket    (PrimalTkn, EntrySize,   AllocRgns,   RgnEntrys,
AllocXs,   BaseIndex,   AccessType,  DiskCache,
CacheLimit,CacheLoad,   NumBuffRgns,
McStat,   &GrpNum,     &GrpHdr,     &BaseRegion))
if (Grp_NewEntry     (PrimalTkn, GrpNum,
McStat,   &Index,        (addrtype )&PartToken))
{
GrpHdr->EnvObjType         = EnvType_AttrNum;
(*PrimalObj)->VpartsDir    = GrpNum;
VpartsDir                  = GrpNum;
Object_CommitImage(PrimalTkn,              False,       McStat);
}
}
if (Normal(*Status))
if ((*PrimalObj)->VpartsDir)
if (Grp_GetPacket       (PrimalTkn,    (*PrimalObj)->VpartsDir,
McStat,                    &GrpHdr))
VpartsDir           = (*PrimalObj)->VpartsDir;
if (Normal(*Status))
{
VlistTkn            = (*PrimalObj)->PartsListHead.VchunkTkn;
if (VlistTkn.Handle)
if (Vchunk_GetStackPtr(&VlistTkn,    McStat,               &NumVlists))
Vchunk_GetAddress (&VlistTkn,    McStat,   (addrtype *)&Vlists);
}
}
if (Normal(*Status))
if (ClassBug || DeBug >= 0)
Object_Dump          (PrimalTkn);
ClassBug = TempClassBug;
TRACK(TrackBak,"PartLib_Create\n");
return (STAT);
}
boolean PartLib_ActivateDb
(tokentype    *PrimalTkn, char         *DbFileName,
ft F,lt Z,zz *Status,    PartLib     **PrimalObj)
{
grpheader    *GrpHdr       = NullPtr;
dbaccesstype  AccessType   = Read_Write;
if (ClassBug)
if (sprintf(Msg, "  PartLibActivate:: [%3u:%8u]  DbFile= '%32s'\n",
PrimalTkn->DbId, PrimalTkn->Handle, DbFileName))
TraceMsg (0, Msg);
if (Primal_ActivateDbByToken
(PrimalTkn,    DbFileName,  AccessType,  McStat))
if (ClassBug || DeBug >= 0)
Object_Dump          (PrimalTkn);
if (Normal(*Status))
if (Object_GetImage     (PrimalTkn,    McStat,    (addrtype *)PrimalObj))
if (ClassBug || DeBug >= 0)
Object_Dump          (PrimalTkn);
if (Normal(*Status))
if ((*PrimalObj)->VpartsDir)
if (Grp_GetPacket       (PrimalTkn,    (*PrimalObj)->VpartsDir,
McStat,      &GrpHdr))
{
VpartsDir          = (*PrimalObj)->VpartsDir;
VlinksDir          = 0;
VlistTkn           = (*PrimalObj)->PartsListHead.VchunkTkn;
if (VlistTkn.Handle)
if (Vchunk_GetStackPtr(&VlistTkn,    McStat,               &NumVlists))
Vchunk_GetAddress (&VlistTkn,    McStat,   (addrtype *)&Vlists);
}
TRACK(TrackBak,"PartLib_ActivateDb\n");
return (STAT);
}
void PartLib_Topology       (void)
{
longaddr    StartAddr = 0;
static   PartLib     That;
static   PartLib    *This      = &That;
TraceMsg (0, "\n\n  <PartLib2> TOPOLOGY MAP:: \n");
StartAddr             = (longaddr )This;
sprintf (Msg,  "  sizeof PartLib            : =%3u\n",   sizeof(PartLib));
TraceMsg (0, Msg);
sprintf (Msg,  "  This                      : @%8x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  "  This->That                : +%3ld\n",
(longaddr )&This->That                 - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Token               : +%3ld\n",
(longaddr )&This->Token                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->DbNum               : +%3ld\n",
(longaddr )&This->DbNum                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->EnvType             : +%3ld\n",
(longaddr )&This->EnvType             - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->DescNum             : +%3ld\n",
(longaddr )&This->DescNum              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->PrimalSlotAttr      : +%3ld\n",
(longaddr )&This->PrimalSlotAttr       - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->PartsListHead       : +%3ld\n",
(longaddr )&This->PartsListHead        - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->VpartsDir           : +%3ld\n",
(longaddr )&This->VpartsDir            - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->VlinksDir           : +%3ld\n",
(longaddr )&This->VlinksDir            - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->OwnerTosFroms       : +%3ld\n\n",
(longaddr )&This->OwnerTosFroms        - StartAddr);
TraceMsg (0, Msg);
return;
}
/* 当前文件是./CINT2000\255.vortex\src\bmtobj.c*/

#define  __DISPLAY_TIME__
#define BMTOBJ
#ifdef __DISPLAY_TIME__
#endif
typedef Part2  Part;
boolean BMT_Iter1 (tokentype    *Token,   numtype       ItNum,
ft F,lt Z,zz *Status);
boolean BMT_Iter2 (tokentype    *Token,   numtype       ItNum,
ft F,lt Z,zz *Status);



boolean DrawPartPair_InitClass (ft F,lt Z,zz *Status)
{
if (ClassBug)
TraceMsg (0, " DrawPartPair::InitClass...\n");
if (!DrawPart_Tupl)
if (Env_GetAttrId     ("DrawObjSlotAttr",
McStat,               &DrawObj_Slot))
if (Env_GetAttrId     ("PartObjSlotAttr",
McStat,               &PartObj_Slot))
Env_GetTupleId    ("DrawPartPair",
McStat,               &DrawPart_Tupl);
TRACK(TrackBak,"DrawPartPair_InitClass\n");
return (STAT);
}
boolean Part_InitClass   (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
Part2           PartObj;
if (Part_Class == 0)
{
if (Env_GetClassId      ("Connection",         McStat,  &Connection_Class))
if (Env_GetAttrId       ("to",                 McStat,  &to_Attr))
if (Env_GetAttrId       ("type",               McStat,  &type_Attr))
if (Env_GetAttrId       ("length",             McStat,  &length_Attr))
if (Env_InitClassMap    (Connection_Class,     sizeof(Connection),
C_Apl,                McStat))
Env_InvokeMap       (C_Apl,                McStat);
if (Normal(*Status))
if (Env_GetClassId      ("Part2",              McStat,  &Part_Class))
if (Env_GetAttrId       ("id",                 McStat,  &id_Attr0))
if (Env_GetAttrId       ("xx",                 McStat,  &xx_Attr))
if (Env_GetAttrId       ("yy",                 McStat,  &yy_Attr))
if (Env_GetAttrId       ("build",              McStat,  &build_Attr))
if (Env_GetAttrId       ("c1",                 McStat,  &c1_Attr))
if (Env_GetAttrId       ("c2",                 McStat,  &c2_Attr))
if (Env_GetAttrId       ("c3",                 McStat,  &c3_Attr))
if (Env_GetAttrId       ("FromParts",          McStat,  &FromList_Attr))
if (Env_GetAttrId       ("RowHeadTosFroms",    McStat,
&RowHeadTosFroms_Attr))
if (Env_GetAttrId       ("ColHeadTosFroms",    McStat,
&ColHeadTosFroms_Attr))
Env_GetAttrId       ("DrawObjSlotAttr",    McStat,
&DrawObjSlotAttr_Attr);
if (Normal(*Status))
PersonParts_InitClass                     (McStat);
StartAddr   = (longaddr     )&PartObj;
if (Normal(*Status))
if (Env_InitClassMap      (Part_Class,        sizeof (Part2),
C_Apl,             McStat))
{
Offset    = (size_t)((longaddr )&PartObj.That    -  StartAddr);
if (Env_AppendToMap    (That_AttrNum,          Offset,     McStat))
Offset = (size_t)((longaddr )&PartObj.Token   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Token_Attr,            Offset,     McStat))
Offset = (size_t)((longaddr )&PartObj.id  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (id_Attr0,              Offset,     McStat))
Offset = (size_t)((longaddr )&PartObj.type      -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (type_Attr,             Offset,     McStat))
Offset = (size_t)((longaddr )&PartObj.xx        -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (xx_Attr,               Offset,     McStat))
Offset = (size_t)((longaddr )&PartObj.yy        -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (yy_Attr,               Offset,     McStat))
Offset = (size_t)((longaddr )&PartObj.build     -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (build_Attr,            Offset,     McStat))
Offset = (size_t)((longaddr )&PartObj.link[0]   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (c1_Attr,               Offset,     McStat))
Offset = (size_t)((longaddr )&PartObj.link[1]   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (c2_Attr,               Offset,     McStat))
Offset = (size_t)((longaddr )&PartObj.link[2]   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (c3_Attr,               Offset,     McStat))
Offset = (size_t)((longaddr )&PartObj.FromList  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (FromList_Attr,         Offset,     McStat))
Offset = (size_t)((longaddr  )&PartObj.RowHeadTosFroms  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (RowHeadTosFroms_Attr,  Offset,     McStat))
Offset = (size_t)((longaddr  )&PartObj.ColHeadTosFroms  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (ColHeadTosFroms_Attr,  Offset,     McStat))
Offset = (size_t)((longaddr  )&PartObj.DrawObjSlotAttr  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (DrawObjSlotAttr_Attr,  Offset,     McStat))
Offset = (size_t)((longaddr  )&PartObj.MemberPersonParts -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (MemberPersonParts_Attr, Offset,  McStat))
if (Normal(*Status))
Env_InvokeMap      (C_Apl,                             McStat);
}
}
TRACK(TrackBak,"Part_Init\n");
return (STAT);
}
boolean      Part_Create  (tokentype    *AnchorTkn,
partidtype    Id,     longtype      X,
longtype      Y,      longtype      TypeNum,
ft F,lt Z,zz *Status, tokentype    *PartTkn)
{
Part          *PartObj      = NullPtr;
tokentype      VchunkTkn    = NullToken;
parttkntype    PartToken;
#ifdef __DISPLAY_TIME__
time_t        *TimePtr      = NullPtr;
#endif
if (Object_NewImage (AnchorTkn,    Part_Class,
McStat,       PartTkn,   (addrtype *)&PartObj))
if (Vchunk_Create   (AnchorTkn,    sizeof (partidtype),    FromCount,
ExtendQty,    McStat,                &VchunkTkn))
{
PartToken.Handle       = PartTkn->Handle;
PartToken.FromList     = VchunkTkn.Handle;
Grp_PutEntry     (PartTkn,    VpartsDir,     Id,
(addrtype )&PartToken,     McStat);
}
if (Normal(*Status))
{
PartObj->id       = Id;
strcpy  (PartObj->type, TypeName[TypeNum]);
PartObj->xx       = X;
PartObj->yy       = Y;
#ifdef __DISPLAY_TIME__
#ifndef   __BMT01__
PartObj->build    = (datetype )time(TimePtr);
#else
PartObj->build    = (datetype )PartTkn->Handle;
#endif
#else
PartObj->build    = (datetype )PartTkn->Handle;
#endif
PartObj->FromList = VchunkTkn;
Vlists[NumVlists++]  = Id;
VchunkPutStackPtr (&VlistTkn,                  NumVlists,
McStat,        (addrtype *)&Vlists);
}
if (!Normal(*Status)
||  ClassBug)
if (sprintf (Msg, " Create  Part[%6u]. Token[%3u:%8u].\n",
Id, PartTkn->DbId, PartTkn->Handle))
TraceMsg (0, Msg);
if (ClassBug)
TraceMsg (0, "     Commit Image.\n");
if (!Normal(*Status))
{
sprintf (Msg, " *** Error... PartCreate:: Part %6u. Token[%3u:%8u].\n",
Id, PartTkn->DbId, PartTkn->Handle);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"Part_Create\n");
return (STAT);
}
boolean      Part_GetToken
(tokentype    *Anchor,  partidtype    PartId,
ft F,lt Z,zz *Status,  tokentype    *Token)
{
parttkntype  PartToken;
Token->DbId = Anchor->DbId;
if (Grp_GetEntry  (Anchor,     VpartsDir,  PartId,
McStat,    (addrtype  )&PartToken))
Token->Handle = PartToken.Handle;
TRACK(TrackBak,"Part_GetToken\n");
return (STAT);
}
boolean      Part_Connect (tokentype    *PartTkn, partidtype    FromPart,
ft F,lt Z,zz *Status)
{
tokentype      ToTkn        = NullToken;
Part          *PartObj      = NullPtr;
partidtype     ToPart       = 0;
unsigned int   j            = 0;
tokentype      VchunkTkn    = NullToken;
indextype      StackPtr     = 0;
parttkntype    PartToken;
#ifdef     __INCLUDE_MTRX__
matrixitor     MtrxItor;
tokentype      PointTkn     = NullToken;
#endif
partidtype     ToParts[3];
boolean        BadMatch     = True;
ToParts[0]      = 0;
ToParts[1]      = 0;
ToParts[2]      = 0;
ToTkn.DbId      = PartTkn->DbId;
VchunkTkn.DbId  = PartTkn->DbId;
Object_GetImage     (PartTkn,     McStat,   (addrtype *)&PartObj);
j = 0;
while (Normal(*Status)
&&     j    < 3)
{
BadMatch  = True;
while (BadMatch)
{
#ifdef __EDB_BENCHMARK__
if (Random(16) > 0)
{
ToPart  = FromPart + Random(OneCent) - HalfCent;
if (ToPart < HalfCent)
ToPart     += HalfCent;
else if (ToPart > (MaxParts - HalfCent))
ToPart     -= HalfCent;
if (ToPart <= 0
|| ToPart > MaxParts)
ToPart      = Random(MaxParts) + 1;
} else {
ToPart         = Random(MaxParts) + 1;
}
#else
ToPart            = Random(NumVlists);
ToPart            = Vlists[ToPart];
#endif
if (ToPart   != ToParts[0]
&&  ToPart   != ToParts[1]
&&  ToPart   != ToParts[2])
BadMatch   = False;
}
ToParts[j]              = ToPart;
PartObj->link[j].to     = ToPart;
strcpy (PartObj->link[j].type, ConnectType);
PartObj->link[j].length = ToPart % 10 + 1;
if (Grp_GetEntry  (PartTkn,  VpartsDir,  ToPart,
McStat,  (addrtype *)&PartToken))
{
ToTkn.Handle     =  PartToken.Handle;
VchunkTkn.Handle =  PartToken.FromList;
}
if (ClassBug || FromPart <= 1)
if (sprintf (Msg,
"   Connect  Part %6u. Token[%3u:%8u] FromList=%6u.\n",
ToPart, ToTkn.DbId, ToTkn.Handle, PartToken.FromList))
TraceMsg (0, Msg);
if (Normal(*Status))
{
if (VchunkTkn.Handle != 0)
{
VchunkPushUnit   (&VchunkTkn,  (addrtype )&FromPart,
McStat,                 &StackPtr);
} else {
sprintf (Msg, "\n Warning... ToPart= %6u; Has no From List.\n",
ToPart);
TraceMsg (0, Msg);
Object_Dump (&ToTkn);
}
}
#ifdef     __INCLUDE_MTRX__
if (Normal(*Status))
if (Object_GetImage     (&ToTkn,     McStat,   (addrtype *)&ToObj))
{
if (FirstTime)
{
FirstTime  = False;
}
Matrix_ExpressMate
(TosFroms_Mtrx,  &PartLib01->OwnerTosFroms,
&LibTkn,         PartTkn,   &ToTkn,
&PartObj->RowHeadTosFroms,  &ToObj->ColHeadTosFroms,
(addrtype )&PartObj->id,    (addrtype )&ToObj->id,
False,
McStat,         &MtrxItor, &PointTkn);
if (FirstTime)
{
FirstTime  = False;
MtrxBug    = False;
SetBug     = False;
ClassBug   = TmpClassBug;
}
if (*Status == Mtrx_AlreadyMated)
{
sprintf (Msg,
"   Part %6u. [%4u:%6u] X ToTkn[%3u:%8u] Already MATED!\n",
ToPart, PartTkn->DbId, PartTkn->Handle,
ToTkn.DbId,    ToTkn.Handle);
TraceMsg (0, Msg);
*Status  = Env_Normal;
}
}
#endif
j++;
}
if (ClassBug)
if (FromPart % 100 == 0)
Object_Dump (PartTkn);
TRACK(TrackBak,"Part_Connect\n");
return (STAT);
}
boolean      Part_Traverse
(tokentype    *PartTkn,  longtype  Level,
ft F,lt Z,zz *Status)
{
tokentype      ToTkn        = NullToken;
Part          *PartObj      = NullPtr;
partidtype     ToPart       = 0;
unsigned int   j            = 0;
parttkntype    PartToken;
static
handletype     SeedHandle   = 0;
static  numtype Traverses   = 0;
static  numtype CallCount    = 0;
if (Level == 0)
{
SeedHandle  = PartTkn->Handle;
DrawObjs       = 0;
Points         = 0;
}
if (Level < Traverse_Limit)
{
Traverses++;
if (Object_GetImage (PartTkn,      McStat, (addrtype *)&PartObj))
if (ClassBug || Traverses %  QueBug == 0)
if (sprintf (Msg, " Traverse Part [%3u:%8u] Level = %2u.\n",
PartTkn->DbId, PartTkn->Handle, Level))
TraceMsg (0, Msg);
if (Normal(*Status))
if (Traverses % 10 == 0)
{
if (CallCount++ % 2 == 0)
BMT_Validate  (PartTkn,                McStat);
else
BMT_DeletePartDrawObj
(PartTkn,      McStat);
} else
BMT_ExportPart    (PartObj->xx,  PartObj->yy,   PartObj->type,
McStat);
j = 0;
while (Normal(*Status)
&&     j    < 3)
{
PartCount++;
ToPart       = PartObj->link[j].to;
ToTkn.DbId   = PartTkn->DbId;
if (ClassBug)
if (sprintf (Msg, "   Part->link[%2u].to Level[%2u] Id = %u\n",
j+1, Level, ToPart))
TraceMsg (0, Msg);
if (ToPart)
if (Env_IsValidToken (PartTkn,              McStat))
{
if (Grp_GetEntry  (PartTkn,  VpartsDir,  ToPart,
McStat,  (addrtype *)&PartToken))
ToTkn.Handle =  PartToken.Handle;
if (Normal(*Status))
if (ToTkn.Handle  !=  SeedHandle)
Part_Traverse  (&ToTkn,       Level+1,          McStat);
else {
sprintf (Msg,
" SEED In Traverse Part [%3u:%8u] @ Level = %2u.\n",
PartTkn->DbId, PartTkn->Handle, Level);
TraceMsg (0, Msg);
return (STAT);
}
}
j++;
}
}
TRACK(TrackBak,"Part_Traverse\n");
return (STAT);
}
boolean      Part_Reverse (tokentype    *PartTkn,  longtype  Level,
ft F,lt Z,zz *Status)
{
tokentype      FromList;
tokentype      FromTkn;
Part          *PartObj      = NullPtr;
partidtype     FromPart     = 0;
unsigned int   j            = 0;
indextype      StackPtr     = 0;
parttkntype    PartToken;
static
handletype     SeedHandle   = 0;
static  numtype Reverses    = 0;
static  numtype CallCount    = 0;
if (Level == 0)
{
SeedHandle  = PartTkn->Handle;
DrawObjs       = 0;
Points         = 0;
}
if (Level < Traverse_Limit)
{
Reverses++;
if (ClassBug || Reverses %  QueBug == 0)
if (sprintf (Msg, " ReVerse Traverse Part [%3u:%8u] Level = %2u.\n",
PartTkn->DbId, PartTkn->Handle, Level))
TraceMsg (0, Msg);
if (Object_GetImage (PartTkn,      McStat, (addrtype *)&PartObj))
{
if (Reverses % 10 == 0)
{
if (CallCount++ % 2 == 0)
BMT_Validate   (PartTkn,      McStat);
else
BMT_DeletePartDrawObj
(PartTkn,      McStat);
} else
BMT_ExportPart    (PartObj->xx,  PartObj->yy,   PartObj->type,
McStat);
FromList.DbId     = PartTkn->DbId;
FromList.Handle   = PartObj->FromList.Handle;
if (Normal(*Status))
if (FromList.Handle == 0)
{
sprintf (Msg,
" ***No From.... for Reverse Traverse Part[%3u:%8u].\n",
PartTkn->DbId, PartTkn->Handle);
TraceMsg (0, Msg);
} else
VchunkGetStackPtr (&FromList,   McStat,      &StackPtr);
} else {
sprintf (Msg, " ReVerse Traverse Part [%3u:%8u] Level = %2u.\n",
PartTkn->DbId, PartTkn->Handle, Level);
TraceMsg (0, Msg);
}
j              = 0;
FromTkn.DbId   = PartTkn->DbId;
while (Normal(*Status)
&&     j    < StackPtr)
{
PartCount++;
if (Vchunk_GetUnit  (&FromList,    j,
McStat,       (addrtype )&FromPart))
if (FromPart)
{
if (Grp_GetEntry  (PartTkn,  VpartsDir,  FromPart,
McStat,  (addrtype *)&PartToken))
FromTkn.Handle =  PartToken.Handle;
if (ClassBug || FromTkn.Handle == 0)
if (sprintf (Msg, "   FromList[%2u] Level[%2u] Part[%3u:%8u]\n",
j, Level, FromTkn.DbId, FromTkn.Handle))
TraceMsg (0, Msg);
if (Normal(*Status))
if (FromTkn.Handle  !=  SeedHandle)
{
if (!Part_Reverse   (&FromTkn, Level+1,    McStat))
{
sprintf (Msg,
"\n ERROR FromList[%2u] of FromPart[%3u]= NULL handle\n",
j, FromPart);
TraceMsg (0, Msg);
Object_Dump     (&FromTkn);
}
} else {
sprintf (Msg, " SEED In Reverse  Part [%3u:%8u] @ Level = %2u.\n",
FromTkn.DbId, FromTkn.Handle, Level);
TraceMsg (0, Msg);
return (STAT);
}
}
j++;
}
}
TRACK(TrackBak,"Part_Reverse\n");
return (STAT);
}
boolean      Part_ExportTo
(tokentype    *PartTkn,
tokentype    *ApiTkn,    void         *FOId,
ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"Part_ExportTo\n");
return (STAT);
}
boolean      Part_ImportFrom
(tokentype    *ApiTkn,    void         *FOId,
tokentype    *PartTkn,   ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"Part_ImportFrom\n");
return (STAT);
}
boolean      Part_DisConnect
(tokentype    *PartTkn, ft F,lt Z,zz *Status)
{
tokentype      ToTkn        = NullToken;
Part          *PartObj      = NullPtr;
partidtype     ToPart       = 0;
int            i            = 0;
int            j            = 0;
tokentype      VchunkTkn    = NullToken;
indextype      StackPtr     = 0;
numtype       *Vchunk       = NullPtr;
parttkntype    PartToken;
boolean        NotFound     = True;
statustype     DumpStatus   = Env_Normal;
static boolean FirstTime    = True;
ToTkn.DbId      = PartTkn->DbId;
VchunkTkn.DbId  = PartTkn->DbId;
if (Object_GetImage     (PartTkn,     McStat,   (addrtype *)&PartObj))
if (ClassBug || FirstTime)
if (sprintf (Msg,
"   PartDisconnect:: Token[%3u:%8u] id:= %6u for each link.\n",
PartTkn->DbId, PartTkn->Handle, PartObj->id))
TraceMsg (0, Msg);
i = 0;
while (Normal(*Status)
&&     i    < 3)
{
PartToken.FromList  = 0;
ToPart   = PartObj->link[i].to;
if (ToPart)
if (Grp_GetEntry  (PartTkn,  VpartsDir,  ToPart,
McStat,  (addrtype *)&PartToken))
{
ToTkn.Handle     =  PartToken.Handle;
VchunkTkn.Handle =  PartToken.FromList;
NotFound         = True;
}
if (ClassBug || FirstTime)
if (sprintf (Msg,
"   DisConnect  link    [%4u]:= %6u; PartToken[%6u:%6u].\n",
i, ToPart, PartToken.Handle, PartToken.FromList))
TraceMsg (0, Msg);
if (ToPart)
if (Normal(*Status))
if (Env_IsValidToken    (&ToTkn,      McStat))
if (VchunkTkn.Handle != 0)
if (Vchunk_GetAddress   (&VchunkTkn,  McStat,(addrtype *)&Vchunk))
if (Vchunk_GetStackPtr  (&VchunkTkn,  McStat,            &StackPtr))
for (j  = 0,          NotFound = True;
j  < StackPtr && NotFound; )
{
if (Vchunk[j] == PartObj->id)
NotFound    = False;
else
j++;
}
if (ToPart)
if (Normal(*Status))
if (NotFound       == False)
{
if (Vchunk_PutStackPtr  (&VchunkTkn,             --StackPtr,
McStat,      (addrtype *)&Vchunk))
while (j  < StackPtr +1)
{
Vchunk[j] = Vchunk[j+1];
j++;
}
} else {
sprintf (Msg,
"   DisConnect  PartObj->id :=%6u; NOT in FromList of ToPart[%4u].\n",
PartObj->id, ToPart);
TraceMsg (0, Msg);
Vchunk_Dump             (&VchunkTkn,               Dump_Status);
}
i++;
}
if (ClassBug)
Object_Dump (PartTkn);
FirstTime     = False;
TRACK(TrackBak,"Part_DisConnect\n");
return (STAT);
}
boolean      Part_Delete (tokentype    *PartTkn, ft F,lt Z,zz *Status)
{
tokentype      FromTkn      = NullToken;
Part          *PartObj      = NullPtr;
Part          *FromObj      = NullPtr;
partidtype     FromPart     = 0;
int            i            = 0;
int            j            = 0;
tokentype      VchunkTkn    = NullToken;
indextype      StackPtr     = 0;
numtype       *Vchunk       = NullPtr;
parttkntype    PartToken;
boolean        NotFound     = True;
static boolean FirstTime    = True;
boolean        TempClassBug = ClassBug;
boolean        TempGrpBug   = GrpBug;
boolean        TempSwapBug  = SwapBug;
handletype     WatchHandle  = 1734;
if (ClassBug || FirstTime)
if (sprintf (Msg, "\n   PartDelete    :: Token[%3u:%8u].\n",
PartTkn->DbId, PartTkn->Handle))
TraceMsg (0, Msg);
FromTkn.DbId    = PartTkn->DbId;
VchunkTkn.DbId  = PartTkn->DbId;
if (Part_DisConnect     (PartTkn,      McStat))
if (Object_GetImage     (PartTkn,      McStat,   (addrtype *)&PartObj))
VchunkTkn          = PartObj->FromList;
if (Normal(*Status))
if (VchunkTkn.Handle != 0)
if (Vchunk_GetAddress   (&VchunkTkn,   McStat,   (addrtype *)&Vchunk))
Vchunk_GetStackPtr  (&VchunkTkn,   McStat,               &StackPtr);
if (Normal(*Status))
if (ClassBug || FirstTime)
if (sprintf (Msg, "   DeleteFromList:: Vchunk[%2u:%8u]. (*%4u)\n",
VchunkTkn.DbId, VchunkTkn.Handle, StackPtr))
TraceMsg (0, Msg);
i = 0;
while (Normal(*Status)
&&     i    <  StackPtr)
{
FromPart   = Vchunk[i];
if (Grp_GetEntry  (PartTkn,  VpartsDir,  FromPart,
McStat,  (addrtype *)&PartToken))
FromTkn.Handle   =  PartToken.Handle;
if (ClassBug && FirstTime)
if (FromTkn.Handle == WatchHandle)
{
ClassBug = True;
GrpBug = True;
SwapBug = True;
}
if (ClassBug || FirstTime)
if (sprintf (Msg,
"   DisConnect  FromList[%4u]:=%6u;  Token[%6u:%6u].\n",
i, FromPart, PartToken.Handle, PartToken.FromList))
TraceMsg (0, Msg);
if (Normal(*Status))
if (Env_IsValidToken    (&FromTkn,     McStat))
if (Object_GetImage     (&FromTkn,     McStat,   (addrtype *)&FromObj))
{
for (j  = 0,          NotFound = True;
j  < 3        && NotFound;        j++)
{
if (FromObj->link[j].to == PartObj->id)
{
NotFound              = False;
FromObj->link[j].to   = 0;
}
}
if (NotFound)
if (sprintf (Msg,
"   DisConnect  Part %6u. Token[%3u:%8u] id=%6u NOT in Link[*].\n",
FromPart, FromTkn.DbId, FromTkn.Handle, PartObj->id))
TraceMsg (0, Msg);
}
i++;
}
i                      = PartObj->id -1;
NotFound               = True;
if (Normal(*Status))
if (Vchunk_GetAddress   (&VlistTkn,    McStat,   (addrtype *)&Vlists))
if (i                  < NumVlists
&&  Vlists[i]         == PartObj->id)
{
--NumVlists;
NotFound            = False;
if (i               < NumVlists)
Vlists[i]        = Vlists[NumVlists];
else
Vlists[i]        = 0;
if (ClassBug || FirstTime)
if (sprintf (Msg, "   Vlists[%4u] :=%6u;\n", i, Vlists[i]))
TraceMsg (0, Msg);
} else {
for (i  = -1,           NotFound   = True;
++i  < NumVlists  && NotFound; )
{
if (Vlists[i]    == PartObj->id)
{
--NumVlists;
NotFound       = False;
if (i             < NumVlists)
Vlists[i]   = Vlists[NumVlists];
else
Vlists[i]   = 0;
if (ClassBug || FirstTime)
if (sprintf (Msg, "   Vlists[%4u] :=%6u;\n", i, Vlists[i]))
TraceMsg (0, Msg);
}
}
}
if (Normal(*Status))
if (NotFound)
if (sprintf (Msg,
"   PartDelete:: Token[%3u:%8u] PartId=%6u NOT in Vlists array.\n",
PartTkn->DbId, PartTkn->Handle, PartObj->id))
TraceMsg (0, Msg);
if (Normal(*Status))
Vchunk_PutStackPtr (&VlistTkn,               NumVlists,
McStat,     (addrtype *)&Vlists);
PartToken.Handle   =  NullHandle;
PartToken.FromList =  NullHandle;
if (Normal(*Status))
if (Grp_PutEntry           (PartTkn,    VpartsDir,       PartObj->id,
(addrtype )&PartToken,       McStat))
Object_Delete          (PartTkn,                     McStat);
ClassBug      = TempClassBug;
GrpBug        = TempGrpBug;
SwapBug       = TempSwapBug;
FirstTime     = False;
TRACK(TrackBak,"Part_Delete\n");
return (STAT);
}
void Part_Topology       (void)
{
longaddr    StartAddr = 0;
static   Part2       That;
static   Part2      *This      = &That;
TraceMsg (0, "\n\n  <Part2> TOPOLOGY MAP:: \n");
StartAddr             = (longaddr )This;
sprintf (Msg,  "  sizeof Part2              : =%3u\n",   sizeof(Part2));
TraceMsg (0, Msg);
sprintf (Msg,  "  This                      : @%8x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  "  This->That                : +%3ld\n",
(longaddr )&This->That                 - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Token               : +%3ld\n",
(longaddr )&This->Token                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->id                  : +%3ld\n",
(longaddr )&This->id                   - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->type                : +%3ld\n",
(longaddr )&This->type                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->xx                  : +%3ld\n",
(longaddr )&This->xx                   - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->yy                  : +%3ld\n",
(longaddr )&This->yy                   - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->build               : +%3ld\n",
(longaddr )&This->build                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->link[0]             : +%3ld\n",
(longaddr )&This->link[0]              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->link[1]             : +%3ld\n",
(longaddr )&This->link[1]              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->link[2]             : +%3ld\n",
(longaddr )&This->link[2]              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->FromList            : +%3ld\n",
(longaddr )&This->FromList             - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->RowHeadTosFroms     : +%3ld\n",
(longaddr )&This->RowHeadTosFroms      - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->ColHeadTosFroms     : +%3ld\n",
(longaddr )&This->ColHeadTosFroms      - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->DrawObjSlotAttr     : +%3ld\n",
(longaddr )&This->DrawObjSlotAttr      - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->MemberPersonParts   : +%3ld\n",
(longaddr )&This->MemberPersonParts    - StartAddr);
TraceMsg (0, Msg);
return;
}
/* 当前文件是./CINT2000\255.vortex\src\core01.c*/

#define CORE
#ifdef FAR_MEM
#endif
#ifdef DEBUG_CORE0
static   numtype       Core0_Chunk                = 0;
#endif
#ifdef NULL_TRACE_STRS
#define TraceStr(StrNum)  TraceStr[0]
static const char   *TraceStr[2] = {"\0", "   ...CORE... message\n" };
#else
#define TraceStr(StrNum)  TraceStr[StrNum]
static const char   *TraceStr[90] =
{
"    Alloc from the VOID %8lu bytes;\n",
"  *** WARNING ... Partial Core Page = %lu\n",
"            Extend VOID %8lu bytes;  New Void =%8lu\n",
"    VOID Extended:: Void Range (* %-8lu) @ %8x :: %8x\n",
" CoreMoreCore... Non Aligned Address= %8x\n",
"                 Core1Size          = %8lu\n",
"    VOID FreeCore:: Void Range (* %-8lu) @ %8x :: %8x\n",
" Allocated %6u bytes @%x\n",
" Allocated %6u bytes @%x\n",
" De Allocate block[%2u] @ %x\n",
"  *** INFO *** Far Core Available = %lu\n",
"    CoreMoreCore ::  Size= %6lu; Alignment =%u\n",
"    CoreMoreCore ::  Request=%8lu > PageSize=%8lu\n",
"\n CORE REQUEST for SizeInBytes : %lu > CoreBlock1Left %lu\n",
"  Core required : %lu >  Current Core Size : %lu\n",
"      Page[%3u] FreeSpace =%8lu   @%x.\n",
"   FAR CORE AVAIL   : %lu\n",
"             BASE   : %x\n",
"           OFFSET   : %x\n",
"        CURR SIZE   : %lu; BLOCKS[%u]\n",
"          REQUEST   : %lu\n",
"     MEM    AVAIL   : %lu\n",
" CORE NO MORE  for Core1BlockElems= %lu EXTRA\n",
"  CoreBlock1 Address Aligned by bytes= %2u\n",
"     CORE    BASE   : @ %x\n",
"     CORE1   SIZE   : %lu\n",
"        Extend  Core Size   : %8lu; PageBLOCK[%u]\n",
"        For     Request     : %8lu;\n",
"                Core1 Size  : %8lu  @%8x\n\n",
"     MEM    AVAIL   : %lu\n",
"     New Region[%6u] * %4u @ %x\n",
" CoreMoreCore... Non Aligned Address= %8x\n",
"                 Core1Size          = %8lu\n",
"        Add  FreeCoreGap[%6u] size = %8lu; @%8x\n",
"        GapAddr[%6u] @%x, Size = %8lu; EndGapAddr @%x\n",
"          Append FreeSpace[%4u]      = %8lu;\n",
"         NewGapSize                   =%8lu; EndGapAddr   @%x\n",
"          Pend   FreeSpace[%4u]      = %8lu;\n",
"         NewGapSize                   =%8lu; StartGapAddr @%x\n",
"        FreeStack      Units          = %8lu\n",
"        Core ReGaped:: Count = %6u, SizeMoved= %6lu\n",
"        Core Spliced:: NewGapSize     = %8lu\n",
"        Reclaim FreeSpace [%6u]  Bytes =%8lu; @ %x Size= %6u\n",
"        ReGap   FreeBlk   [%6u] To @%8x For %6u bytes\n",
"        Append  FreeSpace[%6u]\n",
"        Reclaim CoreSpace (*%-6lu)  @%x\n",
"      NO Free Space for Bytes =%lu; StackPtr = %2u\n",
" CoreGetFreeSpace... Non Aligned Address= %8x\n",
"        Reclaim From Page[%6u] =   %8lu;  FreeSize =%8lu @%x\n",
" CoreGetPageSpace... Non Aligned Address= %8x\n",
"        Reclaim FreeSpace [%6u]  Bytes =%8lu; @ %x Size= %6u\n",
"        ReGap   FreeBlk   [%6u] To @%8x For %6u bytes\n",
"        Append  FreeSpace[%6u]\n",
"        Reclaim CoreSpace (> )  %lu\n",
"      NO Free Space for Bytes =%lu; StackPtr = %2u\n",
" CoreGetGapSpace... Non Aligned Address= %8x\n",
"     FreeStack Size= %6lu  Units; @ %x\n",
"       GapAddr[%5u] @%x,  Size = %8lu; EndGapAddr @%x\n",
"         Append FreeSpace[%4u] =%8lu;\n",
"         NewGapSize                   =%8lu; EndGapAddr @%x\n",
"         Pend   FreeSpace[%4u] =%8lu;\n",
"         NewGapSize                    =%8lu; StartGapAddr @%x\n",
"         Core(* %8u)  ReGaped:: Count   = %6u, ReGapSize= %6u\n",
"         FreeAddr's ReGaped:: StackPtr=%6u, New      = %6u\n",
"     FreeStack Size= %6lu  Units;\n",
"      FreeAddr's ReGaped:: StackPtr=%6u, New      = %6u\n",
"    CoreMoveBytes(%u) @%x to %x NewSize(%u)\n",
" Void      Allocated :: %8lu\n",
" Void   De Allocated :: %8lu\n",
" Void   Used         :: %8lu\n",
" Blks      Allocated :: %8lu\n",
" Blks   De Allocated :: %8lu\n\n",
" Regions  Allocated  :: %8u\n",
" Core   Used         :: %8lu\n",
" Core   Freeed       :: %8lu\n",
" Core   Reclaimed    :: %8lu\n\n",
" CoreBlks Requested  :: %8lu\n",
" CoreBlks Freeed     :: %8lu\n\n",
" CoreBlks Reclaimed  :: %8lu\n",
"     By   Exact Size :: %8lu\n",
"     By   Gaps       :: %8lu\n",
"     By   Page Space :: %8lu\n\n",
"       %6u Bytes moved from %x to %x ",
" %4u\n",
" %4u\n",
"<[%4lu:%4lu]> || <%6xX : %6xX>\n",
"<%4ld>  || <%6xX>\n",
"       %u Bytes compared testvalue= %u \n",
" Error... Duplicate Address Free'ed  GapAddr @%x, Size = %8lu;\n",
"       Current GapSpace[%4u]  StartAddr @%x, EndAddr @%x; Size = %8lu;\n"
};
#endif
#define DumpChunkChunk     Mem_DumpChunkChunk
#define MemDumpChunk       Mem_DumpChunk
#define MemPutStackPtr     Mem_PutStackPtr
#define MemGetStackPtr     Mem_GetStackPtr
#define MemGetChunkAddr    Mem_GetChunkAddr
#define MemPushAddr        Mem_PushAddr
#define MemPushWord        Mem_PushWord
#define MemGetSomeBytes    Mem_GetSomeBytes










#ifdef FAR_MEM


#else


#endif
static  statustype   VoidStatus  = Env_Normal;
void       Core_SetPageSize
(farlongtype    PageSize,  farlongtype MaxEntrySize)
{
Core_PageSize     = PageSize;
Core_MaxEntrySize = MaxEntrySize;
Core1BlockElems   = Core_PageSize;
return;
}
addrtype   VoidExtendCore (farlongtype   *SizeInBytes)
{
lt64          *LongPtr        = NullPtr;
addrtype       CoreAddr       = NullPtr;
addrtype       EndCoreBlkAddr = NullPtr;
sizetype       ByteAlignment  = 0;
farlongtype    FarSize        = 0;
static
boolean        FirstTime      = False;
static
boolean        FirstLimit     = True;
VoidStatus   = Env_Normal;
#ifdef __BCC__
sprintf (Msg, "    Extend VOID [%6u] %8lu bytes;  New Void =%8lu\n",
VoidBlksAllocated + 1, *SizeInBytes, VoidUsed);
TraceMsg (0, Msg);
#endif
#ifdef CORE_LIMIT
if (*SizeInBytes > CORE_LIMIT)
{
sprintf (Msg, TraceStr(0),
*SizeInBytes);
TraceMsg (0, Msg);
return (CoreAddr);
}
#endif
#ifdef OLDWAY
if (*SizeInBytes % CoreBlk_GapSpace)
{
ByteAlignment = CoreBlk_GapSpace - (*SizeInBytes % CoreBlk_GapSpace);
*SizeInBytes  += ByteAlignment;
}
#else
#ifdef CORE_CRC_CHECK
FarSize          = *SizeInBytes + CORE_BLOCK_ALIGN + 4;
if (FarSize % CoreBlk_GapSpace)
{
ByteAlignment = CoreBlk_GapSpace - (FarSize % CoreBlk_GapSpace);
FarSize      += ByteAlignment;
}
#else
FarSize          = *SizeInBytes;
if (FarSize % CoreBlk_GapSpace)
{
ByteAlignment = CoreBlk_GapSpace - (FarSize % CoreBlk_GapSpace);
FarSize      += ByteAlignment;
}
#endif
#endif
if ((FarSize + VoidUsed) > VOID_BOUNDARY)
{
if (FirstLimit)
SendMsg (0,   "\n *** WARNING *** VOID_BOUNDARY EXCEEDED!!!\n");
else
SendMsg (0,   "\n *** ERROR   *** VOID_BOUNDARY EXCEEDED!!!\n");
sprintf (Msg, "      BOUNDARY := %8d;  RESERVE := %8d;\n",
VOID_BOUNDARY, VOID_RESERVE);
SendMsg (0, Msg);
if (FirstLimit)
VOID_BOUNDARY  += VOID_RESERVE;
FirstLimit         = False;
return (NullPtr);
}
if ((LongPtr  = (lt64           *)GET_MEM (1, FarSize)) == NULL)
{
if (!FirstTry)
{
return (NullPtr);
} else {
FirstTry     = False;
do
{
*SizeInBytes = *SizeInBytes - 256;
LongPtr     = (lt64          *)GET_MEM (1, *SizeInBytes);
} while (*SizeInBytes >= 256 && LongPtr == NULL);
if (LongPtr)
if (sprintf (Msg, TraceStr(1),
*SizeInBytes))
SendMsg (0, Msg);
}
}
if (! CoreFreeStoreSize && FirstTry)
SysFarCoreLeft();
else
CoreFreeStoreSize -= FarSize;
#ifdef    CORE_CRC_CHECK
memset             ((addrtype )LongPtr, 0x55,   4);
EndCoreBlkAddr   = (addrtype )((char  *)LongPtr + (FarSize - 4));
memset             (EndCoreBlkAddr,     0x55,   4);
CoreAddr         = (addrtype )((char *)LongPtr + CORE_BLOCK_ALIGN);
#else
CoreAddr         = (addrtype )LongPtr;
#endif
VoidAllocated   += FarSize;
VoidUsed        += FarSize;
if (VoidUsed > VoidMaxUsed)
VoidMaxUsed        = VoidUsed;
VoidBlksAllocated++;
if (FirstTime)
{
VoidLowestAddr   = CoreAddr;
FirstTime        = False;
} else if (CoreAddr < VoidLowestAddr) {
VoidLowestAddr   = CoreAddr;
}
if (StrucAlignment)
{
if ((farlongtype )CoreAddr % StrucAlignment)
{
sprintf (Msg, TraceStr(4),
LongPtr);
TraceMsg (0, Msg);
sprintf (Msg, TraceStr(5),
Core1Size);
SendMsg (0, Msg);
VoidStatus   = Core_NotInAlignment;
}
}
if ( DeBug )
{
sprintf(Msg, "Extend VOID [%6u] := %8lu bytes;  VoidUsed := %8lu\n",
VoidBlksAllocated , *SizeInBytes, VoidUsed);
TraceMsg (0, Msg);
}
return (CoreAddr);
}
void VoidFreeCore         (addrtype      *CoreAddr,  farlongtype SizeInBytes)
{
farlongtype    FarSize        = 0;
sizetype       ByteAlignment  = 0;
addrtype       EndCoreBlkAddr = NullPtr;
lt64          *LongPtr = NullPtr;
VoidStatus   = Env_Normal;
#ifdef __BCC__
sprintf (Msg,
"    VOID FreeCore:: Void Range (* %-8lu) @ %8x :: %8x\n",
SizeInBytes, *CoreAddr,
(addrtype )(*(farlongtype **)CoreAddr + SizeInBytes));
TraceMsg (0, Msg);
#else
if (CoreBug)
if (sprintf (Msg, TraceStr(6),
SizeInBytes, *CoreAddr,
(addrtype )(*(farlongtype **)CoreAddr + SizeInBytes)))
TraceMsg (0, Msg);
#endif
if (*CoreAddr)
{
#ifdef    CORE_CRC_CHECK
FarSize          = SizeInBytes + CORE_BLOCK_ALIGN + 4;
if (FarSize % CoreBlk_GapSpace)
{
ByteAlignment = CoreBlk_GapSpace - (FarSize % CoreBlk_GapSpace);
FarSize      += ByteAlignment;
}
*CoreAddr         = (addrtype )((char  *)*CoreAddr - CORE_BLOCK_ALIGN);
LongPtr          = *(numtype **)CoreAddr;
EndCoreBlkAddr   = (addrtype )((char  *)*CoreAddr + (FarSize - 4));
if (*(numtype *)LongPtr               != CORE_CONSTANT)
{
SendMsg (0, "\n ***ERROR... in Management of VOID\n");
SendMsg (0, "    FIRST 4 bytes in VOID Block OVER-WRITEN !\n");
sprintf (Msg, "     VOID address := @%8x\n", *CoreAddr);
TraceMsg (0, Msg);
VoidStatus   = Core_CRCoverWritten;
} else if (*(numtype *)EndCoreBlkAddr != CORE_CONSTANT) {
SendMsg (0, "\n ***ERROR... in Management of VOID\n");
SendMsg (0, "    LAST  4 bytes in VOID Block OVER-WRITEN !\n");
sprintf (Msg, "     VOID address := @%8x\n", *CoreAddr);
TraceMsg (0, Msg);
VoidStatus   = Core_CRCoverWritten;
}
#else
FarSize          = SizeInBytes;
if (FarSize % CoreBlk_GapSpace)
{
ByteAlignment = CoreBlk_GapSpace - (FarSize % CoreBlk_GapSpace);
FarSize      += ByteAlignment;
}
#endif
VoidDeAllocated += FarSize;
VoidUsed        -= FarSize;
FREE_MEM         (*(void **)CoreAddr);
} else {
sprintf (Msg, "***ERROR... Core Address <%8x> Below Void <%8x>\n",
*CoreAddr, VoidLowestAddr);
TraceMsg (0, Msg);
VoidStatus     = Core_NULLCoreAddrOfFree;
}
*CoreAddr         = NullPtr;
VoidBlksDeAllocated++;
if ( DeBug )
{
sprintf(Msg, "Free   VOID [%6u] := %8lu bytes;  VoidUsed := %8lu\n",
VoidBlksDeAllocated , SizeInBytes, VoidUsed);
TraceMsg (0, Msg);
}
StackTrack ("VoidFreeCore\n");
return;
}
farlongtype SysFarCoreLeft   (void)
{
indextype      CoreBlks           = 0;
addrtype       CoreAddr[20];
counttype      i                  = 0;
farlongtype    AllocAmount        = Core_PageSize;
static
sizetype       SizeOfInt          = sizeof(int);
if (FirstTry == False
||  FirstTry == True)
return (1024000L);
if (FirstTry == True)
{
FirstTry = False;
if (SizeOfInt <= 2)
return (1024000L);
while ((CoreAddr[i]  = (addrtype )GET_MEM (1, AllocAmount)) != NULL)
{
Alloc_Amount += AllocAmount;
sprintf (Msg, TraceStr(7),
AllocAmount, CoreAddr[i]);
SendMsg (0, Msg);
++i;
}
AllocAmount -= 100;
while ( (AllocAmount &&
(CoreAddr[i]  = (addrtype )GET_MEM (1, AllocAmount)) == NULL))
{
AllocAmount -= 100;
}
if (CoreAddr[i])
{
Alloc_Amount += AllocAmount;
sprintf (Msg, TraceStr(8),
AllocAmount, CoreAddr[i]);
SendMsg (0, Msg);
} else
--i;
if (Alloc_Amount)
{
CoreBlks     = i;
while (i >= 0)
{
sprintf (Msg, TraceStr(9),
i, CoreAddr[i]);
SendMsg (0, Msg);
FREE_MEM (CoreAddr[i]);
i--;
}
CoreFreeStoreSize = (Core_PageSize * CoreBlks) + AllocAmount;
sprintf (Msg, TraceStr(10),
CoreFreeStoreSize);
SendMsg (0, Msg);
} else
SendMsg (0, " *** CORE *** CoreNoMore\n");
}
return (CoreFreeStoreSize);
}
boolean    CoreMoreCore   (bytessizetype RequestSize,
ft F,lt Z,zz *Status,      addrtype   *Region)
{
farlongtype    AllocCore1     = 0;
bytessizetype  SizeInBytes    = RequestSize;
AllocCore1      = (farlongtype )SizeInBytes;
if ((*Region    = (addrtype )VoidExtendCore (&AllocCore1)) == NULL)
*Status      = Env_CoreNoMore;
else
*Status      = VoidStatus;
Core1Used      += (farlongtype )SizeInBytes;
#ifdef    NULL_TRACE_STRS
if (sprintf (Msg, "            Core1::  Used=        %6lu;\n",
Core1Size))
TraceMsg (0, Msg);
#endif
if (CoreBug || Core1Bug)
if (sprintf (Msg,
"                          Core1_MORE Core (*%6lu) @%8x; Alloc= %4u\n",
RequestSize,  *Region, SizeInBytes))
TraceMsg (0, Msg);
TRACK(TrackBak,"CoreMoreCore\n");
return(STAT);
}
boolean CoreFreeCoreSpace (addrtype     *CoreAddr,  bytessize   FreeSize,
ft F,lt Z,zz *Status)
{
bytessizetype  SizeInBytes    = FreeSize;
if (CoreBug  || DeBug > 0  || Core1Bug)
if (sprintf (Msg,
"                          Core1_FREE Core (*%6lu) @%8x; Alloc= %4u\n",
FreeSize, *CoreAddr, SizeInBytes))
TraceMsg (0, Msg);
VoidFreeCore    (CoreAddr,    SizeInBytes);
*Status        = VoidStatus;
Core1Used    -= (farlongtype )SizeInBytes;
*CoreAddr  = NullPtr;
Core1Freeed += (farlongtype )SizeInBytes;
TRACK(TrackBak,"CoreFreeCoreSpace\n");
return(STAT);
}
boolean    Core0MoreCore  (bytessizetype SizeInBytes,
ft F,lt Z,zz *Status,      addrtype   *Region)
{
bytessizetype  AllocSize  = SizeInBytes;
#ifdef DEBUG_CORE0
indextype   StackPtr   = 0;
#endif
farlongtype    AllocCore0     = 0;
#ifdef NULL_TRACE_STRS
if (sprintf (Msg, "    Core0MoreCore ::  Size= %6lu;\n",
SizeInBytes))
TraceMsg (0, Msg);
#endif
AllocCore0      = (farlongtype )SizeInBytes;
Core1Used      += (farlongtype )SizeInBytes;
if ((*Region    = (addrtype )VoidExtendCore (&AllocCore0)) == NULL)
*Status      = Env_CoreNoMore;
else
*Status      = VoidStatus;
#ifdef DEBUG_CORE0
if (Core0_Chunk == 0)
{
Mem_MakeChunk   (sizeof(addrtype),  10000,           1000,
0,                McStat,         &Core0_Chunk);
}
if (Normal(*Status))
MemPushAddr (Core0_Chunk,  *Region,  McStat,  &StackPtr);
#endif
if (CoreBug  || DeBug > 0 || Core0Bug)
{
if (sprintf (Msg,
"                          Core0_MORE Core (*%6lu) @%8x; Alloc= %4u\n",
SizeInBytes, *Region, AllocSize))
TraceMsg (0, Msg);
}
TRACK(TrackBak,"Core0MoreCore\n");
return(STAT);
}
boolean Core0FreeCoreSpace(addrtype     *CoreAddr,  bytessize   FreeSize,
ft F,lt Z,zz *Status)
{
bytessizetype  SizeInBytes    = FreeSize;
#ifdef DEBUG_CORE0
addrtype      *Core0Chunk     = NullPtr;
indextype      StackPtr       = 0;
int            i              = 0;
int            j              = 0;
boolean        NotFound       = True;
if (MemGetChunkAddr (Core0_Chunk,  McStat,  (addrtype *)&Core0Chunk))
if (MemGetStackPtr  (Core0_Chunk,  McStat,  &StackPtr))
while (i < StackPtr
&&     NotFound
&&     Normal(*Status))
{
if (Core0Chunk[i] == *CoreAddr)
{
NotFound = False;
Core0Chunk[i]    = NullPtr;
j = i;
while (j < StackPtr - 1)
{
Core0Chunk[j] = Core0Chunk[j+1];
if (Core0Chunk[j] == *CoreAddr)
{
sprintf (Msg,
"  ***ERROR***  Core0_FREE Core (*%6lu) @%8x Have DUPLICATE;\n",
FreeSize, *CoreAddr);
TraceMsg (0, Msg);
Mem_DumpChunk (0, Core0_Chunk,  McStat);
*Status = Err_BadDesign;
}
j++;
}
if (Normal(*Status))
MemPutStackPtr (Core0_Chunk,  --StackPtr,    McStat);
}
i++;
}
if (NotFound == True)
{
sprintf (Msg,
"  ***ERROR***  Core0_FREE Core (*%6lu) @%8x Previously FREEED;\n",
FreeSize, *CoreAddr);
TraceMsg (0, Msg);
Mem_DumpChunk (0, Core0_Chunk,  McStat);
*Status = Err_BadDesign;
}
#endif
if (CoreBug  || DeBug > 0 || Core0Bug)
if (sprintf (Msg,
"                          Core0_FREE Core (*%6lu) @%8x; Alloc= %4u\n",
FreeSize, *CoreAddr, SizeInBytes))
TraceMsg (0, Msg);
VoidFreeCore    (CoreAddr,    SizeInBytes);
*Status        = VoidStatus;
Core1Used    -= (farlongtype )SizeInBytes;
*CoreAddr  = NullPtr;
Core1Freeed += (farlongtype )SizeInBytes;
TRACK(TrackBak,"Core0FreeCoreSpace\n");
return(STAT);
}
boolean    Core0_AllocString
(sizetype      StrSize,
ft F,lt Z,zz *Status,    char       **String)
{
Core0MoreCore(StrSize,McStat,(addrtype *) String);
if (ClassBug || CoreBug || DeBug > 0)
if (sprintf  (Msg, "    Core0_AllocString(*%4u) @%x\n", StrSize, *String))
TraceMsg (0, Msg);
TRACK(TrackBak,"Core0_AllocString\n");
return(STAT);
}
boolean Core0_FreeString  (char         *String,   ft F,lt Z,zz *Status)
{
sizetype  ByteCount = strlen( String ) + 1;
if (ClassBug || CoreBug || DeBug > 0)
if (sprintf  (Msg, "    Core0_FreeString @%x\n", String))
TraceMsg (0, Msg);
AlignStruc( &ByteCount );
Core0FreeCoreSpace((addrtype *) &String, ByteCount, McStat);
TRACK(TrackBak,"Core0_FreeString\n");
return(STAT);
}
void    Core_AssignChunks
(numtype       AddrChunk, addrtype     *FreeAddrs,
numtype       SizeChunk, numtype      *FreeSizes)
{
KrnlFreeAddrChunk  = AddrChunk;
KrnlFreeAddr       = FreeAddrs;
KrnlFreeAddr0      = KrnlFreeAddr        - sizeof (chunkstruc);
KrnlFreeSizeChunk  = SizeChunk;
KrnlFreeSize       = FreeSizes;
KrnlChunkUnits     = KrnlBlocks_AllocQty - 1;
return;
}
boolean    CoreMoveBytes  (addrtype      Source,      sizeinbytes   SourceSize,
sizeinbytes   TargetSize,
ft F,lt Z,zz *Status,      addrtype     *Target )
{
if (SourceSize == 0)
{
*Target = Source;
*Status = Err_NoBytesMoved;
}
if (Normal(*Status))
if (CoreMoreCore     (TargetSize,              McStat,     Target))
memcpy            ((char *)*Target, (char *)Source,     SourceSize);
if (sprintf (Msg, TraceStr(66),
SourceSize, Source, *Target, TargetSize))
SendMsg (0, Msg);
if (Normal(*Status))
CoreFreeCoreSpace (&Source,                 SourceSize, McStat);
TRACK(TrackBak,"CoreMoveBytes\n");
return(STAT);
}
#ifdef NULL_TRACE_STRS
void CoreShowStats       (void)
{
statustype  ShellStatus   = Env_Normal;
TraceMsg (MSGFILE, "\n  Memory Manager Statistics::\n\n");
sprintf (Msg, TraceStr(67),
VoidAllocated);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(68),
VoidDeAllocated);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(69),
VoidUsed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Void   MAX Alloc'd  (at any point in Run) :: %8lu\n\n",  VoidMaxUsed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(70),
VoidBlksAllocated);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(71),
VoidBlksDeAllocated);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(72),
Num1Regions);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(73),
Core1Size);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(74),
Core1Freeed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(75),
Core1Reclaimed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Core   Current Size :: %8lu\n\n",Core1Used);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(76),
CoreBlksRequested);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(77),
CoreBlksFreeed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(78),
CoreBlksReclaimed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(79),
CoreBlksExactReclaimed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(80),
CoreBlksGapReclaimed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, TraceStr(81),
CoreBlksPageSpaceReclaimed);
TraceMsg (MSGFILE, Msg);
if (ClassBug || CoreBug)
if (KrnlFreeAddrChunk)
{
TraceMsg (MSGFILE, " Dump of KrnlFreeAddrChunk ::   ");
Mem_DumpChunkPart (MSGFILE, KrnlFreeAddrChunk, 0, 100, ShellMcStat);
TraceMsg (MSGFILE, "\n Dump of KrnlFreeSizeChunk ::   ");
Mem_DumpChunkPart (MSGFILE, KrnlFreeSizeChunk, 0, 100, ShellMcStat);
TraceMsg (MSGFILE, "\n");
}
return;
}
#else
void CoreShowStats       (void)
{
statustype  ShellStatus   = Env_Normal;
TraceMsg (MSGFILE, "\n     { VOID  :  CORE }\n\n");
sprintf (Msg, " Void:  Total    Allocated :: %8lu\n",  VoidAllocated);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Void:  Total De Allocated :: %8lu\n",  VoidDeAllocated);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " VOID:  Current  USED      :: %8lu\n",  VoidUsed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " VOID:  MAX Alloc'd (run)  :: %8lu\n\n",VoidMaxUsed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Void:  Blks     Allocated :: %8lu\n",  VoidBlksAllocated);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Void:  Blks  De Allocated :: %8lu\n\n",VoidBlksDeAllocated);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Core:  Regions  Allocated :: %8u\n",   Num1Regions);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Core:  Total    Allocated :: %8lu\n",  Core1Size);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Core:  Total    Freeed    :: %8lu\n",  Core1Freeed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Core:  Total    Reclaimed :: %8lu\n\n",Core1Reclaimed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " CORE:  Current  USED      :: %8lu\n\n",Core1Used);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Core:  Blks     Requested :: %8lu\n",  CoreBlksRequested);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Core:  Blks     Freeed    :: %8lu\n\n",  CoreBlksFreeed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, " Core:  Blks     Reclaimed :: %8lu\n",  CoreBlksReclaimed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, "        By       Exact Fit :: %8lu\n",  CoreBlksExactReclaimed);
TraceMsg (MSGFILE, Msg);
sprintf (Msg, "        By       Gaps      :: %8lu\n",  CoreBlksGapReclaimed);
TraceMsg (MSGFILE, Msg);
#ifdef PAGE_SPACE
sprintf (Msg, "     By   Page Space :: %8lu\n\n",CoreBlksPageSpaceReclaimed);
TraceMsg (MSGFILE, Msg);
#endif
if (ClassBug || CoreBug)
if (KrnlFreeAddrChunk)
{
TraceMsg (MSGFILE, " Dump of KrnlFreeAddrChunk ::   ");
Mem_DumpChunkPart   (MSGFILE, KrnlFreeAddrChunk, 0, 100, ShellMcStat);
TraceMsg (MSGFILE, "\n Dump of KrnlFreeSizeChunk ::   ");
Mem_DumpChunkPart   (MSGFILE, KrnlFreeSizeChunk, 0, 100, ShellMcStat);
TraceMsg (MSGFILE, "\n");
}
return;
}
#endif
void       MoveBytes      (addrtype     Source,      addrtype  Target,
sizeinbytes  ByteCount)
{
memcpy    ((char *)Target,    (char *)Source,    ByteCount);
if (DeBug >= 2 || MemBug)
{
sprintf (Msg, TraceStr(82),
ByteCount, Source, Target);
TraceMsg (0, Msg);
switch (ByteCount)
{
case  1 :
sprintf (Msg, TraceStr(83),
*(char      *)Source);
break;
case  2 :
sprintf (Msg, TraceStr(84),
*(short     *)Source);
break;
case  8 :
sprintf (Msg, TraceStr(85),
*(longtype *)Source,
*(longtype *)((char *)Source + sizeof (long)),
*(addrtype *)Source,
*(addrtype *)((char *)Source + sizeof (addrtype)));
break;
case  4 :
default :
sprintf (Msg, TraceStr(86),
*(lt64     *)Source,  *(addrtype  *)Source);
}
TraceMsg (0, Msg);
}
StackTrack ("MoveBytes\n");
return;
}
int        CompareBytes  (addrtype      Source,      addrtype      CmpVal,
sizeinbytes   ByteCount,   ft F,lt Z,zz *Status)
{
int i = 0;
if (DeBug >= 2)
if (sprintf (Msg, TraceStr(87),
ByteCount, Source, CmpVal,
i = memcmp ((char *)Source, (char *)CmpVal, ByteCount)))
TraceMsg (0, Msg);
if (i<0)
*Status = Env_Less;
else if(i>0)
*Status = Env_Gtr;
else
*Status = Env_Normal;
StackTrack ("CompareBytes\n");
STAT;
return(i);
}
/* 当前文件是./CINT2000\255.vortex\src\dba.c*/

#define DBA_C
/* 当前文件是./CINT2000\255.vortex\src\hm.h*/

#ifndef HM00_H
#define HM00_H
#define HmDRIswi                 Hm_DRIswi
#define HmSetDefaults            Hm_SetDefaults
#define HmGetDefaults            Hm_GetDefaults
#define HmMakeDbHdr              Hm_MakeDbHdr
#define HmGetObjNum              Hm_GetObjNum
#define HmIncrementMemRef        Hm_IncrementMemRef
#define HmDecrementMemRef        Hm_DecrementMemRef
#define HmNewHandle              Hm_NewHandle
#define HmPairDbObject           Hm_PairDbObject
#define HmFetchDbObject          Hm_FetchDbObject
#define HmGetStrObjectIndex      Hm_GetStrObjectIndex
#define HmClearObject            Hm_ClearObject
#define HmPointToInnerRealm      Hm_PointToInnerRealm
#define HmFreeHandle             Hm_FreeHandle
#define HmNextFreeHandle         Hm_NextFreeHandle
#define HmDumpDbHdr              Hm_DumpDbHdr

typedef struct TypeVchunkTkn
{
numtype      InCore;
vbntype      OnDisk;
}                     vchunktkntype;
typedef struct TypeTextTkn
{
numtype      InCore;
vbntype      OnDisk;
}                     texttkntype;
typedef struct TypeMapRefTkn
{
numtype      FieldNum;
numtype      LocalObj;
}                     maptkntype;
typedef  numtype handlechunk;
typedef  num     regionflag[2];


typedef dbheader           coredb;
typedef struct CoreObjType
{
num         ObjNum;
boolean     (*CreateCode)(void);
}              coreobj;
typedef coreobj            coreobject;
typedef struct KernelCore
{
coredb      *CoreDbs;
	  coreobject  *CoreObjs;
}                          corekernel;
corekernel  *Kernel              = NullPtr;
idtype       CoreDbCount         = 0;
idtype       MaxCoreDbId         = 99;
dbheader    *CoreDbs[100]        = {
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr,
NullPtr,NullPtr,NullPtr,NullPtr,NullPtr
};
dbheader    *CoreDb0             = NullPtr;
dbheader    *CoreDb1             = NullPtr;
boolean      SwapHandles         = False;
handletype   SwapHandleUnits     = 0;
handletype   CoreHandles         = 0;
static  boolean      DRI_Env             = False;
static  handletype   VoidHandle          = 0;
static  indextype    HM_EnvObjs          = Env_Objs;
static  indextype    HM_EnvAttrs         = Env_Attrs;
static  indextype    HM_AllocDbObjs      = Alloc_DbObjs;
static  indextype    HM_ExtendDbObjs     = Extend_DbObjs;
static  indextype    HM_AllocDbAttrs     = Alloc_Attrs;
static  indextype    HM_ExtendDbAttrs    = Extend_DbAttrNums;
static  indextype    HM_AllocHandles     = 0;
static  indextype    HM_ExtendHandles    = 0;
static  indextype    HM_AllocVchunks     = 0;
static  indextype    HM_ExtendVchunks    = 0;
static  indextype    HM_AllocGrps        = Alloc_Grps;
static  indextype    HM_ExtendGrps       = Extend_Grps;
static  indextype    HM_AllocTxtTkns     = Alloc_TxtTkns;
static  indextype    HM_ExtendTxtTkns    = Extend_TxtTkns;
static  indextype    HM_AllocDbXmemBlks  = 0;
static  indextype    HM_ExtendDbXmemBlks = 0;

void    Hm_SetDRIswi  (boolean       DRI_Env);
boolean HmDRIswi      (void);
void    HmSetDefaults (indextype     EnvObjs,   indextype     EnvAttrs,
indextype     AllocObjs, indextype     ExtendObjs,
indextype     AllocAttrs,indextype     ExtendAttrs,
indextype     AllocHndls,indextype     ExtendHndls,
indextype     AllocVchunks,indextype   ExtendVchunks,
indextype     AllocGrps, indextype     ExtendGrps,
indextype     AllocTexts,indextype     ExtendTexts,
indextype     AllocXblks,indextype     ExtendXblks);
void    HmGetDefaults (indextype    *EnvObjs,   indextype    *EnvAttrs,
indextype    *AllocObjs, indextype    *ExtendObjs,
indextype    *AllocAttrs,indextype    *ExtendAttrs,
indextype    *AllocHndls,indextype    *ExtendHndls,
indextype    *AllocVchunks,indextype  *ExtendVchunks,
indextype    *AllocGrps, indextype    *ExtendGrps,
indextype    *AllocTexts,indextype    *ExtendTexts,
indextype    *AllocXblks,indextype    *ExtendXblks);
boolean HmMakeDbHdr       (indextype     EnvObjs,  indextype     EnvAttrs,
idtype        CoreDbId,
ft F,lt Z,zz *Status,   dbheader    **CoreDb);
#ifdef __MACROIZE_HM__
#define HmPushLocalObjNum(CoreDb, LocalObj, Stat,   StackPtr)  \
MemPushWord (CoreDb->LocalObjNumDir, LocalObj, Stat,   StackPtr)
#define HmGetLocalObjNum(CoreDb, Handle,   Stat,   LocalObj)  \
MemGetWord (CoreDb->LocalObjNumDir, Handle,   Stat,   LocalObj)
#define HmPutLocalObjNum(CoreDb, Handle,   LocalObj, Stat)  \
MemPutWord (CoreDb->LocalObjNumDir, Handle,   LocalObj, Stat)
#define HmPutObjNum(CoreDb, LocalObj, EnvObjNum, Stat)  \
MemPutWord (CoreDb->ObjNumMap, LocalObj, EnvObjNum, Stat)
#define HmPushObjectAddr(CoreDb, ObjAddr,  Stat,   StackPtr)  \
MemPushAddr (CoreDb->ObjectAddrDir, ObjAddr,  Stat,   StackPtr)
#define HmPutObjectAddr(CoreDb,  Handle,   ObjAddr,  Stat)  \
MemPutAddr (CoreDb->ObjectAddrDir,  Handle,   ObjAddr,  Stat)
#define HmGetObjectAddr(CoreDb,  Handle,   Stat,   ObjAddr)  \
MemGetAddr  (CoreDb->ObjectAddrDir,  Handle,   Stat,   ObjAddr)
#define HmPushObjectMemLoc(CoreDb, MemLoc,   Stat,   StackPtr)  \
MemPushBit (CoreDb->ObjectMemLocDir, MemLoc,   Stat,   StackPtr)
#define HmPutObjectMemLoc(CoreDb, Handle,    MemLoc,   Stat)  \
MemPutBit (CoreDb->ObjectMemLocDir, Handle,    MemLoc,   Stat)
#define HmGetObjectMemLoc(CoreDb, Handle,   Stat,   MemLoc)  \
MemGetBit (CoreDb->ObjectMemLocDir, Handle,   Stat,   MemLoc)
#define HmPushObjectMemRef(CoreDb, MemRef,  Stat,  StackPtr)  \
MemPushShort(CoreDb->ObjectMemRefDir, MemRef,  Stat,  StackPtr)
#define HmPutObjectMemRef(CoreDb, Handle, MemRef,   Stat)  \
MemPutShort(CoreDb->ObjectMemRefDir, Handle, MemRef,   Stat)
#define HmGetObjectMemRef(CoreDb, Handle,  Stat,   MemRef)  \
MemGetShort(CoreDb->ObjectMemRefDir, Handle,  Stat,   MemRef)
#define HmPushObjectIndex(CoreDb, ObjIndex, Stat,   StackPtr)  \
MemPushWord(CoreDb->ObjectIndexDir, ObjIndex, Stat,   StackPtr)
#define HmPutObjectIndex(CoreDb, Handle, ObjIndex, Stat)  \
MemPutWord (CoreDb->ObjectIndexDir, Handle, ObjIndex, Stat)
#define HmGetObjectIndex(CoreDb, Handle,  Stat,   ObjIndex)  \
MemGetWord (CoreDb->ObjectIndexDir, Handle,  Stat,   ObjIndex)
#define HmInvokeObject(CoreDb, Handle,  Object,   Stat)  \
MemPutAddr (CoreDb->ObjectAddrDir, Handle,  Object,   Stat)
#define HmPointToOuterRegion(CoreDb, Handle,  Stat)  \
MemPutBit(CoreDb->ObjectMemLocDir, Handle,  1, Stat)
#else
#define HmPushLocalObjNum        Hm_PushLocalObjNum
#define HmGetLocalObjNum         Hm_GetLocalObjNum
#define HmPutLocalObjNum         Hm_PutLocalObjNum
#define HmPutObjNum              Hm_PutObjNum
#define HmPushObjectAddr         Hm_PushObjectAddr
#define HmPutObjectAddr          Hm_PutObjectAddr
#define HmGetObjectAddr          Hm_GetObjectAddr
#define HmPushObjectMemLoc       Hm_PushObjectMemLoc
#define HmPutObjectMemLoc        Hm_PutObjectMemLoc
#define HmGetObjectMemLoc        Hm_GetObjectMemLoc
#define HmPushObjectMemRef       Hm_PushObjectMemRef
#define HmPutObjectMemRef        Hm_PutObjectMemRef
#define HmGetObjectMemRef        Hm_GetObjectMemRef
#define HmPushObjectIndex        Hm_PushObjectIndex
#define HmPutObjectIndex         Hm_PutObjectIndex
#define HmGetObjectIndex         Hm_GetObjectIndex
#define HmInvokeObject           Hm_InvokeObject
#define HmPointToOuterRegion     Hm_PointToOuterRegion
boolean HmPushLocalObjNum (dbheader     *CoreDb,   localnumtype  LocalObj,
ft F,lt Z,zz *Status,   indextype    *StackPtr);
boolean HmGetLocalObjNum  (dbheader     *CoreDb,   handletype    Handle,
ft F,lt Z,zz *Status,   localnumtype *LocalObj);
boolean HmPutLocalObjNum  (dbheader     *CoreDb,   handletype    Handle,
localnumtype  LocalObj, ft F,lt Z,zz *Status);
boolean HmPutObjNum       (dbheader     *CoreDb,   indextype     LocalObj,
numtype       EnvObjNum,ft F,lt Z,zz *Status);
boolean HmPushObjectAddr  (dbheader     *CoreDb,   addrtype      ObjAddr,
ft F,lt Z,zz *Status,   indextype    *StackPtr);
boolean HmPutObjectAddr  (dbheader      *CoreDb,   handletype    Handle,
addrtype      ObjAddr,  ft F,lt Z,zz *Status);
boolean HmGetObjectAddr  (dbheader      *CoreDb,   handletype    Handle,
ft F,lt Z,zz *Status,   addrtype     *ObjAddr);
boolean HmPushObjectMemLoc(dbheader     *CoreDb,   numtype       MemLoc,
ft F,lt Z,zz *Status,   indextype    *StackPtr);
boolean HmPutObjectMemLoc (dbheader     *CoreDb,   handletype    Handle,
numtype       MemLoc,   ft F,lt Z,zz *Status);
boolean HmGetObjectMemLoc (dbheader     *CoreDb,   handletype    Handle,
ft F,lt Z,zz *Status,   numtype      *MemLoc);
boolean HmPushObjectMemRef(dbheader     *CoreDb,   shorttype     MemRef,
ft F,lt Z,zz *Status,   indextype    *StackPtr);
boolean HmPutObjectMemRef (dbheader     *CoreDb,   handletype    Handle,
shorttype     MemRef,   ft F,lt Z,zz *Status);
boolean HmGetObjectMemRef (dbheader     *CoreDb,   handletype    Handle,
ft F,lt Z,zz *Status,   shorttype    *MemRef);
boolean HmPushObjectIndex (dbheader    *CoreDb,    indextype     ObjIndex,
ft F,lt Z,zz *Status,   indextype    *StackPtr);
boolean HmPutObjectIndex  (dbheader     *CoreDb,   handletype    Handle,
indextype     ObjIndex, ft F,lt Z,zz *Status);
boolean HmGetObjectIndex  (dbheader     *CoreDb,   handletype    Handle,
ft F,lt Z,zz *Status,   indextype    *ObjIndex);
boolean HmInvokeObject    (dbheader     *CoreDb,   handletype    Handle,
addrtype      Object,   ft F,lt Z,zz *Status);
boolean HmPointToOuterRegion
(dbheader     *CoreDb,   handletype    Handle,
ft F,lt Z,zz *Status);
#endif
boolean HmGetObjNum       (dbheader     *CoreDb,   handletype    Handle,
ft F,lt Z,zz *Status,   numtype      *EnvObjNum);
boolean HmIncrementMemRef (dbheader     *CoreDb,   handletype    Handle,
ft F,lt Z,zz *Status);
boolean HmDecrementMemRef (dbheader     *CoreDb,   handletype    Handle,
ft F,lt Z,zz *Status,   shorttype    *MemRef);
boolean HmNewHandle       (dbheader     *CoreDb,   localnumtype  LocalObj,
ft F,lt Z,zz *Status,   handletype   *Handle);
boolean HmPairDbObject    (dbheader     *CoreDb,   handletype    Handle,
indextype     Index,    addrtype      Object,
ft F,lt Z,zz *Status);
boolean HmFetchDbObject   (dbheader     *CoreDb,   handletype    Handle,
ft F,lt Z,zz *Status,   addrtype     *Object);
boolean HmGetStrObjectIndex(dbheader    *CoreDb,   strhandle     StrHandle,
ft F,lt Z,zz *Status,   indextype    *StrIndex);
boolean HmClearObject     (dbheader     *CoreDb,   handletype    Handle,
ft F,lt Z,zz *Status);
boolean HmPointToInnerRealm
(dbheader     *CoreDb,   handletype   Handle,
ft F,lt Z,zz *Status);
boolean HmFreeHandle      (dbheader     *CoreDb,   handletype   Handle,
ft F,lt Z,zz *Status);
boolean HmNextFreeHandle  (dbheader     *CoreDb,
ft F,lt Z,zz *Status,   handletype  *Handle);
boolean HmReclaimHandles  (dbheader     *CoreDb, ft F,lt Z,zz *Status);
boolean HmDumpDbHdr       (int           TraceSwi, tokentype   *Anchor,
ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\tm.h*/

#ifndef TM01
#define TM01
boolean TmNewCoreDb   (tokentype    *Anchor,
ft F,lt Z,zz *Status,   dbheader    **CoreDb);
boolean TmRenvToken   (ft F,lt Z,zz *Status,   tokentype    *RenvToken);
boolean TmWenvToken   (ft F,lt Z,zz *Status,   tokentype    *WenvToken);
boolean TmFetchCoreDb (tokentype    *Anchor,
ft F,lt Z,zz *Status,   dbheader    **CoreDb);
boolean TmMakeToken   (tokentype    *Anchor,   indextype     HandleIndex,
ft F,lt Z,zz *Status,   tokentype    *Token);
boolean TmIsValid     (tokentype    *Token,    ft F,lt Z,zz *Status);
boolean TmGetObject   (tokentype    *Token,
ft F,lt Z,zz *Status,   addrtype     *Object);
boolean TmFreeToken   (ft F,lt Z,zz *Status,   tokentype    *Token);
boolean TmReclaimHandles  ( tokentype    *Token,    ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\mem010.h*/

#ifndef MEM01_H
#define MEM01_H
typedef  boolean         bitfield;
typedef  byte            chunktype;
typedef  numtype         numchunk;
typedef  numtype         indexchunk;
typedef  numtype         indexhead;
typedef  numtype         addrchunk;
typedef  numtype         addrhead;
typedef  unsigned short  chunkflags;

#define NewChunkChunk          Mem_NewChunkChunk
#define DumpChunkChunk         Mem_DumpChunkChunk
#define MemNewChunkBlk         Mem_NewChunkBlk
#define MemPutChunkStruc       Mem_PutChunkStruc
#define MemMakeChunk           Mem_MakeChunk
#define MemMakeCppChunk        Mem_MakeCppChunk
#define MemMakeStrChunk        Mem_MakeStrChunk
#define MemDumpChunk           Mem_DumpChunk
#define MemFreeChunk           Mem_FreeChunk
#define MemFreeChunkNum        Mem_FreeChunkNum
#define MemClearChunkSpace     Mem_ClearChunkSpace
#define MemFreeChunkSpace      Mem_FreeChunkSpace
#define MemSwapOutChunk        Mem_SwapOutChunk
#define MemSwapInChunk         Mem_SwapInChunk
#define MemCopyOutChunk        Mem_CopyOutChunk
#define MemCopyInChunk         Mem_CopyInChunk
#define MemGetFileBlk          Mem_GetFileBlk
#define MemFreeFileBlk         Mem_FreeFileBlk
#define MemNewXmemBlk          Mem_NewXmemBlk
#define MemFreeXmemBlk         Mem_FreeXmemBlk
#define MemGetFreeXmemVbn      Mem_GetFreeXmemVbn
#define MemGetFreeXmemBlk      Mem_GetFreeXmemBlk
#define MemFreezeChunk         Mem_FreezeChunk
#define MemDefrostChunk        Mem_DefrostChunk
#define MemGetChunkSize        Mem_GetChunkSize
#define MemGetChunkStruc       Mem_GetChunkStruc
#define MemDumpChunkStruc      Mem_DumpChunkStruc
#define MemPutChunkAddr        Mem_PutChunkAddr
#define MemGetChunkAddr        Mem_GetChunkAddr
#define MemPutStackPtr         Mem_PutStackPtr
#define MemGetStackPtr         Mem_GetStackPtr
#define MemPushEntity          Mem_PushEntity
#define MemPutEntity           Mem_PutEntity
#define MemPopEntity           Mem_PopEntity
#define MemGetEntity           Mem_GetEntity
#define MemNewBitChunk         Mem_NewBitChunk
#define MemPushBit             Mem_PushBit
#define MemPutBit              Mem_PutBit
#define MemPopBit              Mem_PopBit
#define MemGetBit              Mem_GetBit
#define MemPushShort           Mem_PushShort
#define MemPutShort            Mem_PutShort
#define MemPopShort            Mem_PopShort
#define MemGetShort            Mem_GetShort
#define MemPushWord            Mem_PushWord
#define MemPutWord             Mem_PutWord
#define MemPopWord             Mem_PopWord
#define MemGetWord             Mem_GetWord
#define MemPushLong            Mem_PushLong
#define MemPutLong             Mem_PutLong
#define MemPopLong             Mem_PopLong
#define MemGetLong             Mem_GetLong
#define MemPushAddr            Mem_PushAddr
#define MemPutAddr             Mem_PutAddr
#define MemPopAddr             Mem_PopAddr
#define MemGetAddr             Mem_GetAddr
#define MemPushToken           Mem_PushToken
#define MemPutToken            Mem_PutToken
#define MemPopToken            Mem_PopToken
#define MemGetToken            Mem_GetToken
#define MemPushFuncPtr         Mem_PushFuncPtr
#define MemPutFuncPtr          Mem_PutFuncPtr
#define MemPopFuncPtr          Mem_PopFuncPtr
#define MemGetFuncPtr          Mem_GetFuncPtr
#define MemPushSomeBytes       Mem_PushSomeBytes
#define MemPutSomeBytes        Mem_PutSomeBytes
#define MemAssertPutBytes      Mem_AssertPutBytes
#define MemPopSomeBytes        Mem_PopSomeBytes
#define MemGetSomeBytes        Mem_GetSomeBytes
#define MemAssertGetBytes      Mem_AssertGetBytes
#define MemNewString           Mem_NewString
#define MemPushString          Mem_PushString
#define MemPutString           Mem_PutString
#define MemPopString           Mem_PopString
#define MemGetString           Mem_GetString
#define MemDeleteString        Mem_DeleteString
boolean Mem_NewChunkChunk
(ft F,lt Z,zz *Status,    numtype  *ChunkNum);
boolean Mem_NewChunkBlk
(sizeinbytes   BlkSize,   ft F,lt Z,zz *Status,
numtype      *ChunkNum,  addrtype *ChunkBlk);
boolean Mem_PutChunkStruc
(numtype       Chunk,    chunkstruc   *ChunkRef,
idtype        CoreDbId, ft F,lt Z,zz *Status);
boolean Mem_FreeChunkNum
(numtype      *ChunkNum,  ft F,lt Z,zz *Status);
boolean Mem_ClearChunkSpace
(numtype       Chunk,     ft F,lt Z,zz *Status);
boolean Mem_FreeChunkSpace
(numtype       Chunk,     ft F,lt Z,zz *Status);
boolean Mem_FreeXmemBlk
(ft F,lt Z,zz *Status,    vbntype  *Vbn);
boolean Mem_NewXmemBlk
(bytessize     SizeInBytes,
ft F,lt Z,zz *Status,
vbntype      *Vbn,       lt64     *XmemOffset);
boolean Mem_GetFreeXmemVbn
(ft F,lt Z,zz *Status,    vbntype  *Vbn);
boolean Mem_GetFreeXmemBlk
(bytessize     SizeInBytes,
ft F,lt Z,zz *Status,   indextype *BlkIndex);
boolean Mem_PutChunkAddr
(numtype       Chunk,     addrtype  ChunkAddr,
ft F,lt Z,zz *Status);
boolean Mem_MakeChunk
(bytessize     UnitSize,  indextype     AllocQty,
indextype     ExtendQty, idtype        CoreDbId,
ft F,lt Z,zz *Status,    numtype      *Chunk);
boolean Mem_MakeCppChunk
(bytessize     CppObjSize,indextype     AllocQty,
indextype     ExtendQty, idtype        CoreDbId,
ft F,lt Z,zz *Status,    numtype      *Chunk);
boolean Mem_MakeStrChunk
(bytessize     MaxLength, indextype     NumStrings,
indextype     ExtendQty, bytessize     TextLength,
idtype        CoreDbId,
ft F,lt Z,zz *Status,    numtype      *Chunk);
void    Mem_DumpChunkChunk
(int           Dump,      numtype       Chunk);
boolean Mem_SwapOutChunk
(numtype       Chunk,     ft F,lt Z,zz *Status,
vbntype      *Vbn);
boolean Mem_SwapInChunk
(numtype       Chunk,     ft F,lt Z,zz *Status,
vbntype      *Vbn);
boolean Mem_CopyOutChunk
(numtype       Chunk,     ft F,lt Z,zz *Status,
vbntype      *SwapVbn);
boolean Mem_CopyInChunk
(numtype       Chunk,     numtype       SwapVbn,
addrtype      SwapAddr,  ft F,lt Z,zz *Status);
boolean Mem_MoveChunk
(numtype       Chunk,     ft F,lt Z,zz *Status,
addrtype     *FreeAddr,  sizeinbytes  *FreeSize);
boolean Mem_FreezeChunk
(numtype       Chunk,     ft F,lt Z,zz *Status);
boolean Mem_DefrostChunk
(numtype       Chunk,     ft F,lt Z,zz *Status);
boolean Mem_DumpChunk
(int           MsgLevel,  numtype       Chunk,
ft F,lt Z,zz *Status);
boolean Mem_DumpChunkPart
(int           MsgLevel,  numtype       Chunk,
numtype       Ilow,      numtype       Ihigh,
ft F,lt Z,zz *Status);
boolean Mem_FreeChunk
(numtype      *ChunkNum,  ft F,lt Z,zz *Status);
boolean Mem_GetChunkSize
(numtype       Chunk,
ft F,lt Z,zz *Status,    indextype    *UnitCount,
bytessize    *UnitSize);
boolean Mem_GetChunkAddr
(numtype       Chunk,
ft F,lt Z,zz *Status,    addrtype     *ChunkAddr);
boolean Mem_GetStackPtr
(numtype       Chunk,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_PutStackPtr
(numtype       Chunk,     indextype     StackPtr,
ft F,lt Z,zz *Status);
boolean Mem_AssertStackPtr
(numtype       Chunk,     indextype     StackPtr,
ft F,lt Z,zz *Status,    addrtype     *ChunkAddr);
boolean Mem_GetChunkStruc
(numtype       Chunk,     ft F,lt Z,zz *Status,
chunkstruc   *ChunkRef);
boolean Mem_DumpChunkStruc
(chunkstruc   *ChunkRef,  ft F,lt Z,zz *Status);
boolean Mem_NewBitChunk
(numtype       BitWidth,  idtype        CoreDbId,
ft F,lt Z,zz *Status,    numtype      *BitChunk);
boolean Mem_PushBit
(numtype       Chunk,     word          BitValue,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_PutBit
(numtype       Chunk,     indextype     Index,
word          BitValue,  ft F,lt Z,zz *Status);
boolean Mem_PopBit
(numtype       Chunk,     ft F,lt Z,zz *Status,
word         *BitValue,  indextype    *StackPtr);
boolean Mem_GetBit
(numtype       Chunk,     indextype     Index,
ft F,lt Z,zz *Status,    word         *BitValue);
boolean Mem_PushShort
(numtype       Chunk,     shorttype     ShortValue,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_PutShort
(numtype       Chunk,     indextype     Index,
shorttype     ShortVal,  ft F,lt Z,zz *Status);
boolean Mem_PopShort
(numtype       Chunk,     ft F,lt Z,zz *Status,
shorttype    *ShortVal,  indextype    *StackPtr);
boolean Mem_GetShort
(numtype       Chunk,     indextype     Index,
ft F,lt Z,zz *Status,    shorttype    *ShortValue);
boolean Mem_PushWord
(numtype       Chunk,     word          WordValue,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_PutWord
(numtype       Chunk,     indextype     Index,
word          WordValue, ft F,lt Z,zz *Status);
boolean Mem_PopWord
(numtype       Chunk,     ft F,lt Z,zz *Status,
word         *WordValue, indextype    *StackPtr);
boolean Mem_GetWord
(numtype       Chunk,     indextype     Index,
ft F,lt Z,zz *Status,    word         *WordValue);
boolean Mem_PushLong
(numtype       Chunk,     lt64          LongValue,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_PutLong
(numtype       Chunk,     indextype     Index,
lt64          LongValue, ft F,lt Z,zz *Status);
boolean Mem_PopLong
(numtype       Chunk,     ft F,lt Z,zz *Status,
lt64         *LongValue, indextype    *StackPtr);
boolean Mem_GetLong
(numtype       Chunk,     indextype     Index,
ft F,lt Z,zz *Status,    lt64         *LongValue);
boolean Mem_PushAddr
(numtype       Chunk,     addrtype      Addr,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_PutAddr
(numtype       Chunk,     indextype     Index,
addrtype      Addr,      ft F,lt Z,zz *Status);
boolean Mem_PopAddr
(numtype       Chunk,     ft F,lt Z,zz *Status,
addrtype     *Addr,      indextype    *StackPtr);
boolean Mem_GetAddr
(numtype       Chunk,     indextype     Index,
ft F,lt Z,zz *Status,    addrtype     *Addr);
boolean Mem_PushToken
(numtype       Chunk,     tokentype    *Token,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_PutToken
(numtype       Chunk,     indextype     Index,
tokentype    *Token,     ft F,lt Z,zz *Status);
boolean Mem_PopToken
(numtype       Chunk,     ft F,lt Z,zz *Status,
tokentype    *Token,     indextype    *StackPtr);
boolean Mem_GetToken
(numtype       Chunk,     indextype     Index,
ft F,lt Z,zz *Status,    tokentype    *Token);
boolean Mem_PushFuncPtr
(numtype       Chunk,     funcptrtype   FuncPtr,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_PutFuncPtr
(numtype       Chunk,     indextype     Index,
funcptrtype   FuncPtr,   ft F,lt Z,zz *Status);
boolean Mem_PopFuncPtr
(numtype       Chunk,     ft F,lt Z,zz *Status,
funcptrtype  *FuncPtr,   indextype    *StackPtr);
boolean Mem_GetFuncPtr
(numtype       Chunk,     indextype     Index,
ft F,lt Z,zz *Status,    funcptrtype  *FuncPtr);
boolean Mem_NewString
(numtype       Chunk,     char         *String,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_PushString
(numtype       Chunk,     char         *String,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_PutString
(numtype       Chunk,     indextype     Index,
char         *String,    ft F,lt Z,zz *Status);
boolean Mem_PopString
(numtype       Chunk,     ft F,lt Z,zz *Status,
char        **String,    indextype    *StackPtr);
boolean Mem_GetString
(numtype       Chunk,     indextype     Index,
ft F,lt Z,zz *Status,    char        **String);
boolean Mem_DeleteString
(numtype       Chunk,     indextype     StackPtr,
ft F,lt Z,zz *Status);
boolean Mem_PushSomeBytes
(numtype       Chunk,     bytessize     ByteCount,
addrtype      SomeBytes,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_PutSomeBytes
(numtype       Chunk,     indextype     Index,
bytessize     ByteCount, addrtype      SomeBytes,
ft F,lt Z,zz *Status);
boolean Mem_AssertPutBytes
(numtype       Chunk,     indextype     Index,
bytessize     ByteCount,
ft F,lt Z,zz *Status,    addrtype     *BytePtr);
boolean Mem_PopSomeBytes
(numtype       Chunk,     bytessize     ByteCount,
ft F,lt Z,zz *Status,
addrtype      SomeBytes, indextype    *StackPtr);
boolean Mem_GetSomeBytes
(numtype       Chunk,     indextype     Index,
bytessize     ByteCount,
ft F,lt Z,zz *Status,    addrtype      SomeBytes);
boolean Mem_AssertGetBytes
(numtype       Chunk,     indextype     Index,
bytessize     ByteCount,
ft F,lt Z,zz *Status,    addrtype     *BytePtr);
boolean Mem_PushEntity
(numtype       Chunk,    bytessize      ByteCount,
addrtype      Entity,
ft F,lt Z,zz *Status,   indextype     *ByteOffset);
boolean Mem_PutEntity
(numtype       Chunk,     indextype     ByteOffset,
bytessize     ByteCount, addrtype      Entity,
ft F,lt Z,zz *Status);
boolean MemExtractEntity
(numtype       Chunk,   indextype     ByteOffset,
bytessize     Count,   ft F,lt Z,zz *Status);
boolean Mem_GetEntity
(numtype       Chunk,     indextype     ByteOffset,
bytessize     ByteCount,
ft F,lt Z,zz *Status,    addrtype     *Entity);
void    Mem_ShowStats
(void);
#endif
/* 当前文件是./CINT2000\255.vortex\src\odbm.h*/

#ifndef ODBM01_H
#define  ODBM01_H
booleantype   PairObjects    = True;
booleantype   UnPairObjects  = True;


boolean DbmLoadObjHdr  (tokentype    *DbToken, numtype       LocalObj,
ft F,lt Z,zz *Status,  objheader   **ObjHdr);
boolean DbmFileInObjHdr(objheader    *ObjHdr,  idtype        DbId,
blkhdrtype   *BlkHdr,  boolean       Release,
ft F,lt Z,zz *Status);
boolean DbmFileInRegionChunk
(dbheader     *CoreDb,  objheader    *ObjHdr,
indextype     RgnIndex,boolean       Release,
ft F,lt Z,zz *Status,  numtype      *RgnChunk);
boolean DbmPairRgnObjects
(dbheader     *CoreDb,  objheader    *ObjHdr,
numtype  CurrRgnChunk, ft F,lt Z,zz *Status);
boolean DbmUnPairRgnObjects
(dbheader     *CoreDb,  objheader    *ObjHdr,
numtype  CurrRgnChunk, ft F,lt Z,zz *Status);
void    DbmDumpObjHdr  (int          TraceSwi,
objheader   *ObjHdr,   ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\oa0.h*/

#ifndef OA0_H
#define OA0_H
boolean OaCreateDb (tokentype    *SchemaTkn, numtype       PrimalObj,
char         *DbName,    char         *NewFileName,
dbaccesstype  DbAccess,
ft F,lt Z,zz *Status,    tokentype    *DbPrimal);
boolean OaInstallObjHdr
(tokentype    *Anchor,    numtype       EnvObj,
ft F,lt Z,zz *Status,    objheader   **ObjHdr);
boolean OaGetObjClass
(tokentype    *Token,
ft F,lt Z,zz *Status,    numtype      *ObjNum);
boolean OaConfigClass
(tokentype    *PrimalTkn, numtype       ClassId,
numtype       RgnEntrys,
numtype       AllocRgns, numtype       ExtendRgns,
numtype       AllocXs,   numtype       ExtendXs,
accesstype    AccessType,boolean       DiskCache,
numtype       CacheLimit,numtype       CacheLoad,
ft F,lt Z,zz *Status);
boolean OaFreezeObjClass
(tokentype    *Anchor,    numtype       EnvObj,
ft F,lt Z,zz *Status);
boolean OaThawObjClass
(tokentype    *Anchor,    numtype       EnvObj,
ft F,lt Z,zz *Status);
boolean OaCreateObject
(tokentype    *Anchor,    numtype       EnvObj,
ft F,lt Z,zz *Status,    tokentype    *Token);
boolean OaNewObject
(tokentype    *Anchor,    numtype       EnvObj,
ft F,lt Z,zz *Status,    indextype    *Index,
addrtype     *Object);
boolean OaGetObject
(tokentype    *Token,
ft F,lt Z,zz *Status,    addrtype     *Object);
boolean OaRevokeCppObject
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean OaInvokeCppObject
(tokentype    *Token,     addrtype      Object,
ft F,lt Z,zz *Status);
boolean OaUpdateObject
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean OaChkImage (tokentype    *Token,     ft F,lt Z,zz *Status);
boolean OaFreeObject
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean OaDeleteObject
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean OaGetObjHandles
(tokentype    *Anchor,    numtype       ObjNum,
ft F,lt Z,zz *Status,
indextype    *Count,     handletype  **Handles);
boolean OaReclaimHandles
(tokentype    *Anchor,    numtype       ObjNum,
ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\oa1.h*/

#ifndef OA1_H
#define OA1_H
typedef boolean (*p_create) (addrtype Object, addrtype *Foreign);
boolean OaIamA     (tokentype    *Token,     numtype       EnvObj,
ft F,lt Z,zz *Status);
boolean OaInitObject
(tokentype    *Token,     numtype       NumInits,
numtype      *AttrNums,  addrtype     *Values,
ft F,lt Z,zz *Status);
boolean OaCopy     (tokentype    *TokenA,    tokentype    *TokenB,
ft F,lt Z,zz *Status);
boolean OaGetDbObjNums
(int           TraceSwi,  tokentype    *Anchor,
ft F,lt Z,zz *Status);
boolean OaDelete   (tokentype    *Token,     ft F,lt Z,zz *Status);
boolean OaDeleteFields
(tokentype    *Token,     numtype       LocalObj,
objheader    *ObjHdr,    addrtype      Object,
ft F,lt Z,zz *Status);
boolean OaDeleteEmbedded
(tokentype    *Token,     numtype       LocalObj,
addrtype      Object,    ft F,lt Z,zz *Status);
boolean OaCreateArray
(tokentype    *DbmsToken, numtype       AttrNum,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype     *ArrayAddr);
boolean OaCreateVarray
(tokentype    *DbmsToken, numtype       AttrNum,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype     *ArrayAddr);
boolean OaPut      (boolean       CppType,   tokentype    *Token,
addrtype      Object,    numtype       EnvAttrNum,
addrtype      Value,     ft F,lt Z,zz *Status);
boolean OaPutString
(idtype        DbId,      objheader    *ObjHdr,
char         *String,
ft F,lt Z,zz *Status,    indextype    *StrIndex);
boolean OaPutToEmbedded
(tokentype    *Token,     numtype       SubClass,
numtype       AttrNum,   addrtype      Value,
ft F,lt Z,zz *Status);
boolean OaPutField
(tokentype    *Token,     fieldstruc   *FieldStruc,
addrtype      Value,     ft F,lt Z,zz *Status);
boolean OaGet      (boolean       CppType,   tokentype    *Token,
addrtype      Object,    numtype       EnvAttrNum,
ft F,lt Z,zz *Status,    addrtype      AttrValue);
boolean OaGetString
(idtype        DbId,      objheader    *ObjHdr,
indextype     StrIndex,
ft F,lt Z,zz *Status,    char        **String);
boolean OaGetField
(tokentype    *Token,     fieldstruc   *FieldStruc,
ft F,lt Z,zz *Status,    addrtype      Value);
boolean OaChkForAttr
(tokentype    *Token,     numtype       EnvAttrNum,
ft F,lt Z,zz *Status,
sizetype     *Size,      sizetype     *Offset);
boolean OaGetAttrSize
(tokentype    *Anchor,    numtype       EnvAttrNum,
ft F,lt Z,zz *Status,    addrtype      AttrSize);
boolean OaCompare  (boolean       CppType,   tokentype    *Token,
addrtype      Object,    numtype       EnvAttrNum,
addrtype      CompValue, ptr_cmp       CmpCode,
ft F,lt Z,zz *Status);
boolean OaCompareField
(boolean       CppType,   tokentype    *Token,
addrtype      Object,    fieldstruc   *FieldStruc,
addrtype      CompValue, ptr_cmp       CmpCode,
ft F,lt Z,zz *Status);
boolean OaDumpObjHdr
(int           TraceSwi,  tokentype    *Anchor,
num           ObjNum,    ft F,lt Z,zz *Status);
boolean OaDumpObjHndls
(tokentype    *Anchor,    numtype       ObjNum,
ft F,lt Z,zz *Status);
boolean OaDumpObject
(int           TraceSwi,  tokentype    *Token,
ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\env1.h*/

#ifndef ENV1_H
#define ENV1_H
typedef handletype   localobj;
typedef numtype      typenum;
typedef numtype      valuenum;
typedef numtype      attrnum;
typedef numtype      setnum;
typedef numtype      mtrxnum;
typedef numtype      nodenum;
typedef numtype      tuplenum;
typedef numtype      codenum;
typedef handletype   sethead;
typedef handletype   stackhead;
typedef handletype   setnode;
typedef tokentype    rowhead;
typedef tokentype    colhead;
typedef handletype   mtrxnode;
typedef handletype   envobj;
typedef handletype   typeobj;
typedef handletype   attrobj;
typedef handletype   codetype;
typedef handletype   slothandle;
typedef handletype   chunkhandle;
typedef struct EnvTypeDesc
{
handletype     Handle;
numtype        ObjNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
wordtype       FieldExtender01;
#endif
}              envdesc;
typedef  envdesc      envdesctype;
typedef struct Env0TypeDesc
{
handletype     Handle;
numtype        DbNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
numtype        DescNum;
numtype        Objects;
numtype        ObjCount;
numtype        TypeCount;
numtype        ValueCount;
numtype        AttrCount;
numtype        TraitCount;
numtype        SetCount;
numtype        MatrixCount;
numtype        TupleCount;
numtype        SlotCount;
numtype        SchemaCount;
numtype        ViewCount;
numtype        CodeCount;
numtype        ShellCount;
idtype         DbCount;
idtype         EnvId;
slottoken      PrimalSlotAttr;
codetype       SpclCreateCode;
codetype       SpclDeleteCode;
handletype     OwnerTraitsObjsFields;
handletype     OwnerRootTraitsObjs;
tokentype      OwnerParentsChilds;
handletype     OwnerCestorsCendents;
handletype     OwnerSchemasObjs;
handletype     OwnerRowsColsMatrices;
handletype     OwnerMembersOwnersSets;
sethead        RenvObjs;
sethead        RenvTraits;
sethead        RenvStrucs;
sethead        RenvAttrs;
sethead        RenvSets;
sethead        RenvTypes;
sethead        RenvValues;
sethead        RenvTuples;
sethead        RenvSlots;
sethead        RenvMatrices;
sethead        RenvSchemas;
sethead        RenvViews;
sethead        RenvShells;
sethead        RenvCodes;
sethead        RenvDescs;
sethead        RenvCodeDescs;
sethead        RenvNames;
}              renvobj;
typedef struct ObjTypeDesc
{
handletype     Handle;
numtype        ObjNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
numtype        DescNum;
desctype       DescType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
bytessize      ObjSize;
bytessize      PsudoSize;
numtype        CreateCodeCount;
handletype     BaseCreateCode;
chunkhandle    OvrlyCreateCodes;
codetype       DeleteCode;
codetype       GetCode;
codetype       PutCode;
chunkhandle    BasesAccess;
chunkhandle    RootsAccess;
chunkhandle    ClassFields;
chunkhandle    ClassOffsets;
chunkhandle    Fields;
chunkhandle    RootFields;
chunkhandle    Cestrs;
chunkhandle    RootCestrs;
chunkhandle    CestorsOfObj;
chunkhandle    CendentsOfObj;
chunkhandle    FriendsOfObj;
rowhead        RowHeadParentsChilds;
colhead        ColHeadParentsChilds;
sethead        OwnerObjParents;
setnode        MemberObjParents;
sethead        OwnerObjChilds;
setnode        MemberObjChilds;
sethead        OwnerObjAncestors;
setnode        MemberObjAncestors;
sethead        OwnerObjCendents;
setnode        MemberObjCendents;
sethead        OwnerObjSchemas;
sethead        OwnerRootTraits;
sethead        OwnerObjTraits;
sethead        OwnerObjRowHeads;
sethead        OwnerObjColHeads;
sethead        OwnerOwnerSets;
setnode        OwnerMemberSets;
setnode        OwnerObjSlots;
setnode        MemberTraitRootObjs;
setnode        MemberTraitObjs;
setnode        MemberSchemaObjs;
setnode        MemberViewObjs;
setnode        MemberRenvObjs;
setnode        MemberRenvDescs;
setnode        MemberRenvNames;
sethead        OwnerObjCodes;
setnode        MemberPortComponents;
sethead        OwnerComponentOfPorts;
}              objdesctype;
typedef struct PortTypeDesc
{
handletype     Handle;
numtype        ObjNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
numtype        DescNum;
desctype       DescType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
bytessize      ObjSize;
bytessize      PsudoSize;
numtype        CreateCodeCount;
handletype     BaseCreateCode;
chunkhandle    OvrlyCreateCodes;
codetype       DeleteCode;
codetype       GetCode;
codetype       PutCode;
chunkhandle    BasesAccess;
chunkhandle    RootsAccess;
chunkhandle    ClassFields;
chunkhandle    ClassOffsets;
chunkhandle    Fields;
chunkhandle    RootFields;
chunkhandle    Cestrs;
chunkhandle    RootCestrs;
chunkhandle    CestorsOfObj;
chunkhandle    CendentsOfObj;
chunkhandle    FriendsOfObj;
rowhead        RowHeadParentsChilds;
colhead        ColHeadParentsChilds;
sethead        OwnerObjParents;
setnode        MemberObjParents;
sethead        OwnerObjChilds;
setnode        MemberObjChilds;
sethead        OwnerObjAncestors;
setnode        MemberObjAncestors;
sethead        OwnerObjCendents;
setnode        MemberObjCendents;
sethead        OwnerObjSchemas;
sethead        OwnerRootTraits;
sethead        OwnerObjTraits;
sethead        OwnerObjRowHeads;
sethead        OwnerObjColHeads;
sethead        OwnerOwnerSets;
setnode        OwnerMemberSets;
setnode        OwnerObjSlots;
setnode        MemberTraitRootObjs;
setnode        MemberTraitObjs;
setnode        MemberSchemaObjs;
setnode        MemberViewObjs;
setnode        MemberRenvObjs;
setnode        MemberRenvDescs;
setnode        MemberRenvNames;
sethead        OwnerObjCodes;
sethead        OwnerPortComponents;
setnode        MemberPortComponents;
sethead        OwnerComponentOfPorts;
setnode        MemberComponentOfPorts;
sethead        OwnerPortRefAttrs;
}              portdesctype;
typedef struct BaseTypeTypeDesc
{
handletype     Handle;
typenum        TypeNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
char           AliasNam[MAXNAME];
numtype        DescNum;
typetype       TypeType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
bytessize      Size;
valueclasstype ValueClass;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender03;
#endif
#ifdef STRUC_ALIGN_BY64
wordtype       FieldExtender08;
#endif
}              typebasetype;
typedef struct TypeIntegerTypeDesc
{
handletype     Handle;
typenum        TypeNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
char           AliasNam[MAXNAME];
numtype        DescNum;
typetype       TypeType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
bytessize      Size;
valueclasstype ValueClass;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender03;
#endif
boolean        aSigned;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender04;
#endif
codetype       GetCode;
codetype       PutCode;
codetype       CompareCode;
sethead        OwnerTypeAttrs;
setnode        MemberRenvTypes;
setnode        MemberRenvDescs;
setnode        MemberRenvNames;
#ifdef STRUC_ALIGN_BY64
wordtype       FieldExtender05;
#endif
}              integerdesctype;
typedef struct TypeChunkTypeDesc
{
handletype     Handle;
typenum        TypeNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
char           AliasNam[MAXNAME];
numtype        DescNum;
typetype       TypeType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
bytessize      Size;
valueclasstype ValueClass;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender03;
#endif
typeobj        TypeObj;
bytessize      UnitSize;
codetype       GetCode;
codetype       PutCode;
codetype       CompareCode;
sethead        OwnerTypeAttrs;
setnode        MemberRenvTypes;
setnode        MemberRenvDescs;
setnode        MemberRenvNames;
}              chunkdesctype;
typedef struct TypeEnumTypeDesc
{
handletype     Handle;
typenum        TypeNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
char           AliasNam[MAXNAME];
numtype        DescNum;
typetype       TypeType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
bytessize      Size;
valueclasstype ValueClass;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender03;
#endif
numtype        MaxValue;
slothandle     EnumSlotAttr;
codetype       GetCode;
codetype       PutCode;
codetype       CompareCode;
sethead        OwnerTypeAttrs;
sethead        OwnerEnumValues;
setnode        MemberRenvTypes;
setnode        MemberRenvDescs;
setnode        MemberRenvNames;
#ifdef STRUC_ALIGN_BY64
wordtype       FieldExtender05;
#endif
}              enumdesctype;
typedef struct TypeValueTypeDesc
{
handletype     Handle;
valuenum       ValueNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
numtype        DescNum;
numtype        Value;
setnode        MemberEnumValues;
setnode        MemberRenvValues;
setnode        MemberRenvDescs;
setnode        MemberRenvNames;
#ifdef STRUC_ALIGN_BY64
wordtype       FieldExtender05;
#endif
}              valuedesctype;
typedef struct AttrTypeDesc
{
handletype     Handle;
attrnum        AttrNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
numtype        DescNum;
numtype        TraitNum;
typetype       TypeType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
attrtype       AttrType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender03;
#endif
cppattrtype    CppType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender04;
#endif
valueclasstype ValueClass;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender05;
#endif
dbmsstring     DefaultValue;
typeobj        TypeObj;
sizetype       UnitSize;
codetype       GetCode;
codetype       PutCode;
codetype       SpclCompareCode;
handletype     BuildDesc;
setnode        MemberRootTraits;
setnode        MemberObjTraits;
setnode        MemberTypeAttrs;
sethead        OwnerKeySets;
sethead        OwnerTraitRootObjs;
sethead        OwnerTraitObjs;
setnode        MemberStrucAttrs;
sethead        OwnerAttrStrucs;
setnode        MemberRenvTraits;
setnode        MemberRenvAttrs;
setnode        MemberRenvDescs;
setnode        MemberRenvNames;
}              attrdesctype;
typedef struct SetTypeDesc
{
handletype     Handle;
setnum         SetNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
numtype        DescNum;
settype        SetType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
setheadtype    SetHeadType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender03;
#endif
attrnum        OwnerAttrNum;
attrnum        MemberAttrNum;
bytessize      LinkSize;
numtype        NodeObjNum;
envobj         Owner;
envobj         Member;
attrnum        PrimaryKey;
attrnum        Key2ary;
handletype     OwnersMembersNodeLink;
codetype       SpclCompareCode;
setnode        MemberOwnerSets;
setnode        MemberMemberSets;
setnode        MemberKeySets;
setnode        MemberRenvSets;
setnode        MemberRenvDescs;
setnode        MemberRenvNames;
}             setdesctype;
typedef struct lSetHeadTypeDesc
{
handletype     Handle;
handletype     BuildDesc;
envobj         lOwnerObject;
envobj         lFirstLink;
envobj         lLastLink;
chunkhandle    RootNodes;
sizetype       KeySize;
typetype       KeyType;
idtype         AnchorDbId;
numtype        SetKeysDir;
}             lsetheaddesc;
typedef  lsetheaddesc lsetheaddesctype;
typedef struct gSetHeadTypeDesc
{
handletype     Handle;
handletype     BuildDesc;
envobj         lOwnerObject;
envobj         lFirstLink;
envobj         lLastLink;
chunkhandle    RootNodes;
sizetype       KeySize;
typetype       KeyType;
idtype         AnchorDbId;
numtype        SetKeysDir;
}             gsetheaddesc;
typedef  gsetheaddesc gsetheaddesctype;
typedef struct lSetNodeTypeDesc
{
handletype     Handle;
envobj         lOwnerObject;
envobj         lPrevLink;
envobj         lNextLink;
envobj         lMemberObject;
#ifdef STRUC_ALIGN_BY64
wordtype       FieldExtender05;
#endif
}             lsetnodedesc;
typedef  lsetnodedesc lsetnodedesctype;
typedef struct gSetNodeTypeDesc
{
handletype     Handle;
envobj         lOwnerObject;
envobj         lPrevLink;
envobj         lNextLink;
tokentype      gMemberObject;
#ifdef STRUC_ALIGN_BY64
wordtype       FieldExtender05;
#endif
}             gsetnodedesc;
typedef  gsetnodedesc gsetnodedesctype;
typedef struct TypeLsMatrix
{
handletype            Handle;
numtype               MatrixNum;
char                  Nam[MAXNAME];
envclass              EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
numtype               DescNum;
matrixtype            MatrixType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
matrixheadtype        MatrixHeadType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender03;
#endif
numtype               OwnerAttrNum;
handletype            Owner;
handletype            RowsColsNodeLink;
linknodetype          LinkNodeType;
numtype               LinkNodeObjNum;
boolean               LinkNodeIsDepend;
handletype            RowHeadOwner;
numtype               RowHeadAttrNum;
handletype            RowHeadSetDesc;
numtype               RowHeadKey;
handletype            ColHeadOwner;
numtype               ColHeadAttrNum;
handletype            ColHeadSetDesc;
numtype               ColHeadKey;
handletype            RowSetOwner;
numtype               RowSetAttrNum;
handletype            RowSetSetDesc;
numtype               RowSetKey;
handletype            ColSetOwner;
numtype               ColSetAttrNum;
handletype            ColSetSetDesc;
numtype               ColSetKey;
memberhandle          MemberObjRowHeads;
memberhandle          MemberObjColHeads;
handletype            MemberRenvMatrices;
memberhandle          MemberRenvDescs;
setnode               MemberRenvNames;
#ifdef STRUC_ALIGN_BY64
wordtype       FieldExtender05;
#endif
}  LsMatrix;
typedef  LsMatrix     lsmatrixtype;
typedef struct TypelMatrixHead
{
handletype            Handle;
tokentype             OwnerObject;
handletype            lRowHead;
handletype            lColHead;
#ifdef STRUC_ALIGN_BY64
wordtype       FieldExtender05;
#endif
}  lMatrixHead;
typedef lMatrixHead   lmatrixheadtype;
typedef struct TupleTypeDesc
{
handletype     Handle;
attrnum        TupleNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
numtype        DescNum;
tupletype      TupleType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
sethead        OwnerTupleSlots;
setnode        MemberRenvTuples;
setnode        MemberRenvDescs;
setnode        MemberRenvNames;
slothandle     TupleSlotAttr;
}              tupledesctype;
typedef struct SlotTypeDesc
{
handletype     Handle;
attrnum        SlotNum;
char           Nam[MAXNAME];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
numtype        DescNum;
slottype       SlotType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
dependtype     DependType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender03;
#endif
setnode        MemberObjSlots;
sethead        MemberTupleSlots;
setnode        MemberRenvSlots;
setnode        MemberRenvDescs;
setnode        MemberRenvNames;
#ifdef STRUC_ALIGN_BY64
wordtype       FieldExtender08;
#endif
}              slotdesctype;
typedef struct TypeCodeTypeDesc
{
handletype     Handle;
codenum        CodeNum;
char           Nam[32];
envclass       EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
numtype        DescNum;
setnode        MemberRenvCodes;
setnode        MemberRenvDescs;
setnode        MemberRenvCodeDescs;
setnode        MemberRenvNames;
setnode        MemberObjCodes;
char           PathName[32];
codetypetype   CodeType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
cppattrtype    CppQual;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender03;
#endif
handletype     ReturnTypeHndl;
argclasstype   ReturnClass;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender04;
#endif
argqualtype    ReturnQual;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender05;
#endif
sizetype       ReturnSize;
numtype        ArgCount;
sizetype       ArgListSize;
sethead        OwnerCodeArgs;
}              codedesctype;
typedef struct TypeArgTypeDesc
{
handletype     Handle;
char           Nam[32];
numtype        ArgNum;
handletype     ArgTypeHndl;
argclasstype   ArgClass;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
argqualtype    ArgQual;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender02;
#endif
bytessize      ArgListOffset;
setnode        MemberCodeArgs;
}              argdesctype;
typedef struct TypeRschema
{
handletype       Handle;
numtype          SchemaNum;
char             Nam[32];
envclass         EnvType;
#ifdef TWOBYTE_BOOL
twobytetype    FieldExtender01;
#endif
handletype       SchemaPrimalDesc;
chunkhandle      ObjsOfSchema;
slottoken        RschemaSlotAttr;
ownerhandle      OwnerSchemaObjs;
memberhandle     MemberRenvSchemas;
memberhandle     MemberShellSchemas;
#ifdef STRUC_ALIGN_BY64
wordtype       FieldExtender05;
#endif
}  rschematype;
typedef struct TypeWschema
{
handletype       Handle;
slottoken        WschemaSlotAttr;
memberhandle     MemberObjSchemas;
ownerhandle      OwnerSchemaDbs;
#ifdef STRUC_ALIGN_BY64
wordtype       FieldExtender05;
#endif
}  wschematype;

typedef struct TypeVarray
{
tokentype             VchunkTkn;
indextype             Vsize;
addrtype              Varray;
}  varraytype;


char   *HeadNam[14] = {"lSetHead",           "gSetHead",
"lKeyedSetHead",      "gKeyedSetHead",
"lKeyed2arySetHead",  "gKeyed2arySetHead",
"lTableSetHead",      "gTableSetHead",
"lTreeSetHead",       "gTreeSetHead",
"IndexedSetHead",     "SpclSetHead",
"lSetNode",           "gSetNode"     };
num          HeadObjNum[14];
bytessize    HeadObjSize[14];
num          NumHeadTypes = 14;
numtype      Obj0Count                = 84;
varraytype   NullVarray   = {{0,0,0}, 0, NullPtr};
vchunktype   NullVchunk   = {{0,0,0}, 0, NullPtr, 0};

boolean EnvNewDbHdr   (tokentype    *SchemaTkn, numtype       PrimalObj,
char         *DbName,    char         *NewFileName,
dbaccesstype  DbAccess,  indextype     AllocObjs,
indextype     AllocAttrs,
ft F,lt Z,zz *Status,    tokentype    *DbPrimal);
boolean EnvNewObjDesc (tokentype    *Anchor,    desctype      ObjDescType,
ft F,lt Z,zz *Status,
objdesctype **ObjDesc,   tokentype    *Token);
boolean EnvFetchObjNum(tokentype    *ObjTkn,
ft F,lt Z,zz *Status,    numtype      *ObjNum);
boolean EnvFetchObjHandle
(numtype       ObjNum,
ft F,lt Z,zz *Status,    handletype   *ObjHandle);
boolean EnvPairObjHandle
(numtype       ObjNum,    handletype    ObjHandle,
ft F,lt Z,zz *Status);
boolean EnvFetchObjSize
(numtype       ObjNum,
ft F,lt Z,zz *Status,    bytessize    *SizeInBytes);
boolean EnvFetchObjName
(numtype       ObjNum,
ft F,lt Z,zz *Status,    char         *ObjName);
boolean EnvFetchClassSize
(numtype       ObjNum,
ft F,lt Z,zz *Status,    size_t       *ClassSize);
boolean EnvFetchLastObjCount
(ft F,lt Z,zz *Status,    numtype      *ObjCount);
boolean EnvFetchObjCestrs
(numtype       ObjNum,
ft F,lt Z,zz *Status,    tokentype    *ObjCestors);
boolean Env_FetchObjCendents
(numtype       ObjNum,
ft F,lt Z,zz *Status,    tokentype    *ObjCendents);
boolean EnvFetchSchemaObjs
(numtype       ObjNum,
ft F,lt Z,zz *Status,    tokentype    *SchemaObjs);
boolean DeleteObjDesc (tokentype    *Token,     ft F,lt Z,zz *Status);
boolean EnvNewObjHdr  (tokentype    *Anchor,    numtype       EnvObjNum,
indextype     AllocQty,  ft F,lt Z,zz *Status);
boolean EnvBldObjHdr  (tokentype    *Anchor,    numtype       EnvObjNum,
indextype     AllocQty,  ft F,lt Z,zz *Status,
numtype      *FieldNumMap,
chunknum     *FieldOffsetDir,
chunknum     *ClassOffsetDir,
indextype   **FieldCount,
chunknum     *LocalAttrNumMap,
indextype   **FieldRefCount,
chunknum     *FieldRefDir);
boolean InstallObjChunks
(tokentype    *Anchor,    objheader    *ObjHdr,
numtype       EnvObjNum, ft F,lt Z,zz *Status);
boolean EnvInstallObjHdr
(tokentype    *Anchor,    numtype       EnvObjNum,
ft F,lt Z,zz *Status,    numtype      *LocalObj);
boolean EnvBldObjImage
(dbheader     *CoreDb,    objheader    *ObjHdr,
ft F,lt Z,zz *Status,    numtype      *FieldChunk,
numtype      *OffsetChnk,indextype    *FieldCount);
boolean CppEnvGetThatTkn
(addrtype      CppObject, numtype       ObjNum,
ft F,lt Z,zz *Status,    tokentype   **CppToken);
boolean EnvInstallAttr
(handletype    AttrHndl,  numtype       EnvAttrNum,
bytessize     Size,      ft F,lt Z,zz *Status);
boolean EnvFetchLocalAttrNum
(tokentype    *Anchor,    numtype       EnvAttrNum,
ft F,lt Z,zz *Status,    numtype      *LocalAttrNum);
boolean EnvFetchAttrHandle
(numtype       AttrNum,
ft F,lt Z,zz *Status,    handletype   *AttrHandle);
boolean EnvFetchAttrSize
(numtype       AttrNum,
ft F,lt Z,zz *Status,    sizetype     *AttrSize);
boolean EnvFetchAttrOffset
(tokentype    *ObjTkn,    numtype       AttrNum,
objheader    *ObjHdr,    numtype       FieldNum,
ft F,lt Z,zz *Status,    sizetype     *Offset);
boolean Env_FetchObj0AttrOffset
(numtype       MemLoc,    numtype       AttrNum,
objheader    *ObjHdr,
ft F,lt Z,zz *Status,    sizetype     *Offset);
boolean Env_FetchObjAttrOffset
(numtype       MemLoc,
numtype       ObjNum,    numtype       AttrNum,
ft F,lt Z,zz *Status,    sizetype     *Offset);
boolean Env_FetchObjAttrSpec
(numtype       ObjNum,    numtype       AttrId,
ft F,lt Z,zz *Status,    attrtype     *AttrType,
numtype      *RefObjNum, envclass     *RefEnvType,
sizetype     *UnitSize,  typetype     *UnitType,
valueclass   *ValueType, sizetype     *Offset);
boolean Env_FetchFieldOffset
(tokentype    *ObjTkn,      fieldspec     FieldTkns[],
numtype       SubLevel,    ft F,lt Z,zz *Status,
sizetype     *FieldSize,   sizetype     *Offset);
boolean Env_FetchObjFieldSpec
(numtype       ObjNum,    fieldspec     FieldTkns[],
numtype       SubLevel,
ft F,lt Z,zz *Status,    sizetype     *FieldSize,
numtype      *AttrId,    attrtype     *AttrType,
numtype      *RefObjNum, typetype     *FieldType,
sizetype     *Offset,    sizetype     *BaseOffset);
boolean EnvFetchOffsetMap
(tokentype    *ObjTkn,    objheader    *ObjHdr,
ft F,lt Z,zz *Status,    typesize     *MapSize,
numtype      *OffsetMap, indextype    *Inset);
boolean EnvInitCodes  (ft F,lt Z,zz *Status);
boolean EnvMakeCodeChunks
(ft F,lt Z,zz *Status);
boolean EnvPairCode   (numtype       CodeNum,   funcptrtype   CodeAddr,
ft F,lt Z,zz *Status);
boolean EnvFetchCode  (numtype       CodeNum,
ft F,lt Z,zz *Status,    funcptrtype  *CodeAddr);
void    EnvAlignMember
(attrtype      AttrType,  typetype      TypeType,
sizetype      Size,      sizetype     *Offset);
void    EnvAlignStruc
(boolean       DblAlign,  boolean       AddrAlign,
sizetype     *Offset);
#ifdef ENV1_C
boolean TestEnv0      (ft F,lt Z,zz *Status);
boolean CreateObjDesc (tokentype    *Anchor,    ft F,lt Z,zz *Status,
objdesctype **ObjDesc,   tokentype    *Token);
#endif
#endif
/* 当前文件是./CINT2000\255.vortex\src\dba.h*/

#ifndef DBA_H
#define DBA_H
boolean Dbm_CreateDb (tokentype    *SchemaTkn, numtype       PrimalObj,
char         *DbName,    char         *NewFileName,
dbaccesstype  DbAccess,  indextype     AllocObjs,
indextype     AllocAttrs,
ft F,lt Z,zz *Status,    tokentype    *DbPrimal);
boolean Dbm_DeCacheDbs
(ft F,lt Z,zz *Status);
#endif
#ifndef INLINE_OMIDEFS
/* 当前文件是./CINT2000\255.vortex\src\omidefs.h*/

#ifndef OMIDEFS_H
#define OMIDEFS_H
#define        Alloc_RootSlots        (indextype  )50
#define        Alloc_Primals          (indextype  )1
#define        Alloc_Descs            (indextype  )600
#define        ObjDesc_ObjNum         (objnumtype )1
#define        Primal_ObjNum          (objnumtype )25
#define        Renv0_ObjNum           (objnumtype )26
#define        SetHead_ObjNum         (objnumtype )69
#define        lSetHead_ObjNum        (objnumtype )70
#define        gSetHead_ObjNum        (objnumtype )71
#define        lKeyedSetHead_ObjNum   (objnumtype )73
#define        gKeyedSetHead_ObjNum   (objnumtype )74
#define        lKeyed2arySetHead_ObjNum   (objnumtype )76
#define        gKeyed2arySetHead_ObjNum   (objnumtype )77
#define        lTableSetHead_ObjNum   (objnumtype )79
#define        gTableSetHead_ObjNum   (objnumtype )80
#define        lTreeSetHead_ObjNum    (objnumtype )81
#define        gTreeSetHead_ObjNum    (objnumtype )82
#define        Node_ObjNum            (objnumtype )83
#define        lSetNode_ObjNum        (objnumtype )85
#define        gSetNode_ObjNum        (objnumtype )86
#define        lTableNode_ObjNum      (objnumtype )111
#define        LsMatrix_ObjNum        (objnumtype )120
#define        Wschema_ObjNum         (objnumtype )139
#define        Db_ObjNum              (objnumtype )141
#define        CodeDesc_ObjNum        (objnumtype )145
#ifndef ENVDEFS_H
#define        Image01_ObjNum         (objnumtype )149
#endif
#define        lKeyHead_ObjNum        (objnumtype )157
#define        MtrxHead_ObjNum        (objnumtype )158
#ifndef ENVDEFS_H
#define        That_AttrNum               (numtype )1
#define        Token_Attr                 (numtype )2
#define        Handle_AttrNum             (numtype )2
#define        DbId_AttrNum               (numtype )3
#define        CoreDbId_AttrNum           (numtype )4
#define        ObjNum_AttrNum             (numtype )5
#endif
#define        AttrNum_AttrNum            (numtype )9
#define        CodeNum_AttrNum            (numtype )17
#define        DbNum_AttrNum              (numtype )18
#define        Nam_AttrNum                (numtype )19
#define        EnvType_AttrNum            (numtype )20
#define        DescNum_AttrNum            (numtype )22
#define        DbCount_AttrNum            (numtype )38
#define        SetHeadType_AttrNum        (numtype )44
#define        OwnerAttrNum_AttrNum       (numtype )61
#define        MemberAttrNum_AttrNum      (numtype )62
#define        PrimaryKey_AttrNum         (numtype )64
#define        AccessRights_AttrNum       (numtype )70
#define        BaseCreateCode_AttrNum     (numtype )72
#define        lOwnerObject_AttrNum       (numtype )88
#define        lFirstLink_AttrNum         (numtype )89
#define        gFirstLink_AttrNum         (numtype )90
#define        lLastLink_AttrNum          (numtype )91
#define        gLastLink_AttrNum          (numtype )92
#define        lPrevLink_AttrNum          (numtype )93
#define        gPrevLink_AttrNum          (numtype )94
#define        lNextLink_AttrNum          (numtype )95
#define        gNextLink_AttrNum          (numtype )96
#define        lMemberObject_AttrNum      (numtype )97
#define        gMemberObject_AttrNum      (numtype )98
#ifndef ENVDEFS_H
#define        Id_AttrNum                 (numtype )144
#endif
#define        RootNodes_AttrNum          (numtype )156
#define        DbAccessType_AttrNum       (numtype )157
#define        SchemaPrimalDesc_AttrNum   (numtype )158
#define        DbFileName_AttrNum         (numtype )159
#define        ObjsOfSchema_AttrNum       (numtype )160
#define        OwnerWenvDbs_AttrNum       (numtype )253
#define        DbSlotAttr_AttrNum         (numtype )267
#define        PrimalSlotAttr_AttrNum     (numtype )268
#define        RschemaSlotAttr_AttrNum    (numtype )269
#define        WschemaSlotAttr_AttrNum    (numtype )270
#define        DbPrimal_Index         (indextype  )0
#define        ObjDesc_Index          (indextype  )1
#define        DbPrimal_Class         (word       )0
#define        ObjDesc_Class          (numtype    )1
#define        ObjDesc_Hndl           (handletype )3
#define        ArgDesc_Hndl           (handletype )149
#define        StatusType_Hndl        (handletype )181
#define        AddrType_Hndl          (handletype )184
#define        ReferenceType_Hndl     (handletype )197
#define        ObjTraits_Hndl         (handletype )681
#define        EnumValues_Hndl        (handletype )688
#define        TraitObjs_Hndl         (handletype )691
#define        RenvObjs_Hndl          (handletype )697
#define        RenvTraits_Hndl        (handletype )698
#define        RenvStrucs_Hndl        (handletype )699
#define        RenvAttrs_Hndl         (handletype )700
#define        RenvSets_Hndl          (handletype )701
#ifndef ENVDEFS_H
#define        RenvTypes_Hndl         (handletype )702
#endif
#define        RenvValues_Hndl        (handletype )703
#define        RenvTuples_Hndl        (handletype )704
#define        RenvSlots_Hndl         (handletype )705
#define        RenvMatrices_Hndl      (handletype )706
#define        RenvSchemas_Hndl       (handletype )707
#define        RenvViews_Hndl         (handletype )708
#define        RenvShells_Hndl        (handletype )709
#define        RenvCodes_Hndl         (handletype )710
#define        RenvDescs_Hndl         (handletype )711
#define        RenvCodeDescs_Hndl     (handletype )712
#define        RenvNames_Hndl         (handletype )713
#define        ObjCodes_Hndl          (handletype )714
#define        WenvDbs_Hndl           (handletype )715
#define        SchemaDbs_Hndl         (handletype )716
#define        ApiPortObjs_Hndl       (handletype )718
#define        Env01_BadDescTypeType                2005
#define        Code_ForeignNotCreate               14000
#endif
#else
#define        Primal_ObjNum          (objnumtype )25
#define        lSetHead_ObjNum        (objnumtype )63
#define        Wschema_ObjNum         (objnumtype )132
#define        Db_ObjNum              (objnumtype )134
#define        DbId_AttrNum           (numtype )3
#define        CoreDbId_AttrNum       (numtype )4
#define        ObjNum_AttrNum         (numtype )5
#define        DbNum_AttrNum          (numtype )18
#define        Nam_AttrNum            (numtype )19
#define        EnvType_AttrNum        (numtype )20
#define        DbCount_AttrNum        (numtype )38
#define        AccessRights_AttrNum   (numtype )70
#define        DbAccessType_AttrNum       (numtype )156
#define        DbFileName_AttrNum         (numtype )158
#define        ObjsOfSchema_AttrNum       (numtype )159
#define        OwnerWenvDbs_AttrNum       (numtype )247
#define        DbSlotAttr_AttrNum         (numtype )263
#define        PrimalSlotAttr_AttrNum     (numtype )264
#define        RschemaSlotAttr_AttrNum    (numtype )265
#define        WschemaSlotAttr_AttrNum    (numtype )266
#define        RenvSchemas_Hndl       (handletype )684
#define        WenvDbs_Hndl           (handletype )692
#define        SchemaDbs_Hndl         (handletype )693
#endif








renvobj     *Env0                   = NullPtr;
numtype      CodeDirChunk           = 0;
numtype      ObjClassMap            = 0;
numtype      PortVindexDir          = 0;
numtype      PortMapDir             = 0;
handletype   CodeArgs_Hndl          = 0;
cppattrtype  CurrentCppQual         = aPublic;
#define MemPutObjNum        Mem_PutWord
#define MemGetObjNum        Mem_GetWord
#define MemPushObjNum       Mem_PushWord
#define MemPushObjHdr       Mem_PushAddr
boolean    DbmCreateDb   (tokentype    *SchemaTkn,   numtype      PrimalObjNum,
char         *DbName,
char         *NewFileName, dbaccesstype DbAccess,
indextype     AllocObjs,   indextype    AllocAttrs,
ft F,lt Z,zz *Status,      tokentype   *DbPrimalTkn)
{
indextype  StackPtr        = 0;
dbheader  *DbHdr           = NullPtr;
idtype     EnvId           = 0;
idtype     NewId           = 0;
statustype DumpStatus      = Env_Normal;
tokentype  Anchor;
tokentype  DbTkn;
envclass   EnvType         = aEnvDb;
int        TmpDeBug        = DeBug;
handletype SetHeadHndl     = 0;
tokentype  RschemaTkn;
tokentype  WschemaTkn;
tokentype  NodeTkn;
tokentype  CurrNodeTkn;
numtype    CurrObj         = 0;
numtype    NextObj         = 0;
tokentype  ObjTkn;
numtype    ObjNum          = 0;
numtype    LocalObjNum     = 0;
tokentype  RenvDbTkn;
time_t     Tod             = 0;
tokentype  BitFieldTkn;
time (&Tod);
NodeTkn.DbId            = RenvTkn.DbId;
CurrNodeTkn.DbId        = RenvTkn.DbId;
ObjTkn.DbId             = RenvTkn.DbId;
RschemaTkn.DbId         = RenvTkn.DbId;
RenvDbTkn.DbId          = WenvTkn.DbId;
DbTkn.DbId              = WenvTkn.DbId;
WschemaTkn.DbId         = WenvTkn.DbId;
EnvId               = ++Env0->DbCount;
if (!Create_Wenv)
{
if (KernelGetAttr   (&WenvTkn,       DbCount_AttrNum,
McStat,        (addrtype )&NewId))
{
NewId++;
EnvId        = (idtype )NewId;
CoreDbCount  = EnvId;
}
} else {
CoreDbCount      = WenvId;
NewId            = WenvId;
}
TraceMsg (0, " CREATE  Db Header and Db Primal  ... \n");
if (Normal(*Status))
if (HmMakeDbHdr (AllocObjs, AllocAttrs, NewId, McStat, &DbHdr))
{
DbHdr->DbId         = EnvId;
DbHdr->LocalAccess  = DbAccess;
DbHdr->DiskCache    = False;
if (NewId == PrimalId)
DbHdr->DiskCache = True;
DbHdr->SchemaHndl   = SchemaTkn->Handle;
CoreDbs[EnvId]      = DbHdr;
Anchor.Handle       = NullHandle;
Anchor.DbId         = EnvId;
Anchor.CoreDbId     = EnvId;
strcpy ((CoreDbs[EnvId])->DbFileName, NewFileName);
sprintf (Msg, "  NEW DB [%2u] Created.\n",
EnvId);
TraceMsg (0, Msg);
if (Normal(*Status))
if (MemPushObjNum (CoreDbs[EnvId]->ObjNumMap,     NullObjNum,
McStat,                       &StackPtr))
if (EnvId != RenvId)
{
if (ClassBug)
if (sprintf (Msg, "  Time Stamp %x : %s\n", Tod, ctime(&Tod)))
TraceMsg (0, Msg);
MemPushLong   (CoreDbs[EnvId]->ObjTimeStampDir,
(longwordtype )Tod,
McStat,                       &StackPtr);
}
if (Normal(*Status))
if (MemPushObjHdr (CoreDbs[EnvId]->ObjHdrDir,     NullPtr,
McStat,                       &StackPtr))
MemPushObjNum (CoreDbs[EnvId]->ObjVbnDir,     NullPtr,
McStat,                       &StackPtr);
if (Normal(*Status))
if (MemPushObjNum (CoreDbs[EnvId]->ObjNumMap,     PrimalObjNum,
McStat,                       &LocalObjNum))
if (EnvId != RenvId)
MemPushLong   (CoreDbs[EnvId]->ObjTimeStampDir,
(longwordtype )Tod,
McStat,                       &StackPtr);
if (Normal(*Status))
if (MemPushObjHdr (CoreDbs[EnvId]->ObjHdrDir,     NullPtr,
McStat,                       &StackPtr))
if (MemPushObjNum (CoreDbs[EnvId]->ObjVbnDir,     NullPtr,
McStat,                       &StackPtr))
if (MemPutObjNum  (CoreDbs[EnvId]->LocalObjNumMap, PrimalObjNum,
LocalObjNum,                   McStat))
CoreDbs[EnvId]->LocalObjCount++;
if (Normal(*Status))
if (TraceMsg (1, "  CREATE Primal Object OF This Db ...\n"))
if (OaCreateObject  (&Anchor,         PrimalObjNum,
McStat,          DbPrimalTkn))
{
if (EnvId == WenvId)
if (TraceMsg (1, "  CREATE the RENV DB Object ...\n"))
if (OaCreateObject   (&WenvTkn,    Db_ObjNum,
McStat,     &RenvDbTkn))
if (OaPut        (False,          &RenvDbTkn,         PtrToVoid,
DbId_AttrNum,
(addrtype )&RenvId,                     McStat))
if (OaPut        (False,          &RenvDbTkn,         PtrToVoid,
CoreDbId_AttrNum,
(addrtype )&RenvId,                     McStat))
if (OaPut        (False,          &RenvDbTkn,         PtrToVoid,
Nam_AttrNum,    (addrtype )RenvNam,     McStat))
if (OaPut        (False,          &RenvDbTkn,         PtrToVoid,
DbSlotAttr_AttrNum,
(addrtype )&RenvTkn.Handle,         McStat))
if (OaPut        (False,          &RenvDbTkn,         PtrToVoid,
DbFileName_AttrNum,
(addrtype )RenvFileName,                McStat))
if (OaPut        (False,          &RenvDbTkn,         PtrToVoid,
DbAccessType_AttrNum,
(addrtype )&RenvDbAccess,               McStat))
if (OaPut        (False,          &RenvDbTkn,         PtrToVoid,
AccessRights_AttrNum,
(addrtype )&RenvDbAccess,                McStat))
if (DeBug)
OaDumpObject (0,              &RenvDbTkn,        Dump_Status);
if (Normal(*Status))
if (TraceMsg (1, "  CREATE a new DB Object in Wenv ... \n"))
if (OaCreateObject
(&WenvTkn,        Db_ObjNum,
McStat,         &DbTkn))
if (OaPut        (False,          &DbTkn,             PtrToVoid,
DbId_AttrNum,   (addrtype )&EnvId,      McStat))
if (OaPut        (False,          &DbTkn,             PtrToVoid,
CoreDbId_AttrNum,
(addrtype )&EnvId,                      McStat))
if (OaPut        (False,          &DbTkn,             PtrToVoid,
Nam_AttrNum,
(addrtype )DbName,                      McStat))
if (OaPut        (False,          &DbTkn,             PtrToVoid,
DbSlotAttr_AttrNum,
(addrtype )DbPrimalTkn,             McStat))
if (OaPut        (False,          &DbTkn,             PtrToVoid,
DbFileName_AttrNum,
(addrtype )NewFileName,                 McStat))
if (OaPut        (False,          &DbTkn,             PtrToVoid,
DbAccessType_AttrNum,       (addrtype )&DbAccess,
McStat))
if (OaPut        (False,          &DbTkn,             PtrToVoid,
AccessRights_AttrNum,       (addrtype )&DbAccess,
McStat))
if (TraceMsg     (1,
"  Pair the Db object in Wenv with  Primal object IN New Db... \n"))
if (OaPut        (False,          &DbTkn,             PtrToVoid,
DbSlotAttr_AttrNum,
(addrtype )DbPrimalTkn,             McStat))
if (TraceMsg     (1,
"  Pair the new Primal object with the Db object IN Wenv... \n"))
if (OaPut        (False,           DbPrimalTkn,       PtrToVoid,
PrimalSlotAttr_AttrNum,
(addrtype )&DbTkn.Handle,           McStat))
if (DeBug)
OaDumpObject (0,              &DbTkn,            Dump_Status);
if (Normal(*Status))
if (WenvId == EnvId)
if (OaPut        (False,           DbPrimalTkn,       PtrToVoid,
DbNum_AttrNum,   (addrtype )&WenvId,    McStat))
if (OaPut        (False,           DbPrimalTkn,       PtrToVoid,
Nam_AttrNum,     (addrtype )WenvNam,    McStat))
if (OaPut        (False,           DbPrimalTkn,       PtrToVoid,
EnvType_AttrNum, (addrtype )&EnvType,   McStat))
if (OaPut        (False,           DbPrimalTkn,       PtrToVoid,
PrimalSlotAttr_AttrNum,
(addrtype )&DbTkn.Handle,           McStat))
if (TraceMsg     (1,
"   Get the Rschema object and PAIR with Wschema object...\n"))
if (SetFirstOf     (RenvSchemas_Hndl, &RenvTkn,        McStat,
&NodeTkn,         &RschemaTkn))
if (OaCreateObject (&WenvTkn,          Wschema_ObjNum,
McStat,           &WschemaTkn))
if (OaPut          (False,            &RschemaTkn,      PtrToVoid,
RschemaSlotAttr_AttrNum,    (addrtype )&WschemaTkn,
McStat))
if (OaPut          (False,            &WschemaTkn,      PtrToVoid,
WschemaSlotAttr_AttrNum,    (addrtype )&RschemaTkn,
McStat))
if (DeBug)
if (OaDumpObject   (0,                &RschemaTkn,   Dump_Status))
OaDumpObject   (0,                &WschemaTkn,   Dump_Status);
CurrNodeTkn.Handle = NodeTkn.Handle;
if (Normal(*Status) &&  WenvId == EnvId)
if (TraceMsg       (1,
"   Make a Schema Object and PAIR with RENV Schema...\n"))
if (SetNextOf      (RenvSchemas_Hndl, &CurrNodeTkn,   McStat,
&NodeTkn,         &RschemaTkn))
if (OaCreateObject (&WenvTkn,          Wschema_ObjNum,
McStat,           &WschemaTkn))
if (OaPut          (False,            &RschemaTkn,      PtrToVoid,
RschemaSlotAttr_AttrNum,    (addrtype )&WschemaTkn,
McStat))
if (OaPut          (False,            &WschemaTkn,      PtrToVoid,
WschemaSlotAttr_AttrNum,    (addrtype )&RschemaTkn,
McStat))
if (SetAddInto     (WenvDbs_Hndl,     &WenvTkn,        &RenvDbTkn,
McStat))
if (SetAddInto     (SchemaDbs_Hndl,   &WschemaTkn,     &RenvDbTkn,
McStat))
if (DeBug)
if (OaDumpObject   (0,                &RschemaTkn,     Dump_Status))
OaDumpObject   (0,                &WschemaTkn,     Dump_Status);
CurrNodeTkn.Handle = NodeTkn.Handle;
if (Normal(*Status) &&  WenvId == EnvId)
if (TraceMsg       (1,
"   Make a Schema Object and PAIR with WENV Schema...\n"))
if (SetNextOf      (RenvSchemas_Hndl, &CurrNodeTkn,     McStat,
&NodeTkn,         &RschemaTkn))
if (OaCreateObject (&WenvTkn,          Wschema_ObjNum,
McStat,           &WschemaTkn))
if (OaPut          (False,            &RschemaTkn,      PtrToVoid,
RschemaSlotAttr_AttrNum,    (addrtype )&WschemaTkn,
McStat))
if (OaPut          (False,            &WschemaTkn,      PtrToVoid,
WschemaSlotAttr_AttrNum,    (addrtype )&RschemaTkn,
McStat))
if (OaPut          (False,             DbPrimalTkn,    PtrToVoid,
OwnerWenvDbs_AttrNum,      (addrtype )&SetHeadHndl,
McStat))
if (DeBug)
if (OaDumpObject   (0,                &RschemaTkn,   Dump_Status))
OaDumpObject   (0,                &WschemaTkn,   Dump_Status);
if (DeBug)
if (OaDumpObject (0,  DbPrimalTkn,    Dump_Status))
OaDumpObject (0, &DbTkn,          Dump_Status);
if (DeBug)
if (OaDumpObjHdr (0,  DbPrimalTkn,     PrimalObjNum,  Dump_Status))
OaDumpObjHdr (0,  DbPrimalTkn,     Db_ObjNum,     Dump_Status);
if (Normal(*Status))
if (TraceMsg     (1,
"  Add The New Db Object Into the WenvDbs set...\n"))
if (DeBug)
OaDumpObject (0, &WenvTkn,        Dump_Status);
if (Normal(*Status))
if (SetAddInto     (WenvDbs_Hndl,     &WenvTkn,       &DbTkn,
McStat))
if (TraceMsg     (1,
"  Retrieve The WschemaTkn for this Schema Instance...\n"))
if (OaGet          (False,             SchemaTkn,     PtrToVoid,
RschemaSlotAttr_AttrNum,
McStat,           (addrtype )&WschemaTkn))
if (DeBug)
if (OaDumpObject   (0,                &DbTkn,        Dump_Status))
OaDumpObject   (0,                &WschemaTkn,   Dump_Status);
if (Normal(*Status))
if (TraceMsg     (1,
"  Add Into the SchemaDbs set this Rschema Object... \n"))
SetAddInto     (SchemaDbs_Hndl,   &WschemaTkn,   &DbTkn,
McStat);
}
if (Normal(*Status))
{
BitFieldTkn.DbId  = RenvId;
if (sprintf   (Msg,
"  Assign SchemaObjs to LocalObjNumMap of Db[%2u]...\n\n",
EnvId))
if (TraceMsg  (1,  Msg))
if (OaGet          (False,            SchemaTkn,        PtrToVoid,
ObjsOfSchema_AttrNum,
McStat,          (addrtype )&BitFieldTkn.Handle))
if (KernelFirstBit (&BitFieldTkn,     McStat,          &CurrObj))
while (Normal(*Status) && CurrObj)
{
if (EnvFetchObjHandle
(CurrObj,           McStat,       &ObjTkn.Handle))
if (OaGet       (False,            &ObjTkn,        PtrToVoid,
ObjNum_AttrNum,
McStat,           (addrtype )&ObjNum))
if (ObjNum)
if (MemGetObjNum  (CoreDbs[EnvId]->LocalObjNumMap,   ObjNum,
McStat,                     &LocalObjNum))
if (ObjNum        >= lSetHead_ObjNum)
if (ObjNum && !LocalObjNum)
if (PrimalObjNum  >= Primal_ObjNum)
if (MemPushObjNum (CoreDbs[EnvId]->ObjNumMap,      ObjNum,
McStat,                        &LocalObjNum))
if (MemPushLong   (CoreDbs[EnvId]->ObjTimeStampDir,
(longwordtype )0,
McStat,                        &LocalObjNum))
if (MemPushObjHdr (CoreDbs[EnvId]->ObjHdrDir,      NullPtr,
McStat,                        &StackPtr))
if (MemPushObjNum (CoreDbs[EnvId]->ObjVbnDir,      NullPtr,
McStat,                        &StackPtr))
if (MemPutObjNum  (CoreDbs[EnvId]->LocalObjNumMap, ObjNum,
LocalObjNum,                    McStat))
CoreDbs[EnvId]->LocalObjCount++;
if (Normal(*Status))
if (KernelNextBit (&BitFieldTkn,      CurrObj,
McStat,           &NextObj))
CurrObj  = NextObj;
if (DeBug)
if (sprintf (Msg, " Add Obj[%3u] to DbObjs as LocalObj[%3u]\n",
ObjNum, (CoreDbs[EnvId]->LocalObjCount)))
TraceMsg (1, Msg);
}
if (*Status == Set_EndOfSet)
*Status = Env_Normal;
}
}
if (Normal(*Status))
KernelPutAttr   (&WenvTkn,             DbCount_AttrNum,
(addrtype )&NewId,    McStat);
if (DeBug || OaBug)
if (sprintf (Msg,  " EnvNewDbHdr::   DbPrimal = [%3u:%4u];\n",
DbPrimalTkn->DbId, DbPrimalTkn->Handle))
TraceMsg (0, Msg);
DeBug = TmpDeBug;
TRACK(TrackBak,"DbmCreateDb\n");
return(STAT);
}
#ifndef __DECACHE_DBS__
boolean    Dbm_DeCacheDbs (ft F,lt Z,zz *Status)
{
tokentype    DbToken         = NullToken;
dbheader    *DbHdr           = NullPtr;
int          i               = 0;
addrtype     FreeAddr        = NullPtr;
addrtype    *FreeAddrs       = NullPtr;
sizeinbytes *FreeSizes       = NullPtr;
bytessize    BlkSize1        = Env0->DbCount * sizeof (addrtype)    * 6;
bytessize    BlkSize2        = Env0->DbCount * sizeof (sizeinbytes) * 6;
numtype      Count           = 0;
statustype   DumpStatus      = Env_Normal;
DbToken.Handle        = 1;
if (Core0_MoreCore     (BlkSize1,    McStat,   (addrtype *)&FreeAddrs))
if (Core0_MoreCore     (BlkSize2,    McStat,   (addrtype *)&FreeSizes))
while (Normal(*Status)
&&   ++i             <= (int) Env0->DbCount)
{
DbHdr              = CoreDbs[i];
DbToken.DbId       = i;
if (DbmBug)
{
sprintf (Msg, "\n Dba_Cache movement:: DbId[%4u] ...\n",
i);
TraceMsg (0, Msg);
HmDumpDbHdr      (0,                        &DbToken,  Dump_Status);
}
if (DbHdr   != NullPtr)
if (Mem_MoveChunk   (DbHdr->ObjectIndexDir,     McStat,
&FreeAddrs[Count+0],       &FreeSizes[Count+0]))
if (Mem_MoveChunk   (DbHdr->ObjectAddrDir,      McStat,
&FreeAddrs[Count+1],       &FreeSizes[Count+1]))
if (Mem_MoveChunk   (DbHdr->ObjectMemLocDir,    McStat,
&FreeAddrs[Count+2],       &FreeSizes[Count+2]))
if (Mem_MoveChunk   (DbHdr->LocalObjNumDir,     McStat,
&FreeAddrs[Count+3],       &FreeSizes[Count+3]))
if (Mem_MoveChunk   (DbHdr->ObjNumMap,          McStat,
&FreeAddrs[Count+4],       &FreeSizes[Count+4]))
Count += 5;
if (Normal(*Status))
if (DbHdr->ObjectMemRefDir)
if (Mem_MoveChunk   (DbHdr->ObjectMemRefDir,    McStat,
&FreeAddrs[Count],        &FreeSizes[Count]))
Count += 1;
}
i     = -1;
while (Normal(*Status)
&&   ++i              < Count)
{
FreeAddr          = FreeAddrs[i];
if (DbmBug)
{
sprintf (Msg, " Free CoreBlk[%2u] :: FreeAddr:= @%8x, FreeSize :=%6u\n",
i, FreeAddr,  FreeSizes[i]);
TraceMsg (0, Msg);
}
CoreFreeCoreSpace   (&FreeAddr,     FreeSizes[i],  McStat);
}
if (Normal(*Status))
if (Core0FreeCoreSpace ((addrtype *)&FreeAddrs,    BlkSize1,      McStat))
Core0FreeCoreSpace ((addrtype *)&FreeSizes,    BlkSize2,      McStat);
TRACK(TrackBak,"Dbm_DeCacheHdr\n");
return (STAT);
}
#endif
/* 当前文件是./CINT2000\255.vortex\src\dbm0.c*/

#define DBM_C
#define DBM0
/* 当前文件是./CINT2000\255.vortex\src\fm.h*/



static boolean     SuppressSeek       = False;
static farlongtype LastFileOffset     = 0;

#define   FilePutSomeBytes          File_PutSomeBytes
#define   FileGetSomeBytes          File_GetSomeBytes
#define   FileOutBlk                File_OutBlk
#define   FileOutChunk              File_OutChunk
#define   FileInBlk                 File_InBlk
#define   FileInChunk               File_InChunk
#define   FileGetZeroedChunk        File_GetZeroedChunk
boolean File_GetSomeBytes
(blkhdrtype   *BlkHdr,    farlongtype   FileOffset,
unsigned      SomeBytes,
ft F,lt Z,zz *Status,    addrtype      BytesAddr);
boolean File_InBlk    (addrtype     *BlkAddr,   bytessize     BlkSize,
blkhdrtype   *BlkHdr,    boolean       Release,
ft F,lt Z,zz *Status,    vbntype      *VmBlk);
boolean File_InChunk  (chunknum     *Chunk,     blkhdrtype   *BlkHdr,
boolean       Release,
ft F,lt Z,zz *Status,    vbntype      *VbnBlk);
boolean File_GetZeroedChunk
(vbntype       VbnBlk,    blkhdrtype   *BlkHdr,
boolean       Release,
ft F,lt Z,zz *Status,    numtype      *Chunk);
/* 当前文件是./CINT2000\255.vortex\src\dbm.h*/

#ifndef DBM01_H
#define  DBM01_H

#ifdef DBM_C
#ifdef DBM0
idtype   DbmDbId   = 0;
boolean  NewDbFile = False;
#else


#endif
#endif
#define DbmSetDefaults       Dbm_SetDefaults
#define DbmGetDefaults       Dbm_GetDefaults
#define DbmCommitDb          Dbm_CommitDb
#define DbmFreeDb            Dbm_FreeDb
#define DbmFreeDbHdr         Dbm_FreeDbHdr
#define DbmLoadDb            Dbm_LoadDb
#define DbmLoadDbHdr         Dbm_LoadDbHdr
#define DbmFileInDbHdr       Dbm_FileInDbHdr
#define DbmFileInBlkHdr      Dbm_FileInBlkHdr
void    Dbm_SetDefaults
(indextype     EnvObjs,   indextype     EnvAttrs,
indextype     AllocObjs, indextype     ExtendObjs,
indextype     AllocAttrs,indextype     ExtendAttrs,
indextype     AllocHndls,indextype     ExtendHndls,
indextype     AllocVchunks,indextype   ExtendVchunks,
indextype     AllocGrps, indextype     ExtendGrps,
indextype     AllocTexts,indextype     ExtendTexts,
indextype     AllocXblks,indextype     ExtendXblks);
void    Dbm_GetDefaults
(indextype    *EnvObjs,   indextype    *EnvAttrs,
indextype    *AllocObjs, indextype    *ExtendObjs,
indextype    *AllocAttrs,indextype    *ExtendAttrs,
indextype    *AllocHndls,indextype    *ExtendHndls,
indextype    *AllocVchunks,indextype  *ExtendVchunks,
indextype    *AllocGrps, indextype    *ExtendGrps,
indextype    *AllocTexts,indextype    *ExtendTexts,
indextype    *AllocXblks,indextype    *ExtendXblks);
boolean Dbm_CommitDb
(tokentype    *DbToken,   boolean       RollOut,
ft F,lt Z,zz *Status);
boolean Dbm_LoadDb
(tokentype    *Anchor,    ft F,lt Z,zz *Status,
char         *DbName,    dbheader    **CoreDb);
boolean Dbm_LoadDbHdr
(tokentype    *DbToken,   char         *LoadFile,
ft F,lt Z,zz *Status,    dbheader    **DbHdr);
boolean Dbm_FileInDbHdr
(dbheader     *DbHdr,     boolean       Release,
ft F,lt Z,zz *Status);
boolean Dbm_FileInBlkHdr
(dbheader     *DbHdr,     ft F,lt Z,zz *Status);
boolean Dbm_FreeDb
(tokentype    *DbToken,   ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\vdbm.h*/

#ifndef VDBM01_H
#define  VDBM01_H
boolean DbmNewVchunk   (tokentype    *Anchor,   sizetype     UnitSize,
indextype     UnitCount,indextype    ExtendQty,
ft F,lt Z,zz *Status,
indextype    *Vchunk,   addrtype    *ChunkAddr);
boolean DbmPutVchunkTkn
(tokentype    *Token,  vchunktkntype *VchunkTkn,
ft F,lt Z,zz *Status);
boolean DbmFreeVchunk  (tokentype    *Vtoken,  ft F,lt Z,zz *Status);
boolean DbmDeleteVchunk
(tokentype    *Vtoken,  ft F,lt Z,zz *Status);
boolean DbmCommitVchunk
(tokentype    *VchunkTkn, boolean     Release,
ft F,lt Z,zz *Status);
boolean DbmInvokeVchunk
(tokentype    *Token,
ft F,lt Z,zz *Status, vchunktkntype *VchunkTkn);
boolean DbmGetVchunkTkn
(tokentype    *Token,
ft F,lt Z,zz *Status, vchunktkntype *VchunkTkn);
boolean DbmDumpVchunkVchunk
(tokentype    *Token,   ft F,lt Z,zz *Status);
boolean DbmDumpVchunk  (tokentype    *Token,
numtype       Limit0, numtype        Limit1,
ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\gdbm.h*/

#ifndef GDBM01_H
#define  GDBM01_H
boolean DbmLoadGrpHdr  (tokentype    *DbToken, numtype       GrpNum,
ft F,lt Z,zz *Status,  grpheader   **GrpHdr);
boolean DbmFileInGrpHdr(grpheader    *GrpHdr,  idtype        DbId,
blkhdrtype   *BlkHdr,  boolean       Release,
ft F,lt Z,zz *Status);
boolean DbmFileInGrpRgnChunk
(dbheader     *CoreDb,  grpheader    *GrpHdr,
indextype     RgnIndex,boolean       Release,
ft F,lt Z,zz *Status,  numtype      *RgnChunk);
boolean DbmDeleteGrpHdr
(tokentype    *DbToken, numtype       GrpNum,
ft F,lt Z,zz *Status);
#endif
#ifdef ENV01


#endif
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#define    MemGetVbn          MemGetWord
#define    MemPutVbn          MemPutWord
#define    MemGetChunkNum     MemGetWord
#define    MemPutChunkNum     MemPutWord
#define    MemGetIndex        MemGetWord

farlongtype   FileBlkOffset   = 0;
boolean DbmCommitDb     (tokentype    *DbToken,  boolean     ReleaseDb,
ft F,lt Z,zz *Status)
{
*Status   = Err_NotImplemented;
TRACK(TrackBak,"DbmCommitDb\n");
return(STAT);
}
void    DbmSetDefaults   (indextype     EnvObjs,   indextype     EnvAttrs,
indextype     AllocObjs, indextype     ExtendObjs,
indextype     AllocAttrs,indextype     ExtendAttrs,
indextype     AllocHndls,indextype     ExtendHndls,
indextype     AllocVchunks,indextype   ExtendVchunks,
indextype     AllocGrps, indextype     ExtendGrps,
indextype     AllocTexts,indextype     ExtendTexts,
indextype     AllocXblks,indextype     ExtendXblks)
{
HmSetDefaults   (EnvObjs,       EnvAttrs,      AllocObjs,     ExtendObjs,
AllocAttrs,    ExtendAttrs,   AllocHndls,    ExtendHndls,
AllocVchunks,  ExtendVchunks, AllocGrps,     ExtendGrps,
AllocTexts,    ExtendTexts,   AllocXblks,    ExtendXblks);
return;
}
void    DbmGetDefaults   (indextype    *EnvObjs,   indextype    *EnvAttrs,
indextype    *AllocObjs, indextype    *ExtendObjs,
indextype    *AllocAttrs,indextype    *ExtendAttrs,
indextype    *AllocHndls,indextype    *ExtendHndls,
indextype    *AllocVchunks,indextype  *ExtendVchunks,
indextype    *AllocGrps, indextype    *ExtendGrps,
indextype    *AllocTexts,indextype    *ExtendTexts,
indextype    *AllocXblks,indextype    *ExtendXblks)
{
HmGetDefaults   (EnvObjs,       EnvAttrs,      AllocObjs,     ExtendObjs,
AllocAttrs,    ExtendAttrs,   AllocHndls,    ExtendHndls,
AllocVchunks,  ExtendVchunks, AllocGrps,     ExtendGrps,
AllocTexts,    ExtendTexts,   AllocXblks,    ExtendXblks);
return;
}
/* 当前文件是./CINT2000\255.vortex\src\dbm1.c*/

#define DBM_C
#define DBM1
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#endif
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#define    MemGetVbn          MemGetWord
#define    MemPutVbn          MemPutWord
#define    MemGetChunkNum     MemGetWord
#define    MemPutChunkNum     MemPutWord
#define    MemPutSize         MemPutWord
#define    MemGetIndex        MemGetWord
#ifdef ENV01
#ifndef INLINE_OMIDEFS
#else
#define        DbFileName_AttrNum     (numtype    )158
#define        WenvDbs_Hndl           (handletype )692
#endif



#endif
boolean DbmLoadDb       (tokentype  *Anchor,   ft F,lt Z,zz *Status,
char       *DbName,   dbheader    **CoreDb)
{
char       LoadFileName[MAXPATHNAME];
tokentype  Token        = NullToken;
idtype     DbId         = 0;
#ifdef ENV01
tokentype  DbToken;
tokentype  NodeTkn;
tokentype  NextNodeTkn;
#endif
DbmDbId        = Anchor->DbId;
if (DbmDbId <= WenvId)
{
Token.Handle  = 1;
Token.DbId    = DbmDbId;
DbId          = DbmDbId;
#ifndef ENV01
if (DbId     == RenvId)
strcpy (LoadFileName, RenvFileName);
else if (DbId     == WenvId)
strcpy (LoadFileName, WenvFileName);
else
{
if (strlen (DbName) == 0)
strcpy (LoadFileName, RenvFileName);
else
strcpy (DbFileName, DbName);
}
#else
if (DbId     == RenvId)
strcpy (LoadFileName, RenvFileName);
else
strcpy (LoadFileName, WenvFileName);
} else {
if (KernelFirstOf    (WenvDbs_Hndl,  &WenvTkn,
McStat,        &NodeTkn,            &DbToken))
while (Normal(*Status)
&&     NodeTkn.Handle)
{
if (KernelGetAttr (&DbToken,      DbId_AttrNum,
McStat,        (addrtype )&DbId))
if (DbId != Anchor->DbId)
{
if (KernelNextOf  (WenvDbs_Hndl,  &NodeTkn,
McStat,        &NextNodeTkn,        &DbToken))
{
NodeTkn.DbId   = NextNodeTkn.DbId;
NodeTkn.Handle = NextNodeTkn.Handle;
}
} else {
NodeTkn.Handle = 0;
Token.DbId     = DbId;
Token.Handle   = 1;
}
}
#endif
}
#ifdef ENV01
if (Normal(*Status)
&&  DbId == Anchor->DbId)
if (KernelGetAttr  (&DbToken,      DbFileName_AttrNum,
McStat,        (addrtype )LoadFileName))
{
sprintf (Msg, "\n DbLoadDb LoadFileFile := <%-32s>\n",
LoadFileName);
SendMsg (0, Msg);
sprintf (Msg, "            DbName       := <%-32s>\n",
DbName);
SendMsg (0, Msg);
#endif
DbmLoadDbHdr   (&Token,        LoadFileName,
McStat,        CoreDb);
#ifdef ENV01
} else {
sprintf (Msg, " Can Not open DbFile ::  %s\n", LoadFileName);
SendMsg (0, Msg);
*Status = Err_NotImplemented;
}
#endif
if (*Status == Set_NotFound
||  !Normal(*Status))
if (sprintf  (Msg,  " Not a registered DbId [=%3u]\n", Anchor->DbId))
TraceMsg (0,    Msg);
TRACK(TrackBak,"DbmLoadDb\n");
return(STAT);
}
boolean DbmLoadDbHdr    (tokentype    *DbToken,   char      *LoadFileName,
ft F,lt Z,zz *Status,    dbheader **CoreDb)
{
boolean     TmpWriteHdr  = WriteHdr;
boolean     TmpSwapBug   = SwapBug;
int         TmpDeBug     = DeBug;
boolean     TmpDbmBug    = DbmBug;
vbntype     DbHdrVbn     = 0;
boolean     Release      = False;
dbheader   *DbHdr        = *CoreDb;
indextype   HndlUnits    = 0;
numtype     AllocGroups  = 0;
sprintf (Msg, "\n OPEN File %s \n", LoadFileName);
TraceMsg (0, Msg);
if (!DbmBug  && !SwapBug)
WriteHdr    = True;
if (*CoreDb)
{
WriteHdr               = TmpWriteHdr;
sprintf (Msg, "\n CoreDb ALREADY LOADED @%x\n\n", *CoreDb);
TraceMsg (0, Msg);
return (STAT);
}
if (LoadFileName == NullPtr)
*Status = File_NoName;
else  if (!strlen (LoadFileName))
*Status = File_NoName;
else
DiskFilePtr = fopen (LoadFileName, "r+b");
if (DiskFilePtr == NULL)
{
#ifdef _WIN32
int err = errno;
unsigned long lasterr = GetLastError();
#endif
SendMsg (0, " DbmLoadDbHdr:: Null File Name\n");
*Status = File_WontOpen;
}
#ifdef NO_DISKCACHE
else
setvbuf (DiskFilePtr, NULL, _IONBF, 1024);
#endif
#ifdef __DISPLAY_MESSAGE__
if (Normal(*Status) || DbmBug)
if (sprintf (Msg, " LOAD DBHDR FilePtr = %x; CoreDb @%8x\n",
DiskFilePtr, *CoreDb))
TraceMsg (0, Msg);
#endif
if (Normal(*Status))
{
CoreMoreCore (sizeof (dbheader),  McStat,   (addrtype *)&DbHdr);
#ifdef __DISPLAY_MESSAGE__
sprintf (Msg, " CoreDb[%4u] Located @%x\n", DbToken->DbId, DbHdr);
TraceMsg (0, Msg);
#endif
}
if (Normal(*Status))
{
*Status = Env_Normal;
if (sprintf (Msg, "    *Status            =%4d\n", *Status))
TraceMsg (0, Msg);
DbHdr->BlkHdr.BlkFile     = DiskFilePtr;
if (FileGetSomeBytes  (&DbHdr->BlkHdr,              (farlongtype )0,
(unsigned )sizeof (dbheader),
McStat,                      (addrtype )DbHdr))
{
sprintf (Msg, "   DB HDR restored from FileVbn[%3u]\n", DbHdrVbn);
TraceMsg (0, Msg);
}
}
if (Normal(*Status))
{
DbHdr->GrpHdrDir          = 0;
DbHdr->GrpVbnDir          = 0;
DbHdr->ObjectIndexDir     = 0;
DbHdr->ObjectAddrDir      = 0;
DbHdr->ObjectMemLocDir    = 0;
DbHdr->ObjectMemRefDir    = 0;
DbHdr->LocalObjNumDir     = 0;
DbHdr->LocalObjNumMap     = 0;
DbHdr->ObjHandleDir       = 0;
DbHdr->ObjNumMap          = 0;
DbHdr->ObjTimeStampDir    = 0;
DbHdr->ObjHdrDir          = 0;
DbHdr->ObjVbnDir          = 0;
DbHdr->VchunkCommitDir    = 0;
DbHdr->VchunkSwapDir      = 0;
DbHdr->VbnDeleteDir       = 0;
DbHdr->VchunkGrpHdr       = NullPtr;
DbHdr->NewHandles         = 0;
DbHdr->FreeRegionDir      = 0;
DbHdr->FreeRegionLengths  = 0;
DbHdr->BlkHdr.BlkFile     = DiskFilePtr;
DbHdr->BlkHdr.BlkDirChunk = 0;
DbHdr->BlkHdr.BlkTknChunk = 0;
DbHdr->BlkHdr.BlkSizeChunk= 0;
DbHdr->LocalAttrNumMap    = 0;
DbHdr->AttrHandleDir      = 0;
DbHdr->AttrNumMap         = 0;
DbHdr->LocalAttrSizeTbl   = 0;
DbHdr->TextTokenDir       = 0;
DbHdr->FreeTxtTknStack    = 0;
if (DbHdr->DbId == RenvId && SwapHandles)
{
CoreHandles               = DbHdr->HandleCount;
if (sprintf (Msg, "  1st %u Handles Of Renv are NonPutable\n",
CoreHandles))
TraceMsg (0, Msg);
}
}
#ifdef   __FREEZE_VCHUNKS__
if (Normal(*Status))
if (DbHdr->DbId  > WenvId)
if (MemMakeChunk      (sizeof(vbntype), 5000,      2000,
DbHdr->DbId,    McStat, &(DbHdr->VbnDeleteDir)))
MemPutStackPtr     (DbHdr->VbnDeleteDir,   0,            McStat);
#endif
if (Normal(*Status))
if (DbHdr->ObjectAddrDir == 0)
if (DbHdr->HandleUnits)
{
if (MemMakeChunk   (sizeof(addr),
DbHdr->HandleUnits,          Extend_Handles,
DbHdr->DbId,    McStat,    &(DbHdr->ObjectAddrDir)))
MemPutStackPtr (DbHdr->ObjectAddrDir, DbHdr->HandleCount, McStat);
HndlUnits = DbHdr->HandleUnits;
}
if (Normal(*Status))
if (DbHdr->HandleUnits)
MemNewBitChunk    (HndlUnits,                  DbHdr->DbId,
McStat,                    &(DbHdr->ObjectMemLocDir));
if (Normal(*Status))
if (DbHdr->HandleUnits)
if (DbHdr->DbId      > WenvId)
if (MemMakeChunk      (sizeof(shorttype),
DbHdr->HandleUnits,         Extend_Handles,
DbHdr->DbId,   McStat,    &(DbHdr->ObjectMemRefDir)))
MemPutStackPtr    (DbHdr->ObjectMemRefDir, DbHdr->HandleCount, McStat);
if (Normal(*Status))
if (DbmFileInBlkHdr    (DbHdr,    McStat))
if (DbmFileInDbHdr     (DbHdr,    Release,     McStat))
if (DbHdr->GrpCount == 0 )
AllocGroups = Alloc_Grps ;
else
AllocGroups = DbHdr->GrpCount + Extend_Grps ;
if (Normal(*Status))
if (MemMakeChunk      (sizeof(addrtype),
AllocGroups ,         Extend_Grps,
DbHdr->DbId,   McStat,    &(DbHdr->GrpHdrDir)))
if (MemPutStackPtr    (DbHdr->GrpHdrDir, DbHdr->GrpCount+1, McStat))
if (MemGetChunkAddr(DbHdr->GrpHdrDir,McStat,(addrtype *) &DbHdr->GrpHdrs))
if (MemMakeChunk      (sizeof(addrtype),
DbHdr->LastEnvObjCount+1 ,         Extend_DbObjs,
DbHdr->DbId,   McStat,    &(DbHdr->ObjHdrDir)))
if (MemPutStackPtr    (DbHdr->ObjHdrDir, DbHdr->LocalObjCount+2, McStat))
if (DeBug || DbmBug)
if (sprintf (Msg, "    DB ObjHdrDir         : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->ObjHdrDir,  DbHdr->ObjHdrDirVbn))
TraceMsg (0, Msg);
if (Normal(*Status))
{
*CoreDb = DbHdr;
sprintf (Msg, "\n  DB[%2u] LOADED;  Handles= %u\n",
DbHdr->DbId, DbHdr->HandleCount);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (DbHdr->DbId  == WenvId)
{
CoreDbCount  = 100;
}
SwapBug                = TmpSwapBug;
DbmBug                 = TmpDbmBug;
DeBug                  = TmpDeBug;
WriteHdr               = TmpWriteHdr;
TRACK(TrackBak,"DbmLoadDbHdr\n");
return(STAT);
}
boolean DbmFileInBlkHdr  (dbheader     *DbHdr,    ft F,lt Z,zz *Status)
{
chunkstruc    CS;
farlongtype   Offset      = sizeof (chunkstruc);
addrtype      ChunkAddr   = NullPtr;
if (DeBug >= 0 || DbmBug)
if (sprintf (Msg, "    DB BlkDirOffset      : @%8x\n", DbHdr->BlkDirOffset))
TraceMsg (0, Msg);
if (FileGetSomeBytes (&DbHdr->BlkHdr,          DbHdr->BlkDirOffset,
(unsigned )sizeof (chunkstruc),
McStat,                 (addrtype )&CS))
if (MemMakeChunk     (CS.UnitSize,            CS.UnitCount,
CS.ExtendQty,           DbHdr->DbId,
McStat,                &DbHdr->BlkHdr.BlkDirChunk))
if (MemGetChunkAddr  (DbHdr->BlkHdr.BlkDirChunk,   McStat, &ChunkAddr))
if (FileGetSomeBytes (&DbHdr->BlkHdr,          DbHdr->BlkDirOffset + Offset,
(unsigned )(CS.UnitSize * CS.UnitCount),
McStat,                  ChunkAddr))
MemPutStackPtr   (DbHdr->BlkHdr.BlkDirChunk, CS.StackPtr,  McStat);
if (DeBug >= 0 || DbmBug)
if (sprintf (Msg, "    DB BlkDirChunk       : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->BlkHdr.BlkDirChunk,   DbHdr->BlkDirVbn))
if (TraceMsg (0, Msg))
MemDumpChunkStruc(&CS,                     McStat);
if (Normal(*Status))
if (FileGetSomeBytes (&DbHdr->BlkHdr,          DbHdr->BlkTknOffset,
(unsigned )sizeof (chunkstruc),
McStat,                 (addrtype )&CS))
if (MemMakeChunk     (CS.UnitSize,            CS.UnitCount,
CS.ExtendQty,           0,
McStat,                &DbHdr->BlkHdr.BlkTknChunk))
if (MemGetChunkAddr  (DbHdr->BlkHdr.BlkTknChunk,   McStat, &ChunkAddr))
if (FileGetSomeBytes (&DbHdr->BlkHdr,          DbHdr->BlkTknOffset + Offset,
(unsigned )(CS.UnitSize * CS.UnitCount),
McStat,                  ChunkAddr))
if (MemPutStackPtr   (DbHdr->BlkHdr.BlkTknChunk, CS.StackPtr,  McStat))
if (DeBug >= 0 || DbmBug)
if (sprintf (Msg, "    DB BlkTknChunk       : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->BlkHdr.BlkTknChunk,   DbHdr->BlkTknVbn))
if (TraceMsg (0, Msg))
MemDumpChunkStruc(&CS,                     McStat);
if (Normal(*Status))
if (FileGetSomeBytes (&DbHdr->BlkHdr,          DbHdr->BlkSizeOffset,
(unsigned )sizeof (chunkstruc),
McStat,                 (addrtype )&CS))
if (MemMakeChunk     (CS.UnitSize,            CS.UnitCount,
CS.ExtendQty,           0,
McStat,                &DbHdr->BlkHdr.BlkSizeChunk))
if (MemGetChunkAddr  (DbHdr->BlkHdr.BlkSizeChunk,  McStat, &ChunkAddr))
if (FileGetSomeBytes (&DbHdr->BlkHdr,          DbHdr->BlkSizeOffset+ Offset,
(unsigned )(CS.UnitSize * CS.UnitCount),
McStat,                  ChunkAddr))
if (MemPutStackPtr   (DbHdr->BlkHdr.BlkSizeChunk, CS.StackPtr,  McStat))
if (DeBug >= 0 || DbmBug)
if (sprintf (Msg, "    DB BlkSizeChunk      : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->BlkHdr.BlkSizeChunk,   DbHdr->BlkSizeVbn))
if (TraceMsg (0, Msg))
MemDumpChunkStruc(&CS,                     McStat);
TRACK(TrackBak,"DbmFileInBlkHdr\n");
return(STAT);
}
boolean DbmFileInDbHdr  (dbheader   *DbHdr,    boolean   Release,
ft F,lt Z,zz *Status)
{
indextype       StackPtr = 0;
if (SwapHandles && DbHdr->DbId == RenvId)
{
*Status = Env_Normal;
} else {
if (DbHdr->ObjectIndexDirVbn)
if (FileInChunk (&DbHdr->ObjectIndexDir,
&(DbHdr->BlkHdr),        Release,
McStat,                      &DbHdr->ObjectIndexDirVbn))
if (MemGetStackPtr (DbHdr->ObjectIndexDir, McStat,     &StackPtr))
if (sprintf (Msg, " DB Handle Chunk's StackPtr = %u\n", StackPtr))
if (TraceMsg (0, Msg))
if (DeBug || DbmBug)
if (sprintf (Msg, "    DB ObjectIndexDir    : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->ObjectIndexDir,  DbHdr->ObjectIndexDirVbn))
if (TraceMsg (0, Msg))
DumpChunkChunk (0, DbHdr->ObjectIndexDir);
if (Normal(*Status))
if (DbHdr->LocalObjNumDirVbn)
if (FileInChunk (&DbHdr->LocalObjNumDir,
&(DbHdr->BlkHdr),        Release,
McStat,                      &DbHdr->LocalObjNumDirVbn))
if (DeBug || DbmBug)
if (sprintf (Msg, "    DB LocalObjNumDir    : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->LocalObjNumDir,  DbHdr->LocalObjNumDirVbn))
if (TraceMsg (0, Msg))
DumpChunkChunk (0, DbHdr->LocalObjNumDir);
}
if (Normal(*Status))
if (DbHdr->LocalObjNumMapVbn)
if (FileInChunk (&DbHdr->LocalObjNumMap,
&(DbHdr->BlkHdr),        Release,
McStat,                      &DbHdr->LocalObjNumMapVbn))
if (DeBug || DbmBug) {
sprintf (Msg, "    DB LocalObjNumMap    : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->LocalObjNumMap,  DbHdr->LocalObjNumMapVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (DbHdr->ObjHandleDirVbn)
if (FileInChunk (&DbHdr->ObjHandleDir,
&(DbHdr->BlkHdr),               Release,
McStat,                        &DbHdr->ObjHandleDirVbn))
if (DeBug || DbmBug)
{
sprintf (Msg, "    DB ObjHandleDir      : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->ObjHandleDir,  DbHdr->ObjHandleDirVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (DbHdr->ObjNumMapDirVbn)
if (FileInChunk (&DbHdr->ObjNumMap,
&(DbHdr->BlkHdr),        Release,
McStat,                        &DbHdr->ObjNumMapDirVbn))
if (DeBug || DbmBug) {
sprintf (Msg, "    DB ObjNumMap         : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->ObjNumMap,  DbHdr->ObjNumMapDirVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (DbHdr->ObjTimeStampVbn)
if (FileInChunk (&DbHdr->ObjTimeStampDir,
&(DbHdr->BlkHdr),        Release,
McStat,                        &DbHdr->ObjTimeStampVbn))
if (DeBug || DbmBug) {
sprintf (Msg, "    DB ObjTimeStampDir   : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->ObjTimeStampDir,  DbHdr->ObjTimeStampVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (DbHdr->LocalAttrMapVbn)
if (FileInChunk (&DbHdr->LocalAttrNumMap,
&(DbHdr->BlkHdr),        Release,
McStat,                        &DbHdr->LocalAttrMapVbn))
if (DeBug || DbmBug) {
sprintf (Msg, "    DB LocalAttrNumMap   : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->LocalAttrNumMap,  DbHdr->LocalAttrMapVbn);
TraceMsg (0, Msg);
DumpChunkChunk (0, DbHdr->LocalAttrNumMap);
}
if (Normal(*Status))
if (DbHdr->AttrHandleDirVbn)
if (FileInChunk (&DbHdr->AttrHandleDir,
&(DbHdr->BlkHdr),        Release,
McStat,                       &DbHdr->AttrHandleDirVbn))
if (DeBug || DbmBug) {
sprintf (Msg, "    DB AttrHandleDir     : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->AttrHandleDir,  DbHdr->AttrHandleDirVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (DbHdr->AttrNumMapVbn)
if (FileInChunk (&DbHdr->AttrNumMap,
&(DbHdr->BlkHdr),        Release,
McStat,                          &DbHdr->AttrNumMapVbn))
if (DeBug || DbmBug) {
sprintf (Msg, "    DB AttrNumMap        : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->AttrNumMap,  DbHdr->AttrNumMapVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (DbHdr->LocalAttrSizeVbn)
if (FileInChunk (&DbHdr->LocalAttrSizeTbl,
&(DbHdr->BlkHdr),        Release,
McStat,                       &DbHdr->LocalAttrSizeVbn))
{
if (DeBug || DbmBug)
{
sprintf (Msg, "    DB LocalAttrSizeTbl  : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->LocalAttrSizeTbl,  DbHdr->LocalAttrSizeVbn);
TraceMsg (0, Msg);
}
if ( DbHdr->DbId == RenvId )
	 MemPutSize( DbHdr->LocalAttrSizeTbl, That_AttrNum,
		     sizeof( addrtype ) , McStat ) ;
}
if (Normal(*Status))
if (DbHdr->TextTknDirVbn)
if (FileInChunk (&DbHdr->TextTokenDir,
&(DbHdr->BlkHdr),        Release,
McStat,                       &DbHdr->TextTknDirVbn))
if (DeBug || DbmBug) {
sprintf (Msg, "    DB TextTokenDir      : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->TextTokenDir, DbHdr->TextTknDirVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (DbHdr->FreeTxtTknVbn)
if (FileInChunk (&DbHdr->FreeTxtTknStack,
&(DbHdr->BlkHdr),        Release,
McStat,                       &DbHdr->FreeTxtTknVbn))
if (DeBug || DbmBug) {
sprintf (Msg, "    DB FreeTxtTknStack   : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->FreeTxtTknStack, DbHdr->FreeTxtTknVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (DbHdr->GrpVbnDirVbn)
if (FileInChunk (&DbHdr->GrpVbnDir,
&(DbHdr->BlkHdr),        Release,
McStat,                           &DbHdr->GrpVbnDirVbn))
if (DeBug || DbmBug)
{
sprintf (Msg, "    DB GrpVbnDir         : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->GrpVbnDir,  DbHdr->GrpVbnDirVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (DbHdr->ObjVbnDirVbn)
if (FileInChunk (&DbHdr->ObjVbnDir,
&(DbHdr->BlkHdr),        Release,
McStat,                           &DbHdr->ObjVbnDirVbn))
if (DeBug || DbmBug) {
sprintf (Msg, "    DB ObjVbnDir         : Chunk[%4u] AT Vbn[%3u]\n",
DbHdr->ObjVbnDir,  DbHdr->ObjVbnDirVbn);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"DbmFileInDbHdr\n");
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\dbm2.c*/

#define DBM_C
#define DBM2
boolean Dbm_FreeDb      (tokentype    *DbToken,  ft F,lt Z,zz *Status);
boolean Dbm_FreeDb      (tokentype    *DbToken,  ft F,lt Z,zz *Status)
{
*Status  = Err_NotImplemented;
TRACK(TrackBak,"DbmFreeDb\n");
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\domain.c*/

#define  DOMAIN01
#define  __DISPLAY_TIME__
#ifdef    DEBUG
#define  __DISPLAY_TIME__
#endif
#ifdef   __DISPLAY_TIME__
#endif





#ifndef INLINE_OMIDEFS
#else
#define        WenvDbs_Hndl           (handletype )692
#endif



#define DbmSetDefaults     Dbm_SetDefaults
#define DbmLoadDbHdr       Dbm_LoadDbHdr
#define DbmCommitDb        Dbm_CommitDb








typedef struct AlignType11 {
bytetype       Byte0;
bytetype       ByteWord0;
}              align11type;
typedef struct AlignType12 {
bytetype       Byte0;
short          ShortWord0;
}              align12type;
typedef struct AlignType14 {
bytetype       Byte0;
longwordtype   LongWord0;
}              align14type;
typedef struct AlignType141 {
bytetype       Byte0;
longwordtype   LongWord0;
longwordtype   Byte1;
}              align141type;
typedef struct AlignType18 {
bytetype       Byte0;
double         DblWord0;
}              align18type;
typedef struct AlignType482 {
longwordtype   LongWord0;
double         DblWord;
short          Word1;
}              align482type;
typedef struct AlignType842 {
double         DblWord;
longwordtype   LongWord0;
short          Word1;
}              align842type;
boolean  Large                   = False;
#ifdef   __DISPLAY_TIME__
static   time_t   Implode_Time  = 0;
#endif
boolean Domain_ImplodeMemory
(ft F,lt Z,zz *Status)
{
#ifdef   __DISPLAY_TIME__
time_t          Tod        = 0;
time_t          TimeOf     = 0;
#endif
align11type     Align11;
align12type     Align12;
align14type     Align14;
align18type     Align18;
size_t          Offset     = 0;
longaddr        StartAddr  = 0;
numtype         AlignSize  = 0;
WriteHdr         = True;
TraceMsg (0, "\n  SYSTEM TYPE...\n");
#ifdef __ZTC__
sprintf (Msg,  "  __ZTC__                := True \n");
#else
sprintf (Msg,  "  __ZTC__                := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __UNIX__
sprintf (Msg,  "  __UNIX__               := True \n");
#else
sprintf (Msg,  "  __UNIX__               := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __RISC__
sprintf (Msg,  "  __RISC__               := True \n");
#else
sprintf (Msg,  "  __RISC__               := False \n");
#endif
TraceMsg (0, Msg);
#ifdef SPEC_CPU2000_LP64
sprintf (Msg,  "  SPEC_CPU2000_LP64        := True \n");
#else
sprintf (Msg,  "  SPEC_CPU2000_LP64        := False \n");
#endif
TraceMsg (0, Msg);
#ifdef SPEC_CPU2000_P64
sprintf (Msg,  "  SPEC_CPU2000_P64        := True \n");
#else
sprintf (Msg,  "  SPEC_CPU2000_P64        := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __MAC__
sprintf (Msg,  "  __MAC__                := True \n");
#else
sprintf (Msg,  "  __MAC__                := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __BCC__
sprintf (Msg,  "  __BCC__                := True \n");
#else
sprintf (Msg,  "  __BCC__                := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __BORLANDC__
sprintf (Msg,  "  __BORLANDC__           := True \n");
#else
sprintf (Msg,  "  __BORLANDC__           := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __GUI__
sprintf (Msg,  "  __GUI__                := True \n");
#else
sprintf (Msg,  "  __GUI__                := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __WTC__
sprintf (Msg,  "  __WTC__                := True \n");
#else
sprintf (Msg,  "  __WTC__                := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __HP__
sprintf (Msg,  "  __HP__                 := True \n");
#else
sprintf (Msg,  "  __HP__                 := False \n");
#endif
TraceMsg (0, Msg);
TraceMsg (0, "\n  CODE OPTIONS...\n");
#ifdef __MACROIZE_HM__
sprintf (Msg,  "  __MACROIZE_HM__        := True \n");
#else
sprintf (Msg,  "  __MACROIZE_HM__        := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __MACROIZE_MEM__
sprintf (Msg,  "  __MACROIZE_MEM__       := True \n");
#else
sprintf (Msg,  "  __MACROIZE_MEM__       := False \n");
#endif
TraceMsg (0, Msg);
#ifdef ENV01
sprintf (Msg,  "  ENV01                  := True \n");
#else
sprintf (Msg,  "  ENV01                  := False \n");
#endif
TraceMsg (0, Msg);
#ifdef USE_HPP_STYPE_HDRS
sprintf (Msg,  "  USE_HPP_STYPE_HDRS     := True \n");
#else
sprintf (Msg,  "  USE_HPP_STYPE_HDRS     := False \n");
#endif
TraceMsg (0, Msg);
#ifdef USE_HPP_STYPE_HDRS
sprintf (Msg,  "  USE_H_STYPE_HDRS       := True \n");
#else
sprintf (Msg,  "  USE_H_STYPE_HDRS       := False \n");
#endif
TraceMsg (0, Msg);
TraceMsg (0, "\n  CODE INCLUSION PARAMETERS...\n");
#ifdef INCLUDE_ALL_CODE
sprintf (Msg,  "  INCLUDE_ALL_CODE       := True \n");
#else
sprintf (Msg,  "  INCLUDE_ALL_CODE       := False \n");
#endif
TraceMsg (0, Msg);
#ifdef INCLUDE_DELETE_CODE
sprintf (Msg,  "  INCLUDE_DELETE_CODE    := True \n");
#else
sprintf (Msg,  "  INCLUDE_DELETE_CODE    := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __SWAP_GRP_POS__
sprintf (Msg,  "  __SWAP_GRP_POS__       := True \n");
#else
sprintf (Msg,  "  __SWAP_GRP_POS__       := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __INCLUDE_MTRX__
sprintf (Msg,  "  __INCLUDE_MTRX__       := True \n");
#else
sprintf (Msg,  "  __INCLUDE_MTRX__       := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __BAD_CODE__
sprintf (Msg,  "  __BAD_CODE__           := True \n");
#else
sprintf (Msg,  "  __BAD_CODE__           := False \n");
#endif
TraceMsg (0, Msg);
#ifdef API_INCLUDE
sprintf (Msg,  "  API_INCLUDE            := True \n");
#else
sprintf (Msg,  "  API_INCLUDE            := False \n");
#endif
TraceMsg (0, Msg);
#ifdef BE_CAREFUL
sprintf (Msg,  "  BE_CAREFUL             := True \n");
#else
sprintf (Msg,  "  BE_CAREFUL             := False \n");
#endif
TraceMsg (0, Msg);
#ifdef OLDWAY
sprintf (Msg,  "  OLDWAY                 := True \n");
#else
sprintf (Msg,  "  OLDWAY                 := False \n");
#endif
TraceMsg (0, Msg);
#ifdef NOTUSED
sprintf (Msg,  "  NOTUSED                := True \n");
#else
sprintf (Msg,  "  NOTUSED                := False \n");
#endif
TraceMsg (0, Msg);
TraceMsg (0, "\n  SYSTEM PARAMETERS...\n");
sprintf (Msg,  "  EXT_ENUM               := %4uL \n", EXT_ENUM);
TraceMsg (0, Msg);
sprintf (Msg,  "  CHUNK_CONSTANT         := %8x \n", CHUNK_CONSTANT);
TraceMsg (0, Msg);
sprintf (Msg,  "  CORE_CONSTANT          := %8x \n", CORE_CONSTANT);
TraceMsg (0, Msg);
sprintf (Msg,  "  CORE_LIMIT             := %4u \n", CORE_LIMIT);
TraceMsg (0, Msg);
sprintf (Msg,  "  CorePage_Size          := %4u \n", CorePage_Size);
TraceMsg (0, Msg);
#ifdef ALIGN_BYTES
sprintf (Msg,  "  ALIGN_BYTES            := True \n");
#else
sprintf (Msg,  "  ALIGN_BYTES            := False \n");
#endif
TraceMsg (0, Msg);
sprintf (Msg,  "  CORE_BLOCK_ALIGN       := %4u \n", CORE_BLOCK_ALIGN);
TraceMsg (0, Msg);
#ifdef FAR_MEM
sprintf (Msg,  "  FAR_MEM                := True \n");
#else
sprintf (Msg,  "  FAR_MEM                := False \n");
#endif
TraceMsg (0, Msg);
TraceMsg (0, "\n  MEMORY MANAGEMENT PARAMETERS...\n");
#ifdef SYSTEM_ALLOC
sprintf (Msg,  "  SYSTEM_ALLOC           := True \n");
#else
sprintf (Msg,  "  SYSTEM_ALLOC           := False \n");
#endif
TraceMsg (0, Msg);
#ifdef SYSTEM_FREESTORE
sprintf (Msg,  "  SYSTEM_FREESTORE       := True \n");
#else
sprintf (Msg,  "  SYSTEM_FREESTORE       := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __NO_DISKCACHE__
sprintf (Msg,  "  __NO_DISKCACHE__       := True \n");
#else
sprintf (Msg,  "  __NO_DISKCACHE__       := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __FREEZE_VCHUNKS__
sprintf (Msg,  "  __FREEZE_VCHUNKS__     := True \n");
#else
sprintf (Msg,  "  __FREEZE_VCHUNKS__     := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __FREEZE_GRP_PACKETS__
sprintf (Msg,  "  __FREEZE_GRP_PACKETS__ := True \n");
#else
sprintf (Msg,  "  __FREEZE_GRP_PACKETS__ := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __MINIMIZE_TREE_CACHE__
sprintf (Msg,  "  __MINIMIZE_TREE_CACHE__:= True \n");
#else
sprintf (Msg,  "  __MINIMIZE_TREE_CACHE__:= False \n");
#endif
TraceMsg (0, Msg);
TraceMsg (0, "\n  SYSTEM STD PARAMETERS...\n");
#ifdef __STDOUT__
sprintf (Msg,  "  __STDOUT__             := True \n");
#else
sprintf (Msg,  "  __STDOUT__             := False \n");
#endif
TraceMsg (0, Msg);
sprintf (Msg,  "  NULL                   := %4u \n", NULL);
TraceMsg (0, Msg);
#ifdef LPTR
sprintf (Msg,  "  LPTR                   := True \n");
#else
sprintf (Msg,  "  LPTR                   := False \n");
#endif
TraceMsg (0, Msg);
sprintf (Msg,  "  False_Status           := %4u \n", False_Status);
TraceMsg (0, Msg);
sprintf (Msg,  "  True_Status            := %4u \n", True_Status);
TraceMsg (0, Msg);
#ifdef LARGE
sprintf (Msg,  "  LARGE                  := True \n");
#else
sprintf (Msg,  "  LARGE                  := False \n");
#endif
TraceMsg (0, Msg);
#ifdef TWOBYTE_BOOL
sprintf (Msg,  "  TWOBYTE_BOOL           := True \n");
#else
sprintf (Msg,  "  TWOBYTE_BOOL           := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __NOSTR__
sprintf (Msg,  "  __NOSTR__              := True \n");
#else
sprintf (Msg,  "  __NOSTR__              := False \n");
#endif
TraceMsg (0, Msg);
TraceMsg (0, "\n  MEMORY VALIDATION PARAMETERS...\n");
#ifdef CORE_CRC_CHECK
sprintf (Msg,  "  CORE_CRC_CHECK         := True \n");
#else
sprintf (Msg,  "  CORE_CRC_CHECK         := False \n");
#endif
TraceMsg (0, Msg);
#ifdef VALIDATE_MEM_CHUNKS
sprintf (Msg,  "  VALIDATE_MEM_CHUNKS    := True \n");
#else
sprintf (Msg,  "  VALIDATE_MEM_CHUNKS    := False \n");
#endif
TraceMsg (0, Msg);
TraceMsg (0, "\n  SYSTEM DEBUG OPTIONS...\n");
#ifdef DEBUG
sprintf (Msg,  "  DEBUG                  := True \n");
#else
sprintf (Msg,  "  DEBUG                  := False \n");
#endif
TraceMsg (0, Msg);
#ifdef MCSTAT
sprintf (Msg,  "  MCSTAT                 := True \n");
#else
sprintf (Msg,  "  MCSTAT                 := False \n");
#endif
TraceMsg (0, Msg);
#ifdef TRACKBACK
sprintf (Msg,  "  TRACKBACK              := True \n");
#else
sprintf (Msg,  "  TRACKBACK              := False \n");
#endif
TraceMsg (0, Msg);
#ifdef FLUSH_FILES
sprintf (Msg,  "  FLUSH_FILES            := True \n");
#else
sprintf (Msg,  "  FLUSH_FILES            := False \n");
#endif
TraceMsg (0, Msg);
#ifdef DEBUG_CORE0
sprintf (Msg,  "  DEBUG_CORE0            := True \n");
#else
sprintf (Msg,  "  DEBUG_CORE0            := False \n");
#endif
TraceMsg (0, Msg);
#ifdef DEBUG_RISC
sprintf (Msg,  "  DEBUG_RISC             := True \n");
#else
sprintf (Msg,  "  DEBUG_RISC             := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __TREE_BUG__
sprintf (Msg,  "  __TREE_BUG__           := True \n");
#else
sprintf (Msg,  "  __TREE_BUG__           := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __TRACK_FILE_READS__
sprintf (Msg,  "  __TRACK_FILE_READS__   := True \n");
#else
sprintf (Msg,  "  __TRACK_FILE_READS__   := False \n");
#endif
TraceMsg (0, Msg);
#ifdef PAGE_SPACE
sprintf (Msg,  "  PAGE_SPACE             := True \n");
#else
sprintf (Msg,  "  PAGE_SPACE             := False \n");
#endif
TraceMsg (0, Msg);
#ifdef LEAVE_NO_TRACE
sprintf (Msg,  "  LEAVE_NO_TRACE         := True \n");
#else
sprintf (Msg,  "  LEAVE_NO_TRACE         := False \n");
#endif
TraceMsg (0, Msg);
#ifdef NULL_TRACE_STRS
sprintf (Msg,  "  NULL_TRACE_STRS        := True \n");
#else
sprintf (Msg,  "  NULL_TRACE_STRS        := False \n");
#endif
TraceMsg (0, Msg);
TraceMsg (0, "\n  TIME PARAMETERS...\n");
#ifdef CLOCK_IS_LONG
sprintf (Msg,  "  CLOCK_IS_LONG          := True \n");
#else
sprintf (Msg,  "  CLOCK_IS_LONG          := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __DISPLAY_TIME__
sprintf (Msg,  "  __DISPLAY_TIME__       := True \n");
#else
sprintf (Msg,  "  __DISPLAY_TIME__       := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __TREE_TIME__
sprintf (Msg,  "  __TREE_TIME__          := True \n");
#else
sprintf (Msg,  "  __TREE_TIME__          := False \n");
#endif
TraceMsg (0, Msg);
#ifdef __DISPLAY_ERRORS__
sprintf (Msg,  "  __DISPLAY_ERRORS__     := True \n");
#else
sprintf (Msg,  "  __DISPLAY_ERRORS__     := False \n");
#endif
TraceMsg (0, Msg);
TraceMsg (0, "\n  API MACROS...\n");
#ifdef __BMT01__
sprintf (Msg,  "  __BMT01__              := True \n");
#else
sprintf (Msg,  "  __BMT01__              := False \n");
#endif
TraceMsg (0, Msg);
#ifdef OPTIMIZE
sprintf (Msg,  "  OPTIMIZE               := True \n");
#else
sprintf (Msg,  "  OPTIMIZE               := False \n");
#endif
TraceMsg (0, Msg);
TraceMsg (0, "\n  END OF DEFINES.\n\n");
WriteHdr         = False;
SendMsg  (0, "\n\n              ...   IMPLODE MEMORY ...\n");
#ifdef __DISPLAY_TIME__
Implode_Time = clock();
TimeOf       = time (&Tod);
if (sprintf  (Msg, "   time stamp= [%lu] :: %s\n",
(lt64 )Implode_Time, ctime (&TimeOf)))
TraceMsg (MSGFILE, Msg);
#endif
Large       = False;
Build_Env   = False;
Admin_Run   = False;
Reload_Wenv = True;
FileBug     = False;
Align_Bytes = False;
#ifdef ALIGN_BYTES
Align_Bytes = True;
#endif
StrucAlignment         = 1;
AlignSize = sizeof(align14type);
if (AlignSize != (sizeof (bytetype)     + sizeof (longwordtype)))
Align_Bytes = True;
if (Align_Bytes)
{
AlignSize   = sizeof(align141type);
if (AlignSize      == 10)
StrucAlignment         = 2;
else if (AlignSize == 12)
StrucAlignment         = 4;
else if (AlignSize == 16)
StrucAlignment         = 8;
StartAddr   = (longaddr)&Align11;
Offset      = (size_t)((longaddr )&Align11.ByteWord0  -  StartAddr);
Byte_Alignment         = Offset;
StartAddr   = (longaddr)&Align12;
Offset      = (size_t)((longaddr )&Align12.ShortWord0 -  StartAddr);
Byte2Alignment         = Offset;
StartAddr   = (longaddr)&Align14;
Offset      = (size_t)((longaddr )&Align14.LongWord0  -  StartAddr);
Byte4Alignment         = Offset;
StartAddr   = (longaddr)&Align18;
Offset      = (size_t)((longaddr )&Align18.DblWord0   -  StartAddr);
Byte8Alignment         = Offset;
BytePtrAlignment       = sizeof (addrtype);
} else {
StrucAlignment         = 1;
Byte_Alignment         = 1;
Byte2Alignment         = 1;
Byte4Alignment         = 1;
Byte8Alignment         = 1;
BytePtrAlignment       = 1;
}
if (Align_CppStruc)
CppAlignment           = 4;
else
CppAlignment           = 0;
#ifdef DEBUG
WriteHdr = True;
sprintf (Msg, " Byte Alignment :: %u byte boundary\n", Byte_Alignment);
TraceMsg (0, Msg);
sprintf (Msg, " Byte(1)  Alignment :: %u byte boundary\n", Byte_Alignment);
TraceMsg (0, Msg);
sprintf (Msg, " Byte(2)  Alignment :: %u byte boundary\n", Byte2Alignment);
TraceMsg (0, Msg);
sprintf (Msg, " Byte(4)  Alignment :: %u byte boundary\n", Byte4Alignment);
TraceMsg (0, Msg);
sprintf (Msg, " Byte(8)  Alignment :: %u byte boundary\n", Byte8Alignment);
TraceMsg (0, Msg);
sprintf (Msg, " Byte(*p) Alignment  :: %u byte boundary\n", BytePtrAlignment);
SendMsg (0, Msg);
sprintf (Msg, " Struc    Alignment :: %u byte boundary\n", StrucAlignment);
TraceMsg (0, Msg);
sprintf (Msg, " Add for THAT       :: %u bytes      \n\n", CppAlignment);
TraceMsg (0, Msg);
TraceMsg (0,   "\n STRUCT alignment with <double> as 2nd member\n");
sprintf (Msg, " Alignment 482   :: %u\n", sizeof (align482type));
TraceMsg (0, Msg);
TraceMsg (0,   " STRUCT alignment with <double> as 1st member\n");
sprintf (Msg, " Alignment 842   :: %u\n", sizeof (align482type));
TraceMsg (0, Msg);
WriteHdr = False;
#endif
sprintf (Msg, "\n  SWAP to DiskCache := %s\n", BoolStr[SWAP]);
SendMsg (0, Msg);
sprintf (Msg, "\n  FREEZE_GRP_PACKETS:= %s\n", BoolStr[FREEZE_GRP_PACKETS]);
SendMsg (0, Msg);
sprintf (Msg, "\n  QueBug            := %u\n", QueBug);
SendMsg (0, Msg);
#ifdef __RISC__
#if defined(SPEC_CPU2000_LP64) || defined(SPEC_CPU2000_P64)
StrucAlignment         = 8;
#else
StrucAlignment         = 4;
#endif
Byte_Alignment         = 1;
Byte2Alignment         = 2;
Byte4Alignment         = 4;
Byte8Alignment         = 8;
BytePtrAlignment       = sizeof (addrtype);
CppAlignment           = 0;
WriteHdr = True;
#ifdef DEBUG
TraceMsg(0, "\n    *** BYTE ALIGNMENT OVERRIDE ***\n");
sprintf (Msg, " Byte Alignment :: %u byte boundary\n", Byte_Alignment);
TraceMsg (0, Msg);
sprintf (Msg, " Byte(1)  Alignment :: %u byte boundary\n", Byte_Alignment);
TraceMsg (0, Msg);
sprintf (Msg, " Byte(2)  Alignment :: %u byte boundary\n", Byte2Alignment);
TraceMsg (0, Msg);
sprintf (Msg, " Byte(4)  Alignment :: %u byte boundary\n", Byte4Alignment);
TraceMsg (0, Msg);
sprintf (Msg, " Byte(8)  Alignment :: %u byte boundary\n", Byte8Alignment);
TraceMsg (0, Msg);
sprintf (Msg, " Byte(*p) Alignment  :: %u byte boundary\n", BytePtrAlignment);
SendMsg (0, Msg);
sprintf (Msg, " Struc    Alignment :: %u byte boundary\n", StrucAlignment);
TraceMsg (0, Msg);
sprintf (Msg, " Add for THAT       :: %u bytes      \n\n", CppAlignment);
TraceMsg (0, Msg);
WriteHdr = False;
#endif
sprintf (Msg, "\n  sizeof(boolean)      = %2u\n", sizeof (boolean));
SendMsg (MSGFILE, Msg);
#ifdef TWOBYTE_BOOL
sprintf (Msg, "  sizeof(twobytetype)  = %2u\n", sizeof (twobytetype));
SendMsg (MSGFILE, Msg);
#endif
sprintf (Msg, "  sizeof(sizetype)     = %2u\n", sizeof (sizetype));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(chunkstruc)   = %2u\n", sizeof (chunkstruc));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "\n  sizeof(shorttype )   = %2u\n", sizeof (shorttype));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(idtype    )   = %2u\n", sizeof (idtype));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(sizetype  )   = %2u\n", sizeof (sizetype));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(indextype )   = %2u\n", sizeof (indextype));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(numtype   )   = %2u\n", sizeof (numtype));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(handletype)   = %2u\n", sizeof (handletype));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(tokentype )   = %2u\n", sizeof (tokentype));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "\n  sizeof(short     )   = %2u\n", sizeof (short));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(int       )   = %2u\n", sizeof (int));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "\n  sizeof(lt64      )   = %2u\n", sizeof (lt64));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(farlongtype)  = %2u\n", sizeof (farlongtype));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(long      )   = %2u\n", sizeof (long));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(longaddr  )   = %2u\n", sizeof (longaddr));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "\n  sizeof(float     )   = %2u\n", sizeof (float));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(double    )   = %2u\n", sizeof (double));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "\n  sizeof(addrtype  )   = %2u\n", sizeof (addrtype));
SendMsg (MSGFILE, Msg);
sprintf (Msg, "  sizeof(char *    )   = %2u\n", sizeof (char *));
SendMsg (MSGFILE, Msg);
#endif
VORTEx (McStat);
TRACK(TrackBak,"Domain_ImplodeMemory\n");
return (STAT);
}
boolean Domain_BeHereNow
(ft F,lt Z,zz *Status)
{
indextype     EnvObjs      = Env_Objs;
indextype     EnvAttrs     = Env_Attrs;
indextype     AllocObjs    = Alloc_DbObjs;
indextype     ExtendObjs   = Extend_DbObjs;
indextype     AllocAttrs   = Alloc_DbAttrs;
indextype     ExtendAttrs  = Extend_DbAttrNums;
indextype     AllocHndls   = Alloc_Handles;
indextype     ExtendHndls  = Extend_Handles;
indextype     AllocVchunks = Alloc_Vchunks;
indextype     ExtendVchunks= Extend_Vchunks;
indextype     AllocGrps    = Alloc_Grps;
indextype     ExtendGrps   = Extend_Grps;
indextype     AllocTexts   = Alloc_TxtTkns;
indextype     ExtendTexts  = Extend_TxtTkns;
indextype     AllocXblks   = DbXmemBlocks_AllocQty;
indextype     ExtendXblks  = DbXmemBlocks_ExtendQty;
tokentype     AddrTypeTkn  = NullToken;
typedesctype *EnvType      = NullPtr;
TraceMsg (0, "\n    BE HERE NOW !!!\n\n");
DbmSetDefaults  (EnvObjs,       EnvAttrs,      AllocObjs,     ExtendObjs,
AllocAttrs,    ExtendAttrs,   AllocHndls,    ExtendHndls,
AllocVchunks,  ExtendVchunks, AllocGrps,     ExtendGrps,
AllocTexts,    ExtendTexts,   AllocXblks,    ExtendXblks);
if (*Status == Env_Installed)
{
*Status          = Env_Normal;
if (Env0->DbCount == RenvId)
{
if (KernelCreateDb
(WenvSchemaNam,  WenvNam,  WenvFileName,  Shared_Write,
McStat,        &WenvTkn))
#ifdef   __FREEZE_VCHUNKS__
;
#else
DbmCommitDb (&WenvTkn,       False,    McStat);
#endif
} else {
if (CoreDbs[WenvId] == NullPtr)
DbmLoadDbHdr (&WenvTkn, WenvFileName, McStat, &CoreDbs[WenvId]);
}
}
WriteHdr         = False;
if (Normal(*Status))
SendMsg  (0, "\n\n               ... VORTEx ON LINE ...\n");
if ( Normal(*Status) )
{
AddrTypeTkn = RenvTkn ;
AddrTypeTkn.Handle = AddrType_Hndl ;
if ( OaGetObject(&AddrTypeTkn, McStat, (addrtype *) &EnvType))
EnvType->Size = sizeof( addrtype ) ;
}
TRACK(TrackBak,"Domain_BeHereNow\n");
return (STAT);
}
boolean Domain_MmiInvoke
(char         *Dat_File,         char         *Msg_File,
char         *Out_File,         char         *Xmem_File,
farlongtype   CorePageSize,     farlongtype   CoreMaxOnPage,
indextype     AllocFreeAddrs,   indextype     ExtendFreeAddrs,
indextype     AllocChunks,      indextype     ExtendChunks,
indextype     AllocXmemBlocks,  indextype     ExtendXmemBlocks,
ft F,lt Z,zz *Status)
{
strcpy      (InFileName,  Dat_File);
if ((InFilePtr = fopen(Dat_File, "r")) == NULL)  {
fprintf (stderr, "%s:  can't open PERSONS data file\n",  Dat_File);
exit(1);
}
if ( (MsgFilePtr = fopen (Msg_File, "w")) == NULL)  {
fprintf (stderr, "***ERROR... Can't open MSG file <%s>\n", Msg_File);
exit(1);
}
if ( (OutFilePtr = fopen (Out_File, "w")) == NULL)  {
fprintf (stderr, "***ERROR... Can't open OUT file <%s>\n", Out_File);
exit(1);
}
Core_SetPageSize      (CorePageSize,         CoreMaxOnPage);
Mem_Init              (AllocFreeAddrs,       ExtendFreeAddrs,
Xmem_File,
AllocChunks,          ExtendChunks,
AllocXmemBlocks,      ExtendXmemBlocks);
Domain_ImplodeMemory  (McStat);
TRACK(TrackBak,"Domain_MmiInvoke\n");
return (STAT);
}
boolean Domain_Omi0Invoke
(char         *Dat_File,         char         *Msg_File,
char         *Out_File,         char         *Xmem_File,
farlongtype   CorePageSize,     farlongtype   CoreMaxOnPage,
indextype     AllocFreeAddrs,   indextype     ExtendFreeAddrs,
indextype     AllocChunks,      indextype     ExtendChunks,
indextype     AllocXmemBlocks,  indextype     ExtendXmemBlocks,
indextype     AllocHandles,     indextype     ExtendHandles,
indextype     AllocVchunks,     indextype     ExtendVchunks,
indextype     AllocGrps,        indextype     ExtendGrps,
indextype     AllocDbBlocks,    indextype     ExtendDbBlocks,
char         *ParmsBuf,         ft F,lt Z,zz *Status)
{
Domain_OmiInvoke
(Dat_File,         Msg_File,
Out_File,         Xmem_File,
CorePageSize,     CoreMaxOnPage,
AllocFreeAddrs,   ExtendFreeAddrs,
AllocChunks,      ExtendChunks,
AllocXmemBlocks,  ExtendXmemBlocks,
AllocHandles,     ExtendHandles,
AllocVchunks,     ExtendVchunks,
AllocGrps,        ExtendGrps,
AllocDbBlocks,    ExtendDbBlocks,
McStat);
TraceMsg(0, ParmsBuf);
TRACK(TrackBak,"Domain_Omi0Invoke\n");
return (STAT);
}
boolean Domain_OmiInvoke
(char         *Dat_File,         char         *Msg_File,
char         *Out_File,         char         *Xmem_File,
farlongtype   CorePageSize,     farlongtype   CoreMaxOnPage,
indextype     AllocFreeAddrs,   indextype     ExtendFreeAddrs,
indextype     AllocChunks,      indextype     ExtendChunks,
indextype     AllocXmemBlocks,  indextype     ExtendXmemBlocks,
indextype     AllocHandles,     indextype     ExtendHandles,
indextype     AllocVchunks,     indextype     ExtendVchunks,
indextype     AllocGrps,        indextype     ExtendGrps,
indextype     AllocDbBlocks,    indextype     ExtendDbBlocks,
ft F,lt Z,zz *Status)
{
tokentype    DbTkn  = NullToken;
strcpy      (InFileName,  Dat_File);
if ((InFilePtr = fopen(Dat_File, "r")) == NULL)  {
fprintf (stderr, "%s:  can't open PERSONS data file\n",  Dat_File);
exit(1);
}
if ( (MsgFilePtr = fopen (Msg_File, "w")) == NULL)  {
fprintf (stderr, "***ERROR... Can't open MSG file <%s>\n", Msg_File);
exit(1);
}
if ( (OutFilePtr = fopen (Out_File, "w")) == NULL)  {
fprintf (stderr, "***ERROR... Can't open OUT file <%s>\n", Out_File);
exit(1);
}
Core_SetPageSize      (CorePageSize,         CoreMaxOnPage);
Hm_SetDRIswi          (False);
Mem_Init              (AllocFreeAddrs,       ExtendFreeAddrs,
Xmem_File,
AllocChunks,          ExtendChunks,
AllocXmemBlocks,      ExtendXmemBlocks);
Alloc_Handles           = AllocHandles;
Extend_Handles          = ExtendHandles;
Alloc_Vchunks           = AllocVchunks;
Extend_Vchunks          = ExtendVchunks;
Alloc_Grps              = AllocGrps;
Extend_Grps             = ExtendGrps;
DbXmemBlocks_AllocQty   = AllocDbBlocks;
DbXmemBlocks_ExtendQty  = ExtendDbBlocks;
Alloc_TxtTkns           = 0;
Extend_TxtTkns          = 0;
if (Domain_ImplodeMemory   (McStat))
if (Domain_BeHereNow       (McStat))
{
if (KernelFindIn     (WenvDbs_Hndl,   &WenvTkn,    (addrtype )PrimalNam,
McStat,         &DbTkn))
{
PrimalTkn.DbId   = PrimalId;
PrimalTkn.Handle = 1;
DbmLoadDbHdr       (&PrimalTkn,      PrimalFileName,
McStat,         &CoreDbs[PrimalId]);
} else {
*Status = Env_Normal;
if (KernelCreateDb
(PrimalSchemaNam, PrimalNam,   PrimalFileName,
Read_Write,
McStat,         &PrimalTkn))
#ifdef   __FREEZE_VCHUNKS__
;
#else
DbmCommitDb   (&PrimalTkn,      False,       McStat);
#endif
}
if (Normal(*Status))
EnvMakeCodeChunks (McStat);
}
TRACK(TrackBak,"Domain_OmiInvoke\n");
return (STAT);
}
boolean Domain_Enter
(char         *Subject,   keydomtype    KeyToRealm,
ft F,lt Z,zz *Status)
{
tokentype    DbTkn  = NullToken;
indextype    AllocFreeAddrs    = 2806;
indextype    ExtendFreeAddrs   = 1806;
indextype    AllocChunks       = 10402;
indextype    ExtendChunks      = 10002;
indextype    AllocXmemBlocks   = 1004;
indextype    ExtendXmemBlocks  = 1004;
sizetype     BoolSize          = sizeof (boolean);
if (BoolSize != 2 || Large)
{
AllocChunks          = 20402;
ExtendChunks         = 10002;
AllocXmemBlocks      = 4004;
ExtendXmemBlocks     = 2004;
AllocFreeAddrs       = 2806;
ExtendFreeAddrs      = 1806;
} else {
AllocChunks          = 10402;
ExtendChunks         = 10002;
AllocXmemBlocks      = 1004;
ExtendXmemBlocks     = 1004;
AllocFreeAddrs       = 2806;
ExtendFreeAddrs      = 1806;
}
Core_SetPageSize      (CorePage_Size, CorePage_Size/2);
Mem_Init              (AllocFreeAddrs,       ExtendFreeAddrs,
XmemFile,
AllocChunks,          ExtendChunks,
AllocXmemBlocks,      ExtendXmemBlocks);
if (Large)
{
Alloc_Handles         = 20001;
Extend_Handles        = 10001;
Alloc_Vchunks         = 14003;
Extend_Vchunks        = 10003;
DbXmemBlocks_AllocQty = 8010;
DbXmemBlocks_ExtendQty= 10010;
} else {
Alloc_Handles         = 10401;
Extend_Handles        = 10001;
Alloc_Vchunks         = 20403;
Extend_Vchunks        = 10003;
DbXmemBlocks_AllocQty = 6010;
DbXmemBlocks_ExtendQty= 10010;
}
if (Domain_ImplodeMemory   (McStat))
if (Domain_BeHereNow       (McStat))
if (sprintf  (Msg,
"\n\n               ... VORTEx ON LINE ... Subject <%-12s> Key=%3u\n",
Subject, KeyToRealm))
if (SendMsg  (0, Msg))
{
if (KernelFindIn     (WenvDbs_Hndl,   &WenvTkn,    (addrtype )PrimalNam,
McStat,         &DbTkn))
{
PrimalTkn.DbId   = PrimalId;
PrimalTkn.Handle = 1;
DbmLoadDbHdr       (&PrimalTkn,      PrimalFileName,
McStat,         &CoreDbs[PrimalId]);
} else {
*Status = Env_Normal;
if (KernelCreateDb
(PrimalSchemaNam, PrimalNam,   PrimalFileName,
Read_Write,
McStat,         &PrimalTkn))
#ifdef   __FREEZE_VCHUNKS__
;
#else
DbmCommitDb   (&PrimalTkn,      False,       McStat);
#endif
}
if (Normal(*Status))
EnvMakeCodeChunks (McStat);
}
TRACK(TrackBak,"Domain_EnterDomain\n");
return (STAT);
}
boolean Domain_Exit
(ft F,lt Z,zz *Status)
{
#ifdef   __DISPLAY_TIME__
time_t    Tod        = 0;
time_t    TimeOf     = 0;
time_t    Elapsed    = 0;
float     Seconds    = 0;
time_t    WenvTime   = 0;
time_t    CurrTime   = 0;
double    DblTime    = 0.0;
#endif
int       i          = 0;
if (*Status == Dbe_Exit)
*Status  = Env_Normal;
if (Normal(*Status))
{
#ifdef   __DISPLAY_TIME__
#ifndef     __BMT01__
time (&WenvTime);
#endif
#endif
DbmCommitDb           (&PrimalTkn,    True,    McStat);
DbmCommitDb           (&WenvTkn,      True,    McStat);
DbmFreeDb             (&RenvTkn,      McStat);
#ifndef   __BMT01__
DblTime    = difftime (TIME(&CurrTime), WenvTime);
sprintf  (Msg, "\n Commit PRIMAL, WENV & RENV DB's: %.0f sec\n",
DblTime);
TraceMsg (0,   Msg);
#else
TraceMsg (0, "\n PRIMAL, WENV & RENV DB's committed.\n");
#endif
}
if (Normal(*Status))
{
TraceMsg (0, "\n\n         Env01 Memory Stats\n\n");
CoreShowStats  ();
Mem_ShowStats  ();
Mem_DumpStats  ();
}
SendMsg  (0, "\n\n              ...   END OF SESSION ...\n");
#ifdef __DISPLAY_TIME__
Elapsed    = clock() - Implode_Time;
Seconds    = (float )Elapsed / CLOCKS_PER_SEC;
sprintf  (Msg, "\n RUN TIME = %4.2f\n\n",
Seconds);
TraceMsg (MSGFILE,   Msg);
TimeOf = time (&Tod);
if (sprintf  (Msg, "   time stamp= [%lu] :: %s;       STATUS= %d\n",
(lt64 )TimeOf, ctime (&TimeOf), *Status))
TraceMsg (MSGFILE, Msg);
#else
#endif
sprintf  (Msg, "   STATUS= %d\n", *Status);
TraceMsg   (0, Msg);
for (i=0; i++ < 5; sprintf (Msg, "V O R T E x 0 1!"), TraceMsg(0,Msg)) {};
TraceMsg   (0,          "\n");
StackTrack ("Domain");
fclose     (OutFilePtr);
OutFilePtr = NULL;
fclose     (MsgFilePtr);
MsgFilePtr = NULL;
if (SWAP)
Mem_CloseXmemFile ();
if (DiskFilePtr)
fclose  (DiskFilePtr);
TRACK(TrackBak,"Domain_ExitDomain\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\draw07.c*/

#define DRAW07
/* 当前文件是./CINT2000\255.vortex\src\draw07.h*/

#ifndef DRAW7_07
#define DRAW7_07
#define        Dbl_Pie   (double )3.1415927

typedef  struct varray(short)
{
tokentype             VchunkTkn;
indextype             Vsize;
short*                Varray;
} varray(short);
typedef  struct vchunk(int)
{
tokentype             VchunkTkn;
indextype             Vsize;
int*                  Varray;
indextype             VstackPtr;
} vchunk(int);
typedef   longtype        partidtype;
typedef   char            parttype[10];
typedef   longtype        datetype;

typedef  tokentype   BitField;
typedef    enum colortype   {aBlue,  aGreen,  aRed, aWhite,
aNonColor=EXT_ENUM              } colortype;

#ifndef POINT_01
typedef struct Point
{
addrtype          That;
tokentype         Token;
short            (*Point_x)      (struct Point07 *This);
short            (*Point_y)      (struct Point07 *This);
doubletype       (*Point_Theta)  (struct Point07 *This);
doubletype       (*Point_Radius) (struct Point07 *This);
}Point;
typedef struct CartesianPoint
{
addrtype          That;
tokentype         Token;
short            (*Point_x)      (struct CartesianPoint07 *This);
short            (*Point_y)      (struct CartesianPoint07 *This);
doubletype       (*Point_Theta)  (struct CartesianPoint07 *This);
doubletype       (*Point_Radius) (struct CartesianPoint07 *This);
shorttype         xCoord;
shorttype         yCoord;
}CartesianPoint;
typedef struct PolarPoint
{
addrtype          That;
tokentype         Token;
short            (*Point_x)      (struct PolarPoint07   *This);
short            (*Point_y)      (struct PolarPoint07   *This);
doubletype       (*Point_Theta)  (struct PolarPoint07   *This);
doubletype       (*Point_Radius) (struct PolarPoint07   *This);
doubletype        Theta;
doubletype        Radius;
}PolarPoint;
#endif

typedef struct TestObj
{
addrtype                   That;
tokentype                  Token;
char                       Char_Scalar;
char                       Char_InStruct[32];
unsigned char             *Char_Array;
char                     **Char_PtrArray_Array;
short               Short_Scalar;
unsigned short             ShortU_Scalar;
int                        Int_Scalar;
unsigned                   IntU_Scalar;
lt64                       Long_Scalar;
longtype                   LongU_Scalar;
float                      Float_Scalar;
double                     Double_Scalar;
tokentype                  Token_Scalar;
handletype                 Handle_Scalar;
short                     *Xarray;
short                    **XyCoords;
addrtype                  *Void_Ptr;
colortype                  Color;
XyPoint                    XyOrigin;
Connection                 link[3];
Point                     *Origin;
XyPoint                   *Points;
boolean                    IsActive;
bytetype                  *Byte_Array;
varyingtype                Char_String;
array(short)               Yarray;
varray(short)              xArray;
vchunk(int)                Xcoords;
vchunktoken                XyDir;
BitField                   BitMap;
refobjtype(Point)          RefOrigin;
numtype                    VpartsDir;
grp(tokentype)             VdrawObjDir;
vgrp(Connection)           VconnectsDir;
}TestObj;
boolean   Draw7_Init                       (ft F,lt Z,zz *Status);
boolean   TestObj_InitClass
(ft F,lt Z,zz *Status);
TestObj  *TestObj_new0
(tokentype    *AnchorTkn, ft F,lt Z,zz *Status);
TestObj  *TestObj_new1
(tokentype    *RecTkn,    ft F,lt Z,zz *Status);
void      TestObj_show
(TestObj      *This);
void      TestObj_Topology
(void);
boolean   TestObj_delete
(TestObj     **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status);
#endif
boolean Draw7_Init       (ft F,lt Z,zz *Status)
{
if (ClassBug)
TraceMsg (0, "\n\n  Initialize Test Object...\n\n");
if (TestObj_Class  == 0)
TestObj_InitClass  (McStat);
TRACK(TrackBak,"Draw7_Init\n");
return (STAT);
}
boolean TestObj_InitClass  (ft F,lt Z,zz *Status)
{
if (ClassBug)
TraceMsg (0, "\n\n  TEST OBJ  Map...\n");
if (EnvGetMemberId     ("xCoord",             McStat, &xCoord_Attr))
if (EnvGetMemberId     ("yCoord",             McStat, &yCoord_Attr))
if (EnvGetClassId      ("XyPoint",            McStat, &XyPoint_Class))
if (Normal(*Status))
if (EnvInitClassMap    (XyPoint_Class,        sizeof(XyPoint),
C_Apl,                McStat))
EnvInvokeMap       (C_Apl,                McStat);
if (Normal(*Status))
if (EnvGetMemberId     ("link",               McStat, &link_Attr))
if (EnvGetClassId      ("Connection",         McStat, &Connection_Class))
if (EnvGetMemberId     ("to",                 McStat, &to_Attr))
if (EnvGetMemberId     ("type",               McStat, &type_Attr))
if (EnvGetMemberId     ("length",             McStat, &length_Attr))
if (Normal(*Status))
if (EnvInitClassMap    (Connection_Class,     sizeof(Connection),
C_Apl,                McStat))
EnvInvokeMap       (C_Apl,                McStat);
if (Normal(*Status))
if (EnvGetClassId      ("CartesianPoint",     McStat, &CartesianPoint_Class))
if (EnvGetMemberId     ("Theta",              McStat, &Theta_Attr))
if (EnvGetMemberId     ("Radius",             McStat, &Radius_Attr))
if (EnvGetClassId      ("PolarPoint",         McStat, &PolarPoint_Class))
if (EnvGetMemberId     ("Char_Scalar",        McStat, &Char_Scalar_Attr))
if (EnvGetMemberId     ("Char_InStruct",      McStat, &Char_InStruct_Attr))
if (EnvGetMemberId     ("Char_Array",         McStat, &Char_Array_Attr))
if (EnvGetMemberId     ("Char_PtrArray_Array",McStat,
&Char_PtrArray_Array_Attr))
if (EnvGetMemberId     ("Short_Scalar",       McStat, &Short_Scalar_Attr))
if (EnvGetMemberId     ("ShortU_Scalar",      McStat, &ShortU_Scalar_Attr))
if (EnvGetMemberId     ("Int_Scalar",         McStat, &Int_Scalar_Attr))
if (EnvGetMemberId     ("IntU_Scalar",        McStat, &IntU_Scalar_Attr))
if (EnvGetMemberId     ("Long_Scalar",        McStat, &Long_Scalar_Attr))
if (EnvGetMemberId     ("LongU_Scalar",       McStat, &LongU_Scalar_Attr))
if (EnvGetMemberId     ("Float_Scalar",       McStat, &Float_Scalar_Attr))
if (EnvGetMemberId     ("Double_Scalar",      McStat, &Double_Scalar_Attr))
if (EnvGetMemberId     ("Token_Scalar",       McStat, &Token_Scalar_Attr))
if (EnvGetMemberId     ("Handle_Scalar",      McStat, &Handle_Scalar_Attr))
if (EnvGetMemberId     ("Xarray",             McStat, &Xarray_Attr))
if (EnvGetMemberId     ("XyCoords",           McStat, &XyCoords_Attr))
if (EnvGetMemberId     ("Void_Ptr",           McStat, &Void_Ptr_Attr))
if (EnvGetMemberId     ("Color",              McStat, &Color_Attr))
if (EnvGetMemberId     ("XyOrigin",           McStat, &XyOrigin_Attr))
if (EnvGetMemberId     ("Origin",             McStat, &Origin_Attr))
if (EnvGetMemberId     ("Points",             McStat, &Points_Attr))
if (EnvGetMemberId     ("IsActive",           McStat, &IsActive_Attr))
if (EnvGetMemberId     ("Byte_Array",         McStat, &Byte_Array_Attr))
if (EnvGetMemberId     ("Char_String",        McStat, &Char_String_Attr))
if (EnvGetMemberId     ("Yarray",             McStat, &Yarray_Attr))
if (EnvGetMemberId     ("xArray",             McStat, &xArray07_Attr))
if (EnvGetMemberId     ("Xcoords",            McStat, &Xcoords_Attr))
if (EnvGetMemberId     ("XyDir",              McStat, &XyDir_Attr))
if (EnvGetMemberId     ("BitMap",             McStat, &BitMap_Attr))
if (EnvGetMemberId     ("RefOrigin",          McStat, &RefOrigin_Attr))
if (EnvGetMemberId     ("VpartsDir",          McStat, &VpartsDir_Attr))
if (EnvGetMemberId     ("VdrawObjDir",        McStat, &VdrawObjDir_Attr))
if (EnvGetMemberId     ("VconnectsDir",       McStat, &VconnectsDir_Attr))
EnvGetClassId      ("TestObj",            McStat, &TestObj_Class);
if (Normal(*Status))
if (EnvInitClassMap    (TestObj_Class,        sizeof(TestObj),
C_Apl,                McStat))
{
EnvInvokeMap       (C_Apl,                McStat);
if (LibBug)
TestObj_Topology   ();
}
TRACK(TrackBak,"TestObj_InitClass\n");
return (STAT);
}
TestObj    *TestObj_new0
(tokentype    *AnchorTkn, ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
TestObj        *Image  = NullPtr;
CartesianPoint   *o      = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  TestObj_New0 Anchor= [%4u:%6u]\n",
AnchorTkn->DbId, AnchorTkn->Handle))
TraceMsg (0, Msg);
if (Object_Create    (AnchorTkn,    TestObj_Class,  McStat,   &Token))
if (Object_GetImage  (&Token,       McStat,       (addrtype *)&Image))
{
Image->RefOrigin.ObjAddr = (Point   *)o;
}
STAT;
return (Image);
}
TestObj  *TestObj_new1
(tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
TestObj      *Image  = NullPtr;
Point          *Point0 = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  TestObj_new1 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (RecTkn,       McStat,         (addrtype *)&Image))
if (Image->RefOrigin.ObjTkn.Handle)
if (Object_GetImage (&Image->RefOrigin.ObjTkn, McStat, (addrtype *)&Point0))
Image->RefOrigin.ObjAddr  = Point0;
STAT;
return (Image);
}
void TestObj_show (TestObj   *This)
{
longaddr           StartAddr = 0;
tokentype      Token     = This->Token;
sprintf (Msg, "\n  The  TestObj MAP:: [%2u:%8u]\n",
Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr             = (longaddr )This;
sprintf (Msg,  "  sizeof TestObj            : %3u\n",   sizeof(TestObj));
TraceMsg (0, Msg);
sprintf (Msg,  "  This                      :      @%8x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  "  This->That                : +%3d @%8x   = %x\n",
(char *)&This->That     - StartAddr, &This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Token               : +%3d @%8x   = [%2u:%8u]\n",
(char *)&This->Token    - StartAddr, &This->Token,
This->Token.DbId, This->Token.Handle );
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Char_Scalar         : +%3ld @%x   = %c\n",
(longaddr )&This->Char_Scalar          - StartAddr,
&This->Char_Scalar,                This->Char_Scalar);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Char_InStruct       : +%3ld @%x   = %s\n",
(longaddr )&This->Char_InStruct        - StartAddr,
&This->Char_InStruct,              This->Char_InStruct);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Char_Array          : +%3ld @%x   = @%x\n",
(longaddr )&This->Char_Array           - StartAddr,
&This->Char_Array,                 This->Char_Array);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Char_PtrArray_Array : +%3ld @%x   = @%x\n",
(longaddr )&This->Char_PtrArray_Array  - StartAddr,
&This->Char_PtrArray_Array,        This->Char_PtrArray_Array);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Short_Scalar        : +%3ld @%x   = %d\n",
(longaddr )&This->Short_Scalar         - StartAddr,
&This->Short_Scalar,               This->Short_Scalar);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->ShortU_Scalar       : +%3ld @%x   = %u\n",
(longaddr )&This->ShortU_Scalar        - StartAddr,
&This->ShortU_Scalar,              This->ShortU_Scalar);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Int_Scalar          : +%3ld @%x   = %ld\n",
(longaddr )&This->Int_Scalar           - StartAddr,
&This->Int_Scalar,                 This->Int_Scalar);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->IntU_Scalar         : +%3ld @%x   = %lu\n",
(longaddr )&This->IntU_Scalar          - StartAddr,
&This->IntU_Scalar,                This->IntU_Scalar);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Long_Scalar         : +%3ld @%x   = %ld\n",
(longaddr )&This->Long_Scalar          - StartAddr,
&This->Long_Scalar,                This->Long_Scalar);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->LongU_Scalar        : +%3ld @%x   = %lu\n",
(longaddr )&This->LongU_Scalar         - StartAddr,
&This->LongU_Scalar,               This->LongU_Scalar);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Float_Scalar        : +%3ld @%x   = %f\n",
(longaddr )&This->Float_Scalar         - StartAddr,
&This->Float_Scalar,               This->Float_Scalar);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Double_Scalar       : +%3ld @%x   = %g\n",
(longaddr )&This->Double_Scalar        - StartAddr,
&This->Double_Scalar,              This->Double_Scalar);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Token_Scalar        : +%3ld @%x   = [%4u:%6u]\n",
(longaddr )&This->Token_Scalar         - StartAddr,
&This->Token_Scalar,
This->Token_Scalar.DbId,          This->Token_Scalar.Handle);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Handle_Scalar       : +%3ld @%x   = %lu\n",
(longaddr )&This->Handle_Scalar        - StartAddr,
&This->Handle_Scalar,              This->Handle_Scalar);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Xarray              : +%3ld @%x   = @%x\n",
(longaddr )&This->Xarray               - StartAddr,
&This->Xarray,                     This->Xarray);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->XyCoords            : +%3ld @%x   = @%x\n",
(longaddr )&This->XyCoords             - StartAddr,
&This->XyCoords,                   This->XyCoords);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Void_Ptr            : +%3ld @%x   = %x\n",
(longaddr )&This->Void_Ptr             - StartAddr,
&This->Void_Ptr,                   This->Void_Ptr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Color               : +%3ld @%x   = %u\n",
(longaddr )&This->Color                - StartAddr,
&This->Color,                      This->Color);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->XyOrigin            : +%3ld @%x\n",
(longaddr )&This->XyOrigin             - StartAddr,
&This->XyOrigin,                   This->XyOrigin);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->XyOrigin.xCoord     : +%3ld @%x   = %4u\n",
(longaddr )&This->XyOrigin.xCoord      - StartAddr,
&This->XyOrigin.xCoord,            This->XyOrigin.xCoord);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->XyOrigin.yCoord     : +%3ld @%x   = %4u\n",
(longaddr )&This->XyOrigin.yCoord      - StartAddr,
&This->XyOrigin.yCoord,            This->XyOrigin.yCoord);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->link[0]             : +%3ld @%x   = %x\n",
(longaddr )&This->link[0]              - StartAddr,
&This->link[0],                    This->link[0]);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->link[1]             : +%3ld @%x   = %x\n",
(longaddr )&This->link[1]              - StartAddr,
&This->link[1],                    This->link[1]);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->link[2]             : +%3ld @%x   = %x\n",
(longaddr )&This->link[2]              - StartAddr,
&This->link[2],                    This->link[2]);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Origin              : +%3d @%8x   = %x\n",
(char *)&This->Origin              - StartAddr, &This->Origin,
&This->Origin);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Points              : +%3d @%8x   = %x\n",
(char *)&This->Points              - StartAddr, &This->Points,
&This->Points);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->IsActive            : +%3d @%8x   = %s\n",
(char *)&This->IsActive            - StartAddr, &This->IsActive,
BoolStr[This->IsActive]);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Byte_Array          : +%3ld @%x   = %x\n",
(longaddr )&This->Byte_Array           - StartAddr,
&This->Byte_Array,                 This->Byte_Array);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Char_String         : +%3ld @%x   = %x\n",
(longaddr )&This->Char_String          - StartAddr,
&This->Char_String,                This->Char_String);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->xArray              : +%3ld @%x   = @%x\n",
(longaddr )&This->xArray               - StartAddr,
&This->xArray,                     This->xArray);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->RefOrigin           : +%3d @%8x   = %x\n",
(char *)&This->RefOrigin           - StartAddr, &This->RefOrigin,
&This->RefOrigin);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->RefOrigin.ObjAddr   :                  = %x\n",
This->RefOrigin.ObjAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->RefOrigin.ObjTkn    :                  = [%4u:%6u]\n",
This->RefOrigin.ObjTkn.DbId, This->RefOrigin.ObjTkn.Handle);
TraceMsg (0, Msg);
TraceMsg (0, "\n");
if (This->Token.DbId == 0)
Image_DumpPseudo     (&PrimalTkn,  TestObj_Class,  This);
return;
}
void TestObj_Topology  (void)
{
longaddr           StartAddr = 0;
static   TestObj        That;
static   TestObj       *This      = &That;
TraceMsg (0, "\n\n  <TestObj> TOPOLOGY MAP:: \n");
StartAddr             = (longaddr )This;
sprintf (Msg,  "  sizeof TestObj            : =%3u\n",   sizeof(TestObj));
TraceMsg (0, Msg);
sprintf (Msg,  "  This                      : @%8x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  "  This->That                : +%3ld\n",
(longaddr )&This->That                 - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Token               : +%3ld\n",
(longaddr )&This->Token                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Char_Scalar         : +%3ld\n",
(longaddr )&This->Char_Scalar          - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Char_InStruct       : +%3ld\n",
(longaddr )&This->Char_InStruct        - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Char_Array          : +%3ld\n",
(longaddr )&This->Char_Array           - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Char_PtrArray_Array : +%3ld\n",
(longaddr )&This->Char_PtrArray_Array  - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Short_Scalar        : +%3ld\n",
(longaddr )&This->Short_Scalar         - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->ShortU_Scalar       : +%3ld\n",
(longaddr )&This->ShortU_Scalar        - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Int_Scalar          : +%3ld\n",
(longaddr )&This->Int_Scalar           - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->IntU_Scalar         : +%3ld\n",
(longaddr )&This->IntU_Scalar          - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Long_Scalar         : +%3ld\n",
(longaddr )&This->Long_Scalar          - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->LongU_Scalar        : +%3ld\n",
(longaddr )&This->LongU_Scalar         - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Float_Scalar        : +%3ld\n",
(longaddr )&This->Float_Scalar         - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Double_Scalar       : +%3ld\n",
(longaddr )&This->Double_Scalar        - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Token_Scalar        : +%3ld\n",
(longaddr )&This->Token_Scalar         - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Handle_Scalar       : +%3ld\n",
(longaddr )&This->Handle_Scalar        - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Xarray              : +%3ld\n",
(longaddr )&This->Xarray               - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->XyCoords            : +%3ld\n",
(longaddr )&This->XyCoords             - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Void_Ptr            : +%3ld\n",
(longaddr )&This->Void_Ptr             - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Color               : +%3ld\n",
(longaddr )&This->Color                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->XyOrigin            : +%3ld\n",
(longaddr )&This->XyOrigin             - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->link[0]             : +%3ld\n",
(longaddr )&This->link[0]              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->link[1]             : +%3ld\n",
(longaddr )&This->link[1]              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->link[2]             : +%3ld\n",
(longaddr )&This->link[2]              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Origin              : +%3ld\n",
(longaddr )&This->Origin              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Points              : +%3ld\n",
(longaddr )&This->Points              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->IsActive            : +%3ld\n",
(longaddr )&This->IsActive            - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Byte_Array          : +%3ld\n",
(longaddr )&This->Byte_Array           - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Char_String         : +%3ld\n",
(longaddr )&This->Char_String          - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Yarray              : +%3ld\n",
(longaddr )&This->Yarray               - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->xArray              : +%3ld\n",
(longaddr )&This->xArray               - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Xcoords             : +%3ld\n",
(longaddr )&This->Xcoords              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->XyDir               : +%3ld\n",
(longaddr )&This->XyDir                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->BitMap              : +%3ld\n",
(longaddr )&This->BitMap               - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->RefOrigin           : +%3ld\n",
(longaddr )&This->RefOrigin            - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->VpartsDir           : +%3ld\n",
(longaddr )&This->VpartsDir            - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->VdrawObjDir         : +%3ld\n",
(longaddr )&This->VdrawObjDir          - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->VconnectsDir        : +%3ld\n",
(longaddr )&This->VconnectsDir         - StartAddr);
TraceMsg (0, Msg);
return;
}
boolean TestObj_delete (TestObj   **This,   deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
TestObj   *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  TestObj_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " TestObj [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"TestObj_delete\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\draw7.c*/

#define  DRAW7
boolean Draw7    (tokentype    *Anchor,   boolean       TestBug,
numtype       Option,   ft F,lt Z,zz *Status);

#define Draw7_JumpToEnd   999


boolean Draw7            (tokentype    *Anchor,   boolean       TestBug,
numtype       Option,   ft F,lt Z,zz *Status)
{
tokentype      LibTkn000    = *Anchor;
tokentype      RefTkn       = NullToken;
TestObj       *ref0         = NullPtr;
TestObj       *ref1         = NullPtr;
int            i            = 0;
int            j            = 0;
int            k            = 0;
char         **StrPtrs      = NullPtr;
boolean        Assert       = False;
static
nametype       str1         = "NameType";
numtype        val0         = 6;
numtype        val1         = 5;
tokentype      CurrentTkn   = NullToken;
numtype        NumEntrys    = 0;
tokentype      Vtoken       = NullToken;
tokentype     *ResultsTkns  = NullPtr;
static dbmsquery          *Query0       = NullPtr;
static fieldstruc         *LinkField0   = NullPtr;
static fieldstruc         *LinkField1   = NullPtr;
static fieldstruc         *LinkField2   = NullPtr;
static
numtype        NumNames     = 10;
static  char  *Names[10]    = {"FullFix",     "Pre1111",        "Q2Mid123",
"Pre12Mid12",  "Q1Post",         "Pre12Post",
"Q2Mid123Post","Pre12Mid123Post",
"wildstring",  "stringwild"};
char          *StrAddr      = NullPtr;
short         *ShortArray   = NullPtr;
char                       Char_Scalar           = 'A';
static
nametype                   Char_InStruct         = "nametype string";
unsigned short             ShortU_Scalar         = 10;
signed                     Int_Scalar            = -11;
unsigned                   IntU_Scalar           = 12;
lt64                       Long_Scalar           = -13;
longtype                   LongU_Scalar          = 14;
float                      Float_Scalar          = 15.15;
double                     Double_Scalar         = 16.16;
tokentype                  Token_Scalar          = *Anchor;
handletype                 Handle_Scalar         = 18;
short                      Xarray[5]             = {1,2,3,4,5};
static short               XyCoords[2][5]        = { {-1,-2,-3,-4,-5},
{6,7,8,9,10} };
colortype                  Color                 = aGreen;
static XyPoint             XyOrigin              = {101,102};
static Connection          link[3]               = { {1, "link1", 10},
{2, "link2", 20},
{3, "link3", 30} };
tokentype                  OriginTkn             = NullToken;
CartesianPoint            *Origin                = NullPtr;
XyPoint                   *Points                = NullPtr;
boolean                    IsActive              = True;
bytetype                  *Bytes                 = NullPtr;
static bytetype            Byte_Array[5]         = {10,20,30,40,50};
short                     *Yarray                = NullPtr;
short                     *xArray                = NullPtr;
int                       *Xcoords               = NullPtr;
vchunktoken                XyDirTkn              = NullToken;
int                       *XyDir                 = NullPtr;
tokentype                  BitMapTkn             = NullToken;
Point                     *RefOrigin             = NullPtr;
numtype       GrpNum        = 0;
grpheader    *GrpHdr        = NullPtr;
numtype       GrpIndex      = 0;
sizetype      EntrySize     = sizeof (XyPoint);
numtype       RgnHndls      = 1000;
numtype       AllocRgns     = (RgnHndls / 25) + 27;
numtype       RgnEntrys     = 25;
numtype       AllocXs       = 1000;
numtype       BaseIndex     = 0;
accesstype    AccessType    = Read_Write;
boolean       DiskCache     = False;
numtype       CacheLimit    = 10;
numtype       CacheLoad     = 10;
numtype       NumBuffRgns   = 10;
numtype       BaseRegion    = 0;
numtype       ObjCount      = 0;
static boolean FirstTime    = True;
if (FirstTime)
if (Draw7_Init        (McStat))
if (Env_NewFieldStruc ("link[0]",           McStat,  &LinkField0))
if (Env_NewFieldStruc ("link[1]",           McStat,  &LinkField1))
if (Env_NewFieldStruc ("link[2]",           McStat,  &LinkField2))
{
FirstTime       = False;
if (TestBug)
if (TraceMsg (0, "\n Build a Query for <TestObj>::\n"))
TraceMsg (0, "\n  if(link[1].length >= 3) ::\n");
if (Query_Create         (McStat,      &Query0))
if (Query_BeginBuild     (Query0,       McStat))
if (Query1_ScopeOn       (Query0,      TestObj_Class,  EXCLUSIVE,  McStat))
if (Query_OpenParen      (Query0,       McStat))
if (Query_AffixCompare   (Query0,     "link[1].length",      aGTE,
(addrtype )&val0,        McStat))
if (Query_CloseParen     (Query0,       McStat))
if (Query_EndBuild       (Query0,       McStat))
if (ClassBug || Option < 10)
if (TestBug)
Query_Dump           (Query0);
}
if (Normal(*Status))
{
if (TestBug)
TraceMsg (0, "\n *** Begin test for TestObj\n");
if (Option == 3)
{
Draw701  (Anchor,  TestBug,  1,    McStat);
*Status  = Draw7_JumpToEnd;
} else if (Option == 4) {
Draw701  (Anchor,  TestBug,  2,    McStat);
*Status  = Draw7_JumpToEnd;
} else if (Option == 2)  {
if (Draw701  (Anchor,  TestBug,  1,    McStat))
Draw701  (Anchor,  TestBug,  2,    McStat);
}
}
if (Option == 1
||  Option == 2)
{
if (TestBug)
TraceMsg (0, "\n  Create Object and GET Image.\n");
if (Normal(*Status))
if ((ref0 = TestObj_new0      (&LibTkn000, McStat))!= NullPtr)
{
RefTkn                      = ref0->Token;
if (RefTkn.Handle == 0) TestBug = True;
if (TestBug)
if (TraceMsg (0, "\n Dump Virgin Image\n"))
Object_Dump  (&RefTkn);
ref0->Char_Scalar           = Char_Scalar;
strncpy ((char *)ref0->Char_InStruct,
(char *)Char_InStruct,        sizeof (nametype));
if (Attr_StringCreate (&RefTkn,   Char_Array_Attr,    sizeof (nametype),
McStat,   &StrAddr))
strcpy (StrAddr, str1);
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   Char_PtrArray_Array_Attr,
NumNames,                      sizeof (char *),
McStat,           (addrtype *)&StrPtrs))
for (j= -1; Normal(*Status) && ++j < NumNames; )
{
if (Attr_SubArrayCreate
(&RefTkn,   Char_PtrArray_Array_Attr,   j,
strlen(Names[j])+1,         sizeof (char ),
McStat,           (addrtype *)&StrAddr))
strcpy (StrAddr, Names[j]);
}
if (Normal(*Status))
{
ref0->Short_Scalar       = -ShortU_Scalar;
ref0->ShortU_Scalar      =  ShortU_Scalar;
ref0->Int_Scalar         = Int_Scalar;
ref0->IntU_Scalar        = IntU_Scalar;
ref0->Long_Scalar        = Long_Scalar;
ref0->LongU_Scalar       = LongU_Scalar;
ref0->Float_Scalar       = Float_Scalar;
ref0->Double_Scalar      = Double_Scalar;
ref0->Token_Scalar       = Token_Scalar;
ref0->Handle_Scalar      = Handle_Scalar;
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   Xarray_Attr,
5,                       sizeof (short),
McStat,           (addrtype *)&ShortArray))
for (j= -1; Normal(*Status) && ++j < 5; )
{
ShortArray[j]   = Xarray[j];
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   XyCoords_Attr,
2,                      sizeof (short *),
McStat,           (addrtype *)&ShortArray))
for (j= -1; Normal(*Status) && ++j < 2; )
{
if (Attr_SubArrayCreate
(&RefTkn,   XyCoords_Attr,   j,
5,                      sizeof (short),
McStat,           (addrtype *)&ShortArray))
for (k= -1; Normal(*Status) && ++k < 5; )
{
ShortArray[k]  = XyCoords[j][k];
}
}
if (Normal(*Status))
ref0->Void_Ptr           = NullPtr;
if (Normal(*Status))
{
ref0->Color              = Color;
ref0->XyOrigin           = XyOrigin;
ref0->link[0]            = link[0];
ref0->link[1]            = link[1];
ref0->link[2]            = link[2];
}
if (Normal(*Status))
if (Object_NewImage   (&RefTkn,   CartesianPoint_Class,  McStat,
&OriginTkn,         (addrtype  *)&Origin))
{
Origin->xCoord  = 24;
Origin->yCoord  = 240;
#ifdef Generic_Use
Attr_ValuePut   (&RefTkn,   Origin_Attr,
(addrtype )Origin,                McStat);
#else
Attr_ObjTknPut  (&RefTkn,   Origin_Attr,          &Origin->Token,
McStat);
#endif
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   Points_Attr,
2,                      sizeof (XyPoint),
McStat,           (addrtype *)&Points))
{
Points[0].xCoord  = 26;
Points[0].yCoord  = -26;
Points[1].xCoord  = 126;
Points[1].yCoord  = -126;
}
if (Normal(*Status))
ref0->IsActive           = IsActive;
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   Byte_Array_Attr,
5,                      sizeof (bytetype),
McStat,           (addrtype *)&Bytes))
for (j= -1; Normal(*Status) && ++j < 5; )
{
Bytes[j]   = Byte_Array[j];
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   Yarray_Attr,
5,                      sizeof (short),
McStat,           (addrtype *)&Yarray))
for (j= -1; Normal(*Status) && ++j < 5; )
{
Yarray[j]   = Xarray[j];
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   xArray07_Attr,
5,                      sizeof (short),
McStat,           (addrtype *)&xArray))
if (Vchunk_PutStackPtr (&(ref0->xArray.VchunkTkn),  5,
McStat,           (addrtype *)&xArray))
ref0->xArray.Vsize  = 5;
for (j= -1; Normal(*Status) && ++j < 5; )
{
xArray[j]   = Xarray[j];
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   Xcoords_Attr,
5,                      sizeof (int),
McStat,           (addrtype *)&Xcoords))
if (Vchunk_PutStackPtr (&(ref0->Xcoords.VchunkTkn),  5,
McStat,           (addrtype *)&Xcoords))
ref0->Xcoords.VstackPtr  = 5;
for (j= -1; Normal(*Status) && ++j < 5; )
{
Xcoords[j]   = Xarray[j];
}
if (Normal(*Status))
if (Vchunk_Create     (&RefTkn,   sizeof (int),     5,     10,
McStat,          &XyDirTkn))
if (Attr_ValuePut     (&RefTkn,   XyDir_Attr,
(addrtype )&XyDirTkn,                McStat))
if (Vchunk_PutStackPtr(&XyDirTkn, 5,     McStat, (addrtype *)&XyDir))
for (j= -1; Normal(*Status) && ++j < 5; )
{
XyDir[j]   = Xarray[j];
}
if (Normal(*Status))
if (BitField_Create   (&RefTkn,   10,    McStat,          &BitMapTkn))
if (Attr_ValuePut     (&RefTkn,   BitMap_Attr,
(addrtype )&BitMapTkn,               McStat))
for (j= -1; Normal(*Status) && ++j < 10; ++j)
{
BitField_Put      (&BitMapTkn,       j,     1,         McStat);
}
if (Normal(*Status))
if (Attr_RefTknPut    (&RefTkn,   RefOrigin_Attr,          &OriginTkn,
McStat))
if (Attr_TokenToRef   (&RefTkn,   RefOrigin_Attr,
McStat,                 (addrtype *)&RefOrigin))
if (RefOrigin != (Point   *)Origin)
TraceMsg (0, "  ***SWIzzle MisMatch on Reference Token value.\n");
if (Normal(*Status))
if (TestBug)
if (GrpNewPacket      (&RefTkn,   EntrySize,   AllocRgns,   RgnEntrys,
AllocXs,   BaseIndex,   AccessType,  DiskCache,
CacheLimit,CacheLoad,   NumBuffRgns,
McStat,   &GrpNum,     &GrpHdr,     &BaseRegion))
if (Attr_ValuePut     (&RefTkn,   VpartsDir_Attr,(addrtype)&GrpNum,
McStat))
for (j= -1; Normal(*Status) && ++j < 100; ++j)
{
Grp_PutNewEntry    (&RefTkn,   GrpNum,       (addrtype )&j,
McStat,   &GrpIndex);
}
if (Normal(*Status))
if (TestBug)
{
sprintf (Msg, " TestObj %4u created. Token[%3u:%8u] @%6x.\n",
i, ref0->Token.DbId, ref0->Token.Handle, ref0);
TraceMsg (0, Msg);
TraceMsg (0, "\n Current State of Image (before Commit)\n");
Object_Dump        (&RefTkn);
Object_Dump        (&OriginTkn);
}
}
i = 0;
if (Normal(*Status))
{
if (TestBug)
TraceMsg (0, "\n  Commit TestObj (and sub-structs) to the DB.\n");
if (TestObj_delete      (&ref0,       dbCommit,   McStat))
if (Object_CommitImage  (&OriginTkn,  True,       McStat))
if (TestBug)
{
TraceMsg (0, "\n Current State of Image (after Commit/release)\n");
Object_Dump          (&RefTkn);
Object_Dump          (&OriginTkn);
}
}
if (Normal(*Status))
{
sprintf (Msg, "\n Retrieve TestObj #%4u From Db with RefTkn\n",i);
if (TestBug)
TraceMsg (0, Msg);
if ((ref1  = TestObj_new1   (&RefTkn,     McStat))!= NullPtr)
{
if (RefTkn.DbId      != ref1->Token.DbId
||  RefTkn.Handle    != ref1->Token.Handle)
{
sprintf (Msg,
"\n ***ERROR...  [%4u:%8u] Retrieved as ref1->Token[%3u:%8u]\n",
RefTkn.DbId, RefTkn.Handle,
ref1->Token.DbId, ref1->Token.Handle);
TraceMsg (0, Msg);
} else if (TestBug) {
sprintf (Msg, " TestObj Retrieved. Token[%3u:%8u] @%6x.\n",
ref1->Token.DbId, ref1->Token.Handle, ref1);
TraceMsg (0, Msg);
}
if (TestBug)
{
Object_Dump    (&RefTkn);
sprintf (Msg, " Current State of OriginTkn[%3u:%8u]\n",
OriginTkn.DbId, OriginTkn.Handle);
TraceMsg (0, Msg);
Object_Dump    (&OriginTkn);
TraceMsg (0, "\n DeReference The RefOrigin Attribute Value\n");
}
if (Attr_TokenToRef
(&RefTkn,   RefOrigin_Attr,
McStat,                 (addrtype *)&RefOrigin))
if (TestBug)
{
sprintf (Msg, " State of OriginTkn[%3u:%8u] AFTER DeReferenced.\n",
ref1->RefOrigin.ObjTkn.DbId,
ref1->RefOrigin.ObjTkn.Handle);
TraceMsg (0, Msg);
Object_Dump    (&ref1->RefOrigin.ObjTkn);
}
if (TestBug)
TestObj_show          (ref1);
}
if (Normal(*Status))
{
sprintf (Msg, "\n TestObj FREE. Token[%3u:%8u].\n",
ref1->Token.DbId, ref1->Token.Handle);
if (TestBug)
TraceMsg (0, Msg);
if (LibTkn000.DbId  != PrimalTkn.DbId)
TestObj_delete (&ref1, dbFree,  McStat);
}
if (Normal(*Status))
if (TestBug)
Object_Dump    (&RefTkn);
}
}
if (Normal(*Status))
if (Option == 2)
{
sprintf (Msg, "\n  Assert As :: %4u .%s.  %4u\n",
val0, CompareOpName[aGTE], val1);
if (TestBug)
TraceMsg (0, Msg);
Assert = Query_AssertOnObject
(&RefTkn,   Query0,         McStat);
sprintf (Msg, "\n Assert on Object [%4u:%6u] = %s\n",
RefTkn.DbId, RefTkn.Handle, BoolStr[Assert]);
if (TestBug)
TraceMsg (0, Msg);
if (Normal(*Status))
*Status  = Draw7_JumpToEnd;
}
if (Option == 0)
if (Normal(*Status))
{
if (TestBug)
if (sprintf  (Msg, "\n Query_AssertOnDb [%3u:%8u] ::\n",
LibTkn000.DbId, LibTkn000.Handle))
TraceMsg (0,   Msg);
if (Primal_GetClassObjectCount
(&LibTkn000,  TestObj_Class,
McStat,     &ObjCount))
if (Query_AssertOnDb     (&LibTkn000,  Query0,
McStat,     &NumEntrys, &Vtoken))
TestObj_Asserts      += NumEntrys;
TestObj_NullAsserts  += (ObjCount - NumEntrys);
j        = -1;
if (Normal(*Status))
if (NumEntrys)
if (TestBug)
if (sprintf  (Msg, "\n Activate/Free Vchunk [%3u:%8u] references ::\n",
Vtoken.DbId, Vtoken.Handle))
TraceMsg (0,   Msg);
if (Normal(*Status))
if (NumEntrys)
if (Vchunk_GetAddress    (&Vtoken,
McStat,     (addrtype *)&ResultsTkns))
while (Normal(*Status)
&&   ++j     < NumEntrys)
{
CurrentTkn      = ResultsTkns[j];
if (TestBug)
{
sprintf (Msg, " Query Result for ItNum=%4u. Token[%3u:%8u].\n",
j, CurrentTkn.DbId, CurrentTkn.Handle);
TraceMsg (0, Msg);
if (Object_GetImage  (&CurrentTkn,  McStat,  (addrtype *)&ref1))
if (TestBug)
if (j == 0 || j % 1 == 0)
{
sprintf (Msg, " ItNum %4u. Token[%3u:%8u]. Char_InStruct= %s\n",
j+1, CurrentTkn.DbId, CurrentTkn.Handle,
ref1->Char_InStruct);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (LibTkn000.DbId  != PrimalTkn.DbId)
Object_FreeImage  (&CurrentTkn,  McStat);
}
}
if (Normal(*Status))
if (Vchunk_IsValidToken (&Vtoken, McStat))
Vchunk_Delete (&Vtoken,  McStat);
}
if (*Status  == Draw7_JumpToEnd)
*Status   = Env_Normal;
if (Normal(*Status))
if (TestBug)
{
TraceMsg (0, "\n Commit all objects that were instantiated\n");
if (PrimalTkn.DbId != LibTkn000.DbId)
Primal_CommitDb  (&LibTkn000,   "\0", True,   McStat);
}
TRACK(TrackBak,"Draw7\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\drawlib.c*/

#define DRAWLIB
#define   Random(Limit)   (RANDOM_FUNC () & (Limit -1))


boolean DrawLib_InitLibrary
(ft F,lt Z,zz *Status)
{
if (DrawLib_Class == 0)
{
TraceMsg (0, "\n Initialize the Class maps\n");
if (List01_Init                             (McStat))
if (DrawLib_InitClass                       (McStat))
if (DrawObj_InitClass                       (McStat))
if (NamedDrawObj_InitClass                  (McStat))
if (LibRectangles_InitClass                 (McStat))
if (Point_InitClass                         (McStat))
if (CartesianPoint_InitClass                (McStat))
if (PolarPoint_InitClass                    (McStat))
if (Rectangle_InitClass                     (McStat))
Rects_InitLibrary                       (McStat);
if (Normal(*Status))
Draw7_Init                              (McStat);
}
LibBug = False;
TRACK(TrackBak,"DrawLib_InitLibrary\n");
return (STAT);
}
boolean DrawLib_InitClass  (ft F,lt Z,zz *Status)
{
if (DrawLib_Class  == 0)
{
if (EnvGetMemberId     ("DrawId",             McStat, &DrawId_Attr))
if (EnvGetMemberId     ("DrawObjDir",         McStat, &DrawObjDir_Attr))
if (EnvGetMemberId     ("VdrawObjDir",        McStat, &VdrawObjDir_Attr))
EnvGetClassId      ("DrawLib",      McStat, &DrawLib_Class);
}
if (Normal(*Status))
if (EnvInitClassMap    (DrawLib_Class,       sizeof(DrawLib),
C_Apl,               McStat))
EnvInvokeMap       (C_Apl,               McStat);
if (Normal(*Status))
if (DrawObjs_InitClass                      (McStat))
if (NamedDrawObjs_InitClass                 (McStat))
LibRectangles_InitClass                 (McStat);
TRACK(TrackBak,"DrawLib_InitClass\n");
return (STAT);
}
boolean DrawLib_InitDb   (char         *DbName,  char         *DbFileName,
numtype       Option,
ft F,lt Z,zz *Status,  tokentype    *PrimalTkn)
{
numtype        RgnEntries      = 0;
DrawLib_InitLibrary    (McStat);
if (Normal(*Status))
if (!DrawLib_ActivateDbByName
(DbName,       DbFileName,      Read_Write,
McStat,      &DrawLib01))
{
*Status        = Env_Normal;
if (Option    > 10000)
RgnEntries = Option;
else
RgnEntries = 10000;
if (DrawLib_CreateDb
(DbName,    DbFileName,
Read_Write,
RgnEntries,    RgnEntries*3,
10000,         10000,
10010,         10000,
McStat,        PrimalTkn,    &DrawLib01))
Primal_ConfigYourClass
(PrimalTkn,    DrawObj_Class,  1000, 20, 10,
10000,   1000, Read_Write,    True, 20, 20, McStat);
} else
*PrimalTkn  =  DrawLib01->Token;
TRACK(TrackBak,"DrawLib_InitDb\n");
return (STAT);
}
boolean DrawLib_QueryDb
(char         *DbName,
ft F,lt Z,zz *Status,    boolean      *Active)
{
if (ClassBug || DeBug > 0)
if (sprintf  (Msg, "  DrawLib_QueryDb:: <%21s>\n",
DbName))
*Active    = False;
*Status    = Err_NotImplemented;
TRACK(TrackBak,"DrawLib_QueryDb\n");
return (STAT);
}
boolean DrawLib_CreateDb
(char         *DbName,    char         *DbFileName,
dbaccesstype  DbAccess,
numtype       HndlRgns,  numtype       RgnHndls,
numtype       VhndlRgns, numtype       RgnVhndls,
numtype       XmemRgns,  numtype       RgnXmems,
ft F,lt Z,zz *Status,
tokentype    *PrimalTkn, DrawLib     **PrimalObj)
{
numtype       GrpNum       = 0;
tokentype     GrpTkn       = NullToken;
grpheader    *GrpHdr       = NullPtr;
sizetype      EntrySize    = sizeof (handletype);
numtype       AllocRgns    = (RgnHndls / 125) + 27;
numtype       RgnEntrys    = 125;
numtype       AllocXs      = 1000;
numtype       BaseIndex    = 2;
accesstype    AccessType   = Read_Write;
boolean       DiskCache    = True;
numtype       CacheLimit   = AllocRgns / 10;
numtype       CacheLoad    = AllocRgns / 10;
numtype       NumBuffRgns  = AllocRgns;
numtype       BaseRegion   = 0;
tokentype     TreeTkn1     = NullToken;
tokentype     TreeTkn2     = NullToken;
attrobjtype   AttrDesc;
sizetype      KeySize      = 0;
typetype      KeyType      = aInteger;
numtype       TreeOrder    = 100;
if (ClassBug)
if (sprintf(Msg, "  DrawLibCreate:: Db= '%32s'; Handles Per Region=%4u\n",
DbName,  RgnHndls))
TraceMsg (0, Msg);
if (Primal_CreateDb ("DrawSchema", DbName,     DbFileName,  DbAccess,
HndlRgns,     RgnHndls,   VhndlRgns,   RgnVhndls,
XmemRgns,     RgnXmems,   McStat,      PrimalTkn))
if (ClassBug)
Object_Dump (PrimalTkn);
if (Normal(*Status))
if (GrpNewPacket    (PrimalTkn, EntrySize,   AllocRgns,   RgnEntrys,
AllocXs,   BaseIndex,   AccessType,  DiskCache,
CacheLimit,CacheLoad,   NumBuffRgns,
McStat,   &GrpNum,     &GrpHdr,     &BaseRegion))
{
GrpTkn.DbId     = PrimalTkn->DbId;
GrpTkn.Handle   = GrpNum;
Attr_ValuePut   (PrimalTkn, DrawObjDir_Attr,(addrtype)&GrpTkn,
McStat);
}
#ifndef   __FREEZE_VCHUNKS__
if (Normal(*Status))
PrimalCommitDb   (PrimalTkn,   "\0",     False,      McStat);
#endif
if (RgnHndls == 20001)
return (STAT);
if (Normal(*Status))
if (Object_GetImage (PrimalTkn,      McStat,  (addrtype *)PrimalObj))
if (SetInitSet      (DrawObjs_Set,           PrimalTkn,   RgnHndls, 10,
McStat))
if (Env_GetAttrInfo    (Nam_AttrNum,   McStat,  &AttrDesc))
{
KeySize    = AttrDesc.Size;
KeyType    = AttrDesc.TypeType;
Tree_Create     (NamedDrawObjs_Set,      PrimalTkn,   TreeOrder,
RgnHndls,               KeySize,     KeyType,
McStat,                &TreeTkn1);
}
if (Normal(*Status))
{
(*PrimalObj)->OwnerNamedDrawObjs = TreeTkn1.Handle;
GrpHdr->EnvObjType         = EnvType_AttrNum;
VpartsDir                  = GrpNum;
sprintf (Msg, "   DrawLibCreate:: Db[%3u]; VpartsDir=%4u\n",
PrimalTkn->DbId,  VpartsDir);
TraceMsg (0, Msg);
if (ClassBug)
{
Object_Dump (PrimalTkn);
Object_Dump (&TreeTkn1);
}
}
if (Normal(*Status))
{
if (Object_CommitImage
(PrimalTkn,   False,               McStat))
#ifndef   __FREEZE_VCHUNKS__
if (PrimalCommitDb  (PrimalTkn,   "\0",     False,     McStat))
if (ClassBug)
Object_Dump (PrimalTkn);
#endif
if (Normal(*Status))
Object_GetImage   (PrimalTkn,   McStat,  (addrtype *)PrimalObj);
DrawLib01         = *PrimalObj;
Print_Msg         = True;
WriteHdr          = False;
} else if (*Status    == Csh_DbAlreadyExists) {
*Status               = Env_Normal;
if (Object_GetImage     (PrimalTkn,    McStat,    (addrtype *)PrimalObj))
if (GrpGetPacket        (PrimalTkn,  (*PrimalObj)->DrawObjDir.Handle,
McStat,                             &GrpHdr))
{
VpartsDir         = (*PrimalObj)->DrawObjDir.Handle;
DrawLib01         = *PrimalObj;
}
}
if (ClassBug)
Object_Dump (PrimalTkn);
if (Normal(*Status))
if (ClassBug)
if (TraceMsg (0, "\n DUMP VpartsDir Grp Struct::\n"))
Grp_DumpStruct (PrimalTkn,  VpartsDir,  McStat);
TRACK(TrackBak,"DrawLib_CreateDb\n");
return (STAT);
}
boolean DrawLib_ActivateDbByName
(char         *DbName,    char         *DbFileName,
dbaccesstype  AccessType,
ft F,lt Z,zz *Status,    DrawLib     **PrimalObj)
{
grpheader    *GrpHdr         = NullPtr;
if (ClassBug || DeBug > 0)
if (sprintf  (Msg, "  DrawLib_ActivateDbByName:: <%21s>\n",
DbName))
if (TraceMsg (0, Msg))
if (sprintf  (Msg, "                 FileName := <%21s>; Access=%s\n",
DbFileName, DbAccessStr[AccessType]))
TraceMsg  (0, Msg);
*PrimalObj = NullPtr;
if (!Primal_ActivateDbByName
(DbName,    DbFileName, AccessType,
McStat,               &LibTkn010))
return (False);
if (Object_GetImage   (&LibTkn010,    McStat, (addrtype *)PrimalObj))
if ((*PrimalObj)->DrawObjDir.Handle != 0)
if (GrpGetPacket      (&LibTkn010, (*PrimalObj)->DrawObjDir.Handle,
McStat,               &GrpHdr))
VpartsDir          = (*PrimalObj)->DrawObjDir.Handle;
DrawLib01          = *PrimalObj;
if (Normal(*Status))
if (ClassBug)
if (TraceMsg (0, "\n DUMP VpartsDir Grp Struct::\n"))
Grp_DumpStruct (&LibTkn010,  VpartsDir,  McStat);
TRACK(TrackBak,"DrawLib_ActivateDbByName\n");
return (STAT);
}
boolean DrawLib_ActivateDbByToken
(tokentype    *PrimalTkn, char         *DbFileName,
dbaccesstype  AccessType,
ft F,lt Z,zz *Status,    DrawLib     **PrimalObj)
{
grpheader    *GrpHdr         = NullPtr;
char     FileName[128];
strcpy (FileName, "\0");
if (DbFileName  != NullPtr)
strcpy (FileName, DbFileName);
if (ClassBug || DeBug > 0)
if (sprintf  (Msg, "  DrawLibActivate:: [%3u:%8u]  DbFile= '%32s'\n",
PrimalTkn->DbId, PrimalTkn->Handle,  FileName))
TraceMsg  (0, Msg);
if (!Primal_ActivateDbByToken
(PrimalTkn,    DbFileName,  AccessType, McStat))
return (False);
if (Normal(*Status))
Object_GetImage     (PrimalTkn,    McStat,    (addrtype *)PrimalObj);
if (Normal(*Status))
if ((*PrimalObj)->DrawObjDir.Handle != 0)
if (GrpGetPacket      (PrimalTkn,  (*PrimalObj)->DrawObjDir.Handle,
McStat,               &GrpHdr))
VpartsDir          = (*PrimalObj)->DrawObjDir.Handle;
DrawLib01          = *PrimalObj;
if (Normal(*Status))
if (ClassBug)
if (TraceMsg (0, "\n DUMP VpartsDir Grp Struct::\n"))
Grp_DumpStruct (&LibTkn010,  VpartsDir,  McStat);
TRACK(TrackBak,"DrawLib_ActivateDbByToken\n");
return (STAT);
}
boolean DrawLib_DeleteDb (tokentype    *PrimalTkn, ft F,lt Z,zz *Status)
{
if (ClassBug || DeBug > 0)
if (sprintf  (Msg, "  DrawLib_DeleteDb:: [%3u:%8u]\n",
PrimalTkn->DbId, PrimalTkn->Handle))
TraceMsg  (0, Msg);
*Status = Err_NotImplemented;
TRACK(TrackBak,"DrawLib_DeleteDb\n");
return (STAT);
}
numtype DrawLib_NewId    (ft F,lt Z,zz *Status)
{
numtype    NewId    = 0;
boolean    NotFound = True;
tokentype  FoundTkn = NullToken;
if (ClassBug || DeBug > 0)
if (sprintf  (Msg, "  DrawLib_NewId:: [%3u:%8u]\n",
LibTkn010.DbId, LibTkn010.Handle))
TraceMsg  (0, Msg);
NewId        = ++DrawLib01->DrawId;
NotFound     = False;
while (Normal(*Status)
&&     NotFound)
{
NewId        = Random((1024*256)) + 1;
DrawObjs_FindIn   (&LibTkn010,  (addrtype )&NewId,
McStat,                 &FoundTkn);
if (*Status     == Set_EmptySet
||  *Status     == Set_EndOfSet
||  *Status     == Set_NotFound)
{
*Status       = Env_Normal;
NotFound     = False;
if (NewId    > DrawLib01->DrawId)
DrawLib01->DrawId = NewId;
} else if (*Status   == Set_AlreadyInSet)
*Status       = Env_Normal;
}
return (NewId);
}
/* 当前文件是./CINT2000\255.vortex\src\drawobj.c*/

#define DRAWOBJ
boolean DrawObj_InitClass  (ft F,lt Z,zz *Status)
{
if (DrawObj_Class  == 0)
{
if (Env_GetAttrId      ("PartObjSlotAttr", McStat, &PartObj_Slot))
if (Env_GetAttrId      ("DrawObjSlotAttr", McStat, &DrawObj_Slot))
if (EnvGetMemberId     ("Id",              McStat, &Id_Attr))
if (EnvGetMemberId     ("MemberDrawObjs",  McStat, &MemberDrawObjs_Attr))
EnvGetClassId      ("DrawObj",      McStat, &DrawObj_Class);
}
if (Normal(*Status))
if (DrawObjs_InitClass (McStat))
if (EnvInitClassMap    (DrawObj_Class,       sizeof(DrawObj),
C_Apl,               McStat))
EnvInvokeMap       (C_Apl,               McStat);
TRACK(TrackBak,"DrawObj_InitClass\n");
return (STAT);
}
DrawObj  *DrawObj_new0   (tokentype    *AnchorTkn, ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
DrawObj        *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  DrawObj_New0 Anchor= [%4u:%6u]\n",
AnchorTkn->DbId, AnchorTkn->Handle))
TraceMsg (0, Msg);
if (Object_Create   (AnchorTkn,    DrawObj_Class,    McStat,   &Token))
if (Object_GetImage (&Token,       McStat,         (addrtype *)&Image))
{
if (DrawLib01)
Image->Id       = ++DrawLib01->DrawId;
Image->draw                = NULL;
Image->area                = NULL;
Image->destruct            = DrawObj_delete;
}
if (Normal(*Status))
DrawObjs_AddInto (&LibTkn010,  &Token,  McStat);
STAT;
return (Image);
}
DrawObj  *DrawObj_new1   (tokentype    *AnchorTkn, numtype       ClassId,
ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
DrawObj        *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  DrawObj_New1 Anchor= [%4u:%6u]; ClassId=%4u\n",
AnchorTkn->DbId, AnchorTkn->Handle, ClassId))
TraceMsg (0, Msg);
if (Object_Create   (AnchorTkn,    ClassId,          McStat,   &Token))
if (Object_GetImage (&Token,       McStat,         (addrtype *)&Image))
{
if (DrawLib01)
Image->Id       = ++DrawLib01->DrawId;
Image->draw                = NULL;
Image->area                = NULL;
Image->destruct            = DrawObj_delete;
}
if (Normal(*Status))
DrawObjs_AddInto (&LibTkn010,  &Token,  McStat);
STAT;
return (Image);
}
DrawObj  *DrawObj_new2   (tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
DrawObj      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  DrawObj_new2 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (RecTkn,       McStat,         (addrtype *)&Image))
{
Image->draw                = NULL;
Image->area                = NULL;
Image->destruct            = DrawObj_delete;
}
STAT;
return (Image);
}
boolean     DrawObj_import
(DrawObj      *This,      ft F,lt Z,zz *Status)
{
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n DrawObj: import; Id =%3u\n", This->Id))
TraceMsg (0, Msg);
return (STAT);
}
boolean     DrawObj_export
(DrawObj      *This, ft F,lt Z,zz *Status)
{
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n DrawObj: export; Id =%3u\n", This->Id))
TraceMsg (0, Msg);
return (STAT);
}
boolean DrawObj_draw     (DrawObj      *This,      ft F,lt Z,zz *Status)
{
if (This->draw)
return  (This->draw       (This,     McStat));
else {
STAT;
return  (False);
}
}
lt64    DrawObj_area     (DrawObj      *This,      ft F,lt Z,zz *Status)
{
if (This->draw)
return  (This->area       (This,     McStat));
else {
STAT;
return  (False);
}
}
boolean DrawObj_delete   (DrawObj     **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
DrawObj   *That  = *This;
if (That->destruct != DrawObj_delete)
return  (That->destruct     (This,     DbEvent,   McStat));
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  DrawObj_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " DrawObj [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"DrawObj_delete\n");
return (STAT);
}
boolean DrawObj_Create0  (tokentype    *Anchor,
ft F,lt Z,zz *Status,    tokentype    *Token)
{
numtype    DrawId   =  0;
if (DrawLib01)
DrawId   =  ++DrawLib01->DrawId;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n DrawObj:: Create [%3u:%8u]\n",
Anchor->DbId,  Anchor->Handle))
TraceMsg (0, Msg);
if (Object_Create   (Anchor, DrawObj_Class,          McStat, Token))
Attr_ValuePut   (Token,  Id_Attr,    (addrtype )&DrawId,     McStat);
TRACK(TrackBak,"DrawObj_Create0\n");
return (STAT);
}
boolean DrawObj_Create1  (tokentype    *Anchor,    numtype       ClassId,
ft F,lt Z,zz *Status,    tokentype    *Token)
{
numtype    DrawId   =  ++DrawLib01->DrawId;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n DrawObj:: Create [%3u:%8u];  ClassId=%4u\n",
Anchor->DbId,  Anchor->Handle, ClassId))
TraceMsg (0, Msg);
if (Object_Create   (Anchor, ClassId,                McStat, Token))
if (Attr_ValuePut   (Token,  Id_Attr,    (addrtype )&DrawId, McStat))
SetAddInto       (DrawObjs_Set,      &LibTkn010,  Token,  McStat);
TRACK(TrackBak,"DrawObj_Create1\n");
return (STAT);
}
boolean DrawObj_Import   (tokentype    *DrawTkn,    ft F,lt Z,zz *Status)
{
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n DrawObj:: Import [%3u:%8u]\n",
DrawTkn->DbId,  DrawTkn->Handle))
TraceMsg (0, Msg);
TRACK(TrackBak,"DrawObj_Import\n");
return (STAT);
}
boolean DrawObj_Export   (tokentype    *DrawTkn,    ft F,lt Z,zz *Status)
{
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n DrawObj:: Export [%3u:%8u]\n",
DrawTkn->DbId,  DrawTkn->Handle))
TraceMsg (0, Msg);
TRACK(TrackBak,"DrawObj_Export\n");
return (STAT);
}
boolean DrawObjs_InitClass (ft F,lt Z,zz *Status)
{
if (ClassBug)
TraceMsg (0, " DrawObjs::InitClass...\n");
if (!DrawObjs_Set)
if (EnvGetMemberId    ("OwnerDrawObjs",
McStat,               &OwnerDrawObjs_Attr))
if (EnvGetMemberId    ("MemberDrawObjs",
McStat,               &MemberDrawObjs_Attr))
EnvGetSetId       ("DrawObjs",
McStat,               &DrawObjs_Set);
TRACK(TrackBak,"DrawObjs_InitClass\n");
return (STAT);
}
boolean OwnerOfDrawObjs (tokentype *Member,
ft F,lt Z,zz *Status,    tokentype *Owner)
{
Member_SetOwnerOf (DrawObjs_Set, Member, McStat, Owner);
TRACK(TrackBak,"OwnerOfDrawObjs\n");
return (STAT);
}
boolean DrawObjs_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status)
{
SetAddInto (DrawObjs_Set, OwnerTkn, MemberTkn, McStat);
TRACK(TrackBak,"DrawObjs_AddInto\n");
return (STAT);
}
boolean DrawObjs_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn)
{
SetFindIn  (DrawObjs_Set,      OwnerTkn,   KeyValue,
McStat,            MemberTkn);
TRACK(TrackBak,"FindInDrawObjs\n");
return (STAT);
}
inttype DrawObjs_IterateOn
(tokentype    *OwnerTkn,  inttype       ItNum,
ft F,lt Z,zz *Status,
tokentype    *NodeTkn,   tokentype    *Token)
{
tokentype    CurrTkn = *NodeTkn;
if (ItNum == 0)
SetFirstOf (DrawObjs_Set,  OwnerTkn, McStat, NodeTkn, Token);
else
SetNextOf  (DrawObjs_Set, &CurrTkn,  McStat, NodeTkn, Token);
if (Normal(*Status))
ItNum++;
else if (*Status == Set_EndOfSet)
{
*Status = Env_Normal;
ItNum  *= -1;
} else if (*Status == Set_EmptySet)  {
*Status = Env_Normal;
ItNum   = -1;
}
STAT;
return (ItNum);
}
boolean NamedDrawObj_InitClass
(ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
NamedDrawObj    Named;
if (NamedDrawObj_Class == 0)
{
if (EnvGetMemberId     ("Nam",          McStat, &Nam_Attr))
if (EnvGetMemberId     ("MemberNamedDrawObjs",
McStat, &MemberNamedDrawObjs_Attr))
EnvGetClassId      ("NamedDrawObj", McStat, &NamedDrawObj_Class);
}
StartAddr   = (longaddr)&Named;
if (Normal(*Status))
if (NamedDrawObjs_InitClass                 (McStat))
if (EnvInitClassMap    (NamedDrawObj_Class,  sizeof(NamedDrawObj),
C_Apl,               McStat))
{
Offset    = (size_t)((longaddr )&Named.That    -  StartAddr);
if (Env_AppendToMap    (That_AttrNum,          Offset,     McStat))
Offset = (size_t)((longaddr )&Named.Token   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Token_Attr,            Offset,     McStat))
Offset = (size_t)((longaddr )&Named.Id      -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Id_Attr,               Offset,     McStat))
Offset = (size_t)((longaddr )&Named.MemberDrawObjs  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (MemberDrawObjs_Attr,   Offset,     McStat))
Offset = (size_t)((longaddr )&Named.PartObjSlotAttr  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (PartObj_Slot,          Offset,     McStat))
Offset = (size_t)((longaddr )&Named.Nam  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Nam_Attr,              Offset,     McStat))
Offset = (size_t)((longaddr )&Named.MemberNamedDrawObjs  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (MemberNamedDrawObjs_Attr, Offset,  McStat))
Env_InvokeMap      (C_Apl,                             McStat);
}
TRACK(TrackBak,"NamedDrawObj_InitClass\n");
return (STAT);
}
NamedDrawObj  *NamedDrawObj_new0
(tokentype    *AnchorTkn, ft F,lt Z,zz *Status)
{
tokentype          Token     = NullToken;
NamedDrawObj      *Image     = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  NamedDrawObj_New0 Anchor= [%4u:%6u]\n",
AnchorTkn->DbId, AnchorTkn->Handle))
TraceMsg (0, Msg);
if (Object_Create   (AnchorTkn,  NamedDrawObj_Class,    McStat,   &Token))
if (Object_GetImage (&Token,     McStat,   (addrtype *)&Image))
{
if (DrawLib01)
Image->Id               = ++DrawLib01->DrawId;
Ut_IntToStr ((int )Image->Id,   Image->Nam);
Image->draw                = NULL;
Image->area                = NULL;
Image->destruct            = NamedDrawObj_delete;
}
if (Normal(*Status))
if (DrawObjs_AddInto      (&LibTkn010,  &Token,  McStat))
NamedDrawObjs_AddInto (&LibTkn010,  &Token,  McStat);
STAT;
return (Image);
}
NamedDrawObj  *NamedDrawObj_new1
(tokentype    *AnchorTkn, numtype       ClassId,
ft F,lt Z,zz *Status)
{
tokentype          Token     = NullToken;
NamedDrawObj      *DrawImage = NullPtr;
DrawObj           *Image     = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  NamedDrawObj_New1 Anchor= [%4u:%6u]; ClassId=%4u\n",
AnchorTkn->DbId, AnchorTkn->Handle, ClassId))
TraceMsg (0, Msg);
if (Object_Create   (AnchorTkn,    ClassId,          McStat,   &Token))
if (Object_GetImage (&Token,       McStat,         (addrtype *)&DrawImage))
{
Image                      = (DrawObj *)DrawImage;
if (DrawLib01)
Image->Id               = ++DrawLib01->DrawId;
Image->draw                = NULL;
Image->area                = NULL;
Image->destruct            = DrawObj_delete;
}
STAT;
return (DrawImage);
}
NamedDrawObj  *NamedDrawObj_new2
(tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
tokentype          Token     = *RecTkn;
DrawObj           *Image     = NullPtr;
NamedDrawObj      *DrawImage = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  NamedDrawObj_new2 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (&Token,       McStat,    (addrtype *)&DrawImage))
{
Image                      = (DrawObj *)DrawImage;
Image->draw                = NULL;
Image->area                = NULL;
Image->destruct            = DrawObj_delete;
}
STAT;
return (DrawImage);
}
boolean NamedDrawObj_Create0
(tokentype    *Anchor,
ft F,lt Z,zz *Status,    tokentype    *Token)
{
numtype    DrawId   =  0;
static
nametype   Nam      = {"Create0_"};
if (DrawLib01)
DrawId   =  ++DrawLib01->DrawId;
Ut_IntToStr   ((int )DrawId, Nam);
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n NamedDrawObj:: Create [%3u:%8u] = <%s>\n",
Anchor->DbId,  Anchor->Handle, Nam))
TraceMsg (0, Msg);
if (Object_Create   (Anchor, NamedDrawObj_Class,     McStat,     Token))
if (Attr_ValuePut   (Token,  Id_Attr,    (addrtype )&DrawId,     McStat))
Attr_ValuePut   (Token,  Nam_Attr,   (addrtype )&Nam,        McStat);
if (Normal(*Status))
if (DrawObjs_AddInto      (&LibTkn010,  Token,  McStat))
NamedDrawObjs_AddInto (&LibTkn010,  Token,  McStat);
TRACK(TrackBak,"NamedDrawObj_Create0\n");
return (STAT);
}
boolean NamedDrawObj_Create1
(tokentype    *Anchor,    numtype       ClassId,
nametype      Nam,
ft F,lt Z,zz *Status,    tokentype    *Token)
{
numtype        DrawId          = 0;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg,
"\n NamedDrawObj:: Create Anchor[%3u:%8u];  ClassId=%4u\n",
Anchor->DbId,  Anchor->Handle, ClassId))
TraceMsg (0, Msg);
if (DrawLib01)
DrawId      =  ++DrawLib01->DrawId;
if (Normal(*Status))
if (Object_Create   (Anchor, ClassId,                McStat, Token))
if (Attr_ValuePut   (Token,  Id_Attr,    (addrtype )&DrawId,     McStat))
if (Attr_ValuePut   (Token,  Nam_Attr,   (addrtype  )Nam,        McStat))
{
if (DrawObjs_AddInto      (&LibTkn010,  Token,  McStat))
NamedDrawObjs_AddInto (&LibTkn010,  Token,  McStat);
}
TRACK(TrackBak,"NamedDrawObj_Create1\n");
return (STAT);
}
boolean  NamedDrawObj_ExportFunc
(tokentype    *Token,   indextype       IterNum,
ft F,lt Z,zz *Status)
{
numtype             j      = IterNum;
NamedDrawObj       *r010   = NullPtr;
if (j == 0 || j % QueBug == 0)
{
sprintf (Msg, " Object %4d. Iterate [%3u:%8u]\n",
IterNum, Token->DbId, Token->Handle);
TraceMsg (0, Msg);
}
if (Object_IsA           (Token,  McStat)   == NamedDrawObj_Class)
{
r010 = NamedDrawObj_new2 (Token,              McStat);
if (r010)
if (DrawObj_export    ((DrawObj  *)r010,    McStat))
DrawObj_delete    ((DrawObj **)&r010,   dbFree,    McStat);
}
TRACK(TrackBak,"NamedDrawObj_ExportFunc\n");
return (STAT);
}
boolean NamedDrawObj_delete
(NamedDrawObj **This,    deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
DrawObj_delete   ((DrawObj **)This,      DbEvent,   McStat);
TRACK(TrackBak,"NamedDrawObj_delete\n");
return (STAT);
}
boolean NamedDrawObjs_InitClass (ft F,lt Z,zz *Status)
{
if (ClassBug)
TraceMsg (0, " NamedDrawObjs::InitClass...\n");
if (!NamedDrawObjs_Set)
if (EnvGetMemberId    ("OwnerNamedDrawObjs",
McStat,               &OwnerNamedDrawObjs_Attr))
if (EnvGetMemberId    ("MemberNamedDrawObjs",
McStat,               &MemberNamedDrawObjs_Attr))
EnvGetSetId       ("NamedDrawObjs",
McStat,               &NamedDrawObjs_Set);
TRACK(TrackBak,"NamedDrawObjs_InitClass\n");
return (STAT);
}
boolean NamedDrawObjs_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status)
{
SetAddInto (NamedDrawObjs_Set, OwnerTkn, MemberTkn, McStat);
TRACK(TrackBak,"NamedDrawObjs_AddInto\n");
return (STAT);
}
boolean NamedDrawObjs_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn)
{
SetFindIn  (NamedDrawObjs_Set, OwnerTkn,   KeyValue,
McStat,            MemberTkn);
TRACK(TrackBak,"FindInNamedDrawObjs\n");
return (STAT);
}
boolean NamedDrawObjs_IterateOn
(tokentype    *OwnerTkn,  treeiterfunc  IterFunc,
ft F,lt Z,zz *Status)
{
SpclTraverseTree (NamedDrawObjs_Set,  OwnerTkn, IterFunc, McStat);
if (*Status == Set_EndOfSet
||  *Status == Set_EmptySet)
*Status  = Env_Normal;
TRACK(TrackBak,"FindInNamedDrawObjs\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\emplib.c*/

#define PERSONLIB
boolean PersonLib_InitLibrary
(ft F,lt Z,zz *Status)
{
if (PersonLib_Class == 0)
{
TraceMsg (0, "\n Initialize the Class maps of this schema.\n");
if (PersonLib_InitClass                       (McStat))
if (Address_InitClass                         (McStat))
Person_InitClass                          (McStat);
}
TRACK(TrackBak,"PersonLib_InitLibrary\n");
return (STAT);
}
boolean PersonLib_InitClass  (ft F,lt Z,zz *Status)
{
if (PersonLib_Class  == 0)
{
if (Env_GetAttrId     ("Descriptor",         McStat, &Descriptor_Attr))
if (Env_GetAttrId     ("MaxId",              McStat, &MaxId_Attr))
if (Env_GetAttrId     ("CompanyName",        McStat, &CompanyName_Attr))
if (Env_GetAttrId     ("AddressTkn",         McStat, &AddressTkn_Attr))
Env_GetClassId    ("PersonLib",          McStat, &PersonLib_Class);
}
if (Normal(*Status))
if (Env_InitClassMap     (PersonLib_Class,      sizeof (PersonLib),
C_Apl,                McStat))
Env_InvokeMap        (C_Apl,                McStat);
if (Normal(*Status))
if (PersonObjs_InitClass                       (McStat))
PersonNames_InitClass                      (McStat);
TRACK(TrackBak,"PersonLib_InitClass\n");
return (STAT);
}
boolean Person_InitDb    (char         *DbName,  char         *DbFileName,
numtype       Option,
ft F,lt Z,zz *Status,  tokentype    *PrimalTkn)
{
numtype        RgnEntries      = 0;
PersonLib_InitLibrary  (McStat);
if (Normal(*Status))
if (!PersonLib_ActivateDbByName
(DbName,       DbFileName,      Read_Write,
McStat,      &PersonLib01))
{
*Status        = Env_Normal;
if (Option    > 10000)
RgnEntries = Option;
else
RgnEntries = 10000;
if (PersonLib_CreateDb
(DbName,    DbFileName,
Read_Write,
RgnEntries,    RgnEntries*3,
10000,         10000,
10010,         10000,
McStat,        PrimalTkn,    &PersonLib01))
Primal_ConfigYourClass
(PrimalTkn,    Person_Class,  1000, 20, 10,
10000,   1000, Read_Write,    True, 20, 20, McStat);
} else
*PrimalTkn  =  PersonLib01->Token;
TRACK(TrackBak,"Person_InitDb\n");
return (STAT);
}
boolean PersonLib_QueryDb
(char         *DbName,
ft F,lt Z,zz *Status,    boolean      *Active)
{
if (ClassBug || DeBug > 0)
if (sprintf  (Msg, "  PersonLib_QueryDb:: <%21s>\n",
DbName))
*Active    = False;
*Status    = Err_NotImplemented;
TRACK(TrackBak,"PersonLib_QueryDb\n");
return (STAT);
}
boolean PersonLib_CreateDb
(char         *DbName,    char         *DbFileName,
dbaccesstype  DbAccess,
numtype       HndlRgns,  numtype       RgnHndls,
numtype       VhndlRgns, numtype       RgnVhndls,
numtype       XmemRgns,  numtype       RgnXmems,
ft F,lt Z,zz *Status,
tokentype    *PrimalTkn, PersonLib     **PrimalObj)
{
sizetype      EntrySize    = sizeof (handletype);
numtype       AllocRgns    = (RgnHndls / 125) + 27;
tokentype     TreeTkn      = NullToken;
attrobjtype   AttrDesc;
sizetype      KeySize      = 0;
typetype      KeyType      = aInteger;
numtype       TreeOrder    = 10;
if (ClassBug)
if (sprintf(Msg, "  PersonLibCreate:: Db= '%32s'; Handles Per Region=%4u\n",
DbName,  RgnHndls))
TraceMsg (0, Msg);
if (Primal_CreateDb ("PersonSchema",  DbName,     DbFileName,  DbAccess,
HndlRgns,        RgnHndls,   VhndlRgns,   RgnVhndls,
XmemRgns,        RgnXmems,   McStat,      PrimalTkn))
if (ClassBug)
Object_Dump     (PrimalTkn);
if (Normal(*Status))
#ifndef   __FREEZE_VCHUNKS__
if (PrimalCommitDb    (PrimalTkn,   "\0",     False,      McStat))
#endif
if (Object_GetImage (PrimalTkn,     McStat,  (addrtype *)PrimalObj))
if (Env_GetAttrInfo (LastName_Attr,            McStat,     &AttrDesc))
{
(*PrimalObj)->Descriptor  = NullPtr;
(*PrimalObj)->MaxId       = 0;
KeySize    = AttrDesc.Size;
KeyType    = AttrDesc.TypeType;
Tree_Create     (PersonNames_Set,        PrimalTkn,   TreeOrder,
RgnHndls,               KeySize,     KeyType,
McStat,                &TreeTkn);
}
if (Normal(*Status))
if (Env_GetAttrInfo (PersonId_Attr,         McStat,     &AttrDesc))
{
KeySize    = AttrDesc.Size;
KeyType    = AttrDesc.TypeType;
Tree_Create     (PersonObjs_Set,         PrimalTkn,   TreeOrder,
RgnHndls,               KeySize,     KeyType,
McStat,                &TreeTkn);
}
if (Normal(*Status))
{
#ifndef   __FREEZE_VCHUNKS__
TraceMsg (0, "\n PrimalTkn BEFORE Commit Object::");
Object_Dump      (PrimalTkn);
if (Object_CommitImage
(PrimalTkn,   True,                McStat))
{
TraceMsg (0, "\n PrimalTkn AFTER  Commit Object ::");
Object_Dump      (PrimalTkn);
}
if (Normal(*Status))
if (Primal_CommitDb (PrimalTkn,   "\0",     False,     McStat))
if (ClassBug || DeBug)
{
TraceMsg (0, "\n PrimalTkn AFTER Commit DB::");
Object_Dump      (PrimalTkn);
}
#else
if (Object_CommitImage
(PrimalTkn,   False,               McStat))
#endif
if (Normal(*Status))
if (Object_GetImage  (PrimalTkn,   McStat,  (addrtype *)PrimalObj))
PersonLib01       = *PrimalObj;
Print_Msg         = True;
WriteHdr          = False;
} else if (*Status    == Csh_DbAlreadyExists) {
*Status               = Env_Normal;
if (Object_GetImage     (PrimalTkn,    McStat,    (addrtype *)PrimalObj))
PersonLib01          = *PrimalObj;
}
#ifdef   __EDB_BENCHMARK__
TraceMsg (0, "\n Primal Token to Person Library::\n");
Object_Dump (PrimalTkn);
TraceMsg (0, "\n PersonNames Set Head Token::\n");
Object_Dump (&TreeTkn);
#endif
TRACK(TrackBak,"PersonLib_CreateDb\n");
return (STAT);
}
boolean PersonLib_ActivateDbByName
(char         *DbName,    char         *DbFileName,
dbaccesstype  AccessType,
ft F,lt Z,zz *Status,    PersonLib     **PrimalObj)
{
if (ClassBug || DeBug > 0)
if (sprintf  (Msg, "  PersonLib_ActivateDbByName:: <%21s>\n",
DbName))
if (TraceMsg (0, Msg))
if (sprintf  (Msg, "                 FileName := <%21s>; Access=%s\n",
DbFileName, DbAccessStr[AccessType]))
TraceMsg  (0, Msg);
*PrimalObj = NullPtr;
if (!Primal_ActivateDbByName
(DbName,    DbFileName, AccessType,
McStat,               &EmpTkn010))
return (False);
if (Object_GetImage   (&EmpTkn010,    McStat, (addrtype *)PrimalObj))
PersonLib01          = *PrimalObj;
if (Normal(*Status))
{
TraceMsg (0, "\n DB Activated::");
Object_Dump      (&EmpTkn010);
}
TRACK(TrackBak,"PersonLib_ActivateDbByName\n");
return (STAT);
}
boolean PersonLib_ActivateDbByToken
(tokentype    *PrimalTkn, char         *DbFileName,
dbaccesstype  AccessType,
ft F,lt Z,zz *Status,    PersonLib      **PrimalObj)
{
static char   FileName[128]  = "\0";
if (DbFileName  != NullPtr)
strcpy (FileName, DbFileName);
if (ClassBug || DeBug > 0)
if (sprintf  (Msg, "  PersonLibActivate:: [%3u:%4u]  DbFile= '%32s'\n",
PrimalTkn->DbId, PrimalTkn->Handle,  FileName))
TraceMsg  (0, Msg);
if (!Primal_ActivateDbByToken
(PrimalTkn,    DbFileName,  AccessType, McStat))
return (False);
if (Object_GetImage     (PrimalTkn,    McStat,      (addrtype *)PrimalObj))
PersonLib01          = *PrimalObj;
TRACK(TrackBak,"PersonLib_ActivateDbByToken\n");
return (STAT);
}
boolean PersonLib_DeleteDb (tokentype    *PrimalTkn, ft F,lt Z,zz *Status)
{
if (ClassBug || DeBug > 0)
if (sprintf  (Msg, "  PersonLib_DeleteDb:: [%3u:%4u]\n",
PrimalTkn->DbId, PrimalTkn->Handle))
TraceMsg  (0, Msg);
Primal_DeleteDb         (PrimalTkn,    McStat);
TRACK(TrackBak,"PersonLib_DeleteDb\n");
return (STAT);
}
boolean PersonObjs_InitClass (ft F,lt Z,zz *Status)
{
if (ClassBug)
TraceMsg (0, " Persons::InitClass...\n");
if (!PersonObjs_Set)
if (EnvGetMemberId    ("OwnerPersonObjs",
McStat,               &OwnerPersonObjs_Attr))
if (EnvGetMemberId    ("MemberPersonObjs",
McStat,               &MemberPersonObjs_Attr))
EnvGetSetId       ("PersonObjs",
McStat,               &PersonObjs_Set);
TRACK(TrackBak,"PersonObjs_InitClass\n");
return (STAT);
}
boolean PersonObjs_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status)
{
Member_KeySetAddInto (PersonObjs_Set, OwnerTkn, MemberTkn, McStat);
TRACK(TrackBak,"PersonObjs_AddInto\n");
return (STAT);
}
boolean PersonObjs_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn)
{
Owner_KeySetFindIn  (PersonObjs_Set,      OwnerTkn,   KeyValue,
McStat,            MemberTkn);
TRACK(TrackBak,"FindInPersonObjs\n");
return (STAT);
}
boolean PersonObjs_IterateOn
(tokentype    *OwnerTkn,  treeiterfunc  IterFunc,
ft F,lt Z,zz *Status)
{
SpclTraverseTree (PersonObjs_Set,  OwnerTkn, IterFunc, McStat);
if (*Status == Set_EndOfSet
||  *Status == Set_EmptySet)
*Status  = Iterate_EndOf;
TRACK(TrackBak,"PersonObjs_IterateOn\n");
return (STAT);
}
boolean PersonNames_InitClass (ft F,lt Z,zz *Status)
{
if (ClassBug)
TraceMsg (0, " PersonNamas::InitClass...\n");
if (!PersonNames_Set)
if (EnvGetMemberId    ("OwnerPersonNames",
McStat,               &OwnerPersonNames_Attr))
if (EnvGetMemberId    ("MemberPersonNames",
McStat,               &MemberPersonNames_Attr))
EnvGetSetId       ("PersonNames",
McStat,               &PersonNames_Set);
TRACK(TrackBak,"PersonNames_InitClass\n");
return (STAT);
}
boolean PersonNames_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status)
{
Member_KeySetAddInto (PersonNames_Set, OwnerTkn, MemberTkn, McStat);
TRACK(TrackBak,"PersonNames_AddInto\n");
return (STAT);
}
boolean PersonNames_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn)
{
Owner_KeySetFindIn  (PersonNames_Set,      OwnerTkn,   KeyValue,
McStat,            MemberTkn);
TRACK(TrackBak,"FindInPersonNames\n");
return (STAT);
}
boolean PersonNames_IterateOn
(tokentype    *OwnerTkn,  treeiterfunc  IterFunc,
ft F,lt Z,zz *Status)
{
SpclTraverseTree (PersonNames_Set,  OwnerTkn, IterFunc, McStat);
if (*Status == Set_EndOfSet
||  *Status == Set_EmptySet)
*Status  = Iterate_EndOf;
TRACK(TrackBak,"PersonNames_IterateOn\n");
return (STAT);
}
#ifdef INCLUDE_ALL_CODE
void PersonLib_Topology       (void)
{
longaddr    StartAddr = 0;
static   PersonLib     That;
static   PersonLib    *This      = &That;
TraceMsg (0, "\n\n  <PersonLib2> TOPOLOGY MAP:: \n");
StartAddr             = (longaddr )This;
sprintf (Msg,  "  sizeof PersonLib          : =%3u\n",   sizeof(PersonLib));
TraceMsg (0, Msg);
sprintf (Msg,  "  This                      : @%8x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  "  This->That                : +%3ld\n",
(longaddr )&This->That                 - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Token               : +%3ld\n",
(longaddr )&This->Token                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->DbNum               : +%3ld\n",
(longaddr )&This->DbNum                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->EnvType             : +%3ld\n",
(longaddr )&This->EnvType             - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->DescNum             : +%3ld\n",
(longaddr )&This->DescNum              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->PrimalSlotAttr      : +%3ld\n",
(longaddr )&This->PrimalSlotAttr       - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Descriptor          : +%3ld\n",
(longaddr )&This->Descriptor           - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->MaxId               : +%3ld\n",
(longaddr )&This->MaxId                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->OwnerPersonObjs     : +%3ld\n",
(longaddr )&This->OwnerPersonObjs      - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->OwnerPersonNames    : +%3ld\n\n",
(longaddr )&This->OwnerPersonNames     - StartAddr);
TraceMsg (0, Msg);
return;
}
#endif
/* 当前文件是./CINT2000\255.vortex\src\empobj.c*/

#define PERSON
boolean Address_InitClass (ft F,lt Z,zz *Status)
{
longaddr        StartAddr = 0;
Address         AddObj;
if (Address_Class  == 0)
{
if (Env_GetAttrId      ("OwnerTkn",        McStat, &OwnerTkn_Attr))
if (Env_GetAttrId      ("AddressType",     McStat, &AddressType_Attr))
if (Env_GetAttrId      ("Street",          McStat, &Street_Attr))
if (Env_GetAttrId      ("Suite",           McStat, &Suite_Attr))
if (Env_GetAttrId      ("City",            McStat, &City_Attr))
if (Env_GetAttrId      ("District",        McStat, &District_Attr))
if (Env_GetAttrId      ("State",           McStat, &State_Attr))
if (Env_GetAttrId      ("Country",         McStat, &Country_Attr))
if (Env_GetAttrId      ("ZipCode",         McStat, &ZipCode_Attr))
if (Env_GetAttrId      ("Phone",           McStat, &Phone_Attr))
if (Env_GetAttrId      ("Fax",             McStat, &Fax_Attr))
Env_GetClassId     ("Address",         McStat, &Address_Class);
}
StartAddr   = (longaddr     )&AddObj;
if (Normal(*Status))
if (Env_InitClassMap      (Address_Class,     sizeof (Address),
C_Apl,             McStat))
{
#ifdef  __OLD_WAY__
Offset    = (size_t)((longaddr )&AddObj.That    -  StartAddr);
if (Env_AppendToMap    (That_AttrNum,          Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.Token   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Token_Attr,            Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.OwnerTkn  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (OwnerTkn_Attr,         Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.AddressType - StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (AddressType_Attr,      Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.Street    -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Street_Attr,           Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.Suite     -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Suite_Attr,            Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.City      -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (City_Attr,             Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.District  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (District_Attr,         Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.State     -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (State_Attr,            Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.Country   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Country_Attr,          Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.ZipCode  - StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (ZipCode_Attr,          Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.Phone            -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Phone_Attr,            Offset,     McStat))
Offset = (size_t)((longaddr )&AddObj.Fax    -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Fax_Attr,              Offset,     McStat))
#endif
if (Normal(*Status))
Env_InvokeMap      (C_Apl,             McStat);
}
TRACK(TrackBak,"Address_InitClass\n");
return (STAT);
}
boolean Person_InitClass (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
Person          EmpObj;
if (Person_Class  == 0)
{
if (Env_GetAttrId      ("PersonId",        McStat, &PersonId_Attr))
if (Env_GetAttrId      ("LastName",        McStat, &LastName_Attr))
if (Env_GetAttrId      ("FirstName",       McStat, &FirstName_Attr))
if (Env_GetAttrId      ("Gender",          McStat, &Gender_Attr))
if (Env_GetAttrId      ("Residence",       McStat, &Residence_Attr))
if (Env_GetAttrId      ("InputDate",       McStat, &InputDate_Attr))
if (Env_GetAttrId      ("InputTime",       McStat, &InputTime_Attr))
if (Env_GetAttrId      ("BirthDate",       McStat, &BirthDate_Attr))
if (Env_GetAttrId      ("MaritalStatus",   McStat, &MaritalStatus_Attr))
if (Env_GetAttrId      ("PersonalAssoc",   McStat, &PersonalAssoc_Attr))
if (Env_GetAttrId      ("Children",        McStat, &Children_Attr))
Env_GetClassId     ("Person",          McStat, &Person_Class);
}
if (Normal(*Status))
PersonParts_InitClass                    (McStat);
StartAddr   = (longaddr     )&EmpObj;
if (Normal(*Status))
if (Env_InitClassMap      (Person_Class,      sizeof (Person),
C_Apl,             McStat))
{
Offset    = (size_t)((longaddr )&EmpObj.That    -  StartAddr);
if (Env_AppendToMap    (That_AttrNum,          Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.Token   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Token_Attr,            Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.PersonId  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (PersonId_Attr,         Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.LastName  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (LastName_Attr,         Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.FirstName -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (FirstName_Attr,        Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.Gender    -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Gender_Attr,           Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.Residence -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Residence_Attr,        Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.InputDate -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (InputDate_Attr,        Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.InputTime -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (InputTime_Attr,        Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.BirthDate -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (BirthDate_Attr,        Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.MaritalStatus  - StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (MaritalStatus_Attr,    Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.Descriptor       -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Descriptor_Attr,       Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.PersonalAssoc   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (PersonalAssoc_Attr,    Offset,     McStat))
Offset = (size_t)((longaddr )&EmpObj.Children -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Children_Attr,         Offset,     McStat))
Offset = (size_t)((longaddr  )&EmpObj.MemberPersonObjs -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (MemberPersonObjs_Attr, Offset,  McStat))
Offset = (size_t)((longaddr  )&EmpObj.MemberPersonNames -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (MemberPersonNames_Attr,Offset,  McStat))
Offset = (size_t)((longaddr  )&EmpObj.OwnerPersonParts -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (OwnerPersonParts_Attr, Offset,  McStat))
Env_InvokeMap      (C_Apl,                          McStat);
}
TRACK(TrackBak,"Person_InitClass\n");
return (STAT);
}
Person  *Person_new0     (tokentype    *Anchor,    ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
Person         *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  Person_New0 Anchor= [%4u:%6u]\n",
Anchor->DbId, Anchor->Handle))
TraceMsg (0, Msg);
if (Object_Create    (Anchor,       Person_Class,    McStat,   &Token))
if (Object_GetImage  (&Token,       McStat,        (addrtype *)&Image))
{
Image->InputTime         = clock();
Image->PersonId          = ++PersonLib01->MaxId;
}
if (Normal(*Status))
Member_KeySetAddInto  (PersonObjs_Set,    &EmpTkn010,   &Token,
McStat);
STAT;
return (Image);
}
Person  *Person_new1     (tokentype    *Anchor,    numtype       ClassId,
ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
Person         *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  Person_New1 Anchor= [%4u:%6u]; ClassId=%4u\n",
Anchor->DbId, Anchor->Handle, ClassId))
TraceMsg (0, Msg);
if (Object_Create   (Anchor,       ClassId,          McStat,   &Token))
if (Object_GetImage (&Token,       McStat,         (addrtype *)&Image))
{
Image->InputTime         = clock();
Image->PersonId          = ++PersonLib01->MaxId;
}
if (Normal(*Status))
Member_KeySetAddInto  (PersonObjs_Set,    &EmpTkn010,   &Token,
McStat);
STAT;
return (Image);
}
Person  *Person_new2     (tokentype    *EmpTkn,    ft F,lt Z,zz *Status)
{
Person      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  Person_new2 Anchor= [%4u:%6u]\n",
EmpTkn->DbId, EmpTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (EmpTkn,       McStat,         (addrtype *)&Image))
;
STAT;
return (Image);
}
boolean Person_Create0  (tokentype    *Anchor,
ft F,lt Z,zz *Status,    tokentype    *Token)
{
time_t    Time     = clock();
numtype    PersonId = 0;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Person:: Create [%3u:%8u]\n",
Anchor->DbId,  Anchor->Handle))
TraceMsg (0, Msg);
PersonId          = ++PersonLib01->MaxId;
if (Object_Create   (Anchor, Person_Class,          McStat, Token))
if (Attr_ValuePut   (Token,  InputTime_Attr,
(addrtype )&Time,     McStat))
Attr_ValuePut   (Token,  PersonId_Attr,
(addrtype )&PersonId,          McStat);
if (Normal(*Status))
Member_KeySetAddInto  (PersonObjs_Set,    &EmpTkn010,   Token,
McStat);
TRACK(TrackBak,"Person_Create0\n");
return (STAT);
}
boolean Person_Create1   (tokentype    *Anchor,    numtype       ClassId,
ft F,lt Z,zz *Status,    tokentype    *Token)
{
time_t    Time     = clock();
numtype    PersonId = 0;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Person:: Create [%3u:%8u];  ClassId=%4u\n",
Anchor->DbId,  Anchor->Handle, ClassId))
TraceMsg (0, Msg);
PersonId          = ++PersonLib01->MaxId;
if (Object_Create   (Anchor, ClassId,               McStat, Token))
if (Attr_ValuePut   (Token,  InputTime_Attr,
(addrtype )&Time,              McStat))
Attr_ValuePut   (Token,  PersonId_Attr,
(addrtype )&PersonId,          McStat);
if (Normal(*Status))
Member_KeySetAddInto  (PersonObjs_Set,    &EmpTkn010,   Token,
McStat);
TRACK(TrackBak,"Person_Create1\n");
return (STAT);
}
boolean Person_Import    (tokentype    *LibTkn,     char         *ImportField,
importspec   *TabFields,  numtype       TabCount,
ft F,lt Z,zz *Status,     tokentype    *PersonTkn)
{
Person        *Person       = NullPtr;
tokentype      AddressTkn   = NullToken;
Address       *Address      = NullPtr;
static char    TabStr[128]  = "\0";
numtype        i            = 0;
numtype        j            = 0;
char          *FieldPtr     = ImportField;
boolean        EndTabStr    = False;
numtype        SpaceOut     = 0;
boolean        TempSetBug   = SetBug;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Person:: Import [%3u:%8u] :\n %s\n",
LibTkn->DbId,  LibTkn->Handle, ImportField))
TraceMsg (0, Msg);
if (Object_NewImage  (LibTkn,      Address_Class,
McStat,     &AddressTkn,     (addrtype *)&Address))
{
Address->OwnerTkn         = NullToken;
Address->AddressType      = aResidence;
Address->Street           = NullPtr;
Address->Suite            = NullPtr;
Address->City[0]          = '\0';
Address->District[0]      = '\0';
Address->State[0]         = '\0';
Address->Country[0]       = '\0';
Address->ZipCode          = '\0';
Address->Phone[0]         = '\0';
Address->Fax[0]           = '\0';
}
if (Normal(*Status))
if (Object_NewImage  (LibTkn,      Person_Class,
McStat,      PersonTkn,      (addrtype *)&Person))
{
Person->PersonId          = ++PersonLib01->MaxId;
Person->LastName[0]       = '\0';
Person->FirstName[0]      = '\0';
Person->Gender            = 'U';
Person->Residence.ObjTkn  = AddressTkn;
Person->Residence.ObjAddr = Address;
Person->InputDate         = clock();
Person->InputTime         = clock();
Person->BirthDate         = 0;
Person->MaritalStatus     = 0;
Person->Descriptor        = NullPtr;
Person->PersonalAssoc[0]  = '\0';
Person->Children          = NullPtr;
Address->OwnerTkn         = *PersonTkn;
}
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg,  " LINE = <%s>\n", FieldPtr))
TraceMsg (0, Msg);
if (Normal(*Status))
for (i = 0; i < TabCount && Normal(*Status); ++i)
{
j           = 0;
EndTabStr   = False;
SpaceOut    = 0;
while (EndTabStr   == False)
{
if (*FieldPtr   != 011
&&  *FieldPtr   != '\0'
&&  *FieldPtr   != '\n')
{
if (*FieldPtr   == ' ')
{
if (++SpaceOut == 1)
TabStr[j++]   =  *FieldPtr;
} else {
SpaceOut       = 0;
TabStr[j++]    =  *FieldPtr;
}
} else {
TabStr[j]        =  '\0';
EndTabStr        = True;
}
FieldPtr++;
}
if (Normal(*Status))
if (ClassBug)
{
sprintf (Msg,
" Field= %4u. ClassId=%3u AttrId=%4u. Str= <%s>\n",
i, TabFields[i].ClassId, TabFields[i].AttrId, TabStr);
TraceMsg (0, Msg);
}
if ( (size_t) (strlen (TabStr)) > 0 )
if (TabFields[i].ClassId      == Address_Class)
{
if (TabFields[i].AttrId    == Street_Attr)
{
#ifdef __BAD_CODE__
Attr_ValuePut     (&AddressTkn,              Street_Attr,
(addrtype )TabStr,        McStat);
#else
;
#endif
} else if (TabFields[i].AttrId    == Suite_Attr)    {
#ifdef __BAD_CODE__
Attr_ValuePut     (&AddressTkn,              Suite_Attr,
(addrtype )TabStr,        McStat);
#else
;
#endif
} else if (TabFields[i].AttrId    == City_Attr)     {
strncpy (Address->City,     TabStr, MAXNAME);
} else if (TabFields[i].AttrId    == State_Attr)    {
strncpy (Address->State,    TabStr, MAXNAME);
} else if (TabFields[i].AttrId    == Country_Attr)  {
strncpy (Address->Country,  TabStr, MAXNAME);
} else if (TabFields[i].AttrId    == ZipCode_Attr)  {
Address->ZipCode  = atol ((char *)TabStr);
} else if (TabFields[i].AttrId    == Phone_Attr)    {
strncpy (Address->Phone,    TabStr, 12);
} else if (TabFields[i].AttrId    == Fax_Attr)      {
strncpy (Address->Fax,      TabStr, 12);
}
} else if (TabFields[i].ClassId      == Person_Class)   {
if (TabFields[i].AttrId           == LastName_Attr)
{
strncpy (Person->LastName,  TabStr, MAXNAME);
} else if (TabFields[i].AttrId    == FirstName_Attr) {
strncpy (Person->FirstName, TabStr, MAXNAME);
}
} else if (TabFields[i].ClassId      != 0) {
sprintf (Msg,
" ...Warning... Invalid Tab Field; Field= %4u. ClassId=%3u AttrId=%4u.\n",
i, TabFields[i].ClassId, TabFields[i].AttrId);
TraceMsg (0, Msg);
}
}
if (Normal(*Status))
if ( (size_t) (strlen (Person->LastName) ) > 0)
Member_KeySetAddInto  (PersonNames_Set,   LibTkn,  PersonTkn,
McStat);
SetBug  = TempSetBug;
if (Normal(*Status))
Member_KeySetAddInto  (PersonObjs_Set,    LibTkn,  PersonTkn,
McStat);
if (*Status == Set_AlreadyInSet)
{
sprintf (Msg, " *** Duplicate Person[%3u:%8u]. Name = %16s, %16s;\n",
PersonTkn->DbId,    PersonTkn->Handle,
Person->LastName,   Person->FirstName);
TraceMsg (0, Msg);
*Status  = Env_Normal;
--PersonLib01->MaxId;
if (Object_Delete      (PersonTkn,    McStat))
if (Object_Delete      (&AddressTkn,  McStat))
{
*PersonTkn  = NullToken;
*Status     = Set_AlreadyInSet;
}
}
TRACK(TrackBak,"Person_Import\n");
return (STAT);
}
boolean Person_Export    (tokentype    *EmpTkn,     filename      OutputFile,
ft F,lt Z,zz *Status)
{
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Person:: Export [%3u:%8u]= %s\n",
EmpTkn->DbId,  EmpTkn->Handle, OutputFile))
TraceMsg (0, Msg);
TRACK(TrackBak,"Person_Export\n");
return (STAT);
}
boolean Person_delete    (Person     **This,      deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
Person   *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  Person_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " Person [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"Person_delete\n");
return (STAT);
}
boolean PersonParts_InitClass (ft F,lt Z,zz *Status)
{
if (ClassBug)
TraceMsg (0, " PersonParts::InitClass...\n");
if (!PersonParts_Set)
if (EnvGetMemberId    ("OwnerPersonParts",
McStat,               &OwnerPersonParts_Attr))
if (EnvGetMemberId    ("MemberPersonParts",
McStat,               &MemberPersonParts_Attr))
EnvGetSetId       ("PersonParts",
McStat,               &PersonParts_Set);
TRACK(TrackBak,"PersonParts_InitClass\n");
return (STAT);
}
boolean PersonParts_OwnerOf
(tokentype *Member,
ft F,lt Z,zz *Status,    tokentype *Owner)
{
Member_SetOwnerOf (PersonParts_Set, Member, McStat, Owner);
TRACK(TrackBak,"OwnerOfPersonParts\n");
return (STAT);
}
boolean PersonParts_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status)
{
Member_KeySetAddInto (PersonParts_Set, OwnerTkn, MemberTkn, McStat);
TRACK(TrackBak,"PersonParts_AddInto\n");
return (STAT);
}
boolean PersonParts_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn)
{
Owner_KeySetFindIn  (PersonParts_Set,      OwnerTkn,   KeyValue,
McStat,            MemberTkn);
TRACK(TrackBak,"FindInPersonParts\n");
return (STAT);
}
inttype PersonParts_IterateOn
(tokentype    *OwnerTkn,  inttype       ItNum,
ft F,lt Z,zz *Status,
tokentype    *NodeTkn,   tokentype    *Token)
{
tokentype    CurrTkn = *NodeTkn;
if (ItNum == 0)
Owner_SetFirstOf (PersonParts_Set,  OwnerTkn, McStat, NodeTkn, Token);
else
Member_SetNextOf (PersonParts_Set, &CurrTkn,  McStat, NodeTkn, Token);
if (Normal(*Status))
ItNum++;
else if (*Status == Set_EndOfSet)
{
*Status = Env_Normal;
ItNum  *= -1;
} else if (*Status == Set_EmptySet)  {
*Status = Env_Normal;
ItNum   = -1;
}
STAT;
return (ItNum);
}
#ifdef INCLUDE_ALL_CODE
void Person_Topology  (void)
{
longaddr      StartAddr = 0;
static   Person        That;
static   Person       *This      = &That;
TraceMsg (0, "\n\n  <Person> TOPOLOGY MAP:: \n");
StartAddr             = (longaddr )This;
sprintf (Msg,  "  sizeof Person             : =%3u\n",   sizeof(Person));
TraceMsg (0, Msg);
sprintf (Msg,  "  This                      : @%8x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  "  This->That                : +%3ld\n",
(longaddr )&This->That                 - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Token               : +%3ld\n",
(longaddr )&This->Token                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->PersonId            : +%3ld\n",
(longaddr )&This->PersonId             - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->LastName            : +%3ld\n",
(longaddr )&This->LastName             - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->FirstName           : +%3ld\n",
(longaddr )&This->FirstName            - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Gender              : +%3ld\n",
(longaddr )&This->Gender               - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Residence           : +%3ld\n",
(longaddr )&This->Residence            - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->InputDate           : +%3ld\n",
(longaddr )&This->InputDate            - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->InputTime           : +%3ld\n",
(longaddr )&This->InputTime            - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->BirthDate           : +%3ld\n",
(longaddr )&This->BirthDate            - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->MaritalStatus       : +%3ld\n",
(longaddr )&This->MaritalStatus        - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Descriptor          : +%3ld\n",
(longaddr )&This->Descriptor           - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->PersonalAssoc       : +%3ld\n",
(longaddr )&This->PersonalAssoc        - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Children            : +%3ld\n",
(longaddr )&This->Children             - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->MemberPersonObjs    : +%3ld\n",
(longaddr )&This->MemberPersonObjs     - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->MemberPersonNames   : +%3ld\n",
(longaddr )&This->MemberPersonNames    - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->OwnerPersonParts    : +%3ld\n\n",
(longaddr )&This->OwnerPersonParts     - StartAddr);
TraceMsg (0, Msg);
return;
}
void Address_Topology  (void)
{
longaddr      StartAddr = 0;
static   Address       That;
static   Address      *This      = &That;
TraceMsg (0, "\n\n  <Address> TOPOLOGY MAP:: \n");
StartAddr             = (longaddr )This;
sprintf (Msg,  "  sizeof Address            : =%3u\n",   sizeof(Address));
TraceMsg (0, Msg);
sprintf (Msg,  "  This                      : @%8x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  "  This->That                : +%3ld\n",
(longaddr )&This->That                 - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Token               : +%3ld\n",
(longaddr )&This->Token                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->OwnerTkn            : +%3ld\n",
(longaddr )&This->OwnerTkn             - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->AddressType         : +%3ld\n",
(longaddr )&This->AddressType           - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Street              : +%3ld\n",
(longaddr )&This->Street               - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Suite               : +%3ld\n",
(longaddr )&This->Suite                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->City                : +%3ld\n",
(longaddr )&This->City                 - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->District            : +%3ld\n",
(longaddr )&This->District             - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->State               : +%3ld\n",
(longaddr )&This->State                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Country             : +%3ld\n",
(longaddr )&This->Country              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->ZipCode             : +%3ld\n",
(longaddr )&This->ZipCode              - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Phone               : +%3ld\n",
(longaddr )&This->Phone                - StartAddr);
TraceMsg (0, Msg);
sprintf (Msg,  "  This->Fax                 : +%3ld\n\n",
(longaddr )&This->Fax                   - StartAddr);
TraceMsg (0, Msg);
return;
}
#endif
/* 当前文件是./CINT2000\255.vortex\src\env0.c*/

#define ENV0
#ifdef ENV01
/* 当前文件是./CINT2000\255.vortex\src\om.h*/

#ifndef OM_H
#define OM_H


#ifndef  ENV00
static boolean      Config_Class             = False;
static numtype      Class_RegionEntrys       = 1000;
static numtype      Class_AllocRegions       = 20;
static numtype      Class_ExtendRegions      = 10;
static numtype      Class_AllocExObjects     = 1000;
static numtype      Class_ExtendExObjects    = 100;
static accesstype   Class_AccessType         = Read_Write;
static boolean      Class_DiskCache          = False;
static indextype    Class_CacheLimit         = 20;
static indextype    Class_CacheLoad          = 20;
#endif
tokentype    HdrSizeVchunkTkn         = {1, 1, 1};
tokentype    AllocQtyVchunkTkn        = {2, 1, 1};
tokentype    RegionQtyVchunkTkn       = {3, 1, 1};
tokentype    SectorQtyVchunkTkn       = {4, 1, 1};
bytessize   *ObjHdrSize               = NullPtr;
indextype   *ObjAllocQty              = NullPtr;
indextype   *ObjRegionQty             = NullPtr;
indextype   *ObjSectorQty             = NullPtr;

#ifndef  ENV00
void    OmSetConfig    (boolean       Config);
void    OmConfigClass  (numtype       RgnEntrys,
numtype       AllocRgns, numtype       ExtendRgns,
numtype       AllocXs,   numtype       ExtendXs,
accesstype    AccessType,boolean       DiskCache,
numtype       CacheLimit,numtype       CacheLoad);
boolean OmNewObjHdr   (tokentype    *Anchor,    numtype       EnvObj,
indextype     AllocQty,
ft F,lt Z,zz *Status,    objheader   **ObjHdr);
boolean OmMakeObjChunks
(tokentype    *Anchor,    objheader    *ObjHdr,
ft F,lt Z,zz *Status,    indextype    *AlocObjects);
boolean OmPutHandleOffset
(tokentype    *Anchor,    numtype       ObjNum,
bytessize     Offset,    ft F,lt Z,zz *Status);
boolean OmGetObjHdr   (tokentype    *Anchor,    numtype       LocalObj,
ft F,lt Z,zz *Status,    objheader   **ObjHdr);
boolean OmNewObject   (dbheader     *CoreDb,    objheader    *ObjHdr,
ft F,lt Z,zz *Status,
indextype    *Index,     addrtype     *Object);
boolean OmNextAvailObject
(objheader    *ObjHdr,    ft F,lt Z,zz *Status,
indextype    *Index,     indextype    *RgnIndex,
indextype    *LocalIndex);
boolean OmNewObjRegion
(dbheader     *CoreDb,    objheader    *ObjHdr,
indextype     Index,
ft F,lt Z,zz *Status,    numtype      *Region);
boolean OmNewObjRgnChunks
(objheader    *ObjHdr,
ft F,lt Z,zz *Status,    indextype    *RgnIndex);
boolean OmGetRegion   (dbheader     *CoreDb,    objheader    *ObjHdr,
indextype     Region,
ft F,lt Z,zz *Status,    numtype      *Chunk);
boolean OmPairRgnObjects
(dbheader     *CoreDb,    objheader    *ObjHdr,
numtype       RgnNum,    ft F,lt Z,zz *Status);
boolean OmUnPairRgnObjects
(dbheader     *CoreDb,    objheader    *ObjHdr,
numtype       RgnNum,    ft F,lt Z,zz *Status);
boolean OmGetObjHandles
(tokentype    *Anchor,    objheader    *ObjHdr,
ft F,lt Z,zz *Status,
indextype    *Count,     handletype  **Handles,
indextype    *RgnCount,  numtype     **RgnStatus);
boolean OmPairDbObject
(objheader    *ObjHdr,    indextype     Index,
handletype    Handle,    ft F,lt Z,zz *Status);
boolean OmGetObject   (tokentype    *Token,     ft F,lt Z,zz *Status,
indextype    *Index,     addrtype     *Object);
boolean OmDeleteObject
(tokentype    *Token,     objheader    *ObjHdr,
addrtype      Object,    ft F,lt Z,zz *Status);
boolean OmChkImage    (tokentype    *Anchor,    numtype       ObjNum,
ft F,lt Z,zz *Status);
boolean OmGetObjectHndls
(tokentype    *Anchor,
objheader    *ObjHdr,    sizeinbytes   HndlOffset,
ft F,lt Z,zz *Status,    handletype   *ObjHndls);
#endif
#endif
/* 当前文件是./CINT2000\255.vortex\src\voa.h*/

#ifndef VOA_H
#define VOA_H
boolean OaCreateVchunk
(tokentype    *Anchor,    sizetype      UnitSize,
indextype     UnitCount, indextype     ExtendQty,
ft F,lt Z,zz *Status,    tokentype    *Token);
boolean OaFreezeVchunk
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean OaDumpVchunkVchunk
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean OaGetVchunkAddr
(tokentype    *Token,
ft F,lt Z,zz *Status,    addrtype     *Chunk);
boolean OaPutVchunkAddr
(tokentype    *Token,     addrtype      ChunkAddr,
ft F,lt Z,zz *Status);
boolean OaGetVchunkAllocQty
(tokentype    *Token,
ft F,lt Z,zz *Status,    indextype    *AllocQty);
boolean OaGetVchunkStackPtr
(tokentype    *Token,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean OaPutVchunkStackPtr
(tokentype    *Token,     indextype     StackPtr,
ft F,lt Z,zz *Status);
boolean OaPushUnit
(tokentype    *Token,     addrtype      SomeBytes,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean OaPutUnit
(tokentype    *Token,     indextype     Index,
addrtype      SomeBytes, ft F,lt Z,zz *Status);
boolean OaGetUnit
(tokentype    *Token,     indextype     Index,
ft F,lt Z,zz *Status,    addrtype      SomeBytes);
boolean OaDumpVchunk
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean OaDeleteVchunk
(tokentype    *Token,     ft F,lt Z,zz *Status);
#endif
#ifndef INLINE_OMIDEFS
#else
#define        DbPrimal_Index         (indextype )0
#define        ObjDesc_Index          (indextype )1
#define        DbPrimal_Class         (word )0
#define        ObjDesc_Class          (numtype )1
#define        ObjDesc_Hndl           (handletype )3
#define  Alloc_Primals     (indextype )1
#define  Alloc_Descs       (indextype )600
#endif
#endif
#define CoreMoreCore       Core_MoreCore
#define Core0MoreCore      Core0_MoreCore
#define MemMakeOry         Mem_MakeOry
#define MemTestTheOry      Mem_TestTheOry
#define MemPushAddr        Mem_PushAddr
#define MemPushWord        Mem_PushWord
#define MemPutWord         Mem_PutWord
#define MemPutLong         Mem_PutLong
#define DbmLoadDbHdr       Dbm_LoadDbHdr

#define MemPutLocalObjNum   Mem_PutWord
#define MemPushSize         Mem_PushWord
#define MemPushObjNum       Mem_PushWord
#define MemPutObjNum        Mem_PutWord
#define MemPushObjHdr       Mem_PushAddr
#define MemPutOffset        Mem_PutWord
#define MemPutHandle        Mem_PutWord
#define MemPutFieldNum      Mem_PutWord
#define MemPushFieldNum     Mem_PushWord
#define MemPushFieldOffset  Mem_PushWord
#define MemPushAttrNum      Mem_PushWord
#define MemPutAttrNum       Mem_PutWord
#define MemPushNum          Mem_PushWord
boolean    CreateImage    (ft F,lt Z,zz *Status,  imagetype **Image)
{
imagetype  *TheImage     = NullPtr;
objtype    *TheCoreImage = NullPtr;
if (!Reload_Env)
{
sprintf (Msg, " ALLOC   CORE_0    :: %u\n", sizeof(objtype));
SendMsg (0, Msg);
if (Core0MoreCore (sizeof(objtype), McStat,  (addrtype *)&TheCoreImage))
{
sprintf (Msg, "                   KERNEL @ %x \n", TheCoreImage);
SendMsg (0, Msg);
}
}
if (Normal(*Status))
{
sprintf (Msg, " ALLOC   CORE_1    :: %u\n", sizeof(imagetype));
SendMsg (MSGFILE, Msg);
if (CoreMoreCore (sizeof(imagetype), McStat,  (addrtype *)&TheImage))
{
*Image= (imagetype *)TheImage;
}
}
TRACK(TrackBak,"CreateImage\n");
return(STAT);
}
boolean  VORTEx (ft F,lt Z,zz *Status)
{
*Status = Env_Normal;
if (CreateImage(McStat,&Image01))
if (ImplodeTheOry (Image01,McStat))
{
#ifdef ENV01
RenvTkn.DbId   = RenvId;
RenvTkn.Handle = Renv0_Hndl;
#endif
if (DeBug == 7)
MemTestTheOry(McStat);
}
if (Normal(*Status))
if (!Reload_Env)
{
if(CreateKernel(Image01,McStat,&CoreDb0,&CoreDb1))
;
} else {
if (!DbmBug)
WriteHdr  = True;
if (LoadKernel  (Image01,  McStat,  &CoreDb0,  &CoreDb1))
if (LoadEnv0    (McStat ))
#ifdef ENV01
if (LoadObj0    (McStat ))
#endif
*Status = Env_Installed;
}
sprintf (Msg, " VORTEx_Status == %d || %x\n", *Status, *Status);
TraceMsg (MSGFILE, Msg);
TRACK(TrackBak,"VORTEx\n");
return(STAT);
}

boolean    ImplodeTheOry (imagetype     *Image,   ft F,lt Z,zz *Status)
{
addrtype   Theory   = NullPtr;
if (MemMakeOry (McStat , &Theory))
{
Image->InTheOry  = Theory;
sprintf (Msg, " BHOOLE NATH\n");
TraceMsg (MSGFILE, Msg);
}
TRACK(TrackBak,"ImplodeTheOry\n");
return(STAT);
}
boolean    CreateKernel (imagetype      *Image,   ft F,lt Z,zz *Status,
dbheader      **Image0,  dbheader    **Image1)
{
if (CoreMoreCore (sizeof(corekernel), McStat,  (addrtype *)&Kernel))
{
Image->InCore           = (addrtype )Kernel;
SysBaseAddr.Address     = Image->InCore;
if (HmMakeDbHdr (Env_Objs,   Env_Attrs,   RenvId, McStat,    Image0))
{
CoreDbs[RenvId]     = *Image0;
(*Image0)->DbId     = RenvId;
sprintf (Msg, " KERNEL in CORE[%2u] @ %x\n", RenvId, *Image0);
TraceMsg (0, Msg);
}
*Image1                  = NullPtr;
}
TRACK(TrackBak,"CreateKernel\n");
return(STAT);
}
boolean    LoadKernel (imagetype *Image,   ft F,lt Z,zz *Status,
dbheader **Image0,   dbheader **Image1)
{
*Image0    =    NullPtr;
*Image1    =    NullPtr;
if (CoreMoreCore (sizeof(corekernel), McStat,  (addrtype *)&Kernel))
{
Image->InCore        = (addrtype )Kernel;
SysBaseAddr.Address  = Image->InCore;
if (DbmLoadDbHdr (&RenvTkn, DbFileName, McStat, Image0))
{
CoreDbs[RenvId]  = *Image0;
sprintf (Msg, " KERNEL in CORE[%2u] Restored @ %x\n",
(*Image0)->DbId, *Image0);
TraceMsg (0, Msg);
}
#ifdef ENV01
if (Normal(*Status))
if (Reload_Wenv)
{
if (DbmLoadDbHdr (&WenvTkn, WenvFileName, McStat, Image1))
CoreDbs[WenvId] = *Image1;
}
#endif
}
#ifdef ENV01
if (Normal(*Status))
if (OaGetVchunkAddr (&HdrSizeVchunkTkn,   McStat, (addrtype *)&ObjHdrSize))
if (OaGetVchunkAddr (&AllocQtyVchunkTkn,  McStat, (addrtype *)&ObjAllocQty))
if (OaGetVchunkAddr (&RegionQtyVchunkTkn, McStat, (addrtype *)&ObjRegionQty))
if (OaGetVchunkAddr (&SectorQtyVchunkTkn, McStat, (addrtype *)&ObjSectorQty))
if (DeBug)
if (OaDumpVchunkVchunk  (&SectorQtyVchunkTkn, McStat))
OaDumpVchunk        (&HdrSizeVchunkTkn, McStat);
#endif
TRACK(TrackBak,"LoadKernel\n");
return(STAT);
}
boolean    LoadEnv0     (ft F,lt Z,zz *Status)
{
#ifdef ENV01
if (TmRenvToken   (McStat ,   RenvTknPtr))
OaGetObject (RenvTknPtr,  McStat, (addrtype *)&Env0);
#endif
TRACK(TrackBak,"LoadEnv0\n");
return(STAT);
}
#ifdef ENV01
boolean    LoadObj0 (ft F,lt Z,zz *Status)
{
addrtype     ObjDesc  = NullPtr;
tokentype    ObjToken;
ObjToken.DbId    = RenvId;
ObjToken.Handle  = ObjDesc_Hndl;
OaGetObject  (&ObjToken,   McStat,       &ObjDesc);
TRACK(TrackBak,"LoadObj0\n");
return(STAT);
}
#endif
/* 当前文件是./CINT2000\255.vortex\src\env01.c*/

#define  ENV01_CSH
/* 当前文件是./CINT2000\255.vortex\src\km.h*/

typedef void    (*Cshell_code)  (tokentype    *Token,   addrtype    ArgStack);
#ifndef KRNL_H
#define KENL_H
boolean KernelCreateDb
(char         *SchemaNam,
char         *DbName,    char         *NewFile,
dbaccesstype  DbAccess,
ft F,lt Z,zz *Status,    tokentype    *DbPrimal);
boolean KernelLoadDbHdr
(tokentype    *DbToken,  char       *DbFileName,
ft F,lt Z,zz *Status);
boolean KernelFreezeObjClass
(tokentype    *Anchor,    numtype       EnvObj,
ft F,lt Z,zz *Status);
boolean Kernel_GetClassObjectCount
(tokentype    *Token,   numtype    ClassId,
ft F,lt Z,zz *Status,  numtype   *Count);
boolean KernelNew         (tokentype    *Anchor,  numtype    ObjNum,
ft F,lt Z,zz *Status,
tokentype    *ObjTkn,  addrtype  *ObjAddr);
boolean KernelCreateObject(tokentype    *Anchor,  numtype    EnvObj,
ft F,lt Z,zz *Status,  tokentype *Token);
boolean KernelNewObject   (tokentype    *Anchor,  numtype    EnvObj,
numtype       NumInits,
numtype      *AttrNums,addrtype  *Values,
ft F,lt Z,zz *Status,  tokentype *Token);
boolean KernelCreateArray (tokentype   *DbmsToken, numtype   AttrNum,
indextype     UnitCount,sizetype  UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype *ArrayAddr);
boolean KernelCreateVarray(tokentype    *DbmsToken, numtype   AttrNum,
indextype     UnitCount,sizetype  UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype *ArrayAddr);
boolean KernelIamA        (tokentype    *Token,   numtype    EnvObj,
ft F,lt Z,zz *Status);
boolean KernelWhatAmI     (tokentype    *Token,
ft F,lt Z,zz *Status,  numtype   *EnvObj);
boolean KernelGet         (tokentype    *ObjTkn,
ft F,lt Z,zz *Status,  addrtype  *ObjAddr);
boolean KernelGetObject   (tokentype    *Token,   numtype    EnvObjNum,
ft F,lt Z,zz *Status,  addrtype   Object);
boolean KernelPutObject   (tokentype    *Token,   numtype    EnvObjNum,
addrtype      Object,
ft F,lt Z,zz *Status);
boolean KernelGetAttrInfo
(numtype       AttrId,
ft F,lt Z,zz *Status,    attrobjtype  *AttrInfo);
boolean Kernel_GetFieldStruc
(char         *FieldNam,
ft F,lt Z,zz *Status,    fieldstruc    *FieldStruc);
boolean KernelGetFieldInfo
(fieldstruc  *FieldStruc,
ft F,lt Z,zz *Status,     attrobjtype *AttrInfo);
boolean KernelPutAttr  (tokentype    *Token,     numtype    EnvAttrNum,
addrtype      AttrValue, ft F,lt Z,zz *Status);
boolean KernelGetAttr  (tokentype    *Token,     numtype    EnvAttrNum,
ft F,lt Z,zz *Status,    addrtype   Value);
boolean KernelPutField
(tokentype    *Token,     fieldstruc   *FieldStruc,
addrtype      Value,     ft F,lt Z,zz *Status);
boolean KernelGetField
(tokentype    *Token,     fieldstruc   *FieldStruc,
ft F,lt Z,zz *Status,    addrtype      Value);
int     KernelCompare     (tokentype    *Token,     numtype  AttrNum,
addrtype      Value,     ptr_cmp  CmpCode,
ft F,lt Z,zz *Status);
int     KernelFieldCompare
(tokentype    *Token,   fieldstruc   *FieldStruc,
addrtype      Value,   ptr_cmp       CmpCode,
ft F,lt Z,zz *Status);
boolean KernelCreateBitField
(tokentype    *Anchor,    sizetype AllocBits,
ft F,lt Z,zz *Status,
tokentype    *BitFieldTkn);
boolean KernelDeleteBitField
(tokentype    *BitFieldTkn,
ft F,lt Z,zz *Status);
boolean KernelPutBit      (tokentype    *BitFieldTkn,
indextype     BitNum,
bytetype      BitValue,
ft F,lt Z,zz *Status);
boolean KernelGetBit      (tokentype    *BitFieldTkn,
indextype     BitNum,
ft F,lt Z,zz *Status,
bytetype     *BitValue);
boolean KernelFirstBit    (tokentype    *BitFieldTkn,
ft F,lt Z,zz *Status,
indextype    *FirstBitNum);
boolean KernelNextBit     (tokentype    *BitFieldTkn,
indextype     CurrBitNum,
ft F,lt Z,zz *Status,
indextype    *NextBitNum);
boolean KernelOwnerOf     (handletype    SetHndl, tokentype *Member,
ft F,lt Z,zz *Status,  tokentype *Owner);
boolean KernelFirstOf  (handletype    SetHndl,  tokentype *Owner,
ft F,lt Z,zz *Status,   tokentype *FirstNode,
tokentype    *FirstMember);
boolean KernelNextOf   (handletype    SetHndl,  tokentype *CurrentNode,
ft F,lt Z,zz *Status,   tokentype *NextNode,
tokentype    *NextMember);
boolean KernelAddInto     (handletype    SetHndl, tokentype *Owner,
tokentype    *NewMember,
ft F,lt Z,zz *Status);
boolean KernelFindIn      (handletype    SetDesc, tokentype *OwnerTkn,
addrtype      KeyValue,
ft F,lt Z,zz *Status,  tokentype *MemberTkn);
#endif
/* 当前文件是./CINT2000\255.vortex\src\im.h*/

#ifndef IM_H
#define IM_H
boolean ImageCreateDb     (char         *SchemaName,
char         *DbName, char       *File,
dbaccesstype  DbAccess,
ft F,lt Z,zz *Status, tokentype  *DbTkn);
boolean ImageConfigClass
(tokentype    *PrimalTkn, numtype  ClassId,
numtype       RgnEntrys,
numtype       AllocRgns, numtype  ExtendRgns,
numtype       AllocXs,   numtype  ExtendXs,
accesstype    AccessType,boolean  DiskCache,
numtype       CacheLimit,numtype  CacheLoad,
ft F,lt Z,zz *Status);
boolean ImageDbCreate     (tokentype    *Anchor, idtype        ClassId,
ft F,lt Z,zz *Status, tokentype    *Token);
boolean ImageNewObject    (tokentype    *Anchor, numtype       ClassId,
ft F,lt Z,zz *Status,
tokentype    *Token,  addrtype     *This);
boolean ImageGetObject    (tokentype    *DbmsTkn,
ft F,lt Z,zz *Status, addrtype     *This);
boolean ImageCreateObject (krnlobjtype  *This,   tokentype    *Anchor,
idtype        ClassId,numtype       AplId,
ft F,lt Z,zz *Status);
boolean Image_IsActive    (tokentype    *Token,
ft F,lt Z,zz *Status, addrtype     *This);
boolean ImageFreeObject   (krnlobjtype  *This,   numtype       AplId,
ft F,lt Z,zz *Status);
boolean ImageCommitObject (numtype       AplId,  tokentype    *Token,
addrtype      This,   boolean       Release,
ft F,lt Z,zz *Status);
boolean ImageDeleteObject (tokentype    *Token,  numtype       AplId,
ft F,lt Z,zz *Status);
boolean ImageDumpObject   (tokentype   *Token);
void    ImageDumpPseudo   (idtype       Ref_DbId,  numtype   ClassId,
addrtype     Pseudo);
boolean ImageInitClassMap (numtype      ClassId, size_t        ObjSize,
numtype      AplId,   ft F,lt Z,zz *Status);
boolean ImageAppendToMap  (numtype       AttrId, size_t        Offset,
numtype       AplId,  addrtype      AplStruct,
ft F,lt Z,zz *Status);
boolean ImageInvokeMap    (numtype       AplId,  ft F,lt Z,zz *Status);
boolean ImageGetClassMap  (numtype       ClassId,numtype       AplId,
ft F,lt Z,zz *Status,
classmaptype *ClassMap);
boolean ImageFreeClassById
(numtype       AplId,  idtype        DbId,
numtype       ClassId,ft F,lt Z,zz *Status);
boolean ImageFreeClass    (numtype       AplId,  tokentype    *Token,
ft F,lt Z,zz *Status);
boolean ImageCommitClass  (numtype       AplId,  tokentype    *Token,
numtype       ClassId,ft F,lt Z,zz *Status);
boolean Image_GetClassObjectCount
(tokentype    *Token,   numtype      ClassId,
ft F,lt Z,zz *Status,  numtype     *Count);
boolean ImageFaxToThis    (numtype       AplId,  tokentype    *Token,
addrtype      This,   ft F,lt Z,zz *Status);
boolean ImageAssertToThis (tokentype    *Token,  addrtype      Object,
ft F,lt Z,zz *Status);
boolean ImageGetActiveObject
(numtype       ClassId,tokentype    *Token,
ft F,lt Z,zz *Status, addrtype     *Object);
boolean ImageReFaxToDb    (numtype       AplId,
tokentype    *Token,  addrtype      This,
boolean       Release,boolean       FreeMem,
ft F,lt Z,zz *Status);
boolean ImageFreeDbObject (numtype       AplId,  tokentype    *Token,
ft F,lt Z,zz *Status);
boolean ImageFreeCppObject
(tokentype    *Token,  boolean    FreeImage,
ft F,lt Z,zz *Status);
boolean ImageRevokeObject (numtype       AplId,  tokentype    *Token,
ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\shell.h*/

#ifndef SCHELL_H
#define SCHELL_H
#ifdef SHELL
typedef void*     (*new_code)      (size_t   ClassSize);
typedef tokentype (*GetToken_code) (addrtype This);
typedef boolean (*shell_code00) (void);
typedef struct Code04StackBLk {
char   StackBlk[4];
}       code04type;
typedef boolean      (*shell_code04) (code04type    ArgStack);
typedef struct Code08StackBLk {
char   StackBlk[8];
}       code08type;
typedef boolean      (*shell_code08) (code08type    ArgStack);
typedef struct Code16StackBLk {
char   StackBlk[16];
}       code16type;
typedef boolean       (*shell_code16) (code16type    ArgStack);
typedef struct Code20StackBLk {
char   StackBlk[20];
}       code20type;
typedef boolean       (*shell_code20) (code20type    ArgStack);
typedef struct Code24StackBLk {
char   StackBlk[24];
}       code24type;
typedef boolean       (*shell_code24) (code24type    ArgStack);
#endif
boolean ShellLoadObjCode  (numtype       ObjNum,  funcptrtype CodeAddr,
ft F,lt Z,zz *Status);
boolean ShellGetObjCode   (numtype       ObjNum,
ft F,lt Z,zz *Status,
funcptrtype  *CodeAddr, size_t   *Size);
boolean ShellLoadTokenCode
(numtype       ObjNum,  funcptrtype CodeAddr,
ft F,lt Z,zz *Status);
boolean ShellGetTokenCode (numtype       ObjNum,
ft F,lt Z,zz *Status, funcptrtype *CodeAddr);
#endif
#ifndef INLINE_OMIDEFS
#else
#define        ObjTraits_Hndl         (handletype )658
#define        RenvObjs_Hndl          (handletype )674
#define        RenvViews_Hndl         (handletype )685
#define        RenvDescs_Hndl         (handletype )688
#define        WenvDbs_Hndl           (handletype )692
#endif




















boolean Env_GetTypeId    (char         *TypeName,
ft F,lt Z,zz *Status,    numtype      *TypeId)
{
tokentype  TypeTkn    = NullToken;
if (ClassBug)
if (sprintf (Msg, " Env_GetTypeId  for Type = %21s\n",
TypeName))
TraceMsg   (0, Msg);
if (KernelFindIn     (RenvDescs_Hndl,               &RenvTkn,
(addrtype )TypeName,
McStat,          (tokentype *)&TypeTkn))
KernelGetAttr    (&TypeTkn,                     TypeNum_AttrNum,
McStat,          (addrtype   )TypeId);
if (ClassBug)
if (sprintf (Msg, "               TypeId             = %3u\n",
*TypeId))
TraceMsg (0, Msg);
if (!Normal(*Status))
if (sprintf  (Msg, "***ERROR (%6u)***  @Env_GetTypeId\n",
*Status))
if (TraceMsg (0, Msg))
if (sprintf  (Msg, "              TypeName = %s\n\n",
TypeName))
if (TraceMsg (0, Msg))
{
*Status  = Env_IdErrata;
return (False);
}
TRACK(TrackBak,"Env_GetTypeId\n");
return (STAT);
}
boolean Env_GetClassId
(char         *ClassName,
ft F,lt Z,zz *Status,    numtype      *ClassId)
{
tokentype  ClassTkn    = NullToken;
if (ClassBug)
if (sprintf (Msg, " Env_GetClassId   for      <%s>.\n",
ClassName))
TraceMsg   (0, Msg);
if (KernelFindIn     (RenvObjs_Hndl,                &RenvTkn,
(addrtype )ClassName,
McStat,          (tokentype *)&ClassTkn))
KernelGetAttr    (&ClassTkn,                    ObjNum_AttrNum,
McStat,         (addrtype    )ClassId);
if (ClassBug)
if (sprintf (Msg, "               ClassId            = %3u\n",
*ClassId))
TraceMsg   (0, Msg);
if (!Normal(*Status))
if (sprintf  (Msg, "***ERROR (%6u)***  @Env_GetClassId\n",
*Status))
if (TraceMsg (0, Msg))
if (sprintf  (Msg, "              ClassName  = %s\n\n",
ClassName))
if (TraceMsg (0, Msg))
{
*Status  = Env_IdErrata;
return (False);
}
TRACK(TrackBak,"Env_GetClassId\n");
return (STAT);
}
boolean Env_GetAttrId    (char         *AttrName,
ft F,lt Z,zz *Status,    numtype      *AttrId)
{
tokentype  AttrTkn    = NullToken;
if (ClassBug)
if (sprintf (Msg, " Env_GetAttrId    for      <%s>. \n",
AttrName))
TraceMsg   (0, Msg);
if (KernelFindIn     (RenvDescs_Hndl,               &RenvTkn,
(addrtype )AttrName,
McStat,          (tokentype *)&AttrTkn))
KernelGetAttr    (&AttrTkn,                     AttrNum_AttrNum,
McStat,          (addrtype   )AttrId);
if (ClassBug)
if (sprintf (Msg, "               AttrId             = %3u\n",
*AttrId))
TraceMsg   (0, Msg);
if (!Normal(*Status))
if (sprintf  (Msg, "***ERROR (%6u)***  @Env_GetAttrId\n",
*Status))
if (TraceMsg (0, Msg))
if (sprintf  (Msg, "              AttrName = %s\n\n",
AttrName))
if (TraceMsg (0, Msg))
{
*Status  = Env_IdErrata;
return (False);
}
TRACK(TrackBak,"Env_GetAttrId\n");
return (STAT);
}
boolean Env_NewFieldStruc
(char         *FieldName,
ft F,lt Z,zz *Status,    fieldstruc  **FieldStruc)
{
static bytessizetype StrucSize    = sizeof (fieldstruc);
static bytessizetype TknsSize     = sizeof (fieldspec) * 10;
fieldstruc          *EnvField;
if (Core_MoreCore  (StrucSize,   McStat,  (addrtype *)&EnvField))
if (Core_MoreCore  (TknsSize,    McStat,  (addrtype *)&EnvField->FieldTkns))
if (Env_GetFieldStruc
(FieldName,   McStat,               EnvField))
*FieldStruc     = EnvField;
TRACK(TrackBak,"Env_NewFieldStruc\n");
return (STAT);
}
boolean Env_GetFieldStruc
(char         *FieldName,
ft F,lt Z,zz *Status,    fieldstruc   *FieldStruc)
{
if (ClassBug)
if (sprintf (Msg, " Env_GetFieldStruc for <%s>\n",
FieldName))
TraceMsg   (0, Msg);
if (!Kernel_GetFieldStruc
(FieldName,     McStat,   FieldStruc))
if (sprintf  (Msg, "***ERROR (%6u)***  @Env_GetFieldStruc\n",
*Status))
if (TraceMsg (0, Msg))
if (sprintf  (Msg, "              FieldName = %s\n\n",
FieldName))
if (TraceMsg (0, Msg))
{
*Status  = Env_IdErrata;
return (False);
}
TRACK(TrackBak,"Env_GetFieldStruc\n");
return (STAT);
}
boolean Env_DeleteFieldStruc
(ft F,lt Z,zz *Status,    fieldstruc  **FieldStruc)
{
static bytessizetype StrucSize    = sizeof (fieldstruc);
static bytessizetype TknsSize     = sizeof (fieldspec) * 10;
fieldstruc          *EnvField     = *FieldStruc;
if (Core_FreeCoreSpace  ((addrtype *)&EnvField->FieldTkns,     TknsSize,
McStat))
Core_FreeCoreSpace  ((addrtype *)FieldStruc,  StrucSize,   McStat);
TRACK(TrackBak,"Env_DeleteFieldStruc\n");
return (STAT);
}
boolean Env_GetSetId     (char         *SetName,
ft F,lt Z,zz *Status,    numtype      *SetId)
{
tokentype  SetTkn    = NullToken;
if (ClassBug)
if (sprintf (Msg, " Env_GetSetId  for Set = %21s\n",
SetName))
TraceMsg   (0, Msg);
if (KernelFindIn     (RenvDescs_Hndl,                &RenvTkn,
(addrtype )SetName,
McStat,           (tokentype *)&SetTkn))
KernelGetAttr    (&SetTkn,                        SetNum_AttrNum,
McStat,           (addrtype    )SetId);
*SetId = (numtype )SetTkn.Handle;
if (ClassBug)
if (sprintf (Msg, "               SetId  = %3u, SetDesc[ 1:%8u]\n",
*SetId, SetTkn.DbId, SetTkn.Handle))
TraceMsg   (0, Msg);
TRACK(TrackBak,"Env_GetSetId\n");
return (STAT);
}
boolean Env_GetTupleId   (char         *TupleName,
ft F,lt Z,zz *Status,    numtype      *TupleId)
{
tokentype  TupleTkn    = NullToken;
if (ClassBug)
if (sprintf (Msg, " Env_GetTupleId  for Tuple = %21s\n",
TupleName))
TraceMsg   (0, Msg);
if (KernelFindIn     (RenvDescs_Hndl,                &RenvTkn,
(addrtype )TupleName,
McStat,           (tokentype *)&TupleTkn))
*TupleId = (numtype )TupleTkn.Handle;
if (ClassBug)
if (sprintf (Msg, "               TupleId  = %3u, TupleDesc[ 1:%8u]\n",
*TupleId, TupleTkn.DbId, TupleTkn.Handle))
TraceMsg   (0, Msg);
TRACK(TrackBak,"Env_GetTupleId\n");
return (STAT);
}
boolean Env_GetMatrixId  (char         *MatrixName,
ft F,lt Z,zz *Status,    numtype      *MatrixId)
{
tokentype  MatrixTkn    = NullToken;
if (ClassBug)
if (sprintf (Msg, " Env_GetMatrixId  for Matrix = %21s\n",
MatrixName))
TraceMsg   (0, Msg);
if (KernelFindIn     (RenvDescs_Hndl,                &RenvTkn,
(addrtype )MatrixName,
McStat,           (tokentype *)&MatrixTkn))
*MatrixId = (numtype )MatrixTkn.Handle;
if (ClassBug)
if (sprintf (Msg, "               MatrixId  = %3u, MatrixDesc[ 1:%8u]\n",
*MatrixId, MatrixTkn.DbId, MatrixTkn.Handle))
TraceMsg   (0, Msg);
TRACK(TrackBak,"Env_GetMatrixId\n");
return (STAT);
}
boolean Env_LoadCreateCode
(numtype       ClassId,    funcptrtype   CodePtr,
ft F,lt Z,zz *Status)
{
if (ClassBug)
if (sprintf (Msg, " Env_LoadCreateCode    for ClassId = %4u\n",
ClassId))
TraceMsg   (0, Msg);
ShellLoadObjCode   (ClassId,     CodePtr,     McStat);
TRACK(TrackBak,"Env_LoadCreateCode\n");
return (STAT);
}
boolean Env_LoadGetTknCode
(numtype       ClassId,    funcptrtype   CodePtr,
ft F,lt Z,zz *Status)
{
if (ClassBug)
if (sprintf (Msg, " Env_LoadGetTknCode    for ClassId = %4u\n",
ClassId))
TraceMsg   (0, Msg);
ShellLoadTokenCode   (ClassId,     CodePtr,     McStat);
TRACK(TrackBak,"Env_LoadGetTknCode\n");
return (STAT);
}
boolean Env_InitClassMap (numtype       ClassId,   size_t        ObjSize,
numtype       AplId,     ft F,lt Z,zz *Status)
{
if (ClassBug)
if (sprintf (Msg, " Env_InitClassMap[%4u]... Apl= %3u  ObjSize = %4u\n",
ClassId,  AplId, ObjSize))
TraceMsg   (0, Msg);
ImageInitClassMap         (ClassId,  ObjSize,  AplId,  McStat);
TRACK(TrackBak,"Env_InitClassMap\n");
return (STAT);
}
boolean Env_AppendToMap  (numtype       AttrId,    size_t        Offset,
ft F,lt Z,zz *Status)
{
addrtype  AplStruct  = NullPtr;
if (ClassBug
||  AttrId == 0)
if (sprintf (Msg,
" Env_AppendToMap ::AttrNum = %3u; Offset = %4u\n",
AttrId,  Offset))
TraceMsg   (0, Msg);
if (AttrId == 0)
{
TraceMsg   (0, "***ERROR*** @Env_AppendToMap... NullAttrId\n");
*Status   = Env_IdErrata;
}
if (Normal(*Status))
ImageAppendToMap   (AttrId,    Offset,     C_Apl,  AplStruct,  McStat);
TRACK(TrackBak,"Env_AppendToMap\n");
return (STAT);
}
boolean EnvInvokeMap     (numtype       AplId,     ft F,lt Z,zz *Status)
{
if (ClassBug)
TraceMsg   (0, " Env_InvokeMap\n");
ImageInvokeMap        (AplId,   McStat);
TRACK(TrackBak,"Env_InvokeMap\n");
return (STAT);
}
boolean EnvGetClassMap   (numtype       ClassId,   numtype       AplId,
ft F,lt Z,zz *Status,    classmaptype *ClassMap)
{
if (ClassBug)
if (sprintf (Msg, " Env_GetClassMap :: ClassId = %3u; AplId = %4u\n",
ClassId,  AplId))
TraceMsg   (0, Msg);
ImageGetClassMap   (ClassId, AplId,   McStat,  ClassMap);
TRACK(TrackBak,"Env_GetClassMap\n");
return (STAT);
}
boolean Env_GetAttrInfo  (numtype       AttrId,
ft F,lt Z,zz *Status,    attrinfotype *AttrInfo)
{
if (ClassBug)
if (sprintf(Msg, "   Env_GetAttrInfo Attr= %3u\n", AttrId))
TraceMsg (0, Msg);
KernelGetAttrInfo (AttrId,   McStat,  AttrInfo);
if (ClassBug)
if (sprintf(Msg, "        AttrInfoType = %21s\n", AttrInfo->AttrName))
TraceMsg (0, Msg);
TRACK(TrackBak,"Env_GetAttrInfo\n");
return (STAT);
}
boolean Env_IsValidToken (tokentype    *Token,     ft F,lt Z,zz *Status)
{
boolean    IsValid   = False;
if (ClassBug)
if (sprintf (Msg, " Env_IsValidToken:: [%3u:%8u]\n",
Token->DbId,  Token->Handle))
TraceMsg   (0, Msg);
if (Token->DbId > 0)
IsValid   = TmIsValid         (Token,                     McStat);
STAT;
TRACK(TrackBak,"Env_IsValidToken\n");
*Status   = Env_Normal;
return (IsValid);
}
boolean Env_TokenIsEquiv (tokentype    *Token0,    tokentype    *Token1)
{
if (Token0->DbId   == Token1->DbId
&&  Token0->Handle == Token1->Handle)
return (True);
else
return (False);
}
boolean Env_ReclaimHandles (tokentype    *Token,     ft F,lt Z,zz *Status)
{
boolean    IsValid   = False;
if (ClassBug)
if (sprintf (Msg, " Env_ReclaimHandles:: [%3u:%8u]\n",
Token->DbId,  Token->Handle))
TraceMsg   (0, Msg);
if (Token->DbId > 0)
IsValid   = TmReclaimHandles (Token,                     McStat);
STAT;
TRACK(TrackBak,"Env_ReclaimHandles\n");
*Status   = Env_Normal;
return (IsValid);
}
boolean Env_GenerateRandomNumbers
(indextype     Count,     ft F,lt Z,zz *Status)
{
int            i            = 0;
unsigned       Seed         = 0;
Seed          = 1008;
srand(Seed);
if (Count == 0)
return (STAT);
if (Count  > 50000)
Count  = 50000;
else if (Count  < 10000)
Count  = 10000;
Random_Limit  = Count;
if (!Vchunk_IsValidToken   (&Random_Tkn,   McStat))
{
*Status   = Env_Normal;
sprintf (Msg, "\n INITIALIZE <%8u>  RANDOM NUMBERS :: seed= %u\n",
Random_Limit, Seed);
TraceMsg (0, Msg);
if (Vchunk_Create      (&WenvTkn,  sizeof (long),   Count,  10000,
McStat,                    &Random_Tkn))
if (Vchunk_PutStackPtr (&Random_Tkn,                Count,
McStat,        (addrtype *)&Random_Dir))
for (i = -1; ++i < Random_Limit; )
{
Random_Dir[i] = rand();
}
if (Normal(*Status))
Vchunk_Commit      (&Random_Tkn,   False,  McStat);
Random_ItNum  = 0;
sprintf (Msg, "\n RANDOM NUMBERS Dir [%4u:%8u]. Count= %8u\n",
Random_Tkn.DbId, Random_Tkn.Handle, Random_Limit);
TraceMsg (0, Msg);
} else {
if (Normal(*Status))
if (Vchunk_GetStackPtr (&Random_Tkn,    McStat,  &Random_Limit))
if (Vchunk_GetAddress  (&Random_Tkn,    McStat,  (addrtype *)&Random_Dir))
{
Random_ItNum  = 0;
sprintf (Msg, "\n RANDOM NUMBERS Dir [%4u:%8u].\n",
Random_Tkn.DbId, Random_Tkn.Handle);
TraceMsg (0, Msg);
}
}
TRACK(TrackBak,"Env_GenerateRandomNumbers\n");
return (STAT);
}
int   Env_Random (numtype       Limit)
{
int  RandomNumber = 0;
Random_ItNum++;
if (Random_Dir     == NullPtr)
RandomNumber     = rand()                   % Limit;
else {
if (Random_ItNum > Random_Limit)
Random_ItNum = 0;
RandomNumber     = Random_Dir[Random_ItNum] % Limit;
}
return(RandomNumber);
}
/* 当前文件是./CINT2000\255.vortex\src\env1.c*/

#define ENV1_C
#define        DefaultValue_AttrNum       (numtype )0






#define MemPutLocalObjNum   Mem_PutWord
#define MemPushSize         Mem_PushWord
#define MemGetSize          Mem_GetWord
#define MemPushObjNum       Mem_PushWord
#define MemPutObjNum        Mem_PutWord
#define MemGetObjNum        Mem_GetWord
#define MemPushObjHdr       Mem_PushAddr
#define MemPutHandle        Mem_PutWord
#define MemGetHandle        Mem_GetWord
#define MemPutFieldNum      Mem_PutWord
#define MemPushFieldNum     Mem_PushWord
#define MemPushFieldOffset  Mem_PushWord
#define MemPushAttrNum      Mem_PushWord
#define MemPutAttrNum       Mem_PutWord
#define MemGetAttrNum       Mem_GetWord
#define MemPushNum          Mem_PushWord
boolean    EnvNewObjDesc    (tokentype    *Anchor,  desctype      ObjDescType,
ft F,lt Z,zz *Status,
objdesctype **ObjDesc, tokentype    *Token)
{
*Status   = Err_NotImplemented;
TRACK(TrackBak,"EnvNewObjDesc\n");
return (STAT);
}
boolean    EnvFetchObjNum     (tokentype    *ObjTkn,
ft F,lt Z,zz *Status, numtype *ObjNum)
{
dbheader   *CoreDb  = NullPtr;
if (TmFetchCoreDb  (ObjTkn,  McStat,  &CoreDb))
HmGetObjNum    (CoreDb,                   ObjTkn->Handle,
McStat,                   ObjNum);
TRACK(TrackBak,"EnvFetchObjNum\n");
return (STAT);
}
boolean    EnvFetchObjHandle  (numtype       ObjNum,
ft F,lt Z,zz *Status, handletype *ObjHandle)
{
MemGetHandle (CoreDb0->ObjHandleDir, ObjNum,  McStat, (word *)ObjHandle);
TRACK(TrackBak,"EnvFetchObjHandle\n");
return (STAT);
}
boolean    EnvPairObjHandle   (numtype       ObjNum,  handletype ObjHandle,
ft F,lt Z,zz *Status)
{
MemPutHandle (CoreDb0->ObjHandleDir, ObjNum,  ObjHandle,  McStat);
TRACK(TrackBak,"EnvPairObjHandle\n");
return (STAT);
}
boolean    EnvFetchObjSize   (numtype       ObjNum,
ft F,lt Z,zz *Status,  bytessize *SizeInBytes)
{
numtype    LocalObjNum = 0;
objheader *ObjHdr      = NullPtr;
if (MemGetObjNum (CoreDb0->LocalObjNumMap, ObjNum, McStat, &LocalObjNum))
if (LocalObjNum == 0)
EnvInstallObjHdr  (&RenvTkn, ObjNum, McStat,   &LocalObjNum);
if (Normal(*Status))
OmGetObjHdr  (&RenvTkn, LocalObjNum, McStat, &ObjHdr);
if (ObjHdr)
*SizeInBytes = ObjHdr->ObjSize;
else
*Status      = Env_ObjNoHdr;
TRACK(TrackBak,"EnvFetchObjSize\n");
return (STAT);
}
boolean    EnvFetchObjName   (numtype       ObjNum,
ft F,lt Z,zz *Status,  char    *ObjName)
{
handletype     ObjHandle = 0;
objdesctype   *ObjDesc   = NullPtr;
tokentype      ObjDescTkn;
indextype      Index     = 0;
if (MemGetHandle    (CoreDb0->ObjHandleDir,               ObjNum,
McStat,                             &ObjHandle))
{
ObjDescTkn.DbId     = RenvId;
ObjDescTkn.Handle   = ObjHandle;
OmGetObject       (&ObjDescTkn,
McStat,       &Index,   (addrtype *)&ObjDesc);
strcpy (ObjName,   ObjDesc->Nam);
}
TRACK(TrackBak,"EnvFetchObjName\n");
return (STAT);
}
boolean    EnvFetchClassSize (numtype       ObjNum,
ft F,lt Z,zz *Status,  size_t  *ClassSize)
{
handletype    ObjDescHndl = NullHandle;
objdesctype  *ObjDesc     = NullPtr;
tokentype     ObjDescTkn;
if (MemGetHandle    (CoreDb0->ObjHandleDir,               ObjNum,
McStat,                             &ObjDescHndl))
{
ObjDescTkn.DbId   = RenvId;
ObjDescTkn.Handle = ObjDescHndl;
OaGetObject      (&ObjDescTkn,    McStat, (addrtype *)&ObjDesc);
}
if (Normal(*Status))
if ((*ClassSize  =  ObjDesc->PsudoSize) == 0)
*ClassSize    =  ObjDesc->ObjSize;
TRACK(TrackBak,"EnvFetchClassSize\n");
return (STAT);
}
boolean EnvFetchLastObjCount  (ft F,lt Z,zz *Status,   numtype *ObjCount)
{
*ObjCount = CoreDb0->LastEnvObjCount;
TRACK(TrackBak,"EnvFetchObjNum\n");
return (STAT);
}
boolean    EnvFetchObjCestrs  (numtype       ObjNum,
ft F,lt Z,zz *Status, tokentype *ObjCestors)
{
handletype    ObjDescHndl = NullHandle;
objdesctype  *ObjDesc     = NullPtr;
tokentype     ObjDescTkn;
indextype     Index       = 0;
ObjDescTkn.DbId   = RenvId;
ObjCestors->DbId  = RenvId;
if (MemGetHandle    (CoreDb0->ObjHandleDir, ObjNum,  McStat, &ObjDescHndl))
{
ObjDescTkn.Handle   = ObjDescHndl;
OmGetObject     (&ObjDescTkn,
McStat,               &Index,   (addrtype *)&ObjDesc);
}
if (Normal(*Status))
ObjCestors->Handle = ObjDesc->CestorsOfObj;
TRACK(TrackBak,"EnvFetchObjCestrs\n");
return (STAT);
}
boolean    Env_FetchObjCendents
(numtype       ObjNum,
ft F,lt Z,zz *Status, tokentype *ObjCendents)
{
handletype    ObjDescHndl = NullHandle;
objdesctype  *ObjDesc     = NullPtr;
tokentype     ObjDescTkn;
indextype     Index       = 0;
ObjDescTkn.DbId    = RenvId;
ObjCendents->DbId  = RenvId;
if (MemGetHandle    (CoreDb0->ObjHandleDir, ObjNum,  McStat, &ObjDescHndl))
{
ObjDescTkn.Handle   = ObjDescHndl;
OmGetObject     (&ObjDescTkn,
McStat,               &Index,   (addrtype *)&ObjDesc);
}
if (Normal(*Status))
ObjCendents->Handle = ObjDesc->CendentsOfObj;
TRACK(TrackBak,"Env_FetchObjCendents\n");
return (STAT);
}
boolean    EnvFetchSchemaObjs  (numtype      ObjNum,
ft F,lt Z,zz *Status, tokentype *SchemaObjs)
{
handletype    ObjDescHndl = NullHandle;
objdesctype  *ObjDesc     = NullPtr;
tokentype     ObjDescTkn;
SchemaObjs->DbId  = RenvId;
if (MemGetHandle    (CoreDb0->ObjHandleDir, ObjNum,  McStat, &ObjDescHndl))
{
ObjDescTkn.DbId    = RenvId;
ObjDescTkn.Handle  = ObjDescHndl;
if (OaGetObject    (&ObjDescTkn,       McStat, (addrtype *)&ObjDesc))
SchemaObjs->Handle = ObjDesc->CestorsOfObj;
}
TRACK(TrackBak,"EnvFetchSchemaObjs\n");
return (STAT);
}
boolean    DeleteObjDesc (tokentype *Token, ft F,lt Z,zz *Status)
{
objdesctype  *ObjDesc = NullPtr;
OaGetObject (Token, McStat, (addrtype *)&ObjDesc);
TRACK(TrackBak,"DeleteObjDesc\n");
return (STAT);
}
boolean    EnvBldObjHdr (tokentype    *Anchor,        numtype   EnvObjNum,
indextype     AllocQty,
ft F,lt Z,zz *Status,
numtype      *FieldNumMap, chunknum *FieldOffsetDir,
chunknum     *ClassOffsetDir,
indextype   **FieldCount,  chunknum *LocalAttrNumMap,
indextype   **FieldRefCount,
chunknum     *FieldRefDir)
{
objheader *ObjHdr        = NullPtr;
if (Anchor->DbId != RenvId)
*Status = Env_BadDbId;
if (AllocQty)
{
if (OmNewObjHdr (&RenvTkn,  EnvObjNum,  AllocQty, McStat,  &ObjHdr))
{
ObjHdr->ObjSize =  ObjHdrSize[EnvObjNum];
ObjHdr->FieldCount = 0;
if (DeBug || OaBug)
TraceMsg (0, "   NEW ");
} else {
if (*Status == Om_ObjHdrExists)
{
*Status = Env_Normal;
OmGetObjHdr (&RenvTkn, EnvObjNum, McStat, &ObjHdr);
}
if (DeBug || OaBug)
TraceMsg (0, "   GET ");
}
if (ObjHdr == NULL)
*Status = Env_NullObjHdr;
if (Normal(*Status))
{
*LocalAttrNumMap =   ObjHdr->LocalAttrNumMap;
*FieldNumMap     =   ObjHdr->FieldNumMap;
*FieldOffsetDir  =   ObjHdr->FieldOffsetDir;
*ClassOffsetDir  =   ObjHdr->ClassOffsetDir;
*FieldCount      = &(ObjHdr->FieldCount);
*FieldRefCount   = &(ObjHdr->FieldRefCount);
*FieldRefDir     =   ObjHdr->FieldRefDir;
} else {
*Status = Env01_BadDescTypeType;
}
} else  {
sprintf (Msg, " *** ObjHeader for EnvObj = %u has ZERO AllocQty\n",
EnvObjNum);
TraceMsg (0, Msg);
*Status = Env_ZeroAllocQty;
}
TRACK(TrackBak,"EnvBldObjHdr\n");
return (STAT);
}
boolean    EnvInstallObjHdr (tokentype    *Anchor,     numtype   EnvObjNum,
ft F,lt Z,zz *Status,     numtype  *LocalObj)
{
objheader *ObjHdr        = NullPtr;
sizetype   ObjSize       = 0;
addrtype   HdrAddr       = NullPtr;
if (ObjAllocQty[EnvObjNum])
{
if (DeBug || OaBug || FileBug)
if (sprintf (Msg, " Install ObjHdr for Obj[%3u] In CoreDb[%2u]\n",
EnvObjNum, Anchor->DbId))
TraceMsg (0, Msg);
if (OmNewObjHdr (Anchor,    EnvObjNum,  ObjAllocQty[EnvObjNum],
McStat,  &ObjHdr))
{
ObjHdr->ObjSize =  ObjHdrSize[EnvObjNum];
ObjHdr->FieldCount = 0;
if (DeBug || OaBug)
TraceMsg (0, "   NEW ");
} else {
if (*Status == Om_ObjHdrExists)
{
*Status = Env_Normal;
OmGetObjHdr (Anchor,   EnvObjNum,  McStat,   &ObjHdr);
}
if (DeBug || OaBug)
TraceMsg (0, "   GET ");
}
if (ObjHdr == NULL) *Status = Env_NullObjHdr;
if (Normal(*Status))
{
*LocalObj  = ObjHdr->LocalObjNum;
if (ObjHdrSize[EnvObjNum] == 0)
{
if (OaGetUnit        (&HdrSizeVchunkTkn, EnvObjNum,
McStat,            (addrtype )&ObjSize))
if (OaGetVchunkAddr  (&HdrSizeVchunkTkn,
McStat,            &HdrAddr))
if (ObjSize)
ObjHdrSize[EnvObjNum] = ObjSize;
else
*Status = Err_BadDesign;
}
if (Normal(*Status))
if (InstallObjChunks (Anchor, ObjHdr, EnvObjNum, McStat))
if (*Status == Env_ZeroAllocQty)
*Status = Env_Normal;
} else {
*Status = Env01_BadDescTypeType;
}
} else  {
sprintf (Msg, " *** ObjHeader for EnvObj = %u has ZERO AllocQty\n",
EnvObjNum);
TraceMsg (0, Msg);
*Status = Env_ZeroAllocQty;
}
TRACK(TrackBak,"EnvInstallObjHdr\n");
return (STAT);
}
boolean InstallObjChunks (tokentype *Anchor,    objheader    *ObjHdr,
numtype    ObjNum,    ft F,lt Z,zz *Status)
{
dbheader     *CoreDb          = NullPtr;
objdesctype  *EnvObj          = NullPtr;
indextype     StackPtr        = 0;
tokentype     ObjToken;
tokentype     TypeToken;
tokentype     AttrToken;
attrdesctype *EnvAttr         = NullPtr;
typedesctype *EnvType         = NullPtr;
tokentype     VclasssTkn;
tokentype     VoffsetsTkn;
tokentype     VfieldToken;
wordtype     *Vclasss         = NullPtr;
typeunsize   *Voffsets        = NullPtr;
wordtype     *Vchunk          = NullPtr;
indextype     Vindex          = 0;
indextype     LocalAttrNum    = 0;
numtype       FieldNum        = 0;
indextype     Fields          = 0;
indextype     Classs          = 0;
indextype     FieldCount      = 0;
indextype     ClassCount      = 0;
indextype     FieldRefCount   = 0;
indextype     FieldArrayCount = 0;
indextype     FieldMapCount   = 0;
bytessize     Offset          = 0;
typeunsize    ClassOffset     = 0;
boolean       AttrFound       = False;
boolean       SystemObj       = True;
sizetype      EnvTypeSize     = 0;
tokentype     BldDescTkn;
objdesctype  *BldDesc         = NullPtr;
objheader    *BldObjHdr       = NullPtr;
maptkntype    BldMapTkn;
reftkntype    FieldRefTkn;
ObjToken.DbId     = RenvId;
TypeToken.DbId    = RenvId;
AttrToken.DbId    = RenvId;
VclasssTkn.DbId   = RenvId;
VoffsetsTkn.DbId  = RenvId;
VfieldToken.DbId  = RenvId;
BldDescTkn.DbId   = RenvId;
BldMapTkn.FieldNum   = 0;
BldMapTkn.LocalObj   = 0;
if (TmFetchCoreDb     (Anchor,    McStat, &CoreDb))
if (EnvFetchObjHandle (ObjNum,    McStat, &ObjToken.Handle))
if (OaGetObject       (&ObjToken, McStat, (addrtype *)&EnvObj))
{
VfieldToken.Handle = EnvObj->Fields;
VclasssTkn.Handle  = EnvObj->ClassFields;
VoffsetsTkn.Handle = EnvObj->ClassOffsets;
if (EnvObj->ObjNum > EOS_ObjNum)
SystemObj = False;
}
if (Normal(*Status))
if (OaGetVchunkAddr     (&VclasssTkn,   McStat, (addrtype *)&Vclasss))
if (OaGetVchunkAddr     (&VoffsetsTkn,  McStat, (addrtype *)&Voffsets))
if (OaGetVchunkAddr     (&VfieldToken,  McStat, (addrtype *)&Vchunk))
if (OaGetVchunkStackPtr (&VfieldToken,  McStat, &Fields))
if (OaGetVchunkStackPtr (&VclasssTkn,   McStat, &Classs))
if (DeBug)
OaDumpVchunk        (&VfieldToken,  McStat);
Vindex = 0;
if (Fields)
while (Normal(*Status) && Fields-- > 0)
{
if (EnvFetchAttrHandle (Vchunk[Vindex],
McStat,           &AttrToken.Handle))
if (OaGetObject (&AttrToken, McStat, (addrtype *)&EnvAttr))
{
if (EnvAttr->AttrNum   == That_AttrNum)
ObjHdr->EnvObjType  = That_AttrNum;
TypeToken.Handle = EnvAttr->TypeObj;
if (OaGetObject (&TypeToken, McStat, (addrtype *)&EnvType))
if (DeBug)
if (sprintf (Msg, " Build FieldMapType :: \n"))
TraceMsg (0, Msg);
if (Normal(*Status))
if (EnvAttr->AttrType == aMapRefAttr)
{
BldDescTkn.Handle = EnvAttr->BuildDesc;
if (OaGetObject (&BldDescTkn,   McStat, (addrtype *)&BldDesc))
if (OaInstallObjHdr (Anchor,                  BldDesc->ObjNum,
McStat,                 &BldObjHdr))
EnvTypeSize   = BldDesc->ObjSize;
if (StrucAlignment  >= 4)
{
}
if (DeBug || OaBug)
if (sprintf (Msg,
" MapRefAttr  BldDesc->ObjNum = %2u; Size= %3u\n",
BldDesc->ObjNum, EnvTypeSize))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "             ObjHdr->ObjNum  = %2u;\n",
BldObjHdr->ObjNum))
TraceMsg (0, Msg);
if (OaGetObject (&ObjToken,  McStat, (addrtype *)&EnvObj))
if (OaGetObject (&AttrToken, McStat, (addrtype *)&EnvAttr))
OaGetObject (&TypeToken, McStat, (addrtype *)&EnvType);
} else {
if (EnvAttr->AttrType == aArrayAttr)
EnvTypeSize = sizeof (handletype);
else if (EnvAttr->AttrType == aDblPtrAttr)
EnvTypeSize = sizeof (handletype);
else if (EnvAttr->AttrType == aVarrayAttr)
EnvTypeSize = sizeof (handletype);
else if (EnvAttr->AttrType == aVchunkAttr)
EnvTypeSize = sizeof (tokentype);
else
EnvTypeSize   = EnvType->Size;
if (EnvAttr->AttrNum != That_AttrNum)
{
if (EnvAttr->AttrNum == DefaultValue_AttrNum)
EnvAlignMember (EnvAttr->AttrType,          aAddr,
EnvTypeSize,      (sizetype *)&Offset);
else
EnvAlignMember (EnvAttr->AttrType,          EnvType->TypeType,
EnvTypeSize,      (sizetype *)&Offset);
} else {
EnvTypeSize     = 0;
}
}
EnvTypeSize *= EnvAttr->UnitSize;
if (EnvAttr->UnitSize > 1)
if (AdminBug || DeBug)
if (sprintf (Msg, "     EnvTypeSize = %3u\n", EnvTypeSize))
TraceMsg (0, Msg);
if (Normal(*Status))
MemPushFieldOffset (ObjHdr->FieldOffsetDir,     Offset,
McStat,                    &FieldNum);
ClassCount  = 0;
AttrFound   = False;
ClassOffset = -1;
if (Normal(*Status))
while (ClassCount < Classs
&&    !AttrFound)
{
if (Vclasss[ClassCount] == Vchunk[Vindex])
{
AttrFound   = True;
ClassOffset = Offset;
Voffsets[ClassCount] = Offset;
}
++ClassCount;
}
if (Normal(*Status))
MemPushFieldOffset (ObjHdr->ClassOffsetDir,
(typesize )ClassOffset,
McStat,                    &FieldNum);
if (Normal(*Status))
if (! strcmp (EnvType->Nam, "referencetype"))
{
FieldRefTkn.FieldNum = FieldNum;
FieldRefTkn.CppAlign = 0;
if (MemPushSomeBytes (ObjHdr->FieldRefDir,   sizeof (reftkntype),
(addrtype )&FieldRefTkn,
McStat,            &StackPtr))
FieldRefCount++;
if (DeBug || OaBug)
if (sprintf (Msg, " RefPtrType for FieldNum = %2u offset@ %3u\n",
FieldRefTkn.FieldNum, Offset))
SendMsg (0, Msg);
} else if (EnvAttr->AttrType == aMapRefAttr) {
if (FieldMapCount == 0)
if (MemMakeChunk   (sizeof(maptkntype),    Alloc_FieldRefs,
Extend_FieldRefs,      RenvId,
McStat,               &(ObjHdr->FieldMapDir)))
MemPutStackPtr (ObjHdr->FieldMapDir,  (indextype  )1,
McStat);
BldMapTkn.FieldNum =  FieldNum;
BldMapTkn.LocalObj =  BldObjHdr->LocalObjNum;
FieldMapCount++;
if (Normal(*Status))
if (MemPushSomeBytes
(ObjHdr->FieldMapDir,   sizeof (maptkntype),
(addrtype )&BldMapTkn,
McStat,                       &StackPtr))
if (DeBug || OaBug)
if (sprintf (Msg,
" MapType for FieldNum =%2u LocalObj=%4u; offset@ %3u\n",
BldMapTkn.FieldNum, BldMapTkn.LocalObj, Offset))
TraceMsg (0, Msg);
} else if (! strcmp (EnvAttr->Nam, "Handle")) {
OmPutHandleOffset (Anchor, ObjNum, Offset, McStat);
} else if (!SystemObj
&&  (EnvType->TypeType == aChunk
|| EnvAttr->AttrType == aArrayAttr
|| EnvAttr->AttrType == aDblPtrAttr
|| EnvAttr->AttrType == aVarrayAttr))
{
if (FieldArrayCount == 0)
if (MemMakeChunk   (sizeof(numtype),       Alloc_FieldRefs,
Extend_FieldRefs,      RenvId,
McStat,               &(ObjHdr->FieldArrayDir)))
MemPutStackPtr (ObjHdr->FieldArrayDir, (indextype  )1,
McStat);
if (Normal(*Status))
if (MemPushFieldNum (ObjHdr->FieldArrayDir,   FieldNum,
McStat,                 &StackPtr))
if (DeBug || OaBug)
if (sprintf (Msg, " ArrayType for FieldNum = %2u offset@ %3u\n",
FieldNum, Offset))
TraceMsg (0, Msg);
FieldArrayCount++;
}
if (Normal(*Status))
if (EnvFetchLocalAttrNum (Anchor,             EnvAttr->AttrNum,
McStat,            &LocalAttrNum))
if (!LocalAttrNum
&&  (Anchor->DbId != RenvId))
{
if (MemPushNum        (CoreDb->AttrNumMap,
EnvAttr->AttrNum,
McStat,            &LocalAttrNum))
if (MemPushNum        (CoreDb->LocalAttrSizeTbl,
EnvTypeSize,
McStat,            &LocalAttrNum))
if (MemPutAttrNum     (CoreDb->LocalAttrNumMap,
(indextype  )EnvAttr->AttrNum,
(chunknum )LocalAttrNum,    McStat))
++CoreDb->LocalAttrCount;
}
if (Normal(*Status))
if (MemPushNum           (ObjHdr->LocalAttrNumMap,
LocalAttrNum,
McStat,                &StackPtr))
if (MemPutFieldNum       (ObjHdr->FieldNumMap,    LocalAttrNum,
(chunknum )StackPtr,    McStat))
FieldCount++;
if (DeBug)
if (sprintf (Msg,
" PUSH Attr[%3u](%3u)  %22s  @ OffSet= %4u size %u\n",
EnvAttr->AttrNum, LocalAttrNum,      EnvAttr->Nam,
Offset,           EnvTypeSize))
TraceMsg (0, Msg);
if ((int )EnvTypeSize >= 0)
Offset += EnvTypeSize;
else
Offset += sizeof (strhandle);
}
Vindex++;
}
if (Normal(*Status))
{
EnvAlignStruc( False, False, &Offset );
ObjHdr->ObjSize         = Offset;
ObjHdr->PsudoSize       = Offset;
ObjHdrSize[ObjNum]      = Offset;
ObjHdr->FieldCount      = FieldCount;
ObjHdr->FieldRefCount   = FieldRefCount;
ObjHdr->FieldMapCount   = FieldMapCount;
ObjHdr->FieldArrayCount = FieldArrayCount;
if (DeBug || FileBug)
OaDumpObjHdr (0, Anchor, ObjNum, McStat);
}
TRACK(TrackBak,"InstallObjChunks\n");
return(STAT);
}
boolean EnvBldObjImage    (dbheader     *CoreDb,     objheader    *ObjHdr,
ft F,lt Z,zz *Status,     numtype      *FieldChunk,
numtype      *OffsetChunk,indextype    *FieldCount)
{
objdesctype  *EnvObj         = NullPtr;
indextype     StackPtr       = 0;
tokentype     ObjToken;
tokentype     AttrToken;
attrdesctype *EnvAttr        = NullPtr;
numtype       EnvLocalAttr   = 0;
numtype       LocalAttr      = 0;
tokentype     VfieldToken;
wordtype     *Vchunk;
indextype     Vindex         = 0;
bytessizetype AttrSize       = 0;
bytessizetype FieldOffset    = 0;
ObjToken.DbId     = RenvId;
AttrToken.DbId    = RenvId;
VfieldToken.DbId  = RenvId;
if (sprintf (Msg, " LastEnvAttrCount:: Renv = %4u  DB = %4u\n",
CoreDbs[RenvId]->LastEnvAttrCount, CoreDb->LastEnvAttrCount))
if (TraceMsg (0, Msg))
if (CoreDbs[RenvId]->LastEnvAttrCount >= CoreDb->LastEnvAttrCount)
if (MemPutStackPtr    (CoreDb->LocalAttrNumMap,
1+ CoreDb0->LastEnvAttrCount,
McStat))
CoreDb->LastEnvAttrCount = CoreDb0->LastEnvAttrCount;
if (Normal(*Status))
if (EnvFetchObjHandle (ObjHdr->ObjNum,    McStat,    &ObjToken.Handle))
if (OaGetObject       (&ObjToken, McStat, (addrtype *)&EnvObj))
VfieldToken.Handle = EnvObj->Fields;
if (Normal(*Status))
if (OaGetVchunkStackPtr (&VfieldToken,    McStat,        FieldCount))
if (MemMakeChunk      (sizeof (numtype), (*FieldCount + 1),    10,
CoreDb->DbId,      McStat,        FieldChunk))
if (MemPutStackPtr    (*FieldChunk,       1,             McStat))
if (MemMakeChunk      (sizeof (numtype), (*FieldCount + 1),    10,
CoreDb->DbId,      McStat,        OffsetChunk))
if (MemPutStackPtr    (*OffsetChunk,      1,             McStat))
{
TraceMsg       (0,       " Build Attributes\n");
sprintf (Msg,  "    Base Image ObjNum[%3u] ObjSize=%4u Fields=%2u\n",
EnvObj->ObjNum,  ObjHdrSize[EnvObj->ObjNum], *FieldCount);
TraceMsg (0, Msg);
}
Vindex = 0;
if (Normal(*Status))
if (OaGetVchunkAddr       (&VfieldToken,  McStat,   (addrtype *)&Vchunk))
while (Normal(*Status) && Vindex < *FieldCount)
{
if (EnvFetchAttrHandle (Vchunk[Vindex],
McStat,                  &AttrToken.Handle))
if (OaGetObject        (&AttrToken, McStat,      (addrtype *)&EnvAttr))
if (MemGetAttrNum      (CoreDb0->LocalAttrNumMap, EnvAttr->AttrNum,
McStat,                  &EnvLocalAttr))
if (MemGetSize         (CoreDb0->LocalAttrSizeTbl,EnvLocalAttr,
McStat,                  &AttrSize))
if (MemGetAttrNum      (CoreDb->LocalAttrNumMap,  EnvAttr->AttrNum,
McStat,                  &LocalAttr))
if ( EnvAttr->TypeType == aAddr && AttrSize != 0 )
	 AttrSize = sizeof( addrtype ) ;
if (Normal(*Status))
if (!LocalAttr)
if (MemPushAttrNum     (CoreDb->AttrNumMap,       EnvAttr->AttrNum,
McStat,                  &LocalAttr))
if (MemPushSize        (CoreDb->LocalAttrSizeTbl, AttrSize,
McStat,                  &LocalAttr))
if (MemPutAttrNum      (CoreDb->LocalAttrNumMap,  EnvAttr->AttrNum,
LocalAttr,                McStat))
{
CoreDb->LocalAttrCount = LocalAttr;
}
if (Normal(*Status))
if (MemPushAttrNum     (*FieldChunk,              LocalAttr,
McStat,                  &StackPtr))
MemPushSize        (*OffsetChunk,             FieldOffset,
McStat,                  &StackPtr);
if (EnvAttr->AttrNum == That_AttrNum)
AttrSize  = 0;
FieldOffset += AttrSize;
FieldOffset += (AttrSize % Byte_Alignment);
++Vindex;
}
TRACK(TrackBak,"EnvBldObjImage\n");
return(STAT);
}
boolean    EnvNewObjHdr        (tokentype   *Anchor,   numtype       EnvObjNum,
indextype    AllocQty, ft F,lt Z,zz *Status)
{
objheader *ObjHdr        = NullPtr;
if (Anchor->DbId != RenvId)
*Status = Env_BadDbId;
if (AllocQty)
{
if (OmNewObjHdr (&RenvTkn,  EnvObjNum,  AllocQty, McStat,  &ObjHdr))
{
ObjHdr->ObjSize =  ObjHdrSize[EnvObjNum];
if (DeBug)
if (sprintf (Msg,
"New Obj[%2d] :: Local ObjHdr[%3u] Env0 size %d * alloc(%d)\n",
EnvObjNum,             ObjHdr->LocalObjNum,
ObjHdrSize[EnvObjNum], ObjAllocQty[EnvObjNum]))
TraceMsg (1, Msg);
} else
*Status = Env01_BadDescTypeType;
} else  {
sprintf (Msg, " *** ObjHeader for EnvObj = %u has ZERO AllocQty\n",
EnvObjNum);
TraceMsg (0, Msg);
*Status = Env_Normal;
}
TRACK(TrackBak,"EnvNewObjHdr\n");
return (STAT);
}
boolean    EnvInstallAttr (handletype   AttrHandle,  numtype       EnvAttrNum,
bytessize    Size,        ft F,lt Z,zz *Status)
{
indextype    LocalAttrNum = 0;
if (MemPushSize   (CoreDb0->LocalAttrSizeTbl,  Size,
McStat,                    &LocalAttrNum))
if (MemPushObjNum (CoreDb0->AttrNumMap,        EnvAttrNum,
McStat,                    &LocalAttrNum))
if (MemPutHandle  (CoreDb0->AttrHandleDir,     (indextype )EnvAttrNum,
AttrHandle,                 McStat))
if (MemPutObjNum  (CoreDb0->LocalAttrNumMap,   (indextype )EnvAttrNum,
(num )LocalAttrNum,         McStat))
{
CoreDb0->LocalAttrCount = CoreDb0->LastEnvAttrCount = LocalAttrNum;
if (CoreDbs[PrimalId])
if (MemPutObjNum  (CoreDbs[PrimalId]->LocalAttrNumMap,
(indextype )EnvAttrNum,    0,         McStat))
CoreDbs[PrimalId]->LocalAttrCount = CoreDb0->LastEnvAttrCount;
}
TRACK(TrackBak,"EnvInstallAttr\n");
return (STAT);
}
boolean    EnvFetchLocalAttrNum (
tokentype    *Anchor,  numtype   EnvAttrNum,
ft F,lt Z,zz *Status,  numtype  *LocalAttrNum)
{
statustype  ShellStatus  = Env_Normal;
dbheader   *CoreDb       = NullPtr;
if (TmFetchCoreDb (Anchor, McStat, &CoreDb))
if (EnvAttrNum     <=  CoreDb->LastEnvAttrCount)
{
MemGetObjNum     (CoreDb->LocalAttrNumMap,  (indextype )EnvAttrNum,
McStat,                    LocalAttrNum);
} else {
MemPutStackPtr   (CoreDb->LocalAttrNumMap,
1+ CoreDb0->LastEnvAttrCount,      McStat);
CoreDb->LastEnvAttrCount = CoreDb0->LastEnvAttrCount;
*LocalAttrNum  = 0;
}
if (!Normal(*Status))
if (CoreDb != NullPtr)
HmDumpDbHdr  (0, Anchor, ShellMcStat);
TRACK(TrackBak,"EnvFetchLocalAttrNum\n");
return (STAT);
}
boolean    EnvFetchAttrHandle (numtype       AttrNum,
ft F,lt Z,zz *Status,  handletype *AttrHandle)
{
MemGetHandle (CoreDb0->AttrHandleDir, AttrNum,  McStat, AttrHandle);
TRACK(TrackBak,"EnvFetchAttrHandle\n");
return (STAT);
}
boolean    EnvFetchAttrSize   (numtype       AttrNum,
ft F,lt Z,zz *Status,  sizetype  *AttrSize)
{
MemGetWord   (CoreDb0->LocalAttrSizeTbl,              AttrNum,
McStat,                     (wordtype *)AttrSize);
TRACK(TrackBak,"EnvFetchAttrSize\n");
return (STAT);
}
boolean    CppEnvGetThatTkn (addrtype      CppObject, numtype      ObjNum,
ft F,lt Z,zz *Status,    tokentype  **CppToken)
{
handletype    ObjDescHndl = NullHandle;
objdesctype  *ObjDesc     = NullPtr;
tokentype     ObjDescTkn;
tokentype     VfieldsTkn;
tokentype     VoffsetsTkn;
indextype     Vindex      = 0;
booleantype   AttrFound   = False;
indextype     FieldCount  = 0;
numtype      *Vfields     = NullPtr;
typesize     *Voffsets    = NullPtr;
numtype       AttrNum     = Handle_AttrNum;
typesize      Offset      = 0;
SendMsg (0, " *** ERROR *** CppEnvGetThatTkn **************\n");
SendMsg (0, "              SHOULD BE INVOKED\n");
if (MemGetHandle    (CoreDb0->ObjHandleDir,               ObjNum,
McStat,                             &ObjDescHndl))
{
ObjDescTkn.DbId   = RenvId;
ObjDescTkn.Handle = ObjDescHndl;
OaGetObject     (&ObjDescTkn,    McStat, (addrtype *)&ObjDesc);
}
if (Normal(*Status))
{
VoffsetsTkn.DbId    =  RenvId;
VoffsetsTkn.Handle  =  ObjDesc->ClassOffsets;
VfieldsTkn.DbId     =  RenvId;
VfieldsTkn.Handle   =  ObjDesc->Fields;
if (Normal(*Status))
if (OaGetVchunkAddr (&VoffsetsTkn,   McStat,  (addrtype *)&Voffsets))
if (OaGetVchunkAddr (&VfieldsTkn,    McStat,  (addrtype *)&Vfields))
if (OaGetVchunkStackPtr
(&VfieldsTkn,    McStat,  &FieldCount))
while (Vindex < FieldCount
&&    !AttrFound)
{
if (Vfields[Vindex] == AttrNum)
{
Offset    = Voffsets[Vindex];
AttrFound = True;
}
Vindex++;
}
}
if (AttrFound)
{
*CppToken = (tokentype*)((char *)CppObject + (indextype )Offset);
if (DeBug >= 0)
if (sprintf (Msg, "  CppEnvGetThatTkn:: [%2u:%4u] @%x\n",
(*CppToken)->DbId, (*CppToken)->Handle, *CppToken))
TraceMsg (0, Msg);
} else
*Status   = Err_BadDesign;
TRACK(TrackBak,"CppEnvGetThatTkn\n");
return (STAT);
}
boolean    EnvFetchAttrOffset (tokentype    *ObjTkn,  numtype    AttrNum,
objheader    *ObjHdr,  numtype    FieldNum,
ft F,lt Z,zz *Status,  sizetype  *Offset)
{
numtype       MemLoc      = 0;
tokentype     VfieldsTkn;
tokentype     VoffsetsTkn;
booleantype   AttrFound   = False;
numtype       ObjNum      = 0;
sizetype      DbOffset    = 0;
dbheader   *CoreDb  = NullPtr;
if (TmFetchCoreDb      (ObjTkn,  McStat,  &CoreDb))
if (HmGetObjectMemLoc  (CoreDb,                         ObjTkn->Handle,
McStat,                        &MemLoc))
if (Normal(*Status))
if (MemLoc)
{
if (HmGetObjNum      (CoreDb,                        ObjTkn->Handle,
McStat,                       &ObjNum))
if (Trans_FetchAttrOffset
(ObjNum,             Cpp_Apl,   FieldNum,
McStat,             Offset))
AttrFound = True;
} else {
MemGetSize    (ObjHdr->FieldOffsetDir,    (indextype )FieldNum,
McStat,                                Offset);
AttrFound    = True;
}
if (!AttrFound)
*Status = Env_AttrNotInDbmsClassDef;
TRACK(TrackBak,"EnvFetchAttrOffset\n");
return (STAT);
}
boolean    Env_FetchObj0AttrOffset
(numtype       MemLoc,  numtype    AttrNum,
objheader    *ObjHdr,
ft F,lt Z,zz *Status,  sizetype  *Offset)
{
numtype      *Vfields         = NullPtr;
booleantype   Found           = False;
booleantype   AttrFound       = False;
indextype     Vindex          = 0;
numtype       NumFields       = 0;
if (MemLoc)
{
if (Env_FetchObjAttrOffset
(MemLoc,  ObjHdr->ObjNum,    AttrNum,
McStat,                     Offset))
AttrFound = True;
} else {
Vindex            = 0;
NumFields         = ObjHdr->FieldCount;
if (MemGetChunkAddr  (ObjHdr->FieldNumMap,  McStat, (addrtype *)&Vfields))
if (NumFields)
while (Normal(*Status)
&&     NumFields--     > 0
&&     Found          == False)
{
if (Vfields[Vindex]  == AttrNum)
{
Found  = True;
} else
++Vindex;
}
if (Found)
if (MemGetSize       (ObjHdr->FieldOffsetDir,   (indextype )Vindex,
McStat,                               Offset))
AttrFound    = True;
}
if (!AttrFound)
*Status = Env_AttrNotInDbmsClassDef;
TRACK(TrackBak,"Env_FetchObj0AttrOffset\n");
return (STAT);
}
boolean Env_FetchObjAttrOffset
(numtype       MemLoc,
numtype       ObjNum,    numtype       AttrNum,
ft F,lt Z,zz *Status,    sizetype     *Offset)
{
tokentype     ObjDescTkn      = NullToken;
objdesctype  *EnvObj          = NullPtr;
tokentype     VoffsetsTkn;
tokentype     VfieldToken;
typeunsize   *Voffsets        = NullPtr;
numtype      *Vfields         = NullPtr;
indextype     Vindex          = 0;
numtype       NumFields       = 0;
boolean       Found           = False;
numtype       LocalObjNum     = 0;
VfieldToken.DbId  = RenvId;
VoffsetsTkn.DbId  = RenvId;
ObjDescTkn.DbId   = RenvId;
if (MemGetHandle    (CoreDb0->ObjHandleDir,    ObjNum,
McStat,                  &ObjDescTkn.Handle))
if (OaGetObject     (&ObjDescTkn,    McStat, (addrtype *)&EnvObj))
{
VfieldToken.Handle   = EnvObj->Fields;
VoffsetsTkn.Handle   = EnvObj->ClassOffsets;
}
if (Normal(*Status))
if (OaGetVchunkAddr     (&VfieldToken,  McStat, (addrtype *)&Vfields))
if (OaGetVchunkAddr     (&VoffsetsTkn,  McStat, (addrtype *)&Voffsets))
OaGetVchunkStackPtr (&VfieldToken,  McStat,             &NumFields);
Vindex         = 0;
if (NumFields)
while (Normal(*Status)
&&     NumFields--     > 0
&&     Found          == False)
{
if (Vfields[Vindex]  == AttrNum)
{
*Offset     = Voffsets[Vindex];
Found  = True;
} else
++Vindex;
}
if (!Found)
{
sprintf (Msg,
" Env_FetchObjAttrOffset:: AttrNum =%4u; NotFound in Class=%4u\n",
AttrNum, ObjNum);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"Env_FetchObjAttrOffset\n");
return (STAT);
}
boolean Env_FetchObjAttrSpec
(numtype       ObjNum,    numtype       AttrNum,
ft F,lt Z,zz *Status,    attrtype     *AttrType,
numtype      *RefObjNum, envclass     *RefEnvType,
sizetype     *UnitSize,  typetype     *UnitType,
valueclass   *ValueType, sizetype     *Offset)
{
tokentype     ObjDescTkn      = NullToken;
objdesctype  *EnvObj          = NullPtr;
tokentype     AttrDescTkn     = NullToken;
attrdesctype *EnvAttr         = NullPtr;
tokentype     BldDescTkn      = NullToken;
objdesctype  *BldDesc         = NullPtr;
tokentype     VoffsetsTkn;
tokentype     VfieldToken;
typeunsize   *Voffsets        = NullPtr;
numtype      *Vfields         = NullPtr;
indextype     Vindex          = 0;
numtype       NumFields       = 0;
boolean       Found           = False;
VfieldToken.DbId  = RenvId;
VoffsetsTkn.DbId  = RenvId;
ObjDescTkn.DbId   = RenvId;
AttrDescTkn.DbId  = RenvId;
BldDescTkn.DbId   = RenvId;
if (MemGetHandle    (CoreDb0->ObjHandleDir,    ObjNum,
McStat,                  &ObjDescTkn.Handle))
if (OaGetObject     (&ObjDescTkn,    McStat, (addrtype *)&EnvObj))
{
VfieldToken.Handle   = EnvObj->Fields;
VoffsetsTkn.Handle   = EnvObj->ClassOffsets;
}
if (Normal(*Status))
if (OaGetVchunkAddr     (&VfieldToken,  McStat, (addrtype *)&Vfields))
if (OaGetVchunkAddr     (&VoffsetsTkn,  McStat, (addrtype *)&Voffsets))
OaGetVchunkStackPtr (&VfieldToken,  McStat,             &NumFields);
Vindex         = 0;
if (NumFields)
while (Normal(*Status)
&&     NumFields--     > 0
&&     Found          == False)
{
if (Vfields[Vindex]  == AttrNum)
{
if (EnvFetchAttrHandle (AttrNum,      McStat, &AttrDescTkn.Handle))
if (OaGetObject        (&AttrDescTkn, McStat, (addrtype *)&EnvAttr))
{
*AttrType   = EnvAttr->AttrType;
*RefObjNum  = 0;
*UnitSize   = EnvAttr->UnitSize;
*UnitType   = EnvAttr->TypeType;
*Offset     = Voffsets[Vindex];
*RefEnvType = aEnvValue;
Found  = True;
if ((BldDescTkn.Handle = EnvAttr->BuildDesc) > 0)
{
if (OaGetObject (&BldDescTkn,   McStat, (addrtype *)&BldDesc))
*RefObjNum   = BldDesc->ObjNum;
*RefEnvType     = aEnvObj;
} else {
if (EnvAttr->AttrType == aArrayAttr
||  EnvAttr->AttrType == aVarrayAttr
||  EnvAttr->AttrType == aChunkAttr
||  EnvAttr->AttrType == aDblPtrAttr)
{
*RefObjNum   = EnvAttr->TypeObj;
*RefEnvType  = aEnvType;
}
}
}
} else
++Vindex;
}
if (!Found)
{
sprintf (Msg,
" Env_FetchObjAttrSpec:: AttrNum =%4u; NotFound in Class=%4u\n",
AttrNum, ObjNum);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"Env_FetchObjAttrSpec\n");
return (STAT);
}
boolean    Env_FetchFieldOffset
(tokentype    *ObjTkn,      fieldspec     FieldTkns[],
numtype       SubLevel,
ft F,lt Z,zz *Status,      sizetype     *FieldSize,
			 sizetype     *Offset)
{
numtype       MemLoc      = 0;
booleantype   AttrFound   = False;
numtype       ObjNum      = 0;
sizetype      DbOffset    = 0;
numtype       AttrId      = 0;
attrtype      AttrType    = aNonTypeAttr;
numtype       RefObjNum   = 0;
typetype      FieldType   = aNonTypeType;
sizetype      BaseOffset  = 0;
dbheader   *CoreDb  = NullPtr;
tokentype     BldDescTkn  = NullToken;
objdesctype  *BuildDesc   = NullPtr;
sizetype      DbBase      = 0;
sizetype      CppBase     = 0;
BldDescTkn.DbId       = RenvId;
if (TmFetchCoreDb      (ObjTkn,  McStat,  &CoreDb))
if (HmGetObjectMemLoc  (CoreDb,                         ObjTkn->Handle,
McStat,                        &MemLoc))
if (Normal(*Status))
if (MemLoc)
{
if (Trans_FetchFieldOffset
(ObjTkn,         Cpp_Apl,
FieldTkns,      SubLevel,
	                   McStat,         FieldSize,    &AttrId,
&AttrType,      &RefObjNum,    &FieldType,
&DbOffset,       Offset,
&DbBase,        &CppBase))
{
AttrFound = True;
if (RefObjNum)
if (EnvFetchObjHandle (RefObjNum,  McStat,  &BldDescTkn.Handle))
if (OaGetObject       (&BldDescTkn,
McStat,    (addrtype *)&BuildDesc))
{
*FieldSize   = BuildDesc->ObjSize;
*Offset     += (*FieldSize * FieldTkns[SubLevel-1].Index);
}
}
} else {
if (HmGetObjNum      (CoreDb,                        ObjTkn->Handle,
McStat,                       &ObjNum))
if (Env_FetchObjFieldSpec
(ObjNum,         FieldTkns,     SubLevel,
McStat,         FieldSize,    &AttrId,
&AttrType,      &RefObjNum,    &FieldType,
Offset,        &BaseOffset))
AttrFound    = True;
}
if (!AttrFound)
*Status = Env_AttrNotInDbmsClassDef;
TRACK(TrackBak,"EnvFetchFieldOffset\n");
return (STAT);
}
boolean    Env_FetchObjFieldSpec
(numtype       ObjNum,      fieldspec     FieldTkns[],
numtype       SubLevel,
ft F,lt Z,zz *Status,      sizetype     *FieldSize,
numtype      *AttrId,      attrtype     *AttrType,
numtype      *RefObjNum,   typetype     *FieldType,
sizetype     *Offset,      sizetype     *BaseOffset)
{
numtype       Level       = 0;
handletype    ObjDescHndl = NullHandle;
tokentype     ObjDescTkn;
objdesctype  *ObjDesc     = NullPtr;
tokentype     VfieldsTkn;
numtype      *Vfields     = NullPtr;
tokentype     VoffsetsTkn;
typeunsize   *Voffsets    = NullPtr;
indextype     Vindex      = 0;
indextype     FieldCount  = 0;
booleantype   AttrFound   = False;
tokentype     AttrToken   = NullToken;
attrdesctype *AttrDesc    = NullPtr;
int           i           = 0;
tokentype     BldDescTkn  = NullToken;
objdesctype  *BuildDesc   = NullPtr;
BldDescTkn.DbId    = RenvId;
AttrToken.DbId     = RenvId;
ObjDescTkn.DbId    = RenvId;
*FieldSize          = 0;
*AttrId             = 0;
*AttrType           = aAttr;
*RefObjNum          = 0;
*FieldType          = aString;
*Offset             = 0;
*BaseOffset         = 0;
Level     = 0;
while (Normal(*Status)
&&     Level < SubLevel)
{
if (MemGetHandle    (CoreDb0->ObjHandleDir,            ObjNum,
McStat,                          &ObjDescHndl))
if (HmGetObjectAddr (CoreDb0,                          ObjDescHndl,
McStat,              (addrtype *)&ObjDesc))
if (!ObjDesc)
{
ObjDescTkn.Handle = ObjDescHndl;
OaGetObject     (&ObjDescTkn,    McStat, (addrtype *)&ObjDesc);
}
if (Normal(*Status))
{
AttrFound           = False;
VoffsetsTkn.DbId    = RenvId;
VoffsetsTkn.Handle  = ObjDesc->ClassOffsets;
VfieldsTkn.DbId     = RenvId;
VfieldsTkn.Handle   = ObjDesc->Fields;
Vindex              = 0;
}
if (Normal(*Status))
if (OaGetVchunkAddr (&VoffsetsTkn,   McStat,  (addrtype *)&Voffsets))
if (OaGetVchunkAddr (&VfieldsTkn,    McStat,  (addrtype *)&Vfields))
if (OaGetVchunkStackPtr
(&VfieldsTkn,    McStat,              &FieldCount))
while (Normal(*Status)
&&     Vindex < FieldCount
&&    !AttrFound)
{
if (Vfields[Vindex] == FieldTkns[Level].AttrId)
{
if (Voffsets[Vindex] < 0)
*Status         = Env_AttrNotInAplClassDef;
else {
AttrFound      = True;
*Offset        += Voffsets[Vindex];
}
} else
++Vindex;
}
if (AttrFound          == False)
*Status = Env_AttrNotInDbmsClassDef;
if (Level              == 0)
*BaseOffset          = *Offset;
else
*Offset     += (ObjDesc->ObjSize * FieldTkns[Level-1].Index);
if (Normal(*Status))
{
if (EnvFetchAttrHandle
(FieldTkns[Level].AttrId,
McStat,                  &AttrToken.Handle))
if (OaGetObject   (&AttrToken,   McStat,   (addrtype *)&AttrDesc))
{
*FieldSize         = AttrDesc->UnitSize;
*AttrId            = AttrDesc->AttrNum;
*AttrType          = AttrDesc->AttrType;
*FieldType         = AttrDesc->TypeType;
if ((BldDescTkn.Handle = AttrDesc->BuildDesc) > 0)
if (OaGetObject    (&BldDescTkn,
McStat,             (addrtype *)&BuildDesc))
*RefObjNum      = BuildDesc->ObjNum;
}
++Level;
if (Normal(*Status))
if (Level               < SubLevel)
if (AttrDesc->AttrType != aMapRefAttr)
{
sprintf  (Msg,
"*** ERRor...@ Level =%4u; AttrId=%4u Not a Nested Object\n",
Level, FieldTkns[Level].AttrId);
TraceMsg (0, Msg);
*Status      = Env_AttrNotInDbmsClassDef;
} else {
ObjNum      = *RefObjNum;
}
if (Normal(*Status))
if (Level              == SubLevel)
if (*RefObjNum)
{
*FieldSize   = BuildDesc->ObjSize;
*Offset     += (*FieldSize * FieldTkns[Level-1].Index);
}
}
}
if (!Normal(*Status))
{
sprintf  (Msg, " Env_FetchObjFieldSpec:: ObjNum=%4u\n",
ObjNum);
TraceMsg (0, Msg);
for (i=0; i < SubLevel; i++)
{
sprintf  (Msg, " Field %4u. AttrId=%4u; Index=%4u.\n",
i, FieldTkns[i].AttrId,  FieldTkns[i].Index);
TraceMsg (0, Msg);
}
sprintf  (Msg,"         @ Level =%4u; AttrId=%4u, Index=%4u\n",
Level, FieldTkns[Level].AttrId, FieldTkns[Level].Index);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"Env_FetchObjFieldSpec\n");
return (STAT);
}
boolean    EnvFetchOffsetMap  (tokentype    *ObjTkn,    objheader *ObjHdr,
ft F,lt Z,zz *Status,    typesize  *MapSize,
numtype      *OffsetMap, indextype *Inset)
{
handletype    ObjDescHndl = NullHandle;
objdesctype  *ObjDesc     = NullPtr;
tokentype     ObjDescTkn;
indextype     Index       = 0;
numtype       ShellType   = 0;
tokentype     VoffsetsTkn;
vchunktkntype VchunkTkn;
indextype     FieldCount  = 0;
typesize     *Voffsets    = NullPtr;
dbheader   *CoreDb  = NullPtr;
VoffsetsTkn.DbId    =  RenvId;
ObjDescTkn.DbId     =  RenvId;
if (TmFetchCoreDb   (ObjTkn,  McStat,  &CoreDb))
if (HmGetObjectMemLoc
(CoreDb,                              ObjTkn->Handle,
McStat,                             &ShellType))
if (MemGetHandle    (CoreDb0->ObjHandleDir,               ObjHdr->ObjNum,
McStat,                             &ObjDescHndl))
{
ObjDescTkn.Handle  = ObjDescHndl;
OmGetObject      (&ObjDescTkn,
McStat,       &Index,   (addrtype *)&ObjDesc);
}
if (Normal(*Status))
if (ObjDesc->ClassOffsets
&&  Global_Apl == Cpp_Apl)
{
*Inset      = 0;
VoffsetsTkn.Handle  =  ObjDesc->ClassOffsets;
if (DbmGetVchunkTkn  (&VoffsetsTkn,     McStat,            &VchunkTkn))
if (MemGetChunkAddr  (VchunkTkn.InCore, McStat,(addrtype *)&Voffsets))
if (MemGetStackPtr   (VchunkTkn.InCore, McStat,            &FieldCount))
{
*MapSize    =  Voffsets[FieldCount-1];
*OffsetMap  =  VchunkTkn.InCore;
}
} else {
*Inset      = 1;
*MapSize    =  ObjDesc->ObjSize;
*OffsetMap  =  ObjHdr->FieldOffsetDir;
}
TRACK(TrackBak,"EnvFetchOffsetMap\n");
return (STAT);
}
boolean    EnvInitCodes (ft F,lt Z,zz *Status )
{
tokentype      ArgObjDescTkn;
numtype        ArgDescObjNum       = 0;
tokentype      CodeArgsSetDescTkn;
if (!CodeArgs_Hndl)
if (sprintf (Msg, " size of codedesc      :: %3u\n",
sizeof(codedesctype)))
if (SendMsg (0, Msg))
if (KernelFindIn  (RenvDescs_Hndl, &RenvTkn,       "ArgDesc",
McStat,         &ArgObjDescTkn))
if (KernelGetAttr (&ArgObjDescTkn,  ObjNum_AttrNum,
McStat,         &ArgDescObjNum))
if (KernelFindIn  (RenvDescs_Hndl, &RenvTkn,       "CodeArgs",
McStat,         &CodeArgsSetDescTkn))
{
if (ArgDesc_Hndl != ArgObjDescTkn.Handle)
*Status = Env0_Corrupted;
CodeArgs_Hndl = CodeArgsSetDescTkn.Handle;
SendMsg        (0, " CODES  loaded ...\n");
} else {
TraceMsg (0, "CodeDesc :: not a Descriptor in Renv\n" );
*Status = Code_NotAnObjDesc;
}
TRACK(TrackBak,"EnvInitCodes\n");
return(STAT);
}
boolean    EnvMakeCodeChunks  (ft F,lt Z,zz *Status)
{
if (MemMakeChunk (sizeof (funcptrtype),   Env0->CodeCount+1,
Extend_Codes,
RenvId,                 McStat,       &CodeDirChunk))
MemPutStackPtr
(CodeDirChunk,           Env0->CodeCount,   McStat);
TRACK(TrackBak,"EnvMakeCodeChunks\n");
return (STAT);
}
boolean    EnvPairCode        (numtype       CodeNum, funcptrtype  CodeAddr,
ft F,lt Z,zz *Status)
{
MemPutFuncPtr (CodeDirChunk,  CodeNum,  CodeAddr,  McStat);
TRACK(TrackBak,"EnvPairCode\n");
return (STAT);
}
boolean    EnvFetchCode       (numtype       CodeNum,
ft F,lt Z,zz *Status,  funcptrtype *CodeAddr)
{
MemGetFuncPtr (CodeDirChunk, CodeNum,  McStat,  CodeAddr);
TRACK(TrackBak,"EnvFetchCode\n");
return (STAT);
}
void    EnvAlignMember    (attrtype      Attr_Type, typetype      Type_Type,
sizetype      Size,      sizetype     *Offset)
{
sizetype  ByteAlign  = 0;
sizetype  Align      = 0;
if (DeBug || ClassBug)
if (sprintf (Msg,  "    Type<%12s> Size(%3u)     @%4u",
TypeTypeNam[Type_Type], Size, *Offset))
TraceMsg (0, Msg);
if (*Offset)
{
switch (Attr_Type)
{
case  aObjRefAttr :
if ((Align = sizeof (tokentype)) > sizeof (addrtype))
{
ByteAlign = Byte4Alignment;
} else
ByteAlign = Byte4Alignment;
break;
case  aArrayAttr  :
case  aDblPtrAttr :
case  aMapRefAttr :
case  aVarrayAttr :
case  aChunkAttr  :
case  aVchunkAttr :
ByteAlign = Byte4Alignment;
break;
default           :
switch (Type_Type)
{
case aString    :
ByteAlign = Byte_Alignment;
break;
case aLink      :
#ifdef LARGE
ByteAlign = Byte4Alignment;
#else
ByteAlign = Byte2Alignment;
#endif
break;
case aInteger   :
if (Size == 1)
{
ByteAlign = Byte_Alignment;
} else if (Size == 2) {
ByteAlign = Byte2Alignment;
} else if (Size == 4) {
ByteAlign = Byte4Alignment;
} else {
ByteAlign = Byte4Alignment;
}
break;
case aReal       :
if (Size == sizeof (float))
ByteAlign = Byte4Alignment;
else if (Size == sizeof (double))
ByteAlign = Byte8Alignment;
break;
case aEnum        :
case aBoolean     :
ByteAlign = Byte4Alignment;
break;
case aChunk       :
ByteAlign = Byte2Alignment;
break;
case aAddr        :
ByteAlign = BytePtrAlignment;
break;
case aRefObj      :
case aDbmsString  :
case aValue       :
ByteAlign = Byte4Alignment;
break;
}
break;
}
Align       = *Offset   %  ByteAlign;
if (Align)
Align  = ByteAlign - (*Offset %  ByteAlign);
*Offset     +=  Align;
}
if (DeBug || ClassBug)
if (sprintf (Msg, "  for ByteAlign_%u;  Align=%4u\n",
ByteAlign, Align))
if (TraceMsg (0, Msg))
if (sprintf (Msg,  "                     Adjusted  Offset=%4u\n",
*Offset))
TraceMsg (0, Msg);
return;
}
void    EnvAlignStruc     (boolean       DblAlign, boolean       AddrAlign,
sizetype     *Offset)
{
#ifdef STRUC_ALIGN_BY64
sizetype      Struc_Alignment  = Byte4Alignment;
#else
sizetype      Struc_Alignment  = Byte4Alignment;
#endif
sizetype  ByteAlign = 0;
if (DblAlign)
{
ByteAlign  = *Offset %  Byte8Alignment;
if (ByteAlign)
ByteAlign  = Byte8Alignment - ByteAlign;
} else if (AddrAlign) {
ByteAlign  = *Offset %  BytePtrAlignment;
if (ByteAlign)
ByteAlign  = BytePtrAlignment - ByteAlign;
} else {
ByteAlign  = *Offset %  Struc_Alignment;
if (ByteAlign)
ByteAlign  = Struc_Alignment - ByteAlign;
}
*Offset    +=  ByteAlign;
if (DeBug || ClassBug)
if (sprintf (Msg, "  StrucAlignment = %2u\n", ByteAlign))
TraceMsg (0, Msg);
return;
}
boolean    TestEnv0      (ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"TestEnv0\n");
return(STAT);
}
numtype     ObjCount        = 0;
boolean    CreateObjDesc (tokentype    *Anchor,  ft F,lt Z,zz *Status,
objdesctype **ObjDesc, tokentype    *Token)
{
numtype    ObjNum   = 0;
indextype  StackPtr = 0;
indextype  ObjIndex = 0;
time_t     Tod      = 0;
time (&Tod);
if (OaCreateObject   (Anchor,  ObjDesc_Class,  McStat,    Token))
if (OaGetObject      (Token,   McStat,        (addrtype *)ObjDesc))
if (ObjCount)
{
if (MemPushObjNum    (CoreDb0->ObjNumMap,   ObjNum,  McStat, &StackPtr))
MemPushObjHdr    (CoreDb0->ObjHdrDir,   NullPtr, McStat, &StackPtr);
} else {
MemGetStackPtr      (CoreDb0->ObjNumMap,            McStat, &StackPtr);
StackPtr--;
}
if (Normal(*Status))
if (++Env0->ObjCount
&& StackPtr        == ++ObjCount)
{
ObjIndex = ObjNum = (*ObjDesc)->ObjNum  = ObjCount;
if (MemPutLocalObjNum (CoreDb0->LocalObjNumMap, ObjIndex, ObjNum,
McStat))
MemPutLong        (CoreDb0->ObjTimeStampDir,   ObjIndex,
(longwordtype )Tod,         McStat);
if (DeBug)
if (sprintf (Msg, " Obj Class (%2d) @%x\n", (*ObjDesc)->ObjNum, *ObjDesc))
TraceMsg (1, Msg);
} else
*Status = Env01_BadObjNumMap;
TRACK(TrackBak,"CreateObjDesc\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\fm.c*/

#define FM
/* 当前文件是./CINT2000\255.vortex\src\blk.h*/

#ifndef BLK1_H
#define BLK1_H

#endif
#ifdef NULL_TRACE_STRS
#define TraceStr1(StrNum)  TraceStr1[0]
static const char   *TraceStr1[1] = {"   ...FM... message\n" };
#else
#define TraceStr1(StrNum)  TraceStr1[StrNum]
static const char *TraceStr1[46] =
{
"     FilePutSomeBytes  =%6u\n",
"    PUT to   File @ Offset= %lu",
", size(%u) =",
"  %u\n" ,
"  %u\n" ,
"  %x\n",
"  \n",
"     FileGetSomeBytes  =%8u\n",
"     SEEK To Offset    =%8ld\n",
"***FileGetSomeBytes... SeekStatus= %u\n",
"***FileGetSomeBytes... CheckCount= %u\n",
"     Get bytes from File @ Offset= %lu",
", Value(*%4u) =",
"  %u\n" ,
"  %u\n" ,
"  %x\n" ,
"  \n",
"    FileOutBLock... Size=%6u\n",
"     Seek To Offset= %lu\n" ,
"    Write To FileBlk Offset= %8lu; From @%x\n",
"\n  FileOutChunk ... Block[%3u] Not Loaded.\n" ,
"    FileOutChunk    =%6u; @ %x\n" ,
" *** ERROR ... @FileOutChunk count=%2u, size=%3u\n",
"            As  Vbn =%6u\n" ,
"\n      Expand VbnBlk =%6u... Size=%4u Units=%4u; StackPtr=%u\n",
"           From... %8u --> %8u\n",
"   ***Chunk[%4u]... ChangeIn Unit Size... %4u --> %4u\n",
"      UnitSize= %3u, Count=%4u, StackPtr=%4u;\n",
"    At file Offset= %8lu\n",
"    At File Offset= %8lu (* %3u)\n",
" *** ERROR... BadDiskWrite for Count=%u\n",
"    FileOutChunk    =%6u; to Vbn[%4u]\n",
"    FileInBlk...    Vbn =%6u;  Size  = %6u\n" ,
"    New Region for Blk. @%6u\n",
"    From       BlkIndex =%6u;  Offset= %8u \n",
" *** ZERO File Offset for Vbn = %6u; BlkIndex= %6u;\n",
"    Seek To Offset  =%8lu\n" ,
"    Read InTo Core  @%8x\n",
"  FILE read ERROR #  Vbn[%3u]\n",
"    Load VbnBlk[%4u]\n" ,
"    ReadInto Chunk[%6u] Unit Count=%6u, Size=%4u Stack=%6u\n",
" ***ERROR... FileInChunk. Size %4u != BlkSize %4u\n",
"    FILE IN From Blk[%3u] ZERO Chunk[%4u](%2u * %2u)\n",
"    ZERO BLOCK [%3u] ZERO Chunk[%4u](%2u * %2u)\n",
" File <%s>:  can't open  file\n",
" File <%s>   Opened For COMMIT::\n"
};
#endif
#define MemGetVbn              Mem_GetWord
#define MemPutVbn              Mem_PutWord
#define MemGetChunkNum         Mem_GetWord
#define MemPutChunkNum         Mem_PutWord
#define MemPutIndex            Mem_PutWord
#define MemGetIndex            Mem_GetWord
#define MemPopIndex            Mem_PopWord
#define MemPushIndex           Mem_PushWord
static idtype   DbmDbId             = 0;
#ifdef USE_BLK
#define MemFreeFileBlk         BlkFreeFileBlk
#else
#define MemFreeFileBlk     Mem_FreeFileBlk

#endif
boolean FileGetSomeBytes (blkhdrtype   *BlkHdr,     farlongtype  FileOffset,
unsigned      SomeBytes,
ft F,lt Z,zz *Status,     addrtype     BytesAddr)
{
size_t  CheckCount  = 0;
int     SeekStatus  = 0;
SeekStatus = fseek (BlkHdr->BlkFile, FileOffset, SEEK_SET);
if (SeekStatus != 0)
{
sprintf  (Msg, TraceStr1(9),
SeekStatus);
TraceMsg  (0,   Msg);
*Status = File_BadDiskWrite;
}
CheckCount = fread (BytesAddr,       SomeBytes,  (size_t )1,
BlkHdr->BlkFile);
if (CheckCount != (int )1)
{
sprintf  (Msg, TraceStr1(10),
CheckCount);
TraceMsg  (0,   Msg);
*Status = File_BadDiskWrite;
}
if (SomeBytes == 0)
*Status = Err_NoBytesMoved;
TRACK(TrackBak,"FileGetSomeBytes\n");
return(STAT);
}
boolean FileInBlk       (addrtype     *BlkAddr, bytessize  BlkSize,
blkhdrtype   *BlkHdr,  boolean    Release,
ft F,lt Z,zz *Status,  vbntype   *VbnBlk)
{
bytessize   UnitSize     = BlkSize;
indextype   UnitCount    = (indextype )1;
lt64        FileOffset   = 0;
indextype   VbnBlkIndex  = 0;
blktkntype  BlkTkn;
int         FileRead     = 0;
if (*BlkAddr      == NullPtr)
CoreMoreCore    (BlkSize,              McStat,    BlkAddr);
if (Normal(*Status))
if (MemGetIndex     (BlkHdr->BlkDirChunk, *VbnBlk,
McStat,              &VbnBlkIndex))
MemGetSomeBytes (BlkHdr->BlkTknChunk,  VbnBlkIndex,
sizeof (blktkntype),
McStat,   (addrtype )&BlkTkn);
if (Normal(*Status))
{
FileOffset    = BlkTkn.Offset;
if (FileOffset <= 0)
{
sprintf (Msg, TraceStr1(35),
*VbnBlk, VbnBlkIndex);
TraceMsg (0, Msg);
}
}
if (Normal(*Status))
{
fseek            (BlkHdr->BlkFile,     FileOffset,     SEEK_SET);
FileRead = fread (*BlkAddr,                 (unsigned )UnitSize,
(unsigned )UnitCount,                BlkHdr->BlkFile);
if (FileRead != (int )UnitCount)
{
sprintf (Msg, TraceStr1(38),
*VbnBlk);
TraceMsg (0, Msg);
perror("    Error Msg ");
*Status = File_BadDiskRead;
}
LastFileOffset = FileOffset + UnitCount;
}
if (Normal(*Status))
if (Release)
MemFreeFileBlk   (BlkHdr,     McStat,   VbnBlk);
TRACK(TrackBak,"FileInBlk\n");
return(STAT);
}
boolean FileInChunk     (numtype      *Chunk,    blkhdrtype *BlkHdr,
boolean       Release,
ft F,lt Z,zz *Status,   vbntype    *VbnBlk)
{
addrtype    ChunkAddr    = NullPtr;
bytessize   UnitSize     = 0;
indextype   UnitCount    = 0;
sizetype    ChunkSize    = 0;
sizetype    BlkSize      = 0;
chunkstruc  ChunkRef;
chunkstruc *ChunkRefPtr  = &ChunkRef;
addrtype    ChunkBlk     = NullPtr;
indextype   BlkIndex     = 0;
if (MemGetIndex       (BlkHdr->BlkDirChunk,        *VbnBlk,
McStat,                     &BlkIndex))
if (MemGetWord        (BlkHdr->BlkSizeChunk,        BlkIndex,
McStat,                     &BlkSize))
if (!*Chunk)
MemNewChunkBlk    (BlkSize,  McStat,    Chunk, &ChunkBlk);
else {
if (MemGetChunkAddr   (*Chunk,   McStat,    &ChunkAddr))
ChunkBlk  = (addrtype )((char *)ChunkAddr - sizeof (chunkstruc));
}
if (Normal(*Status))
if (FileInBlk (&ChunkBlk,   BlkSize,
BlkHdr,      False,       McStat,    VbnBlk))
{
ChunkRefPtr = (chunkstruc *)ChunkBlk;
UnitSize    = ChunkRefPtr->UnitSize;
UnitCount   = ChunkRefPtr->UnitCount;
MemPutChunkStruc   (*Chunk,  (chunkstruc *)ChunkBlk,
DbmDbId,               McStat);
ChunkSize   = UnitSize * UnitCount;
if (ChunkSize != BlkSize - sizeof (chunkstruc))
if (sprintf (Msg, TraceStr1(41),
ChunkSize, BlkSize))
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (Release)
MemFreeFileBlk (BlkHdr,             McStat,        VbnBlk);
TRACK(TrackBak,"FileInChunk\n");
return(STAT);
}
boolean FileGetZeroedChunk (vbntype       VbnBlk,    blkhdrtype *BlkHdr,
boolean       Release,
ft F,lt Z,zz *Status,    numtype    *Chunk)
{
bytessize   UnitSize     = 0;
indextype   UnitCount    = 0;
bytessize   ChunkSize    = 0;
vbntype     ChunkRefVbn  = VbnBlk;
chunkstruc  ChunkRef;
chunkstruc *ChunkRefPtr  = &ChunkRef;
addrtype    ChunkAddr    = NullPtr;
if (FileInBlk ((addrtype *)&ChunkRefPtr,              sizeof(chunkstruc),
BlkHdr,      Release,     McStat,     &ChunkRefVbn))
{
UnitSize  = ChunkRefPtr->UnitSize;
UnitCount = ChunkRefPtr->UnitCount;
ChunkSize = UnitCount * UnitSize;
if (!*Chunk)
MemMakeChunk (UnitSize,  UnitCount, ChunkRef.ExtendQty,
DbmDbId,   McStat,    Chunk);
if (Normal(*Status))
MemPutStackPtr (*Chunk, ChunkRef.StackPtr, McStat);
if (!ChunkSize)
if (sprintf (Msg, TraceStr1(43),
VbnBlk, *Chunk, UnitCount, UnitSize))
TraceMsg (0, Msg);
if (MemGetChunkAddr (*Chunk,     McStat,      &ChunkAddr))
memset           (ChunkAddr,  NULL,    (size_t )ChunkSize);
}
if (Normal(*Status))
if (DeBug)
MemDumpChunk   (0,                 *Chunk,         McStat);
TRACK(TrackBak,"FileGetZeroedChunk\n");
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\gdbm.c*/

#define DBM_C
#define GDBM
#ifdef NULL_TRACE_STRS
#define TraceStr2(StrNum)  TraceStr2[0]
static const char   *TraceStr2[1] = {"   ...GDBM... message\n" };
#else
#define TraceStr2(StrNum)  TraceStr2[StrNum]
static const char *TraceStr2[36] =
{
"\n    DbmFileOutGrpHdr[%4u] ...\n",
"    Grp ExEntryTbl      : Chunk[%4u] AT Vbn[%3u]\n",
"    Grp RgnStatusDirVbn : Chunk[%4u] AT Vbn[%3u]\n",
"    Grp->GrpIndexDir    : Chunk[%4u] AT Vbn[%3u]\n",
"    Grp RegionVbnDir     : Chunk[%4u] AT Vbn[%3u]\n",
"    DbmFileOutGrpRgns    : Release= %s\n",
"     CopyOUT RgnChunk[%3u] To SwapVbn[%4u] @%8x\n\n",
"     RollOut Regions :: Rgns Swaped Out = %s.\n",
"       Region [%4u] @Vbn[%3u] Not Loaded.\n",
"       Chunk [%4u] @%x; SwapVbn[%4u];\n",
"       Copy From      SwapVbn[%4u];  To @%x\n",
"       Region[%4u]   Chunk  [%4u];  To Vbn[%4u]\n",
"       CopyIN CurrRgnChunk[%4u] from SwapVbn[%4u] To @%x\n",
"    DbmFileOutGrpRgns  : Status= %d; GrpHdr @%8x, GrpNum=%3u\n",
"    Number Vchunk Regions Filed out = %u;\n",
"       Region [%4u] @Vbn[%3u] Not Loaded.\n",
"       Region [%4u] @Vbn[%3u] Not Loaded.\n",
"       Chunk [%4u] @%x; SwapVbn[%4u];\n",
"        Copy From  SwapVbn To Chunk[%4u]\n",
"      GrpRgn[%4u]   Chunk  [%4u];  To Vbn[%4u]\n",
" ***Error...GrpHdrNotExist for GrpNum=%3u MaxVbn=%u\n",
" ***Error...GrpHdrNotExist for GrpNum=%3u Vbn=%u\n",
"    LOAD GRPHDR[%3u:%2u] from FilePtr = %x\n" ,
" DbmLoad CoreDb[%2u]::GrpHdr[%2u] has a NULL FilePtr" ,
"    GRP HDR restored from FileVbn[%3u]\n\n",
"    CoreDb[%2u] GrpHdr[%2u] Loaded @ %x\n\n",
"    Grp ExEntryTbl     : Chunk[%4u] AT Vbn[%3u]\n",
"    Grp RegionVbnDir    : Chunk[%4u] AT Vbn[%3u]\n",
"    Grp RgnStatusDir    : Chunk[%4u] AT Vbn[%3u]\n",
"    Grp->GrpIndexDir        : Chunk[%4u] AT Vbn[%3u]\n",
"    Region StackPtr     : %4u\n" ,
"    GRP RegionChunkDir  : Chunk[%4u] Transient. \n",
"    GRP RegionSwapDir   : Chunk[%4u] Transient. \n",
"  DbmFileInGrpRgn :: [%2u]  Chunk[%2u]  :  AT Vbn[%3u]\n",
"    Db[%4u] FileIn Vchunks Region[%2u];Set to zero\n",
" DbmDeleteGrpHdr:: NotImplemented; DbId=%2u, GrpNum=%3u\n"
};
#endif

#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#define    MemGetVbn          MemGetWord
#define    MemPutVbn          MemPutWord
#define    MemGetChunkNum     MemGetWord
#define    MemPutChunkNum     MemPutWord
#define    MemGetIndex        MemGetWord

boolean DbmLoadGrpHdr         (tokentype    *DbToken, numtype       GrpNum,
ft F,lt Z,zz *Status,  grpheader   **GrpHdr)
{
boolean     TmpWriteHdr  = WriteHdr;
boolean     TmpSwapBug   = SwapBug;
int         TmpDeBug     = DeBug;
vbntype     MaxVbn       = 0;
vbntype     GrpHdrVbn    = 0;
boolean     Release      = False;
dbheader   *DbHdr        = NullPtr;
statustype  DumpStatus   = Env_Normal;
if (!DbmBug && !SwapBug)
WriteHdr    = True;
SwapBug        = SwapBug;
DeBug          = DeBug;
DbmDbId        = DbToken->DbId;
if (TmFetchCoreDb  (DbToken,           McStat, &DbHdr))
#ifdef __BAD_CODE__
if (DbHdr->GrpHdrDirVbn == 0)
if (TraceMsg  (0, "  GrpHdrDirVbn == ZERO\n"))
if (HmDumpDbHdr    (0,       DbToken,  McStat))
*Status     = Dbm_NullGrpHdrDirVbn;
#endif
if (Normal(*Status))
if (MemGetStackPtr (DbHdr->GrpVbnDir,  McStat, &MaxVbn))
if (GrpNum >= MaxVbn)
if (sprintf (Msg, TraceStr2(20),
GrpNum, MaxVbn))
if (TraceMsg (0, Msg))
{
MemDumpChunk   (0,  DbHdr->GrpVbnDir,  Dump_Status);
*Status = Dbm_GrpHdrNotExist;
}
if (Normal(*Status))
if (MemGetVbn (DbHdr->GrpVbnDir,      GrpNum, McStat,      &GrpHdrVbn))
if (!GrpHdrVbn)
if (sprintf (Msg, TraceStr2(21),
GrpNum, GrpHdrVbn))
if (TraceMsg (0, Msg))
{
MemDumpChunk   (0,  DbHdr->GrpVbnDir,  Dump_Status);
*Status = Dbm_GrpHdrNotExist;
}
if (Normal(*Status))
if (DbHdr->BlkHdr.BlkFile)
{
} else {
*Status = File_NotFound;
}
if (Normal(*Status))
if (CoreMoreCore (sizeof(grpheader),  McStat,     (addrtype *)GrpHdr))
if (FileInBlk    ((addrtype *)GrpHdr,     (bytessize )sizeof (grpheader),
&DbHdr->BlkHdr,     Release,  McStat,      &GrpHdrVbn))
if (Normal(*Status))
{
(*GrpHdr)->NoRgnsInCore       = True;
if (FREEZE_GRP_PACKETS       == True)
{
(*GrpHdr)->FreezePacket    = True;
(*GrpHdr)->DiskCache       = False;
} else {
(*GrpHdr)->FreezePacket    = False;
(*GrpHdr)->DiskCache       = True;
}
(*GrpHdr)->RegionChunkDir     = 0;
(*GrpHdr)->DirtyRegionDir     = 0;
(*GrpHdr)->RegionFreezeDir    = 0;
(*GrpHdr)->RgnBuffNumDir      = 0;
(*GrpHdr)->RegionSwapDir      = 0;
(*GrpHdr)->RegionVbnDir       = 0;
(*GrpHdr)->RgnStatusDir       = 0;
(*GrpHdr)->ExEntryTbl         = 0;
}
if (Normal(*Status))
if (DbmFileInGrpHdr    (*GrpHdr,  DbmDbId, &DbHdr->BlkHdr, Release, McStat))
MemPutAddr         (DbHdr->GrpHdrDir,       GrpNum,
*(addrtype *)GrpHdr,    McStat);
SwapBug        = TmpSwapBug;
DeBug          = TmpDeBug;
WriteHdr       = TmpWriteHdr;
TRACK(TrackBak,"DbmLoadGrpHdr\n");
return(STAT);
}
boolean DbmFileInGrpHdr  (grpheader    *GrpHdr,    idtype        DbId,
blkhdrtype   *BlkHdr,    boolean       Release,
ft F,lt Z,zz *Status )
{
chunkstruc   RgnChunkStruc;
numtype      AllocEntrys   = 0;
if (FileInChunk (&GrpHdr->ExEntryTbl,            BlkHdr,        Release,
McStat,                       &GrpHdr->ExEntryTblVbn))
if (Normal(*Status))
if (FileInChunk (&GrpHdr->RegionVbnDir,          BlkHdr,        Release,
McStat,                       &GrpHdr->RegionVbnDirVbn))
if (DeBug || DbmBug)
{
Mem_DumpChunkChunk (0, GrpHdr->RegionVbnDir);
}
if (Normal(*Status))
if (GrpHdr->RgnStatusDirVbn)
if (FileInChunk        (&GrpHdr->RgnStatusDir,   BlkHdr,        Release,
McStat,                 &GrpHdr->RgnStatusDirVbn))
MemGetChunkAddr    (GrpHdr->RgnStatusDir,
McStat,     (addrtype *)&GrpHdr->RgnStats);
if (Normal(*Status))
if (GrpHdr->GrpIndexDirVbn)
if (FileInChunk        (&GrpHdr->GrpIndexDir,    BlkHdr,        Release,
McStat,                 &GrpHdr->GrpIndexDirVbn))
MemGetChunkAddr    (GrpHdr->GrpIndexDir,
McStat,     (addrtype *)&GrpHdr->GrpDirAddr);
if (Normal(*Status))
if (MemGetChunkStruc   (GrpHdr->RegionVbnDir,    McStat, &RgnChunkStruc))
AllocEntrys       = (RgnChunkStruc.UnitCount * GrpHdr->RegionEntrys)
+ GrpHdr->BaseIndex;
if (Normal(*Status))
if (MemMakeChunk       (sizeof(numtype),         RgnChunkStruc.UnitCount,
RgnChunkStruc.ExtendQty,           DbId,
McStat,                 &GrpHdr->RegionChunkDir))
if (MemPutStackPtr     (GrpHdr->RegionChunkDir,  RgnChunkStruc.StackPtr,
McStat))
if (MemMakeChunk       (sizeof(numtype),         RgnChunkStruc.UnitCount,
RgnChunkStruc.ExtendQty,           DbId,
McStat,                 &GrpHdr->RegionSwapDir))
if (MemPutStackPtr     (GrpHdr->RegionSwapDir,   RgnChunkStruc.StackPtr,
McStat))
if (MemNewBitChunk     (AllocEntrys,             DbId,
McStat,                 &(GrpHdr->DirtyRegionDir)))
if (MemMakeChunk       (sizeof(numtype),         RgnChunkStruc.UnitCount,
RgnChunkStruc.ExtendQty,           DbId,
McStat,                 &GrpHdr->RegionFreezeDir))
if (MemPutStackPtr     (GrpHdr->RegionFreezeDir, RgnChunkStruc.StackPtr,
McStat))
if (MemGetChunkAddr    (GrpHdr->RegionFreezeDir,
McStat,     (addrtype *)&GrpHdr->FrozenRgns))
if (MemMakeChunk       (sizeof(numtype),         RgnChunkStruc.UnitCount,
RgnChunkStruc.ExtendQty,           DbId,
McStat,                 &GrpHdr->RgnBuffNumDir))
if (MemPutStackPtr     (GrpHdr->RgnBuffNumDir,   RgnChunkStruc.StackPtr,
McStat))
if (MemGetChunkAddr    (GrpHdr->RgnBuffNumDir,
McStat,     (addrtype *)&GrpHdr->RgnBuffNums))
if (MemMakeChunk       (sizeof(numtype),         RgnChunkStruc.UnitCount,
RgnChunkStruc.ExtendQty,           DbId,
McStat,                 &GrpHdr->RgnAccessedDir))
if (MemPutStackPtr     (GrpHdr->RgnAccessedDir,  RgnChunkStruc.StackPtr,
McStat))
if (MemGetChunkAddr    (GrpHdr->RgnAccessedDir,
McStat,     (addrtype *)&GrpHdr->RgnAccessArray))
if (MemMakeChunk       (sizeof(indextype),      (GrpHdr->NumBuffRgns+1),
1,                       DbId,
McStat,                &(GrpHdr->BuffRgnsDir)))
if (MemPutStackPtr     (GrpHdr->BuffRgnsDir,    (GrpHdr->NumBuffRgns+1),
McStat))
if (MemGetChunkAddr    (GrpHdr->BuffRgnsDir,
McStat,     (addrtype *)&GrpHdr->RgnBuffRgns))
if (MemMakeChunk       (sizeof(indextype),      (GrpHdr->NumBuffRgns+1),
1,                       DbId,
McStat,                &(GrpHdr->BuffNodesDir)))
if (MemPutStackPtr     (GrpHdr->BuffNodesDir,   (GrpHdr->NumBuffRgns+1),
McStat))
if (MemGetChunkAddr    (GrpHdr->BuffNodesDir,
McStat,     (addrtype *)&GrpHdr->RgnBuffNodes))
{
GrpHdr->BaseRegion        = 0;
GrpHdr->HeadRgnBuffs      = 0;
GrpHdr->LastRgnBuff       = 0;
GrpHdr->RgnBuffCount      = 0;
}
if (Normal(*Status))
if (GrpHdr->BaseIndex)
DbmFileInGrpRgnChunk  (CoreDbs[DbId], GrpHdr,  0, Release,
McStat,       &GrpHdr->BaseRegion);
TRACK(TrackBak,"DbmFileInGrpHdr\n");
return(STAT);
}
boolean DbmFileInGrpRgnChunk (dbheader     *CoreDb,    grpheader *GrpHdr,
indextype     RgnIndex,  boolean    Release,
ft F,lt Z,zz *Status,    numtype   *RgnChunk )
{
blkhdrtype      BlkHdr;
indextype       MaxRgnVbn    = 0;
indextype       RgnVbn       = 0;
numtype         IsActive     = 0;
int             Index        = -1;
addrtype        RgnAddr      = NullPtr;
indextype       RgnEntrys    = 0;
vchunktkntype  *Vchunk       = (vchunktkntype *)NULL;
BlkHdr = CoreDb->BlkHdr;
if (MemGetStackPtr (GrpHdr->RegionVbnDir,           McStat, &MaxRgnVbn))
if (RgnIndex < MaxRgnVbn)
MemGetVbn      (GrpHdr->RegionVbnDir, RgnIndex, McStat, &RgnVbn);
else {
sprintf (Msg, " DbmFileInGrpRgnChunk:: Grp[%3u]  Index=%3u > Max=%3u\n",
GrpHdr->GrpNum, RgnIndex, MaxRgnVbn);
TraceMsg  (0, Msg);
if (MaxRgnVbn == 0)
return (STAT);
}
if (Normal(*Status))
if (FileInChunk (RgnChunk, &BlkHdr, Release, McStat, &RgnVbn))
{
GrpHdr->NoRgnsInCore     = False;
GrpHdr->RegionIndex      = RgnIndex;
}
if (Normal(*Status))
if (MemPutChunkNum     (GrpHdr->RegionChunkDir, RgnIndex,
*RgnChunk,               McStat))
if (MemPutBit          (GrpHdr->DirtyRegionDir, RgnIndex, 0, McStat))
MemPutVbn          (GrpHdr->RegionSwapDir,  RgnIndex,
0,                      McStat);
if (Normal(*Status))
if (CoreDb->VchunkGrpNum == GrpHdr->GrpNum)
if (GrpHdr->EnvObjType    > That_AttrNum)
if (MemGetChunkNum     (GrpHdr->RgnAccessedDir, RgnIndex,
McStat,                &IsActive))
if (IsActive    == 0)
{
if (MemGetChunkAddr    (*RgnChunk,     McStat,     &RgnAddr))
if (MemGetStackPtr     (*RgnChunk,     McStat,     &RgnEntrys))
{
Vchunk  = (vchunktkntype *)RgnAddr;
for (Index = RgnIndex ? -1  : 0;  ++Index < RgnEntrys;)
Vchunk[Index].InCore = 0;
}
IsActive     = 1;
if (Normal(*Status))
MemPutChunkNum      (GrpHdr->RgnAccessedDir,     RgnIndex,
IsActive,                   McStat);
}
TRACK(TrackBak,"DbmFileInGrpRgnChunk\n");
return(STAT);
}
boolean DbmDeleteGrpHdr
(tokentype    *DbToken, numtype       GrpNum,
ft F,lt Z,zz *Status)
{
sprintf (Msg, TraceStr2(35),
DbToken->DbId, GrpNum);
TraceMsg (0, Msg);
TRACK(TrackBak,"DbmDeleteGrpHdr\n");
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\grp0.c*/

#define  GRP0_C
#define  GRP_C
#define MemFreeFileBlk     Mem_FreeFileBlk

#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#define MemPutHandle         Mem_PutWord
#define MemGetHandle         Mem_GetWord
#define MemPushLocalGrpNum   Mem_PushWord
#define MemPutLocalGrpNum    Mem_PutWord
#define MemGetLocalGrpNum    Mem_GetWord
#define MemPushEntryIndex     Mem_PushWord
#define MemPutEntryIndex      Mem_PutWord
#define MemGetEntryIndex      Mem_GetWord
#define MemPushEntryAddr      Mem_PushAddr
#define MemPutEntryAddr       Mem_PutAddr
#define MemGetEntryAddr       Mem_GetAddr
#define MemGetEntry           Mem_GetAddr
#define MemPutGrpNum         Mem_PutWord
#define MemGetGrpNum         Mem_GetWord
#define MemPushGrpNum        Mem_PushWord
#define MemPushAttrNum       Mem_PushWord
#define MemGetAttrNum        Mem_GetWord
#define MemPutAttrNum        Mem_PutWord
#define MemPushObjHdr        Mem_PushAddr
#define MemPutObjHdr         Mem_PutAddr
#define MemGetObjHdr         Mem_GetAddr
#define MemPushChunkNum      Mem_PushWord
#define MemPopChunkNum       Mem_PopWord
#define MemGetChunkNum       Mem_GetWord
#define MemPutChunkNum       Mem_PutWord
#define MemPushIndex         Mem_PushWord
#define MemGetIndex          Mem_GetWord
#define MemPutIndex          Mem_PutWord
#define MemPopIndex          Mem_PopWord
#define MemPutRegionNum      Mem_PutWord
#define MemGetRegionNum      Mem_GetWord
#define MemPutOffset         Mem_PutWord
#define MemGetOffset         Mem_GetWord
#define MemPushLink          Mem_PushWord
#define MemPutLink           Mem_PutWord
#define MemGetLink           Mem_GetWord
#define MemPushExEntry        Mem_PushWord
#define MemPopExEntry         Mem_PopWord
#define MemPopVbn            Mem_PopWord
#define MemGetVbn            Mem_GetWord
#define MemGetChunkNum       Mem_GetWord
#define MemGetSize           Mem_GetWord
#define MemPushSize          Mem_PushWord
boolean GrpMakeHdrChunks (tokentype    *Anchor,    grpheader    *GrpHdr,
numtype       AllocRgns, numtype       AllocXs,
ft F,lt Z,zz *Status)
{
idtype       CoreDbId        = Anchor->DbId;
numtype      AllocEntrys     = (AllocRgns * GrpHdr->RegionEntrys)
+ GrpHdr->BaseIndex;
numtype      ExtendRegions   = AllocRgns;
if (GrpHdr->BaseIndex)
AllocRgns++;
if (MemMakeChunk (sizeof(chunknum),  AllocRgns,   ExtendRegions,
CoreDbId,          McStat,    &(GrpHdr->RegionChunkDir)))
if (MemMakeChunk (sizeof(vbntype),   AllocRgns,   ExtendRegions,
CoreDbId,          McStat,    &(GrpHdr->RegionSwapDir)))
if (MemNewBitChunk
(AllocEntrys,       CoreDbId,
McStat,                       &(GrpHdr->DirtyRegionDir)))
if (MemMakeChunk (sizeof(numtype),   AllocRgns,   ExtendRegions,
CoreDbId,          McStat,    &(GrpHdr->RegionFreezeDir)))
if (MemGetChunkAddr
(GrpHdr->RegionFreezeDir,
McStat,            (addrtype *)&GrpHdr->FrozenRgns))
if (MemMakeChunk (sizeof(numtype),   AllocRgns,   ExtendRegions,
CoreDbId,          McStat,    &(GrpHdr->RgnBuffNumDir)))
if (MemGetChunkAddr
(GrpHdr->RgnBuffNumDir,
McStat,            (addrtype *)&GrpHdr->RgnBuffNums))
if (MemMakeChunk (sizeof(numtype),   AllocRgns,   ExtendRegions,
CoreDbId,          McStat,    &(GrpHdr->RgnAccessedDir)))
if (MemGetChunkAddr
(GrpHdr->RgnAccessedDir,
McStat,            (addrtype *)&GrpHdr->RgnAccessArray))
if (MemMakeChunk (sizeof(vbntype),   AllocRgns,   ExtendRegions,
CoreDbId,          McStat,    &(GrpHdr->RegionVbnDir)))
if (MemMakeChunk (sizeof(chunkindex),AllocXs,      AllocXs,
CoreDbId,          McStat,      &(GrpHdr->ExEntryTbl)))
if (MemMakeChunk (sizeof(indextype), (GrpHdr->NumBuffRgns+1),ExtendRegions,
CoreDbId,          McStat,    &(GrpHdr->BuffRgnsDir)))
if (MemPutStackPtr
(GrpHdr->BuffRgnsDir,           (GrpHdr->NumBuffRgns+1),
McStat))
if (MemGetChunkAddr
(GrpHdr->BuffRgnsDir,
McStat,           (addrtype *)&GrpHdr->RgnBuffRgns))
if (MemMakeChunk (sizeof(indextype), (GrpHdr->NumBuffRgns+1),ExtendRegions,
CoreDbId,          McStat,    &(GrpHdr->BuffNodesDir)))
if (MemPutStackPtr
(GrpHdr->BuffNodesDir,          (GrpHdr->NumBuffRgns+1),
McStat))
if (MemGetChunkAddr
(GrpHdr->BuffNodesDir,
McStat,           (addrtype *)&GrpHdr->RgnBuffNodes))
if (MemMakeChunk (sizeof (indextype),       AllocRgns,   AllocRgns,
Anchor->DbId,    McStat,      &GrpHdr->RgnStatusDir))
if (MemPutStackPtr
(GrpHdr->RgnStatusDir,     AllocRgns,   McStat))
if (MemGetChunkAddr
(GrpHdr->RgnStatusDir,
McStat,      (addrtype *)&GrpHdr->RgnStats))
{
GrpHdr->RegionVbnDirVbn   = 0;
GrpHdr->ExEntryTblVbn     = 0;
GrpHdr->BaseRegion        = 0;
GrpHdr->RegionsAllocd     = AllocRgns;
GrpHdr->HeadRgnBuffs      = 0;
GrpHdr->LastRgnBuff       = 0;
GrpHdr->RgnBuffCount      = 0;
}
TRACK(TrackBak,"GrpMakeHdrChunks\n");
return (STAT);
}
boolean GrpGetPacket     (tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status,    grpheader   **GrpHdr)
{
dbheader    *CoreDb   = NullPtr;
if (TmGetCoreDb   (Anchor,                      McStat,            &CoreDb))
if (MemGetAddr    (CoreDb->GrpHdrDir, GrpNum,   McStat, (addrtype *)GrpHdr))
{
if (*GrpHdr == NullPtr)
DbmLoadGrpHdr (Anchor, GrpNum,     McStat,      GrpHdr);
} else {
*Status = Grp_GrpHdrNotExist;
}
TRACK(TrackBak,"GrpGetPacket\n");
return (STAT);
}
boolean GrpNewRegion     (dbheader     *CoreDb,    grpheader    *GrpHdr,
indextype     Index,     indextype     RgnIndex,
ft F,lt Z,zz *Status,
numtype      *RgnChunk,  addrtype     *RgnAddr)
{
indextype   StackPtr   = 0;
indextype   RgnEntrys  = 0;
indextype   Region     = 0;
bytessize   UnitSize   = 0;
sizetype    RegionSize = 0;
boolean     TempMemBug = MemBug;
*RgnAddr  = NullPtr;
if (GrpBug == True)
MemBug = True;
if (RgnIndex          == 0
&&  GrpHdr->BaseIndex  > 0)
RgnEntrys  = GrpHdr->BaseIndex;
else
RgnEntrys  = GrpHdr->RegionEntrys;
if (Normal(*Status))
if (*RgnAddr)
{
RegionSize    = GrpHdr->RegionEntrys  * GrpHdr->EntrySize;
if (Normal(*Status))
if (MemPutStackPtr   (*RgnChunk,     0,          McStat))
memset           (*RgnAddr,      NULL,       RegionSize);
} else {
if (MemMakeChunk     (GrpHdr->EntrySize,         RgnEntrys,
0,                         CoreDb->DbId,
McStat,                    RgnChunk))
MemGetChunkAddr  (*RgnChunk,     McStat,     RgnAddr);
}
if (Normal(*Status))
if (GrpHdr->RegionVbnDir)
if (MemGetStackPtr  (GrpHdr->RegionVbnDir,   McStat,  &StackPtr))
if (RgnIndex      == StackPtr)
MemPushChunkNum (GrpHdr->RegionVbnDir,   0,        McStat, &StackPtr);
if (Normal(*Status))
if (MemPutIndex     (GrpHdr->RgnStatusDir,   RgnIndex, 0,       McStat))
if (MemGetChunkAddr (GrpHdr->RgnStatusDir,             McStat,
(addrtype *)&GrpHdr->RgnStats))
if (MemPushChunkNum (GrpHdr->RegionChunkDir,*RgnChunk, McStat, &StackPtr))
if (MemPushChunkNum (GrpHdr->RegionSwapDir,  0,        McStat, &StackPtr))
if (MemPushChunkNum (GrpHdr->RegionFreezeDir,0,        McStat, &StackPtr))
if (MemPushChunkNum (GrpHdr->RgnBuffNumDir,  0,        McStat, &StackPtr))
if (MemPushChunkNum (GrpHdr->RgnAccessedDir, 1,        McStat, &StackPtr))
{
Region             = (regionnum )StackPtr;
if (MemPutBit       (GrpHdr->DirtyRegionDir, Region,   1,       McStat))
if (MemGetChunkAddr (GrpHdr->RgnStatusDir,
McStat,     (addrtype *)&GrpHdr->RgnStats))
if (MemGetChunkAddr (GrpHdr->RegionFreezeDir,
McStat,     (addrtype *)&GrpHdr->FrozenRgns))
if (MemGetChunkAddr (GrpHdr->RgnBuffNumDir,
McStat,     (addrtype *)&GrpHdr->RgnBuffNums))
if (MemGetChunkAddr (GrpHdr->RgnAccessedDir,
McStat,     (addrtype *)&GrpHdr->RgnAccessArray))
MemGetChunkSize (GrpHdr->RegionChunkDir,               McStat,
(indextype *)&GrpHdr->RegionsAllocd, &UnitSize);
if (Normal(*Status))
{
GrpHdr->NoRgnsInCore    = False;
GrpHdr->RegionCount++;
if (Region != 0)
GrpHdr->RegionIndex   = Region;
else {
if (GrpHdr->BaseIndex == 0)
GrpHdr->RegionIndex = Region;
}
if (RgnIndex == 0)
GrpHdr->BaseRegion    = *RgnChunk;
if (RgnIndex           != Region)
*Status              = Grp_BadSwapChunks;
}
}
if (Normal(*Status))
if (RgnIndex              > 0
||  GrpHdr->BaseIndex    == 0)
if (GrpHdr->RgnBuffCount < GrpHdr->NumBuffRgns)
{
GrpHdr->RgnBuffCount++;
GrpHdr->HeadRgnBuffs                          = GrpHdr->RgnBuffCount;
GrpHdr->RgnBuffRgns[GrpHdr->RgnBuffCount]     = RgnIndex;
MemPutWord        (GrpHdr->RgnBuffNumDir,       RgnIndex,
GrpHdr->RgnBuffCount,        McStat);
}
MemBug = TempMemBug;
if (Normal(*Status))
if (DbmBug || SwapBug || DeBug)
if (*RgnChunk)
DumpChunkChunk (0, *RgnChunk);
TRACK(TrackBak,"GrpNewRegion\n");
return(STAT);
}
boolean Grp_GetRegion    (dbheader     *CoreDb,    grpheader    *GrpHdr,
indextype     RgnIndex,  ft F,lt Z,zz *Status,
numtype      *RgnChunk,  addrtype     *RgnAddr)
{
vbn           Vbn          = 0;
vbntype       RgnVbn       = 0;
boolean       CopyIn       = False;
boolean       FileIn       = False;
numtype       BuffIndex    = 0;
statustype    ShellStatus  = Env_Normal;
tokentype     Anchor       = NullToken;
Anchor.DbId   = CoreDb->DbId;
Anchor.Handle = 1;
*RgnAddr  = NullPtr;
if (MemGetChunkNum  (GrpHdr->RegionChunkDir,  RgnIndex,  McStat,  RgnChunk))
if (*RgnChunk)
if (MemGetChunkAddr (*RgnChunk,               McStat,    RgnAddr))
if (*RgnAddr != NullPtr)
{
if (GrpHdr->FreezePacket == False)
if (MemGetWord   (GrpHdr->RgnBuffNumDir,   RgnIndex,  McStat, &BuffIndex))
GrpHdr->RgnBuffNodes[BuffIndex] = 1;
if (!Normal(*Status))
Grp_DumpStruct (&Anchor,  GrpHdr->GrpNum, ShellMcStat);
CacheAtRgnChunks++;
TRACK(TrackBak,"GrpGetRegion\n");
return(STAT);
}
if (MemGetVbn           (GrpHdr->RegionSwapDir,    RgnIndex,
McStat,                  &RgnVbn))
if (RgnVbn   > 0)
{
CopyIn   = True;
} else
FileIn   = True;
if (Normal(*Status))
if (FileIn)
{
if (MemGetVbn      (GrpHdr->RegionVbnDir,    RgnIndex,  McStat, &Vbn))
if (Vbn)
{
if (DbmFileInGrpRgnChunk (CoreDb,    GrpHdr,     RgnIndex,  False,
McStat,    RgnChunk))
MemGetChunkAddr      (*RgnChunk, McStat,     RgnAddr);
} else {
if (MemGetChunkNum (GrpHdr->RegionChunkDir,  RgnIndex,
McStat,                  RgnChunk))
if (RgnChunk == 0)
*Status = Grp_NullRegionChunk;
}
FileInRgnChunks++;
} else if (CopyIn) {
*Status  = Err_NotImplemented;
}
if (RgnIndex != 0)
GrpHdr->RegionIndex = RgnIndex;
else {
if (GrpHdr->BaseIndex == 0)
GrpHdr->RegionIndex = RgnIndex;
}
if (Normal(*Status))
if (GrpHdr->EnvObjType  <= That_AttrNum)
DbmPairRgnObjects  (CoreDb, (objheader *)GrpHdr,  *RgnChunk,  McStat);
TRACK(TrackBak,"GrpGetRegion\n");
return(STAT);
}
boolean Grp_CleanRgnChunks
(dbheader     *CoreDb,    grpheader    *GrpHdr,
indextype     RgnIndex,  numtype       RgnChunk,
ft F,lt Z,zz *Status)
{
numtype    OldValue   = 0;
indextype  StackPtr   = 0;
numtype    RgnVbn     = 0;
numtype    ChunkRgn   = 0;
numtype    SwapVbn    = 0;
indextype  BuffIndex  = 0;
if (Normal(*Status))
if (MemPopChunkNum  (GrpHdr->RegionSwapDir,  McStat, &SwapVbn,  &StackPtr))
if (MemPopChunkNum  (GrpHdr->RgnStatusDir,  McStat, &OldValue,  &StackPtr))
if (MemPopVbn       (GrpHdr->RegionVbnDir,   McStat, &RgnVbn,   &StackPtr))
if (MemPopChunkNum  (GrpHdr->RegionChunkDir, McStat, &ChunkRgn, &StackPtr))
if (MemPopChunkNum  (GrpHdr->RegionFreezeDir,McStat, &OldValue, &StackPtr))
if (MemPopChunkNum  (GrpHdr->RgnBuffNumDir,  McStat, &OldValue, &StackPtr))
if (MemPopChunkNum  (GrpHdr->RgnAccessedDir, McStat, &OldValue, &StackPtr))
{
GrpHdr->RgnStats[RgnIndex] = 0;
GrpHdr->RegionCount--;
if (RgnIndex != 0)
GrpHdr->RegionIndex      = RgnIndex;
else
GrpHdr->BaseRegion       = 0;
if (RgnVbn)
MemFreeFileBlk     (&CoreDb->BlkHdr, McStat, &RgnVbn);
}
if (Normal(*Status))
if (RgnChunk == ChunkRgn)
{
MemFreeChunk         (&ChunkRgn,   McStat);
} else {
*Status   = Grp_RgnNotMatched;
}
if (Normal(*Status))
if (RgnIndex              > 0
||  GrpHdr->BaseIndex    == 0)
if (GrpHdr->RgnBuffCount  > 0)
if (GrpHdr->RgnBuffCount  < GrpHdr->NumBuffRgns)
{
GrpHdr->HeadRgnBuffs              = --GrpHdr->RgnBuffCount;
BuffIndex                         =   GrpHdr->RgnBuffNums[RgnIndex];
GrpHdr->RgnBuffNums[RgnIndex]     = 0;
while (BuffIndex <= GrpHdr->RgnBuffCount)
{
RgnIndex                       = GrpHdr->RgnBuffRgns[BuffIndex+1];
GrpHdr->RgnBuffNodes[BuffIndex]= GrpHdr->RgnBuffNodes[BuffIndex+1];
GrpHdr->RgnBuffRgns[BuffIndex] = GrpHdr->RgnBuffRgns[BuffIndex+1];
GrpHdr->RgnBuffNums[RgnIndex]  = BuffIndex;
BuffIndex++;
}
} else if (GrpHdr->FreezePacket == False) {
GrpHdr->HeadRgnBuffs              = --GrpHdr->RgnBuffCount;
BuffIndex                         =   GrpHdr->RgnBuffNums[RgnIndex];
GrpHdr->RgnBuffNums[RgnIndex]     = 0;
while (BuffIndex <= GrpHdr->RgnBuffCount)
{
RgnIndex                       = GrpHdr->RgnBuffRgns[BuffIndex+1];
GrpHdr->RgnBuffNodes[BuffIndex]= GrpHdr->RgnBuffNodes[BuffIndex+1];
GrpHdr->RgnBuffRgns[BuffIndex] = GrpHdr->RgnBuffRgns[BuffIndex+1];
GrpHdr->RgnBuffNums[RgnIndex]  = BuffIndex;
BuffIndex++;
}
}
TRACK(TrackBak,"GrpCleanRgnChunks\n");
return(STAT);
}
boolean Grp_DeleteRgn
(dbheader     *CoreDb,    grpheader    *GrpHdr,
indextype     RgnIndex,  numtype       RgnChunk,
ft F,lt Z,zz *Status)
{
int           i            = -1;
indextype     Ilow         = 0;
indextype     Ihigh        = 0;
indextype     Ilimit       = 0;
numtype      *ExEntrys     = NullPtr;
numtype       Hits         = 0;
indextype     CurrIndex    = 0;
indextype     RgnNum       = 0;
numtype       Region       = 0;
bytetype     *ByteAddr     = NullPtr;
numtype       RegionEntrys = 0;
indextype     ExEntryCount = 0;
if (MemGetStackPtr   (RgnChunk,             McStat,         &RegionEntrys))
if (MemGetChunkAddr  (GrpHdr->ExEntryTbl,   McStat, (addrtype *)&ExEntrys))
if (MemGetStackPtr   (GrpHdr->ExEntryTbl,   McStat,         &ExEntryCount))
if (GrpHdr->BaseIndex > 0)
{
if (RgnIndex == 0)
{
Ilow    = 0;
Ihigh   = GrpHdr->BaseIndex - 1;
} else {
Ilow    = GrpHdr->BaseIndex + (GrpHdr->RegionEntrys * (RgnIndex -1));
Ihigh   = Ilow              +  GrpHdr->RegionEntrys - 1;
}
} else {
Ilow       = GrpHdr->RegionEntrys *  RgnIndex;
Ihigh      = Ilow                 +  GrpHdr->RegionEntrys - 1;
}
if (GrpHdr->ExEntryCount != ExEntryCount)
{
*Status            = Grp_BadExEntryTable;
}
Ilimit        = RegionEntrys;
CurrIndex     = 0;
if (Normal(*Status))
for (i        = 0,     Hits         = 0;
i        < GrpHdr->ExEntryCount;
++i)
{
if (Hits    >= Ilimit)
ExEntrys[CurrIndex++]     = ExEntrys[i];
else if (ExEntrys[i] >= Ilow
&&  ExEntrys[i] <= Ihigh)
++Hits;
else
ExEntrys[CurrIndex++]     = ExEntrys[i];
}
if (Normal(*Status))
if (MemPutStackPtr  (GrpHdr->ExEntryTbl, CurrIndex,   McStat))
{
GrpHdr->ExEntryCount          = CurrIndex;
GrpHdr->EntryCount           -= Hits;
if (Hits            != Ilimit)
*Status            = Grp_BadExEntryTable;
}
GrpHdr->RgnStats[RgnIndex]     = 0;
if (Normal(*Status))
Grp_CleanRgnChunks (CoreDb,  GrpHdr,  RgnIndex,  RgnChunk,  McStat);
if (Normal(*Status))
if (GrpHdr->RegionCount)
if (GrpHdr->BaseIndex    == 0
||  GrpHdr->RegionCount   > 1)
if (GrpHdr->RgnStats[GrpHdr->RegionCount-1]
== GrpHdr->RegionEntrys)
{
RgnNum     =  GrpHdr->RegionCount - 1;
if (GrpGetRegion    (CoreDb,     GrpHdr,   RgnNum,
McStat,    &Region,  (addrtype *)&ByteAddr))
if (MemPutBit       (GrpHdr->DirtyRegionDir,      RgnNum, 1, McStat))
Grp_DeleteRgn    (CoreDb,     GrpHdr,   RgnNum,  Region,  McStat);
}
TRACK(TrackBak,"GrpDeleteRgn\n");
return(STAT);
}
boolean Grp_RgnSwapTopAndPop
(dbheader     *CoreDb,    grpheader    *GrpHdr,
indextype     RgnIndex,  numtype       RgnChunk,
ft F,lt Z,zz *Status)
{
int           i            = -1;
indextype     Ilow         = 0;
indextype     Ihigh        = 0;
indextype     Ibase        = 0;
indextype     Idiff        = 0;
indextype     Ilimit       = 0;
numtype      *ExEntrys     = NullPtr;
numtype       Hits         = 0;
indextype     CurrIndex    = 0;
numtype       RegionEntrys = 0;
indextype     vIndex       = 0;
numtype       ExRegion     = 0;
numtype       ExRgnEntrys  = 0;
size_t        BytesSize    = 0;
addrtype      SourceAddr   = NullPtr;
addrtype      TargetAddr   = NullPtr;
if (GrpGetRegion     (CoreDb,     GrpHdr,      GrpHdr->RegionCount -1,
McStat,    &ExRegion,   &SourceAddr))
if (MemGetStackPtr   (ExRegion,   McStat,     &ExRgnEntrys))
if (ExRgnEntrys == GrpHdr->RegionEntrys)
{
if (MemGetStackPtr   (RgnChunk,             McStat,         &RegionEntrys))
if (MemGetChunkAddr  (GrpHdr->ExEntryTbl,   McStat, (addrtype *)&ExEntrys))
if (RgnIndex          == 0
&&  GrpHdr->BaseIndex != 0)
{
*Status    = Grp_CanNotSwapBaseRgn;
} else {
Ilow       = GrpHdr->BaseIndex + (GrpHdr->RegionEntrys * (RgnIndex -1));
Ihigh      = Ilow              +  GrpHdr->RegionEntrys - 1;
}
BytesSize     = GrpHdr->RegionEntrys *  GrpHdr->EntrySize;
Ilimit        = RegionEntrys;
CurrIndex     = 0;
if (Normal(*Status))
for (i = 0,         Hits         = 0;
i    < GrpHdr->ExEntryCount
||   Hits < Ilimit; ++i)
{
if (ExEntrys[i] >= Ilow
&&  ExEntrys[i] <= Ihigh)
++Hits;
else
ExEntrys[CurrIndex++]     = ExEntrys[i];
}
if (Normal(*Status))
{
GrpHdr->ExEntryCount          = CurrIndex;
GrpHdr->EntryCount           -= Hits;
if (Hits                     != Ilimit)
*Status                     = Grp_BadExEntryTable;
}
if (Normal(*Status))
{
Ibase            = Ilow;
Idiff            = GrpHdr->EntryCount   - Ilow;
Ilow             = GrpHdr->EntryCount   - GrpHdr->RegionEntrys;
Ihigh            = GrpHdr->EntryCount   - 1;
for (i = 0;
i < GrpHdr->GrpDirCount &&   Hits < RegionEntrys; ++i)
{
if (GrpHdr->GrpDirAddr[i] > 0)
{
vIndex                 = abs((int )GrpHdr->GrpDirAddr[i]);
if (vIndex            >= Ilow
&&  vIndex            <= Ihigh)
{
++Hits;
GrpHdr->GrpDirAddr[i]  =  vIndex - Idiff;
}
}
}
}
if (Normal(*Status))
if (GrpGetRegion     (CoreDb,     GrpHdr,      GrpHdr->RegionCount -1,
McStat,    &ExRegion,   &SourceAddr))
if (MemGetStackPtr   (ExRegion,   McStat,     &ExRgnEntrys))
if (MemGetChunkAddr  (RgnChunk,   McStat,     &TargetAddr))
{
memcpy            (TargetAddr, SourceAddr,  BytesSize);
Grp_CleanRgnChunks(CoreDb, GrpHdr, GrpHdr->RegionCount - 1, ExRegion,
McStat);
}
if (*Status     == Grp_CanNotSwapBaseRgn)
*Status      = Env_Normal;
}
TRACK(TrackBak,"Grp_RgnSwapTopAndPop\n");
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\grp1.c*/

#define  GRP1_C
#define  GRP_C
#ifdef NULL_TRACE_STRS
#define TraceStr3(StrNum)  TraceStr3[0]
static const char   *TraceStr3[1] = {"   ...GRP1... message\n" };
#else
#define TraceStr3(StrNum)  TraceStr3[StrNum]
static const char *TraceStr3[17] =
{
"    GrpNewPacket (CoreDb[%2u] @ %x)  for GrpNum = %3u\n",
"       GrpHdrDir = %4u,  GrpVbnDir = %4u;\n",
"   NEW GrpHdr[%3u] @ %x Regions=%3u Entries/Region=%4u; Base=%3u\n",
"    GrpSetPacketCache[%3d]  = %s\n",
" Error in GrpSetPacketCache :: DbId= %3u; GrpNum=%6u\n",
"    GrpSetAccessType[%3d]  = %s\n",
" Error in GrpSetAccessType:: DbId= %3u; GrpNum=%6u\n",
"    GrpFreezePacket[%3d]\n",
" Error in GrpFreezePacket:: DbId= %3u; GrpNum=%6u\n",
"    GrpThawPacket[%3d]\n",
" Error in GrpThawPacket:: DbId= %3u; GrpNum=%6u\n",
"    GrpDefrostPacket[%3d]\n",
" Error in GrpThawPacket:: DbId= %3u; GrpNum=%6u\n",
"    Free Packet[%3d]  @ %x\n",
" Error in GrpFreePacket:: DbId= %3u; GrpNum=%6u\n",
"    Delete Packet[%3d]  @ %x\n",
" Error in GrpDeletePacket:: DbId= %3u; GrpNum=%6u\n"
};
#endif
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#define MemPutHandle         Mem_PutWord
#define MemGetHandle         Mem_GetWord
#define MemPushLocalGrpNum   Mem_PushWord
#define MemPutLocalGrpNum    Mem_PutWord
#define MemGetLocalGrpNum    Mem_GetWord
#define MemPushEntryIndex     Mem_PushWord
#define MemPutEntryIndex      Mem_PutWord
#define MemGetEntryIndex      Mem_GetWord
#define MemPushEntryAddr      Mem_PushAddr
#define MemPutEntryAddr       Mem_PutAddr
#define MemGetEntryAddr       Mem_GetAddr
#define MemGetEntry           Mem_GetAddr
#define MemPutGrpNum         Mem_PutWord
#define MemGetGrpNum         Mem_GetWord
#define MemPushGrpNum        Mem_PushWord
#define MemPushAttrNum       Mem_PushWord
#define MemGetAttrNum        Mem_GetWord
#define MemPutAttrNum        Mem_PutWord
#define MemPushObjHdr        Mem_PushAddr
#define MemPutObjHdr         Mem_PutAddr
#define MemGetObjHdr         Mem_GetAddr
#define MemPushChunkNum      Mem_PushWord
#define MemGetChunkNum       Mem_GetWord
#define MemPutChunkNum       Mem_PutWord
#define MemPushIndex         Mem_PushWord
#define MemGetIndex          Mem_GetWord
#define MemPutIndex          Mem_PutWord
#define MemPopIndex          Mem_PopWord
#define MemPutRegionNum      Mem_PutWord
#define MemGetRegionNum      Mem_GetWord
#define MemPutOffset         Mem_PutWord
#define MemGetOffset         Mem_GetWord
#define MemPushLink          Mem_PushWord
#define MemPutLink           Mem_PutWord
#define MemGetLink           Mem_GetWord
#define MemPushExEntry        Mem_PushWord
#define MemPopExEntry         Mem_PopWord
#define MemGetVbn            Mem_GetWord
#define MemGetChunkNum       Mem_GetWord
#define MemGetSize           Mem_GetWord
#define MemPushSize          Mem_PushWord
boolean Grp_NewPacket    (tokentype    *Anchor,    sizetype      EntrySize,
numtype       AllocRgns, numtype       RgnEntrys,
numtype       AllocXs,   numtype       BaseIndex,
accesstype    AccessType,boolean       DiskCache,
numtype       CacheLimit,numtype       CacheLoad,
numtype       BuffRgns,
ft F,lt Z,zz *Status,    numtype      *GrpNum,
grpheader   **GrpHdr,    numtype      *BaseRegion)
{
dbheader    *CoreDb          = NullPtr;
indextype    StackPtr        = 0;
addrtype     NullHdr         = NullPtr;
*GrpHdr     = NullPtr;
if (TmGetCoreDb       (Anchor,   McStat,   &CoreDb))
if (Normal(*Status))
if (CoreDb->HeadFreeGrps == 0)
{
if (MemPushWord     (CoreDb->GrpVbnDir,  0,       McStat, &StackPtr))
if (MemPushAddr     (CoreDb->GrpHdrDir,  NullHdr, McStat, &StackPtr))
MemGetChunkAddr (CoreDb->GrpHdrDir,
McStat,            (addrtype *)&CoreDb->GrpHdrs);
*GrpNum    = ++CoreDb->GrpCount;
if (*GrpNum != StackPtr)
*Status = Grp_BadGrpCount;
} else {
*GrpNum   = CoreDb->HeadFreeGrps;
MemGetAddr   (CoreDb->GrpHdrDir,  *GrpNum,
McStat,              (addrtype *)&CoreDb->HeadFreeGrps);
}
if (Normal(*Status))
{
if (Normal(*Status))
if (CoreMoreCore      (sizeof(grpheader),  McStat,    (addrtype *)GrpHdr))
if (MemPutAddr        (CoreDb->GrpHdrDir, *GrpNum,   *(addrtype *)GrpHdr,
McStat))
if (MemPutWord        (CoreDb->GrpVbnDir, *GrpNum,    0,          McStat))
{
(**GrpHdr).EnvObjType    = EnvType_AttrNum;
if (DiskCache           == True
&&  XmemFilePtr         == NULL)
DiskCache            = False;
(**GrpHdr).PacketAccess  = AccessType;
(**GrpHdr).DiskCache     = DiskCache;
(**GrpHdr).GrpNum        = *GrpNum;
(**GrpHdr).EntrySize     = EntrySize;
(**GrpHdr).EntryCount    = 0;
(**GrpHdr).RegionEntrys  = RgnEntrys;
(**GrpHdr).RegionCount   = 0;
(**GrpHdr).RegionIndex   = 0;
(**GrpHdr).NoRgnsInCore  = True;
if (FREEZE_GRP_PACKETS  == True)
{
(**GrpHdr).FreezePacket  = True;
(**GrpHdr).DiskCache     = False;
} else {
(**GrpHdr).FreezePacket  = False;
(**GrpHdr).DiskCache     = True;
}
(**GrpHdr).ExEntryCount  = 0;
(**GrpHdr).NextEx        = 0;
(**GrpHdr).NextEntry     = 1;
(**GrpHdr).BaseIndex     = BaseIndex;
(**GrpHdr).BaseRegion    = 0;
if (BuffRgns == 0)
BuffRgns   = 5;
else if (BuffRgns > 50)
	BuffRgns   = 50;
(**GrpHdr).NumBuffRgns   = BuffRgns;
if (CacheLimit == 0)
{
CacheLimit = BuffRgns;
CacheLoad  = BuffRgns;
}
(**GrpHdr).CacheLimit    = CacheLimit;
(**GrpHdr).CacheLoad     = CacheLoad;
(**GrpHdr).RgnStatusDir  = 0;
(**GrpHdr).RgnStatusDirVbn = 0;
(**GrpHdr).RgnStats      = NullPtr;
(**GrpHdr).GrpIndexDir   = 0;
(**GrpHdr).GrpIndexDirVbn= 0;
(**GrpHdr).GrpDirCount   = 0;
(**GrpHdr).HeadExIndexs  = 0;
(**GrpHdr).GrpDirAddr    = NullPtr;
if ( RgnEntrys > 1 )
	 (**GrpHdr).RegionEntrys  = 8162/EntrySize;
}
if (Normal(*Status))
{
GrpMakeHdrChunks   (Anchor,  *GrpHdr,  AllocRgns,  AllocXs,  McStat);
*BaseRegion = (**GrpHdr).BaseRegion;
}
}
TRACK(TrackBak,"GrpNewPacket\n");
return (STAT);
}
boolean Grp_SetPacketCache
(tokentype    *Anchor,    numtype       GrpNum,
boolean       DiskCache, ft F,lt Z,zz *Status)
{
dbheader    *CoreDb   = NullPtr;
grpheader   *GrpHdr   = NullPtr;
vbntype      Vbn      = 0;
if (TmGetCoreDb   (Anchor,                      McStat,            &CoreDb))
if (MemGetAddr    (CoreDb->GrpHdrDir, GrpNum,   McStat,(addrtype *)&GrpHdr))
{
if (GrpHdr == NullPtr)
{
if(CoreDb->GrpHdrDirVbn)
if (MemGetVbn     (CoreDb->GrpVbnDir,               GrpNum,
McStat,                         &Vbn))
DbmLoadGrpHdr (Anchor, GrpNum,     McStat,     &GrpHdr);
}
if (GrpHdr)
GrpHdr->DiskCache  = DiskCache;
else
*Status  = Grp_PacketNotExist;
} else {
*Status = Grp_GrpHdrNotExist;
}
TRACK(TrackBak,"GrpSetPacketCache\n");
return (STAT);
}
boolean Grp_SetPacketAccess
(tokentype    *Anchor,    numtype       GrpNum,
accesstype    AccessType,ft F,lt Z,zz *Status)
{
dbheader    *CoreDb   = NullPtr;
grpheader   *GrpHdr   = NullPtr;
vbntype      Vbn      = 0;
if (TmGetCoreDb   (Anchor,                      McStat,            &CoreDb))
if (MemGetAddr    (CoreDb->GrpHdrDir, GrpNum,   McStat,(addrtype *)&GrpHdr))
{
if (GrpHdr == NullPtr)
{
if(CoreDb->GrpHdrDirVbn)
if (MemGetVbn     (CoreDb->GrpVbnDir,               GrpNum,
McStat,                         &Vbn))
DbmLoadGrpHdr (Anchor, GrpNum,     McStat,     &GrpHdr);
}
if (GrpHdr)
GrpHdr->PacketAccess = AccessType;
else
*Status  = Grp_PacketNotExist;
} else {
*Status = Grp_GrpHdrNotExist;
}
TRACK(TrackBak,"GrpSetPacketAccess\n");
return (STAT);
}
boolean Grp_FreezePacket (tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status)
{
dbheader    *CoreDb   = NullPtr;
grpheader   *GrpHdr   = NullPtr;
vbntype      Vbn      = 0;
if (TmGetCoreDb   (Anchor,                      McStat,            &CoreDb))
if (MemGetAddr    (CoreDb->GrpHdrDir, GrpNum,   McStat,(addrtype *)&GrpHdr))
{
if (GrpHdr == NullPtr)
{
if(CoreDb->GrpHdrDirVbn)
if (MemGetVbn     (CoreDb->GrpVbnDir,               GrpNum,
McStat,                         &Vbn))
DbmLoadGrpHdr (Anchor, GrpNum,     McStat,     &GrpHdr);
}
if (GrpHdr)
GrpHdr->FreezePacket  = True;
else
*Status  = Grp_PacketNotExist;
} else {
*Status = Grp_GrpHdrNotExist;
}
TRACK(TrackBak,"GrpFreezePacket\n");
return (STAT);
}
boolean Grp_ThawPacket   (tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status)
{
dbheader    *CoreDb   = NullPtr;
grpheader   *GrpHdr   = NullPtr;
if (TmGetCoreDb   (Anchor,                      McStat,            &CoreDb))
if (MemGetAddr    (CoreDb->GrpHdrDir, GrpNum,   McStat,(addrtype *)&GrpHdr))
{
if (GrpHdr)
GrpHdr->FreezePacket  = False;
else
*Status  = Grp_PacketNotLoaded;
} else {
*Status = Grp_GrpHdrNotExist;
}
TRACK(TrackBak,"GrpThawPacket\n");
return (STAT);
}
boolean Grp_DefrostPacket
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status)
{
dbheader    *CoreDb   = NullPtr;
grpheader   *GrpHdr   = NullPtr;
if (TmGetCoreDb   (Anchor,                      McStat,            &CoreDb))
if (MemGetAddr    (CoreDb->GrpHdrDir, GrpNum,   McStat,(addrtype *)&GrpHdr))
{
if (GrpHdr)
GrpHdr->FreezePacket  = False;
else
*Status  = Grp_PacketNotLoaded;
} else {
*Status = Grp_GrpHdrNotExist;
}
TRACK(TrackBak,"GrpDefrostPacket\n");
return (STAT);
}
boolean Grp_FreePacket   (tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status)
{
dbheader    *CoreDb   = NullPtr;
grpheader   *GrpHdr   = NullPtr;
indextype    RgnCount = 0;
int          i        = 0;
numtype     *RgnDir   = NullPtr;
vbntype     *SwapDir  = NullPtr;
if (TmGetCoreDb   (Anchor,                      McStat,            &CoreDb))
if (MemGetAddr    (CoreDb->GrpHdrDir, GrpNum,   McStat,(addrtype *)&GrpHdr))
{
if (GrpHdr)
{
if (MemGetStackPtr  (GrpHdr->RegionChunkDir,     McStat,   &RgnCount))
if (MemGetChunkAddr (GrpHdr->RegionChunkDir,     McStat,
(addrtype *)&RgnDir))
if (MemGetChunkAddr (GrpHdr->RegionSwapDir,      McStat,
(addrtype *)&SwapDir))
for (i = -1; ++i < RgnCount && Normal(*Status); )
{
if (RgnDir[i])
MemFreeChunk   (&RgnDir[i],         McStat);
if (Normal(*Status))
if (SwapDir[i])
MemFreeXmemBlk (McStat,                    &SwapDir[i]);
}
if (Normal(*Status))
if (MemFreeChunk  (&GrpHdr->RegionChunkDir,    McStat))
if (MemFreeChunk  (&GrpHdr->RegionSwapDir,     McStat))
if (MemFreeChunk  (&GrpHdr->DirtyRegionDir,    McStat))
if (MemFreeChunk  (&GrpHdr->RegionFreezeDir,   McStat))
if (MemFreeChunk  (&GrpHdr->RgnBuffNumDir,     McStat))
if (MemFreeChunk  (&GrpHdr->RgnAccessedDir,    McStat))
if (MemFreeChunk  (&GrpHdr->RegionVbnDir,      McStat))
if (MemFreeChunk  (&GrpHdr->ExEntryTbl,        McStat))
if (MemFreeChunk  (&GrpHdr->BuffRgnsDir,       McStat))
if (MemFreeChunk  (&GrpHdr->BuffNodesDir,      McStat))
CoreFreeCoreSpace
((addrtype *)&GrpHdr, sizeof(grpheader), McStat);
} else
*Status  = Grp_PacketNotLoaded;
} else {
*Status = Grp_GrpHdrNotExist;
}
TRACK(TrackBak,"GrpFreePacket\n");
return (STAT);
}
boolean Grp_CommitPacket (tokentype    *Anchor,    numtype       GrpNum,
boolean       Relaese,   ft F,lt Z,zz *Status)
{
dbheader    *CoreDb   = NullPtr;
grpheader   *GrpHdr   = NullPtr;
if (TmGetCoreDb   (Anchor,                      McStat,            &CoreDb))
if (MemGetAddr    (CoreDb->GrpHdrDir, GrpNum,   McStat,(addrtype *)&GrpHdr))
{
}
TRACK(TrackBak,"Grp_CommitPacket\n");
return (STAT);
}
boolean Grp_DeletePacket (tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status)
{
dbheader    *CoreDb   = NullPtr;
grpheader   *GrpHdr   = NullPtr;
numtype      Vbn      = 0;
if (TmGetCoreDb   (Anchor,                      McStat,            &CoreDb))
if (MemGetAddr    (CoreDb->GrpHdrDir, GrpNum,   McStat,(addrtype *)&GrpHdr))
{
if (GrpHdr == NullPtr)
{
if(CoreDb->GrpHdrDirVbn)
if (MemGetVbn       (CoreDb->GrpHdrDirVbn,            GrpNum,
McStat,                         &Vbn))
if (Vbn)
DbmDeleteGrpHdr (Anchor, GrpNum,     McStat);
} else
DbmDeleteGrpHdr     (Anchor, GrpNum,     McStat);
if (Normal(*Status))
GrpFreePacket  (Anchor,  GrpNum,   McStat);
} else {
*Status = Grp_GrpHdrNotExist;
}
TRACK(TrackBak,"GrpDeletePacket\n");
return (STAT);
}
boolean Grp_ShowStats    (tokentype    *Token,    numtype       GrpNum,
ft F,lt Z,zz *Status)
{
grpheader     *GrpHdr          = NullPtr;
if (CoreDbs[Token->DbId]->GrpCount)
{
if (Normal(*Status))
if (GrpGetPacket (Token, GrpNum,  McStat, &GrpHdr))
Grp_DumpStruct (Token,  GrpNum, McStat);
}
TRACK(TrackBak,"GrpShowStats\n");
return (STAT);
}
boolean Grp_DumpStruct   (tokentype    *Token,    numtype       GrpNum,
ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"Grp_DumpStruct\n");
return (STAT);
}
boolean Grp_DumpEntrys   (tokentype    *Token,     numtype       GrpNum,
indextype     Low,       indextype     High,
indextype     Limit,     dumpentryptr  DumpEntryPtr,
ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"Grp_DumpEntrys\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\grp2.c*/

#define  GRP2_C
#define  GRP_C
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#define MemPutHandle          Mem_PutWord
#define MemGetHandle          Mem_GetWord
#define MemPushLocalGrpNum    Mem_PushWord
#define MemPutLocalGrpNum     Mem_PutWord
#define MemGetLocalGrpNum     Mem_GetWord
#define MemPushEntryIndex     Mem_PushWord
#define MemPutEntryIndex      Mem_PutWord
#define MemGetEntryIndex      Mem_GetWord
#define MemPushEntryAddr      Mem_PushAddr
#define MemPutEntryAddr       Mem_PutAddr
#define MemGetEntryAddr       Mem_GetAddr
#define MemGetEntry           Mem_GetAddr
#define MemPutGrpNum          Mem_PutWord
#define MemGetGrpNum          Mem_GetWord
#define MemPushGrpNum         Mem_PushWord
#define MemPushAttrNum        Mem_PushWord
#define MemGetAttrNum         Mem_GetWord
#define MemPutAttrNum         Mem_PutWord
#define MemPushObjHdr         Mem_PushAddr
#define MemPutObjHdr          Mem_PutAddr
#define MemGetObjHdr          Mem_GetAddr
#define MemPushChunkNum       Mem_PushWord
#define MemGetChunkNum        Mem_GetWord
#define MemPutChunkNum        Mem_PutWord
#define MemPushIndex          Mem_PushWord
#define MemGetIndex           Mem_GetWord
#define MemPutIndex           Mem_PutWord
#define MemPopIndex           Mem_PopWord
#define MemPutRegionNum       Mem_PutWord
#define MemGetRegionNum       Mem_GetWord
#define MemPutOffset          Mem_PutWord
#define MemGetOffset          Mem_GetWord
#define MemPushLink           Mem_PushWord
#define MemPutLink            Mem_PutWord
#define MemGetLink            Mem_GetWord
#define MemPushExEntry        Mem_PushWord
#define MemPopExEntry         Mem_PopWord
#define MemGetVbn             Mem_GetWord
#define MemGetChunkNum        Mem_GetWord
#define MemGetSize            Mem_GetWord
#define MemPushSize           Mem_PushWord
boolean Grp_EntryCount   (tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status,    indextype    *Count)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
if (DeBug || GrpBug || DbmBug)
TraceMsg (0, "   GrpEntryCount::  = *Count\n");
if (TmGetCoreDb   (Anchor,          McStat, &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == 0)
{
GrpGetPacket   (Anchor,  GrpNum, McStat, &GrpHdr);
}
if (Normal(*Status))
if (GrpHdr != NullPtr)
*Count    = GrpHdr->EntryCount;
if (DeBug || GrpBug || DbmBug)
TraceMsg (0, "   Grp_EntryCount::  = *Count\n");
TRACK(TrackBak,"Grp_EntryCount\n");
return(STAT);
}
boolean Grp_CreateEntry  (tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status,    indextype    *Index)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
numtype         Chunk        = 0;
addrtype        ChunkAddr    = NullPtr;
indextype       LocalIndex   = 0;
indextype       RgnIndex     = 0;
boolean         ExEntry      = False;
numtype         BuffIndex    = 0;
if (DeBug || GrpBug || DbmBug)
TraceMsg (0, "   GrpNewEntry::\n");
if (TmGetCoreDb   (Anchor,          McStat, &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == 0)
GrpGetPacket  (Anchor,  GrpNum, McStat, &GrpHdr);
if (Normal(*Status))
if (GrpHdr->ExEntryCount)
{
ExEntry      = True;
if (MemPopIndex  (GrpHdr->ExEntryTbl,
McStat,    Index,  &GrpHdr->ExEntryCount))
if (*Index < GrpHdr->BaseIndex)
{
RgnIndex  = 0;
Chunk              = GrpHdr->BaseRegion;
MemGetChunkAddr    (Chunk,       McStat,    &ChunkAddr);
} else {
RgnIndex  = (*Index - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnIndex++;
GrpGetRegion       (CoreDb,      GrpHdr,     RgnIndex,
McStat,     &Chunk,     &ChunkAddr);
}
--GrpHdr->RgnStats[RgnIndex];
} else if (GrpHdr->EntryCount < GrpHdr->BaseIndex) {
*Index                   = GrpHdr->EntryCount++;
RgnIndex                = 0;
if (*Index             == 0
&&  GrpHdr->BaseRegion == 0)
{
GrpNewRegion (CoreDb,  GrpHdr, *Index, RgnIndex,
McStat, &Chunk,  &ChunkAddr);
GrpHdr->BaseRegion = Chunk;
} else {
Chunk              = GrpHdr->BaseRegion;
MemGetChunkAddr       (Chunk,       McStat,    &ChunkAddr);
}
} else {
*Index      =  GrpHdr->EntryCount++;
RgnIndex   = (*Index  - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnIndex++;
LocalIndex = (*Index  - GrpHdr->BaseIndex) % GrpHdr->RegionEntrys;
if (LocalIndex == 0)
{
GrpNewRegion   (CoreDb,   GrpHdr,  *Index,    RgnIndex,
McStat,  &Chunk,   &ChunkAddr);
} else {
if (MemGetChunkNum   (GrpHdr->RegionChunkDir,  RgnIndex,
McStat,                 &Chunk))
if (Chunk  == 0)
GrpGetRegion     (CoreDb,      GrpHdr,     RgnIndex,
McStat,     &Chunk,     &ChunkAddr);
else
MemGetChunkAddr  (Chunk,  McStat,         &ChunkAddr);
if (Normal(*Status))
{
BuffIndex                        = GrpHdr->RgnBuffNums[RgnIndex];
GrpHdr->RgnBuffNodes[BuffIndex]  = 1;
}
}
}
if (Normal(*Status))
if (RgnIndex)
LocalIndex = (*Index - GrpHdr->BaseIndex) % GrpHdr->RegionEntrys;
else
LocalIndex = *Index;
if (Normal(*Status))
if (!ExEntry)
MemPutStackPtr   (Chunk,  LocalIndex+1,    McStat);
if (DbmBug)
MemBug = False;
if (Normal(*Status))
MemPutBit        (GrpHdr->DirtyRegionDir,  RgnIndex, 1, McStat);
if (DbmBug)
MemBug = False;
TRACK(TrackBak,"Grp_CreateEntry\n");
return(STAT);
}
boolean Grp_NewEntry     (tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status,    indextype    *Index,
addrtype      Entry)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
numtype         Chunk        = 0;
addrtype        ChunkAddr    = NullPtr;
indextype       LocalIndex   = 0;
indextype       RgnIndex     = 0;
boolean         ExEntry      = False;
numtype         BuffIndex    = 0;
if (DeBug || GrpBug || DbmBug)
TraceMsg (0, "   GrpNewEntry::\n");
if (TmGetCoreDb   (Anchor,          McStat, &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == 0)
GrpGetPacket  (Anchor,  GrpNum, McStat, &GrpHdr);
if (Normal(*Status))
if (GrpHdr->ExEntryCount)
{
ExEntry      = True;
if (MemPopIndex  (GrpHdr->ExEntryTbl,
McStat,    Index,  &GrpHdr->ExEntryCount))
if (*Index < GrpHdr->BaseIndex)
{
RgnIndex  = 0;
Chunk              = GrpHdr->BaseRegion;
MemGetChunkAddr    (Chunk,       McStat,    &ChunkAddr);
} else {
RgnIndex  = (*Index - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnIndex++;
GrpGetRegion       (CoreDb,      GrpHdr,     RgnIndex,
McStat,     &Chunk,     &ChunkAddr);
}
--GrpHdr->RgnStats[RgnIndex];
} else if (GrpHdr->EntryCount < GrpHdr->BaseIndex) {
*Index        = GrpHdr->EntryCount++;
RgnIndex     = 0;
if (*Index             == 0
&&  GrpHdr->BaseRegion == 0)
{
GrpNewRegion (CoreDb,  GrpHdr, *Index, RgnIndex,
McStat, &Chunk,  &ChunkAddr);
GrpHdr->BaseRegion = Chunk;
} else {
Chunk              = GrpHdr->BaseRegion;
MemGetChunkAddr       (Chunk,       McStat,    &ChunkAddr);
}
} else {
*Index      =  GrpHdr->EntryCount++;
RgnIndex   = (*Index  - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnIndex++;
LocalIndex = (*Index  - GrpHdr->BaseIndex) % GrpHdr->RegionEntrys;
if (LocalIndex == 0)
{
GrpNewRegion   (CoreDb,   GrpHdr,  *Index,    RgnIndex,
McStat,  &Chunk,   &ChunkAddr);
} else {
if (MemGetChunkNum   (GrpHdr->RegionChunkDir,  RgnIndex,
McStat,                 &Chunk))
if (Chunk  == 0)
GrpGetRegion     (CoreDb,      GrpHdr,     RgnIndex,
McStat,     &Chunk,     &ChunkAddr);
else
MemGetChunkAddr  (Chunk,  McStat,         &ChunkAddr);
if (Normal(*Status))
{
BuffIndex                        = GrpHdr->RgnBuffNums[RgnIndex];
GrpHdr->RgnBuffNodes[BuffIndex]  = 1;
}
}
}
if (Normal(*Status))
if (RgnIndex)
LocalIndex = (*Index - GrpHdr->BaseIndex) % GrpHdr->RegionEntrys;
else
LocalIndex = *Index;
if (Normal(*Status))
if (!ExEntry)
MemPutStackPtr   (Chunk,  LocalIndex+1,    McStat);
if (DbmBug)
MemBug = False;
if (Normal(*Status))
if (MemPutBit        (GrpHdr->DirtyRegionDir,  RgnIndex, 1, McStat))
MemGetSomeBytes  (Chunk,  LocalIndex,      GrpHdr->EntrySize,
McStat,                  Entry);
if (DbmBug)
MemBug = False;
TRACK(TrackBak,"GrpNewEntry\n");
return(STAT);
}
boolean Grp_PutNewEntry  (tokentype    *Anchor,    numtype       GrpNum,
addrtype      Entry,
ft F,lt Z,zz *Status,    indextype    *Index)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
numtype         Chunk        = 0;
addrtype        ChunkAddr    = NullPtr;
indextype       LocalIndex   = 0;
indextype       RgnIndex     = 0;
boolean         ExEntry      = False;
numtype         BuffIndex    = 0;
vchunktkntype  *VchunkDir    = NullPtr;
handletype     *VhandleDir   = NullPtr;
if (DeBug || GrpBug || DbmBug)
TraceMsg (0, "   GrpPutNewEntry::\n");
if (TmGetCoreDb   (Anchor,          McStat, &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == 0)
GrpGetPacket  (Anchor,  GrpNum, McStat, &GrpHdr);
if (Normal(*Status))
if (GrpHdr->ExEntryCount)
{
ExEntry      = True;
if (MemPopIndex  (GrpHdr->ExEntryTbl,
McStat,    Index,  &GrpHdr->ExEntryCount))
if (*Index < GrpHdr->BaseIndex)
{
RgnIndex  = 0;
Chunk              = GrpHdr->BaseRegion;
MemGetChunkAddr    (Chunk,       McStat,    &ChunkAddr);
} else {
RgnIndex  = (*Index - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnIndex++;
GrpGetRegion       (CoreDb,      GrpHdr,     RgnIndex,
McStat,     &Chunk,     &ChunkAddr);
}
--GrpHdr->RgnStats[RgnIndex];
} else if (GrpHdr->EntryCount < GrpHdr->BaseIndex) {
*Index        = GrpHdr->EntryCount++;
RgnIndex     = 0;
if (*Index             == 0
&&  GrpHdr->BaseRegion == 0)
{
GrpNewRegion (CoreDb,  GrpHdr, *Index, RgnIndex,
McStat, &Chunk,  &ChunkAddr);
GrpHdr->BaseRegion = Chunk;
} else {
Chunk              = GrpHdr->BaseRegion;
if (Chunk == 0)
GrpGetRegion     (CoreDb,     GrpHdr,     RgnIndex,
McStat,    &Chunk,     &ChunkAddr);
else
MemGetChunkAddr  (Chunk,      McStat,    &ChunkAddr);
}
} else {
*Index      =  GrpHdr->EntryCount++;
RgnIndex   = (*Index  - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnIndex++;
LocalIndex = (*Index  - GrpHdr->BaseIndex) % GrpHdr->RegionEntrys;
if (LocalIndex == 0)
{
GrpNewRegion   (CoreDb,   GrpHdr,  *Index,    RgnIndex,
McStat,  &Chunk,   &ChunkAddr);
} else {
if (MemGetChunkNum   (GrpHdr->RegionChunkDir,  RgnIndex,
McStat,                 &Chunk))
if (Chunk == 0)
GrpGetRegion     (CoreDb,     GrpHdr,      RgnIndex,
McStat,    &Chunk,      &ChunkAddr);
else
MemGetChunkAddr  (Chunk,  McStat,         &ChunkAddr);
if (Normal(*Status))
{
BuffIndex                        = GrpHdr->RgnBuffNums[RgnIndex];
GrpHdr->RgnBuffNodes[BuffIndex]  = 1;
}
}
}
if (Normal(*Status))
if (RgnIndex)
LocalIndex = (*Index - GrpHdr->BaseIndex) % GrpHdr->RegionEntrys;
else
LocalIndex = *Index;
if (Normal(*Status))
if (!ExEntry)
MemPutStackPtr   (Chunk,  LocalIndex+1,    McStat);
if (DbmBug)
MemBug = False;
if (Normal(*Status))
if (MemPutBit        (GrpHdr->DirtyRegionDir,  RgnIndex, 1, McStat))
if (GrpHdr->EntrySize        == sizeof (vchunktkntype))
{
VchunkDir               =  (vchunktkntype *)ChunkAddr;
VchunkDir[LocalIndex]   = *(vchunktkntype *)Entry;
} else if (GrpHdr->EntrySize == sizeof (handletype)) {
VhandleDir              =  (handletype *)ChunkAddr;
VhandleDir[LocalIndex]  = *(handletype *)Entry;
} else
MemPutSomeBytes  (Chunk,  LocalIndex,      GrpHdr->EntrySize,
Entry,                   McStat);
if (DbmBug)
MemBug = False;
TRACK(TrackBak,"GrpPutNewEntry\n");
return(STAT);
}
boolean Grp_PutEntry     (tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,     addrtype      Entry,
ft F,lt Z,zz *Status)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
numtype         RgnNum       = 0;
numtype         Chunk        = 0;
addrtype        ChunkAddr    = NullPtr;
indextype       LocalIndex   = 0;
numtype         BuffIndex    = 0;
vchunktkntype  *VchunkDir    = NullPtr;
handletype     *VhandleDir   = NullPtr;
numtype         EntryCount   = 0;
if (TmGetCoreDb      (Anchor, McStat,    &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == NullPtr)
if (GrpGetPacket     (Anchor,  GrpNum, McStat, &GrpHdr))
EntryCount = GrpHdr->EntryCount;
if (Normal(*Status))
if (Index     < GrpHdr->BaseIndex)
{
RgnNum     = 0;
LocalIndex = Index;
if (GrpHdr->BaseRegion == 0)
{
if (GrpHdr->EntryCount == 0)
{
GrpNewRegion     (CoreDb,   GrpHdr,      LocalIndex,  RgnNum,
McStat,               &Chunk,      &ChunkAddr);
} else
GrpGetRegion     (CoreDb,   GrpHdr,      RgnNum,
McStat,  &Chunk,      &ChunkAddr);
GrpHdr->BaseRegion = Chunk;
} else {
Chunk               = GrpHdr->BaseRegion;
MemGetChunkAddr      (Chunk,    McStat,     &ChunkAddr);
}
} else {
RgnNum     = (Index - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnNum++;
LocalIndex = (Index - GrpHdr->BaseIndex)  % GrpHdr->RegionEntrys;
if (Index < GrpHdr->EntryCount)
{
GrpGetRegion     (CoreDb,     GrpHdr,     RgnNum,
McStat,    &Chunk,     &ChunkAddr);
} else if (Index == GrpHdr->EntryCount) {
if (LocalIndex == 0)
{
GrpNewRegion   (CoreDb,   GrpHdr,   Index,    RgnNum,
McStat,  &Chunk,   &ChunkAddr);
} else {
if (MemGetChunkNum (GrpHdr->RegionChunkDir,      RgnNum,
McStat,                     &Chunk))
if (Chunk == 0)
GrpGetRegion    (CoreDb,     GrpHdr,          RgnNum,
McStat,    &Chunk,          &ChunkAddr);
else
MemGetChunkAddr (Chunk,      McStat,         &ChunkAddr);
if (Normal(*Status))
{
BuffIndex                        = GrpHdr->RgnBuffNums[RgnNum];
GrpHdr->RgnBuffNodes[BuffIndex]  = 1;
}
}
} else {
}
}
if (Normal(*Status))
if (Index == GrpHdr->EntryCount)
if (MemPutStackPtr   (Chunk,  LocalIndex+1,    McStat))
{
GrpHdr->EntryCount++;
}
if (Normal(*Status))
if (MemPutBit        (GrpHdr->DirtyRegionDir,     RgnNum, 1, McStat))
if (GrpHdr->EntrySize        == sizeof (vchunktkntype))
{
VchunkDir                =  (vchunktkntype *)ChunkAddr;
VchunkDir[LocalIndex]    = *(vchunktkntype *)Entry;
} else if (GrpHdr->EntrySize == sizeof (handletype)) {
VhandleDir               =  (handletype *)ChunkAddr;
VhandleDir[LocalIndex]   = *(handletype *)Entry;
} else
MemPutSomeBytes  (Chunk,  LocalIndex,      GrpHdr->EntrySize,
Entry,                   McStat);
TRACK(TrackBak,"GrpPutEntry\n");
return (STAT);
}
boolean Grp_GetBaseRegion
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status,    addrtype     *BaseRgn)
{
dbheader    *CoreDb   = NullPtr;
grpheader   *GrpHdr   = NullPtr;
if (TmGetCoreDb   (Anchor,                      McStat,            &CoreDb))
if (MemGetAddr    (CoreDb->GrpHdrDir, GrpNum,   McStat,(addrtype *)&GrpHdr))
{
if (GrpHdr)
if (GrpHdr->BaseRegion)
MemGetChunkAddr    (GrpHdr->BaseRegion,    McStat,     BaseRgn);
else
*Status = Grp_NoBaseRegion;
else
*Status = Grp_GrpHdrNotExist;
}
TRACK(TrackBak,"Grp_GetBaseRegion\n");
return (STAT);
}
boolean GrpGetEntry      (tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,
ft F,lt Z,zz *Status,    addrtype      Entry)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
numtype         RgnNum       = 0;
numtype         Chunk        = 0;
addrtype        ChunkAddr    = NullPtr;
indextype       LocalIndex   = 0;
vchunktkntype  *VchunkDir    = NullPtr;
handletype     *VhandleDir   = NullPtr;
if (TmGetCoreDb      (Anchor, McStat,    &CoreDb))
{
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == 0)
GrpGetPacket  (Anchor,  GrpNum, McStat, &GrpHdr);
} else {
*Status = Grp_NullDb;
}
if (Normal(*Status))
{
if (Index   < GrpHdr->BaseIndex)
{
RgnNum     = 0;
LocalIndex = Index;
if (GrpHdr->BaseRegion == 0)
GrpGetRegion     (CoreDb,     GrpHdr,               0,
McStat,    &GrpHdr->BaseRegion,  &ChunkAddr);
else
MemGetChunkAddr  (GrpHdr->BaseRegion,  McStat,     &ChunkAddr);
Chunk      = GrpHdr->BaseRegion;
} else {
RgnNum     = (Index - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnNum++;
LocalIndex = (Index - GrpHdr->BaseIndex)  % GrpHdr->RegionEntrys;
GrpGetRegion        (CoreDb,     GrpHdr,               RgnNum,
McStat,    &Chunk,               &ChunkAddr);
}
}
if (Normal(*Status))
if (GrpHdr->EntrySize         == sizeof (vchunktkntype))
{
VchunkDir                  =  (vchunktkntype *)ChunkAddr;
*(vchunktkntype *)Entry     = VchunkDir[LocalIndex];
} else if (GrpHdr->EntrySize  == sizeof (handletype)) {
VhandleDir                 =  (handletype *)ChunkAddr;
*(handletype *)Entry        = VhandleDir[LocalIndex];
} else
MemGetSomeBytes  (Chunk,  LocalIndex,      GrpHdr->EntrySize,
McStat,                  Entry);
TRACK(TrackBak,"GrpGetEntry\n");
return (STAT);
}
boolean Grp_GetInLineEntry
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,
ft F,lt Z,zz *Status,    addrtype     *Entry)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
numtype         RgnNum       = 0;
numtype         Chunk        = 0;
addrtype        ChunkAddr    = NullPtr;
indextype       LocalIndex   = 0;
if (TmGetCoreDb      (Anchor, McStat,    &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == 0)
GrpGetPacket  (Anchor,  GrpNum, McStat, &GrpHdr);
if (Normal(*Status))
{
if (Index   < GrpHdr->BaseIndex)
{
RgnNum     = 0;
LocalIndex = Index;
if (GrpHdr->BaseRegion == 0)
GrpGetRegion     (CoreDb,     GrpHdr,               0,
McStat,    &GrpHdr->BaseRegion,  &ChunkAddr);
else
MemGetChunkAddr  (GrpHdr->BaseRegion,  McStat,     &ChunkAddr);
} else {
RgnNum     = (Index - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnNum++;
LocalIndex = (Index - GrpHdr->BaseIndex)  % GrpHdr->RegionEntrys;
GrpGetRegion    (CoreDb,     GrpHdr,               RgnNum,
McStat,    &Chunk,               &ChunkAddr);
}
}
if (Normal(*Status))
*Entry    =  (addrtype )((char *)ChunkAddr
+ (GrpHdr->EntrySize * LocalIndex));
TRACK(TrackBak,"Grp_GetInLineEntry\n");
return (STAT);
}
boolean Grp_GetFrozenEntry
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,
ft F,lt Z,zz *Status,    addrtype     *Entry)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
numtype         RgnNum       = 0;
numtype         Chunk        = 0;
addrtype        ChunkAddr    = NullPtr;
indextype       LocalIndex   = 0;
if (TmGetCoreDb      (Anchor, McStat,    &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == 0)
GrpGetPacket  (Anchor,  GrpNum, McStat, &GrpHdr);
if (Normal(*Status))
{
if (Index   < GrpHdr->BaseIndex)
{
RgnNum     = 0;
LocalIndex = Index;
if (GrpHdr->BaseRegion == 0)
GrpGetRegion     (CoreDb,     GrpHdr,               0,
McStat,    &GrpHdr->BaseRegion,  &ChunkAddr);
else
MemGetChunkAddr  (GrpHdr->BaseRegion,  McStat,     &ChunkAddr);
} else {
RgnNum     = (Index - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnNum++;
LocalIndex = (Index - GrpHdr->BaseIndex)  % GrpHdr->RegionEntrys;
if (GrpGetRegion    (CoreDb,     GrpHdr,               RgnNum,
McStat,    &Chunk,               &ChunkAddr))
++GrpHdr->FrozenRgns[RgnNum];
}
}
if (Normal(*Status))
*Entry    =  (addrtype )((char *)ChunkAddr
+ (GrpHdr->EntrySize * LocalIndex));
TRACK(TrackBak,"Grp_GetFrozenEntry\n");
return (STAT);
}
boolean Grp_FreezeEntry
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,     ft F,lt Z,zz *Status)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
numtype         RgnNum       = 0;
if (TmGetCoreDb      (Anchor, McStat,    &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == 0)
GrpGetPacket  (Anchor,  GrpNum, McStat, &GrpHdr);
if (Normal(*Status))
{
if (Index   < GrpHdr->BaseIndex)
{
RgnNum     = 0;
} else {
RgnNum     = (Index - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnNum++;
++GrpHdr->FrozenRgns[RgnNum];
}
}
TRACK(TrackBak,"Grp_FreezeEntry\n");
return (STAT);
}
boolean Grp_DefrostEntry
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,     ft F,lt Z,zz *Status)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
numtype         RgnNum       = 0;
if (TmGetCoreDb      (Anchor, McStat,    &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == 0)
GrpGetPacket  (Anchor,  GrpNum, McStat, &GrpHdr);
if (Normal(*Status))
{
if (Index   < GrpHdr->BaseIndex)
{
RgnNum     = 0;
} else {
RgnNum     = (Index - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnNum++;
--GrpHdr->FrozenRgns[RgnNum];
}
}
if ((int  )GrpHdr->FrozenRgns[RgnNum] < 0)
*Status  = Grp_PermaFrostReached;
TRACK(TrackBak,"Grp_DefrostEntry\n");
return (STAT);
}
boolean Grp_EntryIsFrosted
(tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,     ft F,lt Z,zz *Status)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
numtype         RgnNum       = 0;
if (TmGetCoreDb      (Anchor, McStat,    &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == 0)
GrpGetPacket  (Anchor,  GrpNum, McStat, &GrpHdr);
if (Normal(*Status))
{
if (Index   < GrpHdr->BaseIndex)
{
RgnNum     = 0;
} else {
RgnNum     = (Index - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnNum++;
}
}
if ((int  )GrpHdr->FrozenRgns[RgnNum] > 0)
return (True);
if (Normal(*Status))
return (False);
TRACK(TrackBak,"Grp_EntryIsFrosted\n");
return (STAT);
}
boolean Grp_FrostStatus
(tokentype    *Anchor,    numtype       GrpNum,
ft F,lt Z,zz *Status)
{
dbheader       *CoreDb       = NullPtr;
grpheader      *GrpHdr       = NullPtr;
numtype         RgnNum       = 0;
boolean         FrostStatus  = True;
if (TmGetCoreDb      (Anchor, McStat,    &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == 0)
GrpGetPacket  (Anchor,  GrpNum, McStat, &GrpHdr);
if (Normal(*Status))
for (RgnNum = 0;
RgnNum < GrpHdr->RegionCount;
++RgnNum)
{
if (GrpHdr->FrozenRgns[RgnNum] > 0)
{
FrostStatus    = False;
}
}
if (Normal(*Status))
return (FrostStatus);
TRACK(TrackBak,"Grp_FrostStatus\n");
return (STAT);
}
boolean Grp_DeleteEntry   (tokentype    *Anchor,    numtype       GrpNum,
indextype     Index,     ft F,lt Z,zz *Status)
{
dbheader       *CoreDb          = NullPtr;
grpheader      *GrpHdr          = NullPtr;
bytetype       *ByteAddr        = NullPtr;
numtype         Region          = 0;
indextype       RgnNum          = 0;
indextype       LocalIndex      = 0;
numtype         RegionEntrys    = 0;
numtype         DeletedEntrys   = 0;
indextype       StackIndex      = 0;
if (TmGetCoreDb       (Anchor,             McStat,       &CoreDb))
if ((GrpHdr = CoreDb->GrpHdrs[GrpNum]) == NullPtr)
GrpGetPacket      (Anchor, GrpNum,     McStat,       &GrpHdr);
if (Normal(*Status))
if (Index     < GrpHdr->BaseIndex)
{
RgnNum     = 0;
LocalIndex = Index;
Region     = GrpHdr->BaseRegion;
MemGetChunkAddr (Region,  McStat, (addrtype *)&ByteAddr);
} else {
RgnNum     = (Index - GrpHdr->BaseIndex) / GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnNum++;
LocalIndex = (Index - GrpHdr->BaseIndex)  % GrpHdr->RegionEntrys;
GrpGetRegion    (CoreDb,     GrpHdr,   RgnNum,
McStat,    &Region,  (addrtype *)&ByteAddr);
}
if (Normal(*Status))
if (MemPutBit       (GrpHdr->DirtyRegionDir,     RgnNum, 1, McStat))
{
ByteAddr      +=  (LocalIndex  *        GrpHdr->EntrySize);
memset            (ByteAddr,   0,       GrpHdr->EntrySize);
DeletedEntrys  = ++GrpHdr->RgnStats[RgnNum];
MemPushExEntry    (GrpHdr->ExEntryTbl,  Index,
McStat,             &StackIndex);
++GrpHdr->ExEntryCount;
}
if (Normal(*Status))
if (RgnNum         ==   GrpHdr->RegionCount - 1)
{
if (MemGetStackPtr    (Region,           McStat, &RegionEntrys))
if (DeletedEntrys     == RegionEntrys)
if (GrpHdr->BaseIndex == 0)
Grp_DeleteRgn      (CoreDb,  GrpHdr,  RgnNum,  Region, McStat);
else if (RgnNum        > 0)
Grp_DeleteRgn      (CoreDb,  GrpHdr,  RgnNum,  Region, McStat);
} else if (GrpHdr->GrpIndexDir       != 0
&&  GrpHdr->RgnStats[RgnNum]  == GrpHdr->RegionEntrys
&&  RgnNum                    != 0)  {
Grp_RgnSwapTopAndPop  (CoreDb,  GrpHdr,  RgnNum,  Region, McStat);
}
TRACK(TrackBak,"Grp_DeleteEntry\n");
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\hm.c*/

#define HM
#ifdef NULL_TRACE_STRS
#define TraceStr4(StrNum)  TraceStr4[0]
static const char   *TraceStr4[1] = {"   ...MEM00... message\n" };
#else
#define TraceStr4(StrNum)  TraceStr4[StrNum]
static const char *TraceStr4[24] =
{
" NEW  Db Header  :: DbPrimal[xx:%4u] @ %x\n",
"    Hm_Push LocalObjNum  for Handle[%u];  = %u\n",
"    Hm_Put LocalObjNum   for Handle[%u];  = %u\n",
"    Hm_Get LocalObjNum   for Handle[%u];  = %u\n",
" HmPutObjNum DbId[%2u] LocalObj[%3u] = %3u\n",
" HmGetObjNum for Token[%2u:%4u] = %3u\n",
"    Hm_Push ObjectAddr for Handle[%u];  = %x\n",
"    Hm_Put ObjectAddr for Handle[%u];  = %x\n",
"    Hm_Get ObjectAddr(<=%5u) for Handle[%u]; = %x\n",
"    Hm_Push ObjectMemLoc for Handle[%u];  = %1u\n",
"    Hm_Put ObjectMemLoc for Handle[%u];  = %1u\n",
"    Hm_Get ObjectMemLoc(<=%5u) for Handle[%u]; = %1u\n",
"    Hm_Push ObjectIndex  for Handle[%u]; = %u\n",
"    Hm_Put ObjectIndex  for Handle[%u]; = %u\n",
"    Hm_Get ObjectIndex  for Handle[%u]; = %u\n",
"    NEW Handle : %d\n",
"  HmPairDbObject (CoreDb @%x, Hndl: %4u, i= %4u, Obj @%x, Stat= %d)\n",
"  HmFetchDbObject (coreDb @%x, Handle=%4u, %2u, %x)\n",
"   HmFetchDbObject BADHandle[%4u] Object @%x ->Handle= %4u; McStat=%d\n",
"  HmClearObject [@%x:%4u]\n",
"  HmInvokeObject [@%x:%4u] to CoreAddr @%x\n",
"  HmPointToFreeStore [@%x:%4u] \n",
"  HmPointToInnerRealm [@%x:%4u] = %2u\n",
"  HmFreeHandle:: [@%x:%4u]\n",
};
#endif

#define MemPutHandle         Mem_PutWord
#define MemGetHandle         Mem_GetWord
#define MemPushLocalObjNum   Mem_PushWord
#define MemPutLocalObjNum    Mem_PutWord
#define MemGetLocalObjNum    Mem_GetWord
#define MemPushObjectIndex   Mem_PushWord
#define MemPutObjectIndex    Mem_PutWord
#define MemGetObjectIndex    Mem_GetWord
#define MemPushObjectAddr    Mem_PushAddr
#define MemPutObjectAddr     Mem_PutAddr
#define MemGetObjectAddr     Mem_GetAddr
#define MemGetObject         Mem_GetAddr
#define MemPutObjNum         Mem_PutWord
#define MemGetObjNum         Mem_GetWord
#define MemPushObjNum        Mem_PushWord
#define MemPushChunkNum      Mem_PushWord
#define MemGetChunkNum       Mem_GetWord
#define MemPutChunkNum       Mem_PutWord




void    Hm_SetDRIswi      (boolean       Dri_Env)
{
DRI_Env = Dri_Env;
return;
}
boolean HmDRIswi         (void)
{
return (DRI_Env);
}
void    HmSetDefaults    (indextype     EnvObjs,   indextype     EnvAttrs,
indextype     AllocObjs, indextype     ExtendObjs,
indextype     AllocAttrs,indextype     ExtendAttrs,
indextype     AllocHndls,indextype     ExtendHndls,
indextype     AllocVchunks,indextype   ExtendVchunks,
indextype     AllocGrps, indextype     ExtendGrps,
indextype     AllocTexts,indextype     ExtendTexts,
indextype     AllocXblks,indextype     ExtendXblks)
{
HM_EnvObjs          = EnvObjs;
HM_EnvAttrs         = EnvAttrs;
HM_AllocDbObjs      = AllocObjs;
HM_ExtendDbObjs     = ExtendObjs;
HM_AllocDbAttrs     = AllocAttrs;
HM_ExtendDbAttrs    = ExtendAttrs;
HM_AllocHandles     = AllocHndls;
HM_ExtendHandles    = ExtendHndls;
HM_AllocVchunks     = AllocVchunks;
HM_ExtendVchunks    = ExtendVchunks;
HM_AllocGrps        = AllocGrps;
HM_ExtendGrps       = ExtendGrps;
HM_AllocTxtTkns     = AllocTexts;
HM_ExtendTxtTkns    = ExtendTexts;
HM_AllocDbXmemBlks  = AllocXblks;
HM_ExtendDbXmemBlks = ExtendXblks;
return;
}
void    HmGetDefaults    (indextype    *EnvObjs,   indextype    *EnvAttrs,
indextype    *AllocObjs, indextype    *ExtendObjs,
indextype    *AllocAttrs,indextype    *ExtendAttrs,
indextype    *AllocHndls,indextype    *ExtendHndls,
indextype    *AllocVchunks,indextype  *ExtendVchunks,
indextype    *AllocGrps, indextype    *ExtendGrps,
indextype    *AllocTexts,indextype    *ExtendTexts,
indextype    *AllocXblks,indextype    *ExtendXblks)
{
*EnvObjs            =  HM_EnvObjs;
*EnvAttrs           =  HM_EnvAttrs;
*AllocObjs          =  HM_AllocDbObjs;
*ExtendObjs         =  HM_ExtendDbObjs;
*AllocAttrs         =  HM_AllocDbAttrs;
*ExtendAttrs        =  HM_ExtendDbAttrs;
*AllocHndls         =  Alloc_Handles;
*ExtendHndls        =  Extend_Handles;
*AllocVchunks       =  Alloc_Vchunks;
*ExtendVchunks      =  Extend_Vchunks;
*AllocGrps          =  HM_AllocGrps;
*ExtendGrps         =  HM_ExtendGrps;
*AllocTexts         =  HM_AllocTxtTkns;
*ExtendTexts        =  HM_ExtendTxtTkns;
*AllocXblks         =  DbXmemBlocks_AllocQty;
*ExtendXblks        =  DbXmemBlocks_ExtendQty;
return;
}
boolean HmMakeDbHdr      (indextype     EnvObjs,   indextype     EnvAttrs,
idtype        CoreDbId,
ft F,lt Z,zz *Status,    dbheader    **CoreDb)
{
handletype    HandleToVoid = 0;
dbheader     *EnvDb        = NullPtr;
indextype     EnvObjs0     = 0;
indextype     EnvAttrs0    = 0;
indextype     AllocObjs    = 0;
indextype     ExtendObjs   = 0;
indextype     AllocAttrs   = 0;
indextype     ExtendAttrs  = 0;
indextype     AllocHndls   = 0;
indextype     ExtendHndls  = 0;
indextype     AllocVchunks = 0;
indextype     ExtendVchunks= 0;
indextype     AllocGrps    = 0;
indextype     ExtendGrps   = 0;
indextype     AllocTexts   = 0;
indextype     ExtendTexts  = 0;
indextype     AllocXblks   = 0;
indextype     ExtendXblks  = 0;
HmGetDefaults (&EnvObjs0,      &EnvAttrs0,     &AllocObjs,    &ExtendObjs,
&AllocAttrs,    &ExtendAttrs,   &AllocHndls,   &ExtendHndls,
&AllocVchunks,  &ExtendVchunks, &AllocGrps,    &ExtendGrps,
&AllocTexts,    &ExtendTexts,   &AllocXblks,   &ExtendXblks);
if (CoreMoreCore (sizeof(dbheader),    McStat,         (addrtype *)&EnvDb))
if (AllocGrps)
if (MemMakeChunk   (sizeof(addrtype),  AllocGrps,       ExtendGrps,
CoreDbId,          McStat,         &(EnvDb->GrpHdrDir)))
if (MemPutStackPtr (EnvDb->GrpHdrDir,  1,               McStat))
if (MemGetChunkAddr(EnvDb->GrpHdrDir,  McStat, (addrtype *)&EnvDb->GrpHdrs))
if (MemMakeChunk   (sizeof(vbntype),   AllocGrps,       ExtendGrps,
CoreDbId,          McStat,         &(EnvDb->GrpVbnDir)))
MemPutStackPtr (EnvDb->GrpVbnDir,  1,               McStat);
#ifdef   __FREEZE_VCHUNKS__
if (Normal(*Status))
if (MemMakeChunk   (sizeof(vbntype),   AllocVchunks,    ExtendVchunks,
CoreDbId,          McStat,   &(EnvDb->VbnDeleteDir)))
MemPutStackPtr (EnvDb->VbnDeleteDir,  0,            McStat);
#endif
if (AllocHndls)
if (Normal(*Status))
if (MemMakeChunk   (sizeof(chunkindex),AllocHndls,      ExtendHndls,
CoreDbId,          McStat,     &(EnvDb->ObjectIndexDir)))
if (MemPutStackPtr (EnvDb->ObjectIndexDir,  (indextype )1,    McStat))
if (MemMakeChunk   (sizeof(addr),      AllocHndls,      ExtendHndls,
CoreDbId,          McStat,      &(EnvDb->ObjectAddrDir)))
if (MemPutStackPtr (EnvDb->ObjectAddrDir,  (indextype )1,McStat))
if (MemNewBitChunk (AllocHndls,        CoreDbId,
McStat,                       &(EnvDb->ObjectMemLocDir)))
if (MemMakeChunk   (sizeof(objnum),    AllocHndls,      ExtendHndls,
CoreDbId,          McStat,     &(EnvDb->LocalObjNumDir)))
if (MemPutStackPtr (EnvDb->LocalObjNumDir,  (indextype )1,   McStat))
if (CoreDbId > WenvId)
if (MemMakeChunk   (sizeof(shorttype), AllocHndls,      ExtendHndls,
CoreDbId,          McStat,    &(EnvDb->ObjectMemRefDir)))
MemPutStackPtr (EnvDb->ObjectMemRefDir,  1,         McStat);
if (EnvObjs)
if (Normal(*Status))
if (MemMakeChunk   (sizeof(localobjnum),EnvObjs+1,      EnvObjs/2,
CoreDbId,          McStat,     &(EnvDb->LocalObjNumMap)))
if (MemMakeChunk   (sizeof(handletype),EnvObjs+1,       EnvObjs/2,
CoreDbId,          McStat,     &(EnvDb->ObjHandleDir)))
if (MemPutStackPtr (EnvDb->LocalObjNumMap,
(EnvDb->LastEnvObjCount=EnvObjs), McStat))
if (MemPutStackPtr (EnvDb->ObjHandleDir,
EnvDb->LastEnvObjCount,             McStat))
MemPutObjNum   (EnvDb->LocalObjNumMap, 0,  0,       McStat);
if (AllocObjs)
if (Normal(*Status))
if (MemMakeChunk   (sizeof(objnum),    AllocObjs,       ExtendObjs,
CoreDbId,          McStat,        &(EnvDb->ObjNumMap)))
if (MemMakeChunk   (sizeof (longwordtype),AllocObjs,    ExtendObjs,
CoreDbId,          McStat,    &(EnvDb->ObjTimeStampDir)))
if (MemMakeChunk   (sizeof(addrtype),  AllocObjs,       ExtendObjs,
CoreDbId,          McStat,         &(EnvDb->ObjHdrDir)))
if (MemMakeChunk   (sizeof(vbntype),   AllocObjs,       ExtendObjs,
CoreDbId,          McStat,         &(EnvDb->ObjVbnDir)))
if (DRI_Env)
if (MemPutStackPtr (EnvDb->ObjNumMap,  1,               McStat))
if (MemPutStackPtr (EnvDb->ObjHdrDir,  1,               McStat))
if (MemPutStackPtr (EnvDb->ObjVbnDir,  1,               McStat))
MemPutStackPtr (EnvDb->ObjTimeStampDir, 1,          McStat);
if (!DRI_Env)
if (Normal(*Status))
if (Build_Env)
MemPutStackPtr (EnvDb->ObjTimeStampDir,
EnvDb->LastEnvObjCount,             McStat);
if (DeBug)
if (Normal(*Status))
if (EnvDb->LocalObjNumMap)
DumpChunkChunk (2, EnvDb->LocalObjNumMap);
if (EnvAttrs)
if (Normal(*Status))
if (MemMakeChunk   (sizeof(localattrnum), EnvAttrs+1,      EnvAttrs / 2,
CoreDbId,             McStat, &(EnvDb->LocalAttrNumMap)))
if (MemMakeChunk   (sizeof(handletype),   EnvAttrs+1,      EnvAttrs / 2,
CoreDbId,             McStat,   &(EnvDb->AttrHandleDir)))
if (MemPutStackPtr (EnvDb->LocalAttrNumMap,
(EnvDb->LastEnvAttrCount= AllocAttrs),McStat))
MemPutStackPtr (EnvDb->AttrHandleDir,    AllocAttrs, McStat);
if (AllocAttrs)
if (Normal(*Status))
if (MemMakeChunk   (sizeof(localattrnum), AllocAttrs+1,  AllocAttrs / 2,
CoreDbId,             McStat,      &(EnvDb->AttrNumMap)))
if (MemMakeChunk   (sizeof(typesize),     AllocAttrs+1,  AllocAttrs / 2,
CoreDbId,             McStat,&(EnvDb->LocalAttrSizeTbl)))
if (MemPutStackPtr (EnvDb->AttrNumMap,       1,          McStat))
MemPutStackPtr (EnvDb->LocalAttrSizeTbl, 1,          McStat);
if (AllocTexts)
if (Normal(*Status))
if (MemMakeChunk   (sizeof(texttkntype),  AllocTexts,    ExtendTexts,
CoreDbId,             McStat,  &(EnvDb->TextTokenDir)))
if (MemPutStackPtr (EnvDb->TextTokenDir,  1, McStat))
MemMakeChunk   (sizeof(chunkindex),   ExtendTexts,   ExtendTexts,
CoreDbId,             McStat,  &(EnvDb->FreeTxtTknStack));
if (Normal(*Status))
{
if (MemMakeChunk   (sizeof(indextype),        DbXmemBlocks_AllocQty,
DbXmemBlocks_ExtendQty,   CoreDbId,
McStat,                  &(EnvDb->BlkHdr.BlkDirChunk)))
if (MemMakeChunk   (sizeof(blktkntype),       DbXmemBlocks_AllocQty,
DbXmemBlocks_ExtendQty,   CoreDbId,
McStat,                  &(EnvDb->BlkHdr.BlkTknChunk)))
if (MemMakeChunk   (sizeof(bytessize ),       DbXmemBlocks_AllocQty,
DbXmemBlocks_ExtendQty,   CoreDbId,
McStat,                  &(EnvDb->BlkHdr.BlkSizeChunk)))
if (MemPutStackPtr (EnvDb->BlkHdr.BlkDirChunk,       1,      McStat))
if (MemPutStackPtr (EnvDb->BlkHdr.BlkTknChunk,       1,      McStat))
if (MemPutStackPtr (EnvDb->BlkHdr.BlkSizeChunk,      1,      McStat))
{
EnvDb->BlkHdr.DbId      = CoreDbId;
EnvDb->BlkHdr.EofMark   = 0;
EnvDb->BlkHdr.BlkFile   = NullPtr;
EnvDb->SchemaHndl       = NullHandle;
if (DeBug)
{
DumpChunkChunk (0,   EnvDb->BlkHdr.BlkDirChunk);
DumpChunkChunk (0,   EnvDb->BlkHdr.BlkTknChunk);
DumpChunkChunk (0,   EnvDb->BlkHdr.BlkSizeChunk);
}
}
}
if (Normal(*Status))
{
VoidHandle            = HandleToVoid++;
EnvDb->NextHandle     = HandleToVoid;
if (CoreDbId          > WenvId)
EnvDb->DiskCache   = True;
else
EnvDb->DiskCache   = False;
EnvDb->GrpCount       = 0;
EnvDb->GrpHdrDirVbn   = 0;
EnvDb->HeadFreeGrps   = 0;
EnvDb->VchunkGrpNum   = 0;
EnvDb->VchunkGrpHdr   = NullPtr;
EnvDb->VchunkBaseIndex= 1;
EnvDb->HandleCount    = HandleToVoid;
EnvDb->HandleBaseIndex= Alloc_Handles;
EnvDb->LocalAttrCount = 0;
EnvDb->StackHeadDir   = 0;
EnvDb->StackNames     = 0;
EnvDb->ListHeadDir    = 0;
EnvDb->ListNames      = 0;
EnvDb->TblHeadDir     = 0;
EnvDb->TblNames       = 0;
EnvDb->TreeHeadDir    = 0;
EnvDb->TreeNames      = 0;
EnvDb->lKeyHeadDir    = 0;
EnvDb->lKeyNames      = 0;
EnvDb->MtrxHeadDir    = 0;
EnvDb->MtrxNames      = 0;
EnvDb->PrimalHdr      = NullPtr;
EnvDb->PrimalHdrSize  = 0;
EnvDb->PrimalHdrVbn   = 0;
*CoreDb = EnvDb;
}
TRACK(TrackBak,"HmMakeDbHdr\n");
return (STAT);
}
#ifndef __MACROIZE_HM__
boolean    HmPushLocalObjNum  (dbheader     *CoreDb, localnumtype LocalObj,
ft F,lt Z,zz *Status, indextype   *StackPtr)
{
MemPushLocalObjNum (CoreDb->LocalObjNumDir,        LocalObj,
McStat,                        StackPtr);
TRACK(TrackBak,"HmPushLocalObjNum\n");
return (STAT);
}
boolean    HmPutLocalObjNum  (dbheader    *CoreDb,  handletype    Handle,
localnumtype  LocalObj, ft F,lt Z,zz *Status)
{
MemPutLocalObjNum (CoreDb->LocalObjNumDir,        Handle,
LocalObj,                      McStat);
TRACK(TrackBak,"HmPutLocalObjNum\n");
return (STAT);
}
boolean    HmGetLocalObjNum  (dbheader    *CoreDb,  handletype    Handle,
ft F,lt Z,zz *Status,  localnumtype *LocalObj)
{
MemGetLocalObjNum (CoreDb->LocalObjNumDir,        Handle,
McStat,                        LocalObj);
TRACK(TrackBak,"HmGetLocalObjNum\n");
return (STAT);
}
boolean    HmPutObjNum   (dbheader     *CoreDb,    indextype     LocalObjNum,
numtype       EnvObjNum, ft F,lt Z,zz *Status)
{
MemPutObjNum     (CoreDb->ObjNumMap, LocalObjNum,  EnvObjNum, McStat);
TRACK(TrackBak,"HmPutObjNum\n");
return (STAT);
}
boolean    HmPushObjectAddr
(dbheader     *CoreDb, addrtype     ObjectAddr,
ft F,lt Z,zz *Status, indextype   *StackPtr)
{
MemPushObjectAddr    (CoreDb->ObjectAddrDir,        ObjectAddr,
McStat,                       StackPtr);
TRACK(TrackBak,"HmPushObjectAddr\n");
return (STAT);
}
boolean    HmPutObjectAddr  (dbheader  *CoreDb,      handletype Handle,
addrtype   ObjectAddr, ft F,lt Z,zz *Status)
{
MemPutObjectAddr (CoreDb->ObjectAddrDir,        Handle,
ObjectAddr,                   McStat);
TRACK(TrackBak,"HmPutObjectAddr\n");
return (STAT);
}
boolean    HmGetObjectAddr  (dbheader  *CoreDb,  handletype   Handle,
ft F,lt Z,zz *Status,  addrtype    *ObjectAddr)
{
MemGetObjectAddr (CoreDb->ObjectAddrDir,        Handle,
McStat,                      ObjectAddr);
TRACK(TrackBak,"HmGetObjectAddr\n");
return (STAT);
}
boolean    HmPushObjectMemLoc  (dbheader  *CoreDb, numtype      MemLoc,
ft F,lt Z,zz *Status, indextype   *StackPtr)
{
if (MemLoc)
MemLoc = 1;
MemPushBit         (CoreDb->ObjectMemLocDir,   MemLoc,
McStat,                    StackPtr);
TRACK(TrackBak,"HmPushObjectMemLoc\n");
return (STAT);
}
boolean    HmPutObjectMemLoc  (dbheader  *CoreDb,      handletype Handle,
numtype    MemLoc, ft F,lt Z,zz *Status)
{
if (MemLoc)
MemLoc = 1;
MemPutBit        (CoreDb->ObjectMemLocDir,  Handle,
MemLoc,                   McStat);
TRACK(TrackBak,"HmPutObjectMemLoc\n");
return (STAT);
}
boolean    HmGetObjectMemLoc  (dbheader     *CoreDb,  handletype   Handle,
ft F,lt Z,zz *Status,  numtype     *MemLoc)
{
if (Handle == 0)
*Status   = Hm_BadHandle;
else
MemGetBit         (CoreDb->ObjectMemLocDir,   Handle,
McStat,                    MemLoc);
TRACK(TrackBak,"HmGetObjectMemLoc\n");
return (STAT);
}
boolean    HmPushObjectMemRef  (dbheader     *CoreDb, shorttype    MemRef,
ft F,lt Z,zz *Status, indextype   *StackPtr)
{
MemPushShort          (CoreDb->ObjectMemRefDir,        MemRef,
McStat,                         StackPtr);
TRACK(TrackBak,"HmPushObjectMemRef\n");
return (STAT);
}
boolean    HmPutObjectMemRef  (dbheader  *CoreDb,   handletype    Handle,
shorttype  MemRef,   ft F,lt Z,zz *Status)
{
if (Handle == 0)
*Status   = Hm_BadHandle;
else
MemPutShort   (CoreDb->ObjectMemRefDir,  Handle,
MemRef,                   McStat);
TRACK(TrackBak,"HmPutObjectMemRef\n");
return (STAT);
}
boolean    HmGetObjectMemRef  (dbheader     *CoreDb,  handletype   Handle,
ft F,lt Z,zz *Status,  shorttype   *MemRef)
{
if (Handle == 0)
*Status   = Hm_BadHandle;
else
MemGetShort       (CoreDb->ObjectMemRefDir,   Handle,
McStat,                    MemRef);
TRACK(TrackBak,"HmGetObjectMemRef\n");
return (STAT);
}
boolean    HmPushObjectIndex  (dbheader  *CoreDb, indextype   ObjectIndex,
ft F,lt Z,zz *Status, indextype   *StackPtr)
{
MemPushObjectIndex (CoreDb->ObjectIndexDir,        ObjectIndex,
McStat,                        StackPtr);
TRACK(TrackBak,"HmPushObjectIndex\n");
return (STAT);
}
boolean    HmPutObjectIndex (dbheader   *CoreDb,      handletype Handle,
indextype   ObjectIndex,ft F,lt Z,zz *Status)
{
MemPutObjectIndex (CoreDb->ObjectIndexDir,        Handle,
ObjectIndex,                   McStat);
TRACK(TrackBak,"HmPutObjectIndex\n");
return (STAT);
}
boolean    HmGetObjectIndex (dbheader  *CoreDb,  handletype   Handle,
ft F,lt Z,zz *Status,  indextype   *ObjectIndex)
{
MemGetObjectIndex (CoreDb->ObjectIndexDir,      Handle,
McStat,                      ObjectIndex);
TRACK(TrackBak,"HmGetObjectIndex\n");
return (STAT);
}
boolean HmInvokeObject (dbheader *CoreDb,     handletype   Handle,
addrtype  Object,     ft F,lt Z,zz *Status)
{
HmPutObjectAddr (CoreDb, Handle, Object,  McStat);
TRACK(TrackBak,"HmInvokeObject\n");
return (STAT);
}
boolean HmPointToOuterRegion (dbheader     *CoreDb,     handletype   Handle,
ft F,lt Z,zz *Status)
{
HmPutObjectMemLoc (CoreDb, Handle, 1,  McStat);
TRACK(TrackBak,"HmPointToOuterRegion\n");
return (STAT);
}
#endif
boolean    HmGetObjNum   (dbheader     *CoreDb,  handletype    Handle,
ft F,lt Z,zz *Status,  numtype      *EnvObjNum)
{
numtype  LocalObjNum = 0;
if (HmGetLocalObjNum (CoreDb, Handle,    McStat,      &LocalObjNum))
MemGetObjNum     (CoreDb->ObjNumMap, LocalObjNum,  McStat,  EnvObjNum);
TRACK(TrackBak,"HmGetObjNum\n");
return (STAT);
}
boolean  HmIncrementMemRef  (dbheader     *CoreDb, handletype   Handle,
ft F,lt Z,zz *Status)
{
shorttype   MemRef   = 0;
if (MemGetShort      (CoreDb->ObjectMemRefDir,   Handle,
McStat,                   &MemRef))
MemPutShort      (CoreDb->ObjectMemRefDir,   Handle,    ++MemRef,
McStat);
TRACK(TrackBak,"HmIncrementMemRef\n");
return (STAT);
}
boolean  HmDecrementMemRef  (dbheader     *CoreDb, handletype   Handle,
ft F,lt Z,zz *Status, shorttype   *MemRef)
{
*MemRef   = -1;
if (MemGetShort      (CoreDb->ObjectMemRefDir,   Handle,
McStat,                    MemRef))
{
*MemRef          = *MemRef - (shorttype )1;
MemPutShort      (CoreDb->ObjectMemRefDir,   Handle,    *MemRef,
McStat);
}
TRACK(TrackBak,"HmDecrementMemRef\n");
return (STAT);
}
boolean    HmNewHandle  (dbheader     *CoreDb, localnumtype LocalObj,
ft F,lt Z,zz *Status, handletype  *Handle)
{
indextype    StackPtr = 0;
HmNextFreeHandle    (CoreDb,  McStat,   Handle);
if (*Status == Hm_NoFreeHandles)
{
*Status = Env_Normal;
if (HmPushObjectIndex   (CoreDb,  0,        McStat, &StackPtr))
if (HmPushObjectAddr    (CoreDb,  0,        McStat, &StackPtr))
if (HmPushLocalObjNum   (CoreDb,  LocalObj, McStat, &StackPtr))
if (CoreDb->DbId  > WenvId)
HmPushObjectMemRef  (CoreDb,  0,        McStat, &StackPtr);
if (Normal(*Status))
if ((*Handle = StackPtr) == CoreDb->NextHandle++)
++CoreDb->HandleCount;
else {
*Status = Hm_BadHandlesStack;
}
}
else
{
if (HmPutObjectIndex   (CoreDb, *Handle,  0,        McStat))
if (HmPutObjectAddr    (CoreDb,  *Handle, 0,        McStat))
if (HmPutLocalObjNum   (CoreDb,  *Handle, LocalObj, McStat))
if (CoreDb->DbId  > WenvId)
HmPutObjectMemRef  (CoreDb,  *Handle, 0,        McStat);
}
TRACK(TrackBak,"HmNewHandle\n");
return (STAT);
}
boolean    HmPairDbObject  (dbheader *CoreDb,   handletype Handle,
indextype Index,    addrtype   Object,
ft F,lt Z,zz *Status)
{
if (HmPutObjectIndex (CoreDb,   Handle,  Index,   McStat))
if (HmPutObjectMemLoc(CoreDb,   Handle,  0,       McStat))
if (HmPutObjectAddr  (CoreDb,   Handle,  Object,  McStat))
if (CoreDb->DbId > WenvId)
HmPutObjectMemRef(CoreDb,   Handle,  0,       McStat);
TRACK(TrackBak,"HmPairDbObject\n");
return (STAT);
}
boolean    HmFetchDbObject  (dbheader     *CoreDb,   handletype  Handle,
ft F,lt Z,zz *Status,   addrtype   *Object)
{
*Object    = NullPtr;
if (Normal(*Status))
if (HmGetObjectAddr  (CoreDb,   Handle,  McStat,  Object))
if (*Object == NullPtr)
{
*Status = Hm_ObjectNotPaired;
}
TRACK(TrackBak,"HmFetchDbObject\n");
return (STAT);
}
boolean HmClearObject  (dbheader *CoreDb, handletype  Handle,
ft F,lt Z,zz *Status)
{
if (HmPutObjectAddr   (CoreDb, Handle, (addrtype )NullPtr,  McStat))
if (HmPutObjectMemLoc (CoreDb, Handle, (numtype  )0,        McStat))
if (CoreDb->DbId > WenvId)
HmPutObjectMemRef (CoreDb, Handle, (numtype  )0,        McStat);
TRACK(TrackBak,"HmClearObject\n");
return (STAT);
}
boolean HmPointToInnerRealm (dbheader     *CoreDb,     handletype   Handle,
ft F,lt Z,zz *Status)
{
numtype  MemLoc = 0;
if (HmPutObjectMemLoc (CoreDb, Handle, 0,  McStat))
HmGetObjectMemLoc (CoreDb, Handle, McStat, &MemLoc);
TRACK(TrackBak,"HmPointToInnerRealm\n");
return (STAT);
}
boolean  HmFreeHandle    (dbheader     *CoreDb,    handletype     Handle,
ft F,lt Z,zz *Status)
{
if (CoreDb->FutureHandles   == NullHandle)
HmPutObjectIndex (CoreDb,   Handle,  0,                      McStat);
else
HmPutObjectIndex (CoreDb,   Handle,  CoreDb->FutureHandles,  McStat);
CoreDb->FutureHandles     = Handle;
if (Normal(*Status))
HmPutLocalObjNum (CoreDb,   Handle,  Null_ObjNum,            McStat);
TRACK(TrackBak,"HmFreeHandle\n");
return(STAT);
}
boolean  HmNextFreeHandle  (dbheader     *CoreDb,
ft F,lt Z,zz *Status,    handletype    *Handle)
{
handletype  NxtHndl  = NullHandle;
if (CoreDb->CurrentHandles == NullHandle)
{
*Status = Hm_NoFreeHandles;
} else {
*Handle = CoreDb->CurrentHandles;
if (HmGetObjectIndex (CoreDb,  CoreDb->CurrentHandles, McStat, &NxtHndl))
if (HmPutObjectIndex (CoreDb, *Handle,         0,      McStat))
CoreDb->CurrentHandles  = NxtHndl;
}
TRACK(TrackBak,"HmNextFreeHandle\n");
return(STAT);
}
boolean  HmReclaimHandles  (dbheader     *CoreDb, ft F,lt Z,zz *Status )
{
CoreDb->CurrentHandles = CoreDb->FutureHandles ;
CoreDb->FutureHandles = 0 ;
TRACK(TrackBak,"HmReclaimHandles\n");
return(STAT);
}
boolean    HmDumpDbHdr   (int           TraceSwi,  tokentype     *Anchor,
ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"HmDumpDbHdr\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\iam.c*/

#define   IAM
#ifdef __MACROIZE_HM__
#endif
/* 当前文件是./CINT2000\255.vortex\src\trans.h*/

#ifndef TRANS010_H
#define  TRANS010_H
#ifndef OBJ01_H
#ifndef ENV1_H


#endif
typedef struct IntArray
{
tokentype             VchunkTkn;
indextype             Vsize;
int                  *Varray;
}  intarraytype;
typedef struct IntChunk
{
tokentype              VchunkTkn;
indextype              Vsize;
int                   *Varray;
indextype              VstackPtr;
}  intchunktype;
#endif
#define V(ObjNum)  (ObjNum - Image01_ObjNum)
typedef handletype      addrchunktype;
typedef handletype      mapchunktype;
typedef struct TypeWenv           {
handletype            Handle;
numtype               DbNum;
nametype              Nam[32];
envclass              EnvType;
numtype               DescNum;
idtype                DbCount;
slottoken             PrimalSlotAttr;
handletype            SpclCreateCode;
handletype            SpclDeleteCode;
ownerhandle           OwnerWenvDbs;
addrchunktype         VcodeAddrs;
ownerhandle           OwnerWenvGroups;
ownerhandle           OwnerWenvValues;
mapchunktype          C_ImageMapDir;
} wenvdbprimal;
typedef struct TypeImageMap
{
handletype            DbOffsetsHndl;
handletype            CppOffsetsHndl;
handletype            FieldAttrIdsHndl;
handletype            FieldAttrTypesHndl;
handletype            FieldTypeTypesHndl;
handletype            FieldSizesHndl;
handletype            FieldRefObjNumsHndl;
handletype            ArrayAttrsHndl;
} imagemaptype;
typedef struct TypeMapArrays
{
typesize             *DbOffsets;
typesize             *CppOffsets;
typesize             *FieldSizes;
attrtype             *FieldAttrTypes;
numtype              *FieldAttrIds;
numtype              *RefObjNums;
numtype              *ArrayAttrs;
typetype             *FieldTypeTypes;
} maparraystype;
typedef  maparraystype  maparrays;

static tokentype ImageMapTkn           = Null_Token;
boolean   OverRideInitClass     = False;
numtype   C_ImageMapDir_AttrNum = 0;
boolean   Build_ByCpp           = False;
sizetype  AttrTypeSizes[22]     = {1,          sizeof(tokentype),
1,          sizeof(tokentype),
sizeof(tokentype),  sizeof(handletype),
sizeof(tokentype),  sizeof(handletype),
sizeof(tokentype),  sizeof(tokentype),
sizeof(tokentype),
sizeof(tokentype),  sizeof(tokentype),
sizeof(handletype), sizeof(tokentype),
sizeof(handletype), sizeof(tokentype),
sizeof(handletype), sizeof(handletype),
sizeof(handletype),
sizeof(tokentype),  sizeof(tokentype) };
boolean TransInitMap
(numtype       ClassId,     size_t        ObjSize,
numtype       AplId,       ft F,lt Z,zz *Status);
boolean TransAppendToMap
(numtype       AttrId,      size_t        Offset,
numtype       AplId,       ft F,lt Z,zz *Status);
boolean TransInvokeMap
(numtype       AplId,       ft F,lt Z,zz *Status);
boolean TransBuildMap
(numtype       AplId,       ft F,lt Z,zz *Status);
boolean TransGetMap
(numtype       ObjNum,      numtype       AplId,
ft F,lt Z,zz *Status,      classmaptype *ClassMap);
boolean Trans_DumpMap
(numtype       ObjNum,      numtype       AplId,
ft F,lt Z,zz *Status);
boolean Trans_MapIsActive
(numtype       ObjNum,      ft F,lt Z,zz *Status);
boolean TransCreateMapDirs
(numtype       AplId,       ft F,lt Z,zz *Status,
numtype      *ObjMapDir,   numtype      *ImageMapDir);
boolean TransNewImageMap
(numtype       ObjMapDir,   numtype       ImageMapDir,
numtype       ObjNum,      numtype       FieldCount,
ft F,lt Z,zz *Status,      boolean      *MapExists,
imagemaptype *ImageMap,maparraystype   **FieldsDir);
boolean TransBuildFields
(handletype    MapAttrCount,fieldtoken   *FieldTknMap,
objnumtype   *Vfields,     indextype     FieldCount,
char         *ObjName,
imagemaptype *ImageMap,   maparraystype *ClassMap,
ft F,lt Z,zz *Status);
boolean TransBuildMapField
(objdesctype  *BuildDesc,   typesize     *DbOffsets,
typesize     *FieldSizes,  ft F,lt Z,zz *Status,
indextype    *NumMapFields,indextype  *NumArrayAttrs);
boolean Trans_FetchAttrOffset
(numtype       ObjNum,      numtype       AplId,
numtype       FieldNum,    ft F,lt Z,zz *Status,
sizetype     *CppOffset);
boolean Trans_FetchAttrOffsets
(numtype       ObjNum,      numtype       AplId,
numtype       AttrId,      ft F,lt Z,zz *Status,
sizetype     *DbOffset,    sizetype     *CppOffset);
boolean Trans_FetchFieldOffsets
(tokentype    *Token,       numtype       AplId,
fieldspec     FieldTkns[], numtype       SubLevel,
ft F,lt Z,zz *Status,      sizetype     *FieldSize,
sizetype     *DbOffset,    sizetype     *CppOffset);
boolean Trans_FetchFieldOffset
(tokentype    *Token,       numtype       AplId,
fieldspec     FieldTkns[], numtype       SubLevel,
ft F,lt Z,zz *Status,      sizetype     *FieldSize,
numtype      *AttrId,      attrtype     *AttrType,
numtype      *RefObjNum,   typetype     *UnitType,
sizetype     *DbOffset,    sizetype     *CppOffset,
sizetype     *DbBase,      sizetype     *CppBase);
boolean Trans_FetchObjFieldSpec
(numtype       ObjNum,      numtype       AplId,
fieldspec     FieldTkns[], numtype       SubLevel,
ft F,lt Z,zz *Status,      sizetype     *FieldSize,
numtype      *AttrId,      attrtype     *AttrType,
numtype      *RefObjNum,   typetype     *UnitType,
sizetype     *DbOffset,    sizetype     *CppOffset,
sizetype     *DbBase,      sizetype     *CppBase);
boolean C_GetObjectImage
(tokentype    *Token,    numtype       AplId,
ft F,lt Z,zz *Status,   addrtype     *This);
boolean C_ObjectNewImage
(tokentype    *Token,    numtype       ObjNum,
numtype       AplId,
ft F,lt Z,zz *Status,   addrtype     *This);
boolean C_InvokeAtThis
(tokentype    *Token,    addrtype      This,
numtype       AplId,    ft F,lt Z,zz *Status);
boolean C_FaxToThis    (tokentype    *Token,    addrtype      This,
numtype       AplId,    ft F,lt Z,zz *Status);
boolean C_FaxToClassFields
(idtype        DbId,     numtype       LocalObj,
addrtype      DbObject, addrtype      Object,
numtype       ObjNum,   maparrays    *FieldMap,
numtype       AplId,    ft F,lt Z,zz *Status);
boolean C_MapRefToAddr (idtype        DbId,     numtype       LocalObj,
addrtype      DbObject, addrtype      Object,
numtype       ObjNum,   sizetype      MapSize,
numtype       AplId,    ft F,lt Z,zz *Status);
boolean C_RefToAddr    (tokentype    *Token,    numtype       AplId,
ft F,lt Z,zz *Status,   addrtype     *This);
boolean C_CreateArray  (tokentype    *Token,    numtype       AttrNum,
indextype     UnitCount,sizetype      UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn,addrtype     *Array);
boolean C_CreateSubArray
(tokentype    *Token,
numtype       AttrNum,  indextype    ArrayIndex,
indextype     UnitCount,sizetype     UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn,addrtype    *Array);
boolean C_CreateFieldArray
(tokentype    *Token,     numtype       AplId,
fieldspec    *FieldTkns, numtype       SubLevel,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype     *Varray);
boolean C_CreateFieldSubArray
(tokentype    *Token,     numtype       AplId,
fieldspec    *FieldTkns, numtype       SubLevel,
indextype     ArrayIndex,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype     *Varray);
boolean C_CreateObject (numtype       ObjNum,   numtype       AplId,
ft F,lt Z,zz *Status,   addrtype    *CppObject);
boolean C_ReFaxToDb    (tokentype    *Token,   addrtype      Object,
boolean       Release, boolean       FreeImage,
numtype       AplId,
ft F,lt Z,zz *Status,  bytessize    *ImageSize);
boolean C_GroupArrays  (tokentype    *Token,   addrtype      Object,
boolean       Release, numtype       AplId,
ft F,lt Z,zz *Status);
boolean C_MapRefToDb   (idtype        DbId,    numtype       ClassId,
sizetype      MapSize, addrtype      DbObject,
addrtype      Object,  numtype       AplId,
boolean       Release, ft F,lt Z,zz *Status);
boolean C_RefToTkn     (addrtype      ThisObj, numtype       ObjNum,
numtype       AplId,
ft F,lt Z,zz *Status,  tokentype    *ObjTkn);
boolean C_CommitClass  (tokentype    *Token,   numtype       ClassId,
numtype       AplId,   ft F,lt Z,zz *Status);
boolean C_FreeObject   (tokentype    *Token,
numtype       AplId,   boolean       FreeImage,
ft F,lt Z,zz *Status);
boolean C_FreeEmbeded  (idtype        DbId,    numtype       ObjNum,
sizetype      MapSize, addrtype      DbObject,
addrtype      Object,  numtype       AplId,
ft F,lt Z,zz *Status);
boolean C_FreeClass    (idtype        DbId,    numtype       ClassId,
numtype       AplId,   ft F,lt Z,zz *Status);
boolean C_DeleteObject (tokentype    *Token,   numtype       AplId,
ft F,lt Z,zz *Status);
#endif
/* 当前文件是./CINT2000\255.vortex\src\iam.h*/

#ifndef IAM_H
#define IAM_H
boolean ImagePutAttrValue
(tokentype    *Token,     numtype       AttrNum,
addrtype      Value,     ft F,lt Z,zz *Status);
boolean ImageGetAttrValue
(tokentype    *DbmsToken, numtype       AttrNum,
ft F,lt Z,zz *Status,    addrtype      Value);
int     ImageCompareAttr
(tokentype    *Token,     numtype       AttrNum,
addrtype      CompValue, ptr_cmp       CmpCode,
ft F,lt Z,zz *Status);
boolean ImagePutObjTkn
(tokentype    *Token,     numtype       AttrId,
tokentype    *ObjTkn,    ft F,lt Z,zz *Status);
boolean ImageGetObjTkn
(tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,    tokentype    *ObjTkn);
boolean ImageRefTknPut
(tokentype    *Token,     numtype       AttrId,
RefObj       *RefObjVal, ft F,lt Z,zz *Status);
boolean ImageTokenToRef
(tokentype    *DbmsToken, numtype       AttrNum,
ft F,lt Z,zz *Status,    addrtype     *Image);
boolean ImageNewString
(tokentype    *Token,      numtype       AttrNum,
sizetype      AllocSize,
ft F,lt Z,zz *Status,     cstring      *StrValue);
boolean ImageGetString
(tokentype    *Token,      numtype       AttrNum,
ft F,lt Z,zz *Status,
boolean      *StrCpyIsA,  cstring      *StrValue);
boolean ImageGetAttrUnitSize
(tokentype    *Token,    numtype       AttrNum,
ft F,lt Z,zz *Status,   sizetype     *UnitSize);
boolean ImageCreateArray
(tokentype    *DbmsToken, numtype      AttrNum,
indextype     UnitCount, sizetype     UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype    *Varray);
boolean ImageCreateSubArray
(tokentype    *Token,
numtype       AttrNum,   indextype ArrayIndex,
indextype     UnitCount, sizetype  UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype *Varray);
boolean ImageArrayActivate
(tokentype    *Token,     numtype       AttrNum,
ft F,lt Z,zz *Status,    tokentype    *Vtoken,
numtype      *Vsize,     sizetype     *UnitSize,
addrtype     *Varray);
boolean ImageArrayDeActivate
(tokentype    *Token,     numtype       AttrNum,
ft F,lt Z,zz *Status);
boolean ImageArrayGetSize
(tokentype    *Token,     numtype       AttrNum,
ft F,lt Z,zz *Status,
numtype      *UnitCount, sizetype     *UnitSize);
boolean ImageSubArrayGetSize
(tokentype    *Token,     numtype       AttrId,
indextype     Index,
ft F,lt Z,zz *Status,    numtype      *UnitCount);
boolean ImageArrayAssertSize
(tokentype    *Token,     numtype       AttrNum,
numtype       UnitCount,
ft F,lt Z,zz *Status,    addrtype     *Varray);
boolean ImageSubArrayAssertSize
(tokentype    *Token,     numtype       AttrId,
indextype     Index,     numtype       UnitCount,
ft F,lt Z,zz *Status,    addrtype     *Varray);
boolean ImageArrayDelete
(tokentype    *Token,     numtype       AttrNum,
ft F,lt Z,zz *Status);
boolean ImageSubArrayDelete
(tokentype    *Token,     numtype       AttrNum,
indextype     Index,     ft F,lt Z,zz *Status);
boolean ImageCreateVarray (tokentype    *DbmsToken, numtype   AttrNum,
indextype     UnitCount, sizetype  UnitSize,
ft F,lt Z,zz *Status,
tokentype     *VchunkTkn, addrtype *Varray);
boolean ImageGetVarray    (tokentype    *Token,
ft F,lt Z,zz *Status,   indextype *Vsize,
indextype    *VstackPtr,addrtype  *Varray);
boolean ImagePutVarrayStackPtr
(tokentype    *Token,    indextype  StackPtr,
ft F,lt Z,zz *Status,
indextype    *Vsize,    addrtype  *Varray);
boolean ImageGetVarrayStackPtr
(tokentype    *Token,
ft F,lt Z,zz *Status,   indextype *StackPtr);
boolean ImagePutFieldValue
(tokentype    *Token,     fieldstruc   *FieldStruc,
addrtype      Value,     ft F,lt Z,zz *Status);
boolean ImageGetFieldValue
(tokentype    *Token,     fieldstruc   *FieldStruc,
ft F,lt Z,zz *Status,    addrtype      Value);
#endif
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)


boolean ImagePutAttrValue (tokentype    *Token,    numtype       AttrNum,
addrtype      Value,    ft F,lt Z,zz *Status)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
tokentype     BldDescTkn   = NullToken;
objdesctype  *BldDesc      = NullPtr;
sizetype      Offset       = 0;
tokentype     RefTkn       = NullToken;
addrtype      BytePtr      = NullPtr;
char         *StrPtr       = NullPtr;
AttrTkn.DbId   = RenvId;
if (Token->DbId)
if (TmFetchCoreDb      (Token,       McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc  (CoreDb,      Token->Handle,
McStat,                             &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aChunkAttr
||  AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aDblPtrAttr)
{
*Status = Image_AttrNotPutArrayType;
TraceMsg (0, "    Image_PutValue:: Invalid Attribute Type for PutValue.\n");
TraceMsg (0, "    Arrays Must be instantiated with Array Methods.\n");
sprintf (Msg, "          for  Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
} else {
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
}
if (Normal(*Status))
if (AttrDesc->AttrType        == aStrHndlAttr)
{
StrPtr                      = (char *)Value;
KernelPutAttr       (Token,   AttrNum,     Value,     McStat);
} else if (AttrDesc->AttrType == aObjRefAttr) {
if (MemLoc                 == 1)
KernelPutAttr    (Token,   AttrNum,  (addrtype )&Value,     McStat);
else {
BldDescTkn.DbId          =  RenvId;
BldDescTkn.Handle        =  AttrDesc->BuildDesc;
if (OaGetObject  (&BldDescTkn,  McStat,  (addrtype *)&BldDesc))
if (Env_FetchObjAttrOffset
(MemLoc,      BldDesc->ObjNum,      Token_Attr,
McStat,              &Offset))
{
BytePtr     = (addrtype )((char *)Value     + Offset);
MoveBytes     (BytePtr,  (addrtype )&RefTkn,   sizeof (tokentype));
if (RefTkn.DbId
&&  RefTkn.Handle)
KernelPutAttr
(Token,   AttrNum,     (addrtype )&RefTkn, McStat);
}
}
} else
KernelPutAttr       (Token,   AttrNum,     Value,     McStat);
TRACK(TrackBak,"ImagePutAttrValue\n");
return (STAT);
}
boolean ImageGetAttrValue (tokentype    *DbmsToken,numtype       AttrNum,
ft F,lt Z,zz *Status,   addrtype      Value)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
tokentype     VchunkTkn    = NullToken;
vchunktype   *Vstruc       =  (vchunktype *)Value;
sizetype      Vsize        = 0;
addrtype      Image        = NullPtr;
addrtype      BytePtr      = NullPtr;
int           i            = 0;
handletype   *Handles      = NullPtr;
addrtype     *ArrayPtrs    = NullPtr;
handletype   *ArrayHndls   = NullPtr;
RefObj       *RefObjVal    = NullPtr;
AttrTkn.DbId   = RenvId;
if (DbmsToken->DbId)
if (TmFetchCoreDb     (DbmsToken,    McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       DbmsToken->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType == aObjRefAttr
&&  MemLoc             == 0)
KernelGetAttr      (DbmsToken,   AttrNum,
McStat,      (addrtype )&VchunkTkn);
else
KernelGetAttr      (DbmsToken,   AttrNum,      McStat,      Value);
if (Normal(*Status))
if (MemLoc                    == 0)
if (AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aChunkAttr)
{
VchunkTkn.DbId              = DbmsToken->DbId;
VchunkTkn.CoreDbId          = 0;
MoveBytes   (Value, (addrtype )&VchunkTkn.Handle, sizeof (handletype));
if (AttrDesc->AttrType     == aArrayAttr)
{
if (VchunkTkn.Handle     > 0)
Vchunk_GetAddress  (&VchunkTkn,  McStat,  (addrtype *)Value);
else
MoveBytes   (&Image, Value,      sizeof (addrtype));
} else {
Vstruc->VchunkTkn        = VchunkTkn;
if (Vchunk_GetAddress  (&VchunkTkn,  McStat,         &Vstruc->Varray))
if (Vchunk_GetStackPtr (&VchunkTkn,  McStat,         &Vstruc->Vsize))
if (AttrDesc->AttrType  == aChunkAttr)
{
Vstruc->VstackPtr     = Vstruc->Vsize;
Vchunk_GetChunkSize (&VchunkTkn,  McStat, &Vstruc->Vsize, &Vsize);
}
}
} else if (AttrDesc->AttrType == aDblPtrAttr) {
VchunkTkn.DbId              = DbmsToken->DbId;
VchunkTkn.CoreDbId          = 0;
MoveBytes   (Value, (addrtype )&VchunkTkn.Handle, sizeof (handletype));
if (VchunkTkn.Handle        > 0)
{
if (Vchunk_GetAddress  (&VchunkTkn,  McStat, (addrtype *)&ArrayPtrs))
if (Vchunk_GetStackPtr (&VchunkTkn,  McStat,             &Vsize))
{
Vsize               /= 3;
ArrayHndls           = (handletype *)ArrayPtrs;
Handles              = (handletype *)&ArrayHndls[Vsize * 2];
}
for (i = -1; ++i < Vsize && Normal(*Status); )
{
if ((VchunkTkn.Handle  = Handles[i]) > 0)
{
Vchunk_GetAddress (&VchunkTkn,
McStat,           (addrtype *)&ArrayPtrs[i]);
} else
ArrayPtrs[i]         = NullPtr;
}
if (Normal(*Status))
MoveBytes (&ArrayPtrs, Value,      sizeof (addrtype));
} else
MoveBytes   (&Image,     Value,      sizeof (addrtype));
} else if (AttrDesc->AttrType == aObjRefAttr) {
if (VchunkTkn.DbId
&&  VchunkTkn.Handle)
ImageGetObject         (&VchunkTkn,  McStat,         &Image);
MoveBytes      (&Image,     Value,      sizeof (addrtype));
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Image::GetValue Object[%2u:%4u] Reference @%x (Value := @%x)\n",
VchunkTkn.DbId, VchunkTkn.Handle,
Image,         *(addrtype **)Value))
TraceMsg (0, Msg);
} else if (AttrDesc->AttrType == aTknRefAttr) {
BytePtr    = (addrtype )((char *)Value     + sizeof (addrtype));
MoveBytes   (Value,  (addrtype )&VchunkTkn,  sizeof (tokentype));
if (ClassBug)
if (sprintf (Msg, "  Get TknRef[%4u:%6u]Attr  Value @%8x; BytePtr @%8x\n",
VchunkTkn.DbId, VchunkTkn.Handle, Value, BytePtr))
TraceMsg (0, Msg);
MoveBytes   (&Image,                Value,   sizeof (addrtype));
MoveBytes   ((addrtype )&VchunkTkn, BytePtr, sizeof (tokentype));
}
if (Normal(*Status))
if (MemLoc                    == 1)
if (AttrDesc->AttrType        == aTknRefAttr)
{
if ((RefObjVal = *(RefObj **)Value) != NULL)
if (ClassBug)
if (sprintf (Msg, "  Get TknRef[%4u:%6u]Attr  ObjAddr @%8x;\n",
RefObjVal->ObjTkn.DbId, RefObjVal->ObjTkn.Handle,
RefObjVal->ObjAddr))
TraceMsg (0, Msg);
}
TRACK(TrackBak,"ImageGetAttrValue\n");
return (STAT);
}
int     ImageCompareAttr (tokentype    *Token,     numtype       AttrNum,
addrtype      CompValue, ptr_cmp       CmpCode,
ft F,lt Z,zz *Status)
{
int           i            = 0;
bytetype     *ByteValue    = NULL;
idtype       *IdValue      = NULL;
inttype      *IntValue     = NULL;
tokentype    *TknValue     = NULL;
tokentype    *CompTkn      = NULL;
float        *FloatValue   = NULL;
double       *DoubleValue  = NULL;
addrtype     *AddrValue    = NULL;
handletype   *HndlValue    = NULL;
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
tokentype     VchunkTkn    = NullToken;
vchunktype   *Vstruc       = NullPtr;
sizetype      Vsize        = 0;
addrtype      Image        = NullPtr;
addrtype      BytePtr      = NullPtr;
handletype   *Handles      = NullPtr;
addrtype     *ArrayPtrs    = NullPtr;
handletype   *ArrayHndls   = NullPtr;
addrtype      Value        = NullPtr;
sizetype      Size         = 0;
AttrTkn.DbId   = RenvId;
if (Token->DbId)
if (TmFetchCoreDb     (Token,    McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (EnvFetchAttrSize   (AttrNum,     McStat,                &Size))
if (MemLoc)
{
if (AttrDesc->AttrType         == aTknRefAttr)
Size       = sizeof (RefObj);
else if (AttrDesc->AttrType    == aVarrayAttr)
Size       = sizeof (varraytype);
else if (AttrDesc->AttrType    == aChunkAttr)
Size       = sizeof (vchunktype);
}
if (Normal(*Status))
if (AttrDesc->AttrType            != aStrHndlAttr)
Core0_MoreCore   (Size,   McStat,  &Value);
if (AttrDesc->AttrType == aObjRefAttr
&&  MemLoc             == 0)
KernelGetAttr      (Token,   AttrNum,
McStat,      (addrtype )&VchunkTkn);
else
KernelGetAttr      (Token,   AttrNum,      McStat,     Value);
if (Normal(*Status))
if (MemLoc                    == 0)
if (AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aChunkAttr)
{
VchunkTkn.DbId              = Token->DbId;
VchunkTkn.CoreDbId          = 0;
MoveBytes   (Value, (addrtype )&VchunkTkn.Handle, sizeof (handletype));
if (AttrDesc->AttrType     == aArrayAttr)
{
if (VchunkTkn.Handle     > 0)
Vchunk_GetAddress  (&VchunkTkn,  McStat,  (addrtype *)Value);
else
MoveBytes   (&Image, Value,      sizeof (addrtype));
} else {
Vstruc                   =  (vchunktype *)Value;
Vstruc->VchunkTkn        = VchunkTkn;
if (Vchunk_GetAddress  (&VchunkTkn,  McStat,         &Vstruc->Varray))
if (Vchunk_GetStackPtr (&VchunkTkn,  McStat,         &Vstruc->Vsize))
if (AttrDesc->AttrType  == aChunkAttr)
{
Vstruc->VstackPtr     = Vstruc->Vsize;
Vchunk_GetChunkSize (&VchunkTkn,  McStat, &Vstruc->Vsize, &Vsize);
}
}
} else if (AttrDesc->AttrType == aDblPtrAttr) {
VchunkTkn.DbId              = Token->DbId;
VchunkTkn.CoreDbId          = 0;
MoveBytes   (Value, (addrtype )&VchunkTkn.Handle, sizeof (handletype));
if (VchunkTkn.Handle        > 0)
{
if (Vchunk_GetAddress  (&VchunkTkn,  McStat, (addrtype *)&ArrayPtrs))
if (Vchunk_GetStackPtr (&VchunkTkn,  McStat,             &Vsize))
{
Vsize               /= 3;
ArrayHndls           = (handletype *)ArrayPtrs;
Handles              = (handletype *)&ArrayHndls[Vsize * 2];
}
for (i = -1; ++i < Vsize && Normal(*Status); )
{
if ((VchunkTkn.Handle  = Handles[i]) > 0)
{
Vchunk_GetAddress (&VchunkTkn,
McStat,           (addrtype *)&ArrayPtrs[i]);
} else
ArrayPtrs[i]         = NullPtr;
}
if (Normal(*Status))
MoveBytes (&ArrayPtrs, Value,      sizeof (addrtype));
} else
MoveBytes   (&Image,     Value,      sizeof (addrtype));
} else if (AttrDesc->AttrType == aObjRefAttr) {
if (VchunkTkn.DbId
&&  VchunkTkn.Handle)
ImageGetObject         (&VchunkTkn,  McStat,         &Image);
MoveBytes      (&Image,     Value,      sizeof (addrtype));
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Image::GetValue Object[%2u:%4u] Reference @%x (Value := @%x)\n",
VchunkTkn.DbId, VchunkTkn.Handle,
Image,         Value))
TraceMsg (0, Msg);
} else if (AttrDesc->AttrType == aTknRefAttr) {
BytePtr    = (addrtype )((char *)Value     + sizeof (addrtype));
MoveBytes   (Value,  (addrtype )&VchunkTkn,  sizeof (tokentype));
if (ClassBug)
if (sprintf (Msg, "  Get TknRef[%4u:%6u]Attr  Value @%8x; BytePtr @%8x\n",
VchunkTkn.DbId, VchunkTkn.Handle, Value, BytePtr))
TraceMsg (0, Msg);
MoveBytes   (&Image,                Value,   sizeof (addrtype));
MoveBytes   ((addrtype )&VchunkTkn, BytePtr, sizeof (tokentype));
}
if (Normal(*Status))
switch (AttrDesc->TypeType)
{
case aDbmsString :
case aString     :
if (AttrDesc->UnitSize == 1)
{
ByteValue    = (bytetype *)CompValue;
if (*(bytetype *)Value < *ByteValue)
i = -1;
else if (*(bytetype *)Value > *ByteValue)
i = 1;
} else
i = strcmp  ((char *)Value,  (char *)CompValue);
break;
case aLink       :
if (Size == sizeof (tokentype ))
{
TknValue    = (tokentype *)CompValue;
CompTkn     = (tokentype *)Value;
if (CompTkn->Handle < TknValue->Handle)
i = -1;
else if (CompTkn->Handle > TknValue->Handle)
i = 1;
if (i == 0
&& CompTkn->DbId  != TknValue->DbId)
i = -1;
} else {
HndlValue   = (handletype *)CompValue;
if (*(handletype *)Value < *HndlValue)
i = -1;
else if (*(handletype *)Value > *HndlValue)
i = 1;
}
break;
case aReal       :
if (Size == sizeof (float))
{
FloatValue    = (float *)CompValue;
if (*(float *)Value < *FloatValue)
i = -1;
else if (*(float *)Value > *FloatValue)
i = 1;
} else if (Size == sizeof (double)) {
DoubleValue    = (double *)CompValue;
if (*(double *)Value < *DoubleValue)
i = -1;
else if (*(double *)Value > *DoubleValue)
i = 1;
}
break;
case aAddr       :
AddrValue    = (addrtype *)CompValue;
if (*(addrtype *)Value != AddrValue)
i = 1;
break;
case aEnum       :
case aBoolean    :
case aValue      :
case aChunk      :
case aInteger    :
switch (Size)
{
case 1     :
ByteValue    = (bytetype *)CompValue;
if (*(bytetype *)Value < *ByteValue)
i = -1;
else if (*(bytetype *)Value > *ByteValue)
i = 1;
break;
case 2     :
IdValue    = (idtype *)CompValue;
if (*(idtype *)Value < *IdValue)
i = -1;
else if (*(idtype *)Value > *IdValue)
i = 1;
break;
case 4     :
IntValue    = (inttype *)CompValue;
if (*(inttype *)Value < *IntValue)
i = -1;
else if (*(inttype *)Value > *IntValue)
i = 1;
break;
default    :
#ifdef LARGE
if (Size == sizeof (tokentype))
{
TknValue    = (tokentype *)CompValue;
CompTkn     = (tokentype *)Value;
if (CompTkn->Handle < TknValue->Handle)
i = -1;
else if (CompTkn->Handle > TknValue->Handle)
i = 1;
if (i == 0
&& CompTkn->DbId  != TknValue->DbId)
i = -1;
} else {
#endif
if (Size <= sizeof (tokentype ))
i = memcmp  ((char *)Value,
(char *)CompValue, (size_t )Size);
else
i = strncmp ((char *)Value,
(char *)CompValue, (size_t )Size);
#ifdef LARGE
}
#endif
}
break;
}
if (Normal(*Status))
if (AttrDesc->AttrType            != aStrHndlAttr)
Core0_FreeCore   ((addrtype *)&Value,  Size,   McStat);
STAT;
TRACK(TrackBak,"ImageCompareAttr\n");
return (i);
}
boolean ImagePutObjTkn   (tokentype    *Token,     numtype       AttrNum,
tokentype    *ObjTkn,    ft F,lt Z,zz *Status)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
addrtype      ObjAddr      = NullPtr;
AttrTkn.DbId   = RenvId;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Image::PutObjTkn To [%2u:%4u] Attr= %2u; ObjTkn[%4u:%6u]\n",
Token->DbId, Token->Handle, AttrNum,
ObjTkn->DbId, ObjTkn->Handle))
TraceMsg (0, Msg);
if (Token->DbId)
if (TmFetchCoreDb     (Token,        McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aObjRefAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotObjRefType;
TraceMsg (0, " Image_PutObjTkn:: Attribute Not a ObjRef Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (MemLoc             == 0)
{
KernelPutAttr      (Token,   AttrNum,     (addrtype )ObjTkn, McStat);
} else {
if (ObjTkn->DbId      > 0
&&  ObjTkn->Handle    > 0)
{
if (ImageGetObject (ObjTkn,    McStat,    &ObjAddr))
KernelPutAttr  (Token,     AttrNum,   (addrtype )&ObjAddr,
McStat);
}
}
TRACK(TrackBak,"ImagePutObjTkn\n");
return (STAT);
}
boolean ImageGetObjTkn   (tokentype    *Token,     numtype       AttrNum,
ft F,lt Z,zz *Status,    tokentype    *ObjTkn)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
addrtype      ObjAddr      = NullPtr;
tokentype     BldDescTkn   = NullToken;
objdesctype  *BldDesc      = NullPtr;
sizetype      Offset       = 0;
addrtype      BytePtr      = NullPtr;
AttrTkn.DbId   = RenvId;
*ObjTkn         = NullToken;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Image::GetObjTkn From [%2u:%4u] Attr= %2u;\n",
Token->DbId, Token->Handle, AttrNum))
TraceMsg (0, Msg);
if (Token->DbId)
if (TmFetchCoreDb     (Token,        McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aObjRefAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotObjRefType;
TraceMsg (0, " Image_GetObjTkn:: Attribute Not a ObjRefType.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (MemLoc             == 0)
{
KernelGetAttr      (Token,   AttrNum,   McStat, (addrtype *)ObjTkn);
} else {
if (KernelGetAttr  (Token,   AttrNum,   McStat, (addrtype *)&ObjAddr))
if (ObjAddr         != NullPtr)
{
BldDescTkn.DbId          =  RenvId;
BldDescTkn.Handle        =  AttrDesc->BuildDesc;
if (OaGetObject  (&BldDescTkn,  McStat,  (addrtype *)&BldDesc))
if (Env_FetchObjAttrOffset
(MemLoc,      BldDesc->ObjNum,      Token_Attr,
McStat,              &Offset))
{
BytePtr     = (addrtype )((char *)ObjAddr   + Offset);
MoveBytes     (BytePtr,  (addrtype )ObjTkn,   sizeof (tokentype));
}
}
}
TRACK(TrackBak,"ImageGetObjTkn\n");
return (STAT);
}
boolean ImageRefTknPut    (tokentype    *Token,    numtype       AttrNum,
RefObj       *RefObjVal,ft F,lt Z,zz *Status)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
AttrTkn.DbId   = RenvId;
if (Token->DbId)
if (TmFetchCoreDb     (Token,        McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aTknRefAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotRefTknType;
TraceMsg (0, " Image_RefTknPut:: Attribute Not an Reference Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
KernelPutAttr     (Token,    AttrNum,   (addrtype )RefObjVal,  McStat);
TRACK(TrackBak,"ImageRefTknPut\n");
return (STAT);
}
boolean ImageTokenToRef   (tokentype    *Token,    numtype       AttrNum,
ft F,lt Z,zz *Status,   addrtype     *RefObject)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
tokentype     RefTkn       = NullToken;
RefObj        RefObjVal;
*RefObject      = NullPtr;
AttrTkn.DbId   = RenvId;
if (Token->DbId)
if (TmFetchCoreDb     (Token,        McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aTknRefAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotRefTknType;
TraceMsg (0, " Image_TokenToRef:: Attribute Not a Reference Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (MemLoc             == 0)
{
if (KernelGetAttr  (Token,                     AttrNum,
McStat,        (addrtype )&RefTkn))
if (!TmIsValid     (&RefTkn,     McStat))
{
*RefObject         = NullPtr;
} else {
if (ImageGetObject (&RefTkn,  McStat,          RefObject))
Hm_IncrementMemRef
(CoreDb,   RefTkn.Handle,   McStat);
}
} else {
if (KernelGetAttr  (Token,       AttrNum,
McStat,      (addrtype )&RefObjVal))
if (!TmIsValid (&RefObjVal.ObjTkn,  McStat))
{
RefObjVal.ObjTkn           = NullToken;
RefObjVal.ObjAddr          = NullPtr;
} else if (RefObjVal.ObjAddr  == NullPtr) {
if (ImageGetObject (&RefObjVal.ObjTkn,  McStat,          RefObject))
if (Hm_IncrementMemRef
(CoreDb,   RefObjVal.ObjTkn.Handle,   McStat))
RefObjVal.ObjAddr      = *RefObject;
if (ClassBug)
if (sprintf (Msg, "  Get TknRef[%4u:%6u]Attr  ObjAddr @%8x;\n",
RefObjVal.ObjTkn.DbId, RefObjVal.ObjTkn.Handle,
RefObjVal.ObjAddr))
TraceMsg (0, Msg);
}
}
TRACK(TrackBak,"ImageTokenToRef\n");
return (STAT);
}
boolean ImageNewString    (tokentype    *Token,    numtype       AttrNum,
sizetype      StrSize,
ft F,lt Z,zz *Status,   cstring      *StrValue)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
boolean       StringIsA    = False;
tokentype     VchunkTkn    = NullToken;
AttrTkn.DbId   = RenvId;
if (Token->DbId)
if (TmFetchCoreDb     (Token,        McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType  == aStrHndlAttr)
StringIsA                   = False;
else if (AttrDesc->AttrType  == aArrayAttr
&&  AttrDesc->TypeType  == aString)
StringIsA                   = True;
else
StringIsA                   = False;
if (StringIsA)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrName= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotStringType;
TraceMsg (0, " Image_NewString:: Attr Not a Allocatable String Type.\n");
TraceMsg (0, "                   Must be of type <char *>.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
sprintf (Msg, "        For AttrType = %s; AttrName= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
if (Normal(*Status))
ImageCreateArray   (Token,  AttrNum,  StrSize,    sizeof (char ),
McStat,         &VchunkTkn,  (addrtype *)StrValue);
TRACK(TrackBak,"ImageNewString\n");
return (STAT);
}
boolean ImageGetString    (tokentype    *Token,    numtype       AttrNum,
ft F,lt Z,zz *Status,
boolean      *StrCpyIsA,cstring      *StrValue)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
boolean       StringIsA    = False;
sizetype      StrSize      = 0;
cstring       Cstring      = NullPtr;
handletype    Chandle      = 0;
tokentype     Vtoken       = NullToken;
*StrCpyIsA      = False;
AttrTkn.DbId   = RenvId;
if (Token->DbId)
if (TmFetchCoreDb     (Token,        McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aStrHndlAttr)
{
StringIsA                   = True;
} else if (AttrDesc->AttrType == aAttr)   {
if   (AttrDesc->TypeType   == aString
&&    AttrDesc->UnitSize    > 1)
StringIsA                   = True;
} else if (AttrDesc->AttrType == aArrayAttr
&&  AttrDesc->TypeType == aString) {
StringIsA                   = True;
} else
StringIsA                   = False;
if (StringIsA)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotStringType;
TraceMsg (0, " Image_GetString:: Attribute Not a String Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (MemLoc  == 0)
KernelGetAttr      (Token,   AttrNum,  McStat, (addrtype *)&Chandle);
else
KernelGetAttr      (Token,   AttrNum,  McStat, (addrtype *)&Cstring);
if (MemLoc  == 0)
{
if (AttrDesc->AttrType == aArrayAttr)
{
Vtoken.DbId         = Token->DbId;
Vtoken.Handle       = Chandle;
if (Vtoken.Handle   > 0)
Vchunk_GetAddress  (&Vtoken,     McStat,  (addrtype *)&Cstring);
}
if (Normal(*Status))
if (Cstring              != NullPtr)
{
if (AttrDesc->AttrType   != aStrHndlAttr)
{
*StrCpyIsA    = True;
if ((StrSize = strlen (Cstring)) > 0)
if (Core0MoreCore  (StrSize +1, McStat, (addrtype *)StrValue))
strncpy (*(char **)StrValue,  Cstring, StrSize);
} else
*StrValue   = Cstring;
}
} else
*StrValue   = Cstring;
TRACK(TrackBak,"ImageGetString\n");
return (STAT);
}
boolean ImageGetAttrUnitSize
(tokentype    *Token,    numtype       AttrNum,
ft F,lt Z,zz *Status,   sizetype     *UnitSize)
{
numtype       ObjNum       = 0;
attrtype      AttrType     = aNonTypeAttr;
numtype       RefObjNum    = 0;
typetype      UnitType     = aNonTypeType;
valueclass    ValueType    = aNonValueClass;
sizetype      Offset       = 0;
tokentype     TypeTkn      = NullToken;
typedesctype *EnvType      = NullPtr;
envclass      RefType      = aNonEnvClass;
TypeTkn.DbId      = RenvId;
if (EnvFetchObjNum       (Token,       McStat,      &ObjNum))
if (Env_FetchObjAttrSpec (ObjNum,      AttrNum,
McStat,     &AttrType,    &RefObjNum, &RefType,
UnitSize,   &UnitType,    &ValueType,
&Offset))
if (RefObjNum)
if (RefType          == aEnvObj)
EnvFetchObjSize (RefObjNum,  McStat, UnitSize);
else {
TypeTkn.Handle     = RefObjNum;
if (OaGetObject   (&TypeTkn,  McStat, (addrtype *)&EnvType))
*UnitSize       = EnvType->Size;
}
TRACK(TrackBak,"ImageGetAttrUnitSize\n");
return (STAT);
}
boolean ImageCreateArray  (tokentype    *Token,    numtype       AttrNum,
indextype     UnitCount,sizetype      UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn,addrtype     *Varray)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
AttrTkn.DbId   = RenvId;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, " Image::CreateArray for [%2u:%4u] Attr= %2u @%x\n",
Token->DbId, Token->Handle, AttrNum, *Varray))
TraceMsg (0, Msg);
if (Token->DbId)
if (TmFetchCoreDb     (Token,        McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aDblPtrAttr
||  AttrDesc->AttrType        == aChunkAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotArrayType;
TraceMsg (0, " Image_CreateArray :: Attribute Not an Array Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (AttrDesc->AttrType        == aDblPtrAttr)
{
UnitSize          = sizeof (handletype);
C_CreateArray      (Token,       AttrNum,      UnitCount,  UnitSize,
McStat,      VchunkTkn,    Varray);
} else
C_CreateArray      (Token,       AttrNum,      UnitCount,  UnitSize,
McStat,      VchunkTkn,    Varray);
if (Normal(*Status))
if (AttrDesc->AttrType        == aArrayAttr)
Vchunk_PutStackPtr (VchunkTkn,   UnitCount,    McStat,     Varray);
else if (AttrDesc->AttrType   == aDblPtrAttr)
Vchunk_PutStackPtr (VchunkTkn,   UnitCount *3, McStat,     Varray);
else
Vchunk_PutStackPtr (VchunkTkn,   0,            McStat,     Varray);
if (!Normal(*Status) || DeBug)
{
sprintf (Msg, "  Image::CreateArray for Token[%2u:%4u] @%x\n",
Token->DbId, Token->Handle, *Varray);
TraceMsg (0, Msg);
if (DeBug || OaBug)
OaDumpObject    (0, Token, McStat);
}
TRACK(TrackBak,"ImageCreateArray\n");
return (STAT);
}
boolean ImageCreateSubArray (tokentype    *Token,
numtype       AttrNum,  indextype ArrayIndex,
indextype     UnitCount,sizetype  UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype *Varray)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
AttrTkn.DbId   = RenvId;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, " Image::CreateArray for [%2u:%4u] Attr= %2u @%x\n",
Token->DbId, Token->Handle, AttrNum, *Varray))
TraceMsg (0, Msg);
if (Token->DbId)
if (TmFetchCoreDb     (Token,        McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aDblPtrAttr
||  AttrDesc->AttrType        == aChunkAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotArrayType;
TraceMsg (0, " Image_CreateArray :: Attribute Not an Array Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (C_CreateSubArray  (Token,       AttrNum,      ArrayIndex,
UnitCount,   UnitSize,
McStat,      VchunkTkn,    Varray))
Vchunk_PutStackPtr (VchunkTkn,   UnitCount,    McStat,     Varray);
if (!Normal(*Status) || DeBug)
{
sprintf (Msg,
"  Image::CreateSubArray for Token[%2u:%4u] Index=%4u @%x\n",
Token->DbId, Token->Handle, ArrayIndex, *Varray);
TraceMsg (0, Msg);
if (DeBug || OaBug)
OaDumpObject    (0, Token, McStat);
}
TRACK(TrackBak,"ImageCreateSubArray\n");
return (STAT);
}
boolean ImageArrayActivate
(tokentype    *Token,    numtype       AttrNum,
ft F,lt Z,zz *Status,   tokentype    *Vtoken,
numtype      *Vsize,    sizetype     *UnitSize,
addrtype     *Varray)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
int           i            = 0;
handletype   *Handles      = NullPtr;
addrtype     *ArrayPtrs    = NullPtr;
handletype   *ArrayHndls   = NullPtr;
tokentype     VchunkTkn    = NullToken;
addrtype      Object       = NullPtr;
numtype       ObjNum       = 0;
addrtype      DbObject     = NullPtr;
numtype       UnitCount    = 0;
vchunktype    Vstruc;
AttrTkn.DbId   = RenvId;
if (Token->DbId)
if (TmFetchCoreDb     (Token,        McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aDblPtrAttr
||  AttrDesc->AttrType        == aChunkAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotArrayType;
TraceMsg (0, " Image_ArrayActivate :: Attribute Not an Array Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
Vtoken->DbId                   = Token->DbId;
if (Normal(*Status))
if (MemLoc)
*Status   = Attr_ImageIsActive;
else if (MemLoc     == 0)
{
if (KernelGetAttr  (Token,       AttrNum,  McStat,  (addrtype )Vtoken))
if (Vtoken->Handle          > 0)
{
if (Vchunk_GetStackPtr (Vtoken,     McStat,              Vsize))
if (Vchunk_GetChunkSize
(Vtoken,     McStat,  &UnitCount, UnitSize))
Vchunk_GetAddress  (Vtoken,     McStat,  (addrtype *)Varray);
if (Normal (*Status))
if (AttrDesc->AttrType        == aDblPtrAttr)
{
*Vsize                      /= 3;
ArrayPtrs                   = *(addrtype **)Varray;
ArrayHndls                  = (handletype *)ArrayPtrs;
Handles                     = (handletype *)&ArrayHndls[*Vsize * 2];
VchunkTkn.DbId              = Vtoken->DbId;
for (i = -1; ++i < *Vsize && Normal(*Status); )
{
if ((VchunkTkn.Handle    = Handles[i]) > 0)
{
Vchunk_GetAddress (&VchunkTkn,
McStat,    (addrtype *)&ArrayPtrs[i]);
} else
ArrayPtrs[i]        = NullPtr;
}
}
} else {
*Varray                  = NullPtr;
*Vsize                   = 0;
}
} else if (AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aDblPtrAttr)
{
if (HmGetObjectAddr   (CoreDb,  Token->Handle,  McStat,        &Object))
if (OaRevokeCppObject (Token,                   McStat))
if (HmGetObjNum       (CoreDb,  Token->Handle,  McStat,        &ObjNum))
if (OaGetObject       (Token,                   McStat,        &DbObject))
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Get Internal DbObject of Class =%3u Of Image @%x As DB @%x\n",
ObjNum, Object, DbObject))
TraceMsg (0, Msg);
if (Normal (*Status))
if (KernelGetAttr     (Token,   AttrNum,    McStat,  (addrtype )Vtoken))
OaInvokeCppObject (Token,   Object,     McStat);
if (Vtoken->Handle          > 0)
{
if (Vchunk_GetStackPtr (Vtoken,     McStat,              Vsize))
if (Vchunk_GetAddress  (Vtoken,     McStat,  (addrtype *)Varray))
if (Vchunk_GetChunkSize
(Vtoken,     McStat,  &UnitCount, UnitSize))
if (AttrDesc->AttrType  == aDblPtrAttr)
*Vsize                /= 3;
} else {
*Varray                  = NullPtr;
*Vsize                   = 0;
}
} else {
if (KernelGetAttr  (Token,   AttrNum,  McStat,  (addrtype )&Vstruc))
{
*Vtoken                  = Vstruc.VchunkTkn;
*Varray                  = Vstruc.Varray;
*Vsize                   = Vstruc.Vsize;
if (Vstruc.VchunkTkn.Handle   > 0)
Vchunk_GetChunkSize
(Vtoken,     McStat,  &UnitCount,        UnitSize);
}
}
TRACK(TrackBak,"ImageArrayActivate\n");
return (STAT);
}
boolean ImageArrayDeActivate
(tokentype    *Token,    numtype       AttrNum,
ft F,lt Z,zz *Status)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
tokentype     Vtoken       = NullToken;
sizetype      Vsize        = 0;
addrtype      Varray       = NullPtr;
int           i            = 0;
handletype   *Handles      = NullPtr;
addrtype     *ArrayPtrs    = NullPtr;
handletype   *ArrayHndls   = NullPtr;
tokentype     VchunkTkn    = NullToken;
AttrTkn.DbId   = RenvId;
if (Token->DbId)
if (TmFetchCoreDb     (Token,        McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aDblPtrAttr
||  AttrDesc->AttrType        == aChunkAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotArrayType;
TraceMsg (0, " Image_ArrayActivate :: Attribute Not an Array Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
Vtoken.DbId                    = Token->DbId;
if (Normal(*Status))
if (MemLoc == 0)
{
if (KernelGetAttr  (Token, AttrNum,    McStat,  (addrtype   )&Vtoken))
if (Vtoken.Handle           > 0)
{
if (Normal (*Status))
if (AttrDesc->AttrType        == aDblPtrAttr)
if (Vchunk_GetStackPtr (&Vtoken,    McStat,  (indextype *)&Vsize))
if (Vchunk_GetAddress  (&Vtoken,    McStat,  (addrtype  *)&Varray))
{
Vsize                      /= 3;
ArrayPtrs                   = (addrtype   *)Varray;
ArrayHndls                  = (handletype *)ArrayPtrs;
Handles                     = (handletype *)&ArrayHndls[Vsize * 2];
VchunkTkn.DbId              = Vtoken.DbId;
for (i = -1; ++i < Vsize && Normal(*Status); )
{
if ((VchunkTkn.Handle    = Handles[i]) > 0)
Vchunk_GetAddress (&VchunkTkn,
McStat,    (addrtype *)&ArrayPtrs[i]);
}
}
}
}
TRACK(TrackBak,"ImageArrayDeActivate\n");
return (STAT);
}
boolean ImageArrayGetSize (tokentype    *Token,    numtype       AttrNum,
ft F,lt Z,zz *Status,
numtype      *UnitCount,sizetype     *UnitSize)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
addrtype      Object       = NullPtr;
numtype       ObjNum       = 0;
addrtype      DbObject     = NullPtr;
tokentype     Vtoken       = NullToken;
*UnitCount       = 0;
*UnitSize        = 0;
AttrTkn.DbId   = RenvId;
Vtoken.DbId    = Token->DbId;
Vtoken.Handle  = 0;
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aDblPtrAttr
||  AttrDesc->AttrType        == aChunkAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotArrayType;
TraceMsg (0, " Image_ArrayGetSize :: Attribute Not an Array Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (Token->DbId)
if (TmFetchCoreDb     (Token,   McStat,                  &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,  Token->Handle,
McStat,                           &MemLoc))
if (MemLoc)
if (HmGetObjectAddr   (CoreDb,  Token->Handle,  McStat,  &Object))
if (OaRevokeCppObject (Token,                   McStat))
if (HmGetObjNum       (CoreDb,  Token->Handle,  McStat,  &ObjNum))
if (OaGetObject       (Token,                   McStat,  &DbObject))
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Get Internal DbObject of Class =%3u Of Image @%x As DB @%x\n",
ObjNum, Object, DbObject))
TraceMsg (0, Msg);
if (Normal (*Status))
if (KernelGetAttr     (Token,   AttrNum,   McStat,  (addrtype )&Vtoken))
if (MemLoc)
OaInvokeCppObject (Token,   Object,    McStat);
if (Normal (*Status))
if (Vtoken.Handle           > 0)
if (Vchunk_GetChunkSize
(&Vtoken, McStat,    UnitCount,           UnitSize))
if (Vchunk_GetStackPtr
(&Vtoken, McStat,    (indextype *)UnitCount))
if (AttrDesc->AttrType     == aDblPtrAttr)
*UnitCount /= 3;
TRACK(TrackBak,"ImageArrayGetSize\n");
return (STAT);
}
boolean ImageSubArrayGetSize
(tokentype    *Token,     numtype       AttrNum,
indextype     Index,
ft F,lt Z,zz *Status,    numtype      *NumEntrys)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
addrtype      Object       = NullPtr;
numtype       ObjNum       = 0;
addrtype      DbObject     = NullPtr;
handletype   *Handles      = NullPtr;
addrtype     *ArrayPtrs    = NullPtr;
handletype   *ArrayHndls   = NullPtr;
tokentype     Vtoken       = NullToken;
indextype     Vsize        = 0;
*NumEntrys      = 0;
AttrTkn.DbId   = RenvId;
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aDblPtrAttr)
{
if (Token->DbId)
if (TmFetchCoreDb     (Token,   McStat,                  &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,  Token->Handle,
McStat,                           &MemLoc))
if (MemLoc)
if (HmGetObjectAddr   (CoreDb,  Token->Handle,  McStat,  &Object))
if (OaRevokeCppObject (Token,                   McStat))
if (HmGetObjNum       (CoreDb,  Token->Handle,  McStat,  &ObjNum))
if (OaGetObject       (Token,                   McStat,  &DbObject))
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Get Internal DbObject of Class =%3u Of Image @%x As DB @%x\n",
ObjNum, Object, DbObject))
TraceMsg (0, Msg);
Vtoken.DbId                 = Token->DbId;
Vtoken.Handle               = 0;
if (Normal (*Status))
if (KernelGetAttr     (Token,   AttrNum,   McStat,  (addrtype )&Vtoken))
if (MemLoc)
OaInvokeCppObject (Token,   Object,    McStat);
if (Normal (*Status))
if (Vtoken.Handle           > 0)
{
if (Vchunk_GetStackPtr (&Vtoken,        McStat,             &Vsize))
if (Index                < (Vsize /3))
{
if (Vchunk_GetAddress
(&Vtoken, McStat,    (addrtype *)&ArrayPtrs))
{
ArrayHndls         = (handletype *)ArrayPtrs;
Handles            = (handletype *)&ArrayHndls[Vsize / 3 * 2];
if ((Vtoken.Handle = Handles[Index]) > 0)
Vchunk_GetStackPtr
(&Vtoken,        McStat,           NumEntrys);
}
} else {
*Status                = Image_ArrayIndexOutOfRange;
TraceMsg (0,
" Image_SubArrayGetSize :: Index of SubArray Out OfRange.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
sprintf (Msg, "         Index =%2u  GTR Size =%4u.\n",
Index, Vsize/2);
TraceMsg (0, Msg);
}
}
} else {
*Status = Image_AttrNotDblPtrType;
TraceMsg (0, " Image_SubArrayGetSize :: Attribute Not a DblPtr Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"ImageSubArrayGetSize\n");
return (STAT);
}
boolean ImageArrayAssertSize
(tokentype    *Token,    numtype       AttrNum,
numtype       UnitCount,
ft F,lt Z,zz *Status,   addrtype     *Varray)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
addrtype      Object       = NullPtr;
numtype       ObjNum       = 0;
addrtype      DbObject     = NullPtr;
tokentype     Vtoken       = NullToken;
tokentype     Vchunk       = NullToken;
indextype     Vsize        = 0;
int           i            = -1;
farlongtype   SizeInBytes  = 0;
handletype   *Handles      = NullPtr;
addrtype     *TmpAddrs     = NullPtr;
handletype   *ArrayHndls   = NullPtr;
handletype   *NewHndls     = NullPtr;
handletype   *TmpHndls     = NullPtr;
int           DiffSize     = 0;
indextype     Index        = 0;
indextype     Indx0        = 0;
*Varray          = 0;
AttrTkn.DbId   = RenvId;
Vtoken.DbId    = Token->DbId;
Vtoken.Handle  = 0;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Image::ArrayAssertSize [%2u:%4u] EnvAttr= %2u\n",
Token->DbId, Token->Handle, AttrNum))
TraceMsg (0, Msg);
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aDblPtrAttr
||  AttrDesc->AttrType        == aChunkAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotArrayType;
TraceMsg (0, " Image_ArrayAssertSize :: Attribute Not an Array Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (Token->DbId)
if (TmFetchCoreDb     (Token,   McStat,                  &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,  Token->Handle,
McStat,                           &MemLoc))
if (MemLoc)
if (HmGetObjectAddr   (CoreDb,  Token->Handle,  McStat,  &Object))
if (OaRevokeCppObject (Token,                   McStat))
if (HmGetObjNum       (CoreDb,  Token->Handle,  McStat,  &ObjNum))
if (OaGetObject       (Token,                   McStat,  &DbObject))
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Get Internal DbObject of Class =%3u Of Image @%x As DB @%x\n",
ObjNum, Object, DbObject))
TraceMsg (0, Msg);
if (Normal (*Status))
if (KernelGetAttr     (Token,   AttrNum,   McStat,  (addrtype )&Vtoken))
if (MemLoc)
OaInvokeCppObject (Token,   Object,    McStat);
if (Vtoken.Handle           > 0)
{
if (AttrDesc->AttrType  == aDblPtrAttr)
{
if (Vchunk_GetStackPtr (&Vtoken, McStat,      &Vsize))
if (Vchunk_PutStackPtr (&Vtoken, UnitCount*3,  McStat,  Varray))
{
Vsize      /= 3;
ArrayHndls  = (handletype *)Varray;
Handles     = &ArrayHndls[Vsize * 2];
DiffSize    = UnitCount - Vsize;
}
if (Normal(*Status))
if (UnitCount < Vsize)
{
for (i = UnitCount ; ++i < Vsize  && Normal(*Status); )
{
if ((Vchunk.Handle = Handles[i]) > 0)
Vchunk_Delete (&Vchunk,   McStat);
}
NewHndls       = &ArrayHndls[UnitCount * 2];
for (i = -1; ++i < UnitCount; )
{
ArrayHndls[i]  =  Handles[i];
}
Vchunk.DbId    = Token->DbId;
} else {
SizeInBytes   = UnitCount * 3 * sizeof (handletype);
if (Core0_MoreCore (SizeInBytes,  McStat, (addrtype *)&TmpHndls))
{
TmpAddrs         = (addrtype *)TmpHndls;
for (i = -1; ++i < Vsize; )
TmpAddrs[i]    =  Varray[i];
for (i = Vsize - 1; ++i < UnitCount; )
TmpAddrs[i]    =  NullPtr;
for (i = - 1; ++i < Vsize; )
{
Index           = Vsize     * 2 + i;
Indx0           = UnitCount * 2 + i;
TmpHndls[Indx0] = Handles[Index];
}
MoveBytes     (TmpAddrs, Varray, UnitCount * 3);
Core0_FreeCore    ((addrtype *)&TmpHndls,  SizeInBytes, McStat);
}
}
} else
Vchunk_PutStackPtr (&Vtoken, UnitCount,  McStat,  Varray);
if (Normal(*Status)
&&  ClassBug)
Vchunk_Dump        (&Vtoken, McStat);
} else {
*Status = Image_ArrayWasNotCreated;
TraceMsg (0, " Image_ArrayAssertSize :: Array was not First Created.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"ImageArrayAssertSize\n");
return (STAT);
}
boolean ImageSubArrayAssertSize
(tokentype    *Token,    numtype       AttrNum,
indextype     Index,    numtype       UnitCount,
ft F,lt Z,zz *Status,   addrtype     *Varray)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
tokentype     BldDescTkn   = NullToken;
typedesctype *TypeDesc     = NullPtr;
addrtype      Object       = NullPtr;
numtype       ObjNum       = 0;
addrtype      DbObject     = NullPtr;
handletype   *Handles      = NullPtr;
addrtype     *ArrayPtrs    = NullPtr;
handletype   *ArrayHndls   = NullPtr;
tokentype     Vtoken       = NullToken;
indextype     Vsize        = 0;
sizetype      UnitSize     = 0;
*Varray         = 0;
AttrTkn.DbId   = RenvId;
Vtoken.DbId    = Token->DbId;
Vtoken.Handle  = 0;
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aDblPtrAttr)
{
BldDescTkn.DbId          =  RenvId;
BldDescTkn.Handle        =  AttrDesc->TypeObj;
if (OaGetObject  (&BldDescTkn,  McStat,  (addrtype *)&TypeDesc))
UnitSize      = TypeDesc->Size;
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotDblPtrType;
TraceMsg (0, " Image_SubArrayAssertSize :: Attribute Not DblPtr Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (Token->DbId)
if (TmFetchCoreDb     (Token,   McStat,                  &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,  Token->Handle,
McStat,                           &MemLoc))
if (MemLoc)
if (HmGetObjectAddr   (CoreDb,  Token->Handle,  McStat,  &Object))
if (OaRevokeCppObject (Token,                   McStat))
if (HmGetObjNum       (CoreDb,  Token->Handle,  McStat,  &ObjNum))
if (OaGetObject       (Token,                   McStat,  &DbObject))
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Get Internal DbObject of Class =%3u Of Image @%x As DB @%x\n",
ObjNum, Object, DbObject))
TraceMsg (0, Msg);
if (Normal (*Status))
if (KernelGetAttr     (Token,   AttrNum,   McStat,  (addrtype )&Vtoken))
if (MemLoc)
OaInvokeCppObject (Token,   Object,    McStat);
if (Normal (*Status))
if (Vtoken.Handle           > 0)
{
if (Vchunk_GetStackPtr (&Vtoken,        McStat,             &Vsize))
if (Index                < (Vsize /3))
{
Vsize                /= 3;
if (Vchunk_GetAddress  (&Vtoken,     McStat, (addrtype *)&ArrayPtrs))
{
ArrayHndls         = (handletype *)ArrayPtrs;
Handles            = (handletype *)&ArrayHndls[Vsize * 2];
if ((Vtoken.Handle = Handles[Index]) == 0)
{
if (VchunkCreate (Token,       UnitSize,            UnitCount,
1,           McStat,             &Vtoken))
if (VchunkPutStackPtr
(&Vtoken,     UnitCount,  McStat,  Varray))
Handles[Index] = Vtoken.Handle;
} else
Vchunk_PutStackPtr
(&Vtoken,     UnitCount,  McStat,  Varray);
if (Normal(*Status))
ArrayPtrs[Index] = Varray;
}
} else {
*Status                = Image_ArrayIndexOutOfRange;
TraceMsg (0,
" Image_SubArrayAssertSize :: Index of SubArray Out OfRange.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
sprintf (Msg, "         Index[%2u]  >= NumSubArrays(%4u).\n",
Index, Vsize/3);
TraceMsg (0, Msg);
}
} else {
*Status = Image_ArrayWasNotCreated;
TraceMsg (0, " Image_SubArrayAssertSize :: Array was not First Created.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"ImageSubArrayAssertSize\n");
return (STAT);
}
boolean ImageArrayDelete
(tokentype    *Token,    numtype       AttrNum,
ft F,lt Z,zz *Status)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
addrtype      Object       = NullPtr;
numtype       ObjNum       = 0;
addrtype      DbObject     = NullPtr;
handletype   *Handles      = NullPtr;
addrtype     *ArrayPtrs    = NullPtr;
handletype   *ArrayHndls   = NullPtr;
tokentype     Vtoken       = NullToken;
indextype     Vsize        = 0;
tokentype     VchunkTkn    = NullToken;
int           i            = 0;
AttrTkn.DbId   = RenvId;
Vtoken.DbId    = Token->DbId;
Vtoken.Handle  = 0;
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aDblPtrAttr
||  AttrDesc->AttrType        == aChunkAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotArrayType;
TraceMsg (0, " Image_ArrayDelete :: Attribute Not an Array Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (Token->DbId)
if (TmFetchCoreDb     (Token,   McStat,                  &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,  Token->Handle,
McStat,                           &MemLoc))
if (MemLoc)
if (HmGetObjectAddr   (CoreDb,  Token->Handle,  McStat,  &Object))
if (OaRevokeCppObject (Token,                   McStat))
if (HmGetObjNum       (CoreDb,  Token->Handle,  McStat,  &ObjNum))
if (OaGetObject       (Token,                   McStat,  &DbObject))
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Get Internal DbObject of Class =%3u Of Image @%x As DB @%x\n",
ObjNum, Object, DbObject))
TraceMsg (0, Msg);
if (Normal (*Status))
if (KernelGetAttr     (Token,   AttrNum,   McStat,      (addrtype )&Vtoken))
if (MemLoc    == 0)
KernelPutAttr     (Token,   AttrNum,   (addrtype )&NullToken,   McStat);
else {
if (OaInvokeCppObject       (Token,     Object,     McStat))
if (AttrDesc->AttrType       == aArrayAttr
||  AttrDesc->AttrType       == aDblPtrAttr)
KernelPutAttr  (Token,   AttrNum,   (addrtype )&NullAddr,    McStat);
else if (AttrDesc->AttrType  == aVarrayAttr)
KernelPutAttr  (Token,   AttrNum,   (addrtype )&NullVarray,  McStat);
else
KernelPutAttr  (Token,   AttrNum,   (addrtype )&NullVchunk,  McStat);
}
if (Normal (*Status))
if (Vtoken.Handle                > 0)
{
if (MemLoc                   == 0)
if (AttrDesc->AttrType       == aDblPtrAttr)
{
if (Vchunk_GetStackPtr (&Vtoken,    McStat,  (indextype *)&Vsize))
if (Vchunk_GetAddress  (&Vtoken,    McStat,  (addrtype  *)&ArrayPtrs))
{
Vsize                      /= 3;
ArrayHndls                  = (handletype *)ArrayPtrs;
Handles                     = (handletype *)&ArrayHndls[Vsize * 2];
VchunkTkn.DbId              = Vtoken.DbId;
for (i = -1; ++i < Vsize && Normal(*Status); )
{
if ((VchunkTkn.Handle    = Handles[i]) > 0)
Vchunk_Delete (&VchunkTkn, McStat);
}
}
} else
Vchunk_Delete          (&Vtoken,    McStat);
} else {
*Status = Image_ArrayWasNotCreated;
TraceMsg (0, " Image_ArrayDelete :: Array was not First Created.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"ImageArrayDelete\n");
return (STAT);
}
boolean ImageSubArrayDelete
(tokentype    *Token,    numtype       AttrNum,
indextype     Index,    ft F,lt Z,zz *Status)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
addrtype      Object       = NullPtr;
numtype       ObjNum       = 0;
addrtype      DbObject     = NullPtr;
int           i            = 0;
handletype   *Handles      = NullPtr;
addrtype     *ArrayPtrs    = NullPtr;
handletype   *ArrayHndls   = NullPtr;
tokentype     Vtoken       = NullToken;
indextype     Vsize        = 0;
AttrTkn.DbId   = RenvId;
Vtoken.DbId    = Token->DbId;
Vtoken.Handle  = 0;
if (EnvFetchAttrHandle (AttrNum,     McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aDblPtrAttr)
{
if (ClassBug || DeBug || OaBug)
{
sprintf (Msg, "        For AttrType = %s; AttrMame= %s\n",
AttrTypeNam[AttrDesc->AttrType], AttrDesc->Nam);
TraceMsg (0, Msg);
}
} else {
*Status = Image_AttrNotDblPtrType;
TraceMsg (0, " Image_SubArrayDelete :: Attribute Not DblPtr Type.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (Token->DbId)
if (TmFetchCoreDb     (Token,   McStat,                  &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,  Token->Handle,
McStat,                           &MemLoc))
if (MemLoc)
if (HmGetObjectAddr   (CoreDb,  Token->Handle,  McStat,  &Object))
if (OaRevokeCppObject (Token,                   McStat))
if (HmGetObjNum       (CoreDb,  Token->Handle,  McStat,  &ObjNum))
if (OaGetObject       (Token,                   McStat,  &DbObject))
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Get Internal DbObject of Class =%3u Of Image @%x As DB @%x\n",
ObjNum, Object, DbObject))
TraceMsg (0, Msg);
if (Normal (*Status))
if (KernelGetAttr     (Token,   AttrNum,   McStat,  (addrtype )&Vtoken))
if (MemLoc)
OaInvokeCppObject (Token,   Object,    McStat);
if (Normal (*Status))
if (Vtoken.Handle           > 0)
{
if (Vchunk_GetStackPtr (&Vtoken,        McStat,             &Vsize))
if (Index                < (Vsize /3))
{
if (Vchunk_GetAddress  (&Vtoken,     McStat, (addrtype *)&ArrayPtrs))
{
ArrayHndls         = (handletype *)ArrayPtrs;
Handles            = (handletype *)&ArrayHndls[Vsize/3*2];
if ((Vtoken.Handle = Handles[i]) > 0)
if (Vchunk_Delete   (&Vtoken,     McStat))
{
ArrayPtrs[i]    = NullPtr;
Handles[i]      = 0;
}
}
} else {
*Status                = Image_ArrayIndexOutOfRange;
TraceMsg (0,
" Image_SubArrayDelete :: Index of SubArray Out OfRange.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
sprintf (Msg, "         Index =%2u  GTR Size =%4u.\n",
Index, Vsize);
TraceMsg (0, Msg);
}
} else {
*Status = Image_ArrayWasNotCreated;
TraceMsg (0, " Image_SubArrayDelete :: Array was not First Created.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrNum);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"ImageSubArrayDelete\n");
return (STAT);
}
boolean ImageCreateVarray (tokentype    *DbmsToken, numtype   AttrNum,
indextype     UnitCount, sizetype  UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype *Varray)
{
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Image::CreateVarray DbmsObject[%2u:%4u] EnvAttr= %2u\n",
DbmsToken->DbId, DbmsToken->Handle, AttrNum))
TraceMsg (0, Msg);
C_CreateArray      (DbmsToken,   AttrNum,      UnitCount,  UnitSize,
McStat,      VchunkTkn,    Varray);
if (!Normal(*Status) || DeBug)
{
sprintf (Msg, "  Image::CreateVarray for Token[%2u:%4u] @%x\n",
DbmsToken->DbId, DbmsToken->Handle, *Varray);
TraceMsg (0, Msg);
if (DeBug || OaBug)
OaDumpObject    (0, DbmsToken, McStat);
} else {
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, "  Image::CreateVarray[%2u:%4u] @%x;\n",
VchunkTkn->DbId, VchunkTkn->Handle, *Varray))
TraceMsg (0, Msg);
}
TRACK(TrackBak,"ImageCreateVarray\n");
return (STAT);
}
boolean ImageGetVarray (tokentype     *VchunkTkn,
ft F,lt Z,zz  *Status,    indextype     *Vsize,
indextype     *VstackPtr, addrtype      *Varray)
{
chunkstruc  VchunkStruc;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
"\n Image_Get Varray from DB with Token[%2u:%4u]\n",
VchunkTkn->DbId, VchunkTkn->Handle))
TraceMsg (0, Msg);
if (VchunkGetAddress    (VchunkTkn, McStat,   Varray))
if (VchunkGetVstruc     (VchunkTkn, McStat,  &VchunkStruc))
{
*Vsize     = VchunkStruc.UnitCount;
*VstackPtr = VchunkStruc.StackPtr;
}
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, "\n Varray[%3u:%4u](*%4u) located at %8x Stack=%4u\n",
VchunkTkn->DbId, VchunkTkn->Handle, *Vsize, *Varray,
*VstackPtr))
TraceMsg (0, Msg);
TRACK(TrackBak,"ImageGetVarray\n");
return (STAT);
}
boolean ImagePutVarrayStackPtr
(tokentype     *VchunkTkn,  indextype   StackPtr,
ft F,lt Z,zz  *Status,
indextype     *Vsize,      addrtype   *Varray)
{
chunkstruc  VchunkStruc;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
"\n ImagePutVarray StackPtr = %4u for VarrayTkn[%2u:%4u]\n",
StackPtr, VchunkTkn->DbId, VchunkTkn->Handle))
TraceMsg (0, Msg);
if (VchunkPutStackPtr   (VchunkTkn, StackPtr, McStat, Varray))
if (VchunkGetVstruc     (VchunkTkn, McStat,  &VchunkStruc))
*Vsize = VchunkStruc.UnitCount;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, "\n Varray[%3u:%4u](*%4u) located at %8x Stack= %3u\n",
VchunkTkn->DbId, VchunkTkn->Handle, *Vsize,
*Varray,         StackPtr))
TraceMsg (0, Msg);
TRACK(TrackBak,"ImagePutVarrayStackPtr\n");
return (STAT);
}
boolean ImageGetVarrayStackPtr
(tokentype     *VchunkTkn,
ft F,lt Z,zz  *Status,     indextype  *StackPtr)
{
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
"\n Image_Put Varray StackPtr = %4u for VarrayTkn[%2u:%4u]\n",
StackPtr, VchunkTkn->DbId, VchunkTkn->Handle))
TraceMsg (0, Msg);
VchunkGetStackPtr (VchunkTkn, McStat, StackPtr);
TRACK(TrackBak,"ImageGetVarrayStackPtr\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\ifm.c*/

#define   IFM
#ifdef __MACROIZE_HM__
#endif
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)


boolean ImagePutFieldValue
(tokentype    *Token,    fieldstruc   *FS,
addrtype      Value,    ft F,lt Z,zz *Status)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
tokentype     BldDescTkn   = NullToken;
objdesctype  *BldDesc      = NullPtr;
sizetype      Offset       = 0;
tokentype     RefTkn       = NullToken;
addrtype      BytePtr      = NullPtr;
char         *StrPtr       = NullPtr;
numtype       AttrId       = FS->FieldTkns[FS->SubLevel-1].AttrId;
AttrTkn.DbId   = RenvId;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Image::PutFieldValue Object[%2u:%4u]    AttrId= %2u @%x\n",
Token->DbId, Token->Handle, AttrId, Value))
TraceMsg (0, Msg);
if (Token->DbId)
if (TmFetchCoreDb      (Token,       McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc  (CoreDb,      Token->Handle,
McStat,                             &MemLoc))
if (EnvFetchAttrHandle (AttrId,      McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType        == aChunkAttr
||  AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aDblPtrAttr)
{
*Status = Image_AttrNotPutArrayType;
TraceMsg (0, " Image_PutFieldValue:: Invalid Attribute Type for PutValue.\n");
TraceMsg (0, "    Arrays Must be instantiated with Array Methods.\n");
sprintf (Msg, "     for Token[%2u:%4u] AttrId= %4u.\n",
Token->DbId, Token->Handle, AttrId);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (AttrDesc->AttrType        == aStrHndlAttr)
{
StrPtr                      = (char *)Value;
if (sprintf (Msg, " Image::PutValue [%2u:%4u] String @%x := <%s>)\n",
Token->DbId, Token->Handle, Value,   StrPtr))
TraceMsg (0, Msg);
KernelPutField       (Token,   FS,     Value,     McStat);
} else if (AttrDesc->AttrType == aObjRefAttr) {
if (MemLoc                 == 0)
KernelPutField    (Token,   FS,  (addrtype )&Value,     McStat);
else {
BldDescTkn.DbId          =  RenvId;
BldDescTkn.Handle        =  AttrDesc->BuildDesc;
if (OaGetObject  (&BldDescTkn,  McStat,  (addrtype *)&BldDesc))
if (Env_FetchObjAttrOffset
(MemLoc,      BldDesc->ObjNum,      Token_Attr,
McStat,              &Offset))
{
BytePtr     = (addrtype )((char *)Value     + Offset);
MoveBytes     (BytePtr,  (addrtype )&RefTkn,   sizeof (tokentype));
if (RefTkn.DbId
&&  RefTkn.Handle)
KernelPutField
(Token,   FS,     (addrtype )&RefTkn, McStat);
}
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Image::PutFieldValue Reference[%2u:%4u]  @%x)\n",
RefTkn.DbId, RefTkn.Handle, *(addrtype **)Value))
TraceMsg (0, Msg);
}
} else
KernelPutField       (Token,   FS,     Value,     McStat);
TRACK(TrackBak,"ImagePutFieldValue\n");
return (STAT);
}
boolean ImageGetFieldValue (tokentype    *Token,    fieldstruc   *FS,
ft F,lt Z,zz *Status,   addrtype      Value)
{
dbheader     *CoreDb       = NullPtr;
numtype       MemLoc       = 0;
tokentype     AttrTkn      = NullToken;
attrdesctype *AttrDesc     = NullPtr;
tokentype     VchunkTkn    = NullToken;
vchunktype   *Vstruc       =  (vchunktype *)Value;
sizetype      Vsize        = 0;
addrtype      Image        = NullPtr;
addrtype      BytePtr      = NullPtr;
int           i            = 0;
handletype   *Handles      = NullPtr;
handletype   *ArrayPtrs    = NullPtr;
RefObj       *RefObjVal    = NullPtr;
numtype       AttrId       = FS->FieldTkns[FS->SubLevel-1].AttrId;
AttrTkn.DbId   = RenvId;
if (Token->DbId)
if (TmFetchCoreDb     (Token,        McStat,                &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc (CoreDb,       Token->Handle,
McStat,                              &MemLoc))
if (EnvFetchAttrHandle (AttrId,      McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (AttrDesc->AttrType == aObjRefAttr
&&  MemLoc             == 0)
KernelGetField      (Token,       FS,
McStat,                   (addrtype )&VchunkTkn);
else
KernelGetField      (Token,       FS,      McStat,        Value);
if (Normal(*Status))
if (MemLoc                    == 0)
if (AttrDesc->AttrType        == aArrayAttr
||  AttrDesc->AttrType        == aVarrayAttr
||  AttrDesc->AttrType        == aChunkAttr)
{
VchunkTkn.DbId              = Token->DbId;
VchunkTkn.CoreDbId          = 0;
MoveBytes   (Value, (addrtype )&VchunkTkn.Handle, sizeof (handletype));
if (AttrDesc->AttrType     == aArrayAttr)
{
if (VchunkTkn.Handle     > 0)
Vchunk_GetAddress  (&VchunkTkn,  McStat,  (addrtype *)Value);
else
MoveBytes   (&Image, Value,      sizeof (addrtype));
} else {
Vstruc->VchunkTkn        = VchunkTkn;
if (Vchunk_GetAddress  (&VchunkTkn,  McStat,         &Vstruc->Varray))
if (Vchunk_GetStackPtr (&VchunkTkn,  McStat,         &Vstruc->Vsize))
if (AttrDesc->AttrType  == aChunkAttr)
{
Vstruc->VstackPtr     = Vstruc->Vsize;
Vchunk_GetChunkSize (&VchunkTkn,  McStat, &Vstruc->Vsize, &Vsize);
}
}
} else if (AttrDesc->AttrType == aDblPtrAttr) {
VchunkTkn.DbId              = Token->DbId;
VchunkTkn.CoreDbId          = 0;
MoveBytes   (Value, (addrtype )&VchunkTkn.Handle, sizeof (handletype));
if (VchunkTkn.Handle        > 0)
{
if (Vchunk_GetAddress  (&VchunkTkn,  McStat, (addrtype *)&ArrayPtrs))
if (Vchunk_GetStackPtr (&VchunkTkn,  McStat,             &Vsize))
{
Vsize               /= 2;
Handles              = (handletype *)&ArrayPtrs[Vsize];
}
for (i = -1; ++i < Vsize && Normal(*Status); )
{
if ((VchunkTkn.Handle  = Handles[i]) > 0)
{
Vchunk_GetAddress (&VchunkTkn,
McStat,           (addrtype *)&ArrayPtrs[i]);
} else
ArrayPtrs[i]         = NullPtr;
}
if (Normal(*Status))
MoveBytes (&ArrayPtrs, Value,      sizeof (addrtype));
} else
MoveBytes   (&Image,     Value,      sizeof (addrtype));
} else if (AttrDesc->AttrType == aObjRefAttr) {
if (VchunkTkn.DbId
&&  VchunkTkn.Handle)
ImageGetObject         (&VchunkTkn,  McStat,         &Image);
MoveBytes      (&Image,     Value,      sizeof (addrtype));
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Image::GetValue Object[%2u:%4u] Reference @%x (Value := @%x)\n",
VchunkTkn.DbId, VchunkTkn.Handle,
Image,         *(addrtype **)Value))
TraceMsg (0, Msg);
} else if (AttrDesc->AttrType == aTknRefAttr) {
BytePtr    = (addrtype )((char *)Value     + sizeof (addrtype));
MoveBytes   (Value,  (addrtype )&VchunkTkn,  sizeof (tokentype));
if (sprintf (Msg, "  Get TknRef[%4u:%6u]Attr  Value @%8x; BytePtr @%8x\n",
VchunkTkn.DbId, VchunkTkn.Handle, Value, BytePtr))
TraceMsg (0, Msg);
MoveBytes   (&Image,                Value,   sizeof (addrtype));
MoveBytes   ((addrtype )&VchunkTkn, BytePtr, sizeof (tokentype));
}
if (Normal(*Status))
if (MemLoc                    == 1)
if (AttrDesc->AttrType        == aTknRefAttr)
{
if ((RefObjVal = *(RefObj **)Value) != NULL)
if (sprintf (Msg, "  Get TknRef[%4u:%6u]Attr  ObjAddr @%8x;\n",
RefObjVal->ObjTkn.DbId, RefObjVal->ObjTkn.Handle,
RefObjVal->ObjAddr))
TraceMsg (0, Msg);
}
TRACK(TrackBak,"ImageGetFieldValue\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\im.c*/

#define   IM
#ifndef INLINE_OMIDEFS
#else
#define        DbId_AttrNum               (numtype )3
#define        Id_AttrNum                 (numtype )143
#define        DbFileName_AttrNum         (numtype )158
#define        WenvDbs_Hndl            (handletype )692
#endif
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#define MemMakeChunk       Mem_MakeChunk
#define MemPutStackPtr     Mem_PutStackPtr
#define MemPushSomeBytes   Mem_PushSomeBytes
#define DbmLoadDbHdr       Dbm_LoadDbHdr







boolean ImageCreateDb     (char        *SchemaName,
char        *DbName,    char        *NewFileName,
dbaccesstype DbAccess,
ft F,lt Z,zz *Status,   tokentype   *DbToken)
{
if (Normal(*Status))
if (!KernelFindIn    (WenvDbs_Hndl,   &WenvTkn,   (addrtype )DbName,
McStat,          DbToken))
{
*Status = Env_Normal;
KernelCreateDb     (SchemaName,   DbName,   NewFileName,
DbAccess,
McStat,                 DbToken);
}
TRACK(TrackBak,"ImageCreateDb\n");
return (STAT);
}
boolean ImageConfigClass (tokentype    *PrimalTkn, numtype       ClassId,
numtype       RgnEntrys,
numtype       AllocRgns, numtype       ExtendRgns,
numtype       AllocXs,   numtype       ExtendXs,
accesstype    AccessType,boolean       DiskCache,
numtype       CacheLimit,numtype       CacheLoad,
ft F,lt Z,zz *Status)
{
OaConfigClass   (PrimalTkn,    ClassId,     RgnEntrys,    AllocRgns,
ExtendRgns,   AllocXs,     ExtendXs,     AccessType,
DiskCache,    CacheLimit,  CacheLoad,    McStat);
TRACK(TrackBak,"ImageConfigClass\n");
return (STAT);
}
boolean ImageDbCreate     (tokentype    *Anchor,  idtype        ClassId,
ft F,lt Z,zz *Status,  tokentype    *Token)
{
KernelCreateObject   (Anchor, ClassId, McStat, Token);
TRACK(TrackBak,"ImageDbCreate\n");
return (STAT);
}
boolean ImageNewObject (tokentype    *Anchor,   numtype    ClassId,
ft F,lt Z,zz *Status,
tokentype    *Token,    addrtype  *This)
{
if (OaCreateObject    (Anchor,   ClassId,  McStat,  Token))
if (C_ObjectNewImage  (Token,    ClassId,  C_Apl,   McStat,  This))
if (DeBug)
OaDumpObject    (0, Token, McStat);
TRACK(TrackBak,"ImageNewObject\n");
return (STAT);
}
boolean ImageGetObject (tokentype     *Token,
ft F,lt Z,zz  *Status,  addrtype      *This)
{
addrtype  That  = *This;
if (*This == NullPtr)
{
Build_ByCpp = False;
C_GetObjectImage (Token,   C_Apl,     McStat,    This);
} else {
Build_ByCpp = True;
C_FaxToThis      (Token,   That,      Cpp_Apl,   McStat);
if (!Normal(*Status) || DeBug || OaBug)
if (sprintf (Msg,
"  Image_GetObject for This @%x\n", That))
TraceMsg (0, Msg);
}
TRACK(TrackBak,"ImageGetObject\n");
return (STAT);
}
boolean ImageCreateObject (krnlobjtype  *This,    tokentype    *Anchor,
idtype        ClassId, numtype       AplId,
ft F,lt Z,zz *Status)
{
tokentype     DbToken;
if (DeBug || OaBug)
if (sprintf (Msg,
" Image::CreateObject Type[%2u] : Anchor[%2u:%4u]\n",
ClassId, Anchor->DbId, Anchor->Handle))
TraceMsg (0, Msg);
if (OaCreateObject   (Anchor,   (numtype  )ClassId,  McStat,  &DbToken))
if (C_FaxToThis      (&DbToken, (addrtype )This,     AplId,    McStat))
if (DeBug)
OaDumpObject    (0, &This->Token, McStat);
TRACK(TrackBak,"ImageCreateObject\n");
return (STAT);
}
boolean Image_IsActive (tokentype    *Token,
ft F,lt Z,zz *Status,   addrtype      *This)
{
dbheader   *CoreDb         = NullPtr;
numtype     MemLoc         = 0;
*This   = NullPtr;
if (TmGetCoreDb          (Token,                   McStat,   &CoreDb))
if (HmGetObjectMemLoc    (CoreDb,  Token->Handle,  McStat,   &MemLoc))
if (MemLoc)
{
HmGetObjectAddr    (CoreDb,    Token->Handle,  McStat,   This);
return (True);
}
STAT;
return (False);
}
boolean ImageCommitObject    (numtype       AplId,  tokentype    *Token,
addrtype      This,   boolean       Release,
ft F,lt Z,zz *Status)
{
bytessize   ImageSize   = 0;
if (ClassBug || DeBug || OaBug)
TraceMsg (0,  " ImageCommitObject ::\n");
if (AplId == Cpp_Apl)
{
C_ReFaxToDb     (Token,    This,       Release,   True,  AplId,
McStat,   &ImageSize);
} else if (AplId == C_Apl) {
C_ReFaxToDb     (Token,    This,       Release,   True,  AplId,
McStat,   &ImageSize);
} else
*Status = Err_NotImplemented;
TRACK(TrackBak,"ImageCommitObject\n");
return (STAT);
}
boolean ImageDeleteObject (tokentype    *Token,  numtype       AplId,
ft F,lt Z,zz *Status)
{
C_DeleteObject (Token, AplId, McStat);
TRACK(TrackBak,"ImageDeleteObject\n");
return (STAT);
}
boolean ImageDumpObject (tokentype *Token)
{
statustype ShellStatus  = Env_Normal;
OaDumpObject  (0,  Token, ShellMcStat);
return (ShellStatus ? True : False);
}
void    ImageDumpPseudo  (idtype        Ref_DbId,  numtype       ClassId,
addrtype      Pseudo)
{
return;
}
boolean ImageInitClassMap (numtype       ClassId, size_t        ObjSize,
numtype       AplId,   ft F,lt Z,zz *Status)
{
indextype    StackPtr  = 0;
f77tokentype F77Struct;
TransInitMap         (ClassId,    ObjSize,    AplId,  McStat);
if (AplId        == F77_Apl)
if (F77StructDir == 0)
if (Normal(*Status))
if (MemMakeChunk     (sizeof (f77tokentype),  50,            10,
RenvId,                 McStat,       &F77StructDir))
if (MemPutStackPtr   (F77StructDir,           0,             McStat))
MemPushSomeBytes (F77StructDir,            sizeof (f77tokentype),
(addrtype )&F77Struct,   McStat,       &StackPtr);
TRACK(TrackBak,"ImageInitClassMap\n");
return (STAT);
}
boolean ImageAppendToMap  (numtype       AttrId,  size_t      Offset,
numtype       AplId,   addrtype    AplStruct,
ft F,lt Z,zz *Status)
{
indextype   StackPtr  = 0;
TransAppendToMap     (AttrId,    Offset,  AplId,  McStat);
if (AplId          == F77_Apl)
MemPushSomeBytes (F77StructDir,            sizeof (f77tokentype),
(addrtype )AplStruct,    McStat,       &StackPtr);
TRACK(TrackBak,"ImageAppendToMap\n");
return (STAT);
}
boolean ImageInvokeMap    (numtype       AplId,   ft F,lt Z,zz *Status)
{
if (AplId == Cpp_Apl
||  AplId == C_Apl)
{
if (TransInvokeMap  (AplId,   McStat))
TransBuildMap   (AplId,   McStat);
} else if (AplId == F77_Apl) {
if (TransInvokeMap  (AplId,   McStat))
TransBuildMap   (AplId,   McStat);
} else
*Status = Err_NotImplemented;
TRACK(TrackBak,"ImageInvokeMap\n");
return (STAT);
}
boolean ImageGetClassMap (numtype       ClassId,   numtype       AplId,
ft F,lt Z,zz *Status,    classmaptype *ClassMap)
{
if (AplId == Cpp_Apl
||  AplId == C_Apl)
TransGetMap     (ClassId,   AplId,   McStat,  ClassMap);
else
*Status = Err_NotImplemented;
TRACK(TrackBak,"ImageGetClassMap\n");
return (STAT);
}
boolean ImageFreeClassById   (numtype       AplId,  idtype        DbId,
numtype       ClassId,ft F,lt Z,zz *Status)
{
if (AplId == Cpp_Apl)
{
C_FreeClass     (DbId,     ClassId,   AplId,    McStat);
} else if (AplId == C_Apl) {
C_FreeClass     (DbId,     ClassId,   AplId,    McStat);
} else
*Status = Err_NotImplemented;
TRACK(TrackBak,"ImageFreeClassById\n");
return (STAT);
}
boolean ImageFreeClass       (numtype       AplId,  tokentype    *Token,
ft F,lt Z,zz *Status)
{
dbheader   *CoreDb         = NullPtr;
numtype     ClassId        = 0;
if (TmGetCoreDb          (Token,                   McStat,   &CoreDb))
if (HmGetObjNum          (CoreDb,  Token->Handle,  McStat,   &ClassId))
if (AplId == Cpp_Apl)
{
C_FreeClass     (Token->DbId,     ClassId,   AplId,  McStat);
} else if (AplId == C_Apl) {
C_FreeClass     (Token->DbId,     ClassId,   AplId,  McStat);
} else
*Status = Err_NotImplemented;
TRACK(TrackBak,"ImageFreeClass\n");
return (STAT);
}
boolean ImageCommitClass  (numtype       AplId,   tokentype    *Token,
numtype       ClassId, ft F,lt Z,zz *Status)
{
if (AplId == Cpp_Apl)
{
C_CommitClass     (Token,  ClassId,  AplId,    McStat);
} else if (AplId == C_Apl) {
C_CommitClass     (Token,  ClassId,  AplId,    McStat);
} else
*Status = Err_NotImplemented;
TRACK(TrackBak,"ImageCommitClass\n");
return (STAT);
}
boolean Image_GetClassObjectCount
(tokentype    *Token,   numtype       ClassId,
ft F,lt Z,zz *Status,  numtype      *Count)
{
Kernel_GetClassObjectCount (Token, ClassId, McStat, Count);
TRACK(TrackBak,"ImageGetClassObjectCount\n");
return (STAT);
}
boolean ImageFaxToThis       (numtype       AplId,  tokentype    *Token,
addrtype      This,   ft F,lt Z,zz *Status)
{
if (AplId == Cpp_Apl)
{
Build_ByCpp = True;
C_FaxToThis     (Token,    This,   AplId,    McStat);
} else if (AplId == C_Apl) {
Build_ByCpp = False;
C_FaxToThis     (Token,    This,   AplId,    McStat);
} else
*Status = Err_NotImplemented;
TRACK(TrackBak,"ImageFaxToThis\n");
return (STAT);
}
boolean ImageAssertToThis    (tokentype    *Token,    addrtype     Object,
ft F,lt Z,zz *Status)
{
numtype      MemLoc    = 0;
dbheader    *CoreDb    = NullPtr;
if (Token->DbId)
{
if (DeBug || OaBug)
OaDumpObject    (0,        Token,         McStat);
if (TmFetchCoreDb    (Token,    McStat,       &CoreDb))
if (CoreDb)
if (HmGetObjectMemLoc
(CoreDb,   Token->Handle, McStat,   &MemLoc))
if (!MemLoc)
{
if (HmPutObjectMemLoc
(CoreDb,   Token->Handle, 1,        McStat))
HmPutObjectAddr
(CoreDb,   Token->Handle, Object,   McStat);
} else
*Status = Cpp_DbNotActivated;
} else
*Status = Cpp_InvalidToken;
TRACK(TrackBak,"ImageAssertToThis\n");
return (STAT);
}
boolean ImageGetActiveObject
(numtype       ClassId,  tokentype    *Token,
ft F,lt Z,zz *Status,   addrtype     *Object)
{
addrtype     NewObject = NullPtr;
numtype      MemLoc    = 0;
dbheader    *CoreDb    = NullPtr;
numtype      ObjNum    = 0;
*Object = NullPtr;
if (Token->DbId)
{
if (TmFetchCoreDb    (Token,    McStat,       &CoreDb))
if (CoreDb)
{
if (HmGetObjNum   (CoreDb,   Token->Handle, McStat,   &ObjNum))
if (ObjNum == ClassId)
{
if (HmGetObjectMemLoc
(CoreDb,   Token->Handle, McStat,   &MemLoc))
if (MemLoc)
{
OaGetObject (Token,                   McStat,   &NewObject);
*Object = NewObject;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
"  Return Address Of Object IN OuterRealm @%x\n",
*Object))
TraceMsg (0, Msg);
} else
*Status = Cpp_ObjectNotActivated;
} else
*Status = Cpp_NotOfThisClass;
} else
*Status = Cpp_DbNotActivated;
} else
*Status = Cpp_InvalidToken;
TRACK(TrackBak,"ImageGetActiveObject\n");
return (STAT);
}
boolean ImageReFaxToDb        (numtype       AplId,
tokentype    *Token,   addrtype      This,
boolean       Release, boolean       FreeMem,
ft F,lt Z,zz *Status)
{
bytessize   ImageSize   = 0;
if (AplId == Cpp_Apl)
{
C_ReFaxToDb     (Token,    This,      Release,   FreeMem,  AplId,
McStat,  &ImageSize);
} else if (AplId == C_Apl) {
C_ReFaxToDb     (Token,    This,      Release,   FreeMem,  AplId,
McStat,  &ImageSize);
} else
*Status = Err_NotImplemented;
TRACK(TrackBak,"ImageReFaxToDb\n");
return (STAT);
}
boolean ImageFreeDbObject        (numtype       AplId,  tokentype    *Token,
ft F,lt Z,zz *Status)
{
if (AplId == Cpp_Apl)
{
C_FreeObject     (Token,    AplId,    True,     McStat);
} else if (AplId == C_Apl) {
C_FreeObject     (Token,    AplId,    True,     McStat);
} else
*Status = Err_NotImplemented;
TRACK(TrackBak,"ImageFreeDbObject\n");
return (STAT);
}
boolean ImageFreeCppObject
(tokentype    *Token,     boolean       FreeImage,
ft F,lt Z,zz *Status)
{
C_FreeObject     (Token,    Cpp_Apl,    FreeImage,     McStat);
TRACK(TrackBak,"ImageFreeCppObject\n");
return (STAT);
}
boolean ImageRevokeObject (numtype       AplId,  tokentype    *Token,
ft F,lt Z,zz *Status)
{
if (AplId == Cpp_Apl)
OaRevokeCppObject (Token,  McStat);
else
*Status = Err_NotImplemented;
TRACK(TrackBak,"ImageRevokeObject\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\km.c*/

#define  KRNL
#ifdef __NOSTR__
#endif
#ifndef INLINE_OMIDEFS
#else
#define        ObjNum_AttrNum             (numtype )5
#define        lOwnerObject_AttrNum       (numtype )87
#define        SchemaPrimalDesc_AttrNum   (numtype )157
#define        TraitObjs_Hndl         (handletype )668
#define        RenvSchemas_Hndl       (handletype )684
#endif
#define MemGetWord           Mem_GetWord
#define MemGetObjNum         Mem_GetWord
#define MemGetSize           Mem_GetWord

boolean KernelCreateDb    (char         *SchemaNam,
char         *DbName,    char       *NewFile,
dbaccesstype  DbAccess,
ft F,lt Z,zz *Status,    tokentype  *DbPrimal)
{
tokentype   SchemaTkn       = NullToken;
tokentype   PrimalDescTkn   = NullToken;
numtype     PrimalObjNum    = 0;
statustype  DumpStatus      = Env_Normal;
int         TmpDeBug        = DeBug;
SchemaTkn.DbId     = RenvTkn.DbId;
PrimalDescTkn.DbId = RenvTkn.DbId;
if (KernelFindIn  (RenvSchemas_Hndl, &RenvTkn,     (addrtype )SchemaNam,
McStat,           &SchemaTkn))
{
*Status = Env_Normal;
DeBug  = TmpDeBug;
if (DeBug || OaBug)
if (TraceMsg      (0, "  The Schema Primal Descriptor ::\n"))
OaDumpObject  (0,                &SchemaTkn,   Dump_Status);
if (KernelGetAttr (&SchemaTkn,        SchemaPrimalDesc_AttrNum,
McStat,           &PrimalDescTkn))
if (DeBug || OaBug)
OaDumpObject  (0,                &PrimalDescTkn,   Dump_Status);
if (Normal(*Status))
if (KernelGetAttr (&PrimalDescTkn,    ObjNum_AttrNum,
McStat,           &PrimalObjNum))
OaCreateDb    (&SchemaTkn,        PrimalObjNum,
DbName,            NewFile,       DbAccess,
McStat,            DbPrimal);
} else if (*Status == Set_NotFound) {
sprintf  (Msg, "  Schema[%-14s] Not in RenvSchemas\n", SchemaNam);
TraceMsg (0, Msg);
}
DeBug = TmpDeBug;
TRACK(TrackBak,"KernelCreateDb\n");
return (STAT);
}
boolean  KernelLoadDbHdr    (tokentype    *DbToken,  char       *DbFileName,
ft F,lt Z,zz *Status)
{
dbheader  *CoreDb  = NullPtr;
DbmLoadDbHdr   (DbToken,  DbFileName,  McStat,  &CoreDb);
TRACK(TrackBak,"KernelLoadDb\n");
return (STAT);
}
boolean KernelFreezeObjClass
(tokentype    *Anchor,    numtype       EnvObj,
ft F,lt Z,zz *Status)
{
OaFreezeObjClass (Anchor,  EnvObj,  McStat);
TRACK(TrackBak,"KernelDeleteDb\n");
return (STAT);
}
boolean Kernel_GetClassObjectCount
(tokentype    *Token,   numtype       EnvObj,
ft F,lt Z,zz *Status,  numtype      *Count)
{
dbheader    *CoreDb     = NullPtr;
objheader   *ObjHdr     = NullPtr;
localnumtype LocalObj   = 0;
vbntype      Vbn        = 0;
*Count                = 0;
if (TmFetchCoreDb    (Token,                  McStat,  &CoreDb))
if (Mem_GetWord      (CoreDb->LocalObjNumMap, EnvObj,   McStat, &LocalObj))
if (LocalObj)
{
if (Mem_GetAddr    (CoreDb->ObjHdrDir,      LocalObj,
McStat,                 (addrtype *)&ObjHdr))
if (ObjHdr == NullPtr)
{
if (CoreDb->ObjVbnDirVbn)
{
if (Mem_GetWord
(CoreDb->ObjVbnDir,      LocalObj,
McStat,                &Vbn))
if (Vbn)
{
if (DbmLoadObjHdr
(Token,  LocalObj,       McStat,     &ObjHdr))
*Count  = ObjHdr->ObjectCount - ObjHdr->ExObjectCount;
}
}
} else
*Count           = ObjHdr->ObjectCount - ObjHdr->ExObjectCount;
}
TRACK(TrackBak,"Kernel_GetClassObjectCount\n");
return (STAT);
}
boolean  KernelNew          (tokentype    *Anchor,    numtype      EnvObj,
ft F,lt Z,zz *Status,
tokentype    *Token,     addrtype    *ObjAddr)
{
if (OaCreateObject  (Anchor,  EnvObj,   McStat,  Token))
OaGetObject     (Token,   McStat,   ObjAddr);
TRACK(TrackBak,"KernelNew\n");
return (STAT);
}
boolean  KernelCreateObject (tokentype    *Anchor,    numtype      EnvObj,
ft F,lt Z,zz *Status,    tokentype   *Token)
{
OaCreateObject  (Anchor,  EnvObj,   McStat,  Token);
TRACK(TrackBak,"KernelCreateObject\n");
return (STAT);
}
boolean  KernelNewObject   (tokentype    *Anchor,  numtype    EnvObj,
numtype       NumInits,
numtype      *AttrNums,addrtype  *Values,
ft F,lt Z,zz *Status,  tokentype *Token)
{
if (OaCreateObject  (Anchor,  EnvObj,   McStat,   Token))
OaInitObject    (Token,   NumInits, AttrNums, Values,  McStat);
TRACK(TrackBak,"KernelNewObject\n");
return (STAT);
}
boolean  KernelCreateArray (tokentype   *DbmsToken,  numtype   AttrNum,
indextype    UnitCount,  sizetype  UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype *ArrayAddr)
{
OaCreateArray  (DbmsToken,       AttrNum,      UnitCount,   UnitSize,
McStat,          VchunkTkn,    ArrayAddr);
TRACK(TrackBak,"KernelCreateArray\n");
return (STAT);
}
boolean  KernelCreateVarray (tokentype   *DbmsToken,  numtype   AttrNum,
indextype    UnitCount,  sizetype  UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype *ArrayAddr)
{
OaCreateVarray (DbmsToken,       AttrNum,      UnitCount,   UnitSize,
McStat,          VchunkTkn,    ArrayAddr);
TRACK(TrackBak,"KernelCreateVarray\n");
return (STAT);
}
boolean KernelIamA        (tokentype    *Token,     numtype   EnvObj,
ft F,lt Z,zz *Status)
{
numtype       ObjNum        = 0;
tokentype     ObjCestrsTkn;
bytetype      BitVal        = 1;
if (Token->DbId   == 0
&&  Token->Handle  > 0)
ObjNum = Token->Handle;
else
EnvFetchObjNum     (Token,         McStat,           &ObjNum);
if (Normal(*Status))
if (ObjNum != EnvObj)
if (EnvFetchObjCestrs  (ObjNum,        McStat,           &ObjCestrsTkn))
if (KernelGetBit       (&ObjCestrsTkn, EnvObj,  McStat,  &BitVal))
if (!BitVal)
*Status = Kernl_IamNot;
if (ClassBug || DeBug)
if (sprintf (Msg, "   Kernel_IamA (Obj =%2u)... for [%2u:%4u] = %s\n",
ObjNum, Token->DbId, Token->Handle, BoolStr[BitVal]))
TraceMsg (0, Msg);
TRACK(TrackBak,"KernelIamA\n");
return (STAT);
}
boolean KernelWhatAmI     (tokentype    *Token,
ft F,lt Z,zz *Status,    numtype   *EnvObj)
{
if (Token->DbId   == 0
&&  Token->Handle  > 0)
*EnvObj = Token->Handle;
else
EnvFetchObjNum      (Token,         McStat,           EnvObj);
TRACK(TrackBak,"KernelWhatAmI\n");
return (STAT);
}
boolean KernelGet         (tokentype    *Token,
ft F,lt Z,zz *Status,    addrtype *ObjAddr)
{
OaGetObject (Token, McStat, ObjAddr);
TRACK(TrackBak,"KernelGet\n");
return (STAT);
}
boolean KernelGetObject   (tokentype    *Token,     numtype   EnvObjNum,
ft F,lt Z,zz *Status,    addrtype  Object)
{
addrtype   ObjectAddr = NullPtr;
if (OaGetObject (Token, McStat, &ObjectAddr))
MoveBytes (ObjectAddr, Object, ObjHdrSize[EnvObjNum]);
TRACK(TrackBak,"KernelGetObject\n");
return (STAT);
}
boolean KernelPutObject   (tokentype  *Token,     numtype       EnvObjNum,
addrtype    Object,    ft F,lt Z,zz *Status)
{
addrtype   ObjectAddr = NullPtr;
if (OaGetObject (Token, McStat, &ObjectAddr))
MoveBytes (Object, ObjectAddr, ObjHdrSize[EnvObjNum]);
TRACK(TrackBak,"KernelPutObject\n");
return (STAT);
}
boolean    KernelGetAttrInfo
(numtype       AttrId,
ft F,lt Z,zz *Status,     attrobjtype *AttrInfo)
{
dbheader       *CoreDb          = NullPtr;
tokentype       AttrToken       = NullToken;
attrdesctype   *AttrDesc        = NullPtr;
indextype       LocalAttrNum    = 0;
sizetype        AttrSize        = 0;
AttrToken.DbId       = RenvId;
CoreDb               = CoreDbs[RenvId];
if (EnvFetchAttrHandle
(AttrId,
McStat,                     &(AttrToken.Handle)))
if (KernelGet       (&AttrToken,   McStat,       (addrtype *)&AttrDesc))
if (MemGetObjNum    (CoreDb->LocalAttrNumMap,    (indextype )AttrId,
McStat,                     &LocalAttrNum))
if (MemGetSize      (CoreDb->LocalAttrSizeTbl,   (indextype )LocalAttrNum,
McStat,                     (word *)&AttrSize))
{
strcpy (AttrInfo->AttrName,      AttrDesc->Nam);
AttrInfo->AttrType            =  AttrDesc->AttrType;
AttrInfo->CppType             =  AttrDesc->CppType;
AttrInfo->TypeType            =  AttrDesc->TypeType;
AttrInfo->Size                =  AttrSize;
}
TRACK(TrackBak,"KernelGetAttrInfo\n");
return (STAT);
}
boolean Kernel_GetFieldStruc
(char         *FieldName,
ft F,lt Z,zz *Status,    fieldstruc   *FieldStruc)
{
tokentype    AttrTkn    = NullToken;
numtype      AttrId;
nametype     AttrNam;
static char  WildOps[3] = {".["};
size_t       StrSize    = 0;
char        *StrSeg     = NullPtr;
char         IntNam[10];
size_t       MaxSize    = strlen (FieldName);
int          i          = 0;
AttrNam[0] = '\0';
IntNam[0]  = '\0';
if (ClassBug)
if (sprintf (Msg, " Kernel_GetFieldStruc for MemberName= <%21s>\n",
FieldName))
TraceMsg   (0, Msg);
FieldStruc->SubLevel     = 0;
FieldStruc->IsIndexed    = False;
strcpy                    (FieldStruc->FieldName, FieldName);
StrSize                  = MaxSize;
#ifndef __NOSTR__
while (Normal(*Status)
&&     FieldName[0]     != '\0')
{
if ((StrSeg           = strpbrk (FieldName,  WildOps)) != NULL)
{
StrSize            = StrSeg  - FieldName;
strncpy  (AttrNam, FieldName, StrSize);
AttrNam[StrSize]   = '\0';
} else {
strcpy   (AttrNam, FieldName);
StrSize            = strlen (FieldName);
}
if (ClassBug || SetBug)
if (sprintf (Msg, " Truncated Name:= <%s> size=%3u\n",
AttrNam, strlen (AttrNam)))
TraceMsg   (0, Msg);
if (KernelFindIn     (RenvDescs_Hndl,               &RenvTkn,
(addrtype )AttrNam,
McStat,          (tokentype *)&AttrTkn))
if (KernelGetAttr    (&AttrTkn,                      AttrNum_AttrNum,
McStat,          (addrtype   )&AttrId))
{
if (ClassBug)
if (sprintf (Msg, "               AttrId             = %3u\n",
AttrId))
TraceMsg (0, Msg);
FieldStruc->FieldTkns[FieldStruc->SubLevel].AttrId  = AttrId;
FieldStruc->FieldTkns[FieldStruc->SubLevel].Index   = 0;
FieldStruc->SubLevel                               += 1;
}
if (Normal(*Status))
{
i=0;
while (i++ < StrSize)
++FieldName;
if (FieldName[0] == '[')
{
++FieldName;
if ((StrSeg    = strpbrk (FieldName, "]")) != NULL)
{
StrSize           = StrSeg - FieldName;
strncpy  (IntNam, FieldName, StrSize);
IntNam[StrSize]   = '\0';
FieldStruc->FieldTkns[FieldStruc->SubLevel - 1].Index
= atoi (IntNam);
FieldName         = StrSeg;
++FieldName;
if (FieldName[0] == '\0')
FieldStruc->IsIndexed    = True;
} else
*Status = Lex_BadSyntax;
}
if (FieldName[0] == '.')
++FieldName;
if (ClassBug)
if (sprintf (Msg, "               Index              = %3u\n",
FieldStruc->FieldTkns[FieldStruc->SubLevel - 1].Index))
TraceMsg (0, Msg);
}
}
#endif
TRACK(TrackBak,"Kernel_GetFieldStruc\n");
return (STAT);
}
boolean    KernelGetFieldInfo
(fieldstruc   *FieldStruc,
ft F,lt Z,zz *Status,     attrobjtype *AttrInfo)
{
numtype         AttrId          = 0;
AttrId             = FieldStruc->FieldTkns[FieldStruc->SubLevel-1].AttrId;
KernelGetAttrInfo  (AttrId,   McStat,  AttrInfo);
TRACK(TrackBak,"KernelGetFieldInfo\n");
return (STAT);
}
boolean    KernelPutAttr (tokentype   *Token,      numtype    EnvAttrNum,
addrtype     Value,      ft F,lt Z,zz *Status)
{
addrtype     Object       = NullPtr;
OaPut (False, Token, Object, EnvAttrNum, Value, McStat);
TRACK(TrackBak,"KernelPutAttr\n");
return (STAT);
}
boolean    KernelGetAttr (tokentype    *Token,      numtype   EnvAttrNum,
ft F,lt Z,zz *Status,     addrtype  Value )
{
addrtype     Object       = PtrToVoid;
OaGet (False, Token, Object, EnvAttrNum, McStat, Value);
TRACK(TrackBak,"KernelGetAttr\n");
return (STAT);
}
boolean    KernelPutField
(tokentype    *Token,     fieldstruc   *FieldStruc,
addrtype      Value,     ft F,lt Z,zz *Status)
{
OaPutField    (Token, FieldStruc, Value, McStat);
TRACK(TrackBak,"KernelPutField\n");
return (STAT);
}
boolean    KernelGetField
(tokentype    *Token,     fieldstruc   *FieldStruc,
ft F,lt Z,zz *Status,    addrtype      Value)
{
OaGetField    (Token,  FieldStruc,  McStat,  Value);
TRACK(TrackBak,"KernelGetField\n");
return (STAT);
}
int        KernelCompare (tokentype   *Token,      numtype       AttrNum,
addrtype     Value,      ptr_cmp       CmpCode,
ft F,lt Z,zz *Status)
{
addrtype     Object       = NullPtr;
int          i            = 0;
OaCompare (False, Token, Object, AttrNum, Value, CmpCode, McStat);
if (Normal(*Status))
return (0);
if (*Status  == Oa_GtrThen)
{
*Status = Env_Normal;
return (1);
} else if (*Status  == Oa_LessThen) {
*Status = Env_Normal;
return (-1);
}
STAT;
TRACK(TrackBak,"KernelCompare\n");
return (i);
}
int        KernelFieldCompare
(tokentype   *Token,      fieldstruc   *FieldStruc,
addrtype     Value,      ptr_cmp       CmpCode,
ft F,lt Z,zz *Status)
{
addrtype     Object       = NullPtr;
int          i            = 0;
i = OaCompareField (False,  Token,     Object,  FieldStruc,
Value,  CmpCode,            McStat);
STAT;
TRACK(TrackBak,"KernelCompare\n");
return (i);
}
boolean  KernelCreateBitField
(tokentype    *Anchor,      sizetype   AllocBits,
ft F,lt Z,zz *Status,
tokentype    *BitFieldTkn)
{
bitfieldtype *BitField   = NullPtr;
sizetype      NumBits    = (AllocBits | 7)+1;
indextype     AllocBytes =  NumBits / 8;
if (OaCreateVchunk  (Anchor,      sizeof (bitfieldtype),
AllocBytes,  Extend_BitField,
McStat,      BitFieldTkn))
if (OaGetVchunkAddr (BitFieldTkn, McStat,  (addrtype *)&BitField))
if (OaPutVchunkStackPtr
(BitFieldTkn, AllocBytes,   McStat))
memset          (BitField,    '\0',         AllocBytes);
TRACK(TrackBak,"KernelCreateBitField\n");
return (STAT);
}
boolean  KernelDeleteBitField
(tokentype    *BitFieldTkn, ft F,lt Z,zz *Status)
{
OaDeleteVchunk  (BitFieldTkn, McStat);
TRACK(TrackBak,"KernelDeleteBitField\n");
return (STAT);
}
boolean  KernelPutBit     (tokentype    *BitFieldTkn,    indextype     BitNum,
bytetype      BitValue,       ft F,lt Z,zz *Status)
{
bitfieldtype    *BitField  = NullPtr;
indextype        ByteNum   = BitNum >> 3;
indextype        ByteCount = 0;
numtype          Value     = 0;
if (OaGetVchunkStackPtr  (BitFieldTkn, McStat,  &ByteCount))
if (ByteNum >= ByteCount)
OaPutVchunkStackPtr  (BitFieldTkn, ByteNum,  McStat);
if (Normal(*Status))
if (OaGetVchunkAddr      (BitFieldTkn, McStat,  (addrtype *)&BitField))
BitField[ ByteNum ] |= BitValue << (BitNum & 7);
if (Normal(*Status))
Value =  (BitField[BitNum >> 3] & 1 << (BitNum & 7)) ? 1: 0;
if (Value != BitValue)
if (sprintf (Msg, "   ERROR... Kernel_PutBit[%4u] @byte %3u =%u\n",
BitNum, ByteNum, BitValue))
SendMsg (0, Msg);
TRACK(TrackBak,"KernelPutBit\n");
return (STAT);
}
boolean  KernelGetBit     (tokentype    *BitFieldTkn,    indextype  BitNum,
ft F,lt Z,zz *Status,         bytetype  *BitValue)
{
indextype        ByteNum   = BitNum >> 3;
bitfieldtype    *BitField  = NullPtr;
indextype        ByteCount = 0;
if (OaGetVchunkAddr (BitFieldTkn, McStat,  (addrtype *)&BitField))
if (OaGetVchunkStackPtr
(BitFieldTkn, McStat,  &ByteCount))
if (ByteNum >= ByteCount)
*Status = Set_IndexGtrAllocRoots;
if (Normal(*Status))
*BitValue =  (BitField[BitNum >> 3] & 1 << (BitNum & 7)) ? 1: 0;
if (DeBug || OaBug)
if (sprintf (Msg, "   Kernel_GetBit[%4u] Value=%u from Byte %2u\n",
BitNum, BitValue, ByteNum))
TraceMsg (0, Msg);
TRACK(TrackBak,"KernelGetBit\n");
return (STAT);
}
boolean  KernelFirstBit   (tokentype    *BitFieldTkn,
ft F,lt Z,zz *Status,         indextype *FirstBit)
{
bitfieldtype    *BitField;
indextype        BitNum    = 0;
indextype        ByteCount = 0;
if (!BitFieldTkn->Handle)
*Status = Set_EmptySet;
if (Normal(*Status))
if (OaGetVchunkAddr (BitFieldTkn, McStat,  (addrtype *)&BitField))
if (OaGetVchunkStackPtr
(BitFieldTkn, McStat,  &ByteCount))
if (!ByteCount)
*Status = Set_EmptySet;
while (Normal(*Status)
&&   !( (BitField[BitNum >> 3] & 1 << (BitNum & 7)) )  ) {
if (++BitNum / 8 >= ByteCount)
*Status = Set_EndOfSet;
}
*FirstBit    = BitNum;
TRACK(TrackBak,"KernelFirstBit\n");
return (STAT);
}
boolean  KernelNextBit    (tokentype    *BitFieldTkn,    indextype  CurrBitNum,
ft F,lt Z,zz *Status,         indextype *NextBitNum)
{
bitfieldtype    *BitField;
indextype        BitNum    = CurrBitNum;
indextype        ByteCount = 0;
if (OaGetVchunkAddr (BitFieldTkn, McStat,  (addrtype *)&BitField))
if (OaGetVchunkStackPtr
(BitFieldTkn, McStat,  &ByteCount))
do {
if (++BitNum / 8 >= ByteCount)
*Status = Set_EndOfSet;
} while (Normal(*Status)
&&   !( (BitField[BitNum >> 3] & 1 << (BitNum & 7)) )  );
*NextBitNum = BitNum;
TRACK(TrackBak,"KernelNextBit\n");
return (STAT);
}
boolean KernelOwnerOf    (handletype    SetHndl,   tokentype *Member,
ft F,lt Z,zz *Status,    tokentype *Owner)
{
tokentype        SetDescTkn;
setdesctype     *SetDesc     = NullPtr;
tokentype        SetHeadTkn;
tokentype        SetNodeTkn;
addrtype         Dummy       = NullPtr;
Owner->DbId       = Member->DbId;
SetHeadTkn.DbId   = Member->DbId;
SetNodeTkn.DbId   = Member->DbId;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetHndl;
if (OaGetObject (&SetDescTkn,   McStat,   (addrtype *)&SetDesc))
if (OaGet       (False,         Member,   Dummy,
SetDesc->MemberAttrNum,
McStat,        (addrtype )&SetNodeTkn))
if (SetNodeTkn.Handle == NullHandle)
*Status = Set_EmptySet;
SetHeadTkn.DbId   = SetNodeTkn.DbId;
Owner->DbId       = SetNodeTkn.DbId;
if (Normal(*Status))
if (SetDesc->SetType == aIndexedSet)
{
Owner->Handle = SetNodeTkn.Handle;
} else if (SetDesc->SetType == aGlobalKeyedSet)  {
if (OaGet       (False,        &SetNodeTkn,   Dummy,
lOwnerObject_AttrNum,
McStat,        (addrtype )&(SetHeadTkn.Handle)))
OaGet       (False,        &SetHeadTkn,   Dummy,
lOwnerObject_AttrNum,
McStat,        (addrtype )&(Owner->Handle));
} else {
if (OaGet       (False,        &SetNodeTkn,   Dummy,
lOwnerObject_AttrNum,
McStat,        (addrtype )&(SetHeadTkn.Handle)))
OaGet       (False,        &SetHeadTkn,   Dummy,
lOwnerObject_AttrNum,
McStat,        (addrtype )&(Owner->Handle));
}
TRACK(TrackBak,"KernelOwnerOf\n");
return (STAT);
}
boolean KernelFirstOf    (handletype    SetHndl,    tokentype *Owner,
ft F,lt Z,zz *Status,     tokentype *FirstNode,
tokentype   *FirstMember)
{
SetFirstOf (SetHndl, Owner, McStat, FirstNode, FirstMember);
TRACK(TrackBak,"KernelFirstOf\n");
return (STAT);
}
boolean KernelNextOf     (handletype    SetHndl,    tokentype *CurrentNode,
ft F,lt Z,zz *Status,     tokentype *NextNode,
tokentype    *NextMember)
{
SetNextOf (SetHndl, CurrentNode, McStat, NextNode, NextMember);
TRACK(TrackBak,"KernelNextOf\n");
return (STAT);
}
boolean KernelAddInto     (handletype   SetDescHndl,  tokentype    *OwnerTkn,
tokentype   *MemberTkn,    ft F,lt Z,zz *Status)
{
SetAddInto (SetDescHndl, OwnerTkn, MemberTkn, McStat);
TRACK(TrackBak,"KernelAddInto\n");
return (STAT);
}
boolean KernelFindIn     (handletype    SetDescHndl,  tokentype    *OwnerTkn,
addrtype      KeyValue,
ft F,lt Z,zz *Status,       tokentype    *MemberTkn)
{
SetFindIn (SetDescHndl, OwnerTkn, KeyValue, McStat, MemberTkn);
TRACK(TrackBak,"KernelFindIn\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\list01.c*/

#define LIST01_C











boolean   List01_Init    (ft F,lt Z,zz *Status)
{
if (DbListNode_Class == 0)
{
if (Env_GetClassId   ("DbListHead",        McStat, &DbListHead_Class))
Env_GetClassId   ("DbListNode",        McStat, &DbListNode_Class);
if (sprintf (Msg, " LIST HEADS  loaded ... DbListHead_Class = %2u\n",
DbListHead_Class))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "                        DbListNode_Class = %2u\n",
DbListNode_Class))
TraceMsg (0, Msg);
}
TRACK(TrackBak,"List01_Init\n");
return(STAT);
}
boolean List01_Create    (tokentype    *Anchor,    tokentype    *Owner,
char         *NameOfList,
numtype       CompCode,  numtype       WithinCode,
ft F,lt Z,zz *Status,    tokentype    *ListTkn)
{
listheadtype *HeadObj         = NullPtr;
if (OaCreateObject (Anchor,    DbListHead_Class,  McStat, ListTkn))
if (OaGetObject    (ListTkn,   McStat,       (addrtype *)&HeadObj))
{
HeadObj->OwnerTkn         = *Owner;
HeadObj->FirstNode        = NullHandle;
HeadObj->LastNode         = NullHandle;
HeadObj->CurrentNode      = NullHandle;
HeadObj->NodeCount        = 0;
HeadObj->NodeClass        = DbListNode_Class;
strncpy (HeadObj->ListName, NameOfList,  sizeof (nametype));
}
TRACK(TrackBak,"List01_Create\n");
return(STAT);
}
boolean List01_FindListHead
(tokentype    *Anchor,    char         *NameOfList,
ft F,lt Z,zz *Status,    tokentype    *ListTkn)
{
listheadtype *HeadObj    = NullPtr;
tokentype     ItorTkn    = NullToken;
boolean       FOUND      = False;
*Status                 = Iterate_Begin;
while (!FOUND
&&     Primal_IterateOnClassObjects
(Anchor, DbListHead_Class, McStat,
&ItorTkn,   ListTkn))
{
if (OaGetObject    (ListTkn,   McStat,       (addrtype *)&HeadObj))
if (!strncmp (HeadObj->ListName, NameOfList,  sizeof (nametype)))
FOUND   = True;
}
if (*Status   == Iterate_EndOf)
*Status    = Env_Normal;
if (!FOUND)
{
*ListTkn  = NullToken;
*Status   = List01_NotFound;
}
TRACK(TrackBak,"List01_FindListHead\n");
return(STAT);
}
boolean   List01_CreateNode
(tokentype    *ListTkn,
ft F,lt Z,zz *Status,     tokentype  *NodeTkn)
{
listheadtype *HeadObj         = NullPtr;
listnodetype *NodeObj         = NullPtr;
if (OaGetObject    (ListTkn,   McStat,    (addrtype *)&HeadObj))
if (OaCreateObject (ListTkn,                           HeadObj->NodeClass,
McStat,                            NodeTkn))
if (OaGetObject    (NodeTkn,   McStat,    (addrtype *)&NodeObj))
{
HeadObj->CurrentNode      = NodeTkn->Handle;
NodeObj->PrevNode         = ListTkn->Handle;
NodeObj->NextNode         = NullHandle;
NodeObj->NodeObject       = NullToken;
}
TRACK(TrackBak,"List01_CreateNode\n");
return(STAT);
}
boolean    Is_List01Head (tokentype    *ListTkn,   ft F,lt Z,zz *Status)
{
KernelIamA (ListTkn, DbListHead_Class, McStat);
return(STAT);
}
boolean    Is_List01Node   (tokentype    *ListTkn,   ft F,lt Z,zz *Status)
{
KernelIamA (ListTkn, DbListNode_Class, McStat);
return(STAT);
}
boolean Is_List01Member  (tokentype    *ListTkn,   tokentype    *MemberTkn,
ft F,lt Z,zz *Status,    tokentype    *NodeTkn)
{
listheadtype *HeadObj         = NullPtr;
tokentype     NextNode        = NullToken;
listnodetype *NodeObj         = NullPtr;
NextNode.DbId   = ListTkn->DbId;
if (ListBug || DeBug)
if (sprintf (Msg, "\n   Is_List01Member[%4u:%6u]:: Token=[%2u:%4u]  \n",
ListTkn->DbId,    ListTkn->Handle,
MemberTkn->DbId,  MemberTkn->Handle))
TraceMsg (0, Msg);
if (OaGetObject (ListTkn,   McStat,   (addrtype *)&HeadObj))
for (NextNode.Handle  = HeadObj->FirstNode;
Normal(*Status) && NextNode.Handle;)
{
if (OaGetObject (&NextNode,   McStat,   (addrtype *)&NodeObj))
if (NodeObj->NodeObject.Handle == MemberTkn->Handle
&&  NodeObj->NodeObject.DbId   == MemberTkn->DbId)
{
if (ListBug || DeBug)
if (sprintf (Msg, "     ...NodeTkn =[%4u:%6u]\n",
NodeTkn->DbId, NodeTkn->Handle))
TraceMsg (0, Msg);
return (True);
} else
NextNode.Handle = NodeObj->NextNode;
}
if (ListBug || DeBug)
TraceMsg (0, "\n   ... Not a Member.\n");
if (Normal(*Status))
return (False);
TRACK(TrackBak,"Is_List01Member\n");
return (STAT);
}
boolean   List01_GetCount
(tokentype    *ListTkn,
ft F,lt Z,zz *Status,    numtype   *ItemCount)
{
listheadtype  *HeadObj         = NullPtr;
*ItemCount      = 0;
if (OaGetObject (ListTkn,   McStat,   (addrtype *)&HeadObj))
*ItemCount  = HeadObj->NodeCount;
TRACK(TrackBak,"List01_GetCount\n");
return (STAT);
}
boolean   List01_Reset   (tokentype    *ListTkn,   ft F,lt Z,zz *Status)
{
listheadtype  *HeadObj         = NullPtr;
if (OaGetObject (ListTkn,   McStat,   (addrtype *)&HeadObj))
HeadObj->CurrentNode      = HeadObj->FirstNode;
TRACK(TrackBak,"List01_Reset\n");
return (STAT);
}
boolean   List01_SetCurrent
(tokentype    *ListTkn,   tokentype  *NodeTkn,
ft F,lt Z,zz *Status)
{
listheadtype  *HeadObj         = NullPtr;
if (OaGetObject (ListTkn,   McStat,   (addrtype *)&HeadObj))
HeadObj->CurrentNode      = NodeTkn->Handle;
TRACK(TrackBak,"List01_SetCurrent\n");
return (STAT);
}
boolean   List01_GetCurrent
(tokentype    *ListTkn,
ft F,lt Z,zz *Status,     tokentype  *NodeTkn)
{
listheadtype  *HeadObj         = NullPtr;
*NodeTkn             = NullToken;
if (OaGetObject (ListTkn,   McStat,   (addrtype *)&HeadObj))
{
NodeTkn->Handle   = HeadObj->CurrentNode;
NodeTkn->DbId     = ListTkn->DbId;
}
TRACK(TrackBak,"List01_GetCurrent\n");
return (STAT);
}
boolean   List01_IsEmpty
(tokentype    *ListTkn,    ft F,lt Z,zz *Status)
{
listheadtype  *HeadObj         = NullPtr;
if (OaGetObject (ListTkn,   McStat,   (addrtype *)&HeadObj))
if (HeadObj->NodeCount)
return(False);
TRACK(TrackBak,"List01_IsEmpty\n");
return (STAT);
}
boolean   List01_Append  (tokentype    *ListTkn,   tokentype *MemberTkn,
ft F,lt Z,zz *Status)
{
listheadtype *HeadObj         =  NullPtr;
listnodetype *LastObj         =  NullPtr;
listnodetype *PrevObj         =  NullPtr;
tokentype     PrevNode        =  NullToken;
tokentype     LastNode        =  NullToken;
PrevNode.DbId    = ListTkn->DbId;
LastNode.DbId    = ListTkn->DbId;
if (Normal(*Status))
if (OaGetObject    (ListTkn,   McStat,   (addrtype *)&HeadObj))
PrevNode.Handle = HeadObj->LastNode;
if (Normal(*Status))
if (List01_CreateNode (ListTkn,     McStat,                  &LastNode))
if (OaGetObject       (&LastNode,   McStat,      (addrtype *)&LastObj))
LastObj->NodeObject  = *MemberTkn;
if (Normal(*Status))
if (HeadObj->FirstNode == NullHandle)
{
LastObj->PrevNode    =  ListTkn->Handle;
LastObj->NextNode    =  NullHandle;
HeadObj->FirstNode   =  LastNode.Handle;
} else {
LastObj->PrevNode    =  PrevNode.Handle;
LastObj->NextNode    =  NullHandle;
if (OaGetObject (&PrevNode,  McStat,           (addrtype *)&PrevObj))
PrevObj->NextNode =  LastNode.Handle;
}
if (Normal(*Status))
{
HeadObj->CurrentNode =  LastNode.Handle;
HeadObj->LastNode    =  LastNode.Handle;
HeadObj->NodeCount++;
}
TRACK(TrackBak,"ListAppend\n");
return (STAT);
}
boolean   List01_FirstIn (tokentype    *ListTkn,
ft F,lt Z,zz *Status,     tokentype *NodeTkn,
tokentype    *MemberTkn)
{
listheadtype *HeadObj         = NullPtr;
listnodetype *NodeObj         = NullPtr;
*MemberTkn       = NullToken;
*NodeTkn         = NullToken;
if (Normal(*Status))
if (ListTkn->Handle == NullHandle)
*Status = List01_NullListTkn;
if (Normal(*Status))
if (OaGetObject (ListTkn,   McStat,   (addrtype *)&HeadObj))
if (HeadObj->FirstNode == NullHandle)
{
*Status = List01_EmptyList;
if (DeBug || ListBug)
TraceMsg (0, "    ... Empty List\n");
} else {
NodeTkn->DbId   = ListTkn->DbId;
if ((NodeTkn->Handle = HeadObj->FirstNode) != NullHandle)
if (OaGetObject (NodeTkn,   McStat,   (addrtype *)&NodeObj))
*MemberTkn = NodeObj->NodeObject;
HeadObj->CurrentNode  = NodeTkn->Handle;
}
if (ListBug || DeBug)
if (sprintf (Msg, "     Node[%2u:%4u]  Member[%2u,%4u]\n",
NodeTkn->DbId,     NodeTkn->Handle,
MemberTkn->DbId,   MemberTkn->Handle))
TraceMsg (0, Msg);
TRACK(TrackBak,"ListFirstIn\n");
return (STAT);
}
boolean   List01_NextIn    (tokentype    *ListTkn,    tokentype  *CurrNodeTkn,
ft F,lt Z,zz *Status,     tokentype  *NodeTkn,
tokentype    *MemberTkn)
{
listheadtype *HeadObj         = NullPtr;
listnodetype *NodeObj         = NullPtr;
*NodeTkn    = NullToken;
*MemberTkn  = NullToken;
if (Normal(*Status))
if (ListTkn->Handle == NullHandle)
*Status = List01_NullListTkn;
if (Normal(*Status))
if (OaGetObject (ListTkn,   McStat,   (addrtype *)&HeadObj))
if (CurrNodeTkn->Handle == NullHandle)
*Status = List01_EmptyList;
if (Normal(*Status))
if (OaGetObject (CurrNodeTkn,   McStat,   (addrtype *)&NodeObj))
if (NodeObj->NextNode  == NullHandle)
{
HeadObj->CurrentNode  =  HeadObj->LastNode;
*Status = List01_EndOfList;
} else {
NodeTkn->DbId   = ListTkn->DbId;
if ((NodeTkn->Handle = NodeObj->NextNode) != NullHandle)
if (OaGetObject (NodeTkn,   McStat,   (addrtype *)&NodeObj))
*MemberTkn          =  NodeObj->NodeObject;
HeadObj->CurrentNode  =  NodeTkn->Handle;
}
if (ListBug ||  DeBug)
if (sprintf (Msg, "  ListNextOf... Current[%2u,%4u]  Next[%2u,%4u]\n",
CurrNodeTkn->DbId,    CurrNodeTkn->Handle,
NodeTkn->DbId,        NodeTkn->Handle))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "                Member [%2u,%4u]\n",
MemberTkn->DbId,      MemberTkn->Handle))
TraceMsg (0, Msg);
TRACK(TrackBak,"List01_NextIn\n");
return (STAT);
}
boolean   List01_IterateOn (tokentype   *ListTkn,
iteratetype   Method,     ft F,lt Z,zz *Status)
{
tokentype     CurrentTkn;
tokentype     CurrentNode;
tokentype     NextTkn;
tokentype     NextNode;
indextype     ItNum        = 0;
if (ListBug || DeBug)
if (sprintf (Msg, "\n   IterateOn the List by ListTkn[%2u:%4u]  \n",
ListTkn->DbId, ListTkn->Handle))
TraceMsg (0, Msg);
if (ListTkn->Handle)
if (List01_Reset      (ListTkn,  McStat))
if (List01_FirstIn    (ListTkn,  McStat,  &CurrentNode,   &CurrentTkn))
{
if (Normal(*Status))
do {
++ItNum;
if ((*Method)   (&CurrentTkn,   ItNum,          McStat))
if (List01_NextIn (ListTkn,      &CurrentNode,
McStat,       &NextNode,      &NextTkn))
{
CurrentNode.Handle = NextNode.Handle;
CurrentTkn.Handle  = NextTkn.Handle;
}
} while (Normal(*Status));
}
if (*Status == List01_EndOfList  || *Status == List01_EmptyList)
*Status = Env_Normal;
TRACK(TrackBak,"List01_IterateOn\n");
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\mem00.c*/

#define MEM_C
#define MEM00
/* 当前文件是./CINT2000\255.vortex\src\mem00.h*/

#ifndef MEM00_H
#define MEM00_H
typedef  boolean         bitfield;
typedef  byte            chunktype;
typedef  numtype         numchunk;
typedef  numtype         indexchunk;
typedef  numtype         indexhead;
typedef  numtype         addrchunk;
typedef  numtype         addrhead;
//typedef  longtype        chunkflags;

#ifdef MEM00

#else
#ifdef MEM_C






#else






#endif
#endif
#ifdef MEM_C
#define  ChunkAddrChunkNum   ChunkAddrChunk
#define  Num_ChunkChunks    (ChunkHdr.ChunkCount)
#define  ChunkChunkNum    0
#define  ChunkAddr_Chunk  0
#define  NextChunk_Chunk  1
#define  DbIdChunk_Chunk  1
#define  Flags_Chunk      2
#define  UnitSize_Chunk   3
#define  UnitCount_Chunk  4
#define  StackPtr_Chunk   5
#define  StringText_Chunk 6
#define  ExtendQty_Chunk  7
#define  MaxUnitLen_Chunk 8
#define  UnitType_Chunk   9
#define  CRC_Chunk        10
#ifdef LARGE
#define  CRC_Offset        32
#define  UnitSize_Offset   28
#define  UnitCount_Offset  24
#define  StackPtr_Offset   20
#define  StringText_Offset 16
#define  MaxUnitLen_Offset 12
#define  ExtendQty_Offset   8
#define  UnitType_Offset    4
#else
#define  UnitSize_Offset   16
#define  UnitCount_Offset  14
#define  StackPtr_Offset   12
#define  StringText_Offset 10
#define  MaxUnitLen_Offset  8
#define  ExtendQty_Offset   6
#define  UnitType_Offset    4
#define  CRC_Offset         2
#endif
#define  Is_CPP         0x0001
#define  Is_Ptrs        0x0002
#define  Is_Vary        0x0004
#define  IsNot_Vary    ~0x0004
#define  Is_Data        0x0008
#define  IsNot_Data    ~0x0008
#define  Is_String      0x0010
#define  IsNot_String  ~0x0010
#define  Is_Text        0x0020
#define  IsNot_Text    ~0x0020
#define  Is_Numeric     0x0040
#define  IsNot_Numeric ~0x0040
#define  Is_InCore      0x0080
#define  IsNot_InCore  ~0x0080
#define  Is_Active      0x0100
#define  IsNot_Active  ~0x0100
#define  Is_Clean       0x0200
#define  IsNot_Clean   ~0x0200
#define  Is_Frozen      0x0400
#define  IsNot_Frozen  ~0x0400
#define  Is_Grown       0x0800
#define  IsNot_Grown   ~0x0800
#define  Chunk_Addr(ChunkNum)\
		((Theory->ChunkAddr[ChunkNum]))
#define  Next_Chunk(ChunkNum)\
		((Theory->NextChunk[ChunkNum]))
#define  CoreDbId_Chunk(ChunkNum)\
		((Theory->NextChunk[ChunkNum]))
#define  Chunk_Flags(ChunkNum)\
		((Theory->Flags[ChunkNum]))
#define  Chunk_IsCpp(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_Cpp))
#define  IsCpp_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |=  Is_Cpp))
#define  IsNotCpp_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |=  IsNot_Cpp))
#define  Chunk_IsPtrs(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_Ptrs))
#define  Chunk_IsVary(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_Vary))
#define  IsVary_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= Is_Vary))
#define  IsNotVary_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= IsNot_Vary))
#define  Chunk_IsData(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_Data))
#define  IsData_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= Is_Data))
#define  Chunk_IsString(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_String))
#define  IsString_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= Is_String))
#define  IsNotString_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= IsNot_String))
#define  Chunk_IsText(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_Text))
#define  IsText_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= Is_Text))
#define  IsNotText_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= IsNot_Text))
#define  Chunk_IsNumeric(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_Numeric))
#define  IsNumeric_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= Is_Numeric))
#define  Chunk_IsInCore(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_InCore))
#define  IsInCore_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= Is_InCore))
#define  IsNotInCore_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= Is_NotInCore))
#define  Chunk_IsActive(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_Active))
#define  IsActive_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= Is_Active))
#define  Chunk_IsClean(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_Clean))
#define  Dirty_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= IsNot_Clean))
#define  Clean_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= Is_Clean))
#define  Chunk_IsFrozen(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_Frozen))
#define  Thaw_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= IsNot_Frozen))
#define  Freeze_Chunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= Is_Frozen))
#define  Chunk_IsGrown(ChunkNum)\
		((Theory->Flags[ChunkNum] & Is_Grown))
#define  GrownChunk(ChunkNum)\
		((Theory->Flags[ChunkNum] |= Is_Grown))
#define  Unit_Size(ChunkNum)\
(*(sizeinbytes *)((char *)Theory->ChunkAddr[ChunkNum] - UnitSize_Offset))
#define  Unit_Count(ChunkNum)\
(*(indextype   *)((char *)Theory->ChunkAddr[ChunkNum] - UnitCount_Offset))
#define  Stack_Ptr(ChunkNum)\
(*(indextype   *)((char *)Theory->ChunkAddr[ChunkNum] - StackPtr_Offset))
#define  Text_Chunk(ChunkNum)\
(*(numtype     *)((char *)Theory->ChunkAddr[ChunkNum] - StringText_Offset))
#define  Extend_Qty(ChunkNum)\
(*(sizeinbytes *)((char *)Theory->ChunkAddr[ChunkNum] - ExtendQty_Offset))
#define  MaxUnit_Length(ChunkNum)\
(*(indextype   *)((char *)Theory->ChunkAddr[ChunkNum] - MaxUnitLen_Offset))
#define  Unit_Type(ChunkNum)\
(*(indextype   *)((char *)Theory->ChunkAddr[ChunkNum] - UnitType_Offset))
#define  CRC_Value(ChunkNum)\
(*(indextype   *)((char *)Theory->ChunkAddr[ChunkNum] - CRC_Offset))
#define  NonNull_Chunk(ChunkNum)\
((Theory->Addr[ChunkNum] == NULL))
#define  SameSize_Chunk(ChunkNum,TypeSize)\
((*(sizeinbytes *)((char *)Theory->ChunkAddr[ChunkNum] - UnitSize_Offset) \
== (sizeinbytes)TypeSize))
#define  NotSameSize_Chunk(ChunkNum,TypeSize)\
((*(sizeinbytes *)((char *)Theory->ChunkAddr[ChunkNum] - UnitSize_Offset) \
!= (sizeinbytes)TypeSize))
#endif
#define MemMakeOry             Mem_MakeOry
#define MemNewOry              Mem_NewOry
#define MemMakeOryChunks       Mem_MakeOryChunks
#define MemTestTheOry          Mem_TestTheOry
#define InitBlocks             Mem_InitBlocks
#define BlockCount             Mem_BlockCount
#define NewRegion              Mem_NewRegion
#define FreeChunkChunk         Mem_FreeChunkChunk
#define ExpandChunkTables      Mem_ExpandChunkTables
#define DumpChunkChunk         Mem_DumpChunkChunk
#define MakeChunk              Chunk_MakeChunk
#define NewChunkChunk          Mem_NewChunkChunk
#define InitChunk              Chunk_InitChunk
#define MemNewChunkBlk         Mem_NewChunkBlk
#define MemPutChunkStruc       Mem_PutChunkStruc
#define GrowNumericChunk       Chunk_GrowNumericChunk
#define GrowTextChunk          Chunk_GrowTextChunk
#define ExpandChunk            Chunk_ExpandChunk
#ifndef __MACROIZE_MEM__
#define ChunkExists            Chunk_ChunkExists
boolean Chunk_ChunkExists
(numtype       ChunkNum,  ft F,lt Z,zz *Status);
#else
#ifdef MCSTAT
#define ChunkExists(ChunkNum,Stat)  True
#else
#define ChunkExists(ChunkNum,Stat)  True
#endif
#endif
#define ChkPutChunk            Chunk_ChkPutChunk
#define ChkPopChunk            Chunk_ChkPopChunk
#define ChkGetChunk            Chunk_ChkGetChunk
#ifdef MEM00
void    Mem_Init
(indextype     Alloc_FreeAddrs,  indextype  Extend_FreeAddrs,
char         *Xmem_File,
indextype     Alloc_MemChunks,  indextype  Extend_MemChunks,
indextype     Alloc_XmemBlks,   indextype  Extend_XmemBlks);
boolean MemMakeOry     (ft F,lt Z,zz *Status,    addrtype   *TheOry);
boolean MemNewOry      (ft F,lt Z,zz *Status,    addrtype   *TheOry);
boolean MemMakeOryChunks
(ft F,lt Z,zz *Status);
boolean MemMakeKrnlChunk
(bytessize     UnitSize,  indextype   AllocQty,
indextype     ExtendQty, idtype      CoreDbId,
ft F,lt Z,zz *Status,    numtype    *ChunkNum);
boolean Mem_ExpandKrnlChunk
(chunknum      ChunkNum,
ft F,lt Z,zz *Status,    addrtype   *KrnlAddr);
boolean MemTestTheOry  (ft F,lt Z,zz *Status);
sizeinbytes   Block_Size             = 1;
sizeinblocks
InitBlocks     (bytessize   UnitSize);
sizeinblocks
BlockCount     (bytessize   UnitSize,    indextype UnitCount);
boolean NewRegion      (sizeinblocks  Blocks,
ft F,lt Z,zz *Status,    addrtype *Region);
#ifdef     VALIDATE_MEM_CHUNKS
numtype Chunk_Validate
(numtype     ChunkNum);
#endif
#endif
#ifdef MEM_C
boolean NewChunkChunk  (ft F,lt Z,zz *Status,    numtype      *ChunkNum);
boolean FreeChunkChunk (numtype      *Chunk,     ft F,lt Z,zz *Status);
boolean ExpandChunkTables
(ft F,lt Z,zz *Status);
void    DumpChunkChunk (int           Dump,      numtype   ChunkNum);
boolean MakeChunk      (boolean       VarLength, boolean   PtrChunk,
bytessize     UnitSize,  indextype AllocQty,
indextype     ExtendQty, idtype    CoreDbId,
ft F,lt Z,zz *Status,    numtype  *ChunkNum);
boolean Chunk_NewChunk (bytessize     UnitSize,  indextype AllocQty,
ft F,lt Z,zz *Status,    numtype  *ChunkNum);
boolean InitChunk      (numtype       ChunkNum,  boolean   VaryLength,
boolean       PtrChunk,  bytessize UnitSize,
indextype     ExtendQty, idtype    CoreDbId,
ft F,lt Z,zz *Status);
boolean MemNewChunkBlk
(sizeinbytes   BlkSize,   ft F,lt Z,zz *Status,
numtype      *ChunkNum,  addrtype     *ChunkBlk);
boolean MemPutChunkStruc
(numtype       Chunk,    chunkstruc   *ChunkRef,
idtype        CoreDbId, ft F,lt Z,zz *Status);
boolean GrowNumericChunk
(numtype       ChunkNum,  ft F,lt Z,zz *Status);
boolean GrowTextChunk
(numtype       ChunkNum,  ft F,lt Z,zz *Status);
boolean ExpandChunk
(numtype       ChunkNum,
ft F,lt Z,zz *Status,    indextype    *StackPtr);
boolean Mem_ExpandKrnlChunk
(chunknum      ChunkNum,
ft F,lt Z,zz *Status,    addrtype     *KrnlAddr);
boolean ChkPushChunk   (numtype       ChunkNum,  size_t    SizeOfUnit,
ft F,lt Z,zz *Status);
boolean ChkPutChunk    (numtype       ChunkNum,  indextype Index,
size_t        SizeOfUnit,
ft F,lt Z,zz *Status,    boolean  *PushFlag);
boolean ChkPopChunk    (numtype       ChunkNum,  size_t    SizeOfUnit,
ft F,lt Z,zz *Status);
boolean ChkGetChunk    (numtype       ChunkNum,  indextype Index,
size_t        SizeOfUnit,
ft F,lt Z,zz *Status);
#endif
void Mem_ShowStats     (void);
void Mem_DumpStats     (void);
#endif
#ifndef   CORE_CRC_CHECK
#undef    VALIDATE_MEM_CHUNKS
#endif
#ifdef NULL_TRACE_STRS
#define TraceStr5(StrNum)  TraceStr5[0]
static const char   *TraceStr5[2] = {"\0", "   ...MEM00... message\n" };
#else
#define TraceStr5(StrNum)  TraceStr5[StrNum]
static const char *TraceStr5[50] =
{
" A Null Trace String Msg",
"  Theory       = %x\n",
" *TheOry       = %x\n",
"  ChunkTblPtr  = %x\n",
"  Theory->ChunkAddr  = %x\n",
"  ChunkAddrPtr  = %x\n",
" *ChunkAddrPtr  = %x\n",
"  ChunkTblPtr[0]     = %x\n",
"  Theory->ChunkAddr  = %x\n",
"  Theory->NextChunk  = %x\n",
"  Theory->(%d)          = %x\n",
"  ChunkTablePtr[%d]     = %x\n",
" &Theory->NextChunk[%d] = %x\n",
"  NextChunk(%d)         = %d\n",
"Chunk(%d) [%x]  :: StackPtr = %d\n",
"Get Chunk(%d)[%d] = %d\n",
"Put Chunk(%d)[%d] = %d\n",
"Get Chunk(%d)[%d] = %d\n",
"Push XmemBlkSize[%d] = %d\n",
"Push XmemBlkSize[%d] = %d\n",
"Get XmemBlkSize[0] = %d\n",
"Pop XmemBlkSize[%d] = %d\n",
"Pop XmemBlkSize[%d] = %d\n",
"GetSomeBytes from  Chunk(%d)[%d] = %d\n",
"    New     Chunk     %6u.  NextFree= %6u\n",
"    Reclaim Chunk     %6u.  NextFree= %6u\n",
"        Mem  FreeChunkChunk  [%6u]; 2nd Free=%6u\n",
"     &Chunk(%d)_ChunkAddr @%x\n",
"     &Chunk[%4u] @%8x;                           CRC:= <%-8x>\n",
"    Chunk_NewChunk[%6u] @ %x\n",
"   InitChunk [%6u] UnitSize= %8u... Size_Conflict!!!\n",
"    MemGetChunkBlk As Chunk[%6u] Blk@ %x BlkSize=%5u\n",
"    MemAssignChunkStruc To Chunk[%6u]\n",
"      MemPutChunkStruc[%6u] ...\n",
"      Unit Size =%3u, Count =%6u; StackPtr =%6u\n",
"\n   Mem_ExpandChunk::   [%4u] StackPtr =%6u; By ExtendQty=%6u\n",
"                       Current StackPtr=%6u;\n",
"   NO bytes moved... SourceSize=%5u, TargetSize=%5u;\n",
"     Theory->ChunkAddr  = %x\n",
"     Copy from Source @%x TO Target @%x * %u Bytes\n",
"     Theory->@%x  = %x; StackPtr=%4u\n",
"     Copy from Source(*%8u) @%x TO Target(*%8u) @%x\n",
" ChunkNum[%4u] > NumChunks=%4u\n",
" UnitSize %u !=  SizeOfUnit %u ::",
" Index = %4u >= StackPtr = %4u ::",
" UnitSize %u !=  SizeOfUnit %u ::",
" UnitSize %u !=  SizeOfUnit %u ::",
" Index = %4u >= StackPtr = %4u ::",
" UnitSize %u !=  SizeOfUnit %u ::",
" *** Chunk not Numeric || Data. ::"
};
#endif
#define MemMakeChunk           Mem_MakeChunk
#define MemDumpChunk           Mem_DumpChunk
#define MemGetChunkAddr        Mem_GetChunkAddr
#define MemPutStackPtr         Mem_PutStackPtr
#define MemGetStackPtr         Mem_GetStackPtr
#define MemPushWord            Mem_PushWord
#define MemPutWord             Mem_PutWord
#define MemPopWord             Mem_PopWord
#define MemGetWord             Mem_GetWord
#define MemGetSomeBytes        Mem_GetSomeBytes
boolean MemMakeChunk   (bytessize     UnitSize,  indextype AllocQty,
indextype     ExtendQty, idtype    CoreDbId,
ft F,lt Z,zz *Status,    numtype  *Chunk);
boolean MemDumpChunk
(int           MsgLevel,  numtype   Chunk,
ft F,lt Z,zz *Status);
boolean Mem_DumpChunkPart
(int           MsgLevel,  numtype       Chunk,
numtype       Ilow,      numtype       Ihigh,
ft F,lt Z,zz *Status);
void    Mem_AssignXmemFile
(char         *FileName);
boolean Mem_MakeXmemChunks
(indextype     AllocQty,  indextype     ExtendQty,
ft F,lt Z,zz *Status);
void    Mem_ShowXmemStats
(void);
boolean MemGetChunkAddr(numtype       Chunk,
ft F,lt Z,zz *Status,    addrtype *ChunkAddr);
boolean MemPutStackPtr (numtype       Chunk,     indextype StackPtr,
ft F,lt Z,zz *Status);
boolean MemGetStackPtr (numtype       Chunk,
ft F,lt Z,zz *Status,    indextype *StackPtr);
boolean MemPushWord    (numtype       Chunk,    word       WordValue,
ft F,lt Z,zz *Status,   indextype *StackPtr);
boolean MemPutWord     (numtype       Chunk,    indextype  Index,
word          WordValue,ft F,lt Z,zz *Status);
boolean MemPopWord     (numtype       Chunk,    ft F,lt Z,zz *Status,
word         *WordValue,indextype *StackPtr);
boolean MemGetWord     (numtype       Chunk,    indextype  Index,
ft F,lt Z,zz *Status,   word      *WordValue);
boolean MemGetSomeBytes(numtype       Chunk,     indextype   Index,
bytessize     ByteCount,
ft F,lt Z,zz *Status,    addrtype    SomeBytes);
#define MemPushIndex           Mem_PushWord
#define MemPutIndex            Mem_PutWord
#define MemGetIndex            Mem_GetWord
#define MemPopIndex            Mem_PopWord
void    Mem_Init
(indextype     Alloc_FreeAddrs,  indextype  Extend_FreeAddrs,
char         *Xmem_File,
indextype     Alloc_MemChunks,  indextype  Extend_MemChunks,
indextype     Alloc_XmemBlks,   indextype  Extend_XmemBlks)
{
KrnlBlocks_AllocQty    = Alloc_FreeAddrs;
KrnlBlocks_ExtendQty   = Extend_FreeAddrs;
Alloc_Chunks           = Alloc_MemChunks;
Extend_Chunks          = Extend_MemChunks;
Mem_AssignXmemFile      (Xmem_File);
XmemBlocks_AllocQty    = Alloc_XmemBlks;
XmemBlocks_ExtendQty   = Extend_XmemBlks;
return;
}
boolean   MemMakeOry (ft F,lt Z,zz *Status,   addrtype  *TheOry)
{
if (MemNewOry     (McStat,      TheOry))
MemTestTheOry (McStat);
TRACK(TrackBak,"MemMakeOry\n");
return (STAT);
}
boolean    MemNewOry (ft F,lt Z,zz *Status,   addrtype  *TheOry)
{
addrtype     TableChunkAddr = NullPtr;
numtype      ChunkChunk     = 0;
addrtype     *ChunkAddrPtr  = NullPtr;
addrtype     *ChunkTblPtr   = NullPtr;
unsigned     i              = 0;
addrtype     ChunkBlk       = NullPtr;
static  int  FirstTimeIn    = 0;
if (Theory        == NullPtr
||  FirstTimeIn++ == 0)
{
if (CoreMoreCore (sizeof(OryType),   McStat,   (addrtype *)(&Theory)))
{
ChunkTblPtr = (addrtype *)Theory;
*TheOry      = (addrtype  )Theory;
}
if (Normal(*Status))
{
ChunkBlk     = (addrtype )GET_MEM (1,
InitBlocks (sizeof(addrtype))    );
ChunkBlk     = (addrtype )((char *)ChunkBlk + sizeof (chunkstruc));
}
if (Normal(*Status))
if ((Theory->ChunkAddr = (addrtype *)ChunkBlk)
!=  NullPtr)
{
ChunkAddrPtr      =  Theory->ChunkAddr;
*ChunkAddrPtr      =  (addrtype )ChunkAddrPtr;
}
if (Normal(*Status))
{
++ChunkAddrPtr;
ChunkBlk     = (addrtype )GET_MEM (1,
InitBlocks (sizeof(chunknum))    );
ChunkBlk     = (addrtype )((char *)ChunkBlk + sizeof (chunkstruc));
*ChunkAddrPtr = (addrtype *)ChunkBlk;
++ChunkAddrPtr;
ChunkBlk     = (addrtype )GET_MEM (1,
InitBlocks (sizeof(chunkflags))    );
ChunkBlk     = (addrtype )((char *)ChunkBlk + sizeof (chunkstruc));
*ChunkAddrPtr = (addrtype *)ChunkBlk;
ChunkAddrPtr =  Theory->ChunkAddr;
}
if (Normal(*Status))
{
for (  ChunkChunk = ChunkAddrChunk;
++ChunkChunk < NumChunkChunks; )
{
*(++ChunkTblPtr) = *(++ChunkAddrPtr);
}
ChunkTblPtr = Theory->ChunkAddr;
for (ChunkChunk = ChunkAddrChunk;
ChunkChunk < NumChunkChunks; ChunkChunk++)
{
i                                 = ChunkChunk;
TableChunkAddr                    = ChunkTblPtr[i];
Unit_Count      (ChunkChunk)      = Alloc_Chunks;
Extend_Qty      (ChunkChunk)      = Extend_Chunks;
Stack_Ptr       (ChunkChunk)      = NumChunkChunks;
Next_Chunk      (ChunkChunk)      = 0;
CRC_Value       (ChunkChunk)      = CHUNK_CONSTANT;
IsNotText_Chunk (ChunkChunk);
IsInCore_Chunk  (ChunkChunk);
IsData_Chunk    (ChunkChunk);
IsNumeric_Chunk (ChunkChunk);
}
ChunkChunk                  = ChunkAddr_Chunk;
Unit_Size(ChunkChunk++)     = (sizeinbytes)sizeof (addrtype);
Unit_Size(ChunkChunk++)     = (sizeinbytes)sizeof (chunknum);
Unit_Size(ChunkChunk++)     = (sizeinbytes)sizeof(chunkflags);
}
if (Normal(*Status))
if (MemBug)
{
TraceMsg (0, " Dump The Chunk Chunks\n");
for (ChunkChunk = ChunkAddrChunk;
ChunkChunk < NumChunkChunks;   ChunkChunk++)
DumpChunkChunk (0, ChunkChunk);
}
if (Normal(*Status))
MemMakeOryChunks (McStat);
} else
*Status = Env_OryExists;
TRACK(TrackBak,"  strcpy (MemNewOry\n");
return (STAT);
}
boolean    MemMakeOryChunks (ft F,lt Z,zz *Status)
{
numtype       FreeAddrChunk          = 0;
addrtype     *FreeAddr               = NullPtr;
numtype       FreeSizeChunk          = 0;
numtype      *FreeSize               = NullPtr;
if (MemMakeKrnlChunk
(sizeof(addrtype),        KrnlBlocks_AllocQty,
KrnlBlocks_ExtendQty,    0,
McStat,                             &FreeAddrChunk))
if (MemMakeKrnlChunk
(sizeof(bytessize),       KrnlBlocks_AllocQty,
KrnlBlocks_ExtendQty,    0,
McStat,                             &FreeSizeChunk))
{
FreeAddr  = (addrtype *)Theory->ChunkAddr[FreeAddrChunk];
FreeSize  = (numtype  *)Theory->ChunkAddr[FreeSizeChunk];
Core_AssignChunks  (FreeAddrChunk,      FreeAddr,
FreeSizeChunk,      FreeSize);
}
if (DeBug || CoreBug)
{
DumpChunkChunk (1, FreeAddrChunk);
DumpChunkChunk (1, FreeSizeChunk);
}
if (Normal(*Status))
Mem_MakeXmemChunks (XmemBlocks_AllocQty, XmemBlocks_ExtendQty,
McStat);
TRACK(TrackBak,"MakeOryChunks\n");
return (STAT);
}
boolean    MemMakeKrnlChunk
(bytessize     UnitSize,  indextype   AllocQty,
indextype     ExtendQty, idtype      CoreDbId,
ft F,lt Z,zz *Status,    numtype    *ChunkNum)
{
boolean        VarLength      = False;
boolean        PtrChunk       = False;
sizeinblocks   Blocks         = 0;
addrtype       ChunkAddr      = NullPtr;
farlongtype    AllocCore1     = 0;
sizetype       ByteAlignment  = 0;
bytessizetype  SizeInBytes    = 0;
if (!UnitSize || !AllocQty)
{
*Status = Err_BadUnitSize;
}
if (Normal(*Status))
if (! AllocQty)
Blocks  = InitBlocks (UnitSize);
else
Blocks  = BlockCount (UnitSize, AllocQty);
Blocks   = Blocks * Block_Size;
if (Normal(*Status))
if (Blocks % CoreBlk_GapSpace)
{
ByteAlignment   = CoreBlk_GapSpace - (Blocks  % CoreBlk_GapSpace);
SizeInBytes     = Blocks  + ByteAlignment;
}
if (Normal(*Status))
{
AllocCore1      = (farlongtype )SizeInBytes;
CoreBug = True;
if ((ChunkAddr  = (addrtype )VoidExtendCore (&AllocCore1)) == NULL)
*Status      = Env_CoreNoMore;
CoreBug = False;
if (AllocCore1 != SizeInBytes)
*Status      = Env_CoreNoMore;
}
if (Normal(*Status))
if (NewChunkChunk       (McStat ,  ChunkNum))
{
ChunkAddr                 = (addrtype )((char *)ChunkAddr
+ sizeof (chunkstruc));
Chunk_Addr  (*ChunkNum)   = ChunkAddr;
Unit_Count  (*ChunkNum)   = AllocQty;
}
if (Normal(*Status))
if (InitChunk    (*ChunkNum, VarLength, PtrChunk, UnitSize,
ExtendQty, CoreDbId,            McStat))
{
IsNumeric_Chunk    (*ChunkNum);
IsData_Chunk       (*ChunkNum);
}
TRACK(TrackBak,"MemMakeKrnlChunk\n");
return (STAT);
}
boolean MemTestTheOry (ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"MemTestTheOry\n");
return (STAT);
}
boolean    NewRegion      (sizeinblocks  Blocks,
ft F,lt Z,zz *Status, addrtype *Region)
{
CoreMoreCore (Blocks * Block_Size, McStat, Region);
TRACK(TrackBak,"NewRegion\n");
return(STAT);
}
sizeinblocks
InitBlocks     (bytessize     UnitSize)
{
sizeinbytes   RegionSize = sizeof (chunkstruc) + (UnitSize * Alloc_Chunks);
sizeinblocks  Blocks     = RegionSize / Block_Size;
StackTrack ("InitBlocks\n");
return ((RegionSize % Block_Size > 0) ? ++Blocks : Blocks);
}
sizeinblocks
BlockCount     (bytessize     UnitSize, indextype  UnitCount)
{
sizeinbytes   RegionSize = sizeof (chunkstruc) + (UnitSize * UnitCount);
sizeinblocks  Blocks     = RegionSize / Block_Size;
StackTrack ("BlockCount\n");
return ((RegionSize % Block_Size > 0) ? ++Blocks : Blocks);
}
boolean    NewChunkChunk (ft F,lt Z,zz *Status,     numtype   *ChunkNum)
{
chunknum ChunkChunk = 0;
int      TempDeBug  = DeBug;
if ((*ChunkNum    = Theory->NextFree)          == 0)
{
if ((*ChunkNum = Stack_Ptr(ChunkAddrChunk)) == Unit_Count(ChunkAddrChunk))
{
ExpandChunkTables (McStat);
Mem_DumpChunkPart (0,  0, 0, NumChunkChunks, McStat);
DeBug = TempDeBug;
}
for (ChunkChunk = ChunkAddrChunk;
ChunkChunk < NumChunkChunks; ChunkChunk++)
{
++Stack_Ptr(ChunkChunk);
}
++NumChunks;
++ChunksAllocated;
Next_Chunk        (*ChunkNum) = 0;
} else {
Theory->NextFree = Next_Chunk(*ChunkNum);
ChunksReclaimed++;
Next_Chunk        (*ChunkNum) = 0;
}
TRACK(TrackBak,"NewChunkChunk\n");
return(STAT);
}
boolean    FreeChunkChunk  (numtype      *Chunk,  ft F,lt Z,zz *Status)
{
if (*Chunk)
{
ChunksFreeed++;
Next_Chunk(*Chunk)  = Theory->NextFree;
Theory->NextFree    = *Chunk;
*Chunk               = 0;
}
TRACK(TrackBak,"FreeChunkChunk\n");
return (STAT);
}
boolean    ExpandChunkTables (ft F,lt Z,zz *Status)
{
indextype      StackPtr       = 0;
numtype        ChunkChunk     = 0;
static numtype Expands        = 0;
sprintf (Msg, "\n   *** INFO *** ExpandChunkChunks[%4u]!\n", ++Expands);
TraceMsg (MSGFILE, Msg);
while (Normal(*Status)
&&     ChunkChunk     < NumChunkChunks)
{
ExpandChunk  (ChunkChunk,   McStat,     &StackPtr);
++ChunkChunk;
}
TRACK(TrackBak,"ExpandChunkTables\n");
return (STAT);
}
void       DumpChunkChunk (int       Dump,      chunknum     ChunkNum)
{
return;
}
boolean    MakeChunk(boolean       VarLength,   boolean     PtrChunk,
bytessize     UnitSize,    indextype   AllocQty,
indextype     ExtendQty,   idtype      CoreDbId,
ft F,lt Z,zz *Status,      numtype    *ChunkNum)
{
static boolean FirstChunk = True;
*Status = Env_Normal;
if (! UnitSize)
*Status = Err_BadUnitSize;
if (Normal(*Status))
if (Chunk_NewChunk  (UnitSize,  AllocQty,  McStat,   ChunkNum))
InitChunk (*ChunkNum, VarLength, PtrChunk, UnitSize,
ExtendQty, CoreDbId,           McStat);
if (Normal(*Status) && abs(DeBug) >= 4
||  FirstChunk)
{
DumpChunkChunk (0, *ChunkNum);
FirstChunk = False;
}
if (MemBug)
if (TraceMsg (0, "    MAKE Chunk "))
DumpChunkChunk (0, *ChunkNum);
TRACK(TrackBak,"MakeChunk\n");
return(STAT);
}
boolean    Chunk_NewChunk
(sizeinbytes   UnitSize,   indextype    AllocQty,
ft F,lt Z,zz *Status,     numtype     *ChunkNum)
{
sizeinblocks  Blocks     = 0;
addrtype      ChunkAddr  = NullPtr;
if (! AllocQty)
Blocks  = InitBlocks (UnitSize);
else
Blocks  = BlockCount (UnitSize, AllocQty);
if (NewRegion           (Blocks,   McStat,     &ChunkAddr))
if (NewChunkChunk       (McStat ,  ChunkNum))
{
ChunkAddr                 = (addrtype )((char *)ChunkAddr
+ sizeof (chunkstruc));
Chunk_Addr  (*ChunkNum)   = ChunkAddr;
Unit_Count  (*ChunkNum)   = AllocQty;
}
TRACK(TrackBak,"Chunk_NewChunk\n");
return(STAT);
}
boolean    InitChunk    (numtype       ChunkNum,   boolean       VaryLength,
boolean       PtrChunk,   bytessize     UnitSize,
indextype     ExtendQty,  idtype        CoreDbId,
ft F,lt Z,zz *Status)
{
if (VaryLength)
{
Unit_Size      (ChunkNum) = sizeof(bytetype);
Extend_Qty     (ChunkNum) = 0;
MaxUnit_Length (ChunkNum) = UnitSize;
} else {
Unit_Size      (ChunkNum) = UnitSize;
Extend_Qty     (ChunkNum) = ExtendQty;
MaxUnit_Length (ChunkNum) = 0;
}
Stack_Ptr         (ChunkNum) = (chunkindex)VaryLength;
CoreDbId_Chunk    (ChunkNum) = CoreDbId;
VaryLength   ?  IsText_Chunk   (ChunkNum) : IsNotText_Chunk   (ChunkNum);
Clean_Chunk       (ChunkNum);
Thaw_Chunk        (ChunkNum);
PtrChunk     ?  IsString_Chunk (ChunkNum) : IsNotString_Chunk (ChunkNum);
IsActive_Chunk    (ChunkNum);
IsInCore_Chunk    (ChunkNum);
CRC_Value         (ChunkNum) = CHUNK_CONSTANT;
if (NotSameSize_Chunk          (ChunkNum,  UnitSize))
{
DumpChunkChunk (0, ChunkNum);
*Status = Err_BadUnitSize;
}
TRACK(TrackBak,"InitChunk\n");
return(STAT);
}
boolean    MemNewChunkBlk
(sizeinbytes   BlkSize,      ft F,lt Z,zz *Status,
numtype      *ChunkNum,     addrtype     *ChunkBlk)
{
addrtype      ChunkAddr  = NullPtr;
sizeinblocks  Blocks     = 0;
sizeinbytes   ChunkSize  = 0;
ChunkSize = BlkSize - sizeof (chunkstruc);
Blocks    = BlockCount (ChunkSize, 1);
if (NewRegion           (Blocks,   McStat,      &ChunkAddr))
if (NewChunkChunk       (McStat ,  ChunkNum))
{
*ChunkBlk                  = ChunkAddr;
ChunkAddr                 = (addrtype )((char *)ChunkAddr
+ sizeof (chunkstruc));
Chunk_Addr  (*ChunkNum)   = ChunkAddr;
}
TRACK(TrackBak,"MemNewChunkBlk\n");
return(STAT);
}
boolean    MemPutChunkStruc
(numtype       Chunk,    chunkstruc   *ChunkRef,
idtype        CoreDbId, ft F,lt Z,zz *Status)
{
Next_Chunk        (Chunk) = 0;
CoreDbId_Chunk    (Chunk) = CoreDbId;
ChunkRef->StringText      ? IsText_Chunk (Chunk) : IsNotText_Chunk (Chunk);
IsNotText_Chunk   (Chunk);
Clean_Chunk       (Chunk);
Thaw_Chunk        (Chunk);
IsNotString_Chunk (Chunk);
IsActive_Chunk    (Chunk);
IsInCore_Chunk    (Chunk);
IsNumeric_Chunk   (Chunk);
IsData_Chunk      (Chunk);
TRACK(TrackBak,"MemPutChunkStruc\n");
return(STAT);
}
boolean    GrowNumericChunk (numtype  ChunkNum,  ft F,lt Z,zz *Status)
{
indextype     StackPtr = 0;
ExpandChunk     (ChunkNum,   McStat,        &StackPtr);
TRACK(TrackBak,"GrowNumericChunk\n");
return(STAT);
}
boolean    GrowTextChunk (numtype     ChunkNum,  ft F,lt Z,zz *Status)
{
indextype     StackPtr = 0;
if (ChunkBug || DeBug || MemBug)
if (TraceMsg        (0, "\n   *** INFO *** GrowTextChunk   ... "))
DumpChunkChunk      (0,          ChunkNum);
if (ExpandChunk     (ChunkNum,   McStat,        &StackPtr))
if (ChunkBug || DeBug || MemBug)
if (TraceMsg    (0, "                New Chunk Specs ... "))
DumpChunkChunk  (0,          ChunkNum);
TRACK(TrackBak,"GrowTextChunk\n");
return(STAT);
}
boolean    ExpandChunk (chunknum      ChunkNum,
ft F,lt Z,zz *Status,   indextype   *StackPtr)
{
addrtype       Source         = NullPtr;
addrtype       SourceRegion   = NullPtr;
sizeinbytes    SourceSize     = 0;
addrtype       TargetRegion   = NullPtr;
indextype      NewCount       = 0;
sizeinbytes    TargetSize     = 0;
addrtype      *ChunkAddrPtr   = NullPtr;
addrtype      *ValuePtr       = NullPtr;
booleantype    TmpSwap        = SWAP;
static numtype NumChunkChunkFrees  = 0;
SWAP         = False;
SourceRegion = Chunk_Addr (ChunkNum);
SourceRegion = (addrtype )((char *)SourceRegion - sizeof (chunkstruc));
Source       = SourceRegion;
SourceSize   = Unit_Size  (ChunkNum) *  Unit_Count (ChunkNum);
SourceSize  += sizeof (chunkstruc);
NewCount     = Unit_Count (ChunkNum) +  Extend_Qty (ChunkNum);
*StackPtr     = Stack_Ptr  (ChunkNum);
if (NewCount < *StackPtr)
NewCount  = *StackPtr;
TargetSize   = Unit_Size  (ChunkNum)  * NewCount;
TargetSize  += sizeof (chunkstruc);
if (TargetSize <= SourceSize)
{
*Status = Err_NoBytesMoved;
sprintf (Msg, TraceStr(37),
SourceSize, TargetSize);
TraceMsg (0, Msg);
DumpChunkChunk   (0, ChunkNum);
}
if (Normal(*Status))
if (ChunkNum   < NumChunkChunks)
{
if (NewRegion (TargetSize,   McStat,  (addrtype *)&ChunkAddrPtr))
{
TargetRegion   = (addrtype  )ChunkAddrPtr;
ChunkAddrPtr   = (addrtype *)((char *)ChunkAddrPtr
+ sizeof (chunkstruc));
}
if (Normal(*Status))
if (ChunkNum == 0)
{
Theory->ChunkAddr = ChunkAddrPtr;
*ChunkAddrPtr      =  (addrtype   )ChunkAddrPtr;
ChunkTheoryAddr   =  ChunkAddrPtr;
} else {
ChunkTheoryAddr++;
}
if (Normal(*Status))
{
memcpy  ((char *)TargetRegion, (char *)SourceRegion, SourceSize);
TargetRegion  = (addrtype )((char *)TargetRegion
+ sizeof (chunkstruc));
if (ChunkNum == 0)
{
Theory->ChunkAddr = (addrtype   *)ChunkAddrPtr;
} else if (ChunkNum == 1) {
Theory->NextChunk = (numtype    *)ChunkAddrPtr;
} else if (ChunkNum == 2) {
Theory->Flags     = (chunkflags *)ChunkAddrPtr;
} else {
memcpy  ((char *)ChunkTheoryAddr,
(char *)&TargetRegion,            sizeof(addrtype));
}
ValuePtr                        = ChunkTheoryAddr;
Theory->ChunkAddr[ChunkNum]     = TargetRegion;
Unit_Count(ChunkNum)            = NewCount;
Mem_ChunkExpanded               = ChunkNum;
}
if (++NumChunkChunkFrees > 3)
CoreFreeCoreSpace (&Source,  SourceSize,   McStat);
else
FREE_MEM   (Source);
} else {
if (NewRegion   (TargetSize,      McStat,     (addrtype *)&ChunkAddrPtr))
{
TargetRegion = ChunkAddrPtr;
memcpy  ((char *)ChunkAddrPtr, (char *)SourceRegion, SourceSize);
TargetRegion  = (addrtype )((char *)TargetRegion
+ sizeof (chunkstruc));
ChunkAddrPtr  = (addrtype *)TargetRegion;
Chunk_Addr(ChunkNum)    = TargetRegion;
Unit_Count(ChunkNum)    = NewCount;
}
if (Normal(*Status))
CoreFreeCoreSpace (&Source,  SourceSize,   McStat);
}
if (Normal(*Status))
Mem_ChunkExpanded      = ChunkNum;
SWAP  = TmpSwap;
TRACK(TrackBak,"ExpandChunk\n");
return(STAT);
}
boolean    Mem_ExpandKrnlChunk
(chunknum      ChunkNum,
ft F,lt Z,zz *Status,   addrtype    *KrnlAddr)
{
addrtype      Source         = NullPtr;
addrtype      SourceRegion   = NullPtr;
sizeinbytes   SourceSize     = 0;
addrtype      TargetRegion   = NullPtr;
indextype     NewCount       = 0;
sizeinbytes   TargetSize     = 0;
addrtype     *ChunkAddrPtr   = NullPtr;
farlongtype   AllocCore1     = 0;
sizetype      ByteAlignment  = 0;
int           TmpDeBug       = DeBug;
booleantype   TmpSwap        = SWAP;
SWAP          = False;
SourceRegion  = Chunk_Addr (ChunkNum);
SourceRegion  = (addrtype )((char *)SourceRegion - sizeof (chunkstruc));
Source        = SourceRegion;
SourceSize    = Unit_Size  (ChunkNum) *  Unit_Count (ChunkNum);
SourceSize   += sizeof (chunkstruc);
NewCount      = Unit_Count (ChunkNum) +  Extend_Qty (ChunkNum);
TargetSize    = Unit_Size  (ChunkNum)  * NewCount;
TargetSize   += sizeof (chunkstruc);
if ((AllocCore1 = TargetSize) % CoreBlk_GapSpace)
{
ByteAlignment       = CoreBlk_GapSpace - (TargetSize % CoreBlk_GapSpace);
AllocCore1         += ByteAlignment;
TargetSize          = AllocCore1;
}
if ((ChunkAddrPtr      = (addrtype *)VoidExtendCore (&AllocCore1))
== NULL)
{
*Status              = Env_CoreNoMore;
} else if (AllocCore1 != TargetSize)
*Status              = Env_CoreNoMore;
if (Normal(*Status))
{
TargetRegion        = ChunkAddrPtr;
memcpy  ((char *)ChunkAddrPtr, (char *)SourceRegion, SourceSize);
TargetRegion         = (addrtype )((char *)TargetRegion
+ sizeof (chunkstruc));
ChunkAddrPtr         = (addrtype *)TargetRegion;
Chunk_Addr(ChunkNum) = TargetRegion;
Unit_Count(ChunkNum) = NewCount;
*KrnlAddr             = TargetRegion;
}
AllocCore1 = SourceSize;
if (Normal(*Status))
if (SourceSize % CoreBlk_GapSpace)
{
ByteAlignment       = CoreBlk_GapSpace - (SourceSize % CoreBlk_GapSpace);
AllocCore1         += ByteAlignment;
}
if (Normal(*Status))
VoidFreeCore       (&Source,     AllocCore1);
DeBug = TmpDeBug;
SWAP  = TmpSwap;
TRACK(TrackBak,"Mem_ExpandKrnlChunk\n");
return(STAT);
}
#ifndef   __MACROIZE_MEM__
boolean    Chunk_ChunkExists
(numtype      ChunkNum,  ft F,lt Z,zz *Status)
{
if (ChunkNum > NumChunks)
{
*Status = Err_BadChunk;
} else if (!ChunkNum) {
*Status = Err_BadChunk;
} else if (Chunk_Addr(ChunkNum) == NullPtr) {
*Status = Err_BadChunk;
} else if (CRC_Value(ChunkNum) != CHUNK_CONSTANT) {
DumpChunkChunk (0, ChunkNum);
*Status = Mem_ChunkCRCisBad;
#ifdef     VALIDATE_MEM_CHUNKS
#ifdef     SYSTEM_ALLOC
} else if (Chunk_Validate(ChunkNum) != CHUNK_CONSTANT) {
DumpChunkChunk (0, ChunkNum);
*Status = Mem_ChunkCRCisBad;
#endif
#endif
}
Mem_ChunkExpanded                = 0;
TRACK(TrackBak,"Chunk_ChunkExists\n");
return(STAT);
}
#endif
boolean    ChkPushChunk (numtype       ChunkNum,  size_t    SizeOfUnit,
ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"ChkPushCunk\n");
*Status    = Env_Normal;
Mem_ChunkExpanded                = 0;
if (ChunkExists (ChunkNum,McStat))
{
if (Chunk_IsData      (ChunkNum))
if (Chunk_IsNumeric   (ChunkNum))
if ((size_t)Unit_Size (ChunkNum)   == SizeOfUnit)
{
if (Stack_Ptr       (ChunkNum)   >= Unit_Count  (ChunkNum))
GrowNumericChunk (ChunkNum,      McStat);
return (STAT);
}
*Status = Err_BadUnitType;
DumpChunkChunk (0, ChunkNum);
}
TRACK(TrackBak,"ChkPushChunk\n");
return(STAT);
}
boolean    ChkPutChunk (numtype       ChunkNum,   indextype   Index,
size_t        SizeOfUnit,
ft F,lt Z,zz *Status,     boolean    *PushFlag)
{
*Status    = Env_Normal;
*PushFlag  = False;
Mem_ChunkExpanded                = 0;
if (ChunkExists (ChunkNum, McStat))
{
if (Chunk_IsData      (ChunkNum)
&&  Chunk_IsNumeric   (ChunkNum)
&&  (size_t)Unit_Size (ChunkNum) == SizeOfUnit)
{
if (Index   >  Stack_Ptr(ChunkNum))
{
DumpChunkChunk (0, ChunkNum);
*Status    = Err_IndexOutOfRange;
} else if (Index              == Stack_Ptr (ChunkNum))
*PushFlag = True;
} else {
*Status = Err_BadUnitType;
DumpChunkChunk (0, ChunkNum);
}
}
TRACK(TrackBak,"ChkPutChunk\n");
return(STAT);
}
boolean    ChkPopChunk (numtype       ChunkNum,   size_t SizeOfUnit,
ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"ChkPopChunk\n");
Mem_ChunkExpanded                = 0;
if (ChunkExists           (ChunkNum,      McStat))
{
if (Chunk_IsData       (ChunkNum))
if (Chunk_IsNumeric    (ChunkNum))
if ((size_t)Unit_Size  (ChunkNum)   == SizeOfUnit)
{
*Status    = Env_Normal;
return(STAT);
}
*Status = Err_BadUnitType;
DumpChunkChunk (0, ChunkNum);
}
TRACK(TrackBak,"ChkPopChunk\n");
return(STAT);
}
boolean    ChkGetChunk (numtype     ChunkNum,    indextype     Index,
size_t      SizeOfUnit,  ft F,lt Z,zz *Status)
{
indextype  StackPtr = 0;
Mem_ChunkExpanded                = 0;
if (ChunkExists (ChunkNum,McStat))
{
if (Chunk_IsData        (ChunkNum)
&&  Chunk_IsNumeric     (ChunkNum)
&& (size_t)Unit_Size    (ChunkNum)   == SizeOfUnit)
{
StackPtr = Stack_Ptr  (ChunkNum);
if (Index   >= StackPtr)
{
if (SetGetSwi)
*Status    = Set_EndOfSet;
else {
DumpChunkChunk (0, ChunkNum);
*Status    = Err_IndexOutOfRange;
}
}
} else {
if ((size_t)Unit_Size     (ChunkNum) != SizeOfUnit)
{
*Status = Err_BadUnitType;
} else {
*Status = Err_BadChunk;
}
DumpChunkChunk (0, ChunkNum);
}
}
TRACK(TrackBak,"ChkGetChunk\n");
return(STAT);
}
void Mem_ShowStats       (void)
{
TraceMsg (0, "\n\n         Env01 Memory Stats\n\n");
TraceMsg (0, "  Chunk Manager Statistics::\n");
sprintf
(Msg, "\n Chunks Allocated         :: %u\n",  ChunksAllocated);
TraceMsg (0, Msg);
sprintf (Msg, " Chunks Freeed            :: %u\n",  ChunksFreeed);
TraceMsg (0, Msg);
sprintf (Msg, " Chunks Reclaimed         :: %u\n\n",ChunksReclaimed);
TraceMsg (0, Msg);
TraceMsg (0, "\n Dump of Chunk ADDRESS'S   ::   ");
DumpChunkChunk (0, ChunkAddrChunk);
Mem_ShowXmemStats   ();
TraceMsg (0, "\n");
return;
}
void Mem_DumpStats       (void)
{
numtype      ChunkNum     = 0;
indextype    StackPtr     = Stack_Ptr(ChunkAddrChunk);
sizetype     BlkSize      = 0;
sprintf (Msg, "\n Dump of Chunk STAT'S      :: StackPtr=%6u\n", StackPtr);
TraceMsg (0, Msg);
TraceMsg (0,
"\n Chunk#  Address  DbId  UnitSize  UnitCount  StackPtr  BlkSize\n");
for (ChunkNum = 0; (ChunkNum < StackPtr) && (ChunkNum < 200); ++ChunkNum)
{
if (Chunk_Addr(ChunkNum) != NullPtr)
{
BlkSize  = Unit_Count(ChunkNum) * Unit_Size(ChunkNum)
+ sizeof (chunkstruc);
sprintf (Msg, " %6u %8x  %4u  %8u  %9u  %8d  %7u\n",
ChunkNum, Chunk_Addr(ChunkNum), Next_Chunk(ChunkNum),
Unit_Size(ChunkNum),
Unit_Count(ChunkNum), Stack_Ptr(ChunkNum), BlkSize);
TraceMsg (0, Msg);
}
}
TraceMsg (0, "\n");
return;
}
#ifdef     VALIDATE_MEM_CHUNKS
#ifdef     SYSTEM_ALLOC
numtype    Chunk_Validate
(numtype     ChunkNum)
{
numtype        CRCvalue       = 0;
sizetype       UnitSize       = Unit_Size  (ChunkNum);
numtype        UnitCount      = Unit_Count (ChunkNum);
addrtype       CoreAddr       = Chunk_Addr (ChunkNum);
sizetype       ByteAlignment  = 0;
farlongtype    FarSize        = 0;
addrtype       EndCoreBlkAddr = NullPtr;
CoreAddr         = (addrtype )((char *)CoreAddr
- (sizeof (chunkstruc)   + CORE_BLOCK_ALIGN));
FarSize          = (UnitSize * UnitCount) + sizeof (chunkstruc)
+ CORE_BLOCK_ALIGN       + 4;
if (FarSize % CoreBlk_GapSpace)
{
ByteAlignment = CoreBlk_GapSpace - (FarSize % CoreBlk_GapSpace);
FarSize      += ByteAlignment;
}
EndCoreBlkAddr   = (addrtype )((char  *)CoreAddr + (FarSize - 4));
CRCvalue         = *(numtype *)EndCoreBlkAddr;
return(CRCvalue);
}
#endif
#endif
/* 当前文件是./CINT2000\255.vortex\src\mem01.c*/

#define MEM_C
#define MEM01
/* 当前文件是./CINT2000\255.vortex\src\mem01.h*/

#define MEM01_H

static   FilePtrType        XmemFilePtr       = NULL;
static   farlongtype        XmemSize          = 0;
static   indextype          XmemHeadFreeVbns  = 0;
static   numtype            XmemBlkDirChunk   = 0;
static   indextype          XmemHeadFreeBlks  = 0;
static   indextype          XmemHeadNullBlks  = 0;
static   numtype            XmemBlkTknChunk   = 0;
static   numtype            XmemBlkSizeChunk  = 0;
static   indextype         *XmemBlkDir        = NullPtr;
static   blktkntype        *XmemBlkTkn        = NullPtr;
static   bytessize         *XmemBlkSize       = NullPtr;
static   FILE              *MemBlkFile        = NullPtr;
static   indextype          MemHeadFreeVbns   = 0;
static   numtype            MemBlkDirChunk    = 0;
static   indextype          MemHeadFreeBlks   = 0;
static   indextype          MemHeadNullBlks   = 0;
static   numtype            MemBlkTknChunk    = 0;
static   numtype            MemBlkSizeChunk   = 0;
static   indextype         *MemBlkDir         = NullPtr;
static   blktkntype        *MemBlkTkn         = NullPtr;
static   bytessize         *MemBlkSize        = NullPtr;

#define MemMakeChunk           Mem_MakeChunk
#define MemMakeCppChunk        Mem_MakeCppChunk
#define MemMakeStrChunk        Mem_MakeStrChunk
#define MemDumpChunk           Mem_DumpChunk
#define MemFreeChunk           Mem_FreeChunk
#define MemFreeChunkNum        Mem_FreeChunkNum
#define MemClearChunkSpace     Mem_ClearChunkSpace
#define MemFreeChunkSpace      Mem_FreeChunkSpace
#define MemSwapOutChunk        Mem_SwapOutChunk
#define MemSwapInChunk         Mem_SwapInChunk
#define MemCopyOutChunk        Mem_CopyOutChunk
#define MemCopyInChunk         Mem_CopyInChunk
#define MemGetFileBlk          Mem_GetFileBlk
#define MemFreeFileBlk         Mem_FreeFileBlk
#define MemNewXmemBlk          Mem_NewXmemBlk
#define MemFreeXmemBlk         Mem_FreeXmemBlk
#define MemGetFreeXmemVbn      Mem_GetFreeXmemVbn
#define MemGetFreeXmemBlk      Mem_GetFreeXmemBlk
boolean MemMakeChunk
(bytessize     UnitSize,  indextype AllocQty,
indextype     ExtendQty, idtype    CoreDbId,
ft F,lt Z,zz *Status,    numtype  *Chunk);
boolean MemMakeCppChunk
(bytessize     CppObjSize,indextype AllocQty,
indextype     ExtendQty, idtype    CoreDbId,
ft F,lt Z,zz *Status,    numtype  *Chunk);
boolean MemMakeStrChunk
(bytessize     MaxLength, indextype NumStrings,
indextype     ExtendQty, bytessize TextLength,
idtype        CoreDbId,
ft F,lt Z,zz *Status,    numtype  *Chunk);
boolean MemDumpChunk
(int           MsgLevel,  numtype   Chunk,
ft F,lt Z,zz *Status);
boolean Mem_DumpChunkPart
(int           MsgLevel,  numtype       Chunk,
numtype       Ilow,      numtype       Ihigh,
ft F,lt Z,zz *Status);
boolean MemFreeChunk
(numtype      *ChunkNum,  ft F,lt Z,zz *Status);
boolean MemFreeChunkNum
(numtype      *ChunkNum,  ft F,lt Z,zz *Status);
boolean MemClearChunkSpace
(numtype       Chunk,     ft F,lt Z,zz *Status);
boolean MemFreeChunkSpace
(numtype       Chunk,     ft F,lt Z,zz *Status);
boolean MemSwapOutChunk
(numtype       Chunk,     ft F,lt Z,zz *Status,
vbntype      *Vbn);
boolean MemSwapInChunk
(numtype       Chunk,     ft F,lt Z,zz *Status,
vbntype      *Vbn);
boolean MemCopyOutChunk
(numtype       Chunk,     ft F,lt Z,zz *Status,
vbntype      *SwapVbn);
boolean MemCopyInChunk
(numtype       Chunk,     numtype       SwapVbn,
addrtype      SwapAddr,  ft F,lt Z,zz *Status);
boolean Mem_MoveChunk
(numtype       Chunk,     ft F,lt Z,zz *Status,
addrtype     *FreeAddr,  sizeinbytes  *FreeSize);
boolean Mem_MakeXmemChunks
(indextype     AllocQty,  indextype     ExtendQty,
ft F,lt Z,zz *Status);
void    Mem_AssignXmemFile
(char         *FileName);
void    Mem_CloseXmemFile
(void);
boolean MemGetFileBlk
(bytessize     SizeInBytes,
blkhdrtype   *BlkHdr,    ft F,lt Z,zz *Status,
vbntype      *Vbn,       lt64         *FileOffset);
boolean MemFreeFileBlk
(blkhdrtype   *BlkHdr,
ft F,lt Z,zz *Status,    vbntype      *Vbn);
boolean MemNewXmemBlk
(bytessize     Bytes,     ft F,lt Z,zz *Status,
vbntype      *Vbn,       lt64         *XmemOffset);
boolean MemFreeXmemBlk
(ft F,lt Z,zz *Status,    vbntype      *Vbn);
void    Mem_ShowXmemStats
(void);

#ifdef NULL_TRACE_STRS
#define TraceStr6(StrNum)  TraceStr6[0]
static const char   *TraceStr6[2] = {"\0", "   ...MEM01... message\n" };
#else
#define TraceStr6(StrNum)  TraceStr6[StrNum]
static const char   *TraceStr6[53] =
{
" *** ERROR ... MemMakeChunk ZERO(0) UnitSize=%u, AllocQty=%u\n",
"  New TextPtrChunk[%6u];\n",
"  StrucHdr::TextChunk = %3u;\n",
"      Value[%4u]= ",
"        Mem  FreeChunk       [%6u]; 2nd Free=%6u\n",
"        Mem  FreeChunkNum    [%6u]; 2nd Free=%6u\n",
"     CLEAR Chunk[%4u] @%x * Bytes= %6u\n",
"        Mem  FreeChunk    [%6u]  Bytes =%8u  @%x\n",
"    SwapOUT Chunk[%6u](*%4u) Units= %6u @%8x; Vbn=%6u\n",
"      TO              BlkIndex %6u; BlkOffset= %8u\n",
"      Seek To File Offset    = %8ld\n",
"      Write From Chunk       @ %8x\n",
"          From Chunk           [%6u](* %4u) units= %6u\n",
"    SwapIN  Chunk[%6u](*%4u); Vbn=%6u\n",
"      FROM Vbn as     BlkIndex %6u; BlkOffset= %8u\n",
"      Seek To File Offset    = %8ld\n",
"      Read  Into Chunk       @ %8x\n",
"     COPY From Vbn[%6u] XmemBlk[%6u] Offset= %8ld\n",
"      TO   Chunk[%6u]\n",
"\n    CopyOUT Chunk[%6u](*%4u) Units= %6u @%8x; Blk Size=%4u\n",
"      TO   Vbn[%6u] = BlkIndex %6u; BlkOffset= %8u\n",
"     SEEK To File Offset    = %8ld\n",
"     COPY To  Vbn[%3u] Offset= %ld \n",
"     FROM Chunk(%3u) Base address @%8x; for %6u bytes\n",
"\n    CopyIN  Chunk[%6u];  From Vbn= %6u To SwapAddr @%6x\n",
"***ERROr...MemCopyInChunk Chunk[%3u] Swap Vbn= 0\n",
"      FROM Vbn[%6u] = BlkIndex %6u; BlkOffset= %8u; BlkSize=%4u\n",
"     SEEK To File Offset    = %8ld\n",
"     CopyIN  From XmemBlk[%4u]  Offset= %6ld\n",
"     TO   Chunk(%3u) %4u units * %2u bytes\n",
"      MemFreeFileBlk referenced by Vbn = %6u\n",
"      MemGetFileBlk for CUR Vbn = %6u @Offset= %8u\n",
"      MemGetFileBlk for NEW Vbn = %6u @Offset= %8u\n",
"          PrePend ",
"          PostPend",
"Blk[%4u]  Size     =%8lu;\n",
"          To  GapBlk [%4u]  New Size =%8lu; @%8x\n",
"          Insert Blk=%6u Into NullBlks List; Next= %6u\n",
"          Delete Blk=%6u From FreeBlks List; Prev= %6u\n",
"          Insert Blk=%6u Into NullBlks List; Next= %6u\n",
"  NumFreeBlks In ReGap= %4u\n",
"          Insert Blk=%6u Into FreeBlks List; Next= %6u\n",
"          Insert Vbn=%6u Into FreeVbns List; Next= %6u\n",
"      New      Vbn  =%6u; BlkIndex=%6u @FileOffset =%8u\n",
"      Get Free Vbn  =%6u\n",
"      Get New  Vbn  =%6u\n",
"      ReClaim EqualSized FreeBlk= %6u, Prev=%6u\n",
"  NumFreeBlks In Search = %4u\n",
"      Get NULL Blk  =%6u\n",
"      Get New  Blk  =%6u\n",
"      ReGap Blk     =%6u   Offset   @%8u Tosize=%6u\n",
"      Increment Eof =%6u  To %6u\n",
"     TO   Chunk(%3u) Base address @%8x; for %6u bytes\n"
};
#endif
#define MemGetChunkAddr        Mem_GetChunkAddr
#define MemPutStackPtr         Mem_PutStackPtr
#define MemGetStackPtr         Mem_GetStackPtr
#define MemPushWord            Mem_PushWord
#define MemPutWord             Mem_PutWord
#define MemPopWord             Mem_PopWord
#define MemGetWord             Mem_GetWord
#define MemGetSomeBytes        Mem_GetSomeBytes
boolean MemGetChunkAddr(numtype       Chunk,
ft F,lt Z,zz *Status,    addrtype *ChunkAddr);
boolean MemPutStackPtr (numtype       Chunk,     indextype StackPtr,
ft F,lt Z,zz *Status);
boolean MemGetStackPtr (numtype       Chunk,
ft F,lt Z,zz *Status,    indextype *StackPtr);
boolean MemPushWord    (numtype       Chunk,    word       WordValue,
ft F,lt Z,zz *Status,   indextype *StackPtr);
boolean MemGetWord     (numtype       Chunk,    indextype  Index,
ft F,lt Z,zz *Status,   word      *WordValue);
boolean MemGetSomeBytes(numtype       Chunk,     indextype   Index,
bytessize     ByteCount,
ft F,lt Z,zz *Status,    addrtype    SomeBytes);
boolean NewRegion      (sizeinblocks  Blocks,
ft F,lt Z,zz *Status,    addrtype *Region);
#define MemPutIndex         Mem_PutWord
#define MemGetIndex         Mem_GetWord
#define MemPopIndex         Mem_PopWord
#define MemPushIndex        Mem_PushWord
boolean    MemMakeChunk   (bytessize     UnitSize,  indextype   AllocQty,
indextype     ExtendQty, idtype      CoreDbId,
ft F,lt Z,zz *Status,    numtype    *Chunk)
{
boolean  VaryLength  = False;
boolean  PtrChunk    = False;
if (!UnitSize || !AllocQty)
{
*Status = Err_BadUnitSize;
}
if (Normal(*Status))
if (MakeChunk         (VaryLength, PtrChunk, UnitSize, AllocQty, ExtendQty,
CoreDbId,   McStat,   Chunk))
{
IsNumeric_Chunk    (*Chunk);
IsData_Chunk       (*Chunk);
}
TRACK(TrackBak,"MemMakeChunk\n");
return(STAT);
}
boolean MemMakeCppChunk (bytessize     CppObjSize,   indextype   AllocQty,
indextype     ExtendQty,    idtype      CoreDbId,
ft F,lt Z,zz *Status,       numtype    *Chunk)
{
boolean  VaryLength  = False;
boolean  PtrChunk    = True;
MakeChunk   (VaryLength, PtrChunk,  CppObjSize,  AllocQty,  ExtendQty,
CoreDbId,   McStat,    Chunk);
TRACK(TrackBak,"MemMakeCppChunk\n");
return(STAT);
}
boolean MemMakeStrChunk (bytessize     MaxLength, indextype   NumStrings,
indextype     ExtendQty, bytessize   TextLength,
idtype        CoreDbId,
ft F,lt Z,zz *Status,    numtype    *StrChunk)
{
boolean    VaryLength  = False;
boolean    PtrChunk    = True;
numtype    TextChunk   = 0;
struchdr  *StrucHdr    = NullPtr;
if (MakeChunk (VaryLength,   PtrChunk,  sizeof (stringstruc),  NumStrings,
ExtendQty,    CoreDbId,  McStat,                StrChunk))
VaryLength  = True;
PtrChunk    = False;
if (Normal(*Status)
&&  *StrChunk)
if (MakeChunk (VaryLength,   PtrChunk,  sizeof (char),         TextLength,
ExtendQty*32, CoreDbId,  McStat,               &TextChunk))
{
Extend_Qty      (TextChunk)  = ExtendQty * 32;
MaxUnit_Length  (TextChunk)  = MaxLength;
IsData_Chunk    (*StrChunk);
StrucHdr                     = (struchdr *)Chunk_Addr (*StrChunk);
StrucHdr->TextChunk          = TextChunk;
StrucHdr->TextVbn            = 0;
StrucHdr->FirstFreeGap       = 0;
Stack_Ptr         (*StrChunk)++;
}
TRACK(TrackBak,"MemMakeStrChunk\n");
return(STAT);
}
boolean MemDumpChunk  (int           MsgLevel,    numtype   Chunk,
ft F,lt Z,zz *Status)
{
if (!Normal(*Status))
DumpChunkChunk (0,        Chunk);
else
DumpChunkChunk (MsgLevel, Chunk);
TRACK(TrackBak,"MemDumpChunk\n");
return(STAT);
}
boolean Mem_DumpChunkPart
(int           MsgLevel,    numtype       Chunk,
numtype       Ilow,        numtype       Ihigh,
ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"MemDumpChunkPart\n");
return(STAT);
}
boolean    MemFreeChunk   (numtype      *Chunk,  ft F,lt Z,zz *Status)
{
if (*Chunk)
if (MemClearChunkSpace (*Chunk,  McStat))
if (MemFreeChunkSpace  (*Chunk,  McStat))
{
ChunksFreeed++;
Next_Chunk(*Chunk)  = Theory->NextFree;
Theory->NextFree    = *Chunk;
*Chunk               = 0;
}
TRACK(TrackBak,"MemFreeChunk\n");
return (STAT);
}
boolean    MemFreeChunkNum
(numtype      *Chunk,  ft F,lt Z,zz *Status)
{
if (*Chunk)
{
ChunksFreeed++;
Next_Chunk(*Chunk)  = Theory->NextFree;
Theory->NextFree    = *Chunk;
Chunk_Addr(*Chunk)  = NullPtr;
*Chunk               = 0;
}
TRACK(TrackBak,"MemFreeChunkNum\n");
return (STAT);
}
boolean MemClearChunkSpace (numtype    Chunk,     ft F,lt Z,zz *Status)
{
indextype   UnitCount = Unit_Count(Chunk);
bytessize   UnitSize  = Unit_Size(Chunk);
addrtype    ChunkAddr = Chunk_Addr(Chunk);
bytessize   ChunkSize = 0;
Mem_ChunkExpanded                = 0;
if (ChunkExists (Chunk, McStat))
{
ChunkSize = UnitSize * (bytessize )UnitCount;
}
TRACK(TrackBak,"MemClearChunkSpace\n");
return(STAT);
}
boolean MemFreeChunkSpace (numtype      Chunk,  ft F,lt Z,zz *Status)
{
indextype   UnitCount = Unit_Count   (Chunk);
bytessize   UnitSize  = Unit_Size    (Chunk);
addrtype    ChunkAddr = Chunk_Addr   (Chunk);
bytessize   ChunkSize = UnitSize    * (bytessize )UnitCount;
ChunkSize            += sizeof (chunkstruc);
ChunkAddr             = (addrtype )((char *)ChunkAddr
- sizeof (chunkstruc));
CoreFreeCoreSpace       (&ChunkAddr,  ChunkSize,  McStat);
Chunk_Addr  (Chunk)   = NullPtr;
if (!Normal(*Status))
DumpChunkChunk (0, Chunk);
TRACK(TrackBak,"MemFreeChunkSpace\n");
return(STAT);
}
boolean MemSwapOutChunk (numtype    Chunk,    ft F,lt Z,zz *Status,
vbntype   *Vbn)
{
TRACK(TrackBak,"MemSwapOutChunk\n");
return(STAT);
}
boolean MemSwapInChunk  (numtype       Chunk,
ft F,lt Z,zz *Status, vbntype  *Vbn)
{
TRACK(TrackBak,"MemSwapInChunk\n");
return(STAT);
}
boolean MemCopyOutChunk (numtype    Chunk,    ft F,lt Z,zz *Status,
vbntype   *SwapVbn)
{
TRACK(TrackBak,"MemCopyOutChunk\n");
return(STAT);
}
boolean MemCopyInChunk  (numtype       Chunk,      numtype       SwapVbn,
addrtype      SwapAddr,   ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"MemCopyInChunk\n");
return(STAT);
}
boolean Mem_MoveChunk   (numtype       ChunkNum,  ft F,lt Z,zz *Status,
addrtype     *FreeAddr,  sizeinbytes  *FreeSize)
{
addrtype      Source         = NullPtr;
addrtype      SourceRegion   = NullPtr;
sizeinbytes   SourceSize     = 0;
addrtype      TargetRegion   = NullPtr;
addrtype     *ChunkAddrPtr   = NullPtr;
*FreeAddr      =  NullPtr;
*FreeSize      =  0;
if (DbmBug)
if (TraceMsg (0, " BEFORE move ::    "))
Mem_DumpChunkChunk (0, ChunkNum);
SourceRegion  = Chunk_Addr (ChunkNum);
SourceRegion  = (addrtype )((char *)SourceRegion - sizeof (chunkstruc));
Source        = SourceRegion;
SourceSize   = Unit_Size  (ChunkNum) *  Unit_Count (ChunkNum);
SourceSize  += sizeof (chunkstruc);
if (Normal(*Status))
{
if (NewRegion   (SourceSize,      McStat,     (addrtype *)&ChunkAddrPtr))
{
TargetRegion = ChunkAddrPtr;
if (DbmBug || MemBug)
{
sprintf (Msg, TraceStr6(41),
SourceSize, SourceRegion, TargetRegion);
TraceMsg (0, Msg);
}
memcpy  ((char *)ChunkAddrPtr, (char *)SourceRegion, SourceSize);
TargetRegion  = (addrtype )((char *)TargetRegion
+ sizeof (chunkstruc));
ChunkAddrPtr  = (addrtype *)TargetRegion;
Chunk_Addr(ChunkNum)    = TargetRegion;
if (DbmBug)
if (TraceMsg (0, " AFTER  move ::    "))
Mem_DumpChunkChunk (0, ChunkNum);
}
*FreeAddr      =  Source;
*FreeSize      =  SourceSize;
if (DbmBug)
{
sprintf (Msg,
" Mem_MoveChunk [%6u] :: TO Target @%8x; Size :=%6u,  From @%8x.\n",
ChunkNum, TargetRegion, SourceSize, SourceRegion);
TraceMsg (0, Msg);
}
}
TRACK(TrackBak,"Mem_MoveChunk\n");
return(STAT);
}
boolean    Mem_MakeXmemChunks
(indextype     AllocQty,  indextype     ExtendQty,
ft F,lt Z,zz *Status)
{
if (MemMakeChunk   (sizeof(indextype),      AllocQty,
ExtendQty,              0,
McStat,                &XmemBlkDirChunk))
if (MemPutStackPtr (XmemBlkDirChunk,        1,                   McStat))
if (MemMakeChunk   (sizeof(blktkntype),     AllocQty,
ExtendQty,              0,
McStat,                &XmemBlkTknChunk))
if (MemPutStackPtr (XmemBlkTknChunk,        1,                   McStat))
if (MemMakeChunk   (sizeof(bytessize ),     AllocQty,
ExtendQty,              0,
McStat,                &XmemBlkSizeChunk))
if (MemPutStackPtr (XmemBlkSizeChunk,       1,                   McStat))
{
XmemSize         = 0;
MemBlkFile       = XmemFilePtr;
MemBlkDirChunk   = XmemBlkDirChunk;
MemBlkTknChunk   = XmemBlkTknChunk;
MemBlkSizeChunk  = XmemBlkSizeChunk;
XmemHeadFreeVbns =
MemHeadFreeVbns = 0;
XmemHeadFreeBlks =
MemHeadFreeBlks = 0;
XmemHeadNullBlks =
MemHeadNullBlks = 0;
XmemBlkDir       =
MemBlkDir       = (indextype  *)Theory->ChunkAddr[XmemBlkDirChunk];
XmemBlkTkn       =
MemBlkTkn       = (blktkntype *)Theory->ChunkAddr[XmemBlkTknChunk];
XmemBlkSize      =
MemBlkSize      = (bytessize  *)Theory->ChunkAddr[XmemBlkSizeChunk];
}
if (DeBug)
DumpChunkChunk (1, XmemBlkDirChunk);
TRACK(TrackBak,"  strcpy (Mem_MakeXmemChunks\n");
return (STAT);
}
void    Mem_AssignXmemFile    (char         *Mem_File)
{
if (strlen  (Mem_File) == 0 || !strcmp( Mem_File , "NULL") )
{
SWAP   = False;
} else if ((XmemFilePtr = fopen(Mem_File, "w+b")) == NULL) {
fprintf (stderr, "%s:  can't open Xmem_File\n", Mem_File);
SendMsg (0, "***WARNING... Swap Chunks will be suppressed\n");
SWAP   = False;
} else {
if (FREEZE_GRP_PACKETS == False)
SWAP   = True;
#ifdef NO_DISKCACHE
if (setvbuf (XmemFilePtr, NULL, _IONBF, 0))
SendMsg (0, "***ERROR... setvbuf() function failed\n");
#endif
}
return;
}
void    Mem_CloseXmemFile (void)
{
fclose (XmemFilePtr);
return;
}
boolean MemGetFileBlk   (bytessize     SizeInBytes, blkhdrtype *BlkHdr,
ft F,lt Z,zz *Status,
vbntype      *Vbn,         lt64       *FileOffset)
{
indextype   BlkIndex    = 0;
blktkntype  BlkTkn;
lt64        TmpXmemSize = XmemSize;
*FileOffset            = 0;
XmemFilePtr           = BlkHdr->BlkFile;
XmemSize              = BlkHdr->EofMark;
XmemHeadFreeVbns      = BlkHdr->HeadFreeVbns;
XmemBlkDirChunk       = BlkHdr->BlkDirChunk;
XmemHeadFreeBlks      = BlkHdr->HeadFreeBlks;
XmemHeadNullBlks      = BlkHdr->HeadNullBlks;
XmemBlkTknChunk       = BlkHdr->BlkTknChunk;
XmemBlkSizeChunk      = BlkHdr->BlkSizeChunk;
if (MemGetChunkAddr    (BlkHdr->BlkDirChunk,
McStat,                   (addrtype *)&XmemBlkDir))
if (MemGetChunkAddr    (BlkHdr->BlkTknChunk,
McStat,                   (addrtype *)&XmemBlkTkn))
if (MemGetChunkAddr    (BlkHdr->BlkSizeChunk,
McStat,                   (addrtype *)&XmemBlkSize))
if (*Vbn)
{
if (MemGetIndex     (XmemBlkDirChunk,  *Vbn,      McStat,  &BlkIndex))
if (MemGetSomeBytes (XmemBlkTknChunk,   BlkIndex,   sizeof (blktkntype),
McStat,                    (addrtype )&BlkTkn))
*FileOffset     = BlkTkn.Offset;
} else {
MemNewXmemBlk   (SizeInBytes,       McStat,   Vbn,      FileOffset);
}
BlkHdr->HeadFreeVbns  = XmemHeadFreeVbns;
BlkHdr->HeadFreeBlks  = XmemHeadFreeBlks;
BlkHdr->HeadNullBlks  = XmemHeadNullBlks;
BlkHdr->EofMark       = XmemSize;
XmemSize              = TmpXmemSize;
XmemFilePtr           = MemBlkFile;
XmemHeadFreeVbns      = MemHeadFreeVbns;
XmemBlkDirChunk       = MemBlkDirChunk;
XmemHeadFreeBlks      = MemHeadFreeBlks;
XmemHeadNullBlks      = MemHeadNullBlks;
XmemBlkTknChunk       = MemBlkTknChunk;
XmemBlkSizeChunk      = MemBlkSizeChunk;
XmemBlkDir            = MemBlkDir;
XmemBlkTkn            = MemBlkTkn;
XmemBlkSize           = MemBlkSize;
TRACK(TrackBak,"MemGetFileBlk\n");
return(STAT);
}
boolean MemFreeFileBlk  (blkhdrtype   *BlkHdr,
ft F,lt Z,zz *Status,   vbntype      *Vbn)
{
*Status  = Err_NotImplemented;
TRACK(TrackBak,"MemFreeFileBlk\n");
return(STAT);
}
boolean MemNewXmemBlk (bytessize   SizeInBytes,  ft F,lt Z,zz *Status,
vbntype    *Vbn,          lt64         *XmemOffset)
{
*Status  = Err_NotImplemented;
TRACK(TrackBak,"MemNewXmemBlk\n");
return(STAT);
}
boolean MemFreeXmemBlk  (ft F,lt Z,zz *Status,    vbntype    *Vbn)
{
*Status  = Err_NotImplemented;
TRACK(TrackBak,"MemFreeXmemBlk\n");
return(STAT);
}
void Mem_ShowXmemStats       (void)
{
TraceMsg (0, " Dump of XmemBlkSizeChunk  ::    ");
DumpChunkChunk (0, XmemBlkSizeChunk);
TraceMsg (0, "\n Dump of XmemBlkDirChunk   ::    ");
DumpChunkChunk (0, XmemBlkDirChunk);
return;
}
/* 当前文件是./CINT2000\255.vortex\src\mem10.c*/

#define MEM_C
#define MEM10
/* 当前文件是./CINT2000\255.vortex\src\mem10.h*/

#ifndef MEM10_H
#define MEM10_H
#define MemFreezeChunk         Mem_FreezeChunk
#define MemDefrostChunk        Mem_DefrostChunk
#define MemGetChunkSize        Mem_GetChunkSize
#define MemGetChunkStruc       Mem_GetChunkStruc
#define MemDumpChunkStruc      Mem_DumpChunkStruc
#define MemPutChunkAddr        Mem_PutChunkAddr
#define MemGetChunkAddr        Mem_GetChunkAddr
#define MemPutStackPtr         Mem_PutStackPtr
#define MemGetStackPtr         Mem_GetStackPtr
#define MemPushEntity          Mem_PushEntity
#define MemPutEntity           Mem_PutEntity
#define MemExtractEntity       Mem_ExtractEntity
#define MemGetEntity           Mem_GetEntity
#define MemNewBitChunk         Mem_NewBitChunk
#define MemPushBit             Mem_PushBit
#define MemPutBit              Mem_PutBit
#define MemPopBit              Mem_PopBit
#define MemGetBit              Mem_GetBit
#define MemPushShort           Mem_PushShort
#define MemPutShort            Mem_PutShort
#define MemPopShort            Mem_PopShort
#define MemGetShort            Mem_GetShort
#define MemPushWord            Mem_PushWord
#define MemPutWord             Mem_PutWord
#define MemPopWord             Mem_PopWord
#define MemGetWord             Mem_GetWord
#define MemPushLong            Mem_PushLong
#define MemPutLong             Mem_PutLong
#define MemPopLong             Mem_PopLong
#define MemGetLong             Mem_GetLong
#define MemPushAddr            Mem_PushAddr
#define MemPutAddr             Mem_PutAddr
#define MemPopAddr             Mem_PopAddr
#define MemGetAddr             Mem_GetAddr
#define MemPushToken           Mem_PushToken
#define MemPutToken            Mem_PutToken
#define MemPopToken            Mem_PopToken
#define MemGetToken            Mem_GetToken
#define MemPushFuncPtr         Mem_PushFuncPtr
#define MemPutFuncPtr          Mem_PutFuncPtr
#define MemPopFuncPtr          Mem_PopFuncPtr
#define MemGetFuncPtr          Mem_GetFuncPtr
#define MemPushSomeBytes       Mem_PushSomeBytes
#define MemPutSomeBytes        Mem_PutSomeBytes
#define MemAssertPutBytes      Mem_AssertPutBytes
#define MemPopSomeBytes        Mem_PopSomeBytes
#define MemGetSomeBytes        Mem_GetSomeBytes
#define MemAssertGetBytes      Mem_AssertGetBytes
#define MemNewString           Mem_NewString
#define MemPushString          Mem_PushString
#define MemPutString           Mem_PutString
#define MemPopString           Mem_PopString
#define MemGetString           Mem_GetString
#define MemDeleteString        Mem_DeleteString
boolean MemFreezeChunk (numtype       Chunk,     ft F,lt Z,zz *Status);
boolean MemDefrostChunk(numtype       Chunk,     ft F,lt Z,zz *Status);
boolean MemGetChunkSize(numtype       Chunk,
ft F,lt Z,zz *Status,   indextype *UnitCount,
bytessize *UnitSize);
boolean MemGetChunkStruc
(numtype       Chunk,     ft F,lt Z,zz *Status,
chunkstruc   *ChunkRef);
boolean MemDumpChunkStruc
(chunkstruc   *ChunkRef,  ft F,lt Z,zz *Status);
boolean MemPutChunkAddr(numtype       Chunk,     addrtype  ChunkAddr,
ft F,lt Z,zz *Status);
boolean MemGetChunkAddr(numtype       Chunk,
ft F,lt Z,zz *Status,    addrtype *ChunkAddr);
boolean MemPutStackPtr (numtype       Chunk,     indextype StackPtr,
ft F,lt Z,zz *Status);
boolean Mem_AssertStackPtr
(numtype       Chunk,     indextype  StackPtr,
ft F,lt Z,zz *Status,    addrtype  *ChunkAddr);
boolean MemGetStackPtr (numtype       Chunk,
ft F,lt Z,zz *Status,    indextype *StackPtr);
boolean MemPushEntity  (numtype       Chunk,    bytessize  ByteCount,
addrtype      Entity,
ft F,lt Z,zz *Status,   indextype *ByteOffset);
boolean MemPutEntity   (numtype       Chunk,    indextype  ByteOffset,
bytessize     ByteCount, addrtype  Entity,
ft F,lt Z,zz *Status);
boolean MemExtractEntity
(numtype       Chunk,    indextype     Offset,
bytessize     Count,    ft F,lt Z,zz *Status);
boolean MemGetEntity   (numtype       Chunk,    indextype  ByteOffset,
bytessize     ByteCount,
ft F,lt Z,zz *Status,   addrtype  *Entity);
boolean MemNewBitChunk (numtype       BitWidth, idtype     CoreDbId,
ft F,lt Z,zz *Status,   numtype   *BitChunk);
boolean MemPushBit     (numtype       Chunk,    word       BitValue,
ft F,lt Z,zz *Status,   indextype *StackPtr);
boolean MemPutBit      (numtype       Chunk,    indextype  Index,
word          BitValue, ft F,lt Z,zz *Status);
boolean MemPopBit      (numtype       Chunk,    ft F,lt Z,zz *Status,
word         *BitValue, indextype *StackPtr);
boolean MemGetBit      (numtype       Chunk,    indextype  Index,
ft F,lt Z,zz *Status,   word      *BitValue);
boolean MemPushShort   (numtype       Chunk,    shorttype  ShortValue,
ft F,lt Z,zz *Status,   indextype *StackPtr);
boolean MemPutShort    (numtype       Chunk,    indextype  Index,
shorttype     ShortVal, ft F,lt Z,zz *Status);
boolean MemPopShort    (numtype       Chunk,    ft F,lt Z,zz *Status,
shorttype    *ShortVal, indextype *StackPtr);
boolean MemGetShort    (numtype       Chunk,    indextype  Index,
ft F,lt Z,zz *Status,   shorttype *ShortValue);
boolean MemPushWord    (numtype       Chunk,    word       WordValue,
ft F,lt Z,zz *Status,   indextype *StackPtr);
boolean MemPutWord     (numtype       Chunk,    indextype  Index,
word          WordValue,ft F,lt Z,zz *Status);
boolean MemPopWord     (numtype       Chunk,    ft F,lt Z,zz *Status,
word         *WordValue,indextype *StackPtr);
boolean MemGetWord     (numtype       Chunk,    indextype  Index,
ft F,lt Z,zz *Status,   word      *WordValue);
boolean MemPushLong    (numtype       Chunk,    lt64       LongValue,
ft F,lt Z,zz *Status,   indextype *StackPtr);
boolean MemPutLong     (numtype       Chunk,    indextype  Index,
lt64          LongValue,ft F,lt Z,zz *Status);
boolean MemPopLong     (numtype       Chunk,    ft F,lt Z,zz *Status,
lt64         *LongValue,indextype *StackPtr);
boolean MemGetLong     (numtype       Chunk,    indextype  Index,
ft F,lt Z,zz *Status,   lt64      *LongValue);
boolean MemPushAddr    (numtype       Chunk,   addrtype    Addr,
ft F,lt Z,zz *Status,  indextype  *StackPtr);
boolean MemPutAddr     (numtype       Chunk,   indextype   Index,
addrtype      Addr,    ft F,lt Z,zz *Status);
boolean MemPopAddr     (numtype       Chunk,   ft F,lt Z,zz *Status,
addrtype     *Addr,    indextype  *StackPtr);
boolean MemGetAddr     (numtype       Chunk,   indextype   Index,
ft F,lt Z,zz *Status,  addrtype   *Addr);
boolean MemPushToken   (numtype       Chunk,   tokentype  *Token,
ft F,lt Z,zz *Status,  indextype  *StackPtr);
boolean MemPutToken    (numtype       Chunk,   indextype   Index,
tokentype    *Token,   ft F,lt Z,zz *Status);
boolean MemPopToken    (numtype       Chunk,   ft F,lt Z,zz *Status,
tokentype    *Token,   indextype  *StackPtr);
boolean MemGetToken    (numtype       Chunk,   indextype   Index,
ft F,lt Z,zz *Status,  tokentype  *Token);
boolean MemPushSomeBytes
(numtype       Chunk,     bytessize   ByteCount,
addrtype      SomeBytes,
ft F,lt Z,zz *Status,    indextype  *StackPtr);
boolean MemPutSomeBytes(numtype       Chunk,     indextype   Index,
bytessize     ByteCount, addrtype    SomeBytes,
ft F,lt Z,zz *Status);
boolean MemPopSomeBytes(numtype       Chunk,     bytessize   ByteCount,
ft F,lt Z,zz *Status,
addrtype      SomeBytes, indextype  *StackPtr);
boolean MemGetSomeBytes(numtype       Chunk,     indextype   Index,
bytessize     ByteCount,
ft F,lt Z,zz *Status,    addrtype    SomeBytes);
boolean MemPushFuncPtr (numtype       Chunk,   funcptrtype   FuncPtr,
ft F,lt Z,zz *Status,  indextype    *StackPtr);
boolean MemPopFuncPtr  (numtype       Chunk,   ft F,lt Z,zz *Status,
funcptrtype  *FuncPtr, indextype    *StackPtr);
boolean MemPutFuncPtr  (numtype       Chunk,   indextype     Index,
funcptrtype   FuncPtr, ft F,lt Z,zz *Status);
boolean MemGetFuncPtr  (numtype       Chunk,   indextype     Index,
ft F,lt Z,zz *Status,  funcptrtype  *FuncPtr);
boolean MemNewString   (numtype       Chunk,     char       *String,
ft F,lt Z,zz *Status,    indextype  *StackPtr);
boolean MemDeleteString(numtype       Chunk,     indextype   StackPtr,
ft F,lt Z,zz *Status);
boolean MemPushString  (numtype       Chunk,     char       *String,
ft F,lt Z,zz *Status,    indextype  *StackPtr);
boolean MemPutString   (numtype       Chunk,     indextype   Index,
char         *String,    ft F,lt Z,zz *Status);
boolean MemPopString   (numtype       Chunk,     ft F,lt Z,zz *Status,
char        **String,    indextype  *StackPtr);
boolean MemGetString   (numtype       Chunk,     indextype   Index,
ft F,lt Z,zz *Status,    char      **String);
#endif
boolean    MemFreezeChunk (numtype  Chunk,  ft F,lt Z,zz *Status)
{
Mem_ChunkExpanded                = 0;
if (ChunkExists (Chunk, McStat))
Chunk_Addr(Chunk) = NullPtr;
TRACK(TrackBak,"MemFreezeChunk\n");
return(STAT);
}
boolean    MemDefrostChunk (numtype  Chunk,  ft F,lt Z,zz *Status)
{
Mem_ChunkExpanded                = 0;
if (ChunkExists (Chunk, McStat))
Chunk_Addr(Chunk) = NullPtr;
TRACK(TrackBak,"MemDefrostChunk\n");
return(STAT);
}
boolean    MemGetChunkSize(numtype       Chunk,
ft F,lt Z,zz *Status,    indextype  *UnitCount,
bytessize    *UnitSize)
{
Mem_ChunkExpanded                = 0;
if (ChunkExists (Chunk,        McStat))
{
*UnitCount = Unit_Count    (Chunk);
*UnitSize  = Unit_Size     (Chunk);
}
TRACK(TrackBak,"MemGetChunkSize\n");
return(STAT);
}
boolean    MemGetChunkStruc (numtype     Chunk,    ft F,lt Z,zz *Status,
chunkstruc *ChunkRef)
{
Mem_ChunkExpanded          = 0;
if (ChunkExists (Chunk,      McStat))
{
ChunkRef->UnitSize      = Unit_Size       (Chunk);
ChunkRef->UnitCount     = Unit_Count      (Chunk);
ChunkRef->StackPtr      = Stack_Ptr       (Chunk);
ChunkRef->StringText    = Text_Chunk      (Chunk);
ChunkRef->MaxUnitLength = MaxUnit_Length  (Chunk);
ChunkRef->ExtendQty     = Extend_Qty      (Chunk);
}
TRACK(TrackBak,"MemGetChunkStruc\n");
return(STAT);
}
boolean    MemDumpChunkStruc (chunkstruc *ChunkRef,    ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"MemDumpChunkStruc\n");
return(STAT);
}
boolean    MemPutChunkAddr (numtype       Chunk,  addrtype  Addr,
ft F,lt Z,zz *Status)
{
if (Chunk > NumChunks) {
*Status = Err_BadChunk;
} else if (!Chunk) {
*Status = Err_BadChunk;
}
Mem_ChunkExpanded                   = 0;
if (Normal(*Status))
Chunk_Addr(Chunk) = Addr;
TRACK(TrackBak,"MemPutChunkAddr\n");
return(STAT);
}
boolean    MemGetChunkAddr (numtype       Chunk,
ft F,lt Z,zz *Status,  addrtype  *Addr)
{
if (Chunk > NumChunks) {
*Status = Err_BadChunk;
} else if (!Chunk) {
*Status = Err_BadChunk;
}
Mem_ChunkExpanded                   = 0;
if (Normal(*Status))
*Addr = Chunk_Addr(Chunk);
TRACK(TrackBak,"MemGetChunkAddr\n");
return(STAT);
}
boolean    MemPutStackPtr (numtype       Chunk,   indextype   StackPtr,
ft F,lt Z,zz *Status)
{
indextype   CurrStackPtr  = 0;
sizetype    TempByte      = 0;
sizetype    StartByte     = 0;
sizetype    EndByte       = 0;
sizetype    ExtendBytes   = 0;
bytetype   *ChunkAddr     = NullPtr;
Mem_ChunkExpanded                = 0;
if (ChunkExists (Chunk, McStat))
{
CurrStackPtr   = Stack_Ptr(Chunk);
if ((Stack_Ptr(Chunk) = StackPtr) > (Unit_Count(Chunk)) )
if (Chunk_IsNumeric(Chunk))
GrowNumericChunk (Chunk, McStat);
else
GrowTextChunk    (Chunk, McStat);
}
if (Normal(*Status))
if (ClearChunk)
{
ChunkAddr  = (bytetype *)Chunk_Addr(Chunk);
StartByte  = (sizetype )(CurrStackPtr * Unit_Size(Chunk));
EndByte    = (sizetype )(StackPtr     * Unit_Size(Chunk)) - 1;
if (StartByte > EndByte)
{
TempByte  = StartByte;
StartByte = EndByte;
EndByte   = TempByte;
}
ExtendBytes= EndByte                  - StartByte         + 1;
ChunkAddr   += StartByte;
memset ((void *)ChunkAddr, (int )NULL, ExtendBytes);
}
TRACK(TrackBak,"MemPutStackPtr\n");
return(STAT);
}
boolean    Mem_AssertStackPtr
(numtype       Chunk,   indextype   StackPtr,
ft F,lt Z,zz *Status,  addrtype   *ChunkAddr)
{
if (MemPutStackPtr   (Chunk,  StackPtr,  McStat))
*ChunkAddr    = Chunk_Addr(Chunk);
TRACK(TrackBak,"Mem_AssertStackPtr\n");
return(STAT);
}
boolean    MemGetStackPtr (numtype       Chunk,
ft F,lt Z,zz *Status,   indextype  *StackPtr)
{
Mem_ChunkExpanded                = 0;
if (ChunkExists (Chunk, McStat))
*StackPtr = Stack_Ptr(Chunk);
if (*Status == Core_GapFound)
*Status = Err_BadDesign;
TRACK(TrackBak,"MemGetStackPtr\n");
return(STAT);
}
boolean    MemPushEntity  (numtype       Chunk,  sizeinbytes ByteCount,
addrtype      Entity,
ft F,lt Z,zz *Status, indextype  *ByteOffset)
{
indextype     StackPtr   = 0;
addrtype      BytePtr    = NullPtr;
Mem_ChunkExpanded                = 0;
if (ChunkExists (Chunk,  McStat))
if (Chunk_IsData(Chunk))
{
*ByteOffset        = (indextype  )Stack_Ptr(Chunk);
StackPtr          = *ByteOffset       + ByteCount;
AlignStruc ((sizetype *)&StackPtr);
Stack_Ptr(Chunk)  = StackPtr;
if (StackPtr     >= Unit_Count(Chunk))
GrowNumericChunk (Chunk,             McStat);
if (Normal(*Status))
{
BytePtr = ((char *)(Chunk_Addr(Chunk))) + *ByteOffset;
MoveBytes (Entity, BytePtr, ByteCount);
}
} else {
*Status = Err_BadUnitType;
DumpChunkChunk (0, Chunk);
}
TRACK(TrackBak,"MemPushEntity\n");
return(STAT);
}
boolean    MemPutEntity   (numtype   Chunk,      indextype     ByteOffset,
bytessize ByteCount,
addrtype  Entity,     ft F,lt Z,zz *Status)
{
indextype     StackPtr   = 0;
addrtype      BytePtr    = NullPtr;
Mem_ChunkExpanded                = 0;
if (ChunkExists (Chunk,  McStat))
if (Chunk_IsData(Chunk))
{
StackPtr        = ByteOffset + ByteCount;
if (StackPtr    >  Stack_Ptr(Chunk))
{
TraceMsg (0, Msg);
DumpChunkChunk (0, Chunk);
*Status    = Err_IndexOutOfRange;
} else {
BytePtr = ((char *)(Chunk_Addr(Chunk))) + ByteOffset;
MoveBytes (Entity, BytePtr, ByteCount);
}
}
TRACK(TrackBak,"MemPutEntity\n");
return(STAT);
}
boolean MemExtractEntity (numtype       Chunk,   indextype     ByteOffset,
sizeinbytes   Count,   ft F,lt Z,zz *Status)
{
indextype     StackPtr   = 0;
bytetype     *BytePtr    = NullPtr;
bytetype     *NewPtr     = NullPtr;
Mem_ChunkExpanded                = 0;
if (ChunkExists (Chunk,  McStat))
if (Chunk_IsData(Chunk))
{
NewPtr  = (bytetype *)Chunk_Addr(Chunk);
BytePtr = (bytetype *)(((char *)(Chunk_Addr(Chunk))) + ByteOffset);
for (StackPtr    = (indextype )Stack_Ptr(Chunk);
StackPtr--  > ByteOffset;)
{
*NewPtr++ = *BytePtr++;
}
Stack_Ptr(Chunk)  -= Count;
}
TRACK(TrackBak,"MemExtractEntity\n");
return(STAT);
}
boolean    MemGetEntity   (numtype       Chunk,     indextype  ByteOffset,
bytessize     ByteCount,
ft F,lt Z,zz *Status,    addrtype  *Entity)
{
char         *BytePtr    = NullPtr;
Mem_ChunkExpanded                = 0;
if (ChunkExists (Chunk,  McStat))
if (Chunk_IsData(Chunk))
{
Core0_AllocString (ByteCount, McStat, (char **)Entity);
BytePtr = ((char *)(Chunk_Addr(Chunk))) + ByteOffset;
if ((ByteOffset +ByteCount) > Unit_Count(Chunk))
{
if (SetGetSwi)
*Status    = Set_EndOfSet;
else {
DumpChunkChunk (0, Chunk);
*Status    = Err_IndexOutOfRange;
}
}
if (Normal(*Status))
MoveBytes (BytePtr, *Entity, ByteCount);
}
TRACK(TrackBak,"MemGetEntity\n");
return(STAT);
}
boolean    MemNewBitChunk (numtype       BitWidth,   idtype      CoreDbId,
ft F,lt Z,zz *Status,     numtype    *BitChunk)
{
bitfieldtype *BitField   = NullPtr;
sizetype      NumBits    = (BitWidth | 7)+1;
sizetype      NumBytes   = NumBits / 8;
if (MemMakeChunk    (sizeof (bitfieldtype),  NumBytes,  NumBytes,
CoreDbId,               McStat,    BitChunk))
if (MemPutStackPtr  (*BitChunk,              NumBytes,  McStat))
if (MemGetChunkAddr (*BitChunk,              McStat, (addrtype *)&BitField))
memset       (BitField,    '\0',      NumBytes);
TRACK(TrackBak,"MemNewBitChunk\n");
return(STAT);
}
boolean    MemPushBit    (numtype       Chunk,      numtype       BitValue,
ft F,lt Z,zz *Status,     indextype    *StackPtr)
{
*Status = Err_NotImplemented;
TRACK(TrackBak,"MemPushBit\n");
return(STAT);
}
boolean    MemPutBit     (numtype       Chunk,      indextype     BitNum,
numtype       BitValue,   ft F,lt Z,zz *Status)
{
bitfieldtype    *BitField  = NullPtr;
indextype        ByteNum   = BitNum >> 3;
boolean          PushFlag  = False;
numtype          Value     = 0;
Mem_ChunkExpanded                = 0;
if (ChunkExists       (Chunk,      McStat))
{
if (ByteNum       >= Unit_Count (Chunk))
{
Stack_Ptr(Chunk) = ByteNum;
GrowNumericChunk (Chunk,       McStat);
Stack_Ptr(Chunk) = Unit_Count (Chunk);
}
if (ChkPutChunk (Chunk, ByteNum, sizeof(bitfieldtype), McStat, &PushFlag))
{
BitField    = (bitfieldtype *)Chunk_Addr(Chunk);
if (BitValue)
BitField[ ByteNum ] |= BitValue << (BitNum & 7);
else
BitField[ ByteNum ] &= ~(1 << (BitNum & 7));
}
if (MemBug)
{
Value       =  (BitField[ ByteNum ] & 1 << (BitNum & 7)) ? 1: 0;
}
}
TRACK(TrackBak,"MemPutBit\n");
return(STAT);
}
boolean    MemPopBit     (numtype       Chunk,
ft F,lt Z,zz *Status,     numtype     *BitValue,
indextype    *StackPtr )
{
*Status = Err_NotImplemented;
TRACK(TrackBak,"MemPopBit\n");
return(STAT);
}
boolean    MemGetBit     (numtype       Chunk,      indextype    BitNum,
ft F,lt Z,zz *Status,     numtype     *BitValue)
{
indextype        ByteNum   = BitNum >> 3;
bitfieldtype    *BitField  = NullPtr;
indextype        ByteCount = 0;
if (ChkGetChunk     (Chunk, ByteNum, sizeof(bitfieldtype), McStat))
if (MemGetStackPtr  (Chunk, McStat,  &ByteCount))
if (ByteNum >= ByteCount)
*Status = Mem_BitIndexGtrByteCount;
if (Normal(*Status))
{
BitField =  (bitfieldtype *)Chunk_Addr(Chunk);
*BitValue =  (BitField[ ByteNum ] & 1 << (BitNum & 7)) ? 1: 0;
}
TRACK(TrackBak,"MemGetBit\n");
return(STAT);
}
boolean    MemPushShort (numtype       Chunk,  shorttype    ShortValue,
ft F,lt Z,zz *Status, indextype  *StackPtr)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
if (ChkPushChunk (Chunk, sizeof(shorttype), McStat))
{
*StackPtr = Stack_Ptr(Chunk)++;
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(*StackPtr * sizeof(shorttype));
Ptr      = (addrtype )(Base + Inset);
*( ((short *)(Chunk_Addr(Chunk))) + *StackPtr )  = ShortValue;
if (*(short *)Ptr != ShortValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemPushShort\n");
return(STAT);
}
boolean    MemPutShort  (numtype   Chunk,     indextype     Index,
shorttype  ShortValue, ft F,lt Z,zz *Status)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
boolean PushFlag = False;
if (ChkPutChunk (Chunk, Index, sizeof(shorttype), McStat, &PushFlag))
if (PushFlag)
{indextype  StackPtr;
MemPushShort (Chunk, ShortValue, McStat, &StackPtr);
} else {
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(Index * sizeof(shorttype));
Ptr      = (addrtype )(Base + Inset);
*( ((short *)(Chunk_Addr(Chunk))) + Index ) = ShortValue;
if (*(short *)Ptr != ShortValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemPutShort\n");
return(STAT);
}
boolean    MemPopShort  (numtype   Chunk,     ft F,lt Z,zz *Status,
shorttype *ShortValue, indextype    *StackPtr)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
if (ChkPopChunk (Chunk, sizeof(shorttype), McStat)) {
*StackPtr = --Stack_Ptr(Chunk);
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(*StackPtr * sizeof(shorttype));
Ptr      = (addrtype )(Base + Inset);
*ShortValue = *( ((short *)(Chunk_Addr(Chunk))) + *StackPtr );
if (*(short *)Ptr != *ShortValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemPopShort\n");
return(STAT);
}
boolean    MemGetShort  (numtype       Chunk,  indextype   Index,
ft F,lt Z,zz *Status, shorttype   *ShortValue)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
if (ChkGetChunk (Chunk, Index, sizeof(shorttype), McStat))
if (*Status != Set_EndOfSet) {
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(Index * sizeof(shorttype));
Ptr      = (addrtype )(Base + Inset);
*ShortValue = *(((short *)(Chunk_Addr(Chunk))) + Index);
if (*(short *)Ptr != *ShortValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemGetShort\n");
return(STAT);
}
boolean    MemPushWord (numtype       Chunk,  wordtype    WordValue,
ft F,lt Z,zz *Status, indextype  *StackPtr)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
if (ChkPushChunk (Chunk, sizeof(wordtype), McStat)) {
*StackPtr = Stack_Ptr(Chunk)++;
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(*StackPtr * sizeof(wordtype));
Ptr      = (addrtype )(Base + Inset);
*( ((word *)(Chunk_Addr(Chunk))) + *StackPtr )  = WordValue;
if (*(word *)Ptr != WordValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemPushWord\n");
return(STAT);
}
boolean    MemPutWord  (numtype   Chunk,     indextype     Index,
wordtype  WordValue, ft F,lt Z,zz *Status)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
boolean PushFlag = False;
if (ChkPutChunk (Chunk, Index, sizeof(wordtype), McStat, &PushFlag))
if (PushFlag)
{indextype  StackPtr;
MemPushWord (Chunk, WordValue, McStat, &StackPtr);
} else {
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(Index * sizeof(wordtype));
Ptr      = (addrtype )(Base + Inset);
*( ((word *)(Chunk_Addr(Chunk))) + Index ) = WordValue;
if (*(word *)Ptr != WordValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemPutWord\n");
return(STAT);
}
boolean    MemPopWord  (numtype   Chunk,     ft F,lt Z,zz *Status,
wordtype *WordValue, indextype    *StackPtr)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
if (ChkPopChunk (Chunk, sizeof(wordtype), McStat)) {
*StackPtr = --Stack_Ptr(Chunk);
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(*StackPtr * sizeof(wordtype));
Ptr      = (addrtype )(Base + Inset);
*WordValue = *( ((word *)(Chunk_Addr(Chunk))) + *StackPtr );
if (*(word *)Ptr != *WordValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemPopWord\n");
return(STAT);
}
boolean    MemGetWord  (numtype       Chunk,  indextype   Index,
ft F,lt Z,zz *Status, wordtype   *WordValue)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
if (ChkGetChunk (Chunk, Index, sizeof(wordtype), McStat))
if (*Status != Set_EndOfSet)
{
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(Index * sizeof(wordtype));
Ptr      = (addrtype )(Base + Inset);
*WordValue = *(((word *)(Chunk_Addr(Chunk))) + Index);
if (*(word *)Ptr != *WordValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemGetWord\n");
return(STAT);
}
boolean    MemPushLong (numtype       Chunk,  lt64        LongValue,
ft F,lt Z,zz *Status, indextype  *StackPtr)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
if (ChkPushChunk (Chunk, sizeof(lt64    ), McStat)) {
*StackPtr = Stack_Ptr(Chunk)++;
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(*StackPtr * sizeof(lt64    ));
Ptr      = (addrtype )(Base + Inset);
*( ((lt64     *)(Chunk_Addr(Chunk))) + *StackPtr )  = LongValue;
if (*(lt64     *)Ptr != LongValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemPushLong\n");
return(STAT);
}
boolean    MemPutLong  (numtype   Chunk,     indextype     Index,
lt64      LongValue, ft F,lt Z,zz *Status)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
boolean PushFlag = False;
if (ChkPutChunk (Chunk, Index, sizeof(lt64    ), McStat, &PushFlag))
if (PushFlag)
{indextype  StackPtr;
MemPushLong (Chunk, LongValue, McStat, &StackPtr);
} else {
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(Index * sizeof(lt64    ));
Ptr      = (addrtype )(Base + Inset);
*( ((lt64     *)(Chunk_Addr(Chunk))) + Index ) = LongValue;
if (*(lt64     *)Ptr != LongValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemPutLong\n");
return(STAT);
}
boolean    MemPopLong  (numtype   Chunk,     ft F,lt Z,zz *Status,
lt64     *LongValue, indextype    *StackPtr)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
if (ChkPopChunk (Chunk, sizeof(lt64    ), McStat))
{
*StackPtr = --Stack_Ptr(Chunk);
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(*StackPtr * sizeof(lt64    ));
Ptr      = (addrtype )(Base + Inset);
*LongValue = *( ((lt64     *)(Chunk_Addr(Chunk))) + *StackPtr );
if (*(lt64     *)Ptr != *LongValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemPopLong\n");
return(STAT);
}
boolean    MemGetLong  (numtype       Chunk,  indextype   Index,
ft F,lt Z,zz *Status, lt64       *LongValue)
{
char     *Base  = 0;
indextype Inset = 0;
addrtype  Ptr   = 0;
if (ChkGetChunk (Chunk, Index, sizeof(lt64    ), McStat))
if (*Status != Set_EndOfSet)
{
Base     = (char    *)Chunk_Addr(Chunk);
Inset    = (indextype )(Index * sizeof(lt64    ));
Ptr      = (addrtype )(Base + Inset);
*LongValue = *(((lt64     *)(Chunk_Addr(Chunk))) + Index);
if (*(lt64     *)Ptr != *LongValue)
*Status = Err_BadStackMath;
}
TRACK(TrackBak,"MemGetLong\n");
return(STAT);
}
boolean    MemPushAddr (numtype       Chunk,  addrtype    AddrValue,
ft F,lt Z,zz *Status, indextype  *StackPtr)
{
addrtype *BytePtr = NullPtr;
if (ChkPushChunk (Chunk, sizeof(addrtype), McStat)) {
BytePtr  = (addrtype *)Chunk_Addr(Chunk);
*StackPtr = Stack_Ptr(Chunk)++;
*(BytePtr + *StackPtr )  = AddrValue;
}
TRACK(TrackBak,"MemPushAddr\n");
return(STAT);
}
boolean    MemPutAddr  (numtype  Chunk,     indextype      Index,
addrtype  Addr,      ft F,lt Z,zz *Status)
{
boolean PushFlag = False;
addrtype     ChunkSlotAddr = NullPtr;
if (ChkPutChunk (Chunk, Index, sizeof(addrtype), McStat, &PushFlag))
if (PushFlag)
{indextype  StackPtr;
MemPushAddr (Chunk, Addr, McStat, &StackPtr);
} else
*( ((addrtype *)(Chunk_Addr(Chunk))) + Index ) = Addr;
ChunkSlotAddr = (addrtype )((char *)Chunk_Addr(Chunk) + Index);
TRACK(TrackBak,"MemPutAddr\n");
return(STAT);
}
boolean    MemPopAddr  (numtype   Chunk,     ft F,lt Z,zz *Status,
addrtype *Addr,      indextype    *StackPtr)
{
if (ChkPopChunk (Chunk, sizeof(addrtype), McStat)) {
*StackPtr = --Stack_Ptr(Chunk);
*Addr = *( ((addrtype *)(Chunk_Addr(Chunk))) + *StackPtr );
}
TRACK(TrackBak,"MemPopAddr\n");
return(STAT);
}
boolean    MemGetAddr  (numtype       Chunk,  indextype   Index,
ft F,lt Z,zz *Status, addrtype   *Addr)
{
addrtype     ChunkSlotAddr = NullPtr;
if (ChkGetChunk (Chunk, Index, sizeof(addrtype), McStat))
if (*Status != Set_EndOfSet)
{
*Addr = *(((addrtype *)(Chunk_Addr(Chunk))) + Index);
ChunkSlotAddr = (addrtype )((char *)Chunk_Addr(Chunk) + Index);
}
TRACK(TrackBak,"MemGetAddr\n");
return(STAT);
}
boolean    MemPushToken (numtype       Chunk,  tokentype  *Token,
ft F,lt Z,zz *Status, indextype  *StackPtr)
{
if (ChkPushChunk (Chunk, sizeof(tokentype), McStat)) {
*StackPtr = Stack_Ptr(Chunk)++;
*( ((tokentype *)(Chunk_Addr(Chunk))) + *StackPtr )  = *Token;
}
TRACK(TrackBak,"MemPushToken\n");
return(STAT);
}
boolean    MemPutToken  (numtype    Chunk,     indextype     Index,
tokentype *Token,     ft F,lt Z,zz *Status)
{
boolean PushFlag = False;
if (ChkPutChunk (Chunk, Index, sizeof(tokentype), McStat, &PushFlag))
if (PushFlag)
{indextype  StackPtr;
MemPushToken (Chunk, Token, McStat, &StackPtr);
} else
*( ((tokentype *)(Chunk_Addr(Chunk))) + Index ) = *Token;
TRACK(TrackBak,"MemPutToken\n");
return(STAT);
}
boolean    MemPopToken  (numtype   Chunk,      ft F,lt Z,zz *Status,
tokentype *Token,      indextype    *StackPtr)
{
if (ChkPopChunk (Chunk, sizeof(tokentype), McStat)) {
*StackPtr = --Stack_Ptr(Chunk);
*Token = *( ((tokentype *)(Chunk_Addr(Chunk))) + *StackPtr );
}
TRACK(TrackBak,"MemPopToken\n");
return(STAT);
}
boolean    MemGetToken  (numtype       Chunk,  indextype    Index,
ft F,lt Z,zz *Status, tokentype   *Token)
{
if (ChkGetChunk (Chunk, Index, sizeof(tokentype), McStat))
if (*Status != Set_EndOfSet)
*Token = *(((tokentype *)(Chunk_Addr(Chunk))) + Index);
TRACK(TrackBak,"MemGetToken\n");
return(STAT);
}
boolean    MemPushSomeBytes (numtype       Chunk,      sizeinbytes ByteCount,
addrtype      SomeBytes,
ft F,lt Z,zz *Status,     indextype  *StackPtr)
{
addrtype  BytePtr = NullPtr;
indextype Offset  = 0;
if (ChkPushChunk (Chunk, ByteCount, McStat))
{
*StackPtr = Stack_Ptr(Chunk)++;
Offset   = *StackPtr * (indextype  )ByteCount;
BytePtr  = ((char *)(Chunk_Addr(Chunk))) + Offset;
MoveBytes (SomeBytes, BytePtr, ByteCount);
}
TRACK(TrackBak,"MemPushSomeBytes\n");
return(STAT);
}
boolean    MemPutSomeBytes  (numtype       Chunk,     indextype   Index,
sizeinbytes   ByteCount, addrtype    SomeBytes,
ft F,lt Z,zz *Status)
{
boolean    PushFlag  = False;
addrtype   BytePtr   = NullPtr;
indextype  StackPtr  = 0;
if (ChkPutChunk     (Chunk, Index,     ByteCount, McStat, &PushFlag))
if (PushFlag)
MemPushSomeBytes (Chunk, ByteCount, SomeBytes, McStat, &StackPtr);
else {
BytePtr  = ((char *)(Chunk_Addr(Chunk))) + (ByteCount * Index);
MoveBytes        (SomeBytes,        BytePtr,   ByteCount);
*Status   = Env_Normal;
}
TRACK(TrackBak,"MemPutSomeBytes\n");
return(STAT);
}
boolean    MemPopSomeBytes  (numtype       Chunk,      bytessize   ByteCount,
ft F,lt Z,zz *Status,
addrtype      SomeBytes,  indextype  *StackPtr)
{
addrtype  BytePtr    = NullPtr;
indextype Offset     = 0;
if (ChkPopChunk (Chunk, ByteCount, McStat))
{
*StackPtr = --Stack_Ptr(Chunk);
Offset   = *StackPtr * (indextype  )ByteCount;
BytePtr  = ((char *)(Chunk_Addr(Chunk))) + Offset;
MoveBytes (BytePtr, SomeBytes, ByteCount);
}
TRACK(TrackBak,"MemPopSomeBytes\n");
return(STAT);
}
boolean    MemGetSomeBytes  (numtype       Chunk,       indextype   Index,
sizeinbytes   ByteCount,
ft F,lt Z,zz *Status,      addrtype    SomeBytes)
{
addrtype BytePtr = NullPtr;
if (ChkGetChunk (Chunk, Index, ByteCount, McStat))
if (*Status != Set_EndOfSet)
{
BytePtr  = ((char *)(Chunk_Addr(Chunk))) + (ByteCount * Index);
MoveBytes (BytePtr, SomeBytes, ByteCount);
*Status  = Env_Normal;
}
TRACK(TrackBak,"MemGetSomeBytes\n");
return(STAT);
}
boolean    MemPushFuncPtr (numtype       Chunk,  funcptrtype FuncPtr,
ft F,lt Z,zz *Status, indextype  *StackPtr)
{
addrtype  BytePtr   = NullPtr;
indextype Offset    = 0;
indextype ByteCount = sizeof (funcptrtype);
if (ChkPushChunk (Chunk, ByteCount, McStat))
{
*StackPtr = Stack_Ptr(Chunk)++;
Offset   = *StackPtr *  ByteCount;
BytePtr  = ((char *)(Chunk_Addr(Chunk))) + Offset;
MoveBytes ((addrtype )&FuncPtr, BytePtr, ByteCount);
}
TRACK(TrackBak,"MemPushFuncPtr\n");
return(STAT);
}
boolean    MemPutFuncPtr  (numtype     Chunk,     indextype      Index,
funcptrtype FuncPtr,   ft F,lt Z,zz  *Status)
{
boolean    PushFlag  = False;
addrtype   BytePtr   = NullPtr;
indextype  StackPtr  = 0;
indextype  ByteCount = sizeof (funcptrtype);
if (ChkPutChunk     (Chunk, Index,    ByteCount, McStat, &PushFlag))
if (PushFlag)
MemPushFuncPtr   (Chunk, FuncPtr,             McStat, &StackPtr);
else {
BytePtr  = ((char *)(Chunk_Addr(Chunk))) + (ByteCount * Index);
MoveBytes        ((addrtype )&FuncPtr,        BytePtr, ByteCount);
*Status   = Env_Normal;
}
TRACK(TrackBak,"MemPutFuncPtr\n");
return(STAT);
}
boolean    MemPopFuncPtr  (numtype      Chunk,     ft F,lt Z,zz *Status,
funcptrtype *FuncPtr,   indextype    *StackPtr)
{
indextype  ByteCount = sizeof (funcptrtype);
addrtype   BytePtr   = NullPtr;
if (ChkPopChunk (Chunk, ByteCount, McStat))
{
*StackPtr = --Stack_Ptr(Chunk);
BytePtr  = ((char *)(Chunk_Addr(Chunk))) + *StackPtr;
MoveBytes (BytePtr, (addrtype )&FuncPtr,    ByteCount);
}
TRACK(TrackBak,"MemPopFuncPtr\n");
return(STAT);
}
boolean    MemGetFuncPtr  (numtype       Chunk,  indextype    Index,
ft F,lt Z,zz *Status, funcptrtype *FuncPtr)
{
indextype  ByteCount = sizeof (funcptrtype);
addrtype   BytePtr   = NullPtr;
if (ChkGetChunk (Chunk, Index, ByteCount, McStat))
if (*Status != Set_EndOfSet)
{
BytePtr  = ((char *)(Chunk_Addr(Chunk))) + (ByteCount * Index);
MoveBytes (BytePtr, (addrtype )FuncPtr,    ByteCount);
*Status  = Env_Normal;
}
TRACK(TrackBak,"MemGetFuncPtr\n");
return(STAT);
}
boolean    MemNewString     (numtype       Chunk,     char         *String,
ft F,lt Z,zz *Status,    indextype    *StackPtr)
{
sizeinbytes   ByteCount  = 0;
struchdr     *StrucHdr   = NullPtr;
stringstruc  *CurrStruc  = NullPtr;
indextype     NextGap    = 0;
boolean       GapFound   = False;
StrucHdr    = (struchdr *)Chunk_Addr(Chunk);
ByteCount   = strlen(String) + 1;
if ((NextGap    =  StrucHdr->FirstFreeGap) > 0)
{
GapFound     = True;
*StackPtr     = NextGap;
CurrStruc    = (stringstruc *)(  (char *)Chunk_Addr(Chunk)
+ (sizeof (stringstruc) * NextGap) );
StrucHdr->FirstFreeGap = CurrStruc->NextFreeGap;
}
if (!GapFound)
MemPushString (Chunk,  String,   McStat,   StackPtr);
else
MemPutString  (Chunk, *StackPtr, String,   McStat);
TRACK(TrackBak,"MemNewString   \n");
return(STAT);
}
boolean    MemDeleteString  (numtype       Chunk,     indextype   Index,
ft F,lt Z,zz *Status)
{
indextype     StackPtr   = 0;
sizeinbytes   ByteCount  = 0;
struchdr     *StrucHdr   = NullPtr;
stringstruc  *StrStruc   = NullPtr;
stringstruc  *StrStruc0  = NullPtr;
sizetype      TextOffset = 0;
StrucHdr    = (struchdr *)Chunk_Addr(Chunk);
StrStruc    = (stringstruc *)( (char *)Chunk_Addr(Chunk)
+ (sizeof (stringstruc) * Index) );
ByteCount   = StrStruc->TextSize;
StrStruc0   = StrStruc;
TextOffset  = StrStruc->TextOffset;
if (MemExtractEntity  (StrucHdr->TextChunk, StrStruc->TextOffset,
StrStruc->TextSize,            McStat))
if (Stack_Ptr(Chunk))
{
for (StackPtr    = (indextype )Stack_Ptr(Chunk), ++StrStruc;
StackPtr--  > 0;       ++StrStruc)
{
if (StrStruc->TextOffset  > TextOffset)
StrStruc->TextOffset -= TextOffset;
}
}
StrStruc0->TextOffset   = 0;
StrStruc0->TextSize     = 0;
StrStruc0->NextFreeGap  = StrucHdr->FirstFreeGap;
StrucHdr->FirstFreeGap  = StackPtr;
TRACK(TrackBak,"MemDeleteString\n");
return(STAT);
}
boolean    MemPushString    (numtype       Chunk,     char         *String,
ft F,lt Z,zz *Status,    indextype    *StackPtr)
{
sizeinbytes   ByteCount  = 0;
sizeinbytes   StrSize    = 0;
stringstruc  *StrStruc   = NullPtr;
numtype       TextChunk  = 0;
char         *TextPtr    = NullPtr;
struchdr     *StrucHdr   = NullPtr;
if (ChkPushChunk (Chunk, sizeof (stringstruc), McStat))
{
StrucHdr  = (struchdr *)Chunk_Addr(Chunk);
*StackPtr  = (indextype )Stack_Ptr(Chunk)++;
StrStruc  = (stringstruc *)( ((char *)(Chunk_Addr(Chunk)))
+ (sizeof (stringstruc) * *StackPtr) );
StrSize   = strlen (String) + 1;
if (StrSize > MaxUnit_Length(StrucHdr->TextChunk))
{
StrSize = MaxUnit_Length(StrucHdr->TextChunk);
String[StrSize] = '\0';
}
ByteCount = StrSize;
StrStruc->TextSize = ByteCount;
TextChunk = StrucHdr->TextChunk;
if (ByteCount  > 1)
{
	 AlignStruc((sizetype *) &ByteCount);
StrStruc->TextSize = ByteCount;
if (MemPushEntity (TextChunk, ByteCount, String,
McStat,              &StrStruc->TextOffset))
{
TextPtr = ((char *)(Chunk_Addr(TextChunk))) + StrStruc->TextOffset;
MoveBytes (String, TextPtr, StrSize);
}
} else
StrStruc->TextOffset = 0;
}
TRACK(TrackBak,"MemPushString\n");
return(STAT);
}
boolean    MemPutString     (numtype       Chunk,  indextype     Index,
char         *String, ft F,lt Z,zz *Status)
{
boolean       PushFlag   = False;
indextype     StackPtr   = 0;
sizeinbytes   ByteCount  = 0;
stringstruc  *StrStruc   = NullPtr;
numtype       TextChunk  = 0;
struchdr     *StrucHdr   = NullPtr;
sizetype      StrSize    = 0;
sizetype      TextSize   = 0;
indextype     TextOffset = 0;
if (ChkPutChunk   (Chunk, Index,  sizeof (stringstruc), McStat, &PushFlag))
if (PushFlag)
{
MemPushString  (Chunk, String,   McStat,  &StackPtr);
} else {
StrucHdr  = (struchdr *)Chunk_Addr(Chunk);
StrStruc  = (stringstruc *)( ((char *)(Chunk_Addr(Chunk)))
+ (sizeof (stringstruc) * Index) );
TextChunk = StrucHdr->TextChunk;
StrSize = strlen (String) + 1;
if ((ByteCount = StrSize) > 1 )
	 AlignStruc((sizetype *) &ByteCount) ;
if ( ByteCount > StrStruc->TextSize )
{
TextSize         = StrStruc->TextSize;
TextOffset       = StrStruc->TextOffset;
if (MemExtractEntity  (TextChunk, TextOffset,  TextSize, McStat))
if (MemPushEntity     (TextChunk, ByteCount, String,
McStat,                &StrStruc->TextOffset))
for (StackPtr    = (indextype )Stack_Ptr(Chunk), ++StrStruc;
StackPtr--  > 0;       ++StrStruc)
{
if (StrStruc->TextOffset  > TextOffset)
StrStruc->TextOffset -= TextOffset;
}
}
}
TRACK(TrackBak,"MemPutString\n");
return(STAT);
}
boolean    MemPopString     (numtype       Chunk,     ft F,lt Z,zz *Status,
char        **String,    indextype    *StackPtr)
{
sizeinbytes   ByteCount  = 0;
stringstruc  *StrStruc   = NullPtr;
numtype       TextChunk  = 0;
char         *TextPtr    = NullPtr;
struchdr     *StrucHdr   = NullPtr;
if (ChkPopChunk (Chunk, sizeof(stringstruc), McStat))
{
StrucHdr  = (struchdr *)Chunk_Addr(Chunk);
*StackPtr = --Stack_Ptr(Chunk);
StrStruc  = (stringstruc *)( ((char *)(Chunk_Addr(Chunk)))
+ (sizeof (stringstruc) * *StackPtr) );
ByteCount = StrStruc->TextSize;
Core0_AllocString (ByteCount, McStat, String);
TextChunk = StrucHdr->TextChunk;
TextPtr   = ((char *)(Chunk_Addr(TextChunk))) + StrStruc->TextOffset;
if (Normal(*Status))
MoveBytes   (TextPtr, *String, ByteCount);
}
TRACK(TrackBak,"MemPopString\n");
return(STAT);
}
boolean    MemGetString     (numtype       Chunk,       indextype   Index,
ft F,lt Z,zz *Status,      char      **String)
{
sizeinbytes   ByteCount  = 0;
stringstruc  *StrStruc   = NullPtr;
numtype       TextChunk  = 0;
char         *TextPtr    = NullPtr;
struchdr     *StrucHdr   = NullPtr;
if (Chunk)
if (ChkGetChunk (Chunk, Index, sizeof (stringstruc), McStat))
if (*Status != Set_EndOfSet)
if (Index    > 0)
{
*Status    = Env_Normal;
StrucHdr  = (struchdr *)Chunk_Addr(Chunk);
StrStruc  = (stringstruc *)( ((char *)(Chunk_Addr(Chunk)))
+ (sizeof (stringstruc) * Index) );
ByteCount = StrStruc->TextSize;
if (!ByteCount)
ByteCount = 1;
Core0_AllocString (ByteCount, McStat, String);
TextChunk = StrucHdr->TextChunk;
TextPtr = ((char *)(Chunk_Addr(TextChunk))) + StrStruc->TextOffset;
if (Normal(*Status))
if ( ByteCount > 1 )
MoveBytes (TextPtr, *String, ByteCount);
else
strcpy (*String, "\0");
} else {
if (Core0_AllocString (1, McStat, String))
strcpy (*String, "\0");
}
TRACK(TrackBak,"MemGetString\n");
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\oa0.c*/

#define OA0
#ifdef NULL_TRACE_STRS
#define TraceStr7(StrNum)  TraceStr7[0]
static const char   *TraceStr7[1] = {"   ...MEM00... message\n" };
#else
#define TraceStr7(StrNum)  TraceStr7[StrNum]
static const char *TraceStr7[21] =
{
"   OaInstallObjHdr(%3u) in DbId = %3u\n",
"   InstallObjHdr Db[%2u] Obj[%3u] Local?[%3u] ObjHdr @%x McStat=%d\n",
"  OaInstallObjHdr[%2u] as ObjNum=%2u In Db=%2u @%x\n",
"   GET ObjClass from [%3u:%3u] ::=  %u \n",
"   OaFreezeObjHdr(%3u) in DbId = %3u\n",
"   ObjHdr[%3u:%4u] Frozen %2u times.\n",
"   OaThawObjHdr(%3u) in DbId = %3u\n",
"   OaCreateObject(%3u) in DbId = %3u\n",
"   CreateObject Db[%2u] Obj[%3u] Local?[%3u] ObjHdr @ %x McStat= %d\n",
"  OaCreateObject[%2u] Handle =%4u for Db=%2u @%x\n",
"  CREATE Object (* %3u) ::  NewObjHdr[%u] [%2u:%4u]\n",
"  OaCreateObject[type= %2u] :: [%2u:%4u]\n",
"    OA New  Object(%4u) [%2u:%4u]  of Class Obj[%2u]\n",
"  OaGetObject[%2u :%4u], McStat= %d\n",
"  Oa GET Object[%2u :%4u] @%x, McStat= %d\n",
"  OA Revoke C++ Object [%2u:%4u]\n",
"   Oa Assign C++ Object @%x TO Image[%2u:%4u] \n",
"   OaUpdateObject:: [%3u:%4u] ObjNum=%3u Index=%4u Region[%2u:%2u]\n",
"   OaCHkObjHdr(%3u) in DbId = %3u\n",
"  from DB_ObjHdr Time: %s   To RENV_ObjDesc Time %s\n",
"   OaChange  [%2u:%4u] To Obj[%3u]\n"
};
#endif




#define MemPushObjHdr        Mem_PushAddr
#define MemGetObjHdr         Mem_GetAddr
#define MemGetLocalObjNum    Mem_GetWord
#define MemPutLocalObjNum    Mem_PutWord
#define MemGetObjNum         Mem_GetWord
#define MemPushObjNum        Mem_PushWord
#define MemGetVbn            Mem_GetWord
#ifdef __ZTC__
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#else
#ifdef MCSTAT
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(Anchor->DbId <= MaxCoreDbId \
&& ((*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr)) ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#else
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#endif
#endif
boolean    OaCreateDb     (tokentype    *SchemaTkn, numtype       PrimalObj,
char         *DbName,    char         *NewFileName,
dbaccesstype  DbAccess,
ft F,lt Z,zz *Status,    tokentype    *DbPrimal)
{
indextype   AllocObjs       = CoreDb0->LastEnvObjCount  + 1;
indextype   AllocAttrs      = CoreDb0->LastEnvAttrCount + 1;
int         TmpDeBug        = DeBug;
if (SchemaTkn->DbId == PrimalId)
{
AllocObjs  = Env_Objs;
AllocAttrs = Env_Attrs;
} else {
AllocObjs  = CoreDb0->LastEnvObjCount  + 1;
AllocAttrs = CoreDb0->LastEnvAttrCount + 1;
}
DbmCreateDb   (SchemaTkn,         PrimalObj,
DbName,            NewFileName,       DbAccess,
AllocObjs,         AllocAttrs,
McStat,            DbPrimal);
DeBug = TmpDeBug;
TRACK(TrackBak,"OaCreateDb\n");
return (STAT);
}
boolean    OaInstallObjHdr (tokentype    *Anchor,   numtype     EnvObj,
ft F,lt Z,zz *Status,   objheader **ObjHdr)
{
localnumtype LocalObj        = 0;
dbheader    *CoreDb          = NullPtr;
vbntype      Vbn             = 0;
if (TmGetCoreDb       (Anchor,                 McStat,  &CoreDb))
if (MemGetLocalObjNum (CoreDb->LocalObjNumMap, EnvObj,   McStat, &LocalObj))
if (LocalObj)
{
if (MemGetObjHdr   (CoreDb->ObjHdrDir,      LocalObj,
McStat,                 (addrtype *)ObjHdr))
if (*ObjHdr == NullPtr)
if (CoreDb->ObjVbnDirVbn)
{
if (MemGetVbn   (CoreDb->ObjVbnDir,      LocalObj,
McStat,                &Vbn))
if (Vbn)
{
if (DbmLoadObjHdr (Anchor, LocalObj,      McStat,     ObjHdr))
OmChkImage    (Anchor,     (*ObjHdr)->ObjNum,     McStat);
} else
*Status = Oa_NewObjHdr;
} else
*Status = Oa_NewObjHdr;
}
if ( (! LocalObj && EnvObj)
||   *Status == Oa_NewObjHdr)
{
*Status = Env_Normal;
if (! Build_Env)
{
if (EnvInstallObjHdr (Anchor, EnvObj, McStat, &LocalObj))
MemGetObjHdr     (CoreDb->ObjHdrDir,      LocalObj,
McStat,                 (addrtype *)ObjHdr);
} else
*Status = Om_ObjNotInSchema;
}
TRACK(TrackBak,"OaInstallObjHdr\n");
return (STAT);
}
boolean    OaGetObjClass  (tokentype    *Token,
ft F,lt Z,zz *Status,     numtype    *ObjClass)
{
dbheader     *CoreDb    = NullPtr;
if (TmGetCoreDb      (Token,  McStat,         &CoreDb))
if (HmGetObjNum      (CoreDb, Token->Handle,   McStat,     ObjClass))
if (!Normal(*Status) || DeBug || OaBug)
{
sprintf (Msg, TraceStr7(3),
Token->DbId, Token->Handle,  *ObjClass);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"OaGetObjClass\n");
return (STAT);
}
boolean    OaConfigClass   (tokentype    *PrimalTkn, numtype       ClassId,
numtype       RgnEntrys,
numtype       AllocRgns, numtype       ExtendRgns,
numtype       AllocXs,   numtype       ExtendXs,
accesstype    AccessType,boolean       DiskCache,
numtype       CacheLimit,numtype       CacheLoad,
ft F,lt Z,zz *Status)
{
objheader    *ObjHdr    = NullPtr;
OmConfigClass        (RgnEntrys,    AllocRgns,  ExtendRgns,
AllocXs,      ExtendXs,   AccessType,
DiskCache,    CacheLimit, CacheLoad);
OaInstallObjHdr      (PrimalTkn,    ClassId,    McStat,     &ObjHdr);
OmSetConfig          (False);
TRACK(TrackBak,"OaConfigClass\n");
return (STAT);
}
boolean    OaFreezeObjClass(tokentype    *Anchor,   numtype     EnvObj,
ft F,lt Z,zz *Status)
{
objheader   *ObjHdr          = NullPtr;
dbheader    *CoreDb          = NullPtr;
localnumtype LocalObj        = 0;
if (OaInstallObjHdr   (Anchor,   EnvObj,  McStat,  &ObjHdr))
ObjHdr->FreezeClass++;
TRACK(TrackBak,"OaFreezeObjClass\n");
return (STAT);
}
boolean    OaThawObjClass  (tokentype    *Anchor,   numtype     EnvObj,
ft F,lt Z,zz *Status)
{
objheader   *ObjHdr          = NullPtr;
localnumtype LocalObj        = 0;
dbheader    *CoreDb          = NullPtr;
if (TmGetCoreDb       (Anchor,                 McStat,           &CoreDb))
if (MemGetLocalObjNum (CoreDb->LocalObjNumMap, EnvObj,   McStat, &LocalObj))
if (LocalObj)
if (MemGetObjHdr      (CoreDb->ObjHdrDir,                         LocalObj,
McStat,                       (addrtype *)&ObjHdr))
if (ObjHdr == NullPtr)
*Status    = Oa_ObjClassNotLoaded;
else if (ObjHdr->FreezeClass)
ObjHdr->FreezeClass--;
TRACK(TrackBak,"OaThawObjClass\n");
return (STAT);
}
boolean    OaCreateObject (tokentype    *Anchor, numtype     EnvObj,
ft F,lt Z,zz *Status, tokentype  *Token )
{
handletype  Handle          = 0;
indextype   Index           = 0;
localnumtype LocalObj        = 0;
addrtype    Object          = NullPtr;
dbheader   *CoreDb          = NullPtr;
objheader  *ObjHdr          = NullPtr;
count       AllocQty        = 0;
indextype   StackPtr        = 0;
vbntype     Vbn             = 0;
boolean     TempOaBug       = OaBug;
if (TmGetCoreDb       (Anchor,                 McStat,  &CoreDb))
if (MemGetLocalObjNum (CoreDb->LocalObjNumMap, EnvObj,   McStat, &LocalObj))
if (LocalObj)
{
if (MemGetObjHdr   (CoreDb->ObjHdrDir,      LocalObj,
McStat,                 (addrtype *)&ObjHdr))
if (ObjHdr == NullPtr)
if (CoreDb->ObjVbnDirVbn)
{
if (MemGetVbn   (CoreDb->ObjVbnDir,      LocalObj,
McStat,                &Vbn))
if (Vbn)
{
if (DbmLoadObjHdr (Anchor, LocalObj,  McStat,     &ObjHdr))
OmChkImage    (Anchor,    ObjHdr->ObjNum,      McStat);
} else
*Status = Oa_NewObjHdr;
} else
*Status = Oa_NewObjHdr;
}
if ( (! LocalObj && EnvObj)
||   *Status == Oa_NewObjHdr)
{
*Status = Env_Normal;
if (ObjAllocQty[EnvObj] > 0)
AllocQty = ObjAllocQty[EnvObj];
else
AllocQty = Alloc_ObjectObjs;
if (!LocalObj)
if (Build_Env
||  (Admin_Run && Anchor->DbId == RenvId))
{
if (MemPushObjNum (CoreDb->ObjNumMap,  EnvObj,  McStat, &LocalObj))
if (MemPushObjHdr (CoreDb->ObjHdrDir,  NullPtr, McStat, &StackPtr))
if (MemPushWord   (CoreDb->ObjVbnDir,  0,       McStat, &StackPtr))
++(CoreDb->LocalObjCount);
if (Normal(*Status))
MemPutLocalObjNum (CoreDb->LocalObjNumMap,  EnvObj,
LocalObj,                McStat);
}
if (! Build_Env)
{
if (EnvInstallObjHdr (Anchor, EnvObj, McStat, &LocalObj))
HmNewHandle (CoreDb,  LocalObj, McStat,  &Handle);
} else if (OmNewObjHdr (Anchor,  EnvObj, AllocQty, McStat, &ObjHdr)) {
ObjHdr->ObjSize = ObjHdrSize[EnvObj];
if (ObjHdr->ObjSize == 0)
*Status = Om_ObjNotInSchema;
} else
*Status = Om_ObjNotInSchema;
} else {
HmNewHandle (CoreDb,  LocalObj, McStat,  &Handle);
}
if (Normal(*Status))
if (TmMakeToken    (Anchor,  Handle,   McStat,   Token))
if (OaNewObject    (Token,   LocalObj, McStat,  &Index,  &Object))
HmPairDbObject (CoreDb,  Handle,   Index,    Object,  McStat);
TRACK(TrackBak,"OaCreateObject\n");
return (STAT);
}
boolean    OaNewObject (tokentype    *Anchor,    localnumtype LocalObj,
ft F,lt Z,zz *Status,    indextype   *Index,
addrtype     *Object)
{
objheader    *ObjHdr         = NullPtr;
handletype   *HandlePtr      = NullPtr;
cppobjtype   *CppObject      = NullPtr;
dbheader     *CoreDb         = NullPtr;
if (TmGetCoreDb    (Anchor,    McStat,   &CoreDb))
if (OmGetObjHdr    (Anchor,    LocalObj,  McStat,        &ObjHdr))
if (ObjHdr == NullPtr)
*Status = Oa_NullObjHdr;
if (Normal(*Status))
if (OmNewObject    (CoreDb,   ObjHdr,    McStat,          Index,     Object))
if (OmPairDbObject (ObjHdr,  *Index,     Anchor->Handle,  McStat))
{
if (ObjHdr->EnvObjType != That_AttrNum)
{
HandlePtr = *(handletype **)Object;
*HandlePtr = Anchor->Handle;
} else {
CppObject           = *(cppobjtype **)Object;
#ifdef IMAGE_WITH_THAT
CppObject->That     = *Object;
#endif
CppObject->Handle   = Anchor->Handle;
CppObject->DbId     = Anchor->DbId;
CppObject->CoreDbId = Anchor->CoreDbId;
}
}
if (! Normal(*Status))
{
sprintf (Msg,
"\n *** ERROR *** at OaNewObject::LocalObj[%3u] in Db %2u\n",
LocalObj, Anchor->DbId);
TraceMsg (0, Msg);
} else {
if (DeBug || OaBug)
if (sprintf (Msg,
TraceStr7(12),
LocalObj, Anchor->DbId, Anchor->Handle, ObjHdr->ObjNum))
TraceMsg (1, Msg);
}
if (Normal(*Status))
if (Anchor->DbId != RenvId)
*Status = Env_Normal;
TRACK(TrackBak,"OaNewObject\n");
return (STAT);
}
boolean    OaGetObject (tokentype    *Token,
ft F,lt Z,zz *Status,     addrtype  *Object )
{
indextype   Index           = 0;
dbheader   *CoreDb          = NullPtr;
TmGetObject          (Token,    McStat,         Object);
if (*Status == Hm_BadHandle)
{
*Status = Env0_Corrupted;
} else if (*Status == Tm_ObjectNotPaired) {
*Status = Env_Normal;
if (TmGetCoreDb       (Token,   McStat,        &CoreDb))
if (OmGetObject       (Token,   McStat,        &Index,        Object))
if (HmPutObjectMemLoc (CoreDb,  Token->Handle, 0,             McStat))
HmPutObjectAddr   (CoreDb,  Token->Handle, *Object,       McStat);
}
if (!Normal(*Status) || DeBug || OaBug)
if (sprintf  (Msg, TraceStr7(14),
Token->DbId, Token->Handle, *Object, *Status))
TraceMsg (0, Msg);
TRACK(TrackBak,"OaGetObject\n");
return (STAT);
}
boolean    OaRevokeCppObject (tokentype    *Token,  ft F,lt Z,zz *Status )
{
dbheader     *CoreDb    = NullPtr;
if (TmGetCoreDb         (Token,  McStat,       &CoreDb))
if (HmInvokeObject      (CoreDb, Token->Handle, (addrtype )NullPtr,  McStat))
HmPointToInnerRealm (CoreDb, Token->Handle, McStat);
TRACK(TrackBak,"OaRevokeCppObject\n");
return (STAT);
}
boolean    OaInvokeCppObject (tokentype    *Token,  addrtype  Object,
ft F,lt Z,zz *Status )
{
dbheader     *CoreDb    = NullPtr;
if (TmGetCoreDb          (Token,   McStat,         &CoreDb))
if (HmInvokeObject       (CoreDb,  Token->Handle,   Object,  McStat))
HmPointToOuterRegion (CoreDb,  Token->Handle,   McStat);
TRACK(TrackBak,"OaInvokeCppObject\n");
return (STAT);
}
boolean   OaUpdateObject (tokentype    *Token,   ft F,lt Z,zz *Status)
{
dbheader     *CoreDb    = NullPtr;
indextype     LocalObj  = 0;
objheader    *ObjHdr    = NullPtr;
indextype     Index     = 0;
numtype       RgnNum    = 0;
indextype     LocalIndex= 0;
if (TmGetCoreDb       (Token,    McStat,         &CoreDb))
if (HmGetObjectIndex  (CoreDb,   Token->Handle,   McStat,   &Index))
if (HmGetLocalObjNum  (CoreDb,   Token->Handle,   McStat,   &LocalObj))
if (LocalObj     == Null_ObjNum)
*Status = Oa_ObjectHasBeenDeleted;
if (Normal(*Status))
if (OmGetObjHdr       (Token,    LocalObj,        McStat,   &ObjHdr))
if (Index   < ObjHdr->BaseIndex)
{
RgnNum     = 0;
LocalIndex = Index;
} else {
RgnNum     = (Index - ObjHdr->BaseIndex) / ObjHdr->RegionObjects;
if (ObjHdr->BaseIndex)
RgnNum++;
LocalIndex = (Index - ObjHdr->BaseIndex)  % ObjHdr->RegionObjects;
}
if (Normal(*Status))
MemPutBit        (ObjHdr->DirtyRegionDir,  RgnNum, 1, McStat);
if (!Normal(*Status) || GrpBug || DbmBug || DeBug)
if (sprintf (Msg,
TraceStr7(17),
Token->DbId, Token->Handle, ObjHdr->LocalObjNum,  Index,
RgnNum, LocalIndex))
TraceMsg (0, Msg);
TRACK(TrackBak,"OaUpdateObject\n");
return(STAT);
}
boolean OaChkImage       (tokentype     *Token,   ft F,lt Z,zz  *Status)
{
dbheader     *CoreDb          = NullPtr;
numtype       ObjNum          = 0;
numtype       LocalObj        = 0;
time_t        ObjTod          = 0;
time_t        TknTod          = 0;
if (Renv_Modified)
if (TmGetCoreDb       (Token,  McStat,          &CoreDb))
if (EnvFetchObjNum    (Token,  McStat,          &ObjNum))
if (OaBug || DeBug)
if (sprintf  (Msg, TraceStr7(18),
ObjNum, Token->DbId))
TraceMsg (0,  Msg);
if (MemGetLong        (CoreDbs[RenvId]->ObjTimeStampDir,
(indextype )ObjNum,
McStat,                  (lt64     *)&ObjTod))
if (MemGetObjNum      (CoreDb->LocalObjNumMap,   ObjNum,
McStat,                  &LocalObj))
if (MemGetLong        (CoreDb->ObjTimeStampDir,  LocalObj,
McStat,                  (lt64     *)&TknTod))
if (TknTod < ObjTod)
if (OaBug || DeBug)
if (sprintf  (Msg, TraceStr7(19),
ctime (&TknTod), ctime (&ObjTod)))
if (TraceMsg (0,  Msg))
*Status   = Err_NotImplemented;
TRACK(TrackBak,"OaChkImage\n");
return (STAT);
}
boolean   OaFreeObject   (tokentype    *Token,   ft F,lt Z,zz *Status)
{
dbheader     *CoreDb    = NullPtr;
numtype       MemLoc    = 0;
addrtype      Object    = NullPtr;
indextype     LocalObj  = 0;
objheader    *ObjHdr    = NullPtr;
if (TmGetCoreDb       (Token,    McStat,         &CoreDb))
if (HmGetObjectMemLoc (CoreDb,   Token->Handle,   McStat,   &MemLoc))
if (MemLoc)
{
if (HmGetLocalObjNum  (CoreDb,   Token->Handle,   McStat,   &LocalObj))
if (OmGetObjHdr       (Token,    LocalObj,        McStat,   &ObjHdr))
if (HmGetObjectAddr   (CoreDb,   Token->Handle,   McStat,   &Object))
if (CoreFreeCoreSpace (&Object,  ObjHdr->ObjSize, McStat))
if (HmPutObjectAddr   (CoreDb,   Token->Handle,   NullPtr,   McStat))
HmPutObjectMemLoc (CoreDb,   Token->Handle,   0,         McStat);
} else {
SendMsg (0, "***ERROR... OaFreeObject:: Object NOT a Image\n");
*Status  = Oa_ObjNotInImageForm;
if (Normal(*Status))
HmClearObject (CoreDb, Token->Handle, McStat);
}
TRACK(TrackBak,"OaFreeObject\n");
return(STAT);
}
boolean   OaDeleteObject  (tokentype   *Token,   ft F,lt Z,zz *Status)
{
dbheader       *CoreDb          = NullPtr;
addrtype        Object          = NullPtr;
numtype         ObjNum          = 0;
numtype         LocalObj        = 0;
objheader      *ObjHdr          = NullPtr;
indextype       ObjIndex        = 0;
indextype       StackPtr        = 0;
if (TmGetCoreDb      (Token,              McStat,          &CoreDb))
if (EnvFetchObjNum   (Token,              McStat,          &ObjNum))
if (MemGetLocalObjNum
(CoreDb->LocalObjNumMap,               ObjNum,
McStat,                              &LocalObj))
if (OmGetObjHdr      (Token,                                LocalObj,
McStat,                              &ObjHdr))
if (OaGetObject       (Token,              McStat,         &Object))
if (OaUpdateObject    (Token,              McStat))
if (Normal(*Status))
#ifdef   __SWAP_GRP_POS__
OmDeleteObject      (Token,            ObjHdr,      Object,   McStat);
#else
if (HmGetObjectIndex  (CoreDb,                              Token->Handle,
McStat,                             &ObjIndex))
if (MemPushWord       (ObjHdr->ExObjectTbl,                 ObjIndex,
McStat,                             &StackPtr))
if (TmFreeToken       (McStat,                              Token))
ObjHdr->ExObjectCount++;
if (Normal(*Status))
memset (Object, 0, (size_t )ObjHdr->ObjSize);
#endif
TRACK(TrackBak,"OaDeleteObject\n");
return(STAT);
}
boolean    OaGetObjHandles
(tokentype    *Anchor,  numtype      ObjNum,
ft F,lt Z,zz *Status,
indextype    *Count,   handletype **Handles)
{
dbheader     *CoreDb        = NullPtr;
localnumtype  ObjIndex      = 0;
objheader    *ObjHdr        = NullPtr;
bytessize     CoreBlkSize   = 0;
numtype      *RgnStatus     = NullPtr;
indextype     RgnCount      = 0;
if (TmFetchCoreDb     (Anchor,                  McStat,    &CoreDb))
if (MemGetLocalObjNum (CoreDb->LocalObjNumMap,  ObjNum,
McStat,                 &ObjIndex))
if (OmGetObjHdr       (Anchor,                  ObjIndex,
McStat,                 &ObjHdr))
if (OmGetObjHandles   (Anchor,    ObjHdr,       McStat,
Count,     Handles,     &RgnCount,  &RgnStatus))
{
CoreBlkSize  = RgnCount * sizeof (numtype);
CoreFreeCoreSpace ((addrtype *)RgnStatus,   CoreBlkSize,   McStat);
}
TRACK(TrackBak,"OaGetObjHandles\n");
return (STAT);
}
boolean    OaReclaimHandles
(tokentype    *Anchor,  numtype      ObjNum,
ft F,lt Z,zz *Status)
{
indextype     Count         = 0;
handletype   *Handles       = NullPtr;
dbheader     *CoreDb        = NullPtr;
localnumtype  ObjIndex      = 0;
objheader    *ObjHdr        = NullPtr;
bytessize     CoreBlkSize   = 0;
numtype      *RgnStatus     = NullPtr;
indextype     RgnCount      = 0;
indextype     NullRgnCount  = 0;
int           i             = -1;
int           j             = -1;
indextype    *ExObjects     = NullPtr;
indextype     ExObjectCount = 0;
indextype     HighIndex     = 0;
indextype     LowIndex      = 0;
if (TmFetchCoreDb     (Anchor,                  McStat,    &CoreDb))
if (MemGetLocalObjNum (CoreDb->LocalObjNumMap,  ObjNum,
McStat,                 &ObjIndex))
if (OmGetObjHdr       (Anchor,                  ObjIndex,
McStat,                 &ObjHdr))
if (OmGetObjHandles   (Anchor,    ObjHdr,       McStat,
&Count,    &Handles,     &RgnCount,  &RgnStatus))
if (MemGetChunkAddr   (ObjHdr->ExObjectTbl, McStat, (addrtype *)&ExObjects))
{
ExObjectCount    = ObjHdr->ExObjectCount;
NullRgnCount     = 0;
while (++i < RgnCount)
{
if (RgnStatus[i] == 0)
{
for (j = -1; ++j < ObjHdr->ExObjectCount; )
{
if (ExObjects[j] <= HighIndex
&&  ExObjects[j] >= LowIndex)
{
ExObjects[j] =  0;
ExObjectCount--;
}
}
RgnStatus[NullRgnCount++] = i;
}
}
for (i = -1, j= -1; ++i < ObjHdr->ExObjectCount; )
{
if (ExObjects[i]  == 0)
{
ExObjects[++j]  = 0;
}
}
if ((ObjHdr->ExObjectCount = ExObjectCount) != ++j)
if (sprintf (Msg,  "***ERROR... Mismatched Stacks; j=%4u, ExCount=%4u\n",
j, ExObjectCount))
if (TraceMsg (0,  Msg))
*Status  = Oa_BadObjStacks;
}
CoreBlkSize  = Count * sizeof (handletype);
if (Handles)
CoreFreeCoreSpace ((addrtype *)Handles,   CoreBlkSize,   McStat);
CoreBlkSize  = RgnCount * sizeof (numtype);
if (RgnStatus)
CoreFreeCoreSpace ((addrtype *)RgnStatus,   CoreBlkSize,   McStat);
TRACK(TrackBak,"OaReclaimHandles\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\oa1.c*/

#define OA1



#ifdef API_INCLUDE

#endif
#define MemGetObjNum         Mem_GetWord
#define MemGetLocalObjNum    Mem_GetWord
#define MemGetAttrNum        Mem_GetWord
#define MemGetSize           Mem_GetWord
#define MemGetVbn            Mem_GetWord
#ifdef __ZTC__
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#else
#ifdef MCSTAT
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(Anchor->DbId <= MaxCoreDbId \
&& ((*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr)) ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#else
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#endif
#endif
#ifndef INLINE_OMIDEFS
#else
#define        SetHead_ObjNum         (objnumtype )62
#define        Node_ObjNum            (objnumtype )76
#define        ObjNum_AttrNum         (numtype )5
#define        CodeNum_AttrNum        (numtype )17
#define        BaseCreateCode_AttrNum (numtype )72
#define Code_ForeignNotCreate   14000
#endif
boolean OaIamA            (tokentype    *Token,     numtype       EnvObj,
ft F,lt Z,zz *Status)
{
numtype       ObjNum        = 0;
tokentype     ObjCestrsTkn;
bytetype      BitVal        = 1;
if (Token->DbId   == 0
&&  Token->Handle  > 0)
ObjNum = Token->Handle;
else
EnvFetchObjNum     (Token,         McStat,           &ObjNum);
if (Normal(*Status))
if (ObjNum != EnvObj)
if (EnvFetchObjCestrs  (ObjNum,        McStat,           &ObjCestrsTkn))
if (BitField_Get       (&ObjCestrsTkn, EnvObj,  McStat,  &BitVal))
if (!BitVal)
*Status = Kernl_IamNot;
TRACK(TrackBak,"OaIamA\n");
return (STAT);
}
boolean    ForeignCreate  (numtype       ObjNum,    addrtype      ForeignTkn,
ft F,lt Z,zz *Status,    addrtype     *ForeignAddr )
{
tokentype    Token;
handletype   ObjHandle;
handletype   CodeHandle;
addrtype     DumObj         = NullPtr;
indextype    CodeNum        = 0;
p_create     CreateCodeAddr = (p_create )NullPtr;
if (EnvFetchObjHandle (ObjNum, McStat, &ObjHandle))
{
Token.DbId   = RenvId;
Token.Handle = ObjHandle;
}
if (Normal(*Status))
if (OaGet (False,   &Token,  (addrtype )DumObj, BaseCreateCode_AttrNum,
McStat,  (addrtype )&CodeHandle))
{
Token.DbId   = RenvId;
Token.Handle = CodeHandle;
}
if (Normal(*Status))
if (OaGet (False,   &Token,  (addrtype )DumObj, CodeNum_AttrNum,
McStat,   (addrtype )&CodeNum))
if (EnvFetchCode  (CodeNum, McStat, (funcptrtype *)&CreateCodeAddr))
if (! (*CreateCodeAddr) (ForeignTkn, ForeignAddr))
*Status = Code_ForeignNotCreate;
TRACK(TrackBak,"ForeignCreate\n");
return (STAT);
}
boolean  OaInitObject     (tokentype    *Token,     numtype       NumInits,
numtype      *AttrNums,  addrtype     *Values,
ft F,lt Z,zz *Status)
{
#ifdef API_INCLUDE
indextype    Index          = 0;
short        i              = 0;
boolean      Match          = False;
addrtype     DbOffset       = NullPtr;
sizetype     AttrSize       = 0;
indextype    ExtendQty      = 0;
tokentype    VchunkTkn      = NullToken;
classmaptype ClassMap;
#endif
#ifdef API_INCLUDE
VchunkTkn.DbId  = RenvId;
if (CoreDbs[Token->DbId])
MemGetAddr (CoreDbs[Token->DbId]->ObjectAddrDir,  Token->Handle,
McStat,                  (addrtype *)&Object);
if (Normal(*Status))
if (Object)
{
if (EnvFetchObjNum (Token,           McStat,  &ObjNum))
if (TransGetMap    (C_Apl,     ObjNum,   McStat,  &ClassMap))
for (i=0;  i < NumInits; i++)
{
for (Index = 1,  Match = False;
Index <= ClassMap.NumMapFields && ! Match; Index++ )
{
if (AttrNums[i] == ClassMap.FieldAttrIds[Index])
Match  = True;
}
if (Match)
{
DbOffset  = (addrtype )((char *)Object + ClassMap.DbOffsets[Index]);
if (ClassMap.FieldAttrTypes[Index] == aArrayAttr
||  ClassMap.FieldAttrTypes[Index] == aDblPtrAttr
||  ClassMap.FieldAttrTypes[Index] == aVarrayAttr)
{
ExtendQty   = *(indextype *)Values[i];
if (EnvFetchAttrSize (ClassMap.FieldAttrIds[Index],
McStat,                    &AttrSize))
if (OaCreateVchunk   (Token,                      AttrSize,
*(sizetype *)Values[i],     ExtendQty,
McStat,                    &VchunkTkn))
if (OaPutVchunkStackPtr
(&VchunkTkn,  ExtendQty,     McStat))
if (OaGetVchunkAddr  (&VchunkTkn,  McStat,       &Array))
if (DeBug || OaBug)
if (sprintf (Msg, "  Assign Array Address To @%x\n", Array))
TraceMsg (0, Msg);
if (Normal(*Status))
MoveBytes (&VchunkTkn.Handle, DbOffset, sizeof (handletype));
} else
MoveBytes (Values[i], DbOffset, ClassMap.FieldSizes[Index]);
} else
*Status = Oa_AttrNotPresent;
}
} else
#endif
*Status = Oa_NotInCreateMode;
TRACK(TrackBak,"OaInitObject\n");
return (STAT);
}
boolean    OaCopy         (tokentype    *TokenA,    tokentype     *TokenB,
ft F,lt Z,zz *Status)
{
*Status   = Err_NotImplemented;
TRACK(TrackBak,"OaCopy\n");
return(STAT);
}
boolean OaGetDbObjNums    (int           TraceSwi, tokentype    *Anchor,
ft F,lt Z,zz *Status)
{
dbheader     *DbHdr      = NullPtr;
indextype     ObjectCount   = 0;
indextype     ObjIndex   = 0;
objheader    *ObjHdr     = NullPtr;
objdesctype  *ObjDesc    = 0;
numtype       EnvObjNum  = 0;
tokentype     ObjTkn;
numtype       Items      = 0;
wordtype      Vbn        = 0;
time_t        Tod        = 0;
ObjTkn.DbId  = RenvId;
sprintf  (Msg, "             OBJ Classes In Db[%2u]\n", Anchor->DbId);
TraceMsg (0,   Msg);
if (TraceSwi)
TraceMsg (0,   "                 with number of instances\n\n");
if (TmFetchCoreDb  (Anchor,               McStat,    &DbHdr))
if (sprintf  (Msg, "                 TimeStampChunk : %2u\n",
DbHdr->ObjTimeStampDir))
if (TraceMsg (0,   Msg))
while (Normal(*Status)
&&   ++ObjIndex <= DbHdr->LocalObjCount)
{
ObjectCount  = 0;
if (MemGetWord  (DbHdr->ObjNumMap,     ObjIndex,   McStat, &EnvObjNum))
if (MemGetAddr  (DbHdr->ObjHdrDir,     ObjIndex,
McStat,              (addrtype *)&ObjHdr))
if (Anchor->DbId == RenvId)
MemGetLong        (DbHdr->ObjTimeStampDir, EnvObjNum,    McStat,
(lt64 *)&Tod);
else
MemGetLong        (DbHdr->ObjTimeStampDir, ObjIndex,  McStat,
(lt64 *)&Tod);
if (Normal(*Status))
if (ObjHdr)
ObjectCount  = ObjHdr->ObjectCount;
else if (TraceSwi) {
if (MemGetVbn     (DbHdr->ObjVbnDir,   ObjIndex,   McStat, &Vbn))
if (Vbn)
if (DbmLoadObjHdr (Anchor,             ObjIndex,   McStat, &ObjHdr))
ObjectCount  = ObjHdr->ObjectCount;
else
ObjectCount  = 0;
}
if (EnvFetchObjHandle
(EnvObjNum,            McStat,          &ObjTkn.Handle))
if (OaGetObject (&ObjTkn,              McStat,    (addrtype *)&ObjDesc))
{
if ((TraceSwi  == 0)
||  (TraceSwi  && ObjectCount > 0))
{
if (Items++ % 3 == 0
&&  Items       != 1)
TraceMsg (0, "\n");
if (TraceSwi)
sprintf  (Msg,  " %18s(%3u) ", ObjDesc->Nam, ObjectCount);
else
sprintf  (Msg,  " %24s",       ObjDesc->Nam);
TraceMsg (0, Msg);
}
}
}
TraceMsg (0, "\n");
TRACK(TrackBak,"OaGetDbObjNums\n");
return(STAT);
}
boolean   OaDelete        (tokentype    *Token,     ft F,lt Z,zz *Status)
{
dbheader       *CoreDb          = NullPtr;
addrtype        Object          = NullPtr;
numtype         ObjNum          = 0;
numtype         LocalObj        = 0;
objheader      *ObjHdr          = NullPtr;
if (TmIsValid      (Token,  McStat)  == False)
{
sprintf (Msg,
"\n ***ERROR*** OaDelete :: Object[%2u:%4u]\n",
Token->DbId, Token->Handle);
TraceMsg (0,  Msg);
*Status  = Oa_ObjectHasBeenDeleted;
}
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, "   Oa_Delete... Token= [%2u:%4u]\n",
Token->DbId, Token->Handle))
TraceMsg (0, Msg);
if (TmGetCoreDb       (Token,            McStat,     &CoreDb))
if (EnvFetchObjNum    (Token,            McStat,     &ObjNum))
if (MemGetLocalObjNum (CoreDb->LocalObjNumMap,        ObjNum,
McStat,                       &LocalObj))
if (OmGetObjHdr       (Token,                         LocalObj,
McStat,                       &ObjHdr))
if (OaGetObject       (Token,            McStat,     &Object))
if (OaUpdateObject    (Token,            McStat))
OaDeleteFields    (Token,  LocalObj, ObjHdr,      Object,   McStat);
if (Normal(*Status))
#ifdef   __SWAP_GRP_POS__
OmDeleteObject      (Token,            ObjHdr,      Object,   McStat);
#else
if (HmGetObjectIndex  (CoreDb,                        Token->Handle,
McStat,                       &ObjIndex))
if (MemPushWord       (ObjHdr->ExObjectTbl,           ObjIndex,
McStat,                       &StackPtr))
if (TmFreeToken       (McStat,                        Token))
ObjHdr->ExObjectCount++;
if (Normal(*Status))
memset (Object, 0, ObjHdr->ObjSize);
#endif
TRACK(TrackBak,"OaDelete\n");
return(STAT);
}
boolean    OaDeleteFields (tokentype    *Token,     numtype       LocalObj,
objheader    *ObjHdr,    addrtype      Object,
ft F,lt Z,zz *Status)
{
dbheader       *CoreDb          = NullPtr;
bytessizetype   FieldSize       = 0;
bytessizetype   FieldOffset     = 0;
counttype       FieldCount      = 0;
addrtype        FieldAddr       = NullPtr;
numtype         AttrNum         = 0;
numtype         LocalAttr       = 0;
tokentype       AttrToken;
attrdesctype   *AttrDesc        = NullPtr;
static tokentype ValueTkn       = Null_Token;
static addrtype  ValuePtr       = &ValueTkn;
indextype       Index           = 0;
tokentype       VchunkTkn       = NullToken;
chunkstruc      ChunkStruc;
int             j               = 0;
addrtype       *Arrays          = NullPtr;
handletype     *ArrayHndls      = NullPtr;
handletype     *SubArrays       = NullPtr;
indextype       NumSubArrays    = 0;
handletype      ArrayOwner      = 0;
indextype       FieldMapCount   = 0;
maptkntype      RefMapTkn;
static boolean  FirstDeleteNode = True;
boolean         TempClassBug    = ClassBug;
boolean         TempSetBug      = SetBug;
AttrToken.DbId        = RenvId;
ValueTkn.DbId         = Token->DbId;
if (TmGetCoreDb       (Token,            McStat,     &CoreDb))
while (Normal(*Status)
&&   ++FieldCount     <= ObjHdr->FieldCount)
{
if (MemGetAttrNum (ObjHdr->LocalAttrNumMap,             FieldCount,
McStat,                             &LocalAttr))
if (MemGetAttrNum (CoreDb->AttrNumMap,                  LocalAttr,
McStat,                             &AttrNum))
if (EnvFetchAttrHandle
(AttrNum,
McStat,                  &(AttrToken.Handle)))
if (OaGetObject   (&AttrToken,   McStat,   (addrtype *)&AttrDesc))
if (AttrDesc->AttrType != aAttr)
{
ValueTkn.DbId     = Token->DbId;
ValueTkn.Handle   = NullHandle;
if (MemGetSize (CoreDb->LocalAttrSizeTbl,            LocalAttr,
McStat,                             &FieldSize))
if (MemGetSize (ObjHdr->FieldOffsetDir,              FieldCount,
McStat,                             &FieldOffset))
{
FieldAddr = (addrtype )((char *)Object    +      FieldOffset);
if (FieldSize <= sizeof (tokentype))
{
MoveBytes  (FieldAddr,          ValuePtr,        FieldSize);
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg,
"                           ValueTkn= [%2u:%4u]\n",
ValueTkn.DbId, ValueTkn.Handle))
TraceMsg (0, Msg);
}
}
if (Normal(*Status))
{
switch (AttrDesc->AttrType)
{
case  aObjRefAttr      :
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   DeReference the Object Ref Attr ...\n"))
TraceMsg (0, Msg);
break;
case  aMapRefAttr      :
++FieldMapCount;
if (MemGetSomeBytes
(ObjHdr->FieldMapDir,       FieldMapCount,
sizeof (maptkntype),
McStat,                   &RefMapTkn))
if (RefMapTkn.FieldNum  == FieldCount)
OaDeleteEmbedded
(Token,               RefMapTkn.LocalObj,
FieldAddr,           McStat);
else {
sprintf (Msg,
" ***ERROR*** Oa_Delete:: FieldNum(%4u) != RefFieldNum(%4u)/n",
FieldCount,  RefMapTkn.FieldNum);
TraceMsg (0, Msg);
}
break;
case  aPortRefAttr :
case  aTknRefAttr  :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
break;
case  aSetNodeAttr :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   Delete the Set Node...\n"))
TraceMsg (0, Msg);
if (FirstDeleteNode)
{
FirstDeleteNode = False;
}
SetDeleteFrom     (AttrDesc->BuildDesc, Token, McStat);
if (*Status == Set_NotFound)
{
*Status  = Env_Normal;
sprintf (Msg,
"   Delete from Set...Token[%4u:%6u] not in set!\n",
Token->DbId, Token->Handle);
TraceMsg (0, Msg);
}
break;
case  aSetHeadAttr :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   Delete the Set ...\n"))
TraceMsg (0, Msg);
SetDeleteSet      (AttrDesc->BuildDesc,  Token, McStat);
break;
case  aStrHndlAttr     :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   Delete the Dbms String ...\n"))
TraceMsg (0, Msg);
Index    = (indextype )ValueTkn.Handle;
break;
case  aSlotHndlAttr    :
case  aSlotTokenAttr   :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   UnTuple this Object ...\n"))
TraceMsg (0, Msg);
break;
case  aMtrxHeadAttr    :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   Delete the Matrix...\n"))
TraceMsg (0, Msg);
break;
case  aRowHeadAttr     :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   Delete/UnMate the Row...\n"))
TraceMsg (0, Msg);
break;
case  aColHeadAttr     :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   Delete/Unmate The Column   ...\n"))
TraceMsg (0, Msg);
break;
case  aMateNodeAttr     :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   Unmate the Row and Column   ...\n"))
TraceMsg (0, Msg);
break;
case  aPointNodeAttr     :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   Delete the Point Node      ...\n"))
TraceMsg (0, Msg);
break;
case aChunkAttr    :
case aVchunkAttr   :
case aArrayAttr    :
case aVarrayAttr   :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   Delete The Virtual Chunk ...\n"))
TraceMsg (0, Msg);
if (Normal(*Status))
if (ValueTkn.Handle > 0)
Vchunk_Delete   (&ValueTkn,     McStat);
break;
case aDblPtrAttr   :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   Delete The Indirect Virtual Chunk ...\n"))
TraceMsg (0, Msg);
VchunkTkn.DbId     = Token->DbId;
j                  = -1;
if (VchunkGetAddress  (&ValueTkn,
McStat,      (addrtype *)&Arrays))
if (VchunkGetVstruc   (&ValueTkn,   McStat,     &ChunkStruc))
if (DeBug  || OaBug || ClassBug)
if (sprintf (Msg, "  Array Of Pointers; StackPtr =%4u;\n",
ChunkStruc.StackPtr))
TraceMsg (0, Msg);
ArrayOwner          = ValueTkn.Handle;
ArrayHndls = (handletype *) Arrays;
NumSubArrays  = ChunkStruc.StackPtr / 3;
SubArrays = (handletype *) &ArrayHndls[NumSubArrays*2];
while (Normal(*Status)
&&     ++j   < NumSubArrays)
{
#ifdef __BCC__
memcpy (&Index,
&SubArrays[j], sizeof (handletype));
#else
Index             = (handletype )SubArrays[j];
#endif
VchunkTkn.Handle  = Index;
if (Index)
Vchunk_Delete   (&VchunkTkn,     McStat);
if (DeBug  || OaBug || ClassBug)
if (sprintf (Msg, "  Delete SubVarray[%2u] Vchunk[%3u:%4u]\n",
j, VchunkTkn.DbId, Index))
TraceMsg (0, Msg);
}
ValueTkn.Handle  = ArrayOwner;
if (Normal(*Status))
if (ArrayOwner)
Vchunk_Delete   (&ValueTkn,     McStat);
break;
case  aGrpAttr         :
case  aVgrpAttr        :
if (ValueTkn.Handle == 0
||  ValueTkn.DbId   == 0)
break;
if (OaBug || ClassBug || DeBug)
if (sprintf (Msg, "   Delete the dependent GRP    ...\n"))
TraceMsg (0, Msg);
Grp_DeletePacket  (&ValueTkn, ValueTkn.Handle,  McStat);
break;
default            :
break;
}
}
}
}
ClassBug = TempClassBug;
SetBug = TempSetBug;
TRACK(TrackBak,"OaDeleteFields\n");
return(STAT);
}
boolean    OaDeleteEmbedded
(tokentype    *Token,     numtype       LocalObj,
addrtype      Object,    ft F,lt Z,zz *Status)
{
objheader      *ObjHdr          = NullPtr;
if (OmGetObjHdr     (Token,     LocalObj,    McStat,    &ObjHdr))
OaDeleteFields  (Token,     LocalObj,    ObjHdr,     Object,   McStat);
TRACK(TrackBak,"OaDeleteEmbedded\n");
return(STAT);
}
boolean OaCreateArray     (tokentype    *DbmsToken, numtype   AttrNum,
indextype     UnitCount, sizetype  UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype *ArrayAddr)
{
indextype   ExtendQty = UnitCount;
numtype     MemLoc    = 0;
addrtype    CppAddr   = NullPtr;
addrtype    NullObject= NullPtr;
statustype  DumpStatus  = Env_Normal;
addrtype    Vchunk    = NullPtr;
if (TmIsValid      (DbmsToken,  McStat)  == False)
{
sprintf (Msg,  "\n ***ERROR*** OaDelete :: Object[%2u:%4u]\n",
DbmsToken->DbId, DbmsToken->Handle);
TraceMsg (0,  Msg);
*Status  = Oa_ObjectHasBeenDeleted;
}
if (Normal(*Status))
if (HmGetObjectMemLoc (CoreDbs[DbmsToken->DbId],  DbmsToken->Handle,
McStat,                   &MemLoc))
if (DeBug || OaBug)
if (sprintf (Msg,
" OaCreateArray DbmsObject[%2u:%4u](Attr %2u)*%2u MemLoc= %1u\n",
DbmsToken->DbId, DbmsToken->Handle, AttrNum, UnitCount, MemLoc))
TraceMsg (0, Msg);
if (Normal(*Status))
if (MemLoc)
if (HmGetObjectAddr   (CoreDbs[DbmsToken->DbId],  DbmsToken->Handle,
McStat,                   &CppAddr))
HmPutObjectAddr   (CoreDbs[DbmsToken->DbId],  DbmsToken->Handle,
NullPtr,                   McStat);
if (Normal(*Status))
if (VchunkCreate      (DbmsToken,  UnitSize,      UnitCount,
ExtendQty,
McStat,     VchunkTkn))
if (VchunkPutStackPtr (VchunkTkn,  UnitCount,     McStat,   &Vchunk))
if (DeBug || OaBug)
if (sprintf (Msg, "  Assign Array Address To @%x\n",   *ArrayAddr))
TraceMsg (0, Msg);
if (Normal(*Status))
if (*ArrayAddr == NullPtr)
{
if (VchunkGetAddress (VchunkTkn,     McStat,            ArrayAddr))
if (DeBug || OaBug)
if (sprintf (Msg, "  Assign Array Address To VchunkAddr = @%x\n",
*ArrayAddr))
TraceMsg (0, Msg);
if (Normal(*Status))
if (OaPut          (False,           DbmsToken,         NullObject,
AttrNum,        (addrtype )VchunkTkn,   McStat))
if (OaBug)
OaDumpObject   (0,               DbmsToken,         Dump_Status);
if (Normal(*Status))
if (MemLoc)
if (HmPutObjectMemLoc (CoreDbs[DbmsToken->DbId],  DbmsToken->Handle,
(numtype )1,               McStat))
HmPutObjectAddr   (CoreDbs[DbmsToken->DbId],  DbmsToken->Handle,
CppAddr,                   McStat);
} else {
if (OaPut          (False,           DbmsToken,            NullObject,
AttrNum,        (addrtype )VchunkTkn,  McStat))
if (OaBug)
OaDumpObject   (0,               DbmsToken,         Dump_Status);
if (Normal(*Status))
if (MemLoc)
if (HmPutObjectMemLoc (CoreDbs[DbmsToken->DbId],  DbmsToken->Handle,
(numtype )1,               McStat))
if (HmPutObjectAddr   (CoreDbs[DbmsToken->DbId],  DbmsToken->Handle,
CppAddr,                   McStat))
if (OaBug)
OaDumpObject      (0,                 DbmsToken,      Dump_Status);
}
if (!Normal(*Status) || DeBug || OaBug || ClassBug)
{
sprintf (Msg, "  OaCreateArray for Token[%2u:%4u] Vchunk = %3u @%x\n",
DbmsToken->DbId,    DbmsToken->Handle,
VchunkTkn->Handle, *ArrayAddr);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"OaCreateArray\n");
return (STAT);
}
boolean OaCreateVarray    (tokentype    *DbmsToken, numtype   AttrNum,
indextype     UnitCount, sizetype  UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype *Varray)
{
indextype   ExtendQty = UnitCount;
numtype     MemLoc    = 0;
addrtype    NullObject= NullPtr;
statustype  DumpStatus  = Env_Normal;
if (DeBug || OaBug)
if (sprintf (Msg,
" OaCreateVarray DbmsObject[%2u:%4u](Attr %2u)*%2u MemLoc= %1u\n",
DbmsToken->DbId, DbmsToken->Handle, AttrNum, UnitCount, MemLoc))
TraceMsg (0, Msg);
if (VchunkCreate        (DbmsToken,           UnitSize,   UnitCount,
ExtendQty,
McStat,                          VchunkTkn))
if (VchunkPutStackPtr   (VchunkTkn,           0,
McStat,                          Varray))
if (OaPut               (False,               DbmsToken,  NullObject,
AttrNum,  (addrtype )VchunkTkn,  McStat))
if (OaBug)
OaDumpObject        (0,               DbmsToken,      Dump_Status);
if (!Normal(*Status) || DeBug || OaBug)
{
sprintf (Msg, "  OaCreateVarray for Token[%2u:%4u] Vchunk = %3u @%x\n",
DbmsToken->DbId,    DbmsToken->Handle,
VchunkTkn->Handle, *Varray);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"OaCreateVarray\n");
return (STAT);
}
boolean    OaPut          (boolean      CppType,    tokentype    *Token,
addrtype     ObjectAddr, numtype       EnvAttrNum,
addrtype     AttrValue,  ft F,lt Z,zz *Status)
{
num          LocalAttrNum = 0;
num          LocalObjNum  = 0;
num          FieldNum     = 0;
bytessize    Size         = 0;
bytessize    Offset       = 0;
addrtype     BytePtr      = NullPtr;
objheader   *ObjHdr       = NullPtr;
addrtype     Object       = ObjectAddr;
dbheader    *CoreDb       = NullPtr;
tokentype    AttrTkn;
attrdesctype *AttrDesc    = NullPtr;
statustype   DumpStatus   = Env_Normal;
indextype    Index        = 0;
numtype      MemLoc       = 0;
tokentype   *TokenPtr     = NullPtr;
char        *StrPtr       = NullPtr;
char        *String       = NullPtr;
sizetype     StrSize      = 0;
if (TmIsValid      (Token,   McStat)  == False)
{
sprintf (Msg,
"\n ***ERROR*** OaPut ::  Object[%2u:%4u]. Token is Invalid!\n",
Token->DbId, Token->Handle);
TraceMsg (0,  Msg);
*Status  = Oa_ObjectHasBeenDeleted;
}
if (DeBug)
if (sprintf (Msg, "   OaPut TO Object[%2u:%4u] for AttrNum= %u\n",
Token->DbId, Token->Handle, EnvAttrNum))
TraceMsg (0, Msg);
AttrTkn.DbId = RenvId;
if (Normal(*Status))
if (CppType)
{
Token->Handle = ((objtype *)Object)->Handle;
if (TmGetCoreDb     (Token,    McStat,   &CoreDb))
*Status = Oa_BadDbToken;
} else {
if (TmGetCoreDb    (Token,    McStat,   &CoreDb))
if (OaGetObject    (Token,    McStat,   &Object))
OaUpdateObject (Token,    McStat);
if (!Normal(*Status))
{
sprintf (Msg, "   Object[%2u:%4u] Corrupted ... \n",
Token->DbId, Token->Handle);
TraceMsg (0, Msg);
if (HmPutObjectAddr (CoreDb, Token->Handle,  NullPtr, Dump_Status))
if (OmGetObject     (Token,  Dump_Status,   &Index,       &Object))
OaDumpObject    (0,      Token,                   Dump_Status);
if (Normal(DumpStatus))
*Status = Env_Normal;
}
}
if (Normal(*Status))
if (HmGetObjectMemLoc
(CoreDb,  Token->Handle,    McStat,   &MemLoc))
if (HmGetLocalObjNum (CoreDb,                               Token->Handle,
McStat,                              &LocalObjNum))
if (MemGetAddr       (CoreDb->ObjHdrDir,        (indextype )LocalObjNum,
McStat,                  (addrtype *)&ObjHdr))
MemGetObjNum     (CoreDb->LocalAttrNumMap,  (indextype )EnvAttrNum,
McStat,                              &LocalAttrNum);
if (Normal(*Status))
if (!LocalAttrNum)
{
sprintf (Msg, "   Object[%2u:%4u] does not have AttrNum : %u\n",
Token->DbId, Token->Handle, EnvAttrNum);
TraceMsg (0, Msg);
*Status = Oa_DbNoThisAttr;
}
if (Normal(*Status))
if (MemGetSize      (CoreDb->LocalAttrSizeTbl,  (indextype )LocalAttrNum,
McStat,                                 &Size))
if (MemGetObjNum    (ObjHdr->FieldNumMap,       (indextype )LocalAttrNum,
McStat,                        (num *)&FieldNum))
if (EnvFetchAttrOffset
(Token,      EnvAttrNum,   ObjHdr,      FieldNum,
McStat,                               &Offset))
if (*Status       == Env_AttrNotInDbmsClassDef)
*Status        = Oa_AttrNotInDbmsClassDef;
else if (FieldNum == 0)
*Status        = Oa_ObjNoThisField;
if (Normal(*Status))
if (EnvFetchAttrHandle
(EnvAttrNum, McStat,           &AttrTkn.Handle))
if (OaGetObject     (&AttrTkn,   McStat,       (addrtype *)&AttrDesc))
if (AttrDesc->AttrType         == aTknRefAttr)
{
if (MemLoc  == 0)
TokenPtr   = (tokentype *)((char *)AttrValue + sizeof(addrtype));
else {
Size       = sizeof (addrtype)   + sizeof (tokentype);
TokenPtr   = (tokentype *)AttrValue;
}
BytePtr      = (addrtype )((char *)Object + Offset);
MoveBytes      (TokenPtr, BytePtr, Size);
} else if (AttrDesc->AttrType  == aObjRefAttr) {
if (MemLoc  == 1)
Size       = sizeof (addrtype);
BytePtr      = (addrtype )((char *)Object + Offset);
MoveBytes      (AttrValue, BytePtr, Size);
} else if (AttrDesc->TypeType  == aDbmsString) {
BytePtr      = (addrtype )((char *)Object + Offset);
if (MemLoc  == 0)
OaPutString    (Token->DbId,  ObjHdr,  (char      *)AttrValue,
McStat,                (indextype *)BytePtr);
else {
StrPtr      = (char *)AttrValue;
if (StrPtr)
if ((StrSize = strlen (StrPtr)+1) >= 1)
{
if (Core0_AllocString  (StrSize,  McStat,  &String))
{
if (ClassBug || OaBug  || DeBug)
if (sprintf (Msg, "    ***DbmsString Mallocd  @%x\n", String))
TraceMsg (0, Msg);
strcpy (String,  StrPtr);
MoveBytes   ((addrtype )&String, BytePtr, sizeof (char *));
}
} else
MoveBytes   (&StrPtr, BytePtr, sizeof (char *));
}
} else if (AttrDesc->TypeType  == aString
&&  AttrDesc->UnitSize   > 1)
{
BytePtr      = (addrtype )((char *)Object + Offset);
StrPtr       = (char *)AttrValue;
if (StrPtr)
{
strncpy ((char *)BytePtr,  StrPtr, AttrDesc->UnitSize - 1);
} else
MoveBytes   (AttrValue, BytePtr, sizeof (char *));
} else {
BytePtr      = (addrtype )((char *)Object + Offset);
MoveBytes      (AttrValue, BytePtr, Size);
}
if (!Normal(*Status) || DeBug || OaBug) {
if (sprintf (Msg, "   PUT Attr[%3u](%3u) size %4d ::= ",
EnvAttrNum, LocalAttrNum, Size))
if (TraceMsg   (0, Msg))
if (TraceBytes (0, AttrValue, Size))
if (TraceMsg   (0, "\n"))
if (sprintf (Msg, "   TO  object[%2u:%4u](%3u)  offset %3u @%x\n",
Token->DbId, Token->Handle, LocalObjNum,
Offset, BytePtr))
TraceMsg   (0, Msg);
}
if (*Status != Env_Normal)
OaDumpObject (0, Token, Dump_Status);
TRACK(TrackBak,"OaPut\n");
return (STAT);
}
boolean    OaPutString    (idtype        DbId,    objheader    *ObjHdr,
char         *String,
ft F,lt Z,zz *Status,  indextype    *StrIndex)
{
indextype    Index        = *StrIndex;
dbheader    *CoreDb       = CoreDbs[DbId];
indextype    NumStrings   = 0;
if (Index)
MemPutString    (ObjHdr->TextChunk,    Index,
String,               McStat);
else {
if (!ObjHdr->TextChunk)
if ( ObjHdr->TextChunkVbn)
FileInChunk  (&ObjHdr->TextChunk,  &CoreDb->BlkHdr,
False,
McStat,              &ObjHdr->TextChunkVbn);
else {
NumStrings = ObjHdr->RegionObjects;
MemMakeStrChunk (1024, NumStrings, ObjHdr->RegionObjects,
2048, DbId,
McStat,           &ObjHdr->TextChunk);
}
if (ObjHdr->TextChunk)
{
MemNewString (ObjHdr->TextChunk,           String,
McStat,                     &Index);
} else
*Status = Err_BadDesign;
}
*StrIndex = Index;
TRACK(TrackBak,"OaPutString\n");
return (STAT);
}
boolean    OaPutToEmbedded
(tokentype    *Token,     numtype    SubClassAttr,
numtype       AttrNum,   addrtype   Value,
ft F,lt Z,zz *Status)
{
numtype      SubClassObj  = 0;
numtype      LocalAttrNum = 0;
numtype      LocalObjNum  = 0;
numtype      FieldNum     = 0;
bytessize    Size         = 0;
bytessize    SubOffset    = 0;
bytessize    Offset       = 0;
addrtype     BytePtr      = NullPtr;
objheader   *ObjHdr       = NullPtr;
objheader   *SubObjHdr    = NullPtr;
addrtype     Object       = NullPtr;
dbheader    *CoreDb       = NullPtr;
tokentype    AttrTkn;
attrdesctype *AttrDesc    = NullPtr;
tokentype    ObjTkn;
objdesctype *ObjDesc      = NullPtr;
indextype    Index        = 0;
statustype   DumpStatus   = Env_Normal;
AttrTkn.DbId = RenvId;
ObjTkn.DbId  = RenvId;
if (TmGetCoreDb    (Token,    McStat,   &CoreDb))
if (OaGetObject    (Token,    McStat,   &Object))
OaUpdateObject (Token,    McStat);
if (!Normal(*Status))
{
sprintf (Msg, "   Object[%2u:%4u] Corrupted ... \n",
Token->DbId, Token->Handle);
TraceMsg (0, Msg);
if (HmPutObjectAddr (CoreDb, Token->Handle,  NullPtr, Dump_Status))
if (OmGetObject     (Token,  Dump_Status,   &Index,       &Object))
OaDumpObject    (0,      Token,                   Dump_Status);
if (Normal(DumpStatus))
*Status = Env_Normal;
}
if (Normal(*Status))
if (HmGetLocalObjNum (CoreDb,                               Token->Handle,
McStat,                              &LocalObjNum))
if (MemGetAddr       (CoreDb->ObjHdrDir,       (indextype  )LocalObjNum,
McStat,                  (addrtype *)&ObjHdr))
if (MemGetObjNum     (CoreDb->LocalAttrNumMap, (indextype  )SubClassAttr,
McStat,                              &LocalAttrNum))
if (!LocalAttrNum)
{
sprintf (Msg, " Object[%2u:%4u] does not have Attribute %3u\n",
Token->DbId, Token->Handle, SubClassAttr);
TraceMsg (0, Msg);
*Status = Oa_DbNoThisAttr;
}
if (Normal(*Status))
if (MemGetObjNum     (ObjHdr->FieldNumMap,     (indextype )LocalAttrNum,
McStat,                             &FieldNum))
if (FieldNum)
if (EnvFetchAttrOffset
(Token,  SubClassAttr,    ObjHdr,     FieldNum,
McStat,                             &SubOffset))
if (*Status == Env_AttrNotInDbmsClassDef)
*Status  = Oa_AttrNotInDbmsClassDef;
if (Normal(*Status))
if (EnvFetchAttrHandle
(SubClassAttr,     McStat,    &AttrTkn.Handle))
if (OaGetObject      (&AttrTkn,         McStat, (addrtype *)&AttrDesc))
ObjTkn.Handle  = AttrDesc->BuildDesc;
if (Normal(*Status))
if (OaGetObject      (&ObjTkn,          McStat, (addrtype *)&ObjDesc))
if (MemGetObjNum     (CoreDb->LocalObjNumMap,       ObjDesc->ObjNum,
McStat,                              &LocalObjNum))
if (MemGetAddr       (CoreDb->ObjHdrDir,                    LocalObjNum,
McStat,                  (addrtype *)&SubObjHdr))
MemGetObjNum     (CoreDb->LocalAttrNumMap, (indextype  )AttrNum,
McStat,                              &LocalAttrNum);
if (Normal(*Status))
if (!LocalAttrNum)
{
sprintf (Msg, " Object[%2u:%4u] SubClass %3u does not have Attr %u\n",
Token->DbId, Token->Handle, SubClassAttr, AttrNum);
TraceMsg (0, Msg);
*Status = Oa_DbNoThisAttr;
}
if (Normal(*Status))
if (MemGetSize    (CoreDb->LocalAttrSizeTbl,  (indextype )LocalAttrNum,
McStat,                    &Size))
if (MemGetObjNum  (SubObjHdr->FieldNumMap,    (indextype )LocalAttrNum,
McStat,                    (numtype *)&FieldNum))
if (EnvFetchAttrOffset (Token,   AttrNum,   SubObjHdr,    FieldNum,
McStat,                          &Offset))
if (*Status == Env_AttrNotInDbmsClassDef)
*Status  = Oa_AttrNotInDbmsClassDef;
if (Normal(*Status))
if (FieldNum)
{
BytePtr  = (addrtype )((char *)Object + SubOffset + Offset);
if (Size == 2
&&  sizeof (booleantype) == 1)
{
if (EnvFetchAttrHandle (AttrNum,  McStat,     &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn, McStat, (addrtype *)&AttrDesc))
if (AttrDesc->TypeType == aEnum)
Size = 1;
}
MoveBytes (Value, BytePtr, Size);
} else
*Status = Oa_ObjNoThisField;
if (!Normal(*Status) || DeBug || OaBug) {
if (sprintf (Msg, "   PUT To Embedded Obj=%3u Attr(%3u) size %4d ::= ",
SubClassObj,AttrNum, Size))
if (TraceMsg   (0, Msg))
if (TraceBytes (0, Value, Size))
if (TraceMsg   (0, "\n"))
if (sprintf (Msg, "   TO  object[%2u:%4u](%3u)  offset %3u @%x\n",
Token->DbId, Token->Handle, LocalObjNum,
Offset, BytePtr))
TraceMsg   (0, Msg);
}
if (!Normal(*Status))
OaDumpObject (0, Token, Dump_Status);
TRACK(TrackBak,"OaPutToEmbedded\n");
return (STAT);
}
boolean    OaPutField    (tokentype    *Token,     fieldstruc   *FS,
addrtype      Value,     ft F,lt Z,zz *Status)
{
dbheader    *CoreDb       = NullPtr;
addrtype     Object       = NullPtr;
numtype      ObjNum       = 0;
sizetype     Offset       = 0;
sizetype     Size         = 0;
addrtype     BytePtr      = NullPtr;
fieldspec   *FieldTkns    = FS->FieldTkns;
indextype    SubLevel     = FS->SubLevel;
if (TmGetCoreDb       (Token,    McStat,   &CoreDb))
if (OaGetObject       (Token,    McStat,   &Object))
OaUpdateObject    (Token,    McStat);
if (!Normal(*Status))
{
sprintf (Msg, "***ERROR... Object[%2u:%4u] Corrupted ... \n",
Token->DbId, Token->Handle);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (EnvFetchObjNum       (Token,       McStat,     &ObjNum))
if (Env_FetchFieldOffset
(Token,    FieldTkns,      SubLevel,
McStat,   &Size, &Offset))
{
BytePtr  = (addrtype )((char *)Object    + Offset);
MoveBytes             (Value,       BytePtr,               Size);
}
if (!Normal(*Status) || DeBug || OaBug || ClassBug)
{
if (sprintf (Msg, "   PUT Field :: AttrId=%4u; size (%4d) ::= ",
FieldTkns[SubLevel-1].AttrId, Size))
if (TraceMsg   (0, Msg))
if (TraceBytes (0, Value, Size))
if (TraceMsg   (0, "\n"))
if (sprintf (Msg, "   TO  object[%2u:%4u] offset %3u @%x\n",
Token->DbId, Token->Handle, Offset, BytePtr))
TraceMsg   (0, Msg);
}
TRACK(TrackBak,"OaPutField\n");
return (STAT);
}
boolean    OaGet         (boolean       CppType,    tokentype  *Token,
addrtype      ObjectAddr, numtype     EnvAttrNum,
ft F,lt Z,zz *Status,     addrtype    AttrValue)
{
num          LocalAttrNum = 0;
num          LocalObjNum  = 0;
num          FieldNum     = 0;
bytessize    Size         = 0;
bytessize    Offset       = 0;
addrtype     BytePtr      = NullPtr;
objheader   *ObjHdr       = NullPtr;
addrtype     Object       = ObjectAddr;
dbheader    *CoreDb       = NullPtr;
tokentype    AttrTkn;
attrdesctype *AttrDesc    = NullPtr;
numtype      MemLoc       = 0;
char        *StringPtr    = NullPtr;
indextype    Index        = 0;
statustype   DumpStatus   = Env_Normal;
if (TmIsValid      (Token,   McStat)  == False)
{
sprintf (Msg,
"\n ***ERROR*** OaGet :: Object[%2u:%4u]. Token is Invalid!\n",
Token->DbId, Token->Handle);
TraceMsg (0,  Msg);
*Status  = Oa_ObjectHasBeenDeleted;
}
AttrTkn.DbId     = RenvId;
if (Normal(*Status))
if (CppType)
Token->Handle = ((objtype *)Object)->Handle;
else
OaGetObject   (Token,  McStat, &Object);
if (Normal(*Status))
if (TmGetCoreDb      (Token,     McStat,                   &CoreDb))
if (HmGetObjectMemLoc
(CoreDb,    Token->Handle,  McStat,   &MemLoc))
if (HmGetLocalObjNum (CoreDb,                               Token->Handle,
McStat,                              &LocalObjNum))
if (MemGetAddr       (CoreDb->ObjHdrDir,        (indextype )LocalObjNum,
McStat,                  (addrtype *)&ObjHdr))
if (EnvAttrNum     <= CoreDb->LastEnvAttrCount)
{
MemGetObjNum     (CoreDb->LocalAttrNumMap,  (indextype )EnvAttrNum,
McStat,                   &LocalAttrNum);
} else {
MemPutStackPtr   (CoreDb->LocalAttrNumMap,  CoreDb0->LastEnvAttrCount,
McStat);
LocalAttrNum  = 0;
CoreDb->LastEnvAttrCount = CoreDb0->LastEnvAttrCount;
}
if (Normal(*Status))
if (!LocalAttrNum)
*Status = Oa_ObjNoThisAttr;
if (Normal(*Status))
if (MemGetSize       (CoreDb->LocalAttrSizeTbl,(indextype )LocalAttrNum,
McStat,                             &Size))
if (MemGetObjNum     (ObjHdr->FieldNumMap,     (indextype )LocalAttrNum,
McStat,                      (num *)&FieldNum))
if (Normal(*Status))
if (!FieldNum)
*Status = Oa_AttrNotPresent;
if (Normal(*Status))
if (EnvFetchAttrOffset
(Token,       EnvAttrNum,   ObjHdr,   FieldNum,
McStat,                             &Offset))
if (*Status == Env_AttrNotInDbmsClassDef)
*Status  = Oa_AttrNotInDbmsClassDef;
if (Normal(*Status))
if (EnvFetchAttrHandle
(EnvAttrNum,  McStat,                &AttrTkn.Handle))
if (OaGetObject      (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
if (Token->DbId > RenvId)
if (MemLoc)
{
if (AttrDesc->AttrType         == aTknRefAttr)
Size      += sizeof(addrtype);
else if (AttrDesc->AttrType    == aVarrayAttr)
Size       = sizeof (varraytype);
else if (AttrDesc->AttrType    == aChunkAttr)
Size       = sizeof (vchunktype);
}
if (Normal(*Status))
{
BytePtr  = (addrtype )((char *)Object + Offset);
if (Size                 == 2
&&  sizeof (booleantype) == 1)
Size  = 1;
MoveBytes   (BytePtr, AttrValue, Size);
if (Token->DbId > RenvId)
if (!MemLoc)
if (AttrDesc->TypeType        == aDbmsString)
{
Index       = *(indextype *)BytePtr;
StringPtr   = NullPtr;
OaGetString (Token->DbId,  ObjHdr,                Index,
McStat,                    (char **)&StringPtr);
MoveBytes   ((addrtype )&StringPtr, (addrtype )AttrValue,
sizeof (addrtype ));
}
}
if (!Normal(*Status) || DeBug  || OaBug)
{
if (sprintf (Msg,
"\n  OA GET Attr[%3u](%3u) Field=%2u size %4u ::=",
EnvAttrNum, LocalAttrNum, FieldNum, Size))
if (TraceMsg (0, Msg))
if (TraceBytes (0, AttrValue, Size))
if (TraceMsg (0, "\n"))
if (sprintf (Msg, "   FROM Object[%2u :%4u](%3u)  @ %x +%3u== %x\n",
Token->DbId, Token->Handle, LocalObjNum,
Object, Offset, BytePtr))
TraceMsg (0, Msg);
}
if (*Status != Env_Normal)
OaDumpObject (0, Token, Dump_Status);
TRACK(TrackBak,"OaGet\n");
return (STAT);
}
boolean    OaGetString    (idtype        DbId,    objheader    *ObjHdr,
indextype     StrIndex,
ft F,lt Z,zz *Status,  char        **String)
{
dbheader    *CoreDb       = CoreDbs[DbId];
*String  = NullPtr;
if (!ObjHdr->TextChunk)
if ( ObjHdr->TextChunkVbn)
FileInChunk  (&ObjHdr->TextChunk,  &CoreDb->BlkHdr,
False,
McStat,              &ObjHdr->TextChunkVbn);
if (Normal(*Status))
if (ObjHdr->TextChunk)
MemGetString (ObjHdr->TextChunk,    StrIndex,
McStat,               String);
TRACK(TrackBak,"OaGetString\n");
return (STAT);
}
boolean    OaGetField    (tokentype    *Token,     fieldstruc   *FS,
ft F,lt Z,zz *Status,    addrtype      Value)
{
dbheader    *CoreDb       = NullPtr;
addrtype     Object       = NullPtr;
numtype      ObjNum       = 0;
numtype      LocalObjNum  = 0;
objheader   *ObjHdr       = NullPtr;
sizetype     Offset       = 0;
sizetype     Size         = 0;
addrtype     BytePtr      = NullPtr;
statustype   DumpStatus   = Env_Normal;
int          i            = 0;
indextype    Index        = 0;
numtype      MemLoc       = 0;
attrtype     AttrType     = aNonTypeAttr;
typetype     FieldType    = aNonTypeType;
char        *StringPtr    = NullPtr;
fieldspec   *FieldTkns    = FS->FieldTkns;
indextype    SubLevel     = FS->SubLevel;
if (OaBug || DeBug)
{
sprintf (Msg, "   OaGetField:: From Object[%2u:%4u]; SubLevel=%4u\n",
Token->DbId, Token->Handle, SubLevel);
TraceMsg (0, Msg);
for (i=0; i < SubLevel; i++)
{
sprintf  (Msg, " Field %4u. AttrId=%4u; Index=%4u.\n",
i, FieldTkns[i].AttrId,  FieldTkns[i].Index);
TraceMsg (0, Msg);
}
}
if (TmGetCoreDb       (Token,    McStat,   &CoreDb))
OaGetObject       (Token,    McStat,   &Object);
if (!Normal(*Status))
{
sprintf (Msg, "***ERROR... Object[%2u:%4u] Corrupted ... \n",
Token->DbId, Token->Handle);
TraceMsg (0, Msg);
if (HmPutObjectAddr (CoreDb, Token->Handle,  NullPtr, Dump_Status))
if (OmGetObject     (Token,  Dump_Status,   &Index,       &Object))
OaDumpObject    (0,      Token,                   Dump_Status);
if (Normal(DumpStatus))
*Status = Env_Normal;
}
if (Normal(*Status))
if (HmGetObjectMemLoc
(CoreDb,    Token->Handle,  McStat,   &MemLoc))
if (HmGetObjNum      (CoreDb,    Token->Handle,  McStat,   &ObjNum))
if (Env_FetchFieldOffset
(Token,    FieldTkns,      SubLevel,
McStat,   &Size, &Offset))
if (Token->DbId > RenvId)
if (MemLoc)
if (AttrType   == aTknRefAttr)
Offset      += sizeof(addrtype);
if (Normal(*Status))
{
BytePtr  = (addrtype )((char *)Object    + Offset);
MoveBytes            (BytePtr, Value,      Size);
if (Token->DbId > RenvId)
if (!MemLoc)
if (FieldType  == aDbmsString)
if (HmGetLocalObjNum
(CoreDb,                               Token->Handle,
McStat,                              &LocalObjNum))
if (MemGetAddr    (CoreDb->ObjHdrDir,        (indextype )LocalObjNum,
McStat,                  (addrtype *)&ObjHdr))
{
OaGetString (Token->DbId,  ObjHdr, *(longtype  *)BytePtr,
McStat,                    (char **)&StringPtr);
MoveBytes   (StringPtr, (addrtype )Value,  sizeof (addrtype ));
}
}
if (!Normal(*Status) || DeBug || OaBug)
{
if (sprintf (Msg, "   PUT Field :: AttrId=%4u; size (%4d) ::= ",
FieldTkns[SubLevel-1].AttrId, Size))
if (TraceMsg   (0, Msg))
if (TraceBytes (0, Value, Size))
if (TraceMsg   (0, "\n"))
if (sprintf (Msg, "   TO  object[%2u:%4u] offset %3u @%x\n",
Token->DbId, Token->Handle, Offset, BytePtr))
TraceMsg   (0, Msg);
}
TRACK(TrackBak,"OaGetField\n");
return (STAT);
}
boolean    OaChkForAttr  (tokentype    *Token,    numtype     EnvAttrNum,
ft F,lt Z,zz *Status,
sizetype     *Size,     sizetype   *Offset)
{
dbheader    *CoreDb       = NullPtr;
objheader   *ObjHdr       = NullPtr;
numtype      LocalAttrNum = 0;
numtype      LocalObjNum  = 0;
numtype      FieldNum     = 0;
if (TmGetCoreDb      (Token,       McStat,      &CoreDb))
if (HmGetLocalObjNum (CoreDb,                    Token->Handle,
McStat,                   &LocalObjNum))
if (MemGetAddr       (CoreDb->ObjHdrDir,        (indextype )LocalObjNum,
McStat,                   (addrtype *)&ObjHdr))
MemGetObjNum     (CoreDb->LocalAttrNumMap,  (indextype )EnvAttrNum,
McStat,                   &LocalAttrNum);
if (!LocalAttrNum)
*Status = Oa_AttrNotPresent;
if (Normal(*Status))
if (MemGetSize    (CoreDb->LocalAttrSizeTbl,    (indextype )LocalAttrNum,
McStat,                      (bytessize *)Size))
if (MemGetObjNum  (ObjHdr->FieldNumMap,         (indextype )LocalAttrNum,
McStat,                      &FieldNum))
if (!FieldNum)
*Status = Oa_AttrNotPresent;
if (Normal(*Status))
MemGetSize    (ObjHdr->FieldOffsetDir,      (indextype )FieldNum,
McStat,                      (bytessize *)Offset);
if (ClassBug)
if (sprintf (Msg, "  OA CHK For Attr[%3u] local(%3u) size %u offset %u\n",
EnvAttrNum, LocalAttrNum, *Size, *Offset))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "   IN Object[%2u :%4u] ::  Status= %3u\n",
Token->DbId, Token->Handle, *Status))
TraceMsg (0, Msg);
TRACK(TrackBak,"OaChkForAttr\n");
return (STAT);
}
boolean    OaGetAttrSize  (tokentype    *Anchor,     numtype   EnvAttrNum,
ft F,lt Z,zz *Status,     addrtype  AttrSize)
{
num          LocalAttrNum = 0;
dbheader    *CoreDb       = NullPtr;
if (TmGetCoreDb   (Anchor,       McStat,       &CoreDb))
if (MemGetObjNum  (CoreDb->LocalAttrNumMap,    (indextype )EnvAttrNum,
McStat,                     &LocalAttrNum))
if (MemGetSize    (CoreDb->LocalAttrSizeTbl,   (indextype )LocalAttrNum,
McStat,                     (word *)AttrSize))
if (!Normal(*Status) || DeBug)
{
sprintf (Msg, "   GET AttrSize[%3u] (%3u) ::=  %u \n",
EnvAttrNum, LocalAttrNum,  *(num *)AttrSize);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"OaGetAttrSize\n");
return (STAT);
}
boolean    OaCompare     (boolean       CppType,    tokentype  *Token,
addrtype      Object,     numtype     EnvAttrNum,
addrtype      CompValue,  ptr_cmp     CmpCode,
ft F,lt Z,zz *Status)
{
static unsigned char      Value[MAXSTRING];
static addrtype           ValuePtr        =  (addrtype )&Value[0];
int          i               = 0;
bytessize    KeySize         = 0;
bytetype    *ByteValue       = NULL;
short       *IdValue         = NULL;
lt64        *IntValue        = NULL;
#ifdef LARGE
tokentype   *TknValue        = NULL;
tokentype   *CompTkn         = NULL;
#endif
tokentype     AttrTkn;
attrdesctype *AttrDesc       = NullPtr;
if (TmIsValid      (Token,   McStat)  == False)
{
sprintf (Msg,
"\n ***ERROR*** OaCompare On Object[%2u:%4u]. Token is Invalid!\n",
Token->DbId, Token->Handle);
TraceMsg (0,  Msg);
*Status  = Oa_ObjectHasBeenDeleted;
}
AttrTkn.DbId     = RenvId;
memset (Value,     NULL, MAXNAME);
if (CmpCode != NullPtr)
{
TraceMsg (0, "     COMP Func Not Implemented\n");
*Status = Err_NotImplemented;
}
if (Normal(*Status))
if (EnvFetchAttrHandle (EnvAttrNum,  McStat,                &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,    (addrtype *)&AttrDesc))
OaGetAttrSize      (Token,       EnvAttrNum,
McStat,                 (addrtype  )&KeySize);
if (Normal(*Status))
if (OaGet          (CppType,    Token,    Object,           EnvAttrNum,
McStat,     ValuePtr))
if (AttrDesc->TypeType  == aString)
{
i = Ut_CompareString ((char *)CompValue, (char *)ValuePtr);
} else switch (KeySize) {
case sizeof (bytetype  )   :
ByteValue    = (bytetype *)ValuePtr;
if (*(bytetype *)CompValue < *ByteValue)
i = -1;
else if (*(bytetype *)CompValue > *ByteValue)
i = 1;
break;
case sizeof (short )     :
IdValue    = (short *)ValuePtr;
if (*(short *)CompValue < *IdValue)
i = -1;
else if (*(short *)CompValue > *IdValue)
i = 1;
break;
case sizeof (lt64  ) :
IntValue    = (lt64 *)ValuePtr;
if (*(lt64 *)CompValue < *IntValue)
i = -1;
else if (*(lt64 *)CompValue > *IntValue)
i = 1;
break;
#ifdef LARGE
case sizeof (tokentype )  :
TknValue    = (tokentype *)ValuePtr;
CompTkn     = (tokentype *)CompValue;
if (CompTkn->Handle < TknValue->Handle)
i = -1;
else if (CompTkn->Handle > TknValue->Handle)
i = 1;
if (i == 0
&& CompTkn->DbId  != TknValue->DbId)
i = -1;
break;
#endif
default                   :
if (KeySize <= sizeof (tokentype ))
i = memcmp  ((char *)CompValue,
(char *)ValuePtr, (size_t )KeySize);
else
i = strncmp ((char *)CompValue,
(char *)ValuePtr, (size_t )KeySize);
}
if (Normal (*Status))
if (!i)
{
if (DeBug || OaBug)
if (sprintf (Msg,
"     COMPARED on Object [%2u:%4u] =",  Token->DbId, Token->Handle))
if (TraceMsg (0, Msg))
if (AttrDesc->TypeType  == aString)
{
sprintf (Msg, " %s\n", Value);
TraceMsg   (0, Msg);
} else {
TraceBytes (0, ValuePtr, KeySize);
TraceMsg   (0, "\n");
}
} else if (i < 0) {
*Status = Oa_LessThen;
} else {
*Status = Oa_GtrThen;
}
if (DeBug || SetBug || OaBug)
{
if (KeySize            <= sizeof (tokentype )
&&  AttrDesc->TypeType != aString)
{
sprintf    (Msg, "     OaCompare [%2u:%4u]  Value=",
Token->DbId, Token->Handle);
TraceMsg   (0,   Msg);
TraceBytes (0,   ValuePtr, KeySize);
sprintf    (Msg, "; i = %d;",       i);
TraceMsg   (0, Msg);
TraceMsg   (0, " CompValue =");
TraceBytes (0,   CompValue, KeySize);
TraceMsg   (0, "\n");
} else {
sprintf (Msg, "     OaCompare Object[%2u:%4u]  =<%21s>; i = %d\n",
Token->DbId, Token->Handle, Value, i);
TraceMsg (0,  Msg);
sprintf (Msg, "                     CompValue  =<%21s>\n",
CompValue);
TraceMsg (0,  Msg);
}
}
TRACK(TrackBak,"OaCompare\n");
return (STAT);
}
boolean    OaCompareField
(boolean       CppType,    tokentype  *Token,
addrtype      Object,     fieldstruc *FS,
addrtype      CompValue,  ptr_cmp     CmpCode,
ft F,lt Z,zz *Status)
{
static unsigned char      Value[MAXSTRING];
static addrtype           ValuePtr        =  (addrtype )&Value[0];
int          i               = 0;
bytessize    KeySize         = 0;
bytetype    *ByteValue       = NULL;
short       *IdValue         = NULL;
lt64        *IntValue        = NULL;
numtype      EnvAttrNum      = FS->FieldTkns[FS->SubLevel-1].AttrId;
#ifdef LARGE
tokentype   *TknValue        = NULL;
tokentype   *CompTkn         = NULL;
#endif
memset (Value,     NULL, MAXNAME);
if (CmpCode != NullPtr)
{
TraceMsg (0, "     COMP Func Not Implemented\n");
*Status = Err_NotImplemented;
}
if (OaGetAttrSize  (Token, EnvAttrNum, McStat,   (addrtype )&KeySize))
if (KeySize > MAXNAME)
*Status = Err_NotImplemented;
if (Normal(*Status))
if (OaGetField     (Token,    FS,   McStat,     ValuePtr))
switch (KeySize)
{
case sizeof (bytetype  )   :
ByteValue    = (bytetype *)ValuePtr;
if (*(bytetype *)CompValue < *ByteValue)
i = -1;
else if (*(bytetype *)CompValue > *ByteValue)
i = 1;
break;
case sizeof (short )     :
IdValue    = (short *)ValuePtr;
if (*(short *)CompValue < *IdValue)
i = -1;
else if (*(short *)CompValue > *IdValue)
i = 1;
break;
case sizeof (lt64  ) :
IntValue    = (lt64 *)ValuePtr;
if (*(lt64 *)CompValue < *IntValue)
i = -1;
else if (*(lt64 *)CompValue > *IntValue)
i = 1;
break;
#ifdef LARGE
case sizeof (tokentype )  :
TknValue    = (tokentype *)ValuePtr;
CompTkn     = (tokentype *)CompValue;
if (CompTkn->Handle < TknValue->Handle)
i = -1;
else if (CompTkn->Handle > TknValue->Handle)
i = 1;
if (i == 0
&& CompTkn->DbId  != TknValue->DbId)
i = -1;
break;
#endif
default                   :
if (KeySize <= sizeof (tokentype ))
i = memcmp  ((char *)CompValue,
(char *)ValuePtr, (size_t )KeySize);
else
i = strncmp ((char *)CompValue,
(char *)ValuePtr, (size_t )KeySize);
}
if (Normal (*Status))
if (!i)
{
if (DeBug || OaBug)
if (sprintf (Msg,
"     COMPARED on Object [%2u:%4u] =",  Token->DbId, Token->Handle))
if (TraceMsg (0, Msg))
if (TraceBytes (0, ValuePtr, KeySize))
TraceMsg (0, "\n");
} else if (i < 0) {
*Status = Oa_LessThen;
} else {
*Status = Oa_GtrThen;
}
if (DeBug || SetBug || OaBug)
{
if (KeySize <= sizeof (tokentype ))
{
sprintf    (Msg, "     OaCompare Object[%2u:%4u]  Value=",
Token->DbId, Token->Handle);
TraceMsg   (0,   Msg);
TraceBytes (0,   ValuePtr, KeySize);
sprintf    (Msg, "; i = %d  ;",       i);
TraceMsg   (0, Msg);
sprintf    (Msg, " CompValue = %d  ;",  (int *)CompValue);
TraceMsg   (0, Msg);
} else {
sprintf (Msg, "     OaCompare Object[%2u:%4u]  = %s; i = %d\n",
Token->DbId, Token->Handle, Value, i);
TraceMsg (0,  Msg);
}
}
TRACK(TrackBak,"OaCompareField\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\oadmp.c*/

#define OADMP
#ifndef INLINE_OMIDEFS
#else
#define        ObjDesc_ObjNum         (objnumtype )1
#define        ReferenceType_Hndl     (handletype )190
#define        EnumValues_Hndl        (handletype )665
#endif
#define MemGetVbn           Mem_GetWord
#define MemPutVbn           Mem_PutWord
#define MemGetChunkNum      Mem_GetWord
#define MemPutChunkNum      Mem_PutWord
#define MemGetLocalObjNum   Mem_GetWord
#define MemPutLocalObjNum   Mem_PutWord
#define MemPushSize         Mem_PushWord
#define MemGetSize          Mem_GetWord
#define MemGetAttrSize      Mem_GetWord
#define MemPushObjNum       Mem_PushWord
#define MemPutObjNum        Mem_PutWord
#define MemGetObjNum        Mem_GetWord
#define MemPushObjHdr       Mem_PushAddr
#define MemPutOffset        Mem_PutWord
#define MemGetOffset        Mem_GetWord
#define MemGetAttrNum       Mem_GetWord
#define MemGetObjHdr        Mem_GetAddr






boolean OaDumpEmbedded
(int           TraceSwi,  numtype       MemLoc,
tokentype    *Token,     addrtype      Object,
handletype    BuildDesc, numtype       NumMaps,
sizetype      MapOffset, ft F,lt Z,zz *Status);
char        *booleanValue[2] = { "False", "True" };
boolean      LinkSwi = False;
boolean    OaDumpObjHdr (int TraceSwi,  tokentype     *Anchor,
num ObjNum,    ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"OaDumpObjHdr\n");
return (STAT);
}
boolean    OaDumpObjHndls (tokentype    *Anchor,  numtype      ObjNum,
ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"OaDumpObjHndls\n");
return (STAT);
}
boolean    OaDumpObject (int           TraceSwi,  tokentype *Token,
ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"OaDumpObject\n");
return (STAT);
}
boolean    OaDumpEmbedded (int           TraceSwi,  numtype       MemLoc,
tokentype    *Token,     addrtype      Object,
handletype    BuildDesc, numtype       NumMaps,
sizetype      MapOffset, ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"OaDumpEmbedded\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\obj01.c*/

#define  OBJ01_C


boolean Object_Create
(tokentype    *Anchor,    numtype       ClassId,
ft F,lt Z,zz *Status,    tokentype    *Token)
{
if (ImageDbCreate (Anchor,  ClassId,   McStat,   Token))
{
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, "  Object Createed [%3u:%8u]...\n",
Token->DbId, Token->Handle))
TraceMsg (0, Msg);
} else
TraceMsg (0, " ***ERROR @ Object_DbCreate\n");
TRACK(TrackBak,"Object_Create\n");
return (STAT);
}
void    Object_Dump       (tokentype    *Token)
{
if (ClassBug || DeBug || OaBug)
TraceMsg (0, "\n Object_DbDump \n");
ImageDumpObject   (Token);
}
numtype Object_IsA       (tokentype    *Token,     ft F,lt Z,zz *Status)
{
numtype    ClassNum     = 0;
KernelWhatAmI           (Token,     McStat,     &ClassNum);
STAT;
return (ClassNum);
}
boolean Object_IsKindOf  (tokentype    *Token,     numtype       ClassId,
ft F,lt Z,zz *Status)
{
KernelIamA              (Token,     ClassId,      McStat);
if (*Status == Kernl_IamNot)
{
*Status  = Env_Normal;
return (False);
}
TRACK(TrackBak,"Object_IsKindOf\n");
return(STAT);
}
boolean Object_Delete    (tokentype    *Token,     ft F,lt Z,zz *Status)
{
ImageDeleteObject (Token, C_Apl,   McStat);
if (Normal(*Status))
{
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, "  Object Deleted \n"))
TraceMsg (0, Msg);
} else {
TraceMsg (0, " ***ERROR @ Image01_:DbDelete\n");
sprintf (Msg, "\n    Object_DbDelete [%3u:%8u]...\n",
Token->DbId, Token->Handle);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"Object_Delete\n");
return (STAT);
}
boolean Object_NewImage  (tokentype    *Anchor,   numtype       ClassId,
ft F,lt Z,zz *Status,
tokentype    *Token,    addrtype     *Image)
{
*Image           = (addrtype )NullPtr;
ImageNewObject    (Anchor,   ClassId, McStat,   Token,   Image);
TRACK(TrackBak,"Object_NewImage\n");
return (STAT);
}
boolean Object_GetImage  (tokentype    *Token,
ft F,lt Z,zz *Status,   addrtype      *Image)
{
*Image           = (addrtype )NullPtr;
ImageGetObject    (Token,   McStat,   Image);
TRACK(TrackBak,"Object_GetImage\n");
return (STAT);
}
boolean Object_ImageIsActive
(tokentype    *Token,     ft F,lt Z,zz *Status)
{
addrtype      This  = NullPtr;
if (Env_IsValidToken       (Token,    McStat))
return (Image_IsActive  (Token,    McStat,    &This));
TRACK(TrackBak,"Object_ImageIsActive\n");
return (STAT);
}
boolean Object_PutImage  (tokentype    *Token,     ft F,lt Z,zz *Status)
{
addrtype Object  = NullPtr;
boolean  Release = True;
boolean  FreeMem = True;
if (ImageGetObject (Token, McStat, &Object))
ImageReFaxToDb (C_Apl,  Token,   Object,  Release,  FreeMem,
McStat);
if (!Normal(*Status))
if (sprintf (Msg,  " ***ERROR @ Object_DbPut @%6x TO [%3u:%6u]\n",
Object, Token->DbId, Token->Handle))
TraceMsg (0,    Msg);
TRACK(TrackBak,"Object_PutImage\n");
return (STAT);
}
boolean Object_FreeImage (tokentype    *Token,     ft F,lt Z,zz *Status)
{
ImageFreeDbObject (C_Apl, Token, McStat);
TRACK(TrackBak,"Object_FreeImage\n");
return (STAT);
}
boolean Object_CommitImage
(tokentype    *Token,     boolean       Release,
ft F,lt Z,zz *Status)
{
addrtype   NullAddr   = NullPtr;
ImageCommitObject  (C_Apl, Token, &NullAddr,  Release,  McStat);
TRACK(TrackBak,"Object_CommitImage\n");
return (STAT);
}
void    Image_DumpPseudo
(tokentype    *Anchor,    numtype       ClassId,
addrtype      Pseudo)
{
ImageDumpPseudo    (Anchor->DbId,  ClassId,  Pseudo);
return;
}
boolean Attr_ValuePut    (tokentype    *Token,     numtype       AttrId,
addrtype      Value,     ft F,lt Z,zz *Status)
{
ImagePutAttrValue  (Token,  AttrId,  Value,  McStat);
TRACK(TrackBak,"Attr_ValuePut\n");
return (STAT);
}
boolean Attr_ValueGet    (tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,    addrtype      Value)
{
ImageGetAttrValue      (Token,       AttrId,    McStat,      Value);
TRACK(TrackBak,"Attr_ValueGet\n");
return (STAT);
}
int     Attr_ValueCompare
(tokentype    *Token,     numtype       AttrId,
addrtype      CompValue, ptr_cmp       CmpCode,
ft F,lt Z,zz *Status)
{
int     i = 0;
i = ImageCompareAttr    (Token,    AttrId,   CompValue,    CmpCode,
McStat);
TRACK(TrackBak,"Attr_ValueCompare\n");
STAT;
return (i);
}
boolean Attr_ObjTknPut   (tokentype    *Token,     numtype       AttrId,
tokentype    *ObjTkn,    ft F,lt Z,zz *Status)
{
ImagePutObjTkn (Token,  AttrId,  ObjTkn,     McStat);
TRACK(TrackBak,"Attr_ObjTknPut\n");
return (STAT);
}
boolean Attr_ObjTknGet   (tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,    tokentype    *ObjTkn)
{
ImageGetObjTkn (Token,  AttrId,  McStat,  ObjTkn);
TRACK(TrackBak,"Attr_ObjTknGet\n");
return (STAT);
}
boolean Attr_RefTknPut   (tokentype    *Token,     numtype       AttrId,
tokentype    *RefTkn,    ft F,lt Z,zz *Status)
{
RefObj     RefObjVal;
RefObjVal.ObjAddr   = NullPtr;
RefObjVal.ObjTkn    = *RefTkn;
ImageRefTknPut (Token,  AttrId,  &RefObjVal,  McStat);
TRACK(TrackBak,"Attr_RefTknPut\n");
return (STAT);
}
boolean Attr_TokenToRef  (tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,    addrtype     *RefObject)
{
*RefObject   = NullPtr;
ImageTokenToRef  (Token,   AttrId,   McStat,  RefObject);
TRACK(TrackBak,"Attr_TokenToRef\n");
return (STAT);
}
boolean Attr_StringCreate
(tokentype    *Token,     numtype       AttrId,
sizetype      AllocSize,
ft F,lt Z,zz *Status,    cstring      *String)
{
ImageNewString      (Token,  AttrId,  AllocSize,  McStat,   String);
TRACK(TrackBak,"Attr_StringCreate\n");
return (STAT);
}
boolean Attr_StringGet   (tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,
boolean      *StrCpyIsA, cstring      *String)
{
ImageGetString      (Token,  AttrId,  McStat,   StrCpyIsA,  String);
TRACK(TrackBak,"Attr_StringGet\n");
return (STAT);
}
boolean Attr_StrCpyGet   (tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,    cstring      *String)
{
boolean      StrCpyIsA = False;
sizetype     StrSize   = 0;
cstring      StrValue  = NullPtr;
if (ImageGetString  (Token,  AttrId,  McStat,  &StrCpyIsA,   &StrValue))
if (StrCpyIsA     == False)
{
if ((StrSize    = strlen (StrValue)) > 0)
if (Core0_MoreCore   (++StrSize, McStat, (addrtype *)String))
strncpy (*(char **)String,  StrValue, StrSize);
} else
*String   = StrValue;
TRACK(TrackBak,"Attr_StrCpyGet\n");
return (STAT);
}
boolean Attr_StrCpyFree  (ft F,lt Z,zz *Status,    cstring      *String)
{
sizetype     StrSize   = 0;
if ((StrSize       = strlen (*String)) > 0)
Core0_FreeCoreSpace   ((addrtype *)String, ++StrSize, McStat);
TRACK(TrackBak,"Attr_StrCpyFree\n");
return (STAT);
}
boolean Attr_ArrayCreate (tokentype    *Token,     numtype       AttrId,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,    addrtype     *Array)
{
tokentype  VchunkTkn   = NullToken;
*Array   = NullPtr;
ImageCreateArray  (Token,    AttrId,      UnitCount,     UnitSize,
McStat,  &VchunkTkn,   Array);
TRACK(TrackBak,"Attr_ArrayCreate\n");
return (STAT);
}
boolean Attr_SubArrayCreate
(tokentype    *Token,
numtype       AttrId,    indextype     ArrayIndex,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,    addrtype     *Array)
{
tokentype  VchunkTkn   = NullToken;
*Array   = NullPtr;
ImageCreateSubArray  (Token,         AttrId,     ArrayIndex,
UnitCount,     UnitSize,
McStat,       &VchunkTkn,  Array);
TRACK(TrackBak,"Attr_SubArrayCreate\n");
return (STAT);
}
boolean Attr0_ArrayActivate
(tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,    numtype      *UnitCount,
sizetype     *UnitSize,  addrtype     *Varray)
{
tokentype  VchunkTkn   = NullToken;
if (Object_ImageIsActive             (Token,     McStat))
*Status    = Attr_ImageIsActive;
if (Normal(*Status))
if (ImageArrayActivate (Token,       AttrId,     McStat,
&VchunkTkn,  UnitCount,  UnitSize,  Varray))
if (VchunkTkn.Handle  == 0)
{
*Status = Attr_NullArray;
TraceMsg (0, " ***Error... @Attr_ArrayActivate :: Null Vchunk Token\n");
sprintf (Msg, "     for Token[%2u:%8u] AttrId= %4u\n",
Token->DbId, Token->Handle, AttrId);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"Attr0_ArrayActivate\n");
return (STAT);
}
boolean Attr0_ArrayDeActivate
(tokentype    *Token,     numtype       AttrId,
deletetype    Action,    ft F,lt Z,zz *Status)
{
if (Object_ImageIsActive             (Token,     McStat))
*Status    = Attr_ArrayIsActive;
else
ImageArrayDeActivate (Token,       AttrId,    McStat);
TRACK(TrackBak,"Attr0_ArrayDeActivate\n");
return (STAT);
}
boolean Attr_ArrayGetSize
(tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status,
numtype      *UnitCount, sizetype     *UnitSize)
{
ImageArrayGetSize  (Token,       AttrId,
McStat,      UnitCount,  UnitSize);
TRACK(TrackBak,"Attr_ArrayGetSize\n");
return (STAT);
}
boolean Attr_SubArrayGetSize
(tokentype    *Token,     numtype       AttrId,
indextype     Index,
ft F,lt Z,zz *Status,    numtype      *UnitCount)
{
ImageSubArrayGetSize  (Token,   AttrId,   Index,  McStat,  UnitCount);
TRACK(TrackBak,"Attr_SubArrayGetSize\n");
return (STAT);
}
boolean Attr_ArrayAssertSize
(tokentype    *Token,     numtype       AttrId,
numtype       UnitCount,
ft F,lt Z,zz *Status,    addrtype     *Varray)
{
ImageArrayAssertSize  (Token,   AttrId,   UnitCount,  McStat,  Varray);
TRACK(TrackBak,"Attr_ArrayAssertSize\n");
return (STAT);
}
boolean Attr_SubArrayAssertSize
(tokentype    *Token,     numtype       AttrId,
indextype     Index,     numtype       UnitCount,
ft F,lt Z,zz *Status,    addrtype     *Varray)
{
ImageSubArrayAssertSize  (Token,   AttrId,   Index,  UnitCount,
McStat,  Varray);
TRACK(TrackBak,"Attr_SubArrayAssertSize\n");
return (STAT);
}
boolean Attr_ArrayDelete (tokentype    *Token,     numtype       AttrId,
ft F,lt Z,zz *Status)
{
ImageArrayDelete      (Token,  AttrId,  McStat);
TRACK(TrackBak,"Attr_ArrayDelete\n");
return (STAT);
}
boolean Attr_SubArrayDelete
(tokentype    *Token,     numtype       AttrId,
indextype     Index,     ft F,lt Z,zz *Status)
{
ImageSubArrayDelete      (Token,  AttrId,  Index,  McStat);
TRACK(TrackBak,"Attr_ArrayDelete\n");
return (STAT);
}
boolean Field_ValuePut   (tokentype    *Token,     fieldstruc   *FieldStruc,
addrtype      Value,     ft F,lt Z,zz *Status)
{
ImagePutFieldValue (Token,  FieldStruc,  Value,   McStat);
TRACK(TrackBak,"Field_ValuePut\n");
return (STAT);
}
boolean Field_ValueGet   (tokentype    *Token,     fieldstruc   *FieldStruc,
ft F,lt Z,zz *Status,    addrtype      Value)
{
ImageGetFieldValue  (Token,  FieldStruc,   McStat,  Value);
TRACK(TrackBak,"Field_ValueGet\n");
return (STAT);
}
inttype Owner_SetIterateOn
(numtype       SetId,     tokentype    *OwnerTkn,
inttype       ItNum,     ft F,lt Z,zz *Status,
tokentype    *NodeTkn,   tokentype    *Token)
{
tokentype    CurrTkn = *NodeTkn;
if (ItNum == 0)
KernelFirstOf   ((handletype )SetId,  OwnerTkn, McStat, NodeTkn, Token);
else
KernelNextOf    ((handletype )SetId, &CurrTkn,  McStat, NodeTkn, Token);
if (Normal(*Status))
ItNum++;
if (*Status == Set_EndOfSet
||  *Status == Set_EmptySet)
*Status  = Iterate_EndOf;
STAT;
return (ItNum);
}
boolean Owner_SetFirstOf
(numtype       SetId,     tokentype    *OwnerTkn,
ft F,lt Z,zz *Status,    tokentype    *NodeTkn,
tokentype    *FirstTkn)
{
KernelFirstOf   (SetId,  OwnerTkn, McStat, NodeTkn, FirstTkn);
TRACK(TrackBak,"Owner_SetFirstOf\n");
return (STAT);
}
boolean Owner_KeySetFindIn
(numtype       SetId,     tokentype    *OwnerTkn,
addrtype      KeyValue,
ft F,lt Z,zz *Status,    tokentype    *MemberTkn)
{
KernelFindIn   (SetId,  OwnerTkn, KeyValue, McStat, MemberTkn);
TRACK(TrackBak,"Owner_KeySetFindIn\n");
return (STAT);
}
boolean Owner_KeySetFindInBy2aryKey
(numtype       SetId,     tokentype    *OwnerTkn,
addrtype      KeyValue,
ft F,lt Z,zz *Status,    tokentype    *MemberTkn)
{
*Status = Err_NotImplemented;
TRACK(TrackBak,"Owner_KeySetFindInBy2aryKey\n");
return (STAT);
}
boolean Member_SetOwnerOf
(numtype       SetId,     tokentype    *MemberTkn,
ft F,lt Z,zz *Status,    tokentype    *OwnerTkn)
{
KernelOwnerOf   (SetId,  MemberTkn, McStat, OwnerTkn);
TRACK(TrackBak,"Member_SetOwnerOf\n");
return (STAT);
}
boolean Member_SetNextOf
(numtype       SetId,     tokentype    *MemberTkn,
ft F,lt Z,zz *Status,
tokentype    *NodeTkn,   tokentype    *NextTkn)
{
tokentype   CurrNodeTkn  = NullToken;
KernelNextOf (SetId, &CurrNodeTkn,  McStat, NodeTkn, NextTkn);
TRACK(TrackBak,"Member_SetNextOf\n");
return (STAT);
}
boolean   Member_KeySetAddInto
(numtype       SetId,     tokentype     *Owner,
tokentype    *Member,    ft F,lt Z,zz *Status)
{
KernelAddInto      (SetId, Owner, Member, McStat);
TRACK(TrackBak,"Member_KeySetAddInto\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\odbm.c*/

#define DBM_C
#define ODBM
#ifdef NULL_TRACE_STRS
#define TraceStr8(StrNum)  TraceStr8[0]
static const char   *TraceStr8[1] = {"   ...ODBM... message\n" };
#else
#define TraceStr8(StrNum)  TraceStr[StrNum]
static const char *TraceStr8[54] =
{
"\n    OBJHDR[%3u] Obj[%3u](* %3u) obj's %4u rgn's %3u; In Core= %s\n",
"                                  ObjHdr committed  ...@Vbn[%4u]\n",
"    DB ObjHdrDir         : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj VbnDir           : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj FieldNumMap      : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj LocalAttrNumMap  : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj FieldOffsetDir   : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj ClassOffsetDir   : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj FieldRefDir      : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj FieldMapDir      : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj FieldArrayDir    : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj ExObjectTbl      : Chunk[%4u] AT Vbn[%3u]\n",
"    Grp RgnStatusDirVbn : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj RegionVbnDir     : Chunk[%4u] AT Vbn[%3u]\n",
"     RollOut Regions :: Current Rgn[%4u]... Chunk[%4u]; CoreAddr @%x\n",
"       CopyOUT RgnChunk        To SwapVbn[%4u]\n",
"       Region [%4u] @Vbn[%3u] Not Loaded.\n",
"       Chunk [%4u] @%x; SwapVbn[%4u];\n",
"       Copy From      SwapVbn[%4u];  To @%x\n",
"       Region[%4u]   Chunk  [%4u];  To Vbn[%4u]\n",
"       CopyIN CurrRgnChunk[%4u] from SwapVbn[%4u] To @%x\n",
" ***Error...ObjHdrNotExist for LocalObj=%3u MaxVbn=%u\n",
" ***Error...ObjHdrNotExist for LocalObj=%3u Vbn=%u\n",
"\n LOAD OBJHDR[%2u] from FilePtr = %x\n" ,
" DbmLoad CoreDb[%2u]::ObjHdr[%2u] has a NULL FilePtr" ,
"    OBJ HDR restored from FileVbn[%3u]\n",
"  CoreDb[%2u] ObjHdr[%2u] Loaded @ %x\n",
"    Obj ExObjectTbl     : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj RegionVbnDir    : Chunk[%4u] AT Vbn[%3u]\n",
"    Region StackPtr     : %4u\n",
"    OBJ RegionChunkDir  : Chunk[%4u] Transient. \n",
"    OBJ RegionSwapDir   : Chunk[%4u] Transient. \n",
"    Obj FieldNumMap      : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj LocalAttrNumMap  : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj FieldOffsetDir   : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj ClassOffsetDir   : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj FieldRefDir      : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj FieldMapDir     : Chunk[%4u] AT Vbn[%3u]\n",
"    Obj FieldArrayDir   : Chunk[%4u] AT Vbn[%3u]\n",
"    OBJ Region[%2u]  Chunk[%2u]  :  AT Vbn[%3u]\n",
"   DbmPairRgnObjects<FALSE>::    ObjSize=%3u RgnChunk[%2u] @%x * %4u\n",
" BAD PAIR Handles for RegionChunk[%3u] @%x count %4u\n",
"   OmPairRgnObjects<-->Handles; ObjSize=%3u RgnChunk[%2u] @%x * %4u\n",
"    pair Region[](%3u) Object @%x;  Handle= %u @%x\n " ,
" Outer Region Address Handle[%4u] In Region*%3u :: RegionIndex = %u\n",
" Region[%3u] Object[%3u] Handle= %4u\n",
" Null Handle[%4u] In Region*%3u :: RegionIndex = %u\n",
"\n   UnPairRgnObjects<FALSE>::    ObjSize=%3u RgnChunk[%2u] @%x * %4u\n",
" BAD UNPAIR Handles for RegionChunk[%3u] @%x count %4u\n",
"\n   UnPair Objects<-->Handles; ObjSize=%3u RgnChunk[%2u] @%x * %4u\n",
"    unpair Region[](%3u) @Offset= %4u;  Handle= %u @%x\n " ,
" Outer Region Address Handle[%4u] In Region*%3u :: RegionIndex = %u\n",
" Null Handle[%4u] In Region*%3u :: RegionIndex = %u\n",
"    Obj ObjectLockDir    : Chunk[%4u] AT Vbn[%3u]\n"
};
#endif


#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#define    MemGetVbn          MemGetWord
#define    MemPutVbn          MemPutWord
#define    MemGetChunkNum     MemGetWord
#define    MemPutChunkNum     MemPutWord
#define    MemGetIndex        MemGetWord
boolean DbmLoadObjHdr    (tokentype    *DbToken,  numtype     LocalObj,
ft F,lt Z,zz *Status,   objheader **ObjHdr)
{
boolean     TmpWriteHdr  = WriteHdr;
boolean     TmpSwapBug   = SwapBug;
int         TmpDeBug     = DeBug;
vbntype     MaxVbn       = 0;
vbntype     ObjHdrVbn    = 0;
boolean     Release      = False;
dbheader   *DbHdr        = NullPtr;
statustype  DumpStatus   = Env_Normal;
if (!DbmBug)
WriteHdr    = True;
SwapBug        = SwapBug;
DeBug          = DeBug;
DbmDbId        = DbToken->DbId;
if (TmFetchCoreDb  (DbToken,           McStat, &DbHdr))
if (MemGetStackPtr (DbHdr->ObjVbnDir,  McStat, &MaxVbn))
if (LocalObj >= MaxVbn)
if (sprintf (Msg, TraceStr8(21),
LocalObj, MaxVbn))
if (TraceMsg (0, Msg))
{
MemDumpChunk   (0,  DbHdr->ObjVbnDir,  Dump_Status);
*Status = Dbm_ObjHdrNotExist;
}
if (Normal(*Status))
if (MemGetVbn (DbHdr->ObjVbnDir,      LocalObj, McStat,      &ObjHdrVbn))
if (!ObjHdrVbn)
if (sprintf (Msg, TraceStr8(22),
LocalObj, ObjHdrVbn))
if (TraceMsg (0, Msg))
{
if (DeBug)
MemDumpChunk   (0,  DbHdr->ObjVbnDir,  Dump_Status);
*Status = Dbm_ObjHdrNotExist;
}
if (Normal(*Status))
if (DbHdr->BlkHdr.BlkFile)
{
#ifdef __DISPLAY_MESSAGE__
if (DeBug || DbmBug)
if (sprintf (Msg, TraceStr8(23),
LocalObj, DbHdr->BlkHdr.BlkFile))
TraceMsg (0, Msg);
#endif
} else {
*Status = File_NotFound;
#ifdef __DISPLAY_MESSAGE__
sprintf (Msg, TraceStr8(24),
DbHdr->DbId, LocalObj);
SendMsg (0, Msg);
#endif
}
if (Normal(*Status))
if (CoreMoreCore (sizeof(objheader),  McStat,     (addrtype *)ObjHdr))
if (FileInBlk    ((addrtype *)ObjHdr,        (bytessize )sizeof (objheader),
&DbHdr->BlkHdr,     Release,  McStat,      &ObjHdrVbn))
if (DeBug || DbmBug)
if (sprintf (Msg, TraceStr8(25),
ObjHdrVbn))
TraceMsg (0, Msg);
if (Normal(*Status))
{
(*ObjHdr)->ObjectLockDir      = 0;
(*ObjHdr)->FieldNumMap        = 0;
(*ObjHdr)->LocalAttrNumMap    = 0;
(*ObjHdr)->FieldOffsetDir     = 0;
(*ObjHdr)->ClassOffsetDir     = 0;
(*ObjHdr)->FieldRefDir        = 0;
(*ObjHdr)->FieldMapDir        = 0;
(*ObjHdr)->FieldArrayDir      = 0;
(*ObjHdr)->NoRegionsInCore    = True;
if (FREEZE_GRP_PACKETS  == True)
{
(*ObjHdr)->FreezeClass     = 1;
(*ObjHdr)->DiskCache       = False;
} else {
(*ObjHdr)->FreezeClass     = 0;
(*ObjHdr)->DiskCache       = True;
}
if ((*ObjHdr)->ObjNum        == lSetNode_ObjNum
||  (*ObjHdr)->ObjNum        == gSetNode_ObjNum)
(*ObjHdr)->FreezeClass     = 1;
(*ObjHdr)->RegionChunkDir     = 0;
(*ObjHdr)->RegionVbnDir       = 0;
(*ObjHdr)->RegionSwapDir      = 0;
(*ObjHdr)->RegionFreezeDir    = 0;
(*ObjHdr)->TextChunk          = 0;
(*ObjHdr)->ExObjectTbl        = 0;
(*ObjHdr)->RgnStatusDir       = 0;
}
if (Normal(*Status))
if (DbmFileInObjHdr    (*ObjHdr,  DbmDbId, &DbHdr->BlkHdr, Release, McStat))
if (MemPutAddr         (DbHdr->ObjHdrDir,   LocalObj,
*(addrtype *)ObjHdr,    McStat))
if (DeBug)
MemDumpChunk   (0,  DbHdr->ObjHdrDir,  Dump_Status);
#ifdef __DISPLAY_MESSAGE__
if (DeBug >= 0)
if (sprintf (Msg, TraceStr8(26),
DbToken->DbId, LocalObj, *ObjHdr))
TraceMsg (0, Msg);
#endif
if (DbmBug)
if (*ObjHdr)
OaDumpObjHdr  (0, DbToken,  (*ObjHdr)->ObjNum,   McStat);
SwapBug        = TmpSwapBug;
DeBug          = TmpDeBug;
WriteHdr       = TmpWriteHdr;
TRACK(TrackBak,"DbmLoadObjHdr\n");
return(STAT);
}
boolean DbmFileInObjHdr  (objheader  *ObjHdr,    idtype        DbId,
blkhdrtype *BlkHdr,    boolean       Release,
ft F,lt Z,zz *Status )
{
struchdr     *StrucHdr   = NullPtr;
DbmFileInGrpHdr  ((grpheader *)ObjHdr,      DbId,
BlkHdr,      Release,     McStat);
if (DbId == RenvId)
ObjHdr->FreezeClass  = 1;
if (Normal(*Status))
if (ObjHdr->ObjectLockDirVbn)
if (FileInChunk (&ObjHdr->ObjectLockDir,    BlkHdr,        Release,
McStat,                 &ObjHdr->ObjectLockDirVbn))
if (DeBug || DbmBug) {
sprintf (Msg, TraceStr8(53),
ObjHdr->ObjectLockDir,ObjHdr->ObjectLockDirVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (FileInChunk (&ObjHdr->FieldNumMap,      BlkHdr,        Release,
McStat,                 &ObjHdr->FieldNumMapVbn))
if (DeBug || DbmBug) {
sprintf (Msg, TraceStr8(32),
ObjHdr->FieldNumMap,  ObjHdr->FieldNumMapVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (FileInChunk (&ObjHdr->LocalAttrNumMap,      BlkHdr,        Release,
McStat,                 &ObjHdr->LocalAttrNumMapVbn))
if (DeBug || DbmBug) {
sprintf (Msg, TraceStr8(33),
ObjHdr->LocalAttrNumMap,  ObjHdr->LocalAttrNumMapVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (FileInChunk (&ObjHdr->FieldOffsetDir,      BlkHdr,        Release,
McStat,                 &ObjHdr->FieldOffsetDirVbn))
if (DeBug || DbmBug) {
sprintf (Msg, TraceStr8(34),
ObjHdr->FieldOffsetDir,  ObjHdr->FieldOffsetDirVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (FileInChunk (&ObjHdr->ClassOffsetDir,      BlkHdr,        Release,
McStat,                 &ObjHdr->ClassOffsetDirVbn))
if (DeBug || DbmBug) {
sprintf (Msg, TraceStr8(35),
ObjHdr->ClassOffsetDir,  ObjHdr->ClassOffsetDirVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (FileInChunk (&ObjHdr->FieldRefDir,         BlkHdr,        Release,
McStat,                 &ObjHdr->FieldRefDirVbn))
if (DeBug || DbmBug) {
sprintf (Msg, TraceStr8(36),
ObjHdr->FieldRefDir,  ObjHdr->FieldRefDirVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (ObjHdr->FieldMapCount)
if (FileInChunk (&ObjHdr->FieldMapDir,     BlkHdr,        Release,
McStat,                 &ObjHdr->FieldMapDirVbn))
if (DeBug || DbmBug) {
sprintf (Msg, TraceStr8(37),
ObjHdr->FieldMapDir,           ObjHdr->FieldMapDirVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (ObjHdr->FieldArrayCount)
if (FileInChunk (&ObjHdr->FieldArrayDir,   BlkHdr,        Release,
McStat,                 &ObjHdr->FieldArrayDirVbn))
if (DeBug || DbmBug) {
sprintf (Msg, TraceStr8(38),
ObjHdr->FieldArrayDir,  ObjHdr->FieldArrayDirVbn);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (ObjHdr->TextChunkVbn)
if (FileInChunk     (&ObjHdr->TextChunk,   BlkHdr,        Release,
McStat,              &ObjHdr->TextChunkVbn))
if (MemGetChunkAddr (ObjHdr->TextChunk,    McStat,   (addrtype *)&StrucHdr))
{
if (StrucHdr->TextVbn)
FileInChunk   (&StrucHdr->TextChunk,   BlkHdr,        Release,
McStat,                &StrucHdr->TextVbn);
if (DeBug || DbmBug)
{
sprintf (Msg, TraceStr8(38),
ObjHdr->TextChunk,  ObjHdr->TextChunkVbn);
TraceMsg (0, Msg);
}
}
TRACK(TrackBak,"DbmFileInObjHdr\n");
return(STAT);
}
boolean DbmFileInRegionChunk (dbheader     *CoreDb,    objheader *ObjHdr,
indextype     RgnIndex,  boolean    Release,
ft F,lt Z,zz *Status,    numtype   *RgnChunk )
{
*Status = Err_BadDesign;
return(STAT);
}
boolean    DbmPairRgnObjects  (dbheader       *CoreDb,  objheader    *ObjHdr,
numtype    CurrRgnChunk, ft F,lt Z,zz *Status)
{
indextype   Index         = 0;
indextype   Offset        = 0;
indextype   Objects       = 0;
byte       *RegionAddr    = NullPtr;
handletype *HandlePtr     = NullPtr;
addrtype    ObjectAddr    = NullPtr;
int         TempDeBug     = DeBug;
booleantype TempMemBug    = MemBug;
numtype     MemLoc        = 0;
if (!PairObjects)
{
TRACK(TrackBak,"DbmPairRgnObjects\n");
return (STAT);
}
if (MemGetChunkAddr (CurrRgnChunk,          McStat, (addrtype *)&RegionAddr))
MemGetStackPtr  (CurrRgnChunk,          McStat, &Objects);
if (!RegionAddr || !Objects)
{
*Status = Odbm_BadSwapChunks;
sprintf (Msg, TraceStr8(41),
CurrRgnChunk, RegionAddr, Objects);
TraceMsg (0, Msg);
}
if (SWAP)
{
DeBug = 0;
MemBug = False;
while (Normal(*Status)
&&     Index < Objects)
{
Offset     = (ObjHdr->ObjSize * Index) + ObjHdr->HandleOffset;
ObjectAddr =  (addrtype )(RegionAddr + (ObjHdr->ObjSize * Index));
HandlePtr  = (handletype *)(RegionAddr + Offset);
if (*HandlePtr          == 1
&&  ObjHdr->ObjectCount != 1)
{
sprintf (Msg,
" DbmPairRgnObjects:: RegionChunk[%3u] Index = %2u; Handle=%4u\n",
CurrRgnChunk,  Index, *HandlePtr);
TraceMsg (0, Msg);
TraceMsg (0,
" ***ERROR... Should not be equal 1, as is NOT a Primal!\n");
*Status = Dbm_BadHandleInRegion;
}
if (*HandlePtr)
{
if (HmGetObjectMemLoc (CoreDb,  *HandlePtr, McStat, &MemLoc))
if (MemLoc == 0)
HmPutObjectAddr   (CoreDb,  *HandlePtr, ObjectAddr, McStat);
if (!Normal(*Status))
if (sprintf (Msg,
TraceStr8(45),
CurrRgnChunk,   Index, *HandlePtr))
TraceMsg (0, Msg);
}
++Index;
}
MemBug = TempMemBug;
DeBug = TempDeBug;
}
TRACK(TrackBak,"DbmPairRgnObjects\n");
return (STAT);
}
boolean    DbmUnPairRgnObjects
(dbheader       *CoreDb,  objheader    *ObjHdr,
numtype    CurrRgnChunk, ft F,lt Z,zz *Status)
{
indextype   Index         = 0;
indextype   Offset        = 0;
indextype   Objects       = 0;
byte       *RegionAddr    = NullPtr;
handletype *HandlePtr     = NullPtr;
addrtype    NullAddrValue = NullPtr;
int         TempDeBug     = DeBug;
booleantype TempMemBug    = MemBug;
numtype     MemLoc        = 0;
*Status = Err_NotImplemented;
TRACK(TrackBak,"DbmUnPairRgnObjects\n");
return (STAT);
}
void       DbmDumpObjHdr (int           TraceSwi,
objheader    *ObjHdr,    ft F,lt Z,zz *Status)
{
STAT;
return;
}
/* 当前文件是./CINT2000\255.vortex\src\ogrp.c*/

#define  OGRP_C
#define  GRP_C
/* 当前文件是./CINT2000\255.vortex\src\ogrp.h*/

#ifndef OGRP01_H
#define OGRP01_H
#define GrpNewObject                Grp_NewObject
#define GrpGetObject                Grp_GetObject
boolean Grp_NewObject
(dbheader     *CoreDb,    objheader    *ObjHdr,
ft F,lt Z,zz *Status,    indextype    *Index,
numtype      *RgnIndex,  addrtype     *RgnAddr);
boolean Grp_GetObject
(dbheader     *CoreDb,    objheader    *ObjHdr,
indextype     Index,
ft F,lt Z,zz *Status,    addrtype     *RgnAddr);
	boolean Grp_DeleteObject
(dbheader     *CoreDb,    objheader    *ObjHdr,
indextype     Index,     ft F,lt Z,zz *Status);
#endif
#ifdef NULL_TRACE_STRS
#define TraceStr9(StrNum)  TraceStr9[0]
static const char   *TraceStr9[1] = {"   ...OGRP... message\n" };
#else
#define TraceStr9(StrNum)  TraceStr9[StrNum]
static const char *TraceStr9[7] =
{
" ObjHdr[%3u:%3u] Not set as ObjectType.\n",
"    NewRgn  Entry(%5u) to Region[%5u] Head=%3u, RgnBufRgn=%5u\n",
"    Append Grp[%3u] Entry(%5u) to Region[%5u] (%5u)\n",
"   GrpNewObject[%4u] (%4u) Rgn=%3u RgnChunk= %3u   @ %x\n",
"  GrpGetObject DbId[%3u] ObjHdr[%2u] Index=%4u ...\n",
"        Index =%3u; RgnNum =%3u, LocalIndex = %3u\n",
"   GrpGetObject DbId=%3u Obj[%3u] Index=%4u Region[%2u:%2u]\n"
};
#endif
#define MemPopIndex          Mem_PopWord
#define MemGetChunkNum       Mem_GetWord
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)

boolean GrpNewObject     (dbheader     *CoreDb,    objheader    *ObjHdr,
ft F,lt Z,zz *Status,    indextype    *Index,
numtype      *RgnIndex,  addrtype     *RgnAddr)
{
numtype         Chunk        = 0;
addrtype        ChunkAddr    = NullPtr;
indextype       LocalIndex   = 0;
boolean         ExObject     = False;
numtype         BuffIndex    = 0;
if (ObjHdr->EnvObjType > That_AttrNum)
if (sprintf (Msg, TraceStr9(0),
CoreDb->DbId, ObjHdr->ObjNum))
if (SendMsg (0, Msg))
ObjHdr->EnvObjType = 0;
if (ObjHdr->ExObjectCount)
{
ExObject     = True;
if (MemPopIndex  (ObjHdr->ExObjectTbl,
McStat,    Index,  &ObjHdr->ExObjectCount))
if (*Index < ObjHdr->BaseIndex)
{
*RgnIndex  = 0;
Chunk              = ObjHdr->BaseRegion;
MemGetChunkAddr    (Chunk,       McStat,    &ChunkAddr);
} else {
*RgnIndex  = (*Index - ObjHdr->BaseIndex) / ObjHdr->RegionObjects;
if (ObjHdr->BaseIndex)
++*RgnIndex;
GrpGetRegion       (CoreDb,     (grpheader *)ObjHdr,    *RgnIndex,
McStat,     &Chunk,     &ChunkAddr);
}
} else if (ObjHdr->ObjectCount < ObjHdr->BaseIndex) {
*Index        = ObjHdr->ObjectCount++;
*RgnIndex     = 0;
if (*Index  == 0)
{
GrpNewRegion (CoreDb,  (grpheader *)ObjHdr, *Index,     *RgnIndex,
McStat,              &Chunk,  &ChunkAddr);
ObjHdr->BaseRegion = Chunk;
} else {
Chunk              = ObjHdr->BaseRegion;
MemGetChunkAddr       (Chunk,       McStat,    &ChunkAddr);
}
} else {
*Index      =  ObjHdr->ObjectCount++;
*RgnIndex   = (*Index  - ObjHdr->BaseIndex) / ObjHdr->RegionObjects;
if (ObjHdr->BaseIndex)
++*RgnIndex;
LocalIndex = (*Index  - ObjHdr->BaseIndex) % ObjHdr->RegionObjects;
if (LocalIndex == 0)
{
GrpNewRegion   (CoreDb,   (grpheader *)ObjHdr,
*Index,               *RgnIndex,
McStat,               &Chunk,   &ChunkAddr);
} else {
if (MemGetChunkNum   (ObjHdr->RegionChunkDir, *RgnIndex,
McStat,                 &Chunk))
if (Chunk  != 0)
MemGetChunkAddr  (Chunk,  McStat,         &ChunkAddr);
if (Chunk     == 0
||  ChunkAddr == NullPtr)
GrpGetRegion     (CoreDb,     (grpheader *)ObjHdr,    *RgnIndex,
McStat,     &Chunk,     &ChunkAddr);
if (Normal(*Status))
{
BuffIndex                        = ObjHdr->RgnBuffNums[*RgnIndex];
ObjHdr->RgnBuffNodes[BuffIndex]  = 1;
}
}
}
if (Normal(*Status))
if (*RgnIndex)
LocalIndex = (*Index - ObjHdr->BaseIndex) % ObjHdr->RegionObjects;
else
LocalIndex = *Index;
if (Normal(*Status))
if (!ExObject)
MemPutStackPtr   (Chunk,  LocalIndex+1,    McStat);
if (Normal(*Status))
if (MemPutBit        (ObjHdr->DirtyRegionDir,  *RgnIndex, 1, McStat))
*RgnAddr   = ChunkAddr;
if (DbmBug)
MemBug = False;
if (!Normal(*Status) || DeBug || GrpBug || DbmBug)
if (sprintf (Msg, TraceStr9(3),
*Index, LocalIndex, *RgnIndex, Chunk, *RgnAddr))
TraceMsg (0, Msg);
TRACK(TrackBak,"GrpNewObject\n");
return(STAT);
}
boolean GrpGetObject     (dbheader     *CoreDb,    objheader    *ObjHdr,
indextype     Index,
ft F,lt Z,zz *Status,    addrtype     *RgnAddr)
{
numtype         RgnNum       = 0;
numtype         Chunk        = 0;
addrtype        ChunkAddr    = NullPtr;
indextype       LocalIndex   = 0;
if (Normal(*Status))
{
if (Index   < ObjHdr->BaseIndex)
{
RgnNum     = 0;
LocalIndex = Index;
if (ObjHdr->BaseRegion == 0)
GrpGetRegion     (CoreDb,     (grpheader *)ObjHdr,  0,
McStat,    &ObjHdr->BaseRegion,  &ChunkAddr);
else
MemGetChunkAddr  (ObjHdr->BaseRegion,  McStat,     &ChunkAddr);
Chunk      = ObjHdr->BaseRegion;
} else {
RgnNum     = (Index - ObjHdr->BaseIndex) / ObjHdr->RegionObjects;
if (ObjHdr->BaseIndex)
RgnNum++;
LocalIndex = (Index - ObjHdr->BaseIndex)  % ObjHdr->RegionObjects;
GrpGetRegion        (CoreDb,     (grpheader *)ObjHdr,  RgnNum,
McStat,    &Chunk,               &ChunkAddr);
}
*RgnAddr    = ChunkAddr;
}
if (Normal(*Status))
if (Admin_Run)
if (CoreDb->DbId < PrimalId)
MemPutBit        (ObjHdr->DirtyRegionDir,  RgnNum, 1, McStat);
if (!Normal(*Status) || GrpBug || DbmBug || DeBug)
if (sprintf (Msg, TraceStr9(6),
CoreDb->DbId, ObjHdr->LocalObjNum,  Index,
RgnNum, LocalIndex))
TraceMsg (0, Msg);
TRACK(TrackBak,"GrpGetObject\n");
return (STAT);
}
boolean Grp_DeleteObject (dbheader     *CoreDb,    objheader    *ObjHdr,
indextype     Index,     ft F,lt Z,zz *Status)
{
numtype         DeleteRgn    = 0;
numtype         RgnNum       = 0;
numtype         Chunk        = 0;
addrtype        ChunkAddr    = NullPtr;
indextype       LocalIndex   = 0;
addrtype        DeleteEntry  = NullPtr;
indextype       LastIndex    = 0;
addrtype        LastEntry    = NullPtr;
numtype         MemLoc       = 0;
handletype      Handle       = 0;
boolean         TempGrpBug   = GrpBug;
if (Index   < ObjHdr->BaseIndex)
{
DeleteRgn               = 0;
LocalIndex              = Index;
if (ObjHdr->BaseRegion == 0)
GrpGetRegion     (CoreDb,     (grpheader *)ObjHdr,  0,
McStat,    &ObjHdr->BaseRegion,  &ChunkAddr);
else
MemGetChunkAddr  (ObjHdr->BaseRegion,  McStat,     &ChunkAddr);
Chunk      = ObjHdr->BaseRegion;
} else {
DeleteRgn      = (Index - ObjHdr->BaseIndex) / ObjHdr->RegionObjects;
if (ObjHdr->BaseIndex)
RgnNum++;
LocalIndex     = (Index - ObjHdr->BaseIndex) % ObjHdr->RegionObjects;
if (GrpGetRegion    (CoreDb,     (grpheader *)ObjHdr,  DeleteRgn,
McStat,    &Chunk,               &ChunkAddr))
++ObjHdr->FrozenRgns[DeleteRgn];
}
DeleteEntry   =  (addrtype )((char *)ChunkAddr
+ (ObjHdr->ObjSize * LocalIndex));
--ObjHdr->ObjectCount;
LastIndex             = ObjHdr->ObjectCount;
if (GrpBug || DbmBug || DeBug)
if (sprintf (Msg,
" Rgn =%4u; Chunk=%4u;                  LocalIndex=%4u;\n",
DeleteRgn, Chunk, LocalIndex))
if (TraceMsg (0, Msg))
if (sprintf (Msg,
"                                         LastIndex=%4u\n",
ObjHdr->ObjectCount))
TraceMsg (0, Msg);
if (Normal(*Status))
if (ObjHdr->ObjectCount == 0)
{
memset     (DeleteEntry,    0,            ObjHdr->ObjSize);
Grp_CleanRgnChunks (CoreDb,  (grpheader *)ObjHdr,  DeleteRgn,  Chunk,
McStat);
} else if (LastIndex    == Index) {
memset     (DeleteEntry,    0,            ObjHdr->ObjSize);
if (DeleteRgn)
--ObjHdr->FrozenRgns[DeleteRgn];
++ObjHdr->RgnStats[DeleteRgn];
if (LocalIndex  == 0)
Grp_CleanRgnChunks (CoreDb,  (grpheader *)ObjHdr,  DeleteRgn, Chunk,
McStat);
else
MemPutStackPtr     (Chunk,        LocalIndex+1,    McStat);
} else {
if (LastIndex         < ObjHdr->BaseIndex)
{
RgnNum     = 0;
LocalIndex = LastIndex;
if (ObjHdr->BaseRegion == 0)
GrpGetRegion     (CoreDb,     (grpheader *)ObjHdr,  0,
McStat,    &ObjHdr->BaseRegion,  &ChunkAddr);
else
MemGetChunkAddr  (ObjHdr->BaseRegion,  McStat,     &ChunkAddr);
Chunk      = ObjHdr->BaseRegion;
} else {
RgnNum     = (LastIndex - ObjHdr->BaseIndex) / ObjHdr->RegionObjects;
if (ObjHdr->BaseIndex)
RgnNum++;
LocalIndex = (LastIndex - ObjHdr->BaseIndex) % ObjHdr->RegionObjects;
GrpGetRegion    (CoreDb,     (grpheader *)ObjHdr,  RgnNum,
McStat,    &Chunk,               &ChunkAddr);
}
LastEntry     =  (addrtype )((char *)ChunkAddr
+ (ObjHdr->ObjSize * LocalIndex));
Handle        = *(handletype *)((char *)LastEntry
+ ObjHdr->HandleOffset);
if (GrpBug || DbmBug || DeBug)
if (sprintf (Msg,
" LAST Rgn =%4u; Chunk=%4u; Local=%4u;      Index=%4u; Handle=%6u\n",
RgnNum, Chunk, LocalIndex, LastIndex,  Handle))
TraceMsg (0, Msg);
if (Normal(*Status))
if (HmPutObjectIndex   (CoreDb,  Handle,  Index,         McStat))
if (HmGetObjectMemLoc  (CoreDb,  Handle,  McStat,       &MemLoc))
if (MemLoc  ==0)
HmPutObjectAddr    (CoreDb,  Handle,  DeleteEntry,   McStat);
if (Normal(*Status))
{
++ObjHdr->RgnStats[RgnNum];
++ObjHdr->RgnStats[DeleteRgn];
MoveBytes  (LastEntry,  DeleteEntry,  ObjHdr->ObjSize);
memset     (LastEntry,  0,            ObjHdr->ObjSize);
if (LocalIndex  == 0)
Grp_CleanRgnChunks (CoreDb,  (grpheader *)ObjHdr,  RgnNum,  Chunk,
McStat);
else
MemPutStackPtr     (Chunk,        LocalIndex+1,    McStat);
}
if (DeleteRgn)
--ObjHdr->FrozenRgns[DeleteRgn];
}
GrpBug  = TempGrpBug;
TRACK(TrackBak,"Grp_DeleteObject\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\om.c*/

#define  OM
#ifdef NULL_TRACE_STRS
#define TraceStr10(StrNum)  TraceStr10[0]
static const char   *TraceStr10[1] = {"   ...MEM00... message\n" };
#else
#define TraceStr10(StrNum)  TraceStr10[StrNum]
static const char *TraceStr10[71] =
{
"    OmNewObjHdr (CoreDb[%2u] @ %x)  for ObjNum = %3u\n",
"        LocalObjNum = %3u\n",
"   OmNewObjHdr intermediate Db Obj Query *Status= %d\n",
"*** ERROR... Obj[%3u] NOT in Schema of CoreDb[%2u]\n",
"   NEW ObjHdr[%3u](%3u) @ %x regions=%3u Sectors=%3u Alloc=%4u\n",
"   NEW ObjHdr[%3u] @ %x Regions=%3u Objects/Region=%4u\n",
"    Set ObjHdr[%3d]->HandleOffset = %2u\n",
"    GET ObjHdr[%3d]  @ %x\n",
" Error in OmGetObjHdr:: DbId= %3u; Object_Index=%6u\n",
"     EXOBJECT Index = %4u Region = %2u Offset = %3u\n",
"    APPEND Obj[%3u] Object(%u) to Region[%u] @ Offset=%u\n",
"    OmNewObject[%4u] (%4u) RgnChunk %2d   @ %x\n",
"     OM NEW Region Obj[%3u] Index[%4u] RgnIndex[%3u] Qty= %3u\n",
"       Current Rgn[%2u] Chunk= %3u Vbn= %2u\n",
"       New     Rgn[%2u] Chunk= XX  Vbn= XX\n",
"  CurrentRegion %3u is EMPTY; swaps for NEW Region[%u]\n",
"      NEW Region[%d] ObjectIndex[%4u] Chunk= %3d\n",
"   Om Pair Object<--Handle :: Region[%2u](%2u)+%2u = %4u @%x Offset %u\n",
"\n   UnPairRgnObjects<FALSE>::    ObjSize=%3u RgnChunk[%2u] @%x * %4u\n",
" BAD UNPAIR Handles for RegionChunk[%3u] @%x count %4u\n",
"\n   UnPair Objects<-->Handles; ObjSize=%3u RgnChunk[%2u] @%x * %4u\n",
"    unpair Region[](%3u) @Offset= %4u;  Handle= %u @%x\n",
" Outer Region Address Handle[%4u] In Region*%3u :: RegionIndex = %u\n",
" Null Handle[%4u] In Region*%3u :: RegionIndex = %u\n",
"   OmPairRgnObjects<FALSE>::    ObjSize=%3u RgnChunk[%2u] @%x * %4u\n",
" BAD PAIR Handles for RegionChunk[%3u] @%x count %4u\n",
"   OmPairRgnObjects<-->Handles; ObjSize=%3u RgnChunk[%2u] @%x * %4u\n",
"    pair Region[](%3u) Object @%x;  Handle= %u @%x\n ",
" Outer Region Address Handle[%4u] In Region*%3u :: RegionIndex = %u\n",
" Region[%3u] Object[%3u] Handle= %4u\n",
" Null Handle[%4u] In Region*%3u :: RegionIndex = %u\n",
"  OmGetRegion for DB = %3u; ObjNum =%3u; Region = %3u\n",
"       Current Rgn[%2u] Chunk= %3u Vbn= %2u\n",
"       New     Rgn[%2u] Chunk= %3u Vbn= %2u\n",
"  CurrentRegion %3u is EMPTY; swaps for Region[%u] vbn=%2u\n",
"    Roll OUT Current Region[%4u] Chunk= %6u SwapVbn =%6u\n",
"       Current Rgn[%2u] Chunk= %3u Vbn= %2u\n",
"       New     Rgn[%2u] Chunk= %3u Vbn= %2u\n",
"  CurrentRegion %3u is EMPTY; swaps for Region[%u] vbn=%2u\n",
"    Roll OUT Current Region[%4u] Chunk= %6u SwapVbn =%6u\n",
"    Roll IN  New     Region[%4u] Chunk= %6u SwapVbn =%6u\n",
"      Region[%3u] Chunk[%6u] @%x OverLoaded!!!\n",
"      Load Region[%3u] Chunk[%6u]\n",
"      Current Region Set to %3u; As Chunk =%3u @%x\n",
"  OmGetObject[%2u:%4u] ...\n",
"        Index =%3u; RgnNum =%3u, LocalIndex = %3u\n",
"   OmGetObject[%2u:%4u]:: @%x Class[%3u] of Region[%2u:%2u]\n",
"   OmChkImage of ObjHdr(%3u) in DbId = %3u\n",
"  from DB_ObjHdr Time: %s   To RENV_ObjDesc Time %s\n",
"       DB_ObjHdr Size= %3u;  Renv ObjDesc Size=%3u\n",
"   OmReBuild Objects of ObjHdr(%3u) in DbId = %3u\n",
"    Field LocalAttr=%3u TransChunk[%3u]=%3u \n",
"    Field LocalAttr=%3u TransChunk[%3u]=%3u \n",
"   Move To Field[%2u]+ %3u @%x From ObjField[%2u]+ %2u @ %x = ",
"\n    Reform Obj's in  Region[%2u]  Chunk[%2u]  :  @ %X\n",
"    From Object[%2u] Handle[%4u] (+ %3u)... To (+ %3u)\n",
" ObjHdr: Size=%3u Fields[%2u], LocalAttrMap=%2u, OffsetDir=%2u\n",
"  REform Object @%x To NewRegion @%x ... \n",
"   Move To Field[%2u]+ %3u @%x From ObjField[%2u]+ %3u @ %x = ",
" OmGetObjHandles ::  ObjNum=%4u\n",
" ObjectCount      :: %u\n",
" RegionObjects    :: %u\n",
" RegionCount      :: %u\n",
" ExObjectCount    :: %u\n",
"\n    Obj Region[%2u]  Chunk[%2u]  :  @ %X\n",
"   %-7u\n",
"   %-7u  ",
"   RgnStatus[%3u] =%4u\n",
"\n    Obj Region[%2u]  Chunk[%2u]  :  @ %X\n",
"   %-7u\n",
"   %-7u  "
};
#endif
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)

#define MemPutHandle         Mem_PutWord
#define MemGetHandle         Mem_GetWord
#define MemPushLocalObjNum   Mem_PushWord
#define MemPutLocalObjNum    Mem_PutWord
#define MemGetLocalObjNum    Mem_GetWord
#define MemPushObjectIndex   Mem_PushWord
#define MemPutObjectIndex    Mem_PutWord
#define MemGetObjectIndex    Mem_GetWord
#define MemPushObjectAddr    Mem_PushAddr
#define MemPutObjectAddr     Mem_PutAddr
#define MemGetObjectAddr     Mem_GetAddr
#define MemGetObject         Mem_GetAddr
#define MemPutObjNum         Mem_PutWord
#define MemGetObjNum         Mem_GetWord
#define MemPushObjNum        Mem_PushWord
#define MemPushAttrNum       Mem_PushWord
#define MemGetAttrNum        Mem_GetWord
#define MemPutAttrNum        Mem_PutWord
#define MemPushObjHdr        Mem_PushAddr
#define MemPutObjHdr         Mem_PutAddr
#define MemGetObjHdr         Mem_GetAddr
#define MemPushChunkNum      Mem_PushWord
#define MemGetChunkNum       Mem_GetWord
#define MemPutChunkNum       Mem_PutWord
#define MemPutRegionNum      Mem_PutWord
#define MemGetRegionNum      Mem_GetWord
#define MemPutOffset         Mem_PutWord
#define MemGetOffset         Mem_GetWord
#define MemPushLink          Mem_PushWord
#define MemPutLink           Mem_PutWord
#define MemGetLink           Mem_GetWord
#define MemPushExObject      Mem_PushWord
#define MemPopExObject       Mem_PopWord
#define MemGetVbn            Mem_GetWord
#define MemGetChunkNum       Mem_GetWord
#define MemGetSize           Mem_GetWord
#define MemPushSize          Mem_PushWord
void       OmSetConfig   (boolean       Config)
{
Config_Class   = Config;
return;
}
void       OmConfigClass (numtype       RgnEntrys,
numtype       AllocRgns, numtype       ExtendRgns,
numtype       AllocXs,   numtype       ExtendXs,
accesstype    AccessType,boolean       DiskCache,
numtype       CacheLimit,numtype       CacheLoad)
{
Config_Class          = True;
Class_RegionEntrys    = RgnEntrys;
Class_AllocRegions    = AllocRgns;
Class_ExtendRegions   = ExtendRgns;
Class_AllocExObjects  = AllocXs;
Class_ExtendExObjects = ExtendXs;
Class_AccessType      = AccessType;
Class_DiskCache       = DiskCache;
Class_CacheLimit      = CacheLimit;
Class_CacheLoad       = CacheLoad;
return;
}
boolean    OmNewObjHdr (tokentype    *Anchor,   numtype     EnvObj,
indextype     AllocQty,
ft F,lt Z,zz *Status,   objheader **ObjHdr)
{
dbheader    *CoreDb          = NullPtr;
localnumtype LocalObj        = 0;
indextype    ObjIndex        = 0;
indextype    StackPtr        = 0;
indextype    AllocObjects    = AllocQty;
time_t       Tod             = 0;
time (&Tod);
*ObjHdr     = NullPtr;
if (TmGetCoreDb       (Anchor,   McStat,   &CoreDb))
if (Normal(*Status))
if (MemGetLocalObjNum (CoreDb->LocalObjNumMap,  EnvObj,  McStat, &LocalObj))
if (LocalObj          == 0
&&  EnvObj            != 0)
*Status             = Om_ObjNotInSchema;
if (Normal(*Status))
{
ObjIndex            = LocalObj;
if (MemGetStackPtr (CoreDb->ObjHdrDir,    McStat,   &StackPtr))
if (ObjIndex
&&  ObjIndex        < StackPtr)
{
*Status           = Env_Normal;
if (Build_Env
&&  Anchor->DbId == RenvId)
{
TraceMsg (0, "    OmNewObjHdr ... from Void to Core \n");
OmGetObjHdr (Anchor,     ObjIndex,      McStat,  ObjHdr);
} else
*ObjHdr = NullPtr;
} else {
if (EnvObj      == 0)
MemGetObjHdr (CoreDb->ObjHdrDir, ObjIndex,
McStat,                      (addrtype *)ObjHdr);
else
*Status        = Om_IndexOutOfRange;
}
}
if (*ObjHdr
&& (*Status           != Om_IndexOutOfRange))
{
*Status              = Om_ObjHdrExists;
} else {
if (*Status      == Om_IndexOutOfRange
||  *Status      == Om_ObjNotInSchema)
{
if (Anchor->DbId <= PrimalId
||  Anchor->DbId >= PrimalId)
{
*Status = Env_Normal;
} else {
if (sprintf (Msg,
TraceStr10(3),
EnvObj, Anchor->DbId))
if (SendMsg (0, Msg))
*Status = Om_ObjNotInSchema;
}
if (Normal(*Status))
if (MemPushObjNum (CoreDb->ObjNumMap,  EnvObj,  McStat, &LocalObj))
if (Anchor->DbId != RenvId)
MemPushLong   (CoreDb->ObjTimeStampDir,  (longwordtype )Tod,
McStat,                              &LocalObj);
if (Normal(*Status))
if (MemPushObjHdr (CoreDb->ObjHdrDir,  NullPtr, McStat, &ObjIndex))
if (MemPushWord   (CoreDb->ObjVbnDir,  0,       McStat, &StackPtr))
++(CoreDb->LocalObjCount);
if (Normal(*Status))
MemPutLocalObjNum (CoreDb->LocalObjNumMap,  EnvObj,
LocalObj,                McStat);
}
if (Normal(*Status))
if ((EnvObj        && Anchor->DbId == RenvId)
||  (LocalObj > 1  && Anchor->DbId != RenvId))
{
if (LocalObj == 0)
{
if (MemPushObjNum (CoreDb->ObjNumMap, EnvObj,   McStat, &LocalObj))
if (Anchor->DbId != RenvId)
MemPushLong   (CoreDb->ObjTimeStampDir,
(longwordtype )Tod,
McStat,                              &LocalObj);
} else  {
MemPutObjNum  (CoreDb->ObjNumMap, LocalObj, EnvObj,  McStat);
if (Anchor->DbId != RenvId)
MemPutLong (CoreDb->ObjTimeStampDir, LocalObj,
(longwordtype )Tod,  McStat);
}
}
if (Normal(*Status))
if (CoreMoreCore      (sizeof(objheader), McStat,    (addrtype *)ObjHdr))
if (MemPutObjHdr      (CoreDb->ObjHdrDir, LocalObj, *(addrtype *)ObjHdr,
McStat))
if (MemPutWord        (CoreDb->ObjVbnDir, LocalObj,  0,          McStat))
if (MemPutLocalObjNum (CoreDb->LocalObjNumMap,      (indextype  )EnvObj,
LocalObj,                                 McStat))
{
(**ObjHdr).EnvObjType    = 0;
(**ObjHdr).LocalAccess   = CoreDb->LocalAccess;
(**ObjHdr).DiskCache     = CoreDb->DiskCache;
(**ObjHdr).ObjSize       = ObjHdrSize[EnvObj];
(**ObjHdr).LocalObjNum   = LocalObj;
(**ObjHdr).ObjNum        = EnvObj;
}
if (Normal(*Status))
{
OmMakeObjChunks (Anchor, *ObjHdr, McStat, &AllocObjects);
}
if (ObjSectorQty[EnvObj] == 0
||  ObjRegionQty[EnvObj] == 0)
{
*Status                = Env0_NullRegionQty;
sprintf (Msg,
TraceStr10(4),
EnvObj, LocalObj, *ObjHdr,  ObjRegionQty[EnvObj],
ObjSectorQty[EnvObj],       AllocObjects);
TraceMsg (0, Msg);
}
}
TRACK(TrackBak,"OmNewObjHdr\n");
return (STAT);
}
boolean    OmMakeObjChunks (tokentype    *Anchor,     objheader  *ObjHdr,
ft F,lt Z,zz *Status,     indextype  *AllocObjects)
{
indextype    AllocExObjects  = Alloc_ExObjects;
indextype    ExtendExObjects = Extend_ExObjects;
indextype    AllocRegions    = 10;
indextype    ExtendRegions   = 10;
numtype      CacheLimit      = 3;
numtype      CacheLoad       = 3;
idtype       CoreDbId        = Anchor->DbId;
if (ObjHdr->ObjNum      == (numtype )0 && Anchor->DbId == RenvId
||  ObjHdr->ObjNum      == (numtype )1 && Anchor->DbId != RenvId)
{
AllocExObjects        = 1;
ExtendExObjects       = 0;
AllocRegions          = 1;
ExtendRegions         = 0;
*AllocObjects          = 1;
CacheLimit            = 1;
} else if (Config_Class) {
*AllocObjects          = Class_RegionEntrys;
AllocRegions          = Class_AllocRegions;
ExtendRegions         = Class_ExtendRegions;
AllocExObjects        = Class_AllocExObjects;
ExtendExObjects       = Class_ExtendExObjects;
CacheLimit            = Class_CacheLimit;
CacheLoad             = Class_CacheLoad;
ObjHdr->LocalAccess   = Class_AccessType;
ObjHdr->DiskCache     = Class_DiskCache;
} else {
*AllocObjects          = ObjSectorQty[ObjHdr->ObjNum];
AllocRegions          = ObjRegionQty[ObjHdr->ObjNum];
}
ObjHdr->RegionObjects    = *AllocObjects;
ObjHdr->NoRegionsInCore  = True;
if (FREEZE_GRP_PACKETS  == True)
{
ObjHdr->FreezeClass    = 1;
ObjHdr->DiskCache      = False;
} else {
ObjHdr->FreezeClass    = 0;
ObjHdr->DiskCache      = True;
}
ObjHdr->RegionIndex      = 0;
ObjHdr->RegionCount      = 0;
ObjHdr->ExObjectCount    = 0;
ObjHdr->NextEx           = 0;
ObjHdr->ObjectCount      = 0;
ObjHdr->NextObject       = 0;
if (Normal(*Status))
{
ObjHdr->NextEntry      = 0;
ObjHdr->BaseIndex      = 0;
ObjHdr->BaseRegion     = 0;
ObjHdr->CacheLimit     = CacheLimit;
ObjHdr->CacheLoad      = CacheLoad;
ObjHdr->NumBuffRgns    = CacheLimit;
if (Anchor->DbId      == RenvId)
ObjHdr->FreezeClass = 1;
GrpMakeHdrChunks   (Anchor,              (grpheader *)ObjHdr,
AllocRegions,  AllocExObjects,    McStat);
}
if (Normal(*Status))
{
if (MemNewBitChunk
(*AllocObjects,        CoreDbId,
McStat,                     &(ObjHdr->ObjectLockDir)))
if (MemMakeChunk (sizeof(localattrnum),        Alloc_DbAttrs,
Extend_DbAttrNums,           CoreDbId,
McStat,                     &(ObjHdr->FieldNumMap)))
if (MemPutStackPtr
(ObjHdr->FieldNumMap,         Alloc_DbAttrs,  McStat))
if (MemMakeChunk (sizeof(localattrnum),        Alloc_DbAttrs,
Extend_DbAttrNums,           CoreDbId,
McStat,                     &(ObjHdr->LocalAttrNumMap)))
if (MemMakeChunk (sizeof(typesize),            Alloc_Fields,
Extend_Fields,               CoreDbId,
McStat,                     &(ObjHdr->FieldOffsetDir)))
if (MemMakeChunk (sizeof(typesize),            Alloc_Fields,
Extend_Fields,               CoreDbId,
McStat,                     &(ObjHdr->ClassOffsetDir)))
if (MemMakeChunk (sizeof(reftkntype),          Alloc_FieldRefs,
Extend_FieldRefs,            CoreDbId,
McStat,                     &(ObjHdr->FieldRefDir)))
if (MemPutStackPtr (ObjHdr->LocalAttrNumMap, (indextype  )1, McStat))
if (MemPutStackPtr (ObjHdr->FieldOffsetDir,  (indextype  )1, McStat))
if (MemPutStackPtr (ObjHdr->ClassOffsetDir,  (indextype  )1, McStat))
if (MemPutStackPtr (ObjHdr->FieldRefDir,     (indextype  )1, McStat))
{
ObjHdr->HandleOffset  = 0;
ObjHdr->StringCount   = 0;
ObjHdr->ExObjectCount = 0;
ObjHdr->NextEx        = 0;
}
}
TRACK(TrackBak,"OmMakeObjChunks\n");
return (STAT);
}
boolean    OmPutHandleOffset (tokentype *Token,  numtype   EnvObj,
bytessize  Offset, ft F,lt Z,zz *Status)
{
dbheader    *CoreDb   = NullPtr;
objheader   *ObjHdr   = NullPtr;
indextype    LocalObj = 0;
if (TmGetCoreDb  (Token,                  McStat,     &CoreDb))
if (MemGetObjNum (CoreDb->LocalObjNumMap, EnvObj,      McStat, &LocalObj))
if (MemGetObjHdr (CoreDb->ObjHdrDir,      LocalObj,
McStat,                 (addrtype *)&ObjHdr))
ObjHdr->HandleOffset = Offset;
if (DeBug >= 2)
if (sprintf (Msg, TraceStr10(6),
EnvObj, Offset))
TraceMsg (0, Msg);
TRACK(TrackBak,"OmPutHandleOffset\n");
return(STAT);
}
boolean    OmGetObjHdr (tokentype    *Anchor,   indextype     ObjIndex,
ft F,lt Z,zz *Status,   objheader   **ObjHdr)
{
dbheader    *CoreDb   = NullPtr;
vbntype      Vbn      = 0;
if (TmGetCoreDb   (Anchor,                      McStat,            &CoreDb))
if (MemGetObjHdr  (CoreDb->ObjHdrDir, ObjIndex, McStat, (addrtype *)ObjHdr))
{
if (*ObjHdr == NullPtr)
{
if(CoreDb->ObjVbnDirVbn)
if (MemGetVbn     (CoreDb->ObjVbnDir,               ObjIndex,
McStat,                         &Vbn))
if (DbmLoadObjHdr (Anchor, ObjIndex,   McStat,      ObjHdr))
if (CoreDb->DbId == RenvId)
(*ObjHdr)->FreezeClass  = 1;
else
OmChkImage      (Anchor,  (*ObjHdr)->ObjNum,    McStat);
}
} else {
*Status = Om_ObjHdrNotExist;
sprintf  (Msg, TraceStr10(8),
Anchor->DbId, ObjIndex);
TraceMsg (0,   Msg);
}
TRACK(TrackBak,"OmGetObjHdr\n");
return (STAT);
}
boolean    OmNextAvailObject (objheader *ObjHdr,   ft F,lt Z,zz *Status,
indextype  *ObjIndex, indextype    *RgnNum,
indextype  *RgnIndex)
{
indextype    StackPtr = 0;
if (ObjHdr->ExObjectCount)
{
if (MemPopWord (ObjHdr->ExObjectTbl,
McStat,             &StackPtr,      ObjIndex))
{
ObjHdr->ExObjectCount--;
*RgnNum   =  *ObjIndex / ObjHdr->RegionObjects;
*RgnIndex =  *ObjIndex % ObjHdr->RegionObjects;
}
} else {
*Status     =  Om_NewIndex;
*ObjIndex   =  ObjHdr->ObjectCount++;
*RgnNum     = *ObjIndex / ObjHdr->RegionObjects;
*RgnIndex   = *ObjIndex % ObjHdr->RegionObjects;
}
TRACK(TrackBak,"OmNextAvailObject\n");
return(STAT);
}
boolean    OmNewObject (dbheader     *CoreDb,  objheader  *ObjHdr,
ft F,lt Z,zz *Status,
indextype    *Index,   addrtype   *Object)
{
numtype         Chunk        = 0;
addrtype        ChunkAddr    = NullPtr;
indextype       LocalIndex   = 0;
indextype       RgnIndex     = 0;
char           *Base         = 0;
indextype       Inset        = 0;
addrtype        Ptr          = 0;
if (GrpNewObject      (CoreDb,  ObjHdr,
McStat,  Index,  &RgnIndex,  &ChunkAddr))
{
LocalIndex       = (*Index  - ObjHdr->BaseIndex) % ObjHdr->RegionObjects;
Base             = (char *)ChunkAddr;
Inset            = LocalIndex           * ObjHdr->ObjSize;
Ptr              = (addrtype )((char *)Base     + Inset);
*(byte **)Object = ((byte *)ChunkAddr)  + (LocalIndex * ObjHdr->ObjSize);
if ((addrtype )Ptr != *Object)
*Status = Om_BadAddr;
if (!Normal(*Status) || DeBug || OaBug || DbmBug)
if (sprintf (Msg,
TraceStr10(11),
*Index, LocalIndex, Chunk, *Object))
TraceMsg (0, Msg);
}
TRACK(TrackBak,"OmNewObject\n");
return(STAT);
}
boolean    OmNewObjRegion (dbheader     *CoreDb,  objheader   *ObjHdr,
indextype     Index,
ft F,lt Z,zz *Status,  numtype     *Region)
{
indextype   SwapRgn    = 0;
indextype   SwapVbn    = 0;
numtype     Chunk      = 0;
indextype   StackPtr   = 0;
indextype   RgnObjects = 0;
indextype   RgnIndex   = Index  / ObjHdr->RegionObjects;
if (RgnIndex != ObjHdr->RegionIndex)
if (ObjHdr->FreezeClass == 0)
{
if (MemGetWord (ObjHdr->RegionChunkDir,  ObjHdr->RegionIndex,
McStat,                 &SwapRgn))
if (MemGetWord (ObjHdr->RegionSwapDir,   ObjHdr->RegionIndex,
McStat,                 &SwapVbn))
if (Normal(*Status))
if (SwapRgn)
if (MemGetStackPtr     (SwapRgn, McStat, &RgnObjects))
if (RgnObjects)
{
OmUnPairRgnObjects (CoreDb,  ObjHdr,  SwapRgn,    McStat);
} else {
sprintf (Msg,
TraceStr10(15),
ObjHdr->RegionIndex, Region);
TraceMsg (0, Msg);
*Status = Om_BadSwapChunks;
}
if (Normal(*Status))
if (SwapRgn)
if (MemSwapOutChunk (SwapRgn,                McStat, &SwapVbn))
MemPutChunkNum  (ObjHdr->RegionSwapDir,  ObjHdr->RegionIndex,
SwapVbn,                        McStat);
}
if (Normal(*Status))
if (MemMakeChunk    (ObjHdr->ObjSize,   ObjHdr->RegionObjects,
Extend_Objects,    CoreDb->DbId,
McStat,           &Chunk))
if (MemPushChunkNum (ObjHdr->RegionChunkDir, Chunk, McStat, &StackPtr))
if (MemPushChunkNum (ObjHdr->RegionSwapDir,  (vbntype )0,
McStat,                                &StackPtr))
{
*Region                  = (regionnum )StackPtr;
ObjHdr->NoRegionsInCore = False;
ObjHdr->RegionIndex     = *Region;
ObjHdr->RegionCount++;
if (RgnIndex           != *Region)
*Status              = Om_BadSwapChunks;
if (!Normal(*Status)   ||  SwapBug || DeBug)
if (sprintf (Msg, TraceStr10(16),
*Region,  Index, Chunk))
if (TraceMsg (0, Msg))
DumpChunkChunk (0, Chunk);
}
TRACK(TrackBak,"OmNewObjRegion\n");
return(STAT);
}
boolean    OmPairDbObject (objheader *ObjHdr,   indextype     Index,
handletype Handle,   ft F,lt Z,zz *Status)
{
indextype   RegionNum   = Index / ObjHdr->RegionObjects;
indextype   RegionIndex = Index % ObjHdr->RegionObjects;
numtype    RegionChunk = 0;
byte       *RegionAddr  = NullPtr;
handletype *HandlePtr   = NullPtr;
indextype   Offset      = 0;
if (MemGetChunkNum  (ObjHdr->RegionChunkDir,                 RegionNum,
McStat,                                &RegionChunk))
if (MemGetChunkAddr (RegionChunk,     McStat,   (addrtype *)&RegionAddr))
{
Offset     =  (ObjHdr->ObjSize * RegionIndex) + ObjHdr->HandleOffset;
RegionAddr =  RegionAddr + Offset;
HandlePtr  =  (handletype *)RegionAddr;
*HandlePtr  =  Handle;
}
if (! HandlePtr)
*Status = Om_BadHandleObjPair;
if (!Normal(*Status) || SwapBug || SwapHandles)
if (sprintf (Msg,
TraceStr10(17),
RegionNum, RegionIndex, ObjHdr->HandleOffset,
*HandlePtr, HandlePtr,   Offset))
TraceMsg (1, Msg);
TRACK(TrackBak,"OmPairDbObject\n");
return (STAT);
}
boolean    OmUnPairRgnObjects (dbheader  *CoreDb,       objheader    *ObjHdr,
numtype    CurrRgnChunk, ft F,lt Z,zz *Status)
{
indextype   Index         = 0;
indextype   Offset        = 0;
indextype   Objects       = 0;
byte       *RegionAddr    = NullPtr;
handletype *HandlePtr     = NullPtr;
addrtype    NullAddrValue = NullPtr;
int         TempDeBug     = DeBug;
booleantype TempMemBug    = MemBug;
numtype     MemLoc        = 0;
if (!UnPairObjects)
{
TRACK(TrackBak,"OmUnPairRgnObjects\n");
return (STAT);
}
if (MemGetChunkAddr (CurrRgnChunk,          McStat, (addrtype *)&RegionAddr))
MemGetStackPtr  (CurrRgnChunk,          McStat, &Objects);
if (!RegionAddr || !Objects)
{
*Status = Om_BadSwapChunks;
sprintf (Msg, TraceStr10(19),
CurrRgnChunk, RegionAddr, Objects);
TraceMsg (0, Msg);
}
if (SWAP)
{
DeBug = 0;
MemBug = False;
while (Normal(*Status) && Index < Objects)
{
Offset     = (ObjHdr->ObjSize * Index) + ObjHdr->HandleOffset;
HandlePtr  = (handletype *)(RegionAddr + Offset);
if (*HandlePtr && *HandlePtr < CoreDb->HandleCount)
{
if (HmGetObjectMemLoc (CoreDb,  *HandlePtr, McStat, &MemLoc))
if (MemLoc == 0)
HmPutObjectAddr (CoreDb, *HandlePtr, NullAddrValue, McStat);
}
if (SwapBug)
*Status = Env_Normal;
++Index;
}
DeBug  = TempDeBug;
MemBug = TempMemBug;
}
TRACK(TrackBak,"OmUnPairRgnObjects\n");
return (STAT);
}
boolean    OmPairRgnObjects   (dbheader  *CoreDb,       objheader    *ObjHdr,
numtype    CurrRgnChunk, ft F,lt Z,zz *Status)
{
indextype   Index         = 0;
indextype   Offset        = 0;
indextype   Objects       = 0;
byte       *RegionAddr    = NullPtr;
handletype *HandlePtr     = NullPtr;
addrtype    ObjectAddr    = NullPtr;
int         TempDeBug     = DeBug;
booleantype TempMemBug    = MemBug;
numtype     MemLoc        = 0;
if (!PairObjects)
{
TRACK(TrackBak,"OmPairRgnObjects\n");
return (STAT);
}
if (MemGetChunkAddr (CurrRgnChunk,          McStat, (addrtype *)&RegionAddr))
MemGetStackPtr  (CurrRgnChunk,          McStat, &Objects);
if (!RegionAddr || !Objects)
{
*Status = Om_BadSwapChunks;
sprintf (Msg, TraceStr10(25),
CurrRgnChunk, RegionAddr, Objects);
TraceMsg (0, Msg);
}
if (SWAP)
{
DeBug = 0;
MemBug = False;
while (Normal(*Status)
&&     Index < Objects)
{
Offset     = (ObjHdr->ObjSize * Index) + ObjHdr->HandleOffset;
ObjectAddr =  (addrtype )(RegionAddr + (ObjHdr->ObjSize * Index));
HandlePtr  = (handletype *)(RegionAddr + Offset);
if (*HandlePtr)
{
if (HmGetObjectMemLoc (CoreDb,  *HandlePtr, McStat, &MemLoc))
if (MemLoc == 0)
HmPutObjectAddr   (CoreDb,  *HandlePtr, ObjectAddr, McStat);
if (!Normal(*Status))
if (sprintf (Msg,
TraceStr10(29),
CurrRgnChunk,   Index, *HandlePtr))
TraceMsg (0, Msg);
}
++Index;
}
MemBug = TempMemBug;
DeBug = TempDeBug;
}
TRACK(TrackBak,"OmPairRgnObjects\n");
return (STAT);
}
boolean    OmGetRegion (dbheader     *CoreDb,  objheader *ObjHdr,
indextype     Region,
ft F,lt Z,zz *Status,  numtype   *Chunk)
{
*Status = Err_BadDesign;
return(STAT);
}
boolean    OmGetObject  (tokentype   *Token,  ft F,lt Z,zz *Status,
indextype   *Index,  addrtype     *Object)
{
dbheader     *CoreDb    = NullPtr;
localnumtype  LocalObj  = 0;
objheader    *ObjHdr    = NullPtr;
numtype      RgnNum    = 0;
addrtype      ChunkAddr = NullPtr;
handletype    Handle    = Token->Handle;
indextype     LocalIndex= 0;
numtype       ObjNum    = 0;
if (TmGetCoreDb      (Token,  McStat,    &CoreDb))
if (HmGetLocalObjNum (CoreDb, Handle,     McStat,   &LocalObj))
if (LocalObj     == Null_ObjNum)
*Status = Om_ObjectHasBeenDeleted;
if (Normal(*Status))
if (OmGetObjHdr      (Token,  LocalObj,   McStat,   &ObjHdr))
if (HmGetObjectIndex (CoreDb, Handle,     McStat,    Index))
{
ObjNum     = ObjHdr->ObjNum;
RgnNum     = *Index  / ObjHdr->RegionObjects;
LocalIndex = *Index  % ObjHdr->RegionObjects;
}
if (Normal(*Status))
GrpGetObject         (CoreDb,          ObjHdr,    *Index,
McStat,                     &ChunkAddr);
if (Normal(*Status))
if (ChunkAddr)
*(byte **)Object = ((byte *)ChunkAddr) + (LocalIndex * ObjHdr->ObjSize);
else
*Status = Om_BadRegion;
if (!Normal(*Status) || OaBug || DeBug)
if (sprintf (Msg,
TraceStr10(46),
Token->DbId, Token->Handle,
*Object, ObjNum,  RgnNum, LocalIndex))
TraceMsg (0, Msg);
TRACK(TrackBak,"OmGetObject\n");
return (STAT);
}
boolean    OmDeleteObject   (tokentype    *Token,   objheader    *ObjHdr,
addrtype      Object,  ft F,lt Z,zz *Status)
{
dbheader       *CoreDb          = NullPtr;
indextype       ObjIndex        = 0;
if (TmGetCoreDb       (Token,         McStat,            &CoreDb))
if (HmGetObjectIndex  (CoreDb,        Token->Handle,
McStat,       &ObjIndex))
#ifdef   __SWAP_GRP_POS__
if (Grp_DeleteObject  (CoreDb,    ObjHdr,    ObjIndex,    McStat))
TmFreeToken       (McStat,                            Token);
#else
if (MemPushWord       (ObjHdr->ExObjectTbl,               ObjIndex,
McStat,                           &StackPtr))
if (TmFreeToken       (McStat,                            Token))
ObjHdr->ExObjectCount++;
if (Normal(*Status))
memset (Object,  0, (size_t)ObjHdr->ObjSize);
#endif
TRACK(TrackBak,"OmDeleteObject\n");
return(STAT);
}
boolean OmChkImage       (tokentype     *Anchor,   numtype    ObjNum,
ft F,lt Z,zz  *Status)
{
dbheader     *CoreDb          = NullPtr;
numtype       LocalObj        = 0;
objheader    *ObjHdr          = NullPtr;
time_t        ObjTod          = 0;
time_t        TknTod          = 0;
if (TmGetCoreDb       (Anchor,  McStat,          &CoreDb))
if (OaBug || DeBug)
if (sprintf  (Msg, TraceStr10(47),
ObjNum, Anchor->DbId))
TraceMsg (0,  Msg);
if (MemGetLong        (CoreDbs[RenvId]->ObjTimeStampDir,
(indextype )ObjNum,
McStat,                  (lt64     *)&ObjTod))
if (MemGetObjNum      (CoreDb->LocalObjNumMap,   ObjNum,
McStat,                  &LocalObj))
if (MemGetLong        (CoreDb->ObjTimeStampDir,  LocalObj,
McStat,                  (lt64     *)&TknTod))
if (OmGetObjHdr       (Anchor,      LocalObj,     McStat,  &ObjHdr))
if (Normal(*Status))
if (ObjHdr->ObjSize != ObjHdrSize[ObjNum])
if (sprintf  (Msg, TraceStr10(48),
ctime (&TknTod), ctime (&ObjTod) ))
if (TraceMsg (0,  Msg))
if (sprintf  (Msg, TraceStr10(49),
ObjHdr->ObjSize, ObjHdrSize[ObjNum]))
if (TraceMsg (0,  Msg))
{
*Status   = Err_NotImplemented;
}
TRACK(TrackBak,"OmChkImage\n");
return (STAT);
}
boolean    OmGetObjHandles
(tokentype    *Anchor,  objheader   *ObjHdr,
ft F,lt Z,zz *Status,
indextype    *Count,   handletype **Handles,
indextype    *RgnCount,numtype    **RgnStatus)
{
dbheader     *CoreDb        = NullPtr;
bytessize     CoreBlkSize   = 0;
bytessize     RgnBlkSize    = 0;
numtype       RgnChunk      = 0;
indextype     RgnIndex      = 0;
indextype     Index         = 0;
indextype     HndlCount     = 0;
indextype     RgnOffset     = 0;
addrtype      RgnAddr       = NullPtr;
int           Items         = 0;
addrtype      ObjectAddr    = NullPtr;
handletype   *ObjHndls      = NullPtr;
numtype      *Rgn_Status    = NullPtr;
*Handles       = NullPtr;
*RgnStatus     = NullPtr;
if (TmFetchCoreDb     (Anchor,           McStat,    &CoreDb))
if (ObjHdr->ObjectCount)
if (Normal(*Status))
{
CoreBlkSize  = ObjHdr->ObjectCount * sizeof (handletype);
if (CoreMoreCore      (CoreBlkSize,             McStat,
(addrtype *)Handles))
if (MemGetStackPtr    (ObjHdr->RegionSwapDir,   McStat,   RgnCount))
{
ObjHndls     = *Handles;
RgnBlkSize   = *RgnCount       * sizeof(numtype);
if (CoreMoreCore (RgnBlkSize,   McStat,  (addrtype *)RgnStatus))
Rgn_Status   = *RgnStatus;
}
while (Normal(*Status)
&&     RgnIndex       < *RgnCount)
{
Rgn_Status[RgnIndex]  = 0;
if (OmGetRegion     (CoreDb,      ObjHdr,        RgnIndex,
McStat,     &RgnChunk))
if (MemGetChunkAddr (RgnChunk,    McStat,       &RgnAddr))
if (ClassBug || OaBug || DeBug)
if (sprintf (Msg,
TraceStr10(64),
RgnIndex, RgnChunk,  RgnAddr))
TraceMsg (0, Msg);
Index       = 0;
RgnOffset   = 0;
while (Normal(*Status)
&& ++Index     <= ObjHdr->RegionObjects
&& ++HndlCount <= ObjHdr->ObjectCount)
{
ObjectAddr            = (char *)RgnAddr    + RgnOffset;
ObjectAddr            = (char *)ObjectAddr + ObjHdr->HandleOffset;
ObjHndls[HndlCount]   = *(handletype *)ObjectAddr;
RgnOffset            += ObjHdr->ObjSize;
if (*(handletype *)ObjectAddr)
Rgn_Status[RgnIndex]++;
if (OaBug || DeBug)
{
if (++Items % 6 == 0)
sprintf  (Msg,  TraceStr10(65), ObjHndls[HndlCount]);
else
sprintf  (Msg,  TraceStr10(66), ObjHndls[HndlCount]);
TraceMsg (0, Msg);
}
}
if (ClassBug || OaBug || DeBug)
if (sprintf  (Msg,  TraceStr10(67), Rgn_Status[RgnIndex]))
TraceMsg (0, Msg);
++RgnIndex;
}
} else
TraceMsg (0, " No Current Objects Of this OBJ type in this DB\n");
*Count = HndlCount;
TRACK(TrackBak,"OmGetObjHandles\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\point.c*/

#define POINT

#undef __HP__
boolean Point_InitClass  (ft F,lt Z,zz *Status)
{
#ifdef __HP__
tokentype (*pmf3)(Point*)        = &Point_GetToken;
#else
tokentype (*pmf3)(Point*)        = Point_GetToken;
#endif
if (Normal(*Status))
if (EnvGetClassId      ("Point",             McStat, &Point_Class))
if (EnvInitClassMap    (Point_Class,         sizeof(Point),
C_Apl,               McStat))
EnvInvokeMap       (C_Apl,               McStat);
Env_LoadGetTknCode (Point_Class, (funcptrtype  )pmf3,  McStat);
TRACK(TrackBak,"Point_InitClass\n");
return (STAT);
}
tokentype  Point_GetToken(Point   *This)
{
return (This->Token);
}
short      Point_x       (Point   *This)
{
return  (This->Point_x       (This));
}
short      Point_y      (Point          *This)
{
return  (This->Point_y       (This));
}
double     Point_Theta  (Point          *This)
{
return  (This->Point_Theta   (This));
}
double     Point_Radius (Point          *This)
{
return  (This->Point_Radius  (This));
}
boolean CartesianPoint_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset           = 0;
longaddr        StartAddr        = 0;
CartesianPoint  Point;
#ifdef __HP__
void*         (*pmf1)(size_t)  = &CartesianPoint_New;
#else
void*         (*pmf1)(size_t);
pmf1   = (void* (* )(size_t))CartesianPoint_New;
#endif
if (xCoord_Attr == 0)
{
if (EnvGetMemberId     ("xCoord",        McStat, &xCoord_Attr))
if (EnvGetMemberId     ("yCoord",        McStat, &yCoord_Attr))
EnvGetClassId      ("CartesianPoint",McStat, &CartesianPoint_Class);
}
StartAddr   = (longaddr)&Point;
if (Normal(*Status))
if (EnvInitClassMap    (CartesianPoint_Class,    sizeof(CartesianPoint),
C_Apl,               McStat))
{
Offset    = (size_t)((longaddr )&Point.That    -  StartAddr);
if (Env_AppendToMap    (That_AttrNum,          Offset,     McStat))
Offset = (size_t)((longaddr )&Point.Token   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Token_Attr,            Offset,     McStat))
Offset = (size_t)((longaddr )&Point.xCoord  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (xCoord_Attr,           Offset,     McStat))
Offset = (size_t)((longaddr )&Point.yCoord  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (yCoord_Attr,           Offset,     McStat))
Env_InvokeMap      (C_Apl,                             McStat);
}
if (Normal(*Status))
Env_LoadCreateCode  (CartesianPoint_Class, (funcptrtype )pmf1, McStat);
TRACK(TrackBak,"CartesianPoint_InitClass\n");
return (STAT);
}
CartesianPoint *CartesianPoint_New
(size_t        ClassSize)
{
CartesianPoint *Image       = NullPtr;
statustype      ShellStatus = Env_Normal;
ClassSize = sizeof (CartesianPoint);
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  CartesianPoint_New:: ClassSize= %2u \n",
ClassSize))
SendMsg (0, Msg);
if (Core0_MoreCore   ((bytessizetype )ClassSize,
ShellMcStat,               (addrtype *)&Image))
{
Image->Point_x      = CartesianPoint_x;
Image->Point_y      = CartesianPoint_y;
Image->Point_Theta  = CartesianPoint_Theta;
Image->Point_Radius = CartesianPoint_Radius;
}
return (Image);
}
CartesianPoint *CartesianPoint_new0
(tokentype    *AnchorTkn,
short         x,         short         y,
ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
CartesianPoint *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  CartesianPoint_New0 Anchor= [%4u:%6u] @ (%4u,%4u)\n",
AnchorTkn->DbId, AnchorTkn->Handle, x, y))
SendMsg (0, Msg);
if (Object_NewImage  (AnchorTkn,    CartesianPoint_Class,
McStat,      &Token,     (addrtype *)&Image))
{
Image->xCoord       = x;
Image->yCoord       = y;
Image->Point_x      = CartesianPoint_x;
Image->Point_y      = CartesianPoint_y;
Image->Point_Theta  = CartesianPoint_Theta;
Image->Point_Radius = CartesianPoint_Radius;
}
STAT;
return (Image);
}
CartesianPoint *CartesianPoint_new1
(tokentype    *PointTkn,  ft F,lt Z,zz *Status)
{
CartesianPoint *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  CartesianPoint_New1 Anchor= [%4u:%6u]\n",
PointTkn->DbId, PointTkn->Handle))
SendMsg (0, Msg);
if (Object_GetImage (PointTkn,      McStat,    (addrtype *)&Image))
{
Image->Point_x      = CartesianPoint_x;
Image->Point_y      = CartesianPoint_y;
Image->Point_Theta  = CartesianPoint_Theta;
Image->Point_Radius = CartesianPoint_Radius;
}
STAT;
return (Image);
}
short     CartesianPoint_x      (CartesianPoint   *This)
{
return This->xCoord;
}
short     CartesianPoint_y      (CartesianPoint   *This)
{
return This->yCoord;
}
double    CartesianPoint_Radius (CartesianPoint   *This)
{
return (sqrt(This->xCoord * This->xCoord
+ This->yCoord * This->yCoord));
}
double    CartesianPoint_Theta  (CartesianPoint   *This)
{
double Theta = 0.0;
if (This->xCoord == 0)
return (This->yCoord >= 0 ? (Dbl_Pie / 2) : (-Dbl_Pie/2));
Theta = atan (This->yCoord / This->xCoord);
if (This->xCoord >= 0)
{
if (This->yCoord >= 0)
return (Theta);
else
return (2 * Dbl_Pie + Theta);
} else
return (Dbl_Pie + Theta);
}
void  CartesianPoint_show (CartesianPoint *This)
{
longaddr       StartAddr = 0;
tokentype      Token     = This->Token;
sprintf (Msg, "\n CartsianPoint(*%3u) ::[%2u:%8u] \n",
sizeof(CartesianPoint), Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr          = (longaddr )This;
sprintf (Msg,  " this                  : @%x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  " This->That            : +%3d @%x   = %x\n",
(char *)&This->That - StartAddr,
&This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Token           : +%3d @%x   = [%2u:%8u]\n",
(char *)&This->Token - StartAddr, &This->Token,
This->Token.DbId,      This->Token.Handle );
TraceMsg (0, Msg);
sprintf (Msg,  " This->xCoord          : +%3d @%x   = %2u\n",
((char *)&(This->xCoord)) - StartAddr,
&This->xCoord, This->xCoord );
TraceMsg (0, Msg);
sprintf (Msg,  " This->yCoord          : +%3d @%x   = %2u\n",
(char *)&This->yCoord - StartAddr,
&This->yCoord, This->yCoord );
TraceMsg (0, Msg);
TraceMsg (0, "\n");
return;
}
boolean    CartesianPoint_delete
(CartesianPoint **This,   deletetype    DbEvent,
ft F,lt Z,zz    *Status)
{
CartesianPoint  *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  CartesianPoint_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " CartesianPoint[%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"CartesianPoint_delete\n");
return (STAT);
}
boolean PolarPoint_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
PolarPoint      Point;
#ifdef __HP__
void* (*pmf1)(size_t)  = &PolarPoint_New;
#else
void* (*pmf1)(size_t);
pmf1   = (void* (* )(size_t))PolarPoint_New;
#endif
if (Theta_Attr == 0)
{
if (EnvGetMemberId     ("Theta",              McStat, &Theta_Attr))
if (EnvGetMemberId     ("Radius",             McStat, &Radius_Attr))
EnvGetClassId      ("PolarPoint",         McStat, &PolarPoint_Class);
}
StartAddr   = (longaddr)&Point;
if (Normal(*Status))
if (EnvInitClassMap    (PolarPoint_Class,    sizeof(PolarPoint),
C_Apl,               McStat))
{
Offset    = (size_t)((longaddr )&Point.That    -  StartAddr);
if (Env_AppendToMap    (That_AttrNum,          Offset,     McStat))
Offset = (size_t)((longaddr )&Point.Token   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Token_Attr,            Offset,     McStat))
Offset = (size_t)((longaddr )&Point.Theta   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Theta_Attr,           Offset,     McStat))
Offset = (size_t)((longaddr )&Point.Radius  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Radius_Attr,           Offset,     McStat))
Env_InvokeMap      (C_Apl,                             McStat);
}
if (Normal(*Status))
Env_LoadCreateCode  (PolarPoint_Class, (funcptrtype  )pmf1,  McStat);
TRACK(TrackBak,"PolarPoint_InitClass\n");
return (STAT);
}
PolarPoint *PolarPoint_New
(size_t        ClassSize)
{
PolarPoint *Image       = NullPtr;
statustype  ShellStatus = Env_Normal;
ClassSize = sizeof (PolarPoint);
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  PolarPoint_New:: ClassSize= %2u \n",
ClassSize))
SendMsg (0, Msg);
if (Core0_MoreCore     ((bytessizetype )ClassSize,
ShellMcStat,              (addrtype *)&Image))
{
Image->Point_x      = PolarPoint_x;
Image->Point_y      = PolarPoint_y;
Image->Point_Theta  = PolarPoint_Theta;
Image->Point_Radius = PolarPoint_Radius;
}
return (Image);
}
PolarPoint *PolarPoint_new0
(tokentype    *AnchorTkn,
double        Theta,     double        Radius,
ft F,lt Z,zz *Status)
{
tokentype   Token  = NullToken;
PolarPoint *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  PolarPoint_New0 Anchor= [%4u:%6u] @ (%f,%f)\n",
AnchorTkn->DbId, AnchorTkn->Handle, Theta, Radius))
SendMsg (0, Msg);
if (Object_Create    (AnchorTkn,    PolarPoint_Class,
McStat,                              &Token))
if (Object_GetImage  (&Token,       McStat,    (addrtype *)&Image))
{
Image->Theta        = Theta;
Image->Radius       = Radius;
Image->Point_x      = PolarPoint_x;
Image->Point_y      = PolarPoint_y;
Image->Point_Theta  = PolarPoint_Theta;
Image->Point_Radius = PolarPoint_Radius;
}
STAT;
return (Image);
}
PolarPoint *PolarPoint_new1
(tokentype    *PointTkn,  ft F,lt Z,zz *Status)
{
PolarPoint *Image       = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  PolarPoint_New1 Anchor= [%4u:%6u]\n",
PointTkn->DbId, PointTkn->Handle))
SendMsg (0, Msg);
if (Object_GetImage (PointTkn,      McStat,    (addrtype *)&Image))
{
Image->Point_x      = PolarPoint_x;
Image->Point_y      = PolarPoint_y;
Image->Point_Theta  = PolarPoint_Theta;
Image->Point_Radius = PolarPoint_Radius;
}
STAT;
return (Image);
}
short     PolarPoint_x      (PolarPoint   *This)
{
return (short )(This->Radius * cos(This->Theta));
}
short     PolarPoint_y      (PolarPoint   *This)
{
return (short )(This->Radius * sin(This->Theta));
}
double    PolarPoint_Radius (PolarPoint   *This)
{
return This->Radius;
}
double    PolarPoint_Theta  (PolarPoint   *This)
{
return This->Theta;
}
void  PolarPoint_show (PolarPoint *This)
{
longaddr       StartAddr = 0;
tokentype      Token     = This->Token;
sprintf (Msg, "\n The  PolarPoint    MAP:: [%2u:%8u]\n",
sizeof(PolarPoint), Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr          = (longaddr )This;
sprintf (Msg,  " this                  : @%x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  " This->That            : +%3d @%x   = %x\n",
(char *)&This->That - StartAddr,
&This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Token           : +%3d @%x   = [%2u:%8u]\n",
(char *)&This->Token - StartAddr, &This->Token,
This->Token.DbId,      This->Token.Handle );
TraceMsg (0, Msg);
TraceMsg (0, Msg);
StartAddr          = (longaddr )This;
sprintf (Msg,  " This->Theta           : +%3d @%x   = %2u\n",
(char *)&This->Theta  - StartAddr,
&This->Theta,  This->Theta  );
TraceMsg (0, Msg);
sprintf (Msg,  " This->Radius          : +%3d @%x   = %2u\n",
(char *)&This->Radius - StartAddr,
&This->Radius, This->Radius );
TraceMsg (0, Msg);
TraceMsg (0, "\n");
return;
}
boolean    PolarPoint_delete
(PolarPoint **This,   deletetype    DbEvent,
ft F,lt Z,zz    *Status)
{
PolarPoint  *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  PolarPoint_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " PolarPoint[%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"PolarPoint_delete\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\primal.c*/

#define  PRIMAL_C
#ifndef INLINE_OMIDEFS
#else
#define        DbId_AttrNum               (numtype )3
#define        Id_AttrNum                 (numtype )143
#define        DbFileName_AttrNum         (numtype )158
#define        WenvDbs_Hndl            (handletype )698
#endif
#define MemGetObjNum         Mem_GetWord





#ifdef __ZTC__
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#else
#ifdef MCSTAT
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(Anchor->DbId <= MaxCoreDbId \
&& ((*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr)) ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#else
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#endif
#endif
boolean    Primal_CreateDb
(char         *SchemaName,char         *DbName,
char         *DbFileName,dbaccesstype  DbAccess,
numtype       HndlRgns,  numtype       RgnHndls,
numtype       VhndlRgns, numtype       RgnVhndls,
numtype       XmemRgns,  numtype       RgnXmems,
ft F,lt Z,zz *Status,    tokentype    *PrimalTkn)
{
TraceMsg (0, "  Primal_CreateDb Accessed !!!\n");
Alloc_Handles          = RgnHndls;
Extend_Handles         = HndlRgns;
Alloc_Vchunks          = RgnVhndls;
Extend_Vchunks         = VhndlRgns;
DbXmemBlocks_AllocQty  = RgnXmems;
DbXmemBlocks_ExtendQty = XmemRgns;
if (DbName  == NullPtr)
{
TraceMsg (0, "  Primal_CreateDb:: NULL DbName\n");
*Status  = Primal_NullDbName;
}
if (DbFileName  == NullPtr)
{
TraceMsg (0, "  Primal_CreateDb:: NULL DbFileName\n");
*Status  = Primal_NullDbFileName;
}
if (Normal(*Status))
if (!KernelFindIn   (WenvDbs_Hndl,     &WenvTkn,    (addrtype )DbName,
McStat,                                   PrimalTkn))
{
if (*Status == Set_NotFound)
{
*Status = Env_Normal;
ImageCreateDb  (SchemaName,  DbName,       DbFileName,   DbAccess,
McStat,      PrimalTkn);
}
} else {
Primal_ActivateDbByName (DbName, DbFileName, DbAccess,
McStat,             PrimalTkn);
*Status = Csh_DbAlreadyExists;
}
TRACK(TrackBak,"Primal_CreateDb\n");
return (STAT);
}
boolean   Primal_ActivateDbByName
(char         *DbName,    char         *DbFileName,
dbaccesstype  AccessType,
ft F,lt Z,zz *Status,    tokentype    *PrimalTkn)
{
return(False);
}
boolean   Primal_ActivateDbByToken
(tokentype    *PrimalTkn, char         *DbFileName,
dbaccesstype  AccessType,ft F,lt Z,zz *Status)
{
return(False);
}
boolean Primal_FreeDb    (tokentype    *PrimalTkn, ft F,lt Z,zz *Status)
{
*Status   = Err_NotImplemented;
return (STAT);
}
boolean Primal_CommitDb  (tokentype    *PrimalTkn, char         *DbFileName,
boolean       Release,   ft F,lt Z,zz *Status)
{
*Status   = Err_NotImplemented;
return (STAT);
}
boolean Primal_DeleteDb  (tokentype    *PrimalTkn, ft F,lt Z,zz *Status)
{
*Status   = Err_NotImplemented;
return (STAT);
}
boolean Primal_ConfigYourClass
(tokentype    *PrimalTkn, numtype       ClassId,
numtype       RgnEntrys,
numtype       AllocRgns, numtype       ExtendRgns,
numtype       AllocXs,   numtype       ExtendXs,
accesstype    AccessType,boolean       DiskCache,
numtype       CacheLimit,numtype       CacheLoad,
ft F,lt Z,zz *Status)
{
ImageConfigClass   (PrimalTkn,    ClassId,     RgnEntrys,    AllocRgns,
ExtendRgns,   AllocXs,     ExtendXs,     AccessType,
DiskCache,    CacheLimit,  CacheLoad,    McStat);
return (STAT);
}
boolean Primal_GetClassObjectCount
(tokentype    *PrimalTkn, numtype       ClassId,
ft F,lt Z,zz *Status,    numtype      *Count)
{
Image_GetClassObjectCount (PrimalTkn,  ClassId,    McStat,  Count);
TRACK(TrackBak,"Primal_GetClassObjectCount\n");
return (STAT);
}
boolean Primal_IterateOnClassObjects
(tokentype    *PrimalTkn, numtype       ClassId,
ft F,lt Z,zz *Status,
tokentype    *ItorTkn,   tokentype    *Token)
{
dbheader     *DbHdr        = NullPtr;
numtype       LocalObjNum  = 0;
boolean       NextObject   = False;
*Token   = NullToken;
if (*Status == Iterate_Begin)
{
*Status    = Env_Normal;
ItorTkn->Handle = 2;
if (TmGetCoreDb  (PrimalTkn,                McStat,         &DbHdr))
if (MemGetObjNum (DbHdr->LocalObjNumMap,    ClassId,
McStat,                  &LocalObjNum))
if (LocalObjNum == 0)
*Status          = Iterate_EndOf;
else
ItorTkn->DbId   = (idtype )LocalObjNum;
} else
TmGetCoreDb      (PrimalTkn,                McStat,         &DbHdr);
while (Normal(*Status)
&&     NextObject      == False
&&   ++ItorTkn->Handle  < DbHdr->NextHandle)
{
if (HmGetLocalObjNum (DbHdr,   ItorTkn->Handle,  McStat,  &LocalObjNum))
if (ItorTkn->DbId  == (idtype )LocalObjNum)
NextObject  = True;
}
if (*Status         == Iterate_EndOf)
return (False);
if (Normal(*Status))
if (NextObject      == False)
{
*Status           = Iterate_EndOf;
return (False);
} else {
Token->DbId      = PrimalTkn->DbId;
Token->Handle    = ItorTkn->Handle;
}
TRACK(TrackBak,"Primal_IterateOnClassObjects\n");
return (STAT);
}
boolean Primal_FreezeClass
(tokentype    *PrimalTkn, numtype       ClassId,
ft F,lt Z,zz *Status)
{
KernelFreezeObjClass      (PrimalTkn,     ClassId,      McStat);
TRACK(TrackBak,"PrimalFreezeClass\n");
return (STAT);
}
boolean Primal_FreeClass
(tokentype    *Token,     numtype       ClassId,
ft F,lt Z,zz *Status)
{
ImageFreeClassById   (C_Apl,   Token->DbId,  ClassId,   McStat);
TRACK(TrackBak,"Primal_FreeClass\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\pstub.c*/

#define  PSTUB
boolean CppCreateObject
(numtype    ObjNum,
ft F,lt Z,zz *Status, addrtype *CppObject);
boolean CppRefToTkn (addrtype      ThisObj, numtype      ObjNum,
ft F,lt Z,zz *Status,  tokentype   *ObjTkn);
boolean CppCastObject
(numtype       ObjNum,  numtype      BaseObjNum,
ft F,lt Z,zz *Status,  addrtype    *Object);
addrtype Image01_GetFreeStoreAddr
(void);
boolean CppCreateObject (numtype    ObjNum,
ft F,lt Z,zz *Status, addrtype *CppObject)
{
*CppObject = NullPtr;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, "  Alloc Object in OuterRealm... Class= %2u\n", ObjNum))
TraceMsg (0, Msg);
TRACK(TrackBak,"CppCreateObject\n");
return (STAT);
}
boolean CppRefToTkn     (addrtype      ThisObj, numtype      ObjNum,
ft F,lt Z,zz *Status,  tokentype   *ObjTkn)
{
*ObjTkn    = NullToken;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, "  CppRefToTkn... Class= %2u  @%x\n",
ObjNum,  ThisObj))
TraceMsg (0, Msg);
*Status    = Trans_CppShellNotInvoked;
strcpy (TrackBak, "CppRefToTkn\n");
return (False);
}
boolean CppCastObject   (numtype       ObjNum,  numtype      BaseObjNum,
ft F,lt Z,zz *Status,  addrtype    *Object)
{
*Object = NullPtr;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, " Cast Object of class= %4u To Base Class= %4u\n",
ObjNum, BaseObjNum))
TraceMsg (0, Msg);
strcpy (TrackBak, "CppCastObject\n");
return (STAT);
}
addrtype Image01_GetFreeStoreAddr   (void)
{
return (NullPtr);
}
/* 当前文件是./CINT2000\255.vortex\src\query.c*/

#define  QUERY



#define   Mem_GetObjNum   Mem_GetWord
#ifdef __ZTC__
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#else
#ifdef MCSTAT
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(Anchor->DbId <= MaxCoreDbId \
&& ((*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr)) ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#else
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#endif
#endif
#ifdef __NOSTR__

//  char *strpbrk (char *s1,  char *s2)
//  {
//
//   return (s1);
//  }
#endif
boolean    Query_Create
(ft F,lt Z,zz  *Status,      dbmsquery    **DbmsQuery)
{
dbmsquery    *Query        = NullPtr;
static boolean       FirstTime    = True;
static bytessizetype TknsSize     = 0;
if (CoreMoreCore     (sizeof (dbmsquery),
McStat,       (addrtype *)&Query))
if (Mem_MakeChunk    (sizeof (numtype),         200, 100, 0,
McStat,                   &Query->ClassStack))
if (Mem_GetChunkAddr (Query->ClassStack,
McStat,       (addrtype *)&Query->ClassSet))
if (Mem_MakeChunk    (sizeof (querysort),        10, 10, 0,
McStat,                   &Query->SortStack))
if (Mem_GetChunkAddr (Query->SortStack,
McStat,       (addrtype *)&Query->SortSet))
if (Mem_MakeChunk    (sizeof (querycomd),        100, 20, 0,
McStat,                   &Query->ComdStack))
if (Mem_GetChunkAddr (Query->ComdStack,
McStat,       (addrtype *)&Query->ComdSet))
if (Mem_MakeChunk    (sizeof (queryfield),       100, 20, 0,
McStat,                   &Query->FieldStack))
if (Mem_GetChunkAddr (Query->FieldStack,
McStat,       (addrtype *)&Query->Fields))
if (Mem_MakeChunk    (sizeof (bytetype),         4048, 1024, 0,
McStat,                   &Query->ValueStack))
if (Mem_GetChunkAddr (Query->ValueStack,
McStat,       (addrtype *)&Query->Values))
{
Query->EnvType        = NullPtr;
Query->ClassId        = 0;
Query->MapIsActive    = False;
Query->CendentsOk     = False;
Query->NumClasses     = 0;
Query->NumSorts       = 0;
Query->NumComds       = 0;
Query->NumFields      = 0;
Query->NumValues      = 0;
Query->NumOpens       = 0;
Query->NumCloses      = 0;
Query->LocalBitVec    = NullPtr;
Query->ResultsDir     = NullToken;
Query->NumResults     = 0;
Query->SortTknsDir    = 0;
*DbmsQuery             = Query;
}
if (Normal(*Status))
if (FirstTime)
{
TknsSize    = sizeof (fieldspec) * 10;
FirstTime   = False;
Core_MoreCore  (TknsSize, McStat,  (addrtype *)&EnvField.FieldTkns);
}
TRACK(TrackBak,"Query_Create\n");
return(STAT);
}
boolean    Query_BeginBuild
(dbmsquery     *Query,       ft F,lt Z,zz  *Status)
{
if (Query->ClassId
||  Query->NumFields)
{
Query->ClassId        = 0;
Query->MapIsActive    = False;
Query->CendentsOk     = False;
Query->NumClasses     = 0;
Query->NumSorts       = 0;
Query->NumComds       = 0;
Query->NumFields      = 0;
Query->NumValues      = 0;
Query->NumOpens       = 0;
Query->NumCloses      = 0;
Query->NumResults     = 0;
Query->ResultsDir     = NullToken;
Query->SortTknsDir    = 0;
if (Mem_PutStackPtr (Query->ClassStack,  0,  McStat))
if (Mem_PutStackPtr (Query->SortStack,   0,  McStat))
if (Mem_PutStackPtr (Query->ComdStack,   0,  McStat))
if (Mem_PutStackPtr (Query->FieldStack,  0,  McStat))
Mem_PutStackPtr (Query->ValueStack,  0,  McStat);
}
TRACK(TrackBak,"Query_BeginBuild\n");
return(STAT);
}
boolean    Query_ScopeOn
(dbmsquery     *Query,       char          *Class,
boolean        CendentsOk,  ft F,lt Z,zz  *Status)
{
if (Env_GetClassId     (Class,     McStat,  &Query->ClassId))
Query1_ScopeOn     (Query,     Query->ClassId,  CendentsOk,  McStat);
TRACK(TrackBak,"Query_ScopeOn\n");
return(STAT);
}
boolean    Query1_ScopeOn
(dbmsquery     *Query,       numtype        ClassId,
boolean        CendentsOk,  ft F,lt Z,zz  *Status)
{
tokentype     BitFieldTkn  = NullToken;
bitfieldtype *BitField     = NullPtr;
numtype       BitNum       = 0;
indextype     ByteCount    = 0;
Query->ClassId       = ClassId;
Query->CendentsOk    = CendentsOk;
Query->NumClasses    = 1;
if (Mem_AssertStackPtr (Query->ClassStack,   Query->NumClasses,
McStat, (addrtype *)&Query->ClassSet))
{
Query->ClassSet[0]    = ClassId;
if (Trans_MapIsActive  (ClassId,   McStat))
Query->MapIsActive = True;
}
if (Normal(*Status))
if (CendentsOk)
if (Env_FetchObjCendents (ClassId,   McStat,    &BitFieldTkn))
if (BitFieldTkn.Handle
&&  BitFieldTkn.DbId)
{
if (OaGetVchunkAddr (&BitFieldTkn, McStat,  (addrtype *)&BitField))
if (OaGetVchunkStackPtr
(&BitFieldTkn, McStat,  &ByteCount))
for (BitNum = 0; (++BitNum / 8)  <  ByteCount; )
{
if ( (BitField[BitNum >> 3] & 1 << (BitNum & 7)) )
{
if (Mem_AssertStackPtr (Query->ClassStack,   Query->NumClasses+1,
McStat, (addrtype *)&Query->ClassSet))
Query->ClassSet[Query->NumClasses++] = BitNum;
}
}
} else
Query->CendentsOk    = False;
TRACK(TrackBak,"Query1_ScopeOn\n");
return(STAT);
}
boolean    Query_SortBy
(dbmsquery     *Query,       char          *Member,
sortorder      SortOrder,   ft F,lt Z,zz  *Status)
{
numtype   AttrId   = 0;
if (Env_GetAttrId     (Member,     McStat,  &AttrId))
Query1_SortBy      (Query,      AttrId,   SortOrder,   McStat);
TRACK(TrackBak,"Query_SortBy\n");
return(STAT);
}
boolean    Query1_SortBy
(dbmsquery     *Query,       numtype        AttrId,
sortorder      SortOrder,   ft F,lt Z,zz  *Status)
{
querysort  SortObj;
numtype    RefObjNum  = 0;
numtype    AplId      = C_Apl;
numtype    SubLevel   = 1;
fieldspec  FieldTkns;
indextype  StackPtr   = 0;
envclass   RefType    = aNonEnvClass;
FieldTkns.AttrId        = AttrId;
FieldTkns.Index         = 0;
SortObj.BaseOffset1     = 0;
SortObj.FieldOffset1    = 0;
SortObj.ValueClass      = aVoid;
if (Query->MapIsActive)
Trans_FetchObjFieldSpec   (Query->ClassId, AplId,&FieldTkns,  SubLevel,
McStat,               &SortObj.UnitSize,
&AttrId,               &SortObj.AttrType,
&RefObjNum,            &SortObj.UnitType,
&SortObj.FieldOffset0, &SortObj.FieldOffset1,
&SortObj.BaseOffset0,  &SortObj.BaseOffset1);
else
Env_FetchObjAttrSpec      (Query->ClassId,        AttrId,     McStat,
&SortObj.AttrType,     &RefObjNum, &RefType,
&SortObj.UnitSize,     &SortObj.UnitType,
&SortObj.ValueClass,   &SortObj.BaseOffset0);
if (Normal(*Status))
{
SortObj.BaseAttr     = AttrId;
SortObj.FieldAttr    = SortObj.BaseAttr;
SortObj.FieldOffset0 = SortObj.BaseOffset0;
SortObj.SortOrder    = SortOrder;
Query->NumSorts++;
SortObj.SeqNum       = Query->NumSorts;
Mem_PushSomeBytes     (Query->SortStack,    sizeof (querysort),
(addrtype )&SortObj, McStat,  &StackPtr);
}
TRACK(TrackBak,"Query1_SortBy\n");
return(STAT);
}
boolean    Query_OpenParen
(dbmsquery     *Query,       ft F,lt Z,zz  *Status)
{
querycomd    ComdObj;
indextype    StackPtr   = 0;
ComdObj.ComdType     = aBeginExp;
ComdObj.QueryField   = 0;
ComdObj.BoolOp       = aNullBoolOp;
ComdObj.TrueJump     = 0;
ComdObj.FalseJump    = 0;
Query->OpenComds[Query->NumOpens++] = Query->NumComds;
Query->NumComds++;
Mem_PushSomeBytes        (Query->ComdStack,    sizeof (querycomd),
(addrtype )&ComdObj, McStat, &StackPtr);
TRACK(TrackBak,"Query_OpenParen\n");
return(STAT);
}
boolean    Query_AffixCompare
(dbmsquery     *Query,       char          *Member,
compareop      CompOp,      addrtype       Value,
ft F,lt Z,zz  *Status)
{
numtype   AttrId  = 0;
char     *StrSeg  = NullPtr;
if (Query  == NullPtr)
*Status  = Env_NullPtr;
if (Normal(*Status))
if ((StrSeg   = strpbrk (Member,  FieldOps)) == NULL)
{
if (Env_GetAttrId       (Member,     McStat,  &AttrId))
Query1_AffixCompare  (Query,      AttrId,   CompOp,  Value,  McStat);
} else {
if (Env_GetFieldStruc   (Member,     McStat,  &EnvField))
Query2_AffixCompare  (Query,      EnvField.FieldTkns,
EnvField.SubLevel,    CompOp,  Value,  McStat);
}
TRACK(TrackBak,"Query_AffixCompare\n");
return(STAT);
}
boolean    Query1_AffixCompare
(dbmsquery     *Query,       numtype        AttrId,
compareop      CompOp,      addrtype       Value,
ft F,lt Z,zz  *Status)
{
queryfield    FldObj;
querycomd     ComdObj;
numtype       RefObjNum  = 0;
numtype       AplId      = C_Apl;
numtype       SubLevel   = 1;
fieldspec     FieldTkns;
indextype     StackPtr   = 0;
char         *StrValue   = NullPtr;
tokentype     AttrTkn    = NullToken;
attrdesctype *AttrDesc   = NullPtr;
tokentype     BldDescTkn = NullToken;
objdesctype  *BldDesc    = NullPtr;
sizetype      TknOffset  = 0;
sizetype      FldOffset  = 0;
envclass      RefType    = aNonEnvClass;
FieldTkns.AttrId        = AttrId;
FieldTkns.Index         = 0;
FldObj.BaseOffset1      = 0;
FldObj.FieldOffset1     = 0;
FldObj.ValueClass       = aVoid;
FldObj.IsValueAssert    = False;
if (Query->MapIsActive)
Trans_FetchObjFieldSpec   (Query->ClassId, AplId,&FieldTkns,  SubLevel,
McStat,               &FldObj.UnitSize,
&AttrId,               &FldObj.AttrType,
&RefObjNum,            &FldObj.UnitType,
&FldObj.FieldOffset0,  &FldObj.FieldOffset1,
&FldObj.BaseOffset0,   &FldObj.BaseOffset1);
else
Env_FetchObjAttrSpec      (Query->ClassId,        AttrId,     McStat,
&FldObj.AttrType,      &RefObjNum,  &RefType,
&FldObj.UnitSize,      &FldObj.UnitType,
&FldObj.ValueClass,    &FldObj.BaseOffset0);
if (Normal(*Status))
Query_CheckType           (Query->ClassId,  AttrId,   FldObj.AttrType,
Value,           CompOp,   McStat);
if (Normal(*Status))
if (FldObj.AttrType  == aObjRefAttr)
{
AttrTkn.DbId       = RenvId;
if (EnvFetchAttrHandle (AttrId,      McStat,      &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,  (addrtype *)&AttrDesc))
{
BldDescTkn.DbId          =  RenvId;
BldDescTkn.Handle        =  AttrDesc->BuildDesc;
if (OaGetObject     (&BldDescTkn,  McStat,  (addrtype *)&BldDesc))
if (Env_FetchObjAttrOffset
(Query->MapIsActive,
BldDesc->ObjNum,      Token_Attr,
McStat,              &TknOffset))
if (Mem_PushEntity  (Query->ValueStack,   sizeof (addrtype), Value,
McStat,             &FldObj.ValueOffset))
Mem_PushEntity  (Query->ValueStack,   sizeof (sizetype),
(addrtype )&TknOffset,
McStat,             &FldOffset);
Query->NumValues++;
}
} else if (FldObj.UnitType   != aString) {
Mem_PushEntity      (Query->ValueStack,   FldObj.UnitSize,     Value,
McStat,             &FldObj.ValueOffset);
} else {
StrValue            = *(char **)Value;
FldObj.UnitSize     = strlen (StrValue) + 1;
Mem_PushEntity      (Query->ValueStack,   FldObj.UnitSize,     StrValue,
McStat,             &FldObj.ValueOffset);
}
if (Normal(*Status))
{
Query->NumValues++;
FldObj.BaseAttr      = AttrId;
FldObj.FieldAttr     = FldObj.BaseAttr;
FldObj.FieldOffset0  = FldObj.BaseOffset0;
FldObj.CompOp        = CompOp;
Query->NumFields++;
FldObj.SeqNum        = Query->NumFields;
Mem_PushSomeBytes   (Query->FieldStack,  sizeof (queryfield),
(addrtype )&FldObj, McStat,  &StackPtr);
}
if (Normal(*Status))
{
ComdObj.ComdType     = aCompareOp;
ComdObj.QueryField   = Query->NumFields - 1;
ComdObj.BoolOp       = aNullBoolOp;
ComdObj.TrueJump     = 0;
ComdObj.FalseJump    = 0;
Query->NumComds++;
Mem_PushSomeBytes      (Query->ComdStack,    sizeof (querycomd),
(addrtype )&ComdObj, McStat, &StackPtr);
}
if (Normal(*Status))
if (ClassBug || DeBug)
{
Query_DumpComdObj  (&ComdObj);
Query_DumpFieldObj (Query,     &FldObj);
}
TRACK(TrackBak,"Query1_AffixCompare\n");
return(STAT);
}
boolean    Query2_AffixCompare
(dbmsquery     *Query,       fieldspec      FieldTkns[],
numtype        SubLevel,
compareop      CompOp,      addrtype       Value,
ft F,lt Z,zz  *Status)
{
queryfield FldObj;
querycomd  ComdObj;
numtype    RefObjNum  = 0;
numtype    AttrId     = 0;
numtype    AplId      = C_Apl;
indextype  StackPtr   = 0;
FldObj.BaseOffset1      = 0;
FldObj.FieldOffset1     = 0;
FldObj.ValueClass       = aVoid;
FldObj.IsValueAssert   = False;
if (Query->MapIsActive)
Trans_FetchObjFieldSpec   (Query->ClassId, AplId, FieldTkns,  SubLevel,
McStat,               &FldObj.UnitSize,
&AttrId,               &FldObj.AttrType,
&RefObjNum,            &FldObj.UnitType,
&FldObj.FieldOffset0,  &FldObj.FieldOffset1,
&FldObj.BaseOffset0,   &FldObj.BaseOffset1);
else
Env_FetchObjFieldSpec     (Query->ClassId,        FieldTkns,  SubLevel,
McStat,               &FldObj.UnitSize,
&AttrId,               &FldObj.AttrType,
&RefObjNum,            &FldObj.UnitType,
&FldObj.FieldOffset0,  &FldObj.BaseOffset0);
if (Normal(*Status))
Query_CheckType           (Query->ClassId,  AttrId,   FldObj.AttrType,
Value,           CompOp,   McStat);
if (Normal(*Status))
if (FldObj.UnitType   != aString)
{
Mem_PushEntity      (Query->ValueStack,   FldObj.UnitSize,     Value,
McStat,             &FldObj.ValueOffset);
} else {
FldObj.UnitSize     = strlen  ((char *)Value) + 1;
Mem_PushEntity      (Query->ValueStack,   FldObj.UnitSize,     Value,
McStat,             &FldObj.ValueOffset);
}
if (Normal(*Status))
{
Query->NumValues++;
FldObj.BaseAttr      = FieldTkns[0].AttrId;
FldObj.FieldAttr     = AttrId;
FldObj.CompOp        = CompOp;
Query->NumFields++;
FldObj.SeqNum        = Query->NumFields;
Mem_PushSomeBytes        (Query->FieldStack,      sizeof (queryfield),
(addrtype )&FldObj, McStat, &StackPtr);
}
if (Normal(*Status))
{
ComdObj.ComdType     = aCompareOp;
ComdObj.QueryField   = Query->NumFields - 1;
ComdObj.BoolOp       = aNullBoolOp;
ComdObj.TrueJump     = 0;
ComdObj.FalseJump    = 0;
Query->NumComds++;
Mem_PushSomeBytes      (Query->ComdStack,    sizeof (querycomd),
(addrtype )&ComdObj, McStat, &StackPtr);
}
TRACK(TrackBak,"Query2_AffixCompare\n");
return(STAT);
}
boolean    Query_AffixRefQuery
(dbmsquery     *Query,       char          *Member,
dbmsquery     *SubQuery,    ft F,lt Z,zz  *Status)
{
numtype   AttrId  = 0;
char     *StrSeg  = NullPtr;
if (Query  == NullPtr)
*Status  = Env_NullPtr;
if (Normal(*Status))
if ((StrSeg   = strpbrk (Member,  FieldOps)) == NULL)
{
if (Env_GetAttrId       (Member,     McStat,  &AttrId))
Query1_AffixRefQuery (Query,      AttrId,   SubQuery,  McStat);
} else {
*Status = Err_NotImplemented;
}
TRACK(TrackBak,"Query_AffixRefQuery\n");
return(STAT);
}
boolean    Query1_AffixRefQuery
(dbmsquery     *Query,       numtype        AttrId,
dbmsquery     *SubQuery,    ft F,lt Z,zz  *Status)
{
queryfield    FldObj;
querycomd     ComdObj;
numtype       RefObjNum  = 0;
numtype       AplId      = C_Apl;
numtype       SubLevel   = 1;
fieldspec     FieldTkns;
indextype     StackPtr   = 0;
tokentype     AttrTkn    = NullToken;
attrdesctype *AttrDesc   = NullPtr;
tokentype     BldDescTkn = NullToken;
objdesctype  *BldDesc    = NullPtr;
envclass      RefType    = aNonEnvClass;
AttrTkn.DbId            = RenvId;
FieldTkns.AttrId        = AttrId;
FieldTkns.Index         = 0;
FldObj.BaseOffset1      = 0;
FldObj.FieldOffset1     = 0;
FldObj.ValueClass       = aVoid;
FldObj.IsValueAssert    = False;
if (Query->MapIsActive)
Trans_FetchObjFieldSpec   (Query->ClassId, AplId,&FieldTkns,  SubLevel,
McStat,               &FldObj.UnitSize,
&AttrId,               &FldObj.AttrType,
&RefObjNum,            &FldObj.UnitType,
&FldObj.FieldOffset0,  &FldObj.FieldOffset1,
&FldObj.BaseOffset0,   &FldObj.BaseOffset1);
else
Env_FetchObjAttrSpec      (Query->ClassId,        AttrId,     McStat,
&FldObj.AttrType,      &RefObjNum, &RefType,
&FldObj.UnitSize,      &FldObj.UnitType,
&FldObj.ValueClass,    &FldObj.BaseOffset0);
if (Normal(*Status))
if (FldObj.AttrType  == aObjRefAttr
||  FldObj.AttrType  == aTknRefAttr)
{
if (EnvFetchAttrHandle (AttrId,      McStat,      &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,    McStat,  (addrtype *)&AttrDesc))
{
BldDescTkn.DbId          =  RenvId;
BldDescTkn.Handle        =  AttrDesc->BuildDesc;
if (OaGetObject     (&BldDescTkn,  McStat,  (addrtype *)&BldDesc))
if (BldDesc->ObjNum     == SubQuery->ClassId)
Mem_PushEntity  (Query->ValueStack,   sizeof (addrtype),
(addrtype )&SubQuery,
McStat,             &FldObj.ValueOffset);
else {
*Status  = Query_BadSubQueryClassId;
sprintf (Msg,
" Query1_AffixRefQuery:: RefClass(%4u) Must be Same As Member RefType(%4u)\n",
SubQuery->ClassId, BldDesc->ObjNum);
TraceMsg (0, Msg);
}
}
} else {
*Status = Query_AttrNotReference;
TraceMsg (0,
" Query1_AffixRefQuery:: Attribute Must be of type reference to\n");
sprintf (Msg, "     for ClassId=%4u; AttrId=%4u.\n",
Query->ClassId, AttrId);
TraceMsg (0, Msg);
}
if (Normal(*Status))
{
Query->NumValues++;
FldObj.BaseAttr      = AttrId;
FldObj.FieldAttr     = FldObj.BaseAttr;
FldObj.FieldOffset0  = FldObj.BaseOffset0;
FldObj.CompOp        = aEQ;
Query->NumFields++;
FldObj.SeqNum        = Query->NumFields;
Mem_PushSomeBytes   (Query->FieldStack,  sizeof (queryfield),
(addrtype )&FldObj, McStat,  &StackPtr);
}
if (Normal(*Status))
{
ComdObj.ComdType     = aSubQuery;
ComdObj.QueryField   = Query->NumFields - 1;
ComdObj.BoolOp       = aNullBoolOp;
ComdObj.TrueJump     = 0;
ComdObj.FalseJump    = 0;
Query->NumComds++;
Mem_PushSomeBytes      (Query->ComdStack,    sizeof (querycomd),
(addrtype )&ComdObj, McStat, &StackPtr);
}
if (Normal(*Status))
if (ClassBug || DeBug)
{
Query_DumpComdObj  (&ComdObj);
Query_DumpFieldObj (Query,     &FldObj);
}
TRACK(TrackBak,"Query1_AffixRefQuery\n");
return(STAT);
}
boolean    Query_AffixBoolOp
(dbmsquery     *Query,       booleanop      BoolOp,
ft F,lt Z,zz  *Status)
{
querycomd  ComdObj;
indextype  StackPtr   = 0;
if (ClassBug || DeBug)
if (sprintf (Msg, "\n   Query_AffixBoolOp:: @%6x\n",
Query))
TraceMsg (0, Msg);
ComdObj.ComdType     = aBooleanOp;
ComdObj.QueryField   = 0;
ComdObj.BoolOp       = BoolOp;
ComdObj.TrueJump     = 0;
ComdObj.FalseJump    = 0;
Query->NumComds++;
Mem_PushSomeBytes        (Query->ComdStack,    sizeof (querycomd),
(addrtype )&ComdObj, McStat, &StackPtr);
TRACK(TrackBak,"Query_AffixBoolOp\n");
return(STAT);
}
boolean    Query_CloseParen
(dbmsquery     *Query,       ft F,lt Z,zz  *Status)
{
querycomd  ComdObj;
indextype  StackPtr   = 0;
numtype    Index      = 0;
if (ClassBug || DeBug)
if (sprintf (Msg, "\n   Query_CloseParen:: @%6x\n",
Query))
TraceMsg (0, Msg);
ComdObj.ComdType     = aEndExp;
ComdObj.QueryField   = 0;
ComdObj.BoolOp       = aNullBoolOp;
ComdObj.TrueJump     = 0;
ComdObj.FalseJump    = 0;
Index                = Query->NumOpens - Query->NumCloses - 1;
Query->CloseComds[Query->NumCloses++]  = Query->OpenComds[Index];
Query->OpenComds[Index]                = Query->NumComds;
Query->NumComds++;
Mem_PushSomeBytes        (Query->ComdStack,    sizeof (querycomd),
(addrtype )&ComdObj, McStat, &StackPtr);
TRACK(TrackBak,"Query_CloseParen\n");
return(STAT);
}
boolean    Query_EndBuild
(dbmsquery     *Query,       ft F,lt Z,zz  *Status)
{
int        i          = 0;
int        j          = 0;
numtype    NumOpens   = 0;
numtype    Jump       = 0;
queryop    QueryOp    = aNonQueryOp;
if (ClassBug || DeBug)
if (sprintf (Msg, "\n   Query_EndBuild:: @%6x\n",
Query))
TraceMsg (0, Msg);
i = 0;
while (i < Query->NumComds)
{
i++;
QueryOp                       = Query->ComdSet[i-1].ComdType;
Query->ComdSet[i-1].SeqNum    = i;
switch (QueryOp)
{
case  aIsA               :
break;
case  aIsKindOf          :
break;
case  aCompareOp         :
break;
case  aSubQuery          :
break;
case  aBooleanOp         :
Jump                = Query->OpenComds[NumOpens - 1];
if (Normal(*Status))
{
switch (Query->ComdSet[i-1].BoolOp)
{
case  aNullBoolOp  :
break;
case  aAND         :
Query->ComdSet[i-1].TrueJump  = i;
Query->ComdSet[i-1].FalseJump = Jump;
break;
case  aOR          :
Query->ComdSet[i-1].FalseJump = i;
Query->ComdSet[i-1].TrueJump  = Jump;
break;
case  aExOR        :
break;
case  aNOT         :
break;
case  aNAND        :
break;
case  aNOR         :
break;
case  aNxOR        :
break;
}
}
break;
case  aBeginExp          :
++NumOpens;
Jump                = Query->OpenComds[NumOpens - 1];
break;
case  aEndExp            :
--NumOpens;
break;
case  aPushBool          :
j = 0;
break;
case  aPopBool           :
j = 0;
break;
case  aJumpSwi           :
j = 0;
break;
case  aEndQuery          :
j = 0;
break;
case  aClearStack        :
j = 0;
break;
default                  :
j = 0;
}
}
TRACK(TrackBak,"Query_EndBuild\n");
return(STAT);
}
boolean    Query_AssertOnObject
(tokentype     *Token,       dbmsquery     *Query,
ft F,lt Z,zz  *Status)
{
dbheader   *CoreDb         = NullPtr;
addrtype    Object         = NullPtr;
addrtype    DbObject       = NullPtr;
numtype     MemLoc         = 0;
numtype     EnvObj         = 0;
numtype     LocalObj       = 0;
boolean     ComputeBase    = False;
querycomd   ComdObj;
queryfield  FieldObj;
boolean     EvalStack[20];
numtype     NumEvals       = 0;
int         i              = 0;
boolean     Eval           = True;
sizetype    BaseOffset0    = 0;
sizetype    BaseOffset1    = 0;
addrtype    FieldAddr      = NullPtr;
sizetype    FieldOffset    = 0;
addrtype    ValueAddr      = NullPtr;
numtype     NumOpens       = 0;
numtype     NumCloses      = 0;
boolean     BoolVal        = False;
boolean     BoolVal0       = False;
tokentype   VchunkTkn      = NullToken;
tokentype   RefTkn         = NullToken;
tokentype   OwnerTkn       = NullToken;
tokentype   MemberTkn      = NullToken;
tokentype   NodeTkn        = NullToken;
boolean     ArrayIsA       = False;
addrtype    BytePtr        = NullPtr;
longaddr    Offset         = 0;
dbmsquery  *Query0         = NullPtr;
indextype   StackPtr       = 0;
indextype   StrIndex       = 0;
objheader  *ObjHdr         = NullPtr;
numtype     NumAsserts     = 0;
numtype     SetId          = 0;
numtype     ItNum          = 0;
if (Query  == NullPtr)
*Status  = Env_NullPtr;
if (ClassBug)
if (sprintf(Msg, "\n  Query_AssertOnObject::  [%3u:%4u]\n",
Token->DbId, Token->Handle))
if (TraceMsg (0, Msg))
OaDumpObject (0, Token, McStat);
if (Normal(*Status))
if (TmGetCoreDb          (Token,                   McStat,   &CoreDb))
if (HmGetObjectAddr      (CoreDb,  Token->Handle,  McStat,   &Object))
if (Object  == NullPtr)
{
if (ClassBug)
if (sprintf(Msg, "\n  Query_AssertOnObject::  [%3u:%4u] Was Deleted.\n",
Token->DbId, Token->Handle))
TraceMsg (0, Msg);
return (False);
}
if (Normal(*Status))
if (HmGetObjectMemLoc    (CoreDb,  Token->Handle,  McStat,   &MemLoc))
if (HmGetObjNum          (CoreDb,  Token->Handle,  McStat,   &EnvObj))
if (EnvObj             != Query->ClassId)
{
ComputeBase         = True;
if (ClassBug)
if (sprintf(Msg, "    EnvObj =%4u; BaseClass =%4u;\n",
EnvObj, Query->ClassId))
TraceMsg (0, Msg);
}
while (Normal(*Status)
&&     i                < Query->NumComds
&&     Eval)
{
ComdObj  = Query->ComdSet[i];
FieldObj = Query->Fields[ComdObj.QueryField];
switch (ComdObj.ComdType)
{
case    aIsA         :
if (EnvObj == ComdObj.QueryField)
EvalStack[NumEvals++] = True;
else
EvalStack[NumEvals++] = False;
break;
case    aIsKindOf    :
BoolVal = False;
for (i = 0; i < Query->NumClasses && BoolVal == False; i++)
{
if (Query->ClassSet[i] == ComdObj.QueryField)
{
BoolVal  = True;
}
}
EvalStack[NumEvals++] = BoolVal;
break;
case    aCompareOp   :
case    aSubQuery    :
if (MemLoc  == 0)
{
if (ComputeBase)
{
Env_FetchObjAttrOffset(MemLoc,
EnvObj,     FieldObj.BaseAttr,
McStat,    &BaseOffset0);
FieldOffset          = FieldObj.FieldOffset0
- FieldObj.BaseOffset0
+ BaseOffset0;
} else
FieldOffset          = FieldObj.FieldOffset0;
} else {
if (ComputeBase)
{
Trans_FetchAttrOffsets
(EnvObj,  C_Apl,  FieldObj.BaseAttr,
McStat, &BaseOffset0, &BaseOffset1);
FieldOffset          = FieldObj.FieldOffset1
- FieldObj.BaseOffset1
+ BaseOffset1;
} else
FieldOffset          = FieldObj.FieldOffset1;
}
FieldAddr    = (addrtype )((char *)Object        + FieldOffset);
ValueAddr    = (addrtype )((char *)Query->Values
+ FieldObj.ValueOffset);
if (Normal(*Status))
if (MemLoc == 0)
{
switch (FieldObj.AttrType)
{
case aObjRefAttr   :
case aTknRefAttr   :
RefTkn            = *(tokentype  *)FieldAddr;
break;
case aVchunkAttr   :
VchunkTkn         = *(tokentype  *)FieldAddr;
ArrayIsA          = True;
break;
case aChunkAttr    :
case aVarrayAttr   :
case aArrayAttr    :
case aDblPtrAttr   :
VchunkTkn.DbId    = Token->DbId;
VchunkTkn.Handle  = *(handletype *)FieldAddr;
ArrayIsA          = True;
break;
}
} else {
switch (FieldObj.AttrType)
{
case aTknRefAttr   :
BytePtr     = (addrtype )((char *)FieldAddr
+ sizeof (addrtype));
MoveBytes     (BytePtr,  (addrtype )&RefTkn,
sizeof (tokentype));
break;
case aObjRefAttr   :
Offset      = (longaddr )((char *)ValueAddr
+ FieldObj.ValueOffset);
BytePtr     = (addrtype )((char *)FieldAddr   + Offset);
MoveBytes     (BytePtr,  (addrtype )&RefTkn,
sizeof (tokentype));
break;
case aVchunkAttr   :
case aChunkAttr    :
case aVarrayAttr   :
ArrayIsA    = True;
VchunkTkn   = *(tokentype  *)FieldAddr;
break;
case aArrayAttr    :
case aDblPtrAttr   :
ArrayIsA       = True;
if (OaRevokeCppObject (Token,                 McStat))
if (OaGetObject       (Token,   McStat,      &DbObject))
{
if (ComputeBase)
{
Env_FetchObjAttrOffset
(MemLoc,
EnvObj,  FieldObj.BaseAttr,
McStat,          &BaseOffset0);
FieldOffset    = FieldObj.FieldOffset0
- FieldObj.BaseOffset0
+ BaseOffset0;
} else
FieldOffset    = FieldObj.FieldOffset0;
FieldAddr         = (addrtype )((char *)DbObject
+ FieldOffset);
VchunkTkn.Handle  = *(handletype *)FieldAddr;
if (Normal(*Status))
OaInvokeCppObject (Token,   Object,       McStat);
}
break;
}
}
if (Normal(*Status))
if (ArrayIsA)
{
Offset      = (longaddr )((char *)ValueAddr
+ FieldObj.ValueOffset);
BytePtr     = (addrtype )((char *)FieldAddr   + Offset);
MoveBytes     (BytePtr,  (addrtype )&NumAsserts,
sizeof (numtype));
BytePtr     = (addrtype )((char *)BytePtr  + sizeof (numtype));
MoveBytes     (BytePtr,  (addrtype )&Query0,
sizeof (addrtype));
StackPtr           = 0;
if (Vchunk_IsValidToken  (&VchunkTkn,  McStat))
Vchunk_GetStackPtr   (&VchunkTkn,  McStat,  &StackPtr);
if (FieldObj.IsValueAssert)
{
if (StackPtr == 0)
EvalStack[NumEvals++] = False;
else
;
} else {
EvalStack[NumEvals++] = Query_CompareValue
(aAttr,     aInteger,  sizeof (indextype),
FieldObj.ValueClass,
(addrtype )&StackPtr, FieldObj.CompOp,
ValueAddr,            McStat);
}
} else if (FieldObj.AttrType   == aSetHeadAttr)  {
Offset      = (longaddr )((char *)ValueAddr
+ FieldObj.ValueOffset);
BytePtr     = (addrtype )((char *)FieldAddr   + Offset);
MoveBytes     (BytePtr,  (addrtype )&NumAsserts,
sizeof (numtype));
BytePtr     = (addrtype )((char *)BytePtr  + sizeof (numtype));
MoveBytes     (BytePtr,  (addrtype )&Query0,
sizeof (addrtype));
BytePtr     = (addrtype )((char *)BytePtr  + sizeof (addrtype));
MoveBytes     (BytePtr,  (addrtype )&SetId,
sizeof (numtype));
if (FieldObj.UnitSize == sizeof (handletype))
{
OwnerTkn.DbId     = Token->DbId;
OwnerTkn.Handle   = *(handletype *)FieldAddr;
} else
OwnerTkn          = *(tokentype *)FieldAddr;
if (ClassBug || DeBug >= 0 || OaBug)
if (sprintf (Msg,
" Object Set Owner[%2u:%4u]; Query @%x\n",
OwnerTkn.DbId, OwnerTkn.Handle, (addrtype )Query0))
TraceMsg (0, Msg);
if (OwnerTkn.Handle == 0
|| !Env_IsValidToken  (&OwnerTkn,  McStat))
{
EvalStack[NumEvals++] = Query_CompareValue
(aAttr,     aInteger,  sizeof (indextype),
FieldObj.ValueClass,
(addrtype )&StackPtr, FieldObj.CompOp,
&OwnerTkn.Handle,             McStat);
} else if (Query0  == NullPtr) {
if (KernelFirstOf ((handletype )SetId,     &OwnerTkn,
McStat,     &NodeTkn,   &MemberTkn))
for (ItNum   = 1;
KernelNextOf  ((handletype )SetId,     &OwnerTkn,
McStat,     &NodeTkn,   &MemberTkn)
&& Normal(*Status); ItNum++)
;
if (*Status == Set_EndOfSet
||  *Status == Set_EmptySet)
*Status  = Env_Normal;
EvalStack[NumEvals++] = Query_CompareValue
(aAttr,     aInteger,  sizeof (indextype),
FieldObj.ValueClass,
(addrtype )&ItNum,   FieldObj.CompOp,
&OwnerTkn.Handle,             McStat);
} else {
#ifdef __INCLUDE_ALL_CODE__
if (Query_AssertOnSet  (SetId,  &OwnerTkn,   Query0,
McStat, &ItNum,     &VchunkTkn))
#endif
EvalStack[NumEvals++] = Query_CompareValue
(aAttr,     aInteger,  sizeof (indextype),
FieldObj.ValueClass,
(addrtype )&ItNum,    FieldObj.CompOp,
&OwnerTkn.Handle,             McStat);
}
} else if (FieldObj.AttrType   == aStrHndlAttr)  {
if (MemLoc == 0)
if (HmGetLocalObjNum
(CoreDb,                        Token->Handle,
McStat,                       &LocalObj))
if (MemGetAddr (CoreDb->ObjHdrDir, (indextype )LocalObj,
McStat,           (addrtype *)&ObjHdr))
{
StrIndex   = *(indextype *)FieldAddr;
OaGetString (Token->DbId,  ObjHdr,          StrIndex,
McStat,              (char **)&FieldAddr);
}
if (Normal(*Status))
EvalStack[NumEvals++] = Query_CompareWild
((char *)FieldAddr,  FieldObj.CompOp,
(char *)ValueAddr,  McStat);
} else if (FieldObj.AttrType   == aObjRefAttr
||  FieldObj.AttrType   == aTknRefAttr)   {
Query0   = *(dbmsquery **)ValueAddr;
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg,
" Object Reference[%2u:%4u]; Query @%x\n",
RefTkn.DbId, RefTkn.Handle, (addrtype )Query0))
TraceMsg (0, Msg);
if (Env_IsValidToken  (&RefTkn,  McStat))
if (Query0  != NullPtr)
EvalStack[NumEvals++] = Query_AssertOnObject
(&RefTkn,  Query0,  McStat);
} else {
if (FieldObj.UnitType != aString)
EvalStack[NumEvals++] = Query_CompareValue
(FieldObj.AttrType,    FieldObj.UnitType,
FieldObj.UnitSize,    FieldObj.ValueClass,
FieldAddr,            FieldObj.CompOp,
ValueAddr,            McStat);
else {
EvalStack[NumEvals++] = Query_CompareWild
((char *)FieldAddr,  FieldObj.CompOp,
(char *)ValueAddr,  McStat);
}
}
break;
case    aBooleanOp   :
BoolVal0  = EvalStack[--NumEvals];
switch (ComdObj.BoolOp)
{
case  aAND          :
if (BoolVal0   == False)
{
EvalStack[NumEvals++] = False;
i                     = ComdObj.FalseJump - 1;
}
break;
case  aOR           :
if (BoolVal0   == True)
{
EvalStack[NumEvals++] = True;
i                     = ComdObj.TrueJump  - 1;
}
break;
case  aExOR         :
break;
case  aNOT          :
break;
case  aNAND         :
break;
case  aNOR          :
break;
case  aNxOR         :
default             :
break;
}
break;
case    aBeginExp    :
NumOpens++;
break;
case    aEndExp      :
if (++NumCloses  == Query->NumCloses)
{
if (ClassBug)
if (sprintf (Msg, "    Assert := %s;\n",
BoolStr[EvalStack[NumEvals-1]]))
TraceMsg (0, Msg);
return (EvalStack[--NumEvals]);
}
break;
}
++i;
}
if (Normal(*Status))
{
if (ClassBug)
if (sprintf (Msg, "    Assert := %s;\n",
BoolStr[EvalStack[--NumEvals]]))
TraceMsg (0, Msg);
return (EvalStack[--NumEvals]);
}
TRACK(TrackBak,"Query_AssertOnObject\n");
return(STAT);
}
boolean    Query_AssertOnDb
(tokentype     *PrimalTkn,   dbmsquery     *Query,
ft F,lt Z,zz  *Status,
numtype       *NumEntrys,   tokentype     *Vtoken)
{
dbheader     *DbHdr        = NullPtr;
numtype       LocalObjNum  = 0;
numtype       LocalObj     = 0;
tokentype     ItorTkn      = NullToken;
int           i            = 0;
boolean       Found        = False;
bytetype      BitVal       = 0;
tokentype    *Results      = NullPtr;
boolean       BoolVal      = False;
indextype     StackIndex   = 0;
ItorTkn.DbId    = PrimalTkn->DbId;
ItorTkn.Handle  = 1;
if (ClassBug)
if (sprintf(Msg,
"  Query_AssertOnDb::  DbId =%3u ClassId =%4u; Cendents= %s\n",
PrimalTkn->DbId, Query->ClassId, BoolStr[Query->CendentsOk]))
TraceMsg (0, Msg);
if (TmGetCoreDb        (PrimalTkn,            McStat,   &DbHdr))
Query_GetClassList (PrimalTkn,        Query,   McStat,  &LocalObjNum);
while (Normal(*Status)
&&   ++ItorTkn.Handle  < DbHdr->NextHandle)
{
Found         = False;
if (HmGetLocalObjNum (DbHdr,   ItorTkn.Handle,  McStat,  &LocalObj))
if (LocalObj != Null_ObjNum)
if (Query->CendentsOk  == False)
{
if (LocalObjNum     == LocalObj)
Found   = True;
} else {
if (BitVec_GetBit (Query->LocalBitVec,  LocalObj,  McStat,  &BitVal))
if (BitVal)
Found   = True;
}
if (Found)
{
BoolVal = Query_AssertOnObject
(&ItorTkn,   Query,   McStat);
if (Normal(*Status)
&&  BoolVal)
{
Vchunk_PushUnit    (&Query->ResultsDir, (addrtype )&ItorTkn,
McStat,             &StackIndex);
Query->NumResults++;
}
}
}
if (*Status  == Iterate_EndOf)
*Status   = Env_Normal;
if (Normal(*Status))
{
*NumEntrys   = Query->NumResults;
*Vtoken      = Query->ResultsDir;
}
if (Normal(*Status))
if (ClassBug || DeBug)
{
sprintf  (Msg, "\n  Query_AssertOnDb:: NumResults = %4u;\n",
Query->NumResults);
TraceMsg (0,   Msg);
if (Vchunk_GetAddress (&Query->ResultsDir, McStat, (addrtype *)&Results))
for (i=0; i < Query->NumResults; ++i)
{
sprintf  (Msg, "  %-6d.  [%3u:%4u]\n",
i, Results[i].DbId, Results[i].Handle);
TraceMsg (0, Msg);
}
TraceMsg (0, "\n");
}
TRACK(TrackBak,"Query_AssertOnDb\n");
return(STAT);
}
boolean    Query_CompareValue
(attrtype      AttrType,    typetype      UnitType,
sizetype      UnitSize,    valueclass    ValueClass,
addrtype      VarValue,    compareop     CompOp,
addrtype      CompValue,   ft F,lt Z,zz *Status)
{
int          i               = 0;
bytetype    *ByteValue       = NULL;
idtype      *IdValue         = NULL;
inttype     *IntValue        = NULL;
tokentype   *TknValue        = NULL;
tokentype   *CompTkn         = NULL;
float       *FloatValue      = NULL;
double      *DoubleValue     = NULL;
addrtype    *AddrValue       = NULL;
handletype  *HndlValue       = NULL;
double       AlignValue;
addrtype     AlignComp       = (addrtype )&AlignValue;
if (UnitType  != aString
&&  UnitSize  <= sizeof (double))
MoveBytes     (CompValue,    AlignComp,    UnitSize);
switch (UnitType)
{
case aDbmsString          :
*Status = Err_NotImplemented;
break;
case aString     :
i = strcmp  ((char *)VarValue,  (char *)CompValue);
break;
case aLink       :
if (UnitSize == sizeof (tokentype ))
{
TknValue    = (tokentype *)AlignComp;
CompTkn     = (tokentype *)VarValue;
if (CompTkn->Handle < TknValue->Handle)
i = -1;
else if (CompTkn->Handle > TknValue->Handle)
i = 1;
if (i == 0
&& CompTkn->DbId  != TknValue->DbId)
i = -1;
} else {
HndlValue   = (handletype *)AlignComp;
if (*(handletype *)VarValue < *HndlValue)
i = -1;
else if (*(handletype *)VarValue > *HndlValue)
i = 1;
}
break;
case aReal       :
if (UnitSize == sizeof (float))
{
FloatValue    = (float *)AlignComp;
if (*(float *)VarValue < *FloatValue)
i = -1;
else if (*(float *)VarValue > *FloatValue)
i = 1;
} else if (UnitSize == sizeof (double)) {
DoubleValue    = (double *)AlignComp;
if (*(double *)VarValue < *DoubleValue)
i = -1;
else if (*(double *)VarValue > *DoubleValue)
i = 1;
}
break;
case aAddr       :
AddrValue    = (addrtype *)AlignComp;
if (*(addrtype *)VarValue != AddrValue)
i = 1;
break;
case aEnum       :
case aBoolean    :
case aValue      :
case aChunk      :
case aInteger    :
switch (UnitSize)
{
case 1     :
ByteValue    = (bytetype *)AlignComp;
if (*(bytetype *)VarValue < *ByteValue)
i = -1;
else if (*(bytetype *)VarValue > *ByteValue)
i = 1;
break;
case 2     :
IdValue    = (idtype *)AlignComp;
if (*(idtype *)VarValue < *IdValue)
i = -1;
else if (*(idtype *)VarValue > *IdValue)
i = 1;
break;
case 4     :
IntValue    = (inttype *)AlignComp;
if (*(inttype *)VarValue < *IntValue)
i = -1;
else if (*(inttype *)VarValue > *IntValue)
i = 1;
break;
#ifdef LARGE
case sizeof (tokentype )  :
TknValue    = (tokentype *)AlignComp;
CompTkn     = (tokentype *)VarValue;
if (CompTkn->Handle < TknValue->Handle)
i = -1;
else if (CompTkn->Handle > TknValue->Handle)
i = 1;
if (i == 0
&& CompTkn->DbId  != TknValue->DbId)
i = -1;
break;
#endif
default    :
if (UnitSize <= sizeof (tokentype ))
i = memcmp  ((char *)VarValue,
(char *)CompValue, (size_t )UnitSize);
else
i = strncmp ((char *)VarValue,
(char *)CompValue, (size_t )UnitSize);
}
break;
}
if (Normal (*Status))
switch (CompOp)
{
case aEQ  :
if (i   == 0)
return(True);
else
return (False);
case aLT  :
if (i    < 0)
return(True);
else
return (False);
case aGT  :
if (i    > 0)
return(True);
else
return (False);
case aGTE :
if (i   == 0
||  i    > 0)
return(True);
else
return (False);
case aLTE :
if (i   == 0
||  i    < 0)
return(True);
else
return (False);
case aNEQ :
if (i   != 0)
return(True);
else
return (False);
case aModEQ0 :
break;
}
TRACK(TrackBak,"Query_CompareValue\n");
return(STAT);
}
boolean    Query_CompareWild
(char          *VarValue,    compareop      CompOp,
char          *WildSpec,    ft F,lt Z,zz  *Status)
{
static char *WildOps    = "?*";
sizetype     StrSize    = 0;
int          i          = 0;
int          j          = 0;
numtype      VarIndex        = 0;
int          VarLen          = 0;
char         CompValue[MAXSTRING];
char        *WildSeg         = NullPtr;
char        *VarSeg          = VarValue;
char         CharSpec[2];
strcpy (CompValue, "\0");
strcpy (CharSpec,  "\0");
VarLen                  = strlen    (VarValue) + 1;
VarIndex                = 0;
while (Normal(*Status)
&&     i               == 0
&&     VarIndex         < VarLen
&&     VarValue[0]     != '\0')
{
if ((WildSeg    = strpbrk (WildSpec, WildOps)) != NULL)
{
StrSize              = (sizetype )(WildSeg - WildSpec);
strncpy  (CompValue,    WildSpec,  StrSize);
CompValue[StrSize]   = '\0';
WildSpec             = &WildSeg[0];
if ((i   = strncmp (VarValue,  CompValue, StrSize)) != 0)
break;
VarIndex            += StrSize;
VarValue            += StrSize;
} else {
VarIndex            += strlen (WildSpec);
i                    = strcmp (VarValue,  WildSpec);
break;
}
if (WildSpec[0] == '?')
{
for (j = 0; WildSpec[0] == '?'; ++WildSpec)
{
++j; ++VarValue;
}
if ((VarIndex  += j)     >= VarLen)
{
i = -1;
break;
}
if (VarValue[0] == '\0')
if (WildSpec[0] != '\0')
if (WildSpec[0] != '*')
i = -1;
} else if (WildSpec[0] == '*') {
++WildSpec;
if ((CharSpec[0]     = WildSpec[0]) == '\0')
VarIndex          = VarLen;
else if ((VarSeg     = strpbrk (VarValue, CharSpec)) != NULL)
{
StrSize            = (sizetype )(VarSeg - VarValue);
VarValue           = &VarSeg[0];
VarIndex          += StrSize;
} else {
i = -1;
VarIndex           = VarLen;
}
} else
*Status  = Lex_BadSyntax;
}
if (ClassBug)
if (sprintf  (Msg, "    Query_CompareWild:: i = %4d\n",
i))
TraceMsg (0, Msg);
if (Normal (*Status))
switch (CompOp)
{
case aEQ  :
if (i   == 0)
return(True);
else
return (False);
case aLT  :
if (i    < 0)
return(True);
else
return (False);
case aGT  :
if (i    > 0)
return(True);
else
return (False);
case aGTE :
if (i   == 0
||  i    > 0)
return(True);
else
return (False);
case aLTE :
if (i   == 0
||  i    < 0)
return(True);
else
return (False);
case aNEQ :
if (i   != 0)
return(True);
else
return (False);
case aModEQ0 :
break;
}
TRACK(TrackBak,"Query_CompareWild\n");
return(STAT);
}
boolean    Query_CheckType
(numtype       ClassId,      numtype       AttrId,
attrtype      AttrType,     addrtype      Value,
compareop     CompOp,       ft F,lt Z,zz *Status)
{
tokentype    CompTkn   = NullToken;
if (Normal(*Status))
if (AttrType     == aArrayAttr
||  AttrType     == aVarrayAttr
||  AttrType     == aDblPtrAttr
||  AttrType     == aChunkAttr
||  AttrType     == aVchunkAttr)
{
*Status = Query_ArrayNotApplicable;
TraceMsg (0,
" Query_Affix :: Array Attribute Not Applicable.\n");
sprintf (Msg, "     for ClassId=%4u; AttrId=%4u.\n",
ClassId, AttrId);
TraceMsg (0, Msg);
TraceMsg (0, "   Use <Query_Assert> type Method.\n");
}
if (Normal(*Status))
if (AttrType     == aSetNodeAttr
||  AttrType     == aSetHeadAttr
||  AttrType     == aSlotHndlAttr
||  AttrType     == aSlotTokenAttr)
{
*Status = Query_SetOrTupleNotAllowed;
TraceMsg (0,
" Query_Affix :: Set or Tuple Type Not Allowed.\n");
sprintf (Msg, "     for ClassId=%4u; AttrId=%4u.\n",
ClassId, AttrId);
TraceMsg (0, Msg);
TraceMsg (0, "   Use <Query_AssertOn> type Method.\n");
}
if (Normal(*Status))
if (AttrType     == aObjRefAttr
||  AttrType     == aTknRefAttr)
{
CompTkn        = *(tokentype *)Value;
if (!Env_IsValidToken (&CompTkn,  McStat)
||  CompOp    != aEQ)
{
*Status = Query_InvalidTknCompare;
TraceMsg (0,
" Query1_AffixCompare :: Compare Value must be Valid With comp== aEq\n");
sprintf (Msg, "     for ClassId=%4u; AttrId=%4u.\n",
ClassId, AttrId);
TraceMsg (0, Msg);
}
}
TRACK(TrackBak,"Query_CheckType\n");
return(STAT);
}
boolean    Query_GetClassList
(tokentype     *DbToken,     dbmsquery     *Query,
ft F,lt Z,zz  *Status,      numtype       *LocalObjNum)
{
dbheader     *DbHdr        = NullPtr;
int           i            = 0;
numtype      *EnvObjs      = NullPtr;
int           j            = 0;
numtype       EnvObj       = 0;
boolean       Found        = False;
boolean       NoneFound    = True;
if (ClassBug)
if (sprintf(Msg,
"  Query_GetClassList:: DbId[%4u] ClassId=%4u; Cendents= %s\n",
DbToken->DbId,  Query->ClassId, BoolStr[Query->CendentsOk]))
TraceMsg (0, Msg);
if (TmGetCoreDb      (DbToken,                 McStat,         &DbHdr))
if (Vchunk_Create    (DbToken,    sizeof (tokentype),  2000,   1000,
McStat,                  &Query->ResultsDir))
Query->NumResults   = 0;
if (Normal(*Status))
if (Mem_GetObjNum    (DbHdr->LocalObjNumMap,    Query->ClassId,
McStat,                   LocalObjNum))
if (Query->CendentsOk)
{
if (OaBug  || DeBug)
{
HmDumpDbHdr (0, DbToken, McStat);
TraceMsg  (0, "   LocalObjNumMap   ::");
Mem_DumpChunkChunk (0, DbHdr->ObjNumMap);
Mem_DumpChunkChunk (0, DbHdr->LocalObjNumMap);
}
i = 1;
if (Mem_GetChunkAddr(DbHdr->ObjNumMap,
McStat,                 (addrtype *)&EnvObjs))
if (BitVec_Create   (DbHdr->LocalObjCount+1,       0,
McStat,                      &Query->LocalBitVec))
while (Normal(*Status)
&&   ++i  < DbHdr->LocalObjCount)
{
j          = 0;
EnvObj     = EnvObjs[i];
Found      = False;
while (j   < Query->NumClasses
&&    !Found)
{
if (EnvObjs[i]  == Query->ClassSet[j])
{
NoneFound   = False;
Found       = True;
BitVec_PutBit  (Query->LocalBitVec,  i,  1,  McStat);
}
++j;
}
}
} else if (*LocalObjNum)
NoneFound     = False;
if (Normal(*Status))
if (*LocalObjNum == 0
||  NoneFound    == True)
{
*Status        = Iterate_EndOf;
return (True);
}
TRACK(TrackBak,"Query_GetClassList\n");
return(STAT);
}
void       Query_Dump (dbmsquery     *Query)
{
return;
}
void       Query_DumpComdObj (querycomd     *ComdObj)
{
return;
}
void       Query_DumpSortObj (querysort     *SortObj)
{
return;
}
void       Query_DumpFieldObj (dbmsquery    *Query,   queryfield    *FieldObj)
{
addrtype   ValueAddr  = (addrtype )((char *)Query->Values
+ FieldObj->ValueOffset);
return;
}
/* 当前文件是./CINT2000\255.vortex\src\rect.c*/

#define RECT




boolean Rectangle_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
Rectangle       Rect;
if (Rectangle_Class == 0)
{
if (EnvGetMemberId     ("Extent",             McStat, &Extent_Attr))
if (EnvGetMemberId     ("Origin",             McStat, &Origin_Attr))
if (EnvGetClassId      ("Rectangle",          McStat, &Rectangle_Class))
if (EnvGetClassId      ("XyRect",             McStat, &XyRect_Class))
if (EnvGetClassId      ("RefRect",            McStat, &RefRect_Class))
EnvGetClassId      ("PortRect",           McStat, &PortRect_Class);
}
StartAddr   = (longaddr )&Rect;
if (Normal(*Status))
if (EnvInitClassMap    (Rectangle_Class,     sizeof(Rectangle),
C_Apl,               McStat))
{
Offset    = (size_t)((longaddr )&Rect.That    -  StartAddr);
if (Env_AppendToMap    (That_AttrNum,          Offset,     McStat))
Offset = (size_t)((longaddr )&Rect.Token   -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Token_Attr,            Offset,     McStat))
Offset = (size_t)((longaddr )&Rect.Id      -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Id_Attr,               Offset,     McStat))
Offset = (size_t)((longaddr )&Rect.MemberDrawObjs  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (MemberDrawObjs_Attr,   Offset,     McStat))
Offset = (size_t)((longaddr )&Rect.PartObjSlotAttr  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (PartObj_Slot,   Offset,     McStat))
Offset = (size_t)((longaddr )&Rect.Origin  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Origin_Attr,           Offset,     McStat))
Offset = (size_t)((longaddr )&Rect.Extent  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (Extent_Attr,           Offset,     McStat))
Offset = (size_t)((longaddr  )&Rect.MemberLibRectangles  -  StartAddr);
if (Normal(*Status))
if (Env_AppendToMap    (MemberLibRectangles_Attr, Offset,  McStat))
Env_InvokeMap      (C_Apl,                             McStat);
}
TRACK(TrackBak,"Rectangle_InitClass\n");
return (STAT);
}
Rectangle  *Rectangle_new0
(tokentype    *AnchorTkn,
short         i0,        short         i1,
short         i01,       ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
Rectangle      *Image  = NullPtr;
CartesianPoint *o      = NullPtr;
CartesianPoint *e      = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  Rectangle_New0 Anchor= [%4u:%6u] @ (%4u,%4u, %4u)\n",
AnchorTkn->DbId, AnchorTkn->Handle, i0, i1, i01))
TraceMsg (0, Msg);
if (Object_Create   (AnchorTkn,    Rectangle_Class,  McStat,   &Token))
if (Object_GetImage (&Token,       McStat,         (addrtype *)&Image))
{
if (DrawLib01)
Image->Id               = ++DrawLib01->DrawId;
Image->MemberDrawObjs      = NullHandle;
Image->draw                = Rectangle_draw;
Image->area                = Rectangle_area;
Image->destruct            = Rectangle_delete;
Image->Origin              = (Point *)o;
Image->Extent              = (Point *)e;
Image->MemberLibRectangles = NullHandle;
if (DrawObjs_AddInto       (AnchorTkn,  &Token,  McStat))
LibRectangles_AddInto  (AnchorTkn,  &Token,  McStat);
}
STAT;
return (Image);
}
Rectangle  *Rectangle_new1
(tokentype    *AnchorTkn,
Point        *o,         Point        *e,
ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
Rectangle      *Image  = NullPtr;
static  boolean Trace  = False;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  Rectangle_New1 Anchor= [%4u:%6u] @ (%x, %x)\n",
AnchorTkn->DbId, AnchorTkn->Handle, o, e))
TraceMsg (0, Msg);
if (Object_NewImage (AnchorTkn,    Rectangle_Class,
McStat,      &Token,          (addrtype *)&Image))
{
if (DrawLib01)
Image->Id               = DrawLib_NewId (McStat);
Image->MemberDrawObjs      = NullHandle;
Image->draw                = Rectangle_draw;
Image->area                = Rectangle_area;
Image->destruct            = Rectangle_delete;
Image->Origin              = o;
Image->Extent              = e;
Image->MemberLibRectangles = NullHandle;
if (Normal(*Status))
if (DrawObjs_AddInto       (AnchorTkn,  &Token,  McStat))
LibRectangles_AddInto  (AnchorTkn,  &Token,  McStat);
}
if (Trace)
{
Trace = False;
OaBug = False;
}
STAT;
return (Image);
}
Rectangle  *Rectangle_new2
(tokentype    *AnchorTkn,
Point        *o,         Point        *e,
ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
Rectangle      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  Rectangle_New2 Anchor= [%4u:%6u] @ (%x, %x)\n",
AnchorTkn->DbId, AnchorTkn->Handle, o, e))
TraceMsg (0, Msg);
if (Object_Create   (AnchorTkn,    Rectangle_Class,  McStat,   &Token))
if (Object_GetImage (&Token,       McStat,         (addrtype *)&Image))
{
if (DrawLib01)
Image->Id    = ++DrawLib01->DrawId;
Image->MemberDrawObjs      = NullHandle;
Image->draw                = Rectangle_draw;
Image->area                = Rectangle_area;
Image->destruct            = Rectangle_delete;
Image->Origin              = o;
Image->Extent              = e;
Image->MemberLibRectangles = NullHandle;
if (DrawObjs_AddInto       (AnchorTkn,  &Token,  McStat))
LibRectangles_AddInto  (AnchorTkn,  &Token,  McStat);
}
STAT;
return (Image);
}
Rectangle  *Rectangle_new3
(tokentype    *AnchorTkn,
tokentype    *oTkn,      tokentype    *eTkn,
ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
Rectangle      *Image  = NullPtr;
Point          *o      = NullPtr;
Point          *e      = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg,
"  Rectangle_new3 Anchor= [%4u:%6u] @ o= [%4u:%6u], e= [%4u:%6u]\n",
AnchorTkn->DbId, AnchorTkn->Handle,
oTkn->DbId, eTkn->Handle,oTkn->DbId, eTkn->Handle))
TraceMsg (0, Msg);
if (Object_Create   (AnchorTkn,    Rectangle_Class,  McStat,   &Token))
if (Object_GetImage (&Token,       McStat,         (addrtype *)&Image))
if (Object_GetImage (oTkn,         McStat,         (addrtype *)&o))
if (Object_GetImage (eTkn,         McStat,         (addrtype *)&e))
{
if (DrawLib01)
Image->Id    = ++DrawLib01->DrawId;
Image->MemberDrawObjs      = NullHandle;
Image->draw                = Rectangle_draw;
Image->area                = Rectangle_area;
Image->destruct            = Rectangle_delete;
Image->Origin              = o;
Image->Extent              = e;
Image->MemberLibRectangles = NullHandle;
if (DrawObjs_AddInto       (AnchorTkn,  &Token,  McStat))
LibRectangles_AddInto  (AnchorTkn,  &Token,  McStat);
}
STAT;
return (Image);
}
Rectangle  *Rectangle_new4
(tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
Rectangle      *Image  = NullPtr;
tokentype       PointTkn  = NullToken;
numtype         DrawClass = 0;
CartesianPoint *c0        = NullPtr;
PolarPoint     *p0        = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  Rectangle_new4 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (RecTkn,       McStat,         (addrtype *)&Image))
{
Image->draw                = Rectangle_draw;
Image->area                = Rectangle_area;
Image->destruct            = Rectangle_delete;
}
if (Normal(*Status))
if (Image->Origin != NullPtr)
{
PointTkn   = Image->Origin->Token;
DrawClass  = Object_IsA (&PointTkn,  McStat);
if (DrawClass == CartesianPoint_Class)
c0 = CartesianPoint_new1 (&PointTkn,  McStat);
else
p0 = PolarPoint_new1     (&PointTkn,  McStat);
}
if (Normal(*Status))
if (Image->Extent != NullPtr)
{
PointTkn   = Image->Extent->Token;
DrawClass  = Object_IsA (&PointTkn,  McStat);
if (DrawClass == CartesianPoint_Class)
c0 = CartesianPoint_new1 (&PointTkn,  McStat);
else
p0 = PolarPoint_new1     (&PointTkn,  McStat);
}
STAT;
return (Image);
}
lt64        Rectangle_area (Rectangle   *This, ft F,lt Z,zz *Status)
{
lt64 RecArea = 0;
RecArea = abs( (Point_x(This->Extent) - Point_x(This->Origin))
* (Point_y(This->Extent) - Point_y(This->Origin)) );
if (DrawBug || ClassBug)
if (sprintf (Msg, "\n Area of Rectangle = %d\n", RecArea))
TraceMsg (0, Msg);
STAT;
return (RecArea);
}
boolean     Rectangle_draw (Rectangle   *This,  ft F,lt Z,zz *Status)
{
if (DrawBug || ClassBug)
{
sprintf (Msg, "\n This->Origin->x() :%d\n", Point_x(This->Origin));
TraceMsg (0, Msg);
sprintf (Msg, " This->Origin->y() :%d\n", Point_y(This->Origin));
TraceMsg (0, Msg);
sprintf (Msg, " This->Extent->x() :%d\n", Point_x(This->Extent));
TraceMsg (0, Msg);
sprintf (Msg, " This->Extent->y() :%d\n", Point_y(This->Extent));
TraceMsg (0, Msg);
} else {
Point_x(This->Origin);
Point_y(This->Origin);
Point_x(This->Extent);
Point_y(This->Extent);
}
if (DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n Draw the Rectangle :: This = %x; Token[%2u:%8u]\n",
This, This->Token.DbId, This->Token.Handle);
TraceMsg (0, Msg);
Object_Dump (&This->Token);
TraceMsg (0, "   Origin :: Point");
Object_Dump (&This->Origin->Token);
TraceMsg (0, "   Extent :: Point");
Object_Dump (&This->Extent->Token);
}
TRACK(TrackBak,"Rectangle_Draw\n");
return (STAT);
}
void Rectangle_show (Rectangle   *This)
{
longaddr       StartAddr = 0;
tokentype      Token     = This->Token;
sprintf (Msg, "\n The  Rectangle MAP:: [%2u:%8u]\n",
Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr             = (longaddr )This;
sprintf (Msg,  " sizeof Rectangle    : %3u\n",   sizeof(Rectangle));
TraceMsg (0, Msg);
sprintf (Msg,  " This                      :      @%x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  " This->That                : +%3d @%x   = %x\n",
(char *)&This->That     - StartAddr, &This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Token               : +%3d @%x   = [%2u:%8u]\n",
(char *)&This->Token    - StartAddr, &This->Token,
This->Token.DbId, This->Token.Handle );
TraceMsg (0, Msg);
sprintf (Msg,  " This->Id                  : +%3d @%x   = %2u\n",
(char *)&This->Id       - StartAddr, &This->Id, This->Id);
TraceMsg (0, Msg);
sprintf (Msg,  " This->MemberDrawObjs      : +%3d @%x   = [%4u:%2u]\n",
(char *)&This->MemberDrawObjs - StartAddr,
&This->MemberDrawObjs,
This->Token.DbId,            This->MemberDrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Origin              : +%3d @%x   = %x\n",
(char *)&This->Origin   - StartAddr, &This->Origin,
This->Origin);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Extent              : +%3d @%x   = %x\n",
(char *)&This->Extent   - StartAddr, &This->Extent,
This->Extent);
TraceMsg (0, Msg);
sprintf (Msg,  " This->MemberLibRectangles : +%3d @%x   = %2u\n",
(char *)&This->MemberLibRectangles - StartAddr,
&This->MemberLibRectangles, This->MemberLibRectangles );
TraceMsg (0, Msg);
TraceMsg (0, "\n");
return;
}
boolean    Rectangle_error (Rectangle   *This,  char * msg,
ft F,lt Z,zz *Status)
{
sprintf (Msg, "\n  *** Rectangle :: %s @%x\n", msg, This);
SendMsg (0, Msg);
exit(1);
TRACK(TrackBak,"Rectangle_error\n");
return (STAT);
}
boolean Rectangle_delete (Rectangle   **This,   deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
Rectangle   *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  Rectangle_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " Rectangle [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"Rectangle_delete\n");
return (STAT);
}
boolean LibRectangles_InitClass (ft F,lt Z,zz *Status)
{
if (ClassBug)
TraceMsg (0, " LibRectangles::InitClass...\n");
if (!OwnerLibRectangles_Attr)
if (EnvGetMemberId    ("OwnerLibRectangles",
McStat,               &OwnerLibRectangles_Attr))
if (EnvGetMemberId    ("MemberLibRectangles",
McStat,               &MemberLibRectangles_Attr))
EnvGetSetId       ("LibRectangles",
McStat,               &LibRectangles_Set);
TRACK(TrackBak,"LibRectangles_InitClass\n");
return (STAT);
}
boolean OwnerOfLibRectangles (tokentype *Member,
ft F,lt Z,zz *Status,    tokentype *Owner)
{
KernelOwnerOf  (LibRectangles_Set, Member, McStat, Owner);
TRACK(TrackBak,"OwnerOfLibRectangles\n");
return (STAT);
}
boolean LibRectangles_AddInto
(tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status)
{
SetAddInto (LibRectangles_Set, OwnerTkn, MemberTkn, McStat);
TRACK(TrackBak,"LibRectangles_AddInto\n");
return (STAT);
}
boolean LibRectangles_FindIn
(tokentype    *OwnerTkn,  addrtype     KeyValue,
ft F,lt Z,zz *Status,    tokentype   *MemberTkn)
{
SetFindIn  (LibRectangles_Set, OwnerTkn,   KeyValue,
McStat,            MemberTkn);
TRACK(TrackBak,"FindInLibRectangles\n");
return (STAT);
}
boolean LibRectangles_IterateOn
(tokentype    *OwnerTkn,  treeiterfunc  IterFunc,
ft F,lt Z,zz *Status)
{
SpclTraverseTree (LibRectangles_Set,  OwnerTkn, IterFunc, McStat);
if (*Status == Set_EndOfSet
||  *Status == Set_EmptySet)
*Status  = Iterate_EndOf;
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\rects.c*/

#define RECTS_C

boolean Rects_InitLibrary
(ft F,lt Z,zz *Status)
{
boolean   TempLibBug = LibBug;
if (ClassBug)
TraceMsg (0, "\n\n  Initialize Rects Library ...\n\n");
if (XyRect_InitClass                        (McStat))
if (NamedXyRect_InitClass                   (McStat))
if (ArrayRect_InitClass                     (McStat))
if (DblPtrRect_InitClass                    (McStat))
if (VarrayRect_InitClass                    (McStat))
if (IntChunkRect_InitClass                  (McStat))
if (VchunkRect_InitClass                    (McStat))
if (RefRect_InitClass                       (McStat))
PortRect_InitClass                      (McStat);
TRACK(TrackBak,"Rects_InitLibrary\n");
return (STAT);
}
boolean XyRect_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
XyRect          Rect;
if (ClassBug)
TraceMsg (0, "\n\n  XY RECT  Map...\n");
if (EnvGetMemberId     ("Id",                 McStat, &Id_Attr))
if (EnvGetMemberId     ("XyExtent",           McStat, &XyExtent_Attr))
if (EnvGetMemberId     ("XyOrigin",           McStat, &XyOrigin_Attr))
if (EnvGetClassId      ("XyRect",             McStat, &XyRect_Class))
if (EnvGetClassId      ("XyPoint",            McStat, &XyPoint_Class))
if (EnvInitClassMap    (XyRect_Class,         sizeof(XyRect),
C_Apl,                McStat))
{
StartAddr= (longaddr  )&Rect;
Offset   = (size_t)((longaddr )&Rect.That    -  StartAddr);
Env_AppendToMap    (That_AttrNum,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Token   -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Token_Attr,            Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Id      -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Id_Attr,               Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.MemberDrawObjs  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (MemberDrawObjs_Attr,   Offset,     McStat);
Offset = (size_t)((longaddr )&Rect.PartObjSlotAttr  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (PartObj_Slot,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.XyOrigin  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (XyOrigin_Attr,         Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.XyExtent  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (XyExtent_Attr,         Offset,     McStat);
if (Normal(*Status))
Env_InvokeMap      (C_Apl,                             McStat);
}
if (Normal(*Status))
if (EnvInitClassMap    (XyPoint_Class,        sizeof(XyPoint),
C_Apl,                McStat))
EnvInvokeMap       (C_Apl,                McStat);
TRACK(TrackBak,"XyRect_InitClass\n");
return (STAT);
}
XyRect  *XyRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status)
{
tokentype    Token  = NullToken;
XyRect      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  XyRect_new0 Anchor= [%4u:%6u] XyPoints @ (%x, %x)\n",
AnchorTkn->DbId, AnchorTkn->Handle, o, e))
TraceMsg (0, Msg);
if (Object_NewImage (AnchorTkn,    XyRect_Class,
McStat,      &Token,          (addrtype *)&Image))
{
if (DrawLib01)
Image->Id               = DrawLib_NewId (McStat);
Image->MemberDrawObjs      = NullHandle;
Image->draw                = XyRect_draw;
Image->area                = XyRect_area;
Image->destruct            = XyRect_delete;
Image->XyOrigin            = *o;
Image->XyExtent            = *e;
if (Normal(*Status))
DrawObjs_AddInto  (AnchorTkn,  &Token,  McStat);
}
STAT;
return (Image);
}
XyRect  *XyRect_new1     (tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
XyRect      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  XyRect_new1 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (RecTkn,       McStat,         (addrtype *)&Image))
{
Image->draw                = XyRect_draw;
Image->area                = XyRect_area;
Image->destruct            = XyRect_delete;
}
STAT;
return (Image);
}
lt64        XyRect_area (XyRect   *This, ft F,lt Z,zz *Status)
{
lt64 RecArea = 0;
RecArea = abs( (This->XyExtent.xCoord - This->XyOrigin.xCoord)
* (This->XyExtent.yCoord - This->XyOrigin.yCoord) );
if (DrawBug || DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Area of XyRect = %d\n", RecArea))
TraceMsg (0, Msg);
STAT;
return (RecArea);
}
boolean     XyRect_draw (XyRect   *This,  ft F,lt Z,zz *Status)
{
if (DrawBug || DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n This->XyOrigin.xCoord :%d\n", This->XyOrigin.xCoord);
TraceMsg (0, Msg);
sprintf (Msg, " This->XyOrigin.yCoord :%d\n", This->XyOrigin.yCoord);
TraceMsg (0, Msg);
sprintf (Msg, " This->XyExtent.xCoord :%d\n", This->XyExtent.xCoord);
TraceMsg (0, Msg);
sprintf (Msg, " This->XyExtent.yCoord :%d\n", This->XyExtent.yCoord);
TraceMsg (0, Msg);
}
if (DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n Draw the XyRect :: This = %x; Token[%2u:%8u]\n",
This, This->Token.DbId, This->Token.Handle);
TraceMsg (0, Msg);
Object_Dump (&This->Token);
}
TRACK(TrackBak,"XyRect_Draw\n");
return (STAT);
}
boolean    XyRect_dump (XyRect   *This, ft F,lt Z,zz *Status)
{
TraceMsg (0, "\n The  XyRect ::\n");
Object_Dump (&This->Token);
TRACK(TrackBak,"XyRect_Dump\n");
return (STAT);
}
boolean    XyRect_error (XyRect   *This,  char * msg,
ft F,lt Z,zz *Status)
{
sprintf (Msg, "\n  *** XyRect:: %s @%x\n", msg, This);
SendMsg (0, Msg);
exit(1);
TRACK(TrackBak,"XyRect_Error\n");
return (STAT);
}
void XyRect_show (XyRect   *This)
{
longaddr       StartAddr = 0;
tokentype      Token     = This->Token;
sprintf (Msg, "\n The  XyRect MAP:: [%2u:%8u]\n",
Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr             = (longaddr )This;
sprintf (Msg,  " sizeof XyRect    : %3u\n",   sizeof(XyRect));
TraceMsg (0, Msg);
sprintf (Msg,  " This                      :      @%x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  " This->That                : +%3d @%x   = %x\n",
(char *)&This->That     - StartAddr, &This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Token               : +%3d @%x   = [%2u:%8u]\n",
(char *)&This->Token    - StartAddr, &This->Token,
This->Token.DbId, This->Token.Handle );
TraceMsg (0, Msg);
sprintf (Msg,  " This->Id                  : +%3d @%x   = %2u\n",
(char *)&This->Id       - StartAddr, &This->Id, This->Id);
TraceMsg (0, Msg);
sprintf (Msg,  " This->MemberDrawObjs      : +%3d @%x   = [%4u:%2u]\n",
(char *)&This->MemberDrawObjs - StartAddr,
&This->MemberDrawObjs,
This->Token.DbId,            This->MemberDrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " This->XyOrigin.xCoord     : +%3d @%x   = %4u\n",
(char *)&This->XyOrigin.xCoord - StartAddr, &This->XyOrigin.xCoord,
This->XyOrigin.xCoord);
TraceMsg (0, Msg);
sprintf (Msg,  " This->XyOrigin.yCoord     : +%3d @%x   = %4u\n",
(char *)&This->XyOrigin.yCoord - StartAddr, &This->XyOrigin.yCoord,
This->XyOrigin.yCoord);
TraceMsg (0, Msg);
sprintf (Msg,  " This->XyExtent.xCoord     : +%3d @%x   = %4u\n",
(char *)&This->XyExtent.xCoord - StartAddr, &This->XyExtent.xCoord,
This->XyExtent.xCoord);
TraceMsg (0, Msg);
sprintf (Msg,  " This->XyExtent.yCoord     : +%3d @%x   = %4u\n",
(char *)&This->XyExtent.yCoord - StartAddr, &This->XyExtent.yCoord,
This->XyExtent.yCoord);
TraceMsg (0, Msg);
TraceMsg (0, "\n");
return;
}
boolean XyRect_delete (XyRect   **This,   deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
XyRect   *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  XyRect_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " XyRect [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"XyRect_delete\n");
return (STAT);
}
boolean NamedXyRect_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
NamedXyRect     Rect;
if (ClassBug)
TraceMsg (0, "\n\n  NAMED XY RECT  Map...\n");
if (XyRect_Class == 0)
if (EnvGetMemberId     ("Id",                 McStat, &Id_Attr))
if (EnvGetMemberId     ("XyExtent",           McStat, &XyExtent_Attr))
if (EnvGetMemberId     ("XyOrigin",           McStat, &XyOrigin_Attr))
if (EnvGetClassId      ("XyPoint",            McStat, &XyPoint_Class))
if (EnvInitClassMap    (XyPoint_Class,        sizeof(XyPoint),
C_Apl,                McStat))
EnvInvokeMap       (C_Apl,                McStat);
if (Normal(*Status))
if (EnvGetMemberId     ("Name",               McStat, &Name_Attr))
if (EnvGetClassId      ("NamedXyRect",        McStat, &NamedXyRect_Class))
if (EnvInitClassMap    (NamedXyRect_Class,    sizeof(NamedXyRect),
C_Apl,                McStat))
{
StartAddr= (longaddr )&Rect;
Offset   = (size_t)((longaddr )&Rect.That    -  StartAddr);
Env_AppendToMap    (That_AttrNum,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Token   -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Token_Attr,            Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Id      -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Id_Attr,               Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.MemberDrawObjs  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (MemberDrawObjs_Attr,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.PartObjSlotAttr -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (PartObj_Slot,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Nam             -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Nam_Attr,              Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.MemberNamedDrawObjs  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (MemberNamedDrawObjs_Attr, Offset,  McStat);
Offset   = (size_t)((longaddr )&Rect.XyOrigin        -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (XyOrigin_Attr,         Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.XyExtent        -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (XyExtent_Attr,         Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Name            -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Name_Attr,             Offset,     McStat);
if (Normal(*Status))
Env_InvokeMap      (C_Apl,                             McStat);
}
TRACK(TrackBak,"NamedXyRect_InitClass\n");
return (STAT);
}
NamedXyRect  *NamedXyRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status)
{
tokentype     Token       = NullToken;
NamedXyRect  *Image       = NullPtr;
char          Name[64];
char          Buffer[32];
static numtype Index      = 0;
boolean       TempSetBug  = SetBug;
boolean       TempClassBug= ClassBug;
Index   = DrawLib_NewId (McStat);
Name[0] = '\0';
Ut_IntToStr   ((int )Index, Name);
if (Index == 1 || DeBug || OaBug || ClassBug)
if (sprintf (Msg,
"  NamedXyRect_new1:: <%12s> [%4u:%6u] XyPoints @ (%x, %x)\n",
Name, AnchorTkn->DbId, AnchorTkn->Handle, o, e))
TraceMsg (0, Msg);
if (Object_NewImage (AnchorTkn,    NamedXyRect_Class,
McStat,      &Token,          (addrtype *)&Image))
#ifdef    __BAD_CODE__
if (Attr_ValuePut   (&Token,       Name_Attr,       Name,       McStat))
#endif
{
Image->Id                  = Index;
Image->MemberDrawObjs      = NullHandle;
Image->MemberNamedDrawObjs = NullHandle;
Image->draw                = NamedXyRect_draw;
Image->area                = NamedXyRect_area;
Image->destruct            = NamedXyRect_delete;
strcpy (Image->Nam,  Name);
Image->XyOrigin            = *o;
Image->XyExtent            = *e;
if (Normal(*Status))
if (DrawObjs_AddInto       (AnchorTkn,  &Token,  McStat))
if (strlen (Name))
NamedDrawObjs_AddInto  (AnchorTkn,  &Token,  McStat);
}
SetBug   = TempSetBug;
ClassBug = TempClassBug;
STAT;
return (Image);
}
NamedXyRect  *NamedXyRect_new1
(tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
NamedXyRect      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  NamedXyRect_new3 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (RecTkn,       McStat,         (addrtype *)&Image))
{
Image->draw                = NamedXyRect_draw;
Image->area                = NamedXyRect_area;
Image->destruct            = NamedXyRect_delete;
}
STAT;
return (Image);
}
lt64        NamedXyRect_area (NamedXyRect   *This, ft F,lt Z,zz *Status)
{
lt64 RecArea = 0;
RecArea = abs( (This->XyExtent.xCoord - This->XyOrigin.xCoord)
* (This->XyExtent.yCoord - This->XyOrigin.yCoord) );
if (DrawBug || DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Area of NamedXyRect = %d\n", RecArea))
TraceMsg (0, Msg);
STAT;
return (RecArea);
}
boolean     NamedXyRect_draw (NamedXyRect   *This,  ft F,lt Z,zz *Status)
{
if (DrawBug || DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n This->XyOrigin.xCoord :%d\n", This->XyOrigin.xCoord);
TraceMsg (0, Msg);
sprintf (Msg, " This->XyOrigin.yCoord :%d\n", This->XyOrigin.yCoord);
TraceMsg (0, Msg);
sprintf (Msg, " This->XyExtent.xCoord :%d\n", This->XyExtent.xCoord);
TraceMsg (0, Msg);
sprintf (Msg, " This->XyExtent.yCoord :%d\n", This->XyExtent.yCoord);
TraceMsg (0, Msg);
}
if (DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n Draw the NamedXyRect :: This = %x; Token[%2u:%8u]\n",
This, This->Token.DbId, This->Token.Handle);
TraceMsg (0, Msg);
Object_Dump (&This->Token);
}
TRACK(TrackBak,"NamedXyRect_Draw\n");
return (STAT);
}
boolean    NamedXyRect_dump (NamedXyRect   *This, ft F,lt Z,zz *Status)
{
TraceMsg (0, "\n The  NamedXyRect ::\n");
Object_Dump (&This->Token);
TRACK(TrackBak,"NamedXyRect_Dump\n");
return (STAT);
}
boolean    NamedXyRect_error (NamedXyRect   *This,  char * msg,
ft F,lt Z,zz *Status)
{
sprintf (Msg, "\n  *** NamedXyRect:: %s @%x\n", msg, This);
SendMsg (0, Msg);
exit(1);
TRACK(TrackBak,"NamedXyRect_Error\n");
return (STAT);
}
void NamedXyRect_show (NamedXyRect   *This)
{
longaddr       StartAddr = 0;
tokentype      Token     = This->Token;
sprintf (Msg, "\n The  NamedXyRect MAP:: [%2u:%8u]\n",
Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr             = (longaddr )This;
sprintf (Msg,  " sizeof NamedXyRect    : %3u\n",   sizeof(NamedXyRect));
TraceMsg (0, Msg);
sprintf (Msg,  " This                      :      @%x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  " This->That                : +%3d @%x   = %x\n",
(char *)&This->That     - StartAddr, &This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Token               : +%3d @%x   = [%2u:%8u]\n",
(char *)&This->Token    - StartAddr, &This->Token,
This->Token.DbId, This->Token.Handle );
TraceMsg (0, Msg);
sprintf (Msg,  " This->Id                  : +%3d @%x   = %2u\n",
(char *)&This->Id       - StartAddr, &This->Id, This->Id);
TraceMsg (0, Msg);
sprintf (Msg,  " This->MemberDrawObjs      : +%3d @%x   = [%4u:%2u]\n",
(char *)&This->MemberDrawObjs - StartAddr,
&This->MemberDrawObjs,
This->Token.DbId,            This->MemberDrawObjs);
sprintf (Msg,  " This->Nam                 : +%3d @%x   = <%s>\n",
(char *)&This->Nam         - StartAddr, &This->Nam,
This->Nam);
TraceMsg (0, Msg);
sprintf (Msg,  " This->MemberNamedDrawObjs : +%3d @%x   = [%4u:%2u]\n",
(char *)&This->MemberNamedDrawObjs - StartAddr,
&This->MemberNamedDrawObjs,
This->Token.DbId,                 This->MemberNamedDrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " This->XyOrigin.xCoord     : +%3d @%x   = %4u\n",
(char *)&This->XyOrigin.xCoord - StartAddr, &This->XyOrigin.xCoord,
This->XyOrigin.xCoord);
TraceMsg (0, Msg);
sprintf (Msg,  " This->XyOrigin.yCoord     : +%3d @%x   = %4u\n",
(char *)&This->XyOrigin.yCoord - StartAddr, &This->XyOrigin.yCoord,
This->XyOrigin.yCoord);
TraceMsg (0, Msg);
sprintf (Msg,  " This->XyExtent.xCoord     : +%3d @%x   = %4u\n",
(char *)&This->XyExtent.xCoord - StartAddr, &This->XyExtent.xCoord,
This->XyExtent.xCoord);
TraceMsg (0, Msg);
sprintf (Msg,  " This->XyExtent.yCoord     : +%3d @%x   = %4u\n",
(char *)&This->XyExtent.yCoord - StartAddr, &This->XyExtent.yCoord,
This->XyExtent.yCoord);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Name                : +%3d @%x   = <%s>\n",
(char *)&This->Name        - StartAddr, &This->Name,
This->Name);
TraceMsg (0, Msg);
TraceMsg (0, "\n");
return;
}
boolean NamedXyRect_delete (NamedXyRect   **This,   deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
NamedXyRect   *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  NamedXyRect_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " NamedXyRect [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"NamedXyRect_delete\n");
return (STAT);
}
boolean ArrayRect_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
ArrayRect       Rect;
if (ClassBug)
TraceMsg (0, "\n\n  ARRAY RECT  Map...\n");
if (EnvGetMemberId     ("Xarray",             McStat, &Xarray_Attr))
if (EnvGetMemberId     ("Yarray",             McStat, &Yarray_Attr))
if (EnvGetClassId      ("ArrayRect",          McStat, &ArrayRect_Class))
if (EnvInitClassMap    (ArrayRect_Class,      sizeof(ArrayRect),
C_Apl,                McStat))
{
StartAddr= (longaddr )&Rect;
Offset   = (size_t)((longaddr )&Rect.That    -  StartAddr);
Env_AppendToMap    (That_AttrNum,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Token   -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Token_Attr,            Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Id      -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Id_Attr,               Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.MemberDrawObjs  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (MemberDrawObjs_Attr,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.PartObjSlotAttr -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (PartObj_Slot,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Xarray   -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Xarray_Attr,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Yarray    -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Yarray_Attr,          Offset,     McStat);
if (Normal(*Status))
Env_InvokeMap      (C_Apl,                             McStat);
}
TRACK(TrackBak,"ArrayRect_InitClass\n");
return (STAT);
}
ArrayRect  *ArrayRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status)
{
tokentype    Token  = NullToken;
ArrayRect      *Image  = NullPtr;
addrtype     ArrayAddr = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  ArrayRect_new1 Anchor= [%4u:%6u] XyPoints @ (%x, %x)\n",
AnchorTkn->DbId, AnchorTkn->Handle, o, e))
TraceMsg (0, Msg);
if (Object_Create     (AnchorTkn,   ArrayRect_Class,  McStat,   &Token))
if (Attr_ArrayCreate  (&Token,      Xarray_Attr,     4,  sizeof(short),
McStat,     &ArrayAddr))
if (Object_GetImage   (&Token,      McStat,         (addrtype *)&Image))
if (Attr_ArrayCreate  (&Token,      Yarray_Attr,     4,  sizeof(short),
McStat,     &ArrayAddr))
if (!Normal(*Status))
if (ClassBug)
{
ArrayRect_show    (Image);
Object_Dump       (&Token);
}
if (Normal(*Status))
{
if (DrawLib01)
Image->Id               = DrawLib_NewId (McStat);
Image->MemberDrawObjs      = NullHandle;
Image->draw                = ArrayRect_draw;
Image->area                = ArrayRect_area;
Image->destruct            = ArrayRect_delete;
Image->Xarray[0]           = o->xCoord;
Image->Yarray[0]           = o->yCoord;
Image->Xarray[1]           = e->xCoord;
Image->Yarray[1]           = o->yCoord;
Image->Xarray[2]           = o->xCoord;
Image->Yarray[2]           = e->yCoord;
Image->Xarray[3]           = e->xCoord;
Image->Yarray[3]           = e->yCoord;
if (Normal(*Status))
DrawObjs_AddInto  (AnchorTkn,  &Token,  McStat);
}
STAT;
return (Image);
}
ArrayRect  *ArrayRect_new1     (tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
ArrayRect      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  ArrayRect_new3 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (RecTkn,       McStat,         (addrtype *)&Image))
{
Image->draw                = ArrayRect_draw;
Image->area                = ArrayRect_area;
Image->destruct            = ArrayRect_delete;
}
STAT;
return (Image);
}
lt64        ArrayRect_area (ArrayRect   *This, ft F,lt Z,zz *Status)
{
lt64 RecArea = 0;
RecArea = abs( (This->Xarray[3] - This->Xarray[0])
* (This->Yarray[3] - This->Yarray[0]) );
if (DrawBug || DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Area of ArrayRect = %d\n", RecArea))
TraceMsg (0, Msg);
STAT;
return (RecArea);
}
boolean     ArrayRect_draw (ArrayRect   *This,  ft F,lt Z,zz *Status)
{
if (DrawBug || DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n This->Xarray[0] :%d\n", This->Xarray[0]);
TraceMsg (0, Msg);
sprintf (Msg, " This->Yarray[0] :%d\n", This->Xarray[0]);
TraceMsg (0, Msg);
sprintf (Msg, " This->Xarray[3] :%d\n", This->Yarray[3]);
TraceMsg (0, Msg);
sprintf (Msg, " This->Yarray[3] :%d\n", This->Yarray[3]);
TraceMsg (0, Msg);
}
if (DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n Draw the ArrayRect :: This = %x; Token[%2u:%8u]\n",
This, This->Token.DbId, This->Token.Handle);
TraceMsg (0, Msg);
Object_Dump (&This->Token);
}
TRACK(TrackBak,"ArrayRect_Draw\n");
return (STAT);
}
boolean    ArrayRect_dump (ArrayRect   *This, ft F,lt Z,zz *Status)
{
TraceMsg (0, "\n The  ArrayRect ::\n");
Object_Dump (&This->Token);
TRACK(TrackBak,"ArrayRect_Dump\n");
return (STAT);
}
boolean    ArrayRect_error (ArrayRect   *This,  char * msg,
ft F,lt Z,zz *Status)
{
sprintf (Msg, "\n  *** ArrayRect:: %s @%x\n", msg, This);
SendMsg (0, Msg);
exit(1);
TRACK(TrackBak,"ArrayRect_Error\n");
return (STAT);
}
void ArrayRect_show (ArrayRect   *This)
{
longaddr       StartAddr = 0;
tokentype      Token     = This->Token;
sprintf (Msg, "\n The  ArrayRect MAP:: [%2u:%8u]\n",
Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr             = (longaddr )This;
sprintf (Msg,  " sizeof ArrayRect    : %3u\n",   sizeof(ArrayRect));
TraceMsg (0, Msg);
sprintf (Msg,  " This                      :      @%x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  " This->That                : +%3d @%x   = %x\n",
(char *)&This->That     - StartAddr, &This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Token               : +%3d @%x   = [%2u:%8u]\n",
(char *)&This->Token    - StartAddr, &This->Token,
This->Token.DbId, This->Token.Handle );
TraceMsg (0, Msg);
sprintf (Msg,  " This->Id                  : +%3d @%x   = %2u\n",
(char *)&This->Id       - StartAddr, &This->Id, This->Id);
TraceMsg (0, Msg);
sprintf (Msg,  " This->MemberDrawObjs      : +%3d @%x   = [%4u:%2u]\n",
(char *)&This->MemberDrawObjs - StartAddr,
&This->MemberDrawObjs,
This->Token.DbId,            This->MemberDrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Xarray              : +%3d @%x   = %4u %4u %4u %4u\n",
(char *)&This->Xarray  - StartAddr, &This->Xarray,
This->Xarray[0],This->Xarray[1],This->Xarray[2],This->Xarray[3]);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Yarray              : +%3d @%x   = %4u %4u %4u %4u\n",
(char *)&This->Yarray  - StartAddr, &This->Yarray,
This->Yarray[0],This->Yarray[1],This->Yarray[2],This->Yarray[3]);
TraceMsg (0, Msg);
TraceMsg (0, "\n");
return;
}
boolean ArrayRect_delete (ArrayRect   **This,   deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
ArrayRect   *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  ArrayRect_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " ArrayRect [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"ArrayRect_delete\n");
return (STAT);
}
boolean DblPtrRect_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
DblPtrRect      Rect;
if (ClassBug)
TraceMsg (0, "\n\n  DBL PTR RECT  Map...\n");
if (EnvGetMemberId     ("XyCoords",           McStat, &XyCoords_Attr))
if (EnvGetClassId      ("DblPtrRect",         McStat, &DblPtrRect_Class))
if (EnvInitClassMap    (DblPtrRect_Class,     sizeof(DblPtrRect),
C_Apl,                McStat))
{
StartAddr= (longaddr )&Rect;
Offset   = (size_t)((longaddr )&Rect.That    -  StartAddr);
Env_AppendToMap    (That_AttrNum,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Token   -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Token_Attr,            Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Id      -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Id_Attr,               Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.MemberDrawObjs  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (MemberDrawObjs_Attr,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.PartObjSlotAttr -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (PartObj_Slot,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.XyCoords -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (XyCoords_Attr,         Offset,     McStat);
if (Normal(*Status))
Env_InvokeMap      (C_Apl,                             McStat);
}
TRACK(TrackBak,"DblPtrRect_InitClass\n");
return (STAT);
}
DblPtrRect  *DblPtrRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status)
{
tokentype    Token     = NullToken;
DblPtrRect  *Image     = NullPtr;
addrtype     ArrayAddr = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg,
"  DblPtrRect_new1 Anchor= [%4u:%6u] XyPoints @ (%x, %x)\n",
AnchorTkn->DbId, AnchorTkn->Handle, o, e))
TraceMsg (0, Msg);
if (Object_Create     (AnchorTkn,   DblPtrRect_Class,  McStat,   &Token))
if (Attr_ArrayCreate  (&Token,      XyCoords_Attr,     2,  sizeof(short*),
McStat,     &ArrayAddr))
if (Attr_SubArrayCreate
(&Token,      XyCoords_Attr,  0, 4,  sizeof(short),
McStat,     &ArrayAddr))
if (Attr_SubArrayCreate
(&Token,      XyCoords_Attr,  1, 4,  sizeof(short),
McStat,     &ArrayAddr))
if (Object_GetImage   (&Token,      McStat,         (addrtype *)&Image))
if (DeBug || OaBug || ClassBug)
DblPtrRect_show (Image);
if (Normal(*Status))
{
if (DrawLib01)
Image->Id               = DrawLib_NewId (McStat);
Image->MemberDrawObjs      = NullHandle;
Image->draw                = DblPtrRect_draw;
Image->area                = DblPtrRect_area;
Image->destruct            = DblPtrRect_delete;
Image->XyCoords[0][0]   = o->xCoord;
Image->XyCoords[1][0]   = o->yCoord;
Image->XyCoords[0][1]   = e->xCoord;
Image->XyCoords[1][1]   = o->yCoord;
Image->XyCoords[0][2]   = o->xCoord;
Image->XyCoords[1][2]   = e->yCoord;
Image->XyCoords[0][3]   = e->xCoord;
Image->XyCoords[1][3]   = e->yCoord;
if (Normal(*Status))
DrawObjs_AddInto  (AnchorTkn,  &Token,  McStat);
if (DeBug || OaBug || ClassBug)
DblPtrRect_show (Image);
}
STAT;
return (Image);
}
DblPtrRect  *DblPtrRect_new1     (tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
DblPtrRect      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  DblPtrRect_new3 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (RecTkn,       McStat,         (addrtype *)&Image))
{
Image->draw                = DblPtrRect_draw;
Image->area                = DblPtrRect_area;
Image->destruct            = DblPtrRect_delete;
}
STAT;
return (Image);
}
lt64        DblPtrRect_area (DblPtrRect   *This, ft F,lt Z,zz *Status)
{
lt64 RecArea = 0;
RecArea = abs( (This->XyCoords[0][3] - This->XyCoords[0][0])
* (This->XyCoords[1][3] - This->XyCoords[1][0]) );
if (DrawBug || DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Area of DblPtrRect = %d\n", RecArea))
TraceMsg (0, Msg);
STAT;
return (RecArea);
}
boolean     DblPtrRect_draw (DblPtrRect   *This,  ft F,lt Z,zz *Status)
{
if (DrawBug || DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n This->XyCoords[0][0] :%d\n", This->XyCoords[0][0]);
TraceMsg (0, Msg);
sprintf (Msg, " This->XyCoords[1][0] :%d\n", This->XyCoords[1][0]);
TraceMsg (0, Msg);
sprintf (Msg, " This->XyCoords[0][3] :%d\n", This->XyCoords[0][3]);
TraceMsg (0, Msg);
sprintf (Msg, " This->XyCoords[1][3] :%d\n", This->XyCoords[1][3]);
TraceMsg (0, Msg);
}
if (DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n Draw the DblPtrRect :: This = %x; Token[%2u:%8u]\n",
This, This->Token.DbId, This->Token.Handle);
TraceMsg (0, Msg);
Object_Dump (&This->Token);
}
TRACK(TrackBak,"DblPtrRect_Draw\n");
return (STAT);
}
boolean    DblPtrRect_dump (DblPtrRect   *This, ft F,lt Z,zz *Status)
{
TraceMsg (0, "\n The  DblPtrRect ::\n");
Object_Dump (&This->Token);
TRACK(TrackBak,"DblPtrRect_Dump\n");
return (STAT);
}
boolean    DblPtrRect_error (DblPtrRect   *This,  char * msg,
ft F,lt Z,zz *Status)
{
sprintf (Msg, "\n  *** DblPtrRect:: %s @%x\n", msg, This);
SendMsg (0, Msg);
exit(1);
TRACK(TrackBak,"DblPtrRect_Error\n");
return (STAT);
}
void DblPtrRect_show (DblPtrRect   *This)
{
longaddr       StartAddr = 0;
tokentype      Token     = This->Token;
sprintf (Msg, "\n The  DblPtrRect MAP:: [%2u:%8u]\n",
Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr             = (longaddr )This;
sprintf (Msg,  " sizeof DblPtrRect    : %3u\n",   sizeof(DblPtrRect));
TraceMsg (0, Msg);
sprintf (Msg,  " This                      :      @%x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  " This->That                : +%3d @%x   = %x\n",
(char *)&This->That     - StartAddr, &This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Token               : +%3d @%x   = [%2u:%8u]\n",
(char *)&This->Token    - StartAddr, &This->Token,
This->Token.DbId, This->Token.Handle );
TraceMsg (0, Msg);
sprintf (Msg,  " This->Id                  : +%3d @%x   = %2u\n",
(char *)&This->Id       - StartAddr, &This->Id, This->Id);
TraceMsg (0, Msg);
sprintf (Msg,  " This->MemberDrawObjs      : +%3d @%x   = [%4u:%2u]\n",
(char *)&This->MemberDrawObjs - StartAddr,
&This->MemberDrawObjs,
This->Token.DbId,            This->MemberDrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " This->XyCoords[0]         : +%3d @%x   = %4u %4u %4u %4u\n",
(char *)&This->XyCoords[0]  - StartAddr, &This->XyCoords[0],
This->XyCoords[0][0],This->XyCoords[0][1],
This->XyCoords[0][2],This->XyCoords[0][3]);
TraceMsg (0, Msg);
sprintf (Msg,  " This->XyCoords[1]         : +%3d @%x   = %4u %4u %4u %4u\n",
(char *)&This->XyCoords[1]  - StartAddr, &This->XyCoords[1],
This->XyCoords[1][0],This->XyCoords[1][1],
This->XyCoords[1][2],This->XyCoords[1][3]);
TraceMsg (0, Msg);
TraceMsg (0, "\n");
return;
}
boolean DblPtrRect_delete (DblPtrRect   **This,   deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
DblPtrRect   *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  DblPtrRect_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " DblPtrRect [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"DblPtrRect_delete\n");
return (STAT);
}
boolean VarrayRect_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
VarrayRect      Rect;
if (ClassBug)
TraceMsg (0, "\n\n  VARRAY RECT  Map...\n");
if (EnvGetMemberId     ("xVarray",           McStat, &xVarray_Attr))
if (EnvGetMemberId     ("yVarray",           McStat, &yVarray_Attr))
if (EnvGetClassId      ("VarrayRect",        McStat, &VarrayRect_Class))
if (EnvInitClassMap    (VarrayRect_Class,    sizeof(VarrayRect),
C_Apl,               McStat))
{
StartAddr= (longaddr )&Rect;
Offset   = (size_t)((longaddr )&Rect.That    -  StartAddr);
Env_AppendToMap    (That_AttrNum,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Token   -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Token_Attr,            Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Id      -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Id_Attr,               Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.MemberDrawObjs  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (MemberDrawObjs_Attr,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.PartObjSlotAttr -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (PartObj_Slot,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.xVarray -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (xVarray_Attr,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.yVarray -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (yVarray_Attr,          Offset,     McStat);
if (Normal(*Status))
Env_InvokeMap      (C_Apl,                             McStat);
}
TRACK(TrackBak,"VarrayRect_InitClass\n");
return (STAT);
}
VarrayRect  *VarrayRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status)
{
tokentype    Token     = NullToken;
VarrayRect  *Image     = NullPtr;
addrtype     ArrayAddr = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg,
"  VarrayRect_new1 Anchor= [%4u:%6u] XyPoints @ (%x, %x)\n",
AnchorTkn->DbId, AnchorTkn->Handle, o, e))
TraceMsg (0, Msg);
if (Object_Create     (AnchorTkn,   VarrayRect_Class,  McStat,   &Token))
if (Attr_ArrayCreate  (&Token,      xVarray_Attr,     4,  sizeof(short),
McStat,     &ArrayAddr))
if (Attr_ArrayCreate  (&Token,      yVarray_Attr,     4,  sizeof(short),
McStat,     &ArrayAddr))
if (Object_GetImage   (&Token,      McStat,         (addrtype *)&Image))
if (DeBug || OaBug || ClassBug)
VarrayRect_show (Image);
if (Normal(*Status))
{
if (DrawLib01)
Image->Id               = DrawLib_NewId (McStat);
Image->MemberDrawObjs      = NullHandle;
Image->draw                = VarrayRect_draw;
Image->area                = VarrayRect_area;
Image->destruct            = VarrayRect_delete;
Image->xVarray.Varray[0]   = o->xCoord;
Image->yVarray.Varray[0]   = o->yCoord;
Image->xVarray.Varray[1]   = e->xCoord;
Image->yVarray.Varray[1]   = o->yCoord;
Image->xVarray.Varray[2]   = o->xCoord;
Image->yVarray.Varray[2]   = e->yCoord;
Image->xVarray.Varray[3]   = e->xCoord;
Image->yVarray.Varray[3]   = e->yCoord;
if (Normal(*Status))
DrawObjs_AddInto  (AnchorTkn,  &Token,  McStat);
if (DeBug || OaBug || ClassBug)
VarrayRect_show (Image);
}
STAT;
return (Image);
}
VarrayRect  *VarrayRect_new1     (tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
VarrayRect      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  VarrayRect_new3 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (RecTkn,       McStat,         (addrtype *)&Image))
{
Image->draw                = VarrayRect_draw;
Image->area                = VarrayRect_area;
Image->destruct            = VarrayRect_delete;
}
STAT;
return (Image);
}
lt64        VarrayRect_area (VarrayRect   *This, ft F,lt Z,zz *Status)
{
lt64 RecArea = 0;
RecArea = abs( (This->xVarray.Varray[3] - This->xVarray.Varray[0])
* (This->yVarray.Varray[3] - This->yVarray.Varray[0]) );
if (DrawBug || DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Area of VarrayRect = %d\n", RecArea))
TraceMsg (0, Msg);
STAT;
return (RecArea);
}
boolean     VarrayRect_draw (VarrayRect   *This,  ft F,lt Z,zz *Status)
{
if (DrawBug || DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n This->xVarray[0] :%d\n", This->xVarray.Varray[0]);
TraceMsg (0, Msg);
sprintf (Msg, " This->yVarray[0] :%d\n", This->xVarray.Varray[0]);
TraceMsg (0, Msg);
sprintf (Msg, " This->xVarray[3] :%d\n", This->yVarray.Varray[3]);
TraceMsg (0, Msg);
sprintf (Msg, " This->yVarray[3] :%d\n", This->yVarray.Varray[3]);
TraceMsg (0, Msg);
}
if (DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n Draw the VarrayRect :: This = %x; Token[%2u:%8u]\n",
This, This->Token.DbId, This->Token.Handle);
TraceMsg (0, Msg);
Object_Dump (&This->Token);
}
TRACK(TrackBak,"VarrayRect_Draw\n");
return (STAT);
}
boolean    VarrayRect_dump (VarrayRect   *This, ft F,lt Z,zz *Status)
{
TraceMsg (0, "\n The  VarrayRect ::\n");
Object_Dump (&This->Token);
TRACK(TrackBak,"VarrayRect_Dump\n");
return (STAT);
}
boolean    VarrayRect_error (VarrayRect   *This,  char * msg,
ft F,lt Z,zz *Status)
{
sprintf (Msg, "\n  *** VarrayRect:: %s @%x\n", msg, This);
SendMsg (0, Msg);
exit(1);
TRACK(TrackBak,"VarrayRect_Error\n");
return (STAT);
}
void VarrayRect_show (VarrayRect   *This)
{
longaddr       StartAddr = 0;
tokentype      Token     = This->Token;
sprintf (Msg, "\n The  VarrayRect MAP:: [%2u:%8u]\n",
Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr             = (longaddr )This;
sprintf (Msg,  " sizeof VarrayRect    : %3u\n",   sizeof(VarrayRect));
TraceMsg (0, Msg);
sprintf (Msg,  " This                      :      @%x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  " This->That                : +%3d @%x   = %x\n",
(char *)&This->That     - StartAddr, &This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Token               : +%3d @%x   = [%2u:%8u]\n",
(char *)&This->Token    - StartAddr, &This->Token,
This->Token.DbId, This->Token.Handle );
TraceMsg (0, Msg);
sprintf (Msg,  " This->Id                  : +%3d @%x   = %2u\n",
(char *)&This->Id       - StartAddr, &This->Id, This->Id);
TraceMsg (0, Msg);
sprintf (Msg,  " This->MemberDrawObjs      : +%3d @%x   = [%4u:%2u]\n",
(char *)&This->MemberDrawObjs - StartAddr,
&This->MemberDrawObjs,
This->Token.DbId,            This->MemberDrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " This->xVarray.Varray      : +%3d @%x   = %4u %4u %4u %4u\n",
(char *)&This->xVarray.Varray  - StartAddr, &This->xVarray.Varray,
This->xVarray.Varray[0],This->xVarray.Varray[1],
This->xVarray.Varray[2],This->xVarray.Varray[3]);
TraceMsg (0, Msg);
sprintf (Msg,  " This->yVarray.Varray      : +%3d @%x   = %4u %4u %4u %4u\n",
(char *)&This->yVarray.Varray  - StartAddr, &This->yVarray.Varray,
(This->yVarray.Varray)[0],(This->yVarray.Varray)[1],
(This->yVarray.Varray)[2],(This->yVarray.Varray)[3]);
TraceMsg (0, Msg);
TraceMsg (0, "\n");
return;
}
boolean VarrayRect_delete (VarrayRect   **This,   deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
VarrayRect   *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  VarrayRect_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " VarrayRect [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"VarrayRect_delete\n");
return (STAT);
}
boolean IntChunkRect_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
IntChunkRect    Rect;
if (ClassBug)
TraceMsg (0, "\n\n  INT ARRAY RECT  Map...\n");
if (EnvGetMemberId     ("Xcoords",            McStat, &Xcoords_Attr))
if (EnvGetMemberId     ("Ycoords",            McStat, &Ycoords_Attr))
if (EnvGetClassId      ("IntChunkRect",       McStat, &IntChunkRect_Class))
if (EnvInitClassMap    (IntChunkRect_Class,      sizeof(IntChunkRect),
C_Apl,                McStat))
{
StartAddr= (longaddr )&Rect;
Offset   = (size_t)((longaddr )&Rect.That    -  StartAddr);
Env_AppendToMap    (That_AttrNum,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Token   -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Token_Attr,            Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Id      -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Id_Attr,               Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.MemberDrawObjs  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (MemberDrawObjs_Attr,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.PartObjSlotAttr -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (PartObj_Slot,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Xcoords -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Xcoords_Attr,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Ycoords -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Ycoords_Attr,          Offset,     McStat);
if (Normal(*Status))
Env_InvokeMap      (C_Apl,                             McStat);
}
EnvInvokeMap       (C_Apl,                McStat);
TRACK(TrackBak,"IntChunkRect_InitClass\n");
return (STAT);
}
IntChunkRect  *IntChunkRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status)
{
tokentype    Token     = NullToken;
IntChunkRect  *Image     = NullPtr;
addrtype     ArrayAddr = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg,
"  IntChunkRect_new1 Anchor= [%4u:%6u] XyPoints @ (%x, %x)\n",
AnchorTkn->DbId, AnchorTkn->Handle, o, e))
TraceMsg (0, Msg);
if (Object_Create     (AnchorTkn,   IntChunkRect_Class,  McStat,   &Token))
if (Attr_ArrayCreate  (&Token,      Xcoords_Attr,     4,  sizeof(int),
McStat,     &ArrayAddr))
if (Attr_ArrayCreate  (&Token,      Ycoords_Attr,     4,  sizeof(int),
McStat,     &ArrayAddr))
if (Object_GetImage   (&Token,      McStat,         (addrtype *)&Image))
if (DeBug || OaBug || ClassBug)
IntChunkRect_show (Image);
if (Normal(*Status))
{
if (DrawLib01)
Image->Id               = DrawLib_NewId (McStat);
Image->MemberDrawObjs      = NullHandle;
Image->draw                = IntChunkRect_draw;
Image->area                = IntChunkRect_area;
Image->destruct            = IntChunkRect_delete;
Image->Xcoords.Varray[0]   = (int )o->xCoord;
Image->Ycoords.Varray[0]   = (int )o->yCoord;
Image->Xcoords.Varray[1]   = (int )e->xCoord;
Image->Ycoords.Varray[1]   = (int )o->yCoord;
Image->Xcoords.Varray[2]   = (int )o->xCoord;
Image->Ycoords.Varray[2]   = (int )e->yCoord;
Image->Xcoords.Varray[3]   = (int )e->xCoord;
Image->Ycoords.Varray[3]   = (int )e->yCoord;
if (Normal(*Status))
DrawObjs_AddInto  (AnchorTkn,  &Token,  McStat);
if (DeBug || OaBug || ClassBug)
IntChunkRect_show (Image);
}
STAT;
return (Image);
}
IntChunkRect  *IntChunkRect_new1     (tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
IntChunkRect      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  IntChunkRect_new3 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (RecTkn,       McStat,         (addrtype *)&Image))
{
Image->draw                = IntChunkRect_draw;
Image->area                = IntChunkRect_area;
Image->destruct            = IntChunkRect_delete;
}
STAT;
return (Image);
}
lt64        IntChunkRect_area (IntChunkRect   *This, ft F,lt Z,zz *Status)
{
lt64 RecArea = 0;
RecArea = abs( (This->Xcoords.Varray[3] - This->Xcoords.Varray[0])
* (This->Ycoords.Varray[3] - This->Ycoords.Varray[0]) );
if (DrawBug || DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Area of IntChunkRect = %d\n", RecArea))
TraceMsg (0, Msg);
STAT;
return (RecArea);
}
boolean     IntChunkRect_draw (IntChunkRect   *This,  ft F,lt Z,zz *Status)
{
if (DrawBug || DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n This->Xcoords[0] :%d\n", This->Xcoords.Varray[0]);
TraceMsg (0, Msg);
sprintf (Msg, " This->Ycoords[0] :%d\n", This->Xcoords.Varray[0]);
TraceMsg (0, Msg);
sprintf (Msg, " This->Xcoords[3] :%d\n", This->Ycoords.Varray[3]);
TraceMsg (0, Msg);
sprintf (Msg, " This->Ycoords[3] :%d\n", This->Ycoords.Varray[3]);
TraceMsg (0, Msg);
}
if (DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n Draw the IntChunkRect :: This = %x; Token[%2u:%8u]\n",
This, This->Token.DbId, This->Token.Handle);
TraceMsg (0, Msg);
Object_Dump (&This->Token);
}
TRACK(TrackBak,"IntChunkRect_Draw\n");
return (STAT);
}
boolean    IntChunkRect_dump (IntChunkRect   *This, ft F,lt Z,zz *Status)
{
TraceMsg (0, "\n The  IntChunkRect ::\n");
Object_Dump (&This->Token);
TRACK(TrackBak,"IntChunkRect_Dump\n");
return (STAT);
}
boolean    IntChunkRect_error (IntChunkRect   *This,  char * msg,
ft F,lt Z,zz *Status)
{
sprintf (Msg, "\n  *** IntChunkRect:: %s @%x\n", msg, This);
SendMsg (0, Msg);
exit(1);
TRACK(TrackBak,"IntChunkRect_Error\n");
return (STAT);
}
void IntChunkRect_show (IntChunkRect   *This)
{
longaddr       StartAddr = 0;
tokentype      Token     = This->Token;
sprintf (Msg, "\n The  IntChunkRect MAP:: [%2u:%8u]\n",
Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr             = (longaddr )This;
sprintf (Msg,  " sizeof IntChunkRect    : %3u\n",   sizeof(IntChunkRect));
TraceMsg (0, Msg);
sprintf (Msg,  " This                      :      @%x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  " This->That                : +%3d @%x   = %x\n",
(char *)&This->That     - StartAddr, &This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Token               : +%3d @%x   = [%2u:%8u]\n",
(char *)&This->Token    - StartAddr, &This->Token,
This->Token.DbId, This->Token.Handle );
TraceMsg (0, Msg);
sprintf (Msg,  " This->Id                  : +%3d @%x   = %2u\n",
(char *)&This->Id       - StartAddr, &This->Id, This->Id);
TraceMsg (0, Msg);
sprintf (Msg,  " This->MemberDrawObjs      : +%3d @%x   = [%4u:%2u]\n",
(char *)&This->MemberDrawObjs - StartAddr,
&This->MemberDrawObjs,
This->Token.DbId,            This->MemberDrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Xcoords.Varray      : +%3d @%x   = %4u %4u %4u %4u\n",
(char *)&This->Xcoords.Varray  - StartAddr, &This->Xcoords.Varray,
This->Xcoords.Varray[0],This->Xcoords.Varray[1],
This->Xcoords.Varray[2],This->Xcoords.Varray[3]);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Ycoords.Varray      : +%3d @%x   = %4u %4u %4u %4u\n",
(char *)&This->Ycoords.Varray  - StartAddr, &This->Ycoords.Varray,
(This->Ycoords.Varray)[0],(This->Ycoords.Varray)[1],
(This->Ycoords.Varray)[2],(This->Ycoords.Varray)[3]);
TraceMsg (0, Msg);
TraceMsg (0, "\n");
return;
}
boolean IntChunkRect_delete
(IntChunkRect   **This,   deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
IntChunkRect   *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  IntChunkRect_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " IntChunkRect [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"IntChunkRect_delete\n");
return (STAT);
}
boolean VchunkRect_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
VchunkRect      Rect;
if (ClassBug)
TraceMsg (0, "\n\n  VCHUNK  RECT  Map...\n");
if (EnvGetMemberId     ("XyDir",              McStat, &XyDir_Attr))
if (EnvGetClassId      ("VchunkRect",         McStat, &VchunkRect_Class))
if (EnvInitClassMap    (VchunkRect_Class,     sizeof(VchunkRect),
C_Apl,                McStat))
{
StartAddr= (longaddr )&Rect;
Offset   = (size_t)((longaddr )&Rect.That    -  StartAddr);
Env_AppendToMap    (That_AttrNum,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Token   -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Token_Attr,            Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Id      -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Id_Attr,               Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.MemberDrawObjs  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (MemberDrawObjs_Attr,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.PartObjSlotAttr -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (PartObj_Slot,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.XyDir   -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (XyDir_Attr,            Offset,     McStat);
if (Normal(*Status))
Env_InvokeMap      (C_Apl,                             McStat);
}
TRACK(TrackBak,"VchunkRect_InitClass\n");
return (STAT);
}
#define   Vchunk(i,j)  Vchunk[i*4+j]
VchunkRect  *VchunkRect_new0
(tokentype    *AnchorTkn,
XyPoint      *o,         XyPoint      *e,
ft F,lt Z,zz *Status)
{
tokentype    Token     = NullToken;
VchunkRect  *Image     = NullPtr;
short       *Vchunk    = NullPtr;
tokentype    VchunkTkn = NullToken;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg,
"  VchunkRect_new1 Anchor= [%4u:%6u] XyPoints @ (%x, %x)\n",
AnchorTkn->DbId, AnchorTkn->Handle, o, e))
TraceMsg (0, Msg);
if (Object_Create       (AnchorTkn,   VchunkRect_Class,  McStat,   &Token))
if (Object_GetImage     (&Token,      McStat,         (addrtype *)&Image))
if (Vchunk_Create       (&Token,      sizeof(short),  8,   0,
McStat,     &VchunkTkn))
if (Vchunk_PutStackPtr  (&VchunkTkn,  8,     McStat,  (addrtype *)&Vchunk))
if (Normal(*Status))
{
if (DrawLib01)
Image->Id               = DrawLib_NewId (McStat);
Image->MemberDrawObjs      = NullHandle;
Image->draw                = VchunkRect_draw;
Image->area                = VchunkRect_area;
Image->destruct            = VchunkRect_delete;
Image->XyDir  = VchunkTkn;
Vchunk[0]  = o->xCoord;
Vchunk[1]  = o->yCoord;
Vchunk[2]  = e->xCoord;
Vchunk[3]  = o->yCoord;
Vchunk[4]  = o->xCoord;
Vchunk[5]  = e->yCoord;
Vchunk[6]  = e->xCoord;
Vchunk[7]  = e->yCoord;
if (Normal(*Status))
DrawObjs_AddInto  (AnchorTkn,  &Token,  McStat);
if (DeBug || OaBug || ClassBug)
VchunkRect_show (Image);
}
STAT;
return (Image);
}
VchunkRect  *VchunkRect_new1     (tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
VchunkRect      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  VchunkRect_new3 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (RecTkn,       McStat,         (addrtype *)&Image))
{
Image->draw                = VchunkRect_draw;
Image->area                = VchunkRect_area;
Image->destruct            = VchunkRect_delete;
}
STAT;
return (Image);
}
lt64        VchunkRect_area (VchunkRect   *This, ft F,lt Z,zz *Status)
{
lt64         RecArea   = 0;
short       *Vchunk    = NullPtr;
if (Vchunk_GetAddress (&This->XyDir,  McStat,  (addrtype *)&Vchunk))
RecArea = abs( (Vchunk[6] - Vchunk[0])
* (Vchunk[7] - Vchunk[1]) );
if (DrawBug || DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Area of VchunkRect = %d\n", RecArea))
TraceMsg (0, Msg);
STAT;
return (RecArea);
}
boolean     VchunkRect_draw (VchunkRect   *This,  ft F,lt Z,zz *Status)
{
short       *Vchunk    = NullPtr;
if (Vchunk_GetAddress (&This->XyDir,  McStat,  (addrtype *)&Vchunk))
if (DrawBug || DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n This->x   [0][0] :%d\n", Vchunk[0]);
TraceMsg (0, Msg);
sprintf (Msg, " This->y   [0][1] :%d\n", Vchunk[1]);
TraceMsg (0, Msg);
sprintf (Msg, " This->x   [3][0] :%d\n", Vchunk[6]);
TraceMsg (0, Msg);
sprintf (Msg, " This->y   [3][1] :%d\n", Vchunk[7]);
TraceMsg (0, Msg);
}
if (DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n Draw the VchunkRect :: This = %x; Token[%2u:%8u]\n",
This, This->Token.DbId, This->Token.Handle);
TraceMsg (0, Msg);
Object_Dump (&This->Token);
}
TRACK(TrackBak,"VchunkRect_Draw\n");
return (STAT);
}
boolean    VchunkRect_dump (VchunkRect   *This, ft F,lt Z,zz *Status)
{
TraceMsg (0, "\n The  VchunkRect ::\n");
Object_Dump (&This->Token);
TRACK(TrackBak,"VchunkRect_Dump\n");
return (STAT);
}
boolean    VchunkRect_error (VchunkRect   *This,  char * msg,
ft F,lt Z,zz *Status)
{
sprintf (Msg, "\n  *** VchunkRect :: %s  @%x\n", msg, This);
SendMsg (0, Msg);
exit(1);
TRACK(TrackBak,"VchunkRect_Error\n");
return (STAT);
}
void VchunkRect_show (VchunkRect   *This)
{
longaddr       StartAddr = 0;
tokentype      Token     = This->Token;
statustype     ShellStatus  = Env_Normal;
sprintf (Msg, "\n The  VchunkRect MAP:: [%2u:%8u]\n",
Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr             = (longaddr )This;
sprintf (Msg,  " sizeof VchunkRect    : %3u\n",   sizeof(VchunkRect));
TraceMsg (0, Msg);
sprintf (Msg,  " This                      :      @%x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  " This->That                : +%3d @%x   = %x\n",
(char *)&This->That     - StartAddr, &This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Token               : +%3d @%x   = [%2u:%8u]\n",
(char *)&This->Token    - StartAddr, &This->Token,
This->Token.DbId, This->Token.Handle );
TraceMsg (0, Msg);
sprintf (Msg,  " This->Id                  : +%3d @%x   = %2u\n",
(char *)&This->Id       - StartAddr, &This->Id, This->Id);
TraceMsg (0, Msg);
sprintf (Msg,  " This->MemberDrawObjs      : +%3d @%x   = [%4u:%2u]\n",
(char *)&This->MemberDrawObjs - StartAddr,
&This->MemberDrawObjs,
This->Token.DbId,            This->MemberDrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " This->XyDir               : +%3d @%x   = [%4u:%6u]\n",
(char *)&This->XyDir  - StartAddr, &This->XyDir,
This->XyDir.DbId,  This->XyDir.Handle);
TraceMsg (0, Msg);
Vchunk_Dump  (&This->XyDir,   ShellMcStat);
TraceMsg (0, "\n");
return;
}
boolean VchunkRect_delete (VchunkRect   **This,   deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
VchunkRect   *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  VchunkRect_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " VchunkRect [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"VchunkRect_delete\n");
return (STAT);
}
boolean RefRect_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
RefRect         Rect;
if (ClassBug)
TraceMsg (0, "\n\n  REF RECT  Map...\n");
if (EnvGetMemberId     ("RefOrigin",          McStat, &RefOrigin_Attr))
if (EnvGetMemberId     ("RefExtent",          McStat, &RefExtent_Attr))
if (EnvGetClassId      ("RefRect",            McStat, &RefRect_Class))
if (EnvInitClassMap    (RefRect_Class,        sizeof(RefRect),
C_Apl,                McStat))
{
StartAddr= (longaddr )&Rect;
Offset   = (size_t)((longaddr )&Rect.That    -  StartAddr);
Env_AppendToMap    (That_AttrNum,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Token   -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Token_Attr,            Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Id      -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Id_Attr,               Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.MemberDrawObjs  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (MemberDrawObjs_Attr,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.PartObjSlotAttr -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (PartObj_Slot,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.RefOrigin  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (RefOrigin_Attr,         Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.RefExtent  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (RefExtent_Attr,         Offset,     McStat);
if (Normal(*Status))
Env_InvokeMap      (C_Apl,                             McStat);
}
TRACK(TrackBak,"RefRect_InitClass\n");
return (STAT);
}
RefRect    *RefRect_new0
(tokentype    *AnchorTkn,
short         i0,        short         i1,
short         i01,       ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
RefRect        *Image  = NullPtr;
CartesianPoint *o      = NullPtr;
CartesianPoint *e      = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  RefRect_New0 Anchor= [%4u:%6u] @ (%4u,%4u, %4u)\n",
AnchorTkn->DbId, AnchorTkn->Handle, i0, i1, i01))
TraceMsg (0, Msg);
if (Object_Create   (AnchorTkn,    RefRect_Class,  McStat,   &Token))
if (Object_GetImage (&Token,       McStat,       (addrtype *)&Image))
{
if (DrawLib01)
Image->Id               = DrawLib_NewId (McStat);
Image->MemberDrawObjs      = NullHandle;
Image->draw                = RefRect_draw;
Image->area                = RefRect_area;
Image->destruct            = RefRect_delete;
Image->RefOrigin.ObjAddr   = (Point *)o;
Image->RefExtent.ObjAddr   = (Point *)e;
DrawObjs_AddInto  (AnchorTkn,  &Token,  McStat);
}
STAT;
return (Image);
}
RefRect  *RefRect_new1
(tokentype    *AnchorTkn,
Point        *o,         Point        *e,
ft F,lt Z,zz *Status)
{
tokentype     Token  = NullToken;
RefRect      *Image  = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  RefRect_New1 Anchor= [%4u:%6u] @ (%x, %x)\n",
AnchorTkn->DbId, AnchorTkn->Handle, o, e))
TraceMsg (0, Msg);
if (Object_Create     (AnchorTkn,    RefRect_Class,  McStat,   &Token))
if (Object_GetImage   (&Token,       McStat,       (addrtype *)&Image))
{
if (DrawLib01)
Image->Id               = DrawLib_NewId (McStat);
Image->MemberDrawObjs      = NullHandle;
Image->draw                = RefRect_draw;
Image->area                = RefRect_area;
Image->destruct            = RefRect_delete;
Image->RefOrigin.ObjAddr   = o;
Image->RefOrigin.ObjTkn    = o->Token;
Image->RefExtent.ObjAddr   = e;
Image->RefExtent.ObjTkn    = e->Token;
if (Normal(*Status))
DrawObjs_AddInto  (AnchorTkn,  &Token,  McStat);
}
STAT;
return (Image);
}
RefRect  *RefRect_new2
(tokentype    *AnchorTkn,
tokentype    *oTkn,      tokentype    *eTkn,
ft F,lt Z,zz *Status)
{
tokentype       Token  = NullToken;
RefRect        *Image  = NullPtr;
Point          *o      = NullPtr;
Point          *e      = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg,
"  RefRect_new2 Anchor= [%4u:%6u] @ o= [%4u:%6u], e= [%4u:%6u]\n",
AnchorTkn->DbId, AnchorTkn->Handle,
oTkn->DbId, eTkn->Handle,oTkn->DbId, eTkn->Handle))
TraceMsg (0, Msg);
if (Object_Create   (AnchorTkn,    RefRect_Class,  McStat,     &Token))
if (Object_GetImage (&Token,       McStat,         (addrtype *)&Image))
if (Object_GetImage (oTkn,         McStat,         (addrtype *)&o))
if (Object_GetImage (eTkn,         McStat,         (addrtype *)&e))
{
if (DrawLib01)
Image->Id               = ++DrawLib01->DrawId;
Image->MemberDrawObjs      = NullHandle;
Image->draw                = RefRect_draw;
Image->area                = RefRect_area;
Image->destruct            = RefRect_delete;
Image->RefOrigin.ObjAddr   = o;
Image->RefOrigin.ObjTkn    = o->Token;
Image->RefExtent.ObjAddr   = e;
Image->RefExtent.ObjTkn    = e->Token;
DrawObjs_AddInto  (AnchorTkn,  &Token,  McStat);
}
STAT;
return (Image);
}
RefRect  *RefRect_new3
(tokentype    *RecTkn,    ft F,lt Z,zz *Status)
{
RefRect        *Image     = NullPtr;
Point          *Point0    = NullPtr;
tokentype       PointTkn  = NullToken;
numtype         DrawClass = 0;
CartesianPoint *c0        = NullPtr;
PolarPoint     *p0        = NullPtr;
if (DeBug || OaBug || ClassBug)
if (sprintf (Msg, "  RefRect_new3 Anchor= [%4u:%6u]\n",
RecTkn->DbId, RecTkn->Handle))
TraceMsg (0, Msg);
if (Object_GetImage (RecTkn,       McStat,         (addrtype *)&Image))
{
Image->draw                = RefRect_draw;
Image->area                = RefRect_area;
Image->destruct            = RefRect_delete;
}
if (Normal(*Status))
if (Image->RefOrigin.ObjTkn.Handle)
if (Object_GetImage (&Image->RefOrigin.ObjTkn, McStat, (addrtype *)&Point0))
Image->RefOrigin.ObjAddr  = Point0;
if (Normal(*Status))
if (Image->RefExtent.ObjTkn.Handle)
if (Object_GetImage (&Image->RefExtent.ObjTkn, McStat, (addrtype *)&Point0))
Image->RefExtent.ObjAddr  = Point0;
if (Normal(*Status))
if (Image->RefOrigin.ObjTkn.Handle)
{
PointTkn   = Image->RefOrigin.ObjTkn;
DrawClass  = Object_IsA (&PointTkn,  McStat);
if (DrawClass == CartesianPoint_Class)
c0 = CartesianPoint_new1 (&PointTkn,  McStat);
else
p0 = PolarPoint_new1     (&PointTkn,  McStat);
}
if (Normal(*Status))
if (Image->RefExtent.ObjTkn.Handle)
{
PointTkn   = Image->RefExtent.ObjTkn;
DrawClass  = Object_IsA (&PointTkn,  McStat);
if (DrawClass == CartesianPoint_Class)
c0 = CartesianPoint_new1 (&PointTkn,  McStat);
else
p0 = PolarPoint_new1     (&PointTkn,  McStat);
}
STAT;
return (Image);
}
lt64        RefRect_area (RefRect   *This, ft F,lt Z,zz *Status)
{
lt64 RecArea = 0;
RecArea = abs( (Point_x(This->RefExtent.ObjAddr)
- Point_x(This->RefOrigin.ObjAddr))
* (Point_y(This->RefExtent.ObjAddr)
- Point_y(This->RefOrigin.ObjAddr)) );
if (DrawBug || DeBug || OaBug || ClassBug)
if (sprintf (Msg, "\n Area of RefRect = %d\n", RecArea))
TraceMsg (0, Msg);
STAT;
return (RecArea);
}
boolean     RefRect_draw (RefRect   *This,  ft F,lt Z,zz *Status)
{
if (DrawBug || DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n This->RefOrigin->x() :%d\n",
Point_x(This->RefOrigin.ObjAddr));
TraceMsg (0, Msg);
sprintf (Msg, " This->RefOrigin->y() :%d\n",
Point_y(This->RefOrigin.ObjAddr));
TraceMsg (0, Msg);
sprintf (Msg, " This->RefExtent->x() :%d\n",
Point_x(This->RefExtent.ObjAddr));
TraceMsg (0, Msg);
sprintf (Msg, " This->RefExtent->y() :%d\n",
Point_y(This->RefExtent.ObjAddr));
TraceMsg (0, Msg);
} else {
Point_x(This->RefOrigin.ObjAddr);
Point_y(This->RefOrigin.ObjAddr);
Point_x(This->RefExtent.ObjAddr);
Point_y(This->RefExtent.ObjAddr);
}
if (DeBug || OaBug || ClassBug)
{
sprintf (Msg, "\n Draw the RefRect :: This = %x; Token[%2u:%8u]\n",
This, This->Token.DbId, This->Token.Handle);
TraceMsg (0, Msg);
Object_Dump (&This->Token);
TraceMsg (0, "   RefOrigin :: Point");
Object_Dump (&This->RefOrigin.ObjTkn);
TraceMsg (0, "   RefExtent :: Point");
Object_Dump (&This->RefExtent.ObjTkn);
}
TRACK(TrackBak,"RefRect_Draw\n");
return (STAT);
}
boolean    RefRect_dump (RefRect   *This, ft F,lt Z,zz *Status)
{
TraceMsg (0, "\n The  RefRect ::\n");
Object_Dump (&This->Token);
TRACK(TrackBak,"RefRect_Dump\n");
return (STAT);
}
boolean    RefRect_error (RefRect   *This,  char * msg,
ft F,lt Z,zz *Status)
{
sprintf (Msg, "\n  *** RefRect:: %s @%x\n", msg, This);
SendMsg (0, Msg);
exit(1);
TRACK(TrackBak,"RefRect_Error\n");
return (STAT);
}
void RefRect_show (RefRect   *This)
{
longaddr       StartAddr = 0;
tokentype      Token     = This->Token;
sprintf (Msg, "\n The  RefRect MAP:: [%2u:%8u]\n",
Token.DbId, Token.Handle);
TraceMsg (0, Msg);
StartAddr             = (longaddr )This;
sprintf (Msg,  " sizeof RefRect            : %3u\n",   sizeof(RefRect));
TraceMsg (0, Msg);
sprintf (Msg,  " This                      :      @%x\n",   This );
TraceMsg (0, Msg);
sprintf (Msg,  " This->That                : +%3d @%x   = %x\n",
(char *)&This->That     - StartAddr, &This->That, This->That);
TraceMsg (0, Msg);
sprintf (Msg,  " This->Token               : +%3d @%x   = [%2u:%8u]\n",
(char *)&This->Token    - StartAddr, &This->Token,
This->Token.DbId, This->Token.Handle );
TraceMsg (0, Msg);
sprintf (Msg,  " This->Id                  : +%3d @%x   = %2u\n",
(char *)&This->Id       - StartAddr, &This->Id, This->Id);
TraceMsg (0, Msg);
sprintf (Msg,  " This->MemberDrawObjs      : +%3d @%x   = [%4u:%2u]\n",
(char *)&This->MemberDrawObjs - StartAddr,
&This->MemberDrawObjs,
This->Token.DbId,            This->MemberDrawObjs);
TraceMsg (0, Msg);
sprintf (Msg,  " This->RefOrigin              : +%3d @%x   = %x\n",
(char *)&This->RefOrigin   - StartAddr, &This->RefOrigin,
&This->RefOrigin);
TraceMsg (0, Msg);
sprintf (Msg,  " This->RefOrigin.ObjAddr      : = %x\n",
This->RefOrigin.ObjAddr);
TraceMsg (0, Msg);
sprintf (Msg,  " This->RefOrigin.ObjTkn       : = [%4u:%6u]\n",
This->RefOrigin.ObjTkn.DbId, This->RefOrigin.ObjTkn.Handle);
TraceMsg (0, Msg);
sprintf (Msg,  " This->RefExtent              : +%3d @%x   = %x\n",
(char *)&This->RefExtent   - StartAddr, &This->RefExtent,
&This->RefExtent);
TraceMsg (0, Msg);
sprintf (Msg,  " This->RefExtent.ObjAddr      : = %x\n",
This->RefExtent.ObjAddr);
TraceMsg (0, Msg);
sprintf (Msg,  " This->RefExtent.ObjTkn       : = [%4u:%6u]\n",
This->RefExtent.ObjTkn.DbId, This->RefExtent.ObjTkn.Handle);
TraceMsg (0, Msg);
TraceMsg (0, "\n");
return;
}
boolean RefRect_delete (RefRect   **This,   deletetype    DbEvent,
ft F,lt Z,zz *Status)
{
RefRect   *That  = *This;
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "\n  RefRect_delete ... ~Delete\n");
if (ClassBug)
if (sprintf (Msg, " RefRect [%2u:%8u] %s in DB\n",
(*This)->Token.DbId, (*This)->Token.Handle, DeleteStr[DbEvent]))
TraceMsg (0, Msg);
switch (DbEvent)
{
case dbFree:
Object_FreeImage   (&That->Token,  McStat);
break;
case dbCommit:
Object_CommitImage (&That->Token,  True,    McStat);
break;
case dbDelete:
Object_Delete      (&That->Token,  McStat);
}
*This   = NullPtr;
TRACK(TrackBak,"RefRect_delete\n");
return (STAT);
}
boolean PortRect_InitClass  (ft F,lt Z,zz *Status)
{
size_t          Offset    = 0;
longaddr        StartAddr = 0;
PortRect        Rect;
if (ClassBug)
TraceMsg (0, "\n\n  PORT RECT  Map...\n");
if (EnvGetMemberId     ("PortHole",           McStat, &PortHole_Attr))
if (EnvGetMemberId     ("PortId",             McStat, &PortId_Attr))
if (EnvGetMemberId     ("MemberAplPorts",     McStat, &MemberAplPorts_Attr))
if (EnvGetMemberId     ("Port_XyOrigin",      McStat, &Port_XyOrigin_Attr))
if (EnvGetMemberId     ("Port_XyExtent",      McStat, &Port_XyExtent_Attr))
if (EnvGetClassId      ("PortRect",           McStat, &PortRect_Class))
if (EnvInitClassMap    (PortRect_Class,       sizeof(PortRect),
C_Apl,                McStat))
{
StartAddr= (longaddr )&Rect;
Offset   = (size_t)((longaddr )&Rect.That    -  StartAddr);
Env_AppendToMap    (That_AttrNum,          Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Token   -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Token_Attr,            Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Id      -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Id_Attr,               Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.MemberDrawObjs  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (MemberDrawObjs_Attr,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.PartObjSlotAttr -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (PartObj_Slot,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.PortHole  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (PortHole_Attr,         Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.PortId  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (PortId_Attr,           Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.MemberAplPorts  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (MemberAplPorts_Attr,   Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Port_XyOrigin  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Port_XyOrigin_Attr,    Offset,     McStat);
Offset   = (size_t)((longaddr )&Rect.Port_XyExtent  -  StartAddr);
if (Normal(*Status))
Env_AppendToMap    (Port_XyExtent_Attr,    Offset,     McStat);
if (Normal(*Status))
Env_InvokeMap      (C_Apl,                             McStat);
}
TRACK(TrackBak,"PortRect_InitClass\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\sa.c*/

#define SA_C
/* 当前文件是./CINT2000\255.vortex\src\sa.h*/

#ifndef SA_H
#define SA_H
#ifdef SA_C
tokentype  LastInIndexedSet = Null_Token;
#else

#endif
boolean SetInitSetHeads
(ft F,lt Z,zz *Status);
boolean SaAddInto  (handletype    SetDesc,
tokentype    *OwnerTkn,  tokentype    *MemberTkn,
ft F,lt Z,zz *Status,    tokentype    *NodeTkn);
boolean SaFindIn   (handletype    SetDesc,   tokentype    *OwnerTkn,
addrtype      KeyValue,  ft F,lt Z,zz *Status,
tokentype    *NodeTkn,   tokentype    *MemberTkn);
boolean SaDeleteSetHead
(handletype    SetDesc,
tokentype    *HeadTkn,   ft F,lt Z,zz *Status);
boolean SaDeleteNode
(handletype    SetDesc,   tokentype    *Member,
tokentype    *NodeTkn,   ft F,lt Z,zz *Status);
boolean    SaAdjustRootNode
(setdesctype   *SetDesc,    indextype      KeyIndex,
tokentype     *SetHeadTkn, lsetheaddesc  *SetHead,
handletype    *RootNodes,  indextype      StackPtr,
tokentype     *NextTkn,    ft F,lt Z,zz  *Status);
boolean SaPutRootNode
(tokentype    *SetHeadTkn,
lsetheaddesc *SetHead,
tokentype    *SetDescTkn,addrtype      KeyValue,
tokentype    *SetNodeTkn,
ft F,lt Z,zz *Status);
boolean SaGetRootNode
(tokentype    *SetHeadTkn,
lsetheaddesc *SetHead,
tokentype    *SetDescTkn,
addrtype      KeyValue,
ft F,lt Z,zz *Status,    tokentype    *RootTkn,
tokentype    *VchunkTkn);
#endif
#ifndef INLINE_OMIDEFS
#else
#define        Alloc_RootSlots        (indextype  )50
#define        lKeyedSetHead_ObjNum   (objnumtype )73
#define        gKeyedSetHead_ObjNum   (objnumtype )74
#define        lSetNode_ObjNum        (objnumtype )85
#define        gSetNode_ObjNum        (objnumtype )86
#define        ObjNum_AttrNum         (numtype )5
#define        Nam_AttrNum            (numtype )19
#define        SetHeadType_AttrNum    (numtype )44
#define        OwnerAttrNum_AttrNum   (numtype )61
#define        MemberAttrNum_AttrNum  (numtype )62
#define        PrimaryKey_AttrNum     (numtype )64
#define        lOwnerObject_AttrNum   (numtype )88
#define        lMemberObject_AttrNum  (numtype )89
#define        gOwnerObject_AttrNum   (numtype )90
#define        lFirstLink_AttrNum     (numtype )91
#define        gFirstLink_AttrNum     (numtype )92
#define        lLastLink_AttrNum      (numtype )93
#define        gLastLink_AttrNum      (numtype )94
#define        lPrevLink_AttrNum      (numtype )95
#define        gPrevLink_AttrNum      (numtype )96
#define        lNextLink_AttrNum      (numtype )97
#define        gNextLink_AttrNum      (numtype )98
#define        RootNodes_AttrNum      (numtype )155
#define        RenvDescs_Hndl         (handletype )688
#endif





#define MemGetWord         Mem_GetWord

#define        MemGetLocalObjNum    Mem_GetWord
boolean SetInitSetHeads  (ft F,lt Z,zz *Status)
{
tokentype      HeadDescTkn;
int            i          = -1;
numtype        ObjNum     = 0;
while (Normal(*Status)
&&     ++i < NumHeadTypes)
{
if (KernelFindIn     (RenvDescs_Hndl, &RenvTkn, (addrtype )HeadNam[i],
McStat,         &HeadDescTkn))
{
if (KernelGetAttr (&HeadDescTkn,    ObjNum_AttrNum,
McStat,         &ObjNum))
HeadObjNum[i] = ObjNum;
} else {
sprintf (Msg, "SetDesc[%u] %s :: not a Desc\n",
i, HeadNam[i]);
TraceMsg (0, Msg);
*Status = Set_NotAnObjDesc;
}
}
sprintf (Msg, " SET HEADS  loaded ... HeadObjNum[2]= %2u\n",
HeadObjNum[2]);
TraceMsg (0, Msg);
TRACK(TrackBak,"SetInitSetHeads\n");
return(STAT);
}
boolean    SaAddInto     (handletype    SetDescHndl,
tokentype    *OwnerTkn, tokentype *MemberTkn,
ft F,lt Z,zz *Status,   tokentype *NodeTkn)
{
tokentype        SetDescTkn;
setdesctype     *SetDesc         = NullPtr;
settype          SetDescType     = aLocalSet;
objtype         *Owner           = NullPtr;
objtype         *Member          = NullPtr;
tokentype        SetMemberTkn;
lsetheaddesc    *SetHead         = NullPtr;
tokentype        SetHeadTkn;
lsetnodedesc    *SetNode         = NullPtr;
gsetnodedesc    *gSetNode        = NullPtr;
lsetnodedesc    *NewSetNode      = NullPtr;
gsetnodedesc    *gNewSetNode     = NullPtr;
tokentype        SetNodeTkn;
tokentype        NewSetNodeTkn;
tokentype        CurrTkn;
tokentype        PrevTkn;
count            Members         = 0;
bytessize        KeySize         = 0;
addrtype         Dummy           = PtrToVoid;
ptr_cmp          CmpCode         = NullPtr;
unsigned char    Value[MAXSTRING];
addrtype         ValuePtr        =  (addrtype )&Value[0];
statustype       DumpStatus      = Env_Normal;
int              TmpDeBug        = DeBug;
indextype        One             = 1;
tokentype        VchunkTkn;
tokentype        VrootToken;
indextype        AllocQty        = 0;
bytetype         Size1Value      = 0;
wordtype         Size2Value      = 0;
numtype          PrimaryKey      = 0;
numtype          MemberAttrNum   = 0;
numtype          NodeObjNum      = 0;
memset (Value, NULL, MAXNAME);
SetHeadTkn.DbId   = OwnerTkn->DbId;
SetNodeTkn.DbId   = OwnerTkn->DbId;
SetMemberTkn.DbId = OwnerTkn->DbId;
CurrTkn.DbId      = OwnerTkn->DbId;
PrevTkn.DbId      = OwnerTkn->DbId;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
if (OaGetObject   (OwnerTkn,            McStat,   (addrtype *)&Owner))
if (OaGetObject   (MemberTkn,           McStat,   (addrtype *)&Member))
if (OaGetObject   (&SetDescTkn,         McStat,   (addrtype *)&SetDesc))
{
PrimaryKey     = SetDesc->PrimaryKey;
SetDescType    = SetDesc->SetType;
MemberAttrNum  = SetDesc->MemberAttrNum;
NodeObjNum     = SetDesc->NodeObjNum;
}
if (Normal(*Status))
OaGet        (False,               OwnerTkn, (addrtype  )Dummy,
SetDesc->OwnerAttrNum,
McStat,              (addrtype )&(SetHeadTkn.Handle));
if (!Normal(*Status))
{
*Status   = Set_NotAnOwnerClass;
sprintf (Msg,"***ERROR*** OwnerAttr[%4u] Not of Owner Object\n",
SetDesc->OwnerAttrNum);
TraceMsg (0, Msg);
sprintf (Msg, " AT AddIntoSet:: %14s SetTkn[%2u:%4u]\n",
SetDesc->Nam, SetDescTkn.DbId, SetDescTkn.Handle);
TraceMsg (0, Msg);
sprintf (Msg,"                 Owner [%2u:%4u]   Member[%2u:%4u]\n",
OwnerTkn->DbId,   OwnerTkn->Handle,
MemberTkn->DbId,  MemberTkn->Handle);
TraceMsg (0, Msg);
TraceMsg (0, "   For SetDesc...\n");
OaDumpObject (0, &SetDescTkn, Dump_Status);
}
if (Normal(*Status))
if (OaGetAttrSize (&RenvTkn,                        PrimaryKey,
McStat,             (addrtype )&KeySize))
if (KeySize > MAXNAME)
*Status = Err_NotImplemented;
if (Normal(*Status))
if (SetHeadTkn.Handle == NullHandle)
{
if (SetDesc->SetType   == aGlobalKeyedSet)
OaCreateObject  (OwnerTkn,        gKeyedSetHead_ObjNum,
McStat,         &SetHeadTkn);
else
OaCreateObject  (OwnerTkn,        lKeyedSetHead_ObjNum,
McStat,         &SetHeadTkn);
if (Normal(*Status))
if (OaGetObject    (&SetHeadTkn,     McStat,     (addrtype *)&SetHead))
{
SetHead->BuildDesc     = SetDescHndl;
SetHead->lOwnerObject  = OwnerTkn->Handle;
SetHead->lFirstLink    = Null_Handle;
SetHead->lLastLink     = Null_Handle;
OaPut (False, OwnerTkn, (addrtype )Owner, SetDesc->OwnerAttrNum,
(addrtype )&(SetHeadTkn.Handle),   McStat);
}
} else {
if (OaGetObject    (&SetHeadTkn,     McStat,     (addrtype *)&SetHead))
OaUpdateObject (&SetHeadTkn,     McStat);
}
if (Normal(*Status))
if (KernelGetAttr (MemberTkn, PrimaryKey, McStat,  ValuePtr))
{
if (SetBug || DeBug)
if (sprintf (Msg, "\n  SetAddInto %14s[%2u:%4u];  Owner[%2u:%4u]\n",
SetDesc->Nam,      SetDescTkn.DbId,  SetDescTkn.Handle,
OwnerTkn->DbId,    OwnerTkn->Handle))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "              Member[%2u:%4u] Key(*%u) = ",
MemberTkn->DbId,    MemberTkn->Handle, KeySize))
if (TraceMsg (0, Msg))
if (PrimaryKey == Nam_AttrNum)
{
sprintf   (Msg, " %s\n", (char *)Value);
TraceMsg  (0, Msg);
} else {
if (TraceBytes (0, Value, KeySize))
TraceMsg (0, "\n");
}
if (SetBug || DeBug)
if (sprintf (Msg, "     Set Head    [%2u:%4u] @ %x\n",
SetHeadTkn.DbId, SetHeadTkn.Handle, SetHead))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "             ->First link [%2u:%4u] \n",
SetHeadTkn.DbId, SetHead->lFirstLink))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "             ->Last  link [%2u:%4u] \n",
SetHeadTkn.DbId,  SetHead->lLastLink))
TraceMsg (0, Msg);
if (SetBug || DeBug)
OaDumpObject (0, &SetHeadTkn, Dump_Status);
} else {
sprintf (Msg,"***ERROR*** Primary Key Attr[%4u] Not of Member Class\n",
PrimaryKey);
TraceMsg (0, Msg);
sprintf (Msg, " AT AddIntoSet:: %14s SetTkn[%2u:%4u]\n",
SetDesc->Nam, SetDescTkn.DbId, SetDescTkn.Handle);
TraceMsg (0, Msg);
sprintf (Msg,"                 Owner [%2u:%4u]   Member[%2u:%4u]\n",
OwnerTkn->DbId,   OwnerTkn->Handle,
MemberTkn->DbId,  MemberTkn->Handle);
TraceMsg (0, Msg);
*Status = Set_SetNotOfObjCestrs;
}
if (Normal(*Status))
if (SetDescType    == aIndexedSet
||  SetDescType    == aLocalKeyedSet
||  SetDescType    == aGlobalKeyedSet)
{
if (SetHead->lFirstLink == NullHandle)
{
if (PrimaryKey   == Nam_AttrNum)
AllocQty                = 53;
else if (SetDescType == aIndexedSet)
{
SetHead->lFirstLink     = One;
SetHead->lLastLink      = NullHandle;
AllocQty                = Alloc_DbObjs;
} else if (PrimaryKey != ObjNum_AttrNum)
AllocQty                = Alloc_RootSlots;
else
AllocQty                = 0;
if (AllocQty)
if (SetHead->RootNodes ==  0)
if (OaCreateVchunk  (&SetHeadTkn,     sizeof (handletype),
AllocQty,        Extend_Fields,
McStat,         &VrootToken))
KernelPutAttr   (&SetHeadTkn,     RootNodes_AttrNum,
(addrtype )&(VrootToken.Handle),
McStat);
}
if (Normal(*Status))
if (SetDescType == aIndexedSet)
{
if (KeySize <= sizeof (idtype))
{
memcpy ((char *)&Size2Value, (char *)ValuePtr, KeySize);
Size1Value  = (bytetype )Size2Value;
Size2Value  = Size1Value;
memcpy ((char *)ValuePtr,   (char *)&Size2Value,
sizeof (wordtype));
if (SetBug || DeBug)
if (sprintf (Msg,
"     KeyValue Resize From(*%2u)= %u -> (*%2u)= %u =>=> (%2u)%u\n",
KeySize,  Size1Value, sizeof(wordtype), Size2Value,
sizeof (wordtype), *(wordtype *)ValuePtr))
TraceMsg (0, Msg);
}
if (SaPutRootNode (&SetHeadTkn,    SetHead,  &SetDescTkn, ValuePtr,
MemberTkn,     McStat))
*Status   = Env_Normal;
if (Normal(*Status))
OaPut          (False,          MemberTkn, (addrtype  )Member,
MemberAttrNum,
(addrtype )&SetHeadTkn,                McStat);
if (DeBug)
OaDumpObject (0, &SetHeadTkn, Dump_Status);
DumpStatus = Env_Normal;
DeBug = TmpDeBug;
TRACK(TrackBak,"SetAddInTo\n");
return (STAT);
}
}
if (Normal(*Status))
if (OaCreateObject (OwnerTkn,       NodeObjNum,  McStat,     &NewSetNodeTkn))
if (OaGetObject    (&NewSetNodeTkn, McStat,      (addrtype *)&NewSetNode))
if (OaPut          (False,          MemberTkn,   (addrtype   )Member,
MemberAttrNum,
(addrtype )&NewSetNodeTkn,                McStat))
{
NewSetNode->lOwnerObject   = SetHeadTkn.Handle;
NewSetNode->lPrevLink      = Null_Handle;
NewSetNode->lNextLink      = Null_Handle;
CurrTkn.Handle             = Null_Handle;
PrevTkn.Handle             = Null_Handle;
if (SetDesc->SetType         == aGlobalKeyedSet)
{
gNewSetNode                = (gsetnodedesc *)NewSetNode;
gNewSetNode->gMemberObject = *MemberTkn;
} else
NewSetNode->lMemberObject  = MemberTkn->Handle;
if (SetBug || DeBug)
OaDumpObject (0, &NewSetNodeTkn, Dump_Status);
}
if (Normal(*Status))
if (SetHead->lFirstLink == NullHandle)
{
SetHead->lFirstLink        = NewSetNodeTkn.Handle;
SetHead->lLastLink         = NewSetNodeTkn.Handle;
SetNodeTkn.Handle          = Null_Handle;
*Status                    = Set_InSerted;
if (DeBug >= 2)
OaDumpObject (0, &SetHeadTkn, Dump_Status);
DumpStatus = Env_Normal;
} else {
if (SetHead->lLastLink)
{
SetNodeTkn.Handle  =  SetHead->lLastLink;
if (OaGetObject (&SetNodeTkn,   McStat,   (addrtype *)&SetNode))
{
if (SetDesc->SetType    == aGlobalKeyedSet)
{
gSetNode              = (gsetnodedesc *)SetNode;
SetMemberTkn          = gSetNode->gMemberObject;
} else
SetMemberTkn.Handle   = SetNode->lMemberObject;
OaCompare (False,    &SetMemberTkn, Dummy,  PrimaryKey,
ValuePtr,  CmpCode,      McStat);
if (*Status == Oa_GtrThen)
{
*Status = Env_Normal;
PrevTkn.Handle = SetNode->Handle;
CurrTkn.Handle = NullHandle;
*Status = Set_GtrThen;
} else if (*Status == Oa_LessThen)
*Status = Env_Normal;
}
}
if (Normal(*Status))
if (SaGetRootNode (&SetHeadTkn,  SetHead,  &SetDescTkn,   ValuePtr,
McStat,     &CurrTkn,  &VchunkTkn))
*Status = Set_GtrThen;
while ((*Status        == Set_GtrThen)
&&     (CurrTkn.Handle != NullHandle ))
{
SetNodeTkn.Handle  =  CurrTkn.Handle;
*Status = Env_Normal;
if (OaGetObject (&SetNodeTkn,   McStat,   (addrtype *)&SetNode))
{
if (SetDesc->SetType      == aGlobalKeyedSet)
{
gSetNode              = (gsetnodedesc *)SetNode;
SetMemberTkn          = gSetNode->gMemberObject;
} else
SetMemberTkn.Handle   = SetNode->lMemberObject;
if (DeBug >= 2)
if (sprintf (Msg,
"     SETNODE [%2u:%4u] @ %x  lPrevLink [%2u:%4u]\n",
SetNodeTkn.DbId, SetNodeTkn.Handle,
SetNode, SetNodeTkn.DbId, SetNode->lPrevLink))
if (TraceMsg (0, Msg))
if (sprintf (Msg,
"                                 lNextLink [%2u:%4u]\n",
SetNodeTkn.DbId, SetNode->lNextLink))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "      SETMEMBER [%2u:%4u] \n",
SetMemberTkn.DbId, SetMemberTkn.Handle))
TraceMsg (0, Msg);
Members++;
OaCompare (False,    &SetMemberTkn, Dummy,  PrimaryKey,
ValuePtr,  CmpCode,      McStat);
}
if (Normal(*Status))
{
*Status = Set_AlreadyInSet;
if (SetBug || DeBug)
if (sprintf  (Msg,
"     Member[%2u:%4u]  Already In Set\n",
MemberTkn->DbId,  MemberTkn->Handle))
if (TraceMsg (0, Msg))
if (PrimaryKey == Nam_AttrNum)
{
sprintf   (Msg, " %s\n", (char *)Value);
TraceMsg  (0, Msg);
} else {
if (TraceBytes (0, Value, KeySize))
TraceMsg (0, "\n");
}
} else if (*Status == Oa_LessThen) {
*Status = Env_Normal;
PrevTkn.Handle  = SetNode->lPrevLink;
if (SetBug ||  DeBug)
if (sprintf  (Msg, "     Current Member[%2u:%4u]  > New[%2u:%4u]\n",
SetMemberTkn.DbId,    SetMemberTkn.Handle,
MemberTkn->DbId,      MemberTkn->Handle))
if (TraceMsg (0, Msg))
if (sprintf  (Msg, "     PrevTkn [%2u,%4u], SetNodeTkn[%2u:%4u]\n",
PrevTkn.DbId,    PrevTkn.Handle,
SetNodeTkn.DbId, SetNodeTkn.Handle))
TraceMsg  (0, Msg);
if (KernelPutAttr (&SetNodeTkn,    lPrevLink_AttrNum,
(addrtype )&(NewSetNodeTkn.Handle),   McStat))
if (KernelPutAttr (&NewSetNodeTkn, lPrevLink_AttrNum,
(addrtype )&(PrevTkn.Handle),   McStat))
if (KernelPutAttr (&NewSetNodeTkn, lNextLink_AttrNum,
(addrtype )&(SetNodeTkn.Handle),   McStat))
if (PrevTkn.Handle)
KernelPutAttr (&PrevTkn,       lNextLink_AttrNum,
(addrtype )&(NewSetNodeTkn.Handle),   McStat);
else
KernelPutAttr (&SetHeadTkn,    lFirstLink_AttrNum,
(addrtype )&(NewSetNodeTkn.Handle),   McStat);
DumpStatus = Env_Normal;
if (DeBug)
OaDumpObject (0, &NewSetNodeTkn, Dump_Status);
if (DeBug)
TraceMsg (0, "   Inserted Into Set \n");
DeBug     = TmpDeBug;
if (Normal(*Status))
*Status   = Set_InSerted;
else {
OaDumpObject  (0, &SetHeadTkn, Dump_Status);
VrootToken.DbId        = SetHeadTkn.DbId;
VrootToken.Handle      = SetHead->RootNodes;
OaDumpVchunk  (&VrootToken,    Dump_Status);
}
} else if (*Status == Oa_GtrThen) {
PrevTkn.Handle             = SetNode->Handle;
CurrTkn.Handle             = SetNode->lNextLink;
*Status                     = Set_GtrThen;
}
}
}
if (*Status == Set_InSerted)
{
*Status   = Env_Normal;
} else if ((*Status        == Set_GtrThen)
&&   (CurrTkn.Handle == Null_Handle))
{
*Status  = Env_Normal;
if (SetBug || DeBug)
if (sprintf  (Msg, "     AppendToSet... Member[%2u:%4u]\n",
MemberTkn->DbId,      MemberTkn->Handle))
TraceMsg (0, Msg);
if (DeBug)
if (sprintf  (Msg, "       PrevTkn [%2u:%4u], SetNodeTkn[%2u:%4u]\n",
PrevTkn.DbId,    PrevTkn.Handle,
SetNodeTkn.DbId, SetNodeTkn.Handle))
TraceMsg (0, Msg);
if (KernelPutAttr (&SetHeadTkn,                    lLastLink_AttrNum,
(addrtype )&NewSetNodeTkn.Handle, McStat))
if (KernelPutAttr (&NewSetNodeTkn,                 lPrevLink_AttrNum,
(addrtype )&PrevTkn.Handle,       McStat))
if (PrevTkn.Handle)
KernelPutAttr (&PrevTkn,                       lNextLink_AttrNum,
(addrtype )&NewSetNodeTkn.Handle, McStat);
if (DeBug)
OaDumpObject  (0, &NewSetNodeTkn, Dump_Status);
}
if (Normal(*Status))
if (SaPutRootNode (&SetHeadTkn,    SetHead,  &SetDescTkn,   ValuePtr,
&NewSetNodeTkn, McStat))
*NodeTkn      =   NewSetNodeTkn;
if (*Status != Set_AlreadyInSet)
{
if (SetBug || DeBug || !Normal(*Status))
{
if (sprintf (Msg,
"   AddedIntoSet %14s [%2u:%4u];  Owner [%2u:%4u]\n",
SetDesc->Nam,    SetDescTkn.DbId, SetDescTkn.Handle,
OwnerTkn->DbId,  OwnerTkn->Handle))
if (TraceMsg (0, Msg))
if (sprintf (Msg,
"                              Member[%2u:%4u]\n",
MemberTkn->DbId,  MemberTkn->Handle))
if (TraceMsg (0, Msg))
if (sprintf (Msg,
"      SetNode [%2u:%4u]       lPrevLink [%2u:%4u]\n",
NewSetNodeTkn.DbId, NewSetNodeTkn.Handle,
PrevTkn.DbId, PrevTkn.Handle))
if (TraceMsg (0, Msg))
if (sprintf (Msg,
"                              lNextLink [%2u:%4u]\n",
SetNodeTkn.DbId,    SetNodeTkn.Handle))
TraceMsg (0, Msg);
DumpStatus = Env_Normal;
if (Normal(*Status) && DeBug)
OaDumpObject (0, &NewSetNodeTkn, Dump_Status);
}
DeBug = TmpDeBug;
}
TRACK(TrackBak,"SetAddInTo\n");
return (STAT);
}
boolean    SaFindIn      (handletype    SetDescHndl, tokentype    *OwnerTkn,
addrtype      KeyValue,    ft F,lt Z,zz *Status,
tokentype    *NodeTkn,     tokentype    *MemberTkn)
{
tokentype        SetDescTkn;
setdesctype     *SetDesc     = NullPtr;
settype          SetDescType = aLocalSet;
lsetheaddesc    *SetHead     = NullPtr;
tokentype        SetHeadTkn;
lsetnodedesc    *SetNode     = NullPtr;
gsetnodedesc    *gSetNode    = NullPtr;
tokentype        SetNodeTkn;
tokentype        VchunkTkn;
tokentype        CurrTkn;
tokentype        PrevTkn;
count            Members     = 0;
bytessize        KeySize     = 0;
addrtype         Dummy       = NullPtr;
ptr_cmp          CmpCode     = NullPtr;
statustype       DumpStatus  = Env_Normal;
numtype          PrimaryKey  = 0;
SetHeadTkn.DbId   = OwnerTkn->DbId;
SetNodeTkn.DbId   = OwnerTkn->DbId;
SetNodeTkn.Handle = OwnerTkn->DbId;
CurrTkn.DbId      = OwnerTkn->DbId;
PrevTkn.DbId      = OwnerTkn->DbId;
MemberTkn->DbId   = OwnerTkn->DbId;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
if (SetBug || DeBug >= 1)
if (sprintf (Msg, "\n   FindInSet:: SetTkn[%2u:%4u]... OwnerTkn[%3u:%4u]\n",
SetDescTkn.DbId, SetDescTkn.Handle,
OwnerTkn->DbId,   OwnerTkn->Handle))
TraceMsg (0, Msg);
if (OaGetObject   (&SetDescTkn,
McStat,                   (addrtype *)&SetDesc))
if (OaGet         (False,                     OwnerTkn,
(addrtype )Dummy,          SetDesc->OwnerAttrNum,
McStat,        (addrtype )&SetHeadTkn.Handle))
PrimaryKey   = SetDesc->PrimaryKey;
if (*Status  == Oa_AttrNotPresent)
*Status   = Set_NotAnOwnerClass;
if (Normal(*Status))
if (DeBug || SetBug)
if (sprintf  (Msg, "    SetDesc @%8x ->PrimaryKey @%8x; KeyAttrNum=%3u\n",
SetDesc,  &SetDesc->PrimaryKey, PrimaryKey))
TraceMsg (0,   Msg);
if (DeBug)
OaDumpObject  (0,  &SetDescTkn,   McStat);
if (Normal(*Status))
if (OaGetAttrSize (&RenvTkn,                  PrimaryKey,
McStat,       (addrtype )&KeySize))
if (SetHeadTkn.Handle == NullHandle)
{
if (DeBug || SetBug)
TraceMsg (0, "    ... Empty Set.\n");
*Status = Set_EmptySet;
SetNodeTkn.Handle = NullHandle;
}
if (Normal(*Status))
if (OaGetObject (&SetHeadTkn,   McStat,   (addrtype *)&SetHead))
{
if (SetBug || DeBug)
if (sprintf (Msg,
"\n  FindInSet  %14s[%2u:%4u];  Owner[%2u:%4u] Key(* %2u)=",
SetDesc->Nam,    SetDescTkn.DbId,  SetDescTkn.Handle,
OwnerTkn->DbId,  OwnerTkn->Handle, KeySize))
if (TraceMsg (0, Msg))
if (PrimaryKey == Nam_AttrNum)
{
sprintf   (Msg, " %s\n", (char *)KeyValue);
TraceMsg  (0, Msg);
} else {
if (KeySize == sizeof (numtype))
{
sprintf  (Msg, "%6u\n", *(numtype *)KeyValue);
TraceMsg (0, Msg);
} else {
TraceBytes (0, KeyValue, KeySize);
TraceMsg (0, "\n");
}
}
if (DeBug || SetBug)
if (OaDumpObject   (0,  &SetHeadTkn, McStat))
if (sprintf (Msg, "     KeyAttr (%3u) size %u \n",
PrimaryKey, KeySize))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "     SetHead    [0:%4u] @ %x\n",
SetHeadTkn.Handle, SetHead))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "             ->First link [0:%4u] \n",
SetHead->lFirstLink))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "             ->Last  link [0:%4u] \n",
SetHead->lLastLink))
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (SetHead->lFirstLink == NullHandle)
*Status = Set_EmptySet;
else {
PrevTkn.Handle = NullHandle;
if (SaGetRootNode (&SetHeadTkn,   SetHead,   &SetDescTkn,   KeyValue,
McStat,      &CurrTkn,   &VchunkTkn))
if (*Status == Set_IsAnIndexedSet)
{
if (CurrTkn.Handle)
{
MemberTkn->Handle = CurrTkn.Handle;
*Status = Set_Found;
} else
*Status = Set_NotFound;
} else
*Status = Set_GtrThen;
while ((Normal(*Status) || *Status == Set_GtrThen)
&&      CurrTkn.Handle  !=  NullHandle)
{
SetNodeTkn.Handle      =  CurrTkn.Handle;
*Status                 = Env_Normal;
if (OaGetObject (&SetNodeTkn,   McStat,   (addrtype *)&SetNode))
{
if (SetDescType    == aGlobalKeyedSet)
{
gSetNode          = (gsetnodedesc *)SetNode;
*MemberTkn         = gSetNode->gMemberObject;
} else
MemberTkn->Handle = SetNode->lMemberObject;
if (TmIsValid   (MemberTkn,   McStat))
{
if (DeBug || SetBug)
if (sprintf (Msg,
"      SetNode [%4u:%8u] lNextLink [%4u:%8u]\n",
SetNodeTkn.DbId,  SetNodeTkn.Handle,
SetNodeTkn.DbId,  SetNode->lNextLink))
if (TraceMsg (0, Msg))
if (sprintf (Msg,
"      Member  [%4u:%8u] lPrevLink [%4u:%8u]\n",
SetNodeTkn.DbId,  SetNode->lPrevLink))
TraceMsg (0, Msg);
Members++;
PrevTkn.Handle = CurrTkn.Handle;
OaCompare (False,    MemberTkn, Dummy,   PrimaryKey,
KeyValue, CmpCode,   McStat);
} else {
TraceMsg (0, "\n ***WARNING... Invalid MemberTkn in Set\n");
sprintf (Msg, "      SetNode [%4u:%8u] lNextLink [%4u:%8u]\n",
SetNodeTkn.DbId,  SetNodeTkn.Handle,
SetNodeTkn.DbId,  SetNode->lNextLink);
TraceMsg (0, Msg);
sprintf (Msg, "      Member  [%4u:%8u] \n",
MemberTkn->DbId, MemberTkn->Handle);
TraceMsg (0, Msg);
CurrTkn.Handle = SetNode->lNextLink;
TraceMsg (0, "\n Set Head::\n");
OaDumpObject      (0, &SetHeadTkn, McStat);
TraceMsg (0, "\n Set Node::\n");
OaDumpObject      (0, &CurrTkn, McStat);
*Status  = Env_Normal;
if (SaDeleteNode  (SetDescHndl,  &NullToken,
				 &SetNodeTkn, McStat))
*Status         = Set_GtrThen;
}
}
if (Normal(*Status))
{
*Status      = Set_Found;
*NodeTkn     = SetNodeTkn;
if (SetBug || DeBug)
if (sprintf  (Msg, "     MATCHED in Member[%2u:%4u]::(%3u) \n",
MemberTkn->DbId,      MemberTkn->Handle,
PrimaryKey))
TraceMsg (0, Msg);
} else if (*Status == Oa_GtrThen || *Status == Oa_LessThen) {
if (DeBug || SetBug)
if (sprintf  (Msg, "     NO Match in Member[%2u:%4u]\n",
MemberTkn->DbId,      MemberTkn->Handle))
TraceMsg (0, Msg);
if (*Status == Oa_LessThen)
*Status = Set_LessThen;
else
*Status = Set_GtrThen;
if (CurrTkn.Handle == SetNode->lNextLink)
*Status = Set_BadSet;
else if (*Status == Set_GtrThen)
CurrTkn.Handle = SetNode->lNextLink;
}
}
}
if (*Status == Set_Found)
*Status = Env_Normal;
else
MemberTkn->Handle = NullHandle;
if (*Status == Set_GtrThen) {
if (DeBug  || SetBug)
if (sprintf (Msg,
"     NoMatchInSet ... End Of List. LastMember[%2u:%4u]\n",
PrevTkn.DbId, PrevTkn.Handle))
TraceMsg (0, Msg);
*Status = Set_NotFound;
} else if (*Status == Set_LessThen) {
if (DeBug || SetBug)
if (sprintf (Msg,
"     NoMatchInSet ... Less Than CurrentMember[%2u:%4u]\n",
CurrTkn.DbId, CurrTkn.Handle))
TraceMsg (0, Msg);
*Status = Set_NotFound;
}
if (!Normal(*Status)
&&  *Status != Set_NotFound) {
if ( *Status != Set_EmptySet ) {
sprintf (Msg,
"  @@FINDIN %14s [0:%4u] BY Key= %3u WITH  Owner[0:%4u]\n",
SetDesc->Nam,    SetDescTkn.Handle,
*(word *)KeyValue, OwnerTkn->Handle);
TraceMsg (0, Msg);
sprintf  (Msg, "     BAD FINDIN for Member[%2u:%4u]\n",
MemberTkn->DbId,      MemberTkn->Handle);
TraceMsg (0, Msg);
if (SetNode)
{
sprintf (Msg, "      SETNODE [0:%4u] @ %x  lNextLink [0:%4u]\n",
SetNodeTkn.Handle, SetNode, SetNode->lNextLink);
TraceMsg (0, Msg);
}
sprintf (Msg, "      SETMEMBER [0:%4u] \n",  MemberTkn->Handle);
TraceMsg (0, Msg);
sprintf (Msg, "      for SETHEAD    [0:%4u] @ %x\n",
SetHeadTkn.Handle, SetHead);
TraceMsg (0, Msg);
if (SetHead)
{
sprintf (Msg, "                 ->FIRST link [0:%4u] \n",
SetHead->lFirstLink);
TraceMsg (0, Msg);
}
} else
*Status = Set_NotFound;
} else if (DeBug
&&  SetNodeTkn.Handle
&&  (*Status != Set_EmptySet)) {
TraceMsg (0, "  DUMP  SetNodeTkn @ Exit from FindIN \n");
OaDumpObject (0, &SetNodeTkn, Dump_Status);
} else if (*Status == Set_NotFound && (SetBug || DeBug)) {
sprintf (Msg,
"  in SET %14s [%2u:%4u] Owner[0:%4u]\n",
SetDesc->Nam,    SetDescTkn.DbId, SetDescTkn.Handle,
OwnerTkn->Handle);
TraceMsg (0, Msg);
sprintf  (Msg, "     NOTFOUND for SetType[%2u] Member[%2u:%4u] Key=%u\n",
SetDescType, MemberTkn->DbId,  MemberTkn->Handle,
*(word *)KeyValue);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"SetFindIn\n");
return (STAT);
}
boolean    SaPutRootNode (tokentype     *SetHeadTkn, lsetheaddesc *SetHead,
tokentype     *SetDescTkn, addrtype      KeyValue,
tokentype     *SetNodeTkn, ft F,lt Z,zz *Status)
{
tokentype        RootTkn;
tokentype        MemberTkn;
tokentype        VrootToken;
indextype        RootStackPtr    = 0;
handletype      *RootNodes       = NullPtr;
lsetnodedesc    *SetNode         = NullPtr;
gsetnodedesc    *gSetNode        = NullPtr;
indextype        KeyIndex        = 0;
char            *KeyPtr          = (char *)KeyValue;
addrtype         Dummy           = PtrToVoid;
ptr_cmp          CmpCode         = NullPtr;
unsigned char    Value[MAXSTRING];
setdesctype     *SetDesc         = NullPtr;
settype          SetDescType     = aLocalSet;
numtype          PrimaryKey      = 0;
numtype          AllocSize       = 0;
statustype       DumpStatus      = Env_Normal;
int              k               = 0;
memset (Value, NULL, MAXNAME);
if (SetHead->RootNodes)
{
RootTkn.DbId           = SetHeadTkn->DbId;
MemberTkn.DbId         = SetHeadTkn->DbId;
VrootToken.DbId        = SetHeadTkn->DbId;
VrootToken.Handle      = SetHead->RootNodes;
if (OaGetObject     (SetDescTkn,     McStat, (addrtype *)&SetDesc))
{
PrimaryKey  = SetDesc->PrimaryKey;
SetDescType = SetDesc->SetType;
}
if (Normal(*Status))
if (OaGetVchunkAddr     (&VrootToken,               McStat,
(addrtype *)&RootNodes))
if (OaGetVchunkStackPtr (&VrootToken,               McStat,
&RootStackPtr))
if (SetBug)
if (sprintf (Msg, "   Put RootNode[<=%3u] ... \n", RootStackPtr))
TraceMsg (0, Msg);
if (Normal(*Status))
if (PrimaryKey        == Nam_AttrNum)
{
if (!RootStackPtr)
if (OaPutVchunkStackPtr (&VrootToken,          53,  McStat))
OaGetVchunkAddr     (&VrootToken,               McStat,
(addrtype *)&RootNodes);
KeyIndex         = (indextype )KeyPtr[0] - (indextype )64;
if (KeyIndex
&&  KeyIndex    <= 58) {
if (KeyIndex  > 26)
KeyIndex -= 6;
if (!RootNodes[KeyIndex])
RootNodes[KeyIndex]  = SetNodeTkn->Handle;
else {
RootTkn.Handle   = RootNodes[KeyIndex];
if (OaGetObject (&RootTkn,   McStat, (addrtype *)&SetNode))
if (SetDescType       == aGlobalKeyedSet)
{
gSetNode           = (gsetnodedesc *)SetNode;
MemberTkn          = gSetNode->gMemberObject;
} else
MemberTkn.Handle   = SetNode->lMemberObject;
if (Normal(*Status))
OaCompare     (False,     &MemberTkn,           Dummy,
PrimaryKey,
KeyValue,   CmpCode,             McStat);
if (*Status == Oa_GtrThen)
{
*Status = Env_Normal;
RootNodes[KeyIndex]  = SetNodeTkn->Handle;
} else if (*Status == Oa_LessThen)
*Status = Env_Normal;
}
}
} else if (SetDescType == aIndexedSet) {
KeyIndex               = *(wordtype *)KeyValue;
if (KeyIndex          >= RootStackPtr)
if (OaPutVchunkStackPtr (&VrootToken,  KeyIndex+1,  McStat))
OaGetVchunkAddr     (&VrootToken,               McStat,
(addrtype *)&RootNodes);
if (Normal(*Status)) {
RootNodes[KeyIndex]    = SetNodeTkn->Handle;
*Status                 = Set_IsAnIndexedSet;
}
} else if (SetDescType == aLocalKeyedSet
||  SetDescType == aGlobalKeyedSet) {
if (SetHeadTkn->DbId <= WenvId)
AllocSize = 10;
else
AllocSize = 100;
KeyIndex = *(wordtype *)KeyValue / AllocSize;
if (KeyIndex >= RootStackPtr)
{
if (DeBug)
if (sprintf (Msg, " Index[%2u]  > Set_QuickAccessStack[%2u] \n",
KeyIndex, RootStackPtr))
TraceMsg (0, Msg);
if (!RootStackPtr
&&  Alloc_RootSlots > KeyIndex)
RootStackPtr = Alloc_RootSlots;
else
RootStackPtr = KeyIndex + 1;
if (OaPutVchunkStackPtr (&VrootToken,  RootStackPtr,  McStat))
OaGetVchunkAddr     (&VrootToken,                 McStat,
(addrtype *)&RootNodes);
}
if (Normal(*Status))
if (RootNodes[KeyIndex]  == NullHandle)
{
RootNodes[KeyIndex]    = SetNodeTkn->Handle;
} else {
RootTkn.Handle         = RootNodes[KeyIndex];
if (OaGetObject (&RootTkn,   McStat, (addrtype *)&SetNode))
if (SetDescType       == aGlobalKeyedSet)
{
gSetNode           = (gsetnodedesc *)SetNode;
MemberTkn          = gSetNode->gMemberObject;
} else
MemberTkn.Handle   = SetNode->lMemberObject;
if (!TmIsValid     (&MemberTkn,   McStat))
*Status  = Oa_GtrThen;
if (Normal(*Status))
OaCompare     (False,     &MemberTkn,           Dummy,
PrimaryKey,
KeyValue,   CmpCode,  McStat);
if (*Status           == Oa_LessThen)
{
*Status               = Env_Normal;
RootNodes[KeyIndex]  = SetNodeTkn->Handle;
} else if (*Status    == Oa_GtrThen)
*Status = Env_Normal;
if (*Status == Oa_ObjNoThisAttr)
{
TraceMsg (0,   "\n  Error :: Attribute Not Of Object ::\n");
sprintf (Msg,  "  @PutRootNode:: StackPtr  =%4u \n",
RootStackPtr);
TraceMsg (0, Msg);
sprintf (Msg,  "  MemberTkn [  1:%6u]; PrimaryKey =%4u.\n",
MemberTkn.Handle, PrimaryKey);
TraceMsg (0, Msg);
sprintf (Msg,  "  RootTkn   [  1:%6u]; KeyIndex   =%4u.\n",
RootTkn.Handle,  KeyIndex);
TraceMsg (0, Msg);
TraceMsg (0, "\n  Set Desc Object ::\n");
OaDumpObject (0, SetDescTkn,  Dump_Status);
TraceMsg (0, "\n  RootNodes Array ::\n");
for (k = 0; k <= KeyIndex; k++)
{
sprintf (Msg,  "           [%3u] =%4u.\n",
k, RootNodes[k]);
TraceMsg (0, Msg);
}
}
}
} else
*Status = Set_BadQuickPickSet;
if (SetBug || DeBug)
if (sprintf (Msg, "  From SetHead->lFirstLink [%2u:%4u] \n",
SetHeadTkn->DbId, SetHead->lFirstLink))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "  Of   SetType  = %2u  Key=%3u   Status = %6d \n",
SetDescType, *(wordtype *)KeyValue, *Status))
if (TraceMsg (0, Msg))
if (sprintf (Msg,  "  PUT RootNode[%4u] = %4u \n",
KeyIndex, SetNodeTkn->Handle))
TraceMsg (0, Msg);
}
TRACK(TrackBak,"SaPutRootNode\n");
return (STAT);
}
boolean    SaGetRootNode  (tokentype     *SetHeadTkn,  lsetheaddesc *SetHead,
tokentype     *SetDescTkn,  addrtype     KeyValue,
ft F,lt Z,zz  *Status,      tokentype    *RootTkn,
tokentype     *VchunkTkn)
{
tokentype        VrootToken;
indextype        RootStackPtr    = 0;
handletype      *RootNodes       = NullPtr;
indextype        KeyIndex        = 0;
char            *KeyPtr          = (char *)KeyValue;
statustype       DumpStatus      = Env_Normal;
tokentype        SetNodeTkn;
lsetnodedesc    *SetNode         = NullPtr;
gsetnodedesc    *gSetNode        = NullPtr;
addrtype         Dummy           = PtrToVoid;
tokentype        SetMemberTkn;
ptr_cmp          CmpCode         = NullPtr;
unsigned char    Value[MAXSTRING];
setdesctype     *SetDesc         = NullPtr;
settype          SetDescType     = aLocalSet;
numtype          PrimaryKey      = 0;
numtype          AllocSize       = 0;
memset (Value, NULL, sizeof (Value));
RootTkn->Handle   = SetHead->lFirstLink;
VrootToken.DbId   = SetHeadTkn->DbId;
SetNodeTkn.DbId   = SetHeadTkn->DbId;
SetMemberTkn.DbId = SetHeadTkn->DbId;
if (OaGetObject    (SetDescTkn,  McStat,  (addrtype *)&SetDesc))
{
PrimaryKey  = SetDesc->PrimaryKey;
SetDescType = SetDesc->SetType;
}
if (Normal(*Status))
if (SetHead->RootNodes)
{
VrootToken.Handle      = SetHead->RootNodes;
VchunkTkn->DbId        = VrootToken.DbId;
VchunkTkn->Handle      = VrootToken.Handle;
if (OaGetVchunkAddr     (&VrootToken,               McStat,
(addrtype *)&RootNodes))
if (OaGetVchunkStackPtr (&VrootToken,               McStat,
&RootStackPtr))
if (RootStackPtr)
if (PrimaryKey == Nam_AttrNum)
{
KeyIndex = (indextype )KeyPtr[0] - (indextype )64;
if (KeyIndex
&&  KeyIndex    <= 58)
{
if (KeyIndex > 26)
KeyIndex -= 6;
if (KeyIndex)
{
while (KeyIndex && ! RootNodes[KeyIndex-1])
{
--KeyIndex;
}
if (KeyIndex)
--KeyIndex;
}
if (RootNodes[KeyIndex])
RootTkn->Handle = RootNodes[KeyIndex];
}
} else if (SetDescType == aIndexedSet) {
KeyIndex = *(wordtype *)KeyValue;
if (KeyIndex >= RootStackPtr)
*Status            = Set_IndexGtrAllocRoots;
else
RootTkn->Handle   = RootNodes[KeyIndex];
if (DeBug)
OaDumpVchunk (&VrootToken, Dump_Status);
*Status               = Set_IsAnIndexedSet;
} else if (SetDescType == aLocalKeyedSet
||  SetDescType == aGlobalKeyedSet) {
if (SetHeadTkn->DbId <= WenvId)
AllocSize = 10;
else
AllocSize = 100;
KeyIndex      = *(wordtype *)KeyValue;
if (KeyIndex >= AllocSize)
{
KeyIndex     = *(wordtype *)KeyValue / AllocSize;
if (KeyIndex > RootStackPtr)
KeyIndex = RootStackPtr;
while (KeyIndex && ! RootNodes[KeyIndex-1])
--KeyIndex;
if (KeyIndex)
--KeyIndex;
} else
KeyIndex   = 0;
if (KeyIndex >= RootStackPtr)
KeyIndex  = RootStackPtr - 1;
if (RootNodes[KeyIndex])
RootTkn->Handle  = RootNodes[KeyIndex];
} else
*Status = Set_BadQuickPickSet;
LastInIndexedSet.DbId   = RootTkn->DbId;
LastInIndexedSet.Handle = RootTkn->Handle;
if (SetBug || DeBug)
if (sprintf (Msg, "   From SetHead->lFirstLink [%2u:%4u] \n",
SetHeadTkn->DbId, SetHead->lFirstLink))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "   Of   SetType  = %2u     Status = %6d \n",
SetDescType, *Status))
if (TraceMsg (0, Msg))
if (TraceMsg (0,  "   For  Key      ="))
if (PrimaryKey != Nam_AttrNum)
sprintf (Msg, "%2u\n", *(wordtype *)KeyValue);
else
sprintf (Msg, " %s  startkey=%u from char %c\n",
(char *)KeyValue, KeyPtr[0], (char )KeyPtr[0]);
if (SetBug || DeBug)
if (TraceMsg (0, Msg))
if (sprintf (Msg, "   ...  GET RootTkn[%4u] SetNode->Handle = %4u\n",
KeyIndex,  RootTkn->Handle))
TraceMsg (0, Msg);
} else {
SetNodeTkn.Handle  =  SetHead->lLastLink;
if (OaGetObject (&SetNodeTkn,   McStat,   (addrtype *)&SetNode))
{
if (SetDescType         == aGlobalKeyedSet)
{
gSetNode              = (gsetnodedesc *)SetNode;
SetMemberTkn          = gSetNode->gMemberObject;
} else
SetMemberTkn.Handle   = SetNode->lMemberObject;
OaCompare (False,    &SetMemberTkn, Dummy,  PrimaryKey,
KeyValue,  CmpCode,      McStat);
if (Normal(*Status)
|| *Status         == Oa_GtrThen)
{
RootTkn->Handle  =  SetHead->lLastLink;
*Status           = Env_Normal;
} else
*Status           = Env_Normal;
}
}
TRACK(TrackBak,"SaGetRootNode\n");
return (STAT);
}
boolean SaDeleteNode     (handletype    SetDescHndl, tokentype    *Member,
tokentype    *NodeTkn,     ft F,lt Z,zz *Status)
{
unsigned char    Value[MAXNAME];
tokentype       SetDescTkn      = NullToken;
setdesctype    *SetDesc         = NullPtr;
tokentype       HeadTkn         = NullToken;
lsetheaddesctype *SetHead       = NullPtr;
dbheader       *CoreDb          = NullPtr;
numtype         LocalObj        = 0;
objheader      *ObjHdr          = NullPtr;
tokentype       NextTkn         = NullToken;
tokentype       NextMemberTkn   = NullToken;
tokentype       PrevTkn         = NullToken;
addrtype        NodeObj         = NullPtr;
tokentype       VrootTkn        = NullToken;
numtype         NodeObjNum      = 0;
handletype     *RootNodes       = NullPtr;
indextype       StackPtr        = 0;
indextype       Index           = 0;
handletype      QuickPickHndl   = NullHandle;
SetDescTkn.DbId    = RenvId;
SetDescTkn.Handle  = SetDescHndl;
HeadTkn.DbId   = NodeTkn->DbId;
PrevTkn.DbId   = NodeTkn->DbId;
NextTkn.DbId   = NodeTkn->DbId;
VrootTkn.DbId  = NodeTkn->DbId;
NextMemberTkn.DbId   = Member->DbId;
if (SetBug || DeBug)
if (sprintf (Msg, "\n  Delete the Set Node[%2u:%4u]  \n",
NodeTkn->DbId, NodeTkn->Handle))
if (TraceMsg (0, Msg))
if (SetBug || DeBug)
OaDumpObject  (0,  NodeTkn, McStat);
if (Normal(*Status))
if (TmFetchCoreDb    (NodeTkn,        McStat,         &CoreDb))
if (OaGetObject      (&SetDescTkn,    McStat,         (addrtype *)&SetDesc))
if (SetDesc->SetHeadType != aIndexedSetHead)
{
if (KernelGetAttr    (NodeTkn,                       lOwnerObject_AttrNum,
McStat,             (addrtype )&HeadTkn))
if (OaGetObject      (&HeadTkn, McStat,  (addrtype *)&SetHead))
if (SetBug || DeBug)
if (TraceMsg (0, "\n  Set Head of Node to be deleted::\n"))
OaDumpObject  (0,  &HeadTkn, McStat);
if (Normal(*Status))
if (KernelGetAttr    (&HeadTkn,                      RootNodes_AttrNum,
McStat,             (addrtype )&VrootTkn))
if (KernelGetAttr    (NodeTkn,                       lPrevLink_AttrNum,
McStat,             (addrtype )&PrevTkn))
if (KernelGetAttr    (NodeTkn,                       lNextLink_AttrNum,
McStat,             (addrtype )&NextTkn))
if (PrevTkn.Handle)
{
KernelPutAttr    (&PrevTkn,                      lNextLink_AttrNum,
(addrtype )&NextTkn,           McStat);
if (SetBug || DeBug)
if (TraceMsg (0, "  PrevTkn of Node to be deleted::\n"))
OaDumpObject  (0, &PrevTkn, McStat);
} else
SetHead->lFirstLink  = NextTkn.Handle;
if (Normal(*Status))
if (NextTkn.Handle)
{
KernelPutAttr    (&NextTkn,                       lPrevLink_AttrNum,
(addrtype )&PrevTkn,            McStat);
if (SetBug || DeBug)
if (TraceMsg (0, "  NextTkn of Node to be deleted::\n"))
OaDumpObject  (0,  &NextTkn, McStat);
} else
SetHead->lLastLink  = PrevTkn.Handle;
QuickPickHndl = NodeTkn->Handle;
if (Normal(*Status))
OaUpdateObject    (&HeadTkn,                       McStat);
} else {
QuickPickHndl = Member->Handle;
}
if (Normal(*Status))
if (QuickPickHndl)
{
if (OaGetVchunkAddr      (&VrootTkn,     McStat,   (addrtype *)&RootNodes))
if (OaGetVchunkStackPtr  (&VrootTkn,     McStat,               &StackPtr))
while (Index < StackPtr)
{
if (RootNodes[Index] == QuickPickHndl)
{
if (NextTkn.Handle  == NullHandle)
RootNodes[Index]  = NullHandle;
else if (SetDesc->SetType == aIndexedSet)
RootNodes[Index]  = NullHandle;
else
SaAdjustRootNode   (SetDesc,    Index,    &HeadTkn,   SetHead,
RootNodes,  StackPtr, &NextTkn,   McStat);
Index                = StackPtr;
}
Index++;
}
}
if (SetBug || DeBug)
if (SetHead != NullPtr)
if (sprintf (Msg,
"  SetHead[%2u:%4u] ->lFirstLink=%6u, ->lLastLink=%6u\n\n",
HeadTkn.DbId,        HeadTkn.Handle,
SetHead->lFirstLink, SetHead->lLastLink))
TraceMsg (0, Msg);
if (Normal(*Status))
if (EnvFetchObjNum   (NodeTkn,            McStat,     &NodeObjNum))
if (MemGetLocalObjNum
(CoreDb->LocalObjNumMap,          NodeObjNum,
McStat,                         &LocalObj))
if (OmGetObjHdr      (NodeTkn,                         LocalObj,
McStat,                         &ObjHdr))
if (OaGetObject      (NodeTkn,        McStat,         &NodeObj))
OmDeleteObject   (NodeTkn,                         ObjHdr,
NodeObj,                         McStat);
TRACK(TrackBak,"SaDeleteNode\n");
return(STAT);
}
boolean    SaAdjustRootNode
(setdesctype   *SetDesc,    indextype      PickIndex,
tokentype     *SetHeadTkn, lsetheaddesc  *SetHead,
handletype    *RootNodes,  indextype   RootStackPtr,
tokentype     *NextTkn,    ft F,lt Z,zz  *Status)
{
tokentype        MemberTkn;
lsetnodedesc    *SetNode         = NullPtr;
gsetnodedesc    *gSetNode        = NullPtr;
indextype        KeyIndex        = 0;
char            *KeyPtr          = NullPtr;
unsigned char    Value[MAXSTRING];
addrtype         ValuePtr        =  (addrtype )&Value[0];
settype          SetDescType     = aLocalSet;
numtype          PrimaryKey      = 0;
numtype          AllocSize       = 0;
memset (Value, NULL, MAXNAME);
if (SetHead->RootNodes)
{
MemberTkn.DbId         = SetHeadTkn->DbId;
PrimaryKey             = SetDesc->PrimaryKey;
SetDescType            = SetDesc->SetType;
if (SetBug)
if (sprintf (Msg, "   Adjust RootNode[<=%3u] ... \n", RootStackPtr))
TraceMsg (0, Msg);
if (Normal(*Status))
if (OaGetObject      (NextTkn,    McStat,    (addrtype *)&SetNode))
if (SetDescType       == aGlobalKeyedSet)
{
gSetNode           = (gsetnodedesc *)SetNode;
MemberTkn          = gSetNode->gMemberObject;
} else
MemberTkn.Handle   = SetNode->lMemberObject;
if (Normal(*Status))
KernelGetAttr     (&MemberTkn, PrimaryKey,  McStat,    ValuePtr);
if (Normal(*Status))
if (PrimaryKey        == Nam_AttrNum)
{
KeyPtr           = (char     *)ValuePtr;
KeyIndex         = (indextype )KeyPtr[0] - (indextype )64;
if (KeyIndex
&&  KeyIndex    <= 58)
{
if (KeyIndex  > 26)
KeyIndex -= 6;
if (KeyIndex == PickIndex)
RootNodes[PickIndex]  = NextTkn->Handle;
else
RootNodes[PickIndex]  = NullHandle;
}
} else if (SetDesc->SetType == aIndexedSet) {
RootNodes[PickIndex] = NullHandle;
} else if (SetDesc->SetType == aLocalKeyedSet
||  SetDesc->SetType == aGlobalKeyedSet) {
if (SetHeadTkn->DbId <= WenvId)
AllocSize = 10;
else
AllocSize = 100;
KeyIndex = *(wordtype *)ValuePtr / AllocSize;
if (KeyIndex < RootStackPtr)
if (KeyIndex == PickIndex)
RootNodes[PickIndex]  = NextTkn->Handle;
else
RootNodes[PickIndex]  = NullHandle;
} else
*Status = Set_BadQuickPickSet;
if (SetBug || DeBug)
if (sprintf (Msg, "  From SetHead->lFirstLink [%2u:%4u] \n",
SetHeadTkn->DbId, SetHead->lFirstLink))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "  Of   SetType  = %2u  Key=%3u   Status = %6d \n",
SetDesc->SetType, *(wordtype *)ValuePtr, *Status))
if (TraceMsg (0, Msg))
if (sprintf (Msg,  "  Adjust RootNode[%4u] = %4u \n",
PickIndex, NextTkn->Handle))
TraceMsg (0, Msg);
}
TRACK(TrackBak,"SaAdjustRootNode\n");
return (STAT);
}
boolean SaDeleteSetHead (handletype    SetDescHndl, tokentype    *HeadTkn,
ft F,lt Z,zz *Status)
{
tokentype       SetDescTkn;
setdesctype    *SetDesc         = NullPtr;
dbheader       *CoreDb          = NullPtr;
numtype         LocalObj        = 0;
objheader      *ObjHdr          = NullPtr;
tokentype       NextNodeTkn;
tokentype       CurrNodeTkn;
tokentype       MemberTkn;
addrtype        CurrNode        = NullPtr;
addrtype        HeadObj         = NullPtr;
numtype         MemberFieldAttrNum  = 0;
tokentype       VrootTkn;
setheadtype     HeadType;
numtype         SetHeadObjNum   = 0;
SetDescTkn.DbId    = RenvId;
SetDescTkn.Handle  = SetDescHndl;
CurrNodeTkn.DbId   = HeadTkn->DbId;
NextNodeTkn.DbId   = HeadTkn->DbId;
MemberTkn.DbId     = HeadTkn->DbId;
VrootTkn.DbId      = HeadTkn->DbId;
if (!HeadObjNum[2])
SetInitSetHeads (McStat);
if (SetBug || DeBug)
if (sprintf (Msg, "\n   Delete the Set [%2u:%4u]  \n",
HeadTkn->DbId, HeadTkn->Handle))
TraceMsg (0, Msg);
if (OaGetObject      (&SetDescTkn,    McStat,         (addrtype *)&SetDesc))
if (KernelGetAttr    (&SetDescTkn,                     MemberAttrNum_AttrNum,
McStat,              (addrtype )&MemberFieldAttrNum))
if (KernelGetAttr    (&SetDescTkn,                     SetHeadType_AttrNum,
McStat,              (addrtype )&HeadType))
{
SetHeadObjNum  = HeadObjNum[HeadType];
sprintf (Msg, "   setheadtype:= %-21s HeadObjNum[%2u]= %2u\n",
HeadNam[HeadType], HeadType, HeadObjNum[HeadType]);
TraceMsg (0, Msg);
}
if (HeadType == aLKeyedSetHead
||  HeadType == aLSetHead)
{
if (TmFetchCoreDb    (HeadTkn,        McStat,       &CoreDb))
if (MemGetLocalObjNum
(CoreDb->LocalObjNumMap,        lSetNode_ObjNum,
McStat,                       &LocalObj))
if (OmGetObjHdr      (HeadTkn,                       LocalObj,
McStat,                       &ObjHdr))
if (KernelGetAttr    (HeadTkn,                       lLastLink_AttrNum,
McStat,            (addrtype )&(CurrNodeTkn.Handle)))
while (Normal(*Status)
&&     CurrNodeTkn.Handle)
{
if (KernelGetAttr (&CurrNodeTkn,                  lPrevLink_AttrNum,
McStat,           (addrtype )&(NextNodeTkn.Handle)))
if (SetDesc->SetType  == aGlobalKeyedSet)
KernelGetAttr (&CurrNodeTkn,                  gMemberObject_AttrNum,
McStat,           (addrtype )&MemberTkn);
else
KernelGetAttr (&CurrNodeTkn,                  lMemberObject_AttrNum,
McStat,           (addrtype )&MemberTkn);
if (Normal(*Status))
if (KernelPutAttr (&MemberTkn,                    MemberFieldAttrNum,
(addrtype )&NullToken,         McStat))
if (OaGetObject   (&CurrNodeTkn,      McStat,    &CurrNode))
if (OmDeleteObject(&CurrNodeTkn,                  ObjHdr,
CurrNode,                      McStat))
CurrNodeTkn.Handle  = NextNodeTkn.Handle;
}
if (Normal(*Status))
if (KernelGetAttr    (HeadTkn,                       RootNodes_AttrNum,
McStat,            (addrtype )&VrootTkn.Handle))
if (OaDeleteVchunk   (&VrootTkn,                     McStat))
if (MemGetLocalObjNum
(CoreDb->LocalObjNumMap,        SetHeadObjNum,
McStat,                       &LocalObj))
if (OmGetObjHdr      (HeadTkn,                       LocalObj,
McStat,                       &ObjHdr))
if (OaGetObject      (HeadTkn,        McStat,       &HeadObj))
OmDeleteObject   (HeadTkn,                       ObjHdr,
HeadObj,                       McStat);
} else
*Status = Err_NotImplemented;
TRACK(TrackBak,"SaDeleteSetHead\n");
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\shell.c*/

#define  SHELL
#ifndef INLINE_OMIDEFS
#else
#define        RenvObjs_Hndl          (handletype )674
#endif
#define MemMakeChunk       Mem_MakeChunk
#define MemPutStackPtr     Mem_PutStackPtr
#define MemPutFuncPtr      Mem_PutFuncPtr
#define MemGetFuncPtr      Mem_GetFuncPtr






static  numtype      GetTknCodeDir  = 0;
boolean    ShellLoadObjCode   (numtype       ObjNum, funcptrtype CodeAddr,
ft F,lt Z,zz *Status)
{
sprintf (Msg,
"\n...NOTE... ShellLoadCode:: Class[%4u] will NOT be Activated.\n\n",
ObjNum);
TraceMsg (0, Msg);
TRACK(TrackBak,"ShellLoadObjCode\n");
return (STAT);
}
boolean ShellGetObjCode     (numtype       ObjNum,
ft F,lt Z,zz *Status,
funcptrtype  *CodeAddr,  size_t  *ClassSize)
{
if (ClassBug)
{
sprintf (Msg,
"\n...NOTE... ShellLoadCode:: Class[%4u] IS NOT Activated.\n\n",
ObjNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
EnvFetchClassSize (ObjNum,       McStat,                ClassSize);
if (DeBug || OaBug)
if (sprintf  (Msg, "   Obj CodeAddr class size=%3u\n", *ClassSize))
TraceMsg (0, Msg);
TRACK(TrackBak,"ShellGetObjCode\n");
return (STAT);
}
boolean    ShellLoadTokenCode (numtype       ObjNum, funcptrtype CodeAddr,
ft F,lt Z,zz *Status)
{
numtype   LastEnvObjCount = 0;
if (!GetTknCodeDir)
if (EnvFetchLastObjCount  (McStat,         &LastEnvObjCount))
if (MemMakeChunk   (sizeof (funcptrtype),   LastEnvObjCount+1,
Extend_Codes,           RenvId,
McStat,                &GetTknCodeDir))
MemPutStackPtr (GetTknCodeDir,            LastEnvObjCount+1,
McStat);
if (ClassBug)
MemBug = True;
if (Normal(*Status))
MemPutFuncPtr     (GetTknCodeDir, ObjNum, CodeAddr,       McStat);
if (ClassBug)
MemBug = False;
if (ClassBug || DeBug)
if (sprintf  (Msg, " ShellLoadTokenCode ObjNum = %4u; Chunk[%4u]\n",
ObjNum, GetTknCodeDir))
TraceMsg (0, Msg);
TRACK(TrackBak,"ShellLoadTokenCode\n");
return (STAT);
}
boolean ShellGetTokenCode   (numtype       ObjNum,
ft F,lt Z,zz *Status, funcptrtype  *CodeAddr)
{
*CodeAddr   = NULL;
if (DeBug || OaBug)
if (sprintf  (Msg, "   ShellGetTokenCode... ObjClass= %4u\n", ObjNum))
TraceMsg (0, Msg);
if (ClassBug)
MemBug = True;
if (GetTknCodeDir)
MemGetFuncPtr         (GetTknCodeDir, ObjNum,  McStat,  CodeAddr);
if (ClassBug)
MemBug = False;
TRACK(TrackBak,"ShellGetTokenCode\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\sm.c*/

#define SM_C
#ifndef INLINE_OMIDEFS
#else
#define        lKeyedSetHead_ObjNum   (objnumtype )66
#define        lSetNode_ObjNum        (objnumtype )78
#define        ObjNum_AttrNum         (numtype )5
#define        Nam_AttrNum            (numtype )19
#define        SetHeadType_AttrNum    (numtype )44
#define        OwnerAttrNum_AttrNum   (numtype )61
#define        PrimaryKey_AttrNum     (numtype )64
#define        lOwnerObject_AttrNum   (numtype )88
#define        lMemberObject_AttrNum  (numtype )89
#define        lFirstLink_AttrNum     (numtype )91
#define        lLastLink_AttrNum      (numtype )93
#define        lPrevLink_AttrNum      (numtype )95
#define        lNextLink_AttrNum      (numtype )97
#define        RenvDescs_Hndl         (handletype )694
#endif


boolean SetInitSet        (handletype    SetDescHndl,tokentype    *OwnerTkn,
numtype       AllocSize,  numtype       Order,
ft F,lt Z,zz *Status)
{
tokentype        SetDescTkn      = NullToken;
setdesctype     *SetDesc         = NullPtr;
settype          SetDescType     = aLocalSet;
objtype         *Owner           = NullPtr;
lsetheaddesc    *SetHead         = NullPtr;
tokentype        SetHeadTkn      = NullToken;
addrtype         Dummy           = NullPtr;
numtype          AllocQty        = 0;
tokentype        VrootToken      = NullToken;
SetHeadTkn.DbId   = OwnerTkn->DbId;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
if (OaGetObject   (OwnerTkn,            McStat,   (addrtype *)&Owner))
if (OaGetObject   (&SetDescTkn,         McStat,   (addrtype *)&SetDesc))
if (OaGet         (False,               OwnerTkn, (addrtype  )Dummy,
SetDesc->OwnerAttrNum,
McStat,              (addrtype )&(SetHeadTkn.Handle)))
SetDescType    = SetDesc->SetType;
if (Normal(*Status))
if (SetHeadTkn.Handle == NullHandle)
{
if (OaCreateObject (OwnerTkn,        lKeyedSetHead_ObjNum,
McStat,         &SetHeadTkn))
if (OaGetObject    (&SetHeadTkn,     McStat,     (addrtype *)&SetHead))
{
SetHead->BuildDesc     = SetDescHndl;
SetHead->lOwnerObject  = OwnerTkn->Handle;
SetHead->lFirstLink    = Null_Handle;
SetHead->lLastLink     = Null_Handle;
OaPut (False, OwnerTkn, (addrtype )Owner, SetDesc->OwnerAttrNum,
(addrtype )&(SetHeadTkn.Handle),   McStat);
}
} else
*Status = Set_BadDescName;
if (Normal(*Status))
{
if (SetBug || DeBug)
if (sprintf (Msg, "\n  Set::InitSet  %14s[%2u:%4u];  Owner[%2u:%4u]\n",
SetDesc->Nam,      SetDescTkn.DbId,  SetDescTkn.Handle,
OwnerTkn->DbId,    OwnerTkn->Handle))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "     Set Head    [%2u:%4u]; Alloc Members=%4u\n",
SetHeadTkn.DbId, SetHeadTkn.Handle, AllocSize))
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (SetDescType    == aIndexedSet
||  SetDescType    == aLocalKeyedSet
||  SetDescType    == aGlobalKeyedSet)
{
if (SetDesc->PrimaryKey   == Nam_AttrNum)
AllocQty                = 53;
else if (SetDescType == aIndexedSet)
{
SetHead->lFirstLink     = 1;
SetHead->lLastLink      = NullHandle;
AllocQty                = Alloc_DbObjs;
} else
AllocQty                = AllocSize / Order;
if (AllocQty)
if (OaCreateVchunk  (&SetHeadTkn,     sizeof (handletype),
AllocQty,        Extend_Fields,
McStat,         &VrootToken))
SetHead->RootNodes      = VrootToken.Handle;
}
TRACK(TrackBak,"SetInitSet\n");
return (STAT);
}
boolean    SetAddInto    (handletype SetDescHndl,   tokentype    *OwnerTkn,
tokentype *MemberTkn,     ft F,lt Z,zz *Status)
{
tokentype        NodeTkn  = NullToken;
tokentype        SetDescTkn;
setdesctype     *SetDesc         = NullPtr;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
if (OaGetObject      (&SetDescTkn,  McStat,   (addrtype *)&SetDesc))
if (SetDesc->SetType  == aLocalTableSet
||  SetDesc->SetType  == aGlobalTableSet)
*Status   = Err_NotImplemented;
else if (SetDesc->SetType  == aLocalTreeSet
||  SetDesc->SetType  == aGlobalTreeSet)
SpclAddIntoTree   (SetDescHndl,  OwnerTkn,  MemberTkn,
McStat,                 &NodeTkn);
else
SaAddInto           (SetDescHndl,  OwnerTkn,  MemberTkn,
McStat,                 &NodeTkn);
TRACK(TrackBak,"SetAddInto\n");
return (STAT);
}
boolean    SetFindIn     (handletype     SetDescHndl,   tokentype  *OwnerTkn,
addrtype       KeyValue,
ft F,lt Z,zz  *Status,        tokentype  *MemberTkn)
{
tokentype        NodeTkn         = NullToken;
tokentype        SetDescTkn      = NullToken;
setdesctype     *SetDesc         = NullPtr;
LastInIndexedSet.DbId    = OwnerTkn->DbId;
LastInIndexedSet.Handle  = 0;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
if (OaGetObject      (&SetDescTkn,  McStat,   (addrtype *)&SetDesc))
if (SetDesc->SetType  == aLocalTableSet
||  SetDesc->SetType  == aGlobalTableSet)
{
*Status   = Err_NotImplemented;
} else if (SetDesc->SetType  == aLocalTreeSet
||  SetDesc->SetType  == aGlobalTreeSet) {
SpclFindInTree    (SetDescHndl,  OwnerTkn,  KeyValue,
McStat,      &NodeTkn,   MemberTkn);
LastInIndexedSet = NodeTkn;
}
else
SaFindIn          (SetDescHndl,  OwnerTkn,  KeyValue,
McStat,      &NodeTkn,   MemberTkn);
TRACK(TrackBak,"SetFindIn\n");
return (STAT);
}
boolean SetIterateOn     (handletype    SetDescHndl, tokentype    *OwnerTkn,
iteratetype   Method,      ft F,lt Z,zz *Status)
{
tokentype     CurrentTkn;
tokentype     CurrentNode;
tokentype     NextTkn;
tokentype     NextNode;
indextype     ItNum        = 0;
int           TempDeBug    = DeBug;
CurrentTkn.DbId    = OwnerTkn->DbId;
CurrentNode.DbId   = OwnerTkn->DbId;
NextTkn.DbId       = OwnerTkn->DbId;
NextNode.DbId      = OwnerTkn->DbId;
DeBug = TempDeBug;
*Status = Env_Normal;
if (SetBug || DeBug)
if (sprintf (Msg, "\n   IterateOn the Set by Owner[%2u:%4u]  \n",
OwnerTkn->DbId, OwnerTkn->Handle))
TraceMsg (0, Msg);
if (OwnerTkn->Handle)
if (SetFirstOf     (SetDescHndl,     OwnerTkn,
McStat,         &CurrentNode,   &CurrentTkn))
{
if (Normal(*Status))
do {
++ItNum;
if ((*Method)  (&CurrentTkn,   ItNum,          McStat))
if (SetNextOf  (SetDescHndl,  &CurrentNode,
McStat,       &NextNode,      &NextTkn))
{
CurrentNode.Handle = NextNode.Handle;
CurrentTkn.Handle  = NextTkn.Handle;
}
} while (Normal(*Status));
}
if (*Status == Set_EndOfSet  || *Status == Set_EmptySet)
*Status = Env_Normal;
TRACK(TrackBak,"SetIterateOn\n");
return(STAT);
}
boolean SetDeleteFrom    (handletype    SetDescHndl, tokentype    *Member,
ft F,lt Z,zz *Status)
{
tokentype       SetDescTkn;
tokentype       NodeTkn;
setdesctype    *SetDesc     = NullPtr;
SetDescTkn.DbId    = RenvId;
SetDescTkn.Handle  = SetDescHndl;
if (ClassBug)
OaDumpObject  (0,  &SetDescTkn,  McStat);
if (OaGetObject      (&SetDescTkn,    McStat,    (addrtype *)&SetDesc))
if (SetDesc->SetType == aLocalTableSet
||  SetDesc->SetType == aGlobalTableSet)
{
*Status = Err_NotImplemented ;
} else if (SetDesc->SetType  == aLocalTreeSet
||  SetDesc->SetType  == aGlobalTreeSet)  {
SpclDeleteFromTree (SetDescHndl,  Member,    McStat);
} else {
NodeTkn.DbId   = Member->DbId;
if (KernelGetAttr    (Member,                   SetDesc->MemberAttrNum,
McStat,       (addrtype )&NodeTkn.Handle))
SaDeleteNode     (SetDescHndl,  Member,    &NodeTkn,         McStat);
}
TRACK(TrackBak,"SetDeleteFrom\n");
return(STAT);
}
boolean SetDeleteSet     (handletype    SetDescHndl, tokentype    *Owner,
ft F,lt Z,zz *Status)
{
*Status   = Err_NotImplemented;
TRACK(TrackBak,"SetDeleteSet\n");
return(STAT);
}
boolean    SetFirstOf    (handletype    SetDescHndl,   tokentype  *OwnerTkn,
ft F,lt Z,zz *Status,        tokentype  *NodeTkn,
tokentype    *MemberTkn)
{
tokentype        SetDescTkn;
setdesctype     *SetDesc     = NullPtr;
lsetheaddesc    *SetHead     = NullPtr;
tokentype        SetHeadTkn;
tokentype        VchunkTkn;
indextype        One         = 1;
indextype        Zero        = 0;
addrtype         Dummy       = NullPtr;
NodeTkn->DbId     = OwnerTkn->DbId;
NodeTkn->Handle   = NullHandle;
MemberTkn->DbId   = OwnerTkn->DbId;
MemberTkn->Handle = NullHandle;
SetHeadTkn.DbId   = OwnerTkn->DbId;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
if (!OwnerTkn->Handle)
{
*Status = Set_EmptySet;
if (SetBug || DeBug)
TraceMsg (0, "    ... !!  NULL Owner for this  Set\n");
}
if (Normal(*Status))
if (OaGetObject (&SetDescTkn,   McStat,   (addrtype *)&SetDesc))
if (OaGet       (False,         OwnerTkn, Dummy,
SetDesc->OwnerAttrNum,
McStat,        (addrtype )&(SetHeadTkn.Handle)))
if (SetHeadTkn.Handle == NullHandle)
*Status = Set_EmptySet;
if (Normal(*Status))
OaGetObject (&SetHeadTkn,   McStat,   (addrtype *)&SetHead);
if ((!Normal(*Status) && SetBug)
||   DeBug)
{
if (*Status != Set_EmptySet)
if (sprintf (Msg, "\n  SetFirstOf  %14s[%2u:%4u]  SetOwner[%2u:%4u]\n",
SetDesc->Nam,   SetDescTkn.DbId,  SetDescTkn.Handle,
OwnerTkn->DbId, OwnerTkn->Handle))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "     SetHead            [%2u:%4u] @ %x\n",
SetHeadTkn.DbId, SetHeadTkn.Handle, SetHead))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "            ->Firstlink [%2u:%4u] \n",
SetHeadTkn.DbId, SetHead->lFirstLink))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "            ->Lastlink  [%2u:%4u] \n",
SetHeadTkn.DbId, SetHead->lLastLink))
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (SetHead->lFirstLink == NullHandle)
*Status = Set_EmptySet;
if (*Status == Set_EmptySet)
{
MemberTkn->Handle   = NullHandle;
if (DeBug)
TraceMsg (0, "    ... Empty Set\n");
} else if (Normal(*Status)) {
if (SetDesc->SetType == aIndexedSet)
{
CurrVchunkIndex    = 0;
if (SaGetRootNode (&SetHeadTkn,       SetHead,   &SetDescTkn,
(addrtype )&Zero,  McStat,
MemberTkn,       &VchunkTkn))
{
NodeTkn->Handle     = VchunkTkn.Handle;
NodeTkn->DbId       = VchunkTkn.DbId;
*Status              = Env_Normal;
}
if (SetBug || DeBug)
if (sprintf (Msg, "     Get IndexedSet[%2u]  Member[%2u:%4u]\n",
One, MemberTkn->DbId,   MemberTkn->Handle))
TraceMsg (0, Msg);
} else {
NodeTkn->DbId   = SetHeadTkn.DbId;
NodeTkn->Handle = SetHead->lFirstLink;
if (OaGet     (False,              NodeTkn, Dummy,
lMemberObject_AttrNum,
McStat,             (addrtype )&(MemberTkn->Handle)))
MemberTkn->DbId = NodeTkn->DbId;
if (Normal(*Status))
if (SetBug || DeBug)
if (sprintf (Msg, "     Node[%2u:%4u]  Member[%2u,%4u]\n",
NodeTkn->DbId,     NodeTkn->Handle,
MemberTkn->DbId,   MemberTkn->Handle))
TraceMsg (0, Msg);
}
}
TRACK(TrackBak,"SetFirstOf\n");
return (STAT);
}
boolean    SetNextOf    (handletype    SetDescHndl,   tokentype  *CurrentNode,
ft F,lt Z,zz *Status,        tokentype  *NextNode,
tokentype    *NextMember)
{
tokentype        SetDescTkn;
setdesctype     *SetDesc     = NullPtr;
addrtype         Dummy       = NullPtr;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
if (CurrentNode->Handle == NullHandle)
*Status = Set_EndOfSet;
if (Normal(*Status))
if (OaGetObject (&SetDescTkn,   McStat,   (addrtype *)&SetDesc))
if (SetDesc->SetType == aIndexedSet)
{
SetGetSwi = True;
OaGetUnit (CurrentNode, ++CurrVchunkIndex,
McStat,       (addrtype )&(NextMember->Handle));
SetGetSwi = False;
NextNode->DbId     = CurrentNode->DbId;
NextNode->Handle   = CurrentNode->Handle;
} else {
OaGet       (False,        CurrentNode, (addrtype )Dummy,
lNextLink_AttrNum,
McStat,       (addrtype )&(NextNode->Handle));
NextNode->DbId = CurrentNode->DbId;
}
if (Normal(*Status))
if (NextNode->Handle == NullHandle)
*Status = Set_EndOfSet;
if (Normal(*Status))
if (SetDesc->SetType != aIndexedSet)
if (OaGet  (False,              NextNode, Dummy,
lMemberObject_AttrNum,
McStat,             (addrtype )&(NextMember->Handle)))
NextMember->DbId = NextNode->DbId;
if (*Status == Set_EndOfSet)
{
NextNode->DbId     = CurrentNode->DbId;
NextNode->Handle   = NullHandle;
NextMember->DbId   = CurrentNode->DbId;
NextMember->Handle = NullHandle;
}
if (SetBug ||  DeBug)
if (sprintf (Msg, "\n    SetNextOf... Current   [%2u,%4u]  Next [%2u,%4u]\n",
CurrentNode->DbId,     CurrentNode->Handle,
NextNode->DbId,        NextNode->Handle))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "                 Member [%2u,%4u]\n",
NextMember->DbId,   NextMember->Handle))
TraceMsg (0, Msg);
TRACK(TrackBak,"SetNextOf\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\testobj.c*/

#define  DRAW7
boolean Draw701   (tokentype    *Anchor,   boolean       TestBug,
numtype       Option,   ft F,lt Z,zz *Status);
boolean Draw701           (tokentype    *Anchor,   boolean       TestBug,
numtype       Option,   ft F,lt Z,zz *Status)
{
tokentype                  LibTkn000             = *Anchor;
tokentype                  RefTkn                = NullToken;
TestObj                    Ref0;
TestObj                   *ref0                  = NullPtr;
int                        j                     = 0;
int                        k                     = 0;
int                        Compare               = 0;
char                      *StrAddr               = NullPtr;
fieldstruc                *LinkField0            = NullPtr;
fieldstruc                *LinkField1            = NullPtr;
fieldstruc                *LinkField2            = NullPtr;
static Connection          Null_link             = {0, "\0", 0};
static XyPoint             Null_XyOrigin         = {0,0};
static varray(short)       Null_ShortArray       = {Null_Token, 0, NullPtr};
static vchunk(int)         Null_IntChunk         = {Null_Token, 0, NullPtr, 0};
static refobjtype(Point)   Null_RefOrigin        = {NullPtr, Null_Token};
numtype                    Null_GrpNum           = 0;
boolean                    StrCpyIsA             = False;
char                       Char_Scalar           = 'A';
static nametype            Char_InStruct         = "nametype string";
static cstring             Char_InStruct1        = "cstring  string";
static char               *str1                  = "char    *array";
cstring                    Char_Array            = NullPtr;
char                     **StrPtrs               = NullPtr;
numtype                    NumNames              = 10;
static  char              *Names[10]             = {
"FullFix",     "Pre1111",        "Q2Mid123",
"Pre12Mid12",  "Q1Post",         "Pre12Post",
"Q2Mid123Post","Pre12Mid123Post","wildstring",
"stringwild"         };
signed short               Short_Scalar          = -9;
unsigned short             ShortU_Scalar         = 10;
signed                     Int_Scalar            = -11;
unsigned                   IntU_Scalar           = 12;
lt64                       Long_Scalar           = -13;
longtype                   LongU_Scalar          = 14;
float                      Float_Scalar          = 15.1;
double                     Double_Scalar         = 16.1;
tokentype                  Token_Scalar          = *Anchor;
handletype                 Handle_Scalar         = 18;
static short               Xarray[5]             = {1,2,3,4,5};
numtype                    NumXarrays            = 5;
numtype                    UnitCount             = 0;
numtype                    UnitCount0            = 0;
static short               XyCoords[2][5]        = { {-1,-2,-3,-4,-5},
{6,7,8,9,10} };
short                     *ShortArray            = NullPtr;
short                     *XyCoordPtrs           = NullPtr;
numtype                    NumXyCoordPtrs        = 2;
numtype                    NumXyCoords           = 5;
addrtype                  *Void_Ptr              = NullPtr;
numtype                    NumVoidPtrs           = 5;
bytessizetype              Void_AllocSize        = 0;
colortype                  Color                 = aGreen;
static XyPoint             XyOrigin              = {101,102};
static Connection          link[3]               = { {1, "link1", 10},
{2, "link2", 20},
{3, "link3", 30} };
tokentype                  OriginTkn             = NullToken;
CartesianPoint            *Origin                = NullPtr;
shorttype                  xAxisVal              = 24;
shorttype                  yAxisVal              = 240;
XyPoint                   *Points                = NullPtr;
numtype                    NumPoints             = 2;
boolean                    IsActive              = True;
bytetype                  *Bytes                 = NullPtr;
static bytetype            Byte_Array[5]         = {10,20,30,40,50};
numtype                    NumBytes              = 5;
short                     *Yarray                = NullPtr;
numtype                    NumYarrays            = 5;
varray(short)              xArrayStruc;
short                     *xArray                = NullPtr;
numtype                    NumxArrays            = 5;
int                       *Xcoords               = NullPtr;
numtype                    NumXcoords            = 5;
vchunk(int)                XcoordsStruc;
vchunktoken                XyDirTkn              = NullToken;
int                       *XyDir                 = NullPtr;
numtype                    NumXyDirs             = 5;
tokentype                  BitMapTkn             = NullToken;
numtype                    NumBits               = 10;
Point                     *RefOrigin             = NullPtr;
numtype                    NumVparts             = 100;
numtype                    GrpNum                = 0;
grpheader                 *GrpHdr                = NullPtr;
numtype                    GrpIndex              = 0;
sizetype                   EntrySize             = sizeof (XyPoint);
numtype                    RgnHndls              = 1000;
numtype                    AllocRgns             = (RgnHndls / 25) + 27;
numtype                    RgnEntrys             = 25;
numtype                    AllocXs               = 1000;
numtype                    BaseIndex             = 0;
accesstype                 AccessType            = Read_Write;
boolean                    DiskCache             = False;
numtype                    CacheLimit            = 10;
numtype                    CacheLoad             = 10;
numtype                    NumBuffRgns           = 10;
numtype                    BaseRegion            = 0;
sizetype                   UnitSize              = 0;
static boolean             FirstTime             = True;
if (Normal(*Status))
{
if (TestBug)
TraceMsg (0, "\n *** Begin test for TestObj\n");
if (Env_NewFieldStruc    ("link[0]", McStat,  &LinkField0))
if (Env_NewFieldStruc    ("link[1]", McStat,  &LinkField1))
if (Env_NewFieldStruc    ("link[2]", McStat,  &LinkField2))
if (Option  == 1)
{
IsActive    = False;
if (TestBug)
TraceMsg (0, " CREATE Object internal to DBMS, and PUT Values\n");
if (Object_Create    (&LibTkn000,       TestObj_Class,
McStat,          &RefTkn))
if (RefTkn.Handle == 0) TestBug = True;
if (TestBug)
{
sprintf (Msg, " TestObj Created. Token[%3u:%8u]\n",
RefTkn.DbId, RefTkn.Handle);
TraceMsg (0, Msg);
}
FirstTime   = False;
} else {
IsActive    = True;
if (TestBug)
TraceMsg (0, " CREATE Object, GET Image, and PUT Values.\n");
if (Object_NewImage
(&LibTkn000,        TestObj_Class,
McStat,   &RefTkn, (addrtype *)&ref0))
if (RefTkn.Handle == 0) TestBug = True;
if (TestBug)
{
sprintf (Msg, " TestObj Created. Token[%3u:%8u] Image @%8x\n",
RefTkn.DbId, RefTkn.Handle, ref0);
TraceMsg (0, Msg);
TraceMsg (0, " Display contents of NEW TestObject IMAGE...\n");
Object_Dump        (&RefTkn);
}
}
if (Normal(*Status))
{
if (Attr_ValuePut     (&RefTkn,   Char_Scalar_Attr,
(addrtype )&Char_Scalar,
McStat))
if (Option       <= 1)
Attr_ValuePut     (&RefTkn,   Char_InStruct_Attr,
(addrtype )Char_InStruct,
McStat);
else if (Option  == 2)
Attr_ValuePut
(&RefTkn,   Char_InStruct_Attr,
"A Long Name",
McStat);
else if (Option  == 2)
Attr_ValuePut     (&RefTkn,   Char_InStruct_Attr,
(addrtype )Char_InStruct1,
McStat);
if (Normal(*Status))
if (Attr_StringCreate (&RefTkn,   Char_Array_Attr,    sizeof (nametype),
McStat,   &StrAddr))
strcpy (StrAddr, str1);
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   Char_PtrArray_Array_Attr,
NumNames,                      sizeof (char *),
McStat,           (addrtype *)&StrPtrs))
for (j= -1; Normal(*Status) && ++j < NumNames; )
{
if (Attr_SubArrayCreate
(&RefTkn,   Char_PtrArray_Array_Attr,   j,
strlen(Names[j])+1,         sizeof (char ),
McStat,           (addrtype *)&StrAddr))
strcpy (StrAddr, Names[j]);
}
if (Normal(*Status))
if (Attr_ValuePut     (&RefTkn,   Short_Scalar_Attr,
(addrtype )&Short_Scalar,
McStat))
if (Attr_ValuePut     (&RefTkn,   ShortU_Scalar_Attr,
(addrtype )&ShortU_Scalar,
McStat))
if (Attr_ValuePut     (&RefTkn,   Int_Scalar_Attr,
(addrtype )&Int_Scalar,
McStat))
if (Attr_ValuePut     (&RefTkn,   IntU_Scalar_Attr,
(addrtype )&IntU_Scalar,
McStat))
if (Attr_ValuePut     (&RefTkn,   Long_Scalar_Attr,
(addrtype )&Long_Scalar,
McStat))
if (Attr_ValuePut     (&RefTkn,   LongU_Scalar_Attr,
(addrtype )&LongU_Scalar,
McStat))
if (Attr_ValuePut     (&RefTkn,   Float_Scalar_Attr,
(addrtype )&Float_Scalar,
McStat))
if (Attr_ValuePut     (&RefTkn,   Double_Scalar_Attr,
(addrtype )&Double_Scalar,
McStat))
if (Attr_ValuePut     (&RefTkn,   Token_Scalar_Attr,
(addrtype )&Token_Scalar,
McStat))
if (Attr_ValuePut     (&RefTkn,   Handle_Scalar_Attr,
(addrtype )&Handle_Scalar,
McStat))
if (Attr_ArrayCreate  (&RefTkn,   Xarray_Attr,
NumXarrays,              sizeof (short),
McStat,           (addrtype *)&ShortArray))
for (j= -1; Normal(*Status) && ++j < NumXarrays; )
{
ShortArray[j]   = Xarray[j];
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   XyCoords_Attr,
NumXyCoordPtrs,         sizeof (short *),
McStat,           (addrtype *)&ShortArray))
for (j= -1; Normal(*Status) && ++j < NumXyCoordPtrs; )
{
if (Attr_SubArrayCreate
(&RefTkn,   XyCoords_Attr,   j,
NumXyCoords,            sizeof (short),
McStat,           (addrtype *)&ShortArray))
for (k= -1; Normal(*Status) && ++k < NumXyCoords; )
{
ShortArray[k]  = XyCoords[j][k];
}
}
if (Normal(*Status))
if (TestBug)
{
Attr_ArrayCreate   (&RefTkn,   Void_Ptr_Attr,
NumVoidPtrs,            sizeof (addrtype ),
McStat,                 (addrtype *)&Void_Ptr);
if (*Status == Trans_MixedArraySize)
{
*Status    = Env_Normal;
if (TestBug)
TraceMsg (0, "  Void_Ptr           'ArrayCreate'     PASSED.\n");
} else
TraceMsg (0, "  Void_Ptr           'ArrayCreate'     FAILED.\n");
if (TestBug)
TraceMsg (0, "\n");
}
if (Normal(*Status))
if (Attr_ValuePut     (&RefTkn,   Color_Attr,   (addrtype )&Color,
McStat))
if (Attr_ValuePut     (&RefTkn,   XyOrigin_Attr,
(addrtype )&XyOrigin,               McStat))
if (Field_ValuePut    (&RefTkn,   LinkField0,   (addrtype )&link[0],
McStat))
if (Field_ValuePut    (&RefTkn,   LinkField1,   (addrtype )&link[1],
McStat))
if (Field_ValuePut    (&RefTkn,   LinkField2,   (addrtype )&link[2],
McStat))
if (Normal(*Status))
if (IsActive == False)
{
if (Object_Create  (&RefTkn,   CartesianPoint_Class,
McStat,                          &OriginTkn))
if (Attr_ValuePut  (&OriginTkn,xCoord_Attr,  (addrtype )&xAxisVal,
McStat))
if (Attr_ValuePut  (&OriginTkn,yCoord_Attr,  (addrtype )&yAxisVal,
McStat))
Attr_ObjTknPut (&RefTkn,   Origin_Attr,             &OriginTkn,
McStat);
} else {
if (Object_NewImage(&RefTkn,   CartesianPoint_Class,  McStat,
&OriginTkn,         (addrtype  *)&Origin))
{
Origin->xCoord  = 24;
Origin->yCoord  = 240;
Attr_ValuePut   (&RefTkn,   Origin_Attr,  (addrtype )Origin,
McStat);
}
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   Points_Attr,
NumPoints,                   sizeof (XyPoint),
McStat,           (addrtype *)&Points))
{
Points[0].xCoord  = 26;
Points[0].yCoord  = -26;
Points[1].xCoord  = 126;
Points[1].yCoord  = -126;
}
if (Normal(*Status))
if (Attr_ValuePut     (&RefTkn,   IsActive_Attr,
(addrtype )&IsActive,               McStat))
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   Byte_Array_Attr,
NumBytes,               sizeof (bytetype),
McStat,           (addrtype *)&Bytes))
for (j= -1; Normal(*Status) && ++j < NumBytes; )
{
Bytes[j]   = Byte_Array[j];
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   Yarray_Attr,
NumYarrays,             sizeof (short),
McStat,           (addrtype *)&Yarray))
for (j= -1; Normal(*Status) && ++j < NumYarrays; )
{
Yarray[j]   = Xarray[j];
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   xArray07_Attr,
NumxArrays,             sizeof (short),
McStat,           (addrtype *)&xArray))
if (Attr_ValueGet     (&RefTkn,   xArray07_Attr,
McStat,    (addrtype )&xArrayStruc))
if (Vchunk_PutStackPtr(&xArrayStruc.VchunkTkn,      NumxArrays,
McStat,         (addrtype *)&xArray))
for (j= -1; Normal(*Status) && ++j < NumxArrays; )
{
xArray[j]   = Xarray[j];
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&RefTkn,   Xcoords_Attr,
NumXcoords,             sizeof (int),
McStat,           (addrtype *)&Xcoords))
if (Attr_ValueGet     (&RefTkn,   Xcoords_Attr,
McStat,    (addrtype )&XcoordsStruc))
if (Vchunk_PutStackPtr(&XcoordsStruc.VchunkTkn,     NumXcoords,
McStat,         (addrtype *)&Xcoords))
for (j= -1; Normal(*Status) && ++j < NumXcoords; )
{
Xcoords[j]   = Xarray[j];
}
if (Normal(*Status))
if (Vchunk_Create     (&RefTkn,   sizeof (int),     5,     10,
McStat,          &XyDirTkn))
if (Attr_ValuePut     (&RefTkn,   XyDir_Attr,
(addrtype )&XyDirTkn,                McStat))
if (Vchunk_PutStackPtr(&XyDirTkn,                          NumXyDirs,
McStat,                (addrtype *)&XyDir))
for (j= -1; Normal(*Status) && ++j < NumXyDirs; )
{
XyDir[j]   = Xarray[j];
}
if (Normal(*Status))
if (BitField_Create   (&RefTkn,   NumBits,   McStat,      &BitMapTkn))
if (Attr_ValuePut     (&RefTkn,   BitMap_Attr,
(addrtype )&BitMapTkn,               McStat))
for (j= -1; Normal(*Status) && ++j < NumBits; ++j)
{
BitField_Put      (&BitMapTkn,       j,     1,         McStat);
}
if (Normal(*Status))
if (Attr_RefTknPut    (&RefTkn,   RefOrigin_Attr,          &OriginTkn,
McStat))
if (Attr_TokenToRef   (&RefTkn,   RefOrigin_Attr,
McStat,                 (addrtype *)&RefOrigin))
if (IsActive)
if (RefOrigin != (Point *)Origin)
{
TraceMsg (0, "  ***SWIzzle MisMatch on Reference Token value.\n");
sprintf (Msg, "     RefOrigin (%8x) != Origin (%8x)\n",
RefOrigin,  Origin);
TraceMsg (0, Msg);
}
if (TestBug)
if (Normal(*Status))
if (GrpNewPacket      (&RefTkn,   EntrySize,   AllocRgns,   RgnEntrys,
AllocXs,   BaseIndex,   AccessType,  DiskCache,
CacheLimit,CacheLoad,   NumBuffRgns,
McStat,   &GrpNum,     &GrpHdr,     &BaseRegion))
if (Attr_ValuePut     (&RefTkn,   VpartsDir_Attr,(addrtype)&GrpNum,
McStat))
for (j= -1; Normal(*Status) && ++j < NumVparts; ++j)
{
Grp_PutNewEntry    (&RefTkn,   GrpNum,       (addrtype )&j,
McStat,   &GrpIndex);
}
if (Normal(*Status))
if (TestBug)
{
TraceMsg (0, "\n Display contents of RefOrigin Object ...\n");
Object_Dump          (&OriginTkn);
TraceMsg (0, " Display contents of Instantiated Object ...\n");
Object_Dump          (&RefTkn);
}
if (Normal(*Status))
if (IsActive)
{
if (TestBug)
TraceMsg (0, "\n  COMMIT && FREE TestObj (and sub-structs) to DB.\n");
if (TestObj_delete      (&ref0,       dbCommit,   McStat))
if (Object_CommitImage  (&OriginTkn,  True,       McStat))
if (TestBug)
{
TraceMsg (0,
" Display contents of Committed RefOrigin  Object ...\n");
Object_Dump          (&OriginTkn);
TraceMsg (0,
" Display contents of Committed TestObject ...\n");
Object_Dump          (&RefTkn);
}
}
if (Normal(*Status))
if (Void_Ptr      != NullPtr)
Core0_FreeCore  ((addrtype *)&Void_Ptr,   Void_AllocSize,  McStat);
}
if (Normal(*Status))
{
if (TestBug)
TraceMsg (0, "\n Retrieve TestObj Values from Db.\n");
if (IsActive)
{
if (TestBug)
{
TraceMsg (0, " Process TestObj IN Activate state (the Image).\n");
TraceMsg (0, "   GET from the Image to a transient Copy.\n");
}
if (Object_GetImage (&RefTkn,     McStat,  (addrtype *)&ref0))
if (TestBug)
{
sprintf (Msg, " TestObj Retrieved. Token[%3u:%8u] @%6x. \n\n",
ref0->Token.DbId, ref0->Token.Handle, ref0);
TraceMsg (0, Msg);
Object_Dump    (&RefTkn);
sprintf (Msg, " Current State of OriginTkn[%3u:%8u]\n",
OriginTkn.DbId, OriginTkn.Handle);
TraceMsg (0, Msg);
Object_Dump    (&OriginTkn);
}
}
if (Normal(*Status))
if (IsActive   == Object_ImageIsActive   (&RefTkn,         McStat))
{
if (TestBug)
TraceMsg (0, "  RefTkn      'Object_ImageIsActive' PASSED.\n");
} else
TraceMsg (0, "  RefTkn      'Object_ImageIsActive' FAILED.\n");
Ref0.That                   = (addrtype )&Ref0;
Ref0.Token                  = NullToken;
Ref0.Char_Scalar            = ' ';
Ref0.Char_InStruct[0]       = '\0';
Ref0.Char_Array             = NullPtr;
Ref0.Char_PtrArray_Array    = NullPtr;
Ref0.Short_Scalar           = 0;
Ref0.ShortU_Scalar          = 0;
Ref0.Int_Scalar             = 0;
Ref0.IntU_Scalar            = 0;
Ref0.Long_Scalar            = 0;
Ref0.LongU_Scalar           = 0;
Ref0.Float_Scalar           = 0.0;
Ref0.Double_Scalar          = 0.0;
Ref0.Token_Scalar           = NullToken;
Ref0.Handle_Scalar          = 0;
Ref0.Xarray                 = NullPtr;
Ref0.XyCoords               = NullPtr;
Ref0.Void_Ptr               = NullPtr;
Ref0.Color                  = aNonColor;
Ref0.XyOrigin               = Null_XyOrigin;
Ref0.link[0]                = Null_link;
Ref0.link[1]                = Null_link;
Ref0.link[2]                = Null_link;
Ref0.Origin                 = NullPtr;
Ref0.Points                 = NullPtr;
Ref0.IsActive               = False;
Ref0.Byte_Array             = NullPtr;
Ref0.Char_String            = NullPtr;
Ref0.Yarray                 = NullPtr;
Ref0.xArray                 = Null_ShortArray;
Ref0.Xcoords                = Null_IntChunk;
Ref0.XyDir                  = NullToken;
Ref0.BitMap                 = NullToken;
Ref0.RefOrigin              = Null_RefOrigin;
Ref0.VpartsDir              = Null_GrpNum;
if (Normal(*Status))
if (Attr_ValueGet     (&RefTkn,   Char_Scalar_Attr,
McStat,    (addrtype )&Ref0.Char_Scalar))
if ((Compare =
Attr_ValueCompare (&RefTkn,   Char_Scalar_Attr,
&Char_Scalar,          NullPtr,  McStat))
== 0)
{
if (TestBug)
TraceMsg (0, "  Char_Scalar        'ValueCompare'      PASSED.\n");
} else
TraceMsg (0, "  Char_Scalar        'ValueCompare'      FAILED.\n");
if (Normal(*Status))
if (Attr_ValueGet     (&RefTkn,   Char_InStruct_Attr,
McStat,    (addrtype )&Ref0.Char_InStruct))
if ((Compare =
Attr_ValueCompare (&RefTkn,   Char_InStruct_Attr,
&Char_InStruct,        NullPtr,  McStat))
== 0)
{
if (TestBug)
TraceMsg (0, "  Char_InStruct      'ValueCompare'      PASSED.\n");
} else {
if (IsActive)
{
if (TestBug)
TraceMsg (0, "  Char_InStruct      'ValueCompare'      PASSED.\n");
} else
TraceMsg (0, "  Char_InStruct      'ValueCompare'      FAILED.\n");
}
StrAddr   = NullPtr;
if (Normal(*Status))
if (Attr_ValueGet     (&RefTkn,   Char_Array_Attr,
McStat,    (addrtype )&Ref0.Char_Array))
if (Attr_StringGet    (&RefTkn,   Char_Array_Attr,
McStat,   &StrCpyIsA,      &Char_Array))
if (!strcmp (Char_Array,          (char *)Ref0.Char_Array))
{
if ((IsActive  == True  && StrCpyIsA  == False)
||  (IsActive  == False && StrCpyIsA  == True))
{
if (TestBug)
TraceMsg (0, "  Char_Array         'ValueCompare'      PASSED.\n");
} else
TraceMsg (0, "  Char_Array         'ValueCompare'      FAILED.\n");
} else
TraceMsg (0, "  Char_Array         'ValueCompare'      FAILED.\n");
if (Normal(*Status))
if (Attr_ValueGet     (&RefTkn,   Char_PtrArray_Array_Attr,
McStat,
(addrtype )&Ref0.Char_PtrArray_Array))
if (Attr_ValueGet     (&RefTkn,   Short_Scalar_Attr,
McStat,    (addrtype )&Ref0.Short_Scalar))
if ((Compare =
Attr_ValueCompare (&RefTkn,   Short_Scalar_Attr,
&Short_Scalar,         NullPtr,  McStat))
== 0)
{
if (TestBug)
TraceMsg (0, "  Short_Scalar       'ValueCompare'      PASSED.\n");
} else
TraceMsg (0, "  Short_Scalar       'ValueCompare'      FAILED.\n");
if (Normal(*Status))
if (Attr_ValueGet     (&RefTkn,   ShortU_Scalar_Attr,
McStat,    (addrtype )&Ref0.ShortU_Scalar))
if (Attr_ValueGet     (&RefTkn,   Int_Scalar_Attr,
McStat,    (addrtype )&Ref0.Int_Scalar))
if (Attr_ValueGet     (&RefTkn,   IntU_Scalar_Attr,
McStat,    (addrtype )&Ref0.IntU_Scalar))
if (Attr_ValueGet     (&RefTkn,   Long_Scalar_Attr,
McStat,    (addrtype )&Ref0.Long_Scalar))
if (Attr_ValueGet     (&RefTkn,   LongU_Scalar_Attr,
McStat,    (addrtype )&Ref0.LongU_Scalar))
if (Attr_ValueGet     (&RefTkn,   Float_Scalar_Attr,
McStat,    (addrtype )&Ref0.Float_Scalar))
if (Attr_ValueGet     (&RefTkn,   Double_Scalar_Attr,
McStat,    (addrtype )&Ref0.Double_Scalar))
if (Attr_ValueGet     (&RefTkn,   Token_Scalar_Attr,
McStat,    (addrtype )&Ref0.Token_Scalar))
if (Attr_ValueGet     (&RefTkn,   Handle_Scalar_Attr,
McStat,    (addrtype )&Ref0.Handle_Scalar))
if (Attr_ArrayGetSize (&RefTkn,   Xarray_Attr,
McStat,   &UnitCount,      &UnitSize))
if (UnitCount      != NumXarrays
||  UnitSize       != sizeof (short))
TraceMsg (0, "  Xarray             'ArrayGetSize'      FAILED.\n");
else  if (TestBug)
TraceMsg (0, "  Xarray             'ArrayGetSize'      PASSED.\n");
if (Normal(*Status))
if (IsActive)
Attr_ValueGet     (&RefTkn,   Xarray_Attr,
McStat,    (addrtype )&Ref0.Xarray);
else {
Attr0_ArrayActivate
(&RefTkn,   Xarray_Attr,
McStat,   &UnitCount0,
&UnitSize,  (addrtype *)&Ref0.Xarray);
if (UnitCount0 != UnitCount
||  UnitSize   != sizeof (short))
TraceMsg (0,
"  Xarray             'ArrayActivate'     FAILED.\n");
else if (TestBug)
TraceMsg (0,
"  Xarray             'ArrayActivate'     PASSED.\n");
}
if (Normal(*Status))
if (Attr_ArrayGetSize (&RefTkn,   XyCoords_Attr,
McStat,   &UnitCount,      &UnitSize))
if (UnitCount      != NumXyCoordPtrs)
TraceMsg (0, "  XyCoords           'ArrayGetSize'      FAILED.\n");
else  if (TestBug)
TraceMsg (0, "  XyCoords           'ArrayGetSize'      PASSED.\n");
if (Normal(*Status))
if (IsActive   == False)
{
Attr0_ArrayActivate
(&RefTkn,   XyCoords_Attr,
McStat,   &UnitCount,
&UnitSize, (addrtype *)&Ref0.XyCoords);
if (UnitCount  != NumXyCoordPtrs)
TraceMsg (0,
"  XyCoords           'ArrayActivate'     FAILED.\n");
else  if (TestBug)
TraceMsg (0,
"  XyCoords           'ArrayActivate'     PASSED.\n");
} else
Attr_ValueGet     (&RefTkn,   XyCoords_Attr,
McStat,    (addrtype  )&Ref0.XyCoords);
if (Normal(*Status))
if (Attr_SubArrayGetSize
(&RefTkn,  XyCoords_Attr,    1,
McStat,   &UnitCount))
if (UnitCount      != NumXyCoords)
TraceMsg (0, "  XyCoords           'SubArrayGetSize'   FAILED.\n");
else if (TestBug)
TraceMsg (0, "  XyCoords           'SubArrayGetSize'   PASSED.\n");
if (Normal(*Status))
if (TestBug)
if (Attr_ValueGet     (&RefTkn,   Void_Ptr_Attr,
McStat,    (addrtype )&Ref0.Void_Ptr))
if (Ref0.Void_Ptr != NullPtr)
TraceMsg (0, "  Void_Ptr           'Attr_ValueGet'     FAILED.\n");
else if (TestBug)
TraceMsg (0, "  Void_Ptr           'Attr_ValueGet'     PASSED.\n");
if (Normal(*Status))
if (Attr_ValueGet     (&RefTkn,   Color_Attr,
McStat,    (addrtype )&Ref0.Color))
if (Attr_ValueGet     (&RefTkn,   XyOrigin_Attr,
McStat,    (addrtype )&Ref0.XyOrigin))
if (Field_ValueGet    (&RefTkn,   LinkField0,
McStat,    (addrtype )&Ref0.link[0]))
if (Field_ValueGet    (&RefTkn,   LinkField1,
McStat,    (addrtype )&Ref0.link[1]))
if (Field_ValueGet    (&RefTkn,   LinkField2,
McStat,    (addrtype )&Ref0.link[2]))
if (IsActive)
Attr_ValueGet     (&RefTkn,   Origin_Attr,
McStat,    (addrtype )&Ref0.Origin);
else {
if (Attr_ObjTknGet (&RefTkn,   Origin_Attr,
McStat,   &OriginTkn))
Attr_ValueGet  (&RefTkn,   Origin_Attr,
McStat,    (addrtype )&Ref0.Origin);
}
if (Normal(*Status))
if (Env_TokenIsEquiv  (&OriginTkn,           &Ref0.Origin->Token))
{
if (TestBug)
TraceMsg (0, "  Origin             'ObjTknGet'         PASSED!\n");
} else
TraceMsg (0, "  Origin             'ObjTknGet'         FAILED!\n");
if (Normal(*Status))
Attr0_ArrayActivate
(&RefTkn,   Points_Attr,
McStat,   &NumPoints,
&UnitSize, (addrtype *)&Ref0.Points);
if (IsActive)
{
if (*Status  == Attr_ImageIsActive)
{
if (TestBug)
TraceMsg (0,
"  Points             'ArrayActivate'     PASSED!\n");
*Status   = Env_Normal;
Attr_ValueGet   (&RefTkn,   Points_Attr,
McStat,    (addrtype )&Ref0.Points);
} else
TraceMsg (0,
"  Points             'ArrayActivate'     FAILED!\n");
} else if (Normal(*Status)) {
if (TestBug)
TraceMsg (0, "  Points             'ArrayActivate'     PASSED!\n");
} else
TraceMsg (0, "  Points             'ArrayActivate'     FAILED!\n");
if (Normal(*Status))
if (Attr_ValueGet     (&RefTkn,   IsActive_Attr,
McStat,    (addrtype )&Ref0.IsActive))
if (IsActive)
{
if (Attr_ValueGet  (&RefTkn,   Byte_Array_Attr,
McStat,   (addrtype *)&Ref0.Byte_Array))
Attr_ArrayGetSize (&RefTkn,   Byte_Array_Attr,
McStat,   &UnitCount,      &UnitSize);
} else
Attr0_ArrayActivate
(&RefTkn,   Byte_Array_Attr,
McStat,   &UnitCount,      &UnitSize,
(addrtype *)&Ref0.Byte_Array);
if (UnitCount      != NumBytes
||  UnitSize       != sizeof (bytetype))
TraceMsg (0, "  Byte_Array         'Array method'      FAILED.\n");
else if (TestBug)
TraceMsg (0, "  Byte_Array         'Array method'      PASSED.\n");
if (Normal(*Status))
if (IsActive)
{
if (Attr_ValueGet  (&RefTkn,   Yarray_Attr,
McStat,   (addrtype *)&Ref0.Yarray))
Attr_ArrayGetSize (&RefTkn,   Yarray_Attr,
McStat,   &UnitCount,      &UnitSize);
} else
Attr0_ArrayActivate
(&RefTkn,   Yarray_Attr,
McStat,   &UnitCount,      &UnitSize,
(addrtype *)&Ref0.Yarray);
if (Normal(*Status))
if (UnitCount      != NumYarrays
||  UnitSize       != sizeof (short))
TraceMsg (0, "  Yarray             'Array method'      FAILED.\n");
else if (TestBug)
TraceMsg (0, "  Yarray             'Array method'      PASSED.\n");
if (Normal(*Status))
if (Attr_ValueGet     (&RefTkn,   xArray07_Attr,
McStat,    (addrtype *)&Ref0.xArray))
if (Ref0.xArray.Vsize    != NumxArrays)
TraceMsg (0, "  xArray             'varray method'     FAILED.\n");
else if (TestBug)
TraceMsg (0, "  xArray             'varray method'     PASSED.\n");
if (Normal(*Status))
if (Attr_ValueGet     (&RefTkn,   Xcoords_Attr,
McStat,    (addrtype *)&Ref0.Xcoords))
if (Ref0.Xcoords.Vsize     != NumXcoords
||  Ref0.Xcoords.VstackPtr != NumXcoords)
TraceMsg (0, "  Xcoords            'vchunk method'     FAILED.\n");
else if (TestBug)
TraceMsg (0, "  Xcoords            'vchunk method'     PASSED.\n");
if (Normal(*Status))
if (Attr_ValueGet     (&RefTkn,   XyDir_Attr,
McStat,    (addrtype )&Ref0.XyDir))
if (Attr_ValueGet     (&RefTkn,   BitMap_Attr,
McStat,    (addrtype )&Ref0.BitMap))
if (Attr_ValueGet     (&RefTkn,   RefOrigin_Attr,
McStat,     (addrtype )&Ref0.RefOrigin))
if (Attr_TokenToRef   (&RefTkn,   RefOrigin_Attr,
McStat,   (addrtype *)&Ref0.RefOrigin.ObjAddr))
if (Attr_ValueGet     (&RefTkn,   VpartsDir_Attr,
McStat,    (addrtype )&Ref0.VpartsDir))
if (Normal(*Status))
if (TestBug)
{
TraceMsg (0, "\n Display contents of RefOrigin Object ...\n");
Object_Dump          (&OriginTkn);
TraceMsg (0, " Display contents of 'Pseudo'  Object Ref0...\n");
Image_DumpPseudo     (&LibTkn000,       TestObj_Class,
(addrtype  )&Ref0);
}
if (Normal(*Status))
if (IsActive)
{
if (TestBug)
TraceMsg (0, "\n  FREE TestObj (and sub-structs) to DB.\n");
if (LibTkn000.DbId != PrimalTkn.DbId)
if (Object_FreeImage  (&RefTkn,        McStat))
Object_FreeImage  (&OriginTkn,     McStat);
} else if (Option == 10) {
if (TestBug)
TraceMsg (0, "\n  FREE StrCpy's and 'delete' Arrays(to DB).\n");
if (Attr_StrCpyFree
(McStat,   &Char_Array))
if (TestBug)
TraceMsg (0, "       StrCpy   Char_Array      Freeed.\n");
if (Normal(*Status))
if (Attr0_ArrayDeActivate
(&RefTkn,   Xarray_Attr,        dbCommit,
McStat))
if (TestBug)
TraceMsg (0, "       Array    Xarray          Committed\n");
if (Normal(*Status))
if (Attr0_ArrayDeActivate
(&RefTkn,   XyCoords_Attr,      dbFree,
McStat))
if (TestBug)
TraceMsg (0, "       Array    XyCoords        Freeed\n");
if (Normal(*Status))
if (Attr0_ArrayDeActivate
(&RefTkn,   Points_Attr,        dbFree,
McStat))
if (TestBug)
TraceMsg (0, "       Array    Points          Freeed\n");
if (Normal(*Status))
if (Attr0_ArrayDeActivate
(&RefTkn,   Byte_Array_Attr,    dbFree,
McStat))
if (TestBug)
TraceMsg (0, "       Array    Byte_Array      Freeed\n");
if (Normal(*Status))
if (Attr0_ArrayDeActivate
(&RefTkn,   Yarray_Attr,        dbFree,
McStat))
if (TestBug)
TraceMsg (0, "       Array    Yarray          Freeed\n");
}
}
}
if (Normal(*Status))
{
if (IsActive)
{
ref0   = NullPtr;
Object_GetImage (&RefTkn,     McStat,  (addrtype *)&ref0);
StrPtrs  = NullPtr;
if (TestBug)
Object_Dump          (&RefTkn);
}
if (Normal(*Status))
if (TestBug)
TraceMsg (0, "\n   Assert New Size of Char_Ptr_Array.\n");
#ifdef __BAD_CODE__
if (Normal(*Status))
if (Attr_ArrayAssertSize
(&RefTkn,   Char_PtrArray_Array_Attr,
NumNewNames,
McStat,           (addrtype *)&StrPtrs))
if (TestBug)
if (TraceMsg (0, "     Char_PtrArray_Array Expanded.\n"))
if (TraceMsg (0, "   ReAssert Size of Char_PtrArray_Array[0:9].\n"))
TraceMsg (0, "            And Assign New set of Names.\n");
for (j= -1; Normal(*Status) && ++j < NumNewNames; )
{
if (Attr_SubArrayAssertSize
(&RefTkn,   Char_PtrArray_Array_Attr,   j,
sizeof (nametype),
McStat,           (addrtype *)&StrAddr))
{
strcpy (StrAddr, NewNames[j]);
sprintf (Msg, "     Char_PtrArray_Array[%2u] = %s.\n",
j, NewNames[j]);
if (TestBug)
TraceMsg (0, Msg);
}
}
if (Normal(*Status))
{
if (TestBug)
TraceMsg (0, "  Char_PtrArray_Array  'resize of'       PASSED.\n");
} else
TraceMsg (0, "  Char_PtrArray_Array  'resize of'       FAILED.\n");
#endif
if (Normal(*Status))
if (TestBug)
TraceMsg (0, "\n   Delete XyCoords[0] SubArray.\n");
if (Normal(*Status))
Attr_SubArrayDelete
(&RefTkn,   XyCoords_Attr,  0,  McStat);
if (Normal(*Status))
if (IsActive)
{
if (ref0->XyCoords[0] != NullPtr)
TraceMsg (0, "  XyCoords           'SubArrayDelete'    FAILED.\n");
else if (TestBug)
TraceMsg (0, "  XyCoords           'SubArrayDelete'    PASSED.\n");
} else {
if (Attr0_ArrayActivate
(&RefTkn,   XyCoords_Attr,
McStat,   &UnitCount,      &UnitSize,
(addrtype *)&XyCoordPtrs))
{
if (XyCoordPtrs[0] != NullPtr)
TraceMsg (0,
"  XyCoords           'SubArrayDelete'    FAILED.\n");
else if (TestBug)
TraceMsg (0,
"  XyCoords           'SubArrayDelete'    PASSED.\n");
} else
TraceMsg (0, "  XyCoords           'SubArrayDelete'    FAILED.\n");
}
if (Normal(*Status))
if (TestBug)
TraceMsg (0, "\n   Delete Byte_Array   Array.\n");
if (Normal(*Status))
Attr_ArrayDelete  (&RefTkn,   Byte_Array_Attr,    McStat);
if (Normal(*Status))
if (Attr_ValueGet     (&RefTkn,   Byte_Array_Attr,
McStat,    (addrtype )&Bytes))
if (Bytes  != NullPtr)
if (IsActive)
{
if (TestBug)
TraceMsg (0, "  Byte_Array         'SubArrayDelete'    PASSED.\n");
} else
TraceMsg (0, "  Byte_Array         'SubArrayDelete'    FAILED.\n");
else if (TestBug)
TraceMsg (0, "  Byte_Array         'SubArrayDelete'    PASSED.\n");
if (Normal(*Status))
if (IsActive)
{
if (TestBug)
TraceMsg (0, "\n Commit Object with ReSized Arrays...\n");
Object_CommitImage (&RefTkn,   True,       McStat);
}
if (Normal(*Status))
if (TestBug)
{
TraceMsg (0, "\n Display contents of Revised Object Arrays...\n");
Object_Dump          (&RefTkn);
}
}
sprintf  (Msg, "\n END of GETs and PUTs TEST... IsActive = %s.\n\n",
BoolStr[IsActive]);
if (TestBug)
TraceMsg (0, Msg);
if (Normal(*Status))
if (Env_DeleteFieldStruc    (McStat,  &LinkField0))
if (Env_DeleteFieldStruc    (McStat,  &LinkField1))
Env_DeleteFieldStruc    (McStat,  &LinkField2);
TRACK(TrackBak,"Draw701\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\tm.c*/

#define TM
#ifdef __MACROIZE_HM__
#endif




boolean    TmNewCoreDb  (tokentype    *Anchor,
ft F,lt Z,zz *Status,   dbheader  **CoreDb)
{
if (Core_MoreCore (sizeof(dbheader), McStat, *(addrtype **)CoreDb))
CoreDbs[Anchor->DbId] = *CoreDb;
TRACK(TrackBak,"TmNewCoreDb\n");
return (STAT);
}
boolean    TmRenvToken    (ft F,lt Z,zz *Status,   tokentype *RenvToken)
{
RenvToken->Handle   = RenvTkn.Handle;
RenvToken->DbId     = RenvTkn.DbId;
RenvToken->CoreDbId = RenvTkn.DbId;
return (STAT);
}
boolean    TmWenvToken    (ft F,lt Z,zz *Status,   tokentype *WenvToken)
{
WenvToken->Handle   = WenvTkn.Handle;
WenvToken->DbId     = WenvTkn.DbId;
WenvToken->CoreDbId = WenvTkn.DbId;
return (STAT);
}
boolean    TmFetchCoreDb  (tokentype    *Anchor,
ft F,lt Z,zz *Status,   dbheader  **CoreDb)
{
char  DbName[MAXNAME];
DbName[0] = '\0';
if (Anchor->DbId <= MaxCoreDbId)
{
if ((*CoreDb  = CoreDbs[Anchor->DbId]) == NullPtr)
{
sprintf  (Msg, "      TmFetchCoreDb[%2u] \n", Anchor->DbId);
TraceMsg (0,   Msg);
Dbm_LoadDb  (Anchor,   McStat,   DbName,  &CoreDbs[Anchor->DbId]);
*CoreDb    = CoreDbs[Anchor->DbId];
if (*CoreDb == NullPtr)
{
sprintf  (Msg, "   NULL COREDB for DbId = %2u\n", Anchor->DbId);
TraceMsg (0, Msg);
*Status = Tm_NullDb;
} else
CoreDbs[Anchor->DbId] = *CoreDb;
}
if (!Anchor->DbId)
*Status = Tm_NullDb;
} else {
*Status = Tm_DbIdOutOfRange;
SendMsg (0, " ***ERROR... DbId Out of Range!\n");
sprintf (Msg, "   @TmFetchCoreDb... MaxCoreDbId=%3u; DbId=%4u\n",
MaxCoreDbId, Anchor->DbId);
TraceMsg (0, Msg);
}
if (!Normal(*Status) || DeBug >= 1)
if (sprintf (Msg, "      TmFetchCoreDb[%2u] @ %x\n",
Anchor->DbId, *CoreDb))
TraceMsg (0, Msg);
TRACK(TrackBak,"TmFetchCoreDb\n");
return (STAT);
}
boolean    TmMakeToken  (tokentype    *Anchor,  indextype  Handle,
ft F,lt Z,zz *Status,  tokentype *Token)
{
Token->Handle   = Handle;
Token->DbId     = Anchor->DbId;
Token->CoreDbId = Anchor->CoreDbId;
TRACK(TrackBak,"TmMakeToken\n");
return (STAT);
}
boolean    TmIsValid    (tokentype    *Token,   ft F,lt Z,zz *Status)
{
dbheader   *CoreDb     = NullPtr;
numtype     LocalObj   = 0;
if (Token->DbId   == 0
||  Token->Handle == 0)
return(False);
if (TmFetchCoreDb    (Token,                  McStat,     &CoreDb))
if (HmGetLocalObjNum (CoreDb, Token->Handle,  McStat,     &LocalObj))
if (LocalObj == Null_ObjNum)
return(False);
TRACK(TrackBak,"TmIsValid\n");
return (STAT);
}
boolean    TmGetObject   (tokentype    *Token,
ft F,lt Z,zz *Status,   addrtype   *Object)
{
dbheader   *CoreDb  = NullPtr;
if (TmFetchCoreDb  (Token,   McStat,        &CoreDb))
if (Normal(*Status))
HmFetchDbObject (CoreDb,  Token->Handle,  McStat,  Object);
if (*Status == Hm_ObjectNotPaired)
*Status  = Tm_ObjectNotPaired;
TRACK(TrackBak,"TmGetObject\n");
return (STAT);
}
boolean    TmFreeToken  (ft F,lt Z,zz *Status,    tokentype *Token)
{
dbheader   *CoreDb  = NullPtr;
if (TmFetchCoreDb (Token,   McStat,  &CoreDb))
HmFreeHandle  (CoreDb, Token->Handle, McStat);
if (!Normal(*Status) || DeBug)
{
sprintf  (Msg, "  TM_Free TOKEN[ %2u : %4u]\n",
Token->DbId, Token->Handle);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"TmFreeToken\n");
return (STAT);
}
boolean    TmReclaimHandles  (tokentype *Token, ft F,lt Z,zz *Status )
{
dbheader   *CoreDb  = NullPtr;
if (TmFetchCoreDb (Token,   McStat,  &CoreDb))
HmReclaimHandles  (CoreDb, McStat);
TRACK(TrackBak,"TmReclaimHandles\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\trans00.c*/

#define  TRANS00
/* 当前文件是./CINT2000\255.vortex\src\vom.h*/

#ifndef VOM_H
#define VOM_H
boolean OmNewVchunk
(tokentype    *Anchor,    sizetype      UnitSize,
indextype     UnitCount, indextype     ExtendQty,
ft F,lt Z,zz *Status,
indextype    *Vchunk,    addrtype     *ChunkAddr);
boolean OmGetVchunkToken
(tokentype    *Token,     ft F,lt Z,zz *Status,
vchunktkntype           *VchunkToken);
boolean OmGetVchunkStruc
(tokentype    *Token,     ft F,lt Z,zz *Status,
chunkstruc   *VchunkStruc);
boolean OmDeleteVchunk
(tokentype    *Token,     ft F,lt Z,zz *Status);
#endif
#ifndef INLINE_OMIDEFS
#else
#define        Image01_ObjNum       (objnumtype )142
#define        That_AttrNum           (numtype )1
#define        Token_Attr             (numtype )2
#define        Handle_AttrNum         (numtype )2
#define        DbId_AttrNum           (numtype )3
#define        CoreDbId_AttrNum       (numtype )4
#define        AttrNum_AttrNum        (numtype )9
#define        RenvAttrs_Hndl         (handletype )677
#endif
#define MemMakeChunk       Mem_MakeChunk
#define MemPutStackPtr     Mem_PutStackPtr
#define MemGetStackPtr     Mem_GetStackPtr
#define MemGetChunkAddr    Mem_GetChunkAddr
#define MemPutAddr         Mem_PutAddr
#define MemGetAddr         Mem_GetAddr
#define MemPushSomeBytes   Mem_PushSomeBytes
#define MemGetSomeBytes    Mem_GetSomeBytes
#define MemPushFieldNum    Mem_PushWord
#define MemGetFieldNum     Mem_GetWord
#define MemGetObjNum       Mem_GetWord
#define MemGetLocalObjNum  Mem_GetWord



static boolean   ImageMapInvoked       = False;
boolean TransInitMap      (numtype       ClassId, size_t        ObjSize,
numtype       AplId,   ft F,lt Z,zz *Status)
{
fieldtoken     FieldTkn;
indextype      StackPtr         = 0;
tokentype      ObjToken         = NullToken;
objdesctype   *ObjDesc          = NullPtr;
typesize       ClassSize        = 0;
indextype      FieldCount       = 0;
tokentype      VfieldsTkn       = NullToken;
objnumtype    *Vfields          = NullPtr;
boolean        ClassMapExists   = False;
imagemaptype   ImageMap;
maparraystype *MapArraysAddr    = NullPtr;
ImageMapInvoked   = False;
VfieldsTkn.DbId   = RenvId;
ObjToken.DbId     = RenvId;
FieldTkn.Index    = ClassId;
FieldTkn.Offset   = ObjSize;
if (Normal(*Status))
if (C_ObjMapDir   == 0
||  C_ImageMapDir == 0)
TransCreateMapDirs(AplId,  McStat,  &C_ObjMapDir,   &C_ImageMapDir);
if (Normal(*Status))
MemGetAddr        (C_ObjMapDir,      ClassId,
McStat,              (addrtype *)&MapArraysAddr);
if (MapArraysAddr)
{
if (ClassBug)
TraceMsg (0,
" Object Class for C_Image already loaded!.\n");
return(False);
}
if (Normal(*Status))
{
if (EnvFetchObjHandle (ClassId,       McStat,  &ObjToken.Handle))
if (EnvFetchObjSize   (ClassId,       McStat,  &ObjSize))
if (ClassBug || OaBug || DeBug)
if (sprintf (Msg, "  C_TransInvokeMap :: ObjNum= %2u; ClassSize= %3u;\n",
ClassId, ClassSize))
TraceMsg (0, Msg);
if (Normal(*Status))
if (OaGetObject         (&ObjToken,      McStat, (addrtype *)&ObjDesc))
VfieldsTkn.Handle  = ObjDesc->Fields;
if (Normal(*Status))
if (OaGetVchunkAddr     (&VfieldsTkn,    McStat, (addrtype *)&Vfields))
OaGetVchunkStackPtr (&VfieldsTkn,    McStat,           &FieldCount);
}
if (Normal(*Status))
if (MapArraysAddr == NullPtr)
{
TransNewImageMap     (C_ObjMapDir,     C_ImageMapDir,   ClassId,
FieldCount,      McStat,
&ClassMapExists, &ImageMap,       &MapArraysAddr);
ClassMapExists      = False;
} else {
TransNewImageMap     (C_ObjMapDir,     C_ImageMapDir,   ClassId,
FieldCount,      McStat,
&ClassMapExists, &ImageMap,       &MapArraysAddr);
if (ClassMapExists     !=  True)
{
TraceMsg (0, "\n ***ERROR*** ImageMap should already exist\n");
*Status   = Err_BadDesign;
}
}
if (Normal(*Status))
if (ClassMapExists)
{
ImageMapInvoked = True;
TraceMsg (0, " Object Class for C_Image Loaded from Disk!\n");
return(STAT);
}
if (Normal(*Status))
if (ObjClassMap  == 0)
MemMakeChunk     (sizeof (fieldtoken),    50,            10,
RenvId,                 McStat,       &ObjClassMap);
if (Normal(*Status))
if (MemPutStackPtr   (ObjClassMap,            0,             McStat))
if (MemPushSomeBytes (ObjClassMap,            sizeof (fieldtoken),
(addrtype )&FieldTkn,   McStat,       &StackPtr))
if (EnvFetchObjHandle (ClassId,     McStat,    &ObjToken.Handle))
if (OaGetObject       (&ObjToken,   McStat,    (addrtype *)&ObjDesc))
ObjDesc->PsudoSize   = ObjSize;
TRACK(TrackBak,"TransInitClassMap\n");
return (STAT);
}
boolean TransAppendToMap  (numtype       AttrId,  size_t        Offset,
numtype       AplId,   ft F,lt Z,zz *Status)
{
fieldtoken  FieldTkn;
indextype   StackPtr  = 0;
if (ImageMapInvoked == True)
return(STAT);
FieldTkn.Index      = AttrId;
FieldTkn.Offset     = Offset;
if (AttrId         == Token_Attr)
{
FieldTkn.Index   = Handle_AttrNum;
FieldTkn.Offset  = Offset;
MemPushSomeBytes     (ObjClassMap,            sizeof (fieldtoken),
(addrtype )&FieldTkn,   McStat,       &StackPtr);
Offset          += sizeof (handletype);
FieldTkn.Index   = DbId_AttrNum;
FieldTkn.Offset  = Offset;
if (Normal(*Status))
MemPushSomeBytes (ObjClassMap,            sizeof (fieldtoken),
(addrtype )&FieldTkn,   McStat,       &StackPtr);
Offset          += sizeof (idtype);
FieldTkn.Index   = CoreDbId_AttrNum;
FieldTkn.Offset  = Offset;
}
if (Normal(*Status))
MemPushSomeBytes    (ObjClassMap,            sizeof (fieldtoken),
(addrtype )&FieldTkn,   McStat,       &StackPtr);
TRACK(TrackBak,"TransAppendToMap\n");
return (STAT);
}
boolean    TransInvokeMap  (numtype       AplId,       ft F,lt Z,zz *Status)
{
tokentype      ObjToken;
handletype     MapAttrCount     = 0;
fieldtoken    *FieldTknMap      = NullPtr;
numtype        AttrNum          = 0;
indextype      AttrCount        = 0;
typeunsize     Offset           = 0;
numtype        ObjNum           = 0;
typesize       ClassSize        = 0;
int            Adjust           = 0;
int            Increment        = 0;
objdesctype   *ObjDesc          = NullPtr;
tokentype      VclasssTkn;
tokentype      VoffsetsTkn;
tokentype      VfieldsTkn;
indextype      FieldCount       = 0;
booleantype    AttrFound        = False;
objnumtype    *Vclasss          = NullPtr;
typeunsize    *Voffsets         = NullPtr;
objnumtype    *Vfields          = NullPtr;
indextype      Vindex           = 0;
tokentype      AttrTkn;
attrdesctype  *EnvAttr          = NullPtr;
tokentype      TypeTkn          = NullToken;
typedesctype  *EnvType          = NullPtr;
tokentype      BldDescTkn       = NullToken;
objdesctype   *BldDesc          = NullPtr;
int            i                = -1;
indextype      StackPtr         = 0;
boolean        FillOffsets      = False;
fieldtoken     FieldTkn;
typeunsize     Null_Offset      = -1;
if (ImageMapInvoked == True)
return(STAT);
ObjToken.DbId         = RenvId;
VclasssTkn.DbId       = RenvId;
VoffsetsTkn.DbId      = RenvId;
VfieldsTkn.DbId       = RenvId;
AttrTkn.DbId          = RenvId;
TypeTkn.DbId          = RenvId;
BldDescTkn.DbId       = RenvId;
if (MemGetStackPtr      (ObjClassMap,    McStat,              &MapAttrCount))
if (MemGetChunkAddr     (ObjClassMap,    McStat,  (addrtype *)&FieldTknMap))
if (MapAttrCount)
{
ObjNum      = FieldTknMap[0].Index;
ClassSize   = FieldTknMap[0].Offset;
EnvFetchObjHandle (ObjNum,  McStat,  &ObjToken.Handle);
if (ClassBug || OaBug || DeBug)
if (sprintf (Msg, "  TransInvokeMap :: ObjNum= %2u; ClassSize= %3u;\n",
ObjNum, ClassSize))
if (TraceMsg (0, Msg))
if (OaBug || DeBug)
OaDumpObject (0, &ObjToken,  McStat);
if (MapAttrCount == 1)
if (MemPutStackPtr   (ObjClassMap,    FieldCount+2, McStat))
if (MemPutStackPtr   (ObjClassMap,    1,            McStat))
if (MemGetChunkAddr  (ObjClassMap,    McStat,  (addrtype *)&FieldTknMap))
FillOffsets    = True;
} else
*Status = Trans_NullMap;
if (Normal(*Status))
if (OaGetObject (&ObjToken,   McStat,     (addrtype *)&ObjDesc))
{
VclasssTkn.Handle   = ObjDesc->ClassFields;
VoffsetsTkn.Handle  = ObjDesc->ClassOffsets;
VfieldsTkn.Handle   = ObjDesc->Fields;
}
if (Normal(*Status))
if (OaGetVchunkAddr     (&VfieldsTkn,    McStat,  (addrtype *)&Vfields))
if (OaGetVchunkStackPtr (&VfieldsTkn,    McStat,              &FieldCount))
if (OaPutVchunkStackPtr (&VclasssTkn,    FieldCount,           McStat))
if (OaPutVchunkStackPtr (&VoffsetsTkn,   FieldCount+1,         McStat))
if (OaGetVchunkAddr     (&VclasssTkn,    McStat,  (addrtype *)&Vclasss))
OaGetVchunkAddr     (&VoffsetsTkn,   McStat,  (addrtype *)&Voffsets);
if (Normal(*Status))
{
Offset   = 0;
Adjust   = 0;
i = 0;
while (Normal(*Status)
&&     i < FieldCount)
{
if (FillOffsets)
{
++MapAttrCount;
FieldTkn.Index        = Vclasss[i];
if (EnvFetchAttrHandle (Vclasss[i], McStat,  &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,   McStat,  (addrtype *)&EnvAttr))
TypeTkn.Handle    = EnvAttr->TypeObj;
if (Normal(*Status))
if (OaGetObject        (&TypeTkn,   McStat,  (addrtype *)&EnvType))
{
	     if ( EnvType->TypeType == aAddr )
EnvType->Size = sizeof( addrtype ) ;
EnvAlignMember     (EnvAttr->AttrType,     EnvType->TypeType,
EnvType->Size, (sizetype *)&Offset);
FieldTkn.Offset   = Offset;
if (EnvAttr->AttrType  == aVarrayAttr
||  EnvAttr->AttrType  == aArrayAttr
||  EnvAttr->AttrType  == aDblPtrAttr
||  EnvAttr->AttrType  == aChunkAttr
||  EnvAttr->AttrType  == aStrHndlAttr
||  EnvAttr->AttrType  == aObjRefAttr
||  EnvAttr->AttrType  == aTknRefAttr)
{
Ut_AlignMember   (aAddr,   sizeof (addrtype), &FieldTkn.Offset);
Offset =  FieldTkn.Offset;
}
MemPushSomeBytes   (ObjClassMap,            sizeof (fieldtoken),
(addrtype )&FieldTkn,   McStat,  &StackPtr);
}
if (Normal(*Status))
{
switch (EnvAttr->AttrType)
{
case aObjRefAttr  :
case aDblPtrAttr  :
case aArrayAttr   :
Increment  = sizeof  (addrtype)   *  EnvAttr->UnitSize;
break;
case aGrpAttr     :
case aVgrpAttr    :
Increment  = sizeof  (tokentype)  *  EnvAttr->UnitSize;
break;
case aTknRefAttr  :
Increment  = sizeof  (RefObj)     *  EnvAttr->UnitSize;
break;
case aChunkAttr  :
Increment  = sizeof  (vchunktype) *  EnvAttr->UnitSize;
break;
case aVarrayAttr  :
Increment  = sizeof  (varraytype) *  EnvAttr->UnitSize;
break;
case aMapRefAttr  :
BldDescTkn.Handle  = EnvAttr->BuildDesc;
if (OaGetObject    (&BldDescTkn,
McStat,       (addrtype *)&BldDesc))
Increment = BldDesc->ObjSize   *  EnvAttr->UnitSize;
break;
case aStrHndlAttr :
Increment    = sizeof (addrtype)  *  EnvAttr->UnitSize;
break;
default           :
Increment    = EnvType->Size      *  EnvAttr->UnitSize;
break;
}
Offset    += Increment;
Adjust    += Increment;
}
}
i++;
}
}
if (Normal(*Status))
ObjDesc->PsudoSize   = ClassSize;
TRACK(TrackBak,"TransInvokeMap\n");
return(STAT);
}
boolean    TransBuildMap  (numtype       AplId,       ft F,lt Z,zz *Status)
{
tokentype      ObjToken         = NullToken;
objdesctype   *ObjDesc          = NullPtr;
handletype     MapAttrCount     = 0;
fieldtoken    *FieldTknMap      = NullPtr;
numtype        ObjNum           = 0;
typesize       ClassSize        = 0;
tokentype      VfieldsTkn       = NullToken;
objnumtype    *Vfields          = NullPtr;
indextype      FieldCount       = 0;
typesize       ObjSize          = 0;
boolean        ClassMapExists   = False;
boolean        ClassImageExists = False;
imagemaptype   ImageMap;
maparraystype *MapArraysAddr    = NullPtr;
if (ImageMapInvoked == True)
{
ImageMapInvoked = False;
return(STAT);
}
OverRideInitClass     = True;
ObjToken.DbId         = RenvId;
VfieldsTkn.DbId       = RenvId;
if (Normal(*Status))
if (MemGetStackPtr      (ObjClassMap,  McStat,              &MapAttrCount))
if (MemGetChunkAddr     (ObjClassMap,  McStat,  (addrtype *)&FieldTknMap))
if (MapAttrCount)
{
ObjNum      = FieldTknMap[0].Index;
ClassSize   = FieldTknMap[0].Offset;
} else
*Status = Trans_NullMap;
if (Normal(*Status))
if (C_ObjMapDir   == 0
||  C_ImageMapDir == 0)
TransCreateMapDirs(AplId,  McStat,  &C_ObjMapDir,   &C_ImageMapDir);
if (Normal(*Status))
MemGetAddr        (C_ObjMapDir,      ObjNum,
McStat,              (addrtype *)&MapArraysAddr);
if (MapArraysAddr)
if (!OverRideInitClass)
return(STAT);
if (Normal(*Status))
{
if (EnvFetchObjHandle (ObjNum,        McStat,  &ObjToken.Handle))
if (EnvFetchObjSize   (ObjNum,        McStat,  &ObjSize))
if (OaGetObject         (&ObjToken,      McStat,  (addrtype *)&ObjDesc))
VfieldsTkn.Handle  = ObjDesc->Fields;
if (Normal(*Status))
if (OaGetVchunkAddr     (&VfieldsTkn,    McStat,  (addrtype *)&Vfields))
OaGetVchunkStackPtr (&VfieldsTkn,    McStat,              &FieldCount);
}
if (Normal(*Status))
if (MapArraysAddr == NullPtr)
{
TransNewImageMap       (C_ObjMapDir,     C_ImageMapDir,   ObjNum,
FieldCount,      McStat,
&ClassMapExists, &ImageMap,       &MapArraysAddr);
ClassMapExists        = False;
} else {
TransNewImageMap       (C_ObjMapDir,     C_ImageMapDir,   ObjNum,
FieldCount,      McStat,
&ClassMapExists, &ImageMap,       &MapArraysAddr);
if (ClassMapExists     !=  True)
{
TraceMsg (0, "\n ***ERROR*** ImageMap should already exist\n");
*Status   = Err_BadDesign;
}
}
if (Normal(*Status))
if (ClassMapExists)
if (!OverRideInitClass)
{
TraceMsg (0, " Object Class for C_Image Loaded from Disk!\n");
return(STAT);
}
if (Normal(*Status))
{
MapArraysAddr->CppOffsets[0]    = (typesize )ClassSize;
if (ClassSize != ObjSize)
MapArraysAddr->DbOffsets[0] = False;
else
MapArraysAddr->DbOffsets[0] = True;
}
if (Normal(*Status))
TransBuildFields  (MapAttrCount,  FieldTknMap, Vfields,       FieldCount,
ObjDesc->Nam, &ImageMap,    MapArraysAddr, McStat);
TRACK(TrackBak,"TransBuildMap\n");
return(STAT);
}
boolean TransGetMap     (numtype       ObjNum,    numtype       AplId,
ft F,lt Z,zz *Status,    classmaptype *ClassMap)
{
addrtype   *FieldMap       = NullPtr;
typesize    ObjSize        = 0;
if (Normal(*Status))
if (MemGetAddr        (C_ObjMapDir,                          ObjNum,
McStat,                  (addrtype *)&FieldMap))
if (EnvFetchObjSize   (ObjNum,        McStat,               &ObjSize))
if (FieldMap)
{
ClassMap->DbOffsets      =  (typesize *)FieldMap[0];
ClassMap->CppOffsets     =  (typesize *)FieldMap[1];
ClassMap->FieldSizes     =  (typesize *)FieldMap[2];
ClassMap->FieldAttrTypes =  (attrtype *)FieldMap[3];
ClassMap->FieldAttrIds   =  (numtype  *)FieldMap[4];
ClassMap->RefObjNums     =  (numtype  *)FieldMap[5];
ClassMap->ArrayAttrs     =  (numtype  *)FieldMap[6];
ClassMap->FieldTypeTypes =  (typetype *)FieldMap[7];
ClassMap->ObjNum         =  ObjNum;
ClassMap->NumMapFields   =  (indextype )ClassMap->RefObjNums[0];
ClassMap->NumArrayAttrs  =  (indextype )ClassMap->ArrayAttrs[0];
ClassMap->ClassSize      =  ObjSize;
ClassMap->ImageSize      =  (typesize  )ClassMap->CppOffsets[0];
ClassMap->PureDbStruc    =  (boolean   )ClassMap->DbOffsets[0];
ClassMap->ThatIndex      =  (typesize  )ClassMap->FieldTypeTypes[0];
} else
*Status = Trans_NullMap;
TRACK(TrackBak,"TransGetMap\n");
return(STAT);
}
boolean Trans_DumpMap   (numtype       ObjNum,    numtype       AplId,
ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"Trans_DumpMap\n");
return(STAT);
}
boolean Trans_MapIsActive
(numtype       ObjNum,      ft F,lt Z,zz *Status)
{
addrtype   *FieldMap       = NullPtr;
if (Normal(*Status))
if (MemGetAddr        (C_ObjMapDir,                          ObjNum,
McStat,                  (addrtype *)&FieldMap))
if (FieldMap == NullPtr)
return(False);
TRACK(TrackBak,"Trans_MapIsActive\n");
return(STAT);
}
boolean    TransCreateMapDirs
(numtype       AplId,       ft F,lt Z,zz *Status,
numtype      *ObjMapDir,   numtype      *ImageMapDir)
{
static char   *AttrName        = "C_ImageMapDir";
tokentype      AttrTkn         = NullToken;
vchunktkntype  VchunkToken;
if (Normal(*Status))
if (*ObjMapDir == 0)
{
if (MemMakeChunk    (sizeof (addrtype),      CoreDb0->LastEnvObjCount+1,
Extend_DbObjNums,       RenvId,
McStat,                 ObjMapDir))
MemPutStackPtr  (*ObjMapDir,             CoreDb0->LastEnvObjCount+1,
McStat);
}
if (Normal(*Status))
if (*ImageMapDir      == 0)
{
ImageMapTkn.DbId    = WenvId;
if (!KernelFindIn    (RenvAttrs_Hndl,                &RenvTkn,
(addrtype )AttrName,
McStat,          (tokentype *)&AttrTkn))
TraceMsg (0, "  Error... Attr C_ImageMapDir_AttrNum Not in Renv\n");
if (Normal(*Status))
if (KernelGetAttr    (&AttrTkn,                    AttrNum_AttrNum,
McStat,  (addrtype   )&C_ImageMapDir_AttrNum))
if (KernelGetAttr     (&WenvTkn,                    C_ImageMapDir_AttrNum,
McStat,          (addrtype )&ImageMapTkn.Handle))
if (ImageMapTkn.Handle == 0)
if (OaCreateVchunk    (&WenvTkn,  sizeof (imagemaptype),
CoreDb0->LastEnvObjCount + 1 - Image01_ObjNum,
100,        McStat,         &ImageMapTkn))
if (OaPutVchunkStackPtr
(&ImageMapTkn,
CoreDb0->LastEnvObjCount + 1 - Image01_ObjNum,
McStat))
if (KernelPutAttr     (&WenvTkn,                    C_ImageMapDir_AttrNum,
(addrtype )&ImageMapTkn.Handle,   McStat))
if (ClassBug || OaBug || DeBug)
TraceMsg (0, "  ImageMap Vchunk Created;\n");
if (Normal(*Status))
if (OmGetVchunkToken   (&ImageMapTkn, McStat, &VchunkToken))
*ImageMapDir   = VchunkToken.InCore;
}
TRACK(TrackBak,"TransCreateMapDirs\n");
return(STAT);
}
boolean    TransNewImageMap
(numtype       ObjMapDir,  numtype         ImageMapDir,
numtype       ObjNum,     numtype         FieldCount,
ft F,lt Z,zz *Status,     boolean        *MapExists,
imagemaptype *ImageMap,   maparraystype **FieldsDir)
{
numtype        FieldsDirChunk   = 0;
tokentype      DbOffsetTkn      = NullToken;
typesize      *DbOffsets        = NullPtr;
tokentype      CppOffsetTkn     = NullToken;
typesize      *CppOffsets       = NullPtr;
tokentype      FieldSizeTkn     = NullToken;
typesize      *FieldSizes       = NullPtr;
tokentype      FieldTypeTkn     = NullToken;
attrtype      *FieldTypes       = NullPtr;
tokentype      TypeTypeTkn      = NullToken;
typetype      *TypeTypes        = NullPtr;
tokentype      FieldAttrTkn     = NullToken;
numtype       *FieldAttrs       = NullPtr;
tokentype      RefObjNumTkn     = NullToken;
numtype       *RefObjNums       = NullPtr;
tokentype      ArrayAttrTkn     = NullToken;
numtype       *ArrayAttrs       = NullPtr;
*MapExists    =  False;
if (MemMakeChunk      (sizeof (addrtype), 8,
0,                 WenvId,
McStat,                              &FieldsDirChunk))
if (MemPutStackPtr    (FieldsDirChunk,    8,                   McStat))
if (MemGetChunkAddr   (FieldsDirChunk,    McStat,  (addrtype *)FieldsDir))
MemPutAddr        (ObjMapDir,         ObjNum, *(addrtype *)FieldsDir,
McStat);
if (Normal(*Status))
if (MemGetSomeBytes   (ImageMapDir,                     V(ObjNum),
sizeof(imagemaptype),
McStat,               (addrtype )ImageMap))
if (ImageMap->DbOffsetsHndl)
{
*MapExists    =  True;
if (OaGetUnit (&ImageMapTkn,  V(ObjNum), McStat,  (addrtype )ImageMap))
{
DbOffsetTkn.DbId    =  WenvId;
DbOffsetTkn.Handle  =  ImageMap->DbOffsetsHndl;
CppOffsetTkn.DbId   =  WenvId;
CppOffsetTkn.Handle =  ImageMap->CppOffsetsHndl;
FieldAttrTkn.DbId   =  WenvId;
FieldAttrTkn.Handle =  ImageMap->FieldAttrIdsHndl;
FieldTypeTkn.DbId   =  WenvId;
FieldTypeTkn.Handle =  ImageMap->FieldAttrTypesHndl;
TypeTypeTkn.DbId    =  WenvId;
TypeTypeTkn.Handle  =  ImageMap->FieldTypeTypesHndl;
FieldSizeTkn.DbId   =  WenvId;
FieldSizeTkn.Handle =  ImageMap->FieldSizesHndl;
RefObjNumTkn.DbId   =  WenvId;
RefObjNumTkn.Handle =  ImageMap->FieldRefObjNumsHndl;
ArrayAttrTkn.DbId   =  WenvId;
ArrayAttrTkn.Handle =  ImageMap->ArrayAttrsHndl;
}
} else {
if (OaBug || DeBug)
TraceMsg (0, "  Create The ClassMapArrays\n");
if (OaCreateVchunk    (&WenvTkn,   sizeof (typesize),
FieldCount + 30,    10,
McStat,                              &DbOffsetTkn))
if (OaPutVchunkStackPtr
(&DbOffsetTkn,       FieldCount + 29,  McStat))
if (OaCreateVchunk    (&WenvTkn,   sizeof (typesize),
FieldCount + 30,    10,
McStat,                              &CppOffsetTkn  ))
if (OaPutVchunkStackPtr
(&CppOffsetTkn,      FieldCount + 29,  McStat))
if (OaCreateVchunk    (&WenvTkn,   sizeof (typesize),
FieldCount + 30,    10,
McStat,                              &FieldSizeTkn  ))
if (OaPutVchunkStackPtr
(&FieldSizeTkn,      FieldCount + 29,  McStat))
if (OaCreateVchunk    (&WenvTkn,   sizeof (attrtype),
FieldCount + 30,    10,
McStat,                              &FieldTypeTkn  ))
if (OaPutVchunkStackPtr
(&FieldTypeTkn  ,    FieldCount + 29,  McStat))
if (OaCreateVchunk    (&WenvTkn,  sizeof(handletype),
FieldCount + 30,    10,
McStat,                              &FieldAttrTkn  ))
if (OaPutVchunkStackPtr
(&FieldAttrTkn,      FieldCount + 29,  McStat))
if (OaCreateVchunk    (&WenvTkn,  sizeof(handletype),
FieldCount + 30,    10,
McStat,                              &RefObjNumTkn  ))
if (OaPutVchunkStackPtr
(&RefObjNumTkn,      FieldCount + 29,    McStat))
if (OaCreateVchunk    (&WenvTkn,  sizeof(handletype),
FieldCount,         10,
McStat,                              &ArrayAttrTkn  ))
if (OaPutVchunkStackPtr
(&ArrayAttrTkn,      1,          McStat))
if (OaCreateVchunk    (&WenvTkn,  sizeof(handletype),
FieldCount + 30,    10,
McStat,                              &TypeTypeTkn  ))
if (OaPutVchunkStackPtr
(&TypeTypeTkn  ,     FieldCount + 29,  McStat))
{
ImageMap->DbOffsetsHndl        = DbOffsetTkn.Handle;
ImageMap->CppOffsetsHndl       = CppOffsetTkn.Handle;
ImageMap->FieldAttrIdsHndl     = FieldAttrTkn.Handle;
ImageMap->FieldAttrTypesHndl   = FieldTypeTkn.Handle;
ImageMap->FieldTypeTypesHndl   = TypeTypeTkn.Handle;
ImageMap->FieldSizesHndl       = FieldSizeTkn.Handle;
ImageMap->FieldRefObjNumsHndl  = RefObjNumTkn.Handle;
ImageMap->ArrayAttrsHndl       = ArrayAttrTkn.Handle;
OaPutUnit (&ImageMapTkn,  V(ObjNum), (addrtype )ImageMap, McStat);
}
}
if (Normal(*Status))
if (OaGetVchunkAddr   (&DbOffsetTkn  ,     McStat, (addrtype *)&DbOffsets))
if (MemPutAddr        (FieldsDirChunk,     0,
(addrtype )DbOffsets,                    McStat))
if (OaGetVchunkAddr   (&CppOffsetTkn  ,    McStat, (addrtype *)&CppOffsets))
if (MemPutAddr        (FieldsDirChunk,     1,
(addrtype )CppOffsets,                   McStat))
if (OaGetVchunkAddr   (&FieldSizeTkn  ,     McStat, (addrtype *)&FieldSizes))
if (MemPutAddr        (FieldsDirChunk,     2,
(addrtype )FieldSizes,                   McStat))
if (OaGetVchunkAddr   (&FieldTypeTkn  ,     McStat, (addrtype *)&FieldTypes))
if (MemPutAddr        (FieldsDirChunk,     3,
(addrtype )FieldTypes,                   McStat))
if (OaGetVchunkAddr   (&FieldAttrTkn  ,     McStat, (addrtype *)&FieldAttrs))
if (MemPutAddr        (FieldsDirChunk,     4,
(addrtype )FieldAttrs,                   McStat))
if (OaGetVchunkAddr   (&RefObjNumTkn  ,     McStat, (addrtype *)&RefObjNums))
if (MemPutAddr        (FieldsDirChunk,     5,
(addrtype )RefObjNums,                   McStat))
if (OaGetVchunkAddr   (&ArrayAttrTkn  ,     McStat, (addrtype *)&ArrayAttrs))
if (MemPutAddr        (FieldsDirChunk,     6,
(addrtype )ArrayAttrs,                   McStat))
if (OaGetVchunkAddr   (&TypeTypeTkn  ,     McStat, (addrtype *)&TypeTypes))
MemPutAddr        (FieldsDirChunk,     7,
(addrtype )TypeTypes,                    McStat);
if (Normal(*Status))
if (*MapExists == False)
OaPutVchunkStackPtr
(&ArrayAttrTkn  ,    1,                   McStat);
TRACK(TrackBak,"TransNewImageMap\n");
return(STAT);
}
boolean    TransBuildFields
(handletype    MapAttrCount,fieldtoken    *FieldTknMap,
objnumtype   *Vfields,     indextype      FieldCount,
char         *ObjName,
imagemaptype *ImageMap,    maparraystype *ClassMap,
ft F,lt Z,zz *Status)
{
tokentype      DbOffsetTkn      = NullToken;
typesize      *DbOffsets        = NullPtr;
tokentype      CppOffsetTkn     = NullToken;
typesize      *CppOffsets       = NullPtr;
tokentype      FieldSizeTkn     = NullToken;
typesize      *FieldSizes       = NullPtr;
tokentype      FieldTypeTkn     = NullToken;
attrtype      *FieldTypes       = NullPtr;
tokentype      TypeTypeTkn      = NullToken;
typetype      *TypeTypes        = NullPtr;
tokentype      FieldAttrTkn     = NullToken;
numtype       *FieldAttrs       = NullPtr;
tokentype      RefObjNumTkn     = NullToken;
numtype       *RefObjNums       = NullPtr;
tokentype      ArrayAttrTkn     = NullToken;
numtype       *ArrayAttrs       = NullPtr;
indextype      NumMapFields     = 0;
indextype      NumArrayAttrs    = 0;
typesize       CppOffset        = 0;
typesize       TrueCppOffset    = 0;
indextype      DbIndex          = 0;
typesize       DbOffset         = 0;
typesize       TrueDbOffset     = 0;
numtype        AttrNum          = 0;
typesize       FieldSize        = 0;
tokentype      AttrTkn          = NullToken;
attrdesctype  *EnvAttr          = NullPtr;
booleantype    AttrFound        = False;
indextype      CppIndex         = 0;
tokentype      TypeTkn          = NullToken;
typedesctype  *EnvType          = NullPtr;
tokentype      BldDescTkn       = NullToken;
objdesctype   *BuildDesc        = NullPtr;
int            i                = -1;
boolean        PureDbStruc      = True;
boolean        TempBug          = ClassBug;
boolean        HasThatAttr      = False;
boolean        TempClassBug     = ClassBug;
if (Normal(*Status))
{
DbOffsetTkn.DbId    =  WenvId;
DbOffsetTkn.Handle  =  ImageMap->DbOffsetsHndl;
DbOffsets           =  ClassMap->DbOffsets;
PureDbStruc         =  (boolean )ClassMap->DbOffsets[0];
CppOffsetTkn.DbId   =  WenvId;
CppOffsetTkn.Handle =  ImageMap->CppOffsetsHndl;
CppOffsets          =  ClassMap->CppOffsets;
FieldAttrTkn.DbId   =  WenvId;
FieldAttrTkn.Handle =  ImageMap->FieldAttrIdsHndl;
FieldAttrs          =  ClassMap->FieldAttrIds;
FieldTypeTkn.DbId   =  WenvId;
FieldTypeTkn.Handle =  ImageMap->FieldAttrTypesHndl;
FieldTypes          =  ClassMap->FieldAttrTypes;
TypeTypeTkn.DbId    =  WenvId;
TypeTypeTkn.Handle  =  ImageMap->FieldTypeTypesHndl;
TypeTypes          =  ClassMap->FieldTypeTypes;
FieldSizeTkn.DbId   =  WenvId;
FieldSizeTkn.Handle =  ImageMap->FieldSizesHndl;
FieldSizes          =  ClassMap->FieldSizes;
RefObjNumTkn.DbId   =  WenvId;
RefObjNumTkn.Handle =  ImageMap->FieldRefObjNumsHndl;
RefObjNums          =  ClassMap->RefObjNums;
ArrayAttrTkn.DbId   =  WenvId;
ArrayAttrTkn.Handle =  ImageMap->ArrayAttrsHndl;
ArrayAttrs          =  ClassMap->ArrayAttrs;
}
AttrTkn.DbId    = RenvId;
BldDescTkn.DbId = RenvId;
TypeTkn.DbId    = RenvId;
if (Normal(*Status))
OaPutVchunkStackPtr  (&ArrayAttrTkn,    1,  McStat);
NumMapFields  = 0;
DbIndex       = 0;
DbOffset      = 0;
TrueDbOffset  = 0;
TrueCppOffset = 0;
if (Normal(*Status))
while (DbIndex < FieldCount)
{
if (NumMapFields >= FieldCount+29)
{
TraceMsg (0,
" Ctrans:: Resize Chunks and Reset Addresses in ClassMapDir\n");
*Status = Err_NotImplemented;
}
AttrNum               = Vfields[DbIndex];
if (EnvFetchAttrSize   (AttrNum,         McStat,  &FieldSize))
if (EnvFetchAttrHandle (AttrNum,         McStat,  &AttrTkn.Handle))
if (OaGetObject        (&AttrTkn,        McStat,  (addrtype *)&EnvAttr))
{
TypeTkn.Handle     = EnvAttr->TypeObj;
OaGetObject         (&TypeTkn,  McStat, (addrtype *)&EnvType);
if (NumMapFields == 0)
{
FieldAttrs[0]      = (numtype  )EnvAttr->AttrType;
FieldTypes[0]      = (attrtype )EnvType->TypeType;
FieldSizes[0]      = (typesize )EnvType->Size;
if (AttrNum       == That_AttrNum)
HasThatAttr      = True;
}
}
AttrFound   = False;
CppIndex    = 0;
if (Normal(*Status))
while (!AttrFound
&&     ++CppIndex < MapAttrCount)
{
if (FieldTknMap[CppIndex].Index == AttrNum)
{
AttrFound        = True;
CppOffset        = FieldTknMap[CppIndex].Offset;
}
}
if (Normal(*Status))
if (!AttrFound
&&  MapAttrCount != 1)
{
sprintf (Msg, " ***Warning... Translation Map 1->0: \"%21s\"\n",
ObjName);
SendMsg (0, Msg);
sprintf (Msg, " ...Attribute [%4u] = \"%21s\".  Not in API Image\n",
AttrNum, EnvAttr->Nam);
SendMsg (0, Msg);
sprintf (Msg, " Attribute Fields[*%4u] of Object ::\n", FieldCount);
TraceMsg (0, Msg);
sprintf (Msg, " Appended  Fields[*%4u] specified ::\n", MapAttrCount);
TraceMsg (0, Msg);
i = MapAttrCount;
if (FieldCount > MapAttrCount)
i = FieldCount;
for (CppIndex    = 0; ++CppIndex < i; )
{
sprintf (Msg, "  Attr [%4u] = %4u;  AppendAttr [%4u] = %4u\n",
CppIndex,  Vfields[CppIndex-1],
CppIndex,  FieldTknMap[CppIndex].Index);
TraceMsg (0, Msg);
}
} else {
NumMapFields++;
TempBug   = ClassBug;
ClassBug  = False;
if (HasThatAttr       == False)
if (EnvAttr->AttrType == aArrayAttr
||  EnvAttr->AttrType == aDblPtrAttr
||  EnvAttr->AttrType == aVarrayAttr
||  EnvAttr->AttrType == aChunkAttr)
{
if (OaPushUnit      (&ArrayAttrTkn,  (addrtype )&NumMapFields,
McStat,                    &NumArrayAttrs))
if (ClassBug || DeBug || OaBug)
if (sprintf (Msg, "    ArrayType[%2u] for MapNum=%3u Index=%3u\n",
NumArrayAttrs, NumMapFields, ArrayAttrs[NumArrayAttrs]))
TraceMsg (0, Msg);
if (EnvAttr->AttrType == aVchunkAttr)
EnvAlignMember(EnvAttr->AttrType,        EnvType->TypeType,
sizeof (tokentype),      (sizetype *)&DbOffset);
else
EnvAlignMember(EnvAttr->AttrType,        aAddr,
sizeof (handletype),     (sizetype *)&DbOffset);
} else
EnvAlignMember  (EnvAttr->AttrType,        EnvType->TypeType,
EnvType->Size,           (sizetype *)&DbOffset);
ClassBug  = TempBug;
if (MapAttrCount == 1)
CppOffset             = DbOffset;
if (DbOffset          != CppOffset
||  EnvAttr->AttrType == aObjRefAttr
||  EnvAttr->AttrType == aTknRefAttr
||  EnvAttr->AttrType == aStrHndlAttr)
PureDbStruc           = False;
CppOffsets[NumMapFields]    = CppOffset;
DbOffsets[NumMapFields]     = DbOffset;
FieldSizes[NumMapFields]    = FieldSize;
FieldTypes[NumMapFields]    = EnvAttr->AttrType;
FieldAttrs[NumMapFields]    = AttrNum;
TypeTypes[NumMapFields]     = EnvType->TypeType;
if (AttrNum == That_AttrNum)
TypeTypes[0]             = (typetype )NumMapFields;
if (EnvAttr->AttrType == aArrayAttr
||  EnvAttr->AttrType == aVarrayAttr
||  EnvAttr->AttrType == aChunkAttr
||  EnvAttr->AttrType == aDblPtrAttr)
{
if ((BldDescTkn.Handle = EnvAttr->BuildDesc) > 0)
RefObjNums[NumMapFields]   = BldDescTkn.Handle;
else
RefObjNums[NumMapFields]   = EnvAttr->TypeObj;
} else if ((BldDescTkn.Handle    = EnvAttr->BuildDesc) > 0) {
if (OaGetObject    (&BldDescTkn,
McStat,             (addrtype *)&BuildDesc))
RefObjNums[NumMapFields]   = BuildDesc->ObjNum;
} else
RefObjNums[NumMapFields]   = 0;
if (Normal(*Status))
if (EnvAttr->AttrType == aMapRefAttr)
{
BldDescTkn.Handle             = EnvAttr->BuildDesc;
TransBuildMapField
(BuildDesc,    DbOffsets,    FieldSizes,
McStat,      &NumMapFields,&NumArrayAttrs);
}
if (AttrNum   == That_AttrNum)
{
HasThatAttr = True;
} else {
DbOffset   += FieldSize;
HasThatAttr = False;
}
}
DbIndex++;
}
if (Normal(*Status))
{
RefObjNums[0]    =  (numtype   )NumMapFields;
ArrayAttrs[0]    =  (numtype   )NumArrayAttrs;
if (CppOffsets[0]  == 140)
DbOffsets[0]     =  (typesize  )False;
else
DbOffsets[0]     =  (typesize  )PureDbStruc;
}
if (Normal(*Status))
{
if (ClassBug || OaBug || DeBug)
if (sprintf (Msg,  "  Adjust the StackPtrs for NumMapFields= %3u\n",
NumMapFields++))
TraceMsg (0, Msg);
if (OaPutVchunkStackPtr
(&DbOffsetTkn  ,      NumMapFields,     McStat))
if (OaPutVchunkStackPtr
(&CppOffsetTkn  ,     NumMapFields,     McStat))
if (OaPutVchunkStackPtr
(&FieldSizeTkn  ,     NumMapFields,     McStat))
if (OaPutVchunkStackPtr
(&FieldTypeTkn  ,     NumMapFields,     McStat))
if (OaPutVchunkStackPtr
(&FieldAttrTkn  ,     NumMapFields,     McStat))
if (OaPutVchunkStackPtr
(&RefObjNumTkn  ,     NumMapFields,     McStat))
OaPutVchunkStackPtr
(&TypeTypeTkn  ,      NumMapFields,     McStat);
}
ClassBug = TempClassBug;
TRACK(TrackBak,"TransBuildFields\n");
return(STAT);
}
boolean    TransBuildMapField
(objdesctype  *BuildDesc,   typesize     *DbOffsets,
typesize     *FieldSizes,  ft F,lt Z,zz *Status,
indextype    *NumMapFields,indextype  *NumArrayAttrs)
{
addrtype      *SubObjFieldMap   = NullPtr;
typesize      *SubObjDbOffsets  = NullPtr;
typesize      *SubObjCppOffsets = NullPtr;
typesize      *SubObjFieldSizes = NullPtr;
attrtype      *SubObjFieldTypes = NullPtr;
typetype      *SubObjTypeTypes  = NullPtr;
numtype       *SubObjFieldAttrs = NullPtr;
numtype       *SubObjRefObjNums = NullPtr;
numtype       *SubObjArrayAttrs = NullPtr;
indextype      SubObjNumArrayAttrs= 0;
numtype        NumMaps          = 0;
sizetype       AttrSize         = 0;
sizetype       SubObjClassSize  = 0;
if (MemGetAddr   (C_ObjMapDir,   BuildDesc->ObjNum,
McStat,        (addrtype *)&SubObjFieldMap))
if (SubObjFieldMap)
{
SubObjDbOffsets    =  (typesize *)SubObjFieldMap[0];
SubObjCppOffsets   =  (typesize *)SubObjFieldMap[1];
SubObjFieldSizes   =  (typesize *)SubObjFieldMap[2];
SubObjFieldTypes   =  (attrtype *)SubObjFieldMap[3];
SubObjFieldAttrs   =  (numtype  *)SubObjFieldMap[4];
SubObjRefObjNums   =  (numtype  *)SubObjFieldMap[5];
SubObjArrayAttrs   =  (numtype  *)SubObjFieldMap[6];
SubObjTypeTypes    =  (typetype *)SubObjFieldMap[7];
SubObjNumArrayAttrs=  (indextype )SubObjArrayAttrs[0];
SubObjClassSize    =  (sizetype  )SubObjCppOffsets[0];
AttrSize           = FieldSizes[*NumMapFields];
NumMaps            = AttrSize / BuildDesc->ObjSize;
if (NumMaps        > 1)
FieldSizes[*NumMapFields] = SubObjClassSize * NumMaps;
if (SubObjClassSize  != BuildDesc->ObjSize)
DbOffsets[0]    = False;
*NumArrayAttrs     += SubObjNumArrayAttrs;
}
TRACK(TrackBak,"TransBuildMapField\n");
return(STAT);
}
boolean Trans_FetchAttrOffset
(numtype       ObjNum,      numtype       AplId,
numtype       FieldNum,    ft F,lt Z,zz *Status,
sizetype     *CppOffset)
{
classmap   ClassMap;
count       i              = 0;
boolean     AttrFound      = False;
if (TransGetMap       (ObjNum,    AplId,   McStat,  &ClassMap))
*CppOffset         = ClassMap.CppOffsets[FieldNum];
else
*CppOffset  = 0;
if (!Normal(*Status)
||  OaBug  ||  DeBug)
{
sprintf  (Msg, " Trans_FetchAttrOffsets:: ImageOffset=%4u\n",
*CppOffset);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"Trans_FetchAttrOffset\n");
return(STAT);
}
boolean Trans_FetchAttrOffsets
(numtype       ObjNum,      numtype       AplId,
numtype       AttrId,      ft F,lt Z,zz *Status,
sizetype     *DbOffset,    sizetype     *CppOffset)
{
classmap   ClassMap;
count       i              = 0;
boolean     AttrFound      = False;
*DbOffset   = 0;
*CppOffset  = 0;
AttrFound            = False;
if (TransGetMap       (ObjNum,    AplId,   McStat,  &ClassMap))
{
i                 = 1;
while (AttrFound == False
&&     i         <= ClassMap.NumMapFields)
{
if (ClassMap.FieldAttrIds[i] == AttrId)
{
AttrFound   = True;
*DbOffset    += ClassMap.DbOffsets[i];
*CppOffset   += ClassMap.CppOffsets[i];
} else
++i;
}
if (!AttrFound)
{
sprintf  (Msg,
" @Trans_FetchAttrOffsets:: AttrId[%4u] NOT in Class[%4u] Def.\n",
AttrId, ClassMap.ObjNum);
TraceMsg (0, Msg);
Trans_DumpMap (ClassMap.ObjNum,  Cpp_Apl,  McStat);
*Status         = Trans_AttrNotInClassDef;
}
}
if (!Normal(*Status)
||  OaBug  ||  DeBug)
{
sprintf  (Msg, " Trans_FetchAttrOffsets:: DbOffset=%4u, ImageOffset=%4u\n",
*DbOffset,  *CppOffset);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"Trans_FetchAttrOffsets\n");
return(STAT);
}
boolean    Trans_FetchFieldOffsets
(tokentype    *Token,       numtype       AplId,
fieldspec     FieldTkns[], numtype       SubLevel,
ft F,lt Z,zz *Status,      sizetype     *FieldSize,
sizetype     *DbOffset,    sizetype     *CppOffset)
{
numtype       AttrId     = 0;
attrtype      AttrType   = aNonTypeAttr;
numtype       RefObjNum  = 0;
typetype      FieldType  = aNonTypeType;
sizetype      DbBase     = 0;
sizetype      CppBase    = 0;
Trans_FetchFieldOffset (Token,          Cpp_Apl,
FieldTkns,      SubLevel,
McStat,         FieldSize,    &AttrId,
&AttrType,      &RefObjNum,    &FieldType,
DbOffset,       CppOffset,
&DbBase,        &CppBase);
TRACK(TrackBak,"Trans_FetchFieldOffsets\n");
return(STAT);
}
boolean    Trans_FetchFieldOffset
(tokentype    *Token,       numtype       AplId,
fieldspec     FieldTkns[], numtype       SubLevel,
ft F,lt Z,zz *Status,      sizetype     *FieldSize,
numtype      *AttrId,      attrtype     *AttrType,
numtype      *RefObjNum,   typetype     *FieldType,
sizetype     *DbOffset,    sizetype     *CppOffset,
sizetype     *DbBase,      sizetype     *CppBase)
{
dbheader   *CoreDb         = NullPtr;
numtype     ObjNum         = 0;
int         i              = 0;
if (TmFetchCoreDb   (Token,                       McStat,   &CoreDb))
if (HmGetObjNum     (CoreDb,      Token->Handle,  McStat,   &ObjNum))
Trans_FetchObjFieldSpec
(ObjNum,    AplId,      FieldTkns, SubLevel,
McStat,    FieldSize,  AttrId,    AttrType, RefObjNum,
FieldType, DbOffset,   CppOffset, DbBase,   CppBase);
TRACK(TrackBak,"Trans_FetchFieldOffset\n");
return(STAT);
}
boolean    Trans_FetchObjFieldSpec
(numtype       ObjNum,      numtype       AplId,
fieldspec     FieldTkns[], numtype       SubLevel,
ft F,lt Z,zz *Status,      sizetype     *FieldSize,
numtype      *AttrId,      attrtype     *AttrType,
numtype      *RefObjNum,   typetype     *FieldType,
sizetype     *DbOffset,    sizetype     *CppOffset,
sizetype     *DbBase,      sizetype     *CppBase)
{
classmap   ClassMap;
count       i              = 0;
numtype     Level          = 0;
sizetype    MapImageSize   = 0;
sizetype    ImageOffset    = 0;
sizetype    ObjOffset      = 0;
boolean     AttrFound      = False;
indextype   NumMaps        = 0;
*DbOffset   = 0;
*CppOffset  = 0;
Level     = 0;
while (Normal(*Status)
&&     Level < SubLevel)
{
AttrFound            = False;
if (TransGetMap       (ObjNum,    AplId,   McStat,  &ClassMap))
{
if (Level > 0)
if (FieldTkns[Level-1].Index  > 0)
{
NumMaps        = MapImageSize / ClassMap.ImageSize;
if (FieldTkns[Level-1].Index  < NumMaps)
{
ImageOffset    = ClassMap.ImageSize * FieldTkns[Level-1].Index;
*CppOffset     += ImageOffset;
ObjOffset     += ClassMap.ClassSize * FieldTkns[Level-1].Index;
*DbOffset      += ObjOffset;
} else {
sprintf  (Msg,
"  TransFetchFieldOffset::= Field Index=%4u >= NumMaps=%4u\n",
FieldTkns[Level].AttrId, NumMaps);
TraceMsg (0, Msg);
*Status = Trans_IndexOutOfRange;
}
}
i                 = 1;
while (AttrFound == False
&&     i         <= ClassMap.NumMapFields)
{
if (ClassMap.FieldAttrIds[i] == FieldTkns[Level].AttrId)
AttrFound   = True;
else
++i;
}
if (!AttrFound)
*Status         = Trans_AttrNotInClassDef;
} else {
sprintf  (Msg,
"  TransFetchFieldOffset::= ClassMap[%4u] was NOT Invoked.\n",
ObjNum);
TraceMsg (0, Msg);
}
if (Normal(*Status))
{
++Level;
*DbOffset    += ClassMap.DbOffsets[i];
*CppOffset   += ClassMap.CppOffsets[i];
if (Level   == 1)
{
*DbBase    = *DbOffset;
*CppBase   = *CppOffset;
}
if (Normal(*Status))
if (Level != SubLevel)
if (ClassMap.FieldAttrTypes[i] != aMapRefAttr)
{
sprintf  (Msg,
"*** ERRor...@ Level =%4u; AttrId=%4u Not a Nested Object\n",
Level, FieldTkns[Level].AttrId);
TraceMsg (0, Msg);
*Status = Trans_AttrNotInClassDef;
} else {
MapImageSize   = ClassMap.FieldSizes[i];
ObjNum         = ClassMap.RefObjNums[i];
}
}
}
if (!AttrFound)
{
sprintf  (Msg, " Trans_FetchObjFieldSpec:: ObjNum=%4u\n", ObjNum);
TraceMsg (0, Msg);
sprintf  (Msg,"         @ Level =%4u; AttrId=%4u, Index=%4u\n",
Level, FieldTkns[Level].AttrId, FieldTkns[Level].Index);
TraceMsg (0, Msg);
*Status = Trans_AttrNotInClassDef;
} else {
*FieldSize    = ClassMap.FieldSizes[i];
*AttrId       = ClassMap.FieldAttrIds[i];
*AttrType     = ClassMap.FieldAttrTypes[i];
*RefObjNum    = ClassMap.RefObjNums[i];
*FieldType    = ClassMap.FieldTypeTypes[i];
}
if (!Normal(*Status))
{
sprintf  (Msg, " Trans_FetchObjFieldSpec:: ObjNum=%4u\n", ObjNum);
TraceMsg (0, Msg);
for (i=0; i < SubLevel; i++)
{
sprintf  (Msg, " Field %4u. AttrId=%4u; Index=%4u.\n",
i, FieldTkns[i].AttrId,  FieldTkns[i].Index);
TraceMsg (0, Msg);
}
}
TRACK(TrackBak,"Trans_FetchObjFieldSpec\n");
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\trans01.c*/

#define  TRANS01
/* 当前文件是./CINT2000\255.vortex\src\api.h*/

typedef struct ApiPortHead
{
handletype        Handle;
numtype           ShellNum;
char              Nam[MAXNAME];
envclass          EnvType;
numtype           DescNum;
handletype        MemberRenvShells;
handletype        MemberRenvDescs;
handletype        OwnerShellSchemas;
handletype        OwnerApiPortObjs;
handletype        CodesInShell;
handletype        ObjsInShell;
} portheadtype;
typedef struct TransPortHead
{
handletype        Handle;
numtype           ShellNum;
char              Nam[MAXNAME];
envclass          EnvType;
numtype           DescNum;
handletype        MemberRenvShells;
handletype        MemberRenvDescs;
handletype        OwnerShellSchemas;
handletype        OwnerApiPortObjs;
handletype        CodesInShell;
handletype        ObjsInShell;
numtype           MapCount;
numtype           FieldCount;
handletype        OwnerApiPortAttrs;
handletype        OwnerTransMapNames;
handletype        OwnerTransFieldNames;
handletype        OwnerTransPortMaps;
handletype        OwnerTransPortFields;
} transporthead;
typedef struct TypeApiPortObj
{
handletype        Handle;
numtype           ObjNum;
char              Nam[MAXNAME];
numtype           AttrCount;
handletype        PortFields;
handletype        PortOffsets;
handletype        MemberApiPortObjs;
numtype           ExportCode;
numtype           ImportCode;
} portobjtype;
typedef struct TransPortMap
{
handletype        Handle;
numtype           ObjNum;
char              Nam[MAXNAME];
numtype           AttrCount;
handletype        PortFields;
handletype        PortOffsets;
handletype        MemberApiPortObjs;
numtype           ExportCode;
numtype           ImportCode;
numtype           MapNum;
sizetype          MapImageSize;
sizetype          MapTokenSize;
handletype        PortAttrs;
handletype        PortMapTkns;
handletype        MemberTransMapNames;
handletype        MemberTransPortMaps;
handletype        OwnerPortMapFields;
handletype        MemberPortFieldMaps;
} transportmap;
typedef struct TransPortField
{
handletype        Handle;
numtype           FieldNum;
char              Nam[MAXNAME];
numtype           AttrNum;
numtype           MapIndex;
numtype           FieldExportCode;
numtype           FieldImportCode;
handletype        MemberApiPortAttrs;
handletype        MemberTransFieldNames;
handletype        MemberTransPortFields;
handletype        MemberPortMapFields;
handletype        OwnerPortFieldMaps;
} transportfield;
#define        That_AttrNum           (numtype )1
#define        Handle_AttrNum         (numtype )2



#define Core0MoreCore      Core0_MoreCore
#define MemGetAddr         Mem_GetAddr
#define MemGetWord         Mem_GetWord
#define MemGetFieldNum      Mem_GetWord
#define MemGetObjNum        Mem_GetWord
#define MemGetLocalObjNum   Mem_GetWord
#define MemGetObjHdr        Mem_GetAddr



#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
numtype  Ref_BaseClass = 0;
boolean C_GetObjectImage  (tokentype    *Token,    numtype       AplId,
ft F,lt Z,zz *Status,   addrtype     *This)
{
dbheader   *CoreDb         = NullPtr;
numtype     MemLoc         = 0;
numtype     ObjNum         = 0;
addrtype   *FieldMap       = NullPtr;
typesize   *CppOffsets     = NullPtr;
typesize    ObjSize        = 0;
if (TmGetCoreDb          (Token,                   McStat,   &CoreDb))
if (HmGetObjectMemLoc    (CoreDb,  Token->Handle,  McStat,   &MemLoc))
if (MemLoc)
{
HmGetObjectAddr    (CoreDb,    Token->Handle,  McStat,   This);
TRACK(TrackBak,"C_GetObjectImage\n");
return (STAT);
}
if (Normal(*Status))
if (HmGetObjNum       (CoreDb, Token->Handle,   McStat,        &ObjNum))
if (MemGetAddr        (C_ObjMapDir,                             ObjNum,
McStat,                     (addrtype *)&FieldMap))
if (FieldMap != NullPtr)
{
CppOffsets   =  (typesize *)FieldMap[1];
ObjSize      =  (typesize  )CppOffsets[0];
} else
*Status = Trans_NullMap;
if (ObjSize == 0)
*Status = Trans_NullObjSize;
if (Normal(*Status))
if (Core0MoreCore ((bytessizetype )ObjSize, McStat, This))
{
C_FaxToThis     (Token,    *This,   AplId,  McStat);
}
TRACK(TrackBak,"C_GetObjectImage\n");
return(STAT);
}
boolean C_ObjectNewImage  (tokentype    *Token,    numtype       ObjNum,
numtype       AplId,
ft F,lt Z,zz *Status,   addrtype     *This)
{
addrtype   *FieldMap       = NullPtr;
typesize    ObjSize        = 0;
typesize   *CppOffsets     = NullPtr;
numtype    *FieldAttrs     = NullPtr;
count       i              = 0;
addrtype    CppObjectAddr  = NullPtr;
addrtype    That           = NullPtr;
if (MemGetAddr        (C_ObjMapDir,                        ObjNum,
McStat,                (addrtype *)&FieldMap))
if (FieldMap != NullPtr)
{
CppOffsets   =  (typesize *)FieldMap[1];
FieldAttrs   =  (numtype  *)FieldMap[4];
if ((ObjSize =  (typesize  )CppOffsets[0]) == 0)
*Status  = Trans_NullObjSize;
} else
*Status       = Trans_NullMap;
if (Normal(*Status))
if (Core0MoreCore ((bytessizetype )ObjSize, McStat, This))
That       = *This;
else
*Status  = Trans_CoreNoMore;
i = 1;
if (Normal(*Status))
if (FieldAttrs[i] == That_AttrNum)
{
CppObjectAddr   = (addrtype )((char *)That  + CppOffsets[i]);
MoveBytes    (This,    CppObjectAddr,  sizeof(addrtype));
i++;
}
if (Normal(*Status))
if (FieldAttrs[i] == Handle_AttrNum)
{
CppObjectAddr   = (addrtype )((char *)That  + CppOffsets[i]);
MoveBytes    ((addrtype )Token,    CppObjectAddr,  sizeof(tokentype));
}
if (Normal(*Status))
if (HmPutObjectMemLoc (CoreDbs[Token->DbId],  Token->Handle,
(numtype )1,           McStat))
HmPutObjectAddr   (CoreDbs[Token->DbId],  Token->Handle,
*This,                  McStat);
TRACK(TrackBak,"C_ObjectNewImage\n");
return(STAT);
}
boolean    C_InvokeAtThis
(tokentype    *Token,    addrtype      This,
numtype       AplId,    ft F,lt Z,zz *Status)
{
dbheader   *CoreDb         = NullPtr;
numtype     ObjNum         = 0;
addrtype   *FieldMap       = NullPtr;
typesize   *CppOffsets     = NullPtr;
numtype    *FieldAttrs     = NullPtr;
count       i              = 0;
addrtype    CppObjectAddr  = NullPtr;
addrtype    That           = This;
if (TmGetCoreDb          (Token,                   McStat,   &CoreDb))
if (HmGetObjNum          (CoreDb,  Token->Handle,  McStat,   &ObjNum))
if (MemGetAddr           (C_ObjMapDir,                       ObjNum,
McStat,               (addrtype *)&FieldMap))
if (FieldMap)
{
CppOffsets      =  (typesize *)FieldMap[1];
FieldAttrs      =  (numtype  *)FieldMap[4];
} else
*Status = Trans_NullMap;
i = 1;
if (Normal(*Status))
if (FieldAttrs[i] == That_AttrNum)
{
CppObjectAddr   = (addrtype )((char *)This  + CppOffsets[i]);
MoveBytes    ((addrtype )&That,    CppObjectAddr,  sizeof(addrtype));
i++;
}
if (Normal(*Status))
if (FieldAttrs[i] == Handle_AttrNum)
{
CppObjectAddr   = (addrtype )((char *)This  + CppOffsets[i]);
MoveBytes    ((addrtype )Token,    CppObjectAddr,  sizeof(tokentype));
}
if (Normal(*Status))
if (HmPutObjectMemLoc (CoreDbs[Token->DbId],  Token->Handle,
(numtype )1,           McStat))
HmPutObjectAddr   (CoreDbs[Token->DbId],  Token->Handle,
This,                  McStat);
TRACK(TrackBak,"C_InvokeAtThis\n");
return (STAT);
}
boolean    C_FaxToThis   (tokentype    *Token,    addrtype      Object,
numtype       AplId,    ft F,lt Z,zz *Status)
{
dbheader   *CoreDb         = NullPtr;
numtype     ObjNum         = 0;
indextype   NumArrayAttrs  = 0;
boolean     PureDbStruc    = False;
typesize    ObjSize        = 0;
indextype   ThatIndex      = 0;
addrtype    CppObjectAddr  = NullPtr;
addrtype    ImageOffset    = NullPtr;
statustype  DumpStatus     = Env_Normal;
maparrays  *FieldMap       = NullPtr;
addrtype    DbObject       = NullPtr;
numtype     LocalObj       = 0;
numtype     MemLoc         = 0;
if (TmGetCoreDb       (Token,                   McStat,        &CoreDb))
if (HmGetObjNum       (CoreDb, Token->Handle,   McStat,        &ObjNum))
if (Normal(*Status))
if (OaGetObject       (Token,                   McStat,        &DbObject))
if (DbObject == Object)
{
TRACK(TrackBak,"C_FaxToThis\n");
return (STAT);
}
if (Normal(*Status))
if (MemGetLocalObjNum (CoreDbs[Token->DbId]->LocalObjNumMap,   ObjNum,
McStat,                                &LocalObj))
if (MemGetAddr        (C_ObjMapDir,                            ObjNum,
McStat,                     (addrtype *)&FieldMap))
if (FieldMap)
{
NumArrayAttrs=  (indextype )FieldMap->ArrayAttrs[0];
PureDbStruc  =  (boolean   )FieldMap->DbOffsets[0];
ThatIndex    =  (indextype )FieldMap->FieldTypeTypes[0];
ObjSize      =  (typesize  )FieldMap->CppOffsets[0];
} else
*Status = Trans_NullMap;
if (Normal(*Status))
if (HmGetObjectMemLoc (CoreDb,                    Token->Handle,
McStat,                   &MemLoc))
if (MemLoc == 1)
{
if (AplId == Cpp_Apl
&&  Image01_GetFreeStoreAddr () == Object
&&  DeBug == -1)
{
if (Core0FreeCoreSpace   (&Object,  (bytessize )ObjSize, McStat))
Object  = DbObject;
} else {
MoveBytes            (DbObject,      Object,     ObjSize);
if (Core0FreeCoreSpace   (&DbObject,  (bytessize )ObjSize, McStat))
{
CppObjectAddr = Object;
ImageOffset   = (addrtype )((char *)Object
+ FieldMap->CppOffsets[ThatIndex]);
MoveBytes       ((addrtype )&CppObjectAddr,  (addrtype )ImageOffset,
sizeof (addrtype));
}
if (Normal(*Status))
OaInvokeCppObject (Token,  Object,  McStat);
}
TRACK(TrackBak,"C_FaxToThis\n");
return (STAT);
}
if (Normal(*Status))
if (MemGetLocalObjNum (CoreDbs[Token->DbId]->LocalObjNumMap,   ObjNum,
McStat,                                &LocalObj))
if (MemGetAddr        (C_ObjMapDir,                            ObjNum,
McStat,                     (addrtype *)&FieldMap))
if (FieldMap)
{
NumArrayAttrs=  (indextype )FieldMap->ArrayAttrs[0];
PureDbStruc  =  (boolean   )FieldMap->DbOffsets[0];
ThatIndex    =  (indextype )FieldMap->FieldTypeTypes[0];
ObjSize      =  (typesize  )FieldMap->CppOffsets[0];
} else
*Status = Trans_NullMap;
if (Normal(*Status))
if (PureDbStruc   == False
||  NumArrayAttrs  > 0)
{
C_FaxToClassFields (Token->DbId,   LocalObj,   DbObject,    Object,
ObjNum,        FieldMap,   AplId,       McStat);
} else {
MoveBytes          (DbObject,      Object,     ObjSize);
}
if (Normal(*Status))
if (ThatIndex                 > 0
|| FieldMap->FieldAttrIds[1] == That_AttrNum)
{
CppObjectAddr = Object;
ImageOffset   = (addrtype )((char *)Object
+ FieldMap->CppOffsets[ThatIndex]);
MoveBytes       ((addrtype )&CppObjectAddr,    (addrtype )ImageOffset,
sizeof (addrtype));
}
if (Normal(*Status))
OaInvokeCppObject (Token,  Object,  McStat);
if (DeBug || OaBug)
OaDumpObject      (0,      Token,   Dump_Status);
TRACK(TrackBak,"C_FaxToThis\n");
return (STAT);
}
boolean    C_FaxToClassFields
(idtype        DbId,     numtype       LocalObj,
addrtype      DbObject, addrtype      Object,
numtype       ObjNum,   maparrays    *FieldMap,
numtype       AplId,    ft F,lt Z,zz *Status)
{
indextype   NumArrayAttrs  = 0;
indextype   NumMapFields   = 0;
boolean     PureDbStruc    = False;
typesize    ObjSize        = 0;
count       i              = 0;
addrtype    CppObjectAddr  = NullPtr;
addrtype    DbObjectAddr   = NullPtr;
indextype   AttrCount      = 0;
typesize    AttrDbSize     = 0;
typesize    Attr01Size     = 0;
typesize    BaseDbOffset   = 0;
typesize    Base01Offset   = 0;
int         k              = 0;
tokentype  *RefTkn         = NullPtr;
longtype    LongIndex      = 0;
indextype   StrIndex       = 0;
char       *StrAddr        = NullPtr;
indextype   UnitCount      = 0;
addrtype    Array          = NullPtr;
tokentype   VchunkTkn      = NullToken;
chunkstruc  ChunkStruc;
handletype *ArrayHndls     = NullPtr;
handletype *SubArrays      = NullPtr;
addrtype   *Arrays         = NullPtr;
int         j              = 0;
indextype   NumSubArrays   = 0;
tokentype   SubChunkTkn    = NullToken;
objheader  *ObjHdr         = NullPtr;
vchunktkntype  Vchunk;
addrtype    Null_Ptr       = NullPtr;
typesize    Offset         = 0;
VchunkTkn.DbId     = DbId;
SubChunkTkn.DbId   = DbId;
NumMapFields =  (indextype )FieldMap->RefObjNums[0];
NumArrayAttrs=  (indextype )FieldMap->ArrayAttrs[0];
PureDbStruc  =  (boolean   )FieldMap->DbOffsets[0];
ObjSize      =  (typesize  )FieldMap->CppOffsets[0];
while (++i <= NumMapFields
&&     Normal(*Status))
{
DbObjectAddr       = (addrtype )((char *)DbObject
+ FieldMap->DbOffsets[i]);
CppObjectAddr      = (addrtype )((char *)Object
+ FieldMap->CppOffsets[i]);
if ((AttrCount    = AttrTypeSizes[
FieldMap->FieldAttrTypes[i] ]) != 1)
{
Attr01Size     = AttrCount;
AttrDbSize     = AttrCount;
AttrCount      = FieldMap->FieldSizes[i] / AttrCount;
if (FieldMap->FieldAttrTypes[i] == aSetHeadAttr
||  FieldMap->FieldAttrTypes[i] == aSetNodeAttr)
{
AttrCount      = 1;
}
} else
Attr01Size     = 0;
BaseDbOffset      = 0;
Base01Offset      = 0;
k                 = 0;
if (FieldMap->FieldAttrIds[i] != That_AttrNum)
while (k++ < AttrCount)
{
CppObjectAddr   = (addrtype )((char *)CppObjectAddr + Base01Offset);
DbObjectAddr    = (addrtype )((char *)DbObjectAddr  + BaseDbOffset);
switch (FieldMap->FieldAttrTypes[i])
{
case aAttr         :
case aPortRefAttr  :
case aSetNodeAttr  :
case aSetHeadAttr  :
case aMtrxHeadAttr :
case aRowHeadAttr  :
case aColHeadAttr  :
case aMateNodeAttr :
case aPointNodeAttr:
case aSlotHndlAttr :
case aSlotTokenAttr:
case aVchunkAttr   :
case aGrpAttr      :
case aVgrpAttr     :
MoveBytes   (DbObjectAddr,   CppObjectAddr,
FieldMap->FieldSizes[i]);
break;
case aObjRefAttr   :
RefTkn   =   (tokentype *)DbObjectAddr;
Ref_BaseClass = FieldMap->RefObjNums[i];
if (RefTkn->Handle)
{
if(C_RefToAddr    (RefTkn,       AplId,
McStat,       (addrtype *)CppObjectAddr))
Hm_IncrementMemRef
(CoreDbs[DbId], RefTkn->Handle,  McStat);
} else {
MoveBytes ((addrtype )&NullToken,     DbObjectAddr,
FieldMap->FieldSizes[i]);
MoveBytes (&Null_Ptr,                 CppObjectAddr,
FieldMap->FieldSizes[i]);
}
break;
case aMapRefAttr   :
C_MapRefToAddr (DbId,                     LocalObj,
DbObjectAddr,             CppObjectAddr,
FieldMap->RefObjNums[i],  FieldMap->FieldSizes[i],
AplId,                    McStat);
break;
case aTknRefAttr  :
MoveBytes   (&Null_Ptr, CppObjectAddr,  sizeof (addrtype));
CppObjectAddr = (addrtype )((char *)CppObjectAddr
+ sizeof (addrtype));
MoveBytes   (DbObjectAddr, CppObjectAddr,  sizeof (tokentype));
break;
case aStrHndlAttr  :
LongIndex = *(longtype *)DbObjectAddr;
StrIndex  = LongIndex;
StrAddr   = NullPtr;
if (StrIndex)
if (MemGetObjHdr      (CoreDbs[DbId]->ObjHdrDir, LocalObj,
McStat,     (addrtype *)&ObjHdr))
OaGetString (DbId,          ObjHdr,        StrIndex,
McStat,                      &StrAddr);
if (StrAddr)
MoveBytes     ((addrtype )&StrAddr,  CppObjectAddr,
sizeof(char *));
else
StrAddr = NullStr;
break;
case aArrayAttr    :
VchunkTkn.DbId = DbId;
MoveBytes   (DbObjectAddr, (addrtype )&VchunkTkn.Handle,
sizeof (handletype));
if (VchunkTkn.Handle)
{
VchunkGetAddress (&VchunkTkn,       McStat,       &Array);
MoveBytes  ((addrtype )&Array,  CppObjectAddr,
sizeof (addrtype));
}
break;
case aChunkAttr    :
case aVarrayAttr   :
UnitCount      = 0;
Array          = NullPtr;
VchunkTkn.DbId = DbId;
MoveBytes (DbObjectAddr, (addrtype )&VchunkTkn.Handle,
sizeof (handletype));
if (VchunkTkn.Handle)
if (VchunkGetVstruc   (&VchunkTkn,  McStat,     &ChunkStruc))
if (VchunkGetAddress  (&VchunkTkn,  McStat,     &Array))
UnitCount = ChunkStruc.UnitCount;
MoveBytes ((addrtype )&VchunkTkn,    CppObjectAddr,
sizeof(tokentype));
CppObjectAddr = (addrtype )((char *)CppObjectAddr
+ sizeof(tokentype));
MoveBytes ((addrtype )&UnitCount,   CppObjectAddr,
sizeof(indextype));
if (BytePtrAlignment  <= 4)
Offset      = sizeof (indextype);
else
Offset      = sizeof (addrtype);
CppObjectAddr = (addrtype )((char *)CppObjectAddr
+ Offset);
MoveBytes((addrtype )&Array, CppObjectAddr, sizeof(addrtype));
if (FieldMap->FieldAttrTypes[i] != aChunkAttr)
break;
CppObjectAddr = (addrtype )((char *)CppObjectAddr
+ sizeof(addrtype));
MoveBytes((addrtype )&ChunkStruc.StackPtr, CppObjectAddr,
sizeof(indextype));
break;
case aDblPtrAttr   :
MoveBytes   (DbObjectAddr, (addrtype )&VchunkTkn.Handle,
sizeof (handletype));
if (VchunkTkn.Handle)
VchunkGetAddress (&VchunkTkn,  McStat, (addrtype *)&Arrays);
MoveBytes   ((addrtype )&Arrays,    CppObjectAddr,
sizeof (addrtype));
if (VchunkTkn.Handle)
if (VchunkGetVstruc (&VchunkTkn,      McStat, &ChunkStruc))
{
ArrayHndls    = (handletype *)Arrays;
NumSubArrays  = ChunkStruc.StackPtr / 3;
SubArrays     = (handletype *)&ArrayHndls[NumSubArrays * 2];
j             = -1;
while (Normal(*Status)
&&     ++j    < NumSubArrays)
{
#ifdef __BCC__
memcpy (&SubChunkTkn.Handle,
&SubArrays[j],           sizeof (handletype));
#else
SubChunkTkn.Handle = SubArrays[j];
#endif
if (SubChunkTkn.Handle)
if (DbmInvokeVchunk  (&SubChunkTkn,    McStat,   &Vchunk))
VchunkGetAddress (&SubChunkTkn,    McStat,
(addrtype *)&Arrays[j]);
}
if (Normal(*Status))
if (DeBug  || OaBug || ClassBug)
VchunkDump  (&VchunkTkn,   McStat);
}
break;
default            :
*Status = Err_NotImplemented;
}
Base01Offset  += Attr01Size;
BaseDbOffset  += AttrDbSize;
}
}
TRACK(TrackBak,"C_FaxToClassFields\n");
return (STAT);
}
boolean    C_MapRefToAddr (idtype        DbId,     numtype       LocalObj,
addrtype      DbObject, addrtype      Object,
numtype       ObjNum,   sizetype      MapSize,
numtype       AplId,    ft F,lt Z,zz *Status)
{
dbheader   *CoreDb         = NullPtr;
maparrays  *FieldMap       = NullPtr;
indextype   NumArrayAttrs  = 0;
indextype   NumMapFields   = 0;
boolean     PureDbStruc    = False;
typesize    ObjSize        = 0;
typesize    DbObjSize      = 0;
indextype   NumMaps        = 0;
count       l              = 0;
addrtype    CppObjectAddr  = NullPtr;
addrtype    DbObjectAddr   = NullPtr;
tokentype   AnchorTkn      = NullToken;
AnchorTkn.DbId = DbId;
if (TmFetchCoreDb     (&AnchorTkn,                  McStat,   &CoreDb))
if (MemGetAddr        (C_ObjMapDir,                            ObjNum,
McStat,                     (addrtype *)&FieldMap))
if (FieldMap  == NullPtr)
{
if (EnvFetchObjSize   (ObjNum,        McStat,               &ObjSize))
if (ImageInitClassMap (ObjNum,        ObjSize,    C_Apl,     McStat))
if (TransInvokeMap    (C_Apl,         McStat))
if (TransBuildMap     (C_Apl,         McStat))
if (MemGetAddr        (C_ObjMapDir,                          ObjNum,
McStat,                  (addrtype *)&FieldMap))
if (FieldMap == NullPtr)
*Status = Trans_NullMap;
}
if (Normal(*Status))
{
NumMapFields =  (indextype )FieldMap->RefObjNums[0];
NumArrayAttrs=  (indextype )FieldMap->ArrayAttrs[0];
PureDbStruc  =  (boolean   )FieldMap->DbOffsets[0];
ObjSize      =  (typesize  )FieldMap->CppOffsets[0];
}
if (Normal(*Status))
if (!PureDbStruc
||  NumArrayAttrs > 0)
{
EnvFetchObjSize (ObjNum,  McStat, &DbObjSize);
NumMaps      =  MapSize   / DbObjSize;
l                = 0;
while (Normal(*Status)
&&     ++l      <= NumMaps)
{
DbObjectAddr       = (addrtype )((char *)DbObject
+  ((l-1) * DbObjSize));
CppObjectAddr      = (addrtype )((char *)Object
+  ((l-1) * ObjSize));
C_FaxToClassFields  (DbId,          LocalObj,   DbObjectAddr,
CppObjectAddr, ObjNum,     FieldMap,
AplId,         McStat);
}
} else {
MoveBytes   (DbObject,   Object,   MapSize);
}
TRACK(TrackBak,"C_MapRefToAddr\n");
return (STAT);
}
boolean    C_RefToAddr    (tokentype    *Token,   numtype       AplId,
ft F,lt Z,zz *Status,  addrtype     *This)
{
cppobjecttype  *ItSelf  = NullPtr;
dbheader   *CoreDb      = NullPtr;
indextype   LocalObjNum = 0;
indextype   ObjNum      = 0;
numtype     MemLoc      = 0;
addrtype    That        = 0;
*This  = NullPtr;
if (TmIsValid(Token, McStat))
{
if (OaGetObject (Token, McStat, (addrtype *)&ItSelf))
{
}
if (Normal(*Status))
if (TmGetCoreDb       (Token,     McStat,        &CoreDb))
if (HmGetLocalObjNum  (CoreDb,                    Token->Handle,
McStat,                   &LocalObjNum))
if (MemGetObjNum      (CoreDb->ObjNumMap,         LocalObjNum,
McStat,                   &ObjNum))
if (HmGetObjectMemLoc (CoreDb,                    Token->Handle,
McStat,                   &MemLoc))
#ifdef IMAGE_WITH_THAT
if (ItSelf->That != NullPtr
||  MemLoc)
#else
if (MemLoc)
#endif
{
if (MemLoc == 0)
if (TraceMsg (0,
"***ERROR... Itself->That !=NullPtr && MemLoc == 0\n"))
HmPutObjectMemLoc (CoreDbs[Token->DbId],  Token->Handle,
(numtype )1,           McStat);
*This  = (addrtype )ItSelf;
} else {
if (Build_ByCpp)
CppCreateObject   (ObjNum,           McStat,   &That);
else
C_CreateObject    (ObjNum,   AplId,  McStat,   &That);
if (Normal(*Status))
{
*This  = That;
C_FaxToThis (Token, *This, AplId,   McStat);
}
}
if (Normal(*Status))
if (Build_ByCpp)
if (Ref_BaseClass)
CppCastObject     (ObjNum, Ref_BaseClass, McStat,  This);
}
TRACK(TrackBak,"C_RefToAddr\n");
return (STAT);
}
boolean C_CreateArray    (tokentype    *Token,     numtype       AttrNum,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype     *Array)
{
addrtype    This           = NullPtr;
dbheader   *CoreDb         = NullPtr;
numtype     MemLoc         = 0;
numtype     ObjNum         = 0;
addrtype    DbObject       = NullPtr;
addrtype   *FieldMap       = NullPtr;
typesize   *DbOffsets      = NullPtr;
typesize   *CppOffsets     = NullPtr;
numtype    *FieldAttrs     = NullPtr;
attrtype   *FieldTypes     = NullPtr;
count       i              = 0;
addrtype    DbObjectAddr   = NullPtr;
addrtype    CppObjectAddr  = NullPtr;
addrtype    CppStrucAddr   = NullPtr;
numtype    *RefObjNums     = NullPtr;
indextype   NumMapFields   = 0;
boolean     Found          = False;
indextype   ExtendQty      = UnitCount;
tokentype   Anchor         = NullToken;
sizetype    ArraySize      = 0;
tokentype   TypeTkn        = NullToken;
typedesctype  *EnvType     = NullPtr;
objdesctype   *EnvObj      = NullPtr;
indextype   StackPtr       = 0;
typesize    Offset         = 0;
TypeTkn.DbId    = RenvId;
Anchor.DbId     = Token->DbId;
Anchor.Handle   = 1;
if (TmGetCoreDb          (Token,                   McStat,   &CoreDb))
if (HmGetObjectMemLoc    (CoreDb,  Token->Handle,  McStat,   &MemLoc))
if (MemLoc)
if (HmGetObjectAddr      (CoreDb,  Token->Handle,  McStat,   &This))
OaRevokeCppObject    (Token,                   McStat);
if (Normal(*Status))
if (HmGetObjNum          (CoreDb,  Token->Handle,  McStat,   &ObjNum))
if (OaGetObject          (Token,                   McStat,   &DbObject))
if (MemLoc)
OaInvokeCppObject    (Token,   This,           McStat);
if (Normal(*Status))
if (MemGetAddr        (C_ObjMapDir,                       ObjNum,
McStat,               (addrtype *)&FieldMap))
if (FieldMap)
{
DbOffsets       =  (typesize *)FieldMap[0];
CppOffsets      =  (typesize *)FieldMap[1];
FieldTypes      =  (attrtype *)FieldMap[3];
FieldAttrs      =  (numtype  *)FieldMap[4];
RefObjNums      =  (numtype  *)FieldMap[5];
NumMapFields    =  (indextype )RefObjNums[0];
i               = 1;
while (Found   == False
&&     i       <= NumMapFields)
{
if (FieldAttrs[i] == AttrNum)
Found = True;
else
++i;
}
if (!Found)
*Status = Trans_ArrayNotOfClass;
} else
*Status = Trans_NullMap;
if (Normal(*Status))
{
TypeTkn.Handle    = RefObjNums[i];
if (OaGetObject   (&TypeTkn,  McStat, (addrtype *)&EnvType))
if (EnvType->EnvType  == aEnvObj)
{
EnvObj         = (objdesctype *)EnvType;
ArraySize      = EnvObj->ObjSize;
} else
ArraySize      = EnvType->Size;
if (Normal(*Status))
if (FieldTypes[i] == aDblPtrAttr)
{
UnitCount     *= 3;
UnitSize       = sizeof (handletype);
} else if (FieldTypes[i] == aArrayAttr)   {
if (ArraySize != UnitSize)
*Status     = Trans_MixedArraySize;
} else if (FieldTypes[i] != aStrHndlAttr) {
if (ArraySize != UnitSize)
*Status     = Trans_MixedArraySize;
}
if ( ArraySize )
	*Status = Env_Normal;
}
if (Normal(*Status))
if (FieldTypes[i] != aStrHndlAttr)
{
if (VchunkCreate      (&Anchor,    UnitSize,      UnitCount,
ExtendQty,  McStat,        VchunkTkn))
if (VchunkGetAddress  (VchunkTkn,  McStat,        Array))
{
DbObjectAddr    =  (addrtype )((char *)DbObject  + DbOffsets[i]);
MoveBytes         ((addrtype )&VchunkTkn->Handle,  DbObjectAddr,
sizeof(handletype));
}
if (Normal(*Status))
if (FieldTypes[i] == aArrayAttr
||  FieldTypes[i] == aVarrayAttr
||  FieldTypes[i] == aDblPtrAttr)
VchunkPutStackPtr (VchunkTkn,  UnitCount, McStat, (addrtype *)Array);
} else {
*Array = (addrtype )calloc (1, UnitCount);
}
if (Normal(*Status))
if (MemLoc)
{
CppObjectAddr   = (addrtype )((char *)This  + CppOffsets[i]);
if (FieldTypes[i] == aVarrayAttr
||  FieldTypes[i] == aChunkAttr)
{
CppStrucAddr       = CppObjectAddr;
MoveBytes  ((addrtype )VchunkTkn,   CppObjectAddr,  sizeof(tokentype));
Offset       += sizeof (tokentype);
CppStrucAddr  = (addrtype )((char *)CppObjectAddr + Offset);
MoveBytes  ((addrtype )&UnitCount,  CppStrucAddr,   sizeof(indextype));
Offset       += sizeof (indextype);
Ut_AlignMember  (aAddr,      sizeof (addrtype), &Offset);
CppStrucAddr  = (addrtype )((char *)CppObjectAddr + Offset);
MoveBytes       ((addrtype )Array,  CppStrucAddr,   sizeof(addrtype));
if (FieldTypes[i] == aChunkAttr)
{
Offset       += sizeof (addrtype);
CppStrucAddr  = (addrtype )((char *)CppObjectAddr  + Offset);
MoveBytes  ((addrtype )&StackPtr,  CppStrucAddr,  sizeof(indextype));
}
} else {
MoveBytes  ((addrtype )Array,       CppObjectAddr,  sizeof(addrtype));
}
}
TRACK(TrackBak,"C_CreateArray\n");
return (STAT);
}
boolean C_CreateSubArray (tokentype    *Token,
numtype       AttrNum,  indextype    ArrayIndex,
indextype     UnitCount,sizetype     UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn,addrtype    *Array)
{
addrtype    This           = NullPtr;
dbheader   *CoreDb         = NullPtr;
numtype     MemLoc         = 0;
numtype     ObjNum         = 0;
addrtype    DbObject       = NullPtr;
addrtype   *FieldMap       = NullPtr;
typesize   *DbOffsets      = NullPtr;
numtype    *FieldAttrs     = NullPtr;
count       i              = 0;
addrtype    DbObjectAddr   = NullPtr;
numtype    *RefObjNums     = NullPtr;
indextype   NumMapFields   = 0;
boolean     Found          = False;
indextype   ExtendQty      = UnitCount;
tokentype   Anchor         = NullToken;
sizetype    ArraySize      = 0;
tokentype   TypeTkn        = NullToken;
typedesctype  *EnvType     = NullPtr;
tokentype   BaseTkn        = NullToken;
addrtype   *BaseArray      = NullPtr;
handletype *ArrayHndls     = NullPtr;
handletype *SubArray       = NullPtr;
indextype   NumSubArrays   = 0;
BaseTkn.DbId    = Token->DbId;
TypeTkn.DbId    = RenvId;
Anchor.DbId     = Token->DbId;
Anchor.Handle   = 1;
if (TmGetCoreDb          (Token,                   McStat,   &CoreDb))
if (HmGetObjectMemLoc    (CoreDb,  Token->Handle,  McStat,   &MemLoc))
if (MemLoc)
if (HmGetObjectAddr      (CoreDb,  Token->Handle,  McStat,   &This))
OaRevokeCppObject    (Token,                   McStat);
if (Normal(*Status))
if (HmGetObjNum          (CoreDb,  Token->Handle,  McStat,   &ObjNum))
if (OaGetObject          (Token,                   McStat,   &DbObject))
if (MemLoc)
OaInvokeCppObject    (Token,   This,           McStat);
if (Normal(*Status))
if (MemGetAddr        (C_ObjMapDir,                       ObjNum,
McStat,               (addrtype *)&FieldMap))
if (FieldMap)
{
DbOffsets       =  (typesize *)FieldMap[0];
FieldAttrs      =  (numtype  *)FieldMap[4];
RefObjNums      =  (numtype  *)FieldMap[5];
NumMapFields    =  (indextype )RefObjNums[0];
i               = 1;
while (Found   == False
&&     i       <= NumMapFields)
{
if (FieldAttrs[i] == AttrNum)
Found = True;
else
++i;
}
if (!Found)
*Status = Trans_ArrayNotOfClass;
} else
*Status = Trans_NullMap;
if (Normal(*Status))
{
TypeTkn.Handle     = RefObjNums[i];
if (OaGetObject   (&TypeTkn,  McStat, (addrtype *)&EnvType))
if ((ArraySize = EnvType->Size) != UnitSize)
{
#ifndef __RISC64__
*Status     = Trans_MixedArraySize;
sprintf (Msg, " C_CreateSubArray:: [%4u:%6u] Attr=%4u; Index=%4u\n",
Token->DbId, Token->Handle, AttrNum, ArrayIndex);
TraceMsg (0,  Msg);
sprintf (Msg, "                   SchemaSize(%4u) != UnitSize(%4u)\n",
ArraySize, UnitSize);
TraceMsg (0,  Msg);
#else
if (ArraySize == 0)
*Status     = Trans_MixedArraySize;
#endif
} else {
DbObjectAddr    =  (addrtype )((char *)DbObject  + DbOffsets[i]);
MoveBytes         (DbObjectAddr, (addrtype )&BaseTkn.Handle,
sizeof(handletype));
if (BaseTkn.Handle == 0)
{
*Status = Trans_NullBaseArray;
}
}
}
if (Normal(*Status))
if (VchunkGetAddress  (&BaseTkn,   McStat,  (addrtype *)&BaseArray))
if (VchunkGetStackPtr (&BaseTkn,   McStat,       &NumSubArrays))
if (NumSubArrays)
if (VchunkCreate      (&Anchor,    UnitSize,      UnitCount,
ExtendQty,  McStat,        VchunkTkn))
if (VchunkPutStackPtr (VchunkTkn,  UnitCount,     McStat,     Array))
if ((NumSubArrays /= 3)   > 0)
{
BaseArray[ArrayIndex]  = *Array;
ArrayHndls             = (handletype *)BaseArray;
SubArray               = (handletype *)&ArrayHndls[NumSubArrays * 2];
SubArray[ArrayIndex]   = VchunkTkn->Handle;
} else
*Status  = Trans_NullBaseArraySize;
TRACK(TrackBak,"C_CreateSubArray\n");
return (STAT);
}
boolean C_CreateFieldArray
(tokentype    *Token,     numtype       AplId,
fieldspec    *FieldTkns, numtype       SubLevel,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype     *Array)
{
addrtype    This           = NullPtr;
dbheader   *CoreDb         = NullPtr;
numtype     MemLoc         = 0;
numtype     ObjNum         = 0;
addrtype    DbObject       = NullPtr;
typesize    DbOffset       = NullPtr;
typesize    CppOffset      = NullPtr;
numtype     AttrId         = NullPtr;
attrtype    AttrType       = aAttr;
numtype     RefObjNum      = NullPtr;
sizetype    FieldSize      = 0;
typetype    FieldType      = aRefObj;
addrtype    DbObjectAddr   = NullPtr;
addrtype    CppObjectAddr  = NullPtr;
indextype   ExtendQty      = UnitCount;
tokentype   Anchor         = NullToken;
sizetype    ArraySize      = 0;
tokentype   TypeTkn        = NullToken;
typedesctype  *EnvType     = NullPtr;
indextype   StackPtr       = 0;
sizetype    DbBase         = 0;
sizetype    CppBase        = 0;
TypeTkn.DbId    = RenvId;
Anchor.DbId     = Token->DbId;
Anchor.Handle   = 1;
if (TmGetCoreDb          (Token,                   McStat,   &CoreDb))
if (HmGetObjectMemLoc    (CoreDb,  Token->Handle,  McStat,   &MemLoc))
if (MemLoc)
if (HmGetObjectAddr      (CoreDb,  Token->Handle,  McStat,   &This))
OaRevokeCppObject    (Token,                   McStat);
if (Normal(*Status))
if (HmGetObjNum          (CoreDb,  Token->Handle,  McStat,   &ObjNum))
if (OaGetObject          (Token,                   McStat,   &DbObject))
if (Normal(*Status))
if (Trans_FetchFieldOffset (Token,      AplId,      FieldTkns,  SubLevel,
McStat,    &FieldSize, &AttrId,    &AttrType,
&RefObjNum, &FieldType, &DbOffset,  &CppOffset,
&DbBase,    &CppBase))
if (MemLoc)
OaInvokeCppObject      (Token,      This,       McStat);
if (Normal(*Status))
{
TypeTkn.Handle    = RefObjNum;
if (OaGetObject   (&TypeTkn,  McStat, (addrtype *)&EnvType))
if (AttrType    == aDblPtrAttr)
{
UnitCount     *= 3;
UnitSize       = sizeof (handletype);
} else if (AttrType != aStrHndlAttr) {
if ((ArraySize = EnvType->Size)    != UnitSize)
*Status     = Trans_MixedArraySize;
}
}
if (Normal(*Status))
if (AttrType   != aStrHndlAttr)
{
if (VchunkCreate      (&Anchor,    UnitSize,      UnitCount,
ExtendQty,  McStat,        VchunkTkn))
if (VchunkGetAddress  (VchunkTkn,  McStat,        Array))
{
DbObjectAddr    =  (addrtype )((char *)DbObject  + DbOffset);
MoveBytes         ((addrtype )&VchunkTkn->Handle,  DbObjectAddr,
sizeof(handletype));
}
if (Normal(*Status))
if (AttrType == aArrayAttr
||  AttrType == aDblPtrAttr)
VchunkPutStackPtr (VchunkTkn,  UnitCount, McStat, (addrtype *)Array);
} else {
*Array = (addrtype )calloc (1, UnitCount);
}
if (Normal(*Status))
if (MemLoc)
{
CppObjectAddr   = (addrtype )((char *)This  + CppOffset);
if (AttrType == aVarrayAttr
||  AttrType == aChunkAttr)
{
MoveBytes  ((addrtype )VchunkTkn,   CppObjectAddr,  sizeof(tokentype));
CppObjectAddr = (addrtype )((char *)CppObjectAddr + sizeof(tokentype));
MoveBytes  ((addrtype )&UnitCount,  CppObjectAddr,  sizeof(indextype));
CppObjectAddr = (addrtype )((char *)CppObjectAddr + sizeof(indextype));
MoveBytes       ((addrtype )Array,  CppObjectAddr,  sizeof(addrtype));
if (AttrType == aChunkAttr)
{
CppObjectAddr = (addrtype )((char *)CppObjectAddr
+ sizeof(addrtype));
MoveBytes  ((addrtype )&StackPtr,  CppObjectAddr,  sizeof(addrtype));
}
} else {
MoveBytes  ((addrtype )Array,       CppObjectAddr,  sizeof(addrtype));
}
}
TRACK(TrackBak,"C_CreateFieldArray\n");
return (STAT);
}
boolean C_CreateFieldSubArray
(tokentype    *Token,     numtype       AplId,
fieldspec    *FieldTkns, numtype       SubLevel,
indextype     ArrayIndex,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,
tokentype    *VchunkTkn, addrtype     *Array)
{
addrtype    This           = NullPtr;
dbheader   *CoreDb         = NullPtr;
numtype     MemLoc         = 0;
numtype     ObjNum         = 0;
addrtype    DbObject       = NullPtr;
typesize    DbOffset       = NullPtr;
typesize    CppOffset      = NullPtr;
numtype     AttrId         = NullPtr;
attrtype    AttrType       = aAttr;
numtype     RefObjNum      = NullPtr;
sizetype    FieldSize      = 0;
typetype    FieldType      = aRefObj;
addrtype    DbObjectAddr   = NullPtr;
indextype   ExtendQty      = UnitCount;
tokentype   Anchor         = NullToken;
sizetype    ArraySize      = 0;
tokentype   TypeTkn        = NullToken;
typedesctype  *EnvType     = NullPtr;
tokentype   BaseTkn        = NullToken;
addrtype   *BaseArray      = NullPtr;
handletype *ArrayHndls     = NullPtr;
handletype *SubArrays      = NullPtr;
indextype   NumSubArrays   = 0;
sizetype    DbBase         = 0;
sizetype    CppBase        = 0;
BaseTkn.DbId    = Token->DbId;
TypeTkn.DbId    = RenvId;
Anchor.DbId     = Token->DbId;
Anchor.Handle   = 1;
if (TmGetCoreDb          (Token,                   McStat,   &CoreDb))
if (HmGetObjectMemLoc    (CoreDb,  Token->Handle,  McStat,   &MemLoc))
if (MemLoc)
if (HmGetObjectAddr      (CoreDb,  Token->Handle,  McStat,   &This))
OaRevokeCppObject    (Token,                   McStat);
if (Normal(*Status))
if (HmGetObjNum          (CoreDb,  Token->Handle,  McStat,   &ObjNum))
if (OaGetObject          (Token,                   McStat,   &DbObject))
if (Normal(*Status))
if (Trans_FetchFieldOffset (Token,      AplId,      FieldTkns,  SubLevel,
McStat,    &FieldSize, &AttrId,    &AttrType,
&RefObjNum, &FieldType, &DbOffset,  &CppOffset,
&DbBase,    &CppBase))
if (MemLoc)
OaInvokeCppObject      (Token,      This,       McStat);
if (Normal(*Status))
{
TypeTkn.Handle     = RefObjNum;
if (OaGetObject   (&TypeTkn,  McStat, (addrtype *)&EnvType))
if ((ArraySize = EnvType->Size) != UnitSize)
{
*Status     = Trans_MixedArraySize;
} else {
DbObjectAddr    =  (addrtype )((char *)DbObject  + DbOffset);
MoveBytes         (DbObjectAddr, (addrtype )&BaseTkn.Handle,
sizeof(handletype));
if (BaseTkn.Handle == 0)
{
*Status = Trans_NullBaseArray;
}
}
}
if (Normal(*Status))
if (VchunkGetAddress  (&BaseTkn,   McStat,  (addrtype *)&BaseArray))
if (VchunkGetStackPtr (&BaseTkn,   McStat,       &NumSubArrays))
if (NumSubArrays)
if (VchunkCreate      (&Anchor,    UnitSize,      UnitCount,
ExtendQty,  McStat,        VchunkTkn))
if (VchunkPutStackPtr (VchunkTkn,  UnitCount,     McStat,     Array))
if ((NumSubArrays /= 3)   > 0)
{
ArrayHndls             = (handletype *)BaseArray;
BaseArray[ArrayIndex]  = *Array;
SubArrays              = (handletype *)&ArrayHndls[NumSubArrays * 2];
SubArrays[ArrayIndex]  = VchunkTkn->Handle;
} else
*Status  = Trans_NullBaseArraySize;
TRACK(TrackBak,"C_CreateFieldSubArray\n");
return (STAT);
}
boolean C_CreateObject (numtype       ObjNum, numtype       AplId,
ft F,lt Z,zz *Status, addrtype     *Object)
{
void*          (*pmf1)(size_t)  = NullPtr;
size_t         ClassSize        = 0;
if (ShellGetObjCode  (ObjNum, McStat, (funcptrtype  *)&pmf1,  &ClassSize))
if (pmf1)
*Object       = (addrtype )(*pmf1)(ClassSize);
else
Core0MoreCore ((bytessizetype    )ClassSize,        McStat, Object);
TRACK(TrackBak,"C_CreateObject\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\trans10.c*/

#define  TRANS10
#define        That_AttrNum           (numtype )1
#define DumpChunkChunk     Mem_DumpChunkChunk


#define MemGetFieldNum      Mem_GetWord
#define MemGetObjNum        Mem_GetWord
#define MemGetLocalObjNum   Mem_GetWord
#define MemGetObjHdr        Mem_GetAddr
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)

boolean    C_ReFaxToDb   (tokentype    *Token,   addrtype      Object,
boolean       Release, boolean       FreeImage,
numtype       AplId,
ft F,lt Z,zz *Status,  bytessize    *ImageSize)
{
dbheader   *CoreDb         = NullPtr;
numtype     MemLoc         = 0;
numtype     ObjNum         = 0;
addrtype    DbObject       = NullPtr;
addrtype   *FieldMap       = NullPtr;
typesize   *DbOffsets      = NullPtr;
typesize   *CppOffsets     = NullPtr;
typesize   *FieldSizes     = NullPtr;
attrtype   *FieldTypes     = NullPtr;
typetype   *TypeTypes      = NullPtr;
numtype    *FieldAttrs     = NullPtr;
numtype    *RefObjNums     = NullPtr;
numtype    *ArrayAttrs     = NullPtr;
indextype   NumArrayAttrs  = 0;
indextype   NumMapFields   = 0;
count       i              = 0;
addrtype    CppObjectAddr  = NullPtr;
addrtype    DbObjectAddr   = NullPtr;
longaddr    NullValue      = 0;
statustype  DumpStatus     = Env_Normal;
boolean     PureDbStruc    = False;
typesize    ObjSize        = 0;
sizetype    TransferSize   = 0;
indextype   ThatIndex      = 0;
tokentype   ObjDescTkn;
objdesctype *ObjDesc       = NullPtr;
addrtype    CppRefObj      = NullPtr;
tokentype  *CppRefTkn      = NullPtr;
addrtype   *CppRefPtr      = NullPtr;
tokentype  *DbRefTkn       = NullPtr;
addrtype    DbRefObj       = NullPtr;
tokentype   AttrTkn        = NullToken;
attrdesctype *EnvAttr      = NullPtr;
numtype     LocalObj       = 0;
objheader  *ObjHdr         = NullPtr;
longtype    LongIndex      = 0;
indextype   StrIndex       = 0;
char       *StrAddr        = NullPtr;
int         k              = 0;
indextype   AttrCount      = 0;
typesize    AttrDbSize     = 0;
typesize    Attr01Size     = 0;
typesize    BaseDbOffset   = 0;
typesize    Base01Offset   = 0;
tokentype      VchunkTkn      = NullToken;
tokentype      DblPtrTkn      = NullToken;
numtype        InCore         = 0;
vchunktkntype  DblVchunk;
vchunktkntype  Vchunk;
chunkstruc     ChunkStruc;
int            j              = 0;
handletype    *ArrayHndls     = NullPtr;
handletype    *SubArrays      = NullPtr;
addrtype      *Arrays         = NullPtr;
indextype      Index          = 0;
indextype      NumSubArrays   = 0;
numtype        IndexInCore    = 0;
static boolean        FirstTime             = True;
static boolean        FirstTime_ObjRef      = True;
AttrTkn.DbId      = Token->DbId;
VchunkTkn.DbId    = Token->DbId;
DblPtrTkn.DbId    = Token->DbId;
if (Normal(*Status))
if (TmGetCoreDb       (Token,                   McStat,        &CoreDb))
if (HmGetObjectMemLoc (CoreDb,  Token->Handle,  McStat,        &MemLoc))
if (MemLoc)
{
HmGetObjectAddr   (CoreDb,  Token->Handle,  McStat,        &Object);
} else
return (STAT);
if (Normal(*Status))
if (OaRevokeCppObject (Token,                   McStat))
if (HmGetObjNum       (CoreDb,  Token->Handle,  McStat,        &ObjNum))
if (OaGetObject       (Token,                   McStat,        &DbObject))
if (Normal(*Status))
if (MemGetAddr        (C_ObjMapDir,                            ObjNum,
McStat,                     (addrtype *)&FieldMap))
if (FieldMap)
{
DbOffsets    =  (typesize *)FieldMap[0];
CppOffsets   =  (typesize *)FieldMap[1];
FieldSizes   =  (typesize *)FieldMap[2];
FieldTypes   =  (attrtype *)FieldMap[3];
FieldAttrs   =  (numtype  *)FieldMap[4];
RefObjNums   =  (numtype  *)FieldMap[5];
ArrayAttrs   =  (numtype  *)FieldMap[6];
TypeTypes    =  (typetype *)FieldMap[7];
NumMapFields =  (indextype )RefObjNums[0];
NumArrayAttrs=  (indextype )ArrayAttrs[0];
PureDbStruc  =  (boolean   )DbOffsets[0];
ObjSize      =  (typesize  )CppOffsets[0];
ThatIndex    =  (indextype )TypeTypes[0];
*ImageSize    =  (bytessize )CppOffsets[0];
CppObjectAddr    = (addrtype )((char *)Object + CppOffsets[ThatIndex]);
} else
*Status = Trans_NullMap;
if (Normal(*Status))
if (PureDbStruc   == False
||  NumArrayAttrs  > 0)
{
while (++i <= NumMapFields
&&     Normal(*Status))
{
TransferSize       = FieldSizes[i];
CppObjectAddr      = (addrtype )((char *)Object   + CppOffsets[i]);
DbObjectAddr       = (addrtype )((char *)DbObject + DbOffsets[i]);
if (FieldAttrs[i] == That_AttrNum)
CppObjectAddr    = &NullValue;
if ((AttrCount    = AttrTypeSizes[FieldTypes[i]]) != 1)
{
Attr01Size     = AttrCount;
AttrDbSize     = AttrCount;
AttrCount      = FieldSizes[i] / AttrCount;
if (FieldTypes[i] == aSetHeadAttr
||  FieldTypes[i] == aSetNodeAttr)
{
AttrCount      = 1;
}
} else
Attr01Size     = 0;
BaseDbOffset      = 0;
Base01Offset      = 0;
k                 = 0;
if (FieldAttrs[i] != That_AttrNum)
while (k++ < AttrCount)
{
CppObjectAddr   = (addrtype )((char *)CppObjectAddr + Base01Offset);
DbObjectAddr    = (addrtype )((char *)DbObjectAddr  + BaseDbOffset);
switch (FieldTypes[i])
{
case aObjRefAttr   :
if (FirstTime_ObjRef)
if (ClassBug          == True)
FirstTime_ObjRef    = False;
CppRefPtr = (addrtype *)((char *)Object    + CppOffsets[i]);
DbRefTkn  = (tokentype *)((char *)DbObject  + DbOffsets[i]);
CppRefObj = *CppRefPtr;
if (((tokentype *)DbRefTkn)->Handle == 0)
if (CppRefObj       != NullPtr)
					C_RefToTkn  (CppRefObj,  RefObjNums[i],     AplId,
									 McStat,           (tokentype *)DbRefTkn);
				 else {
					 OaDumpObject (0,  Token, Dump_Status);
				 }
				 if (FirstTime_ObjRef)
				 {
					 FirstTime_ObjRef   = False;
				 }
					break;
			 case aPortRefAttr  :
					break;
			 case aTknRefAttr   :
				 DbRefTkn  = (tokentype *)((char *)DbObject  + DbOffsets[i]);
				 if (FirstTime)
				 if (ClassBug   == True)
					 FirstTime    = False;
				 CppRefPtr = (addrtype *)CppObjectAddr;
				 CppRefObj = *CppRefPtr;
				 CppRefTkn = (tokentype *)((char *)CppObjectAddr
							  + sizeof (addrtype));
				 DbRefObj  = (addrtype  )DbObjectAddr;
				 if (CppRefTkn->DbId && CppRefTkn->Handle)
				 {
					 MoveBytes     (CppRefTkn,   DbObjectAddr,  sizeof(tokentype));
				 } else if (CppRefObj != NullPtr) {
					 if (EnvFetchAttrHandle (FieldAttrs[i],
													 McStat,        &AttrTkn.Handle))
					 if (OaGetObject        (&AttrTkn,
													 McStat,    (addrtype *)&EnvAttr))
					 {
						 ObjDescTkn.DbId    = RenvId;
						 ObjDescTkn.Handle  = EnvAttr->BuildDesc;
					 }
					 if (Normal(*Status))
					 if (OaGetObject   (&ObjDescTkn, McStat, (addrtype *)&ObjDesc))
						  C_RefToTkn   (CppRefObj,  ObjDesc->ObjNum, AplId,
											  McStat,        (tokentype *)DbObjectAddr);
				 } else  {
					 MoveBytes     (&NullToken,  DbObjectAddr,  sizeof(tokentype));
				 }
				 if (FirstTime)
				 {
					 FirstTime   = False;
				 }
				 break;
			 case aStrHndlAttr  :
					LongIndex = *(longtype *)DbObjectAddr;
					StrIndex  = LongIndex;
					StrAddr   = *(char **)CppObjectAddr;
					if (HmGetLocalObjNum (CoreDb, Token->Handle, McStat, &LocalObj))
					if (OmGetObjHdr      (Token,  LocalObj,      McStat, &ObjHdr))
					if (StrAddr)
							OaDumpObject (0, Token, McStat);
					if (StrAddr)
					if (StrIndex == 0)
					{
						if (OaPutString (Token->DbId,   ObjHdr,   StrAddr,
											  McStat,                 &StrIndex))
							 MoveBytes   ((addrtype )&StrIndex,    DbObjectAddr,
												sizeof (indextype));
					} else
						 MemPutString   (ObjHdr->TextChunk,       StrIndex,
											  (char *)CppObjectAddr,   McStat);
					if (StrAddr != NullPtr
					&&  Release == True)
					{
						Core0_FreeString (StrAddr,   McStat);
					}
					break;
			 case aChunkAttr    :
			 case aVarrayAttr   :
case aArrayAttr    :
case aVchunkAttr   :
if (FieldTypes[i] == aArrayAttr)
{
VchunkTkn.Handle  =  *(handletype *)DbObjectAddr;
VchunkTkn.DbId    =  Token->DbId;
TransferSize      =  sizeof (handletype);
} else if(FieldTypes[i] == aVchunkAttr)  {
MoveBytes (CppObjectAddr, DbObjectAddr, FieldSizes[i]);
VchunkTkn         =  *(tokentype *)DbObjectAddr;
TransferSize      =  FieldSizes[i];
} else {
VchunkTkn =  *(tokentype *)CppObjectAddr;
MoveBytes (CppObjectAddr, DbObjectAddr, FieldSizes[i]);
TransferSize      =  FieldSizes[i];
}
if (VchunkTkn.DbId   > 0
&&  VchunkTkn.Handle > 0)
{
if (DbmGetVchunkTkn (&VchunkTkn, McStat,      &Vchunk))
if ((InCore = Vchunk.InCore) > 0)
#ifdef   __FREEZE_VCHUNKS__
DbmCommitVchunk (&VchunkTkn,   Release,    McStat);
#else
if (FileOutChunk    (&Vchunk.InCore,
&(CoreDb->BlkHdr),        Release,
McStat,                  &Vchunk.OnDisk))
DbmPutVchunkTkn (&VchunkTkn,   &Vchunk,    McStat);
#endif
}
break;
case aGrpAttr    :
case aVgrpAttr   :
TransferSize      = FieldSizes[i];
MoveBytes (CppObjectAddr, DbObjectAddr, FieldSizes[i]);
VchunkTkn         =  *(tokentype *)DbObjectAddr;
break;
case aDblPtrAttr   :
TransferSize      = 4;
DblPtrTkn.Handle  =  *(handletype *)DbObjectAddr;
DblPtrTkn.DbId    =  Token->DbId;
if (DblPtrTkn.Handle > 0)
if (DbmGetVchunkTkn (&DblPtrTkn,   McStat,     &DblVchunk))
if ((InCore          = DblVchunk.InCore) > 0)
{
if (VchunkGetAddress
(&DblPtrTkn,
McStat,      (addrtype *)&Arrays))
if (VchunkGetVstruc
(&DblPtrTkn,  McStat,     &ChunkStruc))
{
ArrayHndls    = (handletype *)Arrays;
NumSubArrays  = ChunkStruc.StackPtr / 3;
SubArrays     = (handletype *)&ArrayHndls[NumSubArrays * 2];
}
j = -1 ;
while (Normal(*Status)
&&     ++j      < NumSubArrays)
{
#ifdef __BCC_45__
memcpy  (&Index,
&SubArrays[j], sizeof (handletype));
#else
Index            = SubArrays[j];
#endif
VchunkTkn.Handle = Index;
if (Index)
if (DbmGetVchunkTkn
(&VchunkTkn,     McStat,     &Vchunk))
if ((IndexInCore  = Vchunk.InCore) >  0)
#ifdef   __FREEZE_VCHUNKS__
DbmCommitVchunk (&VchunkTkn,   Release,  McStat);
#else
if (FileOutChunk
(&Vchunk.InCore,
&(CoreDb->BlkHdr),           Release,
McStat,              &Vchunk.OnDisk))
DbmPutVchunkTkn (&VchunkTkn,     &Vchunk,McStat);
#endif
}
if (Normal(*Status))
#ifdef   __FREEZE_VCHUNKS__
DbmCommitVchunk
(&DblPtrTkn,   Release,  McStat);
#else
if (FileOutChunk (&DblVchunk.InCore,
&(CoreDb->BlkHdr),            Release,
McStat,            &DblVchunk.OnDisk))
DbmPutVchunkTkn
(&DblPtrTkn,        &DblVchunk,McStat);
#endif
}
break;
case aMapRefAttr   :
C_MapRefToDb   (Token->DbId,  RefObjNums[i],    FieldSizes[i],
DbObjectAddr, CppObjectAddr,    AplId,
Release,      McStat);
if (DeBug || OaBug || ClassBug)
TraceMsg (0, "   End of Embedded Object\n\n");
break;
case aSetNodeAttr  :
case aSetHeadAttr  :
case aAttr         :
case aSlotHndlAttr :
case aSlotTokenAttr:
default       :
TransferSize = FieldSizes[i];
MoveBytes (CppObjectAddr, DbObjectAddr, FieldSizes[i]);
break;
}
if (DeBug || OaBug || ClassBug)
switch (FieldTypes[i])
{
case aObjRefAttr   :
case aPortRefAttr  :
case aTknRefAttr   :
case aMapRefAttr   :
break;
default            :
	       break;
}
Base01Offset  += Attr01Size;
BaseDbOffset  += AttrDbSize;
}
}
} else {
MoveBytes   (Object,   DbObject,   ObjSize);
}
if (Normal(*Status))
if (ThatIndex)
{
CppObjectAddr    = &NullValue;
DbObjectAddr     = (addrtype )((char *)DbObject + DbOffsets[ThatIndex]);
#ifdef IMAGE_WITH_THAT
MoveBytes   (CppObjectAddr, DbObjectAddr,   sizeof (addrtype));
#endif
}
if (Normal(*Status))
OaUpdateObject    (Token,           McStat);
if (ClassBug || DeBug || OaBug)
OaDumpObject  (0, Token, Dump_Status);
DbObject   = Object;
if (Normal(*Status))
if (!Release)
OaInvokeCppObject (Token,  Object,  McStat);
else {
if (FreeImage)
{
if (AplId == Cpp_Apl)
Core0FreeCoreSpace  (&Object, (bytessize   )ObjSize, McStat);
else
Core0FreeCoreSpace  (&Object, (bytessize   )ObjSize, McStat);
}
}
TRACK(TrackBak,"C_ReFaxToDb\n");
return (STAT);
}
boolean    C_GroupArrays (tokentype    *Token,   addrtype      Object,
boolean       Release, numtype       AplId,
ft F,lt Z,zz *Status)
{
TRACK(TrackBak,"C_GroupArrays\n");
return (STAT);
}
boolean    C_MapRefToDb   (idtype        DbId,      numtype       ObjNum,
sizetype      MapSize,   addrtype      DbObject,
addrtype      Object,    numtype       AplId,
boolean       Release,   ft F,lt Z,zz *Status)
{
dbheader   *CoreDb         = NullPtr;
addrtype   *FieldMap       = NullPtr;
typesize   *DbOffsets      = NullPtr;
typesize   *CppOffsets     = NullPtr;
typesize   *FieldSizes     = NullPtr;
attrtype   *FieldTypes     = NullPtr;
numtype    *FieldAttrs     = NullPtr;
numtype    *RefObjNums     = NullPtr;
numtype    *ArrayAttrs     = NullPtr;
indextype   NumArrayAttrs  = 0;
indextype   NumMapFields   = 0;
count       i              = 0;
addrtype    BaseCppAddr    = NullPtr;
addrtype    BaseDbAddr     = NullPtr;
sizetype    DbObjSize      = 0;
addrtype    CppObjectAddr  = NullPtr;
addrtype    DbObjectAddr   = NullPtr;
boolean     PureDbStruc    = False;
typesize    ObjSize        = 0;
sizetype    TransferSize   = 0;
tokentype   ObjDescTkn;
objdesctype *ObjDesc     = NullPtr;
addrtype    CppRefObj    = NullPtr;
tokentype  *CppRefTkn    = NullPtr;
addrtype   *CppRefPtr    = NullPtr;
addrtype    DbRefTkn     = NullPtr;
addrtype    DbRefObj     = NullPtr;
attrdesctype *EnvAttr    = NullPtr;
numtype     LocalObj       = 0;
objheader  *ObjHdr         = NullPtr;
longtype    LongIndex      = 0;
indextype   StrIndex       = 0;
char       *StrAddr        = NullPtr;
int         l              = 0;
indextype   NumMaps        = 0;
int         k              = 0;
indextype   AttrCount      = 0;
typesize    AttrDbSize     = 0;
typesize    Attr01Size     = 0;
typesize    BaseDbOffset   = 0;
typesize    Base01Offset   = 0;
if (Normal(*Status))
if (MemGetAddr        (C_ObjMapDir,                            ObjNum,
McStat,                     (addrtype *)&FieldMap))
if (FieldMap == NullPtr)
{
if (EnvFetchObjSize   (ObjNum,        McStat,               &ObjSize))
if (ImageInitClassMap (ObjNum,        ObjSize,    C_Apl,     McStat))
if (TransInvokeMap    (C_Apl,         McStat))
if (TransBuildMap     (C_Apl,         McStat))
if (MemGetAddr        (C_ObjMapDir,                          ObjNum,
McStat,                  (addrtype *)&FieldMap))
if (FieldMap == NullPtr)
*Status = Trans_NullMap;
}
if (Normal(*Status))
if (FieldMap)
{
DbOffsets    =  (typesize *)FieldMap[0];
CppOffsets   =  (typesize *)FieldMap[1];
FieldSizes   =  (typesize *)FieldMap[2];
FieldTypes   =  (attrtype *)FieldMap[3];
FieldAttrs   =  (numtype  *)FieldMap[4];
RefObjNums   =  (numtype  *)FieldMap[5];
ArrayAttrs   =  (numtype  *)FieldMap[6];
NumMapFields =  (indextype )RefObjNums[0];
NumArrayAttrs=  (indextype )ArrayAttrs[0];
PureDbStruc  =  (boolean   )DbOffsets[0];
ObjSize      =  (typesize  )CppOffsets[0];
}
if (Normal(*Status))
if (!PureDbStruc
||  NumArrayAttrs > 0)
{
EnvFetchObjSize (ObjNum,  McStat, &DbObjSize);
NumMaps       =  MapSize / DbObjSize;
l             = 0;
while (Normal(*Status)
&&     ++l   <= NumMaps)
{
BaseDbAddr  = (addrtype )((char *)DbObject  +
((l-1) * DbObjSize));
BaseCppAddr = (addrtype )((char *)Object
+ ((l-1) * ObjSize));
i           = 0;
while (++i <= NumMapFields
&&     Normal(*Status))
{
TransferSize      = FieldSizes[i];
DbObjectAddr      = (addrtype )((char *)BaseDbAddr  + DbOffsets[i]);
CppObjectAddr     = (addrtype )((char *)BaseCppAddr + CppOffsets[i]);
if ((AttrCount    = AttrTypeSizes[FieldTypes[i]]) != 1)
{
Attr01Size     = AttrCount;
AttrDbSize     = AttrCount;
AttrCount      = FieldSizes[i] / AttrCount;
} else
Attr01Size     = 0;
BaseDbOffset      = 0;
Base01Offset      = 0;
k                 = 0;
if (FieldAttrs[i] != That_AttrNum)
while (k++ < AttrCount)
{
DbObjectAddr  = (addrtype )((char *)DbObjectAddr  + BaseDbOffset);
CppObjectAddr = (addrtype )((char *)CppObjectAddr + Base01Offset);
switch (FieldTypes[i])
{
case aObjRefAttr   :
CppRefPtr = (addrtype *)((char *)Object    + CppOffsets[i]);
DbRefTkn  = (addrtype  )((char *)DbObject  + DbOffsets[i]);
CppRefObj = *CppRefPtr;
if ((CppRefObj = *CppRefPtr) != 0)
C_RefToTkn  (CppRefObj,  RefObjNums[i],  AplId,
McStat,        (tokentype *)DbRefTkn);
break;
case aPortRefAttr  :
break;
case aTknRefAttr   :
CppRefPtr = (addrtype *)CppObjectAddr;
CppRefObj = *CppRefPtr;
CppRefTkn = (tokentype *)((char *)CppObjectAddr
+ sizeof (addrtype));
DbRefObj  = (addrtype  )DbObjectAddr;
if (CppRefTkn->DbId && CppRefTkn->Handle)
{
MoveBytes     (CppRefTkn,   DbObjectAddr,  sizeof(tokentype));
} else if (CppRefObj != NullPtr) {
ObjDescTkn.DbId    = RenvId;
ObjDescTkn.Handle  = EnvAttr->BuildDesc;
if (OaGetObject (&ObjDescTkn, McStat, (addrtype *)&ObjDesc))
C_RefToTkn  (CppRefObj,   ObjDesc->ObjNum,   AplId,
McStat,      (tokentype *)DbObjectAddr);
} else  {
MoveBytes     (&NullToken,  DbObjectAddr,  sizeof(tokentype));
}
break;
case aStrHndlAttr  :
LongIndex = *(longtype *)DbObjectAddr;
StrIndex  = LongIndex;
StrAddr   = *(char **)CppObjectAddr;
if (MemGetLocalObjNum (CoreDb->LocalObjNumMap,  ObjNum,
McStat,                 &LocalObj))
if (MemGetObjHdr      (CoreDb->ObjHdrDir,       LocalObj,
McStat,     (addrtype *)&ObjHdr))
if (StrIndex == 0)
{
if (OaPutString    (DbId,   ObjHdr,          StrAddr,
McStat,                 &StrIndex))
MoveBytes      ((addrtype )&LongIndex,   DbObjectAddr,
sizeof (indextype));
} else
MemPutString   (ObjHdr->TextChunk,         StrIndex,
(char *)CppObjectAddr,     McStat);
break;
case aVchunkAttr   :
case aChunkAttr    :
case aArrayAttr    :
case aVarrayAttr   :
case aDblPtrAttr   :
TransferSize = 0;
break;
case aMapRefAttr   :
C_MapRefToDb  (DbId,         RefObjNums[i],    FieldSizes[i],
DbObjectAddr, CppObjectAddr,    AplId,
Release,      McStat);
break;
case aSetNodeAttr  :
case aSetHeadAttr  :
AttrCount      = 1;
case aAttr         :
case aSlotHndlAttr :
case aSlotTokenAttr:
default       :
TransferSize = FieldSizes[i];
MoveBytes    (CppObjectAddr, DbObjectAddr, FieldSizes[i]);
break;
}
if (DeBug || OaBug || ClassBug)
switch (FieldTypes[i])
{
case aObjRefAttr   :
case aPortRefAttr  :
case aTknRefAttr   :
case aMapRefAttr   :
break;
default            :
	       break;
}
BaseDbOffset  += AttrDbSize;
Base01Offset  += Attr01Size;
}
}
}
} else {
MoveBytes   (Object,   DbObject,   MapSize);
}
TRACK(TrackBak,"C_MapRefToDb\n");
return (STAT);
}
boolean C_RefToTkn      (addrtype      ThisObj, numtype      ObjNum,
numtype       AplId,
ft F,lt Z,zz *Status,  tokentype   *ObjTkn)
{
tokentype               (*pmf1)(addrtype)        = NullPtr;
if (AplId == Cpp_Apl)
{
CppRefToTkn      (ThisObj, ObjNum, McStat, ObjTkn);
if (Normal(*Status))
return (STAT);
if (*Status    == Trans_CppShellNotInvoked)
*Status     = Env_Normal;
}
if (Normal(*Status))
{
if (ThisObj)
{
if (ShellGetTokenCode  (ObjNum, McStat, (funcptrtype  *)&pmf1))
if (pmf1)
{
*ObjTkn    = (*pmf1)(ThisObj);
} else {
if (ThisObj == *(addrtype *)ThisObj)
ThisObj  = (addrtype )((char *)ThisObj + sizeof (addrtype));
*ObjTkn    = *(tokentype *)ThisObj;
}
} else
*ObjTkn    = NullToken;
}
strcpy (TrackBak, "C_RefToTkn\n");
return (STAT);
}
boolean    C_CommitClass    (tokentype    *Token,   numtype       ClassId,
numtype       AplId,   ft F,lt Z,zz *Status)
{
dbheader   *CoreDb         = NullPtr;
tokentype   ObjTkn         = NullToken;
numtype     MemLoc         = 0;
numtype     ObjNum         = 0;
addrtype    This           = NullPtr;
handletype  Handle         = 0;
numtype     Count          = 0;
boolean     Release        = True;
boolean     FreeMem        = True;
bytessize   ImageSize      = 0;
if (TmGetCoreDb     (Token,                   McStat,   &CoreDb))
ObjTkn.DbId  = Token->DbId;
while (Normal(*Status)
&&     ++Handle < CoreDb->HandleCount)
{
ObjTkn.Handle  = Handle;
if (HmGetObjectMemLoc    (CoreDb,  ObjTkn.Handle,  McStat,   &MemLoc))
if (MemLoc)
if (HmGetObjNum          (CoreDb,  ObjTkn.Handle,  McStat,   &ObjNum))
if (ObjNum == ClassId)
{
Count++;
C_ReFaxToDb           (&ObjTkn, This,  Release, FreeMem,   AplId,
McStat, &ImageSize);
}
}
TRACK(TrackBak,"C_CommitClass\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\trans20.c*/

#define  TRANS20
#define        That_AttrNum           (numtype )1
#define MemGetFieldNum      Mem_GetWord
#define MemGetObjNum        Mem_GetWord
#define MemGetLocalObjNum   Mem_GetWord
#define MemGetObjHdr        Mem_GetAddr
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)

boolean    C_FreeClass    (idtype        DbId,    numtype       ClassId,
numtype       AplId,   ft F,lt Z,zz *Status)
{
*Status = Err_NotImplemented;
TRACK(TrackBak,"C_FreeClass\n");
return (STAT);
}
boolean    C_FreeObject    (tokentype    *Token,     numtype       AplId,
boolean       FreeImage, ft F,lt Z,zz *Status)
{
*Status = Err_NotImplemented;
TRACK(TrackBak,"C_FreeObject\n");
return (STAT);
}
boolean    C_DeleteObject (tokentype    *Token,   numtype       AplId,
ft F,lt Z,zz *Status)
{
dbheader   *CoreDb         = NullPtr;
numtype     MemLoc         = 0;
addrtype    Image          = NullPtr;
numtype     ObjNum         = 0;
addrtype    DbObject       = NullPtr;
addrtype   *FieldMap       = NullPtr;
typesize   *DbOffsets      = NullPtr;
typesize   *CppOffsets     = NullPtr;
typesize   *FieldSizes     = NullPtr;
attrtype   *FieldTypes     = NullPtr;
numtype    *FieldAttrs     = NullPtr;
numtype    *RefObjNums     = NullPtr;
indextype   NumMapFields   = 0;
typesize    ObjSize        = 0;
tokentype   DbToken        = *Token;
if (TmGetCoreDb          (Token,                   McStat,   &CoreDb))
if (HmGetObjNum          (CoreDb,  Token->Handle,  McStat,   &ObjNum))
if (Normal(*Status))
if (HmGetObjectMemLoc    (CoreDb,  Token->Handle,  McStat,   &MemLoc))
if (MemLoc)
{
if (HmGetObjectAddr    (CoreDb,  Token->Handle,  McStat,  &Image))
if (HmPutObjectAddr    (CoreDb,  Token->Handle,  NullPtr,  McStat))
if (HmPutObjectMemLoc  (CoreDb,  Token->Handle,  0,        McStat))
OaGetObject        (Token,   McStat,        &DbObject);
if (Normal(*Status))
if (MemGetAddr        (C_ObjMapDir,                            ObjNum,
McStat,                     (addrtype *)&FieldMap))
if (FieldMap)
{
DbOffsets    =  (typesize *)FieldMap[0];
CppOffsets   =  (typesize *)FieldMap[1];
FieldSizes   =  (typesize *)FieldMap[2];
FieldTypes   =  (attrtype *)FieldMap[3];
FieldAttrs   =  (numtype  *)FieldMap[4];
RefObjNums   =  (numtype  *)FieldMap[5];
NumMapFields =  (indextype )RefObjNums[0];
ObjSize      =  (typesize  )CppOffsets[0];
} else
*Status = Trans_NullMap;
}
if (Normal(*Status))
{
OaDelete           (&DbToken,      McStat);
}
if (MemLoc)
if (Normal(*Status))
if (AplId == Cpp_Apl)
Core0FreeCoreSpace  (&Image, (bytessize )ObjSize, McStat);
else
Core0FreeCoreSpace  (&Image, (bytessize )ObjSize, McStat);
TRACK(TrackBak,"C_DeleteObject\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\tree0.c*/

#define  TREE0
#define  TREE00
/* 当前文件是./CINT2000\255.vortex\src\tree00.h*/

#ifndef TREE00_H
#define TREE00_H
typedef enum   TypeTreeOp
{aTreeAddInto,  aTreeFindIn, aTreeDeleteFrom,
aTreeTraverse, aTreeDelete, aNonTreeOp=EXT_ENUM } treeoptype;
tokentype   AddInto_MemberTkn  = Null_Token;
addrtype    FindIn_2aryKey     = NullPtr;
treeoptype  Tree_OpType        = aNonTreeOp;

typedef struct bTreeSetHeadType
{
addrtype       This;
tokentype      Token;
numtype        PrimaryKey;
numtype        Key2ary;
handletype     BuildDesc;
handletype     lOwnerObject;
sizetype       KeySize;
typetype       KeyType;
idtype         TreeDbId;
numtype        TreeOrder;
numtype        TreeNodesDir;
indextype      TreeRootNode;
sizetype       NodeSize;
numtype        NodeCount;
numtype        KeyCount;
numtype        TreeKeysDir;
numtype        MaxKeys;
numtype        MinKeys;
indextype     *TempKeys;
handletype    *TempHandles;
handletype    *TempLeafs;
}             btreesethead;
typedef btreesethead   ltreesethead;
typedef struct lBtreeNodeType
{
indextype      Index;
indextype      ParentNode;
numtype        NumKeys;
indextype     *NodeKeys;
handletype    *NodeHandles;
indextype     *NodeLeafs;
}             lbtreenode;
typedef lbtreenode     btreenode;
typedef int  (*ptr_TreeCompare )  (addrtype    Value1, addrtype    Value2);
typedef ptr_TreeCompare  treecompfunc;
boolean    Tree_AddInto
(ltreesethead  *SetHead,     addrtype       KeyValue,
handletype     Handle,      ft F,lt Z,zz  *Status);
boolean    Tree_FindIn
(ltreesethead  *SetHead,     addrtype       KeyValue,
ft F,lt Z,zz  *Status,
lbtreenode   **LeafNode,    indextype     *KeyPos);
boolean    Tree_Traverse
(ltreesethead  *SetHead,     indextype      LeafIndex,
numtype       *IterNum,     treeiterfunc   IterFunc,
ft F,lt Z,zz  *Status);
boolean    Tree_Validate
(ltreesethead  *SetHead,     indextype      LeafIndex,
numtype       *IterNum,     ft F,lt Z,zz  *Status);
boolean    Tree_IterateOn
(ltreesethead  *SetHead,      ft F,lt Z,zz  *Status,
indextype     *CurrLeaf,     indextype     *KeyPos,
numtype       *IterNum,      handletype    *Handle);
boolean    Tree_Delete
(ft F,lt Z,zz *Status,       ltreesethead **SetHead);
boolean    Tree_DeleteNode
(ltreesethead  *SetHead,     indextype     NodeIndex,
ft F,lt Z,zz  *Status);
boolean    Tree_DeleteFrom
(ltreesethead  *SetHead,     addrtype       KeyValue,
ft F,lt Z,zz  *Status,      handletype    *Handle);
#ifndef __GUI__
boolean    Tree_Compare2aryKey
(ltreesethead *SetHead,      handletype    ObjHandle,
ft F,lt Z,zz *Status);
#endif
#ifdef TREE00
boolean    Tree_PromoteRootNode
(ltreesethead  *SetHead,
indextype      RootKey,     handletype     RootHandle,
lbtreenode    *LessNode,    lbtreenode    *GtrNode,
ft F,lt Z,zz  *Status);
boolean    Tree_PromoteInternalNode
(ltreesethead  *SetHead,
lbtreenode    *LeafNode,    indextype      ParentIndex,
indextype      KeyIndex,    handletype     KeyHandle,
ft F,lt Z,zz  *Status);
boolean    Tree_RecurseSearch
(ltreesethead  *SetHead,     addrtype       KeyValue,
indextype      Index,       ft F,lt Z,zz  *Status,
lbtreenode   **LeafNode,    indextype     *KeyPos);
boolean    Tree_GetRecursePos
(ltreesethead *SetHead,      addrtype      KeyValue,
lbtreenode   *LeafNode,
ft F,lt Z,zz *Status,       indextype    *KeyPos);
boolean    Tree_CreateNode
(ltreesethead  *SetHead,     ft F,lt Z,zz  *Status,
indextype     *Index,       lbtreenode   **TreeNode);
boolean    Tree_GetFrozenNode
(ltreesethead  *SetHead,     indextype      Index,
ft F,lt Z,zz  *Status,      lbtreenode   **LeafNode);
boolean    Tree_FreezeNode
(ltreesethead  *SetHead,     indextype      Index,
ft F,lt Z,zz  *Status);
boolean    Tree_DefrostNode
(ltreesethead  *SetHead,     indextype      Index,
ft F,lt Z,zz  *Status);
boolean    Tree_NodeIsFrosted
(ltreesethead  *SetHead,     indextype      Index,
ft F,lt Z,zz  *Status);
void       Tree_DumpNode
(ltreesethead  *SetHead,     lbtreenode    *LeafNode);
boolean    Tree_NewKey
(ltreesethead  *SetHead,     addrtype       KeyValue,
ft F,lt Z,zz  *Status,      indextype     *Index);
boolean    Tree_GetFrozenKey
(ltreesethead  *SetHead,     indextype     *Index,
ft F,lt Z,zz  *Status,      addrtype      *KeyValue);
boolean    Tree_DefrostKey
(ltreesethead  *SetHead,     indextype      Index,
ft F,lt Z,zz  *Status);
boolean    Tree_GetNodeInsertPos
(ltreesethead *SetHead,      indextype     KeyIndex,
lbtreenode   *LeafNode,
ft F,lt Z,zz *Status,       indextype    *KeyPos);
boolean    Tree_CompareKey
(ltreesethead *SetHead,      addrtype      CompValue,
indextype     KeyIndex,     handletype    ObjHandle,
ft F,lt Z,zz *Status);
boolean    Tree_Adjust
(ltreesethead  *SetHead,     lbtreenode   *LeafNode,
ft F,lt Z,zz  *Status);
boolean    Tree_Redistribute
(ltreesethead  *SetHead,     indextype     KeyPos,
lbtreenode    *LessNode,    lbtreenode   *ParentNode,
lbtreenode    *GtrNode,     ft F,lt Z,zz *Status);
boolean    Tree_Concatenate
(ltreesethead  *SetHead,     indextype     KeyPos,
lbtreenode    *LessNode,    lbtreenode   *ParentNode,
lbtreenode    *GtrNode,     ft F,lt Z,zz *Status);
boolean    Tree_Devoid
(ft F,lt Z,zz *Status,       ltreesethead **SetHead);
boolean    Tree_DeleteByName
(tokentype    *Anchor,       nametype       TreeName,
ft F,lt Z,zz *Status);
boolean    Tree_Test
(tokentype     *Anchor,      numtype       Option,
ft F,lt Z,zz  *Status);
#endif
#endif

boolean Test_Iterate
(tokentype    *Token,     indextype     IterNum,
ft F,lt Z,zz *Status);
boolean Tree_Test (tokentype    *Anchor,    numtype       Option,
ft F,lt Z,zz *Status);
boolean    Tree_DeleteFrom
(ltreesethead  *SetHead,     addrtype      KeyValue,
ft F,lt Z,zz  *Status,      handletype   *Handle)
{
lbtreenode      *DeleteNode      = NullPtr;
lbtreenode      *SuccNode        = NullPtr;
indextype        SuccIndex       = 0;
indextype        KeyPos          = 0;
int              Pos             = 0;
indextype        DeleteKeyPos    = 0;
tokentype        TreeTkn         = NullToken;
numtype          IterNum  = 0;
boolean          TempSetBug  = False;
TreeTkn.DbId    = SetHead->TreeDbId;
TreeTkn.Handle  = 1;
if (SetBug)
if (sprintf (Msg,
"   Tree_DeleteEntry:: SetHead[%4u:%6u] for KeyValue @%6x;\n",
SetHead->TreeDbId, SetHead->Token.Handle, KeyValue))
TraceMsg (0, Msg);
Tree_FindIn      (SetHead, KeyValue, McStat, &DeleteNode, &KeyPos);
if (*Status == Set_Found)
{
*Status    = Env_Normal;
*Handle    = DeleteNode->NodeHandles[KeyPos];
DeleteNode->NodeHandles[KeyPos] = 0;
DeleteKeyPos = 0;
DeleteNode->NodeKeys[KeyPos] = 0;
}
if (GrpBug || SetBug)
if (sprintf (Msg, "\n   Delete node[%4u:%6u] from tree::\n",
SetHead->TreeDbId, DeleteNode->Index))
if (TraceMsg  (0, Msg))
Tree_DumpNode     (SetHead,    DeleteNode);
if (Normal(*Status))
if (Tree_FreezeNode   (SetHead,    DeleteNode->Index,    McStat))
if (DeleteNode->NodeLeafs[0]      == 0)
{
if (SetBug)
TraceMsg (0, "  Remove Key from LeafNode\n");
--DeleteNode->NumKeys;
for (Pos = KeyPos;
Pos < DeleteNode->NumKeys;
++Pos)
{
DeleteNode->NodeKeys[Pos]    = DeleteNode->NodeKeys[Pos+1];
DeleteNode->NodeHandles[Pos] = DeleteNode->NodeHandles[Pos+1];
}
DeleteNode->NodeKeys[DeleteNode->NumKeys]    = 0;
DeleteNode->NodeHandles[DeleteNode->NumKeys] = Null_Handle;
if (GrpBug || SetBug)
if (TraceMsg  (0, "\n   Delete node:: Revised\n"))
Tree_DumpNode    (SetHead,  DeleteNode);
if (DeleteNode->NumKeys < SetHead->MinKeys)
Tree_Adjust      (SetHead,  DeleteNode,        McStat);
else
Tree_DefrostNode (SetHead,  DeleteNode->Index, McStat);
} else {
if (SetBug)
{
TraceMsg (0, "   Delete Node is an internal node in the tree.\n");
TraceMsg (0, "   Replace deleted key with immediate successor.\n");
}
SuccIndex              = DeleteNode->NodeLeafs[KeyPos+1];
if (Tree_GetFrozenNode (SetHead,  SuccIndex, McStat,  &SuccNode))
while (Normal(*Status)
&&     SuccNode->NodeLeafs[0] != 0)
{
SuccIndex             = SuccNode->NodeLeafs[0];
if (Tree_DefrostNode   (SetHead,  SuccNode->Index,     McStat))
Tree_GetFrozenNode (SetHead,  SuccIndex, McStat,  &SuccNode);
}
if (SetBug)
if (TraceMsg  (0, "\n   Successor node::\n"))
Tree_DumpNode     (SetHead,    SuccNode);
if (Normal(*Status))
{
DeleteNode->NodeKeys[KeyPos]      = SuccNode->NodeKeys[0];
DeleteNode->NodeHandles[KeyPos]   = SuccNode->NodeHandles[0];
--SuccNode->NumKeys;
}
if (Normal(*Status))
for (Pos = 0;
Pos < SuccNode->NumKeys;
++Pos)
{
SuccNode->NodeKeys[Pos]    = SuccNode->NodeKeys[Pos+1];
SuccNode->NodeHandles[Pos] = SuccNode->NodeHandles[Pos+1];
SuccNode->NodeLeafs[Pos+1] = SuccNode->NodeLeafs[Pos+2];
}
if (Normal(*Status))
{
SuccNode->NodeKeys[SuccNode->NumKeys]    = 0;
SuccNode->NodeHandles[SuccNode->NumKeys] = Null_Handle;
SuccNode->NodeLeafs[SuccNode->NumKeys+1] = 0;
}
if (SetBug)
if (TraceMsg  (0, "\n   Successor node:: Revised\n"))
Tree_DumpNode     (SetHead,    SuccNode);
if (Normal(*Status))
if (SuccNode->NumKeys < SetHead->MinKeys)
{
if (SetBug)
{
sprintf (Msg, "   SuccNode->NumKeys(%4u) < SetHead->MinKeys(%4u)\n",
SuccNode->NumKeys,  SetHead->MinKeys);
TraceMsg (0, Msg);
}
if (Normal(*Status))
if (Tree_DefrostNode (SetHead,  DeleteNode->Index,   McStat))
Tree_Adjust      (SetHead,  SuccNode,            McStat);
} else {
if (SetBug)
TraceMsg (0, "   Free the Successor Node\n");
Tree_DefrostNode (SetHead,  SuccNode->Index,   McStat);
if (Normal(*Status))
Tree_DefrostNode (SetHead,  DeleteNode->Index, McStat);
}
}
#ifdef TREE_BUG
if (Normal(*Status))
if (SetBug == False)
{
IterNum  = 0;
Tree_Validate  (SetHead,  SuccIndex,  &IterNum,  McStat);
SetBug = TempSetBug;
}
if (Normal(*Status))
if (SetHead->TreeNodesDir)
if (Grp_FrostStatus      (&TreeTkn, SetHead->TreeNodesDir,
McStat)
==  False)
if (TraceMsg (0, "\n  TreeNodesDir GRP is still Frosted!\n"))
*Status    =  Tree_GRPisFrosted;
if (Normal(*Status))
if (SetHead->TreeKeysDir)
if (Grp_FrostStatus      (&TreeTkn, SetHead->TreeKeysDir,
McStat)
==  False)
if (TraceMsg (0, "\n  TreeKeysDir GRP is still Frosted!\n"))
*Status    =  Tree_GRPisFrosted;
#endif
TRACK(TrackBak,"Tree_DeleteFrom\n");
return (STAT);
}
boolean    Tree_Adjust
(ltreesethead  *SetHead,     lbtreenode   *LeafNode,
ft F,lt Z,zz  *Status)
{
lbtreenode      *ParentNode      = NullPtr;
lbtreenode      *LessNode        = NullPtr;
lbtreenode      *GtrNode         = NullPtr;
int              Pos             = 0;
indextype        SibGtrKeys      = 0;
indextype        SibLessKeys     = 0;
if (SetBug)
if (sprintf (Msg,
"   Tree_Adjust:: SetHead[%4u:%6u] for LeafNode [%4u];\n",
SetHead->TreeDbId, SetHead->Token.Handle, LeafNode->Index))
TraceMsg (0, Msg);
if (LeafNode->ParentNode  == 0)
{
if (SetBug)
TraceMsg (0, "  LeafNode is the ROOT node\n");
Tree_DefrostNode    (SetHead,  LeafNode->Index,  McStat);
return (STAT);
}
if (Tree_GetFrozenNode (SetHead,  LeafNode->ParentNode,
McStat,  &ParentNode))
for (Pos = 0;
ParentNode->NodeLeafs[Pos] != LeafNode->Index
&&   Pos                         < ParentNode->NumKeys+1;
++Pos)
{
;
}
if (Pos >= ParentNode->NumKeys + 1)
{
if (ParentNode->NumKeys   == 0)
*Status = Err_BadDesign;
else {
Tree_DefrostNode    (SetHead,  LeafNode->Index,       McStat);
Tree_DefrostNode    (SetHead,  LeafNode->ParentNode,  McStat);
}
sprintf (Msg,
"***ERROR @ Tree_Adjust:: SetHead[%4u:%6u] for LeafNode [%4u]; Pos=%4u\n",
SetHead->TreeDbId, SetHead->Token.Handle,
LeafNode->Index, Pos);
SendMsg  (0, Msg);
TraceMsg (0, "\n Dump of LeafNode\n");
Tree_DumpNode (SetHead, LeafNode);
TraceMsg (0, "\n Dump of ParentNode... LeafIndex not found.\n");
Tree_DumpNode (SetHead, ParentNode);
*Status = Err_BadDesign;
}
if (Normal(*Status))
if (SetBug)
{
sprintf (Msg, "   LeafNode Ptr in Parent->NodeLeafs[%4u]; Keys=%4u\n",
Pos, ParentNode->NumKeys);
TraceMsg  (0, Msg);
}
if (Normal(*Status))
if (Pos  < ParentNode->NumKeys)
if (Tree_GetFrozenNode (SetHead,  ParentNode->NodeLeafs[Pos+1],
McStat,  &GtrNode))
SibGtrKeys  = GtrNode->NumKeys;
if (Normal(*Status))
if (Pos  > 0)
if (Tree_GetFrozenNode (SetHead,  ParentNode->NodeLeafs[Pos-1],
McStat,  &LessNode))
SibLessKeys = LessNode->NumKeys;
if (Normal(*Status))
if (SibLessKeys  > SibGtrKeys)
{
--Pos;
if (LessNode == NullPtr)
*Status    = Err_BadDesign;
if (GtrNode  != NullPtr)
Tree_DefrostNode   (SetHead,   GtrNode->Index,  McStat);
if (SetBug)
if (TraceMsg  (0, "\n   Less node::\n"))
Tree_DumpNode     (SetHead,   LessNode);
if (Normal(*Status))
if (LessNode->NumKeys  >= SetHead->MinKeys)
Tree_Redistribute  (SetHead,   Pos,  LessNode,  ParentNode, LeafNode,
McStat);
else
Tree_Concatenate   (SetHead,   Pos,  LessNode,  ParentNode, LeafNode,
McStat);
} else {
if (GtrNode  == NullPtr)
*Status    = Err_BadDesign;
if (LessNode != NullPtr)
Tree_DefrostNode   (SetHead,   LessNode->Index, McStat);
if (SetBug)
if (TraceMsg  (0, "\n   Gtr node::\n"))
Tree_DumpNode     (SetHead,   GtrNode);
if (Normal(*Status))
if (GtrNode->NumKeys  >= SetHead->MinKeys)
Tree_Redistribute  (SetHead,   Pos,  LeafNode,  ParentNode, GtrNode,
McStat);
else
Tree_Concatenate   (SetHead,   Pos,  LeafNode,  ParentNode, GtrNode,
McStat);
}
TRACK(TrackBak,"Tree_Adjust\n");
return (STAT);
}
boolean    Tree_Redistribute
(ltreesethead *SetHead,     indextype     KeyPos,
lbtreenode   *LessNode,    lbtreenode   *ParentNode,
lbtreenode   *GtrNode,     ft F,lt Z,zz *Status)
{
lbtreenode      *ChildNode       = NullPtr;
int              Pos             = 0;
if (SetBug)
{
sprintf (Msg, "   Tree_Redistribute:: SetHead [%4u:%6u] Pos=%4u\n",
SetHead->TreeDbId, SetHead->Token.Handle, KeyPos);
TraceMsg (0, Msg);
sprintf (Msg,
"                       LessNode[%4u]; Parent[%4u]; GtrNode[%4u]\n",
LessNode->Index, ParentNode->Index, GtrNode->Index);
TraceMsg (0, Msg);
}
if (LessNode->NodeLeafs[0] == 0)
{
if (LessNode->NumKeys > GtrNode->NumKeys)
{
for (Pos = GtrNode->NumKeys;
Pos > 0;
--Pos)
{
GtrNode->NodeKeys[Pos]    = GtrNode->NodeKeys[Pos-1];
GtrNode->NodeHandles[Pos] = GtrNode->NodeHandles[Pos-1];
}
GtrNode->NodeKeys[0]    = ParentNode->NodeKeys[KeyPos];
GtrNode->NodeHandles[0] = ParentNode->NodeHandles[KeyPos];
++GtrNode->NumKeys;
--LessNode->NumKeys;
ParentNode->NodeKeys[KeyPos]
= LessNode->NodeKeys[LessNode->NumKeys];
ParentNode->NodeHandles[KeyPos]
= LessNode->NodeHandles[LessNode->NumKeys];
LessNode->NodeKeys[LessNode->NumKeys]     = 0;
LessNode->NodeHandles[LessNode->NumKeys]  = Null_Handle;
} else {
LessNode->NodeKeys[LessNode->NumKeys]
= ParentNode->NodeKeys[KeyPos];
LessNode->NodeHandles[LessNode->NumKeys]
= ParentNode->NodeHandles[KeyPos];
++LessNode->NumKeys;
ParentNode->NodeKeys[KeyPos]    = GtrNode->NodeKeys[0];
ParentNode->NodeHandles[KeyPos] = GtrNode->NodeHandles[0];
--GtrNode->NumKeys;
for (Pos = 0;
Pos < GtrNode->NumKeys;
++Pos)
{
GtrNode->NodeKeys[Pos]    = GtrNode->NodeKeys[Pos+1];
GtrNode->NodeHandles[Pos] = GtrNode->NodeHandles[Pos+1];
}
GtrNode->NodeKeys[Pos]    = 0;
GtrNode->NodeHandles[Pos] = Null_Handle;
}
} else {
if (LessNode->NumKeys > GtrNode->NumKeys)
{
for (Pos = GtrNode->NumKeys;
Pos > 0;
--Pos)
{
GtrNode->NodeKeys[Pos]    = GtrNode->NodeKeys[Pos-1];
GtrNode->NodeHandles[Pos] = GtrNode->NodeHandles[Pos-1];
GtrNode->NodeLeafs[Pos+1] = GtrNode->NodeLeafs[Pos];
}
GtrNode->NodeLeafs[1]        = GtrNode->NodeLeafs[0];
GtrNode->NodeKeys[0]    = ParentNode->NodeKeys[KeyPos];
GtrNode->NodeHandles[0] = ParentNode->NodeHandles[KeyPos];
GtrNode->NodeLeafs[0]   = LessNode->NodeLeafs[LessNode->NumKeys];
if (Tree_GetFrozenNode (SetHead,  GtrNode->NodeLeafs[0],
McStat,  &ChildNode))
{
ChildNode->ParentNode        = GtrNode->Index;
if (SetBug)
{
sprintf (Msg, "    ChildNode[%4u] gets new ParentNode= %4u\n",
ChildNode->Index, GtrNode->Index);
TraceMsg  (0, Msg);
}
Tree_DefrostNode   (SetHead,  ChildNode->Index,     McStat);
}
++GtrNode->NumKeys;
--LessNode->NumKeys;
ParentNode->NodeKeys[KeyPos]
= LessNode->NodeKeys[LessNode->NumKeys];
ParentNode->NodeHandles[KeyPos]
= LessNode->NodeHandles[LessNode->NumKeys];
LessNode->NodeKeys[LessNode->NumKeys]     = 0;
LessNode->NodeHandles[LessNode->NumKeys]  = Null_Handle;
LessNode->NodeLeafs[LessNode->NumKeys + 1]= 0;
} else {
LessNode->NodeKeys[LessNode->NumKeys]
= ParentNode->NodeKeys[KeyPos];
LessNode->NodeHandles[LessNode->NumKeys]
= ParentNode->NodeHandles[KeyPos];
LessNode->NodeLeafs[LessNode->NumKeys + 1]
= GtrNode->NodeLeafs[0];
if (Tree_GetFrozenNode (SetHead,  GtrNode->NodeLeafs[0],
McStat,  &ChildNode))
{
ChildNode->ParentNode        = LessNode->Index;
if (SetBug)
{
sprintf (Msg, "    ChildNode[%4u] gets new ParentNode= %4u\n",
ChildNode->Index, LessNode->Index);
TraceMsg  (0, Msg);
}
Tree_DefrostNode   (SetHead,  ChildNode->Index,     McStat);
}
++LessNode->NumKeys;
ParentNode->NodeKeys[KeyPos]    = GtrNode->NodeKeys[0];
ParentNode->NodeHandles[KeyPos] = GtrNode->NodeHandles[0];
--GtrNode->NumKeys;
for (Pos = 0;
Pos < GtrNode->NumKeys;
++Pos)
{
GtrNode->NodeKeys[Pos]    = GtrNode->NodeKeys[Pos+1];
GtrNode->NodeHandles[Pos] = GtrNode->NodeHandles[Pos+1];
GtrNode->NodeLeafs[Pos]   = GtrNode->NodeLeafs[Pos+1];
}
GtrNode->NodeLeafs[Pos]   = GtrNode->NodeLeafs[Pos+1];
GtrNode->NodeKeys[Pos]    = 0;
GtrNode->NodeHandles[Pos] = Null_Handle;
GtrNode->NodeLeafs[Pos+1] = 0;
}
}
if (SetBug)
{
TraceMsg  (0, "\n After Redistribution::\n");
TraceMsg  (0, " Less node::\n");
Tree_DumpNode     (SetHead,   LessNode);
TraceMsg  (0, " Parent node::\n");
Tree_DumpNode     (SetHead,   ParentNode);
TraceMsg  (0, " Gtr node::\n");
Tree_DumpNode     (SetHead,   GtrNode);
}
if (Normal(*Status))
if (Tree_DefrostNode   (SetHead,  LessNode->Index,     McStat))
if (Tree_DefrostNode   (SetHead,  GtrNode->Index,      McStat))
Tree_DefrostNode   (SetHead,  ParentNode->Index,   McStat);
TRACK(TrackBak,"Tree_Redestribute\n");
return (STAT);
}
boolean    Tree_Concatenate
(ltreesethead *SetHead,     indextype     KeyPos,
lbtreenode   *LessNode,    lbtreenode   *ParentNode,
lbtreenode   *GtrNode,     ft F,lt Z,zz *Status)
{
lbtreenode      *ChildNode       = NullPtr;
sizetype         Pos             = 0;
sizetype         LessPos         = 0;
sizetype         GtrPos          = 0;
if (SetBug)
{
sprintf (Msg, "   Tree_Concatenate :: SetHead [%4u:%6u] Pos=%4u\n",
SetHead->TreeDbId, SetHead->Token.Handle, KeyPos);
TraceMsg (0, Msg);
sprintf (Msg,
"                       LessNode[%4u]; Parent[%4u]; GtrNode[%4u]\n",
LessNode->Index, ParentNode->Index, GtrNode->Index);
TraceMsg (0, Msg);
}
LessNode->NodeKeys[LessNode->NumKeys]    = ParentNode->NodeKeys[KeyPos];
LessNode->NodeHandles[LessNode->NumKeys] = ParentNode->NodeHandles[KeyPos];
LessNode->NodeLeafs[LessNode->NumKeys +1]= GtrNode->NodeLeafs[0];
++LessNode->NumKeys;
--ParentNode->NumKeys;
for (Pos = KeyPos;
Pos < ParentNode->NumKeys;
++Pos)
{
ParentNode->NodeKeys[Pos]      = ParentNode->NodeKeys[Pos + 1];
ParentNode->NodeHandles[Pos]   = ParentNode->NodeHandles[Pos + 1];
ParentNode->NodeLeafs[Pos + 1] = ParentNode->NodeLeafs[Pos + 2];
}
ParentNode->NodeKeys[Pos]         = 0;
ParentNode->NodeHandles[Pos]      = Null_Handle;
ParentNode->NodeLeafs[Pos + 1]    = 0;
GtrPos   = 0;
LessPos  = LessNode->NumKeys;
while (GtrPos  < GtrNode->NumKeys)
{
++LessNode->NumKeys;
LessNode->NodeKeys[LessPos]      = GtrNode->NodeKeys[GtrPos];
LessNode->NodeHandles[LessPos]   = GtrNode->NodeHandles[GtrPos];
LessNode->NodeLeafs[LessPos + 1] = GtrNode->NodeLeafs[GtrPos + 1];
++LessPos;
++GtrPos;
}
if (Tree_DefrostNode (SetHead,  GtrNode->Index,  McStat))
if (Tree_DeleteNode  (SetHead,  GtrNode->Index,  McStat))
if (LessNode->NodeLeafs[0] != 0)
{
if (SetBug)
TraceMsg (0, "   This a Leaf Node:  adjust child ptrs\n");
for (Pos  = 0;
Pos <= LessNode->NumKeys  && Normal(*Status);
++Pos)
{
if (Tree_GetFrozenNode (SetHead,  LessNode->NodeLeafs[Pos],
McStat,  &ChildNode))
{
ChildNode->ParentNode        = LessNode->Index;
if (SetBug)
{
sprintf (Msg, "    ChildNode[%4u] gets new ParentNode= %4u\n",
ChildNode->Index, LessNode->Index);
TraceMsg  (0, Msg);
}
Tree_DefrostNode   (SetHead,  ChildNode->Index,     McStat);
}
}
}
if (Normal(*Status))
if (ParentNode->NumKeys == 0)
{
if (Tree_DefrostNode (SetHead,  ParentNode->Index,  McStat))
if (Tree_DeleteNode  (SetHead,  ParentNode->Index,  McStat))
{
LessNode->ParentNode     = 0;
SetHead->TreeRootNode    = LessNode->Index;
Tree_DefrostNode (SetHead, LessNode->Index,    McStat);
}
if (SetBug)
{
TraceMsg  (0, "\n After Concatenation::\n");
TraceMsg  (0, " Less node::\n");
Tree_DumpNode     (SetHead,   LessNode);
TraceMsg  (0, " Parent node was deleted::\n");
TraceMsg  (0, " Gtr node was deleted::\n");
sprintf (Msg, "  SetHead->TreeRootNode =%4u\n", LessNode->Index);
TraceMsg  (0, Msg);
}
} else {
if (Tree_DefrostNode (SetHead,  LessNode->Index,    McStat))
if (ParentNode->ParentNode  == 0)
SetHead->TreeRootNode    = ParentNode->Index;
if (SetBug)
{
TraceMsg  (0, "\n After Concatenation::\n");
TraceMsg  (0, " Less node::\n");
Tree_DumpNode     (SetHead,   LessNode);
TraceMsg  (0, " Parent node::\n");
Tree_DumpNode     (SetHead,   ParentNode);
TraceMsg  (0, " Gtr node was deleted::\n");
}
if (ParentNode->NumKeys  < SetHead->MinKeys)
Tree_Adjust      (SetHead,  ParentNode,         McStat);
else
Tree_DefrostNode (SetHead,  ParentNode->Index,  McStat);
}
TRACK(TrackBak,"Tree_Concatenate\n");
return (STAT);
}
boolean    Tree_DeleteNode
(ltreesethead  *SetHead,     indextype     Index,
ft F,lt Z,zz  *Status)
{
tokentype   TreeTkn    = NullToken;
TreeTkn.DbId    = SetHead->TreeDbId;
TreeTkn.Handle  = 1;
if (SetBug)
{
sprintf (Msg,
"   Tree_DeleteNode :: SetHead[%4u:%6u] for DeleteNode->Index=%4u\n",
SetHead->TreeDbId, SetHead->Token.Handle, Index);
TraceMsg (0, Msg);
}
if (Grp_DeleteEntry  (&TreeTkn,    SetHead->TreeNodesDir,   Index,
McStat))
--SetHead->NodeCount;
TRACK(TrackBak,"Tree_DeleteNode\n");
return (STAT);
}
boolean  Test_Iterate    (tokentype    *Token,   indextype       IterNum,
ft F,lt Z,zz *Status)
{
numtype             j      = IterNum;
if (j == 0 || j % 1000 == 0)
{
sprintf (Msg, " Object %4d. Iterate [%3u:%4u]\n",
IterNum, Token->DbId, Token->Handle);
TraceMsg (0, Msg);
}
TRACK(TrackBak,"Test_Iterate\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\tree00.c*/

#define  TREE00
#ifdef __ZTC__
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#else
#ifdef MCSTAT
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(Anchor->DbId <= MaxCoreDbId \
&& ((*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr)) ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#else
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#endif
#endif
boolean    Tree_AddInto
(ltreesethead  *SetHead,     addrtype       KeyValue,
handletype     Handle,      ft F,lt Z,zz  *Status)
{
lbtreenode      *LeafNode        = NullPtr;
lbtreenode      *SibNode         = NullPtr;
indextype        KeyIndex        = 0;
indextype        Index           = 0;
indextype        KeyPos          = 0;
sizetype         Pos             = 0;
sizetype         TempPos         = 0;
#ifdef TREE_BUG
tokentype      TreeTkn         = NullToken;
TreeTkn.DbId    = SetHead->TreeDbId;
TreeTkn.Handle  = 1;
#endif
*Status          = Set_AddInto;
if (SetBug)
if (sprintf (Msg,
"   Tree_AddInto:: SetHead[%4u%6u] for KeyValue @%6x; Handle=%4u\n",
SetHead->TreeDbId, SetHead->Token.Handle, KeyValue,  Handle))
TraceMsg (0, Msg);
Tree_OpType       = aTreeFindIn;
Tree_FindIn      (SetHead, KeyValue, McStat, &LeafNode, &KeyPos);
Tree_OpType       = aTreeAddInto;
if (*Status == Set_Found)
*Status  = Set_AlreadyInSet;
else if (*Status == Set_EmptySet)
{
*Status  = Env_Normal;
if (Tree_CreateNode(SetHead,  McStat, &SetHead->TreeRootNode, &LeafNode))
if (Tree_NewKey    (SetHead,            KeyValue,  McStat,  &KeyIndex))
{
SetHead->TreeRootNode    = LeafNode->Index;
LeafNode->NodeKeys[0]    = KeyIndex;
LeafNode->NodeHandles[0] = Handle;
++LeafNode->NumKeys;
}
} else if (*Status == Set_NotFound
||  *Status == Set_LessThen)  {
*Status  = Env_Normal;
if (Tree_NewKey    (SetHead, KeyValue,  McStat,  &KeyIndex))
if (LeafNode->NumKeys == SetHead->MaxKeys)
{
for (Pos = 0; Pos < SetHead->TreeOrder; Pos++)
{
SetHead->TempKeys[Pos]    = 0;
SetHead->TempHandles[Pos] = 0;
}
TempPos  = 0;
Pos      = 0;
SetHead->TempKeys[KeyPos]    = KeyIndex;
SetHead->TempHandles[KeyPos] = Handle;
while (Pos < SetHead->MaxKeys)
{
if (Pos == KeyPos)
++TempPos;
SetHead->TempKeys[TempPos]    = LeafNode->NodeKeys[Pos];
SetHead->TempHandles[TempPos] = LeafNode->NodeHandles[Pos];
++Pos;
++TempPos;
}
if (Tree_CreateNode (SetHead,  McStat,  &Index,   &SibNode))
{
SibNode->ParentNode  = LeafNode->ParentNode;
if (SetBug)
if (sprintf (Msg, "    Create Sibling Leaf Node:: Index=%4u\n",
Index))
TraceMsg (0, Msg);
}
if (Normal(*Status))
{
LeafNode->NumKeys   = 0;
SibNode->NumKeys    = 0;
}
if (Normal(*Status))
for (Pos = 0;
Pos < SetHead->MinKeys;
++Pos)
{
LeafNode->NodeKeys[Pos]     = SetHead->TempKeys[Pos];
LeafNode->NodeHandles[Pos]  = SetHead->TempHandles[Pos];
++LeafNode->NumKeys;
}
if (Normal(*Status))
for (Pos  = SetHead->MinKeys + 1;
Pos <= SetHead->MaxKeys;
++Pos)
{
SibNode->NodeKeys[   Pos - 1 - SetHead->MinKeys]
=   SetHead->TempKeys[Pos];
SibNode->NodeHandles[Pos - 1 - SetHead->MinKeys]
=   SetHead->TempHandles[Pos];
++SibNode->NumKeys;
}
if (Normal(*Status))
for (Pos = SetHead->MinKeys;
Pos < SetHead->MaxKeys;
++Pos)
{
LeafNode->NodeKeys[Pos]     = 0;
LeafNode->NodeHandles[Pos]  = Null_Handle;
}
if (Normal(*Status))
if (LeafNode->ParentNode == 0)
{
if (Tree_PromoteRootNode (SetHead,
SetHead->TempKeys[SetHead->MinKeys],
SetHead->TempHandles[SetHead->MinKeys],
LeafNode, SibNode,    McStat))
{
LeafNode->ParentNode   = SetHead->TreeRootNode;
SibNode->ParentNode    = SetHead->TreeRootNode;
}
} else {
if (SetBug)
if (sprintf (Msg,
"    Promote median key to Leaf Node Parent:: Index=%4u\n",
LeafNode->ParentNode))
TraceMsg (0, Msg);
if (Normal(*Status))
Tree_PromoteInternalNode
(SetHead,      SibNode,      LeafNode->ParentNode,
SetHead->TempKeys[SetHead->MinKeys],
SetHead->TempHandles[SetHead->MinKeys],
McStat);
}
if (Normal(*Status))
if (SetBug)
{
sprintf  (Msg, "    Sibling Leaf Node[%4u]; Parent[%4u]\n",
SibNode->Index, SibNode->ParentNode);
TraceMsg (0,  Msg);
Tree_DumpNode  (SetHead,  SibNode);
}
if (Normal(*Status))
Tree_DefrostNode (SetHead,  SibNode->Index,   McStat);
} else {
if (SetBug)
if (sprintf (Msg, "    Leaf[%4u]:: Insert at Key Pos=%3u, Handle=%4u\n",
LeafNode->Index, KeyPos, Handle))
TraceMsg (0, Msg);
for (Pos = LeafNode->NumKeys;
Pos > KeyPos;
--Pos)
{
LeafNode->NodeKeys[Pos]     = LeafNode->NodeKeys[Pos - 1];
LeafNode->NodeHandles[Pos]  = LeafNode->NodeHandles[Pos - 1];
}
LeafNode->NodeKeys[KeyPos]    = KeyIndex;
LeafNode->NodeHandles[KeyPos] = Handle;
++LeafNode->NumKeys;
}
}
if (Normal(*Status))
if (SetBug)
{
sprintf  (Msg, "    Current Leaf Node[%4u]; Parent[%4u]\n",
LeafNode->Index, LeafNode->ParentNode);
TraceMsg (0,  Msg);
Tree_DumpNode  (SetHead,  LeafNode);
}
if (Normal(*Status))
Tree_DefrostNode (SetHead,  LeafNode->Index,   McStat);
TRACK(TrackBak,"Tree_AddInto\n");
return (STAT);
}
boolean    Tree_FindIn
(ltreesethead  *SetHead,     addrtype       KeyValue,
ft F,lt Z,zz  *Status,
lbtreenode   **LeafNode,    indextype     *KeyPos)
{
indextype          Index        = 0;
boolean            AddInto      = False;
statustype         ShellStatus  = Env_Normal;
#ifdef TREE_BUG
tokentype          TreeTkn      = NullToken;
TreeTkn.DbId    = SetHead->TreeDbId;
TreeTkn.Handle  = 1;
#endif
if (SetBug)
if (sprintf (Msg,
"   Tree_FindIn:: SeatHead[%4u%6u] for KeyValue @%6x;\n",
SetHead->TreeDbId, SetHead->Token.Handle, KeyValue))
TraceMsg (0, Msg);
if ((Index   = SetHead->TreeRootNode) == 0)
*Status    = Set_EmptySet;
else
{
if (*Status == Set_AddInto)
{
AddInto   = True;
*Status    = Env_Normal;
}
Tree_RecurseSearch  (SetHead, KeyValue, Index, McStat, LeafNode, KeyPos);
if (*Status == Set_EndOfSet)
*Status  = Set_NotFound;
if (AddInto == False
||  *Status == Set_Found)
{
if (SetBug)
{
sprintf  (Msg, "    Current Leaf Node[%4u]; Parent[%4u]\n",
(*LeafNode)->Index, (*LeafNode)->ParentNode);
TraceMsg (0,  Msg);
Tree_DumpNode  (SetHead,  *LeafNode);
}
Tree_DefrostNode (SetHead,  (*LeafNode)->Index,   ShellMcStat);
}
}
TRACK(TrackBak,"Tree_FindIn\n");
return (STAT);
}
boolean    Tree_Traverse
(ltreesethead  *SetHead,     indextype      LeafIndex,
numtype       *IterNum,     treeiterfunc   IterFunc,
ft F,lt Z,zz  *Status)
{
lbtreenode        *LeafNode     = NullPtr;
indextype          ChildIndex   = 0;
numtype            Pos          = 0;
tokentype          Token        = NullToken;
static int         RecurseNum   = 0;
if (SetBug)
if (*IterNum == 0)
if (sprintf (Msg,
"   Tree_Traverse:: SeatHead[%4u%6u] LeafIndex=%4u;\n",
SetHead->TreeDbId, SetHead->Token.Handle, LeafIndex))
TraceMsg (0, Msg);
Token.DbId     =  SetHead->TreeDbId;
if (*IterNum == 0)
{
RecurseNum       = 0;
if ((LeafIndex   = SetHead->TreeRootNode) == 0)
*Status      = Set_EmptySet;
else
{
*IterNum = 1;
if (Tree_GetFrozenNode  (SetHead,  SetHead->TreeRootNode,
McStat,           &LeafNode))
if (Normal(*Status))
if (SetBug)
if (sprintf (Msg, "    Root Node ::     Iter= %3u\n", *IterNum))
if (TraceMsg (0, Msg))
Tree_DumpNode   (SetHead,  LeafNode);
}
} else {
if (Tree_GetFrozenNode  (SetHead,           LeafIndex,
McStat,           &LeafNode))
if (SetBug)
if (sprintf (Msg, "    Leaf Node ::     Iter= %3u\n", IterNum))
if (TraceMsg (0, Msg))
Tree_DumpNode   (SetHead,  LeafNode);
}
if (Normal(*Status))
for (Pos = 0;
Pos < LeafNode->NumKeys  &&  Normal(*Status);
++Pos)
{
if ((ChildIndex = LeafNode->NodeLeafs[Pos]) > 0)
Tree_Traverse (SetHead,  ChildIndex, IterNum,  IterFunc,  McStat);
if (Normal(*Status))
if ((Token.Handle = LeafNode->NodeHandles[Pos]) > 0)
{
IterFunc (&Token, *IterNum, McStat);
*IterNum += 1;
++RecurseNum;
}
}
if (Normal(*Status))
{
if ((ChildIndex = LeafNode->NodeLeafs[Pos]) > 0)
Tree_Traverse (SetHead,  ChildIndex, IterNum,  IterFunc,  McStat);
}
if (Normal(*Status))
Tree_DefrostNode (SetHead,   LeafIndex,   McStat);
TRACK(TrackBak,"Tree_Traverse\n");
return (STAT);
}
boolean    Tree_IterateOn
(ltreesethead  *SetHead,      ft F,lt Z,zz  *Status,
indextype     *CurrLeaf,     indextype     *KeyPos,
numtype       *IterNum,      handletype    *Handle)
{
lbtreenode        *LeafNode     = NullPtr;
tokentype          Token        = NullToken;
if (SetBug)
if (*IterNum == 0)
if (sprintf (Msg,
"   Tree_IterateOn:: SeatHead[%4u%6u] LeafIndex=%4u;\n",
SetHead->TreeDbId, SetHead->Token.Handle, *CurrLeaf))
TraceMsg (0, Msg);
Token.DbId     =  SetHead->TreeDbId;
if (*IterNum == 0)
{
*KeyPos           = 0;
if ((*CurrLeaf   = SetHead->TreeRootNode) == 0)
*Status      = Iterate_EndOf;
else
{
*IterNum = 1;
if (Tree_GetFrozenNode  (SetHead,  SetHead->TreeRootNode,
McStat,           &LeafNode))
if (Normal(*Status))
if (SetBug)
if (sprintf (Msg, "    Root Node ::     Iter= %3u\n", *IterNum))
if (TraceMsg (0, Msg))
Tree_DumpNode   (SetHead,  LeafNode);
}
} else {
if (Tree_GetFrozenNode  (SetHead,          *CurrLeaf,
McStat,           &LeafNode))
if (SetBug)
if (sprintf (Msg, "    Leaf Node ::     Iter= %3u\n", *IterNum))
if (TraceMsg (0, Msg))
Tree_DumpNode   (SetHead,  LeafNode);
}
TRACK(TrackBak,"Tree_IterateOn\n");
return (STAT);
}
boolean    Tree_Validate
(ltreesethead  *SetHead,     indextype      LeafIndex,
numtype       *IterNum,     ft F,lt Z,zz  *Status)
{
lbtreenode        *LeafNode     = NullPtr;
lbtreenode        *ParentNode   = NullPtr;
indextype          ChildIndex   = 0;
numtype            Pos          = 0;
numtype            Sos          = 0;
tokentype          Token        = NullToken;
static int         RecurseNum   = 0;
#ifdef TREE_BUG
tokentype          TreeTkn      = NullToken;
TreeTkn.DbId    = SetHead->TreeDbId;
TreeTkn.Handle  = 1;
#endif
if (*IterNum == 0)
if (SetBug)
if (sprintf (Msg,
"   Tree_VALIDATE:: SeatHead[%4u%6u] LeafIndex=%4u;\n",
SetHead->TreeDbId, SetHead->Token.Handle, LeafIndex))
TraceMsg (0, Msg);
Token.DbId     =  SetHead->TreeDbId;
if (*IterNum == 0)
{
RecurseNum       = 0;
if ((LeafIndex   = SetHead->TreeRootNode) == 0)
*Status      = Set_EmptySet;
else
{
*IterNum = 1;
if (Tree_GetFrozenNode  (SetHead,  SetHead->TreeRootNode,
McStat,           &LeafNode))
if (SetBug)
if (sprintf (Msg, "    Root Node ::     Iter= %3u\n", *IterNum))
if (TraceMsg (0, Msg))
Tree_DumpNode   (SetHead,  LeafNode);
}
} else {
if (Tree_GetFrozenNode  (SetHead,           LeafIndex,
McStat,           &LeafNode))
if (SetBug)
if (sprintf (Msg, "    Leaf Node ::     Iter= %3u\n", *IterNum))
if (TraceMsg (0, Msg))
Tree_DumpNode   (SetHead,  LeafNode);
if (Tree_GetFrozenNode  (SetHead,           LeafNode->ParentNode,
McStat,           &ParentNode))
for (Sos  = 0;
ParentNode->NodeLeafs[Sos] != LeafNode->Index
&&   Sos                         < ParentNode->NumKeys+1;
++Sos)
{
;
}
if (Normal(*Status))
Tree_DefrostNode    (SetHead,  LeafNode->ParentNode,  McStat);
if (Sos > ParentNode->NumKeys)
{
sprintf (Msg,
"***ERROR @ Tree_Validate:: SetHead[%4u:%6u] for LeafNode [%4u]; Pos=%4u\n",
SetHead->TreeDbId, SetHead->Token.Handle,
LeafNode->Index, Pos);
SendMsg  (0, Msg);
TraceMsg (0, "\n Dump of LeafNode\n");
Tree_DumpNode (SetHead, LeafNode);
TraceMsg (0, "\n Dump of ParentNode... LeafIndex not found.\n");
Tree_DumpNode (SetHead, ParentNode);
Tree_DefrostNode    (SetHead,  LeafNode->Index,       McStat);
Tree_DefrostNode    (SetHead,  LeafNode->ParentNode,  McStat);
*Status = Tree_UnmatchedParent;
return (STAT);
}
}
if (Normal(*Status))
for (Pos = 0;
Pos < LeafNode->NumKeys  &&  Normal(*Status);
++Pos)
{
if ((ChildIndex = LeafNode->NodeLeafs[Pos]) > 0)
Tree_Validate (SetHead,  ChildIndex, IterNum,  McStat);
if (Normal(*Status))
if ((Token.Handle = LeafNode->NodeHandles[Pos]) > 0)
{
*IterNum += 1;
++RecurseNum;
}
}
if (Normal(*Status))
{
if ((ChildIndex = LeafNode->NodeLeafs[Pos]) > 0)
Tree_Validate (SetHead,  ChildIndex, IterNum,  McStat);
}
if (Normal(*Status))
Tree_DefrostNode (SetHead,   LeafIndex,   McStat);
TRACK(TrackBak,"Tree_Validate\n");
return (STAT);
}
boolean    Tree_Delete   (ft F,lt Z,zz *Status,       ltreesethead **SetHead)
{
bytessizetype size         = (bytessizetype )sizeof (ltreesethead);
dbheader     *DbHdr        = NullPtr;
ltreesethead *TreeHead     = *SetHead;
bytessizetype ArraySize    = 0;
numtype       TreeOrder    = (*SetHead)->TreeOrder;
tokentype     Vtoken       = NullToken;
indextype     Index        = (*SetHead)->Token.Handle;
static
nametype      NullName     = " ";
if (SetBug || DeBug)
if (sprintf (Msg, "\n   Delete the Tree [%2u:%4u]  \n",
TreeHead->Token.DbId, TreeHead->Token.Handle))
TraceMsg (0, Msg);
ArraySize             = TreeOrder     * sizeof (indextype);
if (TmGetCoreDb         ((&TreeHead->Token),          McStat,       &DbHdr))
{
Vtoken.DbId         = TreeHead->Token.DbId;
Vtoken.Handle       = DbHdr->TreeNames;
}
if (CoreFreeCoreSpace   ((addrtype *)&TreeHead->TempKeys,       ArraySize,
McStat))
{
ArraySize          = TreeOrder     * sizeof (handletype);
if (CoreFreeCoreSpace((addrtype *)&TreeHead->TempHandles,    ArraySize,
McStat))
{
ArraySize          =(TreeOrder+1)  * sizeof (indextype);
CoreFreeCoreSpace((addrtype *)&TreeHead->TempHandles,    ArraySize,
McStat);
}
}
if (Normal(*Status))
if (Grp_DeletePacket    (&TreeHead->Token,  TreeHead->TreeNodesDir, McStat))
if (TreeHead->TreeKeysDir)
Grp_DeletePacket    (&TreeHead->Token,  TreeHead->TreeKeysDir,  McStat);
if (Normal(*Status))
if (Vchunk_PutUnit      (&Vtoken,           Index,       (addrtype )NullName,
McStat))
if (Grp_DeleteEntry    (&TreeHead->Token,  DbHdr->TreeHeadDir,     Index,
McStat))
CoreFreeCoreSpace    ((addrtype *)SetHead,      size,            McStat);
*SetHead  = NullPtr;
TRACK(TrackBak,"Tree_Delete\n");
return(STAT);
}
boolean    Tree_PromoteRootNode
(ltreesethead  *SetHead,
indextype      RootKey,     handletype     RootHandle,
lbtreenode    *LessNode,    lbtreenode    *GtrNode,
ft F,lt Z,zz  *Status)
{
lbtreenode      *RootNode        = NullPtr;
indextype        Index           = 0;
if (SetBug)
if (sprintf (Msg, "   Tree_PromoteRootNode:: Less_Leaf= %3u; Gtr_Leaf=%4u\n",
LessNode->Index,  GtrNode->Index))
TraceMsg (0, Msg);
if (Tree_CreateNode (SetHead,  McStat,  &Index,   &RootNode))
{
SetHead->TreeRootNode    = Index;
RootNode->NumKeys        = 1;
RootNode->NodeKeys[0]    = RootKey;
RootNode->NodeHandles[0] = RootHandle;
RootNode->NodeLeafs[0]   = LessNode->Index;
RootNode->NodeLeafs[1]   = GtrNode->Index;
}
if (SetBug)
if (RootNode != NullPtr)
{
sprintf  (Msg, "    Root    .... Node[%4u]; Parent{%4u]\n",
RootNode->Index, RootNode->ParentNode);
TraceMsg (0,  Msg);
Tree_DumpNode  (SetHead,  RootNode);
}
if (Normal(*Status))
Tree_DefrostNode (SetHead,  RootNode->Index,   McStat);
TRACK(TrackBak,"Tree_PromoteRootNode\n");
return (STAT);
}
boolean    Tree_PromoteInternalNode
(ltreesethead  *SetHead,
lbtreenode    *LeafNode,    indextype      ParentIndex,
indextype      KeyIndex,    handletype     Handle,
ft F,lt Z,zz  *Status)
{
lbtreenode      *ParentNode      = NullPtr;
lbtreenode      *SibNode         = NullPtr;
lbtreenode      *ChildNode       = NullPtr;
indextype        KeyPos          = 0;
indextype        Index           = 0;
sizetype         Pos             = 0;
sizetype         TempPos         = 0;
if (SetBug)
if (sprintf (Msg, "   Tree_PromoteInternalNode:: Parent= %3u; \n",
ParentIndex))
if (TraceMsg (0, Msg))
if (sprintf (Msg,
"                              Leaf  = %3u, KeyIndex=%4u,  Handle=%6u\n",
LeafNode->Index, KeyIndex, Handle))
TraceMsg (0, Msg);
if (SetHead->Key2ary)
AddInto_MemberTkn.Handle = Handle;
if (Tree_GetFrozenNode (SetHead,  ParentIndex, McStat,  &ParentNode))
if (ParentNode->NumKeys  == SetHead->MaxKeys)
{
for (Pos = 0; Pos < SetHead->TreeOrder; Pos++)
{
SetHead->TempKeys[Pos]    = 0;
SetHead->TempHandles[Pos] = 0;
SetHead->TempLeafs[Pos]   = 0;
}
SetHead->TempLeafs[Pos]      = 0;
SetHead->TempLeafs[0]        = ParentNode->NodeLeafs[0];
Tree_GetNodeInsertPos (SetHead,   KeyIndex,   ParentNode,
McStat,               &KeyPos);
if (*Status == Set_GtrThen
||  *Status == Set_LessThen)
*Status = Env_Normal;
if (Normal(*Status))
{
SetHead->TempKeys[KeyPos]     = KeyIndex;
SetHead->TempHandles[KeyPos]  = Handle;
SetHead->TempLeafs[KeyPos+1]  = LeafNode->Index;
}
TempPos  = 0;
Pos      = 0;
if (Normal(*Status))
while (Pos < SetHead->MaxKeys)
{
if (Pos == KeyPos)
++TempPos;
SetHead->TempKeys[TempPos]    = ParentNode->NodeKeys[Pos];
SetHead->TempHandles[TempPos] = ParentNode->NodeHandles[Pos];
SetHead->TempLeafs[TempPos+1] = ParentNode->NodeLeafs[Pos+1];
++Pos;
++TempPos;
}
if (Normal(*Status))
if (Tree_CreateNode (SetHead,  McStat,  &Index,   &SibNode))
{
SibNode->ParentNode  = ParentNode->ParentNode;
if (SetBug)
if (sprintf (Msg, "    Create Sibling Leaf Node:: Index=%4u\n",
Index))
TraceMsg (0, Msg);
}
ParentNode->NumKeys   = 0;
SibNode->NumKeys      = 0;
ParentNode->NodeLeafs[0]  = SetHead->TempLeafs[0];
if (Normal(*Status))
for (Pos = 0;
Pos < SetHead->MinKeys;
++Pos)
{
ParentNode->NodeKeys[Pos]       = SetHead->TempKeys[Pos];
ParentNode->NodeHandles[Pos]    = SetHead->TempHandles[Pos];
ParentNode->NodeLeafs[Pos+1]    = SetHead->TempLeafs[Pos+1];
++ParentNode->NumKeys;
}
SibNode->NodeLeafs[0]   = SetHead->TempLeafs[SetHead->MinKeys + 1];
if (Normal(*Status))
for (Pos  = SetHead->MinKeys + 1;
Pos <= SetHead->MaxKeys;
++Pos)
{
SibNode->NodeKeys[   Pos - 1 - SetHead->MinKeys]
=   SetHead->TempKeys[Pos];
SibNode->NodeHandles[Pos - 1 - SetHead->MinKeys]
=   SetHead->TempHandles[Pos];
SibNode->NodeLeafs[  Pos     - SetHead->MinKeys]
=   SetHead->TempLeafs[Pos + 1];
++SibNode->NumKeys;
}
if (Normal(*Status))
for (Pos = SetHead->MinKeys;
Pos < SetHead->MaxKeys;
++Pos)
{
ParentNode->NodeKeys[   Pos]        = 0;
ParentNode->NodeHandles[Pos]        = Null_Handle;
ParentNode->NodeLeafs[  Pos + 1]    = 0;
}
if (Normal(*Status))
for (Pos  = 0;
Pos <= SibNode->NumKeys;
++Pos)
{
if (Tree_GetFrozenNode (SetHead,  SibNode->NodeLeafs[Pos],
McStat,  &ChildNode))
ChildNode->ParentNode        = SibNode->Index;
if (SetBug)
{
sprintf  (Msg, "    Child   Leaf Node[%4u]; Parent[%4u]\n",
ChildNode->Index, ChildNode->ParentNode);
TraceMsg (0,  Msg);
}
if (Normal(*Status))
Tree_DefrostNode (SetHead,  ChildNode->Index,   McStat);
}
if (ParentNode->ParentNode == 0)
{
if (Tree_PromoteRootNode (SetHead,
SetHead->TempKeys[SetHead->MinKeys],
SetHead->TempHandles[SetHead->MinKeys],
ParentNode, SibNode,    McStat))
{
ParentNode->ParentNode = SetHead->TreeRootNode;
SibNode->ParentNode    = SetHead->TreeRootNode;
}
} else {
if (SetBug)
if (sprintf (Msg,
"    Promote median key to Leaf Node Parent:: Index=%4u\n",
LeafNode->ParentNode))
TraceMsg (0, Msg);
if (Normal(*Status))
Tree_PromoteInternalNode
(SetHead,      SibNode,     ParentNode->ParentNode,
SetHead->TempKeys[SetHead->MinKeys],
SetHead->TempHandles[SetHead->MinKeys],
McStat);
}
if (Normal(*Status))
if (SetBug)
{
sprintf  (Msg, "    Sibling Leaf Node[%4u]; Parent[%4u]\n",
SibNode->Index, SibNode->ParentNode);
TraceMsg (0,  Msg);
Tree_DumpNode  (SetHead,  SibNode);
}
if (Normal(*Status))
Tree_DefrostNode (SetHead,  SibNode->Index,   McStat);
} else {
Tree_GetNodeInsertPos (SetHead,   KeyIndex,   ParentNode,
McStat,               &Pos);
if (*Status == Set_GtrThen
||  *Status == Set_LessThen)
*Status = Env_Normal;
for (TempPos = ParentNode->NumKeys;
TempPos > Pos;
--TempPos)
{
ParentNode->NodeKeys[TempPos]    = ParentNode->NodeKeys[TempPos - 1];
ParentNode->NodeHandles[TempPos] = ParentNode->NodeHandles[TempPos- 1];
ParentNode->NodeLeafs[TempPos+1] = ParentNode->NodeLeafs[TempPos];
}
if (Normal(*Status))
{
ParentNode->NumKeys++;
ParentNode->NodeKeys[Pos]    = KeyIndex;
ParentNode->NodeHandles[Pos] = Handle;
ParentNode->NodeLeafs[Pos+1] = LeafNode->Index;
}
if (Normal(*Status))
if (SetBug)
{
sprintf  (Msg, "    Parent  Leaf Node[%4u]; Parent_Of[%4u]\n",
ParentNode->Index, ParentNode->ParentNode);
TraceMsg (0,  Msg);
Tree_DumpNode  (SetHead,  ParentNode);
}
}
if (Normal(*Status))
Tree_DefrostNode (SetHead,  ParentIndex,   McStat);
TRACK(TrackBak,"Tree_PromoteInternalNode\n");
return (STAT);
}
boolean    Tree_RecurseSearch
(ltreesethead  *SetHead,     addrtype       KeyValue,
indextype      Index,       ft F,lt Z,zz  *Status,
lbtreenode   **LeafNode,    indextype     *KeyPos)
{
indextype          NodeIndex    = 0;
*KeyPos          = 0;
if (SetBug)
if (sprintf (Msg, "   TreeRecurse:: Node[%4u]\n", Index))
TraceMsg  (0,   Msg);
if (Tree_GetFrozenNode      (SetHead,  Index,    McStat,   LeafNode))
if (Index                 == SetHead->TreeRootNode)
if ((*LeafNode)->NumKeys  == 0)
*Status               = Set_EndOfSet;
if (SetBug)
if (Index == SetHead->TreeRootNode)
{
sprintf  (Msg, "    ROOT         Node[%4u]; Parent_Of[%4u]\n",
(*LeafNode)->Index, (*LeafNode)->ParentNode);
TraceMsg (0,  Msg);
Tree_DumpNode  (SetHead,  *LeafNode);
} else {
sprintf  (Msg, "    LEAF         Node[%4u]; Parent_Of[%4u]\n",
(*LeafNode)->Index, (*LeafNode)->ParentNode);
TraceMsg (0,  Msg);
Tree_DumpNode  (SetHead,  *LeafNode);
}
while (Normal(*Status))
{
if (SetBug)
if (sprintf (Msg, "                   Node[%4u] KeyPos  =%3u\n",
(*LeafNode)->Index, *KeyPos))
TraceMsg  (0,   Msg);
if (*KeyPos == 0)
{
Tree_GetRecursePos (SetHead,  KeyValue, *LeafNode, McStat, KeyPos);
if (Normal(*Status))
*Status      = Set_Found;
} else if (*KeyPos == (*LeafNode)->NumKeys) {
if ((*LeafNode)->NodeLeafs[*KeyPos] == 0)
{
*Status = Set_EndOfSet;
} else {
*Status = Set_GtrThen;
}
} else {
Tree_CompareKey  (SetHead,                             KeyValue,
(*LeafNode)->NodeKeys[*KeyPos],
(*LeafNode)->NodeHandles[*KeyPos],   McStat);
if (Normal(*Status))
*Status   = Set_Found;
}
if (*Status == Set_LessThen)
{
*Status = Env_Normal;
if ((NodeIndex = (*LeafNode)->NodeLeafs[*KeyPos]) > 0)
{
if (Tree_DefrostNode   (SetHead,    (*LeafNode)->Index,    McStat))
Tree_RecurseSearch (SetHead,      KeyValue, NodeIndex,
McStat,       LeafNode, KeyPos);
} else
*Status = Set_EndOfSet;
} else if (*Status == Set_GtrThen) {
*Status  = Env_Normal;
if (*KeyPos + 1 == (*LeafNode)->NumKeys
&& (NodeIndex    = (*LeafNode)->NodeLeafs[*KeyPos+1]) > 0)
{
if (Tree_DefrostNode   (SetHead,    (*LeafNode)->Index,    McStat))
Tree_RecurseSearch (SetHead,      KeyValue, NodeIndex,
McStat,       LeafNode, KeyPos);
} else if (*KeyPos < (*LeafNode)->NumKeys)
++(*KeyPos);
else
*Status = Set_EndOfSet;
}
}
TRACK(TrackBak,"Tree_RecurseSearch\n");
return (STAT);
}
boolean    Tree_GetRecursePos
(ltreesethead *SetHead,      addrtype      KeyValue,
lbtreenode   *LeafNode,
ft F,lt Z,zz *Status,       indextype    *KeyPos)
{
indextype        Pos             = 0;
numtype          LowKey          = 0;
numtype          MidKey          = 0;
numtype          HighKey         = 0;
numtype          Span            = 0;
boolean          NotFound        = True;
*KeyPos                       = 0;
if (LeafNode->NumKeys)
{
NotFound   = False;
*Status     = Env_Normal;
Tree_CompareKey (SetHead,                         KeyValue,
LeafNode->NodeKeys[LowKey],
LeafNode->NodeHandles[LowKey],   McStat);
if (Normal(*Status))
{
*KeyPos     = LowKey;
*Status     = Set_Found;
} else if (*Status    == Set_LessThen) {
*KeyPos     = LowKey;
} else {
if (LeafNode->NumKeys > 1)
{
Pos        = LeafNode->NumKeys - 1;
*Status     = Env_Normal;
Tree_CompareKey (SetHead,                      KeyValue,
LeafNode->NodeKeys[Pos],
LeafNode->NodeHandles[Pos],   McStat);
if (Normal(*Status))
{
*KeyPos     = Pos;
*Status     = Set_Found;
} else if (*Status    == Set_GtrThen)  {
*KeyPos     = Pos;
} else {
*Status     = Set_GtrThen;
NotFound   = True;
}
} else
NotFound   = True;
}
}
if (NotFound)
{
if (LeafNode->NumKeys  > 10)
{
*Status          = Env_Normal;
HighKey         = Pos;
Span            = (HighKey - LowKey) / 2;
MidKey          = LowKey + Span;
while (NotFound)
{
*Status       = Env_Normal;
*KeyPos       = MidKey;
Tree_CompareKey (SetHead,                         KeyValue,
LeafNode->NodeKeys[MidKey],
LeafNode->NodeHandles[MidKey],   McStat);
if (Normal(*Status))
{
NotFound  = False;
*Status    = Set_Found;
} else {
if (*Status  == Set_GtrThen)
{
LowKey    = MidKey;
*KeyPos    = MidKey + 1;
*Status    = Set_LessThen;
} else
HighKey   = MidKey;
if (HighKey - LowKey > 1)
{
Span      = (HighKey - LowKey) / 2;
MidKey    =  LowKey  + Span;
} else
NotFound  = False;
}
}
} else {
;
}
}
if (SetBug)
if (sprintf (Msg, "    Recurse LeafNode Key Position =%3u; Status = %4d\n",
*KeyPos, *Status))
TraceMsg (0, Msg);
TRACK(TrackBak,"Tree_GetRecursePos\n");
return (STAT);
}
boolean    Tree_CreateNode
(ltreesethead  *SetHead,     ft F,lt Z,zz  *Status,
indextype     *Index,       lbtreenode   **LeafNode)
{
tokentype   TreeTkn    = NullToken;
lbtreenode *TreeNode   = NullPtr;
indextype   Offset     = SetHead->MaxKeys * sizeof (handletype);
Ut_AlignStruc    (&Offset);
TreeTkn.DbId    = SetHead->TreeDbId;
TreeTkn.Handle  = 1;
if (Grp_CreateEntry  (&TreeTkn,    SetHead->TreeNodesDir,
McStat,      Index))
if (Grp_GetFrozenEntry
(&TreeTkn,    SetHead->TreeNodesDir,   *Index,
McStat,     (addrtype *)LeafNode))
{
++SetHead->NodeCount;
TreeNode              = *LeafNode;
TreeNode->Index       = *Index;
TreeNode->ParentNode  = 0;
TreeNode->NumKeys     = 0;
TreeNode->NodeKeys    = (indextype  *)((char *)TreeNode
+  sizeof(lbtreenode));
TreeNode->NodeHandles = (handletype *)((char *)TreeNode->NodeKeys
+  Offset);
TreeNode->NodeLeafs   = (indextype  *)((char *)TreeNode->NodeHandles
+  Offset);
}
TRACK(TrackBak,"Tree_CreateNode\n");
return (STAT);
}
boolean    Tree_GetFrozenNode
(ltreesethead  *SetHead,     indextype      Index,
ft F,lt Z,zz  *Status,      lbtreenode   **LeafNode)
{
tokentype   TreeTkn    = NullToken;
lbtreenode        *TreeNode   = NullPtr;
indextype          Offset     = SetHead->MaxKeys * sizeof (handletype);
Ut_AlignStruc      (&Offset);
TreeTkn.DbId      = SetHead->TreeDbId;
TreeTkn.Handle    = 1;
if (Grp_GetFrozenEntry  (&TreeTkn,  SetHead->TreeNodesDir, Index,
McStat,  (addrtype *)LeafNode))
{
TreeNode              = *LeafNode;
TreeNode->NodeKeys    = (indextype *)((char *)TreeNode
+                sizeof(lbtreenode));
TreeNode->NodeHandles = (handletype *)((char *)TreeNode->NodeKeys
+  Offset);
TreeNode->NodeLeafs   = (indextype  *)((char *)TreeNode->NodeHandles
+  Offset);
}
TRACK(TrackBak,"Tree_GetFrozenNode\n");
return (STAT);
}
boolean    Tree_FreezeNode
(ltreesethead  *SetHead,     indextype      Index,
ft F,lt Z,zz  *Status)
{
tokentype   TreeTkn = NullToken;
TreeTkn.DbId      = SetHead->TreeDbId;
TreeTkn.Handle    = 1;
Grp_FreezeEntry    (&TreeTkn,  SetHead->TreeNodesDir, Index, McStat);
TRACK(TrackBak,"Tree_FreezeNode\n");
return (STAT);
}
boolean    Tree_DefrostNode
(ltreesethead  *SetHead,     indextype      Index,
ft F,lt Z,zz  *Status)
{
tokentype   TreeTkn = NullToken;
TreeTkn.DbId      = SetHead->TreeDbId;
TreeTkn.Handle    = 1;
Grp_DefrostEntry    (&TreeTkn,  SetHead->TreeNodesDir, Index, McStat);
TRACK(TrackBak,"Tree_DefrostNode\n");
return (STAT);
}
boolean    Tree_NodeIsFrosted
(ltreesethead  *SetHead,     indextype      Index,
ft F,lt Z,zz  *Status)
{
tokentype   TreeTkn = NullToken;
TreeTkn.DbId      = SetHead->TreeDbId;
TreeTkn.Handle    = 1;
return (Grp_EntryIsFrosted (&TreeTkn,  SetHead->TreeNodesDir, Index, McStat));
}
void       Tree_DumpNode
(ltreesethead  *SetHead,     lbtreenode    *LeafNode)
{
inttype            i            = 0;
if (LeafNode != NullPtr)
{
if (SetBug)
{
sprintf  (Msg, "    SetHead[%4u:%4u]  RootNode[%4u]\n",
SetHead->TreeDbId, SetHead->Token.Handle,
SetHead->TreeRootNode);
TraceMsg (0,  Msg);
}
sprintf  (Msg, "    Leaf Node[%4u];   Parent[%4u];   Num Keys=%4u\n",
LeafNode->Index, LeafNode->ParentNode, LeafNode->NumKeys);
TraceMsg (0,  Msg);
TraceMsg (0,   "       Keys     []::\n          ");
for (i = 0; i < LeafNode->NumKeys; )
{
sprintf  (Msg, "    %4u", LeafNode->NodeKeys[i]);
TraceMsg (0,  Msg);
if (++i % 5 == 0)
TraceMsg (0,  "\n          ");
}
TraceMsg (0,   "\n       Handles  []::\n          ");
for (i = 0; i < LeafNode->NumKeys; )
{
sprintf  (Msg, "    %4u", LeafNode->NodeHandles[i]);
TraceMsg (0,  Msg);
if (++i % 5 == 0)
TraceMsg (0,  "\n          ");
}
TraceMsg (0,   "\n       NodeLeafs[]::\n          ");
for (i = 0; i < LeafNode->NumKeys+1; )
{
sprintf  (Msg, "    %4u", LeafNode->NodeLeafs[i]);
TraceMsg (0,  Msg);
if (++i % 5 == 0)
TraceMsg (0,  "\n          ");
}
TraceMsg (0,   "\n\n");
}
return;
}
boolean    Tree_NewKey
(ltreesethead  *SetHead,     addrtype       KeyValue,
ft F,lt Z,zz  *Status,      indextype     *Index)
{
tokentype   TreeTkn    = NullToken;
TreeTkn.DbId    = SetHead->TreeDbId;
TreeTkn.Handle  = 1;
SetHead->KeyCount       += 1;
if (SetHead->KeySize <= sizeof (indextype))
*Index             = *(indextype *)KeyValue;
else
Grp_PutNewEntry   (&TreeTkn, SetHead->TreeKeysDir, KeyValue,
McStat,   Index);
TRACK(TrackBak,"Tree_NewKey\n");
return (STAT);
}
boolean    Tree_GetFrozenKey
(ltreesethead  *SetHead,     indextype     *Index,
ft F,lt Z,zz  *Status,      addrtype      *KeyValue)
{
tokentype   TreeTkn    = NullToken;
TreeTkn.DbId      = SetHead->TreeDbId;
TreeTkn.Handle    = 1;
if (SetHead->KeySize <= sizeof (indextype))
*KeyValue  = (addrtype )Index;
else
Grp_GetFrozenEntry  (&TreeTkn,  SetHead->TreeKeysDir, *Index,
McStat,                          KeyValue);
TRACK(TrackBak,"Tree_GetFrozenKey\n");
return (STAT);
}
boolean    Tree_DefrostKey
(ltreesethead  *SetHead,     indextype      Index,
ft F,lt Z,zz  *Status)
{
tokentype   TreeTkn = NullToken;
TreeTkn.DbId      = SetHead->TreeDbId;
TreeTkn.Handle    = 1;
if (SetHead->KeySize > sizeof (indextype))
Grp_DefrostEntry  (&TreeTkn,  SetHead->TreeKeysDir, Index, McStat);
TRACK(TrackBak,"Tree_DefrostKey\n");
return (STAT);
}
boolean    Tree_GetNodeInsertPos
(ltreesethead *SetHead,      indextype     KeyIndex,
lbtreenode   *LeafNode,
ft F,lt Z,zz *Status,       indextype    *KeyPos)
{
indextype        Index           = KeyIndex;
addrtype         KeyValue        = NullPtr;
indextype        Pos             = 0;
numtype          LowKey          = 0;
numtype          MidKey          = 0;
numtype          HighKey         = 0;
numtype          Span            = 0;
boolean          NotFound        = True;
statustype       ShellStatus     = Env_Normal;
*KeyPos                       = 0;
if (Tree_GetFrozenKey      (SetHead,    &Index,   McStat,  &KeyValue))
if (LeafNode->NumKeys  > 2)
{
Pos            = LeafNode->NumKeys - 1;
Tree_CompareKey (SetHead,                      KeyValue,
LeafNode->NodeKeys[Pos],
LeafNode->NodeHandles[Pos],   McStat);
if (Normal(*Status))
{
*KeyPos     = Pos;
NotFound   = False;
} else if (*Status    == Set_GtrThen)  {
*KeyPos     = Pos + 1;
NotFound   = False;
} else if (*Status    == Set_LessThen)  {
*Status         = Env_Normal;
Tree_CompareKey (SetHead,                         KeyValue,
LeafNode->NodeKeys[LowKey],
LeafNode->NodeHandles[LowKey],   McStat);
if (Normal(*Status))
{
*KeyPos     = LowKey;
NotFound   = False;
} else if (*Status    == Set_LessThen) {
*KeyPos     = LowKey;
NotFound   = False;
} else if (*Status    == Set_GtrThen) {
(*KeyPos)++;
NotFound   = True;
} else {
NotFound   = False;
}
}
}
if (NotFound)
{
*Status   = Env_Normal;
if (LeafNode->NumKeys  > 9999)
{
HighKey         = LeafNode->NodeKeys[Pos];
Span            = (HighKey - LowKey) / 2;
MidKey          = LowKey + Span;
if (Span % 2)
++MidKey;
while (NotFound)
{
*Status    = Env_Normal;
*KeyPos       = MidKey;
Tree_CompareKey (SetHead,                         KeyValue,
LeafNode->NodeKeys[MidKey],
LeafNode->NodeHandles[MidKey],   McStat);
if (Normal(*Status))
NotFound     = False;
else
{
if (*Status  == Set_GtrThen)
{
LowKey    = MidKey;
(*KeyPos)++;
} else
HighKey   = MidKey;
if (HighKey - LowKey > 1)
{
Span      = (HighKey - LowKey) / 2;
MidKey    =  LowKey  + Span;
if (Span  % 2)
++MidKey;
} else
NotFound  = False;
}
}
} else {
while (Normal(*Status)
&&    *KeyPos < LeafNode->NumKeys)
{
Tree_CompareKey     (SetHead,                        KeyValue,
LeafNode->NodeKeys[*KeyPos],
LeafNode->NodeHandles[*KeyPos], McStat);
if (*Status == Set_GtrThen)
{
*Status = Env_Normal;
(*KeyPos)++;
}
}
}
}
if (*Status == Set_LessThen)
*Status = Env_Normal;
if (SetBug)
if (sprintf (Msg, "    Insert at Key Pos=%3u; Status = %2u\n",
*KeyPos, *Status))
TraceMsg (0, Msg);
ShellStatus = Env_Normal;
Tree_DefrostKey     (SetHead,      KeyIndex,     ShellMcStat);
TRACK(TrackBak,"Tree_GetNodeInsertPos\n");
return (STAT);
}
boolean    Tree_CompareKey
(ltreesethead *SetHead,      addrtype      CompValue,
indextype     KeyIndex,     handletype    ObjHandle,
ft F,lt Z,zz *Status)
{
typetype     KeyType         = SetHead->KeyType;
sizetype     KeySize         = SetHead->KeySize;
unsigned char
Value[MAXSTRING];
addrtype     ValuePtr        =  (addrtype )&Value[0];
int          i               = 0;
bytetype    *ByteValue       = NULL;
idtype      *IdValue         = NULL;
inttype     *IntValue        = NULL;
tokentype   *TknValue        = NULL;
tokentype   *CompTkn         = NULL;
float       *FloatValue      = NULL;
double      *DoubleValue     = NULL;
addrtype    *AddrValue       = NULL;
handletype  *HndlValue       = NULL;
tokentype    TreeTkn         = NullToken;
memset (Value, NULL, MAXSTRING);
TreeTkn.DbId      = SetHead->TreeDbId;
TreeTkn.Handle    = 1;
if (SetHead->KeySize <= sizeof (indextype))
*(indextype *)ValuePtr   =  KeyIndex;
else
Grp_GetEntry   (&TreeTkn,  SetHead->TreeKeysDir, KeyIndex,
McStat,                          ValuePtr);
if (Normal(*Status))
switch (KeyType)
{
case aDbmsString          :
*Status = Err_NotImplemented;
break;
case aString     :
i = Ut_CompareString ((char *)CompValue, (char *)ValuePtr);
if (DeBug || SetBug || OaBug)
{
sprintf (Msg,
" Tree_CompareKey:: <%-16s> To <%-16s>; i = %d\n",
CompValue, ValuePtr, i);
TraceMsg (0,  Msg);
}
break;
case aLink       :
if (KeySize == sizeof (tokentype ))
{
TknValue    = (tokentype *)ValuePtr;
CompTkn     = (tokentype *)CompValue;
if (CompTkn->Handle < TknValue->Handle)
i = -1;
else if (CompTkn->Handle > TknValue->Handle)
i = 1;
if (i == 0
&& CompTkn->DbId  != TknValue->DbId)
i = -1;
} else {
HndlValue   = (handletype *)ValuePtr;
if (*(handletype *)CompValue < *HndlValue)
i = -1;
else if (*(handletype *)CompValue > *HndlValue)
i = 1;
}
break;
case aReal       :
if (KeySize == sizeof (float))
{
FloatValue    = (float *)ValuePtr;
if (*(float *)CompValue < *FloatValue)
i = -1;
else if (*(float *)CompValue > *FloatValue)
i = 1;
} else if (KeySize == sizeof (double)) {
DoubleValue    = (double *)ValuePtr;
if (*(double *)CompValue < *DoubleValue)
i = -1;
else if (*(double *)CompValue > *DoubleValue)
i = 1;
}
break;
case aAddr       :
AddrValue    = (addrtype *)ValuePtr;
if (*(addrtype *)CompValue != AddrValue)
i = 1;
break;
case aEnum       :
case aBoolean    :
case aValue      :
case aChunk      :
case aInteger    :
switch (KeySize)
{
case 1     :
ByteValue    = (bytetype *)ValuePtr;
if (*(bytetype *)CompValue < *ByteValue)
i = -1;
else if (*(bytetype *)CompValue > *ByteValue)
i = 1;
break;
case 2     :
IdValue    = (idtype *)ValuePtr;
if (*(idtype *)CompValue < *IdValue)
i = -1;
else if (*(idtype *)CompValue > *IdValue)
i = 1;
break;
case 4     :
IntValue    = (inttype *)ValuePtr;
if (*(inttype *)CompValue < *IntValue)
i = -1;
else if (*(inttype *)CompValue > *IntValue)
i = 1;
break;
#ifdef LARGE
case sizeof (tokentype )  :
TknValue    = (tokentype *)ValuePtr;
CompTkn     = (tokentype *)CompValue;
if (CompTkn->Handle < TknValue->Handle)
i = -1;
else if (CompTkn->Handle > TknValue->Handle)
i = 1;
if (i == 0
&& CompTkn->DbId  != TknValue->DbId)
i = -1;
break;
#endif
default    :
if (KeySize <= sizeof (tokentype ))
i = memcmp  ((char *)CompValue,
(char *)ValuePtr, (size_t )KeySize);
else
i = strncmp ((char *)CompValue,
(char *)ValuePtr, (size_t )KeySize);
}
break;
}
if (DeBug || SetBug || OaBug)
{
if (KeyType != aString)
if (KeySize <= sizeof (tokentype ))
{
TraceMsg   (0, "                   Compare :: Value=");
TraceBytes (0,   ValuePtr, KeySize);
sprintf    (Msg, "; i = %d\n",       i);
TraceMsg   (0, Msg);
} else {
sprintf (Msg,
"                    Compare :: Value=<%12s>; i = %d\n",
Value, i);
TraceMsg (0,  Msg);
}
}
if (Normal (*Status))
if (i == 0)
if (SetHead->Key2ary)
{
Tree_Compare2aryKey  (SetHead,  ObjHandle,  McStat);
if (Normal(*Status))
i = 0;
}
if (Normal (*Status))
{
if (!i)
{
if (DeBug || OaBug)
if (sprintf (Msg,
"     COMPARED on Key  Index =%6u; Primary KeyValue = ", KeyIndex))
if (TraceBytes (0, ValuePtr, KeySize))
TraceMsg (0, "\n");
} else if (i < 0) {
*Status = Set_LessThen;
} else {
*Status = Set_GtrThen;
}
}
TRACK(TrackBak,"Tree_CompareKey\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\tree01.c*/

#define  TREE01
#define  SPCL1


boolean Env_GetClassId
(char         *ClassName,
ft F,lt Z,zz *Status,    numtype      *ClassId);
#define        Env_GetMemberId  Env_GetAttrId
boolean Env_GetAttrId
(char         *AttrName,
ft F,lt Z,zz *Status,    numtype      *AttrId);
boolean Env_GetAttrInfo
(numtype       AttrId,
ft F,lt Z,zz *Status,    attrinfotype *AttrInfo);
boolean Env_InitClassMap
(numtype       ClassId,   size_t        ObjSize,
numtype       AplId,     ft F,lt Z,zz *Status);
boolean Env_InvokeMap
(numtype       AplId,     ft F,lt Z,zz *Status);
boolean Object_Create
(tokentype    *Anchor,    numtype       ClassId,
ft F,lt Z,zz *Status,    tokentype    *Token);
boolean Object_PutImage
(tokentype    *Token,     ft F,lt Z,zz *Status);
boolean Object_CommitImage
(tokentype    *Token,     boolean       Release,
ft F,lt Z,zz *Status);
boolean Object_GetImage
(tokentype    *Token,
ft F,lt Z,zz *Status,    addrtype     *Image);
void    Object_Dump
(tokentype    *Token);
boolean Attr_ArrayCreate
(tokentype    *Token,     numtype       AttrId,
indextype     UnitCount, sizetype      UnitSize,
ft F,lt Z,zz *Status,    addrtype     *Array);
boolean    SpclAddIntoTree
(handletype    SetDescHndl,
tokentype    *OwnerTkn,     tokentype     *MemberTkn,
ft F,lt Z,zz *Status,       tokentype     *NodeTkn)
{
tokentype        SetDescTkn;
setdesctype     *SetDesc         = NullPtr;
objtype         *Owner           = NullPtr;
objtype         *Member          = NullPtr;
ltreesethead    *SetHead         = NullPtr;
tokentype        SetHeadTkn;
sizetype         KeySize         = 0;
typetype         KeyType         = aInteger;
addrtype         Dummy           = PtrToVoid;
unsigned char    Value[MAXSTRING];
addrtype         ValuePtr        =  (addrtype )&Value[0];
statustype       DumpStatus      = Env_Normal;
attrobjtype      AttrDesc;
unsigned char    Key2aryValue[64];
addrtype         Key2aryVal      =  (addrtype )&Key2aryValue[0];
Key2aryValue[0]   = '\0';
Tree_OpType       = aTreeAddInto;
AddInto_MemberTkn = *MemberTkn;
memset (Value, NULL, MAXNAME);
SetHeadTkn.DbId   = OwnerTkn->DbId;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
NodeTkn->DbId     = OwnerTkn->DbId;
NodeTkn->Handle   = 0;
if (TempKeys_Attr == 0)
if (Env_GetMemberId  ("TempHandles",   McStat,     &TempHandles_Attr))
if (Env_GetMemberId  ("TempKeys",      McStat,     &TempKeys_Attr))
if (Env_GetMemberId  ("TempLeafs",     McStat,     &TempLeafs_Attr))
if (Env_GetClassId   ("bTreeSetHead",  McStat,     &bTreeSetHead_Class))
if (Env_InitClassMap (bTreeSetHead_Class,           sizeof(ltreesethead),
C_Apl,                        McStat))
Env_InvokeMap    (C_Apl,                        McStat);
if (SetBug || DeBug)
if (sprintf (Msg, "\n   SpclAddIntoTree:: SetTkn[%2u:%4u]\n",
SetDescTkn.DbId, SetDescTkn.Handle))
if (TraceMsg (0, Msg))
if (sprintf (Msg,"                 Owner [%2u:%4u]   Member[%2u:%4u]\n",
OwnerTkn->DbId,   OwnerTkn->Handle,
MemberTkn->DbId,  MemberTkn->Handle))
TraceMsg (0, Msg);
if (OaGetObject   (OwnerTkn,            McStat,   (addrtype *)&Owner))
if (OaGetObject   (MemberTkn,           McStat,   (addrtype *)&Member))
if (OaGetObject   (&SetDescTkn,         McStat,   (addrtype *)&SetDesc))
if (!OaGet        (False,               OwnerTkn, (addrtype  )Dummy,
SetDesc->OwnerAttrNum,
McStat,              (addrtype )&(SetHeadTkn.Handle)))
{
sprintf (Msg,"***ERROR***\n      OwnerAttr[%4u] Not of Owner Object\n",
SetDesc->OwnerAttrNum);
TraceMsg (0, Msg);
sprintf (Msg, " AT AddIntoSet:: <%-14s> SetTkn[%2u:%4u]\n",
SetDesc->Nam, SetDescTkn.DbId, SetDescTkn.Handle);
TraceMsg (0, Msg);
sprintf (Msg,"                 Owner [%2u:%4u]   Member[%2u:%4u]\n",
OwnerTkn->DbId,   OwnerTkn->Handle,
MemberTkn->DbId,  MemberTkn->Handle);
TraceMsg (0, Msg);
TraceMsg (0, "   For SetDesc...\n");
OaDumpObject (0, &SetDescTkn, Dump_Status);
*Status = Set_SetNotOfObjCestrs;
}
if (Normal(*Status))
if (Env_GetAttrInfo  (SetDesc->PrimaryKey,   McStat,   &AttrDesc))
{
KeySize    = AttrDesc.Size;
KeyType    = AttrDesc.TypeType;
}
if (Normal(*Status))
if (SetDesc->Key2ary)
if (!OaGet        (False,               MemberTkn, (addrtype  )Dummy,
SetDesc->Key2ary,
McStat,                         (addrtype  )Key2aryVal))
{
sprintf (Msg,"***ERROR***   2ary KeyAttr[%4u] Not of Member Object\n",
SetDesc->Key2ary);
TraceMsg (0, Msg);
sprintf (Msg, " AT AddIntoSet:: <%-14s> SetTkn[%2u:%4u]\n",
SetDesc->Nam, SetDescTkn.DbId, SetDescTkn.Handle);
TraceMsg (0, Msg);
sprintf (Msg,"                 Owner [%2u:%4u]   Member[%2u:%4u]\n",
OwnerTkn->DbId,   OwnerTkn->Handle,
MemberTkn->DbId,  MemberTkn->Handle);
TraceMsg (0, Msg);
TraceMsg (0, "   For SetDesc...\n");
OaDumpObject (0, &SetDescTkn, Dump_Status);
*Status = Set_SetNotOfObjCestrs;
} else {
FindIn_2aryKey    = Key2aryVal;
}
if (Normal(*Status))
if (SetHeadTkn.Handle == NullHandle)
if (Tree_Create    (SetDescHndl,     OwnerTkn,  7,  5000,   KeySize,
KeyType,         McStat,  &SetHeadTkn))
{
OaPut          (False,           OwnerTkn,      (addrtype )Owner,
SetDesc->OwnerAttrNum,     (addrtype )&SetHeadTkn,
McStat);
}
if (Normal(*Status))
if (KernelGetAttr     (MemberTkn, SetDesc->PrimaryKey, McStat, ValuePtr))
{
if (SetBug || DeBug || DbmBug)
{
if (sprintf (Msg,
"\n   SpclAddIntoTree %14s[%2u:%4u];  Owner[%2u:%4u]\n",
SetDesc->Nam,      SetDescTkn.DbId,  SetDescTkn.Handle,
OwnerTkn->DbId,    OwnerTkn->Handle))
if (TraceMsg (0, Msg))
if (KeySize > sizeof(indextype))
sprintf (Msg, "              Member [%2u:%4u] Key(*%u)[%4u] = <%12s>\n",
MemberTkn->DbId,    MemberTkn->Handle,
KeySize,            SetDesc->PrimaryKey, Value);
else
sprintf (Msg, "              Member [%2u:%4u] Key(*%u)[%4u] = <%4u>\n",
MemberTkn->DbId,    MemberTkn->Handle,
KeySize,            SetDesc->PrimaryKey, *(numtype *)Value);
TraceMsg (0, Msg);
if (sprintf (Msg, "              SetHead[%2u:%4u]\n\n",
SetHeadTkn.DbId, SetHeadTkn.Handle))
TraceMsg (0, Msg);
}
} else {
sprintf (Msg,"***ERROR*** Primary Key Attr[%4u] Not of Member Class\n",
SetDesc->PrimaryKey);
TraceMsg (0, Msg);
sprintf (Msg, " AT AddIntoSet:: %14s SetTkn[%2u:%4u]\n",
SetDesc->Nam, SetDescTkn.DbId, SetDescTkn.Handle);
TraceMsg (0, Msg);
sprintf (Msg,"                 Owner [%2u:%4u]   Member[%2u:%4u]\n",
OwnerTkn->DbId,   OwnerTkn->Handle,
MemberTkn->DbId,  MemberTkn->Handle);
TraceMsg (0, Msg);
*Status = Set_KeyNotOfObjCestrs;
}
if (Normal(*Status))
if (OaPut          (False,          MemberTkn,       (addrtype  )Member,
SetDesc->MemberAttrNum,
(addrtype )&(SetHeadTkn.Handle),             McStat))
if (Object_GetImage(&SetHeadTkn,    McStat,         (addrtype *)&SetHead))
Tree_AddInto   (SetHead,        ValuePtr, MemberTkn->Handle, McStat);
if (SetBug)
{
if (KeySize <= 4)
sprintf  (Msg, "      SpclAddIntoTree ::  <%6u>;\n",
*(numtype *)ValuePtr);
else
sprintf  (Msg, "      SpclAddIntoTree ::  <%-12s>;\n",
Value);
if (TraceMsg (0,   Msg))
if (SetHead)
if (sprintf  (Msg, "         Nodes =%4u;   Keys     = %4u;\n\n",
SetHead->NodeCount, SetHead->KeyCount))
TraceMsg (0,   Msg);
}
Tree_OpType       = aNonTreeOp;
TRACK(TrackBak,"SpclAddInToTree\n");
return (STAT);
}
boolean    SpclFindIn2aryTree
(handletype     SetDescHndl, tokentype     *OwnerTkn,
addrtype       KeyValue,    addrtype       Key2aryVal,
ft F,lt Z,zz  *Status,
tokentype     *NodeTkn,     tokentype     *MemberTkn)
{
Tree_OpType       = aTreeFindIn;
FindIn_2aryKey    = Key2aryVal;
SpclFindInTree     (SetDescHndl, OwnerTkn, KeyValue,
McStat,      NodeTkn,  MemberTkn);
TRACK(TrackBak,"SpclFindIn2aryTree\n");
return (STAT);
}
boolean    SpclFindInTree
(handletype     SetDescHndl, tokentype     *OwnerTkn,
addrtype       KeyValue,
ft F,lt Z,zz  *Status,
tokentype     *NodeTkn,     tokentype     *MemberTkn)
{
tokentype        SetDescTkn;
setdesctype     *SetDesc     = NullPtr;
objtype         *Owner       = NullPtr;
ltreesethead    *SetHead     = NullPtr;
tokentype        SetHeadTkn  = NullToken;
numtype          PrimaryKey  = 0;
bytessize        KeySize     = 0;
addrtype         Dummy       = NullPtr;
lbtreenode      *LeafNode    = NullPtr;
indextype        KeyPos      = 0;
Tree_OpType       = aTreeFindIn;
FindIn_2aryKey    = NullPtr;
if (TempKeys_Attr == 0)
if (Env_GetMemberId  ("TempHandles",   McStat,     &TempHandles_Attr))
if (Env_GetMemberId  ("TempKeys",      McStat,     &TempKeys_Attr))
if (Env_GetMemberId  ("TempLeafs",     McStat,     &TempLeafs_Attr))
if (Env_GetClassId   ("bTreeSetHead",  McStat,     &bTreeSetHead_Class))
if (Env_InitClassMap (bTreeSetHead_Class,           sizeof(ltreesethead),
C_Apl,                        McStat))
Env_InvokeMap    (C_Apl,                        McStat);
SetHeadTkn.DbId   = OwnerTkn->DbId;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
MemberTkn->DbId   = OwnerTkn->DbId;
NodeTkn->DbId     = OwnerTkn->DbId;
NodeTkn->Handle   = 0;
if (SetBug || DeBug)
if (sprintf (Msg, "\n   SpclFindInTree:: SetTkn[%2u:%4u]... OwnerTkn[%3u:%4u]\n",
SetDescTkn.DbId, SetDescTkn.Handle,
OwnerTkn->DbId,   OwnerTkn->Handle))
TraceMsg (0, Msg);
if (OaGetObject   (&SetDescTkn,  McStat,     (addrtype *)&SetDesc))
if (OaGetObject   (OwnerTkn,     McStat,     (addrtype *)&Owner))
{
PrimaryKey     = SetDesc->PrimaryKey;
}
if (Normal(*Status))
if (DeBug || SetBug)
if (sprintf  (Msg, "    SetDesc @%8x ->PrimaryKey @%8x; KeyAttrNum=%3u\n",
SetDesc,  &SetDesc->PrimaryKey, PrimaryKey))
TraceMsg (0,   Msg);
if (Normal(*Status))
if (OaGetAttrSize (&RenvTkn,                  PrimaryKey,
McStat,       (addrtype )&KeySize))
if (OaGet         (False,                     OwnerTkn,
(addrtype )Dummy,          SetDesc->OwnerAttrNum,
McStat,        (addrtype )&SetHeadTkn.Handle))
if (SetHeadTkn.Handle == NullHandle)
{
if (DeBug || SetBug)
TraceMsg (0, "    ... Empty Set.\n");
*Status = Set_EmptySet;
}
if (Normal(*Status))
if (OaGet          (False,                                 OwnerTkn,
(addrtype )Dummy,             SetDesc->OwnerAttrNum,
McStat,         (addrtype )&SetHeadTkn.Handle))
if (Object_GetImage(&SetHeadTkn,     McStat,  (addrtype *)&SetHead))
if (OaUpdateObject (&SetHeadTkn,     McStat))
{
if (SetBug || DeBug)
{
if (KeySize <= 4)
sprintf (Msg,
"\n  FindInTree  %14s[%2u:%4u];  Owner[%2u:%4u] Key(* %2u)= <%6d>\n",
SetDesc->Nam,    SetDescTkn.DbId,  SetDescTkn.Handle,
OwnerTkn->DbId,  OwnerTkn->Handle,
KeySize,         *(int *)KeyValue);
else
sprintf (Msg,
"\n  FindInTree  %14s[%2u:%4u];  Owner[%2u:%4u] Key(* %2u)= <%-12s>\n",
SetDesc->Nam,    SetDescTkn.DbId,  SetDescTkn.Handle,
OwnerTkn->DbId,  OwnerTkn->Handle,
KeySize,         (char *)KeyValue);
TraceMsg (0, Msg);
}
if (DeBug || SetBug)
if (sprintf (Msg, "     PrimaryKey(*%4u)  = %3u\n",
KeySize, PrimaryKey))
TraceMsg (0, Msg);
if (DeBug || SetBug)
if (sprintf (Msg, "     KeyAttr (%3u) size %u \n",
PrimaryKey, KeySize))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "     SetHead    [%3u:%4u] @ %x\n",
SetHeadTkn.DbId, SetHeadTkn.Handle, SetHead))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "             ->TreeNodesDir[%3u:%4u] \n",
SetHeadTkn.DbId, SetHead->TreeNodesDir))
if (TraceMsg (0, Msg))
if (sprintf (Msg, "             ->TreeKeysDir [%3u:%4u] \n",
SetHeadTkn.DbId, SetHead->TreeKeysDir))
TraceMsg (0, Msg);
}
if (Normal(*Status))
Tree_FindIn       (SetHead,    KeyValue,
McStat,    &LeafNode,   &KeyPos);
if (DeBug  || SetBug)
{
if (KeySize > 4)
sprintf (Msg,
"      SpclFindInTree:: <%-12s> LeafNode[%4u] Pos=%3u;\n",
(char *)KeyValue, LeafNode->Index, KeyPos);
else
sprintf (Msg,
"      SpclFindInTree:: <%6d  > LeafNode[%4u] Pos=%3u;\n",
*(int *)KeyValue, LeafNode->Index, KeyPos);
TraceMsg (0,   Msg);
sprintf  (Msg, "                        Status      = %d;\n",
*Status);
TraceMsg (0,   Msg);
}
if (*Status == Set_Found)
{
*Status  = Env_Normal;
MemberTkn->Handle = LeafNode->NodeHandles[KeyPos];
}
Tree_OpType       = aNonTreeOp;
TRACK(TrackBak,"SpclFindInTree\n");
return (STAT);
}
boolean    SpclTraverseTree
(handletype     SetDescHndl, tokentype     *OwnerTkn,
treeiterfunc   IterFunc,    ft F,lt Z,zz  *Status)
{
tokentype        SetDescTkn  = NullToken;
setdesctype     *SetDesc     = NullPtr;
ltreesethead    *SetHead     = NullPtr;
tokentype        SetHeadTkn  = NullToken;
numtype          IterNum     = 0;
indextype        LeafIndex   = 0;
addrtype         Dummy       = NullPtr;
Tree_OpType       = aTreeTraverse;
if (TempKeys_Attr == 0)
if (Env_GetMemberId  ("TempHandles",   McStat,     &TempHandles_Attr))
if (Env_GetMemberId  ("TempKeys",      McStat,     &TempKeys_Attr))
if (Env_GetMemberId  ("TempLeafs",     McStat,     &TempLeafs_Attr))
if (Env_GetClassId   ("bTreeSetHead",  McStat,     &bTreeSetHead_Class))
if (Env_InitClassMap (bTreeSetHead_Class,           sizeof(ltreesethead),
C_Apl,                        McStat))
Env_InvokeMap    (C_Apl,                        McStat);
SetHeadTkn.DbId   = OwnerTkn->DbId;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
if (SetBug || DeBug)
if (sprintf (Msg,
"\n   SpclTraverseTree:: SetTkn[%2u:%4u]... OwnerTkn[%3u:%4u]\n",
SetDescTkn.DbId, SetDescTkn.Handle,
OwnerTkn->DbId,   OwnerTkn->Handle))
TraceMsg (0, Msg);
if (OaGetObject   (&SetDescTkn,
McStat,                   (addrtype *)&SetDesc))
if (OaGet         (False,                     OwnerTkn,
(addrtype )Dummy,          SetDesc->OwnerAttrNum,
McStat,        (addrtype )&SetHeadTkn.Handle))
if (SetHeadTkn.Handle)
{
if (OaGetObject   (&SetHeadTkn,   McStat,    (addrtype *)&SetHead))
Tree_Traverse  (SetHead,  LeafIndex,  &IterNum,  IterFunc,  McStat);
} else {
if (DeBug || SetBug)
TraceMsg (0, "    ... Empty Set.\n");
*Status          = Set_EmptySet;
}
Tree_OpType       = aNonTreeOp;
TRACK(TrackBak,"SpclTraverseTree\n");
return (STAT);
}
boolean    Spcl_TreeIterateOn
(numtype        SetId,       tokentype     *OwnerTkn,
ft F,lt Z,zz  *Status,      indextype     *KeyPos,
numtype       *ItNum,       tokentype     *MemberTkn,
addrtype      *SetHead,     indextype     *LeafNode)
{
tokentype        SetDescTkn  = NullToken;
setdesctype     *SetDesc     = NullPtr;
tokentype        SetHeadTkn  = NullToken;
ltreesethead    *TreeHead    = NullPtr;
indextype        LeafIndex   = 0;
addrtype         Dummy       = NullPtr;
Tree_OpType           = aTreeTraverse;
if (*ItNum           == 0)
{
if (TempKeys_Attr == 0)
if (Env_GetMemberId  ("TempHandles",   McStat,     &TempHandles_Attr))
if (Env_GetMemberId  ("TempKeys",      McStat,     &TempKeys_Attr))
if (Env_GetMemberId  ("TempLeafs",     McStat,     &TempLeafs_Attr))
if (Env_GetClassId   ("bTreeSetHead",  McStat,     &bTreeSetHead_Class))
if (Env_InitClassMap (bTreeSetHead_Class,           sizeof(ltreesethead),
C_Apl,                        McStat))
Env_InvokeMap    (C_Apl,                        McStat);
SetHeadTkn.DbId   = OwnerTkn->DbId;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetId;
if (SetBug || DeBug)
if (sprintf (Msg,
"\n   Spcl_TreeIterateOn:: SetTkn[%2u:%4u]... OwnerTkn[%3u:%4u]\n",
SetDescTkn.DbId, SetDescTkn.Handle,
OwnerTkn->DbId,   OwnerTkn->Handle))
TraceMsg (0, Msg);
if (Normal(*Status))
if (OaGetObject   (&SetDescTkn,
McStat,                   (addrtype *)&SetDesc))
if (OaGet         (False,                     OwnerTkn,
(addrtype )Dummy,          SetDesc->OwnerAttrNum,
McStat,        (addrtype )&SetHeadTkn.Handle))
if (SetHeadTkn.Handle == NullHandle)
{
if (DeBug || SetBug)
TraceMsg (0, "    ... Empty Set.\n");
*Status = Set_EmptySet;
} else
OaGetObject   (&SetHeadTkn,   McStat,    (addrtype *)&SetHead);
}
if (Normal(*Status))
{
MemberTkn->DbId   = OwnerTkn->DbId;
TreeHead          = *(ltreesethead **)SetHead;
LeafIndex         = *LeafNode;
Tree_IterateOn   (TreeHead,  McStat,    LeafNode,  KeyPos,
ItNum,    &MemberTkn->Handle);
}
Tree_OpType       = aNonTreeOp;
TRACK(TrackBak,"Spcl_TreeIterateOn\n");
return (STAT);
}
boolean    SpclDeleteFromTree
(handletype     SetDescHndl, tokentype   *MemberTkn,
ft F,lt Z,zz  *Status)
{
tokentype        SetDescTkn;
setdesctype     *SetDesc     = NullPtr;
ltreesethead    *SetHead     = NullPtr;
tokentype        SetHeadTkn;
addrtype         Dummy       = NullPtr;
sizetype         KeySize     = 0;
typetype         KeyType     = aInteger;
unsigned char    Value[MAXSTRING];
addrtype         ValuePtr    =  (addrtype )&Value[0];
handletype       Handle      = NullHandle;
attrobjtype      AttrDesc;
Tree_OpType       = aTreeDeleteFrom;
SetHeadTkn.DbId   = MemberTkn->DbId;
MemberTkn->DbId   = MemberTkn->DbId;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
if (SetBug || DeBug)
if (sprintf (Msg,
"\n   SpclDeleteTreeSet:: SetTkn[%2u:%4u]... MemberTkn[%3u:%4u]\n",
SetDescTkn.DbId, SetDescTkn.Handle,
MemberTkn->DbId,   MemberTkn->Handle))
TraceMsg (0, Msg);
if (OaGetObject   (&SetDescTkn,
McStat,                   (addrtype *)&SetDesc))
if (OaGet         (False,                     MemberTkn,
(addrtype )Dummy,          SetDesc->MemberAttrNum,
McStat,        (addrtype )&SetHeadTkn.Handle))
if (SetHeadTkn.Handle == NullHandle)
{
if (DeBug || SetBug)
TraceMsg (0, "    ... Empty Set.\n");
*Status = Set_EmptySet;
}
if (OaGetObject      (&SetHeadTkn,   McStat,  (addrtype *)&SetHead))
if (Env_GetAttrInfo  (SetDesc->PrimaryKey,      McStat,   &AttrDesc))
{
KeySize    = AttrDesc.Size;
KeyType    = AttrDesc.TypeType;
}
if (Normal(*Status))
if (KernelGetAttr     (MemberTkn, SetDesc->PrimaryKey, McStat, ValuePtr))
{
if (SetBug || DeBug || DbmBug)
{
if (sprintf (Msg,
"\n   SpclTreeDeleteFrom %14s[%2u:%4u];\n",
SetDesc->Nam,      SetDescTkn.DbId,  SetDescTkn.Handle))
if (TraceMsg (0, Msg))
if (KeySize > sizeof(indextype))
sprintf (Msg, "              Member [%2u:%4u] Key(*%u)[%4u] = <%12s>\n",
MemberTkn->DbId,    MemberTkn->Handle,
KeySize,            SetDesc->PrimaryKey, Value);
else
sprintf (Msg, "              Member [%2u:%4u] Key(*%u)[%4u] = <%4u>\n",
MemberTkn->DbId,    MemberTkn->Handle,
KeySize,            SetDesc->PrimaryKey, *(numtype *)Value);
TraceMsg (0, Msg);
if (sprintf (Msg, "              SetHead[%2u:%4u]\n\n",
SetHeadTkn.DbId, SetHeadTkn.Handle))
TraceMsg (0, Msg);
}
} else {
sprintf (Msg,"***ERROR*** Primary Key Attr[%4u] Not of Member Class\n",
SetDesc->PrimaryKey);
TraceMsg (0, Msg);
sprintf (Msg, " AT AddIntoSet:: %14s SetTkn[%2u:%4u]\n",
SetDesc->Nam, SetDescTkn.DbId, SetDescTkn.Handle);
TraceMsg (0, Msg);
sprintf (Msg,"                 Member[%2u:%4u]\n",
MemberTkn->DbId,  MemberTkn->Handle);
TraceMsg (0, Msg);
*Status = Set_KeyNotOfObjCestrs;
}
if (Normal(*Status))
Tree_DeleteFrom   (SetHead,  (addrtype )ValuePtr,  McStat,  &Handle);
if (!Normal(*Status))
if (SetDesc)
{
if (sprintf (Msg,
"\n   SpclTreeDeleteFrom %14s[%2u:%4u];\n",
SetDesc->Nam,      SetDescTkn.DbId,  SetDescTkn.Handle))
if (TraceMsg (0, Msg))
if (KeySize > sizeof(indextype))
sprintf (Msg, "              Member [%2u:%4u] Key(*%u)[%4u] = <%12s>\n",
MemberTkn->DbId,    MemberTkn->Handle,
KeySize,            SetDesc->PrimaryKey, Value);
else
sprintf (Msg, "              Member [%2u:%4u] Key(*%u)[%4u] = <%4u>\n",
MemberTkn->DbId,    MemberTkn->Handle,
KeySize,            SetDesc->PrimaryKey, *(numtype *)Value);
TraceMsg (0, Msg);
if (sprintf (Msg, "              SetHead[%2u:%4u]\n\n",
SetHeadTkn.DbId, SetHeadTkn.Handle))
TraceMsg (0, Msg);
}
Tree_OpType       = aNonTreeOp;
TRACK(TrackBak,"SpclDeleteFromTree\n");
return (STAT);
}
boolean    SpclDeleteTree
(handletype     SetDescHndl, tokentype     *OwnerTkn,
ft F,lt Z,zz  *Status)
{
tokentype        SetDescTkn;
setdesctype     *SetDesc     = NullPtr;
ltreesethead    *SetHead     = NullPtr;
tokentype        SetHeadTkn;
addrtype         Dummy       = NullPtr;
Tree_OpType       = aTreeDelete;
SetHeadTkn.DbId   = OwnerTkn->DbId;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
if (SetBug || DeBug)
if (sprintf (Msg, "\n   SpclDeleteTree :: SetTkn[%2u:%4u]... OwnerTkn[%3u:%4u]\n",
SetDescTkn.DbId, SetDescTkn.Handle,
OwnerTkn->DbId,   OwnerTkn->Handle))
TraceMsg (0, Msg);
if (OaGetObject   (&SetDescTkn,
McStat,                (addrtype *)&SetDesc))
if (OaGet         (False,                              OwnerTkn,
(addrtype )Dummy,                   SetDesc->OwnerAttrNum,
McStat,                 (addrtype )&SetHeadTkn.Handle))
if (Object_GetImage (&SetHeadTkn, McStat, (addrtype *)&SetHead))
if (DeBug || SetBug)
if (sprintf  (Msg,
"      SpclDeleteTree:: Set<%-12s>  OwnerTkn[%3u:%4u];\n",
SetDesc->Nam, OwnerTkn->DbId, OwnerTkn->Handle))
TraceMsg (0,   Msg);
if (Normal(*Status))
Tree_Delete    (McStat,      &SetHead);
Tree_OpType       = aNonTreeOp;
TRACK(TrackBak,"SpclDeleteTree\n");
return (STAT);
}
boolean    Tree_Create
(handletype    SetDescHndl,  tokentype     *OwnerTkn,
numtype       TreeOrder,    numtype        AllocKeys,
sizetype      KeySize,      typetype       KeyType,
ft F,lt Z,zz *Status,       tokentype     *TreeTkn)
{
tokentype     SetDescTkn   = NullToken;
tokentype     SetHeadTkn   = NullToken;
ltreesethead *SetHead;
setdesctype  *SetDesc      = NullPtr;
grpheader    *GrpHdr       = NullPtr;
sizetype      EntrySize    = 0;
numtype       AllocRgns    = 0;
numtype       RgnEntrys    = 0;
numtype       AllocXs      = 0;
numtype       BaseIndex    = 1;
accesstype    AccessType   = Read_Write;
boolean       DiskCache    = False;
numtype       CacheLimit   = 0;
numtype       CacheLoad    = 0;
numtype       NumBuffRgns  = 0;
numtype       BaseRegion   = 0;
addrtype      Owner        = NullPtr;
indextype     Index        = 0;
indextype     *TempKeys     = NullPtr;
handletype    *TempHandles  = NullPtr;
indextype     *TempLeafs    = NullPtr;
tokentype     Vtoken       = NullToken;
numtype       MaxKeys      = 0;
numtype       NumLeafs     = 0;
boolean       TempClassBug = ClassBug;
sizetype      Size1        = 0;
SetDescTkn.DbId   = RenvTkn.DbId;
SetDescTkn.Handle = SetDescHndl;
if (TempKeys_Attr == 0)
if (Env_GetMemberId  ("TempKeys",      McStat,     &TempKeys_Attr))
if (Env_GetMemberId  ("TempHandles",   McStat,     &TempHandles_Attr))
if (Env_GetMemberId  ("TempLeafs",     McStat,     &TempLeafs_Attr))
if (Env_GetClassId   ("bTreeSetHead",  McStat,     &bTreeSetHead_Class))
{
if (Env_InitClassMap
(bTreeSetHead_Class,           sizeof(ltreesethead),
C_Apl,                        McStat))
Env_InvokeMap (C_Apl,                        McStat);
}
ClassBug   = TempClassBug;
if (Normal(*Status))
if (Vchunk_Create  (OwnerTkn,        sizeof (handletype), TreeOrder+1, 0,
McStat,         &Vtoken))
if (OaGetObject    (&SetDescTkn,     McStat,     (addrtype *)&SetDesc))
if (Object_Create  (OwnerTkn,        bTreeSetHead_Class,
McStat,         &SetHeadTkn))
if (Object_GetImage(&SetHeadTkn,     McStat,     (addrtype *)&SetHead))
{
SetHead->Token         = SetHeadTkn;
SetHead->PrimaryKey    = SetDesc->PrimaryKey;
SetHead->Key2ary       = SetDesc->Key2ary;
SetHead->BuildDesc     = SetDescHndl;
SetHead->lOwnerObject  = OwnerTkn->Handle;
SetHead->TreeDbId      = OwnerTkn->DbId;
SetHead->TreeOrder     = TreeOrder;
SetHead->TreeRootNode  = 0;
MaxKeys                = TreeOrder - 1;
NumLeafs               = TreeOrder + 1;
Size1                  = MaxKeys     * sizeof (handletype);
Ut_AlignStruc          (&Size1);
EntrySize              =               sizeof (lbtreenode)
+ Size1
+ Size1
+ (NumLeafs   * sizeof (indextype));
Ut_AlignStruc          (&EntrySize);
SetHead->NodeSize      = EntrySize;
SetHead->NodeCount     = 0;
SetHead->KeyCount      = 0;
RgnEntrys              = 50;
AllocRgns              = (AllocKeys / RgnEntrys) + 42;
AllocXs                = 1000;
BaseIndex              = 0;
#ifdef    __MINIMIZE_TREE_CACHE__
CacheLimit             = AllocRgns;
CacheLoad              = CacheLimit * 2;
NumBuffRgns            = CacheLimit;
#else
CacheLimit             = TreeOrder + 1;
CacheLimit             = 100;
CacheLoad              = 100;
NumBuffRgns            = 100;
#endif
if (OaPut         (False,   OwnerTkn,        (addrtype )Owner,
SetDesc->OwnerAttrNum,    (addrtype )&SetHead->Token,
McStat))
if (Grp_NewPacket  (OwnerTkn,  EntrySize,   AllocRgns,   RgnEntrys,
AllocXs,   BaseIndex,   AccessType,  DiskCache,
CacheLimit,CacheLoad,   NumBuffRgns,
McStat,   &SetHead->TreeNodesDir,
&GrpHdr,   &BaseRegion))
if (Grp_CreateEntry(OwnerTkn,  SetHead->TreeNodesDir,
McStat,   &Index))
{
EntrySize              = KeySize;
SetHead->KeySize       = KeySize;
SetHead->KeyType       = KeyType;
SetHead->MaxKeys       = TreeOrder - 1;
SetHead->MinKeys       = TreeOrder / 2;
if (KeySize > 8)
{
RgnEntrys           = 200;
AllocRgns           = (AllocKeys / 200) + 42;
AllocXs             = 1000;
BaseIndex           = 0;
} else {
RgnEntrys           = AllocKeys;
AllocRgns           = 108;
AllocXs             = 1000;
BaseIndex           = 0;
}
#ifndef   __MINIMIZE_TREE_CACHE__
CacheLimit          = 7;
CacheLoad           = CacheLimit * 2;
NumBuffRgns         = CacheLimit;
#endif
if (KeySize > sizeof (indextype))
if (Grp_NewPacket  (OwnerTkn,  EntrySize,   AllocRgns,   RgnEntrys,
AllocXs,   BaseIndex,   AccessType,  DiskCache,
CacheLimit,CacheLoad,   NumBuffRgns,
McStat,   &SetHead->TreeKeysDir,
&GrpHdr,   &BaseRegion))
Grp_CreateEntry(OwnerTkn,  SetHead->TreeKeysDir,
McStat,   &Index);
}
if (Normal(*Status))
if (Attr_ArrayCreate  (&SetHeadTkn,          TempKeys_Attr,
TreeOrder,            sizeof (indextype),
McStat,  (addrtype *)&TempKeys))
if (Attr_ArrayCreate  (&SetHeadTkn,          TempHandles_Attr,
TreeOrder,            sizeof (handletype),
McStat,  (addrtype *)&TempHandles))
Attr_ArrayCreate  (&SetHeadTkn,          TempLeafs_Attr,
TreeOrder + 1,        sizeof (indextype),
McStat,  (addrtype *)&TempLeafs);
}
if (SetBug)
Object_Dump (&SetHeadTkn);
if (Normal(*Status))
if (Object_CommitImage   (&SetHeadTkn,     False,  McStat))
*TreeTkn  = SetHeadTkn;
if (DeBug  || SetBug)
if (sprintf  (Msg, "      Tree_Create :: [%4u:%6u];\n",
TreeTkn->DbId, TreeTkn->Handle))
TraceMsg (0,   Msg);
Tree_OpType       = aNonTreeOp;
TRACK(TrackBak,"Tree_Create\n");
return(STAT);
}
boolean    Tree_Compare2aryKey
(ltreesethead *SetHead,      handletype    ObjHandle,
ft F,lt Z,zz *Status)
{
addrtype  Object      = PtrToVoid;
tokentype ObjTkn      = NullToken;
char      MemberVal[64];
switch (Tree_OpType)
{
case aTreeAddInto    :
ObjTkn         = SetHead->Token;
ObjTkn.Handle  = ObjHandle;
if (OaGet       (False,   &AddInto_MemberTkn,     Object,
SetHead->Key2ary,
McStat,               (addrtype )MemberVal))
OaCompare   (False,   &ObjTkn,                Object,
SetHead->Key2ary,     (addrtype )MemberVal,
NullPtr,                         McStat);
if (*Status == Oa_LessThen)
*Status  = Set_LessThen;
else if (*Status == Oa_GtrThen)
*Status  = Set_GtrThen;
break;
case aTreeFindIn     :
if (FindIn_2aryKey  != NullPtr)
{
ObjTkn         = SetHead->Token;
ObjTkn.Handle  = ObjHandle;
OaCompare    (False,   &ObjTkn,                Object,
SetHead->Key2ary,                FindIn_2aryKey,
NullPtr,                         McStat);
if (*Status == Oa_LessThen)
*Status  = Set_LessThen;
else if (*Status == Oa_GtrThen)
*Status  = Set_GtrThen;
}
break;
case aTreeTraverse   :
break;
case aTreeDeleteFrom :
break;
case aTreeDelete     :
break;
}
TRACK(TrackBak,"Tree_Compare2aryKey\n");
return(STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\ut.c*/

#define  UT
#ifdef __NOSTR__
#endif
#ifdef ENV01
#endif

int pow2Round(int val)
{
int i = 1;
while (i < val)
i <<= 1;
return(i);
}
boolean    PrintErr (ft F,lt Z,zz Status)
{
char Line[256];
if (Status > 0  || DeBug)
if (DeBug
|| (Status  != Om_ObjHdrExists
&&  Status  != Kernl_IamNot
&&  Status  != Code_ClassNotMember
&&  Status  != Set_AlreadyInSet
&&  Status  != Set_NotFound
&&  Status  != Set_InSerted
&&  Status  != Set_EmptySet
&&  Status  != Mtrx_NullMatrix
&&  Status  != Mtrx_NotMated
&&  Status  != Mtrx_AlreadyMated
&&  Status  != List01_EmptyList
&&  Status  != List01_AlreadyInList
&&  Status  != List01_NotFound)     )
{
memset (Line, NULL, sizeof (Line));
sprintf (Line, " *** ERROR [%d] IN procedure :: %17s", Status, TrackBak);
SendMsg (0, Line);
sprintf (Line, "                Called FROM  :: %17s  @Line= %u\n", F, Z);
SendMsg (0, Line);
}
return (Status  > 0 ? False : True);
}
boolean    SetWatch (addrtype VoidAddr, sizetype WordSize)
{
WatchAddr  = (char *)VoidAddr;
WatchSize  = WordSize;
memcpy  (WatchWord, WatchAddr, WatchSize);
sprintf (Msg, " Set WATCH On @ %x  Value(* %5u) = ",
WatchAddr, WatchSize);
SendMsg (0, Msg);
TraceBytes (0, (addrtype )WatchAddr, (sizetype )WatchSize);
Watch_Set  = True;
return (True);
}
boolean    StopWatch (addrtype     VoidAddr)
{
sprintf (Msg, " Stop WATCH On @ %x\n", VoidAddr);
SendMsg (0, Msg);
Watch_Set   = False;
return (True);
}
void     SetBreak   (boolean       Break)
{
Break_Set   = Break;
}
boolean    VoidTrack (ft F,lt Z,zz *Status)
{
if (Msg[MsgMaxIndex] != '\0')
{
SendMsg  (0, "\n ***WARNING*** Msg Buffer Size OverWritten\n");
*Status = Env0_Corrupted;
}
if (Watch_Set)
if (!strncmp ((char *)PtrToVoid,  (char *)"VORTEx ", (size_t )9))
{
#ifdef ENV01
if (Env0 != NullPtr)
if (Env0->Handle !=  Renv0_Hndl || Env0->DescNum != 0)
{
SendMsg  (0,   " *** RENV0 *** Env0 Corrupted *** RENV0 \n");
sprintf  (Msg, " *** ERROR *** Renv.Handle == %u OverWriten\n",
Env0->Handle);
SendMsg  (0, Msg);
*Status = Env0_Corrupted;
PrintErr (F, Z, *Status);
}
#endif
if (Watch_Set)
{
if (memcmp    (WatchAddr, (addrtype )&WatchWord[0], WatchSize) != 0)
{
sprintf    (Msg, "     Watch @%x   Value   = ", WatchAddr);
TraceMsg   (0, Msg);
TraceBytes (0, WatchAddr, WatchSize);
TraceMsg   (0, "\n");
sprintf    (Msg, " *** Watch Changed IN    :: %21s",  TrackBak);
TraceMsg   (0, Msg);
sprintf    (Msg,
"           Called  FROM  :: %21s  @Line= %u\n", F, Z);
TraceMsg   (0, Msg);
memcpy     ((addrtype )&WatchWord[0], WatchAddr, WatchSize);
if (Break_Set)
*Status = Env_WatchChangedValue;
}
}
PrintTrack(F, Z);
} else {
SendMsg  (0, " *** VOID0 *** 0 ACCESS NO 1 *** VOID1 \n");
III[8] = AsciiEow;
SendMsg  (0, " ... Msg Buffer = :: \n");
SendMsg  (0, Msg);
sprintf  (Msg, " ... 2 Byte OverLoad :: %x,  %x \n",
*(bytetype *)III, (bytetype )III[4]);
SendMsg  (0, Msg);
PrintErr (F, Z, *Status = Env_BlackIII);
strncpy  (III, "VORTEx ", 9);
*Status = Env_Normal;
PrintTrack(F, Z);
}
return (True);
}
boolean    PrintTrack (ft F,lt Z)
{
if (Trace1 > TrackBack)
{
if (WriteHdr)
{
fprintf (MsgFilePtr, " return from %-24s", TrackBak);
fprintf (MsgFilePtr, " called from %-24s  @Line= %4u", F, Z);
#ifdef    FLUSH_FILES
fflush  (MsgFilePtr);
#endif
} else {
#ifndef __GUI__
printf (" return from %s", TrackBak);
#endif
if (OutFilePtr != NULL)
{
fprintf (OutFilePtr, " return from %s", TrackBak);
#ifdef    FLUSH_FILES
fflush  (OutFilePtr);
#endif
}
}
}
return (True);
}
void       StackTrack (char *ProgNam)
{
if (Trace1 > TrackBack)
{
if (WriteHdr)
{
fprintf (MsgFilePtr, " return from %s", ProgNam);
#ifdef    FLUSH_FILES
fflush  (MsgFilePtr);
#endif
} else {
#ifndef __GUI__
printf (" return from %s", ProgNam);
#endif
if (OutFilePtr != NULL)
{
fprintf (OutFilePtr, " return from %s", ProgNam);
#ifdef    FLUSH_FILES
fflush  (OutFilePtr);
#endif
}
}
}
return;
}
#ifdef __UNIX__
#define __GUI__
#endif
boolean    TraceMsg   (int TraceLevel,  char  *MsgLine)
{
if (Print_Msg)
{
if (abs(DeBug) >= TraceLevel)
{
if (WriteHdr || TraceLevel < 0)
{
if (MsgFilePtr != NULL)
{
fprintf (MsgFilePtr, "%s", MsgLine);
#ifdef    FLUSH_FILES
fflush  (MsgFilePtr);
#endif
}
} else {
if (OutFilePtr != NULL)
{
fprintf (OutFilePtr, "%s", MsgLine);
#ifdef    FLUSH_FILES
fflush  (OutFilePtr);
#endif
}
#ifndef __GUI__
printf ("%s", MsgLine);
#endif
}
}
}
return(True);
}
boolean    SendMsg   (int MsgLevel,  char  *MsgLine) {
if (abs(DeBug) >= MsgLevel)
{
if (MsgFilePtr != NULL)
{
fprintf (MsgFilePtr, "%s", MsgLine);
#ifdef    FLUSH_FILES
fflush  (MsgFilePtr);
#endif
}
#ifdef __GUI__
if ((OutFilePtr != NULL) && (MsgLevel > 0))
{
fprintf (OutFilePtr, "%s", MsgLine);
#ifdef    FLUSH_FILES
fflush  (OutFilePtr);
#endif
}
#endif
#ifndef __GUI__
printf ("%s", MsgLine);
#endif
}
return(True);
}
boolean    TraceBytes (int TraceLevel,  addrtype   SomeBytes, sizetype Size)
{
counttype      Bytes           = 0;
bytetype      *BytePtr         = NullPtr;
short          ShortVal        = 0;
lt64           LongVal         = 0;
char           CharVal         = 0;
unsigned char  UnCharVal       = 0;
if (TraceLevel <= DeBug)
{
if (Size <= 4)
{
if (Size == 1)
{
UnCharVal  =  *(unsigned char*)SomeBytes;
if (*(byte *)SomeBytes <= 127)
sprintf (Msg, "%8u || X%2x ", UnCharVal, UnCharVal);
else {
CharVal  =  *(byte *)SomeBytes;
sprintf (Msg, "%8d || X%2x ", CharVal,   UnCharVal);
}
} else if (Size == 2) {
if (*(unshorttype *)SomeBytes <= 32000)
sprintf (Msg, "%8u  ", *(short *)SomeBytes);
else {
ShortVal  =  *(short *)SomeBytes;
sprintf (Msg, "%8d  ", ShortVal);
}
} else if (Size == 4) {
if (*(lt64 *)SomeBytes <= 100000L)
sprintf (Msg, "%8d",     *(lt64  *)SomeBytes);
else {
LongVal  =  *(lt64 *)SomeBytes;
sprintf (Msg, "%8d  || X%8x", LongVal,  *(char **)SomeBytes);
}
} else
sprintf (Msg, "Null_Size");
TraceMsg (0, Msg);
} else {
BytePtr  = (bytetype *)SomeBytes;
TraceMsg  (0, "\n          ");
while (++Bytes <= Size)
{
sprintf   (Msg, "%4u ", *BytePtr);
TraceMsg  (0,   Msg);
if (Bytes  % 10 == 0
&&  Bytes       != Size)
TraceMsg  (0, "\n          ");
BytePtr++;
}
}
}
return(True);
}
boolean    TraceField (int       TraceLevel,  addrtype  FieldAddr,
sizetype  Size,        typetype  Type)
{
counttype      Bytes        = 0;
char           StrVal[32];
bytetype      *BytePtr      = NullPtr;
#ifdef ENV01
statustype     DumpStatus    = Env_Normal;
tokentype      VchunkTkn;
#endif
if (TraceLevel >= 999)
TraceMsg (TraceLevel, "Ut_TraceLevelOutOfRange\n");
switch (Type)
{
case aString    :
MoveBytes ((addrtype )FieldAddr, (addrtype )StrVal, Size);
StrVal[Size-1] = '\0';
sprintf (Msg, "%s  ", StrVal);
break;
case aChunk     :
#ifdef ENV01
VchunkTkn.DbId   = RenvId;
VchunkTkn.Handle = *(handletype *)FieldAddr;
sprintf (Msg, "%u\n", *(handletype *)FieldAddr);
TraceMsg (0, Msg);
if (VchunkTkn.Handle)
{
OaDumpVchunkVchunk (&VchunkTkn, Dump_Status);
if (DumpStatus == Oa_VchunkNotExist)
DumpStatus = Env_Normal;
}
#endif
break;
case aInteger   :
if (Size == 1)
{
sprintf (Msg, "%u  ", *(byte  *)FieldAddr);
} else if (Size == 2) {
sprintf (Msg, "%d  ", *(short *)FieldAddr);
} else if (Size == 4) {
sprintf (Msg, "%d",
*(char **)FieldAddr);
} else {
Bytes = 0;
BytePtr  = (bytetype *)FieldAddr;
TraceMsg  (0, "\n          ");
while (++Bytes <= Size)
{
sprintf   (Msg, "%4u ", *BytePtr);
TraceMsg  (0,   Msg);
if (Bytes  % 10 == 0
&&  Bytes       != Size)
TraceMsg  (0, "\n          ");
BytePtr++;
}
if (!Bytes) sprintf (Msg, " NULL_SIZE");
}
break;
case aReal   :
if (Size == sizeof (float))
sprintf (Msg, "%f  ", *(float  *)FieldAddr);
else if (Size == sizeof (double))
sprintf (Msg, "%g  ", *(double *)FieldAddr);
break;
case aLink       :
if (Size == sizeof (handletype))
sprintf (Msg, "[XX:%4u] ", *(handletype *)FieldAddr);
else
sprintf (Msg, "[%3u:%4u] ",
((tokentype *)FieldAddr)->DbId,
((tokentype *)FieldAddr)->Handle);
break;
case aEnum       :
sprintf (Msg, "%u  ", *(word *)FieldAddr);
break;
case aBoolean     :
if (! *(boolean *)FieldAddr)
strcpy (Msg, " True ");
else
strcpy (Msg, " False ");
break;
case aDbmsString  :
case aValue       :
Bytes = 0;
BytePtr  = (bytetype *)FieldAddr;
TraceMsg  (0, "\n          ");
while (++Bytes <= Size)
{
sprintf   (Msg, "%4x ", *BytePtr);
TraceMsg  (0,   Msg);
if (Bytes  % 10 == 0
&&  Bytes       != Size)
TraceMsg  (0, "\n          ");
BytePtr++;
}
if (!Bytes) sprintf (Msg, " NULL_SIZE");
break;
case aAddr        :
sprintf (Msg, "%x ",  *(addrtype **)FieldAddr);
break;
default           :
sprintf (Msg, " NULL_TYPE");
}
if (Type != aChunk)
TraceMsg  (0, Msg);
return(True);
}
boolean    Ut_TraceValue (int           TraceLevel,addrtype      Value,
valueclass    ValueClass,sizetype      ValueSize,
numtype       ValueObj)
{
counttype      Bytes        = 0;
char           StrVal[32];
bytetype      *BytePtr      = NullPtr;
#ifdef ENV01
tokentype      VchunkTkn;
#endif
if (Value  !=  NullPtr)
{
switch (ValueClass)
{
case aOid       :
VchunkTkn = *(tokentype *)Value;
sprintf (Msg, "[%3u:%4u]",
VchunkTkn.DbId, VchunkTkn.Handle);
break;
case aVoid        :
case aVoidPtr     :
sprintf (Msg, "%x ",  *(addrtype **)Value);
break;
case aBitField    :
sprintf (Msg, "%8o ",  *(addrtype **)Value);
break;
case aChar      :
if (ValueSize != 1)
sprintf (Msg, "%c  ", *(char            *)Value);
else
sprintf (Msg, "%s  ", *(char            *)Value);
break;
case aUnChar    :
if (ValueSize != 1)
sprintf (Msg, "%c  ", *(char            *)Value);
else {
MoveBytes ((addrtype )Value, (addrtype )StrVal, ValueSize);
StrVal[ValueSize-1] = '\0';
sprintf (Msg, "%s  ", StrVal);
}
break;
case aShort     :
sprintf (Msg, "%d  ", *(short           *)Value);
break;
case aUnShort   :
sprintf (Msg, "%u  ", *(unsigned short  *)Value);
break;
case aInt       :
sprintf (Msg, "%d  ", *(int             *)Value);
break;
case aUnInt     :
sprintf (Msg, "%u  ", *(unsigned int    *)Value);
break;
case aLong      :
sprintf (Msg, "%d  ", *(lt64            *)Value);
break;
case aUnLong    :
sprintf (Msg, "%u  ", *(farlongtype     *)Value);
break;
case aQuad      :
Bytes = 0;
BytePtr  = (bytetype *)Value;
TraceMsg  (0, "\n          ");
while (++Bytes <= ValueSize)
{
sprintf   (Msg, "%4u ", *BytePtr);
TraceMsg  (0,   Msg);
if (Bytes  % 10 == 0
&&  Bytes       != ValueSize)
TraceMsg  (0, "\n          ");
BytePtr++;
}
if (!Bytes)
sprintf (Msg, " NULL_SIZE");
break;
case aFloat  :
sprintf (Msg, "%f  ", *(float  *)Value);
break;
case aDouble :
sprintf (Msg, "%g  ", *(double *)Value);
break;
case aEnumType   :
sprintf (Msg, "%u  ", *(word *)Value);
break;
case aOctet       :
Bytes = 0;
BytePtr  = (bytetype *)Value;
TraceMsg  (0, "\n          ");
while (++Bytes <= ValueSize)
{
sprintf   (Msg, "%4x ", *BytePtr);
TraceMsg  (0,   Msg);
if (Bytes  % 10 == 0
&&  Bytes       != ValueSize)
TraceMsg  (0, "\n          ");
BytePtr++;
}
if (!Bytes) sprintf (Msg, " NULL_SIZE");
break;
default           :
sprintf (Msg, " NULL_TYPE");
}
if (ValueClass != aObject)
{
TraceMsg  (0, Msg);
TraceMsg  (0, "\n");
}
} else {
TraceMsg  (0, "(NULL)\n");
}
return(True);
}
void       AlignMember   (typetype     Type_Type,  sizetype     Size,
sizetype    *Offset)
{
sizetype  ByteAlign  = 0;
sizetype  Align      = 0;
if (DeBug)
if (sprintf (Msg,  "    Type[%u] Size(%3u) @ Offset = %2u ",
Type_Type, Size, *Offset))
TraceMsg (0, Msg);
if (*Offset)
{
switch (Type_Type)
{
case aString    :
ByteAlign = Byte_Alignment;
break;
case aLink      :
#ifdef LARGE
ByteAlign = Byte4Alignment;
#else
ByteAlign = Byte2Alignment;
#endif
break;
case aInteger   :
if (Size == 1)
{
ByteAlign = Byte_Alignment;
} else if (Size == 2) {
ByteAlign = Byte2Alignment;
} else if (Size == 4) {
ByteAlign = Byte4Alignment;
} else {
ByteAlign = Byte4Alignment;
}
break;
case aReal       :
if (Size == sizeof (float))
ByteAlign = Byte4Alignment;
else if (Size == sizeof (double))
ByteAlign = Byte8Alignment;
break;
case aEnum        :
case aBoolean     :
ByteAlign = Byte4Alignment;
break;
case aChunk       :
ByteAlign = Byte2Alignment;
break;
case aAddr        :
ByteAlign = BytePtrAlignment;
break;
case aRefObj      :
case aDbmsString  :
case aValue       :
ByteAlign = Byte4Alignment;
break;
}
Align      = *Offset   %  ByteAlign;
if (Align)
Align   = ByteAlign - (*Offset %  ByteAlign);
*Offset    +=  Align;
}
if (DeBug)
if (sprintf (Msg, "  + ByteAlignment(= %2u)\n", ByteAlign))
TraceMsg (0, Msg);
}
void       AlignStruc    (sizetype     *Offset)
{
sizetype  ByteAlign  = 0;
ByteAlign  = *Offset %  StrucAlignment;
if (ByteAlign)
ByteAlign  = StrucAlignment - ByteAlign;
*Offset    +=  ByteAlign;
if (DeBug || ClassBug)
if (sprintf (Msg, "  StrucAlignment = %2u\n", ByteAlign))
TraceMsg (0, Msg);
}
char      *StrToLower (char *pc)
{
char *pcopy = pc;
while ((*pc = tolower(*pc)) != '\0')
pc++;
*pc = '\0';
return (pcopy);
}
char      *StrToUpper (char *pc)
{
char *pcopy = pc;
while ((*pc = toupper(*pc)) != '\0')
pc++;
*pc = '\0';
return (pcopy);
}
void    Ut_ReverseStr    (char          Str[])
{
int     c  = 0;
int     i  = 0;
int     j  = 0;
for (j = strlen(Str) - 1;  i < j; i++, j--)
{
c      = Str[i];
Str[i] = Str[j];
Str[j] = c;
}
}
void    Ut_IntToStr      (int           IntNum,    char          Str[])
{
int     i     = 0;
int     sign  = 0;
if ((sign = IntNum)  < 0)
IntNum    = -IntNum;
do {
Str[i++]  = IntNum  % 10  + '0';
}  while ((IntNum /= 10)  > 0);
if (sign  < 0)
Str[i++]  = '-';
Str[i]  = '\0';
Ut_ReverseStr  (Str);
}
boolean Ut_FindInList    (char         *Word,     char        **List,
numtype       MaxList,  int          *Index)
{
int   i = 0;
for (i=0; i < MaxList &&  strcmp (Word, List[i]); i++)
{   }
if (i < MaxList)
*Index = i;
else
*Index = 0;
if (DeBug)
if (sprintf (Msg, "  Ut_FindInList [%s] Index = %u (i= %u) \n",
Word,  *Index, i))
TraceMsg (0, Msg);
StackTrack ("Ut_FindInList\n");
return ((boolean )(i != (int )MaxList));
}
boolean Ut_CompareWild   (char         *VarValue,  compareop     CompOp,
char         *WildSpec,  ft F,lt Z,zz *Status)
{
static char *WildOps    = "?*";
sizetype     StrSize    = 0;
int          i          = 0;
int          j          = 0;
numtype      VarIndex        = 0;
int          VarLen          = 0;
char         CompValue[MAXSTRING];
char        *WildSeg         = NullPtr;
char        *VarSeg          = VarValue;
char         CharSpec[2];
strcpy (CompValue, "\0");
strcpy (CharSpec,  "\0");
if (ClassBug)
if (sprintf  (Msg, "    Ut_CompareWild:: '%-24s'  %6s on spec %s..\n",
VarValue, CompareOpName[CompOp],  WildSpec))
TraceMsg (0, Msg);
#ifndef __NOSTR__
VarLen                  = strlen    (VarValue) + 1;
VarIndex                = 0;
while (Normal(*Status)
&&     i               == 0
&&     VarIndex         < VarLen
&&     VarValue[0]     != '\0')
{
if ((WildSeg    = strpbrk (WildSpec, WildOps)) != NULL)
{
StrSize              = (sizetype )(WildSeg - WildSpec);
strncpy  (CompValue,    WildSpec,  StrSize);
CompValue[StrSize]   = '\0';
WildSpec             = &WildSeg[0];
if ((i   = strncmp (VarValue,  CompValue, StrSize)) != 0)
break;
VarIndex            += StrSize;
VarValue            += StrSize;
} else {
VarIndex            += strlen (WildSpec);
i                    = strcmp (VarValue,  WildSpec);
break;
}
if (WildSpec[0] == '?')
{
for (j = 0; WildSpec[0] == '?'; ++WildSpec)
{
++j; ++VarValue;
}
if ((VarIndex  += j)     >= VarLen)
{
i = -1;
break;
}
if (VarValue[0] == '\0')
if (WildSpec[0] != '\0')
if (WildSpec[0] != '*')
i = -1;
} else if (WildSpec[0] == '*') {
++WildSpec;
if ((CharSpec[0]     = WildSpec[0]) == '\0')
VarIndex          = VarLen;
else if ((VarSeg     = strpbrk (VarValue, CharSpec)) != NULL)
{
StrSize            = (sizetype )(VarSeg - VarValue);
VarValue           = &VarSeg[0];
VarIndex          += StrSize;
} else {
i = -1;
VarIndex           = VarLen;
}
} else
*Status  = Lex_BadSyntax;
}
#endif
if (ClassBug)
if (sprintf  (Msg, "    Ut_CompareWild:: i = %4d\n",
i))
TraceMsg (0, Msg);
if (Normal (*Status))
switch (CompOp)
{
case aEQ  :
if (i   == 0)
return(True);
else
return (False);
case aLT  :
if (i    < 0)
return(True);
else
return (False);
case aGT  :
if (i    > 0)
return(True);
else
return (False);
case aGTE :
if (i   == 0
||  i    > 0)
return(True);
else
return (False);
case aLTE :
if (i   == 0
||  i    < 0)
return(True);
else
return (False);
case aNEQ :
if (i   != 0)
return(True);
else
return (False);
case aModEQ0 :
break;
}
TRACK(TrackBak,"Ut_CompareWild\n");
return(STAT);
}
int     Ut_CompareString (char         *CompValue, char         *ValuePtr)
{
int              i           = 0;
unsigned char   *p0          = (unsigned char *)CompValue;
unsigned char   *p1          = (unsigned char *)ValuePtr;
if (DeBug)
if (sprintf  (Msg, "    Ut_CompareString:: <%-24s> To <%-24s>;\n",
p0, p1))
TraceMsg (0, Msg);
for (i = 0; i == 0 && *p0 != NULL && *p1 != NULL; p0++, p1++)
{
if (*p0 != *p1)
if (*p0  < *p1)
i      = -1;
else
i      = 1;
}
if (i    == 0)
if (*p0  != *p1)
if (*p0  == NULL)
i      = -1;
else
i      = 1;
if (ClassBug && !SetBug)
if (sprintf  (Msg,  "  Ut_Compare::      <%-16s> To <%-16s>; i = %d\n",
CompValue, ValuePtr, i))
TraceMsg (0, Msg);
return(i);
}
int     Ut_Random ( void )
{
static unsigned int jran = 19381;
jran=((314157*jran)+19)&0xffffff;
return( (int) jran );
}
/* 当前文件是./CINT2000\255.vortex\src\vchunk.c*/

#define  VCHUNK_C
#define  GRP_C
#define MemThawChunk        Mem_DefrostChunk
#define MemDirtyChunk       Mem_DefrostChunk
#define MemCleanChunk       Mem_DefrostChunk
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
boolean Vchunk_Create    (tokentype    *Anchor,    sizetype      UnitSize,
indextype     UnitCount, indextype     ExtendQty,
ft F,lt Z,zz *Status,    tokentype    *Vtoken)
{
addrtype   ChunkAddr = NullPtr;
Vtoken->DbId          = Anchor->DbId;
DbmNewVchunk           (Anchor,       UnitSize,   UnitCount,  ExtendQty,
McStat,
(indextype  *)&(Vtoken->Handle),     &ChunkAddr);
TRACK(TrackBak,"Vchunk_Create\n");
return (STAT);
}
boolean Vchunk_IsValidToken
(tokentype    *Token,     ft F,lt Z,zz *Status)
{
boolean        IsValid      = False;
dbheader      *CoreDb       = NullPtr;
grpheader     *GrpHdr       = NullPtr;
vchunktkntype *VchunkDir    = NullPtr;
numtype        RgnNum       = 0;
indextype      LocalIndex   = 0;
vchunktkntype  VchunkTkn;
tokentype      DbmsTkn      = NullToken;
numtype        BaseRegion   = 0;
if (Token->DbId   == 0
||  Token->Handle == 0)
return (IsValid);
DbmsTkn.DbId    = Token->DbId;
DbmsTkn.Handle  = 1;
if ((IsValid = TmIsValid (&DbmsTkn,   McStat)) == True)
{
IsValid   = False;
if (TmFetchCoreDb     (&DbmsTkn, McStat,    &CoreDb))
if ((GrpHdr = CoreDb->VchunkGrpHdr) == NullPtr)
{
if (GrpGetPacket    (&DbmsTkn,        CoreDb->VchunkGrpNum,
McStat,         &CoreDb->VchunkGrpHdr))
GrpHdr   = CoreDb->VchunkGrpHdr;
if (Normal(*Status))
if (DbmBug)
Grp_DumpStruct   (&DbmsTkn,   CoreDb->VchunkGrpNum,  McStat);
}
if (Normal(*Status))
{
if (Token->Handle < GrpHdr->BaseIndex)
{
RgnNum     = 0;
LocalIndex = Token->Handle;
} else {
RgnNum     = (Token->Handle  - GrpHdr->BaseIndex)
/ GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnNum++;
LocalIndex = (Token->Handle  - GrpHdr->BaseIndex)
% GrpHdr->RegionEntrys;
}
if (GrpGetRegion (CoreDb,     GrpHdr,                    RgnNum,
McStat,    &BaseRegion,   (addrtype *)&VchunkDir))
VchunkTkn    = VchunkDir[LocalIndex];
if (VchunkTkn.InCore != 0
||  VchunkTkn.OnDisk != 0)
IsValid   = True;
else
IsValid   = False;
}
}
STAT;
TRACK(TrackBak,"Vchunk_IsValidToken\n");
*Status   = Env_Normal;
return (IsValid);
}
boolean Vchunk_GetVstruc (tokentype    *Vtoken,    ft F,lt Z,zz *Status,
vchunkstruc  *VchunkStruc)
{
vchunktkntype Vchunk;
if (DbmInvokeVchunk    (Vtoken,          McStat,          &Vchunk))
MemGetChunkStruc   (Vchunk.InCore,   McStat,           VchunkStruc);
TRACK(TrackBak,"Vchunk_GetVstruc\n");
return (STAT);
}
boolean Vchunk_DumpVstruc
(tokentype    *Vtoken,    ft F,lt Z,zz *Status)
{
vchunktkntype Vchunk;
if (DbmInvokeVchunk    (Vtoken,          McStat,          &Vchunk))
DumpChunkChunk     (0,               Vchunk.InCore);
TRACK(TrackBak,"Vchunk_DumpVstruc\n");
return (STAT);
}
boolean Vchunk_Freeze    (tokentype    *Vtoken,    ft F,lt Z,zz *Status)
{
vchunktkntype Vchunk;
if (DbmInvokeVchunk    (Vtoken,          McStat,          &Vchunk))
MemFreezeChunk     (Vchunk.InCore,   McStat);
TRACK(TrackBak,"Vchunk_Freeze\n");
return (STAT);
}
boolean Vchunk_GetAddress
(tokentype    *Vtoken,
ft F,lt Z,zz *Status,    addrtype     *VchunkAddr)
{
vchunktkntype Vchunk;
if (DbmInvokeVchunk    (Vtoken,          McStat,         &Vchunk))
MemGetChunkAddr    (Vchunk.InCore,   McStat,          VchunkAddr);
TRACK(TrackBak,"Vchunk_GetAddress\n");
return (STAT);
}
boolean Vchunk_PutAddress
(tokentype    *Vtoken,    addrtype      VchunkAddr,
ft F,lt Z,zz *Status)
{
vchunktkntype Vchunk;
if (DbmInvokeVchunk    (Vtoken,          McStat,         &Vchunk))
MemPutChunkAddr    (Vchunk.InCore,   VchunkAddr,      McStat);
TRACK(TrackBak,"Vchunk_PutAddress\n");
return (STAT);
}
boolean Vchunk_GetStackPtr
(tokentype    *Vtoken,
ft F,lt Z,zz *Status,    indextype    *StackPtr)
{
vchunktkntype Vchunk;
if (DbmInvokeVchunk    (Vtoken,          McStat,         &Vchunk))
MemGetStackPtr     (Vchunk.InCore,   McStat,          StackPtr);
TRACK(TrackBak,"Vchunk_GetStackPtr\n");
return (STAT);
}
boolean Vchunk_PutStackPtr
(tokentype    *Vtoken,    indextype     StackPtr,
ft F,lt Z,zz *Status,    addrtype     *Varray)
{
vchunktkntype Vchunk;
if (DbmInvokeVchunk    (Vtoken,          McStat,         &Vchunk))
if (MemPutStackPtr     (Vchunk.InCore,   StackPtr,        McStat))
MemGetChunkAddr    (Vchunk.InCore,   McStat,          Varray);
TRACK(TrackBak,"Vchunk_PutStackPtr\n");
return (STAT);
}
boolean Vchunk_GetChunkSize
(tokentype    *Vtoken,    ft F,lt Z,zz *Status,
indextype    *UnitCount, sizetype     *UnitSize)
{
vchunktkntype Vchunk;
if (DbmInvokeVchunk    (Vtoken,          McStat,         &Vchunk))
MemGetChunkSize    (Vchunk.InCore,   McStat,
UnitCount,           (bytessize *)UnitSize);
TRACK(TrackBak,"Vchunk_GetChunkSize\n");
return (STAT);
}
boolean Vchunk_Copy      (tokentype    *Vtoken0,   tokentype    *Vtoken1,
ft F,lt Z,zz *Status)
{
vchunktkntype Vchunk0;
vchunktkntype Vchunk1;
vchunkstruc   VchunkStruc0;
vchunkstruc   VchunkStruc1;
addrtype      VchunkAddr0   = NullPtr;
addrtype      VchunkAddr1   = NullPtr;
if (DbmInvokeVchunk    (Vtoken0,         McStat,    &Vchunk0))
if (MemGetChunkStruc   (Vchunk0.InCore,  McStat,    &VchunkStruc0))
if (MemGetChunkAddr    (Vchunk0.InCore,  McStat,    &VchunkAddr0))
if (DbmInvokeVchunk    (Vtoken1,         McStat,    &Vchunk1))
if (MemGetChunkStruc   (Vchunk1.InCore,  McStat,    &VchunkStruc1))
if (MemGetChunkAddr    (Vchunk1.InCore,  McStat,    &VchunkAddr1))
if (VchunkStruc0.UnitSize == VchunkStruc1.UnitSize)
{
if (MemPutStackPtr  (Vchunk1.InCore,  VchunkStruc1.StackPtr,    McStat))
MoveBytes       (VchunkAddr0,     VchunkAddr1,
VchunkStruc0.UnitSize * VchunkStruc0.UnitCount);
} else
*Status = Vchunk_NotSameUnitSize;
TRACK(TrackBak,"Vchunk_Copy\n");
return (STAT);
}
boolean Vchunk_Dump      (tokentype    *Vtoken,    ft F,lt Z,zz *Status)
{
vchunktkntype Vchunk;
if (Vtoken->Handle)
{
if (DbmGetVchunkTkn         (Vtoken,     McStat,         &Vchunk))
if (Vchunk.InCore  == 0)
{
} else {
MemDumpChunk       (0,          Vchunk.InCore,   McStat);
}
} else {
}
TRACK(TrackBak,"Vchunk_Dump\n");
return (STAT);
}
boolean Vchunk_DumpPartial
(tokentype    *Vtoken,
numtype       Ilow,      numtype       Ihigh,
ft F,lt Z,zz *Status)
{
vchunktkntype Vchunk;
if (Vtoken->Handle)
{
if (DbmGetVchunkTkn         (Vtoken,     McStat,         &Vchunk))
if (Vchunk.InCore  == 0)
{
} else {
Mem_DumpChunkPart  (0,    Vchunk.InCore,  Ilow,   Ihigh,  McStat);
}
} else {
}
TRACK(TrackBak,"Vchunk_DumpPartial\n");
return (STAT);
}
boolean Vchunk_Free      (tokentype    *Vtoken,    ft F,lt Z,zz *Status)
{
DbmFreeVchunk        (Vtoken,          McStat);
TRACK(TrackBak,"Vchunk_Free\n");
return (STAT);
}
boolean Vchunk_Commit    (tokentype    *Vtoken,    boolean       Release,
ft F,lt Z,zz *Status)
{
DbmCommitVchunk        (Vtoken,    Release,    McStat);
TRACK(TrackBak,"Vchunk_Commit\n");
return (STAT);
}
boolean Vchunk_Delete
(tokentype    *Vtoken,    ft F,lt Z,zz *Status)
{
DbmDeleteVchunk        (Vtoken,          McStat);
TRACK(TrackBak,"Vchunk_Delete\n");
return (STAT);
}
boolean Vchunk_PushUnit  (tokentype    *Vtoken,    addrtype      SomeBytes,
ft F,lt Z,zz *Status,    indextype    *StackPtr)
{
indextype     UnitCount     = 0;
bytessize     UnitSize      = 0;
vchunktkntype Vchunk;
if (DbmInvokeVchunk    (Vtoken,          McStat,    &Vchunk))
if (MemGetChunkSize    (Vchunk.InCore,   McStat,    &UnitCount, &UnitSize))
MemPushSomeBytes   (Vchunk.InCore,   UnitSize,   SomeBytes,
McStat,                                  StackPtr);
TRACK(TrackBak,"Vchunk_PushUnit\n");
return (STAT);
}
boolean Vchunk_PutUnit   (tokentype    *Vtoken,    indextype     Index,
addrtype      SomeBytes, ft F,lt Z,zz *Status)
{
indextype     UnitCount     = 0;
bytessize     UnitSize      = 0;
vchunktkntype Vchunk;
if (DbmInvokeVchunk    (Vtoken,          McStat,    &Vchunk))
if (MemGetChunkSize    (Vchunk.InCore,   McStat,    &UnitCount, &UnitSize))
MemPutSomeBytes    (Vchunk.InCore,   Index,      UnitSize,   SomeBytes,
McStat);
TRACK(TrackBak,"Vchunk_PutUnit\n");
return (STAT);
}
boolean Vchunk_GetUnit   (tokentype    *Vtoken,    indextype     Index,
ft F,lt Z,zz *Status,    addrtype      SomeBytes)
{
indextype     UnitCount     = 0;
bytessize     UnitSize      = 0;
vchunktkntype Vchunk;
if (DbmInvokeVchunk    (Vtoken,          McStat,    &Vchunk))
if (MemGetChunkSize    (Vchunk.InCore,   McStat,    &UnitCount, &UnitSize))
MemGetSomeBytes    (Vchunk.InCore,   Index,      UnitSize,
McStat,          SomeBytes);
TRACK(TrackBak,"Vchunk_GetUnit\n");
return (STAT);
}
boolean BitField_Create   (tokentype    *Anchor,    sizetype      AllocBits,
ft F,lt Z,zz *Status,    tokentype    *BitFldTkn)
{
bitfieldtype *BitField   = NullPtr;
sizetype      NumBits    = (AllocBits | 7)+1;
indextype     AllocBytes =  NumBits / 8;
if (VchunkCreate       (Anchor,      sizeof (bitfieldtype),
AllocBytes,                        Extend_BitField,
McStat,                            BitFldTkn))
if (VchunkPutStackPtr  (BitFldTkn,   AllocBytes,
McStat,     (addrtype *)&BitField))
memset          (BitField,    '\0',                 AllocBytes);
TRACK(TrackBak,"BitField_Create\n");
return (STAT);
}
boolean BitField_Put      (tokentype    *BitFldTkn, indextype     BitNum,
bytetype      BitValue,  ft F,lt Z,zz *Status)
{
bitfieldtype    *BitField  = NullPtr;
indextype        ByteNum   = BitNum >> 3;
indextype        ByteCount = 0;
if (VchunkGetStackPtr    (BitFldTkn,    McStat,              &ByteCount))
if (VchunkGetAddress     (BitFldTkn,    McStat,  (addrtype *)&BitField))
if (ByteNum >= ByteCount)
VchunkPutStackPtr    (BitFldTkn, ByteNum,
McStat,                (addrtype *)&BitField);
if (BitValue)
BitField[ ByteNum ] |= BitValue << (BitNum & 7);
else
BitField[ ByteNum ] &= ~(1 << (BitNum & 7));
TRACK(TrackBak,"BitField_Put\n");
return (STAT);
}
boolean BitField_Get
(tokentype    *BitFldTkn, indextype     BitNum,
ft F,lt Z,zz *Status,    bytetype     *BitValue)
{
indextype        ByteNum   = BitNum >> 3;
bitfieldtype    *BitField  = NullPtr;
indextype        ByteCount = 0;
if (VchunkGetAddress   (BitFldTkn, McStat,  (addrtype *)&BitField))
if (VchunkGetStackPtr  (BitFldTkn, McStat,              &ByteCount))
if (ByteNum  >= ByteCount)
*Status = Set_IndexGtrAllocRoots;
if (Normal(*Status))
*BitValue =  (BitField[ ByteNum ] & 1 << (BitNum & 7)) ? 1: 0;
TRACK(TrackBak,"BitField_Get\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\vdbm.c*/

#define DBM_C
#define VDBM
#ifdef NULL_TRACE_STRS
#define TraceStr11(StrNum)  TraceStr11[0]
static const char   *TraceStr11[1] = {"   ...VDBM... message\n" };
#else
#define TraceStr11(StrNum)  TraceStr11[StrNum]
static const char *TraceStr11[37] =
{
"   DbmNewVchunkDir Db[%3u] VchunkDir=%4u\n",
"   DbmNewVchunk[%3u:%4u] InCore = %4u, OnDisk= %4u\n",
"   DbmPutVchunkTkn [%3u:%4u] InCore = %4u, OnDisk= %4u\n",
"   DbmFreeVchunk [%3u:%4u] InCore = %4u, OnDisk= %4u\n",
"   DbmDeleteVchunk[%3u:%4u] \n",
"   DbmDeleteVchunk [%3u:%4u] InCore = %4u, OnDisk= %4u\n",
" Warming... DbmCommitChunk [%3u:%4u] Null Handle\n",
"    DbmFileOutVchunk[%3u:%4u] : InCore[%4u]; OnDisk[%3u]\n",
"    DB Vchunk[%3u]          : InCore[%4u]; OnDisk[%3u]\n",
" ***ERROR...DbmFileOutVchunk[%3u:%4u] > Index=%4u\n",
"    DbmFileOutVchunks    : Release= %s\n",
"    DB Vchunk[%3u]          : InCore[%4u]; OnDisk[%3u]\n",
"    DB Vchunk[%3u]          : InCore[%4u]; OnDisk[%3u]\n",
"    Number Vchunk_DIR Chunks Filed out = %u;\n",
"    DbmFileOutGrpRgns    : Release= %s\n",
"    DB Vchunk[%3u] from Chunk[%4u]:: InCore[%4u]; OnDisk[%3u]\n",
"    DB Vchunk[%3u] NULL Addr : InCore[%4u]; OnDisk[%3u]\n",
"    Number Vchunk_GRP Chunks[*%6u]... Filed out = %u;\n",
"   Invoke Block Chunk. DiskBlk=%3u, Chunks=%3u\n",
"   InvokeVchunk:: Db=%3u BlkTkn[%4u].Owner=%3u; InCore=%4u, OnDisk=%4u\n",
"   Free Block Chunk=%3u\n",
"   DbmInvokeVchunk[%3u:%4u] InCore = %4u, OnDisk= %4u\n",
"   DbmGetVchunkTkn [%3u:%4u]...\n",
"   DbmGetVchunkTkn [%3u:%4u] InCore = ZERO(%u) OnDisk= %4u\n",
"               Rgn [%3u:%4u]; Chunk[%5u] @%8x Local @%8x\n",
"   DbmGetVchunkTkn [%3u:%4u] InCore = %4u, OnDisk= %4u\n",
"  *** DbId > EnvDb's Count(%4u).\n",
"      DbmDumpVchunkVchunk [%3u:%4u] InCore = %4u, OnDisk= %4u\n",
"  *** DbId > EnvDb's Count(%4u).\n",
"      DbmDumpVchunk       [%3u:%4u] InCore = %4u, OnDisk= %4u\n",
"      Limit0 = %4u, Limit1 = %4u\n",
"   Invoke Block Chunk. DiskBlk=%3u, Chunks=%3u\n",
"   Db=%3u BlkTkn[%4u].Owner=%3u; InCore=%4u, OnDisk=%4u\n",
"   Free Block Chunk=%3u\n",
"    DbmFreeVchunks    : Release= %s\n",
"    Number Vchunk_DIR Chunks Freeed = %u;\n",
"    Number Vchunk_GRP Chunks Filed out = %u;\n"
};
#endif


#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#define    MemGetVbn          Mem_GetWord
#define    MemPushVbn         Mem_PushWord
#define    MemPutVbn          Mem_PutWord
#define    MemGetChunkNum     Mem_GetWord
#define    MemPutChunkNum     Mem_PutWord
#define    MemGetIndex        Mem_GetWord
#define    MemFreeFileBlk     Mem_FreeFileBlk


boolean DbmNewVchunk     (tokentype    *Anchor,    sizetype     UnitSize,
indextype     UnitCount, indextype    ExtendQty,
ft F,lt Z,zz *Status,
indextype    *Vchunk,    addrtype    *ChunkAddr)
{
dbheader     *CoreDb       = NullPtr;
vchunktkntype VchunkToken;
grpheader    *GrpHdr       = NullPtr;
static sizetype      EntrySize    = sizeof (vchunktkntype);
static numtype       AllocRgns    = 0;
static numtype       RgnEntrys    = 125;
static numtype       AllocXs      = 1000;
static numtype       BaseIndex    = 2;
static accesstype    AccessType   = Read_Write;
static boolean       DiskCache    = False;
static numtype       CacheLimit   = 0;
static numtype       CacheLoad    = 0;
static numtype       NumBuffRgns  = 0;
numtype       GrpNum       = 0;
numtype       BaseRegion   = 0;
DiskCache    = False;
AllocRgns    = (Alloc_Handles/125) + 22;
NumBuffRgns  = AllocRgns;
CacheLimit   = AllocRgns;
CacheLoad    = 100;
VchunkToken.OnDisk = 0;
VchunkToken.InCore = 0;
if (TmGetCoreDb      (Anchor,  McStat,           &CoreDb))
if (CoreDb->VchunkGrpNum == 0)
{
if (GrpNewPacket   (Anchor,    EntrySize,   AllocRgns,   RgnEntrys,
AllocXs,   BaseIndex,   AccessType,  DiskCache,
CacheLimit,CacheLoad,   NumBuffRgns,
McStat,   &GrpNum,     &GrpHdr,     &BaseRegion))
if (GrpNewEntry    (Anchor,    GrpNum,
McStat,    Vchunk,       (addrtype )&VchunkToken))
GrpHdr->EnvObjType    = UnitChunk_AttrNum;
CoreDb->VchunkGrpNum  = GrpNum;
CoreDb->VchunkGrpHdr  = GrpHdr;
if (Normal(*Status))
if (Anchor->DbId > WenvId)
if (CoreDb->VchunkCommitDir  == 0)
if (MemNewBitChunk (10000,      Anchor->DbId,
McStat,                  &(CoreDb->VchunkCommitDir)))
if (MemMakeChunk   (sizeof(vbntype),   10000,    2000,
Anchor->DbId,      McStat, &(CoreDb->VchunkSwapDir)))
MemPutStackPtr (CoreDb->VchunkSwapDir,  1,           McStat);
}
if (Normal(*Status))
if (MemMakeChunk    (UnitSize,  UnitCount,  ExtendQty,  Anchor->DbId,
McStat,                           &VchunkToken.InCore))
GrpPutNewEntry  (Anchor,    CoreDb->VchunkGrpNum,
(addrtype )&VchunkToken,
McStat,                            Vchunk);
if (Normal(*Status))
MemGetChunkAddr (VchunkToken.InCore,    McStat,     ChunkAddr);
#ifdef   __FREEZE_VCHUNKS__
if (Normal(*Status))
if (Anchor->DbId > WenvId)
if (CoreDb->VchunkCommitDir)
if (MemPutBit       (CoreDb->VchunkCommitDir,  *Vchunk, 1,
McStat))
MemPutVbn       (CoreDb->VchunkSwapDir,    *Vchunk, 0,
McStat);
#endif
TRACK(TrackBak,"DbmNewVchunk\n");
return (STAT);
}
boolean    DbmPutVchunkTkn (tokentype    *Token,  vchunktkntype *VchunkTkn,
ft F,lt Z,zz *Status)
{
dbheader      *CoreDb       = NullPtr;
if (!Token->Handle)
*Status = Oa_VchunkNotExist;
if (TmGetCoreDb     (Token, McStat,    &CoreDb))
if (CoreDb->VchunkGrpHdr == 0)
GrpGetPacket    (Token,      CoreDb->VchunkGrpNum,
McStat,    &CoreDb->VchunkGrpHdr);
if (Normal(*Status))
GrpPutEntry            (Token,     CoreDb->VchunkGrpNum,Token->Handle,
(addrtype )VchunkTkn,           McStat);
TRACK(TrackBak,"DbmPutVchunkTkn\n");
return (STAT);
}
boolean    DbmFreeVchunk   (tokentype    *Vtoken,  ft F,lt Z,zz *Status)
{
vchunktkntype Vchunk;
numtype       IsCommitted  = 0;
#ifdef   __FREEZE_VCHUNKS__
dbheader     *DbHdr        = NullPtr;
#endif
if (!Vtoken->Handle)
*Status = Oa_VchunkNotExist;
if (Normal(*Status))
if (DbmGetVchunkTkn    (Vtoken,          McStat,          &Vchunk))
if (Normal(*Status))
if (Vchunk.InCore)
#ifdef   __FREEZE_VCHUNKS__
if (TmGetCoreDb       (Vtoken,          McStat,       &DbHdr))
if (DbHdr->VchunkCommitDir)
MemGetBit         (DbHdr->VchunkCommitDir,  Vtoken->Handle,
McStat,                 &IsCommitted);
#endif
if (Normal(*Status))
if (IsCommitted == 0)
if (MemFreeChunk      (&Vchunk.InCore,   McStat))
DbmPutVchunkTkn   (Vtoken,          &Vchunk,           McStat);
TRACK(TrackBak,"DbmFreeVchunk\n");
return (STAT);
}
boolean    DbmDeleteVchunk (tokentype    *Vtoken,  ft F,lt Z,zz *Status)
{
dbheader     *CoreDb       = NullPtr;
vchunktkntype Vchunk;
#ifdef   __FREEZE_VCHUNKS__
#endif
if (!Vtoken->Handle)
*Status = Oa_VchunkNotExist;
if (DbmInvokeVchunk    (Vtoken,          McStat,          &Vchunk))
if (Normal(*Status))
if (Vchunk.InCore)
MemFreeChunk       (&Vchunk.InCore,  McStat);
if (Normal(*Status))
if (TmGetCoreDb        (Vtoken,          McStat,       &CoreDb))
if (Vchunk.OnDisk)
{
*Status  = Err_NotImplemented;
}
if (Normal(*Status))
if (CoreDb->VchunkSwapDir)
if (MemPutVbn       (CoreDb->VchunkSwapDir,   Vtoken->Handle,  0,
McStat))
MemPutBit       (CoreDb->VchunkCommitDir, Vtoken->Handle,  0,
McStat);
if (Normal(*Status))
GrpDeleteEntry    (Vtoken,           CoreDb->VchunkGrpNum,
Vtoken->Handle,   McStat);
TRACK(TrackBak,"DbmDeleteVchunk\n");
return (STAT);
}
boolean DbmCommitVchunk  (tokentype    *VchunkTkn, boolean     Release,
ft F,lt Z,zz *Status)
{
dbheader   *DbHdr        = NullPtr;
if (VchunkTkn->Handle == 0)
return (STAT);
#ifndef   __FREEZE_VCHUNKS__
if (TmGetCoreDb       (VchunkTkn,          McStat,       &DbHdr))
{
CoreBug     = False;
PageBug     = False;
Index       = VchunkTkn->Handle;
if (DbmGetVchunkTkn  (VchunkTkn,    McStat,  &Vchunk))
{
if (Vchunk.InCore)
if (FileOutChunk   (&Vchunk.InCore,           &(DbHdr->BlkHdr),
Release,       McStat,    &Vchunk.OnDisk))
Vchunk.InCore = 0;
if (Normal(*Status))
GrpPutEntry    (&DbToken,      DbHdr->VchunkGrpNum,
Index,
(addrtype )&Vchunk,        McStat);
}
CoreBug      = TempCoreBug;
PageBug      = TempPageBug;
} else {
}
#else
if (Normal(*Status))
if (TmGetCoreDb       (VchunkTkn,          McStat,       &DbHdr))
if (DbHdr->VchunkCommitDir)
if (MemPutBit         (DbHdr->VchunkCommitDir,  VchunkTkn->Handle, 1,
McStat))
if (Release)
MemPutVbn         (DbHdr->VchunkSwapDir,    VchunkTkn->Handle, 0,
McStat);
#endif
TRACK(TrackBak,"DbmCommitVchunk\n");
return(STAT);
}
boolean    DbmInvokeVchunk (tokentype    *Token,
ft F,lt Z,zz *Status, vchunktkntype *VchunkToken)
{
dbheader     *CoreDb       = NullPtr;
booleantype   Release      = False;
boolean       TmpFileBug   = FileBug;
chunkstruc *ChunkStrucPtr = NullPtr;
numtype     NumBlkArrays   = 0;
numtype     ChunkBlk       = 0;
char       *BlkAddr        = NullPtr;
chunkstruc *ChunkStrucRef  = NullPtr;
blktkntype *BlkTkns        = NullPtr;
numtype     Chunk          = 0;
addrtype    ChunkAddr      = NullPtr;
int         i              = 0;
indextype   Index          = 0;
numtype     InCore         = 0;
if (!Token->Handle)
*Status = Oa_VchunkNotExist;
if (Normal(*Status))
if (TmGetCoreDb      (Token,     McStat,            &CoreDb))
if (DbmGetVchunkTkn  (Token,     McStat,             VchunkToken))
if (VchunkToken->InCore == 0)
{
if (VchunkToken->OnDisk)
{
if (FileInChunk      (&VchunkToken->InCore,   &CoreDb->BlkHdr,
Release,
McStat,                 &VchunkToken->OnDisk))
if (MemGetChunkAddr  (VchunkToken->InCore,
McStat,                 (addrtype *)&BlkAddr))
{
ChunkBlk      = VchunkToken->InCore;
ChunkStrucRef = (chunkstruc *)(BlkAddr - sizeof(chunkstruc));
}
if (Normal(*Status))
if (ChunkStrucRef->MaxUnitLength != MAX_UNIT_LENGTH)
{
GrpPutEntry       (Token,     CoreDb->VchunkGrpNum,  Token->Handle,
(addrtype )VchunkToken,           McStat);
} else {
NumBlkArrays  = ChunkStrucRef->StackPtr;
BlkTkns       = (blktkntype *)BlkAddr;
InCore        = 0;
i             = 0;
while (Normal(*Status)
&&     ++i <= NumBlkArrays)
{
Index              = BlkTkns[i].Owner;
Chunk              = 0;
if (Index)
{
ChunkAddr        = (addrtype )(BlkAddr
+ (BlkTkns[i].Offset + sizeof (chunkstruc)));
if (NewChunkChunk      (McStat,    &Chunk))
if (MemPutChunkAddr    (Chunk,      ChunkAddr,    McStat))
ChunkStrucPtr = (chunkstruc *)((char *)ChunkAddr
- sizeof (chunkstruc));
VchunkToken->InCore = Chunk;
if (Normal(*Status))
if (MemPutChunkStruc (Chunk,     ChunkStrucPtr,   Token->DbId,
McStat))
GrpPutEntry      (Token,     CoreDb->VchunkGrpNum,
Index,     (addrtype )VchunkToken,
McStat);
}
if (Chunk)
MemDumpChunk (0, Chunk, McStat);
if (Index == Token->Handle)
InCore  = VchunkToken->InCore;
}
if (Normal(*Status))
{
VchunkToken->InCore      = InCore;
ChunkStrucRef->UnitCount = BlkTkns[1].Offset;
MemFreeChunk (&ChunkBlk, McStat);
}
}
} else
*Status = Oa_VchunkNotExist;
}
FileBug = TmpFileBug;
TRACK(TrackBak,"DbmInvokeVchunk\n");
return (STAT);
}
boolean    DbmGetVchunkTkn (tokentype    *Token,
ft F,lt Z,zz *Status,  vchunktkntype *VchunkTkn)
{
dbheader      *CoreDb       = NullPtr;
grpheader     *GrpHdr       = NullPtr;
vchunktkntype *VchunkDir    = NullPtr;
numtype        RgnNum       = 0;
indextype      LocalIndex   = 0;
numtype        Chunk        = 0;
indextype      StackPtr     = 0;
if (!Token->Handle)
*Status = Oa_VchunkNotExist;
if (TmGetCoreDb     (Token, McStat,    &CoreDb))
if ((GrpHdr = CoreDb->VchunkGrpHdr) == NullPtr)
{
if (GrpGetPacket    (Token,      CoreDb->VchunkGrpNum,
McStat,    &CoreDb->VchunkGrpHdr))
{
GrpHdr   = CoreDb->VchunkGrpHdr;
StackPtr = GrpHdr->EntryCount + 1;
}
if (Normal(*Status))
if (DbmBug)
Grp_DumpStruct   (Token, CoreDb->VchunkGrpNum,  McStat);
#ifdef   __FREEZE_VCHUNKS__
if (Normal(*Status))
if (CoreDb->DbId   > WenvId)
if (MemNewBitChunk  (StackPtr,             CoreDb->DbId,
McStat,              &(CoreDb->VchunkCommitDir)))
if (MemMakeChunk    (sizeof(vbntype),   StackPtr,      2000,
CoreDb->DbId,   McStat, &(CoreDb->VchunkSwapDir)))
MemPutStackPtr  (CoreDb->VchunkSwapDir,  StackPtr,       McStat);
#endif
}
if (Normal(*Status))
{
if (Token->Handle < GrpHdr->BaseIndex)
{
RgnNum     = 0;
LocalIndex = Token->Handle;
} else {
RgnNum     = (Token->Handle - GrpHdr->BaseIndex)
/ GrpHdr->RegionEntrys;
if (GrpHdr->BaseIndex)
RgnNum++;
LocalIndex = (Token->Handle - GrpHdr->BaseIndex)
% GrpHdr->RegionEntrys;
}
if (GrpGetRegion (CoreDb,     GrpHdr,                         RgnNum,
McStat,    &Chunk,          (addrtype *)&VchunkDir))
*VchunkTkn    = VchunkDir[LocalIndex];
if ( RgnNum == 0 )
	GrpHdr->BaseRegion = Chunk ;
if (VchunkTkn->InCore == 0
&&  VchunkTkn->OnDisk == 0)
if (MemGetChunkNum  (GrpHdr->RegionChunkDir, RgnNum, McStat, &Chunk))
if (Chunk)
DumpChunkChunk  (0, Chunk);
}
TRACK(TrackBak,"DbmGetVchunkTkn\n");
return (STAT);
}
boolean    DbmDumpVchunkVchunk
(tokentype    *Token,   ft F,lt Z,zz *Status)
{
vchunktkntype VchunkToken;
dbheader     *CoreDb       = NullPtr;
if (Token->Handle == 0)
{
TraceMsg (0,  "  *** NULL Handle to Virtual Chunk.\n");
*Status = Oa_VchunkNotExist;
}
if (Token->DbId    > CoreDbCount)
{
*Status = Oa_VchunkNotExist;
}
if (Normal(*Status))
if (TmGetCoreDb      (Token,     McStat,            &CoreDb))
if (DbmGetVchunkTkn  (Token,     McStat,            &VchunkToken))
if (Normal(*Status))
if (VchunkToken.InCore)
DumpChunkChunk    (0, VchunkToken.InCore);
TRACK(TrackBak,"DbmDumpVchunkVchunk\n");
return (STAT);
}
boolean    DbmDumpVchunk   (tokentype    *Token,
numtype       Limit0, numtype        Limit1,
ft F,lt Z,zz *Status)
{
vchunktkntype VchunkToken;
dbheader   *CoreDb         = NullPtr;
booleantype Release        = False;
chunkstruc *ChunkStrucPtr  = NullPtr;
numtype     NumBlkArrays   = 0;
numtype     ChunkBlk       = 0;
char       *BlkAddr        = NullPtr;
chunkstruc *ChunkStrucRef  = NullPtr;
blktkntype *BlkTkns        = NullPtr;
numtype     Chunk          = 0;
addrtype    ChunkAddr      = NullPtr;
int         i              = 0;
indextype   Index          = 0;
boolean     NotFound       = True;
if (Token->Handle == 0)
{
TraceMsg (0,  "  *** NULL Handle to Virtual Chunk.\n");
*Status = Oa_VchunkNotExist;
}
if (Token->DbId    > CoreDbCount)
{
*Status = Oa_VchunkNotExist;
}
if (Normal(*Status))
if (TmGetCoreDb      (Token,     McStat,            &CoreDb))
if (DbmGetVchunkTkn  (Token,     McStat,            &VchunkToken))
if (Normal(*Status))
if (VchunkToken.InCore  == 0)
{
if (VchunkToken.OnDisk)
{
if (FileInChunk      (&VchunkToken.InCore,    &CoreDb->BlkHdr,
Release,
McStat,                 &VchunkToken.OnDisk))
if (MemGetChunkAddr  (VchunkToken.InCore,
McStat,                 (addrtype *)&BlkAddr))
{
ChunkBlk      = VchunkToken.InCore;
ChunkStrucRef = (chunkstruc *)(BlkAddr - sizeof(chunkstruc));
}
if (Normal(*Status))
if (ChunkStrucRef->MaxUnitLength
!=  MAX_UNIT_LENGTH)
{
if (Mem_DumpChunkPart (0, VchunkToken.InCore,
Limit0,  Limit1,    McStat))
MemFreeChunk (&VchunkToken.InCore,     McStat);
} else {
NumBlkArrays  = ChunkStrucRef->StackPtr;
BlkTkns       = (blktkntype *)BlkAddr;
i             = 0;
while (Normal(*Status)
&&     ++i <= NumBlkArrays
&&     NotFound)
{
Index              = BlkTkns[i].Owner;
Chunk              = 0;
if (Index  == Token->Handle)
{
NotFound         = False;
ChunkAddr        = (addrtype )(BlkAddr
+ (BlkTkns[i].Offset + sizeof (chunkstruc)));
if (NewChunkChunk      (McStat,    &Chunk))
if (MemPutChunkAddr    (Chunk,      ChunkAddr,    McStat))
ChunkStrucPtr = (chunkstruc *)((char *)ChunkAddr
- sizeof (chunkstruc));
VchunkToken.InCore = Chunk;
if (Normal(*Status))
MemPutChunkStruc (Chunk,     ChunkStrucPtr,   Token->DbId,
McStat);
}
if (Normal(*Status))
if (Chunk)
if (Mem_DumpChunkPart   (0, Chunk,  Limit0,  Limit1, McStat))
MemFreeChunkNum     (&Chunk,    McStat);
}
if (Normal(*Status))
MemFreeChunk      (&ChunkBlk, McStat);
}
} else
TraceMsg (0, " *** DbmVchunkDump:: NULL virtual chunk\n");
} else
Mem_DumpChunkPart (0, VchunkToken.InCore, Limit0, Limit1,  McStat);
if (*Status == Oa_VchunkNotExist)
*Status  = Env_Normal;
TRACK(TrackBak,"DbmDumpVchunk\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\voa.c*/

#define VOA
#ifdef NULL_TRACE_STRS
#define TraceStr12(StrNum)  TraceStr12[0]
static const char   *TraceStr12[1] = {"   ...MEM00... message\n" };
#else
#define TraceStr12(StrNum)  TraceStr12[StrNum]
static const char *TraceStr12[12] =
{
"   OaCreateVchunk  [%3u:%4u];\n",
"   OaSwapOutVchunk [%3u:%4u] Chunk =%4u; Vbn =%4u\n",
"   OaSwapInVchunk  [%3u:%4u] Chunk =%4u; Vbn =%4u \n",
"   Vchunk[%3u] Chunk=%4u...",
"   OaGetVchunkAddr [%3u:%4u] @%8x \n",
"   OaPutVchunkAddr [%3u:%4u] %x \n",
"   OaGetVchunkAllocQty[%3u:%4u] =%4u \n",
"   OaGetVchunkStackPtr[%3u:%4u] =%4u \n",
"   OaPutVchunkStackPtr[%3u:%4u] =%4u \n",
"       ... Vchunk[%3u:%4u]  Index %u > StackPtr %u\n",
"       ... Vchunk[%3u:%4u]  Index %u >= StackPtr %u\n",
"   Vchunk[%3u:%4u] ..."
};
#endif
#define PrimalId  RenvId
boolean    OaCreateVchunk (tokentype    *Anchor,     sizetype      UnitSize,
indextype     UnitCount,  indextype     ExtendQty,
ft F,lt Z,zz *Status,     tokentype    *Token)
{
addrtype   ChunkAddr = NullPtr;
Token->DbId     = Anchor->DbId;
Token->CoreDbId = Anchor->CoreDbId;
DbmNewVchunk      (Anchor,  UnitSize,            UnitCount,  ExtendQty,
McStat,  (indextype  *)&(Token->Handle), &ChunkAddr);
if (DeBug || OaBug)
if (sprintf (Msg, TraceStr12(0),
Token->DbId, Token->Handle))
TraceMsg (0, Msg);
TRACK(TrackBak,"OaCreateVchunk\n");
return (STAT);
}
boolean    OaFreezeVchunk (tokentype   *Token,   ft F,lt Z,zz *Status)
{
vchunktkntype VchunkToken;
if (OmGetVchunkToken (Token, McStat, &VchunkToken))
MemDefrostChunk (VchunkToken.InCore, McStat);
TRACK(TrackBak,"OaFreezeVchunk\n");
return (STAT);
}
boolean    OaDumpVchunkVchunk (tokentype  *Token,   ft F,lt Z,zz *Status)
{
vchunktkntype VchunkToken;
if (OmGetVchunkToken (Token, McStat, &VchunkToken))
if (sprintf           (Msg,  TraceStr12(3),
Token->Handle, VchunkToken.InCore))
if (TraceMsg          (0,    Msg))
if (VchunkToken.InCore)
DumpChunkChunk (0, VchunkToken.InCore);
TRACK(TrackBak,"OaDumpVchunkVchunk\n");
return (STAT);
}
boolean    OaGetVchunkAddr (tokentype    *Token,
ft F,lt Z,zz *Status,  addrtype    *ChunkAddr)
{
vchunktkntype VchunkToken;
if (OmGetVchunkToken (Token, McStat, &VchunkToken))
MemGetChunkAddr (VchunkToken.InCore, McStat, ChunkAddr);
if (DeBug || OaBug)
if (sprintf (Msg, TraceStr12(4),
Token->DbId, Token->Handle, *ChunkAddr))
TraceMsg (0, Msg);
TRACK(TrackBak,"OaGetVchunkAddr\n");
return (STAT);
}
boolean    OaPutVchunkAddr (tokentype    *Token,  addrtype    ChunkAddr,
ft F,lt Z,zz *Status)
{
vchunktkntype VchunkToken;
if (OmGetVchunkToken (Token, McStat, &VchunkToken))
MemPutChunkAddr (VchunkToken.InCore, ChunkAddr, McStat);
if (DeBug || OaBug)
if (sprintf (Msg, TraceStr12(5),
Token->DbId, Token->Handle, ChunkAddr))
TraceMsg (0, Msg);
TRACK(TrackBak,"OaPutVchunkAddr\n");
return (STAT);
}
boolean    OaGetVchunkAllocQty (tokentype    *Token,
ft F,lt Z,zz *Status,   indextype  *AllocQty)
{
vchunktkntype VchunkToken;
numtype       UnitSize    = 0;
if (OmGetVchunkToken  (Token,              McStat,    &VchunkToken))
MemGetChunkSize   (VchunkToken.InCore, McStat,     AllocQty,  &UnitSize);
if (DeBug || OaBug)
if (sprintf (Msg, TraceStr12(6),
Token->DbId, Token->Handle, *AllocQty))
TraceMsg (0, Msg);
TRACK(TrackBak,"OaGetVchunkAllocQty\n");
return (STAT);
}
boolean    OaGetVchunkStackPtr (tokentype    *Token,
ft F,lt Z,zz *Status,   indextype  *StackPtr)
{
vchunktkntype VchunkToken;
if (OmGetVchunkToken (Token, McStat, &VchunkToken))
MemGetStackPtr (VchunkToken.InCore, McStat,  StackPtr);
if (DeBug || OaBug)
if (sprintf (Msg, TraceStr12(7),
Token->DbId, Token->Handle, *StackPtr))
TraceMsg (0, Msg);
TRACK(TrackBak,"OaGetVchunkStackPtr\n");
return (STAT);
}
boolean    OaPutVchunkStackPtr (tokentype    *Token,  indextype   StackPtr,
ft F,lt Z,zz *Status)
{
vchunktkntype VchunkToken;
if (OmGetVchunkToken (Token, McStat, &VchunkToken))
MemPutStackPtr (VchunkToken.InCore, StackPtr, McStat);
if (DeBug || OaBug)
if (sprintf (Msg, TraceStr12(8),
Token->DbId, Token->Handle, StackPtr))
TraceMsg (0, Msg);
TRACK(TrackBak,"OaPutVchunkStackPtr\n");
return (STAT);
}
boolean    OaPushUnit        (tokentype    *Token,   addrtype    SomeBytes,
ft F,lt Z,zz *Status,  indextype  *StackPtr)
{
indextype     UnitCount     = 0;
bytessize     UnitSize      = 0;
vchunktkntype VchunkToken;
indextype     ByteStackPtr  = 0;
if (OmGetVchunkToken  (Token,              McStat,    &VchunkToken))
if (MemGetChunkSize   (VchunkToken.InCore, McStat,    &UnitCount, &UnitSize))
MemPushSomeBytes  (VchunkToken.InCore, UnitSize,   SomeBytes,
McStat,            &ByteStackPtr);
if (Normal(*Status))
if (MemGetStackPtr    (VchunkToken.InCore, McStat,     StackPtr))
*StackPtr = *StackPtr - 1;
TRACK(TrackBak,"OaPushUnit\n");
return (STAT);
}
boolean    OaPutUnit     (tokentype    *Token,     indextype     Index,
addrtype      SomeBytes, ft F,lt Z,zz *Status)
{
indextype     UnitCount  = 0;
bytessize     UnitSize   = 0;
vchunktkntype VchunkToken;
if (OmGetVchunkToken  (Token,              McStat, &VchunkToken))
if (MemGetChunkSize   (VchunkToken.InCore, McStat, &UnitCount, &UnitSize))
MemPutSomeBytes   (VchunkToken.InCore, Index,   UnitSize,  SomeBytes,
McStat);
TRACK(TrackBak,"OaPutUnit\n");
return (STAT);
}
boolean    OaGetUnit         (tokentype    *Token,   indextype   Index,
ft F,lt Z,zz *Status,  addrtype    SomeBytes)
{
indextype     UnitCount  = 0;
bytessize     UnitSize   = 0;
vchunktkntype VchunkToken;
if (OmGetVchunkToken  (Token,              McStat,   &VchunkToken))
if (MemGetChunkSize   (VchunkToken.InCore, McStat,   &UnitCount, &UnitSize))
MemGetSomeBytes   (VchunkToken.InCore, Index,     UnitSize,
McStat,             SomeBytes);
TRACK(TrackBak,"OaGetUnit\n");
return (STAT);
}
boolean    OaDumpVchunk  (tokentype  *Token,   ft F,lt Z,zz *Status)
{
vchunktkntype VchunkToken;
if (OmGetVchunkToken  (Token,  McStat, &VchunkToken))
if (sprintf           (Msg,  TraceStr12(11),
Token->DbId, Token->Handle))
if (TraceMsg          (0,    Msg))
MemDumpChunk (0, VchunkToken.InCore, McStat);
TRACK(TrackBak,"OaDumpVchunk\n");
return (STAT);
}
boolean    OaDeleteVchunk  (tokentype    *Token,  ft F,lt Z,zz *Status)
{
*Status  = Err_NotImplemented;
TRACK(TrackBak,"OaDeleteVchunk\n");
return (STAT);
}
/* 当前文件是./CINT2000\255.vortex\src\vom.c*/

#define  VOM
#define TmGetCoreDb(Anchor,Stat,DbInCore) \
(*DbInCore  = CoreDbs[Anchor->DbId]) != NullPtr ? True : \
TmFetchCoreDb(Anchor,Stat,DbInCore)
#define PrimalId  RenvId
#define MemFreeFileBlk     Mem_FreeFileBlk
#define FileInChunk        File_InChunk


#define MemPopChunkIndex     Mem_PopWord
#define MemPushChunkIndex    Mem_PushWord
boolean OmNewVchunk       (tokentype    *Anchor,    sizetype      UnitSize,
indextype     UnitCount, indextype     ExtendQty,
ft F,lt Z,zz *Status,
indextype    *Vchunk,    addrtype     *ChunkAddr)
{
SendMsg (0, " Warning ... OmNewVchunk Accessed via OA \n");
*Status = Oa_VchunkNoAccess;
TRACK(TrackBak,"OmNewVchunk\n");
return (STAT);
}
boolean OmGetVchunkToken  (tokentype    *Token,     ft F,lt Z,zz *Status,
vchunktkntype           *VchunkToken)
{
dbheader     *CoreDb       = NullPtr;
booleantype   Release      = False;
boolean       TmpFileBug   = FileBug;
if (!Token->Handle)
*Status = Oa_VchunkNotExist;
if (Normal(*Status))
if (TmGetCoreDb      (Token,  McStat,         &CoreDb))
DbmGetVchunkTkn   (Token,  McStat,          VchunkToken);
if (Normal(*Status))
if (!VchunkToken->InCore)
{
if (VchunkToken->OnDisk)
{
if (FileInChunk      (&VchunkToken->InCore,   &CoreDb->BlkHdr,
Release,
McStat,                 &VchunkToken->OnDisk))
if (Token->DbId >= PrimalId)
DbmPutVchunkTkn  (Token,      VchunkToken, McStat);
else {
SendMsg (0, "\n CoreDb->VchunkDir should NOT be Accessed!\n");
*Status  = Err_BadDesign;
}
} else
*Status = Oa_VchunkNotExist;
}
FileBug = TmpFileBug;
TRACK(TrackBak,"OmGetVchunkToken\n");
return (STAT);
}
boolean OmGetVchunkStruc  (tokentype    *Token,     ft F,lt Z,zz *Status,
chunkstruc   *VchunkStruc)
{
vchunktkntype VchunkToken;
if (OmGetVchunkToken (Token, McStat, &VchunkToken))
MemGetChunkStruc (VchunkToken.InCore, McStat, VchunkStruc);
TRACK(TrackBak,"OmGetVchunkStruc\n");
return (STAT);
}
boolean OmDeleteVchunk    (tokentype    *Token,     ft F,lt Z,zz *Status)
{
SendMsg (0, " Warning ... Vchunk Accessed via OA \n");
*Status = Oa_VchunkNoAccess;
TRACK(TrackBak,"OmDeleteVchunk\n");
return (STAT);
}
main                    (int           argc,     char          *argv[])
{
int          argcount           = 0;
FILE        *arglistfile;
char         buffer[MAXSTRING];
char         ArgName[MAXPATHNAME];
statustype   Status             = 0;
boolean      Large              = False;
int          PartCount          = 1000;
int          OuterLoop          = 1;
int          InnerLoop          = 2;
int          LookUps            = 1000;
int          Deletes            = 0;
int          StuffParts         = 100;
int          TraverseLimit      = 7;
int          DeleteDraws        = 0;
int          DeleteParts        = 0;
int          NewPartPct         = 0;
int          LookUpPct          = 0;
int          DeletePct          = 0;
int          StuffPct           = 0;
boolean      CommitDbs          = False;
#ifdef __DISPLAY_TIME__
time_t       NullTime           = 0;
time_t       CurrTime           = 0;
double       Elapsed            = 0.0;
#endif
static char  Parms[MAXSTRING *  2];
numtype      ParmLen                       = 0;
static char  Edb_DbName[MAXPATHNAME]       = "PartLib";
static char  Edb_DbFileName[MAXPATHNAME]   = "Part.db";
static char  Drw_DbName[MAXPATHNAME]       = "DrawLib";
static char  Drw_DbFileName[MAXPATHNAME]   = "Draw.db";
static char  Emp_DbName[MAXPATHNAME]       = "PersonLib";
static char  Emp_DbFileName[MAXPATHNAME]   = "Persom.db";
static char  Dat_File[MAXPATHNAME]         = "";
static char  Msg_File[MAXPATHNAME]         = "";
static char  Out_File[MAXPATHNAME]         = "";
static char  Mem_File[MAXPATHNAME]         = "";
farlongtype  Core_PageSize      = 64000L;
indextype    Alloc_FreeAddrs    = 2806;
indextype    Extend_FreeAddrs   = 1806;
indextype    Alloc_Chunks       = 10402;
indextype    Extend_Chunks      = 10002;
indextype    Alloc_XmemBlks     = 1004;
indextype    Extend_XmemBlks    = 1004;
indextype    Alloc_DbBlks       = 1004;
indextype    Extend_DbBlks      = 1004;
indextype    Alloc_Handles      = 1004;
indextype    Extend_Handles     = 1004;
indextype    Alloc_Vchunks      = 10402;
indextype    Extend_Vchunks     = 10002;
indextype    Alloc_Grps         = 100;
indextype    Extend_Grps        = 20;
sizetype     BoolSize           = sizeof (boolean);
FileBug        = False;
Global_Apl     = Cpp_Apl;
Large          = True;
Align_Bytes    = False;
Align_CppStruc = False;
Print_Msg      = True;
WriteHdr       = True;
strcpy  (Msg_File,     "stdout");
MsgFilePtr     = stdout;
if(--argc     == 0)
{
TraceMsg (0, "\n\n  VORTEX Help File::\n");
TraceMsg (0, "\n  Create an input file with the following arguments\n");
TraceMsg (0, "  listed one per line.  Then use the input file name\n");
TraceMsg (0, "  as the argument to the program when invoked!\n");
TraceMsg (0, "  arg[ 1]... MESSAGE        FileName\n");
TraceMsg (0, "  arg[ 2]... OUTPUT         FileName\n");
TraceMsg (0, "  arg[ 3]... DISK CACHE     FileName\n");
TraceMsg (0, "  arg[ 4]... RENV           FileName\n");
TraceMsg (0, "  arg[ 5]... WENV           FileName\n");
TraceMsg (0, "  arg[ 6]... PRIMAL         FileName\n");
TraceMsg (0, "  arg[ 7]... PART DB        FileName\n");
TraceMsg (0, "  arg[ 8]... DRAW DB        FileName\n");
TraceMsg (0, "  arg[ 9]... PERSON DB      FileName\n");
TraceMsg (0, "  arg[10]... PERSONS Input  FileName\n");
TraceMsg (0, "  arg[11]... # of PARTS            to Create.\n");
TraceMsg (0, "  arg[12]... # of OUTER     Loops\n");
TraceMsg (0, "  arg[13]... # of INNER     Loops \n");
TraceMsg (0, "  arg[14]... # of LOOKUP    Parts         per inner loop\n");
TraceMsg (0, "  arg[15]... # of DELETE    Parts         per inner loop\n");
TraceMsg (0, "  arg[16]... # of STUFF     Parts  to add per inner loop\n");
TraceMsg (0, "  arg[17]... % to DECREASE  new    Parts created.\n");
TraceMsg (0, "  arg[18]... % to INCREASE  Lookup Parts per inner loop.\n");
TraceMsg (0, "  arg[19]... % to INCREASE  Delete Parts per inner loop.\n");
TraceMsg (0, "  arg[20]... % to INCREASE  Stuff  Parts per inner loop.\n");
TraceMsg (0, "  arg[21]... DEPTH          of Level in Traverse/Reverse\n");
TraceMsg (0, "  arg[22]... FREEZE_GRP_PACKETS    always true.\n");
TraceMsg (0, "  arg[23]... ALLOC_CHUNKS   low value will flush data cache\n");
TraceMsg (0, "  arg[24]... EXTEND_CHUNKS  on each extension\n");
TraceMsg (0, "  arg[25]... DELETE Draw    objects during Traverse/Reverse\n");
TraceMsg (0, "  arg[26]... DELETE Part    objects at end of i'th Outer Loop\n");
TraceMsg (0, "  arg[27]... QueBug         modulo  for traceing process\n");
TraceMsg (0, "  arg[28]... Void Boundary  MAX Core allocatable.\n");
TraceMsg (0, "  arg[29]... Void Reserve   RESERVE Core allocatable.\n");
TraceMsg (0, "  arg[30]... Commit Dbs     Commit Dbs during run.\n");
return (0);
}
else
{
strcpy  (ArgName,  *++argv);
arglistfile  = fopen (ArgName,  "r");
if  (!arglistfile)
{
fprintf(stderr,"ERROR on fopen() of VORTEX input parameter file %s\n",
ArgName);
exit (1);
}
while (fgets (buffer,  MAXSTRING,  arglistfile))
{
switch (argcount)
{
case 0:
sscanf (buffer, "%*s %s", Msg_File);
break;
case 1:
sscanf (buffer, "%*s %s", Out_File);
break;
case 2:
sscanf (buffer, "%*s %s", Mem_File);
break;
case 3:
sscanf (buffer, "%*s %s", DbFileName);
break;
case 4:
sscanf (buffer, "%*s %s", WenvFileName);
break;
case 5:
sscanf (buffer, "%*s %s", PrimalFileName);
break;
case 6:
sscanf (buffer, "%*s %s", Edb_DbFileName);
break;
case 7:
sscanf (buffer, "%*s %s", Drw_DbFileName);
break;
case 8:
sscanf (buffer, "%*s %s", Emp_DbFileName);
break;
case 9:
sscanf (buffer, "%*s %s", Dat_File);
break;
case 10:
sscanf (buffer, "%*s %d", &PartCount);
break;
case 11:
sscanf (buffer, "%*s %d", &OuterLoop);
break;
case 12:
sscanf (buffer, "%*s %d", &InnerLoop);
break;
case 13:
sscanf (buffer, "%*s %d", &LookUps);
break;
case 14:
sscanf (buffer, "%*s %d", &Deletes);
break;
case 15:
sscanf (buffer, "%*s %d", &StuffParts);
break;
case 16:
sscanf (buffer, "%*s %d", &NewPartPct);
break;
case 17:
sscanf (buffer, "%*s %d", &LookUpPct);
break;
case 18:
sscanf (buffer, "%*s %d", &DeletePct);
break;
case 19:
sscanf (buffer, "%*s %d", &StuffPct);
break;
case 20:
sscanf (buffer, "%*s %d", &TraverseLimit);
break;
case 21:
sscanf (buffer, "%*s %d", &FREEZE_GRP_PACKETS);
break;
case 22:
sscanf (buffer, "%*s %d", &Alloc_Chunks);
break;
case 23:
sscanf (buffer, "%*s %d", &Extend_Chunks);
break;
case 24:
sscanf (buffer, "%*s %d", &DeleteDraws);
break;
case 25:
sscanf (buffer, "%*s %d", &DeleteParts);
break;
case 26:
sscanf (buffer, "%*s %d", &QueBug);
break;
case 27:
sscanf (buffer, "%*s %d", &VOID_BOUNDARY);
break;
case 28:
sscanf (buffer, "%*s %d", &VOID_RESERVE);
break;
case 29:
sscanf (buffer, "%*s %d", &CommitDbs);
break;
default:
break;
}
argcount++;
}
if (FREEZE_GRP_PACKETS == True)
strcpy (Mem_File, "NULL");
if  (argcount < PARMS_EXPECTED - 3)
{
fprintf (stderr,"ERROR in VORTEX input parameter file %s: ",
ArgName);
fprintf (stderr,"%d of the expected %d arguments were found.\n",
argcount,  PARMS_EXPECTED);
exit (1);
}
else if  (argcount > PARMS_EXPECTED)
{
fprintf(stderr,"ERROR in VORTEX input parameter file %s: ",
ArgName);
fprintf(stderr,"%d arguments exceeds the %d required parameters.\n",
argcount,  PARMS_EXPECTED);
exit (1);
}
else
{
#ifdef __BMT01__
sprintf (Parms, "\nVORTEX INPUT PARAMETERS::\n");
strcat  (Parms, Msg );
sprintf (Msg, "\tMESSAGE       FileName:\t %-21s\n", Msg_File);
strcat  (Parms, Msg );
sprintf (Msg, "\tOUTPUT        FileName:\t %-21s\n", Out_File);
strcat  (Parms, Msg );
sprintf (Msg, "\tDISK CACHE    FileName:\t %-21s\n", Mem_File);
strcat  (Parms, Msg );
sprintf (Msg, "\tPART DB       FileName:\t %-21s\n", Edb_DbFileName);
strcat  (Parms, Msg );
sprintf (Msg, "\tDRAW DB       FileName:\t %-21s\n", Drw_DbFileName);
strcat  (Parms, Msg );
sprintf (Msg, "\tPERSON DB     FileName:\t %-21s\n", Emp_DbFileName);
strcat  (Parms, Msg );
sprintf (Msg, "\tPERSONS Data  FileName:\t %-21s\n", Dat_File);
strcat  (Parms, Msg );
sprintf (Msg, "\tPARTS         Count   :\t %-8d\n",  PartCount);
strcat  (Parms, Msg );
sprintf (Msg, "\tOUTER         Loops   :\t %-8d\n",  OuterLoop);
strcat  (Parms, Msg );
sprintf (Msg, "\tINNER         Loops   :\t %-8d\n",  InnerLoop);
strcat  (Parms, Msg );
sprintf (Msg, "\tLOOKUP        Parts   :\t %-8d\n",  LookUps);
strcat  (Parms, Msg );
sprintf (Msg, "\tDELETE        Parts   :\t %-8d\n",  Deletes);
strcat  (Parms, Msg );
sprintf (Msg, "\tSTUFF         Parts   :\t %-8d\n",  StuffParts);
strcat  (Parms, Msg );
sprintf (Msg, "\tDEPTH         Traverse:\t %-8d\n",  TraverseLimit);
strcat  (Parms, Msg );
sprintf (Msg, "\t%% DECREASE    Parts   :\t %-8d\n",  NewPartPct);
strcat  (Parms, Msg );
sprintf (Msg, "\t%% INCREASE    LookUps :\t %-8d\n",  LookUpPct);
strcat  (Parms, Msg );
sprintf (Msg, "\t%% INCREASE    Deletes :\t %-8d\n",  DeletePct);
strcat  (Parms, Msg );
sprintf (Msg, "\t%% INCREASE    Stuffs  :\t %-8d\n",  StuffPct);
strcat  (Parms, Msg );
sprintf (Msg, "\tFREEZE_PACKETS        :\t %-8d\n",  FREEZE_GRP_PACKETS);
strcat  (Parms, Msg );
sprintf (Msg, "\tALLOC_CHUNKS          :\t %-8d\n",  Alloc_Chunks);
strcat  (Parms, Msg );
sprintf (Msg, "\tEXTEND_CHUNKS         :\t %-8d\n",  Extend_Chunks);
strcat  (Parms, Msg );
sprintf (Msg, "\tDELETE Draw objects   :\t %-21s\n",
BoolStr[DeleteDraws]);
strcat  (Parms, Msg );
if (DeleteParts > 1)
sprintf (Msg, "\tDELETE Part objects   :\t %-21s\n", BoolStr[True]);
else
sprintf (Msg, "\tDELETE Part objects   :\t %-21s\n", BoolStr[DeleteParts]);
strcat  (Parms, Msg );
sprintf (Msg, "\tQUE_BUG               :\t %d\n", QueBug);
strcat  (Parms, Msg );
sprintf (Msg, "\tVOID_BOUNDARY         :\t %d\n", VOID_BOUNDARY);
strcat  (Parms, Msg );
sprintf (Msg, "\tVOID_RESERVE          :\t %d\n\n", VOID_RESERVE);
strcat  (Parms, Msg );
sprintf (Msg, "\tCOMMIT_DBS            :\t %s\n\n", BoolStr[CommitDbs]);
strcat  (Parms, Msg );
#else
fprintf (stdout, "\nVORTEX INPUT PARAMETERS::\n");
fprintf (stdout, "\tMESSAGE       FileName:\t %-21s\n", Msg_File);
fprintf (stdout, "\tOUTPUT        FileName:\t %-21s\n", Out_File);
fprintf (stdout, "\tDISK CACHE    FileName:\t %-21s\n", Mem_File);
fprintf (stdout, "\tRENV          FileName:\t %-21s\n", DbFileName);
fprintf (stdout, "\tWENV          FileName:\t %-21s\n", WenvFileName);
fprintf (stdout, "\tPRIMAL        FileName:\t %-21s\n", PrimalFileName);
fprintf (stdout, "\tPART DB       FileName:\t %-21s\n", Edb_DbFileName);
fprintf (stdout, "\tDRAW DB       FileName:\t %-21s\n", Drw_DbFileName);
fprintf (stdout, "\tPERSON DB     FileName:\t %-21s\n", Emp_DbFileName);
fprintf (stdout, "\tPERSONS Data  FileName:\t %-21s\n", Dat_File);
fprintf (stdout, "\tPARTS         Count   :\t %-8d\n",  PartCount);
fprintf (stdout, "\tOUTER         Loops   :\t %-8d\n",  OuterLoop);
fprintf (stdout, "\tINNER         Loops   :\t %-8d\n",  InnerLoop);
fprintf (stdout, "\tLOOKUP        Parts   :\t %-8d\n",  LookUps);
fprintf (stdout, "\tDELETE        Parts   :\t %-8d\n",  Deletes);
fprintf (stdout, "\tSTUFF         Parts   :\t %-8d\n",  StuffParts);
fprintf (stdout, "\t% DECREASE    Parts   :\t %-8d\n",  NewPartPct);
fprintf (stdout, "\t% INCREASE    LookUps :\t %-8d\n",  LookUpPct);
fprintf (stdout, "\t% INCREASE    Deletes :\t %-8d\n",  DeletePct);
fprintf (stdout, "\t% INCREASE    Stuffs  :\t %-8d\n",  StuffPct);
fprintf (stdout, "\tDEPTH         Traverse:\t %-8d\n",  TraverseLimit);
fprintf (stdout, "\tFREEZE_PACKETS        :\t %-8d\n",  FREEZE_GRP_PACKETS);
fprintf (stdout, "\tALLOC_CHUNKS          :\t %-8d\n",  Alloc_Chunks);
fprintf (stdout, "\tEXTEND_CHUNKS         :\t %-8d\n",  Extend_Chunks);
fprintf (stdout, "\tDELETE Draw objects   :\t %-21s\n",
BoolStr[DeleteDraws]);
if (DeleteParts > 1)
fprintf (stdout, "\tDELETE Part objects   :\t %s\n", BoolStr[True]);
else
fprintf (stdout, "\tDELETE Part objects   :\t %s\n", BoolStr[DeleteParts]);
fprintf (stdout, "\tQUE_BUG               :\t %d\n", QueBug);
fprintf (stdout, "\tVOID_BOUNDARY         :\t %d\n", VOID_BOUNDARY);
fprintf (stdout, "\tVOID_RESERVE          :\t %d\n\n", VOID_RESERVE);
fprintf (stdout, "\tCOMMIT DBS            :\t %s\n\n",BoolStr[CommitDbs]);
fflush  (stdout);
#endif
if ((ParmLen = strlen (Parms)) > MAXSTRING * 2)
{
fprintf (stdout, "\nPARAMETER STRING EXCEEDED (*%6u) !!!\n", MAXSTRING);
fprintf (stdout, "          STRING Size   :=  %6u\n", ParmLen);
}
}
}
WriteHdr       = False;
Print_Msg      = True;
Core_PageSize  = 65536 ;
if (BoolSize != 2 || Large)
{
Alloc_DbBlks          = 1500;
Extend_DbBlks         = 1005;
Alloc_Handles         = 1000;
Extend_Handles        = 1000;
Alloc_Vchunks         = 3001;
Extend_Vchunks        = 1001;
Alloc_XmemBlks        = 1004;
Extend_XmemBlks       = 1004;
Alloc_FreeAddrs       = 2806;
Extend_FreeAddrs      = 1806;
} else {
Alloc_DbBlks          = 1000;
Extend_DbBlks         = 1005;
Alloc_Handles         = 1000;
Extend_Handles        = 1000;
Alloc_Vchunks         = 2000;
Extend_Vchunks        = 1002;
Alloc_XmemBlks        = 99;
Extend_XmemBlks       = 50;
Alloc_FreeAddrs       = 84;
Extend_FreeAddrs      = 100;
}
WriteHdr       = False;
Print_Msg      = True;
Reload_Env     = True;
Install_Env    = False;
Ctest_Count    = PartCount;
#ifdef __DISPLAY_TIME__
time (&NullTime);
#endif
if (Domain_Omi0Invoke (Dat_File,        Msg_File,
Out_File,        Mem_File,
Core_PageSize,   Core_PageSize/2,
Alloc_FreeAddrs, Extend_FreeAddrs,
Alloc_Chunks,    Extend_Chunks,
Alloc_XmemBlks,  Extend_XmemBlks,
Alloc_Handles,   Extend_Handles,
Alloc_Vchunks,   Extend_Vchunks,
Alloc_Grps,      Extend_Grps,
Alloc_DbBlks,    Extend_DbBlks,
Parms,           McStatPtr))
{
BMT_Test           (Edb_DbName,      Edb_DbFileName,
Drw_DbName,      Drw_DbFileName,
Emp_DbName,      Emp_DbFileName,
PartCount,       OuterLoop,      InnerLoop,
LookUps,         Deletes,        StuffParts,
TraverseLimit,   NewPartPct,     LookUpPct,
DeletePct,       StuffPct,
DeleteDraws,     DeleteParts,    CommitDbs,
McStatPtr);
}
#ifdef __DISPLAY_TIME__
Elapsed    = difftime (time(&CurrTime), NullTime);
sprintf  (Msg, "\n Run Time = %.0f sec\n", Elapsed);
TraceMsg (MSGFILE,   Msg);
#endif
ClassBug = False;
Domain_Exit           (McStatPtr);
TraceMsg (0,"\n");
StackTrack ("Main");
#if 0
exit(1);
#endif
return(0);
}