/* 当前文件是D:\Read\mesa4.c*/

/* 当前文件是D:\Read\osmesa.h*/

#ifndef OSMESA_H
#define OSMESA_H
#define OSMESA_MAJOR_VERSION 2
#define OSMESA_MINOR_VERSION 5
#define OSMESA_COLOR_INDEX	GL_COLOR_INDEX
#define OSMESA_RGBA		GL_RGBA
#define OSMESA_BGRA		0x1
#define OSMESA_ARGB		0x2
#define OSMESA_RGB		GL_RGB
#define OSMESA_BGR		0x4

#define OSMESA_ROW_LENGTH	0x10
#define OSMESA_Y_UP		0x11
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <signal.h>
#include <ctype.h>
#include <time.h>
#include <limits.h>
#include <errno.h>
#define OSMESA_WIDTH		0x20
#define OSMESA_HEIGHT		0x21
#define OSMESA_FORMAT		0x22
#define OSMESA_TYPE		0x23
#define GL_NO_ERROR 0
typedef enum {
	/* Boolean values */
	GL_FALSE			= 0,
	GL_TRUE				= 1,

	/* Data types */
	GL_BYTE				= 0x1400,
	GL_UNSIGNED_BYTE		= 0x1401,
	GL_SHORT			= 0x1402,
	GL_UNSIGNED_SHORT		= 0x1403,
	GL_INT				= 0x1404,
	GL_UNSIGNED_INT			= 0x1405,
	GL_FLOAT			= 0x1406,
	GL_DOUBLE			= 0x140A,
	GL_2_BYTES			= 0x1407,
	GL_3_BYTES			= 0x1408,
	GL_4_BYTES			= 0x1409,

	/* Primitives */
	GL_LINES			= 0x0001,
	GL_POINTS			= 0x0000,
	GL_LINE_STRIP			= 0x0003,
	GL_LINE_LOOP			= 0x0002,
	GL_TRIANGLES			= 0x0004,
	GL_TRIANGLE_STRIP		= 0x0005,
	GL_TRIANGLE_FAN			= 0x0006,
	GL_QUADS			= 0x0007,
	GL_QUAD_STRIP			= 0x0008,
	GL_POLYGON			= 0x0009,
	GL_EDGE_FLAG			= 0x0B43,

	/* Vertex Arrays */
	GL_VERTEX_ARRAY			= 0x8074,
	GL_NORMAL_ARRAY			= 0x8075,
	GL_COLOR_ARRAY			= 0x8076,
	GL_INDEX_ARRAY			= 0x8077,
	GL_TEXTURE_COORD_ARRAY		= 0x8078,
	GL_EDGE_FLAG_ARRAY		= 0x8079,
	GL_VERTEX_ARRAY_SIZE		= 0x807A,
	GL_VERTEX_ARRAY_TYPE		= 0x807B,
	GL_VERTEX_ARRAY_STRIDE		= 0x807C,
	GL_NORMAL_ARRAY_TYPE		= 0x807E,
	GL_NORMAL_ARRAY_STRIDE		= 0x807F,
	GL_COLOR_ARRAY_SIZE		= 0x8081,
	GL_COLOR_ARRAY_TYPE		= 0x8082,
	GL_COLOR_ARRAY_STRIDE		= 0x8083,
	GL_INDEX_ARRAY_TYPE		= 0x8085,
	GL_INDEX_ARRAY_STRIDE		= 0x8086,
	GL_TEXTURE_COORD_ARRAY_SIZE	= 0x8088,
	GL_TEXTURE_COORD_ARRAY_TYPE	= 0x8089,
	GL_TEXTURE_COORD_ARRAY_STRIDE	= 0x808A,
	GL_EDGE_FLAG_ARRAY_STRIDE	= 0x808C,
	GL_VERTEX_ARRAY_POINTER		= 0x808E,
	GL_NORMAL_ARRAY_POINTER		= 0x808F,
	GL_COLOR_ARRAY_POINTER		= 0x8090,
	GL_INDEX_ARRAY_POINTER		= 0x8091,
	GL_TEXTURE_COORD_ARRAY_POINTER	= 0x8092,
	GL_EDGE_FLAG_ARRAY_POINTER	= 0x8093,
        GL_V2F				= 0x2A20,
	GL_V3F				= 0x2A21,
	GL_C4UB_V2F			= 0x2A22,
	GL_C4UB_V3F			= 0x2A23,
	GL_C3F_V3F			= 0x2A24,
	GL_N3F_V3F			= 0x2A25,
	GL_C4F_N3F_V3F			= 0x2A26,
	GL_T2F_V3F			= 0x2A27,
	GL_T4F_V4F			= 0x2A28,
	GL_T2F_C4UB_V3F			= 0x2A29,
	GL_T2F_C3F_V3F			= 0x2A2A,
	GL_T2F_N3F_V3F			= 0x2A2B,
	GL_T2F_C4F_N3F_V3F		= 0x2A2C,
	GL_T4F_C4F_N3F_V4F		= 0x2A2D,

	/* Matrix Mode */
	GL_MATRIX_MODE			= 0x0BA0,
	GL_MODELVIEW			= 0x1700,
	GL_PROJECTION			= 0x1701,
	GL_TEXTURE			= 0x1702,

	/* Points */
	GL_POINT_SMOOTH			= 0x0B10,
	GL_POINT_SIZE			= 0x0B11,
	GL_POINT_SIZE_GRANULARITY 	= 0x0B13,
	GL_POINT_SIZE_RANGE		= 0x0B12,

	/* Lines */
	GL_LINE_SMOOTH			= 0x0B20,
	GL_LINE_STIPPLE			= 0x0B24,
	GL_LINE_STIPPLE_PATTERN		= 0x0B25,
	GL_LINE_STIPPLE_REPEAT		= 0x0B26,
	GL_LINE_WIDTH			= 0x0B21,
	GL_LINE_WIDTH_GRANULARITY	= 0x0B23,
	GL_LINE_WIDTH_RANGE		= 0x0B22,

	/* Polygons */
	GL_POINT			= 0x1B00,
	GL_LINE				= 0x1B01,
	GL_FILL				= 0x1B02,
	GL_CCW				= 0x0901,
	GL_CW				= 0x0900,
	GL_FRONT			= 0x0404,
	GL_BACK				= 0x0405,
	GL_CULL_FACE			= 0x0B44,
	GL_CULL_FACE_MODE		= 0x0B45,
	GL_POLYGON_SMOOTH		= 0x0B41,
	GL_POLYGON_STIPPLE		= 0x0B42,
	GL_FRONT_FACE			= 0x0B46,
	GL_POLYGON_MODE			= 0x0B40,
	GL_POLYGON_OFFSET_FACTOR	= 0x8038,
	GL_POLYGON_OFFSET_UNITS		= 0x2A00,
	GL_POLYGON_OFFSET_POINT		= 0x2A01,
	GL_POLYGON_OFFSET_LINE		= 0x2A02,
	GL_POLYGON_OFFSET_FILL		= 0x8037,

	/* Display Lists */
	GL_COMPILE			= 0x1300,
	GL_COMPILE_AND_EXECUTE		= 0x1301,
	GL_LIST_BASE			= 0x0B32,
	GL_LIST_INDEX			= 0x0B33,
	GL_LIST_MODE			= 0x0B30,

	/* Depth buffer */
	GL_NEVER			= 0x0200,
	GL_LESS				= 0x0201,
	GL_GEQUAL			= 0x0206,
	GL_LEQUAL			= 0x0203,
	GL_GREATER			= 0x0204,
	GL_NOTEQUAL			= 0x0205,
	GL_EQUAL			= 0x0202,
	GL_ALWAYS			= 0x0207,
	GL_DEPTH_TEST			= 0x0B71,
	GL_DEPTH_BITS			= 0x0D56,
	GL_DEPTH_CLEAR_VALUE		= 0x0B73,
	GL_DEPTH_FUNC			= 0x0B74,
	GL_DEPTH_RANGE			= 0x0B70,
	GL_DEPTH_WRITEMASK		= 0x0B72,
	GL_DEPTH_COMPONENT		= 0x1902,

	/* Lighting */
	GL_LIGHTING			= 0x0B50,
	GL_LIGHT0			= 0x4000,
	GL_LIGHT1			= 0x4001,
	GL_LIGHT2			= 0x4002,
	GL_LIGHT3			= 0x4003,
	GL_LIGHT4			= 0x4004,
	GL_LIGHT5			= 0x4005,
	GL_LIGHT6			= 0x4006,
	GL_LIGHT7			= 0x4007,
	GL_SPOT_EXPONENT		= 0x1205,
	GL_SPOT_CUTOFF			= 0x1206,
	GL_CONSTANT_ATTENUATION		= 0x1207,
	GL_LINEAR_ATTENUATION		= 0x1208,
	GL_QUADRATIC_ATTENUATION	= 0x1209,
	GL_AMBIENT			= 0x1200,
	GL_DIFFUSE			= 0x1201,
	GL_SPECULAR			= 0x1202,
	GL_SHININESS			= 0x1601,
	GL_EMISSION			= 0x1600,
	GL_POSITION			= 0x1203,
	GL_SPOT_DIRECTION		= 0x1204,
	GL_AMBIENT_AND_DIFFUSE		= 0x1602,
	GL_COLOR_INDEXES		= 0x1603,
	GL_LIGHT_MODEL_TWO_SIDE		= 0x0B52,
	GL_LIGHT_MODEL_LOCAL_VIEWER	= 0x0B51,
	GL_LIGHT_MODEL_AMBIENT		= 0x0B53,
	GL_FRONT_AND_BACK		= 0x0408,
	GL_SHADE_MODEL			= 0x0B54,
	GL_FLAT				= 0x1D00,
	GL_SMOOTH			= 0x1D01,
	GL_COLOR_MATERIAL		= 0x0B57,
	GL_COLOR_MATERIAL_FACE		= 0x0B55,
	GL_COLOR_MATERIAL_PARAMETER	= 0x0B56,
	GL_NORMALIZE			= 0x0BA1,

	/* User clipping planes */
	GL_CLIP_PLANE0			= 0x3000,
	GL_CLIP_PLANE1			= 0x3001,
	GL_CLIP_PLANE2			= 0x3002,
	GL_CLIP_PLANE3			= 0x3003,
	GL_CLIP_PLANE4			= 0x3004,
	GL_CLIP_PLANE5			= 0x3005,

	/* Accumulation buffer */
	GL_ACCUM_RED_BITS		= 0x0D58,
	GL_ACCUM_GREEN_BITS		= 0x0D59,
	GL_ACCUM_BLUE_BITS		= 0x0D5A,
	GL_ACCUM_ALPHA_BITS		= 0x0D5B,
	GL_ACCUM_CLEAR_VALUE		= 0x0B80,
	GL_ACCUM			= 0x0100,
	GL_ADD				= 0x0104,
	GL_LOAD				= 0x0101,
	GL_MULT				= 0x0103,
	GL_RETURN			= 0x0102,

	/* Alpha testing */
	GL_ALPHA_TEST			= 0x0BC0,
	GL_ALPHA_TEST_REF		= 0x0BC2,
	GL_ALPHA_TEST_FUNC		= 0x0BC1,

	/* Blending */
	GL_BLEND			= 0x0BE2,
	GL_BLEND_SRC			= 0x0BE1,
	GL_BLEND_DST			= 0x0BE0,
	GL_ZERO				= 0,
	GL_ONE				= 1,
	GL_SRC_COLOR			= 0x0300,
	GL_ONE_MINUS_SRC_COLOR		= 0x0301,
	GL_DST_COLOR			= 0x0306,
	GL_ONE_MINUS_DST_COLOR		= 0x0307,
	GL_SRC_ALPHA			= 0x0302,
	GL_ONE_MINUS_SRC_ALPHA		= 0x0303,
	GL_DST_ALPHA			= 0x0304,
	GL_ONE_MINUS_DST_ALPHA		= 0x0305,
	GL_SRC_ALPHA_SATURATE		= 0x0308,
	GL_CONSTANT_COLOR		= 0x8001,
	GL_ONE_MINUS_CONSTANT_COLOR	= 0x8002,
	GL_CONSTANT_ALPHA		= 0x8003,
	GL_ONE_MINUS_CONSTANT_ALPHA	= 0x8004,

	/* Render Mode */
	GL_FEEDBACK			= 0x1C01,
	GL_RENDER			= 0x1C00,
	GL_SELECT			= 0x1C02,

	/* Feedback */
	GL_2D				= 0x0600,
	GL_3D				= 0x0601,
	GL_3D_COLOR			= 0x0602,
	GL_3D_COLOR_TEXTURE		= 0x0603,
	GL_4D_COLOR_TEXTURE		= 0x0604,
	GL_POINT_TOKEN			= 0x0701,
	GL_LINE_TOKEN			= 0x0702,
	GL_LINE_RESET_TOKEN		= 0x0707,
	GL_POLYGON_TOKEN		= 0x0703,
	GL_BITMAP_TOKEN			= 0x0704,
	GL_DRAW_PIXEL_TOKEN		= 0x0705,
	GL_COPY_PIXEL_TOKEN		= 0x0706,
	GL_PASS_THROUGH_TOKEN		= 0x0700,
	GL_FEEDBACK_BUFFER_POINTER	= 0x0DF0,
	GL_FEEDBACK_BUFFER_SIZE		= 0x0DF1,
	GL_FEEDBACK_BUFFER_TYPE		= 0x0DF2,


	/* Fog */
	GL_FOG				= 0x0B60,
	GL_FOG_MODE			= 0x0B65,
	GL_FOG_DENSITY			= 0x0B62,
	GL_FOG_COLOR			= 0x0B66,
	GL_FOG_INDEX			= 0x0B61,
	GL_FOG_START			= 0x0B63,
	GL_FOG_END			= 0x0B64,
	GL_LINEAR			= 0x2601,
	GL_EXP				= 0x0800,
	GL_EXP2				= 0x0801,

	/* Logic Ops */
	GL_LOGIC_OP			= 0x0BF1,
	GL_INDEX_LOGIC_OP		= 0x0BF1,
	GL_COLOR_LOGIC_OP		= 0x0BF2,
	GL_LOGIC_OP_MODE		= 0x0BF0,
	GL_CLEAR			= 0x1500,
	GL_SET				= 0x150F,
	GL_COPY				= 0x1503,
	GL_COPY_INVERTED		= 0x150C,
	GL_NOOP				= 0x1505,
	GL_INVERT			= 0x150A,
	GL_AND				= 0x1501,
	GL_NAND				= 0x150E,
	GL_OR				= 0x1507,
	GL_NOR				= 0x1508,
	GL_XOR				= 0x1506,
	GL_EQUIV			= 0x1509,
	GL_AND_REVERSE			= 0x1502,
	GL_AND_INVERTED			= 0x1504,
	GL_OR_REVERSE			= 0x150B,
	GL_OR_INVERTED			= 0x150D,

	/* Stencil */
	GL_STENCIL_TEST			= 0x0B90,
	GL_STENCIL_WRITEMASK		= 0x0B98,
	GL_STENCIL_BITS			= 0x0D57,
	GL_STENCIL_FUNC			= 0x0B92,
	GL_STENCIL_VALUE_MASK		= 0x0B93,
	GL_STENCIL_REF			= 0x0B97,
	GL_STENCIL_FAIL			= 0x0B94,
	GL_STENCIL_PASS_DEPTH_PASS	= 0x0B96,
	GL_STENCIL_PASS_DEPTH_FAIL	= 0x0B95,
	GL_STENCIL_CLEAR_VALUE		= 0x0B91,
	GL_STENCIL_INDEX		= 0x1901,
	GL_KEEP				= 0x1E00,
	GL_REPLACE			= 0x1E01,
	GL_INCR				= 0x1E02,
	GL_DECR				= 0x1E03,

	/* Buffers, Pixel Drawing/Reading */
	GL_NONE				= 0,
	GL_LEFT				= 0x0406,
	GL_RIGHT			= 0x0407,
	/*GL_FRONT			= 0x0404, */
	/*GL_BACK			= 0x0405, */
	/*GL_FRONT_AND_BACK		= 0x0408, */
	GL_FRONT_LEFT			= 0x0400,
	GL_FRONT_RIGHT			= 0x0401,
	GL_BACK_LEFT			= 0x0402,
	GL_BACK_RIGHT			= 0x0403,
	GL_AUX0				= 0x0409,
	GL_AUX1				= 0x040A,
	GL_AUX2				= 0x040B,
	GL_AUX3				= 0x040C,
	GL_COLOR_INDEX			= 0x1900,
	GL_RED				= 0x1903,
	GL_GREEN			= 0x1904,
	GL_BLUE				= 0x1905,
	GL_ALPHA			= 0x1906,
	GL_LUMINANCE			= 0x1909,
	GL_LUMINANCE_ALPHA		= 0x190A,
	GL_ALPHA_BITS			= 0x0D55,
	GL_RED_BITS			= 0x0D52,
	GL_GREEN_BITS			= 0x0D53,
	GL_BLUE_BITS			= 0x0D54,
	GL_INDEX_BITS			= 0x0D51,
	GL_SUBPIXEL_BITS		= 0x0D50,
	GL_AUX_BUFFERS			= 0x0C00,
	GL_READ_BUFFER			= 0x0C02,
	GL_DRAW_BUFFER			= 0x0C01,
	GL_DOUBLEBUFFER			= 0x0C32,
	GL_STEREO			= 0x0C33,
	GL_BITMAP			= 0x1A00,
	GL_COLOR			= 0x1800,
	GL_DEPTH			= 0x1801,
	GL_STENCIL			= 0x1802,
	GL_DITHER			= 0x0BD0,
	GL_RGB				= 0x1907,
	GL_RGBA				= 0x1908,

	/* Implementation limits */
	GL_MAX_LIST_NESTING		= 0x0B31,
	GL_MAX_ATTRIB_STACK_DEPTH	= 0x0D35,
	GL_MAX_MODELVIEW_STACK_DEPTH	= 0x0D36,
	GL_MAX_NAME_STACK_DEPTH		= 0x0D37,
	GL_MAX_PROJECTION_STACK_DEPTH	= 0x0D38,
	GL_MAX_TEXTURE_STACK_DEPTH	= 0x0D39,
	GL_MAX_EVAL_ORDER		= 0x0D30,
	GL_MAX_LIGHTS			= 0x0D31,
	GL_MAX_CLIP_PLANES		= 0x0D32,
	GL_MAX_TEXTURE_SIZE		= 0x0D33,
	GL_MAX_PIXEL_MAP_TABLE		= 0x0D34,
	GL_MAX_VIEWPORT_DIMS		= 0x0D3A,
	GL_MAX_CLIENT_ATTRIB_STACK_DEPTH= 0x0D3B,

	/* Gets */
	GL_ATTRIB_STACK_DEPTH		= 0x0BB0,
	GL_CLIENT_ATTRIB_STACK_DEPTH	= 0x0BB1,
	GL_COLOR_CLEAR_VALUE		= 0x0C22,
	GL_COLOR_WRITEMASK		= 0x0C23,
	GL_CURRENT_INDEX		= 0x0B01,
	GL_CURRENT_COLOR		= 0x0B00,
	GL_CURRENT_NORMAL		= 0x0B02,
	GL_CURRENT_RASTER_COLOR		= 0x0B04,
	GL_CURRENT_RASTER_DISTANCE	= 0x0B09,
	GL_CURRENT_RASTER_INDEX		= 0x0B05,
	GL_CURRENT_RASTER_POSITION	= 0x0B07,
	GL_CURRENT_RASTER_TEXTURE_COORDS = 0x0B06,
	GL_CURRENT_RASTER_POSITION_VALID = 0x0B08,
	GL_CURRENT_TEXTURE_COORDS	= 0x0B03,
	GL_INDEX_CLEAR_VALUE		= 0x0C20,
	GL_INDEX_MODE			= 0x0C30,
	GL_INDEX_WRITEMASK		= 0x0C21,
	GL_MODELVIEW_MATRIX		= 0x0BA6,
	GL_MODELVIEW_STACK_DEPTH	= 0x0BA3,
	GL_NAME_STACK_DEPTH		= 0x0D70,
	GL_PROJECTION_MATRIX		= 0x0BA7,
	GL_PROJECTION_STACK_DEPTH	= 0x0BA4,
	GL_RENDER_MODE			= 0x0C40,
	GL_RGBA_MODE			= 0x0C31,
	GL_TEXTURE_MATRIX		= 0x0BA8,
	GL_TEXTURE_STACK_DEPTH		= 0x0BA5,
	GL_VIEWPORT			= 0x0BA2,


	/* Evaluators */
	GL_AUTO_NORMAL			= 0x0D80,
	GL_MAP1_COLOR_4			= 0x0D90,
	GL_MAP1_GRID_DOMAIN		= 0x0DD0,
	GL_MAP1_GRID_SEGMENTS		= 0x0DD1,
	GL_MAP1_INDEX			= 0x0D91,
	GL_MAP1_NORMAL			= 0x0D92,
	GL_MAP1_TEXTURE_COORD_1		= 0x0D93,
	GL_MAP1_TEXTURE_COORD_2		= 0x0D94,
	GL_MAP1_TEXTURE_COORD_3		= 0x0D95,
	GL_MAP1_TEXTURE_COORD_4		= 0x0D96,
	GL_MAP1_VERTEX_3		= 0x0D97,
	GL_MAP1_VERTEX_4		= 0x0D98,
	GL_MAP2_COLOR_4			= 0x0DB0,
	GL_MAP2_GRID_DOMAIN		= 0x0DD2,
	GL_MAP2_GRID_SEGMENTS		= 0x0DD3,
	GL_MAP2_INDEX			= 0x0DB1,
	GL_MAP2_NORMAL			= 0x0DB2,
	GL_MAP2_TEXTURE_COORD_1		= 0x0DB3,
	GL_MAP2_TEXTURE_COORD_2		= 0x0DB4,
	GL_MAP2_TEXTURE_COORD_3		= 0x0DB5,
	GL_MAP2_TEXTURE_COORD_4		= 0x0DB6,
	GL_MAP2_VERTEX_3		= 0x0DB7,
	GL_MAP2_VERTEX_4		= 0x0DB8,
	GL_COEFF			= 0x0A00,
	GL_DOMAIN			= 0x0A02,
	GL_ORDER			= 0x0A01,

	/* Hints */
	GL_FOG_HINT			= 0x0C54,
	GL_LINE_SMOOTH_HINT		= 0x0C52,
	GL_PERSPECTIVE_CORRECTION_HINT	= 0x0C50,
	GL_POINT_SMOOTH_HINT		= 0x0C51,
	GL_POLYGON_SMOOTH_HINT		= 0x0C53,
	GL_DONT_CARE			= 0x1100,
	GL_FASTEST			= 0x1101,
	GL_NICEST			= 0x1102,

	/* Scissor box */
	GL_SCISSOR_TEST			= 0x0C11,
	GL_SCISSOR_BOX			= 0x0C10,

	/* Pixel Mode / Transfer */
	GL_MAP_COLOR			= 0x0D10,
	GL_MAP_STENCIL			= 0x0D11,
	GL_INDEX_SHIFT			= 0x0D12,
	GL_INDEX_OFFSET			= 0x0D13,
	GL_RED_SCALE			= 0x0D14,
	GL_RED_BIAS			= 0x0D15,
	GL_GREEN_SCALE			= 0x0D18,
	GL_GREEN_BIAS			= 0x0D19,
	GL_BLUE_SCALE			= 0x0D1A,
	GL_BLUE_BIAS			= 0x0D1B,
	GL_ALPHA_SCALE			= 0x0D1C,
	GL_ALPHA_BIAS			= 0x0D1D,
	GL_DEPTH_SCALE			= 0x0D1E,
	GL_DEPTH_BIAS			= 0x0D1F,
	GL_PIXEL_MAP_S_TO_S_SIZE	= 0x0CB1,
	GL_PIXEL_MAP_I_TO_I_SIZE	= 0x0CB0,
	GL_PIXEL_MAP_I_TO_R_SIZE	= 0x0CB2,
	GL_PIXEL_MAP_I_TO_G_SIZE	= 0x0CB3,
	GL_PIXEL_MAP_I_TO_B_SIZE	= 0x0CB4,
	GL_PIXEL_MAP_I_TO_A_SIZE	= 0x0CB5,
	GL_PIXEL_MAP_R_TO_R_SIZE	= 0x0CB6,
	GL_PIXEL_MAP_G_TO_G_SIZE	= 0x0CB7,
	GL_PIXEL_MAP_B_TO_B_SIZE	= 0x0CB8,
	GL_PIXEL_MAP_A_TO_A_SIZE	= 0x0CB9,
	GL_PIXEL_MAP_S_TO_S		= 0x0C71,
	GL_PIXEL_MAP_I_TO_I		= 0x0C70,
	GL_PIXEL_MAP_I_TO_R		= 0x0C72,
	GL_PIXEL_MAP_I_TO_G		= 0x0C73,
	GL_PIXEL_MAP_I_TO_B		= 0x0C74,
	GL_PIXEL_MAP_I_TO_A		= 0x0C75,
	GL_PIXEL_MAP_R_TO_R		= 0x0C76,
	GL_PIXEL_MAP_G_TO_G		= 0x0C77,
	GL_PIXEL_MAP_B_TO_B		= 0x0C78,
	GL_PIXEL_MAP_A_TO_A		= 0x0C79,
	GL_PACK_ALIGNMENT		= 0x0D05,
	GL_PACK_LSB_FIRST		= 0x0D01,
	GL_PACK_ROW_LENGTH		= 0x0D02,
	GL_PACK_SKIP_PIXELS		= 0x0D04,
	GL_PACK_SKIP_ROWS		= 0x0D03,
	GL_PACK_SWAP_BYTES		= 0x0D00,
	GL_UNPACK_ALIGNMENT		= 0x0CF5,
	GL_UNPACK_LSB_FIRST		= 0x0CF1,
	GL_UNPACK_ROW_LENGTH		= 0x0CF2,
	GL_UNPACK_SKIP_PIXELS		= 0x0CF4,
	GL_UNPACK_SKIP_ROWS		= 0x0CF3,
	GL_UNPACK_SWAP_BYTES		= 0x0CF0,
	GL_ZOOM_X			= 0x0D16,
	GL_ZOOM_Y			= 0x0D17,

	/* Texture mapping */
	GL_TEXTURE_ENV			= 0x2300,
	GL_TEXTURE_ENV_MODE		= 0x2200,
	GL_TEXTURE_1D			= 0x0DE0,
	GL_TEXTURE_2D			= 0x0DE1,
	GL_TEXTURE_WRAP_S		= 0x2802,
	GL_TEXTURE_WRAP_T		= 0x2803,
	GL_TEXTURE_MAG_FILTER		= 0x2800,
	GL_TEXTURE_MIN_FILTER		= 0x2801,
	GL_TEXTURE_ENV_COLOR		= 0x2201,
	GL_TEXTURE_GEN_S		= 0x0C60,
	GL_TEXTURE_GEN_T		= 0x0C61,
	GL_TEXTURE_GEN_MODE		= 0x2500,
	GL_TEXTURE_BORDER_COLOR		= 0x1004,
	GL_TEXTURE_WIDTH		= 0x1000,
	GL_TEXTURE_HEIGHT		= 0x1001,
	GL_TEXTURE_BORDER		= 0x1005,
	GL_TEXTURE_COMPONENTS		= 0x1003,
	GL_TEXTURE_RED_SIZE		= 0x805C,
	GL_TEXTURE_GREEN_SIZE		= 0x805D,
	GL_TEXTURE_BLUE_SIZE		= 0x805E,
	GL_TEXTURE_ALPHA_SIZE		= 0x805F,
	GL_TEXTURE_LUMINANCE_SIZE	= 0x8060,
	GL_TEXTURE_INTENSITY_SIZE	= 0x8061,
	GL_NEAREST_MIPMAP_NEAREST	= 0x2700,
	GL_NEAREST_MIPMAP_LINEAR	= 0x2702,
	GL_LINEAR_MIPMAP_NEAREST	= 0x2701,
	GL_LINEAR_MIPMAP_LINEAR		= 0x2703,
	GL_OBJECT_LINEAR		= 0x2401,
	GL_OBJECT_PLANE			= 0x2501,
	GL_EYE_LINEAR			= 0x2400,
	GL_EYE_PLANE			= 0x2502,
	GL_SPHERE_MAP			= 0x2402,
	GL_DECAL			= 0x2101,
	GL_MODULATE			= 0x2100,
	GL_NEAREST			= 0x2600,
	GL_REPEAT			= 0x2901,
	GL_CLAMP			= 0x2900,
	GL_S				= 0x2000,
	GL_T				= 0x2001,
	GL_R				= 0x2002,
	GL_Q				= 0x2003,
	GL_TEXTURE_GEN_R		= 0x0C62,
	GL_TEXTURE_GEN_Q		= 0x0C63,

	GL_PROXY_TEXTURE_1D		= 0x8063,
	GL_PROXY_TEXTURE_2D		= 0x8064,
	GL_TEXTURE_PRIORITY		= 0x8066,
	GL_TEXTURE_RESIDENT		= 0x8067,
	GL_TEXTURE_BINDING_1D		= 0x8068,
	GL_TEXTURE_BINDING_2D		= 0x8069,

	/* Internal texture formats */
	GL_ALPHA4			= 0x803B,
	GL_ALPHA8			= 0x803C,
	GL_ALPHA12			= 0x803D,
	GL_ALPHA16			= 0x803E,
	GL_LUMINANCE4			= 0x803F,
	GL_LUMINANCE8			= 0x8040,
	GL_LUMINANCE12			= 0x8041,
	GL_LUMINANCE16			= 0x8042,
	GL_LUMINANCE4_ALPHA4		= 0x8043,
	GL_LUMINANCE6_ALPHA2		= 0x8044,
	GL_LUMINANCE8_ALPHA8		= 0x8045,
	GL_LUMINANCE12_ALPHA4		= 0x8046,
	GL_LUMINANCE12_ALPHA12		= 0x8047,
	GL_LUMINANCE16_ALPHA16		= 0x8048,
	GL_INTENSITY			= 0x8049,
	GL_INTENSITY4			= 0x804A,
	GL_INTENSITY8			= 0x804B,
	GL_INTENSITY12			= 0x804C,
	GL_INTENSITY16			= 0x804D,
	GL_R3_G3_B2			= 0x2A10,
	GL_RGB4				= 0x804F,
	GL_RGB5				= 0x8050,
	GL_RGB8				= 0x8051,
	GL_RGB10			= 0x8052,
	GL_RGB12			= 0x8053,
	GL_RGB16			= 0x8054,
	GL_RGBA2			= 0x8055,
	GL_RGBA4			= 0x8056,
	GL_RGB5_A1			= 0x8057,
	GL_RGBA8			= 0x8058,
	GL_RGB10_A2			= 0x8059,
	GL_RGBA12			= 0x805A,
	GL_RGBA16			= 0x805B,

	/* Utility */
	GL_VENDOR			= 0x1F00,
	GL_RENDERER			= 0x1F01,
	GL_VERSION			= 0x1F02,
	GL_EXTENSIONS			= 0x1F03,

	/* Errors */
	GL_INVALID_VALUE		= 0x0501,
	GL_INVALID_ENUM			= 0x0500,
	GL_INVALID_OPERATION		= 0x0502,
	GL_STACK_OVERFLOW		= 0x0503,
	GL_STACK_UNDERFLOW		= 0x0504,
	GL_OUT_OF_MEMORY		= 0x0505,

	/*
	 * 1.0 Extensions
	 */
        /* GL_EXT_blend_minmax and GL_EXT_blend_color */
	GL_CONSTANT_COLOR_EXT		= 0x8001,
	GL_ONE_MINUS_CONSTANT_COLOR_EXT	= 0x8002,
	GL_CONSTANT_ALPHA_EXT		= 0x8003,
	GL_ONE_MINUS_CONSTANT_ALPHA_EXT	= 0x8004,
	GL_BLEND_EQUATION_EXT		= 0x8009,
	GL_MIN_EXT			= 0x8007,
	GL_MAX_EXT			= 0x8008,
	GL_FUNC_ADD_EXT			= 0x8006,
	GL_FUNC_SUBTRACT_EXT		= 0x800A,
	GL_FUNC_REVERSE_SUBTRACT_EXT	= 0x800B,
	GL_BLEND_COLOR_EXT		= 0x8005,

	/* GL_EXT_polygon_offset */
        GL_POLYGON_OFFSET_EXT           = 0x8037,
        GL_POLYGON_OFFSET_FACTOR_EXT    = 0x8038,
        GL_POLYGON_OFFSET_BIAS_EXT      = 0x8039,

	/* GL_EXT_vertex_array */
	GL_VERTEX_ARRAY_EXT			= 0x8074,
	GL_NORMAL_ARRAY_EXT			= 0x8075,
	GL_COLOR_ARRAY_EXT			= 0x8076,
	GL_INDEX_ARRAY_EXT			= 0x8077,
	GL_TEXTURE_COORD_ARRAY_EXT		= 0x8078,
	GL_EDGE_FLAG_ARRAY_EXT			= 0x8079,
	GL_VERTEX_ARRAY_SIZE_EXT		= 0x807A,
	GL_VERTEX_ARRAY_TYPE_EXT		= 0x807B,
	GL_VERTEX_ARRAY_STRIDE_EXT		= 0x807C,
	GL_VERTEX_ARRAY_COUNT_EXT		= 0x807D,
	GL_NORMAL_ARRAY_TYPE_EXT		= 0x807E,
	GL_NORMAL_ARRAY_STRIDE_EXT		= 0x807F,
	GL_NORMAL_ARRAY_COUNT_EXT		= 0x8080,
	GL_COLOR_ARRAY_SIZE_EXT			= 0x8081,
	GL_COLOR_ARRAY_TYPE_EXT			= 0x8082,
	GL_COLOR_ARRAY_STRIDE_EXT		= 0x8083,
	GL_COLOR_ARRAY_COUNT_EXT		= 0x8084,
	GL_INDEX_ARRAY_TYPE_EXT			= 0x8085,
	GL_INDEX_ARRAY_STRIDE_EXT		= 0x8086,
	GL_INDEX_ARRAY_COUNT_EXT		= 0x8087,
	GL_TEXTURE_COORD_ARRAY_SIZE_EXT		= 0x8088,
	GL_TEXTURE_COORD_ARRAY_TYPE_EXT		= 0x8089,
	GL_TEXTURE_COORD_ARRAY_STRIDE_EXT	= 0x808A,
	GL_TEXTURE_COORD_ARRAY_COUNT_EXT	= 0x808B,
	GL_EDGE_FLAG_ARRAY_STRIDE_EXT		= 0x808C,
	GL_EDGE_FLAG_ARRAY_COUNT_EXT		= 0x808D,
	GL_VERTEX_ARRAY_POINTER_EXT		= 0x808E,
	GL_NORMAL_ARRAY_POINTER_EXT		= 0x808F,
	GL_COLOR_ARRAY_POINTER_EXT		= 0x8090,
	GL_INDEX_ARRAY_POINTER_EXT		= 0x8091,
	GL_TEXTURE_COORD_ARRAY_POINTER_EXT	= 0x8092,
	GL_EDGE_FLAG_ARRAY_POINTER_EXT		= 0x8093,

	/* GL_EXT_texture_object */
	GL_TEXTURE_PRIORITY_EXT		= 0x8066,
	GL_TEXTURE_RESIDENT_EXT		= 0x8067,
	GL_TEXTURE_1D_BINDING_EXT	= 0x8068,
	GL_TEXTURE_2D_BINDING_EXT	= 0x8069,

	/* GL_EXT_texture3D */
	GL_PACK_SKIP_IMAGES_EXT		= 0x806B,
	GL_PACK_IMAGE_HEIGHT_EXT	= 0x806C,
	GL_UNPACK_SKIP_IMAGES_EXT	= 0x806D,
	GL_UNPACK_IMAGE_HEIGHT_EXT	= 0x806E,
	GL_TEXTURE_3D_EXT		= 0x806F,
	GL_PROXY_TEXTURE_3D_EXT		= 0x8070,
	GL_TEXTURE_DEPTH_EXT		= 0x8071,
	GL_TEXTURE_WRAP_R_EXT		= 0x8072,
	GL_MAX_3D_TEXTURE_SIZE_EXT	= 0x8073,
	GL_TEXTURE_3D_BINDING_EXT	= 0x806A,

        /* GL_EXT_paletted_texture */
	GL_TABLE_TOO_LARGE_EXT			= 0x8031,
	GL_COLOR_TABLE_FORMAT_EXT		= 0x80D8,
	GL_COLOR_TABLE_WIDTH_EXT		= 0x80D9,
	GL_COLOR_TABLE_RED_SIZE_EXT		= 0x80DA,
	GL_COLOR_TABLE_GREEN_SIZE_EXT		= 0x80DB,
	GL_COLOR_TABLE_BLUE_SIZE_EXT		= 0x80DC,
	GL_COLOR_TABLE_ALPHA_SIZE_EXT	 	= 0x80DD,
	GL_COLOR_TABLE_LUMINANCE_SIZE_EXT	= 0x80DE,
	GL_COLOR_TABLE_INTENSITY_SIZE_EXT	= 0x80DF,
	GL_TEXTURE_INDEX_SIZE_EXT		= 0x80E1, /*XXX right value??*/
	GL_COLOR_INDEX1_EXT			= 0x80E2,
	GL_COLOR_INDEX2_EXT			= 0x80E3,
	GL_COLOR_INDEX4_EXT			= 0x80E4,
	GL_COLOR_INDEX8_EXT			= 0x80E5,
	GL_COLOR_INDEX12_EXT			= 0x80E6,
	GL_COLOR_INDEX16_EXT			= 0x80E7,

	/* GL_EXT_shared_texture_palette */
	GL_SHARED_TEXTURE_PALETTE_EXT		= 0x81FB,

#if 0
	/* GL_SGIS_texture_lod */
	GL_TEXTURE_MIN_LOD_SGIS			= 0x813A,
	GL_TEXTURE_MAX_LOD_SGIS			= 0x813B,
	GL_TEXTURE_BASE_LEVEL_SGIS		= 0x813C,
	GL_TEXTURE_MAX_LEVEL_SGIS		= 0x813D,
#endif

	/* GL_EXT_point_parameters */
	GL_POINT_SIZE_MIN_EXT			= 0x8126,
	GL_POINT_SIZE_MAX_EXT			= 0x8127,
	GL_POINT_FADE_THRESHOLD_SIZE_EXT	= 0x8128,
	GL_DISTANCE_ATTENUATION_EXT		= 0x8129
}gl_enum;
enum {
	GL_CURRENT_BIT		= 0x00000001,
	GL_POINT_BIT		= 0x00000002,
	GL_LINE_BIT		= 0x00000004,
	GL_POLYGON_BIT		= 0x00000008,
	GL_POLYGON_STIPPLE_BIT	= 0x00000010,
	GL_PIXEL_MODE_BIT	= 0x00000020,
	GL_LIGHTING_BIT		= 0x00000040,
	GL_FOG_BIT		= 0x00000080,
	GL_DEPTH_BUFFER_BIT	= 0x00000100,
	GL_ACCUM_BUFFER_BIT	= 0x00000200,
	GL_STENCIL_BUFFER_BIT	= 0x00000400,
	GL_VIEWPORT_BIT		= 0x00000800,
	GL_TRANSFORM_BIT	= 0x00001000,
	GL_ENABLE_BIT		= 0x00002000,
	GL_COLOR_BUFFER_BIT	= 0x00004000,
	GL_HINT_BIT		= 0x00008000,
	GL_EVAL_BIT		= 0x00010000,
	GL_LIST_BIT		= 0x00020000,
	GL_TEXTURE_BIT		= 0x00040000,
	GL_SCISSOR_BIT		= 0x00080000,
	GL_ALL_ATTRIB_BITS	= 0x000fffff
};
enum {
	GL_CLIENT_PIXEL_STORE_BIT	= 0x00000001,
	GL_CLIENT_VERTEX_ARRAY_BIT	= 0x00000002,
	GL_CLIENT_ALL_ATTRIB_BITS	= 0x0000FFFF
};
typedef int GLenum;
#  define MAX_WIDTH 640
#  define MAX_HEIGHT 400
typedef unsigned int GLbitfield;
typedef void		GLvoid;
typedef unsigned char	GLboolean;
typedef signed char	GLbyte;		
typedef short		GLshort;	
typedef int		GLint;		
typedef unsigned char	GLubyte;	
typedef unsigned short	GLushort;	
typedef unsigned int	GLuint;		
typedef int		GLsizei;	
//typedef float		float;	
typedef float		GLclampf;	
typedef double		GLdouble;	
typedef double		GLclampd;
typedef struct gl_visual GLvisual;
typedef struct gl_context GLcontext;
typedef struct gl_frame_buffer GLframebuffer;
struct osmesa_context {
GLcontext *gl_ctx;		
GLvisual *gl_visual;		
GLframebuffer *gl_buffer;	
GLenum format;		
void *buffer;		
GLint width, height;		
GLuint pixel;		
GLuint clearpixel;		
GLint rowlength;		
GLint userRowLength;		
GLint rshift, gshift;	
GLint bshift, ashift;
GLint rind, gind, bind;	
void *rowaddr[MAX_HEIGHT];	
GLboolean yup;						
};
typedef struct osmesa_context *OSMesaContext;

typedef void (*points_func)( GLcontext *ctx, GLuint first, GLuint last );
typedef void (*line_func)( GLcontext *ctx, GLuint v1, GLuint v2, GLuint pv );
typedef void (*triangle_func)( GLcontext *ctx,
GLuint v1, GLuint v2, GLuint v3, GLuint pv );
typedef void (*quad_func)( GLcontext *ctx, GLuint v1, GLuint v2,
GLuint v3, GLuint v4, GLuint pv );
typedef void (*rect_func)( GLcontext *ctx, GLint x, GLint y,
GLint width, GLint height );
struct gl_texture_object;
typedef void (*TextureSampleFunc)( const struct gl_texture_object *tObj,
GLuint n,
const float s[], const float t[],
const float u[], const float lambda[],
GLubyte r[], GLubyte g[],
GLubyte b[],GLubyte a[] );
struct gl_image {
	GLint Width;
	GLint Height;
	GLint Depth;		
	GLint Components;	
GLenum Format;		
	GLenum Type;		
	GLvoid *Data;
	GLboolean Interleaved;
	GLint RefCount;
};
struct gl_texture_image {
	GLenum Format;		
	GLenum IntFormat;	
	GLuint Border;		
	GLuint Width;		
	GLuint Height;		
	GLuint Depth;		
	GLuint Width2;		
	GLuint Height2;		
	GLuint Depth2;		
	GLuint WidthLog2;	
	GLuint HeightLog2;	
	GLuint DepthLog2;	
	GLuint MaxLog2;		
	GLubyte *Data;		
	
	void *DriverData;	
};
typedef GLbyte GLaccum;
typedef GLubyte GLstencil;
typedef GLushort GLdepth;
#if defined(__BEOS__) || defined(__QUICKDRAW__)
#endif

#if defined(__BEOS__) || defined(__QUICKDRAW__)
#endif

#endif
/* 当前文件是D:\Read\macros.h*/

#ifndef MACROS_H
#define MACROS_H
#ifdef DEBUG
#  include <assert.h>
#  define ASSERT(X)   assert(X)
#else
#  define ASSERT(X)
#endif
#define MAX_GLUSHORT	0xffff
#define MAX_GLUINT	0xffffffff
#define COPY_2V( DST, SRC )	DST[0] = SRC[0];	\
				DST[1] = SRC[1];
#define COPY_3V( DST, SRC )	DST[0] = SRC[0];	\
				DST[1] = SRC[1];	\
				DST[2] = SRC[2];
#define COPY_4V( DST, SRC )	DST[0] = SRC[0];	\
				DST[1] = SRC[1];	\
				DST[2] = SRC[2];	\
				DST[3] = SRC[3];
#define COPY_4UBV(DST, SRC)			\
if (sizeof(GLuint)==4*sizeof(GLubyte)) {	\
*((GLuint*)(DST)) = *((GLuint*)(SRC));	\
}						\
else {					\
(DST)[0] = (SRC)[0];			\
(DST)[1] = (SRC)[1];			\
(DST)[2] = (SRC)[2];			\
(DST)[3] = (SRC)[3];			\
}
#define ASSIGN_2V( V, V0, V1 )  V[0] = V0;  V[1] = V1;
#define ASSIGN_3V( V, V0, V1, V2 )  V[0] = V0;  V[1] = V1;  V[2] = V2;
#define ASSIGN_4V( V, V0, V1, V2, V3 )  V[0] = V0;	\
				        V[1] = V1;	\
				        V[2] = V2;	\
				        V[3] = V3;
#define INSIDE_BEGIN_END(CTX)  ((CTX)->Primitive!=GL_BITMAP)
#define ABSI(X)  ((X) < 0 ? -(X) : (X))
#define ABSF(X)  ((X) < 0.0F ? -(X) : (X))
#define ABSD(X)  ((X) < 0.0 ? -(X) : (X))
#define ROUNDF(X)  ( (X)<0.0F ? ((GLint) ((X)-0.5F)) : ((GLint) ((X)+0.5F)) )
#define CEILING( A, B )  ( (A) % (B) == 0 ? (A)/(B) : (A)/(B)+1 )
#define CLAMP( X, MIN, MAX )  ( (X)<(MIN) ? (MIN) : ((X)>(MAX) ? (MAX) : (X)) )
#define MIN2( A, B )   ( (A)<(B) ? (A) : (B) )
#define MAX2( A, B )   ( (A)>(B) ? (A) : (B) )
#define DOT3( a, b )  ( a[0]*b[0] + a[1]*b[1] + a[2]*b[2] )
#define DOT4( a, b )  ( a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3] )
#define UBYTE_TO_FLOAT(B)	((float) (B) * (1.0F / 255.0F))
#define FLOAT_TO_UBYTE(X)	((GLubyte) (GLint) (((X)) * 255.0F))
#define BYTE_TO_FLOAT(B)	((2.0F * (B) + 1.0F) * (1.0F/255.0F))
#define FLOAT_TO_BYTE(X)	( (((GLint) (255.0F * (X))) - 1) / 2 )
#define USHORT_TO_FLOAT(S)	((float) (S) * (1.0F / 65535.0F))
#define FLOAT_TO_USHORT(X)	((GLushort) (GLint) ((X) * 65535.0F))
#define SHORT_TO_FLOAT(S)	((2.0F * (S) + 1.0F) * (1.0F/65535.0F))
#define FLOAT_TO_SHORT(X)	( (((GLint) (65535.0F * (X))) - 1) / 2 )
#define UINT_TO_FLOAT(U)	((float) (U) * (1.0F / 4294967295.0F))
#define FLOAT_TO_UINT(X)	((GLuint) ((X) * 4294967295.0))
#define INT_TO_FLOAT(I)		((2.0F * (I) + 1.0F) * (1.0F/4294967294.0F))
#define FLOAT_TO_INT(X)		( (GLint) (2147483647.0 * (X)) )
#ifdef SUNOS4
#define MEMCPY( DST, SRC, BYTES) \
	memcpy( (char *) (DST), (char *) (SRC), (int) (BYTES) )
#else
#define MEMCPY( DST, SRC, BYTES) \
	memcpy( (void *) (DST), (void *) (SRC), (size_t) (BYTES) )
#endif
#ifdef SUNOS4
#define MEMSET( DST, VAL, N ) \
	memset( (char *) (DST), (int) (VAL), (int) (N) )
#else
#define MEMSET( DST, VAL, N ) \
	memset( (void *) (DST), (int) (VAL), (size_t) (N) )
#endif
#if defined(macintosh) && !defined(__MRC__)


#  define DEFARRAY(TYPE,NAME,SIZE)  TYPE *NAME = (TYPE*)AGLAlloc(sizeof(TYPE)*(SIZE))
#  define UNDEFARRAY(NAME)          AGLFree((char*)NAME)
#elif defined(__BEOS__)
#  define DEFARRAY(TYPE,NAME,SIZE)  TYPE *NAME = malloc(sizeof(TYPE)*(SIZE))
#  define UNDEFARRAY(NAME)          free(NAME)
#else
#  define DEFARRAY(TYPE,NAME,SIZE)  TYPE NAME[SIZE]
#  define UNDEFARRAY(NAME)
#endif
#ifndef M_PI
#define M_PI (3.1415926)
#endif
#define DEG2RAD (M_PI/180.0)
#ifndef NULL
#define NULL 0
#endif
#endif
#define WIDTH 1280									
#define HEIGHT 1024									
static int NumRows, NumColumns;
static float *SurfaceV;
static float *SurfaceN;
static float Xmin = -10.0, Xmax = 10.0;
static float Ymin = -10.0, Ymax = 10.0;
static float Xrot = -35.0, Yrot = 40.0;
static void ReadMesh(const char *filename)
{
int i, j;
FILE *f = fopen(filename, "r");
if (!f) {
printf("Error: couldn't open input mesh file: %s\n", filename);
exit(1);
}
fscanf(f, "%d %d\n", &NumRows, &NumColumns);
if (NumRows < 2) {
printf("Error: number of mesh rows invalid\n");
exit(1);
}
if (NumColumns < 2) {
printf("Error: number of mesh columns invalid\n");
exit(1);
}
SurfaceV = (float *) malloc(NumRows * NumColumns * 3 * sizeof(float));
SurfaceN = (float *) malloc(NumRows * NumColumns * 3 * sizeof(float));
if (!SurfaceV || !SurfaceN) {
printf("Error: unable to allocate memory for mesh data\n");
exit(1);
}
for (i=0; i<NumRows; i++) {
for (j=0; j<NumColumns; j++) {
int k = (i * NumColumns + j) * 3;
float vx, vy, vz, nx, ny, nz;
fscanf(f, "%f %f %f  %f %f %f\n", &vx, &vy, &vz, &nx, &ny, &nz);
SurfaceV[k+0] = vx;
SurfaceV[k+1] = vy;
SurfaceV[k+2] = vz;
SurfaceN[k+0] = nx;
SurfaceN[k+1] = ny;
SurfaceN[k+2] = nz;
}
}
fclose(f);
}
static void DrawMesh( void )
{
int i, j;
for (i=0; i < NumRows-1; i++) {
glBegin(GL_TRIANGLE_STRIP);
for (j=0; j < NumColumns; j++) {
int k0 = ( i    * NumColumns + j) * 3;
int k1 = ((i+1) * NumColumns + j) * 3;
glNormal3fv(SurfaceN + k0);
glVertex3fv(SurfaceV + k0);
glNormal3fv(SurfaceN + k1);
glVertex3fv(SurfaceV + k1);
}
glEnd();
}
}
static void SPECWriteIntermediateImage( FILE *fip, FILE *fop, int width, int height, const void *buffer, int frame_count)
{
int i, x, y;
GLubyte *ptr = (GLubyte *) buffer;
int counter = 0;
if (fip)
	{
	  fscanf(fip, "%d %d", &x, &y);
	  y = y % height;
	  x = x % width;
	  i = (y*width + x) * 4;
	}
if (fop)
	{
	  fprintf(fop, "%d %d %d %d\n", i, ptr[i], ptr[i+1], ptr[i+2]);
	}
}
static void Render( int frames, int width, int height, const void *buffer  )
{
int i;
FILE *fip = fopen("numbers", "r");
FILE *fop = fopen("mesa.log", "w");
Yrot = -5.0F*(float)(frames-1);								
for (i=0; i<frames; i++) {
	  if (Yrot > 360.0F) {
		  while (Yrot > 360.0F) {
			  Yrot = Yrot - 360.0F;								
		  }
	  }
	  else if (Yrot < 0.0F) {									
			while (Yrot < 0.0F ) {								
				Yrot = Yrot + 360.0F;							
			}
	  }															
	  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glPushMatrix();
glRotatef(-Xrot, 1, 0, 0);
glRotatef(Yrot, 0, 1, 0);
glRotatef(-90, 1, 0, 0);
SPECWriteIntermediateImage(fip, fop, width, height, buffer, i);
DrawMesh();
glPopMatrix();
	
Yrot += 5.0F;												
}
}
static void Reshape( int width, int height )
{
float w = (float) width / (float) height;
glViewport( 0, 0, width, height );
glMatrixMode( GL_PROJECTION );
glLoadIdentity();
glFrustum( -w*1.1, w*1.1, -1.1, 1.1, 5.0, 100.0 );	
glMatrixMode( GL_MODELVIEW );
glLoadIdentity();
glTranslatef( 0.0, 0.0, -60.0 );
}
static void Init( void )
{
GLint i;
GLubyte texture[256];
static float texPlane[4] = {0.0, 0.0, 0.1, 0.0};
static float blue[4] = {0.2, 0.2, 1.0, 1.0};
static float white[4] = {1.0, 1.0, 1.0, 1.0};
static float posred[4] =    {0.0, 2.0, 5.0, 0.0};			
static float posgreen[4] =  {0.0, 2.5, 5.0, 0.0};			
static float posblue[4] =   {0.0, 2.0, 6.0, 0.0};			
static float grayred[4] =   {0.43F, 0.125F, 0.0625F, 1.0F};
static float graygreen[4] = {0.0625F, 0.45F, 0.125F, 1.0F};
static float grayblue[4] =  {0.125F, 0.0625F, 0.47F, 1.0F};
glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);
glEnable(GL_LIGHT1);											
glEnable(GL_LIGHT2);											
glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, blue);
glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, white);
glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 15.0);
glLightfv(GL_LIGHT0, GL_POSITION, posred);					
glLightfv(GL_LIGHT0, GL_DIFFUSE, grayred);					
glLightfv(GL_LIGHT0, GL_SPECULAR, grayred);			
glLightfv(GL_LIGHT1, GL_POSITION, posgreen);					
glLightfv(GL_LIGHT1, GL_DIFFUSE, graygreen);					
glLightfv(GL_LIGHT1, GL_SPECULAR, graygreen);		
glLightfv(GL_LIGHT2, GL_POSITION, posblue);					
glLightfv(GL_LIGHT2, GL_DIFFUSE, grayblue);					
glLightfv(GL_LIGHT2, GL_SPECULAR, grayblue);			
glEnable(GL_DEPTH_TEST);
for (i=0; i<256; i++) {
if ((i % 16) < 1) {
texture[i] = 0;
}
else {
texture[i] = 255;
}
}
glTexImage1D(GL_TEXTURE_1D, 0, 1, 256, 0,
GL_LUMINANCE, GL_UNSIGNED_BYTE, texture);
glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glEnable(GL_TEXTURE_1D);
glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
glTexGenfv(GL_S, GL_OBJECT_PLANE, texPlane);
glEnable(GL_TEXTURE_GEN_S);
Reshape(WIDTH, HEIGHT);
}
static void WriteImage( const char *filename, int width, int height,
const void *buffer )
{
FILE *f = fopen( filename, "w" );
if (f) {
int i, x, y;
GLubyte *ptr = (GLubyte *) buffer;
int counter = 0;
fprintf(f, "P3\n");
fprintf(f, "# ascii ppm file created by %s\n", "SPEC mesa177");
fprintf(f, "%i %i\n", width, height);
fprintf(f, "255\n");
for (y=HEIGHT-1; y>=0; y--) {
for (x=0; x<WIDTH; x++) {
i = (y*WIDTH + x) * 4;
fprintf(f, " %d %d %d", ptr[i], ptr[i+1], ptr[i+2]);
counter++;
if (counter % 5 == 0)
fprintf(f, "\n");
}
}
fclose(f);
}
}
#define FRONT_AMBIENT_BIT     0x1
#define BACK_AMBIENT_BIT      0x2
#define FRONT_DIFFUSE_BIT     0x4
#define BACK_DIFFUSE_BIT      0x8
#define FRONT_SPECULAR_BIT   0x10
#define BACK_SPECULAR_BIT    0x20
#define FRONT_EMISSION_BIT   0x40
#define BACK_EMISSION_BIT    0x80
#define FRONT_SHININESS_BIT 0x100
#define BACK_SHININESS_BIT  0x200
#define FRONT_INDEXES_BIT   0x400
#define BACK_INDEXES_BIT    0x800
#define FRONT_MATERIAL_BITS	(FRONT_EMISSION_BIT | FRONT_AMBIENT_BIT | \
				 FRONT_DIFFUSE_BIT | FRONT_SPECULAR_BIT | \
				 FRONT_SHININESS_BIT | FRONT_INDEXES_BIT)
#define BACK_MATERIAL_BITS	(BACK_EMISSION_BIT | BACK_AMBIENT_BIT | \
				 BACK_DIFFUSE_BIT | BACK_SPECULAR_BIT | \
				 BACK_SHININESS_BIT | BACK_INDEXES_BIT)
#define ALL_MATERIAL_BITS	(FRONT_MATERIAL_BITS | BACK_MATERIAL_BITS)
#define EXP_TABLE_SIZE 512
#define SHINE_TABLE_SIZE 200

#define CLIP_FCOLOR_BIT		0x01
#define CLIP_BCOLOR_BIT		0x02
#define CLIP_FINDEX_BIT		0x04
#define CLIP_BINDEX_BIT		0x08
#define CLIP_TEXTURE_BIT	0x10
#define ALPHATEST_BIT		0x001	
#define BLEND_BIT		0x002	
#define DEPTH_BIT		0x004	
#define FOG_BIT			0x008	
#define LOGIC_OP_BIT		0x010	
#define SCISSOR_BIT		0x020	
#define STENCIL_BIT		0x040	
#define MASKING_BIT		0x080	
#define ALPHABUF_BIT		0x100	
#define WINCLIP_BIT		0x200	
#define FRONT_AND_BACK_BIT	0x400	
#define NO_DRAW_BIT		0x800	
#define NEW_LIGHTING	0x1
#define NEW_RASTER_OPS	0x2
#define NEW_TEXTURING	0x4
#define NEW_POLYGON	0x8
#define NEW_ALL		0xf
#define MATRIX_GENERAL		0	
#define MATRIX_IDENTITY		1	
#define MATRIX_ORTHO		2	
#define MATRIX_PERSPECTIVE	3	
#define MATRIX_2D		4	
#define MATRIX_2D_NO_ROT	5	
#define MATRIX_3D		6	
#ifndef CONFIG_H
#define CONFIG_H
#define MAX_MODELVIEW_STACK_DEPTH 32
#define MAX_PROJECTION_STACK_DEPTH 32
#define MAX_TEXTURE_STACK_DEPTH 10
#define MAX_ATTRIB_STACK_DEPTH 16
#define MAX_CLIENT_ATTRIB_STACK_DEPTH 16
#define MAX_LIST_NESTING 64
#define MAX_LIGHTS 8
#define MAX_CLIP_PLANES 6
#ifdef FX
#define MAX_TEXTURE_LEVELS 9
#else
#define MAX_TEXTURE_LEVELS 11
#endif
#define MAX_TEXTURE_SIZE   (1 << (MAX_TEXTURE_LEVELS-1))
#define MAX_PIXEL_MAP_TABLE 256
#define NUM_AUX_BUFFERS 0
#ifdef AMIGA
#   define MAX_EVAL_ORDER 12
#else
#   define MAX_EVAL_ORDER 30
#endif
#define MAX_NAME_STACK_DEPTH 64
#define MIN_POINT_SIZE 1.0
#define MAX_POINT_SIZE 10.0
#define POINT_SIZE_GRANULARITY 0.1
#define MIN_LINE_WIDTH 1.0
#define MAX_LINE_WIDTH 10.0
#define LINE_WIDTH_GRANULARITY 1.0
#define MAX_TEXTURE_PALETTE_SIZE 256
//#ifdef AMIGA

//#else
//#  define MAX_WIDTH 1600
//#  define MAX_HEIGHT 1200
//#endif
#define PB_SIZE (3*MAX_WIDTH)
#define ACCUM_BITS 16
#define DEPTH_BITS 16
#if DEPTH_BITS==16
#  define MAX_DEPTH 0xffff
#  define DEPTH_SCALE 65535.0F
#else
#  define MAX_DEPTH 0x00ffffff
#  define DEPTH_SCALE ((float) 0x00ffffff)
#endif
#define STENCIL_BITS 8
#endif
struct gl_light {
	float Ambient[4];		
	float Diffuse[4];		
	float Specular[4];		
	float Position[4];		
	float Direction[4];		
	float SpotExponent;
	float SpotCutoff;		
float CosCutoff;		
	float ConstantAttenuation;
	float LinearAttenuation;
	float QuadraticAttenuation;
	GLboolean Enabled;		
	struct gl_light *NextEnabled;	
	
	float VP_inf_norm[3];		
	float h_inf_norm[3];		
float NormDirection[3];	
float SpotExpTable[EXP_TABLE_SIZE][2];
	float MatAmbient[2][3];	
	float MatDiffuse[2][3];	
	float MatSpecular[2][3];	
	float dli;			
	float sli;			
};
struct gl_lightmodel {
	float Ambient[4];		
	GLboolean LocalViewer;		
	GLboolean TwoSide;		
};
struct gl_material {
	float Ambient[4];
	float Diffuse[4];
	float Specular[4];
	float Emission[4];
	float Shininess;
	float AmbientIndex;	
	float DiffuseIndex;	
	float SpecularIndex;	
float ShineTable[SHINE_TABLE_SIZE];
};
struct gl_accum_attrib {
	float ClearColor[4];	
};
struct gl_colorbuffer_attrib {
	GLuint ClearIndex;		
	float ClearColor[4];		
	GLuint IndexMask;		
	GLuint ColorMask;		
GLboolean SWmasking;		
	GLenum DrawBuffer;		
	
	GLboolean AlphaEnabled;		
	GLenum AlphaFunc;		
	float AlphaRef;		
	GLubyte AlphaRefUbyte;		
	
	GLboolean BlendEnabled;		
	GLenum BlendSrc;		
	GLenum BlendDst;		
	GLenum BlendEquation;
	float BlendColor[4];
	
	GLenum LogicOp;			
	GLboolean IndexLogicOpEnabled;	
	GLboolean ColorLogicOpEnabled;	
	GLboolean SWLogicOpEnabled;	
	GLboolean DitherFlag;		
};
struct gl_current_attrib {
	GLubyte ByteColor[4];		
	GLuint Index;			
	float Normal[3];		
	float TexCoord[4];		
	float RasterPos[4];		
	float RasterDistance;		
	float RasterColor[4];		
	GLuint RasterIndex;		
	float RasterTexCoord[4];	
	GLboolean RasterPosValid;	
	GLboolean EdgeFlag;		
};
struct gl_depthbuffer_attrib {
	GLenum Func;		
	float Clear;		
	GLboolean Test;		
	GLboolean Mask;		
};
struct gl_enable_attrib {
	GLboolean AlphaTest;
	GLboolean AutoNormal;
	GLboolean Blend;
	GLboolean ClipPlane[MAX_CLIP_PLANES];
	GLboolean ColorMaterial;
	GLboolean CullFace;
	GLboolean DepthTest;
	GLboolean Dither;
	GLboolean Fog;
	GLboolean Light[MAX_LIGHTS];
	GLboolean Lighting;
	GLboolean LineSmooth;
	GLboolean LineStipple;
	GLboolean IndexLogicOp;
	GLboolean ColorLogicOp;
	GLboolean Map1Color4;
	GLboolean Map1Index;
	GLboolean Map1Normal;
	GLboolean Map1TextureCoord1;
	GLboolean Map1TextureCoord2;
	GLboolean Map1TextureCoord3;
	GLboolean Map1TextureCoord4;
	GLboolean Map1Vertex3;
	GLboolean Map1Vertex4;
	GLboolean Map2Color4;
	GLboolean Map2Index;
	GLboolean Map2Normal;
	GLboolean Map2TextureCoord1;
	GLboolean Map2TextureCoord2;
	GLboolean Map2TextureCoord3;
	GLboolean Map2TextureCoord4;
	GLboolean Map2Vertex3;
	GLboolean Map2Vertex4;
	GLboolean Normalize;
	GLboolean PointSmooth;
	GLboolean PolygonOffsetPoint;
	GLboolean PolygonOffsetLine;
	GLboolean PolygonOffsetFill;
	GLboolean PolygonSmooth;
	GLboolean PolygonStipple;
	GLboolean Scissor;
	GLboolean Stencil;
	GLuint Texture;
	GLuint TexGen;
};
struct gl_eval_attrib {
	
	GLboolean Map1Color4;
	GLboolean Map1Index;
	GLboolean Map1Normal;
	GLboolean Map1TextureCoord1;
	GLboolean Map1TextureCoord2;
	GLboolean Map1TextureCoord3;
	GLboolean Map1TextureCoord4;
	GLboolean Map1Vertex3;
	GLboolean Map1Vertex4;
	GLboolean Map2Color4;
	GLboolean Map2Index;
	GLboolean Map2Normal;
	GLboolean Map2TextureCoord1;
	GLboolean Map2TextureCoord2;
	GLboolean Map2TextureCoord3;
	GLboolean Map2TextureCoord4;
	GLboolean Map2Vertex3;
	GLboolean Map2Vertex4;
	GLboolean AutoNormal;
	
	GLuint MapGrid1un;
	float MapGrid1u1, MapGrid1u2;
	GLuint MapGrid2un, MapGrid2vn;
	float MapGrid2u1, MapGrid2u2;
	float MapGrid2v1, MapGrid2v2;
};
struct gl_fog_attrib {
	GLboolean Enabled;		
	float Color[4];		
	float Density;		
	float Start;			
	float End;			
	float Index;			
	GLenum Mode;			
};
struct gl_hint_attrib {
	
	GLenum PerspectiveCorrection;
	GLenum PointSmooth;
	GLenum LineSmooth;
	GLenum PolygonSmooth;
	GLenum Fog;
};
struct gl_light_attrib {
struct gl_light Light[MAX_LIGHTS];	
struct gl_lightmodel Model;		
struct gl_material Material[2];	
GLboolean Enabled;			
GLenum ShadeModel;			
GLenum ColorMaterialFace;		
GLenum ColorMaterialMode;		
GLuint ColorMaterialBitmask;		
GLboolean ColorMaterialEnabled;
struct gl_light *FirstEnabled;	
GLboolean Fast;			
float BaseColor[2][4];
};
struct gl_line_attrib {
	GLboolean SmoothFlag;		
	GLboolean StippleFlag;		
	GLushort StipplePattern;	
	GLint StippleFactor;		
	float Width;			
};
struct gl_list_attrib {
	GLuint ListBase;
};
struct gl_pixel_attrib {
	GLenum ReadBuffer;
	float RedBias, RedScale;	
	float GreenBias, GreenScale;
	float BlueBias, BlueScale;
	float AlphaBias, AlphaScale;
	float DepthBias, DepthScale;
	GLint IndexShift;
	GLint IndexOffset;
	GLboolean MapColorFlag;
	GLboolean MapStencilFlag;
	float ZoomX;			
	float ZoomY;			
	
	GLint MapStoSsize;			
	GLint MapItoIsize;
	GLint MapItoRsize;
	GLint MapItoGsize;
	GLint MapItoBsize;
	GLint MapItoAsize;
	GLint MapRtoRsize;
	GLint MapGtoGsize;
	GLint MapBtoBsize;
	GLint MapAtoAsize;
	GLint MapStoS[MAX_PIXEL_MAP_TABLE];	
	GLint MapItoI[MAX_PIXEL_MAP_TABLE];
	float MapItoR[MAX_PIXEL_MAP_TABLE];
	float MapItoG[MAX_PIXEL_MAP_TABLE];
	float MapItoB[MAX_PIXEL_MAP_TABLE];
	float MapItoA[MAX_PIXEL_MAP_TABLE];
	float MapRtoR[MAX_PIXEL_MAP_TABLE];
	float MapGtoG[MAX_PIXEL_MAP_TABLE];
	float MapBtoB[MAX_PIXEL_MAP_TABLE];
	float MapAtoA[MAX_PIXEL_MAP_TABLE];
};
struct gl_point_attrib {
	GLboolean SmoothFlag;	
	float Size;		
	float Params[3];	
	float MinSize;	
	float MaxSize;	
	float Threshold;	
};
struct gl_polygon_attrib {
	GLenum FrontFace;	
	GLenum FrontMode;	
	GLenum BackMode;	
	GLboolean Unfilled;	
	GLboolean CullFlag;	
	GLenum CullFaceMode;	
GLuint CullBits;	
	GLboolean SmoothFlag;	
	GLboolean StippleFlag;	
float OffsetFactor;	
float OffsetUnits;	
GLboolean OffsetPoint;	
GLboolean OffsetLine;	
GLboolean OffsetFill;	
GLboolean OffsetAny;	
};
struct gl_scissor_attrib {
	GLboolean	Enabled;		
	GLint		X, Y;			
	GLsizei		Width, Height;		
};
struct gl_stencil_attrib {
	GLboolean	Enabled;	
	GLenum		Function;	
	GLenum		FailFunc;	
	GLenum		ZPassFunc;	
	GLenum		ZFailFunc;	
	GLstencil	Ref;		
	GLstencil	ValueMask;	
	GLstencil	Clear;		
	GLstencil	WriteMask;	
};
#define Q_BIT 1
#define R_BIT 2
#define S_BIT 4
#define T_BIT 8
#define TEXTURE_1D 1
#define TEXTURE_2D 2
#define TEXTURE_3D 4
struct gl_texture_attrib {
	GLuint Enabled;			
	GLenum EnvMode;			
	float EnvColor[4];
	GLuint TexGenEnabled;		
	GLenum GenModeS;		
	GLenum GenModeT;		
	GLenum GenModeR;		
	GLenum GenModeQ;		
	float ObjectPlaneS[4];
	float ObjectPlaneT[4];
	float ObjectPlaneR[4];
	float ObjectPlaneQ[4];
	float EyePlaneS[4];
	float EyePlaneT[4];
	float EyePlaneR[4];
	float EyePlaneQ[4];
	struct gl_texture_object *Current1D;
	struct gl_texture_object *Current2D;
	struct gl_texture_object *Current3D;
	struct gl_texture_object *Current;
//#ifdef GL_VERSION_1_1
	struct gl_texture_object *Proxy1D;
	struct gl_texture_object *Proxy2D;
	struct gl_texture_object *Proxy3D;
//#endif
	
	GLboolean SharedPalette;
	GLubyte Palette[MAX_TEXTURE_PALETTE_SIZE*4];
	GLuint PaletteSize;
	GLenum PaletteIntFormat;
	GLenum PaletteFormat;
};
struct gl_transform_attrib {
	GLenum MatrixMode;			
	float ClipEquation[MAX_CLIP_PLANES][4];
	GLboolean ClipEnabled[MAX_CLIP_PLANES];
	GLboolean AnyClip;			
	GLboolean Normalize;			
};
struct gl_viewport_attrib {
	GLint X, Y;		
	GLsizei Width, Height;	
	float Near, Far;	
	float Sx, Sy, Sz;	
	float Tx, Ty, Tz;	
};
struct gl_attrib_node {
	GLbitfield kind;
	void *data;
	struct gl_attrib_node *next;
};
struct gl_pixelstore_attrib {
	GLint Alignment;
	GLint RowLength;
	GLint SkipPixels;
	GLint SkipRows;
	GLint ImageHeight;
	GLint SkipImages;
	GLboolean SwapBytes;
	GLboolean LsbFirst;
};
struct gl_array_attrib {
	GLint VertexSize;
	GLenum VertexType;
	GLsizei VertexStride;		
	GLsizei VertexStrideB;		
	void *VertexPtr;
	GLboolean VertexEnabled;
	GLenum NormalType;
	GLsizei NormalStride;		
	GLsizei NormalStrideB;		
	void *NormalPtr;
	GLboolean NormalEnabled;
	GLint ColorSize;
	GLenum ColorType;
	GLsizei ColorStride;		
	GLsizei ColorStrideB;		
	void *ColorPtr;
	GLboolean ColorEnabled;
	GLenum IndexType;
	GLsizei IndexStride;		
	GLsizei IndexStrideB;		
	void *IndexPtr;
	GLboolean IndexEnabled;
	GLint TexCoordSize;
	GLenum TexCoordType;
	GLsizei TexCoordStride;		
	GLsizei TexCoordStrideB;	
	void *TexCoordPtr;
	GLboolean TexCoordEnabled;
	GLsizei EdgeFlagStride;		
	GLsizei EdgeFlagStrideB;	
	GLboolean *EdgeFlagPtr;
	GLboolean EdgeFlagEnabled;
};
struct gl_feedback {
	GLenum Type;
	GLuint Mask;
	float *Buffer;
	GLuint BufferSize;
	GLuint Count;
};
struct gl_selection {
	GLuint *Buffer;
	GLuint BufferSize;	
	GLuint BufferCount;	
	GLuint Hits;		
	GLuint NameStackDepth;
	GLuint NameStack[MAX_NAME_STACK_DEPTH];
	GLboolean HitFlag;
	float HitMinZ, HitMaxZ;
};
struct gl_1d_map {
	GLuint Order;		
	float u1, u2;
	float *Points;	
	GLboolean Retain;	
};
	
struct gl_2d_map {
	GLuint Uorder;		
	GLuint Vorder;		
	float u1, u2;
	float v1, v2;
	float *Points;	
	GLboolean Retain;	
};
struct gl_evaluators {
	
	struct gl_1d_map Map1Vertex3;
	struct gl_1d_map Map1Vertex4;
	struct gl_1d_map Map1Index;
	struct gl_1d_map Map1Color4;
	struct gl_1d_map Map1Normal;
	struct gl_1d_map Map1Texture1;
	struct gl_1d_map Map1Texture2;
	struct gl_1d_map Map1Texture3;
	struct gl_1d_map Map1Texture4;
	
	struct gl_2d_map Map2Vertex3;
	struct gl_2d_map Map2Vertex4;
	struct gl_2d_map Map2Index;
	struct gl_2d_map Map2Color4;
	struct gl_2d_map Map2Normal;
	struct gl_2d_map Map2Texture1;
	struct gl_2d_map Map2Texture2;
	struct gl_2d_map Map2Texture3;
	struct gl_2d_map Map2Texture4;
};
struct gl_texture_object {
	GLint RefCount;			
	GLuint Name;			
	GLuint Dimensions;		
	float Priority;		
	GLint BorderColor[4];		
	GLenum WrapS;			
	GLenum WrapT;			
	GLenum WrapR;			
	GLenum MinFilter;		
	GLenum MagFilter;		
	float MinMagThresh;		
	struct gl_texture_image *Image[MAX_TEXTURE_LEVELS];
	
	GLubyte Palette[MAX_TEXTURE_PALETTE_SIZE*4];
	GLuint PaletteSize;
	GLenum PaletteIntFormat;
	GLenum PaletteFormat;
	
	GLboolean Dirty;	
	void *DriverData;	
	GLboolean Complete;		
	TextureSampleFunc SampleFunc;
	struct gl_texture_object *Next;	
};
struct gl_shared_state {
GLint RefCount;			
struct HashTable *DisplayList;	
struct HashTable *TexObjects;	
struct gl_texture_object *TexObjectList;
struct gl_texture_object *Default1D;	
struct gl_texture_object *Default2D;
struct gl_texture_object *Default3D;
};
struct gl_visual {
	GLboolean RGBAflag;	
	GLboolean DBflag;	
	float RedScale;	
	float GreenScale;	
	float BlueScale;	
	float AlphaScale;	
				
				
	GLboolean EightBitColor;
float InvRedScale;	
float InvGreenScale;	
float InvBlueScale;	
float InvAlphaScale;	
	GLint RedBits;		
	GLint GreenBits;
	GLint BlueBits;
	GLint AlphaBits;
	GLint IndexBits;	
	GLint AccumBits;	
	GLint DepthBits;	
	GLint StencilBits;	
	
	GLboolean FrontAlphaEnabled;
	GLboolean BackAlphaEnabled;
};
struct gl_frame_buffer {
	GLvisual *Visual;	
	GLint Width;		
	GLint Height;		
	GLdepth *Depth;		
	
	GLstencil *Stencil;	
	
	GLaccum *Accum;		
	
	GLubyte *FrontAlpha;	
	GLubyte *BackAlpha;	
	GLubyte *Alpha;		
	
	GLint Xmin, Xmax, Ymin, Ymax;
#if 0
struct gl_frame_buffer *Next;
#endif
};
struct dd_function_table {
const char * (*RendererString)(void);
void (*UpdateState)( GLcontext *ctx );
void (*ClearIndex)( GLcontext *ctx, GLuint index );
void (*ClearColor)( GLcontext *ctx, GLubyte red, GLubyte green,
GLubyte blue, GLubyte alpha );
void (*Clear)( GLcontext *ctx,
GLboolean all, GLint x, GLint y, GLint width, GLint height );
void (*Index)( GLcontext *ctx, GLuint index );
void (*Color)( GLcontext *ctx,
GLubyte red, GLubyte green, GLubyte glue, GLubyte alpha );
GLboolean (*SetBuffer)( GLcontext *ctx, GLenum mode );
void (*GetBufferSize)( GLcontext *ctx,
GLuint *width, GLuint *height );
void (*WriteColorSpan)( GLcontext *ctx,
GLuint n, GLint x, GLint y,
			   const GLubyte red[], const GLubyte green[],
			   const GLubyte blue[], const GLubyte alpha[],
			   const GLubyte mask[] );
void (*WriteMonocolorSpan)( GLcontext *ctx,
GLuint n, GLint x, GLint y,
			       const GLubyte mask[] );
void (*WriteColorPixels)( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
			     const GLubyte red[], const GLubyte green[],
			     const GLubyte blue[], const GLubyte alpha[],
			     const GLubyte mask[] );
void (*WriteMonocolorPixels)( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
				 const GLubyte mask[] );
void (*WriteIndexSpan)( GLcontext *ctx,
GLuint n, GLint x, GLint y, const GLuint index[],
const GLubyte mask[] );
void (*WriteMonoindexSpan)( GLcontext *ctx,
GLuint n, GLint x, GLint y,
			       const GLubyte mask[] );
void (*WriteIndexPixels)( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
const GLuint index[], const GLubyte mask[] );
void (*WriteMonoindexPixels)( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
				 const GLubyte mask[] );
void (*ReadIndexSpan)( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLuint index[] );
void (*ReadColorSpan)( GLcontext *ctx,
GLuint n, GLint x, GLint y,
			  GLubyte red[], GLubyte green[],
			  GLubyte blue[], GLubyte alpha[] );
void (*ReadIndexPixels)( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
			    GLuint indx[], const GLubyte mask[] );
void (*ReadColorPixels)( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
			    GLubyte red[], GLubyte green[],
			    GLubyte blue[], GLubyte alpha[],
const GLubyte mask[] );
void (*Finish)( GLcontext *ctx );
void (*Flush)( GLcontext *ctx );
GLboolean (*IndexMask)( GLcontext *ctx, GLuint mask );
GLboolean (*ColorMask)( GLcontext *ctx,
GLboolean rmask, GLboolean gmask,
GLboolean bmask, GLboolean amask );
GLboolean (*LogicOp)( GLcontext *ctx, GLenum op );
void (*Dither)( GLcontext *ctx, GLboolean enable );
void (*Error)( GLcontext *ctx );
void (*NearFar)( GLcontext *ctx, float nearVal, float farVal );
void (*AllocDepthBuffer)( GLcontext *ctx );
void (*ClearDepthBuffer)( GLcontext *ctx );
GLuint (*DepthTestSpan)( GLcontext *ctx,
GLuint n, GLint x, GLint y, const GLdepth z[],
GLubyte mask[] );
void (*DepthTestPixels)( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
const GLdepth z[], GLubyte mask[] );
void (*ReadDepthSpanFloat)( GLcontext *ctx,
GLuint n, GLint x, GLint y, float depth[]);
void (*ReadDepthSpanInt)( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLdepth depth[] );
points_func PointsFunc;
line_func LineFunc;
triangle_func TriangleFunc;
quad_func QuadFunc;
rect_func RectFunc;
GLboolean (*DrawPixels)( GLcontext *ctx,
GLint x, GLint y, GLsizei width, GLsizei height,
GLenum format, GLenum type, GLboolean packed,
const GLvoid *pixels );
GLboolean (*Bitmap)( GLcontext *ctx, GLsizei width, GLsizei height,
float xorig, float yorig,
float xmove, float ymove,
const struct gl_image *bitmap );
void (*Begin)( GLcontext *ctx, GLenum mode );
void (*End)( GLcontext *ctx );
void (*RasterSetup)( GLcontext *ctx, GLuint start, GLuint end );
GLboolean (*RenderVB)( GLcontext *ctx, GLboolean allDone );
void (*TexEnv)( GLcontext *ctx, GLenum pname, const float *param );
void (*TexImage)( GLcontext *ctx, GLenum target,
struct gl_texture_object *tObj, GLint level,
GLint internalFormat,
const struct gl_texture_image *image );
void (*TexParameter)( GLcontext *ctx, GLenum target,
struct gl_texture_object *tObj,
GLenum pname, const float *params );
void (*BindTexture)( GLcontext *ctx, GLenum target,
struct gl_texture_object *tObj );
void (*DeleteTexture)( GLcontext *ctx, struct gl_texture_object *tObj );
void (*UpdateTexturePalette)( GLcontext *ctx,
struct gl_texture_object *tObj );
void (*UseGlobalTexturePalette)( GLcontext *ctx, GLboolean state );
};
struct gl_api_table {
void (*Accum)( GLcontext *, GLenum, float );
void (*AlphaFunc)( GLcontext *, GLenum, GLclampf );
GLboolean (*AreTexturesResident)( GLcontext *, GLsizei,
const GLuint *, GLboolean * );
void (*ArrayElement)( GLcontext *, GLint );
void (*Begin)( GLcontext *, GLenum );
void (*BindTexture)( GLcontext *, GLenum, GLuint );
void (*Bitmap)( GLcontext *, GLsizei, GLsizei, float, float,
		     float, float, const struct gl_image *bitmap );
void (*BlendColor)( GLcontext *, GLclampf, GLclampf, GLclampf, GLclampf);
void (*BlendEquation)( GLcontext *, GLenum );
void (*BlendFunc)( GLcontext *, GLenum, GLenum );
void (*CallList)( GLcontext *, GLuint list );
void (*CallLists)( GLcontext *, GLsizei, GLenum, const GLvoid * );
void (*Clear)( GLcontext *, GLbitfield );
void (*ClearAccum)( GLcontext *, float, float, float, float );
void (*ClearColor)( GLcontext *, GLclampf, GLclampf, GLclampf, GLclampf );
void (*ClearDepth)( GLcontext *, GLclampd );
void (*ClearIndex)( GLcontext *, float );
void (*ClearStencil)( GLcontext *, GLint );
void (*ClipPlane)( GLcontext *, GLenum, const float * );
void (*Color3f)( GLcontext *, float, float, float );
void (*Color3fv)( GLcontext *, const float * );
void (*Color4f)( GLcontext *, float, float, float, float );
void (*Color4fv)( GLcontext *, const float * );
void (*Color4ub)( GLcontext *, GLubyte, GLubyte, GLubyte, GLubyte );
void (*Color4ubv)( GLcontext *, const GLubyte * );
void (*ColorMask)( GLcontext *,
			GLboolean, GLboolean, GLboolean, GLboolean );
void (*ColorMaterial)( GLcontext *, GLenum, GLenum );
void (*ColorPointer)( GLcontext *, GLint, GLenum, GLsizei, const GLvoid * );
void (*ColorTable)( GLcontext *, GLenum, GLenum, struct gl_image * );
void (*ColorSubTable)( GLcontext *, GLenum, GLsizei, struct gl_image * );
void (*CopyPixels)( GLcontext *, GLint, GLint, GLsizei, GLsizei, GLenum );
void (*CopyTexImage1D)( GLcontext *, GLenum, GLint, GLenum,
GLint, GLint, GLsizei, GLint );
void (*CopyTexImage2D)( GLcontext *, GLenum, GLint, GLenum,
GLint, GLint, GLsizei, GLsizei, GLint );
void (*CopyTexSubImage1D)( GLcontext *, GLenum, GLint, GLint,
GLint, GLint, GLsizei );
void (*CopyTexSubImage2D)( GLcontext *, GLenum, GLint, GLint, GLint,
GLint, GLint, GLsizei, GLsizei );
void (*CopyTexSubImage3DEXT)(GLcontext *,
GLenum , GLint ,
GLint , GLint , GLint ,
GLint , GLint ,
GLsizei , GLsizei  );
void (*CullFace)( GLcontext *, GLenum );
void (*DeleteLists)( GLcontext *, GLuint, GLsizei );
void (*DeleteTextures)( GLcontext *, GLsizei, const GLuint *);
void (*DepthFunc)( GLcontext *, GLenum );
void (*DepthMask)( GLcontext *, GLboolean );
void (*DepthRange)( GLcontext *, GLclampd, GLclampd );
void (*Disable)( GLcontext *, GLenum );
void (*DisableClientState)( GLcontext *, GLenum );
void (*DrawArrays)( GLcontext *, GLenum, GLint, GLsizei );
void (*DrawBuffer)( GLcontext *, GLenum );
void (*DrawElements)( GLcontext *, GLenum, GLsizei, GLenum, const GLvoid *);
void (*DrawPixels)( GLcontext *,
GLsizei, GLsizei, GLenum, GLenum, const GLvoid * );
void (*EdgeFlag)( GLcontext *, GLboolean );
void (*EdgeFlagPointer)( GLcontext *, GLsizei, const GLboolean * );
void (*Enable)( GLcontext *, GLenum );
void (*EnableClientState)( GLcontext *, GLenum );
void (*End)( GLcontext * );
void (*EndList)( GLcontext * );
void (*EvalCoord1f)( GLcontext *, float );
void (*EvalCoord2f)( GLcontext *, float , float );
void (*EvalMesh1)( GLcontext *, GLenum, GLint, GLint );
void (*EvalMesh2)( GLcontext *, GLenum, GLint, GLint, GLint, GLint );
void (*EvalPoint1)( GLcontext *, GLint );
void (*EvalPoint2)( GLcontext *, GLint, GLint );
void (*FeedbackBuffer)( GLcontext *, GLsizei, GLenum, float * );
void (*Finish)( GLcontext * );
void (*Flush)( GLcontext * );
void (*Fogfv)( GLcontext *, GLenum, const float * );
void (*FrontFace)( GLcontext *, GLenum );
void (*Frustum)( GLcontext *, GLdouble, GLdouble, GLdouble, GLdouble,
GLdouble, GLdouble );
GLuint (*GenLists)( GLcontext *, GLsizei );
void (*GenTextures)( GLcontext *, GLsizei, GLuint * );
void (*GetBooleanv)( GLcontext *, GLenum, GLboolean * );
void (*GetClipPlane)( GLcontext *, GLenum, GLdouble * );
void (*GetColorTable)( GLcontext *, GLenum, GLenum, GLenum, GLvoid *);
void (*GetColorTableParameteriv)( GLcontext *, GLenum, GLenum, GLint *);
void (*GetDoublev)( GLcontext *, GLenum, GLdouble * );
GLenum (*GetError)( GLcontext * );
void (*GetFloatv)( GLcontext *, GLenum, float * );
void (*GetIntegerv)( GLcontext *, GLenum, GLint * );
const GLubyte* (*GetString)( GLcontext *, GLenum name );
void (*GetLightfv)( GLcontext *, GLenum light, GLenum, float * );
void (*GetLightiv)( GLcontext *, GLenum light, GLenum, GLint * );
void (*GetMapdv)( GLcontext *, GLenum, GLenum, GLdouble * );
void (*GetMapfv)( GLcontext *, GLenum, GLenum, float * );
void (*GetMapiv)( GLcontext *, GLenum, GLenum, GLint * );
void (*GetMaterialfv)( GLcontext *, GLenum, GLenum, float * );
void (*GetMaterialiv)( GLcontext *, GLenum, GLenum, GLint * );
void (*GetPixelMapfv)( GLcontext *, GLenum, float * );
void (*GetPixelMapuiv)( GLcontext *, GLenum, GLuint * );
void (*GetPixelMapusv)( GLcontext *, GLenum, GLushort * );
void (*GetPointerv)( GLcontext *, GLenum, GLvoid ** );
void (*GetPolygonStipple)( GLcontext *, GLubyte * );
void (*PrioritizeTextures)( GLcontext *, GLsizei, const GLuint *,
const GLclampf * );
void (*GetTexEnvfv)( GLcontext *, GLenum, GLenum, float * );
void (*GetTexEnviv)( GLcontext *, GLenum, GLenum, GLint * );
void (*GetTexGendv)( GLcontext *, GLenum coord, GLenum, GLdouble * );
void (*GetTexGenfv)( GLcontext *, GLenum coord, GLenum, float * );
void (*GetTexGeniv)( GLcontext *, GLenum coord, GLenum, GLint * );
void (*GetTexImage)( GLcontext *, GLenum, GLint level, GLenum, GLenum,
GLvoid * );
void (*GetTexLevelParameterfv)( GLcontext *,
				     GLenum, GLint, GLenum, float * );
void (*GetTexLevelParameteriv)( GLcontext *,
				     GLenum, GLint, GLenum, GLint * );
void (*GetTexParameterfv)( GLcontext *, GLenum, GLenum, float *);
void (*GetTexParameteriv)( GLcontext *, GLenum, GLenum, GLint * );
void (*Hint)( GLcontext *, GLenum, GLenum );
void (*IndexMask)( GLcontext *, GLuint );
void (*Indexf)( GLcontext *, float c );
void (*Indexi)( GLcontext *, GLint c );
void (*IndexPointer)( GLcontext *, GLenum, GLsizei, const GLvoid * );
void (*InitNames)( GLcontext * );
void (*InterleavedArrays)( GLcontext *, GLenum, GLsizei, const GLvoid * );
GLboolean (*IsEnabled)( GLcontext *, GLenum );
GLboolean (*IsList)( GLcontext *, GLuint );
GLboolean (*IsTexture)( GLcontext *, GLuint );
void (*LightModelfv)( GLcontext *, GLenum, const float * );
void (*Lightfv)( GLcontext *, GLenum light, GLenum, const float *, GLint);
void (*LineStipple)( GLcontext *, GLint factor, GLushort );
void (*LineWidth)( GLcontext *, float );
void (*ListBase)( GLcontext *, GLuint );
void (*LoadIdentity)( GLcontext * );
void (*LoadMatrixf)( GLcontext *, const float * );
void (*LoadName)( GLcontext *, GLuint );
void (*LogicOp)( GLcontext *, GLenum );
void (*Map1f)( GLcontext *, GLenum, float, float, GLint, GLint,
		  const float *, GLboolean );
void (*Map2f)( GLcontext *, GLenum, float, float, GLint, GLint,
		  float, float, GLint, GLint, const float *,
		  GLboolean );
void (*MapGrid1f)( GLcontext *, GLint, float, float );
void (*MapGrid2f)( GLcontext *, GLint, float, float,
			GLint, float, float );
void (*Materialfv)( GLcontext *, GLenum, GLenum, const float * );
void (*MatrixMode)( GLcontext *, GLenum );
void (*MultMatrixf)( GLcontext *, const float * );
void (*NewList)( GLcontext *, GLuint list, GLenum );
void (*Normal3f)( GLcontext *, float, float, float );
void (*Normal3fv)( GLcontext *, const float * );
void (*NormalPointer)( GLcontext *, GLenum, GLsizei, const GLvoid * );
void (*Ortho)( GLcontext *, GLdouble, GLdouble, GLdouble, GLdouble,
GLdouble, GLdouble );
void (*PassThrough)( GLcontext *, float );
void (*PixelMapfv)( GLcontext *, GLenum, GLint, const float * );
void (*PixelStorei)( GLcontext *, GLenum, GLint );
void (*PixelTransferf)( GLcontext *, GLenum, float );
void (*PixelZoom)( GLcontext *, float, float );
void (*PointParameterfvEXT)( GLcontext *, GLenum, const float * );
void (*PointSize)( GLcontext *, float );
void (*PolygonMode)( GLcontext *, GLenum, GLenum );
void (*PolygonOffset)( GLcontext *, float, float );
void (*PolygonStipple)( GLcontext *, const GLubyte * );
void (*PopAttrib)( GLcontext * );
void (*PopClientAttrib)( GLcontext * );
void (*PopMatrix)( GLcontext * );
void (*PopName)( GLcontext * );
void (*PushAttrib)( GLcontext *, GLbitfield );
void (*PushClientAttrib)( GLcontext *, GLbitfield );
void (*PushMatrix)( GLcontext * );
void (*PushName)( GLcontext *, GLuint );
void (*RasterPos4f)( GLcontext *,
float x, float y, float z, float w );
void (*ReadBuffer)( GLcontext *, GLenum );
void (*ReadPixels)( GLcontext *, GLint, GLint, GLsizei, GLsizei, GLenum,
			 GLenum, GLvoid * );
void (*Rectf)( GLcontext *, float, float, float, float );
GLint (*RenderMode)( GLcontext *, GLenum );
void (*Rotatef)( GLcontext *, float, float, float, float );
void (*Scalef)( GLcontext *, float, float, float );
void (*Scissor)( GLcontext *, GLint, GLint, GLsizei, GLsizei);
void (*SelectBuffer)( GLcontext *, GLsizei, GLuint * );
void (*ShadeModel)( GLcontext *, GLenum );
void (*StencilFunc)( GLcontext *, GLenum, GLint, GLuint );
void (*StencilMask)( GLcontext *, GLuint );
void (*StencilOp)( GLcontext *, GLenum, GLenum, GLenum );
void (*TexCoord2f)( GLcontext *, float, float );
void (*TexCoord4f)( GLcontext *, float, float, float, float );
void (*TexCoordPointer)( GLcontext *, GLint, GLenum, GLsizei,
const GLvoid *);
void (*TexEnvfv)( GLcontext *, GLenum, GLenum, const float * );
void (*TexGenfv)( GLcontext *, GLenum coord, GLenum, const float * );
void (*TexImage1D)( GLcontext *, GLenum, GLint, GLint, GLsizei,
GLint, GLenum, GLenum, struct gl_image * );
void (*TexImage2D)( GLcontext *, GLenum, GLint, GLint, GLsizei, GLsizei,
GLint, GLenum, GLenum, struct gl_image * );
void (*TexSubImage1D)( GLcontext *, GLenum, GLint, GLint, GLsizei,
GLenum, GLenum, struct gl_image * );
void (*TexSubImage2D)( GLcontext *, GLenum, GLint, GLint, GLint,
GLsizei, GLsizei, GLenum, GLenum,
struct gl_image * );
void (*TexImage3DEXT)(GLcontext *,
GLenum , GLint , GLint ,
GLsizei , GLsizei , GLsizei ,
GLint ,
GLenum , GLenum ,
struct gl_image * );
void (*TexSubImage3DEXT)(GLcontext *,
GLenum , GLint ,
GLint , GLint , GLint,
GLsizei , GLsizei , GLsizei ,
GLenum , GLenum ,
struct gl_image * );
void (*TexParameterfv)( GLcontext *, GLenum, GLenum, const float * );
void (*Translatef)( GLcontext *, float, float, float );
void (*Vertex2f)( GLcontext *, float, float );
void (*Vertex3f)( GLcontext *, float, float, float );
void (*Vertex4f)( GLcontext *, float, float, float, float );
void (*Vertex3fv)( GLcontext *, const float * );
void (*VertexPointer)( GLcontext *, GLint, GLenum, GLsizei, const GLvoid *);
void (*Viewport)( GLcontext *, GLint, GLint, GLsizei, GLsizei );
void (*WindowPos4fMESA)( GLcontext *, float, float, float, float );
void (*ResizeBuffersMESA)( GLcontext * );
};
#ifdef FX
#define VB_MAX 72
#else
#define VB_MAX 480
#endif
#define VB_SIZE  (VB_MAX + 2 * (6 + MAX_CLIP_PLANES))
#define VERTEX3_BIT  2
#define VERTEX4_BIT  4
struct vertex_buffer {
float Obj[VB_SIZE][4];	
float Eye[VB_SIZE][4];	
float Clip[VB_SIZE][4];	
float Win[VB_SIZE][3];	
float Normal[VB_SIZE][3];	
GLubyte Fcolor[VB_SIZE][4];	
GLubyte Bcolor[VB_SIZE][4];	
GLubyte (*Color)[4];		
GLuint Findex[VB_SIZE];	
GLuint Bindex[VB_SIZE];	
GLuint *Index;		
GLboolean Edgeflag[VB_SIZE];	
float TexCoord[VB_SIZE][4];
GLubyte ClipMask[VB_SIZE];	
GLubyte ClipOrMask;		
GLubyte ClipAndMask;		
GLuint Start;		
GLuint Count;		
GLuint Free;			
GLuint VertexSizeMask;	
GLuint TexCoordSize;		
GLboolean MonoColor;		
GLboolean MonoNormal;	
GLboolean MonoMaterial;	
GLuint MaterialMask[VB_SIZE];	
struct gl_material Material[VB_SIZE][2];
};
struct pixel_buffer {
	GLint x[PB_SIZE];	
	GLint y[PB_SIZE];	
	GLdepth z[PB_SIZE];	
	GLubyte r[PB_SIZE];	
	GLubyte g[PB_SIZE];	
	GLubyte b[PB_SIZE];	
	GLubyte a[PB_SIZE];	
	GLuint i[PB_SIZE];	
	float s[PB_SIZE];	
	float t[PB_SIZE];	
	float u[PB_SIZE];	
	float lambda[PB_SIZE];
	GLint color[4];		
	GLuint index;		
	GLuint count;		
	GLboolean mono;		
	GLenum primitive;	
};
struct gl_context {
	
	struct gl_shared_state *Shared;
	
	struct gl_api_table API;		
	struct gl_api_table Save;		
	struct gl_api_table Exec;		
GLvisual *Visual;
GLframebuffer *Buffer;
	
	struct dd_function_table Driver;
	void *DriverCtx;	
	void *DriverMgrCtx;	
	
	GLboolean NewModelViewMatrix;
	GLuint ModelViewMatrixType;	
	float ModelViewMatrix[16];
	float ModelViewInv[16];	
	GLuint ModelViewStackDepth;
	float ModelViewStack[MAX_MODELVIEW_STACK_DEPTH][16];
	
	GLboolean NewProjectionMatrix;
	GLuint ProjectionMatrixType;	
	float ProjectionMatrix[16];
	GLuint ProjectionStackDepth;
	float ProjectionStack[MAX_PROJECTION_STACK_DEPTH][16];
	float NearFarStack[MAX_PROJECTION_STACK_DEPTH][2];
	
	GLboolean NewTextureMatrix;
	GLuint TextureMatrixType;	
	float TextureMatrix[16];
	GLuint TextureStackDepth;
	float TextureStack[MAX_TEXTURE_STACK_DEPTH][16];
	
	GLuint CallDepth;	
	GLboolean ExecuteFlag;	
	GLboolean CompileFlag;	
	
	GLuint AttribStackDepth;
	struct gl_attrib_node *AttribStack[MAX_ATTRIB_STACK_DEPTH];
	
	struct gl_accum_attrib		Accum;
	struct gl_colorbuffer_attrib	Color;
	struct gl_current_attrib	Current;
	struct gl_depthbuffer_attrib	Depth;
	struct gl_eval_attrib		Eval;
	struct gl_fog_attrib		Fog;
	struct gl_hint_attrib		Hint;
	struct gl_light_attrib		Light;
	struct gl_line_attrib		Line;
	struct gl_list_attrib		List;
	struct gl_pixel_attrib		Pixel;
	struct gl_point_attrib		Point;
	struct gl_polygon_attrib	Polygon;
	GLuint PolygonStipple[32];
	struct gl_scissor_attrib	Scissor;
	struct gl_stencil_attrib	Stencil;
	struct gl_texture_attrib	Texture;
	struct gl_transform_attrib	Transform;
	struct gl_viewport_attrib	Viewport;
	
	GLuint ClientAttribStackDepth;
	struct gl_attrib_node *ClientAttribStack[MAX_CLIENT_ATTRIB_STACK_DEPTH];
	
	struct gl_array_attrib		Array;	
	struct gl_pixelstore_attrib	Pack;	
	struct gl_pixelstore_attrib	Unpack;	
	struct gl_evaluators EvalMap;	
	struct gl_feedback Feedback;	
	struct gl_selection Select;	
	GLenum ErrorValue;		
	GLboolean DirectContext;	
	
GLuint NewState;
	GLenum RenderMode;	
	GLenum Primitive;	
	GLuint StippleCounter;	
	GLuint ClipMask;	
	GLuint RasterMask;	
	GLboolean LightTwoSide;	
	GLboolean DirectTriangles;
	float PolygonZoffset;	
	float LineZoffset;	
	float PointZoffset;	
	GLboolean NeedNormals;	
GLboolean FastDrawPixels;
GLboolean MutablePixels;
GLboolean MonoPixels;
	
points_func PointsFunc;
line_func LineFunc;
triangle_func TriangleFunc;
quad_func QuadFunc;
rect_func RectFunc;
struct vertex_buffer* VB;
struct pixel_buffer* PB;
#ifdef PROFILE
GLuint BeginEndCount;	
GLdouble BeginEndTime;	
GLuint VertexCount;	
GLdouble VertexTime;	
GLuint PointCount;	
GLdouble PointTime;	
GLuint LineCount;	
GLdouble LineTime;	
GLuint PolygonCount;	
GLdouble PolygonTime;	
GLuint ClearCount;	
GLdouble ClearTime;	
GLuint SwapCount;	
GLdouble SwapTime;	
#endif
GLboolean NoRaster;
GLboolean NoDither;
};
/* 当前文件是D:\Read\accum.c*/

#ifdef PC_HEADER
/* 当前文件是D:\Read\all.h*/

#ifndef SRC_ALL_H
#define SRC_ALL_H
#ifndef PC_HEADER
#endif
/* 当前文件是D:\Read\accum.h*/

//#ifndef ACCUM_H
#define ACCUM_H
/* 当前文件是D:\Read\types.h*/

//#ifndef TYPES_H
#define TYPES_H
/* 当前文件是D:\Read\config.h*/


struct HashTable;
#if ACCUM_BITS==8
typedef GLbyte GLaccum;
#elif ACCUM_BITS==16
typedef GLshort GLaccum;
#else
#endif
#if STENCIL_BITS==8
typedef GLubyte GLstencil;
#else
#endif
#if DEPTH_BITS==16
typedef GLushort GLdepth;
#elif DEPTH_BITS==32
typedef GLint GLdepth;
#else
#endif

WINGDIAPI void   glClearIndex( float c );
WINGDIAPI void   glClearColor( GLclampf red,
			  GLclampf green,
			  GLclampf blue,
			  GLclampf alpha );
WINGDIAPI void   glClear( GLbitfield mask );
WINGDIAPI void   glIndexMask( GLuint mask );
WINGDIAPI void   glColorMask( GLboolean red, GLboolean green,
			 GLboolean blue, GLboolean alpha );
WINGDIAPI void   glAlphaFunc( GLenum func, GLclampf ref );
WINGDIAPI void   glBlendFunc( GLenum sfactor, GLenum dfactor );
WINGDIAPI void   glLogicOp( GLenum opcode );
WINGDIAPI void   glCullFace( GLenum mode );
WINGDIAPI void   glFrontFace( GLenum mode );
WINGDIAPI void   glPointSize( float size );
WINGDIAPI void   glLineWidth( float width );
WINGDIAPI void   glLineStipple( GLint factor, GLushort pattern );
WINGDIAPI void   glPolygonMode( GLenum face, GLenum mode );
WINGDIAPI void   glPolygonOffset( float factor, float units );
WINGDIAPI void   glPolygonStipple( const GLubyte *mask );
WINGDIAPI void   glGetPolygonStipple( GLubyte *mask );
WINGDIAPI void   glEdgeFlag( GLboolean flag );
WINGDIAPI void   glEdgeFlagv( const GLboolean *flag );
WINGDIAPI void   glScissor( GLint x, GLint y,
GLsizei width, GLsizei height);
WINGDIAPI void   glClipPlane( GLenum plane, const GLdouble *equation );
WINGDIAPI void   glGetClipPlane( GLenum plane, GLdouble *equation );
WINGDIAPI void   glDrawBuffer( GLenum mode );
WINGDIAPI void   glReadBuffer( GLenum mode );
WINGDIAPI void   glEnable( GLenum cap );
WINGDIAPI void   glDisable( GLenum cap );
WINGDIAPI GLboolean   glIsEnabled( GLenum cap );
WINGDIAPI void   glEnableClientState( GLenum cap );
WINGDIAPI void   glDisableClientState( GLenum cap );
WINGDIAPI void   glGetBooleanv( GLenum pname, GLboolean *params );
WINGDIAPI void   glGetDoublev( GLenum pname, GLdouble *params );
WINGDIAPI void   glGetFloatv( GLenum pname, float *params );
WINGDIAPI void   glGetIntegerv( GLenum pname, GLint *params );
WINGDIAPI void   glPushAttrib( GLbitfield mask );
WINGDIAPI void   glPopAttrib( void );
WINGDIAPI void   glPushClientAttrib( GLbitfield mask );
WINGDIAPI void   glPopClientAttrib( void );
WINGDIAPI GLint   glRenderMode( GLenum mode );
WINGDIAPI GLenum   glGetError( void );
WINGDIAPI const GLubyte*   glGetString( GLenum name );
WINGDIAPI void   glFinish( void );
WINGDIAPI void   glFlush( void );
WINGDIAPI void   glHint( GLenum target, GLenum mode );
WINGDIAPI void   glClearDepth( GLclampd depth );
WINGDIAPI void   glDepthFunc( GLenum func );
WINGDIAPI void   glDepthMask( GLboolean flag );
WINGDIAPI void   glDepthRange( GLclampd near_val, GLclampd far_val );
WINGDIAPI void   glClearAccum( float red, float green,
float blue, float alpha );
WINGDIAPI void   glAccum( GLenum op, float value );
WINGDIAPI void   glMatrixMode( GLenum mode );
WINGDIAPI void   glOrtho( GLdouble left, GLdouble right,
GLdouble bottom, GLdouble top,
GLdouble near_val, GLdouble far_val );
WINGDIAPI void   glFrustum( GLdouble left, GLdouble right,
GLdouble bottom, GLdouble top,
GLdouble near_val, GLdouble far_val );
WINGDIAPI void   glViewport( GLint x, GLint y,
GLsizei width, GLsizei height );
WINGDIAPI void   glPushMatrix( void );
WINGDIAPI void   glPopMatrix( void );
WINGDIAPI void   glLoadIdentity( void );
WINGDIAPI void   glLoadMatrixd( const GLdouble *m );
WINGDIAPI void   glLoadMatrixf( const float *m );
WINGDIAPI void   glMultMatrixd( const GLdouble *m );
WINGDIAPI void   glMultMatrixf( const float *m );
WINGDIAPI void   glRotated( GLdouble angle,
GLdouble x, GLdouble y, GLdouble z );
WINGDIAPI void   glRotatef( float angle,
float x, float y, float z );
WINGDIAPI void   glScaled( GLdouble x, GLdouble y, GLdouble z );
WINGDIAPI void   glScalef( float x, float y, float z );
WINGDIAPI void   glTranslated( GLdouble x, GLdouble y, GLdouble z );
WINGDIAPI void   glTranslatef( float x, float y, float z );
WINGDIAPI GLboolean   glIsList( GLuint list );
WINGDIAPI void   glDeleteLists( GLuint list, GLsizei range );
WINGDIAPI GLuint   glGenLists( GLsizei range );
WINGDIAPI void   glNewList( GLuint list, GLenum mode );
WINGDIAPI void   glEndList( void );
WINGDIAPI void   glCallList( GLuint list );
WINGDIAPI void   glCallLists( GLsizei n, GLenum type,
const GLvoid *lists );
WINGDIAPI void   glListBase( GLuint base );
WINGDIAPI void   glBegin( GLenum mode );
WINGDIAPI void   glEnd( void );
WINGDIAPI void   glVertex2d( GLdouble x, GLdouble y );
WINGDIAPI void   glVertex2f( float x, float y );
WINGDIAPI void   glVertex2i( GLint x, GLint y );
WINGDIAPI void   glVertex2s( GLshort x, GLshort y );
WINGDIAPI void   glVertex3d( GLdouble x, GLdouble y, GLdouble z );
WINGDIAPI void   glVertex3f( float x, float y, float z );
WINGDIAPI void   glVertex3i( GLint x, GLint y, GLint z );
WINGDIAPI void   glVertex3s( GLshort x, GLshort y, GLshort z );
WINGDIAPI void   glVertex4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
WINGDIAPI void   glVertex4f( float x, float y, float z, float w );
WINGDIAPI void   glVertex4i( GLint x, GLint y, GLint z, GLint w );
WINGDIAPI void   glVertex4s( GLshort x, GLshort y, GLshort z, GLshort w );
WINGDIAPI void   glVertex2dv( const GLdouble *v );
WINGDIAPI void   glVertex2fv( const float *v );
WINGDIAPI void   glVertex2iv( const GLint *v );
WINGDIAPI void   glVertex2sv( const GLshort *v );
WINGDIAPI void   glVertex3dv( const GLdouble *v );
WINGDIAPI void   glVertex3fv( const float *v );
WINGDIAPI void   glVertex3iv( const GLint *v );
WINGDIAPI void   glVertex3sv( const GLshort *v );
WINGDIAPI void   glVertex4dv( const GLdouble *v );
WINGDIAPI void   glVertex4fv( const float *v );
WINGDIAPI void   glVertex4iv( const GLint *v );
WINGDIAPI void   glVertex4sv( const GLshort *v );
WINGDIAPI void   glNormal3b( GLbyte nx, GLbyte ny, GLbyte nz );
WINGDIAPI void   glNormal3d( GLdouble nx, GLdouble ny, GLdouble nz );
WINGDIAPI void   glNormal3f( float nx, float ny, float nz );
WINGDIAPI void   glNormal3i( GLint nx, GLint ny, GLint nz );
WINGDIAPI void   glNormal3s( GLshort nx, GLshort ny, GLshort nz );
WINGDIAPI void   glNormal3bv( const GLbyte *v );
WINGDIAPI void   glNormal3dv( const GLdouble *v );
WINGDIAPI void   glNormal3fv( const float *v );
WINGDIAPI void   glNormal3iv( const GLint *v );
WINGDIAPI void   glNormal3sv( const GLshort *v );
WINGDIAPI void   glIndexd( GLdouble c );
WINGDIAPI void   glIndexf( float c );
WINGDIAPI void   glIndexi( GLint c );
WINGDIAPI void   glIndexs( GLshort c );
WINGDIAPI void   glIndexub( GLubyte c );
WINGDIAPI void   glIndexdv( const GLdouble *c );
WINGDIAPI void   glIndexfv( const float *c );
WINGDIAPI void   glIndexiv( const GLint *c );
WINGDIAPI void   glIndexsv( const GLshort *c );
WINGDIAPI void   glIndexubv( const GLubyte *c );
WINGDIAPI void   glColor3b( GLbyte red, GLbyte green, GLbyte blue );
WINGDIAPI void   glColor3d( GLdouble red, GLdouble green, GLdouble blue );
WINGDIAPI void   glColor3f( float red, float green, float blue );
WINGDIAPI void   glColor3i( GLint red, GLint green, GLint blue );
WINGDIAPI void   glColor3s( GLshort red, GLshort green, GLshort blue );
WINGDIAPI void   glColor3ub( GLubyte red, GLubyte green, GLubyte blue );
WINGDIAPI void   glColor3ui( GLuint red, GLuint green, GLuint blue );
WINGDIAPI void   glColor3us( GLushort red, GLushort green, GLushort blue );
WINGDIAPI void   glColor4b( GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha );
WINGDIAPI void   glColor4d( GLdouble red, GLdouble green,
		       GLdouble blue, GLdouble alpha );
WINGDIAPI void   glColor4f( float red, float green,
		       float blue, float alpha );
WINGDIAPI void   glColor4i( GLint red, GLint green, GLint blue, GLint alpha );
WINGDIAPI void   glColor4s( GLshort red, GLshort green,
		       GLshort blue, GLshort alpha );
WINGDIAPI void   glColor4ub( GLubyte red, GLubyte green,
			GLubyte blue, GLubyte alpha );
WINGDIAPI void   glColor4ui( GLuint red, GLuint green, GLuint blue, GLuint alpha );
WINGDIAPI void   glColor4us( GLushort red, GLushort green,
			GLushort blue, GLushort alpha );
WINGDIAPI void   glColor3bv( const GLbyte *v );
WINGDIAPI void   glColor3dv( const GLdouble *v );
WINGDIAPI void   glColor3fv( const float *v );
WINGDIAPI void   glColor3iv( const GLint *v );
WINGDIAPI void   glColor3sv( const GLshort *v );
WINGDIAPI void   glColor3ubv( const GLubyte *v );
WINGDIAPI void   glColor3uiv( const GLuint *v );
WINGDIAPI void   glColor3usv( const GLushort *v );
WINGDIAPI void   glColor4bv( const GLbyte *v );
WINGDIAPI void   glColor4dv( const GLdouble *v );
WINGDIAPI void   glColor4fv( const float *v );
WINGDIAPI void   glColor4iv( const GLint *v );
WINGDIAPI void   glColor4sv( const GLshort *v );
WINGDIAPI void   glColor4ubv( const GLubyte *v );
WINGDIAPI void   glColor4uiv( const GLuint *v );
WINGDIAPI void   glColor4usv( const GLushort *v );
WINGDIAPI void   glTexCoord1d( GLdouble s );
WINGDIAPI void   glTexCoord1f( float s );
WINGDIAPI void   glTexCoord1i( GLint s );
WINGDIAPI void   glTexCoord1s( GLshort s );
WINGDIAPI void   glTexCoord2d( GLdouble s, GLdouble t );
WINGDIAPI void   glTexCoord2f( float s, float t );
WINGDIAPI void   glTexCoord2i( GLint s, GLint t );
WINGDIAPI void   glTexCoord2s( GLshort s, GLshort t );
WINGDIAPI void   glTexCoord3d( GLdouble s, GLdouble t, GLdouble r );
WINGDIAPI void   glTexCoord3f( float s, float t, float r );
WINGDIAPI void   glTexCoord3i( GLint s, GLint t, GLint r );
WINGDIAPI void   glTexCoord3s( GLshort s, GLshort t, GLshort r );
WINGDIAPI void   glTexCoord4d( GLdouble s, GLdouble t, GLdouble r, GLdouble q );
WINGDIAPI void   glTexCoord4f( float s, float t, float r, float q );
WINGDIAPI void   glTexCoord4i( GLint s, GLint t, GLint r, GLint q );
WINGDIAPI void   glTexCoord4s( GLshort s, GLshort t, GLshort r, GLshort q );
WINGDIAPI void   glTexCoord1dv( const GLdouble *v );
WINGDIAPI void   glTexCoord1fv( const float *v );
WINGDIAPI void   glTexCoord1iv( const GLint *v );
WINGDIAPI void   glTexCoord1sv( const GLshort *v );
WINGDIAPI void   glTexCoord2dv( const GLdouble *v );
WINGDIAPI void   glTexCoord2fv( const float *v );
WINGDIAPI void   glTexCoord2iv( const GLint *v );
WINGDIAPI void   glTexCoord2sv( const GLshort *v );
WINGDIAPI void   glTexCoord3dv( const GLdouble *v );
WINGDIAPI void   glTexCoord3fv( const float *v );
WINGDIAPI void   glTexCoord3iv( const GLint *v );
WINGDIAPI void   glTexCoord3sv( const GLshort *v );
WINGDIAPI void   glTexCoord4dv( const GLdouble *v );
WINGDIAPI void   glTexCoord4fv( const float *v );
WINGDIAPI void   glTexCoord4iv( const GLint *v );
WINGDIAPI void   glTexCoord4sv( const GLshort *v );
WINGDIAPI void   glRasterPos2d( GLdouble x, GLdouble y );
WINGDIAPI void   glRasterPos2f( float x, float y );
WINGDIAPI void   glRasterPos2i( GLint x, GLint y );
WINGDIAPI void   glRasterPos2s( GLshort x, GLshort y );
WINGDIAPI void   glRasterPos3d( GLdouble x, GLdouble y, GLdouble z );
WINGDIAPI void   glRasterPos3f( float x, float y, float z );
WINGDIAPI void   glRasterPos3i( GLint x, GLint y, GLint z );
WINGDIAPI void   glRasterPos3s( GLshort x, GLshort y, GLshort z );
WINGDIAPI void   glRasterPos4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
WINGDIAPI void   glRasterPos4f( float x, float y, float z, float w );
WINGDIAPI void   glRasterPos4i( GLint x, GLint y, GLint z, GLint w );
WINGDIAPI void   glRasterPos4s( GLshort x, GLshort y, GLshort z, GLshort w );
WINGDIAPI void   glRasterPos2dv( const GLdouble *v );
WINGDIAPI void   glRasterPos2fv( const float *v );
WINGDIAPI void   glRasterPos2iv( const GLint *v );
WINGDIAPI void   glRasterPos2sv( const GLshort *v );
WINGDIAPI void   glRasterPos3dv( const GLdouble *v );
WINGDIAPI void   glRasterPos3fv( const float *v );
WINGDIAPI void   glRasterPos3iv( const GLint *v );
WINGDIAPI void   glRasterPos3sv( const GLshort *v );
WINGDIAPI void   glRasterPos4dv( const GLdouble *v );
WINGDIAPI void   glRasterPos4fv( const float *v );
WINGDIAPI void   glRasterPos4iv( const GLint *v );
WINGDIAPI void   glRasterPos4sv( const GLshort *v );
WINGDIAPI void   glRectd( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 );
WINGDIAPI void   glRectf( float x1, float y1, float x2, float y2 );
WINGDIAPI void   glRecti( GLint x1, GLint y1, GLint x2, GLint y2 );
WINGDIAPI void   glRects( GLshort x1, GLshort y1, GLshort x2, GLshort y2 );
WINGDIAPI void   glRectdv( const GLdouble *v1, const GLdouble *v2 );
WINGDIAPI void   glRectfv( const float *v1, const float *v2 );
WINGDIAPI void   glRectiv( const GLint *v1, const GLint *v2 );
WINGDIAPI void   glRectsv( const GLshort *v1, const GLshort *v2 );
WINGDIAPI void   glVertexPointer( GLint size, GLenum type, GLsizei stride,
const GLvoid *ptr );
WINGDIAPI void   glNormalPointer( GLenum type, GLsizei stride,
const GLvoid *ptr );
WINGDIAPI void   glColorPointer( GLint size, GLenum type, GLsizei stride,
const GLvoid *ptr );
WINGDIAPI void   glIndexPointer( GLenum type, GLsizei stride, const GLvoid *ptr );
WINGDIAPI void   glTexCoordPointer( GLint size, GLenum type, GLsizei stride,
const GLvoid *ptr );
WINGDIAPI void   glEdgeFlagPointer( GLsizei stride, const GLboolean *ptr );
WINGDIAPI void   glGetPointerv( GLenum pname, void **params );
WINGDIAPI void   glArrayElement( GLint i );
WINGDIAPI void   glDrawArrays( GLenum mode, GLint first, GLsizei count );
WINGDIAPI void   glDrawElements( GLenum mode, GLsizei count,
GLenum type, const GLvoid *indices );
WINGDIAPI void   glInterleavedArrays( GLenum format, GLsizei stride,
const GLvoid *pointer );
WINGDIAPI void   glShadeModel( GLenum mode );
WINGDIAPI void   glLightf( GLenum light, GLenum pname, float param );
WINGDIAPI void   glLighti( GLenum light, GLenum pname, GLint param );
WINGDIAPI void   glLightfv( GLenum light, GLenum pname, const float *params );
WINGDIAPI void   glLightiv( GLenum light, GLenum pname, const GLint *params );
WINGDIAPI void   glGetLightfv( GLenum light, GLenum pname, float *params );
WINGDIAPI void   glGetLightiv( GLenum light, GLenum pname, GLint *params );
WINGDIAPI void   glLightModelf( GLenum pname, float param );
WINGDIAPI void   glLightModeli( GLenum pname, GLint param );
WINGDIAPI void   glLightModelfv( GLenum pname, const float *params );
WINGDIAPI void   glLightModeliv( GLenum pname, const GLint *params );
WINGDIAPI void   glMaterialf( GLenum face, GLenum pname, float param );
WINGDIAPI void   glMateriali( GLenum face, GLenum pname, GLint param );
WINGDIAPI void   glMaterialfv( GLenum face, GLenum pname, const float *params );
WINGDIAPI void   glMaterialiv( GLenum face, GLenum pname, const GLint *params );
WINGDIAPI void   glGetMaterialfv( GLenum face, GLenum pname, float *params );
WINGDIAPI void   glGetMaterialiv( GLenum face, GLenum pname, GLint *params );
WINGDIAPI void   glColorMaterial( GLenum face, GLenum mode );
WINGDIAPI void   glPixelZoom( float xfactor, float yfactor );
WINGDIAPI void   glPixelStoref( GLenum pname, float param );
WINGDIAPI void   glPixelStorei( GLenum pname, GLint param );
WINGDIAPI void   glPixelTransferf( GLenum pname, float param );
WINGDIAPI void   glPixelTransferi( GLenum pname, GLint param );
WINGDIAPI void   glPixelMapfv( GLenum map, GLint mapsize,
const float *values );
WINGDIAPI void   glPixelMapuiv( GLenum map, GLint mapsize,
const GLuint *values );
WINGDIAPI void   glPixelMapusv( GLenum map, GLint mapsize,
const GLushort *values );
WINGDIAPI void   glGetPixelMapfv( GLenum map, float *values );
WINGDIAPI void   glGetPixelMapuiv( GLenum map, GLuint *values );
WINGDIAPI void   glGetPixelMapusv( GLenum map, GLushort *values );
WINGDIAPI void   glBitmap( GLsizei width, GLsizei height,
float xorig, float yorig,
float xmove, float ymove,
const GLubyte *bitmap );
WINGDIAPI void   glReadPixels( GLint x, GLint y,
GLsizei width, GLsizei height,
GLenum format, GLenum type,
GLvoid *pixels );
WINGDIAPI void   glDrawPixels( GLsizei width, GLsizei height,
GLenum format, GLenum type,
const GLvoid *pixels );
WINGDIAPI void   glCopyPixels( GLint x, GLint y,
GLsizei width, GLsizei height,
GLenum type );
WINGDIAPI void   glStencilFunc( GLenum func, GLint ref, GLuint mask );
WINGDIAPI void   glStencilMask( GLuint mask );
WINGDIAPI void   glStencilOp( GLenum fail, GLenum zfail, GLenum zpass );
WINGDIAPI void   glClearStencil( GLint s );
WINGDIAPI void   glTexGend( GLenum coord, GLenum pname, GLdouble param );
WINGDIAPI void   glTexGenf( GLenum coord, GLenum pname, float param );
WINGDIAPI void   glTexGeni( GLenum coord, GLenum pname, GLint param );
WINGDIAPI void   glTexGendv( GLenum coord, GLenum pname, const GLdouble *params );
WINGDIAPI void   glTexGenfv( GLenum coord, GLenum pname, const float *params );
WINGDIAPI void   glTexGeniv( GLenum coord, GLenum pname, const GLint *params );
WINGDIAPI void   glGetTexGendv( GLenum coord, GLenum pname, GLdouble *params );
WINGDIAPI void   glGetTexGenfv( GLenum coord, GLenum pname, float *params );
WINGDIAPI void   glGetTexGeniv( GLenum coord, GLenum pname, GLint *params );
WINGDIAPI void   glTexEnvf( GLenum target, GLenum pname, float param );
WINGDIAPI void   glTexEnvi( GLenum target, GLenum pname, GLint param );
WINGDIAPI void   glTexEnvfv( GLenum target, GLenum pname, const float *params );
WINGDIAPI void   glTexEnviv( GLenum target, GLenum pname, const GLint *params );
WINGDIAPI void   glGetTexEnvfv( GLenum target, GLenum pname, float *params );
WINGDIAPI void   glGetTexEnviv( GLenum target, GLenum pname, GLint *params );
WINGDIAPI void   glTexParameterf( GLenum target, GLenum pname, float param );
WINGDIAPI void   glTexParameteri( GLenum target, GLenum pname, GLint param );
WINGDIAPI void   glTexParameterfv( GLenum target, GLenum pname,
const float *params );
WINGDIAPI void   glTexParameteriv( GLenum target, GLenum pname,
const GLint *params );
WINGDIAPI void   glGetTexParameterfv( GLenum target,
GLenum pname, float *params);
WINGDIAPI void   glGetTexParameteriv( GLenum target,
GLenum pname, GLint *params );
WINGDIAPI void   glGetTexLevelParameterfv( GLenum target, GLint level,
GLenum pname, float *params );
WINGDIAPI void   glGetTexLevelParameteriv( GLenum target, GLint level,
GLenum pname, GLint *params );
WINGDIAPI void   glTexImage1D( GLenum target, GLint level,
GLint internalFormat,
GLsizei width, GLint border,
GLenum format, GLenum type,
const GLvoid *pixels );
WINGDIAPI void   glTexImage2D( GLenum target, GLint level,
GLint internalFormat,
GLsizei width, GLsizei height,
GLint border, GLenum format, GLenum type,
const GLvoid *pixels );
WINGDIAPI void   glGetTexImage( GLenum target, GLint level,
GLenum format, GLenum type,
GLvoid *pixels );
WINGDIAPI void   glGenTextures( GLsizei n, GLuint *textures );
WINGDIAPI void   glDeleteTextures( GLsizei n, const GLuint *textures);
WINGDIAPI void   glBindTexture( GLenum target, GLuint texture );
WINGDIAPI void   glPrioritizeTextures( GLsizei n,
const GLuint *textures,
const GLclampf *priorities );
WINGDIAPI GLboolean   glAreTexturesResident( GLsizei n,
const GLuint *textures,
GLboolean *residences );
WINGDIAPI GLboolean   glIsTexture( GLuint texture );
WINGDIAPI void   glTexSubImage1D( GLenum target, GLint level,
GLint xoffset,
GLsizei width, GLenum format,
GLenum type, const GLvoid *pixels );
WINGDIAPI void   glTexSubImage2D( GLenum target, GLint level,
GLint xoffset, GLint yoffset,
GLsizei width, GLsizei height,
GLenum format, GLenum type,
const GLvoid *pixels );
WINGDIAPI void   glCopyTexImage1D( GLenum target, GLint level,
GLenum internalformat,
GLint x, GLint y,
GLsizei width, GLint border );
WINGDIAPI void   glCopyTexImage2D( GLenum target, GLint level,
GLenum internalformat,
GLint x, GLint y,
GLsizei width, GLsizei height,
GLint border );
WINGDIAPI void   glCopyTexSubImage1D( GLenum target, GLint level,
GLint xoffset, GLint x, GLint y,
GLsizei width );
WINGDIAPI void   glCopyTexSubImage2D( GLenum target, GLint level,
GLint xoffset, GLint yoffset,
GLint x, GLint y,
GLsizei width, GLsizei height );
WINGDIAPI void   glMap1d( GLenum target, GLdouble u1, GLdouble u2,
GLint stride,
GLint order, const GLdouble *points );
WINGDIAPI void   glMap1f( GLenum target, float u1, float u2,
GLint stride,
GLint order, const float *points );
WINGDIAPI void   glMap2d( GLenum target,
		     GLdouble u1, GLdouble u2, GLint ustride, GLint uorder,
		     GLdouble v1, GLdouble v2, GLint vstride, GLint vorder,
		     const GLdouble *points );
WINGDIAPI void   glMap2f( GLenum target,
		     float u1, float u2, GLint ustride, GLint uorder,
		     float v1, float v2, GLint vstride, GLint vorder,
		     const float *points );
WINGDIAPI void   glGetMapdv( GLenum target, GLenum query, GLdouble *v );
WINGDIAPI void   glGetMapfv( GLenum target, GLenum query, float *v );
WINGDIAPI void   glGetMapiv( GLenum target, GLenum query, GLint *v );
WINGDIAPI void   glEvalCoord1d( GLdouble u );
WINGDIAPI void   glEvalCoord1f( float u );
WINGDIAPI void   glEvalCoord1dv( const GLdouble *u );
WINGDIAPI void   glEvalCoord1fv( const float *u );
WINGDIAPI void   glEvalCoord2d( GLdouble u, GLdouble v );
WINGDIAPI void   glEvalCoord2f( float u, float v );
WINGDIAPI void   glEvalCoord2dv( const GLdouble *u );
WINGDIAPI void   glEvalCoord2fv( const float *u );
WINGDIAPI void   glMapGrid1d( GLint un, GLdouble u1, GLdouble u2 );
WINGDIAPI void   glMapGrid1f( GLint un, float u1, float u2 );
WINGDIAPI void   glMapGrid2d( GLint un, GLdouble u1, GLdouble u2,
GLint vn, GLdouble v1, GLdouble v2 );
WINGDIAPI void   glMapGrid2f( GLint un, float u1, float u2,
GLint vn, float v1, float v2 );
WINGDIAPI void   glEvalPoint1( GLint i );
WINGDIAPI void   glEvalPoint2( GLint i, GLint j );
WINGDIAPI void   glEvalMesh1( GLenum mode, GLint i1, GLint i2 );
WINGDIAPI void   glEvalMesh2( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 );
WINGDIAPI void   glFogf( GLenum pname, float param );
WINGDIAPI void   glFogi( GLenum pname, GLint param );
WINGDIAPI void   glFogfv( GLenum pname, const float *params );
WINGDIAPI void   glFogiv( GLenum pname, const GLint *params );
WINGDIAPI void   glFeedbackBuffer( GLsizei size, GLenum type, float *buffer );
WINGDIAPI void   glPassThrough( float token );
WINGDIAPI void   glSelectBuffer( GLsizei size, GLuint *buffer );
WINGDIAPI void   glInitNames( void );
WINGDIAPI void   glLoadName( GLuint name );
WINGDIAPI void   glPushName( GLuint name );
WINGDIAPI void   glPopName( void );
WINGDIAPI void   glBlendEquationEXT( GLenum mode );
WINGDIAPI void   glBlendColorEXT( GLclampf red, GLclampf green,
GLclampf blue, GLclampf alpha );
WINGDIAPI void   glPolygonOffsetEXT( float factor, float bias );
WINGDIAPI void   glVertexPointerEXT( GLint size, GLenum type,
GLsizei stride,
GLsizei count, const GLvoid *ptr );
WINGDIAPI void   glNormalPointerEXT( GLenum type, GLsizei stride,
GLsizei count, const GLvoid *ptr );
WINGDIAPI void   glColorPointerEXT( GLint size, GLenum type,
GLsizei stride,
GLsizei count, const GLvoid *ptr );
WINGDIAPI void   glIndexPointerEXT( GLenum type, GLsizei stride,
GLsizei count, const GLvoid *ptr );
WINGDIAPI void   glTexCoordPointerEXT( GLint size, GLenum type,
GLsizei stride, GLsizei count,
const GLvoid *ptr );
WINGDIAPI void   glEdgeFlagPointerEXT( GLsizei stride, GLsizei count,
const GLboolean *ptr );
WINGDIAPI void   glGetPointervEXT( GLenum pname, void **params );
WINGDIAPI void   glArrayElementEXT( GLint i );
WINGDIAPI void   glDrawArraysEXT( GLenum mode, GLint first,
GLsizei count );
WINGDIAPI void   glGenTexturesEXT( GLsizei n, GLuint *textures );
WINGDIAPI void   glDeleteTexturesEXT( GLsizei n,
const GLuint *textures);
WINGDIAPI void   glBindTextureEXT( GLenum target, GLuint texture );
WINGDIAPI void   glPrioritizeTexturesEXT( GLsizei n,
const GLuint *textures,
const GLclampf *priorities );
WINGDIAPI GLboolean   glAreTexturesResidentEXT( GLsizei n,
const GLuint *textures,
GLboolean *residences );
WINGDIAPI GLboolean   glIsTextureEXT( GLuint texture );
WINGDIAPI void   glTexImage3DEXT( GLenum target, GLint level,
GLenum internalFormat,
GLsizei width, GLsizei height,
GLsizei depth, GLint border,
GLenum format, GLenum type,
const GLvoid *pixels );
WINGDIAPI void   glTexSubImage3DEXT( GLenum target, GLint level,
GLint xoffset, GLint yoffset,
GLint zoffset, GLsizei width,
GLsizei height, GLsizei depth,
GLenum format,
GLenum type, const GLvoid *pixels);
WINGDIAPI void   glCopyTexSubImage3DEXT( GLenum target, GLint level,
GLint xoffset, GLint yoffset,
GLint zoffset, GLint x,
GLint y, GLsizei width,
GLsizei height );
WINGDIAPI void   glColorTableEXT( GLenum target, GLenum internalformat,
GLsizei width, GLenum format,
GLenum type, const GLvoid *table );
WINGDIAPI void   glColorSubTableEXT( GLenum target,
GLsizei start, GLsizei count,
GLenum format, GLenum type,
const GLvoid *data );
WINGDIAPI void   glGetColorTableEXT( GLenum target, GLenum format,
GLenum type, GLvoid *table );
WINGDIAPI void   glGetColorTableParameterfvEXT( GLenum target,
GLenum pname,
float *params );
WINGDIAPI void   glGetColorTableParameterivEXT( GLenum target,
GLenum pname,
GLint *params );
WINGDIAPI void   glPointParameterfEXT( GLenum pname, float param );
WINGDIAPI void   glPointParameterfvEXT( GLenum pname,
const float *params );
WINGDIAPI void   glWindowPos2iMESA( GLint x, GLint y );
WINGDIAPI void   glWindowPos2sMESA( GLshort x, GLshort y );
WINGDIAPI void   glWindowPos2fMESA( float x, float y );
WINGDIAPI void   glWindowPos2dMESA( GLdouble x, GLdouble y );
WINGDIAPI void   glWindowPos2ivMESA( const GLint *p );
WINGDIAPI void   glWindowPos2svMESA( const GLshort *p );
WINGDIAPI void   glWindowPos2fvMESA( const float *p );
WINGDIAPI void   glWindowPos2dvMESA( const GLdouble *p );
WINGDIAPI void   glWindowPos3iMESA( GLint x, GLint y, GLint z );
WINGDIAPI void   glWindowPos3sMESA( GLshort x, GLshort y, GLshort z );
WINGDIAPI void   glWindowPos3fMESA( float x, float y, float z );
WINGDIAPI void   glWindowPos3dMESA( GLdouble x, GLdouble y, GLdouble z );
WINGDIAPI void   glWindowPos3ivMESA( const GLint *p );
WINGDIAPI void   glWindowPos3svMESA( const GLshort *p );
WINGDIAPI void   glWindowPos3fvMESA( const float *p );
WINGDIAPI void   glWindowPos3dvMESA( const GLdouble *p );
WINGDIAPI void   glWindowPos4iMESA( GLint x, GLint y, GLint z, GLint w );
WINGDIAPI void   glWindowPos4sMESA( GLshort x, GLshort y, GLshort z, GLshort w );
WINGDIAPI void   glWindowPos4fMESA( float x, float y, float z, float w );
WINGDIAPI void   glWindowPos4dMESA( GLdouble x, GLdouble y, GLdouble z, GLdouble w);
WINGDIAPI void   glWindowPos4ivMESA( const GLint *p );
WINGDIAPI void   glWindowPos4svMESA( const GLshort *p );
WINGDIAPI void   glWindowPos4fvMESA( const float *p );
WINGDIAPI void   glWindowPos4dvMESA( const GLdouble *p );
WINGDIAPI void   glResizeBuffersMESA();
/**/


/* 当前文件是D:\Read\fixed.h*/

//#ifndef FIXED_H

//#endif


/* 当前文件是D:\Read\dd.h*/

#ifndef DD_INCLUDED
#define DD_INCLUDED

#endif


//#endif

//#endif
/* 当前文件是D:\Read\alpha.h*/

#ifndef ALPHA_H
#define ALPHA_H


#endif
/* 当前文件是D:\Read\alphabuf.h*/

#ifndef ALPHABUF_H
#define ALPHABUF_H

#endif
/* 当前文件是D:\Read\api.h*/
//#define  
//#ifndef API_H
#define API_H
//#ifdef MULTI_THREADING
#define GET_CONTEXT	GLcontext *CC = gl_get_thread_context()
//#else
#define GET_CONTEXT
//#endif
#define CHECK_CONTEXT							\
if (!CC) {								\
if (getenv("MESA_DEBUG")) {					\
	 fprintf(stderr,"Mesa user error: no rendering context.\n");	\
}									\
return;								\
}
#define CHECK_CONTEXT_RETURN(R)						\
if (!CC) {								\
if (getenv("MESA_DEBUG")) {					\
fprintf(stderr,"Mesa user error: no rendering context.\n");	\
}									\
return (R);							\
}
#define SHORTCUT

#ifndef WINDOWS_NT

#endif
//#endif
/* 当前文件是D:\Read\attrib.h*/

#ifndef ATTRIB_H
#define ATTRIB_h




#endif
/* 当前文件是D:\Read\bitmap.h*/

#ifndef BITMAP_H
#define BITMAP_H



#endif
/* 当前文件是D:\Read\blend.h*/

#ifndef BLEND_H
#define BLEND_H





#endif
/* 当前文件是D:\Read\clip.h*/

#ifndef CLIP_H
#define CLIP_H
#ifdef DEBUG
#  define GL_VIEWCLIP_POINT( V )   gl_viewclip_point( V )
#else
#  define GL_VIEWCLIP_POINT( V )			\
(    (V)[0] <= (V)[3] && (V)[0] >= -(V)[3]		\
&& (V)[1] <= (V)[3] && (V)[1] >= -(V)[3]		\
&& (V)[2] <= (V)[3] && (V)[2] >= -(V)[3] )
#endif

#endif
/* 当前文件是D:\Read\colortab.h*/

#ifndef COLORTAB_H
#define COLORTAB_H

#endif
/* 当前文件是D:\Read\context.h*/

#ifndef CONTEXT_H
#define CONTEXT_H
#ifdef THREADS

#else

#endif

#ifdef PROFILE

#endif
#endif
/* 当前文件是D:\Read\copypix.h*/

#ifndef COPYPIXELS_H
#define COPYPIXELS_H

#endif
/* 当前文件是D:\Read\depth.h*/

#ifndef DEPTH_H
#define DEPTH_H
#define Z_ADDRESS( CTX, X, Y )  \
((CTX)->Buffer->Depth + (CTX)->Buffer->Width * (Y) + (X))

#endif
/* 当前文件是D:\Read\dlist.h*/

#ifndef DLIST_H
#define DLIST_H

#endif
/* 当前文件是D:\Read\drawpix.h*/

#ifndef DRAWPIXELS_H
#define DRAWPIXELS_H

#endif
/* 当前文件是D:\Read\enable.h*/

#ifndef ENABLE_H
#define ENABLE_H

#endif
/* 当前文件是D:\Read\eval.h*/

#ifndef EVAL_H
#define EVAL_H

#endif
/* 当前文件是D:\Read\feedback.h*/

#ifndef FEEDBACK_H
#define FEEDBACK_H
#define FEEDBACK_TOKEN( CTX, T )				\
	if (CTX->Feedback.Count < CTX->Feedback.BufferSize) {	\
	   CTX->Feedback.Buffer[CTX->Feedback.Count] = (T);	\
	}							\
	CTX->Feedback.Count++;










#endif
/* 当前文件是D:\Read\fog.h*/

#ifndef FOG_H
#define FOG_H





#endif
/* 当前文件是D:\Read\get.h*/

#ifndef GET_H
#define GET_H




#endif
/* 当前文件是D:\Read\hash.h*/

#ifndef HASH_H
#define HASH_H
/* 当前文件是D:\Read\gl.h*/

#ifndef GL_H
#define GL_H
#if defined(USE_MGL_NAMESPACE)
#endif
#if (defined(FX) && defined(__WIN32__)) || defined(__CYGWIN32__)
#else

#define CALLBACK
#define WINGDIAPI extern
#endif
#ifdef __cplusplus
extern "C" {

#else
#endif




#ifdef CENTERLINE_CLPP
#define signed
#endif
	
#if defined(__BEOS__) || defined(__QUICKDRAW__)
#endif

#if defined(__BEOS__) || defined(__QUICKDRAW__)
#endif
#define GL_EXT_blend_color		1
#define GL_EXT_blend_logic_op		1
#define GL_EXT_blend_minmax		1
#define GL_EXT_blend_subtract		1
#define GL_EXT_polygon_offset		1
#define GL_EXT_vertex_array		1
#define GL_EXT_texture_object		1
#define GL_EXT_texture3D		1
#define GL_EXT_paletted_texture		1
#define GL_EXT_shared_texture_palette	1
#define GL_EXT_point_parameters		1
#define GL_MESA_window_pos		1
#define GL_MESA_resize_buffers		1
#ifdef macintosh
	#if PRAGMA_IMPORT_SUPPORTED
	#endif
#endif
#ifdef __cplusplus
}
#endif
#endif
struct HashTable;








#endif
/* 当前文件是D:\Read\image.h*/

#ifndef IMAGE_H
#define IMAGE_H







struct gl_image *gl_unpack_image3D( GLcontext *ctx,
GLint width, GLint height,GLint depth,
GLenum srcFormat, GLenum srcType,
const GLvoid *pixels );

#endif
/* 当前文件是D:\Read\light.h*/

#ifndef LIGHT_H
#define LIGHT_H














#endif
/* 当前文件是D:\Read\lines.h*/

#ifndef LINES_H
#define LINES_H



#endif
/* 当前文件是D:\Read\logic.h*/

#ifndef LOGIC_H
#define LOGIC_H





#endif
/* 当前文件是D:\Read\masking.h*/

#ifndef MASKING_H
#define MASKING_H






#endif
/* 当前文件是D:\Read\matrix.h*/

#ifndef MATRIX_H
#define MATRIX_H
















#endif
/* 当前文件是D:\Read\misc.h*/

#ifndef MISC_H
#define MISC_H









#endif
/* 当前文件是D:\Read\mmath.h*/

#ifndef MMATH_H
#define MMATH_H
#if defined(__linux__) && defined(__i386__) && defined(FAST_MATH)

#else
#define START_FAST_MATH
#define END_FAST_MATH
#endif

#ifdef FAST_MATH
#  define GL_SQRT(X)  gl_sqrt(X)
#else
#  define GL_SQRT(X)  sqrt(X)
#endif
#define NORMALIZE_3FV( V )				\
{							\
float len;						\
len = GL_SQRT(V[0]*V[0]+V[1]*V[1]+V[2]*V[2]);	\
if (len>0.0001F) {					\
len = 1.0F / len;					\
V[0] *= len;					\
V[1] *= len;					\
V[2] *= len;					\
}							\
}

#endif
/* 当前文件是D:\Read\pb.h*/

//#ifndef PB_H
#define PB_H


#define PB_INIT( PB, PRIM )		\
	(PB)->count = 0;		\
	(PB)->mono = GL_FALSE;		\
	(PB)->primitive = (PRIM);
#define PB_SET_COLOR( CTX, PB, R, G, B, A )		\
	if ((PB)->color[0]!=(R) || (PB)->color[1]!=(G)	\
	 || (PB)->color[2]!=(B) || (PB)->color[3]!=(A)	\
	 || !(PB)->mono) {				\
		gl_flush_pb( ctx );			\
	}						\
	(PB)->color[0] = R;				\
	(PB)->color[1] = G;				\
	(PB)->color[2] = B;				\
	(PB)->color[3] = A;				\
	(PB)->mono = GL_TRUE;
#define PB_SET_INDEX( CTX, PB, I )		\
	if ((PB)->index!=(I) || !(PB)->mono) {	\
		gl_flush_pb( CTX );		\
	}					\
	(PB)->index = I;			\
	(PB)->mono = GL_TRUE;
#define PB_WRITE_PIXEL( PB, X, Y, Z )		\
	(PB)->x[(PB)->count] = X;		\
	(PB)->y[(PB)->count] = Y;		\
	(PB)->z[(PB)->count] = Z;		\
	(PB)->count++;
#define PB_WRITE_RGBA_PIXEL( PB, X, Y, Z, R, G, B, A )	\
	(PB)->x[(PB)->count] = X;			\
	(PB)->y[(PB)->count] = Y;			\
	(PB)->z[(PB)->count] = Z;			\
	(PB)->r[(PB)->count] = R;			\
	(PB)->g[(PB)->count] = G;			\
	(PB)->b[(PB)->count] = B;			\
	(PB)->a[(PB)->count] = A;			\
	(PB)->count++;
#define PB_WRITE_CI_PIXEL( PB, X, Y, Z, I )	\
	(PB)->x[(PB)->count] = X;		\
	(PB)->y[(PB)->count] = Y;		\
	(PB)->z[(PB)->count] = Z;		\
	(PB)->i[(PB)->count] = I;		\
	(PB)->count++;
#define PB_WRITE_TEX_PIXEL( PB, X, Y, Z, R, G, B, A, S, T, U )	\
	(PB)->x[(PB)->count] = X;				\
	(PB)->y[(PB)->count] = Y;				\
	(PB)->z[(PB)->count] = Z;				\
	(PB)->r[(PB)->count] = R;				\
	(PB)->g[(PB)->count] = G;				\
	(PB)->b[(PB)->count] = B;				\
	(PB)->a[(PB)->count] = A;				\
	(PB)->s[(PB)->count] = S;				\
	(PB)->t[(PB)->count] = T;				\
	(PB)->u[(PB)->count] = U;				\
	(PB)->count++;
#define PB_CHECK_FLUSH( CTX, PB )		\
	if ((PB)->count>=PB_SIZE-MAX_WIDTH) {	\
	   gl_flush_pb( CTX );			\
	}


//#endif
/* 当前文件是D:\Read\pixel.h*/

#ifndef PIXEL_H
#define PIXEL_H











#endif
/* 当前文件是D:\Read\pointers.h*/

#ifndef POINTERS_H
#define POINTERS_H

#endif
/* 当前文件是D:\Read\points.h*/

#ifndef POINTS_H
#define POINTS_H



#endif
/* 当前文件是D:\Read\polygon.h*/

#ifndef POLYGON_H
#define POLYGON_H






#endif
/* 当前文件是D:\Read\rastpos.h*/

#ifndef RASTPOS_H
#define RASTPOS_H


#endif
/* 当前文件是D:\Read\readpix.h*/

#ifndef READPIX_H
#define READPIX_H

#endif
/* 当前文件是D:\Read\rect.h*/

#ifndef RECT_H
#define RECT_H

#endif
/* 当前文件是D:\Read\scissor.h*/

#ifndef SCISSOR_H
#define SCISSOR_H



#endif
/* 当前文件是D:\Read\shade.h*/

#ifndef SHADE_H
#define SHADE_H



#endif
/* 当前文件是D:\Read\span.h*/

#ifndef SPAN_H
#define SPAN_H







#endif
/* 当前文件是D:\Read\stencil.h*/

#ifndef STENCIL_H
#define STENCIL_H












#endif
/* 当前文件是D:\Read\teximage.h*/

#ifndef TEXIMAGE_H
#define TEXIMAGE_H




















#endif
/* 当前文件是D:\Read\texobj.h*/

#ifndef TEXTOBJ_H
#define TEXTOBJ_H









#endif
/* 当前文件是D:\Read\texstate.h*/

#ifndef TEXSTATE_H
#define TEXSTATE_H













#endif
/* 当前文件是D:\Read\texture.h*/

#ifndef TEXTURE_H
#define TEXTURE_H



#endif
/* 当前文件是D:\Read\triangle.h*/

#ifndef TRIANGLES_H
#define TRIANGLES_H

#endif
/* 当前文件是D:\Read\varray.h*/

#ifndef VARRAY_H
#define VARRAY_H















#endif
/* 当前文件是D:\Read\vb.h*/

#ifndef VB_H
#define VB_H



#endif
/* 当前文件是D:\Read\vbfill.h*/

#ifndef VBFILL_H
#define VBFILL_H
#endif
/* 当前文件是D:\Read\vbrender.h*/

#ifndef VBRENDER_H
#define VBRENDER_H


#endif
/* 当前文件是D:\Read\vbxform.h*/

#ifndef VBXFORM_H
#define VBXFORM_H


#endif
/* 当前文件是D:\Read\winpos.h*/

#ifndef WINPOS_H
#define WINPOS_H
#ifndef GL_MESA_window_pos

#endif

#endif
/* 当前文件是D:\Read\xform.h*/

#ifndef XFORM_H
#define XFORM_H
#define TRANSFORM_POINT( Q, M, P )					\
Q[0] = M[0] * P[0] + M[4] * P[1] + M[8] *  P[2] + M[12] * P[3];	\
Q[1] = M[1] * P[0] + M[5] * P[1] + M[9] *  P[2] + M[13] * P[3];	\
Q[2] = M[2] * P[0] + M[6] * P[1] + M[10] * P[2] + M[14] * P[3];	\
Q[3] = M[3] * P[0] + M[7] * P[1] + M[11] * P[2] + M[15] * P[3];
#define TRANSFORM_NORMAL( NX, NY, NZ, N, MAT )		\
NX = N[0] * MAT[0] + N[1] * MAT[1] + N[2] * MAT[2];	\
NY = N[0] * MAT[4] + N[1] * MAT[5] + N[2] * MAT[6];	\
NZ = N[0] * MAT[8] + N[1] * MAT[9] + N[2] * MAT[10];	\




#endif
#endif
#else
#endif
void gl_alloc_accum_buffer( GLcontext *ctx )
{
GLint n;
if (ctx->Buffer->Accum) {
free( ctx->Buffer->Accum );
ctx->Buffer->Accum = NULL;
}
n = ctx->Buffer->Width * ctx->Buffer->Height * 4 * sizeof(GLaccum);
ctx->Buffer->Accum = (GLaccum *) malloc( n );
if (!ctx->Buffer->Accum) {
gl_error( ctx, GL_OUT_OF_MEMORY, "glAccum" );
}
}
void gl_ClearAccum( GLcontext *ctx,
float red, float green, float blue, float alpha )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glAccum" );
return;
}
ctx->Accum.ClearColor[0] = CLAMP( red, -1.0, 1.0 );
ctx->Accum.ClearColor[1] = CLAMP( green, -1.0, 1.0 );
ctx->Accum.ClearColor[2] = CLAMP( blue, -1.0, 1.0 );
ctx->Accum.ClearColor[3] = CLAMP( alpha, -1.0, 1.0 );
}
void gl_Accum( GLcontext *ctx, GLenum op, float value )
{
GLuint xpos, ypos, width, height;
float acc_scale;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glAccum" );
return;
}
if (ctx->Visual->AccumBits==0 || !ctx->Buffer->Accum) {
gl_warning(ctx, "Calling glAccum() without an accumulation buffer");
return;
}
if (sizeof(GLaccum)==1) {
acc_scale = 127.0;
}
else if (sizeof(GLaccum)==2) {
acc_scale = 32767.0;
}
else {
acc_scale = (float) SHRT_MAX;
}
if (ctx->Scissor.Enabled) {
xpos = ctx->Scissor.X;
ypos = ctx->Scissor.Y;
width = ctx->Scissor.Width;
height = ctx->Scissor.Height;
}
else {
xpos = 0;
ypos = 0;
width = ctx->Buffer->Width;
height = ctx->Buffer->Height;
}
switch (op) {
case GL_ADD:
{
	    GLaccum ival, *acc;
	    GLuint i, j;
	    ival = (GLaccum) (value * acc_scale);
	    for (j=0;j<height;j++) {
	       acc = ctx->Buffer->Accum
+ (ypos * ctx->Buffer->Width + xpos) * 4;
	       for (i=0;i<width;i++) {
		  *acc += ival;	  acc++;
		  *acc += ival;	  acc++;
		  *acc += ival;	  acc++;
		  *acc += ival;	  acc++;
	       }
	       ypos++;
	    }
	 }
	 break;
case GL_MULT:
	 {
	    GLaccum *acc;
	    GLuint i, j;
	    for (j=0;j<height;j++) {
	       acc = ctx->Buffer->Accum
+ (ypos * ctx->Buffer->Width + xpos) * 4;
	       for (i=0;i<width;i++) {
		  *acc = (GLaccum) ( (float) *acc * value );	  acc++;
		  *acc = (GLaccum) ( (float) *acc * value );	  acc++;
		  *acc = (GLaccum) ( (float) *acc * value );	  acc++;
		  *acc = (GLaccum) ( (float) *acc * value );	  acc++;
	       }
	       ypos++;
	    }
	 }
	 break;
case GL_ACCUM:
	 {
	    GLaccum *acc;
	    GLubyte red[MAX_WIDTH], green[MAX_WIDTH];
	    GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];
	    float rscale, gscale, bscale, ascale;
	    GLuint i, j;
		struct dd_function_table myd=ctx->Driver;
	    (void) (*ctx->Driver.SetBuffer)( ctx, ctx->Pixel.ReadBuffer );
	    rscale = value * acc_scale * ctx->Visual->InvRedScale;
	    gscale = value * acc_scale * ctx->Visual->InvGreenScale;
	    bscale = value * acc_scale * ctx->Visual->InvBlueScale;
	    ascale = value * acc_scale * ctx->Visual->InvAlphaScale;
	    for (j=0;j<height;j++) {
	       (*ctx->Driver.ReadColorSpan)( ctx, width, xpos, ypos,
red, green, blue, alpha);
	       acc = ctx->Buffer->Accum
+ (ypos * ctx->Buffer->Width + xpos) * 4;
	       for (i=0;i<width;i++) {
		  *acc += (GLaccum) ( (float) red[i]   * rscale );  acc++;
		  *acc += (GLaccum) ( (float) green[i] * gscale );  acc++;
		  *acc += (GLaccum) ( (float) blue[i]  * bscale );  acc++;
		  *acc += (GLaccum) ( (float) alpha[i] * ascale );  acc++;
	       }
	       ypos++;
	    }
	    (void) (*ctx->Driver.SetBuffer)( ctx, ctx->Color.DrawBuffer );
	 }
	 break;
case GL_LOAD:
	 {
	    GLaccum *acc;
	    GLubyte red[MAX_WIDTH], green[MAX_WIDTH];
	    GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];
	    float rscale, gscale, bscale, ascale;
	    GLuint i, j;
	    (void) (*ctx->Driver.SetBuffer)( ctx, ctx->Pixel.ReadBuffer );
	
	    rscale = value * acc_scale * ctx->Visual->InvRedScale;
	    gscale = value * acc_scale * ctx->Visual->InvGreenScale;
	    bscale = value * acc_scale * ctx->Visual->InvBlueScale;
	    ascale = value * acc_scale * ctx->Visual->InvAlphaScale;
	    for (j=0;j<height;j++) {
	       (*ctx->Driver.ReadColorSpan)( ctx, width, xpos, ypos,
red, green, blue, alpha);
	       acc = ctx->Buffer->Accum
+ (ypos * ctx->Buffer->Width + xpos) * 4;
	       for (i=0;i<width;i++) {
		  *acc++ = (GLaccum) ( (float) red[i]   * rscale );
		  *acc++ = (GLaccum) ( (float) green[i] * gscale );
		  *acc++ = (GLaccum) ( (float) blue[i]  * bscale );
		  *acc++ = (GLaccum) ( (float) alpha[i] * ascale );
	       }
	       ypos++;
	    }
	    (void) (*ctx->Driver.SetBuffer)( ctx, ctx->Color.DrawBuffer );
	 }
	 break;
case GL_RETURN:
	 {
	    GLubyte red[MAX_WIDTH], green[MAX_WIDTH];
	    GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];
	    GLaccum *acc;
	    float rscale, gscale, bscale, ascale;
	    GLint rmax, gmax, bmax, amax;
	    GLuint i, j;
	    rscale = value / acc_scale * ctx->Visual->RedScale;
	    gscale = value / acc_scale * ctx->Visual->GreenScale;
	    bscale = value / acc_scale * ctx->Visual->BlueScale;
	    ascale = value / acc_scale * ctx->Visual->AlphaScale;
	    rmax = (GLint) ctx->Visual->RedScale;
	    gmax = (GLint) ctx->Visual->GreenScale;
	    bmax = (GLint) ctx->Visual->BlueScale;
	    amax = (GLint) ctx->Visual->AlphaScale;
	    for (j=0;j<height;j++) {
	       acc = ctx->Buffer->Accum
+ (ypos * ctx->Buffer->Width + xpos) * 4;
	       for (i=0;i<width;i++) {
		  GLint r, g, b, a;
		  r = (GLint) ( (float) (*acc++) * rscale + 0.5F );
		  g = (GLint) ( (float) (*acc++) * gscale + 0.5F );
		  b = (GLint) ( (float) (*acc++) * bscale + 0.5F );
		  a = (GLint) ( (float) (*acc++) * ascale + 0.5F );
		  red[i]   = CLAMP( r, 0, rmax );
		  green[i] = CLAMP( g, 0, gmax );
		  blue[i]  = CLAMP( b, 0, bmax );
		  alpha[i] = CLAMP( a, 0, amax );
	       }
	       (*ctx->Driver.WriteColorSpan)( ctx, width, xpos, ypos,
red, green, blue, alpha, NULL );
	       ypos++;
	    }
	 }
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glAccum" );
}
}
void gl_clear_accum_buffer( GLcontext *ctx )
{
GLuint buffersize;
float acc_scale;
if (ctx->Visual->AccumBits==0) {
return;
}
if (sizeof(GLaccum)==1) {
acc_scale = 127.0;
}
else if (sizeof(GLaccum)==2) {
acc_scale = 32767.0;
}
else {
acc_scale = (float) SHRT_MAX;
}
buffersize = ctx->Buffer->Width * ctx->Buffer->Height;
if (!ctx->Buffer->Accum) {
ctx->Buffer->Accum = (GLaccum *)
	                   malloc( buffersize * 4 * sizeof(GLaccum) );
}
if (ctx->Buffer->Accum) {
if (ctx->Scissor.Enabled) {
	
	 GLaccum r, g, b, a;
	 GLint i, j;
GLint width, height;
GLaccum *row;
	 r = (GLaccum) (ctx->Accum.ClearColor[0] * acc_scale);
	 g = (GLaccum) (ctx->Accum.ClearColor[1] * acc_scale);
	 b = (GLaccum) (ctx->Accum.ClearColor[2] * acc_scale);
	 a = (GLaccum) (ctx->Accum.ClearColor[3] * acc_scale);
width = 4 * (ctx->Buffer->Xmax - ctx->Buffer->Xmin + 1);
height = ctx->Buffer->Ymax - ctx->Buffer->Ymin + 1;
row = ctx->Buffer->Accum
+ 4 * (ctx->Buffer->Ymin * ctx->Buffer->Width
+ ctx->Buffer->Xmin);
for (j=0;j<height;j++) {
for (i=0;i<width;i+=4) {
row[i+0] = r;
row[i+1] = g;
row[i+2] = b;
row[i+3] = a;
	    }
row += 4 * ctx->Buffer->Width;
	 }
}
else {
	
	 if (ctx->Accum.ClearColor[0]==0.0 &&
	     ctx->Accum.ClearColor[1]==0.0 &&
	     ctx->Accum.ClearColor[2]==0.0 &&
	     ctx->Accum.ClearColor[3]==0.0) {
	
	    MEMSET( ctx->Buffer->Accum, 0, buffersize * 4 * sizeof(GLaccum) );
	 }
	 else {
	
	    GLaccum *acc, r, g, b, a;
	    GLuint i;
	    acc = ctx->Buffer->Accum;
	    r = (GLaccum) (ctx->Accum.ClearColor[0] * acc_scale);
	    g = (GLaccum) (ctx->Accum.ClearColor[1] * acc_scale);
	    b = (GLaccum) (ctx->Accum.ClearColor[2] * acc_scale);
	    a = (GLaccum) (ctx->Accum.ClearColor[3] * acc_scale);
	    for (i=0;i<buffersize;i++) {
	       *acc++ = r;
	       *acc++ = g;
	       *acc++ = b;
	       *acc++ = a;
	    }
	 }
}
}
}
/* 当前文件是D:\Read\alpha.c*/

#ifdef PC_HEADER
#else
#endif
void gl_AlphaFunc( GLcontext* ctx, GLenum func, GLclampf ref )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glAlphaFunc" );
return;
}
switch (func) {
case GL_NEVER:
case GL_LESS:
case GL_EQUAL:
case GL_LEQUAL:
case GL_GREATER:
case GL_NOTEQUAL:
case GL_GEQUAL:
case GL_ALWAYS:
ctx->Color.AlphaFunc = func;
ctx->Color.AlphaRef = CLAMP( ref, 0.0F, 1.0F );
ctx->Color.AlphaRefUbyte = (GLubyte) (ctx->Color.AlphaRef
* ctx->Visual->AlphaScale);
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glAlphaFunc(func)" );
break;
}
}
GLint gl_alpha_test( GLcontext* ctx,
GLuint n, const GLubyte alpha[], GLubyte mask[] )
{
GLuint i;
GLubyte ref = ctx->Color.AlphaRefUbyte;
switch (ctx->Color.AlphaFunc) {
case GL_LESS:
for (i=0;i<n;i++) {
	    mask[i] &= (alpha[i] < ref);
	 }
	 return 1;
case GL_LEQUAL:
for (i=0;i<n;i++) {
	    mask[i] &= (alpha[i] <= ref);
	 }
	 return 1;
case GL_GEQUAL:
for (i=0;i<n;i++) {
	    mask[i] &= (alpha[i] >= ref);
	 }
	 return 1;
case GL_GREATER:
for (i=0;i<n;i++) {
	    mask[i] &= (alpha[i] > ref);
	 }
	 return 1;
case GL_NOTEQUAL:
for (i=0;i<n;i++) {
	    mask[i] &= (alpha[i] != ref);
	 }
	 return 1;
case GL_EQUAL:
for (i=0;i<n;i++) {
	    mask[i] &= (alpha[i] == ref);
	 }
	 return 1;
case GL_ALWAYS:
	
	 return 1;
case GL_NEVER:
	 return 0;
default:
	 gl_problem( ctx, "Invalid alpha test in gl_alpha_test" );
return 0;
}
return 1;
}
/* 当前文件是D:\Read\alphabuf.c*/

#ifdef PC_HEADER
#else
#endif
#define ALPHA_ADDR(X,Y)  (ctx->Buffer->Alpha + (Y) * ctx->Buffer->Width + (X))
void gl_alloc_alpha_buffers( GLcontext* ctx )
{
GLint bytes = ctx->Buffer->Width * ctx->Buffer->Height * sizeof(GLubyte);
if (ctx->Visual->FrontAlphaEnabled) {
if (ctx->Buffer->FrontAlpha) {
free( ctx->Buffer->FrontAlpha );
}
ctx->Buffer->FrontAlpha = (GLubyte *) malloc( bytes );
if (!ctx->Buffer->FrontAlpha) {
gl_error( ctx, GL_OUT_OF_MEMORY, "Couldn't allocate front alpha buffer" );
}
}
if (ctx->Visual->BackAlphaEnabled) {
if (ctx->Buffer->BackAlpha) {
free( ctx->Buffer->BackAlpha );
}
ctx->Buffer->BackAlpha = (GLubyte *) malloc( bytes );
if (!ctx->Buffer->BackAlpha) {
gl_error( ctx, GL_OUT_OF_MEMORY, "Couldn't allocate back alpha buffer" );
}
}
if (ctx->Color.DrawBuffer==GL_FRONT) {
ctx->Buffer->Alpha = ctx->Buffer->FrontAlpha;
}
if (ctx->Color.DrawBuffer==GL_BACK) {
ctx->Buffer->Alpha = ctx->Buffer->BackAlpha;
}
}
void gl_clear_alpha_buffers( GLcontext* ctx )
{
GLint buffer;
for (buffer=0;buffer<2;buffer++) {
GLubyte *abuffer = NULL;
if (buffer==0
&& (   ctx->Color.DrawBuffer==GL_FRONT
|| ctx->Color.DrawBuffer==GL_FRONT_AND_BACK)
&& ctx->Visual->FrontAlphaEnabled && ctx->Buffer->FrontAlpha) {
abuffer = ctx->Buffer->FrontAlpha;
}
else if (buffer==1
&& (   ctx->Color.DrawBuffer==GL_BACK
|| ctx->Color.DrawBuffer==GL_FRONT_AND_BACK)
&& ctx->Visual->BackAlphaEnabled && ctx->Buffer->BackAlpha) {
abuffer = ctx->Buffer->BackAlpha;
}
if (abuffer) {
GLubyte aclear = (GLint) (ctx->Color.ClearColor[3]
* ctx->Visual->AlphaScale);
if (ctx->Scissor.Enabled) {
GLint i, j;
for (j=0;j<ctx->Scissor.Height;j++) {
GLubyte *aptr = ALPHA_ADDR(ctx->Buffer->Xmin,
ctx->Buffer->Ymin+j);
for (i=0;i<ctx->Scissor.Width;i++) {
*aptr++ = aclear;
}
}
}
else {
MEMSET( abuffer, aclear, ctx->Buffer->Width*ctx->Buffer->Height );
}
}
}
}
void gl_write_alpha_span( GLcontext* ctx, GLuint n, GLint x, GLint y,
GLubyte alpha[], GLubyte mask[] )
{
GLubyte *aptr = ALPHA_ADDR( x, y );
GLuint i;
if (mask) {
for (i=0;i<n;i++) {
if (mask[i]) {
*aptr = alpha[i];
}
aptr++;
}
}
else {
for (i=0;i<n;i++) {
*aptr++ = alpha[i];
}
}
}
void gl_write_mono_alpha_span( GLcontext* ctx, GLuint n, GLint x, GLint y,
GLubyte alpha, GLubyte mask[] )
{
GLubyte *aptr = ALPHA_ADDR( x, y );
GLuint i;
if (mask) {
for (i=0;i<n;i++) {
if (mask[i]) {
*aptr = alpha;
}
aptr++;
}
}
else {
for (i=0;i<n;i++) {
*aptr++ = alpha;
}
}
}
void gl_write_alpha_pixels( GLcontext* ctx,
GLuint n, const GLint x[], const GLint y[],
const GLubyte alpha[], const GLubyte mask[] )
{
GLuint i;
if (mask) {
for (i=0;i<n;i++) {
if (mask[i]) {
GLubyte *aptr = ALPHA_ADDR( x[i], y[i] );
*aptr = alpha[i];
}
}
}
else {
for (i=0;i<n;i++) {
GLubyte *aptr = ALPHA_ADDR( x[i], y[i] );
*aptr = alpha[i];
}
}
}
void gl_write_mono_alpha_pixels( GLcontext* ctx,
GLuint n, const GLint x[], const GLint y[],
GLubyte alpha, const GLubyte mask[] )
{
GLuint i;
if (mask) {
for (i=0;i<n;i++) {
if (mask[i]) {
GLubyte *aptr = ALPHA_ADDR( x[i], y[i] );
*aptr = alpha;
}
}
}
else {
for (i=0;i<n;i++) {
GLubyte *aptr = ALPHA_ADDR( x[i], y[i] );
*aptr = alpha;
}
}
}
void gl_read_alpha_span( GLcontext* ctx,
GLuint n, GLint x, GLint y, GLubyte alpha[] )
{
GLubyte *aptr = ALPHA_ADDR( x, y );
GLuint i;
for (i=0;i<n;i++) {
alpha[i] = *aptr++;
}
}
void gl_read_alpha_pixels( GLcontext* ctx,
GLuint n, const GLint x[], const GLint y[],
GLubyte alpha[], const GLubyte mask[] )
{
GLuint i;
for (i=0;i<n;i++) {
if (mask[i]) {
GLubyte *aptr = ALPHA_ADDR( x[i], y[i] );
alpha[i] = *aptr;
}
}
}
/* 当前文件是D:\Read\api1.c*/
#define GET_CONTEXT	GLcontext *CC = gl_get_thread_context()
#define CHECK_CONTEXT							\
if (!CC) {								\
if (getenv("MESA_DEBUG")) {					\
	 fprintf(stderr,"Mesa user error: no rendering context.\n");	\
}									\
return;								\
}
#ifdef PC_HEADER
#else
#endif
void   glAccum( GLenum op, float value )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Accum)(CC, op, value);
}
void   glAlphaFunc( GLenum func, GLclampf ref )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.AlphaFunc)(CC, func, ref);
}
GLboolean   glAreTexturesResident( GLsizei n, const GLuint *textures,
								 GLboolean *residences )
{
GET_CONTEXT;
CHECK_CONTEXT_RETURN(GL_FALSE);
return (*CC->API.AreTexturesResident)(CC, n, textures, residences);
}
void   glArrayElement( GLint i )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ArrayElement)(CC, i);
}
void   glBegin( GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Begin)( CC, mode );
}
void   glBindTexture( GLenum target, GLuint texture )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.BindTexture)(CC, target, texture);
}
void   glBitmap( GLsizei width, GLsizei height,
float xorig, float yorig,
float xmove, float ymove,
const GLubyte *bitmap )
{
GET_CONTEXT;
CHECK_CONTEXT;
if (!CC->CompileFlag) {
if (   CC->Unpack.LsbFirst==GL_FALSE
&& CC->Unpack.Alignment==1
&& CC->Unpack.RowLength==0
&& CC->Unpack.SkipPixels==0
&& CC->Unpack.SkipRows==0) {
struct gl_image image;
image.Width = width;
image.Height = height;
image.Components = 0;
image.Type = GL_BITMAP;
image.Format = GL_COLOR_INDEX;
image.Data = (GLvoid *) bitmap;
(*CC->Exec.Bitmap)( CC, width, height, xorig, yorig,
xmove, ymove, &image );
}
else {
struct gl_image *image;
image = gl_unpack_bitmap( CC, width, height, bitmap );
(*CC->Exec.Bitmap)( CC, width, height, xorig, yorig,
xmove, ymove, image );
if (image) {
gl_free_image( image );
}
}
}
else {
struct gl_image *image;
image = gl_unpack_bitmap( CC, width, height, bitmap );
(*CC->API.Bitmap)(CC, width, height, xorig, yorig, xmove, ymove, image );
}
}
void   glBlendFunc( GLenum sfactor, GLenum dfactor )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.BlendFunc)(CC, sfactor, dfactor);
}
void   glCallList( GLuint list )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.CallList)(CC, list);
}
void   glCallLists( GLsizei n, GLenum type, const GLvoid *lists )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.CallLists)(CC, n, type, lists);
}
void   glClear( GLbitfield mask )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Clear)(CC, mask);
}
void   glClearAccum( float red, float green,
			  float blue, float alpha )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ClearAccum)(CC, red, green, blue, alpha);
}
void   glClearIndex( float c )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ClearIndex)(CC, c);
}
void   glClearColor( GLclampf red,
			  GLclampf green,
			  GLclampf blue,
			  GLclampf alpha )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ClearColor)(CC, red, green, blue, alpha);
}
void   glClearDepth( GLclampd depth )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ClearDepth)( CC, depth );
}
void   glClearStencil( GLint s )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ClearStencil)(CC, s);
}
void   glClipPlane( GLenum plane, const GLdouble *equation )
{
float eq[4];
GET_CONTEXT;
CHECK_CONTEXT;
eq[0] = (float) equation[0];
eq[1] = (float) equation[1];
eq[2] = (float) equation[2];
eq[3] = (float) equation[3];
(*CC->API.ClipPlane)(CC, plane, eq );
}
void   glColor3b( GLbyte red, GLbyte green, GLbyte blue )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, BYTE_TO_FLOAT(red), BYTE_TO_FLOAT(green),
BYTE_TO_FLOAT(blue) );
}
void   glColor3d( GLdouble red, GLdouble green, GLdouble blue )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, (float) red, (float) green, (float) blue );
}
void   glColor3f( float red, float green, float blue )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, red, green, blue );
}
void   glColor3i( GLint red, GLint green, GLint blue )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, INT_TO_FLOAT(red), INT_TO_FLOAT(green),
INT_TO_FLOAT(blue) );
}
void   glColor3s( GLshort red, GLshort green, GLshort blue )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, SHORT_TO_FLOAT(red), SHORT_TO_FLOAT(green),
SHORT_TO_FLOAT(blue) );
}
void   glColor3ub( GLubyte red, GLubyte green, GLubyte blue )
{
GET_CONTEXT;
(*CC->API.Color4ub)( CC, red, green, blue, 255 );
}
void   glColor3ui( GLuint red, GLuint green, GLuint blue )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, UINT_TO_FLOAT(red), UINT_TO_FLOAT(green),
UINT_TO_FLOAT(blue) );
}
void   glColor3us( GLushort red, GLushort green, GLushort blue )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, USHORT_TO_FLOAT(red), USHORT_TO_FLOAT(green),
USHORT_TO_FLOAT(blue) );
}
void   glColor4b( GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, BYTE_TO_FLOAT(red), BYTE_TO_FLOAT(green),
BYTE_TO_FLOAT(blue), BYTE_TO_FLOAT(alpha) );
}
void   glColor4d( GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, (float) red, (float) green,
(float) blue, (float) alpha );
}
void   glColor4f( float red, float green, float blue, float alpha )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, red, green, blue, alpha );
}
void   glColor4i( GLint red, GLint green, GLint blue, GLint alpha )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, INT_TO_FLOAT(red), INT_TO_FLOAT(green),
INT_TO_FLOAT(blue), INT_TO_FLOAT(alpha) );
}
void   glColor4s( GLshort red, GLshort green, GLshort blue, GLshort alpha )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, SHORT_TO_FLOAT(red), SHORT_TO_FLOAT(green),
SHORT_TO_FLOAT(blue), SHORT_TO_FLOAT(alpha) );
}
void   glColor4ub( GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha )
{
GET_CONTEXT;
(*CC->API.Color4ub)( CC, red, green, blue, alpha );
}
void   glColor4ui( GLuint red, GLuint green, GLuint blue, GLuint alpha )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, UINT_TO_FLOAT(red), UINT_TO_FLOAT(green),
UINT_TO_FLOAT(blue), UINT_TO_FLOAT(alpha) );
}
void   glColor4us( GLushort red, GLushort green, GLushort blue, GLushort alpha )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, USHORT_TO_FLOAT(red), USHORT_TO_FLOAT(green),
USHORT_TO_FLOAT(blue), USHORT_TO_FLOAT(alpha) );
}
void   glColor3bv( const GLbyte *v )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]),
BYTE_TO_FLOAT(v[2]) );
}
void   glColor3dv( const GLdouble *v )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, (GLdouble) v[0], (GLdouble) v[1], (GLdouble) v[2] );
}
void   glColor3fv( const float *v )
{
GET_CONTEXT;
(*CC->API.Color3fv)( CC, v );
}
void   glColor3iv( const GLint *v )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]),
INT_TO_FLOAT(v[2]) );
}
void   glColor3sv( const GLshort *v )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]),
SHORT_TO_FLOAT(v[2]) );
}
void   glColor3ubv( const GLubyte *v )
{
GET_CONTEXT;
(*CC->API.Color4ub)( CC, v[0], v[1], v[2], 255 );
}
void   glColor3uiv( const GLuint *v )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, UINT_TO_FLOAT(v[0]), UINT_TO_FLOAT(v[1]),
UINT_TO_FLOAT(v[2]) );
}
void   glColor3usv( const GLushort *v )
{
GET_CONTEXT;
(*CC->API.Color3f)( CC, USHORT_TO_FLOAT(v[0]), USHORT_TO_FLOAT(v[1]),
USHORT_TO_FLOAT(v[2]) );
}
void   glColor4bv( const GLbyte *v )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]),
BYTE_TO_FLOAT(v[2]), BYTE_TO_FLOAT(v[3]) );
}
void   glColor4dv( const GLdouble *v )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, (GLdouble) v[0], (GLdouble) v[1],
(GLdouble) v[2], (GLdouble) v[3] );
}
void   glColor4fv( const float *v )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, v[0], v[1], v[2], v[3] );
}
void   glColor4iv( const GLint *v )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]),
INT_TO_FLOAT(v[2]), INT_TO_FLOAT(v[3]) );
}
void   glColor4sv( const GLshort *v )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]),
SHORT_TO_FLOAT(v[2]), SHORT_TO_FLOAT(v[3]) );
}
void   glColor4ubv( const GLubyte *v )
{
GET_CONTEXT;
(*CC->API.Color4ubv)( CC, v );
}
void   glColor4uiv( const GLuint *v )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, UINT_TO_FLOAT(v[0]), UINT_TO_FLOAT(v[1]),
UINT_TO_FLOAT(v[2]), UINT_TO_FLOAT(v[3]) );
}
void   glColor4usv( const GLushort *v )
{
GET_CONTEXT;
(*CC->API.Color4f)( CC, USHORT_TO_FLOAT(v[0]), USHORT_TO_FLOAT(v[1]),
USHORT_TO_FLOAT(v[2]), USHORT_TO_FLOAT(v[3]) );
}
void   glColorMask( GLboolean red, GLboolean green,
			 GLboolean blue, GLboolean alpha )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ColorMask)(CC, red, green, blue, alpha);
}
void   glColorMaterial( GLenum face, GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ColorMaterial)(CC, face, mode);
}
void   glColorPointer( GLint size, GLenum type, GLsizei stride,
					 const GLvoid *ptr )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ColorPointer)(CC, size, type, stride, ptr);
}
void   glColorTableEXT( GLenum target, GLenum internalFormat,
GLsizei width, GLenum format, GLenum type,
const GLvoid *table )
{
struct gl_image *image;
GET_CONTEXT;
CHECK_CONTEXT;
image = gl_unpack_image( CC, width, 1, format, type, table );
(*CC->API.ColorTable)( CC, target, internalFormat, image );
if (image->RefCount == 0)
gl_free_image(image);
}
void   glColorSubTableEXT( GLenum target, GLsizei start, GLsizei count,
GLenum format, GLenum type,
const GLvoid *data )
{
struct gl_image *image;
GET_CONTEXT;
CHECK_CONTEXT;
image = gl_unpack_image( CC, count, 1, format, type, data );
(*CC->API.ColorSubTable)( CC, target, start, image );
if (image->RefCount == 0)
gl_free_image(image);
}
void   glCopyPixels( GLint x, GLint y, GLsizei width, GLsizei height,
			  GLenum type )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.CopyPixels)(CC, x, y, width, height, type);
}
void   glCopyTexImage1D( GLenum target, GLint level,
GLenum internalformat,
GLint x, GLint y,
GLsizei width, GLint border )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.CopyTexImage1D)( CC, target, level, internalformat,
								 x, y, width, border );
}
void   glCopyTexImage2D( GLenum target, GLint level,
GLenum internalformat,
GLint x, GLint y,
GLsizei width, GLsizei height, GLint border )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.CopyTexImage2D)( CC, target, level, internalformat,
x, y, width, height, border );
}
void   glCopyTexSubImage1D( GLenum target, GLint level,
GLint xoffset, GLint x, GLint y,
GLsizei width )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.CopyTexSubImage1D)( CC, target, level, xoffset, x, y, width );
}
void   glCopyTexSubImage2D( GLenum target, GLint level,
GLint xoffset, GLint yoffset,
GLint x, GLint y,
GLsizei width, GLsizei height )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.CopyTexSubImage2D)( CC, target, level, xoffset, yoffset,
x, y, width, height );
}
void   glCullFace( GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.CullFace)(CC, mode);
}
void   glDepthFunc( GLenum func )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.DepthFunc)( CC, func );
}
void   glDepthMask( GLboolean flag )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.DepthMask)( CC, flag );
}
void   glDepthRange( GLclampd near_val, GLclampd far_val )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.DepthRange)( CC, near_val, far_val );
}
void   glDeleteLists( GLuint list, GLsizei range )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.DeleteLists)(CC, list, range);
}
void   glDeleteTextures( GLsizei n, const GLuint *textures)
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.DeleteTextures)(CC, n, textures);
}
void   glDisable( GLenum cap )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Disable)( CC, cap );
}
void   glDisableClientState( GLenum cap )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.DisableClientState)( CC, cap );
}
void   glDrawArrays( GLenum mode, GLint first, GLsizei count )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.DrawArrays)(CC, mode, first, count);
}
void   glDrawBuffer( GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.DrawBuffer)(CC, mode);
}
void   glDrawElements( GLenum mode, GLsizei count,
GLenum type, const GLvoid *indices )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.DrawElements)( CC, mode, count, type, indices );
}
void   glDrawPixels( GLsizei width, GLsizei height,
GLenum format, GLenum type, const GLvoid *pixels )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.DrawPixels)( CC, width, height, format, type, pixels );
}
void   glEnable( GLenum cap )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Enable)( CC, cap );
}
void   glEnableClientState( GLenum cap )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EnableClientState)( CC, cap );
}
void   glEnd( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.End)( CC );
}
void   glEndList( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EndList)(CC);
}
void   glEvalCoord1d( GLdouble u )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalCoord1f)( CC, (float) u );
}
void   glEvalCoord1f( float u )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalCoord1f)( CC, u );
}
void   glEvalCoord1dv( const GLdouble *u )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalCoord1f)( CC, (float) *u );
}
void   glEvalCoord1fv( const float *u )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalCoord1f)( CC, (float) *u );
}
void   glEvalCoord2d( GLdouble u, GLdouble v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalCoord2f)( CC, (float) u, (float) v );
}
void   glEvalCoord2f( float u, float v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalCoord2f)( CC, u, v );
}
void   glEvalCoord2dv( const GLdouble *u )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalCoord2f)( CC, (float) u[0], (float) u[1] );
}
void   glEvalCoord2fv( const float *u )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalCoord2f)( CC, u[0], u[1] );
}
void   glEvalPoint1( GLint i )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalPoint1)( CC, i );
}
void   glEvalPoint2( GLint i, GLint j )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalPoint2)( CC, i, j );
}
void   glEvalMesh1( GLenum mode, GLint i1, GLint i2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalMesh1)( CC, mode, i1, i2 );
}
void   glEdgeFlag( GLboolean flag )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EdgeFlag)(CC, flag);
}
void   glEdgeFlagv( const GLboolean *flag )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EdgeFlag)(CC, *flag);
}
void   glEdgeFlagPointer( GLsizei stride, const GLboolean *ptr )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EdgeFlagPointer)(CC, stride, ptr);
}
void   glEvalMesh2( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EvalMesh2)( CC, mode, i1, i2, j1, j2 );
}
void   glFeedbackBuffer( GLsizei size, GLenum type, float *buffer )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.FeedbackBuffer)(CC, size, type, buffer);
}
void   glFinish( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Finish)(CC);
}
void   glFlush( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Flush)(CC);
}
void   glFogf( GLenum pname, float param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Fogfv)(CC, pname, &param);
}
void   glFogi( GLenum pname, GLint param )
{
float fparam = (float) param;
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Fogfv)(CC, pname, &fparam);
}
void   glFogfv( GLenum pname, const float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Fogfv)(CC, pname, params);
}
void   glFogiv( GLenum pname, const GLint *params )
{
float p[4];
GET_CONTEXT;
CHECK_CONTEXT;
switch (pname) {
case GL_FOG_MODE:
case GL_FOG_DENSITY:
case GL_FOG_START:
case GL_FOG_END:
case GL_FOG_INDEX:
	 p[0] = (float) *params;
	 break;
case GL_FOG_COLOR:
	 p[0] = INT_TO_FLOAT( params[0] );
	 p[1] = INT_TO_FLOAT( params[1] );
	 p[2] = INT_TO_FLOAT( params[2] );
	 p[3] = INT_TO_FLOAT( params[3] );
	 break;
default:
;
}
(*CC->API.Fogfv)( CC, pname, p );
}
void   glFrontFace( GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.FrontFace)(CC, mode);
}
void   glFrustum( GLdouble left, GLdouble right,
GLdouble bottom, GLdouble top,
GLdouble nearval, GLdouble farval )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Frustum)(CC, left, right, bottom, top, nearval, farval);
}
GLuint   glGenLists( GLsizei range )
{
GET_CONTEXT;
CHECK_CONTEXT_RETURN(0);
return (*CC->API.GenLists)(CC, range);
}
void   glGenTextures( GLsizei n, GLuint *textures )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GenTextures)(CC, n, textures);
}
void   glGetBooleanv( GLenum pname, GLboolean *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetBooleanv)(CC, pname, params);
}
void   glGetClipPlane( GLenum plane, GLdouble *equation )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetClipPlane)(CC, plane, equation);
}
void   glGetColorTableEXT( GLenum target, GLenum format,
GLenum type, GLvoid *table )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetColorTable)(CC, target, format, type, table);
}
void   glGetColorTableParameterivEXT( GLenum target, GLenum pname,
GLint *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetColorTableParameteriv)(CC, target, pname, params);
}
void   glGetColorTableParameterfvEXT( GLenum target, GLenum pname,
float *params )
{
GLint iparams;
glGetColorTableParameterivEXT( target, pname, &iparams );
*params = (float) iparams;
}
void   glGetDoublev( GLenum pname, GLdouble *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetDoublev)(CC, pname, params);
}
GLenum   glGetError( void )
{
GET_CONTEXT;
if (!CC) {
return GL_NO_ERROR;
}
return (*CC->API.GetError)(CC);
}
void   glGetFloatv( GLenum pname, float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetFloatv)(CC, pname, params);
}
void   glGetIntegerv( GLenum pname, GLint *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetIntegerv)(CC, pname, params);
}
void   glGetLightfv( GLenum light, GLenum pname, float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetLightfv)(CC, light, pname, params);
}
void   glGetLightiv( GLenum light, GLenum pname, GLint *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetLightiv)(CC, light, pname, params);
}
void   glGetMapdv( GLenum target, GLenum query, GLdouble *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetMapdv)( CC, target, query, v );
}
void   glGetMapfv( GLenum target, GLenum query, float *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetMapfv)( CC, target, query, v );
}
void   glGetMapiv( GLenum target, GLenum query, GLint *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetMapiv)( CC, target, query, v );
}
void   glGetMaterialfv( GLenum face, GLenum pname, float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetMaterialfv)(CC, face, pname, params);
}
void   glGetMaterialiv( GLenum face, GLenum pname, GLint *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetMaterialiv)(CC, face, pname, params);
}
void   glGetPixelMapfv( GLenum map, float *values )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetPixelMapfv)(CC, map, values);
}
void   glGetPixelMapuiv( GLenum map, GLuint *values )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetPixelMapuiv)(CC, map, values);
}
void   glGetPixelMapusv( GLenum map, GLushort *values )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetPixelMapusv)(CC, map, values);
}
void   glGetPointerv( GLenum pname, GLvoid **params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetPointerv)(CC, pname, params);
}
void   glGetPolygonStipple( GLubyte *mask )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetPolygonStipple)(CC, mask);
}
const GLubyte *   glGetString( GLenum name )
{
GET_CONTEXT;
CHECK_CONTEXT_RETURN(NULL);
return (*CC->API.GetString)(CC, name);
}
void   glGetTexEnvfv( GLenum target, GLenum pname, float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetTexEnvfv)(CC, target, pname, params);
}
void   glGetTexEnviv( GLenum target, GLenum pname, GLint *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetTexEnviv)(CC, target, pname, params);
}
void   glGetTexGeniv( GLenum coord, GLenum pname, GLint *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetTexGeniv)(CC, coord, pname, params);
}
void   glGetTexGendv( GLenum coord, GLenum pname, GLdouble *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetTexGendv)(CC, coord, pname, params);
}
void   glGetTexGenfv( GLenum coord, GLenum pname, float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetTexGenfv)(CC, coord, pname, params);
}
void   glGetTexImage( GLenum target, GLint level, GLenum format,
GLenum type, GLvoid *pixels )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetTexImage)(CC, target, level, format, type, pixels);
}
void   glGetTexLevelParameterfv( GLenum target, GLint level,
GLenum pname, float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetTexLevelParameterfv)(CC, target, level, pname, params);
}
void   glGetTexLevelParameteriv( GLenum target, GLint level,
GLenum pname, GLint *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetTexLevelParameteriv)(CC, target, level, pname, params);
}
void   glGetTexParameterfv( GLenum target, GLenum pname, float *params)
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetTexParameterfv)(CC, target, pname, params);
}
void   glGetTexParameteriv( GLenum target, GLenum pname, GLint *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetTexParameteriv)(CC, target, pname, params);
}
void   glHint( GLenum target, GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Hint)(CC, target, mode);
}
void   glIndexd( GLdouble c )
{
GET_CONTEXT;
(*CC->API.Indexf)( CC, (float) c );
}
void   glIndexf( float c )
{
GET_CONTEXT;
(*CC->API.Indexf)( CC, c );
}
void   glIndexi( GLint c )
{
GET_CONTEXT;
(*CC->API.Indexi)( CC, c );
}
void   glIndexs( GLshort c )
{
GET_CONTEXT;
(*CC->API.Indexi)( CC, (GLint) c );
}
#ifdef GL_VERSION_1_1
void   glIndexub( GLubyte c )
{
GET_CONTEXT;
(*CC->API.Indexi)( CC, (GLint) c );
}
#endif
void   glIndexdv( const GLdouble *c )
{
GET_CONTEXT;
(*CC->API.Indexf)( CC, (float) *c );
}
void   glIndexfv( const float *c )
{
GET_CONTEXT;
(*CC->API.Indexf)( CC, *c );
}
void   glIndexiv( const GLint *c )
{
GET_CONTEXT;
(*CC->API.Indexi)( CC, *c );
}
void   glIndexsv( const GLshort *c )
{
GET_CONTEXT;
(*CC->API.Indexi)( CC, (GLint) *c );
}
#ifdef GL_VERSION_1_1
void   glIndexubv( const GLubyte *c )
{
GET_CONTEXT;
(*CC->API.Indexi)( CC, (GLint) *c );
}
#endif
void   glIndexMask( GLuint mask )
{
GET_CONTEXT;
(*CC->API.IndexMask)(CC, mask);
}
void   glIndexPointer( GLenum type, GLsizei stride, const GLvoid *ptr )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.IndexPointer)(CC, type, stride, ptr);
}
void   glInterleavedArrays( GLenum format, GLsizei stride,
const GLvoid *pointer )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.InterleavedArrays)( CC, format, stride, pointer );
}
void   glInitNames( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.InitNames)(CC);
}
GLboolean   glIsList( GLuint list )
{
GET_CONTEXT;
CHECK_CONTEXT_RETURN(GL_FALSE);
return (*CC->API.IsList)(CC, list);
}
GLboolean   glIsTexture( GLuint texture )
{
GET_CONTEXT;
CHECK_CONTEXT_RETURN(GL_FALSE);
return (*CC->API.IsTexture)(CC, texture);
}
void   glLightf( GLenum light, GLenum pname, float param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Lightfv)( CC, light, pname, &param, 1 );
}
void   glLighti( GLenum light, GLenum pname, GLint param )
{
float fparam = (float) param;
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Lightfv)( CC, light, pname, &fparam, 1 );
}
void   glLightfv( GLenum light, GLenum pname, const float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Lightfv)( CC, light, pname, params, 4 );
}
void   glLightiv( GLenum light, GLenum pname, const GLint *params )
{
float fparam[4];
GET_CONTEXT;
CHECK_CONTEXT;
switch (pname) {
case GL_AMBIENT:
case GL_DIFFUSE:
case GL_SPECULAR:
fparam[0] = INT_TO_FLOAT( params[0] );
fparam[1] = INT_TO_FLOAT( params[1] );
fparam[2] = INT_TO_FLOAT( params[2] );
fparam[3] = INT_TO_FLOAT( params[3] );
break;
case GL_POSITION:
fparam[0] = (float) params[0];
fparam[1] = (float) params[1];
fparam[2] = (float) params[2];
fparam[3] = (float) params[3];
break;
case GL_SPOT_DIRECTION:
fparam[0] = (float) params[0];
fparam[1] = (float) params[1];
fparam[2] = (float) params[2];
break;
case GL_SPOT_EXPONENT:
	  case GL_SPOT_CUTOFF:
case GL_CONSTANT_ATTENUATION:
case GL_LINEAR_ATTENUATION:
case GL_QUADRATIC_ATTENUATION:
fparam[0] = (float) params[0];
break;
default:
		
		 ;
}
(*CC->API.Lightfv)( CC, light, pname, fparam, 4 );
}
void   glLightModelf( GLenum pname, float param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.LightModelfv)( CC, pname, &param );
}
void   glLightModeli( GLenum pname, GLint param )
{
float fparam[4];
GET_CONTEXT;
CHECK_CONTEXT;
fparam[0] = (float) param;
(*CC->API.LightModelfv)( CC, pname, fparam );
}
void   glLightModelfv( GLenum pname, const float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.LightModelfv)( CC, pname, params );
}
void   glLightModeliv( GLenum pname, const GLint *params )
{
float fparam[4];
GET_CONTEXT;
CHECK_CONTEXT;
switch (pname) {
case GL_LIGHT_MODEL_AMBIENT:
fparam[0] = INT_TO_FLOAT( params[0] );
fparam[1] = INT_TO_FLOAT( params[1] );
fparam[2] = INT_TO_FLOAT( params[2] );
fparam[3] = INT_TO_FLOAT( params[3] );
break;
case GL_LIGHT_MODEL_LOCAL_VIEWER:
case GL_LIGHT_MODEL_TWO_SIDE:
fparam[0] = (float) params[0];
break;
default:
;
}
(*CC->API.LightModelfv)( CC, pname, fparam );
}
void   glLineWidth( float width )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.LineWidth)(CC, width);
}
void   glLineStipple( GLint factor, GLushort pattern )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.LineStipple)(CC, factor, pattern);
}
void   glListBase( GLuint base )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ListBase)(CC, base);
}
void   glLoadIdentity( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.LoadIdentity)( CC );
}
void   glLoadMatrixd( const GLdouble *m )
{
float fm[16];
GLuint i;
GET_CONTEXT;
CHECK_CONTEXT;
for (i=0;i<16;i++) {
	  fm[i] = (float) m[i];
}
(*CC->API.LoadMatrixf)( CC, fm );
}
void   glLoadMatrixf( const float *m )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.LoadMatrixf)( CC, m );
}
void   glLoadName( GLuint name )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.LoadName)(CC, name);
}
void   glLogicOp( GLenum opcode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.LogicOp)(CC, opcode);
}
void   glMap1d( GLenum target, GLdouble u1, GLdouble u2, GLint stride,
GLint order, const GLdouble *points )
{
float *pnts;
GLboolean retain;
GET_CONTEXT;
CHECK_CONTEXT;
pnts = gl_copy_map_points1d( target, stride, order, points );
retain = CC->CompileFlag;
(*CC->API.Map1f)( CC, target, u1, u2, stride, order, pnts, retain );
}
void   glMap1f( GLenum target, float u1, float u2, GLint stride,
GLint order, const float *points )
{
float *pnts;
GLboolean retain;
GET_CONTEXT;
CHECK_CONTEXT;
pnts = gl_copy_map_points1f( target, stride, order, points );
retain = CC->CompileFlag;
(*CC->API.Map1f)( CC, target, u1, u2, stride, order, pnts, retain );
}
void   glMap2d( GLenum target,
GLdouble u1, GLdouble u2, GLint ustride, GLint uorder,
GLdouble v1, GLdouble v2, GLint vstride, GLint vorder,
const GLdouble *points )
{
float *pnts;
GLboolean retain;
GET_CONTEXT;
CHECK_CONTEXT;
pnts = gl_copy_map_points2d( target, ustride, uorder,
vstride, vorder, points );
retain = CC->CompileFlag;
(*CC->API.Map2f)( CC, target, u1, u2, ustride, uorder,
v1, v2, vstride, vorder, pnts, retain );
}
void   glMap2f( GLenum target,
float u1, float u2, GLint ustride, GLint uorder,
float v1, float v2, GLint vstride, GLint vorder,
const float *points )
{
float *pnts;
GLboolean retain;
GET_CONTEXT;
CHECK_CONTEXT;
pnts = gl_copy_map_points2f( target, ustride, uorder,
vstride, vorder, points );
retain = CC->CompileFlag;
(*CC->API.Map2f)( CC, target, u1, u2, ustride, uorder,
v1, v2, vstride, vorder, pnts, retain );
}
void   glMapGrid1d( GLint un, GLdouble u1, GLdouble u2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.MapGrid1f)( CC, un, (float) u1, (float) u2 );
}
void   glMapGrid1f( GLint un, float u1, float u2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.MapGrid1f)( CC, un, u1, u2 );
}
void   glMapGrid2d( GLint un, GLdouble u1, GLdouble u2,
GLint vn, GLdouble v1, GLdouble v2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.MapGrid2f)( CC, un, (float) u1, (float) u2,
vn, (float) v1, (float) v2 );
}
void   glMapGrid2f( GLint un, float u1, float u2,
GLint vn, float v1, float v2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.MapGrid2f)( CC, un, u1, u2, vn, v1, v2 );
}
void   glMaterialf( GLenum face, GLenum pname, float param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Materialfv)( CC, face, pname, &param );
}
void   glMateriali( GLenum face, GLenum pname, GLint param )
{
float fparam[4];
GET_CONTEXT;
CHECK_CONTEXT;
fparam[0] = (float) param;
(*CC->API.Materialfv)( CC, face, pname, fparam );
}
void   glMaterialfv( GLenum face, GLenum pname, const float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Materialfv)( CC, face, pname, params );
}
void   glMaterialiv( GLenum face, GLenum pname, const GLint *params )
{
float fparam[4];
GET_CONTEXT;
CHECK_CONTEXT;
switch (pname) {
case GL_AMBIENT:
case GL_DIFFUSE:
case GL_SPECULAR:
case GL_EMISSION:
case GL_AMBIENT_AND_DIFFUSE:
fparam[0] = INT_TO_FLOAT( params[0] );
fparam[1] = INT_TO_FLOAT( params[1] );
fparam[2] = INT_TO_FLOAT( params[2] );
fparam[3] = INT_TO_FLOAT( params[3] );
break;
case GL_SHININESS:
fparam[0] = (float) params[0];
break;
case GL_COLOR_INDEXES:
fparam[0] = (float) params[0];
fparam[1] = (float) params[1];
fparam[2] = (float) params[2];
break;
default:
;
}
(*CC->API.Materialfv)( CC, face, pname, fparam );
}
void   glMatrixMode( GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.MatrixMode)( CC, mode );
}
void   glMultMatrixd( const GLdouble *m )
{
float fm[16];
GLuint i;
GET_CONTEXT;
CHECK_CONTEXT;
for (i=0;i<16;i++) {
	  fm[i] = (float) m[i];
}
(*CC->API.MultMatrixf)( CC, fm );
}
void   glMultMatrixf( const float *m )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.MultMatrixf)( CC, m );
}
void   glNewList( GLuint list, GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.NewList)(CC, list, mode);
}
void   glNormal3b( GLbyte nx, GLbyte ny, GLbyte nz )
{
GET_CONTEXT;
(*CC->API.Normal3f)( CC, BYTE_TO_FLOAT(nx),
BYTE_TO_FLOAT(ny), BYTE_TO_FLOAT(nz) );
}
void   glNormal3d( GLdouble nx, GLdouble ny, GLdouble nz )
{
float fx, fy, fz;
GET_CONTEXT;
if (ABSD(nx)<0.00001)   fx = 0.0F;   else  fx = nx;
if (ABSD(ny)<0.00001)   fy = 0.0F;   else  fy = ny;
if (ABSD(nz)<0.00001)   fz = 0.0F;   else  fz = nz;
(*CC->API.Normal3f)( CC, fx, fy, fz );
}
void   glNormal3f( float nx, float ny, float nz )
{
GET_CONTEXT;
#ifdef SHORTCUT
if (CC->CompileFlag) {
(*CC->Save.Normal3f)( CC, nx, ny, nz );
}
else {
CC->Current.Normal[0] = nx;
CC->Current.Normal[1] = ny;
CC->Current.Normal[2] = nz;
CC->VB->MonoNormal = GL_FALSE;
}
#else
(*CC->API.Normal3f)( CC, nx, ny, nz );
#endif
}
void   glNormal3i( GLint nx, GLint ny, GLint nz )
{
GET_CONTEXT;
(*CC->API.Normal3f)( CC, INT_TO_FLOAT(nx),
INT_TO_FLOAT(ny), INT_TO_FLOAT(nz) );
}
void   glNormal3s( GLshort nx, GLshort ny, GLshort nz )
{
GET_CONTEXT;
(*CC->API.Normal3f)( CC, SHORT_TO_FLOAT(nx),
SHORT_TO_FLOAT(ny), SHORT_TO_FLOAT(nz) );
}
void   glNormal3bv( const GLbyte *v )
{
GET_CONTEXT;
(*CC->API.Normal3f)( CC, BYTE_TO_FLOAT(v[0]),
BYTE_TO_FLOAT(v[1]), BYTE_TO_FLOAT(v[2]) );
}
void   glNormal3dv( const GLdouble *v )
{
float fx, fy, fz;
GET_CONTEXT;
if (ABSD(v[0])<0.00001)   fx = 0.0F;   else  fx = v[0];
if (ABSD(v[1])<0.00001)   fy = 0.0F;   else  fy = v[1];
if (ABSD(v[2])<0.00001)   fz = 0.0F;   else  fz = v[2];
(*CC->API.Normal3f)( CC, fx, fy, fz );
}
void   glNormal3fv( const float *v )
{
GET_CONTEXT;
#ifdef SHORTCUT
if (CC->CompileFlag) {
(*CC->Save.Normal3fv)( CC, v );
}
else {
float *n = CC->Current.Normal;
n[0] = v[0];
n[1] = v[1];
n[2] = v[2];
CC->VB->MonoNormal = GL_FALSE;
}
#else
(*CC->API.Normal3fv)( CC, v );
#endif
}
void   glNormal3iv( const GLint *v )
{
GET_CONTEXT;
(*CC->API.Normal3f)( CC, INT_TO_FLOAT(v[0]),
INT_TO_FLOAT(v[1]), INT_TO_FLOAT(v[2]) );
}
void   glNormal3sv( const GLshort *v )
{
GET_CONTEXT;
(*CC->API.Normal3f)( CC, SHORT_TO_FLOAT(v[0]),
SHORT_TO_FLOAT(v[1]), SHORT_TO_FLOAT(v[2]) );
}
void   glNormalPointer( GLenum type, GLsizei stride, const GLvoid *ptr )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.NormalPointer)(CC, type, stride, ptr);
}
/* 当前文件是D:\Read\api2.c*/

#ifdef PC_HEADER
#else
#endif
void   glOrtho( GLdouble left, GLdouble right,
GLdouble bottom, GLdouble top,
GLdouble nearval, GLdouble farval )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Ortho)(CC, left, right, bottom, top, nearval, farval);
}
void   glPassThrough( float token )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PassThrough)(CC, token);
}
void   glPixelMapfv( GLenum map, GLint mapsize, const float *values )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PixelMapfv)( CC, map, mapsize, values );
}
void   glPixelMapuiv( GLenum map, GLint mapsize, const GLuint *values )
{
float fvalues[MAX_PIXEL_MAP_TABLE];
GLuint i;
GET_CONTEXT;
CHECK_CONTEXT;
if (map==GL_PIXEL_MAP_I_TO_I || map==GL_PIXEL_MAP_S_TO_S) {
for (i=0;i<mapsize;i++) {
fvalues[i] = (float) values[i];
}
}
else {
for (i=0;i<mapsize;i++) {
fvalues[i] = UINT_TO_FLOAT( values[i] );
}
}
(*CC->API.PixelMapfv)( CC, map, mapsize, fvalues );
}
void   glPixelMapusv( GLenum map, GLint mapsize, const GLushort *values )
{
float fvalues[MAX_PIXEL_MAP_TABLE];
GLuint i;
GET_CONTEXT;
CHECK_CONTEXT;
if (map==GL_PIXEL_MAP_I_TO_I || map==GL_PIXEL_MAP_S_TO_S) {
for (i=0;i<mapsize;i++) {
fvalues[i] = (float) values[i];
}
}
else {
for (i=0;i<mapsize;i++) {
fvalues[i] = USHORT_TO_FLOAT( values[i] );
}
}
(*CC->API.PixelMapfv)( CC, map, mapsize, fvalues );
}
void   glPixelStoref( GLenum pname, float param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PixelStorei)( CC, pname, (GLint) param );
}
void   glPixelStorei( GLenum pname, GLint param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PixelStorei)( CC, pname, param );
}
void   glPixelTransferf( GLenum pname, float param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PixelTransferf)(CC, pname, param);
}
void   glPixelTransferi( GLenum pname, GLint param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PixelTransferf)(CC, pname, (float) param);
}
void   glPixelZoom( float xfactor, float yfactor )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PixelZoom)(CC, xfactor, yfactor);
}
void   glPointSize( float size )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PointSize)(CC, size);
}
void   glPolygonMode( GLenum face, GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PolygonMode)(CC, face, mode);
}
void   glPolygonOffset( float factor, float units )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PolygonOffset)( CC, factor, units );
}
#ifdef GL_EXT_polygon_offset
void   glPolygonOffsetEXT( float factor, float bias )
{
glPolygonOffset( factor, bias * DEPTH_SCALE );
}
#endif
void   glPolygonStipple( const GLubyte *mask )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PolygonStipple)(CC, mask);
}
void   glPopAttrib( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PopAttrib)(CC);
}
void   glPopClientAttrib( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PopClientAttrib)(CC);
}
void   glPopMatrix( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PopMatrix)( CC );
}
void   glPopName( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PopName)(CC);
}
void   glPrioritizeTextures( GLsizei n, const GLuint *textures,
const GLclampf *priorities )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PrioritizeTextures)(CC, n, textures, priorities);
}
void   glPushMatrix( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PushMatrix)( CC );
}
void   glRasterPos2d( GLdouble x, GLdouble y )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) x, (float) y, 0.0F, 1.0F );
}
void   glRasterPos2f( float x, float y )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) x, (float) y, 0.0F, 1.0F );
}
void   glRasterPos2i( GLint x, GLint y )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) x, (float) y, 0.0F, 1.0F );
}
void   glRasterPos2s( GLshort x, GLshort y )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) x, (float) y, 0.0F, 1.0F );
}
void   glRasterPos3d( GLdouble x, GLdouble y, GLdouble z )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) x, (float) y, (float) z, 1.0F );
}
void   glRasterPos3f( float x, float y, float z )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) x, (float) y, (float) z, 1.0F );
}
void   glRasterPos3i( GLint x, GLint y, GLint z )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) x, (float) y, (float) z, 1.0F );
}
void   glRasterPos3s( GLshort x, GLshort y, GLshort z )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) x, (float) y, (float) z, 1.0F );
}
void   glRasterPos4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) x, (float) y,
							   (float) z, (float) w );
}
void   glRasterPos4f( float x, float y, float z, float w )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, x, y, z, w );
}
void   glRasterPos4i( GLint x, GLint y, GLint z, GLint w )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) x, (float) y,
(float) z, (float) w );
}
void   glRasterPos4s( GLshort x, GLshort y, GLshort z, GLshort w )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) x, (float) y,
(float) z, (float) w );
}
void   glRasterPos2dv( const GLdouble *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) v[0], (float) v[1], 0.0F, 1.0F );
}
void   glRasterPos2fv( const float *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) v[0], (float) v[1], 0.0F, 1.0F );
}
void   glRasterPos2iv( const GLint *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) v[0], (float) v[1], 0.0F, 1.0F );
}
void   glRasterPos2sv( const GLshort *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) v[0], (float) v[1], 0.0F, 1.0F );
}
void   glRasterPos3dv( const GLdouble *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) v[0], (float) v[1],
(float) v[2], 1.0F );
}
void   glRasterPos3fv( const float *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) v[0], (float) v[1],
(float) v[2], 1.0F );
}
void   glRasterPos3iv( const GLint *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) v[0], (float) v[1],
(float) v[2], 1.0F );
}
void   glRasterPos3sv( const GLshort *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) v[0], (float) v[1],
(float) v[2], 1.0F );
}
void   glRasterPos4dv( const GLdouble *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) v[0], (float) v[1],
(float) v[2], (float) v[3] );
}
void   glRasterPos4fv( const float *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, v[0], v[1], v[2], v[3] );
}
void   glRasterPos4iv( const GLint *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) v[0], (float) v[1],
(float) v[2], (float) v[3] );
}
void   glRasterPos4sv( const GLshort *v )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.RasterPos4f)( CC, (float) v[0], (float) v[1],
(float) v[2], (float) v[3] );
}
void   glReadBuffer( GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ReadBuffer)( CC, mode );
}
void   glReadPixels( GLint x, GLint y, GLsizei width, GLsizei height,
		   GLenum format, GLenum type, GLvoid *pixels )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ReadPixels)( CC, x, y, width, height, format, type, pixels );
}
void   glRectd( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Rectf)( CC, (float) x1, (float) y1,
(float) x2, (float) y2 );
}
void   glRectf( float x1, float y1, float x2, float y2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Rectf)( CC, x1, y1, x2, y2 );
}
void   glRecti( GLint x1, GLint y1, GLint x2, GLint y2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Rectf)( CC, (float) x1, (float) y1,
(float) x2, (float) y2 );
}
void   glRects( GLshort x1, GLshort y1, GLshort x2, GLshort y2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Rectf)( CC, (float) x1, (float) y1,
(float) x2, (float) y2 );
}
void   glRectdv( const GLdouble *v1, const GLdouble *v2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Rectf)(CC, (float) v1[0], (float) v1[1],
(float) v2[0], (float) v2[1]);
}
void   glRectfv( const float *v1, const float *v2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Rectf)(CC, v1[0], v1[1], v2[0], v2[1]);
}
void   glRectiv( const GLint *v1, const GLint *v2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Rectf)( CC, (float) v1[0], (float) v1[1],
(float) v2[0], (float) v2[1] );
}
void   glRectsv( const GLshort *v1, const GLshort *v2 )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Rectf)(CC, (float) v1[0], (float) v1[1],
(float) v2[0], (float) v2[1]);
}
void   glScissor( GLint x, GLint y, GLsizei width, GLsizei height)
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Scissor)(CC, x, y, width, height);
}
GLboolean   glIsEnabled( GLenum cap )
{
GET_CONTEXT;
CHECK_CONTEXT_RETURN(GL_FALSE);
return (*CC->API.IsEnabled)( CC, cap );
}
void   glPushAttrib( GLbitfield mask )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PushAttrib)(CC, mask);
}
void   glPushClientAttrib( GLbitfield mask )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PushClientAttrib)(CC, mask);
}
void   glPushName( GLuint name )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PushName)(CC, name);
}
GLint   glRenderMode( GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT_RETURN(0);
return (*CC->API.RenderMode)(CC, mode);
}
void   glRotated( GLdouble angle, GLdouble x, GLdouble y, GLdouble z )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Rotatef)( CC, (float) angle,
(float) x, (float) y, (float) z );
}
void   glRotatef( float angle, float x, float y, float z )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Rotatef)( CC, angle, x, y, z );
}
void   glSelectBuffer( GLsizei size, GLuint *buffer )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.SelectBuffer)(CC, size, buffer);
}
void   glScaled( GLdouble x, GLdouble y, GLdouble z )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Scalef)( CC, (float) x, (float) y, (float) z );
}
void   glScalef( float x, float y, float z )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Scalef)( CC, x, y, z );
}
void   glShadeModel( GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ShadeModel)(CC, mode);
}
void   glStencilFunc( GLenum func, GLint ref, GLuint mask )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.StencilFunc)(CC, func, ref, mask);
}
void   glStencilMask( GLuint mask )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.StencilMask)(CC, mask);
}
void   glStencilOp( GLenum fail, GLenum zfail, GLenum zpass )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.StencilOp)(CC, fail, zfail, zpass);
}
void   glTexCoord1d( GLdouble s )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) s, 0.0, 0.0, 1.0 );
}
void   glTexCoord1f( float s )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, s, 0.0, 0.0, 1.0 );
}
void   glTexCoord1i( GLint s )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) s, 0.0, 0.0, 1.0 );
}
void   glTexCoord1s( GLshort s )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) s, 0.0, 0.0, 1.0 );
}
void   glTexCoord2d( GLdouble s, GLdouble t )
{
GET_CONTEXT;
(*CC->API.TexCoord2f)( CC, (float) s, (float) t );
}
void   glTexCoord2f( float s, float t )
{
GET_CONTEXT;
(*CC->API.TexCoord2f)( CC, s, t );
}
void   glTexCoord2i( GLint s, GLint t )
{
GET_CONTEXT;
(*CC->API.TexCoord2f)( CC, (float) s, (float) t );
}
void   glTexCoord2s( GLshort s, GLshort t )
{
GET_CONTEXT;
(*CC->API.TexCoord2f)( CC, (float) s, (float) t );
}
void   glTexCoord3d( GLdouble s, GLdouble t, GLdouble r )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) s, (float) t, (float) r, 1.0 );
}
void   glTexCoord3f( float s, float t, float r )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, s, t, r, 1.0 );
}
void   glTexCoord3i( GLint s, GLint t, GLint r )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) s, (float) t,
(float) r, 1.0 );
}
void   glTexCoord3s( GLshort s, GLshort t, GLshort r )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) s, (float) t,
(float) r, 1.0 );
}
void   glTexCoord4d( GLdouble s, GLdouble t, GLdouble r, GLdouble q )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) s, (float) t,
(float) r, (float) q );
}
void   glTexCoord4f( float s, float t, float r, float q )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, s, t, r, q );
}
void   glTexCoord4i( GLint s, GLint t, GLint r, GLint q )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) s, (float) t,
(float) r, (float) q );
}
void   glTexCoord4s( GLshort s, GLshort t, GLshort r, GLshort q )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) s, (float) t,
(float) r, (float) q );
}
void   glTexCoord1dv( const GLdouble *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) *v, 0.0, 0.0, 1.0 );
}
void   glTexCoord1fv( const float *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, *v, 0.0, 0.0, 1.0 );
}
void   glTexCoord1iv( const GLint *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, *v, 0.0, 0.0, 1.0 );
}
void   glTexCoord1sv( const GLshort *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) *v, 0.0, 0.0, 1.0 );
}
void   glTexCoord2dv( const GLdouble *v )
{
GET_CONTEXT;
(*CC->API.TexCoord2f)( CC, (float) v[0], (float) v[1] );
}
void   glTexCoord2fv( const float *v )
{
GET_CONTEXT;
(*CC->API.TexCoord2f)( CC, v[0], v[1] );
}
void   glTexCoord2iv( const GLint *v )
{
GET_CONTEXT;
(*CC->API.TexCoord2f)( CC, (float) v[0], (float) v[1] );
}
void   glTexCoord2sv( const GLshort *v )
{
GET_CONTEXT;
(*CC->API.TexCoord2f)( CC, (float) v[0], (float) v[1] );
}
void   glTexCoord3dv( const GLdouble *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) v[0], (float) v[1],
(float) v[2], 1.0 );
}
void   glTexCoord3fv( const float *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, v[0], v[1], v[2], 1.0 );
}
void   glTexCoord3iv( const GLint *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) v[0], (float) v[1],
(float) v[2], 1.0 );
}
void   glTexCoord3sv( const GLshort *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) v[0], (float) v[1],
(float) v[2], 1.0 );
}
void   glTexCoord4dv( const GLdouble *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) v[0], (float) v[1],
(float) v[2], (float) v[3] );
}
void   glTexCoord4fv( const float *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, v[0], v[1], v[2], v[3] );
}
void   glTexCoord4iv( const GLint *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) v[0], (float) v[1],
(float) v[2], (float) v[3] );
}
void   glTexCoord4sv( const GLshort *v )
{
GET_CONTEXT;
(*CC->API.TexCoord4f)( CC, (float) v[0], (float) v[1],
(float) v[2], (float) v[3] );
}
void   glTexCoordPointer( GLint size, GLenum type, GLsizei stride,
const GLvoid *ptr )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexCoordPointer)(CC, size, type, stride, ptr);
}
void   glTexGend( GLenum coord, GLenum pname, GLdouble param )
{
float p = (float) param;
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexGenfv)( CC, coord, pname, &p );
}
void   glTexGenf( GLenum coord, GLenum pname, float param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexGenfv)( CC, coord, pname, &param );
}
void   glTexGeni( GLenum coord, GLenum pname, GLint param )
{
float p = (float) param;
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexGenfv)( CC, coord, pname, &p );
}
void   glTexGendv( GLenum coord, GLenum pname, const GLdouble *params )
{
float p[4];
GET_CONTEXT;
CHECK_CONTEXT;
p[0] = params[0];
p[1] = params[1];
p[2] = params[2];
p[3] = params[3];
(*CC->API.TexGenfv)( CC, coord, pname, p );
}
void   glTexGeniv( GLenum coord, GLenum pname, const GLint *params )
{
float p[4];
GET_CONTEXT;
CHECK_CONTEXT;
p[0] = params[0];
p[1] = params[1];
p[2] = params[2];
p[3] = params[3];
(*CC->API.TexGenfv)( CC, coord, pname, p );
}
void   glTexGenfv( GLenum coord, GLenum pname, const float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexGenfv)( CC, coord, pname, params );
}
void   glTexEnvf( GLenum target, GLenum pname, float param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexEnvfv)( CC, target, pname, &param );
}
void   glTexEnvi( GLenum target, GLenum pname, GLint param )
{
float p[4];
p[0] = (float) param;
p[1] = p[2] = p[3] = 0.0;
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexEnvfv)( CC, target, pname, p );
}
void   glTexEnvfv( GLenum target, GLenum pname, const float *param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexEnvfv)( CC, target, pname, param );
}
void   glTexEnviv( GLenum target, GLenum pname, const GLint *param )
{
float p[4];
p[0] = INT_TO_FLOAT( param[0] );
p[1] = INT_TO_FLOAT( param[1] );
p[2] = INT_TO_FLOAT( param[2] );
p[3] = INT_TO_FLOAT( param[3] );
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexEnvfv)( CC, target, pname, p );
}
void   glTexImage1D( GLenum target, GLint level, GLint internalformat,
GLsizei width, GLint border,
GLenum format, GLenum type, const GLvoid *pixels )
{
struct gl_image *teximage;
GET_CONTEXT;
CHECK_CONTEXT;
teximage = gl_unpack_image( CC, width, 1, format, type, pixels );
(*CC->API.TexImage1D)( CC, target, level, internalformat,
width, border, format, type, teximage );
}
void   glTexImage2D( GLenum target, GLint level, GLint internalformat,
GLsizei width, GLsizei height, GLint border,
GLenum format, GLenum type, const GLvoid *pixels )
{
struct gl_image *teximage;
#if defined(FX) && defined(__WIN32__)
GLvoid *newpixels=NULL;
GLsizei newwidth,newheight;
GLint x,y;
static GLint leveldif=0;
static GLuint lasttexobj=0xffffff;
#endif
GET_CONTEXT;
CHECK_CONTEXT;
#if defined(FX) && defined(__WIN32__)
newpixels=NULL;
if(CC->Texture.Current2D->Name!=lasttexobj) {
lasttexobj=CC->Texture.Current2D->Name;
leveldif=0;
}
if((format==GL_COLOR_INDEX) && (internalformat==1))
internalformat=GL_COLOR_INDEX8_EXT;
if(width>256 || height >256) {
while(width>256 || height >256) {
newwidth=width/2;
newheight=height/2;
leveldif++;
fprintf(stderr,"Scaling: %dx%d -> %dx%d\n",width,height,newwidth,newheight);
newpixels=malloc((newwidth+4)*newheight*4);
for(y=0;y<newheight;y++)
	for(x=0;x<newwidth;x++)
	  ((GLubyte *)newpixels)[x+y*newwidth]=((GLubyte *)pixels)[x*2+y*width*2];
if(newpixels)
	free(pixels);
pixels=newpixels;
width=newwidth;
height=newheight;
}
level=0;
} else
level-=leveldif;
#endif
teximage = gl_unpack_image( CC, width, height, format, type, pixels );
(*CC->API.TexImage2D)( CC, target, level, internalformat,
			 width, height, border, format, type, teximage );
#if defined(FX) && defined(__WIN32__)
if(newpixels)
free(newpixels);
#endif
}
void   glTexParameterf( GLenum target, GLenum pname, float param )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexParameterfv)( CC, target, pname, &param );
}
void   glTexParameteri( GLenum target, GLenum pname, GLint param )
{
float fparam[4];
fparam[0] = (float) param;
fparam[1] = fparam[2] = fparam[3] = 0.0;
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexParameterfv)( CC, target, pname, fparam );
}
void   glTexParameterfv( GLenum target, GLenum pname, const float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexParameterfv)( CC, target, pname, params );
}
void   glTexParameteriv( GLenum target, GLenum pname, const GLint *params )
{
float p[4];
GET_CONTEXT;
CHECK_CONTEXT;
if (pname==GL_TEXTURE_BORDER_COLOR) {
p[0] = INT_TO_FLOAT( params[0] );
p[1] = INT_TO_FLOAT( params[1] );
p[2] = INT_TO_FLOAT( params[2] );
p[3] = INT_TO_FLOAT( params[3] );
}
else {
p[0] = (float) params[0];
p[1] = (float) params[1];
p[2] = (float) params[2];
p[3] = (float) params[3];
}
(*CC->API.TexParameterfv)( CC, target, pname, p );
}
void   glTexSubImage1D( GLenum target, GLint level, GLint xoffset,
GLsizei width, GLenum format,
GLenum type, const GLvoid *pixels )
{
struct gl_image *image;
GET_CONTEXT;
CHECK_CONTEXT;
image = gl_unpack_texsubimage( CC, width, 1, 1, format, type, pixels );
(*CC->API.TexSubImage1D)( CC, target, level, xoffset, width,
format, type, image );
}
void   glTexSubImage2D( GLenum target, GLint level,
GLint xoffset, GLint yoffset,
GLsizei width, GLsizei height,
GLenum format, GLenum type,
const GLvoid *pixels )
{
struct gl_image *image;
GET_CONTEXT;
CHECK_CONTEXT;
image = gl_unpack_texsubimage( CC, width, height, 1, format, type, pixels );
(*CC->API.TexSubImage2D)( CC, target, level, xoffset, yoffset,
width, height, format, type, image );
}
void   glTranslated( GLdouble x, GLdouble y, GLdouble z )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Translatef)( CC, (float) x, (float) y, (float) z );
}
void   glTranslatef( float x, float y, float z )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.Translatef)( CC, x, y, z );
}
void   glVertex2d( GLdouble x, GLdouble y )
{
GET_CONTEXT;
(*CC->API.Vertex2f)( CC, (float) x, (float) y );
}
void   glVertex2f( float x, float y )
{
GET_CONTEXT;
(*CC->API.Vertex2f)( CC, x, y );
}
void   glVertex2i( GLint x, GLint y )
{
GET_CONTEXT;
(*CC->API.Vertex2f)( CC, (float) x, (float) y );
}
void   glVertex2s( GLshort x, GLshort y )
{
GET_CONTEXT;
(*CC->API.Vertex2f)( CC, (float) x, (float) y );
}
void   glVertex3d( GLdouble x, GLdouble y, GLdouble z )
{
GET_CONTEXT;
(*CC->API.Vertex3f)( CC, (float) x, (float) y, (float) z );
}
void   glVertex3f( float x, float y, float z )
{
GET_CONTEXT;
(*CC->API.Vertex3f)( CC, x, y, z );
}
void   glVertex3i( GLint x, GLint y, GLint z )
{
GET_CONTEXT;
(*CC->API.Vertex3f)( CC, (float) x, (float) y, (float) z );
}
void   glVertex3s( GLshort x, GLshort y, GLshort z )
{
GET_CONTEXT;
(*CC->API.Vertex3f)( CC, (float) x, (float) y, (float) z );
}
void   glVertex4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
GET_CONTEXT;
(*CC->API.Vertex4f)( CC, (float) x, (float) y,
(float) z, (float) w );
}
void   glVertex4f( float x, float y, float z, float w )
{
GET_CONTEXT;
(*CC->API.Vertex4f)( CC, x, y, z, w );
}
void   glVertex4i( GLint x, GLint y, GLint z, GLint w )
{
GET_CONTEXT;
(*CC->API.Vertex4f)( CC, (float) x, (float) y,
(float) z, (float) w );
}
void   glVertex4s( GLshort x, GLshort y, GLshort z, GLshort w )
{
GET_CONTEXT;
(*CC->API.Vertex4f)( CC, (float) x, (float) y,
(float) z, (float) w );
}
void   glVertex2dv( const GLdouble *v )
{
GET_CONTEXT;
(*CC->API.Vertex2f)( CC, (float) v[0], (float) v[1] );
}
void   glVertex2fv( const float *v )
{
GET_CONTEXT;
(*CC->API.Vertex2f)( CC, v[0], v[1] );
}
void   glVertex2iv( const GLint *v )
{
GET_CONTEXT;
(*CC->API.Vertex2f)( CC, (float) v[0], (float) v[1] );
}
void   glVertex2sv( const GLshort *v )
{
GET_CONTEXT;
(*CC->API.Vertex2f)( CC, (float) v[0], (float) v[1] );
}
void   glVertex3dv( const GLdouble *v )
{
GET_CONTEXT;
(*CC->API.Vertex3f)( CC, (float) v[0], (float) v[1], (float) v[2] );
}
void   glVertex3fv( const float *v )
{
GET_CONTEXT;
(*CC->API.Vertex3fv)( CC, v );
}
void   glVertex3iv( const GLint *v )
{
GET_CONTEXT;
(*CC->API.Vertex3f)( CC, (float) v[0], (float) v[1], (float) v[2] );
}
void   glVertex3sv( const GLshort *v )
{
GET_CONTEXT;
(*CC->API.Vertex3f)( CC, (float) v[0], (float) v[1], (float) v[2] );
}
void   glVertex4dv( const GLdouble *v )
{
GET_CONTEXT;
(*CC->API.Vertex4f)( CC, (float) v[0], (float) v[1],
(float) v[2], (float) v[3] );
}
void   glVertex4fv( const float *v )
{
GET_CONTEXT;
(*CC->API.Vertex4f)( CC, v[0], v[1], v[2], v[3] );
}
void   glVertex4iv( const GLint *v )
{
GET_CONTEXT;
(*CC->API.Vertex4f)( CC, (float) v[0], (float) v[1],
(float) v[2], (float) v[3] );
}
void   glVertex4sv( const GLshort *v )
{
GET_CONTEXT;
(*CC->API.Vertex4f)( CC, (float) v[0], (float) v[1],
(float) v[2], (float) v[3] );
}
void   glVertexPointer( GLint size, GLenum type, GLsizei stride,
const GLvoid *ptr )
{
GET_CONTEXT;
(*CC->API.VertexPointer)(CC, size, type, stride, ptr);
}
void   glViewport( GLint x, GLint y, GLsizei width, GLsizei height )
{
GET_CONTEXT;
(*CC->API.Viewport)( CC, x, y, width, height );
}
void   glBlendEquationEXT( GLenum mode )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.BlendEquation)(CC, mode);
}
void   glBlendColorEXT( GLclampf red, GLclampf green,
GLclampf blue, GLclampf alpha )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.BlendColor)(CC, red, green, blue, alpha);
}
void   glVertexPointerEXT( GLint size, GLenum type, GLsizei stride,
GLsizei count, const GLvoid *ptr )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.VertexPointer)(CC, size, type, stride, ptr);
}
void   glNormalPointerEXT( GLenum type, GLsizei stride, GLsizei count,
const GLvoid *ptr )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.NormalPointer)(CC, type, stride, ptr);
}
void   glColorPointerEXT( GLint size, GLenum type, GLsizei stride,
GLsizei count, const GLvoid *ptr )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ColorPointer)(CC, size, type, stride, ptr);
}
void   glIndexPointerEXT( GLenum type, GLsizei stride,
GLsizei count, const GLvoid *ptr )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.IndexPointer)(CC, type, stride, ptr);
}
void   glTexCoordPointerEXT( GLint size, GLenum type, GLsizei stride,
GLsizei count, const GLvoid *ptr )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.TexCoordPointer)(CC, size, type, stride, ptr);
}
void   glEdgeFlagPointerEXT( GLsizei stride, GLsizei count,
const GLboolean *ptr )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.EdgeFlagPointer)(CC, stride, ptr);
}
void   glGetPointervEXT( GLenum pname, GLvoid **params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.GetPointerv)(CC, pname, params);
}
void   glArrayElementEXT( GLint i )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ArrayElement)(CC, i);
}
void   glDrawArraysEXT( GLenum mode, GLint first, GLsizei count )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.DrawArrays)(CC, mode, first, count);
}
GLboolean glAreTexturesResidentEXT( GLsizei n, const GLuint *textures,
GLboolean *residences )
{
return glAreTexturesResident( n, textures, residences );
}
void   glBindTextureEXT( GLenum target, GLuint texture )
{
glBindTexture( target, texture );
}
void   glDeleteTexturesEXT( GLsizei n, const GLuint *textures)
{
glDeleteTextures( n, textures );
}
void   glGenTexturesEXT( GLsizei n, GLuint *textures )
{
glGenTextures( n, textures );
}
GLboolean glIsTextureEXT( GLuint texture )
{
return glIsTexture( texture );
}
void   glPrioritizeTexturesEXT( GLsizei n, const GLuint *textures,
const GLclampf *priorities )
{
glPrioritizeTextures( n, textures, priorities );
}
void   glCopyTexSubImage3DEXT( GLenum target, GLint level, GLint xoffset,
GLint yoffset, GLint zoffset,
GLint x, GLint y, GLsizei width,
GLsizei height )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.CopyTexSubImage3DEXT)( CC, target, level, xoffset, yoffset,
zoffset, x, y, width, height );
}
void   glTexImage3DEXT( GLenum target, GLint level, GLenum internalformat,
GLsizei width, GLsizei height, GLsizei depth,
GLint border, GLenum format, GLenum type,
const GLvoid *pixels )
{
struct gl_image *teximage;
GET_CONTEXT;
CHECK_CONTEXT;
teximage = gl_unpack_image3D( CC, width, height, depth, format, type, pixels);
(*CC->API.TexImage3DEXT)( CC, target, level, internalformat,
width, height, depth, border, format, type,
teximage );
}
void   glTexSubImage3DEXT( GLenum target, GLint level, GLint xoffset,
GLint yoffset, GLint zoffset, GLsizei width,
GLsizei height, GLsizei depth, GLenum format,
GLenum type, const GLvoid *pixels )
{
struct gl_image *image;
GET_CONTEXT;
CHECK_CONTEXT;
image = gl_unpack_texsubimage( CC, width, height, depth, format, type, pixels );
(*CC->API.TexSubImage3DEXT)( CC, target, level, xoffset, yoffset, zoffset,
width, height, depth, format, type, image );
}
void   glPointParameterfEXT( GLenum pname, float param )
{
float params[3];
GET_CONTEXT;
CHECK_CONTEXT;
params[0] = param;
params[1] = 0.0;
params[2] = 0.0;
(*CC->API.PointParameterfvEXT)(CC, pname, params);
}
void   glPointParameterfvEXT( GLenum pname, const float *params )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.PointParameterfvEXT)(CC, pname, params);
}
#ifdef GL_MESA_window_pos
void   glWindowPos4fMESA( float x, float y, float z, float w )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.WindowPos4fMESA)( CC, x, y, z, w );
}
#else
#endif
void   glWindowPos2iMESA( GLint x, GLint y )
{
glWindowPos4fMESA( (float) x, (float) y, 0.0F, 1.0F );
}
void   glWindowPos2sMESA( GLshort x, GLshort y )
{
glWindowPos4fMESA( (float) x, (float) y, 0.0F, 1.0F );
}
void   glWindowPos2fMESA( float x, float y )
{
glWindowPos4fMESA( x, y, 0.0F, 1.0F );
}
void   glWindowPos2dMESA( GLdouble x, GLdouble y )
{
glWindowPos4fMESA( (float) x, (float) y, 0.0F, 1.0F );
}
void   glWindowPos2ivMESA( const GLint *p )
{
glWindowPos4fMESA( (float) p[0], (float) p[1], 0.0F, 1.0F );
}
void   glWindowPos2svMESA( const GLshort *p )
{
glWindowPos4fMESA( (float) p[0], (float) p[1], 0.0F, 1.0F );
}
void   glWindowPos2fvMESA( const float *p )
{
glWindowPos4fMESA( p[0], p[1], 0.0F, 1.0F );
}
void   glWindowPos2dvMESA( const GLdouble *p )
{
glWindowPos4fMESA( (float) p[0], (float) p[1], 0.0F, 1.0F );
}
void   glWindowPos3iMESA( GLint x, GLint y, GLint z )
{
glWindowPos4fMESA( (float) x, (float) y, (float) z, 1.0F );
}
void   glWindowPos3sMESA( GLshort x, GLshort y, GLshort z )
{
glWindowPos4fMESA( (float) x, (float) y, (float) z, 1.0F );
}
void   glWindowPos3fMESA( float x, float y, float z )
{
glWindowPos4fMESA( x, y, z, 1.0F );
}
void   glWindowPos3dMESA( GLdouble x, GLdouble y, GLdouble z )
{
glWindowPos4fMESA( (float) x, (float) y, (float) z, 1.0F );
}
void   glWindowPos3ivMESA( const GLint *p )
{
glWindowPos4fMESA( (float) p[0], (float) p[1], (float) p[2], 1.0F );
}
void   glWindowPos3svMESA( const GLshort *p )
{
glWindowPos4fMESA( (float) p[0], (float) p[1], (float) p[2], 1.0F );
}
void   glWindowPos3fvMESA( const float *p )
{
glWindowPos4fMESA( p[0], p[1], p[2], 1.0F );
}
void   glWindowPos3dvMESA( const GLdouble *p )
{
glWindowPos4fMESA( (float) p[0], (float) p[1], (float) p[2], 1.0F );
}
void   glWindowPos4iMESA( GLint x, GLint y, GLint z, GLint w )
{
glWindowPos4fMESA( (float) x, (float) y, (float) z, (float) w );
}
void   glWindowPos4sMESA( GLshort x, GLshort y, GLshort z, GLshort w )
{
glWindowPos4fMESA( (float) x, (float) y, (float) z, (float) w );
}
void   glWindowPos4dMESA( GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
glWindowPos4fMESA( (float) x, (float) y, (float) z, (float) w );
}
void   glWindowPos4ivMESA( const GLint *p )
{
glWindowPos4fMESA( (float) p[0], (float) p[1],
(float) p[2], (float) p[3] );
}
void   glWindowPos4svMESA( const GLshort *p )
{
glWindowPos4fMESA( (float) p[0], (float) p[1],
(float) p[2], (float) p[3] );
}
void   glWindowPos4fvMESA( const float *p )
{
glWindowPos4fMESA( p[0], p[1], p[2], p[3] );
}
void   glWindowPos4dvMESA( const GLdouble *p )
{
glWindowPos4fMESA( (float) p[0], (float) p[1],
(float) p[2], (float) p[3] );
}
void   glResizeBuffersMESA( void )
{
GET_CONTEXT;
CHECK_CONTEXT;
(*CC->API.ResizeBuffersMESA)( CC );
}
/* 当前文件是D:\Read\attrib.c*/

#ifdef PC_HEADER
#else
#endif
#define MALLOC_STRUCT(T)  (struct T *) malloc( sizeof(struct T) )
static struct gl_attrib_node *new_attrib_node( GLbitfield kind )
{
struct gl_attrib_node *an;
an = (struct gl_attrib_node *) malloc( sizeof(struct gl_attrib_node) );
if (an) {
an->kind = kind;
}
return an;
}
void gl_PushAttrib( GLcontext* ctx, GLbitfield mask )
{
struct gl_attrib_node *newnode;
struct gl_attrib_node *head;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPushAttrib" );
return;
}
if (ctx->AttribStackDepth>=MAX_ATTRIB_STACK_DEPTH) {
gl_error( ctx, GL_STACK_OVERFLOW, "glPushAttrib" );
return;
}
head = NULL;
if (mask & GL_ACCUM_BUFFER_BIT) {
struct gl_accum_attrib *attr;
attr = MALLOC_STRUCT( gl_accum_attrib );
MEMCPY( attr, &ctx->Accum, sizeof(struct gl_accum_attrib) );
newnode = new_attrib_node( GL_ACCUM_BUFFER_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_COLOR_BUFFER_BIT) {
struct gl_colorbuffer_attrib *attr;
attr = MALLOC_STRUCT( gl_colorbuffer_attrib );
MEMCPY( attr, &ctx->Color, sizeof(struct gl_colorbuffer_attrib) );
newnode = new_attrib_node( GL_COLOR_BUFFER_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_CURRENT_BIT) {
struct gl_current_attrib *attr;
attr = MALLOC_STRUCT( gl_current_attrib );
MEMCPY( attr, &ctx->Current, sizeof(struct gl_current_attrib) );
newnode = new_attrib_node( GL_CURRENT_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_DEPTH_BUFFER_BIT) {
struct gl_depthbuffer_attrib *attr;
attr = MALLOC_STRUCT( gl_depthbuffer_attrib );
MEMCPY( attr, &ctx->Depth, sizeof(struct gl_depthbuffer_attrib) );
newnode = new_attrib_node( GL_DEPTH_BUFFER_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_ENABLE_BIT) {
struct gl_enable_attrib *attr;
GLuint i;
attr = MALLOC_STRUCT( gl_enable_attrib );
attr->AlphaTest = ctx->Color.AlphaEnabled;
attr->AutoNormal = ctx->Eval.AutoNormal;
attr->Blend = ctx->Color.BlendEnabled;
for (i=0;i<MAX_CLIP_PLANES;i++) {
attr->ClipPlane[i] = ctx->Transform.ClipEnabled[i];
}
attr->ColorMaterial = ctx->Light.ColorMaterialEnabled;
attr->CullFace = ctx->Polygon.CullFlag;
attr->DepthTest = ctx->Depth.Test;
attr->Dither = ctx->Color.DitherFlag;
attr->Fog = ctx->Fog.Enabled;
for (i=0;i<MAX_LIGHTS;i++) {
attr->Light[i] = ctx->Light.Light[i].Enabled;
}
attr->Lighting = ctx->Light.Enabled;
attr->LineSmooth = ctx->Line.SmoothFlag;
attr->LineStipple = ctx->Line.StippleFlag;
attr->IndexLogicOp = ctx->Color.IndexLogicOpEnabled;
attr->ColorLogicOp = ctx->Color.ColorLogicOpEnabled;
attr->Map1Color4 = ctx->Eval.Map1Color4;
attr->Map1Index = ctx->Eval.Map1Index;
attr->Map1Normal = ctx->Eval.Map1Normal;
attr->Map1TextureCoord1 = ctx->Eval.Map1TextureCoord1;
attr->Map1TextureCoord2 = ctx->Eval.Map1TextureCoord2;
attr->Map1TextureCoord3 = ctx->Eval.Map1TextureCoord3;
attr->Map1TextureCoord4 = ctx->Eval.Map1TextureCoord4;
attr->Map1Vertex3 = ctx->Eval.Map1Vertex3;
attr->Map1Vertex4 = ctx->Eval.Map1Vertex4;
attr->Map2Color4 = ctx->Eval.Map2Color4;
attr->Map2Index = ctx->Eval.Map2Index;
attr->Map2Normal = ctx->Eval.Map2Normal;
attr->Map2TextureCoord1 = ctx->Eval.Map2TextureCoord1;
attr->Map2TextureCoord2 = ctx->Eval.Map2TextureCoord2;
attr->Map2TextureCoord3 = ctx->Eval.Map2TextureCoord3;
attr->Map2TextureCoord4 = ctx->Eval.Map2TextureCoord4;
attr->Map2Vertex3 = ctx->Eval.Map2Vertex3;
attr->Map2Vertex4 = ctx->Eval.Map2Vertex4;
attr->Normalize = ctx->Transform.Normalize;
attr->PointSmooth = ctx->Point.SmoothFlag;
attr->PolygonOffsetPoint = ctx->Polygon.OffsetPoint;
attr->PolygonOffsetLine = ctx->Polygon.OffsetLine;
attr->PolygonOffsetFill = ctx->Polygon.OffsetFill;
attr->PolygonSmooth = ctx->Polygon.SmoothFlag;
attr->PolygonStipple = ctx->Polygon.StippleFlag;
attr->Scissor = ctx->Scissor.Enabled;
attr->Stencil = ctx->Stencil.Enabled;
attr->Texture = ctx->Texture.Enabled;
attr->TexGen = ctx->Texture.TexGenEnabled;
newnode = new_attrib_node( GL_ENABLE_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_EVAL_BIT) {
struct gl_eval_attrib *attr;
attr = MALLOC_STRUCT( gl_eval_attrib );
MEMCPY( attr, &ctx->Eval, sizeof(struct gl_eval_attrib) );
newnode = new_attrib_node( GL_EVAL_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_FOG_BIT) {
struct gl_fog_attrib *attr;
attr = MALLOC_STRUCT( gl_fog_attrib );
MEMCPY( attr, &ctx->Fog, sizeof(struct gl_fog_attrib) );
newnode = new_attrib_node( GL_FOG_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_HINT_BIT) {
struct gl_hint_attrib *attr;
attr = MALLOC_STRUCT( gl_hint_attrib );
MEMCPY( attr, &ctx->Hint, sizeof(struct gl_hint_attrib) );
newnode = new_attrib_node( GL_HINT_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_LIGHTING_BIT) {
struct gl_light_attrib *attr;
attr = MALLOC_STRUCT( gl_light_attrib );
MEMCPY( attr, &ctx->Light, sizeof(struct gl_light_attrib) );
newnode = new_attrib_node( GL_LIGHTING_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_LINE_BIT) {
struct gl_line_attrib *attr;
attr = MALLOC_STRUCT( gl_line_attrib );
MEMCPY( attr, &ctx->Line, sizeof(struct gl_line_attrib) );
newnode = new_attrib_node( GL_LINE_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_LIST_BIT) {
struct gl_list_attrib *attr;
attr = MALLOC_STRUCT( gl_list_attrib );
MEMCPY( attr, &ctx->List, sizeof(struct gl_list_attrib) );
newnode = new_attrib_node( GL_LIST_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_PIXEL_MODE_BIT) {
struct gl_pixel_attrib *attr;
attr = MALLOC_STRUCT( gl_pixel_attrib );
MEMCPY( attr, &ctx->Pixel, sizeof(struct gl_pixel_attrib) );
newnode = new_attrib_node( GL_PIXEL_MODE_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_POINT_BIT) {
struct gl_point_attrib *attr;
attr = MALLOC_STRUCT( gl_point_attrib );
MEMCPY( attr, &ctx->Point, sizeof(struct gl_point_attrib) );
newnode = new_attrib_node( GL_POINT_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_POLYGON_BIT) {
struct gl_polygon_attrib *attr;
attr = MALLOC_STRUCT( gl_polygon_attrib );
MEMCPY( attr, &ctx->Polygon, sizeof(struct gl_polygon_attrib) );
newnode = new_attrib_node( GL_POLYGON_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_POLYGON_STIPPLE_BIT) {
GLuint *stipple;
stipple = (GLuint *) malloc( 32*sizeof(GLuint) );
MEMCPY( stipple, ctx->PolygonStipple, 32*sizeof(GLuint) );
newnode = new_attrib_node( GL_POLYGON_STIPPLE_BIT );
newnode->data = stipple;
newnode->next = head;
head = newnode;
}
if (mask & GL_SCISSOR_BIT) {
struct gl_scissor_attrib *attr;
attr = MALLOC_STRUCT( gl_scissor_attrib );
MEMCPY( attr, &ctx->Scissor, sizeof(struct gl_scissor_attrib) );
newnode = new_attrib_node( GL_SCISSOR_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_STENCIL_BUFFER_BIT) {
struct gl_stencil_attrib *attr;
attr = MALLOC_STRUCT( gl_stencil_attrib );
MEMCPY( attr, &ctx->Stencil, sizeof(struct gl_stencil_attrib) );
newnode = new_attrib_node( GL_STENCIL_BUFFER_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_TEXTURE_BIT) {
struct gl_texture_attrib *attr;
attr = MALLOC_STRUCT( gl_texture_attrib );
MEMCPY( attr, &ctx->Texture, sizeof(struct gl_texture_attrib) );
newnode = new_attrib_node( GL_TEXTURE_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_TRANSFORM_BIT) {
struct gl_transform_attrib *attr;
attr = MALLOC_STRUCT( gl_transform_attrib );
MEMCPY( attr, &ctx->Transform, sizeof(struct gl_transform_attrib) );
newnode = new_attrib_node( GL_TRANSFORM_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_VIEWPORT_BIT) {
struct gl_viewport_attrib *attr;
attr = MALLOC_STRUCT( gl_viewport_attrib );
MEMCPY( attr, &ctx->Viewport, sizeof(struct gl_viewport_attrib) );
newnode = new_attrib_node( GL_VIEWPORT_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
ctx->AttribStack[ctx->AttribStackDepth] = head;
ctx->AttribStackDepth++;
}
void gl_PopAttrib( GLcontext* ctx )
{
struct gl_attrib_node *attr, *next;
struct gl_enable_attrib *enable;
GLuint i, oldDrawBuffer;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPopAttrib" );
return;
}
if (ctx->AttribStackDepth==0) {
gl_error( ctx, GL_STACK_UNDERFLOW, "glPopAttrib" );
return;
}
ctx->AttribStackDepth--;
attr = ctx->AttribStack[ctx->AttribStackDepth];
while (attr) {
switch (attr->kind) {
case GL_ACCUM_BUFFER_BIT:
MEMCPY( &ctx->Accum, attr->data, sizeof(struct gl_accum_attrib) );
break;
case GL_COLOR_BUFFER_BIT:
	    oldDrawBuffer = ctx->Color.DrawBuffer;
MEMCPY( &ctx->Color, attr->data,
		    sizeof(struct gl_colorbuffer_attrib) );
	    if (ctx->Color.DrawBuffer != oldDrawBuffer) {
	       gl_DrawBuffer(ctx, ctx->Color.DrawBuffer);
}
break;
case GL_CURRENT_BIT:
MEMCPY( &ctx->Current, attr->data,
		    sizeof(struct gl_current_attrib) );
break;
case GL_DEPTH_BUFFER_BIT:
MEMCPY( &ctx->Depth, attr->data,
		    sizeof(struct gl_depthbuffer_attrib) );
break;
case GL_ENABLE_BIT:
enable = (struct gl_enable_attrib *) attr->data;
ctx->Color.AlphaEnabled = enable->AlphaTest;
ctx->Transform.Normalize = enable->AutoNormal;
ctx->Color.BlendEnabled = enable->Blend;
	    for (i=0;i<MAX_CLIP_PLANES;i++) {
ctx->Transform.ClipEnabled[i] = enable->ClipPlane[i];
	    }
	    ctx->Light.ColorMaterialEnabled = enable->ColorMaterial;
	    ctx->Polygon.CullFlag = enable->CullFace;
	    ctx->Depth.Test = enable->DepthTest;
	    ctx->Color.DitherFlag = enable->Dither;
	    ctx->Fog.Enabled = enable->Fog;
	    ctx->Light.Enabled = enable->Lighting;
	    ctx->Line.SmoothFlag = enable->LineSmooth;
	    ctx->Line.StippleFlag = enable->LineStipple;
	    ctx->Color.IndexLogicOpEnabled = enable->IndexLogicOp;
	    ctx->Color.ColorLogicOpEnabled = enable->ColorLogicOp;
	    ctx->Eval.Map1Color4 = enable->Map1Color4;
	    ctx->Eval.Map1Index = enable->Map1Index;
	    ctx->Eval.Map1Normal = enable->Map1Normal;
	    ctx->Eval.Map1TextureCoord1 = enable->Map1TextureCoord1;
	    ctx->Eval.Map1TextureCoord2 = enable->Map1TextureCoord2;
	    ctx->Eval.Map1TextureCoord3 = enable->Map1TextureCoord3;
	    ctx->Eval.Map1TextureCoord4 = enable->Map1TextureCoord4;
	    ctx->Eval.Map1Vertex3 = enable->Map1Vertex3;
	    ctx->Eval.Map1Vertex4 = enable->Map1Vertex4;
	    ctx->Eval.Map2Color4 = enable->Map2Color4;
	    ctx->Eval.Map2Index = enable->Map2Index;
	    ctx->Eval.Map2Normal = enable->Map2Normal;
	    ctx->Eval.Map2TextureCoord1 = enable->Map2TextureCoord1;
	    ctx->Eval.Map2TextureCoord2 = enable->Map2TextureCoord2;
	    ctx->Eval.Map2TextureCoord3 = enable->Map2TextureCoord3;
	    ctx->Eval.Map2TextureCoord4 = enable->Map2TextureCoord4;
	    ctx->Eval.Map2Vertex3 = enable->Map2Vertex3;
	    ctx->Eval.Map2Vertex4 = enable->Map2Vertex4;
	    ctx->Transform.Normalize = enable->Normalize;
	    ctx->Point.SmoothFlag = enable->PointSmooth;
	    ctx->Polygon.OffsetPoint = enable->PolygonOffsetPoint;
	    ctx->Polygon.OffsetLine = enable->PolygonOffsetLine;
	    ctx->Polygon.OffsetFill = enable->PolygonOffsetFill;
ctx->Polygon.OffsetAny = ctx->Polygon.OffsetPoint ||
ctx->Polygon.OffsetLine ||
ctx->Polygon.OffsetFill;
	    ctx->Polygon.SmoothFlag = enable->PolygonSmooth;
	    ctx->Polygon.StippleFlag = enable->PolygonStipple;
	    ctx->Scissor.Enabled = enable->Scissor;
	    ctx->Stencil.Enabled = enable->Stencil;
	    ctx->Texture.Enabled = enable->Texture;
	    ctx->Texture.TexGenEnabled = enable->TexGen;
break;
case GL_EVAL_BIT:
MEMCPY( &ctx->Eval, attr->data, sizeof(struct gl_eval_attrib) );
break;
case GL_FOG_BIT:
MEMCPY( &ctx->Fog, attr->data, sizeof(struct gl_fog_attrib) );
break;
case GL_HINT_BIT:
MEMCPY( &ctx->Hint, attr->data, sizeof(struct gl_hint_attrib) );
break;
case GL_LIGHTING_BIT:
MEMCPY( &ctx->Light, attr->data, sizeof(struct gl_light_attrib) );
break;
case GL_LINE_BIT:
MEMCPY( &ctx->Line, attr->data, sizeof(struct gl_line_attrib) );
break;
case GL_LIST_BIT:
MEMCPY( &ctx->List, attr->data, sizeof(struct gl_list_attrib) );
break;
case GL_PIXEL_MODE_BIT:
MEMCPY( &ctx->Pixel, attr->data, sizeof(struct gl_pixel_attrib) );
break;
case GL_POINT_BIT:
MEMCPY( &ctx->Point, attr->data, sizeof(struct gl_point_attrib) );
break;
case GL_POLYGON_BIT:
MEMCPY( &ctx->Polygon, attr->data,
		    sizeof(struct gl_polygon_attrib) );
break;
	 case GL_POLYGON_STIPPLE_BIT:
	    MEMCPY( ctx->PolygonStipple, attr->data, 32*sizeof(GLuint) );
	    break;
case GL_SCISSOR_BIT:
MEMCPY( &ctx->Scissor, attr->data,
		    sizeof(struct gl_scissor_attrib) );
break;
case GL_STENCIL_BUFFER_BIT:
MEMCPY( &ctx->Stencil, attr->data,
		    sizeof(struct gl_stencil_attrib) );
break;
case GL_TRANSFORM_BIT:
MEMCPY( &ctx->Transform, attr->data,
		    sizeof(struct gl_transform_attrib) );
break;
case GL_TEXTURE_BIT:
MEMCPY( &ctx->Texture, attr->data,
		    sizeof(struct gl_texture_attrib) );
break;
case GL_VIEWPORT_BIT:
MEMCPY( &ctx->Viewport, attr->data,
		    sizeof(struct gl_viewport_attrib) );
break;
default:
gl_problem( ctx, "Bad attrib flag in PopAttrib");
break;
}
next = attr->next;
free( (void *) attr->data );
free( (void *) attr );
attr = next;
}
ctx->NewState = NEW_ALL;
}
#define GL_CLIENT_PACK_BIT (1<<20)
#define GL_CLIENT_UNPACK_BIT (1<<21)
void gl_PushClientAttrib( GLcontext *ctx, GLbitfield mask )
{
struct gl_attrib_node *newnode;
struct gl_attrib_node *head;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPushClientAttrib" );
return;
}
if (ctx->ClientAttribStackDepth>=MAX_CLIENT_ATTRIB_STACK_DEPTH) {
gl_error( ctx, GL_STACK_OVERFLOW, "glPushClientAttrib" );
return;
}
head = NULL;
if (mask & GL_CLIENT_PIXEL_STORE_BIT) {
struct gl_pixelstore_attrib *attr;
attr = MALLOC_STRUCT( gl_pixelstore_attrib );
MEMCPY( attr, &ctx->Pack, sizeof(struct gl_pixelstore_attrib) );
newnode = new_attrib_node( GL_CLIENT_PACK_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
attr = MALLOC_STRUCT( gl_pixelstore_attrib );
MEMCPY( attr, &ctx->Unpack, sizeof(struct gl_pixelstore_attrib) );
newnode = new_attrib_node( GL_CLIENT_UNPACK_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
if (mask & GL_CLIENT_VERTEX_ARRAY_BIT) {
struct gl_array_attrib *attr;
attr = MALLOC_STRUCT( gl_array_attrib );
MEMCPY( attr, &ctx->Array, sizeof(struct gl_array_attrib) );
newnode = new_attrib_node( GL_CLIENT_VERTEX_ARRAY_BIT );
newnode->data = attr;
newnode->next = head;
head = newnode;
}
ctx->ClientAttribStack[ctx->ClientAttribStackDepth] = head;
ctx->ClientAttribStackDepth++;
}
void gl_PopClientAttrib( GLcontext *ctx )
{
struct gl_attrib_node *attr, *next;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPopClientAttrib" );
return;
}
if (ctx->ClientAttribStackDepth==0) {
gl_error( ctx, GL_STACK_UNDERFLOW, "glPopClientAttrib" );
return;
}
ctx->ClientAttribStackDepth--;
attr = ctx->ClientAttribStack[ctx->ClientAttribStackDepth];
while (attr) {
switch (attr->kind) {
case GL_CLIENT_PACK_BIT:
MEMCPY( &ctx->Pack, attr->data,
sizeof(struct gl_pixelstore_attrib) );
break;
case GL_CLIENT_UNPACK_BIT:
MEMCPY( &ctx->Unpack, attr->data,
sizeof(struct gl_pixelstore_attrib) );
break;
case GL_CLIENT_VERTEX_ARRAY_BIT:
MEMCPY( &ctx->Array, attr->data,
		    sizeof(struct gl_array_attrib) );
break;
default:
gl_problem( ctx, "Bad attrib flag in PopClientAttrib");
break;
}
next = attr->next;
free( (void *) attr->data );
free( (void *) attr );
attr = next;
}
ctx->NewState = NEW_ALL;
}
/* 当前文件是D:\Read\bitmap.c*/

#ifdef PC_HEADER
#else
#endif
struct gl_image *gl_unpack_bitmap( GLcontext* ctx,
GLsizei width, GLsizei height,
const GLubyte *bitmap )
{
return gl_unpack_image( ctx, width, height,
GL_COLOR_INDEX, GL_BITMAP, bitmap );
}
void gl_render_bitmap( GLcontext* ctx,
GLsizei width, GLsizei height,
float xorig, float yorig,
float xmove, float ymove,
const struct gl_image *bitmap )
{
struct pixel_buffer *PB = ctx->PB;
GLint bx, by;
GLint px, py, pz;
GLubyte *ptr;
assert(bitmap);
assert(bitmap->Type == GL_BITMAP);
assert(bitmap->Format == GL_COLOR_INDEX);
if (ctx->NewState) {
gl_update_state(ctx);
PB_INIT( PB, GL_BITMAP );
}
if (ctx->Visual->RGBAflag) {
GLint r, g, b, a;
r = (GLint) (ctx->Current.RasterColor[0] * ctx->Visual->RedScale);
g = (GLint) (ctx->Current.RasterColor[1] * ctx->Visual->GreenScale);
b = (GLint) (ctx->Current.RasterColor[2] * ctx->Visual->BlueScale);
a = (GLint) (ctx->Current.RasterColor[3] * ctx->Visual->AlphaScale);
PB_SET_COLOR( ctx, PB, r, g, b, a );
}
else {
PB_SET_INDEX( ctx, PB, ctx->Current.RasterIndex );
}
px = (GLint) ( (ctx->Current.RasterPos[0] - xorig) + 0.0F );
py = (GLint) ( (ctx->Current.RasterPos[1] - yorig) + 0.0F );
pz = (GLint) ( ctx->Current.RasterPos[2] * DEPTH_SCALE );
ptr = (GLubyte *) bitmap->Data;
for (by=0;by<height;by++) {
GLubyte bitmask;
bitmask = 128;
for (bx=0;bx<width;bx++) {
if (*ptr&bitmask) {
PB_WRITE_PIXEL( PB, px+bx, py+by, pz );
}
bitmask = bitmask >> 1;
if (bitmask==0) {
ptr++;
bitmask = 128;
}
}
PB_CHECK_FLUSH(ctx,PB);
if (bitmask!=128)  ptr++;
}
gl_flush_pb(ctx);
}
void gl_Bitmap( GLcontext* ctx,
GLsizei width, GLsizei height,
	        float xorig, float yorig,
	        float xmove, float ymove,
const struct gl_image *bitmap )
{
if (width<0 || height<0) {
gl_error( ctx, GL_INVALID_VALUE, "glBitmap" );
return;
}
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glBitmap" );
return;
}
if (ctx->Current.RasterPosValid==GL_FALSE) {
return;
}
if (ctx->RenderMode==GL_RENDER) {
GLboolean completed = GL_FALSE;
if (ctx->Driver.Bitmap) {
completed = (*ctx->Driver.Bitmap)( ctx, width, height, xorig, yorig,
xmove, ymove, bitmap );
}
if (!completed) {
gl_render_bitmap( ctx, width, height, xorig, yorig,
xmove, ymove, bitmap );
}
}
else if (ctx->RenderMode==GL_FEEDBACK) {
float color[4], texcoord[4], invq;
color[0] = ctx->Current.ByteColor[0] * ctx->Visual->InvRedScale;
color[1] = ctx->Current.ByteColor[1] * ctx->Visual->InvGreenScale;
color[2] = ctx->Current.ByteColor[2] * ctx->Visual->InvBlueScale;
color[3] = ctx->Current.ByteColor[3] * ctx->Visual->InvAlphaScale;
invq = 1.0F / ctx->Current.TexCoord[3];
texcoord[0] = ctx->Current.TexCoord[0] * invq;
texcoord[1] = ctx->Current.TexCoord[1] * invq;
texcoord[2] = ctx->Current.TexCoord[2] * invq;
texcoord[3] = ctx->Current.TexCoord[3];
FEEDBACK_TOKEN( ctx, (float) GL_BITMAP_TOKEN );
gl_feedback_vertex( ctx, ctx->Current.RasterPos[0] - xorig,
			  ctx->Current.RasterPos[1] - yorig,
			  ctx->Current.RasterPos[2],
			  ctx->Current.RasterPos[3],
			  color, ctx->Current.Index, texcoord );
}
else if (ctx->RenderMode==GL_SELECT) {
}
ctx->Current.RasterPos[0] += xmove;
ctx->Current.RasterPos[1] += ymove;
}
/* 当前文件是D:\Read\blend.c*/

#ifdef PC_HEADER
#else
#endif
void gl_BlendFunc( GLcontext* ctx, GLenum sfactor, GLenum dfactor )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glBlendFunc" );
return;
}
switch (sfactor) {
case GL_ZERO:
case GL_ONE:
case GL_DST_COLOR:
case GL_ONE_MINUS_DST_COLOR:
case GL_SRC_ALPHA:
case GL_ONE_MINUS_SRC_ALPHA:
case GL_DST_ALPHA:
case GL_ONE_MINUS_DST_ALPHA:
case GL_SRC_ALPHA_SATURATE:
case GL_CONSTANT_COLOR:
case GL_ONE_MINUS_CONSTANT_COLOR:
case GL_CONSTANT_ALPHA:
case GL_ONE_MINUS_CONSTANT_ALPHA:
ctx->Color.BlendSrc = sfactor;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glBlendFunc(sfactor)" );
return;
}
switch (dfactor) {
case GL_ZERO:
case GL_ONE:
case GL_SRC_COLOR:
case GL_ONE_MINUS_SRC_COLOR:
case GL_SRC_ALPHA:
case GL_ONE_MINUS_SRC_ALPHA:
case GL_DST_ALPHA:
case GL_ONE_MINUS_DST_ALPHA:
case GL_CONSTANT_COLOR:
case GL_ONE_MINUS_CONSTANT_COLOR:
case GL_CONSTANT_ALPHA:
case GL_ONE_MINUS_CONSTANT_ALPHA:
ctx->Color.BlendDst = dfactor;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glBlendFunc(dfactor)" );
}
ctx->NewState |= NEW_RASTER_OPS;
}
void gl_BlendEquation( GLcontext* ctx, GLenum mode )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glBlendEquation" );
return;
}
switch (mode) {
case GL_MIN_EXT:
case GL_MAX_EXT:
case GL_LOGIC_OP:
case GL_FUNC_ADD_EXT:
case GL_FUNC_SUBTRACT_EXT:
case GL_FUNC_REVERSE_SUBTRACT_EXT:
ctx->Color.BlendEquation = mode;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glBlendEquation" );
return;
}
if (mode==GL_LOGIC_OP && ctx->Color.BlendEnabled) {
ctx->Color.ColorLogicOpEnabled = GL_TRUE;
}
else {
ctx->Color.ColorLogicOpEnabled = GL_FALSE;
}
ctx->NewState |= NEW_RASTER_OPS;
}
void gl_BlendColor( GLcontext* ctx, GLclampf red, GLclampf green,
		    GLclampf blue, GLclampf alpha )
{
ctx->Color.BlendColor[0] = CLAMP( red,   0.0, 1.0 );
ctx->Color.BlendColor[1] = CLAMP( green, 0.0, 1.0 );
ctx->Color.BlendColor[2] = CLAMP( blue,  0.0, 1.0 );
ctx->Color.BlendColor[3] = CLAMP( alpha, 0.0, 1.0 );
}
static void do_blend( GLcontext* ctx, GLuint n, const GLubyte mask[],
GLubyte red[], GLubyte green[],
GLubyte blue[], GLubyte alpha[],
const GLubyte rdest[], const GLubyte gdest[],
const GLubyte bdest[], const GLubyte adest[] )
{
GLuint i;
if (ctx->Color.BlendEquation==GL_FUNC_ADD_EXT
&& ctx->Color.BlendSrc==GL_SRC_ALPHA
&& ctx->Color.BlendDst==GL_ONE_MINUS_SRC_ALPHA) {
float ascale = 256.0f * ctx->Visual->InvAlphaScale;
GLint rmax = (GLint) ctx->Visual->RedScale;
GLint gmax = (GLint) ctx->Visual->GreenScale;
GLint bmax = (GLint) ctx->Visual->BlueScale;
GLint amax = (GLint) ctx->Visual->AlphaScale;
for (i=0;i<n;i++) {
	 if (mask[i]) {
	    GLint r, g, b, a;
GLint t = (GLint) ( alpha[i] * ascale );
GLint s = 256 - t;
	    r = (red[i]   * t + rdest[i] * s) >> 8;
	    g = (green[i] * t + gdest[i] * s) >> 8;
	    b = (blue[i]  * t + bdest[i] * s) >> 8;
	    a = (alpha[i] * t + adest[i] * s) >> 8;
	    red[i]   = MIN2( r, rmax );
	    green[i] = MIN2( g, gmax );
	    blue[i]  = MIN2( b, bmax );
	    alpha[i] = MIN2( a, amax );
	 }
}
}
else if (ctx->Color.BlendEquation==GL_FUNC_ADD_EXT
|| ctx->Color.BlendEquation==GL_FUNC_SUBTRACT_EXT
|| ctx->Color.BlendEquation==GL_FUNC_REVERSE_SUBTRACT_EXT) {
float rmax = ctx->Visual->RedScale;
float gmax = ctx->Visual->GreenScale;
float bmax = ctx->Visual->BlueScale;
float amax = ctx->Visual->AlphaScale;
float rscale = 1.0f / rmax;
float gscale = 1.0f / gmax;
float bscale = 1.0f / bmax;
float ascale = 1.0f / amax;
for (i=0;i<n;i++) {
	 if (mask[i]) {
	    GLint Rs, Gs, Bs, As;
	    GLint Rd, Gd, Bd, Ad;
	    float sR, sG, sB, sA;
	    float dR, dG, dB, dA;
	    float r, g, b, a;
	
	    Rs = red[i];
	    Gs = green[i];
	    Bs = blue[i];
	    As = alpha[i];
	
	    Rd = rdest[i];
	    Gd = gdest[i];
	    Bd = bdest[i];
	    Ad = adest[i];
	
	    switch (ctx->Color.BlendSrc) {
	       case GL_ZERO:
		  sR = sG = sB = sA = 0.0F;
		  break;
	       case GL_ONE:
		  sR = sG = sB = sA = 1.0F;
		  break;
	       case GL_DST_COLOR:
		  sR = (float) Rd * rscale;
		  sG = (float) Gd * gscale;
		  sB = (float) Bd * bscale;
		  sA = (float) Ad * ascale;
		  break;
	       case GL_ONE_MINUS_DST_COLOR:
		  sR = 1.0F - (float) Rd * rscale;
		  sG = 1.0F - (float) Gd * gscale;
		  sB = 1.0F - (float) Bd * bscale;
		  sA = 1.0F - (float) Ad * ascale;
		  break;
	       case GL_SRC_ALPHA:
		  sR = sG = sB = sA = (float) As * ascale;
		  break;
	       case GL_ONE_MINUS_SRC_ALPHA:
		  sR = sG = sB = sA = (float) 1.0F - (float) As * ascale;
		  break;
	       case GL_DST_ALPHA:
		  sR = sG = sB = sA =(float) Ad * ascale;
		  break;
	       case GL_ONE_MINUS_DST_ALPHA:
		  sR = sG = sB = sA = 1.0F - (float) Ad * ascale;
		  break;
	       case GL_SRC_ALPHA_SATURATE:
		  if (As < 1.0F - (float) Ad * ascale) {
		     sR = sG = sB = (float) As * ascale;
		  }
		  else {
		     sR = sG = sB = 1.0F - (float) Ad * ascale;
		  }
		  sA = 1.0;
		  break;
	       case GL_CONSTANT_COLOR:
		  sR = ctx->Color.BlendColor[0];
		  sG = ctx->Color.BlendColor[1];
		  sB = ctx->Color.BlendColor[2];
		  sA = ctx->Color.BlendColor[3];
		  break;
	       case GL_ONE_MINUS_CONSTANT_COLOR:
		  sR = 1.0F - ctx->Color.BlendColor[0];
		  sG = 1.0F - ctx->Color.BlendColor[1];
		  sB = 1.0F - ctx->Color.BlendColor[2];
		  sA = 1.0F - ctx->Color.BlendColor[3];
		  break;
	       case GL_CONSTANT_ALPHA:
		  sR = sG = sB = sA = ctx->Color.BlendColor[3];
		  break;
	       case GL_ONE_MINUS_CONSTANT_ALPHA:
		  sR = sG = sB = sA = 1.0F - ctx->Color.BlendColor[3];
		  break;
	       default:
gl_problem(ctx, "Bad blend source factor in do_blend");
	    }
	
	    switch (ctx->Color.BlendDst) {
	       case GL_ZERO:
		  dR = dG = dB = dA = 0.0F;
		  break;
	       case GL_ONE:
		  dR = dG = dB = dA = 1.0F;
		  break;
	       case GL_SRC_COLOR:
		  dR = (float) Rs * rscale;
		  dG = (float) Gs * gscale;
		  dB = (float) Bs * bscale;
		  dA = (float) As * ascale;
		  break;
	       case GL_ONE_MINUS_SRC_COLOR:
		  dR = 1.0F - (float) Rs * rscale;
		  dG = 1.0F - (float) Gs * gscale;
		  dB = 1.0F - (float) Bs * bscale;
		  dA = 1.0F - (float) As * ascale;
		  break;
	       case GL_SRC_ALPHA:
		  dR = dG = dB = dA = (float) As * ascale;
		  break;
	       case GL_ONE_MINUS_SRC_ALPHA:
		  dR = dG = dB = dA = (float) 1.0F - (float) As * ascale;
		  break;
	       case GL_DST_ALPHA:
		  dR = dG = dB = dA = (float) Ad * ascale;
		  break;
	       case GL_ONE_MINUS_DST_ALPHA:
		  dR = dG = dB = dA = 1.0F - (float) Ad * ascale;
		  break;
	       case GL_CONSTANT_COLOR:
		  dR = ctx->Color.BlendColor[0];
		  dG = ctx->Color.BlendColor[1];
		  dB = ctx->Color.BlendColor[2];
		  dA = ctx->Color.BlendColor[3];
		  break;
	       case GL_ONE_MINUS_CONSTANT_COLOR:
		  dR = 1.0F - ctx->Color.BlendColor[0];
		  dG = 1.0F - ctx->Color.BlendColor[1];
		  dB = 1.0F - ctx->Color.BlendColor[2];
		  dA = 1.0F - ctx->Color.BlendColor[3];
		  break;
	       case GL_CONSTANT_ALPHA:
		  dR = dG = dB = dA = ctx->Color.BlendColor[3];
		  break;
	       case GL_ONE_MINUS_CONSTANT_ALPHA:
		  dR = dG = dB = dA = 1.0F - ctx->Color.BlendColor[3] * ascale;
		  break;
	       default:
gl_problem(ctx, "Bad blend dest factor in do_blend");
	    }
#ifdef DEBUG
	    assert( sR>= 0.0 && sR<=1.0 );
	    assert( sG>= 0.0 && sG<=1.0 );
	    assert( sB>= 0.0 && sB<=1.0 );
	    assert( sA>= 0.0 && sA<=1.0 );
	    assert( dR>= 0.0 && dR<=1.0 );
	    assert( dG>= 0.0 && dG<=1.0 );
	    assert( dB>= 0.0 && dB<=1.0 );
	    assert( dA>= 0.0 && dA<=1.0 );
#endif
	
	    if (ctx->Color.BlendEquation==GL_FUNC_ADD_EXT) {
	       r = Rs * sR + Rd * dR;
	       g = Gs * sG + Gd * dG;
	       b = Bs * sB + Bd * dB;
	       a = As * sA + Ad * dA;
	    }
	    else if (ctx->Color.BlendEquation==GL_FUNC_SUBTRACT_EXT) {
	       r = Rs * sR - Rd * dR;
	       g = Gs * sG - Gd * dG;
	       b = Bs * sB - Bd * dB;
	       a = As * sA - Ad * dA;
	    }
	    else if (ctx->Color.BlendEquation==GL_FUNC_REVERSE_SUBTRACT_EXT) {
	       r = Rd * dR - Rs * sR;
	       g = Gd * dG - Gs * sG;
	       b = Bd * dB - Bs * sB;
	       a = Ad * dA - As * sA;
	    }
	    red[i]   = (GLint) CLAMP( r, 0.0F, rmax );
	    green[i] = (GLint) CLAMP( g, 0.0F, gmax );
	    blue[i]  = (GLint) CLAMP( b, 0.0F, bmax );
	    alpha[i] = (GLint) CLAMP( a, 0.0F, amax );
	 }
}
}
else if (ctx->Color.BlendEquation==GL_MIN_EXT) {
for (i=0;i<n;i++) {
	 if (mask[i]) {
	    red[i]   = MIN2( red[i],   rdest[i] );
	    green[i] = MIN2( green[i], gdest[i] );
	    blue[i]  = MIN2( blue[i],  bdest[i] );
	    alpha[i] = MIN2( alpha[i], adest[i] );
	 }
}
}
else if (ctx->Color.BlendEquation==GL_MAX_EXT) {
for (i=0;i<n;i++) {
	 if (mask[i]) {
	    red[i]   = MAX2( red[i],   rdest[i] );
	    green[i] = MAX2( green[i], gdest[i] );
	    blue[i]  = MAX2( blue[i],  bdest[i] );
	    alpha[i] = MAX2( alpha[i], adest[i] );
	 }
}
}
}
void gl_blend_span( GLcontext* ctx, GLuint n, GLint x, GLint y,
		    GLubyte red[], GLubyte green[],
		    GLubyte blue[], GLubyte alpha[],
		    GLubyte mask[] )
{
GLubyte rdest[MAX_WIDTH], gdest[MAX_WIDTH];
GLubyte bdest[MAX_WIDTH], adest[MAX_WIDTH];
if (ctx->Color.BlendEquation==GL_LOGIC_OP && !ctx->Color.SWLogicOpEnabled) {
return;
}
gl_read_color_span( ctx, n, x, y, rdest, gdest, bdest, adest );
do_blend( ctx, n, mask, red, green, blue, alpha, rdest, gdest, bdest, adest );
}
void gl_blend_pixels( GLcontext* ctx,
GLuint n, const GLint x[], const GLint y[],
		      GLubyte red[], GLubyte green[],
		      GLubyte blue[], GLubyte alpha[],
		      GLubyte mask[] )
{
GLubyte rdest[PB_SIZE], gdest[PB_SIZE], bdest[PB_SIZE], adest[PB_SIZE];
if (ctx->Color.BlendEquation==GL_LOGIC_OP && !ctx->Color.SWLogicOpEnabled) {
return;
}
(*ctx->Driver.ReadColorPixels)( ctx, n, x, y, rdest, gdest, bdest, adest, mask );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_read_alpha_pixels( ctx, n, x, y, adest, mask );
}
do_blend( ctx, n, mask, red, green, blue, alpha, rdest, gdest, bdest, adest );
}
/* 当前文件是D:\Read\clip.c*/

#ifdef PC_HEADER
#else
#endif
#define LINTERP( T, A, B )   ( (A) + (T) * ( (B) - (A) ) )
#define EYE_SPACE 1
#define CLIP_SPACE 2
static GLuint Space;
static void interpolate_aux( GLcontext* ctx,
GLuint dst, float t, GLuint in, GLuint out )
{
struct vertex_buffer* VB = ctx->VB;
if (ctx->ClipMask & CLIP_FCOLOR_BIT) {
VB->Fcolor[dst][0] = LINTERP( t, VB->Fcolor[in][0], VB->Fcolor[out][0] );
VB->Fcolor[dst][1] = LINTERP( t, VB->Fcolor[in][1], VB->Fcolor[out][1] );
VB->Fcolor[dst][2] = LINTERP( t, VB->Fcolor[in][2], VB->Fcolor[out][2] );
VB->Fcolor[dst][3] = LINTERP( t, VB->Fcolor[in][3], VB->Fcolor[out][3] );
}
else if (ctx->ClipMask & CLIP_FINDEX_BIT) {
VB->Findex[dst] = (GLuint) (GLint) LINTERP( t, (float) VB->Findex[in],
(float) VB->Findex[out] );
}
if (ctx->ClipMask & CLIP_BCOLOR_BIT) {
VB->Bcolor[dst][0] = LINTERP( t, VB->Bcolor[in][0], VB->Bcolor[out][0] );
VB->Bcolor[dst][1] = LINTERP( t, VB->Bcolor[in][1], VB->Bcolor[out][1] );
VB->Bcolor[dst][2] = LINTERP( t, VB->Bcolor[in][2], VB->Bcolor[out][2] );
VB->Bcolor[dst][3] = LINTERP( t, VB->Bcolor[in][3], VB->Bcolor[out][3] );
}
else if (ctx->ClipMask & CLIP_BINDEX_BIT) {
VB->Bindex[dst] = (GLuint) (GLint) LINTERP( t, (float) VB->Bindex[in],
(float) VB->Bindex[out] );
}
if (ctx->ClipMask & CLIP_TEXTURE_BIT) {
if (Space==CLIP_SPACE) {
	
	 VB->Eye[dst][2] = LINTERP( t, VB->Eye[in][2], VB->Eye[out][2] );
}
VB->TexCoord[dst][0] = LINTERP(t,VB->TexCoord[in][0],VB->TexCoord[out][0]);
VB->TexCoord[dst][1] = LINTERP(t,VB->TexCoord[in][1],VB->TexCoord[out][1]);
VB->TexCoord[dst][2] = LINTERP(t,VB->TexCoord[in][2],VB->TexCoord[out][2]);
VB->TexCoord[dst][3] = LINTERP(t,VB->TexCoord[in][3],VB->TexCoord[out][3]);
}
}
void gl_ClipPlane( GLcontext* ctx, GLenum plane, const float *equation )
{
GLint p;
p = (GLint) plane - (GLint) GL_CLIP_PLANE0;
if (p<0 || p>=MAX_CLIP_PLANES) {
gl_error( ctx, GL_INVALID_ENUM, "glClipPlane" );
return;
}
if (ctx->NewModelViewMatrix) {
gl_analyze_modelview_matrix(ctx);
}
gl_transform_vector( ctx->Transform.ClipEquation[p], equation,
		        ctx->ModelViewInv );
}
void gl_GetClipPlane( GLcontext* ctx, GLenum plane, GLdouble *equation )
{
GLint p;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetClipPlane" );
return;
}
p = (GLint) (plane - GL_CLIP_PLANE0);
if (p<0 || p>=MAX_CLIP_PLANES) {
gl_error( ctx, GL_INVALID_ENUM, "glGetClipPlane" );
return;
}
equation[0] = (GLdouble) ctx->Transform.ClipEquation[p][0];
equation[1] = (GLdouble) ctx->Transform.ClipEquation[p][1];
equation[2] = (GLdouble) ctx->Transform.ClipEquation[p][2];
equation[3] = (GLdouble) ctx->Transform.ClipEquation[p][3];
}
GLuint gl_viewclip_point( const float v[] )
{
if (   v[0] > v[3] || v[0] < -v[3]
|| v[1] > v[3] || v[1] < -v[3]
|| v[2] > v[3] || v[2] < -v[3] ) {
return 0;
}
else {
return 1;
}
}
GLuint gl_viewclip_line( GLcontext* ctx, GLuint *i, GLuint *j )
{
struct vertex_buffer* VB = ctx->VB;
float (*coord)[4] = VB->Clip;
float t, dx, dy, dz, dw;
register GLuint ii, jj;
Space = CLIP_SPACE;
ii = *i;
jj = *j;
#define GENERAL_CLIP							\
if (OUTSIDE(ii)) {           	                        	\
if (OUTSIDE(jj)) {                	                	\
			\
return 0;                                      		\
}                                                 		\
else {                                            		\
		\
	 			\
COMPUTE_INTERSECTION( VB->Free, jj, ii )             		\
	 if (ctx->ClipMask)						\
	    interpolate_aux( ctx, VB->Free, t, jj, ii );		\
	 ii = VB->Free;							\
	 VB->Free++;							\
	 if (VB->Free==VB_SIZE)  VB->Free = 1;				\
}                                                 		\
}                                                    		\
else {                                               		\
if (OUTSIDE(jj)) {                                		\
		\
	 			\
COMPUTE_INTERSECTION( VB->Free, ii, jj );            		\
	 if (ctx->ClipMask)						\
	    interpolate_aux( ctx, VB->Free, t, ii, jj );		\
	 jj = VB->Free;							\
	 VB->Free++;							\
	 if (VB->Free==VB_SIZE)  VB->Free = 1;				\
}                                                 		\
		\
}
#define X(I)	coord[I][0]
#define Y(I)	coord[I][1]
#define Z(I)	coord[I][2]
#define W(I)	coord[I][3]
#define OUTSIDE(K)      (X(K) > W(K))
#define COMPUTE_INTERSECTION( new, in, out )		\
	dx = X(out) - X(in);				\
	dw = W(out) - W(in);				\
	t = (X(in) - W(in)) / (dw-dx);			\
	X(new) = X(in) + t * dx;			\
	Y(new) = Y(in) + t * (Y(out) - Y(in));		\
	Z(new) = Z(in) + t * (Z(out) - Z(in));		\
	W(new) = W(in) + t * dw;
GENERAL_CLIP
#undef OUTSIDE
#undef COMPUTE_INTERSECTION
#define OUTSIDE(K)      (X(K) < -W(K))
#define COMPUTE_INTERSECTION( new, in, out )		\
	dx = X(out) - X(in);				\
	dw = W(out) - W(in);				\
t = -(X(in) + W(in)) / (dw+dx);			\
	X(new) = X(in) + t * dx;			\
	Y(new) = Y(in) + t * (Y(out) - Y(in));		\
	Z(new) = Z(in) + t * (Z(out) - Z(in));		\
	W(new) = W(in) + t * dw;
GENERAL_CLIP
#undef OUTSIDE
#undef COMPUTE_INTERSECTION
#define OUTSIDE(K)      (Y(K) > W(K))
#define COMPUTE_INTERSECTION( new, in, out )		\
	dy = Y(out) - Y(in);				\
	dw = W(out) - W(in);				\
t = (Y(in) - W(in)) / (dw-dy);			\
	X(new) = X(in) + t * (X(out) - X(in));		\
	Y(new) = Y(in) + t * dy;			\
	Z(new) = Z(in) + t * (Z(out) - Z(in));		\
	W(new) = W(in) + t * dw;
GENERAL_CLIP
#undef OUTSIDE
#undef COMPUTE_INTERSECTION
#define OUTSIDE(K)      (Y(K) < -W(K))
#define COMPUTE_INTERSECTION( new, in, out )		\
dy = Y(out) - Y(in);				\
dw = W(out) - W(in);				\
t = -(Y(in) + W(in)) / (dw+dy);			\
X(new) = X(in) + t * (X(out) - X(in));		\
	Y(new) = Y(in) + t * dy;			\
	Z(new) = Z(in) + t * (Z(out) - Z(in));		\
	W(new) = W(in) + t * dw;
GENERAL_CLIP
#undef OUTSIDE
#undef COMPUTE_INTERSECTION
#define OUTSIDE(K)      (Z(K) > W(K))
#define COMPUTE_INTERSECTION( new, in, out )		\
dz = Z(out) - Z(in);				\
dw = W(out) - W(in);				\
t = (Z(in) - W(in)) / (dw-dz);			\
X(new) = X(in) + t * (X(out) - X(in));		\
Y(new) = Y(in) + t * (Y(out) - Y(in));		\
	Z(new) = Z(in) + t * dz;			\
	W(new) = W(in) + t * dw;

#undef OUTSIDE
#undef COMPUTE_INTERSECTION
#define OUTSIDE(K)      (Z(K) < -W(K))
#define COMPUTE_INTERSECTION( new, in, out )		\
dz = Z(out) - Z(in);				\
dw = W(out) - W(in);				\
t = -(Z(in) + W(in)) / (dw+dz);			\
X(new) = X(in) + t * (X(out) - X(in));		\
Y(new) = Y(in) + t * (Y(out) - Y(in));		\
	Z(new) = Z(in) + t * dz;			\
	W(new) = W(in) + t * dw;
#undef OUTSIDE
#undef COMPUTE_INTERSECTION
#undef GENERAL_CLIP
*i = ii;
*j = jj;
return 1;
}
GLuint gl_viewclip_polygon( GLcontext* ctx, GLuint n, GLuint vlist[] )
{
struct vertex_buffer* VB = ctx->VB;
float (*coord)[4] = VB->Clip;
GLuint previ, prevj;
GLuint curri, currj;
GLuint vlist2[VB_SIZE];
GLuint n2;
GLdouble dx, dy, dz, dw, t, neww;
Space = CLIP_SPACE;
#define GENERAL_CLIP                                                    \
if (INCOUNT<3)  return 0;						\
previ = INCOUNT-1;			\
prevj = INLIST[previ];						\
OUTCOUNT = 0;                                                        \
for (curri=0;curri<INCOUNT;curri++) {				\
currj = INLIST[curri];						\
if (INSIDE(currj)) {						\
if (INSIDE(prevj)) {						\
\
	    OUTLIST[OUTCOUNT] = currj;					\
	    OUTCOUNT++;							\
}                                                              \
else {                                                         \
	\
	    COMPUTE_INTERSECTION( currj, prevj,	VB->Free )		\
	    	\
	    if (t>0.0) {						\
	       		\
	       if (ctx->ClipMask)					\
		  interpolate_aux( ctx, VB->Free, t, currj, prevj );	\
	       VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];		\
	       					\
	       OUTLIST[OUTCOUNT] = VB->Free;				\
	       VB->Free++;						\
	       if (VB->Free==VB_SIZE)   VB->Free = 1;			\
	       OUTCOUNT++;						\
	    }								\
	    					\
	    OUTLIST[OUTCOUNT] = currj;					\
	    OUTCOUNT++;							\
}                                                              \
}                                                                 \
else {                                                            \
if (INSIDE(prevj)) {						\
	\
	    COMPUTE_INTERSECTION( prevj, currj, VB->Free )		\
	    	\
	    if (t>0.0) {						\
	       		\
	       if (ctx->ClipMask)					\
		  interpolate_aux( ctx, VB->Free, t, prevj, currj );	\
	       VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];		\
	       					\
	       OUTLIST[OUTCOUNT] = VB->Free;				\
	       VB->Free++;						\
	       if (VB->Free==VB_SIZE)   VB->Free = 1;			\
	       OUTCOUNT++;						\
	    }								\
}								\
		\
}									\
					\
previ = curri;							\
prevj = currj;							\
				\
if (OUTCOUNT>=VB_SIZE-1) {					\
	 					\
if (OUTLIST==vlist2) {						\
	    				\
	    int i;							\
	    for (i=0;i<VB_SIZE;i++) {					\
	       vlist[i] = OUTLIST[i];					\
	    }								\
	 }								\
	 return VB_SIZE-1;						\
}									\
}
#define X(I)	coord[I][0]
#define Y(I)	coord[I][1]
#define Z(I)	coord[I][2]
#define W(I)	coord[I][3]
#define INCOUNT n
#define OUTCOUNT n2
#define INLIST vlist
#define OUTLIST vlist2
#define INSIDE(K)      (X(K) <= W(K))
#define COMPUTE_INTERSECTION( in, out, new )		\
dx = X(out) - X(in);				\
dw = W(out) - W(in);				\
t = (X(in)-W(in)) / (dw-dx);			\
	neww = W(in) + t * dw;				\
	X(new) = neww;					\
	Y(new) = Y(in) + t * (Y(out) - Y(in));		\
	Z(new) = Z(in) + t * (Z(out) - Z(in)); 		\
	W(new) = neww;
GENERAL_CLIP
#undef INCOUNT
#undef OUTCOUNT
#undef INLIST
#undef OUTLIST
#undef INSIDE
#undef COMPUTE_INTERSECTION
#define INCOUNT n2
#define OUTCOUNT n
#define INLIST vlist2
#define OUTLIST vlist
#define INSIDE(K)       (X(K) >= -W(K))
#define COMPUTE_INTERSECTION( in, out, new )		\
dx = X(out)-X(in);                      	\
dw = W(out)-W(in);                      	\
t = -(X(in)+W(in)) / (dw+dx);           	\
	neww = W(in) + t * dw;				\
X(new) = -neww;					\
Y(new) = Y(in) + t * (Y(out) - Y(in));		\
Z(new) = Z(in) + t * (Z(out) - Z(in));		\
W(new) = neww;
GENERAL_CLIP
#undef INCOUNT
#undef OUTCOUNT
#undef INLIST
#undef OUTLIST
#undef INSIDE
#undef COMPUTE_INTERSECTION
#define INCOUNT n
#define OUTCOUNT n2
#define INLIST vlist
#define OUTLIST vlist2
#define INSIDE(K)       (Y(K) <= W(K))
#define COMPUTE_INTERSECTION( in, out, new )		\
dy = Y(out)-Y(in);                      	\
dw = W(out)-W(in);                      	\
t = (Y(in)-W(in)) / (dw-dy);            	\
	neww = W(in) + t * dw; 				\
X(new) = X(in) + t * (X(out) - X(in));		\
Y(new) = neww;					\
Z(new) = Z(in) + t * (Z(out) - Z(in));		\
W(new) = neww;
GENERAL_CLIP
#undef INCOUNT
#undef OUTCOUNT
#undef INLIST
#undef OUTLIST
#undef INSIDE
#undef COMPUTE_INTERSECTION
#define INCOUNT n2
#define OUTCOUNT n
#define INLIST vlist2
#define OUTLIST vlist
#define INSIDE(K)       (Y(K) >= -W(K))
#define COMPUTE_INTERSECTION( in, out, new )		\
dy = Y(out)-Y(in);                      	\
dw = W(out)-W(in);                      	\
t = -(Y(in)+W(in)) / (dw+dy);           	\
	neww = W(in) + t * dw;				\
X(new) = X(in) + t * (X(out) - X(in));		\
Y(new) = -neww;					\
Z(new) = Z(in) + t * (Z(out) - Z(in));		\
W(new) = neww;
GENERAL_CLIP
#undef INCOUNT
#undef OUTCOUNT
#undef INLIST
#undef OUTLIST
#undef INSIDE
#undef COMPUTE_INTERSECTION
#define INCOUNT n
#define OUTCOUNT n2
#define INLIST vlist
#define OUTLIST vlist2
#define INSIDE(K)       (Z(K) <= W(K))
#define COMPUTE_INTERSECTION( in, out, new )		\
dz = Z(out)-Z(in);                      	\
dw = W(out)-W(in);                      	\
t = (Z(in)-W(in)) / (dw-dz);            	\
	neww = W(in) + t * dw;				\
X(new) = X(in) + t * (X(out) - X(in));		\
Y(new) = Y(in) + t * (Y(out) - Y(in));		\
Z(new) = neww;					\
W(new) = neww;
GENERAL_CLIP
#undef INCOUNT
#undef OUTCOUNT
#undef INLIST
#undef OUTLIST
#undef INSIDE
#undef COMPUTE_INTERSECTION
#define INCOUNT n2
#define OUTCOUNT n
#define INLIST vlist2
#define OUTLIST vlist
#define INSIDE(K)       (Z(K) >= -W(K))
#define COMPUTE_INTERSECTION( in, out, new )		\
dz = Z(out)-Z(in);                      	\
dw = W(out)-W(in);                      	\
t = -(Z(in)+W(in)) / (dw+dz);           	\
	neww = W(in) + t * dw;				\
X(new) = X(in) + t * (X(out) - X(in));		\
Y(new) = Y(in) + t * (Y(out) - Y(in));		\
Z(new) = -neww;					\
W(new) = neww;
GENERAL_CLIP
#undef INCOUNT
#undef INLIST
#undef OUTLIST
#undef INSIDE
#undef COMPUTE_INTERSECTION
return OUTCOUNT;
#undef GENERAL_CLIP
#undef OUTCOUNT
}
GLuint gl_userclip_point( GLcontext* ctx, const float v[] )
{
GLuint p;
for (p=0;p<MAX_CLIP_PLANES;p++) {
if (ctx->Transform.ClipEnabled[p]) {
	 float dot = v[0] * ctx->Transform.ClipEquation[p][0]
		     + v[1] * ctx->Transform.ClipEquation[p][1]
		     + v[2] * ctx->Transform.ClipEquation[p][2]
		     + v[3] * ctx->Transform.ClipEquation[p][3];
if (dot < 0.0F) {
return 0;
}
}
}
return 1;
}
#define MAGIC_NUMBER -0.8e-03F
#define INSIDE( J, A, B, C, D )   				\
( (VB->Eye[J][0] * A + VB->Eye[J][1] * B			\
+ VB->Eye[J][2] * C + VB->Eye[J][3] * D) >= MAGIC_NUMBER )
#define OUTSIDE( J, A, B, C, D )   				\
( (VB->Eye[J][0] * A + VB->Eye[J][1] * B			\
+ VB->Eye[J][2] * C + VB->Eye[J][3] * D) < MAGIC_NUMBER )
GLuint gl_userclip_line( GLcontext* ctx, GLuint *i, GLuint *j )
{
struct vertex_buffer* VB = ctx->VB;
GLuint p, ii, jj;
Space = EYE_SPACE;
ii = *i;
jj = *j;
for (p=0;p<MAX_CLIP_PLANES;p++) {
if (ctx->Transform.ClipEnabled[p]) {
	 register float a, b, c, d;
	 a = ctx->Transform.ClipEquation[p][0];
	 b = ctx->Transform.ClipEquation[p][1];
	 c = ctx->Transform.ClipEquation[p][2];
	 d = ctx->Transform.ClipEquation[p][3];
if (OUTSIDE( ii, a,b,c,d  )) {
if (OUTSIDE( jj, a,b,c,d )) {
return 0;
}
else {
float dx, dy, dz, dw, t, denom;
dx = VB->Eye[ii][0] - VB->Eye[jj][0];
dy = VB->Eye[ii][1] - VB->Eye[jj][1];
dz = VB->Eye[ii][2] - VB->Eye[jj][2];
dw = VB->Eye[ii][3] - VB->Eye[jj][3];
	       denom = dx*a + dy*b + dz*c + dw*d;
	       if (denom==0.0) {
		  t = 0.0;
	       }
	       else {
		  t = -(VB->Eye[jj][0]*a+VB->Eye[jj][1]*b
		       +VB->Eye[jj][2]*c+VB->Eye[jj][3]*d) / denom;
if (t>1.0F)  t = 1.0F;
	       }
	       VB->Eye[VB->Free][0] = VB->Eye[jj][0] + t * dx;
	       VB->Eye[VB->Free][1] = VB->Eye[jj][1] + t * dy;
	       VB->Eye[VB->Free][2] = VB->Eye[jj][2] + t * dz;
	       VB->Eye[VB->Free][3] = VB->Eye[jj][3] + t * dw;
	
	       if (ctx->ClipMask)
		  interpolate_aux( ctx, VB->Free, t, jj, ii );
	       ii = VB->Free;
	       VB->Free++;
	       if (VB->Free==VB_SIZE)   VB->Free = 1;
}
}
else {
if (OUTSIDE( jj, a,b,c,d )) {
float dx, dy, dz, dw, t, denom;
dx = VB->Eye[jj][0] - VB->Eye[ii][0];
dy = VB->Eye[jj][1] - VB->Eye[ii][1];
dz = VB->Eye[jj][2] - VB->Eye[ii][2];
dw = VB->Eye[jj][3] - VB->Eye[ii][3];
	       denom = dx*a + dy*b + dz*c + dw*d;
	       if (denom==0.0) {
		  t = 0.0;
	       }
	       else {
		  t = -(VB->Eye[ii][0]*a+VB->Eye[ii][1]*b
		       +VB->Eye[ii][2]*c+VB->Eye[ii][3]*d) / denom;
if (t>1.0F)  t = 1.0F;
	       }
	       VB->Eye[VB->Free][0] = VB->Eye[ii][0] + t * dx;
	       VB->Eye[VB->Free][1] = VB->Eye[ii][1] + t * dy;
	       VB->Eye[VB->Free][2] = VB->Eye[ii][2] + t * dz;
	       VB->Eye[VB->Free][3] = VB->Eye[ii][3] + t * dw;
	
	       if (ctx->ClipMask)
		  interpolate_aux( ctx, VB->Free, t, ii, jj );
	       jj = VB->Free;
	       VB->Free++;
	       if (VB->Free==VB_SIZE)   VB->Free = 1;
}
else {
}
}
}
}
*i = ii;
*j = jj;
return 1;
}
GLuint gl_userclip_polygon( GLcontext* ctx, GLuint n, GLuint vlist[] )
{
struct vertex_buffer* VB = ctx->VB;
GLuint vlist2[VB_SIZE];
GLuint *inlist, *outlist;
GLuint incount, outcount;
GLuint curri, currj;
GLuint previ, prevj;
GLuint p;
Space = EYE_SPACE;
incount = n;
inlist = vlist;
outlist = vlist2;
for (p=0;p<MAX_CLIP_PLANES;p++) {
if (ctx->Transform.ClipEnabled[p]) {
	 register float a = ctx->Transform.ClipEquation[p][0];
	 register float b = ctx->Transform.ClipEquation[p][1];
	 register float c = ctx->Transform.ClipEquation[p][2];
	 register float d = ctx->Transform.ClipEquation[p][3];
	 if (incount<3)  return 0;
	
	 previ = incount - 1;
	 prevj = inlist[previ];
outcount = 0;
for (curri=0;curri<incount;curri++) {
	    currj = inlist[curri];
if (INSIDE(currj, a,b,c,d)) {
if (INSIDE(prevj, a,b,c,d)) {
		  outlist[outcount++] = currj;
}
else {
float dx, dy, dz, dw, t, denom;
		
		  dx = VB->Eye[prevj][0] - VB->Eye[currj][0];
		  dy = VB->Eye[prevj][1] - VB->Eye[currj][1];
		  dz = VB->Eye[prevj][2] - VB->Eye[currj][2];
		  dw = VB->Eye[prevj][3] - VB->Eye[currj][3];
		  denom = dx*a + dy*b + dz*c + dw*d;
		  if (denom==0.0) {
		     t = 0.0;
		  }
		  else {
		     t = -(VB->Eye[currj][0]*a+VB->Eye[currj][1]*b
		       +VB->Eye[currj][2]*c+VB->Eye[currj][3]*d) / denom;
if (t>1.0F) {
t = 1.0F;
}
		  }
		
		  VB->Eye[VB->Free][0] = VB->Eye[currj][0] + t*dx;
		  VB->Eye[VB->Free][1] = VB->Eye[currj][1] + t*dy;
		  VB->Eye[VB->Free][2] = VB->Eye[currj][2] + t*dz;
		  VB->Eye[VB->Free][3] = VB->Eye[currj][3] + t*dw;
		
		  if (ctx->ClipMask) {
		     interpolate_aux( ctx, VB->Free, t, currj, prevj);
		  }
		  VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
		
		  outlist[outcount++] = VB->Free;
		  VB->Free++;
		  if (VB->Free==VB_SIZE)   VB->Free = 1;
		
		  outlist[outcount++] = currj;
}
}
else {
if (INSIDE(prevj, a,b,c,d)) {
float dx, dy, dz, dw, t, denom;
		
dx = VB->Eye[currj][0]-VB->Eye[prevj][0];
dy = VB->Eye[currj][1]-VB->Eye[prevj][1];
dz = VB->Eye[currj][2]-VB->Eye[prevj][2];
dw = VB->Eye[currj][3]-VB->Eye[prevj][3];
		  denom = dx*a + dy*b + dz*c + dw*d;
		  if (denom==0.0) {
		     t = 0.0;
		  }
		  else {
		     t = -(VB->Eye[prevj][0]*a+VB->Eye[prevj][1]*b
		       +VB->Eye[prevj][2]*c+VB->Eye[prevj][3]*d) / denom;
if (t>1.0F) {
t = 1.0F;
}
		  }
		
		  VB->Eye[VB->Free][0] = VB->Eye[prevj][0] + t*dx;
		  VB->Eye[VB->Free][1] = VB->Eye[prevj][1] + t*dy;
		  VB->Eye[VB->Free][2] = VB->Eye[prevj][2] + t*dz;
		  VB->Eye[VB->Free][3] = VB->Eye[prevj][3] + t*dw;
		
		  if (ctx->ClipMask) {
		     interpolate_aux( ctx, VB->Free, t, prevj, currj);
		  }
		  VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
		
		  outlist[outcount++] = VB->Free;
		  VB->Free++;
		  if (VB->Free==VB_SIZE)   VB->Free = 1;
	       }
}
	    previ = curri;
	    prevj = currj;
	
if (outcount>=VB_SIZE-1) {
if (outlist!=vlist2) {
MEMCPY( vlist, vlist2, outcount * sizeof(GLuint) );
}
return VB_SIZE-1;
}
}
{
GLuint *tmp;
tmp = inlist;
inlist = outlist;
outlist = tmp;
incount = outcount;
}
}
}
if (outlist!=vlist2) {
MEMCPY( vlist, vlist2, outcount * sizeof(GLuint) );
}
return outcount;
}
/* 当前文件是D:\Read\colortab.c*/

#ifdef PC_HEADER
#else
#endif
static GLboolean power_of_two( GLint k )
{
GLint i, m = 1;
for (i=0; i<32; i++) {
if (k == m)
return GL_TRUE;
m = m << 1;
}
return GL_FALSE;
}
static GLint decode_internal_format( GLint format )
{
switch (format) {
case GL_ALPHA:
case GL_ALPHA4:
case GL_ALPHA8:
case GL_ALPHA12:
case GL_ALPHA16:
return GL_ALPHA;
case 1:
case GL_LUMINANCE:
case GL_LUMINANCE4:
case GL_LUMINANCE8:
case GL_LUMINANCE12:
case GL_LUMINANCE16:
return GL_LUMINANCE;
case 2:
case GL_LUMINANCE_ALPHA:
case GL_LUMINANCE4_ALPHA4:
case GL_LUMINANCE6_ALPHA2:
case GL_LUMINANCE8_ALPHA8:
case GL_LUMINANCE12_ALPHA4:
case GL_LUMINANCE12_ALPHA12:
case GL_LUMINANCE16_ALPHA16:
return GL_LUMINANCE_ALPHA;
case GL_INTENSITY:
case GL_INTENSITY4:
case GL_INTENSITY8:
case GL_INTENSITY12:
case GL_INTENSITY16:
return GL_INTENSITY;
case 3:
case GL_RGB:
case GL_R3_G3_B2:
case GL_RGB4:
case GL_RGB5:
case GL_RGB8:
case GL_RGB10:
case GL_RGB12:
case GL_RGB16:
return GL_RGB;
case 4:
case GL_RGBA:
case GL_RGBA2:
case GL_RGBA4:
case GL_RGB5_A1:
case GL_RGBA8:
case GL_RGB10_A2:
case GL_RGBA12:
case GL_RGBA16:
return GL_RGBA;
default:
return -1;
}
}
void gl_ColorTable( GLcontext *ctx, GLenum target,
GLenum internalFormat, struct gl_image *table )
{
struct gl_texture_object *texObj;
GLboolean proxy = GL_FALSE;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetBooleanv" );
return;
}
switch (target) {
case GL_TEXTURE_1D:
texObj = ctx->Texture.Current1D;
break;
case GL_TEXTURE_2D:
texObj = ctx->Texture.Current2D;
break;
case GL_TEXTURE_3D_EXT:
texObj = ctx->Texture.Current3D;
break;
case GL_PROXY_TEXTURE_1D:
texObj = ctx->Texture.Proxy1D;
proxy = GL_TRUE;
break;
case GL_PROXY_TEXTURE_2D:
texObj = ctx->Texture.Proxy2D;
proxy = GL_TRUE;
break;
case GL_PROXY_TEXTURE_3D_EXT:
texObj = ctx->Texture.Proxy3D;
proxy = GL_TRUE;
break;
case GL_SHARED_TEXTURE_PALETTE_EXT:
texObj = NULL;
break;
default:
gl_error(ctx, GL_INVALID_ENUM, "glColorTableEXT(target)");
return;
}
if (table->Width < 1 || table->Width > MAX_TEXTURE_PALETTE_SIZE
|| !power_of_two(table->Width)) {
gl_error(ctx, GL_INVALID_VALUE, "glColorTableEXT(width)");
if (proxy) {
texObj->PaletteSize = 0;
texObj->PaletteIntFormat = 0;
texObj->PaletteFormat = 0;
}
return;
}
if (texObj) {
texObj->PaletteSize = table->Width;
texObj->PaletteIntFormat = internalFormat;
texObj->PaletteFormat = decode_internal_format(internalFormat);
if (!proxy) {
MEMCPY(texObj->Palette, table->Data, table->Width*table->Components);
if (ctx->Driver.UpdateTexturePalette) {
(*ctx->Driver.UpdateTexturePalette)( ctx, texObj );
}
}
}
else {
ctx->Texture.PaletteSize = table->Width;
ctx->Texture.PaletteIntFormat = internalFormat;
ctx->Texture.PaletteFormat = decode_internal_format(internalFormat);
MEMCPY(ctx->Texture.Palette, table->Data, table->Width*table->Components);
if (ctx->Driver.UpdateTexturePalette) {
(*ctx->Driver.UpdateTexturePalette)( ctx, NULL );
}
}
}
void gl_ColorSubTable( GLcontext *ctx, GLenum target,
GLsizei start, struct gl_image *data )
{
gl_problem(ctx, "glColorSubTableEXT not implemented");
}
void gl_GetColorTable( GLcontext *ctx, GLenum target, GLenum format,
GLenum type, GLvoid *table )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetBooleanv" );
return;
}
switch (target) {
case GL_TEXTURE_1D:
break;
case GL_TEXTURE_2D:
break;
case GL_TEXTURE_3D_EXT:
break;
case GL_SHARED_TEXTURE_PALETTE_EXT:
break;
default:
gl_error(ctx, GL_INVALID_ENUM, "glGetColorTableEXT(target)");
return;
}
gl_problem(ctx, "glGetColorTableEXT not implemented!");
}
void gl_GetColorTableParameterfv( GLcontext *ctx, GLenum target,
GLenum pname, float *params )
{
GLint iparams[10];
gl_GetColorTableParameteriv( ctx, target, pname, iparams );
*params = (float) iparams[0];
}
void gl_GetColorTableParameteriv( GLcontext *ctx, GLenum target,
GLenum pname, GLint *params )
{
struct gl_texture_object *texObj;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetColorTableParameter" );
return;
}
switch (target) {
case GL_TEXTURE_1D:
texObj = ctx->Texture.Current1D;
break;
case GL_TEXTURE_2D:
texObj = ctx->Texture.Current2D;
break;
case GL_TEXTURE_3D_EXT:
texObj = ctx->Texture.Current3D;
break;
case GL_SHARED_TEXTURE_PALETTE_EXT:
texObj = NULL;
break;
default:
gl_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameter(target)");
return;
}
switch (pname) {
case GL_COLOR_TABLE_FORMAT_EXT:
if (texObj)
*params = texObj->PaletteIntFormat;
else
*params = ctx->Texture.PaletteIntFormat;
break;
case GL_COLOR_TABLE_WIDTH_EXT:
if (texObj)
*params = texObj->PaletteSize;
else
*params = ctx->Texture.PaletteSize;
break;
case GL_COLOR_TABLE_RED_SIZE_EXT:
*params = 8;
break;
case GL_COLOR_TABLE_GREEN_SIZE_EXT:
*params = 8;
break;
case GL_COLOR_TABLE_BLUE_SIZE_EXT:
*params = 8;
break;
case GL_COLOR_TABLE_ALPHA_SIZE_EXT:
*params = 8;
break;
case GL_COLOR_TABLE_LUMINANCE_SIZE_EXT:
*params = 8;
break;
case GL_COLOR_TABLE_INTENSITY_SIZE_EXT:
*params = 8;
break;
default:
gl_error(ctx, GL_INVALID_ENUM, "glGetColorTableParameter" );
return;
}
}
/* 当前文件是D:\Read\context.c*/

/* 当前文件是D:\Read\quads.h*/

#ifndef QUADS_H
#define QUADS_H

#endif
#ifdef THREADS
#define MAX_THREADS 20
static pid_t ThreadID[MAX_THREADS];
static GLcontext *ThreadContext[MAX_THREADS];
static int NumThreads = 0;
GLcontext *gl_get_thread_context( void )
{
pid_t id;
int i;
id = getpid();
for (i=0;i<MAX_THREADS;i++) {
if (ThreadID[i]==id) {
return ThreadContext[i];
}
}
return NULL;
}
static void set_thread_context( GLcontext *ctx )
{
pid_t id = getpid();
int i;
for (i=0;i<NumThreads;i++) {
if (ThreadID[i]==id) {
ThreadContext[i] = c;
return;
}
}
if (i<MAX_THREADS) {
ThreadID[i] = getpid();
ThreadContext[i] = c;
NumThreads++;
}
}
#else
GLcontext *CC = NULL;
#endif
#ifdef PROFILE
GLdouble gl_time( void )
{
static GLdouble prev_time = 0.0;
static GLdouble time;
struct tms tm;
clock_t clk;
clk = times(&tm);
#ifdef CLK_TCK
time = (double)clk / (double)CLK_TCK;
#else
time = (double)clk / (double)HZ;
#endif
if (time>prev_time) {
prev_time = time;
return time;
}
else {
return prev_time;
}
}
static void init_timings( GLcontext *ctx )
{
ctx->BeginEndCount = 0;
ctx->BeginEndTime = 0.0;
ctx->VertexCount = 0;
ctx->VertexTime = 0.0;
ctx->PointCount = 0;
ctx->PointTime = 0.0;
ctx->LineCount = 0;
ctx->LineTime = 0.0;
ctx->PolygonCount = 0;
ctx->PolygonTime = 0.0;
ctx->ClearCount = 0;
ctx->ClearTime = 0.0;
ctx->SwapCount = 0;
ctx->SwapTime = 0.0;
}
static void print_timings( GLcontext *ctx )
{
GLdouble beginendrate;
GLdouble vertexrate;
GLdouble pointrate;
GLdouble linerate;
GLdouble polygonrate;
GLdouble overhead;
GLdouble clearrate;
GLdouble swaprate;
GLdouble avgvertices;
if (ctx->BeginEndTime>0.0) {
beginendrate = ctx->BeginEndCount / ctx->BeginEndTime;
}
else {
beginendrate = 0.0;
}
if (ctx->VertexTime>0.0) {
vertexrate = ctx->VertexCount / ctx->VertexTime;
}
else {
vertexrate = 0.0;
}
if (ctx->PointTime>0.0) {
pointrate = ctx->PointCount / ctx->PointTime;
}
else {
pointrate = 0.0;
}
if (ctx->LineTime>0.0) {
linerate = ctx->LineCount / ctx->LineTime;
}
else {
linerate = 0.0;
}
if (ctx->PolygonTime>0.0) {
polygonrate = ctx->PolygonCount / ctx->PolygonTime;
}
else {
polygonrate = 0.0;
}
if (ctx->ClearTime>0.0) {
clearrate = ctx->ClearCount / ctx->ClearTime;
}
else {
clearrate = 0.0;
}
if (ctx->SwapTime>0.0) {
swaprate = ctx->SwapCount / ctx->SwapTime;
}
else {
swaprate = 0.0;
}
if (ctx->BeginEndCount>0) {
avgvertices = (GLdouble) ctx->VertexCount / (GLdouble) ctx->BeginEndCount;
}
else {
avgvertices = 0.0;
}
overhead = ctx->BeginEndTime - ctx->VertexTime - ctx->PointTime
- ctx->LineTime - ctx->PolygonTime;
printf("                          Count   Time (s)    Rate (/s) \n");
printf("--------------------------------------------------------\n");
printf("glBegin/glEnd           %7d  %8.3f   %10.3f\n",
ctx->BeginEndCount, ctx->BeginEndTime, beginendrate);
printf("  vertexes transformed  %7d  %8.3f   %10.3f\n",
ctx->VertexCount, ctx->VertexTime, vertexrate );
printf("  points rasterized     %7d  %8.3f   %10.3f\n",
ctx->PointCount, ctx->PointTime, pointrate );
printf("  lines rasterized      %7d  %8.3f   %10.3f\n",
ctx->LineCount, ctx->LineTime, linerate );
printf("  polygons rasterized   %7d  %8.3f   %10.3f\n",
ctx->PolygonCount, ctx->PolygonTime, polygonrate );
printf("  overhead                       %8.3f\n", overhead );
printf("glClear                 %7d  %8.3f   %10.3f\n",
ctx->ClearCount, ctx->ClearTime, clearrate );
printf("SwapBuffers             %7d  %8.3f   %10.3f\n",
ctx->SwapCount, ctx->SwapTime, swaprate );
printf("\n");
printf("Average number of vertices per begin/end: %8.3f\n", avgvertices );
}
#endif
static struct gl_shared_state *alloc_shared_state( void )
{
struct gl_shared_state *ss;
ss = (struct gl_shared_state*) calloc( 1, sizeof(struct gl_shared_state) );
if (!ss)
return NULL;
ss->DisplayList = NewHashTable();
ss->TexObjects = NewHashTable();
ss->Default1D = gl_alloc_texture_object(ss, 0, 1);
ss->Default2D = gl_alloc_texture_object(ss, 0, 2);
ss->Default3D = gl_alloc_texture_object(ss, 0, 3);
if (!ss->DisplayList || !ss->TexObjects
|| !ss->Default1D || !ss->Default2D || !ss->Default3D) {
if (!ss->DisplayList)
DeleteHashTable(ss->DisplayList);
if (!ss->TexObjects)
DeleteHashTable(ss->TexObjects);
if (!ss->Default1D)
gl_free_texture_object(ss, ss->Default1D);
if (!ss->Default2D)
gl_free_texture_object(ss, ss->Default2D);
if (!ss->Default3D)
gl_free_texture_object(ss, ss->Default3D);
free(ss);
return NULL;
}
else {
return ss;
}
}
static void free_shared_state( GLcontext *ctx, struct gl_shared_state *ss )
{
while (1) {
GLuint list = HashFirstEntry(ss->DisplayList);
if (list) {
gl_destroy_list(ctx, list);
}
else {
break;
}
}
DeleteHashTable(ss->DisplayList);
while (ss->TexObjectList)
{
gl_free_texture_object(ss, ss->TexObjectList);
}
DeleteHashTable(ss->TexObjects);
free(ss);
}
static void init_light( struct gl_light *l, GLuint n )
{
ASSIGN_4V( l->Ambient, 0.0, 0.0, 0.0, 1.0 );
if (n==0) {
ASSIGN_4V( l->Diffuse, 1.0, 1.0, 1.0, 1.0 );
ASSIGN_4V( l->Specular, 1.0, 1.0, 1.0, 1.0 );
}
else {
ASSIGN_4V( l->Diffuse, 0.0, 0.0, 0.0, 1.0 );
ASSIGN_4V( l->Specular, 0.0, 0.0, 0.0, 1.0 );
}
ASSIGN_4V( l->Position, 0.0, 0.0, 1.0, 0.0 );
ASSIGN_3V( l->Direction, 0.0, 0.0, -1.0 );
l->SpotExponent = 0.0;
gl_compute_spot_exp_table( l );
l->SpotCutoff = 180.0;
l->CosCutoff = -1.0;
l->ConstantAttenuation = 1.0;
l->LinearAttenuation = 0.0;
l->QuadraticAttenuation = 0.0;
l->Enabled = GL_FALSE;
}
static void init_lightmodel( struct gl_lightmodel *lm )
{
ASSIGN_4V( lm->Ambient, 0.2, 0.2, 0.2, 1.0 );
lm->LocalViewer = GL_FALSE;
lm->TwoSide = GL_FALSE;
}
static void init_material( struct gl_material *m )
{
ASSIGN_4V( m->Ambient,  0.2, 0.2, 0.2, 1.0 );
ASSIGN_4V( m->Diffuse,  0.8, 0.8, 0.8, 1.0 );
ASSIGN_4V( m->Specular, 0.0, 0.0, 0.0, 1.0 );
ASSIGN_4V( m->Emission, 0.0, 0.0, 0.0, 1.0 );
m->Shininess = 0.0;
m->AmbientIndex = 0;
m->DiffuseIndex = 1;
m->SpecularIndex = 1;
gl_compute_material_shine_table( m );
}
static void initialize_context( GLcontext *ctx )
{
static float identity[16] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
};
GLuint i;
if (ctx) {
ctx->NewModelViewMatrix = GL_FALSE;
ctx->ModelViewMatrixType = MATRIX_IDENTITY;
MEMCPY( ctx->ModelViewMatrix, identity, 16*sizeof(float) );
MEMCPY( ctx->ModelViewInv, identity, 16*sizeof(float) );
ctx->ModelViewStackDepth = 0;
ctx->NewProjectionMatrix = GL_FALSE;
ctx->ProjectionMatrixType = MATRIX_IDENTITY;
MEMCPY( ctx->ProjectionMatrix, identity, 16*sizeof(float) );
ctx->ProjectionStackDepth = 0;
ctx->NearFarStack[0][0] = 1.0;
ctx->NearFarStack[0][1] = 0.0;
ctx->NewTextureMatrix = GL_FALSE;
ctx->TextureMatrixType = MATRIX_IDENTITY;
MEMCPY( ctx->TextureMatrix, identity, 16*sizeof(float) );
ctx->TextureStackDepth = 0;
ASSIGN_4V( ctx->Accum.ClearColor, 0.0, 0.0, 0.0, 0.0 );
ctx->Color.IndexMask = 0xffffffff;
ctx->Color.ColorMask = 0xf;
ctx->Color.SWmasking = GL_FALSE;
ctx->Color.ClearIndex = 0;
ASSIGN_4V( ctx->Color.ClearColor, 0.0, 0.0, 0.0, 0.0 );
ctx->Color.DrawBuffer = GL_FRONT;
ctx->Color.AlphaEnabled = GL_FALSE;
ctx->Color.AlphaFunc = GL_ALWAYS;
ctx->Color.AlphaRef = 0.0;
ctx->Color.AlphaRefUbyte = 0;
ctx->Color.BlendEnabled = GL_FALSE;
ctx->Color.BlendSrc = GL_ONE;
ctx->Color.BlendDst = GL_ZERO;
ctx->Color.BlendEquation = GL_FUNC_ADD_EXT;
ASSIGN_4V( ctx->Color.BlendColor, 0.0, 0.0, 0.0, 0.0 );
ctx->Color.IndexLogicOpEnabled = GL_FALSE;
ctx->Color.ColorLogicOpEnabled = GL_FALSE;
ctx->Color.SWLogicOpEnabled = GL_FALSE;
ctx->Color.LogicOp = GL_COPY;
ctx->Color.DitherFlag = GL_TRUE;
ctx->Current.Index = 1;
ASSIGN_3V( ctx->Current.Normal, 0.0, 0.0, 1.0 );
ctx->Current.ByteColor[0] = (GLint) ctx->Visual->RedScale;
ctx->Current.ByteColor[1] = (GLint) ctx->Visual->GreenScale;
ctx->Current.ByteColor[2] = (GLint) ctx->Visual->BlueScale;
ctx->Current.ByteColor[3] = (GLint) ctx->Visual->AlphaScale;
ASSIGN_4V( ctx->Current.RasterPos, 0.0, 0.0, 0.0, 1.0 );
ctx->Current.RasterPosValid = GL_TRUE;
ctx->Current.RasterIndex = 1;
ASSIGN_4V( ctx->Current.TexCoord, 0.0, 0.0, 0.0, 1.0 );
ASSIGN_4V( ctx->Current.RasterColor, 1.0, 1.0, 1.0, 1.0 );
ctx->Current.EdgeFlag = GL_TRUE;
ctx->Depth.Test = GL_FALSE;
ctx->Depth.Clear = 1.0;
ctx->Depth.Func = GL_LESS;
ctx->Depth.Mask = GL_TRUE;
ctx->Eval.Map1Color4 = GL_FALSE;
ctx->Eval.Map1Index = GL_FALSE;
ctx->Eval.Map1Normal = GL_FALSE;
ctx->Eval.Map1TextureCoord1 = GL_FALSE;
ctx->Eval.Map1TextureCoord2 = GL_FALSE;
ctx->Eval.Map1TextureCoord3 = GL_FALSE;
ctx->Eval.Map1TextureCoord4 = GL_FALSE;
ctx->Eval.Map1Vertex3 = GL_FALSE;
ctx->Eval.Map1Vertex4 = GL_FALSE;
ctx->Eval.Map2Color4 = GL_FALSE;
ctx->Eval.Map2Index = GL_FALSE;
ctx->Eval.Map2Normal = GL_FALSE;
ctx->Eval.Map2TextureCoord1 = GL_FALSE;
ctx->Eval.Map2TextureCoord2 = GL_FALSE;
ctx->Eval.Map2TextureCoord3 = GL_FALSE;
ctx->Eval.Map2TextureCoord4 = GL_FALSE;
ctx->Eval.Map2Vertex3 = GL_FALSE;
ctx->Eval.Map2Vertex4 = GL_FALSE;
ctx->Eval.AutoNormal = GL_FALSE;
ctx->Eval.MapGrid1un = 1;
ctx->Eval.MapGrid1u1 = 0.0;
ctx->Eval.MapGrid1u2 = 1.0;
ctx->Eval.MapGrid2un = 1;
ctx->Eval.MapGrid2vn = 1;
ctx->Eval.MapGrid2u1 = 0.0;
ctx->Eval.MapGrid2u2 = 1.0;
ctx->Eval.MapGrid2v1 = 0.0;
ctx->Eval.MapGrid2v2 = 1.0;
ctx->Fog.Enabled = GL_FALSE;
ctx->Fog.Mode = GL_EXP;
ASSIGN_4V( ctx->Fog.Color, 0.0, 0.0, 0.0, 0.0 );
ctx->Fog.Index = 0.0;
ctx->Fog.Density = 1.0;
ctx->Fog.Start = 0.0;
ctx->Fog.End = 1.0;
ctx->Hint.PerspectiveCorrection = GL_DONT_CARE;
ctx->Hint.PointSmooth = GL_DONT_CARE;
ctx->Hint.LineSmooth = GL_DONT_CARE;
ctx->Hint.PolygonSmooth = GL_DONT_CARE;
ctx->Hint.Fog = GL_DONT_CARE;
for (i=0;i<MAX_LIGHTS;i++) {
	 init_light( &ctx->Light.Light[i], i );
}
init_lightmodel( &ctx->Light.Model );
init_material( &ctx->Light.Material[0] );
init_material( &ctx->Light.Material[1] );
ctx->Light.ShadeModel = GL_SMOOTH;
ctx->Light.Enabled = GL_FALSE;
ctx->Light.ColorMaterialFace = GL_FRONT_AND_BACK;
ctx->Light.ColorMaterialMode = GL_AMBIENT_AND_DIFFUSE;
ctx->Light.ColorMaterialBitmask
= gl_material_bitmask( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE );
ctx->Light.ColorMaterialEnabled = GL_FALSE;
ctx->Line.SmoothFlag = GL_FALSE;
ctx->Line.StippleFlag = GL_FALSE;
ctx->Line.Width = 1.0;
ctx->Line.StipplePattern = 0xffff;
ctx->Line.StippleFactor = 1;
ctx->List.ListBase = 0;
ctx->Pixel.RedBias = 0.0;
ctx->Pixel.RedScale = 1.0;
ctx->Pixel.GreenBias = 0.0;
ctx->Pixel.GreenScale = 1.0;
ctx->Pixel.BlueBias = 0.0;
ctx->Pixel.BlueScale = 1.0;
ctx->Pixel.AlphaBias = 0.0;
ctx->Pixel.AlphaScale = 1.0;
ctx->Pixel.DepthBias = 0.0;
ctx->Pixel.DepthScale = 1.0;
ctx->Pixel.IndexOffset = 0;
ctx->Pixel.IndexShift = 0;
ctx->Pixel.ZoomX = 1.0;
ctx->Pixel.ZoomY = 1.0;
ctx->Pixel.MapColorFlag = GL_FALSE;
ctx->Pixel.MapStencilFlag = GL_FALSE;
ctx->Pixel.MapStoSsize = 1;
ctx->Pixel.MapItoIsize = 1;
ctx->Pixel.MapItoRsize = 1;
ctx->Pixel.MapItoGsize = 1;
ctx->Pixel.MapItoBsize = 1;
ctx->Pixel.MapItoAsize = 1;
ctx->Pixel.MapRtoRsize = 1;
ctx->Pixel.MapGtoGsize = 1;
ctx->Pixel.MapBtoBsize = 1;
ctx->Pixel.MapAtoAsize = 1;
ctx->Pixel.MapStoS[0] = 0;
ctx->Pixel.MapItoI[0] = 0;
ctx->Pixel.MapItoR[0] = 0.0;
ctx->Pixel.MapItoG[0] = 0.0;
ctx->Pixel.MapItoB[0] = 0.0;
ctx->Pixel.MapItoA[0] = 0.0;
ctx->Pixel.MapRtoR[0] = 0.0;
ctx->Pixel.MapGtoG[0] = 0.0;
ctx->Pixel.MapBtoB[0] = 0.0;
ctx->Pixel.MapAtoA[0] = 0.0;
ctx->Point.SmoothFlag = GL_FALSE;
ctx->Point.Size = 1.0;
ctx->Point.Params[0] = 1.0;
ctx->Point.Params[1] = 0.0;
ctx->Point.Params[2] = 0.0;
ctx->Point.MinSize = 0.0;
ctx->Point.MaxSize = (float) MAX_POINT_SIZE;
ctx->Point.Threshold = 1.0;
ctx->Polygon.CullFlag = GL_FALSE;
ctx->Polygon.CullFaceMode = GL_BACK;
ctx->Polygon.FrontFace = GL_CCW;
ctx->Polygon.FrontMode = GL_FILL;
ctx->Polygon.BackMode = GL_FILL;
ctx->Polygon.Unfilled = GL_FALSE;
ctx->Polygon.SmoothFlag = GL_FALSE;
ctx->Polygon.StippleFlag = GL_FALSE;
ctx->Polygon.OffsetFactor = 0.0F;
ctx->Polygon.OffsetUnits = 0.0F;
ctx->Polygon.OffsetPoint = GL_FALSE;
ctx->Polygon.OffsetLine = GL_FALSE;
ctx->Polygon.OffsetFill = GL_FALSE;
ctx->Polygon.OffsetAny = GL_FALSE;
MEMSET( ctx->PolygonStipple, 0xff, 32*sizeof(GLuint) );
ctx->Scissor.Enabled = GL_FALSE;
ctx->Scissor.X = 0;
ctx->Scissor.Y = 0;
ctx->Scissor.Width = 0;
ctx->Scissor.Height = 0;
ctx->Stencil.Enabled = GL_FALSE;
ctx->Stencil.Function = GL_ALWAYS;
ctx->Stencil.FailFunc = GL_KEEP;
ctx->Stencil.ZPassFunc = GL_KEEP;
ctx->Stencil.ZFailFunc = GL_KEEP;
ctx->Stencil.Ref = 0;
ctx->Stencil.ValueMask = 0xff;
ctx->Stencil.Clear = 0;
ctx->Stencil.WriteMask = 0xff;
ctx->Texture.Enabled = 0;
ctx->Texture.EnvMode = GL_MODULATE;
ASSIGN_4V( ctx->Texture.EnvColor, 0.0, 0.0, 0.0, 0.0 );
ctx->Texture.TexGenEnabled = 0;
ctx->Texture.GenModeS = GL_EYE_LINEAR;
ctx->Texture.GenModeT = GL_EYE_LINEAR;
ctx->Texture.GenModeR = GL_EYE_LINEAR;
ctx->Texture.GenModeQ = GL_EYE_LINEAR;
ASSIGN_4V( ctx->Texture.ObjectPlaneS, 1.0, 0.0, 0.0, 0.0 );
ASSIGN_4V( ctx->Texture.ObjectPlaneT, 0.0, 1.0, 0.0, 0.0 );
ASSIGN_4V( ctx->Texture.ObjectPlaneR, 0.0, 0.0, 0.0, 0.0 );
ASSIGN_4V( ctx->Texture.ObjectPlaneQ, 0.0, 0.0, 0.0, 0.0 );
ASSIGN_4V( ctx->Texture.EyePlaneS, 1.0, 0.0, 0.0, 0.0 );
ASSIGN_4V( ctx->Texture.EyePlaneT, 0.0, 1.0, 0.0, 0.0 );
ASSIGN_4V( ctx->Texture.EyePlaneR, 0.0, 0.0, 0.0, 0.0 );
ASSIGN_4V( ctx->Texture.EyePlaneQ, 0.0, 0.0, 0.0, 0.0 );
#if 00
assert( ctx->Shared->TexObjectList );
assert( ctx->Shared->TexObjectList->Next );
ctx->Texture.Current1D = ctx->Shared->TexObjectList;
ctx->Texture.Current2D = ctx->Shared->TexObjectList->Next;
ctx->Texture.Current3D = ctx->Shared->TexObjectList->Next->Next;
#else
ctx->Texture.Current1D = ctx->Shared->Default1D;
ctx->Texture.Current2D = ctx->Shared->Default2D;
ctx->Texture.Current3D = ctx->Shared->Default3D;
#endif
ctx->Texture.SharedPalette = GL_FALSE;
ctx->Texture.Palette[0] = 255;
ctx->Texture.Palette[1] = 255;
ctx->Texture.Palette[2] = 255;
ctx->Texture.Palette[3] = 255;
ctx->Texture.PaletteSize = 1;
ctx->Texture.PaletteIntFormat = GL_RGBA;
ctx->Texture.PaletteFormat = GL_RGBA;
ctx->Transform.MatrixMode = GL_MODELVIEW;
ctx->Transform.Normalize = GL_FALSE;
for (i=0;i<MAX_CLIP_PLANES;i++) {
	 ctx->Transform.ClipEnabled[i] = GL_FALSE;
ASSIGN_4V( ctx->Transform.ClipEquation[i], 0.0, 0.0, 0.0, 0.0 );
}
ctx->Transform.AnyClip = GL_FALSE;
ctx->Viewport.X = 0;
ctx->Viewport.Y = 0;
ctx->Viewport.Width = 0;
ctx->Viewport.Height = 0;
ctx->Viewport.Near = 0.0;
ctx->Viewport.Far = 1.0;
ctx->Viewport.Sx = 0.0;
ctx->Viewport.Tx = 0.0;
ctx->Viewport.Sy = 0.0;
ctx->Viewport.Ty = 0.0;
ctx->Viewport.Sz = 0.5 * DEPTH_SCALE;
ctx->Viewport.Tz = 0.5 * DEPTH_SCALE;
ctx->Pack.Alignment = 4;
ctx->Pack.RowLength = 0;
ctx->Pack.SkipPixels = 0;
ctx->Pack.SkipRows = 0;
ctx->Pack.SwapBytes = GL_FALSE;
ctx->Pack.LsbFirst = GL_FALSE;
ctx->Unpack.Alignment = 4;
ctx->Unpack.RowLength = 0;
ctx->Unpack.SkipPixels = 0;
ctx->Unpack.SkipRows = 0;
ctx->Unpack.SwapBytes = GL_FALSE;
ctx->Unpack.LsbFirst = GL_FALSE;
ctx->Feedback.Type = GL_2D;
ctx->Feedback.Buffer = NULL;
ctx->Feedback.BufferSize = 0;
ctx->Feedback.Count = 0;
ctx->Select.Buffer = NULL;
ctx->Select.BufferSize = 0;
ctx->Select.BufferCount = 0;
ctx->Select.Hits = 0;
ctx->Select.NameStackDepth = 0;
ctx->AttribStackDepth = 0;
ctx->ClientAttribStackDepth = 0;
ctx->NewState = NEW_ALL;
ctx->RenderMode = GL_RENDER;
ctx->Primitive = GL_BITMAP;
ctx->StippleCounter = 0;
ctx->NeedNormals = GL_FALSE;
if (   ctx->Visual->RedScale==255.0F
&& ctx->Visual->GreenScale==255.0F
&& ctx->Visual->BlueScale==255.0F
&& ctx->Visual->AlphaScale==255.0F) {
ctx->Visual->EightBitColor = GL_TRUE;
}
else {
ctx->Visual->EightBitColor = GL_FALSE;
}
ctx->FastDrawPixels = ctx->Visual->RGBAflag && ctx->Visual->EightBitColor;
#if JUNK
ctx->PointsFunc = NULL;
ctx->LineFunc = NULL;
ctx->TriangleFunc = NULL;
#endif
ctx->DirectContext = GL_TRUE;
ctx->CallDepth = 0;
ctx->ExecuteFlag = GL_TRUE;
ctx->CompileFlag = GL_FALSE;
ctx->ErrorValue = GL_NO_ERROR;
ctx->NoRaster = getenv("MESA_NO_RASTER") ? GL_TRUE : GL_FALSE;
ctx->NoDither = getenv("MESA_NO_DITHER") ? GL_TRUE : GL_FALSE;
if (ctx->NoDither) {
if (getenv("MESA_DEBUG")) {
fprintf(stderr, "MESA_NO_DITHER set - dithering disabled\n");
}
ctx->Color.DitherFlag = GL_FALSE;
}
}
}
GLvisual *gl_create_visual( GLboolean rgb_flag,
GLboolean alpha_flag,
GLboolean db_flag,
GLint depth_bits,
GLint stencil_bits,
GLint accum_bits,
GLint index_bits,
float red_scale,
float green_scale,
float blue_scale,
float alpha_scale,
GLint red_bits,
GLint green_bits,
GLint blue_bits,
GLint alpha_bits )
{
GLvisual *vis;
assert( red_scale<=255.0 );
assert( green_scale<=255.0 );
assert( blue_scale<=255.0 );
assert( alpha_scale<=255.0 );
if (depth_bits > 8*sizeof(GLdepth)) {
return NULL;
}
if (stencil_bits > 8*sizeof(GLstencil)) {
return NULL;
}
if (accum_bits > 8*sizeof(GLaccum)) {
return NULL;
}
vis = (GLvisual *) calloc( 1, sizeof(GLvisual) );
if (!vis) {
return NULL;
}
vis->RGBAflag      = rgb_flag;
vis->DBflag        = db_flag;
vis->RedScale      = red_scale;
vis->GreenScale    = green_scale;
vis->BlueScale     = blue_scale;
vis->AlphaScale    = alpha_scale;
if (red_scale) {
vis->InvRedScale   = 1.0F / red_scale;
}
if (green_scale) {
vis->InvGreenScale = 1.0F / green_scale;
}
if (blue_scale) {
vis->InvBlueScale  = 1.0F / blue_scale;
}
if (alpha_scale) {
vis->InvAlphaScale = 1.0F / alpha_scale;
}
vis->RedBits   = red_bits;
vis->GreenBits = green_bits;
vis->BlueBits  = blue_bits;
vis->AlphaBits = alpha_flag ? 8*sizeof(GLubyte) : alpha_bits;
vis->IndexBits   = index_bits;
vis->DepthBits   = (depth_bits>0) ? 8*sizeof(GLdepth) : 0;
vis->AccumBits   = (accum_bits>0) ? 8*sizeof(GLaccum) : 0;
vis->StencilBits = (stencil_bits>0) ? 8*sizeof(GLstencil) : 0;
if (red_scale==255.0F && green_scale==255.0F
&& blue_scale==255.0F && alpha_scale==255.0F) {
vis->EightBitColor = GL_TRUE;
}
else {
vis->EightBitColor = GL_FALSE;
}
if (alpha_flag) {
vis->FrontAlphaEnabled = GL_TRUE;
if (db_flag) {
vis->BackAlphaEnabled = GL_TRUE;
}
}
return vis;
}
void gl_destroy_visual( GLvisual *vis )
{
free( vis );
}
static GLboolean alloc_proxy_textures( GLcontext *ctx )
{
GLboolean out_of_memory;
GLint i;
ctx->Texture.Proxy1D = gl_alloc_texture_object(NULL, 0, 1);
if (!ctx->Texture.Proxy1D) {
return GL_FALSE;
}
ctx->Texture.Proxy2D = gl_alloc_texture_object(NULL, 0, 2);
if (!ctx->Texture.Proxy2D) {
gl_free_texture_object(NULL, ctx->Texture.Proxy1D);
return GL_FALSE;
}
ctx->Texture.Proxy3D = gl_alloc_texture_object(NULL, 0, 3);
if (!ctx->Texture.Proxy3D) {
gl_free_texture_object(NULL, ctx->Texture.Proxy1D);
gl_free_texture_object(NULL, ctx->Texture.Proxy2D);
return GL_FALSE;
}
out_of_memory = GL_FALSE;
for (i=0;i<MAX_TEXTURE_LEVELS;i++) {
ctx->Texture.Proxy1D->Image[i] = gl_alloc_texture_image();
ctx->Texture.Proxy2D->Image[i] = gl_alloc_texture_image();
ctx->Texture.Proxy3D->Image[i] = gl_alloc_texture_image();
if (!ctx->Texture.Proxy1D->Image[i]
|| !ctx->Texture.Proxy2D->Image[i]
|| !ctx->Texture.Proxy3D->Image[i]) {
out_of_memory = GL_TRUE;
}
}
if (out_of_memory) {
for (i=0;i<MAX_TEXTURE_LEVELS;i++) {
if (ctx->Texture.Proxy1D->Image[i]) {
gl_free_texture_image(ctx->Texture.Proxy1D->Image[i]);
}
if (ctx->Texture.Proxy2D->Image[i]) {
gl_free_texture_image(ctx->Texture.Proxy2D->Image[i]);
}
if (ctx->Texture.Proxy3D->Image[i]) {
gl_free_texture_image(ctx->Texture.Proxy3D->Image[i]);
}
}
gl_free_texture_object(NULL, ctx->Texture.Proxy1D);
gl_free_texture_object(NULL, ctx->Texture.Proxy2D);
gl_free_texture_object(NULL, ctx->Texture.Proxy3D);
return GL_FALSE;
}
else {
return GL_TRUE;
}
}
GLcontext *gl_create_context( GLvisual *visual,
GLcontext *share_list,
void *driver_ctx )
{
GLcontext *ctx;
assert( sizeof(GLbyte) == 1 );
assert( sizeof(GLshort) >= 2 );
assert( sizeof(GLint) >= 4 );
assert( sizeof(GLubyte) == 1 );
assert( sizeof(GLushort) >= 2 );
assert( sizeof(GLuint) >= 4 );
gl_init_math();
gl_init_lists();
gl_init_eval();
ctx = (GLcontext *) calloc( 1, sizeof(GLcontext) );
if (!ctx) {
return NULL;
}
ctx->DriverCtx = driver_ctx;
ctx->Visual = visual;
ctx->Buffer = NULL;
ctx->VB = gl_alloc_vb();
if (!ctx->VB) {
free( ctx );
return NULL;
}
ctx->PB = gl_alloc_pb();
if (!ctx->PB) {
free( ctx->VB );
free( ctx );
return NULL;
}
if (share_list) {
ctx->Shared = share_list->Shared;
}
else {
ctx->Shared = alloc_shared_state();
if (!ctx->Shared) {
free(ctx->VB);
free(ctx->PB);
free(ctx);
return NULL;
}
}
ctx->Shared->RefCount++;
initialize_context( ctx );
if (visual->DBflag) {
ctx->Color.DrawBuffer = GL_BACK;
ctx->Pixel.ReadBuffer = GL_BACK;
}
else {
ctx->Color.DrawBuffer = GL_FRONT;
ctx->Pixel.ReadBuffer = GL_FRONT;
}
#ifdef PROFILE
init_timings( ctx );
#endif
#ifdef GL_VERSION_1_1
if (!alloc_proxy_textures(ctx)) {
free_shared_state(ctx, ctx->Shared);
free(ctx->VB);
free(ctx->PB);
free(ctx);
return NULL;
}
#endif
gl_init_api_function_pointers( ctx );
ctx->API = ctx->Exec;
return ctx;
}
void gl_destroy_context( GLcontext *ctx )
{
if (ctx) {
#ifdef PROFILE
if (getenv("MESA_PROFILE")) {
print_timings( ctx );
}
#endif
free( ctx->PB );
free( ctx->VB );
ctx->Shared->RefCount--;
assert(ctx->Shared->RefCount>=0);
if (ctx->Shared->RefCount==0) {
	
	 free_shared_state( ctx, ctx->Shared );
}
gl_free_texture_object( NULL, ctx->Texture.Proxy1D );
gl_free_texture_object( NULL, ctx->Texture.Proxy2D );
gl_free_texture_object( NULL, ctx->Texture.Proxy3D );
free( (void *) ctx );
#ifndef THREADS
if (ctx==CC) {
CC = NULL;
}
#endif
}
}
GLframebuffer *gl_create_framebuffer( GLvisual *visual )
{
GLframebuffer *buffer;
buffer = (GLframebuffer *) calloc( 1, sizeof(GLframebuffer) );
if (!buffer) {
return NULL;
}
buffer->Visual = visual;
return buffer;
}
void gl_destroy_framebuffer( GLframebuffer *buffer )
{
if (buffer) {
if (buffer->Depth) {
free( buffer->Depth );
}
if (buffer->Accum) {
free( buffer->Accum );
}
if (buffer->Stencil) {
free( buffer->Stencil );
}
if (buffer->FrontAlpha) {
free( buffer->FrontAlpha );
}
if (buffer->BackAlpha) {
free( buffer->BackAlpha );
}
free(buffer);
}
}
void gl_make_current( GLcontext *ctx, GLframebuffer *buffer )
{
#ifdef THREADS
set_thread_context( ctx );
#else
if (CC && CC->Buffer) {
CC->Buffer = NULL;
}
CC = ctx;
#endif
if (ctx && buffer) {
ctx->Buffer = buffer;
ctx->NewState = NEW_ALL;
gl_update_state( ctx );
}
}
GLcontext *gl_get_current_context( void )
{
#ifdef MULTI_THREADING
return gl_get_thread_context();
#else
return CC;
#endif
}
void gl_copy_context( const GLcontext *src, GLcontext *dst, GLuint mask )
{
if (mask & GL_ACCUM_BUFFER_BIT) {
MEMCPY( &dst->Accum, &src->Accum, sizeof(struct gl_accum_attrib) );
}
if (mask & GL_COLOR_BUFFER_BIT) {
MEMCPY( &dst->Color, &src->Color, sizeof(struct gl_colorbuffer_attrib) );
}
if (mask & GL_CURRENT_BIT) {
MEMCPY( &dst->Current, &src->Current, sizeof(struct gl_current_attrib) );
}
if (mask & GL_DEPTH_BUFFER_BIT) {
MEMCPY( &dst->Depth, &src->Depth, sizeof(struct gl_depthbuffer_attrib) );
}
if (mask & GL_ENABLE_BIT) {
}
if (mask & GL_EVAL_BIT) {
MEMCPY( &dst->Eval, &src->Eval, sizeof(struct gl_eval_attrib) );
}
if (mask & GL_FOG_BIT) {
MEMCPY( &dst->Fog, &src->Fog, sizeof(struct gl_fog_attrib) );
}
if (mask & GL_HINT_BIT) {
MEMCPY( &dst->Hint, &src->Hint, sizeof(struct gl_hint_attrib) );
}
if (mask & GL_LIGHTING_BIT) {
MEMCPY( &dst->Light, &src->Light, sizeof(struct gl_light_attrib) );
}
if (mask & GL_LINE_BIT) {
MEMCPY( &dst->Line, &src->Line, sizeof(struct gl_line_attrib) );
}
if (mask & GL_LIST_BIT) {
MEMCPY( &dst->List, &src->List, sizeof(struct gl_list_attrib) );
}
if (mask & GL_PIXEL_MODE_BIT) {
MEMCPY( &dst->Pixel, &src->Pixel, sizeof(struct gl_pixel_attrib) );
}
if (mask & GL_POINT_BIT) {
MEMCPY( &dst->Point, &src->Point, sizeof(struct gl_point_attrib) );
}
if (mask & GL_POLYGON_BIT) {
MEMCPY( &dst->Polygon, &src->Polygon, sizeof(struct gl_polygon_attrib) );
}
if (mask & GL_POLYGON_STIPPLE_BIT) {
MEMCPY( &dst->PolygonStipple, &src->PolygonStipple, 32*sizeof(GLuint) );
}
if (mask & GL_SCISSOR_BIT) {
MEMCPY( &dst->Scissor, &src->Scissor, sizeof(struct gl_scissor_attrib) );
}
if (mask & GL_STENCIL_BUFFER_BIT) {
MEMCPY( &dst->Stencil, &src->Stencil, sizeof(struct gl_stencil_attrib) );
}
if (mask & GL_TEXTURE_BIT) {
MEMCPY( &dst->Texture, &src->Texture, sizeof(struct gl_texture_attrib) );
}
if (mask & GL_TRANSFORM_BIT) {
MEMCPY( &dst->Transform, &src->Transform, sizeof(struct gl_transform_attrib) );
}
if (mask & GL_VIEWPORT_BIT) {
MEMCPY( &dst->Viewport, &src->Viewport, sizeof(struct gl_viewport_attrib) );
}
}
void gl_set_api_table( GLcontext *ctx, const struct gl_api_table *api )
{
if (api) {
MEMCPY( &ctx->API, api, sizeof(struct gl_api_table) );
}
else {
MEMCPY( &ctx->API, &ctx->Exec, sizeof(struct gl_api_table) );
}
}
void gl_problem( const GLcontext *ctx, const char *s )
{
fprintf( stderr, "Mesa implementation error: %s\n", s );
fprintf( stderr, "Report to Mesa author.\n" );
}
void gl_warning( const GLcontext *ctx, const char *s )
{
GLboolean debug;
#ifdef DEBUG
debug = GL_TRUE;
#else
if (getenv("MESA_DEBUG")) {
debug = GL_TRUE;
}
else {
debug = GL_FALSE;
}
#endif
if (debug) {
fprintf( stderr, "Mesa warning: %s\n", s );
}
}
void gl_error( GLcontext *ctx, GLenum error, const char *s )
{
GLboolean debug;
#ifdef DEBUG
debug = GL_TRUE;
#else
if (getenv("MESA_DEBUG")) {
debug = GL_TRUE;
}
else {
debug = GL_FALSE;
}
#endif
if (debug) {
char errstr[1000];
switch (error) {
	 case GL_NO_ERROR:
	    strcpy( errstr, "GL_NO_ERROR" );
	    break;
	 case GL_INVALID_VALUE:
	    strcpy( errstr, "GL_INVALID_VALUE" );
	    break;
	 case GL_INVALID_ENUM:
	    strcpy( errstr, "GL_INVALID_ENUM" );
	    break;
	 case GL_INVALID_OPERATION:
	    strcpy( errstr, "GL_INVALID_OPERATION" );
	    break;
	 case GL_STACK_OVERFLOW:
	    strcpy( errstr, "GL_STACK_OVERFLOW" );
	    break;
	 case GL_STACK_UNDERFLOW:
	    strcpy( errstr, "GL_STACK_UNDERFLOW" );
	    break;
	 case GL_OUT_OF_MEMORY:
	    strcpy( errstr, "GL_OUT_OF_MEMORY" );
	    break;
	 default:
	    strcpy( errstr, "unknown" );
	    break;
}
fprintf( stderr, "Mesa user error: %s in %s\n", errstr, s );
}
if (ctx->ErrorValue==GL_NO_ERROR) {
ctx->ErrorValue = error;
}
if (ctx->Driver.Error) {
(*ctx->Driver.Error)( ctx );
}
}
GLenum gl_GetError( GLcontext *ctx )
{
GLenum e;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetError" );
return GL_INVALID_OPERATION;
}
e = ctx->ErrorValue;
ctx->ErrorValue = GL_NO_ERROR;
return e;
}
void gl_ResizeBuffersMESA( GLcontext *ctx )
{
GLint newsize;
GLuint buf_width, buf_height;
ctx->NewState |= NEW_ALL;
(*ctx->Driver.GetBufferSize)( ctx, &buf_width, &buf_height );
newsize = ctx->Buffer->Width!=buf_width || ctx->Buffer->Height!=buf_height;
ctx->Buffer->Width = buf_width;
ctx->Buffer->Height = buf_height;
if (newsize && ctx->Visual->DepthBits>0) {
(*ctx->Driver.AllocDepthBuffer)( ctx );
}
if (newsize && ctx->Visual->StencilBits>0) {
gl_alloc_stencil_buffer( ctx );
}
if (newsize && ctx->Visual->AccumBits>0) {
gl_alloc_accum_buffer( ctx );
}
if (newsize
&& (ctx->Visual->FrontAlphaEnabled || ctx->Visual->BackAlphaEnabled)) {
gl_alloc_alpha_buffers( ctx );
}
}
static void update_pixel_logic( GLcontext *ctx )
{
if (ctx->Visual->RGBAflag) {
if (ctx->Color.ColorLogicOpEnabled) {
	 if (ctx->Driver.LogicOp
&& (*ctx->Driver.LogicOp)( ctx, ctx->Color.LogicOp )) {
	
	    ctx->Color.SWLogicOpEnabled = GL_FALSE;
	 }
	 else {
	
	    ctx->Color.SWLogicOpEnabled = GL_TRUE;
	 }
}
else {
	
	 if (ctx->Driver.LogicOp) {
(void) (*ctx->Driver.LogicOp)( ctx, GL_COPY );
}
	 ctx->Color.SWLogicOpEnabled = GL_FALSE;
}
}
else {
if (ctx->Color.IndexLogicOpEnabled) {
	 if (ctx->Driver.LogicOp
&& (*ctx->Driver.LogicOp)( ctx, ctx->Color.LogicOp )) {
	
	    ctx->Color.SWLogicOpEnabled = GL_FALSE;
	 }
	 else {
	
	    ctx->Color.SWLogicOpEnabled = GL_TRUE;
	 }
}
else {
	
	 if (ctx->Driver.LogicOp) {
(void) (*ctx->Driver.LogicOp)( ctx, GL_COPY );
}
	 ctx->Color.SWLogicOpEnabled = GL_FALSE;
}
}
}
static void update_pixel_masking( GLcontext *ctx )
{
if (ctx->Visual->RGBAflag) {
if (ctx->Color.ColorMask==0xf) {
if (ctx->Driver.ColorMask) {
(void) (*ctx->Driver.ColorMask)( ctx, GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE );
}
ctx->Color.SWmasking = GL_FALSE;
}
else {
GLboolean red   = (ctx->Color.ColorMask & 8) ? GL_TRUE : GL_FALSE;
GLboolean green = (ctx->Color.ColorMask & 4) ? GL_TRUE : GL_FALSE;
GLboolean blue  = (ctx->Color.ColorMask & 2) ? GL_TRUE : GL_FALSE;
GLboolean alpha = (ctx->Color.ColorMask & 1) ? GL_TRUE : GL_FALSE;
if (ctx->Driver.ColorMask
&& (*ctx->Driver.ColorMask)( ctx, red, green, blue, alpha )) {
ctx->Color.SWmasking = GL_FALSE;
}
else {
ctx->Color.SWmasking = GL_TRUE;
}
}
}
else {
if (ctx->Color.IndexMask==0xffffffff) {
if (ctx->Driver.IndexMask) {
(void) (*ctx->Driver.IndexMask)( ctx, 0xffffffff );
}
ctx->Color.SWmasking = GL_FALSE;
}
else {
if (ctx->Driver.IndexMask
&& (*ctx->Driver.IndexMask)( ctx, ctx->Color.IndexMask )) {
ctx->Color.SWmasking = GL_FALSE;
}
else {
ctx->Color.SWmasking = GL_TRUE;
}
}
}
}
static void update_rasterflags( GLcontext *ctx )
{
ctx->RasterMask = 0;
if (ctx->Color.AlphaEnabled)		ctx->RasterMask |= ALPHATEST_BIT;
if (ctx->Color.BlendEnabled)		ctx->RasterMask |= BLEND_BIT;
if (ctx->Depth.Test)			ctx->RasterMask |= DEPTH_BIT;
if (ctx->Fog.Enabled)		ctx->RasterMask |= FOG_BIT;
if (ctx->Color.SWLogicOpEnabled)	ctx->RasterMask |= LOGIC_OP_BIT;
if (ctx->Scissor.Enabled)		ctx->RasterMask |= SCISSOR_BIT;
if (ctx->Stencil.Enabled)		ctx->RasterMask |= STENCIL_BIT;
if (ctx->Color.SWmasking)		ctx->RasterMask |= MASKING_BIT;
if (ctx->Visual->FrontAlphaEnabled)	ctx->RasterMask |= ALPHABUF_BIT;
if (ctx->Visual->BackAlphaEnabled)	ctx->RasterMask |= ALPHABUF_BIT;
if (   ctx->Viewport.X<0
|| ctx->Viewport.X + ctx->Viewport.Width > ctx->Buffer->Width
|| ctx->Viewport.Y<0
|| ctx->Viewport.Y + ctx->Viewport.Height > ctx->Buffer->Height) {
ctx->RasterMask |= WINCLIP_BIT;
}
if (ctx->Color.DrawBuffer==GL_FRONT_AND_BACK) {
ctx->RasterMask |= FRONT_AND_BACK_BIT;
}
if (ctx->Color.DrawBuffer==GL_NONE) {
ctx->RasterMask |= NO_DRAW_BIT;
}
else if (ctx->Visual->RGBAflag && ctx->Color.ColorMask==0) {
ctx->RasterMask |= NO_DRAW_BIT;
}
else if (!ctx->Visual->RGBAflag && ctx->Color.IndexMask==0) {
ctx->RasterMask |= NO_DRAW_BIT;
}
}
static void update_clipmask(GLcontext *ctx)
{
ctx->ClipMask = 0;
if (ctx->Texture.Enabled) {
ctx->ClipMask |= CLIP_TEXTURE_BIT;
}
if (ctx->Light.ShadeModel==GL_SMOOTH) {
if (ctx->Visual->RGBAflag) {
	 ctx->ClipMask |= CLIP_FCOLOR_BIT;
	 if (ctx->Light.Model.TwoSide) {
	    ctx->ClipMask |= CLIP_BCOLOR_BIT;
	 }
}
else {
	 ctx->ClipMask |= CLIP_FINDEX_BIT;
	 if (ctx->Light.Model.TwoSide) {
	    ctx->ClipMask |= CLIP_BINDEX_BIT;
	 }
}
}
}
void gl_clear_depth_buffer( GLcontext* ctx )
{
GLdepth clear_value = (GLdepth) (ctx->Depth.Clear * DEPTH_SCALE);
if (ctx->Visual->DepthBits==0 || !ctx->Buffer->Depth) {
return;
}
if (ctx->Scissor.Enabled) {
GLint y;
for (y=ctx->Buffer->Ymin; y<=ctx->Buffer->Ymax; y++) {
GLdepth *d = Z_ADDRESS( ctx, ctx->Buffer->Xmin, y );
GLint n = ctx->Buffer->Xmax - ctx->Buffer->Xmin + 1;
do {
*d++ = clear_value;
n--;
} while (n);
}
}
else {
if (sizeof(GLdepth)==2 && (clear_value&0xff)==(clear_value>>8)) {
MEMSET( ctx->Buffer->Depth, clear_value&0xff,
2*ctx->Buffer->Width*ctx->Buffer->Height);
}
else {
GLdepth *d = ctx->Buffer->Depth;
GLint n = ctx->Buffer->Width * ctx->Buffer->Height;
while (n>=16) {
d[0] = clear_value;    d[1] = clear_value;
d[2] = clear_value;    d[3] = clear_value;
d[4] = clear_value;    d[5] = clear_value;
d[6] = clear_value;    d[7] = clear_value;
d[8] = clear_value;    d[9] = clear_value;
d[10] = clear_value;   d[11] = clear_value;
d[12] = clear_value;   d[13] = clear_value;
d[14] = clear_value;   d[15] = clear_value;
d += 16;
n -= 16;
}
while (n>0) {
*d++ = clear_value;
n--;
}
}
}
}

void gl_alloc_depth_buffer( GLcontext* ctx )
{
if (ctx->Buffer->Depth) {
free(ctx->Buffer->Depth);
ctx->Buffer->Depth = NULL;
}
ctx->Buffer->Depth = (GLdepth *) malloc( ctx->Buffer->Width
* ctx->Buffer->Height
* sizeof(GLdepth) );
if (!ctx->Buffer->Depth) {
ctx->Depth.Test = GL_FALSE;
gl_error( ctx, GL_OUT_OF_MEMORY, "Couldn't allocate depth buffer" );
}
}
GLuint gl_depth_test_span_less( GLcontext* ctx,
GLuint n, GLint x, GLint y, const GLdepth z[],
GLubyte mask[] )
{
GLdepth *zptr = Z_ADDRESS( ctx, x, y );
GLuint i;
GLuint passed = 0;
for (i=0; i<n; i++) {
if (mask[i]) {
if (z[i] < zptr[i]) {
zptr[i] = z[i];
passed++;
}
else {
mask[i] = 0;
}
}
}
return passed;
}
GLuint gl_depth_test_span_greater( GLcontext* ctx,
GLuint n, GLint x, GLint y,
const GLdepth z[],
GLubyte mask[] )
{
GLdepth *zptr = Z_ADDRESS( ctx, x, y );
GLuint i;
GLuint passed = 0;
for (i=0; i<n; i++) {
if (mask[i]) {
if (z[i] > zptr[i]) {
zptr[i] = z[i];
passed++;
}
else {
mask[i] = 0;
}
}
}
return passed;
}
#define ZADDR_SETUP   GLdepth *depthbuffer = ctx->Buffer->Depth; \
GLint width = ctx->Buffer->Width;
#define ZADDR( X, Y )   (depthbuffer + (Y) * width + (X) )
void gl_depth_test_pixels_generic( GLcontext* ctx,
GLuint n, const GLint x[], const GLint y[],
const GLdepth z[], GLubyte mask[] )
{
register GLdepth *zptr;
register GLuint i;
switch (ctx->Depth.Func) {
case GL_LESS:
if (ctx->Depth.Mask) {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] < *zptr) {
		
		     *zptr = z[i];
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] < *zptr) {
		
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 break;
case GL_LEQUAL:
if (ctx->Depth.Mask) {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] <= *zptr) {
		
		     *zptr = z[i];
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] <= *zptr) {
		
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 break;
case GL_GEQUAL:
if (ctx->Depth.Mask) {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] >= *zptr) {
		
		     *zptr = z[i];
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] >= *zptr) {
		
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 break;
case GL_GREATER:
if (ctx->Depth.Mask) {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] > *zptr) {
		
		     *zptr = z[i];
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] > *zptr) {
		
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 break;
case GL_NOTEQUAL:
if (ctx->Depth.Mask) {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] != *zptr) {
		
		     *zptr = z[i];
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] != *zptr) {
		
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 break;
case GL_EQUAL:
if (ctx->Depth.Mask) {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] == *zptr) {
		
		     *zptr = z[i];
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  if (z[i] == *zptr) {
		
		  }
		  else {
		
		     mask[i] = 0;
		  }
	       }
	    }
	 }
	 break;
case GL_ALWAYS:
	 if (ctx->Depth.Mask) {
	
	    for (i=0; i<n; i++) {
	       if (mask[i]) {
		  zptr = Z_ADDRESS(ctx,x[i],y[i]);
		  *zptr = z[i];
	       }
	    }
	 }
	 else {
	
	 }
	 break;
case GL_NEVER:
	
	 for (i=0;i<n;i++) {
	    mask[i] = 0;
	 }
	 break;
default:
gl_problem(ctx, "Bad depth func in gl_depth_test_pixels_generic");
}
}
void gl_depth_test_pixels_less( GLcontext* ctx,
GLuint n, const GLint x[], const GLint y[],
const GLdepth z[], GLubyte mask[] )
{
GLdepth *zptr;
GLuint i;
for (i=0; i<n; i++) {
if (mask[i]) {
zptr = Z_ADDRESS(ctx,x[i],y[i]);
if (z[i] < *zptr) {
*zptr = z[i];
}
else {
mask[i] = 0;
}
}
}
}
void gl_depth_test_pixels_greater( GLcontext* ctx,
GLuint n, const GLint x[], const GLint y[],
const GLdepth z[], GLubyte mask[] )
{
GLdepth *zptr;
GLuint i;
for (i=0; i<n; i++) {
if (mask[i]) {
zptr = Z_ADDRESS(ctx,x[i],y[i]);
if (z[i] > *zptr) {
*zptr = z[i];
}
else {
mask[i] = 0;
}
}
}
}
void gl_read_depth_span_float( GLcontext* ctx,
GLuint n, GLint x, GLint y, float depth[] )
{
GLdepth *zptr;
float scale;
GLuint i;
scale = 1.0F / DEPTH_SCALE;
if (ctx->Buffer->Depth) {
zptr = Z_ADDRESS( ctx, x, y );
for (i=0;i<n;i++) {
	 depth[i] = (float) zptr[i] * scale;
}
}
else {
for (i=0;i<n;i++) {
	 depth[i] = 0.0F;
}
}
}
void gl_read_depth_span_int( GLcontext* ctx,
GLuint n, GLint x, GLint y, GLdepth depth[] )
{
if (ctx->Buffer->Depth) {
GLdepth *zptr = Z_ADDRESS( ctx, x, y );
MEMCPY( depth, zptr, n * sizeof(GLdepth) );
}
else {
GLuint i;
for (i=0;i<n;i++) {
	 depth[i] = 0.0;
}
}
}
GLuint gl_depth_test_span_generic( GLcontext* ctx,
GLuint n, GLint x, GLint y,
const GLdepth z[],
GLubyte mask[] )
{
GLdepth *zptr = Z_ADDRESS( ctx, x, y );
GLubyte *m = mask;
GLuint i;
GLuint passed = 0;
switch (ctx->Depth.Func) {
case GL_LESS:
if (ctx->Depth.Mask) {
	
	    for (i=0; i<n; i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] < *zptr) {
		
		     *zptr = z[i];
		     passed++;
		  }
		  else {
		
		     *m = 0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0; i<n; i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] < *zptr) {
		
		     passed++;
		  }
		  else {
		     *m = 0;
		  }
	       }
	    }
	 }
	 break;
case GL_LEQUAL:
	 if (ctx->Depth.Mask) {
	
	    for (i=0;i<n;i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] <= *zptr) {
		     *zptr = z[i];
		     passed++;
		  }
		  else {
		     *m = 0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0;i<n;i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] <= *zptr) {
		
		     passed++;
		  }
		  else {
		     *m = 0;
		  }
	       }
	    }
	 }
	 break;
case GL_GEQUAL:
	 if (ctx->Depth.Mask) {
	
	    for (i=0;i<n;i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] >= *zptr) {
		     *zptr = z[i];
		     passed++;
		  }
		  else {
		     *m = 0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0;i<n;i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] >= *zptr) {
		
		     passed++;
		  }
		  else {
		     *m = 0;
		  }
	       }
	    }
	 }
	 break;
case GL_GREATER:
	 if (ctx->Depth.Mask) {
	
	    for (i=0;i<n;i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] > *zptr) {
		     *zptr = z[i];
		     passed++;
		  }
		  else {
		     *m = 0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0;i<n;i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] > *zptr) {
		
		     passed++;
		  }
		  else {
		     *m = 0;
		  }
	       }
	    }
	 }
	 break;
case GL_NOTEQUAL:
	 if (ctx->Depth.Mask) {
	
	    for (i=0;i<n;i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] != *zptr) {
		     *zptr = z[i];
		     passed++;
		  }
		  else {
		     *m = 0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0;i<n;i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] != *zptr) {
		
		     passed++;
		  }
		  else {
		     *m = 0;
		  }
	       }
	    }
	 }
	 break;
case GL_EQUAL:
	 if (ctx->Depth.Mask) {
	
	    for (i=0;i<n;i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] == *zptr) {
		     *zptr = z[i];
		     passed++;
		  }
		  else {
		     *m =0;
		  }
	       }
	    }
	 }
	 else {
	
	    for (i=0;i<n;i++,zptr++,m++) {
	       if (*m) {
		  if (z[i] == *zptr) {
		
		     passed++;
		  }
		  else {
		     *m =0;
		  }
	       }
	    }
	 }
	 break;
case GL_ALWAYS:
	 if (ctx->Depth.Mask) {
	
	    for (i=0;i<n;i++,zptr++,m++) {
	       if (*m) {
		  *zptr = z[i];
		  passed++;
	       }
	    }
	 }
	 else {
	
	    passed = n;
	 }
	 break;
case GL_NEVER:
	 for (i=0;i<n;i++) {
	    mask[i] = 0;
	 }
	 break;
default:
gl_problem(ctx, "Bad depth func in gl_depth_test_span_generic");
}
return passed;
}
void gl_update_state( GLcontext *ctx )
{
if (ctx->NewState & NEW_RASTER_OPS) {
update_pixel_logic(ctx);
update_pixel_masking(ctx);
update_rasterflags(ctx);
if (ctx->Driver.Dither) {
(*ctx->Driver.Dither)( ctx, ctx->Color.DitherFlag );
}
}
if (ctx->NewState & (NEW_RASTER_OPS | NEW_LIGHTING)) {
update_clipmask(ctx);
}
if (ctx->NewState & NEW_LIGHTING) {
gl_update_lighting(ctx);
gl_set_color_function(ctx);
}
if (ctx->NewState & NEW_TEXTURING) {
gl_update_texture_state(ctx);
}
if (ctx->NewState & (NEW_LIGHTING | NEW_TEXTURING)) {
GLboolean sphereGen = ctx->Texture.Enabled
&& ((ctx->Texture.GenModeS==GL_SPHERE_MAP
&& (ctx->Texture.TexGenEnabled & S_BIT))
|| (ctx->Texture.GenModeT==GL_SPHERE_MAP
&& (ctx->Texture.TexGenEnabled & T_BIT)));
if (ctx->Light.Enabled || sphereGen) {
ctx->NeedNormals = GL_TRUE;
}
else {
ctx->NeedNormals = GL_FALSE;
}
}
if (ctx->NewState & NEW_RASTER_OPS) {
if (ctx->Fog.Enabled ||
ctx->Texture.Enabled ||
ctx->Color.BlendEnabled ||
ctx->Color.SWmasking ||
ctx->Color.SWLogicOpEnabled) {
ctx->MutablePixels = GL_TRUE;
}
else {
ctx->MutablePixels = GL_FALSE;
}
}
if (ctx->NewState & (NEW_RASTER_OPS | NEW_LIGHTING)) {
if (ctx->Light.ShadeModel==GL_SMOOTH ||
ctx->Light.Enabled ||
ctx->Fog.Enabled ||
ctx->Texture.Enabled ||
ctx->Color.BlendEnabled ||
ctx->Color.SWmasking ||
ctx->Color.SWLogicOpEnabled) {
ctx->MonoPixels = GL_FALSE;
}
else {
ctx->MonoPixels = GL_TRUE;
}
}
if (ctx->NewState & NEW_POLYGON) {
ctx->Polygon.CullBits = 0;
if (ctx->Polygon.CullFlag) {
if (ctx->Polygon.CullFaceMode==GL_FRONT ||
ctx->Polygon.CullFaceMode==GL_FRONT_AND_BACK) {
ctx->Polygon.CullBits |= 1;
}
if (ctx->Polygon.CullFaceMode==GL_BACK ||
ctx->Polygon.CullFaceMode==GL_FRONT_AND_BACK) {
ctx->Polygon.CullBits |= 2;
}
}
ctx->Polygon.OffsetAny = ctx->Polygon.OffsetPoint ||
ctx->Polygon.OffsetLine ||
ctx->Polygon.OffsetFill;
ctx->PointZoffset   = 0.0;
ctx->LineZoffset    = 0.0;
ctx->PolygonZoffset = 0.0;
}
if (ctx->NewState & (NEW_POLYGON | NEW_LIGHTING)) {
if (   ctx->Polygon.Unfilled
|| ctx->Polygon.OffsetAny
|| ctx->Polygon.CullFlag
|| ctx->Light.Model.TwoSide
|| ctx->RenderMode!=GL_RENDER) {
ctx->DirectTriangles = GL_FALSE;
}
else {
ctx->DirectTriangles = GL_TRUE;
}
}
ctx->Buffer->Xmin = 0;
ctx->Buffer->Ymin = 0;
ctx->Buffer->Xmax = ctx->Buffer->Width-1;
ctx->Buffer->Ymax = ctx->Buffer->Height-1;
if (ctx->Scissor.Enabled) {
if (ctx->Scissor.X > ctx->Buffer->Xmin) {
ctx->Buffer->Xmin = ctx->Scissor.X;
}
if (ctx->Scissor.Y > ctx->Buffer->Ymin) {
ctx->Buffer->Ymin = ctx->Scissor.Y;
}
if (ctx->Scissor.X + ctx->Scissor.Width - 1 < ctx->Buffer->Xmax) {
ctx->Buffer->Xmax = ctx->Scissor.X + ctx->Scissor.Width - 1;
}
if (ctx->Scissor.Y + ctx->Scissor.Height - 1 < ctx->Buffer->Ymax) {
ctx->Buffer->Ymax = ctx->Scissor.Y + ctx->Scissor.Height - 1;
}
}
if (ctx->NewState & NEW_RASTER_OPS) {
ctx->Driver.AllocDepthBuffer = gl_alloc_depth_buffer;
ctx->Driver.ClearDepthBuffer = gl_clear_depth_buffer;
if (ctx->Depth.Mask) {
switch (ctx->Depth.Func) {
case GL_LESS:
ctx->Driver.DepthTestSpan = gl_depth_test_span_less;
ctx->Driver.DepthTestPixels = gl_depth_test_pixels_less;
break;
case GL_GREATER:
ctx->Driver.DepthTestSpan = gl_depth_test_span_greater;
ctx->Driver.DepthTestPixels = gl_depth_test_pixels_greater;
break;
default:
ctx->Driver.DepthTestSpan = gl_depth_test_span_generic;
ctx->Driver.DepthTestPixels = gl_depth_test_pixels_generic;
}
}
else {
ctx->Driver.DepthTestSpan = gl_depth_test_span_generic;
ctx->Driver.DepthTestPixels = gl_depth_test_pixels_generic;
}
ctx->Driver.ReadDepthSpanFloat = gl_read_depth_span_float;
ctx->Driver.ReadDepthSpanInt = gl_read_depth_span_int;
}
ctx->Driver.PointsFunc = NULL;
ctx->Driver.LineFunc = NULL;
ctx->Driver.TriangleFunc = NULL;
ctx->Driver.QuadFunc = NULL;
ctx->Driver.RectFunc = NULL;
if (ctx->Driver.UpdateState) {
(*ctx->Driver.UpdateState)(ctx);
}
gl_set_point_function(ctx);
gl_set_line_function(ctx);
gl_set_triangle_function(ctx);
gl_set_quad_function(ctx);
gl_set_vertex_function(ctx);
ctx->NewState = 0;
}
/* 当前文件是D:\Read\copypix.c*/

#ifdef PC_HEADER
#else
#endif
static void copy_rgb_pixels( GLcontext* ctx,
GLint srcx, GLint srcy, GLint width, GLint height,
GLint destx, GLint desty )
{
DEFARRAY( GLdepth, zspan, MAX_WIDTH );
DEFARRAY( GLubyte, red, MAX_WIDTH );
DEFARRAY( GLubyte, green, MAX_WIDTH );
DEFARRAY( GLubyte, blue, MAX_WIDTH );
DEFARRAY( GLubyte, alpha, MAX_WIDTH );
GLboolean scale_or_bias, quick_draw, zoom;
GLint sy, dy, stepy;
GLint i, j;
GLboolean setbuffer;
if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==1.0F) {
zoom = GL_FALSE;
}
else {
zoom = GL_TRUE;
}
if (srcy<desty) {
sy = srcy + height - 1;
dy = desty + height - 1;
stepy = -1;
}
else {
sy = srcy;
dy = desty;
stepy = 1;
}
scale_or_bias = ctx->Pixel.RedScale!=1.0 || ctx->Pixel.RedBias!=0.0
|| ctx->Pixel.GreenScale!=1.0 || ctx->Pixel.GreenBias!=0.0
		|| ctx->Pixel.BlueScale!=1.0 || ctx->Pixel.BlueBias!=0.0
		|| ctx->Pixel.AlphaScale!=1.0 || ctx->Pixel.AlphaBias!=0.0;
if (ctx->Depth.Test) {
GLint z = (GLint) (ctx->Current.RasterPos[2] * DEPTH_SCALE);
for (i=0;i<width;i++) {
zspan[i] = z;
}
}
if (ctx->RasterMask==0 && !zoom
&& destx>=0 && destx+width<=ctx->Buffer->Width) {
quick_draw = GL_TRUE;
}
else {
quick_draw = GL_FALSE;
}
setbuffer = ctx->Pixel.ReadBuffer!=ctx->Color.DrawBuffer;
for (j=0; j<height; j++, sy+=stepy, dy+=stepy) {
if (setbuffer) {
(*ctx->Driver.SetBuffer)( ctx, ctx->Pixel.ReadBuffer );
}
gl_read_color_span( ctx, width, srcx, sy, red, green, blue, alpha );
if (scale_or_bias) {
float rbias = ctx->Pixel.RedBias   * ctx->Visual->RedScale;
float gbias = ctx->Pixel.GreenBias * ctx->Visual->GreenScale;
float bbias = ctx->Pixel.BlueBias  * ctx->Visual->BlueScale;
float abias = ctx->Pixel.AlphaBias * ctx->Visual->AlphaScale;
GLint rmax = (GLint) ctx->Visual->RedScale;
GLint gmax = (GLint) ctx->Visual->GreenScale;
GLint bmax = (GLint) ctx->Visual->BlueScale;
GLint amax = (GLint) ctx->Visual->AlphaScale;
for (i=0;i<width;i++) {
GLint r = red[i]   * ctx->Pixel.RedScale   + rbias;
GLint g = green[i] * ctx->Pixel.GreenScale + gbias;
GLint b = blue[i]  * ctx->Pixel.BlueScale  + bbias;
GLint a = alpha[i] * ctx->Pixel.AlphaScale + abias;
red[i]   = CLAMP( r, 0, rmax );
green[i] = CLAMP( g, 0, gmax );
blue[i]  = CLAMP( b, 0, bmax );
alpha[i] = CLAMP( a, 0, amax );
}
}
if (ctx->Pixel.MapColorFlag) {
float r = (ctx->Pixel.MapRtoRsize-1) * ctx->Visual->InvRedScale;
float g = (ctx->Pixel.MapGtoGsize-1) * ctx->Visual->InvGreenScale;
float b = (ctx->Pixel.MapBtoBsize-1) * ctx->Visual->InvBlueScale;
float a = (ctx->Pixel.MapAtoAsize-1) * ctx->Visual->InvAlphaScale;
for (i=0;i<width;i++) {
GLint ir = red[i] * r;
GLint ig = green[i] * g;
GLint ib = blue[i] * b;
GLint ia = alpha[i] * a;
red[i]   = (GLint) (ctx->Pixel.MapRtoR[ir]*ctx->Visual->RedScale);
green[i] = (GLint) (ctx->Pixel.MapGtoG[ig]*ctx->Visual->GreenScale);
blue[i]  = (GLint) (ctx->Pixel.MapBtoB[ib]*ctx->Visual->BlueScale);
alpha[i] = (GLint) (ctx->Pixel.MapAtoA[ia]*ctx->Visual->AlphaScale);
}
}
if (setbuffer) {
(*ctx->Driver.SetBuffer)( ctx, ctx->Color.DrawBuffer );
}
if (quick_draw && dy>=0 && dy<ctx->Buffer->Height) {
(*ctx->Driver.WriteColorSpan)( ctx, width, destx, dy,
red, green, blue, alpha, NULL);
}
else if (zoom) {
gl_write_zoomed_color_span( ctx, width, destx, dy, zspan,
red, green, blue, alpha, desty );
}
else {
gl_write_color_span( ctx, width, destx, dy, zspan,
red, green, blue, alpha, GL_BITMAP );
}
}
UNDEFARRAY( zspan );
UNDEFARRAY( red );
UNDEFARRAY( green );
UNDEFARRAY( blue );
UNDEFARRAY( alpha );
}
static void copy_ci_pixels( GLcontext* ctx,
GLint srcx, GLint srcy, GLint width, GLint height,
GLint destx, GLint desty )
{
GLdepth zspan[MAX_WIDTH];
GLuint indx[MAX_WIDTH];
GLint sy, dy, stepy;
GLint i, j;
GLboolean setbuffer, zoom;
if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==1.0F) {
zoom = GL_FALSE;
}
else {
zoom = GL_TRUE;
}
if (srcy<desty) {
sy = srcy + height - 1;
dy = desty + height - 1;
stepy = -1;
}
else {
sy = srcy;
dy = desty;
stepy = 1;
}
if (ctx->Depth.Test) {
GLint z = (GLint) (ctx->Current.RasterPos[2] * DEPTH_SCALE);
for (i=0;i<width;i++) {
zspan[i] = z;
}
}
setbuffer = ctx->Pixel.ReadBuffer!=ctx->Color.DrawBuffer;
for (j=0; j<height; j++, sy+=stepy, dy+=stepy) {
if (setbuffer) {
(*ctx->Driver.SetBuffer)( ctx, ctx->Pixel.ReadBuffer );
}
gl_read_index_span( ctx, width, srcx, sy, indx );
if (ctx->Pixel.IndexShift || ctx->Pixel.IndexOffset) {
if (ctx->Pixel.IndexShift<0) {
for (i=0;i<width;i++) {
indx[i] = (indx[i] >> -ctx->Pixel.IndexShift)
+ ctx->Pixel.IndexOffset;
}
}
else {
for (i=0;i<width;i++) {
indx[i] = (indx[i] << ctx->Pixel.IndexShift)
+ ctx->Pixel.IndexOffset;
}
}
}
if (ctx->Pixel.MapColorFlag) {
for (i=0;i<width;i++) {
if (indx[i] < ctx->Pixel.MapItoIsize) {
indx[i] = ctx->Pixel.MapItoI[ indx[i] ];
}
}
}
if (setbuffer) {
(*ctx->Driver.SetBuffer)( ctx, ctx->Color.DrawBuffer );
}
if (zoom) {
gl_write_zoomed_index_span( ctx, width, destx, dy, zspan, indx, desty );
}
else {
gl_write_index_span( ctx, width, destx, dy, zspan, indx, GL_BITMAP );
}
}
}
static void copy_depth_pixels( GLcontext* ctx, GLint srcx, GLint srcy,
GLint width, GLint height,
GLint destx, GLint desty )
{
float depth[MAX_WIDTH];
GLdepth zspan[MAX_WIDTH];
GLuint indx[MAX_WIDTH];
GLubyte red[MAX_WIDTH], green[MAX_WIDTH];
GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];
GLint sy, dy, stepy;
GLint i, j;
GLboolean zoom;
if (!ctx->Buffer->Depth) {
gl_error( ctx, GL_INVALID_OPERATION, "glCopyPixels" );
return;
}
if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==1.0F) {
zoom = GL_FALSE;
}
else {
zoom = GL_TRUE;
}
if (srcy<desty) {
sy = srcy + height - 1;
dy = desty + height - 1;
stepy = -1;
}
else {
sy = srcy;
dy = desty;
stepy = 1;
}
if (ctx->Visual->RGBAflag) {
GLubyte r, g, b, a;
r = ctx->Current.ByteColor[0];
g = ctx->Current.ByteColor[1];
b = ctx->Current.ByteColor[2];
a = ctx->Current.ByteColor[3];
MEMSET( red,   (int) r, width );
MEMSET( green, (int) g, width );
MEMSET( blue,  (int) b, width );
MEMSET( alpha, (int) a, width );
}
else {
for (i=0;i<width;i++) {
indx[i] = ctx->Current.Index;
}
}
for (j=0; j<height; j++, sy+=stepy, dy+=stepy) {
(*ctx->Driver.ReadDepthSpanFloat)( ctx, width, srcx, sy, depth );
for (i=0;i<width;i++) {
float d = depth[i] * ctx->Pixel.DepthScale + ctx->Pixel.DepthBias;
zspan[i] = (GLint) (CLAMP( d, 0.0, 1.0 ) * DEPTH_SCALE);
}
if (ctx->Visual->RGBAflag) {
if (zoom) {
gl_write_zoomed_color_span( ctx, width, destx, dy, zspan,
red, green, blue, alpha, desty );
}
else {
gl_write_color_span( ctx, width, destx, dy, zspan,
red, green, blue, alpha, GL_BITMAP );
}
}
else {
if (zoom) {
gl_write_zoomed_index_span( ctx, width, destx, dy,
zspan, indx, desty);
}
else {
gl_write_index_span( ctx, width, destx, dy,
zspan, indx, GL_BITMAP );
}
}
}
}
static void copy_stencil_pixels( GLcontext* ctx, GLint srcx, GLint srcy,
GLint width, GLint height,
GLint destx, GLint desty )
{
GLubyte stencil[MAX_WIDTH];
GLint sy, dy, stepy;
GLint i, j;
GLboolean zoom;
if (!ctx->Buffer->Stencil) {
gl_error( ctx, GL_INVALID_OPERATION, "glCopyPixels" );
return;
}
if (ctx->Pixel.ZoomX==1.0F && ctx->Pixel.ZoomY==1.0F) {
zoom = GL_FALSE;
}
else {
zoom = GL_TRUE;
}
if (srcy<desty) {
sy = srcy + height - 1;
dy = desty + height - 1;
stepy = -1;
}
else {
sy = srcy;
dy = desty;
stepy = 1;
}
for (j=0; j<height; j++, sy+=stepy, dy+=stepy) {
gl_read_stencil_span( ctx, width, srcx, sy, stencil );
if (ctx->Pixel.IndexShift<0) {
for (i=0;i<width;i++) {
stencil[i] = (stencil[i] >> -ctx->Pixel.IndexShift)
+ ctx->Pixel.IndexOffset;
}
}
else {
for (i=0;i<width;i++) {
stencil[i] = (stencil[i] << ctx->Pixel.IndexShift)
			 + ctx->Pixel.IndexOffset;
}
}
if (ctx->Pixel.MapStencilFlag) {
for (i=0;i<width;i++) {
if ((GLint) stencil[i] < ctx->Pixel.MapStoSsize) {
stencil[i] = ctx->Pixel.MapStoS[ stencil[i] ];
}
}
}
if (zoom) {
gl_write_zoomed_stencil_span( ctx, width, destx, dy, stencil, desty );
}
else {
gl_write_stencil_span( ctx, width, destx, dy, stencil );
}
}
}
void gl_CopyPixels( GLcontext* ctx, GLint srcx, GLint srcy, GLsizei width, GLsizei height,
		    GLenum type )
{
GLint destx, desty;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glCopyPixels" );
return;
}
if (width<0 || height<0) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyPixels" );
return;
}
if (ctx->NewState) {
gl_update_state(ctx);
}
if (ctx->RenderMode==GL_RENDER) {
if (!ctx->Current.RasterPosValid) {
	 return;
}
destx = (GLint) (ctx->Current.RasterPos[0] + 0.5F);
desty = (GLint) (ctx->Current.RasterPos[1] + 0.5F);
if (type==GL_COLOR && ctx->Visual->RGBAflag) {
copy_rgb_pixels( ctx, srcx, srcy, width, height, destx, desty );
}
else if (type==GL_COLOR && !ctx->Visual->RGBAflag) {
copy_ci_pixels( ctx, srcx, srcy, width, height, destx, desty );
}
else if (type==GL_DEPTH) {
copy_depth_pixels( ctx, srcx, srcy, width, height, destx, desty );
}
else if (type==GL_STENCIL) {
copy_stencil_pixels( ctx, srcx, srcy, width, height, destx, desty );
}
else {
	 gl_error( ctx, GL_INVALID_ENUM, "glCopyPixels" );
}
}
else if (ctx->RenderMode==GL_FEEDBACK) {
float color[4];
color[0] = ctx->Current.ByteColor[0] * ctx->Visual->InvRedScale;
color[1] = ctx->Current.ByteColor[1] * ctx->Visual->InvGreenScale;
color[2] = ctx->Current.ByteColor[2] * ctx->Visual->InvBlueScale;
color[3] = ctx->Current.ByteColor[3] * ctx->Visual->InvAlphaScale;
FEEDBACK_TOKEN( ctx, (float) GL_COPY_PIXEL_TOKEN );
gl_feedback_vertex( ctx, ctx->Current.RasterPos[0],
			  ctx->Current.RasterPos[1],
			  ctx->Current.RasterPos[2],
			  ctx->Current.RasterPos[3],
			  color, ctx->Current.Index,
			  ctx->Current.TexCoord );
}
else if (ctx->RenderMode==GL_SELECT) {
gl_update_hitflag( ctx, ctx->Current.RasterPos[2] );
}
}
/* 当前文件是D:\Read\depth.c*/

#ifdef PC_HEADER
#else
#endif
void gl_ClearDepth( GLcontext* ctx, GLclampd depth )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glClearDepth" );
return;
}
ctx->Depth.Clear = (float) CLAMP( depth, 0.0, 1.0 );
}
void gl_DepthFunc( GLcontext* ctx, GLenum func )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glDepthFunc" );
return;
}
switch (func) {
case GL_NEVER:
case GL_LESS:
case GL_GEQUAL:
case GL_LEQUAL:
case GL_GREATER:
case GL_NOTEQUAL:
case GL_EQUAL:
case GL_ALWAYS:
ctx->Depth.Func = func;
ctx->NewState |= NEW_RASTER_OPS;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glDepth.Func" );
}
}
void gl_DepthMask( GLcontext* ctx, GLboolean flag )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glDepthMask" );
return;
}
ctx->Depth.Mask = flag;
ctx->NewState |= NEW_RASTER_OPS;
}
void gl_DepthRange( GLcontext* ctx, GLclampd nearval, GLclampd farval )
{
float n, f;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glDepthRange" );
return;
}
n = (float) CLAMP( nearval, 0.0, 1.0 );
f = (float) CLAMP( farval, 0.0, 1.0 );
ctx->Viewport.Near = n;
ctx->Viewport.Far = f;
ctx->Viewport.Sz = DEPTH_SCALE * ((f - n) / 2.0);
ctx->Viewport.Tz = DEPTH_SCALE * ((f - n) / 2.0 + n);
}



/* 当前文件是D:\Read\dlist.c*/

#ifdef PC_HEADER
#else
#endif
#define BLOCK_SIZE 500
typedef enum {
	OPCODE_ACCUM,
	OPCODE_ALPHA_FUNC,
OPCODE_BEGIN,
OPCODE_BIND_TEXTURE,
	OPCODE_BITMAP,
	OPCODE_BLEND_COLOR,
	OPCODE_BLEND_EQUATION,
	OPCODE_BLEND_FUNC,
OPCODE_CALL_LIST,
OPCODE_CALL_LIST_OFFSET,
	OPCODE_CLEAR,
	OPCODE_CLEAR_ACCUM,
	OPCODE_CLEAR_COLOR,
	OPCODE_CLEAR_DEPTH,
	OPCODE_CLEAR_INDEX,
	OPCODE_CLEAR_STENCIL,
OPCODE_CLIP_PLANE,
	OPCODE_COLOR_3F,
	OPCODE_COLOR_4F,
	OPCODE_COLOR_4UB,
	OPCODE_COLOR_MASK,
	OPCODE_COLOR_MATERIAL,
	OPCODE_COLOR_TABLE,
	OPCODE_COLOR_SUB_TABLE,
	OPCODE_COPY_PIXELS,
OPCODE_COPY_TEX_IMAGE1D,
OPCODE_COPY_TEX_IMAGE2D,
OPCODE_COPY_TEX_IMAGE3D,
OPCODE_COPY_TEX_SUB_IMAGE1D,
OPCODE_COPY_TEX_SUB_IMAGE2D,
OPCODE_COPY_TEX_SUB_IMAGE3D,
	OPCODE_CULL_FACE,
	OPCODE_DEPTH_FUNC,
	OPCODE_DEPTH_MASK,
	OPCODE_DEPTH_RANGE,
	OPCODE_DISABLE,
	OPCODE_DRAW_BUFFER,
	OPCODE_DRAW_PIXELS,
OPCODE_EDGE_FLAG,
	OPCODE_ENABLE,
OPCODE_END,
	OPCODE_EVALCOORD1,
	OPCODE_EVALCOORD2,
	OPCODE_EVALMESH1,
	OPCODE_EVALMESH2,
	OPCODE_EVALPOINT1,
	OPCODE_EVALPOINT2,
	OPCODE_FOG,
	OPCODE_FRONT_FACE,
	OPCODE_FRUSTUM,
	OPCODE_HINT,
	OPCODE_INDEX,
	OPCODE_INDEX_MASK,
	OPCODE_INIT_NAMES,
	OPCODE_LIGHT,
	OPCODE_LIGHT_MODEL,
	OPCODE_LINE_STIPPLE,
	OPCODE_LINE_WIDTH,
	OPCODE_LIST_BASE,
	OPCODE_LOAD_IDENTITY,
	OPCODE_LOAD_MATRIX,
	OPCODE_LOAD_NAME,
	OPCODE_LOGIC_OP,
	OPCODE_MAP1,
	OPCODE_MAP2,
	OPCODE_MAPGRID1,
	OPCODE_MAPGRID2,
	OPCODE_MATERIAL,
	OPCODE_MATRIX_MODE,
	OPCODE_MULT_MATRIX,
OPCODE_NORMAL,
	OPCODE_ORTHO,
	OPCODE_PASSTHROUGH,
	OPCODE_PIXEL_MAP,
	OPCODE_PIXEL_TRANSFER,
	OPCODE_PIXEL_ZOOM,
	OPCODE_POINT_SIZE,
OPCODE_POINT_PARAMETERS,
	OPCODE_POLYGON_MODE,
OPCODE_POLYGON_STIPPLE,
	OPCODE_POLYGON_OFFSET,
	OPCODE_POP_ATTRIB,
	OPCODE_POP_MATRIX,
	OPCODE_POP_NAME,
	OPCODE_PRIORITIZE_TEXTURE,
	OPCODE_PUSH_ATTRIB,
	OPCODE_PUSH_MATRIX,
	OPCODE_PUSH_NAME,
	OPCODE_RASTER_POS,
	OPCODE_RECTF,
	OPCODE_READ_BUFFER,
OPCODE_SCALE,
	OPCODE_SCISSOR,
	OPCODE_SHADE_MODEL,
	OPCODE_STENCIL_FUNC,
	OPCODE_STENCIL_MASK,
	OPCODE_STENCIL_OP,
	OPCODE_TEXCOORD2,
	OPCODE_TEXCOORD4,
OPCODE_TEXENV,
OPCODE_TEXGEN,
OPCODE_TEXPARAMETER,
	OPCODE_TEX_IMAGE1D,
	OPCODE_TEX_IMAGE2D,
	OPCODE_TEX_IMAGE3D,
	OPCODE_TEX_SUB_IMAGE1D,
	OPCODE_TEX_SUB_IMAGE2D,
	OPCODE_TEX_SUB_IMAGE3D,
OPCODE_TRANSLATE,
OPCODE_VERTEX2,
OPCODE_VERTEX3,
OPCODE_VERTEX4,
	OPCODE_VIEWPORT,
	OPCODE_WINDOW_POS,
	
	OPCODE_CONTINUE,
	OPCODE_END_OF_LIST
} OpCode;
typedef union node {
	OpCode		opcode;
	GLboolean	b;
	GLbitfield	bf;
	GLubyte		ub;
	GLshort		s;
	GLushort	us;
	GLint		i;
	GLuint		ui;
	GLenum		e;
	float		f;
	GLvoid		*data;
	void		*next;	
} Node;
static GLuint InstSize[ OPCODE_END_OF_LIST+1 ];
static Node *CurrentListPtr;	
static GLuint CurrentListNum;	
static Node *CurrentBlock;	
static GLuint CurrentPos;	
static Node *alloc_instruction( GLcontext *ctx, OpCode opcode, GLint argcount )
{
Node *n, *newblock;
GLuint count = InstSize[opcode];
assert( count == argcount+1 );
if (CurrentPos + count + 2 > BLOCK_SIZE) {
n = CurrentBlock + CurrentPos;
n[0].opcode = OPCODE_CONTINUE;
newblock = (Node *) malloc( sizeof(Node) * BLOCK_SIZE );
if (!newblock) {
gl_error( ctx, GL_OUT_OF_MEMORY, "Building display list" );
return NULL;
}
n[1].next = (Node *) newblock;
CurrentBlock = newblock;
CurrentPos = 0;
}
n = CurrentBlock + CurrentPos;
CurrentPos += count;
n[0].opcode = opcode;
return n;
}
static Node *make_empty_list( void )
{
Node *n = (Node *) malloc( sizeof(Node) );
n[0].opcode = OPCODE_END_OF_LIST;
return n;
}
void gl_destroy_list( GLcontext *ctx, GLuint list )
{
Node *n, *block;
GLboolean done;
block = (Node *) HashLookup(ctx->Shared->DisplayList, list);
n = block;
done = block ? GL_FALSE : GL_TRUE;
while (!done) {
switch (n[0].opcode) {
	
	 case OPCODE_MAP1:
	    gl_free_control_points( ctx, n[1].e, (float *) n[6].data );
	    n += InstSize[n[0].opcode];
	    break;
	 case OPCODE_MAP2:
	    gl_free_control_points( ctx, n[1].e, (float *) n[10].data );
	    n += InstSize[n[0].opcode];
	    break;
	 case OPCODE_DRAW_PIXELS:
	    free( n[5].data );
	    n += InstSize[n[0].opcode];
	    break;
	 case OPCODE_BITMAP:
	    gl_free_image( (struct gl_image *) n[7].data );
	    n += InstSize[n[0].opcode];
	    break;
case OPCODE_COLOR_TABLE:
gl_free_image( (struct gl_image *) n[3].data );
n += InstSize[n[0].opcode];
break;
case OPCODE_COLOR_SUB_TABLE:
gl_free_image( (struct gl_image *) n[3].data );
n += InstSize[n[0].opcode];
break;
case OPCODE_POLYGON_STIPPLE:
free( n[1].data );
	    n += InstSize[n[0].opcode];
break;
	 case OPCODE_TEX_IMAGE1D:
gl_free_image( (struct gl_image *) n[8].data );
n += InstSize[n[0].opcode];
	    break;
	 case OPCODE_TEX_IMAGE2D:
gl_free_image( (struct gl_image *) n[9].data );
n += InstSize[n[0].opcode];
	    break;
case OPCODE_TEX_SUB_IMAGE1D:
{
struct gl_image *image;
image = (struct gl_image *) n[7].data;
gl_free_image( image );
}
break;
case OPCODE_TEX_SUB_IMAGE2D:
{
struct gl_image *image;
image = (struct gl_image *) n[9].data;
gl_free_image( image );
}
break;
	 case OPCODE_CONTINUE:
	    n = (Node *) n[1].next;
	    free( block );
	    block = n;
	    break;
	 case OPCODE_END_OF_LIST:
	    free( block );
	    done = GL_TRUE;
	    break;
	 default:
	
	    n += InstSize[n[0].opcode];
	    break;
}
}
HashRemove(ctx->Shared->DisplayList, list);
}
static GLuint translate_id( GLsizei n, GLenum type, const GLvoid *list )
{
GLbyte *bptr;
GLubyte *ubptr;
GLshort *sptr;
GLushort *usptr;
GLint *iptr;
GLuint *uiptr;
float *fptr;
switch (type) {
case GL_BYTE:
bptr = (GLbyte *) list;
return (GLuint) *(bptr+n);
case GL_UNSIGNED_BYTE:
ubptr = (GLubyte *) list;
return (GLuint) *(ubptr+n);
case GL_SHORT:
sptr = (GLshort *) list;
return (GLuint) *(sptr+n);
case GL_UNSIGNED_SHORT:
usptr = (GLushort *) list;
return (GLuint) *(usptr+n);
case GL_INT:
iptr = (GLint *) list;
return (GLuint) *(iptr+n);
case GL_UNSIGNED_INT:
uiptr = (GLuint *) list;
return (GLuint) *(uiptr+n);
case GL_FLOAT:
fptr = (float *) list;
return (GLuint) *(fptr+n);
case GL_2_BYTES:
ubptr = ((GLubyte *) list) + 2*n;
return (GLuint) *ubptr * 256 + (GLuint) *(ubptr+1);
case GL_3_BYTES:
ubptr = ((GLubyte *) list) + 3*n;
return (GLuint) *ubptr * 65536
+ (GLuint) *(ubptr+1) * 256
+ (GLuint) *(ubptr+2);
case GL_4_BYTES:
ubptr = ((GLubyte *) list) + 4*n;
return (GLuint) *ubptr * 16777216
+ (GLuint) *(ubptr+1) * 65536
+ (GLuint) *(ubptr+2) * 256
+ (GLuint) *(ubptr+3);
default:
return 0;
}
}
void gl_init_lists( void )
{
static int init_flag = 0;
if (init_flag==0) {
CurrentListPtr = CurrentBlock = NULL;
CurrentListNum = 0;
InstSize[OPCODE_ACCUM] = 3;
InstSize[OPCODE_ALPHA_FUNC] = 3;
InstSize[OPCODE_BEGIN] = 2;
InstSize[OPCODE_BIND_TEXTURE] = 3;
InstSize[OPCODE_BITMAP] = 8;
InstSize[OPCODE_BLEND_COLOR] = 5;
InstSize[OPCODE_BLEND_EQUATION] = 2;
InstSize[OPCODE_BLEND_FUNC] = 3;
InstSize[OPCODE_CALL_LIST] = 2;
InstSize[OPCODE_CALL_LIST_OFFSET] = 2;
InstSize[OPCODE_CLEAR] = 2;
InstSize[OPCODE_CLEAR_ACCUM] = 5;
InstSize[OPCODE_CLEAR_COLOR] = 5;
InstSize[OPCODE_CLEAR_DEPTH] = 2;
InstSize[OPCODE_CLEAR_INDEX] = 2;
InstSize[OPCODE_CLEAR_STENCIL] = 2;
InstSize[OPCODE_CLIP_PLANE] = 6;
InstSize[OPCODE_COLOR_3F] = 4;
InstSize[OPCODE_COLOR_4F] = 5;
InstSize[OPCODE_COLOR_4UB] = 5;
InstSize[OPCODE_COLOR_MASK] = 5;
InstSize[OPCODE_COLOR_MATERIAL] = 3;
InstSize[OPCODE_COLOR_TABLE] = 4;
InstSize[OPCODE_COLOR_SUB_TABLE] = 4;
InstSize[OPCODE_COPY_PIXELS] = 6;
InstSize[OPCODE_COPY_TEX_IMAGE1D] = 8;
InstSize[OPCODE_COPY_TEX_IMAGE2D] = 9;
InstSize[OPCODE_COPY_TEX_SUB_IMAGE1D] = 7;
InstSize[OPCODE_COPY_TEX_SUB_IMAGE2D] = 9;
InstSize[OPCODE_COPY_TEX_SUB_IMAGE3D] = 10;
InstSize[OPCODE_CULL_FACE] = 2;
InstSize[OPCODE_DEPTH_FUNC] = 2;
InstSize[OPCODE_DEPTH_MASK] = 2;
InstSize[OPCODE_DEPTH_RANGE] = 3;
InstSize[OPCODE_DISABLE] = 2;
InstSize[OPCODE_DRAW_BUFFER] = 2;
InstSize[OPCODE_DRAW_PIXELS] = 6;
InstSize[OPCODE_ENABLE] = 2;
InstSize[OPCODE_EDGE_FLAG] = 2;
InstSize[OPCODE_END] = 1;
InstSize[OPCODE_EVALCOORD1] = 2;
InstSize[OPCODE_EVALCOORD2] = 3;
InstSize[OPCODE_EVALMESH1] = 4;
InstSize[OPCODE_EVALMESH2] = 6;
InstSize[OPCODE_EVALPOINT1] = 2;
InstSize[OPCODE_EVALPOINT2] = 3;
InstSize[OPCODE_FOG] = 6;
InstSize[OPCODE_FRONT_FACE] = 2;
InstSize[OPCODE_FRUSTUM] = 7;
InstSize[OPCODE_HINT] = 3;
InstSize[OPCODE_INDEX] = 2;
InstSize[OPCODE_INDEX_MASK] = 2;
InstSize[OPCODE_INIT_NAMES] = 1;
InstSize[OPCODE_LIGHT] = 7;
InstSize[OPCODE_LIGHT_MODEL] = 6;
InstSize[OPCODE_LINE_STIPPLE] = 3;
InstSize[OPCODE_LINE_WIDTH] = 2;
InstSize[OPCODE_LIST_BASE] = 2;
InstSize[OPCODE_LOAD_IDENTITY] = 1;
InstSize[OPCODE_LOAD_MATRIX] = 17;
InstSize[OPCODE_LOAD_NAME] = 2;
InstSize[OPCODE_LOGIC_OP] = 2;
InstSize[OPCODE_MAP1] = 7;
InstSize[OPCODE_MAP2] = 11;
InstSize[OPCODE_MAPGRID1] = 4;
InstSize[OPCODE_MAPGRID2] = 7;
InstSize[OPCODE_MATERIAL] = 7;
InstSize[OPCODE_MATRIX_MODE] = 2;
InstSize[OPCODE_MULT_MATRIX] = 17;
InstSize[OPCODE_NORMAL] = 4;
InstSize[OPCODE_ORTHO] = 7;
InstSize[OPCODE_PASSTHROUGH] = 2;
InstSize[OPCODE_PIXEL_MAP] = 4;
InstSize[OPCODE_PIXEL_TRANSFER] = 3;
InstSize[OPCODE_PIXEL_ZOOM] = 3;
InstSize[OPCODE_POINT_SIZE] = 2;
InstSize[OPCODE_POINT_PARAMETERS] = 5;
InstSize[OPCODE_POLYGON_MODE] = 3;
InstSize[OPCODE_POLYGON_STIPPLE] = 2;
InstSize[OPCODE_POLYGON_OFFSET] = 3;
InstSize[OPCODE_POP_ATTRIB] = 1;
InstSize[OPCODE_POP_MATRIX] = 1;
InstSize[OPCODE_POP_NAME] = 1;
InstSize[OPCODE_PRIORITIZE_TEXTURE] = 3;
InstSize[OPCODE_PUSH_ATTRIB] = 2;
InstSize[OPCODE_PUSH_MATRIX] = 1;
InstSize[OPCODE_PUSH_NAME] = 2;
InstSize[OPCODE_RASTER_POS] = 5;
InstSize[OPCODE_RECTF] = 5;
InstSize[OPCODE_READ_BUFFER] = 2;
InstSize[OPCODE_SCALE] = 4;
InstSize[OPCODE_SCISSOR] = 5;
InstSize[OPCODE_STENCIL_FUNC] = 4;
InstSize[OPCODE_STENCIL_MASK] = 2;
InstSize[OPCODE_STENCIL_OP] = 4;
InstSize[OPCODE_SHADE_MODEL] = 2;
InstSize[OPCODE_TEXCOORD2] = 3;
InstSize[OPCODE_TEXCOORD4] = 5;
InstSize[OPCODE_TEXENV] = 7;
InstSize[OPCODE_TEXGEN] = 7;
InstSize[OPCODE_TEXPARAMETER] = 7;
InstSize[OPCODE_TEX_IMAGE1D] = 9;
InstSize[OPCODE_TEX_IMAGE2D] = 10;
InstSize[OPCODE_TEX_IMAGE3D] = 11;
InstSize[OPCODE_TEX_SUB_IMAGE1D] = 8;
InstSize[OPCODE_TEX_SUB_IMAGE2D] = 10;
InstSize[OPCODE_TEX_SUB_IMAGE3D] = 12;
InstSize[OPCODE_TRANSLATE] = 4;
InstSize[OPCODE_VERTEX2] = 3;
InstSize[OPCODE_VERTEX3] = 4;
InstSize[OPCODE_VERTEX4] = 5;
InstSize[OPCODE_VIEWPORT] = 5;
InstSize[OPCODE_WINDOW_POS] = 5;
InstSize[OPCODE_CONTINUE] = 2;
InstSize[OPCODE_END_OF_LIST] = 1;
}
init_flag = 1;
}
GLint gl_list_index( void )
{
return CurrentListNum;
}
void gl_save_Accum( GLcontext *ctx, GLenum op, float value )
{
Node *n = alloc_instruction( ctx, OPCODE_ACCUM, 2 );
if (n) {
n[1].e = op;
n[2].f = value;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Accum)( ctx, op, value );
}
}
void gl_save_AlphaFunc( GLcontext *ctx, GLenum func, GLclampf ref )
{
Node *n = alloc_instruction( ctx, OPCODE_ALPHA_FUNC, 2 );
if (n) {
n[1].e = func;
n[2].f = (float) ref;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.AlphaFunc)( ctx, func, ref );
}
}
void gl_save_Begin( GLcontext *ctx, GLenum mode )
{
Node *n = alloc_instruction( ctx, OPCODE_BEGIN, 1 );
if (n) {
n[1].e = mode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Begin)( ctx, mode );
}
}
void gl_save_BindTexture( GLcontext *ctx, GLenum target, GLuint texture )
{
Node *n = alloc_instruction( ctx, OPCODE_BIND_TEXTURE, 2 );
if (n) {
n[1].e = target;
n[2].ui = texture;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.BindTexture)( ctx, target, texture );
}
}
void gl_save_Bitmap( GLcontext *ctx,
GLsizei width, GLsizei height,
		     float xorig, float yorig,
		     float xmove, float ymove,
		     const struct gl_image *bitmap )
{
Node *n = alloc_instruction( ctx, OPCODE_BITMAP, 7 );
if (n) {
n[1].i = (GLint) width;
n[2].i = (GLint) height;
n[3].f = xorig;
n[4].f = yorig;
n[5].f = xmove;
n[6].f = ymove;
n[7].data = (void *) bitmap;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Bitmap)( ctx, width, height,
xorig, yorig, xmove, ymove, bitmap );
}
}
void gl_save_BlendEquation( GLcontext *ctx, GLenum mode )
{
Node *n = alloc_instruction( ctx, OPCODE_BLEND_EQUATION, 1 );
if (n) {
n[1].e = mode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.BlendEquation)( ctx, mode );
}
}
void gl_save_BlendFunc( GLcontext *ctx, GLenum sfactor, GLenum dfactor )
{
Node *n = alloc_instruction( ctx, OPCODE_BLEND_FUNC, 2 );
if (n) {
n[1].e = sfactor;
n[2].e = dfactor;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.BlendFunc)( ctx, sfactor, dfactor );
}
}
void gl_save_BlendColor( GLcontext *ctx, float red, float green,
float blue, float alpha )
{
Node *n = alloc_instruction( ctx, OPCODE_BLEND_COLOR, 4 );
if (n) {
n[1].f = red;
n[2].f = green;
n[3].f = blue;
n[4].f = alpha;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.BlendColor)( ctx, red, green, blue, alpha );
}
}
void gl_save_CallList( GLcontext *ctx, GLuint list )
{
Node *n = alloc_instruction( ctx, OPCODE_CALL_LIST, 1 );
if (n) {
n[1].ui = list;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.CallList)( ctx, list );
}
}
void gl_save_CallLists( GLcontext *ctx,
GLsizei n, GLenum type, const GLvoid *lists )
{
GLuint i;
for (i=0;i<n;i++) {
GLuint list = translate_id( i, type, lists );
Node *n = alloc_instruction( ctx, OPCODE_CALL_LIST_OFFSET, 1 );
if (n) {
n[1].ui = list;
}
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.CallLists)( ctx, n, type, lists );
}
}
void gl_save_Clear( GLcontext *ctx, GLbitfield mask )
{
Node *n = alloc_instruction( ctx, OPCODE_CLEAR, 1 );
if (n) {
n[1].bf = mask;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Clear)( ctx, mask );
}
}
void gl_save_ClearAccum( GLcontext *ctx, float red, float green,
			 float blue, float alpha )
{
Node *n = alloc_instruction( ctx, OPCODE_CLEAR_ACCUM, 4 );
if (n) {
n[1].f = red;
n[2].f = green;
n[3].f = blue;
n[4].f = alpha;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ClearAccum)( ctx, red, green, blue, alpha );
}
}
void gl_save_ClearColor( GLcontext *ctx, GLclampf red, GLclampf green,
			 GLclampf blue, GLclampf alpha )
{
Node *n = alloc_instruction( ctx, OPCODE_CLEAR_COLOR, 4 );
if (n) {
n[1].f = red;
n[2].f = green;
n[3].f = blue;
n[4].f = alpha;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ClearColor)( ctx, red, green, blue, alpha );
}
}
void gl_save_ClearDepth( GLcontext *ctx, GLclampd depth )
{
Node *n = alloc_instruction( ctx, OPCODE_CLEAR_DEPTH, 1 );
if (n) {
n[1].f = (float) depth;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ClearDepth)( ctx, depth );
}
}
void gl_save_ClearIndex( GLcontext *ctx, float c )
{
Node *n = alloc_instruction( ctx, OPCODE_CLEAR_INDEX, 1 );
if (n) {
n[1].f = c;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ClearIndex)( ctx, c );
}
}
void gl_save_ClearStencil( GLcontext *ctx, GLint s )
{
Node *n = alloc_instruction( ctx, OPCODE_CLEAR_STENCIL, 1 );
if (n) {
n[1].i = s;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ClearStencil)( ctx, s );
}
}
void gl_save_ClipPlane( GLcontext *ctx, GLenum plane, const float *equ )
{
Node *n = alloc_instruction( ctx, OPCODE_CLIP_PLANE, 5 );
if (n) {
n[1].e = plane;
n[2].f = equ[0];
n[3].f = equ[1];
n[4].f = equ[2];
n[5].f = equ[3];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ClipPlane)( ctx, plane, equ );
}
}
void gl_save_Color3f( GLcontext *ctx, float r, float g, float b )
{
Node *n = alloc_instruction( ctx, OPCODE_COLOR_3F, 3 );
if (n) {
n[1].f = r;
n[2].f = g;
n[3].f = b;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Color3f)( ctx, r, g, b );
}
}
void gl_save_Color3fv( GLcontext *ctx, const float *c )
{
Node *n = alloc_instruction( ctx, OPCODE_COLOR_3F, 3 );
if (n) {
n[1].f = c[0];
n[2].f = c[1];
n[3].f = c[2];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Color3fv)( ctx, c );
}
}
void gl_save_Color4f( GLcontext *ctx, float r, float g,
float b, float a )
{
Node *n = alloc_instruction( ctx, OPCODE_COLOR_4F, 4 );
if (n) {
n[1].f = r;
n[2].f = g;
n[3].f = b;
n[4].f = a;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Color4f)( ctx, r, g, b, a );
}
}
void gl_save_Color4fv( GLcontext *ctx, const float *c )
{
Node *n = alloc_instruction( ctx, OPCODE_COLOR_4F, 4 );
if (n) {
n[1].f = c[0];
n[2].f = c[1];
n[3].f = c[2];
n[4].f = c[3];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Color4fv)( ctx, c );
}
}
void gl_save_Color4ub( GLcontext *ctx, GLubyte r, GLubyte g,
GLubyte b, GLubyte a )
{
Node *n = alloc_instruction( ctx, OPCODE_COLOR_4UB, 4 );
if (n) {
n[1].ub = r;
n[2].ub = g;
n[3].ub = b;
n[4].ub = a;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Color4ub)( ctx, r, g, b, a );
}
}
void gl_save_Color4ubv( GLcontext *ctx, const GLubyte *c )
{
Node *n = alloc_instruction( ctx, OPCODE_COLOR_4UB, 4 );
if (n) {
n[1].ub = c[0];
n[2].ub = c[1];
n[3].ub = c[2];
n[4].ub = c[3];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Color4ubv)( ctx, c );
}
}
void gl_save_ColorMask( GLcontext *ctx, GLboolean red, GLboolean green,
GLboolean blue, GLboolean alpha )
{
Node *n = alloc_instruction( ctx, OPCODE_COLOR_MASK, 4 );
if (n) {
n[1].b = red;
n[2].b = green;
n[3].b = blue;
n[4].b = alpha;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ColorMask)( ctx, red, green, blue, alpha );
}
}
void gl_save_ColorMaterial( GLcontext *ctx, GLenum face, GLenum mode )
{
Node *n = alloc_instruction( ctx, OPCODE_COLOR_MATERIAL, 2 );
if (n) {
n[1].e = face;
n[2].e = mode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ColorMaterial)( ctx, face, mode );
}
}
void gl_save_ColorTable( GLcontext *ctx, GLenum target, GLenum internalFormat,
struct gl_image *table )
{
Node *n = alloc_instruction( ctx, OPCODE_COLOR_TABLE, 3 );
if (n) {
n[1].e = target;
n[2].e = internalFormat;
n[3].data = (GLvoid *) table;
if (table) {
table->RefCount = 1;
}
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ColorTable)( ctx, target, internalFormat, table );
}
}
void gl_save_ColorSubTable( GLcontext *ctx, GLenum target,
GLsizei start, struct gl_image *data )
{
Node *n = alloc_instruction( ctx, OPCODE_COLOR_SUB_TABLE, 3 );
if (n) {
n[1].e = target;
n[2].i = start;
n[3].data = (GLvoid *) data;
if (data) {
data->RefCount = 1;
}
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ColorSubTable)( ctx, target, start, data );
}
}
void gl_save_CopyPixels( GLcontext *ctx, GLint x, GLint y,
			 GLsizei width, GLsizei height, GLenum type )
{
Node *n = alloc_instruction( ctx, OPCODE_COPY_PIXELS, 5 );
if (n) {
n[1].i = x;
n[2].i = y;
n[3].i = (GLint) width;
n[4].i = (GLint) height;
n[5].e = type;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.CopyPixels)( ctx, x, y, width, height, type );
}
}
void gl_save_CopyTexImage1D( GLcontext *ctx,
GLenum target, GLint level,
GLenum internalformat,
GLint x, GLint y, GLsizei width,
GLint border )
{
Node *n = alloc_instruction( ctx, OPCODE_COPY_TEX_IMAGE1D, 7 );
if (n) {
n[1].e = target;
n[2].i = level;
n[3].e = internalformat;
n[4].i = x;
n[5].i = y;
n[6].i = width;
n[7].i = border;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.CopyTexImage1D)( ctx, target, level, internalformat,
x, y, width, border );
}
}
void gl_save_CopyTexImage2D( GLcontext *ctx,
GLenum target, GLint level,
GLenum internalformat,
GLint x, GLint y, GLsizei width,
GLsizei height, GLint border )
{
Node *n = alloc_instruction( ctx, OPCODE_COPY_TEX_IMAGE2D, 8 );
if (n) {
n[1].e = target;
n[2].i = level;
n[3].e = internalformat;
n[4].i = x;
n[5].i = y;
n[6].i = width;
n[7].i = height;
n[8].i = border;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.CopyTexImage2D)( ctx, target, level, internalformat,
x, y, width, height, border );
}
}
void gl_save_CopyTexSubImage1D( GLcontext *ctx,
GLenum target, GLint level,
GLint xoffset, GLint x, GLint y,
GLsizei width )
{
Node *n = alloc_instruction( ctx, OPCODE_COPY_TEX_SUB_IMAGE1D, 6 );
if (n) {
n[1].e = target;
n[2].i = level;
n[3].i = xoffset;
n[4].i = x;
n[5].i = y;
n[6].i = width;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.CopyTexSubImage1D)( ctx, target, level, xoffset, x, y, width );
}
}
void gl_save_CopyTexSubImage2D( GLcontext *ctx,
GLenum target, GLint level,
GLint xoffset, GLint yoffset,
GLint x, GLint y,
GLsizei width, GLint height )
{
Node *n = alloc_instruction( ctx, OPCODE_COPY_TEX_SUB_IMAGE2D, 8 );
if (n) {
n[1].e = target;
n[2].i = level;
n[3].i = xoffset;
n[4].i = yoffset;
n[5].i = x;
n[6].i = y;
n[7].i = width;
n[8].i = height;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.CopyTexSubImage2D)( ctx, target, level, xoffset, yoffset,
x, y, width, height );
}
}
void gl_save_CopyTexSubImage3DEXT( GLcontext *ctx,
GLenum target, GLint level,
GLint xoffset, GLint yoffset, GLint zoffset,
GLint x, GLint y,
GLsizei width, GLint height )
{
Node *n = alloc_instruction( ctx, OPCODE_COPY_TEX_SUB_IMAGE3D, 9 );
if (n) {
n[1].e = target;
n[2].i = level;
n[3].i = xoffset;
n[4].i = yoffset;
n[5].i = zoffset;
n[6].i = x;
n[7].i = y;
n[8].i = width;
n[9].i = height;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.CopyTexSubImage3DEXT)( ctx, target, level, xoffset, yoffset, zoffset,
x, y, width, height );
}
}
void gl_save_CullFace( GLcontext *ctx, GLenum mode )
{
Node *n = alloc_instruction( ctx, OPCODE_CULL_FACE, 1 );
if (n) {
n[1].e = mode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.CullFace)( ctx, mode );
}
}
void gl_save_DepthFunc( GLcontext *ctx, GLenum func )
{
Node *n = alloc_instruction( ctx, OPCODE_DEPTH_FUNC, 1 );
if (n) {
n[1].e = func;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.DepthFunc)( ctx, func );
}
}
void gl_save_DepthMask( GLcontext *ctx, GLboolean mask )
{
Node *n = alloc_instruction( ctx, OPCODE_DEPTH_MASK, 1 );
if (n) {
n[1].b = mask;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.DepthMask)( ctx, mask );
}
}
void gl_save_DepthRange( GLcontext *ctx, GLclampd nearval, GLclampd farval )
{
Node *n = alloc_instruction( ctx, OPCODE_DEPTH_RANGE, 2 );
if (n) {
n[1].f = (float) nearval;
n[2].f = (float) farval;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.DepthRange)( ctx, nearval, farval );
}
}
void gl_save_Disable( GLcontext *ctx, GLenum cap )
{
Node *n = alloc_instruction( ctx, OPCODE_DISABLE, 1 );
if (n) {
n[1].e = cap;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Disable)( ctx, cap );
}
}
void gl_save_DrawBuffer( GLcontext *ctx, GLenum mode )
{
Node *n = alloc_instruction( ctx, OPCODE_DRAW_BUFFER, 1 );
if (n) {
n[1].e = mode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.DrawBuffer)( ctx, mode );
}
}
void gl_save_DrawPixels( GLcontext *ctx, GLsizei width, GLsizei height,
GLenum format, GLenum type, const GLvoid *pixels )
{
Node *n = alloc_instruction( ctx, OPCODE_DRAW_PIXELS, 5 );
if (n) {
n[1].i = (GLint) width;
n[2].i = (GLint) height;
n[3].e = format;
n[4].e = type;
n[5].data = (GLvoid *) pixels;
}
}
void gl_save_EdgeFlag( GLcontext *ctx, GLboolean flag )
{
Node *n = alloc_instruction( ctx, OPCODE_EDGE_FLAG, 1 );
if (n) {
n[1].b = flag;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.EdgeFlag)( ctx, flag );
}
}
void gl_save_Enable( GLcontext *ctx, GLenum cap )
{
Node *n = alloc_instruction( ctx, OPCODE_ENABLE, 1 );
if (n) {
n[1].e = cap;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Enable)( ctx, cap );
}
}
void gl_save_End( GLcontext *ctx )
{
(void) alloc_instruction( ctx, OPCODE_END, 0 );
if (ctx->ExecuteFlag) {
(*ctx->Exec.End)( ctx );
}
}
void gl_save_EvalCoord1f( GLcontext *ctx, float u )
{
Node *n = alloc_instruction( ctx, OPCODE_EVALCOORD1, 1 );
if (n) {
n[1].f = u;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.EvalCoord1f)( ctx, u );
}
}
void gl_save_EvalCoord2f( GLcontext *ctx, float u, float v )
{
Node *n = alloc_instruction( ctx, OPCODE_EVALCOORD2, 2 );
if (n) {
n[1].f = u;
n[2].f = v;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.EvalCoord2f)( ctx, u, v );
}
}
void gl_save_EvalMesh1( GLcontext *ctx,
GLenum mode, GLint i1, GLint i2 )
{
Node *n = alloc_instruction( ctx, OPCODE_EVALMESH1, 3 );
if (n) {
n[1].e = mode;
n[2].i = i1;
n[3].i = i2;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.EvalMesh1)( ctx, mode, i1, i2 );
}
}
void gl_save_EvalMesh2( GLcontext *ctx,
GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 )
{
Node *n = alloc_instruction( ctx, OPCODE_EVALMESH2, 5 );
if (n) {
n[1].e = mode;
n[2].i = i1;
n[3].i = i2;
n[4].i = j1;
n[5].i = j2;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.EvalMesh2)( ctx, mode, i1, i2, j1, j2 );
}
}
void gl_save_EvalPoint1( GLcontext *ctx, GLint i )
{
Node *n = alloc_instruction( ctx, OPCODE_EVALPOINT1, 1 );
if (n) {
n[1].i = i;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.EvalPoint1)( ctx, i );
}
}
void gl_save_EvalPoint2( GLcontext *ctx, GLint i, GLint j )
{
Node *n = alloc_instruction( ctx, OPCODE_EVALPOINT2, 2 );
if (n) {
n[1].i = i;
n[2].i = j;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.EvalPoint2)( ctx, i, j );
}
}
void gl_save_Fogfv( GLcontext *ctx, GLenum pname, const float *params )
{
Node *n = alloc_instruction( ctx, OPCODE_FOG, 5 );
if (n) {
n[1].e = pname;
n[2].f = params[0];
n[3].f = params[1];
n[4].f = params[2];
n[5].f = params[3];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Fogfv)( ctx, pname, params );
}
}
void gl_save_FrontFace( GLcontext *ctx, GLenum mode )
{
Node *n = alloc_instruction( ctx, OPCODE_FRONT_FACE, 1 );
if (n) {
n[1].e = mode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.FrontFace)( ctx, mode );
}
}
void gl_save_Frustum( GLcontext *ctx, GLdouble left, GLdouble right,
GLdouble bottom, GLdouble top,
GLdouble nearval, GLdouble farval )
{
Node *n = alloc_instruction( ctx, OPCODE_FRUSTUM, 6 );
if (n) {
n[1].f = left;
n[2].f = right;
n[3].f = bottom;
n[4].f = top;
n[5].f = nearval;
n[6].f = farval;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Frustum)( ctx, left, right, bottom, top, nearval, farval );
}
}
void gl_save_Hint( GLcontext *ctx, GLenum target, GLenum mode )
{
Node *n = alloc_instruction( ctx, OPCODE_HINT, 2 );
if (n) {
n[1].e = target;
n[2].e = mode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Hint)( ctx, target, mode );
}
}
void gl_save_Indexi( GLcontext *ctx, GLint index )
{
Node *n = alloc_instruction( ctx, OPCODE_INDEX, 1 );
if (n) {
n[1].i = index;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Indexi)( ctx, index );
}
}
void gl_save_Indexf( GLcontext *ctx, float index )
{
Node *n = alloc_instruction( ctx, OPCODE_INDEX, 1 );
if (n) {
n[1].i = (GLint) index;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Indexf)( ctx,index );
}
}
void gl_save_IndexMask( GLcontext *ctx, GLuint mask )
{
Node *n = alloc_instruction( ctx, OPCODE_INDEX_MASK, 1 );
if (n) {
n[1].ui = mask;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.IndexMask)( ctx, mask );
}
}
void gl_save_InitNames( GLcontext *ctx )
{
(void) alloc_instruction( ctx, OPCODE_INIT_NAMES, 0 );
if (ctx->ExecuteFlag) {
(*ctx->Exec.InitNames)( ctx );
}
}
void gl_save_Lightfv( GLcontext *ctx, GLenum light, GLenum pname,
const float *params, GLint numparams )
{
Node *n = alloc_instruction( ctx, OPCODE_LIGHT, 6 );
if (OPCODE_LIGHT) {
GLint i;
n[1].e = light;
n[2].e = pname;
for (i=0;i<numparams;i++) {
	 n[3+i].f = params[i];
}
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Lightfv)( ctx, light, pname, params, numparams );
}
}
void gl_save_LightModelfv( GLcontext *ctx,
GLenum pname, const float *params )
{
Node *n = alloc_instruction( ctx, OPCODE_LIGHT_MODEL, 5 );
if (n) {
n[1].e = pname;
n[2].f = params[0];
n[3].f = params[1];
n[4].f = params[2];
n[5].f = params[3];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.LightModelfv)( ctx, pname, params );
}
}
void gl_save_LineStipple( GLcontext *ctx, GLint factor, GLushort pattern )
{
Node *n = alloc_instruction( ctx, OPCODE_LINE_STIPPLE, 2 );
if (n) {
n[1].i = factor;
n[2].us = pattern;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.LineStipple)( ctx, factor, pattern );
}
}
void gl_save_LineWidth( GLcontext *ctx, float width )
{
Node *n = alloc_instruction( ctx, OPCODE_LINE_WIDTH, 1 );
if (n) {
n[1].f = width;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.LineWidth)( ctx, width );
}
}
void gl_save_ListBase( GLcontext *ctx, GLuint base )
{
Node *n = alloc_instruction( ctx, OPCODE_LIST_BASE, 1 );
if (n) {
n[1].ui = base;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ListBase)( ctx, base );
}
}
void gl_save_LoadIdentity( GLcontext *ctx )
{
(void) alloc_instruction( ctx, OPCODE_LOAD_IDENTITY, 0 );
if (ctx->ExecuteFlag) {
(*ctx->Exec.LoadIdentity)( ctx );
}
}
void gl_save_LoadMatrixf( GLcontext *ctx, const float *m )
{
Node *n = alloc_instruction( ctx, OPCODE_LOAD_MATRIX, 16 );
if (n) {
GLuint i;
for (i=0;i<16;i++) {
	 n[1+i].f = m[i];
}
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.LoadMatrixf)( ctx, m );
}
}
void gl_save_LoadName( GLcontext *ctx, GLuint name )
{
Node *n = alloc_instruction( ctx, OPCODE_LOAD_NAME, 1 );
if (n) {
n[1].ui = name;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.LoadName)( ctx, name );
}
}
void gl_save_LogicOp( GLcontext *ctx, GLenum opcode )
{
Node *n = alloc_instruction( ctx, OPCODE_LOGIC_OP, 1 );
if (n) {
n[1].e = opcode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.LogicOp)( ctx, opcode );
}
}
void gl_save_Map1f( GLcontext *ctx,
GLenum target, float u1, float u2, GLint stride,
		   GLint order, const float *points, GLboolean retain )
{
Node *n = alloc_instruction( ctx, OPCODE_MAP1, 6 );
if (n) {
n[1].e = target;
n[2].f = u1;
n[3].f = u2;
n[4].i = stride;
n[5].i = order;
n[6].data = (void *) points;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Map1f)( ctx, target, u1, u2, stride, order, points, GL_TRUE );
}
}
void gl_save_Map2f( GLcontext *ctx, GLenum target,
float u1, float u2, GLint ustride, GLint uorder,
float v1, float v2, GLint vstride, GLint vorder,
const float *points, GLboolean retain )
{
Node *n = alloc_instruction( ctx, OPCODE_MAP2, 10 );
if (n) {
n[1].e = target;
n[2].f = u1;
n[3].f = u2;
n[4].f = v1;
n[5].f = v2;
n[6].i = ustride;
n[7].i = vstride;
n[8].i = uorder;
n[9].i = vorder;
n[10].data = (void *) points;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Map2f)( ctx, target,
u1, u2, ustride, uorder,
v1, v2, vstride, vorder, points, GL_TRUE );
}
}
void gl_save_MapGrid1f( GLcontext *ctx, GLint un, float u1, float u2 )
{
Node *n = alloc_instruction( ctx, OPCODE_MAPGRID1, 3 );
if (n) {
n[1].i = un;
n[2].f = u1;
n[3].f = u2;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.MapGrid1f)( ctx, un, u1, u2 );
}
}
void gl_save_MapGrid2f( GLcontext *ctx,
GLint un, float u1, float u2,
		        GLint vn, float v1, float v2 )
{
Node *n = alloc_instruction( ctx, OPCODE_MAPGRID2, 6 );
if (n) {
n[1].i = un;
n[2].f = u1;
n[3].f = u2;
n[4].i = vn;
n[5].f = v1;
n[6].f = v2;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.MapGrid2f)( ctx, un, u1, u2, vn, v1, v2 );
}
}
void gl_save_Materialfv( GLcontext *ctx,
GLenum face, GLenum pname, const float *params )
{
Node *n = alloc_instruction( ctx, OPCODE_MATERIAL, 6 );
if (n) {
n[1].e = face;
n[2].e = pname;
n[3].f = params[0];
n[4].f = params[1];
n[5].f = params[2];
n[6].f = params[3];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Materialfv)( ctx, face, pname, params );
}
}
void gl_save_MatrixMode( GLcontext *ctx, GLenum mode )
{
Node *n = alloc_instruction( ctx, OPCODE_MATRIX_MODE, 1 );
if (n) {
n[1].e = mode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.MatrixMode)( ctx, mode );
}
}
void gl_save_MultMatrixf( GLcontext *ctx, const float *m )
{
Node *n = alloc_instruction( ctx, OPCODE_MULT_MATRIX, 16 );
if (n) {
GLuint i;
for (i=0;i<16;i++) {
	 n[1+i].f = m[i];
}
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.MultMatrixf)( ctx, m );
}
}
void gl_save_NewList( GLcontext *ctx, GLuint list, GLenum mode )
{
gl_error( ctx, GL_INVALID_OPERATION, "glNewList" );
}
void gl_save_Normal3fv( GLcontext *ctx, const float norm[3] )
{
Node *n = alloc_instruction( ctx, OPCODE_NORMAL, 3 );
if (n) {
n[1].f = norm[0];
n[2].f = norm[1];
n[3].f = norm[2];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Normal3fv)( ctx, norm );
}
}
void gl_save_Normal3f( GLcontext *ctx, float nx, float ny, float nz )
{
Node *n = alloc_instruction( ctx, OPCODE_NORMAL, 3 );
if (n) {
n[1].f = nx;
n[2].f = ny;
n[3].f = nz;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Normal3f)( ctx, nx, ny, nz );
}
}
void gl_save_Ortho( GLcontext *ctx, GLdouble left, GLdouble right,
GLdouble bottom, GLdouble top,
GLdouble nearval, GLdouble farval )
{
Node *n = alloc_instruction( ctx, OPCODE_ORTHO, 6 );
if (n) {
n[1].f = left;
n[2].f = right;
n[3].f = bottom;
n[4].f = top;
n[5].f = nearval;
n[6].f = farval;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Ortho)( ctx, left, right, bottom, top, nearval, farval );
}
}
void gl_save_PixelMapfv( GLcontext *ctx,
GLenum map, GLint mapsize, const float *values )
{
Node *n = alloc_instruction( ctx, OPCODE_PIXEL_MAP, 3 );
if (n) {
n[1].e = map;
n[2].i = mapsize;
n[3].data  = (void *) malloc( mapsize * sizeof(float) );
MEMCPY( n[3].data, (void *) values, mapsize * sizeof(float) );
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PixelMapfv)( ctx, map, mapsize, values );
}
}
void gl_save_PixelTransferf( GLcontext *ctx, GLenum pname, float param )
{
Node *n = alloc_instruction( ctx, OPCODE_PIXEL_TRANSFER, 2 );
if (n) {
n[1].e = pname;
n[2].f = param;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PixelTransferf)( ctx, pname, param );
}
}
void gl_save_PixelZoom( GLcontext *ctx, float xfactor, float yfactor )
{
Node *n = alloc_instruction( ctx, OPCODE_PIXEL_ZOOM, 2 );
if (n) {
n[1].f = xfactor;
n[2].f = yfactor;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PixelZoom)( ctx, xfactor, yfactor );
}
}
void gl_save_PointParameterfvEXT( GLcontext *ctx, GLenum pname,
const float *params)
{
Node *n = alloc_instruction( ctx, OPCODE_POINT_PARAMETERS, 4 );
if (n) {
n[1].e = pname;
n[2].f = params[0];
n[3].f = params[1];
n[4].f = params[2];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PointParameterfvEXT)( ctx, pname, params );
}
}
void gl_save_PointSize( GLcontext *ctx, float size )
{
Node *n = alloc_instruction( ctx, OPCODE_POINT_SIZE, 1 );
if (n) {
n[1].f = size;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PointSize)( ctx, size );
}
}
void gl_save_PolygonMode( GLcontext *ctx, GLenum face, GLenum mode )
{
Node *n = alloc_instruction( ctx, OPCODE_POLYGON_MODE, 2 );
if (n) {
n[1].e = face;
n[2].e = mode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PolygonMode)( ctx, face, mode );
}
}
void gl_save_PolygonStipple( GLcontext *ctx, const GLubyte *mask )
{
Node *n = alloc_instruction( ctx, OPCODE_POLYGON_STIPPLE, 1 );
if (n) {
void *data;
n[1].data = malloc( 32 * 4 );
data = n[1].data;
MEMCPY( data, mask, 32 * 4 );
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PolygonStipple)( ctx, mask );
}
}
void gl_save_PolygonOffset( GLcontext *ctx, float factor, float units )
{
Node *n = alloc_instruction( ctx, OPCODE_POLYGON_OFFSET, 2 );
if (n) {
n[1].f = factor;
n[2].f = units;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PolygonOffset)( ctx, factor, units );
}
}
void gl_save_PopAttrib( GLcontext *ctx )
{
(void) alloc_instruction( ctx, OPCODE_POP_ATTRIB, 0 );
if (ctx->ExecuteFlag) {
(*ctx->Exec.PopAttrib)( ctx );
}
}
void gl_save_PopMatrix( GLcontext *ctx )
{
(void) alloc_instruction( ctx, OPCODE_POP_MATRIX, 0 );
if (ctx->ExecuteFlag) {
(*ctx->Exec.PopMatrix)( ctx );
}
}
void gl_save_PopName( GLcontext *ctx )
{
(void) alloc_instruction( ctx, OPCODE_POP_NAME, 0 );
if (ctx->ExecuteFlag) {
(*ctx->Exec.PopName)( ctx );
}
}
void gl_save_PrioritizeTextures( GLcontext *ctx,
GLsizei num, const GLuint *textures,
const GLclampf *priorities )
{
GLint i;
for (i=0;i<num;i++) {
Node *n = alloc_instruction( ctx,  OPCODE_PRIORITIZE_TEXTURE, 2 );
if (n) {
n[1].ui = textures[i];
n[2].f = priorities[i];
}
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PrioritizeTextures)( ctx, num, textures, priorities );
}
}
void gl_save_PushAttrib( GLcontext *ctx, GLbitfield mask )
{
Node *n = alloc_instruction( ctx, OPCODE_PUSH_ATTRIB, 1 );
if (n) {
n[1].bf = mask;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PushAttrib)( ctx, mask );
}
}
void gl_save_PushMatrix( GLcontext *ctx )
{
(void) alloc_instruction( ctx, OPCODE_PUSH_MATRIX, 0 );
if (ctx->ExecuteFlag) {
(*ctx->Exec.PushMatrix)( ctx );
}
}
void gl_save_PushName( GLcontext *ctx, GLuint name )
{
Node *n = alloc_instruction( ctx, OPCODE_PUSH_NAME, 1 );
if (n) {
n[1].ui = name;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PushName)( ctx, name );
}
}
void gl_save_RasterPos4f( GLcontext *ctx,
float x, float y, float z, float w )
{
Node *n = alloc_instruction( ctx, OPCODE_RASTER_POS, 4 );
if (n) {
n[1].f = x;
n[2].f = y;
n[3].f = z;
n[4].f = w;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.RasterPos4f)( ctx, x, y, z, w );
}
}
void gl_save_PassThrough( GLcontext *ctx, float token )
{
Node *n = alloc_instruction( ctx, OPCODE_PASSTHROUGH, 1 );
if (n) {
n[1].f = token;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.PassThrough)( ctx, token );
}
}
void gl_save_ReadBuffer( GLcontext *ctx, GLenum mode )
{
Node *n = alloc_instruction( ctx, OPCODE_READ_BUFFER, 1 );
if (n) {
n[1].e = mode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ReadBuffer)( ctx, mode );
}
}
void gl_save_Rectf( GLcontext *ctx,
float x1, float y1, float x2, float y2 )
{
Node *n = alloc_instruction( ctx, OPCODE_RECTF, 4 );
if (n) {
n[1].f = x1;
n[2].f = y1;
n[3].f = x2;
n[4].f = y2;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Rectf)( ctx, x1, y1, x2, y2 );
}
}
void gl_save_Rotatef( GLcontext *ctx, float angle,
float x, float y, float z )
{
float m[16];
gl_rotation_matrix( angle, x, y, z, m );
gl_save_MultMatrixf( ctx, m );
}
void gl_save_Scalef( GLcontext *ctx, float x, float y, float z )
{
Node *n = alloc_instruction( ctx, OPCODE_SCALE, 3 );
if (n) {
n[1].f = x;
n[2].f = y;
n[3].f = z;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Scalef)( ctx, x, y, z );
}
}
void gl_save_Scissor( GLcontext *ctx,
GLint x, GLint y, GLsizei width, GLsizei height )
{
Node *n = alloc_instruction( ctx, OPCODE_SCISSOR, 4 );
if (n) {
n[1].i = x;
n[2].i = y;
n[3].i = width;
n[4].i = height;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Scissor)( ctx, x, y, width, height );
}
}
void gl_save_ShadeModel( GLcontext *ctx, GLenum mode )
{
Node *n = alloc_instruction( ctx, OPCODE_SHADE_MODEL, 1 );
if (n) {
n[1].e = mode;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.ShadeModel)( ctx, mode );
}
}
void gl_save_StencilFunc( GLcontext *ctx, GLenum func, GLint ref, GLuint mask )
{
Node *n = alloc_instruction( ctx, OPCODE_STENCIL_FUNC, 3 );
if (n) {
n[1].e = func;
n[2].i = ref;
n[3].ui = mask;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.StencilFunc)( ctx, func, ref, mask );
}
}
void gl_save_StencilMask( GLcontext *ctx, GLuint mask )
{
Node *n = alloc_instruction( ctx, OPCODE_STENCIL_MASK, 1 );
if (n) {
n[1].ui = mask;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.StencilMask)( ctx, mask );
}
}
void gl_save_StencilOp( GLcontext *ctx,
GLenum fail, GLenum zfail, GLenum zpass )
{
Node *n = alloc_instruction( ctx, OPCODE_STENCIL_OP, 3 );
if (n) {
n[1].e = fail;
n[2].e = zfail;
n[3].e = zpass;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.StencilOp)( ctx, fail, zfail, zpass );
}
}
void gl_save_TexCoord2f( GLcontext *ctx, float s, float t )
{
Node *n = alloc_instruction( ctx, OPCODE_TEXCOORD2, 2 );
if (n) {
n[1].f = s;
n[2].f = t;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.TexCoord2f)( ctx, s, t );
}
}
void gl_save_TexCoord4f( GLcontext *ctx, float s, float t,
float r, float q )
{
Node *n = alloc_instruction( ctx, OPCODE_TEXCOORD4, 4 );
if (n) {
n[1].f = s;
n[2].f = t;
n[3].f = r;
n[4].f = q;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.TexCoord4f)( ctx, s, t, r, q );
}
}
void gl_save_TexEnvfv( GLcontext *ctx,
GLenum target, GLenum pname, const float *params )
{
Node *n = alloc_instruction( ctx, OPCODE_TEXENV, 6 );
if (n) {
n[1].e = target;
n[2].e = pname;
n[3].f = params[0];
n[4].f = params[1];
n[5].f = params[2];
n[6].f = params[3];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.TexEnvfv)( ctx, target, pname, params );
}
}
void gl_save_TexGenfv( GLcontext *ctx,
GLenum coord, GLenum pname, const float *params )
{
Node *n = alloc_instruction( ctx, OPCODE_TEXGEN, 6 );
if (n) {
n[1].e = coord;
n[2].e = pname;
n[3].f = params[0];
n[4].f = params[1];
n[5].f = params[2];
n[6].f = params[3];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.TexGenfv)( ctx, coord, pname, params );
}
}
void gl_save_TexParameterfv( GLcontext *ctx, GLenum target,
GLenum pname, const float *params )
{
Node *n = alloc_instruction( ctx, OPCODE_TEXPARAMETER, 6 );
if (n) {
n[1].e = target;
n[2].e = pname;
n[3].f = params[0];
n[4].f = params[1];
n[5].f = params[2];
n[6].f = params[3];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.TexParameterfv)( ctx, target, pname, params );
}
}
void gl_save_TexImage1D( GLcontext *ctx, GLenum target,
GLint level, GLint components,
			 GLsizei width, GLint border,
GLenum format, GLenum type,
			 struct gl_image *teximage )
{
Node *n = alloc_instruction( ctx, OPCODE_TEX_IMAGE1D, 8 );
if (n) {
n[1].e = target;
n[2].i = level;
n[3].i = components;
n[4].i = (GLint) width;
n[5].i = border;
n[6].e = format;
n[7].e = type;
n[8].data = teximage;
if (teximage) {
teximage->RefCount = 1;
}
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.TexImage1D)( ctx, target, level, components, width,
border, format, type, teximage );
}
}
void gl_save_TexImage2D( GLcontext *ctx, GLenum target,
GLint level, GLint components,
			 GLsizei width, GLsizei height, GLint border,
GLenum format, GLenum type,
			 struct gl_image *teximage )
{
Node *n = alloc_instruction( ctx, OPCODE_TEX_IMAGE2D, 9 );
if (n) {
n[1].e = target;
n[2].i = level;
n[3].i = components;
n[4].i = (GLint) width;
n[5].i = (GLint) height;
n[6].i = border;
n[7].e = format;
n[8].e = type;
n[9].data = teximage;
if (teximage) {
teximage->RefCount = 1;
}
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.TexImage2D)( ctx, target, level, components, width,
height, border, format, type, teximage );
}
}
void gl_save_TexImage3DEXT( GLcontext *ctx, GLenum target,
GLint level, GLint components,
GLsizei width, GLsizei height, GLsizei depth,
GLint border,
GLenum format, GLenum type,
struct gl_image *teximage )
{
Node *n = alloc_instruction( ctx, OPCODE_TEX_IMAGE3D, 10 );
if (n) {
n[1].e = target;
n[2].i = level;
n[3].i = components;
n[4].i = (GLint) width;
n[5].i = (GLint) height;
n[6].i = (GLint) depth;
n[7].i = border;
n[8].e = format;
n[9].e = type;
n[10].data = teximage;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.TexImage3DEXT)( ctx, target, level, components, width,
height, depth, border, format, type, teximage );
}
}
void gl_save_TexSubImage1D( GLcontext *ctx,
GLenum target, GLint level, GLint xoffset,
GLsizei width, GLenum format, GLenum type,
struct gl_image *image )
{
Node *n = alloc_instruction( ctx, OPCODE_TEX_SUB_IMAGE1D, 7 );
if (n) {
n[1].e = target;
n[2].i = level;
n[3].i = xoffset;
n[4].i = (GLint) width;
n[5].e = format;
n[6].e = type;
n[7].data = image;
if (image)
image->RefCount = 1;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.TexSubImage1D)( ctx, target, level, xoffset, width,
format, type, image );
}
}
void gl_save_TexSubImage2D( GLcontext *ctx,
GLenum target, GLint level,
GLint xoffset, GLint yoffset,
GLsizei width, GLsizei height,
GLenum format, GLenum type,
struct gl_image *image )
{
Node *n = alloc_instruction( ctx, OPCODE_TEX_SUB_IMAGE2D, 9 );
if (n) {
n[1].e = target;
n[2].i = level;
n[3].i = xoffset;
n[4].i = yoffset;
n[5].i = (GLint) width;
n[6].i = (GLint) height;
n[7].e = format;
n[8].e = type;
n[9].data = image;
if (image)
image->RefCount = 1;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.TexSubImage2D)( ctx, target, level, xoffset, yoffset,
width, height, format, type, image );
}
}
void gl_save_TexSubImage3DEXT( GLcontext *ctx,
GLenum target, GLint level,
GLint xoffset, GLint yoffset,GLint zoffset,
GLsizei width, GLsizei height, GLsizei depth,
GLenum format, GLenum type,
struct gl_image *image )
{
Node *n = alloc_instruction( ctx, OPCODE_TEX_SUB_IMAGE3D, 11 );
if (n) {
n[1].e = target;
n[2].i = level;
n[3].i = xoffset;
n[4].i = yoffset;
n[5].i = zoffset;
n[6].i = (GLint) width;
n[7].i = (GLint) height;
n[8].i = (GLint) depth;
n[9].e = format;
n[10].e = type;
n[11].data = image;
if (image)
image->RefCount = 1;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.TexSubImage3DEXT)( ctx, target, level, xoffset, yoffset, zoffset,
width, height, depth, format, type, image );
}
}
void gl_save_Translatef( GLcontext *ctx, float x, float y, float z )
{
Node *n = alloc_instruction( ctx,  OPCODE_TRANSLATE, 3 );
if (n) {
n[1].f = x;
n[2].f = y;
n[3].f = z;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Translatef)( ctx, x, y, z );
}
}
void gl_save_Vertex2f( GLcontext *ctx, float x, float y )
{
Node *n = alloc_instruction( ctx,  OPCODE_VERTEX2, 2 );
if (n) {
n[1].f = x;
n[2].f = y;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Vertex2f)( ctx, x, y );
}
}
void gl_save_Vertex3f( GLcontext *ctx, float x, float y, float z )
{
Node *n = alloc_instruction( ctx,  OPCODE_VERTEX3, 3 );
if (n) {
n[1].f = x;
n[2].f = y;
n[3].f = z;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Vertex3f)( ctx, x, y, z );
}
}
void gl_save_Vertex4f( GLcontext *ctx,
float x, float y, float z, float w )
{
Node *n = alloc_instruction( ctx,  OPCODE_VERTEX4, 4 );
if (n) {
n[1].f = x;
n[2].f = y;
n[3].f = z;
n[4].f = w;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Vertex4f)( ctx, x, y, z, w );
}
}
void gl_save_Vertex3fv( GLcontext *ctx, const float v[3] )
{
Node *n = alloc_instruction( ctx,  OPCODE_VERTEX3, 3 );
if (n) {
n[1].f = v[0];
n[2].f = v[1];
n[3].f = v[2];
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Vertex3fv)( ctx, v );
}
}
void gl_save_Viewport( GLcontext *ctx,
GLint x, GLint y, GLsizei width, GLsizei height )
{
Node *n = alloc_instruction( ctx,  OPCODE_VIEWPORT, 4 );
if (n) {
n[1].i = x;
n[2].i = y;
n[3].i = (GLint) width;
n[4].i = (GLint) height;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.Viewport)( ctx, x, y, width, height );
}
}
void gl_save_WindowPos4fMESA( GLcontext *ctx,
float x, float y, float z, float w )
{
Node *n = alloc_instruction( ctx,  OPCODE_WINDOW_POS, 4 );
if (n) {
n[1].f = x;
n[2].f = y;
n[3].f = z;
n[4].f = w;
}
if (ctx->ExecuteFlag) {
(*ctx->Exec.WindowPos4fMESA)( ctx, x, y, z, w );
}
}
static void execute_list( GLcontext *ctx, GLuint list )
{
Node *n;
GLboolean done;
OpCode opcode;
if (!gl_IsList(ctx,list))
return;
ctx->CallDepth++;
n = (Node *) HashLookup(ctx->Shared->DisplayList, list);
done = GL_FALSE;
while (!done) {
opcode = n[0].opcode;
switch (opcode) {
	
case OPCODE_VERTEX2:
(*ctx->Exec.Vertex2f)( ctx, n[1].f, n[2].f );
break;
case OPCODE_VERTEX3:
(*ctx->Exec.Vertex3f)( ctx, n[1].f, n[2].f, n[3].f );
break;
case OPCODE_VERTEX4:
(*ctx->Exec.Vertex4f)( ctx, n[1].f, n[2].f, n[3].f, n[4].f );
break;
case OPCODE_NORMAL:
ctx->Current.Normal[0] = n[1].f;
ctx->Current.Normal[1] = n[2].f;
ctx->Current.Normal[2] = n[3].f;
ctx->VB->MonoNormal = GL_FALSE;
break;
	 case OPCODE_COLOR_4UB:
(*ctx->Exec.Color4ub)( ctx, n[1].ub, n[2].ub, n[3].ub, n[4].ub );
	    break;
	 case OPCODE_COLOR_3F:
(*ctx->Exec.Color3f)( ctx, n[1].f, n[2].f, n[3].f );
break;
	 case OPCODE_COLOR_4F:
(*ctx->Exec.Color4f)( ctx, n[1].f, n[2].f, n[3].f, n[4].f );
break;
case OPCODE_INDEX:
ctx->Current.Index = n[1].ui;
ctx->VB->MonoColor = GL_FALSE;
break;
case OPCODE_BEGIN:
gl_Begin( ctx, n[1].e );
break;
case OPCODE_END:
gl_End( ctx );
break;
	 case OPCODE_TEXCOORD2:
	    ctx->Current.TexCoord[0] = n[1].f;
	    ctx->Current.TexCoord[1] = n[2].f;
if (ctx->VB->TexCoordSize==4) {
ctx->Current.TexCoord[2] = 0.0F;
ctx->Current.TexCoord[3] = 1.0F;
}
	    break;
	 case OPCODE_TEXCOORD4:
	    ctx->Current.TexCoord[0] = n[1].f;
	    ctx->Current.TexCoord[1] = n[2].f;
	    ctx->Current.TexCoord[2] = n[3].f;
	    ctx->Current.TexCoord[3] = n[4].f;
if (ctx->VB->TexCoordSize==2) {
ctx->VB->TexCoordSize = 4;
gl_set_vertex_function(ctx);
}
	    break;
	
case OPCODE_ACCUM:
	    gl_Accum( ctx, n[1].e, n[2].f );
	    break;
case OPCODE_ALPHA_FUNC:
	    gl_AlphaFunc( ctx, n[1].e, n[2].f );
	    break;
case OPCODE_BIND_TEXTURE:
gl_BindTexture( ctx, n[1].e, n[2].ui );
break;
	 case OPCODE_BITMAP:
	    gl_Bitmap( ctx, (GLsizei) n[1].i, (GLsizei) n[2].i,
		       n[3].f, n[4].f,
		       n[5].f, n[6].f,
		       (struct gl_image *) n[7].data );
	    break;
	 case OPCODE_BLEND_COLOR:
	    gl_BlendColor( ctx, n[1].f, n[2].f, n[3].f, n[4].f );
	    break;
	 case OPCODE_BLEND_EQUATION:
	    gl_BlendEquation( ctx, n[1].e );
	    break;
	 case OPCODE_BLEND_FUNC:
	    gl_BlendFunc( ctx, n[1].e, n[2].e );
	    break;
case OPCODE_CALL_LIST:
	
if (ctx->CallDepth<MAX_LIST_NESTING) {
execute_list( ctx, n[1].ui );
}
break;
case OPCODE_CALL_LIST_OFFSET:
	
if (ctx->CallDepth<MAX_LIST_NESTING) {
execute_list( ctx, ctx->List.ListBase + n[1].ui );
}
break;
	 case OPCODE_CLEAR:
	    gl_Clear( ctx, n[1].bf );
	    break;
	 case OPCODE_CLEAR_COLOR:
	    gl_ClearColor( ctx, n[1].f, n[2].f, n[3].f, n[4].f );
	    break;
	 case OPCODE_CLEAR_ACCUM:
	    gl_ClearAccum( ctx, n[1].f, n[2].f, n[3].f, n[4].f );
	    break;
	 case OPCODE_CLEAR_DEPTH:
	    gl_ClearDepth( ctx, (GLclampd) n[1].f );
	    break;
	 case OPCODE_CLEAR_INDEX:
	    gl_ClearIndex( ctx, n[1].ui );
	    break;
	 case OPCODE_CLEAR_STENCIL:
	    gl_ClearStencil( ctx, n[1].i );
	    break;
case OPCODE_CLIP_PLANE:
{
float equ[4];
equ[0] = n[2].f;
equ[1] = n[3].f;
equ[2] = n[4].f;
equ[3] = n[5].f;
gl_ClipPlane( ctx, n[1].e, equ );
}
break;
	 case OPCODE_COLOR_MASK:
	    gl_ColorMask( ctx, n[1].b, n[2].b, n[3].b, n[4].b );
	    break;
	 case OPCODE_COLOR_MATERIAL:
	    gl_ColorMaterial( ctx, n[1].e, n[2].e );
	    break;
case OPCODE_COLOR_TABLE:
gl_ColorTable( ctx, n[1].e, n[2].e, (struct gl_image *) n[3].data);
break;
case OPCODE_COLOR_SUB_TABLE:
gl_ColorSubTable( ctx, n[1].e, n[2].i,
(struct gl_image *) n[3].data);
break;
	 case OPCODE_COPY_PIXELS:
	    gl_CopyPixels( ctx, n[1].i, n[2].i,
			   (GLsizei) n[3].i, (GLsizei) n[4].i, n[5].e );
	    break;
case OPCODE_COPY_TEX_IMAGE1D:
	    gl_CopyTexImage1D( ctx, n[1].e, n[2].i, n[3].e, n[4].i,
n[5].i, n[6].i, n[7].i );
break;
case OPCODE_COPY_TEX_IMAGE2D:
	    gl_CopyTexImage2D( ctx, n[1].e, n[2].i, n[3].e, n[4].i,
n[5].i, n[6].i, n[7].i, n[8].i );
break;
case OPCODE_COPY_TEX_SUB_IMAGE1D:
	    gl_CopyTexSubImage1D( ctx, n[1].e, n[2].i, n[3].i, n[4].i,
n[5].i, n[6].i );
break;
case OPCODE_COPY_TEX_SUB_IMAGE2D:
	    gl_CopyTexSubImage2D( ctx, n[1].e, n[2].i, n[3].i, n[4].i,
n[5].i, n[6].i, n[7].i, n[8].i );
break;
case OPCODE_COPY_TEX_SUB_IMAGE3D:
gl_CopyTexSubImage3DEXT( ctx, n[1].e, n[2].i, n[3].i, n[4].i,
n[5].i, n[6].i, n[7].i, n[8].i , n[9].i);
break;
	 case OPCODE_CULL_FACE:
	    gl_CullFace( ctx, n[1].e );
	    break;
	 case OPCODE_DEPTH_FUNC:
	    gl_DepthFunc( ctx, n[1].e );
	    break;
	 case OPCODE_DEPTH_MASK:
	    gl_DepthMask( ctx, n[1].b );
	    break;
	 case OPCODE_DEPTH_RANGE:
	    gl_DepthRange( ctx, (GLclampd) n[1].f, (GLclampd) n[2].f );
	    break;
	 case OPCODE_DISABLE:
	    gl_Disable( ctx, n[1].e );
	    break;
	 case OPCODE_DRAW_BUFFER:
	    gl_DrawBuffer( ctx, n[1].e );
	    break;
	 case OPCODE_DRAW_PIXELS:
	    gl_DrawPixels( ctx, (GLsizei) n[1].i, (GLsizei) n[2].i,
			   n[3].e, n[4].e, n[5].data );
	    break;
	 case OPCODE_EDGE_FLAG:
ctx->Current.EdgeFlag = n[1].b;
break;
	 case OPCODE_ENABLE:
	    gl_Enable( ctx, n[1].e );
	    break;
	 case OPCODE_EVALCOORD1:
	    gl_EvalCoord1f( ctx, n[1].f );
	    break;
	 case OPCODE_EVALCOORD2:
	    gl_EvalCoord2f( ctx, n[1].f, n[2].f );
	    break;
	 case OPCODE_EVALMESH1:
	    gl_EvalMesh1( ctx, n[1].e, n[2].i, n[3].i );
	    break;
	 case OPCODE_EVALMESH2:
	    gl_EvalMesh2( ctx, n[1].e, n[2].i, n[3].i, n[4].i, n[5].i );
	    break;
	 case OPCODE_EVALPOINT1:
	    gl_EvalPoint1( ctx, n[1].i );
	    break;
	 case OPCODE_EVALPOINT2:
	    gl_EvalPoint2( ctx, n[1].i, n[2].i );
	    break;
	 case OPCODE_FOG:
	    {
	       float p[4];
	       p[0] = n[2].f;
	       p[1] = n[3].f;
	       p[2] = n[4].f;
	       p[3] = n[5].f;
	       gl_Fogfv( ctx, n[1].e, p );
	    }
	    break;
	 case OPCODE_FRONT_FACE:
	    gl_FrontFace( ctx, n[1].e );
	    break;
case OPCODE_FRUSTUM:
gl_Frustum( ctx, n[1].f, n[2].f, n[3].f, n[4].f, n[5].f, n[6].f );
break;
	 case OPCODE_HINT:
	    gl_Hint( ctx, n[1].e, n[2].e );
	    break;
	 case OPCODE_INDEX_MASK:
	    gl_IndexMask( ctx, n[1].ui );
	    break;
	 case OPCODE_INIT_NAMES:
	    gl_InitNames( ctx );
	    break;
case OPCODE_LIGHT:
	    {
	       float p[4];
	       p[0] = n[3].f;
	       p[1] = n[4].f;
	       p[2] = n[5].f;
	       p[3] = n[6].f;
	       gl_Lightfv( ctx, n[1].e, n[2].e, p, 4 );
	    }
	    break;
case OPCODE_LIGHT_MODEL:
	    {
	       float p[4];
	       p[0] = n[2].f;
	       p[1] = n[3].f;
	       p[2] = n[4].f;
	       p[3] = n[5].f;
	       gl_LightModelfv( ctx, n[1].e, p );
	    }
	    break;
	 case OPCODE_LINE_STIPPLE:
	    gl_LineStipple( ctx, n[1].i, n[2].us );
	    break;
	 case OPCODE_LINE_WIDTH:
	    gl_LineWidth( ctx, n[1].f );
	    break;
	 case OPCODE_LIST_BASE:
	    gl_ListBase( ctx, n[1].ui );
	    break;
	 case OPCODE_LOAD_IDENTITY:
gl_LoadIdentity( ctx );
break;
	 case OPCODE_LOAD_MATRIX:
	    if (sizeof(Node)==sizeof(float)) {
	       gl_LoadMatrixf( ctx, &n[1].f );
	    }
	    else {
	       float m[16];
	       GLuint i;
	       for (i=0;i<16;i++) {
		  m[i] = n[1+i].f;
	       }
	       gl_LoadMatrixf( ctx, m );
	    }
	    break;
	 case OPCODE_LOAD_NAME:
	    gl_LoadName( ctx, n[1].ui );
	    break;
	 case OPCODE_LOGIC_OP:
	    gl_LogicOp( ctx, n[1].e );
	    break;
	 case OPCODE_MAP1:
	    gl_Map1f( ctx, n[1].e, n[2].f, n[3].f,
n[4].i, n[5].i, (float *) n[6].data, GL_TRUE );
	    break;
	 case OPCODE_MAP2:
	    gl_Map2f( ctx, n[1].e,
n[2].f, n[3].f,
		      n[6].i, n[8].i,
		      n[4].f, n[5].f,
		      n[7].i, n[9].i,
		      (float *) n[10].data,
GL_TRUE);
	    break;
	 case OPCODE_MAPGRID1:
	    gl_MapGrid1f( ctx, n[1].i, n[2].f, n[3].f );
	    break;
	 case OPCODE_MAPGRID2:
	    gl_MapGrid2f( ctx, n[1].i, n[2].f, n[3].f, n[4].i, n[5].f, n[6].f);
	    break;
	 case OPCODE_MATERIAL:
	    {
	       float params[4];
	       params[0] = n[3].f;
	       params[1] = n[4].f;
	       params[2] = n[5].f;
	       params[3] = n[6].f;
	       gl_Materialfv( ctx, n[1].e, n[2].e, params );
	    }
	    break;
case OPCODE_MATRIX_MODE:
gl_MatrixMode( ctx, n[1].e );
break;
	 case OPCODE_MULT_MATRIX:
	    if (sizeof(Node)==sizeof(float)) {
	       gl_MultMatrixf( ctx, &n[1].f );
	    }
	    else {
	       float m[16];
	       GLuint i;
	       for (i=0;i<16;i++) {
		  m[i] = n[1+i].f;
	       }
	       gl_MultMatrixf( ctx, m );
	    }
	    break;
case OPCODE_ORTHO:
gl_Ortho( ctx, n[1].f, n[2].f, n[3].f, n[4].f, n[5].f, n[6].f );
break;
	 case OPCODE_PASSTHROUGH:
	    gl_PassThrough( ctx, n[1].f );
	    break;
	 case OPCODE_PIXEL_MAP:
	    gl_PixelMapfv( ctx, n[1].e, n[2].i, (float *) n[3].data );
	    break;
	 case OPCODE_PIXEL_TRANSFER:
	    gl_PixelTransferf( ctx, n[1].e, n[2].f );
	    break;
	 case OPCODE_PIXEL_ZOOM:
	    gl_PixelZoom( ctx, n[1].f, n[2].f );
	    break;
	 case OPCODE_POINT_SIZE:
	    gl_PointSize( ctx, n[1].f );
	    break;
	 case OPCODE_POINT_PARAMETERS:
	    {
		float params[3];
		params[0] = n[2].f;
		params[1] = n[3].f;
		params[2] = n[4].f;
		gl_PointParameterfvEXT( ctx, n[1].e, params );
	    }
	    break;
	 case OPCODE_POLYGON_MODE:
	    gl_PolygonMode( ctx, n[1].e, n[2].e );
	    break;
	 case OPCODE_POLYGON_STIPPLE:
	    gl_PolygonStipple( ctx, (GLubyte *) n[1].data );
	    break;
	 case OPCODE_POLYGON_OFFSET:
	    gl_PolygonOffset( ctx, n[1].f, n[2].f );
	    break;
	 case OPCODE_POP_ATTRIB:
	    gl_PopAttrib( ctx );
	    break;
	 case OPCODE_POP_MATRIX:
	    gl_PopMatrix( ctx );
	    break;
	 case OPCODE_POP_NAME:
	    gl_PopName( ctx );
	    break;
	 case OPCODE_PRIORITIZE_TEXTURE:
gl_PrioritizeTextures( ctx, 1, &n[1].ui, &n[2].f );
	    break;
	 case OPCODE_PUSH_ATTRIB:
	    gl_PushAttrib( ctx, n[1].bf );
	    break;
	 case OPCODE_PUSH_MATRIX:
	    gl_PushMatrix( ctx );
	    break;
	 case OPCODE_PUSH_NAME:
	    gl_PushName( ctx, n[1].ui );
	    break;
	 case OPCODE_RASTER_POS:
gl_RasterPos4f( ctx, n[1].f, n[2].f, n[3].f, n[4].f );
	    break;
	 case OPCODE_READ_BUFFER:
	    gl_ReadBuffer( ctx, n[1].e );
	    break;
case OPCODE_RECTF:
gl_Rectf( ctx, n[1].f, n[2].f, n[3].f, n[4].f );
break;
case OPCODE_SCALE:
gl_Scalef( ctx, n[1].f, n[2].f, n[3].f );
break;
	 case OPCODE_SCISSOR:
	    gl_Scissor( ctx, n[1].i, n[2].i, n[3].i, n[4].i );
	    break;
	 case OPCODE_SHADE_MODEL:
	    gl_ShadeModel( ctx, n[1].e );
	    break;
	 case OPCODE_STENCIL_FUNC:
	    gl_StencilFunc( ctx, n[1].e, n[2].i, n[3].ui );
	    break;
	 case OPCODE_STENCIL_MASK:
	    gl_StencilMask( ctx, n[1].ui );
	    break;
	 case OPCODE_STENCIL_OP:
	    gl_StencilOp( ctx, n[1].e, n[2].e, n[3].e );
	    break;
case OPCODE_TEXENV:
{
float params[4];
params[0] = n[3].f;
params[1] = n[4].f;
params[2] = n[5].f;
params[3] = n[6].f;
gl_TexEnvfv( ctx, n[1].e, n[2].e, params );
}
break;
case OPCODE_TEXGEN:
{
float params[4];
params[0] = n[3].f;
params[1] = n[4].f;
params[2] = n[5].f;
params[3] = n[6].f;
gl_TexGenfv( ctx, n[1].e, n[2].e, params );
}
break;
case OPCODE_TEXPARAMETER:
{
float params[4];
params[0] = n[3].f;
params[1] = n[4].f;
params[2] = n[5].f;
params[3] = n[6].f;
gl_TexParameterfv( ctx, n[1].e, n[2].e, params );
}
break;
	 case OPCODE_TEX_IMAGE1D:
	    gl_TexImage1D( ctx,
n[1].e,
n[2].i,
n[3].i,
n[4].i,
n[5].e,
n[6].e,
n[7].e,
(struct gl_image *) n[8].data );
	    break;
	 case OPCODE_TEX_IMAGE2D:
	    gl_TexImage2D( ctx,
n[1].e,
n[2].i,
n[3].i,
n[4].i,
n[5].i,
n[6].e,
n[7].e,
n[8].e,
(struct gl_image *) n[9].data );
	    break;
case OPCODE_TEX_IMAGE3D:
gl_TexImage3DEXT( ctx,
n[1].e,
n[2].i,
n[3].i,
n[4].i,
n[5].i,
n[6].i,
n[7].e,
n[8].e,
n[9].e,
(struct gl_image *) n[10].data );
break;
case OPCODE_TEX_SUB_IMAGE1D:
gl_TexSubImage1D( ctx, n[1].e, n[2].i, n[3].i, n[4].i, n[5].e,
n[6].e, (struct gl_image *) n[7].data );
break;
case OPCODE_TEX_SUB_IMAGE2D:
gl_TexSubImage2D( ctx, n[1].e, n[2].i, n[3].i, n[4].i, n[5].e,
n[6].i, n[7].e, n[8].e,
(struct gl_image *) n[9].data );
break;
case OPCODE_TEX_SUB_IMAGE3D:
gl_TexSubImage3DEXT( ctx, n[1].e, n[2].i, n[3].i, n[4].i, n[5].i,
n[6].i, n[7].i, n[8].i, n[9].e, n[10].e,
(struct gl_image *) n[11].data );
break;
case OPCODE_TRANSLATE:
gl_Translatef( ctx, n[1].f, n[2].f, n[3].f );
break;
	 case OPCODE_VIEWPORT:
	    gl_Viewport( ctx,
n[1].i, n[2].i, (GLsizei) n[3].i, (GLsizei) n[4].i );
	    break;
	 case OPCODE_WINDOW_POS:
gl_WindowPos4fMESA( ctx, n[1].f, n[2].f, n[3].f, n[4].f );
	    break;
	 case OPCODE_CONTINUE:
	    n = (Node *) n[1].next;
	    break;
	 case OPCODE_END_OF_LIST:
	    done = GL_TRUE;
	    break;
	 default:
{
char msg[1000];
sprintf(msg, "Error in execute_list: opcode=%d", (int) opcode);
gl_problem( ctx, msg );
}
done = GL_TRUE;
}
if (opcode!=OPCODE_CONTINUE) {
	 n += InstSize[opcode];
}
}
ctx->CallDepth--;
}
GLboolean gl_IsList( GLcontext *ctx, GLuint list )
{
if (list > 0 && HashLookup(ctx->Shared->DisplayList, list)) {
return GL_TRUE;
}
else {
return GL_FALSE;
}
}
void gl_DeleteLists( GLcontext *ctx, GLuint list, GLsizei range )
{
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glDeleteLists" );
return;
}
if (range<0) {
gl_error( ctx, GL_INVALID_VALUE, "glDeleteLists" );
return;
}
for (i=list;i<list+range;i++) {
gl_destroy_list( ctx, i );
}
}
GLuint gl_GenLists( GLcontext *ctx, GLsizei range )
{
GLuint base;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGenLists" );
return 0;
}
if (range<0) {
gl_error( ctx, GL_INVALID_VALUE, "glGenLists" );
return 0;
}
if (range==0) {
return 0;
}
base = HashFindFreeKeyBlock(ctx->Shared->DisplayList, range);
if (base) {
GLuint i;
for (i=0; i<range; i++) {
HashInsert(ctx->Shared->DisplayList, base+i, make_empty_list());
}
}
return base;
}
void gl_NewList( GLcontext *ctx, GLuint list, GLenum mode )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glNewList" );
return;
}
if (list==0) {
gl_error( ctx, GL_INVALID_VALUE, "glNewList" );
return;
}
if (mode!=GL_COMPILE && mode!=GL_COMPILE_AND_EXECUTE) {
gl_error( ctx, GL_INVALID_ENUM, "glNewList" );
return;
}
if (CurrentListPtr) {
gl_error( ctx, GL_INVALID_OPERATION, "glNewList" );
return;
}
CurrentListNum = list;
CurrentListPtr = CurrentBlock = (Node *) malloc( sizeof(Node) * BLOCK_SIZE );
CurrentPos = 0;
ctx->CompileFlag = GL_TRUE;
if (mode==GL_COMPILE) {
ctx->ExecuteFlag = GL_FALSE;
}
else {
ctx->ExecuteFlag = GL_TRUE;
}
ctx->API = ctx->Save;
}
void gl_EndList( GLcontext *ctx )
{
Node *n;
if (!CurrentListPtr) {
gl_error( ctx, GL_INVALID_OPERATION, "glEndList" );
return;
}
n = alloc_instruction( ctx, OPCODE_END_OF_LIST, 0 );
gl_destroy_list(ctx, CurrentListNum);
HashInsert(ctx->Shared->DisplayList, CurrentListNum, CurrentListPtr);
CurrentListNum = 0;
CurrentListPtr = NULL;
ctx->ExecuteFlag = GL_TRUE;
ctx->CompileFlag = GL_FALSE;
ctx->API = ctx->Exec;
}
void gl_CallList( GLcontext *ctx, GLuint list )
{
GLboolean save_compile_flag;
save_compile_flag = ctx->CompileFlag;
ctx->CompileFlag = GL_FALSE;
execute_list( ctx, list );
ctx->CompileFlag = save_compile_flag;
}
void gl_CallLists( GLcontext *ctx,
GLsizei n, GLenum type, const GLvoid *lists )
{
GLuint i, list;
GLboolean save_compile_flag;
save_compile_flag = ctx->CompileFlag;
ctx->CompileFlag = GL_FALSE;
for (i=0;i<n;i++) {
list = translate_id( i, type, lists );
execute_list( ctx, ctx->List.ListBase + list );
}
ctx->CompileFlag = save_compile_flag;
}
void gl_ListBase( GLcontext *ctx, GLuint base )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glListBase" );
return;
}
ctx->List.ListBase = base;
}
static char tmp[1000];
static char *enum_string( GLenum k )
{
switch (k) {
case GL_POINTS:		return "GL_POINTS";
case GL_LINES:		return "GL_LINES";
case GL_LINE_STRIP:	return "GL_LINE_STRIP";
case GL_LINE_LOOP:	return "GL_LINE_LOOP";
case GL_TRIANGLES:	return "GL_TRIANGLES";
case GL_TRIANGLE_STRIP:	return "GL_TRIANGLE_STRIP";
case GL_TRIANGLE_FAN:	return "GL_TRIANGLE_FAN";
case GL_QUADS:		return "GL_QUADS";
case GL_QUAD_STRIP:	return "GL_QUAD_STRIP";
case GL_POLYGON:		return "GL_POLYGON";
case GL_FRONT:		return "GL_FRONT";
case GL_BACK:		return "GL_BACK";
case GL_FRONT_AND_BACK:	return "GL_FRONT_AND_BACK";
case GL_AMBIENT:		return "GL_AMBIENT";
case GL_DIFFUSE:		return "GL_DIFFUSE";
case GL_SPECULAR:		return "GL_SPECULAR";
case GL_SHININESS:	return "GL_SHININESS";
default:
sprintf(tmp,"0x%X", k);
return tmp;
}
}
static void print_list( GLcontext *ctx, FILE *f, GLuint list )
{
Node *n;
GLboolean done;
OpCode opcode;
if (!glIsList(list)) {
fprintf(f,"%d is not a display list ID\n",list);
return;
}
n = (Node *) HashLookup(ctx->Shared->DisplayList, list);
fprintf( f, "START-LIST %d, address %p\n", list, (void*)n );
done = n ? GL_FALSE : GL_TRUE;
while (!done) {
opcode = n[0].opcode;
switch (opcode) {
case OPCODE_ACCUM:
fprintf(f,"accum %d %g\n", n[1].e, n[2].f );
	    break;
case OPCODE_BEGIN:
fprintf(f,"Begin %s\n", enum_string(n[1].e) );
break;
	 case OPCODE_BITMAP:
fprintf(f,"Bitmap %d %d %g %g %g %g %p\n", n[1].i, n[2].i,
		       n[3].f, n[4].f, n[5].f, n[6].f, (void *) n[7].data );
	    break;
case OPCODE_CALL_LIST:
fprintf(f,"CallList %d\n", n[1].ui );
break;
case OPCODE_CALL_LIST_OFFSET:
fprintf(f,"CallList %d + offset %d = %d\n", n[1].ui,
ctx->List.ListBase, ctx->List.ListBase + n[1].ui );
break;
	 case OPCODE_COLOR_3F:
fprintf(f,"Color3f %g %g %gn", n[1].f, n[2].f, n[3].f );
	    break;
	 case OPCODE_COLOR_4F:
fprintf(f,"Color4f %g %g %g %g\n", n[1].f, n[2].f, n[3].f, n[4].f);
	    break;
	 case OPCODE_COLOR_4UB:
fprintf(f,"Color4ub %d %d %d %d\n", n[1].ub, n[2].ub,
n[3].ub, n[4].ub );
	    break;
	 case OPCODE_DISABLE:
fprintf(f,"Disable %s\n", enum_string(n[1].e));
	    break;
	 case OPCODE_ENABLE:
fprintf(f,"Enable %s\n", enum_string(n[1].e));
	    break;
case OPCODE_END:
fprintf(f,"End\n");
break;
case OPCODE_FRUSTUM:
fprintf(f,"Frustum %g %g %g %g %g %g\n",
n[1].f, n[2].f, n[3].f, n[4].f, n[5].f, n[6].f );
break;
case OPCODE_INDEX:
fprintf(f,"Index %d\n", n[1].ui );
break;
	 case OPCODE_LINE_STIPPLE:
	    fprintf(f,"LineStipple %d %x\n", n[1].i, (int) n[2].us );
	    break;
	 case OPCODE_LOAD_IDENTITY:
fprintf(f,"LoadIdentity\n");
	    break;
	 case OPCODE_LOAD_MATRIX:
fprintf(f,"LoadMatrix\n");
fprintf(f,"  %8f %8f %8f %8f\n", n[1].f, n[5].f,  n[9].f, n[13].f);
fprintf(f,"  %8f %8f %8f %8f\n", n[2].f, n[6].f, n[10].f, n[14].f);
fprintf(f,"  %8f %8f %8f %8f\n", n[3].f, n[7].f, n[11].f, n[15].f);
fprintf(f,"  %8f %8f %8f %8f\n", n[4].f, n[8].f, n[12].f, n[16].f);
	    break;
	 case OPCODE_MATERIAL:
fprintf(f,"Material %s %s %g %g %g %g\n", enum_string(n[1].e),
enum_string(n[2].e), n[3].f, n[4].f, n[5].f, n[6].f );
break;
	 case OPCODE_MULT_MATRIX:
fprintf(f,"MultMatrix (or Rotate)\n");
fprintf(f,"  %8f %8f %8f %8f\n", n[1].f, n[5].f,  n[9].f, n[13].f);
fprintf(f,"  %8f %8f %8f %8f\n", n[2].f, n[6].f, n[10].f, n[14].f);
fprintf(f,"  %8f %8f %8f %8f\n", n[3].f, n[7].f, n[11].f, n[15].f);
fprintf(f,"  %8f %8f %8f %8f\n", n[4].f, n[8].f, n[12].f, n[16].f);
	    break;
case OPCODE_NORMAL:
fprintf(f,"Normal %g %g %g\n", n[1].f, n[2].f, n[3].f );
break;
case OPCODE_ORTHO:
fprintf(f,"Ortho %g %g %g %g %g %g\n",
n[1].f, n[2].f, n[3].f, n[4].f, n[5].f, n[6].f );
break;
	 case OPCODE_POP_ATTRIB:
fprintf(f,"PopAttrib\n");
	    break;
	 case OPCODE_POP_MATRIX:
fprintf(f,"PopMatrix\n");
	    break;
	 case OPCODE_POP_NAME:
fprintf(f,"PopName\n");
	    break;
	 case OPCODE_PUSH_ATTRIB:
fprintf(f,"PushAttrib %x\n", n[1].bf );
	    break;
	 case OPCODE_PUSH_MATRIX:
fprintf(f,"PushMatrix\n");
	    break;
	 case OPCODE_PUSH_NAME:
fprintf(f,"PushName %d\n", n[1].ui );
	    break;
	 case OPCODE_RASTER_POS:
fprintf(f,"RasterPos %g %g %g %g\n", n[1].f, n[2].f,n[3].f,n[4].f);
	    break;
case OPCODE_RECTF:
fprintf( f, "Rectf %g %g %g %g\n", n[1].f, n[2].f, n[3].f, n[4].f);
break;
case OPCODE_SCALE:
fprintf(f,"Scale %g %g %g\n", n[1].f, n[2].f, n[3].f );
break;
	 case OPCODE_TEXCOORD2:
fprintf(f,"TexCoord %g %g\n", n[1].f, n[2].f);
	    break;
	 case OPCODE_TEXCOORD4:
fprintf(f,"TexCoord %g %g %g %g\n", n[1].f, n[2].f, n[3].f,n[4].f);
	    break;
case OPCODE_TRANSLATE:
fprintf(f,"Translate %g %g %g\n", n[1].f, n[2].f, n[3].f );
break;
case OPCODE_VERTEX2:
fprintf(f,"Vertex %g %g\n", n[1].f, n[2].f );
break;
case OPCODE_VERTEX3:
fprintf(f,"Vertex %g %g %g\n", n[1].f, n[2].f, n[3].f );
break;
case OPCODE_VERTEX4:
fprintf(f,"Vertex %g %g %g %g\n", n[1].f, n[2].f, n[3].f, n[4].f );
break;
	
	 case OPCODE_CONTINUE:
fprintf(f,"DISPLAY-LIST-CONTINUE\n");
	    n = (Node *) n[1].next;
	    break;
	 case OPCODE_END_OF_LIST:
fprintf(f,"END-LIST %d\n", list);
	    done = GL_TRUE;
	    break;
default:
if (opcode < 0 || opcode > OPCODE_END_OF_LIST) {
fprintf(f,"ERROR IN DISPLAY LIST: opcode = %d, address = %p\n",
opcode, (void*) n);
return;
}
else {
fprintf(f,"command %d, %d operands\n",opcode,InstSize[opcode]);
}
}
if (opcode!=OPCODE_CONTINUE) {
	 n += InstSize[opcode];
}
}
}
void mesa_print_display_list( GLuint list )
{
GLcontext *ctx;
#ifdef MULTI_THREADING
ctx = gl_get_thread_context();
#else
ctx = CC;
#endif
print_list( ctx, stdout, list );
}
/* 当前文件是D:\Read\drawpix.c*/

#ifdef PC_HEADER
#else
#endif
static void draw_index_pixels( GLcontext* ctx, GLsizei width, GLsizei height,
			       GLenum type, const GLvoid *pixels )
{
GLint x, y, desty;
GLuint i, j;
GLdepth zspan[MAX_WIDTH];
GLboolean zoom;
zoom = ctx->Pixel.ZoomX!=1.0 || ctx->Pixel.ZoomY!=1.0;
x = (GLint) (ctx->Current.RasterPos[0] + 0.5F);
y = (GLint) (ctx->Current.RasterPos[1] + 0.5F);
desty = y;
if (ctx->Depth.Test) {
GLdepth zval = (GLdepth) (ctx->Current.RasterPos[2] * DEPTH_SCALE);
for (i=0;i<width;i++) {
	 zspan[i] = zval;
}
}
for (i=0;i<height;i++,y++) {
GLuint ispan[MAX_WIDTH];
switch (type) {
	 case GL_UNSIGNED_BYTE:
	    {
	       GLubyte *src = (GLubyte *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  ispan[j] = (GLuint) *src++;
	       }
	    }
	    break;
	 case GL_BYTE:
	    {
	       GLbyte *src = (GLbyte *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  ispan[j] = (GLuint) *src++;
	       }
	    }
	    break;
	 case GL_UNSIGNED_SHORT:
	    {
	       GLushort *src = (GLushort *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  ispan[j] = (GLuint) *src++;
	       }
	    }
	    break;
	 case GL_SHORT:
	    {
	       GLshort *src = (GLshort *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  ispan[j] = (GLuint) *src++;
	       }
	    }
	    break;
	 case GL_UNSIGNED_INT:
	    {
	       GLuint *src = (GLuint *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  ispan[j] = *src++;
	       }
	    }
	    break;
	 case GL_INT:
	    {
	       GLint *src = (GLint *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  ispan[j] = (GLuint) *src++;
	       }
	    }
	    break;
	 case GL_BITMAP:
	
	    break;
	 case GL_FLOAT:
	    {
	       float *src = (float *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  ispan[j] = (GLuint) (GLint) *src++;
	       }
	    }
	    break;
	 default:
	    gl_error( ctx, GL_INVALID_ENUM, "Internal: draw_index_pixels" );
}
if (ctx->Pixel.IndexOffset || ctx->Pixel.IndexShift) {
	 if (ctx->Pixel.IndexShift>=0) {
	    for (j=0;j<width;j++) {
	       ispan[j] = (ispan[j] << ctx->Pixel.IndexShift)
		          + ctx->Pixel.IndexOffset;
	    }
	 }
	 else {
	    for (j=0;j<width;j++) {
	       ispan[j] = (ispan[j] >> -ctx->Pixel.IndexShift)
		          + ctx->Pixel.IndexOffset;
	    }
	 }
}
if (ctx->Visual->RGBAflag) {
	
	 GLubyte red[MAX_WIDTH], green[MAX_WIDTH];
	 GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];
	 for (j=0;j<width;j++) {
	    red[j]   = (GLint) (ctx->Pixel.MapItoR[ispan[j]] * ctx->Visual->RedScale);
	    green[j] = (GLint) (ctx->Pixel.MapItoG[ispan[j]] * ctx->Visual->GreenScale);
	    blue[j]  = (GLint) (ctx->Pixel.MapItoB[ispan[j]] * ctx->Visual->BlueScale);
	    alpha[j] = (GLint) (ctx->Pixel.MapItoA[ispan[j]] * ctx->Visual->AlphaScale);
	 }
if (zoom) {
gl_write_zoomed_color_span( ctx, width, x, y, zspan,
red, green, blue, alpha, desty );
}
else {
gl_write_color_span( ctx, width, x, y, zspan,
red, green, blue, alpha, GL_BITMAP );
}
}
else {
	
	 if (ctx->Pixel.MapColorFlag) {
	    for (j=0;j<width;j++) {
	       ispan[j] = ctx->Pixel.MapItoI[ispan[j]];
	    }
	 }
if (zoom) {
gl_write_zoomed_index_span( ctx, width, x, y, zspan, ispan, desty );
}
else {
gl_write_index_span( ctx, width, x, y, zspan, ispan, GL_BITMAP );
}
}
}
}
static void draw_stencil_pixels( GLcontext* ctx, GLsizei width, GLsizei height,
			         GLenum type, const GLvoid *pixels )
{
GLint x, y, desty;
GLuint i, j;
GLboolean zoom;
zoom = ctx->Pixel.ZoomX!=1.0 || ctx->Pixel.ZoomY!=1.0;
x = (GLint) (ctx->Current.RasterPos[0] + 0.5F);
y = (GLint) (ctx->Current.RasterPos[1] + 0.5F);
desty = y;
for (i=0;i<height;i++,y++) {
GLubyte stencil[MAX_WIDTH];
switch (type) {
	 case GL_UNSIGNED_BYTE:
	    {
	       GLubyte *src = (GLubyte *) pixels + i * width;
	       MEMCPY( stencil, src, width );
	    }
	    break;
	 case GL_BYTE:
	    {
	       GLbyte *src = (GLbyte *) pixels + i * width;
	       MEMCPY( stencil, src, width );
	    }
	    break;
	 case GL_UNSIGNED_SHORT:
	    {
	       GLushort *src = (GLushort *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  stencil[j] = (GLubyte) ((*src++) & 0xff);
	       }
	    }
	    break;
	 case GL_SHORT:
	    {
	       GLshort *src = (GLshort *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  stencil[j] = (GLubyte) ((*src++) & 0xff);
	       }
	    }
	    break;
	 case GL_UNSIGNED_INT:
	    {
	       GLuint *src = (GLuint *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  stencil[j] = (GLubyte) ((*src++) & 0xff);
	       }
	    }
	    break;
	 case GL_INT:
	    {
	       GLint *src = (GLint *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  stencil[j] = (GLubyte) ((*src++) & 0xff);
	       }
	    }
	    break;
	 case GL_BITMAP:
	
	    break;
	 case GL_FLOAT:
	    {
	       float *src = (float *) pixels + i * width;
	       for (j=0;j<width;j++) {
		  stencil[j] = (GLubyte) (((GLint) *src++) & 0xff);
	       }
	    }
	    break;
	 default:
	    gl_error( ctx, GL_INVALID_ENUM, "Internal: draw_stencil_pixels" );
}
if (ctx->Pixel.IndexOffset || ctx->Pixel.IndexShift) {
	 if (ctx->Pixel.IndexShift>=0) {
	    for (j=0;j<width;j++) {
	       stencil[j] = (stencil[j] << ctx->Pixel.IndexShift)
		          + ctx->Pixel.IndexOffset;
	    }
	 }
	 else {
	    for (j=0;j<width;j++) {
	       stencil[j] = (stencil[j] >> -ctx->Pixel.IndexShift)
		          + ctx->Pixel.IndexOffset;
	    }
	 }
}
if (ctx->Pixel.MapStencilFlag) {
	 for (j=0;j<width;j++) {
	    stencil[j] = ctx->Pixel.MapStoS[ stencil[j] ];
	 }
}
if (zoom) {
gl_write_zoomed_stencil_span( ctx, (GLuint) width, x, y, stencil, desty );
}
else {
gl_write_stencil_span( ctx, (GLuint) width, x, y, stencil );
}
}
}
static void draw_depth_pixels( GLcontext* ctx, GLsizei width, GLsizei height,
			       GLenum type, const GLvoid *pixels )
{
GLint x, y, desty;
GLubyte red[MAX_WIDTH], green[MAX_WIDTH], blue[MAX_WIDTH], alpha[MAX_WIDTH];
GLuint ispan[MAX_WIDTH];
GLboolean bias_or_scale;
GLboolean zoom;
bias_or_scale = ctx->Pixel.DepthBias!=0.0 || ctx->Pixel.DepthScale!=1.0;
zoom = ctx->Pixel.ZoomX!=1.0 || ctx->Pixel.ZoomY!=1.0;
x = (GLint) (ctx->Current.RasterPos[0] + 0.5F);
y = (GLint) (ctx->Current.RasterPos[1] + 0.5F);
desty = y;
if (ctx->Visual->RGBAflag) {
GLint r, g, b, a;
r = (GLint) (ctx->Current.RasterColor[0] * ctx->Visual->RedScale);
g = (GLint) (ctx->Current.RasterColor[1] * ctx->Visual->GreenScale);
b = (GLint) (ctx->Current.RasterColor[2] * ctx->Visual->BlueScale);
a = (GLint) (ctx->Current.RasterColor[3] * ctx->Visual->AlphaScale);
MEMSET( red,   r, width );
MEMSET( green, g, width );
MEMSET( blue,  b, width );
MEMSET( alpha, a, width );
}
else {
GLuint i;
for (i=0;i<width;i++) {
	 ispan[i] = ctx->Current.RasterIndex;
}
}
if (type==GL_UNSIGNED_SHORT && sizeof(GLdepth)==sizeof(GLushort)
&& !bias_or_scale && !zoom && ctx->Visual->RGBAflag) {
GLuint j;
for (j=0;j<height;j++,y++) {
GLdepth *zptr = (GLdepth *) pixels + j * width;
gl_write_color_span( ctx, width, x, y, zptr,
red, green, blue, alpha, GL_BITMAP );
}
}
else if (type==GL_UNSIGNED_INT && sizeof(GLdepth)==sizeof(GLuint)
&& !bias_or_scale && !zoom && ctx->Visual->RGBAflag) {
GLuint i, j;
GLuint shift = 0;
GLuint max = MAX_DEPTH;
while ((max&0x80000000)==0) {
max = max << 1;
shift++;
}
for (j=0;j<height;j++,y++) {
GLdepth zspan[MAX_WIDTH];
GLuint *zptr = (GLuint *) pixels + j * width;
for (i=0;i<width;i++) {
zspan[i] = zptr[i] >> shift;
}
gl_write_color_span( ctx, width, x, y, zspan,
red, green, blue, alpha, GL_BITMAP );
}
}
else {
GLuint i, j;
for (i=0;i<height;i++,y++) {
float depth[MAX_WIDTH];
GLdepth zspan[MAX_WIDTH];
switch (type) {
case GL_UNSIGNED_BYTE:
{
GLubyte *src = (GLubyte *) pixels + i * width;
for (j=0;j<width;j++) {
depth[j] = UBYTE_TO_FLOAT( *src++ );
}
}
break;
case GL_BYTE:
{
GLbyte *src = (GLbyte *) pixels + i * width;
for (j=0;j<width;j++) {
depth[j] = BYTE_TO_FLOAT( *src++ );
}
}
break;
case GL_UNSIGNED_SHORT:
{
GLushort *src = (GLushort *) pixels + i * width;
for (j=0;j<width;j++) {
depth[j] = USHORT_TO_FLOAT( *src++ );
}
}
break;
case GL_SHORT:
{
GLshort *src = (GLshort *) pixels + i * width;
for (j=0;j<width;j++) {
depth[j] = SHORT_TO_FLOAT( *src++ );
}
}
break;
case GL_UNSIGNED_INT:
{
GLuint *src = (GLuint *) pixels + i * width;
for (j=0;j<width;j++) {
depth[j] = UINT_TO_FLOAT( *src++ );
}
}
break;
case GL_INT:
{
GLint *src = (GLint *) pixels + i * width;
for (j=0;j<width;j++) {
depth[j] = INT_TO_FLOAT( *src++ );
}
}
break;
case GL_FLOAT:
{
float *src = (float *) pixels + i * width;
for (j=0;j<width;j++) {
depth[j] = *src++;
}
}
break;
default:
gl_problem(ctx, "Bad type in draw_depth_pixels");
return;
}
if (ctx->Pixel.DepthScale!=1.0 || ctx->Pixel.DepthBias!=0.0) {
for (j=0;j<width;j++) {
depth[j] = depth[j] * ctx->Pixel.DepthScale + ctx->Pixel.DepthBias;
}
}
for (j=0;j<width;j++) {
zspan[j] = (GLdepth) (CLAMP( depth[j], 0.0F, 1.0F ) * DEPTH_SCALE);
}
if (ctx->Visual->RGBAflag) {
if (zoom) {
gl_write_zoomed_color_span( ctx, width, x, y, zspan,
red, green, blue, alpha, desty );
}
else {
gl_write_color_span( ctx, width, x, y, zspan,
red, green, blue, alpha, GL_BITMAP );
}
}
else {
if (zoom) {
gl_write_zoomed_index_span( ctx, width, x, y, zspan,
ispan, GL_BITMAP );
}
else {
gl_write_index_span( ctx, width, x, y, zspan, ispan, GL_BITMAP );
}
}
}
}
}
static void draw_color_pixels( GLcontext* ctx,
GLsizei width, GLsizei height, GLenum format,
			       GLenum type, const GLvoid *pixels )
{
GLuint i, j;
GLint x, y, desty;
GLdepth zspan[MAX_WIDTH];
GLboolean scale_or_bias, quick_draw;
GLboolean zoom;
zoom = ctx->Pixel.ZoomX!=1.0 || ctx->Pixel.ZoomY!=1.0;
x = (GLint) (ctx->Current.RasterPos[0] + 0.5F);
y = (GLint) (ctx->Current.RasterPos[1] + 0.5F);
desty = y;
if (ctx->Depth.Test) {
GLdepth z = (GLdepth) (ctx->Current.RasterPos[2] * DEPTH_SCALE);
for (i=0;i<width;i++) {
	 zspan[i] = z;
}
}
if (ctx->Pixel.RedScale!=1.0F   || ctx->Pixel.RedBias!=0.0F ||
ctx->Pixel.GreenScale!=1.0F || ctx->Pixel.GreenBias!=0.0F ||
ctx->Pixel.BlueScale!=1.0F  || ctx->Pixel.BlueBias!=0.0F ||
ctx->Pixel.AlphaScale!=1.0F || ctx->Pixel.AlphaBias!=0.0F) {
scale_or_bias = GL_TRUE;
}
else {
scale_or_bias = GL_FALSE;
}
if (ctx->RasterMask==0 && !zoom && x>=0 && y>=0
&& x+width<=ctx->Buffer->Width && y+height<=ctx->Buffer->Height) {
quick_draw = GL_TRUE;
}
else {
quick_draw = GL_FALSE;
}
if (type==GL_UNSIGNED_BYTE && (format==GL_RGB || format == GL_LUMINANCE)
&& !ctx->Pixel.MapColorFlag && !scale_or_bias
&& ctx->Visual->EightBitColor) {
DEFARRAY( GLubyte, alpha, MAX_WIDTH );
GLubyte *src = (GLubyte *) pixels;
MEMSET( alpha, (GLint) ctx->Visual->AlphaScale, width );
if (format == GL_RGB) {
	
	 DEFARRAY( GLubyte, red, MAX_WIDTH );
	 DEFARRAY( GLubyte, green, MAX_WIDTH );
	 DEFARRAY( GLubyte, blue, MAX_WIDTH );
	 for (i=0;i<height;i++,y++) {
	    for (j=0;j<width;j++) {
	       red[j]   = *src++;
	       green[j] = *src++;
	       blue[j]  = *src++;
	    }
	    if (quick_draw) {
	       (*ctx->Driver.WriteColorSpan)( ctx, width, x, y,
red, green, blue, alpha, NULL);
	    }
	    else if (zoom) {
	       gl_write_zoomed_color_span( ctx, (GLuint) width, x, y, zspan,
					   red, green, blue, alpha, desty );
	    }
	    else {
	       gl_write_color_span( ctx, (GLuint) width, x, y, zspan,
				    red, green, blue, alpha, GL_BITMAP );
	    }
	 }
	 UNDEFARRAY( red );
	 UNDEFARRAY( green );
	 UNDEFARRAY( blue );
}
else {
	
	 GLubyte *lum = (GLubyte *) pixels;
	 for (i=0;i<height;i++,y++,lum+=width) {
	    if (quick_draw) {
	       (*ctx->Driver.WriteColorSpan)( ctx, width, x,y,
lum, lum, lum, alpha, NULL);
	    }
	    else if (zoom) {
	       gl_write_zoomed_color_span( ctx, (GLuint) width, x, y, zspan,
					   lum, lum, lum, alpha, desty );
	    }
	    else {
	       gl_write_color_span( ctx, (GLuint) width, x, y, zspan,
				    lum, lum, lum, alpha, GL_BITMAP );
	    }
	 }
}
UNDEFARRAY( alpha );
}
else {
GLboolean r_flag, g_flag, b_flag, a_flag, l_flag;
GLuint components;
r_flag = g_flag = b_flag = a_flag = l_flag = GL_FALSE;
switch (format) {
	 case GL_RED:
	    r_flag = GL_TRUE;
	    components = 1;
	    break;
	 case GL_GREEN:
	    g_flag = GL_TRUE;
	    components = 1;
	    break;
	 case GL_BLUE:
	    b_flag = GL_TRUE;
	    components = 1;
	    break;
	 case GL_ALPHA:
	    a_flag = GL_TRUE;
	    components = 1;
	    break;
	 case GL_RGB:
	    r_flag = g_flag = b_flag = GL_TRUE;
	    components = 3;
	    break;
	 case GL_LUMINANCE:
	    l_flag = GL_TRUE;
	    components = 1;
	    break;
	 case GL_LUMINANCE_ALPHA:
	    l_flag = a_flag = GL_TRUE;
	    components = 2;
	    break;
	 case GL_RGBA:
	    r_flag = g_flag = b_flag = a_flag = GL_TRUE;
	    components = 4;
	    break;
default:
gl_problem(ctx, "Bad type in draw_color_pixels");
return;
}
for (i=0;i<height;i++,y++) {
DEFARRAY(float, rf, MAX_WIDTH);
DEFARRAY(float, gf, MAX_WIDTH);
DEFARRAY(float, bf, MAX_WIDTH);
DEFARRAY(float, af, MAX_WIDTH);
DEFARRAY(GLubyte, red, MAX_WIDTH);
DEFARRAY(GLubyte, green, MAX_WIDTH);
DEFARRAY(GLubyte, blue, MAX_WIDTH);
DEFARRAY(GLubyte, alpha, MAX_WIDTH);
	
	 switch (type) {
	    case GL_UNSIGNED_BYTE:
	       {
		  GLubyte *src = (GLubyte *) pixels + i * width * components;
		  for (j=0;j<width;j++) {
		     if (l_flag) {
			rf[j] = gf[j] = bf[j] = UBYTE_TO_FLOAT(*src++);
		     }
		     else {
			rf[j] = r_flag ? UBYTE_TO_FLOAT(*src++) : 0.0;
			gf[j] = g_flag ? UBYTE_TO_FLOAT(*src++) : 0.0;
			bf[j] = b_flag ? UBYTE_TO_FLOAT(*src++) : 0.0;
		     }
		     af[j] = a_flag ? UBYTE_TO_FLOAT(*src++) : 1.0;
		  }
	       }
	       break;
	    case GL_BYTE:
	       {
		  GLbyte *src = (GLbyte *) pixels + i * width * components;
		  for (j=0;j<width;j++) {
		     if (l_flag) {
			rf[j] = gf[j] = bf[j] = BYTE_TO_FLOAT(*src++);
		     }
		     else {
			rf[j] = r_flag ? BYTE_TO_FLOAT(*src++) : 0.0;
			gf[j] = g_flag ? BYTE_TO_FLOAT(*src++) : 0.0;
			bf[j] = b_flag ? BYTE_TO_FLOAT(*src++) : 0.0;
		     }
		     af[j] = a_flag ? BYTE_TO_FLOAT(*src++) : 1.0;
		  }
	       }
	       break;
	    case GL_BITMAP:
	
	       break;
	    case GL_UNSIGNED_SHORT:
	       {
		  GLushort *src = (GLushort *) pixels + i * width * components;
		  for (j=0;j<width;j++) {
		     if (l_flag) {
			rf[j] = gf[j] = bf[j] = USHORT_TO_FLOAT(*src++);
		     }
		     else {
			rf[j] = r_flag ? USHORT_TO_FLOAT(*src++) : 0.0;
			gf[j] = g_flag ? USHORT_TO_FLOAT(*src++) : 0.0;
			bf[j] = b_flag ? USHORT_TO_FLOAT(*src++) : 0.0;
		     }
		     af[j] = a_flag ? USHORT_TO_FLOAT(*src++) : 1.0;
		  }
	       }
	       break;
	    case GL_SHORT:
	       {
		  GLshort *src = (GLshort *) pixels + i * width * components;
		  for (j=0;j<width;j++) {
		     if (l_flag) {
			rf[j] = gf[j] = bf[j] = SHORT_TO_FLOAT(*src++);
		     }
		     else {
			rf[j] = r_flag ? SHORT_TO_FLOAT(*src++) : 0.0;
			gf[j] = g_flag ? SHORT_TO_FLOAT(*src++) : 0.0;
			bf[j] = b_flag ? SHORT_TO_FLOAT(*src++) : 0.0;
		     }
		     af[j] = a_flag ? SHORT_TO_FLOAT(*src++) : 1.0;
		  }
	       }
	       break;
	    case GL_UNSIGNED_INT:
	       {
		  GLuint *src = (GLuint *) pixels + i * width * components;
		  for (j=0;j<width;j++) {
		     if (l_flag) {
			rf[j] = gf[j] = bf[j] = UINT_TO_FLOAT(*src++);
		     }
		     else {
			rf[j] = r_flag ? UINT_TO_FLOAT(*src++) : 0.0;
			gf[j] = g_flag ? UINT_TO_FLOAT(*src++) : 0.0;
			bf[j] = b_flag ? UINT_TO_FLOAT(*src++) : 0.0;
		     }
		     af[j] = a_flag ? af[j] = UINT_TO_FLOAT(*src++) : 1.0;
		  }
	       }
	       break;
	    case GL_INT:
	       {
		  GLint *src = (GLint *) pixels + i * width * components;
		  for (j=0;j<width;j++) {
		     if (l_flag) {
			rf[j] = gf[j] = bf[j] = INT_TO_FLOAT(*src++);
		     }
		     else {
			rf[j] = r_flag ? INT_TO_FLOAT(*src++) : 0.0;
			gf[j] = g_flag ? INT_TO_FLOAT(*src++) : 0.0;
			bf[j] = b_flag ? INT_TO_FLOAT(*src++) : 0.0;
		     }
		     af[j] = a_flag ? INT_TO_FLOAT(*src++) : 1.0;
		  }
	       }
	       break;
	    case GL_FLOAT:
	       {
		  float *src = (float *) pixels + i * width * components;
		  for (j=0;j<width;j++) {
		     if (l_flag) {
			rf[j] = gf[j] = bf[j] = *src++;
		     }
		     else {
			rf[j] = r_flag ? *src++ : 0.0;
			gf[j] = g_flag ? *src++ : 0.0;
			bf[j] = b_flag ? *src++ : 0.0;
		     }
		     af[j] = a_flag ? *src++ : 1.0;
		  }
	       }
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glDrawPixels" );
	       return;
	 }
	
	 if (scale_or_bias) {
	    for (j=0;j<width;j++) {
	       float r, g, b, a;
	       r = rf[j] * ctx->Pixel.RedScale   + ctx->Pixel.RedBias;
	       g = gf[j] * ctx->Pixel.GreenScale + ctx->Pixel.GreenBias;
	       b = bf[j] * ctx->Pixel.BlueScale  + ctx->Pixel.BlueBias;
	       a = af[j] * ctx->Pixel.AlphaScale + ctx->Pixel.AlphaBias;
	       rf[j] = CLAMP( r, 0.0, 1.0 );
	       gf[j] = CLAMP( g, 0.0, 1.0 );
	       bf[j] = CLAMP( b, 0.0, 1.0 );
	       af[j] = CLAMP( a, 0.0, 1.0 );
	    }
	 }
	
	 if (ctx->Pixel.MapColorFlag) {
float rscale = ctx->Pixel.MapRtoRsize-1;
float gscale = ctx->Pixel.MapGtoGsize-1;
float bscale = ctx->Pixel.MapBtoBsize-1;
float ascale = ctx->Pixel.MapAtoAsize-1;
	    for (j=0;j<width;j++) {
	       rf[j] = ctx->Pixel.MapRtoR[ (GLint) (rf[j] * rscale) ];
	       gf[j] = ctx->Pixel.MapGtoG[ (GLint) (gf[j] * gscale) ];
	       bf[j] = ctx->Pixel.MapBtoB[ (GLint) (bf[j] * bscale) ];
	       af[j] = ctx->Pixel.MapAtoA[ (GLint) (af[j] * ascale) ];
	    }
	 }
	
	 for (j=0;j<width;j++) {
	    red[j]   = (GLint) (rf[j] * ctx->Visual->RedScale);
	    green[j] = (GLint) (gf[j] * ctx->Visual->GreenScale);
	    blue[j]  = (GLint) (bf[j] * ctx->Visual->BlueScale);
	    alpha[j] = (GLint) (af[j] * ctx->Visual->AlphaScale);
	 }
	
if (quick_draw) {
(*ctx->Driver.WriteColorSpan)( ctx, width, x, y,
red, green, blue, alpha, NULL);
}
else if (zoom) {
gl_write_zoomed_color_span( ctx, width, x, y, zspan,
red, green, blue, alpha, desty );
}
else {
gl_write_color_span( ctx, (GLuint) width, x, y, zspan,
red, green, blue, alpha, GL_BITMAP );
}
UNDEFARRAY(rf);
UNDEFARRAY(gf);
UNDEFARRAY(bf);
UNDEFARRAY(af);
UNDEFARRAY(red);
UNDEFARRAY(green);
UNDEFARRAY(blue);
UNDEFARRAY(alpha);
}
}
}
static GLboolean quickdraw_rgb( GLcontext* ctx, GLsizei width, GLsizei height,
const void *pixels )
{
DEFARRAY( GLubyte, red, MAX_WIDTH );
DEFARRAY( GLubyte, green, MAX_WIDTH );
DEFARRAY( GLubyte, blue, MAX_WIDTH );
DEFARRAY( GLubyte, alpha, MAX_WIDTH );
GLint i, j;
GLint x, y;
GLint bytes_per_row;
GLboolean result;
bytes_per_row = width * 3 + (width % ctx->Unpack.Alignment);
if (!ctx->Current.RasterPosValid) {
result = GL_TRUE;
}
else {
x = (GLint) (ctx->Current.RasterPos[0] + 0.5F);
y = (GLint) (ctx->Current.RasterPos[1] + 0.5F);
if (x<0 || y<0
|| x+width>ctx->Buffer->Width || y+height>ctx->Buffer->Height) {
result = GL_FALSE;
}
else {
for (j=0;j<width;j++) {
alpha[j] = (GLint) ctx->Visual->AlphaScale;
}
for (i=0;i<height;i++) {
GLubyte *src = (GLubyte *) pixels + i * bytes_per_row;
for (j=0;j<width;j++) {
red[j]   = *src++;
green[j] = *src++;
blue[j]  = *src++;
}
(*ctx->Driver.WriteColorSpan)( ctx, width, x, y+i,
red, green, blue, alpha, NULL);
}
result = GL_TRUE;
}
}
UNDEFARRAY( red );
UNDEFARRAY( green );
UNDEFARRAY( blue );
UNDEFARRAY( alpha );
return result;
}
static void drawpixels( GLcontext* ctx, GLsizei width, GLsizei height,
GLenum format, GLenum type, const GLvoid *pixels )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glDrawPixels" );
return;
}
if (ctx->RenderMode==GL_RENDER) {
if (!ctx->Current.RasterPosValid) {
	 return;
}
switch (format) {
	 case GL_COLOR_INDEX:
draw_index_pixels( ctx, width, height, type, pixels );
	    break;
	 case GL_STENCIL_INDEX:
	    draw_stencil_pixels( ctx, width, height, type, pixels );
	    break;
	 case GL_DEPTH_COMPONENT:
	    draw_depth_pixels( ctx, width, height, type, pixels );
	    break;
	 case GL_RED:
	 case GL_GREEN:
	 case GL_BLUE:
	 case GL_ALPHA:
	 case GL_RGB:
	 case GL_LUMINANCE:
	 case GL_LUMINANCE_ALPHA:
	 case GL_RGBA:
draw_color_pixels( ctx, width, height, format, type, pixels );
	    break;
	 default:
	    gl_error( ctx, GL_INVALID_ENUM, "glDrawPixels" );
}
}
else if (ctx->RenderMode==GL_FEEDBACK) {
if (ctx->Current.RasterPosValid) {
float color[4], texcoord[4], invq;
color[0] = ctx->Current.ByteColor[0] * ctx->Visual->InvRedScale;
color[1] = ctx->Current.ByteColor[1] * ctx->Visual->InvGreenScale;
color[2] = ctx->Current.ByteColor[2] * ctx->Visual->InvBlueScale;
color[3] = ctx->Current.ByteColor[3] * ctx->Visual->InvAlphaScale;
invq = 1.0F / ctx->Current.TexCoord[3];
texcoord[0] = ctx->Current.TexCoord[0] * invq;
texcoord[1] = ctx->Current.TexCoord[1] * invq;
texcoord[2] = ctx->Current.TexCoord[2] * invq;
texcoord[3] = ctx->Current.TexCoord[3];
FEEDBACK_TOKEN( ctx, (float) GL_DRAW_PIXEL_TOKEN );
gl_feedback_vertex( ctx, ctx->Current.RasterPos[0],
ctx->Current.RasterPos[1],
ctx->Current.RasterPos[2],
ctx->Current.RasterPos[3],
color, ctx->Current.Index, texcoord );
}
}
else if (ctx->RenderMode==GL_SELECT) {
if (ctx->Current.RasterPosValid) {
gl_update_hitflag( ctx, ctx->Current.RasterPos[2] );
}
}
}
void gl_DrawPixels( GLcontext* ctx, GLsizei width, GLsizei height,
GLenum format, GLenum type, const GLvoid *pixels )
{
GLvoid *image;
if (width<0 || height<0) {
gl_error( ctx, GL_INVALID_VALUE, "glDrawPixels" );
return;
}
if (ctx->NewState) {
gl_update_state(ctx);
}
if (!ctx->CompileFlag && ctx->Driver.DrawPixels) {
GLint x = (GLint) (ctx->Current.RasterPos[0] + 0.5F);
GLint y = (GLint) (ctx->Current.RasterPos[1] + 0.5F);
if ((*ctx->Driver.DrawPixels)( ctx, x, y, width, height,
format, type, GL_FALSE, pixels )) {
return;
}
}
if (format==GL_RGB && type==GL_UNSIGNED_BYTE && ctx->FastDrawPixels
&& !ctx->CompileFlag && ctx->RenderMode==GL_RENDER
&& ctx->RasterMask==0 && ctx->CallDepth==0) {
if (quickdraw_rgb( ctx, width, height, pixels )) {
return;
}
}
if (ctx->CallDepth == 0) {
image = gl_unpack_pixels( ctx, width, height, format, type, pixels );
if (!image) {
gl_error( ctx, GL_OUT_OF_MEMORY, "glDrawPixels" );
return;
}
}
else {
image = (GLvoid *) pixels;
}
if (ctx->CompileFlag) {
gl_save_DrawPixels( ctx, width, height, format, type, image );
}
if (ctx->ExecuteFlag) {
drawpixels( ctx, width, height, format, type, image );
if (!ctx->CompileFlag) {
if (image!=pixels)
free( image );
}
}
}
/* 当前文件是D:\Read\enable.c*/

#ifdef PC_HEADER
#else
#endif
static void gl_enable( GLcontext* ctx, GLenum cap, GLboolean state )
{
GLuint p;
if (INSIDE_BEGIN_END(ctx)) {
if (state) {
	 gl_error( ctx, GL_INVALID_OPERATION, "glEnable" );
}
else {
	 gl_error( ctx, GL_INVALID_OPERATION, "glDisable" );
}
return;
}
switch (cap) {
case GL_ALPHA_TEST:
if (ctx->Color.AlphaEnabled!=state) {
ctx->Color.AlphaEnabled = state;
ctx->NewState |= NEW_RASTER_OPS;
}
	 break;
case GL_AUTO_NORMAL:
	 ctx->Eval.AutoNormal = state;
	 break;
case GL_BLEND:
if (ctx->Color.BlendEnabled!=state) {
ctx->Color.BlendEnabled = state;
if (ctx->Color.BlendEquation==GL_LOGIC_OP && state) {
ctx->Color.ColorLogicOpEnabled = GL_TRUE;
}
else {
ctx->Color.ColorLogicOpEnabled = GL_FALSE;
}
ctx->NewState |= NEW_RASTER_OPS;
}
	 break;
case GL_CLIP_PLANE0:
case GL_CLIP_PLANE1:
case GL_CLIP_PLANE2:
case GL_CLIP_PLANE3:
case GL_CLIP_PLANE4:
case GL_CLIP_PLANE5:
	 ctx->Transform.ClipEnabled[cap-GL_CLIP_PLANE0] = state;
	
ctx->Transform.AnyClip = GL_FALSE;
for (p=0;p<MAX_CLIP_PLANES;p++) {
if (ctx->Transform.ClipEnabled[p]) {
ctx->Transform.AnyClip = GL_TRUE;
break;
}
}
	 break;
case GL_COLOR_MATERIAL:
if (ctx->Light.ColorMaterialEnabled!=state) {
ctx->Light.ColorMaterialEnabled = state;
if (state) {
float color[4];
color[0] = ctx->Current.ByteColor[0] * ctx->Visual->InvRedScale;
color[1] = ctx->Current.ByteColor[1] * ctx->Visual->InvGreenScale;
color[2] = ctx->Current.ByteColor[2] * ctx->Visual->InvBlueScale;
color[3] = ctx->Current.ByteColor[3] * ctx->Visual->InvAlphaScale;
gl_set_material( ctx, ctx->Light.ColorMaterialBitmask, color );
}
gl_set_color_function(ctx);
ctx->NewState |= NEW_LIGHTING;
}
	 break;
case GL_CULL_FACE:
if (ctx->Polygon.CullFlag!=state) {
ctx->Polygon.CullFlag = state;
ctx->NewState |= NEW_POLYGON;
}
	 break;
case GL_DEPTH_TEST:
if (state && ctx->Visual->DepthBits==0) {
gl_warning(ctx,"glEnable(GL_DEPTH_TEST) but no depth buffer");
return;
}
	 if (ctx->Depth.Test!=state) {
ctx->Depth.Test = state;
ctx->NewState |= NEW_RASTER_OPS;
}
break;
case GL_DITHER:
if (ctx->NoDither) {
state = GL_FALSE;
}
if (ctx->Color.DitherFlag!=state) {
ctx->Color.DitherFlag = state;
ctx->NewState |= NEW_RASTER_OPS;
}
	 break;
case GL_FOG:
	 if (ctx->Fog.Enabled!=state) {
ctx->Fog.Enabled = state;
ctx->NewState |= NEW_RASTER_OPS;
}
	 break;
case GL_LIGHT0:
case GL_LIGHT1:
case GL_LIGHT2:
case GL_LIGHT3:
case GL_LIGHT4:
case GL_LIGHT5:
case GL_LIGHT6:
case GL_LIGHT7:
ctx->Light.Light[cap-GL_LIGHT0].Enabled = state;
ctx->NewState |= NEW_LIGHTING;
break;
case GL_LIGHTING:
if (ctx->Light.Enabled!=state) {
ctx->Light.Enabled = state;
ctx->NewState |= NEW_LIGHTING;
}
break;
case GL_LINE_SMOOTH:
	 if (ctx->Line.SmoothFlag!=state) {
ctx->Line.SmoothFlag = state;
ctx->NewState |= NEW_RASTER_OPS;
}
	 break;
case GL_LINE_STIPPLE:
	 if (ctx->Line.StippleFlag!=state) {
ctx->Line.StippleFlag = state;
ctx->NewState |= NEW_RASTER_OPS;
}
	 break;
case GL_INDEX_LOGIC_OP:
if (ctx->Color.IndexLogicOpEnabled!=state) {
ctx->NewState |= NEW_RASTER_OPS;
}
	 ctx->Color.IndexLogicOpEnabled = state;
	 break;
case GL_COLOR_LOGIC_OP:
if (ctx->Color.ColorLogicOpEnabled!=state) {
ctx->NewState |= NEW_RASTER_OPS;
}
	 ctx->Color.ColorLogicOpEnabled = state;
	 break;
case GL_MAP1_COLOR_4:
	 ctx->Eval.Map1Color4 = state;
	 break;
case GL_MAP1_INDEX:
	 ctx->Eval.Map1Index = state;
	 break;
case GL_MAP1_NORMAL:
	 ctx->Eval.Map1Normal = state;
	 break;
case GL_MAP1_TEXTURE_COORD_1:
	 ctx->Eval.Map1TextureCoord1 = state;
	 break;
case GL_MAP1_TEXTURE_COORD_2:
	 ctx->Eval.Map1TextureCoord2 = state;
	 break;
case GL_MAP1_TEXTURE_COORD_3:
	 ctx->Eval.Map1TextureCoord3 = state;
	 break;
case GL_MAP1_TEXTURE_COORD_4:
	 ctx->Eval.Map1TextureCoord4 = state;
	 break;
case GL_MAP1_VERTEX_3:
	 ctx->Eval.Map1Vertex3 = state;
	 break;
case GL_MAP1_VERTEX_4:
	 ctx->Eval.Map1Vertex4 = state;
	 break;
case GL_MAP2_COLOR_4:
	 ctx->Eval.Map2Color4 = state;
	 break;
case GL_MAP2_INDEX:
	 ctx->Eval.Map2Index = state;
	 break;
case GL_MAP2_NORMAL:
	 ctx->Eval.Map2Normal = state;
	 break;
case GL_MAP2_TEXTURE_COORD_1:
	 ctx->Eval.Map2TextureCoord1 = state;
	 break;
case GL_MAP2_TEXTURE_COORD_2:
	 ctx->Eval.Map2TextureCoord2 = state;
	 break;
case GL_MAP2_TEXTURE_COORD_3:
	 ctx->Eval.Map2TextureCoord3 = state;
	 break;
case GL_MAP2_TEXTURE_COORD_4:
	 ctx->Eval.Map2TextureCoord4 = state;
	 break;
case GL_MAP2_VERTEX_3:
	 ctx->Eval.Map2Vertex3 = state;
	 break;
case GL_MAP2_VERTEX_4:
	 ctx->Eval.Map2Vertex4 = state;
	 break;
case GL_NORMALIZE:
	 ctx->Transform.Normalize = state;
	 break;
case GL_POINT_SMOOTH:
	 if (ctx->Point.SmoothFlag!=state) {
ctx->Point.SmoothFlag = state;
ctx->NewState |= NEW_RASTER_OPS;
}
	 break;
case GL_POLYGON_SMOOTH:
	 if (ctx->Polygon.SmoothFlag!=state) {
ctx->Polygon.SmoothFlag = state;
ctx->NewState |= NEW_RASTER_OPS;
}
	 break;
case GL_POLYGON_STIPPLE:
	 if (ctx->Polygon.StippleFlag!=state) {
ctx->Polygon.StippleFlag = state;
ctx->NewState |= NEW_RASTER_OPS;
}
	 break;
case GL_POLYGON_OFFSET_POINT:
if (ctx->Polygon.OffsetPoint!=state) {
ctx->Polygon.OffsetPoint = state;
ctx->NewState |= NEW_POLYGON;
}
break;
case GL_POLYGON_OFFSET_LINE:
if (ctx->Polygon.OffsetLine!=state) {
ctx->Polygon.OffsetLine = state;
ctx->NewState |= NEW_POLYGON;
}
break;
case GL_POLYGON_OFFSET_FILL:
if (ctx->Polygon.OffsetFill!=state) {
ctx->Polygon.OffsetFill = state;
ctx->NewState |= NEW_POLYGON;
}
break;
case GL_SCISSOR_TEST:
if (ctx->Scissor.Enabled!=state) {
ctx->Scissor.Enabled = state;
ctx->NewState |= NEW_RASTER_OPS;
}
	 break;
case GL_SHARED_TEXTURE_PALETTE_EXT:
ctx->Texture.SharedPalette = state;
if (ctx->Driver.UseGlobalTexturePalette)
(*ctx->Driver.UseGlobalTexturePalette)( ctx, state );
break;
case GL_STENCIL_TEST:
	 if (state && ctx->Visual->StencilBits==0) {
gl_warning(ctx, "glEnable(GL_STENCIL_TEST) but no stencil buffer");
return;
	 }
	 if (ctx->Stencil.Enabled!=state) {
ctx->Stencil.Enabled = state;
ctx->NewState |= NEW_RASTER_OPS;
}
	 break;
case GL_TEXTURE_1D:
if (ctx->Visual->RGBAflag) {
if (state) {
ctx->Texture.Enabled |= TEXTURE_1D;
}
else {
ctx->Texture.Enabled &= (~TEXTURE_1D);
}
ctx->NewState |= (NEW_RASTER_OPS | NEW_TEXTURING);
}
	 break;
case GL_TEXTURE_2D:
if (ctx->Visual->RGBAflag) {
if (state) {
ctx->Texture.Enabled |= TEXTURE_2D;
}
else {
ctx->Texture.Enabled &= (~TEXTURE_2D);
}
ctx->NewState |= (NEW_RASTER_OPS | NEW_TEXTURING);
}
	 break;
case GL_TEXTURE_3D_EXT:
if (ctx->Visual->RGBAflag) {
if (state) {
ctx->Texture.Enabled |= TEXTURE_3D;
}
else {
ctx->Texture.Enabled &= (~TEXTURE_3D);
}
ctx->NewState |= (NEW_RASTER_OPS | NEW_TEXTURING);
}
break;
case GL_TEXTURE_GEN_Q:
if (state) {
ctx->Texture.TexGenEnabled |= Q_BIT;
}
else {
ctx->Texture.TexGenEnabled &= ~Q_BIT;
}
ctx->NewState |= NEW_TEXTURING;
	 break;
case GL_TEXTURE_GEN_R:
if (state) {
ctx->Texture.TexGenEnabled |= R_BIT;
}
else {
ctx->Texture.TexGenEnabled &= ~R_BIT;
}
ctx->NewState |= NEW_TEXTURING;
	 break;
case GL_TEXTURE_GEN_S:
	 if (state) {
ctx->Texture.TexGenEnabled |= S_BIT;
}
else {
ctx->Texture.TexGenEnabled &= ~S_BIT;
}
ctx->NewState |= NEW_TEXTURING;
	 break;
case GL_TEXTURE_GEN_T:
if (state) {
ctx->Texture.TexGenEnabled |= T_BIT;
}
else {
ctx->Texture.TexGenEnabled &= ~T_BIT;
}
ctx->NewState |= NEW_TEXTURING;
	 break;
case GL_VERTEX_ARRAY:
ctx->Array.VertexEnabled = state;
break;
case GL_NORMAL_ARRAY:
ctx->Array.NormalEnabled = state;
break;
case GL_COLOR_ARRAY:
ctx->Array.ColorEnabled = state;
break;
case GL_INDEX_ARRAY:
ctx->Array.IndexEnabled = state;
break;
case GL_TEXTURE_COORD_ARRAY:
ctx->Array.TexCoordEnabled = state;
break;
case GL_EDGE_FLAG_ARRAY:
ctx->Array.EdgeFlagEnabled = state;
break;
default:
	 if (state) {
	    gl_error( ctx, GL_INVALID_ENUM, "glEnable" );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glDisable" );
	 }
break;
}
}
void gl_Enable( GLcontext* ctx, GLenum cap )
{
gl_enable( ctx, cap, GL_TRUE );
}
void gl_Disable( GLcontext* ctx, GLenum cap )
{
gl_enable( ctx, cap, GL_FALSE );
}
GLboolean gl_IsEnabled( GLcontext* ctx, GLenum cap )
{
switch (cap) {
case GL_ALPHA_TEST:
return ctx->Color.AlphaEnabled;
case GL_AUTO_NORMAL:
	 return ctx->Eval.AutoNormal;
case GL_BLEND:
return ctx->Color.BlendEnabled;
case GL_CLIP_PLANE0:
case GL_CLIP_PLANE1:
case GL_CLIP_PLANE2:
case GL_CLIP_PLANE3:
case GL_CLIP_PLANE4:
case GL_CLIP_PLANE5:
	 return ctx->Transform.ClipEnabled[cap-GL_CLIP_PLANE0];
case GL_COLOR_MATERIAL:
	 return ctx->Light.ColorMaterialEnabled;
case GL_CULL_FACE:
return ctx->Polygon.CullFlag;
case GL_DEPTH_TEST:
return ctx->Depth.Test;
case GL_DITHER:
	 return ctx->Color.DitherFlag;
case GL_FOG:
	 return ctx->Fog.Enabled;
case GL_LIGHTING:
return ctx->Light.Enabled;
case GL_LIGHT0:
case GL_LIGHT1:
case GL_LIGHT2:
case GL_LIGHT3:
case GL_LIGHT4:
case GL_LIGHT5:
case GL_LIGHT6:
case GL_LIGHT7:
return ctx->Light.Light[cap-GL_LIGHT0].Enabled;
case GL_LINE_SMOOTH:
	 return ctx->Line.SmoothFlag;
case GL_LINE_STIPPLE:
	 return ctx->Line.StippleFlag;
case GL_INDEX_LOGIC_OP:
	 return ctx->Color.IndexLogicOpEnabled;
case GL_COLOR_LOGIC_OP:
	 return ctx->Color.ColorLogicOpEnabled;
case GL_MAP1_COLOR_4:
	 return ctx->Eval.Map1Color4;
case GL_MAP1_INDEX:
	 return ctx->Eval.Map1Index;
case GL_MAP1_NORMAL:
	 return ctx->Eval.Map1Normal;
case GL_MAP1_TEXTURE_COORD_1:
	 return ctx->Eval.Map1TextureCoord1;
case GL_MAP1_TEXTURE_COORD_2:
	 return ctx->Eval.Map1TextureCoord2;
case GL_MAP1_TEXTURE_COORD_3:
	 return ctx->Eval.Map1TextureCoord3;
case GL_MAP1_TEXTURE_COORD_4:
	 return ctx->Eval.Map1TextureCoord4;
case GL_MAP1_VERTEX_3:
	 return ctx->Eval.Map1Vertex3;
case GL_MAP1_VERTEX_4:
	 return ctx->Eval.Map1Vertex4;
case GL_MAP2_COLOR_4:
	 return ctx->Eval.Map2Color4;
case GL_MAP2_INDEX:
	 return ctx->Eval.Map2Index;
case GL_MAP2_NORMAL:
	 return ctx->Eval.Map2Normal;
case GL_MAP2_TEXTURE_COORD_1:
	 return ctx->Eval.Map2TextureCoord1;
case GL_MAP2_TEXTURE_COORD_2:
	 return ctx->Eval.Map2TextureCoord2;
case GL_MAP2_TEXTURE_COORD_3:
	 return ctx->Eval.Map2TextureCoord3;
case GL_MAP2_TEXTURE_COORD_4:
	 return ctx->Eval.Map2TextureCoord4;
case GL_MAP2_VERTEX_3:
	 return ctx->Eval.Map2Vertex3;
case GL_MAP2_VERTEX_4:
	 return ctx->Eval.Map2Vertex4;
case GL_NORMALIZE:
	 return ctx->Transform.Normalize;
case GL_POINT_SMOOTH:
	 return ctx->Point.SmoothFlag;
case GL_POLYGON_SMOOTH:
	 return ctx->Polygon.SmoothFlag;
case GL_POLYGON_STIPPLE:
	 return ctx->Polygon.StippleFlag;
case GL_POLYGON_OFFSET_POINT:
	 return ctx->Polygon.OffsetPoint;
case GL_POLYGON_OFFSET_LINE:
	 return ctx->Polygon.OffsetLine;
case GL_POLYGON_OFFSET_FILL:
	 return ctx->Polygon.OffsetFill;
case GL_SCISSOR_TEST:
	 return ctx->Scissor.Enabled;
case GL_SHARED_TEXTURE_PALETTE_EXT:
return ctx->Texture.SharedPalette;
break;
case GL_STENCIL_TEST:
	 return ctx->Stencil.Enabled;
case GL_TEXTURE_1D:
	 return (ctx->Texture.Enabled & TEXTURE_1D) ? GL_TRUE : GL_FALSE;
case GL_TEXTURE_2D:
	 return (ctx->Texture.Enabled & TEXTURE_2D) ? GL_TRUE : GL_FALSE;
case GL_TEXTURE_3D_EXT:
return (ctx->Texture.Enabled & TEXTURE_3D) ? GL_TRUE : GL_FALSE;
case GL_TEXTURE_GEN_Q:
	 return (ctx->Texture.TexGenEnabled & Q_BIT) ? GL_TRUE : GL_FALSE;
case GL_TEXTURE_GEN_R:
	 return (ctx->Texture.TexGenEnabled & R_BIT) ? GL_TRUE : GL_FALSE;
case GL_TEXTURE_GEN_S:
	 return (ctx->Texture.TexGenEnabled & S_BIT) ? GL_TRUE : GL_FALSE;
case GL_TEXTURE_GEN_T:
	 return (ctx->Texture.TexGenEnabled & T_BIT) ? GL_TRUE : GL_FALSE;
case GL_VERTEX_ARRAY:
return ctx->Array.VertexEnabled;
case GL_NORMAL_ARRAY:
return ctx->Array.NormalEnabled;
case GL_COLOR_ARRAY:
return ctx->Array.ColorEnabled;
case GL_INDEX_ARRAY:
return ctx->Array.IndexEnabled;
case GL_TEXTURE_COORD_ARRAY:
return ctx->Array.TexCoordEnabled;
case GL_EDGE_FLAG_ARRAY:
return ctx->Array.EdgeFlagEnabled;
default:
	 gl_error( ctx, GL_INVALID_ENUM, "glIsEnabled" );
	 return GL_FALSE;
}
}
void gl_client_state( GLcontext *ctx, GLenum cap, GLboolean state )
{
switch (cap) {
case GL_VERTEX_ARRAY:
ctx->Array.VertexEnabled = state;
break;
case GL_NORMAL_ARRAY:
ctx->Array.NormalEnabled = state;
break;
case GL_COLOR_ARRAY:
ctx->Array.ColorEnabled = state;
break;
case GL_INDEX_ARRAY:
ctx->Array.IndexEnabled = state;
break;
case GL_TEXTURE_COORD_ARRAY:
ctx->Array.TexCoordEnabled = state;
break;
case GL_EDGE_FLAG_ARRAY:
ctx->Array.EdgeFlagEnabled = state;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glEnable/DisableClientState" );
}
}
void gl_EnableClientState( GLcontext *ctx, GLenum cap )
{
gl_client_state( ctx, cap, GL_TRUE );
}
void gl_DisableClientState( GLcontext *ctx, GLenum cap )
{
gl_client_state( ctx, cap, GL_FALSE );
}
/* 当前文件是D:\Read\eval.c*/

#ifdef PC_HEADER
#else
#endif
void gl_init_eval( void )
{
static int init_flag = 0;
if (init_flag==0)
{
}
init_flag = 1;
}
static void
horner_bezier_curve(float *cp, float *out, float t,
GLuint dim, GLuint order)
{
float s, powert;
GLuint i, k, bincoeff;
if(order >= 2)
{
bincoeff = order-1;
s = 1.0-t;
for(k=0; k<dim; k++)
out[k] = s*cp[k] + bincoeff*t*cp[dim+k];
for(i=2, cp+=2*dim, powert=t*t; i<order; i++, powert*=t, cp +=dim)
{
bincoeff *= order-i;
bincoeff /= i;
for(k=0; k<dim; k++)
out[k] = s*out[k] + bincoeff*powert*cp[k];
}
}
else
{
for(k=0; k<dim; k++)
out[k] = cp[k];
}
}
static void
horner_bezier_surf(float *cn, float *out, float u, float v,
GLuint dim, GLuint uorder, GLuint vorder)
{
float *cp = cn + uorder*vorder*dim;
GLuint i, uinc = vorder*dim;
if(vorder > uorder)
{
if(uorder >= 2)
{
float s, poweru;
GLuint j, k, bincoeff;
for(j=0; j<vorder; j++)
{
float *ucp = &cn[j*dim];
	bincoeff = uorder-1;
	s = 1.0-u;
	for(k=0; k<dim; k++)
	  cp[j*dim+k] = s*ucp[k] + bincoeff*u*ucp[uinc+k];
	for(i=2, ucp+=2*uinc, poweru=u*u; i<uorder;
i++, poweru*=u, ucp +=uinc)
	{
	  bincoeff *= uorder-i;
bincoeff /= i;
	  for(k=0; k<dim; k++)
	    cp[j*dim+k] = s*cp[j*dim+k] + bincoeff*poweru*ucp[k];
	}
}
horner_bezier_curve(cp, out, v, dim, vorder);
}
else
horner_bezier_curve(cn, out, v, dim, vorder);
}
else
{
if(vorder > 1)
{
GLuint i;
for(i=0; i<uorder; i++, cn += uinc)
{
	
	
	
	horner_bezier_curve(cn, &cp[i*dim], v, dim, vorder);
}
horner_bezier_curve(cp, out, u, dim, uorder);
}
else
horner_bezier_curve(cn, out, u, dim, uorder);
}
}
static void
de_casteljau_surf(float *cn, float *out, float *du, float *dv,
float u, float v, GLuint dim,
GLuint uorder, GLuint vorder)
{
float *dcn = cn + uorder*vorder*dim;
float us = 1.0-u, vs = 1.0-v;
GLuint h, i, j, k;
GLuint minorder = uorder < vorder ? uorder : vorder;
GLuint uinc = vorder*dim;
GLuint dcuinc = vorder;
#define CN(I,J,K) cn[(I)*uinc+(J)*dim+(K)]
#define DCN(I, J) dcn[(I)*dcuinc+(J)]
if(minorder < 3)
{
if(uorder==vorder)
{
for(k=0; k<dim; k++)
{
	
	du[k] = vs*(CN(1,0,k) - CN(0,0,k)) +
	         v*(CN(1,1,k) - CN(0,1,k));
	
	dv[k] = us*(CN(0,1,k) - CN(0,0,k)) +
	         u*(CN(1,1,k) - CN(1,0,k));
	
out[k] =  us*(vs*CN(0,0,k) + v*CN(0,1,k)) +
	           u*(vs*CN(1,0,k) + v*CN(1,1,k));
}
}
else if(minorder == uorder)
{
for(k=0; k<dim; k++)
{
	
	DCN(1,0) =    CN(1,0,k) -   CN(0,0,k);
	DCN(0,0) = us*CN(0,0,k) + u*CN(1,0,k);
	for(j=0; j<vorder-1; j++)
	{
	
	  DCN(1,j+1) =    CN(1,j+1,k) -   CN(0,j+1,k);
	  DCN(1,j)   = vs*DCN(1,j)    + v*DCN(1,j+1);
	
	  DCN(0,j+1) = us*CN(0,j+1,k) + u*CN(1,j+1,k);
	  DCN(0,j)   = vs*DCN(0,j)    + v*DCN(0,j+1);
	}
	
	for(h=minorder; h<vorder-1; h++)
	  for(j=0; j<vorder-h; j++)
	  {
	
	    DCN(1,j) = vs*DCN(1,j) + v*DCN(1,j+1);
	
	    DCN(0,j) = vs*DCN(0,j) + v*DCN(0,j+1);
	  }
	
	dv[k] = DCN(0,1) - DCN(0,0);
	
	du[k] =   vs*DCN(1,0) + v*DCN(1,1);
	
	out[k] =  vs*DCN(0,0) + v*DCN(0,1);
}
}
else
{
for(k=0; k<dim; k++)
{
	
	DCN(0,1) =    CN(0,1,k) -   CN(0,0,k);
	DCN(0,0) = vs*CN(0,0,k) + v*CN(0,1,k);
	for(i=0; i<uorder-1; i++)
	{
	
	  DCN(i+1,1) =    CN(i+1,1,k) -   CN(i+1,0,k);
	  DCN(i,1)   = us*DCN(i,1)    + u*DCN(i+1,1);
	
	  DCN(i+1,0) = vs*CN(i+1,0,k) + v*CN(i+1,1,k);
	  DCN(i,0)   = us*DCN(i,0)    + u*DCN(i+1,0);
	}
	
	for(h=minorder; h<uorder-1; h++)
	  for(i=0; i<uorder-h; i++)
	  {
	
	    DCN(i,1) = us*DCN(i,1) + u*DCN(i+1,1);
	
	    DCN(i,0) = us*DCN(i,0) + u*DCN(i+1,0);
	  }
	
	du[k] = DCN(1,0) - DCN(0,0);
	
	dv[k] =   us*DCN(0,1) + u*DCN(1,1);
	
	out[k] =  us*DCN(0,0) + u*DCN(1,0);
}
}
}
else if(uorder == vorder)
{
for(k=0; k<dim; k++)
{
for(i=0; i<uorder-1; i++)
{
	DCN(i,0) = us*CN(i,0,k) + u*CN(i+1,0,k);
	for(j=0; j<vorder-1; j++)
	{
	  DCN(i,j+1) = us*CN(i,j+1,k) + u*CN(i+1,j+1,k);
	  DCN(i,j)   = vs*DCN(i,j)    + v*DCN(i,j+1);
	}
}
for(h=2; h<minorder-1; h++)
	for(i=0; i<uorder-h; i++)
	{
	  DCN(i,0) = us*DCN(i,0) + u*DCN(i+1,0);
	  for(j=0; j<vorder-h; j++)
	  {
	    DCN(i,j+1) = us*DCN(i,j+1) + u*DCN(i+1,j+1);
	    DCN(i,j)   = vs*DCN(i,j)   + v*DCN(i,j+1);
	  }
	}
du[k] = vs*(DCN(1,0) - DCN(0,0)) +
	       v*(DCN(1,1) - DCN(0,1));
dv[k] = us*(DCN(0,1) - DCN(0,0)) +
	       u*(DCN(1,1) - DCN(1,0));
out[k] =  us*(vs*DCN(0,0) + v*DCN(0,1)) +
	         u*(vs*DCN(1,0) + v*DCN(1,1));
}
}
else if(minorder == uorder)
{
for(k=0; k<dim; k++)
{
for(i=0; i<uorder-1; i++)
{
	DCN(i,0) = us*CN(i,0,k) + u*CN(i+1,0,k);
	for(j=0; j<vorder-1; j++)
	{
	  DCN(i,j+1) = us*CN(i,j+1,k) + u*CN(i+1,j+1,k);
	  DCN(i,j)   = vs*DCN(i,j)    + v*DCN(i,j+1);
	}
}
for(h=2; h<minorder-1; h++)
	for(i=0; i<uorder-h; i++)
	{
	  DCN(i,0) = us*DCN(i,0) + u*DCN(i+1,0);
	  for(j=0; j<vorder-h; j++)
	  {
	    DCN(i,j+1) = us*DCN(i,j+1) + u*DCN(i+1,j+1);
	    DCN(i,j)   = vs*DCN(i,j)   + v*DCN(i,j+1);
	  }
	}
DCN(2,0) =    DCN(1,0) -   DCN(0,0);
DCN(0,0) = us*DCN(0,0) + u*DCN(1,0);
for(j=0; j<vorder-1; j++)
{
	
	DCN(2,j+1) =    DCN(1,j+1) -    DCN(0,j+1);
	DCN(2,j)   = vs*DCN(2,j)    + v*DCN(2,j+1);
	
	
	DCN(0,j+1) = us*DCN(0,j+1 ) + u*DCN(1,j+1);
	DCN(0,j)   = vs*DCN(0,j)    + v*DCN(0,j+1);
}
for(h=minorder; h<vorder-1; h++)
	for(j=0; j<vorder-h; j++)
	{
	
	  DCN(2,j) = vs*DCN(2,j) + v*DCN(2,j+1);
	
	
	  DCN(0,j) = vs*DCN(0,j) + v*DCN(0,j+1);
	}
dv[k] = DCN(0,1) - DCN(0,0);
du[k] =   vs*DCN(2,0) + v*DCN(2,1);
out[k] =  vs*DCN(0,0) + v*DCN(0,1);
}
}
else
{
for(k=0; k<dim; k++)
{
for(i=0; i<uorder-1; i++)
{
	DCN(i,0) = us*CN(i,0,k) + u*CN(i+1,0,k);
	for(j=0; j<vorder-1; j++)
	{
	  DCN(i,j+1) = us*CN(i,j+1,k) + u*CN(i+1,j+1,k);
	  DCN(i,j)   = vs*DCN(i,j)    + v*DCN(i,j+1);
	}
}
for(h=2; h<minorder-1; h++)
	for(i=0; i<uorder-h; i++)
	{
	  DCN(i,0) = us*DCN(i,0) + u*DCN(i+1,0);
	  for(j=0; j<vorder-h; j++)
	  {
	    DCN(i,j+1) = us*DCN(i,j+1) + u*DCN(i+1,j+1);
	    DCN(i,j)   = vs*DCN(i,j)   + v*DCN(i,j+1);
	  }
	}
DCN(0,2) =    DCN(0,1) -   DCN(0,0);
DCN(0,0) = vs*DCN(0,0) + v*DCN(0,1);
for(i=0; i<uorder-1; i++)
{
	
	DCN(i+1,2) =    DCN(i+1,1)  -   DCN(i+1,0);
	DCN(i,2)   = us*DCN(i,2)    + u*DCN(i+1,2);
	
	
	DCN(i+1,0) = vs*DCN(i+1,0)  + v*DCN(i+1,1);
	DCN(i,0)   = us*DCN(i,0)    + u*DCN(i+1,0);
}
for(h=minorder; h<uorder-1; h++)
	for(i=0; i<uorder-h; i++)
	{
	
	  DCN(i,2) = us*DCN(i,2) + u*DCN(i+1,2);
	
	
	  DCN(i,0) = us*DCN(i,0) + u*DCN(i+1,0);
	}
du[k] = DCN(1,0) - DCN(0,0);
dv[k] =   us*DCN(0,2) + u*DCN(1,2);
out[k] =  us*DCN(0,0) + u*DCN(1,0);
}
}
#undef DCN
#undef CN
}
static GLint components( GLenum target )
{
switch (target) {
case GL_MAP1_VERTEX_3:		return 3;
case GL_MAP1_VERTEX_4:		return 4;
case GL_MAP1_INDEX:		return 1;
case GL_MAP1_COLOR_4:		return 4;
case GL_MAP1_NORMAL:		return 3;
case GL_MAP1_TEXTURE_COORD_1:	return 1;
case GL_MAP1_TEXTURE_COORD_2:	return 2;
case GL_MAP1_TEXTURE_COORD_3:	return 3;
case GL_MAP1_TEXTURE_COORD_4:	return 4;
case GL_MAP2_VERTEX_3:		return 3;
case GL_MAP2_VERTEX_4:		return 4;
case GL_MAP2_INDEX:		return 1;
case GL_MAP2_COLOR_4:		return 4;
case GL_MAP2_NORMAL:		return 3;
case GL_MAP2_TEXTURE_COORD_1:	return 1;
case GL_MAP2_TEXTURE_COORD_2:	return 2;
case GL_MAP2_TEXTURE_COORD_3:	return 3;
case GL_MAP2_TEXTURE_COORD_4:	return 4;
default:				return 0;
}
}
float *gl_copy_map_points1f( GLenum target,
GLint ustride, GLint uorder,
const float *points )
{
float *buffer, *p;
GLuint i, k, size = components(target);
if (!points || components==0) {
return NULL;
}
buffer = (float *) malloc(uorder * size * sizeof(float));
if(buffer)
for(i=0, p=buffer; i<uorder; i++, points+=ustride)
	for(k=0; k<size; k++)
	  *p++ = points[k];
return buffer;
}
float *gl_copy_map_points1d( GLenum target,
			        GLint ustride, GLint uorder,
			        const GLdouble *points )
{
float *buffer, *p;
GLuint i, k, size = components(target);
buffer = (float *) malloc(uorder * size * sizeof(float));
if(buffer)
for(i=0, p=buffer; i<uorder; i++, points+=ustride)
	for(k=0; k<size; k++)
	  *p++ = (float) points[k];
return buffer;
}
float *gl_copy_map_points2f( GLenum target,
			        GLint ustride, GLint uorder,
			        GLint vstride, GLint vorder,
			        const float *points )
{
float *buffer, *p;
GLuint i, j, k, size, dsize, hsize;
GLint uinc;
size = components(target);
dsize = (uorder == 2 && vorder == 2)? 0 : uorder*vorder;
hsize = (uorder > vorder ? uorder : vorder)*size;
if(hsize>dsize)
buffer = (float *) malloc((uorder*vorder*size+hsize)*sizeof(float));
else
buffer = (float *) malloc((uorder*vorder*size+dsize)*sizeof(float));
uinc = ustride - vorder*vstride;
if (buffer)
for (i=0, p=buffer; i<uorder; i++, points += uinc)
	 for (j=0; j<vorder; j++, points += vstride)
	    for (k=0; k<size; k++)
	       *p++ = points[k];
return buffer;
}
float *gl_copy_map_points2d(GLenum target,
GLint ustride, GLint uorder,
GLint vstride, GLint vorder,
const GLdouble *points )
{
float *buffer, *p;
GLuint i, j, k, size, hsize, dsize;
GLint uinc;
size = components(target);
dsize = (uorder == 2 && vorder == 2)? 0 : uorder*vorder;
hsize = (uorder > vorder ? uorder : vorder)*size;
if(hsize>dsize)
buffer = (float *) malloc((uorder*vorder*size+hsize)*sizeof(float));
else
buffer = (float *) malloc((uorder*vorder*size+dsize)*sizeof(float));
uinc = ustride - vorder*vstride;
if (buffer)
for (i=0, p=buffer; i<uorder; i++, points += uinc)
	 for (j=0; j<vorder; j++, points += vstride)
	    for (k=0; k<size; k++)
	       *p++ = (float) points[k];
return buffer;
}
void gl_free_control_points( GLcontext* ctx, GLenum target, float *data )
{
struct gl_1d_map *map1 = NULL;
struct gl_2d_map *map2 = NULL;
switch (target) {
case GL_MAP1_VERTEX_3:
map1 = &ctx->EvalMap.Map1Vertex3;
break;
case GL_MAP1_VERTEX_4:
map1 = &ctx->EvalMap.Map1Vertex4;
	 break;
case GL_MAP1_INDEX:
map1 = &ctx->EvalMap.Map1Index;
break;
case GL_MAP1_COLOR_4:
map1 = &ctx->EvalMap.Map1Color4;
break;
case GL_MAP1_NORMAL:
map1 = &ctx->EvalMap.Map1Normal;
	 break;
case GL_MAP1_TEXTURE_COORD_1:
map1 = &ctx->EvalMap.Map1Texture1;
	 break;
case GL_MAP1_TEXTURE_COORD_2:
map1 = &ctx->EvalMap.Map1Texture2;
	 break;
case GL_MAP1_TEXTURE_COORD_3:
map1 = &ctx->EvalMap.Map1Texture3;
	 break;
case GL_MAP1_TEXTURE_COORD_4:
map1 = &ctx->EvalMap.Map1Texture4;
	 break;
case GL_MAP2_VERTEX_3:
map2 = &ctx->EvalMap.Map2Vertex3;
	 break;
case GL_MAP2_VERTEX_4:
map2 = &ctx->EvalMap.Map2Vertex4;
	 break;
case GL_MAP2_INDEX:
map2 = &ctx->EvalMap.Map2Index;
	 break;
case GL_MAP2_COLOR_4:
map2 = &ctx->EvalMap.Map2Color4;
break;
case GL_MAP2_NORMAL:
map2 = &ctx->EvalMap.Map2Normal;
	 break;
case GL_MAP2_TEXTURE_COORD_1:
map2 = &ctx->EvalMap.Map2Texture1;
	 break;
case GL_MAP2_TEXTURE_COORD_2:
map2 = &ctx->EvalMap.Map2Texture2;
	 break;
case GL_MAP2_TEXTURE_COORD_3:
map2 = &ctx->EvalMap.Map2Texture3;
	 break;
case GL_MAP2_TEXTURE_COORD_4:
map2 = &ctx->EvalMap.Map2Texture4;
	 break;
default:
	 gl_error( ctx, GL_INVALID_ENUM, "gl_free_control_points" );
return;
}
if (map1) {
if (data==map1->Points) {
map1->Retain = GL_FALSE;
}
else {
free( data );
}
}
if (map2) {
if (data==map2->Points) {
map2->Retain = GL_FALSE;
}
else {
free( data );
}
}
}
void gl_Map1f( GLcontext* ctx, GLenum target,
float u1, float u2, GLint stride,
GLint order, const float *points, GLboolean retain )
{
GLuint k;
if (!points) {
gl_error( ctx, GL_OUT_OF_MEMORY, "glMap1f" );
return;
}
stride = components( target );
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glMap1" );
return;
}
if (u1==u2) {
gl_error( ctx, GL_INVALID_VALUE, "glMap1(u1,u2)" );
return;
}
if (order<1 || order>MAX_EVAL_ORDER) {
gl_error( ctx, GL_INVALID_VALUE, "glMap1(order)" );
return;
}
k = components( target );
if (k==0) {
gl_error( ctx, GL_INVALID_ENUM, "glMap1(target)" );
}
if (stride < k) {
gl_error( ctx, GL_INVALID_VALUE, "glMap1(stride)" );
return;
}
switch (target) {
case GL_MAP1_VERTEX_3:
ctx->EvalMap.Map1Vertex3.Order = order;
	 ctx->EvalMap.Map1Vertex3.u1 = u1;
	 ctx->EvalMap.Map1Vertex3.u2 = u2;
	 if (ctx->EvalMap.Map1Vertex3.Points
&& !ctx->EvalMap.Map1Vertex3.Retain) {
	    free( ctx->EvalMap.Map1Vertex3.Points );
	 }
	 ctx->EvalMap.Map1Vertex3.Points = (float *) points;
ctx->EvalMap.Map1Vertex3.Retain = retain;
	 break;
case GL_MAP1_VERTEX_4:
ctx->EvalMap.Map1Vertex4.Order = order;
	 ctx->EvalMap.Map1Vertex4.u1 = u1;
	 ctx->EvalMap.Map1Vertex4.u2 = u2;
	 if (ctx->EvalMap.Map1Vertex4.Points
&& !ctx->EvalMap.Map1Vertex4.Retain) {
	    free( ctx->EvalMap.Map1Vertex4.Points );
	 }
	 ctx->EvalMap.Map1Vertex4.Points = (float *) points;
	 ctx->EvalMap.Map1Vertex4.Retain = retain;
	 break;
case GL_MAP1_INDEX:
ctx->EvalMap.Map1Index.Order = order;
	 ctx->EvalMap.Map1Index.u1 = u1;
	 ctx->EvalMap.Map1Index.u2 = u2;
	 if (ctx->EvalMap.Map1Index.Points
&& !ctx->EvalMap.Map1Index.Retain) {
	    free( ctx->EvalMap.Map1Index.Points );
	 }
	 ctx->EvalMap.Map1Index.Points = (float *) points;
	 ctx->EvalMap.Map1Index.Retain = retain;
	 break;
case GL_MAP1_COLOR_4:
ctx->EvalMap.Map1Color4.Order = order;
	 ctx->EvalMap.Map1Color4.u1 = u1;
	 ctx->EvalMap.Map1Color4.u2 = u2;
	 if (ctx->EvalMap.Map1Color4.Points
&& !ctx->EvalMap.Map1Color4.Retain) {
	    free( ctx->EvalMap.Map1Color4.Points );
	 }
	 ctx->EvalMap.Map1Color4.Points = (float *) points;
	 ctx->EvalMap.Map1Color4.Retain = retain;
	 break;
case GL_MAP1_NORMAL:
ctx->EvalMap.Map1Normal.Order = order;
	 ctx->EvalMap.Map1Normal.u1 = u1;
	 ctx->EvalMap.Map1Normal.u2 = u2;
	 if (ctx->EvalMap.Map1Normal.Points
&& !ctx->EvalMap.Map1Normal.Retain) {
	    free( ctx->EvalMap.Map1Normal.Points );
	 }
	 ctx->EvalMap.Map1Normal.Points = (float *) points;
	 ctx->EvalMap.Map1Normal.Retain = retain;
	 break;
case GL_MAP1_TEXTURE_COORD_1:
ctx->EvalMap.Map1Texture1.Order = order;
	 ctx->EvalMap.Map1Texture1.u1 = u1;
	 ctx->EvalMap.Map1Texture1.u2 = u2;
	 if (ctx->EvalMap.Map1Texture1.Points
&& !ctx->EvalMap.Map1Texture1.Retain) {
	    free( ctx->EvalMap.Map1Texture1.Points );
	 }
	 ctx->EvalMap.Map1Texture1.Points = (float *) points;
	 ctx->EvalMap.Map1Texture1.Retain = retain;
	 break;
case GL_MAP1_TEXTURE_COORD_2:
ctx->EvalMap.Map1Texture2.Order = order;
	 ctx->EvalMap.Map1Texture2.u1 = u1;
	 ctx->EvalMap.Map1Texture2.u2 = u2;
	 if (ctx->EvalMap.Map1Texture2.Points
&& !ctx->EvalMap.Map1Texture2.Retain) {
	    free( ctx->EvalMap.Map1Texture2.Points );
	 }
	 ctx->EvalMap.Map1Texture2.Points = (float *) points;
	 ctx->EvalMap.Map1Texture2.Retain = retain;
	 break;
case GL_MAP1_TEXTURE_COORD_3:
ctx->EvalMap.Map1Texture3.Order = order;
	 ctx->EvalMap.Map1Texture3.u1 = u1;
	 ctx->EvalMap.Map1Texture3.u2 = u2;
	 if (ctx->EvalMap.Map1Texture3.Points
&& !ctx->EvalMap.Map1Texture3.Retain) {
	    free( ctx->EvalMap.Map1Texture3.Points );
	 }
	 ctx->EvalMap.Map1Texture3.Points = (float *) points;
	 ctx->EvalMap.Map1Texture3.Retain = retain;
	 break;
case GL_MAP1_TEXTURE_COORD_4:
ctx->EvalMap.Map1Texture4.Order = order;
	 ctx->EvalMap.Map1Texture4.u1 = u1;
	 ctx->EvalMap.Map1Texture4.u2 = u2;
	 if (ctx->EvalMap.Map1Texture4.Points
&& !ctx->EvalMap.Map1Texture4.Retain) {
	    free( ctx->EvalMap.Map1Texture4.Points );
	 }
	 ctx->EvalMap.Map1Texture4.Points = (float *) points;
	 ctx->EvalMap.Map1Texture4.Retain = retain;
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glMap1(target)" );
}
}
void gl_Map2f( GLcontext* ctx, GLenum target,
	      float u1, float u2, GLint ustride, GLint uorder,
	      float v1, float v2, GLint vstride, GLint vorder,
	      const float *points, GLboolean retain )
{
GLuint k;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glMap2" );
return;
}
if (u1==u2) {
gl_error( ctx, GL_INVALID_VALUE, "glMap2(u1,u2)" );
return;
}
if (v1==v2) {
gl_error( ctx, GL_INVALID_VALUE, "glMap2(v1,v2)" );
return;
}
if (uorder<1 || uorder>MAX_EVAL_ORDER) {
gl_error( ctx, GL_INVALID_VALUE, "glMap2(uorder)" );
return;
}
if (vorder<1 || vorder>MAX_EVAL_ORDER) {
gl_error( ctx, GL_INVALID_VALUE, "glMap2(vorder)" );
return;
}
k = components( target );
if (k==0) {
gl_error( ctx, GL_INVALID_ENUM, "glMap2(target)" );
}
if (ustride < k) {
gl_error( ctx, GL_INVALID_VALUE, "glMap2(ustride)" );
return;
}
if (vstride < k) {
gl_error( ctx, GL_INVALID_VALUE, "glMap2(vstride)" );
return;
}
switch (target) {
case GL_MAP2_VERTEX_3:
ctx->EvalMap.Map2Vertex3.Uorder = uorder;
	 ctx->EvalMap.Map2Vertex3.u1 = u1;
	 ctx->EvalMap.Map2Vertex3.u2 = u2;
ctx->EvalMap.Map2Vertex3.Vorder = vorder;
	 ctx->EvalMap.Map2Vertex3.v1 = v1;
	 ctx->EvalMap.Map2Vertex3.v2 = v2;
	 if (ctx->EvalMap.Map2Vertex3.Points
&& !ctx->EvalMap.Map2Vertex3.Retain) {
	    free( ctx->EvalMap.Map2Vertex3.Points );
	 }
	 ctx->EvalMap.Map2Vertex3.Retain = retain;
	 ctx->EvalMap.Map2Vertex3.Points = (float *) points;
	 break;
case GL_MAP2_VERTEX_4:
ctx->EvalMap.Map2Vertex4.Uorder = uorder;
	 ctx->EvalMap.Map2Vertex4.u1 = u1;
	 ctx->EvalMap.Map2Vertex4.u2 = u2;
ctx->EvalMap.Map2Vertex4.Vorder = vorder;
	 ctx->EvalMap.Map2Vertex4.v1 = v1;
	 ctx->EvalMap.Map2Vertex4.v2 = v2;
	 if (ctx->EvalMap.Map2Vertex4.Points
&& !ctx->EvalMap.Map2Vertex4.Retain) {
	    free( ctx->EvalMap.Map2Vertex4.Points );
	 }
	 ctx->EvalMap.Map2Vertex4.Points = (float *) points;
	 ctx->EvalMap.Map2Vertex4.Retain = retain;
	 break;
case GL_MAP2_INDEX:
ctx->EvalMap.Map2Index.Uorder = uorder;
	 ctx->EvalMap.Map2Index.u1 = u1;
	 ctx->EvalMap.Map2Index.u2 = u2;
ctx->EvalMap.Map2Index.Vorder = vorder;
	 ctx->EvalMap.Map2Index.v1 = v1;
	 ctx->EvalMap.Map2Index.v2 = v2;
	 if (ctx->EvalMap.Map2Index.Points
&& !ctx->EvalMap.Map2Index.Retain) {
	    free( ctx->EvalMap.Map2Index.Points );
	 }
	 ctx->EvalMap.Map2Index.Retain = retain;
	 ctx->EvalMap.Map2Index.Points = (float *) points;
	 break;
case GL_MAP2_COLOR_4:
ctx->EvalMap.Map2Color4.Uorder = uorder;
	 ctx->EvalMap.Map2Color4.u1 = u1;
	 ctx->EvalMap.Map2Color4.u2 = u2;
ctx->EvalMap.Map2Color4.Vorder = vorder;
	 ctx->EvalMap.Map2Color4.v1 = v1;
	 ctx->EvalMap.Map2Color4.v2 = v2;
	 if (ctx->EvalMap.Map2Color4.Points
&& !ctx->EvalMap.Map2Color4.Retain) {
	    free( ctx->EvalMap.Map2Color4.Points );
	 }
	 ctx->EvalMap.Map2Color4.Retain = retain;
	 ctx->EvalMap.Map2Color4.Points = (float *) points;
	 break;
case GL_MAP2_NORMAL:
ctx->EvalMap.Map2Normal.Uorder = uorder;
	 ctx->EvalMap.Map2Normal.u1 = u1;
	 ctx->EvalMap.Map2Normal.u2 = u2;
ctx->EvalMap.Map2Normal.Vorder = vorder;
	 ctx->EvalMap.Map2Normal.v1 = v1;
	 ctx->EvalMap.Map2Normal.v2 = v2;
	 if (ctx->EvalMap.Map2Normal.Points
&& !ctx->EvalMap.Map2Normal.Retain) {
	    free( ctx->EvalMap.Map2Normal.Points );
	 }
	 ctx->EvalMap.Map2Normal.Retain = retain;
	 ctx->EvalMap.Map2Normal.Points = (float *) points;
	 break;
case GL_MAP2_TEXTURE_COORD_1:
ctx->EvalMap.Map2Texture1.Uorder = uorder;
	 ctx->EvalMap.Map2Texture1.u1 = u1;
	 ctx->EvalMap.Map2Texture1.u2 = u2;
ctx->EvalMap.Map2Texture1.Vorder = vorder;
	 ctx->EvalMap.Map2Texture1.v1 = v1;
	 ctx->EvalMap.Map2Texture1.v2 = v2;
	 if (ctx->EvalMap.Map2Texture1.Points
&& !ctx->EvalMap.Map2Texture1.Retain) {
	    free( ctx->EvalMap.Map2Texture1.Points );
	 }
	 ctx->EvalMap.Map2Texture1.Retain = retain;
	 ctx->EvalMap.Map2Texture1.Points = (float *) points;
	 break;
case GL_MAP2_TEXTURE_COORD_2:
ctx->EvalMap.Map2Texture2.Uorder = uorder;
	 ctx->EvalMap.Map2Texture2.u1 = u1;
	 ctx->EvalMap.Map2Texture2.u2 = u2;
ctx->EvalMap.Map2Texture2.Vorder = vorder;
	 ctx->EvalMap.Map2Texture2.v1 = v1;
	 ctx->EvalMap.Map2Texture2.v2 = v2;
	 if (ctx->EvalMap.Map2Texture2.Points
&& !ctx->EvalMap.Map2Texture2.Retain) {
	    free( ctx->EvalMap.Map2Texture2.Points );
	 }
	 ctx->EvalMap.Map2Texture2.Retain = retain;
	 ctx->EvalMap.Map2Texture2.Points = (float *) points;
	 break;
case GL_MAP2_TEXTURE_COORD_3:
ctx->EvalMap.Map2Texture3.Uorder = uorder;
	 ctx->EvalMap.Map2Texture3.u1 = u1;
	 ctx->EvalMap.Map2Texture3.u2 = u2;
ctx->EvalMap.Map2Texture3.Vorder = vorder;
	 ctx->EvalMap.Map2Texture3.v1 = v1;
	 ctx->EvalMap.Map2Texture3.v2 = v2;
	 if (ctx->EvalMap.Map2Texture3.Points
&& !ctx->EvalMap.Map2Texture3.Retain) {
	    free( ctx->EvalMap.Map2Texture3.Points );
	 }
	 ctx->EvalMap.Map2Texture3.Retain = retain;
	 ctx->EvalMap.Map2Texture3.Points = (float *) points;
	 break;
case GL_MAP2_TEXTURE_COORD_4:
ctx->EvalMap.Map2Texture4.Uorder = uorder;
	 ctx->EvalMap.Map2Texture4.u1 = u1;
	 ctx->EvalMap.Map2Texture4.u2 = u2;
ctx->EvalMap.Map2Texture4.Vorder = vorder;
	 ctx->EvalMap.Map2Texture4.v1 = v1;
	 ctx->EvalMap.Map2Texture4.v2 = v2;
	 if (ctx->EvalMap.Map2Texture4.Points
&& !ctx->EvalMap.Map2Texture4.Retain) {
	    free( ctx->EvalMap.Map2Texture4.Points );
	 }
	 ctx->EvalMap.Map2Texture4.Retain = retain;
	 ctx->EvalMap.Map2Texture4.Points = (float *) points;
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glMap2(target)" );
}
}
void gl_GetMapdv( GLcontext* ctx, GLenum target, GLenum query, GLdouble *v )
{
GLuint i, n;
float *data;
switch (query) {
case GL_COEFF:
	 switch (target) {
	    case GL_MAP1_COLOR_4:
	       data = ctx->EvalMap.Map1Color4.Points;
	       n = ctx->EvalMap.Map1Color4.Order * 4;
	       break;
	    case GL_MAP1_INDEX:
	       data = ctx->EvalMap.Map1Index.Points;
	       n = ctx->EvalMap.Map1Index.Order;
	       break;
	    case GL_MAP1_NORMAL:
	       data = ctx->EvalMap.Map1Normal.Points;
	       n = ctx->EvalMap.Map1Normal.Order * 3;
	       break;
	    case GL_MAP1_TEXTURE_COORD_1:
	       data = ctx->EvalMap.Map1Texture1.Points;
	       n = ctx->EvalMap.Map1Texture1.Order * 1;
	       break;
	    case GL_MAP1_TEXTURE_COORD_2:
	       data = ctx->EvalMap.Map1Texture2.Points;
	       n = ctx->EvalMap.Map1Texture2.Order * 2;
	       break;
	    case GL_MAP1_TEXTURE_COORD_3:
	       data = ctx->EvalMap.Map1Texture3.Points;
	       n = ctx->EvalMap.Map1Texture3.Order * 3;
	       break;
	    case GL_MAP1_TEXTURE_COORD_4:
	       data = ctx->EvalMap.Map1Texture4.Points;
	       n = ctx->EvalMap.Map1Texture4.Order * 4;
	       break;
	    case GL_MAP1_VERTEX_3:
	       data = ctx->EvalMap.Map1Vertex3.Points;
	       n = ctx->EvalMap.Map1Vertex3.Order * 3;
	       break;
	    case GL_MAP1_VERTEX_4:
	       data = ctx->EvalMap.Map1Vertex4.Points;
	       n = ctx->EvalMap.Map1Vertex4.Order * 4;
	       break;
	    case GL_MAP2_COLOR_4:
	       data = ctx->EvalMap.Map2Color4.Points;
	       n = ctx->EvalMap.Map2Color4.Uorder
* ctx->EvalMap.Map2Color4.Vorder * 4;
	       break;
	    case GL_MAP2_INDEX:
	       data = ctx->EvalMap.Map2Index.Points;
	       n = ctx->EvalMap.Map2Index.Uorder
* ctx->EvalMap.Map2Index.Vorder;
	       break;
	    case GL_MAP2_NORMAL:
	       data = ctx->EvalMap.Map2Normal.Points;
	       n = ctx->EvalMap.Map2Normal.Uorder
* ctx->EvalMap.Map2Normal.Vorder * 3;
	       break;
	    case GL_MAP2_TEXTURE_COORD_1:
	       data = ctx->EvalMap.Map2Texture1.Points;
	       n = ctx->EvalMap.Map2Texture1.Uorder
* ctx->EvalMap.Map2Texture1.Vorder * 1;
	       break;
	    case GL_MAP2_TEXTURE_COORD_2:
	       data = ctx->EvalMap.Map2Texture2.Points;
	       n = ctx->EvalMap.Map2Texture2.Uorder
* ctx->EvalMap.Map2Texture2.Vorder * 2;
	       break;
	    case GL_MAP2_TEXTURE_COORD_3:
	       data = ctx->EvalMap.Map2Texture3.Points;
	       n = ctx->EvalMap.Map2Texture3.Uorder
* ctx->EvalMap.Map2Texture3.Vorder * 3;
	       break;
	    case GL_MAP2_TEXTURE_COORD_4:
	       data = ctx->EvalMap.Map2Texture4.Points;
	       n = ctx->EvalMap.Map2Texture4.Uorder
* ctx->EvalMap.Map2Texture4.Vorder * 4;
	       break;
	    case GL_MAP2_VERTEX_3:
	       data = ctx->EvalMap.Map2Vertex3.Points;
	       n = ctx->EvalMap.Map2Vertex3.Uorder
* ctx->EvalMap.Map2Vertex3.Vorder * 3;
	       break;
	    case GL_MAP2_VERTEX_4:
	       data = ctx->EvalMap.Map2Vertex4.Points;
	       n = ctx->EvalMap.Map2Vertex4.Uorder
* ctx->EvalMap.Map2Vertex4.Vorder * 4;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetMapdv(target)" );
	 }
	 if (data) {
	    for (i=0;i<n;i++) {
	       v[i] = data[i];
	    }
	 }
break;
case GL_ORDER:
	 switch (target) {
	    case GL_MAP1_COLOR_4:
	       *v = ctx->EvalMap.Map1Color4.Order;
	       break;
	    case GL_MAP1_INDEX:
	       *v = ctx->EvalMap.Map1Index.Order;
	       break;
	    case GL_MAP1_NORMAL:
	       *v = ctx->EvalMap.Map1Normal.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_1:
	       *v = ctx->EvalMap.Map1Texture1.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_2:
	       *v = ctx->EvalMap.Map1Texture2.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_3:
	       *v = ctx->EvalMap.Map1Texture3.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_4:
	       *v = ctx->EvalMap.Map1Texture4.Order;
	       break;
	    case GL_MAP1_VERTEX_3:
	       *v = ctx->EvalMap.Map1Vertex3.Order;
	       break;
	    case GL_MAP1_VERTEX_4:
	       *v = ctx->EvalMap.Map1Vertex4.Order;
	       break;
	    case GL_MAP2_COLOR_4:
	       v[0] = ctx->EvalMap.Map2Color4.Uorder;
	       v[1] = ctx->EvalMap.Map2Color4.Vorder;
	       break;
	    case GL_MAP2_INDEX:
	       v[0] = ctx->EvalMap.Map2Index.Uorder;
	       v[1] = ctx->EvalMap.Map2Index.Vorder;
	       break;
	    case GL_MAP2_NORMAL:
	       v[0] = ctx->EvalMap.Map2Normal.Uorder;
	       v[1] = ctx->EvalMap.Map2Normal.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_1:
	       v[0] = ctx->EvalMap.Map2Texture1.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture1.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_2:
	       v[0] = ctx->EvalMap.Map2Texture2.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture2.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_3:
	       v[0] = ctx->EvalMap.Map2Texture3.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture3.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_4:
	       v[0] = ctx->EvalMap.Map2Texture4.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture4.Vorder;
	       break;
	    case GL_MAP2_VERTEX_3:
	       v[0] = ctx->EvalMap.Map2Vertex3.Uorder;
	       v[1] = ctx->EvalMap.Map2Vertex3.Vorder;
	       break;
	    case GL_MAP2_VERTEX_4:
	       v[0] = ctx->EvalMap.Map2Vertex4.Uorder;
	       v[1] = ctx->EvalMap.Map2Vertex4.Vorder;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetMapdv(target)" );
	 }
break;
case GL_DOMAIN:
	 switch (target) {
	    case GL_MAP1_COLOR_4:
	       v[0] = ctx->EvalMap.Map1Color4.u1;
	       v[1] = ctx->EvalMap.Map1Color4.u2;
	       break;
	    case GL_MAP1_INDEX:
	       v[0] = ctx->EvalMap.Map1Index.u1;
	       v[1] = ctx->EvalMap.Map1Index.u2;
	       break;
	    case GL_MAP1_NORMAL:
	       v[0] = ctx->EvalMap.Map1Normal.u1;
	       v[1] = ctx->EvalMap.Map1Normal.u2;
	       break;
	    case GL_MAP1_TEXTURE_COORD_1:
	       v[0] = ctx->EvalMap.Map1Texture1.u1;
	       v[1] = ctx->EvalMap.Map1Texture1.u2;
	       break;
	    case GL_MAP1_TEXTURE_COORD_2:
	       v[0] = ctx->EvalMap.Map1Texture2.u1;
	       v[1] = ctx->EvalMap.Map1Texture2.u2;
	       break;
	    case GL_MAP1_TEXTURE_COORD_3:
	       v[0] = ctx->EvalMap.Map1Texture3.u1;
	       v[1] = ctx->EvalMap.Map1Texture3.u2;
	       break;
	    case GL_MAP1_TEXTURE_COORD_4:
	       v[0] = ctx->EvalMap.Map1Texture4.u1;
	       v[1] = ctx->EvalMap.Map1Texture4.u2;
	       break;
	    case GL_MAP1_VERTEX_3:
	       v[0] = ctx->EvalMap.Map1Vertex3.u1;
	       v[1] = ctx->EvalMap.Map1Vertex3.u2;
	       break;
	    case GL_MAP1_VERTEX_4:
	       v[0] = ctx->EvalMap.Map1Vertex4.u1;
	       v[1] = ctx->EvalMap.Map1Vertex4.u2;
	       break;
	    case GL_MAP2_COLOR_4:
	       v[0] = ctx->EvalMap.Map2Color4.u1;
	       v[1] = ctx->EvalMap.Map2Color4.u2;
	       v[2] = ctx->EvalMap.Map2Color4.v1;
	       v[3] = ctx->EvalMap.Map2Color4.v2;
	       break;
	    case GL_MAP2_INDEX:
	       v[0] = ctx->EvalMap.Map2Index.u1;
	       v[1] = ctx->EvalMap.Map2Index.u2;
	       v[2] = ctx->EvalMap.Map2Index.v1;
	       v[3] = ctx->EvalMap.Map2Index.v2;
	       break;
	    case GL_MAP2_NORMAL:
	       v[0] = ctx->EvalMap.Map2Normal.u1;
	       v[1] = ctx->EvalMap.Map2Normal.u2;
	       v[2] = ctx->EvalMap.Map2Normal.v1;
	       v[3] = ctx->EvalMap.Map2Normal.v2;
	       break;
	    case GL_MAP2_TEXTURE_COORD_1:
	       v[0] = ctx->EvalMap.Map2Texture1.u1;
	       v[1] = ctx->EvalMap.Map2Texture1.u2;
	       v[2] = ctx->EvalMap.Map2Texture1.v1;
	       v[3] = ctx->EvalMap.Map2Texture1.v2;
	       break;
	    case GL_MAP2_TEXTURE_COORD_2:
	       v[0] = ctx->EvalMap.Map2Texture2.u1;
	       v[1] = ctx->EvalMap.Map2Texture2.u2;
	       v[2] = ctx->EvalMap.Map2Texture2.v1;
	       v[3] = ctx->EvalMap.Map2Texture2.v2;
	       break;
	    case GL_MAP2_TEXTURE_COORD_3:
	       v[0] = ctx->EvalMap.Map2Texture3.u1;
	       v[1] = ctx->EvalMap.Map2Texture3.u2;
	       v[2] = ctx->EvalMap.Map2Texture3.v1;
	       v[3] = ctx->EvalMap.Map2Texture3.v2;
	       break;
	    case GL_MAP2_TEXTURE_COORD_4:
	       v[0] = ctx->EvalMap.Map2Texture4.u1;
	       v[1] = ctx->EvalMap.Map2Texture4.u2;
	       v[2] = ctx->EvalMap.Map2Texture4.v1;
	       v[3] = ctx->EvalMap.Map2Texture4.v2;
	       break;
	    case GL_MAP2_VERTEX_3:
	       v[0] = ctx->EvalMap.Map2Vertex3.u1;
	       v[1] = ctx->EvalMap.Map2Vertex3.u2;
	       v[2] = ctx->EvalMap.Map2Vertex3.v1;
	       v[3] = ctx->EvalMap.Map2Vertex3.v2;
	       break;
	    case GL_MAP2_VERTEX_4:
	       v[0] = ctx->EvalMap.Map2Vertex4.u1;
	       v[1] = ctx->EvalMap.Map2Vertex4.u2;
	       v[2] = ctx->EvalMap.Map2Vertex4.v1;
	       v[3] = ctx->EvalMap.Map2Vertex4.v2;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetMapdv(target)" );
	 }
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetMapdv(query)" );
}
}
void gl_GetMapfv( GLcontext* ctx, GLenum target, GLenum query, float *v )
{
GLuint i, n;
float *data;
switch (query) {
case GL_COEFF:
	 switch (target) {
	    case GL_MAP1_COLOR_4:
	       data = ctx->EvalMap.Map1Color4.Points;
	       n = ctx->EvalMap.Map1Color4.Order * 4;
	       break;
	    case GL_MAP1_INDEX:
	       data = ctx->EvalMap.Map1Index.Points;
	       n = ctx->EvalMap.Map1Index.Order;
	       break;
	    case GL_MAP1_NORMAL:
	       data = ctx->EvalMap.Map1Normal.Points;
	       n = ctx->EvalMap.Map1Normal.Order * 3;
	       break;
	    case GL_MAP1_TEXTURE_COORD_1:
	       data = ctx->EvalMap.Map1Texture1.Points;
	       n = ctx->EvalMap.Map1Texture1.Order * 1;
	       break;
	    case GL_MAP1_TEXTURE_COORD_2:
	       data = ctx->EvalMap.Map1Texture2.Points;
	       n = ctx->EvalMap.Map1Texture2.Order * 2;
	       break;
	    case GL_MAP1_TEXTURE_COORD_3:
	       data = ctx->EvalMap.Map1Texture3.Points;
	       n = ctx->EvalMap.Map1Texture3.Order * 3;
	       break;
	    case GL_MAP1_TEXTURE_COORD_4:
	       data = ctx->EvalMap.Map1Texture4.Points;
	       n = ctx->EvalMap.Map1Texture4.Order * 4;
	       break;
	    case GL_MAP1_VERTEX_3:
	       data = ctx->EvalMap.Map1Vertex3.Points;
	       n = ctx->EvalMap.Map1Vertex3.Order * 3;
	       break;
	    case GL_MAP1_VERTEX_4:
	       data = ctx->EvalMap.Map1Vertex4.Points;
	       n = ctx->EvalMap.Map1Vertex4.Order * 4;
	       break;
	    case GL_MAP2_COLOR_4:
	       data = ctx->EvalMap.Map2Color4.Points;
	       n = ctx->EvalMap.Map2Color4.Uorder
* ctx->EvalMap.Map2Color4.Vorder * 4;
	       break;
	    case GL_MAP2_INDEX:
	       data = ctx->EvalMap.Map2Index.Points;
	       n = ctx->EvalMap.Map2Index.Uorder
* ctx->EvalMap.Map2Index.Vorder;
	       break;
	    case GL_MAP2_NORMAL:
	       data = ctx->EvalMap.Map2Normal.Points;
	       n = ctx->EvalMap.Map2Normal.Uorder
* ctx->EvalMap.Map2Normal.Vorder * 3;
	       break;
	    case GL_MAP2_TEXTURE_COORD_1:
	       data = ctx->EvalMap.Map2Texture1.Points;
	       n = ctx->EvalMap.Map2Texture1.Uorder
* ctx->EvalMap.Map2Texture1.Vorder * 1;
	       break;
	    case GL_MAP2_TEXTURE_COORD_2:
	       data = ctx->EvalMap.Map2Texture2.Points;
	       n = ctx->EvalMap.Map2Texture2.Uorder
* ctx->EvalMap.Map2Texture2.Vorder * 2;
	       break;
	    case GL_MAP2_TEXTURE_COORD_3:
	       data = ctx->EvalMap.Map2Texture3.Points;
	       n = ctx->EvalMap.Map2Texture3.Uorder
* ctx->EvalMap.Map2Texture3.Vorder * 3;
	       break;
	    case GL_MAP2_TEXTURE_COORD_4:
	       data = ctx->EvalMap.Map2Texture4.Points;
	       n = ctx->EvalMap.Map2Texture4.Uorder
* ctx->EvalMap.Map2Texture4.Vorder * 4;
	       break;
	    case GL_MAP2_VERTEX_3:
	       data = ctx->EvalMap.Map2Vertex3.Points;
	       n = ctx->EvalMap.Map2Vertex3.Uorder
* ctx->EvalMap.Map2Vertex3.Vorder * 3;
	       break;
	    case GL_MAP2_VERTEX_4:
	       data = ctx->EvalMap.Map2Vertex4.Points;
	       n = ctx->EvalMap.Map2Vertex4.Uorder
* ctx->EvalMap.Map2Vertex4.Vorder * 4;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetMapfv(target)" );
	 }
	 if (data) {
	    for (i=0;i<n;i++) {
	       v[i] = data[i];
	    }
	 }
break;
case GL_ORDER:
	 switch (target) {
	    case GL_MAP1_COLOR_4:
	       *v = ctx->EvalMap.Map1Color4.Order;
	       break;
	    case GL_MAP1_INDEX:
	       *v = ctx->EvalMap.Map1Index.Order;
	       break;
	    case GL_MAP1_NORMAL:
	       *v = ctx->EvalMap.Map1Normal.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_1:
	       *v = ctx->EvalMap.Map1Texture1.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_2:
	       *v = ctx->EvalMap.Map1Texture2.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_3:
	       *v = ctx->EvalMap.Map1Texture3.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_4:
	       *v = ctx->EvalMap.Map1Texture4.Order;
	       break;
	    case GL_MAP1_VERTEX_3:
	       *v = ctx->EvalMap.Map1Vertex3.Order;
	       break;
	    case GL_MAP1_VERTEX_4:
	       *v = ctx->EvalMap.Map1Vertex4.Order;
	       break;
	    case GL_MAP2_COLOR_4:
	       v[0] = ctx->EvalMap.Map2Color4.Uorder;
	       v[1] = ctx->EvalMap.Map2Color4.Vorder;
	       break;
	    case GL_MAP2_INDEX:
	       v[0] = ctx->EvalMap.Map2Index.Uorder;
	       v[1] = ctx->EvalMap.Map2Index.Vorder;
	       break;
	    case GL_MAP2_NORMAL:
	       v[0] = ctx->EvalMap.Map2Normal.Uorder;
	       v[1] = ctx->EvalMap.Map2Normal.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_1:
	       v[0] = ctx->EvalMap.Map2Texture1.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture1.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_2:
	       v[0] = ctx->EvalMap.Map2Texture2.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture2.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_3:
	       v[0] = ctx->EvalMap.Map2Texture3.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture3.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_4:
	       v[0] = ctx->EvalMap.Map2Texture4.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture4.Vorder;
	       break;
	    case GL_MAP2_VERTEX_3:
	       v[0] = ctx->EvalMap.Map2Vertex3.Uorder;
	       v[1] = ctx->EvalMap.Map2Vertex3.Vorder;
	       break;
	    case GL_MAP2_VERTEX_4:
	       v[0] = ctx->EvalMap.Map2Vertex4.Uorder;
	       v[1] = ctx->EvalMap.Map2Vertex4.Vorder;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetMapfv(target)" );
	 }
break;
case GL_DOMAIN:
	 switch (target) {
	    case GL_MAP1_COLOR_4:
	       v[0] = ctx->EvalMap.Map1Color4.u1;
	       v[1] = ctx->EvalMap.Map1Color4.u2;
	       break;
	    case GL_MAP1_INDEX:
	       v[0] = ctx->EvalMap.Map1Index.u1;
	       v[1] = ctx->EvalMap.Map1Index.u2;
	       break;
	    case GL_MAP1_NORMAL:
	       v[0] = ctx->EvalMap.Map1Normal.u1;
	       v[1] = ctx->EvalMap.Map1Normal.u2;
	       break;
	    case GL_MAP1_TEXTURE_COORD_1:
	       v[0] = ctx->EvalMap.Map1Texture1.u1;
	       v[1] = ctx->EvalMap.Map1Texture1.u2;
	       break;
	    case GL_MAP1_TEXTURE_COORD_2:
	       v[0] = ctx->EvalMap.Map1Texture2.u1;
	       v[1] = ctx->EvalMap.Map1Texture2.u2;
	       break;
	    case GL_MAP1_TEXTURE_COORD_3:
	       v[0] = ctx->EvalMap.Map1Texture3.u1;
	       v[1] = ctx->EvalMap.Map1Texture3.u2;
	       break;
	    case GL_MAP1_TEXTURE_COORD_4:
	       v[0] = ctx->EvalMap.Map1Texture4.u1;
	       v[1] = ctx->EvalMap.Map1Texture4.u2;
	       break;
	    case GL_MAP1_VERTEX_3:
	       v[0] = ctx->EvalMap.Map1Vertex3.u1;
	       v[1] = ctx->EvalMap.Map1Vertex3.u2;
	       break;
	    case GL_MAP1_VERTEX_4:
	       v[0] = ctx->EvalMap.Map1Vertex4.u1;
	       v[1] = ctx->EvalMap.Map1Vertex4.u2;
	       break;
	    case GL_MAP2_COLOR_4:
	       v[0] = ctx->EvalMap.Map2Color4.u1;
	       v[1] = ctx->EvalMap.Map2Color4.u2;
	       v[2] = ctx->EvalMap.Map2Color4.v1;
	       v[3] = ctx->EvalMap.Map2Color4.v2;
	       break;
	    case GL_MAP2_INDEX:
	       v[0] = ctx->EvalMap.Map2Index.u1;
	       v[1] = ctx->EvalMap.Map2Index.u2;
	       v[2] = ctx->EvalMap.Map2Index.v1;
	       v[3] = ctx->EvalMap.Map2Index.v2;
	       break;
	    case GL_MAP2_NORMAL:
	       v[0] = ctx->EvalMap.Map2Normal.u1;
	       v[1] = ctx->EvalMap.Map2Normal.u2;
	       v[2] = ctx->EvalMap.Map2Normal.v1;
	       v[3] = ctx->EvalMap.Map2Normal.v2;
	       break;
	    case GL_MAP2_TEXTURE_COORD_1:
	       v[0] = ctx->EvalMap.Map2Texture1.u1;
	       v[1] = ctx->EvalMap.Map2Texture1.u2;
	       v[2] = ctx->EvalMap.Map2Texture1.v1;
	       v[3] = ctx->EvalMap.Map2Texture1.v2;
	       break;
	    case GL_MAP2_TEXTURE_COORD_2:
	       v[0] = ctx->EvalMap.Map2Texture2.u1;
	       v[1] = ctx->EvalMap.Map2Texture2.u2;
	       v[2] = ctx->EvalMap.Map2Texture2.v1;
	       v[3] = ctx->EvalMap.Map2Texture2.v2;
	       break;
	    case GL_MAP2_TEXTURE_COORD_3:
	       v[0] = ctx->EvalMap.Map2Texture3.u1;
	       v[1] = ctx->EvalMap.Map2Texture3.u2;
	       v[2] = ctx->EvalMap.Map2Texture3.v1;
	       v[3] = ctx->EvalMap.Map2Texture3.v2;
	       break;
	    case GL_MAP2_TEXTURE_COORD_4:
	       v[0] = ctx->EvalMap.Map2Texture4.u1;
	       v[1] = ctx->EvalMap.Map2Texture4.u2;
	       v[2] = ctx->EvalMap.Map2Texture4.v1;
	       v[3] = ctx->EvalMap.Map2Texture4.v2;
	       break;
	    case GL_MAP2_VERTEX_3:
	       v[0] = ctx->EvalMap.Map2Vertex3.u1;
	       v[1] = ctx->EvalMap.Map2Vertex3.u2;
	       v[2] = ctx->EvalMap.Map2Vertex3.v1;
	       v[3] = ctx->EvalMap.Map2Vertex3.v2;
	       break;
	    case GL_MAP2_VERTEX_4:
	       v[0] = ctx->EvalMap.Map2Vertex4.u1;
	       v[1] = ctx->EvalMap.Map2Vertex4.u2;
	       v[2] = ctx->EvalMap.Map2Vertex4.v1;
	       v[3] = ctx->EvalMap.Map2Vertex4.v2;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetMapfv(target)" );
	 }
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetMapfv(query)" );
}
}
void gl_GetMapiv( GLcontext* ctx, GLenum target, GLenum query, GLint *v )
{
GLuint i, n;
float *data;
switch (query) {
case GL_COEFF:
	 switch (target) {
	    case GL_MAP1_COLOR_4:
	       data = ctx->EvalMap.Map1Color4.Points;
	       n = ctx->EvalMap.Map1Color4.Order * 4;
	       break;
	    case GL_MAP1_INDEX:
	       data = ctx->EvalMap.Map1Index.Points;
	       n = ctx->EvalMap.Map1Index.Order;
	       break;
	    case GL_MAP1_NORMAL:
	       data = ctx->EvalMap.Map1Normal.Points;
	       n = ctx->EvalMap.Map1Normal.Order * 3;
	       break;
	    case GL_MAP1_TEXTURE_COORD_1:
	       data = ctx->EvalMap.Map1Texture1.Points;
	       n = ctx->EvalMap.Map1Texture1.Order * 1;
	       break;
	    case GL_MAP1_TEXTURE_COORD_2:
	       data = ctx->EvalMap.Map1Texture2.Points;
	       n = ctx->EvalMap.Map1Texture2.Order * 2;
	       break;
	    case GL_MAP1_TEXTURE_COORD_3:
	       data = ctx->EvalMap.Map1Texture3.Points;
	       n = ctx->EvalMap.Map1Texture3.Order * 3;
	       break;
	    case GL_MAP1_TEXTURE_COORD_4:
	       data = ctx->EvalMap.Map1Texture4.Points;
	       n = ctx->EvalMap.Map1Texture4.Order * 4;
	       break;
	    case GL_MAP1_VERTEX_3:
	       data = ctx->EvalMap.Map1Vertex3.Points;
	       n = ctx->EvalMap.Map1Vertex3.Order * 3;
	       break;
	    case GL_MAP1_VERTEX_4:
	       data = ctx->EvalMap.Map1Vertex4.Points;
	       n = ctx->EvalMap.Map1Vertex4.Order * 4;
	       break;
	    case GL_MAP2_COLOR_4:
	       data = ctx->EvalMap.Map2Color4.Points;
	       n = ctx->EvalMap.Map2Color4.Uorder
* ctx->EvalMap.Map2Color4.Vorder * 4;
	       break;
	    case GL_MAP2_INDEX:
	       data = ctx->EvalMap.Map2Index.Points;
	       n = ctx->EvalMap.Map2Index.Uorder
* ctx->EvalMap.Map2Index.Vorder;
	       break;
	    case GL_MAP2_NORMAL:
	       data = ctx->EvalMap.Map2Normal.Points;
	       n = ctx->EvalMap.Map2Normal.Uorder
* ctx->EvalMap.Map2Normal.Vorder * 3;
	       break;
	    case GL_MAP2_TEXTURE_COORD_1:
	       data = ctx->EvalMap.Map2Texture1.Points;
	       n = ctx->EvalMap.Map2Texture1.Uorder
* ctx->EvalMap.Map2Texture1.Vorder * 1;
	       break;
	    case GL_MAP2_TEXTURE_COORD_2:
	       data = ctx->EvalMap.Map2Texture2.Points;
	       n = ctx->EvalMap.Map2Texture2.Uorder
* ctx->EvalMap.Map2Texture2.Vorder * 2;
	       break;
	    case GL_MAP2_TEXTURE_COORD_3:
	       data = ctx->EvalMap.Map2Texture3.Points;
	       n = ctx->EvalMap.Map2Texture3.Uorder
* ctx->EvalMap.Map2Texture3.Vorder * 3;
	       break;
	    case GL_MAP2_TEXTURE_COORD_4:
	       data = ctx->EvalMap.Map2Texture4.Points;
	       n = ctx->EvalMap.Map2Texture4.Uorder
* ctx->EvalMap.Map2Texture4.Vorder * 4;
	       break;
	    case GL_MAP2_VERTEX_3:
	       data = ctx->EvalMap.Map2Vertex3.Points;
	       n = ctx->EvalMap.Map2Vertex3.Uorder
* ctx->EvalMap.Map2Vertex3.Vorder * 3;
	       break;
	    case GL_MAP2_VERTEX_4:
	       data = ctx->EvalMap.Map2Vertex4.Points;
	       n = ctx->EvalMap.Map2Vertex4.Uorder
* ctx->EvalMap.Map2Vertex4.Vorder * 4;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetMapiv(target)" );
	 }
	 if (data) {
	    for (i=0;i<n;i++) {
	       v[i] = ROUNDF(data[i]);
	    }
	 }
break;
case GL_ORDER:
	 switch (target) {
	    case GL_MAP1_COLOR_4:
	       *v = ctx->EvalMap.Map1Color4.Order;
	       break;
	    case GL_MAP1_INDEX:
	       *v = ctx->EvalMap.Map1Index.Order;
	       break;
	    case GL_MAP1_NORMAL:
	       *v = ctx->EvalMap.Map1Normal.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_1:
	       *v = ctx->EvalMap.Map1Texture1.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_2:
	       *v = ctx->EvalMap.Map1Texture2.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_3:
	       *v = ctx->EvalMap.Map1Texture3.Order;
	       break;
	    case GL_MAP1_TEXTURE_COORD_4:
	       *v = ctx->EvalMap.Map1Texture4.Order;
	       break;
	    case GL_MAP1_VERTEX_3:
	       *v = ctx->EvalMap.Map1Vertex3.Order;
	       break;
	    case GL_MAP1_VERTEX_4:
	       *v = ctx->EvalMap.Map1Vertex4.Order;
	       break;
	    case GL_MAP2_COLOR_4:
	       v[0] = ctx->EvalMap.Map2Color4.Uorder;
	       v[1] = ctx->EvalMap.Map2Color4.Vorder;
	       break;
	    case GL_MAP2_INDEX:
	       v[0] = ctx->EvalMap.Map2Index.Uorder;
	       v[1] = ctx->EvalMap.Map2Index.Vorder;
	       break;
	    case GL_MAP2_NORMAL:
	       v[0] = ctx->EvalMap.Map2Normal.Uorder;
	       v[1] = ctx->EvalMap.Map2Normal.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_1:
	       v[0] = ctx->EvalMap.Map2Texture1.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture1.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_2:
	       v[0] = ctx->EvalMap.Map2Texture2.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture2.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_3:
	       v[0] = ctx->EvalMap.Map2Texture3.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture3.Vorder;
	       break;
	    case GL_MAP2_TEXTURE_COORD_4:
	       v[0] = ctx->EvalMap.Map2Texture4.Uorder;
	       v[1] = ctx->EvalMap.Map2Texture4.Vorder;
	       break;
	    case GL_MAP2_VERTEX_3:
	       v[0] = ctx->EvalMap.Map2Vertex3.Uorder;
	       v[1] = ctx->EvalMap.Map2Vertex3.Vorder;
	       break;
	    case GL_MAP2_VERTEX_4:
	       v[0] = ctx->EvalMap.Map2Vertex4.Uorder;
	       v[1] = ctx->EvalMap.Map2Vertex4.Vorder;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetMapiv(target)" );
	 }
break;
case GL_DOMAIN:
	 switch (target) {
	    case GL_MAP1_COLOR_4:
	       v[0] = ROUNDF(ctx->EvalMap.Map1Color4.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map1Color4.u2);
	       break;
	    case GL_MAP1_INDEX:
	       v[0] = ROUNDF(ctx->EvalMap.Map1Index.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map1Index.u2);
	       break;
	    case GL_MAP1_NORMAL:
	       v[0] = ROUNDF(ctx->EvalMap.Map1Normal.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map1Normal.u2);
	       break;
	    case GL_MAP1_TEXTURE_COORD_1:
	       v[0] = ROUNDF(ctx->EvalMap.Map1Texture1.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map1Texture1.u2);
	       break;
	    case GL_MAP1_TEXTURE_COORD_2:
	       v[0] = ROUNDF(ctx->EvalMap.Map1Texture2.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map1Texture2.u2);
	       break;
	    case GL_MAP1_TEXTURE_COORD_3:
	       v[0] = ROUNDF(ctx->EvalMap.Map1Texture3.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map1Texture3.u2);
	       break;
	    case GL_MAP1_TEXTURE_COORD_4:
	       v[0] = ROUNDF(ctx->EvalMap.Map1Texture4.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map1Texture4.u2);
	       break;
	    case GL_MAP1_VERTEX_3:
	       v[0] = ROUNDF(ctx->EvalMap.Map1Vertex3.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map1Vertex3.u2);
	       break;
	    case GL_MAP1_VERTEX_4:
	       v[0] = ROUNDF(ctx->EvalMap.Map1Vertex4.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map1Vertex4.u2);
	       break;
	    case GL_MAP2_COLOR_4:
	       v[0] = ROUNDF(ctx->EvalMap.Map2Color4.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map2Color4.u2);
	       v[2] = ROUNDF(ctx->EvalMap.Map2Color4.v1);
	       v[3] = ROUNDF(ctx->EvalMap.Map2Color4.v2);
	       break;
	    case GL_MAP2_INDEX:
	       v[0] = ROUNDF(ctx->EvalMap.Map2Index.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map2Index.u2);
	       v[2] = ROUNDF(ctx->EvalMap.Map2Index.v1);
	       v[3] = ROUNDF(ctx->EvalMap.Map2Index.v2);
	       break;
	    case GL_MAP2_NORMAL:
	       v[0] = ROUNDF(ctx->EvalMap.Map2Normal.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map2Normal.u2);
	       v[2] = ROUNDF(ctx->EvalMap.Map2Normal.v1);
	       v[3] = ROUNDF(ctx->EvalMap.Map2Normal.v2);
	       break;
	    case GL_MAP2_TEXTURE_COORD_1:
	       v[0] = ROUNDF(ctx->EvalMap.Map2Texture1.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map2Texture1.u2);
	       v[2] = ROUNDF(ctx->EvalMap.Map2Texture1.v1);
	       v[3] = ROUNDF(ctx->EvalMap.Map2Texture1.v2);
	       break;
	    case GL_MAP2_TEXTURE_COORD_2:
	       v[0] = ROUNDF(ctx->EvalMap.Map2Texture2.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map2Texture2.u2);
	       v[2] = ROUNDF(ctx->EvalMap.Map2Texture2.v1);
	       v[3] = ROUNDF(ctx->EvalMap.Map2Texture2.v2);
	       break;
	    case GL_MAP2_TEXTURE_COORD_3:
	       v[0] = ROUNDF(ctx->EvalMap.Map2Texture3.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map2Texture3.u2);
	       v[2] = ROUNDF(ctx->EvalMap.Map2Texture3.v1);
	       v[3] = ROUNDF(ctx->EvalMap.Map2Texture3.v2);
	       break;
	    case GL_MAP2_TEXTURE_COORD_4:
	       v[0] = ROUNDF(ctx->EvalMap.Map2Texture4.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map2Texture4.u2);
	       v[2] = ROUNDF(ctx->EvalMap.Map2Texture4.v1);
	       v[3] = ROUNDF(ctx->EvalMap.Map2Texture4.v2);
	       break;
	    case GL_MAP2_VERTEX_3:
	       v[0] = ROUNDF(ctx->EvalMap.Map2Vertex3.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map2Vertex3.u2);
	       v[2] = ROUNDF(ctx->EvalMap.Map2Vertex3.v1);
	       v[3] = ROUNDF(ctx->EvalMap.Map2Vertex3.v2);
	       break;
	    case GL_MAP2_VERTEX_4:
	       v[0] = ROUNDF(ctx->EvalMap.Map2Vertex4.u1);
	       v[1] = ROUNDF(ctx->EvalMap.Map2Vertex4.u2);
	       v[2] = ROUNDF(ctx->EvalMap.Map2Vertex4.v1);
	       v[3] = ROUNDF(ctx->EvalMap.Map2Vertex4.v2);
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetMapiv(target)" );
	 }
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetMapiv(query)" );
}
}
void gl_EvalCoord1f(GLcontext* ctx, float u)
{
float vertex[4];
float normal[3];
float fcolor[4];
GLubyte icolor[4];
GLubyte *colorptr;
float texcoord[4];
GLuint index;
register float uu;
if (ctx->Eval.Map1Vertex4)
{
struct gl_1d_map *map = &ctx->EvalMap.Map1Vertex4;
uu = (u - map->u1) / (map->u2 - map->u1);
horner_bezier_curve(map->Points, vertex, uu, 4, map->Order);
}
else if (ctx->Eval.Map1Vertex3)
{
struct gl_1d_map *map = &ctx->EvalMap.Map1Vertex3;
uu = (u - map->u1) / (map->u2 - map->u1);
horner_bezier_curve(map->Points, vertex, uu, 3, map->Order);
vertex[3] = 1.0;
}
if (ctx->Eval.Map1Index)
{
struct gl_1d_map *map = &ctx->EvalMap.Map1Index;
float findex;
uu = (u - map->u1) / (map->u2 - map->u1);
horner_bezier_curve(map->Points, &findex, uu, 1, map->Order);
index = (GLuint) (GLint) findex;
}
else {
index = ctx->Current.Index;
}
if (ctx->Eval.Map1Color4) {
struct gl_1d_map *map = &ctx->EvalMap.Map1Color4;
uu = (u - map->u1) / (map->u2 - map->u1);
horner_bezier_curve(map->Points, fcolor, uu, 4, map->Order);
icolor[0] = (GLint) (fcolor[0] * ctx->Visual->RedScale);
icolor[1] = (GLint) (fcolor[1] * ctx->Visual->GreenScale);
icolor[2] = (GLint) (fcolor[2] * ctx->Visual->BlueScale);
icolor[3] = (GLint) (fcolor[3] * ctx->Visual->AlphaScale);
colorptr = icolor;
}
else {
GLubyte col[4];
COPY_4V(col, ctx->Current.ByteColor );
colorptr = col;
}
if (ctx->Eval.Map1Normal) {
struct gl_1d_map *map = &ctx->EvalMap.Map1Normal;
uu = (u - map->u1) / (map->u2 - map->u1);
horner_bezier_curve(map->Points, normal, uu, 3, map->Order);
}
else {
normal[0] = ctx->Current.Normal[0];
normal[1] = ctx->Current.Normal[1];
normal[2] = ctx->Current.Normal[2];
}
if (ctx->Eval.Map1TextureCoord4) {
struct gl_1d_map *map = &ctx->EvalMap.Map1Texture4;
uu = (u - map->u1) / (map->u2 - map->u1);
horner_bezier_curve(map->Points, texcoord, uu, 4, map->Order);
}
else if (ctx->Eval.Map1TextureCoord3) {
struct gl_1d_map *map = &ctx->EvalMap.Map1Texture3;
uu = (u - map->u1) / (map->u2 - map->u1);
horner_bezier_curve(map->Points, texcoord, uu, 3, map->Order);
texcoord[3] = 1.0;
}
else if (ctx->Eval.Map1TextureCoord2) {
struct gl_1d_map *map = &ctx->EvalMap.Map1Texture2;
uu = (u - map->u1) / (map->u2 - map->u1);
horner_bezier_curve(map->Points, texcoord, uu, 2, map->Order);
texcoord[2] = 0.0;
texcoord[3] = 1.0;
}
else if (ctx->Eval.Map1TextureCoord1) {
struct gl_1d_map *map = &ctx->EvalMap.Map1Texture1;
uu = (u - map->u1) / (map->u2 - map->u1);
horner_bezier_curve(map->Points, texcoord, uu, 1, map->Order);
texcoord[1] = 0.0;
texcoord[2] = 0.0;
texcoord[3] = 1.0;
}
else {
texcoord[0] = ctx->Current.TexCoord[0];
texcoord[1] = ctx->Current.TexCoord[1];
texcoord[2] = ctx->Current.TexCoord[2];
texcoord[3] = ctx->Current.TexCoord[3];
}
gl_eval_vertex( ctx, vertex, normal, colorptr, index, texcoord );
}
void gl_EvalCoord2f( GLcontext* ctx, float u, float v )
{
float vertex[4];
float normal[3];
float fcolor[4];
GLubyte icolor[4];
GLubyte *colorptr;
float texcoord[4];
GLuint index;
register float uu, vv;
#define CROSS_PROD(n, u, v) \
(n)[0] = (u)[1]*(v)[2] - (u)[2]*(v)[1]; \
(n)[1] = (u)[2]*(v)[0] - (u)[0]*(v)[2]; \
(n)[2] = (u)[0]*(v)[1] - (u)[1]*(v)[0]
if(ctx->Eval.Map2Vertex4) {
struct gl_2d_map *map = &ctx->EvalMap.Map2Vertex4;
uu = (u - map->u1) / (map->u2 - map->u1);
vv = (v - map->v1) / (map->v2 - map->v1);
if (ctx->Eval.AutoNormal) {
float du[4], dv[4];
de_casteljau_surf(map->Points, vertex, du, dv, uu, vv, 4,
map->Uorder, map->Vorder);
CROSS_PROD(normal, du, dv);
NORMALIZE_3FV(normal);
}
else {
horner_bezier_surf(map->Points, vertex, uu, vv, 4,
map->Uorder, map->Vorder);
}
}
else if (ctx->Eval.Map2Vertex3) {
struct gl_2d_map *map = &ctx->EvalMap.Map2Vertex3;
uu = (u - map->u1) / (map->u2 - map->u1);
vv = (v - map->v1) / (map->v2 - map->v1);
if (ctx->Eval.AutoNormal) {
float du[3], dv[3];
de_casteljau_surf(map->Points, vertex, du, dv, uu, vv, 3,
map->Uorder, map->Vorder);
CROSS_PROD(normal, du, dv);
NORMALIZE_3FV(normal);
}
else {
horner_bezier_surf(map->Points, vertex, uu, vv, 3,
map->Uorder, map->Vorder);
}
vertex[3] = 1.0;
}
#undef CROSS_PROD
if (ctx->Eval.Map2Index) {
float findex;
struct gl_2d_map *map = &ctx->EvalMap.Map2Index;
uu = (u - map->u1) / (map->u2 - map->u1);
vv = (v - map->v1) / (map->v2 - map->v1);
horner_bezier_surf(map->Points, &findex, uu, vv, 1,
map->Uorder, map->Vorder);
index = (GLuint) (GLint) findex;
}
else {
index = ctx->Current.Index;
}
if (ctx->Eval.Map2Color4) {
struct gl_2d_map *map = &ctx->EvalMap.Map2Color4;
uu = (u - map->u1) / (map->u2 - map->u1);
vv = (v - map->v1) / (map->v2 - map->v1);
horner_bezier_surf(map->Points, fcolor, uu, vv, 4,
map->Uorder, map->Vorder);
icolor[0] = (GLint) (fcolor[0] * ctx->Visual->RedScale);
icolor[1] = (GLint) (fcolor[1] * ctx->Visual->GreenScale);
icolor[2] = (GLint) (fcolor[2] * ctx->Visual->BlueScale);
icolor[3] = (GLint) (fcolor[3] * ctx->Visual->AlphaScale);
colorptr = icolor;
}
else {
GLubyte col[4];
COPY_4V(col, ctx->Current.ByteColor );
colorptr = col;
}
if (!ctx->Eval.AutoNormal
|| (!ctx->Eval.Map2Vertex3 && !ctx->Eval.Map2Vertex4)) {
if (ctx->Eval.Map2Normal) {
struct gl_2d_map *map = &ctx->EvalMap.Map2Normal;
uu = (u - map->u1) / (map->u2 - map->u1);
vv = (v - map->v1) / (map->v2 - map->v1);
horner_bezier_surf(map->Points, normal, uu, vv, 3,
map->Uorder, map->Vorder);
}
else {
normal[0] = ctx->Current.Normal[0];
normal[1] = ctx->Current.Normal[1];
normal[2] = ctx->Current.Normal[2];
}
}
if (ctx->Eval.Map2TextureCoord4) {
struct gl_2d_map *map = &ctx->EvalMap.Map2Texture4;
uu = (u - map->u1) / (map->u2 - map->u1);
vv = (v - map->v1) / (map->v2 - map->v1);
horner_bezier_surf(map->Points, texcoord, uu, vv, 4,
map->Uorder, map->Vorder);
}
else if (ctx->Eval.Map2TextureCoord3) {
struct gl_2d_map *map = &ctx->EvalMap.Map2Texture3;
uu = (u - map->u1) / (map->u2 - map->u1);
vv = (v - map->v1) / (map->v2 - map->v1);
horner_bezier_surf(map->Points, texcoord, uu, vv, 3,
map->Uorder, map->Vorder);
texcoord[3] = 1.0;
}
else if (ctx->Eval.Map2TextureCoord2) {
struct gl_2d_map *map = &ctx->EvalMap.Map2Texture2;
uu = (u - map->u1) / (map->u2 - map->u1);
vv = (v - map->v1) / (map->v2 - map->v1);
horner_bezier_surf(map->Points, texcoord, uu, vv, 2,
map->Uorder, map->Vorder);
texcoord[2] = 0.0;
texcoord[3] = 1.0;
}
else if (ctx->Eval.Map2TextureCoord1) {
struct gl_2d_map *map = &ctx->EvalMap.Map2Texture1;
uu = (u - map->u1) / (map->u2 - map->u1);
vv = (v - map->v1) / (map->v2 - map->v1);
horner_bezier_surf(map->Points, texcoord, uu, vv, 1,
map->Uorder, map->Vorder);
texcoord[1] = 0.0;
texcoord[2] = 0.0;
texcoord[3] = 1.0;
}
else
{
texcoord[0] = ctx->Current.TexCoord[0];
texcoord[1] = ctx->Current.TexCoord[1];
texcoord[2] = ctx->Current.TexCoord[2];
texcoord[3] = ctx->Current.TexCoord[3];
}
gl_eval_vertex( ctx, vertex, normal, colorptr, index, texcoord );
}
void gl_MapGrid1f( GLcontext* ctx, GLint un, float u1, float u2 )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glMapGrid1f" );
return;
}
if (un<1) {
gl_error( ctx, GL_INVALID_VALUE, "glMapGrid1f" );
return;
}
ctx->Eval.MapGrid1un = un;
ctx->Eval.MapGrid1u1 = u1;
ctx->Eval.MapGrid1u2 = u2;
}
void gl_MapGrid2f( GLcontext* ctx, GLint un, float u1, float u2,
		  GLint vn, float v1, float v2 )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glMapGrid2f" );
return;
}
if (un<1) {
gl_error( ctx, GL_INVALID_VALUE, "glMapGrid2f(un)" );
return;
}
if (vn<1) {
gl_error( ctx, GL_INVALID_VALUE, "glMapGrid2f(vn)" );
return;
}
ctx->Eval.MapGrid2un = un;
ctx->Eval.MapGrid2u1 = u1;
ctx->Eval.MapGrid2u2 = u2;
ctx->Eval.MapGrid2vn = vn;
ctx->Eval.MapGrid2v1 = v1;
ctx->Eval.MapGrid2v2 = v2;
}
void gl_EvalPoint1( GLcontext* ctx, GLint i )
{
	float u, du;
	if (i==0) {
		u = ctx->Eval.MapGrid1u1;
	}
	else if (i==ctx->Eval.MapGrid1un) {
		u = ctx->Eval.MapGrid1u2;
	}
	else {
		du = (ctx->Eval.MapGrid1u2 - ctx->Eval.MapGrid1u1)
			/ (float) ctx->Eval.MapGrid1un;
		u = i * du + ctx->Eval.MapGrid1u1;
	}
	gl_EvalCoord1f( ctx, u );
}
void gl_EvalPoint2( GLcontext* ctx, GLint i, GLint j )
{
	float u, du;
	float v, dv;
	if (i==0) {
		u = ctx->Eval.MapGrid2u1;
	}
	else if (i==ctx->Eval.MapGrid2un) {
		u = ctx->Eval.MapGrid2u2;
	}
	else {
		du = (ctx->Eval.MapGrid2u2 - ctx->Eval.MapGrid2u1)
			/ (float) ctx->Eval.MapGrid2un;
		u = i * du + ctx->Eval.MapGrid2u1;
	}
	if (j==0) {
		v = ctx->Eval.MapGrid2v1;
	}
	else if (j==ctx->Eval.MapGrid2vn) {
		v = ctx->Eval.MapGrid2v2;
	}
	else {
		dv = (ctx->Eval.MapGrid2v2 - ctx->Eval.MapGrid2v1)
			/ (float) ctx->Eval.MapGrid2vn;
		v = j * dv + ctx->Eval.MapGrid2v1;
	}
	gl_EvalCoord2f( ctx, u, v );
}
void gl_EvalMesh1( GLcontext* ctx, GLenum mode, GLint i1, GLint i2 )
{
GLint i;
float u, du;
GLenum prim;
	if (INSIDE_BEGIN_END(ctx)) {
		gl_error( ctx, GL_INVALID_OPERATION, "glEvalMesh1" );
		return;
	}
	switch (mode) {
	case GL_POINT:
		prim = GL_POINTS;
		break;
	case GL_LINE:
		prim = GL_LINE_STRIP;
		break;
	default:
		gl_error( ctx, GL_INVALID_ENUM, "glEvalMesh1(mode)" );
		return;
	}
	du = (ctx->Eval.MapGrid1u2 - ctx->Eval.MapGrid1u1)
		/ (float) ctx->Eval.MapGrid1un;
	gl_Begin( ctx, prim );
	for (i=i1;i<=i2;i++) {
		if (i==0) {
			u = ctx->Eval.MapGrid1u1;
		}
		else if (i==ctx->Eval.MapGrid1un) {
			u = ctx->Eval.MapGrid1u2;
		}
		else {
			u = i * du + ctx->Eval.MapGrid1u1;
		}
		gl_EvalCoord1f( ctx, u );
	}
	gl_End(ctx);
}
void gl_EvalMesh2( GLcontext* ctx, GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 )
{
	GLint i, j;
	float u, du, v, dv, v1, v2;
	if (INSIDE_BEGIN_END(ctx)) {
		gl_error( ctx, GL_INVALID_OPERATION, "glEvalMesh2" );
		return;
	}
	du = (ctx->Eval.MapGrid2u2 - ctx->Eval.MapGrid2u1)
		/ (float) ctx->Eval.MapGrid2un;
	dv = (ctx->Eval.MapGrid2v2 - ctx->Eval.MapGrid2v1)
		/ (float) ctx->Eval.MapGrid2vn;
#define I_TO_U( I, U )				\
	if ((I)==0) {		       	\
		U = ctx->Eval.MapGrid2u1;		\
	}					\
	else if ((I)==ctx->Eval.MapGrid2un) {	\
		U = ctx->Eval.MapGrid2u2;		\
	}					\
	else {				\
		U = (I) * du + ctx->Eval.MapGrid2u1;\
	}
#define J_TO_V( J, V )				\
	if ((J)==0) {			\
		V = ctx->Eval.MapGrid2v1;		\
	}					\
	else if ((J)==ctx->Eval.MapGrid2vn) {	\
		V = ctx->Eval.MapGrid2v2;		\
	}					\
	else {				\
		V = (J) * dv + ctx->Eval.MapGrid2v1;\
	}
	switch (mode) {
	case GL_POINT:
		gl_Begin( ctx, GL_POINTS );
		for (j=j1;j<=j2;j++) {
			J_TO_V( j, v );
			for (i=i1;i<=i2;i++) {
				I_TO_U( i, u );
				gl_EvalCoord2f( ctx, u, v );
			}
		}
		gl_End(ctx);
		break;
	case GL_LINE:
		for (j=j1;j<=j2;j++) {
			J_TO_V( j, v );
			gl_Begin( ctx, GL_LINE_STRIP );
			for (i=i1;i<=i2;i++) {
				I_TO_U( i, u );
				gl_EvalCoord2f( ctx, u, v );
			}
			gl_End(ctx);
		}
		for (i=i1;i<=i2;i++) {
			I_TO_U( i, u );
			gl_Begin( ctx, GL_LINE_STRIP );
			for (j=j1;j<=j2;j++) {
				J_TO_V( j, v );
				gl_EvalCoord2f( ctx, u, v );
			}
			gl_End(ctx);
		}
		break;
	case GL_FILL:
		for (j=j1;j<j2;j++) {
			
			
			gl_Begin( ctx, GL_TRIANGLE_STRIP );
			J_TO_V( j, v1 );
			J_TO_V( j+1, v2 );
			for (i=i1;i<=i2;i++) {
				I_TO_U( i, u );
				gl_EvalCoord2f( ctx, u, v1 );
				gl_EvalCoord2f( ctx, u, v2 );
			}
			gl_End(ctx);
		}
		break;
	default:
		gl_error( ctx, GL_INVALID_ENUM, "glEvalMesh2(mode)" );
		return;
	}
#undef I_TO_U
#undef J_TO_V
}
/* 当前文件是D:\Read\feedback.c*/

#ifdef PC_HEADER
#else
#endif
#define FB_3D		0x01
#define FB_4D		0x02
#define FB_INDEX	0x04
#define FB_COLOR	0x08
#define FB_TEXTURE	0X10
void
gl_FeedbackBuffer( GLcontext *ctx, GLsizei size, GLenum type, float *buffer )
{
if (ctx->RenderMode==GL_FEEDBACK || INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glFeedbackBuffer" );
return;
}
if (size<0) {
gl_error( ctx, GL_INVALID_VALUE, "glFeedbackBuffer(size<0)" );
return;
}
if (!buffer) {
gl_error( ctx, GL_INVALID_VALUE, "glFeedbackBuffer(buffer==NULL)" );
ctx->Feedback.BufferSize = 0;
return;
}
switch (type) {
case GL_2D:
	 ctx->Feedback.Mask = 0;
ctx->Feedback.Type = type;
	 break;
case GL_3D:
	 ctx->Feedback.Mask = FB_3D;
ctx->Feedback.Type = type;
	 break;
case GL_3D_COLOR:
	 ctx->Feedback.Mask = FB_3D
| (ctx->Visual->RGBAflag ? FB_COLOR : FB_INDEX);
ctx->Feedback.Type = type;
	 break;
case GL_3D_COLOR_TEXTURE:
	 ctx->Feedback.Mask = FB_3D
| (ctx->Visual->RGBAflag ? FB_COLOR : FB_INDEX)
	                   | FB_TEXTURE;
ctx->Feedback.Type = type;
	 break;
case GL_4D_COLOR_TEXTURE:
	 ctx->Feedback.Mask = FB_3D | FB_4D
| (ctx->Visual->RGBAflag ? FB_COLOR : FB_INDEX)
	                   | FB_TEXTURE;
ctx->Feedback.Type = type;
	 break;
default:
	 ctx->Feedback.Mask = 0;
gl_error( ctx, GL_INVALID_ENUM, "glFeedbackBuffer" );
}
ctx->Feedback.BufferSize = size;
ctx->Feedback.Buffer = buffer;
ctx->Feedback.Count = 0;
}
void gl_PassThrough( GLcontext *ctx, float token )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPassThrough" );
return;
}
if (ctx->RenderMode==GL_FEEDBACK) {
FEEDBACK_TOKEN( ctx, (float) GL_PASS_THROUGH_TOKEN );
FEEDBACK_TOKEN( ctx, token );
}
}
void gl_feedback_vertex( GLcontext *ctx,
float x, float y, float z, float w,
			 const float color[4], float index,
			 const float texcoord[4] )
{
FEEDBACK_TOKEN( ctx, x );
FEEDBACK_TOKEN( ctx, y );
if (ctx->Feedback.Mask & FB_3D) {
FEEDBACK_TOKEN( ctx, z );
}
if (ctx->Feedback.Mask & FB_4D) {
FEEDBACK_TOKEN( ctx, w );
}
if (ctx->Feedback.Mask & FB_INDEX) {
FEEDBACK_TOKEN( ctx, index );
}
if (ctx->Feedback.Mask & FB_COLOR) {
FEEDBACK_TOKEN( ctx, color[0] );
FEEDBACK_TOKEN( ctx, color[1] );
FEEDBACK_TOKEN( ctx, color[2] );
FEEDBACK_TOKEN( ctx, color[3] );
}
if (ctx->Feedback.Mask & FB_TEXTURE) {
FEEDBACK_TOKEN( ctx, texcoord[0] );
FEEDBACK_TOKEN( ctx, texcoord[1] );
FEEDBACK_TOKEN( ctx, texcoord[2] );
FEEDBACK_TOKEN( ctx, texcoord[3] );
}
}
void gl_SelectBuffer( GLcontext *ctx, GLsizei size, GLuint *buffer )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glSelectBuffer" );
}
if (ctx->RenderMode==GL_SELECT) {
gl_error( ctx, GL_INVALID_OPERATION, "glSelectBuffer" );
}
ctx->Select.Buffer = buffer;
ctx->Select.BufferSize = size;
ctx->Select.BufferCount = 0;
ctx->Select.HitFlag = GL_FALSE;
ctx->Select.HitMinZ = 1.0;
ctx->Select.HitMaxZ = 0.0;
}
void gl_InitNames( GLcontext *ctx )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glInitNames" );
}
ctx->Select.NameStackDepth = 0;
ctx->Select.HitFlag = GL_FALSE;
ctx->Select.HitMinZ = 1.0;
ctx->Select.HitMaxZ = 0.0;
}
#define WRITE_RECORD( CTX, V )					\
	if (CTX->Select.BufferCount < CTX->Select.BufferSize) {	\
	   CTX->Select.Buffer[CTX->Select.BufferCount] = (V);		\
	}							\
	CTX->Select.BufferCount++;
void gl_update_hitflag( GLcontext *ctx, float z )
{
ctx->Select.HitFlag = GL_TRUE;
if (z < ctx->Select.HitMinZ) {
ctx->Select.HitMinZ = z;
}
if (z > ctx->Select.HitMaxZ) {
ctx->Select.HitMaxZ = z;
}
}
static void write_hit_record( GLcontext *ctx )
{
GLuint i;
GLuint zmin, zmax, zscale = (~0u);
assert( ctx != NULL );
zmin = (GLuint) ((float) zscale * ctx->Select.HitMinZ);
zmax = (GLuint) ((float) zscale * ctx->Select.HitMaxZ);
WRITE_RECORD( ctx, ctx->Select.NameStackDepth );
WRITE_RECORD( ctx, zmin );
WRITE_RECORD( ctx, zmax );
for (i=0;i<ctx->Select.NameStackDepth;i++) {
WRITE_RECORD( ctx, ctx->Select.NameStack[i] );
}
ctx->Select.Hits++;
ctx->Select.HitFlag = GL_FALSE;
ctx->Select.HitMinZ = 1.0;
ctx->Select.HitMaxZ = -1.0;
}
void gl_LoadName( GLcontext *ctx, GLuint name )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glLoadName" );
return;
}
if (ctx->RenderMode!=GL_SELECT) {
return;
}
if (ctx->Select.NameStackDepth==0) {
gl_error( ctx, GL_INVALID_OPERATION, "glLoadName" );
return;
}
if (ctx->Select.HitFlag) {
write_hit_record( ctx );
}
if (ctx->Select.NameStackDepth<MAX_NAME_STACK_DEPTH) {
ctx->Select.NameStack[ctx->Select.NameStackDepth-1] = name;
}
else {
ctx->Select.NameStack[MAX_NAME_STACK_DEPTH-1] = name;
}
}
void gl_PushName( GLcontext *ctx, GLuint name )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPushName" );
return;
}
if (ctx->RenderMode!=GL_SELECT) {
return;
}
if (ctx->Select.HitFlag) {
write_hit_record( ctx );
}
if (ctx->Select.NameStackDepth<MAX_NAME_STACK_DEPTH) {
ctx->Select.NameStack[ctx->Select.NameStackDepth++] = name;
}
else {
gl_error( ctx, GL_STACK_OVERFLOW, "glPushName" );
}
}
void gl_PopName( GLcontext *ctx )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPopName" );
return;
}
if (ctx->RenderMode!=GL_SELECT) {
return;
}
if (ctx->Select.HitFlag) {
write_hit_record( ctx );
}
if (ctx->Select.NameStackDepth>0) {
ctx->Select.NameStackDepth--;
}
else {
gl_error( ctx, GL_STACK_UNDERFLOW, "glPopName" );
}
}
GLint gl_RenderMode( GLcontext *ctx, GLenum mode )
{
GLint result;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glRenderMode" );
}
switch (ctx->RenderMode) {
case GL_RENDER:
	 result = 0;
	 break;
case GL_SELECT:
	 if (ctx->Select.HitFlag) {
	    write_hit_record( ctx );
	 }
	 if (ctx->Select.BufferCount > ctx->Select.BufferSize) {
	
#ifdef DEBUG
gl_warning(ctx, "Feedback buffer overflow");
#endif
	    result = -1;
	 }
	 else {
	    result = ctx->Select.Hits;
	 }
	 ctx->Select.BufferCount = 0;
	 ctx->Select.Hits = 0;
	 ctx->Select.NameStackDepth = 0;
	 break;
case GL_FEEDBACK:
	 if (ctx->Feedback.Count > ctx->Feedback.BufferSize) {
	
	    result = -1;
	 }
	 else {
	    result = ctx->Feedback.Count;
	 }
	 ctx->Feedback.Count = 0;
	 break;
default:
	 gl_error( ctx, GL_INVALID_ENUM, "glRenderMode" );
	 return 0;
}
switch (mode) {
case GL_RENDER:
break;
case GL_SELECT:
	 if (ctx->Select.BufferSize==0) {
	
	    gl_error( ctx, GL_INVALID_OPERATION, "glRenderMode" );
	 }
	 break;
case GL_FEEDBACK:
	 if (ctx->Feedback.BufferSize==0) {
	
	    gl_error( ctx, GL_INVALID_OPERATION, "glRenderMode" );
	 }
	 break;
default:
	 gl_error( ctx, GL_INVALID_ENUM, "glRenderMode" );
	 return 0;
}
ctx->RenderMode = mode;
ctx->NewState |= NEW_ALL;
return result;
}
/* 当前文件是D:\Read\fog.c*/

#ifdef PC_HEADER
#else
#endif
void gl_Fogfv( GLcontext *ctx, GLenum pname, const float *params )
{
GLenum m;
switch (pname) {
case GL_FOG_MODE:
m = (GLenum) (GLint) *params;
	 if (m==GL_LINEAR || m==GL_EXP || m==GL_EXP2) {
	    ctx->Fog.Mode = m;
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glFog" );
	 }
	 break;
case GL_FOG_DENSITY:
	 if (*params<0.0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glFog" );
	 }
	 else {
	    ctx->Fog.Density = *params;
	 }
	 break;
case GL_FOG_START:
#ifndef GL_VERSION_1_1
if (*params<0.0F) {
gl_error( ctx, GL_INVALID_VALUE, "glFog(GL_FOG_START)" );
return;
}
#endif
	 ctx->Fog.Start = *params;
	 break;
case GL_FOG_END:
#ifndef GL_VERSION_1_1
if (*params<0.0F) {
gl_error( ctx, GL_INVALID_VALUE, "glFog(GL_FOG_END)" );
return;
}
#endif
	 ctx->Fog.End = *params;
	 break;
case GL_FOG_INDEX:
	 ctx->Fog.Index = *params;
	 break;
case GL_FOG_COLOR:
	 ctx->Fog.Color[0] = params[0];
	 ctx->Fog.Color[1] = params[1];
	 ctx->Fog.Color[2] = params[2];
	 ctx->Fog.Color[3] = params[3];
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glFog" );
}
}
void gl_fog_color_vertices( GLcontext *ctx,
GLuint n, float v[][4], GLubyte color[][4] )
{
GLuint i;
float d;
float fogr = ctx->Fog.Color[0] * ctx->Visual->RedScale;
float fogg = ctx->Fog.Color[1] * ctx->Visual->GreenScale;
float fogb = ctx->Fog.Color[2] * ctx->Visual->BlueScale;
float end = ctx->Fog.End;
switch (ctx->Fog.Mode) {
case GL_LINEAR:
d = 1.0F / (ctx->Fog.End - ctx->Fog.Start);
for (i=0;i<n;i++) {
float f = (end - ABSF(v[i][2])) * d;
f = CLAMP( f, 0.0F, 1.0F );
color[i][0] = f * color[i][0] + (1.0F-f) * fogr;
color[i][1] = f * color[i][1] + (1.0F-f) * fogg;
color[i][2] = f * color[i][2] + (1.0F-f) * fogb;
}
	 break;
case GL_EXP:
d = -ctx->Fog.Density;
for (i=0;i<n;i++) {
float f = exp( d * ABSF(v[i][2]) );
f = CLAMP( f, 0.0F, 1.0F );
color[i][0] = f * color[i][0] + (1.0F-f) * fogr;
color[i][1] = f * color[i][1] + (1.0F-f) * fogg;
color[i][2] = f * color[i][2] + (1.0F-f) * fogb;
}
	 break;
case GL_EXP2:
d = -(ctx->Fog.Density*ctx->Fog.Density);
for (i=0;i<n;i++) {
float z = ABSF(v[i][2]);
float f = exp( d * z*z );
f = CLAMP( f, 0.0F, 1.0F );
color[i][0] = f * color[i][0] + (1.0F-f) * fogr;
color[i][1] = f * color[i][1] + (1.0F-f) * fogg;
color[i][2] = f * color[i][2] + (1.0F-f) * fogb;
}
	 break;
default:
gl_problem(ctx, "Bad fog mode in gl_fog_color_vertices");
return;
}
}
void gl_fog_index_vertices( GLcontext *ctx,
GLuint n, float v[][4], GLuint indx[] )
{
switch (ctx->Fog.Mode) {
case GL_LINEAR:
{
float d = 1.0F / (ctx->Fog.End - ctx->Fog.Start);
float fogindex = ctx->Fog.Index;
float fogend = ctx->Fog.End;
GLuint i;
for (i=0;i<n;i++) {
float f = (fogend - ABSF(v[i][2])) * d;
f = CLAMP( f, 0.0F, 1.0F );
indx[i] = (GLint)
((float) (GLint) indx[i] + (1.0F-f) * fogindex);
}
}
	 break;
case GL_EXP:
{
float d = -ctx->Fog.Density;
float fogindex = ctx->Fog.Index;
GLuint i;
for (i=0;i<n;i++) {
float f = exp( d * ABSF(v[i][2]) );
f = CLAMP( f, 0.0F, 1.0F );
indx[i] = (GLint)
((float) (GLint) indx[i] + (1.0F-f) * fogindex);
}
}
	 break;
case GL_EXP2:
{
float d = -(ctx->Fog.Density*ctx->Fog.Density);
float fogindex = ctx->Fog.Index;
GLuint i;
for (i=0;i<n;i++) {
float z = ABSF(v[i][2]);
float f = exp( -d * z*z );
f = CLAMP( f, 0.0F, 1.0F );
indx[i] = (GLint)
((float) (GLint) indx[i] + (1.0F-f) * fogindex);
}
}
	 break;
default:
gl_problem(ctx, "Bad fog mode in gl_fog_index_vertices");
return;
}
}
void gl_fog_color_pixels( GLcontext *ctx,
GLuint n, const GLdepth z[], GLubyte red[],
			  GLubyte green[], GLubyte blue[], GLubyte alpha[] )
{
float c = ctx->ProjectionMatrix[10];
float d = ctx->ProjectionMatrix[14];
GLuint i;
float fog_red   = ctx->Fog.Color[0] * ctx->Visual->RedScale;
float fog_green = ctx->Fog.Color[1] * ctx->Visual->GreenScale;
float fog_blue  = ctx->Fog.Color[2] * ctx->Visual->BlueScale;
float tz = ctx->Viewport.Tz;
float szInv = 1.0F / ctx->Viewport.Sz;
switch (ctx->Fog.Mode) {
case GL_LINEAR:
{
float fogEnd = ctx->Fog.End;
float fogScale = 1.0F / (ctx->Fog.End - ctx->Fog.Start);
for (i=0;i<n;i++) {
float ndcz = ((float) z[i] - tz) * szInv;
float eyez = -d / (c+ndcz);
float f, g;
if (eyez < 0.0)  eyez = -eyez;
f = (fogEnd - eyez) * fogScale;
f = CLAMP( f, 0.0F, 1.0F );
g = 1.0F - f;
red[i]   = (GLint) (f * (float) red[i]   + g * fog_red);
green[i] = (GLint) (f * (float) green[i] + g * fog_green);
blue[i]  = (GLint) (f * (float) blue[i]  + g * fog_blue);
}
}
	 break;
case GL_EXP:
	 for (i=0;i<n;i++) {
	    float ndcz = ((float) z[i] - tz) * szInv;
	    float eyez = -d / (c+ndcz);
float f, g;
	    if (eyez < 0.0)  eyez = -eyez;
	    f = exp( -ctx->Fog.Density * eyez );
	    f = CLAMP( f, 0.0F, 1.0F );
g = 1.0F - f;
red[i]   = (GLint) (f * (float) red[i]   + g * fog_red);
green[i] = (GLint) (f * (float) green[i] + g * fog_green);
blue[i]  = (GLint) (f * (float) blue[i]  + g * fog_blue);
	 }
	 break;
case GL_EXP2:
{
float negDensitySquared = -ctx->Fog.Density * ctx->Fog.Density;
for (i=0;i<n;i++) {
float ndcz = ((float) z[i] - tz) * szInv;
float eyez = -d / (c+ndcz);
float f, g;
if (eyez < 0.0)  eyez = -eyez;
f = exp( negDensitySquared * eyez*eyez );
f = CLAMP( f, 0.0F, 1.0F );
g = 1.0F - f;
red[i]   = (GLint) (f * (float) red[i]   + g * fog_red);
green[i] = (GLint) (f * (float) green[i] + g * fog_green);
blue[i]  = (GLint) (f * (float) blue[i]  + g * fog_blue);
}
}
	 break;
default:
gl_problem(ctx, "Bad fog mode in gl_fog_color_pixels");
return;
}
}
void gl_fog_index_pixels( GLcontext *ctx,
GLuint n, const GLdepth z[], GLuint index[] )
{
float c = ctx->ProjectionMatrix[10];
float d = ctx->ProjectionMatrix[14];
GLuint i;
float tz = ctx->Viewport.Tz;
float szInv = 1.0F / ctx->Viewport.Sz;
switch (ctx->Fog.Mode) {
case GL_LINEAR:
{
float fogEnd = ctx->Fog.End;
float fogScale = 1.0F / (ctx->Fog.End - ctx->Fog.Start);
for (i=0;i<n;i++) {
float ndcz = ((float) z[i] - tz) * szInv;
float eyez = -d / (c+ndcz);
float f;
if (eyez < 0.0)  eyez = -eyez;
f = (fogEnd - eyez) * fogScale;
f = CLAMP( f, 0.0F, 1.0F );
index[i] = (GLuint) ((float) index[i] + (1.0F-f) * ctx->Fog.Index);
}
	 }
	 break;
case GL_EXP:
for (i=0;i<n;i++) {
	    float ndcz = ((float) z[i] - tz) * szInv;
	    float eyez = -d / (c+ndcz);
float f;
	    if (eyez < 0.0)  eyez = -eyez;
	    f = exp( -ctx->Fog.Density * eyez );
	    f = CLAMP( f, 0.0F, 1.0F );
	    index[i] = (GLuint) ((float) index[i] + (1.0F-f) * ctx->Fog.Index);
	 }
	 break;
case GL_EXP2:
{
float negDensitySquared = -ctx->Fog.Density * ctx->Fog.Density;
for (i=0;i<n;i++) {
float ndcz = ((float) z[i] - tz) * szInv;
float eyez = -d / (c+ndcz);
float f;
if (eyez < 0.0)  eyez = -eyez;
f = exp( negDensitySquared * eyez*eyez );
f = CLAMP( f, 0.0F, 1.0F );
index[i] = (GLuint) ((float) index[i] + (1.0F-f) * ctx->Fog.Index);
}
	 }
	 break;
default:
gl_problem(ctx, "Bad fog mode in gl_fog_index_pixels");
return;
}
}
/* 当前文件是D:\Read\get.c*/

#ifdef PC_HEADER
#else
#endif
#define FLOAT_TO_BOOL(X)	( (X)==0.0F ? GL_FALSE : GL_TRUE )
#define INT_TO_BOOL(I)		( (I)==0 ? GL_FALSE : GL_TRUE )
#define ENUM_TO_BOOL(E)		( (E)==0 ? GL_FALSE : GL_TRUE )
void gl_GetBooleanv( GLcontext *ctx, GLenum pname, GLboolean *params )
{
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetBooleanv" );
return;
}
switch (pname) {
case GL_ACCUM_RED_BITS:
case GL_ACCUM_GREEN_BITS:
case GL_ACCUM_BLUE_BITS:
case GL_ACCUM_ALPHA_BITS:
*params = INT_TO_BOOL(ctx->Visual->AccumBits);
break;
case GL_ACCUM_CLEAR_VALUE:
params[0] = FLOAT_TO_BOOL(ctx->Accum.ClearColor[0]);
params[1] = FLOAT_TO_BOOL(ctx->Accum.ClearColor[1]);
params[2] = FLOAT_TO_BOOL(ctx->Accum.ClearColor[2]);
params[3] = FLOAT_TO_BOOL(ctx->Accum.ClearColor[3]);
break;
case GL_ALPHA_BIAS:
*params = FLOAT_TO_BOOL(ctx->Pixel.AlphaBias);
break;
case GL_ALPHA_BITS:
*params = INT_TO_BOOL(ctx->Visual->AlphaBits);
break;
case GL_ALPHA_SCALE:
*params = FLOAT_TO_BOOL(ctx->Pixel.AlphaScale);
break;
case GL_ALPHA_TEST:
*params = ctx->Color.AlphaEnabled;
break;
case GL_ALPHA_TEST_FUNC:
*params = ENUM_TO_BOOL(ctx->Color.AlphaFunc);
break;
case GL_ALPHA_TEST_REF:
*params = FLOAT_TO_BOOL(ctx->Color.AlphaRef);
break;
case GL_ATTRIB_STACK_DEPTH:
*params = INT_TO_BOOL(ctx->AttribStackDepth);
break;
case GL_AUTO_NORMAL:
*params = ctx->Eval.AutoNormal;
break;
case GL_AUX_BUFFERS:
*params = (NUM_AUX_BUFFERS) ? GL_TRUE : GL_FALSE;
break;
case GL_BLEND:
*params = ctx->Color.BlendEnabled;
break;
case GL_BLEND_DST:
*params = ENUM_TO_BOOL(ctx->Color.BlendDst);
break;
case GL_BLEND_SRC:
*params = ENUM_TO_BOOL(ctx->Color.BlendSrc);
break;
case GL_BLEND_EQUATION_EXT:
	 *params = ENUM_TO_BOOL( ctx->Color.BlendEquation );
	 break;
case GL_BLEND_COLOR_EXT:
	 params[0] = FLOAT_TO_BOOL( ctx->Color.BlendColor[0] );
	 params[1] = FLOAT_TO_BOOL( ctx->Color.BlendColor[1] );
	 params[2] = FLOAT_TO_BOOL( ctx->Color.BlendColor[2] );
	 params[3] = FLOAT_TO_BOOL( ctx->Color.BlendColor[3] );
	 break;
case GL_BLUE_BIAS:
*params = FLOAT_TO_BOOL(ctx->Pixel.BlueBias);
break;
case GL_BLUE_BITS:
*params = INT_TO_BOOL( ctx->Visual->BlueBits );
break;
case GL_BLUE_SCALE:
*params = FLOAT_TO_BOOL(ctx->Pixel.BlueScale);
break;
case GL_CLIENT_ATTRIB_STACK_DEPTH:
*params = INT_TO_BOOL(ctx->ClientAttribStackDepth);
break;
case GL_CLIP_PLANE0:
case GL_CLIP_PLANE1:
case GL_CLIP_PLANE2:
case GL_CLIP_PLANE3:
case GL_CLIP_PLANE4:
case GL_CLIP_PLANE5:
*params = ctx->Transform.ClipEnabled[pname-GL_CLIP_PLANE0];
break;
case GL_COLOR_CLEAR_VALUE:
params[0] = FLOAT_TO_BOOL(ctx->Color.ClearColor[0]);
params[1] = FLOAT_TO_BOOL(ctx->Color.ClearColor[1]);
params[2] = FLOAT_TO_BOOL(ctx->Color.ClearColor[2]);
params[3] = FLOAT_TO_BOOL(ctx->Color.ClearColor[3]);
break;
case GL_COLOR_MATERIAL:
*params = ctx->Light.ColorMaterialEnabled;
break;
case GL_COLOR_MATERIAL_FACE:
*params = ENUM_TO_BOOL(ctx->Light.ColorMaterialFace);
break;
case GL_COLOR_MATERIAL_PARAMETER:
*params = ENUM_TO_BOOL(ctx->Light.ColorMaterialMode);
break;
case GL_COLOR_WRITEMASK:
params[0] = (ctx->Color.ColorMask & 8) ? GL_TRUE : GL_FALSE;
params[1] = (ctx->Color.ColorMask & 4) ? GL_TRUE : GL_FALSE;
params[2] = (ctx->Color.ColorMask & 2) ? GL_TRUE : GL_FALSE;
params[3] = (ctx->Color.ColorMask & 1) ? GL_TRUE : GL_FALSE;
break;
case GL_CULL_FACE:
*params = ctx->Polygon.CullFlag;
break;
case GL_CULL_FACE_MODE:
*params = ENUM_TO_BOOL(ctx->Polygon.CullFaceMode);
break;
case GL_CURRENT_COLOR:
params[0] = INT_TO_BOOL(ctx->Current.ByteColor[0]);
params[1] = INT_TO_BOOL(ctx->Current.ByteColor[1]);
params[2] = INT_TO_BOOL(ctx->Current.ByteColor[2]);
params[3] = INT_TO_BOOL(ctx->Current.ByteColor[3]);
break;
case GL_CURRENT_INDEX:
*params = INT_TO_BOOL(ctx->Current.Index);
break;
case GL_CURRENT_NORMAL:
params[0] = FLOAT_TO_BOOL(ctx->Current.Normal[0]);
params[1] = FLOAT_TO_BOOL(ctx->Current.Normal[1]);
params[2] = FLOAT_TO_BOOL(ctx->Current.Normal[2]);
break;
case GL_CURRENT_RASTER_COLOR:
	 params[0] = FLOAT_TO_BOOL(ctx->Current.RasterColor[0]);
	 params[1] = FLOAT_TO_BOOL(ctx->Current.RasterColor[1]);
	 params[2] = FLOAT_TO_BOOL(ctx->Current.RasterColor[2]);
	 params[3] = FLOAT_TO_BOOL(ctx->Current.RasterColor[3]);
	 break;
case GL_CURRENT_RASTER_DISTANCE:
	 *params = FLOAT_TO_BOOL(ctx->Current.RasterDistance);
	 break;
case GL_CURRENT_RASTER_INDEX:
	 *params = FLOAT_TO_BOOL(ctx->Current.RasterIndex);
	 break;
case GL_CURRENT_RASTER_POSITION:
	 params[0] = FLOAT_TO_BOOL(ctx->Current.RasterPos[0]);
	 params[1] = FLOAT_TO_BOOL(ctx->Current.RasterPos[1]);
	 params[2] = FLOAT_TO_BOOL(ctx->Current.RasterPos[2]);
	 params[3] = FLOAT_TO_BOOL(ctx->Current.RasterPos[3]);
	 break;
case GL_CURRENT_RASTER_TEXTURE_COORDS:
params[0] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoord[0]);
params[1] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoord[1]);
params[2] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoord[2]);
params[3] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoord[3]);
	 break;
case GL_CURRENT_RASTER_POSITION_VALID:
*params = ctx->Current.RasterPosValid;
	 break;
case GL_CURRENT_TEXTURE_COORDS:
params[0] = FLOAT_TO_BOOL(ctx->Current.TexCoord[0]);
params[1] = FLOAT_TO_BOOL(ctx->Current.TexCoord[1]);
params[2] = FLOAT_TO_BOOL(ctx->Current.TexCoord[2]);
params[3] = FLOAT_TO_BOOL(ctx->Current.TexCoord[3]);
	 break;
case GL_DEPTH_BIAS:
*params = FLOAT_TO_BOOL(ctx->Pixel.DepthBias);
	 break;
case GL_DEPTH_BITS:
	 *params = INT_TO_BOOL(ctx->Visual->DepthBits);
	 break;
case GL_DEPTH_CLEAR_VALUE:
*params = FLOAT_TO_BOOL(ctx->Depth.Clear);
	 break;
case GL_DEPTH_FUNC:
*params = ENUM_TO_BOOL(ctx->Depth.Func);
	 break;
case GL_DEPTH_RANGE:
params[0] = FLOAT_TO_BOOL(ctx->Viewport.Near);
params[1] = FLOAT_TO_BOOL(ctx->Viewport.Far);
	 break;
case GL_DEPTH_SCALE:
*params = FLOAT_TO_BOOL(ctx->Pixel.DepthScale);
	 break;
case GL_DEPTH_TEST:
*params = ctx->Depth.Test;
	 break;
case GL_DEPTH_WRITEMASK:
	 *params = ctx->Depth.Mask;
	 break;
case GL_DITHER:
	 *params = ctx->Color.DitherFlag;
	 break;
case GL_DOUBLEBUFFER:
	 *params = ctx->Visual->DBflag;
	 break;
case GL_DRAW_BUFFER:
	 *params = ENUM_TO_BOOL(ctx->Color.DrawBuffer);
	 break;
case GL_EDGE_FLAG:
	 *params = ctx->Current.EdgeFlag;
	 break;
case GL_FEEDBACK_BUFFER_SIZE:
*params = INT_TO_BOOL(ctx->Feedback.BufferSize);
break;
case GL_FEEDBACK_BUFFER_TYPE:
*params = INT_TO_BOOL(ctx->Feedback.Type);
break;
case GL_FOG:
	 *params = ctx->Fog.Enabled;
	 break;
case GL_FOG_COLOR:
params[0] = FLOAT_TO_BOOL(ctx->Fog.Color[0]);
params[1] = FLOAT_TO_BOOL(ctx->Fog.Color[1]);
params[2] = FLOAT_TO_BOOL(ctx->Fog.Color[2]);
params[3] = FLOAT_TO_BOOL(ctx->Fog.Color[3]);
	 break;
case GL_FOG_DENSITY:
*params = FLOAT_TO_BOOL(ctx->Fog.Density);
	 break;
case GL_FOG_END:
*params = FLOAT_TO_BOOL(ctx->Fog.End);
	 break;
case GL_FOG_HINT:
	 *params = ENUM_TO_BOOL(ctx->Hint.Fog);
	 break;
case GL_FOG_INDEX:
	 *params = FLOAT_TO_BOOL(ctx->Fog.Index);
	 break;
case GL_FOG_MODE:
	 *params = ENUM_TO_BOOL(ctx->Fog.Mode);
	 break;
case GL_FOG_START:
*params = FLOAT_TO_BOOL(ctx->Fog.End);
	 break;
case GL_FRONT_FACE:
	 *params = ENUM_TO_BOOL(ctx->Polygon.FrontFace);
	 break;
case GL_GREEN_BIAS:
*params = FLOAT_TO_BOOL(ctx->Pixel.GreenBias);
	 break;
case GL_GREEN_BITS:
*params = INT_TO_BOOL( ctx->Visual->GreenBits );
	 break;
case GL_GREEN_SCALE:
*params = FLOAT_TO_BOOL(ctx->Pixel.GreenScale);
	 break;
case GL_INDEX_BITS:
*params = INT_TO_BOOL( ctx->Visual->IndexBits );
	 break;
case GL_INDEX_CLEAR_VALUE:
	 *params = INT_TO_BOOL(ctx->Color.ClearIndex);
	 break;
case GL_INDEX_MODE:
	 *params = ctx->Visual->RGBAflag ? GL_FALSE : GL_TRUE;
	 break;
case GL_INDEX_OFFSET:
	 *params = INT_TO_BOOL(ctx->Pixel.IndexOffset);
	 break;
case GL_INDEX_SHIFT:
	 *params = INT_TO_BOOL(ctx->Pixel.IndexShift);
	 break;
case GL_INDEX_WRITEMASK:
	 *params = INT_TO_BOOL(ctx->Color.IndexMask);
	 break;
case GL_LIGHT0:
case GL_LIGHT1:
case GL_LIGHT2:
case GL_LIGHT3:
case GL_LIGHT4:
case GL_LIGHT5:
case GL_LIGHT6:
case GL_LIGHT7:
	 *params = ctx->Light.Light[pname-GL_LIGHT0].Enabled;
	 break;
case GL_LIGHTING:
	 *params = ctx->Light.Enabled;
	 break;
case GL_LIGHT_MODEL_AMBIENT:
	 params[0] = FLOAT_TO_BOOL(ctx->Light.Model.Ambient[0]);
	 params[1] = FLOAT_TO_BOOL(ctx->Light.Model.Ambient[1]);
	 params[2] = FLOAT_TO_BOOL(ctx->Light.Model.Ambient[2]);
	 params[3] = FLOAT_TO_BOOL(ctx->Light.Model.Ambient[3]);
	 break;
case GL_LIGHT_MODEL_LOCAL_VIEWER:
	 *params = ctx->Light.Model.LocalViewer;
	 break;
case GL_LIGHT_MODEL_TWO_SIDE:
	 *params = ctx->Light.Model.TwoSide;
	 break;
case GL_LINE_SMOOTH:
	 *params = ctx->Line.SmoothFlag;
	 break;
case GL_LINE_SMOOTH_HINT:
	 *params = ENUM_TO_BOOL(ctx->Hint.LineSmooth);
	 break;
case GL_LINE_STIPPLE:
	 *params = ctx->Line.StippleFlag;
	 break;
case GL_LINE_STIPPLE_PATTERN:
	 *params = INT_TO_BOOL(ctx->Line.StipplePattern);
	 break;
case GL_LINE_STIPPLE_REPEAT:
	 *params = INT_TO_BOOL(ctx->Line.StippleFactor);
	 break;
case GL_LINE_WIDTH:
	 *params = FLOAT_TO_BOOL(ctx->Line.Width);
	 break;
case GL_LINE_WIDTH_GRANULARITY:
	 *params = FLOAT_TO_BOOL(LINE_WIDTH_GRANULARITY);
	 break;
case GL_LINE_WIDTH_RANGE:
	 params[0] = FLOAT_TO_BOOL(MIN_LINE_WIDTH);
	 params[1] = FLOAT_TO_BOOL(MAX_LINE_WIDTH);
	 break;
case GL_LIST_BASE:
	 *params = INT_TO_BOOL(ctx->List.ListBase);
	 break;
case GL_LIST_INDEX:
	 *params = INT_TO_BOOL( gl_list_index() );
	 break;
case GL_LIST_MODE:
	 *params = ENUM_TO_BOOL( ctx->ExecuteFlag
				  ? GL_COMPILE_AND_EXECUTE : GL_COMPILE );
	 break;
case GL_INDEX_LOGIC_OP:
	 *params = ctx->Color.IndexLogicOpEnabled;
	 break;
case GL_COLOR_LOGIC_OP:
	 *params = ctx->Color.ColorLogicOpEnabled;
	 break;
case GL_LOGIC_OP_MODE:
	 *params = ENUM_TO_BOOL(ctx->Color.LogicOp);
	 break;
case GL_MAP1_COLOR_4:
	 *params = ctx->Eval.Map1Color4;
	 break;
case GL_MAP1_GRID_DOMAIN:
	 params[0] = FLOAT_TO_BOOL(ctx->Eval.MapGrid1u1);
	 params[1] = FLOAT_TO_BOOL(ctx->Eval.MapGrid1u2);
	 break;
case GL_MAP1_GRID_SEGMENTS:
	 *params = INT_TO_BOOL(ctx->Eval.MapGrid1un);
	 break;
case GL_MAP1_INDEX:
	 *params = ctx->Eval.Map1Index;
	 break;
case GL_MAP1_NORMAL:
	 *params = ctx->Eval.Map1Normal;
	 break;
case GL_MAP1_TEXTURE_COORD_1:
	 *params = ctx->Eval.Map1TextureCoord1;
	 break;
case GL_MAP1_TEXTURE_COORD_2:
	 *params = ctx->Eval.Map1TextureCoord2;
	 break;
case GL_MAP1_TEXTURE_COORD_3:
	 *params = ctx->Eval.Map1TextureCoord3;
	 break;
case GL_MAP1_TEXTURE_COORD_4:
	 *params = ctx->Eval.Map1TextureCoord4;
	 break;
case GL_MAP1_VERTEX_3:
	 *params = ctx->Eval.Map1Vertex3;
	 break;
case GL_MAP1_VERTEX_4:
	 *params = ctx->Eval.Map1Vertex4;
	 break;
case GL_MAP2_COLOR_4:
	 *params = ctx->Eval.Map2Color4;
	 break;
case GL_MAP2_GRID_DOMAIN:
	 params[0] = FLOAT_TO_BOOL(ctx->Eval.MapGrid2u1);
	 params[1] = FLOAT_TO_BOOL(ctx->Eval.MapGrid2u2);
	 params[2] = FLOAT_TO_BOOL(ctx->Eval.MapGrid2v1);
	 params[3] = FLOAT_TO_BOOL(ctx->Eval.MapGrid2v2);
	 break;
case GL_MAP2_GRID_SEGMENTS:
	 params[0] = INT_TO_BOOL(ctx->Eval.MapGrid2un);
	 params[1] = INT_TO_BOOL(ctx->Eval.MapGrid2vn);
	 break;
case GL_MAP2_INDEX:
	 *params = ctx->Eval.Map2Index;
	 break;
case GL_MAP2_NORMAL:
	 *params = ctx->Eval.Map2Normal;
	 break;
case GL_MAP2_TEXTURE_COORD_1:
	 *params = ctx->Eval.Map2TextureCoord1;
	 break;
case GL_MAP2_TEXTURE_COORD_2:
	 *params = ctx->Eval.Map2TextureCoord2;
	 break;
case GL_MAP2_TEXTURE_COORD_3:
	 *params = ctx->Eval.Map2TextureCoord3;
	 break;
case GL_MAP2_TEXTURE_COORD_4:
	 *params = ctx->Eval.Map2TextureCoord4;
	 break;
case GL_MAP2_VERTEX_3:
	 *params = ctx->Eval.Map2Vertex3;
	 break;
case GL_MAP2_VERTEX_4:
	 *params = ctx->Eval.Map2Vertex4;
	 break;
case GL_MAP_COLOR:
	 *params = ctx->Pixel.MapColorFlag;
	 break;
case GL_MAP_STENCIL:
	 *params = ctx->Pixel.MapStencilFlag;
	 break;
case GL_MATRIX_MODE:
	 *params = ENUM_TO_BOOL( ctx->Transform.MatrixMode );
	 break;
case GL_MAX_ATTRIB_STACK_DEPTH:
	 *params = INT_TO_BOOL(MAX_ATTRIB_STACK_DEPTH);
	 break;
case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
*params = INT_TO_BOOL( MAX_CLIENT_ATTRIB_STACK_DEPTH);
break;
case GL_MAX_CLIP_PLANES:
	 *params = INT_TO_BOOL(MAX_CLIP_PLANES);
	 break;
case GL_MAX_EVAL_ORDER:
	 *params = INT_TO_BOOL(MAX_EVAL_ORDER);
	 break;
case GL_MAX_LIGHTS:
	 *params = INT_TO_BOOL(MAX_LIGHTS);
	 break;
case GL_MAX_LIST_NESTING:
	 *params = INT_TO_BOOL(MAX_LIST_NESTING);
	 break;
case GL_MAX_MODELVIEW_STACK_DEPTH:
	 *params = INT_TO_BOOL(MAX_MODELVIEW_STACK_DEPTH);
	 break;
case GL_MAX_NAME_STACK_DEPTH:
	 *params = INT_TO_BOOL(MAX_NAME_STACK_DEPTH);
	 break;
case GL_MAX_PIXEL_MAP_TABLE:
	 *params = INT_TO_BOOL(MAX_PIXEL_MAP_TABLE);
	 break;
case GL_MAX_PROJECTION_STACK_DEPTH:
	 *params = INT_TO_BOOL(MAX_PROJECTION_STACK_DEPTH);
	 break;
case GL_MAX_TEXTURE_SIZE:
	 *params = INT_TO_BOOL(MAX_TEXTURE_SIZE);
	 break;
case GL_MAX_TEXTURE_STACK_DEPTH:
	 *params = INT_TO_BOOL(MAX_TEXTURE_STACK_DEPTH);
	 break;
case GL_MAX_VIEWPORT_DIMS:
	 params[0] = INT_TO_BOOL(MAX_WIDTH);
	 params[1] = INT_TO_BOOL(MAX_HEIGHT);
	 break;
case GL_MODELVIEW_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = FLOAT_TO_BOOL(ctx->ModelViewMatrix[i]);
	 }
	 break;
case GL_MODELVIEW_STACK_DEPTH:
	 *params = INT_TO_BOOL(ctx->ModelViewStackDepth);
	 break;
case GL_NAME_STACK_DEPTH:
	 *params = INT_TO_BOOL(ctx->Select.NameStackDepth);
	 break;
case GL_NORMALIZE:
	 *params = ctx->Transform.Normalize;
	 break;
case GL_PACK_ALIGNMENT:
	 *params = INT_TO_BOOL(ctx->Pack.Alignment);
	 break;
case GL_PACK_LSB_FIRST:
	 *params = ctx->Pack.LsbFirst;
	 break;
case GL_PACK_ROW_LENGTH:
	 *params = INT_TO_BOOL(ctx->Pack.RowLength);
	 break;
case GL_PACK_SKIP_PIXELS:
	 *params = INT_TO_BOOL(ctx->Pack.SkipPixels);
	 break;
case GL_PACK_SKIP_ROWS:
	 *params = INT_TO_BOOL(ctx->Pack.SkipRows);
	 break;
case GL_PACK_SWAP_BYTES:
	 *params = ctx->Pack.SwapBytes;
	 break;
case GL_PACK_SKIP_IMAGES_EXT:
*params = ctx->Pack.SkipImages;
break;
case GL_PACK_IMAGE_HEIGHT_EXT:
*params = ctx->Pack.ImageHeight;
break;
case GL_PERSPECTIVE_CORRECTION_HINT:
	 *params = ENUM_TO_BOOL(ctx->Hint.PerspectiveCorrection);
	 break;
case GL_PIXEL_MAP_A_TO_A_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapAtoAsize);
	 break;
case GL_PIXEL_MAP_B_TO_B_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapBtoBsize);
	 break;
case GL_PIXEL_MAP_G_TO_G_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapGtoGsize);
	 break;
case GL_PIXEL_MAP_I_TO_A_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapItoAsize);
	 break;
case GL_PIXEL_MAP_I_TO_B_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapItoBsize);
	 break;
case GL_PIXEL_MAP_I_TO_G_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapItoGsize);
	 break;
case GL_PIXEL_MAP_I_TO_I_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapItoIsize);
	 break;
case GL_PIXEL_MAP_I_TO_R_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapItoRsize);
	 break;
case GL_PIXEL_MAP_R_TO_R_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapRtoRsize);
	 break;
case GL_PIXEL_MAP_S_TO_S_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapStoSsize);
	 break;
case GL_POINT_SIZE:
	 *params = FLOAT_TO_BOOL(ctx->Point.Size );
	 break;
case GL_POINT_SIZE_GRANULARITY:
	 *params = FLOAT_TO_BOOL(POINT_SIZE_GRANULARITY );
	 break;
case GL_POINT_SIZE_RANGE:
	 params[0] = FLOAT_TO_BOOL(MIN_POINT_SIZE );
	 params[1] = FLOAT_TO_BOOL(MAX_POINT_SIZE );
	 break;
case GL_POINT_SMOOTH:
	 *params = ctx->Point.SmoothFlag;
	 break;
case GL_POINT_SMOOTH_HINT:
	 *params = ENUM_TO_BOOL(ctx->Hint.PointSmooth);
	 break;
case GL_POINT_SIZE_MIN_EXT:
	 *params = FLOAT_TO_BOOL(ctx->Point.MinSize);
	 break;
case GL_POINT_SIZE_MAX_EXT:
	 *params = FLOAT_TO_BOOL(ctx->Point.MaxSize);
	 break;
case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
	 *params = FLOAT_TO_BOOL(ctx->Point.Threshold);
	 break;
case GL_DISTANCE_ATTENUATION_EXT:
	 params[0] = FLOAT_TO_BOOL(ctx->Point.Params[0]);
	 params[1] = FLOAT_TO_BOOL(ctx->Point.Params[1]);
	 params[2] = FLOAT_TO_BOOL(ctx->Point.Params[2]);
	 break;
case GL_POLYGON_MODE:
	 params[0] = ENUM_TO_BOOL(ctx->Polygon.FrontMode);
	 params[1] = ENUM_TO_BOOL(ctx->Polygon.BackMode);
	 break;
#ifdef GL_EXT_polygon_offset
case GL_POLYGON_OFFSET_BIAS_EXT:
*params = FLOAT_TO_BOOL( ctx->Polygon.OffsetUnits );
break;
#endif
case GL_POLYGON_OFFSET_FACTOR:
*params = FLOAT_TO_BOOL( ctx->Polygon.OffsetFactor );
break;
case GL_POLYGON_OFFSET_UNITS:
*params = FLOAT_TO_BOOL( ctx->Polygon.OffsetUnits );
break;
case GL_POLYGON_SMOOTH:
	 *params = ctx->Polygon.SmoothFlag;
	 break;
case GL_POLYGON_SMOOTH_HINT:
	 *params = ENUM_TO_BOOL(ctx->Hint.PolygonSmooth);
	 break;
case GL_POLYGON_STIPPLE:
	 *params = ctx->Polygon.StippleFlag;
	 break;
case GL_PROJECTION_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = FLOAT_TO_BOOL(ctx->ProjectionMatrix[i]);
	 }
	 break;
case GL_PROJECTION_STACK_DEPTH:
	 *params = INT_TO_BOOL(ctx->ProjectionStackDepth);
	 break;
case GL_READ_BUFFER:
	 *params = ENUM_TO_BOOL(ctx->Pixel.ReadBuffer);
	 break;
case GL_RED_BIAS:
*params = FLOAT_TO_BOOL(ctx->Pixel.RedBias);
	 break;
case GL_RED_BITS:
*params = INT_TO_BOOL( ctx->Visual->RedBits );
	 break;
case GL_RED_SCALE:
*params = FLOAT_TO_BOOL(ctx->Pixel.RedScale);
	 break;
case GL_RENDER_MODE:
	 *params = ENUM_TO_BOOL(ctx->RenderMode);
	 break;
case GL_RGBA_MODE:
*params = ctx->Visual->RGBAflag;
	 break;
case GL_SCISSOR_BOX:
	 params[0] = INT_TO_BOOL(ctx->Scissor.X);
	 params[1] = INT_TO_BOOL(ctx->Scissor.Y);
	 params[2] = INT_TO_BOOL(ctx->Scissor.Width);
	 params[3] = INT_TO_BOOL(ctx->Scissor.Height);
	 break;
case GL_SCISSOR_TEST:
	 *params = ctx->Scissor.Enabled;
	 break;
case GL_SHADE_MODEL:
	 *params = ENUM_TO_BOOL(ctx->Light.ShadeModel);
	 break;
case GL_SHARED_TEXTURE_PALETTE_EXT:
*params = ctx->Texture.SharedPalette;
break;
case GL_STENCIL_BITS:
	 *params = INT_TO_BOOL(ctx->Visual->StencilBits);
	 break;
case GL_STENCIL_CLEAR_VALUE:
	 *params = INT_TO_BOOL(ctx->Stencil.Clear);
	 break;
case GL_STENCIL_FAIL:
	 *params = ENUM_TO_BOOL(ctx->Stencil.FailFunc);
	 break;
case GL_STENCIL_FUNC:
	 *params = ENUM_TO_BOOL(ctx->Stencil.Function);
	 break;
case GL_STENCIL_PASS_DEPTH_FAIL:
	 *params = ENUM_TO_BOOL(ctx->Stencil.ZFailFunc);
	 break;
case GL_STENCIL_PASS_DEPTH_PASS:
	 *params = ENUM_TO_BOOL(ctx->Stencil.ZPassFunc);
	 break;
case GL_STENCIL_REF:
	 *params = INT_TO_BOOL(ctx->Stencil.Ref);
	 break;
case GL_STENCIL_TEST:
	 *params = ctx->Stencil.Enabled;
	 break;
case GL_STENCIL_VALUE_MASK:
	 *params = INT_TO_BOOL(ctx->Stencil.ValueMask);
	 break;
case GL_STENCIL_WRITEMASK:
	 *params = INT_TO_BOOL(ctx->Stencil.WriteMask);
	 break;
case GL_STEREO:
	 *params = GL_FALSE;
	 break;
case GL_SUBPIXEL_BITS:
	 *params = INT_TO_BOOL(0);
	 break;
case GL_TEXTURE_1D:
	 *params = (ctx->Texture.Enabled & TEXTURE_1D) ? GL_TRUE : GL_FALSE;
	 break;
case GL_TEXTURE_2D:
	 *params = (ctx->Texture.Enabled & TEXTURE_2D) ? GL_TRUE : GL_FALSE;
	 break;
case GL_TEXTURE_3D_EXT:
	 *params = (ctx->Texture.Enabled & TEXTURE_3D) ? GL_TRUE : GL_FALSE;
	 break;
case GL_TEXTURE_ENV_COLOR:
	 params[0] = FLOAT_TO_BOOL(ctx->Texture.EnvColor[0]);
	 params[1] = FLOAT_TO_BOOL(ctx->Texture.EnvColor[1]);
	 params[2] = FLOAT_TO_BOOL(ctx->Texture.EnvColor[2]);
	 params[3] = FLOAT_TO_BOOL(ctx->Texture.EnvColor[3]);
	 break;
case GL_TEXTURE_ENV_MODE:
	 *params = ENUM_TO_BOOL(ctx->Texture.EnvMode);
	 break;
case GL_TEXTURE_GEN_S:
	 *params = (ctx->Texture.TexGenEnabled & S_BIT) ? GL_TRUE : GL_FALSE;
	 break;
case GL_TEXTURE_GEN_T:
	 *params = (ctx->Texture.TexGenEnabled & T_BIT) ? GL_TRUE : GL_FALSE;
	 break;
case GL_TEXTURE_GEN_R:
	 *params = (ctx->Texture.TexGenEnabled & R_BIT) ? GL_TRUE : GL_FALSE;
	 break;
case GL_TEXTURE_GEN_Q:
	 *params = (ctx->Texture.TexGenEnabled & Q_BIT) ? GL_TRUE : GL_FALSE;
	 break;
case GL_TEXTURE_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = FLOAT_TO_BOOL(ctx->TextureMatrix[i]);
	 }
	 break;
case GL_TEXTURE_STACK_DEPTH:
	 *params = INT_TO_BOOL(ctx->TextureStackDepth);
	 break;
case GL_UNPACK_ALIGNMENT:
	 *params = INT_TO_BOOL(ctx->Unpack.Alignment);
	 break;
case GL_UNPACK_LSB_FIRST:
	 *params = ctx->Unpack.LsbFirst;
	 break;
case GL_UNPACK_ROW_LENGTH:
	 *params = INT_TO_BOOL(ctx->Unpack.RowLength);
	 break;
case GL_UNPACK_SKIP_PIXELS:
	 *params = INT_TO_BOOL(ctx->Unpack.SkipPixels);
	 break;
case GL_UNPACK_SKIP_ROWS:
	 *params = INT_TO_BOOL(ctx->Unpack.SkipRows);
	 break;
case GL_UNPACK_SWAP_BYTES:
	 *params = ctx->Unpack.SwapBytes;
	 break;
case GL_UNPACK_SKIP_IMAGES_EXT:
*params = ctx->Unpack.SkipImages;
break;
case GL_UNPACK_IMAGE_HEIGHT_EXT:
*params = ctx->Unpack.ImageHeight;
break;
case GL_VIEWPORT:
	 params[0] = INT_TO_BOOL(ctx->Viewport.X);
	 params[1] = INT_TO_BOOL(ctx->Viewport.Y);
	 params[2] = INT_TO_BOOL(ctx->Viewport.Width);
	 params[3] = INT_TO_BOOL(ctx->Viewport.Height);
	 break;
case GL_ZOOM_X:
	 *params = FLOAT_TO_BOOL(ctx->Pixel.ZoomX);
	 break;
case GL_ZOOM_Y:
	 *params = FLOAT_TO_BOOL(ctx->Pixel.ZoomY);
	 break;
case GL_VERTEX_ARRAY_SIZE:
*params = INT_TO_BOOL(ctx->Array.VertexSize);
break;
case GL_VERTEX_ARRAY_TYPE:
*params = ENUM_TO_BOOL(ctx->Array.VertexType);
break;
case GL_VERTEX_ARRAY_STRIDE:
*params = INT_TO_BOOL(ctx->Array.VertexStride);
break;
case GL_VERTEX_ARRAY_COUNT_EXT:
*params = INT_TO_BOOL(0);
break;
case GL_NORMAL_ARRAY_TYPE:
*params = ENUM_TO_BOOL(ctx->Array.NormalType);
break;
case GL_NORMAL_ARRAY_STRIDE:
*params = INT_TO_BOOL(ctx->Array.NormalStride);
break;
case GL_NORMAL_ARRAY_COUNT_EXT:
*params = INT_TO_BOOL(0);
break;
case GL_COLOR_ARRAY_SIZE:
*params = INT_TO_BOOL(ctx->Array.ColorSize);
break;
case GL_COLOR_ARRAY_TYPE:
*params = ENUM_TO_BOOL(ctx->Array.ColorType);
break;
case GL_COLOR_ARRAY_STRIDE:
*params = INT_TO_BOOL(ctx->Array.ColorStride);
break;
case GL_COLOR_ARRAY_COUNT_EXT:
*params = INT_TO_BOOL(0);
break;
case GL_INDEX_ARRAY_TYPE:
*params = ENUM_TO_BOOL(ctx->Array.IndexType);
break;
case GL_INDEX_ARRAY_STRIDE:
*params = INT_TO_BOOL(ctx->Array.IndexStride);
break;
case GL_INDEX_ARRAY_COUNT_EXT:
*params = INT_TO_BOOL(0);
break;
case GL_TEXTURE_COORD_ARRAY_SIZE:
*params = INT_TO_BOOL(ctx->Array.TexCoordSize);
break;
case GL_TEXTURE_COORD_ARRAY_TYPE:
*params = ENUM_TO_BOOL(ctx->Array.TexCoordType);
break;
case GL_TEXTURE_COORD_ARRAY_STRIDE:
*params = INT_TO_BOOL(ctx->Array.TexCoordStride);
break;
case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
*params = INT_TO_BOOL(0);
break;
case GL_EDGE_FLAG_ARRAY_STRIDE:
*params = INT_TO_BOOL(ctx->Array.EdgeFlagStride);
break;
case GL_EDGE_FLAG_ARRAY_EXT:
*params = INT_TO_BOOL(0);
break;
case GL_TEXTURE_BINDING_1D:
*params = INT_TO_BOOL(ctx->Texture.Current1D->Name);
break;
case GL_TEXTURE_BINDING_2D:
*params = INT_TO_BOOL(ctx->Texture.Current2D->Name);
break;
case GL_TEXTURE_3D_BINDING_EXT:
*params = INT_TO_BOOL(ctx->Texture.Current2D->Name);
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetBooleanv" );
}
}
void gl_GetDoublev( GLcontext *ctx, GLenum pname, GLdouble *params )
{
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetDoublev" );
return;
}
switch (pname) {
case GL_ACCUM_RED_BITS:
case GL_ACCUM_GREEN_BITS:
case GL_ACCUM_BLUE_BITS:
case GL_ACCUM_ALPHA_BITS:
*params = (GLdouble) ctx->Visual->AccumBits;
break;
case GL_ACCUM_CLEAR_VALUE:
params[0] = (GLdouble) ctx->Accum.ClearColor[0];
params[1] = (GLdouble) ctx->Accum.ClearColor[1];
params[2] = (GLdouble) ctx->Accum.ClearColor[2];
params[3] = (GLdouble) ctx->Accum.ClearColor[3];
break;
case GL_ALPHA_BIAS:
*params = (GLdouble) ctx->Pixel.AlphaBias;
break;
case GL_ALPHA_BITS:
*params = (GLdouble) ctx->Visual->AlphaBits;
break;
case GL_ALPHA_SCALE:
*params = (GLdouble) ctx->Pixel.AlphaScale;
break;
case GL_ALPHA_TEST:
*params = (GLdouble) ctx->Color.AlphaEnabled;
break;
case GL_ALPHA_TEST_FUNC:
*params = (GLdouble) ctx->Color.AlphaFunc;
break;
case GL_ALPHA_TEST_REF:
*params = (GLdouble) ctx->Color.AlphaRef;
break;
case GL_ATTRIB_STACK_DEPTH:
*params = (GLdouble ) ctx->AttribStackDepth;
break;
case GL_AUTO_NORMAL:
*params = (GLdouble) ctx->Eval.AutoNormal;
break;
case GL_AUX_BUFFERS:
*params = (GLdouble) NUM_AUX_BUFFERS;
break;
case GL_BLEND:
*params = (GLdouble) ctx->Color.BlendEnabled;
break;
case GL_BLEND_DST:
*params = (GLdouble) ctx->Color.BlendDst;
break;
case GL_BLEND_SRC:
*params = (GLdouble) ctx->Color.BlendSrc;
break;
case GL_BLEND_EQUATION_EXT:
	 *params = (GLdouble) ctx->Color.BlendEquation;
	 break;
case GL_BLEND_COLOR_EXT:
	 params[0] = (GLdouble) ctx->Color.BlendColor[0];
	 params[1] = (GLdouble) ctx->Color.BlendColor[1];
	 params[2] = (GLdouble) ctx->Color.BlendColor[2];
	 params[3] = (GLdouble) ctx->Color.BlendColor[3];
	 break;
case GL_BLUE_BIAS:
*params = (GLdouble) ctx->Pixel.BlueBias;
break;
case GL_BLUE_BITS:
*params = (GLdouble) ctx->Visual->BlueBits;
break;
case GL_BLUE_SCALE:
*params = (GLdouble) ctx->Pixel.BlueScale;
break;
case GL_CLIENT_ATTRIB_STACK_DEPTH:
*params = (GLdouble) ctx->ClientAttribStackDepth;
break;
case GL_CLIP_PLANE0:
case GL_CLIP_PLANE1:
case GL_CLIP_PLANE2:
case GL_CLIP_PLANE3:
case GL_CLIP_PLANE4:
case GL_CLIP_PLANE5:
*params = (GLdouble) ctx->Transform.ClipEnabled[pname-GL_CLIP_PLANE0];
break;
case GL_COLOR_CLEAR_VALUE:
params[0] = (GLdouble) ctx->Color.ClearColor[0];
params[1] = (GLdouble) ctx->Color.ClearColor[1];
params[2] = (GLdouble) ctx->Color.ClearColor[2];
params[3] = (GLdouble) ctx->Color.ClearColor[3];
break;
case GL_COLOR_MATERIAL:
*params = (GLdouble) ctx->Light.ColorMaterialEnabled;
break;
case GL_COLOR_MATERIAL_FACE:
*params = (GLdouble) ctx->Light.ColorMaterialFace;
break;
case GL_COLOR_MATERIAL_PARAMETER:
*params = (GLdouble) ctx->Light.ColorMaterialMode;
break;
case GL_COLOR_WRITEMASK:
params[0] = (ctx->Color.ColorMask & 8) ? 1.0 : 0.0;
params[1] = (ctx->Color.ColorMask & 4) ? 1.0 : 0.0;
params[2] = (ctx->Color.ColorMask & 2) ? 1.0 : 0.0;
params[3] = (ctx->Color.ColorMask & 1) ? 1.0 : 0.0;
break;
case GL_CULL_FACE:
*params = (GLdouble) ctx->Polygon.CullFlag;
break;
case GL_CULL_FACE_MODE:
*params = (GLdouble) ctx->Polygon.CullFaceMode;
break;
case GL_CURRENT_COLOR:
params[0] = ctx->Current.ByteColor[0] * ctx->Visual->InvRedScale;
params[1] = ctx->Current.ByteColor[1] * ctx->Visual->InvGreenScale;
params[2] = ctx->Current.ByteColor[2] * ctx->Visual->InvBlueScale;
params[3] = ctx->Current.ByteColor[3] * ctx->Visual->InvAlphaScale;
break;
case GL_CURRENT_INDEX:
*params = (GLdouble) ctx->Current.Index;
break;
case GL_CURRENT_NORMAL:
params[0] = (GLdouble) ctx->Current.Normal[0];
params[1] = (GLdouble) ctx->Current.Normal[1];
params[2] = (GLdouble) ctx->Current.Normal[2];
break;
case GL_CURRENT_RASTER_COLOR:
	 params[0] = (GLdouble) ctx->Current.RasterColor[0];
	 params[1] = (GLdouble) ctx->Current.RasterColor[1];
	 params[2] = (GLdouble) ctx->Current.RasterColor[2];
	 params[3] = (GLdouble) ctx->Current.RasterColor[3];
	 break;
case GL_CURRENT_RASTER_DISTANCE:
	 params[0] = (GLdouble) ctx->Current.RasterDistance;
	 break;
case GL_CURRENT_RASTER_INDEX:
	 *params = (GLdouble) ctx->Current.RasterIndex;
	 break;
case GL_CURRENT_RASTER_POSITION:
	 params[0] = (GLdouble) ctx->Current.RasterPos[0];
	 params[1] = (GLdouble) ctx->Current.RasterPos[1];
	 params[2] = (GLdouble) ctx->Current.RasterPos[2];
	 params[3] = (GLdouble) ctx->Current.RasterPos[3];
	 break;
case GL_CURRENT_RASTER_TEXTURE_COORDS:
	 params[0] = (GLdouble) ctx->Current.RasterTexCoord[0];
	 params[1] = (GLdouble) ctx->Current.RasterTexCoord[1];
	 params[2] = (GLdouble) ctx->Current.RasterTexCoord[2];
	 params[3] = (GLdouble) ctx->Current.RasterTexCoord[3];
	 break;
case GL_CURRENT_RASTER_POSITION_VALID:
	 *params = (GLdouble) ctx->Current.RasterPosValid;
	 break;
case GL_CURRENT_TEXTURE_COORDS:
	 params[0] = (GLdouble) ctx->Current.TexCoord[0];
	 params[1] = (GLdouble) ctx->Current.TexCoord[1];
	 params[2] = (GLdouble) ctx->Current.TexCoord[2];
	 params[3] = (GLdouble) ctx->Current.TexCoord[3];
	 break;
case GL_DEPTH_BIAS:
	 *params = (GLdouble) ctx->Pixel.DepthBias;
	 break;
case GL_DEPTH_BITS:
	 *params = (GLdouble) ctx->Visual->DepthBits;
	 break;
case GL_DEPTH_CLEAR_VALUE:
	 *params = (GLdouble) ctx->Depth.Clear;
	 break;
case GL_DEPTH_FUNC:
	 *params = (GLdouble) ctx->Depth.Func;
	 break;
case GL_DEPTH_RANGE:
params[0] = (GLdouble) ctx->Viewport.Near;
params[1] = (GLdouble) ctx->Viewport.Far;
	 break;
case GL_DEPTH_SCALE:
	 *params = (GLdouble) ctx->Pixel.DepthScale;
	 break;
case GL_DEPTH_TEST:
	 *params = (GLdouble) ctx->Depth.Test;
	 break;
case GL_DEPTH_WRITEMASK:
	 *params = (GLdouble) ctx->Depth.Mask;
	 break;
case GL_DITHER:
	 *params = (GLdouble) ctx->Color.DitherFlag;
	 break;
case GL_DOUBLEBUFFER:
	 *params = (GLdouble) ctx->Visual->DBflag;
	 break;
case GL_DRAW_BUFFER:
	 *params = (GLdouble) ctx->Color.DrawBuffer;
	 break;
case GL_EDGE_FLAG:
	 *params = (GLdouble) ctx->Current.EdgeFlag;
	 break;
case GL_FEEDBACK_BUFFER_SIZE:
*params = (GLdouble) ctx->Feedback.BufferSize;
break;
case GL_FEEDBACK_BUFFER_TYPE:
*params = (GLdouble) ctx->Feedback.Type;
break;
case GL_FOG:
	 *params = (GLdouble) ctx->Fog.Enabled;
	 break;
case GL_FOG_COLOR:
	 params[0] = (GLdouble) ctx->Fog.Color[0];
	 params[1] = (GLdouble) ctx->Fog.Color[1];
	 params[2] = (GLdouble) ctx->Fog.Color[2];
	 params[3] = (GLdouble) ctx->Fog.Color[3];
	 break;
case GL_FOG_DENSITY:
	 *params = (GLdouble) ctx->Fog.Density;
	 break;
case GL_FOG_END:
	 *params = (GLdouble) ctx->Fog.End;
	 break;
case GL_FOG_HINT:
	 *params = (GLdouble) ctx->Hint.Fog;
	 break;
case GL_FOG_INDEX:
	 *params = (GLdouble) ctx->Fog.Index;
	 break;
case GL_FOG_MODE:
	 *params = (GLdouble) ctx->Fog.Mode;
	 break;
case GL_FOG_START:
	 *params = (GLdouble) ctx->Fog.Start;
	 break;
case GL_FRONT_FACE:
	 *params = (GLdouble) ctx->Polygon.FrontFace;
	 break;
case GL_GREEN_BIAS:
*params = (GLdouble) ctx->Pixel.GreenBias;
break;
case GL_GREEN_BITS:
*params = (GLdouble) ctx->Visual->GreenBits;
break;
case GL_GREEN_SCALE:
*params = (GLdouble) ctx->Pixel.GreenScale;
break;
case GL_INDEX_BITS:
*params = (GLdouble) ctx->Visual->IndexBits;
	 break;
case GL_INDEX_CLEAR_VALUE:
*params = (GLdouble) ctx->Color.ClearIndex;
	 break;
case GL_INDEX_MODE:
	 *params = ctx->Visual->RGBAflag ? 0.0 : 1.0;
	 break;
case GL_INDEX_OFFSET:
	 *params = (GLdouble) ctx->Pixel.IndexOffset;
	 break;
case GL_INDEX_SHIFT:
	 *params = (GLdouble) ctx->Pixel.IndexShift;
	 break;
case GL_INDEX_WRITEMASK:
	 *params = (GLdouble) ctx->Color.IndexMask;
	 break;
case GL_LIGHT0:
case GL_LIGHT1:
case GL_LIGHT2:
case GL_LIGHT3:
case GL_LIGHT4:
case GL_LIGHT5:
case GL_LIGHT6:
case GL_LIGHT7:
	 *params = (GLdouble) ctx->Light.Light[pname-GL_LIGHT0].Enabled;
	 break;
case GL_LIGHTING:
	 *params = (GLdouble) ctx->Light.Enabled;
	 break;
case GL_LIGHT_MODEL_AMBIENT:
	 params[0] = (GLdouble) ctx->Light.Model.Ambient[0];
	 params[1] = (GLdouble) ctx->Light.Model.Ambient[1];
	 params[2] = (GLdouble) ctx->Light.Model.Ambient[2];
	 params[3] = (GLdouble) ctx->Light.Model.Ambient[3];
	 break;
case GL_LIGHT_MODEL_LOCAL_VIEWER:
	 *params = (GLdouble) ctx->Light.Model.LocalViewer;
	 break;
case GL_LIGHT_MODEL_TWO_SIDE:
	 *params = (GLdouble) ctx->Light.Model.TwoSide;
	 break;
case GL_LINE_SMOOTH:
	 *params = (GLdouble) ctx->Line.SmoothFlag;
	 break;
case GL_LINE_SMOOTH_HINT:
	 *params = (GLdouble) ctx->Hint.LineSmooth;
	 break;
case GL_LINE_STIPPLE:
	 *params = (GLdouble) ctx->Line.StippleFlag;
	 break;
case GL_LINE_STIPPLE_PATTERN:
*params = (GLdouble) ctx->Line.StipplePattern;
break;
case GL_LINE_STIPPLE_REPEAT:
*params = (GLdouble) ctx->Line.StippleFactor;
break;
case GL_LINE_WIDTH:
	 *params = (GLdouble) ctx->Line.Width;
	 break;
case GL_LINE_WIDTH_GRANULARITY:
	 *params = (GLdouble) LINE_WIDTH_GRANULARITY;
	 break;
case GL_LINE_WIDTH_RANGE:
	 params[0] = (GLdouble) MIN_LINE_WIDTH;
	 params[1] = (GLdouble) MAX_LINE_WIDTH;
	 break;
case GL_LIST_BASE:
	 *params = (GLdouble) ctx->List.ListBase;
	 break;
case GL_LIST_INDEX:
	 *params = (GLdouble) gl_list_index();
	 break;
case GL_LIST_MODE:
	 *params = ctx->ExecuteFlag ? (GLdouble) GL_COMPILE_AND_EXECUTE
	   			  : (GLdouble) GL_COMPILE;
	 break;
case GL_INDEX_LOGIC_OP:
	 *params = (GLdouble) ctx->Color.IndexLogicOpEnabled;
	 break;
case GL_COLOR_LOGIC_OP:
	 *params = (GLdouble) ctx->Color.ColorLogicOpEnabled;
	 break;
case GL_LOGIC_OP_MODE:
*params = (GLdouble) ctx->Color.LogicOp;
	 break;
case GL_MAP1_COLOR_4:
	 *params = (GLdouble) ctx->Eval.Map1Color4;
	 break;
case GL_MAP1_GRID_DOMAIN:
	 params[0] = (GLdouble) ctx->Eval.MapGrid1u1;
	 params[1] = (GLdouble) ctx->Eval.MapGrid1u2;
	 break;
case GL_MAP1_GRID_SEGMENTS:
	 *params = (GLdouble) ctx->Eval.MapGrid1un;
	 break;
case GL_MAP1_INDEX:
	 *params = (GLdouble) ctx->Eval.Map1Index;
	 break;
case GL_MAP1_NORMAL:
	 *params = (GLdouble) ctx->Eval.Map1Normal;
	 break;
case GL_MAP1_TEXTURE_COORD_1:
	 *params = (GLdouble) ctx->Eval.Map1TextureCoord1;
	 break;
case GL_MAP1_TEXTURE_COORD_2:
	 *params = (GLdouble) ctx->Eval.Map1TextureCoord2;
	 break;
case GL_MAP1_TEXTURE_COORD_3:
	 *params = (GLdouble) ctx->Eval.Map1TextureCoord3;
	 break;
case GL_MAP1_TEXTURE_COORD_4:
	 *params = (GLdouble) ctx->Eval.Map1TextureCoord4;
	 break;
case GL_MAP1_VERTEX_3:
	 *params = (GLdouble) ctx->Eval.Map1Vertex3;
	 break;
case GL_MAP1_VERTEX_4:
	 *params = (GLdouble) ctx->Eval.Map1Vertex4;
	 break;
case GL_MAP2_COLOR_4:
	 *params = (GLdouble) ctx->Eval.Map2Color4;
	 break;
case GL_MAP2_GRID_DOMAIN:
	 params[0] = (GLdouble) ctx->Eval.MapGrid2u1;
	 params[1] = (GLdouble) ctx->Eval.MapGrid2u2;
	 params[2] = (GLdouble) ctx->Eval.MapGrid2v1;
	 params[3] = (GLdouble) ctx->Eval.MapGrid2v2;
	 break;
case GL_MAP2_GRID_SEGMENTS:
	 params[0] = (GLdouble) ctx->Eval.MapGrid2un;
	 params[1] = (GLdouble) ctx->Eval.MapGrid2vn;
	 break;
case GL_MAP2_INDEX:
	 *params = (GLdouble) ctx->Eval.Map2Index;
	 break;
case GL_MAP2_NORMAL:
	 *params = (GLdouble) ctx->Eval.Map2Normal;
	 break;
case GL_MAP2_TEXTURE_COORD_1:
	 *params = (GLdouble) ctx->Eval.Map2TextureCoord1;
	 break;
case GL_MAP2_TEXTURE_COORD_2:
	 *params = (GLdouble) ctx->Eval.Map2TextureCoord2;
	 break;
case GL_MAP2_TEXTURE_COORD_3:
	 *params = (GLdouble) ctx->Eval.Map2TextureCoord3;
	 break;
case GL_MAP2_TEXTURE_COORD_4:
	 *params = (GLdouble) ctx->Eval.Map2TextureCoord4;
	 break;
case GL_MAP2_VERTEX_3:
	 *params = (GLdouble) ctx->Eval.Map2Vertex3;
	 break;
case GL_MAP2_VERTEX_4:
	 *params = (GLdouble) ctx->Eval.Map2Vertex4;
	 break;
case GL_MAP_COLOR:
	 *params = (GLdouble) ctx->Pixel.MapColorFlag;
	 break;
case GL_MAP_STENCIL:
	 *params = (GLdouble) ctx->Pixel.MapStencilFlag;
	 break;
case GL_MATRIX_MODE:
	 *params = (GLdouble) ctx->Transform.MatrixMode;
	 break;
case GL_MAX_ATTRIB_STACK_DEPTH:
	 *params = (GLdouble) MAX_ATTRIB_STACK_DEPTH;
	 break;
case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
*params = (GLdouble) MAX_CLIENT_ATTRIB_STACK_DEPTH;
break;
case GL_MAX_CLIP_PLANES:
	 *params = (GLdouble) MAX_CLIP_PLANES;
	 break;
case GL_MAX_EVAL_ORDER:
	 *params = (GLdouble) MAX_EVAL_ORDER;
	 break;
case GL_MAX_LIGHTS:
	 *params = (GLdouble) MAX_LIGHTS;
	 break;
case GL_MAX_LIST_NESTING:
	 *params = (GLdouble) MAX_LIST_NESTING;
	 break;
case GL_MAX_MODELVIEW_STACK_DEPTH:
	 *params = (GLdouble) MAX_MODELVIEW_STACK_DEPTH;
	 break;
case GL_MAX_NAME_STACK_DEPTH:
	 *params = (GLdouble) MAX_NAME_STACK_DEPTH;
	 break;
case GL_MAX_PIXEL_MAP_TABLE:
	 *params = (GLdouble) MAX_PIXEL_MAP_TABLE;
	 break;
case GL_MAX_PROJECTION_STACK_DEPTH:
	 *params = (GLdouble) MAX_PROJECTION_STACK_DEPTH;
	 break;
case GL_MAX_TEXTURE_SIZE:
	 *params = (GLdouble) MAX_TEXTURE_SIZE;
	 break;
case GL_MAX_TEXTURE_STACK_DEPTH:
	 *params = (GLdouble) MAX_TEXTURE_STACK_DEPTH;
	 break;
case GL_MAX_VIEWPORT_DIMS:
params[0] = (GLdouble) MAX_WIDTH;
params[1] = (GLdouble) MAX_HEIGHT;
break;
case GL_MODELVIEW_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = (GLdouble) ctx->ModelViewMatrix[i];
	 }
	 break;
case GL_MODELVIEW_STACK_DEPTH:
	 *params = (GLdouble) ctx->ModelViewStackDepth;
	 break;
case GL_NAME_STACK_DEPTH:
	 *params = (GLdouble) ctx->Select.NameStackDepth;
	 break;
case GL_NORMALIZE:
	 *params = (GLdouble) ctx->Transform.Normalize;
	 break;
case GL_PACK_ALIGNMENT:
	 *params = (GLdouble) ctx->Pack.Alignment;
	 break;
case GL_PACK_LSB_FIRST:
	 *params = (GLdouble) ctx->Pack.LsbFirst;
	 break;
case GL_PACK_ROW_LENGTH:
	 *params = (GLdouble) ctx->Pack.RowLength;
	 break;
case GL_PACK_SKIP_PIXELS:
	 *params = (GLdouble) ctx->Pack.SkipPixels;
	 break;
case GL_PACK_SKIP_ROWS:
	 *params = (GLdouble) ctx->Pack.SkipRows;
	 break;
case GL_PACK_SWAP_BYTES:
	 *params = (GLdouble) ctx->Pack.SwapBytes;
	 break;
case GL_PACK_SKIP_IMAGES_EXT:
*params = (GLdouble) ctx->Pack.SkipImages;
break;
case GL_PACK_IMAGE_HEIGHT_EXT:
*params = (GLdouble) ctx->Pack.ImageHeight;
break;
case GL_PERSPECTIVE_CORRECTION_HINT:
	 *params = (GLdouble) ctx->Hint.PerspectiveCorrection;
	 break;
case GL_PIXEL_MAP_A_TO_A_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapAtoAsize;
	 break;
case GL_PIXEL_MAP_B_TO_B_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapBtoBsize;
	 break;
case GL_PIXEL_MAP_G_TO_G_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapGtoGsize;
	 break;
case GL_PIXEL_MAP_I_TO_A_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapItoAsize;
	 break;
case GL_PIXEL_MAP_I_TO_B_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapItoBsize;
	 break;
case GL_PIXEL_MAP_I_TO_G_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapItoGsize;
	 break;
case GL_PIXEL_MAP_I_TO_I_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapItoIsize;
	 break;
case GL_PIXEL_MAP_I_TO_R_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapItoRsize;
	 break;
case GL_PIXEL_MAP_R_TO_R_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapRtoRsize;
	 break;
case GL_PIXEL_MAP_S_TO_S_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapStoSsize;
	 break;
case GL_POINT_SIZE:
*params = (GLdouble) ctx->Point.Size;
break;
case GL_POINT_SIZE_GRANULARITY:
	 *params = (GLdouble) POINT_SIZE_GRANULARITY;
	 break;
case GL_POINT_SIZE_RANGE:
	 params[0] = (GLdouble) MIN_POINT_SIZE;
	 params[1] = (GLdouble) MAX_POINT_SIZE;
	 break;
case GL_POINT_SMOOTH:
	 *params = (GLdouble) ctx->Point.SmoothFlag;
	 break;
case GL_POINT_SMOOTH_HINT:
	 *params = (GLdouble) ctx->Hint.PointSmooth;
	 break;
case GL_POINT_SIZE_MIN_EXT:
	 *params = (GLdouble) (ctx->Point.MinSize);
	 break;
case GL_POINT_SIZE_MAX_EXT:
	 *params = (GLdouble) (ctx->Point.MaxSize);
	 break;
case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
	 *params = (GLdouble) (ctx->Point.Threshold);
	 break;
case GL_DISTANCE_ATTENUATION_EXT:
	 params[0] = (GLdouble) (ctx->Point.Params[0]);
	 params[1] = (GLdouble) (ctx->Point.Params[1]);
	 params[2] = (GLdouble) (ctx->Point.Params[2]);
	 break;
case GL_POLYGON_MODE:
	 params[0] = (GLdouble) ctx->Polygon.FrontMode;
	 params[1] = (GLdouble) ctx->Polygon.BackMode;
	 break;
#ifdef GL_EXT_polygon_offset
case GL_POLYGON_OFFSET_BIAS_EXT:
*params = (GLdouble) ctx->Polygon.OffsetUnits;
break;
#endif
case GL_POLYGON_OFFSET_FACTOR:
*params = (GLdouble) ctx->Polygon.OffsetFactor;
break;
case GL_POLYGON_OFFSET_UNITS:
*params = (GLdouble) ctx->Polygon.OffsetUnits;
break;
case GL_POLYGON_SMOOTH:
	 *params = (GLdouble) ctx->Polygon.SmoothFlag;
	 break;
case GL_POLYGON_SMOOTH_HINT:
	 *params = (GLdouble) ctx->Hint.PolygonSmooth;
	 break;
case GL_POLYGON_STIPPLE:
	 for (i=0;i<32;i++) {		
	    params[i] = (GLdouble) ctx->PolygonStipple[i];
	 }
	 break;
case GL_PROJECTION_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = (GLdouble) ctx->ProjectionMatrix[i];
	 }
	 break;
case GL_PROJECTION_STACK_DEPTH:
	 *params = (GLdouble) ctx->ProjectionStackDepth;
	 break;
case GL_READ_BUFFER:
	 *params = (GLdouble) ctx->Pixel.ReadBuffer;
	 break;
case GL_RED_BIAS:
*params = (GLdouble) ctx->Pixel.RedBias;
break;
case GL_RED_BITS:
*params = (GLdouble) ctx->Visual->RedBits;
break;
case GL_RED_SCALE:
*params = (GLdouble) ctx->Pixel.RedScale;
break;
case GL_RENDER_MODE:
	 *params = (GLdouble) ctx->RenderMode;
	 break;
case GL_RGBA_MODE:
	 *params = (GLdouble) ctx->Visual->RGBAflag;
	 break;
case GL_SCISSOR_BOX:
	 params[0] = (GLdouble) ctx->Scissor.X;
	 params[1] = (GLdouble) ctx->Scissor.Y;
	 params[2] = (GLdouble) ctx->Scissor.Width;
	 params[3] = (GLdouble) ctx->Scissor.Height;
	 break;
case GL_SCISSOR_TEST:
	 *params = (GLdouble) ctx->Scissor.Enabled;
	 break;
case GL_SHADE_MODEL:
	 *params = (GLdouble) ctx->Light.ShadeModel;
	 break;
case GL_SHARED_TEXTURE_PALETTE_EXT:
*params = (GLdouble) ctx->Texture.SharedPalette;
break;
case GL_STENCIL_BITS:
*params = (GLdouble) ctx->Visual->StencilBits;
break;
case GL_STENCIL_CLEAR_VALUE:
	 *params = (GLdouble) ctx->Stencil.Clear;
	 break;
case GL_STENCIL_FAIL:
	 *params = (GLdouble) ctx->Stencil.FailFunc;
	 break;
case GL_STENCIL_FUNC:
	 *params = (GLdouble) ctx->Stencil.Function;
	 break;
case GL_STENCIL_PASS_DEPTH_FAIL:
	 *params = (GLdouble) ctx->Stencil.ZFailFunc;
	 break;
case GL_STENCIL_PASS_DEPTH_PASS:
	 *params = (GLdouble) ctx->Stencil.ZPassFunc;
	 break;
case GL_STENCIL_REF:
	 *params = (GLdouble) ctx->Stencil.Ref;
	 break;
case GL_STENCIL_TEST:
	 *params = (GLdouble) ctx->Stencil.Enabled;
	 break;
case GL_STENCIL_VALUE_MASK:
	 *params = (GLdouble) ctx->Stencil.ValueMask;
	 break;
case GL_STENCIL_WRITEMASK:
	 *params = (GLdouble) ctx->Stencil.WriteMask;
	 break;
case GL_STEREO:
	 *params = 0.0;
	 break;
case GL_SUBPIXEL_BITS:
	 *params = 0.0;
	 break;
case GL_TEXTURE_1D:
	 *params = (ctx->Texture.Enabled & TEXTURE_1D) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_2D:
	 *params = (ctx->Texture.Enabled & TEXTURE_2D) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_3D_EXT:
	 *params = (ctx->Texture.Enabled & TEXTURE_3D) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_ENV_COLOR:
	 params[0] = (GLdouble) ctx->Texture.EnvColor[0];
	 params[1] = (GLdouble) ctx->Texture.EnvColor[1];
	 params[2] = (GLdouble) ctx->Texture.EnvColor[2];
	 params[3] = (GLdouble) ctx->Texture.EnvColor[3];
	 break;
case GL_TEXTURE_ENV_MODE:
	 *params = (GLdouble) ctx->Texture.EnvMode;
	 break;
case GL_TEXTURE_GEN_S:
	 *params = (ctx->Texture.TexGenEnabled & S_BIT) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_GEN_T:
	 *params = (ctx->Texture.TexGenEnabled & T_BIT) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_GEN_R:
	 *params = (ctx->Texture.TexGenEnabled & R_BIT) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_GEN_Q:
	 *params = (ctx->Texture.TexGenEnabled & Q_BIT) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_MATRIX:
for (i=0;i<16;i++) {
	    params[i] = (GLdouble) ctx->TextureMatrix[i];
	 }
	 break;
case GL_TEXTURE_STACK_DEPTH:
	 *params = (GLdouble) ctx->TextureStackDepth;
	 break;
case GL_UNPACK_ALIGNMENT:
	 *params = (GLdouble) ctx->Unpack.Alignment;
	 break;
case GL_UNPACK_LSB_FIRST:
	 *params = (GLdouble) ctx->Unpack.LsbFirst;
	 break;
case GL_UNPACK_ROW_LENGTH:
	 *params = (GLdouble) ctx->Unpack.RowLength;
	 break;
case GL_UNPACK_SKIP_PIXELS:
	 *params = (GLdouble) ctx->Unpack.SkipPixels;
	 break;
case GL_UNPACK_SKIP_ROWS:
	 *params = (GLdouble) ctx->Unpack.SkipRows;
	 break;
case GL_UNPACK_SWAP_BYTES:
	 *params = (GLdouble) ctx->Unpack.SwapBytes;
	 break;
case GL_UNPACK_SKIP_IMAGES_EXT:
*params = (GLdouble) ctx->Unpack.SkipImages;
break;
case GL_UNPACK_IMAGE_HEIGHT_EXT:
*params = (GLdouble) ctx->Unpack.ImageHeight;
break;
case GL_VIEWPORT:
	 params[0] = (GLdouble) ctx->Viewport.X;
	 params[1] = (GLdouble) ctx->Viewport.Y;
	 params[2] = (GLdouble) ctx->Viewport.Width;
	 params[3] = (GLdouble) ctx->Viewport.Height;
	 break;
case GL_ZOOM_X:
	 *params = (GLdouble) ctx->Pixel.ZoomX;
	 break;
case GL_ZOOM_Y:
	 *params = (GLdouble) ctx->Pixel.ZoomY;
	 break;
case GL_VERTEX_ARRAY_SIZE:
*params = (GLdouble) ctx->Array.VertexSize;
break;
case GL_VERTEX_ARRAY_TYPE:
*params = (GLdouble) ctx->Array.VertexType;
break;
case GL_VERTEX_ARRAY_STRIDE:
*params = (GLdouble) ctx->Array.VertexStride;
break;
case GL_VERTEX_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_NORMAL_ARRAY_TYPE:
*params = (GLdouble) ctx->Array.NormalType;
break;
case GL_NORMAL_ARRAY_STRIDE:
*params = (GLdouble) ctx->Array.NormalStride;
break;
case GL_NORMAL_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_COLOR_ARRAY_SIZE:
*params = (GLdouble) ctx->Array.ColorSize;
break;
case GL_COLOR_ARRAY_TYPE:
*params = (GLdouble) ctx->Array.ColorType;
break;
case GL_COLOR_ARRAY_STRIDE:
*params = (GLdouble) ctx->Array.ColorStride;
break;
case GL_COLOR_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_INDEX_ARRAY_TYPE:
*params = (GLdouble) ctx->Array.IndexType;
break;
case GL_INDEX_ARRAY_STRIDE:
*params = (GLdouble) ctx->Array.IndexStride;
break;
case GL_INDEX_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_TEXTURE_COORD_ARRAY_SIZE:
*params = (GLdouble) ctx->Array.TexCoordSize;
break;
case GL_TEXTURE_COORD_ARRAY_TYPE:
*params = (GLdouble) ctx->Array.TexCoordType;
break;
case GL_TEXTURE_COORD_ARRAY_STRIDE:
*params = (GLdouble) ctx->Array.TexCoordStride;
break;
case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_EDGE_FLAG_ARRAY_STRIDE:
*params = (GLdouble) ctx->Array.EdgeFlagStride;
break;
case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_TEXTURE_BINDING_1D:
*params = (GLdouble) ctx->Texture.Current1D->Name;
break;
case GL_TEXTURE_BINDING_2D:
*params = (GLdouble) ctx->Texture.Current2D->Name;
break;
case GL_TEXTURE_3D_BINDING_EXT:
*params = (GLdouble) ctx->Texture.Current3D->Name;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetDoublev" );
}
}
void gl_GetFloatv( GLcontext *ctx, GLenum pname, float *params )
{
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetFloatv" );
return;
}
switch (pname) {
case GL_ACCUM_RED_BITS:
case GL_ACCUM_GREEN_BITS:
case GL_ACCUM_BLUE_BITS:
case GL_ACCUM_ALPHA_BITS:
*params = (float) ctx->Visual->AccumBits;
break;
case GL_ACCUM_CLEAR_VALUE:
params[0] = ctx->Accum.ClearColor[0];
params[1] = ctx->Accum.ClearColor[1];
params[2] = ctx->Accum.ClearColor[2];
params[3] = ctx->Accum.ClearColor[3];
break;
case GL_ALPHA_BIAS:
*params = ctx->Pixel.AlphaBias;
break;
case GL_ALPHA_BITS:
*params = (float) ctx->Visual->AlphaBits;
break;
case GL_ALPHA_SCALE:
*params = ctx->Pixel.AlphaScale;
break;
case GL_ALPHA_TEST:
*params = (float) ctx->Color.AlphaEnabled;
break;
case GL_ALPHA_TEST_FUNC:
*params = (float) ctx->Color.AlphaFunc;
break;
case GL_ALPHA_TEST_REF:
*params = (float) ctx->Color.AlphaRef;
break;
case GL_ATTRIB_STACK_DEPTH:
*params = (float ) ctx->AttribStackDepth;
break;
case GL_AUTO_NORMAL:
*params = (float) ctx->Eval.AutoNormal;
break;
case GL_AUX_BUFFERS:
*params = (float) NUM_AUX_BUFFERS;
break;
case GL_BLEND:
*params = (float) ctx->Color.BlendEnabled;
break;
case GL_BLEND_DST:
*params = (float) ctx->Color.BlendDst;
break;
case GL_BLEND_SRC:
*params = (float) ctx->Color.BlendSrc;
break;
case GL_BLEND_EQUATION_EXT:
	 *params = (float) ctx->Color.BlendEquation;
	 break;
case GL_BLEND_COLOR_EXT:
	 params[0] = ctx->Color.BlendColor[0];
	 params[1] = ctx->Color.BlendColor[1];
	 params[2] = ctx->Color.BlendColor[2];
	 params[3] = ctx->Color.BlendColor[3];
	 break;
case GL_BLUE_BIAS:
*params = ctx->Pixel.BlueBias;
break;
case GL_BLUE_BITS:
*params = (float) ctx->Visual->BlueBits;
break;
case GL_BLUE_SCALE:
*params = ctx->Pixel.BlueScale;
break;
case GL_CLIENT_ATTRIB_STACK_DEPTH:
*params = (float) ctx->ClientAttribStackDepth;
break;
case GL_CLIP_PLANE0:
case GL_CLIP_PLANE1:
case GL_CLIP_PLANE2:
case GL_CLIP_PLANE3:
case GL_CLIP_PLANE4:
case GL_CLIP_PLANE5:
*params = (float) ctx->Transform.ClipEnabled[pname-GL_CLIP_PLANE0];
break;
case GL_COLOR_CLEAR_VALUE:
params[0] = (float) ctx->Color.ClearColor[0];
params[1] = (float) ctx->Color.ClearColor[1];
params[2] = (float) ctx->Color.ClearColor[2];
params[3] = (float) ctx->Color.ClearColor[3];
break;
case GL_COLOR_MATERIAL:
*params = (float) ctx->Light.ColorMaterialEnabled;
break;
case GL_COLOR_MATERIAL_FACE:
*params = (float) ctx->Light.ColorMaterialFace;
break;
case GL_COLOR_MATERIAL_PARAMETER:
*params = (float) ctx->Light.ColorMaterialMode;
break;
case GL_COLOR_WRITEMASK:
params[0] = (ctx->Color.ColorMask & 8) ? 1.0F : 0.0F;
params[1] = (ctx->Color.ColorMask & 4) ? 1.0F : 0.0F;
params[2] = (ctx->Color.ColorMask & 2) ? 1.0F : 0.0F;
params[3] = (ctx->Color.ColorMask & 1) ? 1.0F : 0.0F;
break;
case GL_CULL_FACE:
*params = (float) ctx->Polygon.CullFlag;
break;
case GL_CULL_FACE_MODE:
*params = (float) ctx->Polygon.CullFaceMode;
break;
case GL_CURRENT_COLOR:
params[0] = ctx->Current.ByteColor[0] * ctx->Visual->InvRedScale;
params[1] = ctx->Current.ByteColor[1] * ctx->Visual->InvGreenScale;
params[2] = ctx->Current.ByteColor[2] * ctx->Visual->InvBlueScale;
params[3] = ctx->Current.ByteColor[3] * ctx->Visual->InvAlphaScale;
break;
case GL_CURRENT_INDEX:
*params = (float) ctx->Current.Index;
break;
case GL_CURRENT_NORMAL:
params[0] = ctx->Current.Normal[0];
params[1] = ctx->Current.Normal[1];
params[2] = ctx->Current.Normal[2];
break;
case GL_CURRENT_RASTER_COLOR:
	 params[0] = ctx->Current.RasterColor[0];
	 params[1] = ctx->Current.RasterColor[1];
	 params[2] = ctx->Current.RasterColor[2];
	 params[3] = ctx->Current.RasterColor[3];
	 break;
case GL_CURRENT_RASTER_DISTANCE:
	 params[0] = ctx->Current.RasterDistance;
	 break;
case GL_CURRENT_RASTER_INDEX:
	 *params = (float) ctx->Current.RasterIndex;
	 break;
case GL_CURRENT_RASTER_POSITION:
	 params[0] = ctx->Current.RasterPos[0];
	 params[1] = ctx->Current.RasterPos[1];
	 params[2] = ctx->Current.RasterPos[2];
	 params[3] = ctx->Current.RasterPos[3];
	 break;
case GL_CURRENT_RASTER_TEXTURE_COORDS:
	 params[0] = ctx->Current.RasterTexCoord[0];
	 params[1] = ctx->Current.RasterTexCoord[1];
	 params[2] = ctx->Current.RasterTexCoord[2];
	 params[3] = ctx->Current.RasterTexCoord[3];
	 break;
case GL_CURRENT_RASTER_POSITION_VALID:
	 *params = (float) ctx->Current.RasterPosValid;
	 break;
case GL_CURRENT_TEXTURE_COORDS:
	 params[0] = (float) ctx->Current.TexCoord[0];
	 params[1] = (float) ctx->Current.TexCoord[1];
	 params[2] = (float) ctx->Current.TexCoord[2];
	 params[3] = (float) ctx->Current.TexCoord[3];
	 break;
case GL_DEPTH_BIAS:
	 *params = (float) ctx->Pixel.DepthBias;
	 break;
case GL_DEPTH_BITS:
	 *params = (float) ctx->Visual->DepthBits;
	 break;
case GL_DEPTH_CLEAR_VALUE:
	 *params = (float) ctx->Depth.Clear;
	 break;
case GL_DEPTH_FUNC:
	 *params = (float) ctx->Depth.Func;
	 break;
case GL_DEPTH_RANGE:
params[0] = (float) ctx->Viewport.Near;
params[1] = (float) ctx->Viewport.Far;
	 break;
case GL_DEPTH_SCALE:
	 *params = (float) ctx->Pixel.DepthScale;
	 break;
case GL_DEPTH_TEST:
	 *params = (float) ctx->Depth.Test;
	 break;
case GL_DEPTH_WRITEMASK:
	 *params = (float) ctx->Depth.Mask;
	 break;
case GL_DITHER:
	 *params = (float) ctx->Color.DitherFlag;
	 break;
case GL_DOUBLEBUFFER:
	 *params = (float) ctx->Visual->DBflag;
	 break;
case GL_DRAW_BUFFER:
	 *params = (float) ctx->Color.DrawBuffer;
	 break;
case GL_EDGE_FLAG:
	 *params = (float) ctx->Current.EdgeFlag;
	 break;
case GL_FEEDBACK_BUFFER_SIZE:
*params = (float) ctx->Feedback.BufferSize;
break;
case GL_FEEDBACK_BUFFER_TYPE:
*params = (float) ctx->Feedback.Type;
break;
case GL_FOG:
	 *params = (float) ctx->Fog.Enabled;
	 break;
case GL_FOG_COLOR:
	 params[0] = ctx->Fog.Color[0];
	 params[1] = ctx->Fog.Color[1];
	 params[2] = ctx->Fog.Color[2];
	 params[3] = ctx->Fog.Color[3];
	 break;
case GL_FOG_DENSITY:
	 *params = ctx->Fog.Density;
	 break;
case GL_FOG_END:
	 *params = ctx->Fog.End;
	 break;
case GL_FOG_HINT:
	 *params = (float) ctx->Hint.Fog;
	 break;
case GL_FOG_INDEX:
	 *params = ctx->Fog.Index;
	 break;
case GL_FOG_MODE:
	 *params = (float) ctx->Fog.Mode;
	 break;
case GL_FOG_START:
	 *params = ctx->Fog.Start;
	 break;
case GL_FRONT_FACE:
	 *params = (float) ctx->Polygon.FrontFace;
	 break;
case GL_GREEN_BIAS:
*params = (float) ctx->Pixel.GreenBias;
break;
case GL_GREEN_BITS:
*params = (float) ctx->Visual->GreenBits;
break;
case GL_GREEN_SCALE:
*params = (float) ctx->Pixel.GreenScale;
break;
case GL_INDEX_BITS:
*params = (float) ctx->Visual->IndexBits;
	 break;
case GL_INDEX_CLEAR_VALUE:
*params = (float) ctx->Color.ClearIndex;
	 break;
case GL_INDEX_MODE:
	 *params = ctx->Visual->RGBAflag ? 0.0F : 1.0F;
	 break;
case GL_INDEX_OFFSET:
	 *params = (float) ctx->Pixel.IndexOffset;
	 break;
case GL_INDEX_SHIFT:
	 *params = (float) ctx->Pixel.IndexShift;
	 break;
case GL_INDEX_WRITEMASK:
	 *params = (float) ctx->Color.IndexMask;
	 break;
case GL_LIGHT0:
case GL_LIGHT1:
case GL_LIGHT2:
case GL_LIGHT3:
case GL_LIGHT4:
case GL_LIGHT5:
case GL_LIGHT6:
case GL_LIGHT7:
	 *params = (float) ctx->Light.Light[pname-GL_LIGHT0].Enabled;
	 break;
case GL_LIGHTING:
	 *params = (float) ctx->Light.Enabled;
	 break;
case GL_LIGHT_MODEL_AMBIENT:
	 params[0] = ctx->Light.Model.Ambient[0];
	 params[1] = ctx->Light.Model.Ambient[1];
	 params[2] = ctx->Light.Model.Ambient[2];
	 params[3] = ctx->Light.Model.Ambient[3];
	 break;
case GL_LIGHT_MODEL_LOCAL_VIEWER:
	 *params = (float) ctx->Light.Model.LocalViewer;
	 break;
case GL_LIGHT_MODEL_TWO_SIDE:
	 *params = (float) ctx->Light.Model.TwoSide;
	 break;
case GL_LINE_SMOOTH:
	 *params = (float) ctx->Line.SmoothFlag;
	 break;
case GL_LINE_SMOOTH_HINT:
	 *params = (float) ctx->Hint.LineSmooth;
	 break;
case GL_LINE_STIPPLE:
	 *params = (float) ctx->Line.StippleFlag;
	 break;
case GL_LINE_STIPPLE_PATTERN:
*params = (float) ctx->Line.StipplePattern;
break;
case GL_LINE_STIPPLE_REPEAT:
*params = (float) ctx->Line.StippleFactor;
break;
case GL_LINE_WIDTH:
	 *params = (float) ctx->Line.Width;
	 break;
case GL_LINE_WIDTH_GRANULARITY:
	 *params = (float) LINE_WIDTH_GRANULARITY;
	 break;
case GL_LINE_WIDTH_RANGE:
	 params[0] = (float) MIN_LINE_WIDTH;
	 params[1] = (float) MAX_LINE_WIDTH;
	 break;
case GL_LIST_BASE:
	 *params = (float) ctx->List.ListBase;
	 break;
case GL_LIST_INDEX:
	 *params = (float) gl_list_index();
	 break;
case GL_LIST_MODE:
	 *params = ctx->ExecuteFlag ? (float) GL_COMPILE_AND_EXECUTE
	   			  : (float) GL_COMPILE;
	 break;
case GL_INDEX_LOGIC_OP:
	 *params = (float) ctx->Color.IndexLogicOpEnabled;
	 break;
case GL_COLOR_LOGIC_OP:
	 *params = (float) ctx->Color.ColorLogicOpEnabled;
	 break;
case GL_LOGIC_OP_MODE:
*params = (float) ctx->Color.LogicOp;
	 break;
case GL_MAP1_COLOR_4:
	 *params = (float) ctx->Eval.Map1Color4;
	 break;
case GL_MAP1_GRID_DOMAIN:
	 params[0] = ctx->Eval.MapGrid1u1;
	 params[1] = ctx->Eval.MapGrid1u2;
	 break;
case GL_MAP1_GRID_SEGMENTS:
	 *params = (float) ctx->Eval.MapGrid1un;
	 break;
case GL_MAP1_INDEX:
	 *params = (float) ctx->Eval.Map1Index;
	 break;
case GL_MAP1_NORMAL:
	 *params = (float) ctx->Eval.Map1Normal;
	 break;
case GL_MAP1_TEXTURE_COORD_1:
	 *params = (float) ctx->Eval.Map1TextureCoord1;
	 break;
case GL_MAP1_TEXTURE_COORD_2:
	 *params = (float) ctx->Eval.Map1TextureCoord2;
	 break;
case GL_MAP1_TEXTURE_COORD_3:
	 *params = (float) ctx->Eval.Map1TextureCoord3;
	 break;
case GL_MAP1_TEXTURE_COORD_4:
	 *params = (float) ctx->Eval.Map1TextureCoord4;
	 break;
case GL_MAP1_VERTEX_3:
	 *params = (float) ctx->Eval.Map1Vertex3;
	 break;
case GL_MAP1_VERTEX_4:
	 *params = (float) ctx->Eval.Map1Vertex4;
	 break;
case GL_MAP2_COLOR_4:
	 *params = (float) ctx->Eval.Map2Color4;
	 break;
case GL_MAP2_GRID_DOMAIN:
	 params[0] = ctx->Eval.MapGrid2u1;
	 params[1] = ctx->Eval.MapGrid2u2;
	 params[2] = ctx->Eval.MapGrid2v1;
	 params[3] = ctx->Eval.MapGrid2v2;
	 break;
case GL_MAP2_GRID_SEGMENTS:
	 params[0] = (float) ctx->Eval.MapGrid2un;
	 params[1] = (float) ctx->Eval.MapGrid2vn;
	 break;
case GL_MAP2_INDEX:
	 *params = (float) ctx->Eval.Map2Index;
	 break;
case GL_MAP2_NORMAL:
	 *params = (float) ctx->Eval.Map2Normal;
	 break;
case GL_MAP2_TEXTURE_COORD_1:
	 *params = ctx->Eval.Map2TextureCoord1;
	 break;
case GL_MAP2_TEXTURE_COORD_2:
	 *params = ctx->Eval.Map2TextureCoord2;
	 break;
case GL_MAP2_TEXTURE_COORD_3:
	 *params = ctx->Eval.Map2TextureCoord3;
	 break;
case GL_MAP2_TEXTURE_COORD_4:
	 *params = ctx->Eval.Map2TextureCoord4;
	 break;
case GL_MAP2_VERTEX_3:
	 *params = (float) ctx->Eval.Map2Vertex3;
	 break;
case GL_MAP2_VERTEX_4:
	 *params = (float) ctx->Eval.Map2Vertex4;
	 break;
case GL_MAP_COLOR:
	 *params = (float) ctx->Pixel.MapColorFlag;
	 break;
case GL_MAP_STENCIL:
	 *params = (float) ctx->Pixel.MapStencilFlag;
	 break;
case GL_MATRIX_MODE:
	 *params = (float) ctx->Transform.MatrixMode;
	 break;
case GL_MAX_ATTRIB_STACK_DEPTH:
	 *params = (float) MAX_ATTRIB_STACK_DEPTH;
	 break;
case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
*params = (float) MAX_CLIENT_ATTRIB_STACK_DEPTH;
break;
case GL_MAX_CLIP_PLANES:
	 *params = (float) MAX_CLIP_PLANES;
	 break;
case GL_MAX_EVAL_ORDER:
	 *params = (float) MAX_EVAL_ORDER;
	 break;
case GL_MAX_LIGHTS:
	 *params = (float) MAX_LIGHTS;
	 break;
case GL_MAX_LIST_NESTING:
	 *params = (float) MAX_LIST_NESTING;
	 break;
case GL_MAX_MODELVIEW_STACK_DEPTH:
	 *params = (float) MAX_MODELVIEW_STACK_DEPTH;
	 break;
case GL_MAX_NAME_STACK_DEPTH:
	 *params = (float) MAX_NAME_STACK_DEPTH;
	 break;
case GL_MAX_PIXEL_MAP_TABLE:
	 *params = (float) MAX_PIXEL_MAP_TABLE;
	 break;
case GL_MAX_PROJECTION_STACK_DEPTH:
	 *params = (float) MAX_PROJECTION_STACK_DEPTH;
	 break;
case GL_MAX_TEXTURE_SIZE:
	 *params = (float) MAX_TEXTURE_SIZE;
	 break;
case GL_MAX_TEXTURE_STACK_DEPTH:
	 *params = (float) MAX_TEXTURE_STACK_DEPTH;
	 break;
case GL_MAX_VIEWPORT_DIMS:
params[0] = (float) MAX_WIDTH;
params[1] = (float) MAX_HEIGHT;
break;
case GL_MODELVIEW_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = ctx->ModelViewMatrix[i];
	 }
	 break;
case GL_MODELVIEW_STACK_DEPTH:
	 *params = (float) ctx->ModelViewStackDepth;
	 break;
case GL_NAME_STACK_DEPTH:
	 *params = (float) ctx->Select.NameStackDepth;
	 break;
case GL_NORMALIZE:
	 *params = (float) ctx->Transform.Normalize;
	 break;
case GL_PACK_ALIGNMENT:
	 *params = (float) ctx->Pack.Alignment;
	 break;
case GL_PACK_LSB_FIRST:
	 *params = (float) ctx->Pack.LsbFirst;
	 break;
case GL_PACK_ROW_LENGTH:
	 *params = (float) ctx->Pack.RowLength;
	 break;
case GL_PACK_SKIP_PIXELS:
	 *params = (float) ctx->Pack.SkipPixels;
	 break;
case GL_PACK_SKIP_ROWS:
	 *params = (float) ctx->Pack.SkipRows;
	 break;
case GL_PACK_SWAP_BYTES:
	 *params = (float) ctx->Pack.SwapBytes;
	 break;
case GL_PACK_SKIP_IMAGES_EXT:
*params = (float) ctx->Pack.SkipImages;
break;
case GL_PACK_IMAGE_HEIGHT_EXT:
*params = (float) ctx->Pack.ImageHeight;
break;
case GL_PERSPECTIVE_CORRECTION_HINT:
	 *params = (float) ctx->Hint.PerspectiveCorrection;
	 break;
case GL_PIXEL_MAP_A_TO_A_SIZE:
	 *params = (float) ctx->Pixel.MapAtoAsize;
	 break;
case GL_PIXEL_MAP_B_TO_B_SIZE:
	 *params = (float) ctx->Pixel.MapBtoBsize;
	 break;
case GL_PIXEL_MAP_G_TO_G_SIZE:
	 *params = (float) ctx->Pixel.MapGtoGsize;
	 break;
case GL_PIXEL_MAP_I_TO_A_SIZE:
	 *params = (float) ctx->Pixel.MapItoAsize;
	 break;
case GL_PIXEL_MAP_I_TO_B_SIZE:
	 *params = (float) ctx->Pixel.MapItoBsize;
	 break;
case GL_PIXEL_MAP_I_TO_G_SIZE:
	 *params = (float) ctx->Pixel.MapItoGsize;
	 break;
case GL_PIXEL_MAP_I_TO_I_SIZE:
	 *params = (float) ctx->Pixel.MapItoIsize;
	 break;
case GL_PIXEL_MAP_I_TO_R_SIZE:
	 *params = (float) ctx->Pixel.MapItoRsize;
	 break;
case GL_PIXEL_MAP_R_TO_R_SIZE:
	 *params = (float) ctx->Pixel.MapRtoRsize;
	 break;
case GL_PIXEL_MAP_S_TO_S_SIZE:
	 *params = (float) ctx->Pixel.MapStoSsize;
	 break;
case GL_POINT_SIZE:
*params = (float) ctx->Point.Size;
break;
case GL_POINT_SIZE_GRANULARITY:
	 *params = (float) POINT_SIZE_GRANULARITY;
	 break;
case GL_POINT_SIZE_RANGE:
	 params[0] = (float) MIN_POINT_SIZE;
	 params[1] = (float) MAX_POINT_SIZE;
	 break;
case GL_POINT_SMOOTH:
	 *params = (float) ctx->Point.SmoothFlag;
	 break;
case GL_POINT_SMOOTH_HINT:
	 *params = (float) ctx->Hint.PointSmooth;
	 break;
case GL_POINT_SIZE_MIN_EXT:
	 *params = (float) (ctx->Point.MinSize);
	 break;
case GL_POINT_SIZE_MAX_EXT:
	 *params = (float) (ctx->Point.MaxSize);
	 break;
case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
	 *params = (float) (ctx->Point.Threshold);
	 break;
case GL_DISTANCE_ATTENUATION_EXT:
	 params[0] = (float) (ctx->Point.Params[0]);
	 params[1] = (float) (ctx->Point.Params[1]);
	 params[2] = (float) (ctx->Point.Params[2]);
	 break;
case GL_POLYGON_MODE:
	 params[0] = (float) ctx->Polygon.FrontMode;
	 params[1] = (float) ctx->Polygon.BackMode;
	 break;
#ifdef GL_EXT_polygon_offset
case GL_POLYGON_OFFSET_BIAS_EXT:
*params = ctx->Polygon.OffsetUnits;
break;
#endif
case GL_POLYGON_OFFSET_FACTOR:
*params = ctx->Polygon.OffsetFactor;
break;
case GL_POLYGON_OFFSET_UNITS:
*params = ctx->Polygon.OffsetUnits;
break;
case GL_POLYGON_SMOOTH:
	 *params = (float) ctx->Polygon.SmoothFlag;
	 break;
case GL_POLYGON_SMOOTH_HINT:
	 *params = (float) ctx->Hint.PolygonSmooth;
	 break;
case GL_POLYGON_STIPPLE:
	 for (i=0;i<32;i++) {		
	    params[i] = (float) ctx->PolygonStipple[i];
	 }
	 break;
case GL_PROJECTION_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = ctx->ProjectionMatrix[i];
	 }
	 break;
case GL_PROJECTION_STACK_DEPTH:
	 *params = (float) ctx->ProjectionStackDepth;
	 break;
case GL_READ_BUFFER:
	 *params = (float) ctx->Pixel.ReadBuffer;
	 break;
case GL_RED_BIAS:
*params = ctx->Pixel.RedBias;
break;
case GL_RED_BITS:
*params = (float) ctx->Visual->RedBits;
break;
case GL_RED_SCALE:
*params = ctx->Pixel.RedScale;
break;
case GL_RENDER_MODE:
	 *params = (float) ctx->RenderMode;
	 break;
case GL_RGBA_MODE:
	 *params = (float) ctx->Visual->RGBAflag;
	 break;
case GL_SCISSOR_BOX:
	 params[0] = (float) ctx->Scissor.X;
	 params[1] = (float) ctx->Scissor.Y;
	 params[2] = (float) ctx->Scissor.Width;
	 params[3] = (float) ctx->Scissor.Height;
	 break;
case GL_SCISSOR_TEST:
	 *params = (float) ctx->Scissor.Enabled;
	 break;
case GL_SHADE_MODEL:
	 *params = (float) ctx->Light.ShadeModel;
	 break;
case GL_SHARED_TEXTURE_PALETTE_EXT:
*params = (float) ctx->Texture.SharedPalette;
break;
case GL_STENCIL_BITS:
*params = (float) ctx->Visual->StencilBits;
break;
case GL_STENCIL_CLEAR_VALUE:
	 *params = (float) ctx->Stencil.Clear;
	 break;
case GL_STENCIL_FAIL:
	 *params = (float) ctx->Stencil.FailFunc;
	 break;
case GL_STENCIL_FUNC:
	 *params = (float) ctx->Stencil.Function;
	 break;
case GL_STENCIL_PASS_DEPTH_FAIL:
	 *params = (float) ctx->Stencil.ZFailFunc;
	 break;
case GL_STENCIL_PASS_DEPTH_PASS:
	 *params = (float) ctx->Stencil.ZPassFunc;
	 break;
case GL_STENCIL_REF:
	 *params = (float) ctx->Stencil.Ref;
	 break;
case GL_STENCIL_TEST:
	 *params = (float) ctx->Stencil.Enabled;
	 break;
case GL_STENCIL_VALUE_MASK:
	 *params = (float) ctx->Stencil.ValueMask;
	 break;
case GL_STENCIL_WRITEMASK:
	 *params = (float) ctx->Stencil.WriteMask;
	 break;
case GL_STEREO:
	 *params = 0.0F;
	 break;
case GL_SUBPIXEL_BITS:
	 *params = 0.0F;
	 break;
case GL_TEXTURE_1D:
	 *params = (ctx->Texture.Enabled & TEXTURE_1D) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_2D:
	 *params = (ctx->Texture.Enabled & TEXTURE_2D) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_3D_EXT:
	 *params = (ctx->Texture.Enabled & TEXTURE_3D) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_ENV_COLOR:
	 params[0] = ctx->Texture.EnvColor[0];
	 params[1] = ctx->Texture.EnvColor[1];
	 params[2] = ctx->Texture.EnvColor[2];
	 params[3] = ctx->Texture.EnvColor[3];
	 break;
case GL_TEXTURE_ENV_MODE:
	 *params = (float) ctx->Texture.EnvMode;
	 break;
case GL_TEXTURE_GEN_S:
	 *params = (ctx->Texture.TexGenEnabled & S_BIT) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_GEN_T:
	 *params = (ctx->Texture.TexGenEnabled & T_BIT) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_GEN_R:
	 *params = (ctx->Texture.TexGenEnabled & R_BIT) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_GEN_Q:
	 *params = (ctx->Texture.TexGenEnabled & Q_BIT) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_MATRIX:
for (i=0;i<16;i++) {
	    params[i] = ctx->TextureMatrix[i];
	 }
	 break;
case GL_TEXTURE_STACK_DEPTH:
	 *params = (float) ctx->TextureStackDepth;
	 break;
case GL_UNPACK_ALIGNMENT:
	 *params = (float) ctx->Unpack.Alignment;
	 break;
case GL_UNPACK_LSB_FIRST:
	 *params = (float) ctx->Unpack.LsbFirst;
	 break;
case GL_UNPACK_ROW_LENGTH:
	 *params = (float) ctx->Unpack.RowLength;
	 break;
case GL_UNPACK_SKIP_PIXELS:
	 *params = (float) ctx->Unpack.SkipPixels;
	 break;
case GL_UNPACK_SKIP_ROWS:
	 *params = (float) ctx->Unpack.SkipRows;
	 break;
case GL_UNPACK_SWAP_BYTES:
	 *params = (float) ctx->Unpack.SwapBytes;
	 break;
case GL_UNPACK_SKIP_IMAGES_EXT:
*params = (float) ctx->Unpack.SkipImages;
break;
case GL_UNPACK_IMAGE_HEIGHT_EXT:
*params = (float) ctx->Unpack.ImageHeight;
break;
case GL_VIEWPORT:
	 params[0] = (float) ctx->Viewport.X;
	 params[1] = (float) ctx->Viewport.Y;
	 params[2] = (float) ctx->Viewport.Width;
	 params[3] = (float) ctx->Viewport.Height;
	 break;
case GL_ZOOM_X:
	 *params = (float) ctx->Pixel.ZoomX;
	 break;
case GL_ZOOM_Y:
	 *params = (float) ctx->Pixel.ZoomY;
	 break;
case GL_VERTEX_ARRAY_SIZE:
*params = (float) ctx->Array.VertexSize;
break;
case GL_VERTEX_ARRAY_TYPE:
*params = (float) ctx->Array.VertexType;
break;
case GL_VERTEX_ARRAY_STRIDE:
*params = (float) ctx->Array.VertexStride;
break;
case GL_VERTEX_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_NORMAL_ARRAY_TYPE:
*params = (float) ctx->Array.NormalType;
break;
case GL_NORMAL_ARRAY_STRIDE:
*params = (float) ctx->Array.NormalStride;
break;
case GL_NORMAL_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_COLOR_ARRAY_SIZE:
*params = (float) ctx->Array.ColorSize;
break;
case GL_COLOR_ARRAY_TYPE:
*params = (float) ctx->Array.ColorType;
break;
case GL_COLOR_ARRAY_STRIDE:
*params = (float) ctx->Array.ColorStride;
break;
case GL_COLOR_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_INDEX_ARRAY_TYPE:
*params = (float) ctx->Array.IndexType;
break;
case GL_INDEX_ARRAY_STRIDE:
*params = (float) ctx->Array.IndexStride;
break;
case GL_INDEX_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_TEXTURE_COORD_ARRAY_SIZE:
*params = (float) ctx->Array.TexCoordSize;
break;
case GL_TEXTURE_COORD_ARRAY_TYPE:
*params = (float) ctx->Array.TexCoordType;
break;
case GL_TEXTURE_COORD_ARRAY_STRIDE:
*params = (float) ctx->Array.TexCoordStride;
break;
case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_EDGE_FLAG_ARRAY_STRIDE:
*params = (float) ctx->Array.EdgeFlagStride;
break;
case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
*params = 0.0;
break;
case GL_TEXTURE_BINDING_1D:
*params = (float) ctx->Texture.Current1D->Name;
break;
case GL_TEXTURE_BINDING_2D:
*params = (float) ctx->Texture.Current2D->Name;
break;
case GL_TEXTURE_3D_BINDING_EXT:
*params = (float) ctx->Texture.Current2D->Name;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetFloatv" );
}
}
void gl_GetIntegerv( GLcontext *ctx, GLenum pname, GLint *params )
{
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetIntegerv" );
return;
}
switch (pname) {
case GL_ACCUM_RED_BITS:
case GL_ACCUM_GREEN_BITS:
case GL_ACCUM_BLUE_BITS:
case GL_ACCUM_ALPHA_BITS:
*params = (GLint) ctx->Visual->AccumBits;
break;
case GL_ACCUM_CLEAR_VALUE:
params[0] = FLOAT_TO_INT( ctx->Accum.ClearColor[0] );
params[1] = FLOAT_TO_INT( ctx->Accum.ClearColor[1] );
params[2] = FLOAT_TO_INT( ctx->Accum.ClearColor[2] );
params[3] = FLOAT_TO_INT( ctx->Accum.ClearColor[3] );
break;
case GL_ALPHA_BIAS:
*params = (GLint) ctx->Pixel.AlphaBias;
break;
case GL_ALPHA_BITS:
*params = ctx->Visual->AlphaBits;
break;
case GL_ALPHA_SCALE:
*params = (GLint) ctx->Pixel.AlphaScale;
break;
case GL_ALPHA_TEST:
*params = (GLint) ctx->Color.AlphaEnabled;
break;
case GL_ALPHA_TEST_REF:
*params = FLOAT_TO_INT( ctx->Color.AlphaRef );
break;
case GL_ALPHA_TEST_FUNC:
*params = (GLint) ctx->Color.AlphaFunc;
break;
case GL_ATTRIB_STACK_DEPTH:
*params = (GLint) ctx->AttribStackDepth;
break;
case GL_AUTO_NORMAL:
*params = (GLint) ctx->Eval.AutoNormal;
break;
case GL_AUX_BUFFERS:
*params = (GLint) NUM_AUX_BUFFERS;
break;
case GL_BLEND:
*params = (GLint) ctx->Color.BlendEnabled;
break;
case GL_BLEND_DST:
*params = (GLint) ctx->Color.BlendDst;
break;
case GL_BLEND_SRC:
*params = (GLint) ctx->Color.BlendSrc;
break;
case GL_BLEND_EQUATION_EXT:
	 *params = (GLint) ctx->Color.BlendEquation;
	 break;
case GL_BLEND_COLOR_EXT:
	 params[0] = FLOAT_TO_INT( ctx->Color.BlendColor[0] );
	 params[1] = FLOAT_TO_INT( ctx->Color.BlendColor[1] );
	 params[2] = FLOAT_TO_INT( ctx->Color.BlendColor[2] );
	 params[3] = FLOAT_TO_INT( ctx->Color.BlendColor[3] );
	 break;
case GL_BLUE_BIAS:
*params = (GLint) ctx->Pixel.BlueBias;
break;
case GL_BLUE_BITS:
*params = (GLint) ctx->Visual->BlueBits;
break;
case GL_BLUE_SCALE:
*params = (GLint) ctx->Pixel.BlueScale;
break;
case GL_CLIENT_ATTRIB_STACK_DEPTH:
*params = ctx->ClientAttribStackDepth;
break;
case GL_CLIP_PLANE0:
case GL_CLIP_PLANE1:
case GL_CLIP_PLANE2:
case GL_CLIP_PLANE3:
case GL_CLIP_PLANE4:
case GL_CLIP_PLANE5:
i = (GLint) (pname - GL_CLIP_PLANE0);
*params = (GLint) ctx->Transform.ClipEnabled[i];
break;
case GL_COLOR_CLEAR_VALUE:
params[0] = FLOAT_TO_INT( ctx->Color.ClearColor[0] );
params[1] = FLOAT_TO_INT( ctx->Color.ClearColor[1] );
params[2] = FLOAT_TO_INT( ctx->Color.ClearColor[2] );
params[3] = FLOAT_TO_INT( ctx->Color.ClearColor[3] );
break;
case GL_COLOR_MATERIAL:
*params = (GLint) ctx->Light.ColorMaterialEnabled;
break;
case GL_COLOR_MATERIAL_FACE:
*params = (GLint) ctx->Light.ColorMaterialFace;
break;
case GL_COLOR_MATERIAL_PARAMETER:
*params = (GLint) ctx->Light.ColorMaterialMode;
break;
case GL_COLOR_WRITEMASK:
params[0] = (ctx->Color.ColorMask & 8) ? 1 : 0;
params[1] = (ctx->Color.ColorMask & 4) ? 1 : 0;
params[2] = (ctx->Color.ColorMask & 2) ? 1 : 0;
params[3] = (ctx->Color.ColorMask & 1) ? 1 : 0;
break;
case GL_CULL_FACE:
*params = (GLint) ctx->Polygon.CullFlag;
break;
case GL_CULL_FACE_MODE:
*params = (GLint) ctx->Polygon.CullFaceMode;
break;
case GL_CURRENT_COLOR:
params[0] = FLOAT_TO_INT( (ctx->Current.ByteColor[0]*ctx->Visual->InvRedScale) );
params[1] = FLOAT_TO_INT( (ctx->Current.ByteColor[1]*ctx->Visual->InvGreenScale) );
params[2] = FLOAT_TO_INT( (ctx->Current.ByteColor[2]*ctx->Visual->InvBlueScale) );
params[3] = FLOAT_TO_INT( (ctx->Current.ByteColor[3]*ctx->Visual->InvAlphaScale) );
break;
case GL_CURRENT_INDEX:
*params = (GLint) ctx->Current.Index;
break;
case GL_CURRENT_NORMAL:
params[0] = FLOAT_TO_INT( ctx->Current.Normal[0] );
params[1] = FLOAT_TO_INT( ctx->Current.Normal[1] );
params[2] = FLOAT_TO_INT( ctx->Current.Normal[2] );
break;
case GL_CURRENT_RASTER_COLOR:
	 params[0] = FLOAT_TO_INT( ctx->Current.RasterColor[0] );
	 params[1] = FLOAT_TO_INT( ctx->Current.RasterColor[1] );
	 params[2] = FLOAT_TO_INT( ctx->Current.RasterColor[2] );
	 params[3] = FLOAT_TO_INT( ctx->Current.RasterColor[3] );
	 break;
case GL_CURRENT_RASTER_DISTANCE:
	 params[0] = (GLint) ctx->Current.RasterDistance;
	 break;
case GL_CURRENT_RASTER_INDEX:
	 *params = (GLint) ctx->Current.RasterIndex;
	 break;
case GL_CURRENT_RASTER_POSITION:
	 params[0] = (GLint) ctx->Current.RasterPos[0];
	 params[1] = (GLint) ctx->Current.RasterPos[1];
	 params[2] = (GLint) ctx->Current.RasterPos[2];
	 params[3] = (GLint) ctx->Current.RasterPos[3];
	 break;
case GL_CURRENT_RASTER_TEXTURE_COORDS:
	 params[0] = (GLint) ctx->Current.RasterTexCoord[0];
	 params[1] = (GLint) ctx->Current.RasterTexCoord[1];
	 params[2] = (GLint) ctx->Current.RasterTexCoord[2];
	 params[3] = (GLint) ctx->Current.RasterTexCoord[3];
	 break;
case GL_CURRENT_RASTER_POSITION_VALID:
	 *params = (GLint) ctx->Current.RasterPosValid;
	 break;
case GL_CURRENT_TEXTURE_COORDS:
params[0] = (GLint) ctx->Current.TexCoord[0];
params[1] = (GLint) ctx->Current.TexCoord[1];
params[2] = (GLint) ctx->Current.TexCoord[2];
params[3] = (GLint) ctx->Current.TexCoord[3];
	 break;
case GL_DEPTH_BIAS:
*params = (GLint) ctx->Pixel.DepthBias;
	 break;
case GL_DEPTH_BITS:
	 *params = ctx->Visual->DepthBits;
	 break;
case GL_DEPTH_CLEAR_VALUE:
*params = (GLint) ctx->Depth.Clear;
	 break;
case GL_DEPTH_FUNC:
*params = (GLint) ctx->Depth.Func;
	 break;
case GL_DEPTH_RANGE:
params[0] = (GLint) ctx->Viewport.Near;
params[1] = (GLint) ctx->Viewport.Far;
	 break;
case GL_DEPTH_SCALE:
*params = (GLint) ctx->Pixel.DepthScale;
	 break;
case GL_DEPTH_TEST:
*params = (GLint) ctx->Depth.Test;
	 break;
case GL_DEPTH_WRITEMASK:
	 *params = (GLint) ctx->Depth.Mask;
	 break;
case GL_DITHER:
	 *params = (GLint) ctx->Color.DitherFlag;
	 break;
case GL_DOUBLEBUFFER:
	 *params = (GLint) ctx->Visual->DBflag;
	 break;
case GL_DRAW_BUFFER:
	 *params = (GLint) ctx->Color.DrawBuffer;
	 break;
case GL_EDGE_FLAG:
	 *params = (GLint) ctx->Current.EdgeFlag;
	 break;
case GL_FEEDBACK_BUFFER_SIZE:
*params = ctx->Feedback.BufferSize;
break;
case GL_FEEDBACK_BUFFER_TYPE:
*params = ctx->Feedback.Type;
break;
case GL_FOG:
	 *params = (GLint) ctx->Fog.Enabled;
	 break;
case GL_FOG_COLOR:
	 params[0] = FLOAT_TO_INT( ctx->Fog.Color[0] );
	 params[1] = FLOAT_TO_INT( ctx->Fog.Color[1] );
	 params[2] = FLOAT_TO_INT( ctx->Fog.Color[2] );
	 params[3] = FLOAT_TO_INT( ctx->Fog.Color[3] );
	 break;
case GL_FOG_DENSITY:
	 *params = (GLint) ctx->Fog.Density;
	 break;
case GL_FOG_END:
	 *params = (GLint) ctx->Fog.End;
	 break;
case GL_FOG_HINT:
	 *params = (GLint) ctx->Hint.Fog;
	 break;
case GL_FOG_INDEX:
	 *params = (GLint) ctx->Fog.Index;
	 break;
case GL_FOG_MODE:
	 *params = (GLint) ctx->Fog.Mode;
	 break;
case GL_FOG_START:
	 *params = (GLint) ctx->Fog.Start;
	 break;
case GL_FRONT_FACE:
	 *params = (GLint) ctx->Polygon.FrontFace;
	 break;
case GL_GREEN_BIAS:
*params = (GLint) ctx->Pixel.GreenBias;
break;
case GL_GREEN_BITS:
*params = (GLint) ctx->Visual->GreenBits;
break;
case GL_GREEN_SCALE:
*params = (GLint) ctx->Pixel.GreenScale;
break;
case GL_INDEX_BITS:
*params = (GLint) ctx->Visual->IndexBits;
break;
case GL_INDEX_CLEAR_VALUE:
*params = (GLint) ctx->Color.ClearIndex;
break;
case GL_INDEX_MODE:
	 *params = ctx->Visual->RGBAflag ? 0 : 1;
	 break;
case GL_INDEX_OFFSET:
	 *params = ctx->Pixel.IndexOffset;
	 break;
case GL_INDEX_SHIFT:
	 *params = ctx->Pixel.IndexShift;
	 break;
case GL_INDEX_WRITEMASK:
	 *params = (GLint) ctx->Color.IndexMask;
	 break;
case GL_LIGHT0:
case GL_LIGHT1:
case GL_LIGHT2:
case GL_LIGHT3:
case GL_LIGHT4:
case GL_LIGHT5:
case GL_LIGHT6:
case GL_LIGHT7:
	 *params = (GLint) ctx->Light.Light[pname-GL_LIGHT0].Enabled;
	 break;
case GL_LIGHTING:
	 *params = (GLint) ctx->Light.Enabled;
	 break;
case GL_LIGHT_MODEL_AMBIENT:
	 params[0] = FLOAT_TO_INT( ctx->Light.Model.Ambient[0] );
	 params[1] = FLOAT_TO_INT( ctx->Light.Model.Ambient[1] );
	 params[2] = FLOAT_TO_INT( ctx->Light.Model.Ambient[2] );
	 params[3] = FLOAT_TO_INT( ctx->Light.Model.Ambient[3] );
	 break;
case GL_LIGHT_MODEL_LOCAL_VIEWER:
	 *params = (GLint) ctx->Light.Model.LocalViewer;
	 break;
case GL_LIGHT_MODEL_TWO_SIDE:
	 *params = (GLint) ctx->Light.Model.TwoSide;
	 break;
case GL_LINE_SMOOTH:
	 *params = (GLint) ctx->Line.SmoothFlag;
	 break;
case GL_LINE_SMOOTH_HINT:
	 *params = (GLint) ctx->Hint.LineSmooth;
	 break;
case GL_LINE_STIPPLE:
	 *params = (GLint) ctx->Line.StippleFlag;
	 break;
case GL_LINE_STIPPLE_PATTERN:
*params = (GLint) ctx->Line.StipplePattern;
break;
case GL_LINE_STIPPLE_REPEAT:
*params = (GLint) ctx->Line.StippleFactor;
break;
case GL_LINE_WIDTH:
	 *params = (GLint) ctx->Line.Width;
	 break;
case GL_LINE_WIDTH_GRANULARITY:
	 *params = (GLint) LINE_WIDTH_GRANULARITY;
	 break;
case GL_LINE_WIDTH_RANGE:
	 params[0] = (GLint) MIN_LINE_WIDTH;
	 params[1] = (GLint) MAX_LINE_WIDTH;
	 break;
case GL_LIST_BASE:
	 *params = (GLint) ctx->List.ListBase;
	 break;
case GL_LIST_INDEX:
	 *params = (GLint) gl_list_index();
	 break;
case GL_LIST_MODE:
	 *params = ctx->ExecuteFlag ? (GLint) GL_COMPILE_AND_EXECUTE
	   			  : (GLint) GL_COMPILE;
	 break;
case GL_INDEX_LOGIC_OP:
	 *params = (GLint) ctx->Color.IndexLogicOpEnabled;
	 break;
case GL_COLOR_LOGIC_OP:
	 *params = (GLint) ctx->Color.ColorLogicOpEnabled;
	 break;
case GL_LOGIC_OP_MODE:
*params = (GLint) ctx->Color.LogicOp;
break;
case GL_MAP1_COLOR_4:
	 *params = (GLint) ctx->Eval.Map1Color4;
	 break;
case GL_MAP1_GRID_DOMAIN:
	 params[0] = (GLint) ctx->Eval.MapGrid1u1;
	 params[1] = (GLint) ctx->Eval.MapGrid1u2;
	 break;
case GL_MAP1_GRID_SEGMENTS:
	 *params = (GLint) ctx->Eval.MapGrid1un;
	 break;
case GL_MAP1_INDEX:
	 *params = (GLint) ctx->Eval.Map1Index;
	 break;
case GL_MAP1_NORMAL:
	 *params = (GLint) ctx->Eval.Map1Normal;
	 break;
case GL_MAP1_TEXTURE_COORD_1:
	 *params = (GLint) ctx->Eval.Map1TextureCoord1;
	 break;
case GL_MAP1_TEXTURE_COORD_2:
	 *params = (GLint) ctx->Eval.Map1TextureCoord2;
	 break;
case GL_MAP1_TEXTURE_COORD_3:
	 *params = (GLint) ctx->Eval.Map1TextureCoord3;
	 break;
case GL_MAP1_TEXTURE_COORD_4:
	 *params = (GLint) ctx->Eval.Map1TextureCoord4;
	 break;
case GL_MAP1_VERTEX_3:
	 *params = (GLint) ctx->Eval.Map1Vertex3;
	 break;
case GL_MAP1_VERTEX_4:
	 *params = (GLint) ctx->Eval.Map1Vertex4;
	 break;
case GL_MAP2_COLOR_4:
	 *params = (GLint) ctx->Eval.Map2Color4;
	 break;
case GL_MAP2_GRID_DOMAIN:
	 params[0] = (GLint) ctx->Eval.MapGrid2u1;
	 params[1] = (GLint) ctx->Eval.MapGrid2u2;
	 params[2] = (GLint) ctx->Eval.MapGrid2v1;
	 params[3] = (GLint) ctx->Eval.MapGrid2v2;
	 break;
case GL_MAP2_GRID_SEGMENTS:
	 params[0] = (GLint) ctx->Eval.MapGrid2un;
	 params[1] = (GLint) ctx->Eval.MapGrid2vn;
	 break;
case GL_MAP2_INDEX:
	 *params = (GLint) ctx->Eval.Map2Index;
	 break;
case GL_MAP2_NORMAL:
	 *params = (GLint) ctx->Eval.Map2Normal;
	 break;
case GL_MAP2_TEXTURE_COORD_1:
	 *params = (GLint) ctx->Eval.Map2TextureCoord1;
	 break;
case GL_MAP2_TEXTURE_COORD_2:
	 *params = (GLint) ctx->Eval.Map2TextureCoord2;
	 break;
case GL_MAP2_TEXTURE_COORD_3:
	 *params = (GLint) ctx->Eval.Map2TextureCoord3;
	 break;
case GL_MAP2_TEXTURE_COORD_4:
	 *params = (GLint) ctx->Eval.Map2TextureCoord4;
	 break;
case GL_MAP2_VERTEX_3:
	 *params = (GLint) ctx->Eval.Map2Vertex3;
	 break;
case GL_MAP2_VERTEX_4:
	 *params = (GLint) ctx->Eval.Map2Vertex4;
	 break;
case GL_MAP_COLOR:
	 *params = (GLint) ctx->Pixel.MapColorFlag;
	 break;
case GL_MAP_STENCIL:
	 *params = (GLint) ctx->Pixel.MapStencilFlag;
	 break;
case GL_MATRIX_MODE:
	 *params = (GLint) ctx->Transform.MatrixMode;
	 break;
case GL_MAX_ATTRIB_STACK_DEPTH:
*params = (GLint) MAX_ATTRIB_STACK_DEPTH;
break;
case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
*params = (GLint) MAX_CLIENT_ATTRIB_STACK_DEPTH;
break;
case GL_MAX_CLIP_PLANES:
*params = (GLint) MAX_CLIP_PLANES;
break;
case GL_MAX_EVAL_ORDER:
	 *params = (GLint) MAX_EVAL_ORDER;
	 break;
case GL_MAX_LIGHTS:
*params = (GLint) MAX_LIGHTS;
break;
case GL_MAX_LIST_NESTING:
*params = (GLint) MAX_LIST_NESTING;
break;
case GL_MAX_MODELVIEW_STACK_DEPTH:
*params = (GLint) MAX_MODELVIEW_STACK_DEPTH;
break;
case GL_MAX_NAME_STACK_DEPTH:
	 *params = (GLint) MAX_NAME_STACK_DEPTH;
	 break;
case GL_MAX_PIXEL_MAP_TABLE:
	 *params = (GLint) MAX_PIXEL_MAP_TABLE;
	 break;
case GL_MAX_PROJECTION_STACK_DEPTH:
*params = (GLint) MAX_PROJECTION_STACK_DEPTH;
break;
case GL_MAX_TEXTURE_SIZE:
	 *params = (GLint) MAX_TEXTURE_SIZE;
	 break;
case GL_MAX_TEXTURE_STACK_DEPTH:
	 *params = (GLint) MAX_TEXTURE_STACK_DEPTH;
	 break;
case GL_MAX_VIEWPORT_DIMS:
params[0] = (GLint) MAX_WIDTH;
params[1] = (GLint) MAX_HEIGHT;
break;
case GL_MODELVIEW_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = (GLint) ctx->ModelViewMatrix[i];
	 }
	 break;
case GL_MODELVIEW_STACK_DEPTH:
	 *params = (GLint) ctx->ModelViewStackDepth;
	 break;
case GL_NAME_STACK_DEPTH:
	 *params = (GLint) ctx->Select.NameStackDepth;
	 break;
case GL_NORMALIZE:
	 *params = (GLint) ctx->Transform.Normalize;
	 break;
case GL_PACK_ALIGNMENT:
	 *params = ctx->Pack.Alignment;
	 break;
case GL_PACK_LSB_FIRST:
	 *params = (GLint) ctx->Pack.LsbFirst;
	 break;
case GL_PACK_ROW_LENGTH:
	 *params = ctx->Pack.RowLength;
	 break;
case GL_PACK_SKIP_PIXELS:
	 *params = ctx->Pack.SkipPixels;
	 break;
case GL_PACK_SKIP_ROWS:
	 *params = ctx->Pack.SkipRows;
	 break;
case GL_PACK_SWAP_BYTES:
	 *params = (GLint) ctx->Pack.SwapBytes;
	 break;
case GL_PACK_SKIP_IMAGES_EXT:
*params = ctx->Pack.SkipImages;
break;
case GL_PACK_IMAGE_HEIGHT_EXT:
*params = ctx->Pack.ImageHeight;
break;
case GL_PERSPECTIVE_CORRECTION_HINT:
	 *params = (GLint) ctx->Hint.PerspectiveCorrection;
	 break;
case GL_PIXEL_MAP_A_TO_A_SIZE:
	 *params = ctx->Pixel.MapAtoAsize;
	 break;
case GL_PIXEL_MAP_B_TO_B_SIZE:
	 *params = ctx->Pixel.MapBtoBsize;
	 break;
case GL_PIXEL_MAP_G_TO_G_SIZE:
	 *params = ctx->Pixel.MapGtoGsize;
	 break;
case GL_PIXEL_MAP_I_TO_A_SIZE:
	 *params = ctx->Pixel.MapItoAsize;
	 break;
case GL_PIXEL_MAP_I_TO_B_SIZE:
	 *params = ctx->Pixel.MapItoBsize;
	 break;
case GL_PIXEL_MAP_I_TO_G_SIZE:
	 *params = ctx->Pixel.MapItoGsize;
	 break;
case GL_PIXEL_MAP_I_TO_I_SIZE:
	 *params = ctx->Pixel.MapItoIsize;
	 break;
case GL_PIXEL_MAP_I_TO_R_SIZE:
	 *params = ctx->Pixel.MapItoRsize;
	 break;
case GL_PIXEL_MAP_R_TO_R_SIZE:
	 *params = ctx->Pixel.MapRtoRsize;
	 break;
case GL_PIXEL_MAP_S_TO_S_SIZE:
	 *params = ctx->Pixel.MapStoSsize;
	 break;
case GL_POINT_SIZE:
*params = (GLint) ctx->Point.Size;
break;
case GL_POINT_SIZE_GRANULARITY:
	 *params = (GLint) POINT_SIZE_GRANULARITY;
	 break;
case GL_POINT_SIZE_RANGE:
	 params[0] = (GLint) MIN_POINT_SIZE;
	 params[1] = (GLint) MAX_POINT_SIZE;
	 break;
case GL_POINT_SMOOTH:
	 *params = (GLint) ctx->Point.SmoothFlag;
	 break;
case GL_POINT_SMOOTH_HINT:
	 *params = (GLint) ctx->Hint.PointSmooth;
	 break;
case GL_POINT_SIZE_MIN_EXT:
	 *params = (GLint) (ctx->Point.MinSize);
	 break;
case GL_POINT_SIZE_MAX_EXT:
	 *params = (GLint) (ctx->Point.MaxSize);
	 break;
case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
	 *params = (GLint) (ctx->Point.Threshold);
	 break;
case GL_DISTANCE_ATTENUATION_EXT:
	 params[0] = (GLint) (ctx->Point.Params[0]);
	 params[1] = (GLint) (ctx->Point.Params[1]);
	 params[2] = (GLint) (ctx->Point.Params[2]);
	 break;
case GL_POLYGON_MODE:
	 params[0] = (GLint) ctx->Polygon.FrontMode;
	 params[1] = (GLint) ctx->Polygon.BackMode;
	 break;
#ifdef GL_EXT_polygon_offset
case GL_POLYGON_OFFSET_BIAS_EXT:
*params = (GLint) ctx->Polygon.OffsetUnits;
break;
#endif
case GL_POLYGON_OFFSET_FACTOR:
*params = (GLint) ctx->Polygon.OffsetFactor;
break;
case GL_POLYGON_OFFSET_UNITS:
*params = (GLint) ctx->Polygon.OffsetUnits;
break;
case GL_POLYGON_SMOOTH:
	 *params = (GLint) ctx->Polygon.SmoothFlag;
	 break;
case GL_POLYGON_SMOOTH_HINT:
	 *params = (GLint) ctx->Hint.PolygonSmooth;
	 break;
case GL_POLYGON_STIPPLE:
	 for (i=0;i<32;i++) {		
	    params[i] = (GLint) ctx->PolygonStipple[i];
	 }
	 break;
case GL_PROJECTION_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = (GLint) ctx->ProjectionMatrix[i];
	 }
	 break;
case GL_PROJECTION_STACK_DEPTH:
	 *params = (GLint) ctx->ProjectionStackDepth;
	 break;
case GL_READ_BUFFER:
	 *params = (GLint) ctx->Pixel.ReadBuffer;
	 break;
case GL_RED_BIAS:
*params = (GLint) ctx->Pixel.RedBias;
break;
case GL_RED_BITS:
*params = (GLint) ctx->Visual->RedBits;
break;
case GL_RED_SCALE:
*params = (GLint) ctx->Pixel.RedScale;
break;
case GL_RENDER_MODE:
	 *params = (GLint) ctx->RenderMode;
	 break;
case GL_RGBA_MODE:
	 *params = (GLint) ctx->Visual->RGBAflag;
	 break;
case GL_SCISSOR_BOX:
	 params[0] = (GLint) ctx->Scissor.X;
	 params[1] = (GLint) ctx->Scissor.Y;
	 params[2] = (GLint) ctx->Scissor.Width;
	 params[3] = (GLint) ctx->Scissor.Height;
	 break;
case GL_SCISSOR_TEST:
	 *params = (GLint) ctx->Scissor.Enabled;
	 break;
case GL_SHADE_MODEL:
	 *params = (GLint) ctx->Light.ShadeModel;
	 break;
case GL_SHARED_TEXTURE_PALETTE_EXT:
*params = (GLint) ctx->Texture.SharedPalette;
break;
case GL_STENCIL_BITS:
*params = ctx->Visual->StencilBits;
break;
case GL_STENCIL_CLEAR_VALUE:
	 *params = (GLint) ctx->Stencil.Clear;
	 break;
case GL_STENCIL_FAIL:
	 *params = (GLint) ctx->Stencil.FailFunc;
	 break;
case GL_STENCIL_FUNC:
	 *params = (GLint) ctx->Stencil.Function;
	 break;
case GL_STENCIL_PASS_DEPTH_FAIL:
	 *params = (GLint) ctx->Stencil.ZFailFunc;
	 break;
case GL_STENCIL_PASS_DEPTH_PASS:
	 *params = (GLint) ctx->Stencil.ZPassFunc;
	 break;
case GL_STENCIL_REF:
	 *params = (GLint) ctx->Stencil.Ref;
	 break;
case GL_STENCIL_TEST:
	 *params = (GLint) ctx->Stencil.Enabled;
	 break;
case GL_STENCIL_VALUE_MASK:
	 *params = (GLint) ctx->Stencil.ValueMask;
	 break;
case GL_STENCIL_WRITEMASK:
	 *params = (GLint) ctx->Stencil.WriteMask;
	 break;
case GL_STEREO:
	 *params = 0;
	 break;
case GL_SUBPIXEL_BITS:
	 *params = 0;
	 break;
case GL_TEXTURE_1D:
	 *params = (ctx->Texture.Enabled & TEXTURE_1D) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_2D:
	 *params = (ctx->Texture.Enabled & TEXTURE_2D) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_3D_EXT:
	 *params = (ctx->Texture.Enabled & TEXTURE_3D) ? 1.0 : 0.0;
	 break;
case GL_TEXTURE_ENV_COLOR:
	 params[0] = FLOAT_TO_INT( ctx->Texture.EnvColor[0] );
	 params[1] = FLOAT_TO_INT( ctx->Texture.EnvColor[1] );
	 params[2] = FLOAT_TO_INT( ctx->Texture.EnvColor[2] );
	 params[3] = FLOAT_TO_INT( ctx->Texture.EnvColor[3] );
	 break;
case GL_TEXTURE_ENV_MODE:
	 *params = (GLint) ctx->Texture.EnvMode;
	 break;
case GL_TEXTURE_GEN_S:
	 *params = (ctx->Texture.TexGenEnabled & S_BIT) ? 1 : 0;
	 break;
case GL_TEXTURE_GEN_T:
	 *params = (ctx->Texture.TexGenEnabled & T_BIT) ? 1 : 0;
	 break;
case GL_TEXTURE_GEN_R:
	 *params = (ctx->Texture.TexGenEnabled & R_BIT) ? 1 : 0;
	 break;
case GL_TEXTURE_GEN_Q:
	 *params = (ctx->Texture.TexGenEnabled & Q_BIT) ? 1 : 0;
	 break;
case GL_TEXTURE_MATRIX:
for (i=0;i<16;i++) {
	    params[i] = (GLint) ctx->TextureMatrix[i];
	 }
	 break;
case GL_TEXTURE_STACK_DEPTH:
	 *params = (GLint) ctx->TextureStackDepth;
	 break;
case GL_UNPACK_ALIGNMENT:
	 *params = ctx->Unpack.Alignment;
	 break;
case GL_UNPACK_LSB_FIRST:
	 *params = (GLint) ctx->Unpack.LsbFirst;
	 break;
case GL_UNPACK_ROW_LENGTH:
	 *params = ctx->Unpack.RowLength;
	 break;
case GL_UNPACK_SKIP_PIXELS:
	 *params = ctx->Unpack.SkipPixels;
	 break;
case GL_UNPACK_SKIP_ROWS:
	 *params = ctx->Unpack.SkipRows;
	 break;
case GL_UNPACK_SWAP_BYTES:
	 *params = (GLint) ctx->Unpack.SwapBytes;
	 break;
case GL_UNPACK_SKIP_IMAGES_EXT:
*params = ctx->Unpack.SkipImages;
break;
case GL_UNPACK_IMAGE_HEIGHT_EXT:
*params = ctx->Unpack.ImageHeight;
break;
case GL_VIEWPORT:
params[0] = (GLint) ctx->Viewport.X;
params[1] = (GLint) ctx->Viewport.Y;
params[2] = (GLint) ctx->Viewport.Width;
params[3] = (GLint) ctx->Viewport.Height;
break;
case GL_ZOOM_X:
	 *params = (GLint) ctx->Pixel.ZoomX;
	 break;
case GL_ZOOM_Y:
	 *params = (GLint) ctx->Pixel.ZoomY;
	 break;
case GL_VERTEX_ARRAY_SIZE:
*params = ctx->Array.VertexSize;
break;
case GL_VERTEX_ARRAY_TYPE:
*params = ctx->Array.VertexType;
break;
case GL_VERTEX_ARRAY_STRIDE:
*params = ctx->Array.VertexStride;
break;
case GL_VERTEX_ARRAY_COUNT_EXT:
*params = 0;
break;
case GL_NORMAL_ARRAY_TYPE:
*params = ctx->Array.NormalType;
break;
case GL_NORMAL_ARRAY_STRIDE:
*params = ctx->Array.NormalStride;
break;
case GL_NORMAL_ARRAY_COUNT_EXT:
*params = 0;
break;
case GL_COLOR_ARRAY_SIZE:
*params = ctx->Array.ColorSize;
break;
case GL_COLOR_ARRAY_TYPE:
*params = ctx->Array.ColorType;
break;
case GL_COLOR_ARRAY_STRIDE:
*params = ctx->Array.ColorStride;
break;
case GL_COLOR_ARRAY_COUNT_EXT:
*params = 0;
break;
case GL_INDEX_ARRAY_TYPE:
*params = ctx->Array.IndexType;
break;
case GL_INDEX_ARRAY_STRIDE:
*params = ctx->Array.IndexStride;
break;
case GL_INDEX_ARRAY_COUNT_EXT:
*params = 0;
break;
case GL_TEXTURE_COORD_ARRAY_SIZE:
*params = ctx->Array.TexCoordSize;
break;
case GL_TEXTURE_COORD_ARRAY_TYPE:
*params = ctx->Array.TexCoordType;
break;
case GL_TEXTURE_COORD_ARRAY_STRIDE:
*params = ctx->Array.TexCoordStride;
break;
case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
*params = 0;
break;
case GL_EDGE_FLAG_ARRAY_STRIDE:
*params = ctx->Array.EdgeFlagStride;
break;
case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
*params = 0;
break;
case GL_TEXTURE_BINDING_1D:
*params = ctx->Texture.Current1D->Name;
break;
case GL_TEXTURE_BINDING_2D:
*params = ctx->Texture.Current2D->Name;
break;
case GL_TEXTURE_3D_BINDING_EXT:
*params = ctx->Texture.Current3D->Name;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
}
}
void gl_GetPointerv( GLcontext *ctx, GLenum pname, GLvoid **params )
{
switch (pname) {
case GL_VERTEX_ARRAY_POINTER:
*params = ctx->Array.VertexPtr;
break;
case GL_NORMAL_ARRAY_POINTER:
*params = ctx->Array.NormalPtr;
break;
case GL_COLOR_ARRAY_POINTER:
*params = ctx->Array.ColorPtr;
break;
case GL_INDEX_ARRAY_POINTER:
*params = ctx->Array.IndexPtr;
break;
case GL_TEXTURE_COORD_ARRAY_POINTER:
*params = ctx->Array.TexCoordPtr;
break;
case GL_EDGE_FLAG_ARRAY_POINTER:
*params = ctx->Array.EdgeFlagPtr;
break;
case GL_FEEDBACK_BUFFER_POINTER:
*params = ctx->Feedback.Buffer;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetPointerv" );
return;
}
}
/* 当前文件是D:\Read\hash.c*/

#ifdef PC_HEADER
#else
#endif
#define TABLE_SIZE 1001
struct HashEntry {
GLuint Key;
void *Data;
struct HashEntry *Next;
};
struct HashTable {
struct HashEntry *Table[TABLE_SIZE];
GLuint MaxKey;
};
struct HashTable *NewHashTable(void)
{
return (struct HashTable *) calloc(sizeof (struct HashTable), 1);
}
void DeleteHashTable(struct HashTable *table)
{
GLuint i;
assert(table);
for (i=0;i<TABLE_SIZE;i++) {
struct HashEntry *entry = table->Table[i];
while (entry) {
	 struct HashEntry *next = entry->Next;
	 free(entry);
	 entry = next;
}
}
free(table);
}
void *HashLookup(const struct HashTable *table, GLuint key)
{
GLuint pos;
struct HashEntry *entry;
assert(table);
assert(key);
pos = key % TABLE_SIZE;
entry = table->Table[pos];
while (entry) {
if (entry->Key == key) {
	 return entry->Data;
}
entry = entry->Next;
}
return NULL;
}
void HashInsert(struct HashTable *table, GLuint key, void *data)
{
GLuint pos;
struct HashEntry *entry;
assert(table);
assert(key);
if (key > table->MaxKey)
table->MaxKey = key;
pos = key % TABLE_SIZE;
entry = table->Table[pos];
while (entry) {
if (entry->Key == key) {
	 entry->Data = data;
	 return;
}
entry = entry->Next;
}
entry = (struct HashEntry *) calloc(sizeof(struct HashEntry), 1);
entry->Key = key;
entry->Data = data;
entry->Next = table->Table[pos];
table->Table[pos] = entry;
}
void HashRemove(struct HashTable *table, GLuint key)
{
GLuint pos;
struct HashEntry *entry, *prev;
assert(table);
assert(key);
pos = key % TABLE_SIZE;
prev = NULL;
entry = table->Table[pos];
while (entry) {
if (entry->Key == key) {
if (prev) {
prev->Next = entry->Next;
}
else {
table->Table[pos] = entry->Next;
}
free(entry);
	 return;
}
prev = entry;
entry = entry->Next;
}
}
GLuint HashFirstEntry(const struct HashTable *table)
{
GLuint pos;
assert(table);
for (pos=0; pos < TABLE_SIZE; pos++) {
if (table->Table[pos])
return table->Table[pos]->Key;
}
return 0;
}
void HashPrint(const struct HashTable *table)
{
GLuint i;
assert(table);
for (i=0;i<TABLE_SIZE;i++) {
struct HashEntry *entry = table->Table[i];
while (entry) {
	 printf("%u %p\n", entry->Key, entry->Data);
	 entry = entry->Next;
}
}
}
GLuint HashFindFreeKeyBlock(const struct HashTable *table, GLuint numKeys)
{
GLuint maxKey = ~0;
if (maxKey - numKeys > table->MaxKey) {
return table->MaxKey + 1;
}
else {
GLuint freeCount = 0;
GLuint freeStart = 0;
GLuint key;
for (key=0; key!=maxKey; key++) {
	 if (HashLookup(table, key)) {
	
	    freeCount = 0;
	    freeStart = key+1;
	 }
	 else {
	
	    freeCount++;
	    if (freeCount == numKeys) {
	       return freeStart;
	    }
	 }
}
return 0;
}
}

/* 当前文件是D:\Read\image.c*/

#ifdef PC_HEADER
#else
#endif
void gl_flip_bytes( GLubyte *p, GLuint n )
{
register GLuint i, a, b;
for (i=0;i<n;i++) {
b = (GLuint) p[i];
a = ((b & 0x01) << 7) |
	  ((b & 0x02) << 5) |
	  ((b & 0x04) << 3) |
	  ((b & 0x08) << 1) |
	  ((b & 0x10) >> 1) |
	  ((b & 0x20) >> 3) |
	  ((b & 0x40) >> 5) |
	  ((b & 0x80) >> 7);
p[i] = (GLubyte) a;
}
}
void gl_swap2( GLushort *p, GLuint n )
{
register GLuint i;
for (i=0;i<n;i++) {
p[i] = (p[i] >> 8) | ((p[i] << 8) & 0xff00);
}
}
void gl_swap4( GLuint *p, GLuint n )
{
register GLuint i, a, b;
for (i=0;i<n;i++) {
b = p[i];
a =  (b >> 24)
	| ((b >> 8) & 0xff00)
	| ((b << 8) & 0xff0000)
	| ((b << 24) & 0xff000000);
p[i] = a;
}
}
GLint gl_sizeof_type( GLenum type )
{
switch (type) {
case GL_BITMAP:
	 return 0;
case GL_UNSIGNED_BYTE:
return sizeof(GLubyte);
case GL_BYTE:
	 return sizeof(GLbyte);
case GL_UNSIGNED_SHORT:
	 return sizeof(GLushort);
case GL_SHORT:
	 return sizeof(GLshort);
case GL_UNSIGNED_INT:
	 return sizeof(GLuint);
case GL_INT:
	 return sizeof(GLint);
case GL_FLOAT:
	 return sizeof(float);
default:
return -1;
}
}
GLint gl_components_in_format( GLenum format )
{
switch (format) {
case GL_COLOR_INDEX:
case GL_STENCIL_INDEX:
case GL_DEPTH_COMPONENT:
case GL_RED:
case GL_GREEN:
case GL_BLUE:
case GL_ALPHA:
case GL_LUMINANCE:
return 1;
case GL_LUMINANCE_ALPHA:
	 return 2;
case GL_RGB:
	 return 3;
case GL_RGBA:
	 return 4;
default:
return -1;
}
}
GLvoid *gl_pixel_addr_in_image( struct gl_pixelstore_attrib *packing,
const GLvoid *image, GLsizei width,
GLsizei height, GLenum format, GLenum type,
GLint img, GLint row, GLint column )
{
GLint bytes_per_comp;
GLint comp_per_pixel;
GLint comps_per_row;
GLint pixels_per_row;
GLint bytes_per_image;
GLint rows_per_image;
GLint alignment;
GLint skiprows;
GLint skippixels;
GLint skipimages;
GLubyte *pixel_addr;
bytes_per_comp = gl_sizeof_type( type );
if (bytes_per_comp<0) {
return NULL;
}
comp_per_pixel = gl_components_in_format( format );
if (comp_per_pixel<0) {
return NULL;
}
alignment = packing->Alignment;
if (packing->RowLength>0) {
pixels_per_row = packing->RowLength;
}
else {
pixels_per_row = width;
}
if (packing->ImageHeight>0) {
rows_per_image = packing->ImageHeight;
}
else {
rows_per_image = height;
}
skiprows = packing->SkipRows;
skippixels = packing->SkipPixels;
skipimages = packing->SkipImages;
if (type==GL_BITMAP) {
GLint bytes_per_row;
bytes_per_row = alignment
* CEILING( comp_per_pixel*pixels_per_row, 8*alignment );
bytes_per_image = bytes_per_row * rows_per_image;
pixel_addr = (GLubyte *) image
+ (skipimages + img) * bytes_per_image
+ (skiprows + row) * bytes_per_row
+ (skippixels + column) / 8;
}
else {
if (bytes_per_comp>=alignment) {
	 comps_per_row = comp_per_pixel * pixels_per_row;
}
else {
GLint bytes_per_row = bytes_per_comp * comp_per_pixel
* pixels_per_row;
	 comps_per_row = alignment / bytes_per_comp
* CEILING( bytes_per_row, alignment );
}
bytes_per_image = bytes_per_comp * comps_per_row * rows_per_image;
pixel_addr = (GLubyte *) image
+ (skipimages + img) * bytes_per_image
+ (skiprows + row) * bytes_per_comp * comps_per_row
+ (skippixels + column) * bytes_per_comp * comp_per_pixel;
}
return (GLvoid *) pixel_addr;
}
struct gl_image *gl_unpack_image( GLcontext *ctx,
GLint width, GLint height,
GLenum srcFormat, GLenum srcType,
const GLvoid *pixels )
{
return gl_unpack_image3D( ctx, width, height, 1,
srcFormat, srcType, pixels );
}
struct gl_image *gl_unpack_image3D( GLcontext *ctx,
GLint width, GLint height, GLint depth,
GLenum srcFormat, GLenum srcType,
const GLvoid *pixels )
{
GLint components;
GLenum destType;
if (srcType==GL_UNSIGNED_BYTE) {
destType = GL_UNSIGNED_BYTE;
}
else if (srcType==GL_BITMAP) {
destType = GL_BITMAP;
}
else {
destType = GL_FLOAT;
}
components = gl_components_in_format( srcFormat );
if (components < 0)
return NULL;
if (srcType==GL_BITMAP || destType==GL_BITMAP) {
struct gl_image *image;
GLint bytes, i, width_in_bytes, d;
GLubyte *buffer, *dst;
assert( srcType==GL_BITMAP );
assert( destType==GL_BITMAP );
if (width > 0 && height > 0 && depth > 0)
bytes = ((width+7)/8 * height) * depth;
else
bytes = 0;
if (bytes>0 && pixels!=NULL) {
buffer = (GLubyte *) malloc( bytes );
if (!buffer) {
return NULL;
}
width_in_bytes = CEILING( width, 8 );
dst = buffer;
for (d=0; d<depth; d++) {
for (i=0; i<height; i++) {
GLvoid *src = gl_pixel_addr_in_image( &ctx->Unpack, pixels,
width, height,
GL_COLOR_INDEX, srcType,
d, i, 0 );
if (!src) {
free(buffer);
return NULL;
}
MEMCPY( dst, src, width_in_bytes );
dst += width_in_bytes;
}
}
if (ctx->Unpack.LsbFirst) {
gl_flip_bytes( buffer, bytes );
}
}
else {
buffer = NULL;
}
image = (struct gl_image *) malloc( sizeof(struct gl_image) );
if (image) {
image->Width = width;
image->Height = height;
image->Depth = depth;
image->Components = 0;
image->Format = GL_COLOR_INDEX;
image->Type = GL_BITMAP;
image->Data = buffer;
image->RefCount = 0;
}
else {
if (buffer)
free( buffer );
return NULL;
}
return image;
}
else if (srcFormat==GL_DEPTH_COMPONENT) {
}
else if (srcFormat==GL_STENCIL_INDEX) {
}
else if (destType==GL_UNSIGNED_BYTE) {
struct gl_image *image;
GLint width_in_bytes;
GLubyte *buffer, *dst;
GLint i, d;
assert( srcType==GL_UNSIGNED_BYTE );
width_in_bytes = width * components * sizeof(GLubyte);
buffer = (GLubyte *) malloc( height * width_in_bytes * depth );
if (!buffer) {
return NULL;
}
dst = buffer;
for (d=0; d<depth; d++ ) {
for (i=0;i<height;i++) {
GLubyte *src = (GLubyte *) gl_pixel_addr_in_image( &ctx->Unpack,
pixels, width, height, srcFormat, srcType, d, i, 0 );
if (!src) {
free(buffer);
return NULL;
}
MEMCPY( dst, src, width_in_bytes );
dst += width_in_bytes;
}
}
if (ctx->Unpack.LsbFirst) {
gl_flip_bytes( buffer, height * width_in_bytes * depth );
}
image = (struct gl_image *) malloc( sizeof(struct gl_image) );
if (image) {
image->Width = width;
image->Height = height;
image->Depth = depth;
image->Components = components;
image->Format = srcFormat;
image->Type = GL_UNSIGNED_BYTE;
image->Data = buffer;
image->RefCount = 0;
}
else {
free( buffer );
return NULL;
}
return image;
}
else if (destType==GL_FLOAT) {
struct gl_image *image;
float *buffer, *dst;
GLint elems_per_row;
GLint i, j, d;
GLboolean normalize;
elems_per_row = width * components;
buffer = (float *) malloc( height * elems_per_row * sizeof(float) * depth);
if (!buffer) {
return NULL;
}
normalize = (srcFormat != GL_COLOR_INDEX)
&& (srcFormat != GL_STENCIL_INDEX);
dst = buffer;
for (d=0; d<depth; d++) {
for (i=0;i<height;i++) {
GLvoid *src = gl_pixel_addr_in_image( &ctx->Unpack, pixels,
width, height,
srcFormat, srcType,
d, i, 0 );
if (!src) {
free(buffer);
return NULL;
}
switch (srcType) {
case GL_UNSIGNED_BYTE:
if (normalize) {
for (j=0;j<elems_per_row;j++) {
*dst++ = UBYTE_TO_FLOAT(((GLubyte*)src)[j]);
}
}
else {
for (j=0;j<elems_per_row;j++) {
*dst++ = (float) ((GLubyte*)src)[j];
}
}
break;
case GL_BYTE:
if (normalize) {
for (j=0;j<elems_per_row;j++) {
*dst++ = BYTE_TO_FLOAT(((GLbyte*)src)[j]);
}
}
else {
for (j=0;j<elems_per_row;j++) {
*dst++ = (float) ((GLbyte*)src)[j];
}
}
break;
case GL_UNSIGNED_SHORT:
if (ctx->Unpack.SwapBytes) {
for (j=0;j<elems_per_row;j++) {
GLushort value = ((GLushort*)src)[j];
value = ((value >> 8) & 0xff) | ((value&0xff) << 8);
if (normalize) {
*dst++ = USHORT_TO_FLOAT(value);
}
else {
*dst++ = (float) value;
}
}
}
else {
if (normalize) {
for (j=0;j<elems_per_row;j++) {
*dst++ = USHORT_TO_FLOAT(((GLushort*)src)[j]);
}
}
else {
for (j=0;j<elems_per_row;j++) {
*dst++ = (float) ((GLushort*)src)[j];
}
}
}
break;
case GL_SHORT:
if (ctx->Unpack.SwapBytes) {
for (j=0;j<elems_per_row;j++) {
GLshort value = ((GLshort*)src)[j];
value = ((value >> 8) & 0xff) | ((value&0xff) << 8);
if (normalize) {
*dst++ = SHORT_TO_FLOAT(value);
}
else {
*dst++ = (float) value;
}
}
}
else {
if (normalize) {
for (j=0;j<elems_per_row;j++) {
*dst++ = SHORT_TO_FLOAT(((GLshort*)src)[j]);
}
}
else {
for (j=0;j<elems_per_row;j++) {
*dst++ = (float) ((GLshort*)src)[j];
}
}
}
break;
case GL_UNSIGNED_INT:
if (ctx->Unpack.SwapBytes) {
GLuint value;
for (j=0;j<elems_per_row;j++) {
value = ((GLuint*)src)[j];
value = ((value & 0xff000000) >> 24)
| ((value & 0x00ff0000) >> 8)
| ((value & 0x0000ff00) << 8)
| ((value & 0x000000ff) << 24);
if (normalize) {
*dst++ = UINT_TO_FLOAT(value);
}
else {
*dst++ = (float) value;
}
}
}
else {
if (normalize) {
for (j=0;j<elems_per_row;j++) {
*dst++ = UINT_TO_FLOAT(((GLuint*)src)[j]);
}
}
else {
for (j=0;j<elems_per_row;j++) {
*dst++ = (float) ((GLuint*)src)[j];
}
}
}
break;
case GL_INT:
if (ctx->Unpack.SwapBytes) {
GLint value;
for (j=0;j<elems_per_row;j++) {
value = ((GLint*)src)[j];
value = ((value & 0xff000000) >> 24)
| ((value & 0x00ff0000) >> 8)
| ((value & 0x0000ff00) << 8)
| ((value & 0x000000ff) << 24);
if (normalize) {
*dst++ = INT_TO_FLOAT(value);
}
else {
*dst++ = (float) value;
}
}
}
else {
if (normalize) {
for (j=0;j<elems_per_row;j++) {
*dst++ = INT_TO_FLOAT(((GLint*)src)[j]);
}
}
else {
for (j=0;j<elems_per_row;j++) {
*dst++ = (float) ((GLint*)src)[j];
}
}
}
break;
case GL_FLOAT:
if (ctx->Unpack.SwapBytes) {
GLint value;
for (j=0;j<elems_per_row;j++) {
value = ((GLuint*)src)[j];
value = ((value & 0xff000000) >> 24)
| ((value & 0x00ff0000) >> 8)
| ((value & 0x0000ff00) << 8)
| ((value & 0x000000ff) << 24);
*dst++ = *((float*) &value);
}
}
else {
MEMCPY( dst, src, elems_per_row*sizeof(float) );
dst += elems_per_row;
}
break;
default:
gl_problem(ctx, "Bad type in gl_unpack_image3D");
return NULL;
}
}
}
image = (struct gl_image *) malloc( sizeof(struct gl_image) );
if (image) {
image->Width = width;
image->Height = height;
image->Depth = depth;
image->Components = components;
image->Format = srcFormat;
image->Type = GL_FLOAT;
image->Data = buffer;
image->RefCount = 0;
}
else {
free( buffer );
return NULL;
}
return image;
}
else {
gl_problem(ctx, "Bad dest type in gl_unpack_image3D");
return NULL;
}
return NULL;
}
void gl_free_image( struct gl_image *image )
{
if (image->Data) {
free(image->Data);
}
free(image);
}
/* 当前文件是D:\Read\light.c*/

#ifdef PC_HEADER
#else
#endif
void gl_ShadeModel( GLcontext *ctx, GLenum mode )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glShadeModel" );
return;
}
switch (mode) {
case GL_FLAT:
case GL_SMOOTH:
if (ctx->Light.ShadeModel!=mode) {
ctx->Light.ShadeModel = mode;
ctx->NewState |= NEW_RASTER_OPS;
}
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glShadeModel" );
}
}
void gl_Lightfv( GLcontext *ctx,
GLenum light, GLenum pname, const float *params,
GLint nparams )
{
GLint l;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glShadeModel" );
return;
}
l = (GLint) (light - GL_LIGHT0);
if (l<0 || l>=MAX_LIGHTS) {
gl_error( ctx, GL_INVALID_ENUM, "glLight" );
return;
}
switch (pname) {
case GL_AMBIENT:
COPY_4V( ctx->Light.Light[l].Ambient, params );
break;
case GL_DIFFUSE:
COPY_4V( ctx->Light.Light[l].Diffuse, params );
break;
case GL_SPECULAR:
COPY_4V( ctx->Light.Light[l].Specular, params );
break;
case GL_POSITION:
	
	 TRANSFORM_POINT( ctx->Light.Light[l].Position, ctx->ModelViewMatrix,
params );
break;
case GL_SPOT_DIRECTION:
	
{
float direction[4];
direction[0] = params[0];
direction[1] = params[1];
direction[2] = params[2];
direction[3] = 0.0;
if (ctx->NewModelViewMatrix) {
gl_analyze_modelview_matrix( ctx );
}
gl_transform_vector( ctx->Light.Light[l].Direction,
direction, ctx->ModelViewInv);
}
break;
case GL_SPOT_EXPONENT:
if (params[0]<0.0 || params[0]>128.0) {
gl_error( ctx, GL_INVALID_VALUE, "glLight" );
return;
}
if (ctx->Light.Light[l].SpotExponent != params[0]) {
ctx->Light.Light[l].SpotExponent = params[0];
gl_compute_spot_exp_table( &ctx->Light.Light[l] );
}
break;
case GL_SPOT_CUTOFF:
if ((params[0]<0.0 || params[0]>90.0) && params[0]!=180.0) {
gl_error( ctx, GL_INVALID_VALUE, "glLight" );
return;
}
ctx->Light.Light[l].SpotCutoff = params[0];
ctx->Light.Light[l].CosCutoff = cos(params[0]*DEG2RAD);
break;
case GL_CONSTANT_ATTENUATION:
if (params[0]<0.0) {
gl_error( ctx, GL_INVALID_VALUE, "glLight" );
return;
}
ctx->Light.Light[l].ConstantAttenuation = params[0];
break;
case GL_LINEAR_ATTENUATION:
if (params[0]<0.0) {
gl_error( ctx, GL_INVALID_VALUE, "glLight" );
return;
}
ctx->Light.Light[l].LinearAttenuation = params[0];
break;
case GL_QUADRATIC_ATTENUATION:
if (params[0]<0.0) {
gl_error( ctx, GL_INVALID_VALUE, "glLight" );
return;
}
ctx->Light.Light[l].QuadraticAttenuation = params[0];
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glLight" );
break;
}
ctx->NewState |= NEW_LIGHTING;
}
void gl_GetLightfv( GLcontext *ctx,
GLenum light, GLenum pname, float *params )
{
GLint l = (GLint) (light - GL_LIGHT0);
if (l<0 || l>=MAX_LIGHTS) {
gl_error( ctx, GL_INVALID_ENUM, "glGetLightfv" );
return;
}
switch (pname) {
case GL_AMBIENT:
COPY_4V( params, ctx->Light.Light[l].Ambient );
break;
case GL_DIFFUSE:
COPY_4V( params, ctx->Light.Light[l].Diffuse );
break;
case GL_SPECULAR:
COPY_4V( params, ctx->Light.Light[l].Specular );
break;
case GL_POSITION:
COPY_4V( params, ctx->Light.Light[l].Position );
break;
case GL_SPOT_DIRECTION:
COPY_3V( params, ctx->Light.Light[l].Direction );
break;
case GL_SPOT_EXPONENT:
params[0] = ctx->Light.Light[l].SpotExponent;
break;
case GL_SPOT_CUTOFF:
params[0] = ctx->Light.Light[l].SpotCutoff;
break;
case GL_CONSTANT_ATTENUATION:
params[0] = ctx->Light.Light[l].ConstantAttenuation;
break;
case GL_LINEAR_ATTENUATION:
params[0] = ctx->Light.Light[l].LinearAttenuation;
break;
case GL_QUADRATIC_ATTENUATION:
params[0] = ctx->Light.Light[l].QuadraticAttenuation;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetLightfv" );
break;
}
}
void gl_GetLightiv( GLcontext *ctx, GLenum light, GLenum pname, GLint *params )
{
GLint l = (GLint) (light - GL_LIGHT0);
if (l<0 || l>=MAX_LIGHTS) {
gl_error( ctx, GL_INVALID_ENUM, "glGetLightiv" );
return;
}
switch (pname) {
case GL_AMBIENT:
params[0] = FLOAT_TO_INT(ctx->Light.Light[l].Ambient[0]);
params[1] = FLOAT_TO_INT(ctx->Light.Light[l].Ambient[1]);
params[2] = FLOAT_TO_INT(ctx->Light.Light[l].Ambient[2]);
params[3] = FLOAT_TO_INT(ctx->Light.Light[l].Ambient[3]);
break;
case GL_DIFFUSE:
params[0] = FLOAT_TO_INT(ctx->Light.Light[l].Diffuse[0]);
params[1] = FLOAT_TO_INT(ctx->Light.Light[l].Diffuse[1]);
params[2] = FLOAT_TO_INT(ctx->Light.Light[l].Diffuse[2]);
params[3] = FLOAT_TO_INT(ctx->Light.Light[l].Diffuse[3]);
break;
case GL_SPECULAR:
params[0] = FLOAT_TO_INT(ctx->Light.Light[l].Specular[0]);
params[1] = FLOAT_TO_INT(ctx->Light.Light[l].Specular[1]);
params[2] = FLOAT_TO_INT(ctx->Light.Light[l].Specular[2]);
params[3] = FLOAT_TO_INT(ctx->Light.Light[l].Specular[3]);
break;
case GL_POSITION:
params[0] = ctx->Light.Light[l].Position[0];
params[1] = ctx->Light.Light[l].Position[1];
params[2] = ctx->Light.Light[l].Position[2];
params[3] = ctx->Light.Light[l].Position[3];
break;
case GL_SPOT_DIRECTION:
params[0] = ctx->Light.Light[l].Direction[0];
params[1] = ctx->Light.Light[l].Direction[1];
params[2] = ctx->Light.Light[l].Direction[2];
break;
case GL_SPOT_EXPONENT:
params[0] = ctx->Light.Light[l].SpotExponent;
break;
case GL_SPOT_CUTOFF:
params[0] = ctx->Light.Light[l].SpotCutoff;
break;
case GL_CONSTANT_ATTENUATION:
params[0] = ctx->Light.Light[l].ConstantAttenuation;
break;
case GL_LINEAR_ATTENUATION:
params[0] = ctx->Light.Light[l].LinearAttenuation;
break;
case GL_QUADRATIC_ATTENUATION:
params[0] = ctx->Light.Light[l].QuadraticAttenuation;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetLightiv" );
break;
}
}
void gl_LightModelfv( GLcontext *ctx, GLenum pname, const float *params )
{
switch (pname) {
case GL_LIGHT_MODEL_AMBIENT:
COPY_4V( ctx->Light.Model.Ambient, params );
break;
case GL_LIGHT_MODEL_LOCAL_VIEWER:
if (params[0]==0.0)
ctx->Light.Model.LocalViewer = GL_FALSE;
else
ctx->Light.Model.LocalViewer = GL_TRUE;
break;
case GL_LIGHT_MODEL_TWO_SIDE:
if (params[0]==0.0)
ctx->Light.Model.TwoSide = GL_FALSE;
else
ctx->Light.Model.TwoSide = GL_TRUE;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glLightModel" );
break;
}
ctx->NewState |= NEW_LIGHTING;
}
GLuint gl_material_bitmask( GLenum face, GLenum pname )
{
GLuint bitmask = 0;
switch (pname) {
case GL_EMISSION:
bitmask |= FRONT_EMISSION_BIT | BACK_EMISSION_BIT;
break;
case GL_AMBIENT:
bitmask |= FRONT_AMBIENT_BIT | BACK_AMBIENT_BIT;
break;
case GL_DIFFUSE:
bitmask |= FRONT_DIFFUSE_BIT | BACK_DIFFUSE_BIT;
break;
case GL_SPECULAR:
bitmask |= FRONT_SPECULAR_BIT | BACK_SPECULAR_BIT;
break;
case GL_SHININESS:
bitmask |= FRONT_SHININESS_BIT | BACK_SHININESS_BIT;
break;
case GL_AMBIENT_AND_DIFFUSE:
bitmask |= FRONT_AMBIENT_BIT | BACK_AMBIENT_BIT;
bitmask |= FRONT_DIFFUSE_BIT | BACK_DIFFUSE_BIT;
break;
case GL_COLOR_INDEXES:
bitmask |= FRONT_INDEXES_BIT  | BACK_INDEXES_BIT;
break;
default:
gl_problem(NULL, "Bad param in gl_material_bitmask");
return 0;
}
ASSERT( face==GL_FRONT || face==GL_BACK || face==GL_FRONT_AND_BACK );
if (face==GL_FRONT) {
bitmask &= FRONT_MATERIAL_BITS;
}
else if (face==GL_BACK) {
bitmask &= BACK_MATERIAL_BITS;
}
return bitmask;
}
void gl_set_material( GLcontext *ctx, GLuint bitmask, const float *params )
{
struct gl_material *mat;
if (INSIDE_BEGIN_END(ctx)) {
struct vertex_buffer *VB = ctx->VB;
mat = VB->Material[VB->Count];
VB->MaterialMask[VB->Count] |= bitmask;
VB->MonoMaterial = GL_FALSE;
}
else {
mat = ctx->Light.Material;
ctx->NewState |= NEW_LIGHTING;
}
if (bitmask & FRONT_AMBIENT_BIT) {
COPY_4V( mat[0].Ambient, params );
}
if (bitmask & BACK_AMBIENT_BIT) {
COPY_4V( mat[1].Ambient, params );
}
if (bitmask & FRONT_DIFFUSE_BIT) {
COPY_4V( mat[0].Diffuse, params );
}
if (bitmask & BACK_DIFFUSE_BIT) {
COPY_4V( mat[1].Diffuse, params );
}
if (bitmask & FRONT_SPECULAR_BIT) {
COPY_4V( mat[0].Specular, params );
}
if (bitmask & BACK_SPECULAR_BIT) {
COPY_4V( mat[1].Specular, params );
}
if (bitmask & FRONT_EMISSION_BIT) {
COPY_4V( mat[0].Emission, params );
}
if (bitmask & BACK_EMISSION_BIT) {
COPY_4V( mat[1].Emission, params );
}
if (bitmask & FRONT_SHININESS_BIT) {
float shininess = CLAMP( params[0], 0.0F, 128.0F );
if (mat[0].Shininess != shininess) {
mat[0].Shininess = shininess;
gl_compute_material_shine_table( &mat[0] );
}
}
if (bitmask & BACK_SHININESS_BIT) {
float shininess = CLAMP( params[0], 0.0F, 128.0F );
if (mat[1].Shininess != shininess) {
mat[1].Shininess = shininess;
gl_compute_material_shine_table( &mat[1] );
}
}
if (bitmask & FRONT_INDEXES_BIT) {
mat[0].AmbientIndex = params[0];
mat[0].DiffuseIndex = params[1];
mat[0].SpecularIndex = params[2];
}
if (bitmask & BACK_INDEXES_BIT) {
mat[1].AmbientIndex = params[0];
mat[1].DiffuseIndex = params[1];
mat[1].SpecularIndex = params[2];
}
}
void gl_ColorMaterial( GLcontext *ctx, GLenum face, GLenum mode )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glColorMaterial" );
return;
}
switch (face) {
case GL_FRONT:
case GL_BACK:
case GL_FRONT_AND_BACK:
ctx->Light.ColorMaterialFace = face;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glColorMaterial(face)" );
return;
}
switch (mode) {
case GL_EMISSION:
case GL_AMBIENT:
case GL_DIFFUSE:
case GL_SPECULAR:
case GL_AMBIENT_AND_DIFFUSE:
ctx->Light.ColorMaterialMode = mode;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glColorMaterial(mode)" );
return;
}
ctx->Light.ColorMaterialBitmask = gl_material_bitmask( face, mode );
}
void gl_Materialfv( GLcontext *ctx,
GLenum face, GLenum pname, const float *params )
{
GLuint bitmask;
if (face!=GL_FRONT && face!=GL_BACK && face!=GL_FRONT_AND_BACK) {
gl_error( ctx, GL_INVALID_ENUM, "glMaterial(face)" );
return;
}
switch (pname) {
case GL_EMISSION:
case GL_AMBIENT:
case GL_DIFFUSE:
case GL_SPECULAR:
case GL_SHININESS:
case GL_AMBIENT_AND_DIFFUSE:
case GL_COLOR_INDEXES:
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glMaterial(pname)" );
return;
}
bitmask = gl_material_bitmask( face, pname );
if (ctx->Light.ColorMaterialEnabled) {
bitmask &= ~ctx->Light.ColorMaterialBitmask;
}
gl_set_material( ctx, bitmask, params );
}
void gl_GetMaterialfv( GLcontext *ctx,
GLenum face, GLenum pname, float *params )
{
GLuint f;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetMaterialfv" );
return;
}
if (face==GL_FRONT) {
f = 0;
}
else if (face==GL_BACK) {
f = 1;
}
else {
gl_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(face)" );
return;
}
switch (pname) {
case GL_AMBIENT:
COPY_4V( params, ctx->Light.Material[f].Ambient );
break;
case GL_DIFFUSE:
COPY_4V( params, ctx->Light.Material[f].Diffuse );
	 break;
case GL_SPECULAR:
COPY_4V( params, ctx->Light.Material[f].Specular );
	 break;
case GL_EMISSION:
	 COPY_4V( params, ctx->Light.Material[f].Emission );
	 break;
case GL_SHININESS:
	 *params = ctx->Light.Material[f].Shininess;
	 break;
case GL_COLOR_INDEXES:
	 params[0] = ctx->Light.Material[f].AmbientIndex;
	 params[1] = ctx->Light.Material[f].DiffuseIndex;
	 params[2] = ctx->Light.Material[f].SpecularIndex;
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(pname)" );
}
}
void gl_GetMaterialiv( GLcontext *ctx,
GLenum face, GLenum pname, GLint *params )
{
GLuint f;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetMaterialiv" );
return;
}
if (face==GL_FRONT) {
f = 0;
}
else if (face==GL_BACK) {
f = 1;
}
else {
gl_error( ctx, GL_INVALID_ENUM, "glGetMaterialiv(face)" );
return;
}
switch (pname) {
case GL_AMBIENT:
params[0] = FLOAT_TO_INT( ctx->Light.Material[f].Ambient[0] );
params[1] = FLOAT_TO_INT( ctx->Light.Material[f].Ambient[1] );
params[2] = FLOAT_TO_INT( ctx->Light.Material[f].Ambient[2] );
params[3] = FLOAT_TO_INT( ctx->Light.Material[f].Ambient[3] );
break;
case GL_DIFFUSE:
params[0] = FLOAT_TO_INT( ctx->Light.Material[f].Diffuse[0] );
params[1] = FLOAT_TO_INT( ctx->Light.Material[f].Diffuse[1] );
params[2] = FLOAT_TO_INT( ctx->Light.Material[f].Diffuse[2] );
params[3] = FLOAT_TO_INT( ctx->Light.Material[f].Diffuse[3] );
	 break;
case GL_SPECULAR:
params[0] = FLOAT_TO_INT( ctx->Light.Material[f].Specular[0] );
params[1] = FLOAT_TO_INT( ctx->Light.Material[f].Specular[1] );
params[2] = FLOAT_TO_INT( ctx->Light.Material[f].Specular[2] );
params[3] = FLOAT_TO_INT( ctx->Light.Material[f].Specular[3] );
	 break;
case GL_EMISSION:
params[0] = FLOAT_TO_INT( ctx->Light.Material[f].Emission[0] );
params[1] = FLOAT_TO_INT( ctx->Light.Material[f].Emission[1] );
params[2] = FLOAT_TO_INT( ctx->Light.Material[f].Emission[2] );
params[3] = FLOAT_TO_INT( ctx->Light.Material[f].Emission[3] );
	 break;
case GL_SHININESS:
*params = ROUNDF( ctx->Light.Material[f].Shininess );
	 break;
case GL_COLOR_INDEXES:
	 params[0] = ROUNDF( ctx->Light.Material[f].AmbientIndex );
	 params[1] = ROUNDF( ctx->Light.Material[f].DiffuseIndex );
	 params[2] = ROUNDF( ctx->Light.Material[f].SpecularIndex );
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(pname)" );
}
}
#define FLT_MIN 1.175494e-38
void gl_compute_spot_exp_table( struct gl_light *l )
{
int i;
double exponent = l->SpotExponent;
double tmp;
int clamp = 0;
l->SpotExpTable[0][0] = 0.0;
for (i=EXP_TABLE_SIZE-1;i>0;i--) {
if (clamp == 0) {
tmp = pow(i/(double)(EXP_TABLE_SIZE-1), exponent);
if (tmp < FLT_MIN*100.0) {//
tmp = 0.0;
clamp = 1;
}
}
l->SpotExpTable[i][0] = tmp;
}
for (i=0;i<EXP_TABLE_SIZE-1;i++) {
l->SpotExpTable[i][1] = l->SpotExpTable[i+1][0] - l->SpotExpTable[i][0];
}
l->SpotExpTable[EXP_TABLE_SIZE-1][1] = 0.0;
}
void gl_compute_material_shine_table( struct gl_material *m )
{
int i;
double exponent = m->Shininess;
m->ShineTable[0] = 0.0F;
for (i=1;i<SHINE_TABLE_SIZE;i++) {
#if 0
double x = pow( i/(double)(SHINE_TABLE_SIZE-1), exponent );
if (x<1.0e-10) {
m->ShineTable[i] = 0.0F;
}
else {
m->ShineTable[i] = x;
}
#else
m->ShineTable[i] = -1.0;
#endif
}
}
void gl_update_lighting( GLcontext *ctx )
{
GLint i, side;
struct gl_light *prev_enabled, *light;
if (!ctx->Light.Enabled) {
return;
}
prev_enabled = NULL;
ctx->Light.FirstEnabled = NULL;
for (i=0;i<MAX_LIGHTS;i++) {
ctx->Light.Light[i].NextEnabled = NULL;
if (ctx->Light.Light[i].Enabled) {
if (prev_enabled) {
prev_enabled->NextEnabled = &ctx->Light.Light[i];
}
else {
ctx->Light.FirstEnabled = &ctx->Light.Light[i];
}
prev_enabled = &ctx->Light.Light[i];
}
}
for (side=0; side<2; side++) {
ctx->Light.BaseColor[side][0] = ctx->Light.Material[side].Emission[0]
+ ctx->Light.Model.Ambient[0] * ctx->Light.Material[side].Ambient[0];
ctx->Light.BaseColor[side][1] = ctx->Light.Material[side].Emission[1]
+ ctx->Light.Model.Ambient[1] * ctx->Light.Material[side].Ambient[1];
ctx->Light.BaseColor[side][2] = ctx->Light.Material[side].Emission[2]
+ ctx->Light.Model.Ambient[2] * ctx->Light.Material[side].Ambient[2];
ctx->Light.BaseColor[side][3]
= MIN2( ctx->Light.Material[side].Diffuse[3], 1.0F );
}
for (light = ctx->Light.FirstEnabled; light; light = light->NextEnabled) {
for (side=0; side<2; side++) {
struct gl_material *mat = &ctx->Light.Material[side];
ctx->Light.BaseColor[side][0] += light->Ambient[0] * mat->Ambient[0];
ctx->Light.BaseColor[side][1] += light->Ambient[1] * mat->Ambient[1];
ctx->Light.BaseColor[side][2] += light->Ambient[2] * mat->Ambient[2];
light->MatAmbient[side][0] = light->Ambient[0] * mat->Ambient[0];
light->MatAmbient[side][1] = light->Ambient[1] * mat->Ambient[1];
light->MatAmbient[side][2] = light->Ambient[2] * mat->Ambient[2];
light->MatDiffuse[side][0] = light->Diffuse[0] * mat->Diffuse[0];
light->MatDiffuse[side][1] = light->Diffuse[1] * mat->Diffuse[1];
light->MatDiffuse[side][2] = light->Diffuse[2] * mat->Diffuse[2];
light->MatSpecular[side][0] = light->Specular[0] * mat->Specular[0];
light->MatSpecular[side][1] = light->Specular[1] * mat->Specular[1];
light->MatSpecular[side][2] = light->Specular[2] * mat->Specular[2];
COPY_3V( light->VP_inf_norm, light->Position );
NORMALIZE_3FV( light->VP_inf_norm );
COPY_3V( light->h_inf_norm, light->VP_inf_norm );
light->h_inf_norm[2] += 1.0F;
NORMALIZE_3FV( light->h_inf_norm );
COPY_3V( light->NormDirection, light->Direction );
NORMALIZE_3FV( light->NormDirection );
light->dli = 0.30F * light->Diffuse[0]
+ 0.59F * light->Diffuse[1]
+ 0.11F * light->Diffuse[2];
light->sli = 0.30F * light->Specular[0]
+ 0.59F * light->Specular[1]
+ 0.11F * light->Specular[2];
}
}
ctx->Light.Fast = GL_TRUE;
if (    ctx->Light.BaseColor[0][0]<0.0F
|| ctx->Light.BaseColor[0][1]<0.0F
|| ctx->Light.BaseColor[0][2]<0.0F
|| ctx->Light.BaseColor[0][3]<0.0F
|| ctx->Light.BaseColor[1][0]<0.0F
|| ctx->Light.BaseColor[1][1]<0.0F
|| ctx->Light.BaseColor[1][2]<0.0F
|| ctx->Light.BaseColor[1][3]<0.0F
|| ctx->Light.Model.LocalViewer
|| ctx->Light.ColorMaterialEnabled) {
ctx->Light.Fast = GL_FALSE;
}
else {
for (light=ctx->Light.FirstEnabled; light; light=light->NextEnabled) {
if (   light->Position[3]!=0.0F
|| light->SpotCutoff!=180.0F
|| light->MatDiffuse[0][0]<0.0F
|| light->MatDiffuse[0][1]<0.0F
|| light->MatDiffuse[0][2]<0.0F
|| light->MatSpecular[0][0]<0.0F
|| light->MatSpecular[0][1]<0.0F
|| light->MatSpecular[0][2]<0.0F
|| light->MatDiffuse[1][0]<0.0F
|| light->MatDiffuse[1][1]<0.0F
|| light->MatDiffuse[1][2]<0.0F
|| light->MatSpecular[1][0]<0.0F
|| light->MatSpecular[1][1]<0.0F
|| light->MatSpecular[1][2]<0.0F) {
ctx->Light.Fast = GL_FALSE;
break;
}
}
}
}
/* 当前文件是D:\Read\lines.c*/

#ifdef PC_HEADER
#else
#endif
void gl_LineWidth( GLcontext *ctx, float width )
{
if (width<=0.0) {
gl_error( ctx, GL_INVALID_VALUE, "glLineWidth" );
return;
}
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glLineWidth" );
return;
}
ctx->Line.Width = width;
ctx->NewState |= NEW_RASTER_OPS;
}
void gl_LineStipple( GLcontext *ctx, GLint factor, GLushort pattern )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glLineStipple" );
return;
}
ctx->Line.StippleFactor = CLAMP( factor, 1, 256 );
ctx->Line.StipplePattern = pattern;
ctx->NewState |= NEW_RASTER_OPS;
}
static void feedback_line( GLcontext *ctx, GLuint v1, GLuint v2, GLuint pv )
{
struct vertex_buffer *VB = ctx->VB;
float x1, y1, z1, w1;
float x2, y2, z2, w2;
float tex1[4], tex2[4], invq;
float invRedScale   = ctx->Visual->InvRedScale;
float invGreenScale = ctx->Visual->InvGreenScale;
float invBlueScale  = ctx->Visual->InvBlueScale;
float invAlphaScale = ctx->Visual->InvAlphaScale;
x1 = VB->Win[v1][0];
y1 = VB->Win[v1][1];
z1 = VB->Win[v1][2] / DEPTH_SCALE;
w1 = VB->Clip[v1][3];
x2 = VB->Win[v2][0];
y2 = VB->Win[v2][1];
z2 = VB->Win[v2][2] / DEPTH_SCALE;
w2 = VB->Clip[v2][3];
invq = (VB->TexCoord[v1][3]==0.0) ? 1.0 : (1.0F / VB->TexCoord[v1][3]);
tex1[0] = VB->TexCoord[v1][0] * invq;
tex1[1] = VB->TexCoord[v1][1] * invq;
tex1[2] = VB->TexCoord[v1][2] * invq;
tex1[3] = VB->TexCoord[v1][3];
invq = (VB->TexCoord[v2][3]==0.0) ? 1.0 : (1.0F / VB->TexCoord[v2][3]);
tex2[0] = VB->TexCoord[v2][0] * invq;
tex2[1] = VB->TexCoord[v2][1] * invq;
tex2[2] = VB->TexCoord[v2][2] * invq;
tex2[3] = VB->TexCoord[v2][3];
if (ctx->StippleCounter==0) {
FEEDBACK_TOKEN( ctx, (float) GL_LINE_RESET_TOKEN );
}
else {
FEEDBACK_TOKEN( ctx, (float) GL_LINE_TOKEN );
}
{
float color[4];
color[0] = (float) VB->Color[pv][0] * invRedScale;
color[1] = (float) VB->Color[pv][1] * invGreenScale;
color[2] = (float) VB->Color[pv][2] * invBlueScale;
color[3] = (float) VB->Color[pv][3] * invAlphaScale;
gl_feedback_vertex( ctx, x1,y1,z1,w1, color,
(float) VB->Index[pv], tex1 );
gl_feedback_vertex( ctx, x2,y2,z2,w2, color,
(float) VB->Index[pv], tex2 );
}
ctx->StippleCounter++;
}
static void select_line( GLcontext *ctx, GLuint v1, GLuint v2, GLuint pv )
{
gl_update_hitflag( ctx, ctx->VB->Win[v1][2] / DEPTH_SCALE );
gl_update_hitflag( ctx, ctx->VB->Win[v2][2] / DEPTH_SCALE );
}
#if MAX_WIDTH > MAX_HEIGHT
#  define MAXPOINTS MAX_WIDTH
#else
#  define MAXPOINTS MAX_HEIGHT
#endif
static void flat_ci_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
GLint count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
PB_SET_INDEX( ctx, ctx->PB, ctx->VB->Index[pvert] );
count = ctx->PB->count;
#define INTERP_XY 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	count++;
/* 当前文件是D:\Read\linetemp.h*/

{
struct vertex_buffer *VB = ctx->VB;
GLint x0 = (GLint) VB->Win[vert0][0], x1 = (GLint) VB->Win[vert1][0];
GLint y0 = (GLint) VB->Win[vert0][1], y1 = (GLint) VB->Win[vert1][1];
GLint dx, dy;
#if INTERP_XY
GLint xstep, ystep;
#endif
#if INTERP_Z
GLint z0, z1, dz, zPtrXstep, zPtrYstep;
GLdepth *zPtr;
#endif
#if INTERP_RGB
int r0 = IntToFixed(VB->Color[vert0][0]);
int dr = IntToFixed(VB->Color[vert1][0]) - r0;
int g0 = IntToFixed(VB->Color[vert0][1]);
int dg = IntToFixed(VB->Color[vert1][1]) - g0;
int b0 = IntToFixed(VB->Color[vert0][2]);
int db = IntToFixed(VB->Color[vert1][2]) - b0;
#endif
#if INTERP_ALPHA
int a0 = IntToFixed(VB->Color[vert0][3]);
int da = IntToFixed(VB->Color[vert1][3]) - a0;
#endif
#if INTERP_INDEX
GLint i0 = VB->Index[vert0] << 8,  di = (GLint) (VB->Index[vert1] << 8)-i0;
#endif
#if INTERP_ST
int s0 = FloatToFixed(VB->TexCoord[vert0][0] * S_SCALE);
int ds = FloatToFixed(VB->TexCoord[vert1][0] * S_SCALE) - s0;
int t0 = FloatToFixed(VB->TexCoord[vert0][1] * T_SCALE);
int dt = FloatToFixed(VB->TexCoord[vert1][1] * T_SCALE) - t0;
#endif
#if INTERP_STW
float s0 = VB->TexCoord[vert0][0], ds = VB->TexCoord[vert1][0] - s0;
float t0 = VB->TexCoord[vert0][1], dt = VB->TexCoord[vert1][1] - t0;
float w0 = 1.0F / VB->Clip[vert0][3], dw = 1.0F / VB->Clip[vert1][3] - w0;
#endif
#if INTERP_UV
float u0 = VB->TexCoord[vert0][2], du = VB->TexCoord[vert1][2] - u0;
float v0 = VB->TexCoord[vert0][3], dv = VB->TexCoord[vert1][3] - v0;
#endif
#ifdef PIXEL_ADDRESS
PIXEL_TYPE *pixelPtr;
GLint pixelXstep, pixelYstep;
#endif
#if WIDE
GLint width, min, max;
width = (GLint) CLAMP( ctx->Line.Width, MIN_LINE_WIDTH, MAX_LINE_WIDTH );
min = -width / 2;
max = min + width - 1;
#endif
#if CLIP_HACK
{
GLint w = ctx->Buffer->Width;
GLint h = ctx->Buffer->Height;
if ((x0==w) | (x1==w)) {
if ((x0==w) & (x1==w))
return;
x0 -= x0==w;
x1 -= x1==w;
}
if ((y0==h) | (y1==h)) {
if ((y0==h) & (y1==h))
return;
y0 -= y0==h;
y1 -= y1==h;
}
}
#endif
dx = x1 - x0;
dy = y1 - y0;
if (dx==0 && dy==0) {
return;
}
#ifdef SETUP_CODE
SETUP_CODE
#endif
#if INTERP_Z
zPtr = Z_ADDRESS(ctx,x0,y0);
#  if DEPTH_BITS==16
z0 = FloatToFixed(VB->Win[vert0][2]);
z1 = FloatToFixed(VB->Win[vert1][2]);
#  else
z0 = (int) VB->Win[vert0][2];
z1 = (int) VB->Win[vert1][2];
#  endif
#endif
#ifdef PIXEL_ADDRESS
pixelPtr = (PIXEL_TYPE *) PIXEL_ADDRESS(x0,y0);
#endif
if (dx<0) {
dx = -dx;
#if INTERP_XY
xstep = -1;
#endif
#ifdef INTERP_Z
zPtrXstep = -sizeof(GLdepth);
#endif
#ifdef PIXEL_ADDRESS
pixelXstep = -sizeof(PIXEL_TYPE);
#endif
}
else {
#if INTERP_XY
xstep = 1;
#endif
#if INTERP_Z
zPtrXstep = sizeof(GLdepth);
#endif
#ifdef PIXEL_ADDRESS
pixelXstep = sizeof(PIXEL_TYPE);
#endif
}
if (dy<0) {
dy = -dy;
#if INTERP_XY
ystep = -1;
#endif
#if INTERP_Z
zPtrYstep = -ctx->Buffer->Width * sizeof(GLdepth);
#endif
#ifdef PIXEL_ADDRESS
pixelYstep = BYTES_PER_ROW;
#endif
}
else {
#if INTERP_XY
ystep = 1;
#endif
#if INTERP_Z
zPtrYstep = ctx->Buffer->Width * sizeof(GLdepth);
#endif
#ifdef PIXEL_ADDRESS
pixelYstep = -(BYTES_PER_ROW);
#endif
}
if (dx>dy) {
GLint i;
GLint errorInc = dy+dy;
GLint error = errorInc-dx;
GLint errorDec = error-dx;
#if INTERP_Z
dz = (z1-z0) / dx;
#endif
#if INTERP_RGB
dr /= dx;
dg /= dx;
db /= dx;
#endif
#if INTERP_ALPHA
da /= dx;
#endif
#if INTERP_INDEX
di /= dx;
#endif
#if INTERP_ST
ds /= dx;
dt /= dx;
#endif
#if INTERP_STW
{
float fdxinv = 1.0F / (float) dx;
ds *= fdxinv;
dt *= fdxinv;
dw *= fdxinv;
#if INTERP_UV
du *= fdxinv;
dv *= fdxinv;
#endif
}
#endif
for (i=0;i<dx;i++) {
#if STIPPLE
GLushort m;
m = 1 << ((ctx->StippleCounter/ctx->Line.StippleFactor) & 0xf);
if (ctx->Line.StipplePattern & m) {
#endif
#if INTERP_Z
#  if DEPTH_BITS==16
GLdepth Z = FixedToInt(z0);
#  else
GLdepth Z = z0;
#  endif
#endif
#if INTERP_INDEX
GLint I = i0 >> 8;
#endif
#if WIDE
GLint yy;
GLint ymin = y0 + min;
GLint ymax = y0 + max;
for (yy=ymin;yy<=ymax;yy++) {
PLOT( x0, yy );
}
#else
#  ifdef XMAJOR_PLOT
XMAJOR_PLOT( x0, y0 );
#  else
PLOT( x0, y0 );
#  endif
#endif
#if STIPPLE
}
	ctx->StippleCounter++;
#endif
#if INTERP_XY
x0 += xstep;
#endif
#if INTERP_Z
zPtr = (GLdepth *) ((GLubyte*) zPtr + zPtrXstep);
z0 += dz;
#endif
#if INTERP_RGB
r0 += dr;
g0 += dg;
b0 += db;
#endif
#if INTERP_ALPHA
a0 += da;
#endif
#if INTERP_INDEX
i0 += di;
#endif
#if INTERP_ST
s0 += ds;
t0 += dt;
#endif
#if INTERP_STW
s0 += ds;
t0 += dt;
w0 += dw;
#endif
#if INTERP_UV
u0 += du;
v0 += dv;
#endif
#ifdef PIXEL_ADDRESS
pixelPtr = (PIXEL_TYPE*) ((GLubyte*) pixelPtr + pixelXstep);
#endif
if (error<0) {
error += errorInc;
}
else {
error += errorDec;
#if INTERP_XY
y0 += ystep;
#endif
#if INTERP_Z
zPtr = (GLdepth *) ((GLubyte*) zPtr + zPtrYstep);
#endif
#ifdef PIXEL_ADDRESS
pixelPtr = (PIXEL_TYPE*) ((GLubyte*) pixelPtr + pixelYstep);
#endif
}
}
}
else {
GLint i;
GLint errorInc = dx+dx;
GLint error = errorInc-dy;
GLint errorDec = error-dy;
#if INTERP_Z
dz = (z1-z0) / dy;
#endif
#if INTERP_RGB
dr /= dy;
dg /= dy;
db /= dy;
#endif
#if INTERP_ALPHA
da /= dy;
#endif
#if INTERP_INDEX
di /= dy;
#endif
#if INTERP_ST
ds /= dy;
dt /= dy;
#endif
#if INTERP_STW
{
float fdyinv = 1.0F / (float) dy;
ds *= fdyinv;
dt *= fdyinv;
dw *= fdyinv;
#if INTERP_UV
du *= fdyinv;
dv *= fdyinv;
#endif
}
#endif
for (i=0;i<dy;i++) {
#if STIPPLE
GLushort m;
m = 1 << ((ctx->StippleCounter/ctx->Line.StippleFactor) & 0xf);
if (ctx->Line.StipplePattern & m) {
#endif
#if INTERP_Z
#  if DEPTH_BITS==16
GLdepth Z = FixedToInt(z0);
#  else
GLdepth Z = z0;
#  endif
#endif
#if INTERP_INDEX
GLint I = i0 >> 8;
#endif
#if WIDE
GLint xx;
GLint xmin = x0 + min;
GLint xmax = x0 + max;
for (xx=xmin;xx<=xmax;xx++) {
PLOT( xx, y0 );
}
#else
#  ifdef YMAJOR_PLOT
YMAJOR_PLOT( x0, y0 );
#  else
PLOT( x0, y0 );
#  endif
#endif
#if STIPPLE
}
	ctx->StippleCounter++;
#endif
#if INTERP_XY
y0 += ystep;
#endif
#if INTERP_Z
zPtr = (GLdepth *) ((GLubyte*) zPtr + zPtrYstep);
z0 += dz;
#endif
#if INTERP_RGB
r0 += dr;
g0 += dg;
b0 += db;
#endif
#if INTERP_ALPHA
a0 += da;
#endif
#if INTERP_INDEX
i0 += di;
#endif
#if INTERP_ST
s0 += ds;
t0 += dt;
#endif
#if INTERP_STW
s0 += ds;
t0 += dt;
w0 += dw;
#endif
#if INTERP_UV
u0 += du;
v0 += dv;
#endif
#ifdef PIXEL_ADDRESS
pixelPtr = (PIXEL_TYPE*) ((GLubyte*) pixelPtr + pixelYstep);
#endif
if (error<0) {
error += errorInc;
}
else {
error += errorDec;
#if INTERP_XY
x0 += xstep;
#endif
#if INTERP_Z
zPtr = (GLdepth *) ((GLubyte*) zPtr + zPtrXstep);
#endif
#ifdef PIXEL_ADDRESS
pixelPtr = (PIXEL_TYPE*) ((GLubyte*) pixelPtr + pixelXstep);
#endif
}
}
}
}
#undef INTERP_XY
#undef INTERP_Z
#undef INTERP_RGB
#undef INTERP_ALPHA
#undef INTERP_INDEX
#undef PIXEL_ADDRESS
#undef PIXEL_TYPE
#undef BYTES_PER_ROW
#undef SETUP_CODE
#undef PLOT
#undef XMAJOR_PLOT
#undef YMAJOR_PLOT
#undef CLIP_HACK
#undef STIPPLE
#undef WIDE
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void flat_ci_z_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
GLint count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLdepth *pbz = ctx->PB->z;
PB_SET_INDEX( ctx, ctx->PB, ctx->VB->Index[pvert] );
count = ctx->PB->count;
#define INTERP_XY 1
#define INTERP_Z 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbz[count] = Z;		\
	count++;
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void flat_rgba_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
GLint count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLubyte *color = ctx->VB->Color[pvert];
PB_SET_COLOR( ctx, ctx->PB, color[0], color[1], color[2], color[3] );
count = ctx->PB->count;
#define INTERP_XY 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	count++;
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void flat_rgba_z_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
GLint count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLdepth *pbz = ctx->PB->z;
GLubyte *color = ctx->VB->Color[pvert];
PB_SET_COLOR( ctx, ctx->PB, color[0], color[1], color[2], color[3] );
count = ctx->PB->count;
#define INTERP_XY 1
#define INTERP_Z 1
#define PLOT(X,Y)	\
	pbx[count] = X;	\
	pby[count] = Y;	\
	pbz[count] = Z;	\
	count++;
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void smooth_ci_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
GLint count = ctx->PB->count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLuint *pbi = ctx->PB->i;
#define INTERP_XY 1
#define INTERP_INDEX 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbi[count] = I;		\
	count++;
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void smooth_ci_z_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
GLint count = ctx->PB->count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLdepth *pbz = ctx->PB->z;
GLuint *pbi = ctx->PB->i;
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_INDEX 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbz[count] = Z;		\
	pbi[count] = I;		\
	count++;
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void smooth_rgba_line( GLcontext *ctx,
	      GLuint vert0, GLuint vert1, GLuint pvert )
{
GLint count = ctx->PB->count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLubyte *pbr = ctx->PB->r;
GLubyte *pbg = ctx->PB->g;
GLubyte *pbb = ctx->PB->b;
GLubyte *pba = ctx->PB->a;
#define INTERP_XY 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define PLOT(X,Y)			\
	pbx[count] = X;			\
	pby[count] = Y;			\
	pbr[count] = FixedToInt(r0);	\
	pbg[count] = FixedToInt(g0);	\
	pbb[count] = FixedToInt(b0);	\
	pba[count] = FixedToInt(a0);	\
	count++;
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void smooth_rgba_z_line( GLcontext *ctx,
	        GLuint vert0, GLuint vert1, GLuint pvert )
{
GLint count = ctx->PB->count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLdepth *pbz = ctx->PB->z;
GLubyte *pbr = ctx->PB->r;
GLubyte *pbg = ctx->PB->g;
GLubyte *pbb = ctx->PB->b;
GLubyte *pba = ctx->PB->a;
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define PLOT(X,Y)			\
	pbx[count] = X;			\
	pby[count] = Y;			\
	pbz[count] = Z;			\
	pbr[count] = FixedToInt(r0);	\
	pbg[count] = FixedToInt(g0);	\
	pbb[count] = FixedToInt(b0);	\
	pba[count] = FixedToInt(a0);	\
	count++;
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
#define CHECK_FULL(count)			\
	if (count >= PB_SIZE-MAX_WIDTH) {	\
	   ctx->PB->count = count;		\
	   gl_flush_pb(ctx);			\
	   count = ctx->PB->count;		\
	}
static void general_smooth_ci_line( GLcontext *ctx,
	    GLuint vert0, GLuint vert1, GLuint pvert )
{
GLint count = ctx->PB->count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLdepth *pbz = ctx->PB->z;
GLuint *pbi = ctx->PB->i;
if (ctx->Line.StippleFlag) {
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_INDEX 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbz[count] = Z;		\
	pbi[count] = I;		\
	count++;		\
	CHECK_FULL(count);
}
else {
if (ctx->Line.Width==2.0F) {
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_INDEX 1
#define XMAJOR_PLOT(X,Y)			\
	pbx[count] = X;  pbx[count+1] = X;	\
	pby[count] = Y;  pby[count+1] = Y+1;	\
	pbz[count] = Z;  pbz[count+1] = Z;	\
	pbi[count] = I;  pbi[count+1] = I;	\
	count += 2;
#define YMAJOR_PLOT(X,Y)			\
	pbx[count] = X;  pbx[count+1] = X+1;	\
	pby[count] = Y;  pby[count+1] = Y;	\
	pbz[count] = Z;  pbz[count+1] = Z;	\
	pbi[count] = I;  pbi[count+1] = I;	\
	count += 2;
}
else {
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_INDEX 1
#define WIDE 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbz[count] = Z;		\
	pbi[count] = I;		\
	count++;		\
	CHECK_FULL(count);
}
}
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void general_flat_ci_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
GLint count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLdepth *pbz = ctx->PB->z;
PB_SET_INDEX( ctx, ctx->PB, ctx->VB->Index[pvert] );
count = ctx->PB->count;
if (ctx->Line.StippleFlag) {
#define INTERP_XY 1
#define INTERP_Z 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbz[count] = Z;		\
	count++;		\
	CHECK_FULL(count);
}
else {
if (ctx->Line.Width==2.0F) {
#define INTERP_XY 1
#define INTERP_Z 1
#define XMAJOR_PLOT(X,Y)			\
	pbx[count] = X;  pbx[count+1] = X;	\
	pby[count] = Y;  pby[count+1] = Y+1;	\
	pbz[count] = Z;  pbz[count+1] = Z;	\
	count += 2;
#define YMAJOR_PLOT(X,Y)			\
	pbx[count] = X;  pbx[count+1] = X+1;	\
	pby[count] = Y;  pby[count+1] = Y;	\
	pbz[count] = Z;  pbz[count+1] = Z;	\
	count += 2;
}
else {
#define INTERP_XY 1
#define INTERP_Z 1
#define WIDE 1
#define PLOT(X,Y)		\
	pbx[count] = X;		\
	pby[count] = Y;		\
	pbz[count] = Z;		\
	count++;		\
	CHECK_FULL(count);
}
}
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void general_smooth_rgba_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert)
{
GLint count = ctx->PB->count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLdepth *pbz = ctx->PB->z;
GLubyte *pbr = ctx->PB->r;
GLubyte *pbg = ctx->PB->g;
GLubyte *pbb = ctx->PB->b;
GLubyte *pba = ctx->PB->a;
if (ctx->Line.StippleFlag) {
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)			\
	pbx[count] = X;			\
	pby[count] = Y;			\
	pbz[count] = Z;			\
	pbr[count] = FixedToInt(r0);	\
	pbg[count] = FixedToInt(g0);	\
	pbb[count] = FixedToInt(b0);	\
	pba[count] = FixedToInt(a0);	\
	count++;			\
	CHECK_FULL(count);
}
else {
if (ctx->Line.Width==2.0F) {
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define XMAJOR_PLOT(X,Y)						\
	pbx[count] = X;  pbx[count+1] = X;				\
	pby[count] = Y;  pby[count+1] = Y+1;				\
	pbz[count] = Z;  pbz[count+1] = Z;				\
	pbr[count] = FixedToInt(r0);  pbr[count+1] = FixedToInt(r0);	\
	pbg[count] = FixedToInt(g0);  pbg[count+1] = FixedToInt(g0);	\
	pbb[count] = FixedToInt(b0);  pbb[count+1] = FixedToInt(b0);	\
	pba[count] = FixedToInt(a0);  pba[count+1] = FixedToInt(a0);	\
	count += 2;
#define YMAJOR_PLOT(X,Y)						\
	pbx[count] = X;  pbx[count+1] = X+1;				\
	pby[count] = Y;  pby[count+1] = Y;				\
	pbz[count] = Z;  pbz[count+1] = Z;				\
	pbr[count] = FixedToInt(r0);  pbr[count+1] = FixedToInt(r0);	\
	pbg[count] = FixedToInt(g0);  pbg[count+1] = FixedToInt(g0);	\
	pbb[count] = FixedToInt(b0);  pbb[count+1] = FixedToInt(b0);	\
	pba[count] = FixedToInt(a0);  pba[count+1] = FixedToInt(a0);	\
	count += 2;
}
else {
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define WIDE 1
#define PLOT(X,Y)			\
	pbx[count] = X;			\
	pby[count] = Y;			\
	pbz[count] = Z;			\
	pbr[count] = FixedToInt(r0);	\
	pbg[count] = FixedToInt(g0);	\
	pbb[count] = FixedToInt(b0);	\
	pba[count] = FixedToInt(a0);	\
	count++;			\
	CHECK_FULL(count);
}
}
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void general_flat_rgba_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
GLint count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLdepth *pbz = ctx->PB->z;
GLubyte *color = ctx->VB->Color[pvert];
PB_SET_COLOR( ctx, ctx->PB, color[0], color[1], color[2], color[3] );
count = ctx->PB->count;
if (ctx->Line.StippleFlag) {
#define INTERP_XY 1
#define INTERP_Z 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)			\
	pbx[count] = X;			\
	pby[count] = Y;			\
	pbz[count] = Z;			\
	count++;			\
	CHECK_FULL(count);
}
else {
if (ctx->Line.Width==2.0F) {
#define INTERP_XY 1
#define INTERP_Z 1
#define XMAJOR_PLOT(X,Y)			\
	pbx[count] = X;  pbx[count+1] = X;	\
	pby[count] = Y;  pby[count+1] = Y+1;	\
	pbz[count] = Z;  pbz[count+1] = Z;	\
	count += 2;
#define YMAJOR_PLOT(X,Y)			\
	pbx[count] = X;  pbx[count+1] = X+1;	\
	pby[count] = Y;  pby[count+1] = Y;	\
	pbz[count] = Z;  pbz[count+1] = Z;	\
	count += 2;
}
else {
#define INTERP_XY 1
#define INTERP_Z 1
#define WIDE 1
#define PLOT(X,Y)			\
	pbx[count] = X;			\
	pby[count] = Y;			\
	pbz[count] = Z;			\
	count++;			\
	CHECK_FULL(count);
}
}
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void flat_textured_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pv )
{
GLint count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLdepth *pbz = ctx->PB->z;
float *pbs = ctx->PB->s;
float *pbt = ctx->PB->t;
float *pbu = ctx->PB->u;
GLubyte *color = ctx->VB->Color[pv];
PB_SET_COLOR( ctx, ctx->PB, color[0], color[1], color[2], color[3] );
count = ctx->PB->count;
if (ctx->Line.StippleFlag) {
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_STW 1
#define INTERP_UV 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)			\
	pbx[count] = X;			\
	pby[count] = Y;			\
	pbz[count] = Z;			\
	pbs[count] = s0 / w0;		\
	pbt[count] = t0 / w0;		\
	pbu[count] = u0 / w0;		\
	count++;			\
	CHECK_FULL(count);
}
else {
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_STW 1
#define INTERP_UV 1
#define WIDE 1
#define PLOT(X,Y)			\
	pbx[count] = X;			\
	pby[count] = Y;			\
	pbz[count] = Z;			\
	pbs[count] = s0 / w0;		\
	pbt[count] = t0 / w0;		\
	pbu[count] = u0 / w0;		\
	count++;			\
	CHECK_FULL(count);
}
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void smooth_textured_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pv )
{
GLint count = ctx->PB->count;
GLint *pbx = ctx->PB->x;
GLint *pby = ctx->PB->y;
GLdepth *pbz = ctx->PB->z;
float *pbs = ctx->PB->s;
float *pbt = ctx->PB->t;
float *pbu = ctx->PB->u;
GLubyte *pbr = ctx->PB->r;
GLubyte *pbg = ctx->PB->g;
GLubyte *pbb = ctx->PB->b;
GLubyte *pba = ctx->PB->a;
if (ctx->Line.StippleFlag) {
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INTERP_STW 1
#define INTERP_UV 1
#define WIDE 1
#define STIPPLE 1
#define PLOT(X,Y)			\
	pbx[count] = X;			\
	pby[count] = Y;			\
	pbz[count] = Z;			\
	pbs[count] = s0 / w0;		\
	pbt[count] = t0 / w0;		\
	pbu[count] = u0 / w0;		\
	pbr[count] = FixedToInt(r0);	\
	pbg[count] = FixedToInt(g0);	\
	pbb[count] = FixedToInt(b0);	\
	pba[count] = FixedToInt(a0);	\
	count++;			\
	CHECK_FULL(count);
}
else {
#define INTERP_XY 1
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INTERP_STW 1
#define INTERP_UV 1
#define WIDE 1
#define PLOT(X,Y)			\
	pbx[count] = X;			\
	pby[count] = Y;			\
	pbz[count] = Z;			\
	pbs[count] = s0 / w0;		\
	pbt[count] = t0 / w0;		\
	pbu[count] = u0 / w0;		\
	pbr[count] = FixedToInt(r0);	\
	pbg[count] = FixedToInt(g0);	\
	pbb[count] = FixedToInt(b0);	\
	pba[count] = FixedToInt(a0);	\
	count++;			\
	CHECK_FULL(count);
}
ctx->PB->count = count;
PB_CHECK_FLUSH( ctx, ctx->PB );
}
static void null_line( GLcontext *ctx, GLuint v1, GLuint v2, GLuint pv )
{
}
void gl_set_line_function( GLcontext *ctx )
{
GLboolean rgbmode = ctx->Visual->RGBAflag;
if (ctx->RenderMode==GL_RENDER) {
if (ctx->NoRaster) {
ctx->Driver.LineFunc = null_line;
return;
}
if (ctx->Driver.LineFunc) {
ctx->Driver.LineFunc = ctx->Driver.LineFunc;
}
else if (ctx->Texture.Enabled) {
if (ctx->Light.ShadeModel==GL_SMOOTH) {
ctx->Driver.LineFunc = smooth_textured_line;
}
else {
ctx->Driver.LineFunc = flat_textured_line;
}
}
else if (ctx->Line.Width!=1.0 || ctx->Line.StippleFlag
|| ctx->Line.SmoothFlag || ctx->Texture.Enabled) {
if (ctx->Light.ShadeModel==GL_SMOOTH) {
ctx->Driver.LineFunc = rgbmode ? general_smooth_rgba_line
: general_smooth_ci_line;
}
else {
ctx->Driver.LineFunc = rgbmode ? general_flat_rgba_line
: general_flat_ci_line;
}
}
else {
	 if (ctx->Light.ShadeModel==GL_SMOOTH) {
	
if (ctx->Depth.Test
	        || (ctx->Fog.Enabled && ctx->Hint.Fog==GL_NICEST)) {
ctx->Driver.LineFunc = rgbmode ? smooth_rgba_z_line
: smooth_ci_z_line;
}
else {
ctx->Driver.LineFunc = rgbmode ? smooth_rgba_line
: smooth_ci_line;
}
	 }
else {
	
if (ctx->Depth.Test
|| (ctx->Fog.Enabled && ctx->Hint.Fog==GL_NICEST)) {
ctx->Driver.LineFunc = rgbmode ? flat_rgba_z_line
: flat_ci_z_line;
}
else {
ctx->Driver.LineFunc = rgbmode ? flat_rgba_line
: flat_ci_line;
}
}
}
}
else if (ctx->RenderMode==GL_FEEDBACK) {
ctx->Driver.LineFunc = feedback_line;
}
else {
ctx->Driver.LineFunc = select_line;
}
}
/* 当前文件是D:\Read\logic.c*/

#ifdef PC_HEADER
#else
#endif
void gl_LogicOp( GLcontext *ctx, GLenum opcode )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glLogicOp" );
return;
}
switch (opcode) {
case GL_CLEAR:
case GL_SET:
case GL_COPY:
case GL_COPY_INVERTED:
case GL_NOOP:
case GL_INVERT:
case GL_AND:
case GL_NAND:
case GL_OR:
case GL_NOR:
case GL_XOR:
case GL_EQUIV:
case GL_AND_REVERSE:
case GL_AND_INVERTED:
case GL_OR_REVERSE:
case GL_OR_INVERTED:
ctx->Color.LogicOp = opcode;
ctx->NewState |= NEW_RASTER_OPS;
	 return;
default:
gl_error( ctx, GL_INVALID_ENUM, "glLogicOp" );
	 return;
}
}
void gl_logicop_ci_span( GLcontext *ctx, GLuint n, GLint x, GLint y,
GLuint index[], GLubyte mask[] )
{
GLuint dest[MAX_WIDTH];
GLuint i;
(*ctx->Driver.ReadIndexSpan)( ctx, n, x, y, dest );
switch (ctx->Color.LogicOp) {
case GL_CLEAR:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = 0;
	    }
	 }
	 break;
case GL_SET:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = 1;
	    }
	 }
	 break;
case GL_COPY:
	
	 break;
case GL_COPY_INVERTED:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~index[i];
	    }
	 }
	 break;
case GL_NOOP:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = dest[i];
	    }
	 }
	 break;
case GL_INVERT:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~dest[i];
	    }
	 }
	 break;
case GL_AND:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] &= dest[i];
	    }
	 }
	 break;
case GL_NAND:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~(index[i] & dest[i]);
	    }
	 }
	 break;
case GL_OR:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] |= dest[i];
	    }
	 }
	 break;
case GL_NOR:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~(index[i] | dest[i]);
	    }
	 }
	 break;
case GL_XOR:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] ^= dest[i];
	    }
	 }
	 break;
case GL_EQUIV:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~(index[i] ^ dest[i]);
	    }
	 }
	 break;
case GL_AND_REVERSE:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = index[i] & ~dest[i];
	    }
	 }
	 break;
case GL_AND_INVERTED:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~index[i] & dest[i];
	    }
	 }
	 break;
case GL_OR_REVERSE:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = index[i] | ~dest[i];
	    }
	 }
	 break;
case GL_OR_INVERTED:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~index[i] | dest[i];
	    }
	 }
	 break;
default:
	 gl_error( ctx, GL_INVALID_ENUM, "gl_logic error" );
}
}
void gl_logicop_ci_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
GLuint index[], GLubyte mask[] )
{
GLuint dest[PB_SIZE];
GLuint i;
(*ctx->Driver.ReadIndexPixels)( ctx, n, x, y, dest, mask );
switch (ctx->Color.LogicOp) {
case GL_CLEAR:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = 0;
	    }
	 }
	 break;
case GL_SET:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = 1;
	    }
	 }
	 break;
case GL_COPY:
	
	 break;
case GL_COPY_INVERTED:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~index[i];
	    }
	 }
	 break;
case GL_NOOP:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = dest[i];
	    }
	 }
	 break;
case GL_INVERT:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~dest[i];
	    }
	 }
	 break;
case GL_AND:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] &= dest[i];
	    }
	 }
	 break;
case GL_NAND:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~(index[i] & dest[i]);
	    }
	 }
	 break;
case GL_OR:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] |= dest[i];
	    }
	 }
	 break;
case GL_NOR:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~(index[i] | dest[i]);
	    }
	 }
	 break;
case GL_XOR:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] ^= dest[i];
	    }
	 }
	 break;
case GL_EQUIV:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~(index[i] ^ dest[i]);
	    }
	 }
	 break;
case GL_AND_REVERSE:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = index[i] & ~dest[i];
	    }
	 }
	 break;
case GL_AND_INVERTED:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~index[i] & dest[i];
	    }
	 }
	 break;
case GL_OR_REVERSE:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = index[i] | ~dest[i];
	    }
	 }
	 break;
case GL_OR_INVERTED:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       index[i] = ~index[i] | dest[i];
	    }
	 }
	 break;
default:
	 gl_error( ctx, GL_INVALID_ENUM, "gl_logic_pixels error" );
}
}
void gl_logicop_rgba_span( GLcontext *ctx,
GLuint n, GLint x, GLint y,
GLubyte red[], GLubyte green[],
GLubyte blue[], GLubyte alpha[],
GLubyte mask[] )
{
GLubyte rdest[MAX_WIDTH], gdest[MAX_WIDTH];
GLubyte bdest[MAX_WIDTH], adest[MAX_WIDTH];
GLuint i;
gl_read_color_span( ctx, n, x, y, rdest, gdest, bdest, adest );
switch (ctx->Color.LogicOp) {
case GL_CLEAR:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i] = green[i] = blue[i] = alpha[i] = 0;
}
}
break;
case GL_SET:
{
GLubyte r = (GLint) ctx->Visual->RedScale;
GLubyte g = (GLint) ctx->Visual->GreenScale;
GLubyte b = (GLint) ctx->Visual->BlueScale;
GLubyte a = (GLint) ctx->Visual->AlphaScale;
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = r;
green[i] = g;
blue[i]  = b;
alpha[i] = a;
}
}
}
break;
case GL_COPY:
break;
case GL_COPY_INVERTED:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~red[i];
green[i] = ~green[i];
blue[i]  = ~blue[i];
alpha[i] = ~alpha[i];
}
}
break;
case GL_NOOP:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = rdest[i];
green[i] = gdest[i];
blue[i]  = bdest[i];
alpha[i] = adest[i];
}
}
break;
case GL_INVERT:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~rdest[i];
green[i] = ~gdest[i];
blue[i]  = ~bdest[i];
alpha[i] = ~adest[i];
}
}
break;
case GL_AND:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   &= rdest[i];
green[i] &= gdest[i];
blue[i]  &= bdest[i];
alpha[i] &= adest[i];
}
}
break;
case GL_NAND:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~(red[i]   & rdest[i]);
green[i] = ~(green[i] & gdest[i]);
blue[i]  = ~(blue[i]  & bdest[i]);
alpha[i] = ~(alpha[i] & adest[i]);
}
}
break;
case GL_OR:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   |= rdest[i];
green[i] |= gdest[i];
blue[i]  |= bdest[i];
alpha[i] |= adest[i];
}
}
break;
case GL_NOR:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~(red[i]   | rdest[i]);
green[i] = ~(green[i] | gdest[i]);
blue[i]  = ~(blue[i]  | bdest[i]);
alpha[i] = ~(alpha[i] | adest[i]);
}
}
break;
case GL_XOR:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   ^= rdest[i];
green[i] ^= gdest[i];
blue[i]  ^= bdest[i];
alpha[i] ^= adest[i];
}
}
break;
case GL_EQUIV:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~(red[i]   ^ rdest[i]);
green[i] = ~(green[i] ^ gdest[i]);
blue[i]  = ~(blue[i]  ^ bdest[i]);
alpha[i] = ~(alpha[i] ^ adest[i]);
}
}
break;
case GL_AND_REVERSE:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = red[i]   & ~rdest[i];
green[i] = green[i] & ~gdest[i];
blue[i]  = blue[i]  & ~bdest[i];
alpha[i] = alpha[i] & ~adest[i];
}
}
break;
case GL_AND_INVERTED:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~red[i]   & rdest[i];
green[i] = ~green[i] & gdest[i];
blue[i]  = ~blue[i]  & bdest[i];
alpha[i] = ~alpha[i] & adest[i];
}
}
break;
case GL_OR_REVERSE:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = red[i]   | ~rdest[i];
green[i] = green[i] | ~gdest[i];
blue[i]  = blue[i]  | ~bdest[i];
alpha[i] = alpha[i] | ~adest[i];
}
}
break;
case GL_OR_INVERTED:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~red[i]   | rdest[i];
green[i] = ~green[i] | gdest[i];
blue[i]  = ~blue[i]  | bdest[i];
alpha[i] = ~alpha[i] | adest[i];
}
}
break;
default:
gl_problem(ctx, "Bad function in gl_logicop_rgba_span");
return;
}
}
void gl_logicop_rgba_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
GLubyte red[], GLubyte green[],
GLubyte blue[], GLubyte alpha[],
GLubyte mask[] )
{
GLubyte rdest[PB_SIZE], gdest[PB_SIZE], bdest[PB_SIZE], adest[PB_SIZE];
GLuint i;
(*ctx->Driver.ReadColorPixels)( ctx, n, x, y, rdest, gdest, bdest, adest, mask );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_read_alpha_pixels( ctx, n, x, y, adest, mask );
}
switch (ctx->Color.LogicOp) {
case GL_CLEAR:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i] = green[i] = blue[i] = alpha[i] = 0;
}
}
break;
case GL_SET:
{
GLubyte r = (GLint) ctx->Visual->RedScale;
GLubyte g = (GLint) ctx->Visual->GreenScale;
GLubyte b = (GLint) ctx->Visual->BlueScale;
GLubyte a = (GLint) ctx->Visual->AlphaScale;
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = r;
green[i] = g;
blue[i]  = b;
alpha[i] = a;
}
}
}
break;
case GL_COPY:
break;
case GL_COPY_INVERTED:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~red[i];
green[i] = ~green[i];
blue[i]  = ~blue[i];
alpha[i] = ~alpha[i];
}
}
break;
case GL_NOOP:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = rdest[i];
green[i] = gdest[i];
blue[i]  = bdest[i];
alpha[i] = adest[i];
}
}
break;
case GL_INVERT:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~rdest[i];
green[i] = ~gdest[i];
blue[i]  = ~bdest[i];
alpha[i] = ~adest[i];
}
}
break;
case GL_AND:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   &= rdest[i];
green[i] &= gdest[i];
blue[i]  &= bdest[i];
alpha[i] &= adest[i];
}
}
break;
case GL_NAND:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~(red[i]   & rdest[i]);
green[i] = ~(green[i] & gdest[i]);
blue[i]  = ~(blue[i]  & bdest[i]);
alpha[i] = ~(alpha[i] & adest[i]);
}
}
break;
case GL_OR:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   |= rdest[i];
green[i] |= gdest[i];
blue[i]  |= bdest[i];
alpha[i] |= adest[i];
}
}
break;
case GL_NOR:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~(red[i]   | rdest[i]);
green[i] = ~(green[i] | gdest[i]);
blue[i]  = ~(blue[i]  | bdest[i]);
alpha[i] = ~(alpha[i] | adest[i]);
}
}
break;
case GL_XOR:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   ^= rdest[i];
green[i] ^= gdest[i];
blue[i]  ^= bdest[i];
alpha[i] ^= adest[i];
}
}
break;
case GL_EQUIV:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~(red[i]   ^ rdest[i]);
green[i] = ~(green[i] ^ gdest[i]);
blue[i]  = ~(blue[i]  ^ bdest[i]);
alpha[i] = ~(alpha[i] ^ adest[i]);
}
}
break;
case GL_AND_REVERSE:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = red[i]   & ~rdest[i];
green[i] = green[i] & ~gdest[i];
blue[i]  = blue[i]  & ~bdest[i];
alpha[i] = alpha[i] & ~adest[i];
}
}
break;
case GL_AND_INVERTED:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~red[i]   & rdest[i];
green[i] = ~green[i] & gdest[i];
blue[i]  = ~blue[i]  & bdest[i];
alpha[i] = ~alpha[i] & adest[i];
}
}
break;
case GL_OR_REVERSE:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = red[i]   | ~rdest[i];
green[i] = green[i] | ~gdest[i];
blue[i]  = blue[i]  | ~bdest[i];
alpha[i] = alpha[i] | ~adest[i];
}
}
break;
case GL_OR_INVERTED:
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = ~red[i]   | rdest[i];
green[i] = ~green[i] | gdest[i];
blue[i]  = ~blue[i]  | bdest[i];
alpha[i] = ~alpha[i] | adest[i];
}
}
break;
default:
gl_problem(ctx, "Bad function in gl_logicop_rgba_pixels");
return;
}
}
/* 当前文件是D:\Read\makemesh.c*/

#define ROWS 150													
#define COLUMNS 150													
static float SurfaceV1[ROWS][COLUMNS][3];
static float SurfaceN1[ROWS][COLUMNS][3];
//static float Xmin = -10.0, Xmax = 10.0;
//static float Ymin = -10.0, Ymax = 10.0;
static float Func1( float x, float y )
{
float s = cos(x*0.5) * (10.0 - fabs(x));
float t = cos(y*0.5) * (10.0 - fabs(y));
return s * t * 0.05;
}
static void MakeSurface( float (*func)(float, float) )
{
float x, y;
float dx, dy;
int i, j;
dx = (Xmax - Xmin) / (COLUMNS-1);
dy = (Ymax - Ymin) / (ROWS-1);
y = Ymin;
for (i=0; i < ROWS; i++) {
x = Xmin;
for (j=0; j < COLUMNS; j++) {
float z = (*func)(x, y);
SurfaceV1[i][j][0] = x;
SurfaceV1[i][j][1] = y;
SurfaceV1[i][j][2] = z;
x += dx;
}
y += dy;
}
}
static void ComputeNormals( void )
{
int i, j;
float dx = (Xmax - Xmin) / (COLUMNS-1);
float dy = (Ymax - Ymin) / (ROWS-1);
for (i=0; i < ROWS; i++) {
for (j=0; j < COLUMNS; j++) {
float ax = dx;
float ay = 0.0;
float az = SurfaceV1[i][j+1][2] - SurfaceV1[i][j][2];
float bx = 0.0;
float by = dy;
float bz = SurfaceV1[i+1][j][2] - SurfaceV1[i][j][2];
float nx = ay*bz - az*by;
float ny = az*bx - ax*bz;
float nz = ax*by - ay*bx;
float len = sqrt(nx*nx + ny*ny + nz*nz);
SurfaceN1[i][j][0] = nx / len;
SurfaceN1[i][j][1] = ny / len;
SurfaceN1[i][j][2] = nz / len;
}
}
for (i=0; i < ROWS; i++) {
SurfaceN1[i][COLUMNS-1][0] = 0;
SurfaceN1[i][COLUMNS-1][1] = 0;
SurfaceN1[i][COLUMNS-1][2] = 1;
}
for (j=0; j < COLUMNS; j++) {
SurfaceN1[ROWS-1][j][0] = 0;
SurfaceN1[ROWS-1][j][1] = 0;
SurfaceN1[ROWS-1][j][2] = 1;
}
}
static void WriteMesh(const char *filename)
{
int i, j;
FILE *f = fopen(filename, "w");
if (!f) {
printf("Error: couldn't open output file: %s\n", filename);
return;
}
fprintf(f, "%d %d\n", ROWS, COLUMNS);
for (i=0; i<ROWS; i++) {
for (j=0; j<ROWS; j++) {
	 fprintf(f, "%f %f %f  %f %f %f\n",
		 SurfaceV1[i][j][0], SurfaceV1[i][j][1], SurfaceV1[i][j][2],
		 SurfaceN1[i][j][0], SurfaceN1[i][j][1], SurfaceN1[i][j][2]);
}
}
fclose(f);
}

/* 当前文件是D:\Read\masking.c*/

#ifdef PC_HEADER
#else
#endif
void gl_IndexMask( GLcontext *ctx, GLuint mask )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glIndexMask" );
return;
}
ctx->Color.IndexMask = mask;
ctx->NewState |= NEW_RASTER_OPS;
}
void gl_ColorMask( GLcontext *ctx, GLboolean red, GLboolean green,
GLboolean blue, GLboolean alpha )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glColorMask" );
return;
}
ctx->Color.ColorMask = (red << 3) | (green << 2) | (blue << 1) | alpha;
ctx->NewState |= NEW_RASTER_OPS;
}
void gl_mask_color_span( GLcontext *ctx,
GLuint n, GLint x, GLint y,
GLubyte red[], GLubyte green[],
GLubyte blue[], GLubyte alpha[] )
{
GLubyte r[MAX_WIDTH], g[MAX_WIDTH], b[MAX_WIDTH], a[MAX_WIDTH];
gl_read_color_span( ctx, n, x, y, r, g, b, a );
if ((ctx->Color.ColorMask & 8) == 0) {
MEMCPY( red, r, n );
}
if ((ctx->Color.ColorMask & 4) == 0) {
MEMCPY( green, g, n );
}
if ((ctx->Color.ColorMask & 2) == 0) {
MEMCPY( blue, b, n );
}
if ((ctx->Color.ColorMask & 1) == 0) {
MEMCPY( alpha, a, n );
}
}
void gl_mask_color_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
GLubyte red[], GLubyte green[],
GLubyte blue[], GLubyte alpha[],
const GLubyte mask[] )
{
GLubyte r[PB_SIZE], g[PB_SIZE], b[PB_SIZE], a[PB_SIZE];
(*ctx->Driver.ReadColorPixels)( ctx, n, x, y, r, g, b, a, mask );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_read_alpha_pixels( ctx, n, x, y, a, mask );
}
if ((ctx->Color.ColorMask & 8) == 0) {
MEMCPY( red, r, n );
}
if ((ctx->Color.ColorMask & 4) == 0) {
MEMCPY( green, g, n );
}
if ((ctx->Color.ColorMask & 2) == 0) {
MEMCPY( blue, b, n );
}
if ((ctx->Color.ColorMask & 1) == 0) {
MEMCPY( alpha, a, n );
}
}
void gl_mask_index_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLuint index[] )
{
GLuint i;
GLuint fbindexes[MAX_WIDTH];
GLuint msrc, mdest;
gl_read_index_span( ctx, n, x, y, fbindexes );
msrc = ctx->Color.IndexMask;
mdest = ~msrc;
for (i=0;i<n;i++) {
index[i] = (index[i] & msrc) | (fbindexes[i] & mdest);
}
}
void gl_mask_index_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
GLuint index[], const GLubyte mask[] )
{
GLuint i;
GLuint fbindexes[PB_SIZE];
GLuint msrc, mdest;
(*ctx->Driver.ReadIndexPixels)( ctx, n, x, y, fbindexes, mask );
msrc = ctx->Color.IndexMask;
mdest = ~msrc;
for (i=0;i<n;i++) {
index[i] = (index[i] & msrc) | (fbindexes[i] & mdest);
}
}
/* 当前文件是D:\Read\matrix.c*/

#ifdef PC_HEADER
#else
#endif
static float Identity[16] = {
1.0, 0.0, 0.0, 0.0,
0.0, 1.0, 0.0, 0.0,
0.0, 0.0, 1.0, 0.0,
0.0, 0.0, 0.0, 1.0
};
static void print_matrix( const float m[16] )
{
int i;
for (i=0;i<4;i++) {
printf("%f %f %f %f\n", m[i], m[4+i], m[8+i], m[12+i] );
}
}
static void matmul( float *product, const float *a, const float *b )
{
GLint i;
#define A(row,col)  a[(col<<2)+row]
#define B(row,col)  b[(col<<2)+row]
#define P(row,col)  product[(col<<2)+row]
for (i = 0; i < 4; i++) {
float ai0=A(i,0),  ai1=A(i,1),  ai2=A(i,2),  ai3=A(i,3);
P(i,0) = ai0 * B(0,0) + ai1 * B(1,0) + ai2 * B(2,0) + ai3 * B(3,0);
P(i,1) = ai0 * B(0,1) + ai1 * B(1,1) + ai2 * B(2,1) + ai3 * B(3,1);
P(i,2) = ai0 * B(0,2) + ai1 * B(1,2) + ai2 * B(2,2) + ai3 * B(3,2);
P(i,3) = ai0 * B(0,3) + ai1 * B(1,3) + ai2 * B(2,3) + ai3 * B(3,3);
}
#undef A
#undef B
#undef P
}
typedef float Mat2[2][2];
enum {
M00 = 0, M01 = 4, M02 = 8, M03 = 12,
M10 = 1, M11 = 5, M12 = 9, M13 = 13,
M20 = 2, M21 = 6, M22 = 10,M23 = 14,
M30 = 3, M31 = 7, M32 = 11,M33 = 15
};
static void invert_matrix_general( const float *m, float *out )
{
Mat2 r1, r2, r3, r4, r5, r6, r7;
const float * A = m;
float *       C = out;
float one_over_det;
one_over_det = 1.0f / ( ( A[M00] * A[M11] ) - ( A[M10] * A[M01] ) );
r1[0][0] = one_over_det * A[M11];
r1[0][1] = one_over_det * -A[M01];
r1[1][0] = one_over_det * -A[M10];
r1[1][1] = one_over_det * A[M00];
r2[0][0] = A[M20] * r1[0][0] + A[M21] * r1[1][0];
r2[0][1] = A[M20] * r1[0][1] + A[M21] * r1[1][1];
r2[1][0] = A[M30] * r1[0][0] + A[M31] * r1[1][0];
r2[1][1] = A[M30] * r1[0][1] + A[M31] * r1[1][1];
r3[0][0] = r1[0][0] * A[M02] + r1[0][1] * A[M12];
r3[0][1] = r1[0][0] * A[M03] + r1[0][1] * A[M13];
r3[1][0] = r1[1][0] * A[M02] + r1[1][1] * A[M12];
r3[1][1] = r1[1][0] * A[M03] + r1[1][1] * A[M13];
r4[0][0] = A[M20] * r3[0][0] + A[M21] * r3[1][0];
r4[0][1] = A[M20] * r3[0][1] + A[M21] * r3[1][1];
r4[1][0] = A[M30] * r3[0][0] + A[M31] * r3[1][0];
r4[1][1] = A[M30] * r3[0][1] + A[M31] * r3[1][1];
r5[0][0] = r4[0][0] - A[M22];
r5[0][1] = r4[0][1] - A[M23];
r5[1][0] = r4[1][0] - A[M32];
r5[1][1] = r4[1][1] - A[M33];
one_over_det = 1.0f / ( ( r5[0][0] * r5[1][1] ) - ( r5[1][0] * r5[0][1] ) );
r6[0][0] = one_over_det * r5[1][1];
r6[0][1] = one_over_det * -r5[0][1];
r6[1][0] = one_over_det * -r5[1][0];
r6[1][1] = one_over_det * r5[0][0];
C[M02] = r3[0][0] * r6[0][0] + r3[0][1] * r6[1][0];
C[M03] = r3[0][0] * r6[0][1] + r3[0][1] * r6[1][1];
C[M12] = r3[1][0] * r6[0][0] + r3[1][1] * r6[1][0];
C[M13] = r3[1][0] * r6[0][1] + r3[1][1] * r6[1][1];
C[M20] = r6[0][0] * r2[0][0] + r6[0][1] * r2[1][0];
C[M21] = r6[0][0] * r2[0][1] + r6[0][1] * r2[1][1];
C[M30] = r6[1][0] * r2[0][0] + r6[1][1] * r2[1][0];
C[M31] = r6[1][0] * r2[0][1] + r6[1][1] * r2[1][1];
r7[0][0] = r3[0][0] * C[M20] + r3[0][1] * C[M30];
r7[0][1] = r3[0][0] * C[M21] + r3[0][1] * C[M31];
r7[1][0] = r3[1][0] * C[M20] + r3[1][1] * C[M30];
r7[1][1] = r3[1][0] * C[M21] + r3[1][1] * C[M31];
C[M00] = r1[0][0] - r7[0][0];
C[M01] = r1[0][1] - r7[0][1];
C[M10] = r1[1][0] - r7[1][0];
C[M11] = r1[1][1] - r7[1][1];
C[M22] = -r6[0][0];
C[M23] = -r6[0][1];
C[M32] = -r6[1][0];
C[M33] = -r6[1][1];
}
static void invert_matrix( const float *m, float *out )
{
#define MAT(m,r,c) (m)[(c)*4+(r)]
#define m11 MAT(m,0,0)
#define m12 MAT(m,0,1)
#define m13 MAT(m,0,2)
#define m14 MAT(m,0,3)
#define m21 MAT(m,1,0)
#define m22 MAT(m,1,1)
#define m23 MAT(m,1,2)
#define m24 MAT(m,1,3)
#define m31 MAT(m,2,0)
#define m32 MAT(m,2,1)
#define m33 MAT(m,2,2)
#define m34 MAT(m,2,3)
#define m41 MAT(m,3,0)
#define m42 MAT(m,3,1)
#define m43 MAT(m,3,2)
#define m44 MAT(m,3,3)
register float det;
float tmp[16];
if( m41 != 0. || m42 != 0. || m43 != 0. || m44 != 1. ) {
invert_matrix_general(m, out);
return;
}
tmp[0]= m22 * m33 - m23 * m32;
tmp[1]= m23 * m31 - m21 * m33;
tmp[2]= m21 * m32 - m22 * m31;
det= m11 * tmp[0] + m12 * tmp[1] + m13 * tmp[2];
if (det == 0.0F) {
MEMCPY( out, Identity, 16*sizeof(float) );
}
else {
float d12, d13, d23, d24, d34, d41;
register float im11, im12, im13, im14;
det= 1. / det;
tmp[0] *= det;
tmp[1] *= det;
tmp[2] *= det;
tmp[3]  = 0.;
im11= m11 * det;
im12= m12 * det;
im13= m13 * det;
im14= m14 * det;
tmp[4] = im13 * m32 - im12 * m33;
tmp[5] = im11 * m33 - im13 * m31;
tmp[6] = im12 * m31 - im11 * m32;
tmp[7] = 0.;
d12 = im11*m22 - m21*im12;
d13 = im11*m23 - m21*im13;
d23 = im12*m23 - m22*im13;
d24 = im12*m24 - m22*im14;
d34 = im13*m24 - m23*im14;
d41 = im14*m21 - m24*im11;
tmp[8] =  d23;
tmp[9] = -d13;
tmp[10] = d12;
tmp[11] = 0.;
tmp[12] = -(m32 * d34 - m33 * d24 + m34 * d23);
tmp[13] =  (m31 * d34 + m33 * d41 + m34 * d13);
tmp[14] = -(m31 * d24 + m32 * d41 + m34 * d12);
tmp[15] =  1.;
MEMCPY(out, tmp, 16*sizeof(float));
}
#undef m11
#undef m12
#undef m13
#undef m14
#undef m21
#undef m22
#undef m23
#undef m24
#undef m31
#undef m32
#undef m33
#undef m34
#undef m41
#undef m42
#undef m43
#undef m44
#undef MAT
}
static GLboolean is_identity( const float m[16] )
{
if (   m[0]==1.0F && m[4]==0.0F && m[ 8]==0.0F && m[12]==0.0F
&& m[1]==0.0F && m[5]==1.0F && m[ 9]==0.0F && m[13]==0.0F
&& m[2]==0.0F && m[6]==0.0F && m[10]==1.0F && m[14]==0.0F
&& m[3]==0.0F && m[7]==0.0F && m[11]==0.0F && m[15]==1.0F) {
return GL_TRUE;
}
else {
return GL_FALSE;
}
}
void gl_analyze_modelview_matrix( GLcontext *ctx )
{
const float *m = ctx->ModelViewMatrix;
if (is_identity(m)) {
ctx->ModelViewMatrixType = MATRIX_IDENTITY;
}
else if (                 m[4]==0.0F && m[ 8]==0.0F
&& m[1]==0.0F               && m[ 9]==0.0F
&& m[2]==0.0F && m[6]==0.0F && m[10]==1.0F && m[14]==0.0F
&& m[3]==0.0F && m[7]==0.0F && m[11]==0.0F && m[15]==1.0F) {
ctx->ModelViewMatrixType = MATRIX_2D_NO_ROT;
}
else if (                               m[ 8]==0.0F
&&                             m[ 9]==0.0F
&& m[2]==0.0F && m[6]==0.0F && m[10]==1.0F && m[14]==0.0F
&& m[3]==0.0F && m[7]==0.0F && m[11]==0.0F && m[15]==1.0F) {
ctx->ModelViewMatrixType = MATRIX_2D;
}
else if (m[3]==0.0F && m[7]==0.0F && m[11]==0.0F && m[15]==1.0F) {
ctx->ModelViewMatrixType = MATRIX_3D;
}
else {
ctx->ModelViewMatrixType = MATRIX_GENERAL;
}
invert_matrix( ctx->ModelViewMatrix, ctx->ModelViewInv );
ctx->NewModelViewMatrix = GL_FALSE;
}
void gl_analyze_projection_matrix( GLcontext *ctx )
{
const float *m = ctx->ProjectionMatrix;
if (is_identity(m)) {
ctx->ProjectionMatrixType = MATRIX_IDENTITY;
}
else if (                 m[4]==0.0F && m[8] ==0.0F
&& m[1]==0.0F               && m[9] ==0.0F
&& m[2]==0.0F && m[6]==0.0F
&& m[3]==0.0F && m[7]==0.0F && m[11]==0.0F && m[15]==1.0F) {
ctx->ProjectionMatrixType = MATRIX_ORTHO;
}
else if (                 m[4]==0.0F                 && m[12]==0.0F
&& m[1]==0.0F                               && m[13]==0.0F
&& m[2]==0.0F && m[6]==0.0F
&& m[3]==0.0F && m[7]==0.0F && m[11]==-1.0F && m[15]==0.0F) {
ctx->ProjectionMatrixType = MATRIX_PERSPECTIVE;
}
else {
ctx->ProjectionMatrixType = MATRIX_GENERAL;
}
ctx->NewProjectionMatrix = GL_FALSE;
}
void gl_analyze_texture_matrix( GLcontext *ctx )
{
const float *m = ctx->TextureMatrix;
if (is_identity(m)) {
ctx->TextureMatrixType = MATRIX_IDENTITY;
}
else if (                               m[ 8]==0.0F
&&                             m[ 9]==0.0F
&& m[2]==0.0F && m[6]==0.0F && m[10]==1.0F && m[14]==0.0F
&& m[3]==0.0F && m[7]==0.0F && m[11]==0.0F && m[15]==1.0F) {
ctx->TextureMatrixType = MATRIX_2D;
}
else if (m[3]==0.0F && m[7]==0.0F && m[11]==0.0F && m[15]==1.0F) {
ctx->TextureMatrixType = MATRIX_3D;
}
else {
ctx->TextureMatrixType = MATRIX_GENERAL;
}
ctx->NewTextureMatrix = GL_FALSE;
}
void gl_Frustum( GLcontext *ctx,
GLdouble left, GLdouble right,
	 	 GLdouble bottom, GLdouble top,
		 GLdouble nearval, GLdouble farval )
{
float x, y, a, b, c, d;
float m[16];
if (nearval<=0.0 || farval<=0.0) {
gl_error( ctx,  GL_INVALID_VALUE, "glFrustum(near or far)" );
}
x = (2.0*nearval) / (right-left);
y = (2.0*nearval) / (top-bottom);
a = (right+left) / (right-left);
b = (top+bottom) / (top-bottom);
c = -(farval+nearval) / ( farval-nearval);
d = -(2.0*farval*nearval) / (farval-nearval);
#define M(row,col)  m[col*4+row]
M(0,0) = x;     M(0,1) = 0.0F;  M(0,2) = a;      M(0,3) = 0.0F;
M(1,0) = 0.0F;  M(1,1) = y;     M(1,2) = b;      M(1,3) = 0.0F;
M(2,0) = 0.0F;  M(2,1) = 0.0F;  M(2,2) = c;      M(2,3) = d;
M(3,0) = 0.0F;  M(3,1) = 0.0F;  M(3,2) = -1.0F;  M(3,3) = 0.0F;
#undef M
gl_MultMatrixf( ctx, m );
ctx->NearFarStack[ctx->ProjectionStackDepth][0] = nearval;
ctx->NearFarStack[ctx->ProjectionStackDepth][1] = farval;
if (ctx->Driver.NearFar) {
(*ctx->Driver.NearFar)( ctx, nearval, farval );
}
}
void gl_Ortho( GLcontext *ctx,
GLdouble left, GLdouble right,
GLdouble bottom, GLdouble top,
GLdouble nearval, GLdouble farval )
{
float x, y, z;
float tx, ty, tz;
float m[16];
x = 2.0 / (right-left);
y = 2.0 / (top-bottom);
z = -2.0 / (farval-nearval);
tx = -(right+left) / (right-left);
ty = -(top+bottom) / (top-bottom);
tz = -(farval+nearval) / (farval-nearval);
#define M(row,col)  m[col*4+row]
M(0,0) = x;     M(0,1) = 0.0F;  M(0,2) = 0.0F;  M(0,3) = tx;
M(1,0) = 0.0F;  M(1,1) = y;     M(1,2) = 0.0F;  M(1,3) = ty;
M(2,0) = 0.0F;  M(2,1) = 0.0F;  M(2,2) = z;     M(2,3) = tz;
M(3,0) = 0.0F;  M(3,1) = 0.0F;  M(3,2) = 0.0F;  M(3,3) = 1.0F;
#undef M
gl_MultMatrixf( ctx, m );
if (ctx->Driver.NearFar) {
(*ctx->Driver.NearFar)( ctx, nearval, farval );
}
}
void gl_MatrixMode( GLcontext *ctx, GLenum mode )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx,  GL_INVALID_OPERATION, "glMatrixMode" );
return;
}
switch (mode) {
case GL_MODELVIEW:
case GL_PROJECTION:
case GL_TEXTURE:
ctx->Transform.MatrixMode = mode;
break;
default:
gl_error( ctx,  GL_INVALID_ENUM, "glMatrixMode" );
}
}
void gl_PushMatrix( GLcontext *ctx )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx,  GL_INVALID_OPERATION, "glPushMatrix" );
return;
}
switch (ctx->Transform.MatrixMode) {
case GL_MODELVIEW:
if (ctx->ModelViewStackDepth>=MAX_MODELVIEW_STACK_DEPTH-1) {
gl_error( ctx,  GL_STACK_OVERFLOW, "glPushMatrix");
return;
}
MEMCPY( ctx->ModelViewStack[ctx->ModelViewStackDepth],
ctx->ModelViewMatrix,
16*sizeof(float) );
ctx->ModelViewStackDepth++;
break;
case GL_PROJECTION:
if (ctx->ProjectionStackDepth>=MAX_PROJECTION_STACK_DEPTH) {
gl_error( ctx,  GL_STACK_OVERFLOW, "glPushMatrix");
return;
}
MEMCPY( ctx->ProjectionStack[ctx->ProjectionStackDepth],
ctx->ProjectionMatrix,
16*sizeof(float) );
ctx->ProjectionStackDepth++;
ctx->NearFarStack[ctx->ProjectionStackDepth][0]
= ctx->NearFarStack[ctx->ProjectionStackDepth-1][0];
ctx->NearFarStack[ctx->ProjectionStackDepth][1]
= ctx->NearFarStack[ctx->ProjectionStackDepth-1][1];
break;
case GL_TEXTURE:
if (ctx->TextureStackDepth>=MAX_TEXTURE_STACK_DEPTH) {
gl_error( ctx,  GL_STACK_OVERFLOW, "glPushMatrix");
return;
}
MEMCPY( ctx->TextureStack[ctx->TextureStackDepth],
ctx->TextureMatrix,
16*sizeof(float) );
ctx->TextureStackDepth++;
break;
default:
gl_problem(ctx, "Bad matrix mode in gl_PushMatrix");
}
}
void gl_PopMatrix( GLcontext *ctx )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx,  GL_INVALID_OPERATION, "glPopMatrix" );
return;
}
switch (ctx->Transform.MatrixMode) {
case GL_MODELVIEW:
if (ctx->ModelViewStackDepth==0) {
gl_error( ctx,  GL_STACK_UNDERFLOW, "glPopMatrix");
return;
}
ctx->ModelViewStackDepth--;
MEMCPY( ctx->ModelViewMatrix,
ctx->ModelViewStack[ctx->ModelViewStackDepth],
16*sizeof(float) );
ctx->NewModelViewMatrix = GL_TRUE;
break;
case GL_PROJECTION:
if (ctx->ProjectionStackDepth==0) {
gl_error( ctx,  GL_STACK_UNDERFLOW, "glPopMatrix");
return;
}
ctx->ProjectionStackDepth--;
MEMCPY( ctx->ProjectionMatrix,
ctx->ProjectionStack[ctx->ProjectionStackDepth],
16*sizeof(float) );
ctx->NewProjectionMatrix = GL_TRUE;
{
float nearVal = ctx->NearFarStack[ctx->ProjectionStackDepth][0];
float farVal  = ctx->NearFarStack[ctx->ProjectionStackDepth][1];
if (ctx->Driver.NearFar) {
(*ctx->Driver.NearFar)( ctx, nearVal, farVal );
}
}
break;
case GL_TEXTURE:
if (ctx->TextureStackDepth==0) {
gl_error( ctx,  GL_STACK_UNDERFLOW, "glPopMatrix");
return;
}
ctx->TextureStackDepth--;
MEMCPY( ctx->TextureMatrix,
ctx->TextureStack[ctx->TextureStackDepth],
16*sizeof(float) );
ctx->NewTextureMatrix = GL_TRUE;
break;
default:
gl_problem(ctx, "Bad matrix mode in gl_PopMatrix");
}
}
void gl_LoadIdentity( GLcontext *ctx )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx,  GL_INVALID_OPERATION, "glLoadIdentity" );
return;
}
switch (ctx->Transform.MatrixMode) {
case GL_MODELVIEW:
MEMCPY( ctx->ModelViewMatrix, Identity, 16*sizeof(float) );
MEMCPY( ctx->ModelViewInv, Identity, 16*sizeof(float) );
ctx->ModelViewMatrixType = MATRIX_IDENTITY;
	 ctx->NewModelViewMatrix = GL_FALSE;
	 break;
case GL_PROJECTION:
	 MEMCPY( ctx->ProjectionMatrix, Identity, 16*sizeof(float) );
ctx->ProjectionMatrixType = MATRIX_IDENTITY;
	 ctx->NewProjectionMatrix = GL_FALSE;
	 break;
case GL_TEXTURE:
	 MEMCPY( ctx->TextureMatrix, Identity, 16*sizeof(float) );
ctx->TextureMatrixType = MATRIX_IDENTITY;
	 ctx->NewTextureMatrix = GL_FALSE;
	 break;
default:
gl_problem(ctx, "Bad matrix mode in gl_LoadIdentity");
}
}
void gl_LoadMatrixf( GLcontext *ctx, const float *m )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx,  GL_INVALID_OPERATION, "glLoadMatrix" );
return;
}
switch (ctx->Transform.MatrixMode) {
case GL_MODELVIEW:
MEMCPY( ctx->ModelViewMatrix, m, 16*sizeof(float) );
	 ctx->NewModelViewMatrix = GL_TRUE;
	 break;
case GL_PROJECTION:
	 MEMCPY( ctx->ProjectionMatrix, m, 16*sizeof(float) );
	 ctx->NewProjectionMatrix = GL_TRUE;
	 break;
case GL_TEXTURE:
	 MEMCPY( ctx->TextureMatrix, m, 16*sizeof(float) );
	 ctx->NewTextureMatrix = GL_TRUE;
	 break;
default:
gl_problem(ctx, "Bad matrix mode in gl_LoadMatrixf");
}
}
void gl_MultMatrixf( GLcontext *ctx, const float *m )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx,  GL_INVALID_OPERATION, "glMultMatrix" );
return;
}
switch (ctx->Transform.MatrixMode) {
case GL_MODELVIEW:
matmul( ctx->ModelViewMatrix, ctx->ModelViewMatrix, m );
	 ctx->NewModelViewMatrix = GL_TRUE;
	 break;
case GL_PROJECTION:
	 matmul( ctx->ProjectionMatrix, ctx->ProjectionMatrix, m );
	 ctx->NewProjectionMatrix = GL_TRUE;
	 break;
case GL_TEXTURE:
	 matmul( ctx->TextureMatrix, ctx->TextureMatrix, m );
	 ctx->NewTextureMatrix = GL_TRUE;
	 break;
default:
gl_problem(ctx, "Bad matrix mode in gl_MultMatrixf");
}
}
void gl_rotation_matrix( float angle, float x, float y, float z,
float m[] )
{
float mag, s, c;
float xx, yy, zz, xy, yz, zx, xs, ys, zs, one_c;
s = sin( angle * DEG2RAD );
c = cos( angle * DEG2RAD );
mag = GL_SQRT( x*x + y*y + z*z );
if (mag == 0.0) {
MEMCPY(m, Identity, sizeof(float)*16);
return;
}
x /= mag;
y /= mag;
z /= mag;
#define M(row,col)  m[col*4+row]
xx = x * x;
yy = y * y;
zz = z * z;
xy = x * y;
yz = y * z;
zx = z * x;
xs = x * s;
ys = y * s;
zs = z * s;
one_c = 1.0F - c;
M(0,0) = (one_c * xx) + c;
M(0,1) = (one_c * xy) - zs;
M(0,2) = (one_c * zx) + ys;
M(0,3) = 0.0F;
M(1,0) = (one_c * xy) + zs;
M(1,1) = (one_c * yy) + c;
M(1,2) = (one_c * yz) - xs;
M(1,3) = 0.0F;
M(2,0) = (one_c * zx) - ys;
M(2,1) = (one_c * yz) + xs;
M(2,2) = (one_c * zz) + c;
M(2,3) = 0.0F;
M(3,0) = 0.0F;
M(3,1) = 0.0F;
M(3,2) = 0.0F;
M(3,3) = 1.0F;
#undef M
}
void gl_Rotatef( GLcontext *ctx,
float angle, float x, float y, float z )
{
float m[16];
gl_rotation_matrix( angle, x, y, z, m );
gl_MultMatrixf( ctx, m );
}
void gl_Scalef( GLcontext *ctx, float x, float y, float z )
{
float *m;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx,  GL_INVALID_OPERATION, "glScale" );
return;
}
switch (ctx->Transform.MatrixMode) {
case GL_MODELVIEW:
m = ctx->ModelViewMatrix;
	 ctx->NewModelViewMatrix = GL_TRUE;
	 break;
case GL_PROJECTION:
m = ctx->ProjectionMatrix;
	 ctx->NewProjectionMatrix = GL_TRUE;
	 break;
case GL_TEXTURE:
m = ctx->TextureMatrix;
	 ctx->NewTextureMatrix = GL_TRUE;
	 break;
default:
gl_problem(ctx, "Bad matrix mode in gl_Scalef");
return;
}
m[0] *= x;   m[4] *= y;   m[8]  *= z;
m[1] *= x;   m[5] *= y;   m[9]  *= z;
m[2] *= x;   m[6] *= y;   m[10] *= z;
m[3] *= x;   m[7] *= y;   m[11] *= z;
}
void gl_Translatef( GLcontext *ctx, float x, float y, float z )
{
float *m;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glTranslate" );
return;
}
switch (ctx->Transform.MatrixMode) {
case GL_MODELVIEW:
m = ctx->ModelViewMatrix;
	 ctx->NewModelViewMatrix = GL_TRUE;
	 break;
case GL_PROJECTION:
m = ctx->ProjectionMatrix;
	 ctx->NewProjectionMatrix = GL_TRUE;
	 break;
case GL_TEXTURE:
m = ctx->TextureMatrix;
	 ctx->NewTextureMatrix = GL_TRUE;
	 break;
default:
gl_problem(ctx, "Bad matrix mode in gl_Translatef");
return;
}
m[12] = m[0] * x + m[4] * y + m[8]  * z + m[12];
m[13] = m[1] * x + m[5] * y + m[9]  * z + m[13];
m[14] = m[2] * x + m[6] * y + m[10] * z + m[14];
m[15] = m[3] * x + m[7] * y + m[11] * z + m[15];
}
void gl_Viewport( GLcontext *ctx,
GLint x, GLint y, GLsizei width, GLsizei height )
{
if (width<0 || height<0) {
gl_error( ctx,  GL_INVALID_VALUE, "glViewport" );
return;
}
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx,  GL_INVALID_OPERATION, "glViewport" );
return;
}
width  = CLAMP( width,  1, MAX_WIDTH );
height = CLAMP( height, 1, MAX_HEIGHT );
ctx->Viewport.X = x;
ctx->Viewport.Width = width;
ctx->Viewport.Y = y;
ctx->Viewport.Height = height;
ctx->Viewport.Sx = (float) width / 2.0F;
ctx->Viewport.Tx = ctx->Viewport.Sx + x;
ctx->Viewport.Sy = (float) height / 2.0F;
ctx->Viewport.Ty = ctx->Viewport.Sy + y;
ctx->NewState |= NEW_ALL;
gl_ResizeBuffersMESA(ctx);
}
/* 当前文件是D:\Read\misc.c*/

#ifdef PC_HEADER
#else
#endif
void gl_ClearIndex( GLcontext *ctx, float c )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glClearIndex" );
return;
}
ctx->Color.ClearIndex = (GLuint) c;
if (!ctx->Visual->RGBAflag) {
(*ctx->Driver.ClearIndex)( ctx, ctx->Color.ClearIndex );
}
}
void gl_ClearColor( GLcontext *ctx, GLclampf red, GLclampf green,
GLclampf blue, GLclampf alpha )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glClearColor" );
return;
}
ctx->Color.ClearColor[0] = CLAMP( red,   0.0F, 1.0F );
ctx->Color.ClearColor[1] = CLAMP( green, 0.0F, 1.0F );
ctx->Color.ClearColor[2] = CLAMP( blue,  0.0F, 1.0F );
ctx->Color.ClearColor[3] = CLAMP( alpha, 0.0F, 1.0F );
if (ctx->Visual->RGBAflag) {
GLubyte r = (GLint) (ctx->Color.ClearColor[0] * ctx->Visual->RedScale);
GLubyte g = (GLint) (ctx->Color.ClearColor[1] * ctx->Visual->GreenScale);
GLubyte b = (GLint) (ctx->Color.ClearColor[2] * ctx->Visual->BlueScale);
GLubyte a = (GLint) (ctx->Color.ClearColor[3] * ctx->Visual->AlphaScale);
(*ctx->Driver.ClearColor)( ctx, r, g, b, a );
}
}
static void clear_color_buffer_with_masking( GLcontext *ctx )
{
GLint x, y, height, width;
if (ctx->Scissor.Enabled) {
x = ctx->Buffer->Xmin;
y = ctx->Buffer->Ymin;
height = ctx->Buffer->Ymax - ctx->Buffer->Ymin + 1;
width  = ctx->Buffer->Xmax - ctx->Buffer->Xmin + 1;
}
else {
x = 0;
y = 0;
height = ctx->Buffer->Height;
width  = ctx->Buffer->Width;
}
if (ctx->Visual->RGBAflag) {
GLubyte red[MAX_WIDTH], green[MAX_WIDTH];
GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];
GLubyte r = ctx->Color.ClearColor[0] * ctx->Visual->RedScale;
GLubyte g = ctx->Color.ClearColor[1] * ctx->Visual->GreenScale;
GLubyte b = ctx->Color.ClearColor[2] * ctx->Visual->BlueScale;
GLubyte a = ctx->Color.ClearColor[3] * ctx->Visual->AlphaScale;
GLint i;
for (i=0;i<height;i++,y++) {
MEMSET( red,   (int) r, width );
MEMSET( green, (int) g, width );
MEMSET( blue,  (int) b, width );
MEMSET( alpha, (int) a, width );
gl_mask_color_span( ctx, width, x, y, red, green, blue, alpha );
(*ctx->Driver.WriteColorSpan)( ctx,
width, x, y, red, green, blue, alpha, NULL );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_write_alpha_span( ctx, width, x, y, alpha, NULL );
}
}
}
else {
GLuint indx[MAX_WIDTH];
GLubyte mask[MAX_WIDTH];
GLint i, j;
MEMSET( mask, 1, width );
for (i=0;i<height;i++,y++) {
for (j=0;j<width;j++) {
indx[j] = ctx->Color.ClearIndex;
}
gl_mask_index_span( ctx, width, x, y, indx );
(*ctx->Driver.WriteIndexSpan)( ctx, width, x, y, indx, mask );
}
}
}
static void clear_color_buffers( GLcontext *ctx )
{
if (ctx->Color.SWmasking) {
clear_color_buffer_with_masking( ctx );
}
else {
GLint x = ctx->Buffer->Xmin;
GLint y = ctx->Buffer->Ymin;
GLint height = ctx->Buffer->Ymax - ctx->Buffer->Ymin + 1;
GLint width  = ctx->Buffer->Xmax - ctx->Buffer->Xmin + 1;
(*ctx->Driver.Clear)( ctx, !ctx->Scissor.Enabled,
x, y, width, height );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_clear_alpha_buffers( ctx );
}
}
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
if (ctx->Color.SWmasking) {
clear_color_buffer_with_masking( ctx );
}
else {
GLint x = ctx->Buffer->Xmin;
GLint y = ctx->Buffer->Ymin;
GLint height = ctx->Buffer->Ymax - ctx->Buffer->Ymin + 1;
GLint width  = ctx->Buffer->Xmax - ctx->Buffer->Xmin + 1;
(*ctx->Driver.Clear)( ctx, !ctx->Scissor.Enabled,
x, y, width, height );
}
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
}
}
void gl_Clear( GLcontext *ctx, GLbitfield mask )
{
#ifdef PROFILE
GLdouble t0 = gl_time();
#endif
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glClear" );
return;
}
if (ctx->RenderMode==GL_RENDER) {
if (ctx->NewState) {
gl_update_state( ctx );
}
if (mask & GL_COLOR_BUFFER_BIT)   clear_color_buffers( ctx );
if (mask & GL_DEPTH_BUFFER_BIT)   (*ctx->Driver.ClearDepthBuffer)( ctx );
if (mask & GL_ACCUM_BUFFER_BIT)   gl_clear_accum_buffer( ctx );
if (mask & GL_STENCIL_BUFFER_BIT) gl_clear_stencil_buffer( ctx );
#ifdef PROFILE
ctx->ClearTime += gl_time() - t0;
ctx->ClearCount++;
#endif
}
}
const GLubyte *gl_GetString( GLcontext *ctx, GLenum name )
{
static char renderer[1000];
static char *vendor = "Brian Paul";
static char *version = "1.1 Mesa 2.5";
#ifdef FX
static char *extensions = "GL_EXT_blend_color GL_EXT_blend_minmax GL_EXT_blend_logic_op GL_EXT_blend_subtract GL_EXT_paletted_texture GL_EXT_point_parameters GL_EXT_polygon_offset GL_EXT_vertex_array GL_EXT_texture_object GL_EXT_texture3D GL_MESA_window_pos GL_MESA_resize_buffers GL_EXT_shared_texture_palette 3DFX_set_global_palette";
#else
static char *extensions = "GL_EXT_blend_color GL_EXT_blend_minmax GL_EXT_blend_logic_op GL_EXT_blend_subtract GL_EXT_paletted_texture GL_EXT_point_parameters GL_EXT_polygon_offset GL_EXT_vertex_array GL_EXT_texture_object GL_EXT_texture3D GL_MESA_window_pos GL_MESA_resize_buffers GL_EXT_shared_texture_palette";
#endif
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetString" );
return (GLubyte *) 0;
}
switch (name) {
case GL_VENDOR:
return (GLubyte *) vendor;
case GL_RENDERER:
strcpy(renderer, "Mesa");
if (ctx->Driver.RendererString) {
strcat(renderer, " ");
strcat(renderer, (*ctx->Driver.RendererString)());
}
return (GLubyte *) renderer;
case GL_VERSION:
return (GLubyte *) version;
case GL_EXTENSIONS:
return (GLubyte *) extensions;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetString" );
return (GLubyte *) 0;
}
}
void gl_Finish( GLcontext *ctx )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glFinish" );
return;
}
if (ctx->Driver.Finish) {
(*ctx->Driver.Finish)( ctx );
}
}
void gl_Flush( GLcontext *ctx )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glFlush" );
return;
}
if (ctx->Driver.Flush) {
(*ctx->Driver.Flush)( ctx );
}
}
void gl_Hint( GLcontext *ctx, GLenum target, GLenum mode )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glHint" );
return;
}
if (mode!=GL_DONT_CARE && mode!=GL_FASTEST && mode!=GL_NICEST) {
gl_error( ctx, GL_INVALID_ENUM, "glHint(mode)" );
return;
}
switch (target) {
case GL_FOG_HINT:
ctx->Hint.Fog = mode;
break;
case GL_LINE_SMOOTH_HINT:
ctx->Hint.LineSmooth = mode;
break;
case GL_PERSPECTIVE_CORRECTION_HINT:
ctx->Hint.PerspectiveCorrection = mode;
break;
case GL_POINT_SMOOTH_HINT:
ctx->Hint.PointSmooth = mode;
break;
case GL_POLYGON_SMOOTH_HINT:
ctx->Hint.PolygonSmooth = mode;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glHint(target)" );
}
ctx->NewState |= NEW_ALL;
}
void gl_DrawBuffer( GLcontext *ctx, GLenum mode )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glDrawBuffer" );
return;
}
switch (mode) {
case GL_FRONT:
case GL_FRONT_LEFT:
case GL_FRONT_AND_BACK:
if ( (*ctx->Driver.SetBuffer)( ctx, GL_FRONT ) == GL_FALSE ) {
gl_error( ctx, GL_INVALID_ENUM, "glDrawBuffer" );
return;
}
ctx->Color.DrawBuffer = mode;
ctx->Buffer->Alpha = ctx->Buffer->FrontAlpha;
	 ctx->NewState |= NEW_RASTER_OPS;
break;
case GL_BACK:
case GL_BACK_LEFT:
if ( (*ctx->Driver.SetBuffer)( ctx, GL_BACK ) == GL_FALSE) {
gl_error( ctx, GL_INVALID_ENUM, "glDrawBuffer" );
return;
}
ctx->Color.DrawBuffer = mode;
ctx->Buffer->Alpha = ctx->Buffer->BackAlpha;
	 ctx->NewState |= NEW_RASTER_OPS;
break;
case GL_NONE:
ctx->Color.DrawBuffer = mode;
ctx->Buffer->Alpha = NULL;
ctx->NewState |= NEW_RASTER_OPS;
break;
case GL_FRONT_RIGHT:
case GL_BACK_RIGHT:
case GL_LEFT:
case GL_RIGHT:
case GL_AUX0:
gl_error( ctx, GL_INVALID_OPERATION, "glDrawBuffer" );
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glDrawBuffer" );
}
}
void gl_ReadBuffer( GLcontext *ctx, GLenum mode )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glReadBuffer" );
return;
}
switch (mode) {
case GL_FRONT:
case GL_FRONT_LEFT:
if ( (*ctx->Driver.SetBuffer)( ctx, GL_FRONT ) == GL_FALSE) {
gl_error( ctx, GL_INVALID_ENUM, "glReadBuffer" );
return;
}
ctx->Pixel.ReadBuffer = mode;
ctx->Buffer->Alpha = ctx->Buffer->FrontAlpha;
ctx->NewState |= NEW_RASTER_OPS;
break;
case GL_BACK:
case GL_BACK_LEFT:
if ( (*ctx->Driver.SetBuffer)( ctx, GL_BACK ) == GL_FALSE) {
gl_error( ctx, GL_INVALID_ENUM, "glReadBuffer" );
return;
}
ctx->Pixel.ReadBuffer = mode;
ctx->Buffer->Alpha = ctx->Buffer->BackAlpha;
ctx->NewState |= NEW_RASTER_OPS;
break;
case GL_FRONT_RIGHT:
case GL_BACK_RIGHT:
case GL_LEFT:
case GL_RIGHT:
case GL_AUX0:
gl_error( ctx, GL_INVALID_OPERATION, "glReadBuffer" );
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glReadBuffer" );
}
(void) (*ctx->Driver.SetBuffer)( ctx, ctx->Color.DrawBuffer );
}
/* 当前文件是D:\Read\mmath.c*/

#ifdef PC_HEADER
#else
#endif
static short sqrttab[0x100];
static void init_sqrt(void)
{
#ifdef FAST_MATH
unsigned short i;
float f;
unsigned int *fi = (unsigned int *)&f;
for(i=0; i<= 0x7f; i++) {
*fi = 0;
*fi = (i << 16) | (127 << 23);
f = sqrt(f);
sqrttab[i] = (*fi & 0x7fffff) >> 16;
*fi = 0;
*fi = (i << 16) | (128 << 23);
f = sqrt(f);
sqrttab[i+0x80] = (*fi & 0x7fffff) >> 16;
}
#endif
}
float gl_sqrt( float x )
{
#ifdef FAST_MATH
unsigned int *num = (unsigned int *)&x;
short e;
if (x == 0.0F) return 0.0F;
e = (*num >> 23) - 127;
*num &= 0x7fffff;
if (e & 0x01) *num |= 0x800000;
e >>= 1;
*num = ((sqrttab[*num >> 16]) << 16) | ((e + 127) << 23);
return x;
#else
return sqrt(x);
#endif
}
void gl_init_math(void)
{
static GLboolean initialized = GL_FALSE;
if (!initialized) {
init_sqrt();
initialized = GL_TRUE;
}
}
/* 当前文件是D:\Read\osmesa.c*/

#ifdef PC_HEADER
#else
#endif

//#ifdef THREADS
//#else
static OSMesaContext Current = NULL;
//#endif
static void osmesa_setup_DD_pointers( GLcontext *ctx );
OSMesaContext OSMesaCreateContext( GLenum format, OSMesaContext sharelist )
{
OSMesaContext osmesa;
float rscale, gscale, bscale, ascale;
GLint rshift, gshift, bshift, ashift;
GLint rind, gind, bind;
GLint index_bits;
GLboolean rgbmode;
GLboolean swalpha;
GLuint i4 = 1;
GLubyte *i1 = (GLubyte *) &i4;
GLint little_endian = *i1;
swalpha = GL_FALSE;
rind = gind = bind = 0;
if (format==OSMESA_COLOR_INDEX) {
rscale = gscale = bscale = ascale = 0.0;
index_bits = 8;
rshift = gshift = bshift = ashift = 0;
rgbmode = GL_FALSE;
}
else if (format==OSMESA_RGBA) {
rscale = gscale = bscale = ascale = 255.0;
index_bits = 0;
if (little_endian) {
rshift = 0;
gshift = 8;
bshift = 16;
ashift = 24;
}
else {
rshift = 24;
gshift = 16;
bshift = 8;
ashift = 0;
}
rgbmode = GL_TRUE;
}
else if (format==OSMESA_BGRA) {
rscale = gscale = bscale = ascale = 255.0;
index_bits = 0;
if (little_endian) {
ashift = 0;
rshift = 8;
gshift = 16;
bshift = 24;
}
else {
bshift = 24;
gshift = 16;
rshift = 8;
ashift = 0;
}
rgbmode = GL_TRUE;
}
else if (format==OSMESA_ARGB) {
rscale = gscale = bscale = ascale = 255.0;
index_bits = 0;
if (little_endian) {
bshift = 0;
gshift = 8;
rshift = 16;
ashift = 24;
}
else {
ashift = 24;
rshift = 16;
gshift = 8;
bshift = 0;
}
rgbmode = GL_TRUE;
}
else if (format==OSMESA_RGB) {
rscale = gscale = bscale = ascale = 255.0;
index_bits = 0;
bshift = 0;
gshift = 8;
rshift = 16;
ashift = 24;
bind = 2;
gind = 1;
rind = 0;
rgbmode = GL_TRUE;
swalpha = GL_TRUE;
}
else if (format==OSMESA_BGR) {
rscale = gscale = bscale = ascale = 255.0;
index_bits = 0;
bshift = 0;
gshift = 8;
rshift = 16;
ashift = 24;
bind = 0;
gind = 1;
rind = 2;
rgbmode = GL_TRUE;
swalpha = GL_TRUE;
}
else {
return NULL;
}
osmesa = (OSMesaContext) calloc( 1, sizeof(struct osmesa_context) );
if (osmesa) {
osmesa->gl_visual = gl_create_visual( rgbmode,
					    swalpha,
GL_FALSE,	
DEPTH_BITS,
STENCIL_BITS,
ACCUM_BITS,
index_bits,
rscale, gscale, bscale, ascale,
8, 8, 8, 0 );
if (!osmesa->gl_visual) {
return NULL;
}
osmesa->gl_ctx = gl_create_context( osmesa->gl_visual,
sharelist ? sharelist->gl_ctx : NULL,
(void *) osmesa );
if (!osmesa->gl_ctx) {
gl_destroy_visual( osmesa->gl_visual );
free(osmesa);
return NULL;
}
osmesa->gl_buffer = gl_create_framebuffer( osmesa->gl_visual );
if (!osmesa->gl_buffer) {
gl_destroy_visual( osmesa->gl_visual );
gl_destroy_context( osmesa->gl_ctx );
free(osmesa);
return NULL;
}
osmesa->format = format;
osmesa->buffer = NULL;
osmesa->width = 0;
osmesa->height = 0;
osmesa->pixel = 0;
osmesa->clearpixel = 0;
osmesa->userRowLength = 0;
osmesa->rowlength = 0;
osmesa->yup = GL_TRUE;
osmesa->rshift = rshift;
osmesa->gshift = gshift;
osmesa->bshift = bshift;
osmesa->ashift = ashift;
osmesa->rind = rind;
osmesa->gind = gind;
osmesa->bind = bind;
}
return osmesa;
}
void OSMesaDestroyContext( OSMesaContext ctx )
{
if (ctx) {
gl_destroy_visual( ctx->gl_visual );
gl_destroy_framebuffer( ctx->gl_buffer );
gl_destroy_context( ctx->gl_ctx );
free( ctx );
}
}
static void compute_row_addresses( OSMesaContext ctx )
{
GLint i;
if (ctx->yup) {
if (ctx->format==OSMESA_COLOR_INDEX) {
GLubyte *origin = (GLubyte *) ctx->buffer;
for (i=0;i<MAX_HEIGHT;i++) {
ctx->rowaddr[i] = origin + i * ctx->rowlength;
}
}
else {
if ((ctx->format==OSMESA_RGB) || (ctx->format==OSMESA_BGR)) {
GLubyte *origin = (GLubyte *) ctx->buffer;
for (i=0;i<MAX_HEIGHT;i++) {
ctx->rowaddr[i] = origin + (i * (ctx->rowlength*3));
}
} else {
GLuint *origin = (GLuint *) ctx->buffer;
for (i=0;i<MAX_HEIGHT;i++) {
ctx->rowaddr[i] = origin + i * ctx->rowlength;
}
}
}
}
else {
if (ctx->format==OSMESA_COLOR_INDEX) {
GLubyte *origin = (GLubyte *) ctx->buffer;
for (i=0;i<MAX_HEIGHT;i++) {
ctx->rowaddr[i] = origin + (ctx->height-i-1) * ctx->rowlength;
}
}
else {
if ((ctx->format==OSMESA_RGB) || (ctx->format==OSMESA_BGR)) {
GLubyte *origin = (GLubyte *) ctx->buffer;
for (i=0;i<MAX_HEIGHT;i++) {
ctx->rowaddr[i] = origin + ((ctx->height-i-1) * (ctx->rowlength*3));
}
} else {
GLuint *origin = (GLuint *) ctx->buffer;
for (i=0;i<MAX_HEIGHT;i++) {
ctx->rowaddr[i] = origin + (ctx->height-i-1) * ctx->rowlength;
}
}
}
}
}
GLboolean OSMesaMakeCurrent( OSMesaContext ctx, void *buffer, GLenum type,
GLsizei width, GLsizei height )
{
if (!ctx || !buffer || type!=GL_UNSIGNED_BYTE
|| width<1 || height<1 || width>MAX_WIDTH || height>MAX_HEIGHT) {
return GL_FALSE;
}
gl_make_current( ctx->gl_ctx, ctx->gl_buffer );
ctx->buffer = buffer;
ctx->width = width;
ctx->height = height;
if (ctx->userRowLength)
ctx->rowlength = ctx->userRowLength;
else
ctx->rowlength = width;
osmesa_setup_DD_pointers( ctx->gl_ctx );
#ifdef THREADS
#else
Current = ctx;
#endif
compute_row_addresses( ctx );
if (ctx->gl_ctx->Viewport.Width==0) {
gl_Viewport( ctx->gl_ctx, 0, 0, width, height );
ctx->gl_ctx->Scissor.Width = width;
ctx->gl_ctx->Scissor.Height = height;
}
return GL_TRUE;
}
OSMesaContext OSMesaGetCurrentContext( void )
{
#ifdef THREADS
#else
return Current;
#endif
}
void OSMesaPixelStore( GLint pname, GLint value )
{
OSMesaContext ctx = OSMesaGetCurrentContext();
switch (pname) {
case OSMESA_ROW_LENGTH:
if (value<0) {
gl_error( ctx->gl_ctx, GL_INVALID_VALUE,
"OSMesaPixelStore(value)" );
return;
}
ctx->userRowLength = value;
ctx->rowlength = value;
break;
case OSMESA_Y_UP:
ctx->yup = value ? GL_TRUE : GL_FALSE;
break;
default:
gl_error( ctx->gl_ctx, GL_INVALID_ENUM, "OSMesaPixelStore(pname)" );
return;
}
compute_row_addresses( ctx );
}
void OSMesaGetIntegerv( GLint pname, GLint *value )
{
OSMesaContext ctx = OSMesaGetCurrentContext();
switch (pname) {
case OSMESA_WIDTH:
*value = ctx->width;
return;
case OSMESA_HEIGHT:
*value = ctx->height;
return;
case OSMESA_FORMAT:
*value = ctx->format;
return;
case OSMESA_TYPE:
*value = GL_UNSIGNED_BYTE;
return;
case OSMESA_ROW_LENGTH:
*value = ctx->rowlength;
return;
case OSMESA_Y_UP:
*value = ctx->yup;
return;
default:
gl_error( ctx->gl_ctx, GL_INVALID_ENUM, "OSMesaGetIntergerv(pname)" );
return;
}
}
GLboolean OSMesaGetDepthBuffer( OSMesaContext c, GLint *width, GLint *height,
GLint *bytesPerValue, void **buffer )
{
if ((!c->gl_buffer) || (!c->gl_buffer->Depth)) {
*width = 0;
*height = 0;
*bytesPerValue = 0;
*buffer = 0;
return GL_FALSE;
}
else {
*width = c->gl_buffer->Width;
*height = c->gl_buffer->Height;
*bytesPerValue = sizeof(GLdepth);
*buffer = c->gl_buffer->Depth;
return GL_TRUE;
}
}
#define PACK_RGBA(R,G,B,A)  (  ((R) << osmesa->rshift) \
| ((G) << osmesa->gshift) \
| ((B) << osmesa->bshift) \
| ((A) << osmesa->ashift) )
#define PACK_RGBA2(R,G,B,A)  (  ((R) << rshift) \
| ((G) << gshift) \
| ((B) << bshift) \
| ((A) << ashift) )
#define UNPACK_RED(P)      (((P) >> osmesa->rshift) & 0xff)
#define UNPACK_GREEN(P)    (((P) >> osmesa->gshift) & 0xff)
#define UNPACK_BLUE(P)     (((P) >> osmesa->bshift) & 0xff)
#define UNPACK_ALPHA(P)    (((P) >> osmesa->ashift) & 0xff)
#define PIXELADDR1(X,Y)  ((GLubyte *) osmesa->rowaddr[Y] + (X))
#define PIXELADDR3(X,Y)  ((GLubyte *) osmesa->rowaddr[Y] + ((X)*3))
#define PIXELADDR4(X,Y)  ((GLuint *)  osmesa->rowaddr[Y] + (X))
static GLboolean set_buffer( GLcontext *ctx, GLenum mode )
{
if (mode==GL_FRONT) {
return GL_TRUE;
}
else {
return GL_FALSE;
}
}
static void clear_index( GLcontext *ctx, GLuint index )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
osmesa->clearpixel = index;
}
static void clear_color( GLcontext *ctx,
GLubyte r, GLubyte g, GLubyte b, GLubyte a )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
osmesa->clearpixel = PACK_RGBA( r, g, b, a );
}
static void clear( GLcontext *ctx,
GLboolean all, GLint x, GLint y, GLint width, GLint height )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
if (osmesa->format==OSMESA_COLOR_INDEX) {
if (all) {
MEMSET(osmesa->buffer, osmesa->clearpixel, osmesa->rowlength*osmesa->height);
}
else {
GLuint i, j;
for (i=0;i<height;i++) {
GLubyte *ptr1 = PIXELADDR1( x, (y+i) );
for (j=0;j<width;j++) {
*ptr1++ = osmesa->clearpixel;
}
}
}
}
else if ((osmesa->format==OSMESA_RGB)||(osmesa->format==OSMESA_BGR)) {
GLubyte rval = UNPACK_RED(osmesa->clearpixel);
GLubyte gval = UNPACK_GREEN(osmesa->clearpixel);
GLubyte bval = UNPACK_BLUE(osmesa->clearpixel);
GLint   rind = osmesa->rind;
GLint   gind = osmesa->gind;
GLint   bind = osmesa->bind;
if (all) {
GLuint  i, n;
GLubyte *ptr3 = (GLubyte *) osmesa->buffer;
n = osmesa->rowlength * osmesa->height;
for (i=0;i<n;i++) {
ptr3[rind] = rval;
ptr3[gind] = gval;
ptr3[bind] = bval;
ptr3 += 3;
}
}
else {
GLuint i, j;
for (i=0;i<height;i++) {
GLubyte *ptr3 = PIXELADDR3( x, (y+i) );
for (j=0;j<width;j++) {
ptr3[rind] = rval;
ptr3[gind] = gval;
ptr3[bind] = bval;
ptr3 += 3;
}
}
}
}
else {
if (all) {
GLuint i, n, *ptr4;
n = osmesa->rowlength * osmesa->height;
ptr4 = (GLuint *) osmesa->buffer;
for (i=0;i<n;i++) {
*ptr4++ = osmesa->clearpixel;
}
}
else {
GLuint i, j;
for (i=0;i<height;i++) {
GLuint *ptr4 = PIXELADDR4( x, (y+i) );
for (j=0;j<width;j++) {
*ptr4++ = osmesa->clearpixel;
}
}
}
}
}
static void set_index( GLcontext *ctx, GLuint index )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
osmesa->pixel = index;
}
static void set_color( GLcontext *ctx,
GLubyte r, GLubyte g, GLubyte b, GLubyte a )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
osmesa->pixel = PACK_RGBA( r, g, b, a );
}
static void buffer_size( GLcontext *ctx, GLuint *width, GLuint *height )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
*width = osmesa->width;
*height = osmesa->height;
}
static void write_color_span( GLcontext *ctx,
GLuint n, GLint x, GLint y,
const GLubyte red[], const GLubyte green[],
			      const GLubyte blue[], const GLubyte alpha[],
			      const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint *ptr4 = PIXELADDR4( x, y );
GLuint i;
GLint rshift = osmesa->rshift;
GLint gshift = osmesa->gshift;
GLint bshift = osmesa->bshift;
GLint ashift = osmesa->ashift;
if (mask) {
for (i=0;i<n;i++,ptr4++) {
if (mask[i]) {
*ptr4 = PACK_RGBA2( red[i], green[i], blue[i], alpha[i] );
}
}
}
else {
for (i=0;i<n;i++,ptr4++) {
*ptr4 = PACK_RGBA2( red[i], green[i], blue[i], alpha[i] );
}
}
}
static void write_monocolor_span( GLcontext *ctx,
GLuint n, GLint x, GLint y,
				  const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint *ptr4 = PIXELADDR4(x,y);
GLuint i;
for (i=0;i<n;i++,ptr4++) {
if (mask[i]) {
*ptr4 = osmesa->pixel;
}
}
}
static void write_color_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
const GLubyte red[], const GLubyte green[],
			        const GLubyte blue[], const GLubyte alpha[],
			        const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
GLint rshift = osmesa->rshift;
GLint gshift = osmesa->gshift;
GLint bshift = osmesa->bshift;
GLint ashift = osmesa->ashift;
for (i=0;i<n;i++) {
if (mask[i]) {
GLuint *ptr4 = PIXELADDR4(x[i],y[i]);
*ptr4 = PACK_RGBA2( red[i], green[i], blue[i], alpha[i] );
}
}
}
static void write_monocolor_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
				    const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
for (i=0;i<n;i++) {
if (mask[i]) {
GLuint *ptr4 = PIXELADDR4(x[i],y[i]);
*ptr4 = osmesa->pixel;
}
}
}
static void write_index_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, const GLuint index[],
			      const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLubyte *ptr1 = PIXELADDR1(x,y);
GLuint i;
for (i=0;i<n;i++,ptr1++) {
if (mask[i]) {
*ptr1 = (GLubyte) index[i];
}
}
}
static void write_monoindex_span( GLcontext *ctx,
GLuint n, GLint x, GLint y,
				  const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLubyte *ptr1 = PIXELADDR1(x,y);
GLuint i;
for (i=0;i<n;i++,ptr1++) {
if (mask[i]) {
*ptr1 = (GLubyte) osmesa->pixel;
}
}
}
static void write_index_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
			        const GLuint index[], const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
for (i=0;i<n;i++) {
if (mask[i]) {
GLubyte *ptr1 = PIXELADDR1(x[i],y[i]);
*ptr1 = (GLubyte) index[i];
}
}
}
static void write_monoindex_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
				    const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
for (i=0;i<n;i++) {
if (mask[i]) {
GLubyte *ptr1 = PIXELADDR1(x[i],y[i]);
*ptr1 = (GLubyte) osmesa->pixel;
}
}
}
static void read_index_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLuint index[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
GLubyte *ptr1 = PIXELADDR1(x,y);
for (i=0;i<n;i++,ptr1++) {
index[i] = (GLuint) *ptr1;
}
}
static void read_color_span( GLcontext *ctx,
GLuint n, GLint x, GLint y,
GLubyte red[], GLubyte green[],
			     GLubyte blue[], GLubyte alpha[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
GLuint *ptr4 = PIXELADDR4(x,y);
for (i=0;i<n;i++) {
GLuint pixel = *ptr4++;
red[i]   = UNPACK_RED(pixel);
green[i] = UNPACK_GREEN(pixel);
blue[i]  = UNPACK_BLUE(pixel);
alpha[i] = UNPACK_ALPHA(pixel);
}
}
static void read_index_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
			       GLuint index[], const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
for (i=0;i<n;i++) {
if (mask[i] ) {
GLubyte *ptr1 = PIXELADDR1(x[i],y[i]);
index[i] = (GLuint) *ptr1;
}
}
}
static void read_color_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
			       GLubyte red[], GLubyte green[],
			       GLubyte blue[], GLubyte alpha[],
const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
for (i=0;i<n;i++) {
if (mask[i]) {
GLuint *ptr4 = PIXELADDR4(x[i],y[i]);
GLuint pixel = *ptr4;
red[i]   = UNPACK_RED(pixel);
green[i] = UNPACK_GREEN(pixel);
blue[i]  = UNPACK_BLUE(pixel);
alpha[i] = UNPACK_ALPHA(pixel);
}
}
}
static void write_color_span3( GLcontext *ctx,
GLuint n, GLint x, GLint y,
const GLubyte red[], const GLubyte green[],
			      const GLubyte blue[], const GLubyte alpha[],
			      const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLubyte *ptr3 = PIXELADDR3( x, y);
GLuint i;
GLint rind = osmesa->rind;
GLint gind = osmesa->gind;
GLint bind = osmesa->bind;
if (mask) {
for (i=0;i<n;i++,ptr3+=3) {
if (mask[i]) {
ptr3[rind] = red[i];
ptr3[gind] = green[i];
ptr3[bind] = blue[i];
}
}
}
else {
for (i=0;i<n;i++,ptr3+=3) {
ptr3[rind] = red[i];
ptr3[gind] = green[i];
ptr3[bind] = blue[i];
}
}
}
static void write_monocolor_span3( GLcontext *ctx,
GLuint n, GLint x, GLint y,
				  const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLubyte rval = UNPACK_RED(osmesa->pixel);
GLubyte gval = UNPACK_GREEN(osmesa->pixel);
GLubyte bval = UNPACK_BLUE(osmesa->pixel);
GLint   rind = osmesa->rind;
GLint   gind = osmesa->gind;
GLint   bind = osmesa->bind;
GLubyte *ptr3 = PIXELADDR3( x, y);
GLuint i;
for (i=0;i<n;i++,ptr3+=3) {
if (mask[i]) {
ptr3[rind] = rval;
ptr3[gind] = gval;
ptr3[bind] = bval;
}
}
}
static void write_color_pixels3( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
const GLubyte red[], const GLubyte green[],
			        const GLubyte blue[], const GLubyte alpha[],
			        const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
GLint rind = osmesa->rind;
GLint gind = osmesa->gind;
GLint bind = osmesa->bind;
for (i=0;i<n;i++) {
if (mask[i]) {
GLubyte *ptr3 = PIXELADDR3(x[i],y[i]);
ptr3[rind] = red[i];
ptr3[gind] = green[i];
ptr3[bind] = blue[i];
}
}
}
static void write_monocolor_pixels3( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
				    const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
GLint rind = osmesa->rind;
GLint gind = osmesa->gind;
GLint bind = osmesa->bind;
GLubyte rval = UNPACK_RED(osmesa->pixel);
GLubyte gval = UNPACK_GREEN(osmesa->pixel);
GLubyte bval = UNPACK_BLUE(osmesa->pixel);
for (i=0;i<n;i++) {
if (mask[i]) {
GLubyte *ptr3 = PIXELADDR3(x[i],y[i]);
ptr3[rind] = rval;
ptr3[gind] = gval;
ptr3[bind] = bval;
}
}
}
static void read_color_span3( GLcontext *ctx,
GLuint n, GLint x, GLint y,
GLubyte red[], GLubyte green[],
			     GLubyte blue[], GLubyte alpha[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
GLint rind = osmesa->rind;
GLint gind = osmesa->gind;
GLint bind = osmesa->bind;
GLubyte *ptr3 = PIXELADDR3( x, y);
for (i=0;i<n;i++,ptr3+=3) {
red[i]   = ptr3[rind];
green[i] = ptr3[gind];
blue[i]  = ptr3[bind];
alpha[i] = 0;
}
}
static void read_color_pixels3( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
			       GLubyte red[], GLubyte green[],
			       GLubyte blue[], GLubyte alpha[],
const GLubyte mask[] )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLuint i;
GLint rind = osmesa->rind;
GLint gind = osmesa->gind;
GLint bind = osmesa->bind;
for (i=0;i<n;i++) {
if (mask[i]) {
GLubyte *ptr3 = PIXELADDR3(x[i],y[i]);
red[i]   = ptr3[rind];
green[i] = ptr3[gind];
blue[i]  = ptr3[bind];
alpha[i] = 0;
}
}
}
static void flat_color_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLubyte *color = ctx->VB->Color[pvert];
unsigned long pixel = PACK_RGBA( color[0], color[1], color[2], color[3] );
#define INTERP_XY 1
#define CLIP_HACK 1
#define PLOT(X,Y) { GLuint *ptr4 = PIXELADDR4(X,Y); *ptr4 = pixel; }
}
static void flat_color_z_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLubyte *color = ctx->VB->Color[pvert];
unsigned long pixel = PACK_RGBA( color[0], color[1], color[2], color[3] );
#define INTERP_XY 1
#define INTERP_Z 1
#define CLIP_HACK 1
#define PLOT(X,Y)				\
	if (Z < *zPtr) {			\
	   GLuint *ptr4 = PIXELADDR4(X,Y);	\
	   *ptr4 = pixel;			\
	   *zPtr = Z;				\
	}
}
static void flat_blend_color_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
struct vertex_buffer *VB = ctx->VB;
GLint rshift = osmesa->rshift;
GLint gshift = osmesa->gshift;
GLint bshift = osmesa->bshift;
GLint avalue = VB->Color[pvert][3];
GLint msavalue = 255 - avalue;
GLint rvalue = VB->Color[pvert][0]*avalue;
GLint gvalue = VB->Color[pvert][1]*avalue;
GLint bvalue = VB->Color[pvert][2]*avalue;
#define INTERP_XY 1
#define CLIP_HACK 1
#define PLOT(X,Y)					\
{ GLuint *ptr4 = PIXELADDR4(X,Y); \
GLuint  pixel = 0; \
pixel |=((((((*ptr4) >> rshift) & 0xff)*msavalue+rvalue)>>8) << rshift);\
pixel |=((((((*ptr4) >> gshift) & 0xff)*msavalue+gvalue)>>8) << gshift);\
pixel |=((((((*ptr4) >> bshift) & 0xff)*msavalue+bvalue)>>8) << bshift);\
*ptr4 = pixel; \
}
}
static void flat_blend_color_z_line( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
struct vertex_buffer *VB = ctx->VB;
GLint rshift = osmesa->rshift;
GLint gshift = osmesa->gshift;
GLint bshift = osmesa->bshift;
GLint avalue = VB->Color[pvert][3];
GLint msavalue = 256 - avalue;
GLint rvalue = VB->Color[pvert][0]*avalue;
GLint gvalue = VB->Color[pvert][1]*avalue;
GLint bvalue = VB->Color[pvert][2]*avalue;
#define INTERP_XY 1
#define INTERP_Z 1
#define CLIP_HACK 1
#define PLOT(X,Y)				\
	if (Z < *zPtr) {			\
{ GLuint *ptr4 = PIXELADDR4(X,Y); \
GLuint  pixel = 0; \
pixel |=((((((*ptr4) >> rshift) & 0xff)*msavalue+rvalue)>>8) << rshift);\
pixel |=((((((*ptr4) >> gshift) & 0xff)*msavalue+gvalue)>>8) << gshift);\
pixel |=((((((*ptr4) >> bshift) & 0xff)*msavalue+bvalue)>>8) << bshift);\
*ptr4 = pixel; \
} \
	}
}
static void flat_blend_color_z_line_write( GLcontext *ctx,
GLuint vert0, GLuint vert1, GLuint pvert )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
struct vertex_buffer *VB = ctx->VB;
GLint rshift = osmesa->rshift;
GLint gshift = osmesa->gshift;
GLint bshift = osmesa->bshift;
GLint avalue = VB->Color[pvert][3];
GLint msavalue = 256 - avalue;
GLint rvalue = VB->Color[pvert][0]*avalue;
GLint gvalue = VB->Color[pvert][1]*avalue;
GLint bvalue = VB->Color[pvert][2]*avalue;
#define INTERP_XY 1
#define INTERP_Z 1
#define CLIP_HACK 1
#define PLOT(X,Y)				\
	if (Z < *zPtr) {			\
{ GLuint *ptr4 = PIXELADDR4(X,Y); \
GLuint  pixel = 0; \
pixel |=((((((*ptr4) >> rshift) & 0xff)*msavalue+rvalue)>>8) << rshift);\
pixel |=((((((*ptr4) >> gshift) & 0xff)*msavalue+gvalue)>>8) << gshift);\
pixel |=((((((*ptr4) >> bshift) & 0xff)*msavalue+bvalue)>>8) << bshift);\
*ptr4 = pixel; \
} \
	   *zPtr = Z;				\
	}
}
static line_func choose_line_function( GLcontext *ctx )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
if (ctx->Line.SmoothFlag)              return NULL;
if (ctx->Texture.Enabled)              return NULL;
if (ctx->Light.ShadeModel!=GL_FLAT)    return NULL;
if (ctx->Line.Width==1.0F
&& ctx->Line.StippleFlag==GL_FALSE) {
if (ctx->RasterMask==DEPTH_BIT
&& ctx->Depth.Func==GL_LESS
&& ctx->Depth.Mask==GL_TRUE) {
switch(osmesa->format) {
		case OSMESA_RGBA:
		case OSMESA_BGRA:
		case OSMESA_ARGB:
			return flat_color_z_line;
			break;
		default:
			return NULL;
			break;
}
}
if (ctx->RasterMask==0) {
switch(osmesa->format) {
		case OSMESA_RGBA:
		case OSMESA_BGRA:
		case OSMESA_ARGB:
			return flat_color_line;
			break;
		default:
			return NULL;
			break;
}
}
if (ctx->RasterMask==(DEPTH_BIT|BLEND_BIT)
&& ctx->Depth.Func==GL_LESS
&& ctx->Depth.Mask==GL_TRUE
&& ctx->Color.BlendSrc==GL_SRC_ALPHA
&& ctx->Color.BlendDst==GL_ONE_MINUS_SRC_ALPHA
&& ctx->Color.BlendEquation==GL_FUNC_ADD_EXT) {
switch(osmesa->format) {
		case OSMESA_RGBA:
		case OSMESA_BGRA:
		case OSMESA_ARGB:
			return flat_blend_color_z_line_write;
			break;
		default:
			return NULL;
			break;
}
}
if (ctx->RasterMask==(DEPTH_BIT|BLEND_BIT)
&& ctx->Depth.Func==GL_LESS
&& ctx->Depth.Mask==GL_FALSE
&& ctx->Color.BlendSrc==GL_SRC_ALPHA
&& ctx->Color.BlendDst==GL_ONE_MINUS_SRC_ALPHA
&& ctx->Color.BlendEquation==GL_FUNC_ADD_EXT) {
switch(osmesa->format) {
		case OSMESA_RGBA:
		case OSMESA_BGRA:
		case OSMESA_ARGB:
			return flat_blend_color_z_line;
			break;
		default:
			return NULL;
			break;
}
}
if (ctx->RasterMask==BLEND_BIT
&& ctx->Color.BlendSrc==GL_SRC_ALPHA
&& ctx->Color.BlendDst==GL_ONE_MINUS_SRC_ALPHA
&& ctx->Color.BlendEquation==GL_FUNC_ADD_EXT) {
switch(osmesa->format) {
		case OSMESA_RGBA:
		case OSMESA_BGRA:
		case OSMESA_ARGB:
			return flat_blend_color_line;
			break;
		default:
			return NULL;
			break;
}
}
}
return NULL;
}

static void smooth_color_z_triangle( GLcontext *ctx, GLuint v0, GLuint v1,
GLuint v2, GLuint pv )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
GLint rshift = osmesa->rshift;
GLint gshift = osmesa->gshift;
GLint bshift = osmesa->bshift;
GLint ashift = osmesa->ashift;
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INNER_LOOP( LEFT, RIGHT, Y )				\
{								\
GLint i, len = RIGHT-LEFT;					\
GLuint *img = PIXELADDR4(LEFT,Y);   				\
for (i=0;i<len;i++,img++) {					\
GLdepth z = FixedToDepth(ffz);				\
if (z < zRow[i]) {					\
*img = PACK_RGBA2( FixedToInt(ffr), FixedToInt(ffg),	\
		            FixedToInt(ffb), FixedToInt(ffa) );	\
zRow[i] = z;						\
}								\
ffr += fdrdx;  ffg += fdgdx;  ffb += fdbdx;  ffa += fdadx;\
ffz += fdzdx;						\
}								\
}
#define FIXED_H
//typedef int int;
#define FIXED_ONE       0x00000800
#define FIXED_HALF      0x00000400
#define FIXED_FRAC_MASK 0x000007FF
#define FIXED_INT_MASK  (~FIXED_FRAC_MASK)
#define FIXED_EPSILON   1
#define FIXED_SCALE     2048.0f
#define FIXED_SHIFT     11
#define FloatToFixed(X) ((int) ((X) * FIXED_SCALE))
#define IntToFixed(I)   ((I) << FIXED_SHIFT)
#define FixedToInt(X)   ((X) >> FIXED_SHIFT)
#define FixedToUns(X)   (((unsigned int)(X)) >> 11)
#define FixedCeil(X)    (((X) + FIXED_ONE - FIXED_EPSILON) & FIXED_INT_MASK)
#define FixedFloor(X)   ((X) & FIXED_INT_MASK)
#define FixedToFloat(X) ((X) * 0.00048828125f)
#define PosFloatToFixed(X)      FloatToFixed(X)
#define SignedFloatToFixed(X)   FloatToFixed(X)
#if DEPTH_BITS==16
#define FixedToDepth(I) ((I) >> FIXED_SHIFT)
#else
#define FixedToDepth(I) (I)
#endif
/* 当前文件是D:\Read\tritemp.h*/

//{
typedef struct {
    GLint v0, v1;
	float dx;	
	float dy;	
	int fdxdy;	
	int fsx;	
	int fsy;
	float adjy;	
	GLint lines;	
	int fx0;	
} EdgeT;
struct vertex_buffer *VB = ctx->VB;
EdgeT eMaj, eTop, eBot;
float oneOverArea;
int vMin, vMid, vMax;
//{
float y0 = VB->Win[v0][1];
float y1 = VB->Win[v1][1];
float y2 = VB->Win[v2][1];
if (y0<=y1) {
	 if (y1<=y2) {
	    vMin = v0;   vMid = v1;   vMax = v2;
	 }
	 else if (y2<=y0) {
	    vMin = v2;   vMid = v0;   vMax = v1;
	 }
	 else {
	    vMin = v0;   vMid = v2;   vMax = v1;
	 }
}
else {
	 if (y0<=y2) {
	    vMin = v1;   vMid = v0;   vMax = v2;
	 }
	 else if (y2<=y1) {
	    vMin = v2;   vMid = v1;   vMax = v0;
	 }
	 else {
	    vMin = v1;   vMid = v2;   vMax = v0;
	 }
}
//}
eMaj.v0 = vMin;   eMaj.v1 = vMax;
eTop.v0 = vMid;   eTop.v1 = vMax;
eBot.v0 = vMin;   eBot.v1 = vMid;
eMaj.dx = VB->Win[vMax][0] - VB->Win[vMin][0];
eMaj.dy = VB->Win[vMax][1] - VB->Win[vMin][1];
eTop.dx = VB->Win[vMax][0] - VB->Win[vMid][0];
eTop.dy = VB->Win[vMax][1] - VB->Win[vMid][1];
eBot.dx = VB->Win[vMid][0] - VB->Win[vMin][0];
eBot.dy = VB->Win[vMid][1] - VB->Win[vMin][1];
{
float area = eMaj.dx * eBot.dy - eBot.dx * eMaj.dy;
if (area>-0.05f && area<0.05f) {
return;
}
oneOverArea = 1.0F / area;
}
{
int vMin_fx = FloatToFixed(VB->Win[vMin][0] + 0.5F);
int vMin_fy = FloatToFixed(VB->Win[vMin][1] - 0.5F);
int vMid_fx = FloatToFixed(VB->Win[vMid][0] + 0.5F);
int vMid_fy = FloatToFixed(VB->Win[vMid][1] - 0.5F);
int vMax_fy = FloatToFixed(VB->Win[vMax][1] - 0.5F);
eMaj.fsy = FixedCeil(vMin_fy);
eMaj.lines = FixedToInt(vMax_fy + FIXED_ONE - FIXED_EPSILON - eMaj.fsy);
if (eMaj.lines > 0) {
float dxdy = eMaj.dx / eMaj.dy;
eMaj.fdxdy = SignedFloatToFixed(dxdy);
eMaj.adjy = (float) (eMaj.fsy - vMin_fy);
eMaj.fx0 = vMin_fx;
eMaj.fsx = eMaj.fx0 + (int) (eMaj.adjy * dxdy);
}
else {
return;
}
eTop.fsy = FixedCeil(vMid_fy);
eTop.lines = FixedToInt(vMax_fy + FIXED_ONE - FIXED_EPSILON - eTop.fsy);
if (eTop.lines > 0) {
float dxdy = eTop.dx / eTop.dy;
eTop.fdxdy = SignedFloatToFixed(dxdy);
eTop.adjy = (float) (eTop.fsy - vMid_fy);
eTop.fx0 = vMid_fx;
eTop.fsx = eTop.fx0 + (int) (eTop.adjy * dxdy);
}
eBot.fsy = FixedCeil(vMin_fy);
eBot.lines = FixedToInt(vMid_fy + FIXED_ONE - FIXED_EPSILON - eBot.fsy);
if (eBot.lines > 0) {
float dxdy = eBot.dx / eBot.dy;
eBot.fdxdy = SignedFloatToFixed(dxdy);
eBot.adjy = (float) (eBot.fsy - vMin_fy);
eBot.fx0 = vMin_fx;
eBot.fsx = eBot.fx0 + (int) (eBot.adjy * dxdy);
}
}
{
GLint ltor;		
#if INTERP_Z
float dzdx, dzdy;      int fdzdx;
#endif
#if INTERP_RGB
float drdx, drdy;      int fdrdx;
float dgdx, dgdy;      int fdgdx;
float dbdx, dbdy;      int fdbdx;
#endif
#if INTERP_ALPHA
float dadx, dady;      int fdadx;
#endif
#if INTERP_INDEX
float didx, didy;      int fdidx;
#endif
#if INTERP_ST
float dsdx, dsdy;      int fdsdx;
float dtdx, dtdy;      int fdtdx;
#endif
#if INTERP_STW
float dsdx, dsdy;
float dtdx, dtdy;
float dwdx, dwdy;
#endif
#if INTERP_UV
float dudx, dudy;
float dvdx, dvdy;
#endif
#ifdef SETUP_CODE
SETUP_CODE
#endif
ltor = (oneOverArea < 0.0F);
#if INTERP_Z
{
float eMaj_dz, eBot_dz;
eMaj_dz = VB->Win[vMax][2] - VB->Win[vMin][2];
eBot_dz = VB->Win[vMid][2] - VB->Win[vMin][2];
dzdx = oneOverArea * (eMaj_dz * eBot.dy - eMaj.dy * eBot_dz);
if (dzdx>DEPTH_SCALE || dzdx<-DEPTH_SCALE) {
dzdx = 0.0;
dzdy = 0.0;
}
else {
dzdy = oneOverArea * (eMaj.dx * eBot_dz - eMaj_dz * eBot.dx);
}
#if DEPTH_BITS==16
fdzdx = SignedFloatToFixed(dzdx);
#else
fdzdx = (GLint) dzdx;
#endif
}
#endif
#if INTERP_RGB
{
float eMaj_dr, eBot_dr;
eMaj_dr = (GLint) VB->Color[vMax][0] - (GLint) VB->Color[vMin][0];
eBot_dr = (GLint) VB->Color[vMid][0] - (GLint) VB->Color[vMin][0];
drdx = oneOverArea * (eMaj_dr * eBot.dy - eMaj.dy * eBot_dr);
fdrdx = SignedFloatToFixed(drdx);
drdy = oneOverArea * (eMaj.dx * eBot_dr - eMaj_dr * eBot.dx);
}
{
float eMaj_dg, eBot_dg;
eMaj_dg = (GLint) VB->Color[vMax][1] - (GLint) VB->Color[vMin][1];
	 eBot_dg = (GLint) VB->Color[vMid][1] - (GLint) VB->Color[vMin][1];
dgdx = oneOverArea * (eMaj_dg * eBot.dy - eMaj.dy * eBot_dg);
fdgdx = SignedFloatToFixed(dgdx);
dgdy = oneOverArea * (eMaj.dx * eBot_dg - eMaj_dg * eBot.dx);
}
{
float eMaj_db, eBot_db;
eMaj_db = (GLint) VB->Color[vMax][2] - (GLint) VB->Color[vMin][2];
eBot_db = (GLint) VB->Color[vMid][2] - (GLint) VB->Color[vMin][2];
dbdx = oneOverArea * (eMaj_db * eBot.dy - eMaj.dy * eBot_db);
fdbdx = SignedFloatToFixed(dbdx);
	 dbdy = oneOverArea * (eMaj.dx * eBot_db - eMaj_db * eBot.dx);
}
#endif
#if INTERP_ALPHA
{
float eMaj_da, eBot_da;
eMaj_da = (GLint) VB->Color[vMax][3] - (GLint) VB->Color[vMin][3];
eBot_da = (GLint) VB->Color[vMid][3] - (GLint) VB->Color[vMin][3];
dadx = oneOverArea * (eMaj_da * eBot.dy - eMaj.dy * eBot_da);
fdadx = SignedFloatToFixed(dadx);
dady = oneOverArea * (eMaj.dx * eBot_da - eMaj_da * eBot.dx);
}
#endif
#if INTERP_INDEX
{
float eMaj_di, eBot_di;
eMaj_di = (GLint) VB->Index[vMax] - (GLint) VB->Index[vMin];
eBot_di = (GLint) VB->Index[vMid] - (GLint) VB->Index[vMin];
didx = oneOverArea * (eMaj_di * eBot.dy - eMaj.dy * eBot_di);
fdidx = SignedFloatToFixed(didx);
didy = oneOverArea * (eMaj.dx * eBot_di - eMaj_di * eBot.dx);
}
#endif
#if INTERP_ST
{
float eMaj_ds, eBot_ds;
eMaj_ds = (VB->TexCoord[vMax][0] - VB->TexCoord[vMin][0]) * S_SCALE;
eBot_ds = (VB->TexCoord[vMid][0] - VB->TexCoord[vMin][0]) * S_SCALE;
dsdx = oneOverArea * (eMaj_ds * eBot.dy - eMaj.dy * eBot_ds);
fdsdx = SignedFloatToFixed(dsdx);
dsdy = oneOverArea * (eMaj.dx * eBot_ds - eMaj_ds * eBot.dx);
}
{
float eMaj_dt, eBot_dt;
eMaj_dt = (VB->TexCoord[vMax][1] - VB->TexCoord[vMin][1]) * T_SCALE;
eBot_dt = (VB->TexCoord[vMid][1] - VB->TexCoord[vMin][1]) * T_SCALE;
dtdx = oneOverArea * (eMaj_dt * eBot.dy - eMaj.dy * eBot_dt);
fdtdx = SignedFloatToFixed(dtdx);
dtdy = oneOverArea * (eMaj.dx * eBot_dt - eMaj_dt * eBot.dx);
}
#endif
#if INTERP_STW
{
float wMax = 1.0F / VB->Clip[vMax][3];
float wMin = 1.0F / VB->Clip[vMin][3];
float wMid = 1.0F / VB->Clip[vMid][3];
float eMaj_dw, eBot_dw;
float eMaj_ds, eBot_ds;
float eMaj_dt, eBot_dt;
#if INTERP_UV
float eMaj_du, eBot_du;
float eMaj_dv, eBot_dv;
#endif
eMaj_dw = wMax - wMin;
eBot_dw = wMid - wMin;
dwdx = oneOverArea * (eMaj_dw * eBot.dy - eMaj.dy * eBot_dw);
dwdy = oneOverArea * (eMaj.dx * eBot_dw - eMaj_dw * eBot.dx);
eMaj_ds = VB->TexCoord[vMax][0]*wMax - VB->TexCoord[vMin][0]*wMin;
eBot_ds = VB->TexCoord[vMid][0]*wMid - VB->TexCoord[vMin][0]*wMin;
dsdx = oneOverArea * (eMaj_ds * eBot.dy - eMaj.dy * eBot_ds);
dsdy = oneOverArea * (eMaj.dx * eBot_ds - eMaj_ds * eBot.dx);
eMaj_dt = VB->TexCoord[vMax][1]*wMax - VB->TexCoord[vMin][1]*wMin;
eBot_dt = VB->TexCoord[vMid][1]*wMid - VB->TexCoord[vMin][1]*wMin;
dtdx = oneOverArea * (eMaj_dt * eBot.dy - eMaj.dy * eBot_dt);
dtdy = oneOverArea * (eMaj.dx * eBot_dt - eMaj_dt * eBot.dx);
#if INTERP_UV
eMaj_du = VB->TexCoord[vMax][2]*wMax - VB->TexCoord[vMin][2]*wMin;
eBot_du = VB->TexCoord[vMid][2]*wMid - VB->TexCoord[vMin][2]*wMin;
dudx = oneOverArea * (eMaj_du * eBot.dy - eMaj.dy * eBot_du);
dudy = oneOverArea * (eMaj.dx * eBot_du - eMaj_du * eBot.dx);
eMaj_dv = VB->TexCoord[vMax][3] - VB->TexCoord[vMin][3];
eBot_dv = VB->TexCoord[vMid][3] - VB->TexCoord[vMin][3];
dvdx = oneOverArea * (eMaj_dv * eBot.dy - eMaj.dy * eBot_dv);
dvdy = oneOverArea * (eMaj.dx * eBot_dv - eMaj_dv * eBot.dx);
#endif
}
#endif
{
int subTriangle;
int fx, fxLeftEdge, fxRightEdge, fdxLeftEdge, fdxRightEdge;
int fdxOuter;
int idxOuter;
float dxOuter;
int fError, fdError;
float adjx, adjy;
int fy;
int iy;
#ifdef PIXEL_ADDRESS
PIXEL_TYPE *pRow;
int dPRowOuter, dPRowInner;
#endif
#if INTERP_Z
GLdepth *zRow;
int dZRowOuter, dZRowInner;
int fz, fdzOuter, fdzInner;
#endif
#if INTERP_RGB
int fr, fdrOuter, fdrInner;
int fg, fdgOuter, fdgInner;
int fb, fdbOuter, fdbInner;
#endif
#if INTERP_ALPHA
int fa, fdaOuter, fdaInner;
#endif
#if INTERP_INDEX
int fi, fdiOuter, fdiInner;
#endif
#if INTERP_ST
int fs, fdsOuter, fdsInner;
int ft, fdtOuter, fdtInner;
#endif
#if INTERP_STW
float sLeft, dsOuter, dsInner;
float tLeft, dtOuter, dtInner;
float wLeft, dwOuter, dwInner;
#endif
#if INTERP_UV
float uLeft, duOuter, duInner;
float vLeft, dvOuter, dvInner;
#endif
for (subTriangle=0; subTriangle<=1; subTriangle++) {
EdgeT *eLeft, *eRight;
int setupLeft, setupRight;
int lines;
if (subTriangle==0) {
if (ltor) {
eLeft = &eMaj;
eRight = &eBot;
lines = eRight->lines;
setupLeft = 1;
setupRight = 1;
}
else {
eLeft = &eBot;
eRight = &eMaj;
lines = eLeft->lines;
setupLeft = 1;
setupRight = 1;
}
}
else {
if (ltor) {
eLeft = &eMaj;
eRight = &eTop;
lines = eRight->lines;
setupLeft = 0;
setupRight = 1;
}
else {
eLeft = &eTop;
eRight = &eMaj;
lines = eLeft->lines;
setupLeft = 1;
setupRight = 0;
}
if (lines==0) return;
}
if (setupLeft && eLeft->lines>0) {
GLint vLower;
int fsx = eLeft->fsx;
fx = FixedCeil(fsx);
fError = fx - fsx - FIXED_ONE;
fxLeftEdge = fsx - FIXED_EPSILON;
fdxLeftEdge = eLeft->fdxdy;
fdxOuter = FixedFloor(fdxLeftEdge - FIXED_EPSILON);
fdError = fdxOuter - fdxLeftEdge + FIXED_ONE;
idxOuter = FixedToInt(fdxOuter);
dxOuter = (float) idxOuter;
fy = eLeft->fsy;
iy = FixedToInt(fy);
adjx = (float)(fx - eLeft->fx0);
adjy = eLeft->adjy;		
vLower = eLeft->v0;
#ifdef PIXEL_ADDRESS
{
pRow = PIXEL_ADDRESS( FixedToInt(fxLeftEdge), iy );
dPRowOuter = -BYTES_PER_ROW + idxOuter * sizeof(PIXEL_TYPE);
}
#endif
#if INTERP_Z
{
float z0, tmp;
z0 = VB->Win[vLower][2] + ctx->PolygonZoffset;
#if DEPTH_BITS==16
tmp = (z0 * FIXED_SCALE + dzdx * adjx + dzdy * adjy) + FIXED_HALF;
if (tmp < MAX_GLUINT/2)
fz = (int) tmp;
else
fz = MAX_GLUINT/2;
fdzOuter = SignedFloatToFixed(dzdy + dxOuter * dzdx);
#else
fz = (GLint) (z0 + dzdx*FixedToFloat(adjx) + dzdy*FixedToFloat(adjy));
fdzOuter = (GLint) (dzdy + dxOuter * dzdx);
#endif
zRow = Z_ADDRESS( ctx, FixedToInt(fxLeftEdge), iy );
dZRowOuter = (ctx->Buffer->Width + idxOuter) * sizeof(GLdepth);
}
#endif
#if INTERP_RGB
fr = (int)(IntToFixed(VB->Color[vLower][0]) + drdx * adjx + drdy * adjy)
+ FIXED_HALF;
fdrOuter = SignedFloatToFixed(drdy + dxOuter * drdx);
fg = (int)(IntToFixed(VB->Color[vLower][1]) + dgdx * adjx + dgdy * adjy)
+ FIXED_HALF;
fdgOuter = SignedFloatToFixed(dgdy + dxOuter * dgdx);
fb = (int)(IntToFixed(VB->Color[vLower][2]) + dbdx * adjx + dbdy * adjy)
+ FIXED_HALF;
fdbOuter = SignedFloatToFixed(dbdy + dxOuter * dbdx);
#endif
#if INTERP_ALPHA
fa = (int)(IntToFixed(VB->Color[vLower][3]) + dadx * adjx + dady * adjy)
+ FIXED_HALF;
fdaOuter = SignedFloatToFixed(dady + dxOuter * dadx);
#endif
#if INTERP_INDEX
fi = (int)(VB->Index[vLower] * FIXED_SCALE + didx * adjx
+ didy * adjy) + FIXED_HALF;
fdiOuter = SignedFloatToFixed(didy + dxOuter * didx);
#endif
#if INTERP_ST
{
float s0, t0;
s0 = VB->TexCoord[vLower][0] * S_SCALE;
fs = (int)(s0 * FIXED_SCALE + dsdx * adjx + dsdy * adjy) + FIXED_HALF;
fdsOuter = SignedFloatToFixed(dsdy + dxOuter * dsdx);
t0 = VB->TexCoord[vLower][1] * T_SCALE;
ft = (int)(t0 * FIXED_SCALE + dtdx * adjx + dtdy * adjy) + FIXED_HALF;
fdtOuter = SignedFloatToFixed(dtdy + dxOuter * dtdx);
}
#endif
#if INTERP_STW
{
float w0 = 1.0F / VB->Clip[vLower][3];
float s0, t0, u0, v0;
wLeft = w0 + (dwdx * adjx + dwdy * adjy) * (1.0F/FIXED_SCALE);
		  dwOuter = dwdy + dxOuter * dwdx;
s0 = VB->TexCoord[vLower][0] * w0;
sLeft = s0 + (dsdx * adjx + dsdy * adjy) * (1.0F/FIXED_SCALE);
dsOuter = dsdy + dxOuter * dsdx;
t0 = VB->TexCoord[vLower][1] * w0;
tLeft = t0 + (dtdx * adjx + dtdy * adjy) * (1.0F/FIXED_SCALE);
dtOuter = dtdy + dxOuter * dtdx;
#if INTERP_UV
u0 = VB->TexCoord[vLower][2] * w0;
uLeft = u0 + (dudx * adjx + dudy * adjy) * (1.0F/FIXED_SCALE);
duOuter = dudy + dxOuter * dudx;
v0 = VB->TexCoord[vLower][3];
vLeft = v0 + (dvdx * adjx + dvdy * adjy) * (1.0F/FIXED_SCALE);
dvOuter = dvdy + dxOuter * dvdx;
#endif
}
#endif
}
if (setupRight && eRight->lines>0) {
fxRightEdge = eRight->fsx - FIXED_EPSILON;
fdxRightEdge = eRight->fdxdy;
}
if (lines==0) {
continue;
}
#ifdef PIXEL_ADDRESS
dPRowInner = dPRowOuter + sizeof(PIXEL_TYPE);
#endif
#if INTERP_Z
dZRowInner = dZRowOuter + sizeof(GLdepth);
fdzInner = fdzOuter + fdzdx;
#endif
#if INTERP_RGB
fdrInner = fdrOuter + fdrdx;
fdgInner = fdgOuter + fdgdx;
fdbInner = fdbOuter + fdbdx;
#endif
#if INTERP_ALPHA
fdaInner = fdaOuter + fdadx;
#endif
#if INTERP_INDEX
fdiInner = fdiOuter + fdidx;
#endif
#if INTERP_ST
fdsInner = fdsOuter + fdsdx;
fdtInner = fdtOuter + fdtdx;
#endif
#if INTERP_STW
	    dwInner = dwOuter + dwdx;
	    dsInner = dsOuter + dsdx;
	    dtInner = dtOuter + dtdx;
#if INTERP_UV
	    duInner = duOuter + dudx;
	    dvInner = dvOuter + dvdx;
#endif
#endif
while (lines>0) {
#if INTERP_Z
int ffz = fz;
#endif
#if INTERP_RGB
int ffr = fr,  ffg = fg,  ffb = fb;
#endif
#if INTERP_ALPHA
int ffa = fa;
#endif
#if INTERP_INDEX
int ffi = fi;
#endif
#if INTERP_ST
int ffs = fs,  fft = ft;
#endif
#if INTERP_STW
float ss = sLeft,  tt = tLeft,  ww = wLeft;
#endif
#if INTERP_UV
float uu = uLeft,  vv = vLeft;
#endif
GLint left = FixedToInt(fxLeftEdge);
GLint right = FixedToInt(fxRightEdge);
#if INTERP_RGB
{
int ffrend = ffr+(right-left-1)*fdrdx;
int ffgend = ffg+(right-left-1)*fdgdx;
int ffbend = ffb+(right-left-1)*fdbdx;
if (ffrend<0) ffr -= ffrend;
if (ffgend<0) ffg -= ffgend;
if (ffbend<0) ffb -= ffbend;
if (ffr<0) ffr = 0;
if (ffg<0) ffg = 0;
if (ffb<0) ffb = 0;
}
#endif
#if INTERP_ALPHA
{
int ffaend = ffa+(right-left-1)*fdadx;
if (ffaend<0) ffa -= ffaend;
if (ffa<0) ffa = 0;
}
#endif
#if INTERP_INDEX
if (ffi<0) ffi = 0;
#endif
INNER_LOOP( left, right, iy );
iy++;
lines--;
fxLeftEdge += fdxLeftEdge;
fxRightEdge += fdxRightEdge;
fError += fdError;
if (fError >= 0) {
fError -= FIXED_ONE;
#ifdef PIXEL_ADDRESS
pRow = (PIXEL_TYPE*) ((GLubyte*)pRow + dPRowOuter);
#endif
#if INTERP_Z
zRow = (GLdepth*) ((GLubyte*)zRow + dZRowOuter);
fz += fdzOuter;
#endif
#if INTERP_RGB
fr += fdrOuter;   fg += fdgOuter;   fb += fdbOuter;
#endif
#if INTERP_ALPHA
fa += fdaOuter;
#endif
#if INTERP_INDEX
fi += fdiOuter;
#endif
#if INTERP_ST
fs += fdsOuter;   ft += fdtOuter;
#endif
#if INTERP_STW
		  sLeft += dsOuter;
		  tLeft += dtOuter;
		  wLeft += dwOuter;
#endif
#if INTERP_UV
		  uLeft += duOuter;
		  vLeft += dvOuter;
#endif
}
else {
#ifdef PIXEL_ADDRESS
pRow = (PIXEL_TYPE*) ((GLubyte*)pRow + dPRowInner);
#endif
#if INTERP_Z
zRow = (GLdepth*) ((GLubyte*)zRow + dZRowInner);
fz += fdzInner;
#endif
#if INTERP_RGB
fr += fdrInner;   fg += fdgInner;   fb += fdbInner;
#endif
#if INTERP_ALPHA
fa += fdaInner;
#endif
#if INTERP_INDEX
fi += fdiInner;
#endif
#if INTERP_ST
fs += fdsInner;   ft += fdtInner;
#endif
#if INTERP_STW
		  sLeft += dsInner;
		  tLeft += dtInner;
		  wLeft += dwInner;
#endif
#if INTERP_UV
		  uLeft += duInner;
		  vLeft += dvInner;
#endif
}
}
}
}
}
//}
#undef SETUP_CODE
#undef INNER_LOOP
#undef PIXEL_TYPE
#undef BYTES_PER_ROW
#undef PIXEL_ADDRESS
#undef INTERP_Z
#undef INTERP_RGB
#undef INTERP_ALPHA
#undef INTERP_INDEX
#undef INTERP_ST
#undef INTERP_STW
#undef INTERP_UV
#undef S_SCALE
#undef T_SCALE
}
static void flat_color_z_triangle( GLcontext *ctx, GLuint v0, GLuint v1,
GLuint v2, GLuint pv )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
#define INTERP_Z 1
#define SETUP_CODE			\
GLubyte r = VB->Color[pv][0];	\
GLubyte g = VB->Color[pv][1];	\
GLubyte b = VB->Color[pv][2];	\
GLubyte a = VB->Color[pv][3];	\
GLuint pixel = PACK_RGBA(r,g,b,a);
#define INNER_LOOP( LEFT, RIGHT, Y )	\
{					\
GLint i, len = RIGHT-LEFT;		\
GLuint *img = PIXELADDR4(LEFT,Y);   	\
for (i=0;i<len;i++,img++) {		\
GLdepth z = FixedToDepth(ffz);	\
if (z < zRow[i]) {		\
*img = pixel;			\
zRow[i] = z;			\
}					\
ffz += fdzdx;			\
}					\
}
}
static triangle_func choose_triangle_function( GLcontext *ctx )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
if ((osmesa->format==OSMESA_RGB)||(osmesa->format==OSMESA_BGR)) return NULL;
if (ctx->Polygon.SmoothFlag)     return NULL;
if (ctx->Polygon.StippleFlag)    return NULL;
if (ctx->Texture.Enabled)        return NULL;
if (ctx->RasterMask==DEPTH_BIT
&& ctx->Depth.Func==GL_LESS
&& ctx->Depth.Mask==GL_TRUE
&& osmesa->format!=OSMESA_COLOR_INDEX) {
if (ctx->Light.ShadeModel==GL_SMOOTH) {
return smooth_color_z_triangle;
}
else {
return flat_color_z_triangle;
}
}
return NULL;
}
static const char *renderer_string(void)
{
return "OffScreen";
}
static void osmesa_setup_DD_pointers( GLcontext *ctx )
{
OSMesaContext osmesa = (OSMesaContext) ctx->DriverCtx;
ctx->Driver.RendererString = renderer_string;
ctx->Driver.UpdateState = osmesa_setup_DD_pointers;
ctx->Driver.SetBuffer = set_buffer;
ctx->Driver.Color = set_color;
ctx->Driver.Index = set_index;
ctx->Driver.ClearIndex = clear_index;
ctx->Driver.ClearColor = clear_color;
ctx->Driver.Clear = clear;
ctx->Driver.GetBufferSize = buffer_size;
ctx->Driver.PointsFunc = NULL;
ctx->Driver.LineFunc = choose_line_function( ctx );
ctx->Driver.TriangleFunc = choose_triangle_function( ctx );
if ((osmesa->format==OSMESA_RGB) || (osmesa->format==OSMESA_BGR)) {
ctx->Driver.WriteColorSpan = write_color_span3;
ctx->Driver.WriteColorPixels = write_color_pixels3;
ctx->Driver.WriteMonocolorSpan = write_monocolor_span3;
ctx->Driver.WriteMonocolorPixels = write_monocolor_pixels3;
ctx->Driver.ReadColorSpan = read_color_span3;
ctx->Driver.ReadColorPixels = read_color_pixels3;
}
else {
ctx->Driver.WriteColorSpan = write_color_span;
ctx->Driver.WriteColorPixels = write_color_pixels;
ctx->Driver.WriteMonocolorSpan = write_monocolor_span;
ctx->Driver.WriteMonocolorPixels = write_monocolor_pixels;
ctx->Driver.ReadColorSpan = read_color_span;
ctx->Driver.ReadColorPixels = read_color_pixels;
}
ctx->Driver.WriteIndexSpan = write_index_span;
ctx->Driver.WriteMonoindexSpan = write_monoindex_span;
ctx->Driver.WriteIndexPixels = write_index_pixels;
ctx->Driver.WriteMonoindexPixels = write_monoindex_pixels;
ctx->Driver.ReadIndexSpan = read_index_span;
ctx->Driver.ReadIndexPixels = read_index_pixels;
}
/* 当前文件是D:\Read\pb.c*/

#ifdef PC_HEADER
#else
#endif
struct pixel_buffer *gl_alloc_pb(void)
{
struct pixel_buffer *pb;
pb = (struct pixel_buffer *) calloc(sizeof(struct pixel_buffer), 1);
if (pb) {
int i;
pb->primitive = GL_BITMAP;
for (i=0; i<PB_SIZE; i++) {
pb->lambda[i] = 0.0;
}
}
return pb;
}
void gl_flush_pb( GLcontext *ctx )
{
struct pixel_buffer* PB = ctx->PB;
DEFARRAY(GLubyte,mask,PB_SIZE);
DEFARRAY(GLubyte, rsave, PB_SIZE);
DEFARRAY(GLubyte, gsave, PB_SIZE);
DEFARRAY(GLubyte, bsave, PB_SIZE);
DEFARRAY(GLubyte, asave, PB_SIZE);
if (PB->count==0)  goto CleanUp;
{
GLint xmin = ctx->Buffer->Xmin;
GLint xmax = ctx->Buffer->Xmax;
GLint ymin = ctx->Buffer->Ymin;
GLint ymax = ctx->Buffer->Ymax;
GLint *x = PB->x;
GLint *y = PB->y;
GLuint i, n = PB->count;
for (i=0;i<n;i++) {
mask[i] = (x[i]>=xmin) & (x[i]<=xmax) & (y[i]>=ymin) & (y[i]<=ymax);
}
}
if (ctx->Visual->RGBAflag) {
if (PB->mono && ctx->MutablePixels) {
	
MEMSET( PB->r, PB->color[0], PB->count );
MEMSET( PB->g, PB->color[1], PB->count );
MEMSET( PB->b, PB->color[2], PB->count );
MEMSET( PB->a, PB->color[3], PB->count );
}
if (ctx->MutablePixels || !PB->mono) {
	 if (ctx->Texture.Enabled) {
	    gl_texture_pixels( ctx, PB->count, PB->s, PB->t, PB->u,
PB->lambda, PB->r, PB->g, PB->b, PB->a);
	 }
	 if (ctx->Fog.Enabled
&& (ctx->Hint.Fog==GL_NICEST || PB->primitive==GL_BITMAP
|| ctx->Texture.Enabled)) {
	    gl_fog_color_pixels( ctx, PB->count, PB->z,
				 PB->r, PB->g, PB->b, PB->a );
	 }
	 if (ctx->Color.AlphaEnabled) {
	    if (gl_alpha_test( ctx, PB->count, PB->a, mask )==0) {
	       goto CleanUp;
	    }
	 }
	 if (ctx->Stencil.Enabled) {
	
	    if (gl_stencil_pixels( ctx, PB->count, PB->x, PB->y, mask )==0) {
	       goto CleanUp;
	    }
	
	    gl_depth_stencil_pixels( ctx, PB->count, PB->x, PB->y, PB->z, mask );
	 }
	 else if (ctx->Depth.Test) {
	
	    (*ctx->Driver.DepthTestPixels)( ctx, PB->count, PB->x, PB->y, PB->z, mask );
	 }
if (ctx->RasterMask & NO_DRAW_BIT) {
goto CleanUp;
}
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
MEMCPY( rsave, PB->r, PB->count * sizeof(GLubyte) );
MEMCPY( gsave, PB->r, PB->count * sizeof(GLubyte) );
MEMCPY( bsave, PB->r, PB->count * sizeof(GLubyte) );
MEMCPY( asave, PB->r, PB->count * sizeof(GLubyte) );
}
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_rgba_pixels( ctx, PB->count, PB->x, PB->y,
PB->r, PB->g, PB->b, PB->a, mask);
}
else if (ctx->Color.BlendEnabled) {
gl_blend_pixels( ctx, PB->count, PB->x, PB->y,
PB->r, PB->g, PB->b, PB->a, mask);
}
if (ctx->Color.SWmasking) {
gl_mask_color_pixels( ctx, PB->count, PB->x, PB->y,
PB->r, PB->g, PB->b, PB->a, mask );
}
(*ctx->Driver.WriteColorPixels)( ctx, PB->count, PB->x, PB->y,
PB->r, PB->g, PB->b, PB->a, mask );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_write_alpha_pixels( ctx, PB->count, PB->x, PB->y, PB->a, mask );
}
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_rgba_pixels( ctx, PB->count, PB->x, PB->y,
PB->r, PB->g, PB->b, PB->a, mask);
}
else if (ctx->Color.BlendEnabled) {
gl_blend_pixels( ctx, PB->count, PB->x, PB->y,
rsave, gsave, bsave, asave, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_color_pixels( ctx, PB->count, PB->x, PB->y,
rsave, gsave, bsave, asave, mask);
}
(*ctx->Driver.WriteColorPixels)( ctx, PB->count, PB->x, PB->y,
rsave, gsave, bsave, asave, mask);
if (ctx->RasterMask & ALPHABUF_BIT) {
ctx->Buffer->Alpha = ctx->Buffer->BackAlpha;
gl_write_alpha_pixels( ctx, PB->count, PB->x, PB->y,
asave, mask );
ctx->Buffer->Alpha = ctx->Buffer->FrontAlpha;
}
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
}
}
else {
	
	 if (ctx->Color.AlphaEnabled) {
	    if (gl_alpha_test( ctx, PB->count, PB->a, mask )==0) {
	       goto CleanUp;
	    }
	 }
	 if (ctx->Stencil.Enabled) {
	
	    if (gl_stencil_pixels( ctx, PB->count, PB->x, PB->y, mask )==0) {
	       goto CleanUp;
	    }
	
	    gl_depth_stencil_pixels( ctx, PB->count, PB->x, PB->y, PB->z, mask );
	 }
	 else if (ctx->Depth.Test) {
	
	    (*ctx->Driver.DepthTestPixels)( ctx, PB->count, PB->x, PB->y, PB->z, mask );
	 }
if (ctx->RasterMask & NO_DRAW_BIT) {
goto CleanUp;
}
{
GLubyte red, green, blue, alpha;
red   = PB->color[0];
green = PB->color[1];
blue  = PB->color[2];
alpha = PB->color[3];
	    (*ctx->Driver.Color)( ctx, red, green, blue, alpha );
}
(*ctx->Driver.WriteMonocolorPixels)( ctx, PB->count, PB->x, PB->y, mask );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_write_mono_alpha_pixels( ctx, PB->count, PB->x, PB->y,
PB->color[3], mask );
}
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
(*ctx->Driver.WriteMonocolorPixels)( ctx, PB->count, PB->x, PB->y, mask );
if (ctx->RasterMask & ALPHABUF_BIT) {
ctx->Buffer->Alpha = ctx->Buffer->BackAlpha;
gl_write_mono_alpha_pixels( ctx, PB->count, PB->x, PB->y,
PB->color[3], mask );
ctx->Buffer->Alpha = ctx->Buffer->FrontAlpha;
}
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
	 }
}
}
else {
if (PB->mono && ctx->MutablePixels) {
	
GLuint n = PB->count, indx = PB->index;
GLuint *pbindex = PB->i;
do {
	    *pbindex++ = indx;
n--;
	 } while (n);
}
if (ctx->MutablePixels || !PB->mono) {
	
GLuint isave[PB_SIZE];
	 if (ctx->Fog.Enabled
&& (ctx->Hint.Fog==GL_NICEST || PB->primitive==GL_BITMAP)) {
	    gl_fog_index_pixels( ctx, PB->count, PB->z, PB->i );
	 }
	 if (ctx->Stencil.Enabled) {
	
	    if (gl_stencil_pixels( ctx, PB->count, PB->x, PB->y, mask )==0) {
	       goto CleanUp;
	    }
	
	    gl_depth_stencil_pixels( ctx, PB->count, PB->x, PB->y, PB->z, mask );
	 }
	 else if (ctx->Depth.Test) {
	
	    (*ctx->Driver.DepthTestPixels)( ctx, PB->count, PB->x, PB->y, PB->z, mask );
	 }
if (ctx->RasterMask & NO_DRAW_BIT) {
goto CleanUp;
}
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
MEMCPY( isave, PB->i, PB->count * sizeof(GLuint) );
}
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_ci_pixels( ctx, PB->count, PB->x, PB->y, PB->i, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_index_pixels( ctx, PB->count, PB->x, PB->y, PB->i, mask );
}
(*ctx->Driver.WriteIndexPixels)( ctx, PB->count, PB->x, PB->y,
PB->i, mask );
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
MEMCPY( PB->i, isave, PB->count * sizeof(GLuint) );
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_ci_pixels( ctx, PB->count, PB->x, PB->y, PB->i, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_index_pixels( ctx, PB->count, PB->x, PB->y,
PB->i, mask );
}
(*ctx->Driver.WriteIndexPixels)( ctx, PB->count, PB->x, PB->y,
PB->i, mask );
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
}
}
else {
	
	 if (ctx->Stencil.Enabled) {
	
	    if (gl_stencil_pixels( ctx, PB->count, PB->x, PB->y, mask )==0) {
	       goto CleanUp;
	    }
	
	    gl_depth_stencil_pixels( ctx, PB->count, PB->x, PB->y, PB->z, mask );
	 }
	 else if (ctx->Depth.Test) {
	
	    (*ctx->Driver.DepthTestPixels)( ctx, PB->count, PB->x, PB->y, PB->z, mask );
	 }
if (ctx->RasterMask & NO_DRAW_BIT) {
goto CleanUp;
}
(*ctx->Driver.Index)( ctx, PB->index );
(*ctx->Driver.WriteMonoindexPixels)( ctx, PB->count, PB->x, PB->y, mask );
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
(*ctx->Driver.WriteMonoindexPixels)( ctx, PB->count, PB->x, PB->y, mask );
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
}
}
}
CleanUp:
PB->count = 0;
UNDEFARRAY(mask);
UNDEFARRAY(rsave);
UNDEFARRAY(gsave);
UNDEFARRAY(bsave);
UNDEFARRAY(asave);
}
/* 当前文件是D:\Read\pixel.c*/

#ifdef PC_HEADER
#else
#endif
static void update_drawpixels_state( GLcontext *ctx )
{
if (ctx->Visual->RGBAflag==GL_TRUE &&
ctx->Visual->EightBitColor &&
ctx->Pixel.RedBias==0.0   && ctx->Pixel.RedScale==1.0 &&
ctx->Pixel.GreenBias==0.0 && ctx->Pixel.GreenScale==1.0 &&
ctx->Pixel.BlueBias==0.0  && ctx->Pixel.BlueScale==1.0 &&
ctx->Pixel.AlphaBias==0.0 && ctx->Pixel.AlphaScale==1.0 &&
ctx->Pixel.MapColorFlag==GL_FALSE &&
ctx->Pixel.ZoomX==1.0 && ctx->Pixel.ZoomY==1.0 &&
ctx->Unpack.RowLength==0 &&
ctx->Unpack.SkipPixels==0 &&
ctx->Unpack.SkipRows==0 &&
ctx->Unpack.SwapBytes==0 &&
ctx->Unpack.LsbFirst==0) {
ctx->FastDrawPixels = GL_TRUE;
}
else {
ctx->FastDrawPixels = GL_FALSE;
}
}
void gl_PixelZoom( GLcontext *ctx, float xfactor, float yfactor )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPixelZoom" );
return;
}
ctx->Pixel.ZoomX = xfactor;
ctx->Pixel.ZoomY = yfactor;
update_drawpixels_state( ctx );
}
void
gl_write_zoomed_color_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, const GLdepth z[],
const GLubyte red[], const GLubyte green[],
const GLubyte blue[], const GLubyte alpha[],
GLint y0 )
{
GLint m;
GLint r0, r1, row, r;
GLint i, j, skipcol;
GLubyte zred[MAX_WIDTH], zgreen[MAX_WIDTH];
GLubyte zblue[MAX_WIDTH], zalpha[MAX_WIDTH];
GLdepth zdepth[MAX_WIDTH];
GLint maxwidth = MIN2( ctx->Buffer->Width, MAX_WIDTH );
m = (GLint) ABSF( n * ctx->Pixel.ZoomX );
if (m==0) {
return;
}
if (ctx->Pixel.ZoomX<0.0) {
x = x - m;
}
row = y-y0;
r0 = y0 + (GLint) (row * ctx->Pixel.ZoomY);
r1 = y0 + (GLint) ((row+1) * ctx->Pixel.ZoomY);
if (r0==r1) {
return;
}
else if (r1<r0) {
GLint rtmp = r1;
r1 = r0;
r0 = rtmp;
}
if (r0<0 && r1<0) {
return;
}
if (r0>=ctx->Buffer->Height && r1>=ctx->Buffer->Height) {
return;
}
skipcol = 0;
if (x<0) {
skipcol = -x;
m += x;
}
if (m>maxwidth) {
m = maxwidth;
}
else if (m<=0) {
return;
}
assert( m <= MAX_WIDTH );
if (ctx->Pixel.ZoomX==-1.0F) {
for (j=0;j<m;j++) {
i = n - (j+skipcol) - 1;
zred[j]   = red[i];
zgreen[j] = green[i];
zblue[j]  = blue[i];
zalpha[j] = alpha[i];
zdepth[j] = z[i];
}
}
else {
float xscale = 1.0F / ctx->Pixel.ZoomX;
for (j=0;j<m;j++) {
i = (j+skipcol) * xscale;
if (i<0)  i = n + i - 1;
zred[j]   = red[i];
zgreen[j] = green[i];
zblue[j]  = blue[i];
zalpha[j] = alpha[i];
zdepth[j] = z[i];
}
}
for (r=r0; r<r1; r++) {
gl_write_color_span( ctx, m, x+skipcol, r, zdepth,
zred, zgreen, zblue, zalpha, GL_BITMAP );
}
}
void
gl_write_zoomed_index_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, const GLdepth z[],
const GLuint indexes[], GLint y0 )
{
GLint m;
GLint r0, r1, row, r;
GLint i, j, skipcol;
GLuint zindexes[MAX_WIDTH];
GLdepth zdepth[MAX_WIDTH];
GLint maxwidth = MIN2( ctx->Buffer->Width, MAX_WIDTH );
m = (GLint) ABSF( n * ctx->Pixel.ZoomX );
if (m==0) {
return;
}
if (ctx->Pixel.ZoomX<0.0) {
x = x - m;
}
row = y-y0;
r0 = y0 + (GLint) (row * ctx->Pixel.ZoomY);
r1 = y0 + (GLint) ((row+1) * ctx->Pixel.ZoomY);
if (r0==r1) {
return;
}
else if (r1<r0) {
GLint rtmp = r1;
r1 = r0;
r0 = rtmp;
}
if (r0<0 && r1<0) {
return;
}
if (r0>=ctx->Buffer->Height && r1>=ctx->Buffer->Height) {
return;
}
skipcol = 0;
if (x<0) {
skipcol = -x;
m += x;
}
if (m>maxwidth) {
m = maxwidth;
}
else if (m<=0) {
return;
}
assert( m <= MAX_WIDTH );
if (ctx->Pixel.ZoomX==-1.0F) {
for (j=0;j<m;j++) {
i = n - (j+skipcol) - 1;
zindexes[j] = indexes[i];
zdepth[j]   = z[i];
}
}
else {
float xscale = 1.0F / ctx->Pixel.ZoomX;
for (j=0;j<m;j++) {
i = (j+skipcol) * xscale;
if (i<0)  i = n + i - 1;
zindexes[j] = indexes[i];
zdepth[j] = z[i];
}
}
for (r=r0; r<r1; r++) {
gl_write_index_span( ctx, m, x+skipcol, r, zdepth, zindexes, GL_BITMAP );
}
}
void
gl_write_zoomed_stencil_span( GLcontext *ctx,
GLuint n, GLint x, GLint y,
const GLubyte stencil[], GLint y0 )
{
GLint m;
GLint r0, r1, row, r;
GLint i, j, skipcol;
GLubyte zstencil[MAX_WIDTH];
GLint maxwidth = MIN2( ctx->Buffer->Width, MAX_WIDTH );
m = (GLint) ABSF( n * ctx->Pixel.ZoomX );
if (m==0) {
return;
}
if (ctx->Pixel.ZoomX<0.0) {
x = x - m;
}
row = y-y0;
r0 = y0 + (GLint) (row * ctx->Pixel.ZoomY);
r1 = y0 + (GLint) ((row+1) * ctx->Pixel.ZoomY);
if (r0==r1) {
return;
}
else if (r1<r0) {
GLint rtmp = r1;
r1 = r0;
r0 = rtmp;
}
if (r0<0 && r1<0) {
return;
}
if (r0>=ctx->Buffer->Height && r1>=ctx->Buffer->Height) {
return;
}
skipcol = 0;
if (x<0) {
skipcol = -x;
m += x;
}
if (m>maxwidth) {
m = maxwidth;
}
else if (m<=0) {
return;
}
assert( m <= MAX_WIDTH );
if (ctx->Pixel.ZoomX==-1.0F) {
for (j=0;j<m;j++) {
i = n - (j+skipcol) - 1;
zstencil[j] = stencil[i];
}
}
else {
float xscale = 1.0F / ctx->Pixel.ZoomX;
for (j=0;j<m;j++) {
i = (j+skipcol) * xscale;
if (i<0)  i = n + i - 1;
zstencil[j] = stencil[i];
}
}
for (r=r0; r<r1; r++) {
gl_write_stencil_span( ctx, m, x+skipcol, r, zstencil );
}
}
void gl_PixelStorei( GLcontext *ctx, GLenum pname, GLint param )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPixelStore" );
return;
}
switch (pname) {
case GL_PACK_SWAP_BYTES:
ctx->Pack.SwapBytes = param ? GL_TRUE : GL_FALSE;
	 break;
case GL_PACK_LSB_FIRST:
ctx->Pack.LsbFirst = param ? GL_TRUE : GL_FALSE;
	 break;
case GL_PACK_ROW_LENGTH:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Pack.RowLength = param;
	 }
	 break;
case GL_PACK_SKIP_PIXELS:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Pack.SkipPixels = param;
	 }
	 break;
case GL_PACK_SKIP_ROWS:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Pack.SkipRows = param;
	 }
	 break;
case GL_PACK_ALIGNMENT:
if (param==1 || param==2 || param==4 || param==8) {
	    ctx->Pack.Alignment = param;
	 }
	 else {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 break;
case GL_UNPACK_SWAP_BYTES:
	 ctx->Unpack.SwapBytes = param ? GL_TRUE : GL_FALSE;
break;
case GL_UNPACK_LSB_FIRST:
	 ctx->Unpack.LsbFirst = param ? GL_TRUE : GL_FALSE;
	 break;
case GL_UNPACK_ROW_LENGTH:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Unpack.RowLength = param;
	 }
	 break;
case GL_UNPACK_SKIP_PIXELS:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Unpack.SkipPixels = param;
	 }
	 break;
case GL_UNPACK_SKIP_ROWS:
	 if (param<0) {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore(param)" );
	 }
	 else {
	    ctx->Unpack.SkipRows = param;
	 }
	 break;
case GL_UNPACK_ALIGNMENT:
if (param==1 || param==2 || param==4 || param==8) {
	    ctx->Unpack.Alignment = param;
	 }
	 else {
	    gl_error( ctx, GL_INVALID_VALUE, "glPixelStore" );
	 }
	 break;
default:
	 gl_error( ctx, GL_INVALID_ENUM, "glPixelStore" );
}
update_drawpixels_state( ctx );
}
void gl_PixelMapfv( GLcontext *ctx,
GLenum map, GLint mapsize, const float *values )
{
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPixelMapfv" );
return;
}
if (mapsize<0 || mapsize>MAX_PIXEL_MAP_TABLE) {
gl_error( ctx, GL_INVALID_VALUE, "glPixelMapfv(mapsize)" );
return;
}
if (map>=GL_PIXEL_MAP_S_TO_S && map<=GL_PIXEL_MAP_I_TO_A) {
GLuint p;
GLboolean ok = GL_FALSE;
for (p=1; p<=MAX_PIXEL_MAP_TABLE; p=p<<1) {
	 if ( (p&mapsize) == p ) {
	    ok = GL_TRUE;
	    break;
	 }
}
if (!ok) {
	 gl_error( ctx, GL_INVALID_VALUE, "glPixelMapfv(mapsize)" );
return;
}
}
switch (map) {
case GL_PIXEL_MAP_S_TO_S:
ctx->Pixel.MapStoSsize = mapsize;
for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapStoS[i] = (GLint) values[i];
	 }
	 break;
case GL_PIXEL_MAP_I_TO_I:
ctx->Pixel.MapItoIsize = mapsize;
for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapItoI[i] = (GLint) values[i];
	 }
	 break;
case GL_PIXEL_MAP_I_TO_R:
ctx->Pixel.MapItoRsize = mapsize;
for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapItoR[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
case GL_PIXEL_MAP_I_TO_G:
ctx->Pixel.MapItoGsize = mapsize;
for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapItoG[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
case GL_PIXEL_MAP_I_TO_B:
ctx->Pixel.MapItoBsize = mapsize;
for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapItoB[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
case GL_PIXEL_MAP_I_TO_A:
ctx->Pixel.MapItoAsize = mapsize;
for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapItoA[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
case GL_PIXEL_MAP_R_TO_R:
ctx->Pixel.MapRtoRsize = mapsize;
for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapRtoR[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
case GL_PIXEL_MAP_G_TO_G:
ctx->Pixel.MapGtoGsize = mapsize;
for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapGtoG[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
case GL_PIXEL_MAP_B_TO_B:
ctx->Pixel.MapBtoBsize = mapsize;
for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapBtoB[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
case GL_PIXEL_MAP_A_TO_A:
ctx->Pixel.MapAtoAsize = mapsize;
for (i=0;i<mapsize;i++) {
	    ctx->Pixel.MapAtoA[i] = CLAMP( values[i], 0.0, 1.0 );
	 }
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glPixelMapfv(map)" );
}
}
void gl_GetPixelMapfv( GLcontext *ctx, GLenum map, float *values )
{
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetPixelMapfv" );
return;
}
switch (map) {
case GL_PIXEL_MAP_I_TO_I:
for (i=0;i<ctx->Pixel.MapItoIsize;i++) {
	    values[i] = (float) ctx->Pixel.MapItoI[i];
	 }
	 break;
case GL_PIXEL_MAP_S_TO_S:
for (i=0;i<ctx->Pixel.MapStoSsize;i++) {
	    values[i] = (float) ctx->Pixel.MapStoS[i];
	 }
	 break;
case GL_PIXEL_MAP_I_TO_R:
MEMCPY(values,ctx->Pixel.MapItoR,ctx->Pixel.MapItoRsize*sizeof(float));
	 break;
case GL_PIXEL_MAP_I_TO_G:
MEMCPY(values,ctx->Pixel.MapItoG,ctx->Pixel.MapItoGsize*sizeof(float));
	 break;
case GL_PIXEL_MAP_I_TO_B:
MEMCPY(values,ctx->Pixel.MapItoB,ctx->Pixel.MapItoBsize*sizeof(float));
	 break;
case GL_PIXEL_MAP_I_TO_A:
MEMCPY(values,ctx->Pixel.MapItoA,ctx->Pixel.MapItoAsize*sizeof(float));
	 break;
case GL_PIXEL_MAP_R_TO_R:
MEMCPY(values,ctx->Pixel.MapRtoR,ctx->Pixel.MapRtoRsize*sizeof(float));
	 break;
case GL_PIXEL_MAP_G_TO_G:
MEMCPY(values,ctx->Pixel.MapGtoG,ctx->Pixel.MapGtoGsize*sizeof(float));
	 break;
case GL_PIXEL_MAP_B_TO_B:
MEMCPY(values,ctx->Pixel.MapBtoB,ctx->Pixel.MapBtoBsize*sizeof(float));
	 break;
case GL_PIXEL_MAP_A_TO_A:
MEMCPY(values,ctx->Pixel.MapAtoA,ctx->Pixel.MapAtoAsize*sizeof(float));
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
}
}
void gl_GetPixelMapuiv( GLcontext *ctx, GLenum map, GLuint *values )
{
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetPixelMapfv" );
return;
}
switch (map) {
case GL_PIXEL_MAP_I_TO_I:
MEMCPY(values, ctx->Pixel.MapItoI, ctx->Pixel.MapItoIsize*sizeof(GLint));
	 break;
case GL_PIXEL_MAP_S_TO_S:
MEMCPY(values, ctx->Pixel.MapStoS, ctx->Pixel.MapStoSsize*sizeof(GLint));
	 break;
case GL_PIXEL_MAP_I_TO_R:
	 for (i=0;i<ctx->Pixel.MapItoRsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoR[i] );
	 }
	 break;
case GL_PIXEL_MAP_I_TO_G:
	 for (i=0;i<ctx->Pixel.MapItoGsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoG[i] );
	 }
	 break;
case GL_PIXEL_MAP_I_TO_B:
	 for (i=0;i<ctx->Pixel.MapItoBsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoB[i] );
	 }
	 break;
case GL_PIXEL_MAP_I_TO_A:
	 for (i=0;i<ctx->Pixel.MapItoAsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapItoA[i] );
	 }
	 break;
case GL_PIXEL_MAP_R_TO_R:
	 for (i=0;i<ctx->Pixel.MapRtoRsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapRtoR[i] );
	 }
	 break;
case GL_PIXEL_MAP_G_TO_G:
	 for (i=0;i<ctx->Pixel.MapGtoGsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapGtoG[i] );
	 }
	 break;
case GL_PIXEL_MAP_B_TO_B:
	 for (i=0;i<ctx->Pixel.MapBtoBsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapBtoB[i] );
	 }
	 break;
case GL_PIXEL_MAP_A_TO_A:
	 for (i=0;i<ctx->Pixel.MapAtoAsize;i++) {
	    values[i] = FLOAT_TO_UINT( ctx->Pixel.MapAtoA[i] );
	 }
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
}
}
void gl_GetPixelMapusv( GLcontext *ctx, GLenum map, GLushort *values )
{
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetPixelMapfv" );
return;
}
switch (map) {
case GL_PIXEL_MAP_I_TO_I:
	 for (i=0;i<ctx->Pixel.MapItoIsize;i++) {
	    values[i] = (GLushort) ctx->Pixel.MapItoI[i];
	 }
	 break;
case GL_PIXEL_MAP_S_TO_S:
	 for (i=0;i<ctx->Pixel.MapStoSsize;i++) {
	    values[i] = (GLushort) ctx->Pixel.MapStoS[i];
	 }
	 break;
case GL_PIXEL_MAP_I_TO_R:
	 for (i=0;i<ctx->Pixel.MapItoRsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapItoR[i] );
	 }
	 break;
case GL_PIXEL_MAP_I_TO_G:
	 for (i=0;i<ctx->Pixel.MapItoGsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapItoG[i] );
	 }
	 break;
case GL_PIXEL_MAP_I_TO_B:
	 for (i=0;i<ctx->Pixel.MapItoBsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapItoB[i] );
	 }
	 break;
case GL_PIXEL_MAP_I_TO_A:
	 for (i=0;i<ctx->Pixel.MapItoAsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapItoA[i] );
	 }
	 break;
case GL_PIXEL_MAP_R_TO_R:
	 for (i=0;i<ctx->Pixel.MapRtoRsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapRtoR[i] );
	 }
	 break;
case GL_PIXEL_MAP_G_TO_G:
	 for (i=0;i<ctx->Pixel.MapGtoGsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapGtoG[i] );
	 }
	 break;
case GL_PIXEL_MAP_B_TO_B:
	 for (i=0;i<ctx->Pixel.MapBtoBsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapBtoB[i] );
	 }
	 break;
case GL_PIXEL_MAP_A_TO_A:
	 for (i=0;i<ctx->Pixel.MapAtoAsize;i++) {
	    values[i] = FLOAT_TO_USHORT( ctx->Pixel.MapAtoA[i] );
	 }
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetPixelMapfv" );
}
}
void gl_PixelTransferf( GLcontext *ctx, GLenum pname, float param )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPixelTransfer" );
return;
}
switch (pname) {
case GL_MAP_COLOR:
ctx->Pixel.MapColorFlag = param ? GL_TRUE : GL_FALSE;
	 break;
case GL_MAP_STENCIL:
ctx->Pixel.MapStencilFlag = param ? GL_TRUE : GL_FALSE;
	 break;
case GL_INDEX_SHIFT:
ctx->Pixel.IndexShift = (GLint) param;
	 break;
case GL_INDEX_OFFSET:
ctx->Pixel.IndexOffset = (GLint) param;
	 break;
case GL_RED_SCALE:
ctx->Pixel.RedScale = param;
	 break;
case GL_RED_BIAS:
ctx->Pixel.RedBias = param;
	 break;
case GL_GREEN_SCALE:
ctx->Pixel.GreenScale = param;
	 break;
case GL_GREEN_BIAS:
ctx->Pixel.GreenBias = param;
	 break;
case GL_BLUE_SCALE:
ctx->Pixel.BlueScale = param;
	 break;
case GL_BLUE_BIAS:
ctx->Pixel.BlueBias = param;
	 break;
case GL_ALPHA_SCALE:
ctx->Pixel.AlphaScale = param;
	 break;
case GL_ALPHA_BIAS:
ctx->Pixel.AlphaBias = param;
	 break;
case GL_DEPTH_SCALE:
ctx->Pixel.DepthScale = param;
	 break;
case GL_DEPTH_BIAS:
ctx->Pixel.DepthBias = param;
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glPixelTransfer(pname)" );
return;
}
update_drawpixels_state( ctx );
}
GLvoid *gl_unpack_pixels( GLcontext *ctx,
GLsizei width, GLsizei height,\
GLenum format, GLenum type,
const GLvoid *pixels )
{
GLint s, n;
s = gl_sizeof_type( type );
if (s<0) {
gl_error( ctx, GL_INVALID_ENUM, "internal error in gl_unpack(type)" );
return NULL;
}
n = gl_components_in_format( format );
if (n<0) {
gl_error( ctx, GL_INVALID_ENUM, "gl_unpack_pixels(format)" );
return NULL;
}
if (type==GL_BITMAP) {
GLint bytes, i, width_in_bytes;
GLubyte *buffer, *dst;
GLvoid *src;
bytes = CEILING( width * height , 8 );
buffer = (GLubyte *) malloc( bytes );
if (!buffer) {
	 return NULL;
}
width_in_bytes = CEILING( width, 8 );
dst = buffer;
for (i=0;i<height;i++) {
src = gl_pixel_addr_in_image( &ctx->Unpack, pixels, width, height,
format, type, 0, i, 0 );
if (!src) {
free(buffer);
return NULL;
}
	 MEMCPY( dst, src, width_in_bytes );
	 dst += width_in_bytes;
}
if (ctx->Unpack.LsbFirst) {
	 gl_flip_bytes( buffer, bytes );
}
return (GLvoid *) buffer;
}
else {
GLint width_in_bytes, bytes, i;
GLubyte *buffer, *dst;
GLvoid *src;
width_in_bytes = width * n * s;
bytes = height * width_in_bytes;
buffer = (GLubyte *) malloc( bytes );
if (!buffer) {
	 return NULL;
}
dst = buffer;
for (i=0;i<height;i++) {
src = gl_pixel_addr_in_image( &ctx->Unpack, pixels, width, height,
format, type, 0, i, 0 );
if (!src) {
free(buffer);
return NULL;
}
	 MEMCPY( dst, src, width_in_bytes );
	 dst += width_in_bytes;
}
if (ctx->Unpack.SwapBytes && s>1) {
	 if (s==2) {
	    gl_swap2( (GLushort *) buffer, bytes/2 );
	 }
	 else if (s==4) {
	    gl_swap4( (GLuint *) buffer, bytes/4 );
	 }
}
return (GLvoid *) buffer;
}
}
/* 当前文件是D:\Read\pointers.c*/

#ifdef PC_HEADER
#else
#endif
static void check_pointers( struct gl_api_table *table )
{
void **entry;
int numentries = sizeof( struct gl_api_table ) / sizeof(void*);
int i;
entry = (void **) table;
for (i=0;i<numentries;i++) {
if (!entry[i]) {
printf("found uninitialized function pointer at %d\n", i );
gl_problem(NULL, "Missing pointer in pointers.c");
}
}
}
GLboolean gl_AreTexturesResident( GLcontext *ctx, GLsizei n,
const GLuint *texName,
GLboolean *residences )
{
GLboolean resident = GL_TRUE;
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glAreTexturesResident" );
return GL_FALSE;
}
if (n<0) {
gl_error( ctx, GL_INVALID_VALUE, "glAreTexturesResident(n)" );
return GL_FALSE;
}
for (i=0;i<n;i++) {
struct gl_texture_object *t;
if (texName[i]==0) {
gl_error( ctx, GL_INVALID_VALUE, "glAreTexturesResident(textures)" );
return GL_FALSE;
}
t = (struct gl_texture_object *)
HashLookup(ctx->Shared->TexObjects, texName[i]);
if (t) {
residences[i] = GL_TRUE;
}
else {
gl_error( ctx, GL_INVALID_VALUE, "glAreTexturesResident(textures)" );
return GL_FALSE;
}
}
return resident;
}
GLboolean gl_IsTexture( GLcontext *ctx, GLuint texture )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glIsTextures" );
return GL_FALSE;
}
if (texture>0 && HashLookup(ctx->Shared->TexObjects, texture)) {
return GL_TRUE;
}
else {
return GL_FALSE;
}
}
void gl_ArrayElement( GLcontext *ctx, GLint i )
{
struct vertex_buffer *VB = ctx->VB;
GLint count = VB->Count;
if (ctx->Array.NormalEnabled) {
GLbyte *p = (GLbyte*) ctx->Array.NormalPtr
+ i * ctx->Array.NormalStrideB;
switch (ctx->Array.NormalType) {
case GL_BYTE:
VB->Normal[count][0] = BYTE_TO_FLOAT( p[0] );
VB->Normal[count][1] = BYTE_TO_FLOAT( p[1] );
VB->Normal[count][2] = BYTE_TO_FLOAT( p[2] );
break;
case GL_SHORT:
VB->Normal[count][0] = SHORT_TO_FLOAT( ((GLshort*)p)[0] );
VB->Normal[count][1] = SHORT_TO_FLOAT( ((GLshort*)p)[1] );
VB->Normal[count][2] = SHORT_TO_FLOAT( ((GLshort*)p)[2] );
break;
case GL_INT:
VB->Normal[count][0] = INT_TO_FLOAT( ((GLint*)p)[0] );
VB->Normal[count][1] = INT_TO_FLOAT( ((GLint*)p)[1] );
VB->Normal[count][2] = INT_TO_FLOAT( ((GLint*)p)[2] );
break;
case GL_FLOAT:
VB->Normal[count][0] = ((float*)p)[0];
VB->Normal[count][1] = ((float*)p)[1];
VB->Normal[count][2] = ((float*)p)[2];
break;
case GL_DOUBLE:
VB->Normal[count][0] = ((GLdouble*)p)[0];
VB->Normal[count][1] = ((GLdouble*)p)[1];
VB->Normal[count][2] = ((GLdouble*)p)[2];
break;
default:
gl_problem(ctx, "Bad normal type in gl_ArrayElement");
return;
}
VB->MonoNormal = GL_FALSE;
}
else {
VB->Normal[count][0] = ctx->Current.Normal[0];
VB->Normal[count][1] = ctx->Current.Normal[1];
VB->Normal[count][2] = ctx->Current.Normal[2];
}
if (ctx->Array.ColorEnabled) {
GLbyte *p = (GLbyte*) ctx->Array.ColorPtr + i * ctx->Array.ColorStrideB;
switch (ctx->Array.ColorType) {
case GL_BYTE:
switch (ctx->Array.ColorSize) {
case 4:   glColor4bv( (GLbyte*) p );   break;
case 3:   glColor3bv( (GLbyte*) p );   break;
}
break;
case GL_UNSIGNED_BYTE:
switch (ctx->Array.ColorSize) {
case 3:   glColor3ubv( (GLubyte*) p );   break;
case 4:   glColor4ubv( (GLubyte*) p );   break;
}
break;
case GL_SHORT:
switch (ctx->Array.ColorSize) {
case 3:   glColor3sv( (GLshort*) p );   break;
case 4:   glColor4sv( (GLshort*) p );   break;
}
break;
case GL_UNSIGNED_SHORT:
switch (ctx->Array.ColorSize) {
case 3:   glColor3usv( (GLushort*) p );   break;
case 4:   glColor4usv( (GLushort*) p );   break;
}
break;
case GL_INT:
switch (ctx->Array.ColorSize) {
case 3:   glColor3iv( (GLint*) p );   break;
case 4:   glColor4iv( (GLint*) p );   break;
}
break;
case GL_UNSIGNED_INT:
switch (ctx->Array.ColorSize) {
case 3:   glColor3uiv( (GLuint*) p );   break;
case 4:   glColor4uiv( (GLuint*) p );   break;
}
break;
case GL_FLOAT:
switch (ctx->Array.ColorSize) {
case 3:   glColor3fv( (float*) p );   break;
case 4:   glColor4fv( (float*) p );   break;
}
break;
case GL_DOUBLE:
switch (ctx->Array.ColorSize) {
case 3:   glColor3dv( (GLdouble*) p );   break;
case 4:   glColor4dv( (GLdouble*) p );   break;
}
break;
default:
gl_problem(ctx, "Bad color type in gl_ArrayElement");
return;
}
ctx->VB->MonoColor = GL_FALSE;
}
{
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
if (ctx->Light.ColorMaterialEnabled) {
float color[4];
color[0] = ctx->Current.ByteColor[0] * ctx->Visual->InvRedScale;
color[1] = ctx->Current.ByteColor[1] * ctx->Visual->InvGreenScale;
color[2] = ctx->Current.ByteColor[2] * ctx->Visual->InvBlueScale;
color[3] = ctx->Current.ByteColor[3] * ctx->Visual->InvAlphaScale;
gl_set_material( ctx, ctx->Light.ColorMaterialBitmask, color );
}
}
if (ctx->Array.IndexEnabled) {
GLbyte *p = (GLbyte*) ctx->Array.IndexPtr + i * ctx->Array.IndexStrideB;
switch (ctx->Array.IndexType) {
case GL_SHORT:
VB->Findex[count] = (GLuint) (*((GLshort*) p));
break;
case GL_INT:
VB->Findex[count] = (GLuint) (*((GLint*) p));
break;
case GL_FLOAT:
VB->Findex[count] = (GLuint) (*((float*) p));
break;
case GL_DOUBLE:
VB->Findex[count] = (GLuint) (*((GLdouble*) p));
break;
default:
gl_problem(ctx, "Bad index type in gl_ArrayElement");
return;
}
ctx->VB->MonoColor = GL_FALSE;
}
else {
VB->Findex[count] = ctx->Current.Index;
}
if (ctx->Array.TexCoordEnabled) {
GLbyte *p = (GLbyte*) ctx->Array.TexCoordPtr
+ i * ctx->Array.TexCoordStrideB;
VB->TexCoord[count][1] = 0.0F;
VB->TexCoord[count][2] = 0.0F;
VB->TexCoord[count][3] = 1.0F;
switch (ctx->Array.TexCoordType) {
case GL_SHORT:
switch (ctx->Array.TexCoordSize) {
case 4:   VB->TexCoord[count][3] = ((GLshort*) p)[3];
case 3:   VB->TexCoord[count][2] = ((GLshort*) p)[2];
case 2:   VB->TexCoord[count][1] = ((GLshort*) p)[1];
case 1:   VB->TexCoord[count][0] = ((GLshort*) p)[0];
}
break;
case GL_INT:
switch (ctx->Array.TexCoordSize) {
case 4:   VB->TexCoord[count][3] = ((GLint*) p)[3];
case 3:   VB->TexCoord[count][2] = ((GLint*) p)[2];
case 2:   VB->TexCoord[count][1] = ((GLint*) p)[1];
case 1:   VB->TexCoord[count][0] = ((GLint*) p)[0];
}
break;
case GL_FLOAT:
switch (ctx->Array.TexCoordSize) {
case 4:   VB->TexCoord[count][3] = ((float*) p)[3];
case 3:   VB->TexCoord[count][2] = ((float*) p)[2];
case 2:   VB->TexCoord[count][1] = ((float*) p)[1];
case 1:   VB->TexCoord[count][0] = ((float*) p)[0];
}
break;
case GL_DOUBLE:
switch (ctx->Array.TexCoordSize) {
case 4:   VB->TexCoord[count][3] = ((GLdouble*) p)[3];
case 3:   VB->TexCoord[count][2] = ((GLdouble*) p)[2];
case 2:   VB->TexCoord[count][1] = ((GLdouble*) p)[1];
case 1:   VB->TexCoord[count][0] = ((GLdouble*) p)[0];
}
break;
default:
gl_problem(ctx, "Bad texcoord type in gl_ArrayElement");
return;
}
}
else {
COPY_4V( VB->TexCoord[count], ctx->Current.TexCoord );
}
if (ctx->Array.EdgeFlagEnabled) {
GLbyte *b = (GLbyte*) ctx->Array.EdgeFlagPtr
+ i * ctx->Array.EdgeFlagStrideB;
VB->Edgeflag[count] = *((GLboolean*) b);
}
else {
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
}
if (ctx->Array.VertexEnabled) {
GLbyte *b = (GLbyte*) ctx->Array.VertexPtr
+ i * ctx->Array.VertexStrideB;
VB->Obj[count][2] = 0.0F;
VB->Obj[count][3] = 1.0F;
switch (ctx->Array.VertexType) {
case GL_SHORT:
switch (ctx->Array.VertexSize) {
case 4:   VB->Obj[count][3] = ((GLshort*) b)[3];
case 3:   VB->Obj[count][2] = ((GLshort*) b)[2];
case 2:   VB->Obj[count][1] = ((GLshort*) b)[1];
VB->Obj[count][0] = ((GLshort*) b)[0];
}
break;
case GL_INT:
switch (ctx->Array.VertexSize) {
case 4:   VB->Obj[count][3] = ((GLint*) b)[3];
case 3:   VB->Obj[count][2] = ((GLint*) b)[2];
case 2:   VB->Obj[count][1] = ((GLint*) b)[1];
VB->Obj[count][0] = ((GLint*) b)[0];
}
break;
case GL_FLOAT:
switch (ctx->Array.VertexSize) {
case 4:   VB->Obj[count][3] = ((float*) b)[3];
case 3:   VB->Obj[count][2] = ((float*) b)[2];
case 2:   VB->Obj[count][1] = ((float*) b)[1];
VB->Obj[count][0] = ((float*) b)[0];
}
break;
case GL_DOUBLE:
switch (ctx->Array.VertexSize) {
case 4:   VB->Obj[count][3] = ((GLdouble*) b)[3];
case 3:   VB->Obj[count][2] = ((GLdouble*) b)[2];
case 2:   VB->Obj[count][1] = ((GLdouble*) b)[1];
VB->Obj[count][0] = ((GLdouble*) b)[0];
}
break;
default:
gl_problem(ctx, "Bad vertex type in gl_ArrayElement");
return;
}
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
else {
}
}
void gl_save_ArrayElement( GLcontext *ctx, GLint i )
{
if (ctx->Array.NormalEnabled) {
GLbyte *p = (GLbyte*) ctx->Array.NormalPtr
+ i * ctx->Array.NormalStrideB;
switch (ctx->Array.NormalType) {
case GL_BYTE:
glNormal3bv( (GLbyte*) p );
break;
case GL_SHORT:
glNormal3sv( (GLshort*) p );
break;
case GL_INT:
glNormal3iv( (GLint*) p );
break;
case GL_FLOAT:
glNormal3fv( (float*) p );
break;
case GL_DOUBLE:
glNormal3dv( (GLdouble*) p );
break;
default:
gl_problem(ctx, "Bad normal type in gl_save_ArrayElement");
return;
}
}
if (ctx->Array.ColorEnabled) {
GLbyte *p = (GLbyte*) ctx->Array.ColorPtr + i * ctx->Array.ColorStrideB;
switch (ctx->Array.ColorType) {
case GL_BYTE:
switch (ctx->Array.ColorSize) {
case 3:   glColor3bv( (GLbyte*) p );   break;
case 4:   glColor4bv( (GLbyte*) p );   break;
}
break;
case GL_UNSIGNED_BYTE:
switch (ctx->Array.ColorSize) {
case 3:   glColor3ubv( (GLubyte*) p );   break;
case 4:   glColor4ubv( (GLubyte*) p );   break;
}
break;
case GL_SHORT:
switch (ctx->Array.ColorSize) {
case 3:   glColor3sv( (GLshort*) p );   break;
case 4:   glColor4sv( (GLshort*) p );   break;
}
break;
case GL_UNSIGNED_SHORT:
switch (ctx->Array.ColorSize) {
case 3:   glColor3usv( (GLushort*) p );   break;
case 4:   glColor4usv( (GLushort*) p );   break;
}
break;
case GL_INT:
switch (ctx->Array.ColorSize) {
case 3:   glColor3iv( (GLint*) p );   break;
case 4:   glColor4iv( (GLint*) p );   break;
}
break;
case GL_UNSIGNED_INT:
switch (ctx->Array.ColorSize) {
case 3:   glColor3uiv( (GLuint*) p );   break;
case 4:   glColor4uiv( (GLuint*) p );   break;
}
break;
case GL_FLOAT:
switch (ctx->Array.ColorSize) {
case 3:   glColor3fv( (float*) p );   break;
case 4:   glColor4fv( (float*) p );   break;
}
break;
case GL_DOUBLE:
switch (ctx->Array.ColorSize) {
case 3:   glColor3dv( (GLdouble*) p );   break;
case 4:   glColor4dv( (GLdouble*) p );   break;
}
break;
default:
gl_problem(ctx, "Bad color type in gl_save_ArrayElement");
return;
}
}
if (ctx->Array.IndexEnabled) {
GLbyte *p = (GLbyte*) ctx->Array.IndexPtr + i * ctx->Array.IndexStrideB;
switch (ctx->Array.IndexType) {
case GL_SHORT:
glIndexsv( (GLshort*) p );
break;
case GL_INT:
glIndexiv( (GLint*) p );
break;
case GL_FLOAT:
glIndexfv( (float*) p );
break;
case GL_DOUBLE:
glIndexdv( (GLdouble*) p );
break;
default:
gl_problem(ctx, "Bad index type in gl_save_ArrayElement");
return;
}
}
if (ctx->Array.TexCoordEnabled) {
GLbyte *p = (GLbyte*) ctx->Array.TexCoordPtr
+ i * ctx->Array.TexCoordStrideB;
switch (ctx->Array.TexCoordType) {
case GL_SHORT:
switch (ctx->Array.TexCoordSize) {
case 1:   glTexCoord1sv( (GLshort*) p );   break;
case 2:   glTexCoord2sv( (GLshort*) p );   break;
case 3:   glTexCoord3sv( (GLshort*) p );   break;
case 4:   glTexCoord4sv( (GLshort*) p );   break;
}
break;
case GL_INT:
switch (ctx->Array.TexCoordSize) {
case 1:   glTexCoord1iv( (GLint*) p );   break;
case 2:   glTexCoord2iv( (GLint*) p );   break;
case 3:   glTexCoord3iv( (GLint*) p );   break;
case 4:   glTexCoord4iv( (GLint*) p );   break;
}
break;
case GL_FLOAT:
switch (ctx->Array.TexCoordSize) {
case 1:   glTexCoord1fv( (float*) p );   break;
case 2:   glTexCoord2fv( (float*) p );   break;
case 3:   glTexCoord3fv( (float*) p );   break;
case 4:   glTexCoord4fv( (float*) p );   break;
}
break;
case GL_DOUBLE:
switch (ctx->Array.TexCoordSize) {
case 1:   glTexCoord1dv( (GLdouble*) p );   break;
case 2:   glTexCoord2dv( (GLdouble*) p );   break;
case 3:   glTexCoord3dv( (GLdouble*) p );   break;
case 4:   glTexCoord4dv( (GLdouble*) p );   break;
}
break;
default:
gl_problem(ctx, "Bad texcoord type in gl_save_ArrayElement");
return;
}
}
if (ctx->Array.EdgeFlagEnabled) {
GLbyte *b = (GLbyte*) ctx->Array.EdgeFlagPtr + i * ctx->Array.EdgeFlagStrideB;
glEdgeFlagv( (GLboolean*) b );
}
if (ctx->Array.VertexEnabled) {
GLbyte *b = (GLbyte*) ctx->Array.VertexPtr
+ i * ctx->Array.VertexStrideB;
switch (ctx->Array.VertexType) {
case GL_SHORT:
switch (ctx->Array.VertexSize) {
case 2:   glVertex2sv( (GLshort*) b );   break;
case 3:   glVertex3sv( (GLshort*) b );   break;
case 4:   glVertex4sv( (GLshort*) b );   break;
}
break;
case GL_INT:
switch (ctx->Array.VertexSize) {
case 2:   glVertex2iv( (GLint*) b );   break;
case 3:   glVertex3iv( (GLint*) b );   break;
case 4:   glVertex4iv( (GLint*) b );   break;
}
break;
case GL_FLOAT:
switch (ctx->Array.VertexSize) {
case 2:   glVertex2fv( (float*) b );   break;
case 3:   glVertex3fv( (float*) b );   break;
case 4:   glVertex4fv( (float*) b );   break;
}
break;
case GL_DOUBLE:
switch (ctx->Array.VertexSize) {
case 2:   glVertex2dv( (GLdouble*) b );   break;
case 3:   glVertex3dv( (GLdouble*) b );   break;
case 4:   glVertex4dv( (GLdouble*) b );   break;
}
break;
default:
gl_problem(ctx, "Bad vertex type in gl_save_ArrayElement");
return;
}
}
}
void gl_DrawArrays( GLcontext *ctx,
GLenum mode, GLint first, GLsizei count )
{
struct vertex_buffer* VB = ctx->VB;
GLint i;
GLboolean need_edges;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glDrawArrays" );
return;
}
if (count<0) {
gl_error( ctx, GL_INVALID_VALUE, "glDrawArrays(count)" );
return;
}
if (ctx->Primitive==GL_TRIANGLES || ctx->Primitive==GL_QUADS
|| ctx->Primitive==GL_POLYGON) {
need_edges = GL_TRUE;
}
else {
need_edges = GL_FALSE;
}
if (!ctx->Light.Enabled
&& !ctx->Texture.Enabled
&& ctx->Array.VertexEnabled && ctx->Array.VertexType==GL_FLOAT
&& ctx->Array.VertexStride==0 && ctx->Array.VertexSize==3
&& !ctx->Array.NormalEnabled
&& !ctx->Array.ColorEnabled
&& !ctx->Array.IndexEnabled
&& !ctx->Array.TexCoordEnabled
&& !ctx->Array.EdgeFlagEnabled) {
float (*vptr)[3];
GLint remaining;
gl_Begin( ctx, mode );
remaining = count;
vptr = (float (*)[3]) ctx->Array.VertexPtr + 3 * first;
while (remaining>0) {
GLint vbspace, n;
vbspace = VB_MAX - VB->Start;
n = MIN2( vbspace, remaining );
gl_xform_points_3fv( n, VB->Eye+VB->Start, ctx->ModelViewMatrix, vptr );
{
GLint i, start = VB->Start;
for (i=0;i<n;i++) {
COPY_4UBV( VB->Fcolor[start+i], ctx->Current.ByteColor );
}
}
if (need_edges) {
GLint i;
for (i=0;i<n;i++) {
VB->Edgeflag[VB->Start+i] = ctx->Current.EdgeFlag;
}
}
remaining -= n;
VB->MonoNormal = GL_FALSE;
VB->Count = VB->Start + n;
gl_transform_vb_part2( ctx, remaining==0 ? GL_TRUE : GL_FALSE );
vptr += n;
}
gl_End( ctx );
}
else if (!ctx->CompileFlag
&& ctx->Light.Enabled
&& !ctx->Texture.Enabled
&& ctx->Array.VertexEnabled && ctx->Array.VertexType==GL_FLOAT
&& ctx->Array.VertexStride==0 && ctx->Array.VertexSize==4
&& ctx->Array.NormalEnabled && ctx->Array.NormalType==GL_FLOAT
&& ctx->Array.NormalStride==0
&& !ctx->Array.ColorEnabled
&& !ctx->Array.IndexEnabled
&& !ctx->Array.TexCoordEnabled
&& !ctx->Array.EdgeFlagEnabled) {
float (*vptr)[4], (*nptr)[3];
GLint remaining;
gl_Begin( ctx, mode );
remaining = count;
vptr = (float (*)[4]) ctx->Array.VertexPtr + 4 * first;
nptr = (float (*)[3]) ctx->Array.NormalPtr + 3 * first;
while (remaining>0) {
GLint vbspace, n;
vbspace = VB_MAX - VB->Start;
n = MIN2( vbspace, remaining );
gl_xform_points_4fv( n, VB->Eye+VB->Start, ctx->ModelViewMatrix, vptr );
gl_xform_normals_3fv( n, VB->Normal+VB->Start, ctx->ModelViewInv, nptr,
ctx->Transform.Normalize );
if (need_edges) {
GLint i;
for (i=0;i<n;i++) {
VB->Edgeflag[VB->Start+i] = ctx->Current.EdgeFlag;
}
}
remaining -= n;
VB->MonoNormal = GL_FALSE;
VB->Count = VB->Start + n;
gl_transform_vb_part2( ctx, remaining==0 ? GL_TRUE : GL_FALSE );
vptr += n;
nptr += n;
}
gl_End( ctx );
}
else if (!ctx->CompileFlag
&& ctx->Light.Enabled
&& !ctx->Texture.Enabled
&& ctx->Array.VertexEnabled && ctx->Array.VertexType==GL_FLOAT
&& ctx->Array.VertexStride==0 && ctx->Array.VertexSize==3
&& ctx->Array.NormalEnabled && ctx->Array.NormalType==GL_FLOAT
&& ctx->Array.NormalStride==0
&& !ctx->Array.ColorEnabled
&& !ctx->Array.IndexEnabled
&& !ctx->Array.TexCoordEnabled
&& !ctx->Array.EdgeFlagEnabled) {
float (*vptr)[3], (*nptr)[3];
GLint remaining;
gl_Begin( ctx, mode );
remaining = count;
vptr = (float (*)[3]) ctx->Array.VertexPtr + 3 * first;
nptr = (float (*)[3]) ctx->Array.NormalPtr + 3 * first;
while (remaining>0) {
GLint vbspace, n;
vbspace = VB_MAX - VB->Start;
n = MIN2( vbspace, remaining );
gl_xform_points_3fv( n, VB->Eye+VB->Start, ctx->ModelViewMatrix, vptr );
gl_xform_normals_3fv( n, VB->Normal+VB->Start, ctx->ModelViewInv, nptr,
ctx->Transform.Normalize );
if (need_edges) {
GLint i;
for (i=0;i<n;i++) {
VB->Edgeflag[VB->Start+i] = ctx->Current.EdgeFlag;
}
}
remaining -= n;
VB->MonoNormal = GL_FALSE;
VB->Count = VB->Start + n;
gl_transform_vb_part2( ctx, remaining==0 ? GL_TRUE : GL_FALSE );
vptr += n;
nptr += n;
}
gl_End( ctx );
}
else {
gl_Begin( ctx, mode );
for (i=0;i<count;i++) {
gl_ArrayElement( ctx, first+i );
}
gl_End( ctx );
}
}
void gl_save_DrawArrays( GLcontext *ctx,
GLenum mode, GLint first, GLsizei count )
{
GLint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glDrawArrays" );
return;
}
if (count<0) {
gl_error( ctx, GL_INVALID_VALUE, "glDrawArrays(count)" );
return;
}
switch (mode) {
case GL_POINTS:
case GL_LINES:
case GL_LINE_STRIP:
case GL_LINE_LOOP:
case GL_TRIANGLES:
case GL_TRIANGLE_STRIP:
case GL_TRIANGLE_FAN:
case GL_QUADS:
case GL_QUAD_STRIP:
case GL_POLYGON:
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glDrawArrays(mode)" );
return;
}
gl_save_Begin( ctx, mode );
for (i=0;i<count;i++) {
gl_save_ArrayElement( ctx, first+i );
}
gl_save_End( ctx );
}
void gl_DrawElements( GLcontext *ctx,
GLenum mode, GLsizei count,
GLenum type, const GLvoid *indices )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glDrawElements" );
return;
}
if (count<0) {
gl_error( ctx, GL_INVALID_VALUE, "glDrawElements(count)" );
return;
}
switch (mode) {
case GL_POINTS:
case GL_LINES:
case GL_LINE_STRIP:
case GL_LINE_LOOP:
case GL_TRIANGLES:
case GL_TRIANGLE_STRIP:
case GL_TRIANGLE_FAN:
case GL_QUADS:
case GL_QUAD_STRIP:
case GL_POLYGON:
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glDrawArrays(mode)" );
return;
}
switch (type) {
case GL_UNSIGNED_BYTE:
{
GLubyte *ub_indices = (GLubyte *) indices;
GLint i;
gl_Begin( ctx, mode );
for (i=0;i<count;i++) {
gl_ArrayElement( ctx, (GLint) ub_indices[i] );
}
gl_End( ctx );
}
break;
case GL_UNSIGNED_SHORT:
{
GLushort *us_indices = (GLushort *) indices;
GLint i;
gl_Begin( ctx, mode );
for (i=0;i<count;i++) {
gl_ArrayElement( ctx, (GLint) us_indices[i] );
}
gl_End( ctx );
}
break;
case GL_UNSIGNED_INT:
{
GLuint *ui_indices = (GLuint *) indices;
GLint i;
gl_Begin( ctx, mode );
for (i=0;i<count;i++) {
gl_ArrayElement( ctx, (GLint) ui_indices[i] );
}
gl_End( ctx );
}
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glDrawElements(type)" );
return;
}
}
void gl_save_DrawElements( GLcontext *ctx,
GLenum mode, GLsizei count,
GLenum type, const GLvoid *indices )
{
switch (type) {
case GL_UNSIGNED_BYTE:
{
GLubyte *ub_indices = (GLubyte *) indices;
GLint i;
gl_save_Begin( ctx, mode );
for (i=0;i<count;i++) {
gl_save_ArrayElement( ctx, (GLint) ub_indices[i] );
}
gl_save_End( ctx );
}
break;
case GL_UNSIGNED_SHORT:
{
GLushort *us_indices = (GLushort *) indices;
GLint i;
gl_save_Begin( ctx, mode );
for (i=0;i<count;i++) {
gl_save_ArrayElement( ctx, (GLint) us_indices[i] );
}
gl_save_End( ctx );
}
break;
case GL_UNSIGNED_INT:
{
GLuint *ui_indices = (GLuint *) indices;
GLint i;
gl_save_Begin( ctx, mode );
for (i=0;i<count;i++) {
gl_save_ArrayElement( ctx, (GLint) ui_indices[i] );
}
gl_save_End( ctx );
}
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glDrawElements(type)" );
return;
}
}
void gl_InterleavedArrays( GLcontext *ctx,
GLenum format, GLsizei stride,
const GLvoid *pointer )
{
GLboolean tflag, cflag, nflag;
GLint tcomps, ccomps, vcomps;
GLenum ctype;
GLint coffset, noffset, voffset;
GLint defstride;
GLint c, f;
f = sizeof(float);
c = f * ((4*sizeof(GLubyte) + (f-1)) / f);
if (stride<0) {
gl_error( ctx, GL_INVALID_VALUE, "glInterleavedArrays(stride)" );
return;
}
switch (format) {
case GL_V2F:
tflag = GL_FALSE;  cflag = GL_FALSE;  nflag = GL_FALSE;
tcomps = 0;  ccomps = 0;  vcomps = 2;
voffset = 0;
defstride = 2*f;
break;
case GL_V3F:
tflag = GL_FALSE;  cflag = GL_FALSE;  nflag = GL_FALSE;
tcomps = 0;  ccomps = 0;  vcomps = 3;
voffset = 0;
defstride = 3*f;
break;
case GL_C4UB_V2F:
tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_FALSE;
tcomps = 0;  ccomps = 4;  vcomps = 2;
ctype = GL_UNSIGNED_BYTE;
coffset = 0;
voffset = c;
defstride = c + 2*f;
break;
case GL_C4UB_V3F:
tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_FALSE;
tcomps = 0;  ccomps = 4;  vcomps = 3;
ctype = GL_UNSIGNED_BYTE;
coffset = 0;
voffset = c;
defstride = c + 3*f;
break;
case GL_C3F_V3F:
tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_FALSE;
tcomps = 0;  ccomps = 3;  vcomps = 3;
ctype = GL_FLOAT;
coffset = 0;
voffset = 3*f;
defstride = 6*f;
break;
case GL_N3F_V3F:
tflag = GL_FALSE;  cflag = GL_FALSE;  nflag = GL_TRUE;
tcomps = 0;  ccomps = 0;  vcomps = 3;
noffset = 0;
voffset = 3*f;
defstride = 6*f;
break;
case GL_C4F_N3F_V3F:
tflag = GL_FALSE;  cflag = GL_TRUE;  nflag = GL_TRUE;
tcomps = 0;  ccomps = 4;  vcomps = 3;
ctype = GL_FLOAT;
coffset = 0;
noffset = 4*f;
voffset = 7*f;
defstride = 10*f;
break;
case GL_T2F_V3F:
tflag = GL_TRUE;  cflag = GL_FALSE;  nflag = GL_FALSE;
tcomps = 2;  ccomps = 0;  vcomps = 3;
voffset = 2*f;
defstride = 5*f;
break;
case GL_T4F_V4F:
tflag = GL_TRUE;  cflag = GL_FALSE;  nflag = GL_FALSE;
tcomps = 4;  ccomps = 0;  vcomps = 4;
voffset = 4*f;
defstride = 8*f;
break;
case GL_T2F_C4UB_V3F:
tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_FALSE;
tcomps = 2;  ccomps = 4;  vcomps = 3;
ctype = GL_UNSIGNED_BYTE;
coffset = 2*f;
voffset = c+2*f;
defstride = c+5*f;
break;
case GL_T2F_C3F_V3F:
tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_FALSE;
tcomps = 2;  ccomps = 3;  vcomps = 3;
ctype = GL_FLOAT;
coffset = 2*f;
voffset = 5*f;
defstride = 8*f;
break;
case GL_T2F_N3F_V3F:
tflag = GL_TRUE;  cflag = GL_FALSE;  nflag = GL_TRUE;
tcomps = 2;  ccomps = 0;  vcomps = 3;
noffset = 2*f;
voffset = 5*f;
defstride = 8*f;
break;
case GL_T2F_C4F_N3F_V3F:
tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_TRUE;
tcomps = 2;  ccomps = 4;  vcomps = 3;
ctype = GL_FLOAT;
coffset = 2*f;
noffset = 6*f;
voffset = 9*f;
defstride = 12*f;
break;
case GL_T4F_C4F_N3F_V4F:
tflag = GL_TRUE;  cflag = GL_TRUE;  nflag = GL_TRUE;
tcomps = 4;  ccomps = 4;  vcomps = 4;
ctype = GL_FLOAT;
coffset = 4*f;
noffset = 8*f;
voffset = 11*f;
defstride = 15*f;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glInterleavedArrays(format)" );
return;
}
if (stride==0) {
stride = defstride;
}
gl_DisableClientState( ctx, GL_EDGE_FLAG_ARRAY );
gl_DisableClientState( ctx, GL_INDEX_ARRAY );
if (tflag) {
gl_EnableClientState( ctx, GL_TEXTURE_COORD_ARRAY );
gl_TexCoordPointer( ctx, tcomps, GL_FLOAT, stride, pointer );
}
else {
gl_DisableClientState( ctx, GL_TEXTURE_COORD_ARRAY );
}
if (cflag) {
gl_EnableClientState( ctx, GL_COLOR_ARRAY );
gl_ColorPointer( ctx, ccomps, ctype, stride,
(GLubyte*) pointer + coffset );
}
else {
gl_DisableClientState( ctx, GL_COLOR_ARRAY );
}
if (nflag) {
gl_EnableClientState( ctx, GL_NORMAL_ARRAY );
gl_NormalPointer( ctx, GL_FLOAT, stride,
(GLubyte*) pointer + noffset );
}
else {
gl_DisableClientState( ctx, GL_NORMAL_ARRAY );
}
gl_EnableClientState( ctx, GL_VERTEX_ARRAY );
gl_VertexPointer( ctx, vcomps, GL_FLOAT, stride,
(GLubyte *) pointer + voffset );
}
void gl_save_InterleavedArrays( GLcontext *ctx,
GLenum format, GLsizei stride,
const GLvoid *pointer )
{
gl_InterleavedArrays( ctx, format, stride, pointer );
}
void gl_Color3f( GLcontext *ctx, float red, float green, float blue )
{
ctx->Current.ByteColor[0] = CLAMP(red  , 0.0F, 1.0F) * ctx->Visual->RedScale;
ctx->Current.ByteColor[1] = CLAMP(green, 0.0F, 1.0F) * ctx->Visual->GreenScale;
ctx->Current.ByteColor[2] = CLAMP(blue , 0.0F, 1.0F) * ctx->Visual->BlueScale;
ctx->Current.ByteColor[3] = ctx->Visual->AlphaScale;
ASSERT( !ctx->Light.ColorMaterialEnabled );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_Color3fv( GLcontext *ctx, const float *c )
{
ctx->Current.ByteColor[0] = CLAMP(c[0], 0.0F, 1.0F) * ctx->Visual->RedScale;
ctx->Current.ByteColor[1] = CLAMP(c[1], 0.0F, 1.0F) * ctx->Visual->GreenScale;
ctx->Current.ByteColor[2] = CLAMP(c[2], 0.0F, 1.0F) * ctx->Visual->BlueScale;
ctx->Current.ByteColor[3] = ctx->Visual->AlphaScale;
ASSERT( !ctx->Light.ColorMaterialEnabled );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_Color4f( GLcontext *ctx,
float red, float green, float blue, float alpha )
{
ctx->Current.ByteColor[0] = CLAMP(red  , 0.0F, 1.0F) * ctx->Visual->RedScale;
ctx->Current.ByteColor[1] = CLAMP(green, 0.0F, 1.0F) * ctx->Visual->GreenScale;
ctx->Current.ByteColor[2] = CLAMP(blue , 0.0F, 1.0F) * ctx->Visual->BlueScale;
ctx->Current.ByteColor[3] = CLAMP(alpha, 0.0F, 1.0F) * ctx->Visual->AlphaScale;
ASSERT( !ctx->Light.ColorMaterialEnabled );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_Color4fv( GLcontext *ctx, const float *c )
{
ctx->Current.ByteColor[0] = CLAMP(c[0], 0.0F, 1.0F) * ctx->Visual->RedScale;
ctx->Current.ByteColor[1] = CLAMP(c[1], 0.0F, 1.0F) * ctx->Visual->GreenScale;
ctx->Current.ByteColor[2] = CLAMP(c[2], 0.0F, 1.0F) * ctx->Visual->BlueScale;
ctx->Current.ByteColor[3] = CLAMP(c[3], 0.0F, 1.0F) * ctx->Visual->AlphaScale;
ASSERT( !ctx->Light.ColorMaterialEnabled );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_Color4ub( GLcontext *ctx,
GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha )
{
ctx->Current.ByteColor[0] = red   * ctx->Visual->RedScale   * (1.0F/255.0F);
ctx->Current.ByteColor[1] = green * ctx->Visual->GreenScale * (1.0F/255.0F);
ctx->Current.ByteColor[2] = blue  * ctx->Visual->BlueScale  * (1.0F/255.0F);
ctx->Current.ByteColor[3] = alpha * ctx->Visual->AlphaScale * (1.0F/255.0F);
ASSERT( !ctx->Light.ColorMaterialEnabled );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_Color4ub8bit( GLcontext *ctx,
GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha )
{
ASSIGN_4V( ctx->Current.ByteColor, red, green, blue, alpha );
ASSERT( !ctx->Light.ColorMaterialEnabled );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_Color4ubv( GLcontext *ctx, const GLubyte *c )
{
ctx->Current.ByteColor[0] = c[0] * ctx->Visual->RedScale   * (1.0F/255.0F);
ctx->Current.ByteColor[1] = c[1] * ctx->Visual->GreenScale * (1.0F/255.0F);
ctx->Current.ByteColor[2] = c[2] * ctx->Visual->BlueScale  * (1.0F/255.0F);
ctx->Current.ByteColor[3] = c[3] * ctx->Visual->AlphaScale * (1.0F/255.0F);
ASSERT( !ctx->Light.ColorMaterialEnabled );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_Color4ubv8bit( GLcontext *ctx, const GLubyte *c )
{
COPY_4UBV( ctx->Current.ByteColor, c );
ASSERT( !ctx->Light.ColorMaterialEnabled );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_ColorMat3f( GLcontext *ctx, float red, float green, float blue )
{
float color[4];
ctx->Current.ByteColor[0] = CLAMP(red  , 0.0F, 1.0F) * ctx->Visual->RedScale;
ctx->Current.ByteColor[1] = CLAMP(green, 0.0F, 1.0F) * ctx->Visual->GreenScale;
ctx->Current.ByteColor[2] = CLAMP(blue , 0.0F, 1.0F) * ctx->Visual->BlueScale;
ctx->Current.ByteColor[3] = ctx->Visual->AlphaScale;
ASSERT( ctx->Light.ColorMaterialEnabled );
ASSIGN_4V( color, red, green, blue, 1.0F );
gl_set_material( ctx, ctx->Light.ColorMaterialBitmask, color );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_ColorMat3fv( GLcontext *ctx, const float *c )
{
float color[4];
ctx->Current.ByteColor[0] = CLAMP(c[0], 0.0F, 1.0F) * ctx->Visual->RedScale;
ctx->Current.ByteColor[1] = CLAMP(c[1], 0.0F, 1.0F) * ctx->Visual->GreenScale;
ctx->Current.ByteColor[2] = CLAMP(c[2], 0.0F, 1.0F) * ctx->Visual->BlueScale;
ctx->Current.ByteColor[3] = ctx->Visual->AlphaScale;
ASSERT( ctx->Light.ColorMaterialEnabled );
ASSIGN_4V( color, c[0], c[1], c[2], 1.0F );
gl_set_material( ctx, ctx->Light.ColorMaterialBitmask, color );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_ColorMat4f( GLcontext *ctx,
float red, float green, float blue, float alpha )
{
float color[4];
ctx->Current.ByteColor[0] = CLAMP(red  , 0.0F, 1.0F) * ctx->Visual->RedScale;
ctx->Current.ByteColor[1] = CLAMP(green, 0.0F, 1.0F) * ctx->Visual->GreenScale;
ctx->Current.ByteColor[2] = CLAMP(blue , 0.0F, 1.0F) * ctx->Visual->BlueScale;
ctx->Current.ByteColor[3] = CLAMP(alpha, 0.0F, 1.0F) * ctx->Visual->AlphaScale;
ASSERT( ctx->Light.ColorMaterialEnabled );
ASSIGN_4V( color, red, green, blue, alpha );
gl_set_material( ctx, ctx->Light.ColorMaterialBitmask, color );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_ColorMat4fv( GLcontext *ctx, const float *c )
{
float color[4];
ctx->Current.ByteColor[0] = CLAMP(c[0], 0.0F, 1.0F) * ctx->Visual->RedScale;
ctx->Current.ByteColor[1] = CLAMP(c[1], 0.0F, 1.0F) * ctx->Visual->GreenScale;
ctx->Current.ByteColor[2] = CLAMP(c[2], 0.0F, 1.0F) * ctx->Visual->BlueScale;
ctx->Current.ByteColor[3] = CLAMP(c[3], 0.0F, 1.0F) * ctx->Visual->AlphaScale;
ASSERT( ctx->Light.ColorMaterialEnabled );
ASSIGN_4V( color, c[0], c[1], c[2], c[3] );
gl_set_material( ctx, ctx->Light.ColorMaterialBitmask, color );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_ColorMat4ub( GLcontext *ctx,
GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha )
{
float color[4];
if (ctx->Visual->EightBitColor) {
ASSIGN_4V( ctx->Current.ByteColor, red, green, blue, alpha );
}
else {
ctx->Current.ByteColor[0] = red   * ctx->Visual->RedScale   * (1.0F/255.0F);
ctx->Current.ByteColor[1] = green * ctx->Visual->GreenScale * (1.0F/255.0F);
ctx->Current.ByteColor[2] = blue  * ctx->Visual->BlueScale  * (1.0F/255.0F);
ctx->Current.ByteColor[3] = alpha * ctx->Visual->AlphaScale * (1.0F/255.0F);
}
ASSERT( ctx->Light.ColorMaterialEnabled );
color[0] = red   * (1.0F/255.0F);
color[1] = green * (1.0F/255.0F);
color[2] = blue  * (1.0F/255.0F);
color[3] = alpha * (1.0F/255.0F);
gl_set_material( ctx, ctx->Light.ColorMaterialBitmask, color );
ctx->VB->MonoColor = GL_FALSE;
}
void gl_ColorMat4ubv( GLcontext *ctx, const GLubyte *c )
{
gl_ColorMat4ub( ctx, c[0], c[1], c[2], c[3] );
}
void gl_EdgeFlag( GLcontext *ctx, GLboolean flag )
{
ctx->Current.EdgeFlag = flag;
}
static void vertex4f_feedback( GLcontext *ctx,
float x, float y, float z, float w )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_4V( VB->Obj[count], x, y, z, w );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
VB->Findex[count] = ctx->Current.Index;
COPY_3V( VB->Normal[count], ctx->Current.Normal );
COPY_4V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3f_feedback( GLcontext *ctx, float x, float y, float z )
{
vertex4f_feedback(ctx, x, y, z, 1.0F);
}
static void vertex2f_feedback( GLcontext *ctx, float x, float y )
{
vertex4f_feedback(ctx, x, y, 0.0F, 1.0F);
}
static void vertex3fv_feedback( GLcontext *ctx, const float v[3] )
{
vertex4f_feedback(ctx, v[0], v[1], v[2], 1.0F);
}
static void vertex4( GLcontext *ctx,
float x, float y, float z, float w )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_4V( VB->Obj[count], x, y, z, w );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_3V( VB->Normal[count], ctx->Current.Normal );
COPY_4V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
VB->VertexSizeMask = VERTEX4_BIT;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3f_normal_color_tex2( GLcontext *ctx,
float x, float y, float z )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, z );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_3V( VB->Normal[count], ctx->Current.Normal );
COPY_2V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3f_normal_color_tex4( GLcontext *ctx,
float x, float y, float z )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, z );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_3V( VB->Normal[count], ctx->Current.Normal );
COPY_4V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3f_normal( GLcontext *ctx, float x, float y, float z )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, z );
COPY_3V( VB->Normal[count], ctx->Current.Normal );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3f_color_tex2( GLcontext *ctx,
float x, float y, float z )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, z );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_2V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3f_color_tex4( GLcontext *ctx,
float x, float y, float z )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, z );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_4V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3f_color( GLcontext *ctx, float x, float y, float z )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, z );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3f_index( GLcontext *ctx, float x, float y, float z )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, z );
VB->Findex[count] = ctx->Current.Index;
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex2f_normal_color_tex2( GLcontext *ctx, float x, float y )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, 0.0F );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_3V( VB->Normal[count], ctx->Current.Normal );
COPY_2V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex2f_normal_color_tex4( GLcontext *ctx, float x, float y )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, 0.0F );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_3V( VB->Normal[count], ctx->Current.Normal );
COPY_4V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex2f_normal( GLcontext *ctx, float x, float y )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, 0.0F );
COPY_3V( VB->Normal[count], ctx->Current.Normal );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex2f_color_tex2( GLcontext *ctx, float x, float y )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, 0.0F );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_2V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex2f_color_tex4( GLcontext *ctx, float x, float y )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, 0.0F );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_4V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex2f_color( GLcontext *ctx, float x, float y )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, 0.0F );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex2f_index( GLcontext *ctx, float x, float y )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
ASSIGN_3V( VB->Obj[count], x, y, 0.0F );
VB->Findex[count] = ctx->Current.Index;
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3fv_normal_color_tex2( GLcontext *ctx, const float v[3] )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
COPY_3V( VB->Obj[count], v );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_3V( VB->Normal[count], ctx->Current.Normal );
COPY_2V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3fv_normal_color_tex4( GLcontext *ctx, const float v[3] )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
COPY_3V( VB->Obj[count], v );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_3V( VB->Normal[count], ctx->Current.Normal );
COPY_4V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3fv_normal( GLcontext *ctx, const float v[3] )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
COPY_3V( VB->Obj[count], v );
COPY_3V( VB->Normal[count], ctx->Current.Normal );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3fv_color_tex2( GLcontext *ctx, const float v[3] )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
COPY_3V( VB->Obj[count], v );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_2V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3fv_color_tex4( GLcontext *ctx, const float v[3] )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
COPY_3V( VB->Obj[count], v );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
COPY_4V( VB->TexCoord[count], ctx->Current.TexCoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3fv_color( GLcontext *ctx, const float v[3] )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
COPY_3V( VB->Obj[count], v );
COPY_4UBV( VB->Fcolor[count], ctx->Current.ByteColor );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
static void vertex3fv_index( GLcontext *ctx, const float v[3] )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
COPY_3V( VB->Obj[count], v );
VB->Findex[count] = ctx->Current.Index;
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
void gl_vertex4f_nop( GLcontext *ctx,
float x, float y, float z, float w )
{
gl_error( ctx, GL_INVALID_OPERATION, "glVertex4" );
}
void gl_vertex3f_nop( GLcontext *ctx, float x, float y, float z )
{
gl_error( ctx, GL_INVALID_OPERATION, "glVertex3" );
}
void gl_vertex2f_nop( GLcontext *ctx, float x, float y )
{
gl_error( ctx, GL_INVALID_OPERATION, "glVertex2" );
}
void gl_vertex3fv_nop( GLcontext *ctx, const float v[3] )
{
gl_error( ctx, GL_INVALID_OPERATION, "glVertex3v" );
}
void gl_TexCoord2f( GLcontext *ctx, float s, float t )
{
ctx->Current.TexCoord[0] = s;
ctx->Current.TexCoord[1] = t;
}
void gl_TexCoord2f4( GLcontext *ctx, float s, float t )
{
ctx->Current.TexCoord[0] = s;
ctx->Current.TexCoord[1] = t;
ctx->Current.TexCoord[2] = 0.0F;
ctx->Current.TexCoord[3] = 1.0F;
}
void gl_TexCoord4f( GLcontext *ctx, float s, float t, float r, float q)
{
ctx->Current.TexCoord[0] = s;
ctx->Current.TexCoord[1] = t;
ctx->Current.TexCoord[2] = r;
ctx->Current.TexCoord[3] = q;
if (ctx->VB->TexCoordSize==2) {
ctx->VB->TexCoordSize = 4;
gl_set_vertex_function( ctx );
ctx->Exec.TexCoord2f = ctx->API.TexCoord2f = gl_TexCoord2f4;
}
}
void gl_set_vertex_function( GLcontext *ctx )
{
if (ctx->RenderMode==GL_FEEDBACK) {
ctx->Exec.Vertex4f = vertex4f_feedback;
ctx->Exec.Vertex3f = vertex3f_feedback;
ctx->Exec.Vertex2f = vertex2f_feedback;
ctx->Exec.Vertex3fv = vertex3fv_feedback;
}
else {
ctx->Exec.Vertex4f = vertex4;
if (ctx->Visual->RGBAflag) {
if (ctx->NeedNormals) {
if (ctx->Texture.Enabled) {
if (ctx->VB->TexCoordSize==2) {
ctx->Exec.Vertex2f = vertex2f_normal_color_tex2;
ctx->Exec.Vertex3f = vertex3f_normal_color_tex2;
ctx->Exec.Vertex3fv = vertex3fv_normal_color_tex2;
}
else {
ctx->Exec.Vertex2f = vertex2f_normal_color_tex4;
ctx->Exec.Vertex3f = vertex3f_normal_color_tex4;
ctx->Exec.Vertex3fv = vertex3fv_normal_color_tex4;
}
}
else {
ctx->Exec.Vertex2f = vertex2f_normal;
ctx->Exec.Vertex3f = vertex3f_normal;
ctx->Exec.Vertex3fv = vertex3fv_normal;
}
}
else {
if (ctx->Texture.Enabled) {
if (ctx->VB->TexCoordSize==2) {
ctx->Exec.Vertex2f = vertex2f_color_tex2;
ctx->Exec.Vertex3f = vertex3f_color_tex2;
ctx->Exec.Vertex3fv = vertex3fv_color_tex2;
}
else {
ctx->Exec.Vertex2f = vertex2f_color_tex4;
ctx->Exec.Vertex3f = vertex3f_color_tex4;
ctx->Exec.Vertex3fv = vertex3fv_color_tex4;
}
}
else {
ctx->Exec.Vertex2f = vertex2f_color;
ctx->Exec.Vertex3f = vertex3f_color;
ctx->Exec.Vertex3fv = vertex3fv_color;
}
}
}
else {
if (ctx->Light.Enabled) {
ctx->Exec.Vertex2f = vertex2f_normal;
ctx->Exec.Vertex3f = vertex3f_normal;
ctx->Exec.Vertex3fv = vertex3fv_normal;
}
else {
ctx->Exec.Vertex2f = vertex2f_index;
ctx->Exec.Vertex3f = vertex3f_index;
ctx->Exec.Vertex3fv = vertex3fv_index;
}
}
}
if (!ctx->CompileFlag) {
ctx->API.Vertex2f = ctx->Exec.Vertex2f;
ctx->API.Vertex3f = ctx->Exec.Vertex3f;
ctx->API.Vertex4f = ctx->Exec.Vertex4f;
ctx->API.Vertex3fv = ctx->Exec.Vertex3fv;
}
}
void gl_set_color_function( GLcontext *ctx )
{
ASSERT( !INSIDE_BEGIN_END(ctx) );
if (ctx->Light.ColorMaterialEnabled) {
ctx->Exec.Color3f = gl_ColorMat3f;
ctx->Exec.Color3fv = gl_ColorMat3fv;
ctx->Exec.Color4f = gl_ColorMat4f;
ctx->Exec.Color4fv = gl_ColorMat4fv;
ctx->Exec.Color4ub = gl_ColorMat4ub;
ctx->Exec.Color4ubv = gl_ColorMat4ubv;
}
else {
ctx->Exec.Color3f = gl_Color3f;
ctx->Exec.Color3fv = gl_Color3fv;
ctx->Exec.Color4f = gl_Color4f;
ctx->Exec.Color4fv = gl_Color4fv;
ctx->Exec.Color4ub
= ctx->Visual->EightBitColor ? gl_Color4ub8bit : gl_Color4ub;
ctx->Exec.Color4ubv
= ctx->Visual->EightBitColor ? gl_Color4ubv8bit : gl_Color4ubv;
}
if (!ctx->CompileFlag) {
ctx->API.Color3f = ctx->Exec.Color3f;
ctx->API.Color3fv = ctx->Exec.Color3fv;
ctx->API.Color4f = ctx->Exec.Color4f;
ctx->API.Color4fv = ctx->Exec.Color4fv;
ctx->API.Color4ub = ctx->Exec.Color4ub;
ctx->API.Color4ubv = ctx->Exec.Color4ubv;
}
}
void gl_eval_vertex( GLcontext *ctx,
const float vertex[4], const float normal[3],
		     const GLubyte color[4],
GLuint index,
const float texcoord[4] )
{
struct vertex_buffer *VB = ctx->VB;
GLuint count = VB->Count;
VB->VertexSizeMask = VERTEX4_BIT;
VB->MonoNormal = GL_FALSE;
COPY_4V( VB->Obj[count], vertex );
COPY_3V( VB->Normal[count], normal );
COPY_4UBV( VB->Fcolor[count], color );
#ifdef GL_VERSION_1_1
if (ctx->Light.ColorMaterialEnabled
&& (ctx->Eval.Map1Color4 || ctx->Eval.Map2Color4)) {
float fcolor[4];
fcolor[0] = color[0] * ctx->Visual->InvRedScale;
fcolor[1] = color[1] * ctx->Visual->InvGreenScale;
fcolor[2] = color[2] * ctx->Visual->InvBlueScale;
fcolor[3] = color[3] * ctx->Visual->InvAlphaScale;
gl_set_material( ctx, ctx->Light.ColorMaterialBitmask, fcolor );
}
#endif
VB->Findex[count] = index;
COPY_4V( VB->TexCoord[count], texcoord );
VB->Edgeflag[count] = ctx->Current.EdgeFlag;
count++;
VB->Count = count;
if (count==VB_MAX) {
gl_transform_vb_part1( ctx, GL_FALSE );
}
}
#ifdef PROFILE
static GLdouble begin_time;
#endif
void gl_Begin( GLcontext *ctx, GLenum p )
{
struct vertex_buffer *VB = ctx->VB;
struct pixel_buffer *PB = ctx->PB;
#ifdef PROFILE
begin_time = gl_time();
#endif
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glBegin" );
return;
}
if (ctx->NewModelViewMatrix) {
gl_analyze_modelview_matrix(ctx);
}
if (ctx->NewProjectionMatrix) {
gl_analyze_projection_matrix(ctx);
}
if (ctx->NewState) {
gl_update_state(ctx);
}
else if (ctx->Exec.Vertex3f==gl_vertex3f_nop) {
gl_set_vertex_function(ctx);
}
if (ctx->Driver.Begin) {
(*ctx->Driver.Begin)( ctx, p );
}
ctx->Primitive = p;
VB->Start = VB->Count = 0;
VB->MonoColor = ctx->MonoPixels;
VB->MonoNormal = GL_TRUE;
if (VB->MonoColor) {
if (ctx->Visual->RGBAflag) {
GLubyte r = ctx->Current.ByteColor[0];
GLubyte g = ctx->Current.ByteColor[1];
GLubyte b = ctx->Current.ByteColor[2];
GLubyte a = ctx->Current.ByteColor[3];
(*ctx->Driver.Color)( ctx, r, g, b, a );
}
else {
(*ctx->Driver.Index)( ctx, ctx->Current.Index );
}
}
VB->Color = VB->Fcolor;
VB->Index = VB->Findex;
switch (ctx->Primitive) {
case GL_POINTS:
	 ctx->LightTwoSide = GL_FALSE;
	 PB_INIT( PB, GL_POINT );
	 break;
case GL_LINES:
case GL_LINE_STRIP:
case GL_LINE_LOOP:
	 ctx->LightTwoSide = GL_FALSE;
	 ctx->StippleCounter = 0;
	 PB_INIT( PB, GL_LINE );
break;
case GL_TRIANGLES:
case GL_TRIANGLE_STRIP:
case GL_TRIANGLE_FAN:
case GL_QUADS:
case GL_QUAD_STRIP:
case GL_POLYGON:
	 ctx->LightTwoSide = ctx->Light.Enabled && ctx->Light.Model.TwoSide;
	 PB_INIT( PB, GL_POLYGON );
break;
default:
	 gl_error( ctx, GL_INVALID_ENUM, "glBegin" );
	 ctx->Primitive = GL_BITMAP;
}
}
void gl_End( GLcontext *ctx )
{
struct pixel_buffer *PB = ctx->PB;
struct vertex_buffer *VB = ctx->VB;
if (ctx->Primitive==GL_BITMAP) {
gl_error( ctx, GL_INVALID_OPERATION, "glEnd" );
return;
}
if (VB->Count > VB->Start) {
gl_transform_vb_part1( ctx, GL_TRUE );
}
if (PB->count>0) {
gl_flush_pb(ctx);
}
if (ctx->Driver.End) {
(*ctx->Driver.End)(ctx);
}
PB->primitive = ctx->Primitive = GL_BITMAP;
#ifdef PROFILE
ctx->BeginEndTime += gl_time() - begin_time;
ctx->BeginEndCount++;
#endif
}
void gl_DeleteTextures( GLcontext *ctx, GLsizei n, const GLuint *texName)
{
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glAreTexturesResident" );
return;
}
for (i=0;i<n;i++) {
struct gl_texture_object *t;
if (texName[i]>0) {
t = (struct gl_texture_object *)
HashLookup(ctx->Shared->TexObjects, texName[i]);
if (t) {
if (ctx->Texture.Current1D==t) {
ctx->Texture.Current1D = ctx->Shared->Default1D;
t->RefCount--;
assert( t->RefCount >= 0 );
}
else if (ctx->Texture.Current2D==t) {
ctx->Texture.Current2D = ctx->Shared->Default2D;
t->RefCount--;
assert( t->RefCount >= 0 );
}
else if (ctx->Texture.Current3D==t) {
ctx->Texture.Current3D = ctx->Shared->Default3D;
t->RefCount--;
assert( t->RefCount >= 0 );
}
if (ctx->Driver.DeleteTexture) {
(*ctx->Driver.DeleteTexture)( ctx, t );
}
if (t->RefCount==0) {
gl_free_texture_object(ctx->Shared, t);
}
}
}
}
}
void gl_BindTexture( GLcontext *ctx, GLenum target, GLuint texName )
{
struct gl_texture_object *oldTexObj;
struct gl_texture_object *newTexObj;
struct gl_texture_object **targetPointer;
GLuint targetDimensions;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glAreTexturesResident" );
return;
}
switch (target) {
case GL_TEXTURE_1D:
oldTexObj = ctx->Texture.Current1D;
targetPointer = &ctx->Texture.Current1D;
targetDimensions = 1;
break;
case GL_TEXTURE_2D:
oldTexObj = ctx->Texture.Current2D;
targetPointer = &ctx->Texture.Current2D;
targetDimensions = 2;
break;
case GL_TEXTURE_3D_EXT:
oldTexObj = ctx->Texture.Current3D;
targetPointer = &ctx->Texture.Current3D;
targetDimensions = 3;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glBindTexture" );
return;
}
if (texName==0) {
switch (target) {
case GL_TEXTURE_1D:
newTexObj = ctx->Shared->Default1D;
break;
case GL_TEXTURE_2D:
newTexObj = ctx->Shared->Default2D;
break;
case GL_TEXTURE_3D_EXT:
newTexObj = ctx->Shared->Default3D;
break;
default:
gl_problem(ctx, "Bad target in gl_BindTexture");
return;
}
}
else {
newTexObj = (struct gl_texture_object *)
HashLookup(ctx->Shared->TexObjects, texName);
if (newTexObj) {
if (newTexObj->Dimensions!=targetDimensions) {
gl_error( ctx, GL_INVALID_OPERATION, "glBindTextureEXT" );
return;
}
}
else {
newTexObj = gl_alloc_texture_object(ctx->Shared, texName,
targetDimensions);
}
}
*targetPointer = newTexObj;
if (*targetPointer != oldTexObj && oldTexObj->Name>0) {
oldTexObj->RefCount--;
assert( oldTexObj->RefCount >= 0 );
}
if (newTexObj->Name>0) {
newTexObj->RefCount++;
}
if (   oldTexObj->WrapS != newTexObj->WrapS
|| oldTexObj->WrapT != newTexObj->WrapT
|| oldTexObj->WrapR != newTexObj->WrapR
|| oldTexObj->MinFilter != newTexObj->MinFilter
|| oldTexObj->MagFilter != newTexObj->MagFilter
|| !newTexObj->Complete) {
ctx->NewState |= NEW_RASTER_OPS;
}
if (oldTexObj==ctx->Texture.Current) {
ctx->Texture.Current = newTexObj;
}
assert(*targetPointer);
if (ctx->Driver.BindTexture) {
(*ctx->Driver.BindTexture)( ctx, target, newTexObj );
}
}
void gl_PrioritizeTextures( GLcontext *ctx,
GLsizei n, const GLuint *texName,
const GLclampf *priorities )
{
GLuint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glAreTexturesResident" );
return;
}
if (n<0) {
gl_error( ctx, GL_INVALID_VALUE, "glAreTexturesResident(n)" );
return;
}
for (i=0;i<n;i++) {
struct gl_texture_object *t;
if (texName[i]>0) {
t = (struct gl_texture_object *)
HashLookup(ctx->Shared->TexObjects, texName[i]);
if (t) {
t->Priority = CLAMP( priorities[i], 0.0F, 1.0F );
}
}
}
}
void gl_EdgeFlagPointer( GLcontext *ctx,
GLsizei stride, const GLboolean *ptr )
{
if (stride<0) {
gl_error( ctx, GL_INVALID_VALUE, "glEdgeFlagPointer(stride)" );
return;
}
ctx->Array.EdgeFlagStride = stride;
ctx->Array.EdgeFlagStrideB = stride ? stride : sizeof(GLboolean);
ctx->Array.EdgeFlagPtr = (GLboolean *) ptr;
}

void gl_init_api_function_pointers( GLcontext *ctx )
{
init_exec_pointers( &ctx->Exec );
init_dlist_pointers( &ctx->Save );
check_pointers( &ctx->Exec );
check_pointers( &ctx->Save );
}
/* 当前文件是D:\Read\points.c*/

#ifdef PC_HEADER
#else
#endif
void gl_PointSize( GLcontext *ctx, float size )
{
if (size<=0.0) {
gl_error( ctx, GL_INVALID_VALUE, "glPointSize" );
return;
}
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPointSize" );
return;
}
ctx->Point.Size = size;
ctx->NewState |= NEW_RASTER_OPS;
}
void gl_PointParameterfvEXT( GLcontext *ctx, GLenum pname,
const float *params)
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPointParameterfvEXT" );
return;
}
if(pname==GL_DISTANCE_ATTENUATION_EXT) {
COPY_3V(ctx->Point.Params,params);
} else {
if (*params<0.0 ) {
gl_error( ctx, GL_INVALID_VALUE, "glPointParameterfvEXT" );
return;
}
switch (pname) {
case GL_POINT_SIZE_MIN_EXT:
ctx->Point.MinSize=*params;
break;
case GL_POINT_SIZE_MAX_EXT:
ctx->Point.MaxSize=*params;
break;
case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
ctx->Point.Threshold=*params;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glPointParameterfvEXT" );
return;
}
}
ctx->NewState |= NEW_RASTER_OPS;
}
static void feedback_points( GLcontext *ctx, GLuint first, GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
GLuint i;
float invRedScale   = ctx->Visual->InvRedScale;
float invGreenScale = ctx->Visual->InvGreenScale;
float invBlueScale  = ctx->Visual->InvBlueScale;
float invAlphaScale = ctx->Visual->InvAlphaScale;
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
float x, y, z, w, invq;
float color[4], texcoord[4];
x = VB->Win[i][0];
y = VB->Win[i][1];
z = VB->Win[i][2] / DEPTH_SCALE;
w = VB->Clip[i][3];
if (ctx->Light.ShadeModel==GL_SMOOTH) {
color[0] = FixedToFloat(VB->Color[i][0]) * invRedScale;
color[1] = FixedToFloat(VB->Color[i][1]) * invGreenScale;
color[2] = FixedToFloat(VB->Color[i][2]) * invBlueScale;
color[3] = FixedToFloat(VB->Color[i][3]) * invAlphaScale;
}
else {
color[0] = VB->Color[i][0] * invRedScale;
color[1] = VB->Color[i][1] * invGreenScale;
color[2] = VB->Color[i][2] * invBlueScale;
color[3] = VB->Color[i][3] * invAlphaScale;
}
invq = 1.0F / VB->TexCoord[i][3];
texcoord[0] = VB->TexCoord[i][0] * invq;
texcoord[1] = VB->TexCoord[i][1] * invq;
texcoord[2] = VB->TexCoord[i][2] * invq;
texcoord[3] = VB->TexCoord[i][3];
FEEDBACK_TOKEN( ctx, (float) GL_POINT_TOKEN );
gl_feedback_vertex( ctx, x, y, z, w, color,
(float) VB->Index[i], texcoord );
}
}
}
static void select_points( GLcontext *ctx, GLuint first, GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
GLuint i;
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
gl_update_hitflag( ctx, VB->Win[i][2] / DEPTH_SCALE );
}
}
}
void size1_ci_points( GLcontext *ctx, GLuint first, GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
struct pixel_buffer *PB = ctx->PB;
float *win;
GLint *pbx = PB->x, *pby = PB->y;
GLdepth *pbz = PB->z;
GLuint *pbi = PB->i;
GLuint pbcount = PB->count;
GLuint i;
win = &VB->Win[first][0];
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
pbx[pbcount] = (GLint)  win[0];
pby[pbcount] = (GLint)  win[1];
pbz[pbcount] = (GLint) (win[2] + ctx->PointZoffset);
pbi[pbcount] = VB->Index[i];
pbcount++;
}
win += 3;
}
PB->count = pbcount;
PB_CHECK_FLUSH(ctx, PB);
}
static void size1_rgba_points( GLcontext *ctx, GLuint first, GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
struct pixel_buffer *PB = ctx->PB;
GLuint i;
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
GLint x, y, z;
GLint red, green, blue, alpha;
x = (GLint)  VB->Win[i][0];
y = (GLint)  VB->Win[i][1];
z = (GLint) (VB->Win[i][2] + ctx->PointZoffset);
red   = VB->Color[i][0];
green = VB->Color[i][1];
blue  = VB->Color[i][2];
alpha = VB->Color[i][3];
PB_WRITE_RGBA_PIXEL( PB, x, y, z, red, green, blue, alpha );
}
}
PB_CHECK_FLUSH(ctx,PB);
}
static void general_ci_points( GLcontext *ctx, GLuint first, GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
struct pixel_buffer *PB = ctx->PB;
GLuint i;
GLint isize;
isize = (GLint) (CLAMP(ctx->Point.Size,MIN_POINT_SIZE,MAX_POINT_SIZE) + 0.5F);
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
GLint x, y, z;
GLint x0, x1, y0, y1;
GLint ix, iy;
x = (GLint)  VB->Win[i][0];
y = (GLint)  VB->Win[i][1];
z = (GLint) (VB->Win[i][2] + ctx->PointZoffset);
if (isize&1) {
x0 = x - isize/2;
x1 = x + isize/2;
y0 = y - isize/2;
y1 = y + isize/2;
}
else {
x0 = (GLint) (x + 0.5F) - isize/2;
x1 = x0 + isize-1;
y0 = (GLint) (y + 0.5F) - isize/2;
y1 = y0 + isize-1;
}
PB_SET_INDEX( ctx, PB, VB->Index[i] );
for (iy=y0;iy<=y1;iy++) {
for (ix=x0;ix<=x1;ix++) {
PB_WRITE_PIXEL( PB, ix, iy, z );
}
}
PB_CHECK_FLUSH(ctx,PB);
}
}
}
static void general_rgba_points( GLcontext *ctx, GLuint first, GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
struct pixel_buffer *PB = ctx->PB;
GLuint i;
GLint isize;
isize = (GLint) (CLAMP(ctx->Point.Size,MIN_POINT_SIZE,MAX_POINT_SIZE) + 0.5F);
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
GLint x, y, z;
GLint x0, x1, y0, y1;
GLint ix, iy;
x = (GLint)  VB->Win[i][0];
y = (GLint)  VB->Win[i][1];
z = (GLint) (VB->Win[i][2] + ctx->PointZoffset);
if (isize&1) {
x0 = x - isize/2;
x1 = x + isize/2;
y0 = y - isize/2;
y1 = y + isize/2;
}
else {
x0 = (GLint) (x + 0.5F) - isize/2;
x1 = x0 + isize-1;
y0 = (GLint) (y + 0.5F) - isize/2;
y1 = y0 + isize-1;
}
PB_SET_COLOR( ctx, PB,
VB->Color[i][0],
VB->Color[i][1],
VB->Color[i][2],
VB->Color[i][3] );
for (iy=y0;iy<=y1;iy++) {
for (ix=x0;ix<=x1;ix++) {
PB_WRITE_PIXEL( PB, ix, iy, z );
}
}
PB_CHECK_FLUSH(ctx,PB);
}
}
}
static void textured_rgba_points( GLcontext *ctx, GLuint first, GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
struct pixel_buffer *PB = ctx->PB;
GLuint i;
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
GLint x, y, z;
GLint x0, x1, y0, y1;
GLint ix, iy;
GLint isize;
GLint red, green, blue, alpha;
float s, t, u;
x = (GLint)  VB->Win[i][0];
y = (GLint)  VB->Win[i][1];
z = (GLint) (VB->Win[i][2] + ctx->PointZoffset);
isize = (GLint)
(CLAMP(ctx->Point.Size,MIN_POINT_SIZE,MAX_POINT_SIZE) + 0.5F);
if (isize<1) {
isize = 1;
}
if (isize&1) {
x0 = x - isize/2;
x1 = x + isize/2;
y0 = y - isize/2;
y1 = y + isize/2;
}
else {
x0 = (GLint) (x + 0.5F) - isize/2;
x1 = x0 + isize-1;
y0 = (GLint) (y + 0.5F) - isize/2;
y1 = y0 + isize-1;
}
red   = VB->Color[i][0];
green = VB->Color[i][1];
blue  = VB->Color[i][2];
alpha = VB->Color[i][3];
s = VB->TexCoord[i][0] / VB->TexCoord[i][3];
t = VB->TexCoord[i][1] / VB->TexCoord[i][3];
u = VB->TexCoord[i][2] / VB->TexCoord[i][3];
for (iy=y0;iy<=y1;iy++) {
for (ix=x0;ix<=x1;ix++) {
PB_WRITE_TEX_PIXEL( PB, ix, iy, z, red, green, blue, alpha, s, t, u );
}
}
PB_CHECK_FLUSH(ctx,PB);
}
}
}
static void antialiased_rgba_points( GLcontext *ctx,
GLuint first, GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
struct pixel_buffer *PB = ctx->PB;
GLuint i;
float radius, rmin, rmax, rmin2, rmax2, cscale;
radius = CLAMP( ctx->Point.Size, MIN_POINT_SIZE, MAX_POINT_SIZE ) * 0.5F;
rmin = radius - 0.7071F;
rmax = radius + 0.7071F;
rmin2 = rmin*rmin;
rmax2 = rmax*rmax;
cscale = 256.0F / (rmax2-rmin2);
if (ctx->Texture.Enabled) {
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
GLint xmin, ymin, xmax, ymax;
GLint x, y, z;
GLint red, green, blue, alpha;
float s, t, u;
xmin = (GLint) (VB->Win[i][0] - radius);
xmax = (GLint) (VB->Win[i][0] + radius);
ymin = (GLint) (VB->Win[i][1] - radius);
ymax = (GLint) (VB->Win[i][1] + radius);
z = (GLint) (VB->Win[i][2] + ctx->PointZoffset);
red   = VB->Color[i][0];
green = VB->Color[i][1];
blue  = VB->Color[i][2];
s = VB->TexCoord[i][0] / VB->TexCoord[i][3];
t = VB->TexCoord[i][1] / VB->TexCoord[i][3];
u = VB->TexCoord[i][2] / VB->TexCoord[i][3];
for (y=ymin;y<=ymax;y++) {
for (x=xmin;x<=xmax;x++) {
float dx = x - VB->Win[i][0];
float dy = y - VB->Win[i][1];
float dist2 = dx*dx + dy*dy;
if (dist2<rmax2) {
alpha = VB->Color[i][3];
if (dist2>=rmin2) {
GLint coverage = (GLint) (256.0F-(dist2-rmin2)*cscale);
alpha = (alpha * coverage) >> 8;
}
PB_WRITE_TEX_PIXEL( PB, x,y,z, red, green, blue, alpha, s, t, u );
}
}
}
PB_CHECK_FLUSH(ctx,PB);
}
}
}
else {
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
GLint xmin, ymin, xmax, ymax;
GLint x, y, z;
GLint red, green, blue, alpha;
xmin = (GLint) (VB->Win[i][0] - radius);
xmax = (GLint) (VB->Win[i][0] + radius);
ymin = (GLint) (VB->Win[i][1] - radius);
ymax = (GLint) (VB->Win[i][1] + radius);
z = (GLint) (VB->Win[i][2] + ctx->PointZoffset);
red   = VB->Color[i][0];
green = VB->Color[i][1];
blue  = VB->Color[i][2];
for (y=ymin;y<=ymax;y++) {
for (x=xmin;x<=xmax;x++) {
float dx = x - VB->Win[i][0];
float dy = y - VB->Win[i][1];
float dist2 = dx*dx + dy*dy;
if (dist2<rmax2) {
alpha = VB->Color[i][3];
if (dist2>=rmin2) {
GLint coverage = (GLint) (256.0F-(dist2-rmin2)*cscale);
alpha = (alpha * coverage) >> 8;
}
PB_WRITE_RGBA_PIXEL( PB, x, y, z, red, green, blue, alpha );
}
}
}
PB_CHECK_FLUSH(ctx,PB);
}
}
}
}
static void null_points( GLcontext *ctx, GLuint first, GLuint last )
{
}
static float dist_attenuation(GLcontext *ctx, const float p[3])
{
float dist;
dist=GL_SQRT(p[0]*p[0]+p[1]*p[1]+p[2]*p[2]);
return (1/(ctx->Point.Params[0]+ ctx->Point.Params[1]*dist +
ctx->Point.Params[2]*dist*dist));
}
static void dist_atten_general_ci_points( GLcontext *ctx, GLuint first,
					GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
struct pixel_buffer *PB = ctx->PB;
GLuint i;
GLint isize;
float psize,dsize;
psize=CLAMP(ctx->Point.Size,MIN_POINT_SIZE,MAX_POINT_SIZE);
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
GLint x, y, z;
GLint x0, x1, y0, y1;
GLint ix, iy;
x = (GLint)  VB->Win[i][0];
y = (GLint)  VB->Win[i][1];
z = (GLint) (VB->Win[i][2] + ctx->PointZoffset);
dsize=psize*dist_attenuation(ctx,VB->Eye[i]);
if(dsize>=ctx->Point.Threshold) {
isize=(GLint) (MIN2(dsize,ctx->Point.MaxSize)+0.5F);
} else {
isize=(GLint) (MAX2(ctx->Point.Threshold,ctx->Point.MinSize)+0.5F);
}
if (isize&1) {
x0 = x - isize/2;
x1 = x + isize/2;
y0 = y - isize/2;
y1 = y + isize/2;
}
else {
x0 = (GLint) (x + 0.5F) - isize/2;
x1 = x0 + isize-1;
y0 = (GLint) (y + 0.5F) - isize/2;
y1 = y0 + isize-1;
}
PB_SET_INDEX( ctx, PB, VB->Index[i] );
for (iy=y0;iy<=y1;iy++) {
for (ix=x0;ix<=x1;ix++) {
PB_WRITE_PIXEL( PB, ix, iy, z );
}
}
PB_CHECK_FLUSH(ctx,PB);
}
}
}
static void dist_atten_general_rgba_points( GLcontext *ctx, GLuint first,
				GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
struct pixel_buffer *PB = ctx->PB;
GLuint i;
GLubyte alpha;
GLint isize;
float psize,dsize;
psize=CLAMP(ctx->Point.Size,MIN_POINT_SIZE,MAX_POINT_SIZE);
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
GLint x, y, z;
GLint x0, x1, y0, y1;
GLint ix, iy;
x = (GLint)  VB->Win[i][0];
y = (GLint)  VB->Win[i][1];
z = (GLint) (VB->Win[i][2] + ctx->PointZoffset);
dsize=psize*dist_attenuation(ctx,VB->Eye[i]);
if(dsize>=ctx->Point.Threshold) {
isize=(GLint) (MIN2(dsize,ctx->Point.MaxSize)+0.5F);
alpha=VB->Color[i][3];
} else {
isize=(GLint) (MAX2(ctx->Point.Threshold,ctx->Point.MinSize)+0.5F);
dsize/=ctx->Point.Threshold;
alpha=VB->Color[i][3]* (dsize*dsize);
}
if (isize&1) {
x0 = x - isize/2;
x1 = x + isize/2;
y0 = y - isize/2;
y1 = y + isize/2;
}
else {
x0 = (GLint) (x + 0.5F) - isize/2;
x1 = x0 + isize-1;
y0 = (GLint) (y + 0.5F) - isize/2;
y1 = y0 + isize-1;
}
PB_SET_COLOR( ctx, PB,
VB->Color[i][0],
VB->Color[i][1],
VB->Color[i][2],
alpha );
for (iy=y0;iy<=y1;iy++) {
for (ix=x0;ix<=x1;ix++) {
PB_WRITE_PIXEL( PB, ix, iy, z );
}
}
PB_CHECK_FLUSH(ctx,PB);
}
}
}
static void dist_atten_textured_rgba_points( GLcontext *ctx, GLuint first,
					GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
struct pixel_buffer *PB = ctx->PB;
GLuint i;
float psize,dsize;
psize=CLAMP(ctx->Point.Size,MIN_POINT_SIZE,MAX_POINT_SIZE);
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
GLint x, y, z;
GLint x0, x1, y0, y1;
GLint ix, iy;
GLint isize;
GLint red, green, blue, alpha;
float s, t, u;
x = (GLint)  VB->Win[i][0];
y = (GLint)  VB->Win[i][1];
z = (GLint) (VB->Win[i][2] + ctx->PointZoffset);
dsize=psize*dist_attenuation(ctx,VB->Eye[i]);
if(dsize>=ctx->Point.Threshold) {
isize=(GLint) (MIN2(dsize,ctx->Point.MaxSize)+0.5F);
alpha=VB->Color[i][3];
} else {
isize=(GLint) (MAX2(ctx->Point.Threshold,ctx->Point.MinSize)+0.5F);
dsize/=ctx->Point.Threshold;
alpha=VB->Color[i][3]* (dsize*dsize);
}
if (isize<1) {
isize = 1;
}
if (isize&1) {
x0 = x - isize/2;
x1 = x + isize/2;
y0 = y - isize/2;
y1 = y + isize/2;
}
else {
x0 = (GLint) (x + 0.5F) - isize/2;
x1 = x0 + isize-1;
y0 = (GLint) (y + 0.5F) - isize/2;
y1 = y0 + isize-1;
}
red   = VB->Color[i][0];
green = VB->Color[i][1];
blue  = VB->Color[i][2];
s = VB->TexCoord[i][0] / VB->TexCoord[i][3];
t = VB->TexCoord[i][1] / VB->TexCoord[i][3];
u = VB->TexCoord[i][2] / VB->TexCoord[i][3];
for (iy=y0;iy<=y1;iy++) {
for (ix=x0;ix<=x1;ix++) {
PB_WRITE_TEX_PIXEL( PB, ix, iy, z, red, green, blue, alpha, s, t,
u );
}
}
PB_CHECK_FLUSH(ctx,PB);
}
}
}
static void dist_atten_antialiased_rgba_points( GLcontext *ctx,
GLuint first, GLuint last )
{
struct vertex_buffer *VB = ctx->VB;
struct pixel_buffer *PB = ctx->PB;
GLuint i;
float radius, rmin, rmax, rmin2, rmax2, cscale;
float psize,dsize,alphaf;
psize=CLAMP(ctx->Point.Size,MIN_POINT_SIZE,MAX_POINT_SIZE);
if (ctx->Texture.Enabled) {
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
GLint xmin, ymin, xmax, ymax;
GLint x, y, z;
GLint red, green, blue, alpha;
float s, t, u;
dsize=psize*dist_attenuation(ctx,VB->Eye[i]);
if(dsize>=ctx->Point.Threshold) {
radius=(MIN2(dsize,ctx->Point.MaxSize)*0.5F);
alphaf=1.0;
} else {
radius=(MAX2(ctx->Point.Threshold,ctx->Point.MinSize)*0.5F);
dsize/=ctx->Point.Threshold;
alphaf=(dsize*dsize);
}
rmin = radius - 0.7071F;
rmax = radius + 0.7071F;
rmin2 = rmin*rmin;
rmax2 = rmax*rmax;
cscale = 256.0F / (rmax2-rmin2);
xmin = (GLint) (VB->Win[i][0] - radius);
xmax = (GLint) (VB->Win[i][0] + radius);
ymin = (GLint) (VB->Win[i][1] - radius);
ymax = (GLint) (VB->Win[i][1] + radius);
z = (GLint) (VB->Win[i][2] + ctx->PointZoffset);
red   = VB->Color[i][0];
green = VB->Color[i][1];
blue  = VB->Color[i][2];
s = VB->TexCoord[i][0] / VB->TexCoord[i][3];
t = VB->TexCoord[i][1] / VB->TexCoord[i][3];
u = VB->TexCoord[i][2] / VB->TexCoord[i][3];
for (y=ymin;y<=ymax;y++) {
for (x=xmin;x<=xmax;x++) {
float dx = x - VB->Win[i][0];
float dy = y - VB->Win[i][1];
float dist2 = dx*dx + dy*dy;
if (dist2<rmax2) {
alpha = VB->Color[i][3];
if (dist2>=rmin2) {
GLint coverage = (GLint) (256.0F-(dist2-rmin2)*cscale);
alpha = (alpha * coverage) >> 8;
}
alpha*=alphaf;
PB_WRITE_TEX_PIXEL( PB, x,y,z, red, green, blue, alpha, s,
t, u );
}
}
}
PB_CHECK_FLUSH(ctx,PB);
}
}
}
else {
for (i=first;i<=last;i++) {
if (VB->ClipMask[i]==0) {
GLint xmin, ymin, xmax, ymax;
GLint x, y, z;
GLint red, green, blue, alpha;
dsize=psize*dist_attenuation(ctx,VB->Eye[i]);
if(dsize>=ctx->Point.Threshold) {
radius=(MIN2(dsize,ctx->Point.MaxSize)*0.5F);
alphaf=1.0;
} else {
radius=(MAX2(ctx->Point.Threshold,ctx->Point.MinSize)*0.5F);
dsize/=ctx->Point.Threshold;
alphaf=(dsize*dsize);
}
rmin = radius - 0.7071F;
rmax = radius + 0.7071F;
rmin2 = rmin*rmin;
rmax2 = rmax*rmax;
cscale = 256.0F / (rmax2-rmin2);
xmin = (GLint) (VB->Win[i][0] - radius);
xmax = (GLint) (VB->Win[i][0] + radius);
ymin = (GLint) (VB->Win[i][1] - radius);
ymax = (GLint) (VB->Win[i][1] + radius);
z = (GLint) (VB->Win[i][2] + ctx->PointZoffset);
red   = VB->Color[i][0];
green = VB->Color[i][1];
blue  = VB->Color[i][2];
for (y=ymin;y<=ymax;y++) {
for (x=xmin;x<=xmax;x++) {
float dx = x - VB->Win[i][0];
float dy = y - VB->Win[i][1];
float dist2 = dx*dx + dy*dy;
if (dist2<rmax2) {
alpha = VB->Color[i][3];
if (dist2>=rmin2) {
GLint coverage = (GLint) (256.0F-(dist2-rmin2)*cscale);
alpha = (alpha * coverage) >> 8;
}
alpha*=alphaf;
PB_WRITE_RGBA_PIXEL( PB, x, y, z, red, green, blue, alpha )
;
}
}
}
PB_CHECK_FLUSH(ctx,PB);
}
}
}
}
void gl_set_point_function( GLcontext *ctx )
{
GLboolean rgbmode = ctx->Visual->RGBAflag;
if (ctx->RenderMode==GL_RENDER) {
if (ctx->NoRaster) {
ctx->Driver.PointsFunc = null_points;
return;
}
if (ctx->Driver.PointsFunc) {
ctx->Driver.PointsFunc = ctx->Driver.PointsFunc;
}
else if (ctx->Point.Params[0]==1.0 && ctx->Point.Params[1]==0.0 &&
ctx->Point.Params[2]==0.0) {
if (ctx->Point.SmoothFlag && rgbmode) {
ctx->Driver.PointsFunc = antialiased_rgba_points;
}
else if (ctx->Texture.Enabled) {
	    ctx->Driver.PointsFunc = textured_rgba_points;
}
else if (ctx->Point.Size==1.0) {
ctx->Driver.PointsFunc = rgbmode ? size1_rgba_points
: size1_ci_points;
}
else {
	
	    ctx->Driver.PointsFunc = rgbmode ? general_rgba_points
: general_ci_points;
}
}
else if(ctx->Point.SmoothFlag && rgbmode) {
ctx->Driver.PointsFunc = dist_atten_antialiased_rgba_points;
}
else if (ctx->Texture.Enabled) {
ctx->Driver.PointsFunc = dist_atten_textured_rgba_points;
}
else {
ctx->Driver.PointsFunc = rgbmode ? dist_atten_general_rgba_points
: dist_atten_general_ci_points;
}
}
else if (ctx->RenderMode==GL_FEEDBACK) {
ctx->Driver.PointsFunc = feedback_points;
}
else {
ctx->Driver.PointsFunc = select_points;
}
}

/* 当前文件是D:\Read\polygon.c*/

#ifdef PC_HEADER
#else
#endif
void gl_CullFace( GLcontext *ctx, GLenum mode )
{
if (mode!=GL_FRONT && mode!=GL_BACK && mode!=GL_FRONT_AND_BACK) {
gl_error( ctx, GL_INVALID_ENUM, "glCullFace" );
return;
}
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glCullFace" );
return;
}
ctx->Polygon.CullFaceMode = mode;
ctx->NewState |= NEW_POLYGON;
}
void gl_FrontFace( GLcontext *ctx, GLenum mode )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glFrontFace" );
return;
}
if (mode!=GL_CW && mode!=GL_CCW) {
gl_error( ctx, GL_INVALID_ENUM, "glFrontFace" );
return;
}
ctx->Polygon.FrontFace = mode;
}
void gl_PolygonMode( GLcontext *ctx, GLenum face, GLenum mode )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPolygonMode" );
return;
}
if (face!=GL_FRONT && face!=GL_BACK && face!=GL_FRONT_AND_BACK) {
gl_error( ctx, GL_INVALID_ENUM, "glPolygonMode(face)" );
return;
}
else if (mode!=GL_POINT && mode!=GL_LINE && mode!=GL_FILL) {
gl_error( ctx, GL_INVALID_ENUM, "glPolygonMode(mode)" );
return;
}
if (face==GL_FRONT || face==GL_FRONT_AND_BACK) {
ctx->Polygon.FrontMode = mode;
}
if (face==GL_BACK || face==GL_FRONT_AND_BACK) {
ctx->Polygon.BackMode = mode;
}
if (ctx->Polygon.FrontMode!=GL_FILL || ctx->Polygon.BackMode!=GL_FILL) {
ctx->Polygon.Unfilled = GL_TRUE;
}
else {
ctx->Polygon.Unfilled = GL_FALSE;
}
ctx->NewState |= NEW_POLYGON;
}
void gl_PolygonStipple( GLcontext *ctx, const GLubyte *mask )
{
GLint i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPolygonStipple" );
return;
}
for (i=0;i<32;i++) {
ctx->PolygonStipple[i] = (mask[i*4+0] << 24)
| (mask[i*4+1] << 16)
| (mask[i*4+2] << 8)
| (mask[i*4+3]);
}
if (ctx->Polygon.StippleFlag) {
ctx->NewState |= NEW_RASTER_OPS;
}
}
void gl_GetPolygonStipple( GLcontext *ctx, GLubyte *mask )
{
}
void gl_PolygonOffset( GLcontext *ctx,
float factor, float units )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glPolygonOffset" );
return;
}
ctx->Polygon.OffsetFactor = factor;
ctx->Polygon.OffsetUnits = units;
}
/* 当前文件是D:\Read\quads.c*/

#ifdef PC_HEADER
#else
#endif
static void quad( GLcontext *ctx,
GLuint v0, GLuint v1, GLuint v2, GLuint v3, GLuint pv )
{
(*ctx->Driver.TriangleFunc)( ctx, v0, v1, v3, pv );
(*ctx->Driver.TriangleFunc)( ctx, v1, v2, v3, pv );
}
static void null_quad( GLcontext *ctx,
GLuint v0, GLuint v1, GLuint v2, GLuint v3, GLuint pv )
{
}
void gl_set_quad_function( GLcontext *ctx )
{
if (ctx->RenderMode==GL_RENDER) {
if (ctx->NoRaster) {
ctx->Driver.QuadFunc = null_quad;
}
else if (ctx->Driver.QuadFunc) {
}
else {
ctx->Driver.QuadFunc = quad;
}
}
else {
ctx->Driver.QuadFunc = quad;
}
}
/* 当前文件是D:\Read\rastpos.c*/

#ifdef PC_HEADER
#else
#endif
void gl_RasterPos4f( GLcontext *ctx,
float x, float y, float z, float w )
{
float v[4], eye[4], clip[4], ndc[3], d;
ASSIGN_4V( v, x, y, z, w );
if (ctx->NewModelViewMatrix) {
gl_analyze_modelview_matrix(ctx);
}
if (ctx->NewProjectionMatrix) {
gl_analyze_projection_matrix(ctx);
}
if (ctx->NewTextureMatrix) {
gl_analyze_texture_matrix(ctx);
}
TRANSFORM_POINT( eye, ctx->ModelViewMatrix, v );
if (ctx->Light.Enabled) {
float eyenorm[3];
TRANSFORM_NORMAL( eyenorm[0], eyenorm[1], eyenorm[2], ctx->Current.Normal,
ctx->ModelViewInv );
if (ctx->Visual->RGBAflag) {
GLubyte color[4];
gl_color_shade_vertices( ctx, 0, 1, &eye, &eyenorm, &color );
ctx->Current.RasterColor[0] = color[0] * ctx->Visual->InvRedScale;
ctx->Current.RasterColor[1] = color[1] * ctx->Visual->InvGreenScale;
ctx->Current.RasterColor[2] = color[2] * ctx->Visual->InvBlueScale;
ctx->Current.RasterColor[3] = color[3] * ctx->Visual->InvAlphaScale;
}
else {
	 gl_index_shade_vertices( ctx, 0, 1, &eye, &eyenorm,
&ctx->Current.RasterIndex );
}
}
else {
if (ctx->Visual->RGBAflag) {
float *rc = ctx->Current.RasterColor;
rc[0] = ctx->Current.ByteColor[0] * ctx->Visual->InvRedScale;
rc[1] = ctx->Current.ByteColor[1] * ctx->Visual->InvGreenScale;
rc[2] = ctx->Current.ByteColor[2] * ctx->Visual->InvBlueScale;
rc[3] = ctx->Current.ByteColor[3] * ctx->Visual->InvAlphaScale;
}
else {
	 ctx->Current.RasterIndex = ctx->Current.Index;
}
}
if (gl_userclip_point(ctx, eye)==0) {
ctx->Current.RasterPosValid = GL_FALSE;
return;
}
ctx->Current.RasterDistance =
GL_SQRT( eye[0]*eye[0] + eye[1]*eye[1] + eye[2]*eye[2] );
TRANSFORM_POINT( clip, ctx->ProjectionMatrix, eye );
if (gl_viewclip_point( clip )==0) {
ctx->Current.RasterPosValid = GL_FALSE;
return;
}
ASSERT( clip[3]!=0.0 );
d = 1.0F / clip[3];
ndc[0] = clip[0] * d;
ndc[1] = clip[1] * d;
ndc[2] = clip[2] * d;
ctx->Current.RasterPos[0] = ndc[0] * ctx->Viewport.Sx + ctx->Viewport.Tx;
ctx->Current.RasterPos[1] = ndc[1] * ctx->Viewport.Sy + ctx->Viewport.Ty;
ctx->Current.RasterPos[2] = (ndc[2] * ctx->Viewport.Sz + ctx->Viewport.Tz)
/ DEPTH_SCALE;
ctx->Current.RasterPos[3] = clip[3];
ctx->Current.RasterPosValid = GL_TRUE;
if (ctx->Texture.Enabled) {
COPY_4V( ctx->Current.RasterTexCoord, ctx->Current.TexCoord );
}
if (ctx->RenderMode==GL_SELECT) {
gl_update_hitflag( ctx, ctx->Current.RasterPos[2] );
}
}
void gl_windowpos( GLcontext *ctx, float x, float y, float z, float w )
{
ctx->Current.RasterPos[0] = x;
ctx->Current.RasterPos[1] = y;
ctx->Current.RasterPos[2] = CLAMP( z, 0.0F, 1.0F );
ctx->Current.RasterPos[3] = w;
ctx->Current.RasterPosValid = GL_TRUE;
if (ctx->Light.Enabled) {
float eye[4];
float eyenorm[3];
COPY_4V( eye, ctx->Current.RasterPos );
if (ctx->NewModelViewMatrix) {
	 gl_analyze_modelview_matrix(ctx);
}
TRANSFORM_NORMAL( eyenorm[0], eyenorm[1], eyenorm[2],
ctx->Current.Normal,
ctx->ModelViewInv );
if (ctx->Visual->RGBAflag) {
GLubyte color[4];
gl_color_shade_vertices( ctx, 0, 1, &eye, &eyenorm, &color );
ASSIGN_4V( ctx->Current.RasterColor,
(float) color[0] * ctx->Visual->InvRedScale,
(float) color[1] * ctx->Visual->InvGreenScale,
(float) color[2] * ctx->Visual->InvBlueScale,
(float) color[3] * ctx->Visual->InvAlphaScale );
}
else {
	 gl_index_shade_vertices( ctx, 0, 1, &eye, &eyenorm,
&ctx->Current.RasterIndex );
}
}
else {
if (ctx->Visual->RGBAflag) {
ASSIGN_4V( ctx->Current.RasterColor,
ctx->Current.ByteColor[0] * ctx->Visual->InvRedScale,
ctx->Current.ByteColor[1] * ctx->Visual->InvGreenScale,
ctx->Current.ByteColor[2] * ctx->Visual->InvBlueScale,
ctx->Current.ByteColor[3] * ctx->Visual->InvAlphaScale );
}
else {
	 ctx->Current.RasterIndex = ctx->Current.Index;
}
}
ctx->Current.RasterDistance = 0.0;
if (ctx->Texture.Enabled) {
COPY_4V( ctx->Current.RasterTexCoord, ctx->Current.TexCoord );
}
if (ctx->RenderMode==GL_SELECT) {
gl_update_hitflag( ctx, ctx->Current.RasterPos[2] );
}
}
/* 当前文件是D:\Read\readpix.c*/

#ifdef PC_HEADER
#else
#endif
static void read_index_pixels1( GLcontext *ctx,
GLint x, GLint y,
			       GLsizei width, GLsizei height,
			       GLenum type, GLvoid *pixels )
{
GLint i, j;
GLuint a, s, k, l, start;
if (ctx->Visual->RGBAflag) {
gl_error( ctx, GL_INVALID_OPERATION, "glReadPixels" );
return;
}
s = gl_sizeof_type( type );
if (s<=0) {
gl_error( ctx, GL_INVALID_ENUM, "glReadPixels(type)" );
return;
}
a = ctx->Pack.Alignment;
if (ctx->Pack.RowLength>0) {
l = ctx->Pack.RowLength;
}
else {
l = width;
}
if (s>=a) {
k = l;
}
else {
k = a/s * CEILING( s*l, a );
}
start = ctx->Pack.SkipRows * k + ctx->Pack.SkipPixels;
for (j=0;j<height;j++,y++) {
GLuint index[MAX_WIDTH];
(*ctx->Driver.ReadIndexSpan)( ctx, width, x, y, index );
if (ctx->Pixel.IndexShift!=0 || ctx->Pixel.IndexOffset!=0) {
	 GLuint s;
	 if (ctx->Pixel.IndexShift<0) {
	
	    s = -ctx->Pixel.IndexShift;
	    for (i=0;i<width;i++) {
	       index[i] = (index[i] >> s) + ctx->Pixel.IndexOffset;
	    }
	 }
	 else {
	
	    s = ctx->Pixel.IndexShift;
	    for (i=0;i<width;i++) {
	       index[i] = (index[i] << s) + ctx->Pixel.IndexOffset;
	    }
	 }
}
if (ctx->Pixel.MapColorFlag) {
	 for (i=0;i<width;i++) {
	    index[i] = ctx->Pixel.MapItoI[ index[i] ];
	 }
}
switch (type) {
	 case GL_UNSIGNED_BYTE:
	    {
	       GLubyte *dst = (GLubyte *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (GLubyte) index[i];
	       }
	    }
	    break;
	 case GL_BYTE:
	    {
	       GLbyte *dst = (GLbyte *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (GLbyte) index[i];
	       }
	    }
	    break;
	 case GL_UNSIGNED_SHORT:
	    {
	       GLushort *dst = (GLushort *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (GLushort) index[i];
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap2( (GLushort *) pixels + start + j * k, width );
	       }
	    }
	    break;
	 case GL_SHORT:
	    {
	       GLshort *dst = (GLshort *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (GLshort) index[i];
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap2( (GLushort *) pixels + start + j * k, width );
	       }
	    }
	    break;
	 case GL_UNSIGNED_INT:
	    {
	       GLuint *dst = (GLuint *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (GLuint) index[i];
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap4( (GLuint *) pixels + start + j * k, width );
	       }
	    }
	    break;
	 case GL_INT:
	    {
	       GLint *dst = (GLint *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (GLint) index[i];
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap4( (GLuint *) pixels + start + j * k, width );
	       }
	    }
	    break;
	 case GL_FLOAT:
	    {
	       float *dst = (float *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (float) index[i];
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap4( (GLuint *) pixels + start + j * k, width );
	       }
	    }
	    break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glReadPixels(type)" );
}
}
}
static void read_depth_pixels( GLcontext *ctx,
GLint x, GLint y,
			       GLsizei width, GLsizei height,
			       GLenum type, GLvoid *pixels )
{
GLint i, j;
GLuint a, s, k, l, start;
GLboolean bias_or_scale;
if (ctx->Visual->DepthBits<=0) {
gl_error( ctx, GL_INVALID_OPERATION, "glReadPixels" );
return;
}
bias_or_scale = ctx->Pixel.DepthBias!=0.0 || ctx->Pixel.DepthScale!=1.0;
s = gl_sizeof_type( type );
if (s<=0) {
gl_error( ctx, GL_INVALID_ENUM, "glReadPixels(type)" );
return;
}
a = ctx->Pack.Alignment;
if (ctx->Pack.RowLength>0) {
l = ctx->Pack.RowLength;
}
else {
l = width;
}
if (s>=a) {
k = l;
}
else {
k = a/s * CEILING( s*l, a );
}
start = ctx->Pack.SkipRows * k + ctx->Pack.SkipPixels;
if (type==GL_UNSIGNED_SHORT && sizeof(GLdepth)==sizeof(GLushort)
&& !bias_or_scale && !ctx->Pack.SwapBytes) {
for (j=0;j<height;j++,y++) {
GLushort *dst = (GLushort *) pixels + start + j * k;
(*ctx->Driver.ReadDepthSpanInt)( ctx, width, x, y, (GLdepth*) dst);
}
}
else if (type==GL_UNSIGNED_INT && sizeof(GLdepth)==sizeof(GLuint)
&& !bias_or_scale && !ctx->Pack.SwapBytes) {
GLuint shift = 0;
GLuint max = MAX_DEPTH;
while ((max&0x80000000)==0) {
max = max << 1;
shift++;
}
for (j=0;j<height;j++,y++) {
GLuint *dst = (GLuint *) pixels + start + j * k;
(*ctx->Driver.ReadDepthSpanInt)( ctx, width, x, y, (GLdepth*) dst);
for (i=0;i<width;i++) {
dst[i] = dst[i] << shift;
}
}
}
else {
for (j=0;j<height;j++,y++) {
float depth[MAX_WIDTH];
(*ctx->Driver.ReadDepthSpanFloat)( ctx, width, x, y, depth );
if (bias_or_scale) {
for (i=0;i<width;i++) {
float d;
d = depth[i] * ctx->Pixel.DepthScale + ctx->Pixel.DepthBias;
depth[i] = CLAMP( d, 0.0, 1.0 );
}
}
switch (type) {
case GL_UNSIGNED_BYTE:
{
GLubyte *dst = (GLubyte *) pixels + start + j * k;
for (i=0;i<width;i++) {
*dst++ = FLOAT_TO_UBYTE( depth[i] );
}
}
break;
case GL_BYTE:
{
GLbyte *dst = (GLbyte *) pixels + start + j * k;
for (i=0;i<width;i++) {
*dst++ = FLOAT_TO_BYTE( depth[i] );
}
}
break;
case GL_UNSIGNED_SHORT:
{
GLushort *dst = (GLushort *) pixels + start + j * k;
for (i=0;i<width;i++) {
*dst++ = FLOAT_TO_USHORT( depth[i] );
}
if (ctx->Pack.SwapBytes) {
gl_swap2( (GLushort *) pixels + start + j * k, width );
}
}
break;
case GL_SHORT:
{
GLshort *dst = (GLshort *) pixels + start + j * k;
for (i=0;i<width;i++) {
*dst++ = FLOAT_TO_SHORT( depth[i] );
}
if (ctx->Pack.SwapBytes) {
gl_swap2( (GLushort *) pixels + start + j * k, width );
}
}
break;
case GL_UNSIGNED_INT:
{
GLuint *dst = (GLuint *) pixels + start + j * k;
for (i=0;i<width;i++) {
*dst++ = FLOAT_TO_UINT( depth[i] );
}
if (ctx->Pack.SwapBytes) {
gl_swap4( (GLuint *) pixels + start + j * k, width );
}
}
break;
case GL_INT:
{
GLint *dst = (GLint *) pixels + start + j * k;
for (i=0;i<width;i++) {
*dst++ = FLOAT_TO_INT( depth[i] );
}
if (ctx->Pack.SwapBytes) {
gl_swap4( (GLuint *) pixels + start + j * k, width );
}
}
break;
case GL_FLOAT:
{
float *dst = (float *) pixels + start + j * k;
for (i=0;i<width;i++) {
*dst++ = depth[i];
}
if (ctx->Pack.SwapBytes) {
gl_swap4( (GLuint *) pixels + start + j * k, width );
}
}
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glReadPixels(type)" );
}
}
}
}
static void read_stencil_pixels( GLcontext *ctx,
GLint x, GLint y,
				 GLsizei width, GLsizei height,
				 GLenum type, GLvoid *pixels )
{
GLint i, j;
GLuint a, s, k, l, start;
GLboolean shift_or_offset;
if (ctx->Visual->StencilBits<=0) {
gl_error( ctx, GL_INVALID_OPERATION, "glReadPixels" );
return;
}
shift_or_offset = ctx->Pixel.IndexShift!=0 || ctx->Pixel.IndexOffset!=0;
s = gl_sizeof_type( type );
if (s<=0) {
gl_error( ctx, GL_INVALID_ENUM, "glReadPixels(type)" );
return;
}
a = ctx->Pack.Alignment;
if (ctx->Pack.RowLength>0) {
l = ctx->Pack.RowLength;
}
else {
l = width;
}
if (s>=a) {
k = l;
}
else {
k = a/s * CEILING( s*l, a );
}
start = ctx->Pack.SkipRows * k + ctx->Pack.SkipPixels;
for (j=0;j<height;j++,y++) {
GLubyte stencil[MAX_WIDTH];
gl_read_stencil_span( ctx, width, x, y, stencil );
if (shift_or_offset) {
	 GLuint s;
	 if (ctx->Pixel.IndexShift<0) {
	
	    s = -ctx->Pixel.IndexShift;
	    for (i=0;i<width;i++) {
	       stencil[i] = (stencil[i] >> s) + ctx->Pixel.IndexOffset;
	    }
	 }
	 else {
	
	    s = ctx->Pixel.IndexShift;
	    for (i=0;i<width;i++) {
	       stencil[i] = (stencil[i] << s) + ctx->Pixel.IndexOffset;
	    }
	 }
}
if (ctx->Pixel.MapStencilFlag) {
	 for (i=0;i<width;i++) {
	    stencil[i] = ctx->Pixel.MapStoS[ stencil[i] ];
	 }
}
switch (type) {
	 case GL_UNSIGNED_BYTE:
	    {
	       GLubyte *dst = (GLubyte *) pixels + start + j * k;
	       MEMCPY( dst, stencil, width );
	    }
	    break;
	 case GL_BYTE:
	    {
	       GLbyte *dst = (GLbyte  *) pixels + start + j * k;
	       MEMCPY( dst, stencil, width );
	    }
	    break;
	 case GL_UNSIGNED_SHORT:
	    {
	       GLushort *dst = (GLushort *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (GLushort) stencil[i];
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap2( (GLushort *) pixels + start +j * k, width );
	       }
	    }
	    break;
	 case GL_SHORT:
	    {
	       GLshort *dst = (GLshort *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (GLshort) stencil[i];
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap2( (GLushort *) pixels + start +j * k, width );
	       }
	    }
	    break;
	 case GL_UNSIGNED_INT:
	    {
	       GLuint *dst = (GLuint *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (GLuint) stencil[i];
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap4( (GLuint *) pixels + start +j * k, width );
	       }
	    }
	    break;
	 case GL_INT:
	    {
	       GLint *dst = (GLint *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (GLint) stencil[i];
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap4( (GLuint *) pixels + start +j * k, width );
	       }
	    }
	    break;
	 case GL_FLOAT:
	    {
	       float *dst = (float *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  *dst++ = (float) stencil[i];
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap4( (GLuint *) pixels + start +j * k, width );
	       }
	    }
	    break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glReadPixels(type)" );
}
}
}
static GLboolean scale_or_bias_rgba( GLcontext *ctx )
{
if (ctx->Pixel.RedScale!=1.0F   || ctx->Pixel.RedBias!=0.0F ||
ctx->Pixel.GreenScale!=1.0F || ctx->Pixel.GreenBias!=0.0F ||
ctx->Pixel.BlueScale!=1.0F  || ctx->Pixel.BlueBias!=0.0F ||
ctx->Pixel.AlphaScale!=1.0F || ctx->Pixel.AlphaBias!=0.0F) {
return GL_TRUE;
}
else {
return GL_FALSE;
}
}
static void scale_and_bias_rgba( GLcontext *ctx,
GLint n,
				 float red[], float green[],
				 float blue[], float alpha[] )
{
register GLint i;
register float r, g, b, a;
for (i=0;i<n;i++) {
r = red[i]   * ctx->Pixel.RedScale   + ctx->Pixel.RedBias;
g = green[i] * ctx->Pixel.GreenScale + ctx->Pixel.GreenBias;
b = blue[i]  * ctx->Pixel.BlueScale  + ctx->Pixel.BlueBias;
a = alpha[i] * ctx->Pixel.AlphaScale + ctx->Pixel.AlphaBias;
red[i]   = CLAMP( r, 0.0F, 1.0F );
green[i] = CLAMP( g, 0.0F, 1.0F );
blue[i]  = CLAMP( b, 0.0F, 1.0F );
alpha[i] = CLAMP( a, 0.0F, 1.0F );
}
}
static void map_rgba( GLcontext *ctx,
GLint n,
		      float red[], float green[],
		      float blue[], float alpha[] )
{
float rscale = ctx->Pixel.MapRtoRsize-1;
float gscale = ctx->Pixel.MapGtoGsize-1;
float bscale = ctx->Pixel.MapBtoBsize-1;
float ascale = ctx->Pixel.MapAtoAsize-1;
GLint i;
for (i=0;i<n;i++) {
red[i]   = ctx->Pixel.MapRtoR[ (GLint) (red[i]   * rscale) ];
green[i] = ctx->Pixel.MapGtoG[ (GLint) (green[i] * gscale) ];
blue[i]  = ctx->Pixel.MapBtoB[ (GLint) (blue[i]  * bscale) ];
alpha[i] = ctx->Pixel.MapAtoA[ (GLint) (alpha[i] * ascale) ];
}
}
static void read_color_pixels1( GLcontext *ctx,
GLint x, GLint y,
			       GLsizei width, GLsizei height,
			       GLenum format, GLenum type, GLvoid *pixels )
{
GLint i, j, n, a, s, l, k;
GLboolean scale_or_bias;
DEFARRAY(float, red, MAX_WIDTH);
DEFARRAY(float, green, MAX_WIDTH);
DEFARRAY(float, blue, MAX_WIDTH);
DEFARRAY(float, alpha, MAX_WIDTH);
DEFARRAY(float, luminance, MAX_WIDTH);
GLboolean r_flag, g_flag, b_flag, a_flag, l_flag;
GLuint start;
scale_or_bias = scale_or_bias_rgba( ctx );
r_flag = g_flag = b_flag = a_flag = l_flag = GL_FALSE;
switch (format) {
case GL_RED:				r_flag = GL_TRUE;  n = 1;  break;
case GL_GREEN:				g_flag = GL_TRUE;  n = 1;  break;
case GL_BLUE:				b_flag = GL_TRUE;  n = 1;  break;
case GL_ALPHA:				a_flag = GL_TRUE;  n = 1;  break;
case GL_LUMINANCE:			l_flag = GL_TRUE;  n = 1;  break;
case GL_LUMINANCE_ALPHA:	       l_flag = a_flag = GL_TRUE;  n = 2;  break;
case GL_RGB:	      r_flag = g_flag = b_flag = GL_TRUE;  n = 3;  break;
case GL_RGBA:  r_flag = g_flag = b_flag = a_flag = GL_TRUE;  n = 4;  break;
default:
	 gl_error( ctx, GL_INVALID_ENUM, "glReadPixels(format)" );
UNDEFARRAY( red );
UNDEFARRAY( green );
UNDEFARRAY( blue );
UNDEFARRAY( alpha );
UNDEFARRAY( luminance );
return;
}
s = gl_sizeof_type( type );
if (s<=0) {
gl_error( ctx, GL_INVALID_ENUM, "glReadPixels(type)" );
UNDEFARRAY( red );
UNDEFARRAY( green );
UNDEFARRAY( blue );
UNDEFARRAY( alpha );
UNDEFARRAY( luminance );
return;
}
a = ctx->Pack.Alignment;
if (ctx->Pack.RowLength>0) {
l = ctx->Pack.RowLength;
}
else {
l = width;
}
if (s>=a) {
k = n * l;
}
else {
k = a/s * CEILING( s*n*l, a );
}
start = ctx->Pack.SkipRows * k + ctx->Pack.SkipPixels * n;
for (j=0;j<height;j++,y++) {
if (ctx->Visual->RGBAflag) {
DEFARRAY(GLubyte, r, MAX_WIDTH);
DEFARRAY(GLubyte, g, MAX_WIDTH);
DEFARRAY(GLubyte, b, MAX_WIDTH);
DEFARRAY(GLubyte, a, MAX_WIDTH);
	 float rscale = 1.0F * ctx->Visual->InvRedScale;
	 float gscale = 1.0F * ctx->Visual->InvGreenScale;
	 float bscale = 1.0F * ctx->Visual->InvBlueScale;
	 float ascale = 1.0F * ctx->Visual->InvAlphaScale;
	
	 (*ctx->Driver.ReadColorSpan)( ctx, width, x, y, r, g, b, a );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_read_alpha_span( ctx, width, x, y, a );
}
	 for (i=0;i<width;i++) {
	    red[i]   = r[i] * rscale;
	    green[i] = g[i] * gscale;
	    blue[i]  = b[i] * bscale;
	    alpha[i] = a[i] * ascale;
	 }
	 if (scale_or_bias) {
	    scale_and_bias_rgba( ctx, width, red, green, blue, alpha );
	 }
	 if (ctx->Pixel.MapColorFlag) {
	    map_rgba( ctx, width, red, green, blue, alpha );
	 }
UNDEFARRAY(r);
UNDEFARRAY(g);
UNDEFARRAY(b);
UNDEFARRAY(a);
}
else {
	
	 GLuint index[MAX_WIDTH];
	 (*ctx->Driver.ReadIndexSpan)( ctx, width, x, y, index );
	 if (ctx->Pixel.IndexShift!=0 || ctx->Pixel.IndexOffset!=0) {
	    GLuint s;
	    if (ctx->Pixel.IndexShift<0) {
	
	       s = -ctx->Pixel.IndexShift;
	       for (i=0;i<width;i++) {
		  index[i] = (index[i] >> s) + ctx->Pixel.IndexOffset;
	       }
	    }
	    else {
	
	       s = ctx->Pixel.IndexShift;
	       for (i=0;i<width;i++) {
		  index[i] = (index[i] << s) + ctx->Pixel.IndexOffset;
	       }
	    }
	 }
	 for (i=0;i<width;i++) {
	    red[i]   = ctx->Pixel.MapItoR[ index[i] ];
	    green[i] = ctx->Pixel.MapItoG[ index[i] ];
	    blue[i]  = ctx->Pixel.MapItoB[ index[i] ];
	    alpha[i] = ctx->Pixel.MapItoA[ index[i] ];
	 }
}
if (l_flag) {
for (i=0;i<width;i++) {
float sum = red[i] + green[i] + blue[i];
luminance[i] = CLAMP( sum, 0.0F, 1.0F );
}
}
switch (type) {
	 case GL_UNSIGNED_BYTE:
	    {
	       GLubyte *dst = (GLubyte *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  if (r_flag)  *dst++ = FLOAT_TO_UBYTE( red[i] );
		  if (g_flag)  *dst++ = FLOAT_TO_UBYTE( green[i] );
		  if (b_flag)  *dst++ = FLOAT_TO_UBYTE( blue[i] );
		  if (l_flag)  *dst++ = FLOAT_TO_UBYTE( luminance[i] );
		  if (a_flag)  *dst++ = FLOAT_TO_UBYTE( alpha[i] );
	       }
	    }
	    break;
	 case GL_BYTE:
	    {
	       GLbyte *dst = (GLbyte *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  if (r_flag)  *dst++ = FLOAT_TO_BYTE( red[i] );
		  if (g_flag)  *dst++ = FLOAT_TO_BYTE( green[i] );
		  if (b_flag)  *dst++ = FLOAT_TO_BYTE( blue[i] );
		  if (l_flag)  *dst++ = FLOAT_TO_BYTE( luminance[i] );
		  if (a_flag)  *dst++ = FLOAT_TO_BYTE( alpha[i] );
	       }
	    }
	    break;
	 case GL_UNSIGNED_SHORT:
	    {
	       GLushort *dst = (GLushort *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  if (r_flag)  *dst++ = FLOAT_TO_USHORT( red[i] );
		  if (g_flag)  *dst++ = FLOAT_TO_USHORT( green[i] );
		  if (b_flag)  *dst++ = FLOAT_TO_USHORT( blue[i] );
		  if (l_flag)  *dst++ = FLOAT_TO_USHORT( luminance[i] );
		  if (a_flag)  *dst++ = FLOAT_TO_USHORT( alpha[i] );
	       }
	    }
	    if (ctx->Pack.SwapBytes) {
	       gl_swap2( (GLushort *) pixels + start + j * k, width*n );
	    }
	    break;
	 case GL_SHORT:
	    {
	       GLshort *dst = (GLshort *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  if (r_flag)  *dst++ = FLOAT_TO_SHORT( red[i] );
		  if (g_flag)  *dst++ = FLOAT_TO_SHORT( green[i] );
		  if (b_flag)  *dst++ = FLOAT_TO_SHORT( blue[i] );
		  if (l_flag)  *dst++ = FLOAT_TO_SHORT( luminance[i] );
		  if (a_flag)  *dst++ = FLOAT_TO_SHORT( alpha[i] );
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap2( (GLushort *) pixels + start + j * k, width*n );
	       }
	    }
	    break;
	 case GL_UNSIGNED_INT:
	    {
	       GLuint *dst = (GLuint *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  if (r_flag)  *dst++ = FLOAT_TO_UINT( red[i] );
		  if (g_flag)  *dst++ = FLOAT_TO_UINT( green[i] );
		  if (b_flag)  *dst++ = FLOAT_TO_UINT( blue[i] );
		  if (l_flag)  *dst++ = FLOAT_TO_UINT( luminance[i] );
		  if (a_flag)  *dst++ = FLOAT_TO_UINT( alpha[i] );
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap4( (GLuint *) pixels + start + j * k, width*n );
	       }
	    }
	    break;
	 case GL_INT:
	    {
	       GLint *dst = (GLint *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  if (r_flag)  *dst++ = FLOAT_TO_INT( red[i] );
		  if (g_flag)  *dst++ = FLOAT_TO_INT( green[i] );
		  if (b_flag)  *dst++ = FLOAT_TO_INT( blue[i] );
		  if (l_flag)  *dst++ = FLOAT_TO_INT( luminance[i] );
		  if (a_flag)  *dst++ = FLOAT_TO_INT( alpha[i] );
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap4( (GLuint *) pixels + start + j * k, width*n );
	       }
	    }
	    break;
	 case GL_FLOAT:
	    {
	       float *dst = (float *) pixels + start + j * k;
	       for (i=0;i<width;i++) {
		  if (r_flag)  *dst++ = red[i];
		  if (g_flag)  *dst++ = green[i];
		  if (b_flag)  *dst++ = blue[i];
		  if (l_flag)  *dst++ = luminance[i];
		  if (a_flag)  *dst++ = alpha[i];
	       }
	       if (ctx->Pack.SwapBytes) {
		  gl_swap4( (GLuint *) pixels + start + j * k, width*n );
	       }
	    }
	    break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glReadPixels(type)" );
}
}
UNDEFARRAY( red );
UNDEFARRAY( green );
UNDEFARRAY( blue );
UNDEFARRAY( alpha );
UNDEFARRAY( luminance );
}
void gl_ReadPixels( GLcontext *ctx,
GLint x, GLint y, GLsizei width, GLsizei height,
		    GLenum format, GLenum type, GLvoid *pixels )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glReadPixels" );
return;
}
(void) (*ctx->Driver.SetBuffer)( ctx, ctx->Pixel.ReadBuffer );
switch (format) {
case GL_COLOR_INDEX:
read_index_pixels1( ctx, x, y, width, height, type, pixels );
	 break;
case GL_STENCIL_INDEX:
	 read_stencil_pixels( ctx, x, y, width, height, type, pixels );
break;
case GL_DEPTH_COMPONENT:
	 read_depth_pixels( ctx, x, y, width, height, type, pixels );
	 break;
case GL_RED:
case GL_GREEN:
case GL_BLUE:
case GL_ALPHA:
case GL_RGB:
case GL_LUMINANCE:
case GL_LUMINANCE_ALPHA:
case GL_RGBA:
	 read_color_pixels1( ctx, x, y, width, height, format, type, pixels );
	 break;
default:
	 gl_error( ctx, GL_INVALID_ENUM, "glReadPixels(format)" );
}
(void) (*ctx->Driver.SetBuffer)( ctx, ctx->Color.DrawBuffer );
}
/* 当前文件是D:\Read\rect.c*/

#ifdef PC_HEADER
#else
#endif
void gl_Rectf( GLcontext *ctx, float x1, float y1, float x2, float y2 )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glRect" );
return;
}
gl_Begin( ctx, GL_QUADS );
(*ctx->Exec.Vertex2f)( ctx, x1, y1 );
(*ctx->Exec.Vertex2f)( ctx, x2, y1 );
(*ctx->Exec.Vertex2f)( ctx, x2, y2 );
(*ctx->Exec.Vertex2f)( ctx, x1, y2 );
gl_End( ctx );
}
/* 当前文件是D:\Read\scissor.c*/

#ifdef PC_HEADER
#else
#endif
void gl_Scissor( GLcontext *ctx,
GLint x, GLint y, GLsizei width, GLsizei height )
{
if (width<0 || height<0) {
gl_error( ctx, GL_INVALID_VALUE, "glScissor" );
return;
}
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glBegin" );
return;
}
ctx->Scissor.X = x;
ctx->Scissor.Y = y;
ctx->Scissor.Width = width;
ctx->Scissor.Height = height;
ctx->NewState |= NEW_ALL;
}
GLint gl_scissor_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLubyte mask[] )
{
if (y<ctx->Buffer->Ymin || y>ctx->Buffer->Ymax
|| x>ctx->Buffer->Xmax || x+(GLint)n-1<ctx->Buffer->Xmin) {
return 0;
}
else {
GLint i;
GLint xMin = ctx->Buffer->Xmin;
GLint xMax = ctx->Buffer->Xmax;
for (i=0; x+i < xMin; i++) {
mask[i] = 0;
}
for (i=(GLint)n-1; x+i > xMax; i--) {
mask[i] = 0;
}
return 1;
}
}
GLuint gl_scissor_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
GLubyte mask[] )
{
GLint xmin = ctx->Buffer->Xmin;
GLint xmax = ctx->Buffer->Xmax;
GLint ymin = ctx->Buffer->Ymin;
GLint ymax = ctx->Buffer->Ymax;
GLuint i;
for (i=0;i<n;i++) {
mask[i] &= (x[i]>=xmin) & (x[i]<=xmax) & (y[i]>=ymin) & (y[i]<=ymax);
}
return 1;
}
/* 当前文件是D:\Read\shade.c*/

#ifdef PC_HEADER
#else
#endif
static float gl_pow( float x, float y )
{
GLdouble z = pow(x, y);
if (z<1.0e-10)
return 0.0F;
else
return (float) z;
}
void gl_color_shade_vertices( GLcontext *ctx,
GLuint side,
GLuint n,
float vertex[][4],
float normal[][3],
GLubyte color[][4] )
{
GLint j;
float rscale, gscale, bscale, ascale;
float baseR, baseG, baseB, baseA;
GLint sumA;
struct gl_light *light;
struct gl_material *mat;
rscale = ctx->Visual->RedScale;
gscale = ctx->Visual->GreenScale;
bscale = ctx->Visual->BlueScale;
ascale = ctx->Visual->AlphaScale;
mat = &ctx->Light.Material[side];
baseR = mat->Emission[0] + ctx->Light.Model.Ambient[0] * mat->Ambient[0];
baseG = mat->Emission[1] + ctx->Light.Model.Ambient[1] * mat->Ambient[1];
baseB = mat->Emission[2] + ctx->Light.Model.Ambient[2] * mat->Ambient[2];
baseA = mat->Diffuse[3];
sumA = (GLint) (CLAMP( baseA, 0.0F, 1.0F ) * ascale);
for (j=0;j<n;j++) {
float sumR, sumG, sumB;
float nx, ny, nz;
if (side==0) {
nx = normal[j][0];
ny = normal[j][1];
nz = normal[j][2];
}
else {
nx = -normal[j][0];
ny = -normal[j][1];
nz = -normal[j][2];
}
sumR = baseR;
sumG = baseG;
sumB = baseB;
for (light=ctx->Light.FirstEnabled; light; light=light->NextEnabled) {
float ambientR, ambientG, ambientB;
float attenuation, spot;
float VPx, VPy, VPz;
float n_dot_VP;
if (light->Position[3]==0.0) {
VPx = light->VP_inf_norm[0];
VPy = light->VP_inf_norm[1];
VPz = light->VP_inf_norm[2];
attenuation = 1.0F;
}
else {
float d;
VPx = light->Position[0] - vertex[j][0];
VPy = light->Position[1] - vertex[j][1];
VPz = light->Position[2] - vertex[j][2];
d = (float) GL_SQRT( VPx*VPx + VPy*VPy + VPz*VPz );
if (d>0.001F) {
float invd = 1.0F / d;
VPx *= invd;
VPy *= invd;
VPz *= invd;
}
attenuation = 1.0F / (light->ConstantAttenuation
+ d * (light->LinearAttenuation
+ d * light->QuadraticAttenuation));
}
if (light->SpotCutoff==180.0F) {
spot = 1.0F;
}
else {
float PVx, PVy, PVz, PV_dot_dir;
PVx = -VPx;
PVy = -VPy;
PVz = -VPz;
PV_dot_dir = PVx*light->NormDirection[0]
+ PVy*light->NormDirection[1]
+ PVz*light->NormDirection[2];
if (PV_dot_dir<=0.0F || PV_dot_dir<light->CosCutoff) {
spot = 0.0F;
}
else {
double x = PV_dot_dir * (EXP_TABLE_SIZE-1);
int k = (int) x;
spot = light->SpotExpTable[k][0]
+ (x-k)*light->SpotExpTable[k][1];
}
}
ambientR = mat->Ambient[0] * light->Ambient[0];
ambientG = mat->Ambient[1] * light->Ambient[1];
ambientB = mat->Ambient[2] * light->Ambient[2];
n_dot_VP = nx * VPx + ny * VPy + nz * VPz;
if (n_dot_VP<=0.0F) {
float t = attenuation * spot;
sumR += t * ambientR;
sumG += t * ambientG;
sumB += t * ambientB;
}
else {
float diffuseR, diffuseG, diffuseB;
float specularR, specularG, specularB;
float h_x, h_y, h_z, n_dot_h, t;
diffuseR = n_dot_VP * mat->Diffuse[0] * light->Diffuse[0];
diffuseG = n_dot_VP * mat->Diffuse[1] * light->Diffuse[1];
diffuseB = n_dot_VP * mat->Diffuse[2] * light->Diffuse[2];
if (ctx->Light.Model.LocalViewer) {
float vx, vy, vz, vlen;
vx = vertex[j][0];
vy = vertex[j][1];
vz = vertex[j][2];
vlen = GL_SQRT( vx*vx + vy*vy + vz*vz );
if (vlen>0.0001F) {
float invlen = 1.0F / vlen;
vx *= invlen;
vy *= invlen;
vz *= invlen;
}
h_x = VPx - vx;
h_y = VPy - vy;
h_z = VPz - vz;
}
else {
h_x = VPx;
h_y = VPy;
h_z = VPz + 1.0F;
}
n_dot_h = nx*h_x + ny*h_y + nz*h_z;
if (n_dot_h<=0.0F) {
specularR = 0.0F;
specularG = 0.0F;
specularB = 0.0F;
}
else {
float spec_coef;
n_dot_h = n_dot_h / GL_SQRT( h_x*h_x + h_y*h_y + h_z*h_z );
if (n_dot_h>1.0F) {
spec_coef = pow( n_dot_h, mat->Shininess );
}
else {
int k = (int) (n_dot_h * (float) (SHINE_TABLE_SIZE-1));
if (mat->ShineTable[k] < 0.0F)
mat->ShineTable[k] = gl_pow( n_dot_h, mat->Shininess );
spec_coef = mat->ShineTable[k];
}
if (spec_coef<1.0e-10) {
specularR = 0.0F;
specularG = 0.0F;
specularB = 0.0F;
}
else {
specularR = spec_coef * mat->Specular[0]*light->Specular[0];
specularG = spec_coef * mat->Specular[1]*light->Specular[1];
specularB = spec_coef * mat->Specular[2]*light->Specular[2];
}
}
t = attenuation * spot;
sumR += t * (ambientR + diffuseR + specularR);
sumG += t * (ambientG + diffuseG + specularG);
sumB += t * (ambientB + diffuseB + specularB);
}
}
color[j][0] = (GLint) (CLAMP( sumR, 0.0F, 1.0F ) * rscale);
color[j][1] = (GLint) (CLAMP( sumG, 0.0F, 1.0F ) * gscale);
color[j][2] = (GLint) (CLAMP( sumB, 0.0F, 1.0F ) * bscale);
color[j][3] = sumA;
}
}
void gl_color_shade_vertices_fast( GLcontext *ctx,
GLuint side,
GLuint n,
float normal[][3],
GLubyte color[][4] )
{
GLint j;
float rscale, gscale, bscale, ascale;
GLint sumA;
float *baseColor = ctx->Light.BaseColor[side];
rscale = ctx->Visual->RedScale;
gscale = ctx->Visual->GreenScale;
bscale = ctx->Visual->BlueScale;
ascale = ctx->Visual->AlphaScale;
sumA = (GLint) (baseColor[3] * ascale);
for (j=0;j<n;j++) {
float sumR, sumG, sumB;
float nx, ny, nz;
struct gl_light *light;
if (side==0) {
nx = normal[j][0];
ny = normal[j][1];
nz = normal[j][2];
}
else {
nx = -normal[j][0];
ny = -normal[j][1];
nz = -normal[j][2];
}
#ifdef SPEED_HACK
if (nz<0.0F) {
color[j][0] = 0.0F;
color[j][1] = 0.0F;
color[j][2] = 0.0F;
color[j][3] = A;
continue;
}
#endif
sumR = baseColor[0];
sumG = baseColor[1];
sumB = baseColor[2];
for (light=ctx->Light.FirstEnabled; light; light=light->NextEnabled) {
float n_dot_VP;
n_dot_VP = nx * light->VP_inf_norm[0]
+ ny * light->VP_inf_norm[1]
+ nz * light->VP_inf_norm[2];
if (n_dot_VP>0.0F) {
float n_dot_h;
float *lightMatDiffuse = light->MatDiffuse[side];
sumR += n_dot_VP * lightMatDiffuse[0];
sumG += n_dot_VP * lightMatDiffuse[1];
sumB += n_dot_VP * lightMatDiffuse[2];
n_dot_h = nx * light->h_inf_norm[0]
+ ny * light->h_inf_norm[1]
+ nz * light->h_inf_norm[2];
if (n_dot_h>0.0F) {
if (n_dot_h>1.0F) {
float spec_coef = pow( n_dot_h,
ctx->Light.Material[side].Shininess );
if (spec_coef>1.0e-10F) {
sumR += spec_coef * light->MatSpecular[side][0];
sumG += spec_coef * light->MatSpecular[side][1];
sumB += spec_coef * light->MatSpecular[side][2];
}
}
else {
int k = (int) (n_dot_h * (float) (SHINE_TABLE_SIZE-1));
struct gl_material *m = &ctx->Light.Material[side];
float spec_coef;
if (m->ShineTable[k] < 0.0F)
m->ShineTable[k] = gl_pow( n_dot_h, m->Shininess );
spec_coef = m->ShineTable[k];
sumR += spec_coef * light->MatSpecular[side][0];
sumG += spec_coef * light->MatSpecular[side][1];
sumB += spec_coef * light->MatSpecular[side][2];
}
}
}
}
color[j][0] = (GLint) (MIN2( sumR, 1.0F ) * rscale);
color[j][1] = (GLint) (MIN2( sumG, 1.0F ) * gscale);
color[j][2] = (GLint) (MIN2( sumB, 1.0F ) * bscale);
color[j][3] = sumA;
}
}
void gl_index_shade_vertices( GLcontext *ctx,
GLuint side,
GLuint n,
float vertex[][4],
float normal[][3],
GLuint indexResult[] )
{
struct gl_material *mat = &ctx->Light.Material[side];
GLint j;
for (j=0;j<n;j++) {
float index;
float diffuse, specular;
float nx, ny, nz;
struct gl_light *light;
if (side==0) {
nx = normal[j][0];
ny = normal[j][1];
nz = normal[j][2];
}
else {
nx = -normal[j][0];
ny = -normal[j][1];
nz = -normal[j][2];
}
diffuse = specular = 0.0F;
for (light=ctx->Light.FirstEnabled; light; light=light->NextEnabled) {
float attenuation;
float lx, ly, lz;
float l_dot_norm;
if (light->Position[3]==0.0) {
lx = light->VP_inf_norm[0];
ly = light->VP_inf_norm[1];
lz = light->VP_inf_norm[2];
attenuation = 1.0F;
}
else {
float d;
lx = light->Position[0] - vertex[j][0];
ly = light->Position[1] - vertex[j][1];
lz = light->Position[2] - vertex[j][2];
d = (float) GL_SQRT( lx*lx + ly*ly + lz*lz );
if (d>0.001F) {
float invd = 1.0F / d;
lx *= invd;
ly *= invd;
lz *= invd;
}
attenuation = 1.0F / (light->ConstantAttenuation
+ d * (light->LinearAttenuation
+ d * light->QuadraticAttenuation));
}
l_dot_norm = lx*nx + ly*ny + lz*nz;
if (l_dot_norm>0.0F) {
float spot_times_atten;
if (light->SpotCutoff==180.0F) {
spot_times_atten = attenuation;
}
else {
float v[3], dot;
v[0] = -lx;
v[1] = -ly;
v[2] = -lz;
dot = DOT3( v, light->NormDirection );
if (dot<=0.0F || dot<light->CosCutoff) {
spot_times_atten = 0.0F;
}
else {
double x = dot * (EXP_TABLE_SIZE-1);
int k = (int) x;
float spot = light->SpotExpTable[k][0]
+ (x-k)*light->SpotExpTable[k][1];
spot_times_atten = spot * attenuation;
}
}
diffuse += l_dot_norm * light->dli * spot_times_atten;
{
float h_x, h_y, h_z, n_dot_h, spec_coef;
if (ctx->Light.Model.LocalViewer) {
float vx, vy, vz, vlen;
vx = vertex[j][0];
vy = vertex[j][1];
vz = vertex[j][2];
vlen = GL_SQRT( vx*vx + vy*vy + vz*vz );
if (vlen>0.0001F) {
float invlen = 1.0F / vlen;
vx *= invlen;
vy *= invlen;
vz *= invlen;
}
h_x = lx - vx;
h_y = ly - vy;
h_z = lz - vz;
}
else {
h_x = lx;
h_y = ly;
h_z = lz + 1.0F;
}
n_dot_h = h_x*nx + h_y*ny + h_z*nz;
if (n_dot_h <= 0.0F) {
spec_coef = 0.0F;
}
else {
n_dot_h = n_dot_h / GL_SQRT(h_x*h_x + h_y*h_y + h_z*h_z);
if (n_dot_h>1.0F) {
spec_coef = pow( n_dot_h, mat->Shininess );
}
else {
int k = (int) (n_dot_h * (float)(SHINE_TABLE_SIZE-1));
if (mat->ShineTable[k] < 0.0F)
mat->ShineTable[k] = gl_pow( n_dot_h, mat->Shininess );
spec_coef = mat->ShineTable[k];
}
}
specular += spec_coef * light->sli * spot_times_atten;
}
}
}
if (specular>1.0F) {
index = mat->SpecularIndex;
}
else {
float d_a, s_a;
d_a = mat->DiffuseIndex - mat->AmbientIndex;
s_a = mat->SpecularIndex - mat->AmbientIndex;
index = mat->AmbientIndex
+ diffuse * (1.0F-specular) * d_a
+ specular * s_a;
if (index>mat->SpecularIndex) {
index = mat->SpecularIndex;
}
}
indexResult[j] = (GLuint) (GLint) index;
}
}
/* 当前文件是D:\Read\span.c*/

#ifdef PC_HEADER
#else
#endif
static void stipple_polygon_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLubyte mask[] )
{
register GLuint i, m, stipple, highbit=0x80000000;
stipple = ctx->PolygonStipple[y % 32];
m = highbit >> (GLuint) (x % 32);
for (i=0;i<n;i++) {
if ((m & stipple)==0) {
	 mask[i] = 0;
}
m = m >> 1;
if (m==0) {
	 m = 0x80000000;
}
}
}
static GLuint clip_span( GLcontext *ctx,
GLint n, GLint x, GLint y, GLubyte mask[] )
{
GLint i;
if (y<0 || y>=ctx->Buffer->Height) {
return 0;
}
if (x>=0 && x+n<=ctx->Buffer->Width) {
return 1;
}
else if (x+n<=0) {
return 0;
}
else if (x>=ctx->Buffer->Width) {
return 0;
}
else {
for (i=0;i<n;i++) {
if (x+i<0 || x+i>=ctx->Buffer->Width) {
mask[i] = 0;
}
}
return 1;
}
}
void gl_write_index_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLdepth z[],
			  GLuint index[], GLenum primitive )
{
GLubyte mask[MAX_WIDTH];
GLuint index_save[MAX_WIDTH];
MEMSET(mask, 1, n);
if ((ctx->RasterMask & WINCLIP_BIT) || primitive==GL_BITMAP) {
if (clip_span(ctx,n,x,y,mask)==0) {
	 return;
}
}
if (ctx->Fog.Enabled
&& (ctx->Hint.Fog==GL_NICEST || primitive==GL_BITMAP)) {
gl_fog_index_pixels( ctx, n, z, index );
}
if (ctx->Scissor.Enabled) {
if (gl_scissor_span( ctx, n, x, y, mask )==0) {
	 return;
}
}
if (ctx->Polygon.StippleFlag && primitive==GL_POLYGON) {
stipple_polygon_span( ctx, n, x, y, mask );
}
if (ctx->Stencil.Enabled) {
if (gl_stencil_span( ctx, n, x, y, mask )==0) {
	 return;
}
gl_depth_stencil_span( ctx, n, x, y, z, mask );
}
else if (ctx->Depth.Test) {
if ((*ctx->Driver.DepthTestSpan)( ctx, n, x, y, z, mask )==0)  return;
}
if (ctx->RasterMask & NO_DRAW_BIT) {
return;
}
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
MEMCPY( index_save, index, n * sizeof(GLuint) );
}
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_ci_span( ctx, n, x, y, index, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_index_span( ctx, n, x, y, index );
}
(*ctx->Driver.WriteIndexSpan)( ctx, n, x, y, index, mask );
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
MEMCPY( index, index_save, n * sizeof(GLuint) );
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_ci_span( ctx, n, x, y, index, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_index_span( ctx, n, x, y, index );
}
(*ctx->Driver.WriteIndexSpan)( ctx, n, x, y, index, mask );
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
}
}
void gl_write_monoindex_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLdepth z[],
			      GLuint index, GLenum primitive )
{
GLuint i;
GLubyte mask[MAX_WIDTH];
GLuint index_save[MAX_WIDTH];
MEMSET(mask, 1, n);
if ((ctx->RasterMask & WINCLIP_BIT) || primitive==GL_BITMAP) {
if (clip_span( ctx,n,x,y,mask)==0) {
	 return;
}
}
if (ctx->Scissor.Enabled) {
if (gl_scissor_span( ctx, n, x, y, mask )==0) {
	 return;
}
}
if (ctx->Polygon.StippleFlag && primitive==GL_POLYGON) {
stipple_polygon_span( ctx, n, x, y, mask );
}
if (ctx->Stencil.Enabled) {
if (gl_stencil_span( ctx, n, x, y, mask )==0) {
	 return;
}
gl_depth_stencil_span( ctx, n, x, y, z, mask );
}
else if (ctx->Depth.Test) {
if ((*ctx->Driver.DepthTestSpan)( ctx, n, x, y, z, mask )==0)  return;
}
if (ctx->RasterMask & NO_DRAW_BIT) {
return;
}
if ((ctx->Fog.Enabled && (ctx->Hint.Fog==GL_NICEST || primitive==GL_BITMAP))
|| ctx->Color.SWLogicOpEnabled || ctx->Color.SWmasking) {
GLuint ispan[MAX_WIDTH];
for (i=0;i<n;i++) {
	 ispan[i] = index;
}
if (ctx->Fog.Enabled
&& (ctx->Hint.Fog==GL_NICEST || primitive==GL_BITMAP)) {
	 gl_fog_index_pixels( ctx, n, z, ispan );
}
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
MEMCPY( index_save, index, n * sizeof(GLuint) );
}
if (ctx->Color.SWLogicOpEnabled) {
	 gl_logicop_ci_span( ctx, n, x, y, ispan, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_index_span( ctx, n, x, y, ispan );
}
(*ctx->Driver.WriteIndexSpan)( ctx, n, x, y, ispan, mask );
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
for (i=0;i<n;i++) {
ispan[i] = index;
}
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_ci_span( ctx, n, x, y, ispan, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_index_span( ctx, n, x, y, ispan );
}
(*ctx->Driver.WriteIndexSpan)( ctx, n, x, y, ispan, mask );
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
}
}
else {
(*ctx->Driver.WriteMonoindexSpan)( ctx, n, x, y, mask );
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
(*ctx->Driver.WriteMonoindexSpan)( ctx, n, x, y, mask );
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
}
}
}
void gl_write_color_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLdepth z[],
			  GLubyte r[], GLubyte g[],
			  GLubyte b[], GLubyte a[],
			  GLenum primitive )
{
GLubyte mask[MAX_WIDTH];
GLboolean write_all = GL_TRUE;
GLubyte rtmp[MAX_WIDTH], gtmp[MAX_WIDTH], btmp[MAX_WIDTH], atmp[MAX_WIDTH];
GLubyte *red, *green, *blue, *alpha;
MEMSET(mask, 1, n);
if ((ctx->RasterMask & WINCLIP_BIT) || primitive==GL_BITMAP) {
if (clip_span( ctx,n,x,y,mask)==0) {
	 return;
}
write_all = GL_FALSE;
}
if ((primitive==GL_BITMAP && ctx->MutablePixels)
|| (ctx->RasterMask & FRONT_AND_BACK_BIT)) {
MEMCPY( rtmp, r, n * sizeof(GLubyte) );
MEMCPY( gtmp, g, n * sizeof(GLubyte) );
MEMCPY( btmp, b, n * sizeof(GLubyte) );
MEMCPY( atmp, a, n * sizeof(GLubyte) );
red = rtmp;
green = gtmp;
blue = btmp;
alpha = atmp;
}
else {
red   = r;
green = g;
blue  = b;
alpha = a;
}
if (ctx->Fog.Enabled && (ctx->Hint.Fog==GL_NICEST || primitive==GL_BITMAP
|| ctx->Texture.Enabled)) {
gl_fog_color_pixels( ctx, n, z, red, green, blue, alpha );
}
if (ctx->Scissor.Enabled) {
if (gl_scissor_span( ctx, n, x, y, mask )==0) {
	 return;
}
write_all = GL_FALSE;
}
if (ctx->Polygon.StippleFlag && primitive==GL_POLYGON) {
stipple_polygon_span( ctx, n, x, y, mask );
write_all = GL_FALSE;
}
if (ctx->Color.AlphaEnabled) {
if (gl_alpha_test( ctx, n, alpha, mask )==0) {
	 return;
}
write_all = GL_FALSE;
}
if (ctx->Stencil.Enabled) {
if (gl_stencil_span( ctx, n, x, y, mask )==0) {
	 return;
}
gl_depth_stencil_span( ctx, n, x, y, z, mask );
write_all = GL_FALSE;
}
else if (ctx->Depth.Test) {
GLuint m = (*ctx->Driver.DepthTestSpan)( ctx, n, x, y, z, mask );
if (m==0) {
return;
}
if (m<n) {
write_all = GL_FALSE;
}
}
if (ctx->RasterMask & NO_DRAW_BIT) {
return;
}
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_rgba_span( ctx, n, x, y, red, green, blue, alpha, mask );
}
else if (ctx->Color.BlendEnabled) {
gl_blend_span( ctx, n, x, y, red, green, blue, alpha, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_color_span( ctx, n, x, y, red, green, blue, alpha );
}
(*ctx->Driver.WriteColorSpan)( ctx, n, x, y, red, green, blue, alpha,
write_all ? NULL : mask );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_write_alpha_span( ctx, n, x, y, alpha, write_all ? NULL : mask );
}
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
MEMCPY( rtmp, r, n * sizeof(GLubyte) );
MEMCPY( gtmp, g, n * sizeof(GLubyte) );
MEMCPY( btmp, b, n * sizeof(GLubyte) );
MEMCPY( atmp, a, n * sizeof(GLubyte) );
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_rgba_span( ctx, n, x, y, red, green, blue, alpha, mask );
}
else  if (ctx->Color.BlendEnabled) {
gl_blend_span( ctx, n, x, y, red, green, blue, alpha, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_color_span( ctx, n, x, y, red, green, blue, alpha );
}
(*ctx->Driver.WriteColorSpan)( ctx, n, x, y, red, green, blue, alpha,
write_all ? NULL : mask );
if (ctx->RasterMask & ALPHABUF_BIT) {
ctx->Buffer->Alpha = ctx->Buffer->BackAlpha;
gl_write_alpha_span( ctx, n, x, y, alpha, write_all ? NULL : mask );
ctx->Buffer->Alpha = ctx->Buffer->FrontAlpha;
}
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
}
}
void gl_write_monocolor_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLdepth z[],
			      GLint r, GLint g, GLint b, GLint a,
GLenum primitive )
{
GLuint i;
GLubyte mask[MAX_WIDTH];
GLboolean write_all = GL_TRUE;
GLubyte red[MAX_WIDTH], green[MAX_WIDTH], blue[MAX_WIDTH], alpha[MAX_WIDTH];
MEMSET(mask, 1, n);
if ((ctx->RasterMask & WINCLIP_BIT) || primitive==GL_BITMAP) {
if (clip_span( ctx,n,x,y,mask)==0) {
	 return;
}
write_all = GL_FALSE;
}
if (ctx->Scissor.Enabled) {
if (gl_scissor_span( ctx, n, x, y, mask )==0) {
	 return;
}
write_all = GL_FALSE;
}
if (ctx->Polygon.StippleFlag && primitive==GL_POLYGON) {
stipple_polygon_span( ctx, n, x, y, mask );
write_all = GL_FALSE;
}
if (ctx->Color.AlphaEnabled) {
GLubyte alpha[MAX_WIDTH];
for (i=0;i<n;i++) {
alpha[i] = a;
}
if (gl_alpha_test( ctx, n, alpha, mask )==0) {
	 return;
}
write_all = GL_FALSE;
}
if (ctx->Stencil.Enabled) {
if (gl_stencil_span( ctx, n, x, y, mask )==0) {
	 return;
}
gl_depth_stencil_span( ctx, n, x, y, z, mask );
write_all = GL_FALSE;
}
else if (ctx->Depth.Test) {
GLuint m = (*ctx->Driver.DepthTestSpan)( ctx, n, x, y, z, mask );
if (m==0) {
return;
}
if (m<n) {
write_all = GL_FALSE;
}
}
if (ctx->RasterMask & NO_DRAW_BIT) {
return;
}
if (ctx->Color.BlendEnabled || ctx->Color.SWLogicOpEnabled
|| ctx->Color.SWmasking) {
for (i=0;i<n;i++) {
	 if (mask[i]) {
	    red[i]   = r;
	    green[i] = g;
	    blue[i]  = b;
	    alpha[i] = a;
	 }
}
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_rgba_span( ctx, n, x, y, red, green, blue, alpha, mask );
}
else if (ctx->Color.BlendEnabled) {
gl_blend_span( ctx, n, x, y, red, green, blue, alpha, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_color_span( ctx, n, x, y, red, green, blue, alpha );
}
(*ctx->Driver.WriteColorSpan)( ctx, n, x, y, red, green, blue, alpha,
write_all ? NULL : mask );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_write_alpha_span( ctx, n, x, y, alpha, write_all ? NULL : mask );
}
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
for (i=0;i<n;i++) {
if (mask[i]) {
red[i]   = r;
green[i] = g;
blue[i]  = b;
alpha[i] = a;
}
}
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_rgba_span( ctx, n, x, y, red, green, blue, alpha, mask);
}
else if (ctx->Color.BlendEnabled) {
gl_blend_span( ctx, n, x, y, red, green, blue, alpha, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_color_span( ctx, n, x, y, red, green, blue, alpha );
}
(*ctx->Driver.WriteColorSpan)( ctx, n, x, y, red, green, blue, alpha,
write_all ? NULL : mask );
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
if (ctx->RasterMask & ALPHABUF_BIT) {
ctx->Buffer->Alpha = ctx->Buffer->BackAlpha;
gl_write_alpha_span( ctx, n, x, y, alpha,
write_all ? NULL : mask );
ctx->Buffer->Alpha = ctx->Buffer->FrontAlpha;
}
}
}
else {
(*ctx->Driver.WriteMonocolorSpan)( ctx, n, x, y, mask );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_write_mono_alpha_span( ctx, n, x, y, a, write_all ? NULL : mask );
}
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
(*ctx->Driver.WriteMonocolorSpan)( ctx, n, x, y, mask );
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
if (ctx->RasterMask & ALPHABUF_BIT) {
ctx->Buffer->Alpha = ctx->Buffer->BackAlpha;
gl_write_mono_alpha_span( ctx, n, x, y, a,
write_all ? NULL : mask );
ctx->Buffer->Alpha = ctx->Buffer->FrontAlpha;
}
}
}
}
void gl_write_texture_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLdepth z[],
			    float s[], float t[], float u[],
float lambda[],
			    GLubyte r[], GLubyte g[],
			    GLubyte b[], GLubyte a[],
			    GLenum primitive )
{
GLubyte mask[MAX_WIDTH];
GLboolean write_all = GL_TRUE;
GLubyte rtmp[MAX_WIDTH], gtmp[MAX_WIDTH], btmp[MAX_WIDTH], atmp[MAX_WIDTH];
GLubyte *red, *green, *blue, *alpha;
MEMSET(mask, 1, n);
if ((ctx->RasterMask & WINCLIP_BIT) || primitive==GL_BITMAP) {
if (clip_span( ctx,n,x,y,mask)==0) {
	 return;
}
write_all = GL_FALSE;
}
if (primitive==GL_BITMAP || (ctx->RasterMask & FRONT_AND_BACK_BIT)) {
MEMCPY( rtmp, r, n * sizeof(GLubyte) );
MEMCPY( gtmp, g, n * sizeof(GLubyte) );
MEMCPY( btmp, b, n * sizeof(GLubyte) );
MEMCPY( atmp, a, n * sizeof(GLubyte) );
red = rtmp;
green = gtmp;
blue = btmp;
alpha = atmp;
}
else {
red   = r;
green = g;
blue  = b;
alpha = a;
}
ASSERT(ctx->Texture.Enabled);
gl_texture_pixels( ctx, n, s, t, u, lambda, red, green, blue, alpha );
if (ctx->Fog.Enabled && (ctx->Hint.Fog==GL_NICEST || primitive==GL_BITMAP
|| ctx->Texture.Enabled)) {
gl_fog_color_pixels( ctx, n, z, red, green, blue, alpha );
}
if (ctx->Scissor.Enabled) {
if (gl_scissor_span( ctx, n, x, y, mask )==0) {
	 return;
}
write_all = GL_FALSE;
}
if (ctx->Polygon.StippleFlag && primitive==GL_POLYGON) {
stipple_polygon_span( ctx, n, x, y, mask );
write_all = GL_FALSE;
}
if (ctx->Color.AlphaEnabled) {
if (gl_alpha_test( ctx, n, alpha, mask )==0) {
	 return;
}
write_all = GL_FALSE;
}
if (ctx->Stencil.Enabled) {
if (gl_stencil_span( ctx, n, x, y, mask )==0) {
	 return;
}
gl_depth_stencil_span( ctx, n, x, y, z, mask );
write_all = GL_FALSE;
}
else if (ctx->Depth.Test) {
GLuint m = (*ctx->Driver.DepthTestSpan)( ctx, n, x, y, z, mask );
if (m==0) {
return;
}
if (m<n) {
write_all = GL_FALSE;
}
}
if (ctx->RasterMask & NO_DRAW_BIT) {
return;
}
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_rgba_span( ctx, n, x, y, red, green, blue, alpha, mask );
}
else  if (ctx->Color.BlendEnabled) {
gl_blend_span( ctx, n, x, y, red, green, blue, alpha, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_color_span( ctx, n, x, y, red, green, blue, alpha );
}
(*ctx->Driver.WriteColorSpan)( ctx, n, x, y, red, green, blue, alpha,
write_all ? NULL : mask );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_write_alpha_span( ctx, n, x, y, alpha, write_all ? NULL : mask );
}
if (ctx->RasterMask & FRONT_AND_BACK_BIT) {
MEMCPY( rtmp, r, n * sizeof(GLubyte) );
MEMCPY( gtmp, g, n * sizeof(GLubyte) );
MEMCPY( btmp, b, n * sizeof(GLubyte) );
MEMCPY( atmp, a, n * sizeof(GLubyte) );
(*ctx->Driver.SetBuffer)( ctx, GL_BACK );
if (ctx->Color.SWLogicOpEnabled) {
gl_logicop_rgba_span( ctx, n, x, y, red, green, blue, alpha, mask );
}
else if (ctx->Color.BlendEnabled) {
gl_blend_span( ctx, n, x, y, red, green, blue, alpha, mask );
}
if (ctx->Color.SWmasking) {
gl_mask_color_span( ctx, n, x, y, red, green, blue, alpha );
}
(*ctx->Driver.WriteColorSpan)( ctx, n, x, y, red, green, blue, alpha,
write_all ? NULL : mask );
(*ctx->Driver.SetBuffer)( ctx, GL_FRONT );
if (ctx->RasterMask & ALPHABUF_BIT) {
ctx->Buffer->Alpha = ctx->Buffer->BackAlpha;
gl_write_alpha_span( ctx, n, x, y, alpha, write_all ? NULL : mask );
ctx->Buffer->Alpha = ctx->Buffer->FrontAlpha;
}
}
}
void gl_read_color_span( GLcontext *ctx,
GLuint n, GLint x, GLint y,
			 GLubyte red[], GLubyte green[],
			 GLubyte blue[], GLubyte alpha[] )
{
register GLuint i;
if (y<0 || y>=ctx->Buffer->Height || x>=ctx->Buffer->Width) {
for (i=0;i<n;i++) {
	 red[i] = green[i] = blue[i] = alpha[i] = 0;
}
}
else {
if (x>=0 && x+n<=ctx->Buffer->Width) {
	
	 (*ctx->Driver.ReadColorSpan)( ctx, n, x, y, red, green, blue, alpha );
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_read_alpha_span( ctx, n, x, y, alpha );
}
}
else {
	 i = 0;
	 if (x<0) {
	    while (x<0 && n>0) {
	       red[i] = green[i] =  blue[i] = alpha[i] = 0;
	       x++;
	       n--;
	       i++;
	    }
	 }
	 n = MIN2( n, ctx->Buffer->Width - x );
	 (*ctx->Driver.ReadColorSpan)( ctx, n, x, y, red+i, green+i, blue+i, alpha+i);
if (ctx->RasterMask & ALPHABUF_BIT) {
gl_read_alpha_span( ctx, n, x, y, alpha+i );
}
}
}
}
void gl_read_index_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLuint indx[] )
{
register GLuint i;
if (y<0 || y>=ctx->Buffer->Height || x>=ctx->Buffer->Width) {
for (i=0;i<n;i++) {
	 indx[i] = 0;
}
}
else {
if (x>=0 && x+n<=ctx->Buffer->Width) {
	
	 (*ctx->Driver.ReadIndexSpan)( ctx, n, x, y, indx );
}
else {
	 i = 0;
	 if (x<0) {
	    while (x<0 && n>0) {
	       indx[i] = 0;
	       x++;
	       n--;
	       i++;
	    }
	 }
	 n = MIN2( n, ctx->Buffer->Width - x );
	 (*ctx->Driver.ReadIndexSpan)( ctx, n, x, y, indx+i );
}
}
}
/* 当前文件是D:\Read\stencil.c*/

#ifdef PC_HEADER
#else
#endif
#define STENCIL_ADDRESS(X,Y)  (ctx->Buffer->Stencil + ctx->Buffer->Width * (Y) + (X))
void gl_ClearStencil( GLcontext *ctx, GLint s )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glClearStencil" );
return;
}
ctx->Stencil.Clear = (GLstencil) s;
}
void gl_StencilFunc( GLcontext *ctx, GLenum func, GLint ref, GLuint mask )
{
GLint maxref;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glStencilFunc" );
return;
}
switch (func) {
case GL_NEVER:
case GL_LESS:
case GL_LEQUAL:
case GL_GREATER:
case GL_GEQUAL:
case GL_EQUAL:
case GL_NOTEQUAL:
case GL_ALWAYS:
ctx->Stencil.Function = func;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glStencilFunc" );
return;
}
maxref = (1 << STENCIL_BITS) - 1;
ctx->Stencil.Ref = CLAMP( ref, 0, maxref );
ctx->Stencil.ValueMask = mask;
}
void gl_StencilMask( GLcontext *ctx, GLuint mask )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glStencilMask" );
return;
}
ctx->Stencil.WriteMask = (GLstencil) mask;
}
void gl_StencilOp( GLcontext *ctx, GLenum fail, GLenum zfail, GLenum zpass )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glStencilOp" );
return;
}
switch (fail) {
case GL_KEEP:
case GL_ZERO:
case GL_REPLACE:
case GL_INCR:
case GL_DECR:
case GL_INVERT:
ctx->Stencil.FailFunc = fail;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glStencilOp" );
return;
}
switch (zfail) {
case GL_KEEP:
case GL_ZERO:
case GL_REPLACE:
case GL_INCR:
case GL_DECR:
case GL_INVERT:
ctx->Stencil.ZFailFunc = zfail;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glStencilOp" );
return;
}
switch (zpass) {
case GL_KEEP:
case GL_ZERO:
case GL_REPLACE:
case GL_INCR:
case GL_DECR:
case GL_INVERT:
ctx->Stencil.ZPassFunc = zpass;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glStencilOp" );
return;
}
}
static void apply_stencil_op_to_span( GLcontext *ctx,
GLuint n, GLint x, GLint y,
				      GLenum oper, GLubyte mask[] )
{
GLint i;
GLstencil s, ref;
GLstencil wrtmask, invmask;
GLstencil *stencil;
wrtmask = ctx->Stencil.WriteMask;
invmask = ~ctx->Stencil.WriteMask;
ref = ctx->Stencil.Ref;
stencil = STENCIL_ADDRESS( x, y );
switch (oper) {
case GL_KEEP:
break;
case GL_ZERO:
	 if (invmask==0) {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
		  stencil[i] = 0;
	       }
	    }
	 }
	 else {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
		  stencil[i] = stencil[i] & invmask;
	       }
	    }
	 }
	 break;
case GL_REPLACE:
	 if (invmask==0) {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
stencil[i] = ref;
	       }
	    }
	 }
	 else {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
		  s = stencil[i];
		  stencil[i] = (invmask & s ) | (wrtmask & ref);
	       }
	    }
	 }
	 break;
case GL_INCR:
	 if (invmask==0) {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
		  s = stencil[i];
		  if (s<0xff) {
		     stencil[i] = s+1;
		  }
	       }
	    }
	 }
	 else {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
		
		  s = stencil[i];
		  if (s<0xff) {
		     stencil[i] = (invmask & s) | (wrtmask & (s+1));
		  }
	       }
	    }
	 }
	 break;
case GL_DECR:
	 if (invmask==0) {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
		  s = stencil[i];
		  if (s>0) {
		     stencil[i] = s-1;
		  }
	       }
	    }
	 }
	 else {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
		
		  s = stencil[i];
		  if (s>0) {
		     stencil[i] = (invmask & s) | (wrtmask & (s-1));
		  }
	       }
	    }
	 }
	 break;
case GL_INVERT:
	 if (invmask==0) {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
		  s = stencil[i];
		  stencil[i] = ~s;
	       }
	    }
	 }
	 else {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
		  s = stencil[i];
		  stencil[i] = (invmask & s) | (wrtmask & ~s);
	       }
	    }
	 }
	 break;
default:
gl_problem(ctx, "Bad stencilop in apply_stencil_op_to_span");
}
}
GLint gl_stencil_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLubyte mask[] )
{
GLubyte fail[MAX_WIDTH];
GLint allfail = 0;
GLuint i;
GLstencil r, s;
GLstencil *stencil;
stencil = STENCIL_ADDRESS( x, y );
switch (ctx->Stencil.Function) {
case GL_NEVER:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       mask[i] = 0;
	       fail[i] = 1;
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 allfail = 1;
	 break;
case GL_LESS:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
	       s = stencil[i] & ctx->Stencil.ValueMask;
	       if (r < s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_LEQUAL:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
	       s = stencil[i] & ctx->Stencil.ValueMask;
	       if (r <= s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_GREATER:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
	       s = stencil[i] & ctx->Stencil.ValueMask;
	       if (r > s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_GEQUAL:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
	       s = stencil[i] & ctx->Stencil.ValueMask;
	       if (r >= s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_EQUAL:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
	       s = stencil[i] & ctx->Stencil.ValueMask;
	       if (r == s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_NOTEQUAL:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
	       s = stencil[i] & ctx->Stencil.ValueMask;
	       if (r != s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_ALWAYS:
	
	 for (i=0;i<n;i++) {
	    fail[i] = 0;
	 }
	 break;
default:
gl_problem(ctx, "Bad stencil func in gl_stencil_span");
return 0;
}
apply_stencil_op_to_span( ctx, n, x, y, ctx->Stencil.FailFunc, fail );
return (allfail) ? 0 : 1;
}
void gl_depth_stencil_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, const GLdepth z[],
			    GLubyte mask[] )
{
if (ctx->Depth.Test==GL_FALSE) {
apply_stencil_op_to_span( ctx, n, x, y, ctx->Stencil.ZPassFunc, mask );
}
else {
GLubyte passmask[MAX_WIDTH], failmask[MAX_WIDTH], oldmask[MAX_WIDTH];
GLuint i;
for (i=0;i<n;i++) {
	 passmask[i] = failmask[i] = 0;
oldmask[i] = mask[i];
}
(*ctx->Driver.DepthTestSpan)( ctx, n, x, y, z, mask );
for (i=0;i<n;i++) {
if (oldmask[i]) {
if (mask[i]) {
passmask[i] = 1;
}
else {
failmask[i] = 1;
}
}
}
apply_stencil_op_to_span( ctx, n, x, y, ctx->Stencil.ZFailFunc, failmask );
apply_stencil_op_to_span( ctx, n, x, y, ctx->Stencil.ZPassFunc, passmask );
}
}
static void apply_stencil_op_to_pixels( GLcontext *ctx,
GLuint n, const GLint x[],
				        const GLint y[],
				        GLenum oper, GLubyte mask[] )
{
GLint i;
GLstencil ref;
GLstencil wrtmask, invmask;
wrtmask = ctx->Stencil.WriteMask;
invmask = ~ctx->Stencil.WriteMask;
ref = ctx->Stencil.Ref;
switch (oper) {
case GL_KEEP:
break;
case GL_ZERO:
	 if (invmask==0) {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS( x[i], y[i] );
*sptr = 0;
	       }
	    }
	 }
	 else {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS( x[i], y[i] );
		  *sptr = invmask & *sptr;
	       }
	    }
	 }
	 break;
case GL_REPLACE:
	 if (invmask==0) {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS( x[i], y[i] );
*sptr = ref;
	       }
	    }
	 }
	 else {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS( x[i], y[i] );
		  *sptr = (invmask & *sptr ) | (wrtmask & ref);
	       }
	    }
	 }
	 break;
case GL_INCR:
	 if (invmask==0) {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS( x[i], y[i] );
		  if (*sptr < 0xff) {
		     *sptr = *sptr + 1;
		  }
	       }
	    }
	 }
	 else {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS( x[i], y[i] );
		  if (*sptr<0xff) {
		     *sptr = (invmask & *sptr) | (wrtmask & (*sptr+1));
		  }
	       }
	    }
	 }
	 break;
case GL_DECR:
	 if (invmask==0) {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS( x[i], y[i] );
		  if (*sptr>0) {
		     *sptr = *sptr - 1;
		  }
	       }
	    }
	 }
	 else {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS( x[i], y[i] );
		  if (*sptr>0) {
		     *sptr = (invmask & *sptr) | (wrtmask & (*sptr-1));
		  }
	       }
	    }
	 }
	 break;
case GL_INVERT:
	 if (invmask==0) {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS( x[i], y[i] );
*sptr = ~*sptr;
	       }
	    }
	 }
	 else {
	    for (i=0;i<n;i++) {
	       if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS( x[i], y[i] );
*sptr = (invmask & *sptr) | (wrtmask & ~*sptr);
	       }
	    }
	 }
	 break;
default:
gl_problem(ctx, "Bad stencilop in apply_stencil_op_to_pixels");
}
}
GLint gl_stencil_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
			 GLubyte mask[] )
{
GLubyte fail[PB_SIZE];
GLstencil r, s;
GLuint i;
GLint allfail = 0;
switch (ctx->Stencil.Function) {
case GL_NEVER:
for (i=0;i<n;i++) {
	    if (mask[i]) {
	       mask[i] = 0;
	       fail[i] = 1;
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 allfail = 1;
	 break;
case GL_LESS:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS(x[i],y[i]);
	       s = *sptr & ctx->Stencil.ValueMask;
	       if (r < s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_LEQUAL:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS(x[i],y[i]);
	       s = *sptr & ctx->Stencil.ValueMask;
	       if (r <= s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_GREATER:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS(x[i],y[i]);
	       s = *sptr & ctx->Stencil.ValueMask;
	       if (r > s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_GEQUAL:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS(x[i],y[i]);
	       s = *sptr & ctx->Stencil.ValueMask;
	       if (r >= s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_EQUAL:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS(x[i],y[i]);
	       s = *sptr & ctx->Stencil.ValueMask;
	       if (r == s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_NOTEQUAL:
	 r = ctx->Stencil.Ref & ctx->Stencil.ValueMask;
	 for (i=0;i<n;i++) {
	    if (mask[i]) {
GLstencil *sptr = STENCIL_ADDRESS(x[i],y[i]);
	       s = *sptr & ctx->Stencil.ValueMask;
	       if (r != s) {
		
		  fail[i] = 0;
	       }
	       else {
		  fail[i] = 1;
		  mask[i] = 0;
	       }
	    }
	    else {
	       fail[i] = 0;
	    }
	 }
	 break;
case GL_ALWAYS:
	
	 for (i=0;i<n;i++) {
	    fail[i] = 0;
	 }
	 break;
default:
gl_problem(ctx, "Bad stencil func in gl_stencil_pixels");
return 0;
}
apply_stencil_op_to_pixels( ctx, n, x, y, ctx->Stencil.FailFunc, fail );
return (allfail) ? 0 : 1;
}
void gl_depth_stencil_pixels( GLcontext *ctx,
GLuint n, const GLint x[], const GLint y[],
			      const GLdepth z[], GLubyte mask[] )
{
if (ctx->Depth.Test==GL_FALSE) {
apply_stencil_op_to_pixels( ctx, n, x, y, ctx->Stencil.ZPassFunc, mask );
}
else {
GLubyte passmask[PB_SIZE], failmask[PB_SIZE], oldmask[PB_SIZE];
GLuint i;
for (i=0;i<n;i++) {
	 passmask[i] = failmask[i] = 0;
oldmask[i] = mask[i];
}
(*ctx->Driver.DepthTestPixels)( ctx, n, x, y, z, mask );
for (i=0;i<n;i++) {
if (oldmask[i]) {
if (mask[i]) {
passmask[i] = 1;
}
else {
failmask[i] = 1;
}
}
}
apply_stencil_op_to_pixels( ctx, n, x, y,
ctx->Stencil.ZFailFunc, failmask );
apply_stencil_op_to_pixels( ctx, n, x, y,
ctx->Stencil.ZPassFunc, passmask );
}
}
void gl_read_stencil_span( GLcontext *ctx,
GLuint n, GLint x, GLint y, GLubyte stencil[] )
{
GLstencil *s;
if (ctx->Buffer->Stencil) {
s = STENCIL_ADDRESS( x, y );
MEMCPY( stencil, s, n * sizeof(GLubyte) );
}
}
void gl_write_stencil_span( GLcontext *ctx,
GLuint n, GLint x, GLint y,
			    const GLubyte stencil[] )
{
GLstencil *s;
if (ctx->Buffer->Stencil) {
s = STENCIL_ADDRESS( x, y );
MEMCPY( s, stencil, n * sizeof(GLubyte) );
}
}
void gl_alloc_stencil_buffer( GLcontext *ctx )
{
GLuint buffersize = ctx->Buffer->Width * ctx->Buffer->Height;
if (ctx->Buffer->Stencil) {
free(ctx->Buffer->Stencil);
ctx->Buffer->Stencil = NULL;
}
ctx->Buffer->Stencil = (GLstencil *) malloc(buffersize * sizeof(GLstencil));
if (!ctx->Buffer->Stencil) {
ctx->Stencil.Enabled = GL_FALSE;
gl_error( ctx, GL_OUT_OF_MEMORY, "gl_alloc_stencil_buffer" );
}
}
void gl_clear_stencil_buffer( GLcontext *ctx )
{
if (ctx->Visual->StencilBits==0 || !ctx->Buffer->Stencil) {
return;
}
if (ctx->Scissor.Enabled) {
GLint y;
GLint width = ctx->Buffer->Xmax - ctx->Buffer->Xmin + 1;
for (y=ctx->Buffer->Ymin; y<=ctx->Buffer->Ymax; y++) {
GLstencil *ptr = STENCIL_ADDRESS( ctx->Buffer->Xmin, y );
MEMSET( ptr, ctx->Stencil.Clear, width * sizeof(GLstencil) );
}
}
else {
MEMSET( ctx->Buffer->Stencil, ctx->Stencil.Clear,
ctx->Buffer->Width * ctx->Buffer->Height * sizeof(GLstencil) );
}
}
/* 当前文件是D:\Read\teximage.c*/

#ifdef PC_HEADER
#else
#endif
static int logbase2( int n )
{
GLint i = 1;
GLint log2 = 0;
if (n<0) {
return -1;
}
while ( n > i ) {
i *= 2;
log2++;
}
if (i != n) {
return -1;
}
else {
return log2;
}
}
static GLint decode_internal_format1( GLint format )
{
switch (format) {
case GL_ALPHA:
case GL_ALPHA4:
case GL_ALPHA8:
case GL_ALPHA12:
case GL_ALPHA16:
return GL_ALPHA;
case 1:
case GL_LUMINANCE:
case GL_LUMINANCE4:
case GL_LUMINANCE8:
case GL_LUMINANCE12:
case GL_LUMINANCE16:
return GL_LUMINANCE;
case 2:
case GL_LUMINANCE_ALPHA:
case GL_LUMINANCE4_ALPHA4:
case GL_LUMINANCE6_ALPHA2:
case GL_LUMINANCE8_ALPHA8:
case GL_LUMINANCE12_ALPHA4:
case GL_LUMINANCE12_ALPHA12:
case GL_LUMINANCE16_ALPHA16:
return GL_LUMINANCE_ALPHA;
case GL_INTENSITY:
case GL_INTENSITY4:
case GL_INTENSITY8:
case GL_INTENSITY12:
case GL_INTENSITY16:
return GL_INTENSITY;
case 3:
case GL_RGB:
case GL_R3_G3_B2:
case GL_RGB4:
case GL_RGB5:
case GL_RGB8:
case GL_RGB10:
case GL_RGB12:
case GL_RGB16:
return GL_RGB;
case 4:
case GL_RGBA:
case GL_RGBA2:
case GL_RGBA4:
case GL_RGB5_A1:
case GL_RGBA8:
case GL_RGB10_A2:
case GL_RGBA12:
case GL_RGBA16:
return GL_RGBA;
case GL_COLOR_INDEX1_EXT:
case GL_COLOR_INDEX2_EXT:
case GL_COLOR_INDEX4_EXT:
case GL_COLOR_INDEX8_EXT:
case GL_COLOR_INDEX12_EXT:
case GL_COLOR_INDEX16_EXT:
return GL_COLOR_INDEX;
default:
return -1;
}
}
static GLint components_in_intformat( GLint format )
{
switch (format) {
case GL_ALPHA:
case GL_ALPHA4:
case GL_ALPHA8:
case GL_ALPHA12:
case GL_ALPHA16:
return 1;
case 1:
case GL_LUMINANCE:
case GL_LUMINANCE4:
case GL_LUMINANCE8:
case GL_LUMINANCE12:
case GL_LUMINANCE16:
return 1;
case 2:
case GL_LUMINANCE_ALPHA:
case GL_LUMINANCE4_ALPHA4:
case GL_LUMINANCE6_ALPHA2:
case GL_LUMINANCE8_ALPHA8:
case GL_LUMINANCE12_ALPHA4:
case GL_LUMINANCE12_ALPHA12:
case GL_LUMINANCE16_ALPHA16:
return 2;
case GL_INTENSITY:
case GL_INTENSITY4:
case GL_INTENSITY8:
case GL_INTENSITY12:
case GL_INTENSITY16:
return 1;
case 3:
case GL_RGB:
case GL_R3_G3_B2:
case GL_RGB4:
case GL_RGB5:
case GL_RGB8:
case GL_RGB10:
case GL_RGB12:
case GL_RGB16:
return 3;
case 4:
case GL_RGBA:
case GL_RGBA2:
case GL_RGBA4:
case GL_RGB5_A1:
case GL_RGBA8:
case GL_RGB10_A2:
case GL_RGBA12:
case GL_RGBA16:
return 4;
case GL_COLOR_INDEX1_EXT:
case GL_COLOR_INDEX2_EXT:
case GL_COLOR_INDEX4_EXT:
case GL_COLOR_INDEX8_EXT:
case GL_COLOR_INDEX12_EXT:
case GL_COLOR_INDEX16_EXT:
return 1;
default:
return -1;
}
}
struct gl_texture_image *gl_alloc_texture_image( void )
{
return (struct gl_texture_image *) calloc( 1, sizeof(struct gl_texture_image) );
}
void gl_free_texture_image( struct gl_texture_image *teximage )
{
if (teximage->Data) {
free( teximage->Data );
}
free( teximage );
}
static struct gl_texture_image *
image_to_texture( GLcontext *ctx, const struct gl_image *image,
GLenum internalFormat, GLint border )
{
GLint components;
struct gl_texture_image *texImage;
GLint numPixels, pixel;
GLboolean scaleOrBias;
assert(image);
assert(image->Width>0);
assert(image->Height>0);
assert(image->Depth>0);
components = components_in_intformat(internalFormat);
numPixels = image->Width * image->Height * image->Depth;
texImage = gl_alloc_texture_image();
if (!texImage)
return NULL;
texImage->Format = decode_internal_format1(internalFormat);
texImage->IntFormat = internalFormat;
texImage->Border = border;
texImage->Width = image->Width;
texImage->Height = image->Height;
texImage->Depth = image->Depth;
texImage->WidthLog2 = logbase2(image->Width - 2*border);
if (image->Height==1)
texImage->HeightLog2 = 0;
else
texImage->HeightLog2 = logbase2(image->Height - 2*border);
if (image->Depth==1)
texImage->DepthLog2 = 0;
else
texImage->DepthLog2 = logbase2(image->Depth - 2*border);
texImage->Width2 = 1 << texImage->WidthLog2;
texImage->Height2 = 1 << texImage->HeightLog2;
texImage->Depth2 = 1 << texImage->DepthLog2;
texImage->MaxLog2 = MAX2( texImage->WidthLog2, texImage->HeightLog2 );
texImage->Data = (GLubyte *) malloc( numPixels * components );
assert(texImage->WidthLog2>=0);
assert(texImage->HeightLog2>=0);
assert(texImage->DepthLog2>=0);
if (!texImage->Data) {
gl_free_texture_image( texImage );
return NULL;
}
if (ctx->Pixel.RedScale!=1.0F   || ctx->Pixel.RedBias!=0.0F ||
ctx->Pixel.GreenScale!=1.0F || ctx->Pixel.GreenBias!=0.0F ||
ctx->Pixel.BlueScale!=1.0F  || ctx->Pixel.BlueBias!=0.0F ||
ctx->Pixel.AlphaScale!=1.0F || ctx->Pixel.AlphaBias!=0.0F) {
scaleOrBias = GL_TRUE;
}
else {
scaleOrBias = GL_FALSE;
}
switch (image->Type) {
case GL_BITMAP:
{
GLint shift = ctx->Pixel.IndexShift;
GLint offset = ctx->Pixel.IndexOffset;
GLint rMask = ctx->Pixel.MapItoRsize-1;
GLint gMask = ctx->Pixel.MapItoGsize-1;
GLint bMask = ctx->Pixel.MapItoBsize-1;
GLint aMask = ctx->Pixel.MapItoAsize-1;
GLint i, j;
GLubyte *srcPtr = (GLubyte *) image->Data;
assert( image->Format==GL_COLOR_INDEX );
for (j=0; j<image->Height; j++) {
GLubyte bitMask = 128;
for (i=0; i<image->Width; i++) {
GLint index;
GLubyte red, green, blue, alpha;
index = (*srcPtr & bitMask) ? 1 : 0;
bitMask = bitMask >> 1;
if (bitMask==0) {
bitMask = 128;
srcPtr++;
}
if (shift>=0) {
index = (index << shift) + offset;
}
else {
index = (index >> -shift) + offset;
}
red   = (GLint) (ctx->Pixel.MapItoR[index & rMask] * 255.0F);
green = (GLint) (ctx->Pixel.MapItoG[index & gMask] * 255.0F);
blue  = (GLint) (ctx->Pixel.MapItoB[index & bMask] * 255.0F);
alpha = (GLint) (ctx->Pixel.MapItoA[index & aMask] * 255.0F);
pixel = j * image->Width + i;
switch (texImage->Format) {
case GL_ALPHA:
texImage->Data[pixel] = alpha;
break;
case GL_LUMINANCE:
texImage->Data[pixel] = red;
break;
case GL_LUMINANCE_ALPHA:
texImage->Data[pixel*2+0] = red;
texImage->Data[pixel*2+1] = alpha;
break;
case GL_INTENSITY:
texImage->Data[pixel] = red;
break;
case GL_RGB:
texImage->Data[pixel*3+0] = red;
texImage->Data[pixel*3+1] = green;
texImage->Data[pixel*3+2] = blue;
break;
case GL_RGBA:
texImage->Data[pixel*4+0] = red;
texImage->Data[pixel*4+1] = green;
texImage->Data[pixel*4+2] = blue;
texImage->Data[pixel*4+3] = alpha;
break;
default:
gl_problem(ctx,"Bad format in image_to_texture");
return NULL;
}
}
if (bitMask!=128) {
srcPtr++;
}
}
}
break;
case GL_UNSIGNED_BYTE:
for (pixel=0; pixel<numPixels; pixel++) {
GLubyte red, green, blue, alpha;
switch (image->Format) {
case GL_COLOR_INDEX:
if (decode_internal_format1(internalFormat)==GL_COLOR_INDEX) {
GLint index = ((GLubyte*)image->Data)[pixel];
red = index;
}
else {
GLint index = ((GLubyte*)image->Data)[pixel];
red   = 255.0F * ctx->Pixel.MapItoR[index];
green = 255.0F * ctx->Pixel.MapItoG[index];
blue  = 255.0F * ctx->Pixel.MapItoB[index];
alpha = 255.0F * ctx->Pixel.MapItoA[index];
}
break;
case GL_RGB:
red   = ((GLubyte*) image->Data)[pixel*3+0];
green = ((GLubyte*) image->Data)[pixel*3+1];
blue  = ((GLubyte*) image->Data)[pixel*3+2];
alpha = 255;
break;
case GL_RGBA:
red   = ((GLubyte*) image->Data)[pixel*4+0];
green = ((GLubyte*) image->Data)[pixel*4+1];
blue  = ((GLubyte*) image->Data)[pixel*4+2];
alpha = ((GLubyte*) image->Data)[pixel*4+3];
break;
case GL_RED:
red   = ((GLubyte*) image->Data)[pixel];
green = 0;
blue  = 0;
alpha = 255;
break;
case GL_GREEN:
red   = 0;
green = ((GLubyte*) image->Data)[pixel];
blue  = 0;
alpha = 255;
break;
case GL_BLUE:
red   = 0;
green = 0;
blue  = ((GLubyte*) image->Data)[pixel];
alpha = 255;
break;
case GL_ALPHA:
red   = 0;
green = 0;
blue  = 0;
alpha = ((GLubyte*) image->Data)[pixel];
break;
case GL_LUMINANCE:
red   = ((GLubyte*) image->Data)[pixel];
green = red;
blue  = red;
alpha = 255;
break;
case GL_LUMINANCE_ALPHA:
red   = ((GLubyte*) image->Data)[pixel*2+0];
green = red;
blue  = red;
alpha = ((GLubyte*) image->Data)[pixel*2+1];
break;
default:
gl_problem(ctx,"Bad format (2) in image_to_texture");
return NULL;
}
if (scaleOrBias || ctx->Pixel.MapColorFlag) {
float r = red   * (1.0F/255.0F);
float g = green * (1.0F/255.0F);
float b = blue  * (1.0F/255.0F);
float a = alpha * (1.0F/255.0F);
if (scaleOrBias) {
r = r * ctx->Pixel.RedScale   + ctx->Pixel.RedBias;
g = g * ctx->Pixel.GreenScale + ctx->Pixel.GreenBias;
b = b * ctx->Pixel.BlueScale  + ctx->Pixel.BlueBias;
a = a * ctx->Pixel.AlphaScale + ctx->Pixel.AlphaBias;
r = CLAMP( r, 0.0F, 1.0F );
g = CLAMP( g, 0.0F, 1.0F );
b = CLAMP( b, 0.0F, 1.0F );
a = CLAMP( a, 0.0F, 1.0F );
}
if (ctx->Pixel.MapColorFlag) {
GLint ir = (GLint) (r*ctx->Pixel.MapRtoRsize);
GLint ig = (GLint) (g*ctx->Pixel.MapGtoGsize);
GLint ib = (GLint) (b*ctx->Pixel.MapBtoBsize);
GLint ia = (GLint) (a*ctx->Pixel.MapAtoAsize);
r = ctx->Pixel.MapRtoR[ir];
g = ctx->Pixel.MapGtoG[ig];
b = ctx->Pixel.MapBtoB[ib];
a = ctx->Pixel.MapAtoA[ia];
}
red   = (GLint) (r * 255.0F);
green = (GLint) (g * 255.0F);
blue  = (GLint) (b * 255.0F);
alpha = (GLint) (a * 255.0F);
}
switch (texImage->Format) {
case GL_COLOR_INDEX:
texImage->Data[pixel] = red;
break;
case GL_ALPHA:
texImage->Data[pixel] = alpha;
break;
case GL_LUMINANCE:
texImage->Data[pixel] = red;
break;
case GL_LUMINANCE_ALPHA:
texImage->Data[pixel*2+0] = red;
texImage->Data[pixel*2+1] = alpha;
break;
case GL_INTENSITY:
texImage->Data[pixel] = red;
break;
case GL_RGB:
texImage->Data[pixel*3+0] = red;
texImage->Data[pixel*3+1] = green;
texImage->Data[pixel*3+2] = blue;
break;
case GL_RGBA:
texImage->Data[pixel*4+0] = red;
texImage->Data[pixel*4+1] = green;
texImage->Data[pixel*4+2] = blue;
texImage->Data[pixel*4+3] = alpha;
break;
default:
gl_problem(ctx,"Bad format (3) in image_to_texture");
return NULL;
}
}
break;
case GL_FLOAT:
for (pixel=0; pixel<numPixels; pixel++) {
float red, green, blue, alpha;
switch (texImage->Format) {
case GL_COLOR_INDEX:
if (decode_internal_format1(internalFormat)==GL_COLOR_INDEX) {
GLint index = (GLint) ((float*) image->Data)[pixel];
red = index;
}
else {
GLint shift = ctx->Pixel.IndexShift;
GLint offset = ctx->Pixel.IndexOffset;
GLint rMask = ctx->Pixel.MapItoRsize-1;
GLint gMask = ctx->Pixel.MapItoGsize-1;
GLint bMask = ctx->Pixel.MapItoBsize-1;
GLint aMask = ctx->Pixel.MapItoAsize-1;
GLint index = (GLint) ((float*) image->Data)[pixel];
if (shift>=0) {
index = (index << shift) + offset;
}
else {
index = (index >> -shift) + offset;
}
red   = ctx->Pixel.MapItoR[index & rMask];
green = ctx->Pixel.MapItoG[index & gMask];
blue  = ctx->Pixel.MapItoB[index & bMask];
alpha = ctx->Pixel.MapItoA[index & aMask];
}
break;
case GL_RGB:
red   = ((float*) image->Data)[pixel*3+0];
green = ((float*) image->Data)[pixel*3+1];
blue  = ((float*) image->Data)[pixel*3+2];
alpha = 1.0;
break;
case GL_RGBA:
red   = ((float*) image->Data)[pixel*4+0];
green = ((float*) image->Data)[pixel*4+1];
blue  = ((float*) image->Data)[pixel*4+2];
alpha = ((float*) image->Data)[pixel*4+3];
break;
case GL_RED:
red   = ((float*) image->Data)[pixel];
green = 0.0;
blue  = 0.0;
alpha = 1.0;
break;
case GL_GREEN:
red   = 0.0;
green = ((float*) image->Data)[pixel];
blue  = 0.0;
alpha = 1.0;
break;
case GL_BLUE:
red   = 0.0;
green = 0.0;
blue  = ((float*) image->Data)[pixel];
alpha = 1.0;
break;
case GL_ALPHA:
red   = 0.0;
green = 0.0;
blue  = 0.0;
alpha = ((float*) image->Data)[pixel];
break;
case GL_LUMINANCE:
red   = ((float*) image->Data)[pixel];
green = red;
blue  = red;
alpha = 1.0;
break;
case GL_LUMINANCE_ALPHA:
red   = ((float*) image->Data)[pixel*2+0];
green = red;
blue  = red;
alpha = ((float*) image->Data)[pixel*2+1];
break;
default:
gl_problem(ctx,"Bad format (4) in image_to_texture");
return NULL;
}
if (image->Format!=GL_COLOR_INDEX) {
if (scaleOrBias) {
red   = red   * ctx->Pixel.RedScale   + ctx->Pixel.RedBias;
green = green * ctx->Pixel.GreenScale + ctx->Pixel.GreenBias;
blue  = blue  * ctx->Pixel.BlueScale  + ctx->Pixel.BlueBias;
alpha = alpha * ctx->Pixel.AlphaScale + ctx->Pixel.AlphaBias;
red   = CLAMP( red,    0.0F, 1.0F );
green = CLAMP( green,  0.0F, 1.0F );
blue  = CLAMP( blue,   0.0F, 1.0F );
alpha = CLAMP( alpha,  0.0F, 1.0F );
}
if (ctx->Pixel.MapColorFlag) {
GLint ir = (GLint) (red  *ctx->Pixel.MapRtoRsize);
GLint ig = (GLint) (green*ctx->Pixel.MapGtoGsize);
GLint ib = (GLint) (blue *ctx->Pixel.MapBtoBsize);
GLint ia = (GLint) (alpha*ctx->Pixel.MapAtoAsize);
red   = ctx->Pixel.MapRtoR[ir];
green = ctx->Pixel.MapGtoG[ig];
blue  = ctx->Pixel.MapBtoB[ib];
alpha = ctx->Pixel.MapAtoA[ia];
}
}
switch (texImage->Format) {
case GL_COLOR_INDEX:
texImage->Data[pixel] = (GLint) (red * 255.0F);
break;
case GL_ALPHA:
texImage->Data[pixel] = (GLint) (alpha * 255.0F);
break;
case GL_LUMINANCE:
texImage->Data[pixel] = (GLint) (red * 255.0F);
break;
case GL_LUMINANCE_ALPHA:
texImage->Data[pixel*2+0] = (GLint) (red * 255.0F);
texImage->Data[pixel*2+1] = (GLint) (alpha * 255.0F);
break;
case GL_INTENSITY:
texImage->Data[pixel] = (GLint) (red * 255.0F);
break;
case GL_RGB:
texImage->Data[pixel*3+0] = (GLint) (red   * 255.0F);
texImage->Data[pixel*3+1] = (GLint) (green * 255.0F);
texImage->Data[pixel*3+2] = (GLint) (blue  * 255.0F);
break;
case GL_RGBA:
texImage->Data[pixel*4+0] = (GLint) (red   * 255.0F);
texImage->Data[pixel*4+1] = (GLint) (green * 255.0F);
texImage->Data[pixel*4+2] = (GLint) (blue  * 255.0F);
texImage->Data[pixel*4+3] = (GLint) (alpha * 255.0F);
break;
default:
gl_problem(ctx,"Bad format (5) in image_to_texture");
return NULL;
}
}
break;
default:
gl_problem(ctx, "Bad image type in image_to_texture");
return NULL;
}
return texImage;
}
static struct gl_texture_image *
make_null_texture( GLcontext *ctx, GLenum internalFormat,
GLsizei width, GLsizei height, GLsizei depth, GLint border )
{
GLint components;
struct gl_texture_image *texImage;
GLint numPixels;
components = components_in_intformat(internalFormat);
numPixels = width * height * depth;
texImage = gl_alloc_texture_image();
if (!texImage)
return NULL;
texImage->Format = decode_internal_format1(internalFormat);
texImage->IntFormat = internalFormat;
texImage->Border = border;
texImage->Width = width;
texImage->Height = height;
texImage->Depth = depth;
texImage->WidthLog2 = logbase2(width - 2*border);
if (height==1)
texImage->HeightLog2 = 0;
else
texImage->HeightLog2 = logbase2(height - 2*border);
if (depth==1)
texImage->DepthLog2 = 0;
else
texImage->DepthLog2 = logbase2(depth - 2*border);
texImage->Width2 = 1 << texImage->WidthLog2;
texImage->Height2 = 1 << texImage->HeightLog2;
texImage->Depth2 = 1 << texImage->DepthLog2;
texImage->MaxLog2 = MAX2( texImage->WidthLog2, texImage->HeightLog2 );
texImage->Data = (GLubyte *) malloc( numPixels * components );
if (texImage->Data) {
char message[8][32] = {
"   X   X  XXXXX   XXX     X    ",
"   XX XX  X      X   X   X X   ",
"   X X X  X      X      X   X  ",
"   X   X  XXXX    XXX   XXXXX  ",
"   X   X  X          X  X   X  ",
"   X   X  X      X   X  X   X  ",
"   X   X  XXXXX   XXX   X   X  ",
"                               "
};
GLubyte *imgPtr = texImage->Data;
GLint i, j, k;
for (i=0;i<height;i++) {
GLint srcRow = 7 - i % 8;
for (j=0;j<width;j++) {
GLint srcCol = j % 32;
GLubyte texel = (message[srcRow][srcCol]=='X') ? 255 : 70;
for (k=0;k<components;k++) {
*imgPtr++ = texel;
}
}
}
}
return texImage;
}
static GLboolean texture_1d_error_check( GLcontext *ctx, GLenum target,
GLint level, GLenum internalFormat,
GLenum format, GLenum type,
GLint width, GLint border )
{
GLint iformat;
if (target!=GL_TEXTURE_1D && target!=GL_PROXY_TEXTURE_1D) {
gl_error( ctx, GL_INVALID_ENUM, "glTexImage1D" );
return GL_TRUE;
}
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage1D(level)" );
return GL_TRUE;
}
iformat = decode_internal_format1( internalFormat );
if (iformat<0) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage1D(internalFormat)" );
return GL_TRUE;
}
if (border!=0 && border!=1) {
if (target!=GL_PROXY_TEXTURE_1D) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage1D(border)" );
}
return GL_TRUE;
}
if (width<2*border || width>2+MAX_TEXTURE_SIZE) {
if (target!=GL_PROXY_TEXTURE_1D) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage1D(width)" );
}
return GL_TRUE;
}
if (logbase2( width-2*border )<0) {
gl_error( ctx, GL_INVALID_VALUE,
"glTexImage1D(width != 2^k + 2*border)");
return GL_TRUE;
}
switch (format) {
case GL_COLOR_INDEX:
case GL_RED:
case GL_GREEN:
case GL_BLUE:
case GL_ALPHA:
case GL_RGB:
case GL_RGBA:
case GL_LUMINANCE:
case GL_LUMINANCE_ALPHA:
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glTexImage1D(format)" );
return GL_TRUE;
}
switch (type) {
case GL_UNSIGNED_BYTE:
case GL_BYTE:
case GL_UNSIGNED_SHORT:
case GL_SHORT:
case GL_FLOAT:
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glTexImage1D(type)" );
return GL_TRUE;
}
return GL_FALSE;
}
static GLboolean texture_2d_error_check( GLcontext *ctx, GLenum target,
GLint level, GLenum internalFormat,
GLenum format, GLenum type,
GLint width, GLint height,
GLint border )
{
GLint iformat;
if (target!=GL_TEXTURE_2D && target!=GL_PROXY_TEXTURE_2D) {
gl_error( ctx, GL_INVALID_ENUM, "glTexImage2D(target)" );
return GL_TRUE;
}
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage2D(level)" );
return GL_TRUE;
}
iformat = decode_internal_format1( internalFormat );
if (iformat<0) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage2D(internalFormat)" );
return GL_TRUE;
}
if (border!=0 && border!=1) {
if (target!=GL_PROXY_TEXTURE_2D) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage2D(border)" );
}
return GL_TRUE;
}
if (width<2*border || width>2+MAX_TEXTURE_SIZE) {
if (target!=GL_PROXY_TEXTURE_2D) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage2D(width)" );
}
return GL_TRUE;
}
if (height<2*border || height>2+MAX_TEXTURE_SIZE) {
if (target!=GL_PROXY_TEXTURE_2D) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage2D(height)" );
}
return GL_TRUE;
}
if (logbase2( width-2*border )<0) {
gl_error( ctx,GL_INVALID_VALUE,
"glTexImage2D(width != 2^k + 2*border)");
return GL_TRUE;
}
if (logbase2( height-2*border )<0) {
gl_error( ctx,GL_INVALID_VALUE,
"glTexImage2D(height != 2^k + 2*border)");
return GL_TRUE;
}
switch (format) {
case GL_COLOR_INDEX:
case GL_RED:
case GL_GREEN:
case GL_BLUE:
case GL_ALPHA:
case GL_RGB:
case GL_RGBA:
case GL_LUMINANCE:
case GL_LUMINANCE_ALPHA:
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glTexImage2D(format)" );
return GL_TRUE;
}
switch (type) {
case GL_UNSIGNED_BYTE:
case GL_BYTE:
case GL_UNSIGNED_SHORT:
case GL_SHORT:
case GL_UNSIGNED_INT:
case GL_INT:
case GL_FLOAT:
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glTexImage2D(type)" );
return GL_TRUE;
}
return GL_FALSE;
}
static GLboolean texture_3d_error_check( GLcontext *ctx, GLenum target,
GLint level, GLenum internalFormat,
GLenum format, GLenum type,
GLint width, GLint height,
GLint depth, GLint border )
{
GLint iformat;
if (target!=GL_TEXTURE_3D_EXT && target!=GL_PROXY_TEXTURE_3D_EXT) {
gl_error( ctx, GL_INVALID_ENUM, "glTexImage3DEXT(target)" );
return GL_TRUE;
}
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage3DEXT(level)" );
return GL_TRUE;
}
iformat = decode_internal_format1( internalFormat );
if (iformat<0) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage3DEXT(internalFormat)" );
return GL_TRUE;
}
if (border!=0 && border!=1) {
if (target!=GL_PROXY_TEXTURE_3D_EXT) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage3DEXT(border)" );
}
return GL_TRUE;
}
if (width<2*border || width>2+MAX_TEXTURE_SIZE) {
if (target!=GL_PROXY_TEXTURE_3D_EXT) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage3DEXT(width)" );
}
return GL_TRUE;
}
if (height<2*border || height>2+MAX_TEXTURE_SIZE) {
if (target!=GL_PROXY_TEXTURE_3D_EXT) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage3DEXT(height)" );
}
return GL_TRUE;
}
if (depth<2*border || depth>2+MAX_TEXTURE_SIZE) {
if (target!=GL_PROXY_TEXTURE_3D_EXT) {
gl_error( ctx, GL_INVALID_VALUE, "glTexImage3DEXT(depth)" );
}
return GL_TRUE;
}
if (logbase2( width-2*border )<0) {
gl_error( ctx,GL_INVALID_VALUE,
"glTexImage3DEXT(width != 2^k + 2*border))");
return GL_TRUE;
}
if (logbase2( height-2*border )<0) {
gl_error( ctx,GL_INVALID_VALUE,
"glTexImage3DEXT(height != 2^k + 2*border))");
return GL_TRUE;
}
if (logbase2( depth-2*border )<0) {
gl_error( ctx,GL_INVALID_VALUE,
"glTexImage3DEXT(depth  != 2^k + 2*border))");
return GL_TRUE;
}
switch (format) {
case GL_COLOR_INDEX:
case GL_RED:
case GL_GREEN:
case GL_BLUE:
case GL_ALPHA:
case GL_RGB:
case GL_RGBA:
case GL_LUMINANCE:
case GL_LUMINANCE_ALPHA:
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glTexImage3DEXT(format)" );
return GL_TRUE;
}
switch (type) {
case GL_UNSIGNED_BYTE:
case GL_BYTE:
case GL_UNSIGNED_SHORT:
case GL_SHORT:
case GL_UNSIGNED_INT:
case GL_INT:
case GL_FLOAT:
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glTexImage3DEXT(type)" );
return GL_TRUE;
}
return GL_FALSE;
}
void gl_TexImage1D( GLcontext *ctx,
GLenum target, GLint level, GLint internalformat,
		    GLsizei width, GLint border, GLenum format,
		    GLenum type, struct gl_image *image )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glTexImage1D" );
return;
}
if (target==GL_TEXTURE_1D) {
struct gl_texture_image *teximage;
if (texture_1d_error_check( ctx, target, level, internalformat,
format, type, width, border )) {
return;
}
if (ctx->Texture.Current1D->Image[level]) {
gl_free_texture_image( ctx->Texture.Current1D->Image[level] );
}
if (image) {
teximage = image_to_texture(ctx, image, internalformat, border);
}
else {
teximage = make_null_texture(ctx, internalformat,
width, 1, 1, border);
}
ctx->Texture.Current1D->Image[level] = teximage;
ctx->Texture.Current1D->Dirty = GL_TRUE;
ctx->NewState |= NEW_TEXTURING;
if (image && image->RefCount==0) {
gl_free_image(image);
}
if (ctx->Driver.TexImage) {
(*ctx->Driver.TexImage)( ctx, GL_TEXTURE_1D,
ctx->Texture.Current1D,
level, internalformat, teximage );
}
}
else if (target==GL_PROXY_TEXTURE_1D) {
if (texture_1d_error_check( ctx, target, level, internalformat,
format, type, width, border )) {
if (level>=0 && level<MAX_TEXTURE_LEVELS) {
MEMSET( ctx->Texture.Proxy1D->Image[level], 0,
sizeof(struct gl_texture_image) );
}
}
else {
ctx->Texture.Proxy1D->Image[level]->Format = internalformat;
ctx->Texture.Proxy1D->Image[level]->Border = border;
ctx->Texture.Proxy1D->Image[level]->Width = width;
ctx->Texture.Proxy1D->Image[level]->Height = 1;
}
if (image->RefCount==0) {
gl_free_image(image);
}
}
else {
gl_error( ctx, GL_INVALID_ENUM, "glTexImage1D(target)" );
return;
}
}
void gl_TexImage2D( GLcontext *ctx,
GLenum target, GLint level, GLint internalformat,
GLsizei width, GLsizei height, GLint border,
GLenum format, GLenum type,
struct gl_image *image )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glTexImage2D" );
return;
}
if (target==GL_TEXTURE_2D) {
struct gl_texture_image *teximage;
if (texture_2d_error_check( ctx, target, level, internalformat,
format, type, width, height, border )) {
return;
}
if (ctx->Texture.Current2D->Image[level]) {
gl_free_texture_image( ctx->Texture.Current2D->Image[level] );
}
if (image) {
teximage = image_to_texture(ctx, image, internalformat, border);
}
else {
teximage = make_null_texture(ctx, internalformat,
width, height, 1, border);
}
ctx->Texture.Current2D->Image[level] = teximage;
ctx->Texture.Current2D->Dirty = GL_TRUE;
ctx->NewState |= NEW_TEXTURING;
if (image && image->RefCount==0) {
gl_free_image(image);
}
if (ctx->Driver.TexImage) {
(*ctx->Driver.TexImage)( ctx, GL_TEXTURE_2D,
ctx->Texture.Current2D,
level, internalformat, teximage );
}
}
else if (target==GL_PROXY_TEXTURE_2D) {
if (texture_2d_error_check( ctx, target, level, internalformat,
format, type, width, height, border )) {
if (level>=0 && level<MAX_TEXTURE_LEVELS) {
MEMSET( ctx->Texture.Proxy2D->Image[level], 0,
sizeof(struct gl_texture_image) );
}
}
else {
ctx->Texture.Proxy2D->Image[level]->Format = internalformat;
ctx->Texture.Proxy2D->Image[level]->Border = border;
ctx->Texture.Proxy2D->Image[level]->Width = width;
ctx->Texture.Proxy2D->Image[level]->Height = height;
}
if (image->RefCount==0) {
gl_free_image(image);
}
}
else {
gl_error( ctx, GL_INVALID_ENUM, "glTexImage2D(target)" );
return;
}
}
void gl_TexImage3DEXT( GLcontext *ctx,
GLenum target, GLint level, GLint internalformat,
GLsizei width, GLsizei height, GLsizei depth,
GLint border, GLenum format, GLenum type,
struct gl_image *image )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glTexImage3DEXT" );
return;
}
if (target==GL_TEXTURE_3D_EXT) {
struct gl_texture_image *teximage;
if (texture_3d_error_check( ctx, target, level, internalformat,
format, type, width, height, depth,
border )) {
return;
}
if (ctx->Texture.Current3D->Image[level]) {
gl_free_texture_image( ctx->Texture.Current3D->Image[level] );
}
if (image) {
teximage = image_to_texture(ctx, image, internalformat, border);
}
else {
teximage = make_null_texture(ctx, internalformat,
width, height, depth, border);
}
ctx->Texture.Current3D->Image[level] = teximage;
ctx->Texture.Current3D->Dirty = GL_TRUE;
ctx->NewState |= NEW_TEXTURING;
if (image && image->RefCount==0) {
gl_free_image(image);
}
if (ctx->Driver.TexImage) {
(*ctx->Driver.TexImage)( ctx, GL_TEXTURE_3D_EXT,
ctx->Texture.Current3D,
level, internalformat, teximage );
}
}
else if (target==GL_PROXY_TEXTURE_3D_EXT) {
if (texture_3d_error_check( ctx, target, level, internalformat,
format, type, width, height, depth,
border )) {
if (level>=0 && level<MAX_TEXTURE_LEVELS) {
MEMSET( ctx->Texture.Proxy3D->Image[level], 0,
sizeof(struct gl_texture_image) );
}
}
else {
ctx->Texture.Proxy3D->Image[level]->Format = internalformat;
ctx->Texture.Proxy3D->Image[level]->Border = border;
ctx->Texture.Proxy3D->Image[level]->Width = width;
ctx->Texture.Proxy3D->Image[level]->Height = height;
ctx->Texture.Proxy3D->Image[level]->Depth  = depth;
}
if (image->RefCount==0) {
gl_free_image(image);
}
}
else {
gl_error( ctx, GL_INVALID_ENUM, "glTexImage3DEXT(target)" );
return;
}
}
void gl_GetTexImage( GLcontext *ctx, GLenum target, GLint level, GLenum format,
GLenum type, GLvoid *pixels )
{
gl_problem(ctx, "glGetTexImage not implemented");
}
struct gl_image *
gl_unpack_texsubimage( GLcontext *ctx, GLint width, GLint height, GLint depth,
GLenum format, GLenum type, const GLvoid *pixels )
{
if (type==GL_BITMAP && format!=GL_COLOR_INDEX) {
return NULL;
}
if (format==GL_STENCIL_INDEX || format==GL_DEPTH_COMPONENT){
return NULL;
}
if (gl_sizeof_type(type)<=0) {
return NULL;
}
return gl_unpack_image3D( ctx, width, height, depth, format, type, pixels );
}
void gl_TexSubImage1D( GLcontext *ctx,
GLenum target, GLint level, GLint xoffset,
GLsizei width, GLenum format, GLenum type,
struct gl_image *image )
{
struct gl_texture_image *destTex;
if (target!=GL_TEXTURE_1D) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage1D(target)" );
return;
}
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage1D(level)" );
return;
}
destTex = ctx->Texture.Current1D->Image[level];
if (!destTex) {
gl_error( ctx, GL_INVALID_OPERATION, "glTexSubImage1D" );
return;
}
if (xoffset < -destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage1D(xoffset)" );
return;
}
if (xoffset + width > destTex->Width + destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage1D(xoffset+width)" );
return;
}
if (image) {
GLint texcomponents = components_in_intformat(destTex->Format);
if (image->Type==GL_UNSIGNED_BYTE && texcomponents==image->Components) {
GLubyte *dst = destTex->Data + texcomponents * xoffset;
GLubyte *src = (GLubyte *) image->Data;
MEMCPY( dst, src, width * texcomponents );
}
else {
struct gl_texture_image *subTexImg = image_to_texture(ctx, image,
destTex->IntFormat, destTex->Border);
GLubyte *dst = destTex->Data + texcomponents * xoffset;
GLubyte *src = subTexImg->Data;
MEMCPY( dst, src, width * texcomponents );
gl_free_texture_image(subTexImg);
}
if (image->RefCount==0) {
gl_free_image(image);
}
ctx->Texture.Current1D->Dirty = GL_TRUE;
if (ctx->Driver.TexImage) {
(*ctx->Driver.TexImage)( ctx, GL_TEXTURE_1D,
ctx->Texture.Current1D,
level, ctx->Texture.Current1D->Image[level]->IntFormat,
				  destTex );
}
}
else {
GLint components, size;
if (width<0) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage1D(width)" );
return;
}
if (type==GL_BITMAP && format!=GL_COLOR_INDEX) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage1D(format)" );
return;
}
components = components_in_intformat( format );
if (components<0 || format==GL_STENCIL_INDEX
|| format==GL_DEPTH_COMPONENT){
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage1D(format)" );
return;
}
size = gl_sizeof_type( type );
if (size<=0) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage1D(type)" );
return;
}
gl_error( ctx, GL_OUT_OF_MEMORY, "glTexSubImage1D" );
}
}
void gl_TexSubImage2D( GLcontext *ctx,
GLenum target, GLint level,
GLint xoffset, GLint yoffset,
GLsizei width, GLsizei height,
GLenum format, GLenum type,
struct gl_image *image )
{
struct gl_texture_image *destTex;
if (target!=GL_TEXTURE_2D) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(target)" );
return;
}
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(level)" );
return;
}
destTex = ctx->Texture.Current2D->Image[level];
if (!destTex) {
gl_error( ctx, GL_INVALID_OPERATION, "glTexSubImage2D" );
return;
}
if (xoffset < -destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage2D(xoffset)" );
return;
}
if (yoffset < -destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage2D(yoffset)" );
return;
}
if (xoffset + width > destTex->Width + destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage2D(xoffset+width)" );
return;
}
if (yoffset + height > destTex->Height + destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage2D(yoffset+height)" );
return;
}
if (image) {
GLint texcomponents = components_in_intformat(destTex->Format);
if (image->Type==GL_UNSIGNED_BYTE && texcomponents==image->Components) {
GLubyte *dst = destTex->Data
+ (yoffset * destTex->Width + xoffset) * texcomponents;
GLubyte *src = (GLubyte *) image->Data;
GLint  j;
for (j=0;j<height;j++) {
MEMCPY( dst, src, width * texcomponents );
dst += destTex->Width * texcomponents * sizeof(GLubyte);
src += width * texcomponents * sizeof(GLubyte);
}
}
else {
struct gl_texture_image *subTexImg = image_to_texture(ctx, image,
destTex->IntFormat, destTex->Border);
GLubyte *dst = destTex->Data
+ (yoffset * destTex->Width + xoffset) * texcomponents;
GLubyte *src = subTexImg->Data;
GLint j;
for (j=0;j<height;j++) {
MEMCPY( dst, src, width * texcomponents );
dst += destTex->Width * texcomponents * sizeof(GLubyte);
src += width * texcomponents * sizeof(GLubyte);
}
gl_free_texture_image(subTexImg);
}
if (image->RefCount==0) {
gl_free_image(image);
}
ctx->Texture.Current2D->Dirty = GL_TRUE;
if (ctx->Driver.TexImage) {
(*ctx->Driver.TexImage)( ctx, GL_TEXTURE_2D, ctx->Texture.Current2D,
level, ctx->Texture.Current2D->Image[level]->IntFormat,
				  destTex );
}
}
else {
GLint components, size;
if (width<0) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage2D(width)" );
return;
}
if (height<0) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage2D(height)" );
return;
}
if (type==GL_BITMAP && format!=GL_COLOR_INDEX) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage1D(format)" );
return;
}
components = gl_components_in_format( format );
if (components<0 || format==GL_STENCIL_INDEX
|| format==GL_DEPTH_COMPONENT){
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(format)" );
return;
}
size = gl_sizeof_type( type );
if (size<=0) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage2D(type)" );
return;
}
gl_error( ctx, GL_OUT_OF_MEMORY, "glTexSubImage2D" );
}
}
void gl_TexSubImage3DEXT( GLcontext *ctx,
GLenum target, GLint level,
GLint xoffset, GLint yoffset, GLint zoffset,
GLsizei width, GLsizei height, GLsizei depth,
GLenum format, GLenum type,
struct gl_image *image )
{
struct gl_texture_image *destTex;
if (target!=GL_TEXTURE_3D_EXT) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage3DEXT(target)" );
return;
}
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage3DEXT(level)" );
return;
}
destTex = ctx->Texture.Current3D->Image[level];
if (!destTex) {
gl_error( ctx, GL_INVALID_OPERATION, "glTexSubImage3DEXT" );
return;
}
if (xoffset < -destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage3DEXT(xoffset)" );
return;
}
if (yoffset < -destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage3DEXT(yoffset)" );
return;
}
if (zoffset < -destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage3DEXT(zoffset)" );
return;
}
if (xoffset + width > destTex->Width+destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage3DEXT(xoffset+width)" );
return;
}
if (yoffset + height > destTex->Height+destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage3DEXT(yoffset+height)" );
return;
}
if (zoffset + depth  > destTex->Depth+destTex->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage3DEXT(zoffset+depth)" );
return;
}
if (image) {
GLint texcomponents = components_in_intformat(destTex->Format);
GLint dstRectArea = destTex->Width * destTex->Height;
GLint srcRectArea = width * height;
if (image->Type==GL_UNSIGNED_BYTE && texcomponents==image->Components) {
GLubyte *dst = destTex->Data
+ (zoffset * dstRectArea +  yoffset * destTex->Width + xoffset)
* texcomponents;
GLubyte *src = (GLubyte *) image->Data;
GLint j, k;
for(k=0;k<depth; k++) {
for (j=0;j<height;j++) {
MEMCPY( dst, src, width * texcomponents );
dst += destTex->Width * texcomponents;
src += width * texcomponents;
}
dst += dstRectArea * texcomponents * sizeof(GLubyte);
src += srcRectArea * texcomponents * sizeof(GLubyte);
}
}
else {
struct gl_texture_image *subTexImg = image_to_texture(ctx, image,
destTex->IntFormat, destTex->Border);
GLubyte *dst = destTex->Data
+ (zoffset * dstRectArea +  yoffset * destTex->Width + xoffset)
* texcomponents;
GLubyte *src = subTexImg->Data;
GLint j, k;
for(k=0;k<depth; k++) {
for (j=0;j<height;j++) {
MEMCPY( dst, src, width * texcomponents );
dst += destTex->Width * texcomponents;
src += width * texcomponents;
}
dst += dstRectArea * texcomponents * sizeof(GLubyte);
src += srcRectArea * texcomponents * sizeof(GLubyte);
}
gl_free_texture_image(subTexImg);
}
if (image->RefCount==0) {
gl_free_image(image);
}
ctx->Texture.Current3D->Dirty = GL_TRUE;
if (ctx->Driver.TexImage) {
(*ctx->Driver.TexImage)( ctx, GL_TEXTURE_3D_EXT,
ctx->Texture.Current3D,
level, ctx->Texture.Current3D->Image[level]->IntFormat,
				  destTex );
}
}
else {
GLint components, size;
if (width<0) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage3DEXT(width)" );
return;
}
if (height<0) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage3DEXT(height)" );
return;
}
if (depth<0) {
gl_error( ctx, GL_INVALID_VALUE, "glTexSubImage3DEXT(depth)" );
return;
}
if (type==GL_BITMAP && format!=GL_COLOR_INDEX) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage3DEXT(format)" );
return;
}
components = components_in_intformat( format );
if (components<0 || format==GL_STENCIL_INDEX
|| format==GL_DEPTH_COMPONENT){
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage3DEXT(format)" );
return;
}
size = gl_sizeof_type( type );
if (size<=0) {
gl_error( ctx, GL_INVALID_ENUM, "glTexSubImage3DEXT(type)" );
return;
}
gl_error( ctx, GL_OUT_OF_MEMORY, "glTexSubImage3DEXT" );
}
}
static struct gl_image *read_color_image( GLcontext *ctx, GLint x, GLint y,
GLsizei width, GLsizei height,
GLint format )
{
struct gl_image *image;
GLubyte *imgptr;
GLint components;
GLint i, j;
components = components_in_intformat( format );
image = (struct gl_image *) malloc( sizeof(struct gl_image) );
if (image) {
image->Width = width;
image->Height = height;
image->Depth = 1;
image->Components = components;
image->Format = format;
image->Type = GL_UNSIGNED_BYTE;
image->RefCount = 0;
image->Data = (GLubyte *) malloc( width * height * components );
if (!image->Data) {
free(image);
return NULL;
}
}
else {
return NULL;
}
imgptr = (GLubyte *) image->Data;
(void) (*ctx->Driver.SetBuffer)( ctx, ctx->Pixel.ReadBuffer );
for (j=0;j<height;j++) {
GLubyte red[MAX_WIDTH], green[MAX_WIDTH];
GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];
gl_read_color_span( ctx, width, x, y+j, red, green, blue, alpha );
if (!ctx->Visual->EightBitColor) {
float rscale = 255.0f * ctx->Visual->InvRedScale;
float gscale = 255.0f * ctx->Visual->InvGreenScale;
float bscale = 255.0f * ctx->Visual->InvBlueScale;
float ascale = 255.0f * ctx->Visual->InvAlphaScale;
for (i=0;i<width;i++) {
red[i]   = (GLubyte) (GLint) (red[i]   * rscale);
green[i] = (GLubyte) (GLint) (green[i] * gscale);
blue[i]  = (GLubyte) (GLint) (blue[i]  * bscale);
alpha[i] = (GLubyte) (GLint) (alpha[i] * ascale);
}
}
switch (format) {
case GL_ALPHA:
for (i=0;i<width;i++) {
*imgptr++ = alpha[i];
}
break;
case GL_LUMINANCE:
for (i=0;i<width;i++) {
*imgptr++ = red[i];
}
break;
case GL_LUMINANCE_ALPHA:
for (i=0;i<width;i++) {
*imgptr++ = red[i];
*imgptr++ = alpha[i];
}
break;
case GL_INTENSITY:
for (i=0;i<width;i++) {
*imgptr++ = red[i];
}
break;
case GL_RGB:
for (i=0;i<width;i++) {
*imgptr++ = red[i];
*imgptr++ = green[i];
*imgptr++ = blue[i];
}
break;
case GL_RGBA:
for (i=0;i<width;i++) {
*imgptr++ = red[i];
*imgptr++ = green[i];
*imgptr++ = blue[i];
*imgptr++ = alpha[i];
}
break;
}
}
(void) (*ctx->Driver.SetBuffer)( ctx, ctx->Color.DrawBuffer );
return image;
}
void gl_CopyTexImage1D( GLcontext *ctx,
GLenum target, GLint level,
GLenum internalformat,
GLint x, GLint y,
GLsizei width, GLint border )
{
GLint format;
struct gl_image *teximage;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glCopyTexImage1D" );
return;
}
if (target!=GL_TEXTURE_1D) {
gl_error( ctx, GL_INVALID_ENUM, "glCopyTexImage1D(target)" );
return;
}
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexImage1D(level)" );
return;
}
if (border!=0 && border!=1) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexImage1D(border)" );
return;
}
if (width<2*border || width>2+MAX_TEXTURE_SIZE || width<0) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexImage1D(width)" );
return;
}
format = decode_internal_format1( internalformat );
if (format<0 || (internalformat>=1 && internalformat<=4)) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexImage1D(format)" );
return;
}
teximage = read_color_image( ctx, x, y, width, 1, format );
if (!teximage) {
gl_error( ctx, GL_OUT_OF_MEMORY, "glCopyTexImage1D" );
return;
}
gl_TexImage1D( ctx, target, level, internalformat, width,
border, GL_RGBA, GL_UNSIGNED_BYTE, teximage );
}
void gl_CopyTexImage2D( GLcontext *ctx,
GLenum target, GLint level, GLenum internalformat,
GLint x, GLint y, GLsizei width, GLsizei height,
GLint border )
{
GLint format;
struct gl_image *teximage;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glCopyTexImage2D" );
return;
}
if (target!=GL_TEXTURE_2D) {
gl_error( ctx, GL_INVALID_ENUM, "glCopyTexImage2D(target)" );
return;
}
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexImage2D(level)" );
return;
}
if (border!=0 && border!=1) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexImage2D(border)" );
return;
}
if (width<2*border || width>2+MAX_TEXTURE_SIZE || width<0) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexImage2D(width)" );
return;
}
if (height<2*border || height>2+MAX_TEXTURE_SIZE || height<0) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexImage2D(height)" );
return;
}
format = decode_internal_format1( internalformat );
if (format<0 || (internalformat>=1 && internalformat<=4)) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexImage2D(format)" );
return;
}
teximage = read_color_image( ctx, x, y, width, height, format );
if (!teximage) {
gl_error( ctx, GL_OUT_OF_MEMORY, "glCopyTexImage2D" );
return;
}
gl_TexImage2D( ctx, target, level, internalformat, width, height,
border, GL_RGBA, GL_UNSIGNED_BYTE, teximage );
}
static void copy_tex_sub_image( GLcontext *ctx, struct gl_texture_image *dest,
GLint width, GLint height,
GLint srcx, GLint srcy,
GLint dstx, GLint dsty, GLint zoffset )
{
GLint i, j;
GLint format, components, rectarea;
rectarea = width*height;
zoffset *= rectarea;
format = dest->Format;
components = components_in_intformat( format );
for (j=0;j<height;j++) {
GLubyte red[MAX_WIDTH], green[MAX_WIDTH];
GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];
GLubyte *texptr;
gl_read_color_span( ctx, width, srcx, srcy+j, red, green, blue, alpha );
if (!ctx->Visual->EightBitColor) {
float rscale = 255.0f * ctx->Visual->InvRedScale;
float gscale = 255.0f * ctx->Visual->InvGreenScale;
float bscale = 255.0f * ctx->Visual->InvBlueScale;
float ascale = 255.0f * ctx->Visual->InvAlphaScale;
for (i=0;i<width;i++) {
red[i]   = (GLubyte) (GLint) (red[i]   * rscale);
green[i] = (GLubyte) (GLint) (green[i] * gscale);
blue[i]  = (GLubyte) (GLint) (blue[i]  * bscale);
alpha[i] = (GLubyte) (GLint) (alpha[i] * ascale);
}
}
texptr = dest->Data + ( zoffset + (dsty+j) * width + dstx) * components;
switch (format) {
case GL_ALPHA:
for (i=0;i<width;i++) {
*texptr++ = alpha[i];
}
break;
case GL_LUMINANCE:
for (i=0;i<width;i++) {
*texptr++ = red[i];
}
break;
case GL_LUMINANCE_ALPHA:
for (i=0;i<width;i++) {
*texptr++ = red[i];
*texptr++ = alpha[i];
}
break;
case GL_INTENSITY:
for (i=0;i<width;i++) {
*texptr++ = red[i];
}
break;
case GL_RGB:
for (i=0;i<width;i++) {
*texptr++ = red[i];
*texptr++ = green[i];
*texptr++ = blue[i];
}
break;
case GL_RGBA:
for (i=0;i<width;i++) {
*texptr++ = red[i];
*texptr++ = green[i];
*texptr++ = blue[i];
*texptr++ = alpha[i];
}
break;
}
}
}
void gl_CopyTexSubImage1D( GLcontext *ctx,
GLenum target, GLint level,
GLint xoffset, GLint x, GLint y, GLsizei width )
{
struct gl_texture_image *teximage;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glCopyTexSubImage1D" );
return;
}
if (target!=GL_TEXTURE_1D) {
gl_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage1D(target)" );
return;
}
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage1D(level)" );
return;
}
if (width<0) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage1D(width)" );
return;
}
teximage = ctx->Texture.Current1D->Image[level];
if (teximage) {
if (xoffset < -teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage1D(xoffset)" );
return;
}
if (xoffset+width > teximage->Width+teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE,
"glCopyTexSubImage1D(xoffset+width)" );
return;
}
if (teximage->Data) {
copy_tex_sub_image( ctx, teximage, width, 1, x, y, xoffset, 0, 0 );
}
}
else {
gl_error( ctx, GL_INVALID_OPERATION, "glCopyTexSubImage1D" );
}
}
void gl_CopyTexSubImage2D( GLcontext *ctx,
GLenum target, GLint level,
GLint xoffset, GLint yoffset,
GLint x, GLint y, GLsizei width, GLsizei height )
{
struct gl_texture_image *teximage;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glCopyTexSubImage2D" );
return;
}
if (target!=GL_TEXTURE_2D) {
gl_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage2D(target)" );
return;
}
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage2D(level)" );
return;
}
if (width<0) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage2D(width)" );
return;
}
if (height<0) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage2D(height)" );
return;
}
teximage = ctx->Texture.Current2D->Image[level];
if (teximage) {
if (xoffset < -teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage2D(xoffset)" );
return;
}
if (yoffset < -teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage2D(yoffset)" );
return;
}
if (xoffset+width > teximage->Width+teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE,
"glCopyTexSubImage2D(xoffset+width)" );
return;
}
if (yoffset+height > teximage->Height+teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE,
"glCopyTexSubImage2D(yoffset+height)" );
return;
}
if (teximage->Data) {
copy_tex_sub_image( ctx, teximage, width, height,
x, y, xoffset, yoffset, 0 );
}
}
else {
gl_error( ctx, GL_INVALID_OPERATION, "glCopyTexSubImage2D" );
}
}
void gl_CopyTexSubImage3DEXT( GLcontext *ctx,
GLenum target, GLint level,
GLint xoffset, GLint yoffset, GLint zoffset,
GLint x, GLint y, GLsizei width, GLsizei height )
{
struct gl_texture_image *teximage;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glCopyTexSubImage3DEXT" );
return;
}
if (target!=GL_TEXTURE_2D) {
gl_error( ctx, GL_INVALID_ENUM, "glCopyTexSubImage3DEXT(target)" );
return;
}
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage3DEXT(level)" );
return;
}
if (width<0) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage3DEXT(width)" );
return;
}
if (height<0) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage3DEXT(height)" );
return;
}
teximage = ctx->Texture.Current3D->Image[level];
if (teximage) {
if (xoffset < -teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage3DEXT(xoffset)" );
return;
}
if (yoffset < -teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage3DEXT(yoffset)" );
return;
}
if (zoffset < -teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE, "glCopyTexSubImage3DEXT(zoffset)" );
return;
}
if (xoffset+width > teximage->Width+teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE,
"glCopyTexSubImage3DEXT(xoffset+width)" );
return;
}
if (yoffset+height > teximage->Height+teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE,
"glCopyTexSubImage3DEXT(yoffset+height)" );
return;
}
if (zoffset > teximage->Depth+teximage->Border) {
gl_error( ctx, GL_INVALID_VALUE,
"glCopyTexSubImage3DEXT(zoffset+depth)" );
return;
}
if (teximage->Data) {
copy_tex_sub_image( ctx, teximage, width, height,
x, y, xoffset, yoffset, zoffset);
}
}
else {
gl_error( ctx, GL_INVALID_OPERATION, "glCopyTexSubImage3DEXT" );
}
}
/* 当前文件是D:\Read\texobj.c*/

#ifdef PC_HEADER
#else
#endif
struct gl_texture_object *
gl_alloc_texture_object( struct gl_shared_state *shared, GLuint name,
GLuint dimensions)
{
struct gl_texture_object *obj;
assert(dimensions >= 1 && dimensions <= 3);
obj = (struct gl_texture_object *)
calloc(1,sizeof(struct gl_texture_object));
if (obj) {
obj->Name = name;
obj->Dimensions = dimensions;
obj->WrapS = GL_REPEAT;
obj->WrapT = GL_REPEAT;
obj->MinFilter = GL_NEAREST_MIPMAP_LINEAR;
obj->MagFilter = GL_LINEAR;
obj->MinMagThresh = 0.0F;
obj->Palette[0] = 255;
obj->Palette[1] = 255;
obj->Palette[2] = 255;
obj->Palette[3] = 255;
obj->PaletteSize = 1;
obj->PaletteIntFormat = GL_RGBA;
obj->PaletteFormat = GL_RGBA;
if (shared) {
obj->Next = shared->TexObjectList;
shared->TexObjectList = obj;
}
if (name > 0) {
HashInsert(shared->TexObjects, name, obj);
}
}
return obj;
}
void gl_free_texture_object( struct gl_shared_state *shared,
struct gl_texture_object *t )
{
struct gl_texture_object *tprev, *tcurr;
assert(t);
if (shared) {
tprev = NULL;
tcurr = shared->TexObjectList;
while (tcurr) {
if (tcurr==t) {
if (tprev) {
tprev->Next = t->Next;
}
else {
shared->TexObjectList = t->Next;
}
break;
}
tprev = tcurr;
tcurr = tcurr->Next;
}
}
if (t->Name) {
HashRemove(shared->TexObjects, t->Name);
}
{
GLuint i;
for (i=0;i<MAX_TEXTURE_LEVELS;i++) {
if (t->Image[i]) {
gl_free_texture_image( t->Image[i] );
}
}
}
free( t );
}
void gl_test_texture_object_completeness( struct gl_texture_object *t )
{
t->Complete = GL_TRUE;
if (!t->Image[0] || !t->Image[0]->Data) {
t->Complete = GL_FALSE;
return;
}
if (t->MinFilter!=GL_NEAREST && t->MinFilter!=GL_LINEAR) {
int i;
for (i=1; i<MAX_TEXTURE_LEVELS; i++) {
if (t->Image[i]) {
if (!t->Image[i]->Data) {
t->Complete = GL_FALSE;
return;
}
if (t->Image[i]->Format != t->Image[0]->Format) {
t->Complete = GL_FALSE;
return;
}
if (t->Image[i]->Border != t->Image[0]->Border) {
t->Complete = GL_FALSE;
return;
}
}
}
if (t->Dimensions==1) {
GLuint width = t->Image[0]->Width2;
for (i=1; i<MAX_TEXTURE_LEVELS; i++) {
if (width>1) {
width /= 2;
}
if (!t->Image[i]) {
t->Complete = GL_FALSE;
return;
}
if (!t->Image[i]->Data) {
t->Complete = GL_FALSE;
return;
}
if (t->Image[i]->Format != t->Image[0]->Format) {
t->Complete = GL_FALSE;
return;
}
if (t->Image[i]->Border != t->Image[0]->Border) {
t->Complete = GL_FALSE;
return;
}
if (t->Image[i]->Width2 != width ) {
t->Complete = GL_FALSE;
return;
}
if (width==1) {
return;
}
}
}
else if (t->Dimensions==2) {
GLuint width = t->Image[0]->Width2;
GLuint height = t->Image[0]->Height2;
for (i=1; i<MAX_TEXTURE_LEVELS; i++) {
if (width>1) {
width /= 2;
}
if (height>1) {
height /= 2;
}
if (!t->Image[i]) {
t->Complete = GL_FALSE;
return;
}
if (t->Image[i]->Width2 != width) {
t->Complete = GL_FALSE;
return;
}
if (t->Image[i]->Height2 != height) {
t->Complete = GL_FALSE;
return;
}
if (width==1 && height==1) {
return;
}
}
}
else if (t->Dimensions==3) {
GLuint width = t->Image[0]->Width2;
GLuint height = t->Image[0]->Height2;
GLuint depth = t->Image[0]->Depth2;
for (i=1; i<MAX_TEXTURE_LEVELS; i++) {
if (width>1) {
width /= 2;
}
if (height>1) {
height /= 2;
}
if (depth>1) {
depth /= 2;
}
if (!t->Image[i]) {
t->Complete = GL_FALSE;
return;
}
if (t->Image[i]->Width2 != width) {
t->Complete = GL_FALSE;
return;
}
if (t->Image[i]->Height2 != height) {
t->Complete = GL_FALSE;
return;
}
if (t->Image[i]->Depth2 != depth) {
t->Complete = GL_FALSE;
return;
}
if (width==1 && height==1 && depth==1) {
return;
}
}
}
else {
gl_problem(NULL, "Bug in gl_test_texture_object_completeness\n");
}
}
}
void gl_GenTextures( GLcontext *ctx, GLsizei n, GLuint *texName )
{
GLuint first, i;
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGenTextures" );
return;
}
if (n<0) {
gl_error( ctx, GL_INVALID_VALUE, "glGenTextures" );
return;
}
first = HashFindFreeKeyBlock(ctx->Shared->TexObjects, n);
for (i=0;i<n;i++) {
texName[i] = first + i;
}
}


/* 当前文件是D:\Read\texstate.c*/

#ifdef PC_HEADER
#else
#endif
void gl_TexEnvfv( GLcontext *ctx,
GLenum target, GLenum pname, const float *param )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glTexEnv" );
return;
}
if (target!=GL_TEXTURE_ENV) {
gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(target)" );
return;
}
if (pname==GL_TEXTURE_ENV_MODE) {
GLenum mode = (GLenum) (GLint) *param;
switch (mode) {
	 case GL_MODULATE:
	 case GL_BLEND:
	 case GL_DECAL:
	 case GL_REPLACE:
	    ctx->Texture.EnvMode = mode;
	    break;
	 default:
	    gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(param)" );
	    return;
}
}
else if (pname==GL_TEXTURE_ENV_COLOR) {
ctx->Texture.EnvColor[0] = CLAMP( param[0], 0.0, 1.0 );
ctx->Texture.EnvColor[1] = CLAMP( param[1], 0.0, 1.0 );
ctx->Texture.EnvColor[2] = CLAMP( param[2], 0.0, 1.0 );
ctx->Texture.EnvColor[3] = CLAMP( param[3], 0.0, 1.0 );
}
else {
gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname)" );
return;
}
if (ctx->Driver.TexEnv) {
(*ctx->Driver.TexEnv)( ctx, pname, param );
}
}
void gl_GetTexEnvfv( GLcontext *ctx,
GLenum target, GLenum pname, float *params )
{
if (target!=GL_TEXTURE_ENV) {
gl_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
return;
}
switch (pname) {
case GL_TEXTURE_ENV_MODE:
*params = (float) ctx->Texture.EnvMode;
	 break;
case GL_TEXTURE_ENV_COLOR:
	 COPY_4V( params, ctx->Texture.EnvColor );
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)" );
}
}
void gl_GetTexEnviv( GLcontext *ctx,
GLenum target, GLenum pname, GLint *params )
{
if (target!=GL_TEXTURE_ENV) {
gl_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
return;
}
switch (pname) {
case GL_TEXTURE_ENV_MODE:
*params = (GLint) ctx->Texture.EnvMode;
	 break;
case GL_TEXTURE_ENV_COLOR:
	 params[0] = FLOAT_TO_INT( ctx->Texture.EnvColor[0] );
	 params[1] = FLOAT_TO_INT( ctx->Texture.EnvColor[1] );
	 params[2] = FLOAT_TO_INT( ctx->Texture.EnvColor[2] );
	 params[3] = FLOAT_TO_INT( ctx->Texture.EnvColor[3] );
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)" );
}
}
void gl_TexParameterfv( GLcontext *ctx,
GLenum target, GLenum pname, const float *params )
{
GLenum eparam = (GLenum) (GLint) params[0];
struct gl_texture_object *texObj;
switch (target) {
case GL_TEXTURE_1D:
texObj = ctx->Texture.Current1D;
break;
case GL_TEXTURE_2D:
texObj = ctx->Texture.Current2D;
break;
case GL_TEXTURE_3D_EXT:
texObj = ctx->Texture.Current3D;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glTexParameter(target)" );
return;
}
switch (pname) {
case GL_TEXTURE_MIN_FILTER:
if (eparam==GL_NEAREST || eparam==GL_LINEAR
|| eparam==GL_NEAREST_MIPMAP_NEAREST
|| eparam==GL_LINEAR_MIPMAP_NEAREST
|| eparam==GL_NEAREST_MIPMAP_LINEAR
|| eparam==GL_LINEAR_MIPMAP_LINEAR) {
texObj->MinFilter = eparam;
ctx->NewState |= NEW_TEXTURING;
}
else {
gl_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
return;
}
break;
case GL_TEXTURE_MAG_FILTER:
if (eparam==GL_NEAREST || eparam==GL_LINEAR) {
texObj->MagFilter = eparam;
ctx->NewState |= NEW_TEXTURING;
}
else {
gl_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
return;
}
break;
case GL_TEXTURE_WRAP_S:
if (eparam==GL_CLAMP || eparam==GL_REPEAT) {
texObj->WrapS = eparam;
}
else {
gl_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
return;
}
break;
case GL_TEXTURE_WRAP_T:
if (eparam==GL_CLAMP || eparam==GL_REPEAT) {
texObj->WrapT = eparam;
}
else {
gl_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
return;
}
break;
case GL_TEXTURE_WRAP_R_EXT:
if (eparam==GL_CLAMP || eparam==GL_REPEAT) {
texObj->WrapR = eparam;
}
else {
gl_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
}
break;
case GL_TEXTURE_BORDER_COLOR:
texObj->BorderColor[0] = CLAMP((GLint)(params[0]*255.0), 0, 255);
texObj->BorderColor[1] = CLAMP((GLint)(params[1]*255.0), 0, 255);
texObj->BorderColor[2] = CLAMP((GLint)(params[2]*255.0), 0, 255);
texObj->BorderColor[3] = CLAMP((GLint)(params[3]*255.0), 0, 255);
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glTexParameter(pname)" );
return;
}
texObj->Dirty = GL_TRUE;
if (ctx->Driver.TexParameter) {
(*ctx->Driver.TexParameter)( ctx, target, texObj, pname, params );
}
}
void gl_GetTexLevelParameterfv( GLcontext *ctx, GLenum target, GLint level,
GLenum pname, float *params )
{
GLint iparam;
gl_GetTexLevelParameteriv( ctx, target, level, pname, &iparam );
*params = (float) iparam;
}
void gl_GetTexLevelParameteriv( GLcontext *ctx, GLenum target, GLint level,
GLenum pname, GLint *params )
{
struct gl_texture_image *tex;
if (level<0 || level>=MAX_TEXTURE_LEVELS) {
gl_error( ctx, GL_INVALID_VALUE, "glGetTexLevelParameter[if]v" );
return;
}
switch (target) {
case GL_TEXTURE_1D:
tex = ctx->Texture.Current1D->Image[level];
switch (pname) {
	    case GL_TEXTURE_WIDTH:
	       *params = tex->Width;
	       break;
	    case GL_TEXTURE_COMPONENTS:
	       *params = tex->Format;
	       break;
	    case GL_TEXTURE_BORDER:
	       *params = tex->Border;
	       break;
case GL_TEXTURE_RED_SIZE:
case GL_TEXTURE_GREEN_SIZE:
case GL_TEXTURE_BLUE_SIZE:
case GL_TEXTURE_ALPHA_SIZE:
case GL_TEXTURE_INTENSITY_SIZE:
case GL_TEXTURE_LUMINANCE_SIZE:
*params = 8;
break;
case GL_TEXTURE_INDEX_SIZE_EXT:
*params = 8;
break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM,
"glGetTexLevelParameter[if]v(pname)" );
	 }
	 break;
case GL_TEXTURE_2D:
tex = ctx->Texture.Current2D->Image[level];
	 switch (pname) {
	    case GL_TEXTURE_WIDTH:
	       *params = tex->Width;
	       break;
	    case GL_TEXTURE_HEIGHT:
	       *params = tex->Height;
	       break;
	    case GL_TEXTURE_COMPONENTS:
	       *params = tex->Format;
	       break;
	    case GL_TEXTURE_BORDER:
	       *params = tex->Border;
	       break;
case GL_TEXTURE_RED_SIZE:
case GL_TEXTURE_GREEN_SIZE:
case GL_TEXTURE_BLUE_SIZE:
case GL_TEXTURE_ALPHA_SIZE:
case GL_TEXTURE_INTENSITY_SIZE:
case GL_TEXTURE_LUMINANCE_SIZE:
*params = 8;
break;
case GL_TEXTURE_INDEX_SIZE_EXT:
*params = 8;
break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM,
"glGetTexLevelParameter[if]v(pname)" );
	 }
	 break;
case GL_TEXTURE_3D_EXT:
tex = ctx->Texture.Current3D->Image[level];
switch (pname) {
case GL_TEXTURE_WIDTH:
*params = tex->Width;
break;
case GL_TEXTURE_HEIGHT:
*params = tex->Height;
break;
case GL_TEXTURE_DEPTH_EXT:
*params = tex->Depth;
break;
case GL_TEXTURE_COMPONENTS:
*params = tex->Format;
break;
case GL_TEXTURE_BORDER:
*params = tex->Border;
break;
case GL_TEXTURE_INDEX_SIZE_EXT:
*params = 8;
break;
default:
gl_error( ctx, GL_INVALID_ENUM,
"glGetTexLevelParameter[if]v(pname)" );
}
break;
case GL_PROXY_TEXTURE_1D:
tex = ctx->Texture.Proxy1D->Image[level];
switch (pname) {
	    case GL_TEXTURE_WIDTH:
	       *params = tex->Width;
	       break;
	    case GL_TEXTURE_COMPONENTS:
	       *params = tex->Format;
	       break;
	    case GL_TEXTURE_BORDER:
	       *params = tex->Border;
	       break;
case GL_TEXTURE_RED_SIZE:
case GL_TEXTURE_GREEN_SIZE:
case GL_TEXTURE_BLUE_SIZE:
case GL_TEXTURE_ALPHA_SIZE:
case GL_TEXTURE_INTENSITY_SIZE:
case GL_TEXTURE_LUMINANCE_SIZE:
*params = 8;
break;
case GL_TEXTURE_INDEX_SIZE_EXT:
*params = 8;
break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM,
"glGetTexLevelParameter[if]v(pname)" );
	 }
	 break;
case GL_PROXY_TEXTURE_2D:
tex = ctx->Texture.Proxy2D->Image[level];
	 switch (pname) {
	    case GL_TEXTURE_WIDTH:
	       *params = tex->Width;
	       break;
	    case GL_TEXTURE_HEIGHT:
	       *params = tex->Height;
	       break;
	    case GL_TEXTURE_COMPONENTS:
	       *params = tex->Format;
	       break;
	    case GL_TEXTURE_BORDER:
	       *params = tex->Border;
	       break;
case GL_TEXTURE_RED_SIZE:
case GL_TEXTURE_GREEN_SIZE:
case GL_TEXTURE_BLUE_SIZE:
case GL_TEXTURE_ALPHA_SIZE:
case GL_TEXTURE_INTENSITY_SIZE:
case GL_TEXTURE_LUMINANCE_SIZE:
*params = 8;
break;
case GL_TEXTURE_INDEX_SIZE_EXT:
*params = 8;
break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM,
"glGetTexLevelParameter[if]v(pname)" );
	 }
	 break;
case GL_PROXY_TEXTURE_3D_EXT:
tex = ctx->Texture.Proxy3D->Image[level];
	 switch (pname) {
	    case GL_TEXTURE_WIDTH:
	       *params = tex->Width;
	       break;
	    case GL_TEXTURE_HEIGHT:
	       *params = tex->Height;
	       break;
	    case GL_TEXTURE_DEPTH_EXT:
	       *params = tex->Depth;
	       break;
	    case GL_TEXTURE_COMPONENTS:
	       *params = tex->Format;
	       break;
	    case GL_TEXTURE_BORDER:
	       *params = tex->Border;
	       break;
case GL_TEXTURE_RED_SIZE:
case GL_TEXTURE_GREEN_SIZE:
case GL_TEXTURE_BLUE_SIZE:
case GL_TEXTURE_ALPHA_SIZE:
case GL_TEXTURE_INTENSITY_SIZE:
case GL_TEXTURE_LUMINANCE_SIZE:
*params = 8;
break;
case GL_TEXTURE_INDEX_SIZE_EXT:
*params = 8;
break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM,
"glGetTexLevelParameter[if]v(pname)" );
	 }
	 break;
default:
	 gl_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(target)");
}	
}
void gl_GetTexParameterfv( GLcontext *ctx,
GLenum target, GLenum pname, float *params )
{
switch (target) {
case GL_TEXTURE_1D:
switch (pname) {
	    case GL_TEXTURE_MAG_FILTER:
	       *params = (float) ctx->Texture.Current1D->MagFilter;
	       break;
	    case GL_TEXTURE_MIN_FILTER:
	       *params = (float) ctx->Texture.Current1D->MinFilter;
	       break;
	    case GL_TEXTURE_WRAP_S:
	       *params = (float) ctx->Texture.Current1D->WrapS;
	       break;
	    case GL_TEXTURE_WRAP_T:
	       *params = (float) ctx->Texture.Current1D->WrapT;
	       break;
	    case GL_TEXTURE_BORDER_COLOR:
params[0] = ctx->Texture.Current1D->BorderColor[0] / 255.0f;
params[1] = ctx->Texture.Current1D->BorderColor[1] / 255.0f;
params[2] = ctx->Texture.Current1D->BorderColor[2] / 255.0f;
params[3] = ctx->Texture.Current1D->BorderColor[3] / 255.0f;
	       break;
	    case GL_TEXTURE_RESIDENT:
*params = (float) GL_TRUE;
	       break;
case GL_TEXTURE_PRIORITY:
*params = ctx->Texture.Current1D->Priority;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetTexParameterfv(pname)" );
	 }
break;
case GL_TEXTURE_2D:
switch (pname) {
	    case GL_TEXTURE_MAG_FILTER:
	       *params = (float) ctx->Texture.Current2D->MagFilter;
	       break;
	    case GL_TEXTURE_MIN_FILTER:
	       *params = (float) ctx->Texture.Current2D->MinFilter;
	       break;
	    case GL_TEXTURE_WRAP_S:
	       *params = (float) ctx->Texture.Current2D->WrapS;
	       break;
	    case GL_TEXTURE_WRAP_T:
	       *params = (float) ctx->Texture.Current2D->WrapT;
	       break;
	    case GL_TEXTURE_BORDER_COLOR:
params[0] = ctx->Texture.Current2D->BorderColor[0] / 255.0f;
params[1] = ctx->Texture.Current2D->BorderColor[1] / 255.0f;
params[2] = ctx->Texture.Current2D->BorderColor[2] / 255.0f;
params[3] = ctx->Texture.Current2D->BorderColor[3] / 255.0f;
break;
	    case GL_TEXTURE_RESIDENT:
*params = (float) GL_TRUE;
	       break;
	    case GL_TEXTURE_PRIORITY:
*params = ctx->Texture.Current2D->Priority;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetTexParameterfv(pname)" );
	 }
	 break;
case GL_TEXTURE_3D_EXT:
switch (pname) {
case GL_TEXTURE_MAG_FILTER:
*params = (float) ctx->Texture.Current3D->MagFilter;
break;
case GL_TEXTURE_MIN_FILTER:
*params = (float) ctx->Texture.Current3D->MinFilter;
break;
case GL_TEXTURE_WRAP_S:
*params = (float) ctx->Texture.Current3D->WrapS;
break;
case GL_TEXTURE_WRAP_T:
*params = (float) ctx->Texture.Current3D->WrapT;
break;
case GL_TEXTURE_WRAP_R_EXT:
*params = (float) ctx->Texture.Current3D->WrapR;
break;
case GL_TEXTURE_BORDER_COLOR:
params[0] = ctx->Texture.Current3D->BorderColor[0] / 255.0f;
params[1] = ctx->Texture.Current3D->BorderColor[1] / 255.0f;
params[2] = ctx->Texture.Current3D->BorderColor[2] / 255.0f;
params[3] = ctx->Texture.Current3D->BorderColor[3] / 255.0f;
break;
case GL_TEXTURE_RESIDENT:
*params = (float) GL_TRUE;
break;
case GL_TEXTURE_PRIORITY:
*params = ctx->Texture.Current3D->Priority;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetTexParameterfv(pname)" );
}
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetTexParameterfv(target)" );
}
}
void gl_GetTexParameteriv( GLcontext *ctx,
GLenum target, GLenum pname, GLint *params )
{
switch (target) {
case GL_TEXTURE_1D:
switch (pname) {
	    case GL_TEXTURE_MAG_FILTER:
	       *params = (GLint) ctx->Texture.Current1D->MagFilter;
	       break;
	    case GL_TEXTURE_MIN_FILTER:
	       *params = (GLint) ctx->Texture.Current1D->MinFilter;
	       break;
	    case GL_TEXTURE_WRAP_S:
	       *params = (GLint) ctx->Texture.Current1D->WrapS;
	       break;
	    case GL_TEXTURE_WRAP_T:
	       *params = (GLint) ctx->Texture.Current1D->WrapT;
	       break;
	    case GL_TEXTURE_BORDER_COLOR:
{
float color[4];
color[0] = ctx->Texture.Current1D->BorderColor[0]/255.0;
color[1] = ctx->Texture.Current1D->BorderColor[1]/255.0;
color[2] = ctx->Texture.Current1D->BorderColor[2]/255.0;
color[3] = ctx->Texture.Current1D->BorderColor[3]/255.0;
params[0] = FLOAT_TO_INT( color[0] );
params[1] = FLOAT_TO_INT( color[1] );
params[2] = FLOAT_TO_INT( color[2] );
params[3] = FLOAT_TO_INT( color[3] );
}
	       break;
	    case GL_TEXTURE_RESIDENT:
*params = (GLint) GL_TRUE;
	       break;
	    case GL_TEXTURE_PRIORITY:
*params = (GLint) ctx->Texture.Current1D->Priority;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetTexParameteriv(pname)" );
	 }
break;
case GL_TEXTURE_2D:
switch (pname) {
	    case GL_TEXTURE_MAG_FILTER:
	       *params = (GLint) ctx->Texture.Current2D->MagFilter;
	       break;
	    case GL_TEXTURE_MIN_FILTER:
	       *params = (GLint) ctx->Texture.Current2D->MinFilter;
	       break;
	    case GL_TEXTURE_WRAP_S:
	       *params = (GLint) ctx->Texture.Current2D->WrapS;
	       break;
	    case GL_TEXTURE_WRAP_T:
	       *params = (GLint) ctx->Texture.Current2D->WrapT;
	       break;
	    case GL_TEXTURE_BORDER_COLOR:
{
float color[4];
color[0] = ctx->Texture.Current2D->BorderColor[0]/255.0;
color[1] = ctx->Texture.Current2D->BorderColor[1]/255.0;
color[2] = ctx->Texture.Current2D->BorderColor[2]/255.0;
color[3] = ctx->Texture.Current2D->BorderColor[3]/255.0;
params[0] = FLOAT_TO_INT( color[0] );
params[1] = FLOAT_TO_INT( color[1] );
params[2] = FLOAT_TO_INT( color[2] );
params[3] = FLOAT_TO_INT( color[3] );
}
	       break;
	    case GL_TEXTURE_RESIDENT:
*params = (GLint) GL_TRUE;
	       break;
	    case GL_TEXTURE_PRIORITY:
*params = (GLint) ctx->Texture.Current2D->Priority;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glGetTexParameteriv(pname)" );
	 }
	 break;
case GL_TEXTURE_3D_EXT:
switch (pname) {
case GL_TEXTURE_MAG_FILTER:
*params = (GLint) ctx->Texture.Current3D->MagFilter;
break;
case GL_TEXTURE_MIN_FILTER:
*params = (GLint) ctx->Texture.Current3D->MinFilter;
break;
case GL_TEXTURE_WRAP_S:
*params = (GLint) ctx->Texture.Current3D->WrapS;
break;
case GL_TEXTURE_WRAP_T:
*params = (GLint) ctx->Texture.Current3D->WrapT;
break;
case GL_TEXTURE_WRAP_R_EXT:
*params = (GLint) ctx->Texture.Current3D->WrapR;
break;
case GL_TEXTURE_BORDER_COLOR:
{
float color[4];
color[0] = ctx->Texture.Current3D->BorderColor[0]/255.0;
color[1] = ctx->Texture.Current3D->BorderColor[1]/255.0;
color[2] = ctx->Texture.Current3D->BorderColor[2]/255.0;
color[3] = ctx->Texture.Current3D->BorderColor[3]/255.0;
params[0] = FLOAT_TO_INT( color[0] );
params[1] = FLOAT_TO_INT( color[1] );
params[2] = FLOAT_TO_INT( color[2] );
params[3] = FLOAT_TO_INT( color[3] );
}
break;
case GL_TEXTURE_RESIDENT:
*params = (GLint) GL_TRUE;
break;
case GL_TEXTURE_PRIORITY:
*params = (GLint) ctx->Texture.Current3D->Priority;
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetTexParameteriv(pname)" );
}
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetTexParameteriv(target)" );
}
}
void gl_TexGenfv( GLcontext *ctx,
GLenum coord, GLenum pname, const float *params )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glTexGenfv" );
return;
}
switch( coord ) {
case GL_S:
if (pname==GL_TEXTURE_GEN_MODE) {
	    GLenum mode = (GLenum) (GLint) *params;
	    if (mode==GL_OBJECT_LINEAR ||
		mode==GL_EYE_LINEAR ||
		mode==GL_SPHERE_MAP) {
	       ctx->Texture.GenModeS = mode;
	    }
	    else {
	       gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
	       return;
	    }
	 }
	 else if (pname==GL_OBJECT_PLANE) {
	    ctx->Texture.ObjectPlaneS[0] = params[0];
	    ctx->Texture.ObjectPlaneS[1] = params[1];
	    ctx->Texture.ObjectPlaneS[2] = params[2];
	    ctx->Texture.ObjectPlaneS[3] = params[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
if (ctx->NewModelViewMatrix) {
gl_analyze_modelview_matrix(ctx);
}
gl_transform_vector( ctx->Texture.EyePlaneS, params,
ctx->ModelViewInv );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
	    return;
	 }
	 break;
case GL_T:
if (pname==GL_TEXTURE_GEN_MODE) {
	    GLenum mode = (GLenum) (GLint) *params;
	    if (mode==GL_OBJECT_LINEAR ||
		mode==GL_EYE_LINEAR ||
		mode==GL_SPHERE_MAP) {
	       ctx->Texture.GenModeT = mode;
	    }
	    else {
	       gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
	       return;
	    }
	 }
	 else if (pname==GL_OBJECT_PLANE) {
	    ctx->Texture.ObjectPlaneT[0] = params[0];
	    ctx->Texture.ObjectPlaneT[1] = params[1];
	    ctx->Texture.ObjectPlaneT[2] = params[2];
	    ctx->Texture.ObjectPlaneT[3] = params[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
if (ctx->NewModelViewMatrix) {
gl_analyze_modelview_matrix(ctx);
}
gl_transform_vector( ctx->Texture.EyePlaneT, params,
ctx->ModelViewInv );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
	    return;
	 }
	 break;
case GL_R:
if (pname==GL_TEXTURE_GEN_MODE) {
	    GLenum mode = (GLenum) (GLint) *params;
	    if (mode==GL_OBJECT_LINEAR ||
		mode==GL_EYE_LINEAR) {
	       ctx->Texture.GenModeR = mode;
	    }
	    else {
	       gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
	       return;
	    }
	 }
	 else if (pname==GL_OBJECT_PLANE) {
	    ctx->Texture.ObjectPlaneR[0] = params[0];
	    ctx->Texture.ObjectPlaneR[1] = params[1];
	    ctx->Texture.ObjectPlaneR[2] = params[2];
	    ctx->Texture.ObjectPlaneR[3] = params[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
if (ctx->NewModelViewMatrix) {
gl_analyze_modelview_matrix(ctx);
}
gl_transform_vector( ctx->Texture.EyePlaneR, params,
ctx->ModelViewInv );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
	    return;
	 }
	 break;
case GL_Q:
if (pname==GL_TEXTURE_GEN_MODE) {
	    GLenum mode = (GLenum) (GLint) *params;
	    if (mode==GL_OBJECT_LINEAR ||
		mode==GL_EYE_LINEAR) {
	       ctx->Texture.GenModeQ = mode;
	    }
	    else {
	       gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
	       return;
	    }
	 }
	 else if (pname==GL_OBJECT_PLANE) {
	    ctx->Texture.ObjectPlaneQ[0] = params[0];
	    ctx->Texture.ObjectPlaneQ[1] = params[1];
	    ctx->Texture.ObjectPlaneQ[2] = params[2];
	    ctx->Texture.ObjectPlaneQ[3] = params[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
if (ctx->NewModelViewMatrix) {
gl_analyze_modelview_matrix(ctx);
}
gl_transform_vector( ctx->Texture.EyePlaneQ, params,
ctx->ModelViewInv );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
	    return;
	 }
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(coord)" );
	 return;
}
ctx->NewState |= NEW_TEXTURING;
}
void gl_GetTexGendv( GLcontext *ctx,
GLenum coord, GLenum pname, GLdouble *params )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetTexGendv" );
return;
}
switch( coord ) {
case GL_S:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeS;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneS );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneS );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
	    return;
	 }
	 break;
case GL_T:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeT;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneT );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneT );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
	    return;
	 }
	 break;
case GL_R:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeR;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneR );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneR );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
	    return;
	 }
	 break;
case GL_Q:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeQ;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneQ );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneQ );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
	    return;
	 }
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(coord)" );
	 return;
}
}
void gl_GetTexGenfv( GLcontext *ctx,
GLenum coord, GLenum pname, float *params )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetTexGenfv" );
return;
}
switch( coord ) {
case GL_S:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeS;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneS );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneS );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
	    return;
	 }
	 break;
case GL_T:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeT;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneT );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneT );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
	    return;
	 }
	 break;
case GL_R:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeR;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneR );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneR );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
	    return;
	 }
	 break;
case GL_Q:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeQ;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneQ );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneQ );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
	    return;
	 }
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(coord)" );
	 return;
}
}
void gl_GetTexGeniv( GLcontext *ctx,
GLenum coord, GLenum pname, GLint *params )
{
if (INSIDE_BEGIN_END(ctx)) {
gl_error( ctx, GL_INVALID_OPERATION, "glGetTexGeniv" );
return;
}
switch( coord ) {
case GL_S:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeS;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneS );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneS );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
	    return;
	 }
	 break;
case GL_T:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeT;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneT );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneT );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
	    return;
	 }
	 break;
case GL_R:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeR;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneR );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneR );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
	    return;
	 }
	 break;
case GL_Q:
if (pname==GL_TEXTURE_GEN_MODE) {
params[0] = ctx->Texture.GenModeQ;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
COPY_4V( params, ctx->Texture.ObjectPlaneQ );
	 }
	 else if (pname==GL_EYE_PLANE) {
COPY_4V( params, ctx->Texture.EyePlaneQ );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
	    return;
	 }
	 break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(coord)" );
	 return;
}
}
void gl_update_texture_state( GLcontext *ctx )
{
struct gl_texture_object *t;
if (ctx->Texture.Enabled & TEXTURE_3D)
ctx->Texture.Current = ctx->Texture.Current3D;
else if (ctx->Texture.Enabled & TEXTURE_2D)
ctx->Texture.Current = ctx->Texture.Current2D;
else if (ctx->Texture.Enabled & TEXTURE_1D)
ctx->Texture.Current = ctx->Texture.Current1D;
else
ctx->Texture.Current = NULL;
for (t = ctx->Shared->TexObjectList; t; t = t->Next) {
if (t->Dirty) {
gl_test_texture_object_completeness(t);
gl_set_texture_sampler(t);
t->Dirty = GL_FALSE;
}
}
}

/* 当前文件是D:\Read\texture.c*/

#ifdef PC_HEADER
#else
#endif
void gl_texgen( GLcontext *ctx, GLint n,
float obj[][4], float eye[][4],
float normal[][3], float texcoord[][4] )
{
if (ctx->Texture.TexGenEnabled==(S_BIT|T_BIT)
&& ctx->Texture.GenModeS==GL_SPHERE_MAP
&& ctx->Texture.GenModeT==GL_SPHERE_MAP) {
GLint i;
for (i=0;i<n;i++) {
float u[3], two_nu, m, fx, fy, fz;
COPY_3V( u, eye[i] );
NORMALIZE_3FV( u );
two_nu = 2.0F * DOT3(normal[i],u);
fx = u[0] - normal[i][0] * two_nu;
fy = u[1] - normal[i][1] * two_nu;
fz = u[2] - normal[i][2] * two_nu;
m = 2.0F * GL_SQRT( fx*fx + fy*fy + (fz+1.0F)*(fz+1.0F) );
if (m==0.0F) {
texcoord[i][0] = 0.5F;
texcoord[i][1] = 0.5F;
}
else {
float mInv = 1.0F / m;
texcoord[i][0] = fx * mInv + 0.5F;
texcoord[i][1] = fy * mInv + 0.5F;
}
}
return;
}
if (ctx->Texture.TexGenEnabled & S_BIT) {
GLint i;
switch (ctx->Texture.GenModeS) {
case GL_OBJECT_LINEAR:
for (i=0;i<n;i++) {
texcoord[i][0] = DOT4( obj[i], ctx->Texture.ObjectPlaneS );
}
break;
case GL_EYE_LINEAR:
for (i=0;i<n;i++) {
texcoord[i][0] = DOT4( eye[i], ctx->Texture.EyePlaneS );
}
break;
case GL_SPHERE_MAP:
for (i=0;i<n;i++) {
float u[3], two_nu, m, fx, fy, fz;
COPY_3V( u, eye[i] );
NORMALIZE_3FV( u );
two_nu = 2.0*DOT3(normal[i],u);
fx = u[0] - normal[i][0] * two_nu;
fy = u[1] - normal[i][1] * two_nu;
fz = u[2] - normal[i][2] * two_nu;
m = 2.0F * GL_SQRT( fx*fx + fy*fy + (fz+1.0)*(fz+1.0) );
if (m==0.0F) {
texcoord[i][0] = 0.5F;
}
else {
texcoord[i][0] = fx / m + 0.5F;
}
}
break;
default:
gl_problem(ctx, "Bad S texgen");
return;
}
}
if (ctx->Texture.TexGenEnabled & T_BIT) {
GLint i;
switch (ctx->Texture.GenModeT) {
case GL_OBJECT_LINEAR:
for (i=0;i<n;i++) {
texcoord[i][1] = DOT4( obj[i], ctx->Texture.ObjectPlaneT );
}
break;
case GL_EYE_LINEAR:
for (i=0;i<n;i++) {
texcoord[i][1] = DOT4( eye[i], ctx->Texture.EyePlaneT );
}
break;
case GL_SPHERE_MAP:
for (i=0;i<n;i++) {
float u[3], two_nu, m, fx, fy, fz;
COPY_3V( u, eye[i] );
NORMALIZE_3FV( u );
two_nu = 2.0*DOT3(normal[i],u);
fx = u[0] - normal[i][0] * two_nu;
fy = u[1] - normal[i][1] * two_nu;
fz = u[2] - normal[i][2] * two_nu;
m = 2.0F * GL_SQRT( fx*fx + fy*fy + (fz+1.0)*(fz+1.0) );
if (m==0.0F) {
texcoord[i][1] = 0.5F;
}
else {
texcoord[i][1] = fy / m + 0.5F;
}
}
break;
default:
gl_problem(ctx, "Bad T texgen");
return;
}
}
if (ctx->Texture.TexGenEnabled & R_BIT) {
GLint i;
switch (ctx->Texture.GenModeR) {
case GL_OBJECT_LINEAR:
for (i=0;i<n;i++) {
texcoord[i][2] = DOT4( obj[i], ctx->Texture.ObjectPlaneR );
}
break;
case GL_EYE_LINEAR:
for (i=0;i<n;i++) {
texcoord[i][2] = DOT4( eye[i], ctx->Texture.EyePlaneR );
}
break;
default:
gl_problem(ctx, "Bad R texgen");
return;
}
}
if (ctx->Texture.TexGenEnabled & Q_BIT) {
GLint i;
switch (ctx->Texture.GenModeQ) {
case GL_OBJECT_LINEAR:
for (i=0;i<n;i++) {
texcoord[i][3] = DOT4( obj[i], ctx->Texture.ObjectPlaneQ );
}
break;
case GL_EYE_LINEAR:
for (i=0;i<n;i++) {
texcoord[i][3] = DOT4( eye[i], ctx->Texture.EyePlaneQ );
}
break;
default:
gl_problem(ctx, "Bad Q texgen");
return;
}
}
}
static void palette_sample(const struct gl_texture_object *tObj,
GLubyte index, GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha)
{
GLcontext *ctx = gl_get_current_context();
GLint i = index;
const GLubyte *palette;
if (ctx->Texture.SharedPalette) {
palette = ctx->Texture.Palette;
}
else {
palette = tObj->Palette;
}
switch (tObj->PaletteFormat) {
case GL_ALPHA:
*alpha = tObj->Palette[index];
return;
case GL_LUMINANCE:
case GL_INTENSITY:
*red = palette[index];
return;
case GL_LUMINANCE_ALPHA:
*red   = palette[(index << 1) + 0];
*alpha = palette[(index << 1) + 1];
return;
case GL_RGB:
*red   = palette[index * 3 + 0];
*green = palette[index * 3 + 1];
*blue  = palette[index * 3 + 2];
return;
case GL_RGBA:
*red   = palette[(i << 2) + 0];
*green = palette[(i << 2) + 1];
*blue  = palette[(i << 2) + 2];
*alpha = palette[(i << 2) + 3];
return;
default:
gl_problem(NULL, "Bad palette format in palette_sample");
}
}
#define frac(x) ((float)(x)-floor((float)x))
static void get_1d_texel( const struct gl_texture_object *tObj,
const struct gl_texture_image *img, GLint i,
GLubyte *red, GLubyte *green, GLubyte *blue,
GLubyte *alpha )
{
GLubyte *texel;
#ifdef DEBUG
GLint width = img->Width;
if (i<0 || i>=width)  abort();
#endif
switch (img->Format) {
case GL_COLOR_INDEX:
{
GLubyte index = img->Data[i];
palette_sample(tObj, index, red, green, blue, alpha);
return;
}
return;
case GL_ALPHA:
*alpha = img->Data[ i ];
return;
case GL_LUMINANCE:
case GL_INTENSITY:
*red   = img->Data[ i ];
return;
case GL_LUMINANCE_ALPHA:
texel = img->Data + i * 2;
*red   = texel[0];
*alpha = texel[1];
return;
case GL_RGB:
texel = img->Data + i * 3;
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
return;
case GL_RGBA:
texel = img->Data + i * 4;
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
*alpha = texel[3];
return;
default:
gl_problem(NULL, "Bad format in get_1d_texel");
return;
}
}
static void sample_1d_nearest( const struct gl_texture_object *tObj,
const struct gl_texture_image *img,
float s,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint width = img->Width2;
GLint i;
GLubyte *texel;
if (tObj->WrapS==GL_REPEAT) {
i = (GLint) (s * width);
if (s<0.0F)  i -= 1;
i &= (width-1);
}
else {
if (s<0.0F)        i = 0;
else if (s>1.0F)   i = width-1;
else               i = (GLint) (s * width);
}
i += img->Border;
switch (img->Format) {
case GL_COLOR_INDEX:
{
GLubyte index = img->Data[i];
palette_sample(tObj, index, red, green, blue, alpha);
return;
}
case GL_ALPHA:
*alpha = img->Data[i];
return;
case GL_LUMINANCE:
case GL_INTENSITY:
*red   = img->Data[i];
return;
case GL_LUMINANCE_ALPHA:
texel = img->Data + i * 2;
*red   = texel[0];
*alpha = texel[1];
return;
case GL_RGB:
texel = img->Data + i * 3;
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
return;
case GL_RGBA:
texel = img->Data + i * 4;
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
*alpha = texel[3];
return;
default:
gl_problem(NULL, "Bad format in sample_1d_nearest");
}
}
static void sample_1d_linear( const struct gl_texture_object *tObj,
const struct gl_texture_image *img,
float s,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint width = img->Width2;
GLint i0, i1;
float u;
GLint i0border, i1border;
u = s * width;
if (tObj->WrapS==GL_REPEAT) {
i0 = ((GLint) floor(u - 0.5F)) % width;
i1 = (i0 + 1) & (width-1);
i0border = i1border = 0;
}
else {
i0 = (GLint) floor(u - 0.5F);
i1 = i0 + 1;
i0border = (i0<0) | (i0>=width);
i1border = (i1<0) | (i1>=width);
}
if (img->Border) {
i0 += img->Border;
i1 += img->Border;
i0border = i1border = 0;
}
else {
i0 &= (width-1);
}
{
float a = frac(u - 0.5F);
GLint w0 = (GLint) ((1.0F-a) * 256.0F);
GLint w1 = (GLint) (      a  * 256.0F);
GLubyte red0, green0, blue0, alpha0;
GLubyte red1, green1, blue1, alpha1;
if (i0border) {
red0   = tObj->BorderColor[0];
green0 = tObj->BorderColor[1];
blue0  = tObj->BorderColor[2];
alpha0 = tObj->BorderColor[3];
}
else {
get_1d_texel( tObj, img, i0, &red0, &green0, &blue0, &alpha0 );
}
if (i1border) {
red1   = tObj->BorderColor[0];
green1 = tObj->BorderColor[1];
blue1  = tObj->BorderColor[2];
alpha1 = tObj->BorderColor[3];
}
else {
get_1d_texel( tObj, img, i1, &red1, &green1, &blue1, &alpha1 );
}
*red   = (w0*red0   + w1*red1)   >> 8;
*green = (w0*green0 + w1*green1) >> 8;
*blue  = (w0*blue0  + w1*blue1)  >> 8;
*alpha = (w0*alpha0 + w1*alpha1) >> 8;
}
}
static void
sample_1d_nearest_mipmap_nearest( const struct gl_texture_object *tObj,
float s, float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint level;
if (lambda<=0.5F) {
level = 0;
}
else {
GLint widthlog2 = tObj->Image[0]->WidthLog2;
level = (GLint) (lambda + 0.499999F);
if (level>widthlog2 ) {
level = widthlog2;
}
}
sample_1d_nearest( tObj, tObj->Image[level],
s, red, green, blue, alpha );
}
static void
sample_1d_linear_mipmap_nearest( const struct gl_texture_object *tObj,
float s, float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint level;
if (lambda<=0.5F) {
level = 0;
}
else {
GLint widthlog2 = tObj->Image[0]->WidthLog2;
level = (GLint) (lambda + 0.499999F);
if (level>widthlog2 ) {
level = widthlog2;
}
}
sample_1d_linear( tObj, tObj->Image[level],
s, red, green, blue, alpha );
}
static void
sample_1d_nearest_mipmap_linear( const struct gl_texture_object *tObj,
float s, float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint max = tObj->Image[0]->MaxLog2;
if (lambda>=max) {
sample_1d_nearest( tObj, tObj->Image[max],
s, red, green, blue, alpha );
}
else {
GLubyte red0, green0, blue0, alpha0;
GLubyte red1, green1, blue1, alpha1;
float f = frac(lambda);
GLint level = (GLint) (lambda + 1.0F);
level = CLAMP( level, 1, max );
sample_1d_nearest( tObj, tObj->Image[level-1],
s, &red0, &green0, &blue0, &alpha0 );
sample_1d_nearest( tObj, tObj->Image[level],
s, &red1, &green1, &blue1, &alpha1 );
*red   = (1.0F-f)*red0   + f*red1;
*green = (1.0F-f)*green0 + f*green1;
*blue  = (1.0F-f)*blue0  + f*blue1;
*alpha = (1.0F-f)*alpha0 + f*alpha1;
}
}
static void
sample_1d_linear_mipmap_linear( const struct gl_texture_object *tObj,
float s, float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint max = tObj->Image[0]->MaxLog2;
if (lambda>=max) {
sample_1d_linear( tObj, tObj->Image[max],
s, red, green, blue, alpha );
}
else {
GLubyte red0, green0, blue0, alpha0;
GLubyte red1, green1, blue1, alpha1;
float f = frac(lambda);
GLint level = (GLint) (lambda + 1.0F);
level = CLAMP( level, 1, max );
sample_1d_linear( tObj, tObj->Image[level-1],
s, &red0, &green0, &blue0, &alpha0 );
sample_1d_linear( tObj, tObj->Image[level],
s, &red1, &green1, &blue1, &alpha1 );
*red   = (1.0F-f)*red0   + f*red1;
*green = (1.0F-f)*green0 + f*green1;
*blue  = (1.0F-f)*blue0  + f*blue1;
*alpha = (1.0F-f)*alpha0 + f*alpha1;
}
}
static void sample_nearest_1d( const struct gl_texture_object *tObj, GLuint n,
const float s[], const float t[],
const float u[], const float lambda[],
GLubyte red[], GLubyte green[], GLubyte blue[],
GLubyte alpha[] )
{
GLuint i;
for (i=0;i<n;i++) {
sample_1d_nearest( tObj, tObj->Image[0], s[i],
&red[i], &green[i], &blue[i], &alpha[i]);
}
}
static void sample_linear_1d( const struct gl_texture_object *tObj, GLuint n,
const float s[], const float t[],
const float u[], const float lambda[],
GLubyte red[], GLubyte green[], GLubyte blue[],
GLubyte alpha[] )
{
GLuint i;
for (i=0;i<n;i++) {
sample_1d_linear( tObj, tObj->Image[0], s[i],
&red[i], &green[i], &blue[i], &alpha[i]);
}
}
static void sample_lambda_1d( const struct gl_texture_object *tObj, GLuint n,
const float s[], const float t[],
const float u[], const float lambda[],
GLubyte red[], GLubyte green[], GLubyte blue[],
GLubyte alpha[] )
{
GLuint i;
for (i=0;i<n;i++) {
if (lambda[i] > tObj->MinMagThresh) {
switch (tObj->MinFilter) {
case GL_NEAREST:
sample_1d_nearest( tObj, tObj->Image[0], s[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR:
sample_1d_linear( tObj, tObj->Image[0], s[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_NEAREST_MIPMAP_NEAREST:
sample_1d_nearest_mipmap_nearest( tObj, lambda[i], s[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR_MIPMAP_NEAREST:
sample_1d_linear_mipmap_nearest( tObj, s[i], lambda[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_NEAREST_MIPMAP_LINEAR:
sample_1d_nearest_mipmap_linear( tObj, s[i], lambda[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR_MIPMAP_LINEAR:
sample_1d_linear_mipmap_linear( tObj, s[i], lambda[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
default:
gl_problem(NULL, "Bad min filter in sample_1d_texture");
return;
}
}
else {
switch (tObj->MagFilter) {
case GL_NEAREST:
sample_1d_nearest( tObj, tObj->Image[0], s[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR:
sample_1d_linear( tObj, tObj->Image[0], s[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
default:
gl_problem(NULL, "Bad mag filter in sample_1d_texture");
return;
}
}
}
}
static void get_2d_texel( const struct gl_texture_object *tObj,
const struct gl_texture_image *img, GLint i, GLint j,
GLubyte *red, GLubyte *green, GLubyte *blue,
GLubyte *alpha )
{
GLint width = img->Width;
GLubyte *texel;
#ifdef DEBUG
GLint height = img->Height;
if (i<0 || i>=width)  abort();
if (j<0 || j>=height)  abort();
#endif
switch (img->Format) {
case GL_COLOR_INDEX:
{
GLubyte index = img->Data[ width *j + i ];
palette_sample(tObj, index, red, green, blue, alpha);
return;
}
case GL_ALPHA:
*alpha = img->Data[ width * j + i ];
return;
case GL_LUMINANCE:
case GL_INTENSITY:
*red   = img->Data[ width * j + i ];
return;
case GL_LUMINANCE_ALPHA:
texel = img->Data + (width * j + i) * 2;
*red   = texel[0];
*alpha = texel[1];
return;
case GL_RGB:
texel = img->Data + (width * j + i) * 3;
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
return;
case GL_RGBA:
texel = img->Data + (width * j + i) * 4;
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
*alpha = texel[3];
return;
default:
gl_problem(NULL, "Bad format in get_2d_texel");
}
}
static void sample_2d_nearest( const struct gl_texture_object *tObj,
const struct gl_texture_image *img,
float s, float t,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint imgWidth = img->Width;
GLint width = img->Width2;
GLint height = img->Height2;
GLint i, j;
GLubyte *texel;
if (tObj->WrapS==GL_REPEAT) {
i = (GLint) (s * width);
if (s<0.0F)  i -= 1;
i &= (width-1);
}
else {
if (s<=0.0F)      i = 0;
else if (s>1.0F)  i = width-1;
else              i = (GLint) (s * width);
}
if (tObj->WrapT==GL_REPEAT) {
j = (GLint) (t * height);
if (t<0.0F)  j -= 1;
j &= (height-1);
}
else {
if (t<=0.0F)      j = 0;
else if (t>1.0F)  j = height-1;
else              j = (GLint) (t * height);
}
i += img->Border;
j += img->Border;
switch (img->Format) {
case GL_COLOR_INDEX:
{
GLubyte index = img->Data[ j * imgWidth + i ];
palette_sample(tObj, index, red, green, blue, alpha);
return;
}
case GL_ALPHA:
*alpha = img->Data[ j * imgWidth + i ];
return;
case GL_LUMINANCE:
case GL_INTENSITY:
*red   = img->Data[ j * imgWidth + i ];
return;
case GL_LUMINANCE_ALPHA:
texel = img->Data + ((j * imgWidth + i) << 1);
*red   = texel[0];
*alpha = texel[1];
return;
case GL_RGB:
texel = img->Data + (j * imgWidth + i) * 3;
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
return;
case GL_RGBA:
texel = img->Data + ((j * imgWidth + i) << 2);
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
*alpha = texel[3];
return;
default:
gl_problem(NULL, "Bad format in sample_2d_nearest");
}
}
static void sample_2d_linear( const struct gl_texture_object *tObj,
const struct gl_texture_image *img,
float s, float t,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint width = img->Width2;
GLint height = img->Height2;
GLint i0, j0, i1, j1;
GLint i0border, j0border, i1border, j1border;
float u, v;
u = s * width;
if (tObj->WrapS==GL_REPEAT) {
i0 = ((GLint) floor(u - 0.5F)) % width;
i1 = (i0 + 1) & (width-1);
i0border = i1border = 0;
}
else {
i0 = (GLint) floor(u - 0.5F);
i1 = i0 + 1;
i0border = (i0<0) | (i0>=width);
i1border = (i1<0) | (i1>=width);
}
v = t * height;
if (tObj->WrapT==GL_REPEAT) {
j0 = ((GLint) floor(v - 0.5F)) % height;
j1 = (j0 + 1) & (height-1);
j0border = j1border = 0;
}
else {
j0 = (GLint) floor(v - 0.5F );
j1 = j0 + 1;
j0border = (j0<0) | (j0>=height);
j1border = (j1<0) | (j1>=height);
}
if (img->Border) {
i0 += img->Border;
i1 += img->Border;
j0 += img->Border;
j1 += img->Border;
i0border = i1border = 0;
j0border = j1border = 0;
}
else {
i0 &= (width-1);
j0 &= (height-1);
}
{
float a = frac(u - 0.5F);
float b = frac(v - 0.5F);
GLint w00 = (GLint) ((1.0F-a)*(1.0F-b) * 256.0F);
GLint w10 = (GLint) (      a *(1.0F-b) * 256.0F);
GLint w01 = (GLint) ((1.0F-a)*      b  * 256.0F);
GLint w11 = (GLint) (      a *      b  * 256.0F);
GLubyte red00, green00, blue00, alpha00;
GLubyte red10, green10, blue10, alpha10;
GLubyte red01, green01, blue01, alpha01;
GLubyte red11, green11, blue11, alpha11;
if (i0border | j0border) {
red00   = tObj->BorderColor[0];
green00 = tObj->BorderColor[1];
blue00  = tObj->BorderColor[2];
alpha00 = tObj->BorderColor[3];
}
else {
get_2d_texel( tObj, img, i0, j0, &red00, &green00, &blue00, &alpha00);
}
if (i1border | j0border) {
red10   = tObj->BorderColor[0];
green10 = tObj->BorderColor[1];
blue10  = tObj->BorderColor[2];
alpha10 = tObj->BorderColor[3];
}
else {
get_2d_texel( tObj, img, i1, j0, &red10, &green10, &blue10, &alpha10);
}
if (i0border | j1border) {
red01   = tObj->BorderColor[0];
green01 = tObj->BorderColor[1];
blue01  = tObj->BorderColor[2];
alpha01 = tObj->BorderColor[3];
}
else {
get_2d_texel( tObj, img, i0, j1, &red01, &green01, &blue01, &alpha01);
}
if (i1border | j1border) {
red11   = tObj->BorderColor[0];
green11 = tObj->BorderColor[1];
blue11  = tObj->BorderColor[2];
alpha11 = tObj->BorderColor[3];
}
else {
get_2d_texel( tObj, img, i1, j1, &red11, &green11, &blue11, &alpha11);
}
*red   = (w00*red00   + w10*red10   + w01*red01   + w11*red11  ) >> 8;
*green = (w00*green00 + w10*green10 + w01*green01 + w11*green11) >> 8;
*blue  = (w00*blue00  + w10*blue10  + w01*blue01  + w11*blue11 ) >> 8;
*alpha = (w00*alpha00 + w10*alpha10 + w01*alpha01 + w11*alpha11) >> 8;
}
}
static void
sample_2d_nearest_mipmap_nearest( const struct gl_texture_object *tObj,
float s, float t, float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint level;
if (lambda<=0.5F) {
level = 0;
}
else {
GLint max = tObj->Image[0]->MaxLog2;
level = (GLint) (lambda + 0.499999F);
if (level>max) {
level = max;
}
}
sample_2d_nearest( tObj, tObj->Image[level],
s, t, red, green, blue, alpha );
}
static void
sample_2d_linear_mipmap_nearest( const struct gl_texture_object *tObj,
float s, float t, float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint level;
if (lambda<=0.5F) {
level = 0;
}
else {
GLint max = tObj->Image[0]->MaxLog2;
level = (GLint) (lambda + 0.499999F);
if (level>max) {
level = max;
}
}
sample_2d_linear( tObj, tObj->Image[level],
s, t, red, green, blue, alpha );
}
static void
sample_2d_nearest_mipmap_linear( const struct gl_texture_object *tObj,
float s, float t, float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint max = tObj->Image[0]->MaxLog2;
if (lambda>=max) {
sample_2d_nearest( tObj, tObj->Image[max],
s, t, red, green, blue, alpha );
}
else {
GLubyte red0, green0, blue0, alpha0;
GLubyte red1, green1, blue1, alpha1;
float f = frac(lambda);
GLint level = (GLint) (lambda + 1.0F);
level = CLAMP( level, 1, max );
sample_2d_nearest( tObj, tObj->Image[level-1], s, t,
&red0, &green0, &blue0, &alpha0 );
sample_2d_nearest( tObj, tObj->Image[level], s, t,
&red1, &green1, &blue1, &alpha1 );
*red   = (1.0F-f)*red0   + f*red1;
*green = (1.0F-f)*green0 + f*green1;
*blue  = (1.0F-f)*blue0  + f*blue1;
*alpha = (1.0F-f)*alpha0 + f*alpha1;
}
}
static void
sample_2d_linear_mipmap_linear( const struct gl_texture_object *tObj,
float s, float t, float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint max = tObj->Image[0]->MaxLog2;
if (lambda>=max) {
sample_2d_linear( tObj, tObj->Image[max],
s, t, red, green, blue, alpha );
}
else {
GLubyte red0, green0, blue0, alpha0;
GLubyte red1, green1, blue1, alpha1;
float f = frac(lambda);
GLint level = (GLint) (lambda + 1.0F);
level = CLAMP( level, 1, max );
sample_2d_linear( tObj, tObj->Image[level-1], s, t,
&red0, &green0, &blue0, &alpha0 );
sample_2d_linear( tObj, tObj->Image[level], s, t,
&red1, &green1, &blue1, &alpha1 );
*red   = (1.0F-f)*red0   + f*red1;
*green = (1.0F-f)*green0 + f*green1;
*blue  = (1.0F-f)*blue0  + f*blue1;
*alpha = (1.0F-f)*alpha0 + f*alpha1;
}
}
static void sample_nearest_2d( const struct gl_texture_object *tObj, GLuint n,
const float s[], const float t[],
const float u[], const float lambda[],
GLubyte red[], GLubyte green[], GLubyte blue[],
GLubyte alpha[] )
{
GLuint i;
for (i=0;i<n;i++) {
sample_2d_nearest( tObj, tObj->Image[0], s[i], t[i],
&red[i], &green[i], &blue[i], &alpha[i]);
}
}
static void sample_linear_2d( const struct gl_texture_object *tObj, GLuint n,
const float s[], const float t[],
const float u[], const float lambda[],
GLubyte red[], GLubyte green[], GLubyte blue[],
GLubyte alpha[] )
{
GLuint i;
for (i=0;i<n;i++) {
sample_2d_linear( tObj, tObj->Image[0], s[i], t[i],
&red[i], &green[i], &blue[i], &alpha[i]);
}
}
static void sample_lambda_2d( const struct gl_texture_object *tObj,
GLuint n,
const float s[], const float t[],
const float u[], const float lambda[],
GLubyte red[], GLubyte green[], GLubyte blue[],
GLubyte alpha[] )
{
GLuint i;
for (i=0;i<n;i++) {
if (lambda[i] > tObj->MinMagThresh) {
switch (tObj->MinFilter) {
case GL_NEAREST:
sample_2d_nearest( tObj, tObj->Image[0], s[i], t[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR:
sample_2d_linear( tObj, tObj->Image[0], s[i], t[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_NEAREST_MIPMAP_NEAREST:
sample_2d_nearest_mipmap_nearest( tObj, s[i], t[i], lambda[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR_MIPMAP_NEAREST:
sample_2d_linear_mipmap_nearest( tObj, s[i], t[i], lambda[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_NEAREST_MIPMAP_LINEAR:
sample_2d_nearest_mipmap_linear( tObj, s[i], t[i], lambda[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR_MIPMAP_LINEAR:
sample_2d_linear_mipmap_linear( tObj, s[i], t[i], lambda[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
default:
gl_problem(NULL, "Bad min filter in sample_2d_texture");
return;
}
}
else {
switch (tObj->MagFilter) {
case GL_NEAREST:
sample_2d_nearest( tObj, tObj->Image[0], s[i], t[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR:
sample_2d_linear( tObj, tObj->Image[0], s[i], t[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
default:
gl_problem(NULL, "Bad mag filter in sample_2d_texture");
}
}
}
}
static void opt_sample_rgb_2d( const struct gl_texture_object *tObj,
GLuint n, const float s[], const float t[],
const float u[], const float lamda[],
GLubyte red[], GLubyte green[],
GLubyte blue[], GLubyte alpha[] )
{
const struct gl_texture_image *img = tObj->Image[0];
float width = img->Width, height = img->Height;
GLint colMask = img->Width-1, rowMask = img->Height-1;
GLint shift = img->WidthLog2;
GLuint k;
ASSERT(tObj->WrapS==GL_REPEAT);
ASSERT(tObj->WrapT==GL_REPEAT);
ASSERT(img->Border==0);
ASSERT(img->Format==GL_RGB);
for (k=0;k<n;k++) {
GLint i = (GLint) (s[k] * width) & colMask;
GLint j = (GLint) (t[k] * height) & rowMask;
GLint pos = (j << shift) | i;
GLubyte *texel = img->Data + pos + pos + pos;
red[k]   = texel[0];
green[k] = texel[1];
blue[k]  = texel[2];
}
}
static void opt_sample_rgba_2d( const struct gl_texture_object *tObj,
GLuint n, const float s[], const float t[],
const float u[], const float lamda[],
GLubyte red[], GLubyte green[],
GLubyte blue[], GLubyte alpha[] )
{
const struct gl_texture_image *img = tObj->Image[0];
float width = img->Width, height = img->Height;
GLint colMask = img->Width-1, rowMask = img->Height-1;
GLint shift = img->WidthLog2;
GLuint k;
ASSERT(tObj->WrapS==GL_REPEAT);
ASSERT(tObj->WrapT==GL_REPEAT);
ASSERT(img->Border==0);
ASSERT(img->Format==GL_RGBA);
for (k=0;k<n;k++) {
GLint i = (GLint) (s[k] * width) & colMask;
GLint j = (GLint) (t[k] * height) & rowMask;
GLint pos = (j << shift) | i;
GLubyte *texel = img->Data + (pos << 2);
red[k]   = texel[0];
green[k] = texel[1];
blue[k]  = texel[2];
alpha[k] = texel[3];
}
}
static void get_3d_texel( const struct gl_texture_object *tObj,
const struct gl_texture_image *img,
GLint i, GLint j, GLint k,
GLubyte *red, GLubyte *green, GLubyte *blue,
GLubyte *alpha )
{
GLint width = img->Width;
GLint height = img->Height;
GLint depth = img->Depth;
GLint rectarea;
GLubyte *texel;
rectarea = width*height;
#ifdef DEBUG
if (i<0 || i>=width)  abort();
if (j<0 || j>=height)  abort();
if (k<0 || k>=depth)  abort();
#endif
switch (img->Format) {
case GL_COLOR_INDEX:
{
GLubyte index = img->Data[ rectarea * k +  width * j + i ];
palette_sample(tObj, index, red, green, blue, alpha);
return;
}
case GL_ALPHA:
*alpha = img->Data[ rectarea * k +  width * j + i ];
return;
case GL_LUMINANCE:
case GL_INTENSITY:
*red   = img->Data[ rectarea * k +  width * j + i ];
return;
case GL_LUMINANCE_ALPHA:
texel = img->Data + ( rectarea * k + width * j + i) * 2;
*red   = texel[0];
*alpha = texel[1];
return;
case GL_RGB:
texel = img->Data + (rectarea * k + width * j + i) * 3;
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
return;
case GL_RGBA:
texel = img->Data + (rectarea * k + width * j + i) * 4;
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
*alpha = texel[3];
return;
default:
gl_problem(NULL, "Bad format in get_3d_texel");
}
}
static void sample_3d_nearest( const struct gl_texture_object *tObj,
const struct gl_texture_image *img,
float s, float t, float r,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint imgWidth = img->Width;
GLint imgHeight = img->Height;
GLint width = img->Width2;
GLint height = img->Height2;
GLint depth = img->Depth2;
GLint rectarea;
GLint i, j, k;
GLubyte *texel;
rectarea = imgWidth * imgHeight;
if (tObj->WrapS==GL_REPEAT) {
i = (GLint) (s * width);
if (s<0.0F)  i -= 1;
i &= (width-1);
}
else {
if (s<0.0F)       i = 0;
else if (s>1.0F)  i = width-1;
else              i = (GLint) (s * width);
}
if (tObj->WrapT==GL_REPEAT) {
j = (GLint) (t * height);
if (t<0.0F)  j -= 1;
j &= (height-1);
}
else {
if (t<0.0F)       j = 0;
else if (t>1.0F)  j = height-1;
else              j = (GLint) (t * height);
}
if (tObj->WrapR==GL_REPEAT) {
k = (GLint) (r * depth);
if (r<0.0F)  k -= 1;
k &= (depth-1);
}
else {
if (r<0.0F)       k = 0;
else if (r>1.0F)  k = depth-1;
else              k = (GLint) (r * depth);
}
switch (tObj->Image[0]->Format) {
case GL_COLOR_INDEX:
{
GLubyte index = img->Data[ rectarea * k + j * imgWidth + i ];
palette_sample(tObj, index, red, green, blue, alpha);
return;
}
case GL_ALPHA:
*alpha = img->Data[ rectarea * k + j * imgWidth + i ];
return;
case GL_LUMINANCE:
case GL_INTENSITY:
*red   = img->Data[ rectarea * k + j * imgWidth + i ];
return;
case GL_LUMINANCE_ALPHA:
texel  = img->Data + ((rectarea * k + j * imgWidth + i) << 1);
*red   = texel[0];
*alpha = texel[1];
return;
case GL_RGB:
texel = img->Data + ( rectarea * k + j * imgWidth + i) * 3;
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
return;
case GL_RGBA:
texel = img->Data + ((rectarea * k + j * imgWidth + i) << 2);
*red   = texel[0];
*green = texel[1];
*blue  = texel[2];
*alpha = texel[3];
return;
default:
gl_problem(NULL, "Bad format in sample_3d_nearest");
}
}
static void sample_3d_linear( const struct gl_texture_object *tObj,
const struct gl_texture_image *img,
float s, float t, float r,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint width = img->Width2;
GLint height = img->Height2;
GLint depth = img->Depth2;
GLint i0, j0, k0, i1, j1, k1;
GLint i0border, j0border, k0border, i1border, j1border, k1border;
float u, v, w;
u = s * width;
if (tObj->WrapS==GL_REPEAT) {
i0 = ((GLint) floor(u - 0.5F)) % width;
i1 = (i0 + 1) & (width-1);
i0border = i1border = 0;
}
else {
i0 = (GLint) floor(u - 0.5F);
i1 = i0 + 1;
i0border = (i0<0) | (i0>=width);
i1border = (i1<0) | (i1>=width);
}
v = t * height;
if (tObj->WrapT==GL_REPEAT) {
j0 = ((GLint) floor(v - 0.5F)) % height;
j1 = (j0 + 1) & (height-1);
j0border = j1border = 0;
}
else {
j0 = (GLint) floor(v - 0.5F);
j1 = j0 + 1;
j0border = (j0<0) | (j0>=height);
j1border = (j1<0) | (j1>=height);
}
w = r * depth;
if (tObj->WrapR==GL_REPEAT) {
k0 = ((GLint) floor(w - 0.5F)) % depth;
k1 = (k0 + 1) & (depth-1);
k0border = k1border = 0;
}
else {
k0 = (GLint) floor(v - 0.5F);
k1 = k0 + 1;
k0border = (k0<0) | (k0>=depth);
k1border = (k1<0) | (k1>=depth);
}
if (img->Border) {
i0 += img->Border;
i1 += img->Border;
j0 += img->Border;
j1 += img->Border;
k0 += img->Border;
k1 += img->Border;
i0border = i1border = 0;
j0border = j1border = 0;
k0border = k1border = 0;
}
else {
i0 &= (width-1);
j0 &= (height-1);
k0 &= (depth-1);
}
{
float a = frac(u - 0.5F);
float b = frac(v - 0.5F);
float c = frac(w - 0.5F);
GLint w000 = (GLint) ((1.0F-a)*(1.0F-b) * (1.0F-c) * 256.0F);
GLint w010 = (GLint) (      a *(1.0F-b) * (1.0F-c) * 256.0F);
GLint w001 = (GLint) ((1.0F-a)*      b  * (1.0F-c) * 256.0F);
GLint w011 = (GLint) (      a *      b  * (1.0F-c) * 256.0F);
GLint w100 = (GLint) ((1.0F-a)*(1.0F-b) * c * 256.0F);
GLint w110 = (GLint) (      a *(1.0F-b) * c * 256.0F);
GLint w101 = (GLint) ((1.0F-a)*      b  * c * 256.0F);
GLint w111 = (GLint) (      a *      b  * c * 256.0F);
GLubyte red000, green000, blue000, alpha000;
GLubyte red010, green010, blue010, alpha010;
GLubyte red001, green001, blue001, alpha001;
GLubyte red011, green011, blue011, alpha011;
GLubyte red100, green100, blue100, alpha100;
GLubyte red110, green110, blue110, alpha110;
GLubyte red101, green101, blue101, alpha101;
GLubyte red111, green111, blue111, alpha111;
if (k0border | i0border | j0border ) {
red000   = tObj->BorderColor[0];
green000 = tObj->BorderColor[1];
blue000  = tObj->BorderColor[2];
alpha000 = tObj->BorderColor[3];
}
else {
get_3d_texel( tObj, img, i0, j0, k0, &red000, &green000, &blue000, &alpha000 );
}
if (k0border | i1border | j0border) {
red010   = tObj->BorderColor[0];
green010 = tObj->BorderColor[1];
blue010  = tObj->BorderColor[2];
alpha010 = tObj->BorderColor[3];
}
else {
get_3d_texel( tObj, img, i1, j0, k0, &red010, &green010, &blue010, &alpha010 );
}
if (k0border | i0border | j1border) {
red001   = tObj->BorderColor[0];
green001 = tObj->BorderColor[1];
blue001  = tObj->BorderColor[2];
alpha001 = tObj->BorderColor[3];
}
else {
get_3d_texel( tObj, img, i0, j1, k0, &red001, &green001, &blue001, &alpha001 );
}
if (k0border | i1border | j1border) {
red011   = tObj->BorderColor[0];
green011 = tObj->BorderColor[1];
blue011  = tObj->BorderColor[2];
alpha011 = tObj->BorderColor[3];
}
else {
get_3d_texel( tObj, img, i1, j1, k0, &red011, &green011, &blue011, &alpha011 );
}
if (k1border | i0border | j0border ) {
red100   = tObj->BorderColor[0];
green100 = tObj->BorderColor[1];
blue100  = tObj->BorderColor[2];
alpha100 = tObj->BorderColor[3];
}
else {
get_3d_texel( tObj, img, i0, j0, k1, &red100, &green100, &blue100, &alpha100 );
}
if (k1border | i1border | j0border) {
red110   = tObj->BorderColor[0];
green110 = tObj->BorderColor[1];
blue110  = tObj->BorderColor[2];
alpha110 = tObj->BorderColor[3];
}
else {
get_3d_texel( tObj, img, i1, j0, k1, &red110, &green110, &blue110, &alpha110 );
}
if (k1border | i0border | j1border) {
red101   = tObj->BorderColor[0];
green101 = tObj->BorderColor[1];
blue101  = tObj->BorderColor[2];
alpha101 = tObj->BorderColor[3];
}
else {
get_3d_texel( tObj, img, i0, j1, k1, &red101, &green101, &blue101, &alpha101 );
}
if (k1border | i1border | j1border) {
red111   = tObj->BorderColor[0];
green111 = tObj->BorderColor[1];
blue111  = tObj->BorderColor[2];
alpha111 = tObj->BorderColor[3];
}
else {
get_3d_texel( tObj, img, i1, j1, k1, &red111, &green111, &blue111, &alpha111 );
}
*red   = (w000*red000   + w010*red010   + w001*red001   + w011*red011 +
w100*red100   + w110*red110   + w101*red101   + w111*red111  )
>> 8;
*green = (w000*green000 + w010*green010 + w001*green001 + w011*green011 +
w100*green100 + w110*green110 + w101*green101 + w111*green111 )
>> 8;
*blue  = (w000*blue000  + w010*blue010  + w001*blue001  + w011*blue011 +
w100*blue100  + w110*blue110  + w101*blue101  + w111*blue111 )
>> 8;
*alpha = (w000*alpha000 + w010*alpha010 + w001*alpha001 + w011*alpha011 +
w100*alpha100 + w110*alpha110 + w101*alpha101 + w111*alpha111 )
>> 8;
}
}
static void
sample_3d_nearest_mipmap_nearest( const struct gl_texture_object *tObj,
float s, float t, float r,
float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint level;
if (lambda<=0.5F) {
level = 0;
}
else {
GLint widthlog2 = tObj->Image[0]->WidthLog2;
level = (GLint) (lambda + 0.499999F);
if (level>widthlog2 ) {
level = widthlog2;
}
}
sample_3d_nearest( tObj, tObj->Image[level],
s, t, r, red, green, blue, alpha );
}
static void
sample_3d_linear_mipmap_nearest( const struct gl_texture_object *tObj,
float s, float t, float r,
float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint level;
if (lambda<=0.5F) {
level = 0;
}
else {
GLint widthlog2 = tObj->Image[0]->WidthLog2;
level = (GLint) (lambda + 0.499999F);
if (level>widthlog2 ) {
level = widthlog2;
}
}
sample_3d_linear( tObj, tObj->Image[level],
s, t, r, red, green, blue, alpha );
}
static void
sample_3d_nearest_mipmap_linear( const struct gl_texture_object *tObj,
float s, float t, float r,
float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint max = tObj->Image[0]->MaxLog2;
if (lambda>=max) {
sample_3d_nearest( tObj, tObj->Image[max],
s, t, r, red, green, blue, alpha );
}
else {
GLubyte red0, green0, blue0, alpha0;
GLubyte red1, green1, blue1, alpha1;
float f = frac(lambda);
GLint level = (GLint) (lambda + 1.0F);
level = CLAMP( level, 1, max );
sample_3d_nearest( tObj, tObj->Image[level-1], s, t, r,
&red0, &green0, &blue0, &alpha0 );
sample_3d_nearest( tObj, tObj->Image[level], s, t, r,
&red1, &green1, &blue1, &alpha1 );
*red   = (1.0F-f)*red1   + f*red0;
*green = (1.0F-f)*green1 + f*green0;
*blue  = (1.0F-f)*blue1  + f*blue0;
*alpha = (1.0F-f)*alpha1 + f*alpha0;
}
}
static void
sample_3d_linear_mipmap_linear( const struct gl_texture_object *tObj,
float s, float t, float r,
float lambda,
GLubyte *red, GLubyte *green,
GLubyte *blue, GLubyte *alpha )
{
GLint max = tObj->Image[0]->MaxLog2;
if (lambda>=max) {
sample_3d_linear( tObj, tObj->Image[max],
s, t, r, red, green, blue, alpha );
}
else {
GLubyte red0, green0, blue0, alpha0;
GLubyte red1, green1, blue1, alpha1;
float f = frac(lambda);
GLint level = (GLint) (lambda + 1.0F);
level = CLAMP( level, 1, max );
sample_3d_linear( tObj, tObj->Image[level-1], s, t, r,
&red0, &green0, &blue0, &alpha0 );
sample_3d_linear( tObj, tObj->Image[level], s, t, r,
&red1, &green1, &blue1, &alpha1 );
*red   = (1.0F-f)*red1   + f*red0;
*green = (1.0F-f)*green1 + f*green0;
*blue  = (1.0F-f)*blue1  + f*blue0;
*alpha = (1.0F-f)*alpha1 + f*alpha0;
}
}
static void sample_nearest_3d( const struct gl_texture_object *tObj, GLuint n,
const float s[], const float t[],
const float u[], const float lambda[],
GLubyte red[], GLubyte green[], GLubyte blue[],
GLubyte alpha[] )
{
GLuint i;
for (i=0;i<n;i++) {
sample_3d_nearest( tObj, tObj->Image[0], s[i], t[i], u[i],
&red[i], &green[i], &blue[i], &alpha[i]);
}
}
static void sample_linear_3d( const struct gl_texture_object *tObj, GLuint n,
const float s[], const float t[],
const float u[], const float lambda[],
GLubyte red[], GLubyte green[], GLubyte blue[],
GLubyte alpha[] )
{
GLuint i;
for (i=0;i<n;i++) {
sample_3d_linear( tObj, tObj->Image[0], s[i], t[i], u[i],
&red[i], &green[i], &blue[i], &alpha[i]);
}
}
static void sample_lambda_3d( const struct gl_texture_object *tObj, GLuint n,
const float s[], const float t[],
const float u[], const float lambda[],
GLubyte red[], GLubyte green[],
GLubyte blue[], GLubyte alpha[] )
{
GLuint i;
for (i=0;i<n;i++) {
if (lambda[i] > tObj->MinMagThresh) {
switch (tObj->MinFilter) {
case GL_NEAREST:
sample_3d_nearest( tObj, tObj->Image[0], s[i], t[i], u[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR:
sample_3d_linear( tObj, tObj->Image[0], s[i], t[i], u[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_NEAREST_MIPMAP_NEAREST:
sample_3d_nearest_mipmap_nearest( tObj, s[i], t[i], u[i],
lambda[i], &red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR_MIPMAP_NEAREST:
sample_3d_linear_mipmap_nearest( tObj, s[i], t[i], u[i],
lambda[i], &red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_NEAREST_MIPMAP_LINEAR:
sample_3d_nearest_mipmap_linear( tObj, s[i], t[i], u[i],
lambda[i], &red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR_MIPMAP_LINEAR:
sample_3d_linear_mipmap_linear( tObj, s[i], t[i], u[i],
lambda[i], &red[i], &green[i], &blue[i], &alpha[i] );
break;
default:
gl_problem(NULL, "Bad min filterin sample_3d_texture");
}
}
else {
switch (tObj->MagFilter) {
case GL_NEAREST:
sample_3d_nearest( tObj, tObj->Image[0], s[i], t[i], u[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
case GL_LINEAR:
sample_3d_linear( tObj, tObj->Image[0], s[i], t[i], u[i],
&red[i], &green[i], &blue[i], &alpha[i] );
break;
default:
gl_problem(NULL, "Bad mag filterin sample_3d_texture");
}
}
}
}
void gl_set_texture_sampler( struct gl_texture_object *t )
{
if (!t->Complete) {
t->SampleFunc = NULL;
}
else {
GLboolean needLambda = (t->MinFilter != t->MagFilter);
if (needLambda) {
if (t->MagFilter==GL_LINEAR
&& (t->MinFilter==GL_NEAREST_MIPMAP_NEAREST ||
t->MinFilter==GL_LINEAR_MIPMAP_NEAREST)) {
t->MinMagThresh = 0.5F;
}
else {
t->MinMagThresh = 0.0F;
}
}
switch (t->Dimensions) {
case 1:
if (needLambda) {
t->SampleFunc = sample_lambda_1d;
}
else if (t->MinFilter==GL_LINEAR) {
t->SampleFunc = sample_linear_1d;
}
else {
ASSERT(t->MinFilter==GL_NEAREST);
t->SampleFunc = sample_nearest_1d;
}
break;
case 2:
if (needLambda) {
t->SampleFunc = sample_lambda_2d;
}
else if (t->MinFilter==GL_LINEAR) {
t->SampleFunc = sample_linear_2d;
}
else {
ASSERT(t->MinFilter==GL_NEAREST);
if (t->WrapS==GL_REPEAT && t->WrapT==GL_REPEAT
&& t->Image[0]->Border==0 && t->Image[0]->Format==GL_RGB) {
t->SampleFunc = opt_sample_rgb_2d;
}
else if (t->WrapS==GL_REPEAT && t->WrapT==GL_REPEAT
&& t->Image[0]->Border==0 && t->Image[0]->Format==GL_RGBA) {
t->SampleFunc = opt_sample_rgba_2d;
}
else
t->SampleFunc = sample_nearest_2d;
}
break;
case 3:
if (needLambda) {
t->SampleFunc = sample_lambda_3d;
}
else if (t->MinFilter==GL_LINEAR) {
t->SampleFunc = sample_linear_3d;
}
else {
ASSERT(t->MinFilter==GL_NEAREST);
t->SampleFunc = sample_nearest_3d;
}
break;
default:
gl_problem(NULL, "invalid dimensions in gl_set_texture_sampler");
}
}
}
static void apply_texture( GLcontext *ctx,
GLuint n, GLint format, GLenum env_mode,
	 GLubyte red[], GLubyte green[], GLubyte blue[], GLubyte alpha[],
	 GLubyte Rt[], GLubyte Gt[], GLubyte Bt[], GLubyte At[] )
{
GLuint i;
GLint Rc, Gc, Bc, Ac;
if (!ctx->Visual->EightBitColor) {
float rscale = 255.0 * ctx->Visual->InvRedScale;
float gscale = 255.0 * ctx->Visual->InvGreenScale;
float bscale = 255.0 * ctx->Visual->InvBlueScale;
float ascale = 255.0 * ctx->Visual->InvAlphaScale;
for (i=0;i<n;i++) {
	 red[i]   = (GLint) (red[i]   * rscale);
	 green[i] = (GLint) (green[i] * gscale);
	 blue[i]  = (GLint) (blue[i]  * bscale);
	 alpha[i] = (GLint) (alpha[i] * ascale);
}
}
#define PROD(A,B)   (((GLint)(A) * ((GLint)(B)+1)) >> 8)
if (format==GL_COLOR_INDEX) {
format = GL_RGBA;
}
switch (env_mode) {
case GL_REPLACE:
	 switch (format) {
	    case GL_ALPHA:
	       for (i=0;i<n;i++) {
		
alpha[i] = At[i];
	       }
	       break;
	    case GL_LUMINANCE:
	       for (i=0;i<n;i++) {
		
GLint Lt = Rt[i];
red[i] = green[i] = blue[i] = Lt;
	       }
	       break;
	    case GL_LUMINANCE_ALPHA:
	       for (i=0;i<n;i++) {
GLint Lt = Rt[i];
		
		  red[i] = green[i] = blue[i] = Lt;
		
		  alpha[i] = At[i];
	       }
	       break;
	    case GL_INTENSITY:
	       for (i=0;i<n;i++) {
		
GLint It = Rt[i];
red[i] = green[i] = blue[i] = It;
alpha[i] = It;
	       }
	       break;
	    case GL_RGB:
	       for (i=0;i<n;i++) {
		
		  red[i]   = Rt[i];
		  green[i] = Gt[i];
		  blue[i]  = Bt[i];
		
	       }
	       break;
	    case GL_RGBA:
	       for (i=0;i<n;i++) {
		
		  red[i]   = Rt[i];
		  green[i] = Gt[i];
		  blue[i]  = Bt[i];
		
		  alpha[i] = At[i];
	       }
	       break;
default:
gl_problem(ctx, "Bad format in apply_texture");
return;
	 }
	 break;
case GL_MODULATE:
switch (format) {
	    case GL_ALPHA:
	       for (i=0;i<n;i++) {
		
		
		  alpha[i] = PROD( alpha[i], At[i] );
	       }
	       break;
	    case GL_LUMINANCE:
	       for (i=0;i<n;i++) {
		
GLint Lt = Rt[i];
		  red[i]   = PROD( red[i],   Lt );
		  green[i] = PROD( green[i], Lt );
		  blue[i]  = PROD( blue[i],  Lt );
		
	       }
	       break;
	    case GL_LUMINANCE_ALPHA:
	       for (i=0;i<n;i++) {
		
GLint Lt = Rt[i];
		  red[i]   = PROD( red[i],   Lt );
		  green[i] = PROD( green[i], Lt );
		  blue[i]  = PROD( blue[i],  Lt );
		
		  alpha[i] = PROD( alpha[i], At[i] );
	       }
	       break;
	    case GL_INTENSITY:
	       for (i=0;i<n;i++) {
		
GLint It = Rt[i];
		  red[i]   = PROD( red[i],   It );
		  green[i] = PROD( green[i], It );
		  blue[i]  = PROD( blue[i],  It );
		
		  alpha[i] = PROD( alpha[i], It );
	       }
	       break;
	    case GL_RGB:
	       for (i=0;i<n;i++) {
		
		  red[i]   = PROD( red[i],   Rt[i] );
		  green[i] = PROD( green[i], Gt[i] );
		  blue[i]  = PROD( blue[i],  Bt[i] );
		
	       }
	       break;
	    case GL_RGBA:
	       for (i=0;i<n;i++) {
		
		  red[i]   = PROD( red[i],   Rt[i] );
		  green[i] = PROD( green[i], Gt[i] );
		  blue[i]  = PROD( blue[i],  Bt[i] );
		
		  alpha[i] = PROD( alpha[i], At[i] );
	       }
	       break;
default:
gl_problem(ctx, "Bad format (2) in apply_texture");
return;
	 }
	 break;
case GL_DECAL:
switch (format) {
case GL_ALPHA:
case GL_LUMINANCE:
case GL_LUMINANCE_ALPHA:
case GL_INTENSITY:
break;
	    case GL_RGB:
	       for (i=0;i<n;i++) {
		
		  red[i]   = Rt[i];
		  green[i] = Gt[i];
		  blue[i]  = Bt[i];
		
	       }
	       break;
	    case GL_RGBA:
	       for (i=0;i<n;i++) {
		
		  GLint t = At[i], s = 255 - t;
		  red[i]   = PROD(red[i],  s) + PROD(Rt[i],t);
		  green[i] = PROD(green[i],s) + PROD(Gt[i],t);
		  blue[i]  = PROD(blue[i], s) + PROD(Bt[i],t);
		
	       }
	       break;
default:
gl_problem(ctx, "Bad format (3) in apply_texture");
return;
	 }
	 break;
case GL_BLEND:
Rc = (GLint) (ctx->Texture.EnvColor[0] * 255.0F);
Gc = (GLint) (ctx->Texture.EnvColor[1] * 255.0F);
Bc = (GLint) (ctx->Texture.EnvColor[2] * 255.0F);
Ac = (GLint) (ctx->Texture.EnvColor[3] * 255.0F);
	 switch (format) {
	    case GL_ALPHA:
	       for (i=0;i<n;i++) {
		
		
alpha[i] = PROD(alpha[i], At[i]);
	       }
	       break;
case GL_LUMINANCE:
	       for (i=0;i<n;i++) {
		
		  GLint Lt = Rt[i], s = 255 - Lt;
		  red[i]   = PROD(red[i],  s) + PROD(Rc,  Lt);
		  green[i] = PROD(green[i],s) + PROD(Gc,Lt);
		  blue[i]  = PROD(blue[i], s) + PROD(Bc, Lt);
		
	       }
	       break;
	    case GL_LUMINANCE_ALPHA:
	       for (i=0;i<n;i++) {
		
		  GLint Lt = Rt[i], s = 255 - Lt;
		  red[i]   = PROD(red[i],  s) + PROD(Rc,  Lt);
		  green[i] = PROD(green[i],s) + PROD(Gc,Lt);
		  blue[i]  = PROD(blue[i], s) + PROD(Bc, Lt);
		
		  alpha[i] = PROD(alpha[i],At[i]);
	       }
	       break;
case GL_INTENSITY:
	       for (i=0;i<n;i++) {
		
		  GLint It = Rt[i], s = 255 - It;
		  red[i]   = PROD(red[i],  s) + PROD(Rc,It);
		  green[i] = PROD(green[i],s) + PROD(Gc,It);
		  blue[i]  = PROD(blue[i], s) + PROD(Bc,It);
alpha[i] = PROD(alpha[i],s) + PROD(Ac,It);
}
break;
	    case GL_RGB:
	       for (i=0;i<n;i++) {
		
		  red[i]   = PROD(red[i],  (255-Rt[i])) + PROD(Rc,Rt[i]);
		  green[i] = PROD(green[i],(255-Gt[i])) + PROD(Gc,Gt[i]);
		  blue[i]  = PROD(blue[i], (255-Bt[i])) + PROD(Bc,Bt[i]);
		
	       }
	       break;
	    case GL_RGBA:
	       for (i=0;i<n;i++) {
		
		  red[i]   = PROD(red[i],  (255-Rt[i])) + PROD(Rc,Rt[i]);
		  green[i] = PROD(green[i],(255-Gt[i])) + PROD(Gc,Gt[i]);
		  blue[i]  = PROD(blue[i], (255-Bt[i])) + PROD(Bc,Bt[i]);
		
		  alpha[i] = PROD(alpha[i],At[i]);
	       }
	       break;
	 }
	 break;
default:
gl_problem(ctx, "Bad env mode in apply_texture");
return;
}
#undef PROD
if (!ctx->Visual->EightBitColor) {
float rscale = ctx->Visual->RedScale   * (1.0F/ 255.0F);
float gscale = ctx->Visual->GreenScale * (1.0F/ 255.0F);
float bscale = ctx->Visual->BlueScale  * (1.0F/ 255.0F);
float ascale = ctx->Visual->AlphaScale * (1.0F/ 255.0F);
for (i=0;i<n;i++) {
	 red[i]   = (GLint) (red[i]   * rscale);
	 green[i] = (GLint) (green[i] * gscale);
	 blue[i]  = (GLint) (blue[i]  * bscale);
	 alpha[i] = (GLint) (alpha[i] * ascale);
}
}
}
void gl_texture_pixels( GLcontext *ctx, GLuint n,
const float s[], const float t[],
const float r[], const float lambda[],
GLubyte red[], GLubyte green[],
GLubyte blue[], GLubyte alpha[] )
{
GLubyte tred[PB_SIZE];
GLubyte tgreen[PB_SIZE];
GLubyte tblue[PB_SIZE];
GLubyte talpha[PB_SIZE];
if (!ctx->Texture.Current || !ctx->Texture.Current->SampleFunc)
return;
(*ctx->Texture.Current->SampleFunc)( ctx->Texture.Current, n,
s, t, r, lambda,
tred, tgreen, tblue, talpha );
apply_texture( ctx, n,
ctx->Texture.Current->Image[0]->Format,
ctx->Texture.EnvMode,
red, green, blue, alpha,
tred, tgreen, tblue, talpha );
}
/* 当前文件是D:\Read\triangle.c*/

#ifdef PC_HEADER
#else
#endif
static void feedback_triangle( GLcontext *ctx,
GLuint v0, GLuint v1, GLuint v2, GLuint pv )
{
struct vertex_buffer *VB = ctx->VB;
float color[4];
GLuint i;
float invRedScale   = ctx->Visual->InvRedScale;
float invGreenScale = ctx->Visual->InvGreenScale;
float invBlueScale  = ctx->Visual->InvBlueScale;
float invAlphaScale = ctx->Visual->InvAlphaScale;
FEEDBACK_TOKEN( ctx, (float) GL_POLYGON_TOKEN );
FEEDBACK_TOKEN( ctx, (float) 3 );
if (ctx->Light.ShadeModel==GL_FLAT) {
color[0] = (float) VB->Color[pv][0] * invRedScale;
color[1] = (float) VB->Color[pv][1] * invGreenScale;
color[2] = (float) VB->Color[pv][2] * invBlueScale;
color[3] = (float) VB->Color[pv][3] * invAlphaScale;
}
for (i=0;i<3;i++) {
float x, y, z, w;
float tc[4];
GLuint v;
float invq;
if (i==0)       v = v0;
else if (i==1)  v = v1;
else            v = v2;
x = VB->Win[v][0];
y = VB->Win[v][1];
z = VB->Win[v][2] / DEPTH_SCALE;
w = VB->Clip[v][3];
if (ctx->Light.ShadeModel==GL_SMOOTH) {
color[0] = VB->Color[v][0] * invRedScale;
color[1] = VB->Color[v][1] * invGreenScale;
color[2] = VB->Color[v][2] * invBlueScale;
color[3] = VB->Color[v][3] * invAlphaScale;
}
invq = (VB->TexCoord[v][3]==0.0) ? 1.0 : (1.0F / VB->TexCoord[v][3]);
tc[0] = VB->TexCoord[v][0] * invq;
tc[1] = VB->TexCoord[v][1] * invq;
tc[2] = VB->TexCoord[v][2] * invq;
tc[3] = VB->TexCoord[v][3];
gl_feedback_vertex( ctx, x, y, z, w, color, (float) VB->Index[v], tc );
}
}
static void select_triangle( GLcontext *ctx,
GLuint v0, GLuint v1, GLuint v2, GLuint pv )
{
struct vertex_buffer *VB = ctx->VB;
gl_update_hitflag( ctx, VB->Win[v0][2] / DEPTH_SCALE );
gl_update_hitflag( ctx, VB->Win[v1][2] / DEPTH_SCALE );
gl_update_hitflag( ctx, VB->Win[v2][2] / DEPTH_SCALE );
}
static void flat_ci_triangle( GLcontext *ctx,
GLuint v0, GLuint v1, GLuint v2, GLuint pv )
{
#define INTERP_Z 1
#define SETUP_CODE				\
GLuint index = VB->Index[pv];		\
if (!VB->MonoColor) {			\
			\
(*ctx->Driver.Index)( ctx, index );	\
}
#define INNER_LOOP( LEFT, RIGHT, Y )				\
	{							\
	   GLint i, n = RIGHT-LEFT;				\
	   GLdepth zspan[MAX_WIDTH];				\
	   if (n>0) {						\
	      for (i=0;i<n;i++) {				\
		 zspan[i] = FixedToDepth(ffz);			\
		 ffz += fdzdx;					\
	      }							\
	      gl_write_monoindex_span( ctx, n, LEFT, Y,		\
	                            zspan, index, GL_POLYGON );	\
	   }							\
	}
}
static void smooth_ci_triangle( GLcontext *ctx,
GLuint v0, GLuint v1, GLuint v2, GLuint pv )
{
#define INTERP_Z 1
#define INTERP_INDEX 1
#define INNER_LOOP( LEFT, RIGHT, Y )				\
	{							\
	   GLint i, n = RIGHT-LEFT;				\
	   GLdepth zspan[MAX_WIDTH];				\
GLuint index[MAX_WIDTH];				\
	   if (n>0) {						\
	      for (i=0;i<n;i++) {				\
		 zspan[i] = FixedToDepth(ffz);			\
index[i] = FixedToInt(ffi);			\
		 ffz += fdzdx;					\
		 ffi += fdidx;					\
	      }							\
	      gl_write_index_span( ctx, n, LEFT, Y, zspan,	\
	                           index, GL_POLYGON );		\
	   }							\
	}
}
static void flat_rgba_triangle( GLcontext *ctx,
GLuint v0, GLuint v1, GLuint v2, GLuint pv )
{
#define INTERP_Z 1
#define SETUP_CODE				\
if (!VB->MonoColor) {			\
			\
GLubyte r = VB->Color[pv][0];		\
GLubyte g = VB->Color[pv][1];		\
GLubyte b = VB->Color[pv][2];		\
GLubyte a = VB->Color[pv][3];		\
(*ctx->Driver.Color)( ctx, r, g, b, a );	\
}
#define INNER_LOOP( LEFT, RIGHT, Y )				\
	{							\
	   GLint i, n = RIGHT-LEFT;				\
	   GLdepth zspan[MAX_WIDTH];				\
	   if (n>0) {						\
	      for (i=0;i<n;i++) {				\
		 zspan[i] = FixedToDepth(ffz);			\
		 ffz += fdzdx;					\
	      }							\
gl_write_monocolor_span( ctx, n, LEFT, Y, zspan,	\
VB->Color[pv][0], VB->Color[pv][1],\
VB->Color[pv][2], VB->Color[pv][3],\
			     GL_POLYGON );			\
	   }							\
	}
}
static void smooth_rgba_triangle( GLcontext *ctx,
GLuint v0, GLuint v1, GLuint v2, GLuint pv )
{
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INNER_LOOP( LEFT, RIGHT, Y )				\
	{							\
	   GLint i, n = RIGHT-LEFT;				\
	   GLdepth zspan[MAX_WIDTH];				\
	   GLubyte red[MAX_WIDTH], green[MAX_WIDTH];		\
	   GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];		\
	   if (n>0) {						\
	      for (i=0;i<n;i++) {				\
		 zspan[i] = FixedToDepth(ffz);			\
		 red[i]   = FixedToInt(ffr);			\
		 green[i] = FixedToInt(ffg);			\
		 blue[i]  = FixedToInt(ffb);			\
		 alpha[i] = FixedToInt(ffa);			\
		 ffz += fdzdx;					\
		 ffr += fdrdx;					\
		 ffg += fdgdx;					\
		 ffb += fdbdx;					\
		 ffa += fdadx;					\
	      }							\
	      gl_write_color_span( ctx, n, LEFT, Y, zspan,	\
	                           red, green, blue, alpha,	\
				   GL_POLYGON );		\
	   }							\
	}
}
static void simple_textured_triangle( GLcontext *ctx, GLuint v0, GLuint v1,
GLuint v2, GLuint pv )
{
#define INTERP_ST 1
#define S_SCALE twidth
#define T_SCALE theight
#define SETUP_CODE							\
float twidth = (float) ctx->Texture.Current2D->Image[0]->Width;	\
float theight = (float) ctx->Texture.Current2D->Image[0]->Height;\
GLint twidth_log2 = ctx->Texture.Current2D->Image[0]->WidthLog2;	\
GLubyte *texture = ctx->Texture.Current2D->Image[0]->Data;		\
GLint smask = ctx->Texture.Current2D->Image[0]->Width - 1;		\
GLint tmask = ctx->Texture.Current2D->Image[0]->Height - 1;
#define INNER_LOOP( LEFT, RIGHT, Y )				\
	{							\
	   GLint i, n = RIGHT-LEFT;				\
	   GLubyte red[MAX_WIDTH], green[MAX_WIDTH];		\
	   GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];		\
	   if (n>0) {						\
	      for (i=0;i<n;i++) {				\
GLint s = FixedToInt(ffs) & smask;		\
GLint t = FixedToInt(fft) & tmask;		\
GLint pos = (t << twidth_log2) + s;		\
pos = pos + pos  + pos;  	\
red[i]   = texture[pos];			\
green[i] = texture[pos+1];			\
blue[i]  = texture[pos+2];			\
alpha[i] = 255;				\
		 ffs += fdsdx;					\
		 fft += fdtdx;					\
	      }							\
(*ctx->Driver.WriteColorSpan)( ctx, n, LEFT, Y,	\
red, green, blue, alpha, NULL );	\
	   }							\
	}
}
static void simple_z_textured_triangle( GLcontext *ctx, GLuint v0, GLuint v1,
GLuint v2, GLuint pv )
{
#define INTERP_Z 1
#define INTERP_ST 1
#define S_SCALE twidth
#define T_SCALE theight
#define SETUP_CODE							\
float twidth = (float) ctx->Texture.Current2D->Image[0]->Width;	\
float theight = (float) ctx->Texture.Current2D->Image[0]->Height;\
GLint twidth_log2 = ctx->Texture.Current2D->Image[0]->WidthLog2;	\
GLubyte *texture = ctx->Texture.Current2D->Image[0]->Data;		\
GLint smask = ctx->Texture.Current2D->Image[0]->Width - 1;		\
GLint tmask = ctx->Texture.Current2D->Image[0]->Height - 1;
#define INNER_LOOP( LEFT, RIGHT, Y )				\
	{							\
	   GLint i, n = RIGHT-LEFT;				\
	   GLubyte red[MAX_WIDTH], green[MAX_WIDTH];		\
	   GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];		\
GLubyte mask[MAX_WIDTH];				\
	   if (n>0) {						\
	      for (i=0;i<n;i++) {				\
GLdepth z = FixedToDepth(ffz);			\
if (z < zRow[i]) {				\
GLint s = FixedToInt(ffs) & smask;		\
GLint t = FixedToInt(fft) & tmask;		\
GLint pos = (t << twidth_log2) + s;		\
pos = pos + pos  + pos;  \
red[i]   = texture[pos];			\
green[i] = texture[pos+1];			\
blue[i]  = texture[pos+2];			\
alpha[i] = 255;				\
		    zRow[i] = z;				\
mask[i] = 1;				\
}						\
else {						\
mask[i] = 0;				\
}						\
		 ffz += fdzdx;					\
		 ffs += fdsdx;					\
		 fft += fdtdx;					\
	      }							\
(*ctx->Driver.WriteColorSpan)( ctx, n, LEFT, Y,	\
red, green, blue, alpha, mask );	\
	   }							\
	}
}
static void general_textured_triangle( GLcontext *ctx, GLuint v0, GLuint v1,
GLuint v2, GLuint pv )
{
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INTERP_STW 1
#define INTERP_UV 1
#define SETUP_CODE						\
GLboolean flat_shade = (ctx->Light.ShadeModel==GL_FLAT);	\
GLint r, g, b, a;						\
if (flat_shade) {						\
r = VB->Color[pv][0];					\
g = VB->Color[pv][1];					\
b = VB->Color[pv][2];					\
a = VB->Color[pv][3];					\
}
#define INNER_LOOP( LEFT, RIGHT, Y )				\
	{							\
	   GLint i, n = RIGHT-LEFT;				\
	   GLdepth zspan[MAX_WIDTH];				\
	   GLubyte red[MAX_WIDTH], green[MAX_WIDTH];		\
	   GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];		\
float s[MAX_WIDTH], t[MAX_WIDTH], u[MAX_WIDTH];	\
	   if (n>0) {						\
if (flat_shade) {					\
for (i=0;i<n;i++) {				\
		    GLdouble wwvvInv = 1.0 / (ww*vv);		\
		    zspan[i] = FixedToDepth(ffz);		\
		    red[i]   = r;				\
		    green[i] = g;				\
		    blue[i]  = b;				\
		    alpha[i] = a;				\
		    s[i] = ss*wwvvInv;				\
		    t[i] = tt*wwvvInv;				\
		    u[i] = uu*wwvvInv;				\
		    ffz += fdzdx;				\
		    ss += dsdx;					\
		    tt += dtdx;					\
		    uu += dudx;					\
		    vv += dvdx;					\
		    ww += dwdx;					\
		 }						\
}							\
else {						\
for (i=0;i<n;i++) {				\
		    GLdouble wwvvInv = 1.0 / (ww*vv);		\
		    zspan[i] = FixedToDepth(ffz);		\
		    red[i]   = FixedToInt(ffr);			\
		    green[i] = FixedToInt(ffg);			\
		    blue[i]  = FixedToInt(ffb);			\
		    alpha[i] = FixedToInt(ffa);			\
		    s[i] = ss*wwvvInv;				\
		    t[i] = tt*wwvvInv;				\
		    u[i] = uu*wwvvInv;				\
		    ffz += fdzdx;				\
		    ffr += fdrdx;				\
		    ffg += fdgdx;				\
		    ffb += fdbdx;				\
		    ffa += fdadx;				\
		    ss += dsdx;					\
		    tt += dtdx;					\
		    uu += dudx;					\
		    ww += dwdx;					\
		    vv += dvdx;					\
		 }						\
}							\
	      gl_write_texture_span( ctx, n, LEFT, Y, zspan,	\
s, t, u, NULL, 		\
	                             red, green, blue, alpha,	\
				     GL_POLYGON );		\
	   }							\
	}
}
static float compute_lambda( float s, float t,
float dsdx, float dsdy,
float dtdx, float dtdy,
float w, float dwdx, float dwdy,
float width, float height )
{
float invw = 1.0 / w;
float dudx, dudy, dvdx, dvdy;
float r1, r2, rho2;
dudx = (dsdx - s*dwdx) * invw * width;
dudy = (dsdy - s*dwdy) * invw * width;
dvdx = (dtdx - t*dwdx) * invw * height;
dvdy = (dtdy - t*dwdy) * invw * height;
r1 = dudx * dudx + dudy * dudy;
r2 = dvdx * dvdx + dvdy * dvdy;
rho2 = r1 + r2;
if (rho2 <= 0.0F) {
return 0.0F;
}
else {
return log(rho2) * 1.442695 * 0.5;
}
}
static void lambda_textured_triangle( GLcontext *ctx, GLuint v0, GLuint v1,
GLuint v2, GLuint pv )
{
#define INTERP_Z 1
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define INTERP_STW 1
#define INTERP_UV 1
#define SETUP_CODE							\
GLboolean flat_shade = (ctx->Light.ShadeModel==GL_FLAT);		\
GLint r, g, b, a;							\
float twidth, theight;						\
if (ctx->Texture.Enabled & TEXTURE_3D) {				\
twidth = (float) ctx->Texture.Current3D->Image[0]->Width;	\
theight = (float) ctx->Texture.Current3D->Image[0]->Height;	\
}									\
else if (ctx->Texture.Enabled & TEXTURE_2D) {			\
twidth = (float) ctx->Texture.Current2D->Image[0]->Width;	\
theight = (float) ctx->Texture.Current2D->Image[0]->Height;	\
}									\
else {								\
twidth = (float) ctx->Texture.Current1D->Image[0]->Width;	\
theight = 1.0;							\
}									\
if (flat_shade) {							\
r = VB->Color[pv][0];						\
g = VB->Color[pv][1];						\
b = VB->Color[pv][2];						\
a = VB->Color[pv][3];						\
}
#define INNER_LOOP( LEFT, RIGHT, Y )					\
	{								\
	   GLint i, n = RIGHT-LEFT;					\
	   GLdepth zspan[MAX_WIDTH];					\
	   GLubyte red[MAX_WIDTH], green[MAX_WIDTH];			\
	   GLubyte blue[MAX_WIDTH], alpha[MAX_WIDTH];			\
float s[MAX_WIDTH], t[MAX_WIDTH], u[MAX_WIDTH];		\
	   DEFARRAY(float,lambda,MAX_WIDTH);				\
	   if (n>0) {							\
	      if (flat_shade) {						\
		 for (i=0;i<n;i++) {					\
		    GLdouble wwvvInv = 1.0 / (ww*vv);			\
		    zspan[i] = FixedToDepth(ffz);			\
		    red[i]   = r;					\
		    green[i] = g;					\
		    blue[i]  = b;					\
		    alpha[i] = a;					\
		    s[i] = ss*wwvvInv;					\
		    t[i] = tt*wwvvInv;					\
		    u[i] = uu*wwvvInv;					\
		    lambda[i] = compute_lambda( s[i], t[i],		\
						dsdx, dsdy,		\
						dtdx, dtdy, ww,		\
						dwdx, dwdy,		\
						twidth, theight );	\
		    ffz += fdzdx;					\
		    ss += dsdx;						\
		    tt += dtdx;						\
		    uu += dudx;						\
		    vv += dvdx;						\
		    ww += dwdx;						\
		 }							\
}								\
else {							\
		 for (i=0;i<n;i++) {					\
		    GLdouble wwvvInv = 1.0 / (ww*vv);			\
		    zspan[i] = FixedToDepth(ffz);			\
		    red[i]   = FixedToInt(ffr);				\
		    green[i] = FixedToInt(ffg);				\
		    blue[i]  = FixedToInt(ffb);				\
		    alpha[i] = FixedToInt(ffa);				\
		    s[i] = ss*wwvvInv;					\
		    t[i] = tt*wwvvInv;					\
		    u[i] = uu*wwvvInv;					\
		    lambda[i] = compute_lambda( s[i], t[i],		\
						dsdx, dsdy,		\
						dtdx, dtdy, ww,		\
						dwdx, dwdy,		\
						twidth, theight );	\
		    ffz += fdzdx;					\
		    ffr += fdrdx;					\
		    ffg += fdgdx;					\
		    ffb += fdbdx;					\
		    ffa += fdadx;					\
		    ss += dsdx;						\
		    tt += dtdx;						\
		    uu += dudx;						\
		    vv += dvdx;						\
		    ww += dwdx;						\
		 }							\
}								\
	      gl_write_texture_span( ctx, n, LEFT, Y, zspan,		\
s, t, u, lambda,	 		\
	                             red, green, blue, alpha,		\
				     GL_POLYGON );			\
	   }								\
	   UNDEFARRAY(lambda);						\
	}
}
static void null_triangle( GLcontext *ctx, GLuint v0, GLuint v1,
GLuint v2, GLuint pv )
{
}
void gl_set_triangle_function( GLcontext *ctx )
{
GLboolean rgbmode = ctx->Visual->RGBAflag;
if (ctx->RenderMode==GL_RENDER) {
if (ctx->NoRaster) {
ctx->Driver.TriangleFunc = null_triangle;
return;
}
if (ctx->Driver.TriangleFunc) {
}
else if (ctx->Texture.Enabled
&& ctx->Texture.Current
&& ctx->Texture.Current->Complete) {
if (   (ctx->Texture.Enabled==TEXTURE_2D)
&& ctx->Texture.Current2D->MinFilter==GL_NEAREST
&& ctx->Texture.Current2D->MagFilter==GL_NEAREST
&& ctx->Texture.Current2D->WrapS==GL_REPEAT
&& ctx->Texture.Current2D->WrapT==GL_REPEAT
&& ctx->Texture.Current2D->Image[0]->Format==GL_RGB
&& ctx->Texture.Current2D->Image[0]->Border==0
&& (ctx->Texture.EnvMode==GL_DECAL
|| ctx->Texture.EnvMode==GL_REPLACE)
&& ctx->Hint.PerspectiveCorrection==GL_FASTEST
&& ctx->TextureMatrixType==MATRIX_IDENTITY
&& ((ctx->RasterMask==DEPTH_BIT
&& ctx->Depth.Func==GL_LESS
&& ctx->Depth.Mask==GL_TRUE)
|| ctx->RasterMask==0)
&& ctx->Polygon.StippleFlag==GL_FALSE
&& ctx->Visual->EightBitColor) {
if (ctx->RasterMask==DEPTH_BIT) {
ctx->Driver.TriangleFunc = simple_z_textured_triangle;
}
else {
ctx->Driver.TriangleFunc = simple_textured_triangle;
}
}
else {
GLboolean needLambda = GL_TRUE;
if (ctx->Texture.Enabled & TEXTURE_3D) {
if (ctx->Texture.Current3D->MinFilter==
ctx->Texture.Current3D->MagFilter) {
needLambda = GL_FALSE;
}
	    }
else if (ctx->Texture.Enabled & TEXTURE_2D) {
if (ctx->Texture.Current2D->MinFilter==
ctx->Texture.Current2D->MagFilter) {
needLambda = GL_FALSE;
}
}
else if (ctx->Texture.Enabled & TEXTURE_1D) {
if (ctx->Texture.Current1D->MinFilter==
ctx->Texture.Current1D->MagFilter) {
needLambda = GL_FALSE;
}
}
ctx->Driver.TriangleFunc = needLambda ? lambda_textured_triangle
: general_textured_triangle;
}
}
else {
	 if (ctx->Light.ShadeModel==GL_SMOOTH) {
	
	    ctx->Driver.TriangleFunc = rgbmode ? smooth_rgba_triangle
: smooth_ci_triangle;
	 }
	 else {
	
	    ctx->Driver.TriangleFunc = rgbmode ? flat_rgba_triangle
: flat_ci_triangle;
	 }
}
}
else if (ctx->RenderMode==GL_FEEDBACK) {
ctx->Driver.TriangleFunc = feedback_triangle;
}
else {
ctx->Driver.TriangleFunc = select_triangle;
}
}
/* 当前文件是D:\Read\varray.c*/

#ifdef PC_HEADER
#else
#endif
void gl_VertexPointer( GLcontext *ctx,
GLint size, GLenum type, GLsizei stride,
const GLvoid *ptr )
{
if (size<2 || size>4) {
gl_error( ctx, GL_INVALID_VALUE, "glVertexPointer(size)" );
return;
}
if (stride<0) {
gl_error( ctx, GL_INVALID_VALUE, "glVertexPointer(stride)" );
return;
}
switch (type) {
case GL_SHORT:
ctx->Array.VertexStrideB = stride ? stride : size*sizeof(GLshort);
break;
case GL_INT:
ctx->Array.VertexStrideB = stride ? stride : size*sizeof(GLint);
break;
case GL_FLOAT:
ctx->Array.VertexStrideB = stride ? stride : size*sizeof(float);
break;
case GL_DOUBLE:
ctx->Array.VertexStrideB = stride ? stride : size*sizeof(GLdouble);
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glVertexPointer(type)" );
return;
}
ctx->Array.VertexSize = size;
ctx->Array.VertexType = type;
ctx->Array.VertexStride = stride;
ctx->Array.VertexPtr = (void *) ptr;
}
void gl_NormalPointer( GLcontext *ctx,
GLenum type, GLsizei stride, const GLvoid *ptr )
{
if (stride<0) {
gl_error( ctx, GL_INVALID_VALUE, "glNormalPointer(stride)" );
return;
}
switch (type) {
case GL_BYTE:
ctx->Array.NormalStrideB = stride ? stride : 3*sizeof(GLbyte);
break;
case GL_SHORT:
ctx->Array.NormalStrideB = stride ? stride : 3*sizeof(GLshort);
break;
case GL_INT:
ctx->Array.NormalStrideB = stride ? stride : 3*sizeof(GLint);
break;
case GL_FLOAT:
ctx->Array.NormalStrideB = stride ? stride : 3*sizeof(float);
break;
case GL_DOUBLE:
ctx->Array.NormalStrideB = stride ? stride : 3*sizeof(GLdouble);
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glNormalPointer(type)" );
return;
}
ctx->Array.NormalType = type;
ctx->Array.NormalStride = stride;
ctx->Array.NormalPtr = (void *) ptr;
}
void gl_ColorPointer( GLcontext *ctx,
GLint size, GLenum type, GLsizei stride,
const GLvoid *ptr )
{
if (size<3 || size>4) {
gl_error( ctx, GL_INVALID_VALUE, "glColorPointer(size)" );
return;
}
if (stride<0) {
gl_error( ctx, GL_INVALID_VALUE, "glColorPointer(stride)" );
return;
}
switch (type) {
case GL_BYTE:
ctx->Array.ColorStrideB = stride ? stride : size*sizeof(GLbyte);
break;
case GL_UNSIGNED_BYTE:
ctx->Array.ColorStrideB = stride ? stride : size*sizeof(GLubyte);
break;
case GL_SHORT:
ctx->Array.ColorStrideB = stride ? stride : size*sizeof(GLshort);
break;
case GL_UNSIGNED_SHORT:
ctx->Array.ColorStrideB = stride ? stride : size*sizeof(GLushort);
break;
case GL_INT:
ctx->Array.ColorStrideB = stride ? stride : size*sizeof(GLint);
break;
case GL_UNSIGNED_INT:
ctx->Array.ColorStrideB = stride ? stride : size*sizeof(GLuint);
break;
case GL_FLOAT:
ctx->Array.ColorStrideB = stride ? stride : size*sizeof(float);
break;
case GL_DOUBLE:
ctx->Array.ColorStrideB = stride ? stride : size*sizeof(GLdouble);
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glColorPointer(type)" );
return;
}
ctx->Array.ColorSize = size;
ctx->Array.ColorType = type;
ctx->Array.ColorStride = stride;
ctx->Array.ColorPtr = (void *) ptr;
}
void gl_IndexPointer( GLcontext *ctx,
GLenum type, GLsizei stride, const GLvoid *ptr )
{
if (stride<0) {
gl_error( ctx, GL_INVALID_VALUE, "glIndexPointer(stride)" );
return;
}
switch (type) {
case GL_SHORT:
ctx->Array.IndexStrideB = stride ? stride : sizeof(GLbyte);
break;
case GL_INT:
ctx->Array.IndexStrideB = stride ? stride : sizeof(GLint);
break;
case GL_FLOAT:
ctx->Array.IndexStrideB = stride ? stride : sizeof(float);
break;
case GL_DOUBLE:
ctx->Array.IndexStrideB = stride ? stride : sizeof(GLdouble);
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glIndexPointer(type)" );
return;
}
ctx->Array.IndexType = type;
ctx->Array.IndexStride = stride;
ctx->Array.IndexPtr = (void *) ptr;
}
void gl_TexCoordPointer( GLcontext *ctx,
GLint size, GLenum type, GLsizei stride,
const GLvoid *ptr )
{
if (size<1 || size>4) {
gl_error( ctx, GL_INVALID_VALUE, "glTexCoordPointer(size)" );
return;
}
switch (type) {
case GL_SHORT:
ctx->Array.TexCoordStrideB = stride ? stride : size*sizeof(GLshort);
break;
case GL_INT:
ctx->Array.TexCoordStrideB = stride ? stride : size*sizeof(GLint);
break;
case GL_FLOAT:
ctx->Array.TexCoordStrideB = stride ? stride : size*sizeof(float);
break;
case GL_DOUBLE:
ctx->Array.TexCoordStrideB = stride ? stride : size*sizeof(GLdouble);
break;
default:
gl_error( ctx, GL_INVALID_ENUM, "glTexCoordPointer(type)" );
return;
}
if (stride<0) {
gl_error( ctx, GL_INVALID_VALUE, "glTexCoordPointer(stride)" );
return;
}
ctx->Array.TexCoordSize = size;
ctx->Array.TexCoordType = type;
ctx->Array.TexCoordStride = stride;
ctx->Array.TexCoordPtr = (void *) ptr;
}


/* 当前文件是D:\Read\vb.c*/

#ifdef PC_HEADER
#else
#endif
#define CLIP_ALL_BITS    0x3f
struct vertex_buffer *gl_alloc_vb(void)
{
struct vertex_buffer *vb;
vb = (struct vertex_buffer *) calloc(sizeof(struct vertex_buffer), 1);
if (vb) {
GLuint i;
for (i=0;i<VB_SIZE;i++) {
vb->MaterialMask[i] = 0;
vb->ClipMask[i] = 0;
vb->Obj[i][3] = 1.0F;
vb->TexCoord[i][2] = 0.0F;
vb->TexCoord[i][3] = 1.0F;
}
vb->VertexSizeMask = VERTEX3_BIT;
vb->TexCoordSize = 2;
vb->MonoColor = GL_TRUE;
vb->MonoMaterial = GL_TRUE;
vb->MonoNormal = GL_TRUE;
vb->ClipOrMask = 0;
vb->ClipAndMask = CLIP_ALL_BITS;
}
return vb;
}
/* 当前文件是D:\Read\vbfill.c*/

#ifdef PC_HEADER
#else
#endif
void gl_Normal3f( GLcontext *ctx, float nx, float ny, float nz )
{
ctx->Current.Normal[0] = nx;
ctx->Current.Normal[1] = ny;
ctx->Current.Normal[2] = nz;
ctx->VB->MonoNormal = GL_FALSE;
}
void gl_Normal3fv( GLcontext *ctx, const float *n )
{
ctx->Current.Normal[0] = n[0];
ctx->Current.Normal[1] = n[1];
ctx->Current.Normal[2] = n[2];
ctx->VB->MonoNormal = GL_FALSE;
}
void gl_Indexf( GLcontext *ctx, float c )
{
ctx->Current.Index = (GLuint) (GLint) c;
ctx->VB->MonoColor = GL_FALSE;
}
void gl_Indexi( GLcontext *ctx, GLint c )
{
ctx->Current.Index = (GLuint) c;
ctx->VB->MonoColor = GL_FALSE;
}

/* 当前文件是D:\Read\vbrender.c*/

#ifdef PC_HEADER
#else
#endif
#ifdef PROFILE
#  define START_PROFILE				\
	{					\
	   GLdouble t0 = gl_time();
#  define END_PROFILE( TIMER, COUNTER, INCR )	\
	   TIMER += (gl_time() - t0);		\
	   COUNTER += INCR;			\
	}
#else
#  define START_PROFILE
#  define END_PROFILE( TIMER, COUNTER, INCR )
#endif
static void render_clipped_line( GLcontext *ctx, GLuint v1, GLuint v2 )
{
float ndc_x, ndc_y, ndc_z;
GLuint provoking_vertex;
struct vertex_buffer *VB = ctx->VB;
provoking_vertex = v2;
VB->Free = VB_MAX;
if (ctx->Transform.AnyClip) {
GLuint orig_v1 = v1, orig_v2 = v2;
if (gl_userclip_line( ctx, &v1, &v2 )==0)
	return;
if (v1!=orig_v1) {
TRANSFORM_POINT( VB->Clip[v1], ctx->ProjectionMatrix, VB->Eye[v1] );
}
if (v2!=orig_v2) {
TRANSFORM_POINT( VB->Clip[v2], ctx->ProjectionMatrix, VB->Eye[v2] );
}
}
if (gl_viewclip_line( ctx, &v1, &v2 )==0)
return;
if (VB->Clip[v1][3] != 0.0F) {
float wInv = 1.0F / VB->Clip[v1][3];
ndc_x = VB->Clip[v1][0] * wInv;
ndc_y = VB->Clip[v1][1] * wInv;
ndc_z = VB->Clip[v1][2] * wInv;
}
else {
ndc_x = ndc_y = ndc_z = 0.0F;
}
VB->Win[v1][0] = ndc_x * ctx->Viewport.Sx + ctx->Viewport.Tx;
VB->Win[v1][1] = ndc_y * ctx->Viewport.Sy + ctx->Viewport.Ty;
VB->Win[v1][2] = ndc_z * ctx->Viewport.Sz + ctx->Viewport.Tz;
if (VB->Clip[v2][3] != 0.0F) {
float wInv = 1.0F / VB->Clip[v2][3];
ndc_x = VB->Clip[v2][0] * wInv;
ndc_y = VB->Clip[v2][1] * wInv;
ndc_z = VB->Clip[v2][2] * wInv;
}
else {
ndc_x = ndc_y = ndc_z = 0.0F;
}
VB->Win[v2][0] = ndc_x * ctx->Viewport.Sx + ctx->Viewport.Tx;
VB->Win[v2][1] = ndc_y * ctx->Viewport.Sy + ctx->Viewport.Ty;
VB->Win[v2][2] = ndc_z * ctx->Viewport.Sz + ctx->Viewport.Tz;
if (ctx->Driver.RasterSetup) {
(*ctx->Driver.RasterSetup)( ctx, v1, v1+1 );
(*ctx->Driver.RasterSetup)( ctx, v2, v2+1 );
}
START_PROFILE
(*ctx->Driver.LineFunc)( ctx, v1, v2, provoking_vertex );
END_PROFILE( ctx->LineTime, ctx->LineCount, 1 )
}
static void offset_polygon( GLcontext *ctx, float a, float b, float c )
{
float ac, bc, m;
float offset;
if (c<0.001F && c>-0.001F) {
offset = 0.0F;
}
else {
ac = a / c;
bc = b / c;
if (ac<0.0F)  ac = -ac;
if (bc<0.0F)  bc = -bc;
m = MAX2( ac, bc );
offset = m * ctx->Polygon.OffsetFactor + ctx->Polygon.OffsetUnits;
}
ctx->PointZoffset   = ctx->Polygon.OffsetPoint ? offset : 0.0F;
ctx->LineZoffset    = ctx->Polygon.OffsetLine  ? offset : 0.0F;
ctx->PolygonZoffset = ctx->Polygon.OffsetFill  ? offset : 0.0F;
}
static void unfilled_polygon( GLcontext *ctx,
GLuint n, GLuint vlist[],
GLuint pv, GLuint facing )
{
GLenum mode = facing ? ctx->Polygon.BackMode : ctx->Polygon.FrontMode;
struct vertex_buffer *VB = ctx->VB;
if (mode==GL_POINT) {
GLint i, j;
GLboolean edge;
if (   ctx->Primitive==GL_TRIANGLES
|| ctx->Primitive==GL_QUADS
|| ctx->Primitive==GL_POLYGON) {
edge = GL_FALSE;
}
else {
edge = GL_TRUE;
}
for (i=0;i<n;i++) {
j = vlist[i];
if (edge || VB->Edgeflag[j]) {
(*ctx->Driver.PointsFunc)( ctx, j, j );
}
}
}
else if (mode==GL_LINE) {
GLuint i, j0, j1;
GLboolean edge;
ctx->StippleCounter = 0;
if (   ctx->Primitive==GL_TRIANGLES
|| ctx->Primitive==GL_QUADS
|| ctx->Primitive==GL_POLYGON) {
edge = GL_FALSE;
}
else {
edge = GL_TRUE;
}
for (i=0;i<n;i++) {
j0 = (i==0) ? vlist[n-1] : vlist[i-1];
j1 = vlist[i];
if (edge || VB->Edgeflag[j0]) {
START_PROFILE
(*ctx->Driver.LineFunc)( ctx, j0, j1, pv );
END_PROFILE( ctx->LineTime, ctx->LineCount, 1 )
}
}
}
else {
GLuint j0, i;
j0 = vlist[0];
for (i=2;i<n;i++) {
START_PROFILE
(*ctx->Driver.TriangleFunc)( ctx, j0, vlist[i-1], vlist[i], pv );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 1 )
}
}
}
static float polygon_area( const struct vertex_buffer *vb,
GLuint n, const GLuint vlist[] )
{
float area = 0.0F;
GLint i;
for (i=0;i<n;i++) {
GLuint j0 = vlist[i];
GLuint j1 = vlist[(i+1)%n];
float x0 = vb->Win[j0][0];
float y0 = vb->Win[j0][1];
float x1 = vb->Win[j1][0];
float y1 = vb->Win[j1][1];
float trapArea = (x0-x1)*(y0+y1);
area += trapArea;
}
return area * 0.5F;
}
static void render_polygon( GLcontext *ctx, GLuint n, GLuint vlist[] )
{
struct vertex_buffer *VB = ctx->VB;
GLuint pv;
pv = (ctx->Primitive==GL_POLYGON) ? vlist[0] : vlist[n-1];
{
GLuint facing;
float area = polygon_area( VB, n, vlist );
if (area==0.0F) {
return;
}
facing = (area<0.0F) ^ (ctx->Polygon.FrontFace==GL_CW);
if ((facing+1) & ctx->Polygon.CullBits) {
return;
}
if (ctx->Polygon.OffsetAny) {
GLuint j0 = vlist[0];
GLuint j1 = vlist[1];
GLuint j2 = vlist[2];
GLuint j3 = vlist[ (n==3) ? 0 : 3 ];
float ex = VB->Win[j1][0] - VB->Win[j3][0];
float ey = VB->Win[j1][1] - VB->Win[j3][1];
float ez = VB->Win[j1][2] - VB->Win[j3][2];
float fx = VB->Win[j2][0] - VB->Win[j0][0];
float fy = VB->Win[j2][1] - VB->Win[j0][1];
float fz = VB->Win[j2][2] - VB->Win[j0][2];
float a = ey*fz-ez*fy;
float b = ez*fx-ex*fz;
float c = ex*fy-ey*fx;
offset_polygon( ctx, a, b, c );
}
if (ctx->LightTwoSide) {
if (facing==1) {
VB->Color = VB->Bcolor;
VB->Index = VB->Bindex;
}
else {
VB->Color = VB->Fcolor;
VB->Index = VB->Findex;
}
}
if (ctx->Polygon.Unfilled) {
unfilled_polygon( ctx, n, vlist, pv, facing );
}
else {
GLint i;
GLuint j0 = vlist[0];
for (i=2;i<n;i++) {
START_PROFILE
(*ctx->Driver.TriangleFunc)( ctx, j0, vlist[i-1], vlist[i], pv );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 1 )
}
}
}
}
static void render_clipped_polygon( GLcontext *ctx, GLuint n, GLuint vlist[] )
{
GLuint pv;
struct vertex_buffer *VB = ctx->VB;
float (*win)[3] = VB->Win;
pv = (ctx->Primitive==GL_POLYGON) ? vlist[0] : vlist[n-1];
VB->Free = VB_MAX;
if (ctx->Transform.AnyClip) {
float *proj = ctx->ProjectionMatrix;
GLuint i;
n = gl_userclip_polygon( ctx, n, vlist );
if (n<3)
return;
for (i=0;i<n;i++) {
GLuint j = vlist[i];
TRANSFORM_POINT( VB->Clip[j], proj, VB->Eye[j] );
}
}
n = gl_viewclip_polygon( ctx, n, vlist );
if (n<3)
return;
{
float sx = ctx->Viewport.Sx;
float tx = ctx->Viewport.Tx;
float sy = ctx->Viewport.Sy;
float ty = ctx->Viewport.Ty;
float sz = ctx->Viewport.Sz;
float tz = ctx->Viewport.Tz;
GLuint i;
for (i=0;i<n;i++) {
GLuint j = vlist[i];
if (VB->Clip[j][3] != 0.0F) {
float wInv = 1.0F / VB->Clip[j][3];
win[j][0] = VB->Clip[j][0] * wInv * sx + tx;
win[j][1] = VB->Clip[j][1] * wInv * sy + ty;
win[j][2] = VB->Clip[j][2] * wInv * sz + tz;
}
else {
win[j][0] = win[j][1] = win[j][2] = 0.0F;
}
}
if (ctx->Driver.RasterSetup && (VB->Free > VB_MAX)) {
(*ctx->Driver.RasterSetup)(ctx, VB_MAX, VB->Free);
}
}
{
GLuint facing;
float area = polygon_area( VB, n, vlist );
if (area==0.0F) {
return;
}
facing = (area<0.0F) ^ (ctx->Polygon.FrontFace==GL_CW);
if ((facing+1) & ctx->Polygon.CullBits) {
return;
}
if (ctx->Polygon.OffsetAny) {
GLuint j0 = vlist[0];
GLuint j1 = vlist[1];
GLuint j2 = vlist[2];
GLuint j3 = vlist[ (n==3) ? 0 : 3 ];
float ex = win[j1][0] - win[j3][0];
float ey = win[j1][1] - win[j3][1];
float ez = win[j1][2] - win[j3][2];
float fx = win[j2][0] - win[j0][0];
float fy = win[j2][1] - win[j0][1];
float fz = win[j2][2] - win[j0][2];
float a = ey*fz-ez*fy;
float b = ez*fx-ex*fz;
float c = ex*fy-ey*fx;
offset_polygon( ctx, a, b, c );
}
if (ctx->LightTwoSide) {
if (facing==1) {
VB->Color = VB->Bcolor;
VB->Index = VB->Bindex;
}
else {
VB->Color = VB->Fcolor;
VB->Index = VB->Findex;
}
}
if (ctx->Polygon.Unfilled) {
unfilled_polygon( ctx, n, vlist, pv, facing );
}
else {
GLint i;
GLuint j0 = vlist[0];
for (i=2;i<n;i++) {
START_PROFILE
(*ctx->Driver.TriangleFunc)( ctx, j0, vlist[i-1], vlist[i], pv );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 1 )
}
}
}
}
static void render_triangle( GLcontext *ctx,
GLuint v0, GLuint v1, GLuint v2, GLuint pv )
{
struct vertex_buffer *VB = ctx->VB;
float ex, ey, fx, fy, c;
GLuint facing;
float (*win)[3] = VB->Win;
ex = win[v1][0] - win[v0][0];
ey = win[v1][1] - win[v0][1];
fx = win[v2][0] - win[v0][0];
fy = win[v2][1] - win[v0][1];
c = ex*fy-ey*fx;
if (c==0.0F) {
return;
}
facing = (c<0.0F) ^ (ctx->Polygon.FrontFace==GL_CW);
if ((facing+1) & ctx->Polygon.CullBits) {
return;
}
if (ctx->Polygon.OffsetAny) {
float fz = win[v2][2] - win[v0][2];
float ez = win[v1][2] - win[v0][2];
float a = ey*fz-ez*fy;
float b = ez*fx-ex*fz;
offset_polygon( ctx, a, b, c );
}
if (ctx->LightTwoSide) {
if (facing==1) {
VB->Color = VB->Bcolor;
VB->Index = VB->Bindex;
}
else {
VB->Color = VB->Fcolor;
VB->Index = VB->Findex;
}
}
if (ctx->Polygon.Unfilled) {
GLuint vlist[3];
vlist[0] = v0;
vlist[1] = v1;
vlist[2] = v2;
unfilled_polygon( ctx, 3, vlist, pv, facing );
}
else {
START_PROFILE
(*ctx->Driver.TriangleFunc)( ctx, v0, v1, v2, pv );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 1 )
}
}
static void render_quad( GLcontext *ctx, GLuint v0, GLuint v1,
GLuint v2, GLuint v3, GLuint pv )
{
struct vertex_buffer *VB = ctx->VB;
float ex, ey, fx, fy, c;
GLuint facing;
float (*win)[3] = VB->Win;
ex = win[v2][0] - win[v0][0];
ey = win[v2][1] - win[v0][1];
fx = win[v3][0] - win[v1][0];
fy = win[v3][1] - win[v1][1];
c = ex*fy-ey*fx;
if (c==0.0F) {
return;
}
facing = (c<0.0F) ^ (ctx->Polygon.FrontFace==GL_CW);
if ((facing+1) & ctx->Polygon.CullBits) {
return;
}
if (ctx->Polygon.OffsetAny) {
float ez = win[v2][2] - win[v0][2];
float fz = win[v3][2] - win[v1][2];
float a = ey*fz-ez*fy;
float b = ez*fx-ex*fz;
offset_polygon( ctx, a, b, c );
}
if (ctx->LightTwoSide) {
if (facing==1) {
VB->Color = VB->Bcolor;
VB->Index = VB->Bindex;
}
else {
VB->Color = VB->Fcolor;
VB->Index = VB->Findex;
}
}
if (ctx->Polygon.Unfilled) {
GLuint vlist[4];
vlist[0] = v0;
vlist[1] = v1;
vlist[2] = v2;
vlist[3] = v3;
unfilled_polygon( ctx, 4, vlist, pv, facing );
}
else {
START_PROFILE
(*ctx->Driver.QuadFunc)( ctx, v0, v1, v2, v3, pv );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 2 )
}
}
static void copy_vertex( struct vertex_buffer *vb, GLuint dst, GLuint src )
{
COPY_4V( vb->Clip[dst], vb->Clip[src] );
COPY_4V( vb->Eye[dst], vb->Eye[src] );
COPY_3V( vb->Win[dst], vb->Win[src] );
COPY_4V( vb->Fcolor[dst], vb->Fcolor[src] );
COPY_4V( vb->Bcolor[dst], vb->Bcolor[src] );
COPY_4V( vb->TexCoord[dst], vb->TexCoord[src] );
vb->Findex[dst] = vb->Findex[src];
vb->Bindex[dst] = vb->Bindex[src];
vb->Edgeflag[dst] = vb->Edgeflag[src];
vb->ClipMask[dst] = vb->ClipMask[src];
}
void gl_render_vb( GLcontext *ctx, GLboolean allDone )
{
struct vertex_buffer *VB = ctx->VB;
GLuint vlist[VB_SIZE];
switch (ctx->Primitive) {
case GL_POINTS:
START_PROFILE
(*ctx->Driver.PointsFunc)( ctx, 0, VB->Count-1 );
END_PROFILE( ctx->PointTime, ctx->PointCount, VB->Count )
	 break;
case GL_LINES:
if (VB->ClipOrMask) {
GLuint i;
for (i=1;i<VB->Count;i+=2) {
if (VB->ClipMask[i-1] | VB->ClipMask[i]) {
render_clipped_line( ctx, i-1, i );
}
else {
START_PROFILE
(*ctx->Driver.LineFunc)( ctx, i-1, i, i );
END_PROFILE( ctx->LineTime, ctx->LineCount, 1 )
}
ctx->StippleCounter = 0;
}
}
else {
GLuint i;
for (i=1;i<VB->Count;i+=2) {
START_PROFILE
(*ctx->Driver.LineFunc)( ctx, i-1, i, i );
END_PROFILE( ctx->LineTime, ctx->LineCount, 1 )
ctx->StippleCounter = 0;
}
}
	 break;
case GL_LINE_STRIP:
if (VB->ClipOrMask) {
GLuint i;
	    for (i=1;i<VB->Count;i++) {
if (VB->ClipMask[i-1] | VB->ClipMask[i]) {
render_clipped_line( ctx, i-1, i );
}
else {
START_PROFILE
(*ctx->Driver.LineFunc)( ctx, i-1, i, i );
END_PROFILE( ctx->LineTime, ctx->LineCount, 1 )
}
	    }
}
else {
GLuint i;
	    for (i=1;i<VB->Count;i++) {
START_PROFILE
(*ctx->Driver.LineFunc)( ctx, i-1, i, i );
END_PROFILE( ctx->LineTime, ctx->LineCount, 1 )
}
}
break;
case GL_LINE_LOOP:
{
GLuint i;
if (VB->Start==0) {
i = 1;
}
else {
i = 2;
}
while (i<VB->Count) {
if (VB->ClipMask[i-1] | VB->ClipMask[i]) {
render_clipped_line( ctx, i-1, i );
}
else {
START_PROFILE
(*ctx->Driver.LineFunc)( ctx, i-1, i, i );
END_PROFILE( ctx->LineTime, ctx->LineCount, 1 )
}
i++;
}
}
break;
case GL_TRIANGLES:
if (VB->ClipOrMask) {
GLuint i;
for (i=2;i<VB->Count;i+=3) {
if (VB->ClipMask[i-2] | VB->ClipMask[i-1] | VB->ClipMask[i]) {
vlist[0] = i-2;
vlist[1] = i-1;
vlist[2] = i-0;
render_clipped_polygon( ctx, 3, vlist );
}
else {
if (ctx->DirectTriangles) {
START_PROFILE
(*ctx->Driver.TriangleFunc)( ctx, i-2, i-1, i, i );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 1 )
}
else {
render_triangle( ctx, i-2, i-1, i, i );
}
}
}
}
else {
GLuint i;
if (ctx->DirectTriangles) {
for (i=2;i<VB->Count;i+=3) {
START_PROFILE
(*ctx->Driver.TriangleFunc)( ctx, i-2, i-1, i, i );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 1 )
}
}
else {
for (i=2;i<VB->Count;i+=3) {
render_triangle( ctx, i-2, i-1, i, i );
}
}
}
	 break;
case GL_TRIANGLE_STRIP:
if (VB->ClipOrMask) {
GLuint i;
for (i=2;i<VB->Count;i++) {
if (VB->ClipMask[i-2] | VB->ClipMask[i-1] | VB->ClipMask[i]) {
if (i&1) {
vlist[0] = i-1;
vlist[1] = i-2;
vlist[2] = i-0;
render_clipped_polygon( ctx, 3, vlist );
}
else {
vlist[0] = i-2;
vlist[1] = i-1;
vlist[2] = i-0;
render_clipped_polygon( ctx, 3, vlist );
}
}
else {
if (ctx->DirectTriangles) {
START_PROFILE
(*ctx->Driver.TriangleFunc)( ctx, i-2, i-1, i, i );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 1 )
}
else {
if (i&1)
render_triangle( ctx, i, i-1, i-2, i );
else
render_triangle( ctx, i-2, i-1, i, i );
}
}
}
}
else {
GLuint i;
if (ctx->DirectTriangles) {
for (i=2;i<VB->Count;i++) {
START_PROFILE
(*ctx->Driver.TriangleFunc)( ctx, i-2, i-1, i, i );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 1 )
}
}
else {
for (i=2;i<VB->Count;i++) {
if (i&1)
render_triangle( ctx, i, i-1, i-2, i );
else
render_triangle( ctx, i-2, i-1, i, i );
}
}
}
	 break;
case GL_TRIANGLE_FAN:
if (VB->ClipOrMask) {
GLuint i;
for (i=2;i<VB->Count;i++) {
if (VB->ClipMask[0] | VB->ClipMask[i-1] | VB->ClipMask[i]) {
vlist[0] = 0;
vlist[1] = i-1;
vlist[2] = i;
render_clipped_polygon( ctx, 3, vlist );
}
else {
if (ctx->DirectTriangles) {
START_PROFILE
(*ctx->Driver.TriangleFunc)( ctx, 0, i-1, i, i );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 1 )
}
else {
render_triangle( ctx, 0, i-1, i, i );
}
}
}
}
else {
GLuint i;
if (ctx->DirectTriangles) {
for (i=2;i<VB->Count;i++) {
START_PROFILE
(*ctx->Driver.TriangleFunc)( ctx, 0, i-1, i, i );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 1 )
}
}
else {
for (i=2;i<VB->Count;i++) {
render_triangle( ctx, 0, i-1, i, i );
}
}
}
	 break;
case GL_QUADS:
if (VB->ClipOrMask) {
GLuint i;
for (i=3;i<VB->Count;i+=4) {
if (  VB->ClipMask[i-3] | VB->ClipMask[i-2]
| VB->ClipMask[i-1] | VB->ClipMask[i]) {
vlist[0] = i-3;
vlist[1] = i-2;
vlist[2] = i-1;
vlist[3] = i-0;
render_clipped_polygon( ctx, 4, vlist );
}
else {
if (ctx->DirectTriangles) {
START_PROFILE
(*ctx->Driver.QuadFunc)( ctx, i-3, i-2, i-1, i, i );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 2 )
}
else {
render_quad( ctx, i-3, i-2, i-1, i, i );
}
}
}
}
else {
GLuint i;
if (ctx->DirectTriangles) {
for (i=3;i<VB->Count;i+=4) {
START_PROFILE
(*ctx->Driver.QuadFunc)( ctx, i-3, i-2, i-1, i, i );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 2 )
}
}
else {
for (i=3;i<VB->Count;i+=4) {
render_quad( ctx, i-3, i-2, i-1, i, i );
}
}
}
	 break;
case GL_QUAD_STRIP:
if (VB->ClipOrMask) {
GLuint i;
for (i=3;i<VB->Count;i+=2) {
if (  VB->ClipMask[i-2] | VB->ClipMask[i-3]
| VB->ClipMask[i-1] | VB->ClipMask[i]) {
vlist[0] = i-1;
vlist[1] = i-3;
vlist[2] = i-2;
vlist[3] = i-0;
render_clipped_polygon( ctx, 4, vlist );
}
else {
if (ctx->DirectTriangles) {
START_PROFILE
(*ctx->Driver.QuadFunc)( ctx, i-3, i-2, i, i-1, i );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 2 )
}
else {
render_quad( ctx, i-3, i-2, i, i-1, i );
}
}
}
}
else {
GLuint i;
if (ctx->DirectTriangles) {
for (i=3;i<VB->Count;i+=2) {
START_PROFILE
(*ctx->Driver.QuadFunc)( ctx, i-3, i-2, i, i-1, i );
END_PROFILE( ctx->PolygonTime, ctx->PolygonCount, 2 )
}
}
else {
for (i=3;i<VB->Count;i+=2) {
render_quad( ctx, i-3, i-2, i, i-1, i );
}
}
}
	 break;
case GL_POLYGON:
if (VB->Count>2) {
GLuint i;
for (i=0;i<VB->Count;i++) {
vlist[i] = i;
}
if (VB->ClipOrMask) {
render_clipped_polygon( ctx, VB->Count, vlist );
}
else {
render_polygon( ctx, VB->Count, vlist );
}
}
	 break;
default:
gl_problem( ctx, "invalid mode in gl_render_vb" );
}
gl_reset_vb( ctx, allDone );
}

void gl_reset_vb( GLcontext *ctx, GLboolean allDone )
{
struct vertex_buffer *VB = ctx->VB;
if (ctx->Primitive==GL_LINE_LOOP && allDone) {
if (VB->ClipMask[VB->Count-1] | VB->ClipMask[0]) {
render_clipped_line( ctx, VB->Count-1, 0 );
}
else {
START_PROFILE
(*ctx->Driver.LineFunc)( ctx, VB->Count-1, 0, 0 );
END_PROFILE( ctx->LineTime, ctx->LineCount, 1 )
}
}
if (VB->ClipOrMask) {
MEMSET( VB->ClipMask + VB->Start, 0,
(VB->Count - VB->Start) * sizeof(VB->ClipMask[0]) );
}
if (!VB->MonoMaterial) {
MEMSET( VB->MaterialMask + VB->Start, 0,
(VB->Count - VB->Start) * sizeof(VB->MaterialMask[0]) );
}
if (VB->VertexSizeMask!=VERTEX3_BIT) {
GLint i, n;
float (*obj)[4] = VB->Obj + VB->Start;
n = VB->Count - VB->Start;
for (i=0; i<n; i++) {
obj[i][3] = 1.0F;
}
}
if (allDone) {
VB->MonoColor = GL_TRUE;
VB->VertexSizeMask = VERTEX3_BIT;
if (VB->TexCoordSize!=2) {
GLint i, n = VB->Count;
for (i=0;i<n;i++) {
VB->TexCoord[i][2] = 0.0F;
VB->TexCoord[i][3] = 1.0F;
}
}
if (ctx->Current.TexCoord[2]==0.0F && ctx->Current.TexCoord[3]==1.0F) {
VB->TexCoordSize = 2;
}
else {
VB->TexCoordSize = 4;
}
}
switch (ctx->Primitive) {
case GL_POINTS:
ASSERT(VB->Start==0);
	 VB->Count = 0;
VB->ClipOrMask = 0;
VB->ClipAndMask = CLIP_ALL_BITS;
VB->MonoMaterial = GL_TRUE;
VB->MonoNormal = GL_TRUE;
	 break;
case GL_LINES:
ASSERT(VB->Start==0);
	 VB->Count = 0;
VB->ClipOrMask = 0;
VB->ClipAndMask = CLIP_ALL_BITS;
VB->MonoMaterial = GL_TRUE;
VB->MonoNormal = GL_TRUE;
	 break;
case GL_LINE_STRIP:
if (allDone) {
VB->Count = 0;
VB->ClipOrMask = 0;
VB->ClipAndMask = CLIP_ALL_BITS;
VB->MonoMaterial = GL_TRUE;
VB->MonoNormal = GL_TRUE;
	 }
else {
copy_vertex( VB, 0, VB->Count-1 );
VB->Count = 1;
VB->ClipOrMask = VB->ClipMask[0];
VB->ClipAndMask = VB->ClipMask[0];
VB->MonoMaterial = VB->MaterialMask[0] ? GL_FALSE : GL_TRUE;
}
break;
case GL_LINE_LOOP:
	 if (allDone) {
VB->Count = 0;
VB->ClipOrMask = 0;
VB->ClipAndMask = CLIP_ALL_BITS;
VB->MonoMaterial = GL_TRUE;
VB->MonoNormal = GL_TRUE;
	 }
	 else {
	    ASSERT(VB->Count==VB_MAX);
	
copy_vertex( VB, 1, VB_MAX-1 );
	    VB->Count = 2;
VB->ClipOrMask = VB->ClipMask[0] | VB->ClipMask[1];
VB->ClipAndMask = VB->ClipMask[0] & VB->ClipMask[1];
VB->MonoMaterial = !(VB->MaterialMask[0] | VB->MaterialMask[1]);
	 }
break;
case GL_TRIANGLES:
ASSERT(VB->Start==0);
	 VB->Count = 0;
VB->ClipOrMask = 0;
VB->ClipAndMask = CLIP_ALL_BITS;
VB->MonoMaterial = GL_TRUE;
VB->MonoNormal = GL_TRUE;
	 break;
case GL_TRIANGLE_STRIP:
if (allDone) {
VB->Count = 0;
VB->ClipOrMask = 0;
VB->ClipAndMask = CLIP_ALL_BITS;
VB->MonoMaterial = GL_TRUE;
VB->MonoNormal = GL_TRUE;
}
else {
copy_vertex( VB, 0, VB_MAX-2 );
copy_vertex( VB, 1, VB_MAX-1 );
VB->Count = 2;
VB->ClipOrMask = VB->ClipMask[0] | VB->ClipMask[1];
VB->ClipAndMask = VB->ClipMask[0] & VB->ClipMask[1];
VB->MonoMaterial = !(VB->MaterialMask[0] | VB->MaterialMask[1]);
}
	 break;
case GL_TRIANGLE_FAN:
if (allDone) {
VB->Count = 0;
VB->ClipOrMask = 0;
VB->ClipAndMask = CLIP_ALL_BITS;
VB->MonoMaterial = GL_TRUE;
VB->MonoNormal = GL_TRUE;
}
else {
copy_vertex( VB, 1, VB_MAX-1 );
VB->Count = 2;
VB->ClipOrMask = VB->ClipMask[0] | VB->ClipMask[1];
VB->ClipAndMask = VB->ClipMask[0] & VB->ClipMask[1];
VB->MonoMaterial = !(VB->MaterialMask[0] | VB->MaterialMask[1]);
	 }
	 break;
case GL_QUADS:
ASSERT(VB->Start==0);
	 VB->Count = 0;
VB->ClipOrMask = 0;
VB->ClipAndMask = CLIP_ALL_BITS;
VB->MonoMaterial = GL_TRUE;
VB->MonoNormal = GL_TRUE;
	 break;
case GL_QUAD_STRIP:
if (allDone) {
VB->Count = 0;
VB->ClipOrMask = 0;
VB->ClipAndMask = CLIP_ALL_BITS;
VB->MonoMaterial = GL_TRUE;
VB->MonoNormal = GL_TRUE;
}
else {
copy_vertex( VB, 0, VB_MAX-2 );
copy_vertex( VB, 1, VB_MAX-1 );
VB->Count = 2;
VB->ClipOrMask = VB->ClipMask[0] | VB->ClipMask[1];
VB->ClipAndMask = VB->ClipMask[0] & VB->ClipMask[1];
VB->MonoMaterial = !(VB->MaterialMask[0] | VB->MaterialMask[1]);
}
	 break;
case GL_POLYGON:
if (allDone) {
VB->Count = 0;
VB->ClipOrMask = 0;
VB->ClipAndMask = CLIP_ALL_BITS;
VB->MonoMaterial = GL_TRUE;
VB->MonoNormal = GL_TRUE;
}
else {
copy_vertex( VB, 1, VB_MAX-1 );
VB->Count = 2;
VB->ClipOrMask = VB->ClipMask[0] | VB->ClipMask[1];
VB->ClipAndMask = VB->ClipMask[0] & VB->ClipMask[1];
VB->MonoMaterial = !(VB->MaterialMask[0] | VB->MaterialMask[1]);
	 }
	 break;
default:
gl_problem( ctx, "invalid mode in gl_reset_vb" );
}
VB->Start = VB->Count;
}
/* 当前文件是D:\Read\vbxform.c*/

#ifdef PC_HEADER
#else
#endif
#if 0
static void transform_points2( GLcontext *ctx, GLuint n,
const float vObj[][4], float vEye[][4] )
{
switch (ctx->ModelViewMatrixType) {
case MATRIX_GENERAL:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0],  m4 = m[4],  m12 = m[12];
float m1 = m[1],  m5 = m[5],  m13 = m[13];
float m2 = m[2],  m6 = m[6],  m14 = m[14];
float m3 = m[3],  m7 = m[7],  m15 = m[15];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1];
vEye[i][0] = m0 * ox + m4 * oy + m12;
vEye[i][1] = m1 * ox + m5 * oy + m13;
vEye[i][2] = m2 * ox + m6 * oy + m14;
vEye[i][3] = m3 * ox + m7 * oy + m15;
}
}
break;
case MATRIX_IDENTITY:
{
GLuint i;
for (i=0;i<n;i++) {
vEye[i][0] = vObj[i][0];
vEye[i][1] = vObj[i][1];
vEye[i][2] = 0.0F;
vEye[i][3] = 1.0F;
}
}
break;
case MATRIX_2D:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0], m1 = m[1], m4 = m[4], m5 = m[5];
float m12 = m[12], m13 = m[13];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1];
vEye[i][0] = m0 * ox + m4 * oy + m12;
vEye[i][1] = m1 * ox + m5 * oy + m13;
vEye[i][2] = 0.0F;
vEye[i][3] = 1.0F;
}
}
break;
case MATRIX_2D_NO_ROT:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0], m5 = m[5], m12 = m[12], m13 = m[13];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1];
vEye[i][0] = m0 * ox           + m12;
vEye[i][1] =           m5 * oy + m13;
vEye[i][2] = 0.0F;
vEye[i][3] = 1.0F;
}
}
break;
case MATRIX_3D:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0], m1 = m[1], m2 = m[2], m4 = m[4], m5 = m[5];
float m6 = m[6], m12 = m[12], m13 = m[13], m14 = m[14];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1];
vEye[i][0] = m0 * ox + m4 * oy + m12;
vEye[i][1] = m1 * ox + m5 * oy + m13;
vEye[i][2] = m2 * ox + m6 * oy + m14;
vEye[i][3] = 1.0F;
}
}
break;
default:
gl_problem( NULL, "invalid matrix type in transform_points3()" );
return;
}
}
#endif
#define START_FAST_MATH
#define END_FAST_MATH
static void transform_points3( GLcontext *ctx, GLuint n,
float vObj[][4], float vEye[][4] )
{
#ifndef USE_ASM
START_FAST_MATH;
switch (ctx->ModelViewMatrixType) {
case MATRIX_GENERAL:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0],  m4 = m[4],  m8 = m[8],  m12 = m[12];
float m1 = m[1],  m5 = m[5],  m9 = m[9],  m13 = m[13];
float m2 = m[2],  m6 = m[6],  m10 = m[10],  m14 = m[14];
float m3 = m[3],  m7 = m[7],  m11 = m[11],  m15 = m[15];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1], oz = vObj[i][2];
vEye[i][0] = m0 * ox + m4 * oy + m8  * oz + m12;
vEye[i][1] = m1 * ox + m5 * oy + m9  * oz + m13;
vEye[i][2] = m2 * ox + m6 * oy + m10 * oz + m14;
vEye[i][3] = m3 * ox + m7 * oy + m11 * oz + m15;
}
}
break;
case MATRIX_IDENTITY:
{
GLuint i;
for (i=0;i<n;i++) {
vEye[i][0] = vObj[i][0];
vEye[i][1] = vObj[i][1];
vEye[i][2] = vObj[i][2];
vEye[i][3] = 1.0F;
}
}
break;
case MATRIX_2D:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0], m1 = m[1], m4 = m[4], m5 = m[5];
float m12 = m[12], m13 = m[13];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1], oz = vObj[i][2];
vEye[i][0] = m0 * ox + m4 * oy            + m12       ;
vEye[i][1] = m1 * ox + m5 * oy            + m13       ;
vEye[i][2] =                   +       oz             ;
vEye[i][3] =                                      1.0F;
}
}
break;
case MATRIX_2D_NO_ROT:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0], m5 = m[5], m12 = m[12], m13 = m[13];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1], oz = vObj[i][2];
vEye[i][0] = m0 * ox                      + m12       ;
vEye[i][1] =           m5 * oy            + m13       ;
vEye[i][2] =                   +       oz             ;
vEye[i][3] =                                      1.0F;
}
}
break;
case MATRIX_3D:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0], m1 = m[1], m2 = m[2], m4 = m[4], m5 = m[5];
float m6 = m[6], m8 = m[8], m9 = m[9], m10 = m[10];
float m12 = m[12], m13 = m[13], m14 = m[14];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1], oz = vObj[i][2];
vEye[i][0] = m0 * ox + m4 * oy +  m8 * oz + m12       ;
vEye[i][1] = m1 * ox + m5 * oy +  m9 * oz + m13       ;
vEye[i][2] = m2 * ox + m6 * oy + m10 * oz + m14       ;
vEye[i][3] =                                      1.0F;
}
}
break;
default:
gl_problem( NULL, "invalid matrix type in transform_points3()" );
}
END_FAST_MATH;
#else
switch (ctx->ModelViewMatrixType) {
case MATRIX_GENERAL:
asm_transform_points3_general( n, vEye, ctx->ModelViewMatrix, vObj );
break;
case MATRIX_IDENTITY:
asm_transform_points3_identity( n, vEye, vObj );
break;
case MATRIX_2D:
asm_transform_points3_2d( n, vEye, ctx->ModelViewMatrix, vObj );
break;
case MATRIX_2D_NO_ROT:
asm_transform_points3_2d_no_rot( n, vEye, ctx->ModelViewMatrix,
vObj );
break;
case MATRIX_3D:
asm_transform_points3_3d( n, vEye, ctx->ModelViewMatrix, vObj );
break;
default:
gl_problem( NULL, "invalid matrix type in transform_points3()" );
return;
}
#endif
}
static void transform_points4( GLcontext *ctx, GLuint n,
float vObj[][4], float vEye[][4] )
{
#ifndef USE_ASM
START_FAST_MATH;
switch (ctx->ModelViewMatrixType) {
case MATRIX_GENERAL:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0],  m4 = m[4],  m8 = m[8],  m12 = m[12];
float m1 = m[1],  m5 = m[5],  m9 = m[9],  m13 = m[13];
float m2 = m[2],  m6 = m[6],  m10 = m[10],  m14 = m[14];
float m3 = m[3],  m7 = m[7],  m11 = m[11],  m15 = m[15];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1];
float oz = vObj[i][2], ow = vObj[i][3];
vEye[i][0] = m0 * ox + m4 * oy + m8  * oz + m12 * ow;
vEye[i][1] = m1 * ox + m5 * oy + m9  * oz + m13 * ow;
vEye[i][2] = m2 * ox + m6 * oy + m10 * oz + m14 * ow;
vEye[i][3] = m3 * ox + m7 * oy + m11 * oz + m15 * ow;
}
}
break;
case MATRIX_IDENTITY:
{
GLuint i;
for (i=0;i<n;i++) {
vEye[i][0] = vObj[i][0];
vEye[i][1] = vObj[i][1];
vEye[i][2] = vObj[i][2];
vEye[i][3] = vObj[i][3];
}
}
break;
case MATRIX_2D:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0], m1 = m[1], m4 = m[4], m5 = m[5];
float m12 = m[12], m13 = m[13];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1];
float oz = vObj[i][2], ow = vObj[i][3];
vEye[i][0] = m0 * ox + m4 * oy            + m12 * ow;
vEye[i][1] = m1 * ox + m5 * oy            + m13 * ow;
vEye[i][2] =                   +       oz           ;
vEye[i][3] =                                      ow;
}
}
break;
case MATRIX_2D_NO_ROT:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0], m5 = m[5], m12 = m[12], m13 = m[13];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1];
float oz = vObj[i][2], ow = vObj[i][3];
vEye[i][0] = m0 * ox                      + m12 * ow;
vEye[i][1] =           m5 * oy            + m13 * ow;
vEye[i][2] =                   +       oz           ;
vEye[i][3] =                                      ow;
}
}
break;
case MATRIX_3D:
{
const float *m = ctx->ModelViewMatrix;
float m0 = m[0], m1 = m[1], m2 = m[2], m4 = m[4], m5 = m[5];
float m6 = m[6], m8 = m[8], m9 = m[9], m10 = m[10];
float m12 = m[12], m13 = m[13], m14 = m[14];
GLuint i;
for (i=0;i<n;i++) {
float ox = vObj[i][0], oy = vObj[i][1];
float oz = vObj[i][2], ow = vObj[i][3];
vEye[i][0] = m0 * ox + m4 * oy +  m8 * oz + m12 * ow;
vEye[i][1] = m1 * ox + m5 * oy +  m9 * oz + m13 * ow;
vEye[i][2] = m2 * ox + m6 * oy + m10 * oz + m14 * ow;
vEye[i][3] =                                      ow;
}
}
break;
default:
gl_problem( NULL, "invalid matrix type in transform_points4()" );
}
END_FAST_MATH;
#else
switch (ctx->ModelViewMatrixType) {
case MATRIX_GENERAL:
asm_transform_points4_general( n, vEye, ctx->ModelViewMatrix, vObj );
break;
case MATRIX_IDENTITY:
asm_transform_points4_identity( n, vEye, vObj );
break;
case MATRIX_2D:
asm_transform_points4_2d( n, vEye, ctx->ModelViewMatrix, vObj );
break;
case MATRIX_2D_NO_ROT:
asm_transform_points4_2d_no_rot( n, vEye, ctx->ModelViewMatrix,
vObj );
break;
case MATRIX_3D:
asm_transform_points4_3d( n, vEye, ctx->ModelViewMatrix, vObj );
break;
default:
gl_problem( NULL, "invalid matrix type in transform_points4()" );
return;
}
#endif
}
static void transform_texcoords( GLcontext *ctx, GLuint n, float t[][4] )
{
#ifndef USE_ASM
START_FAST_MATH;
switch (ctx->TextureMatrixType) {
case MATRIX_GENERAL:
{
const float *m = ctx->TextureMatrix;
float m0 = m[0],  m4 = m[4],  m8 = m[8],  m12 = m[12];
float m1 = m[1],  m5 = m[5],  m9 = m[9],  m13 = m[13];
float m2 = m[2],  m6 = m[6],  m10 = m[10],  m14 = m[14];
float m3 = m[3],  m7 = m[7],  m11 = m[11],  m15 = m[15];
GLuint i;
for (i=0;i<n;i++) {
float t0 = t[i][0], t1 = t[i][1], t2 = t[i][2], t3 = t[i][3];
t[i][0] = m0 * t0 + m4 * t1 + m8  * t2 + m12 * t3;
t[i][1] = m1 * t0 + m5 * t1 + m9  * t2 + m13 * t3;
t[i][2] = m2 * t0 + m6 * t1 + m10 * t2 + m14 * t3;
t[i][3] = m3 * t0 + m7 * t1 + m11 * t2 + m15 * t3;
}
}
break;
case MATRIX_IDENTITY:
break;
case MATRIX_2D:
{
const float *m = ctx->TextureMatrix;
float m0 = m[0], m1 = m[1], m4 = m[4], m5 = m[5];
float m12 = m[12], m13 = m[13];
GLuint i;
for (i=0;i<n;i++) {
float t0 = t[i][0], t1 = t[i][1], t2 = t[i][2], t3 = t[i][3];
t[i][0] = m0 * t0 + m4 * t1            + m12 * t3;
t[i][1] = m1 * t0 + m5 * t1            + m13 * t3;
t[i][2] =                   +       t2           ;
}
}
break;
case MATRIX_3D:
{
const float *m = ctx->TextureMatrix;
float m0 = m[0], m1 = m[1], m2 = m[2], m4 = m[4], m5 = m[5];
float m6 = m[6], m8 = m[8], m9 = m[9], m10 = m[10];
float m12 = m[12], m13 = m[13], m14 = m[14];
GLuint i;
for (i=0;i<n;i++) {
float t0 = t[i][0], t1 = t[i][1], t2 = t[i][2], t3 = t[i][3];
t[i][0] = m0 * t0 + m4 * t1 +  m8 * t2 + m12 * t3;
t[i][1] = m1 * t0 + m5 * t1 +  m9 * t2 + m13 * t3;
t[i][2] = m2 * t0 + m6 * t1 + m10 * t2 + m14 * t3;
}
}
break;
default:
gl_problem( NULL, "invalid matrix type in transform_texcoords()" );
}
END_FAST_MATH;
#else
switch (ctx->TextureMatrixType) {
case MATRIX_GENERAL:
asm_transform_points4_general( n, t, ctx->TextureMatrix, t );
break;
case MATRIX_IDENTITY:
break;
case MATRIX_2D:
asm_transform_points4_2d( n, t, ctx->TextureMatrix, t );
break;
case MATRIX_3D:
asm_transform_points4_3d( n, t, ctx->TextureMatrix, t );
break;
default:
gl_problem( NULL, "invalid matrix type in transform_texcoords()" );
return;
}
#endif
}
#define CLIP_RIGHT_BIT   0x01
#define CLIP_LEFT_BIT    0x02
#define CLIP_TOP_BIT     0x04
#define CLIP_BOTTOM_BIT  0x08
#define CLIP_NEAR_BIT    0x10
#define CLIP_FAR_BIT     0x20
#define CLIP_USER_BIT    0x40
#define CLIP_ALL_BITS    0x3f
#define CLIP_ALL   1
#define CLIP_NONE  2
#define CLIP_SOME  3
static void project_and_cliptest( GLcontext *ctx,
GLuint n,  float vEye[][4],
float vClip[][4], GLubyte clipMask[],
GLubyte *orMask, GLubyte *andMask )
{
#ifndef USE_ASM
GLubyte tmpOrMask = *orMask;
GLubyte tmpAndMask = *andMask;
START_FAST_MATH;
switch (ctx->ProjectionMatrixType) {
case MATRIX_GENERAL:
{
const float *m = ctx->ProjectionMatrix;
float m0 = m[0],  m4 = m[4],  m8 = m[8],  m12 = m[12];
float m1 = m[1],  m5 = m[5],  m9 = m[9],  m13 = m[13];
float m2 = m[2],  m6 = m[6],  m10 = m[10],  m14 = m[14];
float m3 = m[3],  m7 = m[7],  m11 = m[11],  m15 = m[15];
GLuint i;
for (i=0;i<n;i++) {
float ex = vEye[i][0], ey = vEye[i][1];
float ez = vEye[i][2], ew = vEye[i][3];
float cx = m0 * ex + m4 * ey + m8  * ez + m12 * ew;
float cy = m1 * ex + m5 * ey + m9  * ez + m13 * ew;
float cz = m2 * ex + m6 * ey + m10 * ez + m14 * ew;
float cw = m3 * ex + m7 * ey + m11 * ez + m15 * ew;
GLubyte mask = 0;
vClip[i][0] = cx;
vClip[i][1] = cy;
vClip[i][2] = cz;
vClip[i][3] = cw;
if (cx >  cw)       mask |= CLIP_RIGHT_BIT;
else if (cx < -cw)  mask |= CLIP_LEFT_BIT;
if (cy >  cw)       mask |= CLIP_TOP_BIT;
else if (cy < -cw)  mask |= CLIP_BOTTOM_BIT;
if (cz >  cw)       mask |= CLIP_FAR_BIT;
else if (cz < -cw)  mask |= CLIP_NEAR_BIT;
if (mask) {
clipMask[i] |= mask;
tmpOrMask |= mask;
}
tmpAndMask &= mask;
}
}
break;
case MATRIX_IDENTITY:
{
GLuint i;
for (i=0;i<n;i++) {
float cx = vClip[i][0] = vEye[i][0];
float cy = vClip[i][1] = vEye[i][1];
float cz = vClip[i][2] = vEye[i][2];
float cw = vClip[i][3] = vEye[i][3];
GLubyte mask = 0;
if (cx >  cw)       mask |= CLIP_RIGHT_BIT;
else if (cx < -cw)  mask |= CLIP_LEFT_BIT;
if (cy >  cw)       mask |= CLIP_TOP_BIT;
else if (cy < -cw)  mask |= CLIP_BOTTOM_BIT;
if (cz >  cw)       mask |= CLIP_FAR_BIT;
else if (cz < -cw)  mask |= CLIP_NEAR_BIT;
if (mask) {
clipMask[i] |= mask;
tmpOrMask |= mask;
}
tmpAndMask &= mask;
}
}
break;
case MATRIX_ORTHO:
{
const float *m = ctx->ProjectionMatrix;
float m0 = m[0], m5 = m[5], m10 = m[10], m12 = m[12];
float m13 = m[13], m14 = m[14];
GLuint i;
for (i=0;i<n;i++) {
float ex = vEye[i][0], ey = vEye[i][1];
float ez = vEye[i][2], ew = vEye[i][3];
float cx = m0 * ex                      + m12 * ew;
float cy =           m5 * ey            + m13 * ew;
float cz =                     m10 * ez + m14 * ew;
float cw =                                      ew;
GLubyte mask = 0;
vClip[i][0] = cx;
vClip[i][1] = cy;
vClip[i][2] = cz;
vClip[i][3] = cw;
if (cx >  cw)       mask |= CLIP_RIGHT_BIT;
else if (cx < -cw)  mask |= CLIP_LEFT_BIT;
if (cy >  cw)       mask |= CLIP_TOP_BIT;
else if (cy < -cw)  mask |= CLIP_BOTTOM_BIT;
if (cz >  cw)       mask |= CLIP_FAR_BIT;
else if (cz < -cw)  mask |= CLIP_NEAR_BIT;
if (mask) {
clipMask[i] |= mask;
tmpOrMask |= mask;
}
tmpAndMask &= mask;
}
}
break;
case MATRIX_PERSPECTIVE:
{
const float *m = ctx->ProjectionMatrix;
float m0 = m[0], m5 = m[5], m8 = m[8], m9 = m[9];
float m10 = m[10], m14 = m[14];
GLuint i;
for (i=0;i<n;i++) {
float ex = vEye[i][0], ey = vEye[i][1];
float ez = vEye[i][2], ew = vEye[i][3];
float cx = m0 * ex           + m8  * ez           ;
float cy =           m5 * ey + m9  * ez           ;
float cz =                     m10 * ez + m14 * ew;
float cw =                          -ez           ;
GLubyte mask = 0;
vClip[i][0] = cx;
vClip[i][1] = cy;
vClip[i][2] = cz;
vClip[i][3] = cw;
if (cx >  cw)       mask |= CLIP_RIGHT_BIT;
else if (cx < -cw)  mask |= CLIP_LEFT_BIT;
if (cy >  cw)       mask |= CLIP_TOP_BIT;
else if (cy < -cw)  mask |= CLIP_BOTTOM_BIT;
if (cz >  cw)       mask |= CLIP_FAR_BIT;
else if (cz < -cw)  mask |= CLIP_NEAR_BIT;
if (mask) {
clipMask[i] |= mask;
tmpOrMask |= mask;
}
tmpAndMask &= mask;
}
}
break;
default:
gl_problem( NULL, "invalid matrix type in project_and_cliptest()" );
}
*orMask = tmpOrMask;
*andMask = tmpAndMask;
END_FAST_MATH;
#else
switch (ctx->ProjectionMatrixType) {
case MATRIX_GENERAL:
asm_project_and_cliptest_general( n, vClip, ctx->ProjectionMatrix, vEye,
clipMask, orMask, andMask );
break;
case MATRIX_IDENTITY:
asm_project_and_cliptest_identity( n, vClip, vEye, clipMask, orMask, andMask );
break;
case MATRIX_ORTHO:
asm_project_and_cliptest_ortho( n, vClip, ctx->ProjectionMatrix, vEye,
clipMask, orMask, andMask );
break;
case MATRIX_PERSPECTIVE:
asm_project_and_cliptest_perspective( n, vClip, ctx->ProjectionMatrix,
vEye, clipMask, orMask, andMask );
break;
default:
gl_problem( NULL, "invalid matrix type in project_and_cliptest()" );
return;
}
#endif
}
static GLuint userclip_vertices( GLcontext *ctx, GLuint n,
float vEye[][4],
GLubyte clipMask[] )
{
GLboolean anyClipped = GL_FALSE;
GLuint p;
ASSERT(ctx->Transform.AnyClip);
START_FAST_MATH;
for (p=0;p<MAX_CLIP_PLANES;p++) {
if (ctx->Transform.ClipEnabled[p]) {
float a = ctx->Transform.ClipEquation[p][0];
float b = ctx->Transform.ClipEquation[p][1];
float c = ctx->Transform.ClipEquation[p][2];
float d = ctx->Transform.ClipEquation[p][3];
GLboolean allClipped = GL_TRUE;
GLuint i;
for (i=0;i<n;i++) {
float dot = vEye[i][0] * a + vEye[i][1] * b
+ vEye[i][2] * c + vEye[i][3] * d;
if (dot < 0.0F) {
clipMask[i] = CLIP_USER_BIT;
anyClipped = GL_TRUE;
}
else {
allClipped = GL_FALSE;
}
}
if (allClipped) {
return CLIP_ALL;
}
}
}
END_FAST_MATH;
return anyClipped ? CLIP_SOME : CLIP_NONE;
}
static void viewport_map_vertices( GLcontext *ctx,
GLuint n,  float vClip[][4],
const GLubyte clipMask[], float vWin[][3])
{
float sx = ctx->Viewport.Sx;
float tx = ctx->Viewport.Tx;
float sy = ctx->Viewport.Sy;
float ty = ctx->Viewport.Ty;
float sz = ctx->Viewport.Sz;
float tz = ctx->Viewport.Tz;
START_FAST_MATH;
if ((ctx->ProjectionMatrixType==MATRIX_ORTHO ||
ctx->ProjectionMatrixType==MATRIX_IDENTITY)
&& ctx->ModelViewMatrixType!=MATRIX_GENERAL
&& (ctx->VB->VertexSizeMask & VERTEX4_BIT)==0) {
if (clipMask) {
GLuint i;
for (i=0;i<n;i++) {
if (clipMask[i]==0) {
vWin[i][0] = vClip[i][0] * sx + tx;
vWin[i][1] = vClip[i][1] * sy + ty;
vWin[i][2] = vClip[i][2] * sz + tz;
}
}
}
else {
GLuint i;
for (i=0;i<n;i++) {
vWin[i][0] = vClip[i][0] * sx + tx;
vWin[i][1] = vClip[i][1] * sy + ty;
vWin[i][2] = vClip[i][2] * sz + tz;
}
}
}
else {
if (clipMask) {
GLuint i;
for (i=0;i<n;i++) {
if (clipMask[i] == 0) {
if (vClip[i][3] != 0.0F) {
float wInv = 1.0F / vClip[i][3];
vWin[i][0] = vClip[i][0] * wInv * sx + tx;
vWin[i][1] = vClip[i][1] * wInv * sy + ty;
vWin[i][2] = vClip[i][2] * wInv * sz + tz;
}
else {
vWin[i][0] = 0.0F;
vWin[i][1] = 0.0F;
vWin[i][2] = 0.0F;
}
}
}
}
else {
GLuint i;
for (i=0;i<n;i++) {
if (vClip[i][3] != 0.0F) {
float wInv = 1.0F / vClip[i][3];
vWin[i][0] = vClip[i][0] * wInv * sx + tx;
vWin[i][1] = vClip[i][1] * wInv * sy + ty;
vWin[i][2] = vClip[i][2] * wInv * sz + tz;
}
else {
vWin[i][0] = 0.0F;
vWin[i][1] = 0.0F;
vWin[i][2] = 0.0F;
}
}
}
}
END_FAST_MATH;
}
static void update_material( GLcontext *ctx, GLuint i )
{
struct vertex_buffer *VB = ctx->VB;
if (VB->MaterialMask[i]) {
if (VB->MaterialMask[i] & FRONT_AMBIENT_BIT) {
COPY_4V( ctx->Light.Material[0].Ambient, VB->Material[i][0].Ambient );
}
if (VB->MaterialMask[i] & BACK_AMBIENT_BIT) {
COPY_4V( ctx->Light.Material[1].Ambient, VB->Material[i][1].Ambient );
}
if (VB->MaterialMask[i] & FRONT_DIFFUSE_BIT) {
COPY_4V( ctx->Light.Material[0].Diffuse, VB->Material[i][0].Diffuse );
}
if (VB->MaterialMask[i] & BACK_DIFFUSE_BIT) {
COPY_4V( ctx->Light.Material[1].Diffuse, VB->Material[i][1].Diffuse );
}
if (VB->MaterialMask[i] & FRONT_SPECULAR_BIT) {
COPY_4V( ctx->Light.Material[0].Specular, VB->Material[i][0].Specular );
}
if (VB->MaterialMask[i] & BACK_SPECULAR_BIT) {
COPY_4V( ctx->Light.Material[1].Specular, VB->Material[i][1].Specular );
}
if (VB->MaterialMask[i] & FRONT_EMISSION_BIT) {
COPY_4V( ctx->Light.Material[0].Emission, VB->Material[i][0].Emission );
}
if (VB->MaterialMask[i] & BACK_EMISSION_BIT) {
COPY_4V( ctx->Light.Material[1].Emission, VB->Material[i][1].Emission );
}
if (VB->MaterialMask[i] & FRONT_SHININESS_BIT) {
ctx->Light.Material[0].Shininess = VB->Material[i][0].Shininess;
gl_compute_material_shine_table( &ctx->Light.Material[0] );
}
if (VB->MaterialMask[i] & BACK_SHININESS_BIT) {
ctx->Light.Material[1].Shininess = VB->Material[i][1].Shininess;
gl_compute_material_shine_table( &ctx->Light.Material[1] );
}
if (VB->MaterialMask[i] & FRONT_INDEXES_BIT) {
ctx->Light.Material[0].AmbientIndex = VB->Material[i][0].AmbientIndex;
ctx->Light.Material[0].DiffuseIndex = VB->Material[i][0].DiffuseIndex;
ctx->Light.Material[0].SpecularIndex = VB->Material[i][0].SpecularIndex;
}
if (VB->MaterialMask[i] & BACK_INDEXES_BIT) {
ctx->Light.Material[1].AmbientIndex = VB->Material[i][1].AmbientIndex;
ctx->Light.Material[1].DiffuseIndex = VB->Material[i][1].DiffuseIndex;
ctx->Light.Material[1].SpecularIndex = VB->Material[i][1].SpecularIndex;
}
VB->MaterialMask[i] = 0;
}
}
static void shade_vertices( GLcontext *ctx )
{
struct vertex_buffer *VB = ctx->VB;
if (ctx->Visual->RGBAflag) {
if (!VB->MonoMaterial) {
GLuint i;
for (i=VB->Start; i<VB->Count; i++) {
update_material( ctx, i );
gl_color_shade_vertices( ctx, 0, 1, &VB->Eye[i],
&VB->Normal[i], &VB->Fcolor[i]);
if (ctx->Light.Model.TwoSide) {
gl_color_shade_vertices( ctx, 1, 1, &VB->Eye[i],
&VB->Normal[i], &VB->Bcolor[i]);
}
}
update_material( ctx, VB->Count );
}
else {
if (ctx->Light.Fast) {
if (VB->MonoNormal) {
GLubyte color[1][4];
GLuint i;
gl_color_shade_vertices_fast( ctx, 0,
1,
VB->Normal + VB->Start,
color );
for (i=VB->Start; i<VB->Count; i++) {
COPY_4V( VB->Fcolor[i], color[0] );
}
if (ctx->Light.Model.TwoSide) {
gl_color_shade_vertices_fast( ctx, 1,
1,
VB->Normal + VB->Start,
color );
for (i=VB->Start; i<VB->Count; i++) {
COPY_4V( VB->Bcolor[i], color[0] );
}
}
}
else {
gl_color_shade_vertices_fast( ctx, 0,
VB->Count - VB->Start,
VB->Normal + VB->Start,
VB->Fcolor + VB->Start );
if (ctx->Light.Model.TwoSide) {
gl_color_shade_vertices_fast( ctx, 1,
VB->Count - VB->Start,
VB->Normal + VB->Start,
VB->Bcolor + VB->Start );
}
}
}
else {
gl_color_shade_vertices( ctx, 0,
VB->Count - VB->Start,
VB->Eye + VB->Start,
VB->Normal + VB->Start,
VB->Fcolor + VB->Start );
if (ctx->Light.Model.TwoSide) {
gl_color_shade_vertices( ctx, 1,
VB->Count - VB->Start,
VB->Eye + VB->Start,
VB->Normal + VB->Start,
VB->Bcolor + VB->Start );
}
}
}
}
else {
if (!VB->MonoMaterial) {
GLuint i;
for (i=VB->Start; i<VB->Count; i++) {
update_material( ctx, i );
gl_index_shade_vertices( ctx, 0, 1, &VB->Eye[i],
&VB->Normal[i], &VB->Findex[i] );
if (ctx->Light.Model.TwoSide) {
gl_index_shade_vertices( ctx, 1, 1, &VB->Eye[i],
&VB->Normal[i], &VB->Bindex[i] );
}
}
update_material( ctx, VB->Count );
}
else {
gl_index_shade_vertices( ctx, 0,
VB->Count - VB->Start,
VB->Eye + VB->Start,
VB->Normal + VB->Start,
VB->Findex + VB->Start );
if (ctx->Light.Model.TwoSide) {
gl_index_shade_vertices( ctx, 1,
VB->Count - VB->Start,
VB->Eye + VB->Start,
VB->Normal + VB->Start,
VB->Bindex + VB->Start );
}
}
}
}
static void fog_vertices( GLcontext *ctx )
{
struct vertex_buffer *VB = ctx->VB;
if (ctx->Visual->RGBAflag) {
gl_fog_color_vertices( ctx, VB->Count - VB->Start,
VB->Eye + VB->Start,
VB->Fcolor + VB->Start );
if (ctx->LightTwoSide) {
gl_fog_color_vertices( ctx, VB->Count - VB->Start,
VB->Eye + VB->Start,
VB->Bcolor + VB->Start );
}
}
else {
gl_fog_index_vertices( ctx, VB->Count - VB->Start,
VB->Eye + VB->Start,
VB->Findex + VB->Start );
if (ctx->LightTwoSide) {
gl_fog_index_vertices( ctx, VB->Count - VB->Start,
VB->Eye + VB->Start,
VB->Bindex + VB->Start );
}
}
}
void gl_transform_vb_part1( GLcontext *ctx, GLboolean allDone )
{
struct vertex_buffer *VB = ctx->VB;
#ifdef PROFILE
GLdouble t0 = gl_time();
#endif
ASSERT( VB->Count>0 );
if (VB->VertexSizeMask==VERTEX4_BIT) {
transform_points4( ctx, VB->Count - VB->Start,
VB->Obj + VB->Start, VB->Eye + VB->Start );
}
else {
transform_points3( ctx, VB->Count - VB->Start,
VB->Obj + VB->Start, VB->Eye + VB->Start );
}
if (ctx->NeedNormals) {
gl_xform_normals_3fv( VB->Count - VB->Start,
VB->Normal + VB->Start, ctx->ModelViewInv,
VB->Normal + VB->Start, ctx->Transform.Normalize );
}
#ifdef PROFILE
ctx->VertexTime += gl_time() - t0;
#endif
gl_transform_vb_part2( ctx, allDone );
}
void gl_transform_vb_part2( GLcontext *ctx, GLboolean allDone )
{
struct vertex_buffer *VB = ctx->VB;
#ifdef PROFILE
GLdouble t0 = gl_time();
#endif
ASSERT( VB->Count>0 );
if (ctx->Transform.AnyClip) {
GLuint result = userclip_vertices( ctx, VB->Count - VB->Start,
VB->Eye + VB->Start,
VB->ClipMask + VB->Start );
if (result==CLIP_ALL) {
gl_reset_vb( ctx, allDone );
return;
}
else if (result==CLIP_SOME) {
VB->ClipOrMask = CLIP_USER_BIT;
}
else {
VB->ClipAndMask = 0;
}
}
project_and_cliptest( ctx, VB->Count - VB->Start, VB->Eye + VB->Start,
VB->Clip + VB->Start, VB->ClipMask + VB->Start,
&VB->ClipOrMask, &VB->ClipAndMask );
if (VB->ClipAndMask) {
gl_reset_vb( ctx, allDone );
return;
}
if (ctx->Light.Enabled) {
shade_vertices(ctx);
}
if (ctx->Fog.Enabled && ctx->Hint.Fog!=GL_NICEST) {
fog_vertices(ctx);
}
if (ctx->Texture.Enabled || ctx->RenderMode==GL_FEEDBACK) {
if (ctx->Texture.TexGenEnabled) {
gl_texgen( ctx, VB->Count - VB->Start,
VB->Obj + VB->Start,
VB->Eye + VB->Start,
VB->Normal + VB->Start,
VB->TexCoord + VB->Start );
}
if (ctx->NewTextureMatrix) {
gl_analyze_texture_matrix(ctx);
}
if (ctx->TextureMatrixType!=MATRIX_IDENTITY) {
transform_texcoords( ctx, VB->Count - VB->Start,
VB->TexCoord + VB->Start );
}
}
viewport_map_vertices( ctx, VB->Count - VB->Start, VB->Clip + VB->Start,
VB->ClipOrMask ? VB->ClipMask + VB->Start : NULL,
VB->Win + VB->Start );
if (ctx->Driver.RasterSetup) {
(*ctx->Driver.RasterSetup)( ctx, 0, VB->Count );
}
#ifdef PROFILE
ctx->VertexTime += gl_time() - t0;
ctx->VertexCount += VB->Count - VB->Start;
#endif
if (!ctx->Driver.RenderVB || !(*ctx->Driver.RenderVB)(ctx,allDone)) {
gl_render_vb( ctx, allDone );
}
}
/* 当前文件是D:\Read\winpos.c*/

#ifdef PC_HEADER
#else
#endif
#ifdef GL_MESA_window_pos
#ifndef PC_HEADER
#endif
void gl_WindowPos4fMESA( GLcontext *ctx,
float x, float y, float z, float w )
{
gl_windowpos( ctx, x, y, z, w );
}
#else
void glWindowPos4fMESA( float x, float y, float z, float w )
{
float fx, fy;
glPushAttrib( GL_TRANSFORM_BIT | GL_VIEWPORT_BIT );
glMatrixMode( GL_PROJECTION );
glPushMatrix();
glLoadIdentity();
glMatrixMode( GL_MODELVIEW );
glPushMatrix();
glLoadIdentity();
glDepthRange( z, z );
glViewport( (int) x - 1, (int) y - 1, 2, 2 );
fx = x - (int) x;
fy = y - (int) y;
glRasterPos4f( fx, fy, 0.0, w );
glPopMatrix();
glMatrixMode( GL_PROJECTION );
glPopMatrix();
glPopAttrib();
}
#endif
/* 当前文件是D:\Read\xform.c*/

#ifdef PC_HEADER
#else
#endif
void gl_xform_points_4fv( GLuint n, float q[][4], const float m[16],
float p[][4] )
{
{
GLuint i;
float m0 = m[0],  m4 = m[4],  m8 = m[8],  m12 = m[12];
float m1 = m[1],  m5 = m[5],  m9 = m[9],  m13 = m[13];
if (m12==0.0F && m13==0.0F) {
for (i=0;i<n;i++) {
float p0 = p[i][0], p1 = p[i][1], p2 = p[i][2];
q[i][0] = m0 * p0 + m4  * p1 + m8 * p2;
q[i][1] = m1 * p0 + m5  * p1 + m9 * p2;
}
}
else {
for (i=0;i<n;i++) {
float p0 = p[i][0], p1 = p[i][1], p2 = p[i][2], p3 = p[i][3];
q[i][0] = m0 * p0 + m4  * p1 + m8 * p2 + m12 * p3;
q[i][1] = m1 * p0 + m5  * p1 + m9 * p2 + m13 * p3;
}
}
}
{
GLuint i;
float m2 = m[2],  m6 = m[6],  m10 = m[10],  m14 = m[14];
float m3 = m[3],  m7 = m[7],  m11 = m[11],  m15 = m[15];
if (m3==0.0F && m7==0.0F && m11==0.0F && m15==1.0F) {
for (i=0;i<n;i++) {
float p0 = p[i][0], p1 = p[i][1], p2 = p[i][2], p3 = p[i][3];
q[i][2] = m2 * p0 + m6 * p1 + m10 * p2 + m14 * p3;
q[i][3] = p3;
}
}
else {
for (i=0;i<n;i++) {
float p0 = p[i][0], p1 = p[i][1], p2 = p[i][2], p3 = p[i][3];
q[i][2] = m2 * p0 + m6 * p1 + m10 * p2 + m14 * p3;
q[i][3] = m3 * p0 + m7 * p1 + m11 * p2 + m15 * p3;
}
}
}
}
void gl_xform_points_3fv( GLuint n, float q[][4], const float m[16],
float p[][3] )
{
{
GLuint i;
float m0 = m[0],  m4 = m[4],  m8 = m[8],  m12 = m[12];
float m1 = m[1],  m5 = m[5],  m9 = m[9],  m13 = m[13];
for (i=0;i<n;i++) {
float p0 = p[i][0], p1 = p[i][1], p2 = p[i][2];
q[i][0] = m0 * p0 + m4  * p1 + m8 * p2 + m12;
q[i][1] = m1 * p0 + m5  * p1 + m9 * p2 + m13;
}
}
{
GLuint i;
float m2 = m[2],  m6 = m[6],  m10 = m[10],  m14 = m[14];
float m3 = m[3],  m7 = m[7],  m11 = m[11],  m15 = m[15];
if (m3==0.0F && m7==0.0F && m11==0.0F && m15==1.0F) {
for (i=0;i<n;i++) {
float p0 = p[i][0], p1 = p[i][1], p2 = p[i][2];
q[i][2] = m2 * p0 + m6 * p1 + m10 * p2 + m14;
q[i][3] = 1.0F;
}
}
else {
for (i=0;i<n;i++) {
float p0 = p[i][0], p1 = p[i][1], p2 = p[i][2];
q[i][2] = m2 * p0 + m6 * p1 + m10 * p2 + m14;
q[i][3] = m3 * p0 + m7 * p1 + m11 * p2 + m15;
}
}
}
}
#ifndef USE_ASM
void gl_xform_normals_3fv( GLuint n, float v[][3], const float m[16],
float u[][3], GLboolean normalize )
{
if (normalize) {
GLuint i;
float m0 = m[0],  m4 = m[4],  m8 = m[8];
float m1 = m[1],  m5 = m[5],  m9 = m[9];
float m2 = m[2],  m6 = m[6],  m10 = m[10];
for (i=0;i<n;i++) {
GLdouble tx, ty, tz;
{
float ux = u[i][0],  uy = u[i][1],  uz = u[i][2];
tx = ux * m0 + uy * m1 + uz * m2;
ty = ux * m4 + uy * m5 + uz * m6;
tz = ux * m8 + uy * m9 + uz * m10;
}
{
GLdouble len, scale;
len = GL_SQRT( tx*tx + ty*ty + tz*tz );
scale = (len>1E-30) ? (1.0 / len) : 1.0;
v[i][0] = tx * scale;
v[i][1] = ty * scale;
v[i][2] = tz * scale;
}
}
}
else {
GLuint i;
float m0 = m[0],  m4 = m[4],  m8 = m[8];
float m1 = m[1],  m5 = m[5],  m9 = m[9];
float m2 = m[2],  m6 = m[6],  m10 = m[10];
for (i=0;i<n;i++) {
float ux = u[i][0],  uy = u[i][1],  uz = u[i][2];
v[i][0] = ux * m0 + uy * m1 + uz * m2;
v[i][1] = ux * m4 + uy * m5 + uz * m6;
v[i][2] = ux * m8 + uy * m9 + uz * m10;
}
}
}
#endif
void gl_transform_vector( float u[4], const float v[4], const float m[16] )
{
float v0=v[0], v1=v[1], v2=v[2], v3=v[3];
#define M(row,col)  m[col*4+row]
u[0] = v0 * M(0,0) + v1 * M(1,0) + v2 * M(2,0) + v3 * M(3,0);
u[1] = v0 * M(0,1) + v1 * M(1,1) + v2 * M(2,1) + v3 * M(3,1);
u[2] = v0 * M(0,2) + v1 * M(1,2) + v2 * M(2,2) + v3 * M(3,2);
u[3] = v0 * M(0,3) + v1 * M(1,3) + v2 * M(2,3) + v3 * M(3,3);
#undef M
}
int main(int argc, char *argv[])
{
OSMesaContext ctx;
void *buffer;
int frames = 1000;
char *ppmFile = "mesa.ppm";
char *meshFile = "mesa.mesh";
char *intermediateResultsFile = "mesa.log";
int i;
for (i=1; i<argc; i++) {
if (strcmp(argv[i],"-frames")==0) {
if (i+1 >= argc) {
printf("Error:  missing argument after -frames\n");
return 1;
}
frames = atoi(argv[i+1]);
i++;
if (frames <= 0) {
printf("Error:  number of frames must be >= 1\n");
return 1;
}
}
else if (strcmp(argv[i],"-ppmfile")==0) {
if (i+1 >= argc) {
printf("Error:  missing argument after -ppmfile\n");
return 1;
}
ppmFile = argv[i+1];
i++;
}
else if (strcmp(argv[i],"-meshfile")==0) {
if (i+1 >= argc) {
printf("Error:  missing argument after -meshfile\n");
return 1;
}
meshFile = argv[i+1];
i++;
}
else {
printf("Error:  unexpect command line parameter: %s\n", argv[i]);
return 1;
}
}
ctx = OSMesaCreateContext( GL_RGBA, NULL );
buffer = malloc( WIDTH * HEIGHT * 4 );
OSMesaMakeCurrent( ctx, buffer, GL_UNSIGNED_BYTE, WIDTH, HEIGHT );
Init();
ReadMesh(meshFile);
Render( frames, WIDTH, HEIGHT, buffer );
WriteImage( ppmFile, WIDTH, HEIGHT, buffer );
free( buffer );
OSMesaDestroyContext( ctx );
return 0;
}
static void init_exec_pointers( struct gl_api_table *table )
{
table->Accum = gl_Accum;
table->AlphaFunc = gl_AlphaFunc;
table->AreTexturesResident = gl_AreTexturesResident;
table->ArrayElement = gl_ArrayElement;
table->Begin = gl_Begin;
table->BindTexture = gl_BindTexture;
table->Bitmap = gl_Bitmap;
table->BlendColor = gl_BlendColor;
table->BlendEquation = gl_BlendEquation;
table->BlendFunc = gl_BlendFunc;
table->CallList = gl_CallList;
table->CallLists = gl_CallLists;
table->Clear = gl_Clear;
table->ClearAccum = gl_ClearAccum;
table->ClearColor = gl_ClearColor;
table->ClearDepth = gl_ClearDepth;
table->ClearIndex = gl_ClearIndex;
table->ClearStencil = gl_ClearStencil;
table->ClipPlane = gl_ClipPlane;
table->Color3f = gl_Color3f;
table->Color3fv = gl_Color3fv;
table->Color4f = gl_Color4f;
table->Color4fv = gl_Color4fv;
table->Color4ub = gl_Color4ub;
table->Color4ubv = gl_Color4ubv;
table->ColorMask = gl_ColorMask;
table->ColorMaterial = gl_ColorMaterial;
table->ColorPointer = gl_ColorPointer;
table->ColorTable = gl_ColorTable;
table->ColorSubTable = gl_ColorSubTable;
table->CopyPixels = gl_CopyPixels;
table->CopyTexImage1D = gl_CopyTexImage1D;
table->CopyTexImage2D = gl_CopyTexImage2D;
table->CopyTexSubImage1D = gl_CopyTexSubImage1D;
table->CopyTexSubImage2D = gl_CopyTexSubImage2D;
table->CopyTexSubImage3DEXT = gl_CopyTexSubImage3DEXT;
table->CullFace = gl_CullFace;
table->DeleteLists = gl_DeleteLists;
table->DeleteTextures = gl_DeleteTextures;
table->DepthFunc = gl_DepthFunc;
table->DepthMask = gl_DepthMask;
table->DepthRange = gl_DepthRange;
table->Disable = gl_Disable;
table->DisableClientState = gl_DisableClientState;
table->DrawArrays = gl_DrawArrays;
table->DrawBuffer = gl_DrawBuffer;
table->DrawElements = gl_DrawElements;
table->DrawPixels = gl_DrawPixels;
table->EdgeFlag = gl_EdgeFlag;
table->EdgeFlagPointer = gl_EdgeFlagPointer;
table->Enable = gl_Enable;
table->EnableClientState = gl_EnableClientState;
table->End = gl_End;
table->EndList = gl_EndList;
table->EvalCoord1f = gl_EvalCoord1f;
table->EvalCoord2f = gl_EvalCoord2f;
table->EvalMesh1 = gl_EvalMesh1;
table->EvalMesh2 = gl_EvalMesh2;
table->EvalPoint1 = gl_EvalPoint1;
table->EvalPoint2 = gl_EvalPoint2;
table->FeedbackBuffer = gl_FeedbackBuffer;
table->Finish = gl_Finish;
table->Flush = gl_Flush;
table->Fogfv = gl_Fogfv;
table->FrontFace = gl_FrontFace;
table->Frustum = gl_Frustum;
table->GenLists = gl_GenLists;
table->GenTextures = gl_GenTextures;
table->GetBooleanv = gl_GetBooleanv;
table->GetClipPlane = gl_GetClipPlane;
table->GetColorTable = gl_GetColorTable;
table->GetColorTableParameteriv = gl_GetColorTableParameteriv;
table->GetDoublev = gl_GetDoublev;
table->GetError = gl_GetError;
table->GetFloatv = gl_GetFloatv;
table->GetIntegerv = gl_GetIntegerv;
table->GetPointerv = gl_GetPointerv;
table->GetLightfv = gl_GetLightfv;
table->GetLightiv = gl_GetLightiv;
table->GetMapdv = gl_GetMapdv;
table->GetMapfv = gl_GetMapfv;
table->GetMapiv = gl_GetMapiv;
table->GetMaterialfv = gl_GetMaterialfv;
table->GetMaterialiv = gl_GetMaterialiv;
table->GetPixelMapfv = gl_GetPixelMapfv;
table->GetPixelMapuiv = gl_GetPixelMapuiv;
table->GetPixelMapusv = gl_GetPixelMapusv;
table->GetPolygonStipple = gl_GetPolygonStipple;
table->GetString = gl_GetString;
table->GetTexEnvfv = gl_GetTexEnvfv;
table->GetTexEnviv = gl_GetTexEnviv;
table->GetTexGendv = gl_GetTexGendv;
table->GetTexGenfv = gl_GetTexGenfv;
table->GetTexGeniv = gl_GetTexGeniv;
table->GetTexImage = gl_GetTexImage;
table->GetTexLevelParameterfv = gl_GetTexLevelParameterfv;
table->GetTexLevelParameteriv = gl_GetTexLevelParameteriv;
table->GetTexParameterfv = gl_GetTexParameterfv;
table->GetTexParameteriv = gl_GetTexParameteriv;
table->Hint = gl_Hint;
table->Indexf = gl_Indexf;
table->Indexi = gl_Indexi;
table->IndexMask = gl_IndexMask;
table->IndexPointer = gl_IndexPointer;
table->InitNames = gl_InitNames;
table->InterleavedArrays = gl_InterleavedArrays;
table->IsEnabled = gl_IsEnabled;
table->IsList = gl_IsList;
table->IsTexture = gl_IsTexture;
table->LightModelfv = gl_LightModelfv;
table->Lightfv = gl_Lightfv;
table->LineStipple = gl_LineStipple;
table->LineWidth = gl_LineWidth;
table->ListBase = gl_ListBase;
table->LoadIdentity = gl_LoadIdentity;
table->LoadMatrixf = gl_LoadMatrixf;
table->LoadName = gl_LoadName;
table->LogicOp = gl_LogicOp;
table->Map1f = gl_Map1f;
table->Map2f = gl_Map2f;
table->MapGrid1f = gl_MapGrid1f;
table->MapGrid2f = gl_MapGrid2f;
table->Materialfv = gl_Materialfv;
table->MatrixMode = gl_MatrixMode;
table->MultMatrixf = gl_MultMatrixf;
table->NewList = gl_NewList;
table->Normal3f = gl_Normal3f;
table->NormalPointer = gl_NormalPointer;
table->Normal3fv = gl_Normal3fv;
table->Ortho = gl_Ortho;
table->PassThrough = gl_PassThrough;
table->PixelMapfv = gl_PixelMapfv;
table->PixelStorei = gl_PixelStorei;
table->PixelTransferf = gl_PixelTransferf;
table->PixelZoom = gl_PixelZoom;
table->PointSize = gl_PointSize;
table->PolygonMode = gl_PolygonMode;
table->PolygonOffset = gl_PolygonOffset;
table->PolygonStipple = gl_PolygonStipple;
table->PopAttrib = gl_PopAttrib;
table->PopClientAttrib = gl_PopClientAttrib;
table->PopMatrix = gl_PopMatrix;
table->PopName = gl_PopName;
table->PrioritizeTextures = gl_PrioritizeTextures;
table->PushAttrib = gl_PushAttrib;
table->PushClientAttrib = gl_PushClientAttrib;
table->PushMatrix = gl_PushMatrix;
table->PushName = gl_PushName;
table->RasterPos4f = gl_RasterPos4f;
table->ReadBuffer = gl_ReadBuffer;
table->ReadPixels = gl_ReadPixels;
table->Rectf = gl_Rectf;
table->RenderMode = gl_RenderMode;
table->Rotatef = gl_Rotatef;
table->Scalef = gl_Scalef;
table->Scissor = gl_Scissor;
table->SelectBuffer = gl_SelectBuffer;
table->ShadeModel = gl_ShadeModel;
table->StencilFunc = gl_StencilFunc;
table->StencilMask = gl_StencilMask;
table->StencilOp = gl_StencilOp;
table->TexCoord2f = gl_TexCoord2f;
table->TexCoord4f = gl_TexCoord4f;
table->TexCoordPointer = gl_TexCoordPointer;
table->TexEnvfv = gl_TexEnvfv;
table->TexGenfv = gl_TexGenfv;
table->TexImage1D = gl_TexImage1D;
table->TexImage2D = gl_TexImage2D;
table->TexImage3DEXT = gl_TexImage3DEXT;
table->TexSubImage1D = gl_TexSubImage1D;
table->TexSubImage2D = gl_TexSubImage2D;
table->TexSubImage3DEXT = gl_TexSubImage3DEXT;
table->PointParameterfvEXT = gl_PointParameterfvEXT;
table->TexParameterfv = gl_TexParameterfv;
table->Translatef = gl_Translatef;
table->Vertex2f = gl_vertex2f_nop;
table->Vertex3f = gl_vertex3f_nop;
table->Vertex4f = gl_vertex4f_nop;
table->Vertex3fv = gl_vertex3fv_nop;
table->VertexPointer = gl_VertexPointer;
table->Viewport = gl_Viewport;
table->WindowPos4fMESA = gl_WindowPos4fMESA;
table->ResizeBuffersMESA = gl_ResizeBuffersMESA;
}
static void init_dlist_pointers( struct gl_api_table *table )
{
table->Accum = gl_save_Accum;
table->AlphaFunc = gl_save_AlphaFunc;
table->AreTexturesResident = gl_AreTexturesResident;
table->ArrayElement = gl_save_ArrayElement;
table->Begin = gl_save_Begin;
table->BindTexture = gl_save_BindTexture;
table->Bitmap = gl_save_Bitmap;
table->BlendColor = gl_save_BlendColor;
table->BlendEquation = gl_save_BlendEquation;
table->BlendFunc = gl_save_BlendFunc;
table->CallList = gl_save_CallList;
table->CallLists = gl_save_CallLists;
table->Clear = gl_save_Clear;
table->ClearAccum = gl_save_ClearAccum;
table->ClearColor = gl_save_ClearColor;
table->ClearDepth = gl_save_ClearDepth;
table->ClearIndex = gl_save_ClearIndex;
table->ClearStencil = gl_save_ClearStencil;
table->ClipPlane = gl_save_ClipPlane;
table->Color3f = gl_save_Color3f;
table->Color3fv = gl_save_Color3fv;
table->Color4f = gl_save_Color4f;
table->Color4fv = gl_save_Color4fv;
table->Color4ub = gl_save_Color4ub;
table->Color4ubv = gl_save_Color4ubv;
table->ColorMask = gl_save_ColorMask;
table->ColorMaterial = gl_save_ColorMaterial;
table->ColorPointer = gl_ColorPointer;
table->ColorTable = gl_save_ColorTable;
table->ColorSubTable = gl_save_ColorSubTable;
table->CopyPixels = gl_save_CopyPixels;
table->CopyTexImage1D = gl_save_CopyTexImage1D;
table->CopyTexImage2D = gl_save_CopyTexImage2D;
table->CopyTexSubImage1D = gl_save_CopyTexSubImage1D;
table->CopyTexSubImage2D = gl_save_CopyTexSubImage2D;
table->CopyTexSubImage3DEXT = gl_save_CopyTexSubImage3DEXT;
table->CullFace = gl_save_CullFace;
table->DeleteLists = gl_DeleteLists;
table->DeleteTextures = gl_DeleteTextures;
table->DepthFunc = gl_save_DepthFunc;
table->DepthMask = gl_save_DepthMask;
table->DepthRange = gl_save_DepthRange;
table->Disable = gl_save_Disable;
table->DisableClientState = gl_DisableClientState;
table->DrawArrays = gl_save_DrawArrays;
table->DrawBuffer = gl_save_DrawBuffer;
table->DrawElements = gl_save_DrawElements;
table->DrawPixels = gl_DrawPixels;
table->EdgeFlag = gl_save_EdgeFlag;
table->EdgeFlagPointer = gl_EdgeFlagPointer;
table->Enable = gl_save_Enable;
table->EnableClientState = gl_EnableClientState;
table->End = gl_save_End;
table->EndList = gl_EndList;
table->EvalCoord1f = gl_save_EvalCoord1f;
table->EvalCoord2f = gl_save_EvalCoord2f;
table->EvalMesh1 = gl_save_EvalMesh1;
table->EvalMesh2 = gl_save_EvalMesh2;
table->EvalPoint1 = gl_save_EvalPoint1;
table->EvalPoint2 = gl_save_EvalPoint2;
table->FeedbackBuffer = gl_FeedbackBuffer;
table->Finish = gl_Finish;
table->Flush = gl_Flush;
table->Fogfv = gl_save_Fogfv;
table->FrontFace = gl_save_FrontFace;
table->Frustum = gl_save_Frustum;
table->GenLists = gl_GenLists;
table->GenTextures = gl_GenTextures;
table->GetBooleanv = gl_GetBooleanv;
table->GetClipPlane = gl_GetClipPlane;
table->GetColorTable = gl_GetColorTable;
table->GetColorTableParameteriv = gl_GetColorTableParameteriv;
table->GetDoublev = gl_GetDoublev;
table->GetError = gl_GetError;
table->GetFloatv = gl_GetFloatv;
table->GetIntegerv = gl_GetIntegerv;
table->GetString = gl_GetString;
table->GetLightfv = gl_GetLightfv;
table->GetLightiv = gl_GetLightiv;
table->GetMapdv = gl_GetMapdv;
table->GetMapfv = gl_GetMapfv;
table->GetMapiv = gl_GetMapiv;
table->GetMaterialfv = gl_GetMaterialfv;
table->GetMaterialiv = gl_GetMaterialiv;
table->GetPixelMapfv = gl_GetPixelMapfv;
table->GetPixelMapuiv = gl_GetPixelMapuiv;
table->GetPixelMapusv = gl_GetPixelMapusv;
table->GetPointerv = gl_GetPointerv;
table->GetPolygonStipple = gl_GetPolygonStipple;
table->GetTexEnvfv = gl_GetTexEnvfv;
table->GetTexEnviv = gl_GetTexEnviv;
table->GetTexGendv = gl_GetTexGendv;
table->GetTexGenfv = gl_GetTexGenfv;
table->GetTexGeniv = gl_GetTexGeniv;
table->GetTexImage = gl_GetTexImage;
table->GetTexLevelParameterfv = gl_GetTexLevelParameterfv;
table->GetTexLevelParameteriv = gl_GetTexLevelParameteriv;
table->GetTexParameterfv = gl_GetTexParameterfv;
table->GetTexParameteriv = gl_GetTexParameteriv;
table->Hint = gl_save_Hint;
table->IndexMask = gl_save_IndexMask;
table->Indexf = gl_save_Indexf;
table->Indexi = gl_save_Indexi;
table->IndexPointer = gl_IndexPointer;
table->InitNames = gl_save_InitNames;
table->InterleavedArrays = gl_save_InterleavedArrays;
table->IsEnabled = gl_IsEnabled;
table->IsTexture = gl_IsTexture;
table->IsList = gl_IsList;
table->LightModelfv = gl_save_LightModelfv;
table->Lightfv = gl_save_Lightfv;
table->LineStipple = gl_save_LineStipple;
table->LineWidth = gl_save_LineWidth;
table->ListBase = gl_save_ListBase;
table->LoadIdentity = gl_save_LoadIdentity;
table->LoadMatrixf = gl_save_LoadMatrixf;
table->LoadName = gl_save_LoadName;
table->LogicOp = gl_save_LogicOp;
table->Map1f = gl_save_Map1f;
table->Map2f = gl_save_Map2f;
table->MapGrid1f = gl_save_MapGrid1f;
table->MapGrid2f = gl_save_MapGrid2f;
table->Materialfv = gl_save_Materialfv;
table->MatrixMode = gl_save_MatrixMode;
table->MultMatrixf = gl_save_MultMatrixf;
table->NewList = gl_save_NewList;
table->Normal3f = gl_save_Normal3f;
table->Normal3fv = gl_save_Normal3fv;
table->NormalPointer = gl_NormalPointer;
table->Ortho = gl_save_Ortho;
table->PointParameterfvEXT = gl_save_PointParameterfvEXT;
table->PassThrough = gl_save_PassThrough;
table->PixelMapfv = gl_save_PixelMapfv;
table->PixelStorei = gl_PixelStorei;
table->PixelTransferf = gl_save_PixelTransferf;
table->PixelZoom = gl_save_PixelZoom;
table->PointSize = gl_save_PointSize;
table->PolygonMode = gl_save_PolygonMode;
table->PolygonOffset = gl_save_PolygonOffset;
table->PolygonStipple = gl_save_PolygonStipple;
table->PopAttrib = gl_save_PopAttrib;
table->PopClientAttrib = gl_PopClientAttrib;
table->PopMatrix = gl_save_PopMatrix;
table->PopName = gl_save_PopName;
table->PrioritizeTextures = gl_save_PrioritizeTextures;
table->PushAttrib = gl_save_PushAttrib;
table->PushClientAttrib = gl_PushClientAttrib;
table->PushMatrix = gl_save_PushMatrix;
table->PushName = gl_save_PushName;
table->RasterPos4f = gl_save_RasterPos4f;
table->ReadBuffer = gl_save_ReadBuffer;
table->ReadPixels = gl_ReadPixels;
table->Rectf = gl_save_Rectf;
table->RenderMode = gl_RenderMode;
table->Rotatef = gl_save_Rotatef;
table->Scalef = gl_save_Scalef;
table->Scissor = gl_save_Scissor;
table->SelectBuffer = gl_SelectBuffer;
table->ShadeModel = gl_save_ShadeModel;
table->StencilFunc = gl_save_StencilFunc;
table->StencilMask = gl_save_StencilMask;
table->StencilOp = gl_save_StencilOp;
table->TexCoord2f = gl_save_TexCoord2f;
table->TexCoord4f = gl_save_TexCoord4f;
table->TexCoordPointer = gl_TexCoordPointer;
table->TexEnvfv = gl_save_TexEnvfv;
table->TexGenfv = gl_save_TexGenfv;
table->TexImage1D = gl_save_TexImage1D;
table->TexImage2D = gl_save_TexImage2D;
table->TexImage3DEXT = gl_save_TexImage3DEXT;
table->TexSubImage1D = gl_save_TexSubImage1D;
table->TexSubImage2D = gl_save_TexSubImage2D;
table->TexSubImage3DEXT = gl_save_TexSubImage3DEXT;
table->TexParameterfv = gl_save_TexParameterfv;
table->Translatef = gl_save_Translatef;
table->Vertex2f = gl_save_Vertex2f;
table->Vertex3f = gl_save_Vertex3f;
table->Vertex4f = gl_save_Vertex4f;
table->Vertex3fv = gl_save_Vertex3fv;
table->VertexPointer = gl_VertexPointer;
table->Viewport = gl_save_Viewport;
table->WindowPos4fMESA = gl_save_WindowPos4fMESA;
table->ResizeBuffersMESA = gl_ResizeBuffersMESA;
}