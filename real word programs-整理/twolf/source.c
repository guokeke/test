/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 213 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int size_t;
#line 14 "/usr/include/sys/lock.h"
typedef void *_LOCK_T;
#line 15 "/usr/include/sys/_types.h"
typedef long long _off64_t;
#line 18 "/usr/include/sys/_types.h"
typedef int _ssize_t;
#line 354 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int wint_t;
#line 27 "/usr/include/sys/_types.h"
union __anonunion___value_2 {
	wint_t __wch;
	unsigned char __wchb[4];
};
#line 27 "/usr/include/sys/_types.h"
struct __anonstruct__mbstate_t_1 {
	int __count;
	union __anonunion___value_2 __value;
};
#line 27 "/usr/include/sys/_types.h"
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
#line 37 "/usr/include/sys/_types.h"
typedef _LOCK_T _flock_t;
#line 19 "/usr/include/sys/reent.h"
typedef unsigned long __ULong;
#line 40 "/usr/include/sys/reent.h"
struct _Bigint {
	struct _Bigint *_next;
	int _k;
	int _maxwds;
	int _sign;
	int _wds;
	__ULong _x[1];
};
#line 48 "/usr/include/sys/reent.h"
struct __tm {
	int __tm_sec;
	int __tm_min;
	int __tm_hour;
	int __tm_mday;
	int __tm_mon;
	int __tm_year;
	int __tm_wday;
	int __tm_yday;
	int __tm_isdst;
};
#line 67 "/usr/include/sys/reent.h"
struct _on_exit_args {
	void *_fnargs[32];
	void *_dso_handle[32];
	__ULong _fntypes;
	__ULong _is_cxa;
};
#line 85 "/usr/include/sys/reent.h"
struct _atexit {
	struct _atexit *_next;
	int _ind;
	void(*_fns[32])(void);
	struct _on_exit_args _on_exit_args;
};
#line 101 "/usr/include/sys/reent.h"
struct __sbuf {
	unsigned char *_base;
	int _size;
};
#line 111 "/usr/include/sys/reent.h"
typedef long _fpos_t;
#line 115 "/usr/include/sys/reent.h"
typedef _off64_t _fpos64_t;
#line 166
struct _reent;
#line 214 "/usr/include/sys/reent.h"
struct __sFILE64 {
	unsigned char *_p;
	int _r;
	int _w;
	short _flags;
	short _file;
	struct __sbuf _bf;
	int _lbfsize;
	struct _reent *_data;
	void *_cookie;
	_ssize_t(__attribute__((__cdecl__)) (*_read))(void *_cookie, char *_buf, int _n);
	_ssize_t(__attribute__((__cdecl__)) (*_write))(void *_cookie, char const   *_buf,
		int _n);
	_fpos_t(__attribute__((__cdecl__)) (*_seek))(void *_cookie, _fpos_t _offset,
		int _whence);
	int (__attribute__((__cdecl__)) (*_close))(void *_cookie);
	struct __sbuf _ub;
	unsigned char *_up;
	int _ur;
	unsigned char _ubuf[3];
	unsigned char _nbuf[1];
	struct __sbuf _lb;
	int _blksize;
	int _flags2;
	_off64_t _offset;
	_fpos64_t(__attribute__((__cdecl__)) (*_seek64))(void *_cookie, _fpos64_t _offset,
		int _whence);
	_flock_t _lock;
};
#line 257 "/usr/include/sys/reent.h"
typedef struct __sFILE64 __FILE;
#line 262 "/usr/include/sys/reent.h"
struct _glue {
	struct _glue *_next;
	int _niobs;
	__FILE *_iobs;
};
#line 290 "/usr/include/sys/reent.h"
struct _rand48 {
	unsigned short _seed[3];
	unsigned short _mult[3];
	unsigned short _add;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__reent_4 {
	unsigned int _unused_rand;
	char *_strtok_last;
	char _asctime_buf[26];
	struct __tm _localtime_buf;
	int _gamma_signgam;
	unsigned long long _rand_next;
	struct _rand48 _r48;
	_mbstate_t _mblen_state;
	_mbstate_t _mbtowc_state;
	_mbstate_t _wctomb_state;
	char _l64a_buf[8];
	char _signal_buf[24];
	int _getdate_err;
	_mbstate_t _mbrlen_state;
	_mbstate_t _mbrtowc_state;
	_mbstate_t _mbsrtowcs_state;
	_mbstate_t _wcrtomb_state;
	_mbstate_t _wcsrtombs_state;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__unused_5 {
	unsigned char *_nextf[30];
	unsigned int _nmalloc[30];
};
#line 565 "/usr/include/sys/reent.h"
union __anonunion__new_3 {
	struct __anonstruct__reent_4 _reent;
	struct __anonstruct__unused_5 _unused;
};
#line 565 "/usr/include/sys/reent.h"
struct _reent {
	int _errno;
	__FILE *_stdin;
	__FILE *_stdout;
	__FILE *_stderr;
	int _inc;
	char _emergency[25];
	int _current_category;
	char const   *_current_locale;
	int __sdidinit;
	void (__attribute__((__cdecl__)) (*__cleanup))(struct _reent *);
	struct _Bigint *_result;
	int _result_k;
	struct _Bigint *_p5s;
	struct _Bigint **_freelist;
	int _cvtlen;
	char *_cvtbuf;
	union __anonunion__new_3 _new;
	struct _atexit *_atexit;
	struct _atexit _atexit0;
	void(**_sig_func)(int);
	struct _glue __sglue;
	__FILE __sf[3];
};
#line 50 "/usr/include/stdio.h"
typedef __FILE FILE;
#line 44 "standard.h"
struct blockbox {
	int bxcenter;
	int bycenter;
	int bleft;
	int bright;
	int bbottom;
	int btop;
	int bheight;
	int blength;
	int desire;
	int oldsize;
	int newsize;
	int bclass;
	int borient;
};
#line 44 "standard.h"
typedef struct blockbox *BBOXPTR;
#line 60 "standard.h"
struct netbox {
	struct netbox *nterm;
	int terminal;
	int extint;
	int xpos;
	int ypos;
	int newx;
	int newy;
	int row;
	int cell;
	int net;
	char pinloc;
	char unequiv;
	char flag;
	char layer;
};
#line 60 "standard.h"
typedef struct netbox *NBOXPTR;
#line 60 "standard.h"
typedef struct netbox NBOX;
#line 78 "standard.h"
struct termbox {
	struct termbox *nextterm;
	NBOXPTR termptr;
	int cellterm;
	int ei;
	int net;
	int txpos[2];
	int typos[2];
	int ue;
};
#line 78 "standard.h"
typedef struct termbox *TEBOXPTR;
#line 78 "standard.h"
typedef struct termbox TEBOX;
#line 89 "standard.h"
struct tilebox {
	int left;
	int right;
	int bottom;
	int top;
	TEBOXPTR termsptr;
};
#line 89 "standard.h"
typedef struct tilebox *TIBOXPTR;
#line 99 "standard.h"
struct cellbox {
	char *cname;
	char corient;
	char orflag;
	int cxcenter;
	int cycenter;
	int cclass;
	int cheight;
	int clength;
	int border;
	int cblock;
	int numterms;
	int padside;
	TIBOXPTR tileptr;
};
#line 99 "standard.h"
typedef struct cellbox *CBOXPTR;
#line 117 "standard.h"
struct dimbox {
	NBOXPTR netptr;
	char *name;
	char dflag;
	char feedflag;
	char ignore;
	int old_total;
	int new_total;
	int xmin;
	int newxmin;
	int xmax;
	int newxmax;
	int ymin;
	int newymin;
	int ymax;
	int newymax;
	int Lnum;
	int newLnum;
	int Rnum;
	int newRnum;
	int Bnum;
	int newBnum;
	int Tnum;
	int newTnum;
	int numpins;
	float Vweight;
	float Hweight;
};
#line 117 "standard.h"
typedef struct dimbox *DBOXPTR;
#line 149 "standard.h"
struct hash {
	char *hname;
	int hnum;
	struct hash *hnext;
};
#line 149 "standard.h"
typedef struct hash *HASHPTR;
#line 157 "standard.h"
struct rowbox {
	int startx;
	int endx;
	int endx1;
	int startx2;
	int ypos;
	int desiredL;
};
#line 157 "standard.h"
typedef struct rowbox ROWBOX;
#line 166 "standard.h"
struct binbox {
	int left;
	int right;
	int *cell;
	int penalty;
	int nupenalty;
};
#line 166 "standard.h"
typedef struct binbox BINBOX;
#line 175
struct densitybox;
#line 175 "standard.h"
struct changrdbox {
	NBOXPTR netptr;
	int tracks;
	int ntracks;
	int SegType;
	int nSegType;
	struct changrdbox *prevgrd;
	struct changrdbox *nprevgrd;
	struct changrdbox *nextgrd;
	struct changrdbox *nnextgrd;
	struct densitybox *dptr;
};
#line 175 "standard.h"
typedef struct changrdbox *CHANGRDPTR;
#line 4 "addimp.c"
struct ipbox {
	struct ipbox *npin;
	int ixpos;
	int iypos;
	int layer;
	char *ipname;
};
#line 4 "addimp.c"
typedef struct ipbox *IPBOXPTR;
#line 12 "addimp.c"
struct ibox {
	struct ibox *niptr;
	int iactive;
	int aveXpos;
	int icell;
	IPBOXPTR iptr;
};
#line 12 "addimp.c"
typedef struct ibox *IBOXPTR;
#line 2 "buildimp.c"
typedef struct ipbox IPBOX;
#line 10 "buildimp.c"
typedef struct ibox IBOX;
#line 60 "standard.h"
typedef struct netbox NBOX___0;
#line 175 "standard.h"
typedef struct changrdbox CHANGRDBOX___0;
#line 5 "groute.h"
struct tgridbox {
	CHANGRDPTR up;
	CHANGRDPTR down;
};
#line 5 "groute.h"
typedef struct tgridbox *TGRIDPTR;
#line 5 "groute.h"
typedef struct tgridbox TGRIDBOX;
#line 12 "groute.h"
struct densitybox {
	CHANGRDPTR grdptr;
	struct densitybox *next;
	struct densitybox *nnext;
	struct densitybox *back;
	struct densitybox *nback;
};
#line 166 "standard.h"
typedef struct binbox *BINPTR;
#line 1 "route.h"
struct edgeBox {
	int group1;
	int group2;
	int cost;
	int marked;
	int poison;
	int done;
};
#line 1 "route.h"
typedef struct edgeBox edgeBox;
#line 22 "route.h"
struct csPinBox {
	int pin;
	int xloc;
	int yloc;
	int top;
};
#line 22 "route.h"
typedef struct csPinBox csPinBox;
#line 31 "route.h"
struct csGroup {
	int extint;
	int aveX;
	int aveY;
	int poison;
	int edge1;
	int edge2;
	int unequiv;
	int block;
	int check;
	int numPins;
	int pinLimit;
	int flag;
	csPinBox *pinArray;
};
#line 31 "route.h"
typedef struct csGroup csGroup;
#line 9 "config1.c"
struct macrobox {
	int mx;
	int my;
};
#line 9 "config1.c"
typedef struct macrobox MACROBOX;
#line 44 "standard.h"
typedef struct blockbox BBOX;
#line 78 "standard.h"
struct termbox___0 {
	struct termbox *nextterm;
	NBOXPTR termptr;
	int cellterm;
	int ei;
	int net;
	int txpos[2];
	int typos[2];
	int ue;
};
#line 78 "standard.h"
typedef struct termbox___0 *TEBOXPTR___0;
#line 89 "standard.h"
struct tilebox___0 {
	int left;
	int right;
	int bottom;
	int top;
	TEBOXPTR___0 termsptr;
};
#line 89 "standard.h"
typedef struct tilebox___0 *TIBOXPTR___0;
#line 99 "standard.h"
struct cellbox___0 {
	char *cname;
	char corient;
	char orflag;
	int cxcenter;
	int cycenter;
	int cclass;
	int cheight;
	int clength;
	int border;
	int cblock;
	int numterms;
	int padside;
	TIBOXPTR___0 tileptr;
};
#line 99 "standard.h"
typedef struct cellbox___0 *CBOXPTR___0;
#line 89 "standard.h"
typedef struct tilebox TIBOX;
#line 99 "standard.h"
typedef struct cellbox CBOX;
#line 22 "groute.h"
struct segbox {
	int channel;
	int pin1;
	int pin2;
	CHANGRDPTR pin1ptr;
	CHANGRDPTR pin2ptr;
};
#line 22 "groute.h"
typedef struct segbox *SEGBOXPTR;
#line 32 "groute.h"
struct switchbox {
	int net;
	char nflag;
	char ncurrent;
	char nswYorN;
	char current;
	char swYorN;
	int key;
	int nkey;
	SEGBOXPTR ntop;
	SEGBOXPTR nbot;
	SEGBOXPTR top;
	SEGBOXPTR bot;
};
#line 32 "groute.h"
typedef struct switchbox SWITCHBOX;
#line 12 "groute.h"
typedef struct densitybox *DENSITYPTR;
#line 12 "groute.h"
typedef struct densitybox DENSITYBOX;
#line 12 "route.h"
struct chkBox {
	int lowx;
	int highx;
	int ming;
	int maxg;
	int chky;
};
#line 12 "route.h"
typedef struct chkBox chkBox;
#line 32 "grdcell.c"
struct impbox {
	int x;
	struct impbox *next_pin;
};
#line 32 "grdcell.c"
typedef struct impbox IMPBOX;
#line 37 "grdcell.c"
struct celltype {
	struct celltype *next_cell;
	char *name;
	struct impbox *first_imp;
};
#line 37 "grdcell.c"
typedef struct celltype CELLTYPE;
#line 149 "standard.h"
typedef struct hash HASHBOX;
#line 5 "mergplist.c"
struct tmpmerg {
	int value;
	int next;
	int first;
};
#line 5 "mergplist.c"
typedef struct tmpmerg TEMPMERG;
#line 9 "mt.h"
struct MT {
	int sp;
	int stk[100][3][3];
	int t[3][3];
	int ti[3][3];
};
#line 9 "mt.h"
typedef struct MT MT;
#line 17 "mt.c"
enum __anonenum_Bool_7 {
	false = 0,
	true = 1
};
#line 17 "mt.c"
typedef enum __anonenum_Bool_7 Bool;
#line 44 "/usr/include/cygwin/signal.h"
#pragma pack(push,4)
#line 101
#pragma pack(pop)
#line 117 "standard.h"
typedef struct dimbox DBOX;
#line 1 "route.h"
typedef struct edgeBox *edgeBptr;
#line 22 "groute.h"
typedef struct segbox SEGBOX;
#line 44 "standard.h"
struct blockbox___0 {
	int bxcenter;
	int bycenter;
	int bleft;
	int bright;
	int bbottom;
	int btop;
	int bheight;
	int blength;
	int desire;
	int oldsize;
	int newsize;
	int bclass;
	int borient;
};
#line 44 "standard.h"
typedef struct blockbox___0 *BBOXPTR___0;
#line 8 "xcompact.c"
struct int2 {
	int sleft;
	int srite;
};
#line 8 "xcompact.c"
typedef struct int2 INT2;
#line 1 "acceptt.o"
#pragma merger(0,"./acceptt.i","")
#line 5 "acceptt.c"
float table1[1024];
#line 5
float table2[1024];
#line 5
float table3[1024];
#line 5
float T;
#line 6
float cost_scale_factor;
#line 25
int Yacm_random(void);
#line 9 "acceptt.c"
int acceptt(int delta_cost)
{
	int truth;
	float fred;
	register unsigned int fract;
	int tmp;
	int tmp___0;

	{
#line 16
		fred = ((float)delta_cost * cost_scale_factor) / T;
#line 18
		if ((double)fred >= 0.0) {
#line 19
			truth = 1;
		}
		else {
#line 21
			if ((double)fred < -80.0) {
#line 22
				truth = 0;
			}
			else {
#line 24
				if ((double)fred > -0.0001) {
#line 25
					tmp = Yacm_random();
#line 25
					if (1.0 + (double)fred > (double)((float)tmp / (float)2147483647)) {
#line 26
						truth = 1;
					}
					else {
#line 29
						truth = 0;
					}
				}
				else {
#line 33
					fract = (unsigned int)((int)((double)(-fred) * 8388608.0));
#line 34
					tmp___0 = Yacm_random();
#line 34
					if ((table1[(fract >> 20) & 1023U] * table2[(fract >> 10) & 1023U]) * table3[fract & 1023U] > (float)tmp___0 / (float)2147483647) {
#line 38
						truth = 1;
					}
					else {
#line 41
						truth = 0;
					}
				}
			}
		}
#line 45
		return (truth);
	}
}
#line 1 "addimp.o"
#pragma merger(0,"./addimp.i","")
#line 217 "/usr/include/stdio.h"
extern int (__attribute__((__cdecl__)) sprintf)(char *, char const   *, ...);
#line 34 "/usr/include/string.h"
extern size_t(__attribute__((__cdecl__)) strlen)(char const   *);
#line 17 "utils.h"
FILE *fpo;
#line 21
char *safe_malloc(unsigned int size);
#line 195 "standard.h"
struct hash **hashtab;
#line 197 "standard.h"
int netctr;
#line 199 "standard.h"
struct cellbox **carray;
#line 200 "standard.h"
struct dimbox **netarray;
#line 201 "standard.h"
struct netbox **tearray;
#line 202 "standard.h"
struct blockbox **barray;
#line 203 "standard.h"
struct rowbox *rowArray;
#line 204 "standard.h"
struct binbox ***binptr;
#line 205 "standard.h"
struct changrdbox *ULgrdptr;
#line 205 "standard.h"
struct changrdbox *URgrdptr;
#line 205 "standard.h"
struct changrdbox *LLgrdptr;
#line 205 "standard.h"
struct changrdbox *LRgrdptr;
#line 205 "standard.h"
struct changrdbox **Shuffle;
#line 207 "standard.h"
int bdxlen;
#line 207 "standard.h"
int bdylen;
#line 209 "standard.h"
int numblock;
#line 210 "standard.h"
int numcells;
#line 211 "standard.h"
int numterms;
#line 212 "standard.h"
int numnets;
#line 213 "standard.h"
int numRows;
#line 215 "standard.h"
int penalty;
#line 216 "standard.h"
int funccost;
#line 217 "standard.h"
int Trybin;
#line 218 "standard.h"
int binpenal;
#line 219 "standard.h"
int rowpenal;
#line 220 "standard.h"
int newrowpenal;
#line 221 "standard.h"
int newbinpenal;
#line 222 "standard.h"
int Left_bound;
#line 222 "standard.h"
int Rite_bound;
#line 223 "standard.h"
int **cedgebin;
#line 223 "standard.h"
int cedge_binwidth;
#line 223 "standard.h"
int num_edgebin;
#line 224 "standard.h"
int gtopChan;
#line 224 "standard.h"
int gbotChan;
#line 225 "standard.h"
int one_pin_feedthru;
#line 228 "standard.h"
int numBins;
#line 229 "standard.h"
int binWidth;
#line 230 "standard.h"
int binOffst;
#line 231 "standard.h"
int fdWidth;
#line 233 "standard.h"
int feeds;
#line 234 "standard.h"
int **rowgrid;
#line 235 "standard.h"
int windx;
#line 236 "standard.h"
int randVar;
#line 237 "standard.h"
int max_blklength;
#line 238 "standard.h"
int desiredL;
#line 239 "standard.h"
int implicit_feed_count;
#line 240 "standard.h"
int *feeds_in_row;
#line 241 "standard.h"
int resume_run;
#line 242 "standard.h"
int uneven_cell_height;
#line 243 "standard.h"
int track_spacing;
#line 244 "standard.h"
char cktName[128];
#line 20 "addimp.c"
IBOXPTR siptr;
#line 21
int maxterm;
#line 23
char **pinnames;
#line 26 "addimp.c"
void addimp(int row___0, int net)
{
	CBOXPTR ptr;
	TEBOXPTR termptr;
	IPBOXPTR ipptr;
	IPBOXPTR tipptr;
	IPBOXPTR bipptr;
	NBOXPTR nptr;
	NBOXPTR n1ptr;
	NBOXPTR n2ptr;
	int pin;
	int orient;
	int realcell;
	struct termbox *tmp;
	char *tmp___0;
	TEBOXPTR tmp___1;
	char *tmp___2;
	size_t tmp___3;
	char *tmp___4;
	char *tmp___5;
	char *tmp___6;
	size_t tmp___7;
	char *tmp___8;
	char *tmp___9;
	struct netbox *tmp___10;
	char *tmp___11;
	struct netbox *tmp___12;
	char *tmp___13;

	{
#line 35
		realcell = siptr->icell;
#line 36
		ptr = *(carray + realcell);
#line 37
		ptr->numterms += 2;
#line 39
		ipptr = siptr->iptr;
#line 39
		while (!(ipptr->iypos > 0)) {
#line 39
			ipptr = ipptr->npin;
		}
#line 44
		tipptr = ipptr;
#line 46
		ipptr = siptr->iptr;
#line 46
		while (!(ipptr->iypos < 0)) {
#line 46
			ipptr = ipptr->npin;
		}
#line 51
		bipptr = ipptr;
#line 53
		termptr = (ptr->tileptr)->termsptr;
#line 54
		if ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 55
			while ((unsigned int)termptr->nextterm != (unsigned int)((void *)0)) {
#line 56
				termptr = termptr->nextterm;
			}
#line 58
			tmp___0 = safe_malloc(sizeof(TEBOX));
#line 58
			tmp = (struct termbox *)tmp___0;
#line 58
			termptr->nextterm = tmp;
#line 58
			termptr = tmp;
		}
		else {
#line 60
			tmp___2 = safe_malloc(sizeof(TEBOX));
#line 60
			tmp___1 = (struct termbox *)tmp___2;
#line 60
			(ptr->tileptr)->termsptr = tmp___1;
#line 60
			termptr = tmp___1;
		}
#line 63
		maxterm++;
#line 63
		termptr->cellterm = maxterm;
#line 64
		tmp___3 = strlen((char const   *)tipptr->ipname);
#line 64
		tmp___4 = safe_malloc((tmp___3 + 1U) * sizeof(char));
#line 64
		* (pinnames + maxterm) = tmp___4;
#line 66
		sprintf(*(pinnames + maxterm), "%s", tipptr->ipname);
#line 67
		termptr->ei = maxterm;
#line 68
		termptr->ue = 0;
#line 69
		tmp___5 = safe_malloc(sizeof(NBOX));
#line 69
		* (tearray + maxterm) = (struct netbox *)tmp___5;
#line 71
		tmp___6 = safe_malloc(sizeof(TEBOX));
#line 71
		termptr->nextterm = (struct termbox *)tmp___6;
#line 72
		(termptr->nextterm)->nextterm = (struct termbox *)((void *)0);
#line 73
		(termptr->nextterm)->ei = maxterm;
#line 74
		(termptr->nextterm)->ue = 0;
#line 75
		maxterm++;
#line 75
		(termptr->nextterm)->cellterm = maxterm;
#line 76
		tmp___7 = strlen((char const   *)bipptr->ipname);
#line 76
		tmp___8 = safe_malloc((tmp___7 + 1U) * sizeof(char));
#line 76
		* (pinnames + maxterm) = tmp___8;
#line 78
		sprintf(*(pinnames + maxterm), "%s", bipptr->ipname);
#line 79
		tmp___9 = safe_malloc(sizeof(NBOX));
#line 79
		* (tearray + maxterm) = (struct netbox *)tmp___9;
#line 82
		termptr->txpos[0] = tipptr->ixpos;
#line 83
		termptr->typos[0] = tipptr->iypos;
#line 84
		termptr->txpos[1] = -termptr->txpos[0];
#line 85
		termptr->typos[1] = -termptr->typos[0];
#line 86
		if (ptr->clength % 2 != 0) {
#line 87
			(termptr->txpos[1])++;
		}
#line 89
		if (ptr->cheight % 2 != 0) {
#line 90
			(termptr->typos[1])++;
		}
#line 97
		pin = termptr->cellterm;
#line 98
		nptr = (*(netarray + net))->netptr;
#line 99
		while ((unsigned int)nptr->nterm != (unsigned int)((void *)0)) {
#line 99
			nptr = nptr->nterm;
		}
#line 100
		tmp___11 = safe_malloc(sizeof(NBOX));
#line 100
		tmp___10 = (struct netbox *)tmp___11;
#line 100
		nptr->nterm = tmp___10;
#line 100
		nptr = tmp___10;
#line 101
		* (tearray + pin) = nptr;
#line 102
		nptr->terminal = pin;
#line 103
		nptr->flag = (char)0;
#line 104
		nptr->row = row___0;
#line 105
		nptr->cell = realcell;
#line 106
		nptr->net = net;
#line 107
		nptr->extint = termptr->ei;
#line 108
		nptr->unequiv = (char)termptr->ue;
#line 109
		nptr->layer = (char)tipptr->layer;
#line 110
		n1ptr = nptr;
#line 114
		termptr = termptr->nextterm;
#line 115
		termptr->txpos[0] = bipptr->ixpos;
#line 116
		termptr->typos[0] = bipptr->iypos;
#line 117
		termptr->txpos[1] = -termptr->txpos[0];
#line 118
		termptr->typos[1] = -termptr->typos[0];
#line 119
		if (ptr->clength % 2 != 0) {
#line 120
			(termptr->txpos[1])++;
		}
#line 122
		if (ptr->cheight % 2 != 0) {
#line 123
			(termptr->typos[1])++;
		}
#line 125
		pin = termptr->cellterm;
#line 126
		tmp___13 = safe_malloc(sizeof(NBOX));
#line 126
		tmp___12 = (struct netbox *)tmp___13;
#line 126
		nptr->nterm = tmp___12;
#line 126
		nptr = tmp___12;
#line 127
		* (tearray + pin) = nptr;
#line 128
		nptr->nterm = (struct netbox *)((void *)0);
#line 129
		nptr->terminal = pin;
#line 130
		nptr->flag = (char)0;
#line 131
		nptr->row = row___0;
#line 132
		nptr->cell = realcell;
#line 133
		nptr->net = net;
#line 134
		nptr->extint = termptr->ei;
#line 135
		nptr->unequiv = (char)termptr->ue;
#line 136
		nptr->layer = (char)bipptr->layer;
#line 137
		n2ptr = nptr;
#line 149
		orient = (int)ptr->corient;
#line 150
		if (orient == 0) {
#line 151
			n1ptr->pinloc = (char)1;
#line 152
			n2ptr->pinloc = (char)-1;
		}
		else {
#line 150
			if (orient == 2) {
#line 151
				n1ptr->pinloc = (char)1;
#line 152
				n2ptr->pinloc = (char)-1;
			}
			else {
#line 154
				n1ptr->pinloc = (char)-1;
#line 155
				n2ptr->pinloc = (char)1;
			}
		}
#line 157
		return;
	}
}
#line 1 "alignfeed.o"
#pragma merger(0,"./alignfeed.i","")
#line 2 "alignfeed.c"
int fdthrus;
#line 3
int **pairArray;
#line 37
int re_place(int *rowptr, int cell___0, int index___0, int x_location);
#line 6 "alignfeed.c"
int alignfeed(void)
{
	int row___0;
	int last_up;
	int last_dn;
	int up;
	int dn;
	int cell_up;
	int cell_dn;
	int net_up;
	int net_dn;
	int x_up;
	int distance;
	int tmp;

	{
#line 12
		distance = 0;
#line 13
		row___0 = numRows - 1;
#line 13
		while (row___0 >= 1) {
#line 14
			last_up = *(*(pairArray + (row___0 + 1)) + 0);
#line 15
			last_dn = *(*(pairArray + row___0) + 0);
#line 16
			up = 1;
#line 16
			while (up <= last_up) {
#line 17
				cell_up = *(*(pairArray + (row___0 + 1)) + up);
#line 18
				if (cell_up >= (numcells - fdthrus) + 1) {
#line 19
					if ((unsigned int)((*(carray + cell_up))->tileptr)->termsptr == (unsigned int)((void *)0)) {
						goto __Cont;
					}
#line 22
					net_up = (*(tearray + (((*(carray + cell_up))->tileptr)->termsptr)->cellterm))->net;
#line 24
					x_up = (*(carray + cell_up))->cxcenter;
#line 25
					dn = 1;
#line 25
					while (dn <= last_dn) {
#line 26
						cell_dn = *(*(pairArray + row___0) + dn);
#line 27
						if (cell_dn >= (numcells - fdthrus) + 1) {
#line 28
							if ((unsigned int)((*(carray + cell_dn))->tileptr)->termsptr == (unsigned int)((void *)0)) {
								goto __Cont___0;
							}
#line 32
							net_dn = (*(tearray + (((*(carray + cell_dn))->tileptr)->termsptr)->cellterm))->net;
#line 34
							if (net_dn != net_up) {
								goto __Cont___0;
							}
#line 37
							tmp = re_place(*(pairArray + row___0), cell_dn, dn, x_up);
#line 37
							distance += tmp;
#line 39
							break;
						}
					__Cont___0: /* CIL Label */
#line 25
						dn++;
					}
				}
			__Cont: /* CIL Label */
#line 16
				up++;
			}
#line 13
			row___0--;
		}
#line 46
		return (distance);
	}
}
#line 89
int ABS(int value);
#line 51 "alignfeed.c"
int re_place(int *rowptr, int cell___0, int index___0, int x_location)
{
	int i;
	int j;
	int last___0;
	int prev_x;
	int tmp;

	{
#line 56
		last___0 = *(rowptr + 0);
#line 58
		if ((*(carray + *(rowptr + 1)))->cxcenter >= x_location) {
#line 59
			i = 0;
		}
		else {
#line 60
			if ((*(carray + *(rowptr + last___0)))->cxcenter <= x_location) {
#line 61
				i = last___0;
			}
			else {
#line 63
				i = 1;
#line 63
				while (i < last___0) {
#line 64
					if ((*(carray + *(rowptr + i)))->cxcenter <= x_location) {
#line 64
						if ((*(carray + *(rowptr + (i + 1))))->cxcenter >= x_location) {
#line 66
							break;
						}
					}
#line 63
					i++;
				}
			}
		}
#line 70
		prev_x = (*(carray + cell___0))->cxcenter;
#line 71
		if (index___0 > i + 1) {
#line 72
			j = index___0 - 1;
#line 72
			while (j >= i + 1) {
#line 73
				(*(carray + *(rowptr + j)))->cxcenter += fdWidth;
#line 74
				* (rowptr + (j + 1)) = *(rowptr + j);
#line 72
				j--;
			}
#line 76
			* (rowptr + (i + 1)) = cell___0;
#line 78
			(*(carray + cell___0))->cxcenter = ((*(carray + *(rowptr + (i + 2))))->cxcenter + ((*(carray + *(rowptr + (i + 2))))->tileptr)->left) - (fdWidth - fdWidth / 2);
		}
		else {
#line 80
			if (index___0 < i) {
#line 81
				j = index___0 + 1;
#line 81
				while (j <= i) {
#line 82
					(*(carray + *(rowptr + j)))->cxcenter -= fdWidth;
#line 83
					* (rowptr + (j - 1)) = *(rowptr + j);
#line 81
					j++;
				}
#line 85
				* (rowptr + i) = cell___0;
#line 86
				(*(carray + cell___0))->cxcenter = ((*(carray + *(rowptr + (i - 1))))->cxcenter + ((*(carray + *(rowptr + (i - 1))))->tileptr)->right) + fdWidth / 2;
			}
		}
#line 89
		tmp = ABS((*(carray + cell___0))->cxcenter - prev_x);
#line 89
		return (tmp);
	}
}
#line 94 "alignfeed.c"
void align_init(void)
{
	int row___0;
	int i;
	int cell___0;
	int *rowptr;
	int j;
	int last___0;
	int width___0;

	{
#line 99
		row___0 = 1;
#line 99
		while (row___0 <= numRows) {
#line 100
			last___0 = *(*(pairArray + row___0) + 0);
#line 101
			i = 1;
#line 101
			while (i <= last___0) {
#line 102
				cell___0 = *(*(pairArray + row___0) + i);
#line 103
				if (cell___0 < (numcells - fdthrus) + 1) {
#line 104
					break;
				}
#line 101
				i++;
			}
#line 107
			if (i > 1) {
#line 107
				if (i <= last___0) {
#line 108
					rowptr = *(pairArray + row___0);
#line 109
					width___0 = ((*(carray + cell___0))->tileptr)->right - ((*(carray + cell___0))->tileptr)->left;
#line 111
					j = i - 1;
#line 111
					while (j >= 1) {
#line 112
						(*(carray + *(rowptr + j)))->cxcenter += width___0;
#line 113
						* (rowptr + (j + 1)) = *(rowptr + j);
#line 111
						j--;
					}
#line 115
					* (rowptr + 1) = cell___0;
#line 116
					(*(carray + cell___0))->cxcenter = ((*(carray + *(rowptr + 2)))->cxcenter + ((*(carray + *(rowptr + 2)))->tileptr)->left) - (width___0 - width___0 / 2);
				}
			}
#line 120
			i = last___0;
#line 120
			while (i >= 1) {
#line 121
				cell___0 = *(*(pairArray + row___0) + i);
#line 122
				if (cell___0 < (numcells - fdthrus) + 1) {
#line 123
					break;
				}
#line 120
				i--;
			}
#line 126
			if (i < last___0) {
#line 126
				if (i >= 1) {
#line 127
					rowptr = *(pairArray + row___0);
#line 128
					width___0 = ((*(carray + cell___0))->tileptr)->right - ((*(carray + cell___0))->tileptr)->left;
#line 130
					j = i + 1;
#line 130
					while (j <= last___0) {
#line 131
						(*(carray + *(rowptr + j)))->cxcenter -= width___0;
#line 132
						* (rowptr + (j - 1)) = *(rowptr + j);
#line 130
						j++;
					}
#line 134
					* (rowptr + last___0) = cell___0;
#line 135
					(*(carray + cell___0))->cxcenter = ((*(carray + *(rowptr + (last___0 - 1))))->cxcenter + ((*(carray + *(rowptr + (last___0 - 1))))->tileptr)->right) + width___0 / 2;
				}
			}
#line 99
			row___0++;
		}
#line 139
		return;
	}
}
#line 1 "buildimp.o"
#pragma merger(0,"./buildimp.i","")
#line 18 "buildimp.c"
IPBOXPTR xipptr;
#line 19
int *blkToRow;
#line 20
IBOXPTR *impFeeds;
#line 23 "buildimp.c"
void buildimp(int icell, int xrel, int yrel, char *pname, int flag, int layer)
{
	CBOXPTR ptr;
	IBOXPTR iptr;
	int row___0;
	char *tmp;
	char *tmp___0;
	char *tmp___1;
	size_t tmp___2;
	char *tmp___3;
	char *tmp___4;
	size_t tmp___5;
	char *tmp___6;

	{
#line 30
		if (flag == 1) {
#line 31
			ptr = *(carray + icell);
#line 32
			row___0 = *(blkToRow + ptr->cblock);
#line 33
			iptr = *(impFeeds + row___0);
#line 34
			if ((unsigned int)iptr != (unsigned int)((struct ibox *)((void *)0))) {
#line 35
				while ((unsigned int)iptr->niptr != (unsigned int)((struct ibox *)((void *)0))) {
#line 36
					iptr = iptr->niptr;
				}
#line 38
				tmp = safe_malloc(sizeof(IBOX));
#line 38
				iptr->niptr = (struct ibox *)tmp;
#line 39
				iptr = iptr->niptr;
			}
			else {
#line 41
				tmp___0 = safe_malloc(sizeof(IBOX));
#line 41
				* (impFeeds + row___0) = (struct ibox *)tmp___0;
#line 42
				iptr = *(impFeeds + row___0);
			}
#line 44
			iptr->icell = icell;
#line 45
			iptr->iactive = 0;
#line 46
			iptr->aveXpos = ptr->cxcenter + xrel;
#line 47
			iptr->niptr = (struct ibox *)((void *)0);
#line 48
			tmp___1 = safe_malloc(sizeof(IPBOX));
#line 48
			iptr->iptr = (struct ipbox *)tmp___1;
#line 49
			xipptr = iptr->iptr;
#line 50
			xipptr->ixpos = xrel;
#line 51
			xipptr->iypos = yrel;
#line 52
			xipptr->layer = layer;
#line 53
			tmp___2 = strlen((char const   *)pname);
#line 53
			tmp___3 = safe_malloc((tmp___2 + 1U) * sizeof(char));
#line 53
			xipptr->ipname = tmp___3;
#line 54
			sprintf(xipptr->ipname, "%s", pname);
#line 55
			xipptr->npin = (struct ipbox *)((void *)0);
		}
		else {
#line 58
			tmp___4 = safe_malloc(sizeof(IPBOX));
#line 58
			xipptr->npin = (struct ipbox *)tmp___4;
#line 59
			xipptr = xipptr->npin;
#line 60
			xipptr->ixpos = xrel;
#line 61
			xipptr->iypos = yrel;
#line 62
			xipptr->layer = layer;
#line 63
			tmp___5 = strlen((char const   *)pname);
#line 63
			tmp___6 = safe_malloc((tmp___5 + 1U) * sizeof(char));
#line 63
			xipptr->ipname = tmp___6;
#line 64
			sprintf(xipptr->ipname, "%s", pname);
#line 65
			xipptr->npin = (struct ipbox *)((void *)0);
		}
#line 67
		return;
	}
}
#line 72 "buildimp.c"
void build_feed_imp(int feed, int x, int row___0)
{
	IBOXPTR iptr;
	char pname[128];
	char *tmp;
	char *tmp___0;
	char *tmp___1;
	size_t tmp___2;
	char *tmp___3;
	struct ipbox *tmp___4;
	char *tmp___5;
	size_t tmp___6;
	char *tmp___7;

	{
#line 78
		iptr = *(impFeeds + row___0);
#line 79
		if ((unsigned int)iptr != (unsigned int)((struct ibox *)((void *)0))) {
#line 80
			while ((unsigned int)iptr->niptr != (unsigned int)((struct ibox *)((void *)0))) {
#line 81
				iptr = iptr->niptr;
			}
#line 83
			tmp = safe_malloc(sizeof(IBOX));
#line 83
			iptr->niptr = (struct ibox *)tmp;
#line 84
			iptr = iptr->niptr;
		}
		else {
#line 86
			tmp___0 = safe_malloc(sizeof(IBOX));
#line 86
			* (impFeeds + row___0) = (struct ibox *)tmp___0;
#line 87
			iptr = *(impFeeds + row___0);
		}
#line 89
		iptr->icell = numcells + feed;
#line 90
		iptr->iactive = -1;
#line 91
		iptr->aveXpos = x - fdWidth / 2;
#line 92
		iptr->niptr = (struct ibox *)((void *)0);
#line 93
		tmp___1 = safe_malloc(sizeof(IPBOX));
#line 93
		iptr->iptr = (struct ipbox *)tmp___1;
#line 94
		xipptr = iptr->iptr;
#line 95
		xipptr->ixpos = -fdWidth / 2;
#line 96
		xipptr->iypos = (*(barray + 1))->bheight - (*(barray + 1))->bheight / 2;
#line 97
		xipptr->layer = 0;
#line 98
		sprintf(pname, "%s.%d", "twfeed", feed);
#line 99
		tmp___2 = strlen((char const   *)(pname));
#line 99
		tmp___3 = safe_malloc((tmp___2 + 1U) * sizeof(char));
#line 99
		xipptr->ipname = tmp___3;
#line 100
		sprintf(xipptr->ipname, "%s", pname);
#line 102
		tmp___5 = safe_malloc(sizeof(IPBOX));
#line 102
		tmp___4 = (struct ipbox *)tmp___5;
#line 102
		xipptr->npin = tmp___4;
#line 102
		xipptr = tmp___4;
#line 103
		xipptr->ixpos = -fdWidth / 2;
#line 104
		xipptr->iypos = -(*(barray + 1))->bheight / 2;
#line 105
		xipptr->layer = 0;
#line 106
		tmp___6 = strlen((char const   *)(pname));
#line 106
		tmp___7 = safe_malloc((tmp___6 + 1U) * sizeof(char));
#line 106
		xipptr->ipname = tmp___7;
#line 107
		sprintf(xipptr->ipname, "%s", pname);
#line 108
		xipptr->npin = (struct ipbox *)((void *)0);
#line 110
		return;
	}
}
#line 1 "changrid.o"
#pragma merger(0,"./changrid.i","")
#line 22 "utils.h"
char *safe_calloc(unsigned int size, unsigned int num);
#line 52 "groute.h"
CHANGRDPTR *Begin;
#line 52
CHANGRDPTR *End;
#line 54
TGRIDPTR *Tgrid;
#line 60
int numChans;
#line 65
int gxstart;
#line 65
int gxstop;
#line 110 "changrid.c"
void qsortgdx(char *base, int n, int size);
#line 165
void safe_free(char *ptr);
#line 169
void safe_cfree(char *ptr);
#line 4 "changrid.c"
void changrid(void)
{
	CHANGRDPTR **gdptr;
	CHANGRDPTR grdptr;
	CHANGRDPTR cgdptr;
	CHANGRDPTR ngdptr;
	NBOXPTR netptr;
	int row___0;
	int net;
	int channel;
	int terminal___0;
	int *numPins___0;
	int *PinInChan;
	int count___0;
	int i;
	char *tmp;
	char *tmp___0;
	char *tmp___1;
	char *tmp___2;
	char *tmp___3;
	char *tmp___4;
	char *tmp___5;
	CHANGRDPTR tmp___6;
	char *tmp___7;
	char *tmp___8;
	char *tmp___9;
	char *tmp___10;
	char *tmp___11;
	char *tmp___12;
	char *tmp___13;

	{
#line 14
		tmp = safe_calloc(sizeof(int), (unsigned int)(numChans + 1));
#line 14
		numPins___0 = (int *)tmp;
#line 15
		tmp___0 = safe_calloc(sizeof(int), (unsigned int)(numChans + 1));
#line 15
		PinInChan = (int *)tmp___0;
#line 16
		net = 1;
#line 16
		while (net <= numnets) {
#line 17
			netptr = (struct netbox *)(*(netarray + net))->netptr;
#line 17
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 19
				if ((int)netptr->pinloc == -1) {
#line 20
					(*(numPins___0 + netptr->row))++;
				}
				else {
#line 21
					if ((int)netptr->pinloc == 1) {
#line 22
						(*(numPins___0 + (netptr->row + 1)))++;
					}
					else {
#line 24
						if (netptr->row > 0) {
#line 25
							(*(numPins___0 + netptr->row))++;
						}
#line 27
						if (netptr->row < numChans) {
#line 28
							(*(numPins___0 + (netptr->row + 1)))++;
						}
					}
				}
#line 17
				netptr = (struct netbox *)netptr->nterm;
			}
#line 16
			net++;
		}
#line 34
		tmp___1 = safe_malloc((unsigned int)(numChans + 1) * sizeof(CHANGRDPTR *));
#line 34
		gdptr = (CHANGRDPTR **)tmp___1;
#line 36
		channel = 1;
#line 36
		while (channel <= numChans) {
#line 37
			tmp___2 = safe_malloc((unsigned int)(*(numPins___0 + channel) + 1) * sizeof(CHANGRDPTR));
#line 37
			* (gdptr + channel) = (CHANGRDPTR *)tmp___2;
#line 36
			channel++;
		}
#line 41
		tmp___3 = safe_malloc((unsigned int)((maxterm + 2 * numChans) + 1) * sizeof(TGRIDPTR));
#line 41
		Tgrid = (TGRIDPTR *)tmp___3;
#line 43
		terminal___0 = 1;
#line 43
		while (terminal___0 <= maxterm + 2 * numChans) {
#line 44
			tmp___4 = safe_malloc(sizeof(TGRIDBOX));
#line 44
			* (Tgrid + terminal___0) = (struct tgridbox *)tmp___4;
#line 43
			terminal___0++;
		}
#line 46
		net = 1;
#line 46
		while (net <= numnets) {
#line 47
			netptr = (struct netbox *)(*(netarray + net))->netptr;
#line 47
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 49
				row___0 = netptr->row;
#line 50
				terminal___0 = netptr->terminal;
#line 51
				tmp___5 = safe_malloc(sizeof(CHANGRDBOX___0));
#line 51
				grdptr = (struct changrdbox *)tmp___5;
#line 52
				if ((int)netptr->pinloc == -1) {
#line 53
					channel = row___0;
#line 54
					(*(PinInChan + channel))++;
#line 54
					count___0 = *(PinInChan + channel);
#line 55
					* (*(gdptr + channel) + count___0) = grdptr;
#line 56
					(*(Tgrid + terminal___0))->up = grdptr;
#line 57
					(*(Tgrid + terminal___0))->down = grdptr;
#line 58
					grdptr->netptr = (struct netbox *)*(tearray + terminal___0);
#line 59
					grdptr->tracks = 0;
#line 60
					grdptr->SegType = 0;
				}
				else {
#line 61
					if ((int)netptr->pinloc == 1) {
#line 62
						channel = row___0 + 1;
#line 63
						(*(PinInChan + channel))++;
#line 63
						count___0 = *(PinInChan + channel);
#line 64
						* (*(gdptr + channel) + count___0) = grdptr;
#line 65
						(*(Tgrid + terminal___0))->up = grdptr;
#line 66
						(*(Tgrid + terminal___0))->down = grdptr;
#line 67
						grdptr->netptr = (struct netbox *)*(tearray + terminal___0);
#line 68
						grdptr->tracks = 0;
#line 69
						grdptr->SegType = 0;
					}
					else {
#line 71
						if (1 <= row___0) {
#line 71
							if (row___0 <= numChans - 1) {
#line 72
								channel = row___0;
#line 73
								(*(PinInChan + channel))++;
#line 73
								count___0 = *(PinInChan + channel);
#line 74
								* (*(gdptr + channel) + count___0) = grdptr;
#line 75
								(*(Tgrid + terminal___0))->down = grdptr;
#line 76
								grdptr->netptr = (struct netbox *)*(tearray + terminal___0);
#line 77
								grdptr->tracks = 0;
#line 78
								grdptr->SegType = 0;
#line 80
								channel = row___0 + 1;
#line 81
								(*(PinInChan + channel))++;
#line 81
								count___0 = *(PinInChan + channel);
#line 82
								tmp___7 = safe_malloc(sizeof(CHANGRDBOX___0));
#line 82
								tmp___6 = (struct changrdbox *)tmp___7;
#line 82
								* (*(gdptr + channel) + count___0) = tmp___6;
#line 82
								grdptr = tmp___6;
#line 84
								(*(Tgrid + terminal___0))->up = grdptr;
#line 85
								grdptr->netptr = (struct netbox *)*(tearray + terminal___0);
#line 86
								grdptr->tracks = 0;
#line 87
								grdptr->SegType = 0;
							}
							else {
								goto _L;
							}
						}
						else {
						_L: /* CIL Label */
#line 88
							if (row___0 == 0) {
#line 89
								(*(PinInChan + 1))++;
#line 89
								count___0 = *(PinInChan + 1);
#line 90
								* (*(gdptr + 1) + count___0) = grdptr;
#line 91
								(*(Tgrid + terminal___0))->up = grdptr;
#line 92
								(*(Tgrid + terminal___0))->down = grdptr;
#line 93
								grdptr->netptr = (struct netbox *)*(tearray + terminal___0);
#line 94
								grdptr->tracks = 0;
#line 95
								grdptr->SegType = 0;
							}
							else {
#line 97
								(*(PinInChan + numChans))++;
#line 97
								count___0 = *(PinInChan + numChans);
#line 98
								* (*(gdptr + numChans) + count___0) = grdptr;
#line 99
								(*(Tgrid + terminal___0))->up = grdptr;
#line 100
								(*(Tgrid + terminal___0))->down = grdptr;
#line 101
								grdptr->netptr = (struct netbox *)*(tearray + terminal___0);
#line 102
								grdptr->tracks = 0;
#line 103
								grdptr->SegType = 0;
							}
						}
					}
				}
#line 47
				netptr = (struct netbox *)netptr->nterm;
			}
#line 46
			net++;
		}
#line 109
		channel = 1;
#line 109
		while (channel <= numChans) {
#line 110
			qsortgdx((char *)(*(gdptr + channel) + 1), *(numPins___0 + channel), sizeof(CHANGRDPTR));
#line 109
			channel++;
		}
#line 114
		tmp___8 = safe_malloc((unsigned int)(numChans + 1) * sizeof(CHANGRDPTR));
#line 114
		Begin = (CHANGRDPTR *)tmp___8;
#line 116
		tmp___9 = safe_malloc((unsigned int)(numChans + 1) * sizeof(CHANGRDPTR));
#line 116
		End = (CHANGRDPTR *)tmp___9;
#line 118
		channel = 1;
#line 118
		while (channel <= numChans) {
#line 119
			tmp___10 = safe_calloc(sizeof(CHANGRDBOX___0), 1U);
#line 119
			* (Begin + channel) = (struct changrdbox *)tmp___10;
#line 120
			tmp___11 = safe_calloc(sizeof(NBOX___0), 1U);
#line 120
			(*(Begin + channel))->netptr = (struct netbox *)tmp___11;
#line 121
			((*(Begin + channel))->netptr)->xpos = gxstart - 1;
#line 122
			((*(Begin + channel))->netptr)->terminal = maxterm + channel;
#line 123
			((*(Begin + channel))->netptr)->row = channel;
#line 124
			((*(Begin + channel))->netptr)->pinloc = (char)-1;
#line 125
			* (tearray + (maxterm + channel)) = (struct netbox *)(*(Begin + channel))->netptr;
#line 127
			tmp___12 = safe_calloc(sizeof(CHANGRDBOX___0), 1U);
#line 127
			* (End + channel) = (struct changrdbox *)tmp___12;
#line 128
			tmp___13 = safe_calloc(sizeof(NBOX___0), 1U);
#line 128
			(*(End + channel))->netptr = (struct netbox *)tmp___13;
#line 129
			((*(End + channel))->netptr)->xpos = gxstop + 1;
#line 130
			((*(End + channel))->netptr)->terminal = (maxterm + numChans) + channel;
#line 131
			((*(End + channel))->netptr)->row = channel;
#line 132
			((*(End + channel))->netptr)->pinloc = (char)-1;
#line 133
			* (tearray + ((maxterm + numChans) + channel)) = (struct netbox *)(*(End + channel))->netptr;
#line 118
			channel++;
		}
#line 135
		channel = 1;
#line 135
		while (channel <= numChans) {
#line 136
			(*(Tgrid + (maxterm + channel)))->up = *(Begin + channel);
#line 137
			(*(Tgrid + (maxterm + channel)))->down = *(Begin + channel);
#line 138
			(*(Tgrid + ((maxterm + numChans) + channel)))->up = *(End + channel);
#line 139
			(*(Tgrid + ((maxterm + numChans) + channel)))->down = *(End + channel);
#line 135
			channel++;
		}
#line 142
		channel = 1;
#line 142
		while (channel <= numChans) {
#line 143
			if (*(numPins___0 + channel) == 0) {
#line 144
				(*(Begin + channel))->nextgrd = (struct changrdbox *)((void *)0);
#line 145
				(*(End + channel))->prevgrd = (struct changrdbox *)((void *)0);
			}
			else {
#line 146
				if (*(numPins___0 + channel) == 1) {
#line 147
					(*(Begin + channel))->nextgrd = (struct changrdbox *)*(*(gdptr + channel) + 1);
#line 148
					(*(*(gdptr + channel) + 1))->prevgrd = (struct changrdbox *)*(Begin + channel);
#line 149
					(*(End + channel))->prevgrd = (struct changrdbox *)*(*(gdptr + channel) + 1);
#line 150
					(*(*(gdptr + channel) + 1))->nextgrd = (struct changrdbox *)*(End + channel);
				}
				else {
#line 152
					(*(Begin + channel))->nextgrd = (struct changrdbox *)*(*(gdptr + channel) + 1);
#line 153
					(*(*(gdptr + channel) + 1))->prevgrd = (struct changrdbox *)*(Begin + channel);
#line 154
					i = 1;
#line 154
					while (i <= *(numPins___0 + channel) - 1) {
#line 155
						cgdptr = *(*(gdptr + channel) + i);
#line 156
						ngdptr = *(*(gdptr + channel) + (i + 1));
#line 157
						cgdptr->nextgrd = (struct changrdbox *)ngdptr;
#line 158
						ngdptr->prevgrd = (struct changrdbox *)cgdptr;
#line 154
						i++;
					}
#line 160
					ngdptr->nextgrd = (struct changrdbox *)*(End + channel);
#line 161
					(*(End + channel))->prevgrd = (struct changrdbox *)ngdptr;
				}
			}
#line 142
			channel++;
		}
#line 164
		channel = 1;
#line 164
		while (channel <= numChans) {
#line 165
			safe_free(*(gdptr + channel));
#line 164
			channel++;
		}
#line 167
		safe_free(gdptr);
#line 169
		safe_cfree(numPins___0);
#line 170
		safe_cfree(PinInChan);
#line 171
		return;
	}
}
#line 1 "clean.o"
#pragma merger(0,"./clean.i","")
#line 11 "ucxxglb.h"
int ablock;
#line 11
int bblock;
#line 4 "clean.c"
void new_old(int c)
{
	int old;
	int new;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;

	{
#line 9
		if (ablock != bblock) {
#line 10
			(*(barray + ablock))->newsize = (*(barray + ablock))->oldsize + c;
#line 11
			(*(barray + bblock))->newsize = (*(barray + bblock))->oldsize - c;
#line 12
			tmp = ABS((*(barray + ablock))->oldsize - (*(barray + ablock))->desire);
#line 12
			tmp___0 = ABS((*(barray + bblock))->oldsize - (*(barray + bblock))->desire);
#line 12
			old = tmp + tmp___0;
#line 14
			tmp___1 = ABS((*(barray + ablock))->newsize - (*(barray + ablock))->desire);
#line 14
			tmp___2 = ABS((*(barray + bblock))->newsize - (*(barray + bblock))->desire);
#line 14
			new = tmp___1 + tmp___2;
#line 16
			newrowpenal += new - old;
		}
#line 18
		return;
	}
}
#line 21 "clean.c"
void old_assgnto_new1(int alobin, int ahibin, int anewlobin, int anewhibin)
{
	int bin;
	int lobin;
	int hibin;

	{
#line 26
		if (ablock == bblock) {
#line 27
			if (alobin <= anewlobin) {
#line 27
				lobin = alobin;
			}
			else {
#line 27
				lobin = anewlobin;
			}
#line 28
			if (ahibin >= anewhibin) {
#line 28
				hibin = ahibin;
			}
			else {
#line 28
				hibin = anewhibin;
			}
#line 29
			bin = lobin;
#line 29
			while (bin <= hibin) {
#line 30
				(*(*(binptr + ablock) + bin))->nupenalty = (*(*(binptr + ablock) + bin))->penalty;
#line 29
				bin++;
			}
		}
		else {
#line 34
			bin = alobin;
#line 34
			while (bin <= ahibin) {
#line 35
				(*(*(binptr + ablock) + bin))->nupenalty = (*(*(binptr + ablock) + bin))->penalty;
#line 34
				bin++;
			}
#line 38
			bin = anewlobin;
#line 38
			while (bin <= anewhibin) {
#line 39
				(*(*(binptr + bblock) + bin))->nupenalty = (*(*(binptr + bblock) + bin))->penalty;
#line 38
				bin++;
			}
		}
#line 43
		return;
	}
}
#line 46 "clean.c"
void new_assgnto_old1(int alobin, int ahibin, int anewlobin, int anewhibin)
{
	int bin;
	int lobin;
	int hibin;

	{
#line 52
		if (ablock == bblock) {
#line 53
			if (alobin <= anewlobin) {
#line 53
				lobin = alobin;
			}
			else {
#line 53
				lobin = anewlobin;
			}
#line 54
			if (ahibin >= anewhibin) {
#line 54
				hibin = ahibin;
			}
			else {
#line 54
				hibin = anewhibin;
			}
#line 55
			bin = lobin;
#line 55
			while (bin <= hibin) {
#line 56
				(*(*(binptr + ablock) + bin))->penalty = (*(*(binptr + ablock) + bin))->nupenalty;
#line 55
				bin++;
			}
		}
		else {
#line 60
			bin = alobin;
#line 60
			while (bin <= ahibin) {
#line 61
				(*(*(binptr + ablock) + bin))->penalty = (*(*(binptr + ablock) + bin))->nupenalty;
#line 60
				bin++;
			}
#line 64
			bin = anewlobin;
#line 64
			while (bin <= anewhibin) {
#line 65
				(*(*(binptr + bblock) + bin))->penalty = (*(*(binptr + bblock) + bin))->nupenalty;
#line 64
				bin++;
			}
		}
#line 69
		return;
	}
}
#line 71 "clean.c"
void old_assgnto_new2(int a1lobin, int a1hibin, int a2lobin, int a2hibin, int b1lobin,
	int b1hibin, int b2lobin, int b2hibin)
{
	int clobin;
	int chibin;
	int dlobin;
	int dhibin;
	int lobin;
	int hibin;
	int bin;

	{
#line 78
		if (a1lobin <= b2lobin) {
#line 78
			clobin = a1lobin;
		}
		else {
#line 78
			clobin = b2lobin;
		}
#line 79
		if (a1hibin >= b2hibin) {
#line 79
			chibin = a1hibin;
		}
		else {
#line 79
			chibin = b2hibin;
		}
#line 80
		if (a2lobin <= b1lobin) {
#line 80
			dlobin = a2lobin;
		}
		else {
#line 80
			dlobin = b1lobin;
		}
#line 81
		if (a2hibin >= b1hibin) {
#line 81
			dhibin = a2hibin;
		}
		else {
#line 81
			dhibin = b1hibin;
		}
#line 82
		if (ablock == bblock) {
#line 83
			if (clobin <= dlobin) {
#line 83
				lobin = clobin;
			}
			else {
#line 83
				lobin = dlobin;
			}
#line 84
			if (chibin >= dhibin) {
#line 84
				hibin = chibin;
			}
			else {
#line 84
				hibin = dhibin;
			}
#line 85
			bin = lobin;
#line 85
			while (bin <= hibin) {
#line 86
				(*(*(binptr + ablock) + bin))->nupenalty = (*(*(binptr + ablock) + bin))->penalty;
#line 85
				bin++;
			}
		}
		else {
#line 90
			bin = clobin;
#line 90
			while (bin <= chibin) {
#line 91
				(*(*(binptr + ablock) + bin))->nupenalty = (*(*(binptr + ablock) + bin))->penalty;
#line 90
				bin++;
			}
#line 94
			bin = dlobin;
#line 94
			while (bin <= dhibin) {
#line 95
				(*(*(binptr + bblock) + bin))->nupenalty = (*(*(binptr + bblock) + bin))->penalty;
#line 94
				bin++;
			}
		}
#line 99
		return;
	}
}
#line 102 "clean.c"
void new_assgnto_old2(int a1lobin, int a1hibin, int a2lobin, int a2hibin, int b1lobin,
	int b1hibin, int b2lobin, int b2hibin)
{
	int clobin;
	int chibin;
	int dlobin;
	int dhibin;
	int lobin;
	int hibin;
	int bin;

	{
#line 109
		if (a1lobin <= b2lobin) {
#line 109
			clobin = a1lobin;
		}
		else {
#line 109
			clobin = b2lobin;
		}
#line 110
		if (a1hibin >= b2hibin) {
#line 110
			chibin = a1hibin;
		}
		else {
#line 110
			chibin = b2hibin;
		}
#line 111
		if (a2lobin <= b1lobin) {
#line 111
			dlobin = a2lobin;
		}
		else {
#line 111
			dlobin = b1lobin;
		}
#line 112
		if (a2hibin >= b1hibin) {
#line 112
			dhibin = a2hibin;
		}
		else {
#line 112
			dhibin = b1hibin;
		}
#line 113
		if (ablock == bblock) {
#line 114
			if (clobin <= dlobin) {
#line 114
				lobin = clobin;
			}
			else {
#line 114
				lobin = dlobin;
			}
#line 115
			if (chibin >= dhibin) {
#line 115
				hibin = chibin;
			}
			else {
#line 115
				hibin = dhibin;
			}
#line 116
			bin = lobin;
#line 116
			while (bin <= hibin) {
#line 117
				(*(*(binptr + ablock) + bin))->penalty = (*(*(binptr + ablock) + bin))->nupenalty;
#line 116
				bin++;
			}
		}
		else {
#line 121
			bin = clobin;
#line 121
			while (bin <= chibin) {
#line 122
				(*(*(binptr + ablock) + bin))->penalty = (*(*(binptr + ablock) + bin))->nupenalty;
#line 121
				bin++;
			}
#line 125
			bin = dlobin;
#line 125
			while (bin <= dhibin) {
#line 126
				(*(*(binptr + bblock) + bin))->penalty = (*(*(binptr + bblock) + bin))->nupenalty;
#line 125
				bin++;
			}
		}
#line 130
		return;
	}
}
#line 133 "clean.c"
void sub_penal(int startx, int endx, int block___0, int LoBin, int HiBin)
{
	BINPTR bptr;
	int bin;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;

	{
#line 142
		if (LoBin == HiBin) {
#line 143
			bptr = *(*(binptr + block___0) + LoBin);
#line 144
			tmp = ABS(bptr->nupenalty);
#line 144
			newbinpenal -= tmp;
#line 145
			bptr->nupenalty -= endx - startx;
#line 146
			tmp___0 = ABS(bptr->nupenalty);
#line 146
			newbinpenal += tmp___0;
		}
		else {
#line 150
			bin = LoBin;
#line 150
			while (bin <= HiBin) {
#line 151
				bptr = *(*(binptr + block___0) + bin);
#line 155
				if (bin == LoBin) {
#line 156
					tmp___1 = ABS(bptr->nupenalty);
#line 156
					newbinpenal -= tmp___1;
#line 157
					bptr->nupenalty -= bptr->right - startx;
#line 158
					tmp___2 = ABS(bptr->nupenalty);
#line 158
					newbinpenal += tmp___2;
				}
				else {
#line 159
					if (bin == HiBin) {
#line 160
						tmp___3 = ABS(bptr->nupenalty);
#line 160
						newbinpenal -= tmp___3;
#line 161
						bptr->nupenalty -= endx - bptr->left;
#line 162
						tmp___4 = ABS(bptr->nupenalty);
#line 162
						newbinpenal += tmp___4;
					}
					else {
#line 164
						tmp___5 = ABS(bptr->nupenalty);
#line 164
						newbinpenal -= tmp___5;
#line 165
						bptr->nupenalty -= binWidth;
#line 166
						tmp___6 = ABS(bptr->nupenalty);
#line 166
						newbinpenal += tmp___6;
					}
				}
#line 150
				bin++;
			}
		}
#line 173
		return;
	}
}
#line 175 "clean.c"
void add_penal(int startx, int endx, int block___0, int LoBin, int HiBin)
{
	BINPTR bptr;
	int bin;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;

	{
#line 181
		if (LoBin == HiBin) {
#line 182
			bptr = *(*(binptr + block___0) + LoBin);
#line 183
			tmp = ABS(bptr->nupenalty);
#line 183
			newbinpenal -= tmp;
#line 184
			bptr->nupenalty += endx - startx;
#line 185
			tmp___0 = ABS(bptr->nupenalty);
#line 185
			newbinpenal += tmp___0;
		}
		else {
#line 187
			bin = LoBin;
#line 187
			while (bin <= HiBin) {
#line 188
				bptr = *(*(binptr + block___0) + bin);
#line 189
				if (bin == LoBin) {
#line 190
					tmp___1 = ABS(bptr->nupenalty);
#line 190
					newbinpenal -= tmp___1;
#line 191
					bptr->nupenalty += bptr->right - startx;
#line 192
					tmp___2 = ABS(bptr->nupenalty);
#line 192
					newbinpenal += tmp___2;
				}
				else {
#line 193
					if (bin == HiBin) {
#line 194
						tmp___3 = ABS(bptr->nupenalty);
#line 194
						newbinpenal -= tmp___3;
#line 195
						bptr->nupenalty += endx - bptr->left;
#line 196
						tmp___4 = ABS(bptr->nupenalty);
#line 196
						newbinpenal += tmp___4;
					}
					else {
#line 198
						tmp___5 = ABS(bptr->nupenalty);
#line 198
						newbinpenal -= tmp___5;
#line 199
						bptr->nupenalty += binWidth;
#line 200
						tmp___6 = ABS(bptr->nupenalty);
#line 200
						newbinpenal += tmp___6;
					}
				}
#line 187
				bin++;
			}
		}
#line 204
		return;
	}
}
#line 1 "closepins.o"
#pragma merger(0,"./closepins.i","")
#line 177 "/usr/include/stdio.h"
extern int (__attribute__((__cdecl__)) fprintf)(FILE *, char const   *, ...);
#line 48 "route.h"
csGroup *groupArray;
#line 52
edgeBox *edgeArray;
#line 5 "closepins.c"
int *key_queue;
#line 6
int numEdges;
#line 10 "closepins.c"
void closepins(FILE *tw, int net)
{
	int pin;
	int pin1;
	int pin2;
	int minP1;
	int minP2;
	int minX;
	int sepT;
	int sepB;
	int edge___0;
	int left___0;
	int right;
	int group1;
	int group2;
	int block1;
	int block2;
	int p1;
	int p2;
	int minTop;
	int minBottom;
	int maxTpin;
	int maxBpin;
	int otherTpin;
	int otherBpin;
	int maxTop;
	int maxBottom;
	int key_count;
	int key_flag;
	int segment_count;
	int super_edge;
	int next_edge;
	int e1;
	int e2;
	int g1;
	int g2;
	int next_g;
	int save_count;
	int ltop;
	int rtop;
	int lbot;
	int rbot;
	csPinBox *pArray1;
	csPinBox *pArray2;
	csPinBox *pArray;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;

	{
#line 23
		key_count = 0;
#line 24
		segment_count = 0;
#line 25
		super_edge = 0;
#line 27
		fprintf(tw, "net %d\n", net);
#line 28
		while (1) {
#line 29
			if (key_count > 0) {
#line 30
				tmp = key_count;
#line 30
				key_count--;
#line 30
				edge___0 = *(key_queue + tmp);
#line 31
				group1 = (edgeArray + edge___0)->group1;
#line 32
				key_flag = save_count;
#line 33
				rbot = -1;
#line 33
				rtop = rbot;
#line 33
				lbot = rtop;
#line 33
				ltop = lbot;
			}
			else {
#line 36
				while (1) {
#line 36
					super_edge++;
#line 36
					if (!(super_edge <= numEdges)) {
#line 36
						break;
					}
#line 37
					if ((edgeArray + super_edge)->marked == 0) {
#line 38
						continue;
					}
#line 40
					if ((edgeArray + super_edge)->done == 0) {
#line 41
						break;
					}
				}
#line 44
				if (super_edge > numEdges) {
#line 45
					break;
				}
#line 47
				edge___0 = super_edge;
#line 48
				key_flag = 0;
#line 49
				rbot = 0;
#line 49
				rtop = rbot;
#line 49
				lbot = rtop;
#line 49
				ltop = lbot;
			}
#line 53
			segment_count++;
#line 55
			maxTop = -1000000000;
#line 56
			maxBottom = -1000000000;
#line 57
			maxTpin = 0;
#line 58
			maxBpin = 0;
#line 59
			group1 = (edgeArray + edge___0)->group1;
#line 60
			pArray1 = (groupArray + group1)->pinArray;
#line 61
			block1 = (groupArray + group1)->block;
#line 62
			group2 = (edgeArray + edge___0)->group2;
#line 63
			pArray2 = (groupArray + group2)->pinArray;
#line 64
			block2 = (groupArray + group2)->block;
#line 66
			if ((edgeArray + edge___0)->poison == 0) {
#line 66
				if (key_flag == 0) {
#line 67
					save_count = segment_count;
#line 68
					(edgeArray + edge___0)->done = 1;
#line 69
					key_flag = save_count;
#line 73
					e1 = edge___0;
#line 74
					g1 = (edgeArray + e1)->group1;
#line 75
					while (!((groupArray + g1)->poison == 1)) {
#line 82
						if ((groupArray + g1)->edge1 == e1) {
#line 83
							next_edge = (groupArray + g1)->edge2;
						}
						else {
#line 85
							next_edge = (groupArray + g1)->edge1;
						}
#line 87
						if (next_edge == 0) {
#line 88
							break;
						}
#line 90
						next_g = (edgeArray + next_edge)->group1;
#line 91
						if (next_g == g1) {
#line 92
							g1 = (edgeArray + next_edge)->group2;
						}
						else {
#line 94
							g1 = next_g;
						}
#line 96
						e1 = next_edge;
#line 97
						(edgeArray + e1)->done = 1;
#line 98
						key_count++;
#line 98
						* (key_queue + key_count) = e1;
					}
#line 100
					e2 = edge___0;
#line 101
					g2 = (edgeArray + e2)->group2;
#line 102
					while (!((groupArray + g2)->poison == 1)) {
#line 106
						if ((groupArray + g2)->edge1 == e2) {
#line 107
							next_edge = (groupArray + g2)->edge2;
						}
						else {
#line 109
							next_edge = (groupArray + g2)->edge1;
						}
#line 111
						if (next_edge == 0) {
#line 112
							break;
						}
#line 114
						next_g = (edgeArray + next_edge)->group1;
#line 115
						if (next_g == g2) {
#line 116
							g2 = (edgeArray + next_edge)->group2;
						}
						else {
#line 118
							g2 = next_g;
						}
#line 120
						e2 = next_edge;
#line 121
						(edgeArray + e2)->done = 1;
#line 122
						key_count++;
#line 122
						* (key_queue + key_count) = e2;
					}
#line 124
					if ((groupArray + g1)->aveX <= (groupArray + g2)->aveX) {
#line 125
						pArray = (groupArray + g1)->pinArray;
#line 126
						pin = 1;
#line 126
						while (pin <= (groupArray + g1)->numPins) {
#line 127
							if ((pArray + pin)->top == 1) {
#line 128
								ltop = (pArray + pin)->pin;
							}
							else {
#line 127
								if ((pArray + pin)->top == 0) {
#line 128
									ltop = (pArray + pin)->pin;
								}
							}
#line 130
							if ((pArray + pin)->top == -1) {
#line 131
								lbot = (pArray + pin)->pin;
							}
							else {
#line 130
								if ((pArray + pin)->top == 0) {
#line 131
									lbot = (pArray + pin)->pin;
								}
							}
#line 126
							pin++;
						}
#line 134
						pArray = (groupArray + g2)->pinArray;
#line 135
						pin = 1;
#line 135
						while (pin <= (groupArray + g2)->numPins) {
#line 136
							if ((pArray + pin)->top == 1) {
#line 137
								rtop = (pArray + pin)->pin;
							}
							else {
#line 136
								if ((pArray + pin)->top == 0) {
#line 137
									rtop = (pArray + pin)->pin;
								}
							}
#line 139
							if ((pArray + pin)->top == -1) {
#line 140
								rbot = (pArray + pin)->pin;
							}
							else {
#line 139
								if ((pArray + pin)->top == 0) {
#line 140
									rbot = (pArray + pin)->pin;
								}
							}
#line 135
							pin++;
						}
					}
					else {
#line 144
						pArray = (groupArray + g2)->pinArray;
#line 145
						pin = 1;
#line 145
						while (pin <= (groupArray + g2)->numPins) {
#line 146
							if ((pArray + pin)->top == 1) {
#line 147
								ltop = (pArray + pin)->pin;
							}
							else {
#line 146
								if ((pArray + pin)->top == 0) {
#line 147
									ltop = (pArray + pin)->pin;
								}
							}
#line 149
							if ((pArray + pin)->top == -1) {
#line 150
								lbot = (pArray + pin)->pin;
							}
							else {
#line 149
								if ((pArray + pin)->top == 0) {
#line 150
									lbot = (pArray + pin)->pin;
								}
							}
#line 145
							pin++;
						}
#line 153
						pArray = (groupArray + g1)->pinArray;
#line 154
						pin = 1;
#line 154
						while (pin <= (groupArray + g1)->numPins) {
#line 155
							if ((pArray + pin)->top == 1) {
#line 156
								rtop = (pArray + pin)->pin;
							}
							else {
#line 155
								if ((pArray + pin)->top == 0) {
#line 156
									rtop = (pArray + pin)->pin;
								}
							}
#line 158
							if ((pArray + pin)->top == -1) {
#line 159
								rbot = (pArray + pin)->pin;
							}
							else {
#line 158
								if ((pArray + pin)->top == 0) {
#line 159
									rbot = (pArray + pin)->pin;
								}
							}
#line 154
							pin++;
						}
					}
				}
			}
#line 166
			if (block1 == block2) {
#line 168
				if ((groupArray + group1)->aveX <= (groupArray + group2)->aveX) {
#line 169
					pin = 1;
#line 169
					while (pin <= (groupArray + group1)->numPins) {
#line 170
						if ((pArray1 + pin)->top == 1) {
							goto _L;
						}
						else {
#line 170
							if ((pArray1 + pin)->top == 0) {
							_L: /* CIL Label */
#line 171
								if ((pArray1 + pin)->xloc > maxTop) {
#line 172
									maxTop = (pArray1 + pin)->xloc;
#line 173
									maxTpin = (pArray1 + pin)->pin;
								}
							}
						}
#line 176
						if ((pArray1 + pin)->top == -1) {
							goto _L___0;
						}
						else {
#line 176
							if ((pArray1 + pin)->top == 0) {
							_L___0: /* CIL Label */
#line 177
								if ((pArray1 + pin)->xloc > maxBottom) {
#line 178
									maxBottom = (pArray1 + pin)->xloc;
#line 179
									maxBpin = (pArray1 + pin)->pin;
								}
							}
						}
#line 169
						pin++;
					}
#line 183
					sepT = 1000000000;
#line 184
					sepB = 1000000000;
#line 185
					otherTpin = 0;
#line 186
					otherBpin = 0;
#line 187
					pin = 1;
#line 187
					while (pin <= (groupArray + group2)->numPins) {
#line 188
						if ((pArray2 + pin)->top == 1) {
							goto _L___1;
						}
						else {
#line 188
							if ((pArray2 + pin)->top == 0) {
							_L___1: /* CIL Label */
#line 189
								tmp___0 = ABS((pArray2 + pin)->xloc - maxTop);
#line 189
								if (tmp___0 < sepT) {
#line 190
									otherTpin = (pArray2 + pin)->pin;
#line 191
									minTop = (pArray2 + pin)->xloc;
#line 192
									sepT = ABS(minTop - maxTop);
								}
							}
						}
#line 195
						if ((pArray2 + pin)->top == -1) {
							goto _L___2;
						}
						else {
#line 195
							if ((pArray2 + pin)->top == 0) {
							_L___2: /* CIL Label */
#line 196
								tmp___1 = ABS((pArray2 + pin)->xloc - maxBottom);
#line 196
								if (tmp___1 < sepB) {
#line 197
									otherBpin = (pArray2 + pin)->pin;
#line 198
									minBottom = (pArray2 + pin)->xloc;
#line 199
									sepB = ABS(minBottom - maxBottom);
								}
							}
						}
#line 187
						pin++;
					}
#line 203
					if (maxTpin != 0) {
#line 203
						if (otherTpin != 0) {
#line 203
							if (block1 < numChans) {
#line 203
								if (maxBpin != 0) {
#line 203
									if (otherBpin != 0) {
#line 203
										if (maxBpin != 0) {
#line 203
											if (otherBpin != 0) {
#line 203
												if (maxBottom != minBottom) {
												_L___7: /* CIL Label */
#line 208
													if (maxBpin != 0) {
#line 208
														if (otherBpin != 0) {
#line 208
															if (block1 > 0) {
#line 208
																if (maxTop != minTop) {
#line 213
																	fprintf(tw, "segment switchable %d\n", key_flag);
#line 214
																	fprintf(tw, "top channel %d\n", block1 + 1);
#line 215
																	if (maxTop <= minTop) {
#line 216
																		p1 = maxTpin;
#line 217
																		p2 = otherTpin;
																	}
																	else {
#line 219
																		p1 = otherTpin;
#line 220
																		p2 = maxTpin;
																	}
#line 222
																	fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, ltop,
																		rtop);
#line 225
																	fprintf(tw, "bottom channel %d\n", block1);
#line 226
																	if (maxBottom <= minBottom) {
#line 227
																		p1 = maxBpin;
#line 228
																		p2 = otherBpin;
																	}
																	else {
#line 230
																		p1 = otherBpin;
#line 231
																		p2 = maxBpin;
																	}
#line 233
																	fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, lbot,
																		rbot);
																}
																else {
																	goto _L___5;
																}
															}
															else {
																goto _L___5;
															}
														}
														else {
															goto _L___5;
														}
													}
													else {
													_L___5: /* CIL Label */
#line 236
														fprintf(tw, "segment channel %d\n", block1 + 1);
#line 237
														if (maxTop <= minTop) {
#line 238
															p1 = maxTpin;
#line 239
															p2 = otherTpin;
														}
														else {
#line 241
															p1 = otherTpin;
#line 242
															p2 = maxTpin;
														}
#line 244
														fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, ltop, rtop);
													}
												}
												else {
													goto _L___9;
												}
											}
											else {
												goto _L___9;
											}
										}
										else {
											goto _L___9;
										}
									}
									else {
										goto _L___7;
									}
								}
								else {
									goto _L___7;
								}
							}
							else {
								goto _L___9;
							}
						}
						else {
							goto _L___9;
						}
					}
					else {
					_L___9: /* CIL Label */
#line 247
						if (maxBpin != 0) {
#line 247
							if (otherBpin != 0) {
#line 249
								fprintf(tw, "segment channel %d\n", block1);
#line 250
								if (maxBottom <= minBottom) {
#line 251
									p1 = maxBpin;
#line 252
									p2 = otherBpin;
								}
								else {
#line 254
									p1 = otherBpin;
#line 255
									p2 = maxBpin;
								}
#line 257
								fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, lbot, rbot);
							}
						}
					}
				}
				else {
#line 261
					pin = 1;
#line 261
					while (pin <= (groupArray + group2)->numPins) {
#line 262
						if ((pArray2 + pin)->top == 1) {
							goto _L___10;
						}
						else {
#line 262
							if ((pArray2 + pin)->top == 0) {
							_L___10: /* CIL Label */
#line 263
								if ((pArray2 + pin)->xloc > maxTop) {
#line 264
									maxTop = (pArray2 + pin)->xloc;
#line 265
									maxTpin = (pArray2 + pin)->pin;
								}
							}
						}
#line 268
						if ((pArray2 + pin)->top == -1) {
							goto _L___11;
						}
						else {
#line 268
							if ((pArray2 + pin)->top == 0) {
							_L___11: /* CIL Label */
#line 269
								if ((pArray2 + pin)->xloc > maxBottom) {
#line 270
									maxBottom = (pArray2 + pin)->xloc;
#line 271
									maxBpin = (pArray2 + pin)->pin;
								}
							}
						}
#line 261
						pin++;
					}
#line 275
					sepT = 1000000000;
#line 276
					sepB = 1000000000;
#line 277
					otherTpin = 0;
#line 278
					otherBpin = 0;
#line 279
					pin = 1;
#line 279
					while (pin <= (groupArray + group1)->numPins) {
#line 280
						if ((pArray1 + pin)->top == 1) {
							goto _L___12;
						}
						else {
#line 280
							if ((pArray1 + pin)->top == 0) {
							_L___12: /* CIL Label */
#line 281
								tmp___2 = ABS((pArray1 + pin)->xloc - maxTop);
#line 281
								if (tmp___2 < sepT) {
#line 282
									otherTpin = (pArray1 + pin)->pin;
#line 283
									minTop = (pArray1 + pin)->xloc;
#line 284
									sepT = ABS(minTop - maxTop);
								}
							}
						}
#line 287
						if ((pArray1 + pin)->top == -1) {
							goto _L___13;
						}
						else {
#line 287
							if ((pArray1 + pin)->top == 0) {
							_L___13: /* CIL Label */
#line 288
								tmp___3 = ABS((pArray1 + pin)->xloc - maxBottom);
#line 288
								if (tmp___3 < sepB) {
#line 289
									otherBpin = (pArray1 + pin)->pin;
#line 290
									minBottom = (pArray1 + pin)->xloc;
#line 291
									sepB = ABS(minBottom - maxBottom);
								}
							}
						}
#line 279
						pin++;
					}
#line 295
					if (maxTpin != 0) {
#line 295
						if (otherTpin != 0) {
#line 295
							if (block1 < numChans) {
#line 295
								if (maxBpin != 0) {
#line 295
									if (otherBpin != 0) {
#line 295
										if (maxBpin != 0) {
#line 295
											if (otherBpin != 0) {
#line 295
												if (maxBottom != minBottom) {
												_L___18: /* CIL Label */
#line 300
													if (maxBpin != 0) {
#line 300
														if (otherBpin != 0) {
#line 300
															if (block1 > 0) {
#line 300
																if (maxTop != minTop) {
#line 305
																	fprintf(tw, "segment switchable %d\n", key_flag);
#line 306
																	fprintf(tw, "top channel %d\n", block1 + 1);
#line 307
																	if (maxTop <= minTop) {
#line 308
																		p1 = maxTpin;
#line 309
																		p2 = otherTpin;
																	}
																	else {
#line 311
																		p1 = otherTpin;
#line 312
																		p2 = maxTpin;
																	}
#line 314
																	fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, ltop,
																		rtop);
#line 317
																	fprintf(tw, "bottom channel %d\n", block1);
#line 318
																	if (maxBottom <= minBottom) {
#line 319
																		p1 = maxBpin;
#line 320
																		p2 = otherBpin;
																	}
																	else {
#line 322
																		p1 = otherBpin;
#line 323
																		p2 = maxBpin;
																	}
#line 325
																	fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, lbot,
																		rbot);
																}
																else {
																	goto _L___16;
																}
															}
															else {
																goto _L___16;
															}
														}
														else {
															goto _L___16;
														}
													}
													else {
													_L___16: /* CIL Label */
#line 328
														fprintf(tw, "segment channel %d\n", block1 + 1);
#line 329
														if (maxTop <= minTop) {
#line 330
															p1 = maxTpin;
#line 331
															p2 = otherTpin;
														}
														else {
#line 333
															p1 = otherTpin;
#line 334
															p2 = maxTpin;
														}
#line 336
														fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, ltop, rtop);
													}
												}
												else {
													goto _L___20;
												}
											}
											else {
												goto _L___20;
											}
										}
										else {
											goto _L___20;
										}
									}
									else {
										goto _L___18;
									}
								}
								else {
									goto _L___18;
								}
							}
							else {
								goto _L___20;
							}
						}
						else {
							goto _L___20;
						}
					}
					else {
					_L___20: /* CIL Label */
#line 339
						if (maxBpin != 0) {
#line 339
							if (otherBpin != 0) {
#line 341
								fprintf(tw, "segment channel %d\n", block1);
#line 342
								if (maxBottom <= minBottom) {
#line 343
									p1 = maxBpin;
#line 344
									p2 = otherBpin;
								}
								else {
#line 346
									p1 = otherBpin;
#line 347
									p2 = maxBpin;
								}
#line 349
								fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, lbot, rbot);
							}
						}
					}
				}
			}
			else {
#line 354
				minX = 1000000000;
#line 355
				minP1 = 0;
#line 356
				minP2 = 0;
#line 357
				if (block1 > block2) {
#line 358
					pin1 = 1;
#line 358
					while (pin1 <= (groupArray + group1)->numPins) {
#line 359
						if ((pArray1 + pin1)->top == -1) {
							goto _L___22;
						}
						else {
#line 359
							if ((pArray1 + pin1)->top == 0) {
							_L___22: /* CIL Label */
#line 361
								pin2 = 1;
#line 362
								while (pin2 <= (groupArray + group2)->numPins) {
#line 363
									if ((pArray2 + pin2)->top == 1) {
										goto _L___21;
									}
									else {
#line 363
										if ((pArray2 + pin2)->top == 0) {
										_L___21: /* CIL Label */
#line 365
											tmp___4 = ABS((pArray1 + pin1)->xloc - (pArray2 + pin2)->xloc);
#line 365
											if (tmp___4 < minX) {
#line 367
												left___0 = (pArray1 + pin1)->xloc;
#line 368
												right = (pArray2 + pin2)->xloc;
#line 369
												minX = ABS(left___0 - right);
#line 370
												minP1 = (pArray1 + pin1)->pin;
#line 371
												minP2 = (pArray2 + pin2)->pin;
											}
										}
									}
#line 362
									pin2++;
								}
							}
						}
#line 358
						pin1++;
					}
#line 377
					if (minP1 != 0) {
#line 377
						if (minP2 != 0) {
#line 378
							fprintf(tw, "segment channel %d\n", block1);
#line 379
							if (left___0 > right) {
#line 380
								fprintf(tw, " pin1 %d  pin2 %d %d %d\n", minP2, minP1, ltop, rtop);
							}
							else {
#line 383
								fprintf(tw, " pin1 %d  pin2 %d %d %d\n", minP1, minP2, ltop, rtop);
							}
						}
					}
				}
				else {
#line 388
					pin1 = 1;
#line 389
					while (pin1 <= (groupArray + group1)->numPins) {
#line 390
						if ((pArray1 + pin1)->top == 1) {
							goto _L___24;
						}
						else {
#line 390
							if ((pArray1 + pin1)->top == 0) {
							_L___24: /* CIL Label */
#line 392
								pin2 = 1;
#line 393
								while (pin2 <= (groupArray + group2)->numPins) {
#line 394
									if ((pArray2 + pin2)->top == -1) {
										goto _L___23;
									}
									else {
#line 394
										if ((pArray2 + pin2)->top == 0) {
										_L___23: /* CIL Label */
#line 396
											tmp___5 = ABS((pArray1 + pin1)->xloc - (pArray2 + pin2)->xloc);
#line 396
											if (tmp___5 < minX) {
#line 398
												left___0 = (pArray1 + pin1)->xloc;
#line 399
												right = (pArray2 + pin2)->xloc;
#line 400
												minX = ABS(left___0 - right);
#line 401
												minP1 = (pArray1 + pin1)->pin;
#line 402
												minP2 = (pArray2 + pin2)->pin;
											}
										}
									}
#line 393
									pin2++;
								}
							}
						}
#line 389
						pin1++;
					}
#line 408
					if (minP1 != 0) {
#line 408
						if (minP2 != 0) {
#line 409
							fprintf(tw, "segment channel %d\n", block2);
#line 410
							if (left___0 > right) {
#line 411
								fprintf(tw, " pin1 %d  pin2 %d %d %d\n", minP2, minP1, ltop, rtop);
							}
							else {
#line 414
								fprintf(tw, " pin1 %d  pin2 %d %d %d\n", minP1, minP2, ltop, rtop);
							}
						}
					}
				}
			}
		}
#line 421
		return;
	}
}
#line 1 "config1.o"
#pragma merger(0,"./config1.i","")
#line 14 "config1.c"
int celllen;
#line 15
float rowSep;
#line 16
float indent;
#line 17 "config1.c"
int *blkToRow;
#line 19 "config1.c"
int rowHeight;
#line 20
float macspace[16];
#line 22
float *relativeLen;
#line 25 "config1.c"
BBOXPTR boxptr;
#line 25 "config1.c"
BBOXPTR *oldbarray;
#line 26 "config1.c"
CBOXPTR cellptr;
#line 27 "config1.c"
MACROBOX *macroArray;
#line 28 "config1.c"
int *filledTo;
#line 28 "config1.c"
int *endRow;
#line 29 "config1.c"
int macNumber;
#line 29 "config1.c"
int row;
#line 29 "config1.c"
int totalR;
#line 30 "config1.c"
int totalBlock;
#line 30 "config1.c"
int borient;
#line 30 "config1.c"
int empty;
#line 30 "config1.c"
int cell;
#line 30 "config1.c"
int middleRow;
#line 31 "config1.c"
int extraSpace;
#line 31 "config1.c"
int pad;
#line 31 "config1.c"
int height;
#line 31 "config1.c"
int width;
#line 31 "config1.c"
int bot;
#line 31 "config1.c"
int top;
#line 31 "config1.c"
int trow;
#line 32 "config1.c"
static int rows;
#line 33 "config1.c"
int brow;
#line 33 "config1.c"
int rite;
#line 33 "config1.c"
int left;
#line 33 "config1.c"
int coreHeight;
#line 33 "config1.c"
int coreWidth;
#line 33 "config1.c"
int count;
#line 33 "config1.c"
int macro;
#line 34 "config1.c"
int maxHeight;
#line 34 "config1.c"
int space;
#line 34 "config1.c"
int separation;
#line 34 "config1.c"
int yshift;
#line 34 "config1.c"
int xshift;
#line 34 "config1.c"
int last;
#line 35 "config1.c"
int coreTop;
#line 35 "config1.c"
int coreRite;
#line 35 "config1.c"
int block;
#line 35 "config1.c"
int maxWidth;
#line 35 "config1.c"
int *padArray;
#line 35 "config1.c"
int numMacro;
#line 36 "config1.c"
int URmacro;
#line 36 "config1.c"
int Rmacro;
#line 36 "config1.c"
int edge;
#line 37 "config1.c"
int k;
#line 37 "config1.c"
int blk;
#line 37 "config1.c"
int zxshift;
#line 37 "config1.c"
int zyshift;
#line 38 "config1.c"
int mttshift;
#line 38 "config1.c"
int mbbshift;
#line 39 "config1.c"
float dsum;
#line 39 "config1.c"
float ratio;
#line 498
extern int( /* missing proto */  exit)();
#line 41 "config1.c"
void config1(void)
{
	float totalF;
	float modulation;
	float constant;
	int M;
	int r;
	int topRowY;
	int centerY;
	int count_mtt;
	int count_mbb;
	CBOXPTR padptr;
	char *tmp;
	char *tmp___0;
	int tmp___1;
	int tmp___2;
	char *tmp___3;

	{
#line 49
		tmp = safe_malloc(51U * sizeof(MACROBOX));
#line 49
		macroArray = (MACROBOX *)tmp;
#line 50
		macNumber = 0;
#line 51
		numRows = numblock;
#line 52
		tmp___0 = safe_malloc((unsigned int)(numRows + 1) * sizeof(ROWBOX));
#line 52
		rowArray = (ROWBOX *)tmp___0;
#line 53
		row = 1;
#line 53
		while (row <= numRows) {
#line 54
			(rowArray + row)->endx1 = -1;
#line 55
			(rowArray + row)->startx2 = -1;
#line 53
			row++;
		}
#line 64
		totalR = celllen;
#line 65
		rowHeight = 0;
#line 66
		row = 1;
#line 66
		while (row <= numRows) {
#line 67
			rowHeight += (*(barray + row))->btop - (*(barray + row))->bbottom;
#line 66
			row++;
		}
#line 69
		rowHeight /= numRows;
#line 79
		row = 1;
#line 79
		while (row <= numRows) {
#line 80
			(rowArray + row)->startx = 0;
#line 81
			(rowArray + row)->ypos = (int)(((float)(row - 1) * (rowSep + (float)1)) * (float)rowHeight + (float)(rowHeight / 2));
#line 79
			row++;
		}
#line 85
		if (numRows > 1) {
#line 86
			totalF = (float)0.0;
#line 87
			r = 1;
#line 87
			while (r <= numRows) {
#line 88
				totalF += *(relativeLen + r);
#line 87
				r++;
			}
#line 90
			topRowY = (rowArray + numRows)->ypos;
#line 91
			centerY = (topRowY + (rowArray + 1)->ypos) / 2;
#line 92
			M = (int)((float)totalR / totalF);
#line 94
			dsum = (float)0.0;
#line 95
			r = 1;
#line 95
			while (r <= numRows) {
#line 96
				tmp___1 = ABS((rowArray + r)->ypos - centerY);
#line 96
				dsum += *(relativeLen + r) * (float)tmp___1;
#line 95
				r++;
			}
#line 99
			dsum /= totalF;
#line 100
			dsum = (float)((double)dsum * (1.0 / (double)((float)(topRowY - centerY))));
#line 102
			constant = (float)(1.0 + (1.0 - (double)indent) * (1.0 - (double)dsum));
#line 103
			r = 1;
#line 103
			while (r <= numRows) {
#line 104
				(rowArray + r)->endx = (int)(((float)M * constant) * *(relativeLen + r));
#line 106
				tmp___2 = ABS((rowArray + r)->ypos - centerY);
#line 106
				modulation = (float)(1.0 + (1.0 - (double)indent) * (double)((float)tmp___2 / (float)(topRowY - centerY) - dsum));
#line 109
				(rowArray + r)->desiredL = (int)(((float)M * *(relativeLen + r)) * modulation) + 1;
#line 103
				r++;
			}
		}
		else {
#line 113
			(rowArray + 1)->endx = totalR;
#line 114
			(rowArray + 1)->desiredL = (rowArray + 1)->endx;
		}
#line 120
		extraSpace = (int)(rowSep * (float)rowHeight);
#line 121
		k = 1;
#line 121
		while (k <= 15) {
#line 122
			if ((double)macspace[k] < 0.0) {
#line 123
				macspace[k] = (float)extraSpace;
			}
			else {
#line 125
				macspace[k] *= (float)rowHeight;
			}
#line 121
			k++;
		}
#line 128
		middleRow = numRows / 2;
#line 136
		tmp___3 = safe_malloc((unsigned int)(numterms + 1) * sizeof(int));
#line 136
		padArray = (int *)tmp___3;
#line 137
		pad = 1;
#line 137
		while (pad <= numterms) {
#line 138
			* (padArray + pad) = 0;
#line 137
			pad++;
		}
#line 140
		numMacro = 0;
#line 141
		pad = numcells + 1;
#line 141
		while (pad <= numcells + numterms) {
#line 142
			if ((*(carray + pad))->padside == 5) {
#line 144
				numMacro++;
#line 144
				* (padArray + numMacro) = pad;
			}
			else {
#line 142
				if ((*(carray + pad))->padside == 9) {
#line 144
					numMacro++;
#line 144
					* (padArray + numMacro) = pad;
				}
				else {
#line 142
					if ((*(carray + pad))->padside == 7) {
#line 144
						numMacro++;
#line 144
						* (padArray + numMacro) = pad;
					}
				}
			}
#line 141
			pad++;
		}
#line 147
		pad = numcells + 1;
#line 147
		while (pad <= numcells + numterms) {
#line 148
			if ((*(carray + pad))->padside == 12) {
#line 150
				numMacro++;
#line 150
				* (padArray + numMacro) = pad;
			}
			else {
#line 148
				if ((*(carray + pad))->padside == 13) {
#line 150
					numMacro++;
#line 150
					* (padArray + numMacro) = pad;
				}
				else {
#line 148
					if ((*(carray + pad))->padside == 11) {
#line 150
						numMacro++;
#line 150
						* (padArray + numMacro) = pad;
					}
				}
			}
#line 147
			pad++;
		}
#line 153
		pad = numcells + 1;
#line 153
		while (pad <= numcells + numterms) {
#line 154
			if ((*(carray + pad))->padside == 6) {
#line 155
				numMacro++;
#line 155
				* (padArray + numMacro) = pad;
#line 156
				URmacro = numMacro;
			}
#line 153
			pad++;
		}
#line 159
		pad = numcells + 1;
#line 159
		while (pad <= numcells + numterms) {
#line 160
			if ((*(carray + pad))->padside == 10) {
#line 161
				numMacro++;
#line 161
				* (padArray + numMacro) = pad;
#line 162
				Rmacro = numMacro;
			}
#line 159
			pad++;
		}
#line 165
		pad = numcells + 1;
#line 165
		while (pad <= numcells + numterms) {
#line 166
			if ((*(carray + pad))->padside == 8) {
#line 167
				numMacro++;
#line 167
				* (padArray + numMacro) = pad;
			}
#line 165
			pad++;
		}
#line 172
		macro = 1;
#line 172
		while (macro <= numMacro) {
#line 173
			pad = *(padArray + macro);
#line 174
			padptr = *(carray + pad);
#line 175
			height = (padptr->tileptr)->top - (padptr->tileptr)->bottom;
#line 176
			width = (padptr->tileptr)->right - (padptr->tileptr)->left;
#line 178
			macNumber++;
#line 180
			switch (padptr->padside) {
			case 5:
#line 181
				row = numRows;
#line 181
				while (row >= 1) {
#line 182
					if ((double)(rowArray + row)->ypos + (double)(rowSep * (float)rowHeight) * 0.33 <= (double)((rowArray + numRows)->ypos - height)) {
#line 185
						break;
					}
#line 181
					row--;
				}
#line 194
				rows = numRows - row;
#line 195
				row++;
#line 195
				while (row <= numRows) {
#line 196
					(rowArray + row)->startx = (int)((float)width + macspace[5]);
#line 197
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL - ((float)width + macspace[5]));
#line 195
					row++;
				}
#line 199
				row = 1;
#line 199
				while (row <= numRows) {
#line 200
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx + ((float)rows * ((float)width + macspace[5])) / (float)numRows);
#line 202
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL + ((float)rows * ((float)width + macspace[5])) / (float)numRows);
#line 199
					row++;
				}
#line 205
				(macroArray + macNumber)->mx = width / 2;
#line 206
				(macroArray + macNumber)->my = ((rowArray + numRows)->ypos + rowHeight / 2) - height / 2;
#line 209
				break;
			case 6:
#line 210
				row = numRows;
#line 210
				while (row >= 1) {
#line 211
					if ((double)(rowArray + row)->ypos + (double)(rowSep * (float)rowHeight) * 0.33 <= (double)((rowArray + numRows)->ypos - height)) {
#line 214
						break;
					}
#line 210
					row--;
				}
#line 223
				rows = numRows - row;
#line 224
				row++;
#line 224
				while (row <= numRows) {
#line 225
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx - ((float)width + macspace[6]));
#line 226
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL - ((float)width + macspace[6]));
#line 224
					row++;
				}
#line 228
				row = 1;
#line 228
				while (row <= numRows) {
#line 229
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx + ((float)rows * ((float)width + macspace[6])) / (float)numRows);
#line 231
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL + ((float)rows * ((float)width + macspace[6])) / (float)numRows);
#line 228
					row++;
				}
#line 234
				(macroArray + macNumber)->mx = (int)(((float)(rowArray + numRows)->endx + macspace[6]) + (float)(width / 2));
#line 236
				(macroArray + macNumber)->my = ((rowArray + numRows)->ypos + rowHeight / 2) - height / 2;
#line 239
				break;
			case 7:
#line 240
				row = 1;
#line 240
				while (row <= numRows) {
#line 241
					if ((double)(rowArray + row)->ypos - (double)(rowSep * (float)rowHeight) * 0.33 >= (double)((rowArray + 1)->ypos + height)) {
#line 244
						break;
					}
#line 240
					row++;
				}
#line 253
				rows = row - 1;
#line 254
				row--;
#line 254
				while (row >= 1) {
#line 255
					(rowArray + row)->startx = (int)((float)width + macspace[7]);
#line 256
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL - ((float)width + macspace[7]));
#line 254
					row--;
				}
#line 258
				row = 1;
#line 258
				while (row <= numRows) {
#line 259
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx + ((float)rows * ((float)width + macspace[7])) / (float)numRows);
#line 261
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL + ((float)rows * ((float)width + macspace[7])) / (float)numRows);
#line 258
					row++;
				}
#line 264
				(macroArray + macNumber)->mx = width / 2;
#line 265
				(macroArray + macNumber)->my = ((rowArray + 1)->ypos - rowHeight / 2) + height / 2;
#line 268
				break;
			case 8:
#line 269
				row = 1;
#line 269
				while (row <= numRows) {
#line 270
					if ((double)(rowArray + row)->ypos - (double)(rowSep * (float)rowHeight) * 0.33 >= (double)((rowArray + 1)->ypos + height)) {
#line 273
						break;
					}
#line 269
					row++;
				}
#line 282
				rows = row - 1;
#line 283
				row--;
#line 283
				while (row >= 1) {
#line 284
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx - ((float)width + macspace[8]));
#line 285
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL - ((float)width + macspace[8]));
#line 283
					row--;
				}
#line 287
				row = 1;
#line 287
				while (row <= numRows) {
#line 288
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx + ((float)rows * ((float)width + macspace[8])) / (float)numRows);
#line 290
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL + ((float)rows * ((float)width + macspace[8])) / (float)numRows);
#line 287
					row++;
				}
#line 293
				if (URmacro != 0) {
#line 294
					(macroArray + URmacro)->mx = (int)((float)(macroArray + URmacro)->mx + ((float)rows * ((float)width + macspace[8])) / (float)numRows);
				}
#line 297
				if (Rmacro != 0) {
#line 298
					(macroArray + Rmacro)->mx = (int)((float)(macroArray + Rmacro)->mx + ((float)rows * ((float)width + macspace[8])) / (float)numRows);
				}
#line 301
				(macroArray + macNumber)->mx = (int)(((float)(rowArray + 1)->endx + macspace[8]) + (float)(width / 2));
#line 303
				(macroArray + macNumber)->my = ((rowArray + 1)->ypos - rowHeight / 2) + height / 2;
#line 306
				break;
			case 9:
#line 307
				bot = (rowArray + middleRow)->ypos - height / 2;
#line 308
				top = bot + height;
#line 309
				row = 1;
#line 309
				while (row <= numRows) {
#line 310
					if ((double)((rowArray + row)->ypos - rowHeight / 2) - (double)(rowSep * (float)rowHeight) * 0.33 >= (double)top) {
#line 312
						break;
					}
#line 309
					row++;
				}
#line 315
				trow = row;
#line 316
				row = numRows;
#line 316
				while (row >= 1) {
#line 317
					if ((double)((rowArray + row)->ypos + rowHeight / 2) + (double)(rowSep * (float)rowHeight) * 0.33 <= (double)bot) {
#line 319
						break;
					}
#line 316
					row--;
				}
#line 322
				brow = row;
#line 329
				rows = (trow - brow) - 1;
#line 330
				row = brow + 1;
#line 330
				while (row < trow) {
#line 331
					(rowArray + row)->startx = (int)((float)width + macspace[9]);
#line 332
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL - ((float)width + macspace[9]));
#line 330
					row++;
				}
#line 334
				row = 1;
#line 334
				while (row <= numRows) {
#line 335
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx + ((float)rows * ((float)width + macspace[9])) / (float)numRows);
#line 337
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL + ((float)rows * ((float)width + macspace[9])) / (float)numRows);
#line 334
					row++;
				}
#line 340
				(macroArray + macNumber)->mx = width / 2;
#line 341
				(macroArray + macNumber)->my = (rowArray + middleRow)->ypos;
#line 342
				break;
			case 10:
#line 343
				bot = (rowArray + middleRow)->ypos - height / 2;
#line 344
				top = bot + height;
#line 345
				row = 1;
#line 345
				while (row <= numRows) {
#line 346
					if ((double)((rowArray + row)->ypos - rowHeight / 2) - (double)(rowSep * (float)rowHeight) * 0.33 >= (double)top) {
#line 348
						break;
					}
#line 345
					row++;
				}
#line 351
				trow = row;
#line 352
				row = numRows;
#line 352
				while (row >= 1) {
#line 353
					if ((double)((rowArray + row)->ypos + rowHeight / 2) + (double)(rowSep * (float)rowHeight) * 0.33 <= (double)bot) {
#line 355
						break;
					}
#line 352
					row--;
				}
#line 358
				brow = row;
#line 365
				rows = (trow - brow) - 1;
#line 366
				row = brow + 1;
#line 366
				while (row < trow) {
#line 367
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx - ((float)width + macspace[10]));
#line 368
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL - ((float)width + macspace[10]));
#line 366
					row++;
				}
#line 370
				row = 1;
#line 370
				while (row <= numRows) {
#line 371
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx + ((float)rows * ((float)width + macspace[10])) / (float)numRows);
#line 373
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL + ((float)rows * ((float)width + macspace[10])) / (float)numRows);
#line 370
					row++;
				}
#line 376
				if (URmacro != 0) {
#line 377
					(macroArray + URmacro)->mx = (int)((float)(macroArray + URmacro)->mx + ((float)rows * ((float)width + macspace[10])) / (float)numRows);
				}
#line 380
				(macroArray + macNumber)->mx = (int)(((float)(rowArray + middleRow)->endx + macspace[10]) + (float)(width / 2));
#line 383
				(macroArray + macNumber)->my = (rowArray + middleRow)->ypos;
#line 384
				break;
			case 13:
#line 385
				bot = (rowArray + middleRow)->ypos - height / 2;
#line 386
				top = bot + height;
#line 391
				left = ((rowArray + middleRow)->startx + (rowArray + middleRow)->endx) / 2;
#line 393
				rite = left + width;
#line 394
				row = 1;
#line 394
				while (row <= numRows) {
#line 395
					if ((double)((rowArray + row)->ypos - rowHeight / 2) - (double)(rowSep * (float)rowHeight) * 0.67 >= (double)top) {
#line 397
						break;
					}
#line 394
					row++;
				}
#line 400
				trow = row;
#line 401
				row = numRows;
#line 401
				while (row >= 1) {
#line 402
					if ((double)((rowArray + row)->ypos + rowHeight / 2) + (double)(rowSep * (float)rowHeight) * 0.67 <= (double)bot) {
#line 404
						break;
					}
#line 401
					row--;
				}
#line 407
				brow = row;
#line 414
				rows = (trow - brow) - 1;
#line 415
				row = brow + 1;
#line 415
				while (row < trow) {
#line 416
					(rowArray + row)->endx1 = (int)((float)left - macspace[13]);
#line 417
					(rowArray + row)->startx2 = (int)((float)rite + macspace[13]);
#line 418
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL - ((float)width + (float)2 * macspace[13]));
#line 415
					row++;
				}
#line 420
				row = 1;
#line 420
				while (row <= numRows) {
#line 421
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx + ((float)rows * ((float)width + (float)2 * macspace[13])) / (float)numRows);
#line 423
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL + ((float)rows * ((float)width + (float)2 * macspace[13])) / (float)numRows);
#line 420
					row++;
				}
#line 426
				(macroArray + macNumber)->mx = (left + rite) / 2;
#line 427
				(macroArray + macNumber)->my = (bot + top) / 2;
#line 428
				break;
			case 11:
#line 429
				bot = (rowArray + 1)->ypos - rowHeight / 2;
#line 430
				top = bot + height;
#line 431
				left = ((rowArray + 1)->startx + (rowArray + 1)->endx) / 2 - width / 2;
#line 433
				rite = left + width;
#line 434
				row = 1;
#line 434
				while (row <= numRows) {
#line 435
					if ((double)((rowArray + row)->ypos - rowHeight / 2) - (double)(rowSep * (float)rowHeight) * 0.67 >= (double)top) {
#line 437
						break;
					}
#line 434
					row++;
				}
#line 440
				trow = row;
#line 441
				brow = 0;
#line 448
				rows = (trow - brow) - 1;
#line 449
				row = brow + 1;
#line 449
				while (row < trow) {
#line 450
					(rowArray + row)->endx1 = (int)((float)left - macspace[11]);
#line 451
					(rowArray + row)->startx2 = (int)((float)rite + macspace[11]);
#line 452
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL - ((float)width + (float)2 * macspace[11]));
#line 449
					row++;
				}
#line 454
				row = 1;
#line 454
				while (row <= numRows) {
#line 455
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx + ((float)rows * ((float)width + (float)2 * macspace[11])) / (float)numRows);
#line 457
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL + ((float)rows * ((float)width + (float)2 * macspace[11])) / (float)numRows);
#line 454
					row++;
				}
#line 460
				(macroArray + macNumber)->mx = (left + rite) / 2;
#line 461
				(macroArray + macNumber)->my = (bot + top) / 2;
#line 462
				break;
			case 12:
#line 463
				top = (rowArray + numRows)->ypos + rowHeight / 2;
#line 464
				bot = top - height;
#line 465
				left = ((rowArray + numRows)->startx + (rowArray + numRows)->endx) / 2 - width / 2;
#line 467
				rite = left + width;
#line 468
				trow = numRows + 1;
#line 469
				row = numRows;
#line 469
				while (row >= 1) {
#line 470
					if ((double)((rowArray + row)->ypos + rowHeight / 2) + (double)(rowSep * (float)rowHeight) * 0.67 <= (double)bot) {
#line 472
						break;
					}
#line 469
					row--;
				}
#line 475
				brow = row;
#line 482
				rows = (trow - brow) - 1;
#line 483
				row = brow + 1;
#line 483
				while (row < trow) {
#line 484
					(rowArray + row)->endx1 = (int)((float)left - macspace[12]);
#line 485
					(rowArray + row)->startx2 = (int)((float)rite + macspace[12]);
#line 486
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL - ((float)width + (float)2 * macspace[12]));
#line 483
					row++;
				}
#line 488
				row = 1;
#line 488
				while (row <= numRows) {
#line 489
					(rowArray + row)->endx = (int)((float)(rowArray + row)->endx + ((float)rows * ((float)width + (float)2 * macspace[12])) / (float)numRows);
#line 491
					(rowArray + row)->desiredL = (int)((float)(rowArray + row)->desiredL + ((float)rows * ((float)width + (float)2 * macspace[12])) / (float)numRows);
#line 488
					row++;
				}
#line 494
				(macroArray + macNumber)->mx = (left + rite) / 2;
#line 495
				(macroArray + macNumber)->my = (bot + top) / 2;
#line 496
				break;
			default:
#line 497
				fprintf(fpo, "screwup in finding padside\n");
#line 498
				exit(1);
#line 499
				break;
			}
#line 172
			macro++;
		}
#line 508
		coreHeight = ((rowArray + numRows)->ypos + rowHeight) - rowHeight / 2;
#line 509
		coreWidth = 0;
#line 510
		row = 1;
#line 510
		while (row <= numRows) {
#line 511
			if ((rowArray + row)->endx > coreWidth) {
#line 512
				coreWidth = (rowArray + row)->endx;
			}
#line 510
			row++;
		}
#line 515
		macro = 1;
#line 515
		while (macro <= numMacro) {
#line 516
			pad = *(padArray + macro);
#line 517
			edge = (macroArray + macro)->mx + ((*(carray + pad))->tileptr)->right;
#line 518
			if (edge > coreWidth) {
#line 519
				coreWidth = edge;
			}
#line 515
			macro++;
		}
#line 526
		mbbshift = 0;
#line 527
		height = 0;
#line 528
		width = 0;
#line 529
		count_mbb = 0;
#line 530
		pad = numcells + 1;
#line 530
		while (pad <= numcells + numterms) {
#line 531
			padptr = *(carray + pad);
#line 532
			if (padptr->padside == 15) {
#line 533
				if ((padptr->tileptr)->top - (padptr->tileptr)->bottom > height) {
#line 534
					height = (padptr->tileptr)->top - (padptr->tileptr)->bottom;
				}
#line 536
				width += (padptr->tileptr)->right - (padptr->tileptr)->left;
#line 537
				count_mbb++;
			}
#line 530
			pad++;
		}
#line 540
		if (count_mbb > 0) {
#line 541
			mbbshift = (int)((float)height + rowSep * (float)rowHeight);
#line 545
			row = 1;
#line 545
			while (row <= numRows) {
#line 546
				(rowArray + row)->ypos += mbbshift;
#line 545
				row++;
			}
#line 548
			coreHeight += mbbshift;
#line 549
			if (width > coreWidth) {
#line 550
				coreWidth = width;
			}
#line 552
			space = coreWidth - width;
#line 553
			separation = space / (count_mbb + 1);
#line 554
			if (separation < 0) {
#line 555
				separation = 0;
			}
#line 558
			maxHeight = height;
#line 559
			height = 0;
#line 560
			width = 0;
#line 561
			last = separation;
#line 562
			pad = numcells + 1;
#line 562
			while (pad <= numcells + numterms) {
#line 563
				padptr = *(carray + pad);
#line 564
				if (padptr->padside == 15) {
#line 565
					height = (padptr->tileptr)->top - (padptr->tileptr)->bottom;
#line 566
					width = (padptr->tileptr)->right - (padptr->tileptr)->left;
#line 568
					padptr->cxcenter = last + width / 2;
#line 569
					padptr->cycenter = (maxHeight - height / 2) - 1;
#line 570
					last += separation + width;
				}
#line 562
				pad++;
			}
		}
#line 576
		mttshift = 0;
#line 577
		height = 0;
#line 578
		width = 0;
#line 579
		count_mtt = 0;
#line 580
		pad = numcells + 1;
#line 580
		while (pad <= numcells + numterms) {
#line 581
			padptr = *(carray + pad);
#line 582
			if (padptr->padside == 14) {
#line 583
				if ((padptr->tileptr)->top - (padptr->tileptr)->bottom > height) {
#line 584
					height = (padptr->tileptr)->top - (padptr->tileptr)->bottom;
				}
#line 586
				width += (padptr->tileptr)->right - (padptr->tileptr)->left;
#line 587
				count_mtt++;
			}
#line 580
			pad++;
		}
#line 591
		if (count_mtt > 0) {
#line 592
			mttshift = (int)((float)height + rowSep * (float)rowHeight);
#line 593
			coreHeight += mttshift;
#line 594
			if (width > coreWidth) {
#line 595
				coreWidth = width;
			}
#line 597
			space = coreWidth - width;
#line 598
			separation = space / (count_mtt + 1);
#line 599
			if (separation < 0) {
#line 600
				separation = 0;
			}
#line 603
			height = 0;
#line 604
			width = 0;
#line 605
			last = separation;
#line 606
			pad = numcells + 1;
#line 606
			while (pad <= numcells + numterms) {
#line 607
				padptr = *(carray + pad);
#line 608
				if (padptr->padside == 14) {
#line 609
					height = (padptr->tileptr)->top - (padptr->tileptr)->bottom;
#line 610
					width = (padptr->tileptr)->right - (padptr->tileptr)->left;
#line 612
					padptr->cxcenter = last + width / 2;
#line 613
					padptr->cycenter = (int)(((float)coreHeight + rowSep * (float)rowHeight) + (float)(height / 2));
#line 615
					last += separation + width;
				}
#line 606
				pad++;
			}
		}
#line 620
		return;
	}
}
#line 1 "configure.o"
#pragma merger(0,"./configure.i","")
#line 21 "configure.c"
float *padspace;
#line 22
int *fixLRBT;
#line 38 "configure.c"
float ckt_size_factor;
#line 563
int RtoB(int row___0, int from);
#line 42 "configure.c"
void configure(void)
{
	int tmp;
	int tmp___0;
	char *tmp___1;
	char *tmp___2;
	char *tmp___3;
	char *tmp___4;
	char *tmp___5;

	{
#line 46
		config1();
#line 50
		xshift = 0;
#line 51
		yshift = 0;
#line 52
		zxshift = 0;
#line 53
		zyshift = 0;
#line 54
		pad = numcells + 1;
#line 54
		while (pad <= numcells + numterms) {
#line 55
			if ((*(carray + pad))->padside == 4) {
#line 56
				count = 1;
#line 57
				height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 59
				width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 61
				pad++;
#line 61
				while (pad <= numcells + numterms) {
#line 62
					if ((*(carray + pad))->padside != 4) {
#line 63
						break;
					}
#line 65
					count++;
#line 66
					if (((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom > height) {
#line 68
						height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
					}
#line 71
					width += ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 61
					pad++;
				}
#line 74
				maxHeight = height;
#line 75
				if (*(fixLRBT + 2) == 0) {
#line 76
					space = coreWidth - width;
#line 77
					separation = space / (count + 1);
#line 78
					if (separation < 0) {
#line 79
						separation = 0;
#line 80
						zxshift = ABS(space);
					}
				}
				else {
#line 83
					if (coreWidth >= width) {
#line 83
						space = coreWidth;
					}
					else {
#line 83
						space = width;
					}
				}
#line 88
				yshift = maxHeight + extraSpace;
#line 89
				row = 1;
#line 89
				while (row <= numRows) {
#line 90
					(rowArray + row)->ypos += yshift;
#line 89
					row++;
				}
#line 93
				pad = numcells + 1;
#line 93
				while (pad <= numcells + numterms) {
#line 94
					if ((*(carray + pad))->padside == 4) {
#line 95
						height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 97
						width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 99
						if (*(fixLRBT + 2) == 0) {
#line 100
							(*(carray + pad))->cxcenter = separation + width / 2;
						}
						else {
#line 102
							(*(carray + pad))->cxcenter = (int)(*(padspace + (pad - numcells)) * (float)space);
						}
#line 105
						(*(carray + pad))->cycenter = (maxHeight - height / 2) - 1;
#line 106
						last = separation + width;
#line 108
						pad++;
#line 108
						while (pad <= numcells + numterms) {
#line 109
							if ((*(carray + pad))->padside != 4) {
#line 110
								break;
							}
#line 112
							height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 114
							width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 116
							if (*(fixLRBT + 2) == 0) {
#line 117
								(*(carray + pad))->cxcenter = (last + separation) + width / 2;
							}
							else {
#line 120
								(*(carray + pad))->cxcenter = (int)(*(padspace + (pad - numcells)) * (float)space);
							}
#line 123
							(*(carray + pad))->cycenter = (maxHeight - height / 2) - 1;
#line 125
							last += separation + width;
#line 108
							pad++;
						}
					}
#line 93
					pad++;
				}
			}
#line 54
			pad++;
		}
#line 132
		pad = numcells + 1;
#line 132
		while (pad <= numcells + numterms) {
#line 133
			if ((*(carray + pad))->padside == 2) {
#line 134
				count = 1;
#line 135
				width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 137
				pad++;
#line 137
				while (pad <= numcells + numterms) {
#line 138
					if ((*(carray + pad))->padside != 2) {
#line 139
						break;
					}
#line 141
					count++;
#line 142
					width += ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 137
					pad++;
				}
#line 145
				if (*(fixLRBT + 3) == 0) {
#line 146
					space = coreWidth - width;
#line 147
					separation = space / (count + 1);
#line 148
					if (separation < 0) {
#line 149
						separation = 0;
#line 150
						tmp = ABS(space);
#line 150
						if (tmp > zxshift) {
#line 151
							zxshift = ABS(space);
						}
					}
				}
				else {
#line 155
					if (coreWidth >= width) {
#line 155
						space = coreWidth;
					}
					else {
#line 155
						space = width;
					}
				}
#line 161
				coreTop = (((rowArray + numRows)->ypos + rowHeight / 2) + extraSpace) + mttshift;
#line 164
				pad = numcells + 1;
#line 164
				while (pad <= numcells + numterms) {
#line 165
					if ((*(carray + pad))->padside == 2) {
#line 166
						height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 168
						width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 170
						if (*(fixLRBT + 3) == 0) {
#line 171
							(*(carray + pad))->cxcenter = separation + width / 2;
						}
						else {
#line 173
							(*(carray + pad))->cxcenter = (int)(*(padspace + (pad - numcells)) * (float)space);
						}
#line 176
						(*(carray + pad))->cycenter = coreTop + height / 2;
#line 177
						last = separation + width;
#line 179
						pad++;
#line 179
						while (pad <= numcells + numterms) {
#line 180
							if ((*(carray + pad))->padside != 2) {
#line 181
								break;
							}
#line 183
							height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 185
							width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 187
							if (*(fixLRBT + 3) == 0) {
#line 188
								(*(carray + pad))->cxcenter = (last + separation) + width / 2;
							}
							else {
#line 191
								(*(carray + pad))->cxcenter = (int)(*(padspace + (pad - numcells)) * (float)space);
							}
#line 194
							(*(carray + pad))->cycenter = coreTop + height / 2;
#line 195
							last += separation + width;
#line 179
							pad++;
						}
					}
#line 164
					pad++;
				}
			}
#line 132
			pad++;
		}
#line 202
		pad = numcells + 1;
#line 202
		while (pad <= numcells + numterms) {
#line 203
			if ((*(carray + pad))->padside == 1) {
#line 204
				count = 1;
#line 205
				height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 207
				width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 209
				pad++;
#line 209
				while (pad <= numcells + numterms) {
#line 210
					if ((*(carray + pad))->padside != 1) {
#line 211
						break;
					}
#line 213
					count++;
#line 214
					if (((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left > width) {
#line 216
						width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
					}
#line 219
					height += ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 209
					pad++;
				}
#line 222
				maxWidth = width;
#line 223
				if (*(fixLRBT + 0) == 0) {
#line 224
					space = coreHeight - height;
#line 225
					separation = space / (count + 1);
#line 226
					if (separation < 0) {
#line 227
						separation = 0;
#line 228
						zyshift = ABS(space);
					}
				}
				else {
#line 231
					if (coreHeight >= height) {
#line 231
						space = coreHeight;
					}
					else {
#line 231
						space = height;
					}
				}
#line 236
				xshift = maxWidth + extraSpace;
#line 237
				row = 1;
#line 237
				while (row <= numRows) {
#line 238
					(rowArray + row)->startx += xshift;
#line 239
					(rowArray + row)->endx += xshift;
#line 240
					if ((rowArray + row)->endx1 > 0) {
#line 241
						(rowArray + row)->endx1 += xshift;
#line 242
						(rowArray + row)->startx2 += xshift;
					}
#line 237
					row++;
				}
#line 246
				pad = numcells + 1;
#line 246
				while (pad <= numcells + numterms) {
#line 247
					if ((*(carray + pad))->padside == 1) {
#line 248
						height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 250
						width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 252
						if (*(fixLRBT + 0) == 0) {
#line 253
							(*(carray + pad))->cycenter = ((((rowArray + 1)->ypos - rowHeight / 2) + separation) + height / 2) - mbbshift;
						}
						else {
#line 257
							(*(carray + pad))->cycenter = (int)((float)(((rowArray + 1)->ypos - rowHeight / 2) - mbbshift) + *(padspace + (pad - numcells)) * (float)space);
						}
#line 261
						(*(carray + pad))->cxcenter = (maxWidth - width / 2) - 1;
#line 262
						last = ((((rowArray + 1)->ypos - rowHeight / 2) + separation) + height) - mbbshift;
#line 265
						pad++;
#line 265
						while (pad <= numcells + numterms) {
#line 266
							if ((*(carray + pad))->padside != 1) {
#line 267
								break;
							}
#line 269
							height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 271
							width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 273
							if (*(fixLRBT + 0) == 0) {
#line 274
								(*(carray + pad))->cycenter = (last + separation) + height / 2;
							}
							else {
#line 277
								(*(carray + pad))->cycenter = (int)((float)(((rowArray + 1)->ypos - rowHeight / 2) - mbbshift) + *(padspace + (pad - numcells)) * (float)space);
							}
#line 281
							(*(carray + pad))->cxcenter = (maxWidth - width / 2) - 1;
#line 283
							last += separation + height;
#line 265
							pad++;
						}
					}
#line 246
					pad++;
				}
			}
#line 202
			pad++;
		}
#line 290
		pad = numcells + 1;
#line 290
		while (pad <= numcells + numterms) {
#line 291
			if ((*(carray + pad))->padside == 3) {
#line 292
				count = 1;
#line 293
				height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 296
				pad++;
#line 296
				while (pad <= numcells + numterms) {
#line 297
					if ((*(carray + pad))->padside != 3) {
#line 298
						break;
					}
#line 300
					count++;
#line 301
					height += ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 296
					pad++;
				}
#line 304
				if (*(fixLRBT + 1) == 0) {
#line 305
					space = coreHeight - height;
#line 306
					separation = space / (count + 1);
#line 307
					if (separation < 0) {
#line 308
						separation = 0;
#line 309
						tmp___0 = ABS(space);
#line 309
						if (tmp___0 > zyshift) {
#line 310
							zyshift = ABS(space);
						}
					}
				}
				else {
#line 314
					if (coreHeight >= height) {
#line 314
						space = coreHeight;
					}
					else {
#line 314
						space = height;
					}
				}
#line 316
				coreRite = (coreWidth + xshift) + extraSpace;
#line 318
				pad = numcells + 1;
#line 318
				while (pad <= numcells + numterms) {
#line 319
					if ((*(carray + pad))->padside == 3) {
#line 320
						height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 322
						width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 324
						if (*(fixLRBT + 1) == 0) {
#line 325
							(*(carray + pad))->cycenter = ((((rowArray + 1)->ypos - rowHeight / 2) + separation) + height / 2) - mbbshift;
						}
						else {
#line 329
							(*(carray + pad))->cycenter = (int)((float)(((rowArray + 1)->ypos - rowHeight / 2) - mbbshift) + *(padspace + (pad - numcells)) * (float)space);
						}
#line 333
						(*(carray + pad))->cxcenter = coreRite + width / 2;
#line 334
						last = ((((rowArray + 1)->ypos - rowHeight / 2) + separation) + height) - mbbshift;
#line 337
						pad++;
#line 337
						while (pad <= numcells + numterms) {
#line 338
							if ((*(carray + pad))->padside != 3) {
#line 339
								break;
							}
#line 341
							height = ((*(carray + pad))->tileptr)->top - ((*(carray + pad))->tileptr)->bottom;
#line 343
							width = ((*(carray + pad))->tileptr)->right - ((*(carray + pad))->tileptr)->left;
#line 345
							if (*(fixLRBT + 1) == 0) {
#line 346
								(*(carray + pad))->cycenter = (last + separation) + height / 2;
							}
							else {
#line 349
								(*(carray + pad))->cycenter = (int)((float)(((rowArray + 1)->ypos - rowHeight / 2) - mbbshift) + *(padspace + (pad - numcells)) * (float)space);
							}
#line 353
							(*(carray + pad))->cxcenter = coreRite + width / 2;
#line 354
							last += separation + height;
#line 337
							pad++;
						}
					}
#line 318
					pad++;
				}
			}
#line 290
			pad++;
		}
#line 365
		macro = 1;
#line 365
		while (macro <= numMacro) {
#line 366
			pad = *(padArray + macro);
#line 367
			(*(carray + pad))->cxcenter = (macroArray + macro)->mx + xshift;
#line 368
			(*(carray + pad))->cycenter = ((macroArray + macro)->my + yshift) + mbbshift;
#line 365
			macro++;
		}
#line 371
		pad = numcells + 1;
#line 371
		while (pad <= numcells + numterms) {
#line 372
			if ((*(carray + pad))->padside == 4) {
#line 373
				(*(carray + pad))->cxcenter += xshift;
			}
			else {
#line 372
				if ((*(carray + pad))->padside == 2) {
#line 373
					(*(carray + pad))->cxcenter += xshift;
				}
				else {
#line 375
					if ((*(carray + pad))->padside == 14) {
#line 377
						(*(carray + pad))->cxcenter += xshift;
#line 378
						(*(carray + pad))->cycenter += yshift;
					}
					else {
#line 375
						if ((*(carray + pad))->padside == 15) {
#line 377
							(*(carray + pad))->cxcenter += xshift;
#line 378
							(*(carray + pad))->cycenter += yshift;
						}
					}
				}
			}
#line 371
			pad++;
		}
#line 386
		row = 1;
#line 386
		while (row <= numRows) {
#line 387
			(rowArray + row)->startx += zxshift / 2;
#line 388
			(rowArray + row)->endx += zxshift / 2;
#line 389
			if ((rowArray + row)->endx1 > 0) {
#line 390
				(rowArray + row)->endx1 += zxshift / 2;
#line 391
				(rowArray + row)->startx2 += zxshift / 2;
			}
#line 386
			row++;
		}
#line 394
		macro = 1;
#line 394
		while (macro <= numMacro) {
#line 395
			pad = *(padArray + macro);
#line 396
			(*(carray + pad))->cxcenter += zxshift / 2;
#line 394
			macro++;
		}
#line 398
		pad = numcells + 1;
#line 398
		while (pad <= numcells + numterms) {
#line 399
			if ((*(carray + pad))->padside == 3) {
#line 400
				(*(carray + pad))->cxcenter += zxshift;
			}
			else {
#line 402
				if ((*(carray + pad))->padside == 14) {
#line 404
					(*(carray + pad))->cxcenter += zxshift / 2;
				}
				else {
#line 402
					if ((*(carray + pad))->padside == 15) {
#line 404
						(*(carray + pad))->cxcenter += zxshift / 2;
					}
				}
			}
#line 398
			pad++;
		}
#line 411
		yshift = (maxHeight + rowHeight) + extraSpace;
#line 412
		row = 1;
#line 412
		while (row <= numRows) {
#line 413
			(rowArray + row)->ypos += zyshift / 2;
#line 412
			row++;
		}
#line 415
		macro = 1;
#line 415
		while (macro <= numMacro) {
#line 416
			pad = *(padArray + macro);
#line 417
			(*(carray + pad))->cycenter += zyshift / 2;
#line 415
			macro++;
		}
#line 419
		pad = numcells + 1;
#line 419
		while (pad <= numcells + numterms) {
#line 420
			if ((*(carray + pad))->padside == 2) {
#line 421
				(*(carray + pad))->cycenter += zyshift;
			}
			else {
#line 423
				if ((*(carray + pad))->padside == 14) {
#line 425
					(*(carray + pad))->cycenter += zyshift / 2;
				}
				else {
#line 423
					if ((*(carray + pad))->padside == 15) {
#line 425
						(*(carray + pad))->cycenter += zyshift / 2;
					}
				}
			}
#line 419
			pad++;
		}
#line 437
		block = 0;
#line 438
		row = 1;
#line 438
		while (row <= numRows) {
#line 439
			block++;
#line 440
			if ((rowArray + row)->endx1 > 0) {
#line 441
				block++;
			}
#line 438
			row++;
		}
#line 444
		totalBlock = block;
#line 445
		oldbarray = barray;
#line 447
		tmp___1 = safe_malloc((unsigned int)(totalBlock + 1) * sizeof(int));
#line 447
		blkToRow = (int *)tmp___1;
#line 448
		tmp___2 = safe_malloc((unsigned int)(totalBlock + 1) * sizeof(BBOXPTR));
#line 448
		barray = (BBOXPTR *)tmp___2;
#line 449
		block = 1;
#line 449
		while (block <= totalBlock) {
#line 450
			tmp___3 = safe_malloc(sizeof(BBOX));
#line 450
			* (barray + block) = (struct blockbox *)tmp___3;
#line 449
			block++;
		}
#line 453
		block = 0;
#line 454
		row = 1;
#line 454
		while (row <= numRows) {
#line 455
			boxptr = *(oldbarray + row);
#line 456
			if ((rowArray + row)->endx1 > 0) {
#line 457
				block++;
#line 458
				* (blkToRow + block) = row;
#line 459
				(*(barray + block))->bxcenter = ((rowArray + row)->startx + (rowArray + row)->endx1) / 2;
#line 461
				(*(barray + block))->bycenter = (rowArray + row)->ypos;
#line 462
				(*(barray + block))->bleft = (rowArray + row)->startx - (*(barray + block))->bxcenter;
#line 464
				(*(barray + block))->bright = (rowArray + row)->endx1 - (*(barray + block))->bxcenter;
#line 466
				(*(barray + block))->bbottom = boxptr->bbottom;
#line 467
				(*(barray + block))->btop = boxptr->btop;
#line 468
				(*(barray + block))->bheight = boxptr->btop - boxptr->bbottom;
#line 469
				(*(barray + block))->blength = (rowArray + row)->endx1 - (rowArray + row)->startx;
#line 471
				(*(barray + block))->bclass = boxptr->bclass;
#line 472
				(*(barray + block))->borient = boxptr->borient;
#line 473
				(*(barray + block))->oldsize = 0;
#line 475
				block++;
#line 476
				* (blkToRow + block) = row;
#line 477
				(*(barray + block))->bxcenter = ((rowArray + row)->startx2 + (rowArray + row)->endx) / 2;
#line 479
				(*(barray + block))->bycenter = (rowArray + row)->ypos;
#line 480
				(*(barray + block))->bleft = (rowArray + row)->startx2 - (*(barray + block))->bxcenter;
#line 482
				(*(barray + block))->bright = (rowArray + row)->endx - (*(barray + block))->bxcenter;
#line 484
				(*(barray + block))->bbottom = boxptr->bbottom;
#line 485
				(*(barray + block))->btop = boxptr->btop;
#line 486
				(*(barray + block))->bheight = boxptr->btop - boxptr->bbottom;
#line 487
				(*(barray + block))->blength = (rowArray + row)->endx - (rowArray + row)->startx2;
#line 489
				(*(barray + block))->bclass = boxptr->bclass;
#line 490
				(*(barray + block))->borient = boxptr->borient;
#line 492
				ratio = (float)(*(barray + (block - 1)))->blength / (float)((*(barray + (block - 1)))->blength + (*(barray + block))->blength);
#line 494
				(*(barray + block))->desire = 1 + (int)((1.0 - (double)ratio) * (double)(rowArray + row)->desiredL);
#line 496
				(*(barray + (block - 1)))->desire = 1 + (int)(ratio * (float)(rowArray + row)->desiredL);
#line 498
				(*(barray + block))->oldsize = 0;
			}
			else {
#line 500
				block++;
#line 501
				* (blkToRow + block) = row;
#line 502
				(*(barray + block))->bxcenter = ((rowArray + row)->startx + (rowArray + row)->endx) / 2;
#line 504
				(*(barray + block))->bycenter = (rowArray + row)->ypos;
#line 505
				(*(barray + block))->bleft = (rowArray + row)->startx - (*(barray + block))->bxcenter;
#line 507
				(*(barray + block))->bright = (rowArray + row)->endx - (*(barray + block))->bxcenter;
#line 509
				(*(barray + block))->bbottom = boxptr->bbottom;
#line 510
				(*(barray + block))->btop = boxptr->btop;
#line 511
				(*(barray + block))->bheight = boxptr->btop - boxptr->bbottom;
#line 512
				(*(barray + block))->blength = (rowArray + row)->endx - (rowArray + row)->startx;
#line 514
				(*(barray + block))->bclass = boxptr->bclass;
#line 515
				(*(barray + block))->borient = boxptr->borient;
#line 516
				(*(barray + block))->desire = (rowArray + row)->desiredL;
#line 517
				(*(barray + block))->oldsize = 0;
			}
#line 454
			row++;
		}
#line 523
		row = 1;
#line 523
		while (row <= numblock) {
#line 524
			safe_free(*(oldbarray + row));
#line 523
			row++;
		}
#line 526
		safe_free(oldbarray);
#line 527
		numblock = totalBlock;
#line 530
		fprintf(fpo, "\n******************\nBLOCK DATA\n");
#line 531
		desiredL = 0;
#line 532
		block = 1;
#line 532
		while (block <= numblock) {
#line 533
			desiredL += (*(barray + block))->desire;
#line 534
			fprintf(fpo, "block:%d desire:%d\n", block, (*(barray + block))->desire);
#line 532
			block++;
		}
#line 540
		fprintf(fpo, "Total Desired Length: %d\n", desiredL);
#line 541
		ckt_size_factor = (float)desiredL;
#line 548
		tmp___4 = safe_malloc((unsigned int)(numblock + 1) * sizeof(int));
#line 548
		filledTo = (int *)tmp___4;
#line 549
		tmp___5 = safe_malloc((unsigned int)(numblock + 1) * sizeof(int));
#line 549
		endRow = (int *)tmp___5;
#line 550
		row = 1;
#line 550
		while (row <= numblock) {
#line 551
			* (filledTo + row) = (*(barray + row))->bxcenter + (*(barray + row))->bleft;
#line 552
			* (endRow + row) = (*(barray + row))->bxcenter + (*(barray + row))->bright;
#line 550
			row++;
		}
#line 557
		cell = 1;
#line 557
		while (cell <= numcells) {
#line 558
			cellptr = *(carray + cell);
#line 559
			row = cellptr->cblock;
#line 560
			if (row == 0) {
				goto __Cont;
			}
#line 563
			blk = RtoB(row, cellptr->cycenter);
#line 565
			borient = (*(barray + blk))->borient;
#line 566
			cellptr->cblock = blk;
#line 568
			width = (cellptr->tileptr)->right - (cellptr->tileptr)->left;
#line 569
			if (cellptr->cycenter > 0) {
#line 570
				(*(carray + cell))->cxcenter = (((*(barray + blk))->bxcenter + (*(barray + blk))->bleft) + cellptr->cxcenter) + width / 2;
#line 573
				(*(carray + cell))->cycenter = (*(barray + blk))->bycenter;
			}
			else {
#line 575
				(*(carray + cell))->cxcenter = (((*(barray + blk))->bxcenter + (*(barray + blk))->bright) + cellptr->cxcenter) - (width - width / 2);
#line 578
				(*(carray + cell))->cycenter = (*(barray + blk))->bycenter;
			}
#line 581
			if (borient == 2) {
#line 582
				cellptr->corient = (char)1;
			}
			else {
#line 584
				cellptr->corient = (char)0;
			}
		__Cont: /* CIL Label */
#line 557
			cell++;
		}
#line 591
		cell = 1;
#line 591
		while (cell <= numcells) {
#line 592
			if ((*(carray + cell))->cblock != 0) {
				goto __Cont___0;
			}
#line 598
			empty = -32000;
#line 599
			row = 1;
#line 599
			while (row <= numblock) {
#line 600
				if (*(endRow + row) - *(filledTo + row) > empty) {
#line 601
					empty = *(endRow + row) - *(filledTo + row);
#line 602
					block = row;
				}
#line 599
				row++;
			}
#line 605
			borient = (*(barray + block))->borient;
#line 606
			width = ((*(carray + cell))->tileptr)->right - ((*(carray + cell))->tileptr)->left;
#line 607
			(*(carray + cell))->cblock = block;
#line 608
			if (borient > 0) {
#line 609
				(*(carray + cell))->cxcenter = *(filledTo + block) + width / 2;
#line 610
				(*(carray + cell))->cycenter = (*(barray + block))->bycenter;
#line 611
				if (borient == 2) {
#line 612
					(*(carray + cell))->corient = (char)1;
				}
				else {
#line 614
					(*(carray + cell))->corient = (char)0;
				}
			}
			else {
#line 617
				(*(carray + cell))->cycenter = *(filledTo + block) + width / 2;
#line 618
				(*(carray + cell))->cxcenter = (*(barray + block))->bxcenter;
#line 619
				if (borient == -2) {
#line 620
					(*(carray + cell))->corient = (char)4;
				}
				else {
#line 622
					(*(carray + cell))->corient = (char)7;
				}
			}
#line 625
			* (filledTo + block) += width;
		__Cont___0: /* CIL Label */
#line 591
			cell++;
		}
#line 631
		return;
	}
}
#line 634 "configure.c"
int RtoB(int row___0, int from)
{
	int y;
	int block___0;
	int block1;
	int block2;
	int endx1;
	int startx2;

	{
#line 638
		y = (rowArray + row___0)->ypos;
#line 639
		block1 = 0;
#line 640
		block2 = 0;
#line 641
		block___0 = 1;
#line 641
		while (block___0 <= numblock) {
#line 642
			if ((*(barray + block___0))->bycenter == y) {
#line 643
				block1 = block___0;
#line 644
				break;
			}
#line 641
			block___0++;
		}
#line 647
		block___0++;
#line 647
		while (block___0 <= numblock) {
#line 648
			if ((*(barray + block___0))->bycenter == y) {
#line 649
				block2 = block___0;
#line 650
				break;
			}
#line 647
			block___0++;
		}
#line 653
		if (block1 == 0) {
#line 654
			fprintf(fpo, "RtoB failed to find block corresponding");
#line 655
			fprintf(fpo, " to row:%d\n", row___0);
#line 656
			exit(1);
		}
#line 658
		if (block2 == 0) {
#line 659
			block___0 = block1;
		}
		else {
#line 661
			endx1 = (*(barray + block1))->bxcenter + (*(barray + block1))->bright;
#line 662
			startx2 = (*(barray + block2))->bxcenter + (*(barray + block2))->bleft;
#line 663
			if (from > 0) {
#line 664
				if (endx1 < startx2) {
#line 665
					block___0 = block1;
				}
				else {
#line 667
					block___0 = block2;
				}
			}
			else {
#line 670
				if (startx2 > endx1) {
#line 671
					block___0 = block2;
				}
				else {
#line 673
					block___0 = block1;
				}
			}
		}
#line 677
		return (block___0);
	}
}
#line 1 "configuref.o"
#pragma merger(0,"./configuref.i","")
#line 3 "configuref.c"
int old_feed_length = 0;
#line 5 "configuref.c"
void configuref(int feed_length)
{
	CBOXPTR padptr;
	int core_left;
	int core_right;
	int core_span;
	int row___0;
	int pad___0;
	int right;
	int shift_amount;

	{
#line 12
		shift_amount = feed_length / numRows - old_feed_length / numRows;
#line 13
		if (shift_amount == 0) {
#line 14
			row___0 = 1;
#line 14
			while (row___0 <= numRows) {
#line 15
				(*(barray + row___0))->oldsize = 0;
#line 14
				row___0++;
			}
#line 17
			return;
		}
#line 20
		core_right = 0;
#line 21
		core_left = 10000000;
#line 22
		row___0 = 1;
#line 22
		while (row___0 <= numRows) {
#line 23
			(*(barray + row___0))->bright += shift_amount;
#line 24
			(*(barray + row___0))->blength += shift_amount;
#line 25
			(*(barray + row___0))->desire += shift_amount;
#line 26
			(*(barray + row___0))->oldsize = 0;
#line 27
			(rowArray + row___0)->endx += shift_amount;
#line 28
			if ((rowArray + row___0)->startx < core_left) {
#line 29
				core_left = (rowArray + row___0)->startx;
			}
#line 31
			if ((rowArray + row___0)->endx > core_right) {
#line 32
				core_right = (rowArray + row___0)->endx;
			}
#line 22
			row___0++;
		}
#line 35
		core_span = core_right - core_left;
#line 37
		pad___0 = numcells + 1;
#line 37
		while (pad___0 <= numcells + numterms) {
#line 38
			padptr = *(carray + pad___0);
#line 39
			if (padptr->padside == 3) {
#line 41
				padptr->cxcenter += shift_amount;
			}
			else {
#line 39
				if (padptr->padside == 10) {
#line 41
					padptr->cxcenter += shift_amount;
				}
				else {
#line 39
					if (padptr->padside == 6) {
#line 41
						padptr->cxcenter += shift_amount;
					}
					else {
#line 39
						if (padptr->padside == 8) {
#line 41
							padptr->cxcenter += shift_amount;
						}
						else {
#line 42
							if (padptr->padside == 2) {
#line 44
								right = (padptr->cxcenter + (padptr->tileptr)->right) - core_left;
#line 45
								padptr->cxcenter += (int)(((float)right / (float)core_span) * (float)shift_amount);
							}
							else {
#line 42
								if (padptr->padside == 4) {
#line 44
									right = (padptr->cxcenter + (padptr->tileptr)->right) - core_left;
#line 45
									padptr->cxcenter += (int)(((float)right / (float)core_span) * (float)shift_amount);
								}
								else {
#line 42
									if (padptr->padside == 14) {
#line 44
										right = (padptr->cxcenter + (padptr->tileptr)->right) - core_left;
#line 45
										padptr->cxcenter += (int)(((float)right / (float)core_span) * (float)shift_amount);
									}
									else {
#line 42
										if (padptr->padside == 15) {
#line 44
											right = (padptr->cxcenter + (padptr->tileptr)->right) - core_left;
#line 45
											padptr->cxcenter += (int)(((float)right / (float)core_span) * (float)shift_amount);
										}
									}
								}
							}
						}
					}
				}
			}
#line 37
			pad___0++;
		}
#line 51
		old_feed_length = feed_length;
#line 53
		return;
	}
}
#line 1 "controlf.o"
#pragma merger(0,"./controlf.i","")
#line 8 "controlf.c"
int countf(void);
#line 10
int findcostf(void);
#line 3 "controlf.c"
int controlf(void)
{
	int feed_length;

	{
#line 8
		feed_length = countf();
#line 9
		configuref(feed_length);
#line 10
		funccost = findcostf();
#line 12
		return (feed_length / fdWidth);
	}
}
#line 1 "countf.o"
#pragma merger(0,"./countf.i","")
#line 3 "countf.c"
int *xfeeds_in_row;
#line 4 "countf.c"
int est_fds;
#line 5 "countf.c"
int **row_map;
#line 6 "countf.c"
int num_calls = 0;
#line 21
int prep_feed_count_1(void);
#line 28
int insert_row(int flag);
#line 31
int prep_feed_count(void);
#line 60
int feed_situation(int row___0, int net);
#line 8 "countf.c"
int countf(void)
{
	NBOXPTR netptr;
	CBOXPTR cellptr___0;
	int check;
	int a___0;
	int value;
	int net;
	int i;
	int row___0;
	int toprow;
	int botrow;
	int TOP_ROW_FOR_NET;
	int orig_toprow;
	int orig_botrow;
	char *tmp;
	char *tmp___0;

	{
#line 19
		if (num_calls == 0) {
#line 20
			num_calls = 1;
#line 21
			prep_feed_count_1();
#line 22
			tmp = safe_malloc((unsigned int)(numRows + 2) * sizeof(int *));
#line 22
			row_map = (int **)tmp;
#line 24
			row___0 = 0;
#line 24
			while (row___0 <= numRows + 1) {
#line 25
				tmp___0 = safe_malloc(3U * sizeof(int));
#line 25
				* (row_map + row___0) = (int *)tmp___0;
#line 24
				row___0++;
			}
#line 28
			insert_row(0);
		}
		else {
#line 31
			prep_feed_count();
#line 32
			insert_row(1);
		}
#line 36
		net = 1;
#line 36
		while (net <= numnets) {
#line 37
			netptr = (*(netarray + net))->netptr;
#line 37
			if ((unsigned int)netptr == (unsigned int)((void *)0)) {
				goto __Cont;
			}
#line 40
			i = 0;
#line 40
			while (i <= numRows + 1) {
#line 41
				* (*(row_map + i) + 1) = -1000;
#line 42
				* (*(row_map + i) + 2) = -2;
#line 40
				i++;
			}
#line 44
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 45
				cellptr___0 = *(carray + netptr->cell);
#line 46
				if (netptr->cell > numcells) {
#line 46
					if (cellptr___0->padside == 1) {
						goto __Cont___0;
					}
					else {
#line 46
						if (cellptr___0->padside == 9) {
							goto __Cont___0;
						}
						else {
#line 46
							if (cellptr___0->padside == 5) {
								goto __Cont___0;
							}
							else {
#line 46
								if (cellptr___0->padside == 7) {
									goto __Cont___0;
								}
								else {
#line 46
									if (cellptr___0->padside == 3) {
										goto __Cont___0;
									}
									else {
#line 46
										if (cellptr___0->padside == 10) {
											goto __Cont___0;
										}
										else {
#line 46
											if (cellptr___0->padside == 6) {
												goto __Cont___0;
											}
											else {
#line 46
												if (cellptr___0->padside == 8) {
													goto __Cont___0;
												}
											}
										}
									}
								}
							}
						}
					}
				}
#line 57
				row___0 = netptr->row;
#line 58
				* (*(row_map + row___0) + 1) = netptr->xpos;
#line 59
				if (*(*(row_map + row___0) + 2) == -2) {
#line 60
					* (*(row_map + row___0) + 2) = feed_situation(row___0, net);
				}
			__Cont___0: /* CIL Label */
#line 44
				netptr = netptr->nterm;
			}
#line 64
			botrow = 0;
#line 65
			toprow = numRows + 1;
#line 66
			while (botrow <= numRows + 1) {
#line 67
				if (*(*(row_map + botrow) + 1) != -1000) {
#line 68
					break;
				}
#line 66
				botrow++;
			}
#line 71
			while (toprow >= 0) {
#line 72
				if (*(*(row_map + toprow) + 1) != -1000) {
#line 73
					break;
				}
#line 71
				toprow--;
			}
#line 77
			orig_toprow = toprow;
#line 78
			orig_botrow = botrow;
#line 79
			netptr = (*(netarray + net))->netptr;
#line 80
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 81
				if (netptr->cell <= numcells) {
					goto __Cont___1;
				}
#line 84
				cellptr___0 = *(carray + netptr->cell);
#line 85
				if (cellptr___0->padside != 1) {
#line 85
					if (cellptr___0->padside != 9) {
#line 85
						if (cellptr___0->padside != 5) {
#line 85
							if (cellptr___0->padside != 7) {
#line 85
								if (cellptr___0->padside != 3) {
#line 85
									if (cellptr___0->padside != 10) {
#line 85
										if (cellptr___0->padside != 6) {
#line 85
											if (cellptr___0->padside != 8) {
												goto __Cont___1;
											}
										}
									}
								}
							}
						}
					}
				}
#line 95
				row___0 = netptr->row;
#line 96
				if (row___0 <= orig_toprow) {
#line 96
					if (row___0 >= orig_botrow) {
						goto __Cont___1;
					}
				}
#line 99
				if (row___0 > toprow) {
#line 100
					toprow = row___0;
				}
#line 102
				if (row___0 < botrow) {
#line 103
					botrow = row___0;
				}
#line 105
				* (*(row_map + row___0) + 1) = netptr->xpos;
#line 106
				if (*(*(row_map + row___0) + 2) == -2) {
#line 107
					* (*(row_map + row___0) + 2) = feed_situation(row___0, net);
				}
			__Cont___1: /* CIL Label */
#line 80
				netptr = netptr->nterm;
			}
#line 111
			if (toprow != botrow) {
#line 112
				row___0 = toprow;
#line 113
				TOP_ROW_FOR_NET = 1;
#line 114
				row___0--;
#line 114
				while (row___0 >= botrow) {
#line 115
					if (*(*(row_map + row___0) + 1) == -1000) {
						goto __Cont___2;
					}
#line 119
					if (TOP_ROW_FOR_NET == 1) {
#line 120
						if (*(*(row_map + toprow) + 2) == 1) {
#line 122
							(*(feeds_in_row + toprow))++;
#line 123
							(*(xfeeds_in_row + toprow))++;
						}
						else {
#line 120
							if (*(*(row_map + toprow) + 2) == 3) {
#line 122
								(*(feeds_in_row + toprow))++;
#line 123
								(*(xfeeds_in_row + toprow))++;
							}
						}
					}
#line 126
					if (row___0 > botrow) {
#line 127
						if (*(*(row_map + row___0) + 2) != 4) {
#line 128
							(*(feeds_in_row + row___0))++;
#line 129
							(*(xfeeds_in_row + row___0))++;
						}
					}
#line 132
					if (row___0 == botrow) {
#line 133
						if (*(*(row_map + botrow) + 2) == 2) {
#line 135
							(*(feeds_in_row + botrow))++;
#line 136
							(*(xfeeds_in_row + botrow))++;
						}
						else {
#line 133
							if (*(*(row_map + botrow) + 2) == 3) {
#line 135
								(*(feeds_in_row + botrow))++;
#line 136
								(*(xfeeds_in_row + botrow))++;
							}
						}
					}
#line 139
					check = (toprow - row___0) - 1;
#line 140
					if (check != 0) {
#line 141
						a___0 = toprow - 1;
#line 141
						while (a___0 > row___0) {
#line 142
							(*(feeds_in_row + a___0))++;
#line 143
							(*(xfeeds_in_row + a___0))++;
#line 141
							a___0--;
						}
					}
#line 146
					toprow = row___0;
#line 147
					TOP_ROW_FOR_NET = 0;
				__Cont___2: /* CIL Label */
#line 114
					row___0--;
				}
			}
			else {
#line 151
				if (*(*(row_map + toprow) + 2) == 3) {
#line 152
					(*(feeds_in_row + toprow))++;
#line 153
					(*(xfeeds_in_row + toprow))++;
				}
			}
		__Cont: /* CIL Label */
#line 36
			net++;
		}
#line 158
		est_fds = 0;
#line 159
		row___0 = 1;
#line 159
		while (row___0 <= numRows) {
#line 160
			if (*(xfeeds_in_row + row___0) > 0) {
#line 161
				est_fds += *(xfeeds_in_row + row___0);
			}
#line 163
			value = (*(feeds_in_row + row___0) * fdWidth) / binWidth;
#line 164
			if (*(feeds_in_row + row___0) > 0) {
#line 165
				* (feeds_in_row + row___0) = 1 + value;
			}
			else {
#line 168
				* (feeds_in_row + row___0) = 0;
			}
#line 159
			row___0++;
		}
#line 171
		value = 0;
#line 172
		row___0 = 1;
#line 172
		while (row___0 <= numRows) {
#line 173
			value += *(feeds_in_row + row___0);
#line 172
			row___0++;
		}
#line 175
		return (value * binWidth);
	}
}
#line 180 "countf.c"
int prep_feed_count_1(void)
{
	TEBOXPTR pinptr;
	int cell___0;
	int corient;
	int offset;
	int row___0;
	float total_row_len;
	char *tmp;
	char *tmp___0;
	int tmp___1;

	{
#line 187
		total_row_len = (float)0;
#line 188
		row___0 = 1;
#line 188
		while (row___0 <= numRows) {
#line 189
			total_row_len += (float)(*(barray + row___0))->blength;
#line 188
			row___0++;
		}
#line 191
		tmp = safe_malloc((unsigned int)(1 + numRows) * sizeof(int));
#line 191
		feeds_in_row = (int *)tmp;
#line 192
		tmp___0 = safe_malloc((unsigned int)(1 + numRows) * sizeof(int));
#line 192
		xfeeds_in_row = (int *)tmp___0;
#line 194
		offset = -((int)((double)((float)implicit_feed_count) * 0.90));
#line 195
		row___0 = 1;
#line 195
		while (row___0 <= numRows) {
#line 196
			* (feeds_in_row + row___0) = (int)((float)offset * ((float)(*(barray + row___0))->blength / total_row_len));
#line 198
			* (xfeeds_in_row + row___0) = 0;
#line 195
			row___0++;
		}
#line 205
		cell___0 = 1;
#line 205
		while (cell___0 <= numcells + numterms) {
#line 206
			if (cell___0 <= numcells) {
#line 207
				pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 208
				corient = (int)(*(carray + cell___0))->corient;
#line 209
				while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 210
					(*(tearray + pinptr->cellterm))->unequiv = (char)pinptr->ue;
#line 211
					(*(tearray + pinptr->cellterm))->cell = cell___0;
#line 212
					tmp___1 = ABS(pinptr->typos[corient % 2]);
#line 212
					if (tmp___1 > 1) {
#line 213
						if (pinptr->typos[corient % 2] > 0) {
#line 214
							(*(tearray + pinptr->cellterm))->pinloc = (char)1;
						}
						else {
#line 217
							(*(tearray + pinptr->cellterm))->pinloc = (char)-1;
						}
					}
					else {
#line 221
						(*(tearray + pinptr->cellterm))->pinloc = (char)0;
					}
#line 209
					pinptr = pinptr->nextterm;
				}
			}
			else {
#line 225
				if (cell___0 > numcells) {
#line 226
					pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 227
					while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 228
						(*(tearray + pinptr->cellterm))->unequiv = (char)pinptr->ue;
#line 229
						(*(tearray + pinptr->cellterm))->cell = cell___0;
#line 230
						(*(tearray + pinptr->cellterm))->pinloc = (char)0;
#line 227
						pinptr = pinptr->nextterm;
					}
				}
			}
#line 205
			cell___0++;
		}
#line 234
		return;
	}
}
#line 238 "countf.c"
int prep_feed_count(void)
{
	TEBOXPTR pinptr;
	int cell___0;
	int corient;
	int offset;
	int row___0;
	float total_row_len;
	int tmp;

	{
#line 245
		total_row_len = (float)0;
#line 246
		row___0 = 1;
#line 246
		while (row___0 <= numRows) {
#line 247
			total_row_len += (float)(*(barray + row___0))->blength;
#line 246
			row___0++;
		}
#line 249
		offset = -((int)((double)((float)implicit_feed_count) * 0.90));
#line 250
		row___0 = 1;
#line 250
		while (row___0 <= numRows) {
#line 251
			* (feeds_in_row + row___0) = (int)((float)offset * ((float)(*(barray + row___0))->blength / total_row_len));
#line 253
			* (xfeeds_in_row + row___0) = 0;
#line 250
			row___0++;
		}
#line 260
		cell___0 = 1;
#line 260
		while (cell___0 <= numcells) {
#line 261
			pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 262
			corient = (int)(*(carray + cell___0))->corient;
#line 263
			while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 264
				tmp = ABS(pinptr->typos[corient % 2]);
#line 264
				if (tmp > 1) {
#line 265
					if (pinptr->typos[corient % 2] > 0) {
#line 266
						(*(tearray + pinptr->cellterm))->pinloc = (char)1;
					}
					else {
#line 268
						(*(tearray + pinptr->cellterm))->pinloc = (char)-1;
					}
				}
				else {
#line 271
					(*(tearray + pinptr->cellterm))->pinloc = (char)0;
				}
#line 263
				pinptr = pinptr->nextterm;
			}
#line 260
			cell___0++;
		}
#line 275
		return;
	}
}
#line 281 "countf.c"
int insert_row(int flag)
{
	TEBOXPTR pinptr;
	int row___0;
	int cell___0;
	int pad___0;
	int yc;
	int yb;
	int blk___0;

	{
#line 289
		cell___0 = 1;
#line 289
		while (cell___0 <= numcells) {
#line 290
			row___0 = (*(carray + cell___0))->cblock;
#line 291
			pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 292
			while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 293
				(*(tearray + pinptr->cellterm))->row = row___0;
#line 292
				pinptr = pinptr->nextterm;
			}
#line 289
			cell___0++;
		}
#line 296
		if (flag == 0) {
#line 297
			pad___0 = numcells + 1;
#line 297
			while (pad___0 <= numcells + numterms) {
#line 298
				if ((*(carray + pad___0))->padside == 2) {
					goto _L___0;
				}
				else {
#line 298
					if ((*(carray + pad___0))->padside == 14) {
					_L___0: /* CIL Label */
#line 299
						row___0 = numRows + 1;
#line 300
						pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 301
						while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 302
							(*(tearray + pinptr->cellterm))->row = row___0;
#line 301
							pinptr = pinptr->nextterm;
						}
					}
					else {
#line 304
						if ((*(carray + pad___0))->padside == 4) {
							goto _L;
						}
						else {
#line 304
							if ((*(carray + pad___0))->padside == 15) {
							_L: /* CIL Label */
#line 306
								row___0 = 0;
#line 307
								pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 308
								while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 309
									(*(tearray + pinptr->cellterm))->row = row___0;
#line 308
									pinptr = pinptr->nextterm;
								}
							}
							else {
#line 312
								pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 313
								while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 314
									yc = (*(carray + pad___0))->cycenter + pinptr->typos[1];
#line 315
									blk___0 = 1;
#line 315
									while (blk___0 <= numRows) {
#line 316
										if ((rowArray + blk___0)->ypos >= yc) {
#line 317
											break;
										}
#line 315
										blk___0++;
									}
#line 320
									if (blk___0 == 1) {
#line 321
										row___0 = 1;
									}
									else {
#line 322
										if (blk___0 > numRows) {
#line 323
											row___0 = numRows;
										}
										else {
#line 325
											yb = (rowArray + blk___0)->ypos;
#line 326
											if (yb - yc < yc - (rowArray + (blk___0 - 1))->ypos) {
#line 327
												row___0 = blk___0;
											}
											else {
#line 329
												row___0 = blk___0 - 1;
											}
										}
									}
#line 332
									(*(tearray + pinptr->cellterm))->row = row___0;
#line 313
									pinptr = pinptr->nextterm;
								}
							}
						}
					}
				}
#line 297
				pad___0++;
			}
		}
#line 337
		return;
	}
}
#line 343 "countf.c"
int feed_situation(int row___0, int net)
{
	NBOXPTR nptr;
	CBOXPTR cellptr___0;
	int pinup;
	int pindown;
	int pinloc;

	{
#line 359
		pinup = 0;
#line 360
		pindown = 0;
#line 361
		nptr = (*(netarray + net))->netptr;
#line 362
		while ((unsigned int)nptr != (unsigned int)((void *)0)) {
#line 363
			if (nptr->row != row___0) {
				goto __Cont;
			}
			else {
#line 363
				if ((int)nptr->unequiv == 1) {
					goto __Cont;
				}
			}
#line 366
			cellptr___0 = *(carray + nptr->cell);
#line 367
			if (nptr->cell > numcells) {
#line 367
				if (cellptr___0->padside == 1) {
					goto __Cont;
				}
				else {
#line 367
					if (cellptr___0->padside == 9) {
						goto __Cont;
					}
					else {
#line 367
						if (cellptr___0->padside == 5) {
							goto __Cont;
						}
						else {
#line 367
							if (cellptr___0->padside == 7) {
								goto __Cont;
							}
							else {
#line 367
								if (cellptr___0->padside == 3) {
									goto __Cont;
								}
								else {
#line 367
									if (cellptr___0->padside == 10) {
										goto __Cont;
									}
									else {
#line 367
										if (cellptr___0->padside == 6) {
											goto __Cont;
										}
										else {
#line 367
											if (cellptr___0->padside == 8) {
												goto __Cont;
											}
										}
									}
								}
							}
						}
					}
				}
			}
#line 378
			pinloc = (int)nptr->pinloc;
#line 379
			if (pinloc == 0) {
#line 380
				return (4);
			}
#line 382
			if (pinloc > 0) {
#line 383
				pinup = 1;
			}
			else {
#line 385
				pindown = 1;
			}
		__Cont: /* CIL Label */
#line 362
			nptr = nptr->nterm;
		}
#line 388
		if (pinup == 1) {
#line 388
			if (pindown == 0) {
#line 389
				return (1);
			}
			else {
				goto _L___0;
			}
		}
		else {
		_L___0: /* CIL Label */
#line 390
			if (pinup == 0) {
#line 390
				if (pindown == 1) {
#line 391
					return (2);
				}
				else {
					goto _L;
				}
			}
			else {
			_L: /* CIL Label */
#line 392
				if (pinup == 1) {
#line 392
					if (pindown == 1) {
#line 393
						return (3);
					}
					else {
#line 395
						return (0);
					}
				}
				else {
#line 395
					return (0);
				}
			}
		}
	}
}
#line 1 "date.o"
#pragma merger(0,"./date.i","")
#line 5 "date.c"
char *strclone(char *str);
#line 3 "date.c"
char *getCompileDate(void)
{
	char *tmp;

	{
#line 7
		tmp = strclone("Mon Jan 25 18:50:36 EST 1988");
#line 7
		return (tmp);
	}
}
#line 1 "debug.o"
#pragma merger(0,"./debug.i","")
#line 179 "/usr/include/stdio.h"
extern int (__attribute__((__cdecl__)) printf)(char const   *, ...);
#line 252 "standard.h"
FILE *twopen(int a___0, int b___0, int c);
#line 253
void twclose(int a___0);
#line 8 "debug.c"
void cellbox_data(int first_cell, int last_cell)
{
	FILE *fp;
	CBOXPTR___0 ptr;
	int cell___0;

	{
#line 15
		fp = twopen((int)"debug.cellbox", (int)"a", 1);
#line 17
		fprintf(fp, " cell xcenter ycenter corient padside left right\n");
#line 18
		cell___0 = first_cell;
#line 18
		while (cell___0 <= last_cell) {
#line 19
			ptr = (struct cellbox___0 *)*(carray + cell___0);
#line 20
			fprintf(fp, "%5d  %6d  %6d      %2d      %2d %4d  %4d\n", cell___0, ptr->cxcenter,
				ptr->cycenter, ptr->corient, ptr->padside, (ptr->tileptr)->left, (ptr->tileptr)->right);
#line 18
			cell___0++;
		}
#line 25
		twclose((int)fp);
#line 27
		return;
	}
}
#line 30 "debug.c"
void cellterm_data(int first_cell, int last_cell)
{
	FILE *fp;
	CBOXPTR___0 ptr;
	TEBOXPTR___0 termptr;
	NBOXPTR ttermptr;
	int cell___0;
	int corient;

	{
#line 39
		fp = twopen((int)"debug.cellterm", (int)"a", 1);
#line 41
		cell___0 = first_cell;
#line 41
		while (cell___0 <= last_cell) {
#line 42
			fprintf(fp, "\n cell xcenter ycenter corient padside left right\n");
#line 43
			ptr = (struct cellbox___0 *)*(carray + cell___0);
#line 44
			corient = (int)ptr->corient;
#line 45
			fprintf(fp, "%5d  %6d  %6d      %2d      %2d %4d  %4d\n", cell___0, ptr->cxcenter,
				ptr->cycenter, corient, ptr->padside, (ptr->tileptr)->left, (ptr->tileptr)->right);
#line 48
			fprintf(fp, "   pin  net   tx   ty   xpos   ypos   newx   newy ");
#line 49
			fprintf(fp, "loc ue flag\n");
#line 50
			if (cell___0 <= numcells) {
#line 51
				termptr = (ptr->tileptr)->termsptr;
#line 51
				while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 53
					ttermptr = (struct netbox *)*(tearray + termptr->cellterm);
#line 54
					fprintf(fp, " %5d %4d %4d %4d %6d %6d %6d %6d %3d %2d  %2d\n", termptr->cellterm,
						ttermptr->net, termptr->txpos[corient / 2], termptr->typos[corient % 2],
						ttermptr->xpos, ttermptr->ypos, ttermptr->newx, ttermptr->newy, ttermptr->pinloc,
						ttermptr->unequiv, ttermptr->flag);
#line 51
					termptr = (struct termbox___0 *)termptr->nextterm;
				}
			}
			else {
#line 62
				termptr = (ptr->tileptr)->termsptr;
#line 62
				while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 64
					ttermptr = (struct netbox *)*(tearray + termptr->cellterm);
#line 65
					fprintf(fp, " %5d %4d %4d %4d %6d %6d %6d %6d %3d %2d  %2d\n", termptr->cellterm,
						ttermptr->net, termptr->txpos[1], termptr->typos[1], ttermptr->xpos,
						ttermptr->ypos, ttermptr->newx, ttermptr->newy, ttermptr->pinloc,
						ttermptr->unequiv, ttermptr->flag);
#line 62
					termptr = (struct termbox___0 *)termptr->nextterm;
				}
			}
#line 41
			cell___0++;
		}
#line 74
		twclose((int)fp);
#line 75
		return;
	}
}
#line 78 "debug.c"
void terminal(int first_net, int last_net)
{
	FILE *fp;
	NBOXPTR netptr;
	int net;

	{
#line 85
		fp = twopen((int)"debug.terminal", (int)"a", 1);
#line 87
		net = first_net;
#line 87
		while (net <= last_net) {
#line 88
			fprintf(fp, "net %d\n", net);
#line 89
			fprintf(fp, " terminal  xpos  ypos  newx  newy  cell loc ue flag extint\n");
#line 90
			netptr = (struct netbox *)(*(netarray + net))->netptr;
#line 90
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 92
				fprintf(fp, "    %5d %5d %5d %5d %5d %5d %3d %2d    %1d %6d\n", netptr->terminal,
					netptr->xpos, netptr->ypos, netptr->newx, netptr->newy, netptr->cell,
					netptr->pinloc, netptr->unequiv, netptr->flag, netptr->extint);
#line 90
				netptr = (struct netbox *)netptr->nterm;
			}
#line 87
			net++;
		}
#line 99
		twclose((int)fp);
#line 100
		return;
	}
}
#line 103 "debug.c"
void pairCheck(int first_row, int last_row)
{
	FILE *fp;
	CBOXPTR___0 cellptr___0;
	TIBOXPTR___0 tileptr;
	int row___0;
	int i;
	int j;
	int bin_left_edge;
	int *Aray;
	int cell___0;
	int bin;
	int most_left;
	int most_rite;

	{
#line 112
		fp = twopen((int)"dbg.pairCheck", (int)"a", 1);
#line 113
		fprintf(fp, "cedge_binwidth = %d num_edgebin = %d\n", cedge_binwidth, num_edgebin);
#line 116
		row___0 = first_row;
#line 116
		while (row___0 <= last_row) {
#line 117
			Aray = *(pairArray + row___0);
#line 118
			fprintf(fp, "\nROW %d\n", row___0);
#line 119
			fprintf(fp, " total number of cells in this row = %d\n", *(Aray + 0));
#line 120
			cellptr___0 = (struct cellbox___0 *)*(carray + *(Aray + 1));
#line 121
			most_left = cellptr___0->cxcenter + (cellptr___0->tileptr)->left;
#line 122
			cellptr___0 = (struct cellbox___0 *)*(carray + *(Aray + *(Aray + 0)));
#line 123
			most_rite = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
#line 124
			fprintf(fp, " most_left is at %d most_rite is at \n", most_left, most_rite);
#line 126
			fprintf(fp, "   i  cell  left right height   top bottom\n");
#line 127
			i = 1;
#line 127
			while (i <= *(Aray + 0)) {
#line 128
				cell___0 = *(Aray + i);
#line 129
				cellptr___0 = (struct cellbox___0 *)*(carray + cell___0);
#line 130
				tileptr = cellptr___0->tileptr;
#line 131
				fprintf(fp, " %3d %5d %5d %5d %6d %5d %6d\n", i, cell___0, tileptr->left + cellptr___0->cxcenter,
					tileptr->right + cellptr___0->cxcenter, cellptr___0->cheight, tileptr->top,
					-tileptr->bottom);
#line 127
				i++;
			}
#line 136
			fprintf(fp, " bin index cell bin_left_edge\n");
#line 137
			bin_left_edge = most_left;
#line 138
			bin = 1;
#line 138
			while (bin <= num_edgebin) {
#line 139
				j = *(*(cedgebin + row___0) + bin);
#line 140
				fprintf(fp, " %3d %5d %4d        %5d\n", bin, j, *(Aray + j), bin_left_edge);
#line 142
				bin_left_edge += cedge_binwidth;
#line 138
				bin++;
			}
#line 116
			row___0++;
		}
#line 145
		twclose((int)fp);
#line 146
		return;
	}
}
#line 162
int fcellheight(int pin, int *fcell, int status);
#line 149 "debug.c"
void trackdebug(int status)
{
	int fcell;
	int cht;
	int fht;
	int newtrack;
	FILE *fp;
	CHANGRDPTR gdptr;
	NBOXPTR netptr;

	{
#line 158
		fp = twopen((int)"trackdbg", (int)"a", 1);
#line 159
		fprintf(fp, "\n S nS tk nt Tk rs   pin  xpos  newx  cell  fcel cht fht\n");
#line 160
		gdptr = (struct changrdbox *)ULgrdptr;
#line 160
		while ((unsigned int)gdptr != (unsigned int)URgrdptr->nextgrd) {
#line 161
			netptr = gdptr->netptr;
#line 162
			fht = fcellheight(netptr->terminal, &fcell, status);
#line 163
			if ((int)netptr->pinloc == 1) {
#line 164
				cht = ((*(carray + netptr->cell))->tileptr)->top;
			}
			else {
#line 165
				if ((int)netptr->pinloc == 0) {
#line 166
					cht = 0;
				}
				else {
#line 168
					cht = -((*(carray + netptr->cell))->tileptr)->bottom;
				}
			}
#line 170
			if (status == 0) {
#line 171
				newtrack = gdptr->tracks - (cht + fht) / track_spacing;
			}
			else {
#line 173
				newtrack = gdptr->ntracks - (cht + fht) / track_spacing;
			}
#line 175
			fprintf(fp, "%2d %2d %2d %2d %2d %2d %5d %5d %5d %5d %5d %3d %3d\n", gdptr->SegType,
				gdptr->nSegType, gdptr->tracks, gdptr->ntracks, newtrack, (cht + fht) / track_spacing,
				netptr->terminal, netptr->xpos, netptr->newx, netptr->cell, fcell, cht,
				fht);
#line 180
			if (status == 0) {
#line 181
				gdptr = (struct changrdbox *)gdptr->nextgrd;
			}
			else {
#line 183
				gdptr = (struct changrdbox *)gdptr->nnextgrd;
			}
		}
#line 186
		fprintf(fp, "\n S nS tk nt Tk rs   pin  xpos  newx  cell  fcel cht fht\n");
#line 187
		gdptr = (struct changrdbox *)LLgrdptr;
#line 187
		while ((unsigned int)gdptr != (unsigned int)LRgrdptr->nextgrd) {
#line 188
			netptr = gdptr->netptr;
#line 189
			fht = fcellheight(netptr->terminal, &fcell, status);
#line 190
			if ((int)netptr->pinloc == 1) {
#line 191
				cht = ((*(carray + netptr->cell))->tileptr)->top;
			}
			else {
#line 192
				if ((int)netptr->pinloc == 0) {
#line 193
					cht = 0;
				}
				else {
#line 195
					cht = -((*(carray + netptr->cell))->tileptr)->bottom;
				}
			}
#line 197
			if (status == 0) {
#line 198
				newtrack = gdptr->tracks - (cht + fht) / track_spacing;
			}
			else {
#line 200
				newtrack = gdptr->ntracks - (cht + fht) / track_spacing;
			}
#line 202
			fprintf(fp, "%2d %2d %2d %2d %2d %2d %5d %5d %5d %5d %5d %3d %3d\n", gdptr->SegType,
				gdptr->nSegType, gdptr->tracks, gdptr->ntracks, newtrack, (cht + fht) / track_spacing,
				netptr->terminal, netptr->xpos, netptr->newx, netptr->cell, fcell, cht,
				fht);
#line 207
			if (status == 0) {
#line 208
				gdptr = (struct changrdbox *)gdptr->nextgrd;
			}
			else {
#line 210
				gdptr = (struct changrdbox *)gdptr->nnextgrd;
			}
		}
#line 213
		twclose((int)fp);
#line 214
		return;
	}
}
#line 217 "debug.c"
int fcellheight(int pin, int *fcell, int status)
{
	CBOXPTR___0 cellptr___0;
	int bin;
	int i;
	int *Aray;
	int most_left;
	int most_rite;
	int nrow;
	int pin_x;
	int crite;
	int row___0;
	int pinloc;

	{
#line 224
		row___0 = (*(tearray + pin))->row;
#line 225
		pinloc = (int)(*(tearray + pin))->pinloc;
#line 226
		if (1 <= row___0) {
#line 226
			if (row___0 <= numRows) {
#line 227
				nrow = row___0 + pinloc;
#line 228
				if (nrow == 0) {
#line 229
					* fcell = 0;
#line 230
					return (0);
				}
				else {
#line 228
					if (nrow == numChans) {
#line 229
						* fcell = 0;
#line 230
						return (0);
					}
					else {
#line 228
						if (pinloc == 0) {
#line 229
							* fcell = 0;
#line 230
							return (0);
						}
					}
				}
			}
			else {
				goto _L;
			}
		}
		else {
		_L: /* CIL Label */
#line 232
			if (row___0 == 0) {
#line 233
				nrow = 1;
			}
			else {
#line 235
				nrow = numRows;
			}
		}
#line 238
		Aray = *(pairArray + nrow);
#line 239
		if (status == 0) {
#line 240
			pin_x = (*(tearray + pin))->newx;
		}
		else {
#line 242
			pin_x = (*(tearray + pin))->xpos;
		}
#line 244
		cellptr___0 = (struct cellbox___0 *)*(carray + *(Aray + 1));
#line 245
		most_left = cellptr___0->cxcenter + (cellptr___0->tileptr)->left;
#line 246
		cellptr___0 = (struct cellbox___0 *)*(carray + *(Aray + *(Aray + 0)));
#line 247
		most_rite = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
#line 248
		if (pin_x < most_left) {
#line 249
			* fcell = 0;
#line 250
			return (0);
		}
		else {
#line 248
			if (pin_x > most_rite) {
#line 249
				* fcell = 0;
#line 250
				return (0);
			}
		}
#line 252
		bin = (pin_x - most_left) / cedge_binwidth + 1;
#line 253
		i = *(*(cedgebin + nrow) + bin);
#line 253
		if (i == 0) {
#line 254
			* fcell = 0;
#line 255
			return (0);
		}
#line 257
		* fcell = *(Aray + i);
#line 258
		cellptr___0 = (struct cellbox___0 *)*(carray + *fcell);
#line 259
		crite = (cellptr___0->tileptr)->right + cellptr___0->cxcenter;
#line 260
		while (1) {
#line 260
			if (crite < pin_x) {
#line 260
				if (!(i < *(Aray + 0))) {
#line 260
					break;
				}
			}
			else {
#line 260
				break;
			}
#line 261
			i++;
#line 261
			* fcell = *(Aray + i);
#line 262
			cellptr___0 = (struct cellbox___0 *)*(carray + *fcell);
#line 263
			crite += cellptr___0->clength;
		}
#line 265
		if (crite == pin_x) {
#line 265
			if (i != *(Aray + 0)) {
#line 266
				if ((*(carray + *(Aray + (i + 1))))->cheight > cellptr___0->cheight) {
#line 267
					* fcell = *(Aray + (i + 1));
#line 268
					cellptr___0 = (struct cellbox___0 *)*(carray + *fcell);
				}
			}
		}
#line 272
		if (1 <= row___0) {
#line 272
			if (row___0 <= numRows) {
#line 273
				if (pinloc == 1) {
#line 274
					return (-(cellptr___0->tileptr)->bottom);
				}
				else {
#line 276
					return ((cellptr___0->tileptr)->top);
				}
			}
			else {
				goto _L___0;
			}
		}
		else {
		_L___0: /* CIL Label */
#line 278
			if (row___0 == 0) {
#line 279
				return (-(cellptr___0->tileptr)->bottom);
			}
			else {
#line 281
				return ((cellptr___0->tileptr)->top);
			}
		}
	}
}
#line 285 "debug.c"
void chan_debug(int start_chan, int end_chan, int status)
{
	int fcell;
	int cht;
	int fht;
	int chan;
	int newtrack;
	FILE *fp;
	CHANGRDPTR gdptr;
	NBOXPTR netptr;

	{
#line 294
		fp = twopen((int)"chandbg", (int)"a", 1);
#line 295
		chan = start_chan;
#line 295
		while (chan <= end_chan) {
#line 296
			fprintf(fp, "\n channel = %d\n", chan);
#line 297
			fprintf(fp, "\n S nS tk nt Tk rs   pin  xpos  newx  cell  fcel cht fht\n");
#line 298
			if (status == 0) {
#line 299
				gdptr = (struct changrdbox *)(*(Begin + chan))->nextgrd;
			}
			else {
#line 301
				gdptr = (struct changrdbox *)(*(Begin + chan))->nnextgrd;
			}
#line 303
			while ((unsigned int)gdptr != (unsigned int)*(End + chan)) {
#line 304
				netptr = gdptr->netptr;
#line 305
				fht = fcellheight(netptr->terminal, &fcell, status);
#line 306
				if ((int)netptr->pinloc == 1) {
#line 307
					cht = ((*(carray + netptr->cell))->tileptr)->top;
				}
				else {
#line 308
					if ((int)netptr->pinloc == 0) {
#line 309
						cht = 0;
					}
					else {
#line 311
						cht = -((*(carray + netptr->cell))->tileptr)->bottom;
					}
				}
#line 313
				if (status == 0) {
#line 314
					newtrack = gdptr->tracks - (cht + fht) / track_spacing;
				}
				else {
#line 316
					newtrack = gdptr->ntracks - (cht + fht) / track_spacing;
				}
#line 318
				fprintf(fp, "%2d %2d %2d %2d %2d %2d %5d %5d %5d %5d %5d %3d %3d\n", gdptr->SegType,
					gdptr->nSegType, gdptr->tracks, gdptr->ntracks, newtrack, (cht + fht) / track_spacing,
					netptr->terminal, netptr->xpos, netptr->newx, netptr->cell, fcell, cht,
					fht);
#line 323
				if (status == 0) {
#line 324
					gdptr = (struct changrdbox *)gdptr->nextgrd;
				}
				else {
#line 326
					gdptr = (struct changrdbox *)gdptr->nnextgrd;
				}
			}
#line 295
			chan++;
		}
#line 330
		twclose((int)fp);
#line 331
		return;
	}
}
#line 333 "debug.c"
int negative(void)
{
	NBOXPTR netptr;
	CHANGRDPTR gdptr;
	int channel;

	{
#line 341
		channel = 1;
#line 341
		while (channel <= numChans) {
#line 342
			gdptr = (struct changrdbox *)(*(Begin + channel))->nnextgrd;
#line 342
			while ((unsigned int)gdptr != (unsigned int)((void *)0)) {
#line 344
				netptr = gdptr->netptr;
#line 345
				if (gdptr->ntracks < 0) {
#line 346
					printf("channel   pin  xpos  newx  cell   net\n");
#line 347
					printf("    %3d %5d %5d %5d %5d %5d\n", channel, netptr->terminal, netptr->xpos,
						netptr->newx, netptr->cell, netptr->net);
				}
#line 342
				gdptr = (struct changrdbox *)gdptr->nnextgrd;
			}
#line 341
			channel++;
		}
#line 353
		return (0);
	}
}
#line 1 "dimbox.o"
#pragma merger(0,"./dimbox.i","")
#line 810 "/usr/include/sys/reent.h"
extern struct _reent *(__attribute__((__cdecl__)) __getreent)(void);
#line 173 "/usr/include/stdio.h"
extern int (__attribute__((__cdecl__)) fflush)(FILE *);
#line 2 "dimbox.c"
int delta_vert_cost;
#line 3 "dimbox.c"
int tot_num_feeds;
#line 4 "dimbox.c"
int tot_missing_rows;
#line 9 "dimbox.c"
int *num_feeds;
#line 10 "dimbox.c"
int *tmp_num_feeds;
#line 11 "dimbox.c"
int *missing_rows;
#line 12 "dimbox.c"
int *tmp_missing_rows;
#line 13 "dimbox.c"
static char **rows___0;
#line 14 "dimbox.c"
char **tmp_rows;
#line 19 "dimbox.c"
int check_cost(void)
{
	DBOXPTR dimptr;
	NBOXPTR netptr;
	int old_mean;
	int oldx;
	int net;
	int initial_cost;
	int total;
	int tmp;

	{
#line 27
		initial_cost = 0;
#line 28
		net = 1;
#line 28
		while (net <= numnets) {
#line 29
			dimptr = *(netarray + net);
#line 30
			total = 0;
#line 31
			netptr = dimptr->netptr;
#line 31
			while (netptr) {
#line 32
				total += netptr->xpos;
#line 31
				netptr = netptr->nterm;
			}
#line 34
			old_mean = total / dimptr->numpins;
#line 35
			netptr = dimptr->netptr;
#line 35
			while (netptr) {
#line 36
				oldx = netptr->xpos;
#line 37
				tmp = ABS(oldx - old_mean);
#line 37
				initial_cost += tmp;
#line 35
				netptr = netptr->nterm;
			}
#line 28
			net++;
		}
#line 40
		return (initial_cost);
	}
}
#line 45 "dimbox.c"
int initialize_cost(void)
{
	DBOXPTR dimptr;
	NBOXPTR netptr;
	int old_mean;
	int oldx;
	int net;
	int initial_cost;
	int tmp;

	{
#line 53
		initial_cost = 0;
#line 54
		net = 1;
#line 54
		while (net <= numnets) {
#line 55
			dimptr = *(netarray + net);
#line 56
			dimptr->old_total = 0;
#line 57
			netptr = dimptr->netptr;
#line 57
			while (netptr) {
#line 58
				dimptr->old_total += netptr->xpos;
#line 57
				netptr = netptr->nterm;
			}
#line 60
			old_mean = dimptr->old_total / dimptr->numpins;
#line 61
			netptr = dimptr->netptr;
#line 61
			while (netptr) {
#line 62
				oldx = netptr->xpos;
#line 63
				tmp = ABS(oldx - old_mean);
#line 63
				initial_cost += tmp;
#line 61
				netptr = netptr->nterm;
			}
#line 54
			net++;
		}
#line 66
		return (initial_cost);
	}
}
#line 71 "dimbox.c"
void new_dbox(TEBOXPTR antrmptr, int *costptr)
{
	NBOXPTR netptr;
	DBOXPTR dimptr;
	TEBOXPTR termptr;
	int old_mean;
	int new_mean;
	int oldx;
	int newx;
	int tmp;
	int tmp___0;

	{
#line 79
		termptr = antrmptr;
#line 79
		while (termptr) {
#line 80
			dimptr = *(netarray + termptr->net);
#line 81
			if ((int)dimptr->dflag == 0) {
				goto __Cont;
			}
#line 84
			dimptr->dflag = (char)0;
#line 86
			new_mean = dimptr->new_total / dimptr->numpins;
#line 87
			old_mean = dimptr->old_total / dimptr->numpins;
#line 88
			netptr = dimptr->netptr;
#line 88
			while (netptr) {
#line 89
				oldx = netptr->xpos;
#line 90
				if ((int)netptr->flag == 1) {
#line 91
					newx = netptr->newx;
#line 92
					netptr->flag = (char)0;
				}
				else {
#line 94
					newx = oldx;
				}
#line 96
				tmp = ABS(newx - new_mean);
#line 96
				tmp___0 = ABS(oldx - old_mean);
#line 96
				* costptr += tmp - tmp___0;
#line 88
				netptr = netptr->nterm;
			}
		__Cont: /* CIL Label */
#line 79
			termptr = termptr->nextterm;
		}
#line 99
		return;
	}
}
#line 103 "dimbox.c"
int new_dbox_a(TEBOXPTR antrmptr, int *costptr)
{
	DBOXPTR dimptr;
	NBOXPTR netptr;
	TEBOXPTR termptr;
	int old_mean;
	int new_mean;
	int oldx;
	int newx;
	int f;
	int m;
	int min;
	int max;
	int row___0;
	int net;
	char *rowsptr;
	int tmp;
	int tmp___0;

	{
#line 115
		termptr = antrmptr;
#line 115
		while (termptr) {
#line 116
			net = termptr->net;
#line 117
			dimptr = *(netarray + net);
#line 118
			if ((int)dimptr->dflag == 0) {
				goto __Cont;
			}
#line 121
			dimptr->dflag = (char)0;
#line 123
			new_mean = dimptr->new_total / dimptr->numpins;
#line 124
			old_mean = dimptr->old_total / dimptr->numpins;
#line 125
			netptr = dimptr->netptr;
#line 125
			while (netptr) {
#line 126
				oldx = netptr->xpos;
#line 127
				if ((int)netptr->flag == 1) {
#line 128
					newx = netptr->newx;
#line 129
					netptr->flag = (char)0;
				}
				else {
#line 131
					newx = oldx;
				}
#line 133
				tmp = ABS(newx - new_mean);
#line 133
				tmp___0 = ABS(oldx - old_mean);
#line 133
				* costptr += tmp - tmp___0;
#line 125
				netptr = netptr->nterm;
			}
#line 136
			f = 0;
#line 137
			m = 0;
#line 138
			rowsptr = *(tmp_rows + net);
#line 139
			row___0 = 0;
#line 139
			while ((int)*(rowsptr + row___0) == 0) {
#line 139
				row___0++;
			}
#line 140
			min = row___0;
#line 141
			row___0 = numRows + 1;
#line 141
			while ((int)*(rowsptr + row___0) == 0) {
#line 141
				row___0--;
			}
#line 142
			max = row___0;
#line 143
			row___0 = min;
#line 143
			while (row___0 <= max) {
#line 144
				if ((int)*(rowsptr + row___0) == 0) {
#line 145
					f++;
				}
				else {
#line 147
					m++;
				}
#line 143
				row___0++;
			}
#line 150
			* (tmp_num_feeds + net) = f;
#line 151
			if (min < max) {
#line 152
				m += 2;
			}
			else {
#line 153
				if (min == max) {
#line 154
					m++;
				}
				else {
#line 156
					m = 0;
				}
			}
#line 158
			* (tmp_missing_rows + net) = -m;
#line 160
			delta_vert_cost += (((*(tmp_num_feeds + net) - *(num_feeds + net)) + (*(tmp_missing_rows + net) - *(missing_rows + net))) * 2) * rowHeight;
		__Cont: /* CIL Label */
#line 115
			termptr = termptr->nextterm;
		}
#line 164
		return;
	}
}
#line 169 "dimbox.c"
int term_newpos(TEBOXPTR antrmptr, int xcenter, int ycenter, int newaor)
{
	TEBOXPTR termptr;
	NBOXPTR ttermptr;
	DBOXPTR dimptr;

	{
#line 178
		termptr = antrmptr;
#line 178
		while (termptr) {
#line 179
			ttermptr = termptr->termptr;
#line 180
			ttermptr->flag = (char)1;
#line 181
			ttermptr->newx = termptr->txpos[newaor / 2] + xcenter;
#line 183
			dimptr = *(netarray + termptr->net);
#line 184
			if ((int)dimptr->dflag == 0) {
#line 185
				dimptr->dflag = (char)1;
#line 186
				dimptr->new_total = (dimptr->old_total + ttermptr->newx) - ttermptr->xpos;
			}
			else {
#line 189
				dimptr->new_total += ttermptr->newx - ttermptr->xpos;
			}
#line 178
			termptr = termptr->nextterm;
		}
#line 192
		return;
	}
}
#line 197 "dimbox.c"
int term_newpos_a(TEBOXPTR antrmptr, int xcenter, int ycenter, int newaor)
{
	TEBOXPTR termptr;
	NBOXPTR ttermptr;
	DBOXPTR dimptr;
	char *rowsptr1;
	char *rowsptr2;
	int net;
	int row___0;

	{
#line 208
		termptr = antrmptr;
#line 208
		while (termptr) {
#line 209
			ttermptr = termptr->termptr;
#line 210
			ttermptr->flag = (char)1;
#line 211
			ttermptr->newx = termptr->txpos[newaor / 2] + xcenter;
#line 213
			net = termptr->net;
#line 214
			dimptr = *(netarray + net);
#line 216
			rowsptr2 = *(tmp_rows + net);
#line 217
			if ((int)dimptr->dflag == 0) {
#line 218
				dimptr->dflag = (char)1;
#line 220
				rowsptr1 = *(rows___0 + net);
#line 221
				row___0 = 0;
#line 221
				while (row___0 <= numRows + 1) {
#line 222
					* (rowsptr2 + row___0) = *(rowsptr1 + row___0);
#line 221
					row___0++;
				}
#line 224
				* (rowsptr2 + ablock) = (char)((int)*(rowsptr2 + ablock) - 1);
#line 225
				* (rowsptr2 + bblock) = (char)((int)*(rowsptr2 + bblock) + 1);
#line 227
				dimptr->new_total = (dimptr->old_total + ttermptr->newx) - ttermptr->xpos;
			}
			else {
#line 230
				* (rowsptr2 + ablock) = (char)((int)*(rowsptr2 + ablock) - 1);
#line 231
				* (rowsptr2 + bblock) = (char)((int)*(rowsptr2 + bblock) + 1);
#line 232
				dimptr->new_total += ttermptr->newx - ttermptr->xpos;
			}
#line 208
			termptr = termptr->nextterm;
		}
#line 235
		return;
	}
}
#line 240 "dimbox.c"
int term_newpos_b(TEBOXPTR antrmptr, int xcenter, int ycenter, int newaor)
{
	TEBOXPTR termptr;
	NBOXPTR ttermptr;
	DBOXPTR dimptr;
	char *rowsptr1;
	char *rowsptr2;
	int net;
	int row___0;

	{
#line 251
		termptr = antrmptr;
#line 251
		while (termptr) {
#line 252
			ttermptr = termptr->termptr;
#line 253
			ttermptr->flag = (char)1;
#line 254
			ttermptr->newx = termptr->txpos[newaor / 2] + xcenter;
#line 256
			net = termptr->net;
#line 257
			dimptr = *(netarray + net);
#line 259
			rowsptr2 = *(tmp_rows + net);
#line 260
			if ((int)dimptr->dflag == 0) {
#line 261
				dimptr->dflag = (char)1;
#line 263
				rowsptr1 = *(rows___0 + net);
#line 264
				row___0 = 0;
#line 264
				while (row___0 <= numRows + 1) {
#line 265
					* (rowsptr2 + row___0) = *(rowsptr1 + row___0);
#line 264
					row___0++;
				}
#line 267
				* (rowsptr2 + bblock) = (char)((int)*(rowsptr2 + bblock) - 1);
#line 268
				* (rowsptr2 + ablock) = (char)((int)*(rowsptr2 + ablock) + 1);
#line 270
				dimptr->new_total = (dimptr->old_total + ttermptr->newx) - ttermptr->xpos;
			}
			else {
#line 273
				* (rowsptr2 + bblock) = (char)((int)*(rowsptr2 + bblock) - 1);
#line 274
				* (rowsptr2 + ablock) = (char)((int)*(rowsptr2 + ablock) + 1);
#line 275
				dimptr->new_total += ttermptr->newx - ttermptr->xpos;
			}
#line 251
			termptr = termptr->nextterm;
		}
#line 278
		return;
	}
}
#line 283 "dimbox.c"
int dbox_pos(TEBOXPTR antrmptr)
{
	DBOXPTR dimptr;
	TEBOXPTR termptr;

	{
#line 290
		termptr = antrmptr;
#line 290
		while (termptr) {
#line 291
			dimptr = *(netarray + termptr->net);
#line 292
			dimptr->old_total = dimptr->new_total;
#line 294
			(termptr->termptr)->xpos = (termptr->termptr)->newx;
#line 290
			termptr = termptr->nextterm;
		}
#line 296
		return;
	}
}
#line 301 "dimbox.c"
int dbox_pos_2(TEBOXPTR antrmptr)
{
	DBOXPTR dimptr;
	TEBOXPTR termptr;
	int net;
	int row___0;
	register char *rowsptr1;
	register char *rowsptr2;

	{
#line 311
		termptr = antrmptr;
#line 311
		while (termptr) {
#line 312
			net = termptr->net;
#line 313
			dimptr = *(netarray + net);
#line 314
			dimptr->old_total = dimptr->new_total;
#line 316
			(termptr->termptr)->xpos = (termptr->termptr)->newx;
#line 318
			* (missing_rows + net) = *(tmp_missing_rows + net);
#line 319
			* (num_feeds + net) = *(tmp_num_feeds + net);
#line 321
			rowsptr1 = *(rows___0 + net);
#line 322
			rowsptr2 = *(tmp_rows + net);
#line 323
			row___0 = 0;
#line 323
			while (row___0 <= numRows + 1) {
#line 324
				* (rowsptr1 + row___0) = *(rowsptr2 + row___0);
#line 323
				row___0++;
			}
#line 311
			termptr = termptr->nextterm;
		}
#line 327
		return;
	}
}
#line 332 "dimbox.c"
int initialize_rows(void)
{
	TEBOXPTR termptr;
	int net;
	int row___0;
	int cell___0;
	int min;
	int max;
	int f;
	int m;
	char *rowsptr;
	char *tmp;
	char *tmp___0;
	char *tmp___1;
	char *tmp___2;
	char *tmp___3;
	char *tmp___4;
	char *tmp___5;
	char *tmp___6;

	{
#line 339
		tmp = safe_malloc((unsigned int)(1 + numnets) * sizeof(int));
#line 339
		num_feeds = (int *)tmp;
#line 340
		tmp___0 = safe_malloc((unsigned int)(1 + numnets) * sizeof(int));
#line 340
		tmp_num_feeds = (int *)tmp___0;
#line 341
		tmp___1 = safe_malloc((unsigned int)(1 + numnets) * sizeof(int));
#line 341
		missing_rows = (int *)tmp___1;
#line 342
		tmp___2 = safe_malloc((unsigned int)(1 + numnets) * sizeof(int));
#line 342
		tmp_missing_rows = (int *)tmp___2;
#line 343
		tmp___3 = safe_malloc((unsigned int)(1 + numnets) * sizeof(char *));
#line 343
		rows___0 = (char **)tmp___3;
#line 344
		tmp___4 = safe_malloc((unsigned int)(1 + numnets) * sizeof(char *));
#line 344
		tmp_rows = (char **)tmp___4;
#line 345
		net = 1;
#line 345
		while (net <= numnets) {
#line 346
			tmp___5 = safe_malloc((unsigned int)(2 + numRows) * sizeof(char));
#line 346
			* (rows___0 + net) = tmp___5;
#line 347
			tmp___6 = safe_malloc((unsigned int)(2 + numRows) * sizeof(char));
#line 347
			* (tmp_rows + net) = tmp___6;
#line 348
			row___0 = 0;
#line 348
			while (row___0 <= numRows + 1) {
#line 349
				* (*(rows___0 + net) + row___0) = (char)0;
#line 350
				* (*(tmp_rows + net) + row___0) = (char)0;
#line 348
				row___0++;
			}
#line 352
			* (missing_rows + net) = 0;
#line 353
			* (tmp_missing_rows + net) = 0;
#line 354
			* (num_feeds + net) = 0;
#line 355
			* (tmp_num_feeds + net) = 0;
#line 345
			net++;
		}
#line 358
		cell___0 = 1;
#line 358
		while (cell___0 <= numcells + numterms) {
#line 359
			if (cell___0 > numcells) {
#line 360
				if ((*(carray + cell___0))->padside != 2) {
#line 360
					if ((*(carray + cell___0))->padside != 4) {
#line 360
						if ((*(carray + cell___0))->padside != 14) {
#line 360
							if ((*(carray + cell___0))->padside != 15) {
								goto __Cont;
							}
							else {
								goto _L___1;
							}
						}
						else {
							goto _L___1;
						}
					}
					else {
						goto _L___1;
					}
				}
				else {
				_L___1: /* CIL Label */
#line 365
					if ((*(carray + cell___0))->padside == 2) {
#line 367
						row___0 = numRows + 1;
#line 367
						(*(carray + cell___0))->cblock = row___0;
					}
					else {
#line 365
						if ((*(carray + cell___0))->padside == 14) {
#line 367
							row___0 = numRows + 1;
#line 367
							(*(carray + cell___0))->cblock = row___0;
						}
						else {
#line 369
							row___0 = 0;
#line 369
							(*(carray + cell___0))->cblock = row___0;
						}
					}
				}
			}
			else {
#line 372
				row___0 = (*(carray + cell___0))->cblock;
			}
#line 374
			termptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 374
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 376
				* (*(rows___0 + termptr->net) + row___0) = (char)((int)*(*(rows___0 + termptr->net) + row___0) + 1);
#line 374
				termptr = termptr->nextterm;
			}
		__Cont: /* CIL Label */
#line 358
			cell___0++;
		}
#line 380
		net = 1;
#line 380
		while (net <= numnets) {
#line 381
			f = 0;
#line 382
			m = 0;
#line 383
			rowsptr = *(rows___0 + net);
#line 384
			row___0 = 0;
#line 384
			while ((int)*(rowsptr + row___0) == 0) {
#line 384
				row___0++;
			}
#line 385
			min = row___0;
#line 386
			row___0 = numRows + 1;
#line 386
			while ((int)*(rowsptr + row___0) == 0) {
#line 386
				row___0--;
			}
#line 387
			max = row___0;
#line 388
			row___0 = min;
#line 388
			while (row___0 <= max) {
#line 389
				if ((int)*(rowsptr + row___0) == 0) {
#line 390
					f++;
				}
				else {
#line 392
					m++;
				}
#line 388
				row___0++;
			}
#line 395
			* (num_feeds + net) = f;
#line 396
			if (min < max) {
#line 397
				m += 2;
			}
			else {
#line 398
				if (min == max) {
#line 399
					m++;
				}
				else {
#line 401
					m = 0;
				}
			}
#line 403
			* (missing_rows + net) = -m;
#line 380
			net++;
		}
#line 406
		return;
	}
}
#line 411 "dimbox.c"
int check_row_values(void)
{
	TEBOXPTR termptr;
	int net;
	int row___0;
	int cell___0;
	int min;
	int max;
	int f;
	int m;
	int fds;
	int mrs;
	char *rowsptr;
	char **check_rows;
	int *check_feeds;
	char *tmp;
	char *tmp___0;
	char *tmp___1;
	struct _reent *tmp___2;

	{
#line 419
		tmp = safe_malloc((unsigned int)(1 + numnets) * sizeof(int));
#line 419
		check_feeds = (int *)tmp;
#line 420
		tmp___0 = safe_malloc((unsigned int)(1 + numnets) * sizeof(char *));
#line 420
		check_rows = (char **)tmp___0;
#line 421
		net = 1;
#line 421
		while (net <= numnets) {
#line 422
			tmp___1 = safe_malloc((unsigned int)(2 + numRows) * sizeof(char));
#line 422
			* (check_rows + net) = tmp___1;
#line 423
			row___0 = 0;
#line 423
			while (row___0 <= numRows + 1) {
#line 424
				* (*(check_rows + net) + row___0) = (char)0;
#line 423
				row___0++;
			}
#line 426
			* (check_feeds + net) = 0;
#line 421
			net++;
		}
#line 429
		cell___0 = 1;
#line 429
		while (cell___0 <= numcells + numterms) {
#line 430
			if (cell___0 > numcells) {
#line 431
				if ((*(carray + cell___0))->padside != 2) {
#line 431
					if ((*(carray + cell___0))->padside != 4) {
#line 431
						if ((*(carray + cell___0))->padside != 14) {
#line 431
							if ((*(carray + cell___0))->padside != 15) {
								goto __Cont;
							}
							else {
								goto _L___1;
							}
						}
						else {
							goto _L___1;
						}
					}
					else {
						goto _L___1;
					}
				}
				else {
				_L___1: /* CIL Label */
#line 436
					if ((*(carray + cell___0))->padside == 2) {
#line 438
						row___0 = numRows + 1;
#line 438
						(*(carray + cell___0))->cblock = row___0;
					}
					else {
#line 436
						if ((*(carray + cell___0))->padside == 14) {
#line 438
							row___0 = numRows + 1;
#line 438
							(*(carray + cell___0))->cblock = row___0;
						}
						else {
#line 440
							row___0 = 0;
#line 440
							(*(carray + cell___0))->cblock = row___0;
						}
					}
				}
			}
			else {
#line 443
				row___0 = (*(carray + cell___0))->cblock;
			}
#line 445
			termptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 445
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 447
				* (*(check_rows + termptr->net) + row___0) = (char)((int)*(*(check_rows + termptr->net) + row___0) + 1);
#line 445
				termptr = termptr->nextterm;
			}
		__Cont: /* CIL Label */
#line 429
			cell___0++;
		}
#line 451
		fds = 0;
#line 452
		mrs = 0;
#line 453
		net = 1;
#line 453
		while (net <= numnets) {
#line 454
			f = 0;
#line 455
			m = 0;
#line 456
			rowsptr = *(check_rows + net);
#line 457
			row___0 = 0;
#line 457
			while ((int)*(rowsptr + row___0) == 0) {
#line 457
				row___0++;
			}
#line 458
			min = row___0;
#line 459
			row___0 = numRows + 1;
#line 459
			while ((int)*(rowsptr + row___0) == 0) {
#line 459
				row___0--;
			}
#line 460
			max = row___0;
#line 461
			row___0 = min;
#line 461
			while (row___0 <= max) {
#line 462
				if ((int)*(rowsptr + row___0) == 0) {
#line 463
					f++;
				}
				else {
#line 465
					m++;
				}
#line 461
				row___0++;
			}
#line 468
			fds += f;
#line 469
			if (min < max) {
#line 470
				m += 2;
			}
			else {
#line 471
				if (min == max) {
#line 472
					m++;
				}
				else {
#line 474
					m = 0;
				}
			}
#line 476
			mrs -= m;
#line 453
			net++;
		}
#line 479
		safe_free(check_feeds);
#line 480
		net = 1;
#line 480
		while (net <= numnets) {
#line 481
			safe_free(*(check_rows + net));
#line 480
			net++;
		}
#line 483
		safe_free(check_rows);
#line 485
		fprintf(fpo, "FEEDS:%d     MRs:%d\n", fds, mrs);
#line 486
		printf("FEEDS:%d     MRs:%d\n", fds, mrs);
#line 487
		tmp___2 = __getreent();
#line 487
		fflush(tmp___2->_stdout);
#line 488
		fflush(fpo);
#line 490
		return;
	}
}
#line 497 "dimbox.c"
int vert_statistics(void)
{
	int net;

	{
#line 502
		tot_missing_rows = 0;
#line 503
		tot_num_feeds = 0;
#line 504
		net = 1;
#line 504
		while (net <= numnets) {
#line 505
			tot_missing_rows += *(missing_rows + net);
#line 506
			tot_num_feeds += *(num_feeds + net);
#line 504
			net++;
		}
#line 508
		return;
	}
}
#line 1 "finalwire.o"
#pragma merger(0,"./finalwire.i","")
#line 4 "finalwire.c"
int iwire;
#line 5
int iwirex;
#line 6
int iwirey;
#line 7
int fwire;
#line 8
int fwirex;
#line 9
int fwirey;
#line 11 "finalwire.c"
void finalwire(void)
{
	DBOXPTR dimptr;
	NBOXPTR netptr;
	int x;
	int y;
	int net;
	int cost;
	int tmp;
	int tmp___0;

	{
#line 16
		cost = 0;
#line 18
		fwirex = 0;
#line 19
		fwirey = 0;
#line 21
		net = 1;
#line 21
		while (net <= numnets) {
#line 22
			dimptr = *(netarray + net);
#line 23
			netptr = dimptr->netptr;
#line 23
			if ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 24
				tmp = netptr->xpos;
#line 24
				dimptr->xmax = tmp;
#line 24
				dimptr->xmin = tmp;
#line 25
				tmp___0 = netptr->ypos;
#line 25
				dimptr->ymax = tmp___0;
#line 25
				dimptr->ymin = tmp___0;
#line 26
				netptr = netptr->nterm;
			}
#line 28
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 29
				x = netptr->xpos;
#line 30
				y = netptr->ypos;
#line 31
				if (x < dimptr->xmin) {
#line 32
					dimptr->xmin = x;
				}
				else {
#line 33
					if (x > dimptr->xmax) {
#line 34
						dimptr->xmax = x;
					}
				}
#line 36
				if (y < dimptr->ymin) {
#line 37
					dimptr->ymin = y;
				}
				else {
#line 38
					if (y > dimptr->ymax) {
#line 39
						dimptr->ymax = y;
					}
				}
#line 28
				netptr = netptr->nterm;
			}
#line 42
			cost += (int)(dimptr->Hweight * (float)(dimptr->xmax - dimptr->xmin)) + (int)(dimptr->Vweight * (float)(dimptr->ymax - dimptr->ymin));
#line 46
			fwirex += dimptr->xmax - dimptr->xmin;
#line 47
			fwirey += dimptr->ymax - dimptr->ymin;
#line 21
			net++;
		}
#line 49
		fwire = cost;
#line 50
		fprintf(fpo, "\nInitial Wiring Cost: %d   Final Wiring Cost: %d\n", iwire, fwire);
#line 52
		if (iwire != 0) {
#line 53
			fprintf(fpo, "############## Percent Wire Cost Reduction: %d\n\n", 100 - (int)((double)((float)fwire / (float)iwire) * 100.0));
		}
#line 56
		fprintf(fpo, "\nInitial Wire Length: %d   Final Wire Length: %d\n", iwirex + iwirey,
			fwirex + fwirey);
#line 58
		if (iwirex + iwirey != 0) {
#line 59
			fprintf(fpo, "************** Percent Wire Length Reduction: %d\n\n", 100 - (int)((double)((float)(fwirex + fwirey) / (float)(iwirex + iwirey)) * 100.0));
		}
#line 63
		fprintf(fpo, "\nInitial Horiz. Wire: %d   Final Horiz. Wire: %d\n", iwirex, fwirex);
#line 65
		if (iwirex != 0) {
#line 66
			fprintf(fpo, "$$$$$$$$$$$ Percent H-Wire Length Reduction: %d\n\n", 100 - (int)((double)((float)fwirex / (float)iwirex) * 100.0));
		}
#line 69
		fprintf(fpo, "\nInitial Vert. Wire: %d   Final Vert. Wire: %d\n", iwirey, fwirey);
#line 71
		if (iwirey != 0) {
#line 72
			fprintf(fpo, "@@@@@@@@@@@ Percent V-Wire Length Reduction: %d\n\n", 100 - (int)((double)((float)fwirey / (float)iwirey) * 100.0));
		}
#line 75
		return;
	}
}
#line 1 "findcost.o"
#pragma merger(0,"./findcost.i","")
#line 101 "/usr/include/math.h"
extern double sqrt(double);
#line 23 "utils.h"
char *safe_realloc(char *obj, unsigned int size);
#line 250 "standard.h"
int SetBin(int x);
#line 2 "findcost.c"
int minxspan;
#line 9
float roLenCon;
#line 10
float binpenCon;
#line 11 "findcost.c"
float mean_width;
#line 12 "findcost.c"
int offset_limit;
#line 13 "findcost.c"
int blkleft;
#line 13 "findcost.c"
int blkrite;
#line 105
void TW_oldin(FILE *fp);
#line 109
void sortpin(void);
#line 16 "findcost.c"
int findcost(void)
{
	FILE *fp;
	TIBOXPTR tile;
	TIBOXPTR tileptr1;
	CBOXPTR cellptr1;
	CBOXPTR ptr;
	DBOXPTR dimptr;
	NBOXPTR netptr;
	NBOXPTR termptr;
	TEBOXPTR term;
	BINPTR bptr;
	char filename[64];
	int left___0;
	int right;
	int corient;
	int bin;
	int LoBin;
	int HiBin;
	int block___0;
	int cell___0;
	int net;
	int blk___0;
	int startx;
	int endx;
	int x;
	int y;
	int cost;
	int temp;
	int n;
	int k___0;
	int cbin;
	int net_pin_num[11];
	int *adjust_left;
	float deviation;
	float factor;
	char *tmp;
	double tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	char *tmp___7;
	char *tmp___8;
	char *tmp___9;
	char *tmp___10;
	char *tmp___11;
	int tmp___12;
	int tmp___13;

	{
#line 30
		cost = 0;
#line 35
		blkleft = 32000;
#line 36
		blkrite = 0;
#line 37
		tmp = safe_malloc((unsigned int)(numblock + 1) * sizeof(int));
#line 37
		adjust_left = (int *)tmp;
#line 38
		block___0 = 1;
#line 38
		while (block___0 <= numblock) {
#line 39
			if ((*(barray + block___0))->bxcenter + (*(barray + block___0))->bleft < blkleft) {
#line 41
				blkleft = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bleft;
			}
#line 44
			if ((*(barray + block___0))->bxcenter + (*(barray + block___0))->bright > blkrite) {
#line 46
				blkrite = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bright;
			}
#line 49
			* (adjust_left + block___0) = 32000;
#line 38
			block___0++;
		}
#line 51
		binOffst = blkleft;
#line 52
		max_blklength = blkrite - blkleft;
#line 54
		deviation = (float)0;
#line 55
		temp = 0;
#line 56
		factor = (float)0.0;
#line 57
		cell___0 = 1;
#line 57
		while (cell___0 <= numcells) {
#line 58
			temp += (*(carray + cell___0))->clength;
#line 57
			cell___0++;
		}
#line 60
		mean_width = (float)(temp / numcells);
#line 62
		cell___0 = 1;
#line 62
		while (cell___0 <= numcells) {
#line 63
			deviation += ((float)(*(carray + cell___0))->clength - mean_width) * ((float)(*(carray + cell___0))->clength - mean_width);
#line 62
			cell___0++;
		}
#line 66
		tmp___0 = sqrt((double)(deviation / (float)numcells));
#line 66
		deviation = (float)tmp___0;
#line 67
		binWidth = (int)(factor * deviation + mean_width) + 1;
#line 69
		numBins = (blkrite - binOffst) / binWidth;
#line 70
		if (blkrite - binOffst > numBins * binWidth) {
#line 71
			numBins++;
		}
#line 73
		fprintf(fpo, "numBins automatically set to:%d\n", numBins);
#line 74
		fprintf(fpo, "binWidth = average_cell_width + %g sigma", factor);
#line 75
		fprintf(fpo, "= %d\n", binWidth);
#line 76
		fprintf(fpo, "average_cell_width is:%g\n", mean_width);
#line 77
		fprintf(fpo, "standard deviation of cell length is:%g\n", deviation);
#line 80
		minxspan = (int)((double)mean_width + 3.0 * (double)deviation);
#line 81
		offset_limit = (int)(((0.05 * (double)mean_width) * (double)((float)numcells)) / (double)((float)numblock));
#line 85
		sprintf(filename, "%s.res", cktName);
#line 86
		fp = twopen((int)(filename), (int)"r", 0);
#line 87
		if (!fp) {
#line 91
			if (resume_run == 1) {
#line 92
				fprintf(fpo, "Could not use resume file: %s  ", filename);
#line 93
				fprintf(fpo, "since it could not be found\n");
			}
			else {
#line 96
				fprintf(fpo, "TimberWolfSC starting from the beginning\n");
			}
		}
		else {
#line 99
			if (resume_run == 0) {
#line 100
				fprintf(fpo, "Use of resume file: %s was not requested\n", filename);
			}
			else {
#line 103
				fprintf(fpo, "Resuming TimberWolf from previous saved ");
#line 104
				fprintf(fpo, "placement in %s\n", filename);
#line 105
				TW_oldin(fp);
#line 106
				twclose((int)fp);
			}
		}
#line 109
		sortpin();
#line 110
		cell___0 = 1;
#line 110
		while (cell___0 <= numcells + numterms) {
#line 111
			ptr = *(carray + cell___0);
#line 112
			corient = (int)ptr->corient;
#line 113
			block___0 = ptr->cblock;
#line 114
			tile = ptr->tileptr;
#line 115
			if (cell___0 <= numcells) {
#line 116
				ptr->cycenter = (*(barray + block___0))->bycenter;
#line 117
				if (*(adjust_left + block___0) > ptr->cxcenter + tile->left) {
#line 118
					* (adjust_left + block___0) = ptr->cxcenter + tile->left;
				}
#line 120
				term = tile->termsptr;
#line 120
				while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 122
					termptr = *(tearray + term->cellterm);
#line 123
					termptr->xpos = term->txpos[corient / 2] + ptr->cxcenter;
#line 124
					termptr->ypos = term->typos[corient % 2] + ptr->cycenter;
#line 120
					term = term->nextterm;
				}
			}
			else {
#line 128
				term = tile->termsptr;
#line 128
				while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 130
					termptr = *(tearray + term->cellterm);
#line 131
					termptr->xpos = term->txpos[1] + ptr->cxcenter;
#line 132
					termptr->ypos = term->typos[1] + ptr->cycenter;
#line 128
					term = term->nextterm;
				}
			}
#line 110
			cell___0++;
		}
#line 138
		iwirex = 0;
#line 139
		iwirey = 0;
#line 140
		net = 1;
#line 140
		while (net <= numnets) {
#line 141
			dimptr = *(netarray + net);
#line 142
			netptr = dimptr->netptr;
#line 142
			if ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 143
				tmp___1 = netptr->xpos;
#line 143
				dimptr->xmax = tmp___1;
#line 143
				dimptr->xmin = tmp___1;
#line 144
				tmp___2 = netptr->ypos;
#line 144
				dimptr->ymax = tmp___2;
#line 144
				dimptr->ymin = tmp___2;
			}
#line 146
			netptr = netptr->nterm;
#line 146
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 148
				x = netptr->xpos;
#line 149
				y = netptr->ypos;
#line 150
				if (x < dimptr->xmin) {
#line 151
					dimptr->xmin = x;
				}
				else {
#line 153
					if (x > dimptr->xmax) {
#line 154
						dimptr->xmax = x;
					}
				}
#line 156
				if (y < dimptr->ymin) {
#line 157
					dimptr->ymin = y;
				}
				else {
#line 159
					if (y > dimptr->ymax) {
#line 160
						dimptr->ymax = y;
					}
				}
#line 146
				netptr = netptr->nterm;
			}
#line 163
			cost += (int)(dimptr->Hweight * (float)(dimptr->xmax - dimptr->xmin)) + (int)(dimptr->Vweight * (float)(dimptr->ymax - dimptr->ymin));
#line 167
			iwirex += dimptr->xmax - dimptr->xmin;
#line 168
			iwirey += dimptr->ymax - dimptr->ymin;
#line 140
			net++;
		}
#line 170
		fprintf(fpo, "\n\n\nTHIS IS THE ROUTE COST OF THE ");
#line 171
		fprintf(fpo, "ORIGINAL PLACEMENT: %d\n", cost);
#line 177
		if (resume_run == 0) {
#line 179
			cell___0 = 1;
#line 179
			while (cell___0 <= numcells) {
#line 180
				ptr = *(carray + cell___0);
#line 181
				corient = (int)ptr->corient;
#line 182
				block___0 = ptr->cblock;
#line 183
				ptr->cxcenter -= (*(adjust_left + block___0) - (*(barray + block___0))->bxcenter) - (*(barray + block___0))->bleft;
#line 185
				term = (ptr->tileptr)->termsptr;
#line 185
				while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 187
					termptr = *(tearray + term->cellterm);
#line 188
					termptr->xpos = term->txpos[corient / 2] + ptr->cxcenter;
#line 189
					termptr->ypos = term->typos[corient % 2] + ptr->cycenter;
#line 185
					term = term->nextterm;
				}
#line 179
				cell___0++;
			}
		}
#line 195
		cost = 0;
#line 196
		iwirex = 0;
#line 197
		iwirey = 0;
#line 199
		net = 1;
#line 199
		while (net <= numnets) {
#line 200
			dimptr = *(netarray + net);
#line 201
			netptr = dimptr->netptr;
#line 201
			if ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 202
				tmp___3 = netptr->xpos;
#line 202
				dimptr->xmax = tmp___3;
#line 202
				dimptr->xmin = tmp___3;
#line 203
				tmp___4 = netptr->ypos;
#line 203
				dimptr->ymax = tmp___4;
#line 203
				dimptr->ymin = tmp___4;
#line 204
				tmp___5 = 1;
#line 204
				dimptr->Rnum = tmp___5;
#line 204
				dimptr->Lnum = tmp___5;
#line 205
				tmp___6 = 1;
#line 205
				dimptr->Tnum = tmp___6;
#line 205
				dimptr->Bnum = tmp___6;
#line 206
				netptr = netptr->nterm;
			}
#line 208
			n = 1;
#line 209
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 210
				x = netptr->xpos;
#line 211
				y = netptr->ypos;
#line 212
				if (x < dimptr->xmin) {
#line 213
					dimptr->xmin = x;
#line 214
					dimptr->Lnum = 1;
				}
				else {
#line 216
					if (x == dimptr->xmin) {
#line 217
						(dimptr->Lnum)++;
#line 218
						if (x == dimptr->xmax) {
#line 219
							(dimptr->Rnum)++;
						}
					}
					else {
#line 222
						if (x > dimptr->xmax) {
#line 223
							dimptr->xmax = x;
#line 224
							dimptr->Rnum = 1;
						}
						else {
#line 226
							if (x == dimptr->xmax) {
#line 227
								(dimptr->Rnum)++;
							}
						}
					}
				}
#line 229
				if (y < dimptr->ymin) {
#line 230
					dimptr->ymin = y;
#line 231
					dimptr->Bnum = 1;
				}
				else {
#line 233
					if (y == dimptr->ymin) {
#line 234
						(dimptr->Bnum)++;
#line 235
						if (y == dimptr->ymax) {
#line 236
							(dimptr->Tnum)++;
						}
					}
					else {
#line 239
						if (y > dimptr->ymax) {
#line 240
							dimptr->ymax = y;
#line 241
							dimptr->Tnum = 1;
						}
						else {
#line 243
							if (y == dimptr->ymax) {
#line 244
								(dimptr->Tnum)++;
							}
						}
					}
				}
#line 246
				n++;
#line 209
				netptr = netptr->nterm;
			}
#line 248
			dimptr->numpins = n;
#line 249
			cost += (int)(dimptr->Hweight * (float)(dimptr->xmax - dimptr->xmin)) + (int)(dimptr->Vweight * (float)(dimptr->ymax - dimptr->ymin));
#line 253
			iwirex += dimptr->xmax - dimptr->xmin;
#line 254
			iwirey += dimptr->ymax - dimptr->ymin;
#line 199
			net++;
		}
#line 256
		iwire = cost;
#line 258
		n = 1;
#line 258
		while (n <= 10) {
#line 259
			net_pin_num[n] = 0;
#line 258
			n++;
		}
#line 261
		net = 1;
#line 261
		while (net <= numnets) {
#line 262
			dimptr = *(netarray + net);
#line 263
			if (dimptr->numpins >= 10) {
#line 264
				(net_pin_num[10])++;
			}
			else {
#line 267
				(net_pin_num[dimptr->numpins])++;
			}
#line 261
			net++;
		}
#line 270
		n = 1;
#line 270
		while (n <= 9) {
#line 271
			fprintf(fpo, "The number of nets with %d pin is %d\n", n, net_pin_num[n]);
#line 270
			n++;
		}
#line 274
		fprintf(fpo, "The number of nets with 10 pin or more is %d\n", net_pin_num[10]);
#line 277
		binpenal = 0;
#line 278
		rowpenal = 0;
#line 279
		penalty = 0;
#line 282
		tmp___7 = safe_malloc((unsigned int)(numblock + 1) * sizeof(BINPTR *));
#line 282
		binptr = (BINPTR **)tmp___7;
#line 285
		block___0 = 1;
#line 285
		while (block___0 <= numblock) {
#line 287
			tmp___8 = safe_malloc((unsigned int)(numBins + 1) * sizeof(BINPTR));
#line 287
			* (binptr + block___0) = (BINPTR *)tmp___8;
#line 289
			left___0 = (*(barray + block___0))->bleft + (*(barray + block___0))->bxcenter;
#line 290
			right = ((*(barray + block___0))->bleft + (*(barray + block___0))->bxcenter) + (*(barray + block___0))->desire;
#line 292
			LoBin = SetBin(left___0);
#line 293
			HiBin = SetBin(right);
#line 295
			bin = 0;
#line 295
			while (bin <= numBins) {
#line 296
				tmp___9 = safe_malloc(sizeof(BINBOX));
#line 296
				* (*(binptr + block___0) + bin) = (BINBOX *)tmp___9;
#line 298
				tmp___10 = safe_malloc(10U * sizeof(int));
#line 298
				(*(*(binptr + block___0) + bin))->cell = (int *)tmp___10;
#line 300
				bptr = *(*(binptr + block___0) + bin);
#line 301
				* (bptr->cell + 0) = 0;
#line 302
				bptr->right = binOffst + bin * binWidth;
#line 303
				bptr->left = bptr->right - binWidth;
#line 304
				if (bin == LoBin) {
#line 305
					bptr->penalty = left___0 - bptr->right;
				}
				else {
#line 307
					if (bin == HiBin) {
#line 308
						bptr->penalty = bptr->left - right;
					}
					else {
#line 310
						if (bin > HiBin) {
#line 311
							bptr->penalty = 0;
						}
						else {
#line 310
							if (bin < LoBin) {
#line 311
								bptr->penalty = 0;
							}
							else {
#line 314
								bptr->penalty = -binWidth;
							}
						}
					}
				}
#line 295
				bin++;
			}
#line 285
			block___0++;
		}
#line 320
		cell___0 = 1;
#line 320
		while (cell___0 <= numcells) {
#line 322
			cellptr1 = *(carray + cell___0);
#line 323
			tileptr1 = cellptr1->tileptr;
#line 324
			block___0 = cellptr1->cblock;
#line 326
			startx = cellptr1->cxcenter + tileptr1->left;
#line 327
			endx = cellptr1->cxcenter + tileptr1->right;
#line 329
			(*(barray + block___0))->oldsize += endx - startx;
#line 331
			cbin = SetBin(cellptr1->cxcenter);
#line 332
			LoBin = SetBin(startx);
#line 333
			HiBin = SetBin(endx);
#line 337
			(*((*(*(binptr + block___0) + cbin))->cell + 0))++;
#line 337
			k___0 = *((*(*(binptr + block___0) + cbin))->cell + 0);
#line 341
			if (k___0 % 10 == 0) {
#line 342
				tmp___11 = safe_realloc((char *)(*(*(binptr + block___0) + cbin))->cell, (unsigned int)(k___0 + 10) * sizeof(int));
#line 342
				(*(*(binptr + block___0) + cbin))->cell = (int *)tmp___11;
			}
#line 345
			* ((*(*(binptr + block___0) + cbin))->cell + k___0) = cell___0;
#line 346
			if (LoBin == HiBin) {
#line 347
				(*(*(binptr + block___0) + LoBin))->penalty += endx - startx;
			}
			else {
#line 350
				bptr = *(*(binptr + block___0) + LoBin);
#line 351
				bptr->penalty += bptr->right - startx;
#line 353
				bptr = *(*(binptr + block___0) + HiBin);
#line 354
				bptr->penalty += endx - bptr->left;
#line 356
				if (LoBin + 1 < HiBin) {
#line 357
					bin = LoBin + 1;
#line 357
					while (bin <= HiBin - 1) {
#line 358
						(*(*(binptr + block___0) + bin))->penalty += binWidth;
#line 357
						bin++;
					}
				}
			}
#line 320
			cell___0++;
		}
#line 364
		block___0 = 1;
#line 364
		while (block___0 <= numblock) {
#line 365
			bin = 0;
#line 365
			while (bin <= numBins) {
#line 366
				tmp___12 = ABS((*(*(binptr + block___0) + bin))->penalty);
#line 366
				binpenal += tmp___12;
#line 365
				bin++;
			}
#line 364
			block___0++;
		}
#line 370
		blk___0 = 1;
#line 370
		while (blk___0 <= numblock) {
#line 371
			tmp___13 = ABS((*(barray + blk___0))->oldsize - (*(barray + blk___0))->desire);
#line 371
			rowpenal += tmp___13;
#line 370
			blk___0++;
		}
#line 373
		penalty = (int)(binpenCon * (float)binpenal + roLenCon * (float)rowpenal);
#line 375
		return (cost);
	}
}
#line 1 "findcostf.o"
#pragma merger(0,"./findcostf.i","")
#line 165 "findcostf.c"
int installf(void);
#line 10 "findcostf.c"
int findcostf(void)
{
	TIBOXPTR tile;
	TIBOXPTR tileptr1;
	CBOXPTR cellptr1;
	CBOXPTR ptr;
	DBOXPTR dimptr;
	NBOXPTR netptr;
	NBOXPTR termptr;
	TEBOXPTR term;
	BINPTR bptr;
	int left___0;
	int right;
	int corient;
	int bin;
	int LoBin;
	int HiBin;
	int block___0;
	int cell___0;
	int net;
	int blk___0;
	int startx;
	int endx;
	int x;
	int y;
	int cost;
	int k___0;
	int cbin;
	int old_numBins;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	char *tmp___3;
	char *tmp___4;
	char *tmp___5;
	char *tmp___6;
	int tmp___7;
	int tmp___8;

	{
#line 22
		cost = 0;
#line 26
		blkleft = 32000;
#line 27
		blkrite = 0;
#line 28
		block___0 = 1;
#line 28
		while (block___0 <= numblock) {
#line 29
			if ((*(barray + block___0))->bxcenter + (*(barray + block___0))->bleft < blkleft) {
#line 31
				blkleft = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bleft;
			}
#line 34
			if ((*(barray + block___0))->bxcenter + (*(barray + block___0))->bright > blkrite) {
#line 36
				blkrite = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bright;
			}
#line 28
			block___0++;
		}
#line 40
		binOffst = blkleft;
#line 41
		max_blklength = blkrite - blkleft;
#line 43
		old_numBins = numBins;
#line 44
		numBins = (blkrite - binOffst) / binWidth;
#line 45
		if (blkrite - binOffst > numBins * binWidth) {
#line 46
			numBins++;
		}
#line 49
		sortpin();
#line 50
		cell___0 = 1;
#line 50
		while (cell___0 <= numcells + numterms) {
#line 51
			ptr = *(carray + cell___0);
#line 52
			corient = (int)ptr->corient;
#line 53
			block___0 = ptr->cblock;
#line 54
			tile = ptr->tileptr;
#line 55
			if (cell___0 <= numcells) {
#line 56
				ptr->cycenter = (*(barray + block___0))->bycenter;
#line 57
				term = tile->termsptr;
#line 57
				while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 59
					termptr = *(tearray + term->cellterm);
#line 60
					termptr->xpos = term->txpos[corient / 2] + ptr->cxcenter;
#line 61
					termptr->ypos = term->typos[corient % 2] + ptr->cycenter;
#line 57
					term = term->nextterm;
				}
			}
			else {
#line 64
				term = tile->termsptr;
#line 64
				while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 66
					termptr = *(tearray + term->cellterm);
#line 67
					termptr->xpos = term->txpos[1] + ptr->cxcenter;
#line 68
					termptr->ypos = term->typos[1] + ptr->cycenter;
#line 64
					term = term->nextterm;
				}
			}
#line 50
			cell___0++;
		}
#line 73
		cost = 0;
#line 74
		net = 1;
#line 74
		while (net <= numnets) {
#line 75
			dimptr = *(netarray + net);
#line 76
			netptr = dimptr->netptr;
#line 76
			if ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 77
				tmp = netptr->xpos;
#line 77
				dimptr->xmax = tmp;
#line 77
				dimptr->xmin = tmp;
#line 78
				tmp___0 = netptr->ypos;
#line 78
				dimptr->ymax = tmp___0;
#line 78
				dimptr->ymin = tmp___0;
#line 79
				tmp___1 = 1;
#line 79
				dimptr->Rnum = tmp___1;
#line 79
				dimptr->Lnum = tmp___1;
#line 80
				tmp___2 = 1;
#line 80
				dimptr->Tnum = tmp___2;
#line 80
				dimptr->Bnum = tmp___2;
#line 81
				netptr = netptr->nterm;
			}
#line 83
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 84
				x = netptr->xpos;
#line 85
				y = netptr->ypos;
#line 86
				if (x < dimptr->xmin) {
#line 87
					dimptr->xmin = x;
#line 88
					dimptr->Lnum = 1;
				}
				else {
#line 89
					if (x == dimptr->xmin) {
#line 90
						(dimptr->Lnum)++;
#line 91
						if (x == dimptr->xmax) {
#line 92
							(dimptr->Rnum)++;
						}
					}
					else {
#line 94
						if (x > dimptr->xmax) {
#line 95
							dimptr->xmax = x;
#line 96
							dimptr->Rnum = 1;
						}
						else {
#line 97
							if (x == dimptr->xmax) {
#line 98
								(dimptr->Rnum)++;
							}
						}
					}
				}
#line 100
				if (y < dimptr->ymin) {
#line 101
					dimptr->ymin = y;
#line 102
					dimptr->Bnum = 1;
				}
				else {
#line 103
					if (y == dimptr->ymin) {
#line 104
						(dimptr->Bnum)++;
#line 105
						if (y == dimptr->ymax) {
#line 106
							(dimptr->Tnum)++;
						}
					}
					else {
#line 108
						if (y > dimptr->ymax) {
#line 109
							dimptr->ymax = y;
#line 110
							dimptr->Tnum = 1;
						}
						else {
#line 111
							if (y == dimptr->ymax) {
#line 112
								(dimptr->Tnum)++;
							}
						}
					}
				}
#line 83
				netptr = netptr->nterm;
			}
#line 115
			cost += (int)(dimptr->Hweight * (float)(dimptr->xmax - dimptr->xmin)) + (int)(dimptr->Vweight * (float)(dimptr->ymax - dimptr->ymin));
#line 74
			net++;
		}
#line 122
		binpenal = 0;
#line 123
		rowpenal = 0;
#line 124
		penalty = 0;
#line 126
		block___0 = 1;
#line 126
		while (block___0 <= numblock) {
#line 127
			bin = 0;
#line 127
			while (bin <= old_numBins) {
#line 128
				safe_free((*(*(binptr + block___0) + bin))->cell);
#line 129
				safe_free(*(*(binptr + block___0) + bin));
#line 127
				bin++;
			}
#line 131
			safe_free(*(binptr + block___0));
#line 126
			block___0++;
		}
#line 134
		block___0 = 1;
#line 134
		while (block___0 <= numblock) {
#line 136
			tmp___3 = safe_malloc((unsigned int)(numBins + 1) * sizeof(BINPTR));
#line 136
			* (binptr + block___0) = (BINPTR *)tmp___3;
#line 138
			left___0 = (*(barray + block___0))->bleft + (*(barray + block___0))->bxcenter;
#line 139
			right = ((*(barray + block___0))->bleft + (*(barray + block___0))->bxcenter) + (*(barray + block___0))->desire;
#line 141
			LoBin = SetBin(left___0);
#line 142
			HiBin = SetBin(right);
#line 144
			bin = 0;
#line 144
			while (bin <= numBins) {
#line 145
				tmp___4 = safe_malloc(sizeof(BINBOX));
#line 145
				* (*(binptr + block___0) + bin) = (BINBOX *)tmp___4;
#line 147
				tmp___5 = safe_malloc(10U * sizeof(int));
#line 147
				(*(*(binptr + block___0) + bin))->cell = (int *)tmp___5;
#line 149
				bptr = *(*(binptr + block___0) + bin);
#line 150
				* (bptr->cell + 0) = 0;
#line 151
				bptr->right = binOffst + bin * binWidth;
#line 152
				bptr->left = bptr->right - binWidth;
#line 153
				if (bin == LoBin) {
#line 154
					bptr->penalty = left___0 - bptr->right;
				}
				else {
#line 155
					if (bin == HiBin) {
#line 156
						bptr->penalty = bptr->left - right;
					}
					else {
#line 157
						if (bin > HiBin) {
#line 158
							bptr->penalty = 0;
						}
						else {
#line 157
							if (bin < LoBin) {
#line 158
								bptr->penalty = 0;
							}
							else {
#line 160
								bptr->penalty = -binWidth;
							}
						}
					}
				}
#line 144
				bin++;
			}
#line 134
			block___0++;
		}
#line 165
		installf();
#line 167
		cell___0 = 1;
#line 167
		while (cell___0 <= numcells) {
#line 169
			cellptr1 = *(carray + cell___0);
#line 170
			tileptr1 = cellptr1->tileptr;
#line 171
			block___0 = cellptr1->cblock;
#line 173
			startx = cellptr1->cxcenter + tileptr1->left;
#line 174
			endx = cellptr1->cxcenter + tileptr1->right;
#line 176
			(*(barray + block___0))->oldsize += endx - startx;
#line 178
			cbin = SetBin(cellptr1->cxcenter);
#line 179
			LoBin = SetBin(startx);
#line 180
			HiBin = SetBin(endx);
#line 182
			(*((*(*(binptr + block___0) + cbin))->cell + 0))++;
#line 182
			k___0 = *((*(*(binptr + block___0) + cbin))->cell + 0);
#line 183
			if (k___0 % 10 == 0) {
#line 184
				tmp___6 = safe_realloc((char *)(*(*(binptr + block___0) + cbin))->cell, (unsigned int)(k___0 + 10) * sizeof(int));
#line 184
				(*(*(binptr + block___0) + cbin))->cell = (int *)tmp___6;
			}
#line 187
			* ((*(*(binptr + block___0) + cbin))->cell + k___0) = cell___0;
#line 188
			if (LoBin == HiBin) {
#line 189
				(*(*(binptr + block___0) + LoBin))->penalty += endx - startx;
			}
			else {
#line 191
				bptr = *(*(binptr + block___0) + LoBin);
#line 192
				bptr->penalty += bptr->right - startx;
#line 194
				bptr = *(*(binptr + block___0) + HiBin);
#line 195
				bptr->penalty += endx - bptr->left;
#line 197
				if (LoBin + 1 < HiBin) {
#line 198
					bin = LoBin + 1;
#line 198
					while (bin <= HiBin - 1) {
#line 199
						(*(*(binptr + block___0) + bin))->penalty += binWidth;
#line 198
						bin++;
					}
				}
			}
#line 167
			cell___0++;
		}
#line 205
		block___0 = 1;
#line 205
		while (block___0 <= numblock) {
#line 206
			bin = 0;
#line 206
			while (bin <= numBins) {
#line 207
				tmp___7 = ABS((*(*(binptr + block___0) + bin))->penalty);
#line 207
				binpenal += tmp___7;
#line 206
				bin++;
			}
#line 205
			block___0++;
		}
#line 211
		blk___0 = 1;
#line 211
		while (blk___0 <= numblock) {
#line 212
			tmp___8 = ABS((*(barray + blk___0))->oldsize - (*(barray + blk___0))->desire);
#line 212
			rowpenal += tmp___8;
#line 211
			blk___0++;
		}
#line 214
		penalty = (int)(binpenCon * (float)binpenal + roLenCon * (float)rowpenal);
#line 216
		return (cost);
	}
}
#line 222 "findcostf.c"
int installf(void)
{
	int row___0;
	int n;
	int left___0;
	int length;
	int sep;
	int i;
	int bin;

	{
#line 227
		row___0 = 1;
#line 227
		while (row___0 <= numRows) {
#line 228
			n = *(feeds_in_row + row___0);
#line 229
			if (n < 1) {
				goto __Cont;
			}
#line 232
			left___0 = (*(barray + row___0))->bxcenter + (*(barray + row___0))->bleft;
#line 233
			length = (*(barray + row___0))->bright - (*(barray + row___0))->bleft;
#line 234
			sep = (length - n * binWidth) / (n + 1);
#line 235
			i = 1;
#line 235
			while (i <= n) {
#line 236
				bin = SetBin((left___0 + sep * i) + binWidth / 2);
#line 237
				(*(*(binptr + row___0) + bin))->penalty += binWidth;
#line 238
				(*(barray + row___0))->oldsize += binWidth;
#line 235
				i++;
			}
		__Cont: /* CIL Label */
#line 227
			row___0++;
		}
#line 242
		return;
	}
}
#line 1 "findest.o"
#pragma merger(0,"./findest.i","")
#line 2 "findest.c"
int no_feeds_side_nets;
#line 7 "findest.c"
void assignro(void)
{
	TEBOXPTR pinptr;
	NBOXPTR tmptr;
	int row___0;
	int cell___0;
	int pad___0;
	int yc;
	int yb;
	int blk___0;
	char *tmp;
	char *tmp___0;

	{
#line 14
		tmp = safe_malloc((unsigned int)(numRows + 2) * sizeof(int *));
#line 14
		rowgrid = (int **)tmp;
#line 16
		row___0 = 0;
#line 16
		while (row___0 <= numRows + 1) {
#line 17
			tmp___0 = safe_malloc(3U * sizeof(int));
#line 17
			* (rowgrid + row___0) = (int *)tmp___0;
#line 16
			row___0++;
		}
#line 20
		cell___0 = 1;
#line 20
		while (cell___0 <= numcells) {
#line 21
			pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 22
			row___0 = *(blkToRow + (*(carray + cell___0))->cblock);
#line 23
			while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 24
				tmptr = *(tearray + pinptr->cellterm);
#line 25
				tmptr->row = row___0;
#line 23
				pinptr = pinptr->nextterm;
			}
#line 20
			cell___0++;
		}
#line 28
		pad___0 = numcells + 1;
#line 28
		while (pad___0 <= numcells + numterms) {
#line 29
			if ((*(carray + pad___0))->padside == 2) {
				goto _L___0;
			}
			else {
#line 29
				if ((*(carray + pad___0))->padside == 14) {
				_L___0: /* CIL Label */
#line 30
					row___0 = numRows + 1;
#line 31
					pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 32
					while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 33
						tmptr = *(tearray + pinptr->cellterm);
#line 34
						tmptr->row = row___0;
#line 32
						pinptr = pinptr->nextterm;
					}
				}
				else {
#line 36
					if ((*(carray + pad___0))->padside == 4) {
						goto _L;
					}
					else {
#line 36
						if ((*(carray + pad___0))->padside == 15) {
						_L: /* CIL Label */
#line 37
							row___0 = 0;
#line 38
							pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 39
							while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 40
								tmptr = *(tearray + pinptr->cellterm);
#line 41
								tmptr->row = row___0;
#line 39
								pinptr = pinptr->nextterm;
							}
						}
						else {
#line 44
							pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 45
							while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 46
								tmptr = *(tearray + pinptr->cellterm);
#line 47
								if (no_feeds_side_nets == 1) {
#line 48
									if ((*(carray + pad___0))->padside == 1) {
#line 50
										(*(netarray + tmptr->net))->feedflag = (char)1;
									}
									else {
#line 48
										if ((*(carray + pad___0))->padside == 3) {
#line 50
											(*(netarray + tmptr->net))->feedflag = (char)1;
										}
									}
								}
#line 53
								yc = (*(carray + pad___0))->cycenter + pinptr->typos[1];
#line 54
								blk___0 = 1;
#line 54
								while (blk___0 <= numRows) {
#line 55
									if ((rowArray + blk___0)->ypos >= yc) {
#line 56
										break;
									}
#line 54
									blk___0++;
								}
#line 59
								if (blk___0 == 1) {
#line 60
									row___0 = 1;
								}
								else {
#line 61
									if (blk___0 > numRows) {
#line 62
										row___0 = numRows;
									}
									else {
#line 64
										yb = (rowArray + blk___0)->ypos;
#line 65
										if (yb - yc < yc - (rowArray + (blk___0 - 1))->ypos) {
#line 66
											row___0 = blk___0;
										}
										else {
#line 68
											row___0 = blk___0 - 1;
										}
									}
								}
#line 71
								tmptr->row = row___0;
#line 45
								pinptr = pinptr->nextterm;
							}
						}
					}
				}
			}
#line 28
			pad___0++;
		}
#line 75
		return;
	}
}
#line 77 "findest.c"
void reassign(void)
{
	TEBOXPTR pinptr;
	NBOXPTR tmptr;
	int row___0;
	int cell___0;
	int pad___0;
	int yc;
	int yb;
	int blk___0;

	{
#line 85
		cell___0 = 1;
#line 85
		while (cell___0 <= numcells) {
#line 86
			pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 87
			row___0 = *(blkToRow + (*(carray + cell___0))->cblock);
#line 88
			while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 89
				tmptr = *(tearray + pinptr->cellterm);
#line 90
				tmptr->row = row___0;
#line 88
				pinptr = pinptr->nextterm;
			}
#line 85
			cell___0++;
		}
#line 93
		pad___0 = numcells + 1;
#line 93
		while (pad___0 <= numcells + numterms) {
#line 94
			if ((*(carray + pad___0))->padside == 2) {
				goto _L___0;
			}
			else {
#line 94
				if ((*(carray + pad___0))->padside == 14) {
				_L___0: /* CIL Label */
#line 95
					row___0 = numRows + 1;
#line 96
					pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 97
					while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 98
						tmptr = *(tearray + pinptr->cellterm);
#line 99
						tmptr->row = row___0;
#line 97
						pinptr = pinptr->nextterm;
					}
				}
				else {
#line 101
					if ((*(carray + pad___0))->padside == 4) {
						goto _L;
					}
					else {
#line 101
						if ((*(carray + pad___0))->padside == 15) {
						_L: /* CIL Label */
#line 102
							row___0 = 0;
#line 103
							pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 104
							while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 105
								tmptr = *(tearray + pinptr->cellterm);
#line 106
								tmptr->row = row___0;
#line 104
								pinptr = pinptr->nextterm;
							}
						}
						else {
#line 109
							pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 110
							while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 111
								tmptr = *(tearray + pinptr->cellterm);
#line 112
								if (no_feeds_side_nets == 1) {
#line 113
									if ((*(carray + pad___0))->padside == 1) {
#line 115
										(*(netarray + tmptr->net))->feedflag = (char)1;
									}
									else {
#line 113
										if ((*(carray + pad___0))->padside == 3) {
#line 115
											(*(netarray + tmptr->net))->feedflag = (char)1;
										}
									}
								}
#line 118
								yc = (*(carray + pad___0))->cycenter + pinptr->typos[1];
#line 119
								blk___0 = 1;
#line 119
								while (blk___0 <= numRows) {
#line 120
									if ((rowArray + blk___0)->ypos >= yc) {
#line 121
										break;
									}
#line 119
									blk___0++;
								}
#line 124
								if (blk___0 == 1) {
#line 125
									row___0 = 1;
								}
								else {
#line 126
									if (blk___0 > numRows) {
#line 127
										row___0 = numRows;
									}
									else {
#line 129
										yb = (rowArray + blk___0)->ypos;
#line 130
										if (yb - yc < yc - (rowArray + (blk___0 - 1))->ypos) {
#line 131
											row___0 = blk___0;
										}
										else {
#line 133
											row___0 = blk___0 - 1;
										}
									}
								}
#line 136
								tmptr->row = row___0;
#line 110
								pinptr = pinptr->nextterm;
							}
						}
					}
				}
			}
#line 93
			pad___0++;
		}
#line 141
		return;
	}
}
#line 1 "findfeeds.o"
#pragma merger(0,"./findfeeds.i","")
#line 2 "findfeeds.c"
int *length_of_row;
#line 3
int *add_to_row;
#line 4 "findfeeds.c"
int *act_feeds_in_row;
#line 5 "findfeeds.c"
int pad_line;
#line 6 "findfeeds.c"
int last_feed;
#line 7
int gate_array_special;
#line 8
int addFeeds;
#line 9
int *nofeed;
#line 11
int ffeeds;
#line 13
int feedLayer;
#line 32 "findfeeds.c"
int impcount;
#line 35 "findfeeds.c"
int *feed_location;
#line 51
int prepglob(int degree);
#line 60
void impfix(void);
#line 102
int del_pin(int cell___0, int pin);
#line 146
int detfeed(int flag, int row___0, int net);
#line 368
int implfeeds(int row___0, int xc);
#line 384
int addfeed(int row___0, int pos, int feednum, int net);
#line 574
void impclobr(void);
#line 38 "findfeeds.c"
int findfeeds(int flag)
{
	NBOXPTR netptr;
	NBOXPTR saveptr;
	int check;
	int a___0;
	int net;
	int i;
	int row___0;
	int l;
	int r;
	int toprow;
	int botrow;
	int orig_toprow;
	int orig_botrow;
	int TOP_ROW_FOR_NET;
	int position;
	int max_row_length;
	int first_ok;
	int second_ok;
	int rowb;
	int rowt;
	int have_to_check;
	char *tmp;
	char *tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	int tmp___7;
	int tmp___8;
	int tmp___9;
	int tmp___10;

	{
#line 48
		feeds = 0;
#line 50
		if (!flag) {
#line 51
			prepglob(0);
#line 52
			impcount = 0;
#line 53
			tmp = safe_malloc((unsigned int)(1 + numRows) * sizeof(int));
#line 53
			act_feeds_in_row = (int *)tmp;
#line 55
			row___0 = 1;
#line 55
			while (row___0 <= numRows) {
#line 56
				* (act_feeds_in_row + row___0) = 0;
#line 55
				row___0++;
			}
		}
		else {
#line 59
			pad_line = (numcells + ffeeds) + *(add_to_row + 0);
#line 60
			impfix();
		}
#line 63
		tmp___0 = safe_malloc((unsigned int)(1 + numnets) * sizeof(int));
#line 63
		feed_location = (int *)tmp___0;
#line 65
		net = 0;
#line 65
		while (net <= numnets) {
#line 66
			* (feed_location + net) = 0;
#line 65
			net++;
		}
#line 69
		net = 1;
#line 69
		while (net <= numnets) {
#line 70
			if ((int)(*(netarray + net))->feedflag == 1) {
				goto __Cont;
			}
#line 73
			netptr = (*(netarray + net))->netptr;
#line 73
			if ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 74
				i = 0;
#line 74
				while (i <= numRows + 1) {
#line 75
					* (*(rowgrid + i) + 0) = 32000;
#line 76
					* (*(rowgrid + i) + 1) = -1000;
#line 77
					* (*(rowgrid + i) + 2) = -2;
#line 74
					i++;
				}
#line 79
				while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 80
					if (flag == 0) {
#line 80
						if (netptr->cell > numcells) {
							goto _L___1;
						}
						else {
							goto _L___2;
						}
					}
					else {
					_L___2: /* CIL Label */
#line 80
						if (flag == 1) {
#line 80
							if (netptr->cell > pad_line) {
							_L___1: /* CIL Label */
#line 82
								if ((*(carray + netptr->cell))->padside == 1) {
									goto __Cont___0;
								}
								else {
#line 82
									if ((*(carray + netptr->cell))->padside == 9) {
										goto __Cont___0;
									}
									else {
#line 82
										if ((*(carray + netptr->cell))->padside == 5) {
											goto __Cont___0;
										}
										else {
#line 82
											if ((*(carray + netptr->cell))->padside == 7) {
												goto __Cont___0;
											}
											else {
#line 82
												if ((*(carray + netptr->cell))->padside == 3) {
													goto __Cont___0;
												}
												else {
#line 82
													if ((*(carray + netptr->cell))->padside == 10) {
														goto __Cont___0;
													}
													else {
#line 82
														if ((*(carray + netptr->cell))->padside == 6) {
															goto __Cont___0;
														}
														else {
#line 82
															if ((*(carray + netptr->cell))->padside == 8) {
																goto __Cont___0;
															}
															else {
#line 91
																if ((unsigned int)netptr->nterm != (unsigned int)((void *)0)) {
#line 92
																	if ((netptr->nterm)->extint == netptr->extint) {
#line 93
																		while (1) {
#line 94
																			if ((netptr->nterm)->extint == netptr->extint) {
#line 95
																				if (netptr->row > numRows) {
#line 95
																					if (netptr->ypos <= (netptr->nterm)->ypos) {
#line 100
																						saveptr = netptr->nterm;
#line 101
																						netptr->nterm = saveptr->nterm;
#line 102
																						del_pin(saveptr->cell, saveptr->terminal);
#line 104
																						safe_free(saveptr);
																					}
																					else {
																						goto _L___0;
																					}
																				}
																				else {
																				_L___0: /* CIL Label */
#line 95
																					if (netptr->row < 1) {
#line 95
																						if (netptr->ypos >= (netptr->nterm)->ypos) {
#line 100
																							saveptr = netptr->nterm;
#line 101
																							netptr->nterm = saveptr->nterm;
#line 102
																							del_pin(saveptr->cell, saveptr->terminal);
#line 104
																							safe_free(saveptr);
																						}
																						else {
																							goto _L;
																						}
																					}
																					else {
																					_L: /* CIL Label */
#line 106
																						if ((unsigned int)netptr == (unsigned int)(*(netarray + net))->netptr) {
#line 107
																							(*(netarray + net))->netptr = netptr->nterm;
#line 108
																							del_pin(netptr->cell, netptr->terminal);
#line 110
																							safe_free(netptr);
#line 111
																							netptr = (*(netarray + net))->netptr;
																						}
																						else {
#line 113
																							saveptr = (*(netarray + net))->netptr;
#line 114
																							while (1) {
#line 115
																								if ((unsigned int)saveptr->nterm == (unsigned int)netptr) {
#line 116
																									break;
																								}
																								else {
#line 118
																									saveptr = saveptr->nterm;
																								}
																							}
#line 121
																							saveptr->nterm = netptr->nterm;
#line 122
																							del_pin(netptr->cell, netptr->terminal);
#line 124
																							safe_free(netptr);
#line 125
																							netptr = saveptr->nterm;
																						}
																					}
																				}
#line 128
																				if ((unsigned int)netptr->nterm == (unsigned int)((void *)0)) {
#line 129
																					break;
																				}
																			}
																			else {
#line 132
																				break;
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
#line 138
					row___0 = netptr->row;
#line 139
					if (netptr->xpos > *(*(rowgrid + row___0) + 1)) {
#line 140
						* (*(rowgrid + row___0) + 1) = netptr->xpos;
					}
#line 142
					if (netptr->xpos < *(*(rowgrid + row___0) + 0)) {
#line 143
						* (*(rowgrid + row___0) + 0) = netptr->xpos;
					}
#line 145
					if (*(*(rowgrid + row___0) + 2) == -2) {
#line 146
						* (*(rowgrid + row___0) + 2) = detfeed(flag, row___0, net);
					}
				__Cont___0: /* CIL Label */
#line 79
					netptr = netptr->nterm;
				}
#line 149
				botrow = 0;
#line 150
				toprow = numRows + 1;
#line 151
				while (botrow <= numRows + 1) {
#line 152
					if (*(*(rowgrid + botrow) + 1) != -1000) {
#line 153
						break;
					}
#line 151
					botrow++;
				}
#line 156
				while (toprow >= 0) {
#line 157
					if (*(*(rowgrid + toprow) + 1) != -1000) {
#line 158
						break;
					}
#line 156
					toprow--;
				}
#line 162
				orig_toprow = toprow;
#line 163
				orig_botrow = botrow;
#line 164
				netptr = (*(netarray + net))->netptr;
#line 165
				while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 166
					if (flag == 0) {
#line 166
						if (netptr->cell <= numcells) {
							goto __Cont___1;
						}
						else {
							goto _L___3;
						}
					}
					else {
					_L___3: /* CIL Label */
#line 166
						if (flag == 1) {
#line 166
							if (netptr->cell <= pad_line) {
								goto __Cont___1;
							}
						}
					}
#line 170
					if ((*(carray + netptr->cell))->padside != 1) {
#line 170
						if ((*(carray + netptr->cell))->padside != 9) {
#line 170
							if ((*(carray + netptr->cell))->padside != 5) {
#line 170
								if ((*(carray + netptr->cell))->padside != 7) {
#line 170
									if ((*(carray + netptr->cell))->padside != 3) {
#line 170
										if ((*(carray + netptr->cell))->padside != 10) {
#line 170
											if ((*(carray + netptr->cell))->padside != 6) {
#line 170
												if ((*(carray + netptr->cell))->padside != 8) {
													goto __Cont___1;
												}
											}
										}
									}
								}
							}
						}
					}
#line 180
					if ((unsigned int)netptr->nterm != (unsigned int)((void *)0)) {
#line 181
						if ((netptr->nterm)->extint == netptr->extint) {
#line 182
							have_to_check = 1;
						}
						else {
#line 184
							have_to_check = 0;
						}
					}
					else {
#line 187
						have_to_check = 0;
					}
#line 189
					if (have_to_check) {
#line 190
						while (1) {
#line 191
							if ((netptr->nterm)->extint == netptr->extint) {
#line 196
								row___0 = netptr->row;
#line 197
								if (row___0 <= toprow) {
#line 197
									if (row___0 >= botrow) {
#line 198
										first_ok = 0;
									}
								}
#line 200
								if (row___0 > toprow) {
#line 201
									first_ok = row___0 - toprow;
								}
#line 203
								if (row___0 < botrow) {
#line 204
									first_ok = botrow - row___0;
								}
#line 206
								row___0 = (netptr->nterm)->row;
#line 207
								if (row___0 <= toprow) {
#line 207
									if (row___0 >= botrow) {
#line 208
										second_ok = 0;
									}
								}
#line 210
								if (row___0 > toprow) {
#line 211
									second_ok = row___0 - toprow;
								}
#line 213
								if (row___0 < botrow) {
#line 214
									second_ok = botrow - row___0;
								}
#line 217
								if (first_ok == second_ok) {
#line 218
									first_ok = 1000000;
#line 219
									if (netptr->row - 1 >= 0) {
#line 219
										rowb = netptr->row - 1;
									}
									else {
#line 219
										rowb = 0;
									}
#line 221
									if (netptr->row + 1 <= numRows + 1) {
#line 221
										rowt = netptr->row + 1;
									}
									else {
#line 221
										rowt = numRows + 1;
									}
#line 223
									row___0 = rowb;
#line 223
									while (row___0 <= rowt) {
#line 224
										if (*(*(rowgrid + row___0) + 1) == -1000) {
											goto __Cont___2;
										}
#line 227
										if (netptr->xpos <= *(*(rowgrid + row___0) + 1)) {
#line 227
											if (netptr->xpos >= *(*(rowgrid + row___0) + 0)) {
#line 231
												first_ok = 0;
											}
											else {
												goto _L___4;
											}
										}
										else {
										_L___4: /* CIL Label */
#line 232
											if (netptr->xpos > *(*(rowgrid + row___0) + 1)) {
#line 234
												if (netptr->xpos - *(*(rowgrid + row___0) + 1) < first_ok) {
#line 237
													first_ok = netptr->xpos - *(*(rowgrid + row___0) + 1);
												}
											}
											else {
#line 241
												if (*(*(rowgrid + row___0) + 0) - netptr->xpos < first_ok) {
#line 243
													first_ok = *(*(rowgrid + row___0) + 0) - netptr->xpos;
												}
											}
										}
									__Cont___2: /* CIL Label */
#line 223
										row___0++;
									}
#line 249
									second_ok = 1000000;
#line 250
									if ((netptr->nterm)->row - 1 >= 0) {
#line 250
										rowb = (netptr->nterm)->row - 1;
									}
									else {
#line 250
										rowb = 0;
									}
#line 252
									if ((netptr->nterm)->row + 1 <= numRows + 1) {
#line 252
										rowt = (netptr->nterm)->row + 1;
									}
									else {
#line 252
										rowt = numRows + 1;
									}
#line 255
									row___0 = rowb;
#line 255
									while (row___0 <= rowt) {
#line 256
										if (*(*(rowgrid + row___0) + 1) == -1000) {
											goto __Cont___3;
										}
#line 259
										if ((netptr->nterm)->xpos <= *(*(rowgrid + row___0) + 1)) {
#line 259
											if ((netptr->nterm)->xpos >= *(*(rowgrid + row___0) + 0)) {
#line 263
												second_ok = 0;
											}
											else {
												goto _L___5;
											}
										}
										else {
										_L___5: /* CIL Label */
#line 264
											if ((netptr->nterm)->xpos > *(*(rowgrid + row___0) + 1)) {
#line 266
												if ((netptr->nterm)->xpos - *(*(rowgrid + row___0) + 1) < second_ok) {
#line 269
													second_ok = (netptr->nterm)->xpos - *(*(rowgrid + row___0) + 1);
												}
											}
											else {
#line 273
												if (*(*(rowgrid + row___0) + 0) - (netptr->nterm)->xpos < second_ok) {
#line 275
													second_ok = *(*(rowgrid + row___0) + 0) - (netptr->nterm)->xpos;
												}
											}
										}
									__Cont___3: /* CIL Label */
#line 255
										row___0++;
									}
								}
#line 281
								if (first_ok <= second_ok) {
#line 282
									saveptr = netptr->nterm;
#line 283
									netptr->nterm = saveptr->nterm;
#line 284
									del_pin(saveptr->cell, saveptr->terminal);
#line 285
									safe_free(saveptr);
								}
								else {
#line 287
									if ((unsigned int)netptr == (unsigned int)(*(netarray + net))->netptr) {
#line 288
										(*(netarray + net))->netptr = netptr->nterm;
#line 289
										del_pin(netptr->cell, netptr->terminal);
#line 290
										safe_free(netptr);
#line 291
										netptr = (*(netarray + net))->netptr;
									}
									else {
#line 293
										saveptr = (*(netarray + net))->netptr;
#line 294
										while (1) {
#line 295
											if ((unsigned int)saveptr->nterm == (unsigned int)netptr) {
#line 296
												break;
											}
											else {
#line 298
												saveptr = saveptr->nterm;
											}
										}
#line 301
										saveptr->nterm = netptr->nterm;
#line 302
										del_pin(netptr->cell, netptr->terminal);
#line 303
										safe_free(netptr);
#line 304
										netptr = saveptr->nterm;
									}
								}
#line 307
								if ((unsigned int)netptr->nterm == (unsigned int)((void *)0)) {
#line 308
									break;
								}
							}
							else {
#line 311
								break;
							}
						}
					}
#line 316
					row___0 = netptr->row;
#line 317
					if (row___0 <= orig_toprow) {
#line 317
						if (row___0 >= orig_botrow) {
							goto __Cont___1;
						}
					}
#line 320
					if (row___0 > toprow) {
#line 321
						toprow = row___0;
					}
#line 323
					if (row___0 < botrow) {
#line 324
						botrow = row___0;
					}
#line 326
					if (netptr->xpos > *(*(rowgrid + row___0) + 1)) {
#line 327
						* (*(rowgrid + row___0) + 1) = netptr->xpos;
					}
#line 329
					if (netptr->xpos < *(*(rowgrid + row___0) + 0)) {
#line 330
						* (*(rowgrid + row___0) + 0) = netptr->xpos;
					}
#line 332
					if (*(*(rowgrid + row___0) + 2) == -2) {
#line 333
						* (*(rowgrid + row___0) + 2) = detfeed(flag, row___0, net);
					}
				__Cont___1: /* CIL Label */
#line 165
					netptr = netptr->nterm;
				}
#line 338
				if (toprow != botrow) {
#line 339
					row___0 = toprow;
#line 340
					TOP_ROW_FOR_NET = 1;
#line 341
					row___0--;
#line 341
					while (row___0 >= botrow) {
#line 342
						if (*(*(rowgrid + row___0) + 1) == -1000) {
							goto __Cont___4;
						}
#line 345
						if (*(*(rowgrid + toprow) + 0) <= *(*(rowgrid + row___0) + 0)) {
#line 345
							l = *(*(rowgrid + toprow) + 0);
						}
						else {
#line 345
							l = *(*(rowgrid + row___0) + 0);
						}
#line 349
						if (*(*(rowgrid + toprow) + 1) >= *(*(rowgrid + row___0) + 1)) {
#line 349
							r = *(*(rowgrid + toprow) + 1);
						}
						else {
#line 349
							r = *(*(rowgrid + row___0) + 1);
						}
#line 354
						position = (l + r) / 2;
#line 355
						if (gate_array_special) {
#line 356
							if (*(feed_location + net) == 0) {
#line 357
								* (feed_location + net) = position;
							}
							else {
#line 359
								position = *(feed_location + net);
							}
						}
#line 363
						if (TOP_ROW_FOR_NET == 1) {
#line 364
							if (*(*(rowgrid + toprow) + 2) == 1) {
								goto _L___6;
							}
							else {
#line 364
								if (*(*(rowgrid + toprow) + 2) == 3) {
								_L___6: /* CIL Label */
#line 366
									if (!*(nofeed + toprow)) {
#line 367
										if (flag == 0) {
#line 368
											tmp___1 = implfeeds(toprow, position);
#line 368
											if (tmp___1) {
#line 369
												impcount++;
											}
											else {
#line 371
												feeds++;
#line 372
												(*(act_feeds_in_row + toprow))++;
#line 374
												if (gate_array_special == 1) {
#line 375
													build_feed_imp(feeds, position - fdWidth / 2, toprow);
												}
											}
										}
										else {
#line 381
											tmp___2 = implfeeds(toprow, position);
#line 381
											if (tmp___2) {
#line 382
												addimp(toprow, net);
											}
											else {
#line 384
												feeds++;
#line 384
												addfeed(toprow, position, feeds, net);
#line 387
												if (gate_array_special == 1) {
#line 388
													build_feed_imp(feeds, position - fdWidth / 2, toprow);
												}
											}
										}
									}
								}
							}
						}
#line 398
						if (row___0 > botrow) {
#line 399
							if (*(*(rowgrid + row___0) + 2) != 4) {
#line 400
								if (!*(nofeed + row___0)) {
#line 401
									if (flag == 0) {
#line 402
										tmp___3 = implfeeds(row___0, position);
#line 402
										if (tmp___3) {
#line 403
											impcount++;
										}
										else {
#line 405
											feeds++;
#line 406
											(*(act_feeds_in_row + row___0))++;
#line 408
											if (gate_array_special == 1) {
#line 409
												build_feed_imp(feeds, position - fdWidth / 2, row___0);
											}
										}
									}
									else {
#line 415
										tmp___4 = implfeeds(row___0, position);
#line 415
										if (tmp___4) {
#line 416
											addimp(row___0, net);
										}
										else {
#line 418
											feeds++;
#line 418
											addfeed(row___0, position, feeds, net);
#line 421
											if (gate_array_special == 1) {
#line 422
												build_feed_imp(feeds, position - fdWidth / 2, row___0);
											}
										}
									}
								}
							}
						}
#line 432
						if (row___0 == botrow) {
#line 433
							if (*(*(rowgrid + botrow) + 2) == 2) {
								goto _L___7;
							}
							else {
#line 433
								if (*(*(rowgrid + botrow) + 2) == 3) {
								_L___7: /* CIL Label */
#line 435
									if (!*(nofeed + botrow)) {
#line 436
										if (flag == 0) {
#line 437
											tmp___5 = implfeeds(botrow, position);
#line 437
											if (tmp___5) {
#line 438
												impcount++;
											}
											else {
#line 440
												feeds++;
#line 441
												(*(act_feeds_in_row + botrow))++;
#line 443
												if (gate_array_special == 1) {
#line 444
													build_feed_imp(feeds, position - fdWidth / 2, botrow);
												}
											}
										}
										else {
#line 450
											tmp___6 = implfeeds(botrow, position);
#line 450
											if (tmp___6) {
#line 451
												addimp(botrow, net);
											}
											else {
#line 453
												feeds++;
#line 453
												addfeed(botrow, position, feeds, net);
#line 456
												if (gate_array_special == 1) {
#line 457
													build_feed_imp(feeds, position - fdWidth / 2, botrow);
												}
											}
										}
									}
								}
							}
						}
#line 466
						check = (toprow - row___0) - 1;
#line 467
						if (check != 0) {
#line 468
							a___0 = toprow - 1;
#line 468
							while (a___0 > row___0) {
#line 469
								if (!*(nofeed + a___0)) {
#line 470
									if (flag == 0) {
#line 471
										tmp___7 = implfeeds(a___0, position);
#line 471
										if (tmp___7) {
#line 472
											impcount++;
										}
										else {
#line 474
											feeds++;
#line 475
											(*(act_feeds_in_row + a___0))++;
#line 477
											if (gate_array_special == 1) {
#line 478
												build_feed_imp(feeds, position - fdWidth / 2, a___0);
											}
										}
									}
									else {
#line 483
										tmp___8 = implfeeds(a___0, position);
#line 483
										if (tmp___8) {
#line 484
											addimp(a___0, net);
										}
										else {
#line 486
											feeds++;
#line 486
											addfeed(a___0, position, feeds, net);
#line 489
											if (gate_array_special == 1) {
#line 490
												build_feed_imp(feeds, position - fdWidth / 2, a___0);
											}
										}
									}
								}
#line 468
								a___0--;
							}
						}
#line 498
						toprow = row___0;
#line 499
						TOP_ROW_FOR_NET = 0;
					__Cont___4: /* CIL Label */
#line 341
						row___0--;
					}
				}
				else {
#line 502
					if ((int)(*(netarray + net))->feedflag == 0) {
#line 503
						if (*(*(rowgrid + toprow) + 2) == 3) {
#line 504
							if (!*(nofeed + toprow)) {
#line 506
								l = *(*(rowgrid + toprow) + 0);
#line 507
								r = *(*(rowgrid + toprow) + 1);
#line 508
								position = (l + r) / 2;
#line 509
								if (gate_array_special) {
#line 510
									if (*(feed_location + net) == 0) {
#line 511
										* (feed_location + net) = position;
									}
									else {
#line 513
										position = *(feed_location + net);
									}
								}
#line 517
								if (flag == 0) {
#line 518
									tmp___9 = implfeeds(toprow, position);
#line 518
									if (tmp___9) {
#line 519
										impcount++;
									}
									else {
#line 521
										feeds++;
#line 522
										(*(act_feeds_in_row + toprow))++;
#line 524
										if (gate_array_special == 1) {
#line 525
											build_feed_imp(feeds, position - fdWidth / 2, toprow);
										}
									}
								}
								else {
#line 532
									tmp___10 = implfeeds(toprow, position);
#line 532
									if (tmp___10) {
#line 533
										addimp(toprow, net);
									}
									else {
#line 535
										feeds++;
#line 535
										addfeed(toprow, position, feeds, net);
#line 537
										if (gate_array_special == 1) {
#line 538
											build_feed_imp(feeds, position - fdWidth / 2, toprow);
										}
									}
								}
							}
						}
					}
				}
			}
		__Cont: /* CIL Label */
#line 69
			net++;
		}
#line 550
		if (flag == 0) {
#line 551
			ffeeds = feeds;
#line 553
			row___0 = 1;
#line 553
			while (row___0 <= numRows) {
#line 554
				* (length_of_row + row___0) += *(act_feeds_in_row + row___0) * fdWidth;
#line 553
				row___0++;
			}
#line 556
			max_row_length = 0;
#line 557
			row___0 = 1;
#line 557
			while (row___0 <= numRows) {
#line 558
				if (*(length_of_row + row___0) > max_row_length) {
#line 559
					max_row_length = *(length_of_row + row___0);
				}
#line 557
				row___0++;
			}
#line 562
			* (add_to_row + 0) = 0;
#line 563
			row___0 = 1;
#line 563
			while (row___0 <= numRows) {
#line 564
				* (add_to_row + row___0) = (max_row_length - *(length_of_row + row___0)) / fdWidth;
#line 566
				* (add_to_row + 0) += *(add_to_row + row___0);
#line 563
				row___0++;
			}
#line 568
			safe_free(length_of_row);
#line 570
			if (addFeeds) {
#line 571
				prepglob(1);
			}
		}
		else {
#line 574
			impclobr();
#line 575
			last_feed = feeds;
		}
#line 577
		safe_free(feed_location);
#line 579
		return (feeds);
	}
}
#line 587 "findfeeds.c"
int del_pin(int cell___0, int pin)
{
	TEBOXPTR tptr;
	TEBOXPTR sptr;

	{
#line 592
		((*(carray + cell___0))->numterms)--;
#line 593
		tptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 594
		if (tptr->cellterm == pin) {
#line 595
			sptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 596
			((*(carray + cell___0))->tileptr)->termsptr = tptr->nextterm;
#line 597
			safe_free(sptr);
		}
		else {
#line 599
			while (1) {
#line 600
				if ((tptr->nextterm)->cellterm == pin) {
#line 601
					break;
				}
				else {
#line 603
					tptr = tptr->nextterm;
				}
			}
#line 606
			sptr = tptr->nextterm;
#line 607
			tptr->nextterm = sptr->nextterm;
#line 608
			safe_free(sptr);
		}
#line 610
		return;
	}
}
#line 614 "findfeeds.c"
void fixwolf(int nfeed)
{
	CBOXPTR *newarray;
	CBOXPTR ptr;
	int i;
	int j;
	int n;
	char *tmp;
	char *tmp___0;
	char *tmp___1;
	char *tmp___2;
	char *tmp___3;
	char *tmp___4;
	char *tmp___5;
	char *tmp___6;
	char *tmp___7;
	char *tmp___8;

	{
#line 620
		n = numcells;
#line 621
		tmp = safe_malloc((unsigned int)((((1 + numcells) + numterms) + 2 * numblock) + nfeed) * sizeof(CBOXPTR));
#line 621
		newarray = (CBOXPTR *)tmp;
#line 624
		tmp___0 = safe_realloc((char *)tearray, (unsigned int)((2 * (((nfeed + impcount) + numblock) + 1) + maxterm) + 1) * sizeof(NBOXPTR));
#line 624
		tearray = (NBOXPTR *)tmp___0;
#line 626
		tmp___1 = safe_realloc((char *)pinnames, (unsigned int)((1 + maxterm) + 2 * (nfeed + impcount)) * sizeof(char *));
#line 626
		pinnames = (char **)tmp___1;
#line 628
		i = 1;
#line 628
		while (i <= n) {
#line 629
			* (newarray + i) = *(carray + i);
#line 628
			i++;
		}
#line 631
		j = n + 1;
#line 631
		while (j <= n + nfeed) {
#line 632
			tmp___2 = safe_malloc(sizeof(CBOX));
#line 632
			ptr = (struct cellbox *)tmp___2;
#line 632
			* (newarray + j) = ptr;
#line 633
			ptr->corient = (char)0;
#line 634
			ptr->cclass = 0;
#line 635
			if (gate_array_special) {
#line 636
				ptr->orflag = (char)1;
			}
			else {
#line 638
				ptr->orflag = (char)0;
			}
#line 640
			ptr->numterms = 2;
#line 641
			tmp___3 = safe_malloc(sizeof(TIBOX));
#line 641
			ptr->tileptr = (struct tilebox *)tmp___3;
#line 642
			tmp___4 = safe_malloc(sizeof(TEBOX));
#line 642
			(ptr->tileptr)->termsptr = (struct termbox *)tmp___4;
#line 643
			maxterm++;
#line 643
			((ptr->tileptr)->termsptr)->cellterm = maxterm;
#line 644
			tmp___5 = safe_malloc(16U * sizeof(char));
#line 644
			* (pinnames + maxterm) = tmp___5;
#line 645
			sprintf(*(pinnames + maxterm), "twfeed%d", maxterm);
#line 646
			((ptr->tileptr)->termsptr)->ei = maxterm;
#line 647
			((ptr->tileptr)->termsptr)->ue = 0;
#line 649
			tmp___6 = safe_malloc(sizeof(TEBOX));
#line 649
			((ptr->tileptr)->termsptr)->nextterm = (struct termbox *)tmp___6;
#line 651
			(((ptr->tileptr)->termsptr)->nextterm)->nextterm = (struct termbox *)((void *)0);
#line 652
			(((ptr->tileptr)->termsptr)->nextterm)->ei = maxterm;
#line 653
			(((ptr->tileptr)->termsptr)->nextterm)->ue = 0;
#line 654
			maxterm++;
#line 654
			(((ptr->tileptr)->termsptr)->nextterm)->cellterm = maxterm;
#line 655
			tmp___7 = safe_malloc(16U * sizeof(char));
#line 655
			* (pinnames + maxterm) = tmp___7;
#line 656
			sprintf(*(pinnames + maxterm), "twfeed%d", maxterm);
#line 631
			j++;
		}
#line 658
		while (i <= numcells + numterms) {
#line 659
			* (newarray + j) = *(carray + i);
#line 658
			i++;
#line 658
			j++;
		}
#line 661
		safe_free(carray);
#line 662
		tmp___8 = safe_realloc((char *)newarray, (unsigned int)((((1 + numcells) + numterms) + 2 * numblock) + nfeed) * sizeof(CBOXPTR));
#line 662
		carray = (CBOXPTR *)tmp___8;
#line 664
		return;
	}
}
#line 676
int rowToBlk(int row___0, int pos);
#line 668 "findfeeds.c"
int addfeed(int row___0, int pos, int feednum, int net)
{
	CBOXPTR cellptr___0;
	TIBOXPTR tileptr;
	NBOXPTR nptr;
	TEBOXPTR termptr;
	int pin;
	int blk___0;
	int corient;
	char *tmp;
	struct netbox *tmp___0;
	char *tmp___1;
	struct netbox *tmp___2;
	char *tmp___3;

	{
#line 676
		blk___0 = rowToBlk(row___0, pos);
#line 677
		cellptr___0 = *(carray + (numcells + feednum));
#line 678
		cellptr___0->padside = 0;
#line 679
		cellptr___0->cxcenter = pos;
#line 680
		cellptr___0->cycenter = (*(barray + blk___0))->bycenter;
#line 681
		cellptr___0->cheight = (*(barray + blk___0))->bheight;
#line 682
		cellptr___0->clength = fdWidth;
#line 683
		if ((*(barray + blk___0))->borient == 2) {
#line 684
			cellptr___0->corient = (char)1;
		}
#line 686
		tileptr = cellptr___0->tileptr;
#line 687
		tmp = safe_malloc(16U * sizeof(char));
#line 687
		cellptr___0->cname = tmp;
#line 688
		if (gate_array_special) {
#line 689
			sprintf(cellptr___0->cname, "twfeed");
		}
		else {
#line 692
			sprintf(cellptr___0->cname, "twfeed%d", feednum);
		}
#line 695
		cellptr___0->cblock = blk___0;
#line 696
		tileptr->left = -fdWidth / 2;
#line 697
		tileptr->right = fdWidth + tileptr->left;
#line 698
		tileptr->bottom = -(*(barray + blk___0))->bheight / 2;
#line 699
		tileptr->top = (*(barray + blk___0))->bheight + tileptr->bottom;
#line 700
		termptr = tileptr->termsptr;
#line 701
		termptr->txpos[0] = 0;
#line 702
		termptr->txpos[1] = 0;
#line 703
		corient = (int)cellptr___0->corient;
#line 704
		if (corient == 0) {
#line 705
			termptr->typos[0] = tileptr->top;
#line 706
			termptr->typos[1] = tileptr->bottom;
		}
		else {
#line 708
			termptr->typos[0] = tileptr->bottom;
#line 709
			termptr->typos[1] = tileptr->top;
		}
#line 711
		termptr = termptr->nextterm;
#line 712
		termptr->txpos[0] = 0;
#line 713
		termptr->txpos[1] = 0;
#line 714
		if (corient == 0) {
#line 715
			termptr->typos[0] = tileptr->bottom;
#line 716
			termptr->typos[1] = tileptr->top;
		}
		else {
#line 718
			termptr->typos[0] = tileptr->top;
#line 719
			termptr->typos[1] = tileptr->bottom;
		}
#line 722
		pin = (tileptr->termsptr)->cellterm;
#line 723
		nptr = (*(netarray + net))->netptr;
#line 724
		if ((unsigned int)nptr == (unsigned int)((void *)0)) {
#line 725
			fprintf(fpo, "no pins in net to be ");
#line 726
			fprintf(fpo, "connected to feed thru\n");
#line 727
			exit(1);
		}
#line 729
		while ((unsigned int)nptr->nterm != (unsigned int)((void *)0)) {
#line 729
			nptr = nptr->nterm;
		}
#line 730
		tmp___1 = safe_malloc(sizeof(NBOX));
#line 730
		tmp___0 = (struct netbox *)tmp___1;
#line 730
		nptr->nterm = tmp___0;
#line 730
		nptr = tmp___0;
#line 731
		* (tearray + pin) = nptr;
#line 732
		nptr->terminal = pin;
#line 733
		nptr->flag = (char)0;
#line 734
		nptr->row = row___0;
#line 735
		nptr->cell = numcells + feednum;
#line 736
		nptr->net = net;
#line 737
		nptr->extint = (tileptr->termsptr)->ei;
#line 738
		nptr->unequiv = (char)(tileptr->termsptr)->ue;
#line 739
		nptr->layer = (char)feedLayer;
#line 740
		nptr->pinloc = (char)1;
#line 744
		pin = ((tileptr->termsptr)->nextterm)->cellterm;
#line 745
		tmp___3 = safe_malloc(sizeof(NBOX));
#line 745
		tmp___2 = (struct netbox *)tmp___3;
#line 745
		nptr->nterm = tmp___2;
#line 745
		nptr = tmp___2;
#line 746
		* (tearray + pin) = nptr;
#line 747
		nptr->nterm = (struct netbox *)((void *)0);
#line 748
		nptr->terminal = pin;
#line 749
		nptr->flag = (char)0;
#line 750
		nptr->row = row___0;
#line 751
		nptr->cell = numcells + feednum;
#line 752
		nptr->net = net;
#line 753
		nptr->extint = ((tileptr->termsptr)->nextterm)->ei;
#line 754
		nptr->unequiv = (char)((tileptr->termsptr)->nextterm)->ue;
#line 755
		nptr->layer = (char)feedLayer;
#line 756
		nptr->pinloc = (char)-1;
#line 758
		return;
	}
}
#line 761 "findfeeds.c"
int rowToBlk(int row___0, int pos)
{
	int y;
	int block___0;
	int block1;
	int block2;
	int startx1;
	int endx1;
	int startx2;
	int endx2;

	{
#line 767
		y = (rowArray + row___0)->ypos;
#line 768
		block1 = 0;
#line 769
		block2 = 0;
#line 770
		block___0 = 1;
#line 770
		while (block___0 <= numblock) {
#line 771
			if ((*(barray + block___0))->bycenter == y) {
#line 772
				block1 = block___0;
#line 773
				break;
			}
#line 770
			block___0++;
		}
#line 776
		block___0++;
#line 776
		while (block___0 <= numblock) {
#line 777
			if ((*(barray + block___0))->bycenter == y) {
#line 778
				block2 = block___0;
#line 779
				break;
			}
#line 776
			block___0++;
		}
#line 782
		if (block1 == 0) {
#line 783
			fprintf(fpo, "rowToBlk failed to find block corresponding\n");
#line 784
			fprintf(fpo, "to row:%d\n", row___0);
#line 785
			exit(1);
		}
#line 787
		if (block2 == 0) {
#line 788
			block___0 = block1;
		}
		else {
#line 790
			startx1 = (*(barray + block1))->bxcenter + (*(barray + block1))->bleft;
#line 791
			endx1 = (*(barray + block1))->bxcenter + (*(barray + block1))->bright;
#line 792
			startx2 = (*(barray + block2))->bxcenter + (*(barray + block2))->bleft;
#line 793
			endx2 = (*(barray + block2))->bxcenter + (*(barray + block2))->bright;
#line 794
			if (pos >= startx1) {
#line 794
				if (pos <= endx1) {
#line 795
					block___0 = block1;
				}
				else {
					goto _L___0;
				}
			}
			else {
			_L___0: /* CIL Label */
#line 796
				if (pos >= startx2) {
#line 796
					if (pos <= endx2) {
#line 797
						block___0 = block2;
					}
					else {
						goto _L;
					}
				}
				else {
				_L: /* CIL Label */
#line 800
					if (endx2 < startx1) {
#line 801
						if (pos - endx2 <= startx1 - pos) {
#line 802
							block___0 = block2;
						}
						else {
#line 804
							block___0 = block1;
						}
					}
					else {
#line 807
						if (pos - endx1 <= startx2 - pos) {
#line 808
							block___0 = block1;
						}
						else {
#line 810
							block___0 = block2;
						}
					}
				}
			}
		}
#line 815
		return (block___0);
	}
}
#line 818 "findfeeds.c"
int prepglob(int degree)
{
	TEBOXPTR pinptr;
	int cell___0;
	int corient;
	int tmp;

	{
#line 824
		if (degree == 0) {
#line 825
			cell___0 = 1;
#line 825
			while (cell___0 <= numcells + numterms) {
#line 826
				if (cell___0 <= numcells) {
#line 827
					pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 828
					corient = (int)(*(carray + cell___0))->corient;
#line 829
					while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 830
						(*(tearray + pinptr->cellterm))->extint = pinptr->ei;
#line 831
						(*(tearray + pinptr->cellterm))->unequiv = (char)pinptr->ue;
#line 832
						tmp = ABS(pinptr->typos[corient % 2]);
#line 832
						if (tmp > 1) {
#line 833
							if (pinptr->typos[corient % 2] > 0) {
#line 834
								(*(tearray + pinptr->cellterm))->pinloc = (char)1;
							}
							else {
#line 836
								(*(tearray + pinptr->cellterm))->pinloc = (char)-1;
							}
						}
						else {
#line 839
							(*(tearray + pinptr->cellterm))->pinloc = (char)0;
						}
#line 829
						pinptr = pinptr->nextterm;
					}
				}
				else {
#line 842
					if (cell___0 > numcells) {
#line 843
						pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 844
						while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 845
							(*(tearray + pinptr->cellterm))->cell = cell___0;
#line 846
							(*(tearray + pinptr->cellterm))->extint = pinptr->ei;
#line 847
							(*(tearray + pinptr->cellterm))->unequiv = (char)pinptr->ue;
#line 848
							(*(tearray + pinptr->cellterm))->pinloc = (char)0;
#line 844
							pinptr = pinptr->nextterm;
						}
					}
				}
#line 825
				cell___0++;
			}
		}
		else {
#line 853
			cell___0 = numcells + 1;
#line 853
			while (cell___0 <= numcells + numterms) {
#line 854
				pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 855
				while ((unsigned int)pinptr != (unsigned int)((void *)0)) {
#line 856
					(*(tearray + pinptr->cellterm))->cell = (cell___0 + ffeeds) + *(add_to_row + 0);
#line 855
					pinptr = pinptr->nextterm;
				}
#line 853
				cell___0++;
			}
		}
#line 861
		return;
	}
}
#line 864 "findfeeds.c"
int detfeed(int flag, int row___0, int net)
{
	CBOXPTR cellptr___0;
	NBOXPTR nptr;
	NBOXPTR nptr2;
	int pinup;
	int pindown;
	int extint;
	int pinloc;

	{
#line 881
		pinup = 0;
#line 882
		pindown = 0;
#line 883
		nptr = (*(netarray + net))->netptr;
#line 883
		while ((unsigned int)nptr != (unsigned int)((void *)0)) {
#line 884
			if (nptr->row != row___0) {
				goto __Cont;
			}
			else {
#line 884
				if ((int)nptr->unequiv == 1) {
					goto __Cont;
				}
			}
#line 887
			if (flag == 0) {
#line 887
				if (nptr->cell > numcells) {
					goto _L;
				}
				else {
					goto _L___0;
				}
			}
			else {
			_L___0: /* CIL Label */
#line 887
				if (flag == 1) {
#line 887
					if (nptr->cell > pad_line) {
					_L: /* CIL Label */
#line 889
						cellptr___0 = *(carray + nptr->cell);
#line 890
						if (cellptr___0->padside == 1) {
							goto __Cont;
						}
						else {
#line 890
							if (cellptr___0->padside == 9) {
								goto __Cont;
							}
							else {
#line 890
								if (cellptr___0->padside == 5) {
									goto __Cont;
								}
								else {
#line 890
									if (cellptr___0->padside == 7) {
										goto __Cont;
									}
									else {
#line 890
										if (cellptr___0->padside == 3) {
											goto __Cont;
										}
										else {
#line 890
											if (cellptr___0->padside == 10) {
												goto __Cont;
											}
											else {
#line 890
												if (cellptr___0->padside == 6) {
													goto __Cont;
												}
												else {
#line 890
													if (cellptr___0->padside == 8) {
														goto __Cont;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
#line 901
			extint = nptr->extint;
#line 902
			pinloc = (int)nptr->pinloc;
#line 903
			if (pinloc == 0) {
#line 904
				return (4);
			}
#line 906
			if (pinloc > 0) {
#line 907
				pinup = 1;
			}
			else {
#line 909
				pindown = 1;
			}
#line 911
			nptr2 = nptr->nterm;
#line 912
			while ((unsigned int)nptr2 != (unsigned int)((void *)0)) {
#line 913
				if (nptr2->row != row___0) {
					goto __Cont___0;
				}
				else {
#line 913
					if ((int)nptr2->unequiv == 1) {
						goto __Cont___0;
					}
				}
#line 916
				if (flag == 0) {
#line 916
					if (nptr2->cell > numcells) {
						goto _L___1;
					}
					else {
						goto _L___2;
					}
				}
				else {
				_L___2: /* CIL Label */
#line 916
					if (flag == 1) {
#line 916
						if (nptr2->cell > pad_line) {
						_L___1: /* CIL Label */
#line 918
							cellptr___0 = *(carray + nptr2->cell);
#line 919
							if (cellptr___0->padside == 1) {
								goto __Cont___0;
							}
							else {
#line 919
								if (cellptr___0->padside == 9) {
									goto __Cont___0;
								}
								else {
#line 919
									if (cellptr___0->padside == 5) {
										goto __Cont___0;
									}
									else {
#line 919
										if (cellptr___0->padside == 7) {
											goto __Cont___0;
										}
										else {
#line 919
											if (cellptr___0->padside == 3) {
												goto __Cont___0;
											}
											else {
#line 919
												if (cellptr___0->padside == 10) {
													goto __Cont___0;
												}
												else {
#line 919
													if (cellptr___0->padside == 6) {
														goto __Cont___0;
													}
													else {
#line 919
														if (cellptr___0->padside == 8) {
															goto __Cont___0;
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
#line 930
				if ((int)nptr2->pinloc == 0) {
#line 931
					return (4);
				}
#line 933
				if (nptr2->extint == extint) {
#line 934
					if ((int)nptr2->pinloc != pinloc) {
#line 935
						return (4);
					}
				}
				else {
#line 938
					if ((int)nptr2->pinloc > 0) {
#line 939
						pinup = 1;
					}
					else {
#line 941
						pindown = 1;
					}
				}
			__Cont___0: /* CIL Label */
#line 912
				nptr2 = nptr2->nterm;
			}
		__Cont: /* CIL Label */
#line 883
			nptr = nptr->nterm;
		}
#line 946
		if (pinup == 1) {
#line 946
			if (pindown == 0) {
#line 947
				return (1);
			}
			else {
				goto _L___4;
			}
		}
		else {
		_L___4: /* CIL Label */
#line 948
			if (pinup == 0) {
#line 948
				if (pindown == 1) {
#line 949
					return (2);
				}
				else {
					goto _L___3;
				}
			}
			else {
			_L___3: /* CIL Label */
#line 950
				if (pinup == 1) {
#line 950
					if (pindown == 1) {
#line 951
						return (3);
					}
					else {
#line 953
						return (0);
					}
				}
				else {
#line 953
					return (0);
				}
			}
		}
	}
}
#line 1 "findrchk.o"
#pragma merger(0,"./findrchk.i","")
#line 51 "groute.h"
SWITCHBOX *aNetSeg;
#line 61
int numSegs;
#line 63
int *maxTrack;
#line 63
int *nmaxTrack;
#line 130 "findrchk.c"
int reset_ntrack(void);
#line 137
int debug(int chan, CHANGRDPTR gdptr);
#line 4 "findrchk.c"
void findrchk(void)
{
	SEGBOXPTR segptr;
	CHANGRDPTR ptr1;
	CHANGRDPTR ptr2;
	CHANGRDPTR bptr;
	CHANGRDPTR fptr;
	CHANGRDPTR sptr;
	CHANGRDPTR eptr;
	CHANGRDPTR ptr;
	CHANGRDPTR gdptr;
	int chan;
	int segment;
	int pin1;
	int pin2;
	int x1;
	int x2;
	int net;
	int Flag;

	{
#line 13
		chan = 1;
#line 13
		while (chan <= numChans) {
#line 14
			gdptr = *(Begin + chan);
#line 14
			while ((unsigned int)gdptr != (unsigned int)((void *)0)) {
#line 16
				gdptr->ntracks = 0;
#line 17
				gdptr->nSegType = 0;
#line 14
				gdptr = (struct changrdbox *)gdptr->nnextgrd;
			}
#line 13
			chan++;
		}
#line 20
		segment = 1;
#line 20
		while (segment <= numSegs) {
#line 21
			if ((aNetSeg + segment)->key != 0) {
#line 22
				(aNetSeg + segment)->current = (aNetSeg + (aNetSeg + segment)->key)->current;
			}
#line 25
			if ((int)(aNetSeg + segment)->current == 0) {
#line 26
				segptr = (aNetSeg + segment)->top;
			}
			else {
#line 28
				segptr = (aNetSeg + segment)->bot;
			}
#line 30
			pin1 = segptr->pin1;
#line 31
			pin2 = segptr->pin2;
#line 32
			if (pin1 > maxterm) {
#line 32
				if (pin2 > maxterm) {
					goto __Cont;
				}
			}
#line 35
			ptr1 = segptr->pin1ptr;
#line 36
			ptr2 = segptr->pin2ptr;
#line 37
			x1 = (ptr1->netptr)->xpos;
#line 38
			x2 = (ptr2->netptr)->xpos;
#line 39
			if (x1 == x2) {
				goto __Cont;
			}
#line 42
			net = (aNetSeg + segment)->net;
#line 43
			if (ptr1->nSegType >= 0) {
#line 44
				Flag = 0;
#line 45
				bptr = ptr1;
#line 46
				while (1) {
#line 46
					if ((unsigned int)bptr->nprevgrd != (unsigned int)((void *)0)) {
#line 46
						if (!(((bptr->nprevgrd)->netptr)->xpos == x1)) {
#line 46
							break;
						}
					}
					else {
#line 46
						break;
					}
#line 48
					if (net == (*(tearray + ((bptr->nprevgrd)->netptr)->terminal))->net) {
#line 48
						if ((bptr->nprevgrd)->nSegType < 0) {
#line 50
							Flag = 1;
#line 51
							sptr = (struct changrdbox *)ptr1->nnextgrd;
#line 52
							while ((sptr->netptr)->xpos == x1) {
#line 53
								sptr = (struct changrdbox *)sptr->nnextgrd;
							}
#line 55
							break;
						}
						else {
#line 57
							bptr = (struct changrdbox *)bptr->nprevgrd;
						}
					}
					else {
#line 57
						bptr = (struct changrdbox *)bptr->nprevgrd;
					}
				}
#line 60
				if (!Flag) {
#line 61
					sptr = (struct changrdbox *)ptr1->nnextgrd;
#line 62
					while ((sptr->netptr)->xpos == x1) {
#line 63
						if (net == (*(tearray + (sptr->netptr)->terminal))->net) {
#line 63
							if (sptr->nSegType < 0) {
#line 65
								Flag = 1;
							}
						}
#line 67
						sptr = (struct changrdbox *)sptr->nnextgrd;
					}
				}
#line 70
				if (!Flag) {
#line 71
					sptr = bptr;
				}
			}
			else {
#line 74
				sptr = (struct changrdbox *)ptr1->nnextgrd;
#line 75
				while ((sptr->netptr)->xpos == x1) {
#line 76
					sptr = (struct changrdbox *)sptr->nnextgrd;
				}
			}
#line 80
			if (ptr2->nSegType <= 0) {
#line 81
				Flag = 0;
#line 82
				fptr = ptr2;
#line 83
				while (1) {
#line 83
					if ((unsigned int)fptr->nnextgrd != (unsigned int)((void *)0)) {
#line 83
						if (!(((fptr->nnextgrd)->netptr)->xpos == x2)) {
#line 83
							break;
						}
					}
					else {
#line 83
						break;
					}
#line 85
					if (net == (*(tearray + ((fptr->nnextgrd)->netptr)->terminal))->net) {
#line 85
						if ((fptr->nnextgrd)->nSegType > 0) {
#line 87
							Flag = 1;
#line 88
							eptr = (struct changrdbox *)ptr2->nprevgrd;
#line 89
							while ((eptr->netptr)->xpos == x2) {
#line 90
								eptr = (struct changrdbox *)eptr->nprevgrd;
							}
#line 92
							break;
						}
						else {
#line 94
							fptr = (struct changrdbox *)fptr->nnextgrd;
						}
					}
					else {
#line 94
						fptr = (struct changrdbox *)fptr->nnextgrd;
					}
				}
#line 97
				if (!Flag) {
#line 98
					eptr = (struct changrdbox *)ptr2->nprevgrd;
#line 99
					while ((eptr->netptr)->xpos == x2) {
#line 100
						if (net == (*(tearray + (eptr->netptr)->terminal))->net) {
#line 100
							if (eptr->nSegType > 0) {
#line 102
								Flag = 1;
							}
						}
#line 104
						eptr = (struct changrdbox *)eptr->nprevgrd;
					}
				}
#line 107
				if (!Flag) {
#line 108
					eptr = fptr;
				}
			}
			else {
#line 111
				eptr = (struct changrdbox *)ptr2->nprevgrd;
#line 112
				while ((eptr->netptr)->xpos == x2) {
#line 113
					eptr = (struct changrdbox *)eptr->nprevgrd;
				}
			}
#line 117
			eptr = (struct changrdbox *)eptr->nnextgrd;
#line 119
			ptr = sptr;
#line 119
			while ((unsigned int)ptr != (unsigned int)eptr) {
#line 120
				(ptr->ntracks)++;
#line 119
				ptr = (struct changrdbox *)ptr->nnextgrd;
			}
#line 122
			if (pin1 <= maxterm) {
#line 123
				(ptr1->nSegType)++;
			}
#line 125
			if (pin2 <= maxterm) {
#line 126
				(ptr2->nSegType)--;
			}
		__Cont: /* CIL Label */
#line 20
			segment++;
		}
#line 129
		if (uneven_cell_height) {
#line 130
			reset_ntrack();
		}
#line 133
		chan = 1;
#line 133
		while (chan <= numChans) {
#line 134
			gdptr = *(Begin + chan);
#line 134
			while ((unsigned int)gdptr != (unsigned int)((void *)0)) {
#line 136
				if (gdptr->tracks != gdptr->ntracks) {
#line 137
					debug(chan, gdptr);
#line 138
					return;
				}
#line 134
				gdptr = (struct changrdbox *)gdptr->nnextgrd;
			}
#line 133
			chan++;
		}
#line 142
		return;
	}
}
#line 144 "findrchk.c"
int debug(int chan, CHANGRDPTR gdptr)
{
	FILE *fpb;
	char filename[64];
	NBOXPTR netptr;
	int i;

	{
#line 152
		sprintf(filename, "%s.debug", cktName);
#line 153
		fpb = twopen((int)(filename), (int)"w", 1);
#line 155
		fprintf(fpb, " channel = %2d nmaxTrack = %2d maxTrack = %2d\n", chan, *(nmaxTrack + chan),
			*(maxTrack + chan));
#line 157
		fprintf(fpb, "SegType nSegType track ntrack  pin xpos newx cell  net\n");
#line 158
		i = 5;
#line 158
		while (i >= 0) {
#line 159
			if ((unsigned int)gdptr->prevgrd != (unsigned int)((void *)0)) {
#line 160
				gdptr = (struct changrdbox *)gdptr->prevgrd;
			}
#line 158
			i--;
		}
#line 163
		while (i <= 12) {
#line 164
			if ((unsigned int)gdptr != (unsigned int)((void *)0)) {
#line 165
				netptr = gdptr->netptr;
#line 166
				fprintf(fpb, "%7d %8d %5d %6d %4d %4d %4d %4d %4d\n", gdptr->SegType, gdptr->nSegType,
					gdptr->tracks, gdptr->ntracks, netptr->terminal, netptr->xpos, netptr->newx,
					netptr->cell, (*(tearray + netptr->terminal))->net);
#line 170
				gdptr = (struct changrdbox *)gdptr->nextgrd;
			}
#line 163
			i++;
		}
#line 173
		return (0);
	}
}
#line 195
int facing_cellheight(int pin, int row___0, int pinloc, int status);
#line 175 "findrchk.c"
int reset_ntrack(void)
{
	CBOXPTR___0 cellptr___0;
	TIBOXPTR___0 tileptr;
	TEBOXPTR___0 termptr;
	int cell___0;
	int pin;
	int pinloc;
	int row___0;
	int top___0;
	int bottom;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;

	{
#line 183
		cell___0 = 1;
#line 183
		while (cell___0 <= numcells) {
#line 184
			cellptr___0 = (struct cellbox___0 *)*(carray + cell___0);
#line 185
			tileptr = cellptr___0->tileptr;
#line 186
			top___0 = tileptr->top;
#line 187
			bottom = -tileptr->bottom;
#line 188
			row___0 = cellptr___0->cblock;
#line 189
			termptr = tileptr->termsptr;
#line 189
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 192
				pin = termptr->cellterm;
#line 193
				pinloc = (int)(*(tearray + pin))->pinloc;
#line 194
				if (pinloc == 1) {
#line 195
					tmp = facing_cellheight(pin, row___0, 1, 1);
#line 195
					((*(Tgrid + pin))->up)->ntracks += (top___0 + tmp) / track_spacing;
				}
				else {
#line 197
					if (pinloc == -1) {
#line 198
						tmp___0 = facing_cellheight(pin, row___0, -1, 1);
#line 198
						((*(Tgrid + pin))->up)->ntracks += (bottom + tmp___0) / track_spacing;
					}
					else {
#line 201
						tmp___1 = facing_cellheight(pin, row___0, 1, 1);
#line 201
						((*(Tgrid + pin))->up)->ntracks += (top___0 + tmp___1) / track_spacing;
#line 203
						tmp___2 = facing_cellheight(pin, row___0, -1, 1);
#line 203
						((*(Tgrid + pin))->down)->ntracks += (bottom + tmp___2) / track_spacing;
					}
				}
#line 189
				termptr = (struct termbox___0 *)termptr->nextterm;
			}
#line 183
			cell___0++;
		}
#line 208
		while (cell___0 <= numcells + numterms) {
#line 209
			cellptr___0 = (struct cellbox___0 *)*(carray + cell___0);
#line 210
			tileptr = cellptr___0->tileptr;
#line 211
			termptr = tileptr->termsptr;
#line 211
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 213
				pin = termptr->cellterm;
#line 214
				row___0 = (*(tearray + pin))->row;
#line 215
				tmp___3 = facing_cellheight(pin, row___0, 0, 1);
#line 215
				((*(Tgrid + pin))->up)->ntracks += tmp___3 / track_spacing;
#line 211
				termptr = (struct termbox___0 *)termptr->nextterm;
			}
#line 208
			cell___0++;
		}
#line 219
		return (0);
	}
}
#line 1 "findrcost.o"
#pragma merger(0,"./findrcost.i","")
#line 53 "groute.h"
DENSITYPTR **Densebox;
#line 53
DENSITYPTR **DboxHead;
#line 62
int tracks;
#line 64
int max_tdensity;
#line 127 "findrcost.c"
int set_cedgebin(void);
#line 128
int reset_track(void);
#line 4 "findrcost.c"
void findrcost(void)
{
	SEGBOXPTR segptr;
	CHANGRDPTR ptr1;
	CHANGRDPTR ptr2;
	CHANGRDPTR bptr;
	CHANGRDPTR fptr;
	CHANGRDPTR sptr;
	CHANGRDPTR eptr;
	CHANGRDPTR ptr;
	CHANGRDPTR gdptr;
	DENSITYPTR denptr;
	int chan;
	int segment;
	int track;
	int max_trk;
	int pin1;
	int pin2;
	int x1;
	int x2;
	int net;
	int Flag;
	char *tmp;
	char *tmp___0;
	char *tmp___1;
	char *tmp___2;
	char *tmp___3;
	char *tmp___4;
	char *tmp___5;
	DENSITYPTR tmp___6;
	char *tmp___7;
	struct densitybox *tmp___8;
	char *tmp___9;

	{
#line 15
		segment = 1;
#line 15
		while (segment <= numSegs) {
#line 16
			if ((int)(aNetSeg + segment)->current == 0) {
#line 17
				segptr = (aNetSeg + segment)->top;
			}
			else {
#line 19
				segptr = (aNetSeg + segment)->bot;
			}
#line 21
			pin1 = segptr->pin1;
#line 22
			pin2 = segptr->pin2;
#line 23
			ptr1 = segptr->pin1ptr;
#line 24
			ptr2 = segptr->pin2ptr;
#line 25
			x1 = (ptr1->netptr)->xpos;
#line 26
			x2 = (ptr2->netptr)->xpos;
#line 27
			if (x1 == x2) {
				goto __Cont;
			}
#line 30
			net = (aNetSeg + segment)->net;
#line 31
			if (ptr1->SegType >= 0) {
#line 32
				Flag = 0;
#line 33
				bptr = ptr1;
#line 34
				while (1) {
#line 34
					if ((unsigned int)bptr->prevgrd != (unsigned int)((void *)0)) {
#line 34
						if (!(((bptr->prevgrd)->netptr)->xpos == x1)) {
#line 34
							break;
						}
					}
					else {
#line 34
						break;
					}
#line 36
					if (net == (*(tearray + ((bptr->prevgrd)->netptr)->terminal))->net) {
#line 36
						if ((bptr->prevgrd)->SegType < 0) {
#line 38
							Flag = 1;
#line 39
							sptr = (struct changrdbox *)ptr1->nextgrd;
#line 40
							while ((sptr->netptr)->xpos == x1) {
#line 41
								sptr = (struct changrdbox *)sptr->nextgrd;
							}
#line 43
							break;
						}
						else {
#line 45
							bptr = (struct changrdbox *)bptr->prevgrd;
						}
					}
					else {
#line 45
						bptr = (struct changrdbox *)bptr->prevgrd;
					}
				}
#line 48
				if (!Flag) {
#line 49
					sptr = (struct changrdbox *)ptr1->nextgrd;
#line 50
					while ((sptr->netptr)->xpos == x1) {
#line 51
						if (net == (*(tearray + (sptr->netptr)->terminal))->net) {
#line 51
							if (sptr->SegType < 0) {
#line 53
								Flag = 1;
							}
						}
#line 55
						sptr = (struct changrdbox *)sptr->nextgrd;
					}
				}
#line 58
				if (!Flag) {
#line 59
					sptr = bptr;
				}
			}
			else {
#line 62
				sptr = (struct changrdbox *)ptr1->nextgrd;
#line 63
				while ((sptr->netptr)->xpos == x1) {
#line 64
					sptr = (struct changrdbox *)sptr->nextgrd;
				}
			}
#line 68
			if (ptr2->SegType <= 0) {
#line 69
				Flag = 0;
#line 70
				fptr = ptr2;
#line 71
				while (1) {
#line 71
					if ((unsigned int)fptr->nextgrd != (unsigned int)((void *)0)) {
#line 71
						if (!(((fptr->nextgrd)->netptr)->xpos == x2)) {
#line 71
							break;
						}
					}
					else {
#line 71
						break;
					}
#line 73
					if (net == (*(tearray + ((fptr->nextgrd)->netptr)->terminal))->net) {
#line 73
						if ((fptr->nextgrd)->SegType > 0) {
#line 75
							Flag = 1;
#line 76
							eptr = (struct changrdbox *)ptr2->prevgrd;
#line 77
							while ((eptr->netptr)->xpos == x2) {
#line 78
								eptr = (struct changrdbox *)eptr->prevgrd;
							}
#line 80
							break;
						}
						else {
#line 82
							fptr = (struct changrdbox *)fptr->nextgrd;
						}
					}
					else {
#line 82
						fptr = (struct changrdbox *)fptr->nextgrd;
					}
				}
#line 85
				if (!Flag) {
#line 86
					eptr = (struct changrdbox *)ptr2->prevgrd;
#line 87
					while ((eptr->netptr)->xpos == x2) {
#line 88
						if (net == (*(tearray + (eptr->netptr)->terminal))->net) {
#line 88
							if (eptr->SegType > 0) {
#line 90
								Flag = 1;
							}
						}
#line 92
						eptr = (struct changrdbox *)eptr->prevgrd;
					}
				}
#line 95
				if (!Flag) {
#line 96
					eptr = fptr;
				}
			}
			else {
#line 99
				eptr = (struct changrdbox *)ptr2->prevgrd;
#line 100
				while ((eptr->netptr)->xpos == x2) {
#line 101
					eptr = (struct changrdbox *)eptr->prevgrd;
				}
			}
#line 105
			eptr = (struct changrdbox *)eptr->nextgrd;
#line 107
			ptr = sptr;
#line 107
			while ((unsigned int)ptr != (unsigned int)eptr) {
#line 108
				(ptr->tracks)++;
#line 107
				ptr = (struct changrdbox *)ptr->nextgrd;
			}
#line 110
			if (pin1 <= maxterm) {
#line 111
				(ptr1->SegType)++;
			}
#line 113
			if (pin2 <= maxterm) {
#line 114
				(ptr2->SegType)--;
			}
		__Cont: /* CIL Label */
#line 15
			segment++;
		}
#line 118
		tmp = safe_calloc(sizeof(DENSITYPTR *), (unsigned int)(numChans + 1));
#line 118
		DboxHead = (DENSITYPTR **)tmp;
#line 120
		tmp___0 = safe_calloc(sizeof(DENSITYPTR *), (unsigned int)(numChans + 1));
#line 120
		Densebox = (DENSITYPTR **)tmp___0;
#line 122
		tmp___1 = safe_malloc((unsigned int)(numChans + 1) * sizeof(int));
#line 122
		maxTrack = (int *)tmp___1;
#line 123
		tmp___2 = safe_malloc((unsigned int)(numChans + 1) * sizeof(int));
#line 123
		nmaxTrack = (int *)tmp___2;
#line 124
		max_tdensity = 0;
#line 125
		tracks = 0;
#line 126
		if (uneven_cell_height) {
#line 127
			set_cedgebin();
#line 128
			reset_track();
		}
#line 130
		chan = 1;
#line 130
		while (chan <= numChans) {
#line 131
			max_trk = 0;
#line 132
			gdptr = *(Begin + chan);
#line 132
			while ((unsigned int)gdptr != (unsigned int)((void *)0)) {
#line 134
				if (gdptr->tracks > max_trk) {
#line 135
					max_trk = gdptr->tracks;
				}
#line 132
				gdptr = (struct changrdbox *)gdptr->nextgrd;
			}
#line 138
			* (maxTrack + chan) = max_trk;
#line 139
			if (max_trk > max_tdensity) {
#line 140
				max_tdensity = max_trk;
			}
#line 142
			tracks += max_trk;
#line 130
			chan++;
		}
#line 144
		chan = 1;
#line 144
		while (chan <= numChans) {
#line 145
			tmp___3 = safe_calloc(sizeof(DENSITYPTR), (unsigned int)(max_tdensity + 101));
#line 145
			* (DboxHead + chan) = (DENSITYPTR *)tmp___3;
#line 147
			tmp___4 = safe_calloc(sizeof(DENSITYPTR), (unsigned int)(max_tdensity + 101));
#line 147
			* (Densebox + chan) = (DENSITYPTR *)tmp___4;
#line 149
			track = 0;
#line 149
			while (track <= max_tdensity + 100) {
#line 150
				tmp___5 = safe_calloc(sizeof(DENSITYBOX), 1U);
#line 150
				* (*(DboxHead + chan) + track) = (struct densitybox *)tmp___5;
#line 149
				track++;
			}
#line 153
			gdptr = *(Begin + chan);
#line 153
			while ((unsigned int)gdptr != (unsigned int)((void *)0)) {
#line 155
				track = gdptr->tracks;
#line 156
				if ((unsigned int)(*(*(DboxHead + chan) + track))->next == (unsigned int)((void *)0)) {
#line 157
					tmp___7 = safe_calloc(sizeof(DENSITYBOX), 1U);
#line 157
					tmp___6 = (struct densitybox *)tmp___7;
#line 157
					* (*(Densebox + chan) + track) = tmp___6;
#line 157
					(*(*(DboxHead + chan) + track))->next = tmp___6;
#line 159
					(*(*(Densebox + chan) + track))->back = *(*(DboxHead + chan) + track);
#line 160
					(*(*(Densebox + chan) + track))->grdptr = gdptr;
#line 161
					gdptr->dptr = *(*(Densebox + chan) + track);
				}
				else {
#line 163
					tmp___9 = safe_calloc(sizeof(DENSITYBOX), 1U);
#line 163
					tmp___8 = (struct densitybox *)tmp___9;
#line 163
					(*(*(Densebox + chan) + track))->next = tmp___8;
#line 163
					denptr = tmp___8;
#line 165
					denptr->back = *(*(Densebox + chan) + track);
#line 166
					denptr->grdptr = gdptr;
#line 167
					gdptr->dptr = denptr;
#line 168
					* (*(Densebox + chan) + track) = denptr;
				}
#line 153
				gdptr = (struct changrdbox *)gdptr->nextgrd;
			}
#line 144
			chan++;
		}
#line 172
		return;
	}
}
#line 178 "findrcost.c"
int set_cedgebin(void)
{
	CBOXPTR___0 cellptr___0;
	int channel;
	int row___0;
	int bin;
	int bin_rite_edge;
	int crite;
	int most_left;
	int most_rite;
	int rite___0;
	int i;
	char *tmp;
	char *tmp___0;

	{
#line 185
		tmp = safe_malloc((unsigned int)(numChans + 1) * sizeof(int *));
#line 185
		cedgebin = (int **)tmp;
#line 186
		cedge_binwidth = (int)(2.0 * (double)mean_width);
#line 187
		cellptr___0 = (struct cellbox___0 *)*(carray + *(*(pairArray + 1) + *(*(pairArray + 1) + 0)));
#line 188
		most_rite = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
#line 189
		row___0 = 2;
#line 189
		while (row___0 <= numRows) {
#line 190
			cellptr___0 = (struct cellbox___0 *)*(carray + *(*(pairArray + row___0) + *(*(pairArray + row___0) + 0)));
#line 191
			rite___0 = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
#line 192
			if (rite___0 > most_rite) {
#line 193
				most_rite = rite___0;
			}
#line 189
			row___0++;
		}
#line 196
		num_edgebin = (most_rite - blkleft) / cedge_binwidth + 1;
#line 197
		channel = 1;
#line 197
		while (channel <= numChans) {
#line 198
			tmp___0 = safe_malloc((unsigned int)(num_edgebin + 1) * sizeof(int));
#line 198
			* (cedgebin + channel) = (int *)tmp___0;
#line 197
			channel++;
		}
#line 203
		row___0 = 1;
#line 203
		while (row___0 <= numRows) {
#line 204
			cellptr___0 = (struct cellbox___0 *)*(carray + *(*(pairArray + row___0) + 1));
#line 205
			most_left = cellptr___0->cxcenter + (cellptr___0->tileptr)->left;
#line 206
			bin_rite_edge = most_left + cedge_binwidth;
#line 207
			* (*(cedgebin + row___0) + 1) = 1;
#line 208
			bin = 1;
#line 209
			i = 1;
#line 209
			while (i <= *(*(pairArray + row___0) + 0)) {
#line 210
				cellptr___0 = (struct cellbox___0 *)*(carray + *(*(pairArray + row___0) + i));
#line 211
				crite = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
#line 212
				if (bin_rite_edge < crite) {
#line 213
					while (bin_rite_edge <= crite) {
#line 214
						bin++;
#line 214
						* (*(cedgebin + row___0) + bin) = i;
#line 215
						bin_rite_edge += cedge_binwidth;
					}
				}
#line 209
				i++;
			}
#line 219
			bin++;
#line 219
			while (bin <= num_edgebin) {
#line 220
				* (*(cedgebin + row___0) + bin) = 0;
#line 219
				bin++;
			}
#line 203
			row___0++;
		}
#line 223
		return (0);
	}
}
#line 226 "findrcost.c"
int reset_track(void)
{
	CBOXPTR___0 cellptr___0;
	TIBOXPTR___0 tileptr;
	TEBOXPTR___0 termptr;
	int cell___0;
	int pin;
	int pinloc;
	int row___0;
	int top___0;
	int bottom;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;

	{
#line 234
		cell___0 = 1;
#line 234
		while (cell___0 <= numcells) {
#line 235
			cellptr___0 = (struct cellbox___0 *)*(carray + cell___0);
#line 236
			tileptr = cellptr___0->tileptr;
#line 237
			row___0 = cellptr___0->cblock;
#line 238
			top___0 = tileptr->top;
#line 239
			bottom = -tileptr->bottom;
#line 240
			termptr = tileptr->termsptr;
#line 240
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 243
				pin = termptr->cellterm;
#line 244
				pinloc = (int)(*(tearray + pin))->pinloc;
#line 245
				if (pinloc == 1) {
#line 246
					tmp = facing_cellheight(pin, row___0, 1, 1);
#line 246
					((*(Tgrid + pin))->up)->tracks += (top___0 + tmp) / track_spacing;
				}
				else {
#line 248
					if (pinloc == -1) {
#line 249
						tmp___0 = facing_cellheight(pin, row___0, -1, 1);
#line 249
						((*(Tgrid + pin))->up)->tracks += (bottom + tmp___0) / track_spacing;
					}
					else {
#line 252
						tmp___1 = facing_cellheight(pin, row___0, 1, 1);
#line 252
						((*(Tgrid + pin))->up)->tracks += (top___0 + tmp___1) / track_spacing;
#line 254
						tmp___2 = facing_cellheight(pin, row___0, -1, 1);
#line 254
						((*(Tgrid + pin))->down)->tracks += (bottom + tmp___2) / track_spacing;
					}
				}
#line 240
				termptr = (struct termbox___0 *)termptr->nextterm;
			}
#line 234
			cell___0++;
		}
#line 259
		while (cell___0 <= numcells + numterms) {
#line 260
			cellptr___0 = (struct cellbox___0 *)*(carray + cell___0);
#line 261
			tileptr = cellptr___0->tileptr;
#line 262
			termptr = tileptr->termsptr;
#line 262
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 264
				pin = termptr->cellterm;
#line 265
				row___0 = (*(tearray + pin))->row;
#line 266
				tmp___3 = facing_cellheight(pin, row___0, 0, 1);
#line 266
				((*(Tgrid + pin))->up)->tracks += tmp___3 / track_spacing;
#line 262
				termptr = (struct termbox___0 *)termptr->nextterm;
			}
#line 259
			cell___0++;
		}
#line 270
		return (0);
	}
}
#line 273 "findrcost.c"
int facing_cellheight(int pin, int row___0, int pinloc, int status)
{
	CBOXPTR___0 cellptr___0;
	int bin;
	int i;
	int *Aray;
	int most_left;
	int most_rite;
	int nrow;
	int pin_x;
	int crite;

	{
#line 280
		if (1 <= row___0) {
#line 280
			if (row___0 <= numRows) {
#line 281
				nrow = row___0 + pinloc;
#line 282
				if (nrow == 0) {
#line 283
					return (0);
				}
				else {
#line 282
					if (nrow == numChans) {
#line 283
						return (0);
					}
					else {
#line 282
						if (pinloc == 0) {
#line 283
							return (0);
						}
					}
				}
			}
			else {
				goto _L;
			}
		}
		else {
		_L: /* CIL Label */
#line 285
			if (row___0 == 0) {
#line 286
				nrow = 1;
			}
			else {
#line 288
				nrow = numRows;
			}
		}
#line 291
		Aray = *(pairArray + nrow);
#line 292
		if (status == 0) {
#line 293
			pin_x = (*(tearray + pin))->newx;
		}
		else {
#line 295
			pin_x = (*(tearray + pin))->xpos;
		}
#line 297
		cellptr___0 = (struct cellbox___0 *)*(carray + *(Aray + 1));
#line 298
		most_left = cellptr___0->cxcenter + (cellptr___0->tileptr)->left;
#line 299
		cellptr___0 = (struct cellbox___0 *)*(carray + *(Aray + *(Aray + 0)));
#line 300
		most_rite = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
#line 301
		if (pin_x < most_left) {
#line 302
			return (0);
		}
		else {
#line 301
			if (pin_x > most_rite) {
#line 302
				return (0);
			}
		}
#line 304
		bin = (pin_x - most_left) / cedge_binwidth + 1;
#line 305
		i = *(*(cedgebin + nrow) + bin);
#line 305
		if (i == 0) {
#line 306
			return (0);
		}
#line 308
		cellptr___0 = (struct cellbox___0 *)*(carray + *(Aray + i));
#line 309
		if ((cellptr___0->tileptr)->left + cellptr___0->cxcenter == pin_x) {
#line 309
			if (bin >= 2) {
#line 311
				if ((*(carray + *(Aray + (i - 1))))->cheight > cellptr___0->cheight) {
#line 312
					i--;
#line 312
					cellptr___0 = (struct cellbox___0 *)*(carray + *(Aray + i));
				}
			}
			else {
				goto _L___0;
			}
		}
		else {
		_L___0: /* CIL Label */
#line 315
			crite = (cellptr___0->tileptr)->right + cellptr___0->cxcenter;
#line 316
			while (1) {
#line 316
				if (crite < pin_x) {
#line 316
					if (!(i < *(Aray + 0))) {
#line 316
						break;
					}
				}
				else {
#line 316
					break;
				}
#line 317
				i++;
#line 317
				cellptr___0 = (struct cellbox___0 *)*(carray + *(Aray + i));
#line 318
				crite += cellptr___0->clength;
			}
#line 320
			if (crite == pin_x) {
#line 320
				if (i != *(Aray + 0)) {
#line 321
					if ((*(carray + *(Aray + (i + 1))))->cheight > cellptr___0->cheight) {
#line 322
						cellptr___0 = (struct cellbox___0 *)*(carray + *(Aray + (i + 1)));
					}
				}
			}
		}
#line 327
		if (1 <= row___0) {
#line 327
			if (row___0 <= numRows) {
#line 328
				if (pinloc == 1) {
#line 329
					return (-(cellptr___0->tileptr)->bottom);
				}
				else {
#line 331
					return ((cellptr___0->tileptr)->top);
				}
			}
			else {
				goto _L___1;
			}
		}
		else {
		_L___1: /* CIL Label */
#line 333
			if (row___0 == 0) {
#line 334
				return (-(cellptr___0->tileptr)->bottom);
			}
			else {
#line 336
				return ((cellptr___0->tileptr)->top);
			}
		}
	}
}
#line 1 "findunlap.o"
#pragma merger(0,"./findunlap.i","")
#line 2 "findunlap.c"
int *add_to_row;
#line 3 "findunlap.c"
int *length_of_row;
#line 25
void unlap(int flag);
#line 5 "findunlap.c"
void findunlap(int before_feeds)
{
	CBOXPTR cellptr___0;
	CBOXPTR ptr;
	TIBOXPTR tileptr;
	TEBOXPTR term;
	DBOXPTR dimptr;
	NBOXPTR termptr;
	NBOXPTR netptr;
	int cost;
	int corient;
	int block___0;
	int cell___0;
	int bin;
	int i;
	int n;
	int bigblkx;
	int net;
	int x;
	int y;
	int *blklen;
	int row___0;
	char *tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	char *tmp___4;
	char *tmp___5;

	{
#line 19
		tmp = safe_malloc((unsigned int)(numblock + 1) * sizeof(int));
#line 19
		blklen = (int *)tmp;
#line 20
		i = 0;
#line 20
		while (i <= numblock) {
#line 21
			* (blklen + i) = 0;
#line 20
			i++;
		}
#line 24
		if (before_feeds == 1) {
#line 25
			unlap(1);
		}
		else {
#line 26
			if (before_feeds == 0) {
#line 27
				unlap(0);
			}
		}
#line 30
		if (before_feeds == 1) {
#line 31
			block___0 = 1;
#line 31
			while (block___0 <= numblock) {
#line 32
				bin = 0;
#line 32
				while (bin <= numBins) {
#line 33
					safe_free((*(*(binptr + block___0) + bin))->cell);
#line 34
					safe_free(*(*(binptr + block___0) + bin));
#line 32
					bin++;
				}
#line 36
				safe_free(*(binptr + block___0));
#line 31
				block___0++;
			}
#line 38
			safe_free(binptr);
		}
#line 41
		cell___0 = 1;
#line 41
		while (cell___0 <= numcells) {
#line 42
			ptr = *(carray + cell___0);
#line 43
			corient = (int)ptr->corient;
#line 44
			term = (ptr->tileptr)->termsptr;
#line 44
			while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 46
				termptr = *(tearray + term->cellterm);
#line 47
				termptr->xpos = term->txpos[corient / 2] + ptr->cxcenter;
#line 48
				termptr->ypos = term->typos[corient % 2] + ptr->cycenter;
#line 44
				term = term->nextterm;
			}
#line 41
			cell___0++;
		}
#line 51
		cell___0 = numcells + 1;
#line 51
		while (cell___0 <= numcells + numterms) {
#line 52
			ptr = *(carray + cell___0);
#line 53
			term = (ptr->tileptr)->termsptr;
#line 53
			while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 55
				termptr = *(tearray + term->cellterm);
#line 56
				termptr->xpos = term->txpos[1] + ptr->cxcenter;
#line 57
				termptr->ypos = term->typos[1] + ptr->cycenter;
#line 53
				term = term->nextterm;
			}
#line 51
			cell___0++;
		}
#line 61
		cost = 0;
#line 62
		net = 1;
#line 62
		while (net <= numnets) {
#line 63
			dimptr = *(netarray + net);
#line 64
			netptr = dimptr->netptr;
#line 64
			if ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 65
				tmp___0 = netptr->xpos;
#line 65
				dimptr->xmax = tmp___0;
#line 65
				dimptr->xmin = tmp___0;
#line 66
				tmp___1 = netptr->ypos;
#line 66
				dimptr->ymax = tmp___1;
#line 66
				dimptr->ymin = tmp___1;
#line 67
				tmp___2 = 1;
#line 67
				dimptr->Rnum = tmp___2;
#line 67
				dimptr->Lnum = tmp___2;
#line 68
				tmp___3 = 1;
#line 68
				dimptr->Tnum = tmp___3;
#line 68
				dimptr->Bnum = tmp___3;
#line 69
				netptr = netptr->nterm;
			}
#line 71
			n = 1;
#line 72
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 73
				x = netptr->xpos;
#line 74
				y = netptr->ypos;
#line 75
				if (x < dimptr->xmin) {
#line 76
					dimptr->xmin = x;
#line 77
					dimptr->Lnum = 1;
				}
				else {
#line 78
					if (x == dimptr->xmin) {
#line 79
						(dimptr->Lnum)++;
#line 80
						if (x == dimptr->xmax) {
#line 81
							(dimptr->Rnum)++;
						}
					}
					else {
#line 83
						if (x > dimptr->xmax) {
#line 84
							dimptr->xmax = x;
#line 85
							dimptr->Rnum = 1;
						}
						else {
#line 86
							if (x == dimptr->xmax) {
#line 87
								(dimptr->Rnum)++;
							}
						}
					}
				}
#line 89
				if (y < dimptr->ymin) {
#line 90
					dimptr->ymin = y;
#line 91
					dimptr->Bnum = 1;
				}
				else {
#line 92
					if (y == dimptr->ymin) {
#line 93
						(dimptr->Bnum)++;
#line 94
						if (y == dimptr->ymax) {
#line 95
							(dimptr->Tnum)++;
						}
					}
					else {
#line 97
						if (y > dimptr->ymax) {
#line 98
							dimptr->ymax = y;
#line 99
							dimptr->Tnum = 1;
						}
						else {
#line 100
							if (y == dimptr->ymax) {
#line 101
								(dimptr->Tnum)++;
							}
						}
					}
				}
#line 103
				n++;
#line 72
				netptr = netptr->nterm;
			}
#line 105
			dimptr->numpins = n;
#line 106
			cost += (int)(dimptr->Hweight * (float)(dimptr->xmax - dimptr->xmin)) + (int)(dimptr->Vweight * (float)(dimptr->ymax - dimptr->ymin));
#line 62
			net++;
		}
#line 111
		funccost = cost;
#line 114
		cell___0 = 1;
#line 114
		while (cell___0 <= numcells) {
#line 115
			cellptr___0 = *(carray + cell___0);
#line 116
			tileptr = cellptr___0->tileptr;
#line 117
			block___0 = cellptr___0->cblock;
#line 118
			* (blklen + block___0) += tileptr->right - tileptr->left;
#line 114
			cell___0++;
		}
#line 121
		if (before_feeds == 1) {
#line 122
			tmp___4 = safe_malloc((unsigned int)(numRows + 1) * sizeof(int));
#line 122
			length_of_row = (int *)tmp___4;
#line 123
			tmp___5 = safe_malloc((unsigned int)(numRows + 1) * sizeof(int));
#line 123
			add_to_row = (int *)tmp___5;
#line 124
			row___0 = 1;
#line 124
			while (row___0 <= numRows) {
#line 125
				* (length_of_row + row___0) = *(blklen + row___0);
#line 126
				* (add_to_row + row___0) = 0;
#line 124
				row___0++;
			}
		}
#line 130
		if (before_feeds >= 0) {
#line 131
			bigblkx = 0;
#line 132
			if (before_feeds == 1) {
#line 133
				fprintf(fpo, "Before Feeds are Added:\n");
			}
#line 135
			fprintf(fpo, "BLOCK      TOTAL CELL LENGTHS      OVER/UNDER TARGET\n");
#line 136
			i = 1;
#line 136
			while (i <= numblock) {
#line 137
				if (*(blklen + i) > *(blklen + bigblkx)) {
#line 138
					bigblkx = i;
				}
#line 140
				fprintf(fpo, "%3d            %7d                %6d\n", i, *(blklen + i), *(blklen + i) - (*(barray + i))->desire);
#line 136
				i++;
			}
#line 143
			fprintf(fpo, "\nLONGEST Block is:%d   Its length is:%d\n", bigblkx, *(blklen + bigblkx));
		}
#line 146
		safe_free(blklen);
#line 147
		return;
	}
}
#line 1 "globe.o"
#pragma merger(0,"./globe.i","")
#line 172 "/usr/include/stdio.h"
extern int (__attribute__((__cdecl__)) fclose)(FILE *);
#line 48 "route.h"
csGroup *groupArray;
#line 49 "route.h"
chkBox *checkArray;
#line 50 "route.h"
int MPG;
#line 51 "route.h"
int ME;
#line 52 "route.h"
edgeBox *edgeArray;
#line 65 "groute.h"
int gxstart;
#line 65 "groute.h"
int gxstop;
#line 7 "globe.c"
int **pseudoPins;
#line 8 "globe.c"
int **pseudoEdge;
#line 17 "globe.c"
int *key_queue;
#line 18 "globe.c"
int numEdges;
#line 18 "globe.c"
int numGroups;
#line 18 "globe.c"
int numPins;
#line 19 "globe.c"
int top_row;
#line 22 "globe.c"
void twclose(int a___0)
{

	{
#line 24
		fclose((FILE *)a___0);
#line 25
		return;
	}
}
#line 26 "globe.c"
int ABS(int value)
{
	int tmp;

	{
#line 28
		if (value >= 0) {
#line 28
			tmp = value;
		}
		else {
#line 28
			tmp = -value;
		}
#line 28
		return (tmp);
	}
}
#line 251
void qsortg(char *base, int n, int size);
#line 261
int detGroup(int g);
#line 262
int searchG(int g, int type, int block___0);
#line 333
void qsorte(char *base, int n, int size);
#line 408
int addEdge(int g1, int g2);
#line 31 "globe.c"
void globe(void)
{
	FILE *twfile;
	NBOXPTR netptr;
	NBOXPTR net_ptr;
	CBOXPTR___0 cellptr1;
	CBOXPTR___0 cellptr2;
	char filename[64];
	int group1;
	int group2;
	int edge___0;
	int i;
	int pin;
	int net;
	int group;
	int jj;
	int cell___0;
	int cx;
	int cl;
	int cr;
	int top___0;
	int extint;
	int block___0;
	int locX;
	int locY;
	int flag1;
	int flag2;
	int xstart;
	int xstop;
	int found;
	int type1;
	int unequiv;
	int added_an_edge;
	int ue_grp;
	int g1;
	int g2;
	int ei1;
	int ei2;
	int edge2;
	int done;
	int ei;
	int cell1;
	int cell2;
	int a1;
	int b1;
	int a2;
	int b2;
	int edge1;
	int ya;
	int yb;
	int max_group;
	int max_size;
	int size;
	int max_local_group;
	int single_pin1;
	int single_pin2;
	int unequiv1;
	int unequiv2;
	char *tmp;
	char *tmp___0;
	char *tmp___1;
	char *tmp___2;
	char *tmp___3;
	char *tmp___4;
	char *tmp___5;
	char *tmp___6;
	char *tmp___7;

	{
#line 51
		max_group = 2;
#line 52
		max_size = 2;
#line 53
		net = 1;
#line 53
		while (net <= numnets) {
#line 54
			net_ptr = (struct netbox *)(*(netarray + net))->netptr;
#line 55
			max_local_group = 0;
#line 56
			size = 1;
#line 57
			extint = -1;
#line 58
			while ((unsigned int)net_ptr != (unsigned int)((void *)0)) {
#line 59
				if (net_ptr->extint != extint) {
#line 60
					extint = net_ptr->extint;
#line 61
					max_local_group++;
#line 62
					if (size > max_size) {
#line 63
						max_size = size;
					}
#line 65
					size = 1;
				}
				else {
#line 67
					size++;
#line 68
					if ((int)net_ptr->unequiv != 0) {
#line 69
						max_local_group++;
					}
				}
#line 58
				net_ptr = (struct netbox *)net_ptr->nterm;
			}
#line 73
			if (size > max_size) {
#line 74
				max_size = size;
			}
#line 76
			if (max_local_group > max_group) {
#line 77
				max_group = max_local_group;
			}
#line 53
			net++;
		}
#line 81
		max_group += 2 * (numRows + 2);
#line 82
		MPG = max_group;
#line 83
		ME = max_group * (max_group - 1);
#line 86
		tmp = safe_malloc(101U * sizeof(int));
#line 86
		key_queue = (int *)tmp;
#line 87
		tmp___0 = safe_malloc((unsigned int)(MPG + 1) * sizeof(csGroup));
#line 87
		groupArray = (csGroup *)tmp___0;
#line 88
		tmp___1 = safe_malloc((unsigned int)(MPG + 1) * sizeof(chkBox));
#line 88
		checkArray = (chkBox *)tmp___1;
#line 89
		tmp___2 = safe_malloc((unsigned int)(ME + 1) * sizeof(edgeBox));
#line 89
		edgeArray = (edgeBox *)tmp___2;
#line 92
		i = 0;
#line 92
		while (i <= MPG) {
#line 93
			(groupArray + i)->numPins = 0;
#line 94
			(groupArray + i)->flag = 0;
#line 95
			(groupArray + i)->poison = 0;
#line 96
			(groupArray + i)->unequiv = 0;
#line 97
			(groupArray + i)->extint = 0;
#line 98
			(groupArray + i)->edge1 = 0;
#line 99
			(groupArray + i)->edge2 = 0;
#line 100
			(groupArray + i)->check = 0;
#line 101
			tmp___3 = safe_malloc((unsigned int)(max_size + 1) * sizeof(csPinBox));
#line 101
			(groupArray + i)->pinArray = (csPinBox *)tmp___3;
#line 92
			i++;
		}
#line 104
		i = 0;
#line 104
		while (i <= ME) {
#line 105
			(edgeArray + i)->marked = 0;
#line 106
			(edgeArray + i)->done = 0;
#line 107
			(edgeArray + i)->poison = 0;
#line 104
			i++;
		}
#line 112
		tmp___4 = safe_malloc((unsigned int)(numRows + 2) * sizeof(int *));
#line 112
		pseudoPins = (int **)tmp___4;
#line 113
		jj = 0;
#line 113
		while (jj <= numRows + 1) {
#line 114
			tmp___5 = safe_malloc(2U * sizeof(int));
#line 114
			* (pseudoPins + jj) = (int *)tmp___5;
#line 113
			jj++;
		}
#line 116
		tmp___6 = safe_malloc((unsigned int)(numRows + 2) * sizeof(int *));
#line 116
		pseudoEdge = (int **)tmp___6;
#line 117
		jj = 0;
#line 117
		while (jj <= numRows + 1) {
#line 118
			tmp___7 = safe_malloc(2U * sizeof(int));
#line 118
			* (pseudoEdge + jj) = (int *)tmp___7;
#line 117
			jj++;
		}
#line 121
		numChans = numRows + 1;
#line 122
		xstart = 32000;
#line 123
		xstop = 0;
#line 124
		cell___0 = 1;
#line 124
		while (cell___0 <= numcells + numterms) {
#line 125
			cx = (*(carray + cell___0))->cxcenter;
#line 126
			cl = ((*(carray + cell___0))->tileptr)->left;
#line 127
			cr = ((*(carray + cell___0))->tileptr)->right;
#line 128
			if (cx + cr > xstop) {
#line 129
				xstop = cx + cr;
			}
#line 131
			if (cx + cl < xstart) {
#line 132
				xstart = cx + cl;
			}
#line 124
			cell___0++;
		}
#line 135
		gxstart = xstart;
#line 136
		gxstop = xstop;
#line 138
		sprintf(filename, "%s.twf", cktName);
#line 139
		twfile = twopen((int)(filename), (int)"w", 1);
#line 141
		net = 1;
#line 141
		while (net <= numnets) {
#line 143
			jj = 0;
#line 143
			while (jj <= numRows + 1) {
#line 144
				* (*(pseudoPins + jj) + 0) = 0;
#line 145
				* (*(pseudoPins + jj) + 1) = 0;
#line 146
				* (*(pseudoEdge + jj) + 0) = 0;
#line 147
				* (*(pseudoEdge + jj) + 1) = 0;
#line 143
				jj++;
			}
#line 150
			numEdges = 0;
#line 151
			top_row = -1;
#line 152
			netptr = (struct netbox *)(*(netarray + net))->netptr;
#line 153
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 154
				top___0 = (int)netptr->pinloc;
#line 155
				extint = netptr->extint;
#line 156
				unequiv = (int)netptr->unequiv;
#line 157
				block___0 = netptr->row;
#line 158
				if (block___0 > top_row) {
#line 159
					if (netptr->cell <= numcells) {
#line 160
						top_row = block___0;
					}
					else {
#line 161
						if ((*(carray + netptr->cell))->padside != 1) {
#line 161
							if ((*(carray + netptr->cell))->padside != 3) {
#line 163
								top_row = block___0;
							}
						}
					}
				}
#line 166
				locX = netptr->xpos;
#line 167
				locY = netptr->ypos;
#line 168
				pin = netptr->terminal;
#line 170
				found = 0;
#line 171
				group = 1;
#line 172
				while (1) {
#line 172
					if ((groupArray + group)->numPins != 0) {
#line 172
						if (!(found == 0)) {
#line 172
							break;
						}
					}
					else {
#line 172
						break;
					}
#line 173
					if ((groupArray + group)->extint == extint) {
#line 173
						if (unequiv == 0) {
#line 174
							found = 1;
						}
						else {
#line 176
							group++;
						}
					}
					else {
#line 176
						group++;
					}
				}
#line 180
				((groupArray + group)->numPins)++;
#line 180
				numPins = (groupArray + group)->numPins;
#line 181
				((groupArray + group)->pinArray + numPins)->xloc = locX;
#line 182
				((groupArray + group)->pinArray + numPins)->yloc = locY;
#line 183
				((groupArray + group)->pinArray + numPins)->top = top___0;
#line 184
				((groupArray + group)->pinArray + numPins)->pin = pin;
#line 185
				if (found == 0) {
#line 186
					(groupArray + group)->aveX = locX;
#line 187
					(groupArray + group)->aveY = locY;
#line 188
					(groupArray + group)->extint = extint;
#line 189
					(groupArray + group)->unequiv = unequiv;
#line 190
					(groupArray + group)->block = block___0;
				}
				else {
#line 197
					(groupArray + group)->aveX += locX;
#line 198
					(groupArray + group)->aveY += locY;
				}
#line 153
				netptr = (struct netbox *)netptr->nterm;
			}
#line 201
			group = 1;
#line 201
			while ((groupArray + group)->numPins != 0) {
#line 202
				numPins = (groupArray + group)->numPins;
#line 203
				if (numPins > 1) {
#line 204
					(groupArray + group)->aveX /= numPins;
#line 205
					(groupArray + group)->aveY /= numPins;
				}
#line 201
				group++;
			}
#line 208
			numGroups = group - 1;
#line 213
			if (numGroups == 2) {
#line 214
				if ((groupArray + 1)->unequiv == 1) {
#line 214
					if ((groupArray + 2)->unequiv == 1) {
#line 215
						i = 1;
#line 215
						while (i <= numGroups) {
#line 216
							(groupArray + i)->numPins = 0;
#line 217
							(groupArray + i)->flag = 0;
#line 218
							(groupArray + i)->poison = 0;
#line 219
							(groupArray + i)->unequiv = 0;
#line 220
							(groupArray + i)->extint = 0;
#line 221
							(groupArray + i)->edge1 = 0;
#line 222
							(groupArray + i)->edge2 = 0;
#line 223
							(groupArray + i)->check = 0;
#line 215
							i++;
						}
#line 225
						i = 1;
#line 225
						while (i <= numEdges) {
#line 226
							(edgeArray + i)->marked = 0;
#line 227
							(edgeArray + i)->done = 0;
#line 228
							(edgeArray + i)->poison = 0;
#line 225
							i++;
						}
						goto __Cont;
					}
				}
			}
			else {
#line 232
				if (numGroups <= 1) {
#line 233
					i = 1;
#line 233
					while (i <= numGroups) {
#line 234
						(groupArray + i)->numPins = 0;
#line 235
						(groupArray + i)->flag = 0;
#line 236
						(groupArray + i)->poison = 0;
#line 237
						(groupArray + i)->unequiv = 0;
#line 238
						(groupArray + i)->extint = 0;
#line 239
						(groupArray + i)->edge1 = 0;
#line 240
						(groupArray + i)->edge2 = 0;
#line 241
						(groupArray + i)->check = 0;
#line 233
						i++;
					}
#line 243
					i = 1;
#line 243
					while (i <= numEdges) {
#line 244
						(edgeArray + i)->marked = 0;
#line 245
						(edgeArray + i)->done = 0;
#line 246
						(edgeArray + i)->poison = 0;
#line 243
						i++;
					}
					goto __Cont;
				}
			}
#line 251
			qsortg((char *)(groupArray + 1), numGroups, sizeof(csGroup));
#line 259
			group = 1;
#line 259
			while (group < numGroups) {
#line 260
				block___0 = (groupArray + group)->block;
#line 261
				type1 = detGroup(group);
#line 262
				searchG(group, type1, block___0);
#line 259
				group++;
			}
#line 270
			edge1 = 1;
#line 270
			while (edge1 <= numEdges) {
#line 271
				a1 = (edgeArray + edge1)->group1;
#line 272
				a2 = (edgeArray + edge1)->group2;
#line 273
				if ((groupArray + a1)->block != (groupArray + a2)->block) {
					goto __Cont___0;
				}
#line 276
				edge2 = edge1 + 1;
#line 276
				while (edge2 <= numEdges) {
#line 277
					b1 = (edgeArray + edge2)->group1;
#line 278
					b2 = (edgeArray + edge2)->group2;
#line 279
					if ((groupArray + b1)->block != (groupArray + b2)->block) {
						goto __Cont___1;
					}
#line 283
					if ((groupArray + a1)->unequiv == 1) {
#line 283
						if ((groupArray + b1)->unequiv == 1) {
#line 283
							if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
#line 283
								if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
									goto _L;
								}
								else {
									goto _L___2;
								}
							}
							else {
								goto _L___2;
							}
						}
						else {
							goto _L___2;
						}
					}
					else {
					_L___2: /* CIL Label */
#line 283
						if ((groupArray + a2)->unequiv == 1) {
#line 283
							if ((groupArray + b2)->unequiv == 1) {
#line 283
								if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
#line 283
									if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
									_L: /* CIL Label */
#line 294
										ya = ((groupArray + a1)->aveY + (groupArray + a2)->aveY) / 2;
#line 296
										yb = ((groupArray + b1)->aveY + (groupArray + b2)->aveY) / 2;
#line 299
										if ((groupArray + a1)->block == top_row) {
#line 300
											if (ya < yb) {
#line 301
												if ((edgeArray + edge2)->cost <= (edgeArray + edge1)->cost) {
#line 303
													(edgeArray + edge2)->cost = (edgeArray + edge1)->cost + 1;
												}
											}
											else {
#line 307
												if ((edgeArray + edge2)->cost >= (edgeArray + edge1)->cost) {
#line 309
													(edgeArray + edge2)->cost = (edgeArray + edge1)->cost - 1;
												}
											}
										}
										else {
#line 314
											if (ya < yb) {
#line 315
												if ((edgeArray + edge2)->cost >= (edgeArray + edge1)->cost) {
#line 317
													(edgeArray + edge2)->cost = (edgeArray + edge1)->cost - 1;
												}
											}
											else {
#line 321
												if ((edgeArray + edge2)->cost <= (edgeArray + edge1)->cost) {
#line 323
													(edgeArray + edge2)->cost = (edgeArray + edge1)->cost + 1;
												}
											}
										}
#line 328
										break;
									}
								}
							}
						}
					}
				__Cont___1: /* CIL Label */
#line 276
					edge2++;
				}
			__Cont___0: /* CIL Label */
#line 270
				edge1++;
			}
#line 333
			qsorte((char *)(edgeArray + 1), numEdges, sizeof(edgeBox));
#line 335
			group = 1;
#line 335
			while (group <= numGroups) {
#line 336
				(groupArray + group)->flag = group;
#line 335
				group++;
			}
#line 338
			edge___0 = 1;
#line 338
			while (edge___0 <= numEdges) {
#line 339
				group1 = (edgeArray + edge___0)->group1;
#line 340
				flag1 = (groupArray + group1)->flag;
#line 341
				group2 = (edgeArray + edge___0)->group2;
#line 342
				flag2 = (groupArray + group2)->flag;
#line 343
				if (flag1 <= 0) {
					goto __Cont___2;
				}
				else {
#line 343
					if (flag2 <= 0) {
						goto __Cont___2;
					}
					else {
#line 343
						if (flag1 == flag2) {
							goto __Cont___2;
						}
					}
				}
#line 346
				added_an_edge = 0;
#line 347
				(edgeArray + edge___0)->marked = 1;
#line 348
				group = 1;
#line 348
				while (group <= numGroups) {
#line 349
					if ((groupArray + group)->flag == flag2) {
#line 350
						(groupArray + group)->flag = flag1;
					}
#line 348
					group++;
				}
#line 354
				cell1 = (*(tearray + ((groupArray + group1)->pinArray + 1)->pin))->cell;
#line 355
				cell2 = (*(tearray + ((groupArray + group2)->pinArray + 1)->pin))->cell;
#line 356
				cellptr1 = (struct cellbox___0 *)*(carray + cell1);
#line 357
				cellptr2 = (struct cellbox___0 *)*(carray + cell2);
#line 358
				if (cell1 > numcells) {
#line 358
					if (cellptr1->padside != 2) {
#line 358
						if (cellptr1->padside != 14) {
#line 358
							if (cellptr1->padside != 15) {
#line 358
								if (cellptr1->padside != 4) {
#line 362
									if (cell2 <= numcells) {
#line 363
										(groupArray + group1)->flag = 0;
									}
								}
							}
						}
					}
				}
#line 366
				if (cell2 > numcells) {
#line 366
					if (cellptr2->padside != 2) {
#line 366
						if (cellptr2->padside != 14) {
#line 366
							if (cellptr2->padside != 15) {
#line 366
								if (cellptr2->padside != 4) {
#line 370
									if (cell1 <= numcells) {
#line 371
										(groupArray + group2)->flag = 0;
									}
								}
							}
						}
					}
				}
#line 375
				if ((groupArray + group1)->unequiv == 1) {
#line 376
					ei1 = (groupArray + group1)->extint;
#line 377
					ue_grp = 1;
#line 377
					while (ue_grp <= numGroups) {
#line 378
						if (ue_grp == group1) {
							goto __Cont___3;
						}
#line 381
						if ((groupArray + ue_grp)->extint == ei1) {
#line 382
							break;
						}
					__Cont___3: /* CIL Label */
#line 377
						ue_grp++;
					}
#line 385
					if ((groupArray + ue_grp)->flag > 0) {
#line 386
						g2 = 0;
#line 386
						g1 = g2;
#line 387
						(groupArray + ue_grp)->flag = -1;
#line 388
						edge2 = edge___0 + 1;
#line 388
						while (edge2 <= numEdges) {
#line 389
							if (g2 == 0) {
#line 390
								if ((edgeArray + edge2)->group1 == ue_grp) {
#line 391
									g2 = (edgeArray + edge2)->group2;
#line 392
									if ((groupArray + g2)->flag < 0) {
#line 393
										g2 = 0;
									}
									goto __Cont___4;
								}
							}
#line 398
							if (g1 == 0) {
#line 399
								if ((edgeArray + edge2)->group2 == ue_grp) {
#line 400
									g1 = (edgeArray + edge2)->group1;
#line 401
									if ((groupArray + g1)->flag < 0) {
#line 402
										g1 = 0;
									}
								}
							}
						__Cont___4: /* CIL Label */
#line 388
							edge2++;
						}
#line 407
						if (g1 != 0) {
#line 407
							if (g2 != 0) {
#line 408
								addEdge(g1, g2);
#line 409
								added_an_edge = 1;
							}
						}
					}
				}
#line 413
				if ((groupArray + group2)->unequiv == 1) {
#line 414
					ei2 = (groupArray + group2)->extint;
#line 415
					ue_grp = 1;
#line 415
					while (ue_grp <= numGroups) {
#line 416
						if (ue_grp == group2) {
							goto __Cont___5;
						}
#line 419
						if ((groupArray + ue_grp)->extint == ei2) {
#line 420
							break;
						}
					__Cont___5: /* CIL Label */
#line 415
						ue_grp++;
					}
#line 423
					if ((groupArray + ue_grp)->flag > 0) {
#line 424
						g2 = 0;
#line 424
						g1 = g2;
#line 425
						(groupArray + ue_grp)->flag = -1;
#line 426
						edge2 = edge___0 + 1;
#line 426
						while (edge2 <= numEdges) {
#line 427
							if (g2 == 0) {
#line 428
								if ((edgeArray + edge2)->group1 == ue_grp) {
#line 429
									g2 = (edgeArray + edge2)->group2;
#line 430
									if ((groupArray + g2)->flag < 0) {
#line 431
										g2 = 0;
									}
									goto __Cont___6;
								}
							}
#line 436
							if (g1 == 0) {
#line 437
								if ((edgeArray + edge2)->group2 == ue_grp) {
#line 438
									g1 = (edgeArray + edge2)->group1;
#line 439
									if ((groupArray + g1)->flag < 0) {
#line 440
										g1 = 0;
									}
								}
							}
						__Cont___6: /* CIL Label */
#line 426
							edge2++;
						}
#line 445
						if (g1 != 0) {
#line 445
							if (g2 != 0) {
#line 446
								addEdge(g1, g2);
#line 447
								added_an_edge = 1;
							}
						}
					}
				}
#line 451
				if (added_an_edge == 1) {
#line 452
					edge1 = edge___0 + 1;
#line 452
					while (edge1 <= numEdges) {
#line 453
						a1 = (edgeArray + edge1)->group1;
#line 454
						a2 = (edgeArray + edge1)->group2;
#line 455
						if ((groupArray + a1)->block != (groupArray + a2)->block) {
							goto __Cont___7;
						}
#line 458
						edge2 = edge1 + 1;
#line 458
						while (edge2 <= numEdges) {
#line 459
							b1 = (edgeArray + edge2)->group1;
#line 460
							b2 = (edgeArray + edge2)->group2;
#line 461
							if ((groupArray + b1)->block != (groupArray + b2)->block) {
								goto __Cont___8;
							}
#line 465
							if ((groupArray + a1)->unequiv == 1) {
#line 465
								if ((groupArray + b1)->unequiv == 1) {
#line 465
									if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
#line 465
										if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
											goto _L___3;
										}
										else {
											goto _L___6;
										}
									}
									else {
										goto _L___6;
									}
								}
								else {
									goto _L___6;
								}
							}
							else {
							_L___6: /* CIL Label */
#line 465
								if ((groupArray + a2)->unequiv == 1) {
#line 465
									if ((groupArray + b2)->unequiv == 1) {
#line 465
										if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
#line 465
											if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
											_L___3: /* CIL Label */
#line 480
												ya = ((groupArray + a1)->aveY + (groupArray + a2)->aveY) / 2;
#line 482
												yb = ((groupArray + b1)->aveY + (groupArray + b2)->aveY) / 2;
#line 485
												if ((groupArray + a1)->block == top_row) {
#line 486
													if (ya < yb) {
#line 487
														if ((edgeArray + edge2)->cost <= (edgeArray + edge1)->cost) {
#line 489
															(edgeArray + edge2)->cost = (edgeArray + edge1)->cost + 1;
														}
													}
													else {
#line 493
														if ((edgeArray + edge2)->cost >= (edgeArray + edge1)->cost) {
#line 495
															(edgeArray + edge2)->cost = (edgeArray + edge1)->cost - 1;
														}
													}
												}
												else {
#line 500
													if (ya < yb) {
#line 501
														if ((edgeArray + edge2)->cost >= (edgeArray + edge1)->cost) {
#line 503
															(edgeArray + edge2)->cost = (edgeArray + edge1)->cost - 1;
														}
													}
													else {
#line 507
														if ((edgeArray + edge2)->cost <= (edgeArray + edge1)->cost) {
#line 509
															(edgeArray + edge2)->cost = (edgeArray + edge1)->cost + 1;
														}
													}
												}
#line 514
												break;
											}
										}
									}
								}
							}
						__Cont___8: /* CIL Label */
#line 458
							edge2++;
						}
					__Cont___7: /* CIL Label */
#line 452
						edge1++;
					}
#line 518
					qsorte((char *)((edgeArray + 1) + edge___0), numEdges - edge___0, sizeof(edgeBox));
				}
			__Cont___2: /* CIL Label */
#line 338
				edge___0++;
			}
#line 526
			group = 1;
#line 526
			while (group <= numGroups) {
#line 527
				if ((groupArray + group)->flag < 0) {
					goto __Cont___9;
				}
#line 530
				if ((groupArray + group)->unequiv != 1) {
					goto __Cont___9;
				}
#line 533
				ei = (groupArray + group)->extint;
#line 534
				group2 = group + 1;
#line 534
				while (group2 <= numGroups) {
#line 535
					if ((groupArray + group2)->extint == ei) {
#line 536
						if ((groupArray + group2)->flag >= 0) {
#line 537
							(groupArray + group2)->flag = -1;
						}
#line 539
						break;
					}
#line 534
					group2++;
				}
			__Cont___9: /* CIL Label */
#line 526
				group++;
			}
#line 551
			done = 0;
#line 552
			while (done == 0) {
#line 553
				done = 1;
#line 554
				edge___0 = 1;
#line 554
				while (edge___0 <= numEdges) {
#line 555
					if ((edgeArray + edge___0)->marked == 1) {
#line 555
						if ((edgeArray + edge___0)->poison == 0) {
#line 557
							g1 = (edgeArray + edge___0)->group1;
#line 558
							g2 = (edgeArray + edge___0)->group2;
#line 559
							unequiv1 = (groupArray + g1)->unequiv;
#line 560
							if (unequiv1 == 0) {
#line 561
								if ((groupArray + g1)->numPins == 1) {
#line 561
									if (((groupArray + g1)->pinArray + 1)->top != 0) {
#line 563
										single_pin1 = 1;
#line 564
										unequiv1 = 1;
									}
								}
							}
#line 567
							unequiv2 = (groupArray + g2)->unequiv;
#line 568
							if (unequiv2 == 0) {
#line 569
								if ((groupArray + g2)->numPins == 1) {
#line 569
									if (((groupArray + g2)->pinArray + 1)->top != 0) {
#line 571
										single_pin2 = 1;
#line 572
										unequiv2 = 1;
									}
								}
							}
#line 575
							if ((groupArray + g1)->poison == 1) {
								goto _L___8;
							}
							else {
#line 575
								if ((groupArray + g2)->poison == 1) {
								_L___8: /* CIL Label */
#line 577
									done = 0;
#line 578
									(edgeArray + edge___0)->poison = 1;
#line 579
									if (unequiv1 == 1) {
#line 580
										(groupArray + g1)->poison = 1;
									}
#line 582
									if (unequiv2 == 1) {
#line 583
										(groupArray + g2)->poison = 1;
									}
								}
								else {
#line 585
									if ((groupArray + g1)->block != (groupArray + g2)->block) {
#line 586
										done = 0;
#line 587
										(edgeArray + edge___0)->poison = 1;
#line 588
										if (unequiv1 == 1) {
#line 589
											(groupArray + g1)->poison = 1;
										}
#line 591
										if (unequiv2 == 1) {
#line 592
											(groupArray + g2)->poison = 1;
										}
									}
									else {
#line 594
										if (single_pin1 == 1) {
											goto _L___7;
										}
										else {
#line 594
											if (single_pin2 == 1) {
											_L___7: /* CIL Label */
#line 595
												done = 0;
#line 596
												(edgeArray + edge___0)->poison = 1;
#line 597
												if (unequiv1 == 1) {
#line 598
													(groupArray + g1)->poison = 1;
												}
#line 600
												if (unequiv2 == 1) {
#line 601
													(groupArray + g2)->poison = 1;
												}
											}
										}
									}
								}
							}
						}
					}
#line 554
					edge___0++;
				}
			}
#line 607
			edge___0 = 1;
#line 607
			while (edge___0 <= numEdges) {
#line 608
				if ((edgeArray + edge___0)->marked == 1) {
#line 608
					if ((edgeArray + edge___0)->poison == 0) {
#line 610
						g1 = (edgeArray + edge___0)->group1;
#line 611
						g2 = (edgeArray + edge___0)->group2;
#line 612
						if ((groupArray + g1)->unequiv == 0) {
#line 612
							if ((groupArray + g2)->unequiv == 0) {
#line 613
								(edgeArray + edge___0)->poison = 1;
							}
						}
#line 615
						if ((groupArray + g1)->unequiv == 0) {
#line 616
							(groupArray + g1)->poison = 1;
						}
#line 618
						if ((groupArray + g2)->unequiv == 0) {
#line 619
							(groupArray + g2)->poison = 1;
						}
					}
				}
#line 607
				edge___0++;
			}
#line 626
			edge___0 = 1;
#line 626
			while (edge___0 <= numEdges) {
#line 627
				if ((edgeArray + edge___0)->marked == 1) {
#line 627
					if ((edgeArray + edge___0)->poison == 0) {
#line 629
						g1 = (edgeArray + edge___0)->group1;
#line 630
						g2 = (edgeArray + edge___0)->group2;
#line 631
						if ((groupArray + g1)->edge1 == 0) {
#line 632
							(groupArray + g1)->edge1 = edge___0;
						}
						else {
#line 634
							(groupArray + g1)->edge2 = edge___0;
						}
#line 636
						if ((groupArray + g2)->edge1 == 0) {
#line 637
							(groupArray + g2)->edge1 = edge___0;
						}
						else {
#line 639
							(groupArray + g2)->edge2 = edge___0;
						}
#line 641
						if ((groupArray + g1)->poison == 0) {
#line 642
							ei = (groupArray + g1)->extint;
#line 643
							group = 1;
#line 643
							while (1) {
#line 644
								if (group == g1) {
									goto __Cont___10;
								}
								else {
#line 644
									if ((groupArray + group)->extint != ei) {
										goto __Cont___10;
									}
								}
#line 647
								break;
							__Cont___10: /* CIL Label */
#line 643
								group++;
							}
#line 649
							(groupArray + g1)->numPins = 2;
#line 650
							((groupArray + g1)->pinArray + 2)->xloc = ((groupArray + group)->pinArray + 1)->xloc;
#line 651
							((groupArray + g1)->pinArray + 2)->yloc = ((groupArray + group)->pinArray + 1)->yloc;
#line 652
							((groupArray + g1)->pinArray + 2)->top = ((groupArray + group)->pinArray + 1)->top;
#line 653
							((groupArray + g1)->pinArray + 2)->pin = ((groupArray + group)->pinArray + 1)->pin;
						}
#line 656
						if ((groupArray + g2)->poison == 0) {
#line 657
							ei = (groupArray + g2)->extint;
#line 658
							group = 1;
#line 658
							while (1) {
#line 659
								if (group == g2) {
									goto __Cont___11;
								}
								else {
#line 659
									if ((groupArray + group)->extint != ei) {
										goto __Cont___11;
									}
								}
#line 662
								break;
							__Cont___11: /* CIL Label */
#line 658
								group++;
							}
#line 664
							(groupArray + g2)->numPins = 2;
#line 665
							((groupArray + g2)->pinArray + 2)->xloc = ((groupArray + group)->pinArray + 1)->xloc;
#line 666
							((groupArray + g2)->pinArray + 2)->yloc = ((groupArray + group)->pinArray + 1)->yloc;
#line 667
							((groupArray + g2)->pinArray + 2)->top = ((groupArray + group)->pinArray + 1)->top;
#line 668
							((groupArray + g2)->pinArray + 2)->pin = ((groupArray + group)->pinArray + 1)->pin;
						}
					}
				}
#line 626
				edge___0++;
			}
#line 672
			edge___0 = 1;
#line 672
			while (edge___0 <= numEdges) {
#line 673
				if ((edgeArray + edge___0)->marked == 1) {
#line 673
					if ((edgeArray + edge___0)->poison == 0) {
#line 675
						g1 = (edgeArray + edge___0)->group1;
#line 676
						g2 = (edgeArray + edge___0)->group2;
#line 677
						if ((groupArray + g1)->edge2 == 0) {
#line 677
							if ((groupArray + g2)->edge2 == 0) {
#line 678
								(edgeArray + edge___0)->poison = 1;
							}
						}
					}
				}
#line 672
				edge___0++;
			}
#line 691
			closepins(twfile, net);
#line 696
			i = 1;
#line 696
			while (i <= numGroups) {
#line 697
				(groupArray + i)->numPins = 0;
#line 698
				(groupArray + i)->flag = 0;
#line 699
				(groupArray + i)->poison = 0;
#line 700
				(groupArray + i)->unequiv = 0;
#line 701
				(groupArray + i)->extint = 0;
#line 702
				(groupArray + i)->edge1 = 0;
#line 703
				(groupArray + i)->edge2 = 0;
#line 704
				(groupArray + i)->check = 0;
#line 696
				i++;
			}
#line 706
			i = 1;
#line 706
			while (i <= numEdges) {
#line 707
				(edgeArray + i)->marked = 0;
#line 708
				(edgeArray + i)->done = 0;
#line 709
				(edgeArray + i)->poison = 0;
#line 706
				i++;
			}
		__Cont: /* CIL Label */
#line 141
			net++;
		}
#line 712
		twclose((int)twfile);
#line 713
		return;
	}
}
#line 717 "globe.c"
int chkGroup(int g1, int g2, int direction)
{
	int g1type;
	int g2type;

	{
#line 722
		g1type = detGroup(g1);
#line 723
		g2type = detGroup(g2);
#line 725
		if (direction == 0) {
#line 726
			if (g1type == 0) {
#line 727
				return (1);
			}
			else {
#line 728
				if (g1type == 1) {
#line 729
					if (g2type == 0) {
#line 730
						return (1);
					}
					else {
#line 729
						if (g2type == 1) {
#line 730
							return (1);
						}
						else {
#line 732
							return (0);
						}
					}
				}
				else {
#line 735
					if (g2type == 0) {
#line 736
						return (1);
					}
					else {
#line 735
						if (g2type == -1) {
#line 736
							return (1);
						}
						else {
#line 738
							return (0);
						}
					}
				}
			}
		}
		else {
#line 741
			if (direction == 1) {
#line 742
				if (g1type == 0) {
					goto _L;
				}
				else {
#line 742
					if (g1type == 1) {
					_L: /* CIL Label */
#line 742
						if (g2type == 0) {
#line 744
							return (1);
						}
						else {
#line 742
							if (g2type == -1) {
#line 744
								return (1);
							}
							else {
#line 746
								return (0);
							}
						}
					}
					else {
#line 746
						return (0);
					}
				}
			}
			else {
#line 749
				if (g1type == 0) {
					goto _L___0;
				}
				else {
#line 749
					if (g1type == -1) {
					_L___0: /* CIL Label */
#line 749
						if (g2type == 0) {
#line 751
							return (1);
						}
						else {
#line 749
							if (g2type == 1) {
#line 751
								return (1);
							}
							else {
#line 753
								return (0);
							}
						}
					}
					else {
#line 753
						return (0);
					}
				}
			}
		}
	}
}
#line 759 "globe.c"
int detGroup(int g)
{
	int p;
	int pt;
	int pb;
	int p0;

	{
#line 764
		pt = 0;
#line 765
		pb = 0;
#line 766
		p0 = 0;
#line 767
		p = 1;
#line 767
		while (p <= (groupArray + g)->numPins) {
#line 768
			if (((groupArray + g)->pinArray + p)->top == 0) {
#line 769
				p0 = 1;
			}
			else {
#line 770
				if (((groupArray + g)->pinArray + p)->top == 1) {
#line 771
					pt = 1;
				}
				else {
#line 773
					pb = 1;
				}
			}
#line 767
			p++;
		}
#line 776
		if (p0 == 1) {
#line 777
			return (0);
		}
		else {
#line 776
			if (pt == 1) {
#line 776
				if (pb == 1) {
#line 777
					return (0);
				}
				else {
					goto _L;
				}
			}
			else {
			_L: /* CIL Label */
#line 778
				if (pt == 1) {
#line 779
					return (1);
				}
				else {
#line 781
					return (-1);
				}
			}
		}
	}
}
#line 787 "globe.c"
int addEdge(int g1, int g2)
{

	{
#line 790
		numEdges++;
#line 790
		(edgeArray + numEdges)->cost = ABS((groupArray + g1)->aveX - (groupArray + g2)->aveX);
#line 792
		(edgeArray + numEdges)->group1 = g1;
#line 793
		(edgeArray + numEdges)->group2 = g2;
#line 795
		return (0);
	}
}
#line 798 "globe.c"
int searchG(int g, int type, int block___0)
{
	int og;
	int uptarget;
	int dntarget;
	int type2;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;

	{
#line 803
		uptarget = 0;
#line 804
		dntarget = 0;
#line 805
		if (type == 0) {
#line 806
			og = g + 1;
#line 806
			while (og <= numGroups) {
#line 807
				if ((groupArray + og)->block == block___0) {
#line 808
					tmp = chkGroup(g, og, 0);
#line 808
					if (tmp) {
#line 809
						type2 = detGroup(og);
#line 810
						if (type2 == 0) {
#line 811
							if (uptarget == 0) {
#line 811
								if (dntarget == 0) {
#line 812
									addEdge(g, og);
								}
							}
#line 814
							uptarget = 1;
#line 815
							dntarget = 1;
						}
						else {
#line 816
							if (type2 == 1) {
#line 817
								if (uptarget == 0) {
#line 818
									addEdge(g, og);
#line 819
									uptarget = 1;
								}
							}
							else {
#line 822
								if (dntarget == 0) {
#line 823
									addEdge(g, og);
#line 824
									dntarget = 1;
								}
							}
						}
					}
#line 828
					if (uptarget == 1) {
#line 828
						if (dntarget == 1) {
#line 829
							break;
						}
					}
				}
				else {
#line 831
					if ((groupArray + og)->block == block___0 - 1) {
#line 832
						tmp___0 = chkGroup(g, og, -1);
#line 832
						if (tmp___0) {
#line 833
							if (dntarget == 0) {
#line 834
								addEdge(g, og);
#line 835
								dntarget = 1;
							}
						}
#line 838
						if (uptarget == 1) {
#line 838
							if (dntarget == 1) {
#line 839
								break;
							}
						}
					}
					else {
#line 841
						if ((groupArray + og)->block == block___0 + 1) {
#line 842
							tmp___1 = chkGroup(g, og, 1);
#line 842
							if (tmp___1) {
#line 843
								if (uptarget == 0) {
#line 844
									addEdge(g, og);
#line 845
									uptarget = 1;
								}
							}
#line 848
							if (uptarget == 1) {
#line 848
								if (dntarget == 1) {
#line 849
									break;
								}
							}
						}
					}
				}
#line 806
				og++;
			}
		}
		else {
#line 853
			if (type == 1) {
#line 854
				og = g + 1;
#line 854
				while (og <= numGroups) {
#line 855
					if ((groupArray + og)->block == block___0) {
#line 856
						tmp___2 = chkGroup(g, og, 0);
#line 856
						if (tmp___2) {
#line 857
							addEdge(g, og);
#line 858
							break;
						}
					}
					else {
#line 860
						if ((groupArray + og)->block == block___0 + 1) {
#line 861
							tmp___3 = chkGroup(g, og, 1);
#line 861
							if (tmp___3) {
#line 862
								addEdge(g, og);
#line 863
								break;
							}
						}
					}
#line 854
					og++;
				}
			}
			else {
#line 868
				og = g + 1;
#line 868
				while (og <= numGroups) {
#line 869
					if ((groupArray + og)->block == block___0) {
#line 870
						tmp___4 = chkGroup(g, og, 0);
#line 870
						if (tmp___4) {
#line 871
							addEdge(g, og);
#line 872
							break;
						}
					}
					else {
#line 874
						if ((groupArray + og)->block == block___0 - 1) {
#line 875
							tmp___5 = chkGroup(g, og, -1);
#line 875
							if (tmp___5) {
#line 876
								addEdge(g, og);
#line 877
								break;
							}
						}
					}
#line 868
					og++;
				}
			}
		}
#line 883
		return;
	}
}
#line 1 "globedbg.o"
#pragma merger(0,"./globedbg.i","")
#line 56 "groute.h"
int *anet;
#line 17 "globedbg.c"
void checkPos(NBOXPTR pin, int pos, int llx, int lly, int urx, int ury);
#line 11 "globedbg.c"
void globedbg(int lowerNet, int upperNet)
{
	int block___0;
	int left___0;
	int rite___0;
	int bot___0;
	int top___0;
	int cell___0;
	int b___0;
	int e;
	int pin1;
	int pin2;
	int net;
	int seg;
	int term1;
	int curExtint;
	int separation___0;
	int factor;
	int llx;
	int lly;
	int urx;
	int ury;
	SEGBOXPTR sptr;
	CBOXPTR___0 cellptr___0;
	NBOXPTR curTerm;
	FILE *fp;
	FILE *fpp;

	{
#line 24
		fp = twopen((int)"cell.file", (int)"w", 1);
#line 27
		block___0 = 1;
#line 27
		while (block___0 <= numblock) {
#line 29
			left___0 = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bleft;
#line 30
			bot___0 = (*(barray + block___0))->bycenter + (*(barray + block___0))->bbottom;
#line 31
			top___0 = (*(barray + block___0))->bycenter + (*(barray + block___0))->btop;
#line 33
			if (*(*(pairArray + block___0) + 0) > 0) {
#line 34
				cell___0 = *(*(pairArray + block___0) + *(*(pairArray + block___0) + 0));
#line 35
				rite___0 = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->right;
			}
			else {
#line 37
				rite___0 = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bright;
			}
#line 40
			fprintf(fp, "%d, %d, %d, %d, color: %s, label: row:%d\n", left___0, bot___0, rite___0,
				top___0, "aquamarine", block___0);
#line 27
			block___0++;
		}
#line 44
		llx = 2147483647;
#line 45
		lly = 2147483647;
#line 46
		urx = (-0x7FFFFFFF - 1);
#line 47
		ury = (-0x7FFFFFFF - 1);
#line 49
		cell___0 = numcells + 1;
#line 49
		while (cell___0 <= numcells + numterms) {
#line 50
			cellptr___0 = (struct cellbox___0 *)*(carray + cell___0);
#line 51
			left___0 = cellptr___0->cxcenter + (cellptr___0->tileptr)->left;
#line 52
			rite___0 = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
#line 53
			bot___0 = cellptr___0->cycenter + (cellptr___0->tileptr)->bottom;
#line 54
			top___0 = cellptr___0->cycenter + (cellptr___0->tileptr)->top;
#line 55
			fprintf(fp, "%d, %d, %d, %d, color: %s, label: pad:%s\n", left___0, bot___0, rite___0,
				top___0, "aquamarine", cellptr___0->cname);
#line 58
			if (left___0 < llx) {
#line 59
				llx = left___0;
			}
#line 61
			if (rite___0 > urx) {
#line 62
				urx = rite___0;
			}
#line 64
			if (bot___0 < lly) {
#line 65
				lly = bot___0;
			}
#line 67
			if (top___0 > ury) {
#line 68
				ury = top___0;
			}
#line 49
			cell___0++;
		}
#line 72
		twclose((int)fp);
#line 74
		fp = twopen((int)"net.file", (int)"w", 1);
#line 75
		fpp = twopen((int)"pin.file", (int)"w", 1);
#line 78
		separation___0 = ((int)rowSep * rowHeight) / 3;
#line 81
		net = lowerNet;
#line 81
		while (net <= upperNet) {
#line 82
			b___0 = *(anet + net);
#line 83
			e = *(anet + (net + 1)) - 1;
#line 84
			seg = b___0;
#line 84
			while (seg <= e) {
#line 85
				if ((int)(aNetSeg + seg)->nflag == 0) {
#line 88
					if ((int)(aNetSeg + seg)->current == 0) {
#line 89
						sptr = (aNetSeg + seg)->top;
					}
					else {
#line 91
						sptr = (aNetSeg + seg)->bot;
					}
#line 93
					pin1 = sptr->pin1;
#line 94
					pin2 = sptr->pin2;
#line 95
					checkPos(*(tearray + pin1), 1, llx, lly, urx, ury);
#line 96
					checkPos(*(tearray + pin2), 1, llx, lly, urx, ury);
#line 97
					if ((*(tearray + pin1))->ypos != (*(tearray + pin2))->ypos) {
#line 98
						fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
							(*(tearray + pin1))->ypos, (*(tearray + pin2))->xpos, (*(tearray + pin2))->ypos,
							"red");
					}
					else {
#line 106
						if ((int)(*(tearray + pin1))->pinloc == -1) {
#line 107
							factor = -1;
						}
						else {
#line 109
							factor = 1;
						}
#line 111
						fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
							(*(tearray + pin1))->ypos, ((*(tearray + pin1))->xpos + (*(tearray + pin2))->xpos) / 2,
							(*(tearray + pin2))->ypos + factor * separation___0, "red");
#line 118
						fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, ((*(tearray + pin1))->xpos + (*(tearray + pin2))->xpos) / 2,
							(*(tearray + pin2))->ypos + factor * separation___0, (*(tearray + pin2))->xpos,
							(*(tearray + pin2))->ypos, "red");
					}
#line 128
					term1 = (*(tearray + pin1))->terminal;
#line 129
					curExtint = (*(tearray + pin1))->extint;
#line 130
					curTerm = (struct netbox *)(*(netarray + net))->netptr;
#line 130
					while (curTerm) {
#line 131
						if (curTerm->extint == curExtint) {
#line 131
							if (curTerm->terminal != term1) {
#line 132
								if (curTerm->unequiv) {
#line 133
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
										(*(tearray + pin1))->ypos, curTerm->xpos, curTerm->ypos, "blue");
								}
								else {
#line 142
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
										(*(tearray + pin1))->ypos, curTerm->xpos, curTerm->ypos, "orange");
								}
							}
						}
#line 130
						curTerm = (struct netbox *)curTerm->nterm;
					}
#line 154
					term1 = (*(tearray + pin2))->terminal;
#line 155
					curExtint = (*(tearray + pin2))->extint;
#line 156
					curTerm = (struct netbox *)(*(netarray + net))->netptr;
#line 156
					while (curTerm) {
#line 157
						if (curTerm->extint == curExtint) {
#line 157
							if (curTerm->terminal != term1) {
#line 158
								if (curTerm->unequiv) {
#line 159
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->xpos,
										(*(tearray + pin2))->ypos, curTerm->xpos, curTerm->ypos, "blue");
								}
								else {
#line 168
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->xpos,
										(*(tearray + pin2))->ypos, curTerm->xpos, curTerm->ypos, "orange");
								}
							}
						}
#line 156
						curTerm = (struct netbox *)curTerm->nterm;
					}
#line 179
					fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin1))->xpos - 1,
						(*(tearray + pin1))->ypos - 1, (*(tearray + pin1))->xpos + 1, (*(tearray + pin1))->ypos + 1,
						"white", pin1);
#line 187
					fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin2))->xpos - 1,
						(*(tearray + pin2))->ypos - 1, (*(tearray + pin2))->xpos + 1, (*(tearray + pin2))->ypos + 1,
						"white", pin2);
				}
				else {
#line 196
					if ((int)(aNetSeg + seg)->current == 0) {
#line 197
						sptr = (aNetSeg + seg)->top;
					}
					else {
#line 199
						sptr = (aNetSeg + seg)->bot;
					}
#line 201
					pin1 = sptr->pin1;
#line 202
					pin2 = sptr->pin2;
#line 204
					checkPos(*(tearray + pin1), 1, llx, lly, urx, ury);
#line 205
					checkPos(*(tearray + pin2), 1, llx, lly, urx, ury);
#line 206
					checkPos(*(tearray + pin1), 0, llx, lly, urx, ury);
#line 207
					checkPos(*(tearray + pin2), 0, llx, lly, urx, ury);
#line 209
					if ((*(tearray + pin1))->newy != (*(tearray + pin2))->newy) {
#line 210
						fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->newx,
							(*(tearray + pin1))->newy, (*(tearray + pin1))->newx - 2, ((*(tearray + pin1))->newy + (*(tearray + pin2))->newy) / 2,
							"green");
#line 217
						fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->newx - 2,
							((*(tearray + pin1))->newy + (*(tearray + pin2))->newy) / 2, (*(tearray + pin2))->newx,
							(*(tearray + pin2))->newy, "green");
					}
					else {
#line 225
						if ((int)(*(tearray + pin1))->pinloc == -1) {
#line 226
							factor = -1;
						}
						else {
#line 228
							factor = 1;
						}
#line 230
						fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->newx,
							(*(tearray + pin1))->newy, ((*(tearray + pin1))->newx + (*(tearray + pin2))->newx) / 2,
							(*(tearray + pin2))->newy + ((factor * separation___0) * 3) / 4,
							"green");
#line 237
						fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, ((*(tearray + pin1))->newx + (*(tearray + pin2))->newx) / 2,
							(*(tearray + pin2))->newy + ((factor * separation___0) * 3) / 4,
							(*(tearray + pin2))->newx, (*(tearray + pin2))->newy, "green");
					}
#line 247
					term1 = (*(tearray + pin1))->terminal;
#line 248
					curExtint = (*(tearray + pin1))->extint;
#line 249
					curTerm = (struct netbox *)(*(netarray + net))->netptr;
#line 249
					while (curTerm) {
#line 250
						if (curTerm->extint == curExtint) {
#line 250
							if (curTerm->terminal != term1) {
#line 251
								if (curTerm->unequiv) {
#line 252
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->newx,
										(*(tearray + pin1))->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin1))->newy) / 2,
										"blue");
#line 259
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, curTerm->newx,
										curTerm->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin1))->newy) / 2,
										"blue");
								}
								else {
#line 268
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->newx,
										(*(tearray + pin1))->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin1))->newy) / 2,
										"orange");
#line 276
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, curTerm->newx,
										curTerm->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin1))->newy) / 2,
										"orange");
								}
							}
						}
#line 249
						curTerm = (struct netbox *)curTerm->nterm;
					}
#line 288
					term1 = (*(tearray + pin2))->terminal;
#line 289
					curExtint = (*(tearray + pin2))->extint;
#line 290
					curTerm = (struct netbox *)(*(netarray + net))->netptr;
#line 290
					while (curTerm) {
#line 291
						if (curTerm->extint == curExtint) {
#line 291
							if (curTerm->terminal != term1) {
#line 292
								if (curTerm->unequiv) {
#line 293
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->newx,
										(*(tearray + pin2))->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin2))->newy) / 2,
										"blue");
#line 300
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, curTerm->newx,
										curTerm->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin2))->newy) / 2,
										"blue");
								}
								else {
#line 309
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->newx,
										(*(tearray + pin2))->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin2))->newy) / 2,
										"orange");
#line 316
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, curTerm->newx,
										curTerm->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin2))->newy) / 2,
										"orange");
								}
							}
						}
#line 290
						curTerm = (struct netbox *)curTerm->nterm;
					}
#line 327
					fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin1))->newx - 2,
						(*(tearray + pin1))->newy - 2, (*(tearray + pin1))->newx + 2, (*(tearray + pin1))->newy + 2,
						"black", pin1);
#line 335
					fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin2))->newx - 2,
						(*(tearray + pin2))->newy - 2, (*(tearray + pin2))->newx + 2, (*(tearray + pin2))->newy + 2,
						"black", pin2);
#line 344
					if ((int)(aNetSeg + seg)->ncurrent == 0) {
#line 345
						sptr = (aNetSeg + seg)->ntop;
					}
					else {
#line 347
						sptr = (aNetSeg + seg)->nbot;
					}
#line 349
					pin1 = sptr->pin1;
#line 350
					pin2 = sptr->pin2;
#line 351
					if ((*(tearray + pin1))->ypos != (*(tearray + pin2))->ypos) {
#line 352
						fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
							(*(tearray + pin1))->ypos, (*(tearray + pin2))->xpos, (*(tearray + pin2))->ypos,
							"red");
					}
					else {
#line 360
						if ((int)(*(tearray + pin1))->pinloc == -1) {
#line 361
							factor = -1;
						}
						else {
#line 363
							factor = 1;
						}
#line 365
						fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
							(*(tearray + pin1))->ypos, ((*(tearray + pin1))->xpos + (*(tearray + pin2))->xpos) / 2,
							(*(tearray + pin2))->ypos + factor * separation___0, "red");
#line 372
						fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, ((*(tearray + pin1))->xpos + (*(tearray + pin2))->xpos) / 2,
							(*(tearray + pin2))->ypos + factor * separation___0, (*(tearray + pin2))->xpos,
							(*(tearray + pin2))->ypos, "red");
					}
#line 381
					term1 = (*(tearray + pin1))->terminal;
#line 382
					curExtint = (*(tearray + pin1))->extint;
#line 383
					curTerm = (struct netbox *)(*(netarray + net))->netptr;
#line 383
					while (curTerm) {
#line 384
						if (curTerm->extint == curExtint) {
#line 384
							if (curTerm->terminal != term1) {
#line 385
								if (curTerm->unequiv) {
#line 386
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
										(*(tearray + pin1))->ypos, curTerm->xpos, curTerm->ypos, "blue");
								}
								else {
#line 395
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
										(*(tearray + pin1))->ypos, curTerm->xpos, curTerm->ypos, "orange");
								}
							}
						}
#line 383
						curTerm = (struct netbox *)curTerm->nterm;
					}
#line 407
					term1 = (*(tearray + pin2))->terminal;
#line 408
					curExtint = (*(tearray + pin2))->extint;
#line 409
					curTerm = (struct netbox *)(*(netarray + net))->netptr;
#line 409
					while (curTerm) {
#line 410
						if (curTerm->extint == curExtint) {
#line 410
							if (curTerm->terminal != term1) {
#line 411
								if (curTerm->unequiv) {
#line 412
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->xpos,
										(*(tearray + pin2))->ypos, curTerm->xpos, curTerm->ypos, "blue");
								}
								else {
#line 421
									fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->xpos,
										(*(tearray + pin2))->ypos, curTerm->xpos, curTerm->ypos, "orange");
								}
							}
						}
#line 409
						curTerm = (struct netbox *)curTerm->nterm;
					}
#line 432
					fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin1))->xpos - 1,
						(*(tearray + pin1))->ypos - 1, (*(tearray + pin1))->xpos + 1, (*(tearray + pin1))->ypos + 1,
						"white", pin1);
#line 440
					fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin2))->xpos - 1,
						(*(tearray + pin2))->ypos - 1, (*(tearray + pin2))->xpos + 1, (*(tearray + pin2))->ypos + 1,
						"white", pin2);
				}
#line 84
				seg++;
			}
#line 81
			net++;
		}
#line 451
		twclose((int)fp);
#line 452
		twclose((int)fpp);
#line 453
		return;
	}
}
#line 456 "globedbg.c"
void checkPos(NBOXPTR pin, int pos, int llx, int lly, int urx, int ury)
{

	{
#line 465
		if (pos == 1) {
#line 466
			if (pin->xpos > urx) {
#line 467
				printf("ERROR:pin xpos > urx ; set to urx ;");
#line 468
				pin->xpos = urx;
			}
#line 471
			if (pin->xpos < llx) {
#line 472
				printf("ERROR:pin xpos < llx ; set to llx ;");
#line 473
				pin->xpos = llx;
			}
#line 476
			if (pin->ypos > ury) {
#line 477
				printf("ERROR:pin ypos > ury ; set to ury ;");
#line 478
				pin->ypos = ury;
			}
#line 480
			if (pin->ypos < lly) {
#line 481
				printf("ERROR:pin ypos < lly ; set to lly ;");
#line 482
				pin->ypos = ury;
			}
		}
		else {
#line 485
			if (pin->newx > urx) {
#line 486
				printf("ERROR:pin newx > urx ; set to urx ;");
#line 487
				pin->newx = urx;
			}
#line 490
			if (pin->newx < llx) {
#line 491
				printf("ERROR:pin newx < llx ; set to llx ;");
#line 492
				pin->newx = llx;
			}
#line 495
			if (pin->newy > ury) {
#line 496
				printf("ERROR:pin newy > ury ; set to ury ;");
#line 497
				pin->newy = ury;
			}
#line 499
			if (pin->newy < lly) {
#line 500
				printf("ERROR:pin newy < lly ; set to lly ;");
#line 501
				pin->newy = ury;
			}
		}
#line 505
		return;
	}
}
#line 508 "globedbg.c"
void dumpEdgeArray(int net)
{
	int edge___0;
	FILE *fp;
	FILE *fpp;
	int block___0;
	int left___0;
	int rite___0;
	int bot___0;
	int top___0;
	int cell___0;
	int g1;
	int g2;
	int llx;
	int lly;
	int urx;
	int ury;
	CBOXPTR___0 cellptr___0;

	{
#line 519
		fp = twopen((int)"cell.file", (int)"w", 1);
#line 522
		block___0 = 1;
#line 522
		while (block___0 <= numblock) {
#line 524
			left___0 = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bleft;
#line 525
			bot___0 = (*(barray + block___0))->bycenter + (*(barray + block___0))->bbottom;
#line 526
			top___0 = (*(barray + block___0))->bycenter + (*(barray + block___0))->btop;
#line 528
			if (*(*(pairArray + block___0) + 0) > 0) {
#line 529
				cell___0 = *(*(pairArray + block___0) + *(*(pairArray + block___0) + 0));
#line 530
				rite___0 = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->right;
			}
			else {
#line 532
				rite___0 = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bright;
			}
#line 535
			fprintf(fp, "%d, %d, %d, %d, color: %s, label: row:%d\n", left___0, bot___0, rite___0,
				top___0, "aquamarine", block___0);
#line 522
			block___0++;
		}
#line 539
		llx = 2147483647;
#line 540
		lly = 2147483647;
#line 541
		urx = (-0x7FFFFFFF - 1);
#line 542
		ury = (-0x7FFFFFFF - 1);
#line 544
		cell___0 = numcells + 1;
#line 544
		while (cell___0 <= numcells + numterms) {
#line 545
			cellptr___0 = (struct cellbox___0 *)*(carray + cell___0);
#line 546
			left___0 = cellptr___0->cxcenter + (cellptr___0->tileptr)->left;
#line 547
			rite___0 = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
#line 548
			bot___0 = cellptr___0->cycenter + (cellptr___0->tileptr)->bottom;
#line 549
			top___0 = cellptr___0->cycenter + (cellptr___0->tileptr)->top;
#line 550
			fprintf(fp, "%d, %d, %d, %d, color: %s, label: pad:%s\n", left___0, bot___0, rite___0,
				top___0, "aquamarine", cellptr___0->cname);
#line 553
			if (left___0 < llx) {
#line 554
				llx = left___0;
			}
#line 556
			if (rite___0 > urx) {
#line 557
				urx = rite___0;
			}
#line 559
			if (bot___0 < lly) {
#line 560
				lly = bot___0;
			}
#line 562
			if (top___0 > ury) {
#line 563
				ury = top___0;
			}
#line 544
			cell___0++;
		}
#line 567
		twclose((int)fp);
#line 569
		fp = twopen((int)"net.file", (int)"w", 1);
#line 570
		fpp = twopen((int)"pin.file", (int)"w", 1);
#line 572
		edge___0 = 1;
#line 572
		while (edge___0 <= numEdges) {
#line 574
			g1 = (edgeArray + edge___0)->group1;
#line 575
			g2 = (edgeArray + edge___0)->group2;
#line 577
			if ((edgeArray + edge___0)->marked == 1) {
#line 579
				fprintf(fp, "%d, %d, %d, %d, %d, color: %s, label:%d\n", net, (groupArray + g1)->aveX,
					(groupArray + g1)->aveY, (groupArray + g2)->aveX, (groupArray + g2)->aveY,
					"red", edge___0);
#line 588
				fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label:G%d\n", net, (groupArray + g1)->aveX - 1,
					(groupArray + g1)->aveY - 1, (groupArray + g1)->aveX + 1, (groupArray + g1)->aveY + 1,
					"white", g1);
#line 596
				fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label:G%d\n", net, (groupArray + g2)->aveX - 1,
					(groupArray + g2)->aveY - 1, (groupArray + g2)->aveX + 1, (groupArray + g2)->aveY + 1,
					"white", g2);
			}
			else {
#line 606
				fprintf(fp, "%d, %d, %d, %d, %d, color: %s, label:%d\n", net, (groupArray + g1)->aveX,
					(groupArray + g1)->aveY, (groupArray + g2)->aveX, (groupArray + g2)->aveY,
					"blue", edge___0);
#line 614
				fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label:G%d\n", net, (groupArray + g1)->aveX - 1,
					(groupArray + g1)->aveY - 1, (groupArray + g1)->aveX + 1, (groupArray + g1)->aveY + 1,
					"black", g1);
#line 622
				fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label:G%d\n", net, (groupArray + g2)->aveX - 1,
					(groupArray + g2)->aveY - 1, (groupArray + g2)->aveX + 1, (groupArray + g2)->aveY + 1,
					"black", g2);
			}
#line 572
			edge___0++;
		}
#line 633
		twclose((int)fp);
#line 634
		twclose((int)fpp);
#line 635
		return;
	}
}
#line 1 "globroute.o"
#pragma merger(0,"./globroute.i","")
#line 11 "globroute.c"
FILE *openFile(char *filename, char *readwrite, int abort);
#line 16 "globroute.c"
int attlimit;
#line 104 "globroute.c"
SWITCHBOX *aNetSeg;
#line 105 "globroute.c"
CHANGRDPTR *Begin;
#line 105 "globroute.c"
CHANGRDPTR *End;
#line 106 "globroute.c"
TGRIDPTR *Tgrid;
#line 107 "globroute.c"
DENSITYPTR **Densebox;
#line 107 "globroute.c"
DENSITYPTR **DboxHead;
#line 108 "globroute.c"
int *anet;
#line 108 "globroute.c"
int *netchgs;
#line 108 "globroute.c"
int *fixnetseg;
#line 110 "globroute.c"
int numChans;
#line 110 "globroute.c"
int numSegs;
#line 110 "globroute.c"
int numSwSegs;
#line 110 "globroute.c"
int tracks;
#line 111 "globroute.c"
int *maxTrack;
#line 111 "globroute.c"
int *nmaxTrack;
#line 111 "globroute.c"
int max_tdensity;
#line 112
int *fixarray;
#line 113
int stage;
#line 114
unsigned int randomSeed2;
#line 116 "globroute.c"
FILE *twopen(int a___0, int b___0, int c)
{
	FILE *tmp;

	{
#line 118
		tmp = openFile(a___0, b___0, c);
#line 118
		return (tmp);
	}
}
#line 143
void readseg(FILE *fp);
#line 204
int urcost(int segment);
#line 120 "globroute.c"
void globroute(void)
{
	FILE *fp;
	char filename[64];
	int attperseg;
	int swSeg;
	int flips;
	int attempts___0;
	int seg;
	int breakpoint;
	int stoppoint;
	int found;
	SEGBOXPTR segptr;
	DENSITYPTR denptr;
	CHANGRDPTR gdptr;
	CHANGRDPTR ptr1;
	CHANGRDPTR ptr2;
	int x;
	int x1;
	int x2;
	int channel;
	int track;
	int tmp;
	int tmp___0;

	{
#line 135
		attperseg = 40;
#line 136
		randVar = (int)randomSeed2;
#line 137
		fprintf(fpo, "\nThe rand generator seed was at globroute() : %d\n\n", randVar);
#line 140
		sprintf(filename, "%s.twf", cktName);
#line 141
		fp = twopen((int)(filename), (int)"r", 1);
#line 142
		changrid();
#line 143
		readseg(fp);
#line 144
		twclose(fp);
#line 146
		if (stage == 3) {
#line 147
			seg = 1;
#line 147
			while (seg <= numSegs) {
#line 148
				(aNetSeg + seg)->current = (char)*(fixarray + seg);
#line 147
				seg++;
			}
		}
#line 152
		findrcost();
#line 154
		fprintf(fpo, "\n\nTHIS IS THE ORIGINAL NUMBER OF TRACKS: %d\n\n\n", tracks);
#line 156
		fflush(fpo);
#line 158
		attlimit = attperseg * numSwSegs;
#line 159
		attempts___0 = 0;
#line 160
		flips = 0;
#line 161
		stoppoint = 10 * numSwSegs;
#line 162
		breakpoint = 0;
#line 164
		while (attempts___0 < attlimit) {
#line 165
			while (1) {
#line 166
				while (1) {
#line 167
					tmp = Yacm_random();
#line 167
					swSeg = (int)((float)numSegs * ((float)tmp / (float)2147483647)) + 1;
#line 166
					if (!(swSeg == numSegs + 1)) {
#line 166
						break;
					}
				}
#line 170
				if ((int)(aNetSeg + swSeg)->swYorN == 1) {
#line 170
					if ((aNetSeg + swSeg)->key == 0) {
#line 171
						break;
					}
				}
			}
#line 174
			if ((int)(aNetSeg + swSeg)->current == 0) {
#line 175
				segptr = (aNetSeg + swSeg)->top;
			}
			else {
#line 177
				segptr = (aNetSeg + swSeg)->bot;
			}
#line 179
			channel = segptr->channel;
#line 180
			ptr1 = segptr->pin1ptr;
#line 181
			ptr2 = segptr->pin2ptr;
#line 182
			x1 = (ptr1->netptr)->xpos;
#line 183
			x2 = (ptr2->netptr)->xpos;
#line 185
			found = 0;
#line 187
			denptr = (*(*(DboxHead + channel) + *(maxTrack + channel)))->next;
#line 187
			while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 189
				x = ((denptr->grdptr)->netptr)->xpos;
#line 190
				if (x1 <= x) {
#line 190
					if (x2 >= x) {
#line 191
						found = 1;
#line 192
						break;
					}
				}
#line 187
				denptr = denptr->next;
			}
#line 196
			if (!found) {
#line 197
				breakpoint++;
#line 197
				if (breakpoint > stoppoint) {
#line 198
					break;
				}
#line 200
				attempts___0++;
#line 201
				continue;
			}
#line 204
			tmp___0 = urcost(swSeg);
#line 204
			if (tmp___0) {
#line 205
				flips++;
#line 206
				attempts___0++;
#line 207
				breakpoint = 0;
			}
			else {
#line 209
				breakpoint++;
#line 209
				if (breakpoint > stoppoint) {
#line 210
					break;
				}
#line 212
				attempts___0++;
			}
		}
#line 215
		channel = 1;
#line 215
		while (channel <= numChans) {
#line 216
			gdptr = *(Begin + channel);
#line 216
			while ((unsigned int)gdptr != (unsigned int)((void *)0)) {
#line 218
				gdptr->ntracks = gdptr->tracks;
#line 219
				gdptr->nSegType = gdptr->SegType;
#line 220
				gdptr->nnextgrd = gdptr->nextgrd;
#line 221
				gdptr->nprevgrd = gdptr->prevgrd;
#line 222
				(gdptr->netptr)->newx = (gdptr->netptr)->xpos;
#line 223
				(gdptr->netptr)->newy = (gdptr->netptr)->ypos;
#line 216
				gdptr = gdptr->nextgrd;
			}
#line 225
			track = 0;
#line 225
			while (track <= max_tdensity + 100) {
#line 226
				denptr = *(*(DboxHead + channel) + track);
#line 226
				while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 228
					denptr->nnext = denptr->next;
#line 229
					denptr->nback = denptr->back;
#line 226
					denptr = denptr->next;
				}
#line 225
				track++;
			}
#line 232
			* (nmaxTrack + channel) = *(maxTrack + channel);
#line 215
			channel++;
		}
#line 234
		fprintf(fpo, "no. of accepted flips: %d\n", flips);
#line 235
		fprintf(fpo, "no. of attempted flips: %d\n", attempts___0);
#line 236
		if (numSwSegs != 0) {
#line 237
			fprintf(fpo, "no. of attempted flips / numSwSegs: %.1f\n", (float)attempts___0 / (float)numSwSegs);
		}
#line 240
		fprintf(fpo, "THIS IS THE NUMBER OF TRACKS: %d\n\n\n", tracks);
#line 241
		fflush(fpo);
#line 243
		return;
	}
}
#line 1 "gparser.o"
#pragma merger(0,"./gparser.i","")
#line 178 "/usr/include/stdio.h"
extern int (__attribute__((__cdecl__)) fscanf)(FILE *, char const   *, ...);
#line 210
extern void (__attribute__((__cdecl__)) rewind)(FILE *);
#line 29 "/usr/include/string.h"
extern int (__attribute__((__cdecl__)) strcmp)(char const   *, char const   *);
#line 31
extern char *(__attribute__((__cdecl__)) strcpy)(char *, char const   *);
#line 2 "gparser.c"
int *top_row_for_this_net;
#line 3 "gparser.c"
int *bot_row_for_this_net;
#line 4
int pin_layers_given;
#line 6 "gparser.c"
char **pinnames;
#line 32
void maketabl(void);
#line 67
int addhash(char *hname);
#line 11 "gparser.c"
void gparser(FILE *fp)
{
	int cell___0;
	int term;
	int pinctr;
	int i;
	int layer;
	int block___0;
	int left___0;
	int right;
	int bottom;
	int top___0;
	int xpos;
	int ypos;
	int orient;
	int from;
	float space___0;
	char input[1024];
	char netname[1024];
	NBOXPTR nptr;
	NBOXPTR zapptr;
	CBOXPTR ptr;
	TEBOXPTR cptr;
	TEBOXPTR koptr;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	int tmp___7;
	int tmp___8;
	int tmp___9;
	int tmp___10;
	char *tmp___11;
	char *tmp___12;
	char *tmp___13;
	char *tmp___14;

	{
#line 27
		cell___0 = 0;
#line 28
		pinctr = 0;
#line 29
		netctr = 0;
#line 32
		maketabl();
#line 34
		while (1) {
#line 34
			tmp___10 = fscanf(fp, " %s ", input);
#line 34
			if (!(tmp___10 == 1)) {
#line 34
				break;
			}
#line 36
			tmp___9 = strcmp((char const   *)(input), "cell");
#line 36
			if (tmp___9 == 0) {
#line 37
				cell___0++;
#line 38
				fscanf(fp, " %s ", input);
#line 39
				fscanf(fp, " %s ", input);
#line 40
				fscanf(fp, " %s ", input);
#line 41
				fscanf(fp, " %d ", &block___0);
			}
			else {
#line 42
				tmp___8 = strcmp((char const   *)(input), "initially");
#line 42
				if (tmp___8 == 0) {
#line 43
					fscanf(fp, " %s ", input);
#line 44
					fscanf(fp, " %d ", &from);
#line 45
					fscanf(fp, " %s ", input);
#line 46
					fscanf(fp, " %s ", input);
#line 47
					fscanf(fp, " %s ", input);
#line 48
					fscanf(fp, " %s ", input);
#line 49
					fscanf(fp, " %d ", &block___0);
				}
				else {
#line 50
					tmp___7 = strcmp((char const   *)(input), "nomirror");
#line 50
					if (!(tmp___7 == 0)) {
#line 51
						tmp___6 = strcmp((char const   *)(input), "left");
#line 51
						if (tmp___6 == 0) {
#line 52
							fscanf(fp, " %d ", &left___0);
#line 53
							fscanf(fp, " %s ", input);
#line 54
							fscanf(fp, " %d ", &right);
#line 55
							fscanf(fp, " %s ", input);
#line 56
							fscanf(fp, " %d ", &bottom);
#line 57
							fscanf(fp, " %s ", input);
#line 58
							fscanf(fp, " %d ", &top___0);
						}
						else {
#line 59
							tmp___5 = strcmp((char const   *)(input), "pin");
#line 59
							if (tmp___5 == 0) {
#line 60
								fscanf(fp, " %s ", input);
#line 61
								fscanf(fp, " %s ", input);
#line 62
								fscanf(fp, " %s ", input);
#line 63
								fscanf(fp, " %s ", input);
#line 64
								strcpy(netname, (char const   *)(input));
#line 65
								tmp = strcmp((char const   *)(input), "TW_PASS_THRU");
#line 65
								if (tmp != 0) {
#line 66
									pinctr++;
#line 67
									addhash(input);
								}
#line 69
								if (pin_layers_given != 0) {
#line 70
									fscanf(fp, " %s ", input);
#line 71
									fscanf(fp, " %d ", &layer);
								}
#line 73
								fscanf(fp, " %d %d ", &xpos, &ypos);
							}
							else {
#line 74
								tmp___4 = strcmp((char const   *)(input), "equiv");
#line 74
								if (tmp___4 == 0) {
#line 75
									fscanf(fp, " %s ", input);
#line 76
									fscanf(fp, " %s ", input);
#line 77
									if (pin_layers_given != 0) {
#line 78
										fscanf(fp, " %s ", input);
#line 79
										fscanf(fp, " %d ", &layer);
									}
#line 81
									fscanf(fp, " %d %d ", &xpos, &ypos);
#line 82
									tmp___0 = strcmp((char const   *)(netname), "TW_PASS_THRU");
#line 82
									if (tmp___0 != 0) {
#line 83
										pinctr++;
									}
								}
								else {
#line 85
									tmp___3 = strcmp((char const   *)(input), "unequiv");
#line 85
									if (tmp___3 == 0) {
#line 86
										fscanf(fp, " %s ", input);
#line 87
										fscanf(fp, " %s ", input);
#line 88
										if (pin_layers_given != 0) {
#line 89
											fscanf(fp, " %s ", input);
#line 90
											fscanf(fp, " %d ", &layer);
										}
#line 92
										fscanf(fp, " %d %d ", &xpos, &ypos);
#line 93
										pinctr++;
									}
									else {
#line 94
										tmp___2 = strcmp((char const   *)(input), "pad");
#line 94
										if (tmp___2 == 0) {
#line 95
											fscanf(fp, " %s ", input);
#line 96
											fscanf(fp, " %s ", input);
#line 98
											fscanf(fp, " %s ", input);
#line 99
											fscanf(fp, " %d ", &orient);
#line 101
											fscanf(fp, " %s ", input);
#line 102
											fscanf(fp, " %d ", input);
#line 103
											fscanf(fp, " %s ", input);
#line 104
											fscanf(fp, " %d ", &left___0);
#line 105
											fscanf(fp, " %s ", input);
#line 106
											fscanf(fp, " %d ", &right);
#line 107
											fscanf(fp, " %s ", input);
#line 108
											fscanf(fp, " %d ", &bottom);
#line 109
											fscanf(fp, " %s ", input);
#line 110
											fscanf(fp, " %d ", &top___0);
										}
										else {
#line 111
											tmp___1 = strcmp((char const   *)(input), "sidespace");
#line 111
											if (tmp___1 == 0) {
#line 112
												fscanf(fp, " %f ", &space___0);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
#line 117
		rewind(fp);
#line 119
		tmp___11 = safe_malloc((unsigned int)(numnets + 1) * sizeof(int));
#line 119
		top_row_for_this_net = (int *)tmp___11;
#line 121
		tmp___12 = safe_malloc((unsigned int)(numnets + 1) * sizeof(int));
#line 121
		bot_row_for_this_net = (int *)tmp___12;
#line 123
		i = 1;
#line 123
		while (i <= numnets) {
#line 124
			* (top_row_for_this_net + i) = -1;
#line 125
			* (bot_row_for_this_net + i) = 10000000;
#line 123
			i++;
		}
#line 127
		insert_row(1);
#line 128
		i = 1;
#line 128
		while (i <= numnets) {
#line 129
			nptr = (*(netarray + i))->netptr;
#line 130
			while (nptr) {
#line 131
				if (nptr->row > *(top_row_for_this_net + i)) {
#line 132
					* (top_row_for_this_net + i) = nptr->row;
				}
#line 134
				if (nptr->row < *(bot_row_for_this_net + i)) {
#line 135
					* (bot_row_for_this_net + i) = nptr->row;
				}
#line 130
				nptr = nptr->nterm;
			}
#line 128
			i++;
		}
#line 140
		i = 1;
#line 140
		while (i <= numnets) {
#line 141
			nptr = (*(netarray + i))->netptr;
#line 142
			(*(netarray + i))->netptr = (struct netbox *)((void *)0);
#line 143
			if ((unsigned int)nptr != (unsigned int)((void *)0)) {
#line 144
				zapptr = nptr;
#line 145
				while ((unsigned int)nptr->nterm != (unsigned int)((void *)0)) {
#line 146
					nptr = nptr->nterm;
#line 147
					safe_free(zapptr);
#line 148
					zapptr = nptr;
				}
#line 150
				safe_free(nptr);
			}
#line 140
			i++;
		}
#line 154
		safe_free(tearray);
#line 156
		tmp___13 = safe_malloc((unsigned int)(pinctr + 1) * sizeof(NBOXPTR));
#line 156
		tearray = (NBOXPTR *)tmp___13;
#line 157
		term = 1;
#line 157
		while (term <= pinctr) {
#line 158
			* (tearray + term) = (struct netbox *)((void *)0);
#line 157
			term++;
		}
#line 160
		maxterm = pinctr;
#line 161
		tmp___14 = safe_malloc((unsigned int)(pinctr + 1) * sizeof(char *));
#line 161
		pinnames = (char **)tmp___14;
#line 163
		cell___0 = 1;
#line 163
		while (cell___0 <= numcells + numterms) {
#line 164
			ptr = *(carray + cell___0);
#line 165
			ptr->numterms = 0;
#line 166
			cptr = (ptr->tileptr)->termsptr;
#line 167
			(ptr->tileptr)->termsptr = (struct termbox *)((void *)0);
#line 168
			if ((unsigned int)cptr != (unsigned int)((void *)0)) {
#line 169
				koptr = cptr;
#line 170
				while ((unsigned int)cptr->nextterm != (unsigned int)((void *)0)) {
#line 171
					cptr = cptr->nextterm;
#line 172
					safe_free(koptr);
#line 173
					koptr = cptr;
				}
#line 175
				safe_free(cptr);
			}
#line 163
			cell___0++;
		}
#line 178
		return;
	}
}
#line 1 "grdcell.o"
#pragma merger(0,"./grdcell.i","")
#line 10 "grdcell.c"
void move(int moveType);
#line 12
void point(int *x, int *y);
#line 43 "grdcell.c"
CELLTYPE *head_type;
#line 43 "grdcell.c"
CELLTYPE *active_cell_type;
#line 44 "grdcell.c"
IMPBOX *pin_ptr;
#line 45 "grdcell.c"
int active_type;
#line 89
int add_type(char *type);
#line 134
int hashfind(char *hname);
#line 188
int add_pin(int x);
#line 353
void delHtab(void);
#line 48 "grdcell.c"
void grdcell(FILE *fp)
{
	int i;
	int cell___0;
	int orient;
	int corient;
	int block___0;
	int left___0;
	int right;
	int bottom;
	int top___0;
	int xpos;
	int ypos;
	int pinctr;
	int netx;
	int from;
	int pick_top_pin;
	int hack_off_a_pin;
	int terms;
	int net;
	int extint;
	int layer;
	char input[1024];
	char netname[1024];
	char pname[1024];
	float space___0;
	CBOXPTR ptr;
	TIBOXPTR tile;
	TIBOXPTR tptr;
	TEBOXPTR term;
	TEBOXPTR tmptr;
	NBOXPTR netptr;
	NBOXPTR termptr;
	NBOXPTR saveptr;
	char *tmp;
	size_t tmp___0;
	char *tmp___1;
	TEBOXPTR tmp___2;
	char *tmp___3;
	struct termbox *tmp___4;
	char *tmp___5;
	NBOXPTR tmp___6;
	char *tmp___7;
	int tmp___8;
	size_t tmp___9;
	char *tmp___10;
	struct termbox *tmp___11;
	char *tmp___12;
	NBOXPTR tmp___13;
	char *tmp___14;
	int tmp___15;
	size_t tmp___16;
	char *tmp___17;
	struct termbox *tmp___18;
	char *tmp___19;
	NBOXPTR tmp___20;
	char *tmp___21;
	int tmp___22;
	int tmp___23;
	int tmp___24;
	int tmp___25;
	int tmp___26;
	int tmp___27;
	int tmp___28;
	int tmp___29;
	int tmp___30;
	int tmp___31;
	int tmp___32;
	int tmp___33;
	int tmp___34;
	int tmp___35;
	int tmp___36;

	{
#line 68
		gparser(fp);
#line 70
		tmp = safe_malloc((unsigned int)(numRows + 1) * sizeof(IBOXPTR));
#line 70
		impFeeds = (IBOXPTR *)tmp;
#line 71
		i = 1;
#line 71
		while (i <= numRows) {
#line 72
			* (impFeeds + i) = (struct ibox *)((void *)0);
#line 71
			i++;
		}
#line 75
		cell___0 = 0;
#line 76
		terms = 0;
#line 77
		pinctr = 0;
#line 78
		extint = 0;
#line 80
		while (1) {
#line 80
			tmp___36 = fscanf(fp, " %s ", input);
#line 80
			if (!(tmp___36 == 1)) {
#line 80
				break;
			}
#line 82
			tmp___35 = strcmp((char const   *)(input), "cell");
#line 82
			if (tmp___35 == 0) {
#line 84
				cell___0++;
#line 85
				ptr = *(carray + cell___0);
#line 86
				fscanf(fp, " %s ", input);
#line 87
				fscanf(fp, " %s ", input);
#line 88
				if (gate_array_special) {
#line 89
					active_type = add_type(input);
				}
			}
			else {
#line 92
				tmp___34 = strcmp((char const   *)(input), "initially");
#line 92
				if (tmp___34 == 0) {
#line 93
					fscanf(fp, " %s ", input);
#line 94
					fscanf(fp, " %d ", &from);
#line 95
					fscanf(fp, " %s ", input);
#line 96
					fscanf(fp, " %s ", input);
#line 97
					fscanf(fp, " %s ", input);
#line 98
					fscanf(fp, " %s ", input);
#line 99
					fscanf(fp, " %d ", &block___0);
				}
				else {
#line 101
					tmp___33 = strcmp((char const   *)(input), "nomirror");
#line 101
					if (!(tmp___33 == 0)) {
#line 103
						tmp___32 = strcmp((char const   *)(input), "left");
#line 103
						if (tmp___32 == 0) {
#line 105
							tile = ptr->tileptr;
#line 106
							fscanf(fp, " %d ", &left___0);
						}
						else {
#line 108
							tmp___31 = strcmp((char const   *)(input), "right");
#line 108
							if (tmp___31 == 0) {
#line 110
								fscanf(fp, " %d ", &right);
							}
							else {
#line 112
								tmp___30 = strcmp((char const   *)(input), "bottom");
#line 112
								if (tmp___30 == 0) {
#line 114
									fscanf(fp, " %d ", &bottom);
								}
								else {
#line 116
									tmp___29 = strcmp((char const   *)(input), "top");
#line 116
									if (tmp___29 == 0) {
#line 118
										fscanf(fp, " %d ", &top___0);
									}
									else {
#line 120
										tmp___28 = strcmp((char const   *)(input), "pin");
#line 120
										if (tmp___28 == 0) {
#line 122
											fscanf(fp, " %s ", input);
#line 123
											fscanf(fp, " %s ", input);
#line 124
											strcpy(pname, (char const   *)(input));
#line 125
											fscanf(fp, " %s ", input);
#line 126
											fscanf(fp, " %s ", input);
#line 127
											strcpy(netname, (char const   *)(input));
#line 128
											tmp___8 = strcmp((char const   *)(netname), "TW_PASS_THRU");
#line 128
											if (tmp___8 != 0) {
#line 129
												pinctr++;
#line 130
												extint++;
#line 131
												tmp___0 = strlen((char const   *)(pname));
#line 131
												tmp___1 = safe_malloc((tmp___0 + 1U) * sizeof(char));
#line 131
												* (pinnames + pinctr) = tmp___1;
#line 133
												sprintf(*(pinnames + pinctr), "%s", pname);
#line 134
												netx = hashfind(input);
#line 136
												(ptr->numterms)++;
#line 136
												if (ptr->numterms == 1) {
#line 137
													tmp___3 = safe_malloc(sizeof(TEBOX));
#line 137
													tmp___2 = (struct termbox *)tmp___3;
#line 137
													tile->termsptr = tmp___2;
#line 137
													term = tmp___2;
												}
												else {
#line 140
													tmp___5 = safe_malloc(sizeof(TEBOX));
#line 140
													tmp___4 = (struct termbox *)tmp___5;
#line 140
													term->nextterm = tmp___4;
#line 140
													term = tmp___4;
												}
#line 143
												term->nextterm = (struct termbox *)((void *)0);
#line 144
												term->cellterm = pinctr;
#line 145
												term->ei = extint;
#line 146
												term->ue = 0;
#line 148
												saveptr = (*(netarray + netx))->netptr;
#line 149
												tmp___7 = safe_malloc(sizeof(NBOX));
#line 149
												tmp___6 = (struct netbox *)tmp___7;
#line 149
												(*(netarray + netx))->netptr = tmp___6;
#line 149
												netptr = tmp___6;
#line 151
												netptr->nterm = saveptr;
#line 152
												netptr->terminal = pinctr;
#line 153
												if (terms == 0) {
#line 154
													netptr->cell = cell___0;
												}
#line 156
												netptr->net = netx;
#line 157
												netptr->xpos = 0;
#line 158
												netptr->ypos = 0;
#line 159
												netptr->newx = 0;
#line 160
												netptr->newy = 0;
#line 161
												netptr->flag = (char)0;
#line 162
												netptr->unequiv = (char)0;
#line 163
												if (pin_layers_given != 0) {
#line 164
													fscanf(fp, " %s ", input);
#line 165
													fscanf(fp, " %d ", &layer);
												}
												else {
#line 167
													layer = 1;
												}
#line 169
												fscanf(fp, " %d %d ", &xpos, &ypos);
#line 170
												netptr->layer = (char)(layer - 1);
#line 171
												term->txpos[0] = xpos;
#line 172
												term->typos[0] = ypos;
											}
											else {
#line 174
												if (pin_layers_given != 0) {
#line 175
													fscanf(fp, " %s ", input);
#line 176
													fscanf(fp, " %d ", &layer);
												}
												else {
#line 178
													layer = 1;
												}
#line 180
												fscanf(fp, " %d %d ", &xpos, &ypos);
#line 181
												if (one_pin_feedthru) {
#line 182
													buildimp(cell___0, xpos, top___0, pname, 1, layer - 1);
#line 183
													buildimp(cell___0, xpos, bottom, pname, 0, layer - 1);
												}
												else {
#line 185
													buildimp(cell___0, xpos, ypos, pname, 1, layer - 1);
												}
#line 187
												if (gate_array_special) {
#line 187
													if (active_type) {
#line 188
														add_pin(xpos);
													}
												}
											}
										}
										else {
#line 192
											tmp___27 = strcmp((char const   *)(input), "equiv");
#line 192
											if (tmp___27 == 0) {
#line 194
												fscanf(fp, " %s ", input);
#line 195
												fscanf(fp, " %s ", input);
#line 196
												strcpy(pname, (char const   *)(input));
#line 197
												if (pin_layers_given != 0) {
#line 198
													fscanf(fp, " %s ", input);
#line 199
													fscanf(fp, " %d ", &layer);
												}
												else {
#line 201
													layer = 1;
												}
#line 203
												fscanf(fp, " %d %d ", &xpos, &ypos);
#line 204
												tmp___15 = strcmp((char const   *)(netname), "TW_PASS_THRU");
#line 204
												if (tmp___15 != 0) {
#line 205
													pinctr++;
#line 206
													tmp___9 = strlen((char const   *)(pname));
#line 206
													tmp___10 = safe_malloc((tmp___9 + 1U) * sizeof(char));
#line 206
													* (pinnames + pinctr) = tmp___10;
#line 208
													sprintf(*(pinnames + pinctr), "%s", pname);
#line 209
													(ptr->numterms)++;
#line 210
													tmp___12 = safe_malloc(sizeof(TEBOX));
#line 210
													tmp___11 = (struct termbox *)tmp___12;
#line 210
													term->nextterm = tmp___11;
#line 210
													term = tmp___11;
#line 212
													term->nextterm = (struct termbox *)((void *)0);
#line 213
													term->cellterm = pinctr;
#line 214
													term->ei = extint;
#line 215
													term->ue = 0;
#line 217
													saveptr = (*(netarray + netx))->netptr;
#line 218
													tmp___14 = safe_malloc(sizeof(NBOX));
#line 218
													tmp___13 = (struct netbox *)tmp___14;
#line 218
													(*(netarray + netx))->netptr = tmp___13;
#line 218
													netptr = tmp___13;
#line 220
													netptr->nterm = saveptr;
#line 221
													netptr->terminal = pinctr;
#line 222
													netptr->net = netx;
#line 223
													if (terms == 0) {
#line 224
														netptr->cell = cell___0;
													}
#line 226
													netptr->xpos = 0;
#line 227
													netptr->ypos = 0;
#line 228
													netptr->newx = 0;
#line 229
													netptr->newy = 0;
#line 230
													netptr->flag = (char)0;
#line 231
													netptr->unequiv = (char)0;
#line 232
													netptr->layer = (char)(layer - 1);
#line 233
													term->txpos[0] = xpos;
#line 234
													term->typos[0] = ypos;
												}
												else {
#line 236
													buildimp(cell___0, xpos, ypos, pname, 0, layer - 1);
												}
											}
											else {
#line 239
												tmp___26 = strcmp((char const   *)(input), "unequiv");
#line 239
												if (tmp___26 == 0) {
#line 241
													fscanf(fp, " %s ", input);
#line 242
													fscanf(fp, " %s ", input);
#line 243
													strcpy(pname, (char const   *)(input));
#line 244
													if (pin_layers_given != 0) {
#line 245
														fscanf(fp, " %s ", input);
#line 246
														fscanf(fp, " %d ", &layer);
													}
													else {
#line 248
														layer = 1;
													}
#line 250
													fscanf(fp, " %d %d ", &xpos, &ypos);
#line 252
													hack_off_a_pin = 0;
#line 253
													if ((*(netarray + netx))->numpins >= 10) {
#line 254
														hack_off_a_pin = 1;
#line 255
														if (*(top_row_for_this_net + netx) % 2 == 0) {
#line 257
															if ((*(carray + cell___0))->cblock != *(bot_row_for_this_net + netx)) {
#line 259
																if ((*(carray + cell___0))->cblock % 2 == 0) {
#line 260
																	pick_top_pin = 0;
																}
																else {
#line 262
																	pick_top_pin = 1;
																}
															}
															else {
#line 265
																pick_top_pin = 1;
															}
														}
														else {
#line 268
															if ((*(carray + cell___0))->cblock != *(bot_row_for_this_net + netx)) {
#line 270
																if ((*(carray + cell___0))->cblock % 2 == 1) {
#line 271
																	pick_top_pin = 0;
																}
																else {
#line 273
																	pick_top_pin = 1;
																}
															}
															else {
#line 276
																pick_top_pin = 1;
															}
														}
#line 279
														if ((*(barray + (*(carray + cell___0))->cblock))->borient == 2) {
#line 280
															if (pick_top_pin == 0) {
#line 281
																pick_top_pin = 1;
															}
															else {
#line 283
																pick_top_pin = 0;
															}
														}
													}
#line 287
													if (hack_off_a_pin == 0) {
#line 288
														pinctr++;
#line 289
														tmp___16 = strlen((char const   *)(pname));
#line 289
														tmp___17 = safe_malloc((tmp___16 + 1U) * sizeof(char));
#line 289
														* (pinnames + pinctr) = tmp___17;
#line 291
														sprintf(*(pinnames + pinctr), "%s", pname);
#line 292
														(ptr->numterms)++;
#line 293
														term->ue = 1;
#line 294
														tmp___19 = safe_malloc(sizeof(TEBOX));
#line 294
														tmp___18 = (struct termbox *)tmp___19;
#line 294
														term->nextterm = tmp___18;
#line 294
														term = tmp___18;
#line 296
														term->nextterm = (struct termbox *)((void *)0);
#line 297
														term->cellterm = pinctr;
#line 298
														term->ei = extint;
#line 299
														term->ue = 1;
#line 301
														saveptr = (*(netarray + netx))->netptr;
#line 302
														saveptr->unequiv = (char)1;
#line 303
														tmp___21 = safe_malloc(sizeof(NBOX));
#line 303
														tmp___20 = (struct netbox *)tmp___21;
#line 303
														(*(netarray + netx))->netptr = tmp___20;
#line 303
														netptr = tmp___20;
#line 305
														netptr->nterm = saveptr;
#line 306
														netptr->terminal = pinctr;
#line 307
														netptr->net = netx;
#line 308
														if (terms == 0) {
#line 309
															netptr->cell = cell___0;
														}
#line 311
														netptr->xpos = 0;
#line 312
														netptr->ypos = 0;
#line 313
														netptr->newx = 0;
#line 314
														netptr->newy = 0;
#line 315
														netptr->flag = (char)0;
#line 316
														netptr->unequiv = (char)1;
#line 317
														netptr->layer = (char)(layer - 1);
#line 318
														term->txpos[0] = xpos;
#line 319
														term->typos[0] = ypos;
													}
													else {
#line 321
														if (ypos < -1) {
#line 321
															if (pick_top_pin == 1) {
#line 323
																continue;
															}
															else {
																goto _L;
															}
														}
														else {
														_L: /* CIL Label */
#line 321
															if (ypos > 1) {
#line 321
																if (pick_top_pin == 0) {
#line 323
																	continue;
																}
																else {
#line 325
																	sprintf(*(pinnames + pinctr), "%s", pname);
#line 326
																	term->txpos[0] = xpos;
#line 327
																	term->typos[0] = ypos;
																}
															}
															else {
#line 325
																sprintf(*(pinnames + pinctr), "%s", pname);
#line 326
																term->txpos[0] = xpos;
#line 327
																term->typos[0] = ypos;
															}
														}
													}
												}
												else {
#line 331
													tmp___25 = strcmp((char const   *)(input), "pad");
#line 331
													if (tmp___25 == 0) {
#line 333
														terms++;
#line 334
														fscanf(fp, " %s ", input);
#line 335
														fscanf(fp, " %s ", input);
#line 336
														ptr = *(carray + (numcells + terms));
													}
													else {
#line 338
														tmp___24 = strcmp((char const   *)(input), "orient");
#line 338
														if (tmp___24 == 0) {
#line 340
															fscanf(fp, " %d ", &orient);
														}
														else {
#line 342
															tmp___23 = strcmp((char const   *)(input), "padside");
#line 342
															if (tmp___23 == 0) {
#line 344
																fscanf(fp, " %s ", input);
															}
															else {
#line 345
																tmp___22 = strcmp((char const   *)(input), "sidespace");
#line 345
																if (tmp___22 == 0) {
#line 346
																	fscanf(fp, " %f ", &space___0);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
#line 351
		safe_free(top_row_for_this_net);
#line 353
		delHtab();
#line 355
		net = 1;
#line 355
		while (net <= numnets) {
#line 356
			netptr = (*(netarray + net))->netptr;
#line 356
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 358
				* (tearray + netptr->terminal) = netptr;
#line 356
				netptr = netptr->nterm;
			}
#line 355
			net++;
		}
#line 368
		cell___0 = 1;
#line 368
		while (cell___0 <= numcells) {
#line 369
			ptr = *(carray + cell___0);
#line 370
			tptr = ptr->tileptr;
#line 372
			tmptr = tptr->termsptr;
#line 372
			while ((unsigned int)tmptr != (unsigned int)((void *)0)) {
#line 374
				if (ptr->clength % 2 != 0) {
#line 375
					tmptr->txpos[1] = -tmptr->txpos[0] + 1;
				}
				else {
#line 377
					tmptr->txpos[1] = -tmptr->txpos[0];
				}
#line 379
				if (ptr->cheight % 2 != 0) {
#line 380
					tmptr->typos[1] = -tmptr->typos[0] + 1;
				}
				else {
#line 382
					tmptr->typos[1] = -tmptr->typos[0];
				}
#line 372
				tmptr = tmptr->nextterm;
			}
#line 368
			cell___0++;
		}
#line 387
		cell___0 = numcells + 1;
#line 387
		while (cell___0 <= numcells + numterms) {
#line 389
			ptr = *(carray + cell___0);
#line 390
			tptr = ptr->tileptr;
#line 391
			move(ptr->corient);
#line 392
			tmptr = tptr->termsptr;
#line 392
			while ((unsigned int)tmptr != (unsigned int)((void *)0)) {
#line 394
				tmptr->txpos[1] = tmptr->txpos[0];
#line 395
				tmptr->typos[1] = tmptr->typos[0];
#line 396
				point(&tmptr->txpos[1], &tmptr->typos[1]);
#line 397
				if (ptr->cheight % 2 != 0) {
#line 397
					if (orient == 4) {
#line 399
						(tmptr->txpos[1])++;
					}
					else {
#line 397
						if (orient == 6) {
#line 399
							(tmptr->txpos[1])++;
						}
						else {
							goto _L___0;
						}
					}
				}
				else {
				_L___0: /* CIL Label */
#line 397
					if (ptr->clength % 2 != 0) {
#line 397
						if (orient == 2) {
#line 399
							(tmptr->txpos[1])++;
						}
						else {
#line 397
							if (orient == 3) {
#line 399
								(tmptr->txpos[1])++;
							}
						}
					}
				}
#line 401
				if (ptr->cheight % 2 != 0) {
#line 401
					if (orient == 1) {
#line 403
						(tmptr->typos[1])++;
					}
					else {
#line 401
						if (orient == 3) {
#line 403
							(tmptr->typos[1])++;
						}
						else {
							goto _L___1;
						}
					}
				}
				else {
				_L___1: /* CIL Label */
#line 401
					if (ptr->clength % 2 != 0) {
#line 401
						if (orient == 4) {
#line 403
							(tmptr->typos[1])++;
						}
						else {
#line 401
							if (orient == 7) {
#line 403
								(tmptr->typos[1])++;
							}
						}
					}
				}
#line 392
				tmptr = tmptr->nextterm;
			}
#line 387
			cell___0++;
		}
#line 408
		cell___0 = 1;
#line 408
		while (cell___0 <= numcells) {
#line 409
			ptr = *(carray + cell___0);
#line 410
			tile = ptr->tileptr;
#line 411
			corient = (int)ptr->corient;
#line 412
			term = tile->termsptr;
#line 412
			while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 414
				termptr = *(tearray + term->cellterm);
#line 415
				termptr->xpos = term->txpos[corient / 2] + ptr->cxcenter;
#line 416
				termptr->ypos = term->typos[corient % 2] + ptr->cycenter;
#line 412
				term = term->nextterm;
			}
#line 408
			cell___0++;
		}
#line 419
		cell___0 = numcells + 1;
#line 419
		while (cell___0 <= numcells + numterms) {
#line 420
			ptr = *(carray + cell___0);
#line 421
			tile = ptr->tileptr;
#line 422
			term = tile->termsptr;
#line 422
			while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 424
				termptr = *(tearray + term->cellterm);
#line 425
				termptr->xpos = term->txpos[1] + ptr->cxcenter;
#line 426
				termptr->ypos = term->typos[1] + ptr->cycenter;
#line 422
				term = term->nextterm;
			}
#line 419
			cell___0++;
		}
#line 431
		return;
	}
}
#line 435 "grdcell.c"
int add_type(char *type)
{
	CELLTYPE *cell_ptr;
	char *tmp;
	size_t tmp___0;
	char *tmp___1;
	int tmp___2;
	char *tmp___3;
	size_t tmp___4;
	char *tmp___5;

	{
#line 440
		if ((unsigned int)head_type == (unsigned int)((void *)0)) {
#line 441
			tmp = safe_malloc(sizeof(CELLTYPE));
#line 441
			head_type = (CELLTYPE *)tmp;
#line 442
			head_type->next_cell = (struct celltype *)((void *)0);
#line 443
			head_type->first_imp = (struct impbox *)((void *)0);
#line 445
			tmp___0 = strlen((char const   *)type);
#line 445
			tmp___1 = safe_malloc((tmp___0 + 1U) * sizeof(char));
#line 445
			head_type->name = tmp___1;
#line 447
			sprintf(head_type->name, "%s", type);
#line 448
			pin_ptr = (IMPBOX *)((void *)0);
#line 449
			active_cell_type = head_type;
#line 450
			return (1);
		}
		else {
#line 452
			cell_ptr = head_type;
#line 453
			while (1) {
#line 454
				tmp___2 = strcmp((char const   *)cell_ptr->name, (char const   *)type);
#line 454
				if (tmp___2 == 0) {
#line 455
					return (0);
				}
#line 457
				if ((unsigned int)cell_ptr->next_cell != (unsigned int)((void *)0)) {
#line 458
					cell_ptr = cell_ptr->next_cell;
				}
				else {
#line 460
					tmp___3 = safe_malloc(sizeof(CELLTYPE));
#line 460
					cell_ptr->next_cell = (CELLTYPE *)tmp___3;
#line 462
					(cell_ptr->next_cell)->next_cell = (struct celltype *)((void *)0);
#line 463
					(cell_ptr->next_cell)->first_imp = (struct impbox *)((void *)0);
#line 464
					tmp___4 = strlen((char const   *)type);
#line 464
					tmp___5 = safe_malloc((tmp___4 + 1U) * sizeof(char));
#line 464
					(cell_ptr->next_cell)->name = tmp___5;
#line 466
					sprintf((cell_ptr->next_cell)->name, "%s", type);
#line 467
					pin_ptr = (IMPBOX *)((void *)0);
#line 468
					active_cell_type = cell_ptr->next_cell;
#line 469
					return (1);
				}
			}
		}
	}
}
#line 478 "grdcell.c"
int add_pin(int x)
{
	struct impbox *tmp;
	char *tmp___0;
	struct impbox *tmp___1;
	char *tmp___2;

	{
#line 481
		if ((unsigned int)pin_ptr == (unsigned int)((void *)0)) {
#line 482
			tmp___0 = safe_malloc(sizeof(IMPBOX));
#line 482
			tmp = (IMPBOX *)tmp___0;
#line 482
			active_cell_type->first_imp = tmp;
#line 482
			pin_ptr = tmp;
		}
		else {
#line 485
			tmp___2 = safe_malloc(sizeof(IMPBOX));
#line 485
			tmp___1 = (IMPBOX *)tmp___2;
#line 485
			pin_ptr->next_pin = tmp___1;
#line 485
			pin_ptr = tmp___1;
		}
#line 487
		pin_ptr->x = x;
#line 488
		pin_ptr->next_pin = (struct impbox *)((void *)0);
#line 490
		return (0);
	}
}
#line 495 "grdcell.c"
int find_imp_x(char *name, int x)
{
	int tmp;
	struct _reent *tmp___0;
	int tmp___1;
	struct _reent *tmp___2;

	{
#line 498
		tmp = strcmp("twfeed", (char const   *)name);
#line 498
		if (tmp == 0) {
#line 499
			if (x < 0) {
#line 500
				return (0);
			}
			else {
#line 502
				return (-fdWidth / 2);
			}
		}
#line 506
		active_cell_type = head_type;
#line 507
		while (1) {
#line 508
			if ((unsigned int)active_cell_type == (unsigned int)((void *)0)) {
#line 509
				fprintf(fpo, "Failed to find implicit type\n");
#line 510
				printf("Failed to find implicit type: <%s>\n", name);
#line 511
				tmp___0 = __getreent();
#line 511
				fflush(tmp___0->_stdout);
#line 512
				exit(1);
			}
#line 514
			tmp___1 = strcmp((char const   *)active_cell_type->name, (char const   *)name);
#line 514
			if (tmp___1 == 0) {
#line 515
				break;
			}
#line 517
			active_cell_type = active_cell_type->next_cell;
		}
#line 520
		pin_ptr = active_cell_type->first_imp;
#line 521
		while (1) {
#line 522
			if ((unsigned int)pin_ptr == (unsigned int)((void *)0)) {
#line 523
				fprintf(fpo, "Failed to find implicit pin\n");
#line 524
				printf("Failed to find implicit pin at x=<%d>\n", x);
#line 525
				tmp___2 = __getreent();
#line 525
				fflush(tmp___2->_stdout);
#line 526
				exit(1);
			}
#line 528
			if (pin_ptr->x == x) {
#line 529
				break;
			}
#line 531
			pin_ptr = pin_ptr->next_pin;
		}
#line 534
		if ((unsigned int)pin_ptr->next_pin == (unsigned int)((void *)0)) {
#line 535
			return ((active_cell_type->first_imp)->x);
		}
		else {
#line 537
			return (-(pin_ptr->next_pin)->x);
		}
	}
}
#line 1 "hash.o"
#pragma merger(0,"./hash.i","")
#line 3 "hash.c"
void maketabl(void)
{
	int i;
	char *tmp;

	{
#line 7
		tmp = safe_malloc(3001U * sizeof(HASHPTR));
#line 7
		hashtab = (HASHPTR *)tmp;
#line 8
		i = 0;
#line 8
		while (i < 3001) {
#line 9
			* (hashtab + i) = (struct hash *)((void *)0);
#line 8
			i++;
		}
#line 11
		return;
	}
}
#line 14 "hash.c"
void delHtab(void)
{
	int i;
	HASHPTR hptr;
	HASHPTR zapptr;

	{
#line 19
		i = 0;
#line 19
		while (i < 3001) {
#line 20
			hptr = *(hashtab + i);
#line 21
			if ((unsigned int)hptr != (unsigned int)((struct hash *)((void *)0))) {
#line 22
				zapptr = hptr;
#line 23
				while ((unsigned int)hptr->hnext != (unsigned int)((struct hash *)((void *)0))) {
#line 24
					hptr = hptr->hnext;
#line 25
					safe_free(zapptr);
#line 26
					zapptr = hptr;
				}
#line 28
				safe_free(hptr);
			}
#line 19
			i++;
		}
#line 31
		safe_free(hashtab);
#line 32
		return;
	}
}
#line 35 "hash.c"
int addhash(char *hname)
{
	int i;
	HASHPTR hptr;
	unsigned int hsum;
	size_t tmp;
	HASHPTR tmp___0;
	char *tmp___1;
	size_t tmp___2;
	char *tmp___3;
	int tmp___4;
	struct hash *tmp___5;
	char *tmp___6;
	size_t tmp___7;
	char *tmp___8;

	{
#line 39
		hsum = 0U;
#line 41
		i = 0;
#line 41
		while (1) {
#line 41
			tmp = strlen((char const   *)hname);
#line 41
			if (!((size_t)i < tmp)) {
#line 41
				break;
			}
#line 42
			hsum += (unsigned int)*(hname + i);
#line 41
			i++;
		}
#line 44
		hsum %= 3001U;
#line 45
		hptr = *(hashtab + hsum);
#line 45
		if ((unsigned int)hptr == (unsigned int)((struct hash *)((void *)0))) {
#line 46
			tmp___1 = safe_malloc(sizeof(HASHBOX));
#line 46
			tmp___0 = (struct hash *)tmp___1;
#line 46
			* (hashtab + hsum) = tmp___0;
#line 46
			hptr = tmp___0;
#line 47
			hptr->hnext = (struct hash *)((void *)0);
#line 48
			netctr++;
#line 48
			hptr->hnum = netctr;
#line 49
			tmp___2 = strlen((char const   *)hname);
#line 49
			tmp___3 = safe_malloc((tmp___2 + 1U) * sizeof(char));
#line 49
			hptr->hname = tmp___3;
#line 51
			sprintf(hptr->hname, "%s", hname);
#line 52
			return (1);
		}
		else {
#line 54
			while (1) {
#line 55
				tmp___4 = strcmp((char const   *)hname, (char const   *)hptr->hname);
#line 55
				if (tmp___4 == 0) {
#line 56
					return (0);
				}
#line 58
				if ((unsigned int)hptr->hnext == (unsigned int)((struct hash *)((void *)0))) {
#line 59
					tmp___6 = safe_malloc(sizeof(HASHBOX));
#line 59
					tmp___5 = (struct hash *)tmp___6;
#line 59
					hptr->hnext = tmp___5;
#line 59
					hptr = tmp___5;
#line 60
					hptr->hnext = (struct hash *)((void *)0);
#line 61
					netctr++;
#line 61
					hptr->hnum = netctr;
#line 62
					tmp___7 = strlen((char const   *)hname);
#line 62
					tmp___8 = safe_malloc((tmp___7 + 1U) * sizeof(char));
#line 62
					hptr->hname = tmp___8;
#line 64
					sprintf(hptr->hname, "%s", hname);
#line 65
					return (1);
				}
				else {
#line 67
					hptr = hptr->hnext;
				}
			}
		}
	}
}
#line 73 "hash.c"
int hashfind(char *hname)
{
	int i;
	HASHPTR hptr;
	unsigned int hsum;
	size_t tmp;
	int tmp___0;

	{
#line 77
		hsum = 0U;
#line 79
		i = 0;
#line 79
		while (1) {
#line 79
			tmp = strlen((char const   *)hname);
#line 79
			if (!((size_t)i < tmp)) {
#line 79
				break;
			}
#line 80
			hsum += (unsigned int)*(hname + i);
#line 79
			i++;
		}
#line 82
		hsum %= 3001U;
#line 83
		hptr = *(hashtab + hsum);
#line 83
		if ((unsigned int)hptr == (unsigned int)((struct hash *)((void *)0))) {
#line 84
			return (0);
		}
		else {
#line 86
			while (1) {
#line 87
				tmp___0 = strcmp((char const   *)hname, (char const   *)hptr->hname);
#line 87
				if (tmp___0 == 0) {
#line 88
					return (hptr->hnum);
				}
#line 90
				if ((unsigned int)hptr->hnext == (unsigned int)((struct hash *)((void *)0))) {
#line 91
					return (0);
				}
				else {
#line 93
					hptr = hptr->hnext;
				}
			}
		}
	}
}
#line 1 "implfeeds.o"
#pragma merger(0,"./implfeeds.i","")
#line 21 "implfeeds.c"
IBOXPTR siptr;
#line 22
int ifrange;
#line 24 "implfeeds.c"
IBOXPTR *impFeeds;
#line 27 "implfeeds.c"
int implfeeds(int row___0, int xc)
{
	IBOXPTR iptr;
	int minspan;
	int tmp;

	{
#line 33
		minspan = 32000;
#line 34
		siptr = (struct ibox *)((void *)0);
#line 35
		iptr = *(impFeeds + row___0);
#line 35
		while ((unsigned int)iptr != (unsigned int)((void *)0)) {
#line 36
			if (iptr->iactive <= 0) {
#line 37
				tmp = ABS(iptr->aveXpos - xc);
#line 37
				if (tmp < minspan) {
#line 38
					minspan = ABS(iptr->aveXpos - xc);
#line 39
					siptr = iptr;
				}
			}
#line 35
			iptr = iptr->niptr;
		}
#line 43
		if ((unsigned int)siptr != (unsigned int)((void *)0)) {
#line 43
			if (minspan <= ifrange) {
#line 44
				if (siptr->iactive == 0) {
#line 45
					siptr->iactive = 1;
				}
				else {
#line 47
					siptr->iactive = 2;
				}
#line 49
				return (1);
			}
			else {
#line 51
				return (0);
			}
		}
		else {
#line 51
			return (0);
		}
	}
}
#line 56 "implfeeds.c"
void impfix(void)
{
	IBOXPTR iptr;
	IBOXPTR niptr;
	IPBOXPTR ipptr;
	IPBOXPTR nipptr;
	int row___0;

	{
#line 63
		row___0 = 1;
#line 63
		while (row___0 <= numRows) {
#line 64
			iptr = *(impFeeds + row___0);
#line 65
			if ((unsigned int)iptr == (unsigned int)((void *)0)) {
				goto __Cont;
			}
#line 68
			if (iptr->iactive != 1) {
#line 69
				ipptr = iptr->iptr;
#line 70
				while ((unsigned int)ipptr != (unsigned int)((void *)0)) {
#line 71
					nipptr = ipptr->npin;
#line 72
					safe_free(ipptr);
#line 73
					ipptr = nipptr;
				}
#line 75
				niptr = iptr->niptr;
#line 76
				safe_free(iptr);
#line 77
				iptr = niptr;
#line 78
				while ((unsigned int)iptr != (unsigned int)((void *)0)) {
#line 79
					if (iptr->iactive == 1) {
#line 80
						break;
					}
					else {
#line 82
						ipptr = iptr->iptr;
#line 82
						while ((unsigned int)ipptr != (unsigned int)((void *)0)) {
#line 83
							nipptr = ipptr->npin;
#line 84
							safe_free(ipptr);
#line 85
							ipptr = nipptr;
						}
#line 87
						niptr = iptr->niptr;
#line 88
						safe_free(iptr);
#line 89
						iptr = niptr;
					}
				}
#line 92
				* (impFeeds + row___0) = iptr;
			}
#line 94
			if ((unsigned int)iptr != (unsigned int)((void *)0)) {
#line 95
				niptr = iptr->niptr;
#line 96
				while ((unsigned int)niptr != (unsigned int)((void *)0)) {
#line 97
					if (niptr->iactive != 1) {
#line 98
						ipptr = niptr->iptr;
#line 98
						while ((unsigned int)ipptr != (unsigned int)((void *)0)) {
#line 99
							nipptr = ipptr->npin;
#line 100
							safe_free(ipptr);
#line 101
							ipptr = nipptr;
						}
#line 103
						iptr->niptr = niptr->niptr;
#line 104
						safe_free(niptr);
#line 105
						niptr = iptr->niptr;
					}
					else {
#line 107
						iptr = niptr;
#line 108
						niptr = iptr->niptr;
					}
				}
			}
		__Cont: /* CIL Label */
#line 63
			row___0++;
		}
#line 113
		row___0 = 1;
#line 113
		while (row___0 <= numRows) {
#line 114
			iptr = *(impFeeds + row___0);
#line 114
			while ((unsigned int)iptr != (unsigned int)((void *)0)) {
#line 115
				iptr->iactive = 0;
#line 114
				iptr = iptr->niptr;
			}
#line 113
			row___0++;
		}
#line 119
		return;
	}
}
#line 124 "implfeeds.c"
void impclobr(void)
{
	IBOXPTR iptr;
	IBOXPTR niptr;
	IPBOXPTR ipptr;
	IPBOXPTR nipptr;
	int row___0;

	{
#line 131
		row___0 = 1;
#line 131
		while (row___0 <= numRows) {
#line 132
			iptr = *(impFeeds + row___0);
#line 133
			while ((unsigned int)iptr != (unsigned int)((void *)0)) {
#line 134
				niptr = iptr->niptr;
#line 135
				ipptr = iptr->iptr;
#line 135
				while ((unsigned int)ipptr != (unsigned int)((void *)0)) {
#line 136
					nipptr = ipptr->npin;
#line 137
					safe_free(ipptr);
#line 138
					ipptr = nipptr;
				}
#line 140
				safe_free(iptr);
#line 141
				iptr = niptr;
			}
#line 131
			row___0++;
		}
#line 144
		safe_free(impFeeds);
#line 146
		return;
	}
}
#line 1 "main.o"
#pragma merger(0,"./main.i","")
#line 18 "utils.h"
int initProgram(char *name, char *version);
#line 7 "main.c"
int moveable_cells;
#line 8 "main.h"
unsigned int randomSeed;
#line 9 "main.h"
unsigned int randomSeed2;
#line 11 "main.h"
int connection_machine;
#line 12 "main.h"
int estimate_feeds;
#line 13 "main.h"
int tw_fast;
#line 14 "main.h"
int gate_array_special;
#line 15 "main.h"
int pin_layers_given;
#line 16 "main.h"
int no_feeds_side_nets;
#line 17 "main.h"
int no_net_normalize;
#line 18 "main.h"
int route2act;
#line 19 "main.h"
int routeGrid;
#line 20 "main.h"
int gridCell;
#line 21 "main.h"
int feedLayer;
#line 23 "main.h"
int attmax;
#line 24 "main.h"
int maxCellO;
#line 25 "main.h"
int iteration;
#line 26 "main.h"
int iwire;
#line 27 "main.h"
int iwirex;
#line 28 "main.h"
int iwirey;
#line 29 "main.h"
int fwire;
#line 30 "main.h"
int fwirex;
#line 31 "main.h"
int fwirey;
#line 32 "main.h"
int blkxspan;
#line 33 "main.h"
int blkyspan;
#line 34 "main.h"
int ffeeds;

int success = 0;
#line 35 "main.h"
int addFeeds;
#line 37 "main.h"
success = 1;
int lrtxspan;
#line 38 "main.h"
int lrtyspan;
#line 39 "main.h"
int **pairArray;
#line 40 "main.h"
int attprcel;
#line 41 "main.h"
int doglobal;
#line 42 "main.h"
int cswaps;
#line 43 "main.h"
int costonly;
#line 44 "main.h"
int restart;
#line 45 "main.h"
int ifrange;
#line 46 "main.h"
int *fixarray;
#line 48 "main.h"
int tw_slow;
#line 49 "main.h"
float T;
#line 50 "main.h"
float Tzero;
#line 51 "main.h"
float *desired_accept;
#line 52 "main.h"
float imprange;
#line 53 "main.h"
float binpenCon;
#line 54 "main.h"
float indent;
#line 55 "main.h"
float rowSep;
#line 56 "main.h"
float roLenCon;
#line 57 "main.h"
float stopdeg;
#line 58 "main.h"
float macspace[16];
#line 59 "main.h"
float cost_scale_factor;
#line 73
int *pinlist;
#line 45 "main.c"
void readParFile(void);
#line 47
void Yset_random_seed(int seed);
#line 54
int readblck(FILE *fp);
#line 68
int readcell(FILE *fp);
#line 76
int readnets(FILE *fp);
#line 180
void utemp(void);
#line 186
void outcm(void);
#line 209
int add_dummy_feeds(int feednum);
#line 217
void fixfdpos(FILE *fp);
#line 250
void ugpair(void);
#line 259
void mergplist(void);
#line 260
void outpins(void);
#line 261
void output(void);
#line 280
void print_stats(FILE *fp);
#line 17 "main.c"
int closed = 0;
void main(int argc, char **argv)
{
	FILE *fp;
	char filename[64];
	int block___0;
	int i;
	int net;
	int changes;
	int l;
	int r;
	int b___0;
	int t;
	int cx;
	int cy;
	int cl;
	int cr;
	int cb;
	int ct;
	int cell___0;
	int row___0;
	char name[50];
	int tmp;
	char *tmp___0;

	{
#line 32
		if (argc != 2) {
#line 33
			printf("circuit name not entered properly on command line\n");
#line 34
			printf("Proper syntax: TimberwolfSC circuitName\n");
#line 35    closed = 1;
			exit(1);
		}
#line 37
		sprintf(cktName, "%s", *(argv + 1));
#line 38
		name[0] = (char)'F';
#line 38
		name[1] = (char)':';
#line 38
		name[2] = (char)'\\';
#line 38
		name[3] = (char)'i';
#line 38
		name[4] = (char)'n';
#line 38
		name[5] = (char)'p';
#line 38
		name[6] = (char)'u';
#line 38
		name[7] = (char)'t';
#line 38
		name[8] = (char)'\\';
#line 38
		name[9] = (char)'t';
#line 38
		name[10] = (char)'e';
#line 38
		name[11] = (char)'s';
#line 38
		name[12] = (char)'t';
#line 38
		name[13] = (char)'\000';
#line 40
		sprintf(filename, "%s.out", cktName);
#line 41
		fpo = twopen((int)(filename), (int)"w", 1);
#line 43
		initProgram("TimberWolfSC", "v4.3a");
#line 45
		readParFile();
#line 47
		Yset_random_seed(randomSeed);
#line 52
		sprintf(filename, "%s.blk", cktName);
#line 53
		fp = twopen((int)(filename), (int)"r", 1);
#line 54
		readblck(fp);
#line 55
		twclose((int)fp);
#line 57
		maxCellO = 0;
#line 58
		block___0 = 1;
#line 58
		while (block___0 <= numblock) {
#line 59
			if ((*(barray + block___0))->borient == 2) {
#line 60
				maxCellO = 1;
#line 61
				break;
			}
#line 58
			block___0++;
		}
#line 66
		sprintf(filename, "%s.cel", cktName);
#line 67
		fp = twopen((int)(filename), (int)"r", 1);
#line 68
		readcell(fp);
#line 69
		twclose((int)fp);
#line 74
		sprintf(filename, "%s.net", cktName);
#line 75
		fp = twopen((int)(filename), (int)"r", 1);
#line 76
		readnets(fp);
#line 77
		twclose((int)fp);
#line 79
		iteration = 0;
#line 80
		T = (float)500.0;
#line 82
		t = 0;
#line 83
		b___0 = 32000;
#line 84
		r = 0;
#line 85
		l = 32000;
#line 86
		block___0 = 1;
#line 86
		while (block___0 <= numblock) {
#line 87
			cx = (*(barray + block___0))->bxcenter;
#line 88
			cy = (*(barray + block___0))->bycenter;
#line 89
			cl = (*(barray + block___0))->bleft;
#line 90
			cr = (*(barray + block___0))->bright;
#line 91
			cb = (*(barray + block___0))->bbottom;
#line 92
			ct = (*(barray + block___0))->btop;
#line 93
			if (cx + cr > r) {
#line 94
				r = cx + cr;
			}
#line 96
			if (cx + cl < l) {
#line 97
				l = cx + cl;
			}
#line 99
			if (cy + ct > t) {
#line 100
				t = cy + ct;
			}
#line 102
			if (cy + cb < b___0) {
#line 103
				b___0 = cy + cb;
			}
#line 86
			block___0++;
		}
#line 106
		blkxspan = r - l;
#line 107
		blkyspan = t - b___0;
#line 108
		ifrange = (int)((float)blkxspan * imprange);
#line 109
		fprintf(fpo, "block x-span:%d  block y-span:%d\n", blkxspan, blkyspan);
#line 110
		fprintf(fpo, "implicit feed thru range: %d\n", ifrange);
#line 112
		cell___0 = 1;
#line 112
		while (cell___0 <= numcells + numterms) {
#line 113
			cx = (*(carray + cell___0))->cxcenter;
#line 114
			cy = (*(carray + cell___0))->cycenter;
#line 115
			cl = ((*(carray + cell___0))->tileptr)->left;
#line 116
			cr = ((*(carray + cell___0))->tileptr)->right;
#line 117
			cb = ((*(carray + cell___0))->tileptr)->bottom;
#line 118
			ct = ((*(carray + cell___0))->tileptr)->top;
#line 119
			if (cx + cr > r) {
#line 120
				r = cx + cr;
			}
#line 122
			if (cx + cl < l) {
#line 123
				l = cx + cl;
			}
#line 125
			if (cy + ct > t) {
#line 126
				t = cy + ct;
			}
#line 128
			if (cy + cb < b___0) {
#line 129
				b___0 = cy + cb;
			}
#line 112
			cell___0++;
		}
#line 132
		bdxlen = r - l;
#line 133
		bdylen = t - b___0;
#line 135
		lrtxspan = r;
#line 136
		lrtyspan = t;
#line 139
		net = 1;
#line 139
		while (net <= numnets) {
#line 140
			(*(netarray + net))->Vweight = (float)((double)(*(netarray + net))->Vweight * (2.0 / ((double)rowSep + 1.0)));
#line 139
			net++;
		}
#line 143
		binpenCon = (float)(4.0 * ((double)((float)numcells / (float)numblock) / 39.0));
#line 144
		if ((double)binpenCon > 4.0) {
#line 144
			binpenCon = binpenCon;
		}
		else {
#line 144
			binpenCon = (float)4.0;
		}
#line 145
		binpenCon = (float)1.0;
#line 146
		roLenCon = (float)3.0;
#line 147
		fprintf(fpo, "Using default value of bin.penalty.control:%f\n", binpenCon);
#line 149
		funccost = findcost();
#line 151
		assignro();
#line 153
		initialize_rows();
#line 154
		tmp = initialize_cost();
#line 154
		fprintf(fpo, "\nNew Cost Function: Initial Horizontal Cost:%d\n", tmp);
#line 156
		vert_statistics();
#line 157
		fprintf(fpo, "New Cost Function: FEEDS:%d   MISSING_ROWS:%d\n\n", tot_num_feeds,
			tot_missing_rows);
#line 160
		fprintf(fpo, "bdxlen:%d  bdylen:%d\n", bdxlen, bdylen);
#line 161
		fprintf(fpo, "l:%d  t:%d  r:%d  b:%d\n", l, t, r, b___0);
#line 163
		fprintf(fpo, "\n\n\nTHIS IS THE ROUTE COST OF THE ");
#line 164
		fprintf(fpo, "CURRENT PLACEMENT: %d\n", funccost);
#line 165
		fprintf(fpo, "\n\n\nTHIS IS THE PENALTY OF THE ");
#line 166
		fprintf(fpo, "CURRENT PLACEMENT: %d\n", penalty);
#line 167
		fflush(fpo);
#line 169
		if (!costonly) {
#line 170
			Tzero = (float)0.1;
#line 171
			tmp___0 = safe_malloc(117U * sizeof(float));
#line 171
			desired_accept = (float *)tmp___0;
#line 172
			i = 0;
#line 172
			while (i <= 116) {
#line 173
				if (i < 7) {
#line 174
					* (desired_accept + i) = (float)50.0;
				}
				else {
#line 176
					* (desired_accept + i) = (float)(50.5 - (50.0 / 110.0) * (double)((float)(i - 6)));
				}
#line 172
				i++;
			}
#line 180
			utemp();
		}
		else {
#line 183
			if (connection_machine) {
#line 184
				unlap(-1);
#line 185
				findunlap(-1);
#line 186
				outcm();
			}
#line 188
			if (doglobal) {
#line 189
				countf();
#line 190
				sprintf(filename, "%s.cel", cktName);
#line 191
				fp = twopen((int)(filename), (int)"r", 1);
#line 192
				grdcell(fp);
#line 193
				twclose((int)fp);
#line 194
				reassign();
#line 195
				if (addFeeds == 0) {
#line 196
					row___0 = 1;
#line 196
					while (row___0 <= numblock) {
#line 197
						* (nofeed + row___0) = 1;
#line 196
						row___0++;
					}
				}
#line 200
				findunlap(1);
#line 202
				fdthrus = findfeeds(0);
#line 203
				fdthrus += *(add_to_row + 0);
#line 204
				fixwolf(fdthrus);
#line 205
				findfeeds(1);
#line 207
				unlap(-2);
#line 209
				add_dummy_feeds(last_feed);
#line 211
				numcells += fdthrus;
#line 212
				if (stage >= 2) {
#line 213
					sprintf(filename, "%s.rs2", cktName);
#line 214
					fp = twopen((int)(filename), (int)"r", 0);
#line 216
					if (fp) {
#line 217
						fixfdpos(fp);
#line 218
						twclose((int)fp);
					}
				}
#line 221
				findunlap(0);
#line 229
				i = 1;
#line 229
				while (i <= 8) {
#line 230
					align_init();
#line 231
					changes = alignfeed();
#line 232
					fprintf(fpo, "Total Feed-Alignment Movement (Pass %d): %d\n", i, changes);
#line 229
					i++;
				}
#line 235
				align_init();
#line 237
				findunlap(-1);
#line 239
				moveable_cells = 0;
#line 240
				cell___0 = 1;
#line 240
				while (cell___0 <= numcells) {
#line 241
					if ((*(carray + cell___0))->cclass < 0) {
						goto __Cont;
					}
#line 244
					moveable_cells++;
				__Cont: /* CIL Label */
#line 240
					cell___0++;
				}
#line 247
				globe();
#line 248
				globroute();
#line 249
				if (cswaps) {
#line 250
					ugpair();
				}
#line 252
				findrchk();
#line 253
				fprintf(fpo, "\nFINAL NUMBER OF ROUTING TRACKS: %d\n\n", tracks);
#line 255
				i = 1;
#line 255
				while (i <= numChans) {
#line 256
					fprintf(fpo, "MAX OF CHANNEL:%3d  is: %3d\n", i, *(maxTrack + i));
#line 255
					i++;
				}
#line 259
				mergplist();
#line 260
				outpins();
#line 261
				output();
#line 262
				safe_free(pinlist);
			}
			else {
#line 264
				reassign();
#line 265
				findunlap(1);
#line 266
				output();
			}
		}
#line 270
		fprintf(fpo, "Number of Feed Thrus: %d\n", ffeeds);
#line 271
		fprintf(fpo, "Number of Implicit Feed Thrus: %d\n", impcount);
#line 273
		fprintf(fpo, "\nStatistics:\n");
#line 274
		fprintf(fpo, "Number of Standard Cells: %d\n", numcells - fdthrus);
#line 276
		fprintf(fpo, "Number of Pads: %d \n", numterms);
#line 277
		fprintf(fpo, "Number of Nets: %d \n", numnets);
#line 278
		fprintf(fpo, "Number of Pins: %d \n", maxterm);
#line 280
		print_stats(fpo);
#line 281
		twclose((int)fpo);
		closed = 1;
#line 282
		exit(0);
	}
}
#line 285 "main.c"
void outC(void)
{
	int i;

	{
#line 288
		i = 1;
#line 289
		while (i <= 26) {
#line 291
			printf("%d %d %d\n", (*(carray + i))->cxcenter, (*(carray + i))->cycenter, (*(carray + i))->cclass);
#line 292
			printf("%d %d 0 %d %d %d\n", (*(carray + i))->cheight, (*(carray + i))->clength,
				(*(carray + i))->cblock, (*(carray + i))->numterms, (*(carray + i))->padside);
#line 293
			i++;
		}
#line 295
		printf("****************");
#line 296
		return;
	}
}
#line 298 "main.c"
void outB(void)
{
	int i;

	{
#line 301
		i = 1;
#line 302
		while (i <= 2) {
#line 304
			printf("%d %d %d %d %d %d\n", (*(barray + i))->bxcenter, (*(barray + i))->bycenter,
				(*(barray + i))->bleft, (*(barray + i))->bright, (*(barray + i))->bbottom,
				(*(barray + i))->btop);
#line 305
			printf("%d %d %d %d %d %d\n", (*(barray + i))->bheight, (*(barray + i))->blength,
				(*(barray + i))->desire, (*(barray + i))->oldsize, (*(barray + i))->newsize,
				(*(barray + i))->bclass);
#line 306
			i++;
		}
#line 308
		return;
	}
}
#line 1 "mergplist.o"
#pragma merger(0,"./mergplist.i","")
#line 11 "mergplist.c"
TEMPMERG *tmp_pinlist;
#line 17 "mergplist.c"
int *pinlist;
#line 18 "mergplist.c"
int pinGroup;
#line 19 "mergplist.c"
int *merge_array;
#line 20 "mergplist.c"
int array_length;
#line 72
int assign_group_values(void);
#line 73
int initialize_pins(void);
#line 76
int merge_pins(int segment);
#line 24 "mergplist.c"
void mergplist(void)
{
	int segment;
	int i;
	int current_net;
	int chan;
	int track;
	int terminal___0;
	DENSITYPTR denptr;
	DENSITYPTR temptr;
	char *tmp;
	char *tmp___0;
	char *tmp___1;

	{
#line 31
		chan = 1;
#line 31
		while (chan <= numChans) {
#line 32
			track = 0;
#line 32
			while (track <= max_tdensity + 100) {
#line 33
				denptr = (*(*(DboxHead + chan) + track))->next;
#line 34
				while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 35
					temptr = denptr->next;
#line 36
					safe_free(denptr->grdptr);
#line 37
					safe_cfree(denptr);
#line 38
					denptr = temptr;
				}
#line 40
				safe_cfree(*(*(DboxHead + chan) + track));
#line 32
				track++;
			}
#line 42
			safe_cfree(*(DboxHead + chan));
#line 31
			chan++;
		}
#line 44
		safe_cfree(DboxHead);
#line 45
		terminal___0 = 1;
#line 45
		while (terminal___0 <= maxterm + 2 * numChans) {
#line 46
			safe_free(*(Tgrid + terminal___0));
#line 45
			terminal___0++;
		}
#line 48
		safe_free(Tgrid);
#line 50
		pinGroup = 0;
#line 52
		tmp = safe_malloc((unsigned int)(maxterm + 1) * sizeof(int));
#line 52
		pinlist = (int *)tmp;
#line 53
		i = 1;
#line 53
		while (i <= maxterm) {
#line 54
			* (pinlist + i) = 0;
#line 53
			i++;
		}
#line 57
		tmp___0 = safe_malloc(100U * sizeof(int));
#line 57
		merge_array = (int *)tmp___0;
#line 58
		* (merge_array + 0) = 0;
#line 59
		tmp___1 = safe_malloc(100U * sizeof(TEMPMERG));
#line 59
		tmp_pinlist = (TEMPMERG *)tmp___1;
#line 60
		i = 0;
#line 60
		while (i < 100) {
#line 61
			(tmp_pinlist + i)->value = 0;
#line 62
			(tmp_pinlist + i)->next = 0;
#line 63
			(tmp_pinlist + i)->first = i;
#line 60
			i++;
		}
#line 65
		array_length = 100;
#line 68
		current_net = (aNetSeg + 1)->net;
#line 69
		segment = 1;
#line 69
		while (segment <= numSegs + 1) {
#line 70
			if (segment <= numSegs) {
#line 71
				if ((aNetSeg + segment)->net != current_net) {
#line 72
					assign_group_values();
#line 73
					initialize_pins();
#line 74
					current_net = (aNetSeg + segment)->net;
				}
#line 76
				merge_pins(segment);
			}
			else {
#line 78
				assign_group_values();
			}
#line 69
			segment++;
		}
#line 81
		return;
	}
}
#line 87 "mergplist.c"
int initialize_pins(void)
{
	int i;

	{
#line 92
		i = 1;
#line 92
		while (i <= *(merge_array + 0)) {
#line 93
			(tmp_pinlist + i)->value = 0;
#line 94
			(tmp_pinlist + i)->next = 0;
#line 95
			(tmp_pinlist + i)->first = i;
#line 92
			i++;
		}
#line 97
		* (merge_array + 0) = 0;
#line 99
		return;
	}
}
#line 106 "mergplist.c"
int add_pins(int pin)
{
	int i;
	char *tmp;
	char *tmp___0;

	{
#line 112
		i = 1;
#line 112
		while (i <= *(merge_array + 0)) {
#line 113
			if (pin == *(merge_array + i)) {
#line 114
				return (i);
			}
#line 112
			i++;
		}
#line 118
		(*(merge_array + 0))++;
#line 118
		if (*(merge_array + 0) >= array_length) {
#line 119
			array_length += 100;
#line 120
			tmp = safe_realloc((char *)merge_array, (unsigned int)array_length * sizeof(int));
#line 120
			merge_array = (int *)tmp;
#line 122
			tmp___0 = safe_realloc((char *)tmp_pinlist, (unsigned int)array_length * sizeof(TEMPMERG));
#line 122
			tmp_pinlist = (TEMPMERG *)tmp___0;
#line 124
			i = *(merge_array + 0);
#line 124
			while (i < *(merge_array + 0) + 100) {
#line 125
				(tmp_pinlist + i)->value = 0;
#line 126
				(tmp_pinlist + i)->next = 0;
#line 127
				(tmp_pinlist + i)->first = i;
#line 124
				i++;
			}
		}
#line 131
		* (merge_array + *(merge_array + 0)) = pin;
#line 133
		return (*(merge_array + 0));
	}
}
#line 140 "mergplist.c"
int assign_group_values(void)
{
	int i;

	{
#line 145
		i = 1;
#line 145
		while (i <= *(merge_array + 0)) {
#line 146
			* (pinlist + *(merge_array + i)) = (tmp_pinlist + i)->value;
#line 145
			i++;
		}
#line 149
		return;
	}
}
#line 173
int merge(int i, int j);
#line 155 "mergplist.c"
int merge_pins(int segment)
{
	SEGBOXPTR boxptr___0;
	int tmp;
	int tmp___0;

	{
#line 161
		if ((aNetSeg + segment)->key != 0) {
#line 162
			(aNetSeg + segment)->current = (aNetSeg + (aNetSeg + segment)->key)->current;
		}
#line 164
		if ((int)(aNetSeg + segment)->current == 0) {
#line 165
			boxptr___0 = (aNetSeg + segment)->top;
		}
		else {
#line 167
			boxptr___0 = (aNetSeg + segment)->bot;
		}
#line 169
		if (boxptr___0->pin1 != boxptr___0->pin2) {
#line 169
			if (*(pinlist + boxptr___0->pin1) != *(pinlist + boxptr___0->pin2)) {
#line 173
				tmp = add_pins(boxptr___0->pin2);
#line 173
				tmp___0 = add_pins(boxptr___0->pin1);
#line 173
				merge(tmp___0, tmp);
			}
			else {
#line 169
				if (*(pinlist + boxptr___0->pin1) == 0) {
#line 169
					if (*(pinlist + boxptr___0->pin2) == 0) {
#line 173
						tmp = add_pins(boxptr___0->pin2);
#line 173
						tmp___0 = add_pins(boxptr___0->pin1);
#line 173
						merge(tmp___0, tmp);
					}
				}
			}
		}
#line 176
		return;
	}
}
#line 182 "mergplist.c"
int merge(int i, int j)
{
	int newval;
	int next;
	int first;
	int secfirst;

	{
#line 188
		pinGroup++;
#line 188
		newval = pinGroup;
#line 190
		secfirst = (tmp_pinlist + j)->first;
#line 191
		first = (tmp_pinlist + i)->first;
#line 193
		next = secfirst;
#line 194
		while (1) {
#line 195
			(tmp_pinlist + next)->value = newval;
#line 196
			(tmp_pinlist + next)->first = first;
#line 197
			next = (tmp_pinlist + next)->next;
#line 194
			if (!(next != 0)) {
#line 194
				break;
			}
		}
#line 200
		next = first;
#line 201
		while (1) {
#line 202
			(tmp_pinlist + next)->value = newval;
#line 203
			if ((tmp_pinlist + next)->next != 0) {
#line 204
				next = (tmp_pinlist + next)->next;
			}
			else {
#line 206
				(tmp_pinlist + next)->next = secfirst;
#line 207
				break;
			}
		}
#line 210
		return;
	}
}
#line 1 "move.o"
#pragma merger(0,"./move.i","")
#line 19 "mt.h"
MT *MTBegin(void);
#line 4 "move.c"
static MT *mt = (MT *)((void *)0);
#line 20
void MTPoint(MT *t, int *x, int *y);
#line 8 "move.c"
void point(int *x, int *y)
{
	int xx;
	int yy;

	{
#line 12
		if ((unsigned int)mt == (unsigned int)((MT *)((void *)0))) {
#line 14
			return;
		}
#line 17
		xx = *x;
#line 18
		yy = *y;
#line 20
		MTPoint(mt, &xx, &yy);
#line 22
		* x = xx;
#line 23
		* y = yy;
#line 25
		return;
	}
}
#line 30 "move.c"
void rect(int *l, int *b___0, int *r, int *t)
{
	int temp;

	{
#line 35
		point(l, b___0);
#line 36
		point(r, t);
#line 38
		if (*l > *r) {
#line 40
			temp = *l;
#line 41
			* l = *r;
#line 42
			* r = temp;
		}
#line 45
		if (*b___0 > *t) {
#line 47
			temp = *b___0;
#line 48
			* b___0 = *t;
#line 49
			* t = temp;
		}
#line 52
		return;
	}
}
#line 65
void MTIdenti(MT *t);
#line 76
void MTMY(MT *t);
#line 82
void MTMX(MT *t);
#line 88
void MTRotate(MT *t, int x, int y);
#line 57 "move.c"
void move(int moveType)
{

	{
#line 60
		if ((unsigned int)mt == (unsigned int)((MT *)((void *)0))) {
#line 62
			mt = MTBegin();
		}
#line 65
		MTIdenti(mt);
#line 67
		switch (moveType) {
		case 0:
#line 71
			return;
		case 1:
#line 76
			MTMY(mt);
#line 77
			return;
		case 2:
#line 82
			MTMX(mt);
#line 83
			return;
		case 3:
#line 88
			MTRotate(mt, -1, 0);
#line 89
			return;
		case 4:
#line 94
			MTMX(mt);
#line 95
			MTRotate(mt, 0, 1);
#line 96
			return;
		case 5:
#line 101
			MTMX(mt);
#line 102
			MTRotate(mt, 0, -1);
#line 103
			return;
		case 6:
#line 108
			MTRotate(mt, 0, 1);
#line 109
			return;
		case 7:
#line 114
			MTRotate(mt, 0, -1);
#line 115
			return;
		}
#line 118
		return;
	}
}
#line 1 "mt.o"
#pragma merger(0,"./mt.i","")
#line 20 "mt.c"
static void MTInvert(MT *t);
#line 22 "mt.c"
MT *MTBegin(void)
{
	MT *t;
	char *tmp;

	{
#line 33
		tmp = safe_malloc(sizeof(MT));
#line 33
		t = (MT *)tmp;
#line 33
		if ((unsigned int)t == (unsigned int)((void *)0)) {
#line 34
			return ((MT *)((void *)0));
		}
#line 35
		t->sp = 0;
#line 36
		MTIdenti(t);
#line 37
		return (t);
	}
}
#line 45
extern int( /* missing proto */  free)();
#line 40 "mt.c"
void MTEnd(MT *t)
{

	{
#line 45
		free(t);
#line 46
		return;
	}
}
#line 48 "mt.c"
void MTIdenti(MT *t)
{
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	int tmp___7;
	int tmp___8;
	int tmp___9;
	int tmp___10;
	int tmp___11;
	int tmp___12;
	int tmp___13;
	int tmp___14;

	{
#line 53
		tmp___3 = 1;
#line 53
		t->t[2][2] = tmp___3;
#line 53
		tmp___2 = tmp___3;
#line 53
		t->t[1][1] = tmp___2;
#line 53
		tmp___1 = tmp___2;
#line 53
		t->t[0][0] = tmp___1;
#line 53
		tmp___0 = tmp___1;
#line 53
		t->ti[2][2] = tmp___0;
#line 53
		tmp = tmp___0;
#line 53
		t->ti[1][1] = tmp;
#line 53
		t->ti[0][0] = tmp;
#line 55
		tmp___14 = 0;
#line 55
		t->ti[2][1] = tmp___14;
#line 55
		tmp___13 = tmp___14;
#line 55
		t->ti[2][0] = tmp___13;
#line 55
		tmp___12 = tmp___13;
#line 55
		t->ti[1][2] = tmp___12;
#line 55
		tmp___11 = tmp___12;
#line 55
		t->ti[0][2] = tmp___11;
#line 55
		tmp___10 = tmp___11;
#line 55
		t->ti[1][0] = tmp___10;
#line 55
		tmp___9 = tmp___10;
#line 55
		t->ti[0][1] = tmp___9;
#line 55
		tmp___8 = tmp___9;
#line 55
		t->t[2][1] = tmp___8;
#line 55
		tmp___7 = tmp___8;
#line 55
		t->t[2][0] = tmp___7;
#line 55
		tmp___6 = tmp___7;
#line 55
		t->t[1][2] = tmp___6;
#line 55
		tmp___5 = tmp___6;
#line 55
		t->t[0][2] = tmp___5;
#line 55
		tmp___4 = tmp___5;
#line 55
		t->t[1][0] = tmp___4;
#line 55
		t->t[0][1] = tmp___4;
#line 58
		return;
	}
}
#line 60 "mt.c"
void MTTransl(MT *t, int x, int y)
{

	{
#line 65
		t->t[2][0] += x;
#line 66
		t->t[2][1] += y;
#line 67
		MTInvert(t);
#line 68
		return;
	}
}
#line 70 "mt.c"
void MTMY(MT *t)
{

	{
#line 75
		t->t[0][1] = -t->t[0][1];
#line 76
		t->t[1][1] = -t->t[1][1];
#line 77
		t->t[2][1] = -t->t[2][1];
#line 78
		MTInvert(t);
#line 79
		return;
	}
}
#line 81 "mt.c"
void MTMX(MT *t)
{

	{
#line 86
		t->t[0][0] = -t->t[0][0];
#line 87
		t->t[1][0] = -t->t[1][0];
#line 88
		t->t[2][0] = -t->t[2][0];
#line 89
		MTInvert(t);
#line 90
		return;
	}
}
#line 92 "mt.c"
void MTRotate(MT *t, int x, int y)
{
	register int i1;
	int tmp;
	int tmp___0;
	register int i;
	register int j;

	{
#line 100
		if (x == 0) {
#line 101
			tmp = ABS(y);
#line 101
			if (tmp > 1) {
#line 102
				if (y < 0) {
#line 103
					y = -1;
				}
				else {
#line 104
					y = 1;
				}
			}
		}
		else {
#line 105
			if (y == 0) {
#line 106
				tmp___0 = ABS(x);
#line 106
				if (tmp___0 > 1) {
#line 107
					if (x < 0) {
#line 108
						x = -1;
					}
					else {
#line 109
						x = 1;
					}
				}
			}
		}
#line 110
		if (x == 1) {
#line 110
			if (y == 0) {
#line 111
				return;
			}
			else {
				goto _L___1;
			}
		}
		else {
		_L___1: /* CIL Label */
#line 112
			if (x == 0) {
#line 112
				if (y == -1) {
#line 113
					i1 = t->t[0][0];
#line 114
					t->t[0][0] = t->t[0][1];
#line 115
					t->t[0][1] = -i1;
#line 116
					i1 = t->t[1][0];
#line 117
					t->t[1][0] = t->t[1][1];
#line 118
					t->t[1][1] = -i1;
#line 119
					i1 = t->t[2][0];
#line 120
					t->t[2][0] = t->t[2][1];
#line 121
					t->t[2][1] = -i1;
				}
				else {
					goto _L___0;
				}
			}
			else {
			_L___0: /* CIL Label */
#line 122
				if (x == 0) {
#line 122
					if (y == 1) {
#line 123
						i1 = t->t[0][0];
#line 124
						t->t[0][0] = -t->t[0][1];
#line 125
						t->t[0][1] = i1;
#line 126
						i1 = t->t[1][0];
#line 127
						t->t[1][0] = -t->t[1][1];
#line 128
						t->t[1][1] = i1;
#line 129
						i1 = t->t[2][0];
#line 130
						t->t[2][0] = -t->t[2][1];
#line 131
						t->t[2][1] = i1;
					}
					else {
						goto _L;
					}
				}
				else {
				_L: /* CIL Label */
#line 132
					if (x == -1) {
#line 132
						if (y == 0) {
#line 135
							i = 0;
#line 135
							while (i < 3) {
#line 136
								j = 0;
#line 136
								while (j < 2) {
#line 137
									t->t[i][j] = -t->t[i][j];
#line 136
									j++;
								}
#line 135
								i++;
							}
						}
					}
				}
			}
		}
#line 138
		MTInvert(t);
#line 139
		return;
	}
}
#line 141 "mt.c"
void MTConcat(MT *t, int(*a___0)[3])
{
	register int i1;
	register int i2;
	register int i3;
	register int i4;
	register int i5;
	register int i6;

	{
#line 149
		i1 = t->t[0][0] * (*(a___0 + 0))[0] + t->t[0][1] * (*(a___0 + 1))[0];
#line 151
		i2 = t->t[0][0] * (*(a___0 + 0))[1] + t->t[0][1] * (*(a___0 + 1))[1];
#line 153
		i3 = t->t[1][0] * (*(a___0 + 0))[0] + t->t[1][1] * (*(a___0 + 1))[0];
#line 155
		i4 = t->t[1][0] * (*(a___0 + 0))[1] + t->t[1][1] * (*(a___0 + 1))[1];
#line 157
		i5 = (t->t[2][0] * (*(a___0 + 0))[0] + t->t[2][1] * (*(a___0 + 1))[0]) + (*(a___0 + 2))[0];
#line 160
		i6 = (t->t[2][0] * (*(a___0 + 0))[1] + t->t[2][1] * (*(a___0 + 1))[1]) + (*(a___0 + 2))[1];
#line 163
		t->t[0][0] = i1;
#line 164
		t->t[0][1] = i2;
#line 165
		t->t[1][0] = i3;
#line 166
		t->t[1][1] = i4;
#line 167
		t->t[2][0] = i5;
#line 168
		t->t[2][1] = i6;
#line 169
		MTInvert(t);
#line 170
		return;
	}
}
#line 172 "mt.c"
void MTPoint(MT *t, int *x, int *y)
{
	int i1;

	{
#line 179
		i1 = (*x * t->t[0][0] + *y * t->t[1][0]) + t->t[2][0];
#line 181
		* y = (*x * t->t[0][1] + *y * t->t[1][1]) + t->t[2][1];
#line 183
		* x = i1;
#line 184
		return;
	}
}
#line 186 "mt.c"
void MTIPoint(MT *t, int *x, int *y)
{
	int i1;

	{
#line 193
		i1 = (*x * t->ti[0][0] + *y * t->ti[1][0]) + t->ti[2][0];
#line 195
		* y = (*x * t->ti[0][1] + *y * t->ti[1][1]) + t->ti[2][1];
#line 197
		* x = i1;
#line 198
		return;
	}
}
#line 200 "mt.c"
Bool MTPushP(MT *t)
{
	register int i;
	register int j;

	{
#line 209
		if (t->sp == 100) {
#line 210
			return ((enum __anonenum_Bool_7)0);
		}
#line 211
		i = 0;
#line 211
		while (i < 3) {
#line 212
			j = 0;
#line 212
			while (j < 2) {
#line 213
				t->stk[t->sp][i][j] = t->t[i][j];
#line 212
				j++;
			}
#line 211
			i++;
		}
#line 215
		(t->sp)++;
#line 216
		return ((enum __anonenum_Bool_7)1);
	}
}
#line 219 "mt.c"
Bool MTPopP(MT *t)
{
	register int i;
	register int j;

	{
#line 228
		if (t->sp == 0) {
#line 229
			return ((enum __anonenum_Bool_7)0);
		}
#line 230
		(t->sp)--;
#line 231
		i = 0;
#line 231
		while (i < 3) {
#line 232
			j = 0;
#line 232
			while (j < 2) {
#line 233
				t->t[i][j] = t->stk[t->sp][i][j];
#line 232
				j++;
			}
#line 231
			i++;
		}
#line 235
		MTInvert(t);
#line 236
		return ((enum __anonenum_Bool_7)1);
	}
}
#line 239 "mt.c"
Bool MTPremul(MT *t)
{
	register int i1;
	register int i2;
	register int i3;
	register int i4;
	register int i5;
	register int i6;
	register int sp;

	{
#line 248
		if (t->sp == 0) {
#line 249
			return ((enum __anonenum_Bool_7)0);
		}
#line 250
		sp = t->sp - 1;
#line 251
		i1 = t->t[0][0] * t->stk[sp][0][0] + t->t[0][1] * t->stk[sp][1][0];
#line 253
		i2 = t->t[0][0] * t->stk[sp][0][1] + t->t[0][1] * t->stk[sp][1][1];
#line 255
		i3 = t->t[1][0] * t->stk[sp][0][0] + t->t[1][1] * t->stk[sp][1][0];
#line 257
		i4 = t->t[1][0] * t->stk[sp][0][1] + t->t[1][1] * t->stk[sp][1][1];
#line 259
		i5 = (t->t[2][0] * t->stk[sp][0][0] + t->t[2][1] * t->stk[sp][1][0]) + t->stk[sp][2][0];
#line 262
		i6 = (t->t[2][0] * t->stk[sp][0][1] + t->t[2][1] * t->stk[sp][1][1]) + t->stk[sp][2][1];
#line 265
		t->t[0][0] = i1;
#line 266
		t->t[0][1] = i2;
#line 267
		t->t[1][0] = i3;
#line 268
		t->t[1][1] = i4;
#line 269
		t->t[2][0] = i5;
#line 270
		t->t[2][1] = i6;
#line 271
		MTInvert(t);
#line 272
		return ((enum __anonenum_Bool_7)1);
	}
}
#line 283 "mt.c"
static char cif[81];
#line 275 "mt.c"
Bool MTDecode(MT *t, char **s)
{
	register int a___0;
	register int b___0;
	register int c;
	register int d;
	register int tx;
	register int ty;
	Bool tmp;

	{
#line 285
		tmp = MTPushP(t);
#line 285
		if (!tmp) {
#line 286
			return ((enum __anonenum_Bool_7)0);
		}
#line 293
		a___0 = t->t[0][0];
#line 294
		b___0 = t->t[1][0];
#line 295
		c = t->t[0][1];
#line 296
		d = t->t[1][1];
#line 297
		tx = t->t[2][0];
#line 298
		ty = t->t[2][1];
#line 299
		MTIdenti(t);
#line 300
		if (a___0 == 0) {
#line 300
			if (b___0 == 1) {
#line 300
				if (c == 1) {
#line 300
					if (d == 0) {
#line 301
						MTMX(t);
#line 302
						MTRotate(t, 0, -1);
#line 303
						MTTransl(t, tx, ty);
#line 304
						if (tx != 0) {
#line 305
							sprintf(cif, "MX R 0 -1 T %d %d", tx, ty);
						}
						else {
#line 304
							if (ty != 0) {
#line 305
								sprintf(cif, "MX R 0 -1 T %d %d", tx, ty);
							}
							else {
#line 306
								sprintf(cif, "MX R 0 -1");
							}
						}
					}
					else {
						goto _L___19;
					}
				}
				else {
					goto _L___19;
				}
			}
			else {
				goto _L___19;
			}
		}
		else {
		_L___19: /* CIL Label */
#line 307
			if (a___0 == 0) {
#line 307
				if (b___0 == -1) {
#line 307
					if (c == -1) {
#line 307
						if (d == 0) {
#line 308
							MTMX(t);
#line 309
							MTRotate(t, 0, 1);
#line 310
							MTTransl(t, tx, ty);
#line 311
							if (tx != 0) {
#line 312
								sprintf(cif, "MX R 0 1 T %d %d", tx, ty);
							}
							else {
#line 311
								if (ty != 0) {
#line 312
									sprintf(cif, "MX R 0 1 T %d %d", tx, ty);
								}
								else {
#line 313
									sprintf(cif, "MX R 0 1");
								}
							}
						}
						else {
							goto _L___16;
						}
					}
					else {
						goto _L___16;
					}
				}
				else {
					goto _L___16;
				}
			}
			else {
			_L___16: /* CIL Label */
#line 314
				if (a___0 == 0) {
#line 314
					if (b___0 == 1) {
#line 314
						if (c == -1) {
#line 314
							if (d == 0) {
#line 315
								MTRotate(t, 0, -1);
#line 316
								MTTransl(t, tx, ty);
#line 317
								if (tx != 0) {
#line 318
									sprintf(cif, "R 0 -1 T %d %d", tx, ty);
								}
								else {
#line 317
									if (ty != 0) {
#line 318
										sprintf(cif, "R 0 -1 T %d %d", tx, ty);
									}
									else {
#line 319
										sprintf(cif, "R 0 -1");
									}
								}
							}
							else {
								goto _L___13;
							}
						}
						else {
							goto _L___13;
						}
					}
					else {
						goto _L___13;
					}
				}
				else {
				_L___13: /* CIL Label */
#line 320
					if (a___0 == 0) {
#line 320
						if (b___0 == -1) {
#line 320
							if (c == 1) {
#line 320
								if (d == 0) {
#line 321
									MTRotate(t, 0, 1);
#line 322
									MTTransl(t, tx, ty);
#line 323
									if (tx != 0) {
#line 324
										sprintf(cif, "R 0 1 T %d %d", tx, ty);
									}
									else {
#line 323
										if (ty != 0) {
#line 324
											sprintf(cif, "R 0 1 T %d %d", tx, ty);
										}
										else {
#line 325
											sprintf(cif, "R 0 1");
										}
									}
								}
								else {
									goto _L___10;
								}
							}
							else {
								goto _L___10;
							}
						}
						else {
							goto _L___10;
						}
					}
					else {
					_L___10: /* CIL Label */
#line 326
						if (a___0 == 1) {
#line 326
							if (b___0 == 0) {
#line 326
								if (c == 0) {
#line 326
									if (d == 1) {
#line 327
										MTTransl(t, tx, ty);
#line 328
										if (tx != 0) {
#line 329
											sprintf(cif, "T %d %d", tx, ty);
										}
										else {
#line 328
											if (ty != 0) {
#line 329
												sprintf(cif, "T %d %d", tx, ty);
											}
											else {
#line 330
												cif[0] = (char)'\000';
											}
										}
									}
									else {
										goto _L___7;
									}
								}
								else {
									goto _L___7;
								}
							}
							else {
								goto _L___7;
							}
						}
						else {
						_L___7: /* CIL Label */
#line 331
							if (a___0 == -1) {
#line 331
								if (b___0 == 0) {
#line 331
									if (c == 0) {
#line 331
										if (d == -1) {
#line 332
											MTRotate(t, -1, 0);
#line 333
											MTTransl(t, tx, ty);
#line 334
											if (tx != 0) {
#line 335
												sprintf(cif, "R -1 0 T %d %d", tx, ty);
											}
											else {
#line 334
												if (ty != 0) {
#line 335
													sprintf(cif, "R -1 0 T %d %d", tx, ty);
												}
												else {
#line 336
													sprintf(cif, "R -1 0");
												}
											}
										}
										else {
											goto _L___4;
										}
									}
									else {
										goto _L___4;
									}
								}
								else {
									goto _L___4;
								}
							}
							else {
							_L___4: /* CIL Label */
#line 337
								if (a___0 == -1) {
#line 337
									if (b___0 == 0) {
#line 337
										if (c == 0) {
#line 337
											if (d == 1) {
#line 338
												MTMX(t);
#line 339
												MTTransl(t, tx, ty);
#line 340
												if (tx != 0) {
#line 341
													sprintf(cif, "MX T %d %d", tx, ty);
												}
												else {
#line 340
													if (ty != 0) {
#line 341
														sprintf(cif, "MX T %d %d", tx, ty);
													}
													else {
#line 342
														sprintf(cif, "MX");
													}
												}
											}
											else {
												goto _L___1;
											}
										}
										else {
											goto _L___1;
										}
									}
									else {
										goto _L___1;
									}
								}
								else {
								_L___1: /* CIL Label */
#line 343
									if (a___0 == 1) {
#line 343
										if (b___0 == 0) {
#line 343
											if (c == 0) {
#line 343
												if (d == -1) {
#line 344
													MTMY(t);
#line 345
													MTTransl(t, tx, ty);
#line 346
													if (tx != 0) {
#line 347
														sprintf(cif, "MY T %d %d", tx, ty);
													}
													else {
#line 346
														if (ty != 0) {
#line 347
															sprintf(cif, "MY T %d %d", tx, ty);
														}
														else {
#line 348
															sprintf(cif, "MY");
														}
													}
												}
												else {
#line 350
													MTPopP(t);
#line 351
													return ((enum __anonenum_Bool_7)0);
												}
											}
											else {
#line 350
												MTPopP(t);
#line 351
												return ((enum __anonenum_Bool_7)0);
											}
										}
										else {
#line 350
											MTPopP(t);
#line 351
											return ((enum __anonenum_Bool_7)0);
										}
									}
									else {
#line 350
										MTPopP(t);
#line 351
										return ((enum __anonenum_Bool_7)0);
									}
								}
							}
						}
					}
				}
			}
		}
#line 352
		if (t->t[0][0] == a___0) {
#line 352
			if (t->t[0][1] == c) {
#line 352
				if (t->t[1][0] == b___0) {
#line 352
					if (t->t[1][1] == d) {
#line 354
						MTPopP(t);
#line 355
						* s = cif;
#line 356
						return ((enum __anonenum_Bool_7)1);
					}
					else {
#line 358
						MTPopP(t);
#line 359
						return ((enum __anonenum_Bool_7)0);
					}
				}
				else {
#line 358
					MTPopP(t);
#line 359
					return ((enum __anonenum_Bool_7)0);
				}
			}
			else {
#line 358
				MTPopP(t);
#line 359
				return ((enum __anonenum_Bool_7)0);
			}
		}
		else {
#line 358
			MTPopP(t);
#line 359
			return ((enum __anonenum_Bool_7)0);
		}
	}
}
#line 361 "mt.c"
static void MTInvert(MT *t)
{
	int tmp;

	{
#line 394
		t->ti[0][0] = t->t[0][0];
#line 395
		t->ti[0][1] = t->t[1][0];
#line 396
		t->ti[1][0] = t->t[0][1];
#line 397
		t->ti[1][1] = t->t[1][1];
#line 399
		t->ti[2][0] = -t->t[2][0] * t->t[0][0] - t->t[2][1] * t->t[0][1];
#line 401
		t->ti[2][1] = -t->t[2][0] * t->t[1][0] - t->t[2][1] * t->t[1][1];
#line 402
		tmp = 0;
#line 402
		t->ti[1][2] = tmp;
#line 402
		t->ti[0][2] = tmp;
#line 403
		t->ti[2][2] = 1;
#line 404
		return;
	}
}
#line 1 "okmalloc.o"
#pragma merger(0,"./okmalloc.i","")
#line 22 "okmalloc.c"
extern char *malloc();
#line 25
int cleanupHandler(int status, char *function);
#line 18 "okmalloc.c"
char *safe_malloc(unsigned int size)
{
	char *p;

	{
#line 24
		p = malloc(size);
#line 24
		if ((unsigned int)p == (unsigned int)((char *)0)) {
#line 25
			cleanupHandler(1074135042, "safe_malloc");
		}
#line 27
		return (p);
	}
}
#line 35
extern char *realloc();
#line 31 "okmalloc.c"
char *safe_realloc(char *obj, unsigned int size)
{
	char *p;

	{
#line 37
		p = realloc(obj, size);
#line 37
		if ((unsigned int)p == (unsigned int)((char *)0)) {
#line 38
			cleanupHandler(1074135042, "safe_realloc");
		}
#line 40
		return (p);
	}
}
#line 48
extern char *calloc();
#line 44 "okmalloc.c"
char *safe_calloc(unsigned int size, unsigned int num)
{
	char *p;

	{
#line 50
		p = calloc(size, num);
#line 50
		if ((unsigned int)p == (unsigned int)((char *)0)) {
#line 51
			cleanupHandler(1074135042, "safe_calloc");
		}
#line 53
		return (p);
	}
}
#line 56 "okmalloc.c"
void safe_free(char *ptr)
{

	{
#line 58
		free(ptr);
#line 59
		return;
	}
}
#line 62 "okmalloc.c"
void safe_cfree(char *ptr)
{

	{
#line 65
		return;
	}
}
#line 73 "okmalloc.c"
int cleanup(int sigNum)
{

	{
#line 76
		cleanupHandler(-sigNum, (void *)0);
#line 78
		return (0);
	}
}
#line 80 "okmalloc.c"
int cleanupHandler(int status, char *function)
{

	{
#line 83
		exit(1);
	}
}
#line 1 "outcm.o"
#pragma merger(0,"./outcm.i","")
#line 3 "outcm.c"
void outcm(void)
{
	char filename[64];
	FILE *fp;
	NBOXPTR netptr;
	int net;
	int x;
	int local_pin_count;
	int pin_count;
	int cell___0;
	int row___0;
	int length;
	int xstart;

	{
#line 13
		sprintf(filename, "%s.cm", cktName);
#line 14
		fp = twopen((int)(filename), (int)"w", 1);
#line 16
		pin_count = 0;
#line 17
		net = 1;
#line 17
		while (net <= numnets) {
#line 18
			local_pin_count = 0;
#line 19
			netptr = (*(netarray + net))->netptr;
#line 19
			while (netptr) {
#line 20
				if (netptr->cell <= numcells) {
#line 21
					local_pin_count++;
				}
#line 19
				netptr = netptr->nterm;
			}
#line 24
			if (local_pin_count > 1) {
#line 25
				pin_count += local_pin_count;
			}
#line 17
			net++;
		}
#line 28
		fprintf(fp, "%d\n", pin_count);
#line 30
		net = 1;
#line 30
		while (net <= numnets) {
#line 31
			local_pin_count = 0;
#line 32
			netptr = (*(netarray + net))->netptr;
#line 32
			while (netptr) {
#line 33
				if (netptr->cell <= numcells) {
#line 34
					local_pin_count++;
				}
#line 32
				netptr = netptr->nterm;
			}
#line 37
			if (local_pin_count <= 1) {
				goto __Cont;
			}
#line 40
			netptr = (*(netarray + net))->netptr;
#line 40
			while (netptr) {
#line 41
				if (netptr->cell > numcells) {
					goto __Cont___0;
				}
#line 44
				cell___0 = netptr->cell;
#line 45
				row___0 = (*(carray + cell___0))->cblock;
#line 46
				x = netptr->xpos;
#line 47
				length = ((*(carray + cell___0))->tileptr)->right - ((*(carray + cell___0))->tileptr)->left;
#line 49
				xstart = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->left;
#line 51
				fprintf(fp, "%8d %8d %8d %8d %8d %8d\n", row___0, cell___0, net, x, length,
					xstart);
			__Cont___0: /* CIL Label */
#line 40
				netptr = netptr->nterm;
			}
		__Cont: /* CIL Label */
#line 30
			net++;
		}
#line 55
		fclose(fp);
#line 57
		return;
	}
}
#line 1 "outpins.o"
#pragma merger(0,"./outpins.i","")
#line 131 "outpins.c"
int min_l_chan_edge(int channel);
#line 207
int min_r_chan_edge(int channel);
#line 10 "outpins.c"
void outpins(void)
{
	char filename[64];
	FILE *fp;
	NBOXPTR netptr;
	SEGBOXPTR sptr;
	int net;
	int b___0;
	int e;
	int seg;
	int x;
	int y;
	int pin;
	int pinloc;
	int chan;
	int xx;
	int chan1;
	int chan2;
	int r_core_edge;
	int l_core_edge;
	int l_end;
	int r_end;
	int cell___0;
	int blk___0;
	int pin2_1;
	int pin2_2;

	{
#line 23
		sprintf(filename, "%s.pin", cktName);
#line 24
		fp = twopen((int)(filename), (int)"w", 1);
#line 26
		r_core_edge = 0;
#line 27
		l_core_edge = 32000;
#line 28
		blk___0 = 1;
#line 28
		while (blk___0 <= numblock) {
#line 29
			cell___0 = *(*(pairArray + blk___0) + *(*(pairArray + blk___0) + 0));
#line 30
			r_end = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->right;
#line 31
			cell___0 = *(*(pairArray + blk___0) + 1);
#line 32
			l_end = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->left;
#line 33
			if (r_end > r_core_edge) {
#line 34
				r_core_edge = r_end;
			}
#line 36
			if (l_end < l_core_edge) {
#line 37
				l_core_edge = l_end;
			}
#line 28
			blk___0++;
		}
#line 41
		net = 1;
#line 41
		while (net <= numnets) {
#line 42
			netptr = (struct netbox *)(*(netarray + net))->netptr;
#line 43
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 44
				pin = netptr->terminal;
#line 45
				if (*(pinlist + pin) == 0) {
					goto __Cont;
				}
#line 48
				pinloc = -((int)netptr->pinloc);
#line 49
				x = netptr->xpos;
#line 50
				y = netptr->ypos;
#line 52
				b___0 = *(anet + net);
#line 53
				e = *(anet + (net + 1)) - 1;
#line 55
				chan1 = -10;
#line 56
				chan2 = -10;
#line 57
				seg = b___0;
#line 57
				while (seg <= e) {
#line 58
					if ((int)(aNetSeg + seg)->current == 0) {
#line 59
						sptr = (aNetSeg + seg)->top;
					}
					else {
#line 61
						sptr = (aNetSeg + seg)->bot;
					}
#line 63
					if (pin == sptr->pin1) {
						goto _L;
					}
					else {
#line 63
						if (pin == sptr->pin2) {
						_L: /* CIL Label */
#line 64
							chan = sptr->channel;
#line 65
							if (chan1 < 0) {
#line 66
								chan1 = chan;
#line 67
								if (pin == sptr->pin1) {
#line 68
									pin2_1 = sptr->pin2;
								}
								else {
#line 70
									pin2_1 = sptr->pin1;
								}
							}
							else {
#line 72
								if (chan1 == chan) {
									goto __Cont___0;
								}
								else {
#line 74
									if (chan2 < 0) {
#line 75
										chan2 = chan;
#line 76
										if (pin == sptr->pin1) {
#line 77
											pin2_2 = sptr->pin2;
										}
										else {
#line 79
											pin2_2 = sptr->pin1;
										}
#line 81
										break;
									}
								}
							}
						}
					}
				__Cont___0: /* CIL Label */
#line 57
					seg++;
				}
#line 86
				if (netptr->cell <= numcells) {
#line 86
					if (pinloc != 0) {
						goto _L___4;
					}
					else {
						goto _L___5;
					}
				}
				else {
				_L___5: /* CIL Label */
#line 86
					if (netptr->cell > numcells) {
#line 86
						if ((*(carray + netptr->cell))->padside == 2) {
							goto _L___4;
						}
						else {
#line 86
							if ((*(carray + netptr->cell))->padside == 4) {
								goto _L___4;
							}
							else {
#line 86
								if ((*(carray + netptr->cell))->padside == 14) {
									goto _L___4;
								}
								else {
#line 86
									if ((*(carray + netptr->cell))->padside == 15) {
									_L___4: /* CIL Label */
#line 92
										if (netptr->cell > numcells) {
#line 93
											if ((*(carray + netptr->cell))->padside == 2) {
#line 95
												fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
													*(pinlist + pin), (*(carray + netptr->cell))->cname,
													*(pinnames + pin), x, y, chan1, 1);
											}
											else {
#line 93
												if ((*(carray + netptr->cell))->padside == 14) {
#line 95
													fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
														*(pinlist + pin), (*(carray + netptr->cell))->cname,
														*(pinnames + pin), x, y, chan1, 1);
												}
												else {
#line 99
													if ((*(carray + netptr->cell))->padside == 4) {
#line 101
														fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
															*(pinlist + pin), (*(carray + netptr->cell))->cname,
															*(pinnames + pin), x, y, chan1, -1);
													}
													else {
#line 99
														if ((*(carray + netptr->cell))->padside == 15) {
#line 101
															fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
																*(pinlist + pin), (*(carray + netptr->cell))->cname,
																*(pinnames + pin), x, y, chan1, -1);
														}
													}
												}
											}
										}
										else {
#line 107
											fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
												*(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
												x, y, chan1, pinloc);
										}
									}
									else {
										goto _L___3;
									}
								}
							}
						}
					}
					else {
					_L___3: /* CIL Label */
#line 112
						if (netptr->cell > numcells) {
#line 113
							if ((*(carray + netptr->cell))->padside == 1) {
								goto _L___1;
							}
							else {
#line 113
								if ((*(carray + netptr->cell))->padside == 5) {
									goto _L___1;
								}
								else {
#line 113
									if ((*(carray + netptr->cell))->padside == 9) {
										goto _L___1;
									}
									else {
#line 113
										if ((*(carray + netptr->cell))->padside == 7) {
										_L___1: /* CIL Label */
#line 118
											fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
												*(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
												x, y, -1, 1);
#line 123
											if ((*(carray + (*(tearray + pin2_1))->cell))->padside != 1) {
#line 123
												if ((*(carray + (*(tearray + pin2_1))->cell))->padside != 5) {
#line 123
													if ((*(carray + (*(tearray + pin2_1))->cell))->padside != 9) {
#line 123
														if ((*(carray + (*(tearray + pin2_1))->cell))->padside != 7) {
#line 128
															if ((*(carray + netptr->cell))->padside == 1) {
#line 129
																xx = l_core_edge;
															}
															else {
#line 131
																xx = min_l_chan_edge(chan1);
#line 132
																if ((*(tearray + pin2_1))->xpos < xx) {
#line 133
																	xx = x;
																}
															}
#line 136
															if (netptr->row == chan1) {
#line 137
																y = (*(barray + netptr->row))->bycenter - rowHeight;
															}
															else {
#line 140
																y = (*(barray + netptr->row))->bycenter + rowHeight;
															}
#line 143
															fprintf(fp, " %s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
																*(pinlist + pin), "PSEUDO_CELL", "PSEUDO_PIN",
																xx, y, chan1, -2);
#line 147
															fprintf(fp, " %s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
																*(pinlist + pin), "PSEUDO_CELL", "PSEUDO_PIN",
																xx, y, -1, -1);
#line 152
															if (chan2 > 0) {
#line 153
																if ((*(carray + (*(tearray + pin2_2))->cell))->padside != 1) {
#line 153
																	if ((*(carray + (*(tearray + pin2_2))->cell))->padside != 5) {
#line 153
																		if ((*(carray + (*(tearray + pin2_2))->cell))->padside != 9) {
#line 153
																			if ((*(carray + (*(tearray + pin2_2))->cell))->padside != 7) {
#line 162
																				if ((*(carray + netptr->cell))->padside == 1) {
#line 163
																					xx = l_core_edge;
																				}
																				else {
#line 165
																					xx = min_l_chan_edge(chan2);
#line 166
																					if ((*(tearray + pin2_2))->xpos < xx) {
#line 167
																						xx = x;
																					}
																				}
#line 170
																				if (netptr->row == chan2) {
#line 171
																					y = (*(barray + netptr->row))->bycenter - rowHeight;
																				}
																				else {
#line 174
																					y = (*(barray + netptr->row))->bycenter + rowHeight;
																				}
#line 177
																				fprintf(fp, " %s %d %s %s %d %d %d %d 0\n",
																					(*(netarray + net))->name, *(pinlist + pin),
																					"PSEUDO_CELL", "PSEUDO_PIN", xx, y,
																					chan2, -2);
#line 182
																				fprintf(fp, " %s %d %s %s %d %d %d %d 0\n",
																					(*(netarray + net))->name, *(pinlist + pin),
																					"PSEUDO_CELL", "PSEUDO_PIN", xx, y,
																					-1, -1);
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
										else {
#line 190
											if ((*(carray + netptr->cell))->padside == 3) {
												goto _L___0;
											}
											else {
#line 190
												if ((*(carray + netptr->cell))->padside == 6) {
													goto _L___0;
												}
												else {
#line 190
													if ((*(carray + netptr->cell))->padside == 10) {
														goto _L___0;
													}
													else {
#line 190
														if ((*(carray + netptr->cell))->padside == 8) {
														_L___0: /* CIL Label */
#line 195
															fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
																*(pinlist + pin), (*(carray + netptr->cell))->cname,
																*(pinnames + pin), x, y, -2, 1);
#line 199
															if ((*(carray + (*(tearray + pin2_1))->cell))->padside != 3) {
#line 199
																if ((*(carray + (*(tearray + pin2_1))->cell))->padside != 6) {
#line 199
																	if ((*(carray + (*(tearray + pin2_1))->cell))->padside != 10) {
#line 199
																		if ((*(carray + (*(tearray + pin2_1))->cell))->padside != 8) {
#line 204
																			if ((*(carray + netptr->cell))->padside == 3) {
#line 205
																				xx = r_core_edge;
																			}
																			else {
#line 207
																				xx = min_r_chan_edge(chan1);
#line 208
																				if ((*(tearray + pin2_1))->xpos > xx) {
#line 209
																					xx = x;
																				}
																			}
#line 212
																			if (netptr->row == chan1) {
#line 213
																				y = (*(barray + netptr->row))->bycenter - rowHeight;
																			}
																			else {
#line 216
																				y = (*(barray + netptr->row))->bycenter + rowHeight;
																			}
#line 219
																			fprintf(fp, " %s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
																				*(pinlist + pin), "PSEUDO_CELL", "PSEUDO_PIN",
																				xx, y, chan1, 2);
#line 223
																			fprintf(fp, " %s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
																				*(pinlist + pin), "PSEUDO_CELL", "PSEUDO_PIN",
																				xx, y, -2, -1);
#line 228
																			if (chan2 > 0) {
#line 229
																				if ((*(carray + (*(tearray + pin2_2))->cell))->padside != 3) {
#line 229
																					if ((*(carray + (*(tearray + pin2_2))->cell))->padside != 6) {
#line 229
																						if ((*(carray + (*(tearray + pin2_2))->cell))->padside != 10) {
#line 229
																							if ((*(carray + (*(tearray + pin2_2))->cell))->padside != 8) {
#line 237
																								if ((*(carray + netptr->cell))->padside == 3) {
#line 238
																									xx = r_core_edge;
																								}
																								else {
#line 240
																									xx = min_r_chan_edge(chan2);
#line 241
																									if ((*(tearray + pin2_2))->xpos > xx) {
#line 242
																										xx = x;
																									}
																								}
#line 245
																								if (netptr->row == chan2) {
#line 246
																									y = (*(barray + netptr->row))->bycenter - rowHeight;
																								}
																								else {
#line 249
																									y = (*(barray + netptr->row))->bycenter + rowHeight;
																								}
#line 252
																								fprintf(fp, " %s %d %s %s %d %d %d %d 0\n",
																									(*(netarray + net))->name, *(pinlist + pin),
																									"PSEUDO_CELL", "PSEUDO_PIN",
																									xx, y, chan2, 2);
#line 257
																								fprintf(fp, " %s %d %s %s %d %d %d %d 0\n",
																									(*(netarray + net))->name, *(pinlist + pin),
																									"PSEUDO_CELL", "PSEUDO_PIN",
																									xx, y, -2, -1);
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
						else {
#line 267
							if (chan1 == netptr->row) {
#line 268
								fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
									*(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
									x, y, chan1, 1);
							}
							else {
#line 275
								fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
									*(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
									x, y, chan1, -1);
							}
#line 282
							if (chan2 > 0) {
#line 283
								if (chan2 == netptr->row) {
#line 284
									fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
										*(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
										x, y, chan2, 1);
								}
								else {
#line 291
									fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
										*(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
										x, y, chan2, -1);
								}
							}
						}
					}
				}
			__Cont: /* CIL Label */
#line 43
				netptr = (struct netbox *)netptr->nterm;
			}
#line 41
			net++;
		}
#line 302
		twclose((int)fp);
#line 303
		return;
	}
}
#line 311 "outpins.c"
int min_r_chan_edge(int channel)
{
	int cell___0;
	int end;
	int end2;

	{
#line 316
		if (channel == 1) {
#line 317
			cell___0 = *(*(pairArray + 1) + *(*(pairArray + 1) + 0));
#line 318
			end = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->right;
		}
		else {
#line 319
			if (channel == numblock + 1) {
#line 320
				cell___0 = *(*(pairArray + numblock) + *(*(pairArray + numblock) + 0));
#line 321
				end = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->right;
			}
			else {
#line 323
				cell___0 = *(*(pairArray + (channel - 1)) + *(*(pairArray + (channel - 1)) + 0));
#line 324
				end = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->right;
#line 325
				cell___0 = *(*(pairArray + channel) + *(*(pairArray + channel) + 0));
#line 326
				end2 = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->right;
#line 327
				if (end < end2) {
#line 327
					end = end;
				}
				else {
#line 327
					end = end2;
				}
			}
		}
#line 329
		return (end);
	}
}
#line 334 "outpins.c"
int min_l_chan_edge(int channel)
{
	int cell___0;
	int end;
	int end2;

	{
#line 339
		if (channel == 1) {
#line 340
			cell___0 = *(*(pairArray + 1) + 1);
#line 341
			end = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->left;
		}
		else {
#line 342
			if (channel == numblock + 1) {
#line 343
				cell___0 = *(*(pairArray + numblock) + 1);
#line 344
				end = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->left;
			}
			else {
#line 346
				cell___0 = *(*(pairArray + (channel - 1)) + 1);
#line 347
				end = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->left;
#line 348
				cell___0 = *(*(pairArray + channel) + 1);
#line 349
				end2 = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->left;
#line 350
				if (end > end2) {
#line 350
					end = end;
				}
				else {
#line 350
					end = end2;
				}
			}
		}
#line 352
		return (end);
	}
}
#line 1 "output.o"
#pragma merger(0,"./output.i","")
#line 2 "output.c"
int comparex(int *a___0, int *b___0);
#line 9 "output.c"
void output(void)
{
	FILE *fpp1;
	FILE *fpp2;
	int locx;
	int locy;
	int height___0;
	int width___0;
	int xloc;
	int i;
	int cell___0;
	int block___0;
	int orient;
	int num;
	int xloc2;
	int yloc2;
	int yloc;
	int *array;
	int desire;
	int left___0;
	int right;
	int bottom;
	int top___0;
	int end;
	char filename[64];
	CBOXPTR cellptr___0;

	{
#line 23
		sprintf(filename, "%s.pl1", cktName);
#line 24
		fpp1 = twopen((int)(filename), (int)"w", 1);
#line 26
		sprintf(filename, "%s.pl2", cktName);
#line 27
		fpp2 = twopen((int)(filename), (int)"w", 1);
#line 29
		block___0 = 1;
#line 29
		while (block___0 <= numblock) {
#line 31
			left___0 = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bleft;
#line 32
			right = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bright;
#line 33
			bottom = (*(barray + block___0))->bycenter + (*(barray + block___0))->bbottom;
#line 34
			top___0 = (*(barray + block___0))->bycenter + (*(barray + block___0))->btop;
#line 36
			if (restart == 0) {
#line 36
				if (costonly == 1) {
#line 37
					desire = (*(barray + block___0))->desire;
				}
				else {
					goto _L;
				}
			}
			else {
			_L: /* CIL Label */
#line 39
				if (*(*(pairArray + block___0) + 0) > 0) {
#line 40
					cell___0 = *(*(pairArray + block___0) + *(*(pairArray + block___0) + 0));
#line 41
					end = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->right;
#line 43
					desire = end - left___0;
				}
				else {
#line 45
					desire = 0;
				}
			}
#line 49
			if ((*(barray + block___0))->borient > 0) {
#line 50
				fprintf(fpp2, "%d %d %d  %d %d  0 0\n", block___0, left___0, bottom, left___0 + desire,
					top___0);
			}
			else {
#line 53
				fprintf(fpp2, "%d %d %d  %d %d  0 0\n", block___0, left___0, bottom, right,
					bottom + desire);
			}
#line 57
			num = *(*(pairArray + block___0) + 0);
#line 58
			if (num == 0) {
				goto __Cont;
			}
#line 61
			array = *(pairArray + block___0) + 1;
#line 63
			i = 0;
#line 63
			while (i < num) {
#line 64
				cell___0 = *(array + i);
#line 65
				cellptr___0 = *(carray + cell___0);
#line 66
				orient = (int)cellptr___0->corient;
#line 68
				xloc = cellptr___0->cxcenter + (cellptr___0->tileptr)->left;
#line 69
				yloc = cellptr___0->cycenter + (cellptr___0->tileptr)->bottom;
#line 71
				xloc2 = (cellptr___0->tileptr)->right - (cellptr___0->tileptr)->left;
#line 73
				yloc2 = (cellptr___0->tileptr)->top - (cellptr___0->tileptr)->bottom;
#line 76
				fprintf(fpp1, "%s %d %d  %d %d  %d %d\n", cellptr___0->cname, xloc, yloc, xloc + xloc2,
					yloc + yloc2, orient, block___0);
#line 63
				i++;
			}
		__Cont: /* CIL Label */
#line 29
			block___0++;
		}
#line 84
		i = numcells + 1;
#line 84
		while (i <= numcells + numterms) {
#line 85
			cellptr___0 = *(carray + i);
#line 86
			orient = (int)cellptr___0->corient;
#line 88
			locx = cellptr___0->cxcenter + (cellptr___0->tileptr)->left;
#line 89
			locy = cellptr___0->cycenter + (cellptr___0->tileptr)->bottom;
#line 91
			height___0 = (cellptr___0->tileptr)->top - (cellptr___0->tileptr)->bottom;
#line 92
			width___0 = (cellptr___0->tileptr)->right - (cellptr___0->tileptr)->left;
#line 94
			fprintf(fpp1, "%s %d %d  %d %d  %d 0\n", cellptr___0->cname, locx, locy, locx + width___0,
				locy + height___0, orient);
#line 97
			fprintf(fpp2, "%s %d %d  %d %d  %d 0\n", cellptr___0->cname, locx, locy, locx + width___0,
				locy + height___0, orient);
#line 84
			i++;
		}
#line 101
		twclose((int)fpp1);
#line 102
		twclose((int)fpp2);
#line 103
		return;
	}
}
#line 109 "output.c"
int comparex(int *a___0, int *b___0)
{

	{
#line 112
		return ((*(carray + *a___0))->cxcenter - (*(carray + *b___0))->cxcenter);
	}
}
#line 1 "parser.o"
#pragma merger(0,"./parser.i","")
#line 3 "parser.c"
int celllen;
#line 7 "parser.c"
int *fixLRBT;
#line 8 "parser.c"
float *padspace;
#line 10 "parser.c"
void parser(FILE *fp)
{
	DBOXPTR nptr;
	int cell___0;
	int test;
	int layer;
	int block___0;
	int left___0;
	int right;
	int bottom;
	int top___0;
	int xpos;
	int ypos;
	int orient;
	int from;
	int orderchk;
	int length;
	int terms;
	int term;
	int i;
	int pinctr;
	float space___0;
	char input[1024];
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	int tmp___7;
	int tmp___8;
	int tmp___9;
	int tmp___10;
	int tmp___11;
	int tmp___12;
	int tmp___13;
	int tmp___14;
	int tmp___15;
	int tmp___16;
	int tmp___17;
	int tmp___18;
	int tmp___19;
	int tmp___20;
	int tmp___21;
	int tmp___22;
	int tmp___23;
	int tmp___24;
	int tmp___25;
	int tmp___26;
	int tmp___27;
	int tmp___28;
	int tmp___29;
	int tmp___30;
	int tmp___31;
	int tmp___32;
	char *tmp___33;
	char *tmp___34;
	char *tmp___35;
	DBOXPTR tmp___36;
	char *tmp___37;
	char *tmp___38;

	{
#line 24
		celllen = 0;
#line 25
		cell___0 = 0;
#line 26
		terms = 0;
#line 27
		pinctr = 0;
#line 29
		maketabl();
#line 33
		while (1) {
#line 33
			tmp___32 = fscanf(fp, " %s ", input);
#line 33
			if (!(tmp___32 == 1)) {
#line 33
				break;
			}
#line 35
			tmp___31 = strcmp((char const   *)(input), "cell");
#line 35
			if (tmp___31 == 0) {
#line 36
				cell___0++;
#line 37
				orderchk = 0;
#line 38
				test = fscanf(fp, " %s ", input);
#line 39
				if (test != 1) {
#line 40
					fprintf(fpo, "Failed to input dummy cell number/name ");
#line 41
					fprintf(fpo, "in the .cel file\n");
#line 42
					fprintf(fpo, "Current cell: %d\n", cell___0);
#line 43
					exit(1);
				}
#line 45
				fscanf(fp, " %s ", input);
			}
			else {
#line 47
				tmp___30 = strcmp((char const   *)(input), "left");
#line 47
				if (tmp___30 == 0) {
#line 48
					test = fscanf(fp, " %d ", &left___0);
#line 49
					if (test != 1) {
#line 50
						fprintf(fpo, "Failed to input left ");
#line 51
						fprintf(fpo, "in the .cel file\n");
#line 52
						fprintf(fpo, "Current cell: %d\n", cell___0);
#line 53
						exit(1);
					}
#line 55
					fscanf(fp, " %s ", input);
#line 56
					tmp = strcmp((char const   *)(input), "right");
#line 56
					if (tmp == 0) {
#line 57
						test = fscanf(fp, " %d ", &right);
#line 58
						if (test != 1) {
#line 59
							fprintf(fpo, "Failed to input right ");
#line 60
							fprintf(fpo, "in the .cel file\n");
#line 61
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 62
							exit(1);
						}
					}
					else {
#line 65
						fprintf(fpo, "Failed to find keyword right ");
#line 66
						fprintf(fpo, "for a cell\n");
#line 67
						fprintf(fpo, "Current cell: %d\n", cell___0);
#line 68
						exit(1);
					}
#line 70
					fscanf(fp, " %s ", input);
#line 71
					tmp___0 = strcmp((char const   *)(input), "bottom");
#line 71
					if (tmp___0 == 0) {
#line 72
						test = fscanf(fp, " %d ", &bottom);
#line 73
						if (test != 1) {
#line 74
							fprintf(fpo, "Failed to input bottom ");
#line 75
							fprintf(fpo, "in the .cel file\n");
#line 76
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 77
							exit(1);
						}
					}
					else {
#line 80
						fprintf(fpo, "Failed to find keyword bottom ");
#line 81
						fprintf(fpo, "for a cell\n");
#line 82
						fprintf(fpo, "Current cell: %d\n", cell___0);
#line 83
						exit(1);
					}
#line 85
					fscanf(fp, " %s ", input);
#line 86
					tmp___1 = strcmp((char const   *)(input), "top");
#line 86
					if (tmp___1 == 0) {
#line 87
						test = fscanf(fp, " %d ", &top___0);
#line 88
						if (test != 1) {
#line 89
							fprintf(fpo, "Failed to input top ");
#line 90
							fprintf(fpo, "in the .cel file\n");
#line 91
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 92
							exit(1);
						}
					}
					else {
#line 95
						fprintf(fpo, "Failed to find keyword top ");
#line 96
						fprintf(fpo, "for a cell\n");
#line 97
						fprintf(fpo, "Current cell: %d\n", cell___0);
#line 98
						exit(1);
					}
#line 100
					if (right + left___0 != 0) {
#line 100
						if (right + left___0 != 1) {
#line 101
							fprintf(fpo, "The given center of the cell ");
#line 102
							fprintf(fpo, "is not (right + left) div 2\n");
#line 103
							fprintf(fpo, "Where the remainder is truncated\n");
#line 104
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 105
							exit(1);
						}
						else {
							goto _L;
						}
					}
					else {
					_L: /* CIL Label */
#line 100
						if (left___0 > 0) {
#line 101
							fprintf(fpo, "The given center of the cell ");
#line 102
							fprintf(fpo, "is not (right + left) div 2\n");
#line 103
							fprintf(fpo, "Where the remainder is truncated\n");
#line 104
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 105
							exit(1);
						}
					}
#line 107
					if (top___0 + bottom != 0) {
#line 107
						if (top___0 + bottom != 1) {
#line 108
							fprintf(fpo, "The given center of the cell ");
#line 109
							fprintf(fpo, "is not (top + bottom) div 2\n");
#line 110
							fprintf(fpo, "Where the remainder is truncated\n");
#line 111
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 112
							exit(1);
						}
						else {
							goto _L___0;
						}
					}
					else {
					_L___0: /* CIL Label */
#line 107
						if (bottom > 0) {
#line 108
							fprintf(fpo, "The given center of the cell ");
#line 109
							fprintf(fpo, "is not (top + bottom) div 2\n");
#line 110
							fprintf(fpo, "Where the remainder is truncated\n");
#line 111
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 112
							exit(1);
						}
					}
#line 114
					length = right - left___0;
#line 115
					celllen += length;
				}
				else {
#line 117
					tmp___29 = strcmp((char const   *)(input), "initially");
#line 117
					if (tmp___29 == 0) {
#line 118
						if (orderchk != 0) {
#line 119
							fprintf(fpo, "cannot preplace fixed sequence\n");
#line 120
							fprintf(fpo, "in the .cel file\n");
#line 121
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 122
							exit(1);
						}
#line 124
						orderchk = 1;
#line 125
						fscanf(fp, " %s ", input);
#line 126
						tmp___3 = strcmp((char const   *)(input), "fixed");
#line 126
						if (!(tmp___3 == 0)) {
#line 127
							tmp___2 = strcmp((char const   *)(input), "nonfixed");
#line 127
							if (!(tmp___2 == 0)) {
#line 129
								fprintf(fpo, "Failed to find fixed or nonfixed\n");
#line 130
								fprintf(fpo, "Current cell: %d\n", cell___0);
#line 131
								exit(1);
							}
						}
#line 133
						test = fscanf(fp, " %d ", &from);
#line 134
						if (test != 1) {
#line 135
							fprintf(fpo, "Failed to input amount from following ");
#line 136
							fprintf(fpo, "(fixed,nonfixed) in the .cel file");
#line 137
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 138
							exit(1);
						}
#line 140
						fscanf(fp, " %s ", input);
#line 141
						tmp___4 = strcmp((char const   *)(input), "from");
#line 141
						if (tmp___4 != 0) {
#line 142
							fprintf(fpo, "Failed to find keyword from ");
#line 143
							fprintf(fpo, "in the .cel file");
#line 144
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 145
							exit(1);
						}
#line 147
						fscanf(fp, " %s ", input);
#line 148
						tmp___6 = strcmp((char const   *)(input), "left");
#line 148
						if (!(tmp___6 == 0)) {
#line 149
							tmp___5 = strcmp((char const   *)(input), "right");
#line 149
							if (!(tmp___5 == 0)) {
#line 151
								fprintf(fpo, "Failed to find left or right\n");
#line 152
								fprintf(fpo, "following from in the .cel file");
#line 153
								fprintf(fpo, "Current cell: %d\n", cell___0);
#line 154
								exit(1);
							}
						}
#line 156
						fscanf(fp, " %s ", input);
#line 157
						tmp___7 = strcmp((char const   *)(input), "of");
#line 157
						if (tmp___7 != 0) {
#line 158
							fprintf(fpo, "Failed to find keyword of ");
#line 159
							fprintf(fpo, "in the .cel file");
#line 160
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 161
							exit(1);
						}
#line 163
						fscanf(fp, " %s ", input);
#line 164
						tmp___8 = strcmp((char const   *)(input), "block");
#line 164
						if (tmp___8 != 0) {
#line 165
							fprintf(fpo, "Failed to find keyword block ");
#line 166
							fprintf(fpo, "in the .cel file");
#line 167
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 168
							exit(1);
						}
#line 170
						test = fscanf(fp, " %d ", &block___0);
#line 171
						if (test != 1) {
#line 172
							fprintf(fpo, "Failed to input amount from following ");
#line 173
							fprintf(fpo, "(fixed,nonfixed) in the .cel file");
#line 174
							fprintf(fpo, "Current cell: %d\n", cell___0);
#line 175
							exit(1);
						}
					}
					else {
#line 178
						tmp___28 = strcmp((char const   *)(input), "nomirror");
#line 178
						if (!(tmp___28 == 0)) {
#line 179
							tmp___27 = strcmp((char const   *)(input), "pin");
#line 179
							if (tmp___27 == 0) {
#line 180
								fscanf(fp, " %s ", input);
#line 181
								tmp___9 = strcmp((char const   *)(input), "name");
#line 181
								if (tmp___9 != 0) {
#line 182
									fprintf(fpo, "Failed to find keyword name ");
#line 183
									fprintf(fpo, "for a pin\n");
#line 184
									fprintf(fpo, "Current cell: %d\n", cell___0);
#line 185
									exit(1);
								}
#line 187
								test = fscanf(fp, " %s ", input);
#line 188
								if (test != 1) {
#line 189
									fprintf(fpo, "Failed to input pin name ");
#line 190
									fprintf(fpo, "in the .cel file\n");
#line 191
									fprintf(fpo, "Current cell: %d\n", cell___0);
#line 192
									exit(1);
								}
#line 194
								fscanf(fp, " %s ", input);
#line 195
								tmp___10 = strcmp((char const   *)(input), "signal");
#line 195
								if (tmp___10 != 0) {
#line 196
									fprintf(fpo, "Failed to find keyword signal ");
#line 197
									fprintf(fpo, "for a pin\n");
#line 198
									fprintf(fpo, "Current cell: %d\n", cell___0);
#line 199
									exit(1);
								}
#line 201
								test = fscanf(fp, " %s ", input);
#line 202
								if (test != 1) {
#line 203
									fprintf(fpo, "Failed to input signal name ");
#line 204
									fprintf(fpo, "in the .cel file\n");
#line 205
									fprintf(fpo, "Current cell: %d\n", cell___0);
#line 206
									exit(1);
								}
#line 208
								tmp___11 = strcmp((char const   *)(input), "TW_PASS_THRU");
#line 208
								if (tmp___11 != 0) {
#line 209
									addhash(input);
#line 210
									pinctr++;
								}
#line 212
								if (pin_layers_given != 0) {
#line 213
									fscanf(fp, " %s ", input);
#line 214
									tmp___12 = strcmp((char const   *)(input), "layer");
#line 214
									if (tmp___12 != 0) {
#line 215
										fprintf(fpo, "Failed to find keyword layer ");
#line 216
										fprintf(fpo, "for a pin\n");
#line 217
										fprintf(fpo, "Current cell: %d\n", cell___0);
#line 218
										exit(1);
									}
#line 220
									test = fscanf(fp, " %d ", &layer);
#line 221
									if (test != 1) {
#line 222
										fprintf(fpo, "Failed to input layer number ");
#line 223
										fprintf(fpo, "in the .cel file\n");
#line 224
										fprintf(fpo, "Current cell: %d\n", cell___0);
#line 225
										exit(1);
									}
#line 227
									if (layer != 1) {
#line 227
										if (layer != 2) {
#line 227
											if (layer != 3) {
#line 228
												fprintf(fpo, "Currently, a layer number ");
#line 229
												fprintf(fpo, "in the .cel file must be either 1, 2,\n");
#line 230
												fprintf(fpo, "or 3.   Current cell: %d\n", cell___0);
#line 231
												exit(1);
											}
										}
									}
								}
#line 234
								test = fscanf(fp, " %d %d ", &xpos, &ypos);
#line 235
								if (test != 2) {
#line 236
									fprintf(fpo, "Failed to input 2 items ");
#line 237
									fprintf(fpo, "for pin in the .cel file\n");
#line 238
									fprintf(fpo, "Current cell: %d\n", cell___0);
#line 239
									exit(1);
								}
							}
							else {
#line 242
								tmp___26 = strcmp((char const   *)(input), "equiv");
#line 242
								if (tmp___26 == 0) {
#line 243
									fscanf(fp, " %s ", input);
#line 244
									tmp___13 = strcmp((char const   *)(input), "name");
#line 244
									if (tmp___13 != 0) {
#line 245
										fprintf(fpo, "Failed to find keyword name ");
#line 246
										fprintf(fpo, "for an equiv pin\n");
#line 247
										fprintf(fpo, "Current cell: %d\n", cell___0);
#line 248
										exit(1);
									}
#line 250
									test = fscanf(fp, " %s ", input);
#line 251
									if (test != 1) {
#line 252
										fprintf(fpo, "Failed to input equiv pin name ");
#line 253
										fprintf(fpo, "in the .cel file\n");
#line 254
										fprintf(fpo, "Current cell: %d\n", cell___0);
#line 255
										exit(1);
									}
#line 257
									if (pin_layers_given != 0) {
#line 258
										fscanf(fp, " %s ", input);
#line 259
										tmp___14 = strcmp((char const   *)(input), "layer");
#line 259
										if (tmp___14 != 0) {
#line 260
											fprintf(fpo, "Failed to find keyword layer ");
#line 261
											fprintf(fpo, "for an equiv pin\n");
#line 262
											fprintf(fpo, "Current cell: %d\n", cell___0);
#line 263
											exit(1);
										}
#line 265
										test = fscanf(fp, " %d ", &layer);
#line 266
										if (test != 1) {
#line 267
											fprintf(fpo, "Failed to input layer number ");
#line 268
											fprintf(fpo, "in the .cel file\n");
#line 269
											fprintf(fpo, "Current cell: %d\n", cell___0);
#line 270
											exit(1);
										}
#line 272
										if (layer != 1) {
#line 272
											if (layer != 2) {
#line 272
												if (layer != 3) {
#line 273
													fprintf(fpo, "Currently, a layer number ");
#line 274
													fprintf(fpo, "in the .cel file must be either 1, 2,\n");
#line 275
													fprintf(fpo, "or 3.   Current cell: %d\n", cell___0);
#line 276
													exit(1);
												}
											}
										}
									}
#line 279
									test = fscanf(fp, " %d %d ", &xpos, &ypos);
#line 280
									if (test != 2) {
#line 281
										fprintf(fpo, "Failed to input 2 items ");
#line 282
										fprintf(fpo, "for equiv in the .cel file\n");
#line 283
										fprintf(fpo, "Current cell: %d\n", cell___0);
#line 284
										exit(1);
									}
								}
								else {
#line 286
									tmp___25 = strcmp((char const   *)(input), "unequiv");
#line 286
									if (tmp___25 == 0) {
#line 287
										fscanf(fp, " %s ", input);
#line 288
										tmp___15 = strcmp((char const   *)(input), "name");
#line 288
										if (tmp___15 != 0) {
#line 289
											fprintf(fpo, "Failed to find keyword name ");
#line 290
											fprintf(fpo, "for an unequiv pin\n");
#line 291
											fprintf(fpo, "Current cell: %d\n", cell___0);
#line 292
											exit(1);
										}
#line 294
										test = fscanf(fp, " %s ", input);
#line 295
										if (test != 1) {
#line 296
											fprintf(fpo, "Failed to input unequiv pin name ");
#line 297
											fprintf(fpo, "in the .cel file\n");
#line 298
											fprintf(fpo, "Current cell: %d\n", cell___0);
#line 299
											exit(1);
										}
#line 301
										if (pin_layers_given != 0) {
#line 302
											fscanf(fp, " %s ", input);
#line 303
											tmp___16 = strcmp((char const   *)(input), "layer");
#line 303
											if (tmp___16 != 0) {
#line 304
												fprintf(fpo, "Failed to find keyword layer ");
#line 305
												fprintf(fpo, "for an unequiv pin\n");
#line 306
												fprintf(fpo, "Current cell: %d\n", cell___0);
#line 307
												exit(1);
											}
#line 309
											test = fscanf(fp, " %d ", &layer);
#line 310
											if (test != 1) {
#line 311
												fprintf(fpo, "Failed to input layer number ");
#line 312
												fprintf(fpo, "in the .cel file\n");
#line 313
												fprintf(fpo, "Current cell: %d\n", cell___0);
#line 314
												exit(1);
											}
#line 316
											if (layer != 1) {
#line 316
												if (layer != 2) {
#line 316
													if (layer != 3) {
#line 317
														fprintf(fpo, "Currently, a layer number ");
#line 318
														fprintf(fpo, "in the .cel file must be either 1, 2,\n");
#line 319
														fprintf(fpo, "or 3.   Current cell: %d\n", cell___0);
#line 320
														exit(1);
													}
												}
											}
										}
#line 323
										test = fscanf(fp, " %d %d ", &xpos, &ypos);
#line 324
										if (test != 2) {
#line 325
											fprintf(fpo, "Failed to input 2 items ");
#line 326
											fprintf(fpo, "for unequiv in the .cel file\n");
#line 327
											fprintf(fpo, "Current cell: %d\n", cell___0);
#line 328
											exit(1);
										}
									}
									else {
#line 330
										tmp___24 = strcmp((char const   *)(input), "pad");
#line 330
										if (tmp___24 == 0) {
#line 331
											terms++;
#line 332
											test = fscanf(fp, " %s ", input);
#line 333
											if (test != 1) {
#line 334
												fprintf(fpo, "Failed to input dummy pad number/name ");
#line 335
												fprintf(fpo, "in the .cel file\n");
#line 336
												fprintf(fpo, "Current cell: %d\n", cell___0);
#line 337
												exit(1);
											}
#line 339
											fscanf(fp, " %s ", input);
#line 341
											fscanf(fp, " %s ", input);
#line 342
											tmp___17 = strcmp((char const   *)(input), "orient");
#line 342
											if (tmp___17 == 0) {
#line 343
												test = fscanf(fp, " %d ", &orient);
#line 344
												if (test != 1) {
#line 345
													fprintf(fpo, "Failed to input orient ");
#line 346
													fprintf(fpo, "in the .cel file\n");
#line 347
													fprintf(fpo, "Current cell: %d\n", cell___0);
#line 348
													exit(1);
												}
											}
											else {
#line 351
												fprintf(fpo, "Failed to find keyword orient ");
#line 352
												fprintf(fpo, "for a pad\n");
#line 353
												fprintf(fpo, "Current cell: %d\n", cell___0);
#line 354
												exit(1);
											}
#line 357
											fscanf(fp, " %s ", input);
#line 358
											tmp___18 = strcmp((char const   *)(input), "padside");
#line 358
											if (tmp___18 == 0) {
#line 359
												test = fscanf(fp, " %s ", input);
#line 360
												if (test != 1) {
#line 361
													fprintf(fpo, "Failed to input padside ");
#line 362
													fprintf(fpo, "in the .cel file\n");
#line 363
													fprintf(fpo, "Current cell: %d\n", cell___0);
#line 364
													exit(1);
												}
											}
											else {
#line 367
												fprintf(fpo, "Failed to find keyword padside ");
#line 368
												fprintf(fpo, "for a pad\n");
#line 369
												fprintf(fpo, "Current cell: %d\n", cell___0);
#line 370
												exit(1);
											}
#line 372
											fscanf(fp, " %s ", input);
#line 373
											tmp___19 = strcmp((char const   *)(input), "left");
#line 373
											if (tmp___19 == 0) {
#line 374
												test = fscanf(fp, " %d ", &left___0);
#line 375
												if (test != 1) {
#line 376
													fprintf(fpo, "Failed to input left ");
#line 377
													fprintf(fpo, "in the .cel file\n");
#line 378
													fprintf(fpo, "Current cell: %d\n", cell___0);
#line 379
													exit(1);
												}
											}
											else {
#line 382
												fprintf(fpo, "Failed to find keyword left ");
#line 383
												fprintf(fpo, "for a pad\n");
#line 384
												fprintf(fpo, "Current cell: %d\n", cell___0);
#line 385
												exit(1);
											}
#line 387
											fscanf(fp, " %s ", input);
#line 388
											tmp___20 = strcmp((char const   *)(input), "right");
#line 388
											if (tmp___20 == 0) {
#line 389
												test = fscanf(fp, " %d ", &right);
#line 390
												if (test != 1) {
#line 391
													fprintf(fpo, "Failed to input right ");
#line 392
													fprintf(fpo, "in the .cel file\n");
#line 393
													fprintf(fpo, "Current cell: %d\n", cell___0);
#line 394
													exit(1);
												}
											}
											else {
#line 397
												fprintf(fpo, "Failed to find keyword right ");
#line 398
												fprintf(fpo, "for a pad\n");
#line 399
												fprintf(fpo, "Current cell: %d\n", cell___0);
#line 400
												exit(1);
											}
#line 402
											if (right + left___0 != 0) {
#line 402
												if (right + left___0 != 1) {
#line 403
													fprintf(fpo, "The given center of the cell ");
#line 404
													fprintf(fpo, "is not (right + left) div 2\n");
#line 405
													fprintf(fpo, "Where the remainder is truncated\n");
#line 406
													fprintf(fpo, "Current cell: %d\n", cell___0);
#line 407
													exit(1);
												}
											}
#line 409
											fscanf(fp, " %s ", input);
#line 410
											tmp___21 = strcmp((char const   *)(input), "bottom");
#line 410
											if (tmp___21 == 0) {
#line 411
												test = fscanf(fp, " %d ", &bottom);
#line 412
												if (test != 1) {
#line 413
													fprintf(fpo, "Failed to input bottom ");
#line 414
													fprintf(fpo, "in the .cel file\n");
#line 415
													fprintf(fpo, "Current cell: %d\n", cell___0);
#line 416
													exit(1);
												}
											}
											else {
#line 419
												fprintf(fpo, "Failed to find keyword bottom ");
#line 420
												fprintf(fpo, "for a pad\n");
#line 421
												fprintf(fpo, "Current cell: %d\n", cell___0);
#line 422
												exit(1);
											}
#line 424
											fscanf(fp, " %s ", input);
#line 425
											tmp___22 = strcmp((char const   *)(input), "top");
#line 425
											if (tmp___22 == 0) {
#line 426
												test = fscanf(fp, " %d ", &top___0);
#line 427
												if (test != 1) {
#line 428
													fprintf(fpo, "Failed to input top ");
#line 429
													fprintf(fpo, "in the .cel file\n");
#line 430
													fprintf(fpo, "Current cell: %d\n", cell___0);
#line 431
													exit(1);
												}
											}
											else {
#line 434
												fprintf(fpo, "Failed to find keyword top ");
#line 435
												fprintf(fpo, "for a pad\n");
#line 436
												fprintf(fpo, "Current cell: %d\n", cell___0);
#line 437
												exit(1);
											}
#line 439
											if (top___0 + bottom != 0) {
#line 439
												if (top___0 + bottom != 1) {
#line 440
													fprintf(fpo, "The given center of the cell ");
#line 441
													fprintf(fpo, "is not (top + bottom) div 2\n");
#line 442
													fprintf(fpo, "Where the remainder is truncated\n");
#line 443
													fprintf(fpo, "Current cell: %d\n", cell___0);
#line 444
													exit(1);
												}
											}
										}
										else {
#line 446
											tmp___23 = strcmp((char const   *)(input), "sidespace");
#line 446
											if (tmp___23 == 0) {
#line 447
												test = fscanf(fp, " %f ", &space___0);
											}
											else {
#line 449
												fprintf(fpo, "Found unparsable keyword in ");
#line 450
												fprintf(fpo, "the .cel file\n");
#line 451
												fprintf(fpo, "Current cell: %d\n", cell___0);
#line 452
												exit(1);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
#line 455
		rewind(fp);
#line 457
		numcells = cell___0;
#line 458
		numterms = terms;
#line 459
		tmp___33 = safe_malloc((unsigned int)(numterms + 1) * sizeof(float));
#line 459
		padspace = (float *)tmp___33;
#line 460
		i = 1;
#line 460
		while (i <= numterms) {
#line 461
			* (padspace + i) = (float)0.0;
#line 460
			i++;
		}
#line 463
		tmp___34 = safe_malloc(4U * sizeof(int));
#line 463
		fixLRBT = (int *)tmp___34;
#line 464
		* (fixLRBT + 0) = 0;
#line 465
		* (fixLRBT + 1) = 0;
#line 466
		* (fixLRBT + 2) = 0;
#line 467
		* (fixLRBT + 3) = 0;
#line 469
		tmp___35 = safe_malloc((unsigned int)(netctr + 1) * sizeof(DBOXPTR));
#line 469
		netarray = (DBOXPTR *)tmp___35;
#line 471
		i = 1;
#line 471
		while (i <= netctr) {
#line 473
			tmp___37 = safe_malloc(sizeof(DBOX));
#line 473
			tmp___36 = (struct dimbox *)tmp___37;
#line 473
			* (netarray + i) = tmp___36;
#line 473
			nptr = tmp___36;
#line 475
			nptr->netptr = (struct netbox *)((void *)0);
#line 476
			nptr->name = (char *)((void *)0);
#line 477
			nptr->dflag = (char)0;
#line 478
			nptr->xmin = 0;
#line 479
			nptr->newxmin = 0;
#line 480
			nptr->xmax = 0;
#line 481
			nptr->newxmax = 0;
#line 482
			nptr->ymin = 0;
#line 483
			nptr->newymin = 0;
#line 484
			nptr->ymax = 0;
#line 485
			nptr->newymax = 0;
#line 486
			nptr->Hweight = (float)1.0;
#line 487
			nptr->Vweight = (float)1.0;
#line 488
			nptr->feedflag = (char)0;
#line 489
			nptr->ignore = (char)0;
#line 471
			i++;
		}
#line 491
		numnets = netctr;
#line 493
		tmp___38 = safe_malloc((unsigned int)(pinctr + 1) * sizeof(NBOXPTR));
#line 493
		tearray = (NBOXPTR *)tmp___38;
#line 494
		term = 1;
#line 494
		while (term <= pinctr) {
#line 495
			* (tearray + term) = (struct netbox *)((void *)0);
#line 494
			term++;
		}
#line 497
		maxterm = pinctr;
#line 499
		return;
	}
}
#line 1 "purcost.o"
#pragma merger(0,"./purcost.i","")
#line 5 "purcost.c"
int purcost(int segment)
{
	SEGBOXPTR top___0;
	SEGBOXPTR bot___0;
	SEGBOXPTR asegptr;
	SEGBOXPTR bsegptr;
	CHANGRDPTR aptr1;
	CHANGRDPTR aptr2;
	CHANGRDPTR bptr1;
	CHANGRDPTR bptr2;
	CHANGRDPTR bptr;
	CHANGRDPTR fptr;
	CHANGRDPTR ptr;
	CHANGRDPTR saptr;
	CHANGRDPTR eaptr;
	CHANGRDPTR sbptr;
	CHANGRDPTR ebptr;
	DENSITYPTR denptr;
	DENSITYPTR headptr;
	int penalty___0;
	int current;
	int check;
	int x;
	int achannel;
	int bchannel;
	int aMaxVal;
	int bMaxVal;
	int maxaa;
	int maxbb;
	int aoutside;
	int binside;
	int ax1;
	int ax2;
	int bx1;
	int bx2;
	int net;
	int Flag;
	int track;

	{
#line 19
		penalty___0 = 0;
#line 21
		if ((int)(aNetSeg + segment)->nflag == 0) {
#line 22
			top___0 = (aNetSeg + segment)->top;
#line 23
			bot___0 = (aNetSeg + segment)->bot;
#line 24
			current = (int)(aNetSeg + segment)->current;
		}
		else {
#line 26
			top___0 = (aNetSeg + segment)->ntop;
#line 27
			bot___0 = (aNetSeg + segment)->nbot;
#line 28
			current = (int)(aNetSeg + segment)->ncurrent;
		}
#line 30
		if (current == 0) {
#line 31
			asegptr = top___0;
#line 32
			bsegptr = bot___0;
		}
		else {
#line 34
			asegptr = bot___0;
#line 35
			bsegptr = top___0;
		}
#line 37
		achannel = asegptr->channel;
#line 38
		bchannel = bsegptr->channel;
#line 39
		aptr1 = asegptr->pin1ptr;
#line 40
		aptr2 = asegptr->pin2ptr;
#line 41
		bptr1 = bsegptr->pin1ptr;
#line 42
		bptr2 = bsegptr->pin2ptr;
#line 44
		aMaxVal = *(nmaxTrack + achannel);
#line 45
		bMaxVal = *(nmaxTrack + bchannel);
#line 46
		ax1 = (aptr1->netptr)->xpos;
#line 47
		ax2 = (aptr2->netptr)->xpos;
#line 48
		bx1 = (bptr1->netptr)->xpos;
#line 49
		bx2 = (bptr2->netptr)->xpos;
#line 50
		net = (aNetSeg + segment)->net;
#line 52
		if (aptr1->nSegType > 0) {
#line 53
			Flag = 0;
#line 54
			bptr = aptr1;
#line 55
			while (1) {
#line 55
				if ((unsigned int)bptr->nprevgrd != (unsigned int)((void *)0)) {
#line 55
					if (!(((bptr->nprevgrd)->netptr)->xpos == ax1)) {
#line 55
						break;
					}
				}
				else {
#line 55
					break;
				}
#line 57
				if (net == (*(tearray + ((bptr->nprevgrd)->netptr)->terminal))->net) {
#line 57
					if ((bptr->nprevgrd)->nSegType < 0) {
#line 59
						Flag = 1;
#line 60
						saptr = (struct changrdbox *)aptr1->nnextgrd;
#line 61
						while ((saptr->netptr)->xpos == ax1) {
#line 62
							saptr = (struct changrdbox *)saptr->nnextgrd;
						}
#line 64
						break;
					}
					else {
#line 66
						bptr = (struct changrdbox *)bptr->nprevgrd;
					}
				}
				else {
#line 66
					bptr = (struct changrdbox *)bptr->nprevgrd;
				}
			}
#line 69
			if (!Flag) {
#line 70
				saptr = (struct changrdbox *)aptr1->nnextgrd;
#line 71
				while ((saptr->netptr)->xpos == ax1) {
#line 72
					if (net == (*(tearray + (saptr->netptr)->terminal))->net) {
#line 72
						if (saptr->nSegType < 0) {
#line 74
							Flag = 1;
						}
					}
#line 76
					saptr = (struct changrdbox *)saptr->nnextgrd;
				}
			}
#line 79
			if (!Flag) {
#line 80
				saptr = bptr;
			}
		}
		else {
#line 83
			if (ax1 != gxstart) {
#line 84
				saptr = (struct changrdbox *)aptr1->nnextgrd;
#line 85
				while ((saptr->netptr)->xpos == ax1) {
#line 86
					saptr = (struct changrdbox *)saptr->nnextgrd;
				}
			}
			else {
#line 89
				saptr = aptr1;
			}
		}
#line 93
		if (aptr2->nSegType < 0) {
#line 94
			Flag = 0;
#line 95
			fptr = aptr2;
#line 96
			while (1) {
#line 96
				if ((unsigned int)fptr->nnextgrd != (unsigned int)((void *)0)) {
#line 96
					if (!(((fptr->nnextgrd)->netptr)->xpos == ax2)) {
#line 96
						break;
					}
				}
				else {
#line 96
					break;
				}
#line 98
				if (net == (*(tearray + ((fptr->nnextgrd)->netptr)->terminal))->net) {
#line 98
					if ((fptr->nnextgrd)->nSegType > 0) {
#line 100
						Flag = 1;
#line 101
						eaptr = (struct changrdbox *)aptr2->nprevgrd;
#line 102
						while ((eaptr->netptr)->xpos == ax2) {
#line 103
							eaptr = (struct changrdbox *)eaptr->nprevgrd;
						}
#line 105
						break;
					}
					else {
#line 107
						fptr = (struct changrdbox *)fptr->nnextgrd;
					}
				}
				else {
#line 107
					fptr = (struct changrdbox *)fptr->nnextgrd;
				}
			}
#line 110
			if (!Flag) {
#line 111
				eaptr = (struct changrdbox *)aptr2->nprevgrd;
#line 112
				while ((eaptr->netptr)->xpos == ax2) {
#line 113
					if (net == (*(tearray + (eaptr->netptr)->terminal))->net) {
#line 113
						if (eaptr->nSegType > 0) {
#line 115
							Flag = 1;
						}
					}
#line 117
					eaptr = (struct changrdbox *)eaptr->nprevgrd;
				}
			}
#line 120
			if (!Flag) {
#line 121
				eaptr = fptr;
			}
		}
		else {
#line 124
			if (ax2 != gxstop) {
#line 125
				eaptr = (struct changrdbox *)aptr2->nprevgrd;
#line 126
				while ((eaptr->netptr)->xpos == ax2) {
#line 127
					eaptr = (struct changrdbox *)eaptr->nprevgrd;
				}
			}
			else {
#line 130
				eaptr = aptr2;
			}
		}
#line 134
		if (bptr1->nSegType >= 0) {
#line 135
			Flag = 0;
#line 136
			bptr = bptr1;
#line 137
			while (1) {
#line 137
				if ((unsigned int)bptr->nprevgrd != (unsigned int)((void *)0)) {
#line 137
					if (!(((bptr->nprevgrd)->netptr)->xpos == bx1)) {
#line 137
						break;
					}
				}
				else {
#line 137
					break;
				}
#line 139
				if (net == (*(tearray + ((bptr->nprevgrd)->netptr)->terminal))->net) {
#line 139
					if ((bptr->nprevgrd)->nSegType < 0) {
#line 141
						Flag = 1;
#line 142
						sbptr = (struct changrdbox *)bptr1->nnextgrd;
#line 143
						while ((sbptr->netptr)->xpos == bx1) {
#line 144
							sbptr = (struct changrdbox *)sbptr->nnextgrd;
						}
#line 146
						break;
					}
					else {
#line 148
						bptr = (struct changrdbox *)bptr->nprevgrd;
					}
				}
				else {
#line 148
					bptr = (struct changrdbox *)bptr->nprevgrd;
				}
			}
#line 151
			if (!Flag) {
#line 152
				sbptr = (struct changrdbox *)bptr1->nnextgrd;
#line 153
				while ((sbptr->netptr)->xpos == bx1) {
#line 154
					if (net == (*(tearray + (sbptr->netptr)->terminal))->net) {
#line 154
						if (sbptr->nSegType < 0) {
#line 156
							Flag = 1;
						}
					}
#line 158
					sbptr = (struct changrdbox *)sbptr->nnextgrd;
				}
			}
#line 161
			if (!Flag) {
#line 162
				sbptr = bptr;
			}
		}
		else {
#line 165
			sbptr = (struct changrdbox *)bptr1->nnextgrd;
#line 166
			while ((sbptr->netptr)->xpos == bx1) {
#line 167
				sbptr = (struct changrdbox *)sbptr->nnextgrd;
			}
		}
#line 171
		if (bptr2->nSegType <= 0) {
#line 172
			Flag = 0;
#line 173
			fptr = bptr2;
#line 174
			while (1) {
#line 174
				if ((unsigned int)fptr->nnextgrd != (unsigned int)((void *)0)) {
#line 174
					if (!(((fptr->nnextgrd)->netptr)->xpos == bx2)) {
#line 174
						break;
					}
				}
				else {
#line 174
					break;
				}
#line 176
				if (net == (*(tearray + ((fptr->nnextgrd)->netptr)->terminal))->net) {
#line 176
					if ((fptr->nnextgrd)->nSegType > 0) {
#line 178
						Flag = 1;
#line 179
						ebptr = (struct changrdbox *)bptr2->nprevgrd;
#line 180
						while ((ebptr->netptr)->xpos == bx2) {
#line 181
							ebptr = (struct changrdbox *)ebptr->nprevgrd;
						}
#line 183
						break;
					}
					else {
#line 185
						fptr = (struct changrdbox *)fptr->nnextgrd;
					}
				}
				else {
#line 185
					fptr = (struct changrdbox *)fptr->nnextgrd;
				}
			}
#line 188
			if (!Flag) {
#line 189
				ebptr = (struct changrdbox *)bptr2->nprevgrd;
#line 190
				while ((ebptr->netptr)->xpos == bx2) {
#line 191
					if (net == (*(tearray + (ebptr->netptr)->terminal))->net) {
#line 191
						if (ebptr->nSegType > 0) {
#line 193
							Flag = 1;
						}
					}
#line 195
					ebptr = (struct changrdbox *)ebptr->nprevgrd;
				}
			}
#line 198
			if (!Flag) {
#line 199
				ebptr = fptr;
			}
		}
		else {
#line 202
			ebptr = (struct changrdbox *)bptr2->nprevgrd;
#line 203
			while ((ebptr->netptr)->xpos == bx2) {
#line 204
				ebptr = (struct changrdbox *)ebptr->nprevgrd;
			}
		}
#line 208
		aoutside = 0;
#line 209
		ax1 = (saptr->netptr)->xpos;
#line 210
		ax2 = (eaptr->netptr)->xpos;
#line 211
		denptr = (*(*(DboxHead + achannel) + aMaxVal))->nnext;
#line 212
		while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 213
			x = ((denptr->grdptr)->netptr)->xpos;
#line 214
			if (ax1 <= x) {
#line 214
				if (!(ax2 >= x)) {
#line 215
					aoutside = 1;
#line 216
					break;
				}
			}
			else {
#line 215
				aoutside = 1;
#line 216
				break;
			}
#line 212
			denptr = denptr->nnext;
		}
#line 219
		if (aoutside == 0) {
#line 220
			penalty___0--;
		}
#line 223
		binside = 0;
#line 224
		bx1 = (sbptr->netptr)->xpos;
#line 225
		bx2 = (ebptr->netptr)->xpos;
#line 226
		denptr = (*(*(DboxHead + bchannel) + bMaxVal))->nnext;
#line 227
		while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 228
			x = ((denptr->grdptr)->netptr)->xpos;
#line 229
			if (bx1 <= x) {
#line 229
				if (bx2 >= x) {
#line 230
					binside = 1;
#line 231
					break;
				}
			}
#line 227
			denptr = denptr->nnext;
		}
#line 234
		if (binside == 1) {
#line 235
			penalty___0++;
		}
#line 238
		eaptr = (struct changrdbox *)eaptr->nnextgrd;
#line 239
		ebptr = (struct changrdbox *)ebptr->nnextgrd;
#line 240
		if (penalty___0 == 0) {
#line 241
			if (binside == 1) {
#line 241
				if (aoutside == 0) {
#line 243
					check = (bMaxVal - aMaxVal) + 2;
				}
				else {
					goto _L;
				}
			}
			else {
			_L: /* CIL Label */
#line 245
				maxaa = 0;
#line 246
				maxbb = 0;
#line 247
				ptr = saptr;
#line 247
				while ((unsigned int)ptr != (unsigned int)eaptr) {
#line 248
					if (ptr->ntracks > maxaa) {
#line 249
						maxaa = ptr->ntracks;
					}
#line 247
					ptr = (struct changrdbox *)ptr->nnextgrd;
				}
#line 252
				ptr = sbptr;
#line 252
				while ((unsigned int)ptr != (unsigned int)ebptr) {
#line 253
					if (ptr->ntracks > maxbb) {
#line 254
						maxbb = ptr->ntracks;
					}
#line 252
					ptr = (struct changrdbox *)ptr->nnextgrd;
				}
#line 257
				maxaa = (aMaxVal - maxaa) + 1;
#line 258
				maxbb = (bMaxVal - maxbb) - 1;
#line 259
				check = maxaa - maxbb;
			}
		}
		else {
#line 262
			check = penalty___0;
		}
#line 265
		if (check <= 0) {
#line 266
			if (asegptr->pin1 <= maxterm) {
#line 267
				(aptr1->nSegType)--;
			}
#line 269
			if (asegptr->pin2 <= maxterm) {
#line 270
				aptr2->nSegType -= -1;
			}
#line 272
			if (bsegptr->pin1 <= maxterm) {
#line 273
				(bptr1->nSegType)++;
			}
#line 275
			if (bsegptr->pin2 <= maxterm) {
#line 276
				(bptr2->nSegType)--;
			}
#line 278
			ptr = saptr;
#line 278
			while ((unsigned int)ptr != (unsigned int)eaptr) {
#line 279
				denptr = ptr->dptr;
#line 280
				if ((unsigned int)denptr->nnext != (unsigned int)((void *)0)) {
#line 281
					(denptr->nnext)->nback = denptr->nback;
				}
#line 283
				(denptr->nback)->nnext = denptr->nnext;
#line 284
				(ptr->ntracks)--;
#line 284
				track = ptr->ntracks;
#line 286
				headptr = (*(*(DboxHead + achannel) + track))->nnext;
#line 287
				if ((unsigned int)headptr != (unsigned int)((void *)0)) {
#line 288
					(*(*(DboxHead + achannel) + track))->nnext = denptr;
#line 289
					denptr->nnext = headptr;
#line 290
					headptr->nback = denptr;
#line 291
					denptr->nback = *(*(DboxHead + achannel) + track);
				}
				else {
#line 293
					(*(*(DboxHead + achannel) + track))->nnext = denptr;
#line 294
					denptr->nnext = (struct densitybox *)((void *)0);
#line 295
					denptr->nback = *(*(DboxHead + achannel) + track);
				}
#line 278
				ptr = (struct changrdbox *)ptr->nnextgrd;
			}
#line 298
			if (aoutside == 0) {
#line 299
				(*(nmaxTrack + achannel))--;
			}
#line 301
			ptr = sbptr;
#line 301
			while ((unsigned int)ptr != (unsigned int)ebptr) {
#line 302
				denptr = ptr->dptr;
#line 303
				if ((unsigned int)denptr->nnext != (unsigned int)((void *)0)) {
#line 304
					(denptr->nnext)->nback = denptr->nback;
				}
#line 306
				(denptr->nback)->nnext = denptr->nnext;
#line 307
				(ptr->ntracks)++;
#line 307
				track = ptr->ntracks;
#line 309
				headptr = (*(*(DboxHead + bchannel) + track))->nnext;
#line 310
				if ((unsigned int)headptr != (unsigned int)((void *)0)) {
#line 311
					(*(*(DboxHead + bchannel) + track))->nnext = denptr;
#line 312
					denptr->nnext = headptr;
#line 313
					headptr->nback = denptr;
#line 314
					denptr->nback = *(*(DboxHead + bchannel) + track);
				}
				else {
#line 316
					(*(*(DboxHead + bchannel) + track))->nnext = denptr;
#line 317
					denptr->nnext = (struct densitybox *)((void *)0);
#line 318
					denptr->nback = *(*(DboxHead + bchannel) + track);
				}
#line 301
				ptr = (struct changrdbox *)ptr->nnextgrd;
			}
#line 321
			if (binside == 1) {
#line 322
				(*(nmaxTrack + bchannel))++;
			}
#line 324
			if ((int)(aNetSeg + segment)->nflag == 0) {
#line 325
				if (current == 1) {
#line 326
					(aNetSeg + segment)->current = (char)0;
				}
				else {
#line 328
					(aNetSeg + segment)->current = (char)1;
				}
			}
			else {
#line 331
				if (current == 1) {
#line 332
					(aNetSeg + segment)->ncurrent = (char)0;
				}
				else {
#line 334
					(aNetSeg + segment)->ncurrent = (char)1;
				}
			}
#line 338
			tracks += penalty___0;
#line 339
			return (1);
		}
		else {
#line 341
			return (0);
		}
	}
}
#line 1 "qsorte.o"
#pragma merger(0,"./qsorte.i","")
#line 6 "qsorte.c"
int qsz;
#line 7 "qsorte.c"
int thresh;
#line 8 "qsorte.c"
int mthresh;
#line 25
int qste(char *base, char *max);
#line 32
int comparee(edgeBptr a___0, edgeBptr b___0);
#line 11 "qsorte.c"
void qsorte(char *base, int n, int size)
{
	register char c;
	register char *i;
	register char *j;
	register char *lo;
	register char *hi;
	char *min;
	char *max;
	int tmp;
	char *tmp___0;
	char *tmp___1;
	int tmp___2;

	{
#line 16
		if (n <= 1) {
#line 17
			return;
		}
#line 18
		qsz = size;
#line 19
		thresh = qsz * 4;
#line 20
		mthresh = qsz * 6;
#line 21
		max = base + n * qsz;
#line 22
		* max = (char)-51;
#line 24
		if (n >= 4) {
#line 25
			qste(base, max);
#line 26
			hi = base + thresh;
		}
		else {
#line 29
			hi = max;
		}
#line 31
		lo = base;
#line 31
		j = lo;
#line 31
		while (1) {
#line 31
			lo += qsz;
#line 31
			if (!((unsigned int)lo < (unsigned int)hi)) {
#line 31
				break;
			}
#line 32
			tmp = comparee(j, lo);
#line 32
			if (tmp > 0) {
#line 33
				j = lo;
			}
		}
#line 34
		if ((unsigned int)j != (unsigned int)base) {
#line 36
			i = base;
#line 36
			hi = base + qsz;
#line 36
			while ((unsigned int)i < (unsigned int)hi) {
#line 37
				c = *j;
#line 38
				tmp___0 = j;
#line 38
				j++;
#line 38
				* tmp___0 = *i;
#line 39
				tmp___1 = i;
#line 39
				i++;
#line 39
				* tmp___1 = c;
			}
		}
#line 42
		min = base;
#line 42
		while (1) {
#line 42
			min += qsz;
#line 42
			hi = min;
#line 42
			if (!((unsigned int)hi < (unsigned int)max)) {
#line 42
				break;
			}
#line 43
			while (1) {
#line 43
				hi -= qsz;
#line 43
				tmp___2 = comparee(hi, min);
#line 43
				if (!(tmp___2 > 0)) {
#line 43
					break;
				}
			}
#line 45
			hi += qsz;
#line 45
			if ((unsigned int)hi != (unsigned int)min) {
#line 46
				lo = min + qsz;
#line 46
				while (1) {
#line 46
					lo--;
#line 46
					if (!((unsigned int)lo >= (unsigned int)min)) {
#line 46
						break;
					}
#line 47
					c = *lo;
#line 48
					j = lo;
#line 48
					i = j;
#line 48
					while (1) {
#line 48
						j -= qsz;
#line 48
						if (!((unsigned int)j >= (unsigned int)hi)) {
#line 48
							break;
						}
#line 49
						* i = *j;
#line 48
						i = j;
					}
#line 50
					* i = c;
				}
			}
		}
#line 54
		return;
	}
}
#line 57 "qsorte.c"
int qste(char *base, char *max)
{
	register char c;
	register char *i;
	register char *j;
	register char *jj;
	register int ii;
	char *mid;
	char *tmp;
	int lo;
	int hi;
	int goto_swap;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	char *tmp___4;
	char *tmp___5;
	int tmp___6;
	int tmp___7;
	char *tmp___8;
	char *tmp___9;

	{
#line 63
		goto_swap = 0;
#line 64
		lo = max - base;
#line 65
		while (1) {
#line 66
			i = base + qsz * (lo / qsz >> 1);
#line 66
			mid = i;
#line 67
			if (lo >= mthresh) {
#line 68
				jj = base;
#line 68
				tmp___1 = comparee(jj, i);
#line 68
				if (tmp___1 > 0) {
#line 68
					j = jj;
				}
				else {
#line 68
					j = i;
				}
#line 69
				tmp = max - qsz;
#line 69
				tmp___3 = comparee(j, tmp);
#line 69
				if (tmp___3 > 0) {
#line 71
					if ((unsigned int)j == (unsigned int)jj) {
#line 71
						j = i;
					}
					else {
#line 71
						j = jj;
					}
#line 72
					tmp___2 = comparee(j, tmp);
#line 72
					if (tmp___2 < 0) {
#line 73
						j = tmp;
					}
				}
#line 75
				if ((unsigned int)j != (unsigned int)i) {
#line 76
					ii = qsz;
#line 77
					while (1) {
#line 78
						c = *i;
#line 79
						tmp___4 = i;
#line 79
						i++;
#line 79
						* tmp___4 = *j;
#line 80
						tmp___5 = j;
#line 80
						j++;
#line 80
						* tmp___5 = c;
#line 77
						ii--;
#line 77
						if (!ii) {
#line 77
							break;
						}
					}
				}
			}
#line 87
			i = base;
#line 87
			j = max - qsz;
#line 87
			while (1) {
#line 88
				goto_swap = 0;
#line 89
				while (1) {
#line 89
					if ((unsigned int)i < (unsigned int)mid) {
#line 89
						tmp___6 = comparee(i, mid);
#line 89
						if (!(tmp___6 <= 0)) {
#line 89
							break;
						}
					}
					else {
#line 89
						break;
					}
#line 90
					i += qsz;
				}
#line 91
				while ((unsigned int)j > (unsigned int)mid) {
#line 93
					tmp___7 = comparee(mid, j);
#line 93
					if (tmp___7 <= 0) {
#line 94
						j -= qsz;
#line 95
						continue;
					}
#line 97
					tmp = i + qsz;
#line 98
					if ((unsigned int)i == (unsigned int)mid) {
#line 100
						jj = j;
#line 100
						mid = jj;
					}
					else {
#line 104
						jj = j;
#line 105
						j -= qsz;
					}
#line 108
					goto_swap = 1;
#line 109
					break;
				}
#line 111
				if (!goto_swap) {
#line 113
					if ((unsigned int)i == (unsigned int)mid) {
#line 114
						break;
					}
					else {
#line 118
						jj = mid;
#line 119
						mid = i;
#line 119
						tmp = mid;
#line 120
						j -= qsz;
					}
				}
#line 125
				ii = qsz;
#line 126
				while (1) {
#line 127
					c = *i;
#line 128
					tmp___8 = i;
#line 128
					i++;
#line 128
					* tmp___8 = *jj;
#line 129
					tmp___9 = jj;
#line 129
					jj++;
#line 129
					* tmp___9 = c;
#line 126
					ii--;
#line 126
					if (!ii) {
#line 126
						break;
					}
				}
#line 131
				i = tmp;
			}
#line 133
			j = mid;
#line 133
			i = j + qsz;
#line 134
			lo = j - base;
#line 134
			hi = max - i;
#line 134
			if (lo <= hi) {
#line 135
				if (lo >= thresh) {
#line 136
					//qste(base, j);
				}
#line 137
				base = i;
#line 138
				lo = hi;
			}
			else {
#line 141
				if (hi >= thresh) {
#line 142
					//qste(i, max);
				}
#line 143
				max = j;
			}
#line 65
			if (!(lo >= thresh)) {
#line 65
				break;
			}
		}
#line 146
		return (0);
	}
}
#line 150 "qsorte.c"
int comparee(edgeBptr a___0, edgeBptr b___0)
{

	{
#line 153
		return (a___0->cost - b___0->cost);
	}
}
#line 1 "qsortg.o"
#pragma merger(0,"./qsortg.i","")
#line 47 "qsortg.c"
int qstg(char *base, char *max);
#line 53
int compareg(csGroup *a___0, csGroup *b___0);
#line 34 "qsortg.c"
void qsortg(char *base, int n, int size)
{
	register char c;
	register char *i;
	register char *j;
	register char *lo;
	register char *hi;
	char *min;
	char *max;
	int tmp;
	char *tmp___0;
	char *tmp___1;
	int tmp___2;

	{
#line 39
		if (n <= 1) {
#line 40
			return;
		}
#line 41
		qsz = size;
#line 42
		thresh = qsz * 4;
#line 43
		mthresh = qsz * 6;
#line 44
		max = base + n * qsz;
#line 45
		* max = (char)0;
#line 46
		if (n >= 4) {
#line 47
			qstg(base, max);
#line 48
			hi = base + thresh;
		}
		else {
#line 50
			hi = max;
		}
#line 52
		lo = base;
#line 52
		j = lo;
#line 52
		while (1) {
#line 52
			lo += qsz;
#line 52
			if (!((unsigned int)lo < (unsigned int)hi)) {
#line 52
				break;
			}
#line 53
			tmp = compareg(j, lo);
#line 53
			if (tmp > 0) {
#line 54
				j = lo;
			}
		}
#line 55
		if ((unsigned int)j != (unsigned int)base) {
#line 57
			i = base;
#line 57
			hi = base + qsz;
#line 57
			while ((unsigned int)i < (unsigned int)hi) {
#line 58
				c = *j;
#line 59
				tmp___0 = j;
#line 59
				j++;
#line 59
				* tmp___0 = *i;
#line 60
				tmp___1 = i;
#line 60
				i++;
#line 60
				* tmp___1 = c;
			}
		}
#line 63
		min = base;
#line 63
		while (1) {
#line 63
			min += qsz;
#line 63
			hi = min;
#line 63
			if (!((unsigned int)hi < (unsigned int)max)) {
#line 63
				break;
			}
#line 64
			while (1) {
#line 64
				hi -= qsz;
#line 64
				tmp___2 = compareg(hi, min);
#line 64
				if (!(tmp___2 > 0)) {
#line 64
					break;
				}
			}
#line 66
			hi += qsz;
#line 66
			if ((unsigned int)hi != (unsigned int)min) {
#line 67
				lo = min + qsz;
#line 67
				while (1) {
#line 67
					lo--;
#line 67
					if (!((unsigned int)lo >= (unsigned int)min)) {
#line 67
						break;
					}
#line 68
					c = *lo;
#line 69
					j = lo;
#line 69
					i = j;
#line 69
					while (1) {
#line 69
						j -= qsz;
#line 69
						if (!((unsigned int)j >= (unsigned int)hi)) {
#line 69
							break;
						}
#line 70
						* i = *j;
#line 69
						i = j;
					}
#line 71
					* i = c;
				}
			}
		}
#line 75
		return;
	}
}
#line 78 "qsortg.c"
int qstg(char *base, char *max)
{
	register char c;
	register char *i;
	register char *j;
	register char *jj;
	register int ii;
	char *mid;
	char *tmp;
	int lo;
	int hi;
	int goto_swap;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	char *tmp___4;
	char *tmp___5;
	int tmp___6;
	int tmp___7;
	char *tmp___8;
	char *tmp___9;

	{
#line 84
		goto_swap = 0;
#line 85
		lo = max - base;
#line 86
		while (1) {
#line 87
			i = base + qsz * (lo / qsz >> 1);
#line 87
			mid = i;
#line 88
			if (lo >= mthresh) {
#line 89
				jj = base;
#line 89
				tmp___1 = compareg(jj, i);
#line 89
				if (tmp___1 > 0) {
#line 89
					j = jj;
				}
				else {
#line 89
					j = i;
				}
#line 90
				tmp = max - qsz;
#line 90
				tmp___3 = compareg(j, tmp);
#line 90
				if (tmp___3 > 0) {
#line 92
					if ((unsigned int)j == (unsigned int)jj) {
#line 92
						j = i;
					}
					else {
#line 92
						j = jj;
					}
#line 93
					tmp___2 = compareg(j, tmp);
#line 93
					if (tmp___2 < 0) {
#line 94
						j = tmp;
					}
				}
#line 96
				if ((unsigned int)j != (unsigned int)i) {
#line 97
					ii = qsz;
#line 98
					while (1) {
#line 99
						c = *i;
#line 100
						tmp___4 = i;
#line 100
						i++;
#line 100
						* tmp___4 = *j;
#line 101
						tmp___5 = j;
#line 101
						j++;
#line 101
						* tmp___5 = c;
#line 98
						ii--;
#line 98
						if (!ii) {
#line 98
							break;
						}
					}
				}
			}
#line 108
			i = base;
#line 108
			j = max - qsz;
#line 108
			while (1) {
#line 109
				goto_swap = 0;
#line 110
				while (1) {
#line 110
					if ((unsigned int)i < (unsigned int)mid) {
#line 110
						tmp___6 = compareg(i, mid);
#line 110
						if (!(tmp___6 <= 0)) {
#line 110
							break;
						}
					}
					else {
#line 110
						break;
					}
#line 111
					i += qsz;
				}
#line 112
				while ((unsigned int)j > (unsigned int)mid) {
#line 113
					tmp___7 = compareg(mid, j);
#line 113
					if (tmp___7 <= 0) {
#line 114
						j -= qsz;
#line 115
						continue;
					}
#line 117
					tmp = i + qsz;
#line 118
					if ((unsigned int)i == (unsigned int)mid) {
#line 120
						jj = j;
#line 120
						mid = jj;
					}
					else {
#line 123
						jj = j;
#line 124
						j -= qsz;
					}
#line 127
					goto_swap = 1;
#line 128
					break;
				}
#line 130
				if (!goto_swap) {
#line 132
					if ((unsigned int)i == (unsigned int)mid) {
#line 133
						break;
					}
					else {
#line 137
						jj = mid;
#line 138
						mid = i;
#line 138
						tmp = mid;
#line 139
						j -= qsz;
					}
				}
#line 144
				ii = qsz;
#line 145
				while (1) {
#line 146
					c = *i;
#line 147
					tmp___8 = i;
#line 147
					i++;
#line 147
					* tmp___8 = *jj;
#line 148
					tmp___9 = jj;
#line 148
					jj++;
#line 148
					* tmp___9 = c;
#line 145
					ii--;
#line 145
					if (!ii) {
#line 145
						break;
					}
				}
#line 150
				i = tmp;
			}
#line 152
			j = mid;
#line 152
			i = j + qsz;
#line 153
			lo = j - base;
#line 153
			hi = max - i;
#line 153
			if (lo <= hi) {
#line 154
				if (lo >= thresh) {
#line 155
					//qstg(base, j);
				}
#line 156
				base = i;
#line 157
				lo = hi;
			}
			else {
#line 159
				if (hi >= thresh) {
#line 160
					//qstg(i, max);
				}
#line 161
				max = j;
			}
#line 86
			if (!(lo >= thresh)) {
#line 86
				break;
			}
		}
#line 164
		return (0);
	}
}
#line 166 "qsortg.c"
int compareg(csGroup *a___0, csGroup *b___0)
{

	{
#line 168
		return (a___0->aveX - b___0->aveX);
	}
}
#line 1 "qsortgdx.o"
#pragma merger(0,"./qsortgdx.i","")
#line 25 "qsortgdx.c"
int qstgdx(char *base, char *max);
#line 31
int comparegdx(CHANGRDPTR *a___0, CHANGRDPTR *b___0);
#line 12 "qsortgdx.c"
void qsortgdx(char *base, int n, int size)
{
	register char c;
	register char *i;
	register char *j;
	register char *lo;
	register char *hi;
	char *min;
	char *max;
	int tmp;
	char *tmp___0;
	char *tmp___1;
	int tmp___2;

	{
#line 17
		if (n <= 1) {
#line 18
			return;
		}
#line 19
		qsz = size;
#line 20
		thresh = qsz * 4;
#line 21
		mthresh = qsz * 6;
#line 22
		max = base + n * qsz;
#line 23
		* max = (char)-3;
#line 24
		if (n >= 4) {
#line 25
			qstgdx(base, max);
#line 26
			hi = base + thresh;
		}
		else {
#line 28
			hi = max;
		}
#line 30
		lo = base;
#line 30
		j = lo;
#line 30
		while (1) {
#line 30
			lo += qsz;
#line 30
			if (!((unsigned int)lo < (unsigned int)hi)) {
#line 30
				break;
			}
#line 31
			tmp = comparegdx(j, lo);
#line 31
			if (tmp > 0) {
#line 32
				j = lo;
			}
		}
#line 33
		if ((unsigned int)j != (unsigned int)base) {
#line 35
			i = base;
#line 35
			hi = base + qsz;
#line 35
			while ((unsigned int)i < (unsigned int)hi) {
#line 36
				c = *j;
#line 37
				tmp___0 = j;
#line 37
				j++;
#line 37
				* tmp___0 = *i;
#line 38
				tmp___1 = i;
#line 38
				i++;
#line 38
				* tmp___1 = c;
			}
		}
#line 41
		min = base;
#line 41
		while (1) {
#line 41
			min += qsz;
#line 41
			hi = min;
#line 41
			if (!((unsigned int)hi < (unsigned int)max)) {
#line 41
				break;
			}
#line 42
			while (1) {
#line 42
				hi -= qsz;
#line 42
				tmp___2 = comparegdx(hi, min);
#line 42
				if (!(tmp___2 > 0)) {
#line 42
					break;
				}
			}
#line 44
			hi += qsz;
#line 44
			if ((unsigned int)hi != (unsigned int)min) {
#line 45
				lo = min + qsz;
#line 45
				while (1) {
#line 45
					lo--;
#line 45
					if (!((unsigned int)lo >= (unsigned int)min)) {
#line 45
						break;
					}
#line 46
					c = *lo;
#line 47
					j = lo;
#line 47
					i = j;
#line 47
					while (1) {
#line 47
						j -= qsz;
#line 47
						if (!((unsigned int)j >= (unsigned int)hi)) {
#line 47
							break;
						}
#line 48
						* i = *j;
#line 47
						i = j;
					}
#line 49
					* i = c;
				}
			}
		}
#line 53
		return;
	}
}
#line 56 "qsortgdx.c"
int qstgdx(char *base, char *max)
{
	register char c;
	register char *i;
	register char *j;
	register char *jj;
	register int ii;
	char *mid;
	char *tmp;
	int lo;
	int hi;
	int goto_swap;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	char *tmp___4;
	char *tmp___5;
	int tmp___6;
	int tmp___7;
	char *tmp___8;
	char *tmp___9;

	{
#line 62
		goto_swap = 0;
#line 63
		lo = max - base;
#line 64
		while (1) {
#line 65
			i = base + qsz * (lo / qsz >> 1);
#line 65
			mid = i;
#line 66
			if (lo >= mthresh) {
#line 67
				jj = base;
#line 67
				tmp___1 = comparegdx(jj, i);
#line 67
				if (tmp___1 > 0) {
#line 67
					j = jj;
				}
				else {
#line 67
					j = i;
				}
#line 68
				tmp = max - qsz;
#line 68
				tmp___3 = comparegdx(j, tmp);
#line 68
				if (tmp___3 > 0) {
#line 70
					if ((unsigned int)j == (unsigned int)jj) {
#line 70
						j = i;
					}
					else {
#line 70
						j = jj;
					}
#line 71
					tmp___2 = comparegdx(j, tmp);
#line 71
					if (tmp___2 < 0) {
#line 72
						j = tmp;
					}
				}
#line 74
				if ((unsigned int)j != (unsigned int)i) {
#line 75
					ii = qsz;
#line 76
					while (1) {
#line 77
						c = *i;
#line 78
						tmp___4 = i;
#line 78
						i++;
#line 78
						* tmp___4 = *j;
#line 79
						tmp___5 = j;
#line 79
						j++;
#line 79
						* tmp___5 = c;
#line 76
						ii--;
#line 76
						if (!ii) {
#line 76
							break;
						}
					}
				}
			}
#line 86
			i = base;
#line 86
			j = max - qsz;
#line 86
			while (1) {
#line 87
				goto_swap = 0;
#line 88
				while (1) {
#line 88
					if ((unsigned int)i < (unsigned int)mid) {
#line 88
						tmp___6 = comparegdx(i, mid);
#line 88
						if (!(tmp___6 <= 0)) {
#line 88
							break;
						}
					}
					else {
#line 88
						break;
					}
#line 89
					i += qsz;
				}
#line 90
				while ((unsigned int)j > (unsigned int)mid) {
#line 91
					tmp___7 = comparegdx(mid, j);
#line 91
					if (tmp___7 <= 0) {
#line 92
						j -= qsz;
#line 93
						continue;
					}
#line 95
					tmp = i + qsz;
#line 96
					if ((unsigned int)i == (unsigned int)mid) {
#line 98
						jj = j;
#line 98
						mid = jj;
					}
					else {
#line 101
						jj = j;
#line 102
						j -= qsz;
					}
#line 105
					goto_swap = 1;
#line 106
					break;
				}
#line 108
				if (!goto_swap) {
#line 110
					if ((unsigned int)i == (unsigned int)mid) {
#line 111
						break;
					}
					else {
#line 115
						jj = mid;
#line 116
						mid = i;
#line 116
						tmp = mid;
#line 117
						j -= qsz;
					}
				}
#line 122
				ii = qsz;
#line 123
				while (1) {
#line 124
					c = *i;
#line 125
					tmp___8 = i;
#line 125
					i++;
#line 125
					* tmp___8 = *jj;
#line 126
					tmp___9 = jj;
#line 126
					jj++;
#line 126
					* tmp___9 = c;
#line 123
					ii--;
#line 123
					if (!ii) {
#line 123
						break;
					}
				}
#line 128
				i = tmp;
			}
#line 130
			j = mid;
#line 130
			i = j + qsz;
#line 131
			lo = j - base;
#line 131
			hi = max - i;
#line 131
			if (lo <= hi) {
#line 132
				if (lo >= thresh) {
#line 133
					//qstgdx(base, j);
				}
#line 134
				base = i;
#line 135
				lo = hi;
			}
			else {
#line 137
				if (hi >= thresh) {
#line 138
					//qstgdx(i, max);
				}
#line 139
				max = j;
			}
#line 64
			if (!(lo >= thresh)) {
#line 64
				break;
			}
		}
#line 142
		return (0);
	}
}
#line 146 "qsortgdx.c"
int comparegdx(CHANGRDPTR *a___0, CHANGRDPTR *b___0)
{

	{
#line 148
		return (((*a___0)->netptr)->xpos - ((*b___0)->netptr)->xpos);
	}
}
#line 1 "qsortx.o"
#pragma merger(0,"./qsortx.i","")
#line 8 "qsortx.c"
int syf;
#line 27
int qst(char *base, char *max);
#line 10 "qsortx.c"
void qsortx(char *base, int n, int size)
{
	register char c;
	register char *i;
	register char *j;
	register char *lo;
	register char *hi;
	char *min;
	char *max;
	int tmp;
	char *tmp___0;
	char *tmp___1;
	int tmp___2;

	{
#line 15
		if (n <= 1) {
#line 16
			return;
		}
#line 17
		qsz = size;
#line 18
		thresh = qsz * 4;
#line 19
		mthresh = qsz * 6;
#line 20
		max = base + n * qsz;
#line 21
		* max = (char)-3;
#line 22
		if (syf == 121) {
#line 24
			printf("*max=", *max);
		}
#line 26
		if (n >= 4) {
#line 27
			qst(base, max);
#line 28
			hi = base + thresh;
		}
		else {
#line 31
			hi = max;
		}
#line 39
		lo = base;
#line 39
		j = lo;
#line 39
		while (1) {
#line 39
			lo += qsz;
#line 39
			if (!((unsigned int)lo < (unsigned int)hi)) {
#line 39
				break;
			}
#line 41
			tmp = comparex(j, lo);
#line 41
			if (tmp > 0) {
#line 42
				j = lo;
			}
		}
#line 44
		if ((unsigned int)j != (unsigned int)base) {
#line 46
			i = base;
#line 46
			hi = base + qsz;
#line 46
			while ((unsigned int)i < (unsigned int)hi) {
#line 47
				c = *j;
#line 48
				tmp___0 = j;
#line 48
				j++;
#line 48
				* tmp___0 = *i;
#line 49
				tmp___1 = i;
#line 49
				i++;
#line 49
				* tmp___1 = c;
			}
		}
#line 59
		min = base;
#line 59
		while (1) {
#line 59
			min += qsz;
#line 59
			hi = min;
#line 59
			if (!((unsigned int)hi < (unsigned int)max)) {
#line 59
				break;
			}
#line 60
			while (1) {
#line 60
				hi -= qsz;
#line 60
				tmp___2 = comparex(hi, min);
#line 60
				if (!(tmp___2 > 0)) {
#line 60
					break;
				}
			}
#line 62
			hi += qsz;
#line 62
			if ((unsigned int)hi != (unsigned int)min) {
#line 63
				lo = min + qsz;
#line 63
				while (1) {
#line 63
					lo--;
#line 63
					if (!((unsigned int)lo >= (unsigned int)min)) {
#line 63
						break;
					}
#line 64
					c = *lo;
#line 65
					j = lo;
#line 65
					i = j;
#line 65
					while (1) {
#line 65
						j -= qsz;
#line 65
						if (!((unsigned int)j >= (unsigned int)hi)) {
#line 65
							break;
						}
#line 66
						* i = *j;
#line 65
						i = j;
					}
#line 67
					* i = c;
				}
			}
		}
#line 71
		return;
	}
}
#line 88 "qsortx.c"
int qst(char *base, char *max)
{
	register char c;
	register char *i;
	register char *j;
	register char *jj;
	register int ii;
	char *mid;
	char *tmp;
	int lo;
	int hi;
	int goto_swap;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	char *tmp___4;
	char *tmp___5;
	int tmp___6;
	int tmp___7;
	char *tmp___8;
	char *tmp___9;

	{
#line 94
		goto_swap = 0;
#line 104
		lo = max - base;
#line 105
		while (1) {
#line 106
			i = base + qsz * (lo / qsz >> 1);
#line 106
			mid = i;
#line 107
			if (lo >= mthresh) {
#line 108
				jj = base;
#line 108
				tmp___1 = comparex(jj, i);
#line 108
				if (tmp___1 > 0) {
#line 108
					j = jj;
				}
				else {
#line 108
					j = i;
				}
#line 109
				tmp = max - qsz;
#line 109
				tmp___3 = comparex(j, tmp);
#line 109
				if (tmp___3 > 0) {
#line 111
					if ((unsigned int)j == (unsigned int)jj) {
#line 111
						j = i;
					}
					else {
#line 111
						j = jj;
					}
#line 112
					tmp___2 = comparex(j, tmp);
#line 112
					if (tmp___2 < 0) {
#line 113
						j = tmp;
					}
				}
#line 115
				if ((unsigned int)j != (unsigned int)i) {
#line 116
					ii = qsz;
#line 117
					while (1) {
#line 118
						c = *i;
#line 119
						tmp___4 = i;
#line 119
						i++;
#line 119
						* tmp___4 = *j;
#line 120
						tmp___5 = j;
#line 120
						j++;
#line 120
						* tmp___5 = c;
#line 117
						ii--;
#line 117
						if (!ii) {
#line 117
							break;
						}
					}
				}
			}
#line 127
			i = base;
#line 127
			j = max - qsz;
#line 127
			while (1) {
#line 128
				goto_swap = 0;
#line 129
				while (1) {
#line 129
					if ((unsigned int)i < (unsigned int)mid) {
#line 129
						tmp___6 = comparex(i, mid);
#line 129
						if (!(tmp___6 <= 0)) {
#line 129
							break;
						}
					}
					else {
#line 129
						break;
					}
#line 130
					i += qsz;
				}
#line 131
				while ((unsigned int)j > (unsigned int)mid) {
#line 132
					tmp___7 = comparex(mid, j);
#line 132
					if (tmp___7 <= 0) {
#line 133
						j -= qsz;
#line 134
						continue;
					}
#line 136
					tmp = i + qsz;
#line 137
					if ((unsigned int)i == (unsigned int)mid) {
#line 139
						jj = j;
#line 139
						mid = jj;
					}
					else {
#line 143
						jj = j;
#line 144
						j -= qsz;
					}
#line 147
					goto_swap = 1;
#line 148
					break;
				}
#line 150
				if (!goto_swap) {
#line 152
					if ((unsigned int)i == (unsigned int)mid) {
#line 153
						break;
					}
					else {
#line 157
						jj = mid;
#line 158
						mid = i;
#line 158
						tmp = mid;
#line 159
						j -= qsz;
					}
				}
#line 164
				ii = qsz;
#line 165
				while (1) {
#line 166
					c = *i;
#line 167
					tmp___8 = i;
#line 167
					i++;
#line 167
					* tmp___8 = *jj;
#line 168
					tmp___9 = jj;
#line 168
					jj++;
#line 168
					* tmp___9 = c;
#line 165
					ii--;
#line 165
					if (!ii) {
#line 165
						break;
					}
				}
#line 170
				i = tmp;
			}
#line 180
			j = mid;
#line 180
			i = j + qsz;
#line 181
			lo = j - base;
#line 181
			hi = max - i;
#line 181
			if (lo <= hi) {
#line 182
				if (lo >= thresh) {
#line 183
					//qst(base, j);
				}
#line 184
				base = i;
#line 185
				lo = hi;
			}
			else {
#line 188
				if (hi >= thresh) {
#line 189
					//qst(i, max);
				}
#line 190
				max = j;
			}
#line 105
			if (!(lo >= thresh)) {
#line 105
				break;
			}
		}
#line 193
		return (0);
	}
}
#line 1 "rand.o"
#pragma merger(0,"./rand.i","")
#line 18 "rand.c"
static int randVarS;
#line 21 "rand.c"
int RandomCount;
#line 23
int attempts;
#line 32 "rand.c"
int Yacm_random(void)
{
	register int k_rand;

	{
#line 36
		if (syf == 81) {
#line 36
			if (attempts == 197) {
#line 38
				RandomCount++;
			}
		}
#line 41
		k_rand = randVarS / 127773;
#line 42
		randVarS = 16807 * (randVarS - k_rand * 127773) - k_rand * 2836;
#line 43
		if (randVarS < 0) {
#line 44
			randVarS += 2147483647;
		}
#line 46
		return (randVarS);
	}
}
#line 50 "rand.c"
void Yset_random_seed(int seed)
{

	{
#line 52
		seed = ABS(seed);
#line 53
		if (seed == 0) {
#line 54
			seed++;
		}
#line 56
		randVarS = seed;
#line 57
		return;
	}
}
#line 1 "readblck.o"
#pragma merger(0,"./readblck.i","")
#line 3 "readblck.c"
int *nofeed;
#line 4 "readblck.c"
float *relativeLen;
#line 6 "readblck.c"
int readblck(FILE *fp)
{
	int test;
	int block___0;
	int class;
	int height___0;
	int row___0;
	float relLen;
	char input[32];
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	char *tmp___6;
	char *tmp___7;
	char *tmp___8;
	char *tmp___9;
	int tmp___10;
	int tmp___11;
	int tmp___12;
	int tmp___13;
	int tmp___14;

	{
#line 13
		block___0 = 0;
#line 15
		while (1) {
#line 15
			tmp___5 = fscanf(fp, " %s ", input);
#line 15
			if (!(tmp___5 == 1)) {
#line 15
				break;
			}
#line 17
			tmp___4 = strcmp((char const   *)(input), "block");
#line 17
			if (tmp___4 == 0) {
#line 18
				block___0++;
#line 19
				fscanf(fp, " %s ", input);
#line 20
				tmp = strcmp((char const   *)(input), "height");
#line 20
				if (tmp == 0) {
#line 21
					test = fscanf(fp, " %d ", &height___0);
#line 22
					if (test != 1) {
#line 23
						fprintf(fpo, "Failed to input height of a block\n");
#line 24
						fprintf(fpo, "at position height\n");
#line 25
						exit(1);
					}
				}
				else {
#line 28
					fprintf(fpo, "unexpected keyword in the .blk file\n");
#line 29
					fprintf(fpo, "at position height\n");
#line 30
					fprintf(fpo, "current block: %d\n", block___0);
#line 31
					exit(1);
				}
#line 33
				fscanf(fp, " %s ", input);
#line 34
				tmp___0 = strcmp((char const   *)(input), "class");
#line 34
				if (tmp___0 == 0) {
#line 35
					test = fscanf(fp, " %d ", &class);
#line 36
					if (test != 1) {
#line 37
						fprintf(fpo, "Failed to input class of a block\n");
#line 38
						fprintf(fpo, "current block: %d\n", block___0);
#line 39
						exit(1);
					}
				}
				else {
#line 42
					fprintf(fpo, "unexpected keyword in the .blk file\n");
#line 43
					fprintf(fpo, "at position class\n");
#line 44
					fprintf(fpo, "current block: %d\n", block___0);
#line 45
					exit(1);
				}
			}
			else {
#line 47
				tmp___3 = strcmp((char const   *)(input), "mirror");
#line 47
				if (!(tmp___3 == 0)) {
#line 48
					tmp___2 = strcmp((char const   *)(input), "nofeeds");
#line 48
					if (!(tmp___2 == 0)) {
#line 49
						tmp___1 = strcmp((char const   *)(input), "relative_length");
#line 49
						if (tmp___1 == 0) {
#line 50
							test = fscanf(fp, " %f ", &relLen);
						}
						else {
#line 52
							fprintf(fpo, "unexpected keyword in the .blk file\n");
#line 53
							fprintf(fpo, "current block: %d\n", block___0);
#line 54
							exit(1);
						}
					}
				}
			}
		}
#line 57
		numblock = block___0;
#line 59
		rewind(fp);
#line 61
		tmp___6 = safe_malloc((unsigned int)(numblock + 1) * sizeof(BBOXPTR));
#line 61
		barray = (BBOXPTR *)tmp___6;
#line 62
		tmp___7 = safe_malloc((unsigned int)(numblock + 2) * sizeof(int));
#line 62
		nofeed = (int *)tmp___7;
#line 63
		row___0 = 0;
#line 63
		while (row___0 <= numblock + 1) {
#line 64
			* (nofeed + row___0) = 0;
#line 63
			row___0++;
		}
#line 67
		tmp___8 = safe_malloc((unsigned int)(numblock + 1) * sizeof(float));
#line 67
		relativeLen = (float *)tmp___8;
#line 68
		block___0 = 1;
#line 68
		while (block___0 <= numblock) {
#line 69
			* (relativeLen + block___0) = (float)1.0;
#line 68
			block___0++;
		}
#line 72
		block___0 = 1;
#line 72
		while (block___0 <= numblock) {
#line 74
			tmp___9 = safe_malloc(sizeof(BBOX));
#line 74
			* (barray + block___0) = (struct blockbox *)tmp___9;
#line 75
			(*(barray + block___0))->bxcenter = 0;
#line 76
			(*(barray + block___0))->bycenter = 0;
#line 77
			(*(barray + block___0))->bleft = 0;
#line 78
			(*(barray + block___0))->bright = 0;
#line 79
			(*(barray + block___0))->bbottom = 0;
#line 80
			(*(barray + block___0))->btop = 0;
#line 81
			(*(barray + block___0))->bheight = 0;
#line 82
			(*(barray + block___0))->blength = 0;
#line 83
			(*(barray + block___0))->bclass = 0;
#line 84
			(*(barray + block___0))->borient = 0;
#line 85
			(*(barray + block___0))->desire = 0;
#line 86
			(*(barray + block___0))->oldsize = 0;
#line 87
			(*(barray + block___0))->newsize = 0;
#line 72
			block___0++;
		}
#line 90
		block___0 = 0;
#line 92
		while (1) {
#line 92
			tmp___14 = fscanf(fp, " %s ", input);
#line 92
			if (!(tmp___14 == 1)) {
#line 92
				break;
			}
#line 94
			tmp___13 = strcmp((char const   *)(input), "block");
#line 94
			if (tmp___13 == 0) {
#line 95
				block___0++;
#line 96
				fscanf(fp, " %s ", input);
#line 97
				fscanf(fp, " %d ", &height___0);
#line 98
				(*(barray + block___0))->btop = height___0 - height___0 / 2;
#line 99
				(*(barray + block___0))->bbottom = -height___0 / 2;
#line 100
				(*(barray + block___0))->bheight = height___0;
#line 101
				fscanf(fp, " %s ", input);
#line 102
				fscanf(fp, " %d ", &class);
#line 103
				(*(barray + block___0))->bclass = class;
#line 104
				(*(barray + block___0))->borient = 1;
			}
			else {
#line 105
				tmp___12 = strcmp((char const   *)(input), "mirror");
#line 105
				if (tmp___12 == 0) {
#line 106
					(*(barray + block___0))->borient = 2;
				}
				else {
#line 107
					tmp___11 = strcmp((char const   *)(input), "nofeeds");
#line 107
					if (tmp___11 == 0) {
#line 108
						* (nofeed + block___0) = 1;
					}
					else {
#line 109
						tmp___10 = strcmp((char const   *)(input), "relative_length");
#line 109
						if (tmp___10 == 0) {
#line 110
							fscanf(fp, " %f ", &relLen);
#line 111
							* (relativeLen + block___0) = relLen;
						}
					}
				}
			}
		}
#line 114
		return;
	}
}
#line 1 "readcell.o"
#pragma merger(0,"./readcell.i","")
#line 4 "readcell.c"
int totallen;
#line 5 "readcell.c"
int maxterm;
#line 16 "readcell.c"
int readcell(FILE *fp)
{
	int cell___0;
	int orient;
	int layer;
	int block___0;
	int left___0;
	int right;
	int bottom;
	int top___0;
	int xpos;
	int ypos;
	int from;
	int terms;
	int pinctr;
	int netx;
	int tot;
	int totx;
	int toty;
	char input[1024];
	char netname[1024];
	float space___0;
	CBOXPTR ptr;
	TIBOXPTR tile;
	TIBOXPTR tptr;
	TEBOXPTR term;
	TEBOXPTR tmptr;
	NBOXPTR netptr;
	NBOXPTR saveptr;
	char *tmp;
	CBOXPTR tmp___0;
	char *tmp___1;
	size_t tmp___2;
	char *tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	int tmp___7;
	TIBOXPTR tmp___8;
	char *tmp___9;
	size_t tmp___10;
	char *tmp___11;
	TEBOXPTR tmp___12;
	char *tmp___13;
	struct termbox *tmp___14;
	char *tmp___15;
	NBOXPTR tmp___16;
	char *tmp___17;
	int tmp___18;
	int tmp___19;
	size_t tmp___20;
	char *tmp___21;
	int tmp___22;
	int tmp___23;
	int tmp___24;
	int tmp___25;
	int tmp___26;
	int tmp___27;
	int tmp___28;
	int tmp___29;
	int tmp___30;
	int tmp___31;
	int tmp___32;
	int tmp___33;
	int tmp___34;
	int tmp___35;
	int tmp___36;
	int tmp___37;
	int tmp___38;
	int tmp___39;
	int tmp___40;
	int tmp___41;
	int tmp___42;
	int tmp___43;
	int tmp___44;
	int tmp___45;
	int tmp___46;
	int tmp___47;
	int tmp___48;
	int tmp___49;
	int tmp___50;
	int tmp___51;
	char *tmp___52;

	{
#line 33
		parser(fp);
#line 36
		tmp = safe_malloc((unsigned int)((1 + numcells) + numterms) * sizeof(CBOXPTR));
#line 36
		carray = (CBOXPTR *)tmp;
#line 39
		cell___0 = 1;
#line 39
		while (cell___0 <= numcells + numterms) {
#line 41
			tmp___1 = safe_malloc(sizeof(CBOX));
#line 41
			tmp___0 = (struct cellbox *)tmp___1;
#line 41
			* (carray + cell___0) = tmp___0;
#line 41
			ptr = tmp___0;
#line 43
			ptr->cxcenter = 0;
#line 44
			ptr->cycenter = 0;
#line 45
			ptr->cheight = 0;
#line 46
			ptr->clength = 0;
#line 47
			ptr->cblock = 0;
#line 48
			ptr->cclass = 0;
#line 49
			ptr->corient = (char)0;
#line 50
			ptr->orflag = (char)1;
#line 51
			ptr->numterms = 0;
#line 52
			ptr->padside = 0;
#line 53
			ptr->tileptr = (struct tilebox *)((void *)0);
#line 39
			cell___0++;
		}
#line 56
		implicit_feed_count = 0;
#line 57
		cell___0 = 0;
#line 58
		terms = 0;
#line 59
		pinctr = 0;
#line 61
		while (1) {
#line 61
			tmp___51 = fscanf(fp, " %s ", input);
#line 61
			if (!(tmp___51 == 1)) {
#line 61
				break;
			}
#line 63
			tmp___50 = strcmp((char const   *)(input), "cell");
#line 63
			if (tmp___50 == 0) {
#line 65
				cell___0++;
#line 66
				ptr = *(carray + cell___0);
#line 67
				ptr->corient = (char)0;
#line 68
				fscanf(fp, " %s ", input);
#line 69
				fscanf(fp, " %s ", input);
#line 70
				tmp___2 = strlen((char const   *)(input));
#line 70
				tmp___3 = safe_malloc((tmp___2 + 1U) * sizeof(char));
#line 70
				ptr->cname = tmp___3;
#line 72
				sprintf(ptr->cname, "%s", input);
			}
			else {
#line 74
				tmp___49 = strcmp((char const   *)(input), "nomirror");
#line 74
				if (tmp___49 == 0) {
#line 75
					ptr->orflag = (char)0;
				}
				else {
#line 77
					tmp___48 = strcmp((char const   *)(input), "initially");
#line 77
					if (tmp___48 == 0) {
#line 78
						fscanf(fp, " %s ", input);
#line 79
						tmp___5 = strcmp((char const   *)(input), "fixed");
#line 79
						if (tmp___5 == 0) {
#line 80
							ptr->cclass = -1;
#line 81
							ptr->orflag = (char)0;
						}
						else {
#line 82
							tmp___4 = strcmp((char const   *)(input), "nonfixed");
#line 82
							if (tmp___4 == 0) {
#line 83
								ptr->cclass = 0;
							}
						}
#line 85
						fscanf(fp, " %d ", &from);
#line 86
						fscanf(fp, " %s ", input);
#line 87
						fscanf(fp, " %s ", input);
#line 88
						tmp___7 = strcmp((char const   *)(input), "left");
#line 88
						if (tmp___7 == 0) {
#line 89
							ptr->cxcenter = from;
#line 90
							ptr->cycenter = 1;
						}
						else {
#line 91
							tmp___6 = strcmp((char const   *)(input), "right");
#line 91
							if (tmp___6 == 0) {
#line 92
								ptr->cxcenter = -from;
#line 93
								ptr->cycenter = -1;
							}
						}
#line 95
						fscanf(fp, " %s ", input);
#line 96
						fscanf(fp, " %s ", input);
#line 97
						fscanf(fp, " %d ", &block___0);
#line 98
						ptr->cblock = block___0;
					}
					else {
#line 100
						tmp___47 = strcmp((char const   *)(input), "left");
#line 100
						if (tmp___47 == 0) {
#line 102
							tmp___9 = safe_malloc(sizeof(TIBOX));
#line 102
							tmp___8 = (struct tilebox *)tmp___9;
#line 102
							ptr->tileptr = tmp___8;
#line 102
							tile = tmp___8;
#line 103
							tile->termsptr = (struct termbox *)((void *)0);
#line 105
							fscanf(fp, " %d ", &left___0);
#line 106
							tile->left = left___0;
						}
						else {
#line 108
							tmp___46 = strcmp((char const   *)(input), "right");
#line 108
							if (tmp___46 == 0) {
#line 110
								fscanf(fp, " %d ", &right);
#line 111
								tile->right = right;
							}
							else {
#line 113
								tmp___45 = strcmp((char const   *)(input), "bottom");
#line 113
								if (tmp___45 == 0) {
#line 115
									fscanf(fp, " %d ", &bottom);
#line 116
									tile->bottom = bottom;
								}
								else {
#line 118
									tmp___44 = strcmp((char const   *)(input), "top");
#line 118
									if (tmp___44 == 0) {
#line 120
										fscanf(fp, " %d ", &top___0);
#line 121
										tile->top = top___0;
#line 122
										ptr->cheight = top___0 - bottom;
#line 123
										ptr->clength = right - left___0;
									}
									else {
#line 125
										tmp___43 = strcmp((char const   *)(input), "pin");
#line 125
										if (tmp___43 == 0) {
#line 127
											fscanf(fp, " %s ", input);
#line 128
											fscanf(fp, " %s ", input);
#line 129
											fscanf(fp, " %s ", input);
#line 130
											fscanf(fp, " %s ", input);
#line 131
											strcpy(netname, (char const   *)(input));
#line 132
											tmp___18 = strcmp((char const   *)(input), "TW_PASS_THRU");
#line 132
											if (tmp___18 != 0) {
#line 133
												netx = hashfind(input);
#line 134
												if ((unsigned int)(*(netarray + netx))->name == (unsigned int)((void *)0)) {
#line 135
													tmp___10 = strlen((char const   *)(input));
#line 135
													tmp___11 = safe_malloc((tmp___10 + 1U) * sizeof(char));
#line 135
													(*(netarray + netx))->name = tmp___11;
#line 137
													sprintf((*(netarray + netx))->name, "%s", input);
												}
#line 139
												tot = 1;
#line 141
												(ptr->numterms)++;
#line 143
												if (ptr->numterms == 1) {
#line 144
													tmp___13 = safe_malloc(sizeof(TEBOX));
#line 144
													tmp___12 = (struct termbox *)tmp___13;
#line 144
													(ptr->tileptr)->termsptr = tmp___12;
#line 144
													term = tmp___12;
												}
												else {
#line 147
													tmp___15 = safe_malloc(sizeof(TEBOX));
#line 147
													tmp___14 = (struct termbox *)tmp___15;
#line 147
													term->nextterm = tmp___14;
#line 147
													term = tmp___14;
												}
#line 150
												term->nextterm = (struct termbox *)((void *)0);
#line 151
												pinctr++;
#line 151
												term->cellterm = pinctr;
#line 152
												term->ue = 0;
#line 154
												saveptr = (*(netarray + netx))->netptr;
#line 155
												tmp___17 = safe_malloc(sizeof(NBOX));
#line 155
												tmp___16 = (struct netbox *)tmp___17;
#line 155
												(*(netarray + netx))->netptr = tmp___16;
#line 155
												netptr = tmp___16;
#line 157
												netptr->nterm = saveptr;
#line 158
												netptr->terminal = pinctr;
#line 159
												netptr->net = netx;
#line 160
												netptr->xpos = 0;
#line 161
												netptr->ypos = 0;
#line 162
												netptr->newx = 0;
#line 163
												netptr->newy = 0;
#line 164
												netptr->flag = (char)0;
#line 165
												netptr->cell = cell___0 + terms;
#line 167
												if (pin_layers_given != 0) {
#line 168
													fscanf(fp, " %s ", input);
#line 169
													fscanf(fp, " %d ", &layer);
												}
#line 171
												fscanf(fp, " %d %d ", &xpos, &ypos);
#line 172
												totx = xpos;
#line 173
												toty = ypos;
#line 174
												term->txpos[0] = xpos;
#line 175
												term->typos[0] = ypos;
											}
											else {
#line 177
												implicit_feed_count++;
#line 178
												if (pin_layers_given != 0) {
#line 179
													fscanf(fp, " %s ", input);
#line 180
													fscanf(fp, " %d ", &layer);
												}
#line 182
												fscanf(fp, " %d %d ", &xpos, &ypos);
											}
										}
										else {
#line 185
											tmp___42 = strcmp((char const   *)(input), "equiv");
#line 185
											if (tmp___42 == 0) {
#line 187
												fscanf(fp, " %s ", input);
#line 188
												fscanf(fp, " %s ", input);
#line 189
												if (pin_layers_given != 0) {
#line 190
													fscanf(fp, " %s ", input);
#line 191
													fscanf(fp, " %d ", &layer);
												}
#line 193
												fscanf(fp, " %d %d ", &xpos, &ypos);
#line 194
												tmp___19 = strcmp((char const   *)(netname), "TW_PASS_THRU");
#line 194
												if (tmp___19 != 0) {
#line 195
													tot++;
#line 196
													totx += xpos;
#line 197
													toty += ypos;
#line 198
													term->txpos[0] = totx / tot;
#line 199
													if (terms == 0) {
#line 200
														term->typos[0] = 0;
													}
													else {
#line 202
														term->typos[0] = toty / tot;
													}
												}
											}
											else {
#line 206
												tmp___41 = strcmp((char const   *)(input), "unequiv");
#line 206
												if (tmp___41 == 0) {
#line 208
													fscanf(fp, " %s ", input);
#line 209
													fscanf(fp, " %s ", input);
#line 210
													if (pin_layers_given != 0) {
#line 211
														fscanf(fp, " %s ", input);
#line 212
														fscanf(fp, " %d ", &layer);
													}
#line 214
													fscanf(fp, " %d %d ", &xpos, &ypos);
#line 215
													tot++;
#line 216
													totx += xpos;
#line 217
													term->txpos[0] = totx / tot;
#line 218
													term->typos[0] = 0;
#line 219
													term->ue = 1;
												}
												else {
#line 221
													tmp___40 = strcmp((char const   *)(input), "pad");
#line 221
													if (tmp___40 == 0) {
#line 223
														terms++;
#line 224
														fscanf(fp, " %s ", input);
#line 225
														fscanf(fp, " %s ", input);
#line 226
														ptr = *(carray + (numcells + terms));
#line 227
														tmp___20 = strlen((char const   *)(input));
#line 227
														tmp___21 = safe_malloc((tmp___20 + 1U) * sizeof(char));
#line 227
														ptr->cname = tmp___21;
#line 229
														sprintf(ptr->cname, "%s", input);
#line 230
														ptr->cclass = 0;
#line 231
														ptr->orflag = (char)0;
													}
													else {
#line 233
														tmp___39 = strcmp((char const   *)(input), "orient");
#line 233
														if (tmp___39 == 0) {
#line 235
															fscanf(fp, " %d ", &orient);
#line 236
															ptr->corient = (char)orient;
														}
														else {
#line 238
															tmp___38 = strcmp((char const   *)(input), "padside");
#line 238
															if (tmp___38 == 0) {
#line 240
																fscanf(fp, " %s ", input);
#line 241
																tmp___36 = strcmp((char const   *)(input), "L");
#line 241
																if (tmp___36 == 0) {
#line 242
																	ptr->padside = 1;
																}
																else {
#line 243
																	tmp___35 = strcmp((char const   *)(input), "T");
#line 243
																	if (tmp___35 == 0) {
#line 244
																		ptr->padside = 2;
																	}
																	else {
#line 245
																		tmp___34 = strcmp((char const   *)(input), "R");
#line 245
																		if (tmp___34 == 0) {
#line 246
																			ptr->padside = 3;
																		}
																		else {
#line 247
																			tmp___33 = strcmp((char const   *)(input), "B");
#line 247
																			if (tmp___33 == 0) {
#line 248
																				ptr->padside = 4;
																			}
																			else {
#line 249
																				tmp___32 = strcmp((char const   *)(input), "5");
#line 249
																				if (tmp___32 == 0) {
#line 250
																					ptr->padside = 5;
																				}
																				else {
#line 251
																					tmp___31 = strcmp((char const   *)(input),
																						"6");
#line 251
																					if (tmp___31 == 0) {
#line 252
																						ptr->padside = 6;
																					}
																					else {
#line 253
																						tmp___30 = strcmp((char const   *)(input),
																							"7");
#line 253
																						if (tmp___30 == 0) {
#line 254
																							ptr->padside = 7;
																						}
																						else {
#line 255
																							tmp___29 = strcmp((char const   *)(input),
																								"8");
#line 255
																							if (tmp___29 == 0) {
#line 256
																								ptr->padside = 8;
																							}
																							else {
#line 257
																								tmp___28 = strcmp((char const   *)(input),
																									"9");
#line 257
																								if (tmp___28 == 0) {
#line 258
																									ptr->padside = 9;
																								}
																								else {
#line 259
																									tmp___27 = strcmp((char const   *)(input),
																										"10");
#line 259
																									if (tmp___27 == 0) {
#line 260
																										ptr->padside = 10;
																									}
																									else {
#line 261
																										tmp___26 = strcmp((char const   *)(input),
																											"11");
#line 261
																										if (tmp___26 == 0) {
#line 262
																											printf("macro at position 11 is no longer supported -- sorry!\n");
#line 263
																											exit(1);
#line 264
																											ptr->padside = 11;
																										}
																										else {
#line 265
																											tmp___25 = strcmp((char const   *)(input),
																												"MT");
#line 265
																											if (tmp___25 == 0) {
#line 266
																												printf("macro at position MT is no longer supported -- sorry!\n");
#line 267
																												exit(1);
#line 268
																												ptr->padside = 12;
																											}
																											else {
#line 269
																												tmp___24 = strcmp((char const   *)(input),
																													"MM");
#line 269
																												if (tmp___24 == 0) {
#line 270
																													printf("macro at position MM is no longer supported -- sorry!\n");
#line 271
																													exit(1);
#line 272
																													ptr->padside = 13;
																												}
																												else {
#line 273
																													tmp___23 = strcmp((char const   *)(input),
																														"MTT");
#line 273
																													if (tmp___23 == 0) {
#line 274
																														ptr->padside = 14;
																													}
																													else {
#line 275
																														tmp___22 = strcmp((char const   *)(input),
																															"15");
#line 275
																														if (tmp___22 == 0) {
#line 276
																															ptr->padside = 15;
																														}
																														else {
#line 278
																															fprintf(fpo, "padside not specified properly for ");
#line 279
																															fprintf(fpo, "pad: %s\n",
																																ptr->cname);
#line 280
																															exit(1);
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															else {
#line 282
																tmp___37 = strcmp((char const   *)(input), "sidespace");
#line 282
																if (tmp___37 == 0) {
#line 283
																	fscanf(fp, " %f ", &space___0);
#line 284
																	if (ptr->padside == 1) {
#line 285
																		* (fixLRBT + 0) = 1;
#line 286
																		* (padspace + terms) = space___0;
																	}
																	else {
#line 287
																		if (ptr->padside == 3) {
#line 288
																			* (fixLRBT + 1) = 1;
#line 289
																			* (padspace + terms) = space___0;
																		}
																		else {
#line 290
																			if (ptr->padside == 4) {
#line 291
																				* (fixLRBT + 2) = 1;
#line 292
																				* (padspace + terms) = space___0;
																			}
																			else {
#line 293
																				if (ptr->padside == 2) {
#line 294
																					* (fixLRBT + 3) = 1;
#line 295
																					* (padspace + terms) = space___0;
																				}
																				else {
#line 297
																					macspace[ptr->padside] = space___0;
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
#line 307
		cell___0 = 1;
#line 307
		while (cell___0 <= numcells) {
#line 308
			if ((int)(*(carray + cell___0))->orflag == 1) {
#line 309
				if (maxCellO == 0) {
#line 310
					maxCellO = 2;
				}
				else {
#line 311
					if (maxCellO == 1) {
#line 312
						maxCellO = 3;
					}
				}
#line 314
				break;
			}
#line 307
			cell___0++;
		}
#line 319
		cell___0 = 1;
#line 319
		while (cell___0 <= numcells) {
#line 321
			ptr = *(carray + cell___0);
#line 322
			tptr = ptr->tileptr;
#line 324
			tmptr = tptr->termsptr;
#line 324
			while ((unsigned int)tmptr != (unsigned int)((void *)0)) {
#line 326
				if (ptr->clength % 2 != 0) {
#line 327
					tmptr->txpos[1] = -tmptr->txpos[0] + 1;
				}
				else {
#line 329
					tmptr->txpos[1] = -tmptr->txpos[0];
				}
#line 331
				if (ptr->cheight % 2 != 0) {
#line 332
					tmptr->typos[1] = -tmptr->typos[0] + 1;
				}
				else {
#line 334
					tmptr->typos[1] = -tmptr->typos[0];
				}
#line 324
				tmptr = tmptr->nextterm;
			}
#line 319
			cell___0++;
		}
#line 340
		cell___0 = numcells + 1;
#line 340
		while (cell___0 <= numcells + numterms) {
#line 342
			ptr = *(carray + cell___0);
#line 343
			tptr = ptr->tileptr;
#line 344
			orient = (int)ptr->corient;
#line 345
			move(orient);
#line 346
			rect(&tptr->left, &tptr->bottom, &tptr->right, &tptr->top);
#line 348
			if (ptr->cheight % 2 != 0) {
#line 348
				if (orient == 4) {
#line 350
					(tptr->left)++;
#line 351
					(tptr->right)++;
				}
				else {
#line 348
					if (orient == 6) {
#line 350
						(tptr->left)++;
#line 351
						(tptr->right)++;
					}
					else {
						goto _L;
					}
				}
			}
			else {
			_L: /* CIL Label */
#line 348
				if (ptr->clength % 2 != 0) {
#line 348
					if (orient == 2) {
#line 350
						(tptr->left)++;
#line 351
						(tptr->right)++;
					}
					else {
#line 348
						if (orient == 3) {
#line 350
							(tptr->left)++;
#line 351
							(tptr->right)++;
						}
					}
				}
			}
#line 353
			if (ptr->cheight % 2 != 0) {
#line 353
				if (orient == 1) {
#line 355
					(tptr->bottom)++;
#line 356
					(tptr->top)++;
				}
				else {
#line 353
					if (orient == 3) {
#line 355
						(tptr->bottom)++;
#line 356
						(tptr->top)++;
					}
					else {
						goto _L___0;
					}
				}
			}
			else {
			_L___0: /* CIL Label */
#line 353
				if (ptr->clength % 2 != 0) {
#line 353
					if (orient == 4) {
#line 355
						(tptr->bottom)++;
#line 356
						(tptr->top)++;
					}
					else {
#line 353
						if (orient == 7) {
#line 355
							(tptr->bottom)++;
#line 356
							(tptr->top)++;
						}
					}
				}
			}
#line 359
			tmptr = tptr->termsptr;
#line 359
			while ((unsigned int)tmptr != (unsigned int)((void *)0)) {
#line 361
				tmptr->txpos[1] = tmptr->txpos[0];
#line 362
				tmptr->typos[1] = tmptr->typos[0];
#line 363
				point(&tmptr->txpos[1], &tmptr->typos[1]);
#line 364
				if (ptr->cheight % 2 != 0) {
#line 364
					if (orient == 4) {
#line 366
						(tmptr->txpos[1])++;
					}
					else {
#line 364
						if (orient == 6) {
#line 366
							(tmptr->txpos[1])++;
						}
						else {
							goto _L___1;
						}
					}
				}
				else {
				_L___1: /* CIL Label */
#line 364
					if (ptr->clength % 2 != 0) {
#line 364
						if (orient == 2) {
#line 366
							(tmptr->txpos[1])++;
						}
						else {
#line 364
							if (orient == 3) {
#line 366
								(tmptr->txpos[1])++;
							}
						}
					}
				}
#line 368
				if (ptr->cheight % 2 != 0) {
#line 368
					if (orient == 1) {
#line 370
						(tmptr->typos[1])++;
					}
					else {
#line 368
						if (orient == 3) {
#line 370
							(tmptr->typos[1])++;
						}
						else {
							goto _L___2;
						}
					}
				}
				else {
				_L___2: /* CIL Label */
#line 368
					if (ptr->clength % 2 != 0) {
#line 368
						if (orient == 4) {
#line 370
							(tmptr->typos[1])++;
						}
						else {
#line 368
							if (orient == 7) {
#line 370
								(tmptr->typos[1])++;
							}
						}
					}
				}
#line 359
				tmptr = tmptr->nextterm;
			}
#line 340
			cell___0++;
		}
#line 380
		configure();
#line 385
		tmp___52 = safe_realloc((char *)carray, (unsigned int)((1 + numcells) + numterms) * sizeof(CBOXPTR));
#line 385
		carray = (CBOXPTR *)tmp___52;
#line 388
		block___0 = 1;
#line 388
		while (block___0 <= numblock) {
#line 389
			totallen += (*(barray + block___0))->blength;
#line 388
			block___0++;
		}
#line 391
		fprintf(fpo, "total cell length: %d\n", celllen);
#line 392
		fprintf(fpo, "total block length: %d\n", totallen);
#line 397
		return;
	}
}
#line 1 "readnets.o"
#pragma merger(0,"./readnets.i","")
#line 4 "readnets.c"
int readnets(FILE *fp)
{
	int net;
	int test;
	int status;
	float Hweight;
	float Vweight;
	float beta;
	float total_weight;
	NBOXPTR netptr;
	char input[1024];
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;

	{
#line 14
		fscanf(fp, " %s ", input);
#line 15
		tmp = strcmp((char const   *)(input), "allnets");
#line 15
		if (tmp != 0) {
#line 16
			fprintf(fpo, "The keyword allnets was ");
#line 17
			fprintf(fpo, "not properly entered in the .net file\n");
#line 18
			exit(1);
		}
#line 20
		fscanf(fp, " %s ", input);
#line 21
		tmp___0 = strcmp((char const   *)(input), "HVweights");
#line 21
		if (tmp___0 != 0) {
#line 22
			fprintf(fpo, "The keyword HVweights was ");
#line 23
			fprintf(fpo, "not properly entered in the .net file\n");
#line 24
			exit(1);
		}
#line 26
		test = fscanf(fp, "%f %f", &Hweight, &Vweight);
#line 27
		if (test != 2) {
#line 28
			fprintf(fpo, "The net weights for allnets were ");
#line 29
			fprintf(fpo, "not properly entered in the .net file\n");
#line 30
			exit(1);
		}
#line 32
		if ((double)Hweight <= 0.0) {
#line 33
			fprintf(fpo, "A global net weight was ");
#line 34
			fprintf(fpo, "zero or negative in the \n");
#line 35
			fprintf(fpo, ".net file\n");
#line 36
			fprintf(fpo, "This is not allowed; choose .0001 instead\n");
#line 37
			exit(1);
		}
		else {
#line 32
			if ((double)Vweight <= 0.0) {
#line 33
				fprintf(fpo, "A global net weight was ");
#line 34
				fprintf(fpo, "zero or negative in the \n");
#line 35
				fprintf(fpo, ".net file\n");
#line 36
				fprintf(fpo, "This is not allowed; choose .0001 instead\n");
#line 37
				exit(1);
			}
		}
#line 40
		if ((double)Vweight < 1.0) {
#line 41
			Vweight = (float)1.0;
		}
#line 43
		net = 1;
#line 43
		while (net <= numnets) {
#line 44
			(*(netarray + net))->Hweight = Hweight;
#line 45
			(*(netarray + net))->Vweight = Vweight;
#line 43
			net++;
		}
#line 48
		while (1) {
#line 48
			tmp___5 = fscanf(fp, " %s ", input);
#line 48
			if (!(tmp___5 == 1)) {
#line 48
				break;
			}
#line 49
			tmp___4 = strcmp((char const   *)(input), "net");
#line 49
			if (tmp___4 == 0) {
#line 50
				fscanf(fp, " %s ", input);
#line 51
				status = hashfind(input);
#line 52
				if (status == 0) {
#line 53
					fprintf(fpo, "The net named: %s  in the .net file\n", input);
#line 55
					fprintf(fpo, "was not encountered while reading\n");
#line 56
					fprintf(fpo, "the .cel file --- FATAL error\n");
#line 57
					exit(1);
				}
			}
			else {
#line 59
				tmp___3 = strcmp((char const   *)(input), "HVweights");
#line 59
				if (tmp___3 == 0) {
#line 60
					test = fscanf(fp, "%f %f", &Hweight, &Vweight);
#line 61
					if (test != 2) {
#line 62
						fprintf(fpo, "The critical net weights were ");
#line 63
						fprintf(fpo, "not properly entered\n");
#line 64
						fprintf(fpo, "in the .net file after net: %s\n", input);
#line 66
						exit(1);
					}
#line 68
					if ((double)Hweight <= 0.0) {
#line 69
						fprintf(fpo, "A critical net weight was ");
#line 70
						fprintf(fpo, "zero or negative in the \n");
#line 71
						fprintf(fpo, ".net file after net: %s\n", input);
#line 72
						fprintf(fpo, "This is not allowed; choose .0001 instead\n");
#line 73
						exit(1);
					}
					else {
#line 68
						if ((double)Vweight <= 0.0) {
#line 69
							fprintf(fpo, "A critical net weight was ");
#line 70
							fprintf(fpo, "zero or negative in the \n");
#line 71
							fprintf(fpo, ".net file after net: %s\n", input);
#line 72
							fprintf(fpo, "This is not allowed; choose .0001 instead\n");
#line 73
							exit(1);
						}
					}
#line 75
					(*(netarray + status))->Hweight = Hweight;
#line 76
					(*(netarray + status))->Vweight = Vweight;
				}
				else {
#line 77
					tmp___2 = strcmp((char const   *)(input), "nofeeds");
#line 77
					if (tmp___2 == 0) {
#line 78
						(*(netarray + status))->feedflag = (char)1;
					}
					else {
#line 79
						tmp___1 = strcmp((char const   *)(input), "ignore");
#line 79
						if (tmp___1 == 0) {
#line 80
							(*(netarray + status))->ignore = (char)1;
						}
						else {
#line 82
							fprintf(fpo, "unexpected keyword in the .net file\n");
#line 83
							exit(1);
						}
					}
				}
			}
		}
#line 87
		delHtab();
#line 90
		if (!no_net_normalize) {
#line 91
			total_weight = (float)0;
#line 92
			net = 1;
#line 92
			while (net <= numnets) {
#line 93
				total_weight += (*(netarray + net))->Hweight + (*(netarray + net))->Vweight;
#line 92
				net++;
			}
#line 95
			beta = (float)((2.0 * (double)((float)numnets)) / (double)total_weight);
#line 97
			net = 1;
#line 97
			while (net <= numnets) {
#line 98
				(*(netarray + net))->Hweight *= beta;
#line 99
				(*(netarray + net))->Vweight *= beta;
#line 97
				net++;
			}
		}
#line 105
		net = 1;
#line 105
		while (net <= numnets) {
#line 106
			netptr = (*(netarray + net))->netptr;
#line 106
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 108
				* (tearray + netptr->terminal) = netptr;
#line 109
				(*(tearray + netptr->terminal))->net = net;
#line 106
				netptr = netptr->nterm;
			}
#line 105
			net++;
		}
#line 112
		return;
	}
}
#line 1 "readpar.o"
#pragma merger(0,"./readpar.i","")
#line 4 "readpar.c"
void readParFile(void)
{
	FILE *fp;
	char filename[64];
	char input[64];
	int test;
	float f;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	int tmp___7;
	int tmp___8;
	int tmp___9;
	int tmp___10;
	int tmp___11;
	int tmp___12;
	int tmp___13;
	int tmp___14;
	int tmp___15;
	int tmp___16;
	int tmp___17;
	int tmp___18;
	int tmp___19;
	int tmp___20;
	int tmp___21;
	int tmp___22;
	int tmp___23;
	int tmp___24;
	int tmp___25;

	{
#line 11
		sprintf(filename, "%s.par", cktName);
#line 12
		fp = twopen((int)(filename), (int)"r", 1);
#line 13
		route2act = -1;
#line 14
		routeGrid = -1;
#line 15
		gridCell = -1;
#line 17
		while (1) {
#line 17
			tmp___25 = fscanf(fp, " %s ", input);
#line 17
			if (!(tmp___25 == 1)) {
#line 17
				break;
			}
#line 19
			tmp___24 = strcmp((char const   *)(input), "implicit.feed.thru.range");
#line 19
			if (tmp___24 == 0) {
#line 21
				test = fscanf(fp, " %f ", &imprange);
#line 22
				if (test != 1) {
#line 23
					fprintf(fpo, "The value of implicit.feed.thru.range");
#line 24
					fprintf(fpo, " was not properly");
#line 25
					fprintf(fpo, "entered in the .par file\n");
#line 26
					exit(1);
				}
			}
			else {
#line 29
				tmp___23 = strcmp((char const   *)(input), "fast");
#line 29
				if (tmp___23 == 0) {
#line 30
					test = fscanf(fp, " %d ", &tw_fast);
#line 31
					if (test != 1) {
#line 32
						fprintf(fpo, "The value of fast was not ");
#line 33
						fprintf(fpo, "properly entered in the .par file\n");
#line 34
						exit(1);
					}
				}
				else {
#line 37
					tmp___22 = strcmp((char const   *)(input), "slow");
#line 37
					if (tmp___22 == 0) {
#line 38
						test = fscanf(fp, " %d ", &tw_slow);
#line 39
						if (test != 1) {
#line 40
							fprintf(fpo, "The value of fast was not ");
#line 41
							fprintf(fpo, "properly entered in the .par file\n");
#line 42
							exit(1);
						}
					}
					else {
#line 45
						tmp___21 = strcmp((char const   *)(input), "pin_layers_given");
#line 45
						if (tmp___21 == 0) {
#line 46
							pin_layers_given = 1;
						}
						else {
#line 48
							tmp___20 = strcmp((char const   *)(input), "gate_array_special");
#line 48
							if (tmp___20 == 0) {
#line 49
								gate_array_special = 1;
							}
							else {
#line 51
								tmp___19 = strcmp((char const   *)(input), "connection_machine");
#line 51
								if (tmp___19 == 0) {
#line 52
									connection_machine = 1;
								}
								else {
#line 54
									tmp___18 = strcmp((char const   *)(input), "no_feeds_side_nets");
#line 54
									if (tmp___18 == 0) {
#line 55
										no_feeds_side_nets = 0;
									}
									else {
#line 57
										tmp___17 = strcmp((char const   *)(input), "no_net_normalize");
#line 57
										if (tmp___17 == 0) {
#line 58
											no_net_normalize = 1;
										}
										else {
#line 60
											tmp___16 = strcmp((char const   *)(input), "estimate_feeds");
#line 60
											if (tmp___16 == 0) {
#line 61
												estimate_feeds = 1;
											}
											else {
#line 63
												tmp___15 = strcmp((char const   *)(input), "cost_only");
#line 63
												if (tmp___15 == 0) {
#line 64
													costonly = 1;
												}
												else {
#line 66
													tmp___14 = strcmp((char const   *)(input), "do.global.route");
#line 66
													if (tmp___14 == 0) {
#line 67
														doglobal = 1;
													}
													else {
#line 69
														tmp___13 = strcmp((char const   *)(input), "do.global.route.cell.swaps");
#line 69
														if (tmp___13 == 0) {
#line 70
															cswaps = 1;
#line 71
															stopdeg = (float)0.3;
														}
														else {
#line 73
															tmp___12 = strcmp((char const   *)(input), "full");
#line 73
															if (tmp___12 == 0) {
#line 74
																if (cswaps) {
#line 75
																	stopdeg = (float)0.5;
																}
															}
															else {
#line 78
																tmp___11 = strcmp((char const   *)(input), "feedThruWidth");
#line 78
																if (tmp___11 == 0) {
#line 79
																	test = fscanf(fp, " %d ", &fdWidth);
#line 80
																	if (test != 1) {
#line 81
																		fprintf(fpo, "The value of feedThruWidth was not ");
#line 82
																		fprintf(fpo, "properly entered in the .par file\n");
#line 83
																		exit(1);
																	}
																}
																else {
#line 86
																	tmp___10 = strcmp((char const   *)(input), "layer");
#line 86
																	if (tmp___10 == 0) {
#line 87
																		test = fscanf(fp, " %d ", &feedLayer);
#line 88
																		if (test != 1) {
#line 89
																			fprintf(fpo, "The value of layer was not ");
#line 90
																			fprintf(fpo, "properly entered in the .par file\n");
#line 91
																			exit(1);
																		}
#line 93
																		if (feedLayer != 1) {
#line 93
																			if (feedLayer != 2) {
#line 93
																				if (feedLayer != 3) {
#line 94
																					fprintf(fpo, "The value of layer must currently be one of ");
#line 95
																					fprintf(fpo, "1, 2, or 3 \n");
#line 96
																					exit(1);
																				}
																				else {
#line 98
																					feedLayer--;
																				}
																			}
																			else {
#line 98
																				feedLayer--;
																			}
																		}
																		else {
#line 98
																			feedLayer--;
																		}
																	}
																	else {
#line 101
																		tmp___9 = strcmp((char const   *)(input), "addFeeds");
#line 101
																		if (tmp___9 == 0) {
#line 102
																			addFeeds = 1;
																		}
																		else {
#line 104
																			tmp___8 = strcmp((char const   *)(input), "indent");
#line 104
																			if (tmp___8 == 0) {
#line 105
																				test = fscanf(fp, " %f ", &indent);
#line 106
																				indent = (float)1.0;
																			}
																			else {
#line 109
																				tmp___7 = strcmp((char const   *)(input), "random.seed");
#line 109
																				if (tmp___7 == 0) {
#line 111
																					test = fscanf(fp, " %d ", &randomSeed);
#line 113
																					if (test != 1) {
#line 114
																						fprintf(fpo, "The value of random.seed was not ");
#line 115
																						fprintf(fpo, "properly entered in the .par file\n");
#line 116
																						exit(1);
																					}
																				}
																				else {
#line 119
																					tmp___6 = strcmp((char const   *)(input),
																						"random.seed2");
#line 119
																					if (tmp___6 == 0) {
#line 121
																						test = fscanf(fp, " %d ", &randomSeed2);
#line 123
																						if (test != 1) {
#line 124
																							fprintf(fpo, "The value of random.seed2 was not ");
#line 125
																							fprintf(fpo, "properly entered in the .par file\n");
#line 126
																							exit(1);
																						}
																					}
																					else {
#line 129
																						tmp___5 = strcmp((char const   *)(input),
																							"rowSep");
#line 129
																						if (tmp___5 == 0) {
#line 131
																							test = fscanf(fp, " %f ", &rowSep);
#line 133
																							if (test != 1) {
#line 134
																								fprintf(fpo, "The value of rowSep was not properly");
#line 135
																								fprintf(fpo, "entered in the .par file\n");
#line 136
																								exit(1);
																							}
																						}
																						else {
#line 139
																							tmp___4 = strcmp((char const   *)(input),
																								"restart");
#line 139
																							if (tmp___4 == 0) {
#line 140
																								resume_run = 1;
																							}
																							else {
#line 149
																								tmp___3 = strcmp((char const   *)(input),
																									"track.spacing");
#line 149
																								if (tmp___3 == 0) {
#line 150
																									uneven_cell_height = 1;
#line 151
																									test = fscanf(fp, " %d ", &track_spacing);
#line 152
																									if (test != 1) {
#line 153
																										fprintf(fpo, "The value of trackSpacing was not properly");
#line 154
																										fprintf(fpo, "entered in the .par file\n");
#line 155
																										exit(1);
																									}
																								}
																								else {
#line 158
																									tmp___2 = strcmp((char const   *)(input),
																										"one.pin.feedthru");
#line 158
																									if (tmp___2 == 0) {
#line 159
																										one_pin_feedthru = 1;
																									}
																									else {
#line 161
																										tmp___1 = strcmp((char const   *)(input),
																											"route2act");
#line 161
																										if (tmp___1 == 0) {
#line 162
																											test = fscanf(fp, " %d ", &route2act);
#line 163
																											if (test != 1) {
#line 164
																												fprintf(fpo, "The value of route2act was not properly");
#line 165
																												fprintf(fpo, "entered in the .par file\n");
#line 166
																												exit(1);
																											}
																										}
																										else {
#line 169
																											tmp___0 = strcmp((char const   *)(input),
																												"gridCell");
#line 169
																											if (tmp___0 == 0) {
#line 170
																												test = fscanf(fp, " %d ", &gridCell);
#line 171
																												if (test != 1) {
#line 172
																													fprintf(fpo, "The value of gridCell was not properly");
#line 173
																													fprintf(fpo, "entered in the .par file\n");
#line 174
																													exit(1);
																												}
																											}
																											else {
#line 177
																												tmp = strcmp((char const   *)(input),
																													"routeGrid");
#line 177
																												if (tmp == 0) {
#line 178
																													test = fscanf(fp, " %d ",
																														&routeGrid);
#line 179
																													if (test != 1) {
#line 180
																														fprintf(fpo, "The value of routeGrid was not properly");
#line 181
																														fprintf(fpo, "entered in the .par file\n");
#line 182
																														exit(1);
																													}
																												}
																												else {
#line 186
																													fprintf(fpo, "Unparsable keyword>>> %s\n",
																														input);
#line 187
																													fprintf(fpo, "was found in the .par file\n");
#line 188
																													exit(1);
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
#line 191
		twclose((int)fp);
#line 193
		sprintf(filename, "%s.rs2", cktName);
#line 194
		fp = twopen((int)(filename), (int)"r", 0);
#line 194
		if (fp) {
#line 194
			if (resume_run == 1) {
#line 195
				fscanf(fp, "%f", &f);
#line 196
				fscanf(fp, "%d", &stage);
#line 197
				fscanf(fp, "%d", &stage);
#line 198
				fscanf(fp, "%d", &stage);
#line 199
				fprintf(fpo, "\n\nNOTE: Restart file .rs2 will be used \n\n");
#line 200
				twclose((int)fp);
#line 201
				restart = 1;
			}
			else {
#line 203
				stage = 1;
#line 204
				fprintf(fpo, "\n\nNOTE: Restart file .rs2 not used\n\n");
#line 205
				restart = 0;
			}
		}
		else {
#line 203
			stage = 1;
#line 204
			fprintf(fpo, "\n\nNOTE: Restart file .rs2 not used\n\n");
#line 205
			restart = 0;
		}
#line 208
		if (cswaps != 0) {
#line 209
			if (doglobal == 0) {
#line 210
				fprintf(fpo, "user specified cell swaps ");
#line 211
				fprintf(fpo, "without requesting do.global.route\n");
#line 212
				exit(1);
			}
		}
#line 215
		if (doglobal) {
#line 216
			fprintf(fpo, "TimberWolf will perform a global route step\n");
		}
#line 218
		if (cswaps) {
#line 219
			fprintf(fpo, "TimberWolf will perform final cell placements\n");
#line 220
			fprintf(fpo, " by swapping cells based on minimization of\n");
#line 221
			fprintf(fpo, " the total number of routing tracks required\n");
		}
#line 223
		if (addFeeds) {
#line 223
			if ((double)imprange < 0.0) {
#line 224
				fprintf(fpo, "implicit.feed.thru.range was ");
#line 225
				fprintf(fpo, "not entered in the .par file\n");
#line 226
				exit(1);
			}
		}
#line 228
		if ((double)rowSep < 0.0) {
#line 229
			fprintf(fpo, "rowSep was not entered in the .par file\n");
#line 230
			exit(1);
		}
		else {
#line 232
			fprintf(fpo, "rowSep: %f\n", rowSep);
		}
#line 234
		if (addFeeds == 1) {
#line 234
			if (fdWidth == -1) {
#line 235
				fprintf(fpo, "feedThruWidth was not entered in the .par file\n");
#line 236
				exit(1);
			}
			else {
#line 238
				fprintf(fpo, "feedThruWidth: %d\n", fdWidth);
			}
		}
		else {
#line 238
			fprintf(fpo, "feedThruWidth: %d\n", fdWidth);
		}
#line 242
		return;
	}
}
#line 1 "readseg.o"
#pragma merger(0,"./readseg.i","")
#line 11 "readseg.c"
void readseg(FILE *fp)
{
	int segment;
	int net;
	int net1;
	int net2;
	int key_flag;
	int channel;
	int pin1;
	int pin2;
	int ltop;
	int rtop;
	int lbot;
	int rbot;
	int Tleft;
	int Tright;
	int Bleft;
	int Bright;
	char input[16];
	SEGBOXPTR tmp_ptr;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	char *tmp___3;
	char *tmp___4;
	char *tmp___5;
	char *tmp___6;
	char *tmp___7;
	char *tmp___8;
	char *tmp___9;
	char *tmp___10;
	char *tmp___11;
	char *tmp___12;
	char *tmp___13;
	char *tmp___14;
	int tmp___15;
	int tmp___16;
	int tmp___17;
	int tmp___18;

	{
#line 21
		segment = 0;
#line 22
		numSwSegs = 0;
#line 23
		numSegs = 0;
#line 25
		while (1) {
#line 25
			tmp___2 = fscanf(fp, " %s ", input);
#line 25
			if (!(tmp___2 == 1)) {
#line 25
				break;
			}
#line 26
			tmp___1 = strcmp((char const   *)(input), "net");
#line 26
			if (tmp___1 == 0) {
#line 27
				fscanf(fp, " %d ", &net);
			}
			else {
#line 28
				tmp___0 = strcmp((char const   *)(input), "segment");
#line 28
				if (tmp___0 == 0) {
#line 29
					numSegs++;
#line 30
					fscanf(fp, " %s ", input);
#line 31
					tmp = strcmp((char const   *)(input), "channel");
#line 31
					if (tmp == 0) {
#line 32
						fscanf(fp, "%d", &channel);
#line 33
						fscanf(fp, " %s ", input);
#line 34
						fscanf(fp, "%d", &pin1);
#line 35
						fscanf(fp, " %s ", input);
#line 36
						fscanf(fp, "%d", &pin2);
#line 37
						fscanf(fp, "%d", &ltop);
#line 38
						fscanf(fp, "%d", &rtop);
					}
					else {
#line 40
						numSwSegs++;
#line 41
						fscanf(fp, "%d", &key_flag);
#line 42
						fscanf(fp, " %s ", input);
#line 43
						fscanf(fp, " %s ", input);
#line 44
						fscanf(fp, "%d", &channel);
#line 45
						fscanf(fp, " %s ", input);
#line 46
						fscanf(fp, "%d", &pin1);
#line 47
						fscanf(fp, " %s ", input);
#line 48
						fscanf(fp, "%d", &pin2);
#line 49
						fscanf(fp, "%d", &ltop);
#line 50
						fscanf(fp, "%d", &rtop);
#line 51
						fscanf(fp, " %s ", input);
#line 52
						fscanf(fp, " %s ", input);
#line 53
						fscanf(fp, "%d", &channel);
#line 54
						fscanf(fp, " %s ", input);
#line 55
						fscanf(fp, "%d", &pin1);
#line 56
						fscanf(fp, " %s ", input);
#line 57
						fscanf(fp, "%d", &pin2);
#line 58
						fscanf(fp, "%d", &lbot);
#line 59
						fscanf(fp, "%d", &rbot);
					}
				}
			}
		}
#line 63
		fprintf(fpo, "\nTotal Number of Net Segments: %d\n", numSegs);
#line 64
		fprintf(fpo, "Number of Switchable Net Segments: %d\n\n", numSwSegs);
#line 65
		fprintf(fpo, "Number of channels: %d\n\n", numChans);
#line 66
		rewind(fp);
#line 69
		tmp___3 = safe_malloc((unsigned int)(numSegs + 1) * sizeof(SWITCHBOX));
#line 69
		aNetSeg = (struct switchbox *)tmp___3;
#line 71
		tmp___4 = safe_malloc((unsigned int)(numSegs + 1) * sizeof(int));
#line 71
		fixnetseg = (int *)tmp___4;
#line 72
		tmp___5 = safe_malloc((unsigned int)(numnets + 2) * sizeof(int));
#line 72
		anet = (int *)tmp___5;
#line 73
		net = 0;
#line 73
		while (net <= numnets + 1) {
#line 74
			* (anet + net) = 0;
#line 73
			net++;
		}
#line 76
		tmp___6 = safe_malloc((unsigned int)(numnets + 1) * sizeof(int));
#line 76
		netchgs = (int *)tmp___6;
#line 78
		while (1) {
#line 78
			tmp___18 = fscanf(fp, " %s ", input);
#line 78
			if (!(tmp___18 == 1)) {
#line 78
				break;
			}
#line 79
			tmp___17 = strcmp((char const   *)(input), "net");
#line 79
			if (tmp___17 == 0) {
#line 80
				fscanf(fp, " %d ", &net);
#line 81
				* (anet + net) = segment + 1;
			}
			else {
#line 82
				tmp___16 = strcmp((char const   *)(input), "segment");
#line 82
				if (tmp___16 == 0) {
#line 83
					segment++;
#line 84
					fscanf(fp, " %s ", input);
#line 85
					tmp___15 = strcmp((char const   *)(input), "channel");
#line 85
					if (tmp___15 == 0) {
#line 86
						fscanf(fp, "%d", &channel);
#line 87
						fscanf(fp, " %s ", input);
#line 88
						fscanf(fp, "%d", &pin1);
#line 89
						fscanf(fp, " %s ", input);
#line 90
						fscanf(fp, "%d", &pin2);
#line 91
						fscanf(fp, "%d", &ltop);
#line 92
						fscanf(fp, "%d", &rtop);
#line 93
						tmp___7 = safe_malloc(sizeof(SEGBOX));
#line 93
						(aNetSeg + segment)->top = (struct segbox *)tmp___7;
#line 95
						tmp___8 = safe_malloc(sizeof(SEGBOX));
#line 95
						(aNetSeg + segment)->bot = (struct segbox *)tmp___8;
#line 97
						tmp___9 = safe_malloc(sizeof(SEGBOX));
#line 97
						(aNetSeg + segment)->ntop = (struct segbox *)tmp___9;
#line 99
						tmp___10 = safe_malloc(sizeof(SEGBOX));
#line 99
						(aNetSeg + segment)->nbot = (struct segbox *)tmp___10;
#line 101
						(aNetSeg + segment)->net = net;
#line 102
						(aNetSeg + segment)->nflag = (char)0;
#line 103
						(aNetSeg + segment)->current = (char)0;
#line 104
						(aNetSeg + segment)->swYorN = (char)0;
#line 105
						(aNetSeg + segment)->key = 0;
#line 106
						(aNetSeg + segment)->nkey = 0;
#line 107
						((aNetSeg + segment)->top)->channel = channel;
#line 108
						((aNetSeg + segment)->top)->pin1 = pin1;
#line 109
						((aNetSeg + segment)->top)->pin2 = pin2;
#line 110
						((aNetSeg + segment)->top)->pin1ptr = (*(Tgrid + pin1))->up;
#line 111
						if ((int)(*(tearray + pin1))->pinloc == 0) {
#line 111
							if ((*(tearray + pin1))->row == channel) {
#line 113
								((aNetSeg + segment)->top)->pin1ptr = (*(Tgrid + pin1))->down;
							}
						}
#line 115
						((aNetSeg + segment)->top)->pin2ptr = (*(Tgrid + pin2))->up;
#line 116
						if ((int)(*(tearray + pin2))->pinloc == 0) {
#line 116
							if ((*(tearray + pin2))->row == channel) {
#line 118
								((aNetSeg + segment)->top)->pin2ptr = (*(Tgrid + pin2))->down;
							}
						}
					}
					else {
#line 121
						fscanf(fp, "%d", &key_flag);
#line 122
						fscanf(fp, " %s ", input);
#line 123
						fscanf(fp, " %s ", input);
#line 124
						fscanf(fp, "%d", &channel);
#line 125
						fscanf(fp, " %s ", input);
#line 126
						fscanf(fp, "%d", &pin1);
#line 127
						fscanf(fp, " %s ", input);
#line 128
						fscanf(fp, "%d", &pin2);
#line 129
						fscanf(fp, "%d", &ltop);
#line 130
						fscanf(fp, "%d", &rtop);
#line 131
						tmp___11 = safe_malloc(sizeof(SEGBOX));
#line 131
						(aNetSeg + segment)->top = (struct segbox *)tmp___11;
#line 133
						tmp___12 = safe_malloc(sizeof(SEGBOX));
#line 133
						(aNetSeg + segment)->bot = (struct segbox *)tmp___12;
#line 135
						tmp___13 = safe_malloc(sizeof(SEGBOX));
#line 135
						(aNetSeg + segment)->ntop = (struct segbox *)tmp___13;
#line 137
						tmp___14 = safe_malloc(sizeof(SEGBOX));
#line 137
						(aNetSeg + segment)->nbot = (struct segbox *)tmp___14;
#line 139
						(aNetSeg + segment)->net = net;
#line 140
						(aNetSeg + segment)->nflag = (char)0;
#line 141
						(aNetSeg + segment)->current = (char)0;
#line 142
						(aNetSeg + segment)->swYorN = (char)1;
#line 143
						if (key_flag == 0) {
#line 145
							(aNetSeg + segment)->key = 0;
						}
						else {
#line 143
							if ((*(anet + net) - 1) + key_flag == segment) {
#line 145
								(aNetSeg + segment)->key = 0;
							}
							else {
#line 147
								(aNetSeg + segment)->key = (key_flag + *(anet + net)) - 1;
							}
						}
#line 149
						(aNetSeg + segment)->nkey = 0;
#line 150
						((aNetSeg + segment)->top)->channel = channel;
#line 151
						((aNetSeg + segment)->top)->pin1 = pin1;
#line 152
						((aNetSeg + segment)->top)->pin2 = pin2;
#line 153
						if (ltop == -1) {
#line 154
							pin1 = pin2;
						}
						else {
#line 155
							if (ltop > 0) {
#line 156
								pin1 = ltop;
#line 157
								pin2 = rtop;
							}
						}
#line 159
						Tleft = (*(tearray + pin1))->xpos;
#line 160
						((aNetSeg + segment)->top)->pin1ptr = (*(Tgrid + pin1))->up;
#line 161
						if ((int)(*(tearray + pin1))->pinloc == 0) {
#line 161
							if ((*(tearray + pin1))->row == channel) {
#line 163
								((aNetSeg + segment)->top)->pin1ptr = (*(Tgrid + pin1))->down;
							}
						}
#line 165
						Tright = (*(tearray + pin2))->xpos;
#line 166
						((aNetSeg + segment)->top)->pin2ptr = (*(Tgrid + pin2))->up;
#line 167
						if ((int)(*(tearray + pin2))->pinloc == 0) {
#line 167
							if ((*(tearray + pin2))->row == channel) {
#line 169
								((aNetSeg + segment)->top)->pin2ptr = (*(Tgrid + pin2))->down;
							}
						}
#line 171
						fscanf(fp, " %s ", input);
#line 172
						fscanf(fp, " %s ", input);
#line 173
						fscanf(fp, "%d", &channel);
#line 174
						fscanf(fp, " %s ", input);
#line 175
						fscanf(fp, "%d", &pin1);
#line 176
						fscanf(fp, " %s ", input);
#line 177
						fscanf(fp, "%d", &pin2);
#line 178
						fscanf(fp, "%d", &lbot);
#line 179
						fscanf(fp, "%d", &rbot);
#line 180
						((aNetSeg + segment)->bot)->channel = channel;
#line 181
						((aNetSeg + segment)->bot)->pin1 = pin1;
#line 182
						((aNetSeg + segment)->bot)->pin2 = pin2;
#line 183
						if (lbot == -1) {
#line 184
							pin1 = pin2;
						}
						else {
#line 185
							if (lbot > 0) {
#line 186
								pin1 = lbot;
#line 187
								pin2 = rbot;
							}
						}
#line 189
						Bleft = (*(tearray + pin1))->xpos;
#line 190
						((aNetSeg + segment)->bot)->pin1ptr = (*(Tgrid + pin1))->up;
#line 191
						if ((int)(*(tearray + pin1))->pinloc == 0) {
#line 191
							if ((*(tearray + pin1))->row == channel) {
#line 193
								((aNetSeg + segment)->bot)->pin1ptr = (*(Tgrid + pin1))->down;
							}
						}
#line 195
						Bright = (*(tearray + pin2))->xpos;
#line 196
						((aNetSeg + segment)->bot)->pin2ptr = (*(Tgrid + pin2))->up;
#line 197
						if ((int)(*(tearray + pin2))->pinloc == 0) {
#line 197
							if ((*(tearray + pin2))->row == channel) {
#line 199
								((aNetSeg + segment)->bot)->pin2ptr = (*(Tgrid + pin2))->down;
							}
						}
#line 201
						if (Bleft == Bright) {
							goto _L;
						}
						else {
#line 201
							if (Tleft == Tright) {
							_L: /* CIL Label */
#line 202
								(aNetSeg + segment)->swYorN = (char)0;
#line 203
								if (Bleft == Bright) {
#line 203
									if (Tleft != Tright) {
#line 204
										tmp_ptr = (aNetSeg + segment)->top;
#line 205
										(aNetSeg + segment)->top = (aNetSeg + segment)->bot;
#line 207
										(aNetSeg + segment)->bot = tmp_ptr;
									}
								}
							}
						}
					}
				}
			}
		}
#line 213
		net2 = net + 1;
#line 214
		* (anet + net2) = segment + 1;
#line 215
		net = 1;
#line 215
		while (net < net2) {
#line 216
			if (*(anet + net) == 0) {
#line 217
				net1 = net + 1;
#line 217
				while (net1 <= net2) {
#line 218
					if (*(anet + net1) != 0) {
#line 219
						* (anet + net) = *(anet + net1);
#line 220
						break;
					}
#line 217
					net1++;
				}
			}
#line 215
			net++;
		}
#line 226
		return;
	}
}
#line 1 "savewolf.o"
#pragma merger(0,"./savewolf.i","")
#line 219 "/usr/include/stdio.h"
extern int (__attribute__((__cdecl__)) rename)(char const   *, char const   *);
#line 3 "savewolf.c"
int stage;
#line 10 "savewolf.c"
int last_level;
#line 21
float cpu_time(void);
#line 23
void savewolf(int level);
#line 23 "savewolf.c"
static float last_time = (float)0.0;
#line 76
extern int( /* missing proto */  unlink)();
#line 12 "savewolf.c"
void savewolf(int level)
{
	FILE *fp;
	int xcenter;
	int ycenter;
	int cell___0;
	int block___0;
	int orient;
	int seg;
	char filename[64];
	char file1[1024];
	char file2[1024];
	CBOXPTR___0 cellptr___0;
	float current_time;

	{
#line 27
		current_time = cpu_time();
#line 28
		if ((double)(current_time - last_time) < 600.0) {
#line 28
			if (level == last_level) {
#line 28
				if (level <= 1) {
#line 30
					return;
				}
			}
		}
#line 32
		last_time = current_time;
#line 33
		last_level = level;
#line 37
		sprintf(filename, "%s.tmp", cktName);
#line 38
		fp = twopen((int)(filename), (int)"w", 1);
#line 41
		fprintf(fp, "%f\n", T);
#line 42
		fprintf(fp, "%d\n", iteration);
#line 43
		fprintf(fp, "%d\n", ffeeds);
#line 44
		fprintf(fp, "%d\n", level);
#line 46
		fprintf(fp, "%f\n", binpenCon);
#line 47
		fprintf(fp, "%f\n", roLenCon);
#line 48
		fprintf(fp, "%f\n", cost_scale_factor);
#line 49
		fprintf(fp, "%d\n", estimate_feeds);
#line 52
		if (level == 3) {
#line 53
			fprintf(fp, "%d\n", numSegs);
#line 54
			seg = 1;
#line 54
			while (seg <= numSegs) {
#line 55
				fprintf(fp, "%d\n", (aNetSeg + seg)->current);
#line 54
				seg++;
			}
		}
#line 59
		cell___0 = 1;
#line 59
		while (cell___0 <= numcells + numterms) {
#line 60
			cellptr___0 = (struct cellbox___0 *)*(carray + cell___0);
#line 61
			orient = (int)cellptr___0->corient;
#line 62
			block___0 = cellptr___0->cblock;
#line 63
			xcenter = cellptr___0->cxcenter;
#line 64
			ycenter = cellptr___0->cycenter;
#line 65
			fprintf(fp, "%d %d %d %d %d\n", cell___0, block___0, orient, xcenter, ycenter);
#line 59
			cell___0++;
		}
#line 68
		twclose((int)fp);
#line 70
		sprintf(file1, "%s.tmp", cktName);
#line 71
		if (level == 1) {
#line 72
			sprintf(file2, "%s.sav", cktName);
		}
		else {
#line 74
			sprintf(file2, "%s.sv2", cktName);
		}
#line 76
		unlink(file2);
#line 77
		rename((char const   *)(file1), (char const   *)(file2));
#line 79
		return;
	}
}
#line 82 "savewolf.c"
void TW_oldin(FILE *fp)
{
	int cell___0;
	int orient;
	int numfds;
	int block___0;
	int xcenter;
	int ycenter;
	int dummy;
	CBOXPTR___0 ptr;
	TEBOXPTR___0 term;
	NBOXPTR termptr;
	int tmp;

	{
#line 92
		fscanf(fp, "%f", &T);
#line 93
		fscanf(fp, "%d", &iteration);
#line 94
		fscanf(fp, "%d", &numfds);
#line 95
		fscanf(fp, "%d", &dummy);
#line 97
		fscanf(fp, "%f", &binpenCon);
#line 98
		fscanf(fp, "%f", &roLenCon);
#line 99
		fscanf(fp, "%f", &cost_scale_factor);
#line 100
		fscanf(fp, "%d", &estimate_feeds);
#line 102
		while (1) {
#line 102
			tmp = fscanf(fp, " %d %d %d %d %d ", &cell___0, &block___0, &orient, &xcenter,
				&ycenter);
#line 102
			if (!(tmp == 5)) {
#line 102
				break;
			}
#line 104
			ptr = (struct cellbox___0 *)*(carray + cell___0);
#line 105
			ptr->cblock = block___0;
#line 106
			ptr->corient = (char)orient;
#line 107
			ptr->cxcenter = xcenter;
#line 108
			ptr->cycenter = ycenter;
#line 109
			if (cell___0 <= numcells) {
#line 110
				term = (ptr->tileptr)->termsptr;
#line 110
				while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 112
					termptr = (struct netbox *)*(tearray + term->cellterm);
#line 113
					termptr->xpos = term->txpos[orient / 2] + xcenter;
#line 114
					termptr->ypos = term->typos[orient % 2] + ycenter;
#line 110
					term = (struct termbox___0 *)term->nextterm;
				}
			}
			else {
#line 117
				term = (ptr->tileptr)->termsptr;
#line 117
				while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 119
					termptr = (struct netbox *)*(tearray + term->cellterm);
#line 120
					termptr->xpos = term->txpos[1] + xcenter;
#line 121
					termptr->ypos = term->typos[1] + ycenter;
#line 117
					term = (struct termbox___0 *)term->nextterm;
				}
			}
		}
#line 125
		return;
	}
}
#line 129 "savewolf.c"
void fixfdpos(FILE *fp)
{
	int cell___0;
	int orient;
	int numfds;
	int dummy;
	int number;
	int seg;
	int current;
	int block___0;
	int xcenter;
	int ycenter;
	int junk;
	float d_dummy;
	CBOXPTR___0 ptr;
	char *tmp;
	int tmp___0;

	{
#line 138
		fscanf(fp, "%f", &T);
#line 139
		fscanf(fp, "%d", &iteration);
#line 140
		fscanf(fp, "%d", &numfds);
#line 141
		fscanf(fp, "%d", &dummy);
#line 142
		fscanf(fp, "%f", &d_dummy);
#line 143
		fscanf(fp, "%f", &d_dummy);
#line 144
		fscanf(fp, "%f", &d_dummy);
#line 145
		fscanf(fp, "%d", &junk);
#line 147
		if (dummy == 3) {
#line 148
			fscanf(fp, "%d", &number);
#line 149
			tmp = safe_malloc((unsigned int)(number + 1) * sizeof(int));
#line 149
			fixarray = (int *)tmp;
#line 150
			seg = 1;
#line 150
			while (seg <= number) {
#line 151
				fscanf(fp, "%d", &current);
#line 152
				* (fixarray + seg) = current;
#line 150
				seg++;
			}
		}
#line 155
		while (1) {
#line 155
			tmp___0 = fscanf(fp, " %d %d %d %d %d ", &cell___0, &block___0, &orient, &xcenter,
				&ycenter);
#line 155
			if (!(tmp___0 == 5)) {
#line 155
				break;
			}
#line 157
			ptr = (struct cellbox___0 *)*(carray + cell___0);
#line 158
			ptr->cxcenter = xcenter;
#line 159
			ptr->cycenter = ycenter;
#line 160
			ptr->corient = (char)orient;
		}
#line 162
		return;
	}
}
#line 1 "sortpin.o"
#pragma merger(0,"./sortpin.i","")
#line 27 "sortpin.c"
int shellsort(TEBOXPTR *term, int n);
#line 3 "sortpin.c"
void sortpin(void)
{
	int j;
	int n;
	int cell___0;
	CBOXPTR ptr;
	TIBOXPTR tile;
	TEBOXPTR term;
	TEBOXPTR *xpptr;
	NBOXPTR termptr;
	char *tmp;

	{
#line 13
		tmp = safe_malloc(300U * sizeof(TEBOXPTR));
#line 13
		xpptr = (TEBOXPTR *)tmp;
#line 14
		cell___0 = 1;
#line 14
		while (cell___0 <= numcells + numterms) {
#line 15
			ptr = *(carray + cell___0);
#line 16
			tile = ptr->tileptr;
#line 16
			if ((unsigned int)tile == (unsigned int)((void *)0)) {
				goto __Cont;
			}
#line 19
			n = 0;
#line 20
			term = tile->termsptr;
#line 20
			while ((unsigned int)term != (unsigned int)((void *)0)) {
#line 22
				termptr = *(tearray + term->cellterm);
#line 23
				term->net = termptr->net;
#line 24
				term->termptr = termptr;
#line 25
				n++;
#line 25
				* (xpptr + n) = term;
#line 20
				term = term->nextterm;
			}
#line 27
			shellsort(xpptr, n);
#line 28
			* (xpptr + (n + 1)) = (struct termbox *)((void *)0);
#line 29
			(ptr->tileptr)->termsptr = *(xpptr + 1);
#line 30
			j = 1;
#line 30
			while (j <= n) {
#line 31
				(*(xpptr + j))->nextterm = *(xpptr + (j + 1));
#line 30
				j++;
			}
		__Cont: /* CIL Label */
#line 14
			cell___0++;
		}
#line 34
		safe_free(xpptr);
#line 35
		return;
	}
}
#line 38 "sortpin.c"
int shellsort(TEBOXPTR *term, int n)
{
	TEBOXPTR ptr;
	int incr;
	int i;
	int j;

	{
#line 44
		incr = n / 2;
#line 44
		while (incr > 0) {
#line 45
			i = incr + 1;
#line 45
			while (i <= n) {
#line 46
				j = i - incr;
#line 46
				while (1) {
#line 46
					if (j > 0) {
#line 46
						if (!((*(term + j))->net > (*(term + (j + incr)))->net)) {
#line 46
							break;
						}
					}
					else {
#line 46
						break;
					}
#line 48
					ptr = *(term + j);
#line 49
					* (term + j) = *(term + (j + incr));
#line 50
					* (term + (j + incr)) = ptr;
#line 46
					j -= incr;
				}
#line 45
				i++;
			}
#line 44
			incr /= 2;
		}
#line 54
		return (0);
	}
}
#line 1 "stats.o"
#pragma merger(0,"./stats.i","")
#line 7 "stats.c"
void print_stats(FILE *fp)
{

	{
#line 9
		fprintf(fp, "Usage statistics not available\n");
#line 10
		return;
	}
}
#line 13 "stats.c"
float cpu_time(void)
{

	{
#line 15
		return ((float)0.0);
	}
}
#line 1 "uc0.o"
#pragma merger(0,"./uc0.i","")
#line 4 "uc0.c"
void uc0(int a___0, int newaor)
{
	CBOXPTR acellptr___0;
	TEBOXPTR antrmptr;
	int cost;
	int truth;

	{
#line 12
		acellptr___0 = *(carray + a___0);
#line 13
		antrmptr = (acellptr___0->tileptr)->termsptr;
#line 15
		term_newpos(antrmptr, acellptr___0->cxcenter, acellptr___0->cycenter, newaor);
#line 17
		cost = funccost;
#line 19
		new_dbox(antrmptr, &cost);
#line 21
		truth = acceptt(funccost - cost);
#line 22
		if (truth == 1) {
#line 24
			dbox_pos(antrmptr);
#line 25
			acellptr___0->corient = (char)newaor;
#line 26
			funccost = cost;
		}
#line 28
		return;
	}
}
#line 1 "ucg0.o"
#pragma merger(0,"./ucg0.i","")
#line 105 "ucg0.c"
int sub_reset1(int a___0);
#line 109
int uglobe(void);
#line 4 "ucg0.c"
int ucg0(int a___0, int newaor)
{
	CBOXPTR___0 acellptr___0;
	NBOXPTR tmptr;
	TIBOXPTR___0 antilptr;
	TEBOXPTR___0 termptr;
	TEBOXPTR___0 antrmptr;
	SEGBOXPTR segptr;
	DENSITYPTR denptr;
	CHANGRDPTR gdptr;
	CHANGRDPTR endgrd;
	int x;
	int y;
	int oldtracks;
	int track;
	int axcenter___0;
	int aycenter___0;
	int i;
	int b___0;
	int e;
	int seg;
	int chan;
	int net;
	int UpperLeft;
	int UpperRight;
	int LowerLeft;
	int LowerRight;
	int ULpin;
	int URpin;
	int LLpin;
	int LRpin;
	int leftx___0;
	int ritex___0;
	int topchan;
	int botchan;

	{
#line 22
		acellptr___0 = (struct cellbox___0 *)*(carray + a___0);
#line 23
		axcenter___0 = acellptr___0->cxcenter;
#line 24
		aycenter___0 = acellptr___0->cycenter;
#line 26
		antilptr = acellptr___0->tileptr;
#line 27
		antrmptr = antilptr->termsptr;
#line 29
		LowerLeft = gxstop;
#line 29
		UpperLeft = LowerLeft;
#line 30
		LowerRight = gxstart;
#line 30
		UpperRight = LowerRight;
#line 31
		LRpin = 0;
#line 31
		LLpin = LRpin;
#line 31
		URpin = LLpin;
#line 31
		ULpin = URpin;
#line 32
		* (netchgs + 0) = 0;
#line 33
		termptr = antrmptr;
#line 33
		while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 35
			x = termptr->txpos[newaor / 2] + axcenter___0;
#line 36
			y = termptr->typos[newaor % 2] + aycenter___0;
#line 38
			tmptr = (struct netbox *)*(tearray + termptr->cellterm);
#line 39
			if ((int)tmptr->pinloc == 1) {
#line 40
				if (tmptr->newx < UpperLeft) {
#line 41
					UpperLeft = tmptr->newx;
#line 42
					ULpin = termptr->cellterm;
				}
#line 44
				if (tmptr->newx > UpperRight) {
#line 45
					UpperRight = tmptr->newx;
#line 46
					URpin = termptr->cellterm;
				}
			}
			else {
#line 49
				if (tmptr->newx < LowerLeft) {
#line 50
					LowerLeft = tmptr->newx;
#line 51
					LLpin = termptr->cellterm;
				}
#line 53
				if (tmptr->newx > LowerRight) {
#line 54
					LowerRight = tmptr->newx;
#line 55
					LRpin = termptr->cellterm;
				}
			}
#line 58
			tmptr->xpos = x;
#line 59
			tmptr->ypos = y;
#line 60
			i = 1;
#line 60
			while (i <= *(netchgs + 0)) {
#line 61
				if (tmptr->net == *(netchgs + i)) {
#line 62
					break;
				}
#line 60
				i++;
			}
#line 65
			if (i > *(netchgs + 0)) {
#line 66
				(*(netchgs + 0))++;
#line 66
				* (netchgs + *(netchgs + 0)) = tmptr->net;
			}
#line 33
			termptr = (struct termbox___0 *)termptr->nextterm;
		}
#line 69
		if (*(netchgs + 0) == 0) {
#line 70
			return (0);
		}
#line 73
		leftx___0 = axcenter___0 + antilptr->left;
#line 74
		ritex___0 = axcenter___0 + antilptr->right;
#line 76
		if (ULpin != 0) {
#line 77
			ULgrdptr = ((*(Tgrid + ULpin))->up)->prevgrd;
#line 78
			while ((ULgrdptr->netptr)->newx >= leftx___0) {
#line 79
				ULgrdptr = ULgrdptr->prevgrd;
			}
#line 81
			URgrdptr = ((*(Tgrid + URpin))->up)->nextgrd;
#line 82
			while ((URgrdptr->netptr)->newx <= ritex___0) {
#line 83
				URgrdptr = URgrdptr->nextgrd;
			}
		}
		else {
#line 86
			ULgrdptr = (struct changrdbox *)((void *)0);
		}
#line 89
		if (LLpin != 0) {
#line 90
			LLgrdptr = ((*(Tgrid + LLpin))->down)->prevgrd;
#line 91
			while ((LLgrdptr->netptr)->newx >= leftx___0) {
#line 92
				LLgrdptr = LLgrdptr->prevgrd;
			}
#line 94
			LRgrdptr = ((*(Tgrid + LRpin))->down)->nextgrd;
#line 95
			while ((LRgrdptr->netptr)->newx <= ritex___0) {
#line 96
				LRgrdptr = LRgrdptr->nextgrd;
			}
		}
		else {
#line 99
			LLgrdptr = (struct changrdbox *)((void *)0);
		}
#line 102
		Left_bound = leftx___0 - (ritex___0 - leftx___0);
#line 103
		Rite_bound = ritex___0 + (ritex___0 - leftx___0);
#line 104
		if (uneven_cell_height) {
#line 105
			sub_reset1(a___0);
		}
#line 108
		oldtracks = tracks;
#line 109
		uglobe();
#line 110
		topchan = gtopChan + 1;
#line 111
		botchan = gbotChan - 1;
#line 112
		if (topchan > numChans) {
#line 113
			topchan = numChans;
		}
#line 115
		if (botchan < 1) {
#line 116
			botchan = 1;
		}
#line 119
		if (tracks < oldtracks) {
#line 120
			i = 1;
#line 120
			while (i <= *(netchgs + 0)) {
#line 121
				net = *(netchgs + i);
#line 122
				b___0 = *(anet + net);
#line 123
				e = *(anet + (net + 1)) - 1;
#line 124
				seg = b___0;
#line 124
				while (seg <= e) {
#line 125
					(aNetSeg + seg)->current = (aNetSeg + seg)->ncurrent;
#line 126
					(aNetSeg + seg)->swYorN = (aNetSeg + seg)->nswYorN;
#line 127
					(aNetSeg + seg)->key = (aNetSeg + seg)->nkey;
#line 128
					(aNetSeg + seg)->nflag = (char)0;
#line 129
					segptr = (aNetSeg + seg)->top;
#line 130
					(aNetSeg + seg)->top = (aNetSeg + seg)->ntop;
#line 131
					(aNetSeg + seg)->ntop = segptr;
#line 132
					segptr = (aNetSeg + seg)->bot;
#line 133
					(aNetSeg + seg)->bot = (aNetSeg + seg)->nbot;
#line 134
					(aNetSeg + seg)->nbot = segptr;
#line 124
					seg++;
				}
#line 120
				i++;
			}
#line 137
			termptr = antrmptr;
#line 137
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 139
				tmptr = (struct netbox *)*(tearray + termptr->cellterm);
#line 140
				tmptr->newx = tmptr->xpos;
#line 141
				tmptr->newy = tmptr->ypos;
#line 137
				termptr = (struct termbox___0 *)termptr->nextterm;
			}
#line 143
			seg = 1;
#line 143
			while (seg <= numSegs) {
#line 144
				* (fixnetseg + seg) = (int)(aNetSeg + seg)->current;
#line 143
				seg++;
			}
#line 146
			chan = botchan;
#line 146
			while (chan <= topchan) {
#line 147
				gdptr = *(Begin + chan);
#line 147
				while ((unsigned int)gdptr != (unsigned int)((void *)0)) {
#line 149
					gdptr->tracks = gdptr->ntracks;
#line 150
					gdptr->SegType = gdptr->nSegType;
#line 147
					gdptr = (struct changrdbox *)gdptr->nnextgrd;
				}
#line 152
				track = 0;
#line 152
				while (track <= max_tdensity + 30) {
#line 153
					denptr = *(*(DboxHead + chan) + track);
#line 153
					while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 155
						denptr->next = denptr->nnext;
#line 156
						denptr->back = denptr->nback;
#line 153
						denptr = denptr->nnext;
					}
#line 152
					track++;
				}
#line 159
				* (maxTrack + chan) = *(nmaxTrack + chan);
#line 146
				chan++;
			}
#line 161
			if ((unsigned int)ULgrdptr != (unsigned int)((void *)0)) {
#line 162
				endgrd = (struct changrdbox *)URgrdptr->nnextgrd;
#line 163
				gdptr = (struct changrdbox *)ULgrdptr;
#line 163
				while ((unsigned int)gdptr != (unsigned int)endgrd) {
#line 165
					gdptr->nextgrd = gdptr->nnextgrd;
#line 166
					gdptr->prevgrd = gdptr->nprevgrd;
#line 163
					gdptr = (struct changrdbox *)gdptr->nnextgrd;
				}
			}
#line 169
			if ((unsigned int)LLgrdptr != (unsigned int)((void *)0)) {
#line 170
				endgrd = (struct changrdbox *)LRgrdptr->nnextgrd;
#line 171
				gdptr = (struct changrdbox *)LLgrdptr;
#line 171
				while ((unsigned int)gdptr != (unsigned int)endgrd) {
#line 173
					gdptr->nextgrd = gdptr->nnextgrd;
#line 174
					gdptr->prevgrd = gdptr->nprevgrd;
#line 171
					gdptr = (struct changrdbox *)gdptr->nnextgrd;
				}
			}
#line 178
			acellptr___0->corient = (char)newaor;
#line 179
			return (1);
		}
		else {
#line 181
			termptr = antrmptr;
#line 181
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 183
				tmptr = (struct netbox *)*(tearray + termptr->cellterm);
#line 184
				tmptr->xpos = tmptr->newx;
#line 185
				tmptr->ypos = tmptr->newy;
#line 181
				termptr = (struct termbox___0 *)termptr->nextterm;
			}
#line 187
			i = 1;
#line 187
			while (i <= *(netchgs + 0)) {
#line 188
				net = *(netchgs + i);
#line 189
				b___0 = *(anet + net);
#line 190
				e = *(anet + (net + 1)) - 1;
#line 191
				seg = b___0;
#line 191
				while (seg <= e) {
#line 192
					(aNetSeg + seg)->nflag = (char)0;
#line 191
					seg++;
				}
#line 187
				i++;
			}
#line 195
			seg = 1;
#line 195
			while (seg <= numSegs) {
#line 196
				(aNetSeg + seg)->current = (char)*(fixnetseg + seg);
#line 195
				seg++;
			}
#line 198
			chan = botchan;
#line 198
			while (chan <= topchan) {
#line 199
				gdptr = *(Begin + chan);
#line 199
				while ((unsigned int)gdptr != (unsigned int)((void *)0)) {
#line 201
					gdptr->ntracks = gdptr->tracks;
#line 202
					gdptr->nSegType = gdptr->SegType;
#line 199
					gdptr = (struct changrdbox *)gdptr->nextgrd;
				}
#line 204
				track = 0;
#line 204
				while (track <= max_tdensity + 30) {
#line 205
					denptr = *(*(DboxHead + chan) + track);
#line 205
					while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 207
						denptr->nnext = denptr->next;
#line 208
						denptr->nback = denptr->back;
#line 205
						denptr = denptr->next;
					}
#line 204
					track++;
				}
#line 211
				* (nmaxTrack + chan) = *(maxTrack + chan);
#line 198
				chan++;
			}
#line 213
			if ((unsigned int)ULgrdptr != (unsigned int)((void *)0)) {
#line 214
				endgrd = (struct changrdbox *)URgrdptr->nextgrd;
#line 215
				gdptr = (struct changrdbox *)ULgrdptr;
#line 215
				while ((unsigned int)gdptr != (unsigned int)endgrd) {
#line 217
					gdptr->nnextgrd = gdptr->nextgrd;
#line 218
					gdptr->nprevgrd = gdptr->prevgrd;
#line 215
					gdptr = (struct changrdbox *)gdptr->nextgrd;
				}
			}
#line 221
			if ((unsigned int)LLgrdptr != (unsigned int)((void *)0)) {
#line 222
				endgrd = (struct changrdbox *)LRgrdptr->nextgrd;
#line 223
				gdptr = (struct changrdbox *)LLgrdptr;
#line 223
				while ((unsigned int)gdptr != (unsigned int)endgrd) {
#line 225
					gdptr->nnextgrd = gdptr->nextgrd;
#line 226
					gdptr->nprevgrd = gdptr->prevgrd;
#line 223
					gdptr = (struct changrdbox *)gdptr->nextgrd;
				}
			}
#line 230
			tracks = oldtracks;
#line 231
			return (0);
		}
	}
}
#line 236 "ucg0.c"
int sub_reset1(int a___0)
{
	int row___0;
	int pinloc;
	int self_reset;
	NBOXPTR netptr;
	CHANGRDPTR grdptr;
	int tmp;
	int tmp___0;

	{
#line 245
		row___0 = (*(carray + a___0))->cblock;
#line 246
		if ((unsigned int)ULgrdptr != (unsigned int)((void *)0)) {
#line 247
			grdptr = (struct changrdbox *)ULgrdptr;
#line 247
			while ((unsigned int)grdptr != (unsigned int)URgrdptr) {
#line 249
				netptr = grdptr->netptr;
#line 250
				pinloc = (int)netptr->pinloc;
#line 251
				if (pinloc == 1) {
#line 252
					self_reset = ((*(carray + netptr->cell))->tileptr)->top;
				}
				else {
#line 253
					if (pinloc == -1) {
#line 254
						self_reset = -((*(carray + netptr->cell))->tileptr)->bottom;
					}
					else {
#line 256
						self_reset = 0;
					}
				}
#line 258
				tmp = facing_cellheight(netptr->terminal, netptr->row, pinloc, 0);
#line 258
				grdptr->ntracks -= (self_reset + tmp) / track_spacing;
#line 247
				grdptr = (struct changrdbox *)grdptr->nextgrd;
			}
		}
#line 263
		if ((unsigned int)LLgrdptr != (unsigned int)((void *)0)) {
#line 264
			grdptr = (struct changrdbox *)LLgrdptr;
#line 264
			while ((unsigned int)grdptr != (unsigned int)LRgrdptr) {
#line 266
				netptr = grdptr->netptr;
#line 267
				pinloc = (int)netptr->pinloc;
#line 268
				if (pinloc == 1) {
#line 269
					self_reset = ((*(carray + netptr->cell))->tileptr)->top;
				}
				else {
#line 270
					if (pinloc == -1) {
#line 271
						self_reset = -((*(carray + netptr->cell))->tileptr)->bottom;
					}
					else {
#line 273
						self_reset = 0;
					}
				}
#line 275
				tmp___0 = facing_cellheight(netptr->terminal, netptr->row, pinloc, 0);
#line 275
				grdptr->ntracks -= (self_reset + tmp___0) / track_spacing;
#line 264
				grdptr = (struct changrdbox *)grdptr->nextgrd;
			}
		}
#line 280
		return (0);
	}
}
#line 1 "ucgxp.o"
#pragma merger(0,"./ucgxp.i","")
#line 3 "ucgxp.c"
static int na_i;
#line 3 "ucgxp.c"
static int nb_i;
#line 3 "ucgxp.c"
static int start_i;
#line 3 "ucgxp.c"
static int end_i;
#line 4 "ucgxp.c"
static int startcbin;
#line 4 "ucgxp.c"
static int endcbin;
#line 4 "ucgxp.c"
static int rowleft;
#line 5 "ucgxp.c"
static int leftx;
#line 5 "ucgxp.c"
static int ritex;
#line 6 "ucgxp.c"
static int old_axcenter;
#line 6 "ucgxp.c"
static int old_bxcenter;
#line 7 "ucgxp.c"
static CBOXPTR___0 acellptr;
#line 7 "ucgxp.c"
static CBOXPTR___0 bcellptr;
#line 153
int sub_reset2(int a___0, int b___0, int anxcenter___0, int bnxcenter___0);
#line 9 "ucgxp.c"
int ucgxp(int a___0, int b___0, int anxcenter___0, int bnxcenter___0)
{
	CBOXPTR___0 cellptr___0;
	NBOXPTR tmptr;
	TIBOXPTR___0 atileptr;
	TIBOXPTR___0 btileptr;
	TEBOXPTR___0 termptr;
	TEBOXPTR___0 atermptr;
	TEBOXPTR___0 btermptr;
	SEGBOXPTR segptr;
	DENSITYPTR denptr;
	CHANGRDPTR gdptr;
	CHANGRDPTR endgrd;
	int oldtracks;
	int track;
	int x;
	int row___0;
	int aorient;
	int borient___0;
	int bin;
	int bin_rite_edge;
	int crite;
	int i;
	int bb;
	int e;
	int seg;
	int chan;
	int net;
	int UpperLeft;
	int UpperRight;
	int LowerLeft;
	int LowerRight;
	int ULpin;
	int URpin;
	int LLpin;
	int LRpin;
	int topchan;
	int botchan;

	{
#line 27
		acellptr = (struct cellbox___0 *)*(carray + a___0);
#line 28
		aorient = (int)acellptr->corient / 2;
#line 29
		atileptr = acellptr->tileptr;
#line 30
		atermptr = atileptr->termsptr;
#line 32
		bcellptr = (struct cellbox___0 *)*(carray + b___0);
#line 33
		borient___0 = (int)bcellptr->corient / 2;
#line 34
		btileptr = bcellptr->tileptr;
#line 35
		btermptr = btileptr->termsptr;
#line 37
		LowerLeft = gxstop;
#line 37
		UpperLeft = LowerLeft;
#line 38
		LowerRight = gxstart;
#line 38
		UpperRight = LowerRight;
#line 39
		LRpin = 0;
#line 39
		LLpin = LRpin;
#line 39
		URpin = LLpin;
#line 39
		ULpin = URpin;
#line 41
		* (netchgs + 0) = 0;
#line 42
		termptr = atermptr;
#line 42
		while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 44
			x = termptr->txpos[aorient] + anxcenter___0;
#line 46
			tmptr = (struct netbox *)*(tearray + termptr->cellterm);
#line 47
			if ((int)tmptr->pinloc == 1) {
#line 48
				if (tmptr->newx < UpperLeft) {
#line 49
					UpperLeft = tmptr->newx;
#line 50
					ULpin = termptr->cellterm;
				}
#line 52
				if (tmptr->newx > UpperRight) {
#line 53
					UpperRight = tmptr->newx;
#line 54
					URpin = termptr->cellterm;
				}
			}
			else {
#line 58
				if (tmptr->newx < LowerLeft) {
#line 59
					LowerLeft = tmptr->newx;
#line 60
					LLpin = termptr->cellterm;
				}
#line 62
				if (tmptr->newx > LowerRight) {
#line 63
					LowerRight = tmptr->newx;
#line 64
					LRpin = termptr->cellterm;
				}
			}
#line 67
			tmptr->xpos = x;
#line 68
			i = 1;
#line 68
			while (i <= *(netchgs + 0)) {
#line 69
				if (tmptr->net == *(netchgs + i)) {
#line 70
					break;
				}
#line 68
				i++;
			}
#line 73
			if (i > *(netchgs + 0)) {
#line 74
				(*(netchgs + 0))++;
#line 74
				* (netchgs + *(netchgs + 0)) = tmptr->net;
			}
#line 42
			termptr = (struct termbox___0 *)termptr->nextterm;
		}
#line 77
		termptr = btermptr;
#line 77
		while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 79
			x = termptr->txpos[borient___0] + bnxcenter___0;
#line 81
			tmptr = (struct netbox *)*(tearray + termptr->cellterm);
#line 82
			if ((int)tmptr->pinloc == 1) {
#line 83
				if (tmptr->newx < UpperLeft) {
#line 84
					UpperLeft = tmptr->newx;
#line 85
					ULpin = termptr->cellterm;
				}
#line 87
				if (tmptr->newx > UpperRight) {
#line 88
					UpperRight = tmptr->newx;
#line 89
					URpin = termptr->cellterm;
				}
			}
			else {
#line 93
				if (tmptr->newx < LowerLeft) {
#line 94
					LowerLeft = tmptr->newx;
#line 95
					LLpin = termptr->cellterm;
				}
#line 97
				if (tmptr->newx > LowerRight) {
#line 98
					LowerRight = tmptr->newx;
#line 99
					LRpin = termptr->cellterm;
				}
			}
#line 102
			tmptr->xpos = x;
#line 103
			i = 1;
#line 103
			while (i <= *(netchgs + 0)) {
#line 104
				if (tmptr->net == *(netchgs + i)) {
#line 105
					break;
				}
#line 103
				i++;
			}
#line 108
			if (i > *(netchgs + 0)) {
#line 109
				(*(netchgs + 0))++;
#line 109
				* (netchgs + *(netchgs + 0)) = tmptr->net;
			}
#line 77
			termptr = (struct termbox___0 *)termptr->nextterm;
		}
#line 112
		if (*(netchgs + 0) == 0) {
#line 113
			return (0);
		}
#line 116
		if (anxcenter___0 < bnxcenter___0) {
#line 117
			leftx = anxcenter___0 + atileptr->left;
#line 118
			ritex = bnxcenter___0 + btileptr->right;
		}
		else {
#line 120
			leftx = bnxcenter___0 + btileptr->left;
#line 121
			ritex = anxcenter___0 + atileptr->right;
		}
#line 124
		if (ULpin != 0) {
#line 125
			ULgrdptr = ((*(Tgrid + ULpin))->up)->prevgrd;
#line 126
			while ((ULgrdptr->netptr)->newx >= leftx) {
#line 127
				ULgrdptr = ULgrdptr->prevgrd;
			}
#line 129
			URgrdptr = ((*(Tgrid + URpin))->up)->nextgrd;
#line 130
			while ((URgrdptr->netptr)->newx <= ritex) {
#line 131
				URgrdptr = URgrdptr->nextgrd;
			}
		}
		else {
#line 134
			ULgrdptr = (struct changrdbox *)((void *)0);
		}
#line 137
		if (LLpin != 0) {
#line 138
			LLgrdptr = ((*(Tgrid + LLpin))->down)->prevgrd;
#line 139
			while ((LLgrdptr->netptr)->newx >= leftx) {
#line 140
				LLgrdptr = LLgrdptr->prevgrd;
			}
#line 142
			LRgrdptr = ((*(Tgrid + LRpin))->down)->nextgrd;
#line 143
			while ((LRgrdptr->netptr)->newx <= ritex) {
#line 144
				LRgrdptr = LRgrdptr->nextgrd;
			}
		}
		else {
#line 147
			LLgrdptr = (struct changrdbox *)((void *)0);
		}
#line 150
		Left_bound = leftx - (ritex - leftx);
#line 151
		Rite_bound = ritex + (ritex - leftx);
#line 152
		if (uneven_cell_height) {
#line 153
			sub_reset2(a___0, b___0, anxcenter___0, bnxcenter___0);
		}
#line 156
		oldtracks = tracks;
#line 157
		uglobe();
#line 158
		topchan = gtopChan + 1;
#line 159
		botchan = gbotChan - 1;
#line 160
		if (topchan > numChans) {
#line 161
			topchan = numChans;
		}
#line 163
		if (botchan < 1) {
#line 164
			botchan = 1;
		}
#line 167
		if (tracks <= oldtracks) {
#line 169
			if (!uneven_cell_height) {
#line 170
				acellptr->cxcenter = anxcenter___0;
#line 171
				bcellptr->cxcenter = bnxcenter___0;
			}
#line 173
			termptr = atermptr;
#line 173
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 175
				tmptr = (struct netbox *)*(tearray + termptr->cellterm);
#line 176
				tmptr->newx = tmptr->xpos;
#line 173
				termptr = (struct termbox___0 *)termptr->nextterm;
			}
#line 178
			termptr = btermptr;
#line 178
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 180
				tmptr = (struct netbox *)*(tearray + termptr->cellterm);
#line 181
				tmptr->newx = tmptr->xpos;
#line 178
				termptr = (struct termbox___0 *)termptr->nextterm;
			}
#line 183
			i = 1;
#line 183
			while (i <= *(netchgs + 0)) {
#line 184
				net = *(netchgs + i);
#line 185
				bb = *(anet + net);
#line 186
				e = *(anet + (net + 1)) - 1;
#line 187
				seg = bb;
#line 187
				while (seg <= e) {
#line 188
					(aNetSeg + seg)->current = (aNetSeg + seg)->ncurrent;
#line 189
					(aNetSeg + seg)->swYorN = (aNetSeg + seg)->nswYorN;
#line 190
					(aNetSeg + seg)->key = (aNetSeg + seg)->nkey;
#line 191
					(aNetSeg + seg)->nflag = (char)0;
#line 192
					segptr = (aNetSeg + seg)->top;
#line 193
					(aNetSeg + seg)->top = (aNetSeg + seg)->ntop;
#line 194
					(aNetSeg + seg)->ntop = segptr;
#line 195
					segptr = (aNetSeg + seg)->bot;
#line 196
					(aNetSeg + seg)->bot = (aNetSeg + seg)->nbot;
#line 197
					(aNetSeg + seg)->nbot = segptr;
#line 187
					seg++;
				}
#line 183
				i++;
			}
#line 200
			seg = 1;
#line 200
			while (seg <= numSegs) {
#line 201
				* (fixnetseg + seg) = (int)(aNetSeg + seg)->current;
#line 200
				seg++;
			}
#line 203
			chan = botchan;
#line 203
			while (chan <= topchan) {
#line 204
				gdptr = *(Begin + chan);
#line 204
				while ((unsigned int)gdptr != (unsigned int)((void *)0)) {
#line 206
					gdptr->tracks = gdptr->ntracks;
#line 207
					gdptr->SegType = gdptr->nSegType;
#line 204
					gdptr = (struct changrdbox *)gdptr->nnextgrd;
				}
#line 209
				track = 0;
#line 209
				while (track <= max_tdensity + 30) {
#line 210
					denptr = *(*(DboxHead + chan) + track);
#line 210
					while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 212
						denptr->next = denptr->nnext;
#line 213
						denptr->back = denptr->nback;
#line 210
						denptr = denptr->nnext;
					}
#line 209
					track++;
				}
#line 216
				* (maxTrack + chan) = *(nmaxTrack + chan);
#line 203
				chan++;
			}
#line 218
			if ((unsigned int)ULgrdptr != (unsigned int)((void *)0)) {
#line 219
				endgrd = (struct changrdbox *)URgrdptr->nnextgrd;
#line 220
				gdptr = (struct changrdbox *)ULgrdptr;
#line 220
				while ((unsigned int)gdptr != (unsigned int)endgrd) {
#line 222
					gdptr->nextgrd = gdptr->nnextgrd;
#line 223
					gdptr->prevgrd = gdptr->nprevgrd;
#line 220
					gdptr = (struct changrdbox *)gdptr->nnextgrd;
				}
			}
#line 226
			if ((unsigned int)LLgrdptr != (unsigned int)((void *)0)) {
#line 227
				endgrd = (struct changrdbox *)LRgrdptr->nnextgrd;
#line 228
				gdptr = (struct changrdbox *)LLgrdptr;
#line 228
				while ((unsigned int)gdptr != (unsigned int)endgrd) {
#line 230
					gdptr->nextgrd = gdptr->nnextgrd;
#line 231
					gdptr->prevgrd = gdptr->nprevgrd;
#line 228
					gdptr = (struct changrdbox *)gdptr->nnextgrd;
				}
			}
#line 234
			return (1);
		}
		else {
#line 236
			if (uneven_cell_height) {
#line 237
				acellptr->cxcenter = old_axcenter;
#line 238
				bcellptr->cxcenter = old_bxcenter;
			}
#line 240
			termptr = atermptr;
#line 240
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 242
				tmptr = (struct netbox *)*(tearray + termptr->cellterm);
#line 243
				tmptr->xpos = tmptr->newx;
#line 240
				termptr = (struct termbox___0 *)termptr->nextterm;
			}
#line 245
			termptr = btermptr;
#line 245
			while ((unsigned int)termptr != (unsigned int)((void *)0)) {
#line 247
				tmptr = (struct netbox *)*(tearray + termptr->cellterm);
#line 248
				tmptr->xpos = tmptr->newx;
#line 245
				termptr = (struct termbox___0 *)termptr->nextterm;
			}
#line 250
			i = 1;
#line 250
			while (i <= *(netchgs + 0)) {
#line 251
				net = *(netchgs + i);
#line 252
				bb = *(anet + net);
#line 253
				e = *(anet + (net + 1)) - 1;
#line 254
				seg = bb;
#line 254
				while (seg <= e) {
#line 255
					(aNetSeg + seg)->nflag = (char)0;
#line 254
					seg++;
				}
#line 250
				i++;
			}
#line 258
			seg = 1;
#line 258
			while (seg <= numSegs) {
#line 259
				(aNetSeg + seg)->current = (char)*(fixnetseg + seg);
#line 258
				seg++;
			}
#line 261
			chan = botchan;
#line 261
			while (chan <= topchan) {
#line 262
				gdptr = *(Begin + chan);
#line 262
				while ((unsigned int)gdptr != (unsigned int)((void *)0)) {
#line 264
					gdptr->ntracks = gdptr->tracks;
#line 265
					gdptr->nSegType = gdptr->SegType;
#line 262
					gdptr = (struct changrdbox *)gdptr->nextgrd;
				}
#line 267
				track = 0;
#line 267
				while (track <= max_tdensity + 30) {
#line 268
					denptr = *(*(DboxHead + chan) + track);
#line 268
					while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 270
						denptr->nnext = denptr->next;
#line 271
						denptr->nback = denptr->back;
#line 268
						denptr = denptr->next;
					}
#line 267
					track++;
				}
#line 274
				* (nmaxTrack + chan) = *(maxTrack + chan);
#line 261
				chan++;
			}
#line 276
			if ((unsigned int)ULgrdptr != (unsigned int)((void *)0)) {
#line 277
				endgrd = (struct changrdbox *)URgrdptr->nextgrd;
#line 278
				gdptr = (struct changrdbox *)ULgrdptr;
#line 278
				while ((unsigned int)gdptr != (unsigned int)endgrd) {
#line 280
					gdptr->nnextgrd = gdptr->nextgrd;
#line 281
					gdptr->nprevgrd = gdptr->prevgrd;
#line 278
					gdptr = (struct changrdbox *)gdptr->nextgrd;
				}
			}
#line 284
			if ((unsigned int)LLgrdptr != (unsigned int)((void *)0)) {
#line 285
				endgrd = (struct changrdbox *)LRgrdptr->nextgrd;
#line 286
				gdptr = (struct changrdbox *)LLgrdptr;
#line 286
				while ((unsigned int)gdptr != (unsigned int)endgrd) {
#line 288
					gdptr->nnextgrd = gdptr->nextgrd;
#line 289
					gdptr->nprevgrd = gdptr->prevgrd;
#line 286
					gdptr = (struct changrdbox *)gdptr->nextgrd;
				}
			}
#line 293
			tracks = oldtracks;
#line 294
			if (uneven_cell_height) {
#line 295
				row___0 = (*(carray + a___0))->cblock;
#line 296
				* (*(pairArray + row___0) + nb_i) = a___0;
#line 297
				* (*(pairArray + row___0) + na_i) = b___0;
#line 298
				bin = startcbin;
#line 299
				bin--;
#line 299
				bin_rite_edge = rowleft + bin * cedge_binwidth;
#line 300
				i = start_i;
#line 300
				while (i <= end_i) {
#line 301
					cellptr___0 = (struct cellbox___0 *)*(carray + *(*(pairArray + row___0) + i));
#line 302
					crite = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
#line 303
					while (bin_rite_edge < crite) {
#line 304
						bin++;
#line 304
						* (*(cedgebin + row___0) + bin) = i;
#line 305
						bin_rite_edge += cedge_binwidth;
					}
#line 300
					i++;
				}
			}
#line 309
			return (0);
		}
	}
}
#line 314 "ucgxp.c"
int sub_reset2(int a___0, int b___0, int anxcenter___0, int bnxcenter___0)
{
	int row___0;
	int bin;
	int *Aray;
	int i;
	int cell___0;
	int bin_rite_edge;
	int crite;
	int pinloc;
	int self_reset;
	NBOXPTR netptr;
	CBOXPTR___0 cellptr___0;
	CHANGRDPTR grdptr;
	int tmp;
	int tmp___0;

	{
#line 324
		row___0 = (*(carray + a___0))->cblock;
#line 325
		if ((unsigned int)ULgrdptr != (unsigned int)((void *)0)) {
#line 326
			grdptr = (struct changrdbox *)ULgrdptr;
#line 326
			while ((unsigned int)grdptr != (unsigned int)URgrdptr) {
#line 328
				netptr = grdptr->netptr;
#line 329
				pinloc = (int)netptr->pinloc;
#line 330
				if (pinloc == 1) {
#line 331
					self_reset = ((*(carray + netptr->cell))->tileptr)->top;
				}
				else {
#line 332
					if (pinloc == -1) {
#line 333
						self_reset = -((*(carray + netptr->cell))->tileptr)->bottom;
					}
					else {
#line 335
						self_reset = 0;
					}
				}
#line 337
				tmp = facing_cellheight(netptr->terminal, netptr->row, pinloc, 0);
#line 337
				grdptr->ntracks -= (self_reset + tmp) / track_spacing;
#line 326
				grdptr = (struct changrdbox *)grdptr->nextgrd;
			}
		}
#line 342
		if ((unsigned int)LLgrdptr != (unsigned int)((void *)0)) {
#line 343
			grdptr = (struct changrdbox *)LLgrdptr;
#line 343
			while ((unsigned int)grdptr != (unsigned int)LRgrdptr) {
#line 345
				netptr = grdptr->netptr;
#line 346
				pinloc = (int)netptr->pinloc;
#line 347
				if (pinloc == 1) {
#line 348
					self_reset = ((*(carray + netptr->cell))->tileptr)->top;
				}
				else {
#line 349
					if (pinloc == -1) {
#line 350
						self_reset = -((*(carray + netptr->cell))->tileptr)->bottom;
					}
					else {
#line 352
						self_reset = 0;
					}
				}
#line 354
				tmp___0 = facing_cellheight(netptr->terminal, netptr->row, pinloc, 0);
#line 354
				grdptr->ntracks -= (self_reset + tmp___0) / track_spacing;
#line 343
				grdptr = (struct changrdbox *)grdptr->nextgrd;
			}
		}
#line 359
		old_axcenter = acellptr->cxcenter;
#line 360
		old_bxcenter = bcellptr->cxcenter;
#line 361
		acellptr->cxcenter = anxcenter___0;
#line 362
		bcellptr->cxcenter = bnxcenter___0;
#line 363
		Aray = *(pairArray + row___0);
#line 364
		rowleft = (*(carray + *(Aray + 1)))->cxcenter + ((*(carray + *(Aray + 1)))->tileptr)->left;
#line 365
		startcbin = (leftx - rowleft) / cedge_binwidth + 1;
#line 366
		endcbin = (ritex - rowleft) / cedge_binwidth + 1;
#line 367
		start_i = *(*(cedgebin + row___0) + startcbin);
#line 368
		end_i = *(*(cedgebin + row___0) + endcbin);
#line 369
		bin = startcbin;
#line 370
		i = start_i;
#line 371
		cell___0 = *(Aray + i);
#line 371
		while (cell___0 != a___0) {
#line 371
			i++;
#line 371
			cell___0 = *(Aray + i);
		}
#line 372
		if (anxcenter___0 < bnxcenter___0) {
#line 373
			na_i = i - 1;
#line 374
			nb_i = i;
		}
		else {
#line 376
			na_i = i + 1;
#line 377
			nb_i = i;
		}
#line 379
		* (Aray + na_i) = a___0;
#line 380
		* (Aray + nb_i) = b___0;
#line 381
		bin--;
#line 381
		bin_rite_edge = rowleft + bin * cedge_binwidth;
#line 382
		i = start_i;
#line 382
		while (i <= end_i) {
#line 383
			cellptr___0 = (struct cellbox___0 *)*(carray + *(Aray + i));
#line 384
			crite = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
#line 385
			while (bin_rite_edge < crite) {
#line 386
				bin++;
#line 386
				* (*(cedgebin + row___0) + bin) = i;
#line 387
				bin_rite_edge += cedge_binwidth;
			}
#line 382
			i++;
		}
#line 390
		return (0);
	}
}
#line 1 "uclosepns.o"
#pragma merger(0,"./uclosepns.i","")
#line 13 "uclosepns.c"
void uclosepns(int net)
{
	int pin;
	int pin1;
	int pin2;
	int minP1;
	int minP2;
	int minX;
	int sepT;
	int sepB;
	int edge___0;
	int group1;
	int group2;
	int block1;
	int block2;
	int p1;
	int p2;
	int Tleft;
	int Tright;
	int Bleft;
	int Bright;
	int minTop;
	int minBottom;
	int maxTpin;
	int maxBpin;
	int otherTpin;
	int otherBpin;
	int maxTop;
	int maxBottom;
	int segIndex;
	int k_left;
	int k_right;
	int super_edge;
	int e1;
	int e2;
	int g1;
	int g2;
	int next_edge;
	int next_g;
	int save_count;
	int key_flag;
	int key_count;
	int fault_line;
	int channel;
	int left___0;
	int right;
	int ltop;
	int rtop;
	int lbot;
	int rbot;
	csPinBox *pArray1;
	csPinBox *pArray2;
	csPinBox *pArray;
	SEGBOXPTR tmp_ptr;
	int tmp;
	struct _reent *tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	struct _reent *tmp___7;

	{
#line 30
		key_count = 0;
#line 31
		super_edge = 0;
#line 33
		segIndex = *(anet + net) - 1;
#line 34
		fault_line = *(anet + (net + 1));
#line 36
		while (1) {
#line 37
			if (key_count > 0) {
#line 38
				tmp = key_count;
#line 38
				key_count--;
#line 38
				edge___0 = *(key_queue + tmp);
#line 39
				group1 = (edgeArray + edge___0)->group1;
#line 40
				k_left = (groupArray + group1)->aveX;
#line 41
				k_right = k_left;
#line 42
				key_flag = save_count;
			}
			else {
#line 44
				while (1) {
#line 44
					super_edge++;
#line 44
					if (!(super_edge <= numEdges)) {
#line 44
						break;
					}
#line 45
					if ((edgeArray + super_edge)->marked == 0) {
#line 46
						continue;
					}
#line 48
					if ((edgeArray + super_edge)->done == 0) {
#line 49
						break;
					}
				}
#line 52
				if (super_edge > numEdges) {
#line 53
					break;
				}
#line 55
				edge___0 = super_edge;
#line 56
				key_flag = 0;
			}
#line 59
			segIndex++;
#line 61
			if (segIndex >= fault_line) {
#line 62
				printf("Serious fault detected in function: uclosepns():");
#line 63
				printf("   Net:%d\n", net);
#line 64
				tmp___0 = __getreent();
#line 64
				fflush(tmp___0->_stdout);
			}
#line 67
			(aNetSeg + segIndex)->nflag = (char)1;
#line 68
			maxTop = -1000000000;
#line 69
			maxBottom = -1000000000;
#line 70
			maxTpin = 0;
#line 71
			maxBpin = 0;
#line 72
			group1 = (edgeArray + edge___0)->group1;
#line 73
			pArray1 = (groupArray + group1)->pinArray;
#line 74
			block1 = (groupArray + group1)->block;
#line 75
			group2 = (edgeArray + edge___0)->group2;
#line 76
			pArray2 = (groupArray + group2)->pinArray;
#line 77
			block2 = (groupArray + group2)->block;
#line 79
			if ((edgeArray + edge___0)->poison == 0) {
#line 79
				if (key_flag == 0) {
#line 80
					save_count = segIndex;
#line 81
					(edgeArray + edge___0)->done = 1;
#line 82
					key_flag = save_count;
#line 86
					e1 = edge___0;
#line 87
					g1 = (edgeArray + e1)->group1;
#line 88
					while (!((groupArray + g1)->poison == 1)) {
#line 92
						if ((groupArray + g1)->edge1 == e1) {
#line 93
							next_edge = (groupArray + g1)->edge2;
						}
						else {
#line 95
							next_edge = (groupArray + g1)->edge1;
						}
#line 97
						if (next_edge == 0) {
#line 98
							break;
						}
#line 100
						next_g = (edgeArray + next_edge)->group1;
#line 101
						if (next_g == g1) {
#line 102
							g1 = (edgeArray + next_edge)->group2;
						}
						else {
#line 104
							g1 = next_g;
						}
#line 106
						e1 = next_edge;
#line 107
						(edgeArray + e1)->done = 1;
#line 108
						key_count++;
#line 108
						* (key_queue + key_count) = e1;
					}
#line 110
					e2 = edge___0;
#line 111
					g2 = (edgeArray + e2)->group2;
#line 112
					while (!((groupArray + g2)->poison == 1)) {
#line 116
						if ((groupArray + g2)->edge1 == e2) {
#line 117
							next_edge = (groupArray + g2)->edge2;
						}
						else {
#line 119
							next_edge = (groupArray + g2)->edge1;
						}
#line 121
						if (next_edge == 0) {
#line 122
							break;
						}
#line 124
						next_g = (edgeArray + next_edge)->group1;
#line 125
						if (next_g == g2) {
#line 126
							g2 = (edgeArray + next_edge)->group2;
						}
						else {
#line 128
							g2 = next_g;
						}
#line 130
						e2 = next_edge;
#line 131
						(edgeArray + e2)->done = 1;
#line 132
						key_count++;
#line 132
						* (key_queue + key_count) = e2;
					}
#line 134
					if ((groupArray + g1)->aveX <= (groupArray + g2)->aveX) {
#line 135
						k_left = (groupArray + g1)->aveX;
#line 136
						k_right = (groupArray + g2)->aveX;
#line 137
						pArray = (groupArray + g1)->pinArray;
#line 138
						pin = 1;
#line 138
						while (pin <= (groupArray + g1)->numPins) {
#line 139
							if ((pArray + pin)->top == 1) {
#line 140
								ltop = (pArray + pin)->pin;
							}
							else {
#line 139
								if ((pArray + pin)->top == 0) {
#line 140
									ltop = (pArray + pin)->pin;
								}
							}
#line 142
							if ((pArray + pin)->top == -1) {
#line 143
								lbot = (pArray + pin)->pin;
							}
							else {
#line 142
								if ((pArray + pin)->top == 0) {
#line 143
									lbot = (pArray + pin)->pin;
								}
							}
#line 138
							pin++;
						}
#line 146
						pArray = (groupArray + g2)->pinArray;
#line 147
						pin = 1;
#line 147
						while (pin <= (groupArray + g2)->numPins) {
#line 148
							if ((pArray + pin)->top == 1) {
#line 149
								rtop = (pArray + pin)->pin;
							}
							else {
#line 148
								if ((pArray + pin)->top == 0) {
#line 149
									rtop = (pArray + pin)->pin;
								}
							}
#line 151
							if ((pArray + pin)->top == -1) {
#line 152
								rbot = (pArray + pin)->pin;
							}
							else {
#line 151
								if ((pArray + pin)->top == 0) {
#line 152
									rbot = (pArray + pin)->pin;
								}
							}
#line 147
							pin++;
						}
					}
					else {
#line 156
						k_left = (groupArray + g2)->aveX;
#line 157
						k_right = (groupArray + g1)->aveX;
#line 158
						pArray = (groupArray + g2)->pinArray;
#line 159
						pin = 1;
#line 159
						while (pin <= (groupArray + g2)->numPins) {
#line 160
							if ((pArray + pin)->top == 1) {
#line 161
								ltop = (pArray + pin)->pin;
							}
							else {
#line 160
								if ((pArray + pin)->top == 0) {
#line 161
									ltop = (pArray + pin)->pin;
								}
							}
#line 163
							if ((pArray + pin)->top == -1) {
#line 164
								lbot = (pArray + pin)->pin;
							}
							else {
#line 163
								if ((pArray + pin)->top == 0) {
#line 164
									lbot = (pArray + pin)->pin;
								}
							}
#line 159
							pin++;
						}
#line 167
						pArray = (groupArray + g1)->pinArray;
#line 168
						pin = 1;
#line 168
						while (pin <= (groupArray + g1)->numPins) {
#line 169
							if ((pArray + pin)->top == 1) {
#line 170
								rtop = (pArray + pin)->pin;
							}
							else {
#line 169
								if ((pArray + pin)->top == 0) {
#line 170
									rtop = (pArray + pin)->pin;
								}
							}
#line 172
							if ((pArray + pin)->top == -1) {
#line 173
								rbot = (pArray + pin)->pin;
							}
							else {
#line 172
								if ((pArray + pin)->top == 0) {
#line 173
									rbot = (pArray + pin)->pin;
								}
							}
#line 168
							pin++;
						}
					}
				}
			}
#line 179
			if (block1 == block2) {
#line 181
				if ((groupArray + group1)->aveX <= (groupArray + group2)->aveX) {
#line 182
					pin = 1;
#line 182
					while (pin <= (groupArray + group1)->numPins) {
#line 183
						if ((pArray1 + pin)->top == 1) {
							goto _L;
						}
						else {
#line 183
							if ((pArray1 + pin)->top == 0) {
							_L: /* CIL Label */
#line 184
								if ((pArray1 + pin)->xloc > maxTop) {
#line 185
									maxTop = (pArray1 + pin)->xloc;
#line 186
									maxTpin = (pArray1 + pin)->pin;
								}
							}
						}
#line 189
						if ((pArray1 + pin)->top == -1) {
							goto _L___0;
						}
						else {
#line 189
							if ((pArray1 + pin)->top == 0) {
							_L___0: /* CIL Label */
#line 190
								if ((pArray1 + pin)->xloc > maxBottom) {
#line 191
									maxBottom = (pArray1 + pin)->xloc;
#line 192
									maxBpin = (pArray1 + pin)->pin;
								}
							}
						}
#line 182
						pin++;
					}
#line 196
					sepT = 1000000000;
#line 197
					sepB = 1000000000;
#line 198
					otherTpin = 0;
#line 199
					otherBpin = 0;
#line 200
					pin = 1;
#line 200
					while (pin <= (groupArray + group2)->numPins) {
#line 201
						if ((pArray2 + pin)->top == 1) {
							goto _L___1;
						}
						else {
#line 201
							if ((pArray2 + pin)->top == 0) {
							_L___1: /* CIL Label */
#line 202
								tmp___1 = ABS((pArray2 + pin)->xloc - maxTop);
#line 202
								if (tmp___1 < sepT) {
#line 203
									otherTpin = (pArray2 + pin)->pin;
#line 204
									minTop = (pArray2 + pin)->xloc;
#line 205
									sepT = ABS(minTop - maxTop);
								}
							}
						}
#line 208
						if ((pArray2 + pin)->top == -1) {
							goto _L___2;
						}
						else {
#line 208
							if ((pArray2 + pin)->top == 0) {
							_L___2: /* CIL Label */
#line 209
								tmp___2 = ABS((pArray2 + pin)->xloc - maxBottom);
#line 209
								if (tmp___2 < sepB) {
#line 210
									otherBpin = (pArray2 + pin)->pin;
#line 211
									minBottom = (pArray2 + pin)->xloc;
#line 212
									sepB = ABS(minBottom - maxBottom);
								}
							}
						}
#line 200
						pin++;
					}
#line 216
					if (maxTpin != 0) {
#line 216
						if (otherTpin != 0) {
#line 216
							if (block1 < numChans) {
#line 218
								if (maxBpin != 0) {
#line 218
									if (otherBpin != 0) {
#line 218
										if (block1 > 0) {
#line 220
											(aNetSeg + segIndex)->nswYorN = (char)1;
#line 221
											if (key_flag == 0) {
#line 222
												(aNetSeg + segIndex)->nkey = 0;
											}
											else {
#line 221
												if (key_flag == segIndex) {
#line 222
													(aNetSeg + segIndex)->nkey = 0;
												}
												else {
#line 224
													(aNetSeg + segIndex)->nkey = key_flag;
												}
											}
#line 226
											(aNetSeg + segIndex)->ncurrent = (char)0;
#line 227
											if (maxTop <= minTop) {
#line 228
												Tleft = maxTop;
#line 229
												Tright = minTop;
#line 230
												p1 = maxTpin;
#line 231
												p2 = otherTpin;
											}
											else {
#line 233
												Tleft = minTop;
#line 234
												Tright = maxTop;
#line 235
												p1 = otherTpin;
#line 236
												p2 = maxTpin;
											}
#line 238
											if (key_flag != 0) {
#line 239
												Tleft = k_left;
#line 240
												Tright = k_right;
											}
#line 242
											((aNetSeg + segIndex)->ntop)->channel = block1 + 1;
#line 243
											((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 244
											((aNetSeg + segIndex)->ntop)->pin2 = p2;
#line 246
											if (maxBottom <= minBottom) {
#line 247
												Bleft = maxBottom;
#line 248
												Bright = minBottom;
#line 249
												p1 = maxBpin;
#line 250
												p2 = otherBpin;
											}
											else {
#line 252
												Bleft = minBottom;
#line 253
												Bright = maxBottom;
#line 254
												p1 = otherBpin;
#line 255
												p2 = maxBpin;
											}
#line 257
											if (key_flag != 0) {
#line 258
												Bleft = k_left;
#line 259
												Bright = k_right;
											}
#line 261
											((aNetSeg + segIndex)->nbot)->channel = block1;
#line 262
											((aNetSeg + segIndex)->nbot)->pin1 = p1;
#line 263
											((aNetSeg + segIndex)->nbot)->pin2 = p2;
#line 265
											if (Bleft == Bright) {
												goto _L___3;
											}
											else {
#line 265
												if (Tleft == Tright) {
												_L___3: /* CIL Label */
#line 266
													(aNetSeg + segIndex)->nswYorN = (char)0;
#line 267
													if (Bleft == Bright) {
#line 267
														if (Tleft != Tright) {
#line 268
															tmp_ptr = (aNetSeg + segIndex)->ntop;
#line 269
															(aNetSeg + segIndex)->ntop = (aNetSeg + segIndex)->nbot;
#line 271
															(aNetSeg + segIndex)->nbot = tmp_ptr;
														}
													}
												}
											}
										}
										else {
											goto _L___5;
										}
									}
									else {
										goto _L___5;
									}
								}
								else {
								_L___5: /* CIL Label */
#line 275
									(aNetSeg + segIndex)->nswYorN = (char)0;
#line 276
									(aNetSeg + segIndex)->nkey = 0;
#line 277
									(aNetSeg + segIndex)->ncurrent = (char)0;
#line 278
									if (maxTop <= minTop) {
#line 279
										p1 = maxTpin;
#line 280
										p2 = otherTpin;
									}
									else {
#line 282
										p1 = otherTpin;
#line 283
										p2 = maxTpin;
									}
#line 285
									((aNetSeg + segIndex)->ntop)->channel = block1 + 1;
#line 286
									((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 287
									((aNetSeg + segIndex)->ntop)->pin2 = p2;
								}
							}
							else {
								goto _L___7;
							}
						}
						else {
							goto _L___7;
						}
					}
					else {
					_L___7: /* CIL Label */
#line 289
						if (maxBpin != 0) {
#line 289
							if (otherBpin != 0) {
#line 291
								(aNetSeg + segIndex)->nswYorN = (char)0;
#line 292
								(aNetSeg + segIndex)->nkey = 0;
#line 293
								(aNetSeg + segIndex)->ncurrent = (char)0;
#line 294
								if (maxBottom <= minBottom) {
#line 295
									p1 = maxBpin;
#line 296
									p2 = otherBpin;
								}
								else {
#line 298
									p1 = otherBpin;
#line 299
									p2 = maxBpin;
								}
#line 301
								((aNetSeg + segIndex)->ntop)->channel = block1;
#line 302
								((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 303
								((aNetSeg + segIndex)->ntop)->pin2 = p2;
							}
						}
					}
				}
				else {
#line 306
					pin = 1;
#line 306
					while (pin <= (groupArray + group2)->numPins) {
#line 307
						if ((pArray2 + pin)->top == 1) {
							goto _L___8;
						}
						else {
#line 307
							if ((pArray2 + pin)->top == 0) {
							_L___8: /* CIL Label */
#line 308
								if ((pArray2 + pin)->xloc > maxTop) {
#line 309
									maxTop = (pArray2 + pin)->xloc;
#line 310
									maxTpin = (pArray2 + pin)->pin;
								}
							}
						}
#line 313
						if ((pArray2 + pin)->top == -1) {
							goto _L___9;
						}
						else {
#line 313
							if ((pArray2 + pin)->top == 0) {
							_L___9: /* CIL Label */
#line 314
								if ((pArray2 + pin)->xloc > maxBottom) {
#line 315
									maxBottom = (pArray2 + pin)->xloc;
#line 316
									maxBpin = (pArray2 + pin)->pin;
								}
							}
						}
#line 306
						pin++;
					}
#line 320
					sepT = 1000000000;
#line 321
					sepB = 1000000000;
#line 322
					otherTpin = 0;
#line 323
					otherBpin = 0;
#line 324
					pin = 1;
#line 324
					while (pin <= (groupArray + group1)->numPins) {
#line 325
						if ((pArray1 + pin)->top == 1) {
							goto _L___10;
						}
						else {
#line 325
							if ((pArray1 + pin)->top == 0) {
							_L___10: /* CIL Label */
#line 326
								tmp___3 = ABS((pArray1 + pin)->xloc - maxTop);
#line 326
								if (tmp___3 < sepT) {
#line 327
									otherTpin = (pArray1 + pin)->pin;
#line 328
									minTop = (pArray1 + pin)->xloc;
#line 329
									sepT = ABS(minTop - maxTop);
								}
							}
						}
#line 332
						if ((pArray1 + pin)->top == -1) {
							goto _L___11;
						}
						else {
#line 332
							if ((pArray1 + pin)->top == 0) {
							_L___11: /* CIL Label */
#line 333
								tmp___4 = ABS((pArray1 + pin)->xloc - maxBottom);
#line 333
								if (tmp___4 < sepB) {
#line 334
									otherBpin = (pArray1 + pin)->pin;
#line 335
									minBottom = (pArray1 + pin)->xloc;
#line 336
									sepB = ABS(minBottom - maxBottom);
								}
							}
						}
#line 324
						pin++;
					}
#line 340
					if (maxTpin != 0) {
#line 340
						if (otherTpin != 0) {
#line 340
							if (block1 < numChans) {
#line 342
								if (maxBpin != 0) {
#line 342
									if (otherBpin != 0) {
#line 342
										if (block1 > 0) {
#line 344
											(aNetSeg + segIndex)->nswYorN = (char)1;
#line 345
											if (key_flag == 0) {
#line 346
												(aNetSeg + segIndex)->nkey = 0;
											}
											else {
#line 345
												if (key_flag == segIndex) {
#line 346
													(aNetSeg + segIndex)->nkey = 0;
												}
												else {
#line 348
													(aNetSeg + segIndex)->nkey = key_flag;
												}
											}
#line 350
											(aNetSeg + segIndex)->ncurrent = (char)0;
#line 351
											if (maxTop <= minTop) {
#line 352
												Tleft = maxTop;
#line 353
												Tright = minTop;
#line 354
												p1 = maxTpin;
#line 355
												p2 = otherTpin;
											}
											else {
#line 357
												Tleft = minTop;
#line 358
												Tright = maxTop;
#line 359
												p1 = otherTpin;
#line 360
												p2 = maxTpin;
											}
#line 362
											if (key_flag != 0) {
#line 363
												Tleft = k_left;
#line 364
												Tright = k_right;
											}
#line 366
											((aNetSeg + segIndex)->ntop)->channel = block1 + 1;
#line 367
											((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 368
											((aNetSeg + segIndex)->ntop)->pin2 = p2;
#line 370
											if (maxBottom <= minBottom) {
#line 371
												Bleft = maxBottom;
#line 372
												Bright = minBottom;
#line 373
												p1 = maxBpin;
#line 374
												p2 = otherBpin;
											}
											else {
#line 376
												Bleft = minBottom;
#line 377
												Bright = maxBottom;
#line 378
												p1 = otherBpin;
#line 379
												p2 = maxBpin;
											}
#line 381
											if (key_flag != 0) {
#line 382
												Bleft = k_left;
#line 383
												Bright = k_right;
											}
#line 385
											((aNetSeg + segIndex)->nbot)->channel = block1;
#line 386
											((aNetSeg + segIndex)->nbot)->pin1 = p1;
#line 387
											((aNetSeg + segIndex)->nbot)->pin2 = p2;
#line 389
											if (Bleft == Bright) {
												goto _L___12;
											}
											else {
#line 389
												if (Tleft == Tright) {
												_L___12: /* CIL Label */
#line 390
													(aNetSeg + segIndex)->nswYorN = (char)0;
#line 391
													if (Bleft == Bright) {
#line 391
														if (Tleft != Tright) {
#line 392
															tmp_ptr = (aNetSeg + segIndex)->ntop;
#line 393
															(aNetSeg + segIndex)->ntop = (aNetSeg + segIndex)->nbot;
#line 395
															(aNetSeg + segIndex)->nbot = tmp_ptr;
														}
													}
												}
											}
										}
										else {
											goto _L___14;
										}
									}
									else {
										goto _L___14;
									}
								}
								else {
								_L___14: /* CIL Label */
#line 399
									(aNetSeg + segIndex)->nswYorN = (char)0;
#line 400
									(aNetSeg + segIndex)->nkey = 0;
#line 401
									(aNetSeg + segIndex)->ncurrent = (char)0;
#line 402
									if (maxTop <= minTop) {
#line 403
										p1 = maxTpin;
#line 404
										p2 = otherTpin;
									}
									else {
#line 406
										p1 = otherTpin;
#line 407
										p2 = maxTpin;
									}
#line 409
									((aNetSeg + segIndex)->ntop)->channel = block1 + 1;
#line 410
									((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 411
									((aNetSeg + segIndex)->ntop)->pin2 = p2;
								}
							}
							else {
								goto _L___16;
							}
						}
						else {
							goto _L___16;
						}
					}
					else {
					_L___16: /* CIL Label */
#line 413
						if (maxBpin != 0) {
#line 413
							if (otherBpin != 0) {
#line 415
								(aNetSeg + segIndex)->nswYorN = (char)0;
#line 416
								(aNetSeg + segIndex)->nkey = 0;
#line 417
								(aNetSeg + segIndex)->ncurrent = (char)0;
#line 418
								if (maxBottom <= minBottom) {
#line 419
									p1 = maxBpin;
#line 420
									p2 = otherBpin;
								}
								else {
#line 422
									p1 = otherBpin;
#line 423
									p2 = maxBpin;
								}
#line 425
								((aNetSeg + segIndex)->ntop)->channel = block1;
#line 426
								((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 427
								((aNetSeg + segIndex)->ntop)->pin2 = p2;
							}
						}
					}
				}
#line 430
				if ((int)(aNetSeg + segIndex)->nswYorN == 1) {
					goto _L___17;
				}
				else {
#line 430
					if (key_flag != 0) {
					_L___17: /* CIL Label */
#line 431
						channel = ((aNetSeg + segIndex)->ntop)->channel;
#line 432
						if (key_flag == 0) {
#line 433
							pin1 = ((aNetSeg + segIndex)->ntop)->pin1;
#line 434
							pin2 = ((aNetSeg + segIndex)->ntop)->pin2;
						}
						else {
#line 436
							if (k_right > k_left) {
#line 437
								pin1 = ltop;
#line 438
								pin2 = rtop;
							}
							else {
#line 440
								pin2 = ((aNetSeg + segIndex)->ntop)->pin1;
#line 440
								pin1 = pin2;
							}
						}
#line 443
						((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->up;
#line 444
						if ((int)(*(tearray + pin1))->pinloc == 0) {
#line 444
							if ((*(tearray + pin1))->row == channel) {
#line 446
								((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->down;
							}
						}
#line 448
						((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->up;
#line 449
						if ((int)(*(tearray + pin2))->pinloc == 0) {
#line 449
							if ((*(tearray + pin2))->row == channel) {
#line 451
								((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->down;
							}
						}
#line 454
						channel = ((aNetSeg + segIndex)->nbot)->channel;
#line 455
						if (key_flag == 0) {
#line 456
							pin1 = ((aNetSeg + segIndex)->nbot)->pin1;
#line 457
							pin2 = ((aNetSeg + segIndex)->nbot)->pin2;
						}
						else {
#line 459
							if (k_right > k_left) {
#line 460
								pin1 = lbot;
#line 461
								pin2 = rbot;
							}
							else {
#line 463
								pin2 = ((aNetSeg + segIndex)->nbot)->pin1;
#line 463
								pin1 = pin2;
							}
						}
#line 466
						((aNetSeg + segIndex)->nbot)->pin1ptr = (*(Tgrid + pin1))->up;
#line 467
						if ((int)(*(tearray + pin1))->pinloc == 0) {
#line 467
							if ((*(tearray + pin1))->row == channel) {
#line 469
								((aNetSeg + segIndex)->nbot)->pin1ptr = (*(Tgrid + pin1))->down;
							}
						}
#line 471
						((aNetSeg + segIndex)->nbot)->pin2ptr = (*(Tgrid + pin2))->up;
#line 472
						if ((int)(*(tearray + pin2))->pinloc == 0) {
#line 472
							if ((*(tearray + pin2))->row == channel) {
#line 474
								((aNetSeg + segIndex)->nbot)->pin2ptr = (*(Tgrid + pin2))->down;
							}
						}
					}
					else {
#line 477
						channel = ((aNetSeg + segIndex)->ntop)->channel;
#line 478
						if (key_flag == 0) {
#line 479
							pin1 = ((aNetSeg + segIndex)->ntop)->pin1;
#line 480
							pin2 = ((aNetSeg + segIndex)->ntop)->pin2;
						}
						else {
#line 482
							if (k_right > k_left) {
#line 483
								pin1 = ltop;
#line 484
								pin2 = rtop;
							}
							else {
#line 486
								pin2 = ((aNetSeg + segIndex)->ntop)->pin1;
#line 486
								pin1 = pin2;
							}
						}
#line 489
						((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->up;
#line 490
						if ((int)(*(tearray + pin1))->pinloc == 0) {
#line 490
							if ((*(tearray + pin1))->row == channel) {
#line 492
								((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->down;
							}
						}
#line 494
						((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->up;
#line 495
						if ((int)(*(tearray + pin2))->pinloc == 0) {
#line 495
							if ((*(tearray + pin2))->row == channel) {
#line 497
								((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->down;
							}
						}
					}
				}
			}
			else {
#line 501
				minX = 1000000000;
#line 502
				minP1 = 0;
#line 503
				minP2 = 0;
#line 504
				if (block1 > block2) {
#line 505
					pin1 = 1;
#line 505
					while (pin1 <= (groupArray + group1)->numPins) {
#line 506
						if ((pArray1 + pin1)->top == -1) {
							goto _L___19;
						}
						else {
#line 506
							if ((pArray1 + pin1)->top == 0) {
							_L___19: /* CIL Label */
#line 508
								pin2 = 1;
#line 509
								while (pin2 <= (groupArray + group2)->numPins) {
#line 510
									if ((pArray2 + pin2)->top == 1) {
										goto _L___18;
									}
									else {
#line 510
										if ((pArray2 + pin2)->top == 0) {
										_L___18: /* CIL Label */
#line 512
											tmp___5 = ABS((pArray1 + pin1)->xloc - (pArray2 + pin2)->xloc);
#line 512
											if (tmp___5 < minX) {
#line 514
												left___0 = (pArray1 + pin1)->xloc;
#line 515
												right = (pArray2 + pin2)->xloc;
#line 516
												minX = ABS(left___0 - right);
#line 517
												minP1 = (pArray1 + pin1)->pin;
#line 518
												minP2 = (pArray2 + pin2)->pin;
											}
										}
									}
#line 509
									pin2++;
								}
							}
						}
#line 505
						pin1++;
					}
#line 524
					if (minP1 != 0) {
#line 524
						if (minP2 != 0) {
#line 525
							(aNetSeg + segIndex)->nswYorN = (char)0;
#line 526
							(aNetSeg + segIndex)->nkey = 0;
#line 527
							(aNetSeg + segIndex)->ncurrent = (char)0;
#line 528
							if (left___0 > right) {
#line 529
								((aNetSeg + segIndex)->ntop)->channel = block1;
#line 530
								((aNetSeg + segIndex)->ntop)->pin1 = minP2;
#line 531
								((aNetSeg + segIndex)->ntop)->pin2 = minP1;
							}
							else {
#line 533
								((aNetSeg + segIndex)->ntop)->channel = block1;
#line 534
								((aNetSeg + segIndex)->ntop)->pin1 = minP1;
#line 535
								((aNetSeg + segIndex)->ntop)->pin2 = minP2;
							}
						}
					}
				}
				else {
#line 539
					pin1 = 1;
#line 540
					while (pin1 <= (groupArray + group1)->numPins) {
#line 541
						if ((pArray1 + pin1)->top == 1) {
							goto _L___21;
						}
						else {
#line 541
							if ((pArray1 + pin1)->top == 0) {
							_L___21: /* CIL Label */
#line 543
								pin2 = 1;
#line 544
								while (pin2 <= (groupArray + group2)->numPins) {
#line 545
									if ((pArray2 + pin2)->top == -1) {
										goto _L___20;
									}
									else {
#line 545
										if ((pArray2 + pin2)->top == 0) {
										_L___20: /* CIL Label */
#line 547
											tmp___6 = ABS((pArray1 + pin1)->xloc - (pArray2 + pin2)->xloc);
#line 547
											if (tmp___6 < minX) {
#line 549
												left___0 = (pArray1 + pin1)->xloc;
#line 550
												right = (pArray2 + pin2)->xloc;
#line 551
												minX = ABS(left___0 - right);
#line 552
												minP1 = (pArray1 + pin1)->pin;
#line 553
												minP2 = (pArray2 + pin2)->pin;
											}
										}
									}
#line 544
									pin2++;
								}
							}
						}
#line 540
						pin1++;
					}
#line 559
					if (minP1 != 0) {
#line 559
						if (minP2 != 0) {
#line 560
							(aNetSeg + segIndex)->nswYorN = (char)0;
#line 561
							(aNetSeg + segIndex)->nkey = 0;
#line 562
							(aNetSeg + segIndex)->ncurrent = (char)0;
#line 563
							if (left___0 > right) {
#line 564
								((aNetSeg + segIndex)->ntop)->channel = block2;
#line 565
								((aNetSeg + segIndex)->ntop)->pin1 = minP2;
#line 566
								((aNetSeg + segIndex)->ntop)->pin2 = minP1;
							}
							else {
#line 568
								((aNetSeg + segIndex)->ntop)->channel = block2;
#line 569
								((aNetSeg + segIndex)->ntop)->pin1 = minP1;
#line 570
								((aNetSeg + segIndex)->ntop)->pin2 = minP2;
							}
						}
					}
				}
#line 574
				channel = ((aNetSeg + segIndex)->ntop)->channel;
#line 575
				pin1 = ((aNetSeg + segIndex)->ntop)->pin1;
#line 576
				pin2 = ((aNetSeg + segIndex)->ntop)->pin2;
#line 577
				((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->up;
#line 578
				if ((int)(*(tearray + pin1))->pinloc == 0) {
#line 578
					if ((*(tearray + pin1))->row == channel) {
#line 580
						((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->down;
					}
				}
#line 582
				((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->up;
#line 583
				if ((int)(*(tearray + pin2))->pinloc == 0) {
#line 583
					if ((*(tearray + pin2))->row == channel) {
#line 585
						((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->down;
					}
				}
			}
		}
#line 590
		if (segIndex != fault_line - 1) {
#line 591
			printf("Serious FAULT detected in function: uclosepns():");
#line 592
			printf("   Net:%d\n", net);
#line 593
			tmp___7 = __getreent();
#line 593
			fflush(tmp___7->_stdout);
		}
#line 596
		return;
	}
}
#line 1 "ucxx1.o"
#pragma merger(0,"./ucxx1.i","")
#line 8 "ucxxglb.h"
int wire_chg;
#line 8
int binpen_chg;
#line 8
int rowpen_chg;
#line 9
int newpenal;
#line 12
int a;
#line 13
int Apost;
#line 14
int *cellaptr;
#line 14
int *cellbptr;
#line 19
void remv_cell(int *cellptr___0, int post);
#line 2 "ucxx1.c"
void remv_cell(int *cellptr___0, int post)
{

	{
#line 4
		if (*cellptr___0 != post) {
#line 6
			* (cellptr___0 + post) = *(cellptr___0 + *cellptr___0);
#line 6
			(*cellptr___0)--;
		}
		else {
#line 9
			(*cellptr___0)--;
		}
#line 10
		return;
	}
}
#line 81
int add_cell(int **cellptr___0, int c);
#line 11 "ucxx1.c"
int ucxx1(int bxcenter___0, int bycenter___0)
{
	CBOXPTR acellptr___0;
	TIBOXPTR atileptr;
	TEBOXPTR atermptr;
	int cost;
	int axcenter___0;
	int aleft___0;
	int aright___0;
	int a1LoBin;
	int a1HiBin;
	int b1LoBin;
	int b1HiBin;
	int startxa1;
	int endxa1;
	int startxb1;
	int endxb1;
	int truth;
	int aorient;

	{
#line 25
		acellptr___0 = *(carray + a);
#line 26
		aorient = (int)acellptr___0->corient;
#line 27
		axcenter___0 = acellptr___0->cxcenter;
#line 28
		atileptr = acellptr___0->tileptr;
#line 29
		aleft___0 = atileptr->left;
#line 30
		aright___0 = atileptr->right;
#line 31
		atermptr = atileptr->termsptr;
#line 33
		newbinpenal = binpenal;
#line 34
		newrowpenal = rowpenal;
#line 35
		newpenal = penalty;
#line 37
		new_old(aleft___0 - aright___0);
#line 40
		startxa1 = axcenter___0 + aleft___0;
#line 40
		a1LoBin = SetBin(startxa1);
#line 41
		endxa1 = axcenter___0 + aright___0;
#line 41
		a1HiBin = SetBin(endxa1);
#line 42
		startxb1 = bxcenter___0 + aleft___0;
#line 42
		b1LoBin = SetBin(startxb1);
#line 43
		endxb1 = bxcenter___0 + aright___0;
#line 43
		b1HiBin = SetBin(endxb1);
#line 45
		old_assgnto_new1(a1LoBin, a1HiBin, b1LoBin, b1HiBin);
#line 47
		sub_penal(startxa1, endxa1, ablock, a1LoBin, a1HiBin);
#line 48
		add_penal(startxb1, endxb1, bblock, b1LoBin, b1HiBin);
#line 50
		if (ablock != bblock) {
#line 51
			term_newpos_a(atermptr, bxcenter___0, bycenter___0, aorient);
		}
		else {
#line 53
			term_newpos(atermptr, bxcenter___0, bycenter___0, aorient);
		}
#line 56
		cost = funccost;
#line 58
		delta_vert_cost = 0;
#line 59
		if (ablock != bblock) {
#line 60
			new_dbox_a(atermptr, &cost);
		}
		else {
#line 62
			new_dbox(atermptr, &cost);
		}
#line 65
		wire_chg = cost - funccost;
#line 66
		binpen_chg = newbinpenal - binpenal;
#line 67
		rowpen_chg = newrowpenal - rowpenal;
#line 69
		newpenal = (int)(roLenCon * (float)newrowpenal + binpenCon * (float)newbinpenal);
#line 71
		truth = acceptt((((funccost + penalty) - cost) - newpenal) - delta_vert_cost);
#line 72
		if (truth == 1) {
#line 73
			new_assgnto_old1(a1LoBin, a1HiBin, b1LoBin, b1HiBin);
#line 74
			if (ablock != bblock) {
#line 75
				dbox_pos_2(atermptr);
			}
			else {
#line 77
				dbox_pos(atermptr);
			}
#line 80
			remv_cell(cellaptr, Apost);
#line 81
			add_cell(&cellbptr, a);
#line 84
			acellptr___0->cblock = bblock;
#line 85
			acellptr___0->cxcenter = bxcenter___0;
#line 86
			acellptr___0->cycenter = bycenter___0;
#line 88
			funccost = cost;
#line 89
			binpenal = newbinpenal;
#line 90
			rowpenal = newrowpenal;
#line 91
			penalty = newpenal;
#line 93
			if (ablock != bblock) {
#line 94
				(*(barray + ablock))->oldsize = (*(barray + ablock))->newsize;
#line 95
				(*(barray + bblock))->oldsize = (*(barray + bblock))->newsize;
			}
#line 97
			return (1);
		}
		else {
#line 99
			return (0);
		}
	}
}
#line 1 "ucxx2.o"
#pragma merger(0,"./ucxx2.i","")
#line 12 "ucxxglb.h"
int b;
#line 13
int Bpost;
#line 15
int earlyRej;
#line 3 "ucxx2.c"
int axcenter;
#line 3 "ucxx2.c"
int aycenter;
#line 3 "ucxx2.c"
int bxcenter;
#line 3 "ucxx2.c"
int bycenter;
#line 4 "ucxx2.c"
int anxcenter;
#line 4 "ucxx2.c"
int bnxcenter;
#line 5 "ucxx2.c"
int aleft;
#line 5 "ucxx2.c"
int aright;
#line 5 "ucxx2.c"
int bleft;
#line 5 "ucxx2.c"
int bright;
#line 6 "ucxx2.c"
int potential_errors;
#line 6 "ucxx2.c"
int error_count;
#line 6 "ucxx2.c"
int P_limit;
#line 7 "ucxx2.c"
float total_wire_chg;
#line 8 "ucxx2.c"
float sigma_wire_chg;
#line 9 "ucxx2.c"
float mean_wire_chg;
#line 10 "ucxx2.c"
int wire_chgs;
#line 60
int find_new_pos(void);
#line 13 "ucxx2.c"
int ucxx2(void)
{
	CBOXPTR acellptr___0;
	CBOXPTR bcellptr___0;
	TIBOXPTR atileptr;
	TIBOXPTR btileptr;
	TEBOXPTR atermptr;
	TEBOXPTR btermptr;
	int error_light_is_on;
	int cost;
	int aorient;
	int borient___0;
	int a1LoBin;
	int a1HiBin;
	int b1LoBin;
	int b1HiBin;
	int a2LoBin;
	int a2HiBin;
	int b2LoBin;
	int b2HiBin;
	int startxa1;
	int endxa1;
	int startxa2;
	int endxa2;
	int startxb1;
	int endxb1;
	int startxb2;
	int endxb2;
	int anbin;
	int bnbin;
	int i;
	int truth;
	float temp;

	{
#line 32
		acellptr___0 = *(carray + a);
#line 33
		axcenter = acellptr___0->cxcenter;
#line 34
		aycenter = acellptr___0->cycenter;
#line 35
		aorient = (int)acellptr___0->corient;
#line 36
		atileptr = acellptr___0->tileptr;
#line 37
		aleft = atileptr->left;
#line 38
		aright = atileptr->right;
#line 39
		atermptr = atileptr->termsptr;
#line 41
		bcellptr___0 = *(carray + b);
#line 42
		bxcenter = bcellptr___0->cxcenter;
#line 43
		bycenter = bcellptr___0->cycenter;
#line 44
		borient___0 = (int)bcellptr___0->corient;
#line 45
		btileptr = bcellptr___0->tileptr;
#line 46
		bleft = btileptr->left;
#line 47
		bright = btileptr->right;
#line 48
		btermptr = btileptr->termsptr;
#line 50
		newbinpenal = binpenal;
#line 55
		newrowpenal = rowpenal;
#line 56
		newpenal = penalty;
#line 58
		new_old(((bright - bleft) - aright) + aleft);
#line 60
		find_new_pos();
#line 64
		startxa1 = axcenter + aleft;
#line 64
		a1LoBin = SetBin(startxa1);
#line 65
		endxa1 = axcenter + aright;
#line 65
		a1HiBin = SetBin(endxa1);
#line 66
		startxb1 = bxcenter + bleft;
#line 66
		b1LoBin = SetBin(startxb1);
#line 67
		endxb1 = bxcenter + bright;
#line 67
		b1HiBin = SetBin(endxb1);
#line 68
		startxa2 = anxcenter + aleft;
#line 68
		a2LoBin = SetBin(startxa2);
#line 69
		endxa2 = anxcenter + aright;
#line 69
		a2HiBin = SetBin(endxa2);
#line 70
		startxb2 = bnxcenter + bleft;
#line 70
		b2LoBin = SetBin(startxb2);
#line 71
		endxb2 = bnxcenter + bright;
#line 71
		b2HiBin = SetBin(endxb2);
#line 73
		old_assgnto_new2(a1LoBin, a1HiBin, b1LoBin, b1HiBin, a2LoBin, a2HiBin, b2LoBin,
			b2HiBin);
#line 79
		sub_penal(startxa1, endxa1, ablock, a1LoBin, a1HiBin);
#line 83
		sub_penal(startxb1, endxb1, bblock, b1LoBin, b1HiBin);
#line 84
		add_penal(startxa2, endxa2, bblock, a2LoBin, a2HiBin);
#line 85
		add_penal(startxb2, endxb2, ablock, b2LoBin, b2HiBin);
#line 90
		binpen_chg = newbinpenal - binpenal;
#line 91
		rowpen_chg = newrowpenal - rowpenal;
#line 92
		newpenal = (int)(roLenCon * (float)newrowpenal + binpenCon * (float)newbinpenal);
#line 99
		error_light_is_on = 0;
#line 100
		if (newpenal - penalty > P_limit) {
#line 101
			if (potential_errors < 100) {
#line 102
				potential_errors++;
#line 103
				error_light_is_on = 1;
			}
			else {
#line 105
				earlyRej++;
#line 106
				return (-1);
			}
		}
#line 112
		if (ablock != bblock) {
#line 113
			term_newpos_a(atermptr, anxcenter, bycenter, aorient);
#line 114
			term_newpos_b(btermptr, bnxcenter, aycenter, borient___0);
		}
		else {
#line 116
			term_newpos(atermptr, anxcenter, bycenter, aorient);
#line 117
			term_newpos(btermptr, bnxcenter, aycenter, borient___0);
		}
#line 122
		cost = funccost;
#line 124
		delta_vert_cost = 0;
#line 125
		if (ablock != bblock) {
#line 126
			new_dbox_a(atermptr, &cost);
#line 127
			new_dbox_a(btermptr, &cost);
		}
		else {
#line 129
			new_dbox(atermptr, &cost);
#line 130
			new_dbox(btermptr, &cost);
		}
#line 133
		wire_chg = cost - funccost;
#line 137
		truth = acceptt((((funccost + penalty) - cost) - newpenal) - delta_vert_cost);
#line 141
		if (truth == 1) {
#line 143
			if (error_light_is_on) {
#line 144
				error_count++;
			}
#line 146
			new_assgnto_old2(a1LoBin, a1HiBin, b1LoBin, b1HiBin, a2LoBin, a2HiBin, b2LoBin,
				b2HiBin);
#line 148
			if (ablock != bblock) {
#line 149
				dbox_pos_2(atermptr);
#line 150
				dbox_pos_2(btermptr);
			}
			else {
#line 152
				dbox_pos(atermptr);
#line 153
				dbox_pos(btermptr);
			}
#line 155
			anbin = SetBin(anxcenter);
#line 156
			bnbin = SetBin(bnxcenter);
#line 157
			if ((unsigned int)cellaptr != (unsigned int)cellbptr) {
#line 158
				remv_cell(cellaptr, Apost);
#line 159
				remv_cell(cellbptr, Bpost);
#line 160
				add_cell(&(*(*(binptr + bblock) + anbin))->cell, a);
#line 161
				add_cell(&(*(*(binptr + ablock) + bnbin))->cell, b);
			}
			else {
#line 163
				remv_cell(cellaptr, Apost);
#line 164
				i = 1;
#line 164
				while (i <= *cellaptr) {
#line 165
					if (*(cellaptr + i) == b) {
#line 166
						break;
					}
#line 164
					i++;
				}
#line 169
				remv_cell(cellaptr, i);
#line 170
				add_cell(&(*(*(binptr + ablock) + anbin))->cell, a);
#line 171
				add_cell(&(*(*(binptr + ablock) + bnbin))->cell, b);
			}
#line 173
			if (wire_chg < 0) {
#line 174
				temp = (float)(-wire_chg);
#line 175
				total_wire_chg += temp;
#line 176
				sigma_wire_chg += (temp - mean_wire_chg) * (temp - mean_wire_chg);
#line 178
				wire_chgs++;
			}
#line 193
			acellptr___0->cblock = bblock;
#line 194
			acellptr___0->cxcenter = anxcenter;
#line 195
			acellptr___0->cycenter = bycenter;
#line 196
			bcellptr___0->cblock = ablock;
#line 197
			bcellptr___0->cxcenter = bnxcenter;
#line 198
			bcellptr___0->cycenter = aycenter;
#line 202
			funccost = cost;
#line 203
			binpenal = newbinpenal;
#line 204
			rowpenal = newrowpenal;
#line 205
			penalty = newpenal;
#line 209
			if (ablock != bblock) {
#line 210
				(*(barray + ablock))->oldsize = (*(barray + ablock))->newsize;
#line 211
				(*(barray + bblock))->oldsize = (*(barray + bblock))->newsize;
			}
#line 216
			return (1);
		}
		else {
#line 218
			return (0);
		}
	}
}
#line 223 "ucxx2.c"
int find_new_pos(void)
{
	int newA_l;
	int newA_r;
	int newB_l;
	int newB_r;
	int oldA_l;
	int oldA_r;
	int oldB_l;
	int oldB_r;
	int span;
	int target;
	int target_l;
	int target_r;
	int blkLeft;
	int blkRite;
	int dist1;
	int dist2;
	int tmp;
	int tmp___0;

	{
#line 232
		newA_l = bxcenter + aleft;
#line 233
		newA_r = bxcenter + aright;
#line 234
		newB_l = axcenter + bleft;
#line 235
		newB_r = axcenter + bright;
#line 236
		if (ablock == bblock) {
#line 236
			if (newA_l >= newB_r) {
#line 289
				anxcenter = bxcenter;
#line 290
				bnxcenter = axcenter;
			}
			else {
#line 236
				if (newB_l >= newA_r) {
#line 289
					anxcenter = bxcenter;
#line 290
					bnxcenter = axcenter;
				}
				else {
#line 240
					oldA_l = axcenter + aleft;
#line 241
					oldA_r = axcenter + aright;
#line 242
					oldB_l = bxcenter + bleft;
#line 243
					oldB_r = bxcenter + bright;
#line 244
					if (oldA_l >= oldB_r) {
						goto _L;
					}
					else {
#line 244
						if (oldB_l >= oldA_r) {
						_L: /* CIL Label */
#line 280
							if (oldA_l <= oldB_l) {
#line 281
								bnxcenter = oldA_l - bleft;
#line 282
								anxcenter = oldB_r - aright;
							}
							else {
#line 284
								anxcenter = oldB_l - aleft;
#line 285
								bnxcenter = oldA_r - bright;
							}
						}
						else {
#line 250
							span = ((aright - aleft) + bright) - bleft;
#line 251
							if (oldA_l <= oldB_l) {
#line 251
								tmp = oldA_l;
							}
							else {
#line 251
								tmp = oldB_l;
							}
#line 251
							if (oldA_r >= oldB_r) {
#line 251
								tmp___0 = oldA_r;
							}
							else {
#line 251
								tmp___0 = oldB_r;
							}
#line 251
							target = (tmp + tmp___0) / 2;
#line 253
							target_l = target - span / 2;
#line 254
							target_r = target_l + span;
#line 255
							blkLeft = (*(barray + ablock))->bxcenter + (*(barray + ablock))->bleft;
#line 256
							blkRite = blkLeft + (*(barray + ablock))->desire;
#line 257
							if (target_l < blkLeft) {
#line 258
								target_l += blkLeft - target_l;
#line 259
								target_r += blkLeft - target_l;
							}
							else {
#line 260
								if (target_r > blkRite) {
#line 261
									target_l -= target_r - blkRite;
#line 262
									target_r -= target_r - blkRite;
								}
							}
#line 264
							dist1 = newA_r - newB_l;
#line 265
							dist2 = newB_r - newA_l;
#line 266
							if (dist1 <= dist2) {
#line 267
								anxcenter = target_l - aleft;
#line 268
								bnxcenter = target_r - bright;
							}
							else {
#line 270
								anxcenter = target_r - aright;
#line 271
								bnxcenter = target_l - bleft;
							}
						}
					}
				}
			}
		}
		else {
#line 289
			anxcenter = bxcenter;
#line 290
			bnxcenter = axcenter;
		}
#line 293
		return;
	}
}
#line 297 "ucxx2.c"
int add_cell(int **cellptr___0, int c)
{
	int k___0;
	char *tmp;

	{
#line 302
		(*(*cellptr___0))++;
#line 302
		k___0 = *(*cellptr___0);
#line 302
		if (k___0 % 10 == 0) {
#line 303
			tmp = safe_realloc((char *)*cellptr___0, (unsigned int)(k___0 + 10) * sizeof(int));
#line 303
			* cellptr___0 = (int *)tmp;
		}
#line 306
		* (*cellptr___0 + k___0) = c;
#line 308
		return;
	}
}
#line 1 "ucxxo1.o"
#pragma merger(0,"./ucxxo1.i","")
#line 3 "ucxxo1.c"
int ucxxo1(int bxcenter___0, int bycenter___0, int newaor)
{
	CBOXPTR acellptr___0;
	TIBOXPTR atileptr;
	TEBOXPTR antrmptr;
	int cost;
	int axcenter___0;
	int aleft___0;
	int aright___0;
	int a1LoBin;
	int a1HiBin;
	int b1LoBin;
	int b1HiBin;
	int startxa1;
	int endxa1;
	int startxb1;
	int endxb1;
	int truth;

	{
#line 17
		acellptr___0 = *(carray + a);
#line 18
		axcenter___0 = acellptr___0->cxcenter;
#line 19
		atileptr = acellptr___0->tileptr;
#line 20
		aleft___0 = atileptr->left;
#line 21
		aright___0 = atileptr->right;
#line 22
		antrmptr = atileptr->termsptr;
#line 24
		newbinpenal = binpenal;
#line 25
		newrowpenal = rowpenal;
#line 26
		newpenal = penalty;
#line 28
		new_old(aleft___0 - aright___0);
#line 30
		startxa1 = axcenter___0 + aleft___0;
#line 30
		a1LoBin = SetBin(startxa1);
#line 31
		endxa1 = axcenter___0 + aright___0;
#line 31
		a1HiBin = SetBin(endxa1);
#line 32
		startxb1 = bxcenter___0 + aleft___0;
#line 32
		b1LoBin = SetBin(startxb1);
#line 33
		endxb1 = bxcenter___0 + aright___0;
#line 33
		b1HiBin = SetBin(endxb1);
#line 35
		old_assgnto_new1(a1LoBin, a1HiBin, b1LoBin, b1HiBin);
#line 37
		sub_penal(startxa1, endxa1, ablock, a1LoBin, a1HiBin);
#line 38
		add_penal(startxb1, endxb1, bblock, b1LoBin, b1HiBin);
#line 40
		if (ablock != bblock) {
#line 41
			term_newpos_a(antrmptr, bxcenter___0, bycenter___0, newaor);
		}
		else {
#line 43
			term_newpos(antrmptr, bxcenter___0, bycenter___0, newaor);
		}
#line 46
		cost = funccost;
#line 48
		delta_vert_cost = 0;
#line 49
		if (ablock != bblock) {
#line 50
			new_dbox_a(antrmptr, &cost);
		}
		else {
#line 52
			new_dbox(antrmptr, &cost);
		}
#line 55
		wire_chg = cost - funccost;
#line 56
		binpen_chg = newbinpenal - binpenal;
#line 57
		rowpen_chg = newrowpenal - rowpenal;
#line 59
		newpenal = (int)(roLenCon * (float)newrowpenal + binpenCon * (float)newbinpenal);
#line 61
		truth = acceptt((((funccost + penalty) - cost) - newpenal) - delta_vert_cost);
#line 63
		if (truth == 1) {
#line 65
			new_assgnto_old1(a1LoBin, a1HiBin, b1LoBin, b1HiBin);
#line 67
			if (ablock != bblock) {
#line 68
				dbox_pos_2(antrmptr);
			}
			else {
#line 70
				dbox_pos(antrmptr);
			}
#line 73
			remv_cell(cellaptr, Apost);
#line 74
			add_cell(&cellbptr, a);
#line 78
			acellptr___0->cblock = bblock;
#line 79
			acellptr___0->cxcenter = bxcenter___0;
#line 80
			acellptr___0->cycenter = bycenter___0;
#line 81
			acellptr___0->corient = (char)newaor;
#line 83
			funccost = cost;
#line 84
			binpenal = newbinpenal;
#line 85
			rowpenal = newrowpenal;
#line 86
			penalty = newpenal;
#line 88
			if (ablock != bblock) {
#line 89
				(*(barray + ablock))->oldsize = (*(barray + ablock))->newsize;
#line 90
				(*(barray + bblock))->oldsize = (*(barray + bblock))->newsize;
			}
#line 92
			return (1);
		}
		else {
#line 94
			return (0);
		}
	}
}
#line 1 "ucxxo2.o"
#pragma merger(0,"./ucxxo2.i","")
#line 10 "ucxxo2.c"
int ucxxo2(int newaor, int newbor)
{
	CBOXPTR acellptr___0;
	CBOXPTR bcellptr___0;
	TIBOXPTR atileptr;
	TIBOXPTR btileptr;
	TEBOXPTR antrmptr;
	TEBOXPTR bntrmptr;
	float temp;
	int cost;
	int error_light_is_on;
	int axcenter___0;
	int aycenter___0;
	int bxcenter___0;
	int bycenter___0;
	int aleft___0;
	int aright___0;
	int bleft___0;
	int bright___0;
	int a1LoBin;
	int a2LoBin;
	int b1LoBin;
	int b2LoBin;
	int a1HiBin;
	int a2HiBin;
	int b1HiBin;
	int b2HiBin;
	int startxa1;
	int endxa1;
	int startxa2;
	int endxa2;
	int startxb1;
	int endxb1;
	int startxb2;
	int endxb2;
	int truth;

	{
#line 27
		acellptr___0 = *(carray + a);
#line 28
		axcenter___0 = acellptr___0->cxcenter;
#line 29
		aycenter___0 = acellptr___0->cycenter;
#line 30
		atileptr = acellptr___0->tileptr;
#line 31
		aleft___0 = atileptr->left;
#line 32
		aright___0 = atileptr->right;
#line 33
		antrmptr = atileptr->termsptr;
#line 35
		bcellptr___0 = *(carray + b);
#line 36
		bxcenter___0 = bcellptr___0->cxcenter;
#line 37
		bycenter___0 = bcellptr___0->cycenter;
#line 38
		btileptr = bcellptr___0->tileptr;
#line 39
		bleft___0 = btileptr->left;
#line 40
		bright___0 = btileptr->right;
#line 41
		bntrmptr = btileptr->termsptr;
#line 43
		newbinpenal = binpenal;
#line 44
		newrowpenal = rowpenal;
#line 45
		newpenal = penalty;
#line 47
		new_old(((bright___0 - bleft___0) - aright___0) + aleft___0);
#line 49
		startxa1 = axcenter___0 + aleft___0;
#line 49
		a1LoBin = SetBin(startxa1);
#line 50
		endxa1 = axcenter___0 + aright___0;
#line 50
		a1HiBin = SetBin(endxa1);
#line 51
		startxb1 = bxcenter___0 + bleft___0;
#line 51
		b1LoBin = SetBin(startxb1);
#line 52
		endxb1 = bxcenter___0 + bright___0;
#line 52
		b1HiBin = SetBin(endxb1);
#line 53
		startxa2 = bxcenter___0 + aleft___0;
#line 53
		a2LoBin = SetBin(startxa2);
#line 54
		endxa2 = bxcenter___0 + aright___0;
#line 54
		a2HiBin = SetBin(endxa2);
#line 55
		startxb2 = axcenter___0 + bleft___0;
#line 55
		b2LoBin = SetBin(startxb2);
#line 56
		endxb2 = axcenter___0 + bright___0;
#line 56
		b2HiBin = SetBin(endxb2);
#line 58
		old_assgnto_new2(a1LoBin, a1HiBin, b1LoBin, b1HiBin, a2LoBin, a2HiBin, b2LoBin,
			b2HiBin);
#line 60
		sub_penal(startxa1, endxa1, ablock, a1LoBin, a1HiBin);
#line 61
		sub_penal(startxb1, endxb1, bblock, b1LoBin, b1HiBin);
#line 62
		add_penal(startxa2, endxa2, bblock, a2LoBin, a2HiBin);
#line 63
		add_penal(startxb2, endxb2, ablock, b2LoBin, b2HiBin);
#line 65
		binpen_chg = newbinpenal - binpenal;
#line 66
		rowpen_chg = newrowpenal - rowpenal;
#line 67
		newpenal = (int)(roLenCon * (float)newrowpenal + binpenCon * (float)newbinpenal);
#line 70
		error_light_is_on = 0;
#line 71
		if (newpenal - penalty > P_limit) {
#line 72
			if (potential_errors < 100) {
#line 73
				potential_errors++;
#line 74
				error_light_is_on = 1;
			}
			else {
#line 76
				earlyRej++;
#line 77
				return (-1);
			}
		}
#line 81
		if (ablock != bblock) {
#line 82
			term_newpos_a(antrmptr, bxcenter___0, bycenter___0, newaor);
#line 83
			term_newpos_b(bntrmptr, axcenter___0, aycenter___0, newbor);
		}
		else {
#line 85
			term_newpos(antrmptr, bxcenter___0, bycenter___0, newaor);
#line 86
			term_newpos(bntrmptr, axcenter___0, aycenter___0, newbor);
		}
#line 89
		cost = funccost;
#line 91
		delta_vert_cost = 0;
#line 92
		if (ablock != bblock) {
#line 93
			new_dbox_a(antrmptr, &cost);
#line 94
			new_dbox_a(bntrmptr, &cost);
		}
		else {
#line 96
			new_dbox(antrmptr, &cost);
#line 97
			new_dbox(bntrmptr, &cost);
		}
#line 100
		wire_chg = cost - funccost;
#line 102
		truth = acceptt((((funccost + penalty) - cost) - newpenal) - delta_vert_cost);
#line 104
		if (truth == 1) {
#line 106
			if (error_light_is_on) {
#line 107
				error_count++;
			}
#line 110
			new_assgnto_old2(a1LoBin, a1HiBin, b1LoBin, b1HiBin, a2LoBin, a2HiBin, b2LoBin,
				b2HiBin);
#line 112
			if (ablock != bblock) {
#line 113
				dbox_pos_2(antrmptr);
#line 114
				dbox_pos_2(bntrmptr);
			}
			else {
#line 116
				dbox_pos(antrmptr);
#line 117
				dbox_pos(bntrmptr);
			}
#line 119
			if ((unsigned int)cellaptr != (unsigned int)cellbptr) {
#line 120
				remv_cell(cellaptr, Apost);
#line 121
				remv_cell(cellbptr, Bpost);
#line 122
				add_cell(&cellbptr, a);
#line 123
				add_cell(&cellaptr, b);
			}
#line 125
			if (wire_chg < 0) {
#line 126
				temp = (float)(-wire_chg);
#line 127
				total_wire_chg += temp;
#line 128
				sigma_wire_chg += (temp - mean_wire_chg) * (temp - mean_wire_chg);
#line 130
				wire_chgs++;
			}
#line 138
			acellptr___0->cblock = bblock;
#line 139
			acellptr___0->cxcenter = bxcenter___0;
#line 140
			acellptr___0->cycenter = bycenter___0;
#line 141
			bcellptr___0->cblock = ablock;
#line 142
			bcellptr___0->cxcenter = axcenter___0;
#line 143
			bcellptr___0->cycenter = aycenter___0;
#line 145
			acellptr___0->corient = (char)newaor;
#line 146
			bcellptr___0->corient = (char)newbor;
#line 148
			funccost = cost;
#line 149
			binpenal = newbinpenal;
#line 150
			rowpenal = newrowpenal;
#line 151
			penalty = newpenal;
#line 153
			if (ablock != bblock) {
#line 154
				(*(barray + ablock))->oldsize = (*(barray + ablock))->newsize;
#line 155
				(*(barray + bblock))->oldsize = (*(barray + bblock))->newsize;
			}
#line 157
			return (1);
		}
		else {
#line 159
			return (0);
		}
	}
}
#line 1 "ucxxp.o"
#pragma merger(0,"./ucxxp.i","")
#line 3 "ucxxp.c"
int ucxxp(int a___0, int b___0, int anxcenter___0, int bnxcenter___0)
{
	CBOXPTR acellptr___0;
	CBOXPTR bcellptr___0;
	TIBOXPTR atileptr;
	TIBOXPTR btileptr;
	TEBOXPTR atermptr;
	TEBOXPTR btermptr;
	int cost;
	int aorient;
	int borient___0;
	int aycenter___0;
	int bycenter___0;
	int truth;

	{
#line 15
		acellptr___0 = *(carray + a___0);
#line 16
		aycenter___0 = acellptr___0->cycenter;
#line 17
		aorient = (int)acellptr___0->corient;
#line 18
		atileptr = acellptr___0->tileptr;
#line 19
		atermptr = atileptr->termsptr;
#line 21
		bcellptr___0 = *(carray + b___0);
#line 22
		bycenter___0 = bcellptr___0->cycenter;
#line 23
		borient___0 = (int)bcellptr___0->corient;
#line 24
		btileptr = bcellptr___0->tileptr;
#line 25
		btermptr = btileptr->termsptr;
#line 27
		term_newpos(atermptr, anxcenter___0, bycenter___0, aorient);
#line 28
		term_newpos(btermptr, bnxcenter___0, aycenter___0, borient___0);
#line 30
		cost = funccost;
#line 32
		new_dbox(atermptr, &cost);
#line 33
		new_dbox(btermptr, &cost);
#line 35
		truth = acceptt(funccost - cost);
#line 37
		if (truth == 1) {
#line 39
			dbox_pos(atermptr);
#line 40
			dbox_pos(btermptr);
#line 42
			acellptr___0->cxcenter = anxcenter___0;
#line 43
			acellptr___0->cycenter = bycenter___0;
#line 44
			bcellptr___0->cxcenter = bnxcenter___0;
#line 45
			bcellptr___0->cycenter = aycenter___0;
#line 47
			funccost = cost;
#line 48
			return (1);
		}
		else {
#line 50
			return (0);
		}
	}
}
#line 1 "uglobe.o"
#pragma merger(0,"./uglobe.i","")
#line 623 "uglobe.c"
int uglobrout(void);
#line 18 "uglobe.c"
int uglobe(void)
{
	NBOXPTR netptr;
	CBOXPTR___0 cellptr1;
	CBOXPTR___0 cellptr2;
	int group1;
	int group2;
	int edge___0;
	int i;
	int pin;
	int net;
	int group;
	int cell1;
	int cell2;
	int top___0;
	int extint;
	int block___0;
	int locX;
	int locY;
	int flag1;
	int flag2;
	int chgloop;
	int found;
	int type1;
	int unequiv;
	int added_an_edge;
	int ue_grp;
	int g1;
	int g2;
	int ei1;
	int ei2;
	int ei;
	int done;
	int edge2;
	int jj;
	int a1;
	int b1;
	int a2;
	int b2;
	int edge1;
	int ya;
	int yb;
	int single_pin1;
	int single_pin2;
	int unequiv1;
	int unequiv2;

	{
#line 32
		i = 0;
#line 32
		while (i <= MPG) {
#line 33
			(groupArray + i)->numPins = 0;
#line 34
			(groupArray + i)->flag = 0;
#line 35
			(groupArray + i)->poison = 0;
#line 36
			(groupArray + i)->unequiv = 0;
#line 37
			(groupArray + i)->extint = 0;
#line 38
			(groupArray + i)->edge1 = 0;
#line 39
			(groupArray + i)->edge2 = 0;
#line 40
			(groupArray + i)->check = 0;
#line 32
			i++;
		}
#line 42
		i = 0;
#line 42
		while (i <= ME) {
#line 43
			(edgeArray + i)->marked = 0;
#line 44
			(edgeArray + i)->done = 0;
#line 45
			(edgeArray + i)->poison = 0;
#line 42
			i++;
		}
#line 48
		chgloop = 1;
#line 48
		while (chgloop <= *(netchgs + 0)) {
#line 49
			net = *(netchgs + chgloop);
#line 50
			numEdges = 0;
#line 51
			top_row = -1;
#line 52
			jj = 0;
#line 52
			while (jj <= numRows + 1) {
#line 53
				* (*(pseudoPins + jj) + 0) = 0;
#line 54
				* (*(pseudoPins + jj) + 1) = 0;
#line 55
				* (*(pseudoEdge + jj) + 0) = 0;
#line 56
				* (*(pseudoEdge + jj) + 1) = 0;
#line 52
				jj++;
			}
#line 58
			netptr = (struct netbox *)(*(netarray + net))->netptr;
#line 59
			while ((unsigned int)netptr != (unsigned int)((void *)0)) {
#line 60
				top___0 = (int)netptr->pinloc;
#line 61
				extint = netptr->extint;
#line 62
				unequiv = (int)netptr->unequiv;
#line 63
				block___0 = netptr->row;
#line 64
				if (block___0 > top_row) {
#line 65
					if (netptr->cell <= numcells) {
#line 66
						top_row = block___0;
					}
					else {
#line 67
						if ((*(carray + netptr->cell))->padside != 1) {
#line 67
							if ((*(carray + netptr->cell))->padside != 3) {
#line 69
								top_row = block___0;
							}
						}
					}
				}
#line 72
				locX = netptr->xpos;
#line 73
				locY = netptr->ypos;
#line 74
				pin = netptr->terminal;
#line 76
				found = 0;
#line 77
				group = 1;
#line 78
				while (1) {
#line 78
					if ((groupArray + group)->numPins != 0) {
#line 78
						if (!(found == 0)) {
#line 78
							break;
						}
					}
					else {
#line 78
						break;
					}
#line 79
					if ((groupArray + group)->extint == extint) {
#line 79
						if (unequiv == 0) {
#line 80
							found = 1;
						}
						else {
#line 82
							group++;
						}
					}
					else {
#line 82
						group++;
					}
				}
#line 85
				numPins = (groupArray + group)->numPins + 1;
#line 86
				(groupArray + group)->numPins = numPins;
#line 87
				((groupArray + group)->pinArray + numPins)->xloc = locX;
#line 88
				((groupArray + group)->pinArray + numPins)->yloc = locY;
#line 89
				((groupArray + group)->pinArray + numPins)->top = top___0;
#line 90
				((groupArray + group)->pinArray + numPins)->pin = pin;
#line 91
				if (found == 0) {
#line 92
					(groupArray + group)->aveX = locX;
#line 93
					(groupArray + group)->aveY = locY;
#line 94
					(groupArray + group)->extint = extint;
#line 95
					(groupArray + group)->unequiv = unequiv;
#line 96
					(groupArray + group)->block = block___0;
				}
				else {
#line 103
					(groupArray + group)->aveX += locX;
#line 104
					(groupArray + group)->aveY += locY;
				}
#line 59
				netptr = (struct netbox *)netptr->nterm;
			}
#line 107
			group = 1;
#line 108
			group = 1;
#line 108
			while ((groupArray + group)->numPins != 0) {
#line 109
				numPins = (groupArray + group)->numPins;
#line 110
				if (numPins > 1) {
#line 111
					(groupArray + group)->aveX /= numPins;
#line 112
					(groupArray + group)->aveY /= numPins;
				}
#line 108
				group++;
			}
#line 119
			numGroups = 0;
#line 120
			while ((groupArray + (numGroups + 1))->numPins != 0) {
#line 121
				numGroups++;
			}
#line 123
			if (numGroups == 2) {
#line 124
				if ((groupArray + 1)->unequiv == 1) {
#line 124
					if ((groupArray + 2)->unequiv == 1) {
#line 125
						i = 1;
#line 125
						while (i <= numGroups) {
#line 126
							(groupArray + i)->numPins = 0;
#line 127
							(groupArray + i)->flag = 0;
#line 128
							(groupArray + i)->poison = 0;
#line 129
							(groupArray + i)->unequiv = 0;
#line 130
							(groupArray + i)->extint = 0;
#line 131
							(groupArray + i)->edge1 = 0;
#line 132
							(groupArray + i)->edge2 = 0;
#line 133
							(groupArray + i)->check = 0;
#line 125
							i++;
						}
#line 135
						i = 1;
#line 135
						while (i <= numEdges) {
#line 136
							(edgeArray + i)->marked = 0;
#line 137
							(edgeArray + i)->done = 0;
#line 138
							(edgeArray + i)->poison = 0;
#line 135
							i++;
						}
						goto __Cont;
					}
				}
			}
			else {
#line 142
				if (numGroups <= 1) {
#line 143
					i = 1;
#line 143
					while (i <= numGroups) {
#line 144
						(groupArray + i)->numPins = 0;
#line 145
						(groupArray + i)->flag = 0;
#line 146
						(groupArray + i)->poison = 0;
#line 147
						(groupArray + i)->unequiv = 0;
#line 148
						(groupArray + i)->extint = 0;
#line 149
						(groupArray + i)->edge1 = 0;
#line 150
						(groupArray + i)->edge2 = 0;
#line 151
						(groupArray + i)->check = 0;
#line 143
						i++;
					}
#line 153
					i = 1;
#line 153
					while (i <= numEdges) {
#line 154
						(edgeArray + i)->marked = 0;
#line 155
						(edgeArray + i)->done = 0;
#line 156
						(edgeArray + i)->poison = 0;
#line 153
						i++;
					}
					goto __Cont;
				}
			}
#line 161
			qsortg((char *)(groupArray + 1), numGroups, sizeof(csGroup));
#line 169
			group = 1;
#line 169
			while (group < numGroups) {
#line 170
				block___0 = (groupArray + group)->block;
#line 171
				type1 = detGroup(group);
#line 172
				searchG(group, type1, block___0);
#line 169
				group++;
			}
#line 180
			edge1 = 1;
#line 180
			while (edge1 <= numEdges) {
#line 181
				a1 = (edgeArray + edge1)->group1;
#line 182
				a2 = (edgeArray + edge1)->group2;
#line 183
				if ((groupArray + a1)->block != (groupArray + a2)->block) {
					goto __Cont___0;
				}
#line 186
				edge2 = edge1 + 1;
#line 186
				while (edge2 <= numEdges) {
#line 187
					b1 = (edgeArray + edge2)->group1;
#line 188
					b2 = (edgeArray + edge2)->group2;
#line 189
					if ((groupArray + b1)->block != (groupArray + b2)->block) {
						goto __Cont___1;
					}
#line 193
					if ((groupArray + a1)->unequiv == 1) {
#line 193
						if ((groupArray + b1)->unequiv == 1) {
#line 193
							if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
#line 193
								if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
									goto _L;
								}
								else {
									goto _L___2;
								}
							}
							else {
								goto _L___2;
							}
						}
						else {
							goto _L___2;
						}
					}
					else {
					_L___2: /* CIL Label */
#line 193
						if ((groupArray + a2)->unequiv == 1) {
#line 193
							if ((groupArray + b2)->unequiv == 1) {
#line 193
								if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
#line 193
									if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
									_L: /* CIL Label */
#line 205
										ya = ((groupArray + a1)->aveY + (groupArray + a2)->aveY) / 2;
#line 206
										yb = ((groupArray + b1)->aveY + (groupArray + b2)->aveY) / 2;
#line 208
										if ((groupArray + a1)->block == top_row) {
#line 209
											if (ya < yb) {
#line 210
												if ((edgeArray + edge2)->cost <= (edgeArray + edge1)->cost) {
#line 212
													(edgeArray + edge2)->cost = (edgeArray + edge1)->cost + 1;
												}
											}
											else {
#line 216
												if ((edgeArray + edge2)->cost >= (edgeArray + edge1)->cost) {
#line 218
													(edgeArray + edge2)->cost = (edgeArray + edge1)->cost - 1;
												}
											}
										}
										else {
#line 223
											if (ya < yb) {
#line 224
												if ((edgeArray + edge2)->cost >= (edgeArray + edge1)->cost) {
#line 226
													(edgeArray + edge2)->cost = (edgeArray + edge1)->cost - 1;
												}
											}
											else {
#line 230
												if ((edgeArray + edge2)->cost <= (edgeArray + edge1)->cost) {
#line 232
													(edgeArray + edge2)->cost = (edgeArray + edge1)->cost + 1;
												}
											}
										}
#line 237
										break;
									}
								}
							}
						}
					}
				__Cont___1: /* CIL Label */
#line 186
					edge2++;
				}
			__Cont___0: /* CIL Label */
#line 180
				edge1++;
			}
#line 241
			qsorte((char *)(edgeArray + 1), numEdges, sizeof(edgeBox));
#line 243
			group = 1;
#line 243
			while (group <= numGroups) {
#line 244
				(groupArray + group)->flag = group;
#line 243
				group++;
			}
#line 246
			edge___0 = 1;
#line 246
			while (edge___0 <= numEdges) {
#line 247
				group1 = (edgeArray + edge___0)->group1;
#line 248
				flag1 = (groupArray + group1)->flag;
#line 249
				group2 = (edgeArray + edge___0)->group2;
#line 250
				flag2 = (groupArray + group2)->flag;
#line 251
				if (flag1 <= 0) {
					goto __Cont___2;
				}
				else {
#line 251
					if (flag2 <= 0) {
						goto __Cont___2;
					}
					else {
#line 251
						if (flag1 == flag2) {
							goto __Cont___2;
						}
					}
				}
#line 254
				added_an_edge = 0;
#line 255
				(edgeArray + edge___0)->marked = 1;
#line 256
				group = 1;
#line 256
				while (group <= numGroups) {
#line 257
					if ((groupArray + group)->flag == flag2) {
#line 258
						(groupArray + group)->flag = flag1;
					}
#line 256
					group++;
				}
#line 262
				cell1 = (*(tearray + ((groupArray + group1)->pinArray + 1)->pin))->cell;
#line 263
				cell2 = (*(tearray + ((groupArray + group2)->pinArray + 1)->pin))->cell;
#line 264
				cellptr1 = (struct cellbox___0 *)*(carray + cell1);
#line 265
				cellptr2 = (struct cellbox___0 *)*(carray + cell2);
#line 266
				if (cell1 > numcells) {
#line 266
					if (cellptr1->padside != 2) {
#line 266
						if (cellptr1->padside != 14) {
#line 266
							if (cellptr1->padside != 15) {
#line 266
								if (cellptr1->padside != 4) {
#line 270
									if (cell2 <= numcells) {
#line 271
										(groupArray + group1)->flag = 0;
									}
								}
							}
						}
					}
				}
#line 274
				if (cell2 > numcells) {
#line 274
					if (cellptr2->padside != 2) {
#line 274
						if (cellptr2->padside != 14) {
#line 274
							if (cellptr2->padside != 15) {
#line 274
								if (cellptr2->padside != 4) {
#line 278
									if (cell1 <= numcells) {
#line 279
										(groupArray + group2)->flag = 0;
									}
								}
							}
						}
					}
				}
#line 283
				if ((groupArray + group1)->unequiv == 1) {
#line 284
					ei1 = (groupArray + group1)->extint;
#line 285
					ue_grp = 1;
#line 285
					while (ue_grp <= numGroups) {
#line 286
						if (ue_grp == group1) {
							goto __Cont___3;
						}
#line 289
						if ((groupArray + ue_grp)->extint == ei1) {
#line 290
							break;
						}
					__Cont___3: /* CIL Label */
#line 285
						ue_grp++;
					}
#line 293
					if ((groupArray + ue_grp)->flag > 0) {
#line 294
						g2 = 0;
#line 294
						g1 = g2;
#line 295
						(groupArray + ue_grp)->flag = -1;
#line 296
						edge2 = edge___0 + 1;
#line 296
						while (edge2 <= numEdges) {
#line 297
							if (g2 == 0) {
#line 298
								if ((edgeArray + edge2)->group1 == ue_grp) {
#line 299
									g2 = (edgeArray + edge2)->group2;
#line 300
									if ((groupArray + g2)->flag < 0) {
#line 301
										g2 = 0;
									}
									goto __Cont___4;
								}
							}
#line 306
							if (g1 == 0) {
#line 307
								if ((edgeArray + edge2)->group2 == ue_grp) {
#line 308
									g1 = (edgeArray + edge2)->group1;
#line 309
									if ((groupArray + g1)->flag < 0) {
#line 310
										g1 = 0;
									}
								}
							}
						__Cont___4: /* CIL Label */
#line 296
							edge2++;
						}
#line 315
						if (g1 != 0) {
#line 315
							if (g2 != 0) {
#line 316
								addEdge(g1, g2);
#line 317
								added_an_edge = 1;
							}
						}
					}
				}
#line 321
				if ((groupArray + group2)->unequiv == 1) {
#line 322
					ei2 = (groupArray + group2)->extint;
#line 323
					ue_grp = 1;
#line 323
					while (ue_grp <= numGroups) {
#line 324
						if (ue_grp == group2) {
							goto __Cont___5;
						}
#line 327
						if ((groupArray + ue_grp)->extint == ei2) {
#line 328
							break;
						}
					__Cont___5: /* CIL Label */
#line 323
						ue_grp++;
					}
#line 331
					if ((groupArray + ue_grp)->flag > 0) {
#line 332
						g2 = 0;
#line 332
						g1 = g2;
#line 333
						(groupArray + ue_grp)->flag = -1;
#line 334
						edge2 = edge___0 + 1;
#line 334
						while (edge2 <= numEdges) {
#line 335
							if (g2 == 0) {
#line 336
								if ((edgeArray + edge2)->group1 == ue_grp) {
#line 337
									g2 = (edgeArray + edge2)->group2;
#line 338
									if ((groupArray + g2)->flag < 0) {
#line 339
										g2 = 0;
									}
									goto __Cont___6;
								}
							}
#line 344
							if (g1 == 0) {
#line 345
								if ((edgeArray + edge2)->group2 == ue_grp) {
#line 346
									g1 = (edgeArray + edge2)->group1;
#line 347
									if ((groupArray + g1)->flag < 0) {
#line 348
										g1 = 0;
									}
								}
							}
						__Cont___6: /* CIL Label */
#line 334
							edge2++;
						}
#line 353
						if (g1 != 0) {
#line 353
							if (g2 != 0) {
#line 354
								addEdge(g1, g2);
#line 355
								added_an_edge = 1;
							}
						}
					}
				}
#line 359
				if (added_an_edge == 1) {
#line 360
					edge1 = edge___0 + 1;
#line 360
					while (edge1 <= numEdges) {
#line 361
						a1 = (edgeArray + edge1)->group1;
#line 362
						a2 = (edgeArray + edge1)->group2;
#line 363
						if ((groupArray + a1)->block != (groupArray + a2)->block) {
							goto __Cont___7;
						}
#line 366
						edge2 = edge1 + 1;
#line 366
						while (edge2 <= numEdges) {
#line 367
							b1 = (edgeArray + edge2)->group1;
#line 368
							b2 = (edgeArray + edge2)->group2;
#line 369
							if ((groupArray + b1)->block != (groupArray + b2)->block) {
								goto __Cont___8;
							}
#line 374
							if ((groupArray + a1)->unequiv == 1) {
#line 374
								if ((groupArray + b1)->unequiv == 1) {
#line 374
									if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
#line 374
										if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
											goto _L___3;
										}
										else {
											goto _L___6;
										}
									}
									else {
										goto _L___6;
									}
								}
								else {
									goto _L___6;
								}
							}
							else {
							_L___6: /* CIL Label */
#line 374
								if ((groupArray + a2)->unequiv == 1) {
#line 374
									if ((groupArray + b2)->unequiv == 1) {
#line 374
										if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
#line 374
											if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
											_L___3: /* CIL Label */
#line 389
												ya = ((groupArray + a1)->aveY + (groupArray + a2)->aveY) / 2;
#line 391
												yb = ((groupArray + b1)->aveY + (groupArray + b2)->aveY) / 2;
#line 394
												if ((groupArray + a1)->block == top_row) {
#line 395
													if (ya < yb) {
#line 396
														if ((edgeArray + edge2)->cost <= (edgeArray + edge1)->cost) {
#line 398
															(edgeArray + edge2)->cost = (edgeArray + edge1)->cost + 1;
														}
													}
													else {
#line 402
														if ((edgeArray + edge2)->cost >= (edgeArray + edge1)->cost) {
#line 404
															(edgeArray + edge2)->cost = (edgeArray + edge1)->cost - 1;
														}
													}
												}
												else {
#line 409
													if (ya < yb) {
#line 410
														if ((edgeArray + edge2)->cost >= (edgeArray + edge1)->cost) {
#line 412
															(edgeArray + edge2)->cost = (edgeArray + edge1)->cost - 1;
														}
													}
													else {
#line 416
														if ((edgeArray + edge2)->cost <= (edgeArray + edge1)->cost) {
#line 418
															(edgeArray + edge2)->cost = (edgeArray + edge1)->cost + 1;
														}
													}
												}
#line 423
												break;
											}
										}
									}
								}
							}
						__Cont___8: /* CIL Label */
#line 366
							edge2++;
						}
					__Cont___7: /* CIL Label */
#line 360
						edge1++;
					}
#line 427
					qsorte((char *)((edgeArray + 1) + edge___0), numEdges - edge___0, sizeof(edgeBox));
				}
			__Cont___2: /* CIL Label */
#line 246
				edge___0++;
			}
#line 435
			group = 1;
#line 435
			while (group <= numGroups) {
#line 436
				if ((groupArray + group)->flag < 0) {
					goto __Cont___9;
				}
#line 439
				if ((groupArray + group)->unequiv != 1) {
					goto __Cont___9;
				}
#line 442
				ei = (groupArray + group)->extint;
#line 443
				group2 = group + 1;
#line 443
				while (group2 <= numGroups) {
#line 444
					if ((groupArray + group2)->extint == ei) {
#line 445
						if ((groupArray + group2)->flag >= 0) {
#line 446
							(groupArray + group2)->flag = -1;
						}
#line 448
						break;
					}
#line 443
					group2++;
				}
			__Cont___9: /* CIL Label */
#line 435
				group++;
			}
#line 461
			done = 0;
#line 462
			while (done == 0) {
#line 463
				done = 1;
#line 464
				edge___0 = 1;
#line 464
				while (edge___0 <= numEdges) {
#line 465
					if ((edgeArray + edge___0)->marked == 1) {
#line 465
						if ((edgeArray + edge___0)->poison == 0) {
#line 466
							g1 = (edgeArray + edge___0)->group1;
#line 467
							g2 = (edgeArray + edge___0)->group2;
#line 468
							unequiv1 = (groupArray + g1)->unequiv;
#line 469
							if (unequiv1 == 0) {
#line 470
								if ((groupArray + g1)->numPins == 1) {
#line 470
									if (((groupArray + g1)->pinArray + 1)->top != 0) {
#line 472
										single_pin1 = 1;
#line 473
										unequiv1 = 1;
									}
								}
							}
#line 476
							unequiv2 = (groupArray + g2)->unequiv;
#line 477
							if (unequiv2 == 0) {
#line 478
								if ((groupArray + g2)->numPins == 1) {
#line 478
									if (((groupArray + g2)->pinArray + 1)->top != 0) {
#line 480
										single_pin2 = 1;
#line 481
										unequiv2 = 1;
									}
								}
							}
#line 485
							if ((groupArray + g1)->poison == 1) {
								goto _L___8;
							}
							else {
#line 485
								if ((groupArray + g2)->poison == 1) {
								_L___8: /* CIL Label */
#line 487
									done = 0;
#line 488
									(edgeArray + edge___0)->poison = 1;
#line 489
									if (unequiv1 == 1) {
#line 490
										(groupArray + g1)->poison = 1;
									}
#line 492
									if (unequiv2 == 1) {
#line 493
										(groupArray + g2)->poison = 1;
									}
								}
								else {
#line 495
									if ((groupArray + g1)->block != (groupArray + g2)->block) {
#line 496
										done = 0;
#line 497
										(edgeArray + edge___0)->poison = 1;
#line 498
										if (unequiv1 == 1) {
#line 499
											(groupArray + g1)->poison = 1;
										}
#line 501
										if (unequiv2 == 1) {
#line 502
											(groupArray + g2)->poison = 1;
										}
									}
									else {
#line 504
										if (single_pin1 == 1) {
											goto _L___7;
										}
										else {
#line 504
											if (single_pin2 == 1) {
											_L___7: /* CIL Label */
#line 505
												done = 0;
#line 506
												(edgeArray + edge___0)->poison = 1;
#line 507
												if (unequiv1 == 1) {
#line 508
													(groupArray + g1)->poison = 1;
												}
#line 510
												if (unequiv2 == 1) {
#line 511
													(groupArray + g2)->poison = 1;
												}
											}
										}
									}
								}
							}
						}
					}
#line 464
					edge___0++;
				}
			}
#line 517
			edge___0 = 1;
#line 517
			while (edge___0 <= numEdges) {
#line 518
				if ((edgeArray + edge___0)->marked == 1) {
#line 518
					if ((edgeArray + edge___0)->poison == 0) {
#line 520
						g1 = (edgeArray + edge___0)->group1;
#line 521
						g2 = (edgeArray + edge___0)->group2;
#line 522
						if ((groupArray + g1)->unequiv == 0) {
#line 522
							if ((groupArray + g2)->unequiv == 0) {
#line 524
								(edgeArray + edge___0)->poison = 1;
							}
						}
#line 526
						if ((groupArray + g1)->unequiv == 0) {
#line 527
							(groupArray + g1)->poison = 1;
						}
#line 529
						if ((groupArray + g2)->unequiv == 0) {
#line 530
							(groupArray + g2)->poison = 1;
						}
					}
				}
#line 517
				edge___0++;
			}
#line 537
			edge___0 = 1;
#line 537
			while (edge___0 <= numEdges) {
#line 538
				if ((edgeArray + edge___0)->marked == 1) {
#line 538
					if ((edgeArray + edge___0)->poison == 0) {
#line 540
						g1 = (edgeArray + edge___0)->group1;
#line 541
						g2 = (edgeArray + edge___0)->group2;
#line 542
						if ((groupArray + g1)->edge1 == 0) {
#line 543
							(groupArray + g1)->edge1 = edge___0;
						}
						else {
#line 545
							(groupArray + g1)->edge2 = edge___0;
						}
#line 547
						if ((groupArray + g2)->edge1 == 0) {
#line 548
							(groupArray + g2)->edge1 = edge___0;
						}
						else {
#line 550
							(groupArray + g2)->edge2 = edge___0;
						}
#line 552
						if ((groupArray + g1)->poison == 0) {
#line 553
							ei = (groupArray + g1)->extint;
#line 554
							group = 1;
#line 554
							while (1) {
#line 555
								if (group == g1) {
									goto __Cont___10;
								}
								else {
#line 555
									if ((groupArray + group)->extint != ei) {
										goto __Cont___10;
									}
								}
#line 558
								break;
							__Cont___10: /* CIL Label */
#line 554
								group++;
							}
#line 560
							(groupArray + g1)->numPins = 2;
#line 561
							((groupArray + g1)->pinArray + 2)->xloc = ((groupArray + group)->pinArray + 1)->xloc;
#line 562
							((groupArray + g1)->pinArray + 2)->yloc = ((groupArray + group)->pinArray + 1)->yloc;
#line 563
							((groupArray + g1)->pinArray + 2)->top = ((groupArray + group)->pinArray + 1)->top;
#line 564
							((groupArray + g1)->pinArray + 2)->pin = ((groupArray + group)->pinArray + 1)->pin;
						}
#line 567
						if ((groupArray + g2)->poison == 0) {
#line 568
							ei = (groupArray + g2)->extint;
#line 569
							group = 1;
#line 569
							while (1) {
#line 570
								if (group == g2) {
									goto __Cont___11;
								}
								else {
#line 570
									if ((groupArray + group)->extint != ei) {
										goto __Cont___11;
									}
								}
#line 573
								break;
							__Cont___11: /* CIL Label */
#line 569
								group++;
							}
#line 575
							(groupArray + g2)->numPins = 2;
#line 576
							((groupArray + g2)->pinArray + 2)->xloc = ((groupArray + group)->pinArray + 1)->xloc;
#line 577
							((groupArray + g2)->pinArray + 2)->yloc = ((groupArray + group)->pinArray + 1)->yloc;
#line 578
							((groupArray + g2)->pinArray + 2)->top = ((groupArray + group)->pinArray + 1)->top;
#line 579
							((groupArray + g2)->pinArray + 2)->pin = ((groupArray + group)->pinArray + 1)->pin;
						}
					}
				}
#line 537
				edge___0++;
			}
#line 583
			edge___0 = 1;
#line 583
			while (edge___0 <= numEdges) {
#line 584
				if ((edgeArray + edge___0)->marked == 1) {
#line 584
					if ((edgeArray + edge___0)->poison == 0) {
#line 586
						g1 = (edgeArray + edge___0)->group1;
#line 587
						g2 = (edgeArray + edge___0)->group2;
#line 588
						if ((groupArray + g1)->edge2 == 0) {
#line 588
							if ((groupArray + g2)->edge2 == 0) {
#line 589
								(edgeArray + edge___0)->poison = 1;
							}
						}
					}
				}
#line 583
				edge___0++;
			}
#line 602
			uclosepns(net);
#line 607
			i = 1;
#line 607
			while (i <= numGroups) {
#line 608
				(groupArray + i)->numPins = 0;
#line 609
				(groupArray + i)->flag = 0;
#line 610
				(groupArray + i)->poison = 0;
#line 611
				(groupArray + i)->unequiv = 0;
#line 612
				(groupArray + i)->extint = 0;
#line 613
				(groupArray + i)->edge1 = 0;
#line 614
				(groupArray + i)->edge2 = 0;
#line 615
				(groupArray + i)->check = 0;
#line 607
				i++;
			}
#line 617
			i = 1;
#line 617
			while (i <= numEdges) {
#line 618
				(edgeArray + i)->marked = 0;
#line 619
				(edgeArray + i)->done = 0;
#line 620
				(edgeArray + i)->poison = 0;
#line 617
				i++;
			}
		__Cont: /* CIL Label */
#line 48
			chgloop++;
		}
#line 623
		uglobrout();
#line 625
		return;
	}
}
#line 1 "uglobrout.o"
#pragma merger(0,"./uglobrout.i","")
#line 22 "uglobrout.c"
void unetseg(void);
#line 8 "uglobrout.c"
int uglobrout(void)
{
	int attperseg;
	int attlimit___0;
	int attempts___0;
	int swSeg;
	int stoppoint;
	int breakpoint;
	int found;
	int channel;
	int x;
	int x1;
	int x2;
	SEGBOXPTR segptr;
	DENSITYPTR denptr;
	int tmp;
	int tmp___0;

	{
#line 20
		attperseg = 5;
#line 22
		unetseg();
#line 24
		attlimit___0 = attperseg * numSwSegs;
#line 26
		attempts___0 = 0;
#line 27
		breakpoint = 0;
#line 28
		stoppoint = (int)(1.5 * (double)numSwSegs);
#line 30
		while (attempts___0 < attlimit___0) {
#line 31
			while (1) {
#line 32
				while (1) {
#line 33
					tmp = Yacm_random();
#line 33
					swSeg = (int)((float)numSegs * ((float)tmp / (float)2147483647)) + 1;
#line 32
					if (!(swSeg == numSegs + 1)) {
#line 32
						break;
					}
				}
#line 36
				if ((int)(aNetSeg + swSeg)->nflag == 1) {
#line 37
					if ((int)(aNetSeg + swSeg)->nswYorN == 1) {
#line 37
						if ((aNetSeg + swSeg)->nkey == 0) {
#line 39
							break;
						}
					}
				}
				else {
#line 42
					if ((int)(aNetSeg + swSeg)->swYorN == 1) {
#line 42
						if ((aNetSeg + swSeg)->key == 0) {
#line 44
							break;
						}
					}
				}
			}
#line 49
			if ((int)(aNetSeg + swSeg)->nflag == 0) {
#line 50
				if ((int)(aNetSeg + swSeg)->current == 0) {
#line 51
					segptr = (aNetSeg + swSeg)->top;
				}
				else {
#line 53
					segptr = (aNetSeg + swSeg)->bot;
				}
			}
			else {
#line 56
				if ((int)(aNetSeg + swSeg)->ncurrent == 0) {
#line 57
					segptr = (aNetSeg + swSeg)->ntop;
				}
				else {
#line 59
					segptr = (aNetSeg + swSeg)->nbot;
				}
			}
#line 62
			channel = segptr->channel;
#line 63
			x1 = ((segptr->pin1ptr)->netptr)->xpos;
#line 64
			x2 = ((segptr->pin2ptr)->netptr)->xpos;
#line 65
			if (channel > gtopChan) {
#line 67
				attempts___0++;
#line 68
				continue;
			}
			else {
#line 65
				if (channel < gbotChan) {
#line 67
					attempts___0++;
#line 68
					continue;
				}
				else {
#line 65
					if (x2 < Left_bound) {
#line 67
						attempts___0++;
#line 68
						continue;
					}
					else {
#line 65
						if (x1 > Rite_bound) {
#line 67
							attempts___0++;
#line 68
							continue;
						}
					}
				}
			}
#line 71
			found = 0;
#line 73
			denptr = (*(*(DboxHead + channel) + *(nmaxTrack + channel)))->nnext;
#line 73
			while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 75
				x = ((denptr->grdptr)->netptr)->xpos;
#line 76
				if (x1 <= x) {
#line 76
					if (x2 >= x) {
#line 77
						found = 1;
#line 78
						break;
					}
				}
#line 73
				denptr = denptr->nnext;
			}
#line 81
			if (!found) {
#line 82
				breakpoint++;
#line 82
				if (breakpoint > stoppoint) {
#line 83
					break;
				}
#line 85
				attempts___0++;
#line 86
				continue;
			}
#line 89
			tmp___0 = purcost(swSeg);
#line 89
			if (tmp___0) {
#line 90
				attempts___0++;
#line 91
				breakpoint = 0;
			}
			else {
#line 93
				breakpoint++;
#line 93
				if (breakpoint > stoppoint) {
#line 94
					break;
				}
#line 96
				attempts___0++;
			}
		}
#line 99
		return;
	}
}
#line 1 "ugpair.o"
#pragma merger(0,"./ugpair.i","")
#line 9 "ugpair.c"
void ugpair(void)
{
	CBOXPTR___0 acellptr___0;
	CBOXPTR___0 bcellptr___0;
	BBOXPTR___0 ablckptr;
	DENSITYPTR denptr;
	int a___0;
	int b___0;
	int ablock___0;
	int lowValue;
	int flips;
	int attempts___0;
	int segment;
	int axcenter___0;
	int bnxcenter___0;
	int anxcenter___0;
	int aleft___0;
	int aright___0;
	int aorient;
	int startx1;
	int endx1;
	int cellleft;
	int cellrite;
	int x;
	int leftEdge;
	int riteEdge;
	int aptr;
	int chan1;
	int chan2;
	int found;
	int breakpoint;
	int stoppoint;
	float r;
	char *tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	int tmp___7;
	int tmp___8;
	int tmp___9;
	int tmp___10;
	int tmp___11;
	int tmp___12;

	{
#line 27
		lowValue = tracks;
#line 28
		tmp = safe_malloc(251U * sizeof(CHANGRDPTR));
#line 28
		Shuffle = (struct changrdbox **)((CHANGRDPTR *)tmp);
#line 29
		segment = 1;
#line 29
		while (segment <= numSegs) {
#line 30
			* (fixnetseg + segment) = (int)(aNetSeg + segment)->current;
#line 29
			segment++;
		}
#line 33
		flips = 0;
#line 34
		attempts___0 = 0;
#line 35
		breakpoint = 0;
#line 36
		stoppoint = (int)((float)moveable_cells * stopdeg);
#line 37
		while (breakpoint < stoppoint) {
#line 38
			while (1) {
#line 39
				tmp___0 = Yacm_random();
#line 39
				ablock___0 = (int)((float)numblock * ((float)tmp___0 / (float)2147483647)) + 1;
#line 38
				if (!(ablock___0 == numblock + 1)) {
#line 38
					break;
				}
			}
#line 42
			if (*(*(pairArray + ablock___0) + 0) <= 1) {
#line 43
				continue;
			}
#line 45
			chan1 = *(blkToRow + ablock___0) + 1;
#line 46
			chan2 = *(blkToRow + ablock___0);
#line 48
			found = 0;
#line 48
			while (found == 0) {
#line 49
				while (1) {
#line 50
					tmp___1 = Yacm_random();
#line 50
					aptr = (int)((float)*(*(pairArray + ablock___0) + 0) * ((float)tmp___1 / (float)2147483647)) + 1;
#line 49
					if (!(aptr == *(*(pairArray + ablock___0) + 0) + 1)) {
#line 49
						break;
					}
				}
#line 54
				a___0 = *(*(pairArray + ablock___0) + aptr);
#line 55
				acellptr___0 = (struct cellbox___0 *)*(carray + a___0);
#line 56
				aorient = (int)acellptr___0->corient;
#line 58
				axcenter___0 = acellptr___0->cxcenter;
#line 60
				aleft___0 = (acellptr___0->tileptr)->left;
#line 61
				aright___0 = (acellptr___0->tileptr)->right;
#line 62
				startx1 = axcenter___0 + aleft___0;
#line 63
				endx1 = axcenter___0 + aright___0;
#line 65
				denptr = (*(*(DboxHead + chan1) + *(maxTrack + chan1)))->next;
#line 65
				while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 67
					x = ((denptr->grdptr)->netptr)->newx;
#line 68
					if (startx1 <= x) {
#line 68
						if (endx1 >= x) {
#line 69
							found = 1;
#line 70
							break;
						}
					}
#line 65
					denptr = denptr->next;
				}
#line 73
				if (found == 0) {
#line 74
					denptr = (*(*(DboxHead + chan2) + *(maxTrack + chan2)))->next;
#line 74
					while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 76
						x = ((denptr->grdptr)->netptr)->newx;
#line 77
						if (startx1 <= x) {
#line 77
							if (endx1 >= x) {
#line 78
								found = 1;
#line 79
								break;
							}
						}
#line 74
						denptr = denptr->next;
					}
				}
			}
#line 84
			ablckptr = (struct blockbox___0 *)*(barray + ablock___0);
#line 86
			if (aptr > 1) {
#line 87
				cellleft = *(*(pairArray + ablock___0) + (aptr - 1));
			}
			else {
#line 89
				cellleft = 0;
			}
#line 91
			if (aptr < *(*(pairArray + ablock___0) + 0)) {
#line 92
				cellrite = *(*(pairArray + ablock___0) + (aptr + 1));
			}
			else {
#line 94
				cellrite = 0;
			}
#line 97
			if (cellleft != 0) {
#line 97
				if (cellrite != 0) {
#line 97
					if ((*(carray + cellleft))->cclass != -1) {
#line 97
						if (acellptr___0->cclass != -1) {
#line 97
							if ((*(carray + cellrite))->cclass != -1) {
#line 101
								tmp___2 = Yacm_random();
#line 101
								r = (float)tmp___2 / (float)2147483647;
#line 102
								if ((double)r >= 0.5) {
#line 106
									b___0 = cellleft;
#line 107
									bcellptr___0 = (struct cellbox___0 *)*(carray + b___0);
#line 108
									leftEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->left;
#line 109
									anxcenter___0 = leftEdge - aleft___0;
#line 110
									bnxcenter___0 = endx1 - (bcellptr___0->tileptr)->right;
#line 111
									tmp___4 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 111
									if (tmp___4) {
#line 112
										flips++;
#line 113
										attempts___0++;
#line 114
										if (attempts___0 % 50 == 0) {
#line 115
											fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 117
											fflush(fpo);
										}
#line 119
										if (attempts___0 % 150 == 0) {
#line 120
											savewolf(3);
										}
#line 122
										if (tracks < lowValue) {
#line 123
											lowValue = tracks;
#line 124
											fprintf(fpo, "Routing tracks reduced ");
#line 125
											fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0);
#line 127
											fflush(fpo);
										}
										else {
#line 129
											breakpoint++;
										}
#line 131
										if (!uneven_cell_height) {
#line 132
											* (*(pairArray + ablock___0) + aptr) = b___0;
#line 133
											* (*(pairArray + ablock___0) + (aptr - 1)) = a___0;
										}
									}
									else {
#line 136
										breakpoint++;
#line 137
										attempts___0++;
#line 138
										if (attempts___0 % 50 == 0) {
#line 139
											fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 141
											fflush(fpo);
										}
#line 143
										if (attempts___0 % 150 == 0) {
#line 144
											savewolf(3);
										}
#line 146
										b___0 = cellrite;
#line 147
										bcellptr___0 = (struct cellbox___0 *)*(carray + b___0);
#line 148
										riteEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->right;
#line 150
										anxcenter___0 = riteEdge - aright___0;
#line 151
										bnxcenter___0 = startx1 - (bcellptr___0->tileptr)->left;
#line 152
										tmp___3 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 152
										if (tmp___3) {
#line 153
											flips++;
#line 154
											if (tracks < lowValue) {
#line 155
												lowValue = tracks;
#line 156
												fprintf(fpo, "Routing tracks reduced ");
#line 157
												fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0 + 1);
#line 159
												fflush(fpo);
											}
											else {
#line 161
												breakpoint++;
											}
#line 163
											if (!uneven_cell_height) {
#line 164
												* (*(pairArray + ablock___0) + aptr) = b___0;
#line 165
												* (*(pairArray + ablock___0) + (aptr + 1)) = a___0;
											}
										}
										else {
#line 168
											breakpoint++;
										}
#line 170
										attempts___0++;
#line 171
										if (attempts___0 % 50 == 0) {
#line 172
											fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 174
											fflush(fpo);
										}
#line 176
										if (attempts___0 % 150 == 0) {
#line 177
											savewolf(3);
										}
									}
								}
								else {
#line 181
									b___0 = cellrite;
#line 182
									bcellptr___0 = (struct cellbox___0 *)*(carray + b___0);
#line 183
									riteEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->right;
#line 184
									anxcenter___0 = riteEdge - aright___0;
#line 185
									bnxcenter___0 = startx1 - (bcellptr___0->tileptr)->left;
#line 186
									tmp___6 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 186
									if (tmp___6) {
#line 187
										flips++;
#line 188
										attempts___0++;
#line 189
										if (attempts___0 % 50 == 0) {
#line 190
											fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 192
											fflush(fpo);
										}
#line 194
										if (attempts___0 % 150 == 0) {
#line 195
											savewolf(3);
										}
#line 197
										if (tracks < lowValue) {
#line 198
											lowValue = tracks;
#line 199
											fprintf(fpo, "Routing tracks reduced ");
#line 200
											fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0);
#line 202
											fflush(fpo);
										}
										else {
#line 204
											breakpoint++;
										}
#line 206
										if (!uneven_cell_height) {
#line 207
											* (*(pairArray + ablock___0) + aptr) = b___0;
#line 208
											* (*(pairArray + ablock___0) + (aptr + 1)) = a___0;
										}
									}
									else {
#line 211
										attempts___0++;
#line 212
										if (attempts___0 % 50 == 0) {
#line 213
											fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 215
											fflush(fpo);
										}
#line 217
										if (attempts___0 % 150 == 0) {
#line 218
											savewolf(3);
										}
#line 220
										breakpoint++;
#line 221
										b___0 = cellleft;
#line 222
										bcellptr___0 = (struct cellbox___0 *)*(carray + b___0);
#line 223
										leftEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->left;
#line 224
										anxcenter___0 = leftEdge - aleft___0;
#line 225
										bnxcenter___0 = endx1 - (bcellptr___0->tileptr)->right;
#line 226
										tmp___5 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 226
										if (tmp___5) {
#line 227
											flips++;
#line 228
											if (tracks < lowValue) {
#line 229
												lowValue = tracks;
#line 230
												fprintf(fpo, "Routing tracks reduced ");
#line 231
												fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0 + 1);
#line 233
												fflush(fpo);
											}
											else {
#line 235
												breakpoint++;
											}
#line 237
											if (!uneven_cell_height) {
#line 238
												* (*(pairArray + ablock___0) + aptr) = b___0;
#line 239
												* (*(pairArray + ablock___0) + (aptr - 1)) = a___0;
											}
										}
										else {
#line 242
											breakpoint++;
										}
#line 244
										attempts___0++;
#line 245
										if (attempts___0 % 50 == 0) {
#line 246
											fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 248
											fflush(fpo);
										}
#line 250
										if (attempts___0 % 150 == 0) {
#line 251
											savewolf(3);
										}
									}
								}
							}
							else {
								goto _L___4;
							}
						}
						else {
							goto _L___4;
						}
					}
					else {
						goto _L___4;
					}
				}
				else {
					goto _L___4;
				}
			}
			else {
			_L___4: /* CIL Label */
#line 256
				if (cellleft != 0) {
#line 256
					if ((*(carray + cellleft))->cclass != -1) {
#line 256
						if (acellptr___0->cclass != -1) {
#line 259
							b___0 = cellleft;
#line 260
							bcellptr___0 = (struct cellbox___0 *)*(carray + b___0);
#line 261
							leftEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->left;
#line 262
							anxcenter___0 = leftEdge - aleft___0;
#line 263
							bnxcenter___0 = endx1 - (bcellptr___0->tileptr)->right;
#line 264
							tmp___7 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 264
							if (tmp___7) {
#line 265
								flips++;
#line 266
								if (tracks < lowValue) {
#line 267
									lowValue = tracks;
#line 268
									fprintf(fpo, "Routing tracks reduced ");
#line 269
									fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0 + 1);
#line 271
									fflush(fpo);
								}
								else {
#line 273
									breakpoint++;
								}
#line 275
								if (!uneven_cell_height) {
#line 276
									* (*(pairArray + ablock___0) + aptr) = b___0;
#line 277
									* (*(pairArray + ablock___0) + (aptr - 1)) = a___0;
								}
							}
							else {
#line 280
								breakpoint++;
							}
#line 282
							attempts___0++;
#line 283
							if (attempts___0 % 50 == 0) {
#line 284
								fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 286
								fflush(fpo);
							}
#line 288
							if (attempts___0 % 150 == 0) {
#line 289
								savewolf(3);
							}
						}
						else {
							goto _L___0;
						}
					}
					else {
						goto _L___0;
					}
				}
				else {
				_L___0: /* CIL Label */
#line 291
					if (cellrite != 0) {
#line 291
						if ((*(carray + cellrite))->cclass != -1) {
#line 291
							if (acellptr___0->cclass != -1) {
#line 294
								b___0 = cellrite;
#line 295
								bcellptr___0 = (struct cellbox___0 *)*(carray + b___0);
#line 296
								riteEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->right;
#line 297
								anxcenter___0 = riteEdge - aright___0;
#line 298
								bnxcenter___0 = startx1 - (bcellptr___0->tileptr)->left;
#line 299
								tmp___8 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 299
								if (tmp___8) {
#line 300
									flips++;
#line 301
									if (tracks < lowValue) {
#line 302
										lowValue = tracks;
#line 303
										fprintf(fpo, "Routing tracks reduced ");
#line 304
										fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0 + 1);
#line 306
										fflush(fpo);
									}
									else {
#line 308
										breakpoint++;
									}
#line 310
									if (!uneven_cell_height) {
#line 311
										* (*(pairArray + ablock___0) + aptr) = b___0;
#line 312
										* (*(pairArray + ablock___0) + (aptr + 1)) = a___0;
									}
								}
								else {
#line 315
									breakpoint++;
								}
#line 317
								attempts___0++;
#line 318
								if (attempts___0 % 50 == 0) {
#line 319
									fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 321
									fflush(fpo);
								}
#line 323
								if (attempts___0 % 150 == 0) {
#line 324
									savewolf(3);
								}
							}
						}
					}
				}
			}
#line 328
			switch (ablckptr->borient) {
			case 1:
#line 330
				if ((int)acellptr___0->orflag != 0) {
#line 331
					if (aorient == 0) {
#line 331
						tmp___9 = 2;
					}
					else {
#line 331
						tmp___9 = 0;
					}
#line 331
					tmp___10 = ucg0(a___0, tmp___9);
#line 331
					if (tmp___10) {
#line 332
						if (tracks < lowValue) {
#line 333
							lowValue = tracks;
#line 334
							fprintf(fpo, "Routing tracks reduced ");
#line 335
							fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0);
#line 337
							fprintf(fpo, "  ----by an orientation change\n");
#line 338
							fflush(fpo);
						}
					}
				}
#line 342
				break;
			case 2:
#line 344
				if ((int)acellptr___0->orflag != 0) {
#line 345
					if (aorient == 1) {
#line 345
						tmp___11 = 3;
					}
					else {
#line 345
						tmp___11 = 1;
					}
#line 345
					tmp___12 = ucg0(a___0, tmp___11);
#line 345
					if (tmp___12) {
#line 346
						if (tracks < lowValue) {
#line 347
							lowValue = tracks;
#line 348
							fprintf(fpo, "Routing tracks reduced ");
#line 349
							fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0);
#line 351
							fprintf(fpo, "  ----by an orientation change\n");
#line 352
							fflush(fpo);
						}
					}
				}
#line 356
				break;
			}
		}
#line 359
		if (attempts___0 != 0) {
#line 360
			fprintf(fpo, "    no. of accepted gflips: %d --->%d%s\n", flips, (int)((100.0 * (double)((float)flips)) / (double)((float)attempts___0)),
				"%");
#line 363
			fflush(fpo);
		}
#line 365
		safe_free(Shuffle);
#line 366
		return;
	}
}
#line 1 "uloop.o"
#pragma merger(0,"./uloop.i","")
#line 12 "uloop.c"
float partition(int C_initial, int k_initial, int p_initial, int R_initial);
#line 13
float compute_and_combination(int C, int k___0, int p, int R);
#line 14
float combination(int numerator, int denominator);
#line 15
float expected_value(int C_initial, int k_initial, int p_initial, int R_initial);
#line 16
float expected_svalue(int C_initial, int k_initial, int p_initial, int R_initial);
#line 17 "uloop.c"
float finalRowControl;
#line 18 "uloop.c"
float initialRowControl;
#line 37 "uloop.c"
int newpenal;
#line 38 "uloop.c"
int Apost;
#line 38 "uloop.c"
int Bpost;
#line 39 "uloop.c"
int *cellaptr;
#line 39 "uloop.c"
int *cellbptr;
#line 40 "uloop.c"
int earlyRej;
#line 40 "uloop.c"
int Rej_error;
#line 42 "uloop.c"
int wire_chg;
#line 42 "uloop.c"
int binpen_chg;
#line 42 "uloop.c"
int rowpen_chg;
#line 43 "uloop.c"
int a;
#line 43 "uloop.c"
int b;
#line 43 "uloop.c"
int ablock;
#line 43 "uloop.c"
int bblock;
#line 44 "uloop.c"
int attempts;
#line 52 "uloop.c"
int PICK_INT(int l, int u)
{
	int temp;
	int tmp;
	int tmp___0;

	{
#line 54
		if (l < u) {
#line 54
			tmp = Yacm_random();
#line 54
			tmp___0 = tmp % ((u - l) + 1) + l;
		}
		else {
#line 54
			tmp___0 = l;
		}
#line 54
		temp = tmp___0;
#line 55
		if (syf == 81) {
#line 55
			if (attempts == 198) {
#line 57
				printf("temp=%d\n", temp);
			}
		}
#line 59
		return (temp);
	}
}
#line 80 "uloop.c"
static float avg_VW;
#line 221
int XPICK_INT(int l, int u, int c);
#line 488
int rowcon(void);
#line 61 "uloop.c"
void uloop(void)
{
	CBOXPTR acellptr___0;
	CBOXPTR bcellptr___0;
	BBOXPTR ablckptr;
	BBOXPTR bblckptr;
	DBOXPTR dimptr;
	int botblk;
	int topblk;
	int flips;
	int rejects;
	int axcenter___0;
	int bxcenter___0;
	int bycenter___0;
	int aorient;
	int borient___0;
	int bleft___0;
	int bright___0;
	int blk___0;
	int pairflips;
	int i;
	int r;
	int l;
	int t;
	int abin;
	int bbin;
	int firstTry;
	int fds;
	int net;
	int cost;
	float target_row_penalty;
	float target_bin_penalty;
	float temp;
	float accept_deviation;
	float fp_ratio;
	float percent_error;
	float factor;
	float total_feed_length;
	float target_feed_length;
	double tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	int tmp___7;
	int tmp___8;
	int tmp___9;
	int tmp___10;
	int tmp___11;
	int tmp___12;
	int tmp___13;
	int tmp___14;
	int tmp___15;
	int tmp___16;
	int tmp___17;
	int tmp___18;
	int tmp___19;
	int tmp___20;
	int tmp___21;
	int tmp___22;

	{
#line 82
		attempts = 0;
#line 83
		flips = 0;
#line 84
		rejects = 0;
#line 85
		pairflips = 0;
#line 86
		earlyRej = 0;
#line 87
		Rej_error = 0;
#line 89
		potential_errors = 0;
#line 90
		error_count = 0;
#line 91
		if (iteration == 0) {
#line 92
			P_limit = (int)(10.0 * (double)mean_width);
		}
		else {
#line 91
			if (resume_run == 1) {
#line 92
				P_limit = (int)(10.0 * (double)mean_width);
			}
			else {
#line 94
				if (wire_chgs > 0) {
#line 95
					mean_wire_chg = total_wire_chg / (float)wire_chgs;
#line 96
					if (iteration > 1) {
#line 97
						tmp = sqrt((double)(sigma_wire_chg / (float)wire_chgs));
#line 97
						sigma_wire_chg = (float)tmp;
					}
					else {
#line 99
						sigma_wire_chg = (float)(3.0 * (double)mean_wire_chg);
					}
				}
				else {
#line 102
					mean_wire_chg = (float)0.0;
#line 103
					sigma_wire_chg = (float)0.0;
				}
#line 106
				P_limit = (int)(((double)mean_wire_chg + 1.3 * (double)sigma_wire_chg) + (double)(T / cost_scale_factor));
			}
		}
#line 119
		sigma_wire_chg = (float)0.0;
#line 120
		total_wire_chg = (float)0.0;
#line 121
		wire_chgs = 0;
#line 122
		windx = minxspan;
#line 124
		attmax = (int)(((float)((int)(((double)((float)iteration) / 121.0) * (double)((float)(2 * attprcel - attprcel / 2)))) + (float)(attprcel / 2)) * (float)moveable_cells);
#line 127
		if (tw_fast) {
#line 128
			attmax /= tw_fast;
		}
#line 130
		if (tw_slow) {
#line 131
			attmax *= tw_slow;
		}
#line 134
		fds = 0;
#line 135
		if (iteration >= 4) {
#line 136
			fds = controlf();
#line 137
			if (iteration <= 105) {
#line 138
				total_feed_length = (float)est_fds;
#line 139
				target_feed_length = (float)(0.7 * (double)((float)implicit_feed_count) - ((0.5 * (double)((float)implicit_feed_count)) / 105.0) * (double)((float)iteration));
#line 142
				if (implicit_feed_count > 0) {
#line 143
					factor = (total_feed_length - target_feed_length) / (float)implicit_feed_count;
				}
				else {
#line 146
					factor = (float)0.0;
				}
#line 148
				cost = 0;
#line 149
				net = 1;
#line 149
				while (net <= numnets) {
#line 150
					dimptr = *(netarray + net);
#line 151
					if ((double)dimptr->Vweight <= 1.0) {
#line 152
						dimptr->Vweight = (float)((double)dimptr->Vweight * (1.0 + (double)factor));
#line 153
						if ((double)dimptr->Vweight < 0.5) {
#line 154
							dimptr->Vweight = (float)0.5;
						}
						else {
#line 155
							if ((double)dimptr->Vweight > 1.0) {
#line 156
								dimptr->Vweight = (float)1.0;
							}
						}
					}
#line 159
					avg_VW += dimptr->Vweight;
#line 160
					cost += (int)(dimptr->Hweight * (float)(dimptr->xmax - dimptr->xmin)) + (int)(dimptr->Vweight * (float)(dimptr->ymax - dimptr->ymin));
#line 149
					net++;
				}
#line 165
				avg_VW /= (float)numnets;
#line 166
				funccost = cost;
			}
		}
		else {
#line 169
			avg_VW = (float)0.0;
		}
#line 174
		while (attempts < attmax) {
#line 179
			a = PICK_INT(1, numcells);
#line 182
			if (syf == 81) {
#line 182
				if (attempts == 197) {
#line 184
					printf("RandomCount=%d\n", RandomCount);
				}
			}
#line 187
			acellptr___0 = *(carray + a);
#line 188
			if (acellptr___0->cclass == -1) {
#line 189
				continue;
			}
#line 191
			ablock = acellptr___0->cblock;
#line 192
			ablckptr = *(barray + ablock);
#line 193
			axcenter___0 = acellptr___0->cxcenter;
#line 194
			aorient = (int)acellptr___0->corient;
#line 195
			abin = SetBin(axcenter___0);
#line 196
			cellaptr = (*(*(binptr + ablock) + abin))->cell;
#line 197
			i = 1;
#line 197
			while (i <= *cellaptr) {
#line 198
				if (*(cellaptr + i) == a) {
#line 199
					Apost = i;
#line 200
					break;
				}
#line 197
				i++;
			}
#line 210
			bblock = 0;
#line 211
			firstTry = 0;
#line 213
			botblk = ablock - 1;
#line 213
			if (botblk < 1) {
#line 214
				botblk = 1;
			}
#line 216
			topblk = ablock + 1;
#line 216
			if (topblk > numblock) {
#line 217
				topblk = numblock;
			}
#line 219
			i = 1;
#line 219
			while (1) {
#line 220
				while (1) {
#line 221
					blk___0 = XPICK_INT(botblk, topblk, firstTry);
#line 222
					bblckptr = *(barray + blk___0);
#line 220
					if (!(ablckptr->bclass != bblckptr->bclass)) {
#line 220
						break;
					}
				}
#line 229
				bleft___0 = bblckptr->bxcenter + bblckptr->bleft;
#line 230
				bright___0 = bblckptr->bxcenter + bblckptr->bright;
#line 231
				if (bleft___0 >= axcenter___0 - windx) {
#line 231
					l = bleft___0;
				}
				else {
#line 231
					l = axcenter___0 - windx;
				}
#line 232
				if (bright___0 <= axcenter___0 + windx) {
#line 232
					r = bright___0;
				}
				else {
#line 232
					r = axcenter___0 + windx;
				}
#line 233
				if (l > r) {
#line 234
					if (i == 1) {
#line 235
						firstTry = blk___0;
						goto __Cont;
					}
					else {
#line 238
						if (i == 3) {
#line 239
							if (r < bleft___0) {
#line 240
								r = bleft___0;
#line 240
								l = r;
							}
							else {
#line 243
								r = bright___0;
#line 243
								l = r;
							}
						}
						else {
#line 247
							firstTry = -ablock;
							goto __Cont;
						}
					}
				}
#line 251
				bblock = blk___0;
#line 252
				bycenter___0 = bblckptr->bycenter;
#line 256
				if (bblock == ablock) {
#line 257
					bxcenter___0 = XPICK_INT(l, r, axcenter___0);
				}
				else {
#line 259
					bxcenter___0 = XPICK_INT(l, r, 0);
				}
#line 261
				break;
			__Cont: /* CIL Label */
#line 219
				i++;
			}
#line 266
			bbin = SetBin(bxcenter___0);
#line 267
			cellbptr = (*(*(binptr + bblock) + bbin))->cell;
#line 272
			if (*cellbptr == 0) {
#line 274
				if (ablckptr->borient == 1) {
#line 275
					if (bblckptr->borient == 1) {
#line 279
						tmp___1 = ucxx1(bxcenter___0, bycenter___0);
#line 279
						if (tmp___1) {
#line 281
							flips++;
						}
						else {
#line 283
							rejects++;
#line 284
							if (rejects % 6 == 0) {
#line 284
								if ((int)acellptr___0->orflag != 0) {
#line 285
									if (aorient == 0) {
#line 285
										tmp___0 = 2;
									}
									else {
#line 285
										tmp___0 = 0;
									}
#line 285
									uc0(a, tmp___0);
								}
							}
						}
					}
					else {
#line 289
						if (aorient == 0) {
#line 289
							tmp___3 = 1;
						}
						else {
#line 289
							tmp___3 = 3;
						}
#line 289
						tmp___4 = ucxxo1(bxcenter___0, bycenter___0, tmp___3);
#line 289
						if (tmp___4) {
#line 290
							flips++;
						}
						else {
#line 292
							rejects++;
#line 293
							if (rejects % 6 == 0) {
#line 293
								if ((int)acellptr___0->orflag != 0) {
#line 294
									if (aorient == 0) {
#line 294
										tmp___2 = 2;
									}
									else {
#line 294
										tmp___2 = 0;
									}
#line 294
									uc0(a, tmp___2);
								}
							}
						}
					}
				}
				else {
#line 301
					if (bblckptr->borient == 1) {
#line 302
						if (aorient == 1) {
#line 302
							tmp___6 = 0;
						}
						else {
#line 302
							tmp___6 = 2;
						}
#line 302
						tmp___7 = ucxxo1(bxcenter___0, bycenter___0, tmp___6);
#line 302
						if (tmp___7) {
#line 304
							flips++;
						}
						else {
#line 306
							rejects++;
#line 307
							if (rejects % 6 == 0) {
#line 307
								if ((int)acellptr___0->orflag != 0) {
#line 308
									if (aorient == 1) {
#line 308
										tmp___5 = 3;
									}
									else {
#line 308
										tmp___5 = 1;
									}
#line 308
									uc0(a, tmp___5);
								}
							}
						}
					}
					else {
#line 312
						tmp___9 = ucxx1(bxcenter___0, bycenter___0);
#line 312
						if (tmp___9) {
#line 313
							flips++;
						}
						else {
#line 315
							rejects++;
#line 316
							if (rejects % 6 == 0) {
#line 316
								if ((int)acellptr___0->orflag != 0) {
#line 317
									if (aorient == 1) {
#line 317
										tmp___8 = 3;
									}
									else {
#line 317
										tmp___8 = 1;
									}
#line 317
									uc0(a, tmp___8);
								}
							}
						}
					}
				}
			}
			else {
#line 328
				Bpost = PICK_INT(1, *cellbptr);
#line 329
				b = *(cellbptr + Bpost);
#line 330
				bcellptr___0 = *(carray + b);
#line 331
				bblock = bcellptr___0->cblock;
#line 332
				bblckptr = *(barray + bblock);
#line 336
				if (acellptr___0->cclass != bcellptr___0->cclass) {
#line 337
					continue;
				}
				else {
#line 336
					if (a == b) {
#line 337
						continue;
					}
				}
#line 342
				borient___0 = (int)bcellptr___0->corient;
#line 343
				if (ablckptr->borient == 1) {
#line 344
					if (bblckptr->borient == 1) {
#line 355
						t = ucxx2();
#line 359
						if (t == -1) {
#line 360
							rejects++;
#line 361
							if (rejects % 6 == 0) {
#line 361
								if ((int)acellptr___0->orflag != 0) {
#line 362
									if (aorient == 0) {
#line 362
										tmp___10 = 2;
									}
									else {
#line 362
										tmp___10 = 0;
									}
#line 362
									uc0(a, tmp___10);
								}
							}
#line 364
							attempts++;
#line 365
							continue;
						}
						else {
#line 366
							if (t == 1) {
#line 367
								pairflips++;
							}
							else {
#line 369
								rejects++;
#line 370
								if (rejects % 6 == 0) {
#line 370
									if ((int)acellptr___0->orflag != 0) {
#line 371
										if (aorient == 0) {
#line 371
											tmp___11 = 2;
										}
										else {
#line 371
											tmp___11 = 0;
										}
#line 371
										uc0(a, tmp___11);
									}
								}
							}
						}
					}
					else {
#line 378
						if (borient___0 == 1) {
#line 378
							tmp___12 = 0;
						}
						else {
#line 378
							tmp___12 = 2;
						}
#line 378
						if (aorient == 0) {
#line 378
							tmp___13 = 1;
						}
						else {
#line 378
							tmp___13 = 3;
						}
#line 378
						t = ucxxo2(tmp___13, tmp___12);
#line 383
						if (t == -1) {
#line 384
							rejects++;
#line 385
							if (rejects % 6 == 0) {
#line 385
								if ((int)acellptr___0->orflag != 0) {
#line 386
									if (aorient == 0) {
#line 386
										tmp___14 = 2;
									}
									else {
#line 386
										tmp___14 = 0;
									}
#line 386
									uc0(a, tmp___14);
								}
							}
#line 388
							attempts++;
#line 389
							continue;
						}
						else {
#line 390
							if (t == 1) {
#line 391
								pairflips++;
							}
							else {
#line 393
								rejects++;
#line 394
								if (rejects % 6 == 0) {
#line 394
									if ((int)acellptr___0->orflag != 0) {
#line 395
										if (aorient == 0) {
#line 395
											tmp___15 = 2;
										}
										else {
#line 395
											tmp___15 = 0;
										}
#line 395
										uc0(a, tmp___15);
									}
								}
							}
						}
					}
				}
				else {
#line 406
					if (bblckptr->borient == 1) {
#line 409
						if (borient___0 == 0) {
#line 409
							tmp___16 = 1;
						}
						else {
#line 409
							tmp___16 = 3;
						}
#line 409
						if (aorient == 1) {
#line 409
							tmp___17 = 0;
						}
						else {
#line 409
							tmp___17 = 2;
						}
#line 409
						t = ucxxo2(tmp___17, tmp___16);
#line 411
						if (t == -1) {
#line 412
							rejects++;
#line 413
							if (rejects % 6 == 0) {
#line 413
								if ((int)acellptr___0->orflag != 0) {
#line 414
									if (aorient == 1) {
#line 414
										tmp___18 = 3;
									}
									else {
#line 414
										tmp___18 = 1;
									}
#line 414
									uc0(a, tmp___18);
								}
							}
#line 416
							attempts++;
#line 417
							continue;
						}
						else {
#line 418
							if (t == 1) {
#line 419
								pairflips++;
							}
							else {
#line 421
								rejects++;
#line 422
								if (rejects % 6 == 0) {
#line 422
									if ((int)acellptr___0->orflag != 0) {
#line 423
										if (aorient == 1) {
#line 423
											tmp___19 = 3;
										}
										else {
#line 423
											tmp___19 = 1;
										}
#line 423
										uc0(a, tmp___19);
									}
								}
							}
						}
					}
					else {
#line 427
						t = ucxx2();
#line 428
						if (t == -1) {
#line 429
							rejects++;
#line 430
							if (rejects % 6 == 0) {
#line 430
								if ((int)acellptr___0->orflag != 0) {
#line 431
									if (aorient == 1) {
#line 431
										tmp___20 = 3;
									}
									else {
#line 431
										tmp___20 = 1;
									}
#line 431
									uc0(a, tmp___20);
								}
							}
#line 433
							attempts++;
#line 434
							continue;
						}
						else {
#line 435
							if (t == 1) {
#line 436
								pairflips++;
							}
							else {
#line 438
								rejects++;
#line 439
								if (rejects % 6 == 0) {
#line 439
									if ((int)acellptr___0->orflag != 0) {
#line 440
										if (aorient == 1) {
#line 440
											tmp___21 = 3;
										}
										else {
#line 440
											tmp___21 = 1;
										}
#line 440
										uc0(a, tmp___21);
									}
								}
							}
						}
					}
				}
			}
#line 449
			attempts++;
		}
#line 458
		if (potential_errors > 0) {
#line 459
			percent_error = (float)error_count / (float)potential_errors;
		}
		else {
#line 461
			percent_error = (float)0.0;
		}
#line 463
		percent_error = (float)((double)percent_error * 100.0);
#line 466
		temp = (float)((100.0 * (double)((float)(pairflips + flips))) / (double)((float)attmax));
#line 467
		if ((double)pairflips > 0.0001) {
#line 468
			fp_ratio = (float)((100.0 * (double)((float)flips)) / (double)((float)pairflips));
		}
		else {
#line 470
			fp_ratio = (float)100.0;
		}
#line 473
		vert_statistics();
#line 475
		fprintf(fpo, "%3d %3d %4d %8d %7d %5d %4.1f %4.1f %4.1f %4.1f %4.1f", iteration + 1,
			(int)T, fds, funccost, penalty, P_limit, percent_error, binpenCon, roLenCon,
			temp, fp_ratio);
#line 478
		tmp___22 = ABS(tot_missing_rows);
#line 478
		fprintf(fpo, " %4.1f %5d %6d\n", (100.0 * (double)((float)earlyRej)) / (double)((float)attmax),
			tot_num_feeds, tmp___22);
#line 481
		fflush(fpo);
#line 484
		if (iteration < 1) {
			goto _L;
		}
		else {
#line 484
			if (resume_run == 1) {
			_L: /* CIL Label */
#line 485
				if (iteration < 1) {
#line 486
					cost_scale_factor = (float)1.0;
				}
#line 488
				rowcon();
#line 489
				resume_run = 0;
			}
			else {
#line 490
				if (iteration < 100) {
#line 491
					accept_deviation = (float)((double)(temp - *(desired_accept + iteration)) / 40.0);
#line 492
					cost_scale_factor = (float)((double)cost_scale_factor * (1.0 + (double)accept_deviation));
				}
			}
		}
#line 496
		if (iteration <= 104) {
#line 497
			target_bin_penalty = (float)((1.40 - (1.15 / 105.0) * ((double)((float)iteration) + 1.0)) * (double)((float)totalR));
#line 499
			binpenCon += ((float)binpenal - target_bin_penalty) / (float)totalR;
#line 501
			if ((double)binpenCon > 0.5) {
#line 501
				binpenCon = binpenCon;
			}
			else {
#line 501
				binpenCon = (float)0.5;
			}
#line 504
			target_row_penalty = (float)(((double)initialRowControl - ((double)(initialRowControl - finalRowControl) / 105.0) * ((double)((float)iteration) + 1.0)) * (double)((float)totalR));
#line 507
			roLenCon += ((float)rowpenal - target_row_penalty) / target_row_penalty;
#line 510
			if ((double)roLenCon > 0.5) {
#line 510
				roLenCon = roLenCon;
			}
			else {
#line 510
				roLenCon = (float)0.5;
			}
#line 512
			penalty = (int)(binpenCon * (float)binpenal + roLenCon * (float)rowpenal);
		}
#line 516
		return;
	}
}
#line 523 "uloop.c"
int rowcon(void)
{
	int C;
	int R;
	int p_first;
	int totalCells;
	int cellsPerRow;
	int temp_R;
	int over;
	int under;
	float states;
	float value;
	float expect;
	float variance;
	float expectedExtraRowLength;
	float rowControl;
	float x;
	float minDev;
	double tmp;

	{
#line 531
		totalCells = numcells;
#line 532
		R = numRows;
#line 534
		cellsPerRow = totalCells / R;
#line 536
		temp_R = R - R / 3;
#line 537
		rowControl = (float)0.0;
#line 538
		while (1) {
#line 539
			rowControl = (float)((double)rowControl + 0.001);
#line 540
			C = (int)((double)(rowControl * (float)totalCells) / 2.0);
#line 541
			if (2.0 * (double)((float)(C + 1)) - (double)(rowControl * (float)totalCells) <= (double)(rowControl * (float)totalCells) - 2.0 * (double)((float)C)) {
#line 543
				C++;
			}
#line 538
			if (!(2 * C < temp_R)) {
#line 538
				break;
			}
		}
#line 547
		p_first = C / R;
#line 548
		if (p_first * R < C) {
#line 549
			p_first++;
		}
#line 551
		R -= R / 3;
#line 553
		under = 0;
#line 554
		over = 0;
#line 555
		while (1) {
#line 556
			value = expected_value(C, 0, p_first, R);
#line 557
			states = combination((C + R) - 1, C);
#line 558
			expect = value / states;
#line 559
			expectedExtraRowLength = (float)((100.0 * (double)expect) / (double)((float)cellsPerRow));
#line 560
			value = expected_svalue(C, 0, p_first, R);
#line 561
			variance = value / states - expect * expect;
#line 562
			tmp = sqrt((double)variance);
#line 562
			x = (float)((100.0 * tmp) / (double)((float)cellsPerRow));
#line 563
			minDev = (float)(100.0 / (double)((float)cellsPerRow));
#line 564
			value = (x + expectedExtraRowLength) - minDev;
#line 573
			if ((double)value > 2.7) {
#line 573
				if ((double)value < 3.3) {
#line 574
					break;
				}
				else {
					goto _L;
				}
			}
			else {
			_L: /* CIL Label */
#line 575
				if ((double)value <= 2.7) {
#line 576
					rowControl = (float)((double)rowControl + 0.001);
#line 577
					if (!over) {
#line 578
						under = 1;
					}
					else {
#line 580
						break;
					}
				}
				else {
#line 582
					if ((double)value >= 3.3) {
#line 583
						if (!under) {
#line 584
							rowControl = (float)((double)rowControl - 0.001);
#line 585
							over = 1;
						}
						else {
#line 587
							break;
						}
					}
				}
			}
#line 590
			C = (int)((double)(rowControl * (float)totalCells) / 2.0);
#line 591
			if (2.0 * (double)((float)(C + 1)) - (double)(rowControl * (float)totalCells) <= (double)(rowControl * (float)totalCells) - 2.0 * (double)((float)C)) {
#line 593
				C++;
			}
#line 595
			p_first = C / R;
#line 596
			if (p_first * R < C) {
#line 597
				p_first++;
			}
		}
#line 601
		initialRowControl = (float)(5.5 * (double)rowControl);
#line 602
		finalRowControl = rowControl;
#line 604
		return;
	}
}
#line 608 "uloop.c"
float partition(int C_initial, int k_initial, int p_initial, int R_initial)
{
	int R;
	int C;
	int k___0;
	int p;
	int k_limit;
	int p_limit;
	float states;
	float equivs;
	float tmp;
	float tmp___0;

	{
#line 615
		states = (float)0.0;
#line 616
		k_limit = R_initial - k_initial;
#line 616
		R = k_limit;
#line 617
		C = C_initial - p_initial * k_initial;
#line 619
		k___0 = 1;
#line 619
		while (k___0 <= k_limit) {
#line 620
			equivs = combination(R, k___0);
#line 621
			p_limit = C / k___0;
#line 622
			p = p_initial;
#line 622
			while (p <= p_limit) {
#line 623
				if (C - (p - 1) * R > k___0) {
					goto __Cont;
				}
#line 626
				tmp = compute_and_combination(C, k___0, p, R);
#line 626
				tmp___0 = partition(C, k___0, p, R);
#line 626
				states += equivs * (tmp - tmp___0);
				goto __Cont;
			__Cont: /* CIL Label */
#line 622
				p++;
			}
#line 619
			k___0++;
		}
#line 632
		return (states);
	}
}
#line 636 "uloop.c"
float expected_value(int C_initial, int k_initial, int p_initial, int R_initial)
{
	int R;
	int C;
	int k___0;
	int p;
	int k_limit;
	int p_limit;
	float value;
	float equivs;
	float tmp;
	float tmp___0;

	{
#line 643
		value = (float)0.0;
#line 644
		k_limit = R_initial - k_initial;
#line 644
		R = k_limit;
#line 645
		C = C_initial - p_initial * k_initial;
#line 647
		k___0 = 1;
#line 647
		while (k___0 <= k_limit) {
#line 648
			equivs = combination(R, k___0);
#line 649
			p_limit = C / k___0;
#line 650
			p = p_initial;
#line 650
			while (p <= p_limit) {
#line 651
				if (C - (p - 1) * R > k___0) {
					goto __Cont;
				}
#line 654
				tmp = compute_and_combination(C, k___0, p, R);
#line 654
				tmp___0 = partition(C, k___0, p, R);
#line 654
				value += ((float)p * equivs) * (tmp - tmp___0);
			__Cont: /* CIL Label */
#line 650
				p++;
			}
#line 647
			k___0++;
		}
#line 660
		return (value);
	}
}
#line 664 "uloop.c"
float expected_svalue(int C_initial, int k_initial, int p_initial, int R_initial)
{
	int R;
	int C;
	int k___0;
	int p;
	int k_limit;
	int p_limit;
	float value;
	float equivs;
	float tmp;
	float tmp___0;

	{
#line 671
		value = (float)0.0;
#line 672
		k_limit = R_initial - k_initial;
#line 672
		R = k_limit;
#line 673
		C = C_initial - p_initial * k_initial;
#line 675
		k___0 = 1;
#line 675
		while (k___0 <= k_limit) {
#line 676
			equivs = combination(R, k___0);
#line 677
			p_limit = C / k___0;
#line 678
			p = p_initial;
#line 678
			while (p <= p_limit) {
#line 679
				if (C - (p - 1) * R > k___0) {
					goto __Cont;
				}
#line 682
				tmp = compute_and_combination(C, k___0, p, R);
#line 682
				tmp___0 = partition(C, k___0, p, R);
#line 682
				value += ((float)(p * p) * equivs) * (tmp - tmp___0);
			__Cont: /* CIL Label */
#line 678
				p++;
			}
#line 675
			k___0++;
		}
#line 688
		return (value);
	}
}
#line 692 "uloop.c"
float compute_and_combination(int C, int k___0, int p, int R)
{
	int numerator;
	int denom1;
	int denom2;
	int temp;
	float states;

	{
#line 698
		states = (float)1.0;
#line 699
		numerator = (((C - k___0 * p) + R) - k___0) - 1;
#line 700
		denom1 = C - k___0 * p;
#line 701
		denom2 = (R - k___0) - 1;
#line 702
		if (denom1 > denom2) {
#line 703
			temp = denom1;
#line 704
			denom1 = denom2;
#line 705
			denom2 = temp;
		}
#line 707
		while (numerator > denom2) {
#line 708
			states *= (float)numerator;
#line 709
			states /= (float)denom1;
#line 707
			numerator--;
#line 707
			denom1--;
		}
#line 712
		return (states);
	}
}
#line 716 "uloop.c"
float combination(int numerator, int denominator)
{
	float states;
	int temp;
	int denom1;
	int denom2;

	{
#line 722
		states = (float)1.0;
#line 724
		denom1 = denominator;
#line 725
		denom2 = numerator - denominator;
#line 726
		if (denom1 > denom2) {
#line 727
			temp = denom1;
#line 728
			denom1 = denom2;
#line 729
			denom2 = temp;
		}
#line 731
		while (numerator > denom2) {
#line 732
			states *= (float)numerator;
#line 733
			states /= (float)denom1;
#line 731
			numerator--;
#line 731
			denom1--;
		}
#line 736
		return (states);
	}
}
#line 1 "uloop2.o"
#pragma merger(0,"./uloop2.i","")
#line 37 "uloop2.c"
void uloop2(void)
{
	CBOXPTR acellptr___0;
	CBOXPTR bcellptr___0;
	BBOXPTR ablckptr;
	BBOXPTR bblckptr;
	int botblk;
	int topblk;
	int flips;
	int axcenter___0;
	int bxcenter___0;
	int bycenter___0;
	int aorient;
	int borient___0;
	int bleft___0;
	int bright___0;
	int blk___0;
	int pairflips;
	int i;
	int r;
	int l;
	int t;
	int abin;
	int bbin;
	int firstTry;
	int fds;
	float temp;
	float fp_ratio;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	int tmp___7;
	int tmp___8;

	{
#line 54
		attempts = 0;
#line 55
		flips = 0;
#line 56
		pairflips = 0;
#line 57
		earlyRej = 0;
#line 59
		P_limit = -1;
#line 60
		windx = minxspan;
#line 62
		attmax = (2 * attprcel) * numcells;
#line 63
		binpenCon = (float)0.0;
#line 65
		fds = 0;
#line 66
		if (estimate_feeds) {
#line 67
			fds = controlf();
		}
#line 70
		while (attempts < attmax) {
#line 72
			a = PICK_INT(1, numcells);
#line 74
			acellptr___0 = *(carray + a);
#line 75
			if (acellptr___0->cclass == -1) {
#line 76
				continue;
			}
#line 78
			ablock = acellptr___0->cblock;
#line 79
			ablckptr = *(barray + ablock);
#line 80
			axcenter___0 = acellptr___0->cxcenter;
#line 81
			aorient = (int)acellptr___0->corient;
#line 82
			abin = SetBin(axcenter___0);
#line 83
			cellaptr = (*(*(binptr + ablock) + abin))->cell;
#line 84
			i = 1;
#line 84
			while (i <= *cellaptr) {
#line 85
				if (*(cellaptr + i) == a) {
#line 86
					Apost = i;
#line 87
					break;
				}
#line 84
				i++;
			}
#line 95
			bblock = 0;
#line 96
			firstTry = 0;
#line 98
			botblk = ablock - 1;
#line 98
			if (botblk < 1) {
#line 99
				botblk = 1;
			}
#line 101
			topblk = ablock + 1;
#line 101
			if (topblk > numblock) {
#line 102
				topblk = numblock;
			}
#line 104
			i = 1;
#line 104
			while (1) {
#line 105
				while (1) {
#line 106
					blk___0 = XPICK_INT(botblk, topblk, firstTry);
#line 107
					bblckptr = *(barray + blk___0);
#line 105
					if (!(ablock == blk___0)) {
#line 105
						if (!(ablckptr->bclass != bblckptr->bclass)) {
#line 105
							break;
						}
					}
				}
#line 112
				bleft___0 = bblckptr->bxcenter + bblckptr->bleft;
#line 113
				bright___0 = bblckptr->bxcenter + bblckptr->bright;
#line 114
				if (bleft___0 >= axcenter___0 - windx) {
#line 114
					l = bleft___0;
				}
				else {
#line 114
					l = axcenter___0 - windx;
				}
#line 115
				if (bright___0 <= axcenter___0 + windx) {
#line 115
					r = bright___0;
				}
				else {
#line 115
					r = axcenter___0 + windx;
				}
#line 116
				if (l > r) {
#line 117
					if (i == 1) {
#line 118
						firstTry = blk___0;
						goto __Cont;
					}
					else {
#line 120
						if (i == 3) {
#line 121
							if (r < bleft___0) {
#line 122
								r = bleft___0;
#line 122
								l = r;
							}
							else {
#line 124
								r = bright___0;
#line 124
								l = r;
							}
						}
						else {
#line 127
							firstTry = -ablock;
							goto __Cont;
						}
					}
				}
#line 131
				bblock = blk___0;
#line 132
				bycenter___0 = bblckptr->bycenter;
#line 134
				if (bblock == ablock) {
#line 135
					bxcenter___0 = XPICK_INT(l, r, axcenter___0);
				}
				else {
#line 137
					bxcenter___0 = XPICK_INT(l, r, 0);
				}
#line 139
				break;
			__Cont: /* CIL Label */
#line 104
				i++;
			}
#line 141
			bbin = SetBin(bxcenter___0);
#line 142
			cellbptr = (*(*(binptr + bblock) + bbin))->cell;
#line 144
			if (*cellbptr == 0) {
#line 146
				if (ablckptr->borient == 1) {
#line 147
					if (bblckptr->borient == 1) {
#line 148
						tmp = ucxx1(bxcenter___0, bycenter___0);
#line 148
						if (tmp) {
#line 149
							flips++;
						}
					}
					else {
#line 152
						if (aorient == 0) {
#line 152
							tmp___0 = 1;
						}
						else {
#line 152
							tmp___0 = 3;
						}
#line 152
						tmp___1 = ucxxo1(bxcenter___0, bycenter___0, tmp___0);
#line 152
						if (tmp___1) {
#line 153
							flips++;
						}
					}
				}
				else {
#line 157
					if (bblckptr->borient == 1) {
#line 158
						if (aorient == 1) {
#line 158
							tmp___2 = 0;
						}
						else {
#line 158
							tmp___2 = 2;
						}
#line 158
						tmp___3 = ucxxo1(bxcenter___0, bycenter___0, tmp___2);
#line 158
						if (tmp___3) {
#line 160
							flips++;
						}
					}
					else {
#line 163
						tmp___4 = ucxx1(bxcenter___0, bycenter___0);
#line 163
						if (tmp___4) {
#line 164
							flips++;
						}
					}
				}
			}
			else {
#line 170
				Bpost = PICK_INT(1, *cellbptr);
#line 171
				b = *(cellbptr + Bpost);
#line 172
				bcellptr___0 = *(carray + b);
#line 173
				bblock = bcellptr___0->cblock;
#line 174
				bblckptr = *(barray + bblock);
#line 176
				if (bcellptr___0->cclass == -1) {
#line 177
					continue;
				}
				else {
#line 176
					if (a == b) {
#line 177
						continue;
					}
				}
#line 180
				borient___0 = (int)bcellptr___0->corient;
#line 181
				if (ablckptr->borient == 1) {
#line 182
					if (bblckptr->borient == 1) {
#line 183
						t = ucxx2();
#line 184
						if (t == 1) {
#line 185
							pairflips++;
						}
					}
					else {
#line 188
						if (borient___0 == 1) {
#line 188
							tmp___5 = 0;
						}
						else {
#line 188
							tmp___5 = 2;
						}
#line 188
						if (aorient == 0) {
#line 188
							tmp___6 = 1;
						}
						else {
#line 188
							tmp___6 = 3;
						}
#line 188
						t = ucxxo2(tmp___6, tmp___5);
#line 190
						if (t == 1) {
#line 191
							pairflips++;
						}
					}
				}
				else {
#line 195
					if (bblckptr->borient == 1) {
#line 196
						if (borient___0 == 0) {
#line 196
							tmp___7 = 1;
						}
						else {
#line 196
							tmp___7 = 3;
						}
#line 196
						if (aorient == 1) {
#line 196
							tmp___8 = 0;
						}
						else {
#line 196
							tmp___8 = 2;
						}
#line 196
						t = ucxxo2(tmp___8, tmp___7);
#line 198
						if (t == 1) {
#line 199
							pairflips++;
						}
					}
					else {
#line 202
						t = ucxx2();
#line 203
						if (t == 1) {
#line 204
							pairflips++;
						}
					}
				}
			}
#line 209
			attempts++;
		}
#line 213
		temp = (float)((100.0 * (double)((float)(pairflips + flips))) / (double)((float)attmax));
#line 214
		if ((double)pairflips > 0.0001) {
#line 215
			fp_ratio = (float)((100.0 * (double)((float)flips)) / (double)((float)pairflips));
		}
		else {
#line 217
			fp_ratio = (float)100.0;
		}
#line 220
		fprintf(fpo, "%3d %3d %4d %8d %7d %5d 0.0 %4.1f %4.1f %4.1f %4.1f", iteration + 1,
			(int)T, fds, funccost, penalty, P_limit, binpenCon, roLenCon, temp, fp_ratio);
#line 223
		fprintf(fpo, " %4.1f\n", (100.0 * (double)((float)earlyRej)) / (double)((float)attmax));
#line 224
		fflush(fpo);
#line 226
		return;
	}
}
#line 1 "unetseg.o"
#pragma merger(0,"./unetseg.i","")
#line 4 "unetseg.c"
void unetseg(void)
{
	SEGBOXPTR segptr;
	CHANGRDPTR ptr1;
	CHANGRDPTR ptr2;
	CHANGRDPTR bptr;
	CHANGRDPTR fptr;
	CHANGRDPTR sptr;
	CHANGRDPTR eptr;
	CHANGRDPTR ptr;
	CHANGRDPTR gdptr;
	CHANGRDPTR tryptr[500];
	DENSITYPTR denptr;
	DENSITYPTR headptr;
	NBOXPTR netptr;
	int pin1;
	int pin2;
	int x1;
	int x2;
	int x;
	int i;
	int channel;
	int chan;
	int up_channel;
	int segment;
	int Flag;
	int changes;
	int index___0;
	int b___0;
	int e;
	int net;
	int track;
	int dtrack;
	int Ucount;
	int Lcount;
	int j;
	int t;
	int tryFlag[500];
	int trynet;
	int pinloc;
	int self_reset;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;

	{
#line 19
		gtopChan = 1;
#line 20
		gbotChan = numChans;
#line 21
		tracks = 0;
#line 22
		index___0 = 1;
#line 22
		while (index___0 <= *(netchgs + 0)) {
#line 23
			net = *(netchgs + index___0);
#line 24
			b___0 = *(anet + net);
#line 25
			e = *(anet + (net + 1)) - 1;
#line 26
			segment = b___0;
#line 26
			while (segment <= e) {
#line 27
				if ((int)(aNetSeg + segment)->current == 0) {
#line 28
					segptr = (aNetSeg + segment)->top;
				}
				else {
#line 30
					segptr = (aNetSeg + segment)->bot;
				}
#line 32
				pin1 = segptr->pin1;
#line 33
				pin2 = segptr->pin2;
#line 34
				if (pin1 > maxterm) {
#line 34
					if (pin2 > maxterm) {
						goto __Cont;
					}
				}
#line 37
				ptr1 = segptr->pin1ptr;
#line 38
				ptr2 = segptr->pin2ptr;
#line 39
				x1 = (ptr1->netptr)->newx;
#line 40
				x2 = (ptr2->netptr)->newx;
#line 41
				if (x1 == x2) {
					goto __Cont;
				}
#line 44
				channel = segptr->channel;
#line 45
				if (channel > gtopChan) {
#line 46
					gtopChan = channel;
				}
#line 48
				if (channel < gbotChan) {
#line 49
					gbotChan = channel;
				}
#line 51
				net = (aNetSeg + segment)->net;
#line 52
				if (ptr1->nSegType > 0) {
#line 53
					Flag = 0;
#line 54
					bptr = ptr1;
#line 55
					while (1) {
#line 55
						if ((unsigned int)bptr->prevgrd != (unsigned int)((void *)0)) {
#line 55
							if (!(((bptr->prevgrd)->netptr)->newx == x1)) {
#line 55
								break;
							}
						}
						else {
#line 55
							break;
						}
#line 57
						if (net == (*(tearray + ((bptr->prevgrd)->netptr)->terminal))->net) {
#line 57
							if ((bptr->prevgrd)->nSegType < 0) {
#line 59
								Flag = 1;
#line 60
								sptr = (struct changrdbox *)ptr1->nextgrd;
#line 61
								while ((sptr->netptr)->newx == x1) {
#line 62
									sptr = (struct changrdbox *)sptr->nextgrd;
								}
#line 64
								break;
							}
							else {
#line 66
								bptr = (struct changrdbox *)bptr->prevgrd;
							}
						}
						else {
#line 66
							bptr = (struct changrdbox *)bptr->prevgrd;
						}
					}
#line 69
					if (!Flag) {
#line 70
						sptr = (struct changrdbox *)ptr1->nextgrd;
#line 71
						while ((sptr->netptr)->newx == x1) {
#line 72
							if (net == (*(tearray + (sptr->netptr)->terminal))->net) {
#line 72
								if (sptr->nSegType < 0) {
#line 74
									Flag = 1;
								}
							}
#line 76
							sptr = (struct changrdbox *)sptr->nextgrd;
						}
					}
#line 79
					if (!Flag) {
#line 80
						sptr = bptr;
					}
				}
				else {
#line 83
					if (x1 != gxstart) {
#line 84
						sptr = (struct changrdbox *)ptr1->nextgrd;
#line 85
						while ((sptr->netptr)->newx == x1) {
#line 86
							sptr = (struct changrdbox *)sptr->nextgrd;
						}
					}
					else {
#line 89
						sptr = ptr1;
					}
				}
#line 93
				if (ptr2->nSegType < 0) {
#line 94
					Flag = 0;
#line 95
					fptr = ptr2;
#line 96
					while (1) {
#line 96
						if ((unsigned int)fptr->nextgrd != (unsigned int)((void *)0)) {
#line 96
							if (!(((fptr->nextgrd)->netptr)->newx == x2)) {
#line 96
								break;
							}
						}
						else {
#line 96
							break;
						}
#line 98
						if (net == (*(tearray + ((fptr->nextgrd)->netptr)->terminal))->net) {
#line 98
							if ((fptr->nextgrd)->nSegType > 0) {
#line 100
								Flag = 1;
#line 101
								eptr = (struct changrdbox *)ptr2->prevgrd;
#line 102
								while ((eptr->netptr)->newx == x2) {
#line 103
									eptr = (struct changrdbox *)eptr->prevgrd;
								}
#line 105
								break;
							}
							else {
#line 107
								fptr = (struct changrdbox *)fptr->nextgrd;
							}
						}
						else {
#line 107
							fptr = (struct changrdbox *)fptr->nextgrd;
						}
					}
#line 110
					if (!Flag) {
#line 111
						eptr = (struct changrdbox *)ptr2->prevgrd;
#line 112
						while ((eptr->netptr)->newx == x2) {
#line 113
							if (net == (*(tearray + (eptr->netptr)->terminal))->net) {
#line 113
								if (eptr->nSegType > 0) {
#line 115
									Flag = 1;
								}
							}
#line 117
							eptr = (struct changrdbox *)eptr->prevgrd;
						}
					}
#line 120
					if (!Flag) {
#line 121
						eptr = fptr;
					}
				}
				else {
#line 124
					if (x2 != gxstop) {
#line 125
						eptr = (struct changrdbox *)ptr2->prevgrd;
#line 126
						while ((eptr->netptr)->newx == x2) {
#line 127
							eptr = (struct changrdbox *)eptr->prevgrd;
						}
					}
					else {
#line 130
						eptr = ptr2;
					}
				}
#line 133
				eptr = (struct changrdbox *)eptr->nextgrd;
#line 134
				if (pin1 <= maxterm) {
#line 135
					(ptr1->nSegType)--;
				}
#line 137
				if (pin2 <= maxterm) {
#line 138
					ptr2->nSegType -= -1;
				}
#line 141
				ptr = sptr;
#line 141
				while ((unsigned int)ptr != (unsigned int)eptr) {
#line 142
					denptr = ptr->dptr;
#line 143
					if ((unsigned int)denptr->nnext != (unsigned int)((void *)0)) {
#line 144
						(denptr->nnext)->nback = denptr->nback;
					}
#line 146
					(denptr->nback)->nnext = denptr->nnext;
#line 147
					(ptr->ntracks)--;
#line 147
					track = ptr->ntracks;
#line 149
					headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 150
					if ((unsigned int)headptr != (unsigned int)((void *)0)) {
#line 151
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 152
						denptr->nnext = headptr;
#line 153
						headptr->nback = denptr;
#line 154
						denptr->nback = *(*(DboxHead + channel) + track);
					}
					else {
#line 156
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 157
						denptr->nnext = (struct densitybox *)((void *)0);
#line 158
						denptr->nback = *(*(DboxHead + channel) + track);
					}
#line 141
					ptr = (struct changrdbox *)ptr->nextgrd;
				}
			__Cont: /* CIL Label */
#line 26
				segment++;
			}
#line 22
			index___0++;
		}
#line 167
		Lcount = 0;
#line 167
		Ucount = Lcount;
#line 169
		if ((unsigned int)ULgrdptr != (unsigned int)((void *)0)) {
#line 170
			if ((int)(ULgrdptr->netptr)->pinloc == 0) {
#line 171
				gdptr = (struct changrdbox *)ULgrdptr->nnextgrd;
#line 172
				while ((int)(gdptr->netptr)->pinloc == 0) {
#line 173
					gdptr = (struct changrdbox *)gdptr->nnextgrd;
				}
#line 175
				if ((int)(gdptr->netptr)->pinloc == -1) {
#line 176
					channel = (gdptr->netptr)->row;
				}
				else {
#line 178
					channel = (gdptr->netptr)->row + 1;
				}
			}
			else {
#line 181
				if ((int)(ULgrdptr->netptr)->pinloc == -1) {
#line 182
					channel = (ULgrdptr->netptr)->row;
				}
				else {
#line 184
					channel = (ULgrdptr->netptr)->row + 1;
				}
			}
		}
		else {
#line 188
			if ((int)(LLgrdptr->netptr)->pinloc == 0) {
#line 189
				gdptr = (struct changrdbox *)LLgrdptr->nnextgrd;
#line 190
				while ((int)(gdptr->netptr)->pinloc == 0) {
#line 191
					gdptr = (struct changrdbox *)gdptr->nnextgrd;
				}
#line 193
				if ((int)(gdptr->netptr)->pinloc == -1) {
#line 194
					channel = (gdptr->netptr)->row;
				}
				else {
#line 196
					channel = (gdptr->netptr)->row + 1;
				}
			}
			else {
#line 199
				if ((int)(LLgrdptr->netptr)->pinloc == -1) {
#line 200
					channel = (LLgrdptr->netptr)->row;
				}
				else {
#line 202
					channel = (LLgrdptr->netptr)->row + 1;
				}
			}
#line 205
			channel++;
		}
#line 207
		up_channel = channel;
#line 209
		if ((unsigned int)ULgrdptr != (unsigned int)((void *)0)) {
#line 210
			gdptr = (struct changrdbox *)ULgrdptr->nextgrd;
#line 210
			while ((unsigned int)gdptr != (unsigned int)URgrdptr) {
#line 212
				tmp = Ucount;
#line 212
				Ucount++;
#line 212
				* (Shuffle + tmp) = (struct changrdbox *)gdptr;
#line 210
				gdptr = (struct changrdbox *)gdptr->nextgrd;
			}
#line 214
			qsortgdx((char *)Shuffle, Ucount, sizeof(CHANGRDPTR));
#line 216
			ULgrdptr->nnextgrd = *(Shuffle + 0);
#line 217
			(*(Shuffle + 0))->nprevgrd = ULgrdptr;
#line 218
			if (Ucount >= 2) {
#line 219
				i = 0;
#line 219
				while (i <= Ucount - 2) {
#line 220
					(*(Shuffle + i))->nnextgrd = *(Shuffle + (i + 1));
#line 221
					(*(Shuffle + (i + 1)))->nprevgrd = *(Shuffle + i);
#line 219
					i++;
				}
			}
#line 224
			(*(Shuffle + (Ucount - 1)))->nnextgrd = URgrdptr;
#line 225
			URgrdptr->nprevgrd = *(Shuffle + (Ucount - 1));
#line 227
			gdptr = (struct changrdbox *)ULgrdptr->nnextgrd;
#line 227
			while ((unsigned int)gdptr != (unsigned int)URgrdptr) {
#line 229
				x = (gdptr->netptr)->xpos;
#line 230
				dtrack = 0;
#line 231
				if (x != (gdptr->netptr)->newx) {
#line 232
					denptr = gdptr->dptr;
#line 233
					if ((unsigned int)denptr->nnext != (unsigned int)((void *)0)) {
#line 234
						(denptr->nnext)->nback = denptr->nback;
					}
#line 236
					(denptr->nback)->nnext = denptr->nnext;
#line 238
					tryptr[0] = (struct changrdbox *)gdptr->nprevgrd;
#line 239
					if (((tryptr[0])->netptr)->xpos != x) {
#line 240
						t = 0;
#line 240
						tryFlag[t] = 0;
#line 241
						while (1) {
#line 241
							if ((unsigned int)(tryptr[t])->nprevgrd != (unsigned int)((void *)0)) {
#line 241
								if (!((((tryptr[t])->nprevgrd)->netptr)->xpos == ((tryptr[0])->netptr)->xpos)) {
#line 241
									break;
								}
							}
							else {
#line 241
								break;
							}
#line 244
							t++;
#line 245
							tryptr[t] = (struct changrdbox *)(tryptr[t - 1])->nprevgrd;
#line 246
							tryFlag[t] = 0;
						}
#line 248
						i = 0;
#line 248
						while (i <= t) {
#line 249
							if (tryFlag[i] == 0) {
#line 250
								changes = 0;
#line 251
								trynet = (*(tearray + ((tryptr[i])->netptr)->terminal))->net;
#line 253
								changes += (tryptr[i])->nSegType;
#line 254
								j = i + 1;
#line 254
								while (j <= t) {
#line 255
									if ((*(tearray + ((tryptr[j])->netptr)->terminal))->net == trynet) {
#line 257
										tryFlag[j] = 1;
#line 258
										changes += (tryptr[j])->nSegType;
									}
#line 254
									j++;
								}
#line 261
								if (changes < 0) {
#line 262
									dtrack += changes;
								}
							}
#line 248
							i++;
						}
#line 266
						tryptr[0] = (struct changrdbox *)gdptr->nnextgrd;
#line 267
						if (((tryptr[0])->netptr)->xpos == x) {
#line 268
							t = 0;
#line 268
							tryFlag[t] = 0;
#line 269
							while (1) {
#line 269
								if ((unsigned int)(tryptr[t])->nnextgrd != (unsigned int)((void *)0)) {
#line 269
									if (!((((tryptr[t])->nnextgrd)->netptr)->xpos == ((tryptr[0])->netptr)->xpos)) {
#line 269
										break;
									}
								}
								else {
#line 269
									break;
								}
#line 272
								t++;
#line 273
								tryptr[t] = (struct changrdbox *)(tryptr[t - 1])->nnextgrd;
#line 274
								tryFlag[t] = 0;
							}
#line 276
							i = 0;
#line 276
							while (i <= t) {
#line 277
								if (tryFlag[i] == 0) {
#line 278
									changes = 0;
#line 279
									trynet = (*(tearray + ((tryptr[i])->netptr)->terminal))->net;
#line 281
									changes += (tryptr[i])->nSegType;
#line 282
									j = i + 1;
#line 282
									while (j <= t) {
#line 283
										if ((*(tearray + ((tryptr[j])->netptr)->terminal))->net == trynet) {
#line 285
											tryFlag[j] = 1;
#line 286
											changes += (tryptr[j])->nSegType;
										}
#line 282
										j++;
									}
#line 289
									if (changes > 0) {
#line 290
										dtrack += changes;
									}
								}
#line 276
								i++;
							}
						}
					}
#line 297
					gdptr->ntracks = (gdptr->nprevgrd)->ntracks + dtrack;
#line 298
					track = gdptr->ntracks;
#line 300
					headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 301
					if ((unsigned int)headptr != (unsigned int)((void *)0)) {
#line 302
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 303
						denptr->nnext = headptr;
#line 304
						headptr->nback = denptr;
#line 305
						denptr->nback = *(*(DboxHead + channel) + track);
					}
					else {
#line 307
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 308
						denptr->nnext = (struct densitybox *)((void *)0);
#line 309
						denptr->nback = *(*(DboxHead + channel) + track);
					}
				}
#line 227
				gdptr = (struct changrdbox *)gdptr->nnextgrd;
			}
		}
#line 315
		if ((unsigned int)LLgrdptr != (unsigned int)((void *)0)) {
#line 317
			channel--;
#line 318
			gdptr = (struct changrdbox *)LLgrdptr->nextgrd;
#line 318
			while ((unsigned int)gdptr != (unsigned int)LRgrdptr) {
#line 320
				tmp___0 = Lcount;
#line 320
				Lcount++;
#line 320
				* (Shuffle + tmp___0) = (struct changrdbox *)gdptr;
#line 318
				gdptr = (struct changrdbox *)gdptr->nextgrd;
			}
#line 322
			qsortgdx((char *)Shuffle, Lcount, sizeof(CHANGRDPTR));
#line 324
			LLgrdptr->nnextgrd = *(Shuffle + 0);
#line 325
			(*(Shuffle + 0))->nprevgrd = LLgrdptr;
#line 326
			if (Lcount >= 2) {
#line 327
				i = 0;
#line 327
				while (i <= Lcount - 2) {
#line 328
					(*(Shuffle + i))->nnextgrd = *(Shuffle + (i + 1));
#line 329
					(*(Shuffle + (i + 1)))->nprevgrd = *(Shuffle + i);
#line 327
					i++;
				}
			}
#line 332
			(*(Shuffle + (Lcount - 1)))->nnextgrd = LRgrdptr;
#line 333
			LRgrdptr->nprevgrd = *(Shuffle + (Lcount - 1));
#line 335
			gdptr = (struct changrdbox *)LLgrdptr->nnextgrd;
#line 335
			while ((unsigned int)gdptr != (unsigned int)LRgrdptr) {
#line 337
				x = (gdptr->netptr)->xpos;
#line 338
				dtrack = 0;
#line 339
				if (x != (gdptr->netptr)->newx) {
#line 340
					denptr = gdptr->dptr;
#line 341
					if ((unsigned int)denptr->nnext != (unsigned int)((void *)0)) {
#line 342
						(denptr->nnext)->nback = denptr->nback;
					}
#line 344
					(denptr->nback)->nnext = denptr->nnext;
#line 346
					tryptr[0] = (struct changrdbox *)gdptr->nprevgrd;
#line 347
					if (((tryptr[0])->netptr)->xpos != x) {
#line 348
						t = 0;
#line 348
						tryFlag[t] = 0;
#line 349
						while (1) {
#line 349
							if ((unsigned int)(tryptr[t])->nprevgrd != (unsigned int)((void *)0)) {
#line 349
								if (!((((tryptr[t])->nprevgrd)->netptr)->xpos == ((tryptr[0])->netptr)->xpos)) {
#line 349
									break;
								}
							}
							else {
#line 349
								break;
							}
#line 352
							t++;
#line 353
							tryptr[t] = (struct changrdbox *)(tryptr[t - 1])->nprevgrd;
#line 354
							tryFlag[t] = 0;
						}
#line 356
						i = 0;
#line 356
						while (i <= t) {
#line 357
							if (tryFlag[i] == 0) {
#line 358
								changes = 0;
#line 359
								trynet = (*(tearray + ((tryptr[i])->netptr)->terminal))->net;
#line 361
								changes += (tryptr[i])->nSegType;
#line 362
								j = i + 1;
#line 362
								while (j <= t) {
#line 363
									if ((*(tearray + ((tryptr[j])->netptr)->terminal))->net == trynet) {
#line 365
										tryFlag[j] = 1;
#line 366
										changes += (tryptr[j])->nSegType;
									}
#line 362
									j++;
								}
#line 369
								if (changes < 0) {
#line 370
									dtrack += changes;
								}
							}
#line 356
							i++;
						}
#line 374
						tryptr[0] = (struct changrdbox *)gdptr->nnextgrd;
#line 375
						if (((tryptr[0])->netptr)->xpos == x) {
#line 376
							t = 0;
#line 376
							tryFlag[t] = 0;
#line 377
							while (1) {
#line 377
								if ((unsigned int)(tryptr[t])->nnextgrd != (unsigned int)((void *)0)) {
#line 377
									if (!((((tryptr[t])->nnextgrd)->netptr)->xpos == ((tryptr[0])->netptr)->xpos)) {
#line 377
										break;
									}
								}
								else {
#line 377
									break;
								}
#line 380
								t++;
#line 381
								tryptr[t] = (struct changrdbox *)(tryptr[t - 1])->nnextgrd;
#line 382
								tryFlag[t] = 0;
							}
#line 384
							i = 0;
#line 384
							while (i <= t) {
#line 385
								if (tryFlag[i] == 0) {
#line 386
									changes = 0;
#line 387
									trynet = (*(tearray + ((tryptr[i])->netptr)->terminal))->net;
#line 389
									changes += (tryptr[i])->nSegType;
#line 390
									j = i + 1;
#line 390
									while (j <= t) {
#line 391
										if ((*(tearray + ((tryptr[j])->netptr)->terminal))->net == trynet) {
#line 393
											tryFlag[j] = 1;
#line 394
											changes += (tryptr[j])->nSegType;
										}
#line 390
										j++;
									}
#line 397
									if (changes > 0) {
#line 398
										dtrack += changes;
									}
								}
#line 384
								i++;
							}
						}
					}
#line 405
					gdptr->ntracks = (gdptr->nprevgrd)->ntracks + dtrack;
#line 406
					track = gdptr->ntracks;
#line 408
					headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 409
					if ((unsigned int)headptr != (unsigned int)((void *)0)) {
#line 410
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 411
						denptr->nnext = headptr;
#line 412
						headptr->nback = denptr;
#line 413
						denptr->nback = *(*(DboxHead + channel) + track);
					}
					else {
#line 415
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 416
						denptr->nnext = (struct densitybox *)((void *)0);
#line 417
						denptr->nback = *(*(DboxHead + channel) + track);
					}
				}
#line 335
				gdptr = (struct changrdbox *)gdptr->nnextgrd;
			}
		}
#line 422
		if (uneven_cell_height) {
#line 423
			if ((unsigned int)ULgrdptr != (unsigned int)((void *)0)) {
#line 424
				channel = up_channel;
#line 425
				gdptr = (struct changrdbox *)ULgrdptr;
#line 425
				while ((unsigned int)gdptr != (unsigned int)URgrdptr) {
#line 427
					netptr = gdptr->netptr;
#line 428
					pinloc = (int)netptr->pinloc;
#line 429
					if (pinloc == 1) {
#line 430
						self_reset = ((*(carray + netptr->cell))->tileptr)->top;
					}
					else {
#line 431
						if (pinloc == -1) {
#line 432
							self_reset = -((*(carray + netptr->cell))->tileptr)->bottom;
						}
						else {
#line 434
							self_reset = 0;
						}
					}
#line 436
					tmp___1 = facing_cellheight(netptr->terminal, netptr->row, pinloc, 1);
#line 436
					gdptr->ntracks += (self_reset + tmp___1) / track_spacing;
#line 439
					denptr = gdptr->dptr;
#line 440
					if ((unsigned int)denptr->nnext != (unsigned int)((void *)0)) {
#line 441
						(denptr->nnext)->nback = denptr->nback;
					}
#line 443
					(denptr->nback)->nnext = denptr->nnext;
#line 444
					track = gdptr->ntracks;
#line 446
					headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 447
					if ((unsigned int)headptr != (unsigned int)((void *)0)) {
#line 448
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 449
						denptr->nnext = headptr;
#line 450
						headptr->nback = denptr;
#line 451
						denptr->nback = *(*(DboxHead + channel) + track);
					}
					else {
#line 453
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 454
						denptr->nnext = (struct densitybox *)((void *)0);
#line 455
						denptr->nback = *(*(DboxHead + channel) + track);
					}
#line 425
					gdptr = (struct changrdbox *)gdptr->nnextgrd;
				}
			}
#line 459
			if ((unsigned int)LLgrdptr != (unsigned int)((void *)0)) {
#line 460
				channel = up_channel - 1;
#line 461
				gdptr = (struct changrdbox *)LLgrdptr;
#line 461
				while ((unsigned int)gdptr != (unsigned int)LRgrdptr) {
#line 463
					netptr = gdptr->netptr;
#line 464
					pinloc = (int)netptr->pinloc;
#line 465
					if (pinloc == 1) {
#line 466
						self_reset = ((*(carray + netptr->cell))->tileptr)->top;
					}
					else {
#line 467
						if (pinloc == -1) {
#line 468
							self_reset = -((*(carray + netptr->cell))->tileptr)->bottom;
						}
						else {
#line 470
							self_reset = 0;
						}
					}
#line 472
					tmp___2 = facing_cellheight(netptr->terminal, netptr->row, pinloc, 1);
#line 472
					gdptr->ntracks += (self_reset + tmp___2) / track_spacing;
#line 475
					denptr = gdptr->dptr;
#line 476
					if ((unsigned int)denptr->nnext != (unsigned int)((void *)0)) {
#line 477
						(denptr->nnext)->nback = denptr->nback;
					}
#line 479
					(denptr->nback)->nnext = denptr->nnext;
#line 480
					track = gdptr->ntracks;
#line 482
					headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 483
					if ((unsigned int)headptr != (unsigned int)((void *)0)) {
#line 484
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 485
						denptr->nnext = headptr;
#line 486
						headptr->nback = denptr;
#line 487
						denptr->nback = *(*(DboxHead + channel) + track);
					}
					else {
#line 489
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 490
						denptr->nnext = (struct densitybox *)((void *)0);
#line 491
						denptr->nback = *(*(DboxHead + channel) + track);
					}
#line 461
					gdptr = (struct changrdbox *)gdptr->nnextgrd;
				}
			}
		}
#line 497
		index___0 = 1;
#line 497
		while (index___0 <= *(netchgs + 0)) {
#line 498
			net = *(netchgs + index___0);
#line 499
			b___0 = *(anet + net);
#line 500
			e = *(anet + (net + 1)) - 1;
#line 501
			segment = b___0;
#line 501
			while (segment <= e) {
#line 502
				if ((int)(aNetSeg + segment)->ncurrent == 0) {
#line 503
					segptr = (aNetSeg + segment)->ntop;
				}
				else {
#line 505
					segptr = (aNetSeg + segment)->nbot;
				}
#line 507
				pin1 = segptr->pin1;
#line 508
				pin2 = segptr->pin2;
#line 509
				if (pin1 > maxterm) {
#line 509
					if (pin2 > maxterm) {
						goto __Cont___0;
					}
				}
#line 512
				ptr1 = segptr->pin1ptr;
#line 513
				ptr2 = segptr->pin2ptr;
#line 514
				x1 = (ptr1->netptr)->xpos;
#line 515
				x2 = (ptr2->netptr)->xpos;
#line 516
				if (x1 == x2) {
					goto __Cont___0;
				}
#line 519
				channel = segptr->channel;
#line 520
				if (channel > gtopChan) {
#line 521
					gtopChan = channel;
				}
#line 523
				if (channel < gbotChan) {
#line 524
					gbotChan = channel;
				}
#line 526
				net = (aNetSeg + segment)->net;
#line 527
				if (ptr1->nSegType >= 0) {
#line 528
					Flag = 0;
#line 529
					bptr = ptr1;
#line 530
					while (1) {
#line 530
						if ((unsigned int)bptr->nprevgrd != (unsigned int)((void *)0)) {
#line 530
							if (!(((bptr->nprevgrd)->netptr)->xpos == x1)) {
#line 530
								break;
							}
						}
						else {
#line 530
							break;
						}
#line 532
						if ((*(tearray + ((bptr->nprevgrd)->netptr)->terminal))->net == net) {
#line 532
							if ((bptr->nprevgrd)->nSegType < 0) {
#line 534
								Flag = 1;
#line 535
								sptr = (struct changrdbox *)ptr1->nnextgrd;
#line 536
								while ((sptr->netptr)->xpos == x1) {
#line 537
									sptr = (struct changrdbox *)sptr->nnextgrd;
								}
#line 539
								break;
							}
							else {
#line 541
								bptr = (struct changrdbox *)bptr->nprevgrd;
							}
						}
						else {
#line 541
							bptr = (struct changrdbox *)bptr->nprevgrd;
						}
					}
#line 544
					if (!Flag) {
#line 545
						sptr = (struct changrdbox *)ptr1->nnextgrd;
#line 546
						while ((sptr->netptr)->xpos == x1) {
#line 547
							if (net == (*(tearray + (sptr->netptr)->terminal))->net) {
#line 547
								if (sptr->nSegType < 0) {
#line 549
									Flag = 1;
								}
							}
#line 551
							sptr = (struct changrdbox *)sptr->nnextgrd;
						}
					}
#line 554
					if (!Flag) {
#line 555
						sptr = bptr;
					}
				}
				else {
#line 558
					sptr = (struct changrdbox *)ptr1->nnextgrd;
#line 559
					while ((sptr->netptr)->xpos == x1) {
#line 560
						sptr = (struct changrdbox *)sptr->nnextgrd;
					}
				}
#line 564
				if (ptr2->nSegType <= 0) {
#line 565
					Flag = 0;
#line 566
					fptr = ptr2;
#line 567
					while (1) {
#line 567
						if ((unsigned int)fptr->nnextgrd != (unsigned int)((void *)0)) {
#line 567
							if (!(((fptr->nnextgrd)->netptr)->xpos == x2)) {
#line 567
								break;
							}
						}
						else {
#line 567
							break;
						}
#line 569
						if ((*(tearray + ((fptr->nnextgrd)->netptr)->terminal))->net == net) {
#line 569
							if ((fptr->nnextgrd)->nSegType > 0) {
#line 571
								Flag = 1;
#line 572
								eptr = (struct changrdbox *)ptr2->nprevgrd;
#line 573
								while ((eptr->netptr)->xpos == x2) {
#line 574
									eptr = (struct changrdbox *)eptr->nprevgrd;
								}
#line 576
								break;
							}
							else {
#line 578
								fptr = (struct changrdbox *)fptr->nnextgrd;
							}
						}
						else {
#line 578
							fptr = (struct changrdbox *)fptr->nnextgrd;
						}
					}
#line 581
					if (!Flag) {
#line 582
						eptr = (struct changrdbox *)ptr2->nprevgrd;
#line 583
						while ((eptr->netptr)->xpos == x2) {
#line 584
							if (net == (*(tearray + (eptr->netptr)->terminal))->net) {
#line 584
								if (eptr->nSegType > 0) {
#line 586
									Flag = 1;
								}
							}
#line 588
							eptr = (struct changrdbox *)eptr->nprevgrd;
						}
					}
#line 591
					if (!Flag) {
#line 592
						eptr = fptr;
					}
				}
				else {
#line 595
					eptr = (struct changrdbox *)ptr2->nprevgrd;
#line 596
					while ((eptr->netptr)->xpos == x2) {
#line 597
						eptr = (struct changrdbox *)eptr->nprevgrd;
					}
				}
#line 600
				eptr = (struct changrdbox *)eptr->nnextgrd;
#line 601
				if (pin1 <= maxterm) {
#line 602
					(ptr1->nSegType)++;
				}
#line 604
				if (pin2 <= maxterm) {
#line 605
					(ptr2->nSegType)--;
				}
#line 608
				ptr = sptr;
#line 608
				while ((unsigned int)ptr != (unsigned int)eptr) {
#line 609
					denptr = ptr->dptr;
#line 610
					if ((unsigned int)denptr->nnext != (unsigned int)((void *)0)) {
#line 611
						(denptr->nnext)->nback = denptr->nback;
					}
#line 613
					(denptr->nback)->nnext = denptr->nnext;
#line 614
					(ptr->ntracks)++;
#line 614
					track = ptr->ntracks;
#line 616
					headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 617
					if ((unsigned int)headptr != (unsigned int)((void *)0)) {
#line 618
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 619
						denptr->nnext = headptr;
#line 620
						headptr->nback = denptr;
#line 621
						denptr->nback = *(*(DboxHead + channel) + track);
					}
					else {
#line 623
						(*(*(DboxHead + channel) + track))->nnext = denptr;
#line 624
						denptr->nnext = (struct densitybox *)((void *)0);
#line 625
						denptr->nback = *(*(DboxHead + channel) + track);
					}
#line 608
					ptr = (struct changrdbox *)ptr->nnextgrd;
				}
			__Cont___0: /* CIL Label */
#line 501
				segment++;
			}
#line 497
			index___0++;
		}
#line 631
		chan = 1;
#line 631
		while (chan <= numChans) {
#line 632
			track = max_tdensity + 30;
#line 632
			while (track >= 0) {
#line 633
				if ((unsigned int)(*(*(DboxHead + chan) + track))->nnext != (unsigned int)((void *)0)) {
#line 634
					break;
				}
#line 632
				track--;
			}
#line 637
			* (nmaxTrack + chan) = track;
#line 638
			tracks += track;
#line 631
			chan++;
		}
#line 640
		return;
	}
}
#line 1 "unlap.o"
#pragma merger(0,"./unlap.i","")
#line 4 "unlap.c"
int first_time_in_unlap = 1;
#line 8 "unlap.c"
int noPairs;
#line 164
void xcompact(void);
#line 10 "unlap.c"
void unlap(int flag)
{
	CBOXPTR cellptr___0;
	int *num;
	int i;
	int cell_count;
	int space___0;
	int cell___0;
	int block___0;
	int cell_left;
	int left_edge;
	int right_edge;
	int fixed;
	int unfixed;
	int *left_queue;
	int *right_queue;
	int *center_queue;
	int max_cell_in_blk;
	int min_right_fixed_cell;
	int max_left_fixed_cell;
	int pair_array_index;
	int total_cells;
	char *tmp;
	char *tmp___0;
	char *tmp___1;
	char *tmp___2;
	char *tmp___3;
	char *tmp___4;
	int tmp___5;

	{
#line 24
		tmp = safe_malloc((unsigned int)(numblock + 1) * sizeof(int));
#line 24
		num = (int *)tmp;
#line 25
		block___0 = 0;
#line 25
		while (block___0 <= numblock) {
#line 26
			* (num + block___0) = 0;
#line 25
			block___0++;
		}
#line 29
		if (flag == -2) {
#line 30
			total_cells = numcells + ffeeds;
		}
		else {
#line 32
			total_cells = numcells;
		}
#line 35
		cell___0 = 1;
#line 35
		while (cell___0 <= total_cells) {
#line 36
			(*(num + (*(carray + cell___0))->cblock))++;
#line 35
			cell___0++;
		}
#line 39
		if (!first_time_in_unlap) {
#line 40
			block___0 = 1;
#line 40
			while (block___0 <= numblock) {
#line 41
				safe_free(*(pairArray + block___0));
#line 40
				block___0++;
			}
#line 43
			safe_free(pairArray);
		}
		else {
#line 45
			first_time_in_unlap = 0;
		}
#line 48
		tmp___0 = safe_malloc((unsigned int)(numblock + 1) * sizeof(int *));
#line 48
		pairArray = (int **)tmp___0;
#line 50
		max_cell_in_blk = 0;
#line 51
		block___0 = 1;
#line 51
		while (block___0 <= numblock) {
#line 52
			tmp___1 = safe_malloc((unsigned int)(*(num + block___0) + 1) * sizeof(int));
#line 52
			* (pairArray + block___0) = (int *)tmp___1;
#line 53
			* (*(pairArray + block___0) + 0) = *(num + block___0);
#line 55
			if (*(num + block___0) > max_cell_in_blk) {
#line 56
				max_cell_in_blk = *(num + block___0);
			}
#line 51
			block___0++;
		}
#line 59
		tmp___2 = safe_malloc((unsigned int)(max_cell_in_blk + 1) * sizeof(int));
#line 59
		left_queue = (int *)tmp___2;
#line 60
		tmp___3 = safe_malloc((unsigned int)(max_cell_in_blk + 1) * sizeof(int));
#line 60
		right_queue = (int *)tmp___3;
#line 61
		tmp___4 = safe_malloc((unsigned int)(max_cell_in_blk + 1) * sizeof(int));
#line 61
		center_queue = (int *)tmp___4;
#line 63
		cell___0 = 1;
#line 63
		while (cell___0 <= total_cells) {
#line 64
			block___0 = (*(carray + cell___0))->cblock;
#line 65
			tmp___5 = *(num + block___0);
#line 65
			(*(num + block___0))--;
#line 65
			* (*(pairArray + block___0) + tmp___5) = cell___0;
#line 63
			cell___0++;
		}
#line 67
		block___0 = 1;
#line 67
		while (block___0 <= numblock) {
#line 68
			qsortx((char *)(*(pairArray + block___0) + 1), *(*(pairArray + block___0) + 0),
				sizeof(int));
#line 67
			block___0++;
		}
#line 74
		block___0 = 1;
#line 74
		while (block___0 <= numblock) {
#line 75
			left_edge = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bleft;
#line 76
			right_edge = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bright;
#line 77
			cell_count = *(*(pairArray + block___0) + 0);
#line 77
			if (cell_count > 1) {
#line 78
				noPairs = 0;
			}
#line 80
			fixed = 0;
#line 81
			unfixed = 0;
#line 83
			i = 1;
#line 83
			while (i <= cell_count) {
#line 84
				if ((*(carray + *(*(pairArray + block___0) + i)))->cclass == -1) {
#line 85
					fixed = 1;
				}
				else {
#line 87
					unfixed = 1;
				}
#line 83
				i++;
			}
#line 90
			if (fixed == 1) {
#line 90
				if (unfixed == 1) {
#line 91
					i = 0;
#line 91
					while (i <= max_cell_in_blk) {
#line 92
						* (left_queue + i) = 0;
#line 93
						* (right_queue + i) = 0;
#line 94
						* (center_queue + i) = 0;
#line 91
						i++;
					}
#line 96
					max_left_fixed_cell = 0;
#line 97
					i = 1;
#line 97
					while (i <= cell_count) {
#line 98
						cellptr___0 = *(carray + *(*(pairArray + block___0) + i));
#line 99
						if (cellptr___0->cclass == -1) {
#line 100
							if (left_edge == cellptr___0->cxcenter + (cellptr___0->tileptr)->left) {
#line 102
								left_edge += cellptr___0->clength;
#line 103
								(*left_queue)++;
#line 103
								* (left_queue + *left_queue) = *(*(pairArray + block___0) + i);
#line 104
								max_left_fixed_cell = i;
							}
							else {
#line 106
								break;
							}
						}
#line 97
						i++;
					}
#line 110
					min_right_fixed_cell = cell_count + 1;
#line 111
					i = cell_count;
#line 111
					while (i >= 1) {
#line 112
						cellptr___0 = *(carray + *(*(pairArray + block___0) + i));
#line 113
						if (cellptr___0->cclass == -1) {
#line 114
							if (right_edge == cellptr___0->cxcenter + (cellptr___0->tileptr)->right) {
#line 116
								right_edge -= cellptr___0->clength;
#line 117
								(*right_queue)++;
#line 117
								* (right_queue + *right_queue) = *(*(pairArray + block___0) + i);
#line 118
								min_right_fixed_cell = i;
							}
							else {
#line 120
								break;
							}
						}
#line 111
						i--;
					}
#line 124
					i = 1;
#line 124
					while (i <= cell_count) {
#line 125
						cellptr___0 = *(carray + *(*(pairArray + block___0) + i));
#line 126
						if (cellptr___0->cclass != -1) {
#line 130
							(*center_queue)++;
#line 130
							* (center_queue + *center_queue) = *(*(pairArray + block___0) + i);
						}
						else {
#line 126
							if (cellptr___0->cclass == -1) {
#line 126
								if (i > max_left_fixed_cell) {
#line 126
									if (i < min_right_fixed_cell) {
#line 130
										(*center_queue)++;
#line 130
										* (center_queue + *center_queue) = *(*(pairArray + block___0) + i);
									}
								}
							}
						}
#line 124
						i++;
					}
#line 133
					pair_array_index = 0;
#line 134
					i = 1;
#line 134
					while (i <= *left_queue) {
#line 135
						pair_array_index++;
#line 135
						* (*(pairArray + block___0) + pair_array_index) = *(left_queue + i);
#line 134
						i++;
					}
#line 137
					i = 1;
#line 137
					while (i <= *center_queue) {
#line 138
						pair_array_index++;
#line 138
						* (*(pairArray + block___0) + pair_array_index) = *(center_queue + i);
#line 137
						i++;
					}
#line 140
					i = *right_queue;
#line 140
					while (i >= 1) {
#line 141
						pair_array_index++;
#line 141
						* (*(pairArray + block___0) + pair_array_index) = *(right_queue + i);
#line 140
						i--;
					}
				}
			}
#line 144
			left_edge = (*(barray + block___0))->bxcenter + (*(barray + block___0))->bleft;
#line 145
			if (flag == 1) {
#line 146
				space___0 = (int)((float)(*(feeds_in_row + block___0) * binWidth) / (float)(cell_count - 1));
			}
			else {
#line 149
				space___0 = 0;
			}
#line 151
			i = 1;
#line 151
			while (i <= cell_count) {
#line 152
				cellptr___0 = *(carray + *(*(pairArray + block___0) + i));
#line 153
				cell_left = (cellptr___0->tileptr)->left;
#line 154
				cellptr___0->cxcenter = left_edge - cell_left;
#line 155
				left_edge += ((cellptr___0->tileptr)->right - cell_left) + space___0;
#line 151
				i++;
			}
#line 74
			block___0++;
		}
#line 158
		safe_free(num);
#line 159
		safe_free(left_queue);
#line 160
		safe_free(right_queue);
#line 161
		safe_free(center_queue);
#line 163
		if (flag >= 0) {
#line 164
			xcompact();
		}
#line 167
		return;
	}
}
#line 1 "upair.o"
#pragma merger(0,"./upair.i","")
#line 9 "upair.c"
int upair(void)
{
	CBOXPTR acellptr___0;
	CBOXPTR bcellptr___0;
	BBOXPTR ablckptr;
	int a___0;
	int b___0;
	int ablock___0;
	int aorient;
	int flips;
	int attempts___0;
	int axcenter___0;
	int anxcenter___0;
	int bnxcenter___0;
	int aleft___0;
	int aright___0;
	int startx1;
	int endx1;
	int cellleft;
	int cellrite;
	int leftEdge;
	int riteEdge;
	int aptr;
	int tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;
	int tmp___3;
	int tmp___4;
	int tmp___5;
	int tmp___6;
	int tmp___7;

	{
#line 23
		flips = 0;
#line 24
		attempts___0 = 0;
#line 26
		while (attempts___0 < attmax) {
#line 27
			ablock___0 = PICK_INT(1, numblock);
#line 28
			if (*(*(pairArray + ablock___0) + 0) <= 1) {
#line 29
				continue;
			}
#line 31
			aptr = PICK_INT(1, *(*(pairArray + ablock___0) + 0));
#line 33
			a___0 = *(*(pairArray + ablock___0) + aptr);
#line 34
			acellptr___0 = *(carray + a___0);
#line 35
			if (acellptr___0->cclass == -1) {
#line 36
				continue;
			}
#line 38
			aorient = (int)acellptr___0->corient;
#line 40
			ablckptr = *(barray + ablock___0);
#line 41
			axcenter___0 = acellptr___0->cxcenter;
#line 43
			aleft___0 = (acellptr___0->tileptr)->left;
#line 44
			aright___0 = (acellptr___0->tileptr)->right;
#line 45
			startx1 = axcenter___0 + aleft___0;
#line 46
			endx1 = axcenter___0 + aright___0;
#line 47
			if (aptr > 1) {
#line 48
				cellleft = *(*(pairArray + ablock___0) + (aptr - 1));
#line 49
				if ((*(carray + cellleft))->cclass == -1) {
#line 50
					cellleft = 0;
				}
			}
			else {
#line 53
				cellleft = 0;
			}
#line 55
			if (aptr < *(*(pairArray + ablock___0) + 0)) {
#line 56
				cellrite = *(*(pairArray + ablock___0) + (aptr + 1));
#line 57
				if ((*(carray + cellrite))->cclass == -1) {
#line 58
					cellrite = 0;
				}
			}
			else {
#line 61
				cellrite = 0;
			}
#line 63
			if (cellleft == 0) {
#line 63
				if (cellrite == 0) {
#line 64
					continue;
				}
			}
#line 67
			if (cellleft != 0) {
#line 67
				if (cellrite != 0) {
#line 68
					tmp___3 = PICK_INT(1, 2);
#line 68
					if (tmp___3 == 1) {
#line 72
						b___0 = cellleft;
#line 73
						bcellptr___0 = *(carray + b___0);
#line 74
						leftEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->left;
#line 75
						anxcenter___0 = leftEdge - aleft___0;
#line 76
						bnxcenter___0 = endx1 - (bcellptr___0->tileptr)->right;
#line 77
						tmp___0 = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 77
						if (tmp___0) {
#line 78
							flips++;
#line 79
							attempts___0++;
#line 80
							* (*(pairArray + ablock___0) + aptr) = b___0;
#line 81
							* (*(pairArray + ablock___0) + (aptr - 1)) = a___0;
						}
						else {
#line 83
							attempts___0++;
#line 84
							b___0 = cellrite;
#line 85
							bcellptr___0 = *(carray + b___0);
#line 86
							riteEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->right;
#line 88
							anxcenter___0 = riteEdge - aright___0;
#line 89
							bnxcenter___0 = startx1 - (bcellptr___0->tileptr)->left;
#line 90
							tmp = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 90
							if (tmp) {
#line 91
								flips++;
#line 92
								* (*(pairArray + ablock___0) + aptr) = b___0;
#line 93
								* (*(pairArray + ablock___0) + (aptr + 1)) = a___0;
							}
#line 95
							attempts___0++;
						}
					}
					else {
#line 98
						b___0 = cellrite;
#line 99
						bcellptr___0 = *(carray + b___0);
#line 100
						riteEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->right;
#line 101
						anxcenter___0 = riteEdge - aright___0;
#line 102
						bnxcenter___0 = startx1 - (bcellptr___0->tileptr)->left;
#line 103
						tmp___2 = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 103
						if (tmp___2) {
#line 104
							flips++;
#line 105
							attempts___0++;
#line 106
							* (*(pairArray + ablock___0) + aptr) = b___0;
#line 107
							* (*(pairArray + ablock___0) + (aptr + 1)) = a___0;
						}
						else {
#line 109
							attempts___0++;
#line 110
							b___0 = cellleft;
#line 111
							bcellptr___0 = *(carray + b___0);
#line 112
							leftEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->left;
#line 113
							anxcenter___0 = leftEdge - aleft___0;
#line 114
							bnxcenter___0 = endx1 - (bcellptr___0->tileptr)->right;
#line 115
							tmp___1 = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 115
							if (tmp___1) {
#line 116
								flips++;
#line 117
								* (*(pairArray + ablock___0) + aptr) = b___0;
#line 118
								* (*(pairArray + ablock___0) + (aptr - 1)) = a___0;
							}
#line 120
							attempts___0++;
						}
					}
				}
				else {
					goto _L;
				}
			}
			else {
			_L: /* CIL Label */
#line 124
				if (cellleft) {
#line 125
					b___0 = cellleft;
#line 126
					bcellptr___0 = *(carray + b___0);
#line 127
					leftEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->left;
#line 128
					anxcenter___0 = leftEdge - aleft___0;
#line 129
					bnxcenter___0 = endx1 - (bcellptr___0->tileptr)->right;
#line 130
					tmp___4 = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 130
					if (tmp___4) {
#line 131
						flips++;
#line 132
						* (*(pairArray + ablock___0) + aptr) = b___0;
#line 133
						* (*(pairArray + ablock___0) + (aptr - 1)) = a___0;
					}
#line 135
					attempts___0++;
				}
				else {
#line 136
					if (cellrite != 0) {
#line 136
						if ((*(carray + cellrite))->cclass != -1) {
#line 136
							if (acellptr___0->cclass != -1) {
#line 139
								b___0 = cellrite;
#line 140
								bcellptr___0 = *(carray + b___0);
#line 141
								riteEdge = bcellptr___0->cxcenter + (bcellptr___0->tileptr)->right;
#line 142
								anxcenter___0 = riteEdge - aright___0;
#line 143
								bnxcenter___0 = startx1 - (bcellptr___0->tileptr)->left;
#line 144
								tmp___5 = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 144
								if (tmp___5) {
#line 145
									flips++;
#line 146
									* (*(pairArray + ablock___0) + aptr) = b___0;
#line 147
									* (*(pairArray + ablock___0) + (aptr + 1)) = a___0;
								}
#line 149
								attempts___0++;
							}
						}
					}
				}
			}
#line 152
			if (ablckptr->borient == 1) {
#line 153
				if ((int)acellptr___0->orflag != 0) {
#line 154
					if (aorient == 0) {
#line 154
						tmp___6 = 2;
					}
					else {
#line 154
						tmp___6 = 0;
					}
#line 154
					uc0(a___0, tmp___6);
				}
			}
			else {
#line 157
				if ((int)acellptr___0->orflag != 0) {
#line 158
					if (aorient == 1) {
#line 158
						tmp___7 = 3;
					}
					else {
#line 158
						tmp___7 = 1;
					}
#line 158
					uc0(a___0, tmp___7);
				}
			}
		}
#line 162
		fprintf(fpo, " %3d %6.3f %9d  %3d%s\n", iteration + 1, T, funccost, (int)((100.0 * (double)((float)flips)) / (double)((float)attmax)),
			"%");
#line 164
		fflush(fpo);
#line 165
		return;
	}
}
#line 1 "urcost.o"
#pragma merger(0,"./urcost.i","")
#line 4 "urcost.c"
int urcost(int segment)
{
	SEGBOXPTR asegptr;
	SEGBOXPTR bsegptr;
	CHANGRDPTR aptr1;
	CHANGRDPTR aptr2;
	CHANGRDPTR bptr1;
	CHANGRDPTR bptr2;
	CHANGRDPTR bptr;
	CHANGRDPTR fptr;
	CHANGRDPTR ptr;
	CHANGRDPTR saptr;
	CHANGRDPTR eaptr;
	CHANGRDPTR sbptr;
	CHANGRDPTR ebptr;
	DENSITYPTR denptr;
	DENSITYPTR headptr;
	int penalty___0;
	int check;
	int x;
	int achannel;
	int bchannel;
	int aMaxVal;
	int bMaxVal;
	int maxaa;
	int maxbb;
	int aoutside;
	int binside;
	int ax1;
	int ax2;
	int bx1;
	int bx2;
	int net;
	int Flag;
	int track;

	{
#line 18
		penalty___0 = 0;
#line 19
		net = (aNetSeg + segment)->net;
#line 20
		if ((int)(aNetSeg + segment)->current == 0) {
#line 21
			asegptr = (aNetSeg + segment)->top;
#line 22
			bsegptr = (aNetSeg + segment)->bot;
		}
		else {
#line 24
			asegptr = (aNetSeg + segment)->bot;
#line 25
			bsegptr = (aNetSeg + segment)->top;
		}
#line 27
		achannel = asegptr->channel;
#line 28
		bchannel = bsegptr->channel;
#line 29
		aptr1 = asegptr->pin1ptr;
#line 30
		aptr2 = asegptr->pin2ptr;
#line 31
		bptr1 = bsegptr->pin1ptr;
#line 32
		bptr2 = bsegptr->pin2ptr;
#line 34
		aMaxVal = *(maxTrack + achannel);
#line 35
		bMaxVal = *(maxTrack + bchannel);
#line 36
		ax1 = (aptr1->netptr)->xpos;
#line 37
		ax2 = (aptr2->netptr)->xpos;
#line 38
		bx1 = (bptr1->netptr)->xpos;
#line 39
		bx2 = (bptr2->netptr)->xpos;
#line 40
		net = (aNetSeg + segment)->net;
#line 41
		if (aptr1->SegType > 0) {
#line 42
			Flag = 0;
#line 43
			bptr = aptr1;
#line 44
			while (1) {
#line 44
				if ((unsigned int)bptr->prevgrd != (unsigned int)((void *)0)) {
#line 44
					if (!(((bptr->prevgrd)->netptr)->xpos == ax1)) {
#line 44
						break;
					}
				}
				else {
#line 44
					break;
				}
#line 46
				if (net == (*(tearray + ((bptr->prevgrd)->netptr)->terminal))->net) {
#line 46
					if ((bptr->prevgrd)->SegType < 0) {
#line 48
						Flag = 1;
#line 49
						saptr = (struct changrdbox *)aptr1->nextgrd;
#line 50
						while ((saptr->netptr)->xpos == ax1) {
#line 51
							saptr = (struct changrdbox *)saptr->nextgrd;
						}
#line 53
						break;
					}
					else {
#line 55
						bptr = (struct changrdbox *)bptr->prevgrd;
					}
				}
				else {
#line 55
					bptr = (struct changrdbox *)bptr->prevgrd;
				}
			}
#line 58
			if (!Flag) {
#line 59
				saptr = (struct changrdbox *)aptr1->nextgrd;
#line 60
				while ((saptr->netptr)->xpos == ax1) {
#line 61
					if (net == (*(tearray + (saptr->netptr)->terminal))->net) {
#line 61
						if (saptr->SegType < 0) {
#line 63
							Flag = 1;
						}
					}
#line 65
					saptr = (struct changrdbox *)saptr->nextgrd;
				}
			}
#line 68
			if (!Flag) {
#line 69
				saptr = bptr;
			}
		}
		else {
#line 72
			if (ax1 != gxstart) {
#line 73
				saptr = (struct changrdbox *)aptr1->nextgrd;
#line 74
				while ((saptr->netptr)->xpos == ax1) {
#line 75
					saptr = (struct changrdbox *)saptr->nextgrd;
				}
			}
			else {
#line 78
				saptr = aptr1;
			}
		}
#line 82
		if (aptr2->SegType < 0) {
#line 83
			Flag = 0;
#line 84
			fptr = aptr2;
#line 85
			while (1) {
#line 85
				if ((unsigned int)fptr->nextgrd != (unsigned int)((void *)0)) {
#line 85
					if (!(((fptr->nextgrd)->netptr)->xpos == ax2)) {
#line 85
						break;
					}
				}
				else {
#line 85
					break;
				}
#line 87
				if (net == (*(tearray + ((fptr->nextgrd)->netptr)->terminal))->net) {
#line 87
					if ((fptr->nextgrd)->SegType > 0) {
#line 89
						Flag = 1;
#line 90
						eaptr = (struct changrdbox *)aptr2->prevgrd;
#line 91
						while ((eaptr->netptr)->xpos == ax2) {
#line 92
							eaptr = (struct changrdbox *)eaptr->prevgrd;
						}
#line 94
						break;
					}
					else {
#line 96
						fptr = (struct changrdbox *)fptr->nextgrd;
					}
				}
				else {
#line 96
					fptr = (struct changrdbox *)fptr->nextgrd;
				}
			}
#line 99
			if (!Flag) {
#line 100
				eaptr = (struct changrdbox *)aptr2->prevgrd;
#line 101
				while ((eaptr->netptr)->xpos == ax2) {
#line 102
					if (net == (*(tearray + (eaptr->netptr)->terminal))->net) {
#line 102
						if (eaptr->SegType > 0) {
#line 104
							Flag = 1;
						}
					}
#line 106
					eaptr = (struct changrdbox *)eaptr->prevgrd;
				}
			}
#line 109
			if (!Flag) {
#line 110
				eaptr = fptr;
			}
		}
		else {
#line 113
			if (ax2 != gxstop) {
#line 114
				eaptr = (struct changrdbox *)aptr2->prevgrd;
#line 115
				while ((eaptr->netptr)->xpos == ax2) {
#line 116
					eaptr = (struct changrdbox *)eaptr->prevgrd;
				}
			}
			else {
#line 119
				eaptr = aptr2;
			}
		}
#line 123
		if (bptr1->SegType >= 0) {
#line 124
			Flag = 0;
#line 125
			bptr = bptr1;
#line 126
			while (1) {
#line 126
				if ((unsigned int)bptr->prevgrd != (unsigned int)((void *)0)) {
#line 126
					if (!(((bptr->prevgrd)->netptr)->xpos == bx1)) {
#line 126
						break;
					}
				}
				else {
#line 126
					break;
				}
#line 128
				if (net == (*(tearray + ((bptr->prevgrd)->netptr)->terminal))->net) {
#line 128
					if ((bptr->prevgrd)->SegType < 0) {
#line 130
						Flag = 1;
#line 131
						sbptr = (struct changrdbox *)bptr1->nextgrd;
#line 132
						while ((sbptr->netptr)->xpos == bx1) {
#line 133
							sbptr = (struct changrdbox *)sbptr->nextgrd;
						}
#line 135
						break;
					}
					else {
#line 137
						bptr = (struct changrdbox *)bptr->prevgrd;
					}
				}
				else {
#line 137
					bptr = (struct changrdbox *)bptr->prevgrd;
				}
			}
#line 140
			if (!Flag) {
#line 141
				sbptr = (struct changrdbox *)bptr1->nextgrd;
#line 142
				while ((sbptr->netptr)->xpos == bx1) {
#line 143
					if (net == (*(tearray + (sbptr->netptr)->terminal))->net) {
#line 143
						if (sbptr->SegType < 0) {
#line 145
							Flag = 1;
						}
					}
#line 147
					sbptr = (struct changrdbox *)sbptr->nextgrd;
				}
			}
#line 150
			if (!Flag) {
#line 151
				sbptr = bptr;
			}
		}
		else {
#line 154
			sbptr = (struct changrdbox *)bptr1->nextgrd;
#line 155
			while ((sbptr->netptr)->xpos == bx1) {
#line 156
				sbptr = (struct changrdbox *)sbptr->nextgrd;
			}
		}
#line 160
		if (bptr2->SegType <= 0) {
#line 161
			Flag = 0;
#line 162
			fptr = bptr2;
#line 163
			while (1) {
#line 163
				if ((unsigned int)fptr->nextgrd != (unsigned int)((void *)0)) {
#line 163
					if (!(((fptr->nextgrd)->netptr)->xpos == bx2)) {
#line 163
						break;
					}
				}
				else {
#line 163
					break;
				}
#line 165
				if (net == (*(tearray + ((fptr->nextgrd)->netptr)->terminal))->net) {
#line 165
					if ((fptr->nextgrd)->SegType > 0) {
#line 167
						Flag = 1;
#line 168
						ebptr = (struct changrdbox *)bptr2->prevgrd;
#line 169
						while ((ebptr->netptr)->xpos == bx2) {
#line 170
							ebptr = (struct changrdbox *)ebptr->prevgrd;
						}
#line 172
						break;
					}
					else {
#line 174
						fptr = (struct changrdbox *)fptr->nextgrd;
					}
				}
				else {
#line 174
					fptr = (struct changrdbox *)fptr->nextgrd;
				}
			}
#line 177
			if (!Flag) {
#line 178
				ebptr = (struct changrdbox *)bptr2->prevgrd;
#line 179
				while ((ebptr->netptr)->xpos == bx2) {
#line 180
					if (net == (*(tearray + (ebptr->netptr)->terminal))->net) {
#line 180
						if (ebptr->SegType > 0) {
#line 182
							Flag = 1;
						}
					}
#line 184
					ebptr = (struct changrdbox *)ebptr->prevgrd;
				}
			}
#line 187
			if (!Flag) {
#line 188
				ebptr = fptr;
			}
		}
		else {
#line 191
			ebptr = (struct changrdbox *)bptr2->prevgrd;
#line 192
			while ((ebptr->netptr)->xpos == bx2) {
#line 193
				ebptr = (struct changrdbox *)ebptr->prevgrd;
			}
		}
#line 197
		aoutside = 0;
#line 198
		ax1 = (saptr->netptr)->xpos;
#line 199
		ax2 = (eaptr->netptr)->xpos;
#line 200
		denptr = (*(*(DboxHead + achannel) + aMaxVal))->next;
#line 201
		while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 202
			x = ((denptr->grdptr)->netptr)->xpos;
#line 203
			if (ax1 <= x) {
#line 203
				if (!(ax2 >= x)) {
#line 204
					aoutside = 1;
#line 205
					break;
				}
			}
			else {
#line 204
				aoutside = 1;
#line 205
				break;
			}
#line 201
			denptr = denptr->next;
		}
#line 208
		if (aoutside == 0) {
#line 209
			penalty___0--;
		}
#line 212
		binside = 0;
#line 213
		bx1 = (sbptr->netptr)->xpos;
#line 214
		bx2 = (ebptr->netptr)->xpos;
#line 215
		denptr = (*(*(DboxHead + bchannel) + bMaxVal))->next;
#line 216
		while ((unsigned int)denptr != (unsigned int)((void *)0)) {
#line 217
			x = ((denptr->grdptr)->netptr)->xpos;
#line 218
			if (bx1 <= x) {
#line 218
				if (bx2 >= x) {
#line 219
					binside = 1;
#line 220
					break;
				}
			}
#line 216
			denptr = denptr->next;
		}
#line 223
		if (binside == 1) {
#line 224
			penalty___0++;
		}
#line 227
		eaptr = (struct changrdbox *)eaptr->nextgrd;
#line 228
		ebptr = (struct changrdbox *)ebptr->nextgrd;
#line 229
		if (penalty___0 == 0) {
#line 230
			if (binside == 1) {
#line 230
				if (aoutside == 0) {
#line 232
					check = (bMaxVal - aMaxVal) + 2;
				}
				else {
					goto _L;
				}
			}
			else {
			_L: /* CIL Label */
#line 234
				maxaa = 0;
#line 235
				maxbb = 0;
#line 236
				ptr = saptr;
#line 236
				while ((unsigned int)ptr != (unsigned int)eaptr) {
#line 237
					if (ptr->tracks > maxaa) {
#line 238
						maxaa = ptr->tracks;
					}
#line 236
					ptr = (struct changrdbox *)ptr->nextgrd;
				}
#line 241
				ptr = sbptr;
#line 241
				while ((unsigned int)ptr != (unsigned int)ebptr) {
#line 242
					if (ptr->tracks > maxbb) {
#line 243
						maxbb = ptr->tracks;
					}
#line 241
					ptr = (struct changrdbox *)ptr->nextgrd;
				}
#line 246
				maxaa = (aMaxVal - maxaa) + 1;
#line 247
				maxbb = (bMaxVal - maxbb) - 1;
#line 248
				check = maxaa - maxbb;
			}
		}
		else {
#line 251
			check = penalty___0;
		}
#line 254
		if (check <= 0) {
#line 255
			if (asegptr->pin1 <= maxterm) {
#line 256
				(aptr1->SegType)--;
			}
#line 258
			if (asegptr->pin2 <= maxterm) {
#line 259
				aptr2->SegType -= -1;
			}
#line 261
			if (bsegptr->pin1 <= maxterm) {
#line 262
				(bptr1->SegType)++;
			}
#line 264
			if (bsegptr->pin2 <= maxterm) {
#line 265
				(bptr2->SegType)--;
			}
#line 267
			ptr = saptr;
#line 267
			while ((unsigned int)ptr != (unsigned int)eaptr) {
#line 268
				denptr = ptr->dptr;
#line 269
				if ((unsigned int)denptr->next != (unsigned int)((void *)0)) {
#line 270
					(denptr->next)->back = denptr->back;
				}
#line 272
				(denptr->back)->next = denptr->next;
#line 273
				(ptr->tracks)--;
#line 273
				track = ptr->tracks;
#line 275
				headptr = (*(*(DboxHead + achannel) + track))->next;
#line 276
				if ((unsigned int)headptr != (unsigned int)((void *)0)) {
#line 277
					(*(*(DboxHead + achannel) + track))->next = denptr;
#line 278
					denptr->next = headptr;
#line 279
					headptr->back = denptr;
#line 280
					denptr->back = *(*(DboxHead + achannel) + track);
				}
				else {
#line 282
					(*(*(DboxHead + achannel) + track))->next = denptr;
#line 283
					denptr->next = (struct densitybox *)((void *)0);
#line 284
					denptr->back = *(*(DboxHead + achannel) + track);
				}
#line 267
				ptr = (struct changrdbox *)ptr->nextgrd;
			}
#line 287
			if (aoutside == 0) {
#line 288
				(*(maxTrack + achannel))--;
			}
#line 290
			ptr = sbptr;
#line 290
			while ((unsigned int)ptr != (unsigned int)ebptr) {
#line 291
				denptr = ptr->dptr;
#line 292
				if ((unsigned int)denptr->next != (unsigned int)((void *)0)) {
#line 293
					(denptr->next)->back = denptr->back;
				}
#line 295
				(denptr->back)->next = denptr->next;
#line 296
				(ptr->tracks)++;
#line 296
				track = ptr->tracks;
#line 298
				headptr = (*(*(DboxHead + bchannel) + track))->next;
#line 299
				if ((unsigned int)headptr != (unsigned int)((void *)0)) {
#line 300
					(*(*(DboxHead + bchannel) + track))->next = denptr;
#line 301
					denptr->next = headptr;
#line 302
					headptr->back = denptr;
#line 303
					denptr->back = *(*(DboxHead + bchannel) + track);
				}
				else {
#line 305
					(*(*(DboxHead + bchannel) + track))->next = denptr;
#line 306
					denptr->next = (struct densitybox *)((void *)0);
#line 307
					denptr->back = *(*(DboxHead + bchannel) + track);
				}
#line 290
				ptr = (struct changrdbox *)ptr->nextgrd;
			}
#line 310
			if (binside == 1) {
#line 311
				(*(maxTrack + bchannel))++;
			}
#line 313
			if ((int)(aNetSeg + segment)->current == 1) {
#line 314
				(aNetSeg + segment)->current = (char)0;
			}
			else {
#line 316
				(aNetSeg + segment)->current = (char)1;
			}
#line 319
			tracks += penalty___0;
#line 320
			return (1);
		}
		else {
#line 322
			return (0);
		}
	}
}
#line 1 "utemp.o"
#pragma merger(0,"./utemp.i","")
#line 96 "/usr/include/math.h"
extern double exp(double);
#line 100
extern double pow(double, double);
#line 17 "utemp.c"
float table1[1024];
#line 17 "utemp.c"
float table2[1024];
#line 17 "utemp.c"
float table3[1024];
#line 33 "utemp.c"
int moveable_cells;
#line 34 "utemp.c"
int fdthrus;
#line 36 "utemp.c"
int syf;
#line 37 "utemp.c"
int SetBin(int x)
{
	int tmp;
	int tmp___0;

	{
#line 38
		Trybin = (x - binOffst) / binWidth;
#line 38
		if (Trybin < 0) {
#line 38
			tmp___0 = 0;
		}
		else {
#line 38
			if (Trybin > numBins) {
#line 38
				tmp = numBins;
			}
			else {
#line 38
				tmp = Trybin;
			}
#line 38
			tmp___0 = tmp;
		}
#line 38
		return (tmp___0);
	}
}
#line 42 "utemp.c"
void utemp(void)
{
	float TloRange;
	float Tfactor;
	int pairtest;
	int check;
	unsigned int i2;
	float **tempfile;
	char filename[64];
	int t;
	int i;
	int row___0;
	int freeze;
	int cell___0;
	int changes;
	FILE *fp;
	double tmp;
	double tmp___0;
	double tmp___1;
	double tmp___2;
	char *tmp___3;
	char *tmp___4;
	struct _reent *tmp___5;

	{
#line 54
		last_level = -1;
#line 56
		if (stage >= 2) {
#line 57
			pairtest = 1;
		}
		else {
#line 60
			pairtest = 0;
		}
#line 62
		initialRowControl = (float)0.0;
#line 63
		finalRowControl = (float)0.0;
#line 64
		check = 0;
#line 65
		freeze = 10000000;
#line 66
		randVar = (int)randomSeed;
#line 67
		fprintf(fpo, "\nThe rand generator seed was at utemp() : %d\n\n\n", randVar);
#line 70
		table1[0] = (float)1.0;
#line 71
		table2[0] = (float)1.0;
#line 72
		table3[0] = (float)1.0;
#line 73
		i2 = 1U;
#line 73
		while (i2 <= 1023U) {
#line 74
			tmp = exp((double)(-((float)i2)) / 8.0);
#line 74
			table1[i2] = (float)tmp;
#line 75
			tmp___0 = exp((double)(-((float)i2)) / 8192.0);
#line 75
			table2[i2] = (float)tmp___0;
#line 76
			tmp___1 = exp((double)(-((float)i2)) / 8388608.0);
#line 76
			table3[i2] = (float)tmp___1;
#line 73
			i2++;
		}
#line 80
		moveable_cells = 0;
#line 81
		cell___0 = 1;
#line 81
		while (cell___0 <= numcells) {
#line 82
			if ((*(carray + cell___0))->cclass < 0) {
				goto __Cont;
			}
#line 85
			moveable_cells++;
		__Cont: /* CIL Label */
#line 81
			cell___0++;
		}
#line 89
		if (moveable_cells <= 500) {
#line 90
			attprcel = 25;
		}
		else {
#line 94
			tmp___2 = pow((double)((float)moveable_cells) / 500.0, 1.0 / 3.0);
#line 94
			attprcel = (int)(25.0 * tmp___2);
		}
#line 97
		if (tw_fast) {
#line 98
			attprcel /= 5;
		}
#line 101
		tmp___3 = safe_malloc(4U * sizeof(float *));
#line 101
		tempfile = (float **)tmp___3;
#line 102
		t = 0;
#line 102
		while (t <= 3) {
#line 103
			tmp___4 = safe_malloc(2U * sizeof(float));
#line 103
			* (tempfile + t) = (float *)tmp___4;
#line 102
			t++;
		}
#line 105
		* (*(tempfile + 0) + 0) = (float)0.9825;
#line 106
		* (*(tempfile + 0) + 1) = (float)90.0;
#line 107
		fprintf(fpo, "  tempfile[0][0] = %f    ", *(*(tempfile + 0) + 0));
#line 108
		fprintf(fpo, "tempfile[0][1] = %f\n  ", *(*(tempfile + 0) + 1));
#line 109
		* (*(tempfile + 1) + 0) = (float)0.915;
#line 110
		* (*(tempfile + 1) + 1) = (float)20.0;
#line 111
		fprintf(fpo, "tempfile[1][0] = %f    ", *(*(tempfile + 1) + 0));
#line 112
		fprintf(fpo, "tempfile[1][1] = %f\n  ", *(*(tempfile + 1) + 1));
#line 113
		* (*(tempfile + 2) + 0) = (float)0.70;
#line 114
		* (*(tempfile + 2) + 1) = (float)10.0;
#line 115
		fprintf(fpo, "tempfile[2][0] = %f    ", *(*(tempfile + 2) + 0));
#line 116
		fprintf(fpo, "tempfile[2][1] = %f\n  ", *(*(tempfile + 2) + 1));
#line 117
		* (*(tempfile + 3) + 0) = (float)0.10;
#line 118
		* (*(tempfile + 3) + 1) = (float)0.0;
#line 119
		fprintf(fpo, "tempfile[3][0] = %f    ", *(*(tempfile + 3) + 0));
#line 120
		fprintf(fpo, "tempfile[3][1] = %f\n\n", *(*(tempfile + 3) + 1));
#line 123
		TloRange = (float)10000000000.0;
#line 124
		t = -1;
#line 126
		fprintf(fpo, "  I   T  fds     Wire Penalty P_lim Epct ");
#line 127
		fprintf(fpo, "binC rowC  acc  s/p early  FDs    MRs\n");
#line 131
		while (1) {
#line 132
			syf++;
#line 133
			outB();
#line 134
			while (T < TloRange) {
#line 135
				t++;
#line 136
				if (t > 3) {
#line 137
					fprintf(fpo, "exceeded tempfile array in ");
#line 138
					fprintf(fpo, "utemp.c \n");
#line 139
					exit(1);
				}
#line 141
				Tfactor = *(*(tempfile + t) + 0);
#line 142
				TloRange = *(*(tempfile + t) + 1);
			}
#line 145
			if (pairtest == 0) {
#line 149
				uloop();
#line 153
				if (T < Tzero) {
#line 154
					pairtest = 1;
				}
#line 156
				savewolf(1);
			}
			else {
#line 159
				if (check == 0) {
#line 160
					check = 1;
#line 161
					if (stage == 1) {
#line 162
						uloop2();
#line 163
						iteration++;
					}
#line 165
					last_level = -1;
#line 166
					savewolf(1);
#line 167
					freeze = iteration;
#line 169
					if (connection_machine) {
#line 170
						unlap(-1);
#line 171
						findunlap(-1);
#line 172
						outcm();
					}
#line 175
					countf();
#line 176
					if (doglobal) {
#line 177
						sprintf(filename, "%s.cel", cktName);
#line 178
						fp = twopen((int)(filename), (int)"r", 1);
#line 179
						finalwire();
#line 180
						grdcell(fp);
#line 181
						twclose((int)fp);
					}
#line 183
					reassign();
#line 184
					if (doglobal) {
#line 185
						if (addFeeds == 0) {
#line 186
							row___0 = 1;
#line 186
							while (row___0 <= numblock) {
#line 187
								* (nofeed + row___0) = 1;
#line 186
								row___0++;
							}
						}
#line 190
						findunlap(1);
#line 192
						fdthrus = findfeeds(0);
#line 193
						fdthrus += *(add_to_row + 0);
#line 194
						fixwolf(fdthrus);
#line 195
						findfeeds(1);
#line 197
						unlap(-2);
#line 198
						add_dummy_feeds(last_feed);
#line 200
						numcells += fdthrus;
#line 201
						moveable_cells += fdthrus;
#line 202
						if (stage >= 2) {
#line 203
							sprintf(filename, "%s.rs2", cktName);
#line 204
							fp = twopen((int)(filename), (int)"r", 0);
#line 204
							if (fp) {
#line 205
								fixfdpos(fp);
#line 206
								twclose((int)fp);
							}
						}
					}
#line 210
					sortpin();
#line 211
					findunlap(0);
#line 212
					penalty = 0;
#line 213
					initialize_cost();
#line 220
					fprintf(fpo, "Added: %d  feed-through cells\n\n", fdthrus);
#line 221
					fprintf(fpo, "Removed the cell overlaps --- ");
#line 222
					fprintf(fpo, "Will do neighbor interchanges only now\n");
#line 223
					fprintf(fpo, "\nTOTAL INTERCONNECT LENGTH: %d\n", funccost);
#line 224
					fprintf(fpo, "OVERLAP PENALTY: %d\n\n", penalty);
#line 225
					fprintf(fpo, "initialRowControl:%8.3f\n", initialRowControl);
#line 226
					fprintf(fpo, "finalRowControl:%8.3f\n", finalRowControl);
#line 227
					fflush(fpo);
#line 229
					attmax = 5 * moveable_cells;
#line 231
					if (stage != 3) {
#line 232
						if (noPairs == 0) {
#line 233
							T = (float)0.001;
#line 234
							fprintf(fpo, "iter      T      Wire accept\n");
#line 235
							upair();
#line 236
							savewolf(2);
						}
					}
				}
				else {
#line 241
					if (noPairs == 0) {
#line 242
						T = (float)0.001;
#line 243
						upair();
#line 244
						savewolf(2);
					}
				}
			}
#line 249
			if (stage != 3) {
#line 250
				iteration++;
#line 250
				printf("%3d ", iteration);
#line 251
				if (iteration % 15 == 0) {
#line 252
					printf("\n");
				}
#line 254
				tmp___5 = __getreent();
#line 254
				fflush(tmp___5->_stdout);
			}
#line 257
			if (iteration >= freeze + 3) {
				goto _L;
			}
			else {
#line 257
				if (stage == 3) {
				_L: /* CIL Label */
#line 263
					i = 1;
#line 263
					while (i <= 8) {
#line 264
						align_init();
#line 265
						changes = alignfeed();
#line 266
						fprintf(fpo, "Total Feed-Alignment Movement (Pass %d): %d\n", i, changes);
#line 263
						i++;
					}
#line 269
					align_init();
#line 271
					findunlap(-1);
#line 273
					if (doglobal) {
#line 274
						globe();
#line 275
						globroute();
#line 276
						if (cswaps) {
#line 277
							if (noPairs == 0) {
#line 278
								ugpair();
							}
						}
#line 281
						findrchk();
#line 282
						fprintf(fpo, "\nFINAL NUMBER OF ROUTING TRACKS: %d\n\n", tracks);
#line 284
						i = 1;
#line 284
						while (i <= numChans) {
#line 285
							fprintf(fpo, "MAX OF CHANNEL:%3d  is: %3d\n", i, *(maxTrack + i));
#line 284
							i++;
						}
#line 288
						mergplist();
#line 289
						outpins();
#line 290
						output();
					}
					else {
#line 293
						output();
					}
#line 295
					fprintf(fpo, "FINAL TOTAL INTERCONNECT LENGTH: %d\n", funccost);
#line 296
					fprintf(fpo, "FINAL OVERLAP PENALTY: %d    ", penalty);
#line 297
					fprintf(fpo, "FINAL VALUE OF TOTAL COST IS: %d\n", funccost + penalty);
#line 299
					fprintf(fpo, "MAX NUMBER OF ATTEMPTED FLIPS PER T:%8d\n", attmax);
#line 300
					break;
				}
				else {
#line 303
					T = Tfactor * T;
				}
			}
		}
#line 306
		fprintf(fpo, "\n\ncost_scale_factor:%g\n\n", cost_scale_factor);
#line 308
		return;
	}
}
#line 313 "utemp.c"
int add_dummy_feeds(int feednum)
{
	CBOXPTR cellptr___0;
	TIBOXPTR tileptr;
	int pos;
	int row___0;
	int i;
	int last_cell;
	char *tmp;

	{
#line 320
		row___0 = 1;
#line 320
		while (row___0 <= numRows) {
#line 321
			last_cell = *(*(pairArray + row___0) + *(*(pairArray + row___0) + 0));
#line 322
			pos = ((*(carray + last_cell))->cxcenter + ((*(carray + last_cell))->tileptr)->right) - fdWidth;
#line 324
			i = 1;
#line 324
			while (i <= *(add_to_row + row___0)) {
#line 325
				pos += fdWidth;
#line 326
				feednum++;
#line 326
				cellptr___0 = *(carray + (numcells + feednum));
#line 327
				cellptr___0->padside = 0;
#line 328
				cellptr___0->cxcenter = pos;
#line 329
				cellptr___0->cycenter = (*(barray + row___0))->bycenter;
#line 330
				cellptr___0->cheight = (*(barray + row___0))->bheight;
#line 331
				cellptr___0->clength = fdWidth;
#line 332
				if ((*(barray + row___0))->borient == 2) {
#line 333
					cellptr___0->corient = (char)1;
				}
#line 335
				tileptr = cellptr___0->tileptr;
#line 336
				tmp = safe_malloc(16U * sizeof(char));
#line 336
				cellptr___0->cname = tmp;
#line 338
				sprintf(cellptr___0->cname, "twfeed%d", feednum);
#line 340
				cellptr___0->cblock = row___0;
#line 341
				tileptr->left = -fdWidth / 2;
#line 342
				tileptr->right = fdWidth + tileptr->left;
#line 343
				tileptr->bottom = -(*(barray + row___0))->bheight / 2;
#line 344
				tileptr->top = (*(barray + row___0))->bheight + tileptr->bottom;
#line 345
				safe_free((tileptr->termsptr)->nextterm);
#line 346
				safe_free(tileptr->termsptr);
#line 347
				tileptr->termsptr = (struct termbox *)((void *)0);
#line 324
				i++;
			}
#line 320
			row___0++;
		}
#line 350
		return;
	}
}
#line 1 "utils.o"
#pragma merger(0,"./utils.i","")
#line 216 "/usr/include/stdio.h"
extern FILE *(__attribute__((__cdecl__)) fopen)(char const   *_name, char const   *_type);
#line 19 "utils.h"
char *getProgName(void);
#line 10 "utils.c"
static char programName[255];
#line 11 "utils.c"
static char progVersion[255];
#line 12 "utils.c"
static char progDate[255];
#line 14 "utils.c"
int initProgram(char *name, char *version)
{
	char *date;
	int i;

	{
#line 22
		sprintf(programName, "%s", name);
#line 23
		sprintf(progVersion, "%s", version);
#line 25
		date = getCompileDate();
#line 25
		if (date) {
#line 26
			sprintf(progDate, "%s", date);
		}
		else {
#line 28
			sprintf(progDate, "unknown");
		}
#line 31
		fprintf(fpo, "\n%s version:%s date:%s\n", programName, progVersion, progDate);
#line 32
		fprintf(fpo, "Standard Cell Placement and Global Routing Program\n");
#line 33
		fprintf(fpo, "Authors: Carl Sechen, Bill Swartz\n");
#line 34
		fprintf(fpo, "          Yale University\n");
#line 36
		printf("\n%s version:%s date:%s\n", programName, progVersion, progDate);
#line 37
		printf("Standard Cell Placement and Global Routing Program\n");
#line 38
		printf("Authors: Carl Sechen, Bill Swartz\n");
#line 39
		printf("         Yale University\n");
#line 41
		safe_free(date);
#line 44
		randomSeed = 123456789U;
#line 46
		fixarray = (int *)((void *)0);
#line 47
		ffeeds = 0;
#line 48
		i = 1;
#line 48
		while (i <= 15) {
#line 49
			macspace[i] = (float)(-1.0);
#line 48
			i++;
		}
#line 51
		costonly = 0;
#line 52
		fdthrus = 0;
#line 53
		doglobal = 0;
#line 54
		cswaps = 0;
#line 56
		imprange = (float)(-1.0);
#line 57
		attprcel = 0;
#line 59
		addFeeds = 0;
#line 60
		fdWidth = -1;
#line 61
		rowSep = (float)(-1.0);
#line 62
		indent = (float)1.0;
#line 63
		numSegs = 0;
#line 64
		resume_run = 0;
#line 65
		pin_layers_given = 0;
#line 66
		no_feeds_side_nets = 0;
#line 67
		no_net_normalize = 0;
#line 68
		cost_scale_factor = (float)1.0;
#line 69
		feedLayer = 0;
#line 70
		tw_fast = 0;
#line 71
		estimate_feeds = 1;
#line 72
		connection_machine = 0;
#line 74
		gate_array_special = 0;
#line 76
		randomSeed2 = 987654321U;
#line 78
		return (0);
	}
}
#line 81 "utils.c"
char *getProgName(void)
{
	char *tmp;

	{
#line 84
		tmp = strclone(programName);
#line 84
		return (tmp);
	}
}
#line 88 "utils.c"
char *strclone(char *str)
{
	char *copy;
	size_t tmp;
	char *tmp___0;

	{
#line 92
		if (str) {
#line 93
			if (*str) {
#line 94
				tmp = strlen((char const   *)str);
#line 94
				tmp___0 = safe_malloc(tmp + 1U);
#line 94
				copy = tmp___0;
#line 95
				sprintf(copy, "%s", str);
#line 96
				return (copy);
			}
		}
#line 99
		return ((char *)((void *)0));
	}
}
#line 103 "utils.c"
FILE *openFile(char *filename, char *readwrite, int abort)
{
	FILE *fileptr;

	{
#line 108
		fileptr = fopen((char const   *)filename, (char const   *)readwrite);
#line 110
		if (!fileptr) {
#line 110
			if (abort) {
#line 111
				printf("could not open file %s\n", filename);
#line 112
				exit(1);
			}
		}
#line 114
		return (fileptr);
	}
}
#line 1 "xcompact.o"
#pragma merger(0,"./xcompact.i","")
#line 4 "xcompact.c"
int *blklist;
#line 12 "xcompact.c"
INT2 *blkshifts;
#line 50
int findblks(int bot___0, int top___0, int rite___0, int direction);
#line 26 "xcompact.c"
void xcompact(void)
{
	int blk___0;
	int pad___0;
	int k___0;
	int bot___0;
	int top___0;
	int rite___0;
	int left___0;
	int maxd;
	int cell___0;
	int end;
	int mind;
	int padside;
	CBOXPTR padptr;
	CBOXPTR cellptr___0;
	char *tmp;
	char *tmp___0;

	{
#line 33
		tmp = safe_malloc((unsigned int)(numblock + 1) * sizeof(int));
#line 33
		blklist = (int *)tmp;
#line 34
		tmp___0 = safe_malloc((unsigned int)(numblock + 1) * sizeof(INT2));
#line 34
		blkshifts = (INT2 *)tmp___0;
#line 35
		blk___0 = 1;
#line 35
		while (blk___0 <= numblock) {
#line 36
			(blkshifts + blk___0)->sleft = -1000;
#line 35
			blk___0++;
		}
#line 39
		pad___0 = numcells + 1;
#line 39
		while (pad___0 <= numcells + numterms) {
#line 40
			if ((*(carray + pad___0))->padside == 12) {
				goto _L;
			}
			else {
#line 40
				if ((*(carray + pad___0))->padside == 13) {
					goto _L;
				}
				else {
#line 40
					if ((*(carray + pad___0))->padside == 11) {
					_L: /* CIL Label */
#line 42
						padptr = *(carray + pad___0);
#line 43
						padside = padptr->padside;
#line 44
						rite___0 = padptr->cxcenter + (padptr->tileptr)->right;
#line 45
						left___0 = padptr->cxcenter + (padptr->tileptr)->left;
#line 46
						bot___0 = (int)((double)(padptr->cycenter + (padptr->tileptr)->bottom) - (double)(rowSep * (float)rowHeight) * 0.67);
#line 48
						top___0 = (int)((double)(padptr->cycenter + (padptr->tileptr)->top) + (double)(rowSep * (float)rowHeight) * 0.67);
#line 50
						findblks(bot___0, top___0, rite___0, -1);
#line 51
						maxd = 0;
#line 52
						k___0 = 1;
#line 52
						while (k___0 <= *(blklist + 0)) {
#line 53
							blk___0 = *(blklist + k___0);
#line 54
							cell___0 = *(*(pairArray + blk___0) + *(*(pairArray + blk___0) + 0));
#line 55
							cellptr___0 = *(carray + cell___0);
#line 56
							if (cellptr___0->cxcenter + (cellptr___0->tileptr)->right > maxd) {
#line 57
								maxd = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
							}
#line 52
							k___0++;
						}
#line 60
						k___0 = 1;
#line 60
						while (k___0 <= *(blklist + 0)) {
#line 61
							blk___0 = *(blklist + k___0);
#line 62
							(blkshifts + blk___0)->srite = maxd;
#line 63
							(blkshifts + blk___0)->sleft = (*(barray + blk___0))->bxcenter + (*(barray + blk___0))->bleft;
#line 60
							k___0++;
						}
#line 66
						findblks(bot___0, top___0, rite___0, 1);
#line 67
						(*(carray + pad___0))->cxcenter = (int)((float)(*(carray + pad___0))->cxcenter + (macspace[padside] - (float)(left___0 - maxd)));
#line 68
						k___0 = 1;
#line 68
						while (k___0 <= *(blklist + 0)) {
#line 69
							blk___0 = *(blklist + k___0);
#line 70
							(*(barray + blk___0))->bxcenter = (int)((float)(*(barray + blk___0))->bxcenter + (macspace[padside] - (float)(left___0 - maxd)));
#line 72
							k___0 = 1;
#line 72
							while (k___0 <= *(*(pairArray + blk___0) + 0)) {
#line 73
								cell___0 = *(*(pairArray + blk___0) + k___0);
#line 74
								(*(carray + cell___0))->cxcenter = (int)((float)(*(carray + cell___0))->cxcenter + (macspace[padside] - (float)(left___0 - maxd)));
#line 72
								k___0++;
							}
#line 68
							k___0++;
						}
					}
				}
			}
#line 39
			pad___0++;
		}
#line 80
		pad___0 = numcells + 1;
#line 80
		while (pad___0 <= numcells + numterms) {
#line 81
			padptr = *(carray + pad___0);
#line 82
			if (padptr->padside == 6) {
				goto _L___0;
			}
			else {
#line 82
				if (padptr->padside == 10) {
					goto _L___0;
				}
				else {
#line 82
					if (padptr->padside == 8) {
					_L___0: /* CIL Label */
#line 84
						padside = padptr->padside;
#line 85
						rite___0 = padptr->cxcenter + (padptr->tileptr)->right;
#line 86
						left___0 = padptr->cxcenter + (padptr->tileptr)->left;
#line 87
						bot___0 = (int)((double)(padptr->cycenter + (padptr->tileptr)->bottom) - (double)(rowSep * (float)rowHeight) * 0.33);
#line 89
						top___0 = (int)((double)(padptr->cycenter + (padptr->tileptr)->top) + (double)(rowSep * (float)rowHeight) * 0.33);
#line 91
						findblks(bot___0, top___0, rite___0, -1);
#line 92
						maxd = 0;
#line 93
						k___0 = 1;
#line 93
						while (k___0 <= *(blklist + 0)) {
#line 94
							blk___0 = *(blklist + k___0);
#line 95
							cell___0 = *(*(pairArray + blk___0) + *(*(pairArray + blk___0) + 0));
#line 96
							cellptr___0 = *(carray + cell___0);
#line 97
							if (cellptr___0->cxcenter + (cellptr___0->tileptr)->right > maxd) {
#line 98
								maxd = cellptr___0->cxcenter + (cellptr___0->tileptr)->right;
							}
#line 93
							k___0++;
						}
#line 101
						k___0 = 1;
#line 101
						while (k___0 <= *(blklist + 0)) {
#line 102
							blk___0 = *(blklist + k___0);
#line 103
							(blkshifts + blk___0)->srite = maxd;
#line 104
							(blkshifts + blk___0)->sleft = (*(barray + blk___0))->bxcenter + (*(barray + blk___0))->bleft;
#line 101
							k___0++;
						}
#line 107
						(*(carray + pad___0))->cxcenter = (int)((float)(*(carray + pad___0))->cxcenter + (macspace[padside] - (float)(left___0 - maxd)));
					}
				}
			}
#line 80
			pad___0++;
		}
#line 115
		maxd = 0;
#line 116
		blk___0 = 1;
#line 116
		while (blk___0 <= numblock) {
#line 117
			if (*(*(pairArray + blk___0) + 0) <= 0) {
				goto __Cont;
			}
#line 120
			cell___0 = *(*(pairArray + blk___0) + *(*(pairArray + blk___0) + 0));
#line 121
			end = (*(carray + cell___0))->cxcenter + ((*(carray + cell___0))->tileptr)->right;
#line 122
			if (end > maxd) {
#line 123
				maxd = end;
			}
		__Cont: /* CIL Label */
#line 116
			blk___0++;
		}
#line 126
		pad___0 = numcells + 1;
#line 126
		while (pad___0 <= numcells + numterms) {
#line 127
			padptr = *(carray + pad___0);
#line 128
			if (padptr->padside == 6) {
				goto _L___1;
			}
			else {
#line 128
				if (padptr->padside == 10) {
					goto _L___1;
				}
				else {
#line 128
					if (padptr->padside == 8) {
						goto _L___1;
					}
					else {
#line 128
						if (padptr->padside == 14) {
							goto _L___1;
						}
						else {
#line 128
							if (padptr->padside == 15) {
							_L___1: /* CIL Label */
#line 131
								if (padptr->cxcenter + (padptr->tileptr)->right > maxd) {
#line 132
									maxd = padptr->cxcenter + (padptr->tileptr)->right;
								}
							}
						}
					}
				}
			}
#line 126
			pad___0++;
		}
#line 136
		blk___0 = 1;
#line 136
		while (blk___0 <= numblock) {
#line 137
			if ((blkshifts + blk___0)->sleft == -1000) {
#line 138
				(blkshifts + blk___0)->srite = maxd;
#line 139
				(blkshifts + blk___0)->sleft = (*(barray + blk___0))->bxcenter + (*(barray + blk___0))->bleft;
			}
#line 136
			blk___0++;
		}
#line 146
		mind = 32000;
#line 147
		pad___0 = numcells + 1;
#line 147
		while (pad___0 <= numcells + numterms) {
#line 148
			padptr = *(carray + pad___0);
#line 149
			if (padptr->padside == 3) {
#line 150
				if (padptr->cxcenter + (padptr->tileptr)->left < mind) {
#line 151
					mind = padptr->cxcenter + (padptr->tileptr)->left;
				}
			}
#line 147
			pad___0++;
		}
#line 155
		pad___0 = numcells + 1;
#line 155
		while (pad___0 <= numcells + numterms) {
#line 156
			if ((*(carray + pad___0))->padside == 3) {
#line 157
				(*(carray + pad___0))->cxcenter = (int)((float)(*(carray + pad___0))->cxcenter + (rowSep * (float)rowHeight - (float)(mind - maxd)));
			}
#line 155
			pad___0++;
		}
#line 162
		return;
	}
}
#line 165 "xcompact.c"
int findblks(int bot___0, int top___0, int rite___0, int direction)
{
	int blk___0;

	{
#line 170
		* (blklist + 0) = 0;
#line 171
		blk___0 = 1;
#line 171
		while (blk___0 <= numblock) {
#line 172
			if ((*(barray + blk___0))->bycenter > bot___0) {
#line 172
				if ((*(barray + blk___0))->bycenter < top___0) {
#line 173
					if (direction == -1) {
#line 174
						if ((*(barray + blk___0))->bxcenter + (*(barray + blk___0))->bright < rite___0) {
#line 175
							if ((blkshifts + blk___0)->sleft == -1000) {
#line 176
								(*(blklist + 0))++;
#line 176
								* (blklist + *(blklist + 0)) = blk___0;
							}
						}
					}
					else {
#line 180
						if ((*(barray + blk___0))->bxcenter + (*(barray + blk___0))->bleft > rite___0) {
#line 181
							(*(blklist + 0))++;
#line 181
							* (blklist + *(blklist + 0)) = blk___0;
						}
					}
				}
			}
#line 171
			blk___0++;
		}
#line 187
		return;
	}
}
#line 1 "xpickint.o"
#pragma merger(0,"./xpickint.i","")
#line 7 "xpickint.c"
int XPICK_INT(int l, int u, int c)
{
	int d;

	{
#line 12
		if (c < 0) {
#line 13
			return (-c);
		}
		else {
#line 16
			while (1) {
#line 17
				d = PICK_INT(l, u);
#line 16
				if (!(d == c)) {
#line 16
					break;
				}
			}
#line 20
			return (d);
		}
	}
}
