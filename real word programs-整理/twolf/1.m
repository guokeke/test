frame(tempi,tempj,YRcount,syf,rows_1,hashtab,netctr,carray,netarray,tearray,barray,rowArray,binptr,ULgrdptr,URgrdptr,LLgrdptr,LRgrdptr,Shuffle,bdxlen,bdylen,numblock,numcells,numterms,numnets,numRows,penalty,funccost,Trybin,binpenal,rowpenal,newrowpenal,newbinpenal,Left_bound,Rite_bound,cedgebin,cedge_binwidth,num_edgebin,gtopChan,gbotChan,one_pin_feedthru,numBins,binWidth,binOffst,fdWidth,feeds,rowgrid,windx,randVar,max_blklength,desiredL,implicit_feed_count,feeds_in_row,resume_run,uneven_cell_height,track_spacing,fpo,randomSeed,randomSeed2,cktName,connection_machine,estimate_feeds,tw_fast,gate_array_special,pin_layers_given,no_feeds_side_nets,no_net_normalize,route2act,routeGrid,gridCell,feedLayer,attmax,maxCellO,iteration,iwire,iwirex,iwirey,fwire,fwirex,fwirey,blkxspan,blkyspan,ffeeds,addFeeds,lrtxspan,lrtyspan,pairArray,attprcel,doglobal,cswaps,costonly,restart,ifrange,fixarray,tw_slow,T,Tzero,desired_accept,imprange,binpenCon,indent,rowSep,roLenCon,stopdeg,macspace,cost_scale_factor,xipptr,blkToRow,rowHeight,boxptr,oldbarray,cellptr,macroArray,filledTo,endRow,macNumber,row,totalR,totalBlock,borient,empty$,cell,middleRow,extraSpace,pad,height,width,bot,top,trow,rows,brow,rite,left,coreHeight,coreWidth,count,macro,maxHeight,space,separation,yshift,xshift,last,coreTop,coreRite,block,maxWidth,padArray,numMacro,URmacro,Rmacro,edge,k,blk,zxshift,zyshift,mttshift,mbbshift,dsum,ratio,ckt_size_factor,old_feed_length,xfeeds_in_row,est_fds,row_map,num_calls,delta_vert_cost,tot_num_feeds,tot_missing_rows,num_feeds,tmp_num_feeds,missing_rows,tmp_missing_rows,tmp_rows,minxspan,mean_width,offset_limit,blkleft,blkrite,act_feeds_in_row,pad_line,last_feed,impcount,feed_location,add_to_row,length_of_row,pseudoPins,pseudoEdge,groupArray,MPG,ME,edgeArray,checkArray,key_queue,numEdges,numGroups,numPins,gxstart,gxstop,top_row,attlimit,aNetSeg,Begin,End,Tgrid,Densebox,DboxHead,anet,netchgs,fixnetseg,numChans,numSegs,numSwSegs,tracks,maxTrack,nmaxTrack,max_tdensity,top_row_for_this_net,bot_row_for_this_net,pinnames,head_type,active_cell_type,pin_ptr,active_type,siptr,impFeeds,tmp_pinlist,pinlist,pinGroup,merge_array,array_length,mt,celllen,fixLRBT,padspace,qsz,thresh,mthresh,SccsId,randVarS,nofeed,relativeLen,totallen,maxterm,stage,last_level,na_i,nb_i,start_i,end_i,startcbin,endcbin,rowleft,leftx,ritex,old_axcenter,old_bxcenter,acellptr,bcellptr,axcenter,aycenter,bxcenter,bycenter,anxcenter,bnxcenter,aleft,aright,bleft,bright,potential_errors,error_count,P_limit,total_wire_chg,sigma_wire_chg,mean_wire_chg,wire_chgs,finalRowControl,initialRowControl,newpenal,Apost,Bpost,cellaptr,cellbptr,earlyRej,Rej_error,wire_chg,binpen_chg,rowpen_chg,a,b,ablock,bblock,attempts,first_time_in_unlap,noPairs,table1,table2,table3,moveable_cells,fdthrus,programName,progVersion,progDate,blklist,blkshifts) and (
int syf <== 0,tempi,tempj and skip;
int YRcount <== 0 and skip;
struct blockbox {
int bxcenter and 
int bycenter and 
int bleft and 
int bright and 
int bbottom and 
int btop and 
int bheight and 
int blength and 
int desire and 
int oldsize and 
int newsize and 
int bclass and 
int borient 
};
struct netbox {
struct netbox* nterm and 
int terminal and 
int extint and 
int xpos and 
int ypos and 
int newx and 
int newy and 
int row and 
int cell and 
int net and 
char pinloc and 
char unequiv and 
char flag and 
char layer 
};
struct termbox {
struct termbox* nextterm and 
netbox* termptr and 
int cellterm and 
int ei and 
int net and 
int txpos[2] and 
int typos[2] and 
int ue 
};
struct tilebox {
int left and 
int right and 
int bottom and 
int top and 
termbox* termsptr 
};
struct cellbox {
char *cname and 
char corient and 
char orflag and 
int cxcenter and 
int cycenter and 
int cclass and 
int cheight and 
int clength and 
int border and 
int cblock and 
int numterms and 
int padside and 
tilebox* tileptr 
};
struct dimbox {
netbox* netptr and 
char *name and 
char dflag and 
char feedflag and 
char ignore and 
int old_total and 
int new_total and 
int xmin and 
int newxmin and 
int xmax and 
int newxmax and 
int ymin and 
int newymin and 
int ymax and 
int newymax and 
int Lnum and 
int newLnum and 
int Rnum and 
int newRnum and 
int Bnum and 
int newBnum and 
int Tnum and 
int newTnum and 
int numpins and 
float Vweight and 
float Hweight 
};
struct hash {
char *hname and 
int hnum and 
struct hash* hnext 
};
struct rowbox {
int startx and 
int endx and 
int endx1 and 
int startx2 and 
int ypos and 
int desiredL 
};
struct binbox {
int left and 
int right and 
int *cell and 
int penalty and 
int nupenalty 
};
struct changrdbox {
netbox* netptr and 
int tracks and 
int ntracks and 
int SegType and 
int nSegType and 
struct changrdbox* prevgrd and 
struct changrdbox* nprevgrd and 
struct changrdbox* nextgrd and 
struct changrdbox* nnextgrd and 
struct densitybox* dptr 
};
hash* *hashtab and skip;
int netctr and skip;
cellbox* *carray and skip;
dimbox* *netarray and skip;
netbox* *tearray and skip;
blockbox* *barray and skip;
rowbox *rowArray and skip;
binbox ***binptr and skip;
changrdbox* ULgrdptr,*URgrdptr,*LLgrdptr,*LRgrdptr,**Shuffle and skip;
int bdxlen,bdylen and skip;
int numblock and skip;
int numcells and skip;
int numterms and skip;
int numnets and skip;
int numRows and skip;
int penalty and skip;
int funccost and skip;
int Trybin and skip;
int binpenal and skip;
int rowpenal and skip;
int newrowpenal and skip;
int newbinpenal and skip;
int Left_bound,Rite_bound and skip;
int **cedgebin,cedge_binwidth,num_edgebin and skip;
int gtopChan,gbotChan and skip;
int one_pin_feedthru and skip;
int numBins and skip;
int binWidth and skip;
int binOffst and skip;
int fdWidth and skip;
int feeds and skip;
int **rowgrid and skip;
int windx and skip;
int randVar and skip;
int max_blklength and skip;
int desiredL and skip;
int implicit_feed_count and skip;
int *feeds_in_row and skip;
int resume_run and skip;
int uneven_cell_height and skip;
int track_spacing and skip;
FILE *fpo and skip;
unsigned int randomSeed and skip;
unsigned int randomSeed2 and skip;
char cktName[128] and skip;
int connection_machine and skip;
int estimate_feeds and skip;
int tw_fast and skip;
int gate_array_special and skip;
int pin_layers_given and skip;
int no_feeds_side_nets and skip;
int no_net_normalize and skip;
int route2act and skip;
int routeGrid and skip;
int gridCell and skip;
int feedLayer and skip;
int attmax and skip;
int maxCellO and skip;
int iteration and skip;
int iwire and skip;
int iwirex and skip;
int iwirey and skip;
int fwire and skip;
int fwirex and skip;
int fwirey and skip;
int blkxspan and skip;
int blkyspan and skip;
int ffeeds and skip;
int addFeeds and skip;
int lrtxspan and skip;
int lrtyspan and skip;
int **pairArray and skip;
int attprcel and skip;
int doglobal and skip;
int cswaps and skip;
int costonly and skip;
int restart and skip;
int ifrange and skip;
int *fixarray and skip;
int tw_slow and skip;
float T and skip;
float Tzero and skip;
float *desired_accept and skip;
float imprange and skip;
float binpenCon and skip;
float indent and skip;
float rowSep and skip;
float roLenCon and skip;
float stopdeg and skip;
float macspace[16] and skip;
float cost_scale_factor and skip;

function outC ()
{
frame(i) and 
(
int i<==1 and skip;
while(i<=26)
{
	printf("%d %d %d\n",carray[i]->cxcenter,carray[i]->cycenter,carray[i]->cclass) and skip;
	printf("%d %d %d %d %d %d\n",carray[i]->cheight,carray[i]->clength,carray[i]->border,carray[i]->cblock,carray[i]->numterms,carray[i]->padside) and skip;
	i:=i+1
};
printf("****************") and skip
)
};

function outB()
{
frame(i) and 
(
int i<==1 and skip;
while(i<=2)
{
	printf("%d %d %d %d %d %d\n",barray[i]->bxcenter,barray[i]->bycenter,barray[i]->bleft,barray[i]->bright,barray[i]->bbottom,barray[i]->btop) and skip;
	printf("%d %d %d %d %d %d\n",barray[i]->bheight,barray[i]->blength,barray[i]->desire,barray[i]->oldsize,barray[i]->newsize,barray[i]->bclass) and skip;
	i:=i+1
	}
)
};

 function main (  )
 {
     frame(temp_i,name,main_fp,main_filename,main_block,main_i,main_net,main_changes,main_input$,main_l,main_r,main_b,main_t,main_cx,main_cy,main_cl,main_cr,main_cb,main_ct,main_cell,main_row,main_temp$_1,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     FILE *main_fp and skip;
     char main_filename[64] and skip;
     int main_block and skip;
     int main_i,main_net,main_changes and skip;
     char main_input$[40] and skip;
     int main_l,main_r,main_b,main_t,main_cx,main_cy,main_cl,main_cr,main_cb,main_ct,main_cell,main_row and skip;
     /*if(argc!=2) then 
     {
         output ("circuit name not entered properly on command line\n") and skip;
         output ("Proper syntax: TimberwolfSC circuitName\n") and skip;
         exit(0) and skip 
         
     }
     else 
     {
          skip 
     };*/
	 char name[20] <=="F:/input/test\0" and skip;
     sprintf(cktName,"%s",name,RValue) and skip;
     sprintf(main_filename,"%s.out",cktName,RValue) and skip;
     fpo:=twopen(main_filename,"w",1,RValue);
     initProgram("TimberWolfSC","v4.3a",RValue);
     readParFile(RValue);
	 
     Yset_random_seed(randomSeed,RValue);
	 
     sprintf(main_filename,"%s.blk",cktName,RValue) and skip;
     main_fp:=twopen(main_filename,"r",1,RValue);
     readblck(main_fp,RValue);
	 
     twclose(main_fp);
     maxCellO:=0;
     break$<==0 and skip;
     main_block:=1;
     
     while( break$=0 AND  main_block<=numblock)
     {
         if(barray[main_block]->borient=2) then 
         {
             maxCellO:=1;
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             main_block:=main_block+1
         }
         else
         {
             skip
         }
         
     };
	 
     break$<==0 and skip;
     sprintf(main_filename,"%s.cel",cktName,RValue) and skip;
     main_fp:=twopen(main_filename,"r",1,RValue);
	 
     readcell(main_fp,RValue);
	 	  
     twclose(main_fp);
	
     sprintf(main_filename,"%s.net",cktName,RValue) and skip;
     main_fp:=twopen(main_filename,"r",1,RValue);
	  
     readnets(main_fp,RValue);
     twclose(main_fp);
	 
     iteration:=0;
     T:=500.0;
     main_t:=0;
     main_b:=32000;
     main_r:=0;
     main_l:=32000;
     main_block:=1;
      
     while(main_block<=numblock)
     {
         main_cx:=barray[main_block]->bxcenter;
         main_cy:=barray[main_block]->bycenter;
         main_cl:=barray[main_block]->bleft;
         main_cr:=barray[main_block]->bright;
         main_cb:=barray[main_block]->bbottom;
         main_ct:=barray[main_block]->btop;
         if(main_cx+main_cr>main_r) then 
         {
             main_r:=main_cx+main_cr
             
         }
         else 
         {
              skip 
         };
         if(main_cx+main_cl<main_l) then 
         {
             main_l:=main_cx+main_cl
             
         }
         else 
         {
              skip 
         };
         if(main_cy+main_ct>main_t) then 
         {
             main_t:=main_cy+main_ct
             
         }
         else 
         {
              skip 
         };
         if(main_cy+main_cb<main_b) then 
         {
             main_b:=main_cy+main_cb
             
         }
         else 
         {
              skip 
         };
         main_block:=main_block+1
         
     };

	

     blkxspan:=main_r-main_l;
     blkyspan:=main_t-main_b;
     ifrange:=blkxspan*imprange;
     fprintf(fpo,"block x-span:%d  block y-span:%d\n",blkxspan,blkyspan) and skip;
     fprintf(fpo,"implicit feed thru range: %d\n",ifrange) and skip;
     main_cell:=1;
     
     while(main_cell<=numcells+numterms)
     {
         main_cx:=carray[main_cell]->cxcenter;
         main_cy:=carray[main_cell]->cycenter;
         main_cl:=carray[main_cell]->tileptr->left;
         main_cr:=carray[main_cell]->tileptr->right;
         main_cb:=carray[main_cell]->tileptr->bottom;
         main_ct:=carray[main_cell]->tileptr->top;
         if(main_cx+main_cr>main_r) then 
         {
             main_r:=main_cx+main_cr
             
         }
         else 
         {
              skip 
         };
         if(main_cx+main_cl<main_l) then 
         {
             main_l:=main_cx+main_cl
             
         }
         else 
         {
              skip 
         };
         if(main_cy+main_ct>main_t) then 
         {
             main_t:=main_cy+main_ct
             
         }
         else 
         {
              skip 
         };
         if(main_cy+main_cb<main_b) then 
         {
             main_b:=main_cy+main_cb
             
         }
         else 
         {
              skip 
         };
         main_cell:=main_cell+1
         
     };

	

     bdxlen:=main_r-main_l;
     bdylen:=main_t-main_b;
     lrtxspan:=main_r;
     lrtyspan:=main_t;
     main_net:=1;
     
     while(main_net<=numnets)
     {
         netarray[main_net]->Vweight:=netarray[main_net]->Vweight*2.0/ (rowSep+1.0);
         main_net:=main_net+1
         
     };
     binpenCon:=4.0*((((float)numcells)/ ((float)numblock))/ 39.0);
     binpenCon:=( if((binpenCon>4.0)) then binpenCon else 4.0);
     binpenCon:=1.0;
     roLenCon:=3.0;
     fprintf(fpo,"Using default value of bin.penalty.control:%f\n",binpenCon) and skip;
     funccost:=findcost(RValue);
     assignro(RValue);
     initialize_rows(RValue);
     int main_temp$_1 and skip;
     main_temp$_1:=initialize_cost(RValue);
     fprintf(fpo,"\nNew Cost Function: Initial Horizontal Cost:%d\n",main_temp$_1) and skip;
     vert_statistics(RValue);
     fprintf(fpo,"New Cost Function: FEEDS:%d   MISSING_ROWS:%d\n\n",tot_num_feeds,tot_missing_rows) and skip;
     fprintf(fpo,"bdxlen:%d  bdylen:%d\n",bdxlen,bdylen) and skip;
     fprintf(fpo,"l:%d  t:%d  r:%d  b:%d\n",main_l,main_t,main_r,main_b) and skip;
     fprintf(fpo,"\n\n\nTHIS IS THE ROUTE COST OF THE ") and skip;
     fprintf(fpo,"CURRENT PLACEMENT: %d\n",funccost) and skip;
     fprintf(fpo,"\n\n\nTHIS IS THE PENALTY OF THE ") and skip;
     fprintf(fpo,"CURRENT PLACEMENT: %d\n",penalty) and skip;
     fflush(fpo) and skip;
     if(!costonly) then 
     {
         Tzero:=0.1;
         desired_accept:=(float *)safe_malloc(117*sizeof(float),RValue);
         main_i:=0;
         
         while(main_i<=116)
         {
             if(main_i<7) then 
             {
                 desired_accept[main_i]:=50.0
                 
             }
             else
             {
                 desired_accept[main_i]:=50.5-((50.0/ 110.0)*(float)(main_i-6))
             };
             main_i:=main_i+1
             
         };
         utemp(RValue)
          

     }
     else
     {
         if(connection_machine) then 
         {
             unlap(-1,RValue);
             findunlap(-1,RValue);
             outcm(RValue)
             
         }
         else 
         {
              skip 
         };
         if(doglobal) then 
         {
             countf(RValue);
             sprintf(main_filename,"%s.cel",cktName,RValue) and skip;
             main_fp:=twopen(main_filename,"r",1,RValue);
             grdcell(main_fp,RValue);
             twclose(main_fp);
             reassign(RValue);
             if(addFeeds=0) then 
             {
                 main_row:=1;
                 
                 while(main_row<=numblock)
                 {
                     nofeed[main_row]:=1;
                     main_row:=main_row+1
                     
                 }
                 
             }
             else 
             {
                  skip 
             };
             findunlap(1,RValue);
             fdthrus:=findfeeds(0,RValue);
             fdthrus:=fdthrus+add_to_row[0];
             fixwolf(fdthrus,RValue);
             findfeeds(1,RValue);
             unlap(-2,RValue);
             add_dummy_feeds(last_feed,RValue);
             numcells:=numcells+fdthrus;
             if(stage>=2) then 
             {
                 sprintf(main_filename,"%s.rs2",cktName,RValue) and skip;
                 main_fp:=twopen(main_filename,"r",0,RValue);
                 if(main_fp) then 
                 {
                     fixfdpos(main_fp,RValue);
                     twclose(main_fp)
                     
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else 
             {
                  skip 
             };
             findunlap(0,RValue);
             main_i:=1;
             
             while(main_i<=8)
             {
                 align_init(RValue);
                 main_changes:=alignfeed(RValue);
                 fprintf(fpo,"Total Feed-Alignment Movement (Pass %d): %d\n",main_i,main_changes) and skip;
                 main_i:=main_i+1
                 
             };
             align_init(RValue);
             findunlap(-1,RValue);
             moveable_cells:=0;
             continue<==0 and skip;
             main_cell:=1;
             
             while(main_cell<=numcells)
             {
                  continue<==0 and skip;
                 if(carray[main_cell]->cclass<0) then 
                 {
                     continue<==1 and skip;
                      main_cell:=main_cell+1
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     moveable_cells:=moveable_cells+1;
                     main_cell:=main_cell+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             continue<==0 and skip;
             globe(RValue);
             globroute(RValue);
             if(cswaps) then 
             {
                 ugpair(RValue)
                 
             }
             else 
             {
                  skip 
             };
             findrchk(RValue);
             fprintf(fpo,"\nFINAL NUMBER OF ROUTING TRACKS: %d\n\n",tracks) and skip;
             main_i:=1;
             
             while(main_i<=numChans)
             {
                 fprintf(fpo,"MAX OF CHANNEL:%3d  is: %3d\n",main_i,maxTrack[main_i]) and skip;
                 main_i:=main_i+1
                 
             };
             mergplist(RValue);
             outpins(RValue);
             output$(RValue);
             safe_free(pinlist,RValue)
         }
         else
         {
             reassign(RValue);
             findunlap(1,RValue);
             output$(RValue)
         }
     };
     fprintf(fpo,"Number of Feed Thrus: %d\n",ffeeds) and skip;
     fprintf(fpo,"Number of Implicit Feed Thrus: %d\n",impcount) and skip;
     fprintf(fpo,"\nStatistics:\n") and skip;
     fprintf(fpo,"Number of Standard Cells: %d\n",numcells-fdthrus) and skip;
     fprintf(fpo,"Number of Pads: %d \n",numterms) and skip;
     fprintf(fpo,"Number of Nets: %d \n",numnets) and skip;
     fprintf(fpo,"Number of Pins: %d \n",maxterm) and skip;
     print_stats(fpo,RValue);
     twclose(fpo);
     exit(0) and skip 
     )
     }; 
  function acceptt ( int delta_cost,int RValue )
 {
     frame(acceptt_truth,acceptt_fred,acceptt_fract,return) and ( 
     int return<==0 and skip;
     int acceptt_truth and skip;
     float acceptt_fred and skip;
     unsigned int acceptt_fract and skip;
     acceptt_fred:=((float)delta_cost*cost_scale_factor)/ T;
	 	
     if(acceptt_fred>=0.0) then 
     {
         acceptt_truth:=1
         
     }
     else
     {
         if(acceptt_fred<-80.0) then 
         {
             acceptt_truth:=0
         }
         else
         {
             if(acceptt_fred>-0.0001) then 
             {
                 if(1.0+acceptt_fred>((float)(extern Yacm_random(RValue))/ (float)0x7fffffff)) then 
                 {
                     acceptt_truth:=1
                 }
                 else
                 {
                     acceptt_truth:=0
                 }
             }
             else
             {
                 acceptt_fract:=(int)(-acceptt_fred*8388608.0);
                 if((table1[(acceptt_fract>>20) & 1023]*table2[(acceptt_fract>>10) & 1023]*table3[acceptt_fract & 1023])>((float)(extern Yacm_random(RValue))/ (float)0x7fffffff)) then 
                 {
                     acceptt_truth:=1
                 }
                 else
                 {
                     acceptt_truth:=0
                 }
             }
         }
     };
     return<==1 and RValue:=acceptt_truth;
     skip
     )
     }; 
      struct ipbox {
     struct ipbox* npin and 
     int ixpos and 
     int iypos and 
     int layer and 
     char *ipname 
 };
 struct ibox {
 struct ibox* niptr and 
 int iactive and 
 int aveXpos and 
 int icell and 
 ipbox* iptr 
 };
 function addimp ( int row,int net )
 {
     frame(addimp_ptr,addimp_termptr,addimp_ipptr,addimp_tipptr,addimp_bipptr,addimp_nptr,addimp_n1ptr,addimp_n2ptr,addimp_pin,addimp_orient,addimp_realcell,addimp_temp$_1,addimp_temp$_2,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     cellbox* addimp_ptr and skip;
     termbox* addimp_termptr and skip;
     ipbox* addimp_ipptr,*addimp_tipptr,*addimp_bipptr and skip;
     netbox* addimp_nptr,*addimp_n1ptr,*addimp_n2ptr and skip;
     int addimp_pin,addimp_orient,addimp_realcell and skip;
     addimp_realcell:=siptr->icell;
     addimp_ptr:=carray[addimp_realcell];
     addimp_ptr->numterms:=addimp_ptr->numterms+2;
     break$<==0 and skip;
     addimp_ipptr:=siptr->iptr;
     
     while( break$=0 AND  true)
     {
         if(addimp_ipptr->iypos>0) then 
         {
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             addimp_ipptr:=addimp_ipptr->npin
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     addimp_tipptr:=addimp_ipptr;
     break$<==0 and skip;
     addimp_ipptr:=siptr->iptr;
     
     while( break$=0 AND  true)
     {
         if(addimp_ipptr->iypos<0) then 
         {
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             addimp_ipptr:=addimp_ipptr->npin
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     addimp_bipptr:=addimp_ipptr;
     addimp_termptr:=addimp_ptr->tileptr->termsptr;
     if(addimp_termptr!=NULL) then 
     {
         while(addimp_termptr->nextterm!=NULL)
         {
             addimp_termptr:=addimp_termptr->nextterm
         };
         addimp_termptr->nextterm:=(termbox*)safe_malloc(sizeof(termbox),RValue);
		 addimp_termptr<==addimp_termptr->nextterm and skip
         
     }
     else
     {
         addimp_ptr->tileptr->termsptr:=(termbox*)safe_malloc(sizeof(termbox),RValue);
		 addimp_termptr<==addimp_ptr->tileptr->termsptr and skip
     };
     addimp_termptr->cellterm:=(maxterm+1);
     maxterm:=maxterm+1;
     int addimp_temp$_1 and skip;
     addimp_temp$_1:=strlen(addimp_tipptr->ipname);
     pinnames[maxterm]:=(char *)safe_malloc((addimp_temp$_1+1)*sizeof(char),RValue);
     sprintf(pinnames[maxterm],"%s",addimp_tipptr->ipname,RValue) and skip;
     addimp_termptr->ei:=maxterm;
     addimp_termptr->ue:=0;
     tearray[maxterm]:=(netbox*)safe_malloc(sizeof(netbox),RValue);
     addimp_termptr->nextterm:=(termbox*)safe_malloc(sizeof(termbox),RValue);
     addimp_termptr->nextterm->nextterm:=NULL;
     addimp_termptr->nextterm->ei:=maxterm;
     addimp_termptr->nextterm->ue:=0;
     addimp_termptr->nextterm->cellterm:=(maxterm+1);
     maxterm:=maxterm+1;
     int addimp_temp$_2 and skip;
     addimp_temp$_2:=strlen(addimp_bipptr->ipname);
     pinnames[maxterm]:=(char *)safe_malloc((addimp_temp$_2+1)*sizeof(char),RValue);
     sprintf(pinnames[maxterm],"%s",addimp_bipptr->ipname,RValue) and skip;
     tearray[maxterm]:=(netbox*)safe_malloc(sizeof(netbox),RValue);
     addimp_termptr->txpos[0]:=addimp_tipptr->ixpos;
     addimp_termptr->typos[0]:=addimp_tipptr->iypos;
     addimp_termptr->txpos[1]:=-addimp_termptr->txpos[0];
     addimp_termptr->typos[1]:=-addimp_termptr->typos[0];
     if(addimp_ptr->clength % 2!=0) then 
     {
         addimp_termptr->txpos[1]:=addimp_termptr->txpos[1]+1
         
     }
     else 
     {
          skip 
     };
     if(addimp_ptr->cheight % 2!=0) then 
     {
         addimp_termptr->typos[1]:=addimp_termptr->typos[1]+1
         
     }
     else 
     {
          skip 
     };
     addimp_pin:=addimp_termptr->cellterm;
     addimp_nptr:=netarray[net]->netptr;
     while(addimp_nptr->nterm!=NULL)
     {
         addimp_nptr:=addimp_nptr->nterm
         
     };
     addimp_nptr->nterm:=(netbox*)safe_malloc(sizeof(netbox),RValue);
	 addimp_nptr<==addimp_nptr->nterm and skip;
     tearray[addimp_pin]:=addimp_nptr;
     addimp_nptr->terminal:=addimp_pin;
     addimp_nptr->flag:=0;
     addimp_nptr->row:=row;
     addimp_nptr->cell:=addimp_realcell;
     addimp_nptr->net:=net;
     addimp_nptr->extint:=addimp_termptr->ei;
     addimp_nptr->unequiv:=addimp_termptr->ue;
     addimp_nptr->layer:=addimp_tipptr->layer;
     addimp_n1ptr:=addimp_nptr;
     addimp_termptr:=addimp_termptr->nextterm;
     addimp_termptr->txpos[0]:=addimp_bipptr->ixpos;
     addimp_termptr->typos[0]:=addimp_bipptr->iypos;
     addimp_termptr->txpos[1]:=-addimp_termptr->txpos[0];
     addimp_termptr->typos[1]:=-addimp_termptr->typos[0];
     if(addimp_ptr->clength % 2!=0) then 
     {
         addimp_termptr->txpos[1]:=addimp_termptr->txpos[1]+1
         
     }
     else 
     {
          skip 
     };
     if(addimp_ptr->cheight % 2!=0) then 
     {
         addimp_termptr->typos[1]:=addimp_termptr->typos[1]+1
         
     }
     else 
     {
          skip 
     };
     addimp_pin:=addimp_termptr->cellterm;
     addimp_nptr->nterm:=(netbox*)safe_malloc(sizeof(netbox),RValue);
	 addimp_nptr<==addimp_nptr->nterm and skip;
     tearray[addimp_pin]:=addimp_nptr;
     addimp_nptr->nterm:=NULL;
     addimp_nptr->terminal:=addimp_pin;
     addimp_nptr->flag:=0;
     addimp_nptr->row:=row;
     addimp_nptr->cell:=addimp_realcell;
     addimp_nptr->net:=net;
     addimp_nptr->extint:=addimp_termptr->ei;
     addimp_nptr->unequiv:=addimp_termptr->ue;
     addimp_nptr->layer:=addimp_bipptr->layer;
     addimp_n2ptr:=addimp_nptr;
     addimp_orient:=addimp_ptr->corient;
     if(addimp_orient=0 OR addimp_orient=2) then 
     {
         addimp_n1ptr->pinloc:=1;
         addimp_n2ptr->pinloc:=-1
         
     }
     else
     {
         addimp_n1ptr->pinloc:=-1;
         addimp_n2ptr->pinloc:=1
     };
      return<==1 and skip
     )
     }; 
  function alignfeed ( int RValue )
 {
     frame(alignfeed_row,alignfeed_last_up,alignfeed_last_dn,alignfeed_up,alignfeed_dn,alignfeed_cell_up,alignfeed_cell_dn,alignfeed_net_up,alignfeed_net_dn,alignfeed_x_up,alignfeed_distance,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     int alignfeed_row,alignfeed_last_up,alignfeed_last_dn,alignfeed_up,alignfeed_dn,alignfeed_cell_up,alignfeed_cell_dn and skip;
     int alignfeed_net_up,alignfeed_net_dn,alignfeed_x_up,alignfeed_distance and skip;
     alignfeed_distance:=0;
     alignfeed_row:=numRows-1;
     
     while(alignfeed_row>=1)
     {
         alignfeed_last_up:=pairArray[alignfeed_row+1,0];
         alignfeed_last_dn:=pairArray[alignfeed_row,0];
         continue<==0 and skip;
         alignfeed_up:=1;
         
         while(alignfeed_up<=alignfeed_last_up)
         {
              continue<==0 and skip;
             alignfeed_cell_up:=pairArray[alignfeed_row+1,alignfeed_up];
             if(alignfeed_cell_up>=numcells-fdthrus+1) then 
             {
                 if(carray[alignfeed_cell_up]->tileptr->termsptr=NULL) then 
                 {
                     continue<==1 and skip;
                      alignfeed_up:=alignfeed_up+1
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     alignfeed_net_up:=tearray[carray[alignfeed_cell_up]->tileptr->termsptr->cellterm]->net;
                     alignfeed_x_up:=carray[alignfeed_cell_up]->cxcenter;
                     continue<==0 and skip;
                     break$<==0 and skip;
                     alignfeed_dn:=1;
                     
                     while( break$=0 AND  alignfeed_dn<=alignfeed_last_dn)
                     {
                          continue<==0 and skip;
                         alignfeed_cell_dn:=pairArray[alignfeed_row,alignfeed_dn];
                         if(alignfeed_cell_dn>=numcells-fdthrus+1) then 
                         {
                             if(carray[alignfeed_cell_dn]->tileptr->termsptr=NULL) then 
                             {
                                 continue<==1 and skip;
                                  alignfeed_dn:=alignfeed_dn+1
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)   then 
                             {
                                 alignfeed_net_dn:=tearray[carray[alignfeed_cell_dn]->tileptr->termsptr->cellterm]->net;
                                 if(alignfeed_net_dn!=alignfeed_net_up) then 
                                 {
                                     continue<==1 and skip;
                                      alignfeed_dn:=alignfeed_dn+1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(continue=0)   then 
                                 {
                                     alignfeed_distance:=alignfeed_distance+re_place(pairArray[alignfeed_row],alignfeed_cell_dn,alignfeed_dn,alignfeed_x_up,RValue);
                                     break$<==1 and skip
                                  }
                                 else
                                 {
                                     skip
                                 }
                             }
                             else
                             {
                                 skip
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             if(continue=0)  then
                             {
                                 alignfeed_dn:=alignfeed_dn+1
                             }
                             else
                             {
                                 skip
                             }
                         }
                         else
                         {
                             skip
                         }
                     };
                     break$<==0 and skip;
                     continue<==0 and skip
                 }
                 else
                 {
                     skip
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(continue=0)  then
             {
                 alignfeed_up:=alignfeed_up+1
             }
             else
             {
                 skip
             }
             
         };
         continue<==0 and skip;
         alignfeed_row:=alignfeed_row-1
         
     };
     return<==1 and RValue:=alignfeed_distance;
     skip
     )
     }; 
  function re_place ( int *rowptr,int cell,int index,int x_location,int RValue )
 {
     frame(re_place_i,re_place_j,re_place_last,re_place_prev_x,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     int re_place_i,re_place_j,re_place_last,re_place_prev_x and skip;
     re_place_last:=rowptr[0];
     if(carray[rowptr[1]]->cxcenter>=x_location) then 
     {
         re_place_i:=0
         
     }
     else
     {
         if(carray[rowptr[re_place_last]]->cxcenter<=x_location) then 
         {
             re_place_i:=re_place_last
         }
         else
         {
             break$<==0 and skip;
             re_place_i:=1;
             
             while( break$=0 AND  re_place_i<re_place_last)
             {
                 if(carray[rowptr[re_place_i]]->cxcenter<=x_location AND carray[rowptr[re_place_i+1]]->cxcenter>=x_location) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     re_place_i:=re_place_i+1
                 }
                 else
                 {
                     skip
                 }
             };
             break$<==0 and skip
         }
     };
     re_place_prev_x:=carray[cell]->cxcenter;
     if(index>re_place_i+1) then 
     {
         re_place_j:=index-1;
         
         while(re_place_j>=re_place_i+1)
         {
             carray[rowptr[re_place_j]]->cxcenter:=carray[rowptr[re_place_j]]->cxcenter+fdWidth;
             rowptr[re_place_j+1]:=rowptr[re_place_j];
             re_place_j:=re_place_j-1
             
         };
         rowptr[re_place_i+1]:=cell;
         carray[cell]->cxcenter:=carray[rowptr[re_place_i+2]]->cxcenter+carray[rowptr[re_place_i+2]]->tileptr->left-(fdWidth-fdWidth/ 2)
         
     }
     else
     {
         if(index<re_place_i) then 
         {
             re_place_j:=index+1;
             
             while(re_place_j<=re_place_i)
             {
                 carray[rowptr[re_place_j]]->cxcenter:=carray[rowptr[re_place_j]]->cxcenter-fdWidth;
                 rowptr[re_place_j-1]:=rowptr[re_place_j];
                 re_place_j:=re_place_j+1
                 
             };
             rowptr[re_place_i]:=cell;
             carray[cell]->cxcenter:=carray[rowptr[re_place_i-1]]->cxcenter+carray[rowptr[re_place_i-1]]->tileptr->right+fdWidth/ 2
             
         }
         else 
         {
              skip 
         }
     };
     return<==1 and RValue:=(ABS(carray[cell]->cxcenter-re_place_prev_x,RValue));
     skip
     )
     }; 
  function align_init (  )
 {
     frame(align_init_row,align_init_i,align_init_cell,align_init_rowptr,align_init_j,align_init_last,align_init_width,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     int align_init_row,align_init_i,align_init_cell,*align_init_rowptr,align_init_j,align_init_last,align_init_width and skip;
     align_init_row:=1;
     

     while(align_init_row<=numRows)
     {
         align_init_last:=pairArray[align_init_row,0];
         break$<==0 and skip;
         align_init_i:=1;
         
         while( break$=0 AND  align_init_i<=align_init_last)
         {
             align_init_cell:=pairArray[align_init_row,align_init_i];
             if(align_init_cell<numcells-fdthrus+1) then 
             {
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then
             {
                 align_init_i:=align_init_i+1
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
         if(align_init_i>1 AND align_init_i<=align_init_last) then 
         {
             align_init_rowptr:=pairArray[align_init_row];
             align_init_width:=carray[align_init_cell]->tileptr->right-carray[align_init_cell]->tileptr->left;
             align_init_j:=align_init_i-1;
             
             while(align_init_j>=1)
             {
			     printf("width: %d", align_init_width) and skip;
                 carray[align_init_rowptr[align_init_j]]->cxcenter:=carray[align_init_rowptr[align_init_j]]->cxcenter+align_init_width;
                 align_init_rowptr[align_init_j+1]:=align_init_rowptr[align_init_j];
                 align_init_j:=align_init_j-1
                 
             };
             align_init_rowptr[1]:=align_init_cell;
             carray[align_init_cell]->cxcenter:=carray[align_init_rowptr[2]]->cxcenter+carray[align_init_rowptr[2]]->tileptr->left-(align_init_width-align_init_width/ 2)
             
         }
         else 
         {
              skip 
         };
         break$<==0 and skip;
         align_init_i:=align_init_last;
         
         while( break$=0 AND  align_init_i>=1)
         {
             align_init_cell:=pairArray[align_init_row,align_init_i];
             if(align_init_cell<numcells-fdthrus+1) then 
             {
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then
             {
                 align_init_i:=align_init_i-1
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
         if(align_init_i<align_init_last AND align_init_i>=1) then 
         {
             align_init_rowptr:=pairArray[align_init_row];
             align_init_width:=carray[align_init_cell]->tileptr->right-carray[align_init_cell]->tileptr->left;
             align_init_j:=align_init_i+1;
             
             while(align_init_j<=align_init_last)
             {
                 carray[align_init_rowptr[align_init_j]]->cxcenter:=carray[align_init_rowptr[align_init_j]]->cxcenter-align_init_width;
                 align_init_rowptr[align_init_j-1]:=align_init_rowptr[align_init_j];
                 align_init_j:=align_init_j+1
                 
             };
             align_init_rowptr[align_init_last]:=align_init_cell;
             carray[align_init_cell]->cxcenter:=carray[align_init_rowptr[align_init_last-1]]->cxcenter+carray[align_init_rowptr[align_init_last-1]]->tileptr->right+align_init_width/ 2
             
         }
         else 
         {
              skip 
         };
         align_init_row:=align_init_row+1
         
     };
      return<==1 and skip
     )
     }; 


 ipbox* xipptr and skip;
 function buildimp ( int icell,int xrel,int yrel,char pname[],int flag,int layer )
 {
     frame(buildimp_ptr,buildimp_iptr,buildimp_row,buildimp_1_temp$_1,buildimp_5_temp$_2,return) and ( 
     int return<==0 and skip;
     cellbox* buildimp_ptr and skip;
     ibox* buildimp_iptr and skip;
     int buildimp_row and skip;
     if(flag=1) then 
     {
         buildimp_ptr:=carray[icell];
         buildimp_row:=blkToRow[buildimp_ptr->cblock];
         buildimp_iptr:=impFeeds[buildimp_row];
         if(buildimp_iptr!=(ibox*)NULL) then 
         {
             while(buildimp_iptr->niptr!=(ibox*)NULL)
             {
                 buildimp_iptr:=buildimp_iptr->niptr
             };
             buildimp_iptr->niptr:=(ibox*)safe_malloc(sizeof(ibox),RValue);
             buildimp_iptr:=buildimp_iptr->niptr
             
         }
         else
         {
             impFeeds[buildimp_row]:=(ibox*)safe_malloc(sizeof(ibox),RValue);
             buildimp_iptr:=impFeeds[buildimp_row]
         };
         buildimp_iptr->icell:=icell;
         buildimp_iptr->iactive:=0;
         buildimp_iptr->aveXpos:=buildimp_ptr->cxcenter+xrel;
         buildimp_iptr->niptr:=(ibox*)NULL;
         buildimp_iptr->iptr:=(ipbox*)safe_malloc(sizeof(ipbox),RValue);
         xipptr:=buildimp_iptr->iptr;
         xipptr->ixpos:=xrel;
         xipptr->iypos:=yrel;
         xipptr->layer:=layer;
         int buildimp_1_temp$_1 and skip;
         buildimp_1_temp$_1:=strlen(pname);
         xipptr->ipname:=(char *)safe_malloc((buildimp_1_temp$_1+1)*sizeof(char),RValue);
         sprintf(xipptr->ipname,"%s",pname,RValue) and skip;
         xipptr->npin:=(ipbox*)NULL
         
     }
     else
     {
         xipptr->npin:=(ipbox*)safe_malloc(sizeof(ipbox),RValue);
         xipptr:=xipptr->npin;
         xipptr->ixpos:=xrel;
         xipptr->iypos:=yrel;
         xipptr->layer:=layer;
         int buildimp_5_temp$_2 and skip;
         buildimp_5_temp$_2:=strlen(pname);
         xipptr->ipname:=(char *)safe_malloc((buildimp_5_temp$_2+1)*sizeof(char),RValue);
         sprintf(xipptr->ipname,"%s",pname,RValue) and skip;
         xipptr->npin:=(ipbox*)NULL
     };
      return<==1 and skip
     )
     }; 
  function build_feed_imp ( int feed,int x,int row )
 {
     frame(build_feed_imp_iptr,build_feed_imp_pname,build_feed_imp_temp$_1,build_feed_imp_temp$_2,return) and ( 
     int return<==0 and skip;
     ibox* build_feed_imp_iptr and skip;
     char build_feed_imp_pname[128] and skip;
     build_feed_imp_iptr:=impFeeds[row];
     if(build_feed_imp_iptr!=(ibox*)NULL) then 
     {
         while(build_feed_imp_iptr->niptr!=(ibox*)NULL)
         {
             build_feed_imp_iptr:=build_feed_imp_iptr->niptr
         };
         build_feed_imp_iptr->niptr:=(ibox*)safe_malloc(sizeof(ibox),RValue);
         build_feed_imp_iptr:=build_feed_imp_iptr->niptr
         
     }
     else
     {
         impFeeds[row]:=(ibox*)safe_malloc(sizeof(ibox),RValue);
         build_feed_imp_iptr:=impFeeds[row]
     };
     build_feed_imp_iptr->icell:=numcells+feed;
     build_feed_imp_iptr->iactive:=-1;
     build_feed_imp_iptr->aveXpos:=x-fdWidth/ 2;
     build_feed_imp_iptr->niptr:=(ibox*)NULL;
     build_feed_imp_iptr->iptr:=(ipbox*)safe_malloc(sizeof(ipbox),RValue);
     xipptr:=build_feed_imp_iptr->iptr;
     xipptr->ixpos:=-fdWidth/ 2;
     xipptr->iypos:=barray[1]->bheight-barray[1]->bheight/ 2;
     xipptr->layer:=0;
     sprintf(build_feed_imp_pname,"%s.%d","twfeed",feed,RValue) and skip;
     int build_feed_imp_temp$_1 and skip;
     build_feed_imp_temp$_1:=strlen(build_feed_imp_pname);
     xipptr->ipname:=(char *)safe_malloc((build_feed_imp_temp$_1+1)*sizeof(char),RValue);
     sprintf(xipptr->ipname,"%s",build_feed_imp_pname,RValue) and skip;
     xipptr->npin:=(ipbox*)safe_malloc(sizeof(ipbox),RValue);
	 xipptr<==xipptr->npin and skip;
     xipptr->ixpos:=-fdWidth/ 2;
     xipptr->iypos:=-barray[1]->bheight/ 2;
     xipptr->layer:=0;
     int build_feed_imp_temp$_2 and skip;
     build_feed_imp_temp$_2:=strlen(build_feed_imp_pname);
     xipptr->ipname:=(char *)safe_malloc((build_feed_imp_temp$_2+1)*sizeof(char),RValue);
     sprintf(xipptr->ipname,"%s",build_feed_imp_pname,RValue) and skip;
     xipptr->npin:=(ipbox*)NULL;
      return<==1 and skip
     )
     }; 
      struct tgridbox {
     changrdbox* up and 
     changrdbox* down 
 };
 struct densitybox {
 changrdbox* grdptr and 
 struct densitybox* next$ and 
 struct densitybox* nnext and 
 struct densitybox* back and 
 struct densitybox* nback 
 };
 struct segbox {
 int channel and 
 int pin1 and 
 int pin2 and 
 changrdbox* pin1ptr and 
 changrdbox* pin2ptr 
 };
 struct switchbox {
 int net and 
 char nflag and 
 char ncurrent and 
 char nswYorN and 
 char current and 
 char swYorN and 
 int key and 
 int nkey and 
 segbox* ntop and 
 segbox* nbot and 
 segbox* top and 
 segbox* bot 
 };
 function changrid (  )
 {
     frame(changrid_gdptr,changrid_grdptr,changrid_cgdptr,changrid_ngdptr,changrid_netptr,changrid_row,changrid_net,changrid_channel,changrid_terminal,changrid_numPins,changrid_PinInChan,changrid_count,changrid_i) and ( 
     changrdbox* **changrid_gdptr,*changrid_grdptr,*changrid_cgdptr,*changrid_ngdptr and skip;
     netbox* changrid_netptr and skip;
     int changrid_row,changrid_net,changrid_channel,changrid_terminal and skip;
     int *changrid_numPins,*changrid_PinInChan and skip;
     int changrid_count,changrid_i and skip;
     changrid_numPins:=(int *)safe_calloc(sizeof(int),numChans+1,RValue);
     changrid_PinInChan:=(int *)safe_calloc(sizeof(int),numChans+1,RValue);
     changrid_net:=1;
     
     while(changrid_net<=numnets)
     {
         changrid_netptr:=netarray[changrid_net]->netptr;
         
         while(changrid_netptr!=NULL)
         {
             if((int)changrid_netptr->pinloc=-1) then 
             {
                 changrid_numPins[changrid_netptr->row]:=changrid_numPins[changrid_netptr->row]+1
                 
             }
             else
             {
                 if(changrid_netptr->pinloc=1) then 
                 {
                     changrid_numPins[changrid_netptr->row+1]:=changrid_numPins[changrid_netptr->row+1]+1
                 }
                 else
                 {
                     if(changrid_netptr->row>0) then 
                     {
                         changrid_numPins[changrid_netptr->row]:=changrid_numPins[changrid_netptr->row]+1
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(changrid_netptr->row<numChans) then 
                     {
                         changrid_numPins[changrid_netptr->row+1]:=changrid_numPins[changrid_netptr->row+1]+1
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
             };
             changrid_netptr:=changrid_netptr->nterm
             
         };
         changrid_net:=changrid_net+1
         
     };
     changrid_gdptr:=safe_malloc((numChans+1)*4,RValue);
     changrid_channel:=1;
     
     while(changrid_channel<=numChans)
     {
         changrid_gdptr[changrid_channel]:=(changrdbox* *)safe_malloc((changrid_numPins[changrid_channel]+1)*sizeof(changrdbox*),RValue);
         changrid_channel:=changrid_channel+1
         
     };
     Tgrid:=(tgridbox* *)safe_malloc((maxterm+2*numChans+1)*sizeof(tgridbox*),RValue);
     changrid_terminal:=1;
     
     while(changrid_terminal<=maxterm+2*numChans)
     {
         Tgrid[changrid_terminal]:=(tgridbox*)safe_malloc(sizeof(tgridbox),RValue);
         changrid_terminal:=changrid_terminal+1
         
     };
     changrid_net:=1;
     
     while(changrid_net<=numnets)
     {
         changrid_netptr:=netarray[changrid_net]->netptr;
         
         while(changrid_netptr!=NULL)
         {
             changrid_row:=changrid_netptr->row;
             changrid_terminal:=changrid_netptr->terminal;
             changrid_grdptr:=(changrdbox*)safe_malloc(sizeof(changrdbox),RValue);
             if((int)changrid_netptr->pinloc=-1) then 
             {
                 changrid_channel:=changrid_row;
                 changrid_count:=((changrid_PinInChan[changrid_channel])+1);
                 (changrid_PinInChan[changrid_channel]):=(changrid_PinInChan[changrid_channel])+1;
                 changrid_gdptr[changrid_channel,changrid_count]:=changrid_grdptr;
                 Tgrid[changrid_terminal]->up:=changrid_grdptr;
                 Tgrid[changrid_terminal]->down:=changrid_grdptr;
                 changrid_grdptr->netptr:=tearray[changrid_terminal];
                 changrid_grdptr->tracks:=0;
                 changrid_grdptr->SegType:=0
                 
             }
             else
             {
                 if(changrid_netptr->pinloc=1) then 
                 {
                     changrid_channel:=changrid_row+1;
                     changrid_count:=((changrid_PinInChan[changrid_channel])+1);
                     (changrid_PinInChan[changrid_channel]):=(changrid_PinInChan[changrid_channel])+1;
                     changrid_gdptr[changrid_channel,changrid_count]:=changrid_grdptr;
                     Tgrid[changrid_terminal]->up:=changrid_grdptr;
                     Tgrid[changrid_terminal]->down:=changrid_grdptr;
                     changrid_grdptr->netptr:=tearray[changrid_terminal];
                     changrid_grdptr->tracks:=0;
                     changrid_grdptr->SegType:=0
                 }
                 else
                 {
                     if(1<=changrid_row AND changrid_row<=numChans-1) then 
                     {
                         changrid_channel:=changrid_row;
                         changrid_count:=((changrid_PinInChan[changrid_channel])+1);
                         (changrid_PinInChan[changrid_channel]):=(changrid_PinInChan[changrid_channel])+1;
                         changrid_gdptr[changrid_channel,changrid_count]:=changrid_grdptr;
                         Tgrid[changrid_terminal]->down:=changrid_grdptr;
                         changrid_grdptr->netptr:=tearray[changrid_terminal];
                         changrid_grdptr->tracks:=0;
                         changrid_grdptr->SegType:=0;
                         changrid_channel:=changrid_row+1;
                         changrid_count:=((changrid_PinInChan[changrid_channel])+1);
                         (changrid_PinInChan[changrid_channel]):=(changrid_PinInChan[changrid_channel])+1;
                         changrid_gdptr[changrid_channel,changrid_count]:=(changrdbox*)safe_malloc(sizeof(changrdbox),RValue);
						 changrid_grdptr<==changrid_gdptr[changrid_channel,changrid_count] and skip;
                         Tgrid[changrid_terminal]->up:=changrid_grdptr;
                         changrid_grdptr->netptr:=tearray[changrid_terminal];
                         changrid_grdptr->tracks:=0;
                         changrid_grdptr->SegType:=0
                     }
                     else
                     {
                         if(changrid_row=0) then 
                         {
                             changrid_count:=((changrid_PinInChan[1])+1);
                             (changrid_PinInChan[1]):=(changrid_PinInChan[1])+1;
                             changrid_gdptr[1,changrid_count]:=changrid_grdptr;
                             Tgrid[changrid_terminal]->up:=changrid_grdptr;
                             Tgrid[changrid_terminal]->down:=changrid_grdptr;
                             changrid_grdptr->netptr:=tearray[changrid_terminal];
                             changrid_grdptr->tracks:=0;
                             changrid_grdptr->SegType:=0
                         }
                         else
                         {
                             changrid_count:=((changrid_PinInChan[numChans])+1);
                             (changrid_PinInChan[numChans]):=(changrid_PinInChan[numChans])+1;
                             changrid_gdptr[numChans,changrid_count]:=changrid_grdptr;
                             Tgrid[changrid_terminal]->up:=changrid_grdptr;
                             Tgrid[changrid_terminal]->down:=changrid_grdptr;
                             changrid_grdptr->netptr:=tearray[changrid_terminal];
                             changrid_grdptr->tracks:=0;
                             changrid_grdptr->SegType:=0
                         }
                     }
                 }
             };
             changrid_netptr:=changrid_netptr->nterm
             
         };
         changrid_net:=changrid_net+1
         
     };
     changrid_channel:=1;
     
     while(changrid_channel<=numChans)
     {
         qsortgdx((char *)(changrid_gdptr[changrid_channel]+1),changrid_numPins[changrid_channel],sizeof(changrdbox*),RValue);
         changrid_channel:=changrid_channel+1
         
     };
     Begin:=(changrdbox* *)safe_malloc((numChans+1)*sizeof(changrdbox*),RValue);
     End:=(changrdbox* *)safe_malloc((numChans+1)*sizeof(changrdbox*),RValue);
     changrid_channel:=1;
     
     while(changrid_channel<=numChans)
     {
         Begin[changrid_channel]:=(changrdbox*)safe_calloc(sizeof(changrdbox),1,RValue);
         Begin[changrid_channel]->netptr:=(netbox*)safe_calloc(sizeof(netbox),1,RValue);
         Begin[changrid_channel]->netptr->xpos:=gxstart-1;
         Begin[changrid_channel]->netptr->terminal:=maxterm+changrid_channel;
         Begin[changrid_channel]->netptr->row:=changrid_channel;
         Begin[changrid_channel]->netptr->pinloc:=-1;
         tearray[maxterm+changrid_channel]:=Begin[changrid_channel]->netptr;
         End[changrid_channel]:=(changrdbox*)safe_calloc(sizeof(changrdbox),1,RValue);
         End[changrid_channel]->netptr:=(netbox*)safe_calloc(sizeof(netbox),1,RValue);
         End[changrid_channel]->netptr->xpos:=gxstop+1;
         End[changrid_channel]->netptr->terminal:=maxterm+numChans+changrid_channel;
         End[changrid_channel]->netptr->row:=changrid_channel;
         End[changrid_channel]->netptr->pinloc:=-1;
         tearray[maxterm+numChans+changrid_channel]:=End[changrid_channel]->netptr;
         changrid_channel:=changrid_channel+1
         
     };
     changrid_channel:=1;
     
     while(changrid_channel<=numChans)
     {
         Tgrid[maxterm+changrid_channel]->up:=Begin[changrid_channel];
         Tgrid[maxterm+changrid_channel]->down:=Begin[changrid_channel];
         Tgrid[maxterm+numChans+changrid_channel]->up:=End[changrid_channel];
         Tgrid[maxterm+numChans+changrid_channel]->down:=End[changrid_channel];
         changrid_channel:=changrid_channel+1
         
     };
     changrid_channel:=1;
     
     while(changrid_channel<=numChans)
     {
         if(changrid_numPins[changrid_channel]=0) then 
         {
             Begin[changrid_channel]->nextgrd:=NULL;
             End[changrid_channel]->prevgrd:=NULL
             
         }
         else
         {
             if(changrid_numPins[changrid_channel]=1) then 
             {
                 Begin[changrid_channel]->nextgrd:=changrid_gdptr[changrid_channel,1];
                 changrid_gdptr[changrid_channel,1]->prevgrd:=Begin[changrid_channel];
                 End[changrid_channel]->prevgrd:=changrid_gdptr[changrid_channel,1];
                 changrid_gdptr[changrid_channel,1]->nextgrd:=End[changrid_channel]
             }
             else
             {
                 Begin[changrid_channel]->nextgrd:=changrid_gdptr[changrid_channel,1];
                 changrid_gdptr[changrid_channel,1]->prevgrd:=Begin[changrid_channel];
                 changrid_i:=1;
                 
                 while(changrid_i<=changrid_numPins[changrid_channel]-1)
                 {
                     changrid_cgdptr:=changrid_gdptr[changrid_channel,changrid_i];
                     changrid_ngdptr:=changrid_gdptr[changrid_channel,changrid_i+1];
                     changrid_cgdptr->nextgrd:=changrid_ngdptr;
                     changrid_ngdptr->prevgrd:=changrid_cgdptr;
                     changrid_i:=changrid_i+1
                     
                 };
                 changrid_ngdptr->nextgrd:=End[changrid_channel];
                 End[changrid_channel]->prevgrd:=changrid_ngdptr
             }
         };
         changrid_channel:=changrid_channel+1
         
     };
     changrid_channel:=1;
     
     while(changrid_channel<=numChans)
     {
         safe_free(changrid_gdptr[changrid_channel],RValue);
         changrid_channel:=changrid_channel+1
         
     };
     safe_free(changrid_gdptr,RValue);
     safe_cfree(changrid_numPins,RValue);
     safe_cfree(changrid_PinInChan,RValue)
     )
     }; 
  function new_old ( int c )
 {
     frame(new_old_old,new_old_new) and ( 
     int new_old_old,new_old_new and skip;
     if(ablock!=bblock) then 
     {
         barray[ablock]->newsize:=barray[ablock]->oldsize+c;
         barray[bblock]->newsize:=barray[bblock]->oldsize-c;
         new_old_old:=extern ABS(barray[ablock]->oldsize-barray[ablock]->desire,RValue)+extern ABS(barray[bblock]->oldsize-barray[bblock]->desire,RValue);
         new_old_new:=extern ABS(barray[ablock]->newsize-barray[ablock]->desire,RValue)+extern ABS(barray[bblock]->newsize-barray[bblock]->desire,RValue);
         newrowpenal:=newrowpenal+(new_old_new-new_old_old)
         
     }
     else 
     {
          skip 
     }
     )
     }; 
  function old_assgnto_new1 ( int alobin,int ahibin,int anewlobin,int anewhibin )
 {
     frame(old_assgnto_new1_bin,old_assgnto_new1_lobin,old_assgnto_new1_hibin) and ( 
     int old_assgnto_new1_bin,old_assgnto_new1_lobin,old_assgnto_new1_hibin and skip;
     if(ablock=bblock) then 
     {
         old_assgnto_new1_lobin:=( if((alobin<=anewlobin)) then alobin else anewlobin);
         old_assgnto_new1_hibin:=( if((ahibin>=anewhibin)) then ahibin else anewhibin);
         old_assgnto_new1_bin:=old_assgnto_new1_lobin;
         
         while(old_assgnto_new1_bin<=old_assgnto_new1_hibin)
         {
             binptr[ablock,old_assgnto_new1_bin]->nupenalty:=binptr[ablock,old_assgnto_new1_bin]->penalty;
             old_assgnto_new1_bin:=old_assgnto_new1_bin+1
             
         }
     }
     else
     {
         old_assgnto_new1_bin:=alobin;
         
         while(old_assgnto_new1_bin<=ahibin)
         {
             binptr[ablock,old_assgnto_new1_bin]->nupenalty:=binptr[ablock,old_assgnto_new1_bin]->penalty;
             old_assgnto_new1_bin:=old_assgnto_new1_bin+1
             
         };
         old_assgnto_new1_bin:=anewlobin;
         
         while(old_assgnto_new1_bin<=anewhibin)
         {
             binptr[bblock,old_assgnto_new1_bin]->nupenalty:=binptr[bblock,old_assgnto_new1_bin]->penalty;
             old_assgnto_new1_bin:=old_assgnto_new1_bin+1
             
         }
     }
     )
     }; 
  function new_assgnto_old1 ( int alobin,int ahibin,int anewlobin,int anewhibin )
 {
     frame(new_assgnto_old1_bin,new_assgnto_old1_lobin,new_assgnto_old1_hibin) and ( 
     int new_assgnto_old1_bin,new_assgnto_old1_lobin,new_assgnto_old1_hibin and skip;
     if(ablock=bblock) then 
     {
         new_assgnto_old1_lobin:=( if((alobin<=anewlobin)) then alobin else anewlobin);
         new_assgnto_old1_hibin:=( if((ahibin>=anewhibin)) then ahibin else anewhibin);
         new_assgnto_old1_bin:=new_assgnto_old1_lobin;
         
         while(new_assgnto_old1_bin<=new_assgnto_old1_hibin)
         {
             binptr[ablock,new_assgnto_old1_bin]->penalty:=binptr[ablock,new_assgnto_old1_bin]->nupenalty;
             new_assgnto_old1_bin:=new_assgnto_old1_bin+1
             
         }
     }
     else
     {
         new_assgnto_old1_bin:=alobin;
         
         while(new_assgnto_old1_bin<=ahibin)
         {
             binptr[ablock,new_assgnto_old1_bin]->penalty:=binptr[ablock,new_assgnto_old1_bin]->nupenalty;
             new_assgnto_old1_bin:=new_assgnto_old1_bin+1
             
         };
         new_assgnto_old1_bin:=anewlobin;
         
         while(new_assgnto_old1_bin<=anewhibin)
         {
             binptr[bblock,new_assgnto_old1_bin]->penalty:=binptr[bblock,new_assgnto_old1_bin]->nupenalty;
             new_assgnto_old1_bin:=new_assgnto_old1_bin+1
             
         }
     }
     )
     }; 
  function old_assgnto_new2 ( int a1lobin,int a1hibin,int a2lobin,int a2hibin,int b1lobin,int b1hibin,int b2lobin,int b2hibin )
 {
     frame(old_assgnto_new2_clobin,old_assgnto_new2_chibin,old_assgnto_new2_dlobin,old_assgnto_new2_dhibin,old_assgnto_new2_lobin,old_assgnto_new2_hibin,old_assgnto_new2_bin) and ( 
     int old_assgnto_new2_clobin,old_assgnto_new2_chibin,old_assgnto_new2_dlobin,old_assgnto_new2_dhibin and skip;
     int old_assgnto_new2_lobin,old_assgnto_new2_hibin,old_assgnto_new2_bin and skip;
     old_assgnto_new2_clobin:=( if((a1lobin<=b2lobin)) then a1lobin else b2lobin);
     old_assgnto_new2_chibin:=( if((a1hibin>=b2hibin)) then a1hibin else b2hibin);
     old_assgnto_new2_dlobin:=( if((a2lobin<=b1lobin)) then a2lobin else b1lobin);
     old_assgnto_new2_dhibin:=( if((a2hibin>=b1hibin)) then a2hibin else b1hibin);
     if(ablock=bblock) then 
     {
         old_assgnto_new2_lobin:=( if((old_assgnto_new2_clobin<=old_assgnto_new2_dlobin)) then old_assgnto_new2_clobin else old_assgnto_new2_dlobin);
         old_assgnto_new2_hibin:=( if((old_assgnto_new2_chibin>=old_assgnto_new2_dhibin)) then old_assgnto_new2_chibin else old_assgnto_new2_dhibin);
         old_assgnto_new2_bin:=old_assgnto_new2_lobin;
         
         while(old_assgnto_new2_bin<=old_assgnto_new2_hibin)
         {
             binptr[ablock,old_assgnto_new2_bin]->nupenalty:=binptr[ablock,old_assgnto_new2_bin]->penalty;
             old_assgnto_new2_bin:=old_assgnto_new2_bin+1
             
         }
     }
     else
     {
         old_assgnto_new2_bin:=old_assgnto_new2_clobin;
         
         while(old_assgnto_new2_bin<=old_assgnto_new2_chibin)
         {
             binptr[ablock,old_assgnto_new2_bin]->nupenalty:=binptr[ablock,old_assgnto_new2_bin]->penalty;
             old_assgnto_new2_bin:=old_assgnto_new2_bin+1
             
         };
         old_assgnto_new2_bin:=old_assgnto_new2_dlobin;
         
         while(old_assgnto_new2_bin<=old_assgnto_new2_dhibin)
         {
             binptr[bblock,old_assgnto_new2_bin]->nupenalty:=binptr[bblock,old_assgnto_new2_bin]->penalty;
             old_assgnto_new2_bin:=old_assgnto_new2_bin+1
             
         }
     }
     )
     }; 
  function new_assgnto_old2 ( int a1lobin,int a1hibin,int a2lobin,int a2hibin,int b1lobin,int b1hibin,int b2lobin,int b2hibin )
 {
     frame(new_assgnto_old2_clobin,new_assgnto_old2_chibin,new_assgnto_old2_dlobin,new_assgnto_old2_dhibin,new_assgnto_old2_lobin,new_assgnto_old2_hibin,new_assgnto_old2_bin) and ( 
     int new_assgnto_old2_clobin,new_assgnto_old2_chibin,new_assgnto_old2_dlobin,new_assgnto_old2_dhibin and skip;
     int new_assgnto_old2_lobin,new_assgnto_old2_hibin,new_assgnto_old2_bin and skip;
     new_assgnto_old2_clobin:=( if((a1lobin<=b2lobin)) then a1lobin else b2lobin);
     new_assgnto_old2_chibin:=( if((a1hibin>=b2hibin)) then a1hibin else b2hibin);
     new_assgnto_old2_dlobin:=( if((a2lobin<=b1lobin)) then a2lobin else b1lobin);
     new_assgnto_old2_dhibin:=( if((a2hibin>=b1hibin)) then a2hibin else b1hibin);
     if(ablock=bblock) then 
     {
         new_assgnto_old2_lobin:=( if((new_assgnto_old2_clobin<=new_assgnto_old2_dlobin)) then new_assgnto_old2_clobin else new_assgnto_old2_dlobin);
         new_assgnto_old2_hibin:=( if((new_assgnto_old2_chibin>=new_assgnto_old2_dhibin)) then new_assgnto_old2_chibin else new_assgnto_old2_dhibin);
         new_assgnto_old2_bin:=new_assgnto_old2_lobin;
         
         while(new_assgnto_old2_bin<=new_assgnto_old2_hibin)
         {
             binptr[ablock,new_assgnto_old2_bin]->penalty:=binptr[ablock,new_assgnto_old2_bin]->nupenalty;
             new_assgnto_old2_bin:=new_assgnto_old2_bin+1
             
         }
     }
     else
     {
         new_assgnto_old2_bin:=new_assgnto_old2_clobin;
         
         while(new_assgnto_old2_bin<=new_assgnto_old2_chibin)
         {
             binptr[ablock,new_assgnto_old2_bin]->penalty:=binptr[ablock,new_assgnto_old2_bin]->nupenalty;
             new_assgnto_old2_bin:=new_assgnto_old2_bin+1
             
         };
         new_assgnto_old2_bin:=new_assgnto_old2_dlobin;
         
         while(new_assgnto_old2_bin<=new_assgnto_old2_dhibin)
         {
             binptr[bblock,new_assgnto_old2_bin]->penalty:=binptr[bblock,new_assgnto_old2_bin]->nupenalty;
             new_assgnto_old2_bin:=new_assgnto_old2_bin+1
             
         }
     }
     )
     }; 
  function sub_penal ( int startx,int endx,int block,int LoBin,int HiBin )
 {
     frame(sub_penal_bptr,sub_penal_bin) and ( 
     binbox* sub_penal_bptr and skip;
     int sub_penal_bin and skip;
     if(LoBin=HiBin) then 
     {
         sub_penal_bptr:=binptr[block,LoBin];
         newbinpenal:=newbinpenal-extern ABS(sub_penal_bptr->nupenalty,RValue);
         sub_penal_bptr->nupenalty:=sub_penal_bptr->nupenalty-(endx-startx);
         newbinpenal:=newbinpenal+extern ABS(sub_penal_bptr->nupenalty,RValue)
     }
     else
     {
         sub_penal_bin:=LoBin;
         
         while(sub_penal_bin<=HiBin)
         {
             sub_penal_bptr:=binptr[block,sub_penal_bin];


             if(sub_penal_bin=LoBin) then 
             {
                 newbinpenal:=newbinpenal-extern ABS(sub_penal_bptr->nupenalty,RValue);
                 sub_penal_bptr->nupenalty:=sub_penal_bptr->nupenalty-(sub_penal_bptr->right-startx);
                 newbinpenal:=newbinpenal+extern ABS(sub_penal_bptr->nupenalty,RValue)
                 
             }
             else
             {
                 if(sub_penal_bin=HiBin) then 
                 {
                     newbinpenal:=newbinpenal-extern ABS(sub_penal_bptr->nupenalty,RValue);
                     sub_penal_bptr->nupenalty:=sub_penal_bptr->nupenalty-(endx-sub_penal_bptr->left);
                     newbinpenal:=newbinpenal+extern ABS(sub_penal_bptr->nupenalty,RValue)
                 }
                 else
                 {
                     newbinpenal:=newbinpenal-extern ABS(sub_penal_bptr->nupenalty,RValue);
                     sub_penal_bptr->nupenalty:=sub_penal_bptr->nupenalty-binWidth;
                     newbinpenal:=newbinpenal+extern ABS(sub_penal_bptr->nupenalty,RValue)
                 }
             };
             sub_penal_bin:=sub_penal_bin+1
             
         }
     }
     )
     }; 
  function add_penal ( int startx,int endx,int block,int LoBin,int HiBin )
 {
     frame(add_penal_bptr,add_penal_bin) and ( 
     binbox* add_penal_bptr and skip;
     int add_penal_bin and skip;
     if(LoBin=HiBin) then 
     {
         add_penal_bptr:=binptr[block,LoBin];
         newbinpenal:=newbinpenal-extern ABS(add_penal_bptr->nupenalty,RValue);
         add_penal_bptr->nupenalty:=add_penal_bptr->nupenalty+endx-startx;
         newbinpenal:=newbinpenal+extern ABS(add_penal_bptr->nupenalty,RValue)
     }
     else
     {
         add_penal_bin:=LoBin;
         
         while(add_penal_bin<=HiBin)
         {
             add_penal_bptr:=binptr[block,add_penal_bin];
             if(add_penal_bin=LoBin) then 
             {
                 newbinpenal:=newbinpenal-extern ABS(add_penal_bptr->nupenalty,RValue);
                 add_penal_bptr->nupenalty:=add_penal_bptr->nupenalty+add_penal_bptr->right-startx;
                 newbinpenal:=newbinpenal+extern ABS(add_penal_bptr->nupenalty,RValue)
                 
             }
             else
             {
                 if(add_penal_bin=HiBin) then 
                 {
                     newbinpenal:=newbinpenal-extern ABS(add_penal_bptr->nupenalty,RValue);
                     add_penal_bptr->nupenalty:=add_penal_bptr->nupenalty+endx-add_penal_bptr->left;
                     newbinpenal:=newbinpenal+extern ABS(add_penal_bptr->nupenalty,RValue)
                 }
                 else
                 {
                     newbinpenal:=newbinpenal-extern ABS(add_penal_bptr->nupenalty,RValue);
                     add_penal_bptr->nupenalty:=add_penal_bptr->nupenalty+binWidth;
                     newbinpenal:=newbinpenal+extern ABS(add_penal_bptr->nupenalty,RValue)
                 }
             };
             add_penal_bin:=add_penal_bin+1
             
         }
     }
     )
     }; 
      struct edgeBox {
     int group1 and 
     int group2 and 
     int cost and 
     int marked and 
     int poison and 
     int done 
 };
 struct chkBox {
 int lowx and 
 int highx and 
 int ming and 
 int maxg and 
 int chky 
 };
 struct csPinBox {
 int pin and 
 int xloc and 
 int yloc and 
 int top 
 };
 struct csGroup {
 int extint and 
 int aveX and 
 int aveY and 
 int poison and 
 int edge1 and 
 int edge2 and 
 int unequiv and 
 int block and 
 int check and 
 int numPins and 
 int pinLimit and 
 int flag and 
 csPinBox *pinArray 
 };
 function closepins ( FILE *tw,int net )
 {
     frame(closepins_pin,closepins_pin1,closepins_pin2,closepins_minP1,closepins_minP2,closepins_minX,closepins_sepT,closepins_sepB,closepins_edge,closepins_left,closepins_right,closepins_group1,closepins_group2,closepins_block1,closepins_block2,closepins_p1,closepins_p2,closepins_minTop,closepins_minBottom,closepins_maxTpin,closepins_maxBpin,closepins_otherTpin,closepins_otherBpin,closepins_maxTop,closepins_maxBottom,closepins_key_count,closepins_key_flag,closepins_segment_count,closepins_super_edge,closepins_next_edge,closepins_e1,closepins_e2,closepins_g1,closepins_g2,closepins_next_g,closepins_save_count,closepins_ltop,closepins_rtop,closepins_lbot,closepins_rbot,closepins_pArray1,closepins_pArray2,closepins_pArray,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     int closepins_pin,closepins_pin1,closepins_pin2,closepins_minP1,closepins_minP2,closepins_minX,closepins_sepT,closepins_sepB,closepins_edge and skip;
     int closepins_left,closepins_right,closepins_group1,closepins_group2,closepins_block1,closepins_block2,closepins_p1,closepins_p2 and skip;
     int closepins_minTop,closepins_minBottom,closepins_maxTpin,closepins_maxBpin,closepins_otherTpin and skip;
     int closepins_otherBpin,closepins_maxTop,closepins_maxBottom,closepins_key_count,closepins_key_flag and skip;
     int closepins_segment_count,closepins_super_edge,closepins_next_edge and skip;
     int closepins_e1,closepins_e2,closepins_g1,closepins_g2,closepins_next_g,closepins_save_count and skip;
     int closepins_ltop,closepins_rtop,closepins_lbot,closepins_rbot and skip;
     csPinBox *closepins_pArray1,*closepins_pArray2,*closepins_pArray and skip;
     closepins_key_count:=0;
     closepins_segment_count:=0;
     closepins_super_edge:=0;
     fprintf(tw,"net %d\n",net) and skip;
     break$<==0 and skip;
     while( break$=0 AND  true)
     {
         if(closepins_key_count>0) then 
         {
             closepins_edge:=key_queue[closepins_key_count];
             closepins_key_count:=closepins_key_count-1;
             closepins_group1:=edgeArray[closepins_edge].group1;
             closepins_key_flag:=closepins_save_count;
             closepins_rbot<==-1 and closepins_rtop<==closepins_rbot and closepins_lbot<==closepins_rtop and closepins_ltop<==closepins_lbot and skip
             
         }
         else
         {
             break$<==0 and skip;
             while( break$=0 AND  (closepins_super_edge+1)<=numEdges)
             {
                 closepins_super_edge:=closepins_super_edge+1;
                 continue<==0 and skip;
                 if(edgeArray[closepins_super_edge].marked=0) then 
                 {
                     continue<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     if(edgeArray[closepins_super_edge].done=0) then 
                     {
                         break$<==1 and skip
                          
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     skip
                 }
             };closepins_super_edge:=closepins_super_edge+1;
             break$<==0 and skip;
             continue<==0 and skip;
             if(closepins_super_edge>numEdges) then 
             {
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then
             {
                 closepins_edge:=closepins_super_edge;
                 closepins_key_flag:=0;
                 closepins_rbot<==0 and closepins_rtop<==closepins_rbot and closepins_lbot<==closepins_rtop and closepins_ltop<==closepins_lbot and skip
             }
             else
             {
                 skip 
              } 
             };
             if(break$=0)  then 
             {
                 closepins_segment_count:=closepins_segment_count+1;
                 closepins_maxTop:=-1000000000;
                 closepins_maxBottom:=-1000000000;
                 closepins_maxTpin:=0;
                 closepins_maxBpin:=0;
                 closepins_group1:=edgeArray[closepins_edge].group1;
                 closepins_pArray1:=groupArray[closepins_group1].pinArray;
                 closepins_block1:=groupArray[closepins_group1].block;
                 closepins_group2:=edgeArray[closepins_edge].group2;
                 closepins_pArray2:=groupArray[closepins_group2].pinArray;
                 closepins_block2:=groupArray[closepins_group2].block;
                 if(edgeArray[closepins_edge].poison=0 AND closepins_key_flag=0) then 
                 {
                     closepins_save_count:=closepins_segment_count;
                     edgeArray[closepins_edge].done:=1;
                     closepins_key_flag:=closepins_save_count;
                     closepins_e1:=closepins_edge;
                     closepins_g1:=edgeArray[closepins_e1].group1;
                     break$<==0 and skip;
                     while( break$=0 AND  true)
                     {
                         if(groupArray[closepins_g1].poison=1) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             if(groupArray[closepins_g1].edge1=closepins_e1) then 
                             {
                                 closepins_next_edge:=groupArray[closepins_g1].edge2
                                 
                             }
                             else
                             {
                                 closepins_next_edge:=groupArray[closepins_g1].edge1
                             };
                             if(closepins_next_edge=0) then 
                             {
                                 break$<==1 and skip
                                  
                             }
                             else 
                             {
                                  skip 
                             };
                             if(break$=0)   then
                             {
                                 closepins_next_g:=edgeArray[closepins_next_edge].group1;
                                 if(closepins_next_g=closepins_g1) then 
                                 {
                                     closepins_g1:=edgeArray[closepins_next_edge].group2
                                     
                                 }
                                 else
                                 {
                                     closepins_g1:=closepins_next_g
                                 };
                                 closepins_e1:=closepins_next_edge;
                                 edgeArray[closepins_e1].done:=1;
                                 key_queue[(closepins_key_count+1)]:=closepins_e1;
                                 closepins_key_count:=closepins_key_count+1
                             }
                             else
                             {
                                 skip
                             }
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     break$<==0 and skip;
                     closepins_e2:=closepins_edge;
                     closepins_g2:=edgeArray[closepins_e2].group2;
                     break$<==0 and skip;
                     while( break$=0 AND  true)
                     {
                         if(groupArray[closepins_g2].poison=1) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             if(groupArray[closepins_g2].edge1=closepins_e2) then 
                             {
                                 closepins_next_edge:=groupArray[closepins_g2].edge2
                                 
                             }
                             else
                             {
                                 closepins_next_edge:=groupArray[closepins_g2].edge1
                             };
                             if(closepins_next_edge=0) then 
                             {
                                 break$<==1 and skip
                                  
                             }
                             else 
                             {
                                  skip 
                             };
                             if(break$=0)   then
                             {
                                 closepins_next_g:=edgeArray[closepins_next_edge].group1;
                                 if(closepins_next_g=closepins_g2) then 
                                 {
                                     closepins_g2:=edgeArray[closepins_next_edge].group2
                                     
                                 }
                                 else
                                 {
                                     closepins_g2:=closepins_next_g
                                 };
                                 closepins_e2:=closepins_next_edge;
                                 edgeArray[closepins_e2].done:=1;
                                 key_queue[(closepins_key_count+1)]:=closepins_e2;
                                 closepins_key_count:=closepins_key_count+1
                             }
                             else
                             {
                                 skip
                             }
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     break$<==0 and skip;
                     if(groupArray[closepins_g1].aveX<=groupArray[closepins_g2].aveX) then 
                     {
                         closepins_pArray:=groupArray[closepins_g1].pinArray;
                         closepins_pin:=1;
                         
                         while(closepins_pin<=groupArray[closepins_g1].numPins)
                         {
                             if(closepins_pArray[closepins_pin].top=1 OR closepins_pArray[closepins_pin].top=0) then 
                             {
                                 closepins_ltop:=closepins_pArray[closepins_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(closepins_pArray[closepins_pin].top=-1 OR closepins_pArray[closepins_pin].top=0) then 
                             {
                                 closepins_lbot:=closepins_pArray[closepins_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             closepins_pin:=closepins_pin+1
                             
                         };
                         closepins_pArray:=groupArray[closepins_g2].pinArray;
                         closepins_pin:=1;
                         
                         while(closepins_pin<=groupArray[closepins_g2].numPins)
                         {
                             if(closepins_pArray[closepins_pin].top=1 OR closepins_pArray[closepins_pin].top=0) then 
                             {
                                 closepins_rtop:=closepins_pArray[closepins_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(closepins_pArray[closepins_pin].top=-1 OR closepins_pArray[closepins_pin].top=0) then 
                             {
                                 closepins_rbot:=closepins_pArray[closepins_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             closepins_pin:=closepins_pin+1
                             
                         }
                     }
                     else
                     {
                         closepins_pArray:=groupArray[closepins_g2].pinArray;
                         closepins_pin:=1;
                         
                         while(closepins_pin<=groupArray[closepins_g2].numPins)
                         {
                             if(closepins_pArray[closepins_pin].top=1 OR closepins_pArray[closepins_pin].top=0) then 
                             {
                                 closepins_ltop:=closepins_pArray[closepins_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(closepins_pArray[closepins_pin].top=-1 OR closepins_pArray[closepins_pin].top=0) then 
                             {
                                 closepins_lbot:=closepins_pArray[closepins_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             closepins_pin:=closepins_pin+1
                             
                         };
                         closepins_pArray:=groupArray[closepins_g1].pinArray;
                         closepins_pin:=1;
                         
                         while(closepins_pin<=groupArray[closepins_g1].numPins)
                         {
                             if(closepins_pArray[closepins_pin].top=1 OR closepins_pArray[closepins_pin].top=0) then 
                             {
                                 closepins_rtop:=closepins_pArray[closepins_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(closepins_pArray[closepins_pin].top=-1 OR closepins_pArray[closepins_pin].top=0) then 
                             {
                                 closepins_rbot:=closepins_pArray[closepins_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             closepins_pin:=closepins_pin+1
                             
                         }
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(closepins_block1=closepins_block2) then 
                 {
                     if(groupArray[closepins_group1].aveX<=groupArray[closepins_group2].aveX) then 
                     {
                         closepins_pin:=1;
                         
                         while(closepins_pin<=groupArray[closepins_group1].numPins)
                         {
                             if(closepins_pArray1[closepins_pin].top=1 OR closepins_pArray1[closepins_pin].top=0) then 
                             {
                                 if(closepins_pArray1[closepins_pin].xloc>closepins_maxTop) then 
                                 {
                                     closepins_maxTop:=closepins_pArray1[closepins_pin].xloc;
                                     closepins_maxTpin:=closepins_pArray1[closepins_pin].pin
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(closepins_pArray1[closepins_pin].top=-1 OR closepins_pArray1[closepins_pin].top=0) then 
                             {
                                 if(closepins_pArray1[closepins_pin].xloc>closepins_maxBottom) then 
                                 {
                                     closepins_maxBottom:=closepins_pArray1[closepins_pin].xloc;
                                     closepins_maxBpin:=closepins_pArray1[closepins_pin].pin
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             closepins_pin:=closepins_pin+1
                             
                         };
                         closepins_sepT:=1000000000;
                         closepins_sepB:=1000000000;
                         closepins_otherTpin:=0;
                         closepins_otherBpin:=0;
                         closepins_pin:=1;
                         
                         while(closepins_pin<=groupArray[closepins_group2].numPins)
                         {
                             if(closepins_pArray2[closepins_pin].top=1 OR closepins_pArray2[closepins_pin].top=0) then 
                             {
                                 if(extern ABS(closepins_pArray2[closepins_pin].xloc-closepins_maxTop,RValue)<closepins_sepT) then 
                                 {
                                     closepins_otherTpin:=closepins_pArray2[closepins_pin].pin;
                                     closepins_minTop:=closepins_pArray2[closepins_pin].xloc;
                                     closepins_sepT:=ABS(closepins_minTop-closepins_maxTop,RValue)
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(closepins_pArray2[closepins_pin].top=-1 OR closepins_pArray2[closepins_pin].top=0) then 
                             {
                                 if(extern ABS(closepins_pArray2[closepins_pin].xloc-closepins_maxBottom,RValue)<closepins_sepB) then 
                                 {
                                     closepins_otherBpin:=closepins_pArray2[closepins_pin].pin;
                                     closepins_minBottom:=closepins_pArray2[closepins_pin].xloc;
                                     closepins_sepB:=ABS(closepins_minBottom-closepins_maxBottom,RValue)
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             closepins_pin:=closepins_pin+1
                             
                         };
                         if(closepins_maxTpin!=0 AND closepins_otherTpin!=0 AND closepins_block1<numChans AND ((!(closepins_maxBpin!=0 AND closepins_otherBpin!=0)) OR ((closepins_maxBpin!=0 AND closepins_otherBpin!=0) AND closepins_maxBottom!=closepins_minBottom))) then 
                         {
                             if(closepins_maxBpin!=0 AND closepins_otherBpin!=0 AND closepins_block1>0 AND closepins_maxTop!=closepins_minTop) then 
                             {
                                 fprintf(tw,"segment switchable %d\n",closepins_key_flag) and skip;
                                 fprintf(tw,"top channel %d\n",(closepins_block1+1)) and skip;
                                 if(closepins_maxTop<=closepins_minTop) then 
                                 {
                                     closepins_p1:=closepins_maxTpin;
                                     closepins_p2:=closepins_otherTpin
                                     
                                 }
                                 else
                                 {
                                     closepins_p1:=closepins_otherTpin;
                                     closepins_p2:=closepins_maxTpin
                                 };
                                 fprintf(tw,"pin1 %d  pin2 %d %d %d\n",closepins_p1,closepins_p2,closepins_ltop,closepins_rtop) and skip;
                                 fprintf(tw,"bottom channel %d\n",closepins_block1) and skip;
                                 if(closepins_maxBottom<=closepins_minBottom) then 
                                 {
                                     closepins_p1:=closepins_maxBpin;
                                     closepins_p2:=closepins_otherBpin
                                     
                                 }
                                 else
                                 {
                                     closepins_p1:=closepins_otherBpin;
                                     closepins_p2:=closepins_maxBpin
                                 };
                                 fprintf(tw,"pin1 %d  pin2 %d %d %d\n",closepins_p1,closepins_p2,closepins_lbot,closepins_rbot) and skip
                             }
                             else
                             {
                                 fprintf(tw,"segment channel %d\n",(closepins_block1+1)) and skip;
                                 if(closepins_maxTop<=closepins_minTop) then 
                                 {
                                     closepins_p1:=closepins_maxTpin;
                                     closepins_p2:=closepins_otherTpin
                                     
                                 }
                                 else
                                 {
                                     closepins_p1:=closepins_otherTpin;
                                     closepins_p2:=closepins_maxTpin
                                 };
                                 fprintf(tw,"pin1 %d  pin2 %d %d %d\n",closepins_p1,closepins_p2,closepins_ltop,closepins_rtop) and skip
                             }
                         }
                         else
                         {
                             if(closepins_maxBpin!=0 AND closepins_otherBpin!=0) then 
                             {
                                 fprintf(tw,"segment channel %d\n",closepins_block1) and skip;
                                 if(closepins_maxBottom<=closepins_minBottom) then 
                                 {
                                     closepins_p1:=closepins_maxBpin;
                                     closepins_p2:=closepins_otherBpin
                                     
                                 }
                                 else
                                 {
                                     closepins_p1:=closepins_otherBpin;
                                     closepins_p2:=closepins_maxBpin
                                 };
                                 fprintf(tw,"pin1 %d  pin2 %d %d %d\n",closepins_p1,closepins_p2,closepins_lbot,closepins_rbot) and skip
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                         }
                     }
                     else
                     {
                         closepins_pin:=1;
                         
                         while(closepins_pin<=groupArray[closepins_group2].numPins)
                         {
                             if(closepins_pArray2[closepins_pin].top=1 OR closepins_pArray2[closepins_pin].top=0) then 
                             {
                                 if(closepins_pArray2[closepins_pin].xloc>closepins_maxTop) then 
                                 {
                                     closepins_maxTop:=closepins_pArray2[closepins_pin].xloc;
                                     closepins_maxTpin:=closepins_pArray2[closepins_pin].pin
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(closepins_pArray2[closepins_pin].top=-1 OR closepins_pArray2[closepins_pin].top=0) then 
                             {
                                 if(closepins_pArray2[closepins_pin].xloc>closepins_maxBottom) then 
                                 {
                                     closepins_maxBottom:=closepins_pArray2[closepins_pin].xloc;
                                     closepins_maxBpin:=closepins_pArray2[closepins_pin].pin
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             closepins_pin:=closepins_pin+1
                             
                         };
                         closepins_sepT:=1000000000;
                         closepins_sepB:=1000000000;
                         closepins_otherTpin:=0;
                         closepins_otherBpin:=0;
                         closepins_pin:=1;
                         
                         while(closepins_pin<=groupArray[closepins_group1].numPins)
                         {
                             if(closepins_pArray1[closepins_pin].top=1 OR closepins_pArray1[closepins_pin].top=0) then 
                             {
                                 if(extern ABS(closepins_pArray1[closepins_pin].xloc-closepins_maxTop,RValue)<closepins_sepT) then 
                                 {
                                     closepins_otherTpin:=closepins_pArray1[closepins_pin].pin;
                                     closepins_minTop:=closepins_pArray1[closepins_pin].xloc;
                                     closepins_sepT:=ABS(closepins_minTop-closepins_maxTop,RValue)
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(closepins_pArray1[closepins_pin].top=-1 OR closepins_pArray1[closepins_pin].top=0) then 
                             {
                                 if(extern ABS(closepins_pArray1[closepins_pin].xloc-closepins_maxBottom,RValue)<closepins_sepB) then 
                                 {
                                     closepins_otherBpin:=closepins_pArray1[closepins_pin].pin;
                                     closepins_minBottom:=closepins_pArray1[closepins_pin].xloc;
                                     closepins_sepB:=ABS(closepins_minBottom-closepins_maxBottom,RValue)
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             closepins_pin:=closepins_pin+1
                             
                         };
                         if(closepins_maxTpin!=0 AND closepins_otherTpin!=0 AND closepins_block1<numChans AND ((!(closepins_maxBpin!=0 AND closepins_otherBpin!=0)) OR ((closepins_maxBpin!=0 AND closepins_otherBpin!=0) AND closepins_maxBottom!=closepins_minBottom))) then 
                         {
                             if(closepins_maxBpin!=0 AND closepins_otherBpin!=0 AND closepins_block1>0 AND closepins_maxTop!=closepins_minTop) then 
                             {
                                 fprintf(tw,"segment switchable %d\n",closepins_key_flag) and skip;
                                 fprintf(tw,"top channel %d\n",(closepins_block1+1)) and skip;
                                 if(closepins_maxTop<=closepins_minTop) then 
                                 {
                                     closepins_p1:=closepins_maxTpin;
                                     closepins_p2:=closepins_otherTpin
                                     
                                 }
                                 else
                                 {
                                     closepins_p1:=closepins_otherTpin;
                                     closepins_p2:=closepins_maxTpin
                                 };
                                 fprintf(tw,"pin1 %d  pin2 %d %d %d\n",closepins_p1,closepins_p2,closepins_ltop,closepins_rtop) and skip;
                                 fprintf(tw,"bottom channel %d\n",closepins_block1) and skip;
                                 if(closepins_maxBottom<=closepins_minBottom) then 
                                 {
                                     closepins_p1:=closepins_maxBpin;
                                     closepins_p2:=closepins_otherBpin
                                     
                                 }
                                 else
                                 {
                                     closepins_p1:=closepins_otherBpin;
                                     closepins_p2:=closepins_maxBpin
                                 };
                                 fprintf(tw,"pin1 %d  pin2 %d %d %d\n",closepins_p1,closepins_p2,closepins_lbot,closepins_rbot) and skip
                             }
                             else
                             {
                                 fprintf(tw,"segment channel %d\n",(closepins_block1+1)) and skip;
                                 if(closepins_maxTop<=closepins_minTop) then 
                                 {
                                     closepins_p1:=closepins_maxTpin;
                                     closepins_p2:=closepins_otherTpin
                                     
                                 }
                                 else
                                 {
                                     closepins_p1:=closepins_otherTpin;
                                     closepins_p2:=closepins_maxTpin
                                 };
                                 fprintf(tw,"pin1 %d  pin2 %d %d %d\n",closepins_p1,closepins_p2,closepins_ltop,closepins_rtop) and skip
                             }
                         }
                         else
                         {
                             if(closepins_maxBpin!=0 AND closepins_otherBpin!=0) then 
                             {
                                 fprintf(tw,"segment channel %d\n",closepins_block1) and skip;
                                 if(closepins_maxBottom<=closepins_minBottom) then 
                                 {
                                     closepins_p1:=closepins_maxBpin;
                                     closepins_p2:=closepins_otherBpin
                                     
                                 }
                                 else
                                 {
                                     closepins_p1:=closepins_otherBpin;
                                     closepins_p2:=closepins_maxBpin
                                 };
                                 fprintf(tw,"pin1 %d  pin2 %d %d %d\n",closepins_p1,closepins_p2,closepins_lbot,closepins_rbot) and skip
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                         }
                     }
                 }
                 else
                 {
                     closepins_minX:=1000000000;
                     closepins_minP1:=0;
                     closepins_minP2:=0;
                     if(closepins_block1>closepins_block2) then 
                     {
                         closepins_pin1:=1;
                         
                         while(closepins_pin1<=groupArray[closepins_group1].numPins)
                         {
                             if(closepins_pArray1[closepins_pin1].top=-1 OR closepins_pArray1[closepins_pin1].top=0) then 
                             {
                                 closepins_pin2:=1;
                                 while(closepins_pin2<=groupArray[closepins_group2].numPins)
                                 {
                                     if(closepins_pArray2[closepins_pin2].top=1 OR closepins_pArray2[closepins_pin2].top=0) then 
                                     {
                                         if(extern ABS(closepins_pArray1[closepins_pin1].xloc-closepins_pArray2[closepins_pin2].xloc,RValue)<closepins_minX) then 
                                         {
                                             closepins_left:=closepins_pArray1[closepins_pin1].xloc;
                                             closepins_right:=closepins_pArray2[closepins_pin2].xloc;
                                             closepins_minX:=ABS(closepins_left-closepins_right,RValue);
                                             closepins_minP1:=closepins_pArray1[closepins_pin1].pin;
                                             closepins_minP2:=closepins_pArray2[closepins_pin2].pin
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     closepins_pin2:=closepins_pin2+1
                                     
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             closepins_pin1:=closepins_pin1+1
                             
                         };
                         if(closepins_minP1!=0 AND closepins_minP2!=0) then 
                         {
                             fprintf(tw,"segment channel %d\n",closepins_block1) and skip;
                             if(closepins_left>closepins_right) then 
                             {
                                 fprintf(tw," pin1 %d  pin2 %d %d %d\n",closepins_minP2,closepins_minP1,closepins_ltop,closepins_rtop) and skip
                             }
                             else
                             {
                                 fprintf(tw," pin1 %d  pin2 %d %d %d\n",closepins_minP1,closepins_minP2,closepins_ltop,closepins_rtop) and skip
                             }
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                     else
                     {
                         closepins_pin1:=1;
                         while(closepins_pin1<=groupArray[closepins_group1].numPins)
                         {
                             if(closepins_pArray1[closepins_pin1].top=1 OR closepins_pArray1[closepins_pin1].top=0) then 
                             {
                                 closepins_pin2:=1;
                                 while(closepins_pin2<=groupArray[closepins_group2].numPins)
                                 {
                                     if(closepins_pArray2[closepins_pin2].top=-1 OR closepins_pArray2[closepins_pin2].top=0) then 
                                     {
                                         if(extern ABS(closepins_pArray1[closepins_pin1].xloc-closepins_pArray2[closepins_pin2].xloc,RValue)<closepins_minX) then 
                                         {
                                             closepins_left:=closepins_pArray1[closepins_pin1].xloc;
                                             closepins_right:=closepins_pArray2[closepins_pin2].xloc;
                                             closepins_minX:=ABS(closepins_left-closepins_right,RValue);
                                             closepins_minP1:=closepins_pArray1[closepins_pin1].pin;
                                             closepins_minP2:=closepins_pArray2[closepins_pin2].pin
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     closepins_pin2:=closepins_pin2+1
                                     
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             closepins_pin1:=closepins_pin1+1
                             
                         };
                         if(closepins_minP1!=0 AND closepins_minP2!=0) then 
                         {
                             fprintf(tw,"segment channel %d\n",closepins_block2) and skip;
                             if(closepins_left>closepins_right) then 
                             {
                                 fprintf(tw," pin1 %d  pin2 %d %d %d\n",closepins_minP2,closepins_minP1,closepins_ltop,closepins_rtop) and skip
                             }
                             else
                             {
                                 fprintf(tw," pin1 %d  pin2 %d %d %d\n",closepins_minP1,closepins_minP2,closepins_ltop,closepins_rtop) and skip
                             }
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                 }
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
          return<==1 and skip
         )
         }; 
          struct macrobox {
         int mx and 
         int my 
     };
     int *blkToRow and skip;
     int rowHeight and skip;
     blockbox* boxptr,**oldbarray and skip;
     cellbox* cellptr and skip;
     macrobox *macroArray and skip;
     int *filledTo,*endRow and skip;
     int macNumber,row,totalR and skip;
     int totalBlock,borient,empty$,cell,middleRow and skip;
     int extraSpace,pad,height,width,bot,top,trow and skip;
     int rows and skip;
     int brow,rite,left,coreHeight,coreWidth,count,macro and skip;
     int maxHeight,space,separation,yshift,xshift,last and skip;
     int coreTop,coreRite,block,maxWidth,*padArray,numMacro and skip;
     int URmacro,Rmacro,edge and skip;
     int k,blk,zxshift,zyshift and skip;
     int mttshift,mbbshift and skip;
     float dsum,ratio and skip;
 function config1 (  )
 {
     frame(temp_i,config1_totalF,config1_modulation,config1_constant,config1_M,config1_r,config1_topRowY,config1_centerY,config1_count_mtt,config1_count_mbb,config1_padptr,nm_1$,break$$,switch$,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     float config1_totalF,config1_modulation,config1_constant and skip;
     int config1_M,config1_r,config1_topRowY,config1_centerY and skip;
     int config1_count_mtt,config1_count_mbb and skip;
     cellbox* config1_padptr and skip;
     macroArray:=(macrobox *)safe_malloc((50+1)*sizeof(macrobox),RValue);
     macNumber:=0;
     numRows:=numblock;
     rowArray:=(rowbox *)safe_malloc((numRows+1)*sizeof(rowbox),RValue);
     row:=1;
     
     while(row<=numRows)
     {
         rowArray[row].endx1:=-1;
         rowArray[row].startx2:=-1;
         row:=row+1
         
     };
     totalR:=celllen;
     rowHeight:=0;
     row:=1;
     
     while(row<=numRows)
     {
         rowHeight:=rowHeight+barray[row]->btop-barray[row]->bbottom;
         row:=row+1
         
     };
     rowHeight:=rowHeight/ numRows;
     row:=1;
     
     while(row<=numRows)
     {
         rowArray[row].startx:=0;
         rowArray[row].ypos:=(row-1)*(rowSep+1)*rowHeight+rowHeight/ 2;
         row:=row+1
         
     };
     if(numRows>1) then 
     {
         config1_totalF:=0.0;
         config1_r:=1;
         
         while(config1_r<=numRows)
         {
             config1_totalF:=config1_totalF+relativeLen[config1_r];
             config1_r:=config1_r+1
             
         };
         config1_topRowY:=rowArray[numRows].ypos;
         config1_centerY:=(config1_topRowY+rowArray[1].ypos)/ 2;
         config1_M:=(int)(((float)totalR)/ config1_totalF);
         dsum:=0.0;
         config1_r:=1;
         
         while(config1_r<=numRows)
         {
             dsum:=dsum+relativeLen[config1_r]*(float)(ABS(rowArray[config1_r].ypos-config1_centerY,RValue));
             config1_r:=config1_r+1
             
         };
         dsum:=dsum/ config1_totalF;
         dsum:=dsum*1.0/ (float)(config1_topRowY-config1_centerY);
         config1_constant:=1.0+(1.0-indent)*(1.0-dsum);
         config1_r:=1;
         
         while(config1_r<=numRows)
         {
             rowArray[config1_r].endx:=(int)(((float)config1_M)*config1_constant*relativeLen[config1_r]);
             config1_modulation:=1.0+(1.0-indent)*(((float)(ABS(rowArray[config1_r].ypos-config1_centerY,RValue))/ (float)(config1_topRowY-config1_centerY))-dsum);
             rowArray[config1_r].desiredL:=(int)((float)config1_M*relativeLen[config1_r]*config1_modulation)+1;
             config1_r:=config1_r+1
             
         }
         
     }
     else
     {
         rowArray[1].endx:=totalR;
         rowArray[1].desiredL:=rowArray[1].endx
     };
     extraSpace:=rowSep*rowHeight;
     k:=1;
     
     while(k<=15)
     {
         if(macspace[k]<0.0) then 
         {
             macspace[k]:=extraSpace
             
         }
         else
         {
             macspace[k]:=macspace[k]*rowHeight
         };
         k:=k+1
         
     };
     middleRow:=numRows/ 2;
     padArray:=(int *)safe_malloc((numterms+1)*sizeof(int),RValue);
     pad:=1;
     
     while(pad<=numterms)
     {
         padArray[pad]:=0;
         pad:=pad+1
         
     };
     numMacro:=0;
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=5 OR carray[pad]->padside=9 OR carray[pad]->padside=7) then 
         {
             padArray[(numMacro+1)]:=pad;
             numMacro:=numMacro+1
             
         }
         else 
         {
              skip 
         };
         pad:=pad+1
         
     };
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=12 OR carray[pad]->padside=13 OR carray[pad]->padside=11) then 
         {
             padArray[(numMacro+1)]:=pad;
             numMacro:=numMacro+1
             
         }
         else 
         {
              skip 
         };
         pad:=pad+1
         
     };
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=6) then 
         {
             padArray[(numMacro+1)]:=pad;
             numMacro:=numMacro+1;
             URmacro:=numMacro
             
         }
         else 
         {
              skip 
         };
         pad:=pad+1
         
     };
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=10) then 
         {
             padArray[(numMacro+1)]:=pad;
             numMacro:=numMacro+1;
             Rmacro:=numMacro
             
         }
         else 
         {
              skip 
         };
         pad:=pad+1
         
     };
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=8) then 
         {
             padArray[(numMacro+1)]:=pad;
             numMacro:=numMacro+1
             
         }
         else 
         {
              skip 
         };
         pad:=pad+1
         
     };
     macro:=1;
     
     while(macro<=numMacro)
     {
         pad:=padArray[macro];
         config1_padptr:=carray[pad];
         height:=config1_padptr->tileptr->top-config1_padptr->tileptr->bottom;
         width:=config1_padptr->tileptr->right-config1_padptr->tileptr->left;
         macNumber:=macNumber+1;
         int switch$ and skip;
         int break$$ and skip;
         break$$<==0 and skip;
          switch$<==0 and skip;
          int nm_1$ and skip;
         nm_1$ := config1_padptr->padside;
         if (nm_1$=5 OR (switch$=1 AND break$$=0 AND return=0) ) then 
         {
             switch$<==1 and skip;
             break$<==0 and skip;
             row:=numRows;
             
             while( break$=0 AND  row>=1)
             {
                 if(rowArray[row].ypos+rowSep*rowHeight*0.33<=rowArray[numRows].ypos-height) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row-1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             rows:=numRows-row;
             row:=row+1;
             
             while(row<=numRows)
             {
                 rowArray[row].startx:=width+macspace[5];
                 rowArray[row].desiredL:=rowArray[row].desiredL-(width+macspace[5]);
                 row:=row+1
                 
             };
             row:=1;
             
             while(row<=numRows)
             {
                 rowArray[row].endx:=rowArray[row].endx+(rows*(width+macspace[5]))/ numRows;
                 rowArray[row].desiredL:=rowArray[row].desiredL+(rows*(width+macspace[5]))/ numRows;
                 row:=row+1
                 
             };
             macroArray[macNumber].mx:=width/ 2;
             macroArray[macNumber].my:=(rowArray[numRows].ypos+rowHeight/ 2)-height/ 2;
             break$$<==1 and skip
              
         }
         else
         {
             skip
         };
         if (nm_1$=6 OR (switch$=1 AND break$$=0 AND return=0) ) then 
         {
             switch$<==1 and skip;
             break$<==0 and skip;
             row:=numRows;
             
             while( break$=0 AND  row>=1)
             {
                 if(rowArray[row].ypos+rowSep*rowHeight*0.33<=rowArray[numRows].ypos-height) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row-1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             rows:=numRows-row;
             row:=row+1;
             
             while(row<=numRows)
             {
                 rowArray[row].endx:=rowArray[row].endx-(width+macspace[6]);
                 rowArray[row].desiredL:=rowArray[row].desiredL-(width+macspace[6]);
                 row:=row+1
                 
             };
             row:=1;
             
             while(row<=numRows)
             {
                 rowArray[row].endx:=rowArray[row].endx+(rows*(width+macspace[6]))/ numRows;
                 rowArray[row].desiredL:=rowArray[row].desiredL+(rows*(width+macspace[6]))/ numRows;
                 row:=row+1
                 
             };
             macroArray[macNumber].mx:=rowArray[numRows].endx+macspace[6]+width/ 2;
             macroArray[macNumber].my:=(rowArray[numRows].ypos+rowHeight/ 2)-height/ 2;
             break$$<==1 and skip
              
         }
         else
         {
             skip
         };
         if (nm_1$=7 OR (switch$=1 AND break$$=0 AND return=0) ) then 
         {
             switch$<==1 and skip;
             break$<==0 and skip;
             row:=1;
             
             while( break$=0 AND  row<=numRows)
             {
                 if(rowArray[row].ypos-rowSep*rowHeight*0.33>=rowArray[1].ypos+height) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             rows:=row-1;
             row:=row-1;
             
             while(row>=1)
             {
                 rowArray[row].startx:=width+macspace[7];
                 rowArray[row].desiredL:=rowArray[row].desiredL-(width+macspace[7]);
                 row:=row-1
                 
             };
             row:=1;
             
             while(row<=numRows)
             {
                 rowArray[row].endx:=rowArray[row].endx+(rows*(width+macspace[7]))/ numRows;
                 rowArray[row].desiredL:=rowArray[row].desiredL+(rows*(width+macspace[7]))/ numRows;
                 row:=row+1
                 
             };
             macroArray[macNumber].mx:=width/ 2;
             macroArray[macNumber].my:=(rowArray[1].ypos-rowHeight/ 2)+height/ 2;
             break$$<==1 and skip
              
         }
         else
         {
             skip
         };
         if (nm_1$=8 OR (switch$=1 AND break$$=0 AND return=0) ) then 
         {
             switch$<==1 and skip;
             break$<==0 and skip;
             row:=1;
             
             while( break$=0 AND  row<=numRows)
             {
                 if(rowArray[row].ypos-rowSep*rowHeight*0.33>=rowArray[1].ypos+height) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             rows:=row-1;
             row:=row-1;
             
             while(row>=1)
             {
                 rowArray[row].endx:=rowArray[row].endx-(width+macspace[8]);
                 rowArray[row].desiredL:=rowArray[row].desiredL-(width+macspace[8]);
                 row:=row-1
                 
             };
             row:=1;
             
             while(row<=numRows)
             {
                 rowArray[row].endx:=rowArray[row].endx+(rows*(width+macspace[8]))/ numRows;
                 rowArray[row].desiredL:=rowArray[row].desiredL+(rows*(width+macspace[8]))/ numRows;
                 row:=row+1
                 
             };
             if(URmacro!=0) then 
             {
                 macroArray[URmacro].mx:=macroArray[URmacro].mx+(rows*(width+macspace[8]))/ numRows
                 
             }
             else 
             {
                  skip 
             };
             if(Rmacro!=0) then 
             {
                 macroArray[Rmacro].mx:=macroArray[Rmacro].mx+(rows*(width+macspace[8]))/ numRows
                 
             }
             else 
             {
                  skip 
             };
             macroArray[macNumber].mx:=rowArray[1].endx+macspace[8]+width/ 2;
             macroArray[macNumber].my:=(rowArray[1].ypos-rowHeight/ 2)+height/ 2;
             break$$<==1 and skip
              
         }
         else
         {
             skip
         };
         if (nm_1$=9 OR (switch$=1 AND break$$=0 AND return=0) ) then 
         {
             switch$<==1 and skip;
             bot:=rowArray[middleRow].ypos-height/ 2;
             top:=bot+height;
             break$<==0 and skip;
             row:=1;
             
             while( break$=0 AND  row<=numRows)
             {
                 if(rowArray[row].ypos-rowHeight/ 2-rowSep*rowHeight*0.33>=top) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             trow:=row;
             break$<==0 and skip;
             row:=numRows;
             
             while( break$=0 AND  row>=1)
             {
                 if(rowArray[row].ypos+rowHeight/ 2+rowSep*rowHeight*0.33<=bot) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row-1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             brow:=row;
             rows:=trow-brow-1;
             row:=brow+1;
             
             while(row<trow)
             {
                 rowArray[row].startx:=width+macspace[9];
                 rowArray[row].desiredL:=rowArray[row].desiredL-(width+macspace[9]);
                 row:=row+1
                 
             };
             row:=1;
             
             while(row<=numRows)
             {
                 rowArray[row].endx:=rowArray[row].endx+(rows*(width+macspace[9]))/ numRows;
                 rowArray[row].desiredL:=rowArray[row].desiredL+(rows*(width+macspace[9]))/ numRows;
                 row:=row+1
                 
             };
             macroArray[macNumber].mx:=width/ 2;
             macroArray[macNumber].my:=rowArray[middleRow].ypos;
             break$$<==1 and skip
              
         }
         else
         {
             skip
         };
         if (nm_1$=10 OR (switch$=1 AND break$$=0 AND return=0) ) then 
         {
             switch$<==1 and skip;
             bot:=rowArray[middleRow].ypos-height/ 2;
             top:=bot+height;
             break$<==0 and skip;
             row:=1;
             
             while( break$=0 AND  row<=numRows)
             {
                 if(rowArray[row].ypos-rowHeight/ 2-rowSep*rowHeight*0.33>=top) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             trow:=row;
             break$<==0 and skip;
             row:=numRows;
             
             while( break$=0 AND  row>=1)
             {
                 if(rowArray[row].ypos+rowHeight/ 2+rowSep*rowHeight*0.33<=bot) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row-1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             brow:=row;
             rows:=trow-brow-1;
             row:=brow+1;
             
             while(row<trow)
             {
                 rowArray[row].endx:=rowArray[row].endx-(width+macspace[10]);
                 rowArray[row].desiredL:=rowArray[row].desiredL-(width+macspace[10]);
                 row:=row+1
                 
             };
             row:=1;
             
             while(row<=numRows)
             {
                 rowArray[row].endx:=rowArray[row].endx+(rows*(width+macspace[10]))/ numRows;
                 rowArray[row].desiredL:=rowArray[row].desiredL+(rows*(width+macspace[10]))/ numRows;
                 row:=row+1
                 
             };
             if(URmacro!=0) then 
             {
                 macroArray[URmacro].mx:=macroArray[URmacro].mx+(rows*(width+macspace[10]))/ numRows
                 
             }
             else 
             {
                  skip 
             };
             macroArray[macNumber].mx:=rowArray[middleRow].endx+macspace[10]+width/ 2;
             macroArray[macNumber].my:=rowArray[middleRow].ypos;
             break$$<==1 and skip
              
         }
         else
         {
             skip
         };
         if (nm_1$=13 OR (switch$=1 AND break$$=0 AND return=0) ) then 
         {
             switch$<==1 and skip;
             bot:=rowArray[middleRow].ypos-height/ 2;
             top:=bot+height;
             left:=(rowArray[middleRow].startx+rowArray[middleRow].endx)/ 2;
             rite:=left+width;
             break$<==0 and skip;
             row:=1;
             
             while( break$=0 AND  row<=numRows)
             {
                 if(rowArray[row].ypos-rowHeight/ 2-rowSep*rowHeight*0.67>=top) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             trow:=row;
             break$<==0 and skip;
             row:=numRows;
             
             while( break$=0 AND  row>=1)
             {
                 if(rowArray[row].ypos+rowHeight/ 2+rowSep*rowHeight*0.67<=bot) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row-1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             brow:=row;
             rows:=trow-brow-1;
             row:=brow+1;
             
             while(row<trow)
             {
                 rowArray[row].endx1:=left-macspace[13];
                 rowArray[row].startx2:=rite+macspace[13];
                 rowArray[row].desiredL:=rowArray[row].desiredL-(width+2*macspace[13]);
                 row:=row+1
                 
             };
             row:=1;
             
             while(row<=numRows)
             {
                 rowArray[row].endx:=rowArray[row].endx+(rows*(width+2*macspace[13]))/ numRows;
                 rowArray[row].desiredL:=rowArray[row].desiredL+(rows*(width+2*macspace[13]))/ numRows;
                 row:=row+1
                 
             };
             macroArray[macNumber].mx:=(left+rite)/ 2;
             macroArray[macNumber].my:=(bot+top)/ 2;
             break$$<==1 and skip
              
         }
         else
         {
             skip
         };
         if (nm_1$=11 OR (switch$=1 AND break$$=0 AND return=0) ) then 
         {
             switch$<==1 and skip;
             bot:=rowArray[1].ypos-rowHeight/ 2;
             top:=bot+height;
             left:=(rowArray[1].startx+rowArray[1].endx)/ 2-width/ 2;
             rite:=left+width;
             break$<==0 and skip;
             row:=1;
             
             while( break$=0 AND  row<=numRows)
             {
                 if(rowArray[row].ypos-rowHeight/ 2-rowSep*rowHeight*0.67>=top) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             trow:=row;
             brow:=0;
             rows:=trow-brow-1;
             row:=brow+1;
             
             while(row<trow)
             {
                 rowArray[row].endx1:=left-macspace[11];
                 rowArray[row].startx2:=rite+macspace[11];
                 rowArray[row].desiredL:=rowArray[row].desiredL-(width+2*macspace[11]);
                 row:=row+1
                 
             };
             row:=1;
             
             while(row<=numRows)
             {
                 rowArray[row].endx:=rowArray[row].endx+(rows*(width+2*macspace[11]))/ numRows;
                 rowArray[row].desiredL:=rowArray[row].desiredL+(rows*(width+2*macspace[11]))/ numRows;
                 row:=row+1
                 
             };
             macroArray[macNumber].mx:=(left+rite)/ 2;
             macroArray[macNumber].my:=(bot+top)/ 2;
             break$$<==1 and skip
              
         }
         else
         {
             skip
         };
         if (nm_1$=12 OR (switch$=1 AND break$$=0 AND return=0) ) then 
         {
             switch$<==1 and skip;
             top:=rowArray[numRows].ypos+rowHeight/ 2;
             bot:=top-height;
             left:=(rowArray[numRows].startx+rowArray[numRows].endx)/ 2-width/ 2;
             rite:=left+width;
             trow:=numRows+1;
             break$<==0 and skip;
             row:=numRows;
             
             while( break$=0 AND  row>=1)
             {
                 if(rowArray[row].ypos+rowHeight/ 2+rowSep*rowHeight*0.67<=bot) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     row:=row-1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             brow:=row;
             rows:=trow-brow-1;
             row:=brow+1;
             
             while(row<trow)
             {
                 rowArray[row].endx1:=left-macspace[12];
                 rowArray[row].startx2:=rite+macspace[12];
                 rowArray[row].desiredL:=rowArray[row].desiredL-(width+2*macspace[12]);
                 row:=row+1
                 
             };
             row:=1;
             
             while(row<=numRows)
             {
                 rowArray[row].endx:=rowArray[row].endx+(rows*(width+2*macspace[12]))/ numRows;
                 rowArray[row].desiredL:=rowArray[row].desiredL+(rows*(width+2*macspace[12]))/ numRows;
                 row:=row+1
                 
             };
             macroArray[macNumber].mx:=(left+rite)/ 2;
             macroArray[macNumber].my:=(bot+top)/ 2;
             break$$<==1 and skip
              
         }
         else
         {
             skip
         };
         if(break$$=0 AND return=0) then 
         {
             fprintf(fpo,"screwup in finding padside\n") and skip;
             exit(0) and skip;
             break$$<==1 and skip
              
         }
         else
         {
              skip
         };
         macro:=macro+1
         
     };
     coreHeight:=rowArray[numRows].ypos+rowHeight-rowHeight/ 2;
     coreWidth:=0;
     row:=1;
     
     while(row<=numRows)
     {
         if(rowArray[row].endx>coreWidth) then 
         {
             coreWidth:=rowArray[row].endx
             
         }
         else 
         {
              skip 
         };
         row:=row+1
         
     };
     macro:=1;
     
     while(macro<=numMacro)
     {
         pad:=padArray[macro];
         edge:=macroArray[macro].mx+carray[pad]->tileptr->right;
         if(edge>coreWidth) then 
         {
             coreWidth:=edge
             
         }
         else 
         {
              skip 
         };
         macro:=macro+1
         
     };
     mbbshift:=0;
     height:=0;
     width:=0;
     config1_count_mbb:=0;
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         config1_padptr:=carray[pad];
         if(config1_padptr->padside=15) then 
         {
             if(config1_padptr->tileptr->top-config1_padptr->tileptr->bottom>height) then 
             {
                 height:=config1_padptr->tileptr->top-config1_padptr->tileptr->bottom
                 
             }
             else 
             {
                  skip 
             };
             width:=width+config1_padptr->tileptr->right-config1_padptr->tileptr->left;
             config1_count_mbb:=config1_count_mbb+1
             
         }
         else 
         {
              skip 
         };
         pad:=pad+1
         
     };
     if(config1_count_mbb>0) then 
     {
         mbbshift:=height+rowSep*rowHeight;
         row:=1;
         
         while(row<=numRows)
         {
             rowArray[row].ypos:=rowArray[row].ypos+mbbshift;
             row:=row+1
             
         };
         coreHeight:=coreHeight+mbbshift;
         if(width>coreWidth) then 
         {
             coreWidth:=width
             
         }
         else 
         {
              skip 
         };
         space:=coreWidth-width;
         separation:=space/ (config1_count_mbb+1);
         if(separation<0) then 
         {
             separation:=0
             
         }
         else 
         {
              skip 
         };
         maxHeight:=height;
         height:=0;
         width:=0;
         last:=separation;
         pad:=numcells+1;
         
         while(pad<=numcells+numterms)
         {
             config1_padptr:=carray[pad];
             if(config1_padptr->padside=15) then 
             {
                 height:=config1_padptr->tileptr->top-config1_padptr->tileptr->bottom;
                 width:=config1_padptr->tileptr->right-config1_padptr->tileptr->left;
                 config1_padptr->cxcenter:=last+width/ 2;
                 config1_padptr->cycenter:=maxHeight-height/ 2-1;
                 last:=last+separation+width
                 
             }
             else 
             {
                  skip 
             };
             pad:=pad+1
             
         }
         
     }
     else 
     {
          skip 
     };
     mttshift:=0;
     height:=0;
     width:=0;
     config1_count_mtt:=0;
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         config1_padptr:=carray[pad];
         if(config1_padptr->padside=14) then 
         {
             if(config1_padptr->tileptr->top-config1_padptr->tileptr->bottom>height) then 
             {
                 height:=config1_padptr->tileptr->top-config1_padptr->tileptr->bottom
                 
             }
             else 
             {
                  skip 
             };
             width:=width+config1_padptr->tileptr->right-config1_padptr->tileptr->left;
             config1_count_mtt:=config1_count_mtt+1
             
         }
         else 
         {
              skip 
         };
         pad:=pad+1
         
     };
     if(config1_count_mtt>0) then 
     {
         mttshift:=height+rowSep*rowHeight;
         coreHeight:=coreHeight+mttshift;
         if(width>coreWidth) then 
         {
             coreWidth:=width
             
         }
         else 
         {
              skip 
         };
         space:=coreWidth-width;
         separation:=space/ (config1_count_mtt+1);
         if(separation<0) then 
         {
             separation:=0
             
         }
         else 
         {
              skip 
         };
         height:=0;
         width:=0;
         last:=separation;
         pad:=numcells+1;
         
         while(pad<=numcells+numterms)
         {
             config1_padptr:=carray[pad];
             if(config1_padptr->padside=14) then 
             {
                 height:=config1_padptr->tileptr->top-config1_padptr->tileptr->bottom;
                 width:=config1_padptr->tileptr->right-config1_padptr->tileptr->left;
                 config1_padptr->cxcenter:=last+width/ 2;
                 config1_padptr->cycenter:=coreHeight+rowSep*rowHeight+height/ 2;
                 last:=last+separation+width
                 
             }
             else 
             {
                  skip 
             };
             pad:=pad+1
             
         }
         
     }
     else 
     {
          skip 
     };

	 
      return<==1 and skip
     )
     }; 

 float ckt_size_factor and skip;
 function configure (  )
 {
     frame(return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     config1();
     xshift:=0;
     yshift:=0;
     zxshift:=0;
     zyshift:=0;
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=4) then 
         {
             count:=1;
             height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
             width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left;
             break$<==0 and skip;
             pad:=pad+1;
             
             while( break$=0 AND  pad<=numcells+numterms)
             {
                 if(carray[pad]->padside!=4) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     count:=count+1;
                     if(carray[pad]->tileptr->top-carray[pad]->tileptr->bottom>height) then 
                     {
                         height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom
                         
                     }
                     else 
                     {
                          skip 
                     };
                     width:=width+carray[pad]->tileptr->right-carray[pad]->tileptr->left;
                     pad:=pad+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             maxHeight:=height;
             if(fixLRBT[2]=0) then 
             {
                 space:=coreWidth-width;
                 separation:=space/ (count+1);
                 if(separation<0) then 
                 {
                     separation:=0;
                     zxshift:=ABS(space,RValue)
                     
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else
             {
                 space:=( if((coreWidth>=width)) then coreWidth else width)
             };
             yshift:=maxHeight+extraSpace;
             row:=1;
             
             while(row<=numRows)
             {
                 rowArray[row].ypos:=rowArray[row].ypos+yshift;
                 row:=row+1
                 
             };
             pad:=numcells+1;
             
             while(pad<=numcells+numterms)
             {
                 if(carray[pad]->padside=4) then 
                 {
                     height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
                     width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left;
                     if(fixLRBT[2]=0) then 
                     {
                         carray[pad]->cxcenter:=separation+width/ 2
                         
                     }
                     else
                     {
                         carray[pad]->cxcenter:=padspace[pad-numcells]*space
                     };
                     carray[pad]->cycenter:=maxHeight-height/ 2-1;
                     last:=separation+width;
                     break$<==0 and skip;
                     pad:=pad+1;
                     
                     while( break$=0 AND  pad<=numcells+numterms)
                     {
                         if(carray[pad]->padside!=4) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
                             width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left;
                             if(fixLRBT[2]=0) then 
                             {
                                 carray[pad]->cxcenter:=last+separation+width/ 2
                                 
                             }
                             else
                             {
                                 carray[pad]->cxcenter:=padspace[pad-numcells]*space
                             };
                             carray[pad]->cycenter:=maxHeight-height/ 2-1;
                             last:=last+separation+width;
                             pad:=pad+1
                         }
                         else
                         {
                             skip
                         }
                     };
                     break$<==0 and skip
                     
                 }
                 else 
                 {
                      skip 
                 };
                 pad:=pad+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         pad:=pad+1
         
     };
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=2) then 
         {
             count:=1;
             width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left;
             break$<==0 and skip;
             pad:=pad+1;
             
             while( break$=0 AND  pad<=numcells+numterms)
             {
                 if(carray[pad]->padside!=2) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     count:=count+1;
                     width:=width+carray[pad]->tileptr->right-carray[pad]->tileptr->left;
                     pad:=pad+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             if(fixLRBT[3]=0) then 
             {
                 space:=coreWidth-width;
                 separation:=space/ (count+1);
                 if(separation<0) then 
                 {
                     separation:=0;
                     if(extern ABS(space,RValue)>zxshift) then 
                     {
                         zxshift:=ABS(space,RValue)
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else
             {
                 space:=( if((coreWidth>=width)) then coreWidth else width)
             };
             coreTop:=rowArray[numRows].ypos+rowHeight/ 2+extraSpace+mttshift;
             pad:=numcells+1;
             
             while(pad<=numcells+numterms)
             {
                 if(carray[pad]->padside=2) then 
                 {
                     height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
                     width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left;
                     if(fixLRBT[3]=0) then 
                     {
                         carray[pad]->cxcenter:=separation+width/ 2
                         
                     }
                     else
                     {
                         carray[pad]->cxcenter:=padspace[pad-numcells]*space
                     };
                     carray[pad]->cycenter:=coreTop+height/ 2;
                     last:=separation+width;
                     break$<==0 and skip;
                     pad:=pad+1;
                     
                     while( break$=0 AND  pad<=numcells+numterms)
                     {
                         if(carray[pad]->padside!=2) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
                             width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left;
                             if(fixLRBT[3]=0) then 
                             {
                                 carray[pad]->cxcenter:=last+separation+width/ 2
                                 
                             }
                             else
                             {
                                 carray[pad]->cxcenter:=padspace[pad-numcells]*space
                             };
                             carray[pad]->cycenter:=coreTop+height/ 2;
                             last:=last+separation+width;
                             pad:=pad+1
                         }
                         else
                         {
                             skip
                         }
                     };
                     break$<==0 and skip
                     
                 }
                 else 
                 {
                      skip 
                 };
                 pad:=pad+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         pad:=pad+1
         
     };
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=1) then 
         {
             count:=1;
             height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
             width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left;
             break$<==0 and skip;
             pad:=pad+1;
             
             while( break$=0 AND  pad<=numcells+numterms)
             {
                 if(carray[pad]->padside!=1) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     count:=count+1;
                     if(carray[pad]->tileptr->right-carray[pad]->tileptr->left>width) then 
                     {
                         width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left
                         
                     }
                     else 
                     {
                          skip 
                     };
                     height:=height+carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
                     pad:=pad+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             maxWidth:=width;
             if(fixLRBT[0]=0) then 
             {
                 space:=coreHeight-height;
                 separation:=space/ (count+1);
                 if(separation<0) then 
                 {
                     separation:=0;
                     zyshift:=ABS(space,RValue)
                     
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else
             {
                 space:=( if((coreHeight>=height)) then coreHeight else height)
             };
             xshift:=maxWidth+extraSpace;
             row:=1;
             
             while(row<=numRows)
             {
                 rowArray[row].startx:=rowArray[row].startx+xshift;
                 rowArray[row].endx:=rowArray[row].endx+xshift;
                 if(rowArray[row].endx1>0) then 
                 {
                     rowArray[row].endx1:=rowArray[row].endx1+xshift;
                     rowArray[row].startx2:=rowArray[row].startx2+xshift
                     
                 }
                 else 
                 {
                      skip 
                 };
                 row:=row+1
                 
             };
             pad:=numcells+1;
             
             while(pad<=numcells+numterms)
             {
                 if(carray[pad]->padside=1) then 
                 {
                     height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
                     width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left;
                     if(fixLRBT[0]=0) then 
                     {
                         carray[pad]->cycenter:=rowArray[1].ypos-rowHeight/ 2+separation+height/ 2-mbbshift
                         
                     }
                     else
                     {
                         carray[pad]->cycenter:=rowArray[1].ypos-rowHeight/ 2-mbbshift+padspace[pad-numcells]*space
                     };
                     carray[pad]->cxcenter:=maxWidth-width/ 2-1;
                     last:=rowArray[1].ypos-rowHeight/ 2+separation+height-mbbshift;
                     break$<==0 and skip;
                     pad:=pad+1;
                     
                     while( break$=0 AND  pad<=numcells+numterms)
                     {
                         if(carray[pad]->padside!=1) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
                             width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left;
                             if(fixLRBT[0]=0) then 
                             {
                                 carray[pad]->cycenter:=last+separation+height/ 2
                                 
                             }
                             else
                             {
                                 carray[pad]->cycenter:=rowArray[1].ypos-rowHeight/ 2-mbbshift+padspace[pad-numcells]*space
                             };
                             carray[pad]->cxcenter:=maxWidth-width/ 2-1;
                             last:=last+separation+height;
                             pad:=pad+1
                         }
                         else
                         {
                             skip
                         }
                     };
                     break$<==0 and skip
                     
                 }
                 else 
                 {
                      skip 
                 };
                 pad:=pad+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         pad:=pad+1
         
     };
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=3) then 
         {
             count:=1;
             height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
             break$<==0 and skip;
             pad:=pad+1;
             
             while( break$=0 AND  pad<=numcells+numterms)
             {
                 if(carray[pad]->padside!=3) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     count:=count+1;
                     height:=height+carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
                     pad:=pad+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             if(fixLRBT[1]=0) then 
             {
                 space:=coreHeight-height;
                 separation:=space/ (count+1);
                 if(separation<0) then 
                 {
                     separation:=0;
                     if(extern ABS(space,RValue)>zyshift) then 
                     {
                         zyshift:=ABS(space,RValue)
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else
             {
                 space:=( if((coreHeight>=height)) then coreHeight else height)
             };
             coreRite:=coreWidth+xshift+extraSpace;
             pad:=numcells+1;
             
             while(pad<=numcells+numterms)
             {
                 if(carray[pad]->padside=3) then 
                 {
                     height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
                     width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left;
                     if(fixLRBT[1]=0) then 
                     {
                         carray[pad]->cycenter:=rowArray[1].ypos-rowHeight/ 2+separation+height/ 2-mbbshift
                         
                     }
                     else
                     {
                         carray[pad]->cycenter:=rowArray[1].ypos-rowHeight/ 2-mbbshift+padspace[pad-numcells]*space
                     };
                     carray[pad]->cxcenter:=coreRite+width/ 2;
                     last:=rowArray[1].ypos-rowHeight/ 2+separation+height-mbbshift;
                     break$<==0 and skip;
                     pad:=pad+1;
                     
                     while( break$=0 AND  pad<=numcells+numterms)
                     {
                         if(carray[pad]->padside!=3) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             height:=carray[pad]->tileptr->top-carray[pad]->tileptr->bottom;
                             width:=carray[pad]->tileptr->right-carray[pad]->tileptr->left;
                             if(fixLRBT[1]=0) then 
                             {
                                 carray[pad]->cycenter:=last+separation+height/ 2
                                 
                             }
                             else
                             {
                                 carray[pad]->cycenter:=rowArray[1].ypos-rowHeight/ 2-mbbshift+padspace[pad-numcells]*space
                             };
                             carray[pad]->cxcenter:=coreRite+width/ 2;
                             last:=last+separation+height;
                             pad:=pad+1
                         }
                         else
                         {
                             skip
                         }
                     };
                     break$<==0 and skip
                     
                 }
                 else 
                 {
                      skip 
                 };
                 pad:=pad+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         pad:=pad+1
         
     };
     macro:=1;
     
     while(macro<=numMacro)
     {
         pad:=padArray[macro];
         carray[pad]->cxcenter:=macroArray[macro].mx+xshift;
         carray[pad]->cycenter:=macroArray[macro].my+yshift+mbbshift;
         macro:=macro+1
         
     };
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=4 OR carray[pad]->padside=2) then 
         {
             carray[pad]->cxcenter:=carray[pad]->cxcenter+xshift
             
         }
         else
         {
             if(carray[pad]->padside=14 OR carray[pad]->padside=15) then 
             {
                 carray[pad]->cxcenter:=carray[pad]->cxcenter+xshift;
                 carray[pad]->cycenter:=carray[pad]->cycenter+yshift
                 
             }
             else 
             {
                  skip 
             }
         };
         pad:=pad+1
         
     };
     row:=1;
     
     while(row<=numRows)
     {
         rowArray[row].startx:=rowArray[row].startx+zxshift/ 2;
         rowArray[row].endx:=rowArray[row].endx+zxshift/ 2;
         if(rowArray[row].endx1>0) then 
         {
             rowArray[row].endx1:=rowArray[row].endx1+zxshift/ 2;
             rowArray[row].startx2:=rowArray[row].startx2+zxshift/ 2
             
         }
         else 
         {
              skip 
         };
         row:=row+1
         
     };
     macro:=1;
     
     while(macro<=numMacro)
     {
         pad:=padArray[macro];
         carray[pad]->cxcenter:=carray[pad]->cxcenter+zxshift/ 2;
         macro:=macro+1
         
     };
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=3) then 
         {
             carray[pad]->cxcenter:=carray[pad]->cxcenter+zxshift
             
         }
         else
         {
             if(carray[pad]->padside=14 OR carray[pad]->padside=15) then 
             {
                 carray[pad]->cxcenter:=carray[pad]->cxcenter+zxshift/ 2
                 
             }
             else 
             {
                  skip 
             }
         };
         pad:=pad+1
         
     };
     yshift:=maxHeight+rowHeight+extraSpace;
     row:=1;
     
     while(row<=numRows)
     {
         rowArray[row].ypos:=rowArray[row].ypos+zyshift/ 2;
         row:=row+1
         
     };
     macro:=1;
     
     while(macro<=numMacro)
     {
         pad:=padArray[macro];
         carray[pad]->cycenter:=carray[pad]->cycenter+zyshift/ 2;
         macro:=macro+1
         
     };
     pad:=numcells+1;
     
     while(pad<=numcells+numterms)
     {
         if(carray[pad]->padside=2) then 
         {
             carray[pad]->cycenter:=carray[pad]->cycenter+zyshift
             
         }
         else
         {
             if(carray[pad]->padside=14 OR carray[pad]->padside=15) then 
             {
                 carray[pad]->cycenter:=carray[pad]->cycenter+zyshift/ 2
                 
             }
             else 
             {
                  skip 
             }
         };
         pad:=pad+1
         
     };
     block:=0;
     row:=1;
     
     while(row<=numRows)
     {
         block:=block+1;
         if(rowArray[row].endx1>0) then 
         {
             block:=block+1
             
         }
         else 
         {
              skip 
         };
         row:=row+1
         
     };
     totalBlock:=block;
     oldbarray:=barray;
     blkToRow:=(int *)safe_malloc((totalBlock+1)*sizeof(int),RValue);
     barray:=(blockbox* *)safe_malloc((totalBlock+1)*sizeof(blockbox*),RValue);
     block:=1;
     
     while(block<=totalBlock)
     {
         barray[block]:=(blockbox*)safe_malloc(sizeof(blockbox),RValue);
         block:=block+1
         
     };
     block:=0;
     row:=1;
     
     while(row<=numRows)
     {
         boxptr:=oldbarray[row];
         if(rowArray[row].endx1>0) then 
         {
             block:=block+1;
             blkToRow[block]:=row;
             barray[block]->bxcenter:=(rowArray[row].startx+rowArray[row].endx1)/ 2;
             barray[block]->bycenter:=rowArray[row].ypos;
             barray[block]->bleft:=rowArray[row].startx-barray[block]->bxcenter;
             barray[block]->bright:=rowArray[row].endx1-barray[block]->bxcenter;
             barray[block]->bbottom:=boxptr->bbottom;
             barray[block]->btop:=boxptr->btop;
             barray[block]->bheight:=boxptr->btop-boxptr->bbottom;
             barray[block]->blength:=rowArray[row].endx1-rowArray[row].startx;
             barray[block]->bclass:=boxptr->bclass;
             barray[block]->borient:=boxptr->borient;
             barray[block]->oldsize:=0;
             block:=block+1;
             blkToRow[block]:=row;
             barray[block]->bxcenter:=(rowArray[row].startx2+rowArray[row].endx)/ 2;
             barray[block]->bycenter:=rowArray[row].ypos;
             barray[block]->bleft:=rowArray[row].startx2-barray[block]->bxcenter;
             barray[block]->bright:=rowArray[row].endx-barray[block]->bxcenter;
             barray[block]->bbottom:=boxptr->bbottom;
             barray[block]->btop:=boxptr->btop;
             barray[block]->bheight:=boxptr->btop-boxptr->bbottom;
             barray[block]->blength:=rowArray[row].endx-rowArray[row].startx2;
             barray[block]->bclass:=boxptr->bclass;
             barray[block]->borient:=boxptr->borient;
             ratio:=(float)barray[block-1]->blength/ (float)(barray[block-1]->blength+barray[block]->blength);
             barray[block]->desire:=1+(int)((1.0-ratio)*rowArray[row].desiredL);
             barray[block-1]->desire:=1+(int)(ratio*rowArray[row].desiredL);
             barray[block]->oldsize:=0
             
         }
         else
         {
             block:=block+1;
             blkToRow[block]:=row;
             barray[block]->bxcenter:=(rowArray[row].startx+rowArray[row].endx)/ 2;
             barray[block]->bycenter:=rowArray[row].ypos;
             barray[block]->bleft:=rowArray[row].startx-barray[block]->bxcenter;
             barray[block]->bright:=rowArray[row].endx-barray[block]->bxcenter;
             barray[block]->bbottom:=boxptr->bbottom;
             barray[block]->btop:=boxptr->btop;
             barray[block]->bheight:=boxptr->btop-boxptr->bbottom;
             barray[block]->blength:=rowArray[row].endx-rowArray[row].startx;
             barray[block]->bclass:=boxptr->bclass;
             barray[block]->borient:=boxptr->borient;
             barray[block]->desire:=rowArray[row].desiredL;
             barray[block]->oldsize:=0
         };
         row:=row+1
         
     };
     row:=1;
     
     while(row<=numblock)
     {
         safe_free(oldbarray[row],RValue);
         row:=row+1
         
     };
     safe_free(oldbarray,RValue);
     numblock:=totalBlock;
     fprintf(fpo,"\n******************\nBLOCK DATA\n") and skip;
     desiredL:=0;
     block:=1;
     
     while(block<=numblock)
     {
         desiredL:=desiredL+barray[block]->desire;
         fprintf(fpo,"block:%d desire:%d\n",block,barray[block]->desire) and skip;
         block:=block+1
         
     };
     fprintf(fpo,"Total Desired Length: %d\n",desiredL) and skip;
     ckt_size_factor:=(float)desiredL;
     filledTo:=(int *)safe_malloc((numblock+1)*sizeof(int),RValue);
     endRow:=(int *)safe_malloc((numblock+1)*sizeof(int),RValue);
     row:=1;
     
     while(row<=numblock)
     {
         filledTo[row]:=barray[row]->bxcenter+barray[row]->bleft;
         endRow[row]:=barray[row]->bxcenter+barray[row]->bright;
         row:=row+1
         
     };
     continue<==0 and skip;
     cell:=1;
     
     while(cell<=numcells)
     {
          continue<==0 and skip;
         cellptr:=carray[cell];
         row:=cellptr->cblock;
         if(row=0) then 
         {
             continue<==1 and skip;
              cell:=cell+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             blk:=RtoB(row,cellptr->cycenter,RValue);
             borient:=barray[blk]->borient;
             cellptr->cblock:=blk;
             width:=cellptr->tileptr->right-cellptr->tileptr->left;
             if(cellptr->cycenter>0) then 
             {
                 carray[cell]->cxcenter:=barray[blk]->bxcenter+barray[blk]->bleft+cellptr->cxcenter+width/ 2;
                 carray[cell]->cycenter:=barray[blk]->bycenter
                 
             }
             else
             {
                 carray[cell]->cxcenter:=barray[blk]->bxcenter+barray[blk]->bright+cellptr->cxcenter-(width-width/ 2);
                 carray[cell]->cycenter:=barray[blk]->bycenter
             };
             if(borient=2) then 
             {
                 cellptr->corient:=1
                 
             }
             else
             {
                 cellptr->corient:=0
             };
             cell:=cell+1
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     continue<==0 and skip;
     cell:=1;
     
     while(cell<=numcells)
     {
          continue<==0 and skip;
         if(carray[cell]->cblock!=0) then 
         {
             continue<==1 and skip;
              cell:=cell+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             empty$:=-32000;
             row:=1;
             
             while(row<=numblock)
             {
                 if(endRow[row]-filledTo[row]>empty$) then 
                 {
                     empty$:=endRow[row]-filledTo[row];
                     block:=row
                     
                 }
                 else 
                 {
                      skip 
                 };
                 row:=row+1
                 
             };
             borient:=barray[block]->borient;
             width:=carray[cell]->tileptr->right-carray[cell]->tileptr->left;
             carray[cell]->cblock:=block;
             if(borient>0) then 
             {
                 carray[cell]->cxcenter:=filledTo[block]+width/ 2;
                 carray[cell]->cycenter:=barray[block]->bycenter;
                 if(borient=2) then 
                 {
                     carray[cell]->corient:=1
                 }
                 else
                 {
                     carray[cell]->corient:=0
                 }
                 
             }
             else
             {
                 carray[cell]->cycenter:=filledTo[block]+width/ 2;
                 carray[cell]->cxcenter:=barray[block]->bxcenter;
                 if(borient=-2) then 
                 {
                     carray[cell]->corient:=4
                 }
                 else
                 {
                     carray[cell]->corient:=7
                 }
             };
             filledTo[block]:=filledTo[block]+width;
             cell:=cell+1
         }
         else
         {
             skip
         }
         
     };

	 	


     continue<==0 and skip;
      return<==1 and skip
     )
     }; 
  function RtoB ( int row,int from,int RValue )
 {
     frame(RtoB_y,RtoB_block,RtoB_block1,RtoB_block2,RtoB_endx1,RtoB_startx2,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     int RtoB_y,RtoB_block,RtoB_block1,RtoB_block2,RtoB_endx1,RtoB_startx2 and skip;
     RtoB_y:=rowArray[row].ypos;
     RtoB_block1:=0;
     RtoB_block2:=0;
     break$<==0 and skip;
     RtoB_block:=1;
     
     while( break$=0 AND  RtoB_block<=numblock)
     {
         if(barray[RtoB_block]->bycenter=RtoB_y) then 
         {
             RtoB_block1:=RtoB_block;
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             RtoB_block:=RtoB_block+1
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     break$<==0 and skip;
     RtoB_block:=RtoB_block+1;
     
     while( break$=0 AND  RtoB_block<=numblock)
     {
         if(barray[RtoB_block]->bycenter=RtoB_y) then 
         {
             RtoB_block2:=RtoB_block;
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             RtoB_block:=RtoB_block+1
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     if(RtoB_block1=0) then 
     {
         fprintf(fpo,"RtoB failed to find block corresponding") and skip;
         fprintf(fpo," to row:%d\n",row) and skip;
         exit(0) and skip 
         
     }
     else 
     {
          skip 
     };
     if(RtoB_block2=0) then 
     {
         RtoB_block:=RtoB_block1
         
     }
     else
     {
         RtoB_endx1:=barray[RtoB_block1]->bxcenter+barray[RtoB_block1]->bright;
         RtoB_startx2:=barray[RtoB_block2]->bxcenter+barray[RtoB_block2]->bleft;
         if(from>0) then 
         {
             if(RtoB_endx1<RtoB_startx2) then 
             {
                 RtoB_block:=RtoB_block1
             }
             else
             {
                 RtoB_block:=RtoB_block2
             }
         }
         else
         {
             if(RtoB_startx2>RtoB_endx1) then 
             {
                 RtoB_block:=RtoB_block2
             }
             else
             {
                 RtoB_block:=RtoB_block1
             }
         }
     };
     return<==1 and RValue:=RtoB_block;
     skip
     )
     }; 
      int old_feed_length<==0 and skip;
 function configuref ( int feed_length )
 {




	 frame(configuref_padptr,configuref_core_left,configuref_core_right,configuref_core_span,configuref_row,configuref_pad,configuref_right,configuref_shift_amount,return) and ( 
     int return<==0 and skip;
     cellbox* configuref_padptr and skip;
     int configuref_core_left,configuref_core_right,configuref_core_span,configuref_row,configuref_pad,configuref_right and skip;
     int configuref_shift_amount and skip;
     configuref_shift_amount:=(feed_length/ numRows)-(old_feed_length/ numRows);
	 
	
     
	 if(configuref_shift_amount=0) then 
     {
         configuref_row:=1;
         
         while(configuref_row<=numRows)
         {
             barray[configuref_row]->oldsize:=0;
             configuref_row:=configuref_row+1
             
         };
          return<==1 and skip
         
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         configuref_core_right:=0;
         configuref_core_left:=10000000;
         configuref_row:=1;
         
         while(configuref_row<=numRows)
         {
             barray[configuref_row]->bright:=barray[configuref_row]->bright+configuref_shift_amount;
             barray[configuref_row]->blength:=barray[configuref_row]->blength+configuref_shift_amount;
             barray[configuref_row]->desire:=barray[configuref_row]->desire+configuref_shift_amount;
             barray[configuref_row]->oldsize:=0;
             rowArray[configuref_row].endx:=rowArray[configuref_row].endx+configuref_shift_amount;
             if(rowArray[configuref_row].startx<configuref_core_left) then 
             {
                 configuref_core_left:=rowArray[configuref_row].startx
                 
             }
             else 
             {
                  skip 
             };
             if(rowArray[configuref_row].endx>configuref_core_right) then 
             {
                 configuref_core_right:=rowArray[configuref_row].endx
                 
             }
             else 
             {
                  skip 
             };
             configuref_row:=configuref_row+1
             
         };
         configuref_core_span:=configuref_core_right-configuref_core_left;
         configuref_pad:=numcells+1;
         
         while(configuref_pad<=numcells+numterms)
         {
             configuref_padptr:=carray[configuref_pad];
             if(configuref_padptr->padside=3 OR configuref_padptr->padside=10 OR configuref_padptr->padside=6 OR configuref_padptr->padside=8) then 
             {
                 configuref_padptr->cxcenter:=configuref_padptr->cxcenter+configuref_shift_amount
                 
             }
             else
             {
                 if(configuref_padptr->padside=2 OR configuref_padptr->padside=4 OR configuref_padptr->padside=14 OR configuref_padptr->padside=15) then 
                 {
                     configuref_right:=configuref_padptr->cxcenter+configuref_padptr->tileptr->right-configuref_core_left;
                     configuref_padptr->cxcenter:=configuref_padptr->cxcenter+(int)(((float)configuref_right/ (float)configuref_core_span)*((float)configuref_shift_amount))
                     
                 }
                 else 
                 {
                      skip 
                 }
             };
             configuref_pad:=configuref_pad+1
             
         };
         old_feed_length:=feed_length;

		


          return<==1 and skip
     }
     else
     {
         skip
     }
     )
     }; 
  function controlf ( int RValue )
 {
     frame(controlf_feed_length,return) and ( 
     int return<==0 and skip;
     int controlf_feed_length and skip;
     controlf_feed_length:=countf(RValue);

	 //output("controlf_feed_length ", controlf_feed_length, "\n") and skip;

     configuref(controlf_feed_length);
     funccost:=findcostf(RValue);
     return<==1 and RValue:=(controlf_feed_length/ fdWidth);
     skip
     )
     }; 
      int *xfeeds_in_row and skip;
     int est_fds and skip;
     int **row_map and skip;
     int num_calls<==0 and skip;
 function countf ( int RValue )
 {
     
	 frame(countf_netptr,countf_cellptr,countf_check,countf_a,countf_value,countf_net,countf_i,countf_row,countf_toprow,countf_botrow,countf_TOP_ROW_FOR_NET,countf_orig_toprow,countf_orig_botrow,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     netbox* countf_netptr and skip;
     cellbox* countf_cellptr and skip;
     int countf_check,countf_a,countf_value and skip;
     int countf_net,countf_i,countf_row,countf_toprow,countf_botrow and skip;
     int countf_TOP_ROW_FOR_NET and skip;
     int countf_orig_toprow,countf_orig_botrow and skip;
     if(num_calls=0) then 
     {
         num_calls:=1;
         prep_feed_count_1(RValue);
         row_map:=(int **)safe_malloc((numRows+2)*sizeof(int *),RValue);
         countf_row:=0;
         
         while(countf_row<=numRows+1)
         {
             row_map[countf_row]:=(int *)safe_malloc(3*sizeof(int),RValue);
             countf_row:=countf_row+1
             
         };
         insert_row(0,RValue)
         
     }
     else
     {
         prep_feed_count(RValue);
         insert_row(1,RValue)
     };
     continue<==0 and skip;
     countf_net:=1;
     
     while(countf_net<=numnets)
     {
          continue<==0 and skip;
         countf_netptr:=netarray[countf_net]->netptr ;
         if((countf_netptr)=NULL) then 
         {
             continue<==1 and skip;
              countf_net:=countf_net+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             countf_i:=0;
             
             while(countf_i<=numRows+1)
             {
                 row_map[countf_i,1]:=-1000;
                 row_map[countf_i,2]:=-2;
                 countf_i:=countf_i+1
                 
             };
             continue<==0 and skip;
             while(countf_netptr!=NULL)
             {
                  continue<==0 and skip;
                 countf_cellptr:=carray[countf_netptr->cell];
                 if(countf_netptr->cell>numcells AND (countf_cellptr->padside=1 OR countf_cellptr->padside=9 OR countf_cellptr->padside=5 OR countf_cellptr->padside=7 OR countf_cellptr->padside=3 OR countf_cellptr->padside=10 OR countf_cellptr->padside=6 OR countf_cellptr->padside=8)) then 
                 {
                     continue<==1 and skip;
                      countf_netptr:=countf_netptr->nterm
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     countf_row:=countf_netptr->row;

					

                     row_map[countf_row,1]:=countf_netptr->xpos;

					  //printf("\nnetptr->xpos: %d\n", countf_netptr->xpos)and skip;
                     
					 if(row_map[countf_row,2]=-2) then 
                     {
                         row_map[countf_row,2]:=feed_situation(countf_row,countf_net,RValue)
                         
                     }
                     else 
                     {
                          skip 
                     };
                     countf_netptr:=countf_netptr->nterm
                 }
                 else
                 {
                     skip
                 }
                 
             };

			 

             continue<==0 and skip;
             countf_botrow:=0;
             countf_toprow:=numRows+1;
             break$<==0 and skip;
             while( break$=0 AND  countf_botrow<=numRows+1)
             {
                 if(row_map[countf_botrow,1]!=-1000) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     countf_botrow:=countf_botrow+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             break$<==0 and skip;
             while( break$=0 AND  countf_toprow>=0)
             {
                 if(row_map[countf_toprow,1]!=-1000) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     countf_toprow:=countf_toprow-1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             countf_orig_toprow:=countf_toprow;
             countf_orig_botrow:=countf_botrow;
             countf_netptr:=netarray[countf_net]->netptr;
             continue<==0 and skip;
             while(countf_netptr!=NULL)
             {
                  continue<==0 and skip;
                 if(countf_netptr->cell<=numcells) then 
                 {
                     continue<==1 and skip;
                      countf_netptr:=countf_netptr->nterm
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     countf_cellptr:=carray[countf_netptr->cell];
                     if(countf_cellptr->padside!=1 AND countf_cellptr->padside!=9 AND countf_cellptr->padside!=5 AND countf_cellptr->padside!=7 AND countf_cellptr->padside!=3 AND countf_cellptr->padside!=10 AND countf_cellptr->padside!=6 AND countf_cellptr->padside!=8) then 
                     {
                         continue<==1 and skip;
                          countf_netptr:=countf_netptr->nterm
                     }
                     else 
                     {
                          skip 
                     };
                     if(continue=0)   then 
                     {
                         countf_row:=countf_netptr->row;
                         if(countf_row<=countf_orig_toprow AND countf_row>=countf_orig_botrow) then 
                         {
                             continue<==1 and skip;
                              countf_netptr:=countf_netptr->nterm
                         }
                         else 
                         {
                              skip 
                         };
                         if(continue=0)   then 
                         {
                             if(countf_row>countf_toprow) then 
                             {
                                 countf_toprow:=countf_row
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(countf_row<countf_botrow) then 
                             {
                                 countf_botrow:=countf_row
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             row_map[countf_row,1]:=countf_netptr->xpos;
                             if(row_map[countf_row,2]=-2) then 
                             {
                                 row_map[countf_row,2]:=feed_situation(countf_row,countf_net,RValue)
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             countf_netptr:=countf_netptr->nterm
                         }
                         else
                         {
                             skip
                         }
                     }
                     else
                     {
                         skip
                     }
                 }
                 else
                 {
                     skip
                 }
                 
             };
             continue<==0 and skip;
             if(countf_toprow!=countf_botrow) then 
             {
                 countf_row:=countf_toprow;
                 countf_TOP_ROW_FOR_NET:=1;
                 continue<==0 and skip;
                 countf_row:=countf_row-1;
                 
                 while(countf_row>=countf_botrow)
                 {
                      continue<==0 and skip;
                     if(row_map[countf_row,1]=-1000) then 
                     {
                         continue<==1 and skip;
                          countf_row:=countf_row-1
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(continue=0)   then 
                     {
                         if(countf_TOP_ROW_FOR_NET=1) then 
                         {
                             if(row_map[countf_toprow,2]=1 OR row_map[countf_toprow,2]=3) then 
                             {
                                 feeds_in_row[countf_toprow]:=feeds_in_row[countf_toprow]+1;
                                 xfeeds_in_row[countf_toprow]:=xfeeds_in_row[countf_toprow]+1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(countf_row>countf_botrow) then 
                         {
                             if(row_map[countf_row,2]!=4) then 
                             {
                                 feeds_in_row[countf_row]:=feeds_in_row[countf_row]+1;
                                 xfeeds_in_row[countf_row]:=xfeeds_in_row[countf_row]+1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(countf_row=countf_botrow) then 
                         {
                             if(row_map[countf_botrow,2]=2 OR row_map[countf_botrow,2]=3) then 
                             {
                                 feeds_in_row[countf_botrow]:=feeds_in_row[countf_botrow]+1;
                                 xfeeds_in_row[countf_botrow]:=xfeeds_in_row[countf_botrow]+1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         countf_check:=countf_toprow-countf_row-1;
                         if(countf_check!=0) then 
                         {
                             countf_a:=countf_toprow-1;
                             
                             while(countf_a>countf_row)
                             {
                                 feeds_in_row[countf_a]:=feeds_in_row[countf_a]+1;
                                 xfeeds_in_row[countf_a]:=xfeeds_in_row[countf_a]+1;
                                 countf_a:=countf_a-1
                                 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         countf_toprow:=countf_row;
                         countf_TOP_ROW_FOR_NET:=0;
                         countf_row:=countf_row-1
                     }
                     else
                     {
                         skip
                     }
                 };
                 continue<==0 and skip
                 
             }
             else
             {
                 if(row_map[countf_toprow,2]=3) then 
                 {
                     feeds_in_row[countf_toprow]:=feeds_in_row[countf_toprow]+1;
                     xfeeds_in_row[countf_toprow]:=xfeeds_in_row[countf_toprow]+1
                     
                 }
                 else 
                 {
                      skip 
                 }
             };
             countf_net:=countf_net+1
         }
         else
         {
             skip
         }
         
     };


	 


     continue<==0 and skip;
     est_fds:=0;
     countf_row:=1;
     
     while(countf_row<=numRows)
     {
         if(xfeeds_in_row[countf_row]>0) then 
         {
             est_fds:=est_fds+xfeeds_in_row[countf_row]
             
         }
         else 
         {
              skip 
         };
         countf_value:=(feeds_in_row[countf_row]*fdWidth)/ binWidth;
         if(feeds_in_row[countf_row]>0) then 
         {
             feeds_in_row[countf_row]:=1+countf_value
             
         }
         else
         {
             feeds_in_row[countf_row]:=0
         };
         countf_row:=countf_row+1
         
     };
     countf_value:=0;
     countf_row:=1;
     
	 



     while(countf_row<=numRows)
     {
         countf_value:=countf_value+feeds_in_row[countf_row];
         countf_row:=countf_row+1
         
     };
	 
     return<==1 and RValue:=(countf_value*binWidth);
     skip
     )
     }; 
  function prep_feed_count_1 ( int RValue )
 {
     frame(temp_i,prep_feed_count_1_pinptr,prep_feed_count_1_cell,prep_feed_count_1_corient,prep_feed_count_1_offset,prep_feed_count_1_row,prep_feed_count_1_total_row_len,return) and ( 
     int return<==0 and skip;
     termbox* prep_feed_count_1_pinptr and skip;
     int prep_feed_count_1_cell,prep_feed_count_1_corient,prep_feed_count_1_offset,prep_feed_count_1_row and skip;
     float prep_feed_count_1_total_row_len and skip;
     prep_feed_count_1_total_row_len:=0;
     prep_feed_count_1_row:=1;
     
     while(prep_feed_count_1_row<=numRows)
     {
         prep_feed_count_1_total_row_len:=prep_feed_count_1_total_row_len+(float)barray[prep_feed_count_1_row]->blength;
         prep_feed_count_1_row:=prep_feed_count_1_row+1
         
     };
     feeds_in_row:=(int *)safe_malloc((1+numRows)*sizeof(int),RValue);
     xfeeds_in_row:=(int *)safe_malloc((1+numRows)*sizeof(int),RValue);
     prep_feed_count_1_offset:=-(int)((float)implicit_feed_count*0.90);

	

     prep_feed_count_1_row:=1;
     
     while(prep_feed_count_1_row<=numRows)
     {
         feeds_in_row[prep_feed_count_1_row]:=(int)((float)prep_feed_count_1_offset*((float)(barray[prep_feed_count_1_row]->blength)/ prep_feed_count_1_total_row_len));
         xfeeds_in_row[prep_feed_count_1_row]:=0;
         prep_feed_count_1_row:=prep_feed_count_1_row+1
         
     };

	 
	 
	 

     prep_feed_count_1_cell:=1;
     
     while(prep_feed_count_1_cell<=numcells+numterms)
     {
         if(prep_feed_count_1_cell<=numcells) then 
         {
             prep_feed_count_1_pinptr:=carray[prep_feed_count_1_cell]->tileptr->termsptr;
             prep_feed_count_1_corient:=carray[prep_feed_count_1_cell]->corient;
             while(prep_feed_count_1_pinptr!=NULL)
             {
                 tearray[prep_feed_count_1_pinptr->cellterm]->unequiv:=prep_feed_count_1_pinptr->ue;
                 tearray[prep_feed_count_1_pinptr->cellterm]->cell:=prep_feed_count_1_cell;
                 if(extern ABS(prep_feed_count_1_pinptr->typos[prep_feed_count_1_corient % 2],RValue)>1) then 
                 {
                     if(prep_feed_count_1_pinptr->typos[prep_feed_count_1_corient % 2]>0) then 
                     {
                         tearray[prep_feed_count_1_pinptr->cellterm]->pinloc:=1
                     }
                     else
                     {
                         tearray[prep_feed_count_1_pinptr->cellterm]->pinloc:=-1
                     }
                     
                 }
                 else
                 {
                     tearray[prep_feed_count_1_pinptr->cellterm]->pinloc:=0
                 };
                 prep_feed_count_1_pinptr:=prep_feed_count_1_pinptr->nextterm
                 
             }
             
         }
         else
         {
             if(prep_feed_count_1_cell>numcells) then 
             {
                 prep_feed_count_1_pinptr:=carray[prep_feed_count_1_cell]->tileptr->termsptr;
                 while(prep_feed_count_1_pinptr!=NULL)
                 {
                     tearray[prep_feed_count_1_pinptr->cellterm]->unequiv:=prep_feed_count_1_pinptr->ue;
                     tearray[prep_feed_count_1_pinptr->cellterm]->cell:=prep_feed_count_1_cell;
                     tearray[prep_feed_count_1_pinptr->cellterm]->pinloc:=0;
                     prep_feed_count_1_pinptr:=prep_feed_count_1_pinptr->nextterm
                     
                 }
                 
             }
             else 
             {
                  skip 
             }
         };
         prep_feed_count_1_cell:=prep_feed_count_1_cell+1
         
     };
      return<==1 and skip
     )
     }; 
  function prep_feed_count ( int RValue )
 {
     frame(temp_i,prep_feed_count_pinptr,prep_feed_count_cell,prep_feed_count_corient,prep_feed_count_offset,prep_feed_count_row,prep_feed_count_total_row_len,return) and ( 
     int return<==0 and skip;
     termbox* prep_feed_count_pinptr and skip;
     int prep_feed_count_cell,prep_feed_count_corient,prep_feed_count_offset,prep_feed_count_row and skip;
     float prep_feed_count_total_row_len and skip;
     prep_feed_count_total_row_len:=0;
     prep_feed_count_row:=1;
     
     while(prep_feed_count_row<=numRows)
     {
         prep_feed_count_total_row_len:=prep_feed_count_total_row_len+(float)barray[prep_feed_count_row]->blength;
         prep_feed_count_row:=prep_feed_count_row+1
         
     };
     prep_feed_count_offset:=-(int)((float)implicit_feed_count*0.90);
     prep_feed_count_row:=1;
     
     while(prep_feed_count_row<=numRows)
     {
         feeds_in_row[prep_feed_count_row]:=(int)((float)prep_feed_count_offset*((float)(barray[prep_feed_count_row]->blength)/ prep_feed_count_total_row_len));
         xfeeds_in_row[prep_feed_count_row]:=0;
         prep_feed_count_row:=prep_feed_count_row+1
         
     };

	


     prep_feed_count_cell:=1;



     
     while(prep_feed_count_cell<=numcells)
     {
         prep_feed_count_pinptr:=carray[prep_feed_count_cell]->tileptr->termsptr;
         prep_feed_count_corient:=carray[prep_feed_count_cell]->corient;
         while(prep_feed_count_pinptr!=NULL)
         {
             if(extern ABS(prep_feed_count_pinptr->typos[prep_feed_count_corient % 2],RValue)>1) then 
             {
                 if(prep_feed_count_pinptr->typos[prep_feed_count_corient % 2]>0) then 
                 {
                     tearray[prep_feed_count_pinptr->cellterm]->pinloc:=1
                 }
                 else
                 {
                     tearray[prep_feed_count_pinptr->cellterm]->pinloc:=-1
                 }
                 
             }
             else
             {
                 tearray[prep_feed_count_pinptr->cellterm]->pinloc:=0
             };
             prep_feed_count_pinptr:=prep_feed_count_pinptr->nextterm
             
         };
         prep_feed_count_cell:=prep_feed_count_cell+1
         
     };
      return<==1 and skip
     )
     }; 
  function insert_row ( int flag,int RValue )
 {
     frame(insert_row_pinptr,insert_row_row,insert_row_cell,insert_row_pad,insert_row_yc,insert_row_yb,insert_row_blk,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     termbox* insert_row_pinptr and skip;
     int insert_row_row,insert_row_cell,insert_row_pad and skip;
     int insert_row_yc,insert_row_yb,insert_row_blk and skip;
     insert_row_cell:=1;
     
     while(insert_row_cell<=numcells)
     {
         insert_row_row:=carray[insert_row_cell]->cblock;
         insert_row_pinptr:=carray[insert_row_cell]->tileptr->termsptr;
         while(insert_row_pinptr!=NULL)
         {
             tearray[insert_row_pinptr->cellterm]->row:=insert_row_row;
             insert_row_pinptr:=insert_row_pinptr->nextterm
             
         };
         insert_row_cell:=insert_row_cell+1
         
     };
     if(flag=0) then 
     {
         insert_row_pad:=numcells+1;
         
         while(insert_row_pad<=numcells+numterms)
         {
             if(carray[insert_row_pad]->padside=2 OR carray[insert_row_pad]->padside=14) then 
             {
                 insert_row_row:=numRows+1;
                 insert_row_pinptr:=carray[insert_row_pad]->tileptr->termsptr;
                 while(insert_row_pinptr!=NULL)
                 {
                     tearray[insert_row_pinptr->cellterm]->row:=insert_row_row;
                     insert_row_pinptr:=insert_row_pinptr->nextterm
                     
                 }
                 
             }
             else
             {
                 if(carray[insert_row_pad]->padside=4 OR carray[insert_row_pad]->padside=15) then 
                 {
                     insert_row_row:=0;
                     insert_row_pinptr:=carray[insert_row_pad]->tileptr->termsptr;
                     while(insert_row_pinptr!=NULL)
                     {
                         tearray[insert_row_pinptr->cellterm]->row:=insert_row_row;
                         insert_row_pinptr:=insert_row_pinptr->nextterm
                         
                     }
                 }
                 else
                 {
                     insert_row_pinptr:=carray[insert_row_pad]->tileptr->termsptr;
                     while(insert_row_pinptr!=NULL)
                     {
                         insert_row_yc:=carray[insert_row_pad]->cycenter+insert_row_pinptr->typos[1];
                         break$<==0 and skip;
                         insert_row_blk:=1;
                         
                         while( break$=0 AND  insert_row_blk<=numRows)
                         {
                             if(rowArray[insert_row_blk].ypos>=insert_row_yc) then 
                             {
                                 break$<==1 and skip
                                  
                             }
                             else 
                             {
                                  skip 
                             };
                             if(break$=0)   then
                             {
                                 insert_row_blk:=insert_row_blk+1
                             }
                             else
                             {
                                 skip
                             }
                             
                         };
                         break$<==0 and skip;
                         if(insert_row_blk=1) then 
                         {
                             insert_row_row:=1
                             
                         }
                         else
                         {
                             if(insert_row_blk>numRows) then 
                             {
                                 insert_row_row:=numRows
                             }
                             else
                             {
                                 insert_row_yb:=rowArray[insert_row_blk].ypos;
                                 if(insert_row_yb-insert_row_yc<insert_row_yc-rowArray[insert_row_blk-1].ypos) then 
                                 {
                                     insert_row_row:=insert_row_blk
                                 }
                                 else
                                 {
                                     insert_row_row:=insert_row_blk-1
                                 }
                             }
                         };
                         tearray[insert_row_pinptr->cellterm]->row:=insert_row_row;
                         insert_row_pinptr:=insert_row_pinptr->nextterm
                         
                     }
                 }
             };
             insert_row_pad:=insert_row_pad+1
             
         }
         
     }
     else 
     {
          skip 
     };
      return<==1 and skip
     )
     }; 
  function feed_situation ( int row,int net,int RValue )
 {
     frame(feed_situation_nptr,feed_situation_cellptr,feed_situation_pinup,feed_situation_pindown,feed_situation_pinloc,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     netbox* feed_situation_nptr and skip;
     cellbox* feed_situation_cellptr and skip;
     int feed_situation_pinup,feed_situation_pindown,feed_situation_pinloc and skip;
     feed_situation_pinup:=0;
     feed_situation_pindown:=0;
     feed_situation_nptr:=netarray[net]->netptr;
     continue<==0 and skip;
     while( return=0 AND  feed_situation_nptr!=NULL)
     {
          continue<==0 and skip;
         if(feed_situation_nptr->row!=row OR feed_situation_nptr->unequiv=1) then 
         {
             continue<==1 and skip;
              feed_situation_nptr:=feed_situation_nptr->nterm
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             feed_situation_cellptr:=carray[feed_situation_nptr->cell];
             if(feed_situation_nptr->cell>numcells AND (feed_situation_cellptr->padside=1 OR feed_situation_cellptr->padside=9 OR feed_situation_cellptr->padside=5 OR feed_situation_cellptr->padside=7 OR feed_situation_cellptr->padside=3 OR feed_situation_cellptr->padside=10 OR feed_situation_cellptr->padside=6 OR feed_situation_cellptr->padside=8)) then 
             {
                 continue<==1 and skip;
                  feed_situation_nptr:=feed_situation_nptr->nterm
             }
             else 
             {
                  skip 
             };
             if(continue=0)   then 
             {
                 feed_situation_pinloc:=feed_situation_nptr->pinloc;
                 if(feed_situation_pinloc=0) then 
                 {
                     return<==1 and RValue:=4;
                     skip
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(return=0)   then 
                 {
                     if(feed_situation_pinloc>0) then 
                     {
                         feed_situation_pinup:=1
                         
                     }
                     else
                     {
                         feed_situation_pindown:=1
                     };
                     feed_situation_nptr:=feed_situation_nptr->nterm
                 }
                 else
                 {
                     skip
                 }
             }
             else
             {
                 skip
             }
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     if(return=0)   then 
     {
         if(feed_situation_pinup=1 AND feed_situation_pindown=0) then 
         {
             return<==1 and RValue:=1;
             skip
         }
         else
         {
             if(feed_situation_pinup=0 AND feed_situation_pindown=1) then 
             {
                 return<==1 and RValue:=2;
                 skip
             }
             else
             {
                 if(feed_situation_pinup=1 AND feed_situation_pindown=1) then 
                 {
                     return<==1 and RValue:=3;
                     skip
                 }
                 else
                 {
                     return<==1 and RValue:=0;
                     skip
                 }
             }
         }
     }
     else
     {
         skip
     }
     )
     }; 
  function getCompileDate ( char* RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
     return<==1 and RValue:=(strclone("Mon Jan 25 18:50:36 EST 1988",RValue));
     skip
     )
     }; 
  function cellbox_data ( int first_cell,int last_cell )
 {
     frame(cellbox_data_fp,cellbox_data_ptr,cellbox_data_cell) and ( 
     FILE *cellbox_data_fp and skip;
     cellbox* cellbox_data_ptr and skip;
     int cellbox_data_cell and skip;
     cellbox_data_fp:=twopen("debug.cellbox","a",1,RValue);
     fprintf(cellbox_data_fp," cell xcenter ycenter corient padside left right\n") and skip;
     cellbox_data_cell:=first_cell;
     
     while(cellbox_data_cell<=last_cell)
     {
         cellbox_data_ptr:=carray[cellbox_data_cell];
         fprintf(cellbox_data_fp,"%5d  %6d  %6d      %2d      %2d %4d  %4d\n",cellbox_data_cell,cellbox_data_ptr->cxcenter,cellbox_data_ptr->cycenter,cellbox_data_ptr->corient,cellbox_data_ptr->padside,cellbox_data_ptr->tileptr->left,cellbox_data_ptr->tileptr->right) and skip;
         cellbox_data_cell:=cellbox_data_cell+1
         
     };
     twclose(cellbox_data_fp)
     )
     }; 
  function cellterm_data ( int first_cell,int last_cell )
 {
     frame(cellterm_data_fp,cellterm_data_ptr,cellterm_data_termptr,cellterm_data_ttermptr,cellterm_data_cell,cellterm_data_corient) and ( 
     FILE *cellterm_data_fp and skip;
     cellbox* cellterm_data_ptr and skip;
     termbox* cellterm_data_termptr and skip;
     netbox* cellterm_data_ttermptr and skip;
     int cellterm_data_cell,cellterm_data_corient and skip;
     cellterm_data_fp:=twopen("debug.cellterm","a",1,RValue);
     cellterm_data_cell:=first_cell;
     
     while(cellterm_data_cell<=last_cell)
     {
         fprintf(cellterm_data_fp,"\n cell xcenter ycenter corient padside left right\n") and skip;
         cellterm_data_ptr:=carray[cellterm_data_cell];
         cellterm_data_corient:=cellterm_data_ptr->corient;
         fprintf(cellterm_data_fp,"%5d  %6d  %6d      %2d      %2d %4d  %4d\n",cellterm_data_cell,cellterm_data_ptr->cxcenter,cellterm_data_ptr->cycenter,cellterm_data_corient,cellterm_data_ptr->padside,cellterm_data_ptr->tileptr->left,cellterm_data_ptr->tileptr->right) and skip;
         fprintf(cellterm_data_fp,"   pin  net   tx   ty   xpos   ypos   newx   newy ") and skip;
         fprintf(cellterm_data_fp,"loc ue flag\n") and skip;
         if(cellterm_data_cell<=numcells) then 
         {
             cellterm_data_termptr:=cellterm_data_ptr->tileptr->termsptr;
             
             while(cellterm_data_termptr!=NULL)
             {
                 cellterm_data_ttermptr:=tearray[cellterm_data_termptr->cellterm];
                 fprintf(cellterm_data_fp," %5d %4d %4d %4d %6d %6d %6d %6d %3d %2d  %2d\n",cellterm_data_termptr->cellterm,cellterm_data_ttermptr->net,cellterm_data_termptr->txpos[cellterm_data_corient/ 2],cellterm_data_termptr->typos[cellterm_data_corient % 2],cellterm_data_ttermptr->xpos,cellterm_data_ttermptr->ypos,cellterm_data_ttermptr->newx,cellterm_data_ttermptr->newy,cellterm_data_ttermptr->pinloc,cellterm_data_ttermptr->unequiv,cellterm_data_ttermptr->flag) and skip;
                 cellterm_data_termptr:=cellterm_data_termptr->nextterm
                 
             }
             
         }
         else
         {
             cellterm_data_termptr:=cellterm_data_ptr->tileptr->termsptr;
             
             while(cellterm_data_termptr!=NULL)
             {
                 cellterm_data_ttermptr:=tearray[cellterm_data_termptr->cellterm];
                 fprintf(cellterm_data_fp," %5d %4d %4d %4d %6d %6d %6d %6d %3d %2d  %2d\n",cellterm_data_termptr->cellterm,cellterm_data_ttermptr->net,cellterm_data_termptr->txpos[1],cellterm_data_termptr->typos[1],cellterm_data_ttermptr->xpos,cellterm_data_ttermptr->ypos,cellterm_data_ttermptr->newx,cellterm_data_ttermptr->newy,cellterm_data_ttermptr->pinloc,cellterm_data_ttermptr->unequiv,cellterm_data_ttermptr->flag) and skip;
                 cellterm_data_termptr:=cellterm_data_termptr->nextterm
                 
             }
         };
         cellterm_data_cell:=cellterm_data_cell+1
         
     };
     twclose(cellterm_data_fp)
     )
     }; 
  function terminal ( int first_net,int last_net )
 {
     frame(terminal_fp,terminal_netptr,terminal_net) and ( 
     FILE *terminal_fp and skip;
     netbox* terminal_netptr and skip;
     int terminal_net and skip;
     terminal_fp:=twopen("debug.terminal","a",1,RValue);
     terminal_net:=first_net;
     
     while(terminal_net<=last_net)
     {
         fprintf(terminal_fp,"net %d\n",terminal_net) and skip;
         fprintf(terminal_fp," terminal  xpos  ypos  newx  newy  cell loc ue flag extint\n") and skip;
         terminal_netptr:=netarray[terminal_net]->netptr;
         
         while(terminal_netptr!=NULL)
         {
             fprintf(terminal_fp,"    %5d %5d %5d %5d %5d %5d %3d %2d    %1d %6d\n",terminal_netptr->terminal,terminal_netptr->xpos,terminal_netptr->ypos,terminal_netptr->newx,terminal_netptr->newy,terminal_netptr->cell,terminal_netptr->pinloc,terminal_netptr->unequiv,terminal_netptr->flag,terminal_netptr->extint) and skip;
             terminal_netptr:=terminal_netptr->nterm
             
         };
         terminal_net:=terminal_net+1
         
     };
     twclose(terminal_fp)
     )
     }; 
  function pairCheck ( int first_row,int last_row )
 {
     frame(pairCheck_fp,pairCheck_cellptr,pairCheck_tileptr,pairCheck_row,pairCheck_i,pairCheck_j,pairCheck_bin_left_edge,pairCheck_Aray,pairCheck_cell,pairCheck_bin,pairCheck_most_left,pairCheck_most_rite) and ( 
     FILE *pairCheck_fp and skip;
     cellbox* pairCheck_cellptr and skip;
     tilebox* pairCheck_tileptr and skip;
     int pairCheck_row,pairCheck_i,pairCheck_j,pairCheck_bin_left_edge,*pairCheck_Aray,pairCheck_cell,pairCheck_bin and skip;
     int pairCheck_most_left,pairCheck_most_rite and skip;
     pairCheck_fp:=twopen("dbg.pairCheck","a",1,RValue);
     fprintf(pairCheck_fp,"cedge_binwidth = %d num_edgebin = %d\n",cedge_binwidth,num_edgebin) and skip;
     pairCheck_row:=first_row;
     
     while(pairCheck_row<=last_row)
     {
         pairCheck_Aray:=pairArray[pairCheck_row];
         fprintf(pairCheck_fp,"\nROW %d\n",pairCheck_row) and skip;
         fprintf(pairCheck_fp," total number of cells in this row = %d\n",pairCheck_Aray[0]) and skip;
         pairCheck_cellptr:=carray[pairCheck_Aray[1]];
         pairCheck_most_left:=pairCheck_cellptr->cxcenter+pairCheck_cellptr->tileptr->left;
         pairCheck_cellptr:=carray[pairCheck_Aray[pairCheck_Aray[0]]];
         pairCheck_most_rite:=pairCheck_cellptr->cxcenter+pairCheck_cellptr->tileptr->right;
         fprintf(pairCheck_fp," most_left is at %d most_rite is at \n",pairCheck_most_left,pairCheck_most_rite) and skip;
         fprintf(pairCheck_fp,"   i  cell  left right height   top bottom\n") and skip;
         pairCheck_i:=1;
         
         while(pairCheck_i<=pairCheck_Aray[0])
         {
             pairCheck_cell:=pairCheck_Aray[pairCheck_i];
             pairCheck_cellptr:=carray[pairCheck_cell];
             pairCheck_tileptr:=pairCheck_cellptr->tileptr;
             fprintf(pairCheck_fp," %3d %5d %5d %5d %6d %5d %6d\n",pairCheck_i,pairCheck_cell,pairCheck_tileptr->left+pairCheck_cellptr->cxcenter,pairCheck_tileptr->right+pairCheck_cellptr->cxcenter,pairCheck_cellptr->cheight,pairCheck_tileptr->top,-pairCheck_tileptr->bottom) and skip;
             pairCheck_i:=pairCheck_i+1
             
         };
         fprintf(pairCheck_fp," bin index cell bin_left_edge\n") and skip;
         pairCheck_bin_left_edge:=pairCheck_most_left;
         pairCheck_bin:=1;
         
         while(pairCheck_bin<=num_edgebin)
         {
             pairCheck_j:=cedgebin[pairCheck_row,pairCheck_bin];
             fprintf(pairCheck_fp," %3d %5d %4d        %5d\n",pairCheck_bin,pairCheck_j,pairCheck_Aray[pairCheck_j],pairCheck_bin_left_edge) and skip;
             pairCheck_bin_left_edge:=pairCheck_bin_left_edge+cedge_binwidth;
             pairCheck_bin:=pairCheck_bin+1
             
         };
         pairCheck_row:=pairCheck_row+1
         
     };
     twclose(pairCheck_fp)
     )
     }; 
  function trackdebug ( int status )
 {
     frame(trackdebug_filename,trackdebug_i,trackdebug_row,trackdebug_fcell,trackdebug_cht,trackdebug_fht,trackdebug_newtrack,trackdebug_fp,trackdebug_gdptr,trackdebug_startptr,trackdebug_endptr,trackdebug_netptr) and ( 
     char trackdebug_filename[64] and skip;
     int trackdebug_i,trackdebug_row,trackdebug_fcell,trackdebug_cht,trackdebug_fht,trackdebug_newtrack and skip;
     FILE *trackdebug_fp and skip;
     changrdbox* trackdebug_gdptr,trackdebug_startptr,trackdebug_endptr and skip;
     netbox* trackdebug_netptr and skip;
     trackdebug_fp:=twopen("trackdbg","a",1,RValue);
     fprintf(trackdebug_fp,"\n S nS tk nt Tk rs   pin  xpos  newx  cell  fcel cht fht\n") and skip;
     trackdebug_gdptr:=ULgrdptr;
     
     while(trackdebug_gdptr!=URgrdptr->nextgrd)
     {
         trackdebug_netptr:=trackdebug_gdptr->netptr;
         trackdebug_fht:=fcellheight(trackdebug_netptr->terminal,&trackdebug_fcell,status,RValue);
         if(trackdebug_netptr->pinloc=1) then 
         {
             trackdebug_cht:=carray[trackdebug_netptr->cell]->tileptr->top
             
         }
         else
         {
             if(trackdebug_netptr->pinloc=0) then 
             {
                 trackdebug_cht:=0
             }
             else
             {
                 trackdebug_cht:=-carray[trackdebug_netptr->cell]->tileptr->bottom
             }
         };
         if(status=0) then 
         {
             trackdebug_newtrack:=trackdebug_gdptr->tracks-(trackdebug_cht+trackdebug_fht)/ track_spacing
             
         }
         else
         {
             trackdebug_newtrack:=trackdebug_gdptr->ntracks-(trackdebug_cht+trackdebug_fht)/ track_spacing
         };
         fprintf(trackdebug_fp,"%2d %2d %2d %2d %2d %2d %5d %5d %5d %5d %5d %3d %3d\n",trackdebug_gdptr->SegType,trackdebug_gdptr->nSegType,trackdebug_gdptr->tracks,trackdebug_gdptr->ntracks,trackdebug_newtrack,(trackdebug_cht+trackdebug_fht)/ track_spacing,trackdebug_netptr->terminal,trackdebug_netptr->xpos,trackdebug_netptr->newx,trackdebug_netptr->cell,trackdebug_fcell,trackdebug_cht,trackdebug_fht) and skip;
         if(status=0) then 
         {
             trackdebug_gdptr:=trackdebug_gdptr->nextgrd
         }
         else
         {
             trackdebug_gdptr:=trackdebug_gdptr->nnextgrd
         }
         
     };
     fprintf(trackdebug_fp,"\n S nS tk nt Tk rs   pin  xpos  newx  cell  fcel cht fht\n") and skip;
     trackdebug_gdptr:=LLgrdptr;
     
     while(trackdebug_gdptr!=LRgrdptr->nextgrd)
     {
         trackdebug_netptr:=trackdebug_gdptr->netptr;
         trackdebug_fht:=fcellheight(trackdebug_netptr->terminal,&trackdebug_fcell,status,RValue);
         if(trackdebug_netptr->pinloc=1) then 
         {
             trackdebug_cht:=carray[trackdebug_netptr->cell]->tileptr->top
             
         }
         else
         {
             if(trackdebug_netptr->pinloc=0) then 
             {
                 trackdebug_cht:=0
             }
             else
             {
                 trackdebug_cht:=-carray[trackdebug_netptr->cell]->tileptr->bottom
             }
         };
         if(status=0) then 
         {
             trackdebug_newtrack:=trackdebug_gdptr->tracks-(trackdebug_cht+trackdebug_fht)/ track_spacing
             
         }
         else
         {
             trackdebug_newtrack:=trackdebug_gdptr->ntracks-(trackdebug_cht+trackdebug_fht)/ track_spacing
         };
         fprintf(trackdebug_fp,"%2d %2d %2d %2d %2d %2d %5d %5d %5d %5d %5d %3d %3d\n",trackdebug_gdptr->SegType,trackdebug_gdptr->nSegType,trackdebug_gdptr->tracks,trackdebug_gdptr->ntracks,trackdebug_newtrack,(trackdebug_cht+trackdebug_fht)/ track_spacing,trackdebug_netptr->terminal,trackdebug_netptr->xpos,trackdebug_netptr->newx,trackdebug_netptr->cell,trackdebug_fcell,trackdebug_cht,trackdebug_fht) and skip;
         if(status=0) then 
         {
             trackdebug_gdptr:=trackdebug_gdptr->nextgrd
         }
         else
         {
             trackdebug_gdptr:=trackdebug_gdptr->nnextgrd
         }
         
     };
     twclose(trackdebug_fp)
     )
     }; 
  function fcellheight ( int pin,int *fcell,int status,int RValue )
 {
     frame(fcellheight_cellptr,fcellheight_bin,fcellheight_i,fcellheight_Aray,fcellheight_most_left,fcellheight_most_rite,fcellheight_nrow,fcellheight_pin_x,fcellheight_crite,fcellheight_row,fcellheight_pinloc,return) and ( 
     int return<==0 and skip;
     cellbox* fcellheight_cellptr and skip;
     int fcellheight_bin,fcellheight_i,*fcellheight_Aray,fcellheight_most_left,fcellheight_most_rite and skip;
     int fcellheight_nrow,fcellheight_pin_x,fcellheight_crite,fcellheight_row,fcellheight_pinloc and skip;
     fcellheight_row:=tearray[pin]->row;
     fcellheight_pinloc:=tearray[pin]->pinloc;
     if(1<=fcellheight_row AND fcellheight_row<=numRows) then 
     {
         fcellheight_nrow:=fcellheight_row+fcellheight_pinloc;
         if(fcellheight_nrow=0 OR fcellheight_nrow=numChans OR fcellheight_pinloc=0) then 
         {
             * fcell:=0;
             return<==1 and RValue:=0;
             skip
             
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         if(fcellheight_row=0) then 
         {
             fcellheight_nrow:=1
         }
         else
         {
             fcellheight_nrow:=numRows
         }
     };
     if(return=0)  then
     {
         fcellheight_Aray:=pairArray[fcellheight_nrow];
         if(status=0) then 
         {
             fcellheight_pin_x:=tearray[pin]->newx
             
         }
         else
         {
             fcellheight_pin_x:=tearray[pin]->xpos
         };
         fcellheight_cellptr:=carray[fcellheight_Aray[1]];
         fcellheight_most_left:=fcellheight_cellptr->cxcenter+fcellheight_cellptr->tileptr->left;
         fcellheight_cellptr:=carray[fcellheight_Aray[fcellheight_Aray[0]]];
         fcellheight_most_rite:=fcellheight_cellptr->cxcenter+fcellheight_cellptr->tileptr->right;
         if(fcellheight_pin_x<fcellheight_most_left OR fcellheight_pin_x>fcellheight_most_rite) then 
         {
             * fcell:=0;
             return<==1 and RValue:=0;
             skip
             
         }
         else 
         {
              skip 
         };
         if(return=0)   then 
         {
             fcellheight_bin:=(fcellheight_pin_x-fcellheight_most_left)/ cedge_binwidth+1;
             fcellheight_i:=cedgebin[fcellheight_nrow,fcellheight_bin] ;
             if((fcellheight_i)=0) then 
             {
                 * fcell:=0;
                 return<==1 and RValue:=0;
                 skip
                 
             }
             else 
             {
                  skip 
             };
             if(return=0)   then 
             {
                 * fcell:=fcellheight_Aray[fcellheight_i];
                 fcellheight_cellptr:=carray[* fcell];
                 fcellheight_crite:=fcellheight_cellptr->tileptr->right+fcellheight_cellptr->cxcenter;
                 while(fcellheight_crite<fcellheight_pin_x AND fcellheight_i<fcellheight_Aray[0])
                 {
                     * fcell:=fcellheight_Aray[(fcellheight_i+1)];
                     fcellheight_i:=fcellheight_i+1;
                     fcellheight_cellptr:=carray[* fcell];
                     fcellheight_crite:=fcellheight_crite+fcellheight_cellptr->clength
                 };
                 if(fcellheight_crite=fcellheight_pin_x AND fcellheight_i!=fcellheight_Aray[0]) then 
                 {
                     if(carray[fcellheight_Aray[fcellheight_i+1]]->cheight>fcellheight_cellptr->cheight) then 
                     {
                         * fcell:=fcellheight_Aray[fcellheight_i+1];
                         fcellheight_cellptr:=carray[* fcell]
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(1<=fcellheight_row AND fcellheight_row<=numRows) then 
                 {
                     if(fcellheight_pinloc=1) then 
                     {
                         return<==1 and RValue:=(-fcellheight_cellptr->tileptr->bottom);
                         skip
                     }
                     else
                     {
                         return<==1 and RValue:=(fcellheight_cellptr->tileptr->top);
                         skip
                     }
                 }
                 else
                 {
                     if(fcellheight_row=0) then 
                     {
                         return<==1 and RValue:=(-fcellheight_cellptr->tileptr->bottom);
                         skip
                     }
                     else
                     {
                         return<==1 and RValue:=(fcellheight_cellptr->tileptr->top);
                         skip
                     }
                 }
             }
             else
             {
                 skip
             }
         }
         else
         {
             skip
         }
     }
     else
     {
         skip
     }
     )
     }; 
  function chan_debug ( int start_chan,int end_chan,int status )
 {
     frame(chan_debug_filename,chan_debug_i,chan_debug_row,chan_debug_fcell,chan_debug_cht,chan_debug_fht,chan_debug_chan,chan_debug_newtrack,chan_debug_fp,chan_debug_gdptr,chan_debug_netptr) and ( 
     char chan_debug_filename[64] and skip;
     int chan_debug_i,chan_debug_row,chan_debug_fcell,chan_debug_cht,chan_debug_fht,chan_debug_chan,chan_debug_newtrack and skip;
     FILE *chan_debug_fp and skip;
     changrdbox* chan_debug_gdptr and skip;
     netbox* chan_debug_netptr and skip;
     chan_debug_fp:=twopen("chandbg","a",1,RValue);
     chan_debug_chan:=start_chan;
     
     while(chan_debug_chan<=end_chan)
     {
         fprintf(chan_debug_fp,"\n channel = %d\n",chan_debug_chan) and skip;
         fprintf(chan_debug_fp,"\n S nS tk nt Tk rs   pin  xpos  newx  cell  fcel cht fht\n") and skip;
         if(status=0) then 
         {
             chan_debug_gdptr:=Begin[chan_debug_chan]->nextgrd
             
         }
         else
         {
             chan_debug_gdptr:=Begin[chan_debug_chan]->nnextgrd
         };
         while(chan_debug_gdptr!=End[chan_debug_chan])
         {
             chan_debug_netptr:=chan_debug_gdptr->netptr;
             chan_debug_fht:=fcellheight(chan_debug_netptr->terminal,&chan_debug_fcell,status,RValue);
             if(chan_debug_netptr->pinloc=1) then 
             {
                 chan_debug_cht:=carray[chan_debug_netptr->cell]->tileptr->top
                 
             }
             else
             {
                 if(chan_debug_netptr->pinloc=0) then 
                 {
                     chan_debug_cht:=0
                 }
                 else
                 {
                     chan_debug_cht:=-carray[chan_debug_netptr->cell]->tileptr->bottom
                 }
             };
             if(status=0) then 
             {
                 chan_debug_newtrack:=chan_debug_gdptr->tracks-(chan_debug_cht+chan_debug_fht)/ track_spacing
                 
             }
             else
             {
                 chan_debug_newtrack:=chan_debug_gdptr->ntracks-(chan_debug_cht+chan_debug_fht)/ track_spacing
             };
             fprintf(chan_debug_fp,"%2d %2d %2d %2d %2d %2d %5d %5d %5d %5d %5d %3d %3d\n",chan_debug_gdptr->SegType,chan_debug_gdptr->nSegType,chan_debug_gdptr->tracks,chan_debug_gdptr->ntracks,chan_debug_newtrack,(chan_debug_cht+chan_debug_fht)/ track_spacing,chan_debug_netptr->terminal,chan_debug_netptr->xpos,chan_debug_netptr->newx,chan_debug_netptr->cell,chan_debug_fcell,chan_debug_cht,chan_debug_fht) and skip;
             if(status=0) then 
             {
                 chan_debug_gdptr:=chan_debug_gdptr->nextgrd
             }
             else
             {
                 chan_debug_gdptr:=chan_debug_gdptr->nnextgrd
             }
             
         };
         chan_debug_chan:=chan_debug_chan+1
         
     };
     twclose(chan_debug_fp)
     )
     }; 
  function negative (  )
 {
     frame(negative_netptr,negative_gdptr,negative_channel) and ( 
     netbox* negative_netptr and skip;
     changrdbox* negative_gdptr and skip;
     int negative_channel and skip;
     negative_channel:=1;
     
     while(negative_channel<=numChans)
     {
         negative_gdptr:=Begin[negative_channel]->nnextgrd;
         
         while(negative_gdptr!=NULL)
         {
             negative_netptr:=negative_gdptr->netptr;
             if(negative_gdptr->ntracks<0) then 
             {
                 output ("channel   pin  xpos  newx  cell   net\n") and skip;
                 output ("    ",negative_channel," ",negative_netptr->terminal," ",negative_netptr->xpos," ",negative_netptr->newx," ",negative_netptr->cell," ",negative_netptr->net,"\n") and skip
                 
             }
             else 
             {
                  skip 
             };
             negative_gdptr:=negative_gdptr->nnextgrd
             
         };
         negative_channel:=negative_channel+1
         
     }
     )
     }; 
      int delta_vert_cost and skip;
     int tot_num_feeds and skip;
     int tot_missing_rows and skip;
     int *num_feeds and skip;
     int *tmp_num_feeds and skip;
     int *missing_rows and skip;
     int *tmp_missing_rows and skip;
     char **rows_1 and skip;
     char **tmp_rows and skip;
 function check_cost ( int RValue )
 {
     frame(check_cost_dimptr,check_cost_netptr,check_cost_termptr,check_cost_old_mean,check_cost_oldx,check_cost_net,check_cost_initial_cost,check_cost_total,return) and ( 
     int return<==0 and skip;
     dimbox* check_cost_dimptr and skip;
     netbox* check_cost_netptr and skip;
     termbox* check_cost_termptr and skip;
     int check_cost_old_mean,check_cost_oldx,check_cost_net,check_cost_initial_cost,check_cost_total and skip;
     check_cost_initial_cost:=0;
     check_cost_net:=1;
     
     while(check_cost_net<=numnets)
     {
         check_cost_dimptr:=netarray[check_cost_net];
         check_cost_total:=0;
         check_cost_netptr:=check_cost_dimptr->netptr;
         
         while(check_cost_netptr)
         {
             check_cost_total:=check_cost_total+check_cost_netptr->xpos;
             check_cost_netptr:=check_cost_netptr->nterm
             
         };
         check_cost_old_mean:=check_cost_total/ check_cost_dimptr->numpins;
         check_cost_netptr:=check_cost_dimptr->netptr;
         
         while(check_cost_netptr)
         {
             check_cost_oldx:=check_cost_netptr->xpos;
             check_cost_initial_cost:=check_cost_initial_cost+extern ABS(check_cost_oldx-check_cost_old_mean,RValue);
             check_cost_netptr:=check_cost_netptr->nterm
             
         };
         check_cost_net:=check_cost_net+1
         
     };
     return<==1 and RValue:=check_cost_initial_cost;
     skip
     )
     }; 
  function initialize_cost ( int RValue )
 {
     frame(initialize_cost_dimptr,initialize_cost_netptr,initialize_cost_termptr,initialize_cost_old_mean,initialize_cost_oldx,initialize_cost_net,initialize_cost_initial_cost,return) and ( 
     int return<==0 and skip;
     dimbox* initialize_cost_dimptr and skip;
     netbox* initialize_cost_netptr and skip;
     termbox* initialize_cost_termptr and skip;
     int initialize_cost_old_mean,initialize_cost_oldx,initialize_cost_net,initialize_cost_initial_cost and skip;
     initialize_cost_initial_cost:=0;
     initialize_cost_net:=1;
     
     while(initialize_cost_net<=numnets)
     {
         initialize_cost_dimptr:=netarray[initialize_cost_net];
         initialize_cost_dimptr->old_total:=0;
         initialize_cost_netptr:=initialize_cost_dimptr->netptr;
         
         while(initialize_cost_netptr)
         {
             initialize_cost_dimptr->old_total:=initialize_cost_dimptr->old_total+initialize_cost_netptr->xpos;
             initialize_cost_netptr:=initialize_cost_netptr->nterm
             
         };
         initialize_cost_old_mean:=initialize_cost_dimptr->old_total/ initialize_cost_dimptr->numpins;
         initialize_cost_netptr:=initialize_cost_dimptr->netptr;
         
         while(initialize_cost_netptr)
         {
             initialize_cost_oldx:=initialize_cost_netptr->xpos;
             initialize_cost_initial_cost:=initialize_cost_initial_cost+extern ABS(initialize_cost_oldx-initialize_cost_old_mean,RValue);
             initialize_cost_netptr:=initialize_cost_netptr->nterm
             
         };
         initialize_cost_net:=initialize_cost_net+1
         
     };
     return<==1 and RValue:=initialize_cost_initial_cost;
     skip
     )
     }; 
  function new_dbox ( termbox* antrmptr,int *costptr )
 {
     frame(new_dbox_netptr,new_dbox_dimptr,new_dbox_termptr,new_dbox_old_mean,new_dbox_new_mean,new_dbox_oldx,new_dbox_newx,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     netbox* new_dbox_netptr and skip;
     dimbox* new_dbox_dimptr and skip;
     termbox* new_dbox_termptr and skip;
     int new_dbox_old_mean,new_dbox_new_mean,new_dbox_oldx,new_dbox_newx and skip;
     continue<==0 and skip;
     new_dbox_termptr:=antrmptr;
     
     while(new_dbox_termptr)
     {
          continue<==0 and skip;
         new_dbox_dimptr:=netarray[new_dbox_termptr->net];
         if(new_dbox_dimptr->dflag=0) then 
         {
             continue<==1 and skip;
              new_dbox_termptr:=new_dbox_termptr->nextterm
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             new_dbox_dimptr->dflag:=0;
             new_dbox_new_mean:=new_dbox_dimptr->new_total/ new_dbox_dimptr->numpins;
             new_dbox_old_mean:=new_dbox_dimptr->old_total/ new_dbox_dimptr->numpins;
             new_dbox_netptr:=new_dbox_dimptr->netptr;
             
             while(new_dbox_netptr)
             {
                 new_dbox_oldx:=new_dbox_netptr->xpos;
                 if(new_dbox_netptr->flag=1) then 
                 {
                     new_dbox_newx:=new_dbox_netptr->newx;
                     new_dbox_netptr->flag:=0
                     
                 }
                 else
                 {
                     new_dbox_newx:=new_dbox_oldx
                 };
                 * costptr:=* costptr+extern ABS(new_dbox_newx-new_dbox_new_mean,RValue)-extern ABS(new_dbox_oldx-new_dbox_old_mean,RValue);
                 new_dbox_netptr:=new_dbox_netptr->nterm
                 
             };
             new_dbox_termptr:=new_dbox_termptr->nextterm
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
      return<==1 and skip
     )
     }; 
  function new_dbox_a ( termbox* antrmptr,int *costptr )
 {
     frame(new_dbox_a_dimptr,new_dbox_a_netptr,new_dbox_a_termptr,new_dbox_a_old_mean,new_dbox_a_new_mean,new_dbox_a_oldx,new_dbox_a_newx,new_dbox_a_f,new_dbox_a_m,new_dbox_a_min,new_dbox_a_max,new_dbox_a_row,new_dbox_a_net,new_dbox_a_rowsptr,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     dimbox* new_dbox_a_dimptr and skip;
     netbox* new_dbox_a_netptr and skip;
     termbox* new_dbox_a_termptr and skip;
     int new_dbox_a_old_mean,new_dbox_a_new_mean,new_dbox_a_oldx,new_dbox_a_newx and skip;
     int new_dbox_a_f,new_dbox_a_m,new_dbox_a_min,new_dbox_a_max,new_dbox_a_row,new_dbox_a_net and skip;
     char *new_dbox_a_rowsptr and skip;
     continue<==0 and skip;
     new_dbox_a_termptr:=antrmptr;
     
     while(new_dbox_a_termptr)
     {
          continue<==0 and skip;
         new_dbox_a_net:=new_dbox_a_termptr->net;
         new_dbox_a_dimptr:=netarray[new_dbox_a_net];
         if(new_dbox_a_dimptr->dflag=0) then 
         {
             continue<==1 and skip;
              new_dbox_a_termptr:=new_dbox_a_termptr->nextterm
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             new_dbox_a_dimptr->dflag:=0;
             new_dbox_a_new_mean:=new_dbox_a_dimptr->new_total/ new_dbox_a_dimptr->numpins;
             new_dbox_a_old_mean:=new_dbox_a_dimptr->old_total/ new_dbox_a_dimptr->numpins;
             new_dbox_a_netptr:=new_dbox_a_dimptr->netptr;
             
             while(new_dbox_a_netptr)
             {
                 new_dbox_a_oldx:=new_dbox_a_netptr->xpos;
                 if(new_dbox_a_netptr->flag=1) then 
                 {
                     new_dbox_a_newx:=new_dbox_a_netptr->newx;
                     new_dbox_a_netptr->flag:=0
                     
                 }
                 else
                 {
                     new_dbox_a_newx:=new_dbox_a_oldx
                 };
                 * costptr:=* costptr+extern ABS(new_dbox_a_newx-new_dbox_a_new_mean,RValue)-extern ABS(new_dbox_a_oldx-new_dbox_a_old_mean,RValue);
                 new_dbox_a_netptr:=new_dbox_a_netptr->nterm
                 
             };
             new_dbox_a_f:=0;
             new_dbox_a_m:=0;
             new_dbox_a_rowsptr:=tmp_rows[new_dbox_a_net];
             new_dbox_a_row:=0;
             
             while(new_dbox_a_rowsptr[new_dbox_a_row]=0)
             {
                 new_dbox_a_row:=new_dbox_a_row+1
                 
             };
             new_dbox_a_min:=new_dbox_a_row;
             new_dbox_a_row:=numRows+1;
             
             while(new_dbox_a_rowsptr[new_dbox_a_row]=0)
             {
                 new_dbox_a_row:=new_dbox_a_row-1
                 
             };
             new_dbox_a_max:=new_dbox_a_row;
             new_dbox_a_row:=new_dbox_a_min;
             
             while(new_dbox_a_row<=new_dbox_a_max)
             {
                 if(new_dbox_a_rowsptr[new_dbox_a_row]=0) then 
                 {
                     new_dbox_a_f:=new_dbox_a_f+1
                     
                 }
                 else
                 {
                     new_dbox_a_m:=new_dbox_a_m+1
                 };
                 new_dbox_a_row:=new_dbox_a_row+1
                 
             };
             tmp_num_feeds[new_dbox_a_net]:=new_dbox_a_f;
             if(new_dbox_a_min<new_dbox_a_max) then 
             {
                 new_dbox_a_m:=new_dbox_a_m+2
                 
             }
             else
             {
                 if(new_dbox_a_min=new_dbox_a_max) then 
                 {
                     new_dbox_a_m:=new_dbox_a_m+1
                 }
                 else
                 {
                     new_dbox_a_m:=0
                 }
             };
             tmp_missing_rows[new_dbox_a_net]:=-new_dbox_a_m;
             delta_vert_cost:=delta_vert_cost+((tmp_num_feeds[new_dbox_a_net]-num_feeds[new_dbox_a_net])+(tmp_missing_rows[new_dbox_a_net]-missing_rows[new_dbox_a_net]))*2*rowHeight;
             new_dbox_a_termptr:=new_dbox_a_termptr->nextterm
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
      return<==1 and skip
     )
     }; 
  function term_newpos ( termbox* antrmptr,int xcenter,int ycenter,int newaor )
 {
     frame(term_newpos_termptr,term_newpos_ttermptr,term_newpos_dimptr,return) and ( 
     int return<==0 and skip;
     termbox* term_newpos_termptr and skip;
     netbox* term_newpos_ttermptr and skip;
     dimbox* term_newpos_dimptr and skip;
     term_newpos_termptr:=antrmptr;
     
     while(term_newpos_termptr)
     {
         term_newpos_ttermptr:=term_newpos_termptr->termptr;
         term_newpos_ttermptr->flag:=1;
         term_newpos_ttermptr->newx:=term_newpos_termptr->txpos[newaor/ 2]+xcenter;
         term_newpos_dimptr:=netarray[term_newpos_termptr->net];
         if(term_newpos_dimptr->dflag=0) then 
         {
             term_newpos_dimptr->dflag:=1;
             term_newpos_dimptr->new_total:=term_newpos_dimptr->old_total+term_newpos_ttermptr->newx-term_newpos_ttermptr->xpos
             
         }
         else
         {
             term_newpos_dimptr->new_total:=term_newpos_dimptr->new_total+term_newpos_ttermptr->newx-term_newpos_ttermptr->xpos
         };
         term_newpos_termptr:=term_newpos_termptr->nextterm
         
     };
      return<==1 and skip
     )
     }; 
  function term_newpos_a ( termbox* antrmptr,int xcenter,int ycenter,int newaor )
 {
     frame(term_newpos_a_termptr,term_newpos_a_ttermptr,term_newpos_a_dimptr,term_newpos_a_rowsptr1,term_newpos_a_rowsptr2,term_newpos_a_net,term_newpos_a_row,return) and ( 
     int return<==0 and skip;
     termbox* term_newpos_a_termptr and skip;
     netbox* term_newpos_a_ttermptr and skip;
     dimbox* term_newpos_a_dimptr and skip;
     char *term_newpos_a_rowsptr1,*term_newpos_a_rowsptr2 and skip;
     int term_newpos_a_net,term_newpos_a_row and skip;
     term_newpos_a_termptr:=antrmptr;
     
     while(term_newpos_a_termptr)
     {
         term_newpos_a_ttermptr:=term_newpos_a_termptr->termptr;
         term_newpos_a_ttermptr->flag:=1;
         term_newpos_a_ttermptr->newx:=term_newpos_a_termptr->txpos[newaor/ 2]+xcenter;
         term_newpos_a_net:=term_newpos_a_termptr->net;
         term_newpos_a_dimptr:=netarray[term_newpos_a_net];
         term_newpos_a_rowsptr2:=tmp_rows[term_newpos_a_net];
         if(term_newpos_a_dimptr->dflag=0) then 
         {
             term_newpos_a_dimptr->dflag:=1;
             term_newpos_a_rowsptr1:=rows_1[term_newpos_a_net];
             term_newpos_a_row:=0;
             
             while(term_newpos_a_row<=numRows+1)
             {
                 term_newpos_a_rowsptr2[term_newpos_a_row]:=term_newpos_a_rowsptr1[term_newpos_a_row];
                 term_newpos_a_row:=term_newpos_a_row+1
                 
             };
             term_newpos_a_rowsptr2[ablock]:=term_newpos_a_rowsptr2[ablock]-1;
             term_newpos_a_rowsptr2[bblock]:=term_newpos_a_rowsptr2[bblock]+1;
             term_newpos_a_dimptr->new_total:=term_newpos_a_dimptr->old_total+term_newpos_a_ttermptr->newx-term_newpos_a_ttermptr->xpos
             
         }
         else
         {
             term_newpos_a_rowsptr2[ablock]:=term_newpos_a_rowsptr2[ablock]-1;
             term_newpos_a_rowsptr2[bblock]:=term_newpos_a_rowsptr2[bblock]+1;
             term_newpos_a_dimptr->new_total:=term_newpos_a_dimptr->new_total+term_newpos_a_ttermptr->newx-term_newpos_a_ttermptr->xpos
         };
         term_newpos_a_termptr:=term_newpos_a_termptr->nextterm
         
     };
      return<==1 and skip
     )
     }; 
  function term_newpos_b ( termbox* antrmptr,int xcenter,int ycenter,int newaor )
 {
     frame(term_newpos_b_termptr,term_newpos_b_ttermptr,term_newpos_b_dimptr,term_newpos_b_rowsptr1,term_newpos_b_rowsptr2,term_newpos_b_net,term_newpos_b_row,return) and ( 
     int return<==0 and skip;
     termbox* term_newpos_b_termptr and skip;
     netbox* term_newpos_b_ttermptr and skip;
     dimbox* term_newpos_b_dimptr and skip;
     char *term_newpos_b_rowsptr1,*term_newpos_b_rowsptr2 and skip;
     int term_newpos_b_net,term_newpos_b_row and skip;
     term_newpos_b_termptr:=antrmptr;
     
     while(term_newpos_b_termptr)
     {
         term_newpos_b_ttermptr:=term_newpos_b_termptr->termptr;
         term_newpos_b_ttermptr->flag:=1;
         term_newpos_b_ttermptr->newx:=term_newpos_b_termptr->txpos[newaor/ 2]+xcenter;
         term_newpos_b_net:=term_newpos_b_termptr->net;
         term_newpos_b_dimptr:=netarray[term_newpos_b_net];
         term_newpos_b_rowsptr2:=tmp_rows[term_newpos_b_net];
         if(term_newpos_b_dimptr->dflag=0) then 
         {
             term_newpos_b_dimptr->dflag:=1;
             term_newpos_b_rowsptr1:=rows_1[term_newpos_b_net];
             term_newpos_b_row:=0;
             
             while(term_newpos_b_row<=numRows+1)
             {
                 term_newpos_b_rowsptr2[term_newpos_b_row]:=term_newpos_b_rowsptr1[term_newpos_b_row];
                 term_newpos_b_row:=term_newpos_b_row+1
                 
             };
             term_newpos_b_rowsptr2[bblock]:=term_newpos_b_rowsptr2[bblock]-1;
             term_newpos_b_rowsptr2[ablock]:=term_newpos_b_rowsptr2[ablock]+1;
             term_newpos_b_dimptr->new_total:=term_newpos_b_dimptr->old_total+term_newpos_b_ttermptr->newx-term_newpos_b_ttermptr->xpos
             
         }
         else
         {
             term_newpos_b_rowsptr2[bblock]:=term_newpos_b_rowsptr2[bblock]-1;
             term_newpos_b_rowsptr2[ablock]:=term_newpos_b_rowsptr2[ablock]+1;
             term_newpos_b_dimptr->new_total:=term_newpos_b_dimptr->new_total+term_newpos_b_ttermptr->newx-term_newpos_b_ttermptr->xpos
         };
         term_newpos_b_termptr:=term_newpos_b_termptr->nextterm
         
     };
      return<==1 and skip
     )
     }; 
  function dbox_pos ( termbox* antrmptr )
 {
     frame(dbox_pos_dimptr,dbox_pos_termptr,return) and ( 
     int return<==0 and skip;
     dimbox* dbox_pos_dimptr and skip;
     termbox* dbox_pos_termptr and skip;
     dbox_pos_termptr:=antrmptr;
     
     while(dbox_pos_termptr)
     {
         dbox_pos_dimptr:=netarray[dbox_pos_termptr->net];
         dbox_pos_dimptr->old_total:=dbox_pos_dimptr->new_total;
         dbox_pos_termptr->termptr->xpos:=dbox_pos_termptr->termptr->newx;
         dbox_pos_termptr:=dbox_pos_termptr->nextterm
         
     };
      return<==1 and skip
     )
     }; 
  function dbox_pos_2 ( termbox* antrmptr )
 {
     frame(dbox_pos_2_netptr,dbox_pos_2_dimptr,dbox_pos_2_termptr,dbox_pos_2_x,dbox_pos_2_net,dbox_pos_2_row,dbox_pos_2_rowsptr1,dbox_pos_2_rowsptr2,return) and ( 
     int return<==0 and skip;
     netbox* dbox_pos_2_netptr and skip;
     dimbox* dbox_pos_2_dimptr and skip;
     termbox* dbox_pos_2_termptr and skip;
     int dbox_pos_2_x,dbox_pos_2_net,dbox_pos_2_row and skip;
     char *dbox_pos_2_rowsptr1,*dbox_pos_2_rowsptr2 and skip;
     dbox_pos_2_termptr:=antrmptr;
     
     while(dbox_pos_2_termptr)
     {
         dbox_pos_2_net:=dbox_pos_2_termptr->net;
         dbox_pos_2_dimptr:=netarray[dbox_pos_2_net];
         dbox_pos_2_dimptr->old_total:=dbox_pos_2_dimptr->new_total;
         dbox_pos_2_termptr->termptr->xpos:=dbox_pos_2_termptr->termptr->newx;
         missing_rows[dbox_pos_2_net]:=tmp_missing_rows[dbox_pos_2_net];
         num_feeds[dbox_pos_2_net]:=tmp_num_feeds[dbox_pos_2_net];
         dbox_pos_2_rowsptr1:=rows_1[dbox_pos_2_net];
         dbox_pos_2_rowsptr2:=tmp_rows[dbox_pos_2_net];
         dbox_pos_2_row:=0;
         
         while(dbox_pos_2_row<=numRows+1)
         {
             dbox_pos_2_rowsptr1[dbox_pos_2_row]:=dbox_pos_2_rowsptr2[dbox_pos_2_row];
             dbox_pos_2_row:=dbox_pos_2_row+1
             
         };
         dbox_pos_2_termptr:=dbox_pos_2_termptr->nextterm
         
     };
      return<==1 and skip
     )
     }; 
  function initialize_rows (  )
 {
     frame(initialize_rows_termptr,initialize_rows_net,initialize_rows_row,initialize_rows_cell,initialize_rows_min,initialize_rows_max,initialize_rows_f,initialize_rows_m,initialize_rows_rowsptr,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     termbox* initialize_rows_termptr and skip;
     int initialize_rows_net,initialize_rows_row,initialize_rows_cell,initialize_rows_min,initialize_rows_max,initialize_rows_f,initialize_rows_m and skip;
     char *initialize_rows_rowsptr and skip;
     num_feeds:=(int *)safe_malloc((1+numnets)*sizeof(int),RValue);
     tmp_num_feeds:=(int *)safe_malloc((1+numnets)*sizeof(int),RValue);
     missing_rows:=(int *)safe_malloc((1+numnets)*sizeof(int),RValue);
     tmp_missing_rows:=(int *)safe_malloc((1+numnets)*sizeof(int),RValue);
     rows_1:=(char **)safe_malloc((1+numnets)*sizeof(char *),RValue);
     tmp_rows:=(char **)safe_malloc((1+numnets)*sizeof(char *),RValue);
     initialize_rows_net:=1;
     
     while(initialize_rows_net<=numnets)
     {
         rows_1[initialize_rows_net]:=(char *)safe_malloc((2+numRows)*sizeof(char),RValue);
         tmp_rows[initialize_rows_net]:=(char *)safe_malloc((2+numRows)*sizeof(char),RValue);
         initialize_rows_row:=0;
         
         while(initialize_rows_row<=numRows+1)
         {
             rows_1[initialize_rows_net,initialize_rows_row]:=0;
             tmp_rows[initialize_rows_net,initialize_rows_row]:=0;
             initialize_rows_row:=initialize_rows_row+1
             
         };
         missing_rows[initialize_rows_net]:=0;
         tmp_missing_rows[initialize_rows_net]:=0;
         num_feeds[initialize_rows_net]:=0;
         tmp_num_feeds[initialize_rows_net]:=0;
         initialize_rows_net:=initialize_rows_net+1
         
     };
     continue<==0 and skip;
     initialize_rows_cell:=1;
     
     while(initialize_rows_cell<=numcells+numterms)
     {
          continue<==0 and skip;
         if(initialize_rows_cell>numcells) then 
         {
             if(carray[initialize_rows_cell]->padside!=2 AND carray[initialize_rows_cell]->padside!=4 AND carray[initialize_rows_cell]->padside!=14 AND carray[initialize_rows_cell]->padside!=15) then 
             {
                 continue<==1 and skip;
                  initialize_rows_cell:=initialize_rows_cell+1}
                 else
                 {
                     if(carray[initialize_rows_cell]->padside=2 OR carray[initialize_rows_cell]->padside=14) then 
                     {
                         initialize_rows_row<==numRows+1 and carray[initialize_rows_cell]->cblock<==initialize_rows_row and skip
                     }
                     else
                     {
                         initialize_rows_row<==0 and carray[initialize_rows_cell]->cblock<==initialize_rows_row and skip
                     }
                 }
                 
             }
             else
             {
                 initialize_rows_row:=carray[initialize_rows_cell]->cblock
             };
             if(continue=0)  then 
             {
                 initialize_rows_termptr:=carray[initialize_rows_cell]->tileptr->termsptr;
                 
                 while(initialize_rows_termptr!=NULL)
                 {
                     rows_1[initialize_rows_termptr->net,initialize_rows_row]:=rows_1[initialize_rows_termptr->net,initialize_rows_row]+1;
                     initialize_rows_termptr:=initialize_rows_termptr->nextterm
                     
                 };
                 initialize_rows_cell:=initialize_rows_cell+1
             }
             else
             {
                 skip
             }
             
         };
         continue<==0 and skip;
         initialize_rows_net:=1;
         
         while(initialize_rows_net<=numnets)
         {
             initialize_rows_f:=0;
             initialize_rows_m:=0;
             initialize_rows_rowsptr:=rows_1[initialize_rows_net];
             initialize_rows_row:=0;
             
             while(initialize_rows_rowsptr[initialize_rows_row]=0)
             {
                 initialize_rows_row:=initialize_rows_row+1
                 
             };
             initialize_rows_min:=initialize_rows_row;
             initialize_rows_row:=numRows+1;
             
             while(initialize_rows_rowsptr[initialize_rows_row]=0)
             {
                 initialize_rows_row:=initialize_rows_row-1
                 
             };
             initialize_rows_max:=initialize_rows_row;
             initialize_rows_row:=initialize_rows_min;
             
             while(initialize_rows_row<=initialize_rows_max)
             {
                 if(initialize_rows_rowsptr[initialize_rows_row]=0) then 
                 {
                     initialize_rows_f:=initialize_rows_f+1
                     
                 }
                 else
                 {
                     initialize_rows_m:=initialize_rows_m+1
                 };
                 initialize_rows_row:=initialize_rows_row+1
                 
             };
             num_feeds[initialize_rows_net]:=initialize_rows_f;
             if(initialize_rows_min<initialize_rows_max) then 
             {
                 initialize_rows_m:=initialize_rows_m+2
                 
             }
             else
             {
                 if(initialize_rows_min=initialize_rows_max) then 
                 {
                     initialize_rows_m:=initialize_rows_m+1
                 }
                 else
                 {
                     initialize_rows_m:=0
                 }
             };
             missing_rows[initialize_rows_net]:=-initialize_rows_m;
             initialize_rows_net:=initialize_rows_net+1
             
         };
          return<==1 and skip
         )
         }; 
  function check_row_values (  )
 {
     frame(check_row_values_termptr,check_row_values_net,check_row_values_row,check_row_values_cell,check_row_values_min,check_row_values_max,check_row_values_f,check_row_values_m,check_row_values_fds,check_row_values_mrs,check_row_values_rowsptr,check_row_values_check_rows,check_row_values_check_feeds,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     termbox* check_row_values_termptr and skip;
     int check_row_values_net,check_row_values_row,check_row_values_cell,check_row_values_min,check_row_values_max,check_row_values_f,check_row_values_m,check_row_values_fds,check_row_values_mrs and skip;
     char *check_row_values_rowsptr,**check_row_values_check_rows and skip;
     int *check_row_values_check_feeds and skip;
     check_row_values_check_feeds:=(int *)safe_malloc((1+numnets)*sizeof(int),RValue);
     check_row_values_check_rows:=(char **)safe_malloc((1+numnets)*sizeof(char *),RValue);
     check_row_values_net:=1;
     
     while(check_row_values_net<=numnets)
     {
         check_row_values_check_rows[check_row_values_net]:=(char *)safe_malloc((2+numRows)*sizeof(char),RValue);
         check_row_values_row:=0;
         
         while(check_row_values_row<=numRows+1)
         {
             check_row_values_check_rows[check_row_values_net,check_row_values_row]:=0;
             check_row_values_row:=check_row_values_row+1
             
         };
         check_row_values_check_feeds[check_row_values_net]:=0;
         check_row_values_net:=check_row_values_net+1
         
     };
     continue<==0 and skip;
     check_row_values_cell:=1;
     
     while(check_row_values_cell<=numcells+numterms)
     {
          continue<==0 and skip;
         if(check_row_values_cell>numcells) then 
         {
             if(carray[check_row_values_cell]->padside!=2 AND carray[check_row_values_cell]->padside!=4 AND carray[check_row_values_cell]->padside!=14 AND carray[check_row_values_cell]->padside!=15) then 
             {
                 continue<==1 and skip;
                  check_row_values_cell:=check_row_values_cell+1}
                 else
                 {
                     if(carray[check_row_values_cell]->padside=2 OR carray[check_row_values_cell]->padside=14) then 
                     {
                         check_row_values_row<==numRows+1 and carray[check_row_values_cell]->cblock<==check_row_values_row and skip
                     }
                     else
                     {
                         check_row_values_row<==0 and carray[check_row_values_cell]->cblock<==check_row_values_row and skip
                     }
                 }
                 
             }
             else
             {
                 check_row_values_row:=carray[check_row_values_cell]->cblock
             };
             if(continue=0)  then 
             {
                 check_row_values_termptr:=carray[check_row_values_cell]->tileptr->termsptr;
                 
                 while(check_row_values_termptr!=NULL)
                 {
                     check_row_values_check_rows[check_row_values_termptr->net,check_row_values_row]:=check_row_values_check_rows[check_row_values_termptr->net,check_row_values_row]+1;
                     check_row_values_termptr:=check_row_values_termptr->nextterm
                     
                 };
                 check_row_values_cell:=check_row_values_cell+1
             }
             else
             {
                 skip
             }
             
         };
         continue<==0 and skip;
         check_row_values_fds:=0;
         check_row_values_mrs:=0;
         check_row_values_net:=1;
         
         while(check_row_values_net<=numnets)
         {
             check_row_values_f:=0;
             check_row_values_m:=0;
             check_row_values_rowsptr:=check_row_values_check_rows[check_row_values_net];
             check_row_values_row:=0;
             
             while(check_row_values_rowsptr[check_row_values_row]=0)
             {
                 check_row_values_row:=check_row_values_row+1
                 
             };
             check_row_values_min:=check_row_values_row;
             check_row_values_row:=numRows+1;
             
             while(check_row_values_rowsptr[check_row_values_row]=0)
             {
                 check_row_values_row:=check_row_values_row-1
                 
             };
             check_row_values_max:=check_row_values_row;
             check_row_values_row:=check_row_values_min;
             
             while(check_row_values_row<=check_row_values_max)
             {
                 if(check_row_values_rowsptr[check_row_values_row]=0) then 
                 {
                     check_row_values_f:=check_row_values_f+1
                     
                 }
                 else
                 {
                     check_row_values_m:=check_row_values_m+1
                 };
                 check_row_values_row:=check_row_values_row+1
                 
             };
             check_row_values_fds:=check_row_values_fds+check_row_values_f;
             if(check_row_values_min<check_row_values_max) then 
             {
                 check_row_values_m:=check_row_values_m+2
                 
             }
             else
             {
                 if(check_row_values_min=check_row_values_max) then 
                 {
                     check_row_values_m:=check_row_values_m+1
                 }
                 else
                 {
                     check_row_values_m:=0
                 }
             };
             check_row_values_mrs:=check_row_values_mrs-check_row_values_m;
             check_row_values_net:=check_row_values_net+1
             
         };
         safe_free(check_row_values_check_feeds,RValue);
         check_row_values_net:=1;
         
         while(check_row_values_net<=numnets)
         {
             safe_free(check_row_values_check_rows[check_row_values_net],RValue);
             check_row_values_net:=check_row_values_net+1
             
         };
         safe_free(check_row_values_check_rows,RValue);
         fprintf(fpo,"FEEDS:%d     MRs:%d\n",check_row_values_fds,check_row_values_mrs) and skip;
         output ("FEEDS:",check_row_values_fds,"     MRs:",check_row_values_mrs,"\n") and skip;
         fflush(stdout) and skip;
         fflush(fpo) and skip;
          return<==1 and skip
         )
         }; 
  function vert_statistics (  )
 {
     frame(vert_statistics_net,return) and ( 
     int return<==0 and skip;
     int vert_statistics_net and skip;
     tot_missing_rows:=0;
     tot_num_feeds:=0;
     vert_statistics_net:=1;
     
     while(vert_statistics_net<=numnets)
     {
         tot_missing_rows:=tot_missing_rows+missing_rows[vert_statistics_net];
         tot_num_feeds:=tot_num_feeds+num_feeds[vert_statistics_net];
         vert_statistics_net:=vert_statistics_net+1
         
     };
      return<==1 and skip
     )
     }; 
  function finalwire (  )
 {
     frame(finalwire_dimptr,finalwire_netptr,finalwire_x,finalwire_y,finalwire_net,finalwire_cost) and ( 
     dimbox* finalwire_dimptr and skip;
     netbox* finalwire_netptr and skip;
     int finalwire_x,finalwire_y,finalwire_net,finalwire_cost<==0 and skip;
     fwirex:=0;
     fwirey:=0;
     finalwire_net:=1;
     
     while(finalwire_net<=numnets)
     {
         finalwire_dimptr:=netarray[finalwire_net];
         finalwire_netptr:=finalwire_dimptr->netptr ;
         if((finalwire_netptr)!=NULL) then 
         {
             finalwire_dimptr->xmax<==finalwire_netptr->xpos and finalwire_dimptr->xmin<==finalwire_dimptr->xmax and skip;
             finalwire_dimptr->ymax<==finalwire_netptr->ypos and finalwire_dimptr->ymin<==finalwire_dimptr->ymax and skip;
             finalwire_netptr:=finalwire_netptr->nterm
             
         }
         else 
         {
              skip 
         };
         while(finalwire_netptr!=NULL)
         {
             finalwire_x:=finalwire_netptr->xpos;
             finalwire_y:=finalwire_netptr->ypos;
             if(finalwire_x<finalwire_dimptr->xmin) then 
             {
                 finalwire_dimptr->xmin:=finalwire_x
                 
             }
             else
             {
                 if(finalwire_x>finalwire_dimptr->xmax) then 
                 {
                     finalwire_dimptr->xmax:=finalwire_x
                     
                 }
                 else 
                 {
                      skip 
                 }
             };
             if(finalwire_y<finalwire_dimptr->ymin) then 
             {
                 finalwire_dimptr->ymin:=finalwire_y
                 
             }
             else
             {
                 if(finalwire_y>finalwire_dimptr->ymax) then 
                 {
                     finalwire_dimptr->ymax:=finalwire_y
                     
                 }
                 else 
                 {
                      skip 
                 }
             };
             finalwire_netptr:=finalwire_netptr->nterm
             
         };
         finalwire_cost:=finalwire_cost+((int)(finalwire_dimptr->Hweight*(float)(finalwire_dimptr->xmax-finalwire_dimptr->xmin)))+((int)(finalwire_dimptr->Vweight*(float)(finalwire_dimptr->ymax-finalwire_dimptr->ymin)));
         fwirex:=fwirex+finalwire_dimptr->xmax-finalwire_dimptr->xmin;
         fwirey:=fwirey+finalwire_dimptr->ymax-finalwire_dimptr->ymin;
         finalwire_net:=finalwire_net+1
         
     };
     fwire:=finalwire_cost;
     fprintf(fpo,"\nInitial Wiring Cost: %d   Final Wiring Cost: %d\n",iwire,fwire) and skip;
     if(iwire!=0) then 
     {
         fprintf(fpo,"############## Percent Wire Cost Reduction: %d\n\n",100-(int)((float)fwire/ (float)iwire*100.0)) and skip
         
     }
     else 
     {
          skip 
     };
     fprintf(fpo,"\nInitial Wire Length: %d   Final Wire Length: %d\n",(iwirex+iwirey),(fwirex+fwirey)) and skip;
     if(iwirex+iwirey!=0) then 
     {
         fprintf(fpo,"************** Percent Wire Length Reduction: %d\n\n",100-(int)((float)(fwirex+fwirey)/ (float)(iwirex+iwirey)*100.0)) and skip
         
     }
     else 
     {
          skip 
     };
     fprintf(fpo,"\nInitial Horiz. Wire: %d   Final Horiz. Wire: %d\n",iwirex,fwirex) and skip;
     if(iwirex!=0) then 
     {
         fprintf(fpo,"$$$$$$$$$$$ Percent H-Wire Length Reduction: %d\n\n",100-(int)((float)fwirex/ (float)iwirex*100.0)) and skip
         
     }
     else 
     {
          skip 
     };
     fprintf(fpo,"\nInitial Vert. Wire: %d   Final Vert. Wire: %d\n",iwirey,fwirey) and skip;
     if(iwirey!=0) then 
     {
         fprintf(fpo,"@@@@@@@@@@@ Percent V-Wire Length Reduction: %d\n\n",100-(int)((float)fwirey/ (float)iwirey*100.0)) and skip
         
     }
     else 
     {
          skip 
     }
     )
     }; 
      int minxspan and skip;
     float mean_width and skip;
     int offset_limit and skip;
     int blkleft,blkrite and skip;
 function findcost ( int RValue )
 {
     frame(findcost_fp,findcost_tile,findcost_tileptr1,findcost_cellptr1,findcost_ptr,findcost_dimptr,findcost_netptr,findcost_termptr,findcost_term,findcost_bptr,findcost_filename,findcost_left,findcost_right,findcost_corient,findcost_bin,findcost_LoBin,findcost_HiBin,findcost_block,findcost_cell,findcost_net,findcost_blk,findcost_startx,findcost_endx,findcost_x,findcost_y,findcost_cost,findcost_temp,findcost_n,findcost_k,findcost_cbin,findcost_net_pin_num,findcost_adjust_left,findcost_deviation,findcost_factor,return) and ( 
     int return<==0 and skip;
     FILE *findcost_fp and skip;
     tilebox* findcost_tile,*findcost_tileptr1 and skip;
     cellbox* findcost_cellptr1,*findcost_ptr and skip;
     dimbox* findcost_dimptr and skip;
     netbox* findcost_netptr,*findcost_termptr and skip;
     termbox* findcost_term and skip;
     binbox* findcost_bptr and skip;
     char findcost_filename[64] and skip;
     int findcost_left,findcost_right,findcost_corient and skip;
     int findcost_bin,findcost_LoBin,findcost_HiBin and skip;
     int findcost_block,findcost_cell,findcost_net,findcost_blk and skip;
     int findcost_startx,findcost_endx and skip;
     int findcost_x,findcost_y,findcost_cost<==0 and skip;
     int findcost_temp,findcost_n,findcost_k,findcost_cbin and skip;
     int findcost_net_pin_num[11],*findcost_adjust_left and skip;
     float findcost_deviation,findcost_factor and skip;
     blkleft:=32000;
     blkrite:=0;
     findcost_adjust_left:=(int *)safe_malloc((numblock+1)*sizeof(int),RValue);
     findcost_block:=1;
     
     while(findcost_block<=numblock)
     {
         if(barray[findcost_block]->bxcenter+barray[findcost_block]->bleft<blkleft) then 
         {
             blkleft:=barray[findcost_block]->bxcenter+barray[findcost_block]->bleft
             
         }
         else 
         {
              skip 
         };
         if(barray[findcost_block]->bxcenter+barray[findcost_block]->bright>blkrite) then 
         {
             blkrite:=barray[findcost_block]->bxcenter+barray[findcost_block]->bright
             
         }
         else 
         {
              skip 
         };
         findcost_adjust_left[findcost_block]:=32000;
         findcost_block:=findcost_block+1
         
     };
     binOffst:=blkleft;
     max_blklength:=blkrite-blkleft;
     findcost_deviation:=0;
     findcost_temp:=0;
     findcost_factor:=0.0;
     findcost_cell:=1;
     
     while(findcost_cell<=numcells)
     {
         findcost_temp:=findcost_temp+carray[findcost_cell]->clength;
         findcost_cell:=findcost_cell+1
         
     };
     mean_width:=findcost_temp/ numcells;
     findcost_cell:=1;
     
     while(findcost_cell<=numcells)
     {
         findcost_deviation:=findcost_deviation+(carray[findcost_cell]->clength-mean_width)*(carray[findcost_cell]->clength-mean_width);
         findcost_cell:=findcost_cell+1
         
     };
     findcost_deviation:=sqrt(findcost_deviation/ numcells);
     binWidth:=(int)(findcost_factor*findcost_deviation+mean_width)+1;
     numBins:=(int)((blkrite-binOffst)/ binWidth);
     if((blkrite-binOffst)>(numBins*binWidth)) then 
     {
         numBins:=numBins+1
         
     }
     else 
     {
          skip 
     };
     fprintf(fpo,"numBins automatically set to:%d\n",numBins) and skip;
     fprintf(fpo,"binWidth = average_cell_width + %g sigma",findcost_factor) and skip;
     fprintf(fpo,"= %d\n",binWidth) and skip;
     fprintf(fpo,"average_cell_width is:%g\n",mean_width) and skip;
     fprintf(fpo,"standard deviation of cell length is:%g\n",findcost_deviation) and skip;
     minxspan:=(int)(mean_width+3.0*findcost_deviation);
     offset_limit:=(int)(0.05*mean_width*(float)numcells/ (float)numblock);
     sprintf(findcost_filename,"%s.res",cktName,RValue) and skip;
     findcost_fp:=twopen(findcost_filename,"r",0,RValue);
     if(!findcost_fp) then 
     {
         if(resume_run=1) then 
         {
             fprintf(fpo,"Could not use resume file: %s  ",findcost_filename) and skip;
             fprintf(fpo,"since it could not be found\n") and skip
         }
         else
         {
             fprintf(fpo,"TimberWolfSC starting from the beginning\n") and skip
         }
         
     }
     else
     {
         if(resume_run=0) then 
         {
             fprintf(fpo,"Use of resume file: %s was not requested\n",findcost_filename) and skip
         }
         else
         {
             fprintf(fpo,"Resuming TimberWolf from previous saved ") and skip;
             fprintf(fpo,"placement in %s\n",findcost_filename) and skip;
             TW_oldin(findcost_fp,RValue);
             twclose(findcost_fp)
         }
     };
     sortpin(RValue);
     findcost_cell:=1;
     
     while(findcost_cell<=numcells+numterms)
     {
         findcost_ptr:=carray[findcost_cell];
         findcost_corient:=findcost_ptr->corient;
         findcost_block:=findcost_ptr->cblock;
         findcost_tile:=findcost_ptr->tileptr;
         if(findcost_cell<=numcells) then 
         {
             findcost_ptr->cycenter:=barray[findcost_block]->bycenter;
             if(findcost_adjust_left[findcost_block]>findcost_ptr->cxcenter+findcost_tile->left) then 
             {
                 findcost_adjust_left[findcost_block]:=findcost_ptr->cxcenter+findcost_tile->left
                 
             }
             else 
             {
                  skip 
             };
             findcost_term:=findcost_tile->termsptr;
             
             while(findcost_term!=NULL)
             {
                 findcost_termptr:=tearray[findcost_term->cellterm];
                 findcost_termptr->xpos:=findcost_term->txpos[findcost_corient/ 2]+findcost_ptr->cxcenter;
                 findcost_termptr->ypos:=findcost_term->typos[findcost_corient % 2]+findcost_ptr->cycenter;
                 findcost_term:=findcost_term->nextterm
                 
             }
             
         }
         else
         {
             findcost_term:=findcost_tile->termsptr;
             
             while(findcost_term!=NULL)
             {
                 findcost_termptr:=tearray[findcost_term->cellterm];
                 findcost_termptr->xpos:=findcost_term->txpos[1]+findcost_ptr->cxcenter;
                 findcost_termptr->ypos:=findcost_term->typos[1]+findcost_ptr->cycenter;
                 findcost_term:=findcost_term->nextterm
                 
             }
         };
         findcost_cell:=findcost_cell+1
         
     };
     iwirex:=0;
     iwirey:=0;
     findcost_net:=1;
     
     while(findcost_net<=numnets)
     {
         findcost_dimptr:=netarray[findcost_net];
         findcost_netptr:=findcost_dimptr->netptr ;
         if((findcost_netptr)!=NULL) then 
         {
             findcost_dimptr->xmax<==findcost_netptr->xpos and findcost_dimptr->xmin<==findcost_dimptr->xmax and skip;
             findcost_dimptr->ymax<==findcost_netptr->ypos and findcost_dimptr->ymin<==findcost_dimptr->ymax and skip
             
         }
         else 
         {
              skip 
         };
         findcost_netptr:=findcost_netptr->nterm;
         
         while(findcost_netptr!=NULL)
         {
             findcost_x:=findcost_netptr->xpos;
             findcost_y:=findcost_netptr->ypos;
             if(findcost_x<findcost_dimptr->xmin) then 
             {
                 findcost_dimptr->xmin:=findcost_x
                 
             }
             else
             {
                 if(findcost_x>findcost_dimptr->xmax) then 
                 {
                     findcost_dimptr->xmax:=findcost_x
                     
                 }
                 else 
                 {
                      skip 
                 }
             };
             if(findcost_y<findcost_dimptr->ymin) then 
             {
                 findcost_dimptr->ymin:=findcost_y
                 
             }
             else
             {
                 if(findcost_y>findcost_dimptr->ymax) then 
                 {
                     findcost_dimptr->ymax:=findcost_y
                     
                 }
                 else 
                 {
                      skip 
                 }
             };
             findcost_netptr:=findcost_netptr->nterm
             
         };
         findcost_cost:=findcost_cost+((int)(findcost_dimptr->Hweight*(float)(findcost_dimptr->xmax-findcost_dimptr->xmin)))+((int)(findcost_dimptr->Vweight*(float)(findcost_dimptr->ymax-findcost_dimptr->ymin)));
         iwirex:=iwirex+findcost_dimptr->xmax-findcost_dimptr->xmin;
         iwirey:=iwirey+findcost_dimptr->ymax-findcost_dimptr->ymin;
         findcost_net:=findcost_net+1
         
     };
     fprintf(fpo,"\n\n\nTHIS IS THE ROUTE COST OF THE ") and skip;
     fprintf(fpo,"ORIGINAL PLACEMENT: %d\n",findcost_cost) and skip;
     if(resume_run=0) then 
     {
         findcost_cell:=1;
         
         while(findcost_cell<=numcells)
         {
             findcost_ptr:=carray[findcost_cell];
             findcost_corient:=findcost_ptr->corient;
             findcost_block:=findcost_ptr->cblock;
             findcost_ptr->cxcenter:=findcost_ptr->cxcenter-(findcost_adjust_left[findcost_block]-barray[findcost_block]->bxcenter-barray[findcost_block]->bleft);
             findcost_term:=findcost_ptr->tileptr->termsptr;
             
             while(findcost_term!=NULL)
             {
                 findcost_termptr:=tearray[findcost_term->cellterm];
                 findcost_termptr->xpos:=findcost_term->txpos[findcost_corient/ 2]+findcost_ptr->cxcenter;
                 findcost_termptr->ypos:=findcost_term->typos[findcost_corient % 2]+findcost_ptr->cycenter;
                 findcost_term:=findcost_term->nextterm
                 
             };
             findcost_cell:=findcost_cell+1
             
         }
         
     }
     else 
     {
          skip 
     };
     findcost_cost:=0;
     iwirex:=0;
     iwirey:=0;
     findcost_net:=1;
     
     while(findcost_net<=numnets)
     {
         findcost_dimptr:=netarray[findcost_net];
         findcost_netptr:=findcost_dimptr->netptr ;
         if((findcost_netptr)!=NULL) then 
         {
             findcost_dimptr->xmax<==findcost_netptr->xpos and findcost_dimptr->xmin<==findcost_dimptr->xmax and skip;
             findcost_dimptr->ymax<==findcost_netptr->ypos and findcost_dimptr->ymin<==findcost_dimptr->ymax and skip;
             findcost_dimptr->Rnum<==1 and findcost_dimptr->Lnum<==findcost_dimptr->Rnum and skip;
             findcost_dimptr->Tnum<==1 and findcost_dimptr->Bnum<==findcost_dimptr->Tnum and skip;
             findcost_netptr:=findcost_netptr->nterm
             
         }
         else 
         {
              skip 
         };
         findcost_n:=1;
         while(findcost_netptr!=NULL)
         {
             findcost_x:=findcost_netptr->xpos;
             findcost_y:=findcost_netptr->ypos;
             if(findcost_x<findcost_dimptr->xmin) then 
             {
                 findcost_dimptr->xmin:=findcost_x;
                 findcost_dimptr->Lnum:=1
                 
             }
             else
             {
                 if(findcost_x=findcost_dimptr->xmin) then 
                 {
                     findcost_dimptr->Lnum:=findcost_dimptr->Lnum+1;
                     if(findcost_x=findcost_dimptr->xmax) then 
                     {
                         findcost_dimptr->Rnum:=findcost_dimptr->Rnum+1
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     if(findcost_x>findcost_dimptr->xmax) then 
                     {
                         findcost_dimptr->xmax:=findcost_x;
                         findcost_dimptr->Rnum:=1
                     }
                     else
                     {
                         if(findcost_x=findcost_dimptr->xmax) then 
                         {
                             findcost_dimptr->Rnum:=findcost_dimptr->Rnum+1
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                 }
             };
             if(findcost_y<findcost_dimptr->ymin) then 
             {
                 findcost_dimptr->ymin:=findcost_y;
                 findcost_dimptr->Bnum:=1
                 
             }
             else
             {
                 if(findcost_y=findcost_dimptr->ymin) then 
                 {
                     findcost_dimptr->Bnum:=findcost_dimptr->Bnum+1;
                     if(findcost_y=findcost_dimptr->ymax) then 
                     {
                         findcost_dimptr->Tnum:=findcost_dimptr->Tnum+1
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     if(findcost_y>findcost_dimptr->ymax) then 
                     {
                         findcost_dimptr->ymax:=findcost_y;
                         findcost_dimptr->Tnum:=1
                     }
                     else
                     {
                         if(findcost_y=findcost_dimptr->ymax) then 
                         {
                             findcost_dimptr->Tnum:=findcost_dimptr->Tnum+1
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                 }
             };
             findcost_n:=findcost_n+1;
             findcost_netptr:=findcost_netptr->nterm
             
         };
         findcost_dimptr->numpins:=findcost_n;
         findcost_cost:=findcost_cost+((int)(findcost_dimptr->Hweight*(float)(findcost_dimptr->xmax-findcost_dimptr->xmin)))+((int)(findcost_dimptr->Vweight*(float)(findcost_dimptr->ymax-findcost_dimptr->ymin)));
         iwirex:=iwirex+findcost_dimptr->xmax-findcost_dimptr->xmin;
         iwirey:=iwirey+findcost_dimptr->ymax-findcost_dimptr->ymin;
         findcost_net:=findcost_net+1
         
     };
     iwire:=findcost_cost;
     findcost_n:=1;
     
     while(findcost_n<=10)
     {
         findcost_net_pin_num[findcost_n]:=0;
         findcost_n:=findcost_n+1
         
     };
     findcost_net:=1;
     
     while(findcost_net<=numnets)
     {
         findcost_dimptr:=netarray[findcost_net];
         if(findcost_dimptr->numpins>=10) then 
         {
             findcost_net_pin_num[10]:=findcost_net_pin_num[10]+1
             
         }
         else
         {
             findcost_net_pin_num[findcost_dimptr->numpins]:=findcost_net_pin_num[findcost_dimptr->numpins]+1
         };
         findcost_net:=findcost_net+1
         
     };
     findcost_n:=1;
     
     while(findcost_n<=9)
     {
         fprintf(fpo,"The number of nets with %d pin is %d\n",findcost_n,findcost_net_pin_num[findcost_n]) and skip;
         findcost_n:=findcost_n+1
         
     };
     fprintf(fpo,"The number of nets with 10 pin or more is %d\n",findcost_net_pin_num[10]) and skip;
     binpenal:=0;
     rowpenal:=0;
     penalty:=0;
     binptr:=safe_malloc((numblock+1)*4,RValue);
     findcost_block:=1;
     
     while(findcost_block<=numblock)
     {
         binptr[findcost_block]:=(binbox* *)safe_malloc((numBins+1)*sizeof(binbox*),RValue);
         findcost_left:=barray[findcost_block]->bleft+barray[findcost_block]->bxcenter;
         findcost_right:=barray[findcost_block]->bleft+barray[findcost_block]->bxcenter+barray[findcost_block]->desire;
         findcost_LoBin:=SetBin(findcost_left,RValue);
         findcost_HiBin:=SetBin(findcost_right,RValue);
         findcost_bin:=0;
         
         while(findcost_bin<=numBins)
         {
             binptr[findcost_block,findcost_bin]:=(binbox *)safe_malloc(sizeof(binbox),RValue);
             binptr[findcost_block,findcost_bin]->cell:=(int *)safe_malloc(10*sizeof(int),RValue);
             findcost_bptr:=binptr[findcost_block,findcost_bin];
             findcost_bptr->cell[0]:=0;
             findcost_bptr->right:=binOffst+findcost_bin*binWidth;
             findcost_bptr->left:=findcost_bptr->right-binWidth;
             if(findcost_bin=findcost_LoBin) then 
             {
                 findcost_bptr->penalty:=findcost_left-findcost_bptr->right
                 
             }
             else
             {
                 if(findcost_bin=findcost_HiBin) then 
                 {
                     findcost_bptr->penalty:=findcost_bptr->left-findcost_right
                 }
                 else
                 {
                     if(findcost_bin>findcost_HiBin OR findcost_bin<findcost_LoBin) then 
                     {
                         findcost_bptr->penalty:=0
                     }
                     else
                     {
                         findcost_bptr->penalty:=-binWidth
                     }
                 }
             };
             findcost_bin:=findcost_bin+1
             
         };
         findcost_block:=findcost_block+1
         
     };
     findcost_cell:=1;
     
     while(findcost_cell<=numcells)
     {
         findcost_cellptr1:=carray[findcost_cell];
         findcost_tileptr1:=findcost_cellptr1->tileptr;
         findcost_block:=findcost_cellptr1->cblock;
         findcost_startx:=findcost_cellptr1->cxcenter+findcost_tileptr1->left;
         findcost_endx:=findcost_cellptr1->cxcenter+findcost_tileptr1->right;
         barray[findcost_block]->oldsize:=barray[findcost_block]->oldsize+findcost_endx-findcost_startx;
         findcost_cbin:=SetBin(findcost_cellptr1->cxcenter,RValue);
         findcost_LoBin:=SetBin(findcost_startx,RValue);
         findcost_HiBin:=SetBin(findcost_endx,RValue);
         findcost_k:=((binptr[findcost_block,findcost_cbin]->cell[0])+1);
         (binptr[findcost_block,findcost_cbin]->cell[0]):=(binptr[findcost_block,findcost_cbin]->cell[0])+1;
         if(findcost_k % 10=0) then 
         {
             binptr[findcost_block,findcost_cbin]->cell:=(int *)safe_realloc(binptr[findcost_block,findcost_cbin]->cell,(findcost_k+10)*sizeof(int),RValue)
             
         }
         else 
         {
              skip 
         };
         binptr[findcost_block,findcost_cbin]->cell[findcost_k]:=findcost_cell;
         if(findcost_LoBin=findcost_HiBin) then 
         {
             binptr[findcost_block,findcost_LoBin]->penalty:=binptr[findcost_block,findcost_LoBin]->penalty+(findcost_endx-findcost_startx)
             
         }
         else
         {
             findcost_bptr:=binptr[findcost_block,findcost_LoBin];
             findcost_bptr->penalty:=findcost_bptr->penalty+(findcost_bptr->right-findcost_startx);
             findcost_bptr:=binptr[findcost_block,findcost_HiBin];
             findcost_bptr->penalty:=findcost_bptr->penalty+(findcost_endx-findcost_bptr->left);
             if(findcost_LoBin+1<findcost_HiBin) then 
             {
                 findcost_bin:=findcost_LoBin+1;
                 
                 while(findcost_bin<=findcost_HiBin-1)
                 {
                     binptr[findcost_block,findcost_bin]->penalty:=binptr[findcost_block,findcost_bin]->penalty+binWidth;
                     findcost_bin:=findcost_bin+1
                     
                 }
                 
             }
             else 
             {
                  skip 
             }
         };
         findcost_cell:=findcost_cell+1
         
     };
     findcost_block:=1;
     
     while(findcost_block<=numblock)
     {
         findcost_bin:=0;
         
         while(findcost_bin<=numBins)
         {
             binpenal:=binpenal+extern ABS(binptr[findcost_block,findcost_bin]->penalty,RValue);
             findcost_bin:=findcost_bin+1
             
         };
         findcost_block:=findcost_block+1
         
     };
     findcost_blk:=1;
     
     while(findcost_blk<=numblock)
     {
         rowpenal:=rowpenal+extern ABS(barray[findcost_blk]->oldsize-barray[findcost_blk]->desire,RValue);
         findcost_blk:=findcost_blk+1
         
     };
     penalty:=(int)(binpenCon*(float)binpenal+roLenCon*(float)rowpenal);
     return<==1 and RValue:=findcost_cost;
     skip
     )
     }; 
  function findcostf ( int RValue )
 {
     frame(findcostf_tile,findcostf_tileptr1,findcostf_cellptr1,findcostf_ptr,findcostf_dimptr,findcostf_netptr,findcostf_termptr,findcostf_term,findcostf_bptr,findcostf_left,findcostf_right,findcostf_corient,findcostf_bin,findcostf_LoBin,findcostf_HiBin,findcostf_block,findcostf_cell,findcostf_net,findcostf_blk,findcostf_startx,findcostf_endx,findcostf_x,findcostf_y,findcostf_cost,findcostf_n,findcostf_k,findcostf_cbin,findcostf_old_numBins,return) and ( 
     int return<==0 and skip;
     tilebox* findcostf_tile,*findcostf_tileptr1 and skip;
     cellbox* findcostf_cellptr1,*findcostf_ptr and skip;
     dimbox* findcostf_dimptr and skip;
     netbox* findcostf_netptr,*findcostf_termptr and skip;
     termbox* findcostf_term and skip;
     binbox* findcostf_bptr and skip;
     int findcostf_left,findcostf_right,findcostf_corient and skip;
     int findcostf_bin,findcostf_LoBin,findcostf_HiBin and skip;
     int findcostf_block,findcostf_cell,findcostf_net,findcostf_blk and skip;
     int findcostf_startx,findcostf_endx and skip;
     int findcostf_x,findcostf_y,findcostf_cost<==0 and skip;
     int findcostf_n,findcostf_k,findcostf_cbin and skip;
     int findcostf_old_numBins and skip;
     blkleft:=32000;
     blkrite:=0;
     findcostf_block:=1;
     
     while(findcostf_block<=numblock)
     {
         if(barray[findcostf_block]->bxcenter+barray[findcostf_block]->bleft<blkleft) then 
         {
             blkleft:=barray[findcostf_block]->bxcenter+barray[findcostf_block]->bleft
             
         }
         else 
         {
              skip 
         };
         if(barray[findcostf_block]->bxcenter+barray[findcostf_block]->bright>blkrite) then 
         {
             blkrite:=barray[findcostf_block]->bxcenter+barray[findcostf_block]->bright
             
         }
         else 
         {
              skip 
         };
         findcostf_block:=findcostf_block+1
         
     };
     binOffst:=blkleft;
     max_blklength:=blkrite-blkleft;
     findcostf_old_numBins:=numBins;
     numBins:=(int)((blkrite-binOffst)/ binWidth);
     if((blkrite-binOffst)>(numBins*binWidth)) then 
     {
         numBins:=numBins+1
         
     }
     else 
     {
          skip 
     };
     sortpin(RValue);
     findcostf_cell:=1;
     
     while(findcostf_cell<=numcells+numterms)
     {
         findcostf_ptr:=carray[findcostf_cell];
         findcostf_corient:=findcostf_ptr->corient;
         findcostf_block:=findcostf_ptr->cblock;
         findcostf_tile:=findcostf_ptr->tileptr;
         if(findcostf_cell<=numcells) then 
         {
             findcostf_ptr->cycenter:=barray[findcostf_block]->bycenter;
             findcostf_term:=findcostf_tile->termsptr;
             
             while(findcostf_term!=NULL)
             {
                 findcostf_termptr:=tearray[findcostf_term->cellterm];
                 findcostf_termptr->xpos:=findcostf_term->txpos[findcostf_corient/ 2]+findcostf_ptr->cxcenter;
                 findcostf_termptr->ypos:=findcostf_term->typos[findcostf_corient % 2]+findcostf_ptr->cycenter;
                 findcostf_term:=findcostf_term->nextterm
                 
             }
             
         }
         else
         {
             findcostf_term:=findcostf_tile->termsptr;
             
             while(findcostf_term!=NULL)
             {
                 findcostf_termptr:=tearray[findcostf_term->cellterm];
                 findcostf_termptr->xpos:=findcostf_term->txpos[1]+findcostf_ptr->cxcenter;
                 findcostf_termptr->ypos:=findcostf_term->typos[1]+findcostf_ptr->cycenter;
                 findcostf_term:=findcostf_term->nextterm
                 
             }
         };
         findcostf_cell:=findcostf_cell+1
         
     };
     findcostf_cost:=0;
     findcostf_net:=1;
     
     while(findcostf_net<=numnets)
     {
         findcostf_dimptr:=netarray[findcostf_net];
         findcostf_netptr:=findcostf_dimptr->netptr ;
         if((findcostf_netptr)!=NULL) then 
         {
             findcostf_dimptr->xmax<==findcostf_netptr->xpos and findcostf_dimptr->xmin<==findcostf_dimptr->xmax and skip;
             findcostf_dimptr->ymax<==findcostf_netptr->ypos and findcostf_dimptr->ymin<==findcostf_dimptr->ymax and skip;
             findcostf_dimptr->Rnum<==1 and findcostf_dimptr->Lnum<==findcostf_dimptr->Rnum and skip;
             findcostf_dimptr->Tnum<==1 and findcostf_dimptr->Bnum<==findcostf_dimptr->Tnum and skip;
             findcostf_netptr:=findcostf_netptr->nterm
             
         }
         else 
         {
              skip 
         };
         while(findcostf_netptr!=NULL)
         {
             findcostf_x:=findcostf_netptr->xpos;
             findcostf_y:=findcostf_netptr->ypos;
             if(findcostf_x<findcostf_dimptr->xmin) then 
             {
                 findcostf_dimptr->xmin:=findcostf_x;
                 findcostf_dimptr->Lnum:=1
                 
             }
             else
             {
                 if(findcostf_x=findcostf_dimptr->xmin) then 
                 {
                     findcostf_dimptr->Lnum:=findcostf_dimptr->Lnum+1;
                     if(findcostf_x=findcostf_dimptr->xmax) then 
                     {
                         findcostf_dimptr->Rnum:=findcostf_dimptr->Rnum+1
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     if(findcostf_x>findcostf_dimptr->xmax) then 
                     {
                         findcostf_dimptr->xmax:=findcostf_x;
                         findcostf_dimptr->Rnum:=1
                     }
                     else
                     {
                         if(findcostf_x=findcostf_dimptr->xmax) then 
                         {
                             findcostf_dimptr->Rnum:=findcostf_dimptr->Rnum+1
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                 }
             };
             if(findcostf_y<findcostf_dimptr->ymin) then 
             {
                 findcostf_dimptr->ymin:=findcostf_y;
                 findcostf_dimptr->Bnum:=1
                 
             }
             else
             {
                 if(findcostf_y=findcostf_dimptr->ymin) then 
                 {
                     findcostf_dimptr->Bnum:=findcostf_dimptr->Bnum+1;
                     if(findcostf_y=findcostf_dimptr->ymax) then 
                     {
                         findcostf_dimptr->Tnum:=findcostf_dimptr->Tnum+1
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     if(findcostf_y>findcostf_dimptr->ymax) then 
                     {
                         findcostf_dimptr->ymax:=findcostf_y;
                         findcostf_dimptr->Tnum:=1
                     }
                     else
                     {
                         if(findcostf_y=findcostf_dimptr->ymax) then 
                         {
                             findcostf_dimptr->Tnum:=findcostf_dimptr->Tnum+1
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                 }
             };
             findcostf_netptr:=findcostf_netptr->nterm
             
         };
         findcostf_cost:=findcostf_cost+((int)(findcostf_dimptr->Hweight*(float)(findcostf_dimptr->xmax-findcostf_dimptr->xmin)))+((int)(findcostf_dimptr->Vweight*(float)(findcostf_dimptr->ymax-findcostf_dimptr->ymin)));
         findcostf_net:=findcostf_net+1
         
     };
     binpenal:=0;
     rowpenal:=0;
     penalty:=0;
     findcostf_block:=1;
     
     while(findcostf_block<=numblock)
     {
         findcostf_bin:=0;
         
         while(findcostf_bin<=findcostf_old_numBins)
         {
             safe_free(binptr[findcostf_block,findcostf_bin]->cell,RValue);
             safe_free(binptr[findcostf_block,findcostf_bin],RValue);
             findcostf_bin:=findcostf_bin+1
             
         };
         safe_free(binptr[findcostf_block],RValue);
         findcostf_block:=findcostf_block+1
         
     };
     findcostf_block:=1;
     
     while(findcostf_block<=numblock)
     {
         binptr[findcostf_block]:=(binbox* *)safe_malloc((numBins+1)*sizeof(binbox*),RValue);
         findcostf_left:=barray[findcostf_block]->bleft+barray[findcostf_block]->bxcenter;
         findcostf_right:=barray[findcostf_block]->bleft+barray[findcostf_block]->bxcenter+barray[findcostf_block]->desire;
         findcostf_LoBin:=SetBin(findcostf_left,RValue);
         findcostf_HiBin:=SetBin(findcostf_right,RValue);
         findcostf_bin:=0;
         
         while(findcostf_bin<=numBins)
         {
             binptr[findcostf_block,findcostf_bin]:=(binbox *)safe_malloc(sizeof(binbox),RValue);
             binptr[findcostf_block,findcostf_bin]->cell:=(int *)safe_malloc(10*sizeof(int),RValue);
             findcostf_bptr:=binptr[findcostf_block,findcostf_bin];
             findcostf_bptr->cell[0]:=0;
             findcostf_bptr->right:=binOffst+findcostf_bin*binWidth;
             findcostf_bptr->left:=findcostf_bptr->right-binWidth;
             if(findcostf_bin=findcostf_LoBin) then 
             {
                 findcostf_bptr->penalty:=findcostf_left-findcostf_bptr->right
                 
             }
             else
             {
                 if(findcostf_bin=findcostf_HiBin) then 
                 {
                     findcostf_bptr->penalty:=findcostf_bptr->left-findcostf_right
                 }
                 else
                 {
                     if(findcostf_bin>findcostf_HiBin OR findcostf_bin<findcostf_LoBin) then 
                     {
                         findcostf_bptr->penalty:=0
                     }
                     else
                     {
                         findcostf_bptr->penalty:=-binWidth
                     }
                 }
             };
             findcostf_bin:=findcostf_bin+1
             
         };
         findcostf_block:=findcostf_block+1
         
     };
     installf(RValue);
     findcostf_cell:=1;
     
     while(findcostf_cell<=numcells)
     {
         findcostf_cellptr1:=carray[findcostf_cell];
         findcostf_tileptr1:=findcostf_cellptr1->tileptr;
         findcostf_block:=findcostf_cellptr1->cblock;
         findcostf_startx:=findcostf_cellptr1->cxcenter+findcostf_tileptr1->left;
         findcostf_endx:=findcostf_cellptr1->cxcenter+findcostf_tileptr1->right;
         barray[findcostf_block]->oldsize:=barray[findcostf_block]->oldsize+findcostf_endx-findcostf_startx;
         findcostf_cbin:=SetBin(findcostf_cellptr1->cxcenter,RValue);
         findcostf_LoBin:=SetBin(findcostf_startx,RValue);
         findcostf_HiBin:=SetBin(findcostf_endx,RValue);
         findcostf_k:=((binptr[findcostf_block,findcostf_cbin]->cell[0])+1);
         (binptr[findcostf_block,findcostf_cbin]->cell[0]):=(binptr[findcostf_block,findcostf_cbin]->cell[0])+1;
         if(findcostf_k % 10=0) then 
         {
             binptr[findcostf_block,findcostf_cbin]->cell:=(int *)safe_realloc(binptr[findcostf_block,findcostf_cbin]->cell,(findcostf_k+10)*sizeof(int),RValue)
             
         }
         else 
         {
              skip 
         };
         binptr[findcostf_block,findcostf_cbin]->cell[findcostf_k]:=findcostf_cell;
         if(findcostf_LoBin=findcostf_HiBin) then 
         {
             binptr[findcostf_block,findcostf_LoBin]->penalty:=binptr[findcostf_block,findcostf_LoBin]->penalty+(findcostf_endx-findcostf_startx)
             
         }
         else
         {
             findcostf_bptr:=binptr[findcostf_block,findcostf_LoBin];
             findcostf_bptr->penalty:=findcostf_bptr->penalty+(findcostf_bptr->right-findcostf_startx);
             findcostf_bptr:=binptr[findcostf_block,findcostf_HiBin];
             findcostf_bptr->penalty:=findcostf_bptr->penalty+(findcostf_endx-findcostf_bptr->left);
             if(findcostf_LoBin+1<findcostf_HiBin) then 
             {
                 findcostf_bin:=findcostf_LoBin+1;
                 
                 while(findcostf_bin<=findcostf_HiBin-1)
                 {
                     binptr[findcostf_block,findcostf_bin]->penalty:=binptr[findcostf_block,findcostf_bin]->penalty+binWidth;
                     findcostf_bin:=findcostf_bin+1
                     
                 }
                 
             }
             else 
             {
                  skip 
             }
         };
         findcostf_cell:=findcostf_cell+1
         
     };
     findcostf_block:=1;
     
     while(findcostf_block<=numblock)
     {
         findcostf_bin:=0;
         
         while(findcostf_bin<=numBins)
         {
             binpenal:=binpenal+extern ABS(binptr[findcostf_block,findcostf_bin]->penalty,RValue);
             findcostf_bin:=findcostf_bin+1
             
         };
         findcostf_block:=findcostf_block+1
         
     };
     findcostf_blk:=1;
     
     while(findcostf_blk<=numblock)
     {
         rowpenal:=rowpenal+extern ABS(barray[findcostf_blk]->oldsize-barray[findcostf_blk]->desire,RValue);
         findcostf_blk:=findcostf_blk+1
         
     };
     penalty:=(int)(binpenCon*(float)binpenal+roLenCon*(float)rowpenal);
     return<==1 and RValue:=findcostf_cost;
     skip
     )
     }; 
  function installf ( int RValue )
 {
     frame(installf_row,installf_n,installf_left,installf_length,installf_sep,installf_i,installf_bin,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     int installf_row,installf_n,installf_left,installf_length,installf_sep,installf_i,installf_bin and skip;
     continue<==0 and skip;
     installf_row:=1;
     
     while(installf_row<=numRows)
     {
          continue<==0 and skip;
         installf_n:=feeds_in_row[installf_row];
         if(installf_n<1) then 
         {
             continue<==1 and skip;
              installf_row:=installf_row+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             installf_left:=barray[installf_row]->bxcenter+barray[installf_row]->bleft;
             installf_length:=barray[installf_row]->bright-barray[installf_row]->bleft;
             installf_sep:=(installf_length-installf_n*binWidth)/ (installf_n+1);
             installf_i:=1;
             
             while(installf_i<=installf_n)
             {
                 installf_bin:=SetBin(installf_left+installf_sep*installf_i+binWidth/ 2,RValue);
                 binptr[installf_row,installf_bin]->penalty:=binptr[installf_row,installf_bin]->penalty+binWidth;
                 barray[installf_row]->oldsize:=barray[installf_row]->oldsize+binWidth;
                 installf_i:=installf_i+1
                 
             };
             installf_row:=installf_row+1
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
      return<==1 and skip
     )
     }; 
  function assignro (  )
 {
     frame(assignro_pinptr,assignro_tmptr,assignro_row,assignro_cell,assignro_pad,assignro_yc,assignro_yb,assignro_blk,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     termbox* assignro_pinptr and skip;
     netbox* assignro_tmptr and skip;
     int assignro_row,assignro_cell,assignro_pad and skip;
     int assignro_yc,assignro_yb,assignro_blk and skip;
     rowgrid:=(int **)safe_malloc((numRows+2)*sizeof(int *),RValue);
     assignro_row:=0;
     
     while(assignro_row<=numRows+1)
     {
         rowgrid[assignro_row]:=(int *)safe_malloc(3*sizeof(int),RValue);
         assignro_row:=assignro_row+1
         
     };
     assignro_cell:=1;
     
     while(assignro_cell<=numcells)
     {
         assignro_pinptr:=carray[assignro_cell]->tileptr->termsptr;
         assignro_row:=blkToRow[carray[assignro_cell]->cblock];
         while(assignro_pinptr!=NULL)
         {
             assignro_tmptr:=tearray[assignro_pinptr->cellterm];
             assignro_tmptr->row:=assignro_row;
             assignro_pinptr:=assignro_pinptr->nextterm
             
         };
         assignro_cell:=assignro_cell+1
         
     };
     assignro_pad:=numcells+1;
     
     while(assignro_pad<=numcells+numterms)
     {
         if(carray[assignro_pad]->padside=2 OR carray[assignro_pad]->padside=14) then 
         {
             assignro_row:=numRows+1;
             assignro_pinptr:=carray[assignro_pad]->tileptr->termsptr;
             while(assignro_pinptr!=NULL)
             {
                 assignro_tmptr:=tearray[assignro_pinptr->cellterm];
                 assignro_tmptr->row:=assignro_row;
                 assignro_pinptr:=assignro_pinptr->nextterm
                 
             }
             
         }
         else
         {
             if(carray[assignro_pad]->padside=4 OR carray[assignro_pad]->padside=15) then 
             {
                 assignro_row:=0;
                 assignro_pinptr:=carray[assignro_pad]->tileptr->termsptr;
                 while(assignro_pinptr!=NULL)
                 {
                     assignro_tmptr:=tearray[assignro_pinptr->cellterm];
                     assignro_tmptr->row:=assignro_row;
                     assignro_pinptr:=assignro_pinptr->nextterm
                     
                 }
             }
             else
             {
                 assignro_pinptr:=carray[assignro_pad]->tileptr->termsptr;
                 while(assignro_pinptr!=NULL)
                 {
                     assignro_tmptr:=tearray[assignro_pinptr->cellterm];
                     if(no_feeds_side_nets=1) then 
                     {
                         if(carray[assignro_pad]->padside=1 OR carray[assignro_pad]->padside=3) then 
                         {
                             netarray[assignro_tmptr->net]->feedflag:=1
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     assignro_yc:=carray[assignro_pad]->cycenter+assignro_pinptr->typos[1];
                     break$<==0 and skip;
                     assignro_blk:=1;
                     
                     while( break$=0 AND  assignro_blk<=numRows)
                     {
                         if(rowArray[assignro_blk].ypos>=assignro_yc) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             assignro_blk:=assignro_blk+1
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     break$<==0 and skip;
                     if(assignro_blk=1) then 
                     {
                         assignro_row:=1
                         
                     }
                     else
                     {
                         if(assignro_blk>numRows) then 
                         {
                             assignro_row:=numRows
                         }
                         else
                         {
                             assignro_yb:=rowArray[assignro_blk].ypos;
                             if(assignro_yb-assignro_yc<assignro_yc-rowArray[assignro_blk-1].ypos) then 
                             {
                                 assignro_row:=assignro_blk
                             }
                             else
                             {
                                 assignro_row:=assignro_blk-1
                             }
                         }
                     };
                     assignro_tmptr->row:=assignro_row;
                     assignro_pinptr:=assignro_pinptr->nextterm
                     
                 }
             }
         };
         assignro_pad:=assignro_pad+1
         
     };
      return<==1 and skip
     )
     }; 
  function reassign (  )
 {
     frame(reassign_pinptr,reassign_tmptr,reassign_row,reassign_cell,reassign_pad,reassign_yc,reassign_yb,reassign_blk,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     termbox* reassign_pinptr and skip;
     netbox* reassign_tmptr and skip;
     int reassign_row,reassign_cell,reassign_pad and skip;
     int reassign_yc,reassign_yb,reassign_blk and skip;
     reassign_cell:=1;
     
     while(reassign_cell<=numcells)
     {
         reassign_pinptr:=carray[reassign_cell]->tileptr->termsptr;
         reassign_row:=blkToRow[carray[reassign_cell]->cblock];
         while(reassign_pinptr!=NULL)
         {
             reassign_tmptr:=tearray[reassign_pinptr->cellterm];
             reassign_tmptr->row:=reassign_row;
             reassign_pinptr:=reassign_pinptr->nextterm
             
         };
         reassign_cell:=reassign_cell+1
         
     };
     reassign_pad:=numcells+1;
     
     while(reassign_pad<=numcells+numterms)
     {
         if(carray[reassign_pad]->padside=2 OR carray[reassign_pad]->padside=14) then 
         {
             reassign_row:=numRows+1;
             reassign_pinptr:=carray[reassign_pad]->tileptr->termsptr;
             while(reassign_pinptr!=NULL)
             {
                 reassign_tmptr:=tearray[reassign_pinptr->cellterm];
                 reassign_tmptr->row:=reassign_row;
                 reassign_pinptr:=reassign_pinptr->nextterm
                 
             }
             
         }
         else
         {
             if(carray[reassign_pad]->padside=4 OR carray[reassign_pad]->padside=15) then 
             {
                 reassign_row:=0;
                 reassign_pinptr:=carray[reassign_pad]->tileptr->termsptr;
                 while(reassign_pinptr!=NULL)
                 {
                     reassign_tmptr:=tearray[reassign_pinptr->cellterm];
                     reassign_tmptr->row:=reassign_row;
                     reassign_pinptr:=reassign_pinptr->nextterm
                     
                 }
             }
             else
             {
                 reassign_pinptr:=carray[reassign_pad]->tileptr->termsptr;
                 while(reassign_pinptr!=NULL)
                 {
                     reassign_tmptr:=tearray[reassign_pinptr->cellterm];
                     if(no_feeds_side_nets=1) then 
                     {
                         if(carray[reassign_pad]->padside=1 OR carray[reassign_pad]->padside=3) then 
                         {
                             netarray[reassign_tmptr->net]->feedflag:=1
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     reassign_yc:=carray[reassign_pad]->cycenter+reassign_pinptr->typos[1];
                     break$<==0 and skip;
                     reassign_blk:=1;
                     
                     while( break$=0 AND  reassign_blk<=numRows)
                     {
                         if(rowArray[reassign_blk].ypos>=reassign_yc) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             reassign_blk:=reassign_blk+1
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     break$<==0 and skip;
                     if(reassign_blk=1) then 
                     {
                         reassign_row:=1
                         
                     }
                     else
                     {
                         if(reassign_blk>numRows) then 
                         {
                             reassign_row:=numRows
                         }
                         else
                         {
                             reassign_yb:=rowArray[reassign_blk].ypos;
                             if(reassign_yb-reassign_yc<reassign_yc-rowArray[reassign_blk-1].ypos) then 
                             {
                                 reassign_row:=reassign_blk
                             }
                             else
                             {
                                 reassign_row:=reassign_blk-1
                             }
                         }
                     };
                     reassign_tmptr->row:=reassign_row;
                     reassign_pinptr:=reassign_pinptr->nextterm
                     
                 }
             }
         };
         reassign_pad:=reassign_pad+1
         
     };
      return<==1 and skip
     )
     }; 
      int *act_feeds_in_row and skip;
     int pad_line and skip;
     int last_feed and skip;
    

 int impcount and skip;
 int *feed_location and skip;
 function findfeeds ( int flag,int RValue )
 {
     frame(findfeeds_netptr,findfeeds_saveptr,findfeeds_check,findfeeds_a,findfeeds_net,findfeeds_i,findfeeds_row,findfeeds_l,findfeeds_r,findfeeds_toprow,findfeeds_botrow,findfeeds_orig_toprow,findfeeds_orig_botrow,findfeeds_TOP_ROW_FOR_NET,findfeeds_position,findfeeds_max_row_length,findfeeds_first_ok,findfeeds_second_ok,findfeeds_rowb,findfeeds_rowt,findfeeds_have_to_check,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     netbox* findfeeds_netptr,*findfeeds_saveptr and skip;
     int findfeeds_check,findfeeds_a and skip;
     int findfeeds_net,findfeeds_i,findfeeds_row,findfeeds_l,findfeeds_r,findfeeds_toprow,findfeeds_botrow and skip;
     int findfeeds_orig_toprow,findfeeds_orig_botrow and skip;
     int findfeeds_TOP_ROW_FOR_NET,findfeeds_position,findfeeds_max_row_length and skip;
     int findfeeds_first_ok,findfeeds_second_ok,findfeeds_rowb,findfeeds_rowt,findfeeds_have_to_check and skip;
     feeds:=0;
     if(!flag) then 
     {
         prepglob(0,RValue);
         impcount:=0;
         act_feeds_in_row:=(int *)safe_malloc((1+numRows)*sizeof(int),RValue);
         findfeeds_row:=1;
         
         while(findfeeds_row<=numRows)
         {
             act_feeds_in_row[findfeeds_row]:=0;
             findfeeds_row:=findfeeds_row+1
             
         }
         
     }
     else
     {
         pad_line:=numcells+ffeeds+add_to_row[0];
         impfix(RValue)
     };
     feed_location:=(int *)safe_malloc((1+numnets)*sizeof(int),RValue);
     findfeeds_net:=0;
     
     while(findfeeds_net<=numnets)
     {
         feed_location[findfeeds_net]:=0;
         findfeeds_net:=findfeeds_net+1
         
     };
     continue<==0 and skip;
     findfeeds_net:=1;
     
     while(findfeeds_net<=numnets)
     {
          continue<==0 and skip;
         if(netarray[findfeeds_net]->feedflag=1) then 
         {
             continue<==1 and skip;
              findfeeds_net:=findfeeds_net+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             findfeeds_netptr:=netarray[findfeeds_net]->netptr ;
             if((findfeeds_netptr)!=NULL) then 
             {
                 findfeeds_i:=0;
                 
                 while(findfeeds_i<=numRows+1)
                 {
                     rowgrid[findfeeds_i,0]:=32000;
                     rowgrid[findfeeds_i,1]:=-1000;
                     rowgrid[findfeeds_i,2]:=-2;
                     findfeeds_i:=findfeeds_i+1
                     
                 };
                 continue<==0 and skip;
                 while(findfeeds_netptr!=NULL)
                 {
                      continue<==0 and skip;
                     if((flag=0 AND findfeeds_netptr->cell>numcells) OR (flag=1 AND findfeeds_netptr->cell>pad_line)) then 
                     {
                         if(carray[findfeeds_netptr->cell]->padside=1 OR carray[findfeeds_netptr->cell]->padside=9 OR carray[findfeeds_netptr->cell]->padside=5 OR carray[findfeeds_netptr->cell]->padside=7 OR carray[findfeeds_netptr->cell]->padside=3 OR carray[findfeeds_netptr->cell]->padside=10 OR carray[findfeeds_netptr->cell]->padside=6 OR carray[findfeeds_netptr->cell]->padside=8) then 
                         {
                             continue<==1 and skip;
                              findfeeds_netptr:=findfeeds_netptr->nterm}
                             else
                             {
                                 if(findfeeds_netptr->nterm!=NULL) then 
                                 {
                                     if(findfeeds_netptr->nterm->extint=findfeeds_netptr->extint) then 
                                     {
                                         break$<==0 and skip;
                                         while( break$=0 AND  true)
                                         {
                                             if(findfeeds_netptr->nterm->extint=findfeeds_netptr->extint) then 
                                             {
                                                 if((findfeeds_netptr->row>numRows AND findfeeds_netptr->ypos<=findfeeds_netptr->nterm->ypos) OR (findfeeds_netptr->row<1 AND findfeeds_netptr->ypos>=findfeeds_netptr->nterm->ypos)) then 
                                                 {
                                                     findfeeds_saveptr:=findfeeds_netptr->nterm;
                                                     findfeeds_netptr->nterm:=findfeeds_saveptr->nterm;
                                                     del_pin(findfeeds_saveptr->cell,findfeeds_saveptr->terminal,RValue);
                                                     safe_free(findfeeds_saveptr,RValue)
                                                     
                                                 }
                                                 else
                                                 {
                                                     if(findfeeds_netptr=netarray[findfeeds_net]->netptr) then 
                                                     {
                                                         netarray[findfeeds_net]->netptr:=findfeeds_netptr->nterm;
                                                         del_pin(findfeeds_netptr->cell,findfeeds_netptr->terminal,RValue);
                                                         safe_free(findfeeds_netptr,RValue);
                                                         findfeeds_netptr:=netarray[findfeeds_net]->netptr
                                                     }
                                                     else
                                                     {
                                                         findfeeds_saveptr:=netarray[findfeeds_net]->netptr;
                                                         break$<==0 and skip;
                                                         while( break$=0 AND  true)
                                                         {
                                                             if(findfeeds_saveptr->nterm=findfeeds_netptr) then 
                                                             {
                                                                 break$<==1 and skip
                                                              }
                                                             else
                                                             {
                                                                 findfeeds_saveptr:=findfeeds_saveptr->nterm
                                                             }
                                                             
                                                         };
                                                         break$<==0 and skip;
                                                         findfeeds_saveptr->nterm:=findfeeds_netptr->nterm;
                                                         del_pin(findfeeds_netptr->cell,findfeeds_netptr->terminal,RValue);
                                                         safe_free(findfeeds_netptr,RValue);
                                                         findfeeds_netptr:=findfeeds_saveptr->nterm
                                                     }
                                                 };
                                                 if(findfeeds_netptr->nterm=NULL) then 
                                                 {
                                                     break$<==1 and skip
                                                      
                                                 }
                                                 else 
                                                 {
                                                      skip 
                                                 }
                                             }
                                             else
                                             {
                                                 break$<==1 and skip
                                              }
                                         };
                                         break$<==0 and skip
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(continue=0)  then
                         {
                             findfeeds_row:=findfeeds_netptr->row;
                             if(findfeeds_netptr->xpos>rowgrid[findfeeds_row,1]) then 
                             {
                                 rowgrid[findfeeds_row,1]:=findfeeds_netptr->xpos
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(findfeeds_netptr->xpos<rowgrid[findfeeds_row,0]) then 
                             {
                                 rowgrid[findfeeds_row,0]:=findfeeds_netptr->xpos
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(rowgrid[findfeeds_row,2]=-2) then 
                             {
                                 rowgrid[findfeeds_row,2]:=detfeed(flag,findfeeds_row,findfeeds_net,RValue)
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             findfeeds_netptr:=findfeeds_netptr->nterm
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     continue<==0 and skip;
                     findfeeds_botrow:=0;
                     findfeeds_toprow:=numRows+1;
                     break$<==0 and skip;
                     while( break$=0 AND  findfeeds_botrow<=numRows+1)
                     {
                         if(rowgrid[findfeeds_botrow,1]!=-1000) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             findfeeds_botrow:=findfeeds_botrow+1
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     break$<==0 and skip;
                     break$<==0 and skip;
                     while( break$=0 AND  findfeeds_toprow>=0)
                     {
                         if(rowgrid[findfeeds_toprow,1]!=-1000) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             findfeeds_toprow:=findfeeds_toprow-1
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     break$<==0 and skip;
                     findfeeds_orig_toprow:=findfeeds_toprow;
                     findfeeds_orig_botrow:=findfeeds_botrow;
                     findfeeds_netptr:=netarray[findfeeds_net]->netptr;
                     continue<==0 and skip;
                     while(findfeeds_netptr!=NULL)
                     {
                          continue<==0 and skip;
                         if((flag=0 AND findfeeds_netptr->cell<=numcells) OR (flag=1 AND findfeeds_netptr->cell<=pad_line)) then 
                         {
                             continue<==1 and skip;
                              findfeeds_netptr:=findfeeds_netptr->nterm
                         }
                         else 
                         {
                              skip 
                         };
                         if(continue=0)   then 
                         {
                             if(carray[findfeeds_netptr->cell]->padside!=1 AND carray[findfeeds_netptr->cell]->padside!=9 AND carray[findfeeds_netptr->cell]->padside!=5 AND carray[findfeeds_netptr->cell]->padside!=7 AND carray[findfeeds_netptr->cell]->padside!=3 AND carray[findfeeds_netptr->cell]->padside!=10 AND carray[findfeeds_netptr->cell]->padside!=6 AND carray[findfeeds_netptr->cell]->padside!=8) then 
                             {
                                 continue<==1 and skip;
                                  findfeeds_netptr:=findfeeds_netptr->nterm
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)   then 
                             {
                                 if(findfeeds_netptr->nterm!=NULL) then 
                                 {
                                     if(findfeeds_netptr->nterm->extint=findfeeds_netptr->extint) then 
                                     {
                                         findfeeds_have_to_check:=1
                                     }
                                     else
                                     {
                                         findfeeds_have_to_check:=0
                                     }
                                     
                                 }
                                 else
                                 {
                                     findfeeds_have_to_check:=0
                                 };
                                 if(findfeeds_have_to_check) then 
                                 {
                                     break$<==0 and skip;
                                     while( break$=0 AND  true)
                                     {
                                         if(findfeeds_netptr->nterm->extint=findfeeds_netptr->extint) then 
                                         {
                                             findfeeds_row:=findfeeds_netptr->row;
                                             if(findfeeds_row<=findfeeds_toprow AND findfeeds_row>=findfeeds_botrow) then 
                                             {
                                                 findfeeds_first_ok:=0
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             if(findfeeds_row>findfeeds_toprow) then 
                                             {
                                                 findfeeds_first_ok:=findfeeds_row-findfeeds_toprow
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             if(findfeeds_row<findfeeds_botrow) then 
                                             {
                                                 findfeeds_first_ok:=findfeeds_botrow-findfeeds_row
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             findfeeds_row:=findfeeds_netptr->nterm->row;
                                             if(findfeeds_row<=findfeeds_toprow AND findfeeds_row>=findfeeds_botrow) then 
                                             {
                                                 findfeeds_second_ok:=0
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             if(findfeeds_row>findfeeds_toprow) then 
                                             {
                                                 findfeeds_second_ok:=findfeeds_row-findfeeds_toprow
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             if(findfeeds_row<findfeeds_botrow) then 
                                             {
                                                 findfeeds_second_ok:=findfeeds_botrow-findfeeds_row
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             if(findfeeds_first_ok=findfeeds_second_ok) then 
                                             {
                                                 findfeeds_first_ok:=1000000;
                                                 findfeeds_rowb:=( if((findfeeds_netptr->row-1>=0)) then findfeeds_netptr->row-1 else 0);
                                                 findfeeds_rowt:=( if((findfeeds_netptr->row+1<=numRows+1)) then findfeeds_netptr->row+1 else numRows+1);
                                                 continue<==0 and skip;
                                                 findfeeds_row:=findfeeds_rowb;
                                                 
                                                 while(findfeeds_row<=findfeeds_rowt)
                                                 {
                                                      continue<==0 and skip;
                                                     if(rowgrid[findfeeds_row,1]=-1000) then 
                                                     {
                                                         continue<==1 and skip;
                                                          findfeeds_row:=findfeeds_row+1
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     };
                                                     if(continue=0)   then 
                                                     {
                                                         if(findfeeds_netptr->xpos<=rowgrid[findfeeds_row,1] AND findfeeds_netptr->xpos>=rowgrid[findfeeds_row,0]) then 
                                                         {
                                                             findfeeds_first_ok:=0
                                                             
                                                         }
                                                         else
                                                         {
                                                             if(findfeeds_netptr->xpos>rowgrid[findfeeds_row,1]) then 
                                                             {
                                                                 if(findfeeds_netptr->xpos-rowgrid[findfeeds_row,1]<findfeeds_first_ok) then 
                                                                 {
                                                                     findfeeds_first_ok:=findfeeds_netptr->xpos-rowgrid[findfeeds_row,1]
                                                                     
                                                                 }
                                                                 else 
                                                                 {
                                                                      skip 
                                                                 }
                                                             }
                                                             else
                                                             {
                                                                 if(rowgrid[findfeeds_row,0]-findfeeds_netptr->xpos<findfeeds_first_ok) then 
                                                                 {
                                                                     findfeeds_first_ok:=rowgrid[findfeeds_row,0]-findfeeds_netptr->xpos
                                                                     
                                                                 }
                                                                 else 
                                                                 {
                                                                      skip 
                                                                 }
                                                             }
                                                         };
                                                         findfeeds_row:=findfeeds_row+1
                                                     }
                                                     else
                                                     {
                                                         skip
                                                     }
                                                     
                                                 };
                                                 continue<==0 and skip;
                                                 findfeeds_second_ok:=1000000;
                                                 findfeeds_rowb:=( if((findfeeds_netptr->nterm->row-1>=0)) then findfeeds_netptr->nterm->row-1 else 0);
                                                 findfeeds_rowt:=( if((findfeeds_netptr->nterm->row+1<=numRows+1)) then findfeeds_netptr->nterm->row+1 else numRows+1);
                                                 continue<==0 and skip;
                                                 findfeeds_row:=findfeeds_rowb;
                                                 
                                                 while(findfeeds_row<=findfeeds_rowt)
                                                 {
                                                      continue<==0 and skip;
                                                     if(rowgrid[findfeeds_row,1]=-1000) then 
                                                     {
                                                         continue<==1 and skip;
                                                          findfeeds_row:=findfeeds_row+1
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     };
                                                     if(continue=0)   then 
                                                     {
                                                         if(findfeeds_netptr->nterm->xpos<=rowgrid[findfeeds_row,1] AND findfeeds_netptr->nterm->xpos>=rowgrid[findfeeds_row,0]) then 
                                                         {
                                                             findfeeds_second_ok:=0
                                                             
                                                         }
                                                         else
                                                         {
                                                             if(findfeeds_netptr->nterm->xpos>rowgrid[findfeeds_row,1]) then 
                                                             {
                                                                 if(findfeeds_netptr->nterm->xpos-rowgrid[findfeeds_row,1]<findfeeds_second_ok) then 
                                                                 {
                                                                     findfeeds_second_ok:=findfeeds_netptr->nterm->xpos-rowgrid[findfeeds_row,1]
                                                                     
                                                                 }
                                                                 else 
                                                                 {
                                                                      skip 
                                                                 }
                                                             }
                                                             else
                                                             {
                                                                 if(rowgrid[findfeeds_row,0]-findfeeds_netptr->nterm->xpos<findfeeds_second_ok) then 
                                                                 {
                                                                     findfeeds_second_ok:=rowgrid[findfeeds_row,0]-findfeeds_netptr->nterm->xpos
                                                                     
                                                                 }
                                                                 else 
                                                                 {
                                                                      skip 
                                                                 }
                                                             }
                                                         };
                                                         findfeeds_row:=findfeeds_row+1
                                                     }
                                                     else
                                                     {
                                                         skip
                                                     }
                                                 };
                                                 continue<==0 and skip
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             if(findfeeds_first_ok<=findfeeds_second_ok) then 
                                             {
                                                 findfeeds_saveptr:=findfeeds_netptr->nterm;
                                                 findfeeds_netptr->nterm:=findfeeds_saveptr->nterm;
                                                 del_pin(findfeeds_saveptr->cell,findfeeds_saveptr->terminal,RValue);
                                                 safe_free(findfeeds_saveptr,RValue)
                                                 
                                             }
                                             else
                                             {
                                                 if(findfeeds_netptr=netarray[findfeeds_net]->netptr) then 
                                                 {
                                                     netarray[findfeeds_net]->netptr:=findfeeds_netptr->nterm;
                                                     del_pin(findfeeds_netptr->cell,findfeeds_netptr->terminal,RValue);
                                                     safe_free(findfeeds_netptr,RValue);
                                                     findfeeds_netptr:=netarray[findfeeds_net]->netptr
                                                 }
                                                 else
                                                 {
                                                     findfeeds_saveptr:=netarray[findfeeds_net]->netptr;
                                                     break$<==0 and skip;
                                                     while( break$=0 AND  true)
                                                     {
                                                         if(findfeeds_saveptr->nterm=findfeeds_netptr) then 
                                                         {
                                                             break$<==1 and skip
                                                          }
                                                         else
                                                         {
                                                             findfeeds_saveptr:=findfeeds_saveptr->nterm
                                                         }
                                                         
                                                     };
                                                     break$<==0 and skip;
                                                     findfeeds_saveptr->nterm:=findfeeds_netptr->nterm;
                                                     del_pin(findfeeds_netptr->cell,findfeeds_netptr->terminal,RValue);
                                                     safe_free(findfeeds_netptr,RValue);
                                                     findfeeds_netptr:=findfeeds_saveptr->nterm
                                                 }
                                             };
                                             if(findfeeds_netptr->nterm=NULL) then 
                                             {
                                                 break$<==1 and skip
                                                  
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                         }
                                         else
                                         {
                                             break$<==1 and skip
                                          }
                                     };
                                     break$<==0 and skip
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 findfeeds_row:=findfeeds_netptr->row;
                                 if(findfeeds_row<=findfeeds_orig_toprow AND findfeeds_row>=findfeeds_orig_botrow) then 
                                 {
                                     continue<==1 and skip
                                      
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(continue=0)   then 
                                 {
                                     if(findfeeds_row>findfeeds_toprow) then 
                                     {
                                         findfeeds_toprow:=findfeeds_row
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     if(findfeeds_row<findfeeds_botrow) then 
                                     {
                                         findfeeds_botrow:=findfeeds_row
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     if(findfeeds_netptr->xpos>rowgrid[findfeeds_row,1]) then 
                                     {
                                         rowgrid[findfeeds_row,1]:=findfeeds_netptr->xpos
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     if(findfeeds_netptr->xpos<rowgrid[findfeeds_row,0]) then 
                                     {
                                         rowgrid[findfeeds_row,0]:=findfeeds_netptr->xpos
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     if(rowgrid[findfeeds_row,2]=-2) then 
                                     {
                                         rowgrid[findfeeds_row,2]:=detfeed(flag,findfeeds_row,findfeeds_net,RValue)
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     findfeeds_netptr:=findfeeds_netptr->nterm
                                 }
                                 else
                                 {
                                     skip
                                 }
                             }
                             else
                             {
                                 skip
                             }
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     continue<==0 and skip;
                     if(findfeeds_toprow!=findfeeds_botrow) then 
                     {
                         findfeeds_row:=findfeeds_toprow;
                         findfeeds_TOP_ROW_FOR_NET:=1;
                         continue<==0 and skip;
                         findfeeds_row:=findfeeds_row-1;
                         
                         while(findfeeds_row>=findfeeds_botrow)
                         {
                              continue<==0 and skip;
                             if(rowgrid[findfeeds_row,1]=-1000) then 
                             {
                                 continue<==1 and skip;
                                  findfeeds_row:=findfeeds_row-1
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)   then 
                             {
                                 findfeeds_l:=( if((rowgrid[findfeeds_toprow,0]<=rowgrid[findfeeds_row,0])) then rowgrid[findfeeds_toprow,0] else rowgrid[findfeeds_row,0]);
                                 findfeeds_r:=( if((rowgrid[findfeeds_toprow,1]>=rowgrid[findfeeds_row,1])) then rowgrid[findfeeds_toprow,1] else rowgrid[findfeeds_row,1]);
                                 findfeeds_position:=(findfeeds_l+findfeeds_r)/ 2;
                                 if(gate_array_special) then 
                                 {
                                     if(feed_location[findfeeds_net]=0) then 
                                     {
                                         feed_location[findfeeds_net]:=findfeeds_position
                                     }
                                     else
                                     {
                                         findfeeds_position:=feed_location[findfeeds_net]
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(findfeeds_TOP_ROW_FOR_NET=1) then 
                                 {
                                     if(rowgrid[findfeeds_toprow,2]=1 OR rowgrid[findfeeds_toprow,2]=3) then 
                                     {
                                         if(!nofeed[findfeeds_toprow]) then 
                                         {
                                             if(flag=0) then 
                                             {
                                                 if(extern implfeeds(findfeeds_toprow,findfeeds_position,RValue)) then 
                                                 {
                                                     impcount:=impcount+1
                                                 }
                                                 else
                                                 {
                                                     feeds:=feeds+1;
                                                     act_feeds_in_row[findfeeds_toprow]:=act_feeds_in_row[findfeeds_toprow]+1;
                                                     if(gate_array_special=1) then 
                                                     {
                                                         build_feed_imp(feeds,findfeeds_position-fdWidth/ 2,findfeeds_toprow)
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                             }
                                             else
                                             {
                                                 if(extern implfeeds(findfeeds_toprow,findfeeds_position,RValue)) then 
                                                 {
                                                     addimp(findfeeds_toprow,findfeeds_net)
                                                 }
                                                 else
                                                 {
                                                     addfeed(findfeeds_toprow,findfeeds_position,(feeds+1),findfeeds_net,RValue);
                                                     feeds:=feeds+1;
                                                     if(gate_array_special=1) then 
                                                     {
                                                         build_feed_imp(feeds,findfeeds_position-fdWidth/ 2,findfeeds_toprow)
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                             }
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(findfeeds_row>findfeeds_botrow) then 
                                 {
                                     if(rowgrid[findfeeds_row,2]!=4) then 
                                     {
                                         if(!nofeed[findfeeds_row]) then 
                                         {
                                             if(flag=0) then 
                                             {
                                                 if(extern implfeeds(findfeeds_row,findfeeds_position,RValue)) then 
                                                 {
                                                     impcount:=impcount+1
                                                 }
                                                 else
                                                 {
                                                     feeds:=feeds+1;
                                                     act_feeds_in_row[findfeeds_row]:=act_feeds_in_row[findfeeds_row]+1;
                                                     if(gate_array_special=1) then 
                                                     {
                                                         build_feed_imp(feeds,findfeeds_position-fdWidth/ 2,findfeeds_row)
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                             }
                                             else
                                             {
                                                 if(extern implfeeds(findfeeds_row,findfeeds_position,RValue)) then 
                                                 {
                                                     addimp(findfeeds_row,findfeeds_net)
                                                 }
                                                 else
                                                 {
                                                     addfeed(findfeeds_row,findfeeds_position,(feeds+1),findfeeds_net,RValue);
                                                     feeds:=feeds+1;
                                                     if(gate_array_special=1) then 
                                                     {
                                                         build_feed_imp(feeds,findfeeds_position-fdWidth/ 2,findfeeds_row)
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                             }
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(findfeeds_row=findfeeds_botrow) then 
                                 {
                                     if(rowgrid[findfeeds_botrow,2]=2 OR rowgrid[findfeeds_botrow,2]=3) then 
                                     {
                                         if(!nofeed[findfeeds_botrow]) then 
                                         {
                                             if(flag=0) then 
                                             {
                                                 if(extern implfeeds(findfeeds_botrow,findfeeds_position,RValue)) then 
                                                 {
                                                     impcount:=impcount+1
                                                 }
                                                 else
                                                 {
                                                     feeds:=feeds+1;
                                                     act_feeds_in_row[findfeeds_botrow]:=act_feeds_in_row[findfeeds_botrow]+1;
                                                     if(gate_array_special=1) then 
                                                     {
                                                         build_feed_imp(feeds,findfeeds_position-fdWidth/ 2,findfeeds_botrow)
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                             }
                                             else
                                             {
                                                 if(extern implfeeds(findfeeds_botrow,findfeeds_position,RValue)) then 
                                                 {
                                                     addimp(findfeeds_botrow,findfeeds_net)
                                                 }
                                                 else
                                                 {
                                                     addfeed(findfeeds_botrow,findfeeds_position,(feeds+1),findfeeds_net,RValue);
                                                     feeds:=feeds+1;
                                                     if(gate_array_special=1) then 
                                                     {
                                                         build_feed_imp(feeds,findfeeds_position-fdWidth/ 2,findfeeds_botrow)
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                             }
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 findfeeds_check:=findfeeds_toprow-findfeeds_row-1;
                                 if(findfeeds_check!=0) then 
                                 {
                                     findfeeds_a:=findfeeds_toprow-1;
                                     
                                     while(findfeeds_a>findfeeds_row)
                                     {
                                         if(!nofeed[findfeeds_a]) then 
                                         {
                                             if(flag=0) then 
                                             {
                                                 if(extern implfeeds(findfeeds_a,findfeeds_position,RValue)) then 
                                                 {
                                                     impcount:=impcount+1
                                                 }
                                                 else
                                                 {
                                                     feeds:=feeds+1;
                                                     act_feeds_in_row[findfeeds_a]:=act_feeds_in_row[findfeeds_a]+1;
                                                     if(gate_array_special=1) then 
                                                     {
                                                         build_feed_imp(feeds,findfeeds_position-fdWidth/ 2,findfeeds_a)
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                             }
                                             else
                                             {
                                                 if(extern implfeeds(findfeeds_a,findfeeds_position,RValue)) then 
                                                 {
                                                     addimp(findfeeds_a,findfeeds_net)
                                                 }
                                                 else
                                                 {
                                                     addfeed(findfeeds_a,findfeeds_position,(feeds+1),findfeeds_net,RValue);
                                                     feeds:=feeds+1;
                                                     if(gate_array_special=1) then 
                                                     {
                                                         build_feed_imp(feeds,findfeeds_position-fdWidth/ 2,findfeeds_a)
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                             }
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         findfeeds_a:=findfeeds_a-1
                                         
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 findfeeds_toprow:=findfeeds_row;
                                 findfeeds_TOP_ROW_FOR_NET:=0;
                                 findfeeds_row:=findfeeds_row-1
                             }
                             else
                             {
                                 skip
                             }
                         };
                         continue<==0 and skip
                     }
                     else
                     {
                         if(netarray[findfeeds_net]->feedflag=0) then 
                         {
                             if(rowgrid[findfeeds_toprow,2]=3) then 
                             {
                                 if(!nofeed[findfeeds_toprow]) then 
                                 {
                                     findfeeds_l:=rowgrid[findfeeds_toprow,0];
                                     findfeeds_r:=rowgrid[findfeeds_toprow,1];
                                     findfeeds_position:=(findfeeds_l+findfeeds_r)/ 2;
                                     if(gate_array_special) then 
                                     {
                                         if(feed_location[findfeeds_net]=0) then 
                                         {
                                             feed_location[findfeeds_net]:=findfeeds_position
                                         }
                                         else
                                         {
                                             findfeeds_position:=feed_location[findfeeds_net]
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     if(flag=0) then 
                                     {
                                         if(extern implfeeds(findfeeds_toprow,findfeeds_position,RValue)) then 
                                         {
                                             impcount:=impcount+1
                                         }
                                         else
                                         {
                                             feeds:=feeds+1;
                                             act_feeds_in_row[findfeeds_toprow]:=act_feeds_in_row[findfeeds_toprow]+1;
                                             if(gate_array_special=1) then 
                                             {
                                                 build_feed_imp(feeds,findfeeds_position-fdWidth/ 2,findfeeds_toprow)
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                         }
                                     }
                                     else
                                     {
                                         if(extern implfeeds(findfeeds_toprow,findfeeds_position,RValue)) then 
                                         {
                                             addimp(findfeeds_toprow,findfeeds_net)
                                         }
                                         else
                                         {
                                             addfeed(findfeeds_toprow,findfeeds_position,(feeds+1),findfeeds_net,RValue);
                                             feeds:=feeds+1;
                                             if(gate_array_special=1) then 
                                             {
                                                 build_feed_imp(feeds,findfeeds_position-fdWidth/ 2,findfeeds_toprow)
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                         }
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 findfeeds_net:=findfeeds_net+1
             }
             else
             {
                 skip
             }
             
         };
         continue<==0 and skip;
         if(flag=0) then 
         {
             ffeeds:=feeds;
             findfeeds_row:=1;
             
             while(findfeeds_row<=numRows)
             {
                 length_of_row[findfeeds_row]:=length_of_row[findfeeds_row]+act_feeds_in_row[findfeeds_row]*fdWidth;
                 findfeeds_row:=findfeeds_row+1
                 
             };
             findfeeds_max_row_length:=0;
             findfeeds_row:=1;
             
             while(findfeeds_row<=numRows)
             {
                 if(length_of_row[findfeeds_row]>findfeeds_max_row_length) then 
                 {
                     findfeeds_max_row_length:=length_of_row[findfeeds_row]
                     
                 }
                 else 
                 {
                      skip 
                 };
                 findfeeds_row:=findfeeds_row+1
                 
             };
             add_to_row[0]:=0;
             findfeeds_row:=1;
             
             while(findfeeds_row<=numRows)
             {
                 add_to_row[findfeeds_row]:=(findfeeds_max_row_length-length_of_row[findfeeds_row])/ fdWidth;
                 add_to_row[0]:=add_to_row[0]+add_to_row[findfeeds_row];
                 findfeeds_row:=findfeeds_row+1
                 
             };
             safe_free(length_of_row,RValue);
             if(addFeeds) then 
             {
                 prepglob(1,RValue)
                 
             }
             else 
             {
                  skip 
             }
             
         }
         else
         {
             impclobr(RValue);
             last_feed:=feeds
         };
         safe_free(feed_location,RValue);
         return<==1 and RValue:=feeds;
         skip
         )
         }; 
  function del_pin ( int cell,int pin,int RValue )
 {
     frame(del_pin_tptr,del_pin_sptr,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     termbox* del_pin_tptr,*del_pin_sptr and skip;
     carray[cell]->numterms:=carray[cell]->numterms-1;
     del_pin_tptr:=carray[cell]->tileptr->termsptr;
     if(del_pin_tptr->cellterm=pin) then 
     {
         del_pin_sptr:=carray[cell]->tileptr->termsptr;
         carray[cell]->tileptr->termsptr:=del_pin_tptr->nextterm;
         safe_free(del_pin_sptr,RValue)
         
     }
     else
     {
         break$<==0 and skip;
         while( break$=0 AND  true)
         {
             if(del_pin_tptr->nextterm->cellterm=pin) then 
             {
                 break$<==1 and skip
              }
             else
             {
                 del_pin_tptr:=del_pin_tptr->nextterm
             }
             
         };
         break$<==0 and skip;
         del_pin_sptr:=del_pin_tptr->nextterm;
         del_pin_tptr->nextterm:=del_pin_sptr->nextterm;
         safe_free(del_pin_sptr,RValue)
     };
      return<==1 and skip
     )
     }; 
  function fixwolf ( int nfeed )
 {
     frame(fixwolf_newarray,fixwolf_ptr,fixwolf_i,fixwolf_j,fixwolf_n,return) and ( 
     int return<==0 and skip;
     cellbox* *fixwolf_newarray,*fixwolf_ptr and skip;
     int fixwolf_i,fixwolf_j,fixwolf_n and skip;
     fixwolf_n:=numcells;
     fixwolf_newarray:=(cellbox* *)safe_malloc((1+numcells+numterms+2*numblock+nfeed)*sizeof(cellbox*),RValue);
     tearray:=(netbox* *)safe_realloc(tearray,(2*(nfeed+impcount+numblock+1)+maxterm+1)*sizeof(netbox*),RValue);
     pinnames:=(char **)safe_realloc(pinnames,(1+maxterm+2*(nfeed+impcount))*sizeof(char *),RValue);
     fixwolf_i:=1;
     
     while(fixwolf_i<=fixwolf_n)
     {
         fixwolf_newarray[fixwolf_i]:=carray[fixwolf_i];
         fixwolf_i:=fixwolf_i+1
         
     };
     fixwolf_j:=fixwolf_n+1;
     
     while(fixwolf_j<=fixwolf_n+nfeed)
     {
         fixwolf_ptr:=(cellbox*)safe_malloc(sizeof(cellbox),RValue);
		 fixwolf_newarray[fixwolf_j]<==fixwolf_ptr and skip;
         fixwolf_ptr->corient:=0;
         fixwolf_ptr->cclass:=0;
         if(gate_array_special) then 
         {
             fixwolf_ptr->orflag:=1
             
         }
         else
         {
             fixwolf_ptr->orflag:=0
         };
         fixwolf_ptr->numterms:=2;
         fixwolf_ptr->tileptr:=(tilebox*)safe_malloc(sizeof(tilebox),RValue);
         fixwolf_ptr->tileptr->termsptr:=(termbox*)safe_malloc(sizeof(termbox),RValue);
         fixwolf_ptr->tileptr->termsptr->cellterm:=(maxterm+1);
         maxterm:=maxterm+1;
         pinnames[maxterm]:=(char *)safe_malloc(16*sizeof(char),RValue);
         sprintf(pinnames[maxterm],"twfeed%d",maxterm,RValue) and skip;
         fixwolf_ptr->tileptr->termsptr->ei:=maxterm;
         fixwolf_ptr->tileptr->termsptr->ue:=0;
         fixwolf_ptr->tileptr->termsptr->nextterm:=(termbox*)safe_malloc(sizeof(termbox),RValue);
         fixwolf_ptr->tileptr->termsptr->nextterm->nextterm:=NULL;
         fixwolf_ptr->tileptr->termsptr->nextterm->ei:=maxterm;
         fixwolf_ptr->tileptr->termsptr->nextterm->ue:=0;
         fixwolf_ptr->tileptr->termsptr->nextterm->cellterm:=(maxterm+1);
         maxterm:=maxterm+1;
         pinnames[maxterm]:=(char *)safe_malloc(16*sizeof(char),RValue);
         sprintf(pinnames[maxterm],"twfeed%d",maxterm,RValue) and skip;
         fixwolf_j:=fixwolf_j+1
         
     };
     while(fixwolf_i<=numcells+numterms)
     {
         fixwolf_newarray[fixwolf_j]:=carray[fixwolf_i];
         fixwolf_i:=fixwolf_i+1 and fixwolf_j:=fixwolf_j+1
         
     };
     safe_free(carray,RValue);
	 
     carray:=(cellbox* *)safe_realloc(fixwolf_newarray,(1+numcells+numterms+2*numblock+nfeed)*sizeof(cellbox*),RValue);
      return<==1 and skip
     )
     }; 
  function addfeed ( int row,int pos,int feednum,int net,int RValue )
 {
     frame(addfeed_cellptr,addfeed_tileptr,addfeed_nptr,addfeed_termptr,addfeed_pin,addfeed_blk,addfeed_corient,return) and ( 
     int return<==0 and skip;
     cellbox* addfeed_cellptr and skip;
     tilebox* addfeed_tileptr and skip;
     netbox* addfeed_nptr and skip;
     termbox* addfeed_termptr and skip;
     int addfeed_pin,addfeed_blk,addfeed_corient and skip;
     addfeed_blk:=rowToBlk(row,pos,RValue);
     addfeed_cellptr:=carray[numcells+feednum];
     addfeed_cellptr->padside:=0;
     addfeed_cellptr->cxcenter:=pos;
     addfeed_cellptr->cycenter:=barray[addfeed_blk]->bycenter;
     addfeed_cellptr->cheight:=barray[addfeed_blk]->bheight;
     addfeed_cellptr->clength:=fdWidth;
     if(barray[addfeed_blk]->borient=2) then 
     {
         addfeed_cellptr->corient:=1
         
     }
     else 
     {
          skip 
     };
     addfeed_tileptr:=addfeed_cellptr->tileptr;
     addfeed_cellptr->cname:=(char *)safe_malloc(16*sizeof(char),RValue);
     if(gate_array_special) then 
     {
         sprintf(addfeed_cellptr->cname,"twfeed",RValue) and skip
         
     }
     else
     {
         sprintf(addfeed_cellptr->cname,"twfeed%d",feednum,RValue) and skip
     };
     addfeed_cellptr->cblock:=addfeed_blk;
     addfeed_tileptr->left:=-fdWidth/ 2;
     addfeed_tileptr->right:=fdWidth+addfeed_tileptr->left;
     addfeed_tileptr->bottom:=-barray[addfeed_blk]->bheight/ 2;
     addfeed_tileptr->top:=barray[addfeed_blk]->bheight+addfeed_tileptr->bottom;
     addfeed_termptr:=addfeed_tileptr->termsptr;
     addfeed_termptr->txpos[0]:=0;
     addfeed_termptr->txpos[1]:=0;
     addfeed_corient:=addfeed_cellptr->corient;
     if(addfeed_corient=0) then 
     {
         addfeed_termptr->typos[0]:=addfeed_tileptr->top;
         addfeed_termptr->typos[1]:=addfeed_tileptr->bottom
         
     }
     else
     {
         addfeed_termptr->typos[0]:=addfeed_tileptr->bottom;
         addfeed_termptr->typos[1]:=addfeed_tileptr->top
     };
     addfeed_termptr:=addfeed_termptr->nextterm;
     addfeed_termptr->txpos[0]:=0;
     addfeed_termptr->txpos[1]:=0;
     if(addfeed_corient=0) then 
     {
         addfeed_termptr->typos[0]:=addfeed_tileptr->bottom;
         addfeed_termptr->typos[1]:=addfeed_tileptr->top
         
     }
     else
     {
         addfeed_termptr->typos[0]:=addfeed_tileptr->top;
         addfeed_termptr->typos[1]:=addfeed_tileptr->bottom
     };
     addfeed_pin:=addfeed_tileptr->termsptr->cellterm;
     addfeed_nptr:=netarray[net]->netptr;
     if(addfeed_nptr=NULL) then 
     {
         fprintf(fpo,"no pins in net to be ") and skip;
         fprintf(fpo,"connected to feed thru\n") and skip;
         exit(0) and skip
         
     }
     else 
     {
          skip 
     };
     while(addfeed_nptr->nterm!=NULL)
     {
         addfeed_nptr:=addfeed_nptr->nterm
         
     };
     addfeed_nptr->nterm:=(netbox*)safe_malloc(sizeof(netbox),RValue);
	 addfeed_nptr<==addfeed_nptr->nterm and skip;
     tearray[addfeed_pin]:=addfeed_nptr;
     addfeed_nptr->terminal:=addfeed_pin;
     addfeed_nptr->flag:=0;
     addfeed_nptr->row:=row;
     addfeed_nptr->cell:=numcells+feednum;
     addfeed_nptr->net:=net;
     addfeed_nptr->extint:=addfeed_tileptr->termsptr->ei;
     addfeed_nptr->unequiv:=addfeed_tileptr->termsptr->ue;
     addfeed_nptr->layer:=feedLayer;
     addfeed_nptr->pinloc:=1;
     addfeed_pin:=addfeed_tileptr->termsptr->nextterm->cellterm;
     addfeed_nptr->nterm:=(netbox*)safe_malloc(sizeof(netbox),RValue);
	 addfeed_nptr<==addfeed_nptr->nterm and skip;
     tearray[addfeed_pin]:=addfeed_nptr;
     addfeed_nptr->nterm:=NULL;
     addfeed_nptr->terminal:=addfeed_pin;
     addfeed_nptr->flag:=0;
     addfeed_nptr->row:=row;
     addfeed_nptr->cell:=numcells+feednum;
     addfeed_nptr->net:=net;
     addfeed_nptr->extint:=addfeed_tileptr->termsptr->nextterm->ei;
     addfeed_nptr->unequiv:=addfeed_tileptr->termsptr->nextterm->ue;
     addfeed_nptr->layer:=feedLayer;
     addfeed_nptr->pinloc:=-1;
      return<==1 and skip
     )
     }; 
  function rowToBlk ( int row,int pos,int RValue )
 {
     frame(rowToBlk_y,rowToBlk_block,rowToBlk_block1,rowToBlk_block2,rowToBlk_startx1,rowToBlk_endx1,rowToBlk_startx2,rowToBlk_endx2,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     int rowToBlk_y,rowToBlk_block,rowToBlk_block1,rowToBlk_block2,rowToBlk_startx1,rowToBlk_endx1,rowToBlk_startx2 and skip;
     int rowToBlk_endx2 and skip;
     rowToBlk_y:=rowArray[row].ypos;
     rowToBlk_block1:=0;
     rowToBlk_block2:=0;
     break$<==0 and skip;
     rowToBlk_block:=1;
     
     while( break$=0 AND  rowToBlk_block<=numblock)
     {
         if(barray[rowToBlk_block]->bycenter=rowToBlk_y) then 
         {
             rowToBlk_block1:=rowToBlk_block;
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             rowToBlk_block:=rowToBlk_block+1
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     break$<==0 and skip;
     rowToBlk_block:=rowToBlk_block+1;
     
     while( break$=0 AND  rowToBlk_block<=numblock)
     {
         if(barray[rowToBlk_block]->bycenter=rowToBlk_y) then 
         {
             rowToBlk_block2:=rowToBlk_block;
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             rowToBlk_block:=rowToBlk_block+1
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     if(rowToBlk_block1=0) then 
     {
         fprintf(fpo,"rowToBlk failed to find block corresponding\n") and skip;
         fprintf(fpo,"to row:%d\n",row) and skip;
         exit(0) and skip 
         
     }
     else 
     {
          skip 
     };
     if(rowToBlk_block2=0) then 
     {
         rowToBlk_block:=rowToBlk_block1
         
     }
     else
     {
         rowToBlk_startx1:=barray[rowToBlk_block1]->bxcenter+barray[rowToBlk_block1]->bleft;
         rowToBlk_endx1:=barray[rowToBlk_block1]->bxcenter+barray[rowToBlk_block1]->bright;
         rowToBlk_startx2:=barray[rowToBlk_block2]->bxcenter+barray[rowToBlk_block2]->bleft;
         rowToBlk_endx2:=barray[rowToBlk_block2]->bxcenter+barray[rowToBlk_block2]->bright;
         if(pos>=rowToBlk_startx1 AND pos<=rowToBlk_endx1) then 
         {
             rowToBlk_block:=rowToBlk_block1
         }
         else
         {
             if(pos>=rowToBlk_startx2 AND pos<=rowToBlk_endx2) then 
             {
                 rowToBlk_block:=rowToBlk_block2
             }
             else
             {
                 if(rowToBlk_endx2<rowToBlk_startx1) then 
                 {
                     if(pos-rowToBlk_endx2<=rowToBlk_startx1-pos) then 
                     {
                         rowToBlk_block:=rowToBlk_block2
                     }
                     else
                     {
                         rowToBlk_block:=rowToBlk_block1
                     }
                 }
                 else
                 {
                     if(pos-rowToBlk_endx1<=rowToBlk_startx2-pos) then 
                     {
                         rowToBlk_block:=rowToBlk_block1
                     }
                     else
                     {
                         rowToBlk_block:=rowToBlk_block2
                     }
                 }
             }
         }
     };
     return<==1 and RValue:=rowToBlk_block;
     skip
     )
     }; 
  function prepglob ( int degree,int RValue )
 {
     frame(prepglob_pinptr,prepglob_cell,prepglob_corient,return) and ( 
     int return<==0 and skip;
     termbox* prepglob_pinptr and skip;
     int prepglob_cell,prepglob_corient and skip;
     if(degree=0) then 
     {
         prepglob_cell:=1;
         
         while(prepglob_cell<=numcells+numterms)
         {
             if(prepglob_cell<=numcells) then 
             {
                 prepglob_pinptr:=carray[prepglob_cell]->tileptr->termsptr;
                 prepglob_corient:=carray[prepglob_cell]->corient;
                 while(prepglob_pinptr!=NULL)
                 {
                     tearray[prepglob_pinptr->cellterm]->extint:=prepglob_pinptr->ei;
                     tearray[prepglob_pinptr->cellterm]->unequiv:=prepglob_pinptr->ue;
                     if(extern ABS(prepglob_pinptr->typos[prepglob_corient % 2],RValue)>1) then 
                     {
                         if(prepglob_pinptr->typos[prepglob_corient % 2]>0) then 
                         {
                             tearray[prepglob_pinptr->cellterm]->pinloc:=1
                         }
                         else
                         {
                             tearray[prepglob_pinptr->cellterm]->pinloc:=-1
                         }
                         
                     }
                     else
                     {
                         tearray[prepglob_pinptr->cellterm]->pinloc:=0
                     };
                     prepglob_pinptr:=prepglob_pinptr->nextterm
                     
                 }
                 
             }
             else
             {
                 if(prepglob_cell>numcells) then 
                 {
                     prepglob_pinptr:=carray[prepglob_cell]->tileptr->termsptr;
                     while(prepglob_pinptr!=NULL)
                     {
                         tearray[prepglob_pinptr->cellterm]->cell:=prepglob_cell;
                         tearray[prepglob_pinptr->cellterm]->extint:=prepglob_pinptr->ei;
                         tearray[prepglob_pinptr->cellterm]->unequiv:=prepglob_pinptr->ue;
                         tearray[prepglob_pinptr->cellterm]->pinloc:=0;
                         prepglob_pinptr:=prepglob_pinptr->nextterm
                         
                     }
                     
                 }
                 else 
                 {
                      skip 
                 }
             };
             prepglob_cell:=prepglob_cell+1
             
         }
         
     }
     else
     {
         prepglob_cell:=numcells+1;
         
         while(prepglob_cell<=numcells+numterms)
         {
             prepglob_pinptr:=carray[prepglob_cell]->tileptr->termsptr;
             while(prepglob_pinptr!=NULL)
             {
                 tearray[prepglob_pinptr->cellterm]->cell:=prepglob_cell+ffeeds+add_to_row[0];
                 prepglob_pinptr:=prepglob_pinptr->nextterm
                 
             };
             prepglob_cell:=prepglob_cell+1
             
         }
     };
      return<==1 and skip
     )
     }; 
  function detfeed ( int flag,int row,int net,int RValue )
 {
     frame(detfeed_cellptr,detfeed_nptr,detfeed_nptr2,detfeed_pinup,detfeed_pindown,detfeed_extint,detfeed_pinloc,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     cellbox* detfeed_cellptr and skip;
     netbox* detfeed_nptr,*detfeed_nptr2 and skip;
     int detfeed_pinup,detfeed_pindown and skip;
     int detfeed_extint,detfeed_pinloc and skip;
     detfeed_pinup:=0;
     detfeed_pindown:=0;
     continue<==0 and skip;
     detfeed_nptr:=netarray[net]->netptr;
     
     while( return=0 AND  detfeed_nptr!=NULL)
     {
          continue<==0 and skip;
         if(detfeed_nptr->row!=row OR detfeed_nptr->unequiv=1) then 
         {
             continue<==1 and skip;
              detfeed_nptr:=detfeed_nptr->nterm
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             if((flag=0 AND detfeed_nptr->cell>numcells) OR (flag=1 AND detfeed_nptr->cell>pad_line)) then 
             {
                 detfeed_cellptr:=carray[detfeed_nptr->cell];
                 if(detfeed_cellptr->padside=1 OR detfeed_cellptr->padside=9 OR detfeed_cellptr->padside=5 OR detfeed_cellptr->padside=7 OR detfeed_cellptr->padside=3 OR detfeed_cellptr->padside=10 OR detfeed_cellptr->padside=6 OR detfeed_cellptr->padside=8) then 
                 {
                     continue<==1 and skip;
                      detfeed_nptr:=detfeed_nptr->nterm
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(continue=0)  then
             {
                 detfeed_extint:=detfeed_nptr->extint;
                 detfeed_pinloc:=detfeed_nptr->pinloc;
                 if(detfeed_pinloc=0) then 
                 {
                     return<==1 and RValue:=4;
                     skip
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(return=0)   then 
                 {
                     if(detfeed_pinloc>0) then 
                     {
                         detfeed_pinup:=1
                         
                     }
                     else
                     {
                         detfeed_pindown:=1
                     };
                     detfeed_nptr2:=detfeed_nptr->nterm;
                     continue<==0 and skip;
                     while( return=0 AND  detfeed_nptr2!=NULL)
                     {
                          continue<==0 and skip;
                         if(detfeed_nptr2->row!=row OR detfeed_nptr2->unequiv=1) then 
                         {
                             continue<==1 and skip;
                              detfeed_nptr2:=detfeed_nptr2->nterm
                         }
                         else 
                         {
                              skip 
                         };
                         if(continue=0)   then 
                         {
                             if((flag=0 AND detfeed_nptr2->cell>numcells) OR (flag=1 AND detfeed_nptr2->cell>pad_line)) then 
                             {
                                 detfeed_cellptr:=carray[detfeed_nptr2->cell];
                                 if(detfeed_cellptr->padside=1 OR detfeed_cellptr->padside=9 OR detfeed_cellptr->padside=5 OR detfeed_cellptr->padside=7 OR detfeed_cellptr->padside=3 OR detfeed_cellptr->padside=10 OR detfeed_cellptr->padside=6 OR detfeed_cellptr->padside=8) then 
                                 {
                                     continue<==1 and skip;
                                      detfeed_nptr2:=detfeed_nptr2->nterm
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)  then
                             {
                                 if(detfeed_nptr2->pinloc=0) then 
                                 {
                                     return<==1 and RValue:=4;
                                     skip
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(return=0)   then 
                                 {
                                     if(detfeed_nptr2->extint=detfeed_extint) then 
                                     {
                                         if(detfeed_nptr2->pinloc!=detfeed_pinloc) then 
                                         {
                                             return<==1 and RValue:=4;
                                             skip
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     }
                                     else
                                     {
                                         skip
                                     }
                                     
                                 }
                                 else
                                 {
                                     if(detfeed_nptr2->pinloc>0) then 
                                     {
                                         detfeed_pinup:=1
                                     }
                                     else
                                     {
                                         detfeed_pindown:=1
                                     }
                                 };
                                 if(return=0)  then
                                 {
                                     detfeed_nptr2:=detfeed_nptr2->nterm
                                 }
                                 else
                                 {
                                     skip
                                 }
                             }
                             else
                             {
                                 skip
                             }
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     continue<==0 and skip;
                     if(return=0)   then 
                     {
                         detfeed_nptr:=detfeed_nptr->nterm
                     }
                     else
                     {
                         skip
                     }
                 }
                 else
                 {
                     skip
                 }
             }
             else
             {
                 skip
             }
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     if(return=0)   then 
     {
         if(detfeed_pinup=1 AND detfeed_pindown=0) then 
         {
             return<==1 and RValue:=1;
             skip
         }
         else
         {
             if(detfeed_pinup=0 AND detfeed_pindown=1) then 
             {
                 return<==1 and RValue:=2;
                 skip
             }
             else
             {
                 if(detfeed_pinup=1 AND detfeed_pindown=1) then 
                 {
                     return<==1 and RValue:=3;
                     skip
                 }
                 else
                 {
                     return<==1 and RValue:=0;
                     skip
                 }
             }
         }
     }
     else
     {
         skip
     }
     )
     }; 
  function findrchk (  )
 {
     frame(findrchk_segptr,findrchk_ptr1,findrchk_ptr2,findrchk_bptr,findrchk_fptr,findrchk_sptr,findrchk_eptr,findrchk_ptr,findrchk_gdptr,findrchk_chan,findrchk_segment,findrchk_pin1,findrchk_pin2,findrchk_x1,findrchk_x2,findrchk_net,findrchk_Flag,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     segbox* findrchk_segptr and skip;
     changrdbox* findrchk_ptr1,*findrchk_ptr2,*findrchk_bptr,*findrchk_fptr,*findrchk_sptr,*findrchk_eptr,*findrchk_ptr,*findrchk_gdptr and skip;
     int findrchk_chan,findrchk_segment and skip;
     int findrchk_pin1,findrchk_pin2,findrchk_x1,findrchk_x2 and skip;
     int findrchk_net,findrchk_Flag and skip;
     findrchk_chan:=1;
     
     while(findrchk_chan<=numChans)
     {
         findrchk_gdptr:=Begin[findrchk_chan];
         
         while(findrchk_gdptr!=NULL)
         {
             findrchk_gdptr->ntracks:=0;
             findrchk_gdptr->nSegType:=0;
             findrchk_gdptr:=findrchk_gdptr->nnextgrd
             
         };
         findrchk_chan:=findrchk_chan+1
         
     };
     continue<==0 and skip;
     findrchk_segment:=1;
     
     while(findrchk_segment<=numSegs)
     {
          continue<==0 and skip;
         if(aNetSeg[findrchk_segment].key!=0) then 
         {
             aNetSeg[findrchk_segment].current:=aNetSeg[aNetSeg[findrchk_segment].key].current
             
         }
         else 
         {
              skip 
         };
         if(aNetSeg[findrchk_segment].current=0) then 
         {
             findrchk_segptr:=aNetSeg[findrchk_segment].top
             
         }
         else
         {
             findrchk_segptr:=aNetSeg[findrchk_segment].bot
         };
         findrchk_pin1:=findrchk_segptr->pin1;
         findrchk_pin2:=findrchk_segptr->pin2;
         if(findrchk_pin1>maxterm AND findrchk_pin2>maxterm) then 
         {
             continue<==1 and skip;
              findrchk_segment:=findrchk_segment+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             findrchk_ptr1:=findrchk_segptr->pin1ptr;
             findrchk_ptr2:=findrchk_segptr->pin2ptr;
             findrchk_x1:=findrchk_ptr1->netptr->xpos;
             findrchk_x2:=findrchk_ptr2->netptr->xpos;
             if(findrchk_x1=findrchk_x2) then 
             {
                 continue<==1 and skip;
                  findrchk_segment:=findrchk_segment+1
             }
             else 
             {
                  skip 
             };
             if(continue=0)   then 
             {
                 findrchk_net:=aNetSeg[findrchk_segment].net;
                 if(findrchk_ptr1->nSegType>=0) then 
                 {
                     findrchk_Flag:=0;
                     findrchk_bptr:=findrchk_ptr1;
                     break$<==0 and skip;
                     while( break$=0 AND  findrchk_bptr->nprevgrd!=NULL AND findrchk_bptr->nprevgrd->netptr->xpos=findrchk_x1)
                     {
                         if(findrchk_net=tearray[findrchk_bptr->nprevgrd->netptr->terminal]->net AND findrchk_bptr->nprevgrd->nSegType<0) then 
                         {
                             findrchk_Flag:=1;
                             findrchk_sptr:=findrchk_ptr1->nnextgrd;
                             while(findrchk_sptr->netptr->xpos=findrchk_x1)
                             {
                                 findrchk_sptr:=findrchk_sptr->nnextgrd
                             };
                             break$<==1 and skip
                          }
                         else
                         {
                             findrchk_bptr:=findrchk_bptr->nprevgrd
                         }
                     };
                     break$<==0 and skip;
                     if(!findrchk_Flag) then 
                     {
                         findrchk_sptr:=findrchk_ptr1->nnextgrd;
                         while(findrchk_sptr->netptr->xpos=findrchk_x1)
                         {
                             if(findrchk_net=tearray[findrchk_sptr->netptr->terminal]->net AND findrchk_sptr->nSegType<0) then 
                             {
                                 findrchk_Flag:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             findrchk_sptr:=findrchk_sptr->nnextgrd
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(!findrchk_Flag) then 
                     {
                         findrchk_sptr:=findrchk_bptr
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else
                 {
                     findrchk_sptr:=findrchk_ptr1->nnextgrd;
                     while(findrchk_sptr->netptr->xpos=findrchk_x1)
                     {
                         findrchk_sptr:=findrchk_sptr->nnextgrd
                     }
                 };
                 if(findrchk_ptr2->nSegType<=0) then 
                 {
                     findrchk_Flag:=0;
                     findrchk_fptr:=findrchk_ptr2;
                     break$<==0 and skip;
                     while( break$=0 AND  findrchk_fptr->nnextgrd!=NULL AND findrchk_fptr->nnextgrd->netptr->xpos=findrchk_x2)
                     {
                         if(findrchk_net=tearray[findrchk_fptr->nnextgrd->netptr->terminal]->net AND findrchk_fptr->nnextgrd->nSegType>0) then 
                         {
                             findrchk_Flag:=1;
                             findrchk_eptr:=findrchk_ptr2->nprevgrd;
                             while(findrchk_eptr->netptr->xpos=findrchk_x2)
                             {
                                 findrchk_eptr:=findrchk_eptr->nprevgrd
                             };
                             break$<==1 and skip
                          }
                         else
                         {
                             findrchk_fptr:=findrchk_fptr->nnextgrd
                         }
                     };
                     break$<==0 and skip;
                     if(!findrchk_Flag) then 
                     {
                         findrchk_eptr:=findrchk_ptr2->nprevgrd;
                         while(findrchk_eptr->netptr->xpos=findrchk_x2)
                         {
                             if(findrchk_net=tearray[findrchk_eptr->netptr->terminal]->net AND findrchk_eptr->nSegType>0) then 
                             {
                                 findrchk_Flag:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             findrchk_eptr:=findrchk_eptr->nprevgrd
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(!findrchk_Flag) then 
                     {
                         findrchk_eptr:=findrchk_fptr
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else
                 {
                     findrchk_eptr:=findrchk_ptr2->nprevgrd;
                     while(findrchk_eptr->netptr->xpos=findrchk_x2)
                     {
                         findrchk_eptr:=findrchk_eptr->nprevgrd
                     }
                 };
                 findrchk_eptr:=findrchk_eptr->nnextgrd;
                 findrchk_ptr:=findrchk_sptr;
                 
                 while(findrchk_ptr!=findrchk_eptr)
                 {
                     (findrchk_ptr->ntracks):=(findrchk_ptr->ntracks)+1;
                     findrchk_ptr:=findrchk_ptr->nnextgrd
                     
                 };
                 if(findrchk_pin1<=maxterm) then 
                 {
                     findrchk_ptr1->nSegType:=findrchk_ptr1->nSegType+1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(findrchk_pin2<=maxterm) then 
                 {
                     findrchk_ptr2->nSegType:=findrchk_ptr2->nSegType+-1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 findrchk_segment:=findrchk_segment+1
             }
             else
             {
                 skip
             }
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     if(uneven_cell_height) then 
     {
         reset_ntrack(RValue)
         
     }
     else 
     {
          skip 
     };
     findrchk_chan:=1;
     
     while( return=0 AND   return=0 AND  findrchk_chan<=numChans)
     {
         findrchk_gdptr:=Begin[findrchk_chan];
         
         while( return=0 AND  findrchk_gdptr!=NULL)
         {
             if(findrchk_gdptr->tracks!=findrchk_gdptr->ntracks) then 
             {
                 debug(findrchk_chan,findrchk_gdptr,RValue);
                  return<==1 and skip
                 
             }
             else 
             {
                  skip 
             };
             if(return=0)   then 
             {
                 findrchk_gdptr:=findrchk_gdptr->nnextgrd
             }
             else
             {
                 skip
             }
             
         };
         if(return=0)   then 
         {
             findrchk_chan:=findrchk_chan+1
         }
         else
         {
             skip
         }
         
     }
     )
     }; 
  function debug ( int chan,changrdbox* gdptr,int RValue )
 {
     frame(debug_fpb,debug_filename,debug_netptr,debug_i) and ( 
     FILE *debug_fpb and skip;
     char debug_filename[64] and skip;
     netbox* debug_netptr and skip;
     int debug_i and skip;
     sprintf(debug_filename,"%s.debug",cktName,RValue) and skip;
     debug_fpb:=twopen(debug_filename,"w",1,RValue);
     fprintf(debug_fpb," channel = %2d nmaxTrack = %2d maxTrack = %2d\n",chan,nmaxTrack[chan],maxTrack[chan]) and skip;
     fprintf(debug_fpb,"SegType nSegType track ntrack  pin xpos newx cell  net\n") and skip;
     debug_i:=5;
     
     while(debug_i>=0)
     {
         if(gdptr->prevgrd!=NULL) then 
         {
             gdptr:=gdptr->prevgrd
             
         }
         else 
         {
              skip 
         };
         debug_i:=debug_i-1
         
     };
     while(debug_i<=12)
     {
         if(gdptr!=NULL) then 
         {
             debug_netptr:=gdptr->netptr;
             fprintf(debug_fpb,"%7d %8d %5d %6d %4d %4d %4d %4d %4d\n",gdptr->SegType,gdptr->nSegType,gdptr->tracks,gdptr->ntracks,debug_netptr->terminal,debug_netptr->xpos,debug_netptr->newx,debug_netptr->cell,tearray[debug_netptr->terminal]->net) and skip;
             gdptr:=gdptr->nextgrd
             
         }
         else 
         {
              skip 
         };
         debug_i:=debug_i+1
         
     }
     )
     }; 
  function reset_ntrack ( int RValue )
 {
     frame(reset_ntrack_cellptr,reset_ntrack_tileptr,reset_ntrack_termptr,reset_ntrack_cell,reset_ntrack_pin,reset_ntrack_pinloc,reset_ntrack_row,reset_ntrack_top,reset_ntrack_bottom) and ( 
     cellbox* reset_ntrack_cellptr and skip;
     tilebox* reset_ntrack_tileptr and skip;
     termbox* reset_ntrack_termptr and skip;
     int reset_ntrack_cell,reset_ntrack_pin,reset_ntrack_pinloc,reset_ntrack_row,reset_ntrack_top,reset_ntrack_bottom and skip;
     reset_ntrack_cell:=1;
     
     while(reset_ntrack_cell<=numcells)
     {
         reset_ntrack_cellptr:=carray[reset_ntrack_cell];
         reset_ntrack_tileptr:=reset_ntrack_cellptr->tileptr;
         reset_ntrack_top:=reset_ntrack_tileptr->top;
         reset_ntrack_bottom:=-reset_ntrack_tileptr->bottom;
         reset_ntrack_row:=reset_ntrack_cellptr->cblock;
         reset_ntrack_termptr:=reset_ntrack_tileptr->termsptr;
         
         while(reset_ntrack_termptr!=NULL)
         {
             reset_ntrack_pin:=reset_ntrack_termptr->cellterm;
             reset_ntrack_pinloc:=tearray[reset_ntrack_pin]->pinloc;
             if(reset_ntrack_pinloc=1) then 
             {
                 Tgrid[reset_ntrack_pin]->up->ntracks:=Tgrid[reset_ntrack_pin]->up->ntracks+(reset_ntrack_top+facing_cellheight(reset_ntrack_pin,reset_ntrack_row,1,1,RValue))/ track_spacing
                 
             }
             else
             {
                 if(reset_ntrack_pinloc=-1) then 
                 {
                     Tgrid[reset_ntrack_pin]->up->ntracks:=Tgrid[reset_ntrack_pin]->up->ntracks+(reset_ntrack_bottom+facing_cellheight(reset_ntrack_pin,reset_ntrack_row,-1,1,RValue))/ track_spacing
                 }
                 else
                 {
                     Tgrid[reset_ntrack_pin]->up->ntracks:=Tgrid[reset_ntrack_pin]->up->ntracks+(reset_ntrack_top+facing_cellheight(reset_ntrack_pin,reset_ntrack_row,1,1,RValue))/ track_spacing;
                     Tgrid[reset_ntrack_pin]->down->ntracks:=Tgrid[reset_ntrack_pin]->down->ntracks+(reset_ntrack_bottom+facing_cellheight(reset_ntrack_pin,reset_ntrack_row,-1,1,RValue))/ track_spacing
                 }
             };
             reset_ntrack_termptr:=reset_ntrack_termptr->nextterm
             
         };
         reset_ntrack_cell:=reset_ntrack_cell+1
         
     };
     while(reset_ntrack_cell<=numcells+numterms)
     {
         reset_ntrack_cellptr:=carray[reset_ntrack_cell];
         reset_ntrack_tileptr:=reset_ntrack_cellptr->tileptr;
         reset_ntrack_termptr:=reset_ntrack_tileptr->termsptr;
         
         while(reset_ntrack_termptr!=NULL)
         {
             reset_ntrack_pin:=reset_ntrack_termptr->cellterm;
             reset_ntrack_row:=tearray[reset_ntrack_pin]->row;
             Tgrid[reset_ntrack_pin]->up->ntracks:=Tgrid[reset_ntrack_pin]->up->ntracks+facing_cellheight(reset_ntrack_pin,reset_ntrack_row,0,1,RValue)/ track_spacing;
             reset_ntrack_termptr:=reset_ntrack_termptr->nextterm
             
         };
         reset_ntrack_cell:=reset_ntrack_cell+1
         
     }
     )
     }; 
  function findrcost (  )
 {
     frame(findrcost_segptr,findrcost_ptr1,findrcost_ptr2,findrcost_bptr,findrcost_fptr,findrcost_sptr,findrcost_eptr,findrcost_ptr,findrcost_gdptr,findrcost_denptr,findrcost_chan,findrcost_segment,findrcost_track,findrcost_max_trk,findrcost_pin1,findrcost_pin2,findrcost_x1,findrcost_x2,findrcost_net,findrcost_Flag,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     segbox* findrcost_segptr and skip;
     changrdbox* findrcost_ptr1,*findrcost_ptr2,*findrcost_bptr,*findrcost_fptr,*findrcost_sptr,*findrcost_eptr,*findrcost_ptr,*findrcost_gdptr and skip;
     densitybox* findrcost_denptr and skip;
     int findrcost_chan,findrcost_segment and skip;
     int findrcost_track,findrcost_max_trk and skip;
     int findrcost_pin1,findrcost_pin2,findrcost_x1,findrcost_x2 and skip;
     int findrcost_net,findrcost_Flag and skip;
     continue<==0 and skip;
     findrcost_segment:=1;
     
     while(findrcost_segment<=numSegs)
     {
          continue<==0 and skip;
         if(aNetSeg[findrcost_segment].current=0) then 
         {
             findrcost_segptr:=aNetSeg[findrcost_segment].top
             
         }
         else
         {
             findrcost_segptr:=aNetSeg[findrcost_segment].bot
         };
         findrcost_pin1:=findrcost_segptr->pin1;
         findrcost_pin2:=findrcost_segptr->pin2;
         findrcost_ptr1:=findrcost_segptr->pin1ptr;
         findrcost_ptr2:=findrcost_segptr->pin2ptr;
         findrcost_x1:=findrcost_ptr1->netptr->xpos;
         findrcost_x2:=findrcost_ptr2->netptr->xpos;
         if(findrcost_x1=findrcost_x2) then 
         {
             continue<==1 and skip;
              findrcost_segment:=findrcost_segment+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             findrcost_net:=aNetSeg[findrcost_segment].net;
             if(findrcost_ptr1->SegType>=0) then 
             {
                 findrcost_Flag:=0;
                 findrcost_bptr:=findrcost_ptr1;
                 break$<==0 and skip;
                 while( break$=0 AND  findrcost_bptr->prevgrd!=NULL AND findrcost_bptr->prevgrd->netptr->xpos=findrcost_x1)
                 {
                     if(findrcost_net=tearray[findrcost_bptr->prevgrd->netptr->terminal]->net AND findrcost_bptr->prevgrd->SegType<0) then 
                     {
                         findrcost_Flag:=1;
                         findrcost_sptr:=findrcost_ptr1->nextgrd;
                         while(findrcost_sptr->netptr->xpos=findrcost_x1)
                         {
                             findrcost_sptr:=findrcost_sptr->nextgrd
                         };
                         break$<==1 and skip
                      }
                     else
                     {
                         findrcost_bptr:=findrcost_bptr->prevgrd
                     }
                 };
                 break$<==0 and skip;
                 if(!findrcost_Flag) then 
                 {
                     findrcost_sptr:=findrcost_ptr1->nextgrd;
                     while(findrcost_sptr->netptr->xpos=findrcost_x1)
                     {
                         if(findrcost_net=tearray[findrcost_sptr->netptr->terminal]->net AND findrcost_sptr->SegType<0) then 
                         {
                             findrcost_Flag:=1
                             
                         }
                         else 
                         {
                              skip 
                         };
                         findrcost_sptr:=findrcost_sptr->nextgrd
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(!findrcost_Flag) then 
                 {
                     findrcost_sptr:=findrcost_bptr
                     
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else
             {
                 findrcost_sptr:=findrcost_ptr1->nextgrd;
                 while(findrcost_sptr->netptr->xpos=findrcost_x1)
                 {
                     findrcost_sptr:=findrcost_sptr->nextgrd
                 }
             };
             if(findrcost_ptr2->SegType<=0) then 
             {
                 findrcost_Flag:=0;
                 findrcost_fptr:=findrcost_ptr2;
                 break$<==0 and skip;
                 while( break$=0 AND  findrcost_fptr->nextgrd!=NULL AND findrcost_fptr->nextgrd->netptr->xpos=findrcost_x2)
                 {
                     if(findrcost_net=tearray[findrcost_fptr->nextgrd->netptr->terminal]->net AND findrcost_fptr->nextgrd->SegType>0) then 
                     {
                         findrcost_Flag:=1;
                         findrcost_eptr:=findrcost_ptr2->prevgrd;
                         while(findrcost_eptr->netptr->xpos=findrcost_x2)
                         {
                             findrcost_eptr:=findrcost_eptr->prevgrd
                         };
                         break$<==1 and skip
                      }
                     else
                     {
                         findrcost_fptr:=findrcost_fptr->nextgrd
                     }
                 };
                 break$<==0 and skip;
                 if(!findrcost_Flag) then 
                 {
                     findrcost_eptr:=findrcost_ptr2->prevgrd;
                     while(findrcost_eptr->netptr->xpos=findrcost_x2)
                     {
                         if(findrcost_net=tearray[findrcost_eptr->netptr->terminal]->net AND findrcost_eptr->SegType>0) then 
                         {
                             findrcost_Flag:=1
                             
                         }
                         else 
                         {
                              skip 
                         };
                         findrcost_eptr:=findrcost_eptr->prevgrd
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(!findrcost_Flag) then 
                 {
                     findrcost_eptr:=findrcost_fptr
                     
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else
             {
                 findrcost_eptr:=findrcost_ptr2->prevgrd;
                 while(findrcost_eptr->netptr->xpos=findrcost_x2)
                 {
                     findrcost_eptr:=findrcost_eptr->prevgrd
                 }
             };
             findrcost_eptr:=findrcost_eptr->nextgrd;
             findrcost_ptr:=findrcost_sptr;
             
             while(findrcost_ptr!=findrcost_eptr)
             {
                 (findrcost_ptr->tracks):=(findrcost_ptr->tracks)+1;
                 findrcost_ptr:=findrcost_ptr->nextgrd
                 
             };
             if(findrcost_pin1<=maxterm) then 
             {
                 findrcost_ptr1->SegType:=findrcost_ptr1->SegType+1
                 
             }
             else 
             {
                  skip 
             };
             if(findrcost_pin2<=maxterm) then 
             {
                 findrcost_ptr2->SegType:=findrcost_ptr2->SegType+-1
                 
             }
             else 
             {
                  skip 
             };
             findrcost_segment:=findrcost_segment+1
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     DboxHead:= safe_calloc(4,numChans+1,RValue);
     Densebox:= safe_calloc(4,numChans+1,RValue);
     maxTrack:=(int *)safe_malloc((numChans+1)*sizeof(int),RValue);
     nmaxTrack:=(int *)safe_malloc((numChans+1)*sizeof(int),RValue);
     max_tdensity:=0;
     tracks:=0;
     if(uneven_cell_height) then 
     {
         set_cedgebin(RValue);
         reset_track(RValue)
         
     }
     else 
     {
          skip 
     };
     findrcost_chan:=1;
     
     while(findrcost_chan<=numChans)
     {
         findrcost_max_trk:=0;
         findrcost_gdptr:=Begin[findrcost_chan];
         
         while(findrcost_gdptr!=NULL)
         {
             if(findrcost_gdptr->tracks>findrcost_max_trk) then 
             {
                 findrcost_max_trk:=findrcost_gdptr->tracks
                 
             }
             else 
             {
                  skip 
             };
             findrcost_gdptr:=findrcost_gdptr->nextgrd
             
         };
         maxTrack[findrcost_chan]:=findrcost_max_trk;
         if(findrcost_max_trk>max_tdensity) then 
         {
             max_tdensity:=findrcost_max_trk
             
         }
         else 
         {
              skip 
         };
         tracks:=tracks+findrcost_max_trk;
         findrcost_chan:=findrcost_chan+1
         
     };
     findrcost_chan:=1;
     
     while(findrcost_chan<=numChans)
     {
         DboxHead[findrcost_chan]:=(densitybox* *)safe_calloc(sizeof(densitybox*),max_tdensity+101,RValue);
         Densebox[findrcost_chan]:=(densitybox* *)safe_calloc(sizeof(densitybox*),max_tdensity+101,RValue);
         findrcost_track:=0;
         
         while(findrcost_track<=max_tdensity+100)
         {
             DboxHead[findrcost_chan,findrcost_track]:=(densitybox*)safe_calloc(sizeof(densitybox),1,RValue);
             findrcost_track:=findrcost_track+1
             
         };
         findrcost_gdptr:=Begin[findrcost_chan];
         
         while(findrcost_gdptr!=NULL)
         {
             findrcost_track:=findrcost_gdptr->tracks;
             if(DboxHead[findrcost_chan,findrcost_track]->next$=NULL) then 
             {
                 Densebox[findrcost_chan,findrcost_track]<==(densitybox*)safe_calloc(sizeof(densitybox),1,RValue) and DboxHead[findrcost_chan,findrcost_track]->next$<==Densebox[findrcost_chan,findrcost_track] and skip;
                 Densebox[findrcost_chan,findrcost_track]->back:=DboxHead[findrcost_chan,findrcost_track];
                 Densebox[findrcost_chan,findrcost_track]->grdptr:=findrcost_gdptr;
                 findrcost_gdptr->dptr:=Densebox[findrcost_chan,findrcost_track]
                 
             }
             else
             {
                 Densebox[findrcost_chan,findrcost_track]->next$<==(densitybox*)safe_calloc(sizeof(densitybox),1,RValue) and findrcost_denptr<==Densebox[findrcost_chan,findrcost_track]->next$ and skip;
                 findrcost_denptr->back:=Densebox[findrcost_chan,findrcost_track];
                 findrcost_denptr->grdptr:=findrcost_gdptr;
                 findrcost_gdptr->dptr:=findrcost_denptr;
                 Densebox[findrcost_chan,findrcost_track]:=findrcost_denptr
             };
             findrcost_gdptr:=findrcost_gdptr->nextgrd
             
         };
         findrcost_chan:=findrcost_chan+1
         
     }
     )
     }; 
  function set_cedgebin ( int RValue )
 {
     frame(set_cedgebin_cellptr,set_cedgebin_channel,set_cedgebin_row,set_cedgebin_bin,set_cedgebin_bin_rite_edge,set_cedgebin_cleft,set_cedgebin_crite,set_cedgebin_most_left,set_cedgebin_most_rite,set_cedgebin_rite,set_cedgebin_i) and ( 
     cellbox* set_cedgebin_cellptr and skip;
     int set_cedgebin_channel,set_cedgebin_row,set_cedgebin_bin,set_cedgebin_bin_rite_edge,set_cedgebin_cleft,set_cedgebin_crite and skip;
     int set_cedgebin_most_left,set_cedgebin_most_rite,set_cedgebin_rite,set_cedgebin_i and skip;
     cedgebin:=(int **)safe_malloc((numChans+1)*sizeof(int *),RValue);
     cedge_binwidth:=(int)(2.0*mean_width);
     set_cedgebin_cellptr:=carray[pairArray[1,pairArray[1,0]]];
     set_cedgebin_most_rite:=set_cedgebin_cellptr->cxcenter+set_cedgebin_cellptr->tileptr->right;
     set_cedgebin_row:=2;
     
     while(set_cedgebin_row<=numRows)
     {
         set_cedgebin_cellptr:=carray[pairArray[set_cedgebin_row,pairArray[set_cedgebin_row,0]]];
         set_cedgebin_rite:=set_cedgebin_cellptr->cxcenter+set_cedgebin_cellptr->tileptr->right;
         if(set_cedgebin_rite>set_cedgebin_most_rite) then 
         {
             set_cedgebin_most_rite:=set_cedgebin_rite
             
         }
         else 
         {
              skip 
         };
         set_cedgebin_row:=set_cedgebin_row+1
         
     };
     num_edgebin:=(set_cedgebin_most_rite-blkleft)/ cedge_binwidth+1;
     set_cedgebin_channel:=1;
     
     while(set_cedgebin_channel<=numChans)
     {
         cedgebin[set_cedgebin_channel]:=(int *)safe_malloc((num_edgebin+1)*sizeof(int),RValue);
         set_cedgebin_channel:=set_cedgebin_channel+1
         
     };
     set_cedgebin_row:=1;
     
     while(set_cedgebin_row<=numRows)
     {
         set_cedgebin_cellptr:=carray[pairArray[set_cedgebin_row,1]];
         set_cedgebin_most_left:=set_cedgebin_cellptr->cxcenter+set_cedgebin_cellptr->tileptr->left;
         set_cedgebin_bin_rite_edge:=set_cedgebin_most_left+cedge_binwidth;
         cedgebin[set_cedgebin_row,1]:=1;
         set_cedgebin_bin:=1;
         set_cedgebin_i:=1;
         
         while(set_cedgebin_i<=pairArray[set_cedgebin_row,0])
         {
             set_cedgebin_cellptr:=carray[pairArray[set_cedgebin_row,set_cedgebin_i]];
             set_cedgebin_crite:=set_cedgebin_cellptr->cxcenter+set_cedgebin_cellptr->tileptr->right;
             if(set_cedgebin_bin_rite_edge<set_cedgebin_crite) then 
             {
                 while(set_cedgebin_bin_rite_edge<=set_cedgebin_crite)
                 {
                     cedgebin[set_cedgebin_row,(set_cedgebin_bin+1)]:=set_cedgebin_i;
                     set_cedgebin_bin:=set_cedgebin_bin+1;
                     set_cedgebin_bin_rite_edge:=set_cedgebin_bin_rite_edge+cedge_binwidth
                 }
                 
             }
             else 
             {
                  skip 
             };
             set_cedgebin_i:=set_cedgebin_i+1
             
         };
         set_cedgebin_bin:=set_cedgebin_bin+1;
         
         while(set_cedgebin_bin<=num_edgebin)
         {
             cedgebin[set_cedgebin_row,set_cedgebin_bin]:=0;
             set_cedgebin_bin:=set_cedgebin_bin+1
             
         };
         set_cedgebin_row:=set_cedgebin_row+1
         
     }
     )
     }; 
  function reset_track ( int RValue )
 {
     frame(reset_track_cellptr,reset_track_tileptr,reset_track_termptr,reset_track_cell,reset_track_pin,reset_track_pinloc,reset_track_row,reset_track_top,reset_track_bottom) and ( 
     cellbox* reset_track_cellptr and skip;
     tilebox* reset_track_tileptr and skip;
     termbox* reset_track_termptr and skip;
     int reset_track_cell,reset_track_pin,reset_track_pinloc,reset_track_row,reset_track_top,reset_track_bottom and skip;
     reset_track_cell:=1;
     
     while(reset_track_cell<=numcells)
     {
         reset_track_cellptr:=carray[reset_track_cell];
         reset_track_tileptr:=reset_track_cellptr->tileptr;
         reset_track_row:=reset_track_cellptr->cblock;
         reset_track_top:=reset_track_tileptr->top;
         reset_track_bottom:=-reset_track_tileptr->bottom;
         reset_track_termptr:=reset_track_tileptr->termsptr;
         
         while(reset_track_termptr!=NULL)
         {
             reset_track_pin:=reset_track_termptr->cellterm;
             reset_track_pinloc:=tearray[reset_track_pin]->pinloc;
             if(reset_track_pinloc=1) then 
             {
                 Tgrid[reset_track_pin]->up->tracks:=Tgrid[reset_track_pin]->up->tracks+(reset_track_top+facing_cellheight(reset_track_pin,reset_track_row,1,1,RValue))/ track_spacing
                 
             }
             else
             {
                 if(reset_track_pinloc=-1) then 
                 {
                     Tgrid[reset_track_pin]->up->tracks:=Tgrid[reset_track_pin]->up->tracks+(reset_track_bottom+facing_cellheight(reset_track_pin,reset_track_row,-1,1,RValue))/ track_spacing
                 }
                 else
                 {
                     Tgrid[reset_track_pin]->up->tracks:=Tgrid[reset_track_pin]->up->tracks+(reset_track_top+facing_cellheight(reset_track_pin,reset_track_row,1,1,RValue))/ track_spacing;
                     Tgrid[reset_track_pin]->down->tracks:=Tgrid[reset_track_pin]->down->tracks+(reset_track_bottom+facing_cellheight(reset_track_pin,reset_track_row,-1,1,RValue))/ track_spacing
                 }
             };
             reset_track_termptr:=reset_track_termptr->nextterm
             
         };
         reset_track_cell:=reset_track_cell+1
         
     };
     while(reset_track_cell<=numcells+numterms)
     {
         reset_track_cellptr:=carray[reset_track_cell];
         reset_track_tileptr:=reset_track_cellptr->tileptr;
         reset_track_termptr:=reset_track_tileptr->termsptr;
         
         while(reset_track_termptr!=NULL)
         {
             reset_track_pin:=reset_track_termptr->cellterm;
             reset_track_row:=tearray[reset_track_pin]->row;
             Tgrid[reset_track_pin]->up->tracks:=Tgrid[reset_track_pin]->up->tracks+facing_cellheight(reset_track_pin,reset_track_row,0,1,RValue)/ track_spacing;
             reset_track_termptr:=reset_track_termptr->nextterm
             
         };
         reset_track_cell:=reset_track_cell+1
         
     }
     )
     }; 
  function facing_cellheight ( int pin,int row,int pinloc,int status,int RValue )
 {
     frame(facing_cellheight_cellptr,facing_cellheight_bin,facing_cellheight_i,facing_cellheight_Aray,facing_cellheight_most_left,facing_cellheight_most_rite,facing_cellheight_nrow,facing_cellheight_pin_x,facing_cellheight_crite,return) and ( 
     int return<==0 and skip;
     cellbox* facing_cellheight_cellptr and skip;
     int facing_cellheight_bin,facing_cellheight_i,*facing_cellheight_Aray,facing_cellheight_most_left,facing_cellheight_most_rite and skip;
     int facing_cellheight_nrow,facing_cellheight_pin_x,facing_cellheight_crite and skip;
     if(1<=row AND row<=numRows) then 
     {
         facing_cellheight_nrow:=row+pinloc;
         if(facing_cellheight_nrow=0 OR facing_cellheight_nrow=numChans OR pinloc=0) then 
         {
             return<==1 and RValue:=0;
             skip
             
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         if(row=0) then 
         {
             facing_cellheight_nrow:=1
         }
         else
         {
             facing_cellheight_nrow:=numRows
         }
     };
     if(return=0)  then
     {
         facing_cellheight_Aray:=pairArray[facing_cellheight_nrow];
         if(status=0) then 
         {
             facing_cellheight_pin_x:=tearray[pin]->newx
             
         }
         else
         {
             facing_cellheight_pin_x:=tearray[pin]->xpos
         };
         facing_cellheight_cellptr:=carray[facing_cellheight_Aray[1]];
         facing_cellheight_most_left:=facing_cellheight_cellptr->cxcenter+facing_cellheight_cellptr->tileptr->left;
         facing_cellheight_cellptr:=carray[facing_cellheight_Aray[facing_cellheight_Aray[0]]];
         facing_cellheight_most_rite:=facing_cellheight_cellptr->cxcenter+facing_cellheight_cellptr->tileptr->right;
         if(facing_cellheight_pin_x<facing_cellheight_most_left OR facing_cellheight_pin_x>facing_cellheight_most_rite) then 
         {
             return<==1 and RValue:=0;
             skip
             
         }
         else 
         {
              skip 
         };
         if(return=0)   then 
         {
             facing_cellheight_bin:=(facing_cellheight_pin_x-facing_cellheight_most_left)/ cedge_binwidth+1;
             facing_cellheight_i:=cedgebin[facing_cellheight_nrow,facing_cellheight_bin] ;
             if((facing_cellheight_i)=0) then 
             {
                 return<==1 and RValue:=0;
                 skip
                 
             }
             else 
             {
                  skip 
             };
             if(return=0)   then 
             {
                 facing_cellheight_cellptr:=carray[facing_cellheight_Aray[facing_cellheight_i]];
                 if(((facing_cellheight_cellptr->tileptr->left+facing_cellheight_cellptr->cxcenter)=facing_cellheight_pin_x) AND (facing_cellheight_bin>=2)) then 
                 {
                     if(carray[facing_cellheight_Aray[facing_cellheight_i-1]]->cheight>facing_cellheight_cellptr->cheight) then 
                     {
                         facing_cellheight_cellptr:=carray[facing_cellheight_Aray[(facing_cellheight_i-1)]];
                         facing_cellheight_i:=facing_cellheight_i-1
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else
                 {
                     facing_cellheight_crite:=facing_cellheight_cellptr->tileptr->right+facing_cellheight_cellptr->cxcenter;
                     while(facing_cellheight_crite<facing_cellheight_pin_x AND facing_cellheight_i<facing_cellheight_Aray[0])
                     {
                         facing_cellheight_cellptr:=carray[facing_cellheight_Aray[(facing_cellheight_i+1)]];
                         facing_cellheight_i:=facing_cellheight_i+1;
                         facing_cellheight_crite:=facing_cellheight_crite+facing_cellheight_cellptr->clength
                     };
                     if(facing_cellheight_crite=facing_cellheight_pin_x AND facing_cellheight_i!=facing_cellheight_Aray[0]) then 
                     {
                         if(carray[facing_cellheight_Aray[facing_cellheight_i+1]]->cheight>facing_cellheight_cellptr->cheight) then 
                         {
                             facing_cellheight_cellptr:=carray[facing_cellheight_Aray[facing_cellheight_i+1]]
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     }
                 };
                 if(1<=row AND row<=numRows) then 
                 {
                     if(pinloc=1) then 
                     {
                         return<==1 and RValue:=(-facing_cellheight_cellptr->tileptr->bottom);
                         skip
                     }
                     else
                     {
                         return<==1 and RValue:=(facing_cellheight_cellptr->tileptr->top);
                         skip
                     }
                 }
                 else
                 {
                     if(row=0) then 
                     {
                         return<==1 and RValue:=(-facing_cellheight_cellptr->tileptr->bottom);
                         skip
                     }
                     else
                     {
                         return<==1 and RValue:=(facing_cellheight_cellptr->tileptr->top);
                         skip
                     }
                 }
             }
             else
             {
                 skip
             }
         }
         else
         {
             skip
         }
     }
     else
     {
         skip
     }
     )
     }; 
      int *add_to_row and skip;
     int *length_of_row and skip;
 function findunlap ( int before_feeds )
 {
     frame(findunlap_cellptr,findunlap_ptr,findunlap_tileptr,findunlap_term,findunlap_dimptr,findunlap_termptr,findunlap_netptr,findunlap_cost,findunlap_corient,findunlap_block,findunlap_cell,findunlap_bin,findunlap_i,findunlap_n,findunlap_bigblkx,findunlap_net,findunlap_x,findunlap_y,findunlap_blklen,findunlap_row,return) and ( 
     int return<==0 and skip;
     cellbox* findunlap_cellptr,*findunlap_ptr and skip;
     tilebox* findunlap_tileptr and skip;
     termbox* findunlap_term and skip;
     dimbox* findunlap_dimptr and skip;
     netbox* findunlap_termptr,*findunlap_netptr and skip;
     int findunlap_cost,findunlap_corient and skip;
     int findunlap_block,findunlap_cell,findunlap_bin and skip;
     int findunlap_i,findunlap_n and skip;
     int findunlap_bigblkx and skip;
     int findunlap_net,findunlap_x,findunlap_y,*findunlap_blklen,findunlap_row and skip;
     findunlap_blklen:=(int *)safe_malloc((numblock+1)*sizeof(int),RValue);
     findunlap_i:=0;
     
     while(findunlap_i<=numblock)
     {
         findunlap_blklen[findunlap_i]:=0;
         findunlap_i:=findunlap_i+1
         
     };
     if(before_feeds=1) then 
     {
         unlap(1,RValue)
         
     }
     else
     {
         if(before_feeds=0) then 
         {
             unlap(0,RValue)
             
         }
         else 
         {
              skip 
         }
     };
     if(before_feeds=1) then 
     {
         findunlap_block:=1;
         
         while(findunlap_block<=numblock)
         {
             findunlap_bin:=0;
             
             while(findunlap_bin<=numBins)
             {
                 safe_free(binptr[findunlap_block,findunlap_bin]->cell,RValue);
                 safe_free(binptr[findunlap_block,findunlap_bin],RValue);
                 findunlap_bin:=findunlap_bin+1
                 
             };
             safe_free(binptr[findunlap_block],RValue);
             findunlap_block:=findunlap_block+1
             
         };
         safe_free(binptr,RValue)
         
     }
     else 
     {
          skip 
     };
     findunlap_cell:=1;
     
     while(findunlap_cell<=numcells)
     {
         findunlap_ptr:=carray[findunlap_cell];
         findunlap_corient:=findunlap_ptr->corient;
         findunlap_term:=findunlap_ptr->tileptr->termsptr;
         
         while(findunlap_term!=NULL)
         {
             findunlap_termptr:=tearray[findunlap_term->cellterm];
             findunlap_termptr->xpos:=findunlap_term->txpos[findunlap_corient/ 2]+findunlap_ptr->cxcenter;
             findunlap_termptr->ypos:=findunlap_term->typos[findunlap_corient % 2]+findunlap_ptr->cycenter;
             findunlap_term:=findunlap_term->nextterm
             
         };
         findunlap_cell:=findunlap_cell+1
         
     };
     findunlap_cell:=numcells+1;
     
     while(findunlap_cell<=numcells+numterms)
     {
         findunlap_ptr:=carray[findunlap_cell];
         findunlap_term:=findunlap_ptr->tileptr->termsptr;
         
         while(findunlap_term!=NULL)
         {
             findunlap_termptr:=tearray[findunlap_term->cellterm];
             findunlap_termptr->xpos:=findunlap_term->txpos[1]+findunlap_ptr->cxcenter;
             findunlap_termptr->ypos:=findunlap_term->typos[1]+findunlap_ptr->cycenter;
             findunlap_term:=findunlap_term->nextterm
             
         };
         findunlap_cell:=findunlap_cell+1
         
     };
     findunlap_cost:=0;
     findunlap_net:=1;
     
     while(findunlap_net<=numnets)
     {
         findunlap_dimptr:=netarray[findunlap_net];
         findunlap_netptr:=findunlap_dimptr->netptr ;
         if((findunlap_netptr)!=NULL) then 
         {
             findunlap_dimptr->xmax<==findunlap_netptr->xpos and findunlap_dimptr->xmin<==findunlap_dimptr->xmax and skip;
             findunlap_dimptr->ymax<==findunlap_netptr->ypos and findunlap_dimptr->ymin<==findunlap_dimptr->ymax and skip;
             findunlap_dimptr->Rnum<==1 and findunlap_dimptr->Lnum<==findunlap_dimptr->Rnum and skip;
             findunlap_dimptr->Tnum<==1 and findunlap_dimptr->Bnum<==findunlap_dimptr->Tnum and skip;
             findunlap_netptr:=findunlap_netptr->nterm
             
         }
         else 
         {
              skip 
         };
         findunlap_n:=1;
         while(findunlap_netptr!=NULL)
         {
             findunlap_x:=findunlap_netptr->xpos;
             findunlap_y:=findunlap_netptr->ypos;
             if(findunlap_x<findunlap_dimptr->xmin) then 
             {
                 findunlap_dimptr->xmin:=findunlap_x;
                 findunlap_dimptr->Lnum:=1
                 
             }
             else
             {
                 if(findunlap_x=findunlap_dimptr->xmin) then 
                 {
                     findunlap_dimptr->Lnum:=findunlap_dimptr->Lnum+1;
                     if(findunlap_x=findunlap_dimptr->xmax) then 
                     {
                         findunlap_dimptr->Rnum:=findunlap_dimptr->Rnum+1
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     if(findunlap_x>findunlap_dimptr->xmax) then 
                     {
                         findunlap_dimptr->xmax:=findunlap_x;
                         findunlap_dimptr->Rnum:=1
                     }
                     else
                     {
                         if(findunlap_x=findunlap_dimptr->xmax) then 
                         {
                             findunlap_dimptr->Rnum:=findunlap_dimptr->Rnum+1
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                 }
             };
             if(findunlap_y<findunlap_dimptr->ymin) then 
             {
                 findunlap_dimptr->ymin:=findunlap_y;
                 findunlap_dimptr->Bnum:=1
                 
             }
             else
             {
                 if(findunlap_y=findunlap_dimptr->ymin) then 
                 {
                     findunlap_dimptr->Bnum:=findunlap_dimptr->Bnum+1;
                     if(findunlap_y=findunlap_dimptr->ymax) then 
                     {
                         findunlap_dimptr->Tnum:=findunlap_dimptr->Tnum+1
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     if(findunlap_y>findunlap_dimptr->ymax) then 
                     {
                         findunlap_dimptr->ymax:=findunlap_y;
                         findunlap_dimptr->Tnum:=1
                     }
                     else
                     {
                         if(findunlap_y=findunlap_dimptr->ymax) then 
                         {
                             findunlap_dimptr->Tnum:=findunlap_dimptr->Tnum+1
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                 }
             };
             findunlap_n:=findunlap_n+1;
             findunlap_netptr:=findunlap_netptr->nterm
             
         };
         findunlap_dimptr->numpins:=findunlap_n;
         findunlap_cost:=findunlap_cost+((int)(findunlap_dimptr->Hweight*(float)(findunlap_dimptr->xmax-findunlap_dimptr->xmin)))+((int)(findunlap_dimptr->Vweight*(float)(findunlap_dimptr->ymax-findunlap_dimptr->ymin)));
         findunlap_net:=findunlap_net+1
         
     };
     funccost:=findunlap_cost;
     findunlap_cell:=1;
     
     while(findunlap_cell<=numcells)
     {
         findunlap_cellptr:=carray[findunlap_cell];
         findunlap_tileptr:=findunlap_cellptr->tileptr;
         findunlap_block:=findunlap_cellptr->cblock;
         findunlap_blklen[findunlap_block]:=findunlap_blklen[findunlap_block]+findunlap_tileptr->right-findunlap_tileptr->left;
         findunlap_cell:=findunlap_cell+1
         
     };
     if(before_feeds=1) then 
     {
         length_of_row:=(int *)safe_malloc((numRows+1)*sizeof(int),RValue);
         add_to_row:=(int *)safe_malloc((numRows+1)*sizeof(int),RValue);
         findunlap_row:=1;
         
         while(findunlap_row<=numRows)
         {
             length_of_row[findunlap_row]:=findunlap_blklen[findunlap_row];
             add_to_row[findunlap_row]:=0;
             findunlap_row:=findunlap_row+1
             
         }
         
     }
     else 
     {
          skip 
     };
     if(before_feeds>=0) then 
     {
         findunlap_bigblkx:=0;
         if(before_feeds=1) then 
         {
             fprintf(fpo,"Before Feeds are Added:\n") and skip
             
         }
         else 
         {
              skip 
         };
         fprintf(fpo,"BLOCK      TOTAL CELL LENGTHS      OVER/UNDER TARGET\n") and skip;
         findunlap_i:=1;
         
         while(findunlap_i<=numblock)
         {
             if(findunlap_blklen[findunlap_i]>findunlap_blklen[findunlap_bigblkx]) then 
             {
                 findunlap_bigblkx:=findunlap_i
                 
             }
             else 
             {
                  skip 
             };
             fprintf(fpo,"%3d            %7d                %6d\n",findunlap_i,findunlap_blklen[findunlap_i],(findunlap_blklen[findunlap_i]-barray[findunlap_i]->desire)) and skip;
             findunlap_i:=findunlap_i+1
             
         };
         fprintf(fpo,"\nLONGEST Block is:%d   Its length is:%d\n",findunlap_bigblkx,findunlap_blklen[findunlap_bigblkx]) and skip
         
     }
     else 
     {
          skip 
     };
     safe_free(findunlap_blklen,RValue);
      return<==1 and skip
     )
     }; 
      int **pseudoPins and skip;
     int **pseudoEdge and skip;
     csGroup *groupArray and skip;
     int MPG and skip;
     int ME and skip;
     edgeBox *edgeArray and skip;
     chkBox *checkArray and skip;
     int *key_queue and skip;
     int numEdges,numGroups,numPins and skip;
     int gxstart,gxstop,top_row and skip;
 function twclose (FILE* a )
 {
     fclose(a) and skip
     
 };
 function ABS ( int value,int RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
     return<==1 and RValue:=( if(value>=0) then value else -value);
     skip
     )
     }; 
  function globe (  )
 {
     frame(globe_twfile,globe_netptr,globe_net_ptr,globe_cellptr1,globe_cellptr2,globe_filename,globe_group1,globe_group2,globe_edge,globe_i,globe_pin,globe_net,globe_group,globe_jj,globe_cell,globe_cx,globe_cl,globe_cr,globe_top,globe_extint,globe_block,globe_locX,globe_locY,globe_flag1,globe_flag2,globe_xstart,globe_xstop,globe_found,globe_type1,globe_unequiv,globe_added_an_edge,globe_ue_grp,globe_g1,globe_g2,globe_ei1,globe_ei2,globe_edge2,globe_done,globe_ei,globe_cell1,globe_cell2,globe_a1,globe_b1,globe_a2,globe_b2,globe_edge1,globe_ya,globe_yb,globe_max_group,globe_max_size,globe_size,globe_max_local_group,globe_single_pin1,globe_single_pin2,globe_unequiv1,globe_unequiv2,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     FILE *globe_twfile and skip;
     netbox* globe_netptr,*globe_net_ptr and skip;
     cellbox* globe_cellptr1,*globe_cellptr2 and skip;
     char globe_filename[64] and skip;
     int globe_group1,globe_group2,globe_edge,globe_i,globe_pin,globe_net,globe_group,globe_jj and skip;
     int globe_cell,globe_cx,globe_cl,globe_cr,globe_top,globe_extint,globe_block,globe_locX,globe_locY and skip;
     int globe_flag1,globe_flag2,globe_xstart,globe_xstop and skip;
     int globe_found,globe_type1 and skip;
     int globe_unequiv and skip;
     int globe_added_an_edge,globe_ue_grp,globe_g1,globe_g2,globe_ei1,globe_ei2,globe_edge2,globe_done and skip;
     int globe_ei,globe_cell1,globe_cell2 and skip;
     int globe_a1,globe_b1,globe_a2,globe_b2,globe_edge1,globe_ya,globe_yb and skip;
     int globe_max_group,globe_max_size,globe_size,globe_max_local_group and skip;
     int globe_single_pin1,globe_single_pin2,globe_unequiv1,globe_unequiv2 and skip;
     globe_max_group:=2;
     globe_max_size:=2;
     globe_net:=1;
     
     while(globe_net<=numnets)
     {
         globe_net_ptr:=netarray[globe_net]->netptr;
         globe_max_local_group:=0;
         globe_size:=1;
         globe_extint:=-1;
         while(globe_net_ptr!=NULL)
         {
             if(globe_net_ptr->extint!=globe_extint) then 
             {
                 globe_extint:=globe_net_ptr->extint;
                 globe_max_local_group:=globe_max_local_group+1;
                 if(globe_size>globe_max_size) then 
                 {
                     globe_max_size:=globe_size
                     
                 }
                 else 
                 {
                      skip 
                 };
                 globe_size:=1
                 
             }
             else
             {
                 globe_size:=globe_size+1;
                 if(globe_net_ptr->unequiv!=0) then 
                 {
                     globe_max_local_group:=globe_max_local_group+1
                     
                 }
                 else 
                 {
                      skip 
                 }
             };
             globe_net_ptr:=globe_net_ptr->nterm
             
         };
         if(globe_size>globe_max_size) then 
         {
             globe_max_size:=globe_size
             
         }
         else 
         {
              skip 
         };
         if(globe_max_local_group>globe_max_group) then 
         {
             globe_max_group:=globe_max_local_group
             
         }
         else 
         {
              skip 
         };
         globe_net:=globe_net+1
         
     };
     globe_max_group:=globe_max_group+2*(numRows+2);
     MPG:=globe_max_group;
     ME:=globe_max_group*(globe_max_group-1);
     key_queue:=(int *)safe_malloc(101*sizeof(int),RValue);
     groupArray:=(csGroup *)safe_malloc((MPG+1)*sizeof(csGroup),RValue);
     checkArray:=(chkBox *)safe_malloc((MPG+1)*sizeof(chkBox),RValue);
     edgeArray:=(edgeBox *)safe_malloc((ME+1)*sizeof(edgeBox),RValue);
     globe_i:=0;
     
     while(globe_i<=MPG)
     {
         groupArray[globe_i].numPins:=0;
         groupArray[globe_i].flag:=0;
         groupArray[globe_i].poison:=0;
         groupArray[globe_i].unequiv:=0;
         groupArray[globe_i].extint:=0;
         groupArray[globe_i].edge1:=0;
         groupArray[globe_i].edge2:=0;
         groupArray[globe_i].check:=0;
         groupArray[globe_i].pinArray:=(csPinBox *)safe_malloc((globe_max_size+1)*sizeof(csPinBox),RValue);
         globe_i:=globe_i+1
         
     };
     globe_i:=0;
     
     while(globe_i<=ME)
     {
         edgeArray[globe_i].marked:=0;
         edgeArray[globe_i].done:=0;
         edgeArray[globe_i].poison:=0;
         globe_i:=globe_i+1
         
     };
     pseudoPins:=(int **)safe_malloc((numRows+2)*sizeof(int *),RValue);
     globe_jj:=0;
     
     while(globe_jj<=numRows+1)
     {
         pseudoPins[globe_jj]:=(int *)safe_malloc(2*sizeof(int),RValue);
         globe_jj:=globe_jj+1
         
     };
     pseudoEdge:=(int **)safe_malloc((numRows+2)*sizeof(int *),RValue);
     globe_jj:=0;
     
     while(globe_jj<=numRows+1)
     {
         pseudoEdge[globe_jj]:=(int *)safe_malloc(2*sizeof(int),RValue);
         globe_jj:=globe_jj+1
         
     };
     numChans:=numRows+1;
     globe_xstart:=32000;
     globe_xstop:=0;
     globe_cell:=1;
     
     while(globe_cell<=numcells+numterms)
     {
         globe_cx:=carray[globe_cell]->cxcenter;
         globe_cl:=carray[globe_cell]->tileptr->left;
         globe_cr:=carray[globe_cell]->tileptr->right;
         if(globe_cx+globe_cr>globe_xstop) then 
         {
             globe_xstop:=globe_cx+globe_cr
             
         }
         else 
         {
              skip 
         };
         if(globe_cx+globe_cl<globe_xstart) then 
         {
             globe_xstart:=globe_cx+globe_cl
             
         }
         else 
         {
              skip 
         };
         globe_cell:=globe_cell+1
         
     };
     gxstart:=globe_xstart;
     gxstop:=globe_xstop;
     sprintf(globe_filename,"%s.twf",cktName,RValue) and skip;
     globe_twfile:=twopen(globe_filename,"w",1,RValue);
     continue<==0 and skip;
     globe_net:=1;
     
     while(globe_net<=numnets)
     {
          continue<==0 and skip;
         globe_jj:=0;
         
         while(globe_jj<=numRows+1)
         {
             pseudoPins[globe_jj,0]:=0;
             pseudoPins[globe_jj,1]:=0;
             pseudoEdge[globe_jj,0]:=0;
             pseudoEdge[globe_jj,1]:=0;
             globe_jj:=globe_jj+1
             
         };
         numEdges:=0;
         top_row:=-1;
         globe_netptr:=netarray[globe_net]->netptr;
         while(globe_netptr!=NULL)
         {
             globe_top:=globe_netptr->pinloc;
             globe_extint:=globe_netptr->extint;
             globe_unequiv:=globe_netptr->unequiv;
             globe_block:=globe_netptr->row;
             if(globe_block>top_row) then 
             {
                 if(globe_netptr->cell<=numcells) then 
                 {
                     top_row:=globe_block
                 }
                 else
                 {
                     if(carray[globe_netptr->cell]->padside!=1 AND carray[globe_netptr->cell]->padside!=3) then 
                     {
                         top_row:=globe_block
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 
             }
             else 
             {
                  skip 
             };
             globe_locX:=globe_netptr->xpos;
             globe_locY:=globe_netptr->ypos;
             globe_pin:=globe_netptr->terminal;
             globe_found:=0;
             globe_group:=1;
             while(groupArray[globe_group].numPins!=0 AND globe_found=0)
             {
                 if(groupArray[globe_group].extint=globe_extint AND globe_unequiv=0) then 
                 {
                     globe_found:=1
                 }
                 else
                 {
                     globe_group:=globe_group+1
                 }
             };
             numPins:=((groupArray[globe_group].numPins)+1);
             (groupArray[globe_group].numPins):=(groupArray[globe_group].numPins)+1;
             groupArray[globe_group].pinArray[numPins].xloc:=globe_locX;
             groupArray[globe_group].pinArray[numPins].yloc:=globe_locY;
             groupArray[globe_group].pinArray[numPins].top:=globe_top;
             groupArray[globe_group].pinArray[numPins].pin:=globe_pin;
             if(globe_found=0) then 
             {
                 groupArray[globe_group].aveX:=globe_locX;
                 groupArray[globe_group].aveY:=globe_locY;
                 groupArray[globe_group].extint:=globe_extint;
                 groupArray[globe_group].unequiv:=globe_unequiv;
                 groupArray[globe_group].block:=globe_block
                 
             }
             else
             {
                 groupArray[globe_group].aveX:=groupArray[globe_group].aveX+globe_locX;
                 groupArray[globe_group].aveY:=groupArray[globe_group].aveY+globe_locY
             };
             globe_netptr:=globe_netptr->nterm
             
         };
         globe_group:=1;
         
         while(groupArray[globe_group].numPins!=0)
         {
             numPins:=groupArray[globe_group].numPins;
             if(numPins>1) then 
             {
                 groupArray[globe_group].aveX:=groupArray[globe_group].aveX/ numPins;
                 groupArray[globe_group].aveY:=groupArray[globe_group].aveY/ numPins
                 
             }
             else 
             {
                  skip 
             };
             globe_group:=globe_group+1
             
         };
         numGroups:=globe_group-1;
         if(numGroups=2) then 
         {
             if(groupArray[1].unequiv=1 AND groupArray[2].unequiv=1) then 
             {
                 globe_i:=1;
                 
                 while(globe_i<=numGroups)
                 {
                     groupArray[globe_i].numPins:=0;
                     groupArray[globe_i].flag:=0;
                     groupArray[globe_i].poison:=0;
                     groupArray[globe_i].unequiv:=0;
                     groupArray[globe_i].extint:=0;
                     groupArray[globe_i].edge1:=0;
                     groupArray[globe_i].edge2:=0;
                     groupArray[globe_i].check:=0;
                     globe_i:=globe_i+1
                     
                 };
                 globe_i:=1;
                 
                 while(globe_i<=numEdges)
                 {
                     edgeArray[globe_i].marked:=0;
                     edgeArray[globe_i].done:=0;
                     edgeArray[globe_i].poison:=0;
                     globe_i:=globe_i+1
                     
                 };
                 continue<==1 and skip;
                  globe_net:=globe_net+1
             }
             else 
             {
                  skip 
             }
             
         }
         else
         {
             if(numGroups<=1) then 
             {
                 globe_i:=1;
                 
                 while(globe_i<=numGroups)
                 {
                     groupArray[globe_i].numPins:=0;
                     groupArray[globe_i].flag:=0;
                     groupArray[globe_i].poison:=0;
                     groupArray[globe_i].unequiv:=0;
                     groupArray[globe_i].extint:=0;
                     groupArray[globe_i].edge1:=0;
                     groupArray[globe_i].edge2:=0;
                     groupArray[globe_i].check:=0;
                     globe_i:=globe_i+1
                     
                 };
                 globe_i:=1;
                 
                 while(globe_i<=numEdges)
                 {
                     edgeArray[globe_i].marked:=0;
                     edgeArray[globe_i].done:=0;
                     edgeArray[globe_i].poison:=0;
                     globe_i:=globe_i+1
                     
                 };
                 continue<==1 and skip;
                  globe_net:=globe_net+1
             }
             else 
             {
                  skip 
             }
         };
         if(continue=0)  then 
         {
             qsortg((char *)(groupArray+1),numGroups,sizeof(csGroup),RValue);
             globe_group:=1;
             
             while(globe_group<numGroups)
             {
                 globe_block:=groupArray[globe_group].block;
                 globe_type1:=detGroup(globe_group,RValue);
                 searchG(globe_group,globe_type1,globe_block,RValue);
                 globe_group:=globe_group+1
                 
             };
             continue<==0 and skip;
             globe_edge1:=1;
             
             while(globe_edge1<=numEdges)
             {
                  continue<==0 and skip;
                 globe_a1:=edgeArray[globe_edge1].group1;
                 globe_a2:=edgeArray[globe_edge1].group2;
                 if(groupArray[globe_a1].block!=groupArray[globe_a2].block) then 
                 {
                     continue<==1 and skip;
                      globe_edge1:=globe_edge1+1
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     continue<==0 and skip;
                     break$<==0 and skip;
                     globe_edge2:=globe_edge1+1;
                     
                     while( break$=0 AND  globe_edge2<=numEdges)
                     {
                          continue<==0 and skip;
                         globe_b1:=edgeArray[globe_edge2].group1;
                         globe_b2:=edgeArray[globe_edge2].group2;
                         if(groupArray[globe_b1].block!=groupArray[globe_b2].block) then 
                         {
                             continue<==1 and skip;
                              globe_edge2:=globe_edge2+1
                         }
                         else 
                         {
                              skip 
                         };
                         if(continue=0)   then 
                         {
                             if((groupArray[globe_a1].unequiv=1 AND groupArray[globe_b1].unequiv=1 AND groupArray[globe_a1].extint=groupArray[globe_b1].extint AND groupArray[globe_a2].extint=groupArray[globe_b2].extint) OR (groupArray[globe_a2].unequiv=1 AND groupArray[globe_b2].unequiv=1 AND groupArray[globe_a2].extint=groupArray[globe_b2].extint AND groupArray[globe_a1].extint=groupArray[globe_b1].extint)) then 
                             {
                                 globe_ya:=(groupArray[globe_a1].aveY+groupArray[globe_a2].aveY)/ 2;
                                 globe_yb:=(groupArray[globe_b1].aveY+groupArray[globe_b2].aveY)/ 2;
                                 if(groupArray[globe_a1].block=top_row) then 
                                 {
                                     if(globe_ya<globe_yb) then 
                                     {
                                         if(edgeArray[globe_edge2].cost<=edgeArray[globe_edge1].cost) then 
                                         {
                                             edgeArray[globe_edge2].cost:=edgeArray[globe_edge1].cost+1
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     }
                                     else
                                     {
                                         if(edgeArray[globe_edge2].cost>=edgeArray[globe_edge1].cost) then 
                                         {
                                             edgeArray[globe_edge2].cost:=edgeArray[globe_edge1].cost-1
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     }
                                     
                                 }
                                 else
                                 {
                                     if(globe_ya<globe_yb) then 
                                     {
                                         if(edgeArray[globe_edge2].cost>=edgeArray[globe_edge1].cost) then 
                                         {
                                             edgeArray[globe_edge2].cost:=edgeArray[globe_edge1].cost-1
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     }
                                     else
                                     {
                                         if(edgeArray[globe_edge2].cost<=edgeArray[globe_edge1].cost) then 
                                         {
                                             edgeArray[globe_edge2].cost:=edgeArray[globe_edge1].cost+1
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     }
                                 };
                                 break$<==1 and skip
                                  
                             }
                             else 
                             {
                                  skip 
                             };
                             if(break$=0)   then
                             {
                                 globe_edge2:=globe_edge2+1
                             }
                             else
                             {
                                 skip
                             }
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     break$<==0 and skip;
                     continue<==0 and skip;
                     globe_edge1:=globe_edge1+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             continue<==0 and skip;
			 break$<==0 and skip;
             qsorte((char *)(edgeArray+1),numEdges,sizeof(edgeBox),RValue);
             globe_group:=1;
             
             while(globe_group<=numGroups)
             {
                 groupArray[globe_group].flag:=globe_group;
                 globe_group:=globe_group+1
                 
             };
             continue<==0 and skip;
             globe_edge:=1;
             
             while(globe_edge<=numEdges)
             {
                  continue<==0 and skip;
                 globe_group1:=edgeArray[globe_edge].group1;
                 globe_flag1:=groupArray[globe_group1].flag;
                 globe_group2:=edgeArray[globe_edge].group2;
                 globe_flag2:=groupArray[globe_group2].flag;
                 if(globe_flag1<=0 OR globe_flag2<=0 OR globe_flag1=globe_flag2) then 
                 {
                     continue<==1 and skip;
                      globe_edge:=globe_edge+1
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     globe_added_an_edge:=0;
                     edgeArray[globe_edge].marked:=1;
                     globe_group:=1;
                     
                     while(globe_group<=numGroups)
                     {
                         if(groupArray[globe_group].flag=globe_flag2) then 
                         {
                             groupArray[globe_group].flag:=globe_flag1
                             
                         }
                         else 
                         {
                              skip 
                         };
                         globe_group:=globe_group+1
                         
                     };
                     globe_cell1:=tearray[groupArray[globe_group1].pinArray[1].pin]->cell;
                     globe_cell2:=tearray[groupArray[globe_group2].pinArray[1].pin]->cell;
                     globe_cellptr1:=carray[globe_cell1];
                     globe_cellptr2:=carray[globe_cell2];
                     if(globe_cell1>numcells AND globe_cellptr1->padside!=2 AND globe_cellptr1->padside!=14 AND globe_cellptr1->padside!=15 AND globe_cellptr1->padside!=4) then 
                     {
                         if(globe_cell2<=numcells) then 
                         {
                             groupArray[globe_group1].flag:=0
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(globe_cell2>numcells AND globe_cellptr2->padside!=2 AND globe_cellptr2->padside!=14 AND globe_cellptr2->padside!=15 AND globe_cellptr2->padside!=4) then 
                     {
                         if(globe_cell1<=numcells) then 
                         {
                             groupArray[globe_group2].flag:=0
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(groupArray[globe_group1].unequiv=1) then 
                     {
                         globe_ei1:=groupArray[globe_group1].extint;
                         continue<==0 and skip;
                         break$<==0 and skip;
                         globe_ue_grp:=1;
                         
                         while( break$=0 AND  globe_ue_grp<=numGroups)
                         {
                              continue<==0 and skip;
                             if(globe_ue_grp=globe_group1) then 
                             {
                                 continue<==1 and skip;
                                  globe_ue_grp:=globe_ue_grp+1
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)   then 
                             {
                                 if(groupArray[globe_ue_grp].extint=globe_ei1) then 
                                 {
                                     break$<==1 and skip
                                      
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(break$=0)   then
                                 {
                                     globe_ue_grp:=globe_ue_grp+1
                                 }
                                 else
                                 {
                                     skip
                                 }
                             }
                             else
                             {
                                 skip
                             }
                             
                         };
                         break$<==0 and skip;
                         continue<==0 and skip;
                         if(groupArray[globe_ue_grp].flag>0) then 
                         {
                             globe_g2<==0 and globe_g1<==globe_g2 and skip;
                             groupArray[globe_ue_grp].flag:=-1;
                             continue<==0 and skip;
                             globe_edge2:=globe_edge+1;
                             
                             while(globe_edge2<=numEdges)
                             {
                                  continue<==0 and skip;
                                 if(globe_g2=0) then 
                                 {
                                     if(edgeArray[globe_edge2].group1=globe_ue_grp) then 
                                     {
                                         globe_g2:=edgeArray[globe_edge2].group2;
                                         if(groupArray[globe_g2].flag<0) then 
                                         {
                                             globe_g2:=0
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         continue<==1 and skip;
                                          globe_edge2:=globe_edge2+1
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(continue=0)  then
                                 {
                                     if(globe_g1=0) then 
                                     {
                                         if(edgeArray[globe_edge2].group2=globe_ue_grp) then 
                                         {
                                             globe_g1:=edgeArray[globe_edge2].group1;
                                             if(groupArray[globe_g1].flag<0) then 
                                             {
                                                 globe_g1:=0
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     globe_edge2:=globe_edge2+1
                                 }
                                 else
                                 {
                                     skip
                                 }
                                 
                             };
                             continue<==0 and skip;
                             if(globe_g1!=0 AND globe_g2!=0) then 
                             {
                                 addEdge(globe_g1,globe_g2,RValue);
                                 globe_added_an_edge:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(groupArray[globe_group2].unequiv=1) then 
                     {
                         globe_ei2:=groupArray[globe_group2].extint;
                         continue<==0 and skip;
                         break$<==0 and skip;
                         globe_ue_grp:=1;
                         
                         while( break$=0 AND  globe_ue_grp<=numGroups)
                         {
                              continue<==0 and skip;
                             if(globe_ue_grp=globe_group2) then 
                             {
                                 continue<==1 and skip;
                                  globe_ue_grp:=globe_ue_grp+1
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)   then 
                             {
                                 if(groupArray[globe_ue_grp].extint=globe_ei2) then 
                                 {
                                     break$<==1 and skip
                                      
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(break$=0)   then
                                 {
                                     globe_ue_grp:=globe_ue_grp+1
                                 }
                                 else
                                 {
                                     skip
                                 }
                             }
                             else
                             {
                                 skip
                             }
                             
                         };
                         break$<==0 and skip;
                         continue<==0 and skip;
                         if(groupArray[globe_ue_grp].flag>0) then 
                         {
                             globe_g2<==0 and globe_g1<==globe_g2 and skip;
                             groupArray[globe_ue_grp].flag:=-1;
                             continue<==0 and skip;
                             globe_edge2:=globe_edge+1;
                             
                             while(globe_edge2<=numEdges)
                             {
                                  continue<==0 and skip;
                                 if(globe_g2=0) then 
                                 {
                                     if(edgeArray[globe_edge2].group1=globe_ue_grp) then 
                                     {
                                         globe_g2:=edgeArray[globe_edge2].group2;
                                         if(groupArray[globe_g2].flag<0) then 
                                         {
                                             globe_g2:=0
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         continue<==1 and skip;
                                          globe_edge2:=globe_edge2+1
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(continue=0)  then
                                 {
                                     if(globe_g1=0) then 
                                     {
                                         if(edgeArray[globe_edge2].group2=globe_ue_grp) then 
                                         {
                                             globe_g1:=edgeArray[globe_edge2].group1;
                                             if(groupArray[globe_g1].flag<0) then 
                                             {
                                                 globe_g1:=0
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     globe_edge2:=globe_edge2+1
                                 }
                                 else
                                 {
                                     skip
                                 }
                                 
                             };
                             continue<==0 and skip;
                             if(globe_g1!=0 AND globe_g2!=0) then 
                             {
                                 addEdge(globe_g1,globe_g2,RValue);
                                 globe_added_an_edge:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(globe_added_an_edge=1) then 
                     {
                         continue<==0 and skip;
                         globe_edge1:=globe_edge+1;
                         
                         while(globe_edge1<=numEdges)
                         {
                              continue<==0 and skip;
                             globe_a1:=edgeArray[globe_edge1].group1;
                             globe_a2:=edgeArray[globe_edge1].group2;
                             if(groupArray[globe_a1].block!=groupArray[globe_a2].block) then 
                             {
                                 continue<==1 and skip;
                                  globe_edge1:=globe_edge1+1
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)   then 
                             {
                                 continue<==0 and skip;
                                 break$<==0 and skip;
                                 globe_edge2:=globe_edge1+1;
                                 
                                 while( break$=0 AND  globe_edge2<=numEdges)
                                 {
                                      continue<==0 and skip;
                                     globe_b1:=edgeArray[globe_edge2].group1;
                                     globe_b2:=edgeArray[globe_edge2].group2;
                                     if(groupArray[globe_b1].block!=groupArray[globe_b2].block) then 
                                     {
                                         continue<==1 and skip;
                                          globe_edge2:=globe_edge2+1
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     if(continue=0)   then 
                                     {
                                         if((groupArray[globe_a1].unequiv=1 AND groupArray[globe_b1].unequiv=1 AND groupArray[globe_a1].extint=groupArray[globe_b1].extint AND groupArray[globe_a2].extint=groupArray[globe_b2].extint) OR (groupArray[globe_a2].unequiv=1 AND groupArray[globe_b2].unequiv=1 AND groupArray[globe_a2].extint=groupArray[globe_b2].extint AND groupArray[globe_a1].extint=groupArray[globe_b1].extint)) then 
                                         {
                                             globe_ya:=(groupArray[globe_a1].aveY+groupArray[globe_a2].aveY)/ 2;
                                             globe_yb:=(groupArray[globe_b1].aveY+groupArray[globe_b2].aveY)/ 2;
                                             if(groupArray[globe_a1].block=top_row) then 
                                             {
                                                 if(globe_ya<globe_yb) then 
                                                 {
                                                     if(edgeArray[globe_edge2].cost<=edgeArray[globe_edge1].cost) then 
                                                     {
                                                         edgeArray[globe_edge2].cost:=edgeArray[globe_edge1].cost+1
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                                 else
                                                 {
                                                     if(edgeArray[globe_edge2].cost>=edgeArray[globe_edge1].cost) then 
                                                     {
                                                         edgeArray[globe_edge2].cost:=edgeArray[globe_edge1].cost-1
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                                 
                                             }
                                             else
                                             {
                                                 if(globe_ya<globe_yb) then 
                                                 {
                                                     if(edgeArray[globe_edge2].cost>=edgeArray[globe_edge1].cost) then 
                                                     {
                                                         edgeArray[globe_edge2].cost:=edgeArray[globe_edge1].cost-1
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                                 else
                                                 {
                                                     if(edgeArray[globe_edge2].cost<=edgeArray[globe_edge1].cost) then 
                                                     {
                                                         edgeArray[globe_edge2].cost:=edgeArray[globe_edge1].cost+1
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                             };
                                             break$<==1 and skip
                                              
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         if(break$=0)   then
                                         {
                                             globe_edge2:=globe_edge2+1
                                         }
                                         else
                                         {
                                             skip
                                         }
                                     }
                                     else
                                     {
                                         skip
                                     }
                                     
                                 };
                                 break$<==0 and skip;
                                 continue<==0 and skip;
                                 globe_edge1:=globe_edge1+1
                             }
                             else
                             {
                                 skip
                             }
                             
                         };
                         continue<==0 and skip;
						 break$<==0 and skip;
                         qsorte((char *)(edgeArray+1+globe_edge),numEdges-globe_edge,sizeof(edgeBox),RValue)
                         
                     }
                     else 
                     {
                          skip 
                     };
                     globe_edge:=globe_edge+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             continue<==0 and skip;
             continue<==0 and skip;
             globe_group:=1;
             
             while(globe_group<=numGroups)
             {
                  continue<==0 and skip;
                 if(groupArray[globe_group].flag<0) then 
                 {
                     continue<==1 and skip;
                      globe_group:=globe_group+1
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     if(groupArray[globe_group].unequiv!=1) then 
                     {
                         continue<==1 and skip;
                          globe_group:=globe_group+1
                     }
                     else 
                     {
                          skip 
                     };
                     if(continue=0)   then 
                     {
                         globe_ei:=groupArray[globe_group].extint;
                         break$<==0 and skip;
                         globe_group2:=globe_group+1;
                         
                         while( break$=0 AND  globe_group2<=numGroups)
                         {
                             if(groupArray[globe_group2].extint=globe_ei) then 
                             {
                                 if(groupArray[globe_group2].flag>=0) then 
                                 {
                                     groupArray[globe_group2].flag:=-1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 break$<==1 and skip
                                  
                             }
                             else 
                             {
                                  skip 
                             };
                             if(break$=0)   then
                             {
                                 globe_group2:=globe_group2+1
                             }
                             else
                             {
                                 skip
                             }
                             
                         };
                         break$<==0 and skip;
                         globe_group:=globe_group+1
                     }
                     else
                     {
                         skip
                     }
                 }
                 else
                 {
                     skip
                 }
                 
             };
             continue<==0 and skip;
             globe_done:=0;
             while(globe_done=0)
             {
                 globe_done:=1;
                 globe_edge:=1;
                 
                 while(globe_edge<=numEdges)
                 {
                     if(edgeArray[globe_edge].marked=1 AND edgeArray[globe_edge].poison=0) then 
                     {
                         globe_g1:=edgeArray[globe_edge].group1;
                         globe_g2:=edgeArray[globe_edge].group2;
                         globe_unequiv1:=groupArray[globe_g1].unequiv;
                         if(globe_unequiv1=0) then 
                         {
                             if(groupArray[globe_g1].numPins=1 AND groupArray[globe_g1].pinArray[1].top!=0) then 
                             {
                                 globe_single_pin1:=1;
                                 globe_unequiv1:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         globe_unequiv2:=groupArray[globe_g2].unequiv;
                         if(globe_unequiv2=0) then 
                         {
                             if(groupArray[globe_g2].numPins=1 AND groupArray[globe_g2].pinArray[1].top!=0) then 
                             {
                                 globe_single_pin2:=1;
                                 globe_unequiv2:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if((groupArray[globe_g1].poison=1) OR (groupArray[globe_g2].poison=1)) then 
                         {
                             globe_done:=0;
                             edgeArray[globe_edge].poison:=1;
                             if(globe_unequiv1=1) then 
                             {
                                 groupArray[globe_g1].poison:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(globe_unequiv2=1) then 
                             {
                                 groupArray[globe_g2].poison:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                         }
                         else
                         {
                             if(groupArray[globe_g1].block!=groupArray[globe_g2].block) then 
                             {
                                 globe_done:=0;
                                 edgeArray[globe_edge].poison:=1;
                                 if(globe_unequiv1=1) then 
                                 {
                                     groupArray[globe_g1].poison:=1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(globe_unequiv2=1) then 
                                 {
                                     groupArray[globe_g2].poison:=1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                             else
                             {
                                 if(globe_single_pin1=1 OR globe_single_pin2=1) then 
                                 {
                                     globe_done:=0;
                                     edgeArray[globe_edge].poison:=1;
                                     if(globe_unequiv1=1) then 
                                     {
                                         groupArray[globe_g1].poison:=1
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     if(globe_unequiv2=1) then 
                                     {
                                         groupArray[globe_g2].poison:=1
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     globe_edge:=globe_edge+1
                     
                 }
             };
             globe_edge:=1;
             
             while(globe_edge<=numEdges)
             {
                 if(edgeArray[globe_edge].marked=1 AND edgeArray[globe_edge].poison=0) then 
                 {
                     globe_g1:=edgeArray[globe_edge].group1;
                     globe_g2:=edgeArray[globe_edge].group2;
                     if(groupArray[globe_g1].unequiv=0 AND groupArray[globe_g2].unequiv=0) then 
                     {
                         edgeArray[globe_edge].poison:=1
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(groupArray[globe_g1].unequiv=0) then 
                     {
                         groupArray[globe_g1].poison:=1
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(groupArray[globe_g2].unequiv=0) then 
                     {
                         groupArray[globe_g2].poison:=1
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 globe_edge:=globe_edge+1
                 
             };
             break$<==0 and skip;
             globe_edge:=1;
             
             while( break$=0 AND  globe_edge<=numEdges)
             {
                 if(edgeArray[globe_edge].marked=1 AND edgeArray[globe_edge].poison=0) then 
                 {
                     globe_g1:=edgeArray[globe_edge].group1;
                     globe_g2:=edgeArray[globe_edge].group2;
                     if(groupArray[globe_g1].edge1=0) then 
                     {
                         groupArray[globe_g1].edge1:=globe_edge
                         
                     }
                     else
                     {
                         groupArray[globe_g1].edge2:=globe_edge
                     };
                     if(groupArray[globe_g2].edge1=0) then 
                     {
                         groupArray[globe_g2].edge1:=globe_edge
                         
                     }
                     else
                     {
                         groupArray[globe_g2].edge2:=globe_edge
                     };
                     if(groupArray[globe_g1].poison=0) then 
                     {
                         globe_ei:=groupArray[globe_g1].extint;
                         continue<==0 and skip;
                         globe_group:=1;
                         
                         while(break$=0 AND true)
                         {
                              continue<==0 and skip;
                             if((globe_group=globe_g1) OR (groupArray[globe_group].extint!=globe_ei)) then 
                             {
                                 continue<==1 and skip;
                                  globe_group:=globe_group+1
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)   then 
                             {
                                 break$<==1 and skip
                             }
                             else
                             {
                                 skip
                             }
                             
                         };
						 break$<==0 and skip;
                         continue<==0 and skip;
                         groupArray[globe_g1].numPins:=2;
                         groupArray[globe_g1].pinArray[2].xloc:=groupArray[globe_group].pinArray[1].xloc;
                         groupArray[globe_g1].pinArray[2].yloc:=groupArray[globe_group].pinArray[1].yloc;
                         groupArray[globe_g1].pinArray[2].top:=groupArray[globe_group].pinArray[1].top;
                         groupArray[globe_g1].pinArray[2].pin:=groupArray[globe_group].pinArray[1].pin
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(break$=0)   then
                     {
                         if(groupArray[globe_g2].poison=0) then 
                         {
                             globe_ei:=groupArray[globe_g2].extint;
                             continue<==0 and skip;
                             globe_group:=1;
                             
                             while(break$=0 AND true)
                             {
                                  continue<==0 and skip;
                                 if((globe_group=globe_g2) OR (groupArray[globe_group].extint!=globe_ei)) then 
                                 {
                                     continue<==1 and skip;
                                      globe_group:=globe_group+1
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(continue=0)   then 
                                 {
                                     break$<==1 and skip
      
                                 }
                                 else
                                 {
                                     skip
                                 }
                                 
                             };
							 break$<==0 and skip;
                             continue<==0 and skip;
                             groupArray[globe_g2].numPins:=2;
                             groupArray[globe_g2].pinArray[2].xloc:=groupArray[globe_group].pinArray[1].xloc;
                             groupArray[globe_g2].pinArray[2].yloc:=groupArray[globe_group].pinArray[1].yloc;
                             groupArray[globe_g2].pinArray[2].top:=groupArray[globe_group].pinArray[1].top;
                             groupArray[globe_g2].pinArray[2].pin:=groupArray[globe_group].pinArray[1].pin
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                     else
                     {
                         skip
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then 
                 {
                     globe_edge:=globe_edge+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             globe_edge:=1;
             
             while(globe_edge<=numEdges)
             {
                 if(edgeArray[globe_edge].marked=1 AND edgeArray[globe_edge].poison=0) then 
                 {
                     globe_g1:=edgeArray[globe_edge].group1;
                     globe_g2:=edgeArray[globe_edge].group2;
                     if(groupArray[globe_g1].edge2=0 AND groupArray[globe_g2].edge2=0) then 
                     {
                         edgeArray[globe_edge].poison:=1
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 globe_edge:=globe_edge+1
                 
             };
             closepins(globe_twfile,globe_net);
             globe_i:=1;
             
             while(globe_i<=numGroups)
             {
                 groupArray[globe_i].numPins:=0;
                 groupArray[globe_i].flag:=0;
                 groupArray[globe_i].poison:=0;
                 groupArray[globe_i].unequiv:=0;
                 groupArray[globe_i].extint:=0;
                 groupArray[globe_i].edge1:=0;
                 groupArray[globe_i].edge2:=0;
                 groupArray[globe_i].check:=0;
                 globe_i:=globe_i+1
                 
             };
             globe_i:=1;
             
             while(globe_i<=numEdges)
             {
                 edgeArray[globe_i].marked:=0;
                 edgeArray[globe_i].done:=0;
                 edgeArray[globe_i].poison:=0;
                 globe_i:=globe_i+1
                 
             };
             globe_net:=globe_net+1
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     twclose(globe_twfile);
      return<==1 and skip
     )
     }; 
  function chkGroup ( int g1,int g2,int direction,int RValue )
 {
     frame(chkGroup_g1type,chkGroup_g2type,return) and ( 
     int return<==0 and skip;
     int chkGroup_g1type,chkGroup_g2type and skip;
     chkGroup_g1type:=detGroup(g1,RValue);
     chkGroup_g2type:=detGroup(g2,RValue);
     if(direction=0) then 
     {
         if(chkGroup_g1type=0) then 
         {
             return<==1 and RValue:=1;
             skip
         }
         else
         {
             if(chkGroup_g1type=1) then 
             {
                 if(chkGroup_g2type=0 OR chkGroup_g2type=1) then 
                 {
                     return<==1 and RValue:=1;
                     skip
                 }
                 else
                 {
                     return<==1 and RValue:=0;
                     skip
                 }
             }
             else
             {
                 if(chkGroup_g2type=0 OR chkGroup_g2type=-1) then 
                 {
                     return<==1 and RValue:=1;
                     skip
                 }
                 else
                 {
                     return<==1 and RValue:=0;
                     skip
                 }
             }
         }
     }
     else
     {
         if(direction=1) then 
         {
             if((chkGroup_g1type=0 OR chkGroup_g1type=1) AND (chkGroup_g2type=0 OR chkGroup_g2type=-1)) then 
             {
                 return<==1 and RValue:=1;
                 skip
             }
             else
             {
                 return<==1 and RValue:=0;
                 skip
             }
         }
         else
         {
             if((chkGroup_g1type=0 OR chkGroup_g1type=-1) AND (chkGroup_g2type=0 OR chkGroup_g2type=1)) then 
             {
                 return<==1 and RValue:=1;
                 skip
             }
             else
             {
                 return<==1 and RValue:=0;
                 skip
             }
         }
     }
     )
     }; 
  function detGroup ( int g,int RValue )
 {
     frame(detGroup_p,detGroup_pt,detGroup_pb,detGroup_p0,return) and ( 
     int return<==0 and skip;
     int detGroup_p,detGroup_pt,detGroup_pb,detGroup_p0 and skip;
     detGroup_pt:=0;
     detGroup_pb:=0;
     detGroup_p0:=0;
     detGroup_p:=1;
     
     while(detGroup_p<=groupArray[g].numPins)
     {
         if(groupArray[g].pinArray[detGroup_p].top=0) then 
         {
             detGroup_p0:=1
             
         }
         else
         {
             if(groupArray[g].pinArray[detGroup_p].top=1) then 
             {
                 detGroup_pt:=1
             }
             else
             {
                 detGroup_pb:=1
             }
         };
         detGroup_p:=detGroup_p+1
         
     };
     if(detGroup_p0=1 OR (detGroup_pt=1 AND detGroup_pb=1)) then 
     {
         return<==1 and RValue:=0;
         skip
     }
     else
     {
         if(detGroup_pt=1) then 
         {
             return<==1 and RValue:=1;
             skip
         }
         else
         {
             return<==1 and RValue:=(-1);
             skip
         }
     }
     )
     }; 
  function addEdge ( int g1,int g2,int RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
     edgeArray[(numEdges+1)].cost:=ABS(groupArray[g1].aveX-groupArray[g2].aveX,RValue);
     numEdges:=numEdges+1;
     edgeArray[numEdges].group1:=g1;
     edgeArray[numEdges].group2:=g2;
     return<==1 and RValue:=0;
     skip
     )
     }; 
  function searchG ( int g,int type,int block,int RValue )
 {
     frame(searchG_og,searchG_uptarget,searchG_dntarget,searchG_type2,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     int searchG_og,searchG_uptarget,searchG_dntarget,searchG_type2 and skip;
     searchG_uptarget:=0;
     searchG_dntarget:=0;
     if(type=0) then 
     {
         break$<==0 and skip;
         searchG_og:=g+1;
         
         while( break$=0 AND  searchG_og<=numGroups)
         {
             if(groupArray[searchG_og].block=block) then 
             {
                 if(extern chkGroup(g,searchG_og,0,RValue)) then 
                 {
                     searchG_type2:=detGroup(searchG_og,RValue);
                     if(searchG_type2=0) then 
                     {
                         if(searchG_uptarget=0 AND searchG_dntarget=0) then 
                         {
                             addEdge(g,searchG_og,RValue)
                             
                         }
                         else 
                         {
                              skip 
                         };
                         searchG_uptarget:=1;
                         searchG_dntarget:=1
                     }
                     else
                     {
                         if(searchG_type2=1) then 
                         {
                             if(searchG_uptarget=0) then 
                             {
                                 addEdge(g,searchG_og,RValue);
                                 searchG_uptarget:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                         }
                         else
                         {
                             if(searchG_dntarget=0) then 
                             {
                                 addEdge(g,searchG_og,RValue);
                                 searchG_dntarget:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                         }
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(searchG_uptarget=1 AND searchG_dntarget=1) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else
             {
                 if(groupArray[searchG_og].block=block-1) then 
                 {
                     if(extern chkGroup(g,searchG_og,-1,RValue)) then 
                     {
                         if(searchG_dntarget=0) then 
                         {
                             addEdge(g,searchG_og,RValue);
                             searchG_dntarget:=1
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(searchG_uptarget=1 AND searchG_dntarget=1) then 
                     {
                         break$<==1 and skip
                          
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     if(groupArray[searchG_og].block=block+1) then 
                     {
                         if(extern chkGroup(g,searchG_og,1,RValue)) then 
                         {
                             if(searchG_uptarget=0) then 
                             {
                                 addEdge(g,searchG_og,RValue);
                                 searchG_uptarget:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(searchG_uptarget=1 AND searchG_dntarget=1) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
             };
             if(break$=0)  then 
             {
                 searchG_og:=searchG_og+1
             }
             else
             {
                 skip
             }
         };
         break$<==0 and skip
         
     }
     else
     {
         if(type=1) then 
         {
             break$<==0 and skip;
             searchG_og:=g+1;
             
             while( break$=0 AND  searchG_og<=numGroups)
             {
                 if(groupArray[searchG_og].block=block) then 
                 {
                     if(extern chkGroup(g,searchG_og,0,RValue)) then 
                     {
                         addEdge(g,searchG_og,RValue);
                         break$<==1 and skip
                          
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else
                 {
                     if(groupArray[searchG_og].block=block+1) then 
                     {
                         if(extern chkGroup(g,searchG_og,1,RValue)) then 
                         {
                             addEdge(g,searchG_og,RValue);
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     }
                 };
                 if(break$=0)  then 
                 {
                     searchG_og:=searchG_og+1
                 }
                 else
                 {
                     skip
                 }
             };
             break$<==0 and skip
         }
         else
         {
             break$<==0 and skip;
             searchG_og:=g+1;
             
             while( break$=0 AND  searchG_og<=numGroups)
             {
                 if(groupArray[searchG_og].block=block) then 
                 {
                     if(extern chkGroup(g,searchG_og,0,RValue)) then 
                     {
                         addEdge(g,searchG_og,RValue);
                         break$<==1 and skip
                          
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else
                 {
                     if(groupArray[searchG_og].block=block-1) then 
                     {
                         if(extern chkGroup(g,searchG_og,-1,RValue)) then 
                         {
                             addEdge(g,searchG_og,RValue);
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     }
                 };
                 if(break$=0)  then 
                 {
                     searchG_og:=searchG_og+1
                 }
                 else
                 {
                     skip
                 }
             };
             break$<==0 and skip
         }
     };
      return<==1 and skip
     )
     }; 
  function globedbg ( int lowerNet,int upperNet )
 {
     frame(globedbg_block,globedbg_left,globedbg_rite,globedbg_bot,globedbg_top,globedbg_cell,globedbg_b,globedbg_e,globedbg_pin1,globedbg_pin2,globedbg_net,globedbg_seg,globedbg_term1,globedbg_curExtint,globedbg_separation,globedbg_factor,globedbg_llx,globedbg_lly,globedbg_urx,globedbg_ury,globedbg_sptr,globedbg_cellptr,globedbg_curTerm,globedbg_fp,globedbg_fpp,return) and ( 
     int return<==0 and skip;
     int globedbg_block,globedbg_left,globedbg_rite,globedbg_bot,globedbg_top,globedbg_cell,globedbg_b,globedbg_e,globedbg_pin1,globedbg_pin2 and skip;
     int globedbg_net,globedbg_seg,globedbg_term1,globedbg_curExtint,globedbg_separation,globedbg_factor and skip;
     int globedbg_llx,globedbg_lly,globedbg_urx,globedbg_ury and skip;
     segbox* globedbg_sptr and skip;
     cellbox* globedbg_cellptr and skip;
     netbox* globedbg_curTerm and skip;
     FILE *globedbg_fp,*globedbg_fpp and skip;
     globedbg_fp:=twopen("cell.file","w",1,RValue);
     globedbg_block:=1;
     
     while(globedbg_block<=numblock)
     {
         globedbg_left:=barray[globedbg_block]->bxcenter+barray[globedbg_block]->bleft;
         globedbg_bot:=barray[globedbg_block]->bycenter+barray[globedbg_block]->bbottom;
         globedbg_top:=barray[globedbg_block]->bycenter+barray[globedbg_block]->btop;
         if(pairArray[globedbg_block,0]>0) then 
         {
             globedbg_cell:=pairArray[globedbg_block,pairArray[globedbg_block,0]];
             globedbg_rite:=carray[globedbg_cell]->cxcenter+carray[globedbg_cell]->tileptr->right
             
         }
         else
         {
             globedbg_rite:=barray[globedbg_block]->bxcenter+barray[globedbg_block]->bright
         };
         fprintf(globedbg_fp,"%d, %d, %d, %d, color: %s, label: row:%d\n",globedbg_left,globedbg_bot,globedbg_rite,globedbg_top,"aquamarine",globedbg_block) and skip;
         globedbg_block:=globedbg_block+1
         
     };
     globedbg_llx:=2147483647;
     globedbg_lly:=2147483647;
     globedbg_urx:=(-2147483647-1);
     globedbg_ury:=(-2147483647-1);
     globedbg_cell:=numcells+1;
     
     while(globedbg_cell<=numcells+numterms)
     {
         globedbg_cellptr:=carray[globedbg_cell];
         globedbg_left:=globedbg_cellptr->cxcenter+globedbg_cellptr->tileptr->left;
         globedbg_rite:=globedbg_cellptr->cxcenter+globedbg_cellptr->tileptr->right;
         globedbg_bot:=globedbg_cellptr->cycenter+globedbg_cellptr->tileptr->bottom;
         globedbg_top:=globedbg_cellptr->cycenter+globedbg_cellptr->tileptr->top;
         fprintf(globedbg_fp,"%d, %d, %d, %d, color: %s, label: pad:%s\n",globedbg_left,globedbg_bot,globedbg_rite,globedbg_top,"aquamarine",globedbg_cellptr->cname) and skip;
         if(globedbg_left<globedbg_llx) then 
         {
             globedbg_llx:=globedbg_left
             
         }
         else 
         {
              skip 
         };
         if(globedbg_rite>globedbg_urx) then 
         {
             globedbg_urx:=globedbg_rite
             
         }
         else 
         {
              skip 
         };
         if(globedbg_bot<globedbg_lly) then 
         {
             globedbg_lly:=globedbg_bot
             
         }
         else 
         {
              skip 
         };
         if(globedbg_top>globedbg_ury) then 
         {
             globedbg_ury:=globedbg_top
             
         }
         else 
         {
              skip 
         };
         globedbg_cell:=globedbg_cell+1
         
     };
     twclose(globedbg_fp);
     globedbg_fp:=twopen("net.file","w",1,RValue);
     globedbg_fpp:=twopen("pin.file","w",1,RValue);
     globedbg_separation:=(int)rowSep*rowHeight/ 3;
     globedbg_net:=lowerNet;
     
     while(globedbg_net<=upperNet)
     {
         globedbg_b:=anet[globedbg_net];
         globedbg_e:=anet[globedbg_net+1]-1;
         globedbg_seg:=globedbg_b;
         
         while(globedbg_seg<=globedbg_e)
         {
             if(aNetSeg[globedbg_seg].nflag=0) then 
             {
                 if(aNetSeg[globedbg_seg].current=0) then 
                 {
                     globedbg_sptr:=aNetSeg[globedbg_seg].top
                     
                 }
                 else
                 {
                     globedbg_sptr:=aNetSeg[globedbg_seg].bot
                 };
                 globedbg_pin1:=globedbg_sptr->pin1;
                 globedbg_pin2:=globedbg_sptr->pin2;
                 checkPos(tearray[globedbg_pin1],1,globedbg_llx,globedbg_lly,globedbg_urx,globedbg_ury);
                 checkPos(tearray[globedbg_pin2],1,globedbg_llx,globedbg_lly,globedbg_urx,globedbg_ury);
                 if(tearray[globedbg_pin1]->ypos!=tearray[globedbg_pin2]->ypos) then 
                 {
                     fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->xpos,tearray[globedbg_pin1]->ypos,tearray[globedbg_pin2]->xpos,tearray[globedbg_pin2]->ypos,"red") and skip
                     
                 }
                 else
                 {
                     if((int)tearray[globedbg_pin1]->pinloc=-1) then 
                     {
                         globedbg_factor:=-1
                         
                     }
                     else
                     {
                         globedbg_factor:=1
                     };
                     fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->xpos,tearray[globedbg_pin1]->ypos,(tearray[globedbg_pin1]->xpos+tearray[globedbg_pin2]->xpos)/ 2,tearray[globedbg_pin2]->ypos+globedbg_factor*globedbg_separation,"red") and skip;
                     fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,(tearray[globedbg_pin1]->xpos+tearray[globedbg_pin2]->xpos)/ 2,tearray[globedbg_pin2]->ypos+globedbg_factor*globedbg_separation,tearray[globedbg_pin2]->xpos,tearray[globedbg_pin2]->ypos,"red") and skip
                 };
                 globedbg_term1:=tearray[globedbg_pin1]->terminal;
                 globedbg_curExtint:=tearray[globedbg_pin1]->extint;
                 globedbg_curTerm:=netarray[globedbg_net]->netptr;
                 
                 while(globedbg_curTerm)
                 {
                     if(globedbg_curTerm->extint=globedbg_curExtint AND globedbg_curTerm->terminal!=globedbg_term1) then 
                     {
                         if(globedbg_curTerm->unequiv) then 
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->xpos,tearray[globedbg_pin1]->ypos,globedbg_curTerm->xpos,globedbg_curTerm->ypos,"blue") and skip
                         }
                         else
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->xpos,tearray[globedbg_pin1]->ypos,globedbg_curTerm->xpos,globedbg_curTerm->ypos,"orange") and skip
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     globedbg_curTerm:=globedbg_curTerm->nterm
                     
                 };
                 globedbg_term1:=tearray[globedbg_pin2]->terminal;
                 globedbg_curExtint:=tearray[globedbg_pin2]->extint;
                 globedbg_curTerm:=netarray[globedbg_net]->netptr;
                 
                 while(globedbg_curTerm)
                 {
                     if(globedbg_curTerm->extint=globedbg_curExtint AND globedbg_curTerm->terminal!=globedbg_term1) then 
                     {
                         if(globedbg_curTerm->unequiv) then 
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin2]->xpos,tearray[globedbg_pin2]->ypos,globedbg_curTerm->xpos,globedbg_curTerm->ypos,"blue") and skip
                         }
                         else
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin2]->xpos,tearray[globedbg_pin2]->ypos,globedbg_curTerm->xpos,globedbg_curTerm->ypos,"orange") and skip
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     globedbg_curTerm:=globedbg_curTerm->nterm
                     
                 };
                 fprintf(globedbg_fpp,"%d, %d, %d, %d, %d, color: %s, label: %d\n",globedbg_net,tearray[globedbg_pin1]->xpos-1,tearray[globedbg_pin1]->ypos-1,tearray[globedbg_pin1]->xpos+1,tearray[globedbg_pin1]->ypos+1,"white",globedbg_pin1) and skip;
                 fprintf(globedbg_fpp,"%d, %d, %d, %d, %d, color: %s, label: %d\n",globedbg_net,tearray[globedbg_pin2]->xpos-1,tearray[globedbg_pin2]->ypos-1,tearray[globedbg_pin2]->xpos+1,tearray[globedbg_pin2]->ypos+1,"white",globedbg_pin2) and skip
                 
             }
             else
             {
                 if(aNetSeg[globedbg_seg].current=0) then 
                 {
                     globedbg_sptr:=aNetSeg[globedbg_seg].top
                     
                 }
                 else
                 {
                     globedbg_sptr:=aNetSeg[globedbg_seg].bot
                 };
                 globedbg_pin1:=globedbg_sptr->pin1;
                 globedbg_pin2:=globedbg_sptr->pin2;
                 checkPos(tearray[globedbg_pin1],1,globedbg_llx,globedbg_lly,globedbg_urx,globedbg_ury);
                 checkPos(tearray[globedbg_pin2],1,globedbg_llx,globedbg_lly,globedbg_urx,globedbg_ury);
                 checkPos(tearray[globedbg_pin1],0,globedbg_llx,globedbg_lly,globedbg_urx,globedbg_ury);
                 checkPos(tearray[globedbg_pin2],0,globedbg_llx,globedbg_lly,globedbg_urx,globedbg_ury);
                 if(tearray[globedbg_pin1]->newy!=tearray[globedbg_pin2]->newy) then 
                 {
                     fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->newx,tearray[globedbg_pin1]->newy,tearray[globedbg_pin1]->newx-2,(tearray[globedbg_pin1]->newy+tearray[globedbg_pin2]->newy)/ 2,"green") and skip;
                     fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->newx-2,(tearray[globedbg_pin1]->newy+tearray[globedbg_pin2]->newy)/ 2,tearray[globedbg_pin2]->newx,tearray[globedbg_pin2]->newy,"green") and skip
                     
                 }
                 else
                 {
                     if((int)tearray[globedbg_pin1]->pinloc=-1) then 
                     {
                         globedbg_factor:=-1
                         
                     }
                     else
                     {
                         globedbg_factor:=1
                     };
                     fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->newx,tearray[globedbg_pin1]->newy,(tearray[globedbg_pin1]->newx+tearray[globedbg_pin2]->newx)/ 2,tearray[globedbg_pin2]->newy+globedbg_factor*globedbg_separation*3/ 4,"green") and skip;
                     fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,(tearray[globedbg_pin1]->newx+tearray[globedbg_pin2]->newx)/ 2,tearray[globedbg_pin2]->newy+globedbg_factor*globedbg_separation*3/ 4,tearray[globedbg_pin2]->newx,tearray[globedbg_pin2]->newy,"green") and skip
                 };
                 globedbg_term1:=tearray[globedbg_pin1]->terminal;
                 globedbg_curExtint:=tearray[globedbg_pin1]->extint;
                 globedbg_curTerm:=netarray[globedbg_net]->netptr;
                 
                 while(globedbg_curTerm)
                 {
                     if(globedbg_curTerm->extint=globedbg_curExtint AND globedbg_curTerm->terminal!=globedbg_term1) then 
                     {
                         if(globedbg_curTerm->unequiv) then 
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->newx,tearray[globedbg_pin1]->newy,globedbg_curTerm->newx-2,(globedbg_curTerm->newy+tearray[globedbg_pin1]->newy)/ 2,"blue") and skip;
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,globedbg_curTerm->newx,globedbg_curTerm->newy,globedbg_curTerm->newx-2,(globedbg_curTerm->newy+tearray[globedbg_pin1]->newy)/ 2,"blue") and skip
                         }
                         else
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->newx,tearray[globedbg_pin1]->newy,globedbg_curTerm->newx-2,(globedbg_curTerm->newy+tearray[globedbg_pin1]->newy)/ 2,"orange") and skip;
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,globedbg_curTerm->newx,globedbg_curTerm->newy,globedbg_curTerm->newx-2,(globedbg_curTerm->newy+tearray[globedbg_pin1]->newy)/ 2,"orange") and skip
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     globedbg_curTerm:=globedbg_curTerm->nterm
                     
                 };
                 globedbg_term1:=tearray[globedbg_pin2]->terminal;
                 globedbg_curExtint:=tearray[globedbg_pin2]->extint;
                 globedbg_curTerm:=netarray[globedbg_net]->netptr;
                 
                 while(globedbg_curTerm)
                 {
                     if(globedbg_curTerm->extint=globedbg_curExtint AND globedbg_curTerm->terminal!=globedbg_term1) then 
                     {
                         if(globedbg_curTerm->unequiv) then 
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin2]->newx,tearray[globedbg_pin2]->newy,globedbg_curTerm->newx-2,(globedbg_curTerm->newy+tearray[globedbg_pin2]->newy)/ 2,"blue") and skip;
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,globedbg_curTerm->newx,globedbg_curTerm->newy,globedbg_curTerm->newx-2,(globedbg_curTerm->newy+tearray[globedbg_pin2]->newy)/ 2,"blue") and skip
                         }
                         else
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin2]->newx,tearray[globedbg_pin2]->newy,globedbg_curTerm->newx-2,(globedbg_curTerm->newy+tearray[globedbg_pin2]->newy)/ 2,"orange") and skip;
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,globedbg_curTerm->newx,globedbg_curTerm->newy,globedbg_curTerm->newx-2,(globedbg_curTerm->newy+tearray[globedbg_pin2]->newy)/ 2,"orange") and skip
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     globedbg_curTerm:=globedbg_curTerm->nterm
                     
                 };
                 fprintf(globedbg_fpp,"%d, %d, %d, %d, %d, color: %s, label: %d\n",globedbg_net,tearray[globedbg_pin1]->newx-2,tearray[globedbg_pin1]->newy-2,tearray[globedbg_pin1]->newx+2,tearray[globedbg_pin1]->newy+2,"black",globedbg_pin1) and skip;
                 fprintf(globedbg_fpp,"%d, %d, %d, %d, %d, color: %s, label: %d\n",globedbg_net,tearray[globedbg_pin2]->newx-2,tearray[globedbg_pin2]->newy-2,tearray[globedbg_pin2]->newx+2,tearray[globedbg_pin2]->newy+2,"black",globedbg_pin2) and skip;
                 if(aNetSeg[globedbg_seg].ncurrent=0) then 
                 {
                     globedbg_sptr:=aNetSeg[globedbg_seg].ntop
                     
                 }
                 else
                 {
                     globedbg_sptr:=aNetSeg[globedbg_seg].nbot
                 };
                 globedbg_pin1:=globedbg_sptr->pin1;
                 globedbg_pin2:=globedbg_sptr->pin2;
                 if(tearray[globedbg_pin1]->ypos!=tearray[globedbg_pin2]->ypos) then 
                 {
                     fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->xpos,tearray[globedbg_pin1]->ypos,tearray[globedbg_pin2]->xpos,tearray[globedbg_pin2]->ypos,"red") and skip
                     
                 }
                 else
                 {
                     if((int)tearray[globedbg_pin1]->pinloc=-1) then 
                     {
                         globedbg_factor:=-1
                         
                     }
                     else
                     {
                         globedbg_factor:=1
                     };
                     fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->xpos,tearray[globedbg_pin1]->ypos,(tearray[globedbg_pin1]->xpos+tearray[globedbg_pin2]->xpos)/ 2,tearray[globedbg_pin2]->ypos+globedbg_factor*globedbg_separation,"red") and skip;
                     fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,(tearray[globedbg_pin1]->xpos+tearray[globedbg_pin2]->xpos)/ 2,tearray[globedbg_pin2]->ypos+globedbg_factor*globedbg_separation,tearray[globedbg_pin2]->xpos,tearray[globedbg_pin2]->ypos,"red") and skip
                 };
                 globedbg_term1:=tearray[globedbg_pin1]->terminal;
                 globedbg_curExtint:=tearray[globedbg_pin1]->extint;
                 globedbg_curTerm:=netarray[globedbg_net]->netptr;
                 
                 while(globedbg_curTerm)
                 {
                     if(globedbg_curTerm->extint=globedbg_curExtint AND globedbg_curTerm->terminal!=globedbg_term1) then 
                     {
                         if(globedbg_curTerm->unequiv) then 
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->xpos,tearray[globedbg_pin1]->ypos,globedbg_curTerm->xpos,globedbg_curTerm->ypos,"blue") and skip
                         }
                         else
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin1]->xpos,tearray[globedbg_pin1]->ypos,globedbg_curTerm->xpos,globedbg_curTerm->ypos,"orange") and skip
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     globedbg_curTerm:=globedbg_curTerm->nterm
                     
                 };
                 globedbg_term1:=tearray[globedbg_pin2]->terminal;
                 globedbg_curExtint:=tearray[globedbg_pin2]->extint;
                 globedbg_curTerm:=netarray[globedbg_net]->netptr;
                 
                 while(globedbg_curTerm)
                 {
                     if(globedbg_curTerm->extint=globedbg_curExtint AND globedbg_curTerm->terminal!=globedbg_term1) then 
                     {
                         if(globedbg_curTerm->unequiv) then 
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin2]->xpos,tearray[globedbg_pin2]->ypos,globedbg_curTerm->xpos,globedbg_curTerm->ypos,"blue") and skip
                         }
                         else
                         {
                             fprintf(globedbg_fp,"%d, %d, %d, %d, %d, color: %s\n",globedbg_net,tearray[globedbg_pin2]->xpos,tearray[globedbg_pin2]->ypos,globedbg_curTerm->xpos,globedbg_curTerm->ypos,"orange") and skip
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     globedbg_curTerm:=globedbg_curTerm->nterm
                     
                 };
                 fprintf(globedbg_fpp,"%d, %d, %d, %d, %d, color: %s, label: %d\n",globedbg_net,tearray[globedbg_pin1]->xpos-1,tearray[globedbg_pin1]->ypos-1,tearray[globedbg_pin1]->xpos+1,tearray[globedbg_pin1]->ypos+1,"white",globedbg_pin1) and skip;
                 fprintf(globedbg_fpp,"%d, %d, %d, %d, %d, color: %s, label: %d\n",globedbg_net,tearray[globedbg_pin2]->xpos-1,tearray[globedbg_pin2]->ypos-1,tearray[globedbg_pin2]->xpos+1,tearray[globedbg_pin2]->ypos+1,"white",globedbg_pin2) and skip
             };
             globedbg_seg:=globedbg_seg+1
             
         };
         globedbg_net:=globedbg_net+1
         
     };
     twclose(globedbg_fp);
     twclose(globedbg_fpp);
      return<==1 and skip
     )
     }; 
  function checkPos ( netbox* pin,int pos,int llx,int lly,int urx,int ury )
 {
     if(pos=1) then 
     {
         if(pin->xpos>urx) then 
         {
             output ("ERROR:pin xpos > urx ; set to urx ;") and skip;
             pin->xpos:=urx
             
         }
         else 
         {
              skip 
         };
         if(pin->xpos<llx) then 
         {
             output ("ERROR:pin xpos < llx ; set to llx ;") and skip;
             pin->xpos:=llx
             
         }
         else 
         {
              skip 
         };
         if(pin->ypos>ury) then 
         {
             output ("ERROR:pin ypos > ury ; set to ury ;") and skip;
             pin->ypos:=ury
             
         }
         else 
         {
              skip 
         };
         if(pin->ypos<lly) then 
         {
             output ("ERROR:pin ypos < lly ; set to lly ;") and skip;
             pin->ypos:=ury
             
         }
         else 
         {
              skip 
         }
     }
     else
     {
         if(pin->newx>urx) then 
         {
             output ("ERROR:pin newx > urx ; set to urx ;") and skip;
             pin->newx:=urx
             
         }
         else 
         {
              skip 
         };
         if(pin->newx<llx) then 
         {
             output ("ERROR:pin newx < llx ; set to llx ;") and skip;
             pin->newx:=llx
             
         }
         else 
         {
              skip 
         };
         if(pin->newy>ury) then 
         {
             output ("ERROR:pin newy > ury ; set to ury ;") and skip;
             pin->newy:=ury
             
         }
         else 
         {
              skip 
         };
         if(pin->newy<lly) then 
         {
             output ("ERROR:pin newy < lly ; set to lly ;") and skip;
             pin->newy:=ury
             
         }
         else 
         {
              skip 
         }
     }
     
 };
 function dumpEdgeArray ( int net )
 {
     frame(dumpEdgeArray_edge,dumpEdgeArray_fp,dumpEdgeArray_fpp,dumpEdgeArray_block,dumpEdgeArray_left,dumpEdgeArray_rite,dumpEdgeArray_bot,dumpEdgeArray_top,dumpEdgeArray_cell,dumpEdgeArray_g1,dumpEdgeArray_g2,dumpEdgeArray_llx,dumpEdgeArray_lly,dumpEdgeArray_urx,dumpEdgeArray_ury,dumpEdgeArray_cellptr) and ( 
     int dumpEdgeArray_edge and skip;
     FILE *dumpEdgeArray_fp,*dumpEdgeArray_fpp and skip;
     int dumpEdgeArray_block,dumpEdgeArray_left,dumpEdgeArray_rite,dumpEdgeArray_bot,dumpEdgeArray_top,dumpEdgeArray_cell,dumpEdgeArray_g1,dumpEdgeArray_g2 and skip;
     int dumpEdgeArray_llx,dumpEdgeArray_lly,dumpEdgeArray_urx,dumpEdgeArray_ury and skip;
     cellbox* dumpEdgeArray_cellptr and skip;
     dumpEdgeArray_fp:=twopen("cell.file","w",1,RValue);
     dumpEdgeArray_block:=1;
     
     while(dumpEdgeArray_block<=numblock)
     {
         dumpEdgeArray_left:=barray[dumpEdgeArray_block]->bxcenter+barray[dumpEdgeArray_block]->bleft;
         dumpEdgeArray_bot:=barray[dumpEdgeArray_block]->bycenter+barray[dumpEdgeArray_block]->bbottom;
         dumpEdgeArray_top:=barray[dumpEdgeArray_block]->bycenter+barray[dumpEdgeArray_block]->btop;
         if(pairArray[dumpEdgeArray_block,0]>0) then 
         {
             dumpEdgeArray_cell:=pairArray[dumpEdgeArray_block,pairArray[dumpEdgeArray_block,0]];
             dumpEdgeArray_rite:=carray[dumpEdgeArray_cell]->cxcenter+carray[dumpEdgeArray_cell]->tileptr->right
             
         }
         else
         {
             dumpEdgeArray_rite:=barray[dumpEdgeArray_block]->bxcenter+barray[dumpEdgeArray_block]->bright
         };
         fprintf(dumpEdgeArray_fp,"%d, %d, %d, %d, color: %s, label: row:%d\n",dumpEdgeArray_left,dumpEdgeArray_bot,dumpEdgeArray_rite,dumpEdgeArray_top,"aquamarine",dumpEdgeArray_block) and skip;
         dumpEdgeArray_block:=dumpEdgeArray_block+1
         
     };
     dumpEdgeArray_llx:=2147483647;
     dumpEdgeArray_lly:=2147483647;
     dumpEdgeArray_urx:=(-2147483647-1);
     dumpEdgeArray_ury:=(-2147483647-1);
     dumpEdgeArray_cell:=numcells+1;
     
     while(dumpEdgeArray_cell<=numcells+numterms)
     {
         dumpEdgeArray_cellptr:=carray[dumpEdgeArray_cell];
         dumpEdgeArray_left:=dumpEdgeArray_cellptr->cxcenter+dumpEdgeArray_cellptr->tileptr->left;
         dumpEdgeArray_rite:=dumpEdgeArray_cellptr->cxcenter+dumpEdgeArray_cellptr->tileptr->right;
         dumpEdgeArray_bot:=dumpEdgeArray_cellptr->cycenter+dumpEdgeArray_cellptr->tileptr->bottom;
         dumpEdgeArray_top:=dumpEdgeArray_cellptr->cycenter+dumpEdgeArray_cellptr->tileptr->top;
         fprintf(dumpEdgeArray_fp,"%d, %d, %d, %d, color: %s, label: pad:%s\n",dumpEdgeArray_left,dumpEdgeArray_bot,dumpEdgeArray_rite,dumpEdgeArray_top,"aquamarine",dumpEdgeArray_cellptr->cname) and skip;
         if(dumpEdgeArray_left<dumpEdgeArray_llx) then 
         {
             dumpEdgeArray_llx:=dumpEdgeArray_left
             
         }
         else 
         {
              skip 
         };
         if(dumpEdgeArray_rite>dumpEdgeArray_urx) then 
         {
             dumpEdgeArray_urx:=dumpEdgeArray_rite
             
         }
         else 
         {
              skip 
         };
         if(dumpEdgeArray_bot<dumpEdgeArray_lly) then 
         {
             dumpEdgeArray_lly:=dumpEdgeArray_bot
             
         }
         else 
         {
              skip 
         };
         if(dumpEdgeArray_top>dumpEdgeArray_ury) then 
         {
             dumpEdgeArray_ury:=dumpEdgeArray_top
             
         }
         else 
         {
              skip 
         };
         dumpEdgeArray_cell:=dumpEdgeArray_cell+1
         
     };
     twclose(dumpEdgeArray_fp);
     dumpEdgeArray_fp:=twopen("net.file","w",1,RValue);
     dumpEdgeArray_fpp:=twopen("pin.file","w",1,RValue);
     dumpEdgeArray_edge:=1;
     
     while(dumpEdgeArray_edge<=numEdges)
     {
         dumpEdgeArray_g1:=edgeArray[dumpEdgeArray_edge].group1;
         dumpEdgeArray_g2:=edgeArray[dumpEdgeArray_edge].group2;
         if(edgeArray[dumpEdgeArray_edge].marked=1) then 
         {
             fprintf(dumpEdgeArray_fp,"%d, %d, %d, %d, %d, color: %s, label:%d\n",net,groupArray[dumpEdgeArray_g1].aveX,groupArray[dumpEdgeArray_g1].aveY,groupArray[dumpEdgeArray_g2].aveX,groupArray[dumpEdgeArray_g2].aveY,"red",dumpEdgeArray_edge) and skip;
             fprintf(dumpEdgeArray_fpp,"%d, %d, %d, %d, %d, color: %s, label:G%d\n",net,groupArray[dumpEdgeArray_g1].aveX-1,groupArray[dumpEdgeArray_g1].aveY-1,groupArray[dumpEdgeArray_g1].aveX+1,groupArray[dumpEdgeArray_g1].aveY+1,"white",dumpEdgeArray_g1) and skip;
             fprintf(dumpEdgeArray_fpp,"%d, %d, %d, %d, %d, color: %s, label:G%d\n",net,groupArray[dumpEdgeArray_g2].aveX-1,groupArray[dumpEdgeArray_g2].aveY-1,groupArray[dumpEdgeArray_g2].aveX+1,groupArray[dumpEdgeArray_g2].aveY+1,"white",dumpEdgeArray_g2) and skip
             
         }
         else
         {
             fprintf(dumpEdgeArray_fp,"%d, %d, %d, %d, %d, color: %s, label:%d\n",net,groupArray[dumpEdgeArray_g1].aveX,groupArray[dumpEdgeArray_g1].aveY,groupArray[dumpEdgeArray_g2].aveX,groupArray[dumpEdgeArray_g2].aveY,"blue",dumpEdgeArray_edge) and skip;
             fprintf(dumpEdgeArray_fpp,"%d, %d, %d, %d, %d, color: %s, label:G%d\n",net,groupArray[dumpEdgeArray_g1].aveX-1,groupArray[dumpEdgeArray_g1].aveY-1,groupArray[dumpEdgeArray_g1].aveX+1,groupArray[dumpEdgeArray_g1].aveY+1,"black",dumpEdgeArray_g1) and skip;
             fprintf(dumpEdgeArray_fpp,"%d, %d, %d, %d, %d, color: %s, label:G%d\n",net,groupArray[dumpEdgeArray_g2].aveX-1,groupArray[dumpEdgeArray_g2].aveY-1,groupArray[dumpEdgeArray_g2].aveX+1,groupArray[dumpEdgeArray_g2].aveY+1,"black",dumpEdgeArray_g2) and skip
         };
         dumpEdgeArray_edge:=dumpEdgeArray_edge+1
         
     };
     twclose(dumpEdgeArray_fp);
     twclose(dumpEdgeArray_fpp)
     )
     }; 
      int attlimit and skip;
     

 
 
 

 switchbox *aNetSeg and skip;
 changrdbox* *Begin, **End and skip;
 tgridbox* *Tgrid and skip;
 densitybox* **Densebox,***DboxHead and skip;
 int *anet,*netchgs,*fixnetseg and skip;
 int numChans,numSegs,numSwSegs,tracks and skip;
 int *maxTrack,*nmaxTrack,max_tdensity and skip;
 function twopen ( char* a ,char* b ,char *c,FILE* RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
     return<==1 and RValue:=openFile(a,b,c,RValue);
     skip
     )
     }; 
  function globroute (  )
 {
     frame(globroute_fp,globroute_filename,globroute_attperseg,globroute_swSeg,globroute_flips,globroute_attempts,globroute_seg,globroute_breakpoint,globroute_stoppoint,globroute_found,globroute_segptr,globroute_denptr,globroute_gdptr,globroute_ptr1,globroute_ptr2,globroute_x,globroute_x1,globroute_x2,globroute_channel,globroute_track,count$,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     FILE *globroute_fp and skip;
     char globroute_filename[64] and skip;
     int globroute_attperseg and skip;
     int globroute_swSeg,globroute_flips,globroute_attempts,globroute_seg and skip;
     int globroute_breakpoint,globroute_stoppoint and skip;
     int globroute_found and skip;
     segbox* globroute_segptr and skip;
     densitybox* globroute_denptr and skip;
     changrdbox* globroute_gdptr,*globroute_ptr1,*globroute_ptr2 and skip;
     int globroute_x,globroute_x1,globroute_x2,globroute_channel,globroute_track and skip;
     globroute_attperseg:=40;
     randVar:=randomSeed2;
     fprintf(fpo,"\nThe rand generator seed was at globroute() : %d\n\n",randVar) and skip;
     sprintf(globroute_filename,"%s.twf",cktName,RValue) and skip;
     globroute_fp:=twopen(globroute_filename,"r",1,RValue);
     changrid();
     readseg(globroute_fp,RValue);
     twclose(globroute_fp);
     if(stage=3) then 
     {
         globroute_seg:=1;
         
         while(globroute_seg<=numSegs)
         {
             aNetSeg[globroute_seg].current:=fixarray[globroute_seg];
             globroute_seg:=globroute_seg+1
             
         }
         
     }
     else 
     {
          skip 
     };
     findrcost();
     fprintf(fpo,"\n\nTHIS IS THE ORIGINAL NUMBER OF TRACKS: %d\n\n\n",tracks) and skip;
     fflush(fpo) and skip;
     attlimit:=globroute_attperseg*numSwSegs;
     globroute_attempts:=0;
     globroute_flips:=0;
     globroute_stoppoint:=10*numSwSegs;
     globroute_breakpoint:=0;
     break$<==0 and skip;
     while( break$=0 AND  globroute_attempts<attlimit)
     {
         continue<==0 and skip;
         break$<==0 and skip;
         while( break$=0 AND  true)
         {
             int count$<==0 and skip;
             while( ( count$=0 OR globroute_swSeg=numSegs+1))
             {
                 count$:=count$+1;
                 globroute_swSeg:=(int)((float)numSegs*((float)(extern Yacm_random(RValue))/ (float)0x7fffffff))+1
             };
             if(aNetSeg[globroute_swSeg].swYorN=1 AND aNetSeg[globroute_swSeg].key=0) then 
             {
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             }
             
         };
         break$<==0 and skip;
         if(aNetSeg[globroute_swSeg].current=0) then 
         {
             globroute_segptr:=aNetSeg[globroute_swSeg].top
             
         }
         else
         {
             globroute_segptr:=aNetSeg[globroute_swSeg].bot
         };
         globroute_channel:=globroute_segptr->channel;
         globroute_ptr1:=globroute_segptr->pin1ptr;
         globroute_ptr2:=globroute_segptr->pin2ptr;
         globroute_x1:=globroute_ptr1->netptr->xpos;
         globroute_x2:=globroute_ptr2->netptr->xpos;
         globroute_found:=0;
         break$<==0 and skip;
         globroute_denptr:=DboxHead[globroute_channel,maxTrack[globroute_channel]]->next$;
         
         while( break$=0 AND  globroute_denptr!=NULL)
         {
             globroute_x:=globroute_denptr->grdptr->netptr->xpos;
             if(globroute_x1<=globroute_x AND globroute_x2>=globroute_x) then 
             {
                 globroute_found:=1;
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then
             {
                 globroute_denptr:=globroute_denptr->next$
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
         if(!globroute_found) then 
         {
             if((globroute_breakpoint+1)>globroute_stoppoint) then 
             {
                 globroute_breakpoint:=globroute_breakpoint+1;
                 break$<==1 and skip
                  
             }
             else 
             {
                 globroute_breakpoint:=globroute_breakpoint+1
                 
             };
             if(break$=0)   then
             {
                 globroute_attempts:=globroute_attempts+1;
                 continue<==1 and skip
              }
             else
             {
                 skip
             }
             
         }
         else 
         {
              skip 
         };
         if(break$=0)   then 
         {
             if(continue=0)   then 
             {
                 if(extern urcost(globroute_swSeg,RValue)) then 
                 {
                     globroute_flips:=globroute_flips+1;
                     globroute_attempts:=globroute_attempts+1;
                     globroute_breakpoint:=0
                 }
                 else
                 {
                     if((globroute_breakpoint+1)>globroute_stoppoint) then 
                     {
                         globroute_breakpoint:=globroute_breakpoint+1;
                         break$<==1 and skip
                          
                     }
                     else 
                     {
                         globroute_breakpoint:=globroute_breakpoint+1
                         
                     };
                     if(break$=0)   then
                     {
                         globroute_attempts:=globroute_attempts+1
                     }
                     else
                     {
                         skip
                     }
                 }
                 
             }
			 else
                 {
                     skip
                 }
         }
         else
         {
             skip
         }
     };
     break$<==0 and skip;
     continue<==0 and skip;
     globroute_channel:=1;
     
     while(globroute_channel<=numChans)
     {
         globroute_gdptr:=Begin[globroute_channel];
         
         while(globroute_gdptr!=NULL)
         {
             globroute_gdptr->ntracks:=globroute_gdptr->tracks;
             globroute_gdptr->nSegType:=globroute_gdptr->SegType;
             globroute_gdptr->nnextgrd:=globroute_gdptr->nextgrd;
             globroute_gdptr->nprevgrd:=globroute_gdptr->prevgrd;
             globroute_gdptr->netptr->newx:=globroute_gdptr->netptr->xpos;
             globroute_gdptr->netptr->newy:=globroute_gdptr->netptr->ypos;
             globroute_gdptr:=globroute_gdptr->nextgrd
             
         };
         globroute_track:=0;
         
         while(globroute_track<=max_tdensity+100)
         {
             globroute_denptr:=DboxHead[globroute_channel,globroute_track];
             
             while(globroute_denptr!=NULL)
             {
                 globroute_denptr->nnext:=globroute_denptr->next$;
                 globroute_denptr->nback:=globroute_denptr->back;
                 globroute_denptr:=globroute_denptr->next$
                 
             };
             globroute_track:=globroute_track+1
             
         };
         nmaxTrack[globroute_channel]:=maxTrack[globroute_channel];
         globroute_channel:=globroute_channel+1
         
     };
     fprintf(fpo,"no. of accepted flips: %d\n",globroute_flips) and skip;
     fprintf(fpo,"no. of attempted flips: %d\n",globroute_attempts) and skip;
     if(numSwSegs!=0) then 
     {
         fprintf(fpo,"no. of attempted flips / numSwSegs: %.1f\n",(float)globroute_attempts/ (float)numSwSegs) and skip
         
     }
     else 
     {
          skip 
     };
     fprintf(fpo,"THIS IS THE NUMBER OF TRACKS: %d\n\n\n",tracks) and skip;
     fflush(fpo) and skip;
      return<==1 and skip
     )
     }; 
      int *top_row_for_this_net and skip;
     int *bot_row_for_this_net and skip;
     char **pinnames and skip;
 function gparser ( FILE *fp )
 {
     frame(gparser_cell,gparser_term,gparser_pinctr,gparser_i,gparser_layer,gparser_block,gparser_left,gparser_right,gparser_bottom,gparser_top,gparser_xpos,gparser_ypos,gparser_orient,gparser_from,gparser_space,gparser_input$,gparser_netname,gparser_nptr,gparser_zapptr,gparser_ptr,gparser_cptr,gparser_koptr,return) and ( 
     int return<==0 and skip;
     int gparser_cell,gparser_term,gparser_pinctr,gparser_i,gparser_layer and skip;
     int gparser_block,gparser_left,gparser_right,gparser_bottom,gparser_top and skip;
     int gparser_xpos,gparser_ypos,gparser_orient and skip;
     int gparser_from and skip;
     float gparser_space and skip;
     char gparser_input$[1024] and skip;
     char gparser_netname[1024] and skip;
     netbox* gparser_nptr,*gparser_zapptr and skip;
     cellbox* gparser_ptr and skip;
     termbox* gparser_cptr,*gparser_koptr and skip;
     gparser_cell:=0;
     gparser_pinctr:=0;
     netctr:=0;
     maketabl(RValue);
     while(fscanf(fp," %s ",gparser_input$)=1)
     {
         if(strcmp(gparser_input$,"cell")=0) then 
         {
             gparser_cell:=gparser_cell+1;
             fscanf(fp," %s ",gparser_input$) and skip;
             fscanf(fp," %s ",gparser_input$) and skip;
             fscanf(fp," %s ",gparser_input$) and skip;
             fscanf(fp," %d ",&gparser_block) and skip
         }
         else
         {
             if(strcmp(gparser_input$,"initially")=0) then 
             {
                 fscanf(fp," %s ",gparser_input$) and skip;
                 fscanf(fp," %d ",&gparser_from) and skip;
                 fscanf(fp," %s ",gparser_input$) and skip;
                 fscanf(fp," %s ",gparser_input$) and skip;
                 fscanf(fp," %s ",gparser_input$) and skip;
                 fscanf(fp," %s ",gparser_input$) and skip;
                 fscanf(fp," %d ",&gparser_block) and skip
             }
             else
             {
                 if(strcmp(gparser_input$,"nomirror")=0) then 
                 {
				  skip
                 }
                 else
                 {
                     if(strcmp(gparser_input$,"left")=0) then 
                     {
                         fscanf(fp," %d ",&gparser_left) and skip;
                         fscanf(fp," %s ",gparser_input$) and skip;
                         fscanf(fp," %d ",&gparser_right) and skip;
                         fscanf(fp," %s ",gparser_input$) and skip;
                         fscanf(fp," %d ",&gparser_bottom) and skip;
                         fscanf(fp," %s ",gparser_input$) and skip;
                         fscanf(fp," %d ",&gparser_top) and skip
                     }
                     else
                     {
                         if(strcmp(gparser_input$,"pin")=0) then 
                         {
                             fscanf(fp," %s ",gparser_input$) and skip;
                             fscanf(fp," %s ",gparser_input$) and skip;
                             fscanf(fp," %s ",gparser_input$) and skip;
                             fscanf(fp," %s ",gparser_input$) and skip;
                             strcpy(gparser_netname,gparser_input$) and skip;
                             if(strcmp(gparser_input$,"TW_PASS_THRU")!=0) then 
                             {
                                 gparser_pinctr:=gparser_pinctr+1;
                                 addhash(gparser_input$,RValue)
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(pin_layers_given!=0) then 
                             {
                                 fscanf(fp," %s ",gparser_input$) and skip;
                                 fscanf(fp," %d ",&gparser_layer) and skip
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             fscanf(fp," %d %d ",&gparser_xpos,&gparser_ypos) and skip
                         }
                         else
                         {
                             if(strcmp(gparser_input$,"equiv")=0) then 
                             {
                                 fscanf(fp," %s ",gparser_input$) and skip;
                                 fscanf(fp," %s ",gparser_input$) and skip;
                                 if(pin_layers_given!=0) then 
                                 {
                                     fscanf(fp," %s ",gparser_input$) and skip;
                                     fscanf(fp," %d ",&gparser_layer) and skip
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 fscanf(fp," %d %d ",&gparser_xpos,&gparser_ypos) and skip;
                                 if(strcmp(gparser_netname,"TW_PASS_THRU")!=0) then 
                                 {
                                     gparser_pinctr:=gparser_pinctr+1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                             else
                             {
                                 if(strcmp(gparser_input$,"unequiv")=0) then 
                                 {
                                     fscanf(fp," %s ",gparser_input$) and skip;
                                     fscanf(fp," %s ",gparser_input$) and skip;
                                     if(pin_layers_given!=0) then 
                                     {
                                         fscanf(fp," %s ",gparser_input$) and skip;
                                         fscanf(fp," %d ",&gparser_layer) and skip
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     fscanf(fp," %d %d ",&gparser_xpos,&gparser_ypos) and skip;
                                     gparser_pinctr:=gparser_pinctr+1
                                 }
                                 else
                                 {
                                     if(strcmp(gparser_input$,"pad")=0) then 
                                     {
                                         fscanf(fp," %s ",gparser_input$) and skip;
                                         fscanf(fp," %s ",gparser_input$) and skip;
                                         fscanf(fp," %s ",gparser_input$) and skip;
                                         fscanf(fp," %d ",&gparser_orient) and skip;
                                         fscanf(fp," %s ",gparser_input$) and skip;
                                         fscanf(fp," %d ",gparser_input$) and skip;
                                         fscanf(fp," %s ",gparser_input$) and skip;
                                         fscanf(fp," %d ",&gparser_left) and skip;
                                         fscanf(fp," %s ",gparser_input$) and skip;
                                         fscanf(fp," %d ",&gparser_right) and skip;
                                         fscanf(fp," %s ",gparser_input$) and skip;
                                         fscanf(fp," %d ",&gparser_bottom) and skip;
                                         fscanf(fp," %s ",gparser_input$) and skip;
                                         fscanf(fp," %d ",&gparser_top) and skip
                                     }
                                     else
                                     {
                                         if(strcmp(gparser_input$,"sidespace")=0) then 
                                         {
                                             fscanf(fp," %f ",&gparser_space) and skip
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     }
                                 }
                             }
                         }
                     }
                 }
             }
         }
     };
     rewind(fp) and skip;
     top_row_for_this_net:=(int *)safe_malloc((numnets+1)*sizeof(int),RValue);
     bot_row_for_this_net:=(int *)safe_malloc((numnets+1)*sizeof(int),RValue);
     gparser_i:=1;
     
     while(gparser_i<=numnets)
     {
         top_row_for_this_net[gparser_i]:=-1;
         bot_row_for_this_net[gparser_i]:=10000000;
         gparser_i:=gparser_i+1
         
     };
     insert_row(1,RValue);
     gparser_i:=1;
     
     while(gparser_i<=numnets)
     {
         gparser_nptr:=netarray[gparser_i]->netptr;
         while(gparser_nptr)
         {
             if(gparser_nptr->row>top_row_for_this_net[gparser_i]) then 
             {
                 top_row_for_this_net[gparser_i]:=gparser_nptr->row
                 
             }
             else 
             {
                  skip 
             };
             if(gparser_nptr->row<bot_row_for_this_net[gparser_i]) then 
             {
                 bot_row_for_this_net[gparser_i]:=gparser_nptr->row
                 
             }
             else 
             {
                  skip 
             };
             gparser_nptr:=gparser_nptr->nterm
             
         };
         gparser_i:=gparser_i+1
         
     };
     gparser_i:=1;
     
     while(gparser_i<=numnets)
     {
         gparser_nptr:=netarray[gparser_i]->netptr;
         netarray[gparser_i]->netptr:=NULL;
         if(gparser_nptr!=NULL) then 
         {
             gparser_zapptr:=gparser_nptr;
             while(gparser_nptr->nterm!=NULL)
             {
                 gparser_nptr:=gparser_nptr->nterm;
                 safe_free(gparser_zapptr,RValue);
                 gparser_zapptr:=gparser_nptr
             };
             safe_free(gparser_nptr,RValue)
             
         }
         else 
         {
              skip 
         };
         gparser_i:=gparser_i+1
         
     };
     safe_free(tearray,RValue);
     tearray:=(netbox* *)safe_malloc((gparser_pinctr+1)*sizeof(netbox*),RValue);
     gparser_term:=1;
     
     while(gparser_term<=gparser_pinctr)
     {
         tearray[gparser_term]:=NULL;
         gparser_term:=gparser_term+1
         
     };
     maxterm:=gparser_pinctr;
     pinnames:=(char **)safe_malloc((gparser_pinctr+1)*sizeof(char *),RValue);
     gparser_cell:=1;
     
     while(gparser_cell<=numcells+numterms)
     {
         gparser_ptr:=carray[gparser_cell];
         gparser_ptr->numterms:=0;
         gparser_cptr:=gparser_ptr->tileptr->termsptr;
         gparser_ptr->tileptr->termsptr:=NULL;
         if(gparser_cptr!=NULL) then 
         {
             gparser_koptr:=gparser_cptr;
             while(gparser_cptr->nextterm!=NULL)
             {
                 gparser_cptr:=gparser_cptr->nextterm;
                 safe_free(gparser_koptr,RValue);
                 gparser_koptr:=gparser_cptr
             };
             safe_free(gparser_cptr,RValue)
             
         }
         else 
         {
              skip 
         };
         gparser_cell:=gparser_cell+1
         
     };
      return<==1 and skip
     )
     }; 


 struct impbox {
 int x and 
 struct impbox* next_pin 
 };
 struct celltype {
 struct celltype* next_cell and 
 char *name and 
 struct impbox* first_imp 
 };
 celltype *head_type,*active_cell_type and skip;
 impbox *pin_ptr and skip;
 int active_type and skip;
 function grdcell ( FILE *fp )
 {
     frame(grdcell_i,grdcell_cell,grdcell_orient,grdcell_corient,grdcell_block,grdcell_left,grdcell_right,grdcell_bottom,grdcell_top,grdcell_xpos,grdcell_ypos,grdcell_pinctr,grdcell_netx,grdcell_from,grdcell_pick_top_pin,grdcell_hack_off_a_pin,grdcell_terms,grdcell_net,grdcell_extint,grdcell_layer,grdcell_input$,grdcell_netname,grdcell_pname,grdcell_space,grdcell_ptr,grdcell_tile,grdcell_tptr,grdcell_term,grdcell_tmptr,grdcell_netptr,grdcell_termptr,grdcell_saveptr,grdcell_1_4_6_8_10_12_14_16_17_18_temp$_1,grdcell_1_4_6_8_10_12_14_16_30_31_34_temp$_2,grdcell_1_4_6_8_10_12_14_16_30_37_38_55_temp$_3,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     int grdcell_i,grdcell_cell,grdcell_orient,grdcell_corient and skip;
     int grdcell_block,grdcell_left,grdcell_right,grdcell_bottom,grdcell_top and skip;
     int grdcell_xpos,grdcell_ypos,grdcell_pinctr,grdcell_netx and skip;
     int grdcell_from,grdcell_pick_top_pin,grdcell_hack_off_a_pin and skip;
     int grdcell_terms,grdcell_net and skip;
     int grdcell_extint,grdcell_layer and skip;
     char grdcell_input$[1024] and skip;
     char grdcell_netname[1024] and skip;
     char grdcell_pname[1024] and skip;
     float grdcell_space and skip;
     cellbox* grdcell_ptr and skip;
     tilebox* grdcell_tile,*grdcell_tptr and skip;
     termbox* grdcell_term,*grdcell_tmptr and skip;
     netbox* grdcell_netptr,*grdcell_termptr,*grdcell_saveptr and skip;
     gparser(fp);
     impFeeds:=(ibox* *)safe_malloc((numRows+1)*sizeof(ibox*),RValue);
     grdcell_i:=1;
     
     while(grdcell_i<=numRows)
     {
         impFeeds[grdcell_i]:=(ibox*)NULL;
         grdcell_i:=grdcell_i+1
         
     };
     grdcell_cell:=0;
     grdcell_terms:=0;
     grdcell_pinctr:=0;
     grdcell_extint:=0;
     while(fscanf(fp," %s ",grdcell_input$)=1)
     {
         continue<==0 and skip;
         if(strcmp(grdcell_input$,"cell")=0) then 
         {
             grdcell_cell:=grdcell_cell+1;
             grdcell_ptr:=carray[grdcell_cell];
             fscanf(fp," %s ",grdcell_input$) and skip;
             fscanf(fp," %s ",grdcell_input$) and skip;
             if(gate_array_special) then 
             {
                 active_type:=add_type(grdcell_input$,RValue)
                 
             }
             else 
             {
                  skip 
             }
         }
         else
         {
             if(strcmp(grdcell_input$,"initially")=0) then 
             {
                 fscanf(fp," %s ",grdcell_input$) and skip;
                 fscanf(fp," %d ",&grdcell_from) and skip;
                 fscanf(fp," %s ",grdcell_input$) and skip;
                 fscanf(fp," %s ",grdcell_input$) and skip;
                 fscanf(fp," %s ",grdcell_input$) and skip;
                 fscanf(fp," %s ",grdcell_input$) and skip;
                 fscanf(fp," %d ",&grdcell_block) and skip
             }
             else
             {
                 if(strcmp(grdcell_input$,"nomirror")=0) then 
                 {
				  skip
                 }
                 else
                 {
                     if(strcmp(grdcell_input$,"left")=0) then 
                     {
                         grdcell_tile:=grdcell_ptr->tileptr;
                         fscanf(fp," %d ",&grdcell_left) and skip
                     }
                     else
                     {
                         if(strcmp(grdcell_input$,"right")=0) then 
                         {
                             fscanf(fp," %d ",&grdcell_right) and skip
                         }
                         else
                         {
                             if(strcmp(grdcell_input$,"bottom")=0) then 
                             {
                                 fscanf(fp," %d ",&grdcell_bottom) and skip
                             }
                             else
                             {
                                 if(strcmp(grdcell_input$,"top")=0) then 
                                 {
                                     fscanf(fp," %d ",&grdcell_top) and skip
                                 }
                                 else
                                 {
                                     if(strcmp(grdcell_input$,"pin")=0) then 
                                     {
                                         fscanf(fp," %s ",grdcell_input$) and skip;
                                         fscanf(fp," %s ",grdcell_input$) and skip;
                                         strcpy(grdcell_pname,grdcell_input$) and skip;
                                         fscanf(fp," %s ",grdcell_input$) and skip;
                                         fscanf(fp," %s ",grdcell_input$) and skip;
                                         strcpy(grdcell_netname,grdcell_input$) and skip;
                                         if(strcmp(grdcell_netname,"TW_PASS_THRU")!=0) then 
                                         {
                                             grdcell_pinctr:=grdcell_pinctr+1;
                                             grdcell_extint:=grdcell_extint+1;
                                             int grdcell_1_4_6_8_10_12_14_16_17_18_temp$_1 and skip;
                                             grdcell_1_4_6_8_10_12_14_16_17_18_temp$_1:=strlen(grdcell_pname);
                                             pinnames[grdcell_pinctr]:=(char *)safe_malloc((grdcell_1_4_6_8_10_12_14_16_17_18_temp$_1+1)*sizeof(char),RValue);
                                             sprintf(pinnames[grdcell_pinctr],"%s",grdcell_pname,RValue) and skip;
                                             grdcell_netx:=hashfind(grdcell_input$,RValue);
                                             if((grdcell_ptr->numterms+1)=1) then 
                                             {
                                                 grdcell_ptr->numterms:=grdcell_ptr->numterms+1;
                                                 grdcell_tile->termsptr:=(termbox*)safe_malloc(sizeof(termbox),RValue) ; 
												 grdcell_term<==grdcell_tile->termsptr and skip
                                                 
                                             }
                                             else
                                             {
                                                 grdcell_ptr->numterms:=grdcell_ptr->numterms+1;
                                                 grdcell_term->nextterm:=(termbox*)safe_malloc(sizeof(termbox),RValue); 
												 grdcell_term<==grdcell_term->nextterm and skip
                                             };
                                             grdcell_term->nextterm:=NULL;
                                             grdcell_term->cellterm:=grdcell_pinctr;
                                             grdcell_term->ei:=grdcell_extint;
                                             grdcell_term->ue:=0;
                                             grdcell_saveptr:=netarray[grdcell_netx]->netptr;
                                             netarray[grdcell_netx]->netptr:=(netbox*)safe_malloc(sizeof(netbox),RValue); 
											 grdcell_netptr<==netarray[grdcell_netx]->netptr and skip;
                                             grdcell_netptr->nterm:=grdcell_saveptr;
                                             grdcell_netptr->terminal:=grdcell_pinctr;
                                             if(grdcell_terms=0) then 
                                             {
                                                 grdcell_netptr->cell:=grdcell_cell
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             grdcell_netptr->net:=grdcell_netx;
                                             grdcell_netptr->xpos:=0;
                                             grdcell_netptr->ypos:=0;
                                             grdcell_netptr->newx:=0;
                                             grdcell_netptr->newy:=0;
                                             grdcell_netptr->flag:=0;
                                             grdcell_netptr->unequiv:=0;
                                             if(pin_layers_given!=0) then 
                                             {
                                                 fscanf(fp," %s ",grdcell_input$) and skip;
                                                 fscanf(fp," %d ",&grdcell_layer) and skip
                                                 
                                             }
                                             else
                                             {
                                                 grdcell_layer:=1
                                             };
                                             fscanf(fp," %d %d ",&grdcell_xpos,&grdcell_ypos) and skip;
                                             grdcell_netptr->layer:=grdcell_layer-1;
                                             grdcell_term->txpos[0]:=grdcell_xpos;
                                             grdcell_term->typos[0]:=grdcell_ypos
                                         }
                                         else
                                         {
                                             if(pin_layers_given!=0) then 
                                             {
                                                 fscanf(fp," %s ",grdcell_input$) and skip;
                                                 fscanf(fp," %d ",&grdcell_layer) and skip
                                                 
                                             }
                                             else
                                             {
                                                 grdcell_layer:=1
                                             };
                                             fscanf(fp," %d %d ",&grdcell_xpos,&grdcell_ypos) and skip;
                                             if(one_pin_feedthru) then 
                                             {
                                                 buildimp(grdcell_cell,grdcell_xpos,grdcell_top,grdcell_pname,1,grdcell_layer-1);
                                                 buildimp(grdcell_cell,grdcell_xpos,grdcell_bottom,grdcell_pname,0,grdcell_layer-1)
                                                 
                                             }
                                             else
                                             {
                                                 buildimp(grdcell_cell,grdcell_xpos,grdcell_ypos,grdcell_pname,1,grdcell_layer-1)
                                             };
                                             if(gate_array_special AND active_type) then 
                                             {
                                                 add_pin(grdcell_xpos,RValue)
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                         }
                                     }
                                     else
                                     {
                                         if(strcmp(grdcell_input$,"equiv")=0) then 
                                         {
                                             fscanf(fp," %s ",grdcell_input$) and skip;
                                             fscanf(fp," %s ",grdcell_input$) and skip;
                                             strcpy(grdcell_pname,grdcell_input$) and skip;
                                             if(pin_layers_given!=0) then 
                                             {
                                                 fscanf(fp," %s ",grdcell_input$) and skip;
                                                 fscanf(fp," %d ",&grdcell_layer) and skip
                                                 
                                             }
                                             else
                                             {
                                                 grdcell_layer:=1
                                             };
                                             fscanf(fp," %d %d ",&grdcell_xpos,&grdcell_ypos) and skip;
                                             if(strcmp(grdcell_netname,"TW_PASS_THRU")!=0) then 
                                             {
                                                 grdcell_pinctr:=grdcell_pinctr+1;
                                                 int grdcell_1_4_6_8_10_12_14_16_30_31_34_temp$_2 and skip;
                                                 grdcell_1_4_6_8_10_12_14_16_30_31_34_temp$_2:=strlen(grdcell_pname);
                                                 pinnames[grdcell_pinctr]:=(char *)safe_malloc((grdcell_1_4_6_8_10_12_14_16_30_31_34_temp$_2+1)*sizeof(char),RValue);
                                                 sprintf(pinnames[grdcell_pinctr],"%s",grdcell_pname,RValue) and skip;
                                                 grdcell_ptr->numterms:=grdcell_ptr->numterms+1;
                                                 grdcell_term->nextterm:=(termbox*)safe_malloc(sizeof(termbox),RValue);
												 grdcell_term<==grdcell_term->nextterm and skip;
                                                 grdcell_term->nextterm:=NULL;
                                                 grdcell_term->cellterm:=grdcell_pinctr;
                                                 grdcell_term->ei:=grdcell_extint;
                                                 grdcell_term->ue:=0;
                                                 grdcell_saveptr:=netarray[grdcell_netx]->netptr;
                                                 netarray[grdcell_netx]->netptr:=(netbox*)safe_malloc(sizeof(netbox),RValue);
												 grdcell_netptr<==netarray[grdcell_netx]->netptr and skip;
                                                 grdcell_netptr->nterm:=grdcell_saveptr;
                                                 grdcell_netptr->terminal:=grdcell_pinctr;
                                                 grdcell_netptr->net:=grdcell_netx;
                                                 if(grdcell_terms=0) then 
                                                 {
                                                     grdcell_netptr->cell:=grdcell_cell
                                                     
                                                 }
                                                 else 
                                                 {
                                                      skip 
                                                 };
                                                 grdcell_netptr->xpos:=0;
                                                 grdcell_netptr->ypos:=0;
                                                 grdcell_netptr->newx:=0;
                                                 grdcell_netptr->newy:=0;
                                                 grdcell_netptr->flag:=0;
                                                 grdcell_netptr->unequiv:=0;
                                                 grdcell_netptr->layer:=grdcell_layer-1;
                                                 grdcell_term->txpos[0]:=grdcell_xpos;
                                                 grdcell_term->typos[0]:=grdcell_ypos
                                             }
                                             else
                                             {
                                                 buildimp(grdcell_cell,grdcell_xpos,grdcell_ypos,grdcell_pname,0,grdcell_layer-1)
                                             }
                                         }
                                         else
                                         {
                                             if(strcmp(grdcell_input$,"unequiv")=0) then 
                                             {
                                                 fscanf(fp," %s ",grdcell_input$) and skip;
                                                 fscanf(fp," %s ",grdcell_input$) and skip;
                                                 strcpy(grdcell_pname,grdcell_input$) and skip;
                                                 if(pin_layers_given!=0) then 
                                                 {
                                                     fscanf(fp," %s ",grdcell_input$) and skip;
                                                     fscanf(fp," %d ",&grdcell_layer) and skip
                                                     
                                                 }
                                                 else
                                                 {
                                                     grdcell_layer:=1
                                                 };
                                                 fscanf(fp," %d %d ",&grdcell_xpos,&grdcell_ypos) and skip;
                                                 grdcell_hack_off_a_pin:=0;
                                                 if(netarray[grdcell_netx]->numpins>=10) then 
                                                 {
                                                     grdcell_hack_off_a_pin:=1;
                                                     if(top_row_for_this_net[grdcell_netx] % 2=0) then 
                                                     {
                                                         if(carray[grdcell_cell]->cblock!=bot_row_for_this_net[grdcell_netx]) then 
                                                         {
                                                             if(carray[grdcell_cell]->cblock % 2=0) then 
                                                             {
                                                                 grdcell_pick_top_pin:=0
                                                             }
                                                             else
                                                             {
                                                                 grdcell_pick_top_pin:=1
                                                             }
                                                         }
                                                         else
                                                         {
                                                             grdcell_pick_top_pin:=1
                                                         }
                                                         
                                                     }
                                                     else
                                                     {
                                                         if(carray[grdcell_cell]->cblock!=bot_row_for_this_net[grdcell_netx]) then 
                                                         {
                                                             if(carray[grdcell_cell]->cblock % 2=1) then 
                                                             {
                                                                 grdcell_pick_top_pin:=0
                                                             }
                                                             else
                                                             {
                                                                 grdcell_pick_top_pin:=1
                                                             }
                                                         }
                                                         else
                                                         {
                                                             grdcell_pick_top_pin:=1
                                                         }
                                                     };
                                                     if(barray[carray[grdcell_cell]->cblock]->borient=2) then 
                                                     {
                                                         if(grdcell_pick_top_pin=0) then 
                                                         {
                                                             grdcell_pick_top_pin:=1
                                                         }
                                                         else
                                                         {
                                                             grdcell_pick_top_pin:=0
                                                         }
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                     
                                                 }
                                                 else 
                                                 {
                                                      skip 
                                                 };
                                                 if(grdcell_hack_off_a_pin=0) then 
                                                 {
                                                     grdcell_pinctr:=grdcell_pinctr+1;
                                                     int grdcell_1_4_6_8_10_12_14_16_30_37_38_55_temp$_3 and skip;
                                                     grdcell_1_4_6_8_10_12_14_16_30_37_38_55_temp$_3:=strlen(grdcell_pname);
                                                     pinnames[grdcell_pinctr]:=(char *)safe_malloc((grdcell_1_4_6_8_10_12_14_16_30_37_38_55_temp$_3+1)*sizeof(char),RValue);
                                                     sprintf(pinnames[grdcell_pinctr],"%s",grdcell_pname,RValue) and skip;
                                                     grdcell_ptr->numterms:=grdcell_ptr->numterms+1;
                                                     grdcell_term->ue:=1;
                                                     grdcell_term->nextterm:=(termbox*)safe_malloc(sizeof(termbox),RValue); 
													 grdcell_term<==grdcell_term->nextterm and skip;
                                                     grdcell_term->nextterm:=NULL;
                                                     grdcell_term->cellterm:=grdcell_pinctr;
                                                     grdcell_term->ei:=grdcell_extint;
                                                     grdcell_term->ue:=1;
                                                     grdcell_saveptr:=netarray[grdcell_netx]->netptr;
                                                     grdcell_saveptr->unequiv:=1;
                                                     netarray[grdcell_netx]->netptr:=(netbox*)safe_malloc(sizeof(netbox),RValue);
													 grdcell_netptr<==netarray[grdcell_netx]->netptr and skip;
                                                     grdcell_netptr->nterm:=grdcell_saveptr;
                                                     grdcell_netptr->terminal:=grdcell_pinctr;
                                                     grdcell_netptr->net:=grdcell_netx;
                                                     if(grdcell_terms=0) then 
                                                     {
                                                         grdcell_netptr->cell:=grdcell_cell
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     };
                                                     grdcell_netptr->xpos:=0;
                                                     grdcell_netptr->ypos:=0;
                                                     grdcell_netptr->newx:=0;
                                                     grdcell_netptr->newy:=0;
                                                     grdcell_netptr->flag:=0;
                                                     grdcell_netptr->unequiv:=1;
                                                     grdcell_netptr->layer:=grdcell_layer-1;
                                                     grdcell_term->txpos[0]:=grdcell_xpos;
                                                     grdcell_term->typos[0]:=grdcell_ypos
                                                 }
                                                 else
                                                 {
                                                     if(grdcell_ypos<-1 AND grdcell_pick_top_pin=1 OR grdcell_ypos>1 AND grdcell_pick_top_pin=0) then 
                                                     {
                                                         continue<==1 and skip
                                                      }
                                                     else
                                                     {
                                                         sprintf(pinnames[grdcell_pinctr],"%s",grdcell_pname,RValue) and skip;
                                                         grdcell_term->txpos[0]:=grdcell_xpos;
                                                         grdcell_term->typos[0]:=grdcell_ypos
                                                     }
                                                 }
                                             }
                                             else
                                             {
                                                 if(strcmp(grdcell_input$,"pad")=0) then 
                                                 {
                                                     grdcell_terms:=grdcell_terms+1;
                                                     fscanf(fp," %s ",grdcell_input$) and skip;
                                                     fscanf(fp," %s ",grdcell_input$) and skip;
                                                     grdcell_ptr:=carray[numcells+grdcell_terms]
                                                 }
                                                 else
                                                 {
                                                     if(strcmp(grdcell_input$,"orient")=0) then 
                                                     {
                                                         fscanf(fp," %d ",&grdcell_orient) and skip
                                                     }
                                                     else
                                                     {
                                                         if(strcmp(grdcell_input$,"padside")=0) then 
                                                         {
                                                             fscanf(fp," %s ",grdcell_input$) and skip
                                                         }
                                                         else
                                                         {
                                                             if(strcmp(grdcell_input$,"sidespace")=0) then 
                                                             {
                                                                 fscanf(fp," %f ",&grdcell_space) and skip
                                                                 
                                                             }
                                                             else 
                                                             {
                                                                  skip 
                                                             }
                                                         }
                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }
                     }
                 }
             }
         }
     };
     continue<==0 and skip;
     safe_free(top_row_for_this_net,RValue);
     delHtab(RValue);
     grdcell_net:=1;
     
     while(grdcell_net<=numnets)
     {
         grdcell_netptr:=netarray[grdcell_net]->netptr;
         
         while(grdcell_netptr!=NULL)
         {
             tearray[grdcell_netptr->terminal]:=grdcell_netptr;
             grdcell_netptr:=grdcell_netptr->nterm
             
         };
         grdcell_net:=grdcell_net+1
         
     };
     grdcell_cell:=1;
     
     while(grdcell_cell<=numcells)
     {
         grdcell_ptr:=carray[grdcell_cell];
         grdcell_tptr:=grdcell_ptr->tileptr;
         grdcell_tmptr:=grdcell_tptr->termsptr;
         
         while(grdcell_tmptr!=NULL)
         {
             if((grdcell_ptr->clength % 2!=0)) then 
             {
                 grdcell_tmptr->txpos[1]:=-grdcell_tmptr->txpos[0]+1
                 
             }
             else
             {
                 grdcell_tmptr->txpos[1]:=-grdcell_tmptr->txpos[0]
             };
             if((grdcell_ptr->cheight % 2!=0)) then 
             {
                 grdcell_tmptr->typos[1]:=-grdcell_tmptr->typos[0]+1
                 
             }
             else
             {
                 grdcell_tmptr->typos[1]:=-grdcell_tmptr->typos[0]
             };
             grdcell_tmptr:=grdcell_tmptr->nextterm
             
         };
         grdcell_cell:=grdcell_cell+1
         
     };
     grdcell_cell:=numcells+1;
     
     while(grdcell_cell<=numcells+numterms)
     {
         grdcell_ptr:=carray[grdcell_cell];
         grdcell_tptr:=grdcell_ptr->tileptr;
         move(grdcell_ptr->corient,RValue);
         grdcell_tmptr:=grdcell_tptr->termsptr;
         
         while(grdcell_tmptr!=NULL)
         {
             grdcell_tmptr->txpos[1]:=grdcell_tmptr->txpos[0];
             grdcell_tmptr->typos[1]:=grdcell_tmptr->typos[0];
             point(&grdcell_tmptr->txpos[1],&grdcell_tmptr->typos[1],RValue);
             if((grdcell_ptr->cheight % 2!=0 AND (grdcell_orient=4 OR grdcell_orient=6)) OR (grdcell_ptr->clength % 2!=0 AND (grdcell_orient=2 OR grdcell_orient=3))) then 
             {
                 grdcell_tmptr->txpos[1]:=grdcell_tmptr->txpos[1]+1
                 
             }
             else 
             {
                  skip 
             };
             if((grdcell_ptr->cheight % 2!=0 AND (grdcell_orient=1 OR grdcell_orient=3)) OR (grdcell_ptr->clength % 2!=0 AND (grdcell_orient=4 OR grdcell_orient=7))) then 
             {
                 grdcell_tmptr->typos[1]:=grdcell_tmptr->typos[1]+1
                 
             }
             else 
             {
                  skip 
             };
             grdcell_tmptr:=grdcell_tmptr->nextterm
             
         };
         grdcell_cell:=grdcell_cell+1
         
     };
     grdcell_cell:=1;
     
     while(grdcell_cell<=numcells)
     {
         grdcell_ptr:=carray[grdcell_cell];
         grdcell_tile:=grdcell_ptr->tileptr;
         grdcell_corient:=grdcell_ptr->corient;
         grdcell_term:=grdcell_tile->termsptr;
         
         while(grdcell_term!=NULL)
         {
             grdcell_termptr:=tearray[grdcell_term->cellterm];
             grdcell_termptr->xpos:=grdcell_term->txpos[grdcell_corient/ 2]+grdcell_ptr->cxcenter;
             grdcell_termptr->ypos:=grdcell_term->typos[grdcell_corient % 2]+grdcell_ptr->cycenter;
             grdcell_term:=grdcell_term->nextterm
             
         };
         grdcell_cell:=grdcell_cell+1
         
     };
     grdcell_cell:=numcells+1;
     
     while(grdcell_cell<=numcells+numterms)
     {
         grdcell_ptr:=carray[grdcell_cell];
         grdcell_tile:=grdcell_ptr->tileptr;
         grdcell_term:=grdcell_tile->termsptr;
         
         while(grdcell_term!=NULL)
         {
             grdcell_termptr:=tearray[grdcell_term->cellterm];
             grdcell_termptr->xpos:=grdcell_term->txpos[1]+grdcell_ptr->cxcenter;
             grdcell_termptr->ypos:=grdcell_term->typos[1]+grdcell_ptr->cycenter;
             grdcell_term:=grdcell_term->nextterm
             
         };
         grdcell_cell:=grdcell_cell+1
         
     };
      return<==1 and skip
     )
     }; 
  function add_type ( char *type,int RValue )
 {
     frame(add_type_cell_ptr,add_type_1_temp$_1,add_type_2_5_temp$_2,return) and ( 
     int return<==0 and skip;
     celltype *add_type_cell_ptr and skip;
     if(head_type=NULL) then 
     {
         head_type:=(celltype *)safe_malloc(sizeof(celltype),RValue);
         head_type->next_cell:=NULL;
         head_type->first_imp:=NULL;
         int add_type_1_temp$_1 and skip;
         add_type_1_temp$_1:=strlen(type);
         head_type->name:=(char *)safe_malloc((add_type_1_temp$_1+1)*sizeof(char),RValue);
         sprintf(head_type->name,"%s",type,RValue) and skip;
         pin_ptr:=NULL;
         active_cell_type:=head_type;
         return<==1 and RValue:=1;
         skip
     }
     else
     {
         add_type_cell_ptr:=head_type;
         while( return=0 AND   return=0 AND  true)
         {
             if(strcmp(add_type_cell_ptr->name,type)=0) then 
             {
                 return<==1 and RValue:=0;
                 skip
                 
             }
             else 
             {
                  skip 
             };
             if(return=0)   then 
             {
                 if(add_type_cell_ptr->next_cell!=NULL) then 
                 {
                     add_type_cell_ptr:=add_type_cell_ptr->next_cell
                 }
                 else
                 {
                     add_type_cell_ptr->next_cell:=(celltype *)safe_malloc(sizeof(celltype),RValue);
                     add_type_cell_ptr->next_cell->next_cell:=NULL;
                     add_type_cell_ptr->next_cell->first_imp:=NULL;
                     int add_type_2_5_temp$_2 and skip;
                     add_type_2_5_temp$_2:=strlen(type);
                     add_type_cell_ptr->next_cell->name:=(char *)safe_malloc((add_type_2_5_temp$_2+1)*sizeof(char),RValue);
                     sprintf(add_type_cell_ptr->next_cell->name,"%s",type,RValue) and skip;
                     pin_ptr:=NULL;
                     active_cell_type:=add_type_cell_ptr->next_cell;
                     return<==1 and RValue:=1;
                     skip
                 }
             }
             else
             {
                 skip
             }
             
         }
     }
     )
     }; 
  function add_pin ( int x,int RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
     if(pin_ptr=NULL) then 
     {
         active_cell_type->first_imp:=(impbox *)safe_malloc(sizeof(impbox),RValue);
		 pin_ptr<==active_cell_type->first_imp and skip
         
     }
     else
     {
         pin_ptr->next_pin:=(impbox *)safe_malloc(sizeof(impbox),RValue);
		 pin_ptr<==pin_ptr->next_pin and skip
     };
     pin_ptr->x:=x;
     pin_ptr->next_pin:=NULL;
     return<==1 and RValue:=0;
     skip
     )
     }; 
  function find_imp_x ( char *name,int x,int RValue )
 {
     frame(return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     if(strcmp("twfeed",name)=0) then 
     {
         if(x<0) then 
         {
             return<==1 and RValue:=0;
             skip
         }
         else
         {
             return<==1 and RValue:=(-fdWidth/ 2);
             skip
         }
         
     }
     else 
     {
          skip 
     };
     if(return=0)  then
     {
         active_cell_type:=head_type;
         break$<==0 and skip;
         while( break$=0 AND  true)
         {
             if(active_cell_type=NULL) then 
             {
                 fprintf(fpo,"Failed to find implicit type\n") and skip;
                 output ("Failed to find implicit type: <",name,">\n") and skip;
                 fflush(stdout) and skip;
                 exit(0) and skip 
                 
             }
             else 
             {
                  skip 
             };
             if(strcmp(active_cell_type->name,name)=0) then 
             {
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then
             {
                 active_cell_type:=active_cell_type->next_cell
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
         pin_ptr:=active_cell_type->first_imp;
         break$<==0 and skip;
         while( break$=0 AND  true)
         {
             if(pin_ptr=NULL) then 
             {
                 fprintf(fpo,"Failed to find implicit pin\n") and skip;
                 output ("Failed to find implicit pin at x=<",x,">\n") and skip;
                 fflush(stdout) and skip;
                 exit(0) and skip 
                 
             }
             else 
             {
                  skip 
             };
             if(pin_ptr->x=x) then 
             {
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then
             {
                 pin_ptr:=pin_ptr->next_pin
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
         if(pin_ptr->next_pin=NULL) then 
         {
             return<==1 and RValue:=(active_cell_type->first_imp->x);
             skip
         }
         else
         {
             return<==1 and RValue:=(-pin_ptr->next_pin->x);
             skip
         }
     }
     else
     {
         skip
     }
     )
     }; 
  function maketabl (  )
 {
     frame(maketabl_i,return) and ( 
     int return<==0 and skip;
     int maketabl_i and skip;
     hashtab:=(hash* *)safe_malloc(3001*sizeof(hash*),RValue);
     maketabl_i:=0;
     
     while(maketabl_i<3001)
     {
         hashtab[maketabl_i]:=(hash*)NULL;
         maketabl_i:=maketabl_i+1
         
     };
      return<==1 and skip
     )
     }; 
  function delHtab (  )
 {
     frame(delHtab_i,delHtab_hptr,delHtab_zapptr,return) and ( 
     int return<==0 and skip;
     int delHtab_i and skip;
     hash* delHtab_hptr,*delHtab_zapptr and skip;
     delHtab_i:=0;
     
     while(delHtab_i<3001)
     {
         delHtab_hptr:=hashtab[delHtab_i];
         if(delHtab_hptr!=(hash*)NULL) then 
         {
             delHtab_zapptr:=delHtab_hptr;
             while(delHtab_hptr->hnext!=(hash*)NULL)
             {
                 delHtab_hptr:=delHtab_hptr->hnext;
                 safe_free(delHtab_zapptr,RValue);
                 delHtab_zapptr:=delHtab_hptr
             };
             safe_free(delHtab_hptr,RValue)
             
         }
         else 
         {
              skip 
         };
         delHtab_i:=delHtab_i+1
         
     };
     safe_free(hashtab,RValue);
      return<==1 and skip
     )
     }; 
  function addhash ( char hname[],int RValue )
 {
     frame(addhash_i,addhash_hptr,addhash_hsum,addhash_1_temp$_1,addhash_2_4_temp$_2,return) and ( 
     int return<==0 and skip;
     int addhash_i and skip;
     hash* addhash_hptr and skip;
     unsigned int addhash_hsum<==0 and skip;
     addhash_i:=0;
     
     while(addhash_i<strlen(hname))
     {
         addhash_hsum:=addhash_hsum+(unsigned int)hname[addhash_i];
         addhash_i:=addhash_i+1
         
     };
     addhash_hsum:=addhash_hsum%3001;
     addhash_hptr:=hashtab[addhash_hsum] ;
     if((addhash_hptr)=(hash*)NULL) then 
     {
         hashtab[addhash_hsum]:=(hash*)safe_malloc(sizeof(hash),RValue);
		 addhash_hptr<==hashtab[addhash_hsum] and skip;
         addhash_hptr->hnext:=(hash*)NULL;
         addhash_hptr->hnum:=(netctr+1);
         netctr:=netctr+1;
         int addhash_1_temp$_1 and skip;
         addhash_1_temp$_1:=strlen(hname);
         addhash_hptr->hname:=(char *)safe_malloc((addhash_1_temp$_1+1)*sizeof(char),RValue);
         sprintf(addhash_hptr->hname,"%s",hname,RValue) and skip;
         return<==1 and RValue:=1;
         skip
     }
     else
     {
         while( return=0 AND   return=0 AND  true)
         {
             if(strcmp(hname,addhash_hptr->hname, RValue)=0) then 
             {
                 return<==1 and RValue:=0;
                 skip
                 
             }
             else 
             {
                  skip 
             };
             if(return=0)   then 
             {
                 if(addhash_hptr->hnext=(hash*)NULL) then 
                 {
                     addhash_hptr->hnext:=(hash*)safe_malloc(sizeof(hash),RValue);
					  addhash_hptr<==addhash_hptr->hnext and skip;
                     addhash_hptr->hnext:=(hash*)NULL;
                     addhash_hptr->hnum:=(netctr+1);
                     netctr:=netctr+1;
                     int addhash_2_4_temp$_2 and skip;
                     addhash_2_4_temp$_2:=strlen(hname);
                     addhash_hptr->hname:=(char *)safe_malloc((addhash_2_4_temp$_2+1)*sizeof(char),RValue);
                     sprintf(addhash_hptr->hname,"%s",hname,RValue) and skip;
                     return<==1 and RValue:=1;
                     skip
                 }
                 else
                 {
                     addhash_hptr:=addhash_hptr->hnext
                 }
             }
             else
             {
                 skip
             }
             
         }
     }
     )
     }; 
  function hashfind ( char hname[],int RValue )
 {
     frame(hashfind_i,hashfind_hptr,hashfind_hsum,return) and ( 
     int return<==0 and skip;
     int hashfind_i and skip;
     hash* hashfind_hptr and skip;
     unsigned int hashfind_hsum<==0 and skip;
     hashfind_i:=0;
     
     while(hashfind_i<strlen(hname))
     {
         hashfind_hsum:=hashfind_hsum+(unsigned int)hname[hashfind_i];
         hashfind_i:=hashfind_i+1
         
     };
     hashfind_hsum:=hashfind_hsum%3001;
     hashfind_hptr:=hashtab[hashfind_hsum] ;
     if((hashfind_hptr)=(hash*)NULL) then 
     {
         return<==1 and RValue:=0;
         skip
     }
     else
     {
         while( return=0 AND   return=0 AND  true)
         {
             if(strcmp(hname,hashfind_hptr->hname)=0) then 
             {
                 return<==1 and RValue:=(hashfind_hptr->hnum);
                 skip
                 
             }
             else 
             {
                  skip 
             };
             if(return=0)   then 
             {
                 if(hashfind_hptr->hnext=(hash*)NULL) then 
                 {
                     return<==1 and RValue:=0;
                     skip
                 }
                 else
                 {
                     hashfind_hptr:=hashfind_hptr->hnext
                 }
             }
             else
             {
                 skip
             }
             
         }
     }
     )
     }; 


 ibox* siptr and skip;
 ibox* *impFeeds and skip;
 function implfeeds ( int row,int xc,int RValue )
 {
     frame(implfeeds_iptr,implfeeds_minspan,return) and ( 
     int return<==0 and skip;
     ibox* implfeeds_iptr and skip;
     int implfeeds_minspan and skip;
     implfeeds_minspan:=32000;
     siptr:=NULL;
     implfeeds_iptr:=impFeeds[row];
     
     while(implfeeds_iptr!=NULL)
     {
         if(implfeeds_iptr->iactive<=0) then 
         {
             if(extern ABS(implfeeds_iptr->aveXpos-xc,RValue)<implfeeds_minspan) then 
             {
                 implfeeds_minspan:=ABS(implfeeds_iptr->aveXpos-xc,RValue);
                 siptr:=implfeeds_iptr
                 
             }
             else 
             {
                  skip 
             }
             
         }
         else 
         {
              skip 
         };
         implfeeds_iptr:=implfeeds_iptr->niptr
         
     };
     if(siptr!=NULL AND implfeeds_minspan<=ifrange) then 
     {
         if(siptr->iactive=0) then 
         {
             siptr->iactive:=1
             
         }
         else
         {
             siptr->iactive:=2
         };
         return<==1 and RValue:=1;
         skip
     }
     else
     {
         return<==1 and RValue:=0;
         skip
     }
     )
     }; 
  function impfix (  )
 {
     frame(impfix_iptr,impfix_niptr,impfix_ipptr,impfix_nipptr,impfix_row,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     ibox* impfix_iptr,*impfix_niptr and skip;
     ipbox* impfix_ipptr,*impfix_nipptr and skip;
     int impfix_row and skip;
     continue<==0 and skip;
     impfix_row:=1;
     
     while(impfix_row<=numRows)
     {
          continue<==0 and skip;
         impfix_iptr:=impFeeds[impfix_row];
         if(impfix_iptr=NULL) then 
         {
             continue<==1 and skip;
              impfix_row:=impfix_row+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             if(impfix_iptr->iactive!=1) then 
             {
                 impfix_ipptr:=impfix_iptr->iptr;
                 while(impfix_ipptr!=NULL)
                 {
                     impfix_nipptr:=impfix_ipptr->npin;
                     safe_free(impfix_ipptr,RValue);
                     impfix_ipptr:=impfix_nipptr
                 };
                 impfix_niptr:=impfix_iptr->niptr;
                 safe_free(impfix_iptr,RValue);
                 impfix_iptr:=impfix_niptr;
                 break$<==0 and skip;
                 while( break$=0 AND  impfix_iptr!=NULL)
                 {
                     if(impfix_iptr->iactive=1) then 
                     {
                         break$<==1 and skip
                      }
                     else
                     {
                         impfix_ipptr:=impfix_iptr->iptr;
                         
                         while(impfix_ipptr!=NULL)
                         {
                             impfix_nipptr:=impfix_ipptr->npin;
                             safe_free(impfix_ipptr,RValue);
                             impfix_ipptr:=impfix_nipptr
                             
                         };
                         impfix_niptr:=impfix_iptr->niptr;
                         safe_free(impfix_iptr,RValue);
                         impfix_iptr:=impfix_niptr
                     }
                 };
                 break$<==0 and skip;
                 impFeeds[impfix_row]:=impfix_iptr
                 
             }
             else 
             {
                  skip 
             };
             if(impfix_iptr!=NULL) then 
             {
                 impfix_niptr:=impfix_iptr->niptr;
                 while(impfix_niptr!=NULL)
                 {
                     if(impfix_niptr->iactive!=1) then 
                     {
                         impfix_ipptr:=impfix_niptr->iptr;
                         
                         while(impfix_ipptr!=NULL)
                         {
                             impfix_nipptr:=impfix_ipptr->npin;
                             safe_free(impfix_ipptr,RValue);
                             impfix_ipptr:=impfix_nipptr
                             
                         };
                         impfix_iptr->niptr:=impfix_niptr->niptr;
                         safe_free(impfix_niptr,RValue);
                         impfix_niptr:=impfix_iptr->niptr
                     }
                     else
                     {
                         impfix_iptr:=impfix_niptr;
                         impfix_niptr:=impfix_iptr->niptr
                     }
                 }
                 
             }
             else 
             {
                  skip 
             };
             impfix_row:=impfix_row+1
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     impfix_row:=1;
     
     while(impfix_row<=numRows)
     {
         impfix_iptr:=impFeeds[impfix_row];
         
         while(impfix_iptr!=NULL)
         {
             impfix_iptr->iactive:=0;
             impfix_iptr:=impfix_iptr->niptr
             
         };
         impfix_row:=impfix_row+1
         
     };
      return<==1 and skip
     )
     }; 
  function impclobr (  )
 {
     frame(impclobr_iptr,impclobr_niptr,impclobr_ipptr,impclobr_nipptr,impclobr_row,return) and ( 
     int return<==0 and skip;
     ibox* impclobr_iptr,*impclobr_niptr and skip;
     ipbox* impclobr_ipptr,*impclobr_nipptr and skip;
     int impclobr_row and skip;
     impclobr_row:=1;
     
     while(impclobr_row<=numRows)
     {
         impclobr_iptr:=impFeeds[impclobr_row];
         while(impclobr_iptr!=NULL)
         {
             impclobr_niptr:=impclobr_iptr->niptr;
             impclobr_ipptr:=impclobr_iptr->iptr;
             
             while(impclobr_ipptr!=NULL)
             {
                 impclobr_nipptr:=impclobr_ipptr->npin;
                 safe_free(impclobr_ipptr,RValue);
                 impclobr_ipptr:=impclobr_nipptr
                 
             };
             safe_free(impclobr_iptr,RValue);
             impclobr_iptr:=impclobr_niptr
         };
         impclobr_row:=impclobr_row+1
         
     };
     safe_free(impFeeds,RValue);
      return<==1 and skip
     )
     }; 

      struct tmpmerg {
     int value and 
     int next$ and 
     int first 
 };
 tmpmerg *tmp_pinlist and skip;
 int *pinlist and skip;
 int pinGroup and skip;
 int *merge_array and skip;
 int array_length and skip;
 function mergplist (  )
 {
     frame(mergplist_segment,mergplist_i,mergplist_current_net,mergplist_chan,mergplist_track,mergplist_terminal,mergplist_denptr,mergplist_temptr,return) and ( 
     int return<==0 and skip;
     int mergplist_segment,mergplist_i,mergplist_current_net and skip;
     int mergplist_chan,mergplist_track,mergplist_terminal and skip;
     densitybox* mergplist_denptr,*mergplist_temptr and skip;
     mergplist_chan:=1;
     
     while(mergplist_chan<=numChans)
     {
         mergplist_track:=0;
         
         while(mergplist_track<=max_tdensity+100)
         {
             mergplist_denptr:=DboxHead[mergplist_chan,mergplist_track]->next$;
             while(mergplist_denptr!=NULL)
             {
                 mergplist_temptr:=mergplist_denptr->next$;
                 safe_free(mergplist_denptr->grdptr,RValue);
                 safe_cfree(mergplist_denptr,RValue);
                 mergplist_denptr:=mergplist_temptr
             };
             safe_cfree(DboxHead[mergplist_chan,mergplist_track],RValue);
             mergplist_track:=mergplist_track+1
             
         };
         safe_cfree(DboxHead[mergplist_chan],RValue);
         mergplist_chan:=mergplist_chan+1
         
     };
     safe_cfree(DboxHead,RValue);
     mergplist_terminal:=1;
     
     while(mergplist_terminal<=maxterm+2*numChans)
     {
         safe_free(Tgrid[mergplist_terminal],RValue);
         mergplist_terminal:=mergplist_terminal+1
         
     };
     safe_free(Tgrid,RValue);
     pinGroup:=0;
     pinlist:=(int *)safe_malloc((maxterm+1)*sizeof(int),RValue);
     mergplist_i:=1;
     
     while(mergplist_i<=maxterm)
     {
         pinlist[mergplist_i]:=0;
         mergplist_i:=mergplist_i+1
         
     };
     merge_array:=(int *)safe_malloc(100*sizeof(int),RValue);
     merge_array[0]:=0;
     tmp_pinlist:=(tmpmerg *)safe_malloc(100*sizeof(tmpmerg),RValue);
     mergplist_i:=0;
     
     while(mergplist_i<100)
     {
         tmp_pinlist[mergplist_i].value:=0;
         tmp_pinlist[mergplist_i].next$:=0;
         tmp_pinlist[mergplist_i].first:=mergplist_i;
         mergplist_i:=mergplist_i+1
         
     };
     array_length:=100;
     mergplist_current_net:=aNetSeg[1].net;
     mergplist_segment:=1;
     
     while(mergplist_segment<=numSegs+1)
     {
         if(mergplist_segment<=numSegs) then 
         {
             if(aNetSeg[mergplist_segment].net!=mergplist_current_net) then 
             {
                 assign_group_values(RValue);
                 initialize_pins(RValue);
                 mergplist_current_net:=aNetSeg[mergplist_segment].net
                 
             }
             else 
             {
                  skip 
             };
             merge_pins(mergplist_segment,RValue)
             
         }
         else
         {
             assign_group_values(RValue)
         };
         mergplist_segment:=mergplist_segment+1
         
     };
      return<==1 and skip
     )
     }; 
  function initialize_pins ( int RValue )
 {
     frame(initialize_pins_i,return) and ( 
     int return<==0 and skip;
     int initialize_pins_i and skip;
     initialize_pins_i:=1;
     
     while(initialize_pins_i<=merge_array[0])
     {
         tmp_pinlist[initialize_pins_i].value:=0;
         tmp_pinlist[initialize_pins_i].next$:=0;
         tmp_pinlist[initialize_pins_i].first:=initialize_pins_i;
         initialize_pins_i:=initialize_pins_i+1
         
     };
     merge_array[0]:=0;
      return<==1 and skip
     )
     }; 
  function add_pins ( int pin,int RValue )
 {
     frame(add_pins_i,return) and ( 
     int return<==0 and skip;
     int add_pins_i and skip;
     add_pins_i:=1;
     
     while( return=0 AND  add_pins_i<=merge_array[0])
     {
         if(pin=merge_array[add_pins_i]) then 
         {
             return<==1 and RValue:=add_pins_i;
             skip
             
         }
         else 
         {
              skip 
         };
         if(return=0)   then 
         {
             add_pins_i:=add_pins_i+1
         }
         else
         {
             skip
         }
         
     };
     if(return=0)   then 
     {
         if((merge_array[0]+1)>=array_length) then 
         {
             merge_array[0]:=merge_array[0]+1;
             array_length:=array_length+100;
             merge_array:=(int *)safe_realloc(merge_array,array_length*sizeof(int),RValue);
             tmp_pinlist:=(tmpmerg *)safe_realloc(tmp_pinlist,array_length*sizeof(tmpmerg),RValue);
             add_pins_i:=merge_array[0];
             
             while(add_pins_i<merge_array[0]+100)
             {
                 tmp_pinlist[add_pins_i].value:=0;
                 tmp_pinlist[add_pins_i].next$:=0;
                 tmp_pinlist[add_pins_i].first:=add_pins_i;
                 add_pins_i:=add_pins_i+1
                 
             }
             
         }
         else 
         {
             merge_array[0]:=merge_array[0]+1
             
         };
         merge_array[merge_array[0]]:=pin;
         return<==1 and RValue:=(merge_array[0]);
         skip
     }
     else
     {
         skip
     }
     )
     }; 
  function assign_group_values ( int RValue )
 {
     frame(assign_group_values_i,return) and ( 
     int return<==0 and skip;
     int assign_group_values_i and skip;
     assign_group_values_i:=1;
     
     while(assign_group_values_i<=merge_array[0])
     {
         pinlist[merge_array[assign_group_values_i]]:=tmp_pinlist[assign_group_values_i].value;
         assign_group_values_i:=assign_group_values_i+1
         
     };
      return<==1 and skip
     )
     }; 
  function merge_pins ( int segment,int RValue )
 {
     frame(merge_pins_boxptr,merge_pins_4_temp$_1,merge_pins_4_temp$_2,return) and ( 
     int return<==0 and skip;
     segbox* merge_pins_boxptr and skip;
     if(aNetSeg[segment].key!=0) then 
     {
         aNetSeg[segment].current:=aNetSeg[aNetSeg[segment].key].current
         
     }
     else 
     {
          skip 
     };
     if(aNetSeg[segment].current=0) then 
     {
         merge_pins_boxptr:=aNetSeg[segment].top
         
     }
     else
     {
         merge_pins_boxptr:=aNetSeg[segment].bot
     };
     if((merge_pins_boxptr->pin1!=merge_pins_boxptr->pin2) AND ((pinlist[merge_pins_boxptr->pin1]!=pinlist[merge_pins_boxptr->pin2]) OR ((pinlist[merge_pins_boxptr->pin1]=0) AND (pinlist[merge_pins_boxptr->pin2]=0)))) then 
     {
         int merge_pins_4_temp$_1 and skip;
         merge_pins_4_temp$_1:=add_pins(merge_pins_boxptr->pin2,RValue);
         int merge_pins_4_temp$_2 and skip;
         merge_pins_4_temp$_2:=add_pins(merge_pins_boxptr->pin1,RValue);
         merge(merge_pins_4_temp$_2,merge_pins_4_temp$_1,RValue)
         
     }
     else 
     {
          skip 
     };
      return<==1 and skip
     )
     }; 
  function merge ( int i,int j,int RValue )
 {
     frame(merge_newval,merge_next$,merge_first,merge_secfirst,count$,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     int merge_newval,merge_next$,merge_first,merge_secfirst and skip;
     merge_newval:=(pinGroup+1);
     pinGroup:=pinGroup+1;
     merge_secfirst:=tmp_pinlist[j].first;
     merge_first:=tmp_pinlist[i].first;
     merge_next$:=merge_secfirst;
     int count$<==0 and skip;
     while( ( count$=0 OR merge_next$!=0))
     {
         count$:=count$+1;
         tmp_pinlist[merge_next$].value:=merge_newval;
         tmp_pinlist[merge_next$].first:=merge_first;
         merge_next$:=tmp_pinlist[merge_next$].next$
     };
     merge_next$:=merge_first;
     break$<==0 and skip;
     while( break$=0 AND  true)
     {
         tmp_pinlist[merge_next$].value:=merge_newval;
         if(tmp_pinlist[merge_next$].next$!=0) then 
         {
             merge_next$:=tmp_pinlist[merge_next$].next$
         }
         else
         {
             tmp_pinlist[merge_next$].next$:=merge_secfirst;
             break$<==1 and skip
          }
         
     };
     break$<==0 and skip;
      return<==1 and skip
     )
     }; 
      struct MT {
     int sp and 
     int stk[100,3,3] and 
     int t[3,3] and 
     int ti[3,3] 
 };
 MT *mt<==(MT *)NULL and skip;
 function point ( int *x,int *y )
 {
     frame(point_xx,point_yy,return) and ( 
     int return<==0 and skip;
     int point_xx,point_yy and skip;
     if(mt=(MT *)NULL) then 
     {
          return<==1 and skip
         
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         point_xx:=* x;
         point_yy:=* y;
         MTPoint(mt,&point_xx,&point_yy,RValue);
         * x:=point_xx;
         * y:=point_yy;
          return<==1 and skip
     }
     else
     {
         skip
     }
     )
     }; 
  function rect ( int *l,int *b,int *r,int *t )
 {
     frame(rect_temp,return) and ( 
     int return<==0 and skip;
     int rect_temp and skip;
     point(l,b,RValue);
     point(r,t,RValue);
     if(* l>* r) then 
     {
         rect_temp:=* l;
         * l:=* r;
         * r:=rect_temp
         
     }
     else 
     {
          skip 
     };
     if(* b>* t) then 
     {
         rect_temp:=* b;
         * b:=* t;
         * t:=rect_temp
         
     }
     else 
     {
          skip 
     };
      return<==1 and skip
     )
     }; 
  function move ( int moveType )
 {
     frame(nm_2$,break$$,switch$,return) and ( 
     int return<==0 and skip;
     if(mt=(MT *)NULL) then 
     {
         mt:=MTBegin(RValue)
         
     }
     else 
     {
          skip 
     };
     MTIdenti(mt,RValue);
     int switch$ and skip;
     int break$$ and skip;
     break$$<==0 and skip;
      switch$<==0 and skip;
      int nm_2$ and skip;
     nm_2$ := moveType;
     if (nm_2$=0 OR (switch$=1 AND break$$=0 AND return=0) ) then 
     {
         switch$<==1 and skip;
          return<==1 and skip
         
     }
     else
     {
         skip
     };
     if (nm_2$=1 OR (switch$=1 AND break$$=0 AND return=0) ) then 
     {
         switch$<==1 and skip;
         MTMY(mt,RValue);
          return<==1 and skip
         
     }
     else
     {
         skip
     };
     if (nm_2$=2 OR (switch$=1 AND break$$=0 AND return=0) ) then 
     {
         switch$<==1 and skip;
         MTMX(mt,RValue);
          return<==1 and skip
         
     }
     else
     {
         skip
     };
     if (nm_2$=3 OR (switch$=1 AND break$$=0 AND return=0) ) then 
     {
         switch$<==1 and skip;
         MTRotate(mt,-1,0,RValue);
          return<==1 and skip
         
     }
     else
     {
         skip
     };
     if (nm_2$=4 OR (switch$=1 AND break$$=0 AND return=0) ) then 
     {
         switch$<==1 and skip;
         MTMX(mt,RValue);
         MTRotate(mt,0,1,RValue);
          return<==1 and skip
         
     }
     else
     {
         skip
     };
     if (nm_2$=5 OR (switch$=1 AND break$$=0 AND return=0) ) then 
     {
         switch$<==1 and skip;
         MTMX(mt,RValue);
         MTRotate(mt,0,-1,RValue);
          return<==1 and skip
         
     }
     else
     {
         skip
     };
     if (nm_2$=6 OR (switch$=1 AND break$$=0 AND return=0) ) then 
     {
         switch$<==1 and skip;
         MTRotate(mt,0,1,RValue);
          return<==1 and skip
         
     }
     else
     {
         skip
     };
     if (nm_2$=7 OR (switch$=1 AND break$$=0 AND return=0) ) then 
     {
         switch$<==1 and skip;
         MTRotate(mt,0,-1,RValue);
          return<==1 and skip
         
     }
     else
     {
         skip
         })
         }; 
  function MTBegin ( MT* RValue )
 {
     frame(MTBegin_t,return) and ( 
     int return<==0 and skip;
     MT *MTBegin_t and skip;
     MTBegin_t:=(MT *)safe_malloc(sizeof(MT),RValue) ;
     if((MTBegin_t)=NULL) then 
     {
         return<==1 and RValue:=NULL;
         skip
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         MTBegin_t->sp:=0;
         MTIdenti(MTBegin_t);
         return<==1 and RValue:=MTBegin_t;
         skip
     }
     else
     {
         skip
     }
     )
     }; 
  function MTEnd ( MT *t )
 {
     free(t) and skip
     
 };
 function MTIdenti ( MT *t )
 {
     t->t[2,2]<==1 and t->t[1,1]<==t->t[2,2] and t->t[0,0]<==t->t[1,1] and t->ti[2,2]<==t->t[0,0] and t->ti[1,1]<==t->ti[2,2] and t->ti[0,0]<==t->ti[1,1] and skip;
     t->ti[2,1]<==0 and t->ti[2,0]<==t->ti[2,1] and t->ti[1,2]<==t->ti[2,0] and t->ti[0,2]<==t->ti[1,2] and t->ti[1,0]<==t->ti[0,2] and t->ti[0,1]<==t->ti[1,0] and t->t[2,1]<==t->ti[0,1] and t->t[2,0]<==t->t[2,1] and t->t[1,2]<==t->t[2,0] and t->t[0,2]<==t->t[1,2] and t->t[1,0]<==t->t[0,2] and t->t[0,1]<==t->t[1,0] and skip
     
 };
 function MTTransl ( MT *t,int x,int y )
 {
     t->t[2,0]:=t->t[2,0]+x;
     t->t[2,1]:=t->t[2,1]+y;
     MTInvert(t)
     
 };
 function MTMY ( MT *t )
 {
     t->t[0,1]:=-t->t[0,1];
     t->t[1,1]:=-t->t[1,1];
     t->t[2,1]:=-t->t[2,1];
     MTInvert(t)
     
 };
 function MTMX ( MT *t )
 {
     t->t[0,0]:=-t->t[0,0];
     t->t[1,0]:=-t->t[1,0];
     t->t[2,0]:=-t->t[2,0];
     MTInvert(t)
     
 };
 function MTRotate ( MT *t,int x,int y )
 {
     frame(MTRotate_i1,MTRotate_i2,MTRotate_11_13_15_16_i,MTRotate_11_13_15_16_j,return) and ( 
     int return<==0 and skip;
     int MTRotate_i1,MTRotate_i2 and skip;
     if(x=0) then 
     {
         if(extern ABS(y,RValue)>1) then 
         {
             if(y<0) then 
             {
                 y:=-1
             }
             else
             {
                 y:=1
             }
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         if(y=0) then 
         {
             if(extern ABS(x,RValue)>1) then 
             {
                 if(x<0) then 
                 {
                     x:=-1
                 }
                 else
                 {
                     x:=1
                 }
             }
             else 
             {
                  skip 
             }
             
         }
         else 
         {
              skip 
         }
     };
     if(x=1 AND y=0) then 
     {
          return<==1 and skip
     }
     else
     {
         if(x=0 AND y=-1) then 
         {
             MTRotate_i1:=t->t[0,0];
             t->t[0,0]:=t->t[0,1];
             t->t[0,1]:=-MTRotate_i1;
             MTRotate_i1:=t->t[1,0];
             t->t[1,0]:=t->t[1,1];
             t->t[1,1]:=-MTRotate_i1;
             MTRotate_i1:=t->t[2,0];
             t->t[2,0]:=t->t[2,1];
             t->t[2,1]:=-MTRotate_i1
         }
         else
         {
             if(x=0 AND y=1) then 
             {
                 MTRotate_i1:=t->t[0,0];
                 t->t[0,0]:=-t->t[0,1];
                 t->t[0,1]:=MTRotate_i1;
                 MTRotate_i1:=t->t[1,0];
                 t->t[1,0]:=-t->t[1,1];
                 t->t[1,1]:=MTRotate_i1;
                 MTRotate_i1:=t->t[2,0];
                 t->t[2,0]:=-t->t[2,1];
                 t->t[2,1]:=MTRotate_i1
             }
             else
             {
                 if(x=-1 AND y=0) then 
                 {
                     int MTRotate_11_13_15_16_i,MTRotate_11_13_15_16_j and skip;
                     MTRotate_11_13_15_16_i:=0;
                     
                     while(MTRotate_11_13_15_16_i<3)
                     {
                         MTRotate_11_13_15_16_j:=0;
                         
                         while(MTRotate_11_13_15_16_j<2)
                         {
                             t->t[MTRotate_11_13_15_16_i,MTRotate_11_13_15_16_j]:=-t->t[MTRotate_11_13_15_16_i,MTRotate_11_13_15_16_j];
                             MTRotate_11_13_15_16_j:=MTRotate_11_13_15_16_j+1
                             
                         };
                         MTRotate_11_13_15_16_i:=MTRotate_11_13_15_16_i+1
                         
                     }
                     
                 }
                 else 
                 {
                      skip 
                 }
             }
         }
     };
     if(return=0)  then
     {
         MTInvert(t)
     }
     else
     {
         skip
     }
     )
     }; 
  function MTConcat ( MT *t,int **a )
 {
     frame(MTConcat_i1,MTConcat_i2,MTConcat_i3,MTConcat_i4,MTConcat_i5,MTConcat_i6) and ( 
     int MTConcat_i1,MTConcat_i2,MTConcat_i3,MTConcat_i4,MTConcat_i5,MTConcat_i6 and skip;
     MTConcat_i1:=t->t[0,0]*a[0,0]+t->t[0,1]*a[1,0];
     MTConcat_i2:=t->t[0,0]*a[0,1]+t->t[0,1]*a[1,1];
     MTConcat_i3:=t->t[1,0]*a[0,0]+t->t[1,1]*a[1,0];
     MTConcat_i4:=t->t[1,0]*a[0,1]+t->t[1,1]*a[1,1];
     MTConcat_i5:=t->t[2,0]*a[0,0]+t->t[2,1]*a[1,0]+a[2,0];
     MTConcat_i6:=t->t[2,0]*a[0,1]+t->t[2,1]*a[1,1]+a[2,1];
     t->t[0,0]:=MTConcat_i1;
     t->t[0,1]:=MTConcat_i2;
     t->t[1,0]:=MTConcat_i3;
     t->t[1,1]:=MTConcat_i4;
     t->t[2,0]:=MTConcat_i5;
     t->t[2,1]:=MTConcat_i6;
     MTInvert(t)
     )
     }; 
  function MTPoint ( MT *t,int *x,int *y )
 {
     frame(MTPoint_i1) and ( 
     int MTPoint_i1 and skip;
     MTPoint_i1:=* x*t->t[0,0]+* y*t->t[1,0]+t->t[2,0];
     * y:=* x*t->t[0,1]+* y*t->t[1,1]+t->t[2,1];
     * x:=MTPoint_i1
     )
     }; 
  function MTIPoint ( MT *t,int *x,int *y )
 {
     frame(MTIPoint_i1) and ( 
     int MTIPoint_i1 and skip;
     MTIPoint_i1:=* x*t->ti[0,0]+* y*t->ti[1,0]+t->ti[2,0];
     * y:=* x*t->ti[0,1]+* y*t->ti[1,1]+t->ti[2,1];
     * x:=MTIPoint_i1
     )
     }; 
  function MTPushP ( MT *t,int RValue )
 {
     frame(MTPushP_i,MTPushP_j,return) and ( 
     int return<==0 and skip;
     int MTPushP_i,MTPushP_j and skip;
     if(t->sp=100) then 
     {
         return<==1 and RValue:=false;
         skip
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         MTPushP_i:=0;
         
         while(MTPushP_i<3)
         {
             MTPushP_j:=0;
             
             while(MTPushP_j<2)
             {
                 t->stk[t->sp,MTPushP_i,MTPushP_j]:=t->t[MTPushP_i,MTPushP_j];
                 MTPushP_j:=MTPushP_j+1
                 
             };
             MTPushP_i:=MTPushP_i+1
             
         };
         t->sp:=t->sp+1;
         return<==1 and RValue:=true;
         skip
     }
     else
     {
         skip
     }
     )
     }; 
  function MTPopP ( MT *t,int RValue )
 {
     frame(MTPopP_i,MTPopP_j,return) and ( 
     int return<==0 and skip;
     int MTPopP_i,MTPopP_j and skip;
     if(t->sp=0) then 
     {
         return<==1 and RValue:=false;
         skip
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         t->sp:=t->sp-1;
         MTPopP_i:=0;
         
         while(MTPopP_i<3)
         {
             MTPopP_j:=0;
             
             while(MTPopP_j<2)
             {
                 t->t[MTPopP_i,MTPopP_j]:=t->stk[t->sp,MTPopP_i,MTPopP_j];
                 MTPopP_j:=MTPopP_j+1
                 
             };
             MTPopP_i:=MTPopP_i+1
             
         };
         MTInvert(t);
         return<==1 and RValue:=true;
         skip
     }
     else
     {
         skip
     }
     )
     }; 
  function MTPremul ( MT *t,int RValue )
 {
     frame(MTPremul_i1,MTPremul_i2,MTPremul_i3,MTPremul_i4,MTPremul_i5,MTPremul_i6,MTPremul_sp,return) and ( 
     int return<==0 and skip;
     int MTPremul_i1,MTPremul_i2,MTPremul_i3,MTPremul_i4,MTPremul_i5,MTPremul_i6,MTPremul_sp and skip;
     if(t->sp=0) then 
     {
         return<==1 and RValue:=false;
         skip
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         MTPremul_sp:=t->sp-1;
         MTPremul_i1:=t->t[0,0]*t->stk[MTPremul_sp,0,0]+t->t[0,1]*t->stk[MTPremul_sp,1,0];
         MTPremul_i2:=t->t[0,0]*t->stk[MTPremul_sp,0,1]+t->t[0,1]*t->stk[MTPremul_sp,1,1];
         MTPremul_i3:=t->t[1,0]*t->stk[MTPremul_sp,0,0]+t->t[1,1]*t->stk[MTPremul_sp,1,0];
         MTPremul_i4:=t->t[1,0]*t->stk[MTPremul_sp,0,1]+t->t[1,1]*t->stk[MTPremul_sp,1,1];
         MTPremul_i5:=t->t[2,0]*t->stk[MTPremul_sp,0,0]+t->t[2,1]*t->stk[MTPremul_sp,1,0]+t->stk[MTPremul_sp,2,0];
         MTPremul_i6:=t->t[2,0]*t->stk[MTPremul_sp,0,1]+t->t[2,1]*t->stk[MTPremul_sp,1,1]+t->stk[MTPremul_sp,2,1];
         t->t[0,0]:=MTPremul_i1;
         t->t[0,1]:=MTPremul_i2;
         t->t[1,0]:=MTPremul_i3;
         t->t[1,1]:=MTPremul_i4;
         t->t[2,0]:=MTPremul_i5;
         t->t[2,1]:=MTPremul_i6;
         MTInvert(t);
         return<==1 and RValue:=true;
         skip
     }
     else
     {
         skip
     }
     )
     }; 
  function MTDecode ( MT *t,char **s,int RValue )
 {
     frame(MTDecode_a,MTDecode_b,MTDecode_c,MTDecode_d,MTDecode_tx,MTDecode_ty,MTDecode_cif,return) and ( 
     int return<==0 and skip;
     int MTDecode_a,MTDecode_b,MTDecode_c,MTDecode_d,MTDecode_tx,MTDecode_ty and skip;
     char MTDecode_cif[81] and skip;
     if(!extern MTPushP(t,RValue)) then 
     {
         return<==1 and RValue:=false;
         skip
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         MTDecode_a:=t->t[0,0];
         MTDecode_b:=t->t[1,0];
         MTDecode_c:=t->t[0,1];
         MTDecode_d:=t->t[1,1];
         MTDecode_tx:=t->t[2,0];
         MTDecode_ty:=t->t[2,1];
         MTIdenti(t);
         if(MTDecode_a=0 AND MTDecode_b=1 AND MTDecode_c=1 AND MTDecode_d=0) then 
         {
             MTMX(t);
             MTRotate(t,0,-1);
             MTTransl(t,MTDecode_tx,MTDecode_ty);
             if(MTDecode_tx!=0 OR MTDecode_ty!=0) then 
             {
                 sprintf(MTDecode_cif,"MX R 0 -1 T %d %d",MTDecode_tx,MTDecode_ty,RValue) and skip
             }
             else
             {
                 sprintf(MTDecode_cif,"MX R 0 -1",RValue) and skip
             }
             
         }
         else
         {
             if(MTDecode_a=0 AND MTDecode_b=-1 AND MTDecode_c=-1 AND MTDecode_d=0) then 
             {
                 MTMX(t);
                 MTRotate(t,0,1);
                 MTTransl(t,MTDecode_tx,MTDecode_ty);
                 if(MTDecode_tx!=0 OR MTDecode_ty!=0) then 
                 {
                     sprintf(MTDecode_cif,"MX R 0 1 T %d %d",MTDecode_tx,MTDecode_ty,RValue) and skip
                 }
                 else
                 {
                     sprintf(MTDecode_cif,"MX R 0 1",RValue) and skip
                 }
             }
             else
             {
                 if(MTDecode_a=0 AND MTDecode_b=1 AND MTDecode_c=-1 AND MTDecode_d=0) then 
                 {
                     MTRotate(t,0,-1);
                     MTTransl(t,MTDecode_tx,MTDecode_ty);
                     if(MTDecode_tx!=0 OR MTDecode_ty!=0) then 
                     {
                         sprintf(MTDecode_cif,"R 0 -1 T %d %d",MTDecode_tx,MTDecode_ty,RValue) and skip
                     }
                     else
                     {
                         sprintf(MTDecode_cif,"R 0 -1",RValue) and skip
                     }
                 }
                 else
                 {
                     if(MTDecode_a=0 AND MTDecode_b=-1 AND MTDecode_c=1 AND MTDecode_d=0) then 
                     {
                         MTRotate(t,0,1);
                         MTTransl(t,MTDecode_tx,MTDecode_ty);
                         if(MTDecode_tx!=0 OR MTDecode_ty!=0) then 
                         {
                             sprintf(MTDecode_cif,"R 0 1 T %d %d",MTDecode_tx,MTDecode_ty,RValue) and skip
                         }
                         else
                         {
                             sprintf(MTDecode_cif,"R 0 1",RValue) and skip
                         }
                     }
                     else
                     {
                         if(MTDecode_a=1 AND MTDecode_b=0 AND MTDecode_c=0 AND MTDecode_d=1) then 
                         {
                             MTTransl(t,MTDecode_tx,MTDecode_ty);
                             if(MTDecode_tx!=0 OR MTDecode_ty!=0) then 
                             {
                                 sprintf(MTDecode_cif,"T %d %d",MTDecode_tx,MTDecode_ty,RValue) and skip
                             }
                             else
                             {
                                 MTDecode_cif[0]:='\0'
                             }
                         }
                         else
                         {
                             if(MTDecode_a=-1 AND MTDecode_b=0 AND MTDecode_c=0 AND MTDecode_d=-1) then 
                             {
                                 MTRotate(t,-1,0);
                                 MTTransl(t,MTDecode_tx,MTDecode_ty);
                                 if(MTDecode_tx!=0 OR MTDecode_ty!=0) then 
                                 {
                                     sprintf(MTDecode_cif,"R -1 0 T %d %d",MTDecode_tx,MTDecode_ty,RValue) and skip
                                 }
                                 else
                                 {
                                     sprintf(MTDecode_cif,"R -1 0",RValue) and skip
                                 }
                             }
                             else
                             {
                                 if(MTDecode_a=-1 AND MTDecode_b=0 AND MTDecode_c=0 AND MTDecode_d=1) then 
                                 {
                                     MTMX(t);
                                     MTTransl(t,MTDecode_tx,MTDecode_ty);
                                     if(MTDecode_tx!=0 OR MTDecode_ty!=0) then 
                                     {
                                         sprintf(MTDecode_cif,"MX T %d %d",MTDecode_tx,MTDecode_ty,RValue) and skip
                                     }
                                     else
                                     {
                                         sprintf(MTDecode_cif,"MX",RValue) and skip
                                     }
                                 }
                                 else
                                 {
                                     if(MTDecode_a=1 AND MTDecode_b=0 AND MTDecode_c=0 AND MTDecode_d=-1) then 
                                     {
                                         MTMY(t);
                                         MTTransl(t,MTDecode_tx,MTDecode_ty);
                                         if(MTDecode_tx!=0 OR MTDecode_ty!=0) then 
                                         {
                                             sprintf(MTDecode_cif,"MY T %d %d",MTDecode_tx,MTDecode_ty,RValue) and skip
                                         }
                                         else
                                         {
                                             sprintf(MTDecode_cif,"MY",RValue) and skip
                                         }
                                     }
                                     else
                                     {
                                         MTPopP(t,RValue);
                                         return<==1 and RValue:=false;
                                         skip
                                     }
                                 }
                             }
                         }
                     }
                 }
             }
         };
         if(return=0)  then
         {
             if(t->t[0,0]=MTDecode_a AND t->t[0,1]=MTDecode_c AND t->t[1,0]=MTDecode_b AND t->t[1,1]=MTDecode_d) then 
             {
                 MTPopP(t,RValue);
                 * s:=MTDecode_cif;
                 return<==1 and RValue:=true;
                 skip
             }
             else
             {
                 MTPopP(t,RValue);
                 return<==1 and RValue:=false;
                 skip
             }
         }
         else
         {
             skip
         }
     }
     else
     {
         skip
     }
     )
     }; 
  function MTInvert ( MT *t )
 {
     t->ti[0,0]:=t->t[0,0];
     t->ti[0,1]:=t->t[1,0];
     t->ti[1,0]:=t->t[0,1];
     t->ti[1,1]:=t->t[1,1];
     t->ti[2,0]:=-t->t[2,0]*t->t[0,0]-t->t[2,1]*t->t[0,1];
     t->ti[2,1]:=-t->t[2,0]*t->t[1,0]-t->t[2,1]*t->t[1,1];
     t->ti[1,2]<==0 and t->ti[0,2]<==t->ti[1,2] and skip;
     t->ti[2,2]:=1
     
 };
 function safe_malloc (unsigned int size,char* RValue )
 {
     frame(safe_malloc_p,return) and ( 
     int return<==0 and skip;
     char *safe_malloc_p and skip;
     safe_malloc_p:=malloc(size) ;
     if((safe_malloc_p)=NULL) then 
     {
         cleanupHandler((0x40060000+2),"safe_malloc",RValue)
         
     }
     else 
     {
          skip 
     };
     return<==1 and RValue:=safe_malloc_p;
     skip
     )
     }; 
  function safe_realloc ( char *obj,unsigned int size,char* RValue )
 {
     frame(safe_realloc_p,return) and ( 
     int return<==0 and skip;
     char *safe_realloc_p and skip;
     safe_realloc_p:=realloc(obj,size,RValue) ;
     if((safe_realloc_p)=NULL) then 
     {
         cleanupHandler((0x40060000+2),"safe_realloc",RValue)
         
     }
     else 
     {
          skip 
     };
     return<==1 and RValue:=safe_realloc_p;
     skip
     )
     }; 
  function safe_calloc ( unsigned int size,unsigned int num,char* RValue )
 {
     frame(safe_calloc_p,return) and ( 
     int return<==0 and skip;
     char *safe_calloc_p and skip;
     safe_calloc_p:=calloc(size,num) ;
     if((safe_calloc_p)=NULL) then 
     {
         cleanupHandler((0x40060000+2),"safe_calloc",RValue)
         
     }
     else 
     {
          skip 
     };
     return<==1 and RValue:=safe_calloc_p;
     skip
     )
     }; 
  function safe_free ( char *ptr )
 {
     frame(return) and ( 
     int return<==0 and skip;
     free(ptr) and skip;
      return<==1 and skip
     )
     }; 
  function safe_cfree ( char *ptr )
 {
     frame(return) and ( 
     int return<==0 and skip;
      return<==1 and skip
     )
     }; 
  function cleanup ( int sigNum,int RValue )
 {
     cleanupHandler(-sigNum,NULL,RValue)
     
 };
 function cleanupHandler ( int status,char *function$,int RValue )
 {
     exit(0) and skip 
     
 };
 function outcm (  )
 {
     frame(outcm_filename,outcm_fp,outcm_netptr,outcm_net,outcm_x,outcm_local_pin_count,outcm_pin_count,outcm_cell,outcm_row,outcm_length,outcm_xstart,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     char outcm_filename[64] and skip;
     FILE *outcm_fp and skip;
     netbox* outcm_netptr and skip;
     int outcm_net,outcm_x,outcm_local_pin_count,outcm_pin_count and skip;
     int outcm_cell,outcm_row,outcm_length,outcm_xstart and skip;
     sprintf(outcm_filename,"%s.cm",cktName,RValue) and skip;
     outcm_fp:=twopen(outcm_filename,"w",1,RValue);
     outcm_pin_count:=0;
     outcm_net:=1;
     
     while(outcm_net<=numnets)
     {
         outcm_local_pin_count:=0;
         outcm_netptr:=netarray[outcm_net]->netptr;
         
         while(outcm_netptr)
         {
             if(outcm_netptr->cell<=numcells) then 
             {
                 outcm_local_pin_count:=outcm_local_pin_count+1
                 
             }
             else 
             {
                  skip 
             };
             outcm_netptr:=outcm_netptr->nterm
             
         };
         if(outcm_local_pin_count>1) then 
         {
             outcm_pin_count:=outcm_pin_count+outcm_local_pin_count
             
         }
         else 
         {
              skip 
         };
         outcm_net:=outcm_net+1
         
     };
     fprintf(outcm_fp,"%d\n",outcm_pin_count) and skip;
     continue<==0 and skip;
     outcm_net:=1;
     
     while(outcm_net<=numnets)
     {
          continue<==0 and skip;
         outcm_local_pin_count:=0;
         outcm_netptr:=netarray[outcm_net]->netptr;
         
         while(outcm_netptr)
         {
             if(outcm_netptr->cell<=numcells) then 
             {
                 outcm_local_pin_count:=outcm_local_pin_count+1
                 
             }
             else 
             {
                  skip 
             };
             outcm_netptr:=outcm_netptr->nterm
             
         };
         if(outcm_local_pin_count<=1) then 
         {
             continue<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             continue<==0 and skip;
             outcm_netptr:=netarray[outcm_net]->netptr;
             
             while(outcm_netptr)
             {
                  continue<==0 and skip;
                 if(outcm_netptr->cell>numcells) then 
                 {
                     continue<==1 and skip;
                      outcm_netptr:=outcm_netptr->nterm
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     outcm_cell:=outcm_netptr->cell;
                     outcm_row:=carray[outcm_cell]->cblock;
                     outcm_x:=outcm_netptr->xpos;
                     outcm_length:=carray[outcm_cell]->tileptr->right-carray[outcm_cell]->tileptr->left;
                     outcm_xstart:=carray[outcm_cell]->cxcenter+carray[outcm_cell]->tileptr->left;
                     fprintf(outcm_fp,"%8d %8d %8d %8d %8d %8d\n",outcm_row,outcm_cell,outcm_net,outcm_x,outcm_length,outcm_xstart) and skip;
                     outcm_netptr:=outcm_netptr->nterm
                 }
                 else
                 {
                     skip
                 }
                 
             };
             continue<==0 and skip;
             outcm_net:=outcm_net+1
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     fclose(outcm_fp) and skip;
      return<==1 and skip
     )
     }; 
  function outpins (  )
 {
     frame(outpins_filename,outpins_fp,outpins_netptr,outpins_sptr,outpins_net,outpins_b,outpins_e,outpins_seg,outpins_x,outpins_y,outpins_pin,outpins_pinloc,outpins_chan,outpins_xx,outpins_chan1,outpins_chan2,outpins_r_core_edge,outpins_l_core_edge,outpins_l_end,outpins_r_end,outpins_cell,outpins_blk,outpins_pin2_1,outpins_pin2_2,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     char outpins_filename[64] and skip;
     FILE *outpins_fp and skip;
     netbox* outpins_netptr and skip;
     segbox* outpins_sptr and skip;
     int outpins_net,outpins_b,outpins_e,outpins_seg,outpins_x,outpins_y,outpins_pin,outpins_pinloc,outpins_chan,outpins_xx and skip;
     int outpins_chan1,outpins_chan2 and skip;
     int outpins_r_core_edge,outpins_l_core_edge,outpins_l_end,outpins_r_end,outpins_cell,outpins_blk and skip;
     int outpins_pin2_1,outpins_pin2_2 and skip;
     sprintf(outpins_filename,"%s.pin",cktName,RValue) and skip;
     outpins_fp:=twopen(outpins_filename,"w",1,RValue);
     outpins_r_core_edge:=0;
     outpins_l_core_edge:=32000;
     outpins_blk:=1;
     
     while(outpins_blk<=numblock)
     {
         outpins_cell:=pairArray[outpins_blk,pairArray[outpins_blk,0]];
         outpins_r_end:=carray[outpins_cell]->cxcenter+carray[outpins_cell]->tileptr->right;
         outpins_cell:=pairArray[outpins_blk,1];
         outpins_l_end:=carray[outpins_cell]->cxcenter+carray[outpins_cell]->tileptr->left;
         if(outpins_r_end>outpins_r_core_edge) then 
         {
             outpins_r_core_edge:=outpins_r_end
             
         }
         else 
         {
              skip 
         };
         if(outpins_l_end<outpins_l_core_edge) then 
         {
             outpins_l_core_edge:=outpins_l_end
             
         }
         else 
         {
              skip 
         };
         outpins_blk:=outpins_blk+1
         
     };
     outpins_net:=1;
     
     while(outpins_net<=numnets)
     {
         outpins_netptr:=netarray[outpins_net]->netptr;
         continue<==0 and skip;
         while(outpins_netptr!=NULL)
         {
              continue<==0 and skip;
             outpins_pin:=outpins_netptr->terminal;
             if(pinlist[outpins_pin]=0) then 
             {
                 continue<==1 and skip;
                  outpins_netptr:=outpins_netptr->nterm
             }
             else 
             {
                  skip 
             };
             if(continue=0)   then 
             {
                 outpins_pinloc:=-outpins_netptr->pinloc;
                 outpins_x:=outpins_netptr->xpos;
                 outpins_y:=outpins_netptr->ypos;
                 outpins_b:=anet[outpins_net];
                 outpins_e:=anet[outpins_net+1]-1;
                 outpins_chan1:=-10;
                 outpins_chan2:=-10;
                 continue<==0 and skip;
                 break$<==0 and skip;
                 outpins_seg:=outpins_b;
                 
                 while( break$=0 AND  outpins_seg<=outpins_e)
                 {
                      continue<==0 and skip;
                     if(aNetSeg[outpins_seg].current=0) then 
                     {
                         outpins_sptr:=aNetSeg[outpins_seg].top
                         
                     }
                     else
                     {
                         outpins_sptr:=aNetSeg[outpins_seg].bot
                     };
                     if(outpins_pin=outpins_sptr->pin1 OR outpins_pin=outpins_sptr->pin2) then 
                     {
                         outpins_chan:=outpins_sptr->channel;
                         if(outpins_chan1<0) then 
                         {
                             outpins_chan1:=outpins_chan;
                             if(outpins_pin=outpins_sptr->pin1) then 
                             {
                                 outpins_pin2_1:=outpins_sptr->pin2
                             }
                             else
                             {
                                 outpins_pin2_1:=outpins_sptr->pin1
                             }
                         }
                         else
                         {
                             if(outpins_chan1=outpins_chan) then 
                             {
                                 continue<==1 and skip;
                                  outpins_seg:=outpins_seg+1}
                                 else
                                 {
                                     if(outpins_chan2<0) then 
                                     {
                                         outpins_chan2:=outpins_chan;
                                         if(outpins_pin=outpins_sptr->pin1) then 
                                         {
                                             outpins_pin2_2:=outpins_sptr->pin2
                                             
                                         }
                                         else
                                         {
                                             outpins_pin2_2:=outpins_sptr->pin1
                                         };
                                         break$<==1 and skip
                                          
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                 }
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then 
                         {
                             if(continue=0)  then
                             {
                                 outpins_seg:=outpins_seg+1
                             }
                             else
                             {
                                 skip
                             }
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     break$<==0 and skip;
                     continue<==0 and skip;
                     if((outpins_netptr->cell<=numcells AND outpins_pinloc!=0) OR (outpins_netptr->cell>numcells AND (carray[outpins_netptr->cell]->padside=2 OR carray[outpins_netptr->cell]->padside=4 OR carray[outpins_netptr->cell]->padside=14 OR carray[outpins_netptr->cell]->padside=15))) then 
                     {
                         if(outpins_netptr->cell>numcells) then 
                         {
                             if(carray[outpins_netptr->cell]->padside=2 OR carray[outpins_netptr->cell]->padside=14) then 
                             {
                                 fprintf(outpins_fp,"%s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],carray[outpins_netptr->cell]->cname,pinnames[outpins_pin],outpins_x,outpins_y,outpins_chan1,1) and skip
                             }
                             else
                             {
                                 if(carray[outpins_netptr->cell]->padside=4 OR carray[outpins_netptr->cell]->padside=15) then 
                                 {
                                     fprintf(outpins_fp,"%s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],carray[outpins_netptr->cell]->cname,pinnames[outpins_pin],outpins_x,outpins_y,outpins_chan1,-1) and skip
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                         }
                         else
                         {
                             fprintf(outpins_fp,"%s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],carray[outpins_netptr->cell]->cname,pinnames[outpins_pin],outpins_x,outpins_y,outpins_chan1,outpins_pinloc) and skip
                         }
                         
                     }
                     else
                     {
                         if(outpins_netptr->cell>numcells) then 
                         {
                             if(carray[outpins_netptr->cell]->padside=1 OR carray[outpins_netptr->cell]->padside=5 OR carray[outpins_netptr->cell]->padside=9 OR carray[outpins_netptr->cell]->padside=7) then 
                             {
                                 fprintf(outpins_fp,"%s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],carray[outpins_netptr->cell]->cname,pinnames[outpins_pin],outpins_x,outpins_y,-1,1) and skip;
                                 if(carray[tearray[outpins_pin2_1]->cell]->padside!=1 AND carray[tearray[outpins_pin2_1]->cell]->padside!=5 AND carray[tearray[outpins_pin2_1]->cell]->padside!=9 AND carray[tearray[outpins_pin2_1]->cell]->padside!=7) then 
                                 {
                                     if(carray[outpins_netptr->cell]->padside=1) then 
                                     {
                                         outpins_xx:=outpins_l_core_edge
                                         
                                     }
                                     else
                                     {
                                         outpins_xx:=min_l_chan_edge(outpins_chan1,RValue);
                                         if(tearray[outpins_pin2_1]->xpos<outpins_xx) then 
                                         {
                                             outpins_xx:=outpins_x
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     };
                                     if(outpins_netptr->row=outpins_chan1) then 
                                     {
                                         outpins_y:=barray[outpins_netptr->row]->bycenter-rowHeight
                                         
                                     }
                                     else
                                     {
                                         outpins_y:=barray[outpins_netptr->row]->bycenter+rowHeight
                                     };
                                     fprintf(outpins_fp," %s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],"PSEUDO_CELL","PSEUDO_PIN",outpins_xx,outpins_y,outpins_chan1,-2) and skip;
                                     fprintf(outpins_fp," %s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],"PSEUDO_CELL","PSEUDO_PIN",outpins_xx,outpins_y,-1,-1) and skip;
                                     if(outpins_chan2>0) then 
                                     {
                                         if(carray[tearray[outpins_pin2_2]->cell]->padside!=1 AND carray[tearray[outpins_pin2_2]->cell]->padside!=5 AND carray[tearray[outpins_pin2_2]->cell]->padside!=9 AND carray[tearray[outpins_pin2_2]->cell]->padside!=7) then 
                                         {
                                             if(carray[outpins_netptr->cell]->padside=1) then 
                                             {
                                                 outpins_xx:=outpins_l_core_edge
                                                 
                                             }
                                             else
                                             {
                                                 outpins_xx:=min_l_chan_edge(outpins_chan2,RValue);
                                                 if(tearray[outpins_pin2_2]->xpos<outpins_xx) then 
                                                 {
                                                     outpins_xx:=outpins_x
                                                     
                                                 }
                                                 else 
                                                 {
                                                      skip 
                                                 }
                                             };
                                             if(outpins_netptr->row=outpins_chan2) then 
                                             {
                                                 outpins_y:=barray[outpins_netptr->row]->bycenter-rowHeight
                                                 
                                             }
                                             else
                                             {
                                                 outpins_y:=barray[outpins_netptr->row]->bycenter+rowHeight
                                             };
                                             fprintf(outpins_fp," %s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],"PSEUDO_CELL","PSEUDO_PIN",outpins_xx,outpins_y,outpins_chan2,-2) and skip;
                                             fprintf(outpins_fp," %s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],"PSEUDO_CELL","PSEUDO_PIN",outpins_xx,outpins_y,-1,-1) and skip
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                             else
                             {
                                 if(carray[outpins_netptr->cell]->padside=3 OR carray[outpins_netptr->cell]->padside=6 OR carray[outpins_netptr->cell]->padside=10 OR carray[outpins_netptr->cell]->padside=8) then 
                                 {
                                     fprintf(outpins_fp,"%s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],carray[outpins_netptr->cell]->cname,pinnames[outpins_pin],outpins_x,outpins_y,-2,1) and skip;
                                     if(carray[tearray[outpins_pin2_1]->cell]->padside!=3 AND carray[tearray[outpins_pin2_1]->cell]->padside!=6 AND carray[tearray[outpins_pin2_1]->cell]->padside!=10 AND carray[tearray[outpins_pin2_1]->cell]->padside!=8) then 
                                     {
                                         if(carray[outpins_netptr->cell]->padside=3) then 
                                         {
                                             outpins_xx:=outpins_r_core_edge
                                             
                                         }
                                         else
                                         {
                                             outpins_xx:=min_r_chan_edge(outpins_chan1,RValue);
                                             if(tearray[outpins_pin2_1]->xpos>outpins_xx) then 
                                             {
                                                 outpins_xx:=outpins_x
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                         };
                                         if(outpins_netptr->row=outpins_chan1) then 
                                         {
                                             outpins_y:=barray[outpins_netptr->row]->bycenter-rowHeight
                                             
                                         }
                                         else
                                         {
                                             outpins_y:=barray[outpins_netptr->row]->bycenter+rowHeight
                                         };
                                         fprintf(outpins_fp," %s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],"PSEUDO_CELL","PSEUDO_PIN",outpins_xx,outpins_y,outpins_chan1,2) and skip;
                                         fprintf(outpins_fp," %s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],"PSEUDO_CELL","PSEUDO_PIN",outpins_xx,outpins_y,-2,-1) and skip;
                                         if(outpins_chan2>0) then 
                                         {
                                             if(carray[tearray[outpins_pin2_2]->cell]->padside!=3 AND carray[tearray[outpins_pin2_2]->cell]->padside!=6 AND carray[tearray[outpins_pin2_2]->cell]->padside!=10 AND carray[tearray[outpins_pin2_2]->cell]->padside!=8) then 
                                             {
                                                 if(carray[outpins_netptr->cell]->padside=3) then 
                                                 {
                                                     outpins_xx:=outpins_r_core_edge
                                                     
                                                 }
                                                 else
                                                 {
                                                     outpins_xx:=min_r_chan_edge(outpins_chan2,RValue);
                                                     if(tearray[outpins_pin2_2]->xpos>outpins_xx) then 
                                                     {
                                                         outpins_xx:=outpins_x
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 };
                                                 if(outpins_netptr->row=outpins_chan2) then 
                                                 {
                                                     outpins_y:=barray[outpins_netptr->row]->bycenter-rowHeight
                                                     
                                                 }
                                                 else
                                                 {
                                                     outpins_y:=barray[outpins_netptr->row]->bycenter+rowHeight
                                                 };
                                                 fprintf(outpins_fp," %s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],"PSEUDO_CELL","PSEUDO_PIN",outpins_xx,outpins_y,outpins_chan2,2) and skip;
                                                 fprintf(outpins_fp," %s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],"PSEUDO_CELL","PSEUDO_PIN",outpins_xx,outpins_y,-2,-1) and skip
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                         }
                         else
                         {
                             if(outpins_chan1=outpins_netptr->row) then 
                             {
                                 fprintf(outpins_fp,"%s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],carray[outpins_netptr->cell]->cname,pinnames[outpins_pin],outpins_x,outpins_y,outpins_chan1,1) and skip
                                 
                             }
                             else
                             {
                                 fprintf(outpins_fp,"%s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],carray[outpins_netptr->cell]->cname,pinnames[outpins_pin],outpins_x,outpins_y,outpins_chan1,-1) and skip
                             };
                             if(outpins_chan2>0) then 
                             {
                                 if(outpins_chan2=outpins_netptr->row) then 
                                 {
                                     fprintf(outpins_fp,"%s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],carray[outpins_netptr->cell]->cname,pinnames[outpins_pin],outpins_x,outpins_y,outpins_chan2,1) and skip
                                 }
                                 else
                                 {
                                     fprintf(outpins_fp,"%s %d %s %s %d %d %d %d 0\n",netarray[outpins_net]->name,pinlist[outpins_pin],carray[outpins_netptr->cell]->cname,pinnames[outpins_pin],outpins_x,outpins_y,outpins_chan2,-1) and skip
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                         }
                     };
                     outpins_netptr:=outpins_netptr->nterm
                 }
                 else
                 {
                     skip
                 }
                 
             };
             continue<==0 and skip;
             outpins_net:=outpins_net+1
             
         };
         twclose(outpins_fp);
          return<==1 and skip
         )
         }; 
  function min_r_chan_edge ( int channel,int RValue )
 {
     frame(min_r_chan_edge_cell,min_r_chan_edge_end,min_r_chan_edge_end2,return) and ( 
     int return<==0 and skip;
     int min_r_chan_edge_cell,min_r_chan_edge_end,min_r_chan_edge_end2 and skip;
     if(channel=1) then 
     {
         min_r_chan_edge_cell:=pairArray[1,pairArray[1,0]];
         min_r_chan_edge_end:=carray[min_r_chan_edge_cell]->cxcenter+carray[min_r_chan_edge_cell]->tileptr->right
         
     }
     else
     {
         if(channel=numblock+1) then 
         {
             min_r_chan_edge_cell:=pairArray[numblock,pairArray[numblock,0]];
             min_r_chan_edge_end:=carray[min_r_chan_edge_cell]->cxcenter+carray[min_r_chan_edge_cell]->tileptr->right
         }
         else
         {
             min_r_chan_edge_cell:=pairArray[channel-1,pairArray[channel-1,0]];
             min_r_chan_edge_end:=carray[min_r_chan_edge_cell]->cxcenter+carray[min_r_chan_edge_cell]->tileptr->right;
             min_r_chan_edge_cell:=pairArray[channel,pairArray[channel,0]];
             min_r_chan_edge_end2:=carray[min_r_chan_edge_cell]->cxcenter+carray[min_r_chan_edge_cell]->tileptr->right;
             min_r_chan_edge_end:=( if((min_r_chan_edge_end<min_r_chan_edge_end2)) then min_r_chan_edge_end else min_r_chan_edge_end2)
         }
     };
     return<==1 and RValue:=min_r_chan_edge_end;
     skip
     )
     }; 
  function min_l_chan_edge ( int channel,int RValue )
 {
     frame(min_l_chan_edge_cell,min_l_chan_edge_end,min_l_chan_edge_end2,return) and ( 
     int return<==0 and skip;
     int min_l_chan_edge_cell,min_l_chan_edge_end,min_l_chan_edge_end2 and skip;
     if(channel=1) then 
     {
         min_l_chan_edge_cell:=pairArray[1,1];
         min_l_chan_edge_end:=carray[min_l_chan_edge_cell]->cxcenter+carray[min_l_chan_edge_cell]->tileptr->left
         
     }
     else
     {
         if(channel=numblock+1) then 
         {
             min_l_chan_edge_cell:=pairArray[numblock,1];
             min_l_chan_edge_end:=carray[min_l_chan_edge_cell]->cxcenter+carray[min_l_chan_edge_cell]->tileptr->left
         }
         else
         {
             min_l_chan_edge_cell:=pairArray[channel-1,1];
             min_l_chan_edge_end:=carray[min_l_chan_edge_cell]->cxcenter+carray[min_l_chan_edge_cell]->tileptr->left;
             min_l_chan_edge_cell:=pairArray[channel,1];
             min_l_chan_edge_end2:=carray[min_l_chan_edge_cell]->cxcenter+carray[min_l_chan_edge_cell]->tileptr->left;
             min_l_chan_edge_end:=( if((min_l_chan_edge_end>min_l_chan_edge_end2)) then min_l_chan_edge_end else min_l_chan_edge_end2)
         }
     };
     return<==1 and RValue:=min_l_chan_edge_end;
     skip
     )
     }; 
  function output$ (  )
 {
     frame(output$_fpp1,output$_fpp2,output$_locx,output$_locy,output$_height,output$_width,output$_k,output$_Wwd,output$_xloc,output$_i,output$_cell,output$_block,output$_orient,output$_num,output$_xloc2,output$_yloc2,output$_yloc,output$_array,output$_desire,output$_left,output$_right,output$_bottom,output$_top,output$_end,output$_filename,output$_cellptr,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     FILE *output$_fpp1,*output$_fpp2 and skip;
     int output$_locx,output$_locy,output$_height,output$_width,output$_k,output$_Wwd and skip;
     int output$_xloc,output$_i,output$_cell,output$_block,output$_orient and skip;
     int output$_num and skip;
     int output$_xloc2,output$_yloc2,output$_yloc and skip;
     int *output$_array,output$_desire and skip;
     int output$_left,output$_right,output$_bottom,output$_top,output$_end and skip;
     char output$_filename[64] and skip;
     cellbox* output$_cellptr and skip;
     sprintf(output$_filename,"%s.pl1",cktName,RValue) and skip;
     output$_fpp1:=twopen(output$_filename,"w",1,RValue);
     sprintf(output$_filename,"%s.pl2",cktName,RValue) and skip;
     output$_fpp2:=twopen(output$_filename,"w",1,RValue);
     continue<==0 and skip;
     output$_block:=1;
     
     while(output$_block<=numblock)
     {
          continue<==0 and skip;
         output$_left:=barray[output$_block]->bxcenter+barray[output$_block]->bleft;
         output$_right:=barray[output$_block]->bxcenter+barray[output$_block]->bright;
         output$_bottom:=barray[output$_block]->bycenter+barray[output$_block]->bbottom;
         output$_top:=barray[output$_block]->bycenter+barray[output$_block]->btop;
         if(restart=0 AND costonly=1) then 
         {
             output$_desire:=barray[output$_block]->desire
             
         }
         else
         {
             if(pairArray[output$_block,0]>0) then 
             {
                 output$_cell:=pairArray[output$_block,pairArray[output$_block,0]];
                 output$_end:=carray[output$_cell]->cxcenter+carray[output$_cell]->tileptr->right;
                 output$_desire:=output$_end-output$_left
             }
             else
             {
                 output$_desire:=0
             }
         };
         if(barray[output$_block]->borient>0) then 
         {
             fprintf(output$_fpp2,"%d %d %d  %d %d  0 0\n",output$_block,output$_left,output$_bottom,output$_left+output$_desire,output$_top) and skip
             
         }
         else
         {
             fprintf(output$_fpp2,"%d %d %d  %d %d  0 0\n",output$_block,output$_left,output$_bottom,output$_right,output$_bottom+output$_desire) and skip
         };
         output$_num:=pairArray[output$_block,0];
         if(output$_num=0) then 
         {
             continue<==1 and skip;
              output$_block:=output$_block+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             output$_array:=pairArray[output$_block]+1;
             output$_i:=0;
             
             while(output$_i<output$_num)
             {
                 output$_cell:=output$_array[output$_i];
                 output$_cellptr:=carray[output$_cell];
                 output$_orient:=output$_cellptr->corient;
                 output$_xloc:=output$_cellptr->cxcenter+output$_cellptr->tileptr->left;
                 output$_yloc:=output$_cellptr->cycenter+output$_cellptr->tileptr->bottom;
                 output$_xloc2:=output$_cellptr->tileptr->right-output$_cellptr->tileptr->left;
                 output$_yloc2:=output$_cellptr->tileptr->top-output$_cellptr->tileptr->bottom;
                 fprintf(output$_fpp1,"%s %d %d  %d %d  %d %d\n",output$_cellptr->cname,output$_xloc,output$_yloc,output$_xloc+output$_xloc2,output$_yloc+output$_yloc2,output$_orient,output$_block) and skip;
                 output$_i:=output$_i+1
                 
             };
             output$_block:=output$_block+1
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     output$_i:=numcells+1;
     
     while(output$_i<=numcells+numterms)
     {
         output$_cellptr:=carray[output$_i];
         output$_orient:=output$_cellptr->corient;
         output$_locx:=output$_cellptr->cxcenter+output$_cellptr->tileptr->left;
         output$_locy:=output$_cellptr->cycenter+output$_cellptr->tileptr->bottom;
         output$_height:=output$_cellptr->tileptr->top-output$_cellptr->tileptr->bottom;
         output$_width:=output$_cellptr->tileptr->right-output$_cellptr->tileptr->left;
         fprintf(output$_fpp1,"%s %d %d  %d %d  %d 0\n",output$_cellptr->cname,output$_locx,output$_locy,output$_locx+output$_width,output$_locy+output$_height,output$_orient) and skip;
         fprintf(output$_fpp2,"%s %d %d  %d %d  %d 0\n",output$_cellptr->cname,output$_locx,output$_locy,output$_locx+output$_width,output$_locy+output$_height,output$_orient) and skip;
         output$_i:=output$_i+1
         
     };
     twclose(output$_fpp1);
     twclose(output$_fpp2);
      return<==1 and skip
     )
     }; 
  function comparex ( int *a,int *b,int RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
     return<==1 and RValue:=(carray[* a]->cxcenter-carray[* b]->cxcenter);
     skip
     )
     }; 
      int celllen and skip;
     int *fixLRBT and skip;
     float *padspace and skip;
 function parser ( FILE *fp )
 {
     frame(parser_nptr,parser_cell,parser_test,parser_layer,parser_block,parser_left,parser_right,parser_bottom,parser_top,parser_xpos,parser_ypos,parser_orient,parser_from,parser_orderchk,parser_length,parser_terms,parser_term,parser_i,parser_pinctr,parser_space,parser_input$,return) and ( 
     int return<==0 and skip;
     dimbox* parser_nptr and skip;
     int parser_cell,parser_test,parser_layer and skip;
     int parser_block,parser_left,parser_right,parser_bottom,parser_top and skip;
     int parser_xpos,parser_ypos,parser_orient and skip;
     int parser_from,parser_orderchk and skip;
     int parser_length,parser_terms and skip;
     int parser_term,parser_i,parser_pinctr and skip;
     float parser_space and skip;
     char parser_input$[1024] and skip;
     celllen:=0;
     parser_cell:=0;
     parser_terms:=0;
     parser_pinctr:=0;
     maketabl();
     while(fscanf(fp," %s ",parser_input$)=1)
     {
         if(strcmp(parser_input$,"cell")=0) then 
         {
             parser_cell:=parser_cell+1;
             parser_orderchk:=0;
             parser_test:=fscanf(fp," %s ",parser_input$);
             if(parser_test!=1) then 
             {
                 fprintf(fpo,"Failed to input dummy cell number/name ") and skip;
                 fprintf(fpo,"in the .cel file\n") and skip;
                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                 exit(0) and skip 
                 
             }
             else 
             {
                  skip 
             };
             fscanf(fp," %s ",parser_input$) and skip
         }
         else
         {
             if(strcmp(parser_input$,"left")=0) then 
             {
                 parser_test:=fscanf(fp," %d ",&parser_left);
                 if(parser_test!=1) then 
                 {
                     fprintf(fpo,"Failed to input left ") and skip;
                     fprintf(fpo,"in the .cel file\n") and skip;
                     fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                     exit(0) and skip 
                     
                 }
                 else 
                 {
                      skip 
                 };
                 fscanf(fp," %s ",parser_input$) and skip;
                 if(strcmp(parser_input$,"right")=0) then 
                 {
                     parser_test:=fscanf(fp," %d ",&parser_right);
                     if(parser_test!=1) then 
                     {
                         fprintf(fpo,"Failed to input right ") and skip;
                         fprintf(fpo,"in the .cel file\n") and skip;
                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                         exit(0) and skip 
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else
                 {
                     fprintf(fpo,"Failed to find keyword right ") and skip;
                     fprintf(fpo,"for a cell\n") and skip;
                     fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                     exit(0) and skip 
                 };
                 fscanf(fp," %s ",parser_input$) and skip;
                 if(strcmp(parser_input$,"bottom")=0) then 
                 {
                     parser_test:=fscanf(fp," %d ",&parser_bottom);
                     if(parser_test!=1) then 
                     {
                         fprintf(fpo,"Failed to input bottom ") and skip;
                         fprintf(fpo,"in the .cel file\n") and skip;
                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                         exit(0) and skip 
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else
                 {
                     fprintf(fpo,"Failed to find keyword bottom ") and skip;
                     fprintf(fpo,"for a cell\n") and skip;
                     fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                     exit(0) and skip 
                 };
                 fscanf(fp," %s ",parser_input$) and skip;
                 if(strcmp(parser_input$,"top")=0) then 
                 {
                     parser_test:=fscanf(fp," %d ",&parser_top);
                     if(parser_test!=1) then 
                     {
                         fprintf(fpo,"Failed to input top ") and skip;
                         fprintf(fpo,"in the .cel file\n") and skip;
                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                         exit(0) and skip 
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else
                 {
                     fprintf(fpo,"Failed to find keyword top ") and skip;
                     fprintf(fpo,"for a cell\n") and skip;
                     fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                     exit(0) and skip 
                 };
                 if(parser_right+parser_left!=0 AND parser_right+parser_left!=1 OR parser_left>0) then 
                 {
                     fprintf(fpo,"The given center of the cell ") and skip;
                     fprintf(fpo,"is not (right + left) div 2\n") and skip;
                     fprintf(fpo,"Where the remainder is truncated\n") and skip;
                     fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                     exit(0) and skip 
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(parser_top+parser_bottom!=0 AND parser_top+parser_bottom!=1 OR parser_bottom>0) then 
                 {
                     fprintf(fpo,"The given center of the cell ") and skip;
                     fprintf(fpo,"is not (top + bottom) div 2\n") and skip;
                     fprintf(fpo,"Where the remainder is truncated\n") and skip;
                     fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                     exit(0) and skip 
                     
                 }
                 else 
                 {
                      skip 
                 };
                 parser_length:=parser_right-parser_left;
                 celllen:=celllen+parser_length
             }
             else
             {
                 if(strcmp(parser_input$,"initially")=0) then 
                 {
                     if(parser_orderchk!=0) then 
                     {
                         fprintf(fpo,"cannot preplace fixed sequence\n") and skip;
                         fprintf(fpo,"in the .cel file\n") and skip;
                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                         exit(0) and skip 
                         
                     }
                     else 
                     {
                          skip 
                     };
                     parser_orderchk:=1;
                     fscanf(fp," %s ",parser_input$) and skip;
                     if(strcmp(parser_input$,"fixed")=0) then 
                     {
                         skip
                     }
                     else
                     {
                         if(strcmp(parser_input$,"nonfixed")=0) then 
                         {
						   skip
                         }
                         else
                         {
                             fprintf(fpo,"Failed to find fixed or nonfixed\n") and skip;
                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                             exit(0) and skip 
                         }
                     };
                     parser_test:=fscanf(fp," %d ",&parser_from);
                     if(parser_test!=1) then 
                     {
                         fprintf(fpo,"Failed to input amount from following ") and skip;
                         fprintf(fpo,"(fixed,nonfixed) in the .cel file") and skip;
                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                         exit(0) and skip 
                         
                     }
                     else 
                     {
                          skip 
                     };
                     fscanf(fp," %s ",parser_input$) and skip;
                     if(strcmp(parser_input$,"from")!=0) then 
                     {
                         fprintf(fpo,"Failed to find keyword from ") and skip;
                         fprintf(fpo,"in the .cel file") and skip;
                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                         exit(0) and skip 
                         
                     }
                     else 
                     {
                          skip 
                     };
                     fscanf(fp," %s ",parser_input$) and skip;
                     if(strcmp(parser_input$,"left")=0) then 
                     {
                         skip
                     }
                     else
                     {
                         if(strcmp(parser_input$,"right")=0) then 
                         {
						  skip
                         }
                         else
                         {
                             fprintf(fpo,"Failed to find left or right\n") and skip;
                             fprintf(fpo,"following from in the .cel file") and skip;
                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                             exit(0) and skip 
                         }
                     };
                     fscanf(fp," %s ",parser_input$) and skip;
                     if(strcmp(parser_input$,"of")!=0) then 
                     {
                         fprintf(fpo,"Failed to find keyword of ") and skip;
                         fprintf(fpo,"in the .cel file") and skip;
                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                         exit(0) and skip 
                         
                     }
                     else 
                     {
                          skip 
                     };
                     fscanf(fp," %s ",parser_input$) and skip;
                     if(strcmp(parser_input$,"block")!=0) then 
                     {
                         fprintf(fpo,"Failed to find keyword block ") and skip;
                         fprintf(fpo,"in the .cel file") and skip;
                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                         exit(0) and skip 
                         
                     }
                     else 
                     {
                          skip 
                     };
                     parser_test:=fscanf(fp," %d ",&parser_block);
                     if(parser_test!=1) then 
                     {
                         fprintf(fpo,"Failed to input amount from following ") and skip;
                         fprintf(fpo,"(fixed,nonfixed) in the .cel file") and skip;
                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                         exit(0) and skip 
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     if(strcmp(parser_input$,"nomirror")=0) then 
                     {
					   skip
                     }
                     else
                     {
                         if(strcmp(parser_input$,"pin")=0) then 
                         {
                             fscanf(fp," %s ",parser_input$) and skip;
                             if(strcmp(parser_input$,"name")!=0) then 
                             {
                                 fprintf(fpo,"Failed to find keyword name ") and skip;
                                 fprintf(fpo,"for a pin\n") and skip;
                                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                 exit(0) and skip 
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             parser_test:=fscanf(fp," %s ",parser_input$);
                             if(parser_test!=1) then 
                             {
                                 fprintf(fpo,"Failed to input pin name ") and skip;
                                 fprintf(fpo,"in the .cel file\n") and skip;
                                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                 exit(0) and skip 
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             fscanf(fp," %s ",parser_input$) and skip;
                             if(strcmp(parser_input$,"signal")!=0) then 
                             {
                                 fprintf(fpo,"Failed to find keyword signal ") and skip;
                                 fprintf(fpo,"for a pin\n") and skip;
                                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                 exit(0) and skip 
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             parser_test:=fscanf(fp," %s ",parser_input$);
                             if(parser_test!=1) then 
                             {
                                 fprintf(fpo,"Failed to input signal name ") and skip;
                                 fprintf(fpo,"in the .cel file\n") and skip;
                                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                 exit(0) and skip 
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(strcmp(parser_input$,"TW_PASS_THRU")!=0) then 
                             {
                                 addhash(parser_input$,RValue);
                                 parser_pinctr:=parser_pinctr+1
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(pin_layers_given!=0) then 
                             {
                                 fscanf(fp," %s ",parser_input$) and skip;
                                 if(strcmp(parser_input$,"layer")!=0) then 
                                 {
                                     fprintf(fpo,"Failed to find keyword layer ") and skip;
                                     fprintf(fpo,"for a pin\n") and skip;
                                     fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                     exit(0) and skip 
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 parser_test:=fscanf(fp," %d ",&parser_layer);
                                 if(parser_test!=1) then 
                                 {
                                     fprintf(fpo,"Failed to input layer number ") and skip;
                                     fprintf(fpo,"in the .cel file\n") and skip;
                                     fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                     exit(0) and skip 
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(parser_layer!=1 AND parser_layer!=2 AND parser_layer!=3) then 
                                 {
                                     fprintf(fpo,"Currently, a layer number ") and skip;
                                     fprintf(fpo,"in the .cel file must be either 1, 2,\n") and skip;
                                     fprintf(fpo,"or 3.   Current cell: %d\n",parser_cell) and skip;
                                     exit(0) and skip 
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             parser_test:=fscanf(fp," %d %d ",&parser_xpos,&parser_ypos);
                             if(parser_test!=2) then 
                             {
                                 fprintf(fpo,"Failed to input 2 items ") and skip;
                                 fprintf(fpo,"for pin in the .cel file\n") and skip;
                                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                 exit(0) and skip 
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                         }
                         else
                         {
                             if(strcmp(parser_input$,"equiv")=0) then 
                             {
                                 fscanf(fp," %s ",parser_input$) and skip;
                                 if(strcmp(parser_input$,"name")!=0) then 
                                 {
                                     fprintf(fpo,"Failed to find keyword name ") and skip;
                                     fprintf(fpo,"for an equiv pin\n") and skip;
                                     fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                     exit(0) and skip 
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 parser_test:=fscanf(fp," %s ",parser_input$);
                                 if(parser_test!=1) then 
                                 {
                                     fprintf(fpo,"Failed to input equiv pin name ") and skip;
                                     fprintf(fpo,"in the .cel file\n") and skip;
                                     fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                     exit(0) and skip 
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(pin_layers_given!=0) then 
                                 {
                                     fscanf(fp," %s ",parser_input$) and skip;
                                     if(strcmp(parser_input$,"layer")!=0) then 
                                     {
                                         fprintf(fpo,"Failed to find keyword layer ") and skip;
                                         fprintf(fpo,"for an equiv pin\n") and skip;
                                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                         exit(0) and skip 
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     parser_test:=fscanf(fp," %d ",&parser_layer);
                                     if(parser_test!=1) then 
                                     {
                                         fprintf(fpo,"Failed to input layer number ") and skip;
                                         fprintf(fpo,"in the .cel file\n") and skip;
                                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                         exit(0) and skip 
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     if(parser_layer!=1 AND parser_layer!=2 AND parser_layer!=3) then 
                                     {
                                         fprintf(fpo,"Currently, a layer number ") and skip;
                                         fprintf(fpo,"in the .cel file must be either 1, 2,\n") and skip;
                                         fprintf(fpo,"or 3.   Current cell: %d\n",parser_cell) and skip;
                                         exit(0) and skip 
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 parser_test:=fscanf(fp," %d %d ",&parser_xpos,&parser_ypos);
                                 if(parser_test!=2) then 
                                 {
                                     fprintf(fpo,"Failed to input 2 items ") and skip;
                                     fprintf(fpo,"for equiv in the .cel file\n") and skip;
                                     fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                     exit(0) and skip 
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                             else
                             {
                                 if(strcmp(parser_input$,"unequiv")=0) then 
                                 {
                                     fscanf(fp," %s ",parser_input$) and skip;
                                     if(strcmp(parser_input$,"name")!=0) then 
                                     {
                                         fprintf(fpo,"Failed to find keyword name ") and skip;
                                         fprintf(fpo,"for an unequiv pin\n") and skip;
                                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                         exit(0) and skip 
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     parser_test:=fscanf(fp," %s ",parser_input$);
                                     if(parser_test!=1) then 
                                     {
                                         fprintf(fpo,"Failed to input unequiv pin name ") and skip;
                                         fprintf(fpo,"in the .cel file\n") and skip;
                                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                         exit(0) and skip 
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     if(pin_layers_given!=0) then 
                                     {
                                         fscanf(fp," %s ",parser_input$) and skip;
                                         if(strcmp(parser_input$,"layer")!=0) then 
                                         {
                                             fprintf(fpo,"Failed to find keyword layer ") and skip;
                                             fprintf(fpo,"for an unequiv pin\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         parser_test:=fscanf(fp," %d ",&parser_layer);
                                         if(parser_test!=1) then 
                                         {
                                             fprintf(fpo,"Failed to input layer number ") and skip;
                                             fprintf(fpo,"in the .cel file\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         if(parser_layer!=1 AND parser_layer!=2 AND parser_layer!=3) then 
                                         {
                                             fprintf(fpo,"Currently, a layer number ") and skip;
                                             fprintf(fpo,"in the .cel file must be either 1, 2,\n") and skip;
                                             fprintf(fpo,"or 3.   Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     parser_test:=fscanf(fp," %d %d ",&parser_xpos,&parser_ypos);
                                     if(parser_test!=2) then 
                                     {
                                         fprintf(fpo,"Failed to input 2 items ") and skip;
                                         fprintf(fpo,"for unequiv in the .cel file\n") and skip;
                                         fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                         exit(0) and skip 
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                 }
                                 else
                                 {
                                     if(strcmp(parser_input$,"pad")=0) then 
                                     {
                                         parser_terms:=parser_terms+1;
                                         parser_test:=fscanf(fp," %s ",parser_input$);
                                         if(parser_test!=1) then 
                                         {
                                             fprintf(fpo,"Failed to input dummy pad number/name ") and skip;
                                             fprintf(fpo,"in the .cel file\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         fscanf(fp," %s ",parser_input$) and skip;
                                         fscanf(fp," %s ",parser_input$) and skip;
                                         if(strcmp(parser_input$,"orient")=0) then 
                                         {
                                             parser_test:=fscanf(fp," %d ",&parser_orient);
                                             if(parser_test!=1) then 
                                             {
                                                 fprintf(fpo,"Failed to input orient ") and skip;
                                                 fprintf(fpo,"in the .cel file\n") and skip;
                                                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                                 exit(0) and skip 
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                             
                                         }
                                         else
                                         {
                                             fprintf(fpo,"Failed to find keyword orient ") and skip;
                                             fprintf(fpo,"for a pad\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                         };
                                         fscanf(fp," %s ",parser_input$) and skip;
                                         if(strcmp(parser_input$,"padside")=0) then 
                                         {
                                             parser_test:=fscanf(fp," %s ",parser_input$);
                                             if(parser_test!=1) then 
                                             {
                                                 fprintf(fpo,"Failed to input padside ") and skip;
                                                 fprintf(fpo,"in the .cel file\n") and skip;
                                                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                                 exit(0) and skip 
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                             
                                         }
                                         else
                                         {
                                             fprintf(fpo,"Failed to find keyword padside ") and skip;
                                             fprintf(fpo,"for a pad\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                         };
                                         fscanf(fp," %s ",parser_input$) and skip;
                                         if(strcmp(parser_input$,"left")=0) then 
                                         {
                                             parser_test:=fscanf(fp," %d ",&parser_left);
                                             if(parser_test!=1) then 
                                             {
                                                 fprintf(fpo,"Failed to input left ") and skip;
                                                 fprintf(fpo,"in the .cel file\n") and skip;
                                                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                                 exit(0) and skip 
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                             
                                         }
                                         else
                                         {
                                             fprintf(fpo,"Failed to find keyword left ") and skip;
                                             fprintf(fpo,"for a pad\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                         };
                                         fscanf(fp," %s ",parser_input$) and skip;
                                         if(strcmp(parser_input$,"right")=0) then 
                                         {
                                             parser_test:=fscanf(fp," %d ",&parser_right);
                                             if(parser_test!=1) then 
                                             {
                                                 fprintf(fpo,"Failed to input right ") and skip;
                                                 fprintf(fpo,"in the .cel file\n") and skip;
                                                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                                 exit(0) and skip 
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                             
                                         }
                                         else
                                         {
                                             fprintf(fpo,"Failed to find keyword right ") and skip;
                                             fprintf(fpo,"for a pad\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                         };
                                         if(parser_right+parser_left!=0 AND parser_right+parser_left!=1) then 
                                         {
                                             fprintf(fpo,"The given center of the cell ") and skip;
                                             fprintf(fpo,"is not (right + left) div 2\n") and skip;
                                             fprintf(fpo,"Where the remainder is truncated\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         fscanf(fp," %s ",parser_input$) and skip;
                                         if(strcmp(parser_input$,"bottom")=0) then 
                                         {
                                             parser_test:=fscanf(fp," %d ",&parser_bottom);
                                             if(parser_test!=1) then 
                                             {
                                                 fprintf(fpo,"Failed to input bottom ") and skip;
                                                 fprintf(fpo,"in the .cel file\n") and skip;
                                                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                                 exit(0) and skip 
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                             
                                         }
                                         else
                                         {
                                             fprintf(fpo,"Failed to find keyword bottom ") and skip;
                                             fprintf(fpo,"for a pad\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                         };
                                         fscanf(fp," %s ",parser_input$) and skip;
                                         if(strcmp(parser_input$,"top")=0) then 
                                         {
                                             parser_test:=fscanf(fp," %d ",&parser_top);
                                             if(parser_test!=1) then 
                                             {
                                                 fprintf(fpo,"Failed to input top ") and skip;
                                                 fprintf(fpo,"in the .cel file\n") and skip;
                                                 fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                                 exit(0) and skip 
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                             
                                         }
                                         else
                                         {
                                             fprintf(fpo,"Failed to find keyword top ") and skip;
                                             fprintf(fpo,"for a pad\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                         };
                                         if(parser_top+parser_bottom!=0 AND parser_top+parser_bottom!=1) then 
                                         {
                                             fprintf(fpo,"The given center of the cell ") and skip;
                                             fprintf(fpo,"is not (top + bottom) div 2\n") and skip;
                                             fprintf(fpo,"Where the remainder is truncated\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     }
                                     else
                                     {
                                         if(strcmp(parser_input$,"sidespace")=0) then 
                                         {
                                             parser_test:=fscanf(fp," %f ",&parser_space)
                                         }
                                         else
                                         {
                                             fprintf(fpo,"Found unparsable keyword in ") and skip;
                                             fprintf(fpo,"the .cel file\n") and skip;
                                             fprintf(fpo,"Current cell: %d\n",parser_cell) and skip;
                                             exit(0) and skip 
                                         }
                                     }
                                 }
                             }
                         }
                     }
                 }
             }
         }
     };
     rewind(fp) and skip;
     numcells:=parser_cell;
     numterms:=parser_terms;
     padspace:=(float *)safe_malloc((numterms+1)*sizeof(float),RValue);
     parser_i:=1;
     
     while(parser_i<=numterms)
     {
         padspace[parser_i]:=0.0;
         parser_i:=parser_i+1
         
     };
     fixLRBT:=(int *)safe_malloc(4*sizeof(int),RValue);
     fixLRBT[0]:=0;
     fixLRBT[1]:=0;
     fixLRBT[2]:=0;
     fixLRBT[3]:=0;
     netarray:=(dimbox* *)safe_malloc((netctr+1)*sizeof(dimbox*),RValue);
     parser_i:=1;
     
     while(parser_i<=netctr)
     {
         netarray[parser_i]:= (dimbox*)safe_malloc(sizeof(dimbox),RValue);
		 parser_nptr<==netarray[parser_i] and skip;
         parser_nptr->netptr:=NULL;
         parser_nptr->name:=NULL;
         parser_nptr->dflag:=0;
         parser_nptr->xmin:=0;
         parser_nptr->newxmin:=0;
         parser_nptr->xmax:=0;
         parser_nptr->newxmax:=0;
         parser_nptr->ymin:=0;
         parser_nptr->newymin:=0;
         parser_nptr->ymax:=0;
         parser_nptr->newymax:=0;
         parser_nptr->Hweight:=1.0;
         parser_nptr->Vweight:=1.0;
         parser_nptr->feedflag:=0;
         parser_nptr->ignore:=0;
         parser_i:=parser_i+1
         
     };
     numnets:=netctr;
     tearray:=(netbox* *)safe_malloc((parser_pinctr+1)*sizeof(netbox*),RValue);
     parser_term:=1;
     
     while(parser_term<=parser_pinctr)
     {
         tearray[parser_term]:=NULL;
         parser_term:=parser_term+1
         
     };
     maxterm:=parser_pinctr;
      return<==1 and skip
     )
     }; 
  function purcost ( int segment,int RValue )
 {
     frame(purcost_top,purcost_bot,purcost_asegptr,purcost_bsegptr,purcost_aptr1,purcost_aptr2,purcost_bptr1,purcost_bptr2,purcost_bptr,purcost_fptr,purcost_ptr,purcost_saptr,purcost_eaptr,purcost_sbptr,purcost_ebptr,purcost_denptr,purcost_headptr,purcost_penalty,purcost_current,purcost_check,purcost_x,purcost_achannel,purcost_bchannel,purcost_aMaxVal,purcost_bMaxVal,purcost_maxaa,purcost_maxbb,purcost_aoutside,purcost_binside,purcost_ax1,purcost_ax2,purcost_bx1,purcost_bx2,purcost_net,purcost_Flag,purcost_track,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     segbox* purcost_top,*purcost_bot,*purcost_asegptr,*purcost_bsegptr and skip;
     changrdbox* purcost_aptr1,*purcost_aptr2,*purcost_bptr1,*purcost_bptr2,*purcost_bptr,*purcost_fptr,*purcost_ptr and skip;
     changrdbox* purcost_saptr,*purcost_eaptr,*purcost_sbptr,*purcost_ebptr and skip;
     densitybox* purcost_denptr,*purcost_headptr and skip;
     int purcost_penalty,purcost_current,purcost_check and skip;
     int purcost_x,purcost_achannel,purcost_bchannel,purcost_aMaxVal,purcost_bMaxVal and skip;
     int purcost_maxaa,purcost_maxbb and skip;
     int purcost_aoutside,purcost_binside and skip;
     int purcost_ax1,purcost_ax2,purcost_bx1,purcost_bx2 and skip;
     int purcost_net,purcost_Flag,purcost_track and skip;
     purcost_penalty:=0;
     if(aNetSeg[segment].nflag=0) then 
     {
         purcost_top:=aNetSeg[segment].top;
         purcost_bot:=aNetSeg[segment].bot;
         purcost_current:=aNetSeg[segment].current
         
     }
     else
     {
         purcost_top:=aNetSeg[segment].ntop;
         purcost_bot:=aNetSeg[segment].nbot;
         purcost_current:=aNetSeg[segment].ncurrent
     };
     if(purcost_current=0) then 
     {
         purcost_asegptr:=purcost_top;
         purcost_bsegptr:=purcost_bot
         
     }
     else
     {
         purcost_asegptr:=purcost_bot;
         purcost_bsegptr:=purcost_top
     };
     purcost_achannel:=purcost_asegptr->channel;
     purcost_bchannel:=purcost_bsegptr->channel;
     purcost_aptr1:=purcost_asegptr->pin1ptr;
     purcost_aptr2:=purcost_asegptr->pin2ptr;
     purcost_bptr1:=purcost_bsegptr->pin1ptr;
     purcost_bptr2:=purcost_bsegptr->pin2ptr;
     purcost_aMaxVal:=nmaxTrack[purcost_achannel];
     purcost_bMaxVal:=nmaxTrack[purcost_bchannel];
     purcost_ax1:=purcost_aptr1->netptr->xpos;
     purcost_ax2:=purcost_aptr2->netptr->xpos;
     purcost_bx1:=purcost_bptr1->netptr->xpos;
     purcost_bx2:=purcost_bptr2->netptr->xpos;
     purcost_net:=aNetSeg[segment].net;
     if(purcost_aptr1->nSegType>0) then 
     {
         purcost_Flag:=0;
         purcost_bptr:=purcost_aptr1;
         break$<==0 and skip;
         while( break$=0 AND  purcost_bptr->nprevgrd!=NULL AND purcost_bptr->nprevgrd->netptr->xpos=purcost_ax1)
         {
             if(purcost_net=tearray[purcost_bptr->nprevgrd->netptr->terminal]->net AND purcost_bptr->nprevgrd->nSegType<0) then 
             {
                 purcost_Flag:=1;
                 purcost_saptr:=purcost_aptr1->nnextgrd;
                 while(purcost_saptr->netptr->xpos=purcost_ax1)
                 {
                     purcost_saptr:=purcost_saptr->nnextgrd
                 };
                 break$<==1 and skip
              }
             else
             {
                 purcost_bptr:=purcost_bptr->nprevgrd
             }
         };
         break$<==0 and skip;
         if(!purcost_Flag) then 
         {
             purcost_saptr:=purcost_aptr1->nnextgrd;
             while(purcost_saptr->netptr->xpos=purcost_ax1)
             {
                 if(purcost_net=tearray[purcost_saptr->netptr->terminal]->net AND purcost_saptr->nSegType<0) then 
                 {
                     purcost_Flag:=1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 purcost_saptr:=purcost_saptr->nnextgrd
             }
             
         }
         else 
         {
              skip 
         };
         if(!purcost_Flag) then 
         {
             purcost_saptr:=purcost_bptr
             
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         if(purcost_ax1!=gxstart) then 
         {
             purcost_saptr:=purcost_aptr1->nnextgrd;
             while(purcost_saptr->netptr->xpos=purcost_ax1)
             {
                 purcost_saptr:=purcost_saptr->nnextgrd
             }
         }
         else
         {
             purcost_saptr:=purcost_aptr1
         }
     };
     if(purcost_aptr2->nSegType<0) then 
     {
         purcost_Flag:=0;
         purcost_fptr:=purcost_aptr2;
         break$<==0 and skip;
         while( break$=0 AND  purcost_fptr->nnextgrd!=NULL AND purcost_fptr->nnextgrd->netptr->xpos=purcost_ax2)
         {
             if(purcost_net=tearray[purcost_fptr->nnextgrd->netptr->terminal]->net AND purcost_fptr->nnextgrd->nSegType>0) then 
             {
                 purcost_Flag:=1;
                 purcost_eaptr:=purcost_aptr2->nprevgrd;
                 while(purcost_eaptr->netptr->xpos=purcost_ax2)
                 {
                     purcost_eaptr:=purcost_eaptr->nprevgrd
                 };
                 break$<==1 and skip
              }
             else
             {
                 purcost_fptr:=purcost_fptr->nnextgrd
             }
         };
         break$<==0 and skip;
         if(!purcost_Flag) then 
         {
             purcost_eaptr:=purcost_aptr2->nprevgrd;
             while(purcost_eaptr->netptr->xpos=purcost_ax2)
             {
                 if(purcost_net=tearray[purcost_eaptr->netptr->terminal]->net AND purcost_eaptr->nSegType>0) then 
                 {
                     purcost_Flag:=1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 purcost_eaptr:=purcost_eaptr->nprevgrd
             }
             
         }
         else 
         {
              skip 
         };
         if(!purcost_Flag) then 
         {
             purcost_eaptr:=purcost_fptr
             
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         if(purcost_ax2!=gxstop) then 
         {
             purcost_eaptr:=purcost_aptr2->nprevgrd;
             while(purcost_eaptr->netptr->xpos=purcost_ax2)
             {
                 purcost_eaptr:=purcost_eaptr->nprevgrd
             }
         }
         else
         {
             purcost_eaptr:=purcost_aptr2
         }
     };
     if(purcost_bptr1->nSegType>=0) then 
     {
         purcost_Flag:=0;
         purcost_bptr:=purcost_bptr1;
         break$<==0 and skip;
         while( break$=0 AND  purcost_bptr->nprevgrd!=NULL AND purcost_bptr->nprevgrd->netptr->xpos=purcost_bx1)
         {
             if(purcost_net=tearray[purcost_bptr->nprevgrd->netptr->terminal]->net AND purcost_bptr->nprevgrd->nSegType<0) then 
             {
                 purcost_Flag:=1;
                 purcost_sbptr:=purcost_bptr1->nnextgrd;
                 while(purcost_sbptr->netptr->xpos=purcost_bx1)
                 {
                     purcost_sbptr:=purcost_sbptr->nnextgrd
                 };
                 break$<==1 and skip
              }
             else
             {
                 purcost_bptr:=purcost_bptr->nprevgrd
             }
         };
         break$<==0 and skip;
         if(!purcost_Flag) then 
         {
             purcost_sbptr:=purcost_bptr1->nnextgrd;
             while(purcost_sbptr->netptr->xpos=purcost_bx1)
             {
                 if(purcost_net=tearray[purcost_sbptr->netptr->terminal]->net AND purcost_sbptr->nSegType<0) then 
                 {
                     purcost_Flag:=1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 purcost_sbptr:=purcost_sbptr->nnextgrd
             }
             
         }
         else 
         {
              skip 
         };
         if(!purcost_Flag) then 
         {
             purcost_sbptr:=purcost_bptr
             
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         purcost_sbptr:=purcost_bptr1->nnextgrd;
         while(purcost_sbptr->netptr->xpos=purcost_bx1)
         {
             purcost_sbptr:=purcost_sbptr->nnextgrd
         }
     };
     if(purcost_bptr2->nSegType<=0) then 
     {
         purcost_Flag:=0;
         purcost_fptr:=purcost_bptr2;
         break$<==0 and skip;
         while( break$=0 AND  purcost_fptr->nnextgrd!=NULL AND purcost_fptr->nnextgrd->netptr->xpos=purcost_bx2)
         {
             if(purcost_net=tearray[purcost_fptr->nnextgrd->netptr->terminal]->net AND purcost_fptr->nnextgrd->nSegType>0) then 
             {
                 purcost_Flag:=1;
                 purcost_ebptr:=purcost_bptr2->nprevgrd;
                 while(purcost_ebptr->netptr->xpos=purcost_bx2)
                 {
                     purcost_ebptr:=purcost_ebptr->nprevgrd
                 };
                 break$<==1 and skip
              }
             else
             {
                 purcost_fptr:=purcost_fptr->nnextgrd
             }
         };
         break$<==0 and skip;
         if(!purcost_Flag) then 
         {
             purcost_ebptr:=purcost_bptr2->nprevgrd;
             while(purcost_ebptr->netptr->xpos=purcost_bx2)
             {
                 if(purcost_net=tearray[purcost_ebptr->netptr->terminal]->net AND purcost_ebptr->nSegType>0) then 
                 {
                     purcost_Flag:=1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 purcost_ebptr:=purcost_ebptr->nprevgrd
             }
             
         }
         else 
         {
              skip 
         };
         if(!purcost_Flag) then 
         {
             purcost_ebptr:=purcost_fptr
             
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         purcost_ebptr:=purcost_bptr2->nprevgrd;
         while(purcost_ebptr->netptr->xpos=purcost_bx2)
         {
             purcost_ebptr:=purcost_ebptr->nprevgrd
         }
     };
     purcost_aoutside:=0;
     purcost_ax1:=purcost_saptr->netptr->xpos;
     purcost_ax2:=purcost_eaptr->netptr->xpos;
     purcost_denptr:=DboxHead[purcost_achannel,purcost_aMaxVal]->nnext;
     break$<==0 and skip;
     while( break$=0 AND  purcost_denptr!=NULL)
     {
         purcost_x:=purcost_denptr->grdptr->netptr->xpos;
         if(!(purcost_ax1<=purcost_x AND purcost_ax2>=purcost_x)) then 
         {
             purcost_aoutside:=1;
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             purcost_denptr:=purcost_denptr->nnext
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     if(purcost_aoutside=0) then 
     {
         purcost_penalty:=purcost_penalty-1
         
     }
     else 
     {
          skip 
     };
     purcost_binside:=0;
     purcost_bx1:=purcost_sbptr->netptr->xpos;
     purcost_bx2:=purcost_ebptr->netptr->xpos;
     purcost_denptr:=DboxHead[purcost_bchannel,purcost_bMaxVal]->nnext;
     break$<==0 and skip;
     while( break$=0 AND  purcost_denptr!=NULL)
     {
         purcost_x:=purcost_denptr->grdptr->netptr->xpos;
         if(purcost_bx1<=purcost_x AND purcost_bx2>=purcost_x) then 
         {
             purcost_binside:=1;
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             purcost_denptr:=purcost_denptr->nnext
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     if(purcost_binside=1) then 
     {
         purcost_penalty:=purcost_penalty+1
         
     }
     else 
     {
          skip 
     };
     purcost_eaptr:=purcost_eaptr->nnextgrd;
     purcost_ebptr:=purcost_ebptr->nnextgrd;
     if(purcost_penalty=0) then 
     {
         if(purcost_binside=1 AND purcost_aoutside=0) then 
         {
             purcost_check:=purcost_bMaxVal-purcost_aMaxVal+2
         }
         else
         {
             purcost_maxaa:=0;
             purcost_maxbb:=0;
             purcost_ptr:=purcost_saptr;
             
             while(purcost_ptr!=purcost_eaptr)
             {
                 if(purcost_ptr->ntracks>purcost_maxaa) then 
                 {
                     purcost_maxaa:=purcost_ptr->ntracks
                     
                 }
                 else 
                 {
                      skip 
                 };
                 purcost_ptr:=purcost_ptr->nnextgrd
                 
             };
             purcost_ptr:=purcost_sbptr;
             
             while(purcost_ptr!=purcost_ebptr)
             {
                 if(purcost_ptr->ntracks>purcost_maxbb) then 
                 {
                     purcost_maxbb:=purcost_ptr->ntracks
                     
                 }
                 else 
                 {
                      skip 
                 };
                 purcost_ptr:=purcost_ptr->nnextgrd
                 
             };
             purcost_maxaa:=purcost_aMaxVal-purcost_maxaa+1;
             purcost_maxbb:=purcost_bMaxVal-purcost_maxbb-1;
             purcost_check:=purcost_maxaa-purcost_maxbb
         }
         
     }
     else
     {
         purcost_check:=purcost_penalty
     };
     if(purcost_check<=0) then 
     {
         if(purcost_asegptr->pin1<=maxterm) then 
         {
             purcost_aptr1->nSegType:=purcost_aptr1->nSegType-1
             
         }
         else 
         {
              skip 
         };
         if(purcost_asegptr->pin2<=maxterm) then 
         {
             purcost_aptr2->nSegType:=purcost_aptr2->nSegType-(-1)
             
         }
         else 
         {
              skip 
         };
         if(purcost_bsegptr->pin1<=maxterm) then 
         {
             purcost_bptr1->nSegType:=purcost_bptr1->nSegType+1
             
         }
         else 
         {
              skip 
         };
         if(purcost_bsegptr->pin2<=maxterm) then 
         {
             purcost_bptr2->nSegType:=purcost_bptr2->nSegType+(-1)
             
         }
         else 
         {
              skip 
         };
         purcost_ptr:=purcost_saptr;
         
         while(purcost_ptr!=purcost_eaptr)
         {
             purcost_denptr:=purcost_ptr->dptr;
             if(purcost_denptr->nnext!=NULL) then 
             {
                 purcost_denptr->nnext->nback:=purcost_denptr->nback
                 
             }
             else 
             {
                  skip 
             };
             purcost_denptr->nback->nnext:=purcost_denptr->nnext;
             purcost_track:=((purcost_ptr->ntracks)-1);
             (purcost_ptr->ntracks):=(purcost_ptr->ntracks)-1;
             purcost_headptr:=DboxHead[purcost_achannel,purcost_track]->nnext;
             if(purcost_headptr!=NULL) then 
             {
                 DboxHead[purcost_achannel,purcost_track]->nnext:=purcost_denptr;
                 purcost_denptr->nnext:=purcost_headptr;
                 purcost_headptr->nback:=purcost_denptr;
                 purcost_denptr->nback:=DboxHead[purcost_achannel,purcost_track]
                 
             }
             else
             {
                 DboxHead[purcost_achannel,purcost_track]->nnext:=purcost_denptr;
                 purcost_denptr->nnext:=NULL;
                 purcost_denptr->nback:=DboxHead[purcost_achannel,purcost_track]
             };
             purcost_ptr:=purcost_ptr->nnextgrd
             
         };
         if(purcost_aoutside=0) then 
         {
             (nmaxTrack[purcost_achannel]):=(nmaxTrack[purcost_achannel])-1
             
         }
         else 
         {
              skip 
         };
         purcost_ptr:=purcost_sbptr;
         
         while(purcost_ptr!=purcost_ebptr)
         {
             purcost_denptr:=purcost_ptr->dptr;
             if(purcost_denptr->nnext!=NULL) then 
             {
                 purcost_denptr->nnext->nback:=purcost_denptr->nback
                 
             }
             else 
             {
                  skip 
             };
             purcost_denptr->nback->nnext:=purcost_denptr->nnext;
             purcost_track:=((purcost_ptr->ntracks)+1);
             (purcost_ptr->ntracks):=(purcost_ptr->ntracks)+1;
             purcost_headptr:=DboxHead[purcost_bchannel,purcost_track]->nnext;
             if(purcost_headptr!=NULL) then 
             {
                 DboxHead[purcost_bchannel,purcost_track]->nnext:=purcost_denptr;
                 purcost_denptr->nnext:=purcost_headptr;
                 purcost_headptr->nback:=purcost_denptr;
                 purcost_denptr->nback:=DboxHead[purcost_bchannel,purcost_track]
                 
             }
             else
             {
                 DboxHead[purcost_bchannel,purcost_track]->nnext:=purcost_denptr;
                 purcost_denptr->nnext:=NULL;
                 purcost_denptr->nback:=DboxHead[purcost_bchannel,purcost_track]
             };
             purcost_ptr:=purcost_ptr->nnextgrd
             
         };
         if(purcost_binside=1) then 
         {
             nmaxTrack[purcost_bchannel]:=nmaxTrack[purcost_bchannel]+1
             
         }
         else 
         {
              skip 
         };
         if(aNetSeg[segment].nflag=0) then 
         {
             if(purcost_current=1) then 
             {
                 aNetSeg[segment].current:=0
             }
             else
             {
                 aNetSeg[segment].current:=1
             }
             
         }
         else
         {
             if(purcost_current=1) then 
             {
                 aNetSeg[segment].ncurrent:=0
             }
             else
             {
                 aNetSeg[segment].ncurrent:=1
             }
         };
         tracks:=tracks+purcost_penalty;
         return<==1 and RValue:=1;
         skip
     }
     else
     {
         return<==1 and RValue:=0;
         skip
     }
     )
     }; 
      int qsz and skip;
     int thresh and skip;
     int mthresh and skip;
 function qsorte ( char *base,int n,int size )
 {
     frame(qsorte_c,qsorte_i,qsorte_j,qsorte_lo,qsorte_hi,qsorte_min,qsorte_max,return) and ( 
     int return<==0 and skip;
     char qsorte_c,*qsorte_i,*qsorte_j,*qsorte_lo,*qsorte_hi and skip;
     char *qsorte_min,*qsorte_max and skip;
     if(n<=1) then 
     {
          return<==1 and skip
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         qsz:=size;
         thresh:=qsz*4;
         mthresh:=qsz*6;
         qsorte_max:=base+n*qsz;
         if(n>=4) then 
         {
             qste(base,qsorte_max,RValue);
             qsorte_hi:=base+thresh
             
         }
         else
         {
             qsorte_hi:=qsorte_max
         };
         qsorte_lo<==base and skip;
		  qsorte_j<==qsorte_lo and skip;
         
		 qsorte_lo:=qsorte_lo+qsz;
         while(qsorte_lo<qsorte_hi)
         {
             if(extern comparee(qsorte_j,qsorte_lo,RValue)>0) then 
             {
                 qsorte_j:=qsorte_lo
             }
             else 
             {
                  skip 
             };
             qsorte_lo:=qsorte_lo+qsz
             
         };

		 

         if(qsorte_j!=base) then 
         {
             qsorte_i:=base and qsorte_hi:=base+qsz;
             while(qsorte_i<qsorte_hi)
             {
                 qsorte_c:=* qsorte_j;
                 * qsorte_j:=* qsorte_i;
                 qsorte_j:=qsorte_j+1;
                 * qsorte_i:=qsorte_c;
                 qsorte_i:=qsorte_i+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         qsorte_min:=base;
         
		 qsorte_min:=qsorte_min+qsz ;
         qsorte_hi:=qsorte_min;
         while(qsorte_hi<qsorte_max)
         {
		     qsorte_hi:=qsorte_hi-qsz;
             while(extern comparee(qsorte_hi,qsorte_min,RValue)>0)
             {
			   qsorte_hi:=qsorte_hi-qsz
             };
			 qsorte_hi:=qsorte_hi+qsz;
             if((qsorte_hi)!=qsorte_min) then 
             {
                 qsorte_lo:=qsorte_min+qsz;
                 qsorte_lo:=qsorte_lo-1;
                 while(qsorte_lo>=qsorte_min)
                 {
                     qsorte_c:=* qsorte_lo;
                     qsorte_j<==qsorte_lo and qsorte_i<==qsorte_j and skip;
                     
					 qsorte_j:=qsorte_j-qsz;
                     while(qsorte_j>=qsorte_hi)
                     {
                         * qsorte_i:=* qsorte_j;
                         qsorte_i:=qsorte_j;
						 qsorte_j:=qsorte_j-qsz
                         
                     };
                     * qsorte_i:=qsorte_c;
                     qsorte_lo:=qsorte_lo-1
                 }
                 
             }
             else 
             {
                  skip 
             };
            qsorte_min:=qsorte_min+qsz ;
            qsorte_hi:=qsorte_min
         }
     }
     else
     {
         skip
     }
     )
     }; 
  function qste ( char *base,char *max,int RValue )
 {
     frame(qste_c,qste_i,qste_j,qste_jj,qste_ii,qste_mid,qste_tmp,qste_lo,qste_hi,qste_goto_swap,count$,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     char qste_c,*qste_i,*qste_j,*qste_jj and skip;
     int qste_ii and skip;
     char *qste_mid,*qste_tmp and skip;
     int qste_lo,qste_hi and skip;
     int qste_goto_swap<==0 and skip;
     qste_lo:=max-base;
     count$<==0 and skip;
     while( count$=0 OR qste_lo>=thresh)
     {
         count$:=count$+1;
         qste_i<==base+qsz*((qste_lo/ qsz)>>1) and qste_mid<==qste_i and skip;
         if(qste_lo>=mthresh) then 
         {
             qste_jj:=base ;
             qste_j:=(( if(extern comparee((qste_jj),qste_i,RValue)>0) then qste_jj else qste_i));
             qste_tmp:=max-qsz ;
             if(extern comparee(qste_j,(qste_tmp),RValue)>0) then 
             {
                 qste_j:=(( if(qste_j=qste_jj) then qste_i else qste_jj));
                 if(extern comparee(qste_j,qste_tmp,RValue)<0) then 
                 {
                     qste_j:=qste_tmp
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(qste_j!=qste_i) then 
             {
                 qste_ii:=qsz;
                 int count$<==0 and skip;
                 while( count$=0 OR (qste_ii-1))
                 {
                     count$:=count$+1;
                     qste_ii:=qste_ii-1;
                     qste_c:=* qste_i;
                     * qste_i:=* qste_j;
                     qste_i:=qste_i+1;
                     * qste_j:=qste_c;
                     qste_j:=qste_j+1
                 };
                 qste_ii:=qste_ii-1
             }
             else 
             {
                  skip 
             }
             
         }
         else 
         {
              skip 
         };
         break$<==0 and skip;
         qste_i:=base ; qste_j:=max-qsz;
         while( break$=0 AND  true)
         {
             qste_goto_swap:=0;
             while(qste_i<qste_mid AND extern comparee(qste_i,qste_mid,RValue)<=0)
             {
                 qste_i:=qste_i+qsz
             };
             while(break$=0 AND qste_j>qste_mid)
             {
                 continue<==0 and skip;
                 if(extern comparee(qste_mid,qste_j,RValue)<=0) then 
                 {
                     qste_j:=qste_j-qsz;
                     continue<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     qste_tmp:=qste_i+qsz;
                     if(qste_i=qste_mid) then 
                     {
                         qste_jj<==qste_j and qste_mid<==qste_jj and skip
                         
                     }
                     else
                     {
                         qste_jj:=qste_j;
                         qste_j:=qste_j-qsz
                     };
                     qste_goto_swap:=1;
                     break$<==1 and skip
                  }
                 else
                 {
                     skip
                 }
             };
			 break$<==0 and skip;
             continue<==0 and skip;
             if(!qste_goto_swap) then 
             {
                 if(qste_i=qste_mid) then 
                 {
                     break$<==1 and skip
                  }
                 else
                 {
                     qste_jj:=qste_mid;
                     qste_mid<==qste_i and qste_tmp<==qste_mid and skip;
                     qste_j:=qste_j-qsz
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then 
             {
                 qste_ii:=qsz;
                 count$<==0 and skip;
                 while( ( count$=0 OR (qste_ii-1)))
                 {
                     count$:=count$+1;
                     qste_ii:=qste_ii-1;
                     qste_c:=* qste_i;
                     * qste_i:=* qste_jj;
                     qste_i:=qste_i+1;
                     * qste_jj:=qste_c;
                     qste_jj:=qste_jj+1
                 };
				 qste_ii:=qste_ii-1;
                 qste_i:=qste_tmp
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
		 qste_j:=qste_mid;
         qste_i:=qste_j+qsz;
         qste_hi:=max-qste_i ;
         qste_lo:=qste_j-base ;
         if((qste_lo)<=(qste_hi)) then 
         {
             if(qste_lo>=thresh) then 
             {
                 qste(base,qste_j,RValue)
             }
             else 
             {
                  skip 
             };
             base:=qste_i;
             qste_lo:=qste_hi
         }
         else
         {
             if(qste_hi>=thresh) then 
             {
                 qste(qste_i,max,RValue)
             }
             else 
             {
                  skip 
             };
             max:=qste_j
         }
     }
     )
     }; 
  function comparee ( edgeBox* a,edgeBox* b,int RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
     return<==1 and RValue:=(a->cost-b->cost);
     skip
     )
     }; 


 function qsortg ( char *base,int n,int size )
 {
     frame(qsortg_c,qsortg_i,qsortg_j,qsortg_lo,qsortg_hi,qsortg_min,qsortg_max,return) and ( 
     int return<==0 and skip;
     char qsortg_c,*qsortg_i,*qsortg_j,*qsortg_lo,*qsortg_hi and skip;
     char *qsortg_min,*qsortg_max and skip;
     if(n<=1) then 
     {
          return<==1 and skip
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         qsz:=size;
         thresh:=qsz*4;
         mthresh:=qsz*6;
         qsortg_max:=base+n*qsz;
         if(n>=4) then 
         {
             qstg(base,qsortg_max,RValue);
             qsortg_hi:=base+thresh
             
         }
         else
         {
             qsortg_hi:=qsortg_max
         };
         qsortg_lo<==base and skip;
		 qsortg_j<==qsortg_lo and skip;
         
		 qsortg_lo:=qsortg_lo+qsz;
         while(qsortg_lo<qsortg_hi)
         {
             if(extern compareg(qsortg_j,qsortg_lo,RValue)>0) then 
             {
                 qsortg_j:=qsortg_lo
             }
             else 
             {
                  skip 
             };
              qsortg_lo:=qsortg_lo+qsz
             
         };

		 
         
		 
		 if(qsortg_j!=base) then 
         {
             qsortg_i:=base;
			 qsortg_hi:=base+qsz;
             while(qsortg_i<qsortg_hi)
             {
                 qsortg_c:=* qsortg_j;
                 * qsortg_j:=* qsortg_i;
                 qsortg_j:=qsortg_j+1;
                 * qsortg_i:=qsortg_c;
                 qsortg_i:=qsortg_i+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         qsortg_min:=base;
         
		 qsortg_min:=qsortg_min+qsz ;
          qsortg_hi:=qsortg_min;
         while(qsortg_hi<qsortg_max)
         {
		     qsortg_hi:=qsortg_hi-qsz;
             while(extern compareg(qsortg_hi,qsortg_min,RValue)>0)
             {
			   qsortg_hi:=qsortg_hi-qsz
             };

			 

			 qsortg_hi:=qsortg_hi+qsz;
             if(qsortg_hi!=qsortg_min) then 
             {
                 qsortg_lo:=qsortg_min+qsz;
                 qsortg_lo:=qsortg_lo-1;
                 while(qsortg_lo>=qsortg_min)
                 {
                     qsortg_c:=* qsortg_lo;
                     qsortg_j<==qsortg_lo and skip;
					 qsortg_i<==qsortg_j and skip;
                     
					 qsortg_j:=qsortg_j-qsz;
                     while(qsortg_j>=qsortg_hi)
                     {
                         * qsortg_i:=* qsortg_j;
                         qsortg_i:=qsortg_j;
                         qsortg_j:=qsortg_j-qsz
                     };
                     * qsortg_i:=qsortg_c;
                     qsortg_lo:=qsortg_lo-1
                 }
                 
             }
             else 
             {
                  skip 
             };
            qsortg_min:=qsortg_min+qsz ;
            qsortg_hi:=qsortg_min
         }
     }
     else
     {
         skip
     }
     )
     }; 
  function qstg ( char *base,char *max,int RValue )
 {
     frame(qstg_c,qstg_i,qstg_j,qstg_jj,qstg_ii,qstg_mid,qstg_tmp,qstg_lo,qstg_hi,qstg_goto_swap,count$,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     char qstg_c,*qstg_i,*qstg_j,*qstg_jj and skip;
     int qstg_ii and skip;
     char *qstg_mid,*qstg_tmp and skip;
     int qstg_lo,qstg_hi and skip;
     int qstg_goto_swap<==0 and skip;
     qstg_lo:=max-base;
     count$<==0 and skip;
     while( count$=0 OR qstg_lo>=thresh)
     {
         count$:=count$+1;
         qstg_i<==base+qsz*((qstg_lo/ qsz)>>1) and qstg_mid<==qstg_i and skip;
         if(qstg_lo>=mthresh) then 
         {
             qstg_jj:=base ;
             qstg_j:=(( if(extern compareg((qstg_jj),qstg_i,RValue)>0) then qstg_jj else qstg_i));
             qstg_tmp:=max-qsz ;
             if(extern compareg(qstg_j,(qstg_tmp),RValue)>0) then 
             {
                 qstg_j:=(( if(qstg_j=qstg_jj) then qstg_i else qstg_jj));
                 if(extern compareg(qstg_j,qstg_tmp,RValue)<0) then 
                 {
                     qstg_j:=qstg_tmp
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(qstg_j!=qstg_i) then 
             {
                 qstg_ii:=qsz;
                 int count$<==0 and skip;
                 while( count$=0 OR (qstg_ii-1))
                 {
                     count$:=count$+1;
                     qstg_ii:=qstg_ii-1;
                     qstg_c:=* qstg_i;
                     * qstg_i:=* qstg_j;
                     qstg_i:=qstg_i+1;
                     * qstg_j:=qstg_c;
                     qstg_j:=qstg_j+1
                 };
                 qstg_ii:=qstg_ii-1
             }
             else 
             {
                  skip 
             }
             
         }
         else 
         {
              skip 
         };
         break$<==0 and skip;
         qstg_i:=base and qstg_j:=max-qsz;
         while( break$=0 AND  true)
         {
             qstg_goto_swap:=0;
             while(qstg_i<qstg_mid AND extern compareg(qstg_i,qstg_mid,RValue)<=0)
             {
                 qstg_i:=qstg_i+qsz
             };
             while(break$=0 AND qstg_j>qstg_mid)
             {
                 continue<==0 and skip;
                 if(extern compareg(qstg_mid,qstg_j,RValue)<=0) then 
                 {
                     qstg_j:=qstg_j-qsz;
                     continue<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     qstg_tmp:=qstg_i+qsz;
                     if(qstg_i=qstg_mid) then 
                     {
                         qstg_jj<==qstg_j and qstg_mid<==qstg_jj and skip
                         
                     }
                     else
                     {
                         qstg_jj:=qstg_j;
                         qstg_j:=qstg_j-qsz
                     };
                     qstg_goto_swap:=1;
                     break$<==1 and skip
                  }
                 else
                 {
                     skip
                 }
             };
			 break$<==0 and skip;
             continue<==0 and skip;
             if(!qstg_goto_swap) then 
             {
                 if(qstg_i=qstg_mid) then 
                 {
                     break$<==1 and skip
                  }
                 else
                 {
                     qstg_jj:=qstg_mid;
                     qstg_mid<==qstg_i and qstg_tmp<==qstg_mid and skip;
                     qstg_j:=qstg_j-qsz
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then 
             {
                 qstg_ii:=qsz;
                 count$<==0 and skip;
                 while( ( count$=0 OR (qstg_ii-1)))
                 {
                     count$:=count$+1;
                     qstg_ii:=qstg_ii-1;
                     qstg_c:=* qstg_i;
                     * qstg_i:=* qstg_jj;
                     qstg_i:=qstg_i+1;
                     * qstg_jj:=qstg_c;
                     qstg_jj:=qstg_jj+1
                 };
				 qstg_ii:=qstg_ii-1;
                 qstg_i:=qstg_tmp
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
		 qstg_j:=qstg_mid;
         qstg_i:=qstg_j+qsz;
         qstg_hi:=max-qstg_i ;
         qstg_lo:=qstg_j-base ;
         if((qstg_lo)<=(qstg_hi)) then 
         {
             if(qstg_lo>=thresh) then 
             {
                 qstg(base,qstg_j,RValue)
             }
             else 
             {
                  skip 
             };
             base:=qstg_i;
             qstg_lo:=qstg_hi
         }
         else
         {
             if(qstg_hi>=thresh) then 
             {
                 qstg(qstg_i,max,RValue)
             }
             else 
             {
                  skip 
             };
             max:=qstg_j
         }
     }
     )
     }; 
  function compareg ( csGroup *a,csGroup *b,int RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
     return<==1 and RValue:=(a->aveX-b->aveX);
     skip
     )
     }; 
  function qsortgdx ( char *base,int n,int size )
 {
     frame(qsortgdx_c,qsortgdx_i,qsortgdx_j,qsortgdx_lo,qsortgdx_hi,qsortgdx_min,qsortgdx_max,return) and ( 
     int return<==0 and skip;
     char qsortgdx_c,*qsortgdx_i,*qsortgdx_j,*qsortgdx_lo,*qsortgdx_hi and skip;
     char *qsortgdx_min,*qsortgdx_max and skip;
     if(n<=1) then 
     {
          return<==1 and skip
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         qsz:=size;
         thresh:=qsz*4;
         mthresh:=qsz*6;
         qsortgdx_max:=base+n*qsz;
         if(n>=4) then 
         {
             qstgdx(base,qsortgdx_max,RValue);
             qsortgdx_hi:=base+thresh
             
         }
         else
         {
             qsortgdx_hi:=qsortgdx_max
         };
         qsortgdx_lo<==base and skip;
		  qsortgdx_j<==qsortgdx_lo and skip;
         
		 qsortgdx_lo:=qsortgdx_lo+qsz;
         while(qsortgdx_lo<qsortgdx_hi)
         {
             if(extern comparegdx(qsortgdx_j,qsortgdx_lo,RValue)>0) then 
             {
                 qsortgdx_j:=qsortgdx_lo
             }
             else 
             {
                  skip 
             };
             qsortgdx_lo:=qsortgdx_lo+qsz
             
         };

		 

         if(qsortgdx_j!=base) then 
         {
             qsortgdx_i:=base and qsortgdx_hi:=base+qsz;
             while(qsortgdx_i<qsortgdx_hi)
             {
                 qsortgdx_c:=* qsortgdx_j;
                 * qsortgdx_j:=* qsortgdx_i;
                 qsortgdx_j:=qsortgdx_j+1;
                 * qsortgdx_i:=qsortgdx_c;
                 qsortgdx_i:=qsortgdx_i+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         qsortgdx_min:=base;
         
		 qsortgdx_min:=qsortgdx_min+qsz ;
          qsortgdx_hi:=qsortgdx_min;
         while(qsortgdx_hi<qsortgdx_max)
         {
		     qsortgdx_hi:=qsortgdx_hi-qsz;
             while(extern comparegdx(qsortgdx_hi,qsortgdx_min,RValue)>0)
             {
			    qsortgdx_hi:=qsortgdx_hi-qsz
             };
			 qsortgdx_hi:=qsortgdx_hi+qsz;
             if(qsortgdx_hi!=qsortgdx_min) then 
             {
                 qsortgdx_lo:=qsortgdx_min+qsz;
                 qsortgdx_lo:=qsortgdx_lo-1;
                 while(qsortgdx_lo>=qsortgdx_min)
                 {
                     qsortgdx_c:=* qsortgdx_lo;
                     qsortgdx_j<==qsortgdx_lo and qsortgdx_i<==qsortgdx_j and skip;
                     
					 qsortgdx_j:=qsortgdx_j-qsz;
                     while(qsortgdx_j>=qsortgdx_hi)
                     {
                         * qsortgdx_i:=* qsortgdx_j;
                         qsortgdx_i:=qsortgdx_j;
                         qsortgdx_j:=qsortgdx_j-qsz
                     };
                     * qsortgdx_i:=qsortgdx_c;
                     qsortgdx_lo:=qsortgdx_lo-1
                 }
                 
             }
             else 
             {
                  skip 
             };
            qsortgdx_min:=qsortgdx_min+qsz ;
          qsortgdx_hi:=qsortgdx_min 
         }

		 
     }
     else
     {
         skip
     }
     )
     }; 
  function qstgdx ( char *base,char *max,int RValue )
 {
     frame(qstgdx_c,qstgdx_i,qstgdx_j,qstgdx_jj,qstgdx_ii,qstgdx_mid,qstgdx_tmp,qstgdx_lo,qstgdx_hi,qstgdx_goto_swap,count$,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     char qstgdx_c,*qstgdx_i,*qstgdx_j,*qstgdx_jj and skip;
     int qstgdx_ii and skip;
     char *qstgdx_mid,*qstgdx_tmp and skip;
     int qstgdx_lo,qstgdx_hi and skip;
     int qstgdx_goto_swap<==0 and skip;
     qstgdx_lo:=max-base;
     count$<==0 and skip;
     while( count$=0 OR qstgdx_lo>=thresh)
     {
         count$:=count$+1;
         qstgdx_i<==base+qsz*((qstgdx_lo/ qsz)>>1) and qstgdx_mid<==qstgdx_i and skip;
         if(qstgdx_lo>=mthresh) then 
         {
             qstgdx_jj:=base ;
             qstgdx_j:=(( if(extern comparegdx((qstgdx_jj),qstgdx_i,RValue)>0) then qstgdx_jj else qstgdx_i));
             qstgdx_tmp:=max-qsz ;
             if(extern comparegdx(qstgdx_j,(qstgdx_tmp),RValue)>0) then 
             {
                 qstgdx_j:=(( if(qstgdx_j=qstgdx_jj) then qstgdx_i else qstgdx_jj));
                 if(extern comparegdx(qstgdx_j,qstgdx_tmp,RValue)<0) then 
                 {
                     qstgdx_j:=qstgdx_tmp
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(qstgdx_j!=qstgdx_i) then 
             {
                 qstgdx_ii:=qsz;
                 int count$<==0 and skip;
                 while( count$=0 OR (qstgdx_ii-1))
                 {
                     count$:=count$+1;
                     qstgdx_ii:=qstgdx_ii-1;
                     qstgdx_c:=* qstgdx_i;
                     * qstgdx_i:=* qstgdx_j;
                     qstgdx_i:=qstgdx_i+1;
                     * qstgdx_j:=qstgdx_c;
                     qstgdx_j:=qstgdx_j+1
                 };
                 qstgdx_ii:=qstgdx_ii-1
             }
             else 
             {
                  skip 
             }
             
         }
         else 
         {
              skip 
         };
         break$<==0 and skip;
         qstgdx_i:=base and qstgdx_j:=max-qsz;
         while( break$=0 AND  true)
         {
             qstgdx_goto_swap:=0;
             while(qstgdx_i<qstgdx_mid AND extern comparegdx(qstgdx_i,qstgdx_mid,RValue)<=0)
             {
                 qstgdx_i:=qstgdx_i+qsz
             };
             while(break$=0 AND qstgdx_j>qstgdx_mid)
             {
                 continue<==0 and skip;
                 if(extern comparegdx(qstgdx_mid,qstgdx_j,RValue)<=0) then 
                 {
                     qstgdx_j:=qstgdx_j-qsz;
                     continue<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     qstgdx_tmp:=qstgdx_i+qsz;
                     if(qstgdx_i=qstgdx_mid) then 
                     {
                         qstgdx_jj<==qstgdx_j and qstgdx_mid<==qstgdx_jj and skip
                         
                     }
                     else
                     {
                         qstgdx_jj:=qstgdx_j;
                         qstgdx_j:=qstgdx_j-qsz
                     };
                     qstgdx_goto_swap:=1;
                     break$<==1 and skip
                  }
                 else
                 {
                     skip
                 }
             };
			 break$<==0 and skip;
             continue<==0 and skip;
             if(!qstgdx_goto_swap) then 
             {
                 if(qstgdx_i=qstgdx_mid) then 
                 {
                     break$<==1 and skip
                  }
                 else
                 {
                     qstgdx_jj:=qstgdx_mid;
                     qstgdx_mid<==qstgdx_i and qstgdx_tmp<==qstgdx_mid and skip;
                     qstgdx_j:=qstgdx_j-qsz
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then 
             {
                 qstgdx_ii:=qsz;
                 count$<==0 and skip;
                 while( ( count$=0 OR (qstgdx_ii-1)))
                 {
                     count$:=count$+1;
                     qstgdx_ii:=qstgdx_ii-1;
                     qstgdx_c:=* qstgdx_i;
                     * qstgdx_i:=* qstgdx_jj;
                     qstgdx_i:=qstgdx_i+1;
                     * qstgdx_jj:=qstgdx_c;
                     qstgdx_jj:=qstgdx_jj+1
                 };
				 qstgdx_ii:=qstgdx_ii-1;
                 qstgdx_i:=qstgdx_tmp
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
		 qstgdx_j:=qstgdx_mid;
         qstgdx_i:=qstgdx_j+qsz;
         qstgdx_hi:=max-qstgdx_i ;
         qstgdx_lo:=qstgdx_j-base ;
         if((qstgdx_lo)<=(qstgdx_hi)) then 
         {
             if(qstgdx_lo>=thresh) then 
             {
                 qstgdx(base,qstgdx_j,RValue)
             }
             else 
             {
                  skip 
             };
             base:=qstgdx_i;
             qstgdx_lo:=qstgdx_hi
         }
         else
         {
             if(qstgdx_hi>=thresh) then 
             {
                 qstgdx(qstgdx_i,max,RValue)
             }
             else 
             {
                  skip 
             };
             max:=qstgdx_j
         }
     }
     )
     }; 
  function comparegdx ( changrdbox* *a,changrdbox* *b,int RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
     return<==1 and RValue:=((* a)->netptr->xpos-(* b)->netptr->xpos);
     skip
     )
     }; 
  function qsortx ( char *base,int n,int size )
 {
     frame(qsortx_c,qsortx_i,qsortx_j,qsortx_lo,qsortx_hi,qsortx_min,qsortx_max,return) and ( 
     int return<==0 and skip;
     char qsortx_c,*qsortx_i,*qsortx_j,*qsortx_lo,*qsortx_hi and skip;
     char *qsortx_min,*qsortx_max and skip;

     if(n<=1) then 
     {
          return<==1 and skip
     }
     else 
     {
          skip 
     };

     if(return=0)   then 
     {
         qsz:=size;
         thresh:=qsz*4;
         mthresh:=qsz*6;
         qsortx_max:=base+n*qsz;

         if(n>=4) then 
         {
             qst(base,qsortx_max,RValue);

             qsortx_hi:=base+thresh
             
         }
         else
         {
             qsortx_hi:=qsortx_max
         };
         qsortx_lo<==base and skip;
		 qsortx_j<==qsortx_lo and skip;
         
		 qsortx_lo:=qsortx_lo+qsz;
         while(qsortx_lo<qsortx_hi)
         {
             if(extern comparex(qsortx_j,qsortx_lo,RValue)>0) then 
             {
                 qsortx_j:=qsortx_lo
             }
             else 
             {
                  skip 
             };
             qsortx_lo:=qsortx_lo+qsz
             
         };
		

         if(qsortx_j!=base) then 
         {
             qsortx_i:=base and skip;
			  qsortx_hi:=base+qsz;
             while(qsortx_i<qsortx_hi)
             {
                 qsortx_c:=* qsortx_j;
                 * qsortx_j:=* qsortx_i;
                 qsortx_j:=qsortx_j+1;
                 * qsortx_i:=qsortx_c;
                 qsortx_i:=qsortx_i+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         qsortx_min:=base;
         
		 qsortx_min:=qsortx_min+qsz ;
          qsortx_hi:=qsortx_min;

         while(qsortx_hi<qsortx_max)
         {
		     qsortx_hi:=qsortx_hi-qsz;	 
             while(extern comparex(qsortx_hi, qsortx_min,RValue)>0)
             {
			     qsortx_hi:=qsortx_hi-qsz
             };
			  		  
			 qsortx_hi:=qsortx_hi+qsz;
             if(qsortx_hi!=qsortx_min) then 
             {
                 qsortx_lo:=qsortx_min+qsz;
                 qsortx_lo:= qsortx_lo-1;
                 while(qsortx_lo>=qsortx_min)
                 {
                     qsortx_c:=* qsortx_lo;
                     qsortx_j<==qsortx_lo and skip;
					 qsortx_i<==qsortx_j and skip;
                     qsortx_j:=qsortx_j-qsz;
                     while(qsortx_j>=qsortx_hi)
                     {
                         * qsortx_i:=* qsortx_j;
                         qsortx_i:=qsortx_j;
                          qsortx_j:=qsortx_j-qsz
                     };
                     * qsortx_i:=qsortx_c;
                     qsortx_lo:= qsortx_lo-1
                 }
                 
             }
             else 
             {
                  skip 
             };
           qsortx_min:=qsortx_min+qsz ;
          qsortx_hi:=qsortx_min
         }

		 
     }
     else
     {
         skip
     }
     )
     }; 
  function qst ( char *base,char *max,int RValue )
 {
     frame(count$$,count$$$,qst_c,qst_i,qst_j,qst_jj,qst_ii,qst_mid,qst_tmp,qst_lo,qst_hi,qst_goto_swap,count$,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     char qst_c,*qst_i,*qst_j,*qst_jj and skip;
     int qst_ii and skip;
     char *qst_mid,*qst_tmp and skip;
     int qst_lo,qst_hi and skip;
     int qst_goto_swap<==0 and skip;
     int count$<==0 and skip;
	 int count$$<==0 and skip;
	  int count$$$<==0 and skip;
	 qst_lo:=max-base;

     while( count$=0 OR qst_lo>=thresh)
     {
         count$:=count$+1;
         qst_i<==base+qsz*((qst_lo/ qsz)>>1) and skip;
		  qst_mid<==qst_i and skip;
         if(qst_lo>=mthresh) then 
         {
             qst_jj:=base ;
             qst_j:=(( if(extern comparex((qst_jj),qst_i,RValue)>0) then qst_jj else qst_i));
             qst_tmp:=max-qsz ;
             if(extern comparex(qst_j,(qst_tmp),RValue)>0) then 
             {
                 qst_j:=(( if(qst_j=qst_jj) then qst_i else qst_jj));
                 if(extern comparex(qst_j,qst_tmp,RValue)<0) then 
                 {
                     qst_j:=qst_tmp
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(qst_j!=qst_i) then 
             {
                 qst_ii:=qsz;

                 while( count$$=0 OR (qst_ii-1))
                 {
                     count$$:=count$$+1;
                     qst_ii:=qst_ii-1;
                     qst_c:=* qst_i;
                     * qst_i:=* qst_j;
                     qst_i:=qst_i+1;
                     * qst_j:=qst_c;
                     qst_j:=qst_j+1
                 };
                 qst_ii:=qst_ii-1
             }
             else 
             {
                  skip 
             }
             
         }
         else 
         {
              skip 
         };
         break$<==0 and skip;
         qst_i:=base ; qst_j:=max-qsz;
         while( break$=0 AND  true)
         {
             qst_goto_swap:=0;
             while(qst_i<qst_mid AND extern comparex(qst_i,qst_mid,RValue)<=0)
             {
                 qst_i:=qst_i+qsz
             };
             while(break$=0 AND qst_j>qst_mid)
             {
                 continue<==0 and skip;
                 if(extern comparex(qst_mid,qst_j,RValue)<=0) then 
                 {
                     qst_j:=qst_j-qsz;
                     continue<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     qst_tmp:=qst_i+qsz;
                     if(qst_i=qst_mid) then 
                     {
                         qst_jj<==qst_j and skip;
						 qst_mid<==qst_jj and skip
                         
                     }
                     else
                     {
                         qst_jj:=qst_j;
                         qst_j:=qst_j-qsz
                     };
                     qst_goto_swap:=1;
                     break$<==1 and skip
                  }
                 else
                 {
                     skip
                 }
             };
             continue<==0 and skip;
			 break$<==0 and skip;
             if(!qst_goto_swap) then 
             {
                 if(qst_i=qst_mid) then 
                 {
                     break$<==1 and skip
                  }
                 else
                 {
                     qst_jj:=qst_mid;
                     qst_mid<==qst_i and skip;
					 qst_tmp<==qst_mid and skip;
                     qst_j:=qst_j-qsz
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then 
             {
                 qst_ii:=qsz;

                 while( ( count$$$=0 OR (qst_ii-1)))
                 {
                     count$$$:=count$$$+1;
                     qst_ii:=qst_ii-1;
                     qst_c:=* qst_i;
                     * qst_i:=* qst_jj;
                     qst_i:=qst_i+1;
                     * qst_jj:=qst_c;
                     qst_jj:=qst_jj+1
                 };
				  qst_ii:=qst_ii-1;
                 qst_i:=qst_tmp
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
		 qst_j:=qst_mid;
         qst_i:=qst_j+qsz;
         qst_hi:=max-qst_i ;
         qst_lo:=qst_j-base ;
         if((qst_lo)<=(qst_hi)) then 
         {
             if(qst_lo>=thresh) then 
             {
                 qst(base,qst_j,RValue)
             }
             else 
             {
                  skip 
             };
             base:=qst_i;
             qst_lo:=qst_hi
         }
         else
         {
             if(qst_hi>=thresh) then 
             {
                 qst(qst_i,max,RValue)
             }
             else 
             {
                  skip 
             };
             max:=qst_j
         }
     }
     )
     }; 
      char SccsId[39]<==",(#) rand.c (Yale) version 3.1 3/21/90" and skip;
     int randVarS and skip;
 function Yacm_random ( int RValue )
 {
     frame(Yacm_random_k_rand,return) and ( 
     int return<==0 and skip;
     int Yacm_random_k_rand and skip;
	 YRcount := YRcount +1;
     Yacm_random_k_rand:=randVarS/ 127773;
     randVarS:=16807*(randVarS-Yacm_random_k_rand*127773)-(Yacm_random_k_rand*2836);
     if(randVarS<0) then 
     {
         randVarS:=randVarS+2147483647
         
     }
     else 
     {
          skip 
     };
     return<==1 and RValue:=randVarS;
     skip
     )
     }; 
  function Yset_random_seed ( int seed )
 {
     seed:=ABS(seed,RValue);
     if(seed=0) then 
     {
         seed:=seed+1
         
     }
     else 
     {
          skip 
     };
     randVarS:=seed
     
 };
 int *nofeed and skip;
 float *relativeLen and skip;
 function readblck ( FILE *fp,int RValue )
 {
     frame(readblck_test,readblck_block,readblck_class$,readblck_height,readblck_row,readblck_relLen,readblck_input$,return) and ( 
     int return<==0 and skip;
     int readblck_test,readblck_block,readblck_class$,readblck_height,readblck_row and skip;
     float readblck_relLen and skip;
     char readblck_input$[32] and skip;
     readblck_block:=0;
     while(fscanf(fp," %s ",readblck_input$)=1)
     {
         if(strcmp(readblck_input$,"block")=0) then 
         {
             readblck_block:=readblck_block+1;
             fscanf(fp," %s ",readblck_input$) and skip;
             if(strcmp(readblck_input$,"height")=0) then 
             {
                 readblck_test:=fscanf(fp," %d ",&readblck_height);
                 if(readblck_test!=1) then 
                 {
                     fprintf(fpo,"Failed to input height of a block\n") and skip;
                     fprintf(fpo,"at position height\n") and skip;
                     exit(0) and skip 
                     
                 }
                 else 
                 {
                      skip 
                 }
                 
             }
             else
             {
                 fprintf(fpo,"unexpected keyword in the .blk file\n") and skip;
                 fprintf(fpo,"at position height\n") and skip;
                 fprintf(fpo,"current block: %d\n",readblck_block) and skip;
                 exit(0) and skip 
             };
             fscanf(fp," %s ",readblck_input$) and skip;
             if(strcmp(readblck_input$,"class")=0) then 
             {
                 readblck_test:=fscanf(fp," %d ",&readblck_class$);
                 if(readblck_test!=1) then 
                 {
                     fprintf(fpo,"Failed to input class of a block\n") and skip;
                     fprintf(fpo,"current block: %d\n",readblck_block) and skip;
                     exit(0) and skip 
                     
                 }
                 else 
                 {
                      skip 
                 }
             }
             else
             {
                 fprintf(fpo,"unexpected keyword in the .blk file\n") and skip;
                 fprintf(fpo,"at position class\n") and skip;
                 fprintf(fpo,"current block: %d\n",readblck_block) and skip;
                 exit(0) and skip 
             }
         }
         else
         {
             if(strcmp(readblck_input$,"mirror")=0) then 
             {
			   skip
             }
             else
             {
                 if(strcmp(readblck_input$,"nofeeds")=0) then 
                 {
				   skip
                 }
                 else
                 {
                     if(strcmp(readblck_input$,"relative_length")=0) then 
                     {
                         readblck_test:=fscanf(fp," %f ",&readblck_relLen)
                     }
                     else
                     {
                         fprintf(fpo,"unexpected keyword in the .blk file\n") and skip;
                         fprintf(fpo,"current block: %d\n",readblck_block) and skip;
                         exit(0) and skip 
                     }
                 }
             }
         }
     };
     numblock:=readblck_block;
     rewind(fp) and skip;
     barray:=(blockbox* *)safe_malloc((numblock+1)*sizeof(blockbox*),RValue);
     nofeed:=(int *)safe_malloc((numblock+2)*sizeof(int),RValue);
     readblck_row:=0;
     
     while(readblck_row<=numblock+1)
     {
         nofeed[readblck_row]:=0;
         readblck_row:=readblck_row+1
         
     };
     relativeLen:=(float *)safe_malloc((numblock+1)*sizeof(float),RValue);
     readblck_block:=1;
     
     while(readblck_block<=numblock)
     {
         relativeLen[readblck_block]:=1.0;
         readblck_block:=readblck_block+1
         
     };
     readblck_block:=1;
     
     while(readblck_block<=numblock)
     {
         barray[readblck_block]:=(blockbox*)safe_malloc(sizeof(blockbox),RValue);
         barray[readblck_block]->bxcenter:=0;
         barray[readblck_block]->bycenter:=0;
         barray[readblck_block]->bleft:=0;
         barray[readblck_block]->bright:=0;
         barray[readblck_block]->bbottom:=0;
         barray[readblck_block]->btop:=0;
         barray[readblck_block]->bheight:=0;
         barray[readblck_block]->blength:=0;
         barray[readblck_block]->bclass:=0;
         barray[readblck_block]->borient:=0;
         barray[readblck_block]->desire:=0;
         barray[readblck_block]->oldsize:=0;
         barray[readblck_block]->newsize:=0;
         readblck_block:=readblck_block+1
         
     };
     readblck_block:=0;
     while(fscanf(fp," %s ",readblck_input$)=1)
     {
         if(strcmp(readblck_input$,"block")=0) then 
         {
             readblck_block:=readblck_block+1;
             fscanf(fp," %s ",readblck_input$) and skip;
             fscanf(fp," %d ",&readblck_height) and skip;
             barray[readblck_block]->btop:=readblck_height-readblck_height/ 2;
             barray[readblck_block]->bbottom:=-readblck_height/ 2;
             barray[readblck_block]->bheight:=readblck_height;
             fscanf(fp," %s ",readblck_input$) and skip;
             fscanf(fp," %d ",&readblck_class$) and skip;
             barray[readblck_block]->bclass:=readblck_class$;
             barray[readblck_block]->borient:=1
         }
         else
         {
             if(strcmp(readblck_input$,"mirror")=0) then 
             {
                 barray[readblck_block]->borient:=2
             }
             else
             {
                 if(strcmp(readblck_input$,"nofeeds")=0) then 
                 {
                     nofeed[readblck_block]:=1
                 }
                 else
                 {
                     if(strcmp(readblck_input$,"relative_length")=0) then 
                     {
                         fscanf(fp," %f ",&readblck_relLen) and skip;
                         relativeLen[readblck_block]:=readblck_relLen
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
             }
         }
     };
      return<==1 and skip
     )
     }; 
      int totallen and skip;
     int maxterm and skip;
 function readcell ( FILE *fp,int RValue )
 {
     frame(readcell_cell,readcell_orient,readcell_layer,readcell_block,readcell_left,readcell_right,readcell_bottom,readcell_top,readcell_xpos,readcell_ypos,readcell_from,readcell_terms,readcell_pinctr,readcell_netx,readcell_tot,readcell_totx,readcell_toty,readcell_input$,readcell_netname,readcell_space,readcell_ptr,readcell_tile,readcell_tptr,readcell_term,readcell_tmptr,readcell_netptr,readcell_saveptr,readcell_1_2_temp$_1,readcell_1_3_5_13_15_17_19_21_22_23_24_temp$_2,readcell_1_3_5_13_15_17_19_21_30_36_39_40_temp$_3,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
	 
     int readcell_cell,readcell_orient,readcell_layer and skip;
     int readcell_block,readcell_left,readcell_right,readcell_bottom,readcell_top and skip;
     int readcell_xpos,readcell_ypos,readcell_from and skip;
     int readcell_terms,readcell_pinctr,readcell_netx and skip;
     int readcell_tot,readcell_totx,readcell_toty and skip;
     char readcell_input$[1024] and skip;
     char readcell_netname[1024] and skip;
     float readcell_space and skip;
     cellbox* readcell_ptr and skip;
     tilebox* readcell_tile,*readcell_tptr and skip;
     termbox* readcell_term,*readcell_tmptr and skip;
     netbox* readcell_netptr,*readcell_saveptr and skip;
     parser(fp);
	 
     carray:=(cellbox* *)safe_malloc((1+numcells+numterms)*sizeof(cellbox*),RValue);
     readcell_cell:=1;
     
     while(readcell_cell<=numcells+numterms)
     {
         carray[readcell_cell]:=(cellbox*)safe_malloc(sizeof(cellbox),RValue) ;
		  readcell_ptr<==carray[readcell_cell] and skip;
         readcell_ptr->cxcenter:=0;
         readcell_ptr->cycenter:=0;
         readcell_ptr->cheight:=0;
         readcell_ptr->clength:=0;
         readcell_ptr->cblock:=0;
         readcell_ptr->cclass:=0;
         readcell_ptr->corient:=0;
         readcell_ptr->orflag:=1;
         readcell_ptr->numterms:=0;
         readcell_ptr->padside:=0;
         readcell_ptr->tileptr:=NULL;
         readcell_cell:=readcell_cell+1
         
     };
	
     implicit_feed_count:=0;
     readcell_cell:=0;
     readcell_terms:=0;
     readcell_pinctr:=0;
     while(fscanf(fp," %s ",readcell_input$)=1)
     {
         if(strcmp(readcell_input$,"cell")=0) then 
         {
              
			 readcell_cell:=readcell_cell+1;
             readcell_ptr:=carray[readcell_cell];
             readcell_ptr->corient:=0;
             fscanf(fp," %s ",readcell_input$) and skip;
             fscanf(fp," %s ",readcell_input$) and skip;
             int readcell_1_2_temp$_1 and skip;
             readcell_1_2_temp$_1:=strlen(readcell_input$);
             readcell_ptr->cname:=(char *)safe_malloc((readcell_1_2_temp$_1+1)*sizeof(char),RValue);
             sprintf(readcell_ptr->cname,"%s",readcell_input$,RValue) and skip
			 
         }
         else
         {
             if(strcmp(readcell_input$,"nomirror")=0) then 
             {
                 readcell_ptr->orflag:=0
             }
             else
             {
                 if(strcmp(readcell_input$,"initially")=0) then 
                 {
                     fscanf(fp," %s ",readcell_input$) and skip;
                     if(strcmp(readcell_input$,"fixed")=0) then 
                     {
                         readcell_ptr->cclass:=-1;
                         readcell_ptr->orflag:=0
                         
                     }
                     else
                     {
                         if(strcmp(readcell_input$,"nonfixed")=0) then 
                         {
                             readcell_ptr->cclass:=0
                             
                         }
                         else 
                         {
                              skip 
                         }
                     };
                     fscanf(fp," %d ",&readcell_from) and skip;
                     fscanf(fp," %s ",readcell_input$) and skip;
                     fscanf(fp," %s ",readcell_input$) and skip;
                     if(strcmp(readcell_input$,"left")=0) then 
                     {
                         readcell_ptr->cxcenter:=readcell_from;
                         readcell_ptr->cycenter:=1
                         
                     }
                     else
                     {
                         if(strcmp(readcell_input$,"right")=0) then 
                         {
                             readcell_ptr->cxcenter:=-readcell_from;
                             readcell_ptr->cycenter:=-1
                             
                         }
                         else 
                         {
                              skip 
                         }
                     };
                     fscanf(fp," %s ",readcell_input$) and skip;
                     fscanf(fp," %s ",readcell_input$) and skip;
                     fscanf(fp," %d ",&readcell_block) and skip;
                     readcell_ptr->cblock:=readcell_block
                 }
                 else
                 {
                     if(strcmp(readcell_input$,"left")=0) then 
                     {
                         readcell_ptr->tileptr:=(tilebox*)safe_malloc(sizeof(tilebox),RValue);
						 
						 readcell_tile<==readcell_ptr->tileptr and skip;
                         readcell_tile->termsptr:=NULL;
                         fscanf(fp," %d ",&readcell_left) and skip;
                         readcell_tile->left:=readcell_left
                     }
                     else
                     {
                         if(strcmp(readcell_input$,"right")=0) then 
                         {
                             fscanf(fp," %d ",&readcell_right) and skip;
                             readcell_tile->right:=readcell_right
                         }
                         else
                         {
                             if(strcmp(readcell_input$,"bottom")=0) then 
                             {
                                 fscanf(fp," %d ",&readcell_bottom) and skip;
                                 readcell_tile->bottom:=readcell_bottom
                             }
                             else
                             {
                                 if(strcmp(readcell_input$,"top")=0) then 
                                 {
                                     fscanf(fp," %d ",&readcell_top) and skip;
                                     readcell_tile->top:=readcell_top;
                                     readcell_ptr->cheight:=readcell_top-readcell_bottom;
                                     readcell_ptr->clength:=readcell_right-readcell_left
                                 }
                                 else
                                 {
                                     if(strcmp(readcell_input$,"pin")=0) then 
                                     {
                                         fscanf(fp," %s ",readcell_input$) and skip;
                                         fscanf(fp," %s ",readcell_input$) and skip;
                                         fscanf(fp," %s ",readcell_input$) and skip;
                                         fscanf(fp," %s ",readcell_input$) and skip;
                                         strcpy(readcell_netname,readcell_input$) and skip;
                                         if(strcmp(readcell_input$,"TW_PASS_THRU")!=0) then 
                                         {
                                             readcell_netx:=hashfind(readcell_input$,RValue);
                                             if(netarray[readcell_netx]->name=NULL) then 
                                             {
                                                 int readcell_1_3_5_13_15_17_19_21_22_23_24_temp$_2 and skip;
                                                 readcell_1_3_5_13_15_17_19_21_22_23_24_temp$_2:=strlen(readcell_input$);
                                                 netarray[readcell_netx]->name:=(char *)safe_malloc((readcell_1_3_5_13_15_17_19_21_22_23_24_temp$_2+1)*sizeof(char),RValue);
                                                 sprintf(netarray[readcell_netx]->name,"%s",readcell_input$,RValue) and skip
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             readcell_tot:=1;
                                             readcell_ptr->numterms:=readcell_ptr->numterms+1;
                                             if(readcell_ptr->numterms=1) then 
                                             {
                                                 readcell_ptr->tileptr->termsptr:=(termbox*)safe_malloc(sizeof(termbox),RValue);
												 readcell_term<==readcell_ptr->tileptr->termsptr and skip
                                                 
                                             }
                                             else
                                             {
                                                 readcell_term->nextterm:=(termbox*)safe_malloc(sizeof(termbox),RValue);
												 readcell_term<==readcell_term->nextterm and skip
                                             };
                                             readcell_term->nextterm:=NULL;
                                             readcell_term->cellterm:=(readcell_pinctr+1);
                                             readcell_pinctr:=readcell_pinctr+1;
                                             readcell_term->ue:=0;
                                             readcell_saveptr:=netarray[readcell_netx]->netptr;
                                             netarray[readcell_netx]->netptr:=(netbox*)safe_malloc(sizeof(netbox),RValue);
											 readcell_netptr<==netarray[readcell_netx]->netptr and skip;
                                             readcell_netptr->nterm:=readcell_saveptr;
                                             readcell_netptr->terminal:=readcell_pinctr;
                                             readcell_netptr->net:=readcell_netx;
                                             readcell_netptr->xpos:=0;
                                             readcell_netptr->ypos:=0;
                                             readcell_netptr->newx:=0;
                                             readcell_netptr->newy:=0;
                                             readcell_netptr->flag:=0;
                                             readcell_netptr->cell:=readcell_cell+readcell_terms;
                                             if(pin_layers_given!=0) then 
                                             {
                                                 fscanf(fp," %s ",readcell_input$) and skip;
                                                 fscanf(fp," %d ",&readcell_layer) and skip
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             fscanf(fp," %d %d ",&readcell_xpos,&readcell_ypos) and skip;
                                             readcell_totx:=readcell_xpos;
                                             readcell_toty:=readcell_ypos;
                                             readcell_term->txpos[0]:=readcell_xpos;
                                             readcell_term->typos[0]:=readcell_ypos
                                         }
                                         else
                                         {
                                             implicit_feed_count:=implicit_feed_count+1;
                                             if(pin_layers_given!=0) then 
                                             {
                                                 fscanf(fp," %s ",readcell_input$) and skip;
                                                 fscanf(fp," %d ",&readcell_layer) and skip
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             fscanf(fp," %d %d ",&readcell_xpos,&readcell_ypos) and skip
                                         }
                                     }
                                     else
                                     {
                                         if(strcmp(readcell_input$,"equiv")=0) then 
                                         {
                                             fscanf(fp," %s ",readcell_input$) and skip;
                                             fscanf(fp," %s ",readcell_input$) and skip;
                                             if(pin_layers_given!=0) then 
                                             {
                                                 fscanf(fp," %s ",readcell_input$) and skip;
                                                 fscanf(fp," %d ",&readcell_layer) and skip
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             };
                                             fscanf(fp," %d %d ",&readcell_xpos,&readcell_ypos) and skip;
                                             if(strcmp(readcell_netname,"TW_PASS_THRU")!=0) then 
                                             {
                                                 readcell_tot:=readcell_tot+1;
                                                 readcell_totx:=readcell_totx+readcell_xpos;
                                                 readcell_toty:=readcell_toty+readcell_ypos;
                                                 readcell_term->txpos[0]:=readcell_totx/ readcell_tot;
                                                 if(readcell_terms=0) then 
                                                 {
                                                     readcell_term->typos[0]:=0
                                                 }
                                                 else
                                                 {
                                                     readcell_term->typos[0]:=readcell_toty/ readcell_tot
                                                 }
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                         }
                                         else
                                         {
                                             if(strcmp(readcell_input$,"unequiv")=0) then 
                                             {
                                                 fscanf(fp," %s ",readcell_input$) and skip;
                                                 fscanf(fp," %s ",readcell_input$) and skip;
                                                 if(pin_layers_given!=0) then 
                                                 {
                                                     fscanf(fp," %s ",readcell_input$) and skip;
                                                     fscanf(fp," %d ",&readcell_layer) and skip
                                                     
                                                 }
                                                 else 
                                                 {
                                                      skip 
                                                 };
                                                 fscanf(fp," %d %d ",&readcell_xpos,&readcell_ypos) and skip;
                                                 readcell_tot:=readcell_tot+1;
                                                 readcell_totx:=readcell_totx+readcell_xpos;
                                                 readcell_term->txpos[0]:=readcell_totx/ readcell_tot;
                                                 readcell_term->typos[0]:=0;
                                                 readcell_term->ue:=1
                                             }
                                             else
                                             {
                                                 if(strcmp(readcell_input$,"pad")=0) then 
                                                 {
                                                     readcell_terms:=readcell_terms+1;
                                                     fscanf(fp," %s ",readcell_input$) and skip;
                                                     fscanf(fp," %s ",readcell_input$) and skip;
                                                     readcell_ptr:=carray[numcells+readcell_terms];
                                                     int readcell_1_3_5_13_15_17_19_21_30_36_39_40_temp$_3 and skip;
                                                     readcell_1_3_5_13_15_17_19_21_30_36_39_40_temp$_3:=strlen(readcell_input$);
                                                     readcell_ptr->cname:=(char *)safe_malloc((readcell_1_3_5_13_15_17_19_21_30_36_39_40_temp$_3+1)*sizeof(char),RValue);
                                                     sprintf(readcell_ptr->cname,"%s",readcell_input$,RValue) and skip;
                                                     readcell_ptr->cclass:=0;
                                                     readcell_ptr->orflag:=0
                                                 }
                                                 else
                                                 {
                                                     if(strcmp(readcell_input$,"orient")=0) then 
                                                     {
                                                         fscanf(fp," %d ",&readcell_orient) and skip;
                                                         readcell_ptr->corient:=readcell_orient
                                                     }
                                                     else
                                                     {
                                                         if(strcmp(readcell_input$,"padside")=0) then 
                                                         {
                                                             fscanf(fp," %s ",readcell_input$) and skip;
                                                             if(strcmp(readcell_input$,"L")=0) then 
                                                             {
                                                                 readcell_ptr->padside:=1
                                                             }
                                                             else
                                                             {
                                                                 if(strcmp(readcell_input$,"T")=0) then 
                                                                 {
                                                                     readcell_ptr->padside:=2
                                                                 }
                                                                 else
                                                                 {
                                                                     if(strcmp(readcell_input$,"R")=0) then 
                                                                     {
                                                                         readcell_ptr->padside:=3
                                                                     }
                                                                     else
                                                                     {
                                                                         if(strcmp(readcell_input$,"B")=0) then 
                                                                         {
                                                                             readcell_ptr->padside:=4
                                                                         }
                                                                         else
                                                                         {
                                                                             if(strcmp(readcell_input$,"5")=0) then 
                                                                             {
                                                                                 readcell_ptr->padside:=5
                                                                             }
                                                                             else
                                                                             {
                                                                                 if(strcmp(readcell_input$,"6")=0) then 
                                                                                 {
                                                                                     readcell_ptr->padside:=6
                                                                                 }
                                                                                 else
                                                                                 {
                                                                                     if(strcmp(readcell_input$,"7")=0) then 
                                                                                     {
                                                                                         readcell_ptr->padside:=7
                                                                                     }
                                                                                     else
                                                                                     {
                                                                                         if(strcmp(readcell_input$,"8")=0) then 
                                                                                         {
                                                                                             readcell_ptr->padside:=8
                                                                                         }
                                                                                         else
                                                                                         {
                                                                                             if(strcmp(readcell_input$,"9")=0) then 
                                                                                             {
                                                                                                 readcell_ptr->padside:=9
                                                                                             }
                                                                                             else
                                                                                             {
                                                                                                 if(strcmp(readcell_input$,"10")=0) then 
                                                                                                 {
                                                                                                     readcell_ptr->padside:=10
                                                                                                 }
                                                                                                 else
                                                                                                 {
                                                                                                     if(strcmp(readcell_input$,"11")=0) then 
                                                                                                     {
                                                                                                         output ("macro at position 11 is no longer supported -- sorry!\n") and skip;
                                                                                                         exit(0) and skip;
                                                                                                         readcell_ptr->padside:=11
                                                                                                     }
                                                                                                     else
                                                                                                     {
                                                                                                         if(strcmp(readcell_input$,"MT")=0) then 
                                                                                                         {
                                                                                                             output ("macro at position MT is no longer supported -- sorry!\n") and skip;
                                                                                                             exit(0) and skip;
                                                                                                             readcell_ptr->padside:=12
                                                                                                         }
                                                                                                         else
                                                                                                         {
                                                                                                             if(strcmp(readcell_input$,"MM")=0) then 
                                                                                                             {
                                                                                                                 output ("macro at position MM is no longer supported -- sorry!\n") and skip;
                                                                                                                 exit(0) and skip;
                                                                                                                 readcell_ptr->padside:=13
                                                                                                             }
                                                                                                             else
                                                                                                             {
                                                                                                                 if(strcmp(readcell_input$,"MTT")=0) then 
                                                                                                                 {
                                                                                                                     readcell_ptr->padside:=14
                                                                                                                 }
                                                                                                                 else
                                                                                                                 {
                                                                                                                     if(strcmp(readcell_input$,"15")=0) then 
                                                                                                                     {
                                                                                                                         readcell_ptr->padside:=15
                                                                                                                     }
                                                                                                                     else
                                                                                                                     {
                                                                                                                         fprintf(fpo,"padside not specified properly for ") and skip;
                                                                                                                         fprintf(fpo,"pad: %s\n",readcell_ptr->cname) and skip;
                                                                                                                         exit(0) and skip 
                                                                                                                     }
                                                                                                                 }
                                                                                                             }
                                                                                                         }
                                                                                                     }
                                                                                                 }
                                                                                             }
                                                                                         }
                                                                                     }
                                                                                 }
                                                                             }
                                                                         }
                                                                     }
                                                                 }
                                                             }
                                                         }
                                                         else
                                                         {
                                                             if(strcmp(readcell_input$,"sidespace")=0) then 
                                                             {
                                                                 fscanf(fp," %f ",&readcell_space) and skip;
                                                                 if(readcell_ptr->padside=1) then 
                                                                 {
                                                                     fixLRBT[0]:=1;
                                                                     padspace[readcell_terms]:=readcell_space
                                                                 }
                                                                 else
                                                                 {
                                                                     if(readcell_ptr->padside=3) then 
                                                                     {
                                                                         fixLRBT[1]:=1;
                                                                         padspace[readcell_terms]:=readcell_space
                                                                     }
                                                                     else
                                                                     {
                                                                         if(readcell_ptr->padside=4) then 
                                                                         {
                                                                             fixLRBT[2]:=1;
                                                                             padspace[readcell_terms]:=readcell_space
                                                                         }
                                                                         else
                                                                         {
                                                                             if(readcell_ptr->padside=2) then 
                                                                             {
                                                                                 fixLRBT[3]:=1;
                                                                                 padspace[readcell_terms]:=readcell_space
                                                                             }
                                                                             else
                                                                             {
                                                                                 macspace[readcell_ptr->padside]:=readcell_space
                                                                             }
                                                                         }
                                                                     }
                                                                 }
                                                                 
                                                             }
                                                             else 
                                                             {
                                                                  skip 
                                                             }
                                                         }
                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }
                     }
                 }
             }
         }
     };
	 
     break$<==0 and skip;
     readcell_cell:=1;
     
     while( break$=0 AND  readcell_cell<=numcells)
     {
         if(carray[readcell_cell]->orflag=1) then 
         {
             if(maxCellO=0) then 
             {
                 maxCellO:=2
                 
             }
             else
             {
                 if(maxCellO=1) then 
                 {
                     maxCellO:=3
                     
                 }
                 else 
                 {
                      skip 
                 }
             };
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             readcell_cell:=readcell_cell+1
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     readcell_cell:=1;
     
     while(readcell_cell<=numcells)
     {
         readcell_ptr:=carray[readcell_cell];
         readcell_tptr:=readcell_ptr->tileptr;
         readcell_tmptr:=readcell_tptr->termsptr;
         
         while(readcell_tmptr!=NULL)
         {
             if((readcell_ptr->clength % 2!=0)) then 
             {
                 readcell_tmptr->txpos[1]:=-readcell_tmptr->txpos[0]+1
                 
             }
             else
             {
                 readcell_tmptr->txpos[1]:=-readcell_tmptr->txpos[0]
             };
             if((readcell_ptr->cheight % 2!=0)) then 
             {
                 readcell_tmptr->typos[1]:=-readcell_tmptr->typos[0]+1
                 
             }
             else
             {
                 readcell_tmptr->typos[1]:=-readcell_tmptr->typos[0]
             };
             readcell_tmptr:=readcell_tmptr->nextterm
             
         };
         readcell_cell:=readcell_cell+1
         
     };
     readcell_cell:=numcells+1;
     
     while(readcell_cell<=numcells+numterms)
     {
         readcell_ptr:=carray[readcell_cell];
         readcell_tptr:=readcell_ptr->tileptr;
         readcell_orient:=readcell_ptr->corient;
         move(readcell_orient,RValue);
         rect(&readcell_tptr->left,&readcell_tptr->bottom,&readcell_tptr->right,&readcell_tptr->top,RValue);
         if((readcell_ptr->cheight % 2!=0 AND (readcell_orient=4 OR readcell_orient=6)) OR (readcell_ptr->clength % 2!=0 AND (readcell_orient=2 OR readcell_orient=3))) then 
         {
             readcell_tptr->left:=readcell_tptr->left+1;
             readcell_tptr->right:=readcell_tptr->right+1
             
         }
         else 
         {
              skip 
         };
         if((readcell_ptr->cheight % 2!=0 AND (readcell_orient=1 OR readcell_orient=3)) OR (readcell_ptr->clength % 2!=0 AND (readcell_orient=4 OR readcell_orient=7))) then 
         {
             readcell_tptr->bottom:=readcell_tptr->bottom+1;
             readcell_tptr->top:=readcell_tptr->top+1
             
         }
         else 
         {
              skip 
         };
         readcell_tmptr:=readcell_tptr->termsptr;
         
         while(readcell_tmptr!=NULL)
         {
             readcell_tmptr->txpos[1]:=readcell_tmptr->txpos[0];
             readcell_tmptr->typos[1]:=readcell_tmptr->typos[0];
             point(&readcell_tmptr->txpos[1],&readcell_tmptr->typos[1],RValue);
             if((readcell_ptr->cheight % 2!=0 AND (readcell_orient=4 OR readcell_orient=6)) OR (readcell_ptr->clength % 2!=0 AND (readcell_orient=2 OR readcell_orient=3))) then 
             {
                 readcell_tmptr->txpos[1]:=readcell_tmptr->txpos[1]+1
                 
             }
             else 
             {
                  skip 
             };
             if((readcell_ptr->cheight % 2!=0 AND (readcell_orient=1 OR readcell_orient=3)) OR (readcell_ptr->clength % 2!=0 AND (readcell_orient=4 OR readcell_orient=7))) then 
             {
                 readcell_tmptr->typos[1]:=readcell_tmptr->typos[1]+1
                 
             }
             else 
             {
                  skip 
             };
             readcell_tmptr:=readcell_tmptr->nextterm
             
         };
         readcell_cell:=readcell_cell+1
         
     };
	
     configure();
     carray:=(cellbox* *)safe_realloc(carray,(1+numcells+numterms)*sizeof(cellbox*),RValue);
     readcell_block:=1;
     
     while(readcell_block<=numblock)
     {
         totallen:=totallen+barray[readcell_block]->blength;
         readcell_block:=readcell_block+1
         
     };
     fprintf(fpo,"total cell length: %d\n",celllen) and skip;
     fprintf(fpo,"total block length: %d\n",totallen) and skip;

      return<==1 and skip
     )
     }; 
  function readnets ( FILE *fp )
 {
     frame(readnets_net,readnets_test,readnets_status,readnets_Hweight,readnets_Vweight,readnets_beta,readnets_total_weight,readnets_netptr,readnets_input$,return) and ( 
     int return<==0 and skip;
     int readnets_net,readnets_test,readnets_status and skip;
     float readnets_Hweight,readnets_Vweight,readnets_beta,readnets_total_weight and skip;
     netbox* readnets_netptr and skip;
     char readnets_input$[1024] and skip;
     fscanf(fp," %s ",readnets_input$) and skip;
     if(strcmp(readnets_input$,"allnets")!=0) then 
     {
         fprintf(fpo,"The keyword allnets was ") and skip;
         fprintf(fpo,"not properly entered in the .net file\n") and skip;
         exit(0) and skip 
         
     }
     else 
     {
          skip 
     };
     fscanf(fp," %s ",readnets_input$) and skip;
     if(strcmp(readnets_input$,"HVweights")!=0) then 
     {
         fprintf(fpo,"The keyword HVweights was ") and skip;
         fprintf(fpo,"not properly entered in the .net file\n") and skip;
         exit(0) and skip 
         
     }
     else 
     {
          skip 
     };
     readnets_test:=fscanf(fp,"%f %f",&readnets_Hweight,&readnets_Vweight);
     if(readnets_test!=2) then 
     {
         fprintf(fpo,"The net weights for allnets were ") and skip;
         fprintf(fpo,"not properly entered in the .net file\n") and skip;
         exit(0) and skip 
         
     }
     else 
     {
          skip 
     };
     if(readnets_Hweight<=0.0 OR readnets_Vweight<=0.0) then 
     {
         fprintf(fpo,"A global net weight was ") and skip;
         fprintf(fpo,"zero or negative in the \n") and skip;
         fprintf(fpo,".net file\n") and skip;
         fprintf(fpo,"This is not allowed; choose .0001 instead\n") and skip;
         exit(0) and skip 
         
     }
     else 
     {
          skip 
     };
     if(readnets_Vweight<1.0) then 
     {
         readnets_Vweight:=1.0
         
     }
     else 
     {
          skip 
     };
     readnets_net:=1;
     
     while(readnets_net<=numnets)
     {
         netarray[readnets_net]->Hweight:=readnets_Hweight;
         netarray[readnets_net]->Vweight:=readnets_Vweight;
         readnets_net:=readnets_net+1
         
     };
     while(fscanf(fp," %s ",readnets_input$)=1)
     {
         if(strcmp(readnets_input$,"net")=0) then 
         {
             fscanf(fp," %s ",readnets_input$) and skip;
             readnets_status:=hashfind(readnets_input$,RValue);
             if(readnets_status=0) then 
             {
                 fprintf(fpo,"The net named: %s  in the .net file\n",readnets_input$) and skip;
                 fprintf(fpo,"was not encountered while reading\n") and skip;
                 fprintf(fpo,"the .cel file --- FATAL error\n") and skip;
                 exit(0) and skip 
                 
             }
             else 
             {
                  skip 
             }
         }
         else
         {
             if(strcmp(readnets_input$,"HVweights")=0) then 
             {
                 readnets_test:=fscanf(fp,"%f %f",&readnets_Hweight,&readnets_Vweight);
                 if(readnets_test!=2) then 
                 {
                     fprintf(fpo,"The critical net weights were ") and skip;
                     fprintf(fpo,"not properly entered\n") and skip;
                     fprintf(fpo,"in the .net file after net: %s\n",readnets_input$) and skip;
                     exit(0) and skip 
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(readnets_Hweight<=0.0 OR readnets_Vweight<=0.0) then 
                 {
                     fprintf(fpo,"A critical net weight was ") and skip;
                     fprintf(fpo,"zero or negative in the \n") and skip;
                     fprintf(fpo,".net file after net: %s\n",readnets_input$) and skip;
                     fprintf(fpo,"This is not allowed; choose .0001 instead\n") and skip;
                     exit(0) and skip 
                     
                 }
                 else 
                 {
                      skip 
                 };
                 netarray[readnets_status]->Hweight:=readnets_Hweight;
                 netarray[readnets_status]->Vweight:=readnets_Vweight
             }
             else
             {
                 if(strcmp(readnets_input$,"nofeeds")=0) then 
                 {
                     netarray[readnets_status]->feedflag:=1
                 }
                 else
                 {
                     if(strcmp(readnets_input$,"ignore")=0) then 
                     {
                         netarray[readnets_status]->ignore:=1
                     }
                     else
                     {
                         fprintf(fpo,"unexpected keyword in the .net file\n") and skip;
                         exit(0) and skip 
                     }
                 }
             }
         }
     };
     delHtab();
     if(!no_net_normalize) then 
     {
         readnets_total_weight:=0;
         readnets_net:=1;
         
         while(readnets_net<=numnets)
         {
             readnets_total_weight:=readnets_total_weight+netarray[readnets_net]->Hweight+netarray[readnets_net]->Vweight;
             readnets_net:=readnets_net+1
             
         };
         readnets_beta:=2.0*(float)numnets/ readnets_total_weight;
         readnets_net:=1;
         
         while(readnets_net<=numnets)
         {
             netarray[readnets_net]->Hweight:=netarray[readnets_net]->Hweight*readnets_beta;
             netarray[readnets_net]->Vweight:=netarray[readnets_net]->Vweight*readnets_beta;
             readnets_net:=readnets_net+1
             
         }
         
     }
     else 
     {
          skip 
     };
     readnets_net:=1;
     
     while(readnets_net<=numnets)
     {
         readnets_netptr:=netarray[readnets_net]->netptr;
         
         while(readnets_netptr!=NULL)
         {
             tearray[readnets_netptr->terminal]:=readnets_netptr;
             tearray[readnets_netptr->terminal]->net:=readnets_net;
             readnets_netptr:=readnets_netptr->nterm
             
         };
         readnets_net:=readnets_net+1
         
     };
      return<==1 and skip
     )
     }; 
  function readParFile (  )
 {
     frame(readParFile_fp,readParFile_filename,readParFile_input$,readParFile_test,readParFile_f,return) and ( 
     int return<==0 and skip;
     FILE *readParFile_fp and skip;
     char readParFile_filename[64],readParFile_input$[64] and skip;
     int readParFile_test and skip;
     float readParFile_f and skip;
     sprintf(readParFile_filename,"%s.par",cktName,RValue) and skip;
     readParFile_fp:=twopen(readParFile_filename,"r",1,RValue);
     route2act:=-1;
     routeGrid:=-1;
     gridCell:=-1;
     while(fscanf(readParFile_fp," %s ",readParFile_input$)=1)
     {
         if(strcmp(readParFile_input$,"implicit.feed.thru.range")=0) then 
         {
             readParFile_test:=fscanf(readParFile_fp," %f ",&imprange);
             if(readParFile_test!=1) then 
             {
                 fprintf(fpo,"The value of implicit.feed.thru.range") and skip;
                 fprintf(fpo," was not properly") and skip;
                 fprintf(fpo,"entered in the .par file\n") and skip;
                 exit(0) and skip 
                 
             }
             else 
             {
                  skip 
             }
         }
         else
         {
             if(strcmp(readParFile_input$,"fast")=0) then 
             {
                 readParFile_test:=fscanf(readParFile_fp," %d ",&tw_fast);
                 if(readParFile_test!=1) then 
                 {
                     fprintf(fpo,"The value of fast was not ") and skip;
                     fprintf(fpo,"properly entered in the .par file\n") and skip;
                     exit(0) and skip 
                     
                 }
                 else 
                 {
                      skip 
                 }
             }
             else
             {
                 if(strcmp(readParFile_input$,"slow")=0) then 
                 {
                     readParFile_test:=fscanf(readParFile_fp," %d ",&tw_slow);
                     if(readParFile_test!=1) then 
                     {
                         fprintf(fpo,"The value of fast was not ") and skip;
                         fprintf(fpo,"properly entered in the .par file\n") and skip;
                         exit(0) and skip 
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     if(strcmp(readParFile_input$,"pin_layers_given")=0) then 
                     {
                         pin_layers_given:=1
                     }
                     else
                     {
                         if(strcmp(readParFile_input$,"gate_array_special")=0) then 
                         {
                             gate_array_special:=1
                         }
                         else
                         {
                             if(strcmp(readParFile_input$,"connection_machine")=0) then 
                             {
                                 connection_machine:=1
                             }
                             else
                             {
                                 if(strcmp(readParFile_input$,"no_feeds_side_nets")=0) then 
                                 {
                                     no_feeds_side_nets:=0
                                 }
                                 else
                                 {
                                     if(strcmp(readParFile_input$,"no_net_normalize")=0) then 
                                     {
                                         no_net_normalize:=1
                                     }
                                     else
                                     {
                                         if(strcmp(readParFile_input$,"estimate_feeds")=0) then 
                                         {
                                             estimate_feeds:=1
                                         }
                                         else
                                         {
                                             if(strcmp(readParFile_input$,"cost_only")=0) then 
                                             {
                                                 costonly:=1
                                             }
                                             else
                                             {
                                                 if(strcmp(readParFile_input$,"do.global.route")=0) then 
                                                 {
                                                     doglobal:=1
                                                 }
                                                 else
                                                 {
                                                     if(strcmp(readParFile_input$,"do.global.route.cell.swaps")=0) then 
                                                     {
                                                         cswaps:=1;
                                                         stopdeg:=0.3
                                                     }
                                                     else
                                                     {
                                                         if(strcmp(readParFile_input$,"full")=0) then 
                                                         {
                                                             if(cswaps) then 
                                                             {
                                                                 stopdeg:=0.5
                                                                 
                                                             }
                                                             else 
                                                             {
                                                                  skip 
                                                             }
                                                         }
                                                         else
                                                         {
                                                             if(strcmp(readParFile_input$,"feedThruWidth")=0) then 
                                                             {
                                                                 readParFile_test:=fscanf(readParFile_fp," %d ",&fdWidth);
                                                                 if(readParFile_test!=1) then 
                                                                 {
                                                                     fprintf(fpo,"The value of feedThruWidth was not ") and skip;
                                                                     fprintf(fpo,"properly entered in the .par file\n") and skip;
                                                                     exit(0) and skip 
                                                                     
                                                                 }
                                                                 else 
                                                                 {
                                                                      skip 
                                                                 }
                                                             }
                                                             else
                                                             {
                                                                 if(strcmp(readParFile_input$,"layer")=0) then 
                                                                 {
                                                                     readParFile_test:=fscanf(readParFile_fp," %d ",&feedLayer);
                                                                     if(readParFile_test!=1) then 
                                                                     {
                                                                         fprintf(fpo,"The value of layer was not ") and skip;
                                                                         fprintf(fpo,"properly entered in the .par file\n") and skip;
                                                                         exit(0) and skip 
                                                                         
                                                                     }
                                                                     else 
                                                                     {
                                                                          skip 
                                                                     };
                                                                     if(feedLayer!=1 AND feedLayer!=2 AND feedLayer!=3) then 
                                                                     {
                                                                         fprintf(fpo,"The value of layer must currently be one of ") and skip;
                                                                         fprintf(fpo,"1, 2, or 3 \n") and skip;
                                                                         exit(0) and skip 
                                                                     }
                                                                     else
                                                                     {
                                                                         feedLayer:=feedLayer-1
                                                                     }
                                                                 }
                                                                 else
                                                                 {
                                                                     if(strcmp(readParFile_input$,"addFeeds")=0) then 
                                                                     {
                                                                         addFeeds:=1
                                                                     }
                                                                     else
                                                                     {
                                                                         if(strcmp(readParFile_input$,"indent")=0) then 
                                                                         {
                                                                             readParFile_test:=fscanf(readParFile_fp," %f ",&indent);
                                                                             indent:=1.0
                                                                         }
                                                                         else
                                                                         {
                                                                             if(strcmp(readParFile_input$,"random.seed")=0) then 
                                                                             {
                                                                                 readParFile_test:=fscanf(readParFile_fp," %d ",&randomSeed);
                                                                                 if(readParFile_test!=1) then 
                                                                                 {
                                                                                     fprintf(fpo,"The value of random.seed was not ") and skip;
                                                                                     fprintf(fpo,"properly entered in the .par file\n") and skip;
                                                                                     exit(0) and skip 
                                                                                     
                                                                                 }
                                                                                 else 
                                                                                 {
                                                                                      skip 
                                                                                 }
                                                                             }
                                                                             else
                                                                             {
                                                                                 if(strcmp(readParFile_input$,"random.seed2")=0) then 
                                                                                 {
                                                                                     readParFile_test:=fscanf(readParFile_fp," %d ",&randomSeed2);
                                                                                     if(readParFile_test!=1) then 
                                                                                     {
                                                                                         fprintf(fpo,"The value of random.seed2 was not ") and skip;
                                                                                         fprintf(fpo,"properly entered in the .par file\n") and skip;
                                                                                         exit(0) and skip 
                                                                                         
                                                                                     }
                                                                                     else 
                                                                                     {
                                                                                          skip 
                                                                                     }
                                                                                 }
                                                                                 else
                                                                                 {
                                                                                     if(strcmp(readParFile_input$,"rowSep")=0) then 
                                                                                     {
                                                                                         readParFile_test:=fscanf(readParFile_fp," %f ",&rowSep);
                                                                                         if(readParFile_test!=1) then 
                                                                                         {
                                                                                             fprintf(fpo,"The value of rowSep was not properly") and skip;
                                                                                             fprintf(fpo,"entered in the .par file\n") and skip;
                                                                                             exit(0) and skip 
                                                                                             
                                                                                         }
                                                                                         else 
                                                                                         {
                                                                                              skip 
                                                                                         }
                                                                                     }
                                                                                     else
                                                                                     {
                                                                                         if(strcmp(readParFile_input$,"restart")=0) then 
                                                                                         {
                                                                                             resume_run:=1
                                                                                         }
                                                                                         else
                                                                                         {
                                                                                             if(strcmp(readParFile_input$,"track.spacing")=0) then 
                                                                                             {
                                                                                                 uneven_cell_height:=1;
                                                                                                 readParFile_test:=fscanf(readParFile_fp," %d ",&track_spacing);
                                                                                                 if(readParFile_test!=1) then 
                                                                                                 {
                                                                                                     fprintf(fpo,"The value of trackSpacing was not properly") and skip;
                                                                                                     fprintf(fpo,"entered in the .par file\n") and skip;
                                                                                                     exit(0) and skip 
                                                                                                     
                                                                                                 }
                                                                                                 else 
                                                                                                 {
                                                                                                      skip 
                                                                                                 }
                                                                                             }
                                                                                             else
                                                                                             {
                                                                                                 if(strcmp(readParFile_input$,"one.pin.feedthru")=0) then 
                                                                                                 {
                                                                                                     one_pin_feedthru:=1
                                                                                                 }
                                                                                                 else
                                                                                                 {
                                                                                                     if(strcmp(readParFile_input$,"route2act")=0) then 
                                                                                                     {
                                                                                                         readParFile_test:=fscanf(readParFile_fp," %d ",&route2act);
                                                                                                         if(readParFile_test!=1) then 
                                                                                                         {
                                                                                                             fprintf(fpo,"The value of route2act was not properly") and skip;
                                                                                                             fprintf(fpo,"entered in the .par file\n") and skip;
                                                                                                             exit(0) and skip 
                                                                                                             
                                                                                                         }
                                                                                                         else 
                                                                                                         {
                                                                                                              skip 
                                                                                                         }
                                                                                                     }
                                                                                                     else
                                                                                                     {
                                                                                                         if(strcmp(readParFile_input$,"gridCell")=0) then 
                                                                                                         {
                                                                                                             readParFile_test:=fscanf(readParFile_fp," %d ",&gridCell);
                                                                                                             if(readParFile_test!=1) then 
                                                                                                             {
                                                                                                                 fprintf(fpo,"The value of gridCell was not properly") and skip;
                                                                                                                 fprintf(fpo,"entered in the .par file\n") and skip;
                                                                                                                 exit(0) and skip 
                                                                                                                 
                                                                                                             }
                                                                                                             else 
                                                                                                             {
                                                                                                                  skip 
                                                                                                             }
                                                                                                         }
                                                                                                         else
                                                                                                         {
                                                                                                             if(strcmp(readParFile_input$,"routeGrid")=0) then 
                                                                                                             {
                                                                                                                 readParFile_test:=fscanf(readParFile_fp," %d ",&routeGrid);
                                                                                                                 if(readParFile_test!=1) then 
                                                                                                                 {
                                                                                                                     fprintf(fpo,"The value of routeGrid was not properly") and skip;
                                                                                                                     fprintf(fpo,"entered in the .par file\n") and skip;
                                                                                                                     exit(0) and skip 
                                                                                                                     
                                                                                                                 }
                                                                                                                 else 
                                                                                                                 {
                                                                                                                      skip 
                                                                                                                 }
                                                                                                             }
                                                                                                             else
                                                                                                             {
                                                                                                                 fprintf(fpo,"Unparsable keyword>>> %s\n",readParFile_input$) and skip;
                                                                                                                 fprintf(fpo,"was found in the .par file\n") and skip;
                                                                                                                 exit(0) and skip 
                                                                                                             }
                                                                                                         }
                                                                                                     }
                                                                                                 }
                                                                                             }
                                                                                         }
                                                                                     }
                                                                                 }
                                                                             }
                                                                         }
                                                                     }
                                                                 }
                                                             }
                                                         }
                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }
                     }
                 }
             }
         }
     };
     twclose(readParFile_fp);
     sprintf(readParFile_filename,"%s.rs2",cktName,RValue) and skip;
     readParFile_fp:=twopen(readParFile_filename,"r",0,RValue) ;
     if((readParFile_fp) AND resume_run=1) then 
     {
         fscanf(readParFile_fp,"%f",&readParFile_f) and skip;
         fscanf(readParFile_fp,"%d",&stage) and skip;
         fscanf(readParFile_fp,"%d",&stage) and skip;
         fscanf(readParFile_fp,"%d",&stage) and skip;
         fprintf(fpo,"\n\nNOTE: Restart file .rs2 will be used \n\n") and skip;
         twclose(readParFile_fp);
         restart:=1
         
     }
     else
     {
         stage:=1;
         fprintf(fpo,"\n\nNOTE: Restart file .rs2 not used\n\n") and skip;
         restart:=0
     };
     if(cswaps!=0) then 
     {
         if(doglobal=0) then 
         {
             fprintf(fpo,"user specified cell swaps ") and skip;
             fprintf(fpo,"without requesting do.global.route\n") and skip;
             exit(0) and skip 
             
         }
         else 
         {
              skip 
         }
         
     }
     else 
     {
          skip 
     };
     if(doglobal) then 
     {
         fprintf(fpo,"TimberWolf will perform a global route step\n") and skip
         
     }
     else 
     {
          skip 
     };
     if(cswaps) then 
     {
         fprintf(fpo,"TimberWolf will perform final cell placements\n") and skip;
         fprintf(fpo," by swapping cells based on minimization of\n") and skip;
         fprintf(fpo," the total number of routing tracks required\n") and skip
         
     }
     else 
     {
          skip 
     };
     if(addFeeds AND imprange<0.0) then 
     {
         fprintf(fpo,"implicit.feed.thru.range was ") and skip;
         fprintf(fpo,"not entered in the .par file\n") and skip;
         exit(0) and skip 
         
     }
     else 
     {
          skip 
     };
     if(rowSep<0.0) then 
     {
         fprintf(fpo,"rowSep was not entered in the .par file\n") and skip;
         exit(0) and skip 
         
     }
     else
     {
         fprintf(fpo,"rowSep: %f\n",rowSep) and skip
     };
     if(addFeeds=1 AND fdWidth=-1) then 
     {
         fprintf(fpo,"feedThruWidth was not entered in the .par file\n") and skip;
         exit(0) and skip 
         
     }
     else
     {
         fprintf(fpo,"feedThruWidth: %d\n",fdWidth) and skip
     };
      return<==1 and skip
     )
     }; 
  function readseg ( FILE *fp )
 {
     frame(readseg_segment,readseg_net,readseg_net1,readseg_net2,readseg_key_flag,readseg_channel,readseg_pin1,readseg_pin2,readseg_ltop,readseg_rtop,readseg_lbot,readseg_rbot,readseg_Tleft,readseg_Tright,readseg_Bleft,readseg_Bright,readseg_input$,readseg_tmp_ptr,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     int readseg_segment,readseg_net,readseg_net1,readseg_net2,readseg_key_flag and skip;
     int readseg_channel,readseg_pin1,readseg_pin2 and skip;
     int readseg_ltop,readseg_rtop,readseg_lbot,readseg_rbot and skip;
     int readseg_Tleft,readseg_Tright,readseg_Bleft,readseg_Bright and skip;
     char readseg_input$[16] and skip;
     segbox* readseg_tmp_ptr and skip;
     readseg_segment:=0;
     numSwSegs:=0;
     numSegs:=0;
     while(fscanf(fp," %s ",readseg_input$)=1)
     {
         if(strcmp(readseg_input$,"net")=0) then 
         {
             fscanf(fp," %d ",&readseg_net) and skip
         }
         else
         {
             if(strcmp(readseg_input$,"segment")=0) then 
             {
                 numSegs:=numSegs+1;
                 fscanf(fp," %s ",readseg_input$) and skip;
                 if(strcmp(readseg_input$,"channel")=0) then 
                 {
                     fscanf(fp,"%d",&readseg_channel) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin1) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin2) and skip;
                     fscanf(fp,"%d",&readseg_ltop) and skip;
                     fscanf(fp,"%d",&readseg_rtop) and skip
                 }
                 else
                 {
                     numSwSegs:=numSwSegs+1;
                     fscanf(fp,"%d",&readseg_key_flag) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_channel) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin1) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin2) and skip;
                     fscanf(fp,"%d",&readseg_ltop) and skip;
                     fscanf(fp,"%d",&readseg_rtop) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_channel) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin1) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin2) and skip;
                     fscanf(fp,"%d",&readseg_lbot) and skip;
                     fscanf(fp,"%d",&readseg_rbot) and skip
                 }
                 
             }
             else 
             {
                  skip 
             }
         }
     };
     fprintf(fpo,"\nTotal Number of Net Segments: %d\n",numSegs) and skip;
     fprintf(fpo,"Number of Switchable Net Segments: %d\n\n",numSwSegs) and skip;
     fprintf(fpo,"Number of channels: %d\n\n",numChans) and skip;
     rewind(fp) and skip;
     aNetSeg:=(switchbox*)safe_malloc((numSegs+1)*sizeof(switchbox),RValue);
     fixnetseg:=(int *)safe_malloc((numSegs+1)*sizeof(int),RValue);
     anet:=(int *)safe_malloc((numnets+2)*sizeof(int),RValue);
     readseg_net:=0;
     
     while(readseg_net<=numnets+1)
     {
         anet[readseg_net]:=0;
         readseg_net:=readseg_net+1
         
     };
     netchgs:=(int *)safe_malloc((numnets+1)*sizeof(int),RValue);
     while(fscanf(fp," %s ",readseg_input$)=1)
     {
         if(strcmp(readseg_input$,"net")=0) then 
         {
             fscanf(fp," %d ",&readseg_net) and skip;
             anet[readseg_net]:=readseg_segment+1
         }
         else
         {
             if(strcmp(readseg_input$,"segment")=0) then 
             {
                 readseg_segment:=readseg_segment+1;
                 fscanf(fp," %s ",readseg_input$) and skip;
                 if(strcmp(readseg_input$,"channel")=0) then 
                 {
                     fscanf(fp,"%d",&readseg_channel) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin1) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin2) and skip;
                     fscanf(fp,"%d",&readseg_ltop) and skip;
                     fscanf(fp,"%d",&readseg_rtop) and skip;
                     aNetSeg[readseg_segment].top:=(segbox*)safe_malloc(sizeof(segbox),RValue);
                     aNetSeg[readseg_segment].bot:=(segbox*)safe_malloc(sizeof(segbox),RValue);
                     aNetSeg[readseg_segment].ntop:=(segbox*)safe_malloc(sizeof(segbox),RValue);
                     aNetSeg[readseg_segment].nbot:=(segbox*)safe_malloc(sizeof(segbox),RValue);
                     aNetSeg[readseg_segment].net:=readseg_net;
                     aNetSeg[readseg_segment].nflag:=0;
                     aNetSeg[readseg_segment].current:=0;
                     aNetSeg[readseg_segment].swYorN:=0;
                     aNetSeg[readseg_segment].key:=0;
                     aNetSeg[readseg_segment].nkey:=0;
                     aNetSeg[readseg_segment].top->channel:=readseg_channel;
                     aNetSeg[readseg_segment].top->pin1:=readseg_pin1;
                     aNetSeg[readseg_segment].top->pin2:=readseg_pin2;
                     aNetSeg[readseg_segment].top->pin1ptr:=Tgrid[readseg_pin1]->up;
                     if(tearray[readseg_pin1]->pinloc=0 AND tearray[readseg_pin1]->row=readseg_channel) then 
                     {
                         aNetSeg[readseg_segment].top->pin1ptr:=Tgrid[readseg_pin1]->down
                         
                     }
                     else 
                     {
                          skip 
                     };
                     aNetSeg[readseg_segment].top->pin2ptr:=Tgrid[readseg_pin2]->up;
                     if(tearray[readseg_pin2]->pinloc=0 AND tearray[readseg_pin2]->row=readseg_channel) then 
                     {
                         aNetSeg[readseg_segment].top->pin2ptr:=Tgrid[readseg_pin2]->down
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     fscanf(fp,"%d",&readseg_key_flag) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_channel) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin1) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin2) and skip;
                     fscanf(fp,"%d",&readseg_ltop) and skip;
                     fscanf(fp,"%d",&readseg_rtop) and skip;
                     aNetSeg[readseg_segment].top:=(segbox*)safe_malloc(sizeof(segbox),RValue);
                     aNetSeg[readseg_segment].bot:=(segbox*)safe_malloc(sizeof(segbox),RValue);
                     aNetSeg[readseg_segment].ntop:=(segbox*)safe_malloc(sizeof(segbox),RValue);
                     aNetSeg[readseg_segment].nbot:=(segbox*)safe_malloc(sizeof(segbox),RValue);
                     aNetSeg[readseg_segment].net:=readseg_net;
                     aNetSeg[readseg_segment].nflag:=0;
                     aNetSeg[readseg_segment].current:=0;
                     aNetSeg[readseg_segment].swYorN:=1;
                     if(readseg_key_flag=0 OR ((anet[readseg_net]-1+readseg_key_flag)=readseg_segment)) then 
                     {
                         aNetSeg[readseg_segment].key:=0
                         
                     }
                     else
                     {
                         aNetSeg[readseg_segment].key:=readseg_key_flag+anet[readseg_net]-1
                     };
                     aNetSeg[readseg_segment].nkey:=0;
                     aNetSeg[readseg_segment].top->channel:=readseg_channel;
                     aNetSeg[readseg_segment].top->pin1:=readseg_pin1;
                     aNetSeg[readseg_segment].top->pin2:=readseg_pin2;
                     if(readseg_ltop=-1) then 
                     {
                         readseg_pin1:=readseg_pin2
                         
                     }
                     else
                     {
                         if(readseg_ltop>0) then 
                         {
                             readseg_pin1:=readseg_ltop;
                             readseg_pin2:=readseg_rtop
                             
                         }
                         else 
                         {
                              skip 
                         }
                     };
                     readseg_Tleft:=tearray[readseg_pin1]->xpos;
                     aNetSeg[readseg_segment].top->pin1ptr:=Tgrid[readseg_pin1]->up;
                     if(tearray[readseg_pin1]->pinloc=0 AND tearray[readseg_pin1]->row=readseg_channel) then 
                     {
                         aNetSeg[readseg_segment].top->pin1ptr:=Tgrid[readseg_pin1]->down
                         
                     }
                     else 
                     {
                          skip 
                     };
                     readseg_Tright:=tearray[readseg_pin2]->xpos;
                     aNetSeg[readseg_segment].top->pin2ptr:=Tgrid[readseg_pin2]->up;
                     if(tearray[readseg_pin2]->pinloc=0 AND tearray[readseg_pin2]->row=readseg_channel) then 
                     {
                         aNetSeg[readseg_segment].top->pin2ptr:=Tgrid[readseg_pin2]->down
                         
                     }
                     else 
                     {
                          skip 
                     };
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_channel) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin1) and skip;
                     fscanf(fp," %s ",readseg_input$) and skip;
                     fscanf(fp,"%d",&readseg_pin2) and skip;
                     fscanf(fp,"%d",&readseg_lbot) and skip;
                     fscanf(fp,"%d",&readseg_rbot) and skip;
                     aNetSeg[readseg_segment].bot->channel:=readseg_channel;
                     aNetSeg[readseg_segment].bot->pin1:=readseg_pin1;
                     aNetSeg[readseg_segment].bot->pin2:=readseg_pin2;
                     if(readseg_lbot=-1) then 
                     {
                         readseg_pin1:=readseg_pin2
                         
                     }
                     else
                     {
                         if(readseg_lbot>0) then 
                         {
                             readseg_pin1:=readseg_lbot;
                             readseg_pin2:=readseg_rbot
                             
                         }
                         else 
                         {
                              skip 
                         }
                     };
                     readseg_Bleft:=tearray[readseg_pin1]->xpos;
                     aNetSeg[readseg_segment].bot->pin1ptr:=Tgrid[readseg_pin1]->up;
                     if(tearray[readseg_pin1]->pinloc=0 AND tearray[readseg_pin1]->row=readseg_channel) then 
                     {
                         aNetSeg[readseg_segment].bot->pin1ptr:=Tgrid[readseg_pin1]->down
                         
                     }
                     else 
                     {
                          skip 
                     };
                     readseg_Bright:=tearray[readseg_pin2]->xpos;
                     aNetSeg[readseg_segment].bot->pin2ptr:=Tgrid[readseg_pin2]->up;
                     if(tearray[readseg_pin2]->pinloc=0 AND tearray[readseg_pin2]->row=readseg_channel) then 
                     {
                         aNetSeg[readseg_segment].bot->pin2ptr:=Tgrid[readseg_pin2]->down
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(readseg_Bleft=readseg_Bright OR readseg_Tleft=readseg_Tright) then 
                     {
                         aNetSeg[readseg_segment].swYorN:=0;
                         if(readseg_Bleft=readseg_Bright AND readseg_Tleft!=readseg_Tright) then 
                         {
                             readseg_tmp_ptr:=aNetSeg[readseg_segment].top;
                             aNetSeg[readseg_segment].top:=aNetSeg[readseg_segment].bot;
                             aNetSeg[readseg_segment].bot:=readseg_tmp_ptr
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 
             }
             else 
             {
                  skip 
             }
         }
     };
     readseg_net2:=readseg_net+1;
     anet[readseg_net2]:=readseg_segment+1;
     readseg_net:=1;
     
     while(readseg_net<readseg_net2)
     {
         if(anet[readseg_net]=0) then 
         {
             break$<==0 and skip;
             readseg_net1:=readseg_net+1;
             
             while( break$=0 AND  readseg_net1<=readseg_net2)
             {
                 if(anet[readseg_net1]!=0) then 
                 {
                     anet[readseg_net]:=anet[readseg_net1];
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     readseg_net1:=readseg_net1+1
                 }
                 else
                 {
                     skip
                 }
             };
             break$<==0 and skip
             
         }
         else 
         {
              skip 
         };
         readseg_net:=readseg_net+1
         
     };
      return<==1 and skip
     )
     }; 
      int stage and skip;
     int last_level and skip;
 function savewolf ( int level )
 {
     frame(savewolf_fp,savewolf_xcenter,savewolf_ycenter,savewolf_cell,savewolf_block,savewolf_orient,savewolf_seg,savewolf_filename,savewolf_file1,savewolf_file2,savewolf_cellptr,savewolf_current_time,savewolf_last_time,return) and ( 
     int return<==0 and skip;
     FILE *savewolf_fp and skip;
     int savewolf_xcenter,savewolf_ycenter and skip;
     int savewolf_cell,savewolf_block,savewolf_orient,savewolf_seg and skip;
     char savewolf_filename[64] and skip;
     char savewolf_file1[1024],savewolf_file2[1024] and skip;
     cellbox* savewolf_cellptr and skip;
     float savewolf_current_time and skip;
     float savewolf_last_time<==0.0 and skip;
     savewolf_current_time:=cpu_time(RValue);
     if((savewolf_current_time-savewolf_last_time)<600.0 AND level=last_level AND level<=1) then 
     {
          return<==1 and skip
         
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         savewolf_last_time:=savewolf_current_time;
         last_level:=level;
         sprintf(savewolf_filename,"%s.tmp",cktName,RValue) and skip;
         savewolf_fp:=twopen(savewolf_filename,"w",1,RValue);
         fprintf(savewolf_fp,"%f\n",T) and skip;
         fprintf(savewolf_fp,"%d\n",iteration) and skip;
         fprintf(savewolf_fp,"%d\n",ffeeds) and skip;
         fprintf(savewolf_fp,"%d\n",level) and skip;
         fprintf(savewolf_fp,"%f\n",binpenCon) and skip;
         fprintf(savewolf_fp,"%f\n",roLenCon) and skip;
         fprintf(savewolf_fp,"%f\n",cost_scale_factor) and skip;
         fprintf(savewolf_fp,"%d\n",estimate_feeds) and skip;
         if(level=3) then 
         {
             fprintf(savewolf_fp,"%d\n",numSegs) and skip;
             savewolf_seg:=1;
             
             while(savewolf_seg<=numSegs)
             {
                 fprintf(savewolf_fp,"%d\n",aNetSeg[savewolf_seg].current) and skip;
                 savewolf_seg:=savewolf_seg+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         savewolf_cell:=1;
         
         while(savewolf_cell<=numcells+numterms)
         {
             savewolf_cellptr:=carray[savewolf_cell];
             savewolf_orient:=savewolf_cellptr->corient;
             savewolf_block:=savewolf_cellptr->cblock;
             savewolf_xcenter:=savewolf_cellptr->cxcenter;
             savewolf_ycenter:=savewolf_cellptr->cycenter;
             fprintf(savewolf_fp,"%d %d %d %d %d\n",savewolf_cell,savewolf_block,savewolf_orient,savewolf_xcenter,savewolf_ycenter) and skip;
             savewolf_cell:=savewolf_cell+1
             
         };
         twclose(savewolf_fp);
         sprintf(savewolf_file1,"%s.tmp",cktName,RValue) and skip;
         if(level=1) then 
         {
             sprintf(savewolf_file2,"%s.sav",cktName,RValue) and skip
             
         }
         else
         {
             sprintf(savewolf_file2,"%s.sv2",cktName,RValue) and skip
         };
         _unlink(savewolf_file2,RValue) and skip;
         rename(savewolf_file1,savewolf_file2,RValue) and skip;
          return<==1 and skip
     }
     else
     {
         skip
     }
     )
     }; 
  function TW_oldin ( FILE *fp )
 {
     frame(TW_oldin_cell,TW_oldin_orient,TW_oldin_numfds,TW_oldin_block,TW_oldin_xcenter,TW_oldin_ycenter,TW_oldin_dummy,TW_oldin_ptr,TW_oldin_term,TW_oldin_termptr,return) and ( 
     int return<==0 and skip;
     int TW_oldin_cell,TW_oldin_orient,TW_oldin_numfds and skip;
     int TW_oldin_block,TW_oldin_xcenter,TW_oldin_ycenter,TW_oldin_dummy and skip;
     cellbox* TW_oldin_ptr and skip;
     termbox* TW_oldin_term and skip;
     netbox* TW_oldin_termptr and skip;
     fscanf(fp,"%f",&T) and skip;
     fscanf(fp,"%d",&iteration) and skip;
     fscanf(fp,"%d",&TW_oldin_numfds) and skip;
     fscanf(fp,"%d",&TW_oldin_dummy) and skip;
     fscanf(fp,"%f",&binpenCon) and skip;
     fscanf(fp,"%f",&roLenCon) and skip;
     fscanf(fp,"%f",&cost_scale_factor) and skip;
     fscanf(fp,"%d",&estimate_feeds) and skip;
     while(fscanf(fp," %d %d %d %d %d ",&TW_oldin_cell,&TW_oldin_block,&TW_oldin_orient,&TW_oldin_xcenter,&TW_oldin_ycenter)=5)
     {
         TW_oldin_ptr:=carray[TW_oldin_cell];
         TW_oldin_ptr->cblock:=TW_oldin_block;
         TW_oldin_ptr->corient:=TW_oldin_orient;
         TW_oldin_ptr->cxcenter:=TW_oldin_xcenter;
         TW_oldin_ptr->cycenter:=TW_oldin_ycenter;
         if(TW_oldin_cell<=numcells) then 
         {
             TW_oldin_term:=TW_oldin_ptr->tileptr->termsptr;
             
             while(TW_oldin_term!=NULL)
             {
                 TW_oldin_termptr:=tearray[TW_oldin_term->cellterm];
                 TW_oldin_termptr->xpos:=TW_oldin_term->txpos[TW_oldin_orient/ 2]+TW_oldin_xcenter;
                 TW_oldin_termptr->ypos:=TW_oldin_term->typos[TW_oldin_orient % 2]+TW_oldin_ycenter;
                 TW_oldin_term:=TW_oldin_term->nextterm
                 
             }
         }
         else
         {
             TW_oldin_term:=TW_oldin_ptr->tileptr->termsptr;
             
             while(TW_oldin_term!=NULL)
             {
                 TW_oldin_termptr:=tearray[TW_oldin_term->cellterm];
                 TW_oldin_termptr->xpos:=TW_oldin_term->txpos[1]+TW_oldin_xcenter;
                 TW_oldin_termptr->ypos:=TW_oldin_term->typos[1]+TW_oldin_ycenter;
                 TW_oldin_term:=TW_oldin_term->nextterm
                 
             }
         }
     };
      return<==1 and skip
     )
     }; 
  function fixfdpos ( FILE *fp )
 {
     frame(fixfdpos_cell,fixfdpos_orient,fixfdpos_numfds,fixfdpos_dummy,fixfdpos_number,fixfdpos_seg,fixfdpos_current,fixfdpos_block,fixfdpos_xcenter,fixfdpos_ycenter,fixfdpos_junk,fixfdpos_d_dummy,fixfdpos_ptr,return) and ( 
     int return<==0 and skip;
     int fixfdpos_cell,fixfdpos_orient,fixfdpos_numfds,fixfdpos_dummy,fixfdpos_number,fixfdpos_seg,fixfdpos_current and skip;
     int fixfdpos_block,fixfdpos_xcenter,fixfdpos_ycenter,fixfdpos_junk and skip;
     float fixfdpos_d_dummy and skip;
     cellbox* fixfdpos_ptr and skip;
     fscanf(fp,"%f",&T) and skip;
     fscanf(fp,"%d",&iteration) and skip;
     fscanf(fp,"%d",&fixfdpos_numfds) and skip;
     fscanf(fp,"%d",&fixfdpos_dummy) and skip;
     fscanf(fp,"%f",&fixfdpos_d_dummy) and skip;
     fscanf(fp,"%f",&fixfdpos_d_dummy) and skip;
     fscanf(fp,"%f",&fixfdpos_d_dummy) and skip;
     fscanf(fp,"%d",&fixfdpos_junk) and skip;
     if(fixfdpos_dummy=3) then 
     {
         fscanf(fp,"%d",&fixfdpos_number) and skip;
         fixarray:=(int *)safe_malloc((fixfdpos_number+1)*sizeof(int),RValue);
         fixfdpos_seg:=1;
         
         while(fixfdpos_seg<=fixfdpos_number)
         {
             fscanf(fp,"%d",&fixfdpos_current) and skip;
             fixarray[fixfdpos_seg]:=fixfdpos_current;
             fixfdpos_seg:=fixfdpos_seg+1
             
         }
         
     }
     else 
     {
          skip 
     };
     while(fscanf(fp," %d %d %d %d %d ",&fixfdpos_cell,&fixfdpos_block,&fixfdpos_orient,&fixfdpos_xcenter,&fixfdpos_ycenter)=5)
     {
         fixfdpos_ptr:=carray[fixfdpos_cell];
         fixfdpos_ptr->cxcenter:=fixfdpos_xcenter;
         fixfdpos_ptr->cycenter:=fixfdpos_ycenter;
         fixfdpos_ptr->corient:=fixfdpos_orient
     };
      return<==1 and skip
     )
     }; 
  function sortpin (  )
 {
     frame(sortpin_j,sortpin_n,sortpin_cell,sortpin_ptr,sortpin_tile,sortpin_term,sortpin_xpptr,sortpin_termptr,continue) and ( 
     int continue<==0 and skip;
     int sortpin_j,sortpin_n,sortpin_cell and skip;
     cellbox* sortpin_ptr and skip;
     tilebox* sortpin_tile and skip;
     termbox* sortpin_term,**sortpin_xpptr and skip;
     netbox* sortpin_termptr and skip;
     sortpin_xpptr:=(termbox* *)safe_malloc(300*sizeof(termbox*),RValue);
     continue<==0 and skip;
     sortpin_cell:=1;
     
     while(sortpin_cell<=numcells+numterms)
     {
          continue<==0 and skip;
         sortpin_ptr:=carray[sortpin_cell];
         sortpin_tile:=sortpin_ptr->tileptr ;
         if((sortpin_tile)=NULL) then 
         {
             continue<==1 and skip;
              sortpin_cell:=sortpin_cell+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             sortpin_n:=0;
             sortpin_term:=sortpin_tile->termsptr;
             
             while(sortpin_term!=NULL)
             {
                 sortpin_termptr:=tearray[sortpin_term->cellterm];
                 sortpin_term->net:=sortpin_termptr->net;
                 sortpin_term->termptr:=sortpin_termptr;
                 sortpin_xpptr[(sortpin_n+1)]:=sortpin_term;
                 sortpin_n:=sortpin_n+1;
                 sortpin_term:=sortpin_term->nextterm
                 
             };
             shellsort(sortpin_xpptr,sortpin_n,RValue);
             sortpin_xpptr[sortpin_n+1]:=NULL;
             sortpin_ptr->tileptr->termsptr:=sortpin_xpptr[1];
             sortpin_j:=1;
             
             while(sortpin_j<=sortpin_n)
             {
                 sortpin_xpptr[sortpin_j]->nextterm:=sortpin_xpptr[sortpin_j+1];
                 sortpin_j:=sortpin_j+1
                 
             };
             sortpin_cell:=sortpin_cell+1
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     safe_free(sortpin_xpptr)
     )
     }; 
  function shellsort ( termbox* *term,int n,int RValue )
 {
     frame(shellsort_ptr,shellsort_incr,shellsort_i,shellsort_j) and ( 
     termbox* shellsort_ptr and skip;
     int shellsort_incr,shellsort_i,shellsort_j and skip;
     shellsort_incr:=n/ 2;
     
     while(shellsort_incr>0)
     {
         shellsort_i:=shellsort_incr+1;
         
         while(shellsort_i<=n)
         {
             shellsort_j:=shellsort_i-shellsort_incr;
             
             while(shellsort_j>0 AND (term[shellsort_j]->net>term[shellsort_j+shellsort_incr]->net))
             {
                 shellsort_ptr:=term[shellsort_j];
                 term[shellsort_j]:=term[shellsort_j+shellsort_incr];
                 term[shellsort_j+shellsort_incr]:=shellsort_ptr;
                 shellsort_j:=shellsort_j-shellsort_incr
                 
             };
             shellsort_i:=shellsort_i+1
             
         };
         shellsort_incr:=shellsort_incr/ 2
         
     }
     )
     }; 
  function print_stats ( FILE *fp )
 {
     fprintf(fp,"Usage statistics not available\n") and skip
     
 };
 function cpu_time ( float RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
     return<==1 and RValue:=0.0;
     skip
     )
     }; 
  function uc0 ( int a,int newaor )
 {
     frame(uc0_acellptr,uc0_antrmptr,uc0_cost,uc0_truth,return) and ( 
     int return<==0 and skip;
     cellbox* uc0_acellptr and skip;
     termbox* uc0_antrmptr and skip;
     int uc0_cost,uc0_truth and skip;
     uc0_acellptr:=carray[a];
     uc0_antrmptr:=uc0_acellptr->tileptr->termsptr;
     term_newpos(uc0_antrmptr,uc0_acellptr->cxcenter,uc0_acellptr->cycenter,newaor);
     uc0_cost:=funccost;
     new_dbox(uc0_antrmptr,&uc0_cost);
     uc0_truth:=acceptt(funccost-uc0_cost,RValue);
     if(uc0_truth=1) then 
     {
         dbox_pos(uc0_antrmptr);
         uc0_acellptr->corient:=newaor;
         funccost:=uc0_cost
         
     }
     else 
     {
          skip 
     };
      return<==1 and skip
     )
     }; 
  function ucg0 ( int a,int newaor, int RValue )
 {
     frame(ucg0_acellptr,ucg0_tmptr,ucg0_antilptr,ucg0_termptr,ucg0_antrmptr,ucg0_segptr,ucg0_denptr,ucg0_gdptr,ucg0_endgrd,ucg0_x,ucg0_y,ucg0_oldtracks,ucg0_track,ucg0_axcenter,ucg0_aycenter,ucg0_i,ucg0_b,ucg0_e,ucg0_seg,ucg0_chan,ucg0_net,ucg0_UpperLeft,ucg0_UpperRight,ucg0_LowerLeft,ucg0_LowerRight,ucg0_ULpin,ucg0_URpin,ucg0_LLpin,ucg0_LRpin,ucg0_leftx,ucg0_ritex,ucg0_topchan,ucg0_botchan,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     cellbox* ucg0_acellptr and skip;
     netbox* ucg0_tmptr and skip;
     tilebox* ucg0_antilptr and skip;
     termbox* ucg0_termptr,*ucg0_antrmptr and skip;
     segbox* ucg0_segptr and skip;
     densitybox* ucg0_denptr and skip;
     changrdbox* ucg0_gdptr,*ucg0_endgrd and skip;
     int ucg0_x,ucg0_y,ucg0_oldtracks,ucg0_track and skip;
     int ucg0_axcenter,ucg0_aycenter and skip;
     int ucg0_i,ucg0_b,ucg0_e,ucg0_seg,ucg0_chan,ucg0_net and skip;
     int ucg0_UpperLeft,ucg0_UpperRight,ucg0_LowerLeft,ucg0_LowerRight and skip;
     int ucg0_ULpin,ucg0_URpin,ucg0_LLpin,ucg0_LRpin and skip;
     int ucg0_leftx,ucg0_ritex,ucg0_topchan,ucg0_botchan and skip;
     ucg0_acellptr:=carray[a];
     ucg0_axcenter:=ucg0_acellptr->cxcenter;
     ucg0_aycenter:=ucg0_acellptr->cycenter;
     ucg0_antilptr:=ucg0_acellptr->tileptr;
     ucg0_antrmptr:=ucg0_antilptr->termsptr;
     ucg0_LowerLeft<==gxstop and ucg0_UpperLeft<==ucg0_LowerLeft and skip;
     ucg0_LowerRight<==gxstart and ucg0_UpperRight<==ucg0_LowerRight and skip;
     ucg0_LRpin<==0 and ucg0_LLpin<==ucg0_LRpin and ucg0_URpin<==ucg0_LLpin and ucg0_ULpin<==ucg0_URpin and skip;
     netchgs[0]:=0;
     ucg0_termptr:=ucg0_antrmptr;
     
     while(ucg0_termptr!=NULL)
     {
         ucg0_x:=ucg0_termptr->txpos[newaor/ 2]+ucg0_axcenter;
         ucg0_y:=ucg0_termptr->typos[newaor % 2]+ucg0_aycenter;
         ucg0_tmptr:=tearray[ucg0_termptr->cellterm];
         if(ucg0_tmptr->pinloc=1) then 
         {
             if(ucg0_tmptr->newx<ucg0_UpperLeft) then 
             {
                 ucg0_UpperLeft:=ucg0_tmptr->newx;
                 ucg0_ULpin:=ucg0_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             };
             if(ucg0_tmptr->newx>ucg0_UpperRight) then 
             {
                 ucg0_UpperRight:=ucg0_tmptr->newx;
                 ucg0_URpin:=ucg0_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             }
             
         }
         else
         {
             if(ucg0_tmptr->newx<ucg0_LowerLeft) then 
             {
                 ucg0_LowerLeft:=ucg0_tmptr->newx;
                 ucg0_LLpin:=ucg0_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             };
             if(ucg0_tmptr->newx>ucg0_LowerRight) then 
             {
                 ucg0_LowerRight:=ucg0_tmptr->newx;
                 ucg0_LRpin:=ucg0_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             }
         };
         ucg0_tmptr->xpos:=ucg0_x;
         ucg0_tmptr->ypos:=ucg0_y;
         break$<==0 and skip;
         ucg0_i:=1;
         
         while( break$=0 AND  ucg0_i<=netchgs[0])
         {
             if(ucg0_tmptr->net=netchgs[ucg0_i]) then 
             {
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then
             {
                 ucg0_i:=ucg0_i+1
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
         if(ucg0_i>netchgs[0]) then 
         {
             netchgs[(netchgs[0]+1)]:=ucg0_tmptr->net;
             netchgs[0]:=netchgs[0]+1
             
         }
         else 
         {
              skip 
         };
         ucg0_termptr:=ucg0_termptr->nextterm
         
     };
     if(netchgs[0]=0) then 
     {
         return<==1 and RValue:=0;
         skip
         
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         ucg0_leftx:=ucg0_axcenter+ucg0_antilptr->left;
         ucg0_ritex:=ucg0_axcenter+ucg0_antilptr->right;
         if(ucg0_ULpin!=0) then 
         {
             ULgrdptr:=Tgrid[ucg0_ULpin]->up->prevgrd;
             while(ULgrdptr->netptr->newx>=ucg0_leftx)
             {
                 ULgrdptr:=ULgrdptr->prevgrd
             };
             URgrdptr:=Tgrid[ucg0_URpin]->up->nextgrd;
             while(URgrdptr->netptr->newx<=ucg0_ritex)
             {
                 URgrdptr:=URgrdptr->nextgrd
             }
             
         }
         else
         {
             ULgrdptr:=NULL
         };
         if(ucg0_LLpin!=0) then 
         {
             LLgrdptr:=Tgrid[ucg0_LLpin]->down->prevgrd;
             while(LLgrdptr->netptr->newx>=ucg0_leftx)
             {
                 LLgrdptr:=LLgrdptr->prevgrd
             };
             LRgrdptr:=Tgrid[ucg0_LRpin]->down->nextgrd;
             while(LRgrdptr->netptr->newx<=ucg0_ritex)
             {
                 LRgrdptr:=LRgrdptr->nextgrd
             }
             
         }
         else
         {
             LLgrdptr:=NULL
         };
         Left_bound:=ucg0_leftx-(ucg0_ritex-ucg0_leftx);
         Rite_bound:=ucg0_ritex+(ucg0_ritex-ucg0_leftx);
         if(uneven_cell_height) then 
         {
             sub_reset1(a,RValue)
             
         }
         else 
         {
              skip 
         };
         ucg0_oldtracks:=tracks;
         uglobe(RValue);
         ucg0_topchan:=gtopChan+1;
         ucg0_botchan:=gbotChan-1;
         if(ucg0_topchan>numChans) then 
         {
             ucg0_topchan:=numChans
             
         }
         else 
         {
              skip 
         };
         if(ucg0_botchan<1) then 
         {
             ucg0_botchan:=1
             
         }
         else 
         {
              skip 
         };
         if(tracks<ucg0_oldtracks) then 
         {
             ucg0_i:=1;
             
             while(ucg0_i<=netchgs[0])
             {
                 ucg0_net:=netchgs[ucg0_i];
                 ucg0_b:=anet[ucg0_net];
                 ucg0_e:=anet[ucg0_net+1]-1;
                 ucg0_seg:=ucg0_b;
                 
                 while(ucg0_seg<=ucg0_e)
                 {
                     aNetSeg[ucg0_seg].current:=aNetSeg[ucg0_seg].ncurrent;
                     aNetSeg[ucg0_seg].swYorN:=aNetSeg[ucg0_seg].nswYorN;
                     aNetSeg[ucg0_seg].key:=aNetSeg[ucg0_seg].nkey;
                     aNetSeg[ucg0_seg].nflag:=0;
                     ucg0_segptr:=aNetSeg[ucg0_seg].top;
                     aNetSeg[ucg0_seg].top:=aNetSeg[ucg0_seg].ntop;
                     aNetSeg[ucg0_seg].ntop:=ucg0_segptr;
                     ucg0_segptr:=aNetSeg[ucg0_seg].bot;
                     aNetSeg[ucg0_seg].bot:=aNetSeg[ucg0_seg].nbot;
                     aNetSeg[ucg0_seg].nbot:=ucg0_segptr;
                     ucg0_seg:=ucg0_seg+1
                     
                 };
                 ucg0_i:=ucg0_i+1
                 
             };
             ucg0_termptr:=ucg0_antrmptr;
             
             while(ucg0_termptr!=NULL)
             {
                 ucg0_tmptr:=tearray[ucg0_termptr->cellterm];
                 ucg0_tmptr->newx:=ucg0_tmptr->xpos;
                 ucg0_tmptr->newy:=ucg0_tmptr->ypos;
                 ucg0_termptr:=ucg0_termptr->nextterm
                 
             };
             ucg0_seg:=1;
             
             while(ucg0_seg<=numSegs)
             {
                 fixnetseg[ucg0_seg]:=aNetSeg[ucg0_seg].current;
                 ucg0_seg:=ucg0_seg+1
                 
             };
             ucg0_chan:=ucg0_botchan;
             
             while(ucg0_chan<=ucg0_topchan)
             {
                 ucg0_gdptr:=Begin[ucg0_chan];
                 
                 while(ucg0_gdptr!=NULL)
                 {
                     ucg0_gdptr->tracks:=ucg0_gdptr->ntracks;
                     ucg0_gdptr->SegType:=ucg0_gdptr->nSegType;
                     ucg0_gdptr:=ucg0_gdptr->nnextgrd
                     
                 };
                 ucg0_track:=0;
                 
                 while(ucg0_track<=max_tdensity+30)
                 {
                     ucg0_denptr:=DboxHead[ucg0_chan,ucg0_track];
                     
                     while(ucg0_denptr!=NULL)
                     {
                         ucg0_denptr->next$:=ucg0_denptr->nnext;
                         ucg0_denptr->back:=ucg0_denptr->nback;
                         ucg0_denptr:=ucg0_denptr->nnext
                         
                     };
                     ucg0_track:=ucg0_track+1
                     
                 };
                 maxTrack[ucg0_chan]:=nmaxTrack[ucg0_chan];
                 ucg0_chan:=ucg0_chan+1
                 
             };
             if(ULgrdptr!=NULL) then 
             {
                 ucg0_endgrd:=URgrdptr->nnextgrd;
                 ucg0_gdptr:=ULgrdptr;
                 
                 while(ucg0_gdptr!=ucg0_endgrd)
                 {
                     ucg0_gdptr->nextgrd:=ucg0_gdptr->nnextgrd;
                     ucg0_gdptr->prevgrd:=ucg0_gdptr->nprevgrd;
                     ucg0_gdptr:=ucg0_gdptr->nnextgrd
                     
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(LLgrdptr!=NULL) then 
             {
                 ucg0_endgrd:=LRgrdptr->nnextgrd;
                 ucg0_gdptr:=LLgrdptr;
                 
                 while(ucg0_gdptr!=ucg0_endgrd)
                 {
                     ucg0_gdptr->nextgrd:=ucg0_gdptr->nnextgrd;
                     ucg0_gdptr->prevgrd:=ucg0_gdptr->nprevgrd;
                     ucg0_gdptr:=ucg0_gdptr->nnextgrd
                     
                 }
                 
             }
             else 
             {
                  skip 
             };
             ucg0_acellptr->corient:=newaor;
             return<==1 and RValue:=1;
             skip
         }
         else
         {
             ucg0_termptr:=ucg0_antrmptr;
             
             while(ucg0_termptr!=NULL)
             {
                 ucg0_tmptr:=tearray[ucg0_termptr->cellterm];
                 ucg0_tmptr->xpos:=ucg0_tmptr->newx;
                 ucg0_tmptr->ypos:=ucg0_tmptr->newy;
                 ucg0_termptr:=ucg0_termptr->nextterm
                 
             };
             ucg0_i:=1;
             
             while(ucg0_i<=netchgs[0])
             {
                 ucg0_net:=netchgs[ucg0_i];
                 ucg0_b:=anet[ucg0_net];
                 ucg0_e:=anet[ucg0_net+1]-1;
                 ucg0_seg:=ucg0_b;
                 
                 while(ucg0_seg<=ucg0_e)
                 {
                     aNetSeg[ucg0_seg].nflag:=0;
                     ucg0_seg:=ucg0_seg+1
                     
                 };
                 ucg0_i:=ucg0_i+1
                 
             };
             ucg0_seg:=1;
             
             while(ucg0_seg<=numSegs)
             {
                 aNetSeg[ucg0_seg].current:=fixnetseg[ucg0_seg];
                 ucg0_seg:=ucg0_seg+1
                 
             };
             ucg0_chan:=ucg0_botchan;
             
             while(ucg0_chan<=ucg0_topchan)
             {
                 ucg0_gdptr:=Begin[ucg0_chan];
                 
                 while(ucg0_gdptr!=NULL)
                 {
                     ucg0_gdptr->ntracks:=ucg0_gdptr->tracks;
                     ucg0_gdptr->nSegType:=ucg0_gdptr->SegType;
                     ucg0_gdptr:=ucg0_gdptr->nextgrd
                     
                 };
                 ucg0_track:=0;
                 
                 while(ucg0_track<=max_tdensity+30)
                 {
                     ucg0_denptr:=DboxHead[ucg0_chan,ucg0_track];
                     
                     while(ucg0_denptr!=NULL)
                     {
                         ucg0_denptr->nnext:=ucg0_denptr->next$;
                         ucg0_denptr->nback:=ucg0_denptr->back;
                         ucg0_denptr:=ucg0_denptr->next$
                         
                     };
                     ucg0_track:=ucg0_track+1
                     
                 };
                 nmaxTrack[ucg0_chan]:=maxTrack[ucg0_chan];
                 ucg0_chan:=ucg0_chan+1
                 
             };
             if(ULgrdptr!=NULL) then 
             {
                 ucg0_endgrd:=URgrdptr->nextgrd;
                 ucg0_gdptr:=ULgrdptr;
                 
                 while(ucg0_gdptr!=ucg0_endgrd)
                 {
                     ucg0_gdptr->nnextgrd:=ucg0_gdptr->nextgrd;
                     ucg0_gdptr->nprevgrd:=ucg0_gdptr->prevgrd;
                     ucg0_gdptr:=ucg0_gdptr->nextgrd
                     
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(LLgrdptr!=NULL) then 
             {
                 ucg0_endgrd:=LRgrdptr->nextgrd;
                 ucg0_gdptr:=LLgrdptr;
                 
                 while(ucg0_gdptr!=ucg0_endgrd)
                 {
                     ucg0_gdptr->nnextgrd:=ucg0_gdptr->nextgrd;
                     ucg0_gdptr->nprevgrd:=ucg0_gdptr->prevgrd;
                     ucg0_gdptr:=ucg0_gdptr->nextgrd
                     
                 }
                 
             }
             else 
             {
                  skip 
             };
             tracks:=ucg0_oldtracks;
             return<==1 and RValue:=0;
             skip
         }
     }
     else
     {
         skip
     }
     )
     }; 
  function sub_reset1 ( int a,int RValue )
 {
     frame(sub_reset1_row,sub_reset1_track,sub_reset1_pinloc,sub_reset1_self_reset,sub_reset1_netptr,sub_reset1_grdptr,sub_reset1_denptr,sub_reset1_headptr) and ( 
     int sub_reset1_row,sub_reset1_track,sub_reset1_pinloc,sub_reset1_self_reset and skip;
     netbox* sub_reset1_netptr and skip;
     changrdbox* sub_reset1_grdptr and skip;
     densitybox* sub_reset1_denptr,sub_reset1_headptr and skip;
     sub_reset1_row:=carray[a]->cblock;
     if(ULgrdptr!=NULL) then 
     {
         sub_reset1_grdptr:=ULgrdptr;
         
         while(sub_reset1_grdptr!=URgrdptr)
         {
             sub_reset1_netptr:=sub_reset1_grdptr->netptr;
             sub_reset1_pinloc:=sub_reset1_netptr->pinloc;
             if(sub_reset1_pinloc=1) then 
             {
                 sub_reset1_self_reset:=carray[sub_reset1_netptr->cell]->tileptr->top
                 
             }
             else
             {
                 if(sub_reset1_pinloc=-1) then 
                 {
                     sub_reset1_self_reset:=-carray[sub_reset1_netptr->cell]->tileptr->bottom
                 }
                 else
                 {
                     sub_reset1_self_reset:=0
                 }
             };
             sub_reset1_grdptr->ntracks:=sub_reset1_grdptr->ntracks-(sub_reset1_self_reset+facing_cellheight(sub_reset1_netptr->terminal,sub_reset1_netptr->row,sub_reset1_pinloc,0,RValue))/ track_spacing;
             sub_reset1_grdptr:=sub_reset1_grdptr->nextgrd
             
         }
         
     }
     else 
     {
          skip 
     };
     if(LLgrdptr!=NULL) then 
     {
         sub_reset1_grdptr:=LLgrdptr;
         
         while(sub_reset1_grdptr!=LRgrdptr)
         {
             sub_reset1_netptr:=sub_reset1_grdptr->netptr;
             sub_reset1_pinloc:=sub_reset1_netptr->pinloc;
             if(sub_reset1_pinloc=1) then 
             {
                 sub_reset1_self_reset:=carray[sub_reset1_netptr->cell]->tileptr->top
                 
             }
             else
             {
                 if(sub_reset1_pinloc=-1) then 
                 {
                     sub_reset1_self_reset:=-carray[sub_reset1_netptr->cell]->tileptr->bottom
                 }
                 else
                 {
                     sub_reset1_self_reset:=0
                 }
             };
             sub_reset1_grdptr->ntracks:=sub_reset1_grdptr->ntracks-(sub_reset1_self_reset+facing_cellheight(sub_reset1_netptr->terminal,sub_reset1_netptr->row,sub_reset1_pinloc,0,RValue))/ track_spacing;
             sub_reset1_grdptr:=sub_reset1_grdptr->nextgrd
             
         }
         
     }
     else 
     {
          skip 
     }
     )
     }; 
      int na_i,nb_i,start_i,end_i and skip;
     int startcbin,endcbin,rowleft and skip;
     int leftx,ritex and skip;
     int old_axcenter,old_bxcenter and skip;
     cellbox* acellptr,*bcellptr and skip;
 function ucgxp ( int a,int b,int anxcenter,int bnxcenter,int RValue )
 {
     frame(ucgxp_cellptr,ucgxp_tmptr,ucgxp_atileptr,ucgxp_btileptr,ucgxp_termptr,ucgxp_atermptr,ucgxp_btermptr,ucgxp_segptr,ucgxp_denptr,ucgxp_gdptr,ucgxp_endgrd,ucgxp_oldtracks,ucgxp_track,ucgxp_x,ucgxp_row,ucgxp_aorient,ucgxp_borient,ucgxp_bin,ucgxp_bin_rite_edge,ucgxp_crite,ucgxp_i,ucgxp_bb,ucgxp_e,ucgxp_seg,ucgxp_chan,ucgxp_net,ucgxp_UpperLeft,ucgxp_UpperRight,ucgxp_LowerLeft,ucgxp_LowerRight,ucgxp_ULpin,ucgxp_URpin,ucgxp_LLpin,ucgxp_LRpin,ucgxp_topchan,ucgxp_botchan,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     cellbox* ucgxp_cellptr and skip;
     netbox* ucgxp_tmptr and skip;
     tilebox* ucgxp_atileptr,*ucgxp_btileptr and skip;
     termbox* ucgxp_termptr,*ucgxp_atermptr,*ucgxp_btermptr and skip;
     segbox* ucgxp_segptr and skip;
     densitybox* ucgxp_denptr and skip;
     changrdbox* ucgxp_gdptr,*ucgxp_endgrd and skip;
     int ucgxp_oldtracks,ucgxp_track,ucgxp_x,ucgxp_row and skip;
     int ucgxp_aorient,ucgxp_borient,ucgxp_bin,ucgxp_bin_rite_edge,ucgxp_crite and skip;
     int ucgxp_i,ucgxp_bb,ucgxp_e,ucgxp_seg,ucgxp_chan,ucgxp_net and skip;
     int ucgxp_UpperLeft,ucgxp_UpperRight,ucgxp_LowerLeft,ucgxp_LowerRight and skip;
     int ucgxp_ULpin,ucgxp_URpin,ucgxp_LLpin,ucgxp_LRpin and skip;
     int ucgxp_topchan,ucgxp_botchan and skip;
     acellptr:=carray[a];
     ucgxp_aorient:=acellptr->corient/ 2;
     ucgxp_atileptr:=acellptr->tileptr;
     ucgxp_atermptr:=ucgxp_atileptr->termsptr;
     bcellptr:=carray[b];
     ucgxp_borient:=bcellptr->corient/ 2;
     ucgxp_btileptr:=bcellptr->tileptr;
     ucgxp_btermptr:=ucgxp_btileptr->termsptr;
     ucgxp_LowerLeft<==gxstop and ucgxp_UpperLeft<==ucgxp_LowerLeft and skip;
     ucgxp_LowerRight<==gxstart and ucgxp_UpperRight<==ucgxp_LowerRight and skip;
     ucgxp_LRpin<==0 and ucgxp_LLpin<==ucgxp_LRpin and ucgxp_URpin<==ucgxp_LLpin and ucgxp_ULpin<==ucgxp_URpin and skip;
     netchgs[0]:=0;
     ucgxp_termptr:=ucgxp_atermptr;
     
     while(ucgxp_termptr!=NULL)
     {
         ucgxp_x:=ucgxp_termptr->txpos[ucgxp_aorient]+anxcenter;
         ucgxp_tmptr:=tearray[ucgxp_termptr->cellterm];
         if(ucgxp_tmptr->pinloc=1) then 
         {
             if(ucgxp_tmptr->newx<ucgxp_UpperLeft) then 
             {
                 ucgxp_UpperLeft:=ucgxp_tmptr->newx;
                 ucgxp_ULpin:=ucgxp_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             };
             if(ucgxp_tmptr->newx>ucgxp_UpperRight) then 
             {
                 ucgxp_UpperRight:=ucgxp_tmptr->newx;
                 ucgxp_URpin:=ucgxp_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             }
             
         }
         else
         {
             if(ucgxp_tmptr->newx<ucgxp_LowerLeft) then 
             {
                 ucgxp_LowerLeft:=ucgxp_tmptr->newx;
                 ucgxp_LLpin:=ucgxp_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             };
             if(ucgxp_tmptr->newx>ucgxp_LowerRight) then 
             {
                 ucgxp_LowerRight:=ucgxp_tmptr->newx;
                 ucgxp_LRpin:=ucgxp_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             }
         };
         ucgxp_tmptr->xpos:=ucgxp_x;
         break$<==0 and skip;
         ucgxp_i:=1;
         
         while( break$=0 AND  ucgxp_i<=netchgs[0])
         {
             if(ucgxp_tmptr->net=netchgs[ucgxp_i]) then 
             {
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then
             {
                 ucgxp_i:=ucgxp_i+1
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
         if(ucgxp_i>netchgs[0]) then 
         {
             netchgs[(netchgs[0]+1)]:=ucgxp_tmptr->net;
             netchgs[0]:=netchgs[0]+1
             
         }
         else 
         {
              skip 
         };
         ucgxp_termptr:=ucgxp_termptr->nextterm
         
     };
     ucgxp_termptr:=ucgxp_btermptr;
     
     while(ucgxp_termptr!=NULL)
     {
         ucgxp_x:=ucgxp_termptr->txpos[ucgxp_borient]+bnxcenter;
         ucgxp_tmptr:=tearray[ucgxp_termptr->cellterm];
         if(ucgxp_tmptr->pinloc=1) then 
         {
             if(ucgxp_tmptr->newx<ucgxp_UpperLeft) then 
             {
                 ucgxp_UpperLeft:=ucgxp_tmptr->newx;
                 ucgxp_ULpin:=ucgxp_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             };
             if(ucgxp_tmptr->newx>ucgxp_UpperRight) then 
             {
                 ucgxp_UpperRight:=ucgxp_tmptr->newx;
                 ucgxp_URpin:=ucgxp_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             }
             
         }
         else
         {
             if(ucgxp_tmptr->newx<ucgxp_LowerLeft) then 
             {
                 ucgxp_LowerLeft:=ucgxp_tmptr->newx;
                 ucgxp_LLpin:=ucgxp_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             };
             if(ucgxp_tmptr->newx>ucgxp_LowerRight) then 
             {
                 ucgxp_LowerRight:=ucgxp_tmptr->newx;
                 ucgxp_LRpin:=ucgxp_termptr->cellterm
                 
             }
             else 
             {
                  skip 
             }
         };
         ucgxp_tmptr->xpos:=ucgxp_x;
         break$<==0 and skip;
         ucgxp_i:=1;
         
         while( break$=0 AND  ucgxp_i<=netchgs[0])
         {
             if(ucgxp_tmptr->net=netchgs[ucgxp_i]) then 
             {
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then
             {
                 ucgxp_i:=ucgxp_i+1
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
         if(ucgxp_i>netchgs[0]) then 
         {
             netchgs[(netchgs[0]+1)]:=ucgxp_tmptr->net;
             netchgs[0]:=netchgs[0]+1
             
         }
         else 
         {
              skip 
         };
         ucgxp_termptr:=ucgxp_termptr->nextterm
         
     };
     if(netchgs[0]=0) then 
     {
         return<==1 and RValue:=0;
         skip
         
     }
     else 
     {
          skip 
     };
     if(return=0)   then 
     {
         if(anxcenter<bnxcenter) then 
         {
             leftx:=anxcenter+ucgxp_atileptr->left;
             ritex:=bnxcenter+ucgxp_btileptr->right
             
         }
         else
         {
             leftx:=bnxcenter+ucgxp_btileptr->left;
             ritex:=anxcenter+ucgxp_atileptr->right
         };
         if(ucgxp_ULpin!=0) then 
         {
             ULgrdptr:=Tgrid[ucgxp_ULpin]->up->prevgrd;
             while(ULgrdptr->netptr->newx>=leftx)
             {
                 ULgrdptr:=ULgrdptr->prevgrd
             };
             URgrdptr:=Tgrid[ucgxp_URpin]->up->nextgrd;
             while(URgrdptr->netptr->newx<=ritex)
             {
                 URgrdptr:=URgrdptr->nextgrd
             }
             
         }
         else
         {
             ULgrdptr:=NULL
         };
         if(ucgxp_LLpin!=0) then 
         {
             LLgrdptr:=Tgrid[ucgxp_LLpin]->down->prevgrd;
             while(LLgrdptr->netptr->newx>=leftx)
             {
                 LLgrdptr:=LLgrdptr->prevgrd
             };
             LRgrdptr:=Tgrid[ucgxp_LRpin]->down->nextgrd;
             while(LRgrdptr->netptr->newx<=ritex)
             {
                 LRgrdptr:=LRgrdptr->nextgrd
             }
             
         }
         else
         {
             LLgrdptr:=NULL
         };
         Left_bound:=leftx-(ritex-leftx);
         Rite_bound:=ritex+(ritex-leftx);
         if(uneven_cell_height) then 
         {
             sub_reset2(a,b,anxcenter,bnxcenter,RValue)
             
         }
         else 
         {
              skip 
         };
         ucgxp_oldtracks:=tracks;
         uglobe(RValue);
         ucgxp_topchan:=gtopChan+1;
         ucgxp_botchan:=gbotChan-1;
         if(ucgxp_topchan>numChans) then 
         {
             ucgxp_topchan:=numChans
             
         }
         else 
         {
              skip 
         };
         if(ucgxp_botchan<1) then 
         {
             ucgxp_botchan:=1
             
         }
         else 
         {
              skip 
         };
         if(tracks<=ucgxp_oldtracks) then 
         {
             if(!uneven_cell_height) then 
             {
                 acellptr->cxcenter:=anxcenter;
                 bcellptr->cxcenter:=bnxcenter
                 
             }
             else 
             {
                  skip 
             };
             ucgxp_termptr:=ucgxp_atermptr;
             
             while(ucgxp_termptr!=NULL)
             {
                 ucgxp_tmptr:=tearray[ucgxp_termptr->cellterm];
                 ucgxp_tmptr->newx:=ucgxp_tmptr->xpos;
                 ucgxp_termptr:=ucgxp_termptr->nextterm
                 
             };
             ucgxp_termptr:=ucgxp_btermptr;
             
             while(ucgxp_termptr!=NULL)
             {
                 ucgxp_tmptr:=tearray[ucgxp_termptr->cellterm];
                 ucgxp_tmptr->newx:=ucgxp_tmptr->xpos;
                 ucgxp_termptr:=ucgxp_termptr->nextterm
                 
             };
             ucgxp_i:=1;
             
             while(ucgxp_i<=netchgs[0])
             {
                 ucgxp_net:=netchgs[ucgxp_i];
                 ucgxp_bb:=anet[ucgxp_net];
                 ucgxp_e:=anet[ucgxp_net+1]-1;
                 ucgxp_seg:=ucgxp_bb;
                 
                 while(ucgxp_seg<=ucgxp_e)
                 {
                     aNetSeg[ucgxp_seg].current:=aNetSeg[ucgxp_seg].ncurrent;
                     aNetSeg[ucgxp_seg].swYorN:=aNetSeg[ucgxp_seg].nswYorN;
                     aNetSeg[ucgxp_seg].key:=aNetSeg[ucgxp_seg].nkey;
                     aNetSeg[ucgxp_seg].nflag:=0;
                     ucgxp_segptr:=aNetSeg[ucgxp_seg].top;
                     aNetSeg[ucgxp_seg].top:=aNetSeg[ucgxp_seg].ntop;
                     aNetSeg[ucgxp_seg].ntop:=ucgxp_segptr;
                     ucgxp_segptr:=aNetSeg[ucgxp_seg].bot;
                     aNetSeg[ucgxp_seg].bot:=aNetSeg[ucgxp_seg].nbot;
                     aNetSeg[ucgxp_seg].nbot:=ucgxp_segptr;
                     ucgxp_seg:=ucgxp_seg+1
                     
                 };
                 ucgxp_i:=ucgxp_i+1
                 
             };
             ucgxp_seg:=1;
             
             while(ucgxp_seg<=numSegs)
             {
                 fixnetseg[ucgxp_seg]:=aNetSeg[ucgxp_seg].current;
                 ucgxp_seg:=ucgxp_seg+1
                 
             };
             ucgxp_chan:=ucgxp_botchan;
             
             while(ucgxp_chan<=ucgxp_topchan)
             {
                 ucgxp_gdptr:=Begin[ucgxp_chan];
                 
                 while(ucgxp_gdptr!=NULL)
                 {
                     ucgxp_gdptr->tracks:=ucgxp_gdptr->ntracks;
                     ucgxp_gdptr->SegType:=ucgxp_gdptr->nSegType;
                     ucgxp_gdptr:=ucgxp_gdptr->nnextgrd
                     
                 };
                 ucgxp_track:=0;
                 
                 while(ucgxp_track<=max_tdensity+30)
                 {
                     ucgxp_denptr:=DboxHead[ucgxp_chan,ucgxp_track];
                     
                     while(ucgxp_denptr!=NULL)
                     {
                         ucgxp_denptr->next$:=ucgxp_denptr->nnext;
                         ucgxp_denptr->back:=ucgxp_denptr->nback;
                         ucgxp_denptr:=ucgxp_denptr->nnext
                         
                     };
                     ucgxp_track:=ucgxp_track+1
                     
                 };
                 maxTrack[ucgxp_chan]:=nmaxTrack[ucgxp_chan];
                 ucgxp_chan:=ucgxp_chan+1
                 
             };
             if(ULgrdptr!=NULL) then 
             {
                 ucgxp_endgrd:=URgrdptr->nnextgrd;
                 ucgxp_gdptr:=ULgrdptr;
                 
                 while(ucgxp_gdptr!=ucgxp_endgrd)
                 {
                     ucgxp_gdptr->nextgrd:=ucgxp_gdptr->nnextgrd;
                     ucgxp_gdptr->prevgrd:=ucgxp_gdptr->nprevgrd;
                     ucgxp_gdptr:=ucgxp_gdptr->nnextgrd
                     
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(LLgrdptr!=NULL) then 
             {
                 ucgxp_endgrd:=LRgrdptr->nnextgrd;
                 ucgxp_gdptr:=LLgrdptr;
                 
                 while(ucgxp_gdptr!=ucgxp_endgrd)
                 {
                     ucgxp_gdptr->nextgrd:=ucgxp_gdptr->nnextgrd;
                     ucgxp_gdptr->prevgrd:=ucgxp_gdptr->nprevgrd;
                     ucgxp_gdptr:=ucgxp_gdptr->nnextgrd
                     
                 }
                 
             }
             else 
             {
                  skip 
             };
             return<==1 and RValue:=1;
             skip
         }
         else
         {
             if(uneven_cell_height) then 
             {
                 acellptr->cxcenter:=old_axcenter;
                 bcellptr->cxcenter:=old_bxcenter
                 
             }
             else 
             {
                  skip 
             };
             ucgxp_termptr:=ucgxp_atermptr;
             
             while(ucgxp_termptr!=NULL)
             {
                 ucgxp_tmptr:=tearray[ucgxp_termptr->cellterm];
                 ucgxp_tmptr->xpos:=ucgxp_tmptr->newx;
                 ucgxp_termptr:=ucgxp_termptr->nextterm
                 
             };
             ucgxp_termptr:=ucgxp_btermptr;
             
             while(ucgxp_termptr!=NULL)
             {
                 ucgxp_tmptr:=tearray[ucgxp_termptr->cellterm];
                 ucgxp_tmptr->xpos:=ucgxp_tmptr->newx;
                 ucgxp_termptr:=ucgxp_termptr->nextterm
                 
             };
             ucgxp_i:=1;
             
             while(ucgxp_i<=netchgs[0])
             {
                 ucgxp_net:=netchgs[ucgxp_i];
                 ucgxp_bb:=anet[ucgxp_net];
                 ucgxp_e:=anet[ucgxp_net+1]-1;
                 ucgxp_seg:=ucgxp_bb;
                 
                 while(ucgxp_seg<=ucgxp_e)
                 {
                     aNetSeg[ucgxp_seg].nflag:=0;
                     ucgxp_seg:=ucgxp_seg+1
                     
                 };
                 ucgxp_i:=ucgxp_i+1
                 
             };
             ucgxp_seg:=1;
             
             while(ucgxp_seg<=numSegs)
             {
                 aNetSeg[ucgxp_seg].current:=fixnetseg[ucgxp_seg];
                 ucgxp_seg:=ucgxp_seg+1
                 
             };
             ucgxp_chan:=ucgxp_botchan;
             
             while(ucgxp_chan<=ucgxp_topchan)
             {
                 ucgxp_gdptr:=Begin[ucgxp_chan];
                 
                 while(ucgxp_gdptr!=NULL)
                 {
                     ucgxp_gdptr->ntracks:=ucgxp_gdptr->tracks;
                     ucgxp_gdptr->nSegType:=ucgxp_gdptr->SegType;
                     ucgxp_gdptr:=ucgxp_gdptr->nextgrd
                     
                 };
                 ucgxp_track:=0;
                 
                 while(ucgxp_track<=max_tdensity+30)
                 {
                     ucgxp_denptr:=DboxHead[ucgxp_chan,ucgxp_track];
                     
                     while(ucgxp_denptr!=NULL)
                     {
                         ucgxp_denptr->nnext:=ucgxp_denptr->next$;
                         ucgxp_denptr->nback:=ucgxp_denptr->back;
                         ucgxp_denptr:=ucgxp_denptr->next$
                         
                     };
                     ucgxp_track:=ucgxp_track+1
                     
                 };
                 nmaxTrack[ucgxp_chan]:=maxTrack[ucgxp_chan];
                 ucgxp_chan:=ucgxp_chan+1
                 
             };
             if(ULgrdptr!=NULL) then 
             {
                 ucgxp_endgrd:=URgrdptr->nextgrd;
                 ucgxp_gdptr:=ULgrdptr;
                 
                 while(ucgxp_gdptr!=ucgxp_endgrd)
                 {
                     ucgxp_gdptr->nnextgrd:=ucgxp_gdptr->nextgrd;
                     ucgxp_gdptr->nprevgrd:=ucgxp_gdptr->prevgrd;
                     ucgxp_gdptr:=ucgxp_gdptr->nextgrd
                     
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(LLgrdptr!=NULL) then 
             {
                 ucgxp_endgrd:=LRgrdptr->nextgrd;
                 ucgxp_gdptr:=LLgrdptr;
                 
                 while(ucgxp_gdptr!=ucgxp_endgrd)
                 {
                     ucgxp_gdptr->nnextgrd:=ucgxp_gdptr->nextgrd;
                     ucgxp_gdptr->nprevgrd:=ucgxp_gdptr->prevgrd;
                     ucgxp_gdptr:=ucgxp_gdptr->nextgrd
                     
                 }
                 
             }
             else 
             {
                  skip 
             };
             tracks:=ucgxp_oldtracks;
             if(uneven_cell_height) then 
             {
                 ucgxp_row:=carray[a]->cblock;
                 pairArray[ucgxp_row,nb_i]:=a;
                 pairArray[ucgxp_row,na_i]:=b;
                 ucgxp_bin:=startcbin;
                 ucgxp_bin_rite_edge:=rowleft+(ucgxp_bin-1)*cedge_binwidth;
                 ucgxp_bin:=ucgxp_bin-1;
                 ucgxp_i:=start_i;
                 
                 while(ucgxp_i<=end_i)
                 {
                     ucgxp_cellptr:=carray[pairArray[ucgxp_row,ucgxp_i]];
                     ucgxp_crite:=ucgxp_cellptr->cxcenter+ucgxp_cellptr->tileptr->right;
                     while(ucgxp_bin_rite_edge<ucgxp_crite)
                     {
                         cedgebin[ucgxp_row,(ucgxp_bin+1)]:=ucgxp_i;
                         ucgxp_bin:=ucgxp_bin+1;
                         ucgxp_bin_rite_edge:=ucgxp_bin_rite_edge+cedge_binwidth
                     };
                     ucgxp_i:=ucgxp_i+1
                     
                 }
                 
             }
             else 
             {
                  skip 
             };
             return<==1 and RValue:=0;
             skip
         }
     }
     else
     {
         skip
     }
     )
     }; 
  function sub_reset2 ( int a,int b,int anxcenter,int bnxcenter,int RValue )
 {
     frame(sub_reset2_row,sub_reset2_bin,sub_reset2_track,sub_reset2_Aray,sub_reset2_i,sub_reset2_cell,sub_reset2_bin_rite_edge,sub_reset2_crite,sub_reset2_pinloc,sub_reset2_self_reset,sub_reset2_netptr,sub_reset2_cellptr,sub_reset2_grdptr,sub_reset2_denptr,sub_reset2_headptr) and ( 
     int sub_reset2_row,sub_reset2_bin,sub_reset2_track,*sub_reset2_Aray,sub_reset2_i,sub_reset2_cell and skip;
     int sub_reset2_bin_rite_edge,sub_reset2_crite,sub_reset2_pinloc,sub_reset2_self_reset and skip;
     netbox* sub_reset2_netptr and skip;
     cellbox* sub_reset2_cellptr and skip;
     changrdbox* sub_reset2_grdptr and skip;
     densitybox* sub_reset2_denptr,*sub_reset2_headptr and skip;
     sub_reset2_row:=carray[a]->cblock;
     if(ULgrdptr!=NULL) then 
     {
         sub_reset2_grdptr:=ULgrdptr;
         
         while(sub_reset2_grdptr!=URgrdptr)
         {
             sub_reset2_netptr:=sub_reset2_grdptr->netptr;
             sub_reset2_pinloc:=sub_reset2_netptr->pinloc;
             if(sub_reset2_pinloc=1) then 
             {
                 sub_reset2_self_reset:=carray[sub_reset2_netptr->cell]->tileptr->top
                 
             }
             else
             {
                 if(sub_reset2_pinloc=-1) then 
                 {
                     sub_reset2_self_reset:=-carray[sub_reset2_netptr->cell]->tileptr->bottom
                 }
                 else
                 {
                     sub_reset2_self_reset:=0
                 }
             };
             sub_reset2_grdptr->ntracks:=sub_reset2_grdptr->ntracks-(sub_reset2_self_reset+facing_cellheight(sub_reset2_netptr->terminal,sub_reset2_netptr->row,sub_reset2_pinloc,0,RValue))/ track_spacing;
             sub_reset2_grdptr:=sub_reset2_grdptr->nextgrd
             
         }
         
     }
     else 
     {
          skip 
     };
     if(LLgrdptr!=NULL) then 
     {
         sub_reset2_grdptr:=LLgrdptr;
         
         while(sub_reset2_grdptr!=LRgrdptr)
         {
             sub_reset2_netptr:=sub_reset2_grdptr->netptr;
             sub_reset2_pinloc:=sub_reset2_netptr->pinloc;
             if(sub_reset2_pinloc=1) then 
             {
                 sub_reset2_self_reset:=carray[sub_reset2_netptr->cell]->tileptr->top
                 
             }
             else
             {
                 if(sub_reset2_pinloc=-1) then 
                 {
                     sub_reset2_self_reset:=-carray[sub_reset2_netptr->cell]->tileptr->bottom
                 }
                 else
                 {
                     sub_reset2_self_reset:=0
                 }
             };
             sub_reset2_grdptr->ntracks:=sub_reset2_grdptr->ntracks-(sub_reset2_self_reset+facing_cellheight(sub_reset2_netptr->terminal,sub_reset2_netptr->row,sub_reset2_pinloc,0,RValue))/ track_spacing;
             sub_reset2_grdptr:=sub_reset2_grdptr->nextgrd
             
         }
         
     }
     else 
     {
          skip 
     };
     old_axcenter:=acellptr->cxcenter;
     old_bxcenter:=bcellptr->cxcenter;
     acellptr->cxcenter:=anxcenter;
     bcellptr->cxcenter:=bnxcenter;
     sub_reset2_Aray:=pairArray[sub_reset2_row];
     rowleft:=carray[sub_reset2_Aray[1]]->cxcenter+carray[sub_reset2_Aray[1]]->tileptr->left;
     startcbin:=(leftx-rowleft)/ cedge_binwidth+1;
     endcbin:=(ritex-rowleft)/ cedge_binwidth+1;
     start_i:=cedgebin[sub_reset2_row,startcbin];
     end_i:=cedgebin[sub_reset2_row,endcbin];
     sub_reset2_bin:=startcbin;
     sub_reset2_i:=start_i;
     sub_reset2_cell:=sub_reset2_Aray[sub_reset2_i];
     
     while(sub_reset2_cell!=a)
     {
	     sub_reset2_i:=sub_reset2_i+1;
         sub_reset2_cell:=sub_reset2_Aray[sub_reset2_i]
         
     };
     if(anxcenter<bnxcenter) then 
     {
         na_i:=sub_reset2_i-1;
         nb_i:=sub_reset2_i
         
     }
     else
     {
         na_i:=sub_reset2_i+1;
         nb_i:=sub_reset2_i
     };
     sub_reset2_Aray[na_i]:=a;
     sub_reset2_Aray[nb_i]:=b;
     sub_reset2_bin_rite_edge:=rowleft+(sub_reset2_bin-1)*cedge_binwidth;
     sub_reset2_bin:=sub_reset2_bin-1;
     sub_reset2_i:=start_i;
     
     while(sub_reset2_i<=end_i)
     {
         sub_reset2_cellptr:=carray[sub_reset2_Aray[sub_reset2_i]];
         sub_reset2_crite:=sub_reset2_cellptr->cxcenter+sub_reset2_cellptr->tileptr->right;
         while(sub_reset2_bin_rite_edge<sub_reset2_crite)
         {
             cedgebin[sub_reset2_row,(sub_reset2_bin+1)]:=sub_reset2_i;
             sub_reset2_bin:=sub_reset2_bin+1;
             sub_reset2_bin_rite_edge:=sub_reset2_bin_rite_edge+cedge_binwidth
         };
         sub_reset2_i:=sub_reset2_i+1
         
     }
     )
     }; 
  function uclosepns ( int net )
 {
     frame(uclosepns_pin,uclosepns_pin1,uclosepns_pin2,uclosepns_minP1,uclosepns_minP2,uclosepns_minX,uclosepns_sepT,uclosepns_sepB,uclosepns_edge,uclosepns_group1,uclosepns_group2,uclosepns_block1,uclosepns_block2,uclosepns_p1,uclosepns_p2,uclosepns_Tleft,uclosepns_Tright,uclosepns_Bleft,uclosepns_Bright,uclosepns_minTop,uclosepns_minBottom,uclosepns_maxTpin,uclosepns_maxBpin,uclosepns_otherTpin,uclosepns_otherBpin,uclosepns_maxTop,uclosepns_maxBottom,uclosepns_segIndex,uclosepns_k_left,uclosepns_k_right,uclosepns_super_edge,uclosepns_e1,uclosepns_e2,uclosepns_g1,uclosepns_g2,uclosepns_next_edge,uclosepns_next_g,uclosepns_save_count,uclosepns_key_flag,uclosepns_key_count,uclosepns_fault_line,uclosepns_channel,uclosepns_left,uclosepns_right,uclosepns_ltop,uclosepns_rtop,uclosepns_lbot,uclosepns_rbot,uclosepns_pArray1,uclosepns_pArray2,uclosepns_pArray,uclosepns_tmp_ptr,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     int uclosepns_pin,uclosepns_pin1,uclosepns_pin2,uclosepns_minP1,uclosepns_minP2,uclosepns_minX,uclosepns_sepT,uclosepns_sepB,uclosepns_edge and skip;
     int uclosepns_group1,uclosepns_group2,uclosepns_block1,uclosepns_block2,uclosepns_p1,uclosepns_p2 and skip;
     int uclosepns_Tleft,uclosepns_Tright,uclosepns_Bleft,uclosepns_Bright and skip;
     int uclosepns_minTop,uclosepns_minBottom,uclosepns_maxTpin,uclosepns_maxBpin,uclosepns_otherTpin and skip;
     int uclosepns_otherBpin,uclosepns_maxTop,uclosepns_maxBottom,uclosepns_segIndex and skip;
     int uclosepns_k_left,uclosepns_k_right,uclosepns_super_edge and skip;
     int uclosepns_e1,uclosepns_e2,uclosepns_g1,uclosepns_g2,uclosepns_next_edge,uclosepns_next_g,uclosepns_save_count and skip;
     int uclosepns_key_flag,uclosepns_key_count,uclosepns_fault_line and skip;
     int uclosepns_channel,uclosepns_left,uclosepns_right and skip;
     int uclosepns_ltop,uclosepns_rtop,uclosepns_lbot,uclosepns_rbot and skip;
     csPinBox *uclosepns_pArray1,*uclosepns_pArray2,*uclosepns_pArray and skip;
     segbox* uclosepns_tmp_ptr and skip;
     uclosepns_key_count:=0;
     uclosepns_super_edge:=0;
     uclosepns_segIndex:=anet[net]-1;
     uclosepns_fault_line:=anet[net+1];
     break$<==0 and skip;
     while( break$=0 AND  true)
     {
         if(uclosepns_key_count>0) then 
         {
             uclosepns_edge:=key_queue[uclosepns_key_count];
             uclosepns_key_count:=uclosepns_key_count-1;
             uclosepns_group1:=edgeArray[uclosepns_edge].group1;
             uclosepns_k_left:=groupArray[uclosepns_group1].aveX;
             uclosepns_k_right:=uclosepns_k_left;
             uclosepns_key_flag:=uclosepns_save_count
             
         }
         else
         {
             break$<==0 and skip;
             while( break$=0 AND  (uclosepns_super_edge+1)<=numEdges)
             {
                 uclosepns_super_edge:=uclosepns_super_edge+1;
                 continue<==0 and skip;
                 if(edgeArray[uclosepns_super_edge].marked=0) then 
                 {
                     continue<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     if(edgeArray[uclosepns_super_edge].done=0) then 
                     {
                         break$<==1 and skip
                          
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     skip
                 }
             };
			 uclosepns_super_edge:=uclosepns_super_edge+1;
             break$<==0 and skip;
             continue<==0 and skip;
             if(uclosepns_super_edge>numEdges) then 
             {
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then
             {
                 uclosepns_edge:=uclosepns_super_edge;
                 uclosepns_key_flag:=0
             }
             else
             {
                 skip 
                 } 
             };
             if(break$=0)  then 
             {
                 uclosepns_segIndex:=uclosepns_segIndex+1;
                 if(uclosepns_segIndex>=uclosepns_fault_line) then 
                 {
                     output ("Serious fault detected in function: uclosepns():") and skip;
                     output ("   Net:",net,"\n") and skip;
                     fflush(stdout) and skip
                     
                 }
                 else 
                 {
                      skip 
                 };
                 aNetSeg[uclosepns_segIndex].nflag:=1;
                 uclosepns_maxTop:=-1000000000;
                 uclosepns_maxBottom:=-1000000000;
                 uclosepns_maxTpin:=0;
                 uclosepns_maxBpin:=0;
                 uclosepns_group1:=edgeArray[uclosepns_edge].group1;
                 uclosepns_pArray1:=groupArray[uclosepns_group1].pinArray;
                 uclosepns_block1:=groupArray[uclosepns_group1].block;
                 uclosepns_group2:=edgeArray[uclosepns_edge].group2;
                 uclosepns_pArray2:=groupArray[uclosepns_group2].pinArray;
                 uclosepns_block2:=groupArray[uclosepns_group2].block;
                 if(edgeArray[uclosepns_edge].poison=0 AND uclosepns_key_flag=0) then 
                 {
                     uclosepns_save_count:=uclosepns_segIndex;
                     edgeArray[uclosepns_edge].done:=1;
                     uclosepns_key_flag:=uclosepns_save_count;
                     uclosepns_e1:=uclosepns_edge;
                     uclosepns_g1:=edgeArray[uclosepns_e1].group1;
                     break$<==0 and skip;
                     while( break$=0 AND  true)
                     {
                         if(groupArray[uclosepns_g1].poison=1) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             if(groupArray[uclosepns_g1].edge1=uclosepns_e1) then 
                             {
                                 uclosepns_next_edge:=groupArray[uclosepns_g1].edge2
                                 
                             }
                             else
                             {
                                 uclosepns_next_edge:=groupArray[uclosepns_g1].edge1
                             };
                             if(uclosepns_next_edge=0) then 
                             {
                                 break$<==1 and skip
                                  
                             }
                             else 
                             {
                                  skip 
                             };
                             if(break$=0)   then
                             {
                                 uclosepns_next_g:=edgeArray[uclosepns_next_edge].group1;
                                 if(uclosepns_next_g=uclosepns_g1) then 
                                 {
                                     uclosepns_g1:=edgeArray[uclosepns_next_edge].group2
                                     
                                 }
                                 else
                                 {
                                     uclosepns_g1:=uclosepns_next_g
                                 };
                                 uclosepns_e1:=uclosepns_next_edge;
                                 edgeArray[uclosepns_e1].done:=1;
                                 key_queue[(uclosepns_key_count+1)]:=uclosepns_e1;
                                 uclosepns_key_count:=uclosepns_key_count+1
                             }
                             else
                             {
                                 skip
                             }
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     break$<==0 and skip;
                     uclosepns_e2:=uclosepns_edge;
                     uclosepns_g2:=edgeArray[uclosepns_e2].group2;
                     break$<==0 and skip;
                     while( break$=0 AND  true)
                     {
                         if(groupArray[uclosepns_g2].poison=1) then 
                         {
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             if(groupArray[uclosepns_g2].edge1=uclosepns_e2) then 
                             {
                                 uclosepns_next_edge:=groupArray[uclosepns_g2].edge2
                                 
                             }
                             else
                             {
                                 uclosepns_next_edge:=groupArray[uclosepns_g2].edge1
                             };
                             if(uclosepns_next_edge=0) then 
                             {
                                 break$<==1 and skip
                                  
                             }
                             else 
                             {
                                  skip 
                             };
                             if(break$=0)   then
                             {
                                 uclosepns_next_g:=edgeArray[uclosepns_next_edge].group1;
                                 if(uclosepns_next_g=uclosepns_g2) then 
                                 {
                                     uclosepns_g2:=edgeArray[uclosepns_next_edge].group2
                                     
                                 }
                                 else
                                 {
                                     uclosepns_g2:=uclosepns_next_g
                                 };
                                 uclosepns_e2:=uclosepns_next_edge;
                                 edgeArray[uclosepns_e2].done:=1;
                                 key_queue[(uclosepns_key_count+1)]:=uclosepns_e2;
                                 uclosepns_key_count:=uclosepns_key_count+1
                             }
                             else
                             {
                                 skip
                             }
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     break$<==0 and skip;
                     if(groupArray[uclosepns_g1].aveX<=groupArray[uclosepns_g2].aveX) then 
                     {
                         uclosepns_k_left:=groupArray[uclosepns_g1].aveX;
                         uclosepns_k_right:=groupArray[uclosepns_g2].aveX;
                         uclosepns_pArray:=groupArray[uclosepns_g1].pinArray;
                         uclosepns_pin:=1;
                         
                         while(uclosepns_pin<=groupArray[uclosepns_g1].numPins)
                         {
                             if(uclosepns_pArray[uclosepns_pin].top=1 OR uclosepns_pArray[uclosepns_pin].top=0) then 
                             {
                                 uclosepns_ltop:=uclosepns_pArray[uclosepns_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(uclosepns_pArray[uclosepns_pin].top=-1 OR uclosepns_pArray[uclosepns_pin].top=0) then 
                             {
                                 uclosepns_lbot:=uclosepns_pArray[uclosepns_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             uclosepns_pin:=uclosepns_pin+1
                             
                         };
                         uclosepns_pArray:=groupArray[uclosepns_g2].pinArray;
                         uclosepns_pin:=1;
                         
                         while(uclosepns_pin<=groupArray[uclosepns_g2].numPins)
                         {
                             if(uclosepns_pArray[uclosepns_pin].top=1 OR uclosepns_pArray[uclosepns_pin].top=0) then 
                             {
                                 uclosepns_rtop:=uclosepns_pArray[uclosepns_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(uclosepns_pArray[uclosepns_pin].top=-1 OR uclosepns_pArray[uclosepns_pin].top=0) then 
                             {
                                 uclosepns_rbot:=uclosepns_pArray[uclosepns_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             uclosepns_pin:=uclosepns_pin+1
                             
                         }
                     }
                     else
                     {
                         uclosepns_k_left:=groupArray[uclosepns_g2].aveX;
                         uclosepns_k_right:=groupArray[uclosepns_g1].aveX;
                         uclosepns_pArray:=groupArray[uclosepns_g2].pinArray;
                         uclosepns_pin:=1;
                         
                         while(uclosepns_pin<=groupArray[uclosepns_g2].numPins)
                         {
                             if(uclosepns_pArray[uclosepns_pin].top=1 OR uclosepns_pArray[uclosepns_pin].top=0) then 
                             {
                                 uclosepns_ltop:=uclosepns_pArray[uclosepns_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(uclosepns_pArray[uclosepns_pin].top=-1 OR uclosepns_pArray[uclosepns_pin].top=0) then 
                             {
                                 uclosepns_lbot:=uclosepns_pArray[uclosepns_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             uclosepns_pin:=uclosepns_pin+1
                             
                         };
                         uclosepns_pArray:=groupArray[uclosepns_g1].pinArray;
                         uclosepns_pin:=1;
                         
                         while(uclosepns_pin<=groupArray[uclosepns_g1].numPins)
                         {
                             if(uclosepns_pArray[uclosepns_pin].top=1 OR uclosepns_pArray[uclosepns_pin].top=0) then 
                             {
                                 uclosepns_rtop:=uclosepns_pArray[uclosepns_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(uclosepns_pArray[uclosepns_pin].top=-1 OR uclosepns_pArray[uclosepns_pin].top=0) then 
                             {
                                 uclosepns_rbot:=uclosepns_pArray[uclosepns_pin].pin
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             uclosepns_pin:=uclosepns_pin+1
                             
                         }
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(uclosepns_block1=uclosepns_block2) then 
                 {
                     if(groupArray[uclosepns_group1].aveX<=groupArray[uclosepns_group2].aveX) then 
                     {
                         uclosepns_pin:=1;
                         
                         while(uclosepns_pin<=groupArray[uclosepns_group1].numPins)
                         {
                             if(uclosepns_pArray1[uclosepns_pin].top=1 OR uclosepns_pArray1[uclosepns_pin].top=0) then 
                             {
                                 if(uclosepns_pArray1[uclosepns_pin].xloc>uclosepns_maxTop) then 
                                 {
                                     uclosepns_maxTop:=uclosepns_pArray1[uclosepns_pin].xloc;
                                     uclosepns_maxTpin:=uclosepns_pArray1[uclosepns_pin].pin
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(uclosepns_pArray1[uclosepns_pin].top=-1 OR uclosepns_pArray1[uclosepns_pin].top=0) then 
                             {
                                 if(uclosepns_pArray1[uclosepns_pin].xloc>uclosepns_maxBottom) then 
                                 {
                                     uclosepns_maxBottom:=uclosepns_pArray1[uclosepns_pin].xloc;
                                     uclosepns_maxBpin:=uclosepns_pArray1[uclosepns_pin].pin
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             uclosepns_pin:=uclosepns_pin+1
                             
                         };
                         uclosepns_sepT:=1000000000;
                         uclosepns_sepB:=1000000000;
                         uclosepns_otherTpin:=0;
                         uclosepns_otherBpin:=0;
                         uclosepns_pin:=1;
                         
                         while(uclosepns_pin<=groupArray[uclosepns_group2].numPins)
                         {
                             if(uclosepns_pArray2[uclosepns_pin].top=1 OR uclosepns_pArray2[uclosepns_pin].top=0) then 
                             {
                                 if(extern ABS(uclosepns_pArray2[uclosepns_pin].xloc-uclosepns_maxTop,RValue)<uclosepns_sepT) then 
                                 {
                                     uclosepns_otherTpin:=uclosepns_pArray2[uclosepns_pin].pin;
                                     uclosepns_minTop:=uclosepns_pArray2[uclosepns_pin].xloc;
                                     uclosepns_sepT:=ABS(uclosepns_minTop-uclosepns_maxTop,RValue)
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(uclosepns_pArray2[uclosepns_pin].top=-1 OR uclosepns_pArray2[uclosepns_pin].top=0) then 
                             {
                                 if(extern ABS(uclosepns_pArray2[uclosepns_pin].xloc-uclosepns_maxBottom,RValue)<uclosepns_sepB) then 
                                 {
                                     uclosepns_otherBpin:=uclosepns_pArray2[uclosepns_pin].pin;
                                     uclosepns_minBottom:=uclosepns_pArray2[uclosepns_pin].xloc;
                                     uclosepns_sepB:=ABS(uclosepns_minBottom-uclosepns_maxBottom,RValue)
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             uclosepns_pin:=uclosepns_pin+1
                             
                         };
                         if(uclosepns_maxTpin!=0 AND uclosepns_otherTpin!=0 AND uclosepns_block1<numChans) then 
                         {
                             if(uclosepns_maxBpin!=0 AND uclosepns_otherBpin!=0 AND uclosepns_block1>0) then 
                             {
                                 aNetSeg[uclosepns_segIndex].nswYorN:=1;
                                 if(uclosepns_key_flag=0 OR uclosepns_key_flag=uclosepns_segIndex) then 
                                 {
                                     aNetSeg[uclosepns_segIndex].nkey:=0
                                     
                                 }
                                 else
                                 {
                                     aNetSeg[uclosepns_segIndex].nkey:=uclosepns_key_flag
                                 };
                                 aNetSeg[uclosepns_segIndex].ncurrent:=0;
                                 if(uclosepns_maxTop<=uclosepns_minTop) then 
                                 {
                                     uclosepns_Tleft:=uclosepns_maxTop;
                                     uclosepns_Tright:=uclosepns_minTop;
                                     uclosepns_p1:=uclosepns_maxTpin;
                                     uclosepns_p2:=uclosepns_otherTpin
                                     
                                 }
                                 else
                                 {
                                     uclosepns_Tleft:=uclosepns_minTop;
                                     uclosepns_Tright:=uclosepns_maxTop;
                                     uclosepns_p1:=uclosepns_otherTpin;
                                     uclosepns_p2:=uclosepns_maxTpin
                                 };
                                 if(uclosepns_key_flag!=0) then 
                                 {
                                     uclosepns_Tleft:=uclosepns_k_left;
                                     uclosepns_Tright:=uclosepns_k_right
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 aNetSeg[uclosepns_segIndex].ntop->channel:=uclosepns_block1+1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin1:=uclosepns_p1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin2:=uclosepns_p2;
                                 if(uclosepns_maxBottom<=uclosepns_minBottom) then 
                                 {
                                     uclosepns_Bleft:=uclosepns_maxBottom;
                                     uclosepns_Bright:=uclosepns_minBottom;
                                     uclosepns_p1:=uclosepns_maxBpin;
                                     uclosepns_p2:=uclosepns_otherBpin
                                     
                                 }
                                 else
                                 {
                                     uclosepns_Bleft:=uclosepns_minBottom;
                                     uclosepns_Bright:=uclosepns_maxBottom;
                                     uclosepns_p1:=uclosepns_otherBpin;
                                     uclosepns_p2:=uclosepns_maxBpin
                                 };
                                 if(uclosepns_key_flag!=0) then 
                                 {
                                     uclosepns_Bleft:=uclosepns_k_left;
                                     uclosepns_Bright:=uclosepns_k_right
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 aNetSeg[uclosepns_segIndex].nbot->channel:=uclosepns_block1;
                                 aNetSeg[uclosepns_segIndex].nbot->pin1:=uclosepns_p1;
                                 aNetSeg[uclosepns_segIndex].nbot->pin2:=uclosepns_p2;
                                 if(uclosepns_Bleft=uclosepns_Bright OR uclosepns_Tleft=uclosepns_Tright) then 
                                 {
                                     aNetSeg[uclosepns_segIndex].nswYorN:=0;
                                     if(uclosepns_Bleft=uclosepns_Bright AND uclosepns_Tleft!=uclosepns_Tright) then 
                                     {
                                         uclosepns_tmp_ptr:=aNetSeg[uclosepns_segIndex].ntop;
                                         aNetSeg[uclosepns_segIndex].ntop:=aNetSeg[uclosepns_segIndex].nbot;
                                         aNetSeg[uclosepns_segIndex].nbot:=uclosepns_tmp_ptr
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                             else
                             {
                                 aNetSeg[uclosepns_segIndex].nswYorN:=0;
                                 aNetSeg[uclosepns_segIndex].nkey:=0;
                                 aNetSeg[uclosepns_segIndex].ncurrent:=0;
                                 if(uclosepns_maxTop<=uclosepns_minTop) then 
                                 {
                                     uclosepns_p1:=uclosepns_maxTpin;
                                     uclosepns_p2:=uclosepns_otherTpin
                                     
                                 }
                                 else
                                 {
                                     uclosepns_p1:=uclosepns_otherTpin;
                                     uclosepns_p2:=uclosepns_maxTpin
                                 };
                                 aNetSeg[uclosepns_segIndex].ntop->channel:=uclosepns_block1+1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin1:=uclosepns_p1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin2:=uclosepns_p2
                             }
                         }
                         else
                         {
                             if(uclosepns_maxBpin!=0 AND uclosepns_otherBpin!=0) then 
                             {
                                 aNetSeg[uclosepns_segIndex].nswYorN:=0;
                                 aNetSeg[uclosepns_segIndex].nkey:=0;
                                 aNetSeg[uclosepns_segIndex].ncurrent:=0;
                                 if(uclosepns_maxBottom<=uclosepns_minBottom) then 
                                 {
                                     uclosepns_p1:=uclosepns_maxBpin;
                                     uclosepns_p2:=uclosepns_otherBpin
                                     
                                 }
                                 else
                                 {
                                     uclosepns_p1:=uclosepns_otherBpin;
                                     uclosepns_p2:=uclosepns_maxBpin
                                 };
                                 aNetSeg[uclosepns_segIndex].ntop->channel:=uclosepns_block1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin1:=uclosepns_p1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin2:=uclosepns_p2
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                         }
                         
                     }
                     else
                     {
                         uclosepns_pin:=1;
                         
                         while(uclosepns_pin<=groupArray[uclosepns_group2].numPins)
                         {
                             if(uclosepns_pArray2[uclosepns_pin].top=1 OR uclosepns_pArray2[uclosepns_pin].top=0) then 
                             {
                                 if(uclosepns_pArray2[uclosepns_pin].xloc>uclosepns_maxTop) then 
                                 {
                                     uclosepns_maxTop:=uclosepns_pArray2[uclosepns_pin].xloc;
                                     uclosepns_maxTpin:=uclosepns_pArray2[uclosepns_pin].pin
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(uclosepns_pArray2[uclosepns_pin].top=-1 OR uclosepns_pArray2[uclosepns_pin].top=0) then 
                             {
                                 if(uclosepns_pArray2[uclosepns_pin].xloc>uclosepns_maxBottom) then 
                                 {
                                     uclosepns_maxBottom:=uclosepns_pArray2[uclosepns_pin].xloc;
                                     uclosepns_maxBpin:=uclosepns_pArray2[uclosepns_pin].pin
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             uclosepns_pin:=uclosepns_pin+1
                             
                         };
                         uclosepns_sepT:=1000000000;
                         uclosepns_sepB:=1000000000;
                         uclosepns_otherTpin:=0;
                         uclosepns_otherBpin:=0;
                         uclosepns_pin:=1;
                         
                         while(uclosepns_pin<=groupArray[uclosepns_group1].numPins)
                         {
                             if(uclosepns_pArray1[uclosepns_pin].top=1 OR uclosepns_pArray1[uclosepns_pin].top=0) then 
                             {
                                 if(extern ABS(uclosepns_pArray1[uclosepns_pin].xloc-uclosepns_maxTop,RValue)<uclosepns_sepT) then 
                                 {
                                     uclosepns_otherTpin:=uclosepns_pArray1[uclosepns_pin].pin;
                                     uclosepns_minTop:=uclosepns_pArray1[uclosepns_pin].xloc;
                                     uclosepns_sepT:=ABS(uclosepns_minTop-uclosepns_maxTop,RValue)
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(uclosepns_pArray1[uclosepns_pin].top=-1 OR uclosepns_pArray1[uclosepns_pin].top=0) then 
                             {
                                 if(extern ABS(uclosepns_pArray1[uclosepns_pin].xloc-uclosepns_maxBottom,RValue)<uclosepns_sepB) then 
                                 {
                                     uclosepns_otherBpin:=uclosepns_pArray1[uclosepns_pin].pin;
                                     uclosepns_minBottom:=uclosepns_pArray1[uclosepns_pin].xloc;
                                     uclosepns_sepB:=ABS(uclosepns_minBottom-uclosepns_maxBottom,RValue)
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             uclosepns_pin:=uclosepns_pin+1
                             
                         };
                         if(uclosepns_maxTpin!=0 AND uclosepns_otherTpin!=0 AND uclosepns_block1<numChans) then 
                         {
                             if(uclosepns_maxBpin!=0 AND uclosepns_otherBpin!=0 AND uclosepns_block1>0) then 
                             {
                                 aNetSeg[uclosepns_segIndex].nswYorN:=1;
                                 if(uclosepns_key_flag=0 OR uclosepns_key_flag=uclosepns_segIndex) then 
                                 {
                                     aNetSeg[uclosepns_segIndex].nkey:=0
                                     
                                 }
                                 else
                                 {
                                     aNetSeg[uclosepns_segIndex].nkey:=uclosepns_key_flag
                                 };
                                 aNetSeg[uclosepns_segIndex].ncurrent:=0;
                                 if(uclosepns_maxTop<=uclosepns_minTop) then 
                                 {
                                     uclosepns_Tleft:=uclosepns_maxTop;
                                     uclosepns_Tright:=uclosepns_minTop;
                                     uclosepns_p1:=uclosepns_maxTpin;
                                     uclosepns_p2:=uclosepns_otherTpin
                                     
                                 }
                                 else
                                 {
                                     uclosepns_Tleft:=uclosepns_minTop;
                                     uclosepns_Tright:=uclosepns_maxTop;
                                     uclosepns_p1:=uclosepns_otherTpin;
                                     uclosepns_p2:=uclosepns_maxTpin
                                 };
                                 if(uclosepns_key_flag!=0) then 
                                 {
                                     uclosepns_Tleft:=uclosepns_k_left;
                                     uclosepns_Tright:=uclosepns_k_right
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 aNetSeg[uclosepns_segIndex].ntop->channel:=uclosepns_block1+1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin1:=uclosepns_p1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin2:=uclosepns_p2;
                                 if(uclosepns_maxBottom<=uclosepns_minBottom) then 
                                 {
                                     uclosepns_Bleft:=uclosepns_maxBottom;
                                     uclosepns_Bright:=uclosepns_minBottom;
                                     uclosepns_p1:=uclosepns_maxBpin;
                                     uclosepns_p2:=uclosepns_otherBpin
                                     
                                 }
                                 else
                                 {
                                     uclosepns_Bleft:=uclosepns_minBottom;
                                     uclosepns_Bright:=uclosepns_maxBottom;
                                     uclosepns_p1:=uclosepns_otherBpin;
                                     uclosepns_p2:=uclosepns_maxBpin
                                 };
                                 if(uclosepns_key_flag!=0) then 
                                 {
                                     uclosepns_Bleft:=uclosepns_k_left;
                                     uclosepns_Bright:=uclosepns_k_right
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 aNetSeg[uclosepns_segIndex].nbot->channel:=uclosepns_block1;
                                 aNetSeg[uclosepns_segIndex].nbot->pin1:=uclosepns_p1;
                                 aNetSeg[uclosepns_segIndex].nbot->pin2:=uclosepns_p2;
                                 if(uclosepns_Bleft=uclosepns_Bright OR uclosepns_Tleft=uclosepns_Tright) then 
                                 {
                                     aNetSeg[uclosepns_segIndex].nswYorN:=0;
                                     if(uclosepns_Bleft=uclosepns_Bright AND uclosepns_Tleft!=uclosepns_Tright) then 
                                     {
                                         uclosepns_tmp_ptr:=aNetSeg[uclosepns_segIndex].ntop;
                                         aNetSeg[uclosepns_segIndex].ntop:=aNetSeg[uclosepns_segIndex].nbot;
                                         aNetSeg[uclosepns_segIndex].nbot:=uclosepns_tmp_ptr
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                             else
                             {
                                 aNetSeg[uclosepns_segIndex].nswYorN:=0;
                                 aNetSeg[uclosepns_segIndex].nkey:=0;
                                 aNetSeg[uclosepns_segIndex].ncurrent:=0;
                                 if(uclosepns_maxTop<=uclosepns_minTop) then 
                                 {
                                     uclosepns_p1:=uclosepns_maxTpin;
                                     uclosepns_p2:=uclosepns_otherTpin
                                     
                                 }
                                 else
                                 {
                                     uclosepns_p1:=uclosepns_otherTpin;
                                     uclosepns_p2:=uclosepns_maxTpin
                                 };
                                 aNetSeg[uclosepns_segIndex].ntop->channel:=uclosepns_block1+1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin1:=uclosepns_p1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin2:=uclosepns_p2
                             }
                         }
                         else
                         {
                             if(uclosepns_maxBpin!=0 AND uclosepns_otherBpin!=0) then 
                             {
                                 aNetSeg[uclosepns_segIndex].nswYorN:=0;
                                 aNetSeg[uclosepns_segIndex].nkey:=0;
                                 aNetSeg[uclosepns_segIndex].ncurrent:=0;
                                 if(uclosepns_maxBottom<=uclosepns_minBottom) then 
                                 {
                                     uclosepns_p1:=uclosepns_maxBpin;
                                     uclosepns_p2:=uclosepns_otherBpin
                                     
                                 }
                                 else
                                 {
                                     uclosepns_p1:=uclosepns_otherBpin;
                                     uclosepns_p2:=uclosepns_maxBpin
                                 };
                                 aNetSeg[uclosepns_segIndex].ntop->channel:=uclosepns_block1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin1:=uclosepns_p1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin2:=uclosepns_p2
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                         }
                     };
                     if(aNetSeg[uclosepns_segIndex].nswYorN=1 OR uclosepns_key_flag!=0) then 
                     {
                         uclosepns_channel:=aNetSeg[uclosepns_segIndex].ntop->channel;
                         if(uclosepns_key_flag=0) then 
                         {
                             uclosepns_pin1:=aNetSeg[uclosepns_segIndex].ntop->pin1;
                             uclosepns_pin2:=aNetSeg[uclosepns_segIndex].ntop->pin2
                             
                         }
                         else
                         {
                             if(uclosepns_k_right>uclosepns_k_left) then 
                             {
                                 uclosepns_pin1:=uclosepns_ltop;
                                 uclosepns_pin2:=uclosepns_rtop
                             }
                             else
                             {
                                 uclosepns_pin2<==aNetSeg[uclosepns_segIndex].ntop->pin1 and uclosepns_pin1<==uclosepns_pin2 and skip
                             }
                         };
                         aNetSeg[uclosepns_segIndex].ntop->pin1ptr:=Tgrid[uclosepns_pin1]->up;
                         if(tearray[uclosepns_pin1]->pinloc=0 AND tearray[uclosepns_pin1]->row=uclosepns_channel) then 
                         {
                             aNetSeg[uclosepns_segIndex].ntop->pin1ptr:=Tgrid[uclosepns_pin1]->down
                             
                         }
                         else 
                         {
                              skip 
                         };
                         aNetSeg[uclosepns_segIndex].ntop->pin2ptr:=Tgrid[uclosepns_pin2]->up;
                         if(tearray[uclosepns_pin2]->pinloc=0 AND tearray[uclosepns_pin2]->row=uclosepns_channel) then 
                         {
                             aNetSeg[uclosepns_segIndex].ntop->pin2ptr:=Tgrid[uclosepns_pin2]->down
                             
                         }
                         else 
                         {
                              skip 
                         };
                         uclosepns_channel:=aNetSeg[uclosepns_segIndex].nbot->channel;
                         if(uclosepns_key_flag=0) then 
                         {
                             uclosepns_pin1:=aNetSeg[uclosepns_segIndex].nbot->pin1;
                             uclosepns_pin2:=aNetSeg[uclosepns_segIndex].nbot->pin2
                             
                         }
                         else
                         {
                             if(uclosepns_k_right>uclosepns_k_left) then 
                             {
                                 uclosepns_pin1:=uclosepns_lbot;
                                 uclosepns_pin2:=uclosepns_rbot
                             }
                             else
                             {
                                 uclosepns_pin2<==aNetSeg[uclosepns_segIndex].nbot->pin1 and uclosepns_pin1<==uclosepns_pin2 and skip
                             }
                         };
                         aNetSeg[uclosepns_segIndex].nbot->pin1ptr:=Tgrid[uclosepns_pin1]->up;
                         if(tearray[uclosepns_pin1]->pinloc=0 AND tearray[uclosepns_pin1]->row=uclosepns_channel) then 
                         {
                             aNetSeg[uclosepns_segIndex].nbot->pin1ptr:=Tgrid[uclosepns_pin1]->down
                             
                         }
                         else 
                         {
                              skip 
                         };
                         aNetSeg[uclosepns_segIndex].nbot->pin2ptr:=Tgrid[uclosepns_pin2]->up;
                         if(tearray[uclosepns_pin2]->pinloc=0 AND tearray[uclosepns_pin2]->row=uclosepns_channel) then 
                         {
                             aNetSeg[uclosepns_segIndex].nbot->pin2ptr:=Tgrid[uclosepns_pin2]->down
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                     else
                     {
                         uclosepns_channel:=aNetSeg[uclosepns_segIndex].ntop->channel;
                         if(uclosepns_key_flag=0) then 
                         {
                             uclosepns_pin1:=aNetSeg[uclosepns_segIndex].ntop->pin1;
                             uclosepns_pin2:=aNetSeg[uclosepns_segIndex].ntop->pin2
                             
                         }
                         else
                         {
                             if(uclosepns_k_right>uclosepns_k_left) then 
                             {
                                 uclosepns_pin1:=uclosepns_ltop;
                                 uclosepns_pin2:=uclosepns_rtop
                             }
                             else
                             {
                                 uclosepns_pin2<==aNetSeg[uclosepns_segIndex].ntop->pin1 and uclosepns_pin1<==uclosepns_pin2 and skip
                             }
                         };
                         aNetSeg[uclosepns_segIndex].ntop->pin1ptr:=Tgrid[uclosepns_pin1]->up;
                         if(tearray[uclosepns_pin1]->pinloc=0 AND tearray[uclosepns_pin1]->row=uclosepns_channel) then 
                         {
                             aNetSeg[uclosepns_segIndex].ntop->pin1ptr:=Tgrid[uclosepns_pin1]->down
                             
                         }
                         else 
                         {
                              skip 
                         };
                         aNetSeg[uclosepns_segIndex].ntop->pin2ptr:=Tgrid[uclosepns_pin2]->up;
                         if(tearray[uclosepns_pin2]->pinloc=0 AND tearray[uclosepns_pin2]->row=uclosepns_channel) then 
                         {
                             aNetSeg[uclosepns_segIndex].ntop->pin2ptr:=Tgrid[uclosepns_pin2]->down
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                 }
                 else
                 {
                     uclosepns_minX:=1000000000;
                     uclosepns_minP1:=0;
                     uclosepns_minP2:=0;
                     if(uclosepns_block1>uclosepns_block2) then 
                     {
                         uclosepns_pin1:=1;
                         
                         while(uclosepns_pin1<=groupArray[uclosepns_group1].numPins)
                         {
                             if(uclosepns_pArray1[uclosepns_pin1].top=-1 OR uclosepns_pArray1[uclosepns_pin1].top=0) then 
                             {
                                 uclosepns_pin2:=1;
                                 while(uclosepns_pin2<=groupArray[uclosepns_group2].numPins)
                                 {
                                     if(uclosepns_pArray2[uclosepns_pin2].top=1 OR uclosepns_pArray2[uclosepns_pin2].top=0) then 
                                     {
                                         if(extern ABS(uclosepns_pArray1[uclosepns_pin1].xloc-uclosepns_pArray2[uclosepns_pin2].xloc,RValue)<uclosepns_minX) then 
                                         {
                                             uclosepns_left:=uclosepns_pArray1[uclosepns_pin1].xloc;
                                             uclosepns_right:=uclosepns_pArray2[uclosepns_pin2].xloc;
                                             uclosepns_minX:=ABS(uclosepns_left-uclosepns_right,RValue);
                                             uclosepns_minP1:=uclosepns_pArray1[uclosepns_pin1].pin;
                                             uclosepns_minP2:=uclosepns_pArray2[uclosepns_pin2].pin
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     uclosepns_pin2:=uclosepns_pin2+1
                                     
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             uclosepns_pin1:=uclosepns_pin1+1
                             
                         };
                         if(uclosepns_minP1!=0 AND uclosepns_minP2!=0) then 
                         {
                             aNetSeg[uclosepns_segIndex].nswYorN:=0;
                             aNetSeg[uclosepns_segIndex].nkey:=0;
                             aNetSeg[uclosepns_segIndex].ncurrent:=0;
                             if(uclosepns_left>uclosepns_right) then 
                             {
                                 aNetSeg[uclosepns_segIndex].ntop->channel:=uclosepns_block1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin1:=uclosepns_minP2;
                                 aNetSeg[uclosepns_segIndex].ntop->pin2:=uclosepns_minP1
                             }
                             else
                             {
                                 aNetSeg[uclosepns_segIndex].ntop->channel:=uclosepns_block1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin1:=uclosepns_minP1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin2:=uclosepns_minP2
                             }
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else
                     {
                         uclosepns_pin1:=1;
                         while(uclosepns_pin1<=groupArray[uclosepns_group1].numPins)
                         {
                             if(uclosepns_pArray1[uclosepns_pin1].top=1 OR uclosepns_pArray1[uclosepns_pin1].top=0) then 
                             {
                                 uclosepns_pin2:=1;
                                 while(uclosepns_pin2<=groupArray[uclosepns_group2].numPins)
                                 {
                                     if(uclosepns_pArray2[uclosepns_pin2].top=-1 OR uclosepns_pArray2[uclosepns_pin2].top=0) then 
                                     {
                                         if(extern ABS(uclosepns_pArray1[uclosepns_pin1].xloc-uclosepns_pArray2[uclosepns_pin2].xloc,RValue)<uclosepns_minX) then 
                                         {
                                             uclosepns_left:=uclosepns_pArray1[uclosepns_pin1].xloc;
                                             uclosepns_right:=uclosepns_pArray2[uclosepns_pin2].xloc;
                                             uclosepns_minX:=ABS(uclosepns_left-uclosepns_right,RValue);
                                             uclosepns_minP1:=uclosepns_pArray1[uclosepns_pin1].pin;
                                             uclosepns_minP2:=uclosepns_pArray2[uclosepns_pin2].pin
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     uclosepns_pin2:=uclosepns_pin2+1
                                     
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             uclosepns_pin1:=uclosepns_pin1+1
                             
                         };
                         if(uclosepns_minP1!=0 AND uclosepns_minP2!=0) then 
                         {
                             aNetSeg[uclosepns_segIndex].nswYorN:=0;
                             aNetSeg[uclosepns_segIndex].nkey:=0;
                             aNetSeg[uclosepns_segIndex].ncurrent:=0;
                             if(uclosepns_left>uclosepns_right) then 
                             {
                                 aNetSeg[uclosepns_segIndex].ntop->channel:=uclosepns_block2;
                                 aNetSeg[uclosepns_segIndex].ntop->pin1:=uclosepns_minP2;
                                 aNetSeg[uclosepns_segIndex].ntop->pin2:=uclosepns_minP1
                             }
                             else
                             {
                                 aNetSeg[uclosepns_segIndex].ntop->channel:=uclosepns_block2;
                                 aNetSeg[uclosepns_segIndex].ntop->pin1:=uclosepns_minP1;
                                 aNetSeg[uclosepns_segIndex].ntop->pin2:=uclosepns_minP2
                             }
                             
                         }
                         else 
                         {
                              skip 
                         }
                     };
                     uclosepns_channel:=aNetSeg[uclosepns_segIndex].ntop->channel;
                     uclosepns_pin1:=aNetSeg[uclosepns_segIndex].ntop->pin1;
                     uclosepns_pin2:=aNetSeg[uclosepns_segIndex].ntop->pin2;
                     aNetSeg[uclosepns_segIndex].ntop->pin1ptr:=Tgrid[uclosepns_pin1]->up;
                     if(tearray[uclosepns_pin1]->pinloc=0 AND tearray[uclosepns_pin1]->row=uclosepns_channel) then 
                     {
                         aNetSeg[uclosepns_segIndex].ntop->pin1ptr:=Tgrid[uclosepns_pin1]->down
                         
                     }
                     else 
                     {
                          skip 
                     };
                     aNetSeg[uclosepns_segIndex].ntop->pin2ptr:=Tgrid[uclosepns_pin2]->up;
                     if(tearray[uclosepns_pin2]->pinloc=0 AND tearray[uclosepns_pin2]->row=uclosepns_channel) then 
                     {
                         aNetSeg[uclosepns_segIndex].ntop->pin2ptr:=Tgrid[uclosepns_pin2]->down
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
         if(uclosepns_segIndex!=uclosepns_fault_line-1) then 
         {
             output ("Serious FAULT detected in function: uclosepns():") and skip;
             output ("   Net:",net,"\n") and skip;
             fflush(stdout) and skip
             
         }
         else 
         {
              skip 
         };
          return<==1 and skip
         )
         }; 
  function remv_cell ( int *cellptr,int post )
 {
     if(* cellptr!=post) then 
     {
         cellptr[post]:=cellptr[* cellptr];
         (* cellptr):=(* cellptr)-1
     }
     else
     {
         (* cellptr):=(* cellptr)-1
     }
     
 };
 function ucxx1 ( int bxcenter,int bycenter,int RValue )
 {
     frame(ucxx1_acellptr,ucxx1_atileptr,ucxx1_atermptr,ucxx1_cost,ucxx1_axcenter,ucxx1_aleft,ucxx1_aright,ucxx1_a1LoBin,ucxx1_a1HiBin,ucxx1_b1LoBin,ucxx1_b1HiBin,ucxx1_startxa1,ucxx1_endxa1,ucxx1_startxb1,ucxx1_endxb1,ucxx1_truth,ucxx1_aorient,return) and ( 
     int return<==0 and skip;
     cellbox* ucxx1_acellptr and skip;
     tilebox* ucxx1_atileptr and skip;
     termbox* ucxx1_atermptr and skip;
     int ucxx1_cost and skip;
     int ucxx1_axcenter and skip;
     int ucxx1_aleft,ucxx1_aright and skip;
     int ucxx1_a1LoBin,ucxx1_a1HiBin,ucxx1_b1LoBin,ucxx1_b1HiBin and skip;
     int ucxx1_startxa1,ucxx1_endxa1,ucxx1_startxb1,ucxx1_endxb1 and skip;
     int ucxx1_truth,ucxx1_aorient and skip;
     ucxx1_acellptr:=carray[a];
     ucxx1_aorient:=ucxx1_acellptr->corient;
     ucxx1_axcenter:=ucxx1_acellptr->cxcenter;
     ucxx1_atileptr:=ucxx1_acellptr->tileptr;
     ucxx1_aleft:=ucxx1_atileptr->left;
     ucxx1_aright:=ucxx1_atileptr->right;
     ucxx1_atermptr:=ucxx1_atileptr->termsptr;
     newbinpenal:=binpenal;
     newrowpenal:=rowpenal;
     newpenal:=penalty;
     new_old(ucxx1_aleft-ucxx1_aright);
     ucxx1_startxa1:=ucxx1_axcenter+ucxx1_aleft ;
     ucxx1_a1LoBin:=SetBin(ucxx1_startxa1,RValue);
     ucxx1_endxa1:=ucxx1_axcenter+ucxx1_aright ;
     ucxx1_a1HiBin:=SetBin(ucxx1_endxa1,RValue);
     ucxx1_startxb1:=bxcenter+ucxx1_aleft ;
     ucxx1_b1LoBin:=SetBin(ucxx1_startxb1,RValue);
     ucxx1_endxb1:=bxcenter+ucxx1_aright ;
     ucxx1_b1HiBin:=SetBin(ucxx1_endxb1,RValue);
     old_assgnto_new1(ucxx1_a1LoBin,ucxx1_a1HiBin,ucxx1_b1LoBin,ucxx1_b1HiBin);
     sub_penal(ucxx1_startxa1,ucxx1_endxa1,ablock,ucxx1_a1LoBin,ucxx1_a1HiBin);
     add_penal(ucxx1_startxb1,ucxx1_endxb1,bblock,ucxx1_b1LoBin,ucxx1_b1HiBin);
     if(ablock!=bblock) then 
     {
         term_newpos_a(ucxx1_atermptr,bxcenter,bycenter,ucxx1_aorient)
         
     }
     else
     {
         term_newpos(ucxx1_atermptr,bxcenter,bycenter,ucxx1_aorient)
     };
     ucxx1_cost:=funccost;
     delta_vert_cost:=0;
     if(ablock!=bblock) then 
     {
         new_dbox_a(ucxx1_atermptr,&ucxx1_cost)
         
     }
     else
     {
         new_dbox(ucxx1_atermptr,&ucxx1_cost)
     };
     wire_chg:=ucxx1_cost-funccost;
     binpen_chg:=newbinpenal-binpenal;
     rowpen_chg:=newrowpenal-rowpenal;
     newpenal:=(int)(roLenCon*(float)newrowpenal+binpenCon*(float)newbinpenal);
     ucxx1_truth:=acceptt(funccost+penalty-ucxx1_cost-newpenal-delta_vert_cost,RValue);
     if(ucxx1_truth=1) then 
     {
         new_assgnto_old1(ucxx1_a1LoBin,ucxx1_a1HiBin,ucxx1_b1LoBin,ucxx1_b1HiBin);
         if(ablock!=bblock) then 
         {
             dbox_pos_2(ucxx1_atermptr)
             
         }
         else
         {
             dbox_pos(ucxx1_atermptr)
         };
         remv_cell(cellaptr,Apost);
         add_cell(&cellbptr,a,RValue);
         ucxx1_acellptr->cblock:=bblock;
         ucxx1_acellptr->cxcenter:=bxcenter;
         ucxx1_acellptr->cycenter:=bycenter;
         funccost:=ucxx1_cost;
         binpenal:=newbinpenal;
         rowpenal:=newrowpenal;
         penalty:=newpenal;
         if(ablock!=bblock) then 
         {
             barray[ablock]->oldsize:=barray[ablock]->newsize;
             barray[bblock]->oldsize:=barray[bblock]->newsize
             
         }
         else 
         {
              skip 
         };
         return<==1 and RValue:=1;
         skip
     }
     else
     {
         return<==1 and RValue:=0;
         skip
     }
     )
     }; 
      int axcenter,aycenter,bxcenter,bycenter and skip;
     int anxcenter,bnxcenter and skip;
     int aleft,aright,bleft,bright and skip;
     int potential_errors,error_count,P_limit and skip;
     float total_wire_chg and skip;
     float sigma_wire_chg and skip;
     float mean_wire_chg and skip;
     int wire_chgs and skip;
 function ucxx2 ( int RValue )
 {
     frame(ucxx2_acellptr,ucxx2_bcellptr,ucxx2_atileptr,ucxx2_btileptr,ucxx2_atermptr,ucxx2_btermptr,ucxx2_error_light_is_on,ucxx2_cost,ucxx2_aorient,ucxx2_borient,ucxx2_a1LoBin,ucxx2_a1HiBin,ucxx2_b1LoBin,ucxx2_b1HiBin,ucxx2_a2LoBin,ucxx2_a2HiBin,ucxx2_b2LoBin,ucxx2_b2HiBin,ucxx2_startxa1,ucxx2_endxa1,ucxx2_startxa2,ucxx2_endxa2,ucxx2_startxb1,ucxx2_endxb1,ucxx2_startxb2,ucxx2_endxb2,ucxx2_anbin,ucxx2_bnbin,ucxx2_i,ucxx2_truth,ucxx2_temp,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     cellbox* ucxx2_acellptr,*ucxx2_bcellptr and skip;
     tilebox* ucxx2_atileptr,*ucxx2_btileptr and skip;
     termbox* ucxx2_atermptr,*ucxx2_btermptr and skip;
     int ucxx2_error_light_is_on and skip;
     int ucxx2_cost and skip;
     int ucxx2_aorient,ucxx2_borient and skip;
     int ucxx2_a1LoBin,ucxx2_a1HiBin,ucxx2_b1LoBin,ucxx2_b1HiBin and skip;
     int ucxx2_a2LoBin,ucxx2_a2HiBin,ucxx2_b2LoBin,ucxx2_b2HiBin and skip;
     int ucxx2_startxa1,ucxx2_endxa1,ucxx2_startxa2,ucxx2_endxa2 and skip;
     int ucxx2_startxb1,ucxx2_endxb1,ucxx2_startxb2,ucxx2_endxb2 and skip;
     int ucxx2_anbin,ucxx2_bnbin,ucxx2_i and skip;
     int ucxx2_truth and skip;
     float ucxx2_temp and skip;		    
     ucxx2_acellptr:=carray[a];
     axcenter:=ucxx2_acellptr->cxcenter;
     aycenter:=ucxx2_acellptr->cycenter;
     ucxx2_aorient:=ucxx2_acellptr->corient;
     ucxx2_atileptr:=ucxx2_acellptr->tileptr;
     aleft:=ucxx2_atileptr->left;
     aright:=ucxx2_atileptr->right;
     ucxx2_atermptr:=ucxx2_atileptr->termsptr;
     ucxx2_bcellptr:=carray[b];
     bxcenter:=ucxx2_bcellptr->cxcenter;
     bycenter:=ucxx2_bcellptr->cycenter;
     ucxx2_borient:=ucxx2_bcellptr->corient;
     ucxx2_btileptr:=ucxx2_bcellptr->tileptr;
     bleft:=ucxx2_btileptr->left;
     bright:=ucxx2_btileptr->right;
     ucxx2_btermptr:=ucxx2_btileptr->termsptr;
     newbinpenal:=binpenal;
     newrowpenal:=rowpenal;
     newpenal:=penalty;
     new_old(bright-bleft-aright+aleft);
     find_new_pos(RValue);


     ucxx2_startxa1:=axcenter+aleft ;
     ucxx2_a1LoBin:=SetBin(ucxx2_startxa1,RValue);
     ucxx2_endxa1:=axcenter+aright ;
     ucxx2_a1HiBin:=SetBin(ucxx2_endxa1,RValue);
     ucxx2_startxb1:=bxcenter+bleft ;
     ucxx2_b1LoBin:=SetBin(ucxx2_startxb1,RValue);
     ucxx2_endxb1:=bxcenter+bright ;
     ucxx2_b1HiBin:=SetBin(ucxx2_endxb1,RValue);
     ucxx2_startxa2:=anxcenter+aleft ;
     ucxx2_a2LoBin:=SetBin(ucxx2_startxa2,RValue);
     ucxx2_endxa2:=anxcenter+aright ;
     ucxx2_a2HiBin:=SetBin(ucxx2_endxa2,RValue);
     ucxx2_startxb2:=bnxcenter+bleft ;
     ucxx2_b2LoBin:=SetBin(ucxx2_startxb2,RValue);
     ucxx2_endxb2:=bnxcenter+bright ;
     ucxx2_b2HiBin:=SetBin(ucxx2_endxb2,RValue);


     old_assgnto_new2(ucxx2_a1LoBin,ucxx2_a1HiBin,ucxx2_b1LoBin,ucxx2_b1HiBin,ucxx2_a2LoBin,ucxx2_a2HiBin,ucxx2_b2LoBin,ucxx2_b2HiBin);
     




	 

	 sub_penal(ucxx2_startxa1,ucxx2_endxa1,ablock,ucxx2_a1LoBin,ucxx2_a1HiBin);	 			          	 
     sub_penal(ucxx2_startxb1,ucxx2_endxb1,bblock,ucxx2_b1LoBin,ucxx2_b1HiBin);
     add_penal(ucxx2_startxa2,ucxx2_endxa2,bblock,ucxx2_a2LoBin,ucxx2_a2HiBin);
     add_penal(ucxx2_startxb2,ucxx2_endxb2,ablock,ucxx2_b2LoBin,ucxx2_b2HiBin);


     binpen_chg:=newbinpenal-binpenal;
     rowpen_chg:=newrowpenal-rowpenal;
     newpenal:=(int)(roLenCon*(float)newrowpenal+binpenCon*(float)newbinpenal);

	 


     ucxx2_error_light_is_on:=0;
     if(newpenal-penalty>P_limit) then 
     {
         if(potential_errors<100) then 
         {
             potential_errors:=potential_errors+1;
             ucxx2_error_light_is_on:=1
         }
         else
         {
             earlyRej:=earlyRej+1;
             return<==1 and RValue:=(-1);
             skip
         }
         
     }
     else 
     {
          skip 
     };
     if(return=0)  then
     {
         if(ablock!=bblock) then 
         {
             term_newpos_a(ucxx2_atermptr,anxcenter,bycenter,ucxx2_aorient);
             term_newpos_b(ucxx2_btermptr,bnxcenter,aycenter,ucxx2_borient)
             
         }
         else
         {
             term_newpos(ucxx2_atermptr,anxcenter,bycenter,ucxx2_aorient);
             term_newpos(ucxx2_btermptr,bnxcenter,aycenter,ucxx2_borient)
         };
         ucxx2_cost:=funccost;
         delta_vert_cost:=0;
         if(ablock!=bblock) then 
         {
             new_dbox_a(ucxx2_atermptr,&ucxx2_cost);
             new_dbox_a(ucxx2_btermptr,&ucxx2_cost)
             
         }
         else
         {
             new_dbox(ucxx2_atermptr,&ucxx2_cost);
             new_dbox(ucxx2_btermptr,&ucxx2_cost)
         };
         wire_chg:=ucxx2_cost-funccost;
         ucxx2_truth:=acceptt(funccost+penalty-ucxx2_cost-newpenal-delta_vert_cost,RValue);


		 
		 if(ucxx2_truth=1) then 
         {
             if(ucxx2_error_light_is_on) then 
             {
                 error_count:=error_count+1
                 
             }
             else 
             {
                  skip 
             };
             new_assgnto_old2(ucxx2_a1LoBin,ucxx2_a1HiBin,ucxx2_b1LoBin,ucxx2_b1HiBin,ucxx2_a2LoBin,ucxx2_a2HiBin,ucxx2_b2LoBin,ucxx2_b2HiBin);
             if(ablock!=bblock) then 
             {
                 dbox_pos_2(ucxx2_atermptr);
                 dbox_pos_2(ucxx2_btermptr)
                 
             }
             else
             {
                 dbox_pos(ucxx2_atermptr);
                 dbox_pos(ucxx2_btermptr)
             };
             ucxx2_anbin:=SetBin(anxcenter,RValue);
             ucxx2_bnbin:=SetBin(bnxcenter,RValue);
             if(cellaptr!=cellbptr) then 
             {
                 remv_cell(cellaptr,Apost);
                 remv_cell(cellbptr,Bpost);
                 add_cell(&binptr[bblock,ucxx2_anbin]->cell,a,RValue);
                 add_cell(&binptr[ablock,ucxx2_bnbin]->cell,b,RValue)
                 
             }
             else
             {
                 remv_cell(cellaptr,Apost);
                 break$<==0 and skip;
                 ucxx2_i:=1;
                 
                 while( break$=0 AND  ucxx2_i<=* cellaptr)
                 {
                     if(cellaptr[ucxx2_i]=b) then 
                     {
                         break$<==1 and skip
                          
                     }
                     else 
                     {
                          skip 
                     };
                     if(break$=0)   then
                     {
                         ucxx2_i:=ucxx2_i+1
                     }
                     else
                     {
                         skip
                     }
                     
                 };
                 break$<==0 and skip;
                 remv_cell(cellaptr,ucxx2_i);
                 add_cell(&binptr[ablock,ucxx2_anbin]->cell,a,RValue);
                 add_cell(&binptr[ablock,ucxx2_bnbin]->cell,b,RValue)
             };
             if(wire_chg<0) then 
             {
                 ucxx2_temp:=(float)(-wire_chg);
                 total_wire_chg:=total_wire_chg+ucxx2_temp;
                 sigma_wire_chg:=sigma_wire_chg+(ucxx2_temp-mean_wire_chg)*(ucxx2_temp-mean_wire_chg);
                 wire_chgs:=wire_chgs+1
                 
             }
             else 
             {
                  skip 
             };


     
             ucxx2_acellptr->cblock:=bblock;
             ucxx2_acellptr->cxcenter:=anxcenter;
             ucxx2_acellptr->cycenter:=bycenter;
             ucxx2_bcellptr->cblock:=ablock;
             ucxx2_bcellptr->cxcenter:=bnxcenter;
             ucxx2_bcellptr->cycenter:=aycenter;
             funccost:=ucxx2_cost;
             binpenal:=newbinpenal;
             rowpenal:=newrowpenal;
             penalty:=newpenal; 
             if(ablock!=bblock) then 
             {
                 barray[ablock]->oldsize:=barray[ablock]->newsize;
                 barray[bblock]->oldsize:=barray[bblock]->newsize
                 
             }
             else 
             {
                  skip 
             };
             return<==1 and RValue:=1;
             skip
         }
         else
         {
             return<==1 and RValue:=0;
             skip
         }
     }
     else
     {
         skip
     }
     )
     }; 
  function find_new_pos ( int RValue )
 {
     frame(find_new_pos_newA_l,find_new_pos_newA_r,find_new_pos_newB_l,find_new_pos_newB_r,find_new_pos_oldA_l,find_new_pos_oldA_r,find_new_pos_oldB_l,find_new_pos_oldB_r,find_new_pos_span,find_new_pos_target,find_new_pos_target_l,find_new_pos_target_r,find_new_pos_blkLeft,find_new_pos_blkRite,find_new_pos_dist1,find_new_pos_dist2,return) and ( 
     int return<==0 and skip;
     int find_new_pos_newA_l,find_new_pos_newA_r,find_new_pos_newB_l,find_new_pos_newB_r and skip;
     int find_new_pos_oldA_l,find_new_pos_oldA_r,find_new_pos_oldB_l,find_new_pos_oldB_r and skip;
     int find_new_pos_span,find_new_pos_target,find_new_pos_target_l,find_new_pos_target_r,find_new_pos_blkLeft,find_new_pos_blkRite and skip;
     int find_new_pos_dist1,find_new_pos_dist2 and skip;
     find_new_pos_newA_l:=bxcenter+aleft;
     find_new_pos_newA_r:=bxcenter+aright;
     find_new_pos_newB_l:=axcenter+bleft;
     find_new_pos_newB_r:=axcenter+bright;
     if((ablock=bblock) AND (!((find_new_pos_newA_l>=find_new_pos_newB_r) OR (find_new_pos_newB_l>=find_new_pos_newA_r)))) then 
     {
         find_new_pos_oldA_l:=axcenter+aleft;
         find_new_pos_oldA_r:=axcenter+aright;
         find_new_pos_oldB_l:=bxcenter+bleft;
         find_new_pos_oldB_r:=bxcenter+bright;
         if(!((find_new_pos_oldA_l>=find_new_pos_oldB_r) OR (find_new_pos_oldB_l>=find_new_pos_oldA_r))) then 
         {
             find_new_pos_span:=aright-aleft+bright-bleft;
             find_new_pos_target:=((( if((find_new_pos_oldA_l<=find_new_pos_oldB_l)) then find_new_pos_oldA_l else find_new_pos_oldB_l))+(( if((find_new_pos_oldA_r>=find_new_pos_oldB_r)) then find_new_pos_oldA_r else find_new_pos_oldB_r)))/ 2;
             find_new_pos_target_l:=find_new_pos_target-find_new_pos_span/ 2;
             find_new_pos_target_r:=find_new_pos_target_l+find_new_pos_span;
             find_new_pos_blkLeft:=barray[ablock]->bxcenter+barray[ablock]->bleft;
             find_new_pos_blkRite:=find_new_pos_blkLeft+barray[ablock]->desire;
             if(find_new_pos_target_l<find_new_pos_blkLeft) then 
             {
                 find_new_pos_target_l:=find_new_pos_target_l+find_new_pos_blkLeft-find_new_pos_target_l;
                 find_new_pos_target_r:=find_new_pos_target_r+find_new_pos_blkLeft-find_new_pos_target_l
                 
             }
             else
             {
                 if(find_new_pos_target_r>find_new_pos_blkRite) then 
                 {
                     find_new_pos_target_l:=find_new_pos_target_l-(find_new_pos_target_r-find_new_pos_blkRite);
                     find_new_pos_target_r:=find_new_pos_target_r-(find_new_pos_target_r-find_new_pos_blkRite)
                     
                 }
                 else 
                 {
                      skip 
                 }
             };
             find_new_pos_dist1:=find_new_pos_newA_r-find_new_pos_newB_l;
             find_new_pos_dist2:=find_new_pos_newB_r-find_new_pos_newA_l;
             if(find_new_pos_dist1<=find_new_pos_dist2) then 
             {
                 anxcenter:=find_new_pos_target_l-aleft;
                 bnxcenter:=find_new_pos_target_r-bright
             }
             else
             {
                 anxcenter:=find_new_pos_target_r-aright;
                 bnxcenter:=find_new_pos_target_l-bleft
             }
         }
         else
         {
             if(find_new_pos_oldA_l<=find_new_pos_oldB_l) then 
             {
                 bnxcenter:=find_new_pos_oldA_l-bleft;
                 anxcenter:=find_new_pos_oldB_r-aright
             }
             else
             {
                 anxcenter:=find_new_pos_oldB_l-aleft;
                 bnxcenter:=find_new_pos_oldA_r-bright
             }
         }
         
     }
     else
     {
         anxcenter:=bxcenter;
         bnxcenter:=axcenter
     };
      return<==1 and skip
     )
     }; 
  function add_cell ( int **cellptr,int c,int RValue )
 {
     frame(add_cell_k,return) and ( 
     int return<==0 and skip;
     int add_cell_k and skip;
     add_cell_k:=((* * cellptr)+1) ;
     if((add_cell_k) % 10=0) then 
     {
         (* * cellptr):=(* * cellptr)+1;
         * cellptr:=(int *)safe_realloc(* cellptr,(add_cell_k+10)*sizeof(int),RValue)
         
     }
     else 
     {
         (* * cellptr):=(* * cellptr)+1
         
     };
     (* cellptr)[add_cell_k]:=c;
      return<==1 and skip
     )
     }; 
  function ucxxo1 ( int bxcenter,int bycenter,int newaor,int RValue )
 {
     frame(ucxxo1_acellptr,ucxxo1_atileptr,ucxxo1_antrmptr,ucxxo1_cost,ucxxo1_axcenter,ucxxo1_aleft,ucxxo1_aright,ucxxo1_a1LoBin,ucxxo1_a1HiBin,ucxxo1_b1LoBin,ucxxo1_b1HiBin,ucxxo1_startxa1,ucxxo1_endxa1,ucxxo1_startxb1,ucxxo1_endxb1,ucxxo1_truth,return) and ( 
     int return<==0 and skip;
     cellbox* ucxxo1_acellptr and skip;
     tilebox* ucxxo1_atileptr and skip;
     termbox* ucxxo1_antrmptr and skip;
     int ucxxo1_cost and skip;
     int ucxxo1_axcenter and skip;
     int ucxxo1_aleft,ucxxo1_aright and skip;
     int ucxxo1_a1LoBin,ucxxo1_a1HiBin,ucxxo1_b1LoBin,ucxxo1_b1HiBin and skip;
     int ucxxo1_startxa1,ucxxo1_endxa1,ucxxo1_startxb1,ucxxo1_endxb1 and skip;
     int ucxxo1_truth and skip;
     ucxxo1_acellptr:=carray[a];
     ucxxo1_axcenter:=ucxxo1_acellptr->cxcenter;
     ucxxo1_atileptr:=ucxxo1_acellptr->tileptr;
     ucxxo1_aleft:=ucxxo1_atileptr->left;
     ucxxo1_aright:=ucxxo1_atileptr->right;
     ucxxo1_antrmptr:=ucxxo1_atileptr->termsptr;
     newbinpenal:=binpenal;
     newrowpenal:=rowpenal;
     newpenal:=penalty;
     new_old(ucxxo1_aleft-ucxxo1_aright);
     ucxxo1_startxa1:=ucxxo1_axcenter+ucxxo1_aleft ;
     ucxxo1_a1LoBin:=SetBin(ucxxo1_startxa1,RValue);
     ucxxo1_endxa1:=ucxxo1_axcenter+ucxxo1_aright ;
     ucxxo1_a1HiBin:=SetBin(ucxxo1_endxa1,RValue);
     ucxxo1_startxb1:=bxcenter+ucxxo1_aleft ;
     ucxxo1_b1LoBin:=SetBin(ucxxo1_startxb1,RValue);
     ucxxo1_endxb1:=bxcenter+ucxxo1_aright ;
     ucxxo1_b1HiBin:=SetBin(ucxxo1_endxb1,RValue);
     old_assgnto_new1(ucxxo1_a1LoBin,ucxxo1_a1HiBin,ucxxo1_b1LoBin,ucxxo1_b1HiBin);
     sub_penal(ucxxo1_startxa1,ucxxo1_endxa1,ablock,ucxxo1_a1LoBin,ucxxo1_a1HiBin);
     add_penal(ucxxo1_startxb1,ucxxo1_endxb1,bblock,ucxxo1_b1LoBin,ucxxo1_b1HiBin);
     if(ablock!=bblock) then 
     {
         term_newpos_a(ucxxo1_antrmptr,bxcenter,bycenter,newaor)
         
     }
     else
     {
         term_newpos(ucxxo1_antrmptr,bxcenter,bycenter,newaor)
     };
     ucxxo1_cost:=funccost;
     delta_vert_cost:=0;
     if(ablock!=bblock) then 
     {
         new_dbox_a(ucxxo1_antrmptr,&ucxxo1_cost)
         
     }
     else
     {
         new_dbox(ucxxo1_antrmptr,&ucxxo1_cost)
     };
     wire_chg:=ucxxo1_cost-funccost;
     binpen_chg:=newbinpenal-binpenal;
     rowpen_chg:=newrowpenal-rowpenal;
     newpenal:=(int)(roLenCon*(float)newrowpenal+binpenCon*(float)newbinpenal);
     ucxxo1_truth:=acceptt(funccost+penalty-ucxxo1_cost-newpenal-delta_vert_cost,RValue);
     if(ucxxo1_truth=1) then 
     {
         new_assgnto_old1(ucxxo1_a1LoBin,ucxxo1_a1HiBin,ucxxo1_b1LoBin,ucxxo1_b1HiBin);
         if(ablock!=bblock) then 
         {
             dbox_pos_2(ucxxo1_antrmptr)
             
         }
         else
         {
             dbox_pos(ucxxo1_antrmptr)
         };
         remv_cell(cellaptr,Apost);
         add_cell(&cellbptr,a,RValue);
         ucxxo1_acellptr->cblock:=bblock;
         ucxxo1_acellptr->cxcenter:=bxcenter;
         ucxxo1_acellptr->cycenter:=bycenter;
         ucxxo1_acellptr->corient:=newaor;
         funccost:=ucxxo1_cost;
         binpenal:=newbinpenal;
         rowpenal:=newrowpenal;
         penalty:=newpenal;
         if(ablock!=bblock) then 
         {
             barray[ablock]->oldsize:=barray[ablock]->newsize;
             barray[bblock]->oldsize:=barray[bblock]->newsize
             
         }
         else 
         {
              skip 
         };
         return<==1 and RValue:=1;
         skip
     }
     else
     {
         return<==1 and RValue:=0;
         skip
     }
     )
     }; 
  function ucxxo2 ( int newaor,int newbor,int RValue )
 {
     frame(ucxxo2_acellptr,ucxxo2_bcellptr,ucxxo2_atileptr,ucxxo2_btileptr,ucxxo2_antrmptr,ucxxo2_bntrmptr,ucxxo2_temp,ucxxo2_cost,ucxxo2_error_light_is_on,ucxxo2_axcenter,ucxxo2_aycenter,ucxxo2_bxcenter,ucxxo2_bycenter,ucxxo2_aleft,ucxxo2_aright,ucxxo2_bleft,ucxxo2_bright,ucxxo2_a1LoBin,ucxxo2_a2LoBin,ucxxo2_b1LoBin,ucxxo2_b2LoBin,ucxxo2_a1HiBin,ucxxo2_a2HiBin,ucxxo2_b1HiBin,ucxxo2_b2HiBin,ucxxo2_startxa1,ucxxo2_endxa1,ucxxo2_startxa2,ucxxo2_endxa2,ucxxo2_startxb1,ucxxo2_endxb1,ucxxo2_startxb2,ucxxo2_endxb2,ucxxo2_truth,return) and ( 
     int return<==0 and skip;
     cellbox* ucxxo2_acellptr,*ucxxo2_bcellptr and skip;
     tilebox* ucxxo2_atileptr,*ucxxo2_btileptr and skip;
     termbox* ucxxo2_antrmptr,*ucxxo2_bntrmptr and skip;
     float ucxxo2_temp and skip;
     int ucxxo2_cost,ucxxo2_error_light_is_on and skip;
     int ucxxo2_axcenter,ucxxo2_aycenter,ucxxo2_bxcenter,ucxxo2_bycenter and skip;
     int ucxxo2_aleft,ucxxo2_aright and skip;
     int ucxxo2_bleft,ucxxo2_bright and skip;
     int ucxxo2_a1LoBin,ucxxo2_a2LoBin,ucxxo2_b1LoBin,ucxxo2_b2LoBin and skip;
     int ucxxo2_a1HiBin,ucxxo2_a2HiBin,ucxxo2_b1HiBin,ucxxo2_b2HiBin and skip;
     int ucxxo2_startxa1,ucxxo2_endxa1,ucxxo2_startxa2,ucxxo2_endxa2 and skip;
     int ucxxo2_startxb1,ucxxo2_endxb1,ucxxo2_startxb2,ucxxo2_endxb2 and skip;
     int ucxxo2_truth and skip;
     ucxxo2_acellptr:=carray[a];
     ucxxo2_axcenter:=ucxxo2_acellptr->cxcenter;
     ucxxo2_aycenter:=ucxxo2_acellptr->cycenter;
     ucxxo2_atileptr:=ucxxo2_acellptr->tileptr;
     ucxxo2_aleft:=ucxxo2_atileptr->left;
     ucxxo2_aright:=ucxxo2_atileptr->right;
     ucxxo2_antrmptr:=ucxxo2_atileptr->termsptr;
     ucxxo2_bcellptr:=carray[b];
     ucxxo2_bxcenter:=ucxxo2_bcellptr->cxcenter;
     ucxxo2_bycenter:=ucxxo2_bcellptr->cycenter;
     ucxxo2_btileptr:=ucxxo2_bcellptr->tileptr;
     ucxxo2_bleft:=ucxxo2_btileptr->left;
     ucxxo2_bright:=ucxxo2_btileptr->right;
     ucxxo2_bntrmptr:=ucxxo2_btileptr->termsptr;
     newbinpenal:=binpenal;
     newrowpenal:=rowpenal;
     newpenal:=penalty;
     new_old(ucxxo2_bright-ucxxo2_bleft-ucxxo2_aright+ucxxo2_aleft);
     ucxxo2_startxa1:=ucxxo2_axcenter+ucxxo2_aleft ;
     ucxxo2_a1LoBin:=SetBin(ucxxo2_startxa1,RValue);
     ucxxo2_endxa1:=ucxxo2_axcenter+ucxxo2_aright ;
     ucxxo2_a1HiBin:=SetBin(ucxxo2_endxa1,RValue);
     ucxxo2_startxb1:=ucxxo2_bxcenter+ucxxo2_bleft ;
     ucxxo2_b1LoBin:=SetBin(ucxxo2_startxb1,RValue);
     ucxxo2_endxb1:=ucxxo2_bxcenter+ucxxo2_bright ;
     ucxxo2_b1HiBin:=SetBin(ucxxo2_endxb1,RValue);
     ucxxo2_startxa2:=ucxxo2_bxcenter+ucxxo2_aleft ;
     ucxxo2_a2LoBin:=SetBin(ucxxo2_startxa2,RValue);
     ucxxo2_endxa2:=ucxxo2_bxcenter+ucxxo2_aright ;
     ucxxo2_a2HiBin:=SetBin(ucxxo2_endxa2,RValue);
     ucxxo2_startxb2:=ucxxo2_axcenter+ucxxo2_bleft ;
     ucxxo2_b2LoBin:=SetBin(ucxxo2_startxb2,RValue);
     ucxxo2_endxb2:=ucxxo2_axcenter+ucxxo2_bright ;
     ucxxo2_b2HiBin:=SetBin(ucxxo2_endxb2,RValue);
     old_assgnto_new2(ucxxo2_a1LoBin,ucxxo2_a1HiBin,ucxxo2_b1LoBin,ucxxo2_b1HiBin,ucxxo2_a2LoBin,ucxxo2_a2HiBin,ucxxo2_b2LoBin,ucxxo2_b2HiBin);
     sub_penal(ucxxo2_startxa1,ucxxo2_endxa1,ablock,ucxxo2_a1LoBin,ucxxo2_a1HiBin);
     sub_penal(ucxxo2_startxb1,ucxxo2_endxb1,bblock,ucxxo2_b1LoBin,ucxxo2_b1HiBin);
     add_penal(ucxxo2_startxa2,ucxxo2_endxa2,bblock,ucxxo2_a2LoBin,ucxxo2_a2HiBin);
     add_penal(ucxxo2_startxb2,ucxxo2_endxb2,ablock,ucxxo2_b2LoBin,ucxxo2_b2HiBin);
     binpen_chg:=newbinpenal-binpenal;
     rowpen_chg:=newrowpenal-rowpenal;
     newpenal:=(int)(roLenCon*(float)newrowpenal+binpenCon*(float)newbinpenal);
     ucxxo2_error_light_is_on:=0;
     if(newpenal-penalty>P_limit) then 
     {
         if(potential_errors<100) then 
         {
             potential_errors:=potential_errors+1;
             ucxxo2_error_light_is_on:=1
         }
         else
         {
             earlyRej:=earlyRej+1;
             return<==1 and RValue:=(-1);
             skip
         }
         
     }
     else 
     {
          skip 
     };
     if(return=0)  then
     {
         if(ablock!=bblock) then 
         {
             term_newpos_a(ucxxo2_antrmptr,ucxxo2_bxcenter,ucxxo2_bycenter,newaor);
             term_newpos_b(ucxxo2_bntrmptr,ucxxo2_axcenter,ucxxo2_aycenter,newbor)
             
         }
         else
         {
             term_newpos(ucxxo2_antrmptr,ucxxo2_bxcenter,ucxxo2_bycenter,newaor);
             term_newpos(ucxxo2_bntrmptr,ucxxo2_axcenter,ucxxo2_aycenter,newbor)
         };
         ucxxo2_cost:=funccost;
         delta_vert_cost:=0;
         if(ablock!=bblock) then 
         {
             new_dbox_a(ucxxo2_antrmptr,&ucxxo2_cost);
             new_dbox_a(ucxxo2_bntrmptr,&ucxxo2_cost)
             
         }
         else
         {
             new_dbox(ucxxo2_antrmptr,&ucxxo2_cost);
             new_dbox(ucxxo2_bntrmptr,&ucxxo2_cost)
         };
         wire_chg:=ucxxo2_cost-funccost;
         ucxxo2_truth:=acceptt(funccost+penalty-ucxxo2_cost-newpenal-delta_vert_cost,RValue);
         if(ucxxo2_truth=1) then 
         {
             if(ucxxo2_error_light_is_on) then 
             {
                 error_count:=error_count+1
                 
             }
             else 
             {
                  skip 
             };
             new_assgnto_old2(ucxxo2_a1LoBin,ucxxo2_a1HiBin,ucxxo2_b1LoBin,ucxxo2_b1HiBin,ucxxo2_a2LoBin,ucxxo2_a2HiBin,ucxxo2_b2LoBin,ucxxo2_b2HiBin);
             if(ablock!=bblock) then 
             {
                 dbox_pos_2(ucxxo2_antrmptr);
                 dbox_pos_2(ucxxo2_bntrmptr)
                 
             }
             else
             {
                 dbox_pos(ucxxo2_antrmptr);
                 dbox_pos(ucxxo2_bntrmptr)
             };
             if(cellaptr!=cellbptr) then 
             {
                 remv_cell(cellaptr,Apost);
                 remv_cell(cellbptr,Bpost);
                 add_cell(&cellbptr,a,RValue);
                 add_cell(&cellaptr,b,RValue)
                 
             }
             else 
             {
                  skip 
             };
             if(wire_chg<0) then 
             {
                 ucxxo2_temp:=(float)(-wire_chg);
                 total_wire_chg:=total_wire_chg+ucxxo2_temp;
                 sigma_wire_chg:=sigma_wire_chg+(ucxxo2_temp-mean_wire_chg)*(ucxxo2_temp-mean_wire_chg);
                 wire_chgs:=wire_chgs+1
                 
             }
             else 
             {
                  skip 
             };
             ucxxo2_acellptr->cblock:=bblock;
             ucxxo2_acellptr->cxcenter:=ucxxo2_bxcenter;
             ucxxo2_acellptr->cycenter:=ucxxo2_bycenter;
             ucxxo2_bcellptr->cblock:=ablock;
             ucxxo2_bcellptr->cxcenter:=ucxxo2_axcenter;
             ucxxo2_bcellptr->cycenter:=ucxxo2_aycenter;
             ucxxo2_acellptr->corient:=newaor;
             ucxxo2_bcellptr->corient:=newbor;
             funccost:=ucxxo2_cost;
             binpenal:=newbinpenal;
             rowpenal:=newrowpenal;
             penalty:=newpenal;
             if(ablock!=bblock) then 
             {
                 barray[ablock]->oldsize:=barray[ablock]->newsize;
                 barray[bblock]->oldsize:=barray[bblock]->newsize
                 
             }
             else 
             {
                  skip 
             };
             return<==1 and RValue:=1;
             skip
         }
         else
         {
             return<==1 and RValue:=0;
             skip
         }
     }
     else
     {
         skip
     }
     )
     }; 
  function ucxxp ( int a,int b,int anxcenter,int bnxcenter, int RValue )
 {
     frame(ucxxp_acellptr,ucxxp_bcellptr,ucxxp_atileptr,ucxxp_btileptr,ucxxp_atermptr,ucxxp_btermptr,ucxxp_cost,ucxxp_aorient,ucxxp_borient,ucxxp_aycenter,ucxxp_bycenter,ucxxp_truth,return) and ( 
     int return<==0 and skip;
     cellbox* ucxxp_acellptr,*ucxxp_bcellptr and skip;
     tilebox* ucxxp_atileptr,*ucxxp_btileptr and skip;
     termbox* ucxxp_atermptr,*ucxxp_btermptr and skip;
     int ucxxp_cost and skip;
     int ucxxp_aorient,ucxxp_borient and skip;
     int ucxxp_aycenter,ucxxp_bycenter and skip;
     int ucxxp_truth and skip;
     ucxxp_acellptr:=carray[a];
     ucxxp_aycenter:=ucxxp_acellptr->cycenter;
     ucxxp_aorient:=ucxxp_acellptr->corient;
     ucxxp_atileptr:=ucxxp_acellptr->tileptr;
     ucxxp_atermptr:=ucxxp_atileptr->termsptr;
     ucxxp_bcellptr:=carray[b];
     ucxxp_bycenter:=ucxxp_bcellptr->cycenter;
     ucxxp_borient:=ucxxp_bcellptr->corient;
     ucxxp_btileptr:=ucxxp_bcellptr->tileptr;
     ucxxp_btermptr:=ucxxp_btileptr->termsptr;
     term_newpos(ucxxp_atermptr,anxcenter,ucxxp_bycenter,ucxxp_aorient);
     term_newpos(ucxxp_btermptr,bnxcenter,ucxxp_aycenter,ucxxp_borient);
     ucxxp_cost:=funccost;
     new_dbox(ucxxp_atermptr,&ucxxp_cost);
     new_dbox(ucxxp_btermptr,&ucxxp_cost);
     ucxxp_truth:=acceptt(funccost-ucxxp_cost,RValue);
     if(ucxxp_truth=1) then 
     {
         dbox_pos(ucxxp_atermptr);
         dbox_pos(ucxxp_btermptr);
         ucxxp_acellptr->cxcenter:=anxcenter;
         ucxxp_acellptr->cycenter:=ucxxp_bycenter;
         ucxxp_bcellptr->cxcenter:=bnxcenter;
         ucxxp_bcellptr->cycenter:=ucxxp_aycenter;
         funccost:=ucxxp_cost;
         return<==1 and RValue:=1;
         skip
     }
     else
     {
         return<==1 and RValue:=0;
         skip
     }
     )
     }; 
  function uglobe ( int RValue )
 {
     frame(uglobe_netptr,uglobe_cellptr1,uglobe_cellptr2,uglobe_group1,uglobe_group2,uglobe_edge,uglobe_i,uglobe_pin,uglobe_net,uglobe_group,uglobe_cell1,uglobe_cell2,uglobe_top,uglobe_extint,uglobe_block,uglobe_locX,uglobe_locY,uglobe_flag1,uglobe_flag2,uglobe_chgloop,uglobe_found,uglobe_type1,uglobe_unequiv,uglobe_added_an_edge,uglobe_ue_grp,uglobe_g1,uglobe_g2,uglobe_ei1,uglobe_ei2,uglobe_ei,uglobe_done,uglobe_edge2,uglobe_jj,uglobe_a1,uglobe_b1,uglobe_a2,uglobe_b2,uglobe_edge1,uglobe_ya,uglobe_yb,uglobe_single_pin1,uglobe_single_pin2,uglobe_unequiv1,uglobe_unequiv2,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     netbox* uglobe_netptr and skip;
     cellbox* uglobe_cellptr1,*uglobe_cellptr2 and skip;
     int uglobe_group1,uglobe_group2,uglobe_edge,uglobe_i,uglobe_pin,uglobe_net,uglobe_group,uglobe_cell1,uglobe_cell2 and skip;
     int uglobe_top,uglobe_extint,uglobe_block,uglobe_locX,uglobe_locY and skip;
     int uglobe_flag1,uglobe_flag2,uglobe_chgloop and skip;
     int uglobe_found,uglobe_type1 and skip;
     int uglobe_unequiv,uglobe_added_an_edge,uglobe_ue_grp,uglobe_g1,uglobe_g2,uglobe_ei1,uglobe_ei2 and skip;
     int uglobe_ei,uglobe_done,uglobe_edge2,uglobe_jj and skip;
     int uglobe_a1,uglobe_b1,uglobe_a2,uglobe_b2,uglobe_edge1,uglobe_ya,uglobe_yb and skip;
     int uglobe_single_pin1,uglobe_single_pin2,uglobe_unequiv1,uglobe_unequiv2 and skip;
     uglobe_i:=0;
     
     while(uglobe_i<=MPG)
     {
         groupArray[uglobe_i].numPins:=0;
         groupArray[uglobe_i].flag:=0;
         groupArray[uglobe_i].poison:=0;
         groupArray[uglobe_i].unequiv:=0;
         groupArray[uglobe_i].extint:=0;
         groupArray[uglobe_i].edge1:=0;
         groupArray[uglobe_i].edge2:=0;
         groupArray[uglobe_i].check:=0;
         uglobe_i:=uglobe_i+1
         
     };
     uglobe_i:=0;
     
     while(uglobe_i<=ME)
     {
         edgeArray[uglobe_i].marked:=0;
         edgeArray[uglobe_i].done:=0;
         edgeArray[uglobe_i].poison:=0;
         uglobe_i:=uglobe_i+1
         
     };
     continue<==0 and skip;
     uglobe_chgloop:=1;
     
     while(uglobe_chgloop<=netchgs[0])
     {
          continue<==0 and skip;
         uglobe_net:=netchgs[uglobe_chgloop];
         numEdges:=0;
         top_row:=-1;
         uglobe_jj:=0;
         
         while(uglobe_jj<=numRows+1)
         {
             pseudoPins[uglobe_jj,0]:=0;
             pseudoPins[uglobe_jj,1]:=0;
             pseudoEdge[uglobe_jj,0]:=0;
             pseudoEdge[uglobe_jj,1]:=0;
             uglobe_jj:=uglobe_jj+1
             
         };
         uglobe_netptr:=netarray[uglobe_net]->netptr;
         while(uglobe_netptr!=NULL)
         {
             uglobe_top:=uglobe_netptr->pinloc;
             uglobe_extint:=uglobe_netptr->extint;
             uglobe_unequiv:=uglobe_netptr->unequiv;
             uglobe_block:=uglobe_netptr->row;
             if(uglobe_block>top_row) then 
             {
                 if(uglobe_netptr->cell<=numcells) then 
                 {
                     top_row:=uglobe_block
                 }
                 else
                 {
                     if(carray[uglobe_netptr->cell]->padside!=1 AND carray[uglobe_netptr->cell]->padside!=3) then 
                     {
                         top_row:=uglobe_block
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 
             }
             else 
             {
                  skip 
             };
             uglobe_locX:=uglobe_netptr->xpos;
             uglobe_locY:=uglobe_netptr->ypos;
             uglobe_pin:=uglobe_netptr->terminal;
             uglobe_found:=0;
             uglobe_group:=1;
             while(groupArray[uglobe_group].numPins!=0 AND uglobe_found=0)
             {
                 if(groupArray[uglobe_group].extint=uglobe_extint AND uglobe_unequiv=0) then 
                 {
                     uglobe_found:=1
                 }
                 else
                 {
                     uglobe_group:=uglobe_group+1
                 }
             };
             numPins:=groupArray[uglobe_group].numPins+1;
             groupArray[uglobe_group].numPins:=numPins;
             groupArray[uglobe_group].pinArray[numPins].xloc:=uglobe_locX;
             groupArray[uglobe_group].pinArray[numPins].yloc:=uglobe_locY;
             groupArray[uglobe_group].pinArray[numPins].top:=uglobe_top;
             groupArray[uglobe_group].pinArray[numPins].pin:=uglobe_pin;
             if(uglobe_found=0) then 
             {
                 groupArray[uglobe_group].aveX:=uglobe_locX;
                 groupArray[uglobe_group].aveY:=uglobe_locY;
                 groupArray[uglobe_group].extint:=uglobe_extint;
                 groupArray[uglobe_group].unequiv:=uglobe_unequiv;
                 groupArray[uglobe_group].block:=uglobe_block
                 
             }
             else
             {
                 groupArray[uglobe_group].aveX:=groupArray[uglobe_group].aveX+uglobe_locX;
                 groupArray[uglobe_group].aveY:=groupArray[uglobe_group].aveY+uglobe_locY
             };
             uglobe_netptr:=uglobe_netptr->nterm
             
         };
         uglobe_group:=1;
         uglobe_group:=1;
         
         while(groupArray[uglobe_group].numPins!=0)
         {
             numPins:=groupArray[uglobe_group].numPins;
             if(numPins>1) then 
             {
                 groupArray[uglobe_group].aveX:=groupArray[uglobe_group].aveX/ numPins;
                 groupArray[uglobe_group].aveY:=groupArray[uglobe_group].aveY/ numPins
                 
             }
             else 
             {
                  skip 
             };
             uglobe_group:=uglobe_group+1
             
         };
         numGroups:=0;
         while(groupArray[numGroups+1].numPins!=0)
         {
             numGroups:=numGroups+1
         };
         if(numGroups=2) then 
         {
             if(groupArray[1].unequiv=1 AND groupArray[2].unequiv=1) then 
             {
                 uglobe_i:=1;
                 
                 while(uglobe_i<=numGroups)
                 {
                     groupArray[uglobe_i].numPins:=0;
                     groupArray[uglobe_i].flag:=0;
                     groupArray[uglobe_i].poison:=0;
                     groupArray[uglobe_i].unequiv:=0;
                     groupArray[uglobe_i].extint:=0;
                     groupArray[uglobe_i].edge1:=0;
                     groupArray[uglobe_i].edge2:=0;
                     groupArray[uglobe_i].check:=0;
                     uglobe_i:=uglobe_i+1
                     
                 };
                 uglobe_i:=1;
                 
                 while(uglobe_i<=numEdges)
                 {
                     edgeArray[uglobe_i].marked:=0;
                     edgeArray[uglobe_i].done:=0;
                     edgeArray[uglobe_i].poison:=0;
                     uglobe_i:=uglobe_i+1
                     
                 };
                 continue<==1 and skip
                  
             }
             else 
             {
                  skip 
             }
             
         }
         else
         {
             if(numGroups<=1) then 
             {
                 uglobe_i:=1;
                 
                 while(uglobe_i<=numGroups)
                 {
                     groupArray[uglobe_i].numPins:=0;
                     groupArray[uglobe_i].flag:=0;
                     groupArray[uglobe_i].poison:=0;
                     groupArray[uglobe_i].unequiv:=0;
                     groupArray[uglobe_i].extint:=0;
                     groupArray[uglobe_i].edge1:=0;
                     groupArray[uglobe_i].edge2:=0;
                     groupArray[uglobe_i].check:=0;
                     uglobe_i:=uglobe_i+1
                     
                 };
                 uglobe_i:=1;
                 
                 while(uglobe_i<=numEdges)
                 {
                     edgeArray[uglobe_i].marked:=0;
                     edgeArray[uglobe_i].done:=0;
                     edgeArray[uglobe_i].poison:=0;
                     uglobe_i:=uglobe_i+1
                     
                 };
                 continue<==1 and skip
                  
             }
             else 
             {
                  skip 
             }
         };
         if(continue=0)  then 
         {
             qsortg((char *)(groupArray+1),numGroups,sizeof(csGroup));
             uglobe_group:=1;
             
             while(uglobe_group<numGroups)
             {
                 uglobe_block:=groupArray[uglobe_group].block;
                 uglobe_type1:=detGroup(uglobe_group,RValue);
                 searchG(uglobe_group,uglobe_type1,uglobe_block,RValue);
                 uglobe_group:=uglobe_group+1
                 
             };
             continue<==0 and skip;
             uglobe_edge1:=1;
             
             while(uglobe_edge1<=numEdges)
             {
                  continue<==0 and skip;
                 uglobe_a1:=edgeArray[uglobe_edge1].group1;
                 uglobe_a2:=edgeArray[uglobe_edge1].group2;
                 if(groupArray[uglobe_a1].block!=groupArray[uglobe_a2].block) then 
                 {
                     continue<==1 and skip;
                      uglobe_edge1:=uglobe_edge1+1
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     continue<==0 and skip;
                     break$<==0 and skip;
                     uglobe_edge2:=uglobe_edge1+1;
                     
                     while( break$=0 AND  uglobe_edge2<=numEdges)
                     {
                          continue<==0 and skip;
                         uglobe_b1:=edgeArray[uglobe_edge2].group1;
                         uglobe_b2:=edgeArray[uglobe_edge2].group2;
                         if(groupArray[uglobe_b1].block!=groupArray[uglobe_b2].block) then 
                         {
                             continue<==1 and skip;
                              uglobe_edge2:=uglobe_edge2+1
                         }
                         else 
                         {
                              skip 
                         };
                         if(continue=0)   then 
                         {
                             if((groupArray[uglobe_a1].unequiv=1 AND groupArray[uglobe_b1].unequiv=1 AND groupArray[uglobe_a1].extint=groupArray[uglobe_b1].extint AND groupArray[uglobe_a2].extint=groupArray[uglobe_b2].extint) OR (groupArray[uglobe_a2].unequiv=1 AND groupArray[uglobe_b2].unequiv=1 AND groupArray[uglobe_a2].extint=groupArray[uglobe_b2].extint AND groupArray[uglobe_a1].extint=groupArray[uglobe_b1].extint)) then 
                             {
                                 uglobe_ya:=(groupArray[uglobe_a1].aveY+groupArray[uglobe_a2].aveY)/ 2;
                                 uglobe_yb:=(groupArray[uglobe_b1].aveY+groupArray[uglobe_b2].aveY)/ 2;
                                 if(groupArray[uglobe_a1].block=top_row) then 
                                 {
                                     if(uglobe_ya<uglobe_yb) then 
                                     {
                                         if(edgeArray[uglobe_edge2].cost<=edgeArray[uglobe_edge1].cost) then 
                                         {
                                             edgeArray[uglobe_edge2].cost:=edgeArray[uglobe_edge1].cost+1
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     }
                                     else
                                     {
                                         if(edgeArray[uglobe_edge2].cost>=edgeArray[uglobe_edge1].cost) then 
                                         {
                                             edgeArray[uglobe_edge2].cost:=edgeArray[uglobe_edge1].cost-1
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     }
                                     
                                 }
                                 else
                                 {
                                     if(uglobe_ya<uglobe_yb) then 
                                     {
                                         if(edgeArray[uglobe_edge2].cost>=edgeArray[uglobe_edge1].cost) then 
                                         {
                                             edgeArray[uglobe_edge2].cost:=edgeArray[uglobe_edge1].cost-1
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     }
                                     else
                                     {
                                         if(edgeArray[uglobe_edge2].cost<=edgeArray[uglobe_edge1].cost) then 
                                         {
                                             edgeArray[uglobe_edge2].cost:=edgeArray[uglobe_edge1].cost+1
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                     }
                                 };
                                 break$<==1 and skip
                                  
                             }
                             else 
                             {
                                  skip 
                             };
                             if(break$=0)   then
                             {
                                 uglobe_edge2:=uglobe_edge2+1
                             }
                             else
                             {
                                 skip
                             }
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     break$<==0 and skip;
                     continue<==0 and skip;
                     uglobe_edge1:=uglobe_edge1+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             continue<==0 and skip;
             qsorte((char *)(edgeArray+1),numEdges,sizeof(edgeBox));
             uglobe_group:=1;
             
             while(uglobe_group<=numGroups)
             {
                 groupArray[uglobe_group].flag:=uglobe_group;
                 uglobe_group:=uglobe_group+1
                 
             };
             continue<==0 and skip;
             uglobe_edge:=1;
             
             while(uglobe_edge<=numEdges)
             {
                  continue<==0 and skip;
                 uglobe_group1:=edgeArray[uglobe_edge].group1;
                 uglobe_flag1:=groupArray[uglobe_group1].flag;
                 uglobe_group2:=edgeArray[uglobe_edge].group2;
                 uglobe_flag2:=groupArray[uglobe_group2].flag;
                 if(uglobe_flag1<=0 OR uglobe_flag2<=0 OR uglobe_flag1=uglobe_flag2) then 
                 {
                     continue<==1 and skip;
                      uglobe_edge:=uglobe_edge+1
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     uglobe_added_an_edge:=0;
                     edgeArray[uglobe_edge].marked:=1;
                     uglobe_group:=1;
                     
                     while(uglobe_group<=numGroups)
                     {
                         if(groupArray[uglobe_group].flag=uglobe_flag2) then 
                         {
                             groupArray[uglobe_group].flag:=uglobe_flag1
                             
                         }
                         else 
                         {
                              skip 
                         };
                         uglobe_group:=uglobe_group+1
                         
                     };
                     uglobe_cell1:=tearray[groupArray[uglobe_group1].pinArray[1].pin]->cell;
                     uglobe_cell2:=tearray[groupArray[uglobe_group2].pinArray[1].pin]->cell;
                     uglobe_cellptr1:=carray[uglobe_cell1];
                     uglobe_cellptr2:=carray[uglobe_cell2];
                     if(uglobe_cell1>numcells AND uglobe_cellptr1->padside!=2 AND uglobe_cellptr1->padside!=14 AND uglobe_cellptr1->padside!=15 AND uglobe_cellptr1->padside!=4) then 
                     {
                         if(uglobe_cell2<=numcells) then 
                         {
                             groupArray[uglobe_group1].flag:=0
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(uglobe_cell2>numcells AND uglobe_cellptr2->padside!=2 AND uglobe_cellptr2->padside!=14 AND uglobe_cellptr2->padside!=15 AND uglobe_cellptr2->padside!=4) then 
                     {
                         if(uglobe_cell1<=numcells) then 
                         {
                             groupArray[uglobe_group2].flag:=0
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(groupArray[uglobe_group1].unequiv=1) then 
                     {
                         uglobe_ei1:=groupArray[uglobe_group1].extint;
                         continue<==0 and skip;
                         break$<==0 and skip;
                         uglobe_ue_grp:=1;
                         
                         while( break$=0 AND  uglobe_ue_grp<=numGroups)
                         {
                              continue<==0 and skip;
                             if(uglobe_ue_grp=uglobe_group1) then 
                             {
                                 continue<==1 and skip;
                                  uglobe_ue_grp:=uglobe_ue_grp+1
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)   then 
                             {
                                 if(groupArray[uglobe_ue_grp].extint=uglobe_ei1) then 
                                 {
                                     break$<==1 and skip
                                      
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(break$=0)   then
                                 {
                                     uglobe_ue_grp:=uglobe_ue_grp+1
                                 }
                                 else
                                 {
                                     skip
                                 }
                             }
                             else
                             {
                                 skip
                             }
                             
                         };
                         break$<==0 and skip;
                         continue<==0 and skip;
                         if(groupArray[uglobe_ue_grp].flag>0) then 
                         {
                             uglobe_g2<==0 and uglobe_g1<==uglobe_g2 and skip;
                             groupArray[uglobe_ue_grp].flag:=-1;
                             continue<==0 and skip;
                             uglobe_edge2:=uglobe_edge+1;
                             
                             while(uglobe_edge2<=numEdges)
                             {
                                  continue<==0 and skip;
                                 if(uglobe_g2=0) then 
                                 {
                                     if(edgeArray[uglobe_edge2].group1=uglobe_ue_grp) then 
                                     {
                                         uglobe_g2:=edgeArray[uglobe_edge2].group2;
                                         if(groupArray[uglobe_g2].flag<0) then 
                                         {
                                             uglobe_g2:=0
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         continue<==1 and skip;
                                          uglobe_edge2:=uglobe_edge2+1
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(continue=0)  then
                                 {
                                     if(uglobe_g1=0) then 
                                     {
                                         if(edgeArray[uglobe_edge2].group2=uglobe_ue_grp) then 
                                         {
                                             uglobe_g1:=edgeArray[uglobe_edge2].group1;
                                             if(groupArray[uglobe_g1].flag<0) then 
                                             {
                                                 uglobe_g1:=0
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     uglobe_edge2:=uglobe_edge2+1
                                 }
                                 else
                                 {
                                     skip
                                 }
                                 
                             };
                             continue<==0 and skip;
                             if(uglobe_g1!=0 AND uglobe_g2!=0) then 
                             {
                                 addEdge(uglobe_g1,uglobe_g2,RValue);
                                 uglobe_added_an_edge:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(groupArray[uglobe_group2].unequiv=1) then 
                     {
                         uglobe_ei2:=groupArray[uglobe_group2].extint;
                         continue<==0 and skip;
                         break$<==0 and skip;
                         uglobe_ue_grp:=1;
                         
                         while( break$=0 AND  uglobe_ue_grp<=numGroups)
                         {
                              continue<==0 and skip;
                             if(uglobe_ue_grp=uglobe_group2) then 
                             {
                                 continue<==1 and skip;
                                  uglobe_ue_grp:=uglobe_ue_grp+1
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)   then 
                             {
                                 if(groupArray[uglobe_ue_grp].extint=uglobe_ei2) then 
                                 {
                                     break$<==1 and skip
                                      
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(break$=0)   then
                                 {
                                     uglobe_ue_grp:=uglobe_ue_grp+1
                                 }
                                 else
                                 {
                                     skip
                                 }
                             }
                             else
                             {
                                 skip
                             }
                             
                         };
                         break$<==0 and skip;
                         continue<==0 and skip;
                         if(groupArray[uglobe_ue_grp].flag>0) then 
                         {
                             uglobe_g2<==0 and uglobe_g1<==uglobe_g2 and skip;
                             groupArray[uglobe_ue_grp].flag:=-1;
                             continue<==0 and skip;
                             uglobe_edge2:=uglobe_edge+1;
                             
                             while(uglobe_edge2<=numEdges)
                             {
                                  continue<==0 and skip;
                                 if(uglobe_g2=0) then 
                                 {
                                     if(edgeArray[uglobe_edge2].group1=uglobe_ue_grp) then 
                                     {
                                         uglobe_g2:=edgeArray[uglobe_edge2].group2;
                                         if(groupArray[uglobe_g2].flag<0) then 
                                         {
                                             uglobe_g2:=0
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         continue<==1 and skip;
                                          uglobe_edge2:=uglobe_edge2+1
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(continue=0)  then
                                 {
                                     if(uglobe_g1=0) then 
                                     {
                                         if(edgeArray[uglobe_edge2].group2=uglobe_ue_grp) then 
                                         {
                                             uglobe_g1:=edgeArray[uglobe_edge2].group1;
                                             if(groupArray[uglobe_g1].flag<0) then 
                                             {
                                                 uglobe_g1:=0
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         }
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     uglobe_edge2:=uglobe_edge2+1
                                 }
                                 else
                                 {
                                     skip
                                 }
                                 
                             };
                             continue<==0 and skip;
                             if(uglobe_g1!=0 AND uglobe_g2!=0) then 
                             {
                                 addEdge(uglobe_g1,uglobe_g2,RValue);
                                 uglobe_added_an_edge:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(uglobe_added_an_edge=1) then 
                     {
                         continue<==0 and skip;
                         uglobe_edge1:=uglobe_edge+1;
                         
                         while(uglobe_edge1<=numEdges)
                         {
                              continue<==0 and skip;
                             uglobe_a1:=edgeArray[uglobe_edge1].group1;
                             uglobe_a2:=edgeArray[uglobe_edge1].group2;
                             if(groupArray[uglobe_a1].block!=groupArray[uglobe_a2].block) then 
                             {
                                 continue<==1 and skip;
                                  uglobe_edge1:=uglobe_edge1+1
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)   then 
                             {
                                 continue<==0 and skip;
                                 break$<==0 and skip;
                                 uglobe_edge2:=uglobe_edge1+1;
                                 
                                 while( break$=0 AND  uglobe_edge2<=numEdges)
                                 {
                                      continue<==0 and skip;
                                     uglobe_b1:=edgeArray[uglobe_edge2].group1;
                                     uglobe_b2:=edgeArray[uglobe_edge2].group2;
                                     if(groupArray[uglobe_b1].block!=groupArray[uglobe_b2].block) then 
                                     {
                                         continue<==1 and skip;
                                          uglobe_edge2:=uglobe_edge2+1
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     if(continue=0)   then 
                                     {
                                         if((groupArray[uglobe_a1].unequiv=1 AND groupArray[uglobe_b1].unequiv=1 AND groupArray[uglobe_a1].extint=groupArray[uglobe_b1].extint AND groupArray[uglobe_a2].extint=groupArray[uglobe_b2].extint) OR (groupArray[uglobe_a2].unequiv=1 AND groupArray[uglobe_b2].unequiv=1 AND groupArray[uglobe_a2].extint=groupArray[uglobe_b2].extint AND groupArray[uglobe_a1].extint=groupArray[uglobe_b1].extint)) then 
                                         {
                                             uglobe_ya:=(groupArray[uglobe_a1].aveY+groupArray[uglobe_a2].aveY)/ 2;
                                             uglobe_yb:=(groupArray[uglobe_b1].aveY+groupArray[uglobe_b2].aveY)/ 2;
                                             if(groupArray[uglobe_a1].block=top_row) then 
                                             {
                                                 if(uglobe_ya<uglobe_yb) then 
                                                 {
                                                     if(edgeArray[uglobe_edge2].cost<=edgeArray[uglobe_edge1].cost) then 
                                                     {
                                                         edgeArray[uglobe_edge2].cost:=edgeArray[uglobe_edge1].cost+1
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                                 else
                                                 {
                                                     if(edgeArray[uglobe_edge2].cost>=edgeArray[uglobe_edge1].cost) then 
                                                     {
                                                         edgeArray[uglobe_edge2].cost:=edgeArray[uglobe_edge1].cost-1
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                                 
                                             }
                                             else
                                             {
                                                 if(uglobe_ya<uglobe_yb) then 
                                                 {
                                                     if(edgeArray[uglobe_edge2].cost>=edgeArray[uglobe_edge1].cost) then 
                                                     {
                                                         edgeArray[uglobe_edge2].cost:=edgeArray[uglobe_edge1].cost-1
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                                 else
                                                 {
                                                     if(edgeArray[uglobe_edge2].cost<=edgeArray[uglobe_edge1].cost) then 
                                                     {
                                                         edgeArray[uglobe_edge2].cost:=edgeArray[uglobe_edge1].cost+1
                                                         
                                                     }
                                                     else 
                                                     {
                                                          skip 
                                                     }
                                                 }
                                             };
                                             break$<==1 and skip
                                              
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         if(break$=0)   then
                                         {
                                             uglobe_edge2:=uglobe_edge2+1
                                         }
                                         else
                                         {
                                             skip
                                         }
                                     }
                                     else
                                     {
                                         skip
                                     }
                                     
                                 };
                                 break$<==0 and skip;
                                 continue<==0 and skip;
                                 uglobe_edge1:=uglobe_edge1+1
                             }
                             else
                             {
                                 skip
                             }
                             
                         };
                         continue<==0 and skip;
                         qsorte((char *)(edgeArray+1+uglobe_edge),numEdges-uglobe_edge,sizeof(edgeBox))
                         
                     }
                     else 
                     {
                          skip 
                     };
                     uglobe_edge:=uglobe_edge+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             continue<==0 and skip;
             continue<==0 and skip;
             uglobe_group:=1;
             
             while(uglobe_group<=numGroups)
             {
                  continue<==0 and skip;
                 if(groupArray[uglobe_group].flag<0) then 
                 {
                     continue<==1 and skip;
                      uglobe_group:=uglobe_group+1
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     if(groupArray[uglobe_group].unequiv!=1) then 
                     {
                         continue<==1 and skip;
                          uglobe_group:=uglobe_group+1
                     }
                     else 
                     {
                          skip 
                     };
                     if(continue=0)   then 
                     {
                         uglobe_ei:=groupArray[uglobe_group].extint;
                         break$<==0 and skip;
                         uglobe_group2:=uglobe_group+1;
                         
                         while( break$=0 AND  uglobe_group2<=numGroups)
                         {
                             if(groupArray[uglobe_group2].extint=uglobe_ei) then 
                             {
                                 if(groupArray[uglobe_group2].flag>=0) then 
                                 {
                                     groupArray[uglobe_group2].flag:=-1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 break$<==1 and skip
                                  
                             }
                             else 
                             {
                                  skip 
                             };
                             if(break$=0)   then
                             {
                                 uglobe_group2:=uglobe_group2+1
                             }
                             else
                             {
                                 skip
                             }
                             
                         };
                         break$<==0 and skip;
                         uglobe_group:=uglobe_group+1
                     }
                     else
                     {
                         skip
                     }
                 }
                 else
                 {
                     skip
                 }
                 
             };
             continue<==0 and skip;
             uglobe_done:=0;
             while(uglobe_done=0)
             {
                 uglobe_done:=1;
                 uglobe_edge:=1;
                 
                 while(uglobe_edge<=numEdges)
                 {
                     if(edgeArray[uglobe_edge].marked=1 AND edgeArray[uglobe_edge].poison=0) then 
                     {
                         uglobe_g1:=edgeArray[uglobe_edge].group1;
                         uglobe_g2:=edgeArray[uglobe_edge].group2;
                         uglobe_unequiv1:=groupArray[uglobe_g1].unequiv;
                         if(uglobe_unequiv1=0) then 
                         {
                             if(groupArray[uglobe_g1].numPins=1 AND groupArray[uglobe_g1].pinArray[1].top!=0) then 
                             {
                                 uglobe_single_pin1:=1;
                                 uglobe_unequiv1:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         uglobe_unequiv2:=groupArray[uglobe_g2].unequiv;
                         if(uglobe_unequiv2=0) then 
                         {
                             if(groupArray[uglobe_g2].numPins=1 AND groupArray[uglobe_g2].pinArray[1].top!=0) then 
                             {
                                 uglobe_single_pin2:=1;
                                 uglobe_unequiv2:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if((groupArray[uglobe_g1].poison=1) OR (groupArray[uglobe_g2].poison=1)) then 
                         {
                             uglobe_done:=0;
                             edgeArray[uglobe_edge].poison:=1;
                             if(uglobe_unequiv1=1) then 
                             {
                                 groupArray[uglobe_g1].poison:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             if(uglobe_unequiv2=1) then 
                             {
                                 groupArray[uglobe_g2].poison:=1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                         }
                         else
                         {
                             if(groupArray[uglobe_g1].block!=groupArray[uglobe_g2].block) then 
                             {
                                 uglobe_done:=0;
                                 edgeArray[uglobe_edge].poison:=1;
                                 if(uglobe_unequiv1=1) then 
                                 {
                                     groupArray[uglobe_g1].poison:=1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(uglobe_unequiv2=1) then 
                                 {
                                     groupArray[uglobe_g2].poison:=1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                             else
                             {
                                 if(uglobe_single_pin1=1 OR uglobe_single_pin2=1) then 
                                 {
                                     uglobe_done:=0;
                                     edgeArray[uglobe_edge].poison:=1;
                                     if(uglobe_unequiv1=1) then 
                                     {
                                         groupArray[uglobe_g1].poison:=1
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     if(uglobe_unequiv2=1) then 
                                     {
                                         groupArray[uglobe_g2].poison:=1
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };
                     uglobe_edge:=uglobe_edge+1
                     
                 }
             };
             uglobe_edge:=1;
             
             while(uglobe_edge<=numEdges)
             {
                 if(edgeArray[uglobe_edge].marked=1 AND edgeArray[uglobe_edge].poison=0) then 
                 {
                     uglobe_g1:=edgeArray[uglobe_edge].group1;
                     uglobe_g2:=edgeArray[uglobe_edge].group2;
                     if(groupArray[uglobe_g1].unequiv=0 AND groupArray[uglobe_g2].unequiv=0) then 
                     {
                         edgeArray[uglobe_edge].poison:=1
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(groupArray[uglobe_g1].unequiv=0) then 
                     {
                         groupArray[uglobe_g1].poison:=1
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(groupArray[uglobe_g2].unequiv=0) then 
                     {
                         groupArray[uglobe_g2].poison:=1
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 uglobe_edge:=uglobe_edge+1
                 
             };
             break$<==0 and skip;
             uglobe_edge:=1;
             
             while( break$=0 AND  uglobe_edge<=numEdges)
             {
                 if(edgeArray[uglobe_edge].marked=1 AND edgeArray[uglobe_edge].poison=0) then 
                 {
                     uglobe_g1:=edgeArray[uglobe_edge].group1;
                     uglobe_g2:=edgeArray[uglobe_edge].group2;
                     if(groupArray[uglobe_g1].edge1=0) then 
                     {
                         groupArray[uglobe_g1].edge1:=uglobe_edge
                         
                     }
                     else
                     {
                         groupArray[uglobe_g1].edge2:=uglobe_edge
                     };
                     if(groupArray[uglobe_g2].edge1=0) then 
                     {
                         groupArray[uglobe_g2].edge1:=uglobe_edge
                         
                     }
                     else
                     {
                         groupArray[uglobe_g2].edge2:=uglobe_edge
                     };
                     if(groupArray[uglobe_g1].poison=0) then 
                     {
                         uglobe_ei:=groupArray[uglobe_g1].extint;
                         continue<==0 and skip;
                         uglobe_group:=1;
                         
                         while(break$=0 AND true)
                         {
                              continue<==0 and skip;
                             if((uglobe_group=uglobe_g1) OR (groupArray[uglobe_group].extint!=uglobe_ei)) then 
                             {
                                 continue<==1 and skip;
                                  uglobe_group:=uglobe_group+1
                             }
                             else 
                             {
                                  skip 
                             };
                             if(continue=0)   then 
                             {
                                 break$<==1 and skip
                             }
                             else
                             {
                                 skip
                             }
                             
                         };
						 break$<==0 and skip;
                         continue<==0 and skip;
                         groupArray[uglobe_g1].numPins:=2;
                         groupArray[uglobe_g1].pinArray[2].xloc:=groupArray[uglobe_group].pinArray[1].xloc;
                         groupArray[uglobe_g1].pinArray[2].yloc:=groupArray[uglobe_group].pinArray[1].yloc;
                         groupArray[uglobe_g1].pinArray[2].top:=groupArray[uglobe_group].pinArray[1].top;
                         groupArray[uglobe_g1].pinArray[2].pin:=groupArray[uglobe_group].pinArray[1].pin
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(break$=0)   then
                     {
                         if(groupArray[uglobe_g2].poison=0) then 
                         {
                             uglobe_ei:=groupArray[uglobe_g2].extint;
                             continue<==0 and skip;
                             uglobe_group:=1;
                             
                             while(break$=1 AND true)
                             {
                                  continue<==0 and skip;
                                 if((uglobe_group=uglobe_g2) OR (groupArray[uglobe_group].extint!=uglobe_ei)) then 
                                 {
                                     continue<==1 and skip;
                                      uglobe_group:=uglobe_group+1
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 if(continue=0)   then 
                                 {
                                     break$<==1 and skip
                                 }
                                 else
                                 {
                                     skip
                                 }
                                 
                             };
							  break$<==0 and skip;
                             continue<==0 and skip;
                             groupArray[uglobe_g2].numPins:=2;
                             groupArray[uglobe_g2].pinArray[2].xloc:=groupArray[uglobe_group].pinArray[1].xloc;
                             groupArray[uglobe_g2].pinArray[2].yloc:=groupArray[uglobe_group].pinArray[1].yloc;
                             groupArray[uglobe_g2].pinArray[2].top:=groupArray[uglobe_group].pinArray[1].top;
                             groupArray[uglobe_g2].pinArray[2].pin:=groupArray[uglobe_group].pinArray[1].pin
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                     else
                     {
                         skip
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then 
                 {
                     uglobe_edge:=uglobe_edge+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             uglobe_edge:=1;
             
             while(uglobe_edge<=numEdges)
             {
                 if(edgeArray[uglobe_edge].marked=1 AND edgeArray[uglobe_edge].poison=0) then 
                 {
                     uglobe_g1:=edgeArray[uglobe_edge].group1;
                     uglobe_g2:=edgeArray[uglobe_edge].group2;
                     if(groupArray[uglobe_g1].edge2=0 AND groupArray[uglobe_g2].edge2=0) then 
                     {
                         edgeArray[uglobe_edge].poison:=1
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 uglobe_edge:=uglobe_edge+1
                 
             };
             uclosepns(uglobe_net);
             uglobe_i:=1;
             
             while(uglobe_i<=numGroups)
             {
                 groupArray[uglobe_i].numPins:=0;
                 groupArray[uglobe_i].flag:=0;
                 groupArray[uglobe_i].poison:=0;
                 groupArray[uglobe_i].unequiv:=0;
                 groupArray[uglobe_i].extint:=0;
                 groupArray[uglobe_i].edge1:=0;
                 groupArray[uglobe_i].edge2:=0;
                 groupArray[uglobe_i].check:=0;
                 uglobe_i:=uglobe_i+1
                 
             };
             uglobe_i:=1;
             
             while(uglobe_i<=numEdges)
             {
                 edgeArray[uglobe_i].marked:=0;
                 edgeArray[uglobe_i].done:=0;
                 edgeArray[uglobe_i].poison:=0;
                 uglobe_i:=uglobe_i+1
                 
             };
             uglobe_chgloop:=uglobe_chgloop+1
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     uglobrout(RValue);
      return<==1 and skip
     )
     }; 
  function uglobrout ( int RValue )
 {
     frame(uglobrout_attperseg,uglobrout_attlimit,uglobrout_attempts,uglobrout_swSeg,uglobrout_stoppoint,uglobrout_breakpoint,uglobrout_found,uglobrout_channel,uglobrout_x,uglobrout_x1,uglobrout_x2,uglobrout_segptr,uglobrout_denptr,count$,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     int uglobrout_attperseg and skip;
     int uglobrout_attlimit,uglobrout_attempts,uglobrout_swSeg and skip;
     int uglobrout_stoppoint,uglobrout_breakpoint and skip;
     int uglobrout_found,uglobrout_channel and skip;
     int uglobrout_x,uglobrout_x1,uglobrout_x2 and skip;
     segbox* uglobrout_segptr and skip;
     densitybox* uglobrout_denptr and skip;
     uglobrout_attperseg:=5;
     unetseg(RValue);
     uglobrout_attlimit:=uglobrout_attperseg*numSwSegs;
     uglobrout_attempts:=0;
     uglobrout_breakpoint:=0;
     uglobrout_stoppoint:=1.5*numSwSegs;
     break$<==0 and skip;
     while( break$=0 AND  uglobrout_attempts<uglobrout_attlimit)
     {
         continue<==0 and skip;
         break$<==0 and skip;
         while( break$=0 AND  true)
         {
             int count$<==0 and skip;
             while( ( count$=0 OR uglobrout_swSeg=numSegs+1))
             {
                 count$:=count$+1;
                 uglobrout_swSeg:=(int)((float)numSegs*((float)(extern Yacm_random(RValue))/ (float)0x7fffffff))+1
             };
             if(aNetSeg[uglobrout_swSeg].nflag=1) then 
             {
                 if(aNetSeg[uglobrout_swSeg].nswYorN=1 AND aNetSeg[uglobrout_swSeg].nkey=0) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 }
             }
             else
             {
                 if(aNetSeg[uglobrout_swSeg].swYorN=1 AND aNetSeg[uglobrout_swSeg].key=0) then 
                 {
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 }
             }
             
         };
         break$<==0 and skip;
         if(aNetSeg[uglobrout_swSeg].nflag=0) then 
         {
             if(aNetSeg[uglobrout_swSeg].current=0) then 
             {
                 uglobrout_segptr:=aNetSeg[uglobrout_swSeg].top
             }
             else
             {
                 uglobrout_segptr:=aNetSeg[uglobrout_swSeg].bot
             }
             
         }
         else
         {
             if(aNetSeg[uglobrout_swSeg].ncurrent=0) then 
             {
                 uglobrout_segptr:=aNetSeg[uglobrout_swSeg].ntop
             }
             else
             {
                 uglobrout_segptr:=aNetSeg[uglobrout_swSeg].nbot
             }
         };
         uglobrout_channel:=uglobrout_segptr->channel;
         uglobrout_x1:=uglobrout_segptr->pin1ptr->netptr->xpos;
         uglobrout_x2:=uglobrout_segptr->pin2ptr->netptr->xpos;
         if((uglobrout_channel>gtopChan) OR (uglobrout_channel<gbotChan) OR (uglobrout_x2<Left_bound) OR (uglobrout_x1>Rite_bound)) then 
         {
             uglobrout_attempts:=uglobrout_attempts+1;
             continue<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             uglobrout_found:=0;
             break$<==0 and skip;
             uglobrout_denptr:=DboxHead[uglobrout_channel,nmaxTrack[uglobrout_channel]]->nnext;
             
             while( break$=0 AND  uglobrout_denptr!=NULL)
             {
                 uglobrout_x:=uglobrout_denptr->grdptr->netptr->xpos;
                 if(uglobrout_x1<=uglobrout_x AND uglobrout_x2>=uglobrout_x) then 
                 {
                     uglobrout_found:=1;
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     uglobrout_denptr:=uglobrout_denptr->nnext
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             if(!uglobrout_found) then 
             {
                 if((uglobrout_breakpoint+1)>uglobrout_stoppoint) then 
                 {
                     uglobrout_breakpoint:=uglobrout_breakpoint+1;
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                     uglobrout_breakpoint:=uglobrout_breakpoint+1
                     
                 };
                 if(break$=0)   then
                 {
                     uglobrout_attempts:=uglobrout_attempts+1;
                     continue<==1 and skip
                  }
                 else
                 {
                     skip
                 }
                 
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then 
             {
                 if(continue=0)   then 
                 {
                     if(extern purcost(uglobrout_swSeg,RValue)) then 
                     {
                         uglobrout_attempts:=uglobrout_attempts+1;
                         uglobrout_breakpoint:=0
                     }
                     else
                     {
                         if((uglobrout_breakpoint+1)>uglobrout_stoppoint) then 
                         {
                             uglobrout_breakpoint:=uglobrout_breakpoint+1;
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                             uglobrout_breakpoint:=uglobrout_breakpoint+1
                             
                         };
                         if(break$=0)   then
                         {
                             uglobrout_attempts:=uglobrout_attempts+1
                         }
                         else
                         {
                             skip
                         }
                     }

                 }
                 else
                 {
                     skip
                 }
             }
			  else
                     {
                         skip
                     }
         }
         else
         {
             skip
         }
     };
     break$<==0 and skip;
     continue<==0 and skip;
      return<==1 and skip
     )
     }; 
  function ugpair (  )
 {
     frame(ugpair_acellptr,ugpair_bcellptr,ugpair_ablckptr,ugpair_denptr,ugpair_a,ugpair_b,ugpair_ablock,ugpair_lowValue,ugpair_flips,ugpair_attempts,ugpair_segment,ugpair_axcenter,ugpair_bnxcenter,ugpair_anxcenter,ugpair_aleft,ugpair_aright,ugpair_aorient,ugpair_startx1,ugpair_endx1,ugpair_cellleft,ugpair_cellrite,ugpair_x,ugpair_leftEdge,ugpair_riteEdge,ugpair_aptr,ugpair_chan1,ugpair_chan2,ugpair_found,ugpair_breakpoint,ugpair_stoppoint,ugpair_r,count$,nm_3$,break$$,switch$,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     cellbox* ugpair_acellptr,*ugpair_bcellptr and skip;
     blockbox* ugpair_ablckptr and skip;
     densitybox* ugpair_denptr and skip;
     int ugpair_a,ugpair_b,ugpair_ablock,ugpair_lowValue and skip;
     int ugpair_flips,ugpair_attempts,ugpair_segment and skip;
     int ugpair_axcenter,ugpair_bnxcenter,ugpair_anxcenter and skip;
     int ugpair_aleft,ugpair_aright,ugpair_aorient and skip;
     int ugpair_startx1,ugpair_endx1 and skip;
     int ugpair_cellleft,ugpair_cellrite and skip;
     int ugpair_x and skip;
     int ugpair_leftEdge,ugpair_riteEdge and skip;
     int ugpair_aptr,ugpair_chan1,ugpair_chan2,ugpair_found and skip;
     int ugpair_breakpoint,ugpair_stoppoint and skip;
     float ugpair_r and skip;
     ugpair_lowValue:=tracks;
     Shuffle:=(changrdbox* *)safe_malloc(251*sizeof(changrdbox*),RValue);
     ugpair_segment:=1;
     
     while(ugpair_segment<=numSegs)
     {
         fixnetseg[ugpair_segment]:=aNetSeg[ugpair_segment].current;
         ugpair_segment:=ugpair_segment+1
         
     };
     ugpair_flips:=0;
     ugpair_attempts:=0;
     ugpair_breakpoint:=0;
     ugpair_stoppoint:=moveable_cells*stopdeg;
     while(ugpair_breakpoint<ugpair_stoppoint)
     {
         continue<==0 and skip;
         int count$<==0 and skip;
         while( ( count$=0 OR ugpair_ablock=numblock+1))
         {
             count$:=count$+1;
             ugpair_ablock:=(int)((float)numblock*((float)(extern Yacm_random(RValue))/ (float)0x7fffffff))+1
         };
         if(pairArray[ugpair_ablock,0]<=1) then 
         {
             continue<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             ugpair_chan1:=blkToRow[ugpair_ablock]+1;
             ugpair_chan2:=blkToRow[ugpair_ablock];
             ugpair_found:=0;
             
             while(ugpair_found=0)
             {
                 count$<==0 and skip;
                 while( ( count$=0 OR ugpair_aptr=pairArray[ugpair_ablock,0]+1))
                 {
                     count$:=count$+1;
                     ugpair_aptr:=(int)((float)pairArray[ugpair_ablock,0]*((float)(extern Yacm_random(RValue))/ (float)0x7fffffff))+1
                 };
                 ugpair_a:=pairArray[ugpair_ablock,ugpair_aptr];
                 ugpair_acellptr:=carray[ugpair_a];
                 ugpair_aorient:=ugpair_acellptr->corient;
                 ugpair_axcenter:=ugpair_acellptr->cxcenter;
                 ugpair_aleft:=ugpair_acellptr->tileptr->left;
                 ugpair_aright:=ugpair_acellptr->tileptr->right;
                 ugpair_startx1:=ugpair_axcenter+ugpair_aleft;
                 ugpair_endx1:=ugpair_axcenter+ugpair_aright;
                 break$<==0 and skip;
                 ugpair_denptr:=DboxHead[ugpair_chan1,maxTrack[ugpair_chan1]]->next$;
                 
                 while( break$=0 AND  ugpair_denptr!=NULL)
                 {
                     ugpair_x:=ugpair_denptr->grdptr->netptr->newx;
                     if(ugpair_startx1<=ugpair_x AND ugpair_endx1>=ugpair_x) then 
                     {
                         ugpair_found:=1;
                         break$<==1 and skip
                          
                     }
                     else 
                     {
                          skip 
                     };
                     if(break$=0)   then
                     {
                         ugpair_denptr:=ugpair_denptr->next$
                     }
                     else
                     {
                         skip
                     }
                     
                 };
                 break$<==0 and skip;
                 if(ugpair_found=0) then 
                 {
                     break$<==0 and skip;
                     ugpair_denptr:=DboxHead[ugpair_chan2,maxTrack[ugpair_chan2]]->next$;
                     
                     while( break$=0 AND  ugpair_denptr!=NULL)
                     {
                         ugpair_x:=ugpair_denptr->grdptr->netptr->newx;
                         if(ugpair_startx1<=ugpair_x AND ugpair_endx1>=ugpair_x) then 
                         {
                             ugpair_found:=1;
                             break$<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(break$=0)   then
                         {
                             ugpair_denptr:=ugpair_denptr->next$
                         }
                         else
                         {
                             skip
                         }
                     };
                     break$<==0 and skip
                     
                 }
                 else 
                 {
                      skip 
                 }
                 
             };
             ugpair_ablckptr:=barray[ugpair_ablock];
             if(ugpair_aptr>1) then 
             {
                 ugpair_cellleft:=pairArray[ugpair_ablock,ugpair_aptr-1]
                 
             }
             else
             {
                 ugpair_cellleft:=0
             };
             if(ugpair_aptr<pairArray[ugpair_ablock,0]) then 
             {
                 ugpair_cellrite:=pairArray[ugpair_ablock,ugpair_aptr+1]
                 
             }
             else
             {
                 ugpair_cellrite:=0
             };
             if(ugpair_cellleft!=0 AND ugpair_cellrite!=0 AND carray[ugpair_cellleft]->cclass!=-1 AND ugpair_acellptr->cclass!=-1 AND carray[ugpair_cellrite]->cclass!=-1) then 
             {
                 ugpair_r:=(float)(extern Yacm_random(RValue))/ (float)0x7fffffff;
                 if(ugpair_r>=0.5) then 
                 {
                     ugpair_b:=ugpair_cellleft;
                     ugpair_bcellptr:=carray[ugpair_b];
                     ugpair_leftEdge:=ugpair_bcellptr->cxcenter+ugpair_bcellptr->tileptr->left;
                     ugpair_anxcenter:=ugpair_leftEdge-ugpair_aleft;
                     ugpair_bnxcenter:=ugpair_endx1-ugpair_bcellptr->tileptr->right;
                     if(extern ucgxp(ugpair_a,ugpair_b,ugpair_anxcenter,ugpair_bnxcenter,RValue)) then 
                     {
                         ugpair_flips:=ugpair_flips+1;
                         ugpair_attempts:=ugpair_attempts+1;
                         if(ugpair_attempts % 50=0) then 
                         {
                             fprintf(fpo,"current iteration:%d\n",ugpair_attempts) and skip;
                             fflush(fpo) and skip
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(ugpair_attempts % 150=0) then 
                         {
                             savewolf(3)
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(tracks<ugpair_lowValue) then 
                         {
                             ugpair_lowValue:=tracks;
                             fprintf(fpo,"Routing tracks reduced ") and skip;
                             fprintf(fpo,"to: %d  on iteration:%d\n",tracks,ugpair_attempts) and skip;
                             fflush(fpo) and skip
                             
                         }
                         else
                         {
                             ugpair_breakpoint:=ugpair_breakpoint+1
                         };
                         if(!uneven_cell_height) then 
                         {
                             pairArray[ugpair_ablock,ugpair_aptr]:=ugpair_b;
                             pairArray[ugpair_ablock,ugpair_aptr-1]:=ugpair_a
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                     else
                     {
                         ugpair_breakpoint:=ugpair_breakpoint+1;
                         ugpair_attempts:=ugpair_attempts+1;
                         if(ugpair_attempts % 50=0) then 
                         {
                             fprintf(fpo,"current iteration:%d\n",ugpair_attempts) and skip;
                             fflush(fpo) and skip
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(ugpair_attempts % 150=0) then 
                         {
                             savewolf(3)
                             
                         }
                         else 
                         {
                              skip 
                         };
                         ugpair_b:=ugpair_cellrite;
                         ugpair_bcellptr:=carray[ugpair_b];
                         ugpair_riteEdge:=ugpair_bcellptr->cxcenter+ugpair_bcellptr->tileptr->right;
                         ugpair_anxcenter:=ugpair_riteEdge-ugpair_aright;
                         ugpair_bnxcenter:=ugpair_startx1-ugpair_bcellptr->tileptr->left;
                         if(extern ucgxp(ugpair_a,ugpair_b,ugpair_anxcenter,ugpair_bnxcenter,RValue)) then 
                         {
                             ugpair_flips:=ugpair_flips+1;
                             if(tracks<ugpair_lowValue) then 
                             {
                                 ugpair_lowValue:=tracks;
                                 fprintf(fpo,"Routing tracks reduced ") and skip;
                                 fprintf(fpo,"to: %d  on iteration:%d\n",tracks,(ugpair_attempts+1)) and skip;
                                 fflush(fpo) and skip
                                 
                             }
                             else
                             {
                                 ugpair_breakpoint:=ugpair_breakpoint+1
                             };
                             if(!uneven_cell_height) then 
                             {
                                 pairArray[ugpair_ablock,ugpair_aptr]:=ugpair_b;
                                 pairArray[ugpair_ablock,ugpair_aptr+1]:=ugpair_a
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else
                         {
                             ugpair_breakpoint:=ugpair_breakpoint+1
                         };
                         ugpair_attempts:=ugpair_attempts+1;
                         if(ugpair_attempts % 50=0) then 
                         {
                             fprintf(fpo,"current iteration:%d\n",ugpair_attempts) and skip;
                             fflush(fpo) and skip
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(ugpair_attempts % 150=0) then 
                         {
                             savewolf(3)
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                 }
                 else
                 {
                     ugpair_b:=ugpair_cellrite;
                     ugpair_bcellptr:=carray[ugpair_b];
                     ugpair_riteEdge:=ugpair_bcellptr->cxcenter+ugpair_bcellptr->tileptr->right;
                     ugpair_anxcenter:=ugpair_riteEdge-ugpair_aright;
                     ugpair_bnxcenter:=ugpair_startx1-ugpair_bcellptr->tileptr->left;
                     if(extern ucgxp(ugpair_a,ugpair_b,ugpair_anxcenter,ugpair_bnxcenter,RValue)) then 
                     {
                         ugpair_flips:=ugpair_flips+1;
                         ugpair_attempts:=ugpair_attempts+1;
                         if(ugpair_attempts % 50=0) then 
                         {
                             fprintf(fpo,"current iteration:%d\n",ugpair_attempts) and skip;
                             fflush(fpo) and skip
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(ugpair_attempts % 150=0) then 
                         {
                             savewolf(3)
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(tracks<ugpair_lowValue) then 
                         {
                             ugpair_lowValue:=tracks;
                             fprintf(fpo,"Routing tracks reduced ") and skip;
                             fprintf(fpo,"to: %d  on iteration:%d\n",tracks,ugpair_attempts) and skip;
                             fflush(fpo) and skip
                             
                         }
                         else
                         {
                             ugpair_breakpoint:=ugpair_breakpoint+1
                         };
                         if(!uneven_cell_height) then 
                         {
                             pairArray[ugpair_ablock,ugpair_aptr]:=ugpair_b;
                             pairArray[ugpair_ablock,ugpair_aptr+1]:=ugpair_a
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                     else
                     {
                         ugpair_attempts:=ugpair_attempts+1;
                         if(ugpair_attempts % 50=0) then 
                         {
                             fprintf(fpo,"current iteration:%d\n",ugpair_attempts) and skip;
                             fflush(fpo) and skip
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(ugpair_attempts % 150=0) then 
                         {
                             savewolf(3)
                             
                         }
                         else 
                         {
                              skip 
                         };
                         ugpair_breakpoint:=ugpair_breakpoint+1;
                         ugpair_b:=ugpair_cellleft;
                         ugpair_bcellptr:=carray[ugpair_b];
                         ugpair_leftEdge:=ugpair_bcellptr->cxcenter+ugpair_bcellptr->tileptr->left;
                         ugpair_anxcenter:=ugpair_leftEdge-ugpair_aleft;
                         ugpair_bnxcenter:=ugpair_endx1-ugpair_bcellptr->tileptr->right;
                         if(extern ucgxp(ugpair_a,ugpair_b,ugpair_anxcenter,ugpair_bnxcenter,RValue)) then 
                         {
                             ugpair_flips:=ugpair_flips+1;
                             if(tracks<ugpair_lowValue) then 
                             {
                                 ugpair_lowValue:=tracks;
                                 fprintf(fpo,"Routing tracks reduced ") and skip;
                                 fprintf(fpo,"to: %d  on iteration:%d\n",tracks,(ugpair_attempts+1)) and skip;
                                 fflush(fpo) and skip
                                 
                             }
                             else
                             {
                                 ugpair_breakpoint:=ugpair_breakpoint+1
                             };
                             if(!uneven_cell_height) then 
                             {
                                 pairArray[ugpair_ablock,ugpair_aptr]:=ugpair_b;
                                 pairArray[ugpair_ablock,ugpair_aptr-1]:=ugpair_a
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else
                         {
                             ugpair_breakpoint:=ugpair_breakpoint+1
                         };
                         ugpair_attempts:=ugpair_attempts+1;
                         if(ugpair_attempts % 50=0) then 
                         {
                             fprintf(fpo,"current iteration:%d\n",ugpair_attempts) and skip;
                             fflush(fpo) and skip
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(ugpair_attempts % 150=0) then 
                         {
                             savewolf(3)
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                 }
                 
             }
             else
             {
                 if(ugpair_cellleft!=0 AND carray[ugpair_cellleft]->cclass!=-1 AND ugpair_acellptr->cclass!=-1) then 
                 {
                     ugpair_b:=ugpair_cellleft;
                     ugpair_bcellptr:=carray[ugpair_b];
                     ugpair_leftEdge:=ugpair_bcellptr->cxcenter+ugpair_bcellptr->tileptr->left;
                     ugpair_anxcenter:=ugpair_leftEdge-ugpair_aleft;
                     ugpair_bnxcenter:=ugpair_endx1-ugpair_bcellptr->tileptr->right;
                     if(extern ucgxp(ugpair_a,ugpair_b,ugpair_anxcenter,ugpair_bnxcenter,RValue)) then 
                     {
                         ugpair_flips:=ugpair_flips+1;
                         if(tracks<ugpair_lowValue) then 
                         {
                             ugpair_lowValue:=tracks;
                             fprintf(fpo,"Routing tracks reduced ") and skip;
                             fprintf(fpo,"to: %d  on iteration:%d\n",tracks,(ugpair_attempts+1)) and skip;
                             fflush(fpo) and skip
                             
                         }
                         else
                         {
                             ugpair_breakpoint:=ugpair_breakpoint+1
                         };
                         if(!uneven_cell_height) then 
                         {
                             pairArray[ugpair_ablock,ugpair_aptr]:=ugpair_b;
                             pairArray[ugpair_ablock,ugpair_aptr-1]:=ugpair_a
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else
                     {
                         ugpair_breakpoint:=ugpair_breakpoint+1
                     };
                     ugpair_attempts:=ugpair_attempts+1;
                     if(ugpair_attempts % 50=0) then 
                     {
                         fprintf(fpo,"current iteration:%d\n",ugpair_attempts) and skip;
                         fflush(fpo) and skip
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(ugpair_attempts % 150=0) then 
                     {
                         savewolf(3)
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
                 else
                 {
                     if(ugpair_cellrite!=0 AND carray[ugpair_cellrite]->cclass!=-1 AND ugpair_acellptr->cclass!=-1) then 
                     {
                         ugpair_b:=ugpair_cellrite;
                         ugpair_bcellptr:=carray[ugpair_b];
                         ugpair_riteEdge:=ugpair_bcellptr->cxcenter+ugpair_bcellptr->tileptr->right;
                         ugpair_anxcenter:=ugpair_riteEdge-ugpair_aright;
                         ugpair_bnxcenter:=ugpair_startx1-ugpair_bcellptr->tileptr->left;
                         if(extern ucgxp(ugpair_a,ugpair_b,ugpair_anxcenter,ugpair_bnxcenter,RValue)) then 
                         {
                             ugpair_flips:=ugpair_flips+1;
                             if(tracks<ugpair_lowValue) then 
                             {
                                 ugpair_lowValue:=tracks;
                                 fprintf(fpo,"Routing tracks reduced ") and skip;
                                 fprintf(fpo,"to: %d  on iteration:%d\n",tracks,(ugpair_attempts+1)) and skip;
                                 fflush(fpo) and skip
                                 
                             }
                             else
                             {
                                 ugpair_breakpoint:=ugpair_breakpoint+1
                             };
                             if(!uneven_cell_height) then 
                             {
                                 pairArray[ugpair_ablock,ugpair_aptr]:=ugpair_b;
                                 pairArray[ugpair_ablock,ugpair_aptr+1]:=ugpair_a
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else
                         {
                             ugpair_breakpoint:=ugpair_breakpoint+1
                         };
                         ugpair_attempts:=ugpair_attempts+1;
                         if(ugpair_attempts % 50=0) then 
                         {
                             fprintf(fpo,"current iteration:%d\n",ugpair_attempts) and skip;
                             fflush(fpo) and skip
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(ugpair_attempts % 150=0) then 
                         {
                             savewolf(3)
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     }
                 }
             };
             int switch$ and skip;
             int break$$ and skip;
             break$$<==0 and skip;
              switch$<==0 and skip;
              int nm_3$ and skip;
             nm_3$ := ugpair_ablckptr->borient;
             if (nm_3$=1 OR (switch$=1 AND break$$=0 AND return=0) ) then 
             {
                 switch$<==1 and skip;
                 if(ugpair_acellptr->orflag!=0) then 
                 {
                     if(extern ucg0(ugpair_a,( if((ugpair_aorient=0)) then 2 else 0))) then 
                     {
                         if(tracks<ugpair_lowValue) then 
                         {
                             ugpair_lowValue:=tracks;
                             fprintf(fpo,"Routing tracks reduced ") and skip;
                             fprintf(fpo,"to: %d  on iteration:%d\n",tracks,ugpair_attempts) and skip;
                             fprintf(fpo,"  ----by an orientation change\n") and skip;
                             fflush(fpo) and skip
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 break$$<==1 and skip
                  
             }
             else
             {
                 skip
             };
             if (nm_3$=2 OR (switch$=1 AND break$$=0 AND return=0) ) then 
             {
                 switch$<==1 and skip;
                 if(ugpair_acellptr->orflag!=0) then 
                 {
                     if(extern ucg0(ugpair_a,( if((ugpair_aorient=1)) then 3 else 1))) then 
                     {
                         if(tracks<ugpair_lowValue) then 
                         {
                             ugpair_lowValue:=tracks;
                             fprintf(fpo,"Routing tracks reduced ") and skip;
                             fprintf(fpo,"to: %d  on iteration:%d\n",tracks,ugpair_attempts) and skip;
                             fprintf(fpo,"  ----by an orientation change\n") and skip;
                             fflush(fpo) and skip
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 break$$<==1 and skip
                  
             }
             else
             {
                 skip
                 }}
                 else
                 {
                     skip
                 }
             };
             continue<==0 and skip;
             if(ugpair_attempts!=0) then 
             {
                 fprintf(fpo,"    no. of accepted gflips: %d --->%d%s\n",ugpair_flips,(int)(100.0*(float)ugpair_flips/ (float)ugpair_attempts),"%") and skip;
                 fflush(fpo) and skip
                 
             }
             else 
             {
                  skip 
             };
             safe_free(Shuffle);
              return<==1 and skip
             )
             }; 
              float finalRowControl and skip;
             float initialRowControl and skip;
             int newpenal and skip;
             int Apost,Bpost and skip;
             int *cellaptr,*cellbptr and skip;
             int earlyRej,Rej_error and skip;
             int wire_chg,binpen_chg,rowpen_chg and skip;
             int a,b,ablock,bblock and skip;
             int attempts and skip;
 function PICK_INT ( int l,int u,int RValue )
 {
     frame(return,temp) and ( 
     int return<==0,temp and skip;
	 if(l<u) then
	 {
		temp := (((extern Yacm_random(RValue)) % (u-l+1))+l)
	 }
	 else
	 {
		temp := l
	 };
     return<==1 and RValue:=temp;

     skip
     )
     }; 
  function uloop (  )
 {
     frame(temp_i,uloop_acellptr,uloop_bcellptr,uloop_ablckptr,uloop_bblckptr,uloop_dimptr,uloop_botblk,uloop_topblk,uloop_flips,uloop_rejects,uloop_axcenter,uloop_bxcenter,uloop_bycenter,uloop_aorient,uloop_borient,uloop_bleft,uloop_bright,uloop_blk,uloop_pairflips,uloop_i,uloop_r,uloop_l,uloop_t,uloop_abin,uloop_bbin,uloop_firstTry,uloop_fds,uloop_net,uloop_cost,uloop_target_row_penalty,uloop_target_bin_penalty,uloop_temp,uloop_accept_deviation,uloop_fp_ratio,uloop_percent_error,uloop_factor,uloop_total_feed_length,uloop_target_feed_length,uloop_avg_VW,count$,uloop_temp$_1,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     cellbox* uloop_acellptr,*uloop_bcellptr and skip;
     blockbox* uloop_ablckptr,*uloop_bblckptr and skip;
     dimbox* uloop_dimptr and skip;
     int uloop_botblk,uloop_topblk and skip;
     int uloop_flips,uloop_rejects and skip;
     int uloop_axcenter,uloop_bxcenter,uloop_bycenter and skip;
     int uloop_aorient,uloop_borient and skip;
     int uloop_bleft,uloop_bright and skip;
     int uloop_blk,uloop_pairflips and skip;
     int uloop_i,uloop_r,uloop_l,uloop_t and skip;
     int uloop_abin,uloop_bbin and skip;
     int uloop_firstTry,uloop_fds,uloop_net,uloop_cost and skip;
     float uloop_target_row_penalty and skip;
     float uloop_target_bin_penalty and skip;
     float uloop_temp,uloop_accept_deviation,uloop_fp_ratio,uloop_percent_error and skip;
     float uloop_factor,uloop_total_feed_length,uloop_target_feed_length and skip;
     float uloop_avg_VW and skip;
     attempts:=0;
     uloop_flips:=0;
     uloop_rejects:=0;
     uloop_pairflips:=0;
     earlyRej:=0;
     Rej_error:=0;
     potential_errors:=0;
     error_count:=0;

	

     if(iteration=0 OR resume_run=1) then 
     {
         P_limit:=(int)(10.0*mean_width)
         
     }
     else
     {
         if(wire_chgs>0) then 
         {
             mean_wire_chg:=total_wire_chg/ (float)wire_chgs;
             if(iteration>1) then 
             {
                 sigma_wire_chg:=sqrt(sigma_wire_chg/ (float)wire_chgs)
             }
             else
             {
                 sigma_wire_chg:=3.0*mean_wire_chg
             }
             
         }
         else
         {
             mean_wire_chg:=0.0;
             sigma_wire_chg:=0.0
         };
         P_limit:=mean_wire_chg+1.3*sigma_wire_chg+T/ cost_scale_factor
     };
     sigma_wire_chg:=0.0;
     total_wire_chg:=0.0;
     wire_chgs:=0;
     windx:=minxspan;
     attmax:=((int)((float)iteration/ 121.0*(float)(2*attprcel-attprcel/ 2))+(float)(attprcel/ 2))*moveable_cells;
     if(tw_fast) then 
     {
         attmax:=attmax/ tw_fast
         
     }
     else 
     {
          skip 
     };
     if(tw_slow) then 
     {
         attmax:=attmax*tw_slow
         
     }
     else 
     {
          skip 
     };

	  
     uloop_fds:=0;
     if(iteration>=4) then 
     {
         uloop_fds:=controlf(RValue);

		   


         if(iteration<=105) then 
         {
             uloop_total_feed_length:=(float)est_fds;
             uloop_target_feed_length:=0.7*(float)implicit_feed_count-((0.5*(float)implicit_feed_count/ 105.0)*((float)iteration));
             if(implicit_feed_count>0) then 
             {
                 uloop_factor:=(float)(uloop_total_feed_length-uloop_target_feed_length)/ ((float)implicit_feed_count)
                 
             }
             else
             {
                 uloop_factor:=0.0
             };
             uloop_cost:=0;
             uloop_net:=1;
             
             while(uloop_net<=numnets)
             {
                 uloop_dimptr:=netarray[uloop_net];
                 if(uloop_dimptr->Vweight<=1.0) then 
                 {
                     uloop_dimptr->Vweight:=uloop_dimptr->Vweight*(1.0+uloop_factor);
                     if(uloop_dimptr->Vweight<0.5) then 
                     {
                         uloop_dimptr->Vweight:=0.5
                     }
                     else
                     {
                         if(uloop_dimptr->Vweight>1.0) then 
                         {
                             uloop_dimptr->Vweight:=1.0
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 uloop_avg_VW:=uloop_avg_VW+uloop_dimptr->Vweight;
                 uloop_cost:=uloop_cost+((int)(uloop_dimptr->Hweight*(float)(uloop_dimptr->xmax-uloop_dimptr->xmin)))+((int)(uloop_dimptr->Vweight*(float)(uloop_dimptr->ymax-uloop_dimptr->ymin)));
                 uloop_net:=uloop_net+1
                 
             };
             uloop_avg_VW:=uloop_avg_VW/ (float)numnets;
             funccost:=uloop_cost
             
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         uloop_avg_VW:=0.0
     };


     while(attempts<attmax)
     {
         continue<==0 and skip;
         a:=PICK_INT(1,numcells,RValue); 
         uloop_acellptr:=carray[a];
         if(uloop_acellptr->cclass=-1) then 
         {
             continue<==1 and skip
              
         }
         else 
         {
              skip 
         };			 		 		 
         if(continue=0)   then 
         {
             ablock:=uloop_acellptr->cblock;
             uloop_ablckptr:=barray[ablock];
             uloop_axcenter:=uloop_acellptr->cxcenter;
             uloop_aorient:=uloop_acellptr->corient;
             uloop_abin:=SetBin(uloop_axcenter,RValue);
             cellaptr:=binptr[ablock,uloop_abin]->cell;
             break$<==0 and skip;
             uloop_i:=1;
              
             while( break$=0 AND  uloop_i<=* cellaptr)
             {
                 if(cellaptr[uloop_i]=a) then 
                 {
                     Apost:=uloop_i;
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     uloop_i:=uloop_i+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             bblock:=0;
             uloop_firstTry:=0;
             uloop_botblk:=ablock-1 ;
             if((uloop_botblk)<1) then 
             {
                 uloop_botblk:=1
                 
             }
             else 
             {
                  skip 
             };
             uloop_topblk:=ablock+1 ;
             if((uloop_topblk)>numblock) then 
             {
                 uloop_topblk:=numblock
                 
             }
             else 
             {
                  skip 
             };
             continue<==0 and skip;
             uloop_i:=1;
             break$<==0 and skip;
             while(break$=0 AND true)
             {
                  continue<==0 and skip;
                 int count$<==0 and skip;
                 while( ( count$=0 OR uloop_ablckptr->bclass!=uloop_bblckptr->bclass))
                 {
                     count$:=count$+1;
                     uloop_blk:=XPICK_INT(uloop_botblk,uloop_topblk,uloop_firstTry,RValue);
                     uloop_bblckptr:=barray[uloop_blk]
                 };

                 uloop_bleft:=uloop_bblckptr->bxcenter+uloop_bblckptr->bleft;
                 uloop_bright:=uloop_bblckptr->bxcenter+uloop_bblckptr->bright;
                 uloop_l:=( if((uloop_bleft>=uloop_axcenter-windx)) then uloop_bleft else (uloop_axcenter-windx));
                 uloop_r:=( if((uloop_bright<=uloop_axcenter+windx)) then uloop_bright else (uloop_axcenter+windx));
				  
                 if(uloop_l>uloop_r) then 
                 {
                     if(uloop_i=1) then 
                     {
                         uloop_firstTry:=uloop_blk;
                         continue<==1 and skip;
                          uloop_i:=uloop_i+1}
                         else
                         {
                             if(uloop_i=3) then 
                             {
                                 if(uloop_r<uloop_bleft) then 
                                 {
                                     uloop_r<==uloop_bleft and uloop_l<==uloop_r and skip
                                 }
                                 else
                                 {
                                     uloop_r<==uloop_bright and uloop_l<==uloop_r and skip
                                 }
                             }
                             else
                             {
                                 uloop_firstTry:=-ablock;
                                 continue<==1 and skip;
                                  uloop_i:=uloop_i+1}
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(continue=0)  then
                         {
                             bblock:=uloop_blk;
                             uloop_bycenter:=uloop_bblckptr->bycenter;
                             if(bblock=ablock) then 
                             {
                                 uloop_bxcenter:=XPICK_INT(uloop_l,uloop_r,uloop_axcenter,RValue)
                             }
                             else
                             {
                                 uloop_bxcenter:=XPICK_INT(uloop_l,uloop_r,0,RValue)
                             };
                             break$<==1 and skip
                             
                         }
                         else
                         {
                             skip
                         }
                         
                     };
                     continue<==0 and skip;
					 break$<==0 and skip;
                     uloop_bbin:=SetBin(uloop_bxcenter,RValue);
                     cellbptr:=binptr[bblock,uloop_bbin]->cell;
                     if(* cellbptr=0) then 
                     {
                         if(uloop_ablckptr->borient=1) then 
                         {
                             if(uloop_bblckptr->borient=1) then 
                             {
                                 if(extern ucxx1(uloop_bxcenter,uloop_bycenter,RValue)) then 
                                 {
                                     uloop_flips:=uloop_flips+1
                                 }
                                 else
                                 {
                                     uloop_rejects:=uloop_rejects+1;
                                     if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                     {
                                         uc0(a,( if((uloop_aorient=0)) then 2 else 0))
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                 }
                             }
                             else
                             {
                                 if(extern ucxxo1(uloop_bxcenter,uloop_bycenter,( if((uloop_aorient=0)) then 1 else 3),RValue)) then 
                                 {
                                     uloop_flips:=uloop_flips+1
                                 }
                                 else
                                 {
                                     uloop_rejects:=uloop_rejects+1;
                                     if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                     {
                                         uc0(a,( if((uloop_aorient=0)) then 2 else 0))
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                 }
                             }
                         }
                         else
                         {
                             if(uloop_bblckptr->borient=1) then 
                             {
                                 if(extern ucxxo1(uloop_bxcenter,uloop_bycenter,( if((uloop_aorient=1)) then 0 else 2),RValue)) then 
                                 {
                                     uloop_flips:=uloop_flips+1
                                 }
                                 else
                                 {
                                     uloop_rejects:=uloop_rejects+1;
                                     if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                     {
                                         uc0(a,( if((uloop_aorient=1)) then 3 else 1))
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                 }
                             }
                             else
                             {
                                 if(extern ucxx1(uloop_bxcenter,uloop_bycenter,RValue)) then 
                                 {
                                     uloop_flips:=uloop_flips+1
                                 }
                                 else
                                 {
                                     uloop_rejects:=uloop_rejects+1;
                                     if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                     {
                                         uc0(a,( if((uloop_aorient=1)) then 3 else 1))
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                 }
                             }
                         }
                         
                     }
                     else
                     {
                         Bpost:=PICK_INT(1,* cellbptr,RValue);
                         b:=cellbptr[Bpost];
                         uloop_bcellptr:=carray[b];
                         bblock:=uloop_bcellptr->cblock;
                         uloop_bblckptr:=barray[bblock];
						 
                         if(uloop_acellptr->cclass!=uloop_bcellptr->cclass OR a=b) then 
                         {
                             continue<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(continue=0)   then 
                         {
                             uloop_borient:=uloop_bcellptr->corient;
                             if(uloop_ablckptr->borient=1) then 
                             {
                                 if(uloop_bblckptr->borient=1) then 
                                 {
                                     uloop_t:=ucxx2(RValue);
									 		 					 
                                     if(uloop_t=-1) then 
                                     {
                                         uloop_rejects:=uloop_rejects+1;
                                         if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                         {
                                             uc0(a,( if((uloop_aorient=0)) then 2 else 0))
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         attempts:=attempts+1;
                                         continue<==1 and skip
                                      }
                                     else
                                     {
                                         if(uloop_t=1) then 
                                         {
                                             uloop_pairflips:=uloop_pairflips+1
                                         }
                                         else
                                         {
                                             uloop_rejects:=uloop_rejects+1;
                                             if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                             {
                                                 uc0(a,( if((uloop_aorient=0)) then 2 else 0))
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                         }
                                     }
                                 }
                                 else
                                 {
                                     uloop_t:=ucxxo2(( if((uloop_aorient=0)) then 1 else 3),( if((uloop_borient=1)) then 0 else 2),RValue);
                                     if(uloop_t=-1) then 
                                     {
                                         uloop_rejects:=uloop_rejects+1;
                                         if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                         {
                                             uc0(a,( if((uloop_aorient=0)) then 2 else 0))
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         attempts:=attempts+1;
                                         continue<==1 and skip
                                      }
                                     else
                                     {
                                         if(uloop_t=1) then 
                                         {
                                             uloop_pairflips:=uloop_pairflips+1
                                         }
                                         else
                                         {
                                             uloop_rejects:=uloop_rejects+1;
                                             if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                             {
                                                 uc0(a,( if((uloop_aorient=0)) then 2 else 0))
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                         }
                                     }
                                 }
                             }
                             else
                             {
                                 if(uloop_bblckptr->borient=1) then 
                                 {
                                     uloop_t:=ucxxo2(( if((uloop_aorient=1)) then 0 else 2),( if((uloop_borient=0)) then 1 else 3),RValue);
                                     if(uloop_t=-1) then 
                                     {
                                         uloop_rejects:=uloop_rejects+1;
                                         if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                         {
                                             uc0(a,( if((uloop_aorient=1)) then 3 else 1))
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         attempts:=attempts+1;
                                         continue<==1 and skip
                                      }
                                     else
                                     {
                                         if(uloop_t=1) then 
                                         {
                                             uloop_pairflips:=uloop_pairflips+1
                                         }
                                         else
                                         {
                                             uloop_rejects:=uloop_rejects+1;
                                             if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                             {
                                                 uc0(a,( if((uloop_aorient=1)) then 3 else 1))
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                         }
                                     }
                                 }
                                 else
                                 {
                                     uloop_t:=ucxx2(RValue);
                                     if(uloop_t=-1) then 
                                     {
                                         uloop_rejects:=uloop_rejects+1;
                                         if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                         {
                                             uc0(a,( if((uloop_aorient=1)) then 3 else 1))
                                             
                                         }
                                         else 
                                         {
                                              skip 
                                         };
                                         attempts:=attempts+1;
                                         continue<==1 and skip
                                      }
                                     else
                                     {
                                         if(uloop_t=1) then 
                                         {
                                             uloop_pairflips:=uloop_pairflips+1
                                         }
                                         else
                                         {
                                             uloop_rejects:=uloop_rejects+1;
                                             if(uloop_rejects % 6=0 AND uloop_acellptr->orflag!=0) then 
                                             {
                                                 uc0(a,( if((uloop_aorient=1)) then 3 else 1))
                                                 
                                             }
                                             else 
                                             {
                                                  skip 
                                             }
                                         }
                                     }
                                 }
                             }
                         }
                         else
                         {
                             skip 
                             } 
                         };
                         if(continue=0)  then 
                         {
                             attempts:=attempts+1
				
                         }
                         else
                         {
                             skip
                         }
                     }
                     else
                     {
                         skip
                     }
                 };
                 continue<==0 and skip;
                 if(potential_errors>0) then 
                 {
                     uloop_percent_error:=(float)error_count/ (float)potential_errors
                     
                 }
                 else
                 {
                     uloop_percent_error:=0.0
                 };
                 uloop_percent_error:=uloop_percent_error*100.0;
                 uloop_temp:=100.0*(float)(uloop_pairflips+uloop_flips)/ (float)attmax;
                 if(uloop_pairflips>0.0001) then 
                 {
                     uloop_fp_ratio:=100.0*(float)uloop_flips/ (float)uloop_pairflips
                     
                 }
                 else
                 {
                     uloop_fp_ratio:=100.0
                 };
                 vert_statistics();
                 fprintf(fpo,"%3d %3d %4d %8d %7d %5d %4.1f %4.1f %4.1f %4.1f %4.1f",iteration+1,(int)T,uloop_fds,funccost,penalty,P_limit,uloop_percent_error,binpenCon,roLenCon,uloop_temp,uloop_fp_ratio) and skip;
                 int uloop_temp$_1 and skip;
                 uloop_temp$_1:=ABS(tot_missing_rows,RValue);
                 fprintf(fpo," %4.1f %5d %6d\n",100.0*(float)earlyRej/ (float)attmax,tot_num_feeds,uloop_temp$_1) and skip;
                 fflush(fpo) and skip;
                 if(iteration<1 OR resume_run=1) then 
                 {
                     if(iteration<1) then 
                     {
                         cost_scale_factor:=1.0
                         
                     }
                     else 
                     {
                          skip 
                     };
                     rowcon(RValue);
                     resume_run:=0
                     
                 }
                 else
                 {
                     if(iteration<100) then 
                     {
                         uloop_accept_deviation:=(uloop_temp-desired_accept[iteration])/ 40.0;
                         cost_scale_factor:=cost_scale_factor*(1.0+uloop_accept_deviation)
                         
                     }
                     else 
                     {
                          skip 
                     }
                 };
                 if(iteration<=104) then 
                 {
                     uloop_target_bin_penalty:=(1.40-((1.15/ 105.0)*((float)iteration+1.0)))*(float)totalR;
                     binpenCon:=binpenCon+((float)binpenal-uloop_target_bin_penalty)/ (float)totalR;
                     binpenCon:=( if((binpenCon>0.5)) then binpenCon else 0.5);
                     uloop_target_row_penalty:=(initialRowControl-(((initialRowControl-finalRowControl)/ 105.0)*((float)iteration+1.0)))*(float)totalR;
                     roLenCon:=roLenCon+((float)rowpenal-uloop_target_row_penalty)/ uloop_target_row_penalty;
                     roLenCon:=( if((roLenCon>0.5)) then roLenCon else 0.5);
                     penalty:=(int)(binpenCon*(float)binpenal+roLenCon*(float)rowpenal)
                     
                 }
                 else 
                 {
                      skip 
                 };
                  return<==1 and skip
                 )
                 }; 
  function rowcon ( int RValue )
 {
     frame(rowcon_C,rowcon_R,rowcon_p_first,rowcon_totalCells,rowcon_cellsPerRow,rowcon_temp_R,rowcon_over,rowcon_under,rowcon_states,rowcon_value,rowcon_expect,rowcon_variance,rowcon_expectedExtraRowLength,rowcon_rowControl,rowcon_x,rowcon_minDev,count$,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     int rowcon_C,rowcon_R,rowcon_p_first,rowcon_totalCells,rowcon_cellsPerRow,rowcon_temp_R and skip;
     int rowcon_over,rowcon_under and skip;
     float rowcon_states,rowcon_value,rowcon_expect,rowcon_variance and skip;
     float rowcon_expectedExtraRowLength,rowcon_rowControl,rowcon_x,rowcon_minDev and skip;
     rowcon_totalCells:=numcells;
     rowcon_R:=numRows;
     rowcon_cellsPerRow:=rowcon_totalCells/ rowcon_R;
     rowcon_temp_R:=rowcon_R-rowcon_R/ 3;
     rowcon_rowControl:=0.0;
     int count$<==0 and skip;
     while( ( count$=0 OR 2*rowcon_C<rowcon_temp_R))
     {
         count$:=count$+1;
         rowcon_rowControl:=rowcon_rowControl+0.001;
         rowcon_C:=(int)(rowcon_rowControl*(float)rowcon_totalCells/ 2.0);
         if(2.0*(float)(rowcon_C+1)-rowcon_rowControl*rowcon_totalCells<=rowcon_rowControl*rowcon_totalCells-2.0*(float)rowcon_C) then 
         {
             rowcon_C:=rowcon_C+1
             
         }
         else 
         {
              skip 
         }
     };
     rowcon_p_first:=rowcon_C/ rowcon_R;
     if(rowcon_p_first*rowcon_R<rowcon_C) then 
     {
         rowcon_p_first:=rowcon_p_first+1
         
     }
     else 
     {
          skip 
     };
     rowcon_R:=rowcon_R-rowcon_R/ 3;
     rowcon_under:=0;
     rowcon_over:=0;
     break$<==0 and skip;
     while( break$=0 AND  true)
     {
         rowcon_value:=expected_value(rowcon_C,0,rowcon_p_first,rowcon_R,RValue);
         rowcon_states:=combination(rowcon_C+rowcon_R-1,rowcon_C,RValue);
         rowcon_expect:=rowcon_value/ rowcon_states;
         rowcon_expectedExtraRowLength:=100.0*rowcon_expect/ (float)rowcon_cellsPerRow;
         rowcon_value:=expected_svalue(rowcon_C,0,rowcon_p_first,rowcon_R,RValue);
         rowcon_variance:=rowcon_value/ rowcon_states-(rowcon_expect*rowcon_expect);
         rowcon_x:=100.0*sqrt(rowcon_variance)/ (float)rowcon_cellsPerRow;
         rowcon_minDev:=100.0/ (float)rowcon_cellsPerRow;
         rowcon_value:=rowcon_x+rowcon_expectedExtraRowLength-rowcon_minDev;
         if(rowcon_value>2.7 AND rowcon_value<3.3) then 
         {
             break$<==1 and skip
              
         }
         else
         {
             if(rowcon_value<=2.7) then 
             {
                 rowcon_rowControl:=rowcon_rowControl+0.001;
                 if(!rowcon_over) then 
                 {
                     rowcon_under:=1
                 }
                 else
                 {
                     break$<==1 and skip
                  }
             }
             else
             {
                 if(rowcon_value>=3.3) then 
                 {
                     if(!rowcon_under) then 
                     {
                         rowcon_rowControl:=rowcon_rowControl-0.001;
                         rowcon_over:=1
                     }
                     else
                     {
                         break$<==1 and skip
                      }
                     
                 }
                 else 
                 {
                      skip 
                 }
             }
         };
         if(break$=0)  then 
         {
             if(break$=0)   then 
             {
                 rowcon_C:=(int)(rowcon_rowControl*(float)rowcon_totalCells/ 2.0);
                 if(2.0*(float)(rowcon_C+1)-rowcon_rowControl*rowcon_totalCells<=rowcon_rowControl*rowcon_totalCells-2.0*(float)rowcon_C) then 
                 {
                     rowcon_C:=rowcon_C+1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 rowcon_p_first:=rowcon_C/ rowcon_R;
                 if(rowcon_p_first*rowcon_R<rowcon_C) then 
                 {
                     rowcon_p_first:=rowcon_p_first+1
                     
                 }
                 else 
                 {
                      skip 
                 }
             }
             else
             {
                 skip
             }
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     initialRowControl:=5.5*rowcon_rowControl;
     finalRowControl:=rowcon_rowControl;
      return<==1 and skip
     )
     }; 
  function partition ( int C_initial,int k_initial,int p_initial,int R_initial, float RValue )
 {
     frame(partition_R,partition_C,partition_k,partition_p,partition_k_limit,partition_p_limit,partition_states,partition_equivs,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     int partition_R,partition_C,partition_k,partition_p,partition_k_limit,partition_p_limit and skip;
     float partition_states,partition_equivs and skip;
     partition_states:=0.0;
     partition_k_limit<==R_initial-k_initial and partition_R<==partition_k_limit and skip;
     partition_C:=C_initial-p_initial*k_initial;
     partition_k:=1;
     
     while(partition_k<=partition_k_limit)
     {
         partition_equivs:=combination(partition_R,partition_k,RValue);
         partition_p_limit:=partition_C/ partition_k;
         continue<==0 and skip;
         partition_p:=p_initial;
         
         while(partition_p<=partition_p_limit)
         {
              continue<==0 and skip;
             if(partition_C-(partition_p-1)*partition_R>partition_k) then 
             {
                 continue<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
            if(continue=0)   then 
             {
                 partition_states:=partition_states+partition_equivs*(extern compute_and_combination(partition_C,partition_k,partition_p,partition_R,RValue)-extern partition(partition_C,partition_k,partition_p,partition_R,RValue));
                 continue<==1 and skip

                  
            }
             else
             {
                 skip
             };
			partition_p:=partition_p+1
         };
         continue<==0 and skip;
         partition_k:=partition_k+1
         
     };
     return<==1 and RValue:=partition_states;
     skip
     )
     }; 
  function expected_value ( int C_initial,int k_initial,int p_initial,int R_initial,  float RValue)
 {
     frame(expected_value_R,expected_value_C,expected_value_k,expected_value_p,expected_value_k_limit,expected_value_p_limit,expected_value_value,expected_value_equivs,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     int expected_value_R,expected_value_C,expected_value_k,expected_value_p,expected_value_k_limit,expected_value_p_limit and skip;
     float expected_value_value,expected_value_equivs and skip;
     expected_value_value:=0.0;
     expected_value_k_limit<==R_initial-k_initial and skip;
	  expected_value_R<==expected_value_k_limit and skip;
     expected_value_C:=C_initial-p_initial*k_initial;
     expected_value_k:=1;
     
     while(expected_value_k<=expected_value_k_limit)
     {
         expected_value_equivs:=combination(expected_value_R,expected_value_k,RValue);
         expected_value_p_limit:=expected_value_C/ expected_value_k;
         continue<==0 and skip;
         expected_value_p:=p_initial;
         
         while(expected_value_p<=expected_value_p_limit)
         {
              continue<==0 and skip;
             if(expected_value_C-(expected_value_p-1)*expected_value_R>expected_value_k) then 
             {
                 continue<==1 and skip;
                  expected_value_p:=expected_value_p+1
             }
             else 
             {
                  skip 
             };
             if(continue=0)   then 
             {
                 expected_value_value:=expected_value_value+(float)expected_value_p*expected_value_equivs*(compute_and_combination(expected_value_C,expected_value_k,expected_value_p,expected_value_R,RValue)-partition(expected_value_C,expected_value_k,expected_value_p,expected_value_R,RValue));
                 expected_value_p:=expected_value_p+1
             }
             else
             {
                 skip
             }
             
         };
         continue<==0 and skip;
         expected_value_k:=expected_value_k+1
         
     };
     return<==1 and RValue:=expected_value_value;
     skip
     )
     }; 
  function expected_svalue ( int C_initial,int k_initial,int p_initial,int R_initial,  float RValue)
 {
     frame(expected_svalue_R,expected_svalue_C,expected_svalue_k,expected_svalue_p,expected_svalue_k_limit,expected_svalue_p_limit,expected_svalue_value,expected_svalue_equivs,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     int expected_svalue_R,expected_svalue_C,expected_svalue_k,expected_svalue_p,expected_svalue_k_limit,expected_svalue_p_limit and skip;
     float expected_svalue_value,expected_svalue_equivs and skip;
     expected_svalue_value:=0.0;
     expected_svalue_k_limit<==R_initial-k_initial and expected_svalue_R<==expected_svalue_k_limit and skip;
     expected_svalue_C:=C_initial-p_initial*k_initial;
     expected_svalue_k:=1;
     
     while(expected_svalue_k<=expected_svalue_k_limit)
     {
         expected_svalue_equivs:=combination(expected_svalue_R,expected_svalue_k,RValue);
         expected_svalue_p_limit:=expected_svalue_C/ expected_svalue_k;
         continue<==0 and skip;
         expected_svalue_p:=p_initial;
         
         while(expected_svalue_p<=expected_svalue_p_limit)
         {
              continue<==0 and skip;
             if(expected_svalue_C-(expected_svalue_p-1)*expected_svalue_R>expected_svalue_k) then 
             {
                 continue<==1 and skip;
                  expected_svalue_p:=expected_svalue_p+1
             }
             else 
             {
                  skip 
             };
             if(continue=0)   then 
             {
                 expected_svalue_value:=expected_svalue_value+(float)(expected_svalue_p*expected_svalue_p)*expected_svalue_equivs*(compute_and_combination(expected_svalue_C,expected_svalue_k,expected_svalue_p,expected_svalue_R,RValue)-partition(expected_svalue_C,expected_svalue_k,expected_svalue_p,expected_svalue_R,RValue));
                 expected_svalue_p:=expected_svalue_p+1
             }
             else
             {
                 skip
             }
             
         };
         continue<==0 and skip;
         expected_svalue_k:=expected_svalue_k+1
         
     };
     return<==1 and RValue:=expected_svalue_value;
     skip
     )
     }; 
  function compute_and_combination ( int C,int k,int p,int R,float RValue )
 {
     frame(compute_and_combination_numerator,compute_and_combination_denom1,compute_and_combination_denom2,compute_and_combination_temp,compute_and_combination_states,return) and ( 
     int return<==0 and skip;
     int compute_and_combination_numerator,compute_and_combination_denom1,compute_and_combination_denom2,compute_and_combination_temp and skip;
     float compute_and_combination_states and skip;
     compute_and_combination_states:=1.0;
     compute_and_combination_numerator:=C-k*p+R-k-1;
     compute_and_combination_denom1:=C-k*p;
     compute_and_combination_denom2:=R-k-1;
     if(compute_and_combination_denom1>compute_and_combination_denom2) then 
     {
         compute_and_combination_temp:=compute_and_combination_denom1;
         compute_and_combination_denom1:=compute_and_combination_denom2;
         compute_and_combination_denom2:=compute_and_combination_temp
         
     }
     else 
     {
          skip 
     };
     while(compute_and_combination_numerator>compute_and_combination_denom2)
     {
         compute_and_combination_states:=compute_and_combination_states*(float)compute_and_combination_numerator;
         compute_and_combination_states:=compute_and_combination_states/ (float)compute_and_combination_denom1;
         compute_and_combination_numerator:=compute_and_combination_numerator-1 and compute_and_combination_denom1:=compute_and_combination_denom1-1
         
     };
     return<==1 and RValue:=compute_and_combination_states;
     skip
     )
     }; 
  function combination ( int numerator,int denominator,float RValue )
 {
     frame(combination_states,combination_temp,combination_denom1,combination_denom2,return) and ( 
     int return<==0 and skip;
     float combination_states and skip;
     int combination_temp,combination_denom1,combination_denom2 and skip;
     combination_states:=1.0;
     combination_denom1:=denominator;
     combination_denom2:=numerator-denominator;
     if(combination_denom1>combination_denom2) then 
     {
         combination_temp:=combination_denom1;
         combination_denom1:=combination_denom2;
         combination_denom2:=combination_temp
         
     }
     else 
     {
          skip 
     };
     while(numerator>combination_denom2)
     {
         combination_states:=combination_states*(float)numerator;
         combination_states:=combination_states/ (float)combination_denom1;
         numerator:=numerator-1 and combination_denom1:=combination_denom1-1
         
     };
     return<==1 and RValue:=combination_states;
     skip
     )
     }; 
  function uloop2 (  )
 {
     frame(temp_i,uloop2_acellptr,uloop2_bcellptr,uloop2_ablckptr,uloop2_bblckptr,uloop2_botblk,uloop2_topblk,uloop2_flips,uloop2_axcenter,uloop2_bxcenter,uloop2_bycenter,uloop2_aorient,uloop2_borient,uloop2_bleft,uloop2_bright,uloop2_blk,uloop2_pairflips,uloop2_i,uloop2_r,uloop2_l,uloop2_t,uloop2_abin,uloop2_bbin,uloop2_firstTry,uloop2_fds,uloop2_temp,uloop2_fp_ratio,uloop2_percent_error,count$,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     cellbox* uloop2_acellptr,*uloop2_bcellptr and skip;
     blockbox* uloop2_ablckptr,*uloop2_bblckptr and skip;
     int uloop2_botblk,uloop2_topblk and skip;
     int uloop2_flips and skip;
     int uloop2_axcenter,uloop2_bxcenter,uloop2_bycenter and skip;
     int uloop2_aorient,uloop2_borient and skip;
     int uloop2_bleft,uloop2_bright and skip;
     int uloop2_blk,uloop2_pairflips and skip;
     int uloop2_i,uloop2_r,uloop2_l,uloop2_t and skip;
     int uloop2_abin,uloop2_bbin and skip;
     int uloop2_firstTry,uloop2_fds and skip;
     float uloop2_temp,uloop2_fp_ratio,uloop2_percent_error and skip;
     attempts:=0;
     uloop2_flips:=0;
     uloop2_pairflips:=0;
     earlyRej:=0;
     P_limit:=-1;
     windx:=minxspan;
     attmax:=2*attprcel*numcells;
     binpenCon:=0.0;
     uloop2_fds:=0;
     if(estimate_feeds) then 
     {
         uloop2_fds:=controlf(RValue)
         
     }
     else 
     {
          skip 
     };
     while(attempts<attmax)
     {
         continue<==0 and skip;
         a:=PICK_INT(1,numcells,RValue);
         uloop2_acellptr:=carray[a];

		 int temp_i<==1 and skip;
		
         if(uloop2_acellptr->cclass=-1) then 
         {
             continue<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             ablock:=uloop2_acellptr->cblock;
             uloop2_ablckptr:=barray[ablock];
             uloop2_axcenter:=uloop2_acellptr->cxcenter;
             uloop2_aorient:=uloop2_acellptr->corient;
             uloop2_abin:=SetBin(uloop2_axcenter,RValue);
             cellaptr:=binptr[ablock,uloop2_abin]->cell;
             break$<==0 and skip;
             uloop2_i:=1;
             
             while( break$=0 AND  uloop2_i<=* cellaptr)
             {
                 if(cellaptr[uloop2_i]=a) then 
                 {
                     Apost:=uloop2_i;
                     break$<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then
                 {
                     uloop2_i:=uloop2_i+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             bblock:=0;
             uloop2_firstTry:=0;
             uloop2_botblk:=ablock-1 ;
             if((uloop2_botblk)<1) then 
             {
                 uloop2_botblk:=1
                 
             }
             else 
             {
                  skip 
             };
             uloop2_topblk:=ablock+1 ;
             if((uloop2_topblk)>numblock) then 
             {
                 uloop2_topblk:=numblock
                 
             }
             else 
             {
                  skip 
             };
             continue<==0 and skip;
             uloop2_i:=1;
             
             while(break$=0 AND true)
             {
                  continue<==0 and skip;
                 int count$<==0 and skip;
                 while( ( count$=0 OR ablock=uloop2_blk OR uloop2_ablckptr->bclass!=uloop2_bblckptr->bclass))
                 {
                     count$:=count$+1;
                     uloop2_blk:=XPICK_INT(uloop2_botblk,uloop2_topblk,uloop2_firstTry,RValue);
					 
                     uloop2_bblckptr:=barray[uloop2_blk]
                 };
                 uloop2_bleft:=uloop2_bblckptr->bxcenter+uloop2_bblckptr->bleft;
                 uloop2_bright:=uloop2_bblckptr->bxcenter+uloop2_bblckptr->bright;
				 
				 

                 uloop2_l:=( if((uloop2_bleft>=uloop2_axcenter-windx)) then uloop2_bleft else (uloop2_axcenter-windx));


                 uloop2_r:=( if((uloop2_bright<=uloop2_axcenter+windx)) then uloop2_bright else (uloop2_axcenter+windx));
				 

                 if(uloop2_l>uloop2_r) then 
                 {
                     if(uloop2_i=1) then 
                     {
                         uloop2_firstTry:=uloop2_blk;
                         continue<==1 and skip;
                          uloop2_i:=uloop2_i+1}
                         else
                         {
                             if(uloop2_i=3) then 
                             {
                                 if(uloop2_r<uloop2_bleft) then 
                                 {
                                     uloop2_r<==uloop2_bleft and uloop2_l<==uloop2_r and skip
                                 }
                                 else
                                 {
                                     uloop2_r<==uloop2_bright and uloop2_l<==uloop2_r and skip
                                 }
                             }
                             else
                             {
                                 uloop2_firstTry:=-ablock;
                                 continue<==1 and skip;
                                  uloop2_i:=uloop2_i+1}
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(continue=0)  then
                         {
                             bblock:=uloop2_blk;
                             uloop2_bycenter:=uloop2_bblckptr->bycenter;
                             if(bblock=ablock) then 
                             {
                                 uloop2_bxcenter:=XPICK_INT(uloop2_l,uloop2_r,uloop2_axcenter,RValue)
                                 
                             }
                             else
                             {
                                 uloop2_bxcenter:=XPICK_INT(uloop2_l,uloop2_r,0,RValue)
                             };
                             break$<==1 and skip
                         }
                         else
                         {
                             skip
                         }
                         
                     };
					 break$<==0 and skip;
                     continue<==0 and skip;
                     uloop2_bbin:=SetBin(uloop2_bxcenter,RValue);
                     cellbptr:=binptr[bblock,uloop2_bbin]->cell;
                     if(* cellbptr=0) then 
                     {
                         if(uloop2_ablckptr->borient=1) then 
                         {
                             if(uloop2_bblckptr->borient=1) then 
                             {
                                 if(extern ucxx1(uloop2_bxcenter,uloop2_bycenter,RValue)) then 
                                 {
                                     uloop2_flips:=uloop2_flips+1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                             else
                             {
                                 if(extern ucxxo1(uloop2_bxcenter,uloop2_bycenter,( if((uloop2_aorient=0)) then 1 else 3),RValue)) then 
                                 {
                                     uloop2_flips:=uloop2_flips+1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                         }
                         else
                         {
                             if(uloop2_bblckptr->borient=1) then 
                             {
                                 if(extern ucxxo1(uloop2_bxcenter,uloop2_bycenter,( if((uloop2_aorient=1)) then 0 else 2),RValue)) then 
                                 {
                                     uloop2_flips:=uloop2_flips+1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                             else
                             {
                                 if(extern ucxx1(uloop2_bxcenter,uloop2_bycenter,RValue)) then 
                                 {
                                     uloop2_flips:=uloop2_flips+1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                             }
                         }
                         
                     }
                     else
                     {
                         Bpost:=PICK_INT(1,* cellbptr,RValue);
                         b:=cellbptr[Bpost];
                         uloop2_bcellptr:=carray[b];
                         bblock:=uloop2_bcellptr->cblock;
                         uloop2_bblckptr:=barray[bblock];
                         if(uloop2_bcellptr->cclass=-1 OR a=b) then 
                         {
                             continue<==1 and skip
                              
                         }
                         else 
                         {
                              skip 
                         };
                         if(continue=0)   then 
                         {
                             uloop2_borient:=uloop2_bcellptr->corient;
                             if(uloop2_ablckptr->borient=1) then 
                             {
                                 if(uloop2_bblckptr->borient=1) then 
                                 {
                                     uloop2_t:=ucxx2(RValue);
                                     if(uloop2_t=1) then 
                                     {
                                         uloop2_pairflips:=uloop2_pairflips+1
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                 }
                                 else
                                 {
                                     uloop2_t:=ucxxo2(( if((uloop2_aorient=0)) then 1 else 3),( if((uloop2_borient=1)) then 0 else 2),RValue);
                                     if(uloop2_t=1) then 
                                     {
                                         uloop2_pairflips:=uloop2_pairflips+1
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                 }
                             }
                             else
                             {
                                 if(uloop2_bblckptr->borient=1) then 
                                 {
                                     uloop2_t:=ucxxo2(( if((uloop2_aorient=1)) then 0 else 2),( if((uloop2_borient=0)) then 1 else 3),RValue);
                                     if(uloop2_t=1) then 
                                     {
                                         uloop2_pairflips:=uloop2_pairflips+1
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                 }
                                 else
                                 {
                                     uloop2_t:=ucxx2(RValue);
                                     if(uloop2_t=1) then 
                                     {
                                         uloop2_pairflips:=uloop2_pairflips+1
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     }
                                 }
                             }
                         }
                         else
                         {
                             skip 
                             } 
                         };
                         if(continue=0)  then 
                         {
                             attempts:=attempts+1
                         }
                         else
                         {
                             skip
                         }
                     }
                     else
                     {
                         skip
                     }
                 };
                 continue<==0 and skip;
                 uloop2_temp:=100.0*(float)(uloop2_pairflips+uloop2_flips)/ (float)attmax;
                 if(uloop2_pairflips>0.0001) then 
                 {
                     uloop2_fp_ratio:=100.0*(float)uloop2_flips/ (float)uloop2_pairflips
                     
                 }
                 else
                 {
                     uloop2_fp_ratio:=100.0
                 };
                 fprintf(fpo,"%3d %3d %4d %8d %7d %5d 0.0 %4.1f %4.1f %4.1f %4.1f",iteration+1,(int)T,uloop2_fds,funccost,penalty,P_limit,binpenCon,roLenCon,uloop2_temp,uloop2_fp_ratio) and skip;
                 fprintf(fpo," %4.1f\n",100.0*(float)earlyRej/ (float)attmax) and skip;
                 fflush(fpo) and skip;
                  return<==1 and skip
                 )
                 }; 
  function unetseg (  )
 {
     frame(unetseg_segptr,unetseg_ptr1,unetseg_ptr2,unetseg_bptr,unetseg_fptr,unetseg_sptr,unetseg_eptr,unetseg_ptr,unetseg_gdptr,unetseg_tryptr,unetseg_denptr,unetseg_headptr,unetseg_netptr,unetseg_pin1,unetseg_pin2,unetseg_x1,unetseg_x2,unetseg_x,unetseg_i,unetseg_channel,unetseg_chan,unetseg_up_channel,unetseg_segment,unetseg_Flag,unetseg_changes,unetseg_index,unetseg_b,unetseg_e,unetseg_net,unetseg_track,unetseg_dtrack,unetseg_Ucount,unetseg_Lcount,unetseg_j,unetseg_t,unetseg_tryFlag,unetseg_trynet,unetseg_pinloc,unetseg_self_reset,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     segbox* unetseg_segptr and skip;
     changrdbox* unetseg_ptr1,*unetseg_ptr2,*unetseg_bptr,*unetseg_fptr,*unetseg_sptr,*unetseg_eptr,*unetseg_ptr,*unetseg_gdptr and skip;
     changrdbox* unetseg_tryptr[500] and skip;
     densitybox* unetseg_denptr,*unetseg_headptr and skip;
     netbox* unetseg_netptr and skip;
     int unetseg_pin1,unetseg_pin2,unetseg_x1,unetseg_x2,unetseg_x,unetseg_i and skip;
     int unetseg_channel,unetseg_chan,unetseg_up_channel,unetseg_segment,unetseg_Flag,unetseg_changes and skip;
     int unetseg_index,unetseg_b,unetseg_e,unetseg_net,unetseg_track,unetseg_dtrack and skip;
     int unetseg_Ucount,unetseg_Lcount and skip;
     int unetseg_j,unetseg_t,unetseg_tryFlag[500],unetseg_trynet,unetseg_pinloc,unetseg_self_reset and skip;
     gtopChan:=1;
     gbotChan:=numChans;
     tracks:=0;
     unetseg_index:=1;
     
     while(unetseg_index<=netchgs[0])
     {
         unetseg_net:=netchgs[unetseg_index];
         unetseg_b:=anet[unetseg_net];
         unetseg_e:=anet[unetseg_net+1]-1;
         continue<==0 and skip;
         unetseg_segment:=unetseg_b;
         
         while(unetseg_segment<=unetseg_e)
         {
              continue<==0 and skip;
             if(aNetSeg[unetseg_segment].current=0) then 
             {
                 unetseg_segptr:=aNetSeg[unetseg_segment].top
                 
             }
             else
             {
                 unetseg_segptr:=aNetSeg[unetseg_segment].bot
             };
             unetseg_pin1:=unetseg_segptr->pin1;
             unetseg_pin2:=unetseg_segptr->pin2;
             if(unetseg_pin1>maxterm AND unetseg_pin2>maxterm) then 
             {
                 continue<==1 and skip;
                  unetseg_segment:=unetseg_segment+1
             }
             else 
             {
                  skip 
             };
             if(continue=0)   then 
             {
                 unetseg_ptr1:=unetseg_segptr->pin1ptr;
                 unetseg_ptr2:=unetseg_segptr->pin2ptr;
                 unetseg_x1:=unetseg_ptr1->netptr->newx;
                 unetseg_x2:=unetseg_ptr2->netptr->newx;
                 if(unetseg_x1=unetseg_x2) then 
                 {
                     continue<==1 and skip;
                      unetseg_segment:=unetseg_segment+1
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     unetseg_channel:=unetseg_segptr->channel;
                     if(unetseg_channel>gtopChan) then 
                     {
                         gtopChan:=unetseg_channel
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(unetseg_channel<gbotChan) then 
                     {
                         gbotChan:=unetseg_channel
                         
                     }
                     else 
                     {
                          skip 
                     };
                     unetseg_net:=aNetSeg[unetseg_segment].net;
                     if(unetseg_ptr1->nSegType>0) then 
                     {
                         unetseg_Flag:=0;
                         unetseg_bptr:=unetseg_ptr1;
                         break$<==0 and skip;
                         while( break$=0 AND  unetseg_bptr->prevgrd!=NULL AND unetseg_bptr->prevgrd->netptr->newx=unetseg_x1)
                         {
                             if(unetseg_net=tearray[unetseg_bptr->prevgrd->netptr->terminal]->net AND unetseg_bptr->prevgrd->nSegType<0) then 
                             {
                                 unetseg_Flag:=1;
                                 unetseg_sptr:=unetseg_ptr1->nextgrd;
                                 while(unetseg_sptr->netptr->newx=unetseg_x1)
                                 {
                                     unetseg_sptr:=unetseg_sptr->nextgrd
                                 };
                                 break$<==1 and skip
                              }
                             else
                             {
                                 unetseg_bptr:=unetseg_bptr->prevgrd
                             }
                         };
                         break$<==0 and skip;
                         if(!unetseg_Flag) then 
                         {
                             unetseg_sptr:=unetseg_ptr1->nextgrd;
                             while(unetseg_sptr->netptr->newx=unetseg_x1)
                             {
                                 if(unetseg_net=tearray[unetseg_sptr->netptr->terminal]->net AND unetseg_sptr->nSegType<0) then 
                                 {
                                     unetseg_Flag:=1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 unetseg_sptr:=unetseg_sptr->nextgrd
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(!unetseg_Flag) then 
                         {
                             unetseg_sptr:=unetseg_bptr
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else
                     {
                         if(unetseg_x1!=gxstart) then 
                         {
                             unetseg_sptr:=unetseg_ptr1->nextgrd;
                             while(unetseg_sptr->netptr->newx=unetseg_x1)
                             {
                                 unetseg_sptr:=unetseg_sptr->nextgrd
                             }
                         }
                         else
                         {
                             unetseg_sptr:=unetseg_ptr1
                         }
                     };
                     if(unetseg_ptr2->nSegType<0) then 
                     {
                         unetseg_Flag:=0;
                         unetseg_fptr:=unetseg_ptr2;
                         break$<==0 and skip;
                         while( break$=0 AND  unetseg_fptr->nextgrd!=NULL AND unetseg_fptr->nextgrd->netptr->newx=unetseg_x2)
                         {
                             if(unetseg_net=tearray[unetseg_fptr->nextgrd->netptr->terminal]->net AND unetseg_fptr->nextgrd->nSegType>0) then 
                             {
                                 unetseg_Flag:=1;
                                 unetseg_eptr:=unetseg_ptr2->prevgrd;
                                 while(unetseg_eptr->netptr->newx=unetseg_x2)
                                 {
                                     unetseg_eptr:=unetseg_eptr->prevgrd
                                 };
                                 break$<==1 and skip
                              }
                             else
                             {
                                 unetseg_fptr:=unetseg_fptr->nextgrd
                             }
                         };
                         break$<==0 and skip;
                         if(!unetseg_Flag) then 
                         {
                             unetseg_eptr:=unetseg_ptr2->prevgrd;
                             while(unetseg_eptr->netptr->newx=unetseg_x2)
                             {
                                 if(unetseg_net=tearray[unetseg_eptr->netptr->terminal]->net AND unetseg_eptr->nSegType>0) then 
                                 {
                                     unetseg_Flag:=1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 unetseg_eptr:=unetseg_eptr->prevgrd
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(!unetseg_Flag) then 
                         {
                             unetseg_eptr:=unetseg_fptr
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else
                     {
                         if(unetseg_x2!=gxstop) then 
                         {
                             unetseg_eptr:=unetseg_ptr2->prevgrd;
                             while(unetseg_eptr->netptr->newx=unetseg_x2)
                             {
                                 unetseg_eptr:=unetseg_eptr->prevgrd
                             }
                         }
                         else
                         {
                             unetseg_eptr:=unetseg_ptr2
                         }
                     };
                     unetseg_eptr:=unetseg_eptr->nextgrd;
                     if(unetseg_pin1<=maxterm) then 
                     {
                         unetseg_ptr1->nSegType:=unetseg_ptr1->nSegType-1
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(unetseg_pin2<=maxterm) then 
                     {
                         unetseg_ptr2->nSegType:=unetseg_ptr2->nSegType--1
                         
                     }
                     else 
                     {
                          skip 
                     };
                     unetseg_ptr:=unetseg_sptr;
                     
                     while(unetseg_ptr!=unetseg_eptr)
                     {
                         unetseg_denptr:=unetseg_ptr->dptr;
                         if(unetseg_denptr->nnext!=NULL) then 
                         {
                             unetseg_denptr->nnext->nback:=unetseg_denptr->nback
                             
                         }
                         else 
                         {
                              skip 
                         };
                         unetseg_denptr->nback->nnext:=unetseg_denptr->nnext;
                         unetseg_track:=((unetseg_ptr->ntracks)-1);
                         (unetseg_ptr->ntracks):=(unetseg_ptr->ntracks)-1;
                         unetseg_headptr:=DboxHead[unetseg_channel,unetseg_track]->nnext;
                         if(unetseg_headptr!=NULL) then 
                         {
                             DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                             unetseg_denptr->nnext:=unetseg_headptr;
                             unetseg_headptr->nback:=unetseg_denptr;
                             unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                             
                         }
                         else
                         {
                             DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                             unetseg_denptr->nnext:=NULL;
                             unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                         };
                         unetseg_ptr:=unetseg_ptr->nextgrd
                         
                     };
                     unetseg_segment:=unetseg_segment+1
                 }
                 else
                 {
                     skip
                 }
             }
             else
             {
                 skip
             }
             
         };
         continue<==0 and skip;
         unetseg_index:=unetseg_index+1
         
     };
     unetseg_Lcount<==0 and unetseg_Ucount<==unetseg_Lcount and skip;
     if(ULgrdptr!=NULL) then 
     {
         if(ULgrdptr->netptr->pinloc=0) then 
         {
             unetseg_gdptr:=ULgrdptr->nnextgrd;
             while(unetseg_gdptr->netptr->pinloc=0)
             {
                 unetseg_gdptr:=unetseg_gdptr->nnextgrd
             };
             if((int)unetseg_gdptr->netptr->pinloc=-1) then 
             {
                 unetseg_channel:=unetseg_gdptr->netptr->row
             }
             else
             {
                 unetseg_channel:=unetseg_gdptr->netptr->row+1
             }
         }
         else
         {
             if((int)ULgrdptr->netptr->pinloc=-1) then 
             {
                 unetseg_channel:=ULgrdptr->netptr->row
             }
             else
             {
                 unetseg_channel:=ULgrdptr->netptr->row+1
             }
         }
         
     }
     else
     {
         if(LLgrdptr->netptr->pinloc=0) then 
         {
             unetseg_gdptr:=LLgrdptr->nnextgrd;
             while(unetseg_gdptr->netptr->pinloc=0)
             {
                 unetseg_gdptr:=unetseg_gdptr->nnextgrd
             };
             if((int)unetseg_gdptr->netptr->pinloc=-1) then 
             {
                 unetseg_channel:=unetseg_gdptr->netptr->row
             }
             else
             {
                 unetseg_channel:=unetseg_gdptr->netptr->row+1
             }
             
         }
         else
         {
             if((int)LLgrdptr->netptr->pinloc=-1) then 
             {
                 unetseg_channel:=LLgrdptr->netptr->row
             }
             else
             {
                 unetseg_channel:=LLgrdptr->netptr->row+1
             }
         };
         unetseg_channel:=unetseg_channel+1
     };
     unetseg_up_channel:=unetseg_channel;
     if(ULgrdptr!=NULL) then 
     {
         unetseg_gdptr:=ULgrdptr->nextgrd;
         
         while(unetseg_gdptr!=URgrdptr)
         {
             Shuffle[unetseg_Ucount]:=unetseg_gdptr;
             unetseg_Ucount:=unetseg_Ucount+1;
             unetseg_gdptr:=unetseg_gdptr->nextgrd
             
         };
         qsortgdx((char *)Shuffle,unetseg_Ucount,sizeof(changrdbox*));
         ULgrdptr->nnextgrd:=Shuffle[0];
         Shuffle[0]->nprevgrd:=ULgrdptr;
         if(unetseg_Ucount>=2) then 
         {
             unetseg_i:=0;
             
             while(unetseg_i<=unetseg_Ucount-2)
             {
                 Shuffle[unetseg_i]->nnextgrd:=Shuffle[unetseg_i+1];
                 Shuffle[unetseg_i+1]->nprevgrd:=Shuffle[unetseg_i];
                 unetseg_i:=unetseg_i+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         Shuffle[unetseg_Ucount-1]->nnextgrd:=URgrdptr;
         URgrdptr->nprevgrd:=Shuffle[unetseg_Ucount-1];
         unetseg_gdptr:=ULgrdptr->nnextgrd;
         
         while(unetseg_gdptr!=URgrdptr)
         {
             unetseg_x:=unetseg_gdptr->netptr->xpos;
             unetseg_dtrack:=0;
             if(unetseg_x!=unetseg_gdptr->netptr->newx) then 
             {
                 unetseg_denptr:=unetseg_gdptr->dptr;
                 if(unetseg_denptr->nnext!=NULL) then 
                 {
                     unetseg_denptr->nnext->nback:=unetseg_denptr->nback
                     
                 }
                 else 
                 {
                      skip 
                 };
                 unetseg_denptr->nback->nnext:=unetseg_denptr->nnext;
                 unetseg_tryptr[0]:=unetseg_gdptr->nprevgrd;
                 if(unetseg_tryptr[0]->netptr->xpos!=unetseg_x) then 
                 {
				     unetseg_t:=0;
                     unetseg_tryFlag[unetseg_t]:=0;
                     while(unetseg_tryptr[unetseg_t]->nprevgrd!=NULL AND unetseg_tryptr[unetseg_t]->nprevgrd->netptr->xpos=unetseg_tryptr[0]->netptr->xpos)
                     {
                         unetseg_t:=unetseg_t+1;
                         unetseg_tryptr[unetseg_t]:=unetseg_tryptr[unetseg_t-1]->nprevgrd;
                         unetseg_tryFlag[unetseg_t]:=0
                     };
                     unetseg_i:=0;
                     
                     while(unetseg_i<=unetseg_t)
                     {
                         if(unetseg_tryFlag[unetseg_i]=0) then 
                         {
                             unetseg_changes:=0;
                             unetseg_trynet:=tearray[unetseg_tryptr[unetseg_i]->netptr->terminal]->net;
                             unetseg_changes:=unetseg_changes+unetseg_tryptr[unetseg_i]->nSegType;
                             unetseg_j:=unetseg_i+1;
                             
                             while(unetseg_j<=unetseg_t)
                             {
                                 if(tearray[unetseg_tryptr[unetseg_j]->netptr->terminal]->net=unetseg_trynet) then 
                                 {
                                     unetseg_tryFlag[unetseg_j]:=1;
                                     unetseg_changes:=unetseg_changes+unetseg_tryptr[unetseg_j]->nSegType
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 unetseg_j:=unetseg_j+1
                                 
                             };
                             if(unetseg_changes<0) then 
                             {
                                 unetseg_dtrack:=unetseg_dtrack+unetseg_changes
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         unetseg_i:=unetseg_i+1
                         
                     };
                     unetseg_tryptr[0]:=unetseg_gdptr->nnextgrd;
                     if(unetseg_tryptr[0]->netptr->xpos=unetseg_x) then 
                     {
					     unetseg_t:=0;
                         unetseg_tryFlag[unetseg_t]:=0;
                         while(unetseg_tryptr[unetseg_t]->nnextgrd!=NULL AND unetseg_tryptr[unetseg_t]->nnextgrd->netptr->xpos=unetseg_tryptr[0]->netptr->xpos)
                         {
                             unetseg_t:=unetseg_t+1;
                             unetseg_tryptr[unetseg_t]:=unetseg_tryptr[unetseg_t-1]->nnextgrd;
                             unetseg_tryFlag[unetseg_t]:=0
                         };
                         unetseg_i:=0;
                         
                         while(unetseg_i<=unetseg_t)
                         {
                             if(unetseg_tryFlag[unetseg_i]=0) then 
                             {
                                 unetseg_changes:=0;
                                 unetseg_trynet:=tearray[unetseg_tryptr[unetseg_i]->netptr->terminal]->net;
                                 unetseg_changes:=unetseg_changes+unetseg_tryptr[unetseg_i]->nSegType;
                                 unetseg_j:=unetseg_i+1;
                                 
                                 while(unetseg_j<=unetseg_t)
                                 {
                                     if(tearray[unetseg_tryptr[unetseg_j]->netptr->terminal]->net=unetseg_trynet) then 
                                     {
                                         unetseg_tryFlag[unetseg_j]:=1;
                                         unetseg_changes:=unetseg_changes+unetseg_tryptr[unetseg_j]->nSegType
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     unetseg_j:=unetseg_j+1
                                     
                                 };
                                 if(unetseg_changes>0) then 
                                 {
                                     unetseg_dtrack:=unetseg_dtrack+unetseg_changes
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             unetseg_i:=unetseg_i+1
                             
                         }
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 unetseg_gdptr->ntracks:=unetseg_gdptr->nprevgrd->ntracks+unetseg_dtrack;
                 unetseg_track:=unetseg_gdptr->ntracks;
                 unetseg_headptr:=DboxHead[unetseg_channel,unetseg_track]->nnext;
                 if(unetseg_headptr!=NULL) then 
                 {
                     DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                     unetseg_denptr->nnext:=unetseg_headptr;
                     unetseg_headptr->nback:=unetseg_denptr;
                     unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                 }
                 else
                 {
                     DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                     unetseg_denptr->nnext:=NULL;
                     unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                 }
                 
             }
             else 
             {
                  skip 
             };
             unetseg_gdptr:=unetseg_gdptr->nnextgrd
             
         }
         
     }
     else 
     {
          skip 
     };
     if(LLgrdptr!=NULL) then 
     {
         unetseg_channel:=unetseg_channel-1;
         unetseg_gdptr:=LLgrdptr->nextgrd;
         
         while(unetseg_gdptr!=LRgrdptr)
         {
             Shuffle[unetseg_Lcount]:=unetseg_gdptr;
             unetseg_Lcount:=unetseg_Lcount+1;
             unetseg_gdptr:=unetseg_gdptr->nextgrd
             
         };
         qsortgdx((char *)Shuffle,unetseg_Lcount,sizeof(changrdbox*));
         LLgrdptr->nnextgrd:=Shuffle[0];
         Shuffle[0]->nprevgrd:=LLgrdptr;
         if(unetseg_Lcount>=2) then 
         {
             unetseg_i:=0;
             
             while(unetseg_i<=unetseg_Lcount-2)
             {
                 Shuffle[unetseg_i]->nnextgrd:=Shuffle[unetseg_i+1];
                 Shuffle[unetseg_i+1]->nprevgrd:=Shuffle[unetseg_i];
                 unetseg_i:=unetseg_i+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         Shuffle[unetseg_Lcount-1]->nnextgrd:=LRgrdptr;
         LRgrdptr->nprevgrd:=Shuffle[unetseg_Lcount-1];
         unetseg_gdptr:=LLgrdptr->nnextgrd;
         
         while(unetseg_gdptr!=LRgrdptr)
         {
             unetseg_x:=unetseg_gdptr->netptr->xpos;
             unetseg_dtrack:=0;
             if(unetseg_x!=unetseg_gdptr->netptr->newx) then 
             {
                 unetseg_denptr:=unetseg_gdptr->dptr;
                 if(unetseg_denptr->nnext!=NULL) then 
                 {
                     unetseg_denptr->nnext->nback:=unetseg_denptr->nback
                     
                 }
                 else 
                 {
                      skip 
                 };
                 unetseg_denptr->nback->nnext:=unetseg_denptr->nnext;
                 unetseg_tryptr[0]:=unetseg_gdptr->nprevgrd;
                 if(unetseg_tryptr[0]->netptr->xpos!=unetseg_x) then 
                 {
				     unetseg_t:=0;
                     unetseg_tryFlag[unetseg_t]:=0;
                     while(unetseg_tryptr[unetseg_t]->nprevgrd!=NULL AND unetseg_tryptr[unetseg_t]->nprevgrd->netptr->xpos=unetseg_tryptr[0]->netptr->xpos)
                     {
                         unetseg_t:=unetseg_t+1;
                         unetseg_tryptr[unetseg_t]:=unetseg_tryptr[unetseg_t-1]->nprevgrd;
                         unetseg_tryFlag[unetseg_t]:=0
                     };
                     unetseg_i:=0;
                     
                     while(unetseg_i<=unetseg_t)
                     {
                         if(unetseg_tryFlag[unetseg_i]=0) then 
                         {
                             unetseg_changes:=0;
                             unetseg_trynet:=tearray[unetseg_tryptr[unetseg_i]->netptr->terminal]->net;
                             unetseg_changes:=unetseg_changes+unetseg_tryptr[unetseg_i]->nSegType;
                             unetseg_j:=unetseg_i+1;
                             
                             while(unetseg_j<=unetseg_t)
                             {
                                 if(tearray[unetseg_tryptr[unetseg_j]->netptr->terminal]->net=unetseg_trynet) then 
                                 {
                                     unetseg_tryFlag[unetseg_j]:=1;
                                     unetseg_changes:=unetseg_changes+unetseg_tryptr[unetseg_j]->nSegType
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 unetseg_j:=unetseg_j+1
                                 
                             };
                             if(unetseg_changes<0) then 
                             {
                                 unetseg_dtrack:=unetseg_dtrack+unetseg_changes
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         unetseg_i:=unetseg_i+1
                         
                     };
                     unetseg_tryptr[0]:=unetseg_gdptr->nnextgrd;
                     if(unetseg_tryptr[0]->netptr->xpos=unetseg_x) then 
                     {
					     unetseg_t:=0;
                         unetseg_tryFlag[unetseg_t]:=0;
                         while(unetseg_tryptr[unetseg_t]->nnextgrd!=NULL AND unetseg_tryptr[unetseg_t]->nnextgrd->netptr->xpos=unetseg_tryptr[0]->netptr->xpos)
                         {
                             unetseg_t:=unetseg_t+1;
                             unetseg_tryptr[unetseg_t]:=unetseg_tryptr[unetseg_t-1]->nnextgrd;
                             unetseg_tryFlag[unetseg_t]:=0
                         };
                         unetseg_i:=0;
                         
                         while(unetseg_i<=unetseg_t)
                         {
                             if(unetseg_tryFlag[unetseg_i]=0) then 
                             {
                                 unetseg_changes:=0;
                                 unetseg_trynet:=tearray[unetseg_tryptr[unetseg_i]->netptr->terminal]->net;
                                 unetseg_changes:=unetseg_changes+unetseg_tryptr[unetseg_i]->nSegType;
                                 unetseg_j:=unetseg_i+1;
                                 
                                 while(unetseg_j<=unetseg_t)
                                 {
                                     if(tearray[unetseg_tryptr[unetseg_j]->netptr->terminal]->net=unetseg_trynet) then 
                                     {
                                         unetseg_tryFlag[unetseg_j]:=1;
                                         unetseg_changes:=unetseg_changes+unetseg_tryptr[unetseg_j]->nSegType
                                         
                                     }
                                     else 
                                     {
                                          skip 
                                     };
                                     unetseg_j:=unetseg_j+1
                                     
                                 };
                                 if(unetseg_changes>0) then 
                                 {
                                     unetseg_dtrack:=unetseg_dtrack+unetseg_changes
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 }
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             unetseg_i:=unetseg_i+1
                             
                         }
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 unetseg_gdptr->ntracks:=unetseg_gdptr->nprevgrd->ntracks+unetseg_dtrack;
                 unetseg_track:=unetseg_gdptr->ntracks;
                 unetseg_headptr:=DboxHead[unetseg_channel,unetseg_track]->nnext;
                 if(unetseg_headptr!=NULL) then 
                 {
                     DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                     unetseg_denptr->nnext:=unetseg_headptr;
                     unetseg_headptr->nback:=unetseg_denptr;
                     unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                 }
                 else
                 {
                     DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                     unetseg_denptr->nnext:=NULL;
                     unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                 }
                 
             }
             else 
             {
                  skip 
             };
             unetseg_gdptr:=unetseg_gdptr->nnextgrd
             
         }
         
     }
     else 
     {
          skip 
     };
     if(uneven_cell_height) then 
     {
         if(ULgrdptr!=NULL) then 
         {
             unetseg_channel:=unetseg_up_channel;
             unetseg_gdptr:=ULgrdptr;
             
             while(unetseg_gdptr!=URgrdptr)
             {
                 unetseg_netptr:=unetseg_gdptr->netptr;
                 unetseg_pinloc:=unetseg_netptr->pinloc;
                 if(unetseg_pinloc=1) then 
                 {
                     unetseg_self_reset:=carray[unetseg_netptr->cell]->tileptr->top
                     
                 }
                 else
                 {
                     if(unetseg_pinloc=-1) then 
                     {
                         unetseg_self_reset:=-carray[unetseg_netptr->cell]->tileptr->bottom
                     }
                     else
                     {
                         unetseg_self_reset:=0
                     }
                 };
                 unetseg_gdptr->ntracks:=unetseg_gdptr->ntracks+(unetseg_self_reset+facing_cellheight(unetseg_netptr->terminal,unetseg_netptr->row,unetseg_pinloc,1,RValue))/ track_spacing;
                 unetseg_denptr:=unetseg_gdptr->dptr;
                 if(unetseg_denptr->nnext!=NULL) then 
                 {
                     unetseg_denptr->nnext->nback:=unetseg_denptr->nback
                     
                 }
                 else 
                 {
                      skip 
                 };
                 unetseg_denptr->nback->nnext:=unetseg_denptr->nnext;
                 unetseg_track:=unetseg_gdptr->ntracks;
                 unetseg_headptr:=DboxHead[unetseg_channel,unetseg_track]->nnext;
                 if(unetseg_headptr!=NULL) then 
                 {
                     DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                     unetseg_denptr->nnext:=unetseg_headptr;
                     unetseg_headptr->nback:=unetseg_denptr;
                     unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                     
                 }
                 else
                 {
                     DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                     unetseg_denptr->nnext:=NULL;
                     unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                 };
                 unetseg_gdptr:=unetseg_gdptr->nnextgrd
                 
             }
             
         }
         else 
         {
              skip 
         };
         if(LLgrdptr!=NULL) then 
         {
             unetseg_channel:=unetseg_up_channel-1;
             unetseg_gdptr:=LLgrdptr;
             
             while(unetseg_gdptr!=LRgrdptr)
             {
                 unetseg_netptr:=unetseg_gdptr->netptr;
                 unetseg_pinloc:=unetseg_netptr->pinloc;
                 if(unetseg_pinloc=1) then 
                 {
                     unetseg_self_reset:=carray[unetseg_netptr->cell]->tileptr->top
                     
                 }
                 else
                 {
                     if(unetseg_pinloc=-1) then 
                     {
                         unetseg_self_reset:=-carray[unetseg_netptr->cell]->tileptr->bottom
                     }
                     else
                     {
                         unetseg_self_reset:=0
                     }
                 };
                 unetseg_gdptr->ntracks:=unetseg_gdptr->ntracks+(unetseg_self_reset+facing_cellheight(unetseg_netptr->terminal,unetseg_netptr->row,unetseg_pinloc,1,RValue))/ track_spacing;
                 unetseg_denptr:=unetseg_gdptr->dptr;
                 if(unetseg_denptr->nnext!=NULL) then 
                 {
                     unetseg_denptr->nnext->nback:=unetseg_denptr->nback
                     
                 }
                 else 
                 {
                      skip 
                 };
                 unetseg_denptr->nback->nnext:=unetseg_denptr->nnext;
                 unetseg_track:=unetseg_gdptr->ntracks;
                 unetseg_headptr:=DboxHead[unetseg_channel,unetseg_track]->nnext;
                 if(unetseg_headptr!=NULL) then 
                 {
                     DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                     unetseg_denptr->nnext:=unetseg_headptr;
                     unetseg_headptr->nback:=unetseg_denptr;
                     unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                     
                 }
                 else
                 {
                     DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                     unetseg_denptr->nnext:=NULL;
                     unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                 };
                 unetseg_gdptr:=unetseg_gdptr->nnextgrd
                 
             }
             
         }
         else 
         {
              skip 
         }
         
     }
     else 
     {
          skip 
     };
     unetseg_index:=1;
     
     while(unetseg_index<=netchgs[0])
     {
         unetseg_net:=netchgs[unetseg_index];
         unetseg_b:=anet[unetseg_net];
         unetseg_e:=anet[unetseg_net+1]-1;
         continue<==0 and skip;
         unetseg_segment:=unetseg_b;
         
         while(unetseg_segment<=unetseg_e)
         {
              continue<==0 and skip;
             if(aNetSeg[unetseg_segment].ncurrent=0) then 
             {
                 unetseg_segptr:=aNetSeg[unetseg_segment].ntop
                 
             }
             else
             {
                 unetseg_segptr:=aNetSeg[unetseg_segment].nbot
             };
             unetseg_pin1:=unetseg_segptr->pin1;
             unetseg_pin2:=unetseg_segptr->pin2;
             if(unetseg_pin1>maxterm AND unetseg_pin2>maxterm) then 
             {
                 continue<==1 and skip;
                  unetseg_segment:=unetseg_segment+1
             }
             else 
             {
                  skip 
             };
             if(continue=0)   then 
             {
                 unetseg_ptr1:=unetseg_segptr->pin1ptr;
                 unetseg_ptr2:=unetseg_segptr->pin2ptr;
                 unetseg_x1:=unetseg_ptr1->netptr->xpos;
                 unetseg_x2:=unetseg_ptr2->netptr->xpos;
                 if(unetseg_x1=unetseg_x2) then 
                 {
                     continue<==1 and skip;
                      unetseg_segment:=unetseg_segment+1
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     unetseg_channel:=unetseg_segptr->channel;
                     if(unetseg_channel>gtopChan) then 
                     {
                         gtopChan:=unetseg_channel
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(unetseg_channel<gbotChan) then 
                     {
                         gbotChan:=unetseg_channel
                         
                     }
                     else 
                     {
                          skip 
                     };
                     unetseg_net:=aNetSeg[unetseg_segment].net;
                     if(unetseg_ptr1->nSegType>=0) then 
                     {
                         unetseg_Flag:=0;
                         unetseg_bptr:=unetseg_ptr1;
                         break$<==0 and skip;
                         while( break$=0 AND  unetseg_bptr->nprevgrd!=NULL AND unetseg_bptr->nprevgrd->netptr->xpos=unetseg_x1)
                         {
                             if(tearray[unetseg_bptr->nprevgrd->netptr->terminal]->net=unetseg_net AND unetseg_bptr->nprevgrd->nSegType<0) then 
                             {
                                 unetseg_Flag:=1;
                                 unetseg_sptr:=unetseg_ptr1->nnextgrd;
                                 while(unetseg_sptr->netptr->xpos=unetseg_x1)
                                 {
                                     unetseg_sptr:=unetseg_sptr->nnextgrd
                                 };
                                 break$<==1 and skip
                              }
                             else
                             {
                                 unetseg_bptr:=unetseg_bptr->nprevgrd
                             }
                         };
                         break$<==0 and skip;
                         if(!unetseg_Flag) then 
                         {
                             unetseg_sptr:=unetseg_ptr1->nnextgrd;
                             while(unetseg_sptr->netptr->xpos=unetseg_x1)
                             {
                                 if(unetseg_net=tearray[unetseg_sptr->netptr->terminal]->net AND unetseg_sptr->nSegType<0) then 
                                 {
                                     unetseg_Flag:=1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 unetseg_sptr:=unetseg_sptr->nnextgrd
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(!unetseg_Flag) then 
                         {
                             unetseg_sptr:=unetseg_bptr
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else
                     {
                         unetseg_sptr:=unetseg_ptr1->nnextgrd;
                         while(unetseg_sptr->netptr->xpos=unetseg_x1)
                         {
                             unetseg_sptr:=unetseg_sptr->nnextgrd
                         }
                     };
                     if(unetseg_ptr2->nSegType<=0) then 
                     {
                         unetseg_Flag:=0;
                         unetseg_fptr:=unetseg_ptr2;
                         break$<==0 and skip;
                         while( break$=0 AND  unetseg_fptr->nnextgrd!=NULL AND unetseg_fptr->nnextgrd->netptr->xpos=unetseg_x2)
                         {
                             if(tearray[unetseg_fptr->nnextgrd->netptr->terminal]->net=unetseg_net AND unetseg_fptr->nnextgrd->nSegType>0) then 
                             {
                                 unetseg_Flag:=1;
                                 unetseg_eptr:=unetseg_ptr2->nprevgrd;
                                 while(unetseg_eptr->netptr->xpos=unetseg_x2)
                                 {
                                     unetseg_eptr:=unetseg_eptr->nprevgrd
                                 };
                                 break$<==1 and skip
                              }
                             else
                             {
                                 unetseg_fptr:=unetseg_fptr->nnextgrd
                             }
                         };
                         break$<==0 and skip;
                         if(!unetseg_Flag) then 
                         {
                             unetseg_eptr:=unetseg_ptr2->nprevgrd;
                             while(unetseg_eptr->netptr->xpos=unetseg_x2)
                             {
                                 if(unetseg_net=tearray[unetseg_eptr->netptr->terminal]->net AND unetseg_eptr->nSegType>0) then 
                                 {
                                     unetseg_Flag:=1
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 unetseg_eptr:=unetseg_eptr->nprevgrd
                             }
                             
                         }
                         else 
                         {
                              skip 
                         };
                         if(!unetseg_Flag) then 
                         {
                             unetseg_eptr:=unetseg_fptr
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else
                     {
                         unetseg_eptr:=unetseg_ptr2->nprevgrd;
                         while(unetseg_eptr->netptr->xpos=unetseg_x2)
                         {
                             unetseg_eptr:=unetseg_eptr->nprevgrd
                         }
                     };
                     unetseg_eptr:=unetseg_eptr->nnextgrd;
                     if(unetseg_pin1<=maxterm) then 
                     {
                         unetseg_ptr1->nSegType:=unetseg_ptr1->nSegType+1
                         
                     }
                     else 
                     {
                          skip 
                     };
                     if(unetseg_pin2<=maxterm) then 
                     {
                         unetseg_ptr2->nSegType:=unetseg_ptr2->nSegType+-1
                         
                     }
                     else 
                     {
                          skip 
                     };
                     unetseg_ptr:=unetseg_sptr;
                     
                     while(unetseg_ptr!=unetseg_eptr)
                     {
                         unetseg_denptr:=unetseg_ptr->dptr;
                         if(unetseg_denptr->nnext!=NULL) then 
                         {
                             unetseg_denptr->nnext->nback:=unetseg_denptr->nback
                             
                         }
                         else 
                         {
                              skip 
                         };
                         unetseg_denptr->nback->nnext:=unetseg_denptr->nnext;
                         unetseg_track:=((unetseg_ptr->ntracks)+1);
                         (unetseg_ptr->ntracks):=(unetseg_ptr->ntracks)+1;
                         unetseg_headptr:=DboxHead[unetseg_channel,unetseg_track]->nnext;
                         if(unetseg_headptr!=NULL) then 
                         {
                             DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                             unetseg_denptr->nnext:=unetseg_headptr;
                             unetseg_headptr->nback:=unetseg_denptr;
                             unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                             
                         }
                         else
                         {
                             DboxHead[unetseg_channel,unetseg_track]->nnext:=unetseg_denptr;
                             unetseg_denptr->nnext:=NULL;
                             unetseg_denptr->nback:=DboxHead[unetseg_channel,unetseg_track]
                         };
                         unetseg_ptr:=unetseg_ptr->nnextgrd
                         
                     };
                     unetseg_segment:=unetseg_segment+1
                 }
                 else
                 {
                     skip
                 }
             }
             else
             {
                 skip
             }
             
         };
         continue<==0 and skip;
         unetseg_index:=unetseg_index+1
         
     };
     unetseg_chan:=1;
     
     while(unetseg_chan<=numChans)
     {
         break$<==0 and skip;
         unetseg_track:=max_tdensity+30;
         
         while( break$=0 AND  unetseg_track>=0)
         {
             if(DboxHead[unetseg_chan,unetseg_track]->nnext!=NULL) then 
             {
                 break$<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(break$=0)   then
             {
                 unetseg_track:=unetseg_track-1
             }
             else
             {
                 skip
             }
             
         };
         break$<==0 and skip;
         nmaxTrack[unetseg_chan]:=unetseg_track;
         tracks:=tracks+unetseg_track;
         unetseg_chan:=unetseg_chan+1
         
     };
      return<==1 and skip
     )
     }; 
      int first_time_in_unlap<==1 and skip;
     int noPairs and skip;
 function unlap ( int flag )
 {
     frame(unlap_cellptr,unlap_num,unlap_i,unlap_cell_count,unlap_space,unlap_cell,unlap_block,unlap_cell_left,unlap_left_edge,unlap_right_edge,unlap_fixed,unlap_unfixed,unlap_left_queue,unlap_right_queue,unlap_center_queue,unlap_max_cell_in_blk,unlap_min_right_fixed_cell,unlap_max_left_fixed_cell,unlap_pair_array_index,unlap_total_cells,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     cellbox* unlap_cellptr and skip;
     int *unlap_num,unlap_i,unlap_cell_count,unlap_space and skip;
     int unlap_cell,unlap_block and skip;
     int unlap_cell_left,unlap_left_edge,unlap_right_edge and skip;
     int unlap_fixed,unlap_unfixed and skip;
     int *unlap_left_queue,*unlap_right_queue,*unlap_center_queue and skip;
     int unlap_max_cell_in_blk and skip;
     int unlap_min_right_fixed_cell and skip;
     int unlap_max_left_fixed_cell and skip;
     int unlap_pair_array_index,unlap_total_cells and skip;
     unlap_num:=(int *)safe_malloc((numblock+1)*sizeof(int),RValue);
     unlap_block:=0;
     
     while(unlap_block<=numblock)
     {
         unlap_num[unlap_block]:=0;
         unlap_block:=unlap_block+1
         
     };
     if(flag=-2) then 
     {
         unlap_total_cells:=numcells+ffeeds
         
     }
     else
     {
         unlap_total_cells:=numcells
     };
     unlap_cell:=1;
     
     while(unlap_cell<=unlap_total_cells)
     {
         unlap_num[carray[unlap_cell]->cblock]:=unlap_num[carray[unlap_cell]->cblock]+1;
         unlap_cell:=unlap_cell+1
         
     };
     if(!first_time_in_unlap) then 
     {
         unlap_block:=1;
         
         while(unlap_block<=numblock)
         {
             safe_free(pairArray[unlap_block]);
             unlap_block:=unlap_block+1
             
         };
         safe_free(pairArray)
         
     }
     else
     {
         first_time_in_unlap:=0
     };
     pairArray:=(int **)safe_malloc((numblock+1)*sizeof(int *),RValue);
     unlap_max_cell_in_blk:=0;
     unlap_block:=1;
     
     while(unlap_block<=numblock)
     {
         pairArray[unlap_block]:=(int *)safe_malloc((unlap_num[unlap_block]+1)*sizeof(int),RValue);
         pairArray[unlap_block,0]:=unlap_num[unlap_block];
         if(unlap_num[unlap_block]>unlap_max_cell_in_blk) then 
         {
             unlap_max_cell_in_blk:=unlap_num[unlap_block]
             
         }
         else 
         {
              skip 
         };
         unlap_block:=unlap_block+1
         
     };
     unlap_left_queue:=(int *)safe_malloc((unlap_max_cell_in_blk+1)*sizeof(int),RValue);
     unlap_right_queue:=(int *)safe_malloc((unlap_max_cell_in_blk+1)*sizeof(int),RValue);
     unlap_center_queue:=(int *)safe_malloc((unlap_max_cell_in_blk+1)*sizeof(int),RValue);
     unlap_cell:=1;
     
     while(unlap_cell<=unlap_total_cells)
     {
         unlap_block:=carray[unlap_cell]->cblock;
         pairArray[unlap_block,unlap_num[unlap_block]]:=unlap_cell;
         unlap_num[unlap_block]:=unlap_num[unlap_block]-1;
         unlap_cell:=unlap_cell+1
         
     };
     unlap_block:=1;
	 /*tempi:=1; 
     while(tempi<3)
	 {tempj:=0;
		while(tempj<=14)
		{
			output(pairArray[tempi,tempj]," ") and skip;
			tempj:=tempj+1
		};
		tempi:=tempi+1;
		output("\n") and skip
	 };*/

     while(unlap_block<=numblock)
     {
         qsortx((char *)(pairArray[unlap_block]+1),pairArray[unlap_block,0],sizeof(int));
         unlap_block:=unlap_block+1
         
     };
	 
     unlap_block:=1;
     
     while(unlap_block<=numblock)
     {
         unlap_left_edge:=barray[unlap_block]->bxcenter+barray[unlap_block]->bleft;
         unlap_right_edge:=barray[unlap_block]->bxcenter+barray[unlap_block]->bright;
         unlap_cell_count:=pairArray[unlap_block,0] ;
         if((unlap_cell_count)>1) then 
         {
             noPairs:=0
             
         }
         else 
         {
              skip 
         };
         unlap_fixed:=0;
         unlap_unfixed:=0;
         unlap_i:=1;
         
         while(unlap_i<=unlap_cell_count)
         {
             if(carray[pairArray[unlap_block,unlap_i]]->cclass=-1) then 
             {
                 unlap_fixed:=1
                 
             }
             else
             {
                 unlap_unfixed:=1
             };
             unlap_i:=unlap_i+1
             
         };
         if(unlap_fixed=1 AND unlap_unfixed=1) then 
         {
             unlap_i:=0;
             
             while(unlap_i<=unlap_max_cell_in_blk)
             {
                 unlap_left_queue[unlap_i]:=0;
                 unlap_right_queue[unlap_i]:=0;
                 unlap_center_queue[unlap_i]:=0;
                 unlap_i:=unlap_i+1
                 
             };
             unlap_max_left_fixed_cell:=0;
             break$<==0 and skip;
             unlap_i:=1;
             
             while( break$=0 AND  unlap_i<=unlap_cell_count)
             {
                 unlap_cellptr:=carray[pairArray[unlap_block,unlap_i]];
                 if(unlap_cellptr->cclass=-1) then 
                 {
                     if(unlap_left_edge=unlap_cellptr->cxcenter+unlap_cellptr->tileptr->left) then 
                     {
                         unlap_left_edge:=unlap_left_edge+unlap_cellptr->clength;
                         unlap_left_queue[((* unlap_left_queue)+1)]:=pairArray[unlap_block,unlap_i];
                         (* unlap_left_queue):=(* unlap_left_queue)+1;
                         unlap_max_left_fixed_cell:=unlap_i
                     }
                     else
                     {
                         break$<==1 and skip
                      }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then 
                 {
                     unlap_i:=unlap_i+1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             unlap_min_right_fixed_cell:=unlap_cell_count+1;
             break$<==0 and skip;
             unlap_i:=unlap_cell_count;
             
             while( break$=0 AND  unlap_i>=1)
             {
                 unlap_cellptr:=carray[pairArray[unlap_block,unlap_i]];
                 if(unlap_cellptr->cclass=-1) then 
                 {
                     if(unlap_right_edge=unlap_cellptr->cxcenter+unlap_cellptr->tileptr->right) then 
                     {
                         unlap_right_edge:=unlap_right_edge-unlap_cellptr->clength;
                         unlap_right_queue[((* unlap_right_queue)+1)]:=pairArray[unlap_block,unlap_i];
                         (* unlap_right_queue):=(* unlap_right_queue)+1;
                         unlap_min_right_fixed_cell:=unlap_i
                     }
                     else
                     {
                         break$<==1 and skip
                      }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 if(break$=0)   then 
                 {
                     unlap_i:=unlap_i-1
                 }
                 else
                 {
                     skip
                 }
                 
             };
             break$<==0 and skip;
             unlap_i:=1;
             
             while(unlap_i<=unlap_cell_count)
             {
                 unlap_cellptr:=carray[pairArray[unlap_block,unlap_i]];
                 if((unlap_cellptr->cclass!=-1) OR (unlap_cellptr->cclass=-1 AND unlap_i>unlap_max_left_fixed_cell AND unlap_i<unlap_min_right_fixed_cell)) then 
                 {
                     unlap_center_queue[((* unlap_center_queue)+1)]:=pairArray[unlap_block,unlap_i];
                     (* unlap_center_queue):=(* unlap_center_queue)+1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 unlap_i:=unlap_i+1
                 
             };
             unlap_pair_array_index:=0;
             unlap_i:=1;
             
             while(unlap_i<=* unlap_left_queue)
             {
                 pairArray[unlap_block,(unlap_pair_array_index+1)]:=unlap_left_queue[unlap_i];
                 unlap_pair_array_index:=unlap_pair_array_index+1;
                 unlap_i:=unlap_i+1
                 
             };
             unlap_i:=1;
             
             while(unlap_i<=* unlap_center_queue)
             {
                 pairArray[unlap_block,(unlap_pair_array_index+1)]:=unlap_center_queue[unlap_i];
                 unlap_pair_array_index:=unlap_pair_array_index+1;
                 unlap_i:=unlap_i+1
                 
             };
             unlap_i:=* unlap_right_queue;
             
             while(unlap_i>=1)
             {
                 pairArray[unlap_block,(unlap_pair_array_index+1)]:=unlap_right_queue[unlap_i];
                 unlap_pair_array_index:=unlap_pair_array_index+1;
                 unlap_i:=unlap_i-1
                 
             }
             
         }
         else 
         {
              skip 
         };
         unlap_left_edge:=barray[unlap_block]->bxcenter+barray[unlap_block]->bleft;
         if(flag=1) then 
         {
             unlap_space:=(int)((float)(feeds_in_row[unlap_block]*binWidth)/ (float)(unlap_cell_count-1))
             
         }
         else
         {
             unlap_space:=0
         };
         unlap_i:=1;
         
         while(unlap_i<=unlap_cell_count)
         {
             unlap_cellptr:=carray[pairArray[unlap_block,unlap_i]];
             unlap_cell_left:=unlap_cellptr->tileptr->left;
             unlap_cellptr->cxcenter:=unlap_left_edge-unlap_cell_left;
             unlap_left_edge:=unlap_left_edge+unlap_cellptr->tileptr->right-unlap_cell_left+unlap_space;
             unlap_i:=unlap_i+1
             
         };
         unlap_block:=unlap_block+1
         
     };
     safe_free(unlap_num);
     safe_free(unlap_left_queue);
     safe_free(unlap_right_queue);
     safe_free(unlap_center_queue);
     if(flag>=0) then 
     {
         xcompact(RValue)
         
     }
     else 
     {
          skip 
     };
      return<==1 and skip
     )
     }; 
  function upair ( int RValue )
 {
     frame(upair_acellptr,upair_bcellptr,upair_ablckptr,upair_a,upair_b,upair_ablock,upair_aorient,upair_flips,upair_attempts,upair_axcenter,upair_anxcenter,upair_bnxcenter,upair_aleft,upair_aright,upair_startx1,upair_endx1,upair_cellleft,upair_cellrite,upair_leftEdge,upair_riteEdge,upair_aptr,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     cellbox* upair_acellptr,*upair_bcellptr and skip;
     blockbox* upair_ablckptr and skip;
     int upair_a,upair_b,upair_ablock,upair_aorient and skip;
     int upair_flips,upair_attempts and skip;
     int upair_axcenter,upair_anxcenter,upair_bnxcenter and skip;
     int upair_aleft,upair_aright and skip;
     int upair_startx1,upair_endx1 and skip;
     int upair_cellleft,upair_cellrite and skip;
     int upair_leftEdge,upair_riteEdge and skip;
     int upair_aptr and skip;
     upair_flips:=0;
     upair_attempts:=0;
     while(upair_attempts<attmax)
     {
         continue<==0 and skip;
         upair_ablock:=PICK_INT(1,numblock,RValue);
         if(pairArray[upair_ablock,0]<=1) then 
         {
             continue<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             upair_aptr:=PICK_INT(1,pairArray[upair_ablock,0],RValue);
             upair_a:=pairArray[upair_ablock,upair_aptr];
             upair_acellptr:=carray[upair_a];
             if(upair_acellptr->cclass=-1) then 
             {
                 continue<==1 and skip
                  
             }
             else 
             {
                  skip 
             };
             if(continue=0)   then 
             {
                 upair_aorient:=upair_acellptr->corient;
                 upair_ablckptr:=barray[upair_ablock];
                 upair_axcenter:=upair_acellptr->cxcenter;
                 upair_aleft:=upair_acellptr->tileptr->left;
                 upair_aright:=upair_acellptr->tileptr->right;
                 upair_startx1:=upair_axcenter+upair_aleft;
                 upair_endx1:=upair_axcenter+upair_aright;
                 if(upair_aptr>1) then 
                 {
                     upair_cellleft:=pairArray[upair_ablock,upair_aptr-1];
                     if(carray[upair_cellleft]->cclass=-1) then 
                     {
                         upair_cellleft:=0
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else
                 {
                     upair_cellleft:=0
                 };
                 if(upair_aptr<pairArray[upair_ablock,0]) then 
                 {
                     upair_cellrite:=pairArray[upair_ablock,upair_aptr+1];
                     if(carray[upair_cellrite]->cclass=-1) then 
                     {
                         upair_cellrite:=0
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else
                 {
                     upair_cellrite:=0
                 };
                 if(upair_cellleft=0 AND upair_cellrite=0) then 
                 {
                     continue<==1 and skip
                      
                 }
                 else 
                 {
                      skip 
                 };
                 if(continue=0)   then 
                 {
                     if(upair_cellleft!=0 AND upair_cellrite!=0) then 
                     {
                         if(extern PICK_INT(1,2,RValue)=1) then 
                         {
                             upair_b:=upair_cellleft;
                             upair_bcellptr:=carray[upair_b];
                             upair_leftEdge:=upair_bcellptr->cxcenter+upair_bcellptr->tileptr->left;
                             upair_anxcenter:=upair_leftEdge-upair_aleft;
                             upair_bnxcenter:=upair_endx1-upair_bcellptr->tileptr->right;
                             if(extern ucxxp(upair_a,upair_b,upair_anxcenter,upair_bnxcenter)) then 
                             {
                                 upair_flips:=upair_flips+1;
                                 upair_attempts:=upair_attempts+1;
                                 pairArray[upair_ablock,upair_aptr]:=upair_b;
                                 pairArray[upair_ablock,upair_aptr-1]:=upair_a
                             }
                             else
                             {
                                 upair_attempts:=upair_attempts+1;
                                 upair_b:=upair_cellrite;
                                 upair_bcellptr:=carray[upair_b];
                                 upair_riteEdge:=upair_bcellptr->cxcenter+upair_bcellptr->tileptr->right;
                                 upair_anxcenter:=upair_riteEdge-upair_aright;
                                 upair_bnxcenter:=upair_startx1-upair_bcellptr->tileptr->left;
                                 if(extern ucxxp(upair_a,upair_b,upair_anxcenter,upair_bnxcenter)) then 
                                 {
                                     upair_flips:=upair_flips+1;
                                     pairArray[upair_ablock,upair_aptr]:=upair_b;
                                     pairArray[upair_ablock,upair_aptr+1]:=upair_a
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 upair_attempts:=upair_attempts+1
                             }
                         }
                         else
                         {
                             upair_b:=upair_cellrite;
                             upair_bcellptr:=carray[upair_b];
                             upair_riteEdge:=upair_bcellptr->cxcenter+upair_bcellptr->tileptr->right;
                             upair_anxcenter:=upair_riteEdge-upair_aright;
                             upair_bnxcenter:=upair_startx1-upair_bcellptr->tileptr->left;
                             if(extern ucxxp(upair_a,upair_b,upair_anxcenter,upair_bnxcenter)) then 
                             {
                                 upair_flips:=upair_flips+1;
                                 upair_attempts:=upair_attempts+1;
                                 pairArray[upair_ablock,upair_aptr]:=upair_b;
                                 pairArray[upair_ablock,upair_aptr+1]:=upair_a
                             }
                             else
                             {
                                 upair_attempts:=upair_attempts+1;
                                 upair_b:=upair_cellleft;
                                 upair_bcellptr:=carray[upair_b];
                                 upair_leftEdge:=upair_bcellptr->cxcenter+upair_bcellptr->tileptr->left;
                                 upair_anxcenter:=upair_leftEdge-upair_aleft;
                                 upair_bnxcenter:=upair_endx1-upair_bcellptr->tileptr->right;
                                 if(extern ucxxp(upair_a,upair_b,upair_anxcenter,upair_bnxcenter)) then 
                                 {
                                     upair_flips:=upair_flips+1;
                                     pairArray[upair_ablock,upair_aptr]:=upair_b;
                                     pairArray[upair_ablock,upair_aptr-1]:=upair_a
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 upair_attempts:=upair_attempts+1
                             }
                         }
                         
                     }
                     else
                     {
                         if(upair_cellleft) then 
                         {
                             upair_b:=upair_cellleft;
                             upair_bcellptr:=carray[upair_b];
                             upair_leftEdge:=upair_bcellptr->cxcenter+upair_bcellptr->tileptr->left;
                             upair_anxcenter:=upair_leftEdge-upair_aleft;
                             upair_bnxcenter:=upair_endx1-upair_bcellptr->tileptr->right;
                             if(extern ucxxp(upair_a,upair_b,upair_anxcenter,upair_bnxcenter)) then 
                             {
                                 upair_flips:=upair_flips+1;
                                 pairArray[upair_ablock,upair_aptr]:=upair_b;
                                 pairArray[upair_ablock,upair_aptr-1]:=upair_a
                                 
                             }
                             else 
                             {
                                  skip 
                             };
                             upair_attempts:=upair_attempts+1
                         }
                         else
                         {
                             if(upair_cellrite!=0 AND carray[upair_cellrite]->cclass!=-1 AND upair_acellptr->cclass!=-1) then 
                             {
                                 upair_b:=upair_cellrite;
                                 upair_bcellptr:=carray[upair_b];
                                 upair_riteEdge:=upair_bcellptr->cxcenter+upair_bcellptr->tileptr->right;
                                 upair_anxcenter:=upair_riteEdge-upair_aright;
                                 upair_bnxcenter:=upair_startx1-upair_bcellptr->tileptr->left;
                                 if(extern ucxxp(upair_a,upair_b,upair_anxcenter,upair_bnxcenter)) then 
                                 {
                                     upair_flips:=upair_flips+1;
                                     pairArray[upair_ablock,upair_aptr]:=upair_b;
                                     pairArray[upair_ablock,upair_aptr+1]:=upair_a
                                     
                                 }
                                 else 
                                 {
                                      skip 
                                 };
                                 upair_attempts:=upair_attempts+1
                                 
                             }
                             else 
                             {
                                  skip 
                             }
                         }
                     };
                     if(upair_ablckptr->borient=1) then 
                     {
                         if(upair_acellptr->orflag!=0) then 
                         {
                             uc0(upair_a,( if((upair_aorient=0)) then 2 else 0))
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                     else
                     {
                         if(upair_acellptr->orflag!=0) then 
                         {
                             uc0(upair_a,( if((upair_aorient=1)) then 3 else 1))
                             
                         }
                         else 
                         {
                              skip 
                         }
                     }
                 }
                 else
                 {
                     skip
                 }
             }
             else
             {
                 skip
             }
         }
         else
         {
             skip
         }
     };
     continue<==0 and skip;
     fprintf(fpo," %3d %6.3f %9d  %3d%\n",iteration+1,T,funccost,(int)(100.0*(float)upair_flips/ (float)attmax)) and skip;
     fflush(fpo) and skip;
      return<==1 and skip
     )
     }; 
  function urcost ( int segment,int RValue )
 {
     frame(urcost_asegptr,urcost_bsegptr,urcost_aptr1,urcost_aptr2,urcost_bptr1,urcost_bptr2,urcost_bptr,urcost_fptr,urcost_ptr,urcost_saptr,urcost_eaptr,urcost_sbptr,urcost_ebptr,urcost_denptr,urcost_headptr,urcost_penalty,urcost_check,urcost_x,urcost_achannel,urcost_bchannel,urcost_aMaxVal,urcost_bMaxVal,urcost_maxaa,urcost_maxbb,urcost_aoutside,urcost_binside,urcost_ax1,urcost_ax2,urcost_bx1,urcost_bx2,urcost_net,urcost_Flag,urcost_track,return,break$) and ( 
     int break$<==0 and skip;
     int return<==0 and skip;
     segbox* urcost_asegptr,*urcost_bsegptr and skip;
     changrdbox* urcost_aptr1,*urcost_aptr2,*urcost_bptr1,*urcost_bptr2,*urcost_bptr,*urcost_fptr,*urcost_ptr and skip;
     changrdbox* urcost_saptr,*urcost_eaptr,*urcost_sbptr,*urcost_ebptr and skip;
     densitybox* urcost_denptr,*urcost_headptr and skip;
     int urcost_penalty,urcost_check and skip;
     int urcost_x,urcost_achannel,urcost_bchannel,urcost_aMaxVal,urcost_bMaxVal and skip;
     int urcost_maxaa,urcost_maxbb and skip;
     int urcost_aoutside,urcost_binside and skip;
     int urcost_ax1,urcost_ax2,urcost_bx1,urcost_bx2 and skip;
     int urcost_net,urcost_Flag,urcost_track and skip;
     urcost_penalty:=0;
     urcost_net:=aNetSeg[segment].net;
     if(aNetSeg[segment].current=0) then 
     {
         urcost_asegptr:=aNetSeg[segment].top;
         urcost_bsegptr:=aNetSeg[segment].bot
         
     }
     else
     {
         urcost_asegptr:=aNetSeg[segment].bot;
         urcost_bsegptr:=aNetSeg[segment].top
     };
     urcost_achannel:=urcost_asegptr->channel;
     urcost_bchannel:=urcost_bsegptr->channel;
     urcost_aptr1:=urcost_asegptr->pin1ptr;
     urcost_aptr2:=urcost_asegptr->pin2ptr;
     urcost_bptr1:=urcost_bsegptr->pin1ptr;
     urcost_bptr2:=urcost_bsegptr->pin2ptr;
     urcost_aMaxVal:=maxTrack[urcost_achannel];
     urcost_bMaxVal:=maxTrack[urcost_bchannel];
     urcost_ax1:=urcost_aptr1->netptr->xpos;
     urcost_ax2:=urcost_aptr2->netptr->xpos;
     urcost_bx1:=urcost_bptr1->netptr->xpos;
     urcost_bx2:=urcost_bptr2->netptr->xpos;
     urcost_net:=aNetSeg[segment].net;
     if(urcost_aptr1->SegType>0) then 
     {
         urcost_Flag:=0;
         urcost_bptr:=urcost_aptr1;
         break$<==0 and skip;
         while( break$=0 AND  urcost_bptr->prevgrd!=NULL AND urcost_bptr->prevgrd->netptr->xpos=urcost_ax1)
         {
             if(urcost_net=tearray[urcost_bptr->prevgrd->netptr->terminal]->net AND urcost_bptr->prevgrd->SegType<0) then 
             {
                 urcost_Flag:=1;
                 urcost_saptr:=urcost_aptr1->nextgrd;
                 while(urcost_saptr->netptr->xpos=urcost_ax1)
                 {
                     urcost_saptr:=urcost_saptr->nextgrd
                 };
                 break$<==1 and skip
              }
             else
             {
                 urcost_bptr:=urcost_bptr->prevgrd
             }
         };
         break$<==0 and skip;
         if(!urcost_Flag) then 
         {
             urcost_saptr:=urcost_aptr1->nextgrd;
             while(urcost_saptr->netptr->xpos=urcost_ax1)
             {
                 if(urcost_net=tearray[urcost_saptr->netptr->terminal]->net AND urcost_saptr->SegType<0) then 
                 {
                     urcost_Flag:=1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 urcost_saptr:=urcost_saptr->nextgrd
             }
             
         }
         else 
         {
              skip 
         };
         if(!urcost_Flag) then 
         {
             urcost_saptr:=urcost_bptr
             
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         if(urcost_ax1!=gxstart) then 
         {
             urcost_saptr:=urcost_aptr1->nextgrd;
             while(urcost_saptr->netptr->xpos=urcost_ax1)
             {
                 urcost_saptr:=urcost_saptr->nextgrd
             }
         }
         else
         {
             urcost_saptr:=urcost_aptr1
         }
     };
     if(urcost_aptr2->SegType<0) then 
     {
         urcost_Flag:=0;
         urcost_fptr:=urcost_aptr2;
         break$<==0 and skip;
         while( break$=0 AND  urcost_fptr->nextgrd!=NULL AND urcost_fptr->nextgrd->netptr->xpos=urcost_ax2)
         {
             if(urcost_net=tearray[urcost_fptr->nextgrd->netptr->terminal]->net AND urcost_fptr->nextgrd->SegType>0) then 
             {
                 urcost_Flag:=1;
                 urcost_eaptr:=urcost_aptr2->prevgrd;
                 while(urcost_eaptr->netptr->xpos=urcost_ax2)
                 {
                     urcost_eaptr:=urcost_eaptr->prevgrd
                 };
                 break$<==1 and skip
              }
             else
             {
                 urcost_fptr:=urcost_fptr->nextgrd
             }
         };
         break$<==0 and skip;
         if(!urcost_Flag) then 
         {
             urcost_eaptr:=urcost_aptr2->prevgrd;
             while(urcost_eaptr->netptr->xpos=urcost_ax2)
             {
                 if(urcost_net=tearray[urcost_eaptr->netptr->terminal]->net AND urcost_eaptr->SegType>0) then 
                 {
                     urcost_Flag:=1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 urcost_eaptr:=urcost_eaptr->prevgrd
             }
             
         }
         else 
         {
              skip 
         };
         if(!urcost_Flag) then 
         {
             urcost_eaptr:=urcost_fptr
             
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         if(urcost_ax2!=gxstop) then 
         {
             urcost_eaptr:=urcost_aptr2->prevgrd;
             while(urcost_eaptr->netptr->xpos=urcost_ax2)
             {
                 urcost_eaptr:=urcost_eaptr->prevgrd
             }
         }
         else
         {
             urcost_eaptr:=urcost_aptr2
         }
     };
     if(urcost_bptr1->SegType>=0) then 
     {
         urcost_Flag:=0;
         urcost_bptr:=urcost_bptr1;
         break$<==0 and skip;
         while( break$=0 AND  urcost_bptr->prevgrd!=NULL AND urcost_bptr->prevgrd->netptr->xpos=urcost_bx1)
         {
             if(urcost_net=tearray[urcost_bptr->prevgrd->netptr->terminal]->net AND urcost_bptr->prevgrd->SegType<0) then 
             {
                 urcost_Flag:=1;
                 urcost_sbptr:=urcost_bptr1->nextgrd;
                 while(urcost_sbptr->netptr->xpos=urcost_bx1)
                 {
                     urcost_sbptr:=urcost_sbptr->nextgrd
                 };
                 break$<==1 and skip
              }
             else
             {
                 urcost_bptr:=urcost_bptr->prevgrd
             }
         };
         break$<==0 and skip;
         if(!urcost_Flag) then 
         {
             urcost_sbptr:=urcost_bptr1->nextgrd;
             while(urcost_sbptr->netptr->xpos=urcost_bx1)
             {
                 if(urcost_net=tearray[urcost_sbptr->netptr->terminal]->net AND urcost_sbptr->SegType<0) then 
                 {
                     urcost_Flag:=1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 urcost_sbptr:=urcost_sbptr->nextgrd
             }
             
         }
         else 
         {
              skip 
         };
         if(!urcost_Flag) then 
         {
             urcost_sbptr:=urcost_bptr
             
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         urcost_sbptr:=urcost_bptr1->nextgrd;
         while(urcost_sbptr->netptr->xpos=urcost_bx1)
         {
             urcost_sbptr:=urcost_sbptr->nextgrd
         }
     };
     if(urcost_bptr2->SegType<=0) then 
     {
         urcost_Flag:=0;
         urcost_fptr:=urcost_bptr2;
         break$<==0 and skip;
         while( break$=0 AND  urcost_fptr->nextgrd!=NULL AND urcost_fptr->nextgrd->netptr->xpos=urcost_bx2)
         {
             if(urcost_net=tearray[urcost_fptr->nextgrd->netptr->terminal]->net AND urcost_fptr->nextgrd->SegType>0) then 
             {
                 urcost_Flag:=1;
                 urcost_ebptr:=urcost_bptr2->prevgrd;
                 while(urcost_ebptr->netptr->xpos=urcost_bx2)
                 {
                     urcost_ebptr:=urcost_ebptr->prevgrd
                 };
                 break$<==1 and skip
              }
             else
             {
                 urcost_fptr:=urcost_fptr->nextgrd
             }
         };
         break$<==0 and skip;
         if(!urcost_Flag) then 
         {
             urcost_ebptr:=urcost_bptr2->prevgrd;
             while(urcost_ebptr->netptr->xpos=urcost_bx2)
             {
                 if(urcost_net=tearray[urcost_ebptr->netptr->terminal]->net AND urcost_ebptr->SegType>0) then 
                 {
                     urcost_Flag:=1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 urcost_ebptr:=urcost_ebptr->prevgrd
             }
             
         }
         else 
         {
              skip 
         };
         if(!urcost_Flag) then 
         {
             urcost_ebptr:=urcost_fptr
             
         }
         else 
         {
              skip 
         }
         
     }
     else
     {
         urcost_ebptr:=urcost_bptr2->prevgrd;
         while(urcost_ebptr->netptr->xpos=urcost_bx2)
         {
             urcost_ebptr:=urcost_ebptr->prevgrd
         }
     };
     urcost_aoutside:=0;
     urcost_ax1:=urcost_saptr->netptr->xpos;
     urcost_ax2:=urcost_eaptr->netptr->xpos;
     urcost_denptr:=DboxHead[urcost_achannel,urcost_aMaxVal]->next$;
     break$<==0 and skip;
     while( break$=0 AND  urcost_denptr!=NULL)
     {
         urcost_x:=urcost_denptr->grdptr->netptr->xpos;
         if(!(urcost_ax1<=urcost_x AND urcost_ax2>=urcost_x)) then 
         {
             urcost_aoutside:=1;
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             urcost_denptr:=urcost_denptr->next$
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     if(urcost_aoutside=0) then 
     {
         urcost_penalty:=urcost_penalty-1
         
     }
     else 
     {
          skip 
     };
     urcost_binside:=0;
     urcost_bx1:=urcost_sbptr->netptr->xpos;
     urcost_bx2:=urcost_ebptr->netptr->xpos;
     urcost_denptr:=DboxHead[urcost_bchannel,urcost_bMaxVal]->next$;
     break$<==0 and skip;
     while( break$=0 AND  urcost_denptr!=NULL)
     {
         urcost_x:=urcost_denptr->grdptr->netptr->xpos;
         if(urcost_bx1<=urcost_x AND urcost_bx2>=urcost_x) then 
         {
             urcost_binside:=1;
             break$<==1 and skip
              
         }
         else 
         {
              skip 
         };
         if(break$=0)   then
         {
             urcost_denptr:=urcost_denptr->next$
         }
         else
         {
             skip
         }
         
     };
     break$<==0 and skip;
     if(urcost_binside=1) then 
     {
         urcost_penalty:=urcost_penalty+1
         
     }
     else 
     {
          skip 
     };
     urcost_eaptr:=urcost_eaptr->nextgrd;
     urcost_ebptr:=urcost_ebptr->nextgrd;
     if(urcost_penalty=0) then 
     {
         if(urcost_binside=1 AND urcost_aoutside=0) then 
         {
             urcost_check:=urcost_bMaxVal-urcost_aMaxVal+2
         }
         else
         {
             urcost_maxaa:=0;
             urcost_maxbb:=0;
             urcost_ptr:=urcost_saptr;
             
             while(urcost_ptr!=urcost_eaptr)
             {
                 if(urcost_ptr->tracks>urcost_maxaa) then 
                 {
                     urcost_maxaa:=urcost_ptr->tracks
                     
                 }
                 else 
                 {
                      skip 
                 };
                 urcost_ptr:=urcost_ptr->nextgrd
                 
             };
             urcost_ptr:=urcost_sbptr;
             
             while(urcost_ptr!=urcost_ebptr)
             {
                 if(urcost_ptr->tracks>urcost_maxbb) then 
                 {
                     urcost_maxbb:=urcost_ptr->tracks
                     
                 }
                 else 
                 {
                      skip 
                 };
                 urcost_ptr:=urcost_ptr->nextgrd
                 
             };
             urcost_maxaa:=urcost_aMaxVal-urcost_maxaa+1;
             urcost_maxbb:=urcost_bMaxVal-urcost_maxbb-1;
             urcost_check:=urcost_maxaa-urcost_maxbb
         }
         
     }
     else
     {
         urcost_check:=urcost_penalty
     };
     if(urcost_check<=0) then 
     {
         if(urcost_asegptr->pin1<=maxterm) then 
         {
             urcost_aptr1->SegType:=urcost_aptr1->SegType-1
             
         }
         else 
         {
              skip 
         };
         if(urcost_asegptr->pin2<=maxterm) then 
         {
             urcost_aptr2->SegType:=urcost_aptr2->SegType--1
             
         }
         else 
         {
              skip 
         };
         if(urcost_bsegptr->pin1<=maxterm) then 
         {
             urcost_bptr1->SegType:=urcost_bptr1->SegType+1
             
         }
         else 
         {
              skip 
         };
         if(urcost_bsegptr->pin2<=maxterm) then 
         {
             urcost_bptr2->SegType:=urcost_bptr2->SegType+-1
             
         }
         else 
         {
              skip 
         };
         urcost_ptr:=urcost_saptr;
         
         while(urcost_ptr!=urcost_eaptr)
         {
             urcost_denptr:=urcost_ptr->dptr;
             if(urcost_denptr->next$!=NULL) then 
             {
                 urcost_denptr->next$->back:=urcost_denptr->back
                 
             }
             else 
             {
                  skip 
             };
             urcost_denptr->back->next$:=urcost_denptr->next$;
             urcost_track:=((urcost_ptr->tracks)-1);
             (urcost_ptr->tracks):=(urcost_ptr->tracks)-1;
             urcost_headptr:=DboxHead[urcost_achannel,urcost_track]->next$;
             if(urcost_headptr!=NULL) then 
             {
                 DboxHead[urcost_achannel,urcost_track]->next$:=urcost_denptr;
                 urcost_denptr->next$:=urcost_headptr;
                 urcost_headptr->back:=urcost_denptr;
                 urcost_denptr->back:=DboxHead[urcost_achannel,urcost_track]
                 
             }
             else
             {
                 DboxHead[urcost_achannel,urcost_track]->next$:=urcost_denptr;
                 urcost_denptr->next$:=NULL;
                 urcost_denptr->back:=DboxHead[urcost_achannel,urcost_track]
             };
             urcost_ptr:=urcost_ptr->nextgrd
             
         };
         if(urcost_aoutside=0) then 
         {
             maxTrack[urcost_achannel]:=maxTrack[urcost_achannel]-1
             
         }
         else 
         {
              skip 
         };
         urcost_ptr:=urcost_sbptr;
         
         while(urcost_ptr!=urcost_ebptr)
         {
             urcost_denptr:=urcost_ptr->dptr;
             if(urcost_denptr->next$!=NULL) then 
             {
                 urcost_denptr->next$->back:=urcost_denptr->back
                 
             }
             else 
             {
                  skip 
             };
             urcost_denptr->back->next$:=urcost_denptr->next$;
             urcost_track:=((urcost_ptr->tracks)+1);
             (urcost_ptr->tracks):=(urcost_ptr->tracks)+1;
             urcost_headptr:=DboxHead[urcost_bchannel,urcost_track]->next$;
             if(urcost_headptr!=NULL) then 
             {
                 DboxHead[urcost_bchannel,urcost_track]->next$:=urcost_denptr;
                 urcost_denptr->next$:=urcost_headptr;
                 urcost_headptr->back:=urcost_denptr;
                 urcost_denptr->back:=DboxHead[urcost_bchannel,urcost_track]
                 
             }
             else
             {
                 DboxHead[urcost_bchannel,urcost_track]->next$:=urcost_denptr;
                 urcost_denptr->next$:=NULL;
                 urcost_denptr->back:=DboxHead[urcost_bchannel,urcost_track]
             };
             urcost_ptr:=urcost_ptr->nextgrd
             
         };
         if(urcost_binside=1) then 
         {
             maxTrack[urcost_bchannel]:=maxTrack[urcost_bchannel]+1
             
         }
         else 
         {
              skip 
         };
         if(aNetSeg[segment].current=1) then 
         {
             aNetSeg[segment].current:=0
             
         }
         else
         {
             aNetSeg[segment].current:=1
         };
         tracks:=tracks+urcost_penalty;
         return<==1 and RValue:=1;
         skip
     }
     else
     {
         return<==1 and RValue:=0;
         skip
     }
     )
     }; 
      float table1[1024],table2[1024],table3[1024] and skip;
     int moveable_cells and skip;
     int fdthrus and skip;
 function SetBin ( int x,int RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
	 Trybin:=(x-binOffst)/ binWidth;
     return<==1 and RValue:=( if((Trybin<0)) then 0 else (( if((Trybin>numBins)) then numBins else Trybin)));
     skip
     )
     }; 
  function utemp (  )
 {
     frame(temp_i,utemp_TloRange,utemp_Tfactor,utemp_pairtest,utemp_check,utemp_i2,utemp_tempfile,utemp_filename,utemp_t,utemp_i,utemp_row,utemp_freeze,utemp_cell,utemp_changes,utemp_fp,return,break$,continue) and ( 
     int continue<==0 and skip;
     int break$<==0 and skip;
     int return<==0 and skip;
     float utemp_TloRange,utemp_Tfactor and skip;
     int utemp_pairtest,utemp_check and skip;
     unsigned int utemp_i2 and skip;
     float **utemp_tempfile and skip;
     char utemp_filename[64] and skip;
     int utemp_t,utemp_i,utemp_row,utemp_freeze,utemp_cell,utemp_changes and skip;
     FILE *utemp_fp and skip;
     last_level:=-1;
     if(stage>=2) then 
     {
         utemp_pairtest:=1
         
     }
     else
     {
         utemp_pairtest:=0
     };
     initialRowControl:=0.0;
     finalRowControl:=0.0;
     utemp_check:=0;
     utemp_freeze:=10000000;
     randVar:=randomSeed;
     fprintf(fpo,"\nThe rand generator seed was at utemp() : %d\n\n\n",randVar) and skip;
     table1[0]:=1.0;
     table2[0]:=1.0;
     table3[0]:=1.0;
     utemp_i2:=1;
     
     while(utemp_i2<=1023)
     {
         table1[utemp_i2]:=exp(-(float)utemp_i2/ 8.0);

		 

         table2[utemp_i2]:=exp(-(float)utemp_i2/ 8192.0);
         table3[utemp_i2]:=exp(-(float)utemp_i2/ 8388608.0);
         utemp_i2:=utemp_i2+1
         
     };
     moveable_cells:=0;
     continue<==0 and skip;
     utemp_cell:=1;
     
     while(utemp_cell<=numcells)
     {
          continue<==0 and skip;
         if(carray[utemp_cell]->cclass<0) then 
         {
             continue<==1 and skip;
              utemp_cell:=utemp_cell+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             moveable_cells:=moveable_cells+1;
             utemp_cell:=utemp_cell+1
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     if(moveable_cells<=500) then 
     {
         attprcel:=25
         
     }
     else
     {
         attprcel:=(int)(25.0*pow((float)moveable_cells/ 500.0,1.0/ 3.0))
     };
     if(tw_fast) then 
     {
         attprcel:=attprcel/ 5
         
     }
     else 
     {
          skip 
     };
     utemp_tempfile:=(float **)safe_malloc(4*sizeof(float *),RValue);
     utemp_t:=0;
     
     while(utemp_t<=3)
     {
         utemp_tempfile[utemp_t]:=(float *)safe_malloc(2*sizeof(float),RValue);
         utemp_t:=utemp_t+1
         
     };
     utemp_tempfile[0,0]:=0.9825;
     utemp_tempfile[0,1]:=90.0;
     fprintf(fpo,"  tempfile[0][0] = %f    ",utemp_tempfile[0,0]) and skip;
     fprintf(fpo,"tempfile[0][1] = %f\n  ",utemp_tempfile[0,1]) and skip;
     utemp_tempfile[1,0]:=0.915;
     utemp_tempfile[1,1]:=20.0;
     fprintf(fpo,"tempfile[1][0] = %f    ",utemp_tempfile[1,0]) and skip;
     fprintf(fpo,"tempfile[1][1] = %f\n  ",utemp_tempfile[1,1]) and skip;
     utemp_tempfile[2,0]:=0.70;
     utemp_tempfile[2,1]:=10.0;
     fprintf(fpo,"tempfile[2][0] = %f    ",utemp_tempfile[2,0]) and skip;
     fprintf(fpo,"tempfile[2][1] = %f\n  ",utemp_tempfile[2,1]) and skip;
     utemp_tempfile[3,0]:=0.10;
     utemp_tempfile[3,1]:=0.0;
     fprintf(fpo,"tempfile[3][0] = %f    ",utemp_tempfile[3,0]) and skip;
     fprintf(fpo,"tempfile[3][1] = %f\n\n",utemp_tempfile[3,1]) and skip;
     utemp_TloRange:=10000000000.0;
     utemp_t:=-1;
     fprintf(fpo,"  I   T  fds     Wire Penalty P_lim Epct ") and skip;
     fprintf(fpo,"binC rowC  acc  s/p early  FDs    MRs\n") and skip;
     break$<==0 and skip;
     while( break$=0 AND  true)
     {
	 syf:=syf+1;
         while(T<utemp_TloRange)
         {
             utemp_t:=utemp_t+1;
             if(utemp_t>3) then 
             {
                 fprintf(fpo,"exceeded tempfile array in ") and skip;
                 fprintf(fpo,"utemp.c \n") and skip;
                 exit(0) and skip 
                 
             }
             else 
             {
                  skip 
             };
             utemp_Tfactor:=utemp_tempfile[utemp_t,0];
             utemp_TloRange:=utemp_tempfile[utemp_t,1]
         };
		 
  
    
         if(utemp_pairtest=0) then 
         {
			 uloop();

             if(T<Tzero) then 
             {
                 utemp_pairtest:=1
                 
             }
             else 
             {
                  skip 
             };
             savewolf(1)
             
         }
         else
         {
             if(utemp_check=0) then 
             {
                 utemp_check:=1;
                 if(stage=1) then 
                 {
                     uloop2();
                     iteration:=iteration+1
                     
                 }
                 else 
                 {
                      skip 
                 };
                 last_level:=-1;
                 savewolf(1);
                 utemp_freeze:=iteration;
                 if(connection_machine) then 
                 {
                     unlap(-1);
                     findunlap(-1);
                     outcm()
                     
                 }
                 else 
                 {
                      skip 
                 };
                 countf(RValue);
                 if(doglobal) then 
                 {
                     sprintf(utemp_filename,"%s.cel",cktName,RValue) and skip;
                     utemp_fp:=twopen(utemp_filename,"r",1,RValue);
                     finalwire();
                     grdcell(utemp_fp);
                     twclose(utemp_fp)
                     
                 }
                 else 
                 {
                      skip 
                 };
                 reassign();
                 if(doglobal) then 
                 {
                     if(addFeeds=0) then 
                     {
                         utemp_row:=1;
                         
                         while(utemp_row<=numblock)
                         {
                             nofeed[utemp_row]:=1;
                             utemp_row:=utemp_row+1
                             
                         }
                         
                     }
                     else 
                     {
                          skip 
                     };	
                     findunlap(1); 
                     fdthrus:=findfeeds(0,RValue);
                     fdthrus:=fdthrus+add_to_row[0];
                     fixwolf(fdthrus);
                     findfeeds(1,RValue);
                     unlap(-2);
                     add_dummy_feeds(last_feed,RValue);
                     numcells:=numcells+fdthrus;
                     moveable_cells:=moveable_cells+fdthrus;
                     if(stage>=2) then 
                     {
                         sprintf(utemp_filename,"%s.rs2",cktName,RValue) and skip;
                         utemp_fp:=twopen(utemp_filename,"r",0,RValue) ;
                         if(utemp_fp) then 
                         {
                             fixfdpos(utemp_fp);
                             twclose(utemp_fp)
                             
                         }
                         else 
                         {
                              skip 
                         }
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 sortpin();
                 findunlap(0);
                 penalty:=0;
                 initialize_cost(RValue);
                 fprintf(fpo,"Added: %d  feed-through cells\n\n",fdthrus) and skip;
                 fprintf(fpo,"Removed the cell overlaps --- ") and skip;
                 fprintf(fpo,"Will do neighbor interchanges only now\n") and skip;
                 fprintf(fpo,"\nTOTAL INTERCONNECT LENGTH: %d\n",funccost) and skip;
                 fprintf(fpo,"OVERLAP PENALTY: %d\n\n",penalty) and skip;
                 fprintf(fpo,"initialRowControl:%8.3f\n",initialRowControl) and skip;
                 fprintf(fpo,"finalRowControl:%8.3f\n",finalRowControl) and skip;
                 fflush(fpo) and skip;
                 attmax:=5*moveable_cells;
                 if(stage!=3) then 
                 {
                     if(noPairs=0) then 
                     {
                         T:=0.001;
                         fprintf(fpo,"iter      T      Wire accept\n") and skip;
                         upair(RValue);
                         savewolf(2)
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 }
             }
             else
             {
                 if(noPairs=0) then 
                 {
                     T:=0.001;
                     upair(RValue);
                     savewolf(2)
                     
                 }
                 else 
                 {
                      skip 
                 }
             }
         };
         if(stage!=3) then 
         {
			iteration := iteration+1;
             printf("%3d ",iteration) and skip;
             if(iteration % 15=0) then 
             {
                 output ("\n") and skip
                 
             }
             else 
             {
                  skip 
             };
             fflush(stdout) and skip
             
         }
         else 
         {
              skip 
         };
         if(iteration>=utemp_freeze+3 OR stage=3) then 
         {
             utemp_i:=1;
             
             while(utemp_i<=8)
             {
                 align_init();
                 utemp_changes:=alignfeed(RValue);
                 fprintf(fpo,"Total Feed-Alignment Movement (Pass %d): %d\n",utemp_i,utemp_changes) and skip;
                 utemp_i:=utemp_i+1
                 
             };
             align_init();
             findunlap(-1);
             if(doglobal) then 
             {
                 globe();
                 globroute();
                 if(cswaps) then 
                 {
                     if(noPairs=0) then 
                     {
                         ugpair()
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 };
                 findrchk();
                 fprintf(fpo,"\nFINAL NUMBER OF ROUTING TRACKS: %d\n\n",tracks) and skip;
                 utemp_i:=1;
                 
                 while(utemp_i<=numChans)
                 {
                     fprintf(fpo,"MAX OF CHANNEL:%3d  is: %3d\n",utemp_i,maxTrack[utemp_i]) and skip;
                     utemp_i:=utemp_i+1
                     
                 };
                 mergplist();
                 outpins();
                 output$()
                 
             }
             else
             {
                 output$()
             };
             fprintf(fpo,"FINAL TOTAL INTERCONNECT LENGTH: %d\n",funccost) and skip;
             fprintf(fpo,"FINAL OVERLAP PENALTY: %d    ",penalty) and skip;
             fprintf(fpo,"FINAL VALUE OF TOTAL COST IS: %d\n",funccost+penalty) and skip;
             fprintf(fpo,"MAX NUMBER OF ATTEMPTED FLIPS PER T:%8d\n",attmax) and skip;
             break$<==1 and skip
          }
         else
         {
             T:=utemp_Tfactor*T
         }
		 
         
     }; 
     break$<==0 and skip;
     fprintf(fpo,"\n\ncost_scale_factor:%g\n\n",cost_scale_factor) and skip;
      return<==1 and skip
     )
     }; 
  function add_dummy_feeds ( int feednum,int RValue )
 {
     frame(add_dummy_feeds_cellptr,add_dummy_feeds_tileptr,add_dummy_feeds_pin,add_dummy_feeds_corient,add_dummy_feeds_left,add_dummy_feeds_right,add_dummy_feeds_pos,add_dummy_feeds_row,add_dummy_feeds_i,add_dummy_feeds_last_cell,return) and ( 
     int return<==0 and skip;
     cellbox* add_dummy_feeds_cellptr and skip;
     tilebox* add_dummy_feeds_tileptr and skip;
     int add_dummy_feeds_pin,add_dummy_feeds_corient,add_dummy_feeds_left,add_dummy_feeds_right and skip;
     int add_dummy_feeds_pos,add_dummy_feeds_row,add_dummy_feeds_i,add_dummy_feeds_last_cell and skip;
     add_dummy_feeds_row:=1;
     
     while(add_dummy_feeds_row<=numRows)
     {
         add_dummy_feeds_last_cell:=pairArray[add_dummy_feeds_row,pairArray[add_dummy_feeds_row,0]];
         add_dummy_feeds_pos:=carray[add_dummy_feeds_last_cell]->cxcenter+carray[add_dummy_feeds_last_cell]->tileptr->right-fdWidth;
         add_dummy_feeds_i:=1;
         
         while(add_dummy_feeds_i<=add_to_row[add_dummy_feeds_row])
         {
             add_dummy_feeds_pos:=add_dummy_feeds_pos+fdWidth;
             add_dummy_feeds_cellptr:=carray[numcells+(feednum+1)];
             feednum:=feednum+1;
             add_dummy_feeds_cellptr->padside:=0;
             add_dummy_feeds_cellptr->cxcenter:=add_dummy_feeds_pos;
             add_dummy_feeds_cellptr->cycenter:=barray[add_dummy_feeds_row]->bycenter;
             add_dummy_feeds_cellptr->cheight:=barray[add_dummy_feeds_row]->bheight;
             add_dummy_feeds_cellptr->clength:=fdWidth;
             if(barray[add_dummy_feeds_row]->borient=2) then 
             {
                 add_dummy_feeds_cellptr->corient:=1
                 
             }
             else 
             {
                  skip 
             };
             add_dummy_feeds_tileptr:=add_dummy_feeds_cellptr->tileptr;
             add_dummy_feeds_cellptr->cname:=(char *)safe_malloc(16*sizeof(char),RValue);
             sprintf(add_dummy_feeds_cellptr->cname,"twfeed%d",feednum,RValue) and skip;
             add_dummy_feeds_cellptr->cblock:=add_dummy_feeds_row;
             add_dummy_feeds_tileptr->left:=-fdWidth/ 2;
             add_dummy_feeds_tileptr->right:=fdWidth+add_dummy_feeds_tileptr->left;
             add_dummy_feeds_tileptr->bottom:=-barray[add_dummy_feeds_row]->bheight/ 2;
             add_dummy_feeds_tileptr->top:=barray[add_dummy_feeds_row]->bheight+add_dummy_feeds_tileptr->bottom;
             safe_free(add_dummy_feeds_tileptr->termsptr->nextterm);
             safe_free(add_dummy_feeds_tileptr->termsptr);
             add_dummy_feeds_tileptr->termsptr:=NULL;
             add_dummy_feeds_i:=add_dummy_feeds_i+1
             
         };
         add_dummy_feeds_row:=add_dummy_feeds_row+1
         
     };
      return<==1 and skip
     )
     }; 
      char programName[255] and skip;
     char progVersion[255] and skip;
     char progDate[255] and skip;
 function initProgram ( char *name,char *version,int RValue )
 {
     frame(initProgram_message,initProgram_date,initProgram_i) and ( 
     char initProgram_message[255],*initProgram_date and skip;
     int initProgram_i and skip;
     sprintf(programName,"%s",name,RValue) and skip;
     sprintf(progVersion,"%s",version,RValue) and skip;
     initProgram_date:=getCompileDate(RValue) ;
     if(initProgram_date) then 
     {
         sprintf(progDate,"%s",initProgram_date,RValue) and skip
         
     }
     else
     {
         sprintf(progDate,"unknown",RValue) and skip
     };
     fprintf(fpo,"\n%s version:%s date:%s\n",programName,progVersion,progDate) and skip;
     fprintf(fpo,"Standard Cell Placement and Global Routing Program\n") and skip;
     fprintf(fpo,"Authors: Carl Sechen, Bill Swartz\n") and skip;
     fprintf(fpo,"          Yale University\n") and skip;
     output ("\n",programName," version:",progVersion," date:",progDate,"\n") and skip;
     output ("Standard Cell Placement and Global Routing Program\n") and skip;
     output ("Authors: Carl Sechen, Bill Swartz\n") and skip;
     output ("         Yale University\n") and skip;
     safe_free(initProgram_date);
	
     randomSeed:=123456789;
     fixarray:=(int *)NULL;
     ffeeds:=0;
     initProgram_i:=1;
     
     while(initProgram_i<=15)
     {
         macspace[initProgram_i]:=-1.0;
         initProgram_i:=initProgram_i+1
         
     };
     costonly:=0;
     fdthrus:=0;
     doglobal:=0;
     cswaps:=0;
     imprange:=-1.0;
     attprcel:=0;
     addFeeds:=0;
     fdWidth:=-1;
     rowSep:=-1.0;
     indent:=1.0;
     numSegs:=0;
     resume_run:=0;
     pin_layers_given:=0;
     no_feeds_side_nets:=0;
     no_net_normalize:=0;
     cost_scale_factor:=1.0;
     feedLayer:=0;
     tw_fast:=0;
     estimate_feeds:=1;
     connection_machine:=0;
     gate_array_special:=0;
     randomSeed2:=987654321
     )
     }; 
  function getProgName ( char* RValue )
 {
     frame(return) and ( 
     int return<==0 and skip;
     return<==1 and RValue:=(strclone(programName,RValue));
     skip
     )
     }; 
  function strclone ( char *str,char* RValue )
 {
     frame(strclone_copy,strclone_1_2_temp$_1,return) and ( 
     int return<==0 and skip;
     char *strclone_copy and skip;
     if(str) then 
     {
         if(* str) then 
         {
             int strclone_1_2_temp$_1 and skip;
             strclone_1_2_temp$_1:=strlen(str);
             strclone_copy:=(char *)safe_malloc(strclone_1_2_temp$_1+1,RValue);
             sprintf(strclone_copy,"%s",str,RValue) and skip;
             return<==1 and RValue:=strclone_copy;
             skip
             
         }
         else 
         {
              skip 
         }
         
     }
     else 
     {
          skip 
     };
     if(return=0)  then
     {
         return<==1 and RValue:=NULL;
         skip
     }
     else
     {
         skip
     }
     )
     }; 
  function openFile ( char *filename,char *readwrite,int abort,FILE* RValue )
 {
     frame(openFile_fileptr,return) and ( 
     int return<==0 and skip;
     FILE *openFile_fileptr and skip;
     openFile_fileptr:=fopen(filename,readwrite);
     if(!openFile_fileptr AND abort) then 
     {
         output ("could not open file ",filename,"\n") and skip;
         exit(0) and skip 
         
     }
     else 
     {
          skip 
     };
     return<==1 and RValue:=openFile_fileptr;
     skip
     )
     }; 
      int *blklist and skip;
     struct int2 {
     int sleft and 
     int srite 
 };
 int2 *blkshifts and skip;
 function xcompact (  )
 {
     frame(xcompact_blk,xcompact_pad,xcompact_k,xcompact_bot,xcompact_top,xcompact_rite,xcompact_left,xcompact_maxd,xcompact_cell,xcompact_end,xcompact_mind,xcompact_padside,xcompact_padptr,xcompact_cellptr,return,continue) and ( 
     int continue<==0 and skip;
     int return<==0 and skip;
     int xcompact_blk,xcompact_pad,xcompact_k,xcompact_bot,xcompact_top,xcompact_rite,xcompact_left,xcompact_maxd,xcompact_cell,xcompact_end,xcompact_mind and skip;
     int xcompact_padside and skip;
     cellbox* xcompact_padptr,*xcompact_cellptr and skip;
     blklist:=(int *)safe_malloc((numblock+1)*sizeof(int),RValue);
     blkshifts:=(int2 *)safe_malloc((numblock+1)*sizeof(int2),RValue);
     xcompact_blk:=1;
     
     while(xcompact_blk<=numblock)
     {
         blkshifts[xcompact_blk].sleft:=-1000;
         xcompact_blk:=xcompact_blk+1
         
     };
     xcompact_pad:=numcells+1;
     
     while(xcompact_pad<=numcells+numterms)
     {
         if(carray[xcompact_pad]->padside=12 OR carray[xcompact_pad]->padside=13 OR carray[xcompact_pad]->padside=11) then 
         {
             xcompact_padptr:=carray[xcompact_pad];
             xcompact_padside:=xcompact_padptr->padside;
             xcompact_rite:=xcompact_padptr->cxcenter+xcompact_padptr->tileptr->right;
             xcompact_left:=xcompact_padptr->cxcenter+xcompact_padptr->tileptr->left;
             xcompact_bot:=xcompact_padptr->cycenter+xcompact_padptr->tileptr->bottom-rowSep*rowHeight*0.67;
             xcompact_top:=xcompact_padptr->cycenter+xcompact_padptr->tileptr->top+rowSep*rowHeight*0.67;
             findblks(xcompact_bot,xcompact_top,xcompact_rite,-1,RValue);
             xcompact_maxd:=0;
             xcompact_k:=1;
             
             while(xcompact_k<=blklist[0])
             {
                 xcompact_blk:=blklist[xcompact_k];
                 xcompact_cell:=pairArray[xcompact_blk,pairArray[xcompact_blk,0]];
                 xcompact_cellptr:=carray[xcompact_cell];
                 if(xcompact_cellptr->cxcenter+xcompact_cellptr->tileptr->right>xcompact_maxd) then 
                 {
                     xcompact_maxd:=xcompact_cellptr->cxcenter+xcompact_cellptr->tileptr->right
                     
                 }
                 else 
                 {
                      skip 
                 };
                 xcompact_k:=xcompact_k+1
                 
             };
             xcompact_k:=1;
             
             while(xcompact_k<=blklist[0])
             {
                 xcompact_blk:=blklist[xcompact_k];
                 blkshifts[xcompact_blk].srite:=xcompact_maxd;
                 blkshifts[xcompact_blk].sleft:=barray[xcompact_blk]->bxcenter+barray[xcompact_blk]->bleft;
                 xcompact_k:=xcompact_k+1
                 
             };
             findblks(xcompact_bot,xcompact_top,xcompact_rite,1,RValue);
             carray[xcompact_pad]->cxcenter:=carray[xcompact_pad]->cxcenter+macspace[xcompact_padside]-(xcompact_left-xcompact_maxd);
             xcompact_k:=1;
             
             while(xcompact_k<=blklist[0])
             {
                 xcompact_blk:=blklist[xcompact_k];
                 barray[xcompact_blk]->bxcenter:=barray[xcompact_blk]->bxcenter+macspace[xcompact_padside]-(xcompact_left-xcompact_maxd);
                 xcompact_k:=1;
                 
                 while(xcompact_k<=pairArray[xcompact_blk,0])
                 {
                     xcompact_cell:=pairArray[xcompact_blk,xcompact_k];
                     carray[xcompact_cell]->cxcenter:=carray[xcompact_cell]->cxcenter+macspace[xcompact_padside]-(xcompact_left-xcompact_maxd);
                     xcompact_k:=xcompact_k+1
                     
                 };
                 xcompact_k:=xcompact_k+1
                 
             }
             
         }
         else 
         {
              skip 
         };
         xcompact_pad:=xcompact_pad+1
         
     };
     xcompact_pad:=numcells+1;
     
     while(xcompact_pad<=numcells+numterms)
     {
         xcompact_padptr:=carray[xcompact_pad];
         if(xcompact_padptr->padside=6 OR xcompact_padptr->padside=10 OR xcompact_padptr->padside=8) then 
         {
             xcompact_padside:=xcompact_padptr->padside;
             xcompact_rite:=xcompact_padptr->cxcenter+xcompact_padptr->tileptr->right;
             xcompact_left:=xcompact_padptr->cxcenter+xcompact_padptr->tileptr->left;
             xcompact_bot:=xcompact_padptr->cycenter+xcompact_padptr->tileptr->bottom-rowSep*rowHeight*0.33;
             xcompact_top:=xcompact_padptr->cycenter+xcompact_padptr->tileptr->top+rowSep*rowHeight*0.33;
             findblks(xcompact_bot,xcompact_top,xcompact_rite,-1,RValue);
             xcompact_maxd:=0;
             xcompact_k:=1;
             
             while(xcompact_k<=blklist[0])
             {
                 xcompact_blk:=blklist[xcompact_k];
                 xcompact_cell:=pairArray[xcompact_blk,pairArray[xcompact_blk,0]];
                 xcompact_cellptr:=carray[xcompact_cell];
                 if(xcompact_cellptr->cxcenter+xcompact_cellptr->tileptr->right>xcompact_maxd) then 
                 {
                     xcompact_maxd:=xcompact_cellptr->cxcenter+xcompact_cellptr->tileptr->right
                     
                 }
                 else 
                 {
                      skip 
                 };
                 xcompact_k:=xcompact_k+1
                 
             };
             xcompact_k:=1;
             
             while(xcompact_k<=blklist[0])
             {
                 xcompact_blk:=blklist[xcompact_k];
                 blkshifts[xcompact_blk].srite:=xcompact_maxd;
                 blkshifts[xcompact_blk].sleft:=barray[xcompact_blk]->bxcenter+barray[xcompact_blk]->bleft;
                 xcompact_k:=xcompact_k+1
                 
             };
             carray[xcompact_pad]->cxcenter:=carray[xcompact_pad]->cxcenter+macspace[xcompact_padside]-(xcompact_left-xcompact_maxd)
             
         }
         else 
         {
              skip 
         };
         xcompact_pad:=xcompact_pad+1
         
     };
     xcompact_maxd:=0;
     continue<==0 and skip;
     xcompact_blk:=1;
     
     while(xcompact_blk<=numblock)
     {
          continue<==0 and skip;
         if(pairArray[xcompact_blk,0]<=0) then 
         {
             continue<==1 and skip;
              xcompact_blk:=xcompact_blk+1
         }
         else 
         {
              skip 
         };
         if(continue=0)   then 
         {
             xcompact_cell:=pairArray[xcompact_blk,pairArray[xcompact_blk,0]];
             xcompact_end:=carray[xcompact_cell]->cxcenter+carray[xcompact_cell]->tileptr->right;
             if(xcompact_end>xcompact_maxd) then 
             {
                 xcompact_maxd:=xcompact_end
                 
             }
             else 
             {
                  skip 
             };
             xcompact_blk:=xcompact_blk+1
         }
         else
         {
             skip
         }
         
     };
     continue<==0 and skip;
     xcompact_pad:=numcells+1;
     
     while(xcompact_pad<=numcells+numterms)
     {
         xcompact_padptr:=carray[xcompact_pad];
         if(xcompact_padptr->padside=6 OR xcompact_padptr->padside=10 OR xcompact_padptr->padside=8 OR xcompact_padptr->padside=14 OR xcompact_padptr->padside=15) then 
         {
             if(xcompact_padptr->cxcenter+xcompact_padptr->tileptr->right>xcompact_maxd) then 
             {
                 xcompact_maxd:=xcompact_padptr->cxcenter+xcompact_padptr->tileptr->right
                 
             }
             else 
             {
                  skip 
             }
             
         }
         else 
         {
              skip 
         };
         xcompact_pad:=xcompact_pad+1
         
     };
     xcompact_blk:=1;
     
     while(xcompact_blk<=numblock)
     {
         if(blkshifts[xcompact_blk].sleft=-1000) then 
         {
             blkshifts[xcompact_blk].srite:=xcompact_maxd;
             blkshifts[xcompact_blk].sleft:=barray[xcompact_blk]->bxcenter+barray[xcompact_blk]->bleft
             
         }
         else 
         {
              skip 
         };
         xcompact_blk:=xcompact_blk+1
         
     };
     xcompact_mind:=32000;
     xcompact_pad:=numcells+1;
     
     while(xcompact_pad<=numcells+numterms)
     {
         xcompact_padptr:=carray[xcompact_pad];
         if(xcompact_padptr->padside=3) then 
         {
             if(xcompact_padptr->cxcenter+xcompact_padptr->tileptr->left<xcompact_mind) then 
             {
                 xcompact_mind:=xcompact_padptr->cxcenter+xcompact_padptr->tileptr->left
                 
             }
             else 
             {
                  skip 
             }
             
         }
         else 
         {
              skip 
         };
         xcompact_pad:=xcompact_pad+1
         
     };
     xcompact_pad:=numcells+1;
     
     while(xcompact_pad<=numcells+numterms)
     {
         if(carray[xcompact_pad]->padside=3) then 
         {
             carray[xcompact_pad]->cxcenter:=carray[xcompact_pad]->cxcenter+rowSep*rowHeight-(xcompact_mind-xcompact_maxd)
             
         }
         else 
         {
              skip 
         };
         xcompact_pad:=xcompact_pad+1
         
     };
      return<==1 and skip
     )
     }; 
  function findblks ( int bot,int top,int rite,int direction,int RValue )
 {
     frame(findblks_blk,return) and ( 
     int return<==0 and skip;
     int findblks_blk and skip;
     blklist[0]:=0;
     findblks_blk:=1;
     
     while(findblks_blk<=numblock)
     {
         if(barray[findblks_blk]->bycenter>bot AND barray[findblks_blk]->bycenter<top) then 
         {
             if(direction=-1) then 
             {
                 if(barray[findblks_blk]->bxcenter+barray[findblks_blk]->bright<rite) then 
                 {
                     if(blkshifts[findblks_blk].sleft=-1000) then 
                     {
                         blklist[(blklist[0]+1)]:=findblks_blk;
                         blklist[0]:=blklist[0]+1
                         
                     }
                     else 
                     {
                          skip 
                     }
                     
                 }
                 else 
                 {
                      skip 
                 }
             }
             else
             {
                 if(barray[findblks_blk]->bxcenter+barray[findblks_blk]->bleft>rite) then 
                 {
                     blklist[(blklist[0]+1)]:=findblks_blk;
                     blklist[0]:=blklist[0]+1
                     
                 }
                 else 
                 {
                      skip 
                 }
             }
             
         }
         else 
         {
              skip 
         };
         findblks_blk:=findblks_blk+1
         
     };
      return<==1 and skip
     )
     }; 
  function XPICK_INT ( int l,int u,int c,int RValue )
 {
     frame(XPICK_INT_d,count$,return) and (
     int return<==0 and skip;
     int XPICK_INT_d and skip;
     if(c<0) then 
     {
         return<==1 and RValue:=(-c);
         skip
     }
     else
     {
         int count$<==0 and skip;
         while( ( count$=0 OR XPICK_INT_d=c))
         {
             count$:=count$+1;
             XPICK_INT_d:=PICK_INT(l,u,RValue)
         };
         return<==1 and RValue:=XPICK_INT_d;
         skip
     }
     )
 };

 main()

 )
