/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 213 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int size_t;
#line 14 "/usr/include/sys/lock.h"
typedef void *_LOCK_T;
#line 15 "/usr/include/sys/_types.h"
typedef long long _off64_t;
#line 18 "/usr/include/sys/_types.h"
typedef int _ssize_t;
#line 354 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int wint_t;
#line 27 "/usr/include/sys/_types.h"
union __anonunion___value_2 {
   wint_t __wch ;
   unsigned char __wchb[4] ;
};
#line 27 "/usr/include/sys/_types.h"
struct __anonstruct__mbstate_t_1 {
   int __count ;
   union __anonunion___value_2 __value ;
};
#line 27 "/usr/include/sys/_types.h"
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
#line 37 "/usr/include/sys/_types.h"
typedef _LOCK_T _flock_t;
#line 19 "/usr/include/sys/reent.h"
typedef unsigned long __ULong;
#line 40 "/usr/include/sys/reent.h"
struct _Bigint {
   struct _Bigint *_next ;
   int _k ;
   int _maxwds ;
   int _sign ;
   int _wds ;
   __ULong _x[1] ;
};
#line 48 "/usr/include/sys/reent.h"
struct __tm {
   int __tm_sec ;
   int __tm_min ;
   int __tm_hour ;
   int __tm_mday ;
   int __tm_mon ;
   int __tm_year ;
   int __tm_wday ;
   int __tm_yday ;
   int __tm_isdst ;
};
#line 67 "/usr/include/sys/reent.h"
struct _on_exit_args {
   void *_fnargs[32] ;
   void *_dso_handle[32] ;
   __ULong _fntypes ;
   __ULong _is_cxa ;
};
#line 85 "/usr/include/sys/reent.h"
struct _atexit {
   struct _atexit *_next ;
   int _ind ;
   void (*_fns[32])(void) ;
   struct _on_exit_args _on_exit_args ;
};
#line 101 "/usr/include/sys/reent.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 111 "/usr/include/sys/reent.h"
typedef long _fpos_t;
#line 115 "/usr/include/sys/reent.h"
typedef _off64_t _fpos64_t;
#line 166
struct _reent;
#line 214 "/usr/include/sys/reent.h"
struct __sFILE64 {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   struct _reent *_data ;
   void *_cookie ;
   _ssize_t ( __attribute__((__cdecl__)) (*_read))(void *_cookie , char *_buf , int _n ) ;
   _ssize_t ( __attribute__((__cdecl__)) (*_write))(void *_cookie , char const   *_buf ,
                                                    int _n ) ;
   _fpos_t ( __attribute__((__cdecl__)) (*_seek))(void *_cookie , _fpos_t _offset ,
                                                  int _whence ) ;
   int ( __attribute__((__cdecl__)) (*_close))(void *_cookie ) ;
   struct __sbuf _ub ;
   unsigned char *_up ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   int _flags2 ;
   _off64_t _offset ;
   _fpos64_t ( __attribute__((__cdecl__)) (*_seek64))(void *_cookie , _fpos64_t _offset ,
                                                      int _whence ) ;
   _flock_t _lock ;
};
#line 257 "/usr/include/sys/reent.h"
typedef struct __sFILE64 __FILE;
#line 262 "/usr/include/sys/reent.h"
struct _glue {
   struct _glue *_next ;
   int _niobs ;
   __FILE *_iobs ;
};
#line 290 "/usr/include/sys/reent.h"
struct _rand48 {
   unsigned short _seed[3] ;
   unsigned short _mult[3] ;
   unsigned short _add ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__reent_4 {
   unsigned int _unused_rand ;
   char *_strtok_last ;
   char _asctime_buf[26] ;
   struct __tm _localtime_buf ;
   int _gamma_signgam ;
   unsigned long long _rand_next ;
   struct _rand48 _r48 ;
   _mbstate_t _mblen_state ;
   _mbstate_t _mbtowc_state ;
   _mbstate_t _wctomb_state ;
   char _l64a_buf[8] ;
   char _signal_buf[24] ;
   int _getdate_err ;
   _mbstate_t _mbrlen_state ;
   _mbstate_t _mbrtowc_state ;
   _mbstate_t _mbsrtowcs_state ;
   _mbstate_t _wcrtomb_state ;
   _mbstate_t _wcsrtombs_state ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__unused_5 {
   unsigned char *_nextf[30] ;
   unsigned int _nmalloc[30] ;
};
#line 565 "/usr/include/sys/reent.h"
union __anonunion__new_3 {
   struct __anonstruct__reent_4 _reent ;
   struct __anonstruct__unused_5 _unused ;
};
#line 565 "/usr/include/sys/reent.h"
struct _reent {
   int _errno ;
   __FILE *_stdin ;
   __FILE *_stdout ;
   __FILE *_stderr ;
   int _inc ;
   char _emergency[25] ;
   int _current_category ;
   char const   *_current_locale ;
   int __sdidinit ;
   void ( __attribute__((__cdecl__)) (*__cleanup))(struct _reent * ) ;
   struct _Bigint *_result ;
   int _result_k ;
   struct _Bigint *_p5s ;
   struct _Bigint **_freelist ;
   int _cvtlen ;
   char *_cvtbuf ;
   union __anonunion__new_3 _new ;
   struct _atexit *_atexit ;
   struct _atexit _atexit0 ;
   void (**_sig_func)(int  ) ;
   struct _glue __sglue ;
   __FILE __sf[3] ;
};
#line 104 "/usr/include/sys/types.h"
typedef unsigned long clock_t;
#line 50 "/usr/include/stdio.h"
typedef __FILE FILE;
#line 44 "/usr/include/cygwin/signal.h"
#pragma pack(push,4)
#line 101
#pragma pack(pop)
#line 15 "/usr/include/signal.h"
struct _reent;
#line 32 "188.c"
/*user-defined struct start*/
struct __anonstruct_ATOM_21 {
   double x ;
   double y ;
   double z ;
   double fx ;
   double fy ;
   double fz ;
   int serial ;
   double q ;
   double a ;
   double b ;
   double mass ;
   void *next ;
   char active ;
   char name[9] ;
   double chi ;
   double jaa ;
   double vx ;
   double vy ;
   double vz ;
   double vw ;
   double dx ;
   double dy ;
   double dz ;
   double gx ;
   double gy ;
   double gz ;
   double VP ;
   double px ;
   double py ;
   double pz ;
   double dpx ;
   double dpy ;
   double dpz ;
   double qxx ;
   double qxy ;
   double qxz ;
   double qyy ;
   double qyz ;
   double qzz ;
   void *close[200] ;
   void *excluded[32] ;
   char exkind[32] ;
   int dontuse ;
};
#line 32 "188.c"
typedef struct __anonstruct_ATOM_21 ATOM;
#line 221 "188.c"
struct __anonstruct_ANGLE_22 {
   ATOM *atom1 ;
   ATOM *atom2 ;
   ATOM *atom3 ;
   double target ;
   double k ;
   void *next ;
};
#line 221 "188.c"
typedef struct __anonstruct_ANGLE_22 ANGLE;
#line 2483 "188.c"
struct __anonstruct_BOND_23 {
   ATOM *atom1 ;
   ATOM *atom2 ;
   double length ;
   double k ;
   double dlength ;
   double dk ;
   int ndiff ;
   void *next ;
};
#line 2483 "188.c"
typedef struct __anonstruct_BOND_23 BOND;
#line 3975 "188.c"
struct __anonstruct_HYBRID_24 {
   ATOM *atom1 ;
   ATOM *atom2 ;
   ATOM *atom3 ;
   ATOM *atom4 ;
   double k ;
   double offset ;
   void *next ;
};
#line 3975 "188.c"
typedef struct __anonstruct_HYBRID_24 HYBRID;
#line 4419 "188.c"
union __anonunion_value_26 {
   double f ;
   int i ;
};
#line 4419 "188.c"
struct __anonstruct_VARIABLE_25 {
   int type ;
   char name[7] ;
   union __anonunion_value_26 value ;
   void *next ;
};
#line 4419 "188.c"
typedef struct __anonstruct_VARIABLE_25 VARIABLE;
#line 5264 "188.c"
struct __anonstruct_NOEL_27 {
   ATOM *atom1 ;
   ATOM *atom2 ;
   double d ;
   double dm ;
   double dh ;
   double km ;
   double kh ;
   void *next ;
};
#line 5264 "188.c"
typedef struct __anonstruct_NOEL_27 NOEL;
#line 5856 "188.c"
struct __anonstruct_MMNODE_28 {
   double xc ;
   double yc ;
   double zc ;
   double sqp ;
   double sa ;
   double xa ;
   double ya ;
   double za ;
   double q100 ;
   double q010 ;
   double q001 ;
   double q200 ;
   double q020 ;
   double q002 ;
   double q110 ;
   double q101 ;
   double q011 ;
   double q300 ;
   double q030 ;
   double q003 ;
   double q210 ;
   double q201 ;
   double q120 ;
   double q021 ;
   double q102 ;
   double q012 ;
   double q111 ;
   int first ;
   int last ;
   int innode ;
};
#line 5856 "188.c"
typedef struct __anonstruct_MMNODE_28 MMNODE;
#line 5870 "188.c"
struct __anonstruct_MMATOM_29 {
   ATOM *who ;
   int next ;
   int which ;
};
#line 5870 "188.c"
typedef struct __anonstruct_MMATOM_29 MMATOM;
#line 6832 "188.c"
struct __anonstruct_RESTRAIN_30 {
   ATOM *atom1 ;
   ATOM *atom2 ;
   double length ;
   double k ;
   void *next ;
};
#line 6832 "188.c"
typedef struct __anonstruct_RESTRAIN_30 RESTRAIN;
#line 7162 "188.c"
struct __anonstruct_TETHER_31 {
   ATOM *atom1 ;
   double k ;
   double x ;
   double y ;
   double z ;
   void *next ;
};
#line 7162 "188.c"
typedef struct __anonstruct_TETHER_31 TETHER;
#line 7662 "188.c"
struct __anonstruct_TGROUP_32 {
   ATOM *context ;
   ATOM *b1 ;
   ATOM *b2 ;
   ATOM *b3 ;
   int which ;
   int ntry ;
   int ingroup ;
   double base ;
   ATOM *group[100] ;
   void *next ;
};
#line 7662 "188.c"
typedef struct __anonstruct_TGROUP_32 TGROUP;
#line 8191 "188.c"
struct __anonstruct_TORSION_33 {
   ATOM *atom1 ;
   ATOM *atom2 ;
   ATOM *atom3 ;
   ATOM *atom4 ;
   double k ;
   double offset ;
   int n ;
   void *next ;
};
#line 8191 "188.c"
typedef struct __anonstruct_TORSION_33 TORSION;
#line 9166 "188.c"
union __anonunion_value_35 {
   double f ;
   int i ;
};
#line 9166 "188.c"
struct __anonstruct_VARIABLE_34 {
   int type ;
   char name[7] ;
   union __anonunion_value_35 value ;
   void *next ;
};
typedef struct __anonstruct_VARIABLE_34 VARIABLE___0;
#line 9166 "188.c"
/*user-defined struct end*/

#line 810 "/usr/include/sys/reent.h"
extern struct _reent *( __attribute__((__cdecl__)) __getreent)(void) ;
#line 170 "/usr/include/stdio.h"
extern FILE *( __attribute__((__cdecl__)) tmpfile)(void) ;
#line 172
extern int ( __attribute__((__cdecl__)) fclose)(FILE * ) ;
#line 173
extern int ( __attribute__((__cdecl__)) fflush)(FILE * ) ;
#line 177
extern int ( __attribute__((__cdecl__)) fprintf)(FILE * , char const   *  , ...) ;
#line 179
extern int ( __attribute__((__cdecl__)) printf)(char const   *  , ...) ;
#line 185
extern int ( __attribute__((__cdecl__)) fgetc)(FILE * ) ;
#line 186
extern char *( __attribute__((__cdecl__)) fgets)(char * , int  , FILE * ) ;
#line 188
extern int ( __attribute__((__cdecl__)) fputs)(char const   * , FILE * ) ;
#line 210
extern void ( __attribute__((__cdecl__)) rewind)(FILE * ) ;
#line 216
extern FILE *( __attribute__((__cdecl__)) fopen)(char const   *_name , char const   *_type ) ;
#line 217
extern int ( __attribute__((__cdecl__)) sprintf)(char * , char const   *  , ...) ;
#line 64 "/usr/include/stdlib.h"
extern double ( __attribute__((__cdecl__)) atof)(char const   *__nptr ) ;
#line 68
extern int ( __attribute__((__cdecl__)) atoi)(char const   *__nptr ) ;
#line 79
extern  __attribute__((__noreturn__)) void ( __attribute__((__cdecl__)) exit)(int __status ) ;
#line 80
extern void ( __attribute__((__cdecl__)) free)(void * ) ;
#line 87
extern void *( __attribute__((__cdecl__)) malloc)(size_t __size ) ;
#line 44 "/usr/include/ctype.h"
extern  __attribute__((__dllimport__)) char const   _ctype_[] ;
#line 76 "/usr/include/math.h"
extern double cos(double  ) ;
#line 77
extern double sin(double  ) ;
#line 83
extern double fabs(double  ) ;
#line 91
extern double acos(double  ) ;
#line 93
extern double atan2(double  , double  ) ;
#line 96
extern double exp(double  ) ;
#line 98
extern double log(double  ) ;
#line 100
extern double pow(double  , double  ) ;
#line 101
extern double sqrt(double  ) ;
#line 29 "/usr/include/string.h"
extern int ( __attribute__((__cdecl__)) strcmp)(char const   * , char const   * ) ;
#line 46 "/usr/include/time.h"
extern clock_t ( __attribute__((__cdecl__)) clock)(void) ;
#line 112 "188.c"
void aaerror(char *line ) ;
#line 113
int a_ftodx(double lambda , double lamold ) ;
#line 114
void a_inactive_f_zero(void) ;
#line 115
void get_bond(ATOM *a1 , ATOM **bonded , int mbond , int *inbond ) ;
#line 116
void mom_param(int serial , double chi , double jaa ) ;
#line 117
void rand3(double *x , double *y , double *z ) ;
#line 118
int set_f_variable(char *name , double f ) ;
#line 119
int a_inc_d(double lambda ) ;
#line 122
void dump_angles(FILE *where ) ;
#line 123
void dump_atoms(FILE *where ) ;
#line 124
void dump_bonds(FILE *where ) ;
#line 125
void dump_excludes(FILE *where ) ;
#line 126
void dump_force(FILE *where ) ;
#line 127
void dump_hybrids(FILE *where ) ;
#line 128
void dump_noels(FILE *where ) ;
#line 129
void dump_pdb(FILE *where , int res_mod ) ;
#line 130
void dump_restrains(FILE *where ) ;
#line 131
void dump_tethers(FILE *where ) ;
#line 132
void dump_tgroup(FILE *where ) ;
#line 133
void dump_torsions(FILE *where ) ;
#line 134
void dump_variable(FILE *where ) ;
#line 135
void dump_velocity(FILE *where ) ;
#line 145
void read_eval_do(FILE *ip , FILE *op ) ;
#line 148
int set_i_variable(char *name , int f ) ;
#line 143 "188.c"

/**************/
int temp_ver=0;
/*************/

int main(void) 
{ struct _reent *tmp ;
  struct _reent *tmp___0 ;

  {
#line 146
  set_f_variable((char *)"mxdq", .05);
#line 147
  set_f_variable((char *)"mxcut", 6.);
#line 148
  set_i_variable("nostep", 1);
#line 149
  tmp = __getreent();
#line 149
  tmp___0 = __getreent();
#line 149
  read_eval_do(tmp___0->_stdin, tmp->_stdout);
#line 150
  return (0);
}
}
#line 163
int v_bond(double *V , double lambda ) ;
#line 163
int f_bond(double lambda ) ;
#line 163
int v_angle(double *V , double lambda ) ;
#line 163
int f_angle(double lambda ) ;
#line 164
int v_mmbond(double *V , double lambda ) ;
#line 164
int f_mmbond(double lambda ) ;
#line 164
int v_mmangle(double *V , double lambda ) ;
#line 164
int f_mmangle(double lambda ) ;
#line 165
int v_nonbon(double *V , double lambda ) ;
#line 165
int f_nonbon(double lambda ) ;
#line 165
int v_torsion(double *V , double lambda ) ;
#line 165
int f_torsion(double lambda ) ;
#line 166
int atom(double x , double y , double z , int serial , double q , double a , double b ,
         double mass , char *name ) ;
#line 166
int bond(int p1 , int p2 , double bl , double fk ) ;
#line 166
int angle(int p1 , int p2 , int p3 , double fk , double bl ) ;
#line 166
int torsion(int p1 , int p2 , int p3 , int p4 , double fk , int n , double off ) ;
#line 167
int v_hybrid(double *V , double lambda ) ;
#line 167
int f_hybrid(double lambda ) ;
#line 168
int restrain(int p1 , int p2 , double bl , double fk ) ;
#line 168
int v_restrain(double *V , double lambda ) ;
#line 168
int f_restrain(double lambda ) ;
#line 169
int tether(int p1 , double fk , double x , double y , double z ) ;
#line 169
int v_tether(double *V , double lambda ) ;
#line 169
int f_tether(double lambda ) ;
#line 170
int u_v_nonbon(double *V , double lambda ) ;
#line 170
int u_f_nonbon(double lambda ) ;
#line 171
int v_noel(double *V , double lambda ) ;
#line 171
int a_noel(double *V , double lambda , int ilow , int ihigh , FILE *op ) ;
#line 172
int v_ho_noel(double *V , double lambda ) ;
#line 173
int a_bond(double *V , double lambda , int ilow , int ihigh , FILE *op ) ;
#line 173
int a_mmbond(double *V , double lambda , int ilow , int ihigh , FILE *op ) ;
#line 173
int a_angle(double *V , double lambda , int ilow , int ihigh , FILE *op ) ;
#line 173
int a_mmangle(double *V , double lambda , int ilow , int ihigh , FILE *op ) ;
#line 174
int a_nonbon(double *V , double lambda , int ilow , int ihigh , FILE *op ) ;
#line 174
int a_torsion(double *V , double lambda , int ilow , int ihigh , FILE *op ) ;
#line 174
int a_hybrid(double *V , double lambda , int ilow , int ihigh , FILE *op ) ;
#line 174
int a_restrain(double *V , double lambda , int ilow , int ihigh , FILE *op ) ;
#line 175
int a_tether(double *V , double lambda , int ilow , int ihigh , FILE *op ) ;
#line 157 "188.c"
void analyze(int (**vfs)() , int nfs , int ilow , int ihigh , FILE *op ) 
{ double V ;
  double vt ;
  int ifs ;
  int i ;
  int j ;

  {
#line 179
  i = ilow;
#line 180
  j = ihigh;
#line 181
  if (ihigh < ilow) {
#line 181
    j = ilow;
  }
#line 182
  V = 0.;
#line 183
  ifs = 0;
#line 183
  while (ifs < nfs) {
#line 185
    vt = 0.;
#line 186
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_bond)) {
#line 187
      a_bond(& vt, 0., i, j, op);
#line 187
      fprintf(op, " %f bond energy\n", vt);
      goto DONE;
    }
#line 188
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_mmbond)) {
#line 189
      a_mmbond(& vt, 0., i, j, op);
#line 189
      fprintf(op, " %f mm bond energy\n", vt);
      goto DONE;
    }
#line 190
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_mmangle)) {
#line 191
      a_mmangle(& vt, 0., i, j, op);
#line 191
      fprintf(op, " %f mm angle energy\n", vt);
      goto DONE;
    }
#line 192
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_angle)) {
#line 193
      a_angle(& vt, 0., i, j, op);
#line 193
      fprintf(op, " %f angle energy\n", vt);
      goto DONE;
    }
#line 194
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_noel)) {
#line 195
      a_noel(& vt, 0., i, j, op);
#line 195
      fprintf(op, " %f noel energy\n", vt);
      goto DONE;
    }
#line 196
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_ho_noel)) {
#line 197
      a_noel(& vt, 0., i, j, op);
#line 197
      fprintf(op, " %f noel energy\n", vt);
      goto DONE;
    }
#line 198
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& u_v_nonbon)) {
#line 199
      a_nonbon(& vt, 0., i, j, op);
#line 199
      fprintf(op, " %f non-bonded energy\n", vt);
      goto DONE;
    }
#line 200
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_nonbon)) {
#line 201
      a_nonbon(& vt, 0., i, j, op);
#line 201
      fprintf(op, " %f non-bonded energy\n", vt);
      goto DONE;
    }
#line 202
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_torsion)) {
#line 203
      a_torsion(& vt, 0., i, j, op);
#line 203
      fprintf(op, " %f torsion energy\n", vt);
      goto DONE;
    }
#line 204
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_hybrid)) {
#line 205
      a_hybrid(& vt, 0., i, j, op);
#line 205
      fprintf(op, " %f hybrid energy\n", vt);
      goto DONE;
    }
#line 206
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_tether)) {
#line 207
      a_tether(& vt, 0., i, j, op);
#line 207
      fprintf(op, " %f tether restraint energy\n", vt);
      goto DONE;
    }
#line 208
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_restrain)) {
#line 209
      a_restrain(& vt, 0., i, j, op);
#line 209
      fprintf(op, " %f restraint bond energy\n", vt);
      goto DONE;
    }
    DONE: 
#line 211
    V += vt;
#line 212
    vt = 0.;
#line 183
    ifs ++;
  }
#line 214
  fprintf(op, " %f total potential energy\n", V);
#line 215
  return;
}
}
#line 227 "188.c"
ANGLE *angle_first  =    (ANGLE *)((void *)0);
#line 228 "188.c"
ANGLE *angle_last  =    (ANGLE *)((void *)0);
#line 234
ATOM *a_m_serial(int serial ) ;
#line 229 "188.c"
int angle(int p1 , int p2 , int p3 , double fk , double bl ) 
{ ANGLE *new ;
  ATOM *ap1 ;
  ATOM *ap2 ;
  ATOM *ap3 ;
  char line[80] ;
  int i ;
  void *tmp ;

  {
#line 237
  ap1 = a_m_serial(p1);
#line 238
  ap2 = a_m_serial(p2);
#line 239
  ap3 = a_m_serial(p3);
#line 240
  if ((unsigned int )ap1 == (unsigned int )((void *)0)) {
#line 242
    sprintf(line, "undefined atom in angle %d %d %d \000", p1, p2, p3);
#line 243
    aaerror(line);
#line 244
    return (0);
  } else {
#line 240
    if ((unsigned int )ap2 == (unsigned int )((void *)0)) {
#line 242
      sprintf(line, "undefined atom in angle %d %d %d \000", p1, p2, p3);
#line 243
      aaerror(line);
#line 244
      return (0);
    } else {
#line 240
      if ((unsigned int )ap3 == (unsigned int )((void *)0)) {
#line 242
        sprintf(line, "undefined atom in angle %d %d %d \000", p1, p2, p3);
#line 243
        aaerror(line);
#line 244
        return (0);
      }
    }
  }
#line 246
  tmp = malloc(sizeof(ANGLE ));
#line 246
  new = (ANGLE *)tmp;
#line 246
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 248
    return (0);
  }
#line 251
  if ((unsigned int )angle_first == (unsigned int )((void *)0)) {
#line 251
    angle_first = new;
  }
#line 252
  if ((unsigned int )angle_last == (unsigned int )((void *)0)) {
#line 252
    angle_last = new;
  }
#line 253
  new->atom1 = ap1;
#line 254
  new->atom2 = ap2;
#line 255
  new->atom3 = ap3;
#line 256
  new->target = bl;
#line 257
  new->k = fk;
#line 258
  new->next = (void *)new;
#line 259
  if (ap1->dontuse < 32) {
#line 261
    i = 0;
#line 261
    while (i < ap1->dontuse) {
#line 263
      if ((unsigned int )ap1->excluded[i] == (unsigned int )ap3) {
        goto excluded1;
      }
#line 261
      i ++;
    }
#line 265
    ap1->excluded[ap1->dontuse] = (void *)ap3;
#line 265
    (ap1->dontuse) ++;
  } else {
#line 267
    aaerror((char *)" too many bonds to an atom increase NEXCLUDE in ammp.h");
#line 268
    exit(0);
  }
  excluded1: 
#line 271
  if (ap3->dontuse < 32) {
#line 273
    i = 0;
#line 273
    while (i < ap3->dontuse) {
#line 275
      if ((unsigned int )ap3->excluded[i] == (unsigned int )ap1) {
        goto excluded3;
      }
#line 273
      i ++;
    }
#line 277
    ap3->excluded[ap3->dontuse] = (void *)ap1;
#line 277
    (ap3->dontuse) ++;
  } else {
#line 279
    aaerror((char *)" too many bonds to an atom increase NEXCLUDE in ammp.h");
#line 280
    exit(0);
  }
  excluded3: 
#line 283
  angle_last->next = (void *)new;
#line 284
  angle_last = new;
#line 285
  return (1);
}
}
#line 287 "188.c"
int v_angle(double *V , double lambda ) 
{ ANGLE *bp ;
  double r ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double dp ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;

  {
#line 294
  bp = angle_first;
#line 295
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 295
    return (1);
  }
#line 296
  while (1) {
#line 298
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 298
      return (0);
    }
#line 299
    a1 = bp->atom1;
#line 299
    a2 = bp->atom2;
#line 299
    a3 = bp->atom3;
#line 300
    if (a1->active) {
      goto _L;
    } else {
#line 300
      if (a2->active) {
        goto _L;
      } else {
#line 300
        if (a3->active) {
          _L: /* CIL Label */ 
#line 302
          x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 303
          y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 304
          z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 305
          x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 306
          y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 307
          z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 308
          dp = (x1 * x2 + y1___0 * y2) + z1 * z2;
#line 309
          r = ((x1 * x1 + y1___0 * y1___0) + z1 * z1) * ((x2 * x2 + y2 * y2) + z2 * z2);
#line 310
          if (r > 1.e-8) {
#line 311
            r = sqrt(r);
#line 312
            dp /= r;
#line 312
            if (dp > 1.) {
#line 312
              dp = 1.;
            }
#line 312
            if (dp < - 1.) {
#line 312
              dp = - 1.;
            }
#line 313
            dp = acos(dp);
#line 314
            *V += (bp->k * (bp->target - dp)) * (bp->target - dp);
          }
        }
      }
    }
#line 317
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 317
      return (1);
    }
#line 318
    bp = (ANGLE *)bp->next;
  }
}
}
#line 321 "188.c"
int f_angle(double lambda ) 
{ ANGLE *bp ;
  double r ;
  double k ;
  double ux1 ;
  double uy1 ;
  double uz1 ;
  double ux2 ;
  double uy2 ;
  double uz2 ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double r1 ;
  double r2 ;
  double dtheta ;
  double dp ;
  double r11 ;
  double r22 ;
  double sdth ;

  {
#line 330
  bp = angle_first;
#line 331
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 331
    return (1);
  }
#line 332
  while (1) {
#line 334
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 334
      return (0);
    }
#line 335
    k = bp->k;
#line 336
    a1 = bp->atom1;
#line 336
    a2 = bp->atom2;
#line 336
    a3 = bp->atom3;
#line 337
    if (a1->active) {
      goto _L;
    } else {
#line 337
      if (a2->active) {
        goto _L;
      } else {
#line 337
        if (a3->active) {
          _L: /* CIL Label */ 
#line 339
          x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 340
          y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 341
          z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 342
          x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 343
          y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 344
          z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 345
          dp = (x1 * x2 + y1___0 * y2) + z1 * z2;
#line 346
          r1 = sqrt((x1 * x1 + y1___0 * y1___0) + z1 * z1);
#line 347
          r2 = sqrt((x2 * x2 + y2 * y2) + z2 * z2);
#line 348
          if (r1 < 1.e-5) {
            goto SKIP;
          } else {
#line 348
            if (r2 < 1.e-5) {
              goto SKIP;
            }
          }
#line 349
          r = r1 * r2;
#line 350
          if (r > 1.e-8) {
#line 351
            dp /= r;
#line 351
            if (dp > 1.) {
#line 351
              dp = 1.;
            }
#line 351
            if (dp < - 1.) {
#line 351
              dp = - 1.;
            }
#line 352
            dtheta = acos(dp);
#line 353
            sdth = sin(dtheta);
#line 353
            if (sdth < 1.e-3) {
#line 353
              sdth = 1.e-3;
            }
#line 354
            r11 = r1 * sdth;
#line 354
            r22 = r2 * sdth;
#line 355
            ux1 = x2 / r2 - (dp * x1) / r1;
#line 356
            uy1 = y2 / r2 - (dp * y1___0) / r1;
#line 357
            uz1 = z2 / r2 - (dp * z1) / r1;
#line 358
            ux2 = x1 / r1 - (dp * x2) / r2;
#line 359
            uy2 = y1___0 / r1 - (dp * y2) / r2;
#line 360
            uz2 = z1 / r1 - (dp * z2) / r2;
#line 361
            dtheta = (- 2. * k) * (bp->target - dtheta);
#line 362
            ux1 = (ux1 * dtheta) / r11;
#line 363
            uy1 = (uy1 * dtheta) / r11;
#line 364
            uz1 = (uz1 * dtheta) / r11;
#line 365
            ux2 = (ux2 * dtheta) / r22;
#line 366
            uy2 = (uy2 * dtheta) / r22;
#line 367
            uz2 = (uz2 * dtheta) / r22;
#line 368
            if (a1->active) {
#line 370
              a1->fx += ux1;
#line 371
              a1->fy += uy1;
#line 372
              a1->fz += uz1;
            }
#line 374
            if (a2->active) {
#line 376
              a2->fx += - ux1 - ux2;
#line 377
              a2->fy += - uy1 - uy2;
#line 378
              a2->fz += - uz1 - uz2;
            }
#line 380
            if (a3->active) {
#line 382
              a3->fx += ux2;
#line 383
              a3->fy += uy2;
#line 384
              a3->fz += uz2;
            }
          }
        }
      }
    }
    SKIP: 
#line 389
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 389
      return (1);
    }
#line 390
    bp = (ANGLE *)bp->next;
  }
}
}
#line 393 "188.c"
void get_angle(ATOM *a1 , ATOM **bonded , int mbond , int *inbond ) 
{ ANGLE *mine ;
  int tmp ;
  int tmp___0 ;

  {
#line 398
  mine = angle_first;
#line 399
  *inbond = 0;
#line 400
  while (1) {
#line 402
    if ((unsigned int )mine == (unsigned int )((void *)0)) {
#line 404
      return;
    }
#line 406
    if ((unsigned int )mine->atom1 == (unsigned int )a1) {
#line 408
      tmp = *inbond;
#line 408
      (*inbond) ++;
#line 408
      *(bonded + tmp) = mine->atom3;
    }
#line 410
    if ((unsigned int )mine->atom3 == (unsigned int )a1) {
#line 412
      tmp___0 = *inbond;
#line 412
      (*inbond) ++;
#line 412
      *(bonded + tmp___0) = mine->atom1;
    }
#line 414
    if ((unsigned int )mine == (unsigned int )mine->next) {
#line 414
      return;
    }
#line 415
    mine = (ANGLE *)mine->next;
#line 416
    if (*inbond == mbond) {
#line 416
      return;
    }
  }
}
}
#line 419 "188.c"
void dump_angles(FILE *where ) 
{ ANGLE *b ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  double rtodeg ;
  double tmp ;

  {
#line 424
  b = angle_first;
#line 425
  if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 425
    return;
  }
#line 426
  tmp = acos(- 1.);
#line 426
  rtodeg = 180. / tmp;
#line 427
  while ((unsigned int )b->next != (unsigned int )b) {
#line 429
    if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 429
      return;
    }
#line 430
    a1 = b->atom1;
#line 430
    a2 = b->atom2;
#line 430
    a3 = b->atom3;
#line 431
    fprintf(where, "angle %d %d %d %f %f ;\n", a1->serial, a2->serial, a3->serial,
            b->k, b->target * rtodeg);
#line 433
    b = (ANGLE *)b->next;
  }
#line 435
  if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 435
    return;
  }
#line 436
  a1 = b->atom1;
#line 436
  a2 = b->atom2;
#line 436
  a3 = b->atom3;
#line 437
  fprintf(where, "angle %d %d %d %f %f ;\n", a1->serial, a2->serial, a3->serial, b->k,
          b->target * rtodeg);
#line 439
  return;
}
}
#line 440 "188.c"
int v_mmangle(double *V , double lambda ) 
{ ANGLE *bp ;
  double r ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double dp ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;

  {
#line 447
  bp = angle_first;
#line 448
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 448
    return (1);
  }
#line 449
  while (1) {
#line 451
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 451
      return (0);
    }
#line 452
    a1 = bp->atom1;
#line 452
    a2 = bp->atom2;
#line 452
    a3 = bp->atom3;
#line 453
    if (a1->active) {
      goto _L;
    } else {
#line 453
      if (a2->active) {
        goto _L;
      } else {
#line 453
        if (a3->active) {
          _L: /* CIL Label */ 
#line 455
          x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 456
          y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 457
          z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 458
          x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 459
          y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 460
          z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 461
          dp = (x1 * x2 + y1___0 * y2) + z1 * z2;
#line 462
          r = ((x1 * x1 + y1___0 * y1___0) + z1 * z1) * ((x2 * x2 + y2 * y2) + z2 * z2);
#line 463
          if (r > 1.e-8) {
#line 464
            r = sqrt(r);
#line 465
            dp /= r;
#line 465
            if (dp > 1.) {
#line 465
              dp = 1.;
            }
#line 465
            if (dp < - 1.) {
#line 465
              dp = - 1.;
            }
#line 466
            dp = acos(dp);
#line 467
            dp -= bp->target;
#line 468
            *V += ((bp->k * dp) * dp) * ((((1. - .014 * dp) + (5.6e-5 * dp) * dp) - ((7.e-7 * dp) * dp) * dp) + (((9e-10 * dp) * dp) * dp) * dp);
          }
        }
      }
    }
#line 472
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 472
      return (1);
    }
#line 473
    bp = (ANGLE *)bp->next;
  }
}
}
#line 476 "188.c"
int f_mmangle(double lambda ) 
{ ANGLE *bp ;
  double r ;
  double k ;
  double ux1 ;
  double uy1 ;
  double uz1 ;
  double ux2 ;
  double uy2 ;
  double uz2 ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double r1 ;
  double r2 ;
  double dtheta ;
  double dp ;
  double r11 ;
  double r22 ;
  double sdth ;

  {
#line 485
  bp = angle_first;
#line 486
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 486
    return (1);
  }
#line 487
  while (1) {
#line 489
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 489
      return (0);
    }
#line 490
    k = bp->k;
#line 491
    a1 = bp->atom1;
#line 491
    a2 = bp->atom2;
#line 491
    a3 = bp->atom3;
#line 492
    if (a1->active) {
      goto _L;
    } else {
#line 492
      if (a2->active) {
        goto _L;
      } else {
#line 492
        if (a3->active) {
          _L: /* CIL Label */ 
#line 494
          x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 495
          y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 496
          z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 497
          x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 498
          y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 499
          z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 500
          dp = (x1 * x2 + y1___0 * y2) + z1 * z2;
#line 501
          r1 = sqrt((x1 * x1 + y1___0 * y1___0) + z1 * z1);
#line 502
          r2 = sqrt((x2 * x2 + y2 * y2) + z2 * z2);
#line 503
          if (r1 < 1.e-5) {
            goto SKIP;
          } else {
#line 503
            if (r2 < 1.e-5) {
              goto SKIP;
            }
          }
#line 504
          r = r1 * r2;
#line 505
          if (r > 1.e-8) {
#line 506
            dp /= r;
#line 506
            if (dp > 1.) {
#line 506
              dp = 1.;
            }
#line 506
            if (dp < - 1.) {
#line 506
              dp = - 1.;
            }
#line 507
            dtheta = acos(dp);
#line 508
            sdth = sin(dtheta);
#line 508
            if (sdth < 1.e-3) {
#line 508
              sdth = 1.e-3;
            }
#line 509
            r11 = r1 * sdth;
#line 509
            r22 = r2 * sdth;
#line 510
            ux1 = x2 / r2 - (dp * x1) / r1;
#line 511
            uy1 = y2 / r2 - (dp * y1___0) / r1;
#line 512
            uz1 = z2 / r2 - (dp * z1) / r1;
#line 513
            ux2 = x1 / r1 - (dp * x2) / r2;
#line 514
            uy2 = y1___0 / r1 - (dp * y2) / r2;
#line 515
            uz2 = z1 / r1 - (dp * z2) / r2;
#line 516
            dp = dtheta - bp->target;
#line 517
            dtheta = (k * dp) * ((((2. - (.014 * (double )3) * dp) + (((double )4 * 5.6e-5) * dp) * dp) - ((((double )5 * 7.e-7) * dp) * dp) * dp) + (((((double )6 * 9.e-10) * dp) * dp) * dp) * dp);
#line 519
            ux1 = (ux1 * dtheta) / r11;
#line 520
            uy1 = (uy1 * dtheta) / r11;
#line 521
            uz1 = (uz1 * dtheta) / r11;
#line 522
            ux2 = (ux2 * dtheta) / r22;
#line 523
            uy2 = (uy2 * dtheta) / r22;
#line 524
            uz2 = (uz2 * dtheta) / r22;
#line 525
            if (a1->active) {
#line 526
              a1->fx += ux1;
#line 527
              a1->fy += uy1;
#line 528
              a1->fz += uz1;
            }
#line 530
            if (a2->active) {
#line 531
              a2->fx += - ux1 - ux2;
#line 532
              a2->fy += - uy1 - uy2;
#line 533
              a2->fz += - uz1 - uz2;
            }
#line 535
            if (a3->active) {
#line 536
              a3->fx += ux2;
#line 537
              a3->fy += uy2;
#line 538
              a3->fz += uz2;
            }
          }
        }
      }
    }
    SKIP: 
#line 543
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 543
      return (1);
    }
#line 544
    bp = (ANGLE *)bp->next;
  }
}
}
#line 547 "188.c"
int a_angle(double *V , double lambda , int ilow , int ihigh , FILE *op ) 
{ ANGLE *bp ;
  double r ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double dp ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;

  {
#line 556
  bp = angle_first;
#line 557
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 557
    return (1);
  }
#line 558
  while (1) {
#line 560
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 560
      return (0);
    }
#line 561
    a1 = bp->atom1;
#line 561
    a2 = bp->atom2;
#line 561
    a3 = bp->atom3;
#line 562
    if (a1->serial >= ilow) {
#line 562
      if (a1->serial <= ihigh) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 562
      if (a2->serial >= ilow) {
#line 562
        if (a2->serial <= ihigh) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 562
        if (a3->serial >= ilow) {
#line 562
          if (a3->serial <= ihigh) {
            _L: /* CIL Label */ 
#line 566
            x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 567
            y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 568
            z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 569
            x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 570
            y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 571
            z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 572
            dp = (x1 * x2 + y1___0 * y2) + z1 * z2;
#line 573
            r = ((x1 * x1 + y1___0 * y1___0) + z1 * z1) * ((x2 * x2 + y2 * y2) + z2 * z2);
#line 574
            if (r > 1.e-8) {
#line 575
              r = sqrt(r);
#line 576
              dp /= r;
#line 576
              if (dp > 1.) {
#line 576
                dp = 1.;
              }
#line 576
              if (dp < - 1.) {
#line 576
                dp = - 1.;
              }
#line 577
              dp = acos(dp);
#line 578
              z2 = (bp->k * (bp->target - dp)) * (bp->target - dp);
#line 579
              *V += z2;
#line 580
              fprintf(op, "Angle %s %d %s %d %s %d E %f value %f error %f\n", a1->name,
                      a1->serial, a2->name, a2->serial, a3->name, a3->serial, z2,
                      (dp * 180.) / 3.14159265, ((dp - bp->target) * 180.) / 3.14159265);
            }
          }
        }
      }
    }
#line 586
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 586
      return (1);
    }
#line 587
    bp = (ANGLE *)bp->next;
  }
}
}
#line 590 "188.c"
int a_mmangle(double *V , double lambda , int ilow , int ihigh , FILE *op ) 
{ ANGLE *bp ;
  double r ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double dp ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;

  {
#line 599
  bp = angle_first;
#line 600
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 600
    return (1);
  }
#line 601
  while (1) {
#line 603
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 603
      return (0);
    }
#line 604
    a1 = bp->atom1;
#line 604
    a2 = bp->atom2;
#line 604
    a3 = bp->atom3;
#line 605
    if (a1->serial >= ilow) {
#line 605
      if (a1->serial <= ihigh) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 605
      if (a2->serial >= ilow) {
#line 605
        if (a2->serial <= ihigh) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 605
        if (a3->serial >= ilow) {
#line 605
          if (a3->serial <= ihigh) {
            _L: /* CIL Label */ 
#line 609
            x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 610
            y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 611
            z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 612
            x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 613
            y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 614
            z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 615
            dp = (x1 * x2 + y1___0 * y2) + z1 * z2;
#line 616
            r = ((x1 * x1 + y1___0 * y1___0) + z1 * z1) * ((x2 * x2 + y2 * y2) + z2 * z2);
#line 617
            if (r > 1.e-8) {
#line 618
              r = sqrt(r);
#line 619
              dp /= r;
#line 619
              if (dp > 1.) {
#line 619
                dp = 1.;
              }
#line 619
              if (dp < - 1.) {
#line 619
                dp = - 1.;
              }
#line 620
              dp = acos(dp);
#line 621
              dp -= bp->target;
#line 622
              z2 = ((bp->k * dp) * dp) * ((((1. - .014 * dp) + (5.6e-5 * dp) * dp) - ((7.e-7 * dp) * dp) * dp) + (((9e-10 * dp) * dp) * dp) * dp);
#line 624
              *V += z2;
#line 625
              dp += bp->target;
#line 626
              fprintf(op, "mmAngle %s %d %s %d %s %d E %f value %f error %f\n", a1->name,
                      a1->serial, a2->name, a2->serial, a3->name, a3->serial, z2,
                      (dp * 180.) / 3.14159265, ((dp - bp->target) * 180.) / 3.14159265);
            }
          }
        }
      }
    }
#line 632
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 632
      return (1);
    }
#line 633
    bp = (ANGLE *)bp->next;
  }
}
}
#line 636 "188.c"
int v_c_angle(double *V , double lambda ) 
{ ANGLE *bp ;
  double r ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double dp ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  double C0 ;
  double C1 ;
  double C2 ;
  double tmp ;

  {
#line 644
  bp = angle_first;
#line 645
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 645
    return (1);
  }
#line 646
  while (1) {
#line 648
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 648
      return (0);
    }
#line 649
    a1 = bp->atom1;
#line 649
    a2 = bp->atom2;
#line 649
    a3 = bp->atom3;
#line 650
    if (a1->active) {
      goto _L;
    } else {
#line 650
      if (a2->active) {
        goto _L;
      } else {
#line 650
        if (a3->active) {
          _L: /* CIL Label */ 
#line 652
          x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 653
          y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 654
          z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 655
          x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 656
          y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 657
          z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 658
          dp = (x1 * x2 + y1___0 * y2) + z1 * z2;
#line 659
          r = ((x1 * x1 + y1___0 * y1___0) + z1 * z1) * ((x2 * x2 + y2 * y2) + z2 * z2);
#line 660
          if (r > 1.e-8) {
#line 661
            r = sqrt(r);
#line 662
            dp /= r;
#line 662
            if (dp > 1.) {
#line 662
              dp = 1.;
            }
#line 662
            if (dp < - 1.) {
#line 662
              dp = - 1.;
            }
#line 663
            r = dp;
#line 664
            dp = acos(dp);
#line 665
            C0 = cos(bp->target);
#line 666
            C2 = 1. / (4. - ((double )4 * C0) * C0);
#line 667
            C1 = (- 4. * C2) * C0;
#line 668
            C0 = C2 * (((double )2 * C0) * C0 + (double )1);
#line 669
            tmp = cos(dp * (double )2);
#line 669
            *V += ((double )2 * bp->k) * ((C0 + C1 * r) + C2 * tmp);
          }
        }
      }
    }
#line 672
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 672
      return (1);
    }
#line 673
    bp = (ANGLE *)bp->next;
  }
}
}
#line 676 "188.c"
int f_c_angle(double lambda ) 
{ ANGLE *bp ;
  double r ;
  double k ;
  double ux1 ;
  double uy1 ;
  double uz1 ;
  double ux2 ;
  double uy2 ;
  double uz2 ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double r1 ;
  double r2 ;
  double dtheta ;
  double dp ;
  double r11 ;
  double r22 ;
  double sdth ;
  double C0 ;
  double C1 ;
  double C2 ;
  double tmp ;

  {
#line 686
  bp = angle_first;
#line 687
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 687
    return (1);
  }
#line 688
  while (1) {
#line 690
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 690
      return (0);
    }
#line 691
    k = bp->k;
#line 692
    a1 = bp->atom1;
#line 692
    a2 = bp->atom2;
#line 692
    a3 = bp->atom3;
#line 693
    if (a1->active) {
      goto _L;
    } else {
#line 693
      if (a2->active) {
        goto _L;
      } else {
#line 693
        if (a3->active) {
          _L: /* CIL Label */ 
#line 695
          x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 696
          y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 697
          z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 698
          x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 699
          y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 700
          z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 701
          dp = (x1 * x2 + y1___0 * y2) + z1 * z2;
#line 702
          r1 = sqrt((x1 * x1 + y1___0 * y1___0) + z1 * z1);
#line 703
          r2 = sqrt((x2 * x2 + y2 * y2) + z2 * z2);
#line 704
          if (r1 < 1.e-5) {
            goto SKIP;
          } else {
#line 704
            if (r2 < 1.e-5) {
              goto SKIP;
            }
          }
#line 705
          r = r1 * r2;
#line 706
          if (r > 1.e-8) {
#line 707
            dp /= r;
#line 707
            if (dp > 1.) {
#line 707
              dp = 1.;
            }
#line 707
            if (dp < - 1.) {
#line 707
              dp = - 1.;
            }
#line 708
            dtheta = acos(dp);
#line 709
            sdth = sin(dtheta);
#line 709
            if (sdth < 1.e-3) {
#line 709
              sdth = 1.e-3;
            }
#line 710
            r11 = r1 * sdth;
#line 710
            r22 = r2 * sdth;
#line 711
            ux1 = x2 / r2 - (dp * x1) / r1;
#line 712
            uy1 = y2 / r2 - (dp * y1___0) / r1;
#line 713
            uz1 = z2 / r2 - (dp * z1) / r1;
#line 714
            ux2 = x1 / r1 - (dp * x2) / r2;
#line 715
            uy2 = y1___0 / r1 - (dp * y2) / r2;
#line 716
            uz2 = z1 / r1 - (dp * z2) / r2;
#line 717
            C0 = cos(bp->target);
#line 718
            C2 = 1. / (4. - ((double )4 * C0) * C0);
#line 719
            C1 = (- 4. * C2) * C0;
#line 720
            C0 = C2 * (((double )2 * C0) * C0 + (double )1);
#line 721
            tmp = sin(dtheta * (double )2);
#line 721
            dtheta = (- 2. * bp->k) * (C1 * sdth + ((double )2 * C2) * tmp);
#line 722
            ux1 = (ux1 * dtheta) / r11;
#line 723
            uy1 = (uy1 * dtheta) / r11;
#line 724
            uz1 = (uz1 * dtheta) / r11;
#line 725
            ux2 = (ux2 * dtheta) / r22;
#line 726
            uy2 = (uy2 * dtheta) / r22;
#line 727
            uz2 = (uz2 * dtheta) / r22;
#line 728
            if (a1->active) {
#line 729
              a1->fx += ux1;
#line 730
              a1->fy += uy1;
#line 731
              a1->fz += uz1;
            }
#line 733
            if (a2->active) {
#line 734
              a2->fx += - ux1 - ux2;
#line 735
              a2->fy += - uy1 - uy2;
#line 736
              a2->fz += - uz1 - uz2;
            }
#line 738
            if (a3->active) {
#line 739
              a3->fx += ux2;
#line 740
              a3->fy += uy2;
#line 741
              a3->fz += uz2;
            }
          }
        }
      }
    }
    SKIP: 
#line 746
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 746
      return (1);
    }
#line 747
    bp = (ANGLE *)bp->next;
  }
}
}
#line 750 "188.c"
int a_c_angle(double *V , double lambda , int ilow , int ihigh , FILE *op ) 
{ ANGLE *bp ;
  double r ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double dp ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  double C0 ;
  double C1 ;
  double C2 ;
  double tmp ;

  {
#line 760
  bp = angle_first;
#line 761
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 761
    return (1);
  }
#line 762
  while (1) {
#line 764
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 764
      return (0);
    }
#line 765
    a1 = bp->atom1;
#line 765
    a2 = bp->atom2;
#line 765
    a3 = bp->atom3;
#line 766
    if (a1->serial >= ilow) {
#line 766
      if (a1->serial <= ihigh) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 766
      if (a2->serial >= ilow) {
#line 766
        if (a2->serial <= ihigh) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 766
        if (a3->serial >= ilow) {
#line 766
          if (a3->serial <= ihigh) {
            _L: /* CIL Label */ 
#line 770
            x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 771
            y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 772
            z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 773
            x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 774
            y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 775
            z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 776
            dp = (x1 * x2 + y1___0 * y2) + z1 * z2;
#line 777
            r = ((x1 * x1 + y1___0 * y1___0) + z1 * z1) * ((x2 * x2 + y2 * y2) + z2 * z2);
#line 778
            if (r > 1.e-8) {
#line 779
              r = sqrt(r);
#line 780
              dp /= r;
#line 780
              if (dp > 1.) {
#line 780
                dp = 1.;
              }
#line 780
              if (dp < - 1.) {
#line 780
                dp = - 1.;
              }
#line 781
              r = dp;
#line 782
              dp = acos(dp);
#line 783
              C0 = cos(bp->target);
#line 784
              C2 = 1. / (4. - ((double )4 * C0) * C0);
#line 785
              C1 = (- 4. * C2) * C0;
#line 786
              C0 = C2 * (((double )2 * C0) * C0 + (double )1);
#line 787
              tmp = cos(dp * (double )2);
#line 787
              *V += ((double )2 * bp->k) * ((C0 + C1 * r) + C2 * tmp);
#line 788
              fprintf(op, "c Angle %s %d %s %d %s %d E %f value %f error %f\n", a1->name,
                      a1->serial, a2->name, a2->serial, a3->name, a3->serial, z2,
                      (dp * 180.) / 3.14159265, ((dp - bp->target) * 180.) / 3.14159265);
            }
          }
        }
      }
    }
#line 794
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 794
      return (1);
    }
#line 795
    bp = (ANGLE *)bp->next;
  }
}
}
#line 804
double bond_length(ATOM *a1 , ATOM *a2 ) ;
#line 798 "188.c"
int gsdg_angle(ATOM *who ) 
{ ANGLE *bp ;
  ATOM *ap ;
  ATOM *ap1 ;
  double r ;
  double r1 ;
  double theta ;
  double tmp ;
  double tmp___0 ;

  {
#line 805
  bp = angle_first;
#line 806
  while (1) {
#line 807
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 807
      return (0);
    }
#line 808
    if ((unsigned int )bp->atom1 == (unsigned int )who) {
#line 809
      ap1 = bp->atom2;
#line 810
      ap = bp->atom3;
#line 811
      r = bond_length(who, ap1);
#line 811
      r1 = bond_length(ap1, ap);
#line 812
      tmp = cos(bp->target);
#line 812
      theta = (r * r + r1 * r1) - (((double )2 * tmp) * r) * r1;
#line 813
      ap->vx = theta;
#line 814
      ap->vy = bp->k;
    }
#line 816
    if ((unsigned int )bp->atom3 == (unsigned int )who) {
#line 817
      ap1 = bp->atom2;
#line 818
      ap = bp->atom1;
#line 819
      r = bond_length(who, ap1);
#line 819
      r1 = bond_length(ap1, ap);
#line 820
      tmp___0 = cos(bp->target);
#line 820
      theta = (r * r + r1 * r1) - (((double )2 * tmp___0) * r) * r1;
#line 821
      ap->vx = theta;
#line 822
      ap->vy = bp->k;
    }
#line 824
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 824
      return (0);
    }
#line 825
    bp = (ANGLE *)bp->next;
  }
}
}
#line 835
double get_f_variable(char *name ) ;
#line 828 "188.c"
int v_ho_angle(double *V , double lambda ) 
{ ANGLE *bp ;
  double r ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double dp ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  double hol ;
  double target ;

  {
#line 836
  hol = get_f_variable("lambda");
#line 837
  if (hol < 0.) {
#line 837
    hol = 0.;
  }
#line 838
  if (hol > 1.) {
#line 838
    hol = 1.;
  }
#line 839
  bp = angle_first;
#line 840
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 840
    return (1);
  }
#line 841
  while (1) {
#line 843
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 843
      return (0);
    }
#line 844
    a1 = bp->atom1;
#line 844
    a2 = bp->atom2;
#line 844
    a3 = bp->atom3;
#line 845
    if (a1->active) {
      goto _L;
    } else {
#line 845
      if (a2->active) {
        goto _L;
      } else {
#line 845
        if (a3->active) {
          _L: /* CIL Label */ 
#line 847
          x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 848
          y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 849
          z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 850
          x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 851
          y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 852
          z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 853
          dp = (x1 * x2 + y1___0 * y2) + z1 * z2;
#line 854
          r = ((x1 * x1 + y1___0 * y1___0) + z1 * z1) * ((x2 * x2 + y2 * y2) + z2 * z2);
#line 855
          if (r > 1.e-8) {
#line 856
            r = sqrt(r);
#line 857
            dp /= r;
#line 857
            if (dp > 1.) {
#line 857
              dp = 1.;
            }
#line 857
            if (dp < - 1.) {
#line 857
              dp = - 1.;
            }
#line 858
            dp = acos(dp);
#line 859
            target = hol * dp + (1. - hol) * bp->target;
#line 860
            *V += (bp->k * (target - dp)) * (target - dp);
          }
        }
      }
    }
#line 863
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 863
      return (1);
    }
#line 864
    bp = (ANGLE *)bp->next;
  }
}
}
#line 867 "188.c"
int f_ho_angle(double lambda ) 
{ ANGLE *bp ;
  double r ;
  double k ;
  double ux1 ;
  double uy1 ;
  double uz1 ;
  double ux2 ;
  double uy2 ;
  double uz2 ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double r1 ;
  double r2 ;
  double dtheta ;
  double dp ;
  double r11 ;
  double r22 ;
  double sdth ;
  double hol ;
  double target ;

  {
#line 877
  hol = get_f_variable("lambda");
#line 878
  if (hol < 0.) {
#line 878
    hol = 0.;
  }
#line 879
  if (hol > 1.) {
#line 879
    hol = 1.;
  }
#line 880
  bp = angle_first;
#line 881
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 881
    return (1);
  }
#line 882
  while (1) {
#line 884
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 884
      return (0);
    }
#line 885
    k = bp->k;
#line 886
    a1 = bp->atom1;
#line 886
    a2 = bp->atom2;
#line 886
    a3 = bp->atom3;
#line 887
    if (a1->active) {
      goto _L;
    } else {
#line 887
      if (a2->active) {
        goto _L;
      } else {
#line 887
        if (a3->active) {
          _L: /* CIL Label */ 
#line 889
          x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 890
          y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 891
          z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 892
          x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 893
          y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 894
          z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 895
          dp = (x1 * x2 + y1___0 * y2) + z1 * z2;
#line 896
          r1 = sqrt((x1 * x1 + y1___0 * y1___0) + z1 * z1);
#line 897
          r2 = sqrt((x2 * x2 + y2 * y2) + z2 * z2);
#line 898
          if (r1 < 1.e-5) {
            goto SKIP;
          } else {
#line 898
            if (r2 < 1.e-5) {
              goto SKIP;
            }
          }
#line 899
          r = r1 * r2;
#line 900
          if (r > 1.e-8) {
#line 901
            dp /= r;
#line 901
            if (dp > 1.) {
#line 901
              dp = 1.;
            }
#line 901
            if (dp < - 1.) {
#line 901
              dp = - 1.;
            }
#line 902
            dtheta = acos(dp);
#line 903
            target = hol * dtheta + (1. - hol) * bp->target;
#line 904
            sdth = sin(dtheta);
#line 904
            if (sdth < 1.e-3) {
#line 904
              sdth = 1.e-3;
            }
#line 905
            r11 = r1 * sdth;
#line 905
            r22 = r2 * sdth;
#line 906
            ux1 = x2 / r2 - (dp * x1) / r1;
#line 907
            uy1 = y2 / r2 - (dp * y1___0) / r1;
#line 908
            uz1 = z2 / r2 - (dp * z1) / r1;
#line 909
            ux2 = x1 / r1 - (dp * x2) / r2;
#line 910
            uy2 = y1___0 / r1 - (dp * y2) / r2;
#line 911
            uz2 = z1 / r1 - (dp * z2) / r2;
#line 912
            dtheta = ((- 2. * k) * (target - dtheta)) * (1. - hol);
#line 913
            ux1 = (ux1 * dtheta) / r11;
#line 914
            uy1 = (uy1 * dtheta) / r11;
#line 915
            uz1 = (uz1 * dtheta) / r11;
#line 916
            ux2 = (ux2 * dtheta) / r22;
#line 917
            uy2 = (uy2 * dtheta) / r22;
#line 918
            uz2 = (uz2 * dtheta) / r22;
#line 919
            if (a1->active) {
#line 921
              a1->fx += ux1;
#line 922
              a1->fy += uy1;
#line 923
              a1->fz += uz1;
            }
#line 925
            if (a2->active) {
#line 927
              a2->fx += - ux1 - ux2;
#line 928
              a2->fy += - uy1 - uy2;
#line 929
              a2->fz += - uz1 - uz2;
            }
#line 931
            if (a3->active) {
#line 933
              a3->fx += ux2;
#line 934
              a3->fy += uy2;
#line 935
              a3->fz += uz2;
            }
          }
        }
      }
    }
    SKIP: 
#line 940
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 940
      return (1);
    }
#line 941
    bp = (ANGLE *)bp->next;
  }
}
}
#line 952
double randg(void) ;
#line 954
ATOM *a_next(int flag ) ;
#line 949 "188.c"
int v_maxwell(double T , double dx , double dy , double dz ) 
{ ATOM *ap ;
  ATOM *bonded[10] ;
  int iflag ;
  int inbond ;
  double vmag ;
  double R ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;

  {
#line 958
  R = 1.987;
#line 959
  iflag = -1;
#line 960
  while (1) {
#line 960
    tmp___1 = iflag;
#line 960
    iflag ++;
#line 960
    ap = a_next(tmp___1);
#line 960
    if (! ((unsigned int )ap != (unsigned int )((void *)0))) {
#line 960
      break;
    }
#line 962
    iflag = 1;
#line 963
    if (ap->mass > 0.) {
#line 965
      tmp = sqrt(((((3. * R) * T) / ap->mass) * 4.184) * 1000.);
#line 965
      tmp___0 = randg();
#line 965
      vmag = tmp * tmp___0;
#line 966
      rand3(& ap->vx, & ap->vy, & ap->vz);
#line 967
      if (ap->active) {
#line 968
        ap->vx = ap->vx * vmag + dx;
#line 969
        ap->vy = ap->vy * vmag + dy;
#line 970
        ap->vz = ap->vz * vmag + dz;
      } else {
#line 972
        ap->vx = 0.;
#line 973
        ap->vy = 0.;
#line 974
        ap->vz = 0.;
      }
    }
  }
#line 978
  iflag = -1;
#line 979
  while (1) {
#line 979
    ap = a_next(iflag);
#line 979
    if (! ((unsigned int )ap != (unsigned int )((void *)0))) {
#line 979
      break;
    }
#line 981
    iflag = 1;
#line 982
    if (ap->mass <= 0.) {
#line 984
      get_bond(ap, bonded, 10, & inbond);
#line 985
      if (inbond >= 0) {
#line 987
        ap->vx = (bonded[0])->vx;
#line 988
        ap->vy = (bonded[0])->vy;
#line 989
        ap->vz = (bonded[0])->vz;
      }
    }
  }
#line 993
  return (1);
}
}
#line 999
int a_number(void) ;
#line 995 "188.c"
int v_rescale(double T ) 
{ ATOM *ap ;
  int iflag ;
  double vmag ;
  double KE ;
  double target ;
  double R ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1002
  R = 1.987;
#line 1003
  target = 0.;
#line 1004
  tmp = a_number();
#line 1004
  target += (((.5 * ((3. * R) * T)) * 4.184) * (double )1000) * (double )tmp;
#line 1005
  KE = 0.;
#line 1006
  iflag = -1;
#line 1007
  while (1) {
#line 1007
    tmp___0 = iflag;
#line 1007
    iflag ++;
#line 1007
    ap = a_next(tmp___0);
#line 1007
    if (! ((unsigned int )ap != (unsigned int )((void *)0))) {
#line 1007
      break;
    }
#line 1009
    iflag = 1;
#line 1010
    if (ap->mass > 0.) {
#line 1012
      vmag = (ap->vx * ap->vx + ap->vy * ap->vy) + ap->vz * ap->vz;
#line 1013
      KE += ap->mass * vmag;
    }
  }
#line 1015
  KE *= .5;
#line 1016
  if (KE == 0.) {
#line 1017
    aaerror((char *)" Cannot rescale a zero velocity field -use v_maxwell");
#line 1018
    return (0);
  }
#line 1020
  vmag = sqrt(target / KE);
#line 1021
  iflag = -1;
#line 1022
  while (1) {
#line 1022
    tmp___1 = iflag;
#line 1022
    iflag ++;
#line 1022
    ap = a_next(tmp___1);
#line 1022
    if (! ((unsigned int )ap != (unsigned int )((void *)0))) {
#line 1022
      break;
    }
#line 1024
    iflag = 1;
#line 1025
    ap->vx *= vmag;
#line 1026
    ap->vy *= vmag;
#line 1027
    ap->vz *= vmag;
  }
#line 1029
  return (1);
}
}
#line 1038
int a_f_zero(void) ;
#line 1038
int a_inc_v(double lambda ) ;
#line 1031 "188.c"
int verlet(int (**forces)() , int nforces , int nstep , double dtime ) 
{ ATOM *bp ;
  ATOM *ap ;
  ATOM *bonded[10] ;
  int inbond ;
  int istep ;
  int iforces ;
  int i ;
  int imax ;

  {
#line 1041
  istep = (int )0.;
#line 1041
  while (istep < nstep) {
#line 1043
    a_f_zero();
#line 1044
    iforces = 0;
#line 1044
    while (iforces < nforces) {
#line 1045
    //  //(*(*(ffs___0 + ifs)))(0.);
#line 1044
      iforces ++;
    }
#line 1046
    imax = a_number();
#line 1047
    ap = a_next(-1);
#line 1048
    bp = ap;
#line 1049
    i = 0;
#line 1049
    while (i < imax) {
#line 1051
      bp = a_next(1);
#line 1052
      if (ap->mass > 0.) {
#line 1054
        ap->vx += ((ap->fx / ap->mass) * dtime) * 4.184e6;
#line 1055
        ap->vy += ((ap->fy / ap->mass) * dtime) * 4.184e6;
#line 1056
        ap->vz += ((ap->fz / ap->mass) * dtime) * 4.184e6;
      }
#line 1049
      i ++;
#line 1049
      ap = bp;
    }
#line 1059
    imax = a_number();
#line 1060
    ap = a_next(-1);
#line 1061
    bp = ap;
#line 1062
    i = 0;
#line 1062
    while (i < imax) {
#line 1064
      bp = a_next(1);
#line 1065
      if (ap->mass <= 0.) {
#line 1067
        get_bond(ap, bonded, 10, & inbond);
#line 1068
        if (inbond >= 0) {
#line 1070
          ap->vx = (bonded[0])->vx;
#line 1071
          ap->vy = (bonded[0])->vy;
#line 1072
          ap->vz = (bonded[0])->vz;
        }
      }
#line 1062
      i ++;
#line 1062
      ap = bp;
    }
#line 1076
    a_inc_v(dtime);
#line 1041
    istep ++;
  }
#line 1078
  return (1);
}
}
#line 1080 "188.c"
int pac(int (**forces)() , int nforces , int nstep , double dtime ) 
{ ATOM *ap ;
  ATOM *bp ;
  ATOM *bonded[10] ;
  int inbond ;
  int iflag ;
  int istep ;
  int iforces ;
  int i ;
  int imax ;

  {
#line 1090
  istep = (int )0.;
#line 1090
  while (istep < nstep) {
#line 1092
    imax = a_number();
#line 1093
    ap = a_next(-1);
#line 1094
    bp = ap;
#line 1095
    i = 0;
#line 1095
    while (i < imax) {
#line 1097
      bp = a_next(1);
#line 1098
      ap->dx = ap->vx;
#line 1099
      ap->dy = ap->vy;
#line 1100
      ap->dz = ap->vz;
#line 1095
      i ++;
#line 1095
      ap = bp;
    }
#line 1102
    a_f_zero();
#line 1103
    iforces = 0;
#line 1103
    while (iforces < nforces) {
#line 1104
      //(*(*(ffs___0 + ifs)))(dtime / 2.);
#line 1103
      iforces ++;
    }
#line 1105
    imax = a_number();
#line 1106
    ap = a_next(-1);
#line 1107
    bp = ap;
#line 1108
    i = 0;
#line 1108
    while (i < imax) {
#line 1110
      bp = a_next(1);
#line 1111
      if (ap->mass > 0.) {
#line 1113
        ap->vx = ap->dx + ((ap->fx / ap->mass) * dtime) * 4.184e6;
#line 1114
        ap->vy = ap->dy + ((ap->fy / ap->mass) * dtime) * 4.184e6;
#line 1115
        ap->vz = ap->dz + ((ap->fz / ap->mass) * dtime) * 4.184e6;
      }
#line 1108
      i ++;
#line 1108
      ap = bp;
    }
#line 1118
    imax = a_number();
#line 1119
    ap = a_next(-1);
#line 1120
    bp = ap;
#line 1121
    i = 0;
#line 1121
    while (i < imax) {
#line 1123
      bp = a_next(1);
#line 1124
      if (ap->mass <= 0.) {
#line 1126
        get_bond(ap, bonded, 10, & inbond);
#line 1127
        if (inbond >= 0) {
#line 1129
          ap->vx = (bonded[0])->vx;
#line 1130
          ap->vy = (bonded[0])->vy;
#line 1131
          ap->vz = (bonded[0])->vz;
        }
      }
#line 1121
      i ++;
#line 1121
      ap = bp;
    }
#line 1135
    imax = a_number();
#line 1136
    ap = a_next(-1);
#line 1137
    bp = ap;
#line 1138
    i = 0;
#line 1138
    while (i < imax) {
#line 1140
      bp = a_next(1);
#line 1141
      iflag = 1;
#line 1142
      ap->x += (.5 * (ap->vx + ap->dx)) * dtime;
#line 1143
      ap->y += (.5 * (ap->vy + ap->dy)) * dtime;
#line 1144
      ap->z += (.5 * (ap->vz + ap->dz)) * dtime;
#line 1138
      i ++;
#line 1138
      ap = bp;
    }
#line 1090
    istep ++;
  }
#line 1148
  return (1);
}
}
#line 1150 "188.c"
int tpac(int (**forces)() , int nforces , int nstep , double dtime_real , double T ) 
{ ATOM *ap ;
  ATOM *bp ;
  ATOM *bonded[10] ;
  double ke ;
  double Tke ;
  double R ;
  double dtime ;
  int inbond ;
  int iflag ;
  int istep ;
  int iforces ;
  int i ;
  int imax ;

  {
#line 1163
  R = 1.987;
#line 1164
  istep = (int )0.;
#line 1164
  while (istep < nstep) {
#line 1166
    ke = 0.;
#line 1167
    imax = a_number();
#line 1168
    ap = a_next(-1);
#line 1169
    bp = ap;
#line 1170
    i = 0;
#line 1170
    while (i < imax) {
#line 1172
      bp = a_next(1);
#line 1173
      ke += ap->mass * ((ap->vx * ap->vx + ap->vy * ap->vy) + ap->vz * ap->vz);
#line 1175
      ap->dx = ap->vx;
#line 1176
      ap->dy = ap->vy;
#line 1177
      ap->dz = ap->vz;
#line 1170
      i ++;
#line 1170
      ap = bp;
    }
#line 1179
    Tke = (((double )(3 * imax) * R) * 4.184) * (double )1000;
#line 1180
    Tke = ke / Tke;
#line 1181
    dtime = dtime_real;
#line 1182
    if (Tke > 1.e-6) {
#line 1184
      ke = sqrt(T / Tke);
#line 1185
      dtime = dtime_real / ke;
#line 1186
      if (dtime > 0.000020) {
#line 1187
     //   tpac(forces, nforces, 1, dtime_real * 0.5, T);
#line 1188
     //   tpac(forces, nforces, 1, dtime_real * 0.5, T);
        goto SKIP;
      }
#line 1191
      ap = a_next(-1);
#line 1192
      bp = ap;
#line 1193
      i = 0;
#line 1193
      while (i < imax) {
#line 1195
        bp = a_next(1);
#line 1196
        ap->dx *= ke;
#line 1197
        ap->dy *= ke;
#line 1198
        ap->dz *= ke;
#line 1193
        i ++;
#line 1193
        ap = bp;
      }
    }
#line 1201
    a_f_zero();
#line 1202
    iforces = 0;
#line 1202
    while (iforces < nforces) {
#line 1203
      //(*(*(ffs___0 + ifs)))(dtime / 2.);
#line 1202
      iforces ++;
    }
#line 1204
    imax = a_number();
#line 1205
    ap = a_next(-1);
#line 1206
    bp = ap;
#line 1207
    i = 0;
#line 1207
    while (i < imax) {
#line 1209
      bp = a_next(1);
#line 1210
      if (ap->mass > 0.) {
#line 1212
        ap->vx = ap->dx + ((ap->fx / ap->mass) * dtime) * 4.184e6;
#line 1213
        ap->vy = ap->dy + ((ap->fy / ap->mass) * dtime) * 4.184e6;
#line 1214
        ap->vz = ap->dz + ((ap->fz / ap->mass) * dtime) * 4.184e6;
      }
#line 1207
      i ++;
#line 1207
      ap = bp;
    }
#line 1217
    imax = a_number();
#line 1218
    ap = a_next(-1);
#line 1219
    bp = ap;
#line 1220
    i = 0;
#line 1220
    while (i < imax) {
#line 1222
      bp = a_next(1);
#line 1223
      if (ap->mass <= 0.) {
#line 1225
        get_bond(ap, bonded, 10, & inbond);
#line 1226
        if (inbond >= 0) {
#line 1228
          ap->vx = (bonded[0])->vx;
#line 1229
          ap->vy = (bonded[0])->vy;
#line 1230
          ap->vz = (bonded[0])->vz;
        }
      }
#line 1220
      i ++;
#line 1220
      ap = bp;
    }
#line 1234
    imax = a_number();
#line 1235
    ap = a_next(-1);
#line 1236
    bp = ap;
#line 1237
    i = 0;
#line 1237
    while (i < imax) {
#line 1239
      bp = a_next(1);
#line 1240
      iflag = 1;
#line 1241
      ap->x += (.5 * (ap->vx + ap->dx)) * dtime;
#line 1242
      ap->y += (.5 * (ap->vy + ap->dy)) * dtime;
#line 1243
      ap->z += (.5 * (ap->vz + ap->dz)) * dtime;
#line 1237
      i ++;
#line 1237
      ap = bp;
    }
    SKIP: 
#line 1164
    istep ++;
  }
#line 1248
  return (1);
}
}
#line 1250 "188.c"
int pacpac(int (**forces)() , int nforces , int nstep , double dtime ) 
{ ATOM *ap ;
  ATOM *bp ;
  ATOM *bonded[10] ;
  int inbond ;
  int iflag ;
  int istep ;
  int iforces ;
  int icorrect ;
  int i ;
  int imax ;

  {
#line 1260
  istep = (int )0.;
#line 1260
  while (istep < nstep) {
#line 1262
    iflag = -1;
#line 1263
    while (1) {
#line 1263
      ap = a_next(iflag);
#line 1263
      if (! ((unsigned int )ap != (unsigned int )((void *)0))) {
#line 1263
        break;
      }
#line 1265
      iflag = 1;
#line 1266
      ap->dx = ap->vx;
#line 1267
      ap->dy = ap->vy;
#line 1268
      ap->dz = ap->vz;
    }
#line 1270
    a_f_zero();
#line 1271
    iforces = 0;
#line 1271
    while (iforces < nforces) {
#line 1272
      //(*(*(ffs___0 + ifs)))(dtime / 2.);
#line 1271
      iforces ++;
    }
#line 1273
    iflag = -1;
#line 1274
    while (1) {
#line 1274
      ap = a_next(iflag);
#line 1274
      if (! ((unsigned int )ap != (unsigned int )((void *)0))) {
#line 1274
        break;
      }
#line 1276
      iflag = 1;
#line 1277
      if (ap->mass > 0.) {
#line 1279
        ap->gx = ap->vx;
#line 1280
        ap->gy = ap->vy;
#line 1281
        ap->gz = ap->vz;
#line 1282
        ap->vx += ((ap->fx / ap->mass) * dtime) * 4.184e6;
#line 1283
        ap->vy += ((ap->fy / ap->mass) * dtime) * 4.184e6;
#line 1284
        ap->vz += ((ap->fz / ap->mass) * dtime) * 4.184e6;
      }
    }
#line 1287
    iflag = -1;
#line 1288
    while (1) {
#line 1288
      ap = a_next(iflag);
#line 1288
      if (! ((unsigned int )ap != (unsigned int )((void *)0))) {
#line 1288
        break;
      }
#line 1290
      iflag = 1;
#line 1291
      if (ap->mass <= 0.) {
#line 1293
        ap->gx = ap->vx;
#line 1294
        ap->gy = ap->vy;
#line 1295
        ap->gz = ap->vz;
#line 1296
        get_bond(ap, bonded, 10, & inbond);
#line 1297
        if (inbond >= 0) {
#line 1299
          ap->vx = (bonded[0])->vx;
#line 1300
          ap->vy = (bonded[0])->vy;
#line 1301
          ap->vz = (bonded[0])->vz;
        }
      }
    }
#line 1305
    imax = a_number();
#line 1306
    ap = a_next(-1);
#line 1307
    bp = ap;
#line 1308
    i = 0;
#line 1308
    while (i < imax) {
#line 1310
      bp = a_next(1);
#line 1311
      ap->dx = ap->vx + ap->gx;
#line 1312
      ap->dy = ap->vy + ap->gy;
#line 1313
      ap->dz = ap->vz + ap->gz;
#line 1308
      i ++;
#line 1308
      ap = bp;
    }
#line 1315
    icorrect = 0;
#line 1315
    while (icorrect < 2) {
#line 1317
      a_f_zero();
#line 1318
      iforces = 0;
#line 1318
      while (iforces < nforces) {
#line 1319
        //(*(*(ffs___0 + ifs)))(dtime / 4.);
#line 1318
        iforces ++;
      }
#line 1320
      imax = a_number();
#line 1321
      ap = a_next(-1);
#line 1322
      bp = ap;
#line 1323
      i = 0;
#line 1323
      while (i < imax) {
#line 1325
        bp = a_next(1);
#line 1326
        if (ap->mass > 0.) {
#line 1328
          ap->vx = ap->gx + ((ap->fx / ap->mass) * dtime) * 4.184e6;
#line 1329
          ap->vy = ap->gy + ((ap->fy / ap->mass) * dtime) * 4.184e6;
#line 1330
          ap->vz = ap->gz + ((ap->fz / ap->mass) * dtime) * 4.184e6;
        }
#line 1323
        i ++;
#line 1323
        ap = bp;
      }
#line 1333
      imax = a_number();
#line 1334
      ap = a_next(-1);
#line 1335
      bp = ap;
#line 1336
      i = 0;
#line 1336
      while (i < imax) {
#line 1338
        bp = a_next(1);
#line 1339
        if (ap->mass <= 0.) {
#line 1341
          get_bond(ap, bonded, 10, & inbond);
#line 1342
          if (inbond >= 0) {
#line 1344
            ap->vx = (bonded[0])->vx;
#line 1345
            ap->vy = (bonded[0])->vy;
#line 1346
            ap->vz = (bonded[0])->vz;
          }
        }
#line 1336
        i ++;
#line 1336
        ap = bp;
      }
#line 1350
      imax = a_number();
#line 1351
      ap = a_next(-1);
#line 1352
      bp = ap;
#line 1353
      i = 0;
#line 1353
      while (i < imax) {
#line 1355
        bp = a_next(1);
#line 1356
        ap->dx = ap->vx + ap->gx;
#line 1357
        ap->dy = ap->vy + ap->gy;
#line 1358
        ap->dz = ap->vz + ap->gz;
#line 1353
        i ++;
#line 1353
        ap = bp;
      }
#line 1315
      icorrect ++;
    }
#line 1361
    imax = a_number();
#line 1362
    ap = a_next(-1);
#line 1363
    bp = ap;
#line 1364
    i = 0;
#line 1364
    while (i < imax) {
#line 1366
      bp = a_next(1);
#line 1367
      ap->x += (.5 * (ap->vx + ap->gx)) * dtime;
#line 1368
      ap->y += (.5 * (ap->vy + ap->gy)) * dtime;
#line 1369
      ap->z += (.5 * (ap->vz + ap->gz)) * dtime;
#line 1364
      i ++;
#line 1364
      ap = bp;
    }
#line 1260
    istep ++;
  }
#line 1373
  return (1);
}
}
#line 1428
int a_v_zero(void) ;
#line 1429
int a_d_zero(void) ;
#line 1375 "188.c"
int hpac(int (**forces)() , int (**poten)() , int nforces , int nstep , double dtime_real ,
         double H ) 
{ ATOM *ap ;
  ATOM *bp ;
  ATOM *bonded[10] ;
  double ke ;
  double Tke ;
  double dtime ;
  int inbond ;
  int iflag ;
  int istep ;
  int iforces ;
  int i ;
  int imax ;

  {
#line 1388
  istep = (int )0.;
#line 1388
  while (istep < nstep) {
#line 1390
    ke = 0.;
#line 1391
    imax = a_number();
#line 1392
    ap = a_next(-1);
#line 1393
    bp = ap;
#line 1394
    i = 0;
#line 1394
    while (i < imax) {
#line 1396
      bp = a_next(1);
#line 1397
      ke += ap->mass * ((ap->vx * ap->vx + ap->vy * ap->vy) + ap->vz * ap->vz);
#line 1399
      ap->dx = ap->vx;
#line 1400
      ap->dy = ap->vy;
#line 1401
      ap->dz = ap->vz;
#line 1394
      i ++;
#line 1394
      ap = bp;
    }
#line 1403
    ke = (((ke * .5) / 4.184) / (double )1000) / (double )1000;
#line 1404
    Tke = 0.;
#line 1405
    i = 0;
#line 1405
    while (i < nforces) {
#line 1406
      //(*(*(poten + i)))(& Tke, 0.);
#line 1405
      i ++;
    }
#line 1407
    dtime = dtime_real;
#line 1408
    if (Tke < H) {
#line 1410
      ke = sqrt((H - Tke) / ke);
#line 1411
      dtime = dtime_real / ke;
#line 1412
      if (dtime > 0.000020) {
#line 1413
       // hpac(forces, poten, nforces, 1, dtime_real * 0.5, H);
#line 1414
      //  hpac(forces, poten, nforces, 1, dtime_real * 0.5, H);
        goto SKIP;
      }
#line 1417
      ap = a_next(-1);
#line 1418
      bp = ap;
#line 1419
      i = 0;
#line 1419
      while (i < imax) {
#line 1421
        bp = a_next(1);
#line 1422
        ap->dx *= ke;
#line 1423
        ap->dy *= ke;
#line 1424
        ap->dz *= ke;
#line 1419
        i ++;
#line 1419
        ap = bp;
      }
    } else {
#line 1427
      aaerror((char *)"Warning in Hpac, Potential energy higher than target\n");
#line 1428
      a_v_zero();
#line 1429
      a_d_zero();
    }
#line 1431
    a_f_zero();
#line 1432
    iforces = 0;
#line 1432
    while (iforces < nforces) {
#line 1433
      //(*(*(ffs___0 + ifs)))(dtime / 2.);
#line 1432
      iforces ++;
    }
#line 1434
    imax = a_number();
#line 1435
    ap = a_next(-1);
#line 1436
    bp = ap;
#line 1437
    i = 0;
#line 1437
    while (i < imax) {
#line 1439
      bp = a_next(1);
#line 1440
      if (ap->mass > 0.) {
#line 1442
        ap->vx = ap->dx + ((ap->fx / ap->mass) * dtime) * 4.184e6;
#line 1443
        ap->vy = ap->dy + ((ap->fy / ap->mass) * dtime) * 4.184e6;
#line 1444
        ap->vz = ap->dz + ((ap->fz / ap->mass) * dtime) * 4.184e6;
      }
#line 1437
      i ++;
#line 1437
      ap = bp;
    }
#line 1447
    imax = a_number();
#line 1448
    ap = a_next(-1);
#line 1449
    bp = ap;
#line 1450
    i = 0;
#line 1450
    while (i < imax) {
#line 1452
      bp = a_next(1);
#line 1453
      if (ap->mass <= 0.) {
#line 1455
        get_bond(ap, bonded, 10, & inbond);
#line 1456
        if (inbond >= 0) {
#line 1458
          ap->vx = (bonded[0])->vx;
#line 1459
          ap->vy = (bonded[0])->vy;
#line 1460
          ap->vz = (bonded[0])->vz;
        }
      }
#line 1450
      i ++;
#line 1450
      ap = bp;
    }
#line 1464
    imax = a_number();
#line 1465
    ap = a_next(-1);
#line 1466
    bp = ap;
#line 1467
    i = 0;
#line 1467
    while (i < imax) {
#line 1469
      bp = a_next(1);
#line 1470
      iflag = 1;
#line 1471
      ap->x += (.5 * (ap->vx + ap->dx)) * dtime;
#line 1472
      ap->y += (.5 * (ap->vy + ap->dy)) * dtime;
#line 1473
      ap->z += (.5 * (ap->vz + ap->dz)) * dtime;
#line 1467
      i ++;
#line 1467
      ap = bp;
    }
    SKIP: 
#line 1388
    istep ++;
  }
#line 1478
  return (1);
}
}
#line 1480 "188.c"
int ppac(int (**forces)() , int nforces , int nstep , double dtime_real , double P ) 
{ ATOM *ap ;
  ATOM *bp ;
  ATOM *bonded[10] ;
  double p ;
  double Tp ;
  double R ;
  double dtime ;
  double cx ;
  double cy ;
  double cz ;
  int inbond ;
  int iflag ;
  int istep ;
  int iforces ;
  int i ;
  int imax ;
  double tmp ;

  {
#line 1493
  R = 1.987;
#line 1494
  imax = a_number();
#line 1495
  if (imax <= 0) {
#line 1495
    return (0);
  }
#line 1496
  istep = (int )0.;
#line 1496
  while (istep < nstep) {
#line 1498
    cx = 0.;
#line 1498
    cy = 0.;
#line 1498
    cz = 0.;
#line 1499
    ap = a_next(-1);
#line 1500
    bp = ap;
#line 1501
    i = 0;
#line 1501
    while (i < imax) {
#line 1503
      bp = a_next(1);
#line 1504
      ap->dx = ap->vx;
#line 1505
      ap->dy = ap->vy;
#line 1506
      ap->dz = ap->vz;
#line 1507
      cx += ap->x;
#line 1508
      cy += ap->y;
#line 1509
      cz += ap->z;
#line 1501
      i ++;
#line 1501
      ap = bp;
    }
#line 1511
    cx /= (double )imax;
#line 1512
    cy /= (double )imax;
#line 1513
    cz /= (double )imax;
#line 1514
    p = 0.;
#line 1515
    Tp = 0.;
#line 1516
    ap = a_next(-1);
#line 1517
    bp = ap;
#line 1518
    i = 0;
#line 1518
    while (i < imax) {
#line 1520
      bp = a_next(1);
#line 1521
      p += (ap->vx * ap->vx) * ap->mass;
#line 1522
      p += (ap->vy * ap->vy) * ap->mass;
#line 1523
      p += (ap->vz * ap->vz) * ap->mass;
#line 1524
      Tp += (ap->x - cx) * (ap->x - cx);
#line 1525
      Tp += (ap->y - cy) * (ap->y - cy);
#line 1526
      Tp += (ap->z - cz) * (ap->z - cz);
#line 1518
      i ++;
#line 1518
      ap = bp;
    }
#line 1528
    Tp = sqrt(Tp / (double )imax);
#line 1529
    Tp = (((((double )4 * 3.1415926535897932384626433) / (double )3) * Tp) * Tp) * Tp;
#line 1530
    p = ((p / (double )imax) / Tp) * .5;
#line 1531
    printf("P %f p %f Tp %f\n", P, p, Tp);
#line 1532
    dtime = dtime_real;
#line 1533
    tmp = pow(p / P, 1. / 3.);
#line 1533
    p = (1. + .1 * tmp) / 1.1;
#line 1535
    ap = a_next(-1);
#line 1536
    bp = ap;
#line 1537
    i = 0;
#line 1537
    while (i < imax) {
#line 1539
      bp = a_next(1);
#line 1540
      ap->x *= p;
#line 1541
      ap->y *= p;
#line 1542
      ap->z *= p;
#line 1537
      i ++;
#line 1537
      ap = bp;
    }
#line 1544
    a_f_zero();
#line 1545
    iforces = 0;
#line 1545
    while (iforces < nforces) {
#line 1546
      //(*(*(ffs___0 + ifs)))(dtime / 2.);
#line 1545
      iforces ++;
    }
#line 1547
    imax = a_number();
#line 1548
    ap = a_next(-1);
#line 1549
    bp = ap;
#line 1550
    i = 0;
#line 1550
    while (i < imax) {
#line 1552
      bp = a_next(1);
#line 1553
      if (ap->mass > 0.) {
#line 1555
        ap->vx = ap->dx + ((ap->fx / ap->mass) * dtime) * 4.184e6;
#line 1556
        ap->vy = ap->dy + ((ap->fy / ap->mass) * dtime) * 4.184e6;
#line 1557
        ap->vz = ap->dz + ((ap->fz / ap->mass) * dtime) * 4.184e6;
      }
#line 1550
      i ++;
#line 1550
      ap = bp;
    }
#line 1560
    imax = a_number();
#line 1561
    ap = a_next(-1);
#line 1562
    bp = ap;
#line 1563
    i = 0;
#line 1563
    while (i < imax) {
#line 1565
      bp = a_next(1);
#line 1566
      if (ap->mass <= 0.) {
#line 1568
        get_bond(ap, bonded, 10, & inbond);
#line 1569
        if (inbond >= 0) {
#line 1571
          ap->vx = (bonded[0])->vx;
#line 1572
          ap->vy = (bonded[0])->vy;
#line 1573
          ap->vz = (bonded[0])->vz;
        }
      }
#line 1563
      i ++;
#line 1563
      ap = bp;
    }
#line 1577
    imax = a_number();
#line 1578
    ap = a_next(-1);
#line 1579
    bp = ap;
#line 1580
    i = 0;
#line 1580
    while (i < imax) {
#line 1582
      bp = a_next(1);
#line 1583
      iflag = 1;
#line 1584
      ap->x += (.5 * (ap->vx + ap->dx)) * dtime;
#line 1585
      ap->y += (.5 * (ap->vy + ap->dy)) * dtime;
#line 1586
      ap->z += (.5 * (ap->vz + ap->dz)) * dtime;
#line 1580
      i ++;
#line 1580
      ap = bp;
    }
#line 1496
    istep ++;
  }
#line 1590
  return (1);
}
}
#line 1592 "188.c"
int ptpac(int (**forces)() , int nforces , int nstep , double dtime_real , double P ,
          double T ) 
{ ATOM *ap ;
  ATOM *bp ;
  ATOM *bonded[10] ;
  double p ;
  double Tp ;
  double R ;
  double Tk ;
  double dtime ;
  double cx ;
  double cy ;
  double cz ;
  int inbond ;
  int iflag ;
  int istep ;
  int iforces ;
  int i ;
  int imax ;
  double tmp ;

  {
#line 1606
  R = 1.987;
#line 1607
  imax = a_number();
#line 1608
  if (imax <= 0) {
#line 1608
    return (0);
  }
#line 1609
  istep = (int )0.;
#line 1609
  while (istep < nstep) {
#line 1611
    cx = 0.;
#line 1611
    cy = 0.;
#line 1611
    cz = 0.;
#line 1612
    ap = a_next(-1);
#line 1613
    bp = ap;
#line 1614
    i = 0;
#line 1614
    while (i < imax) {
#line 1616
      bp = a_next(1);
#line 1617
      ap->dx = ap->vx;
#line 1618
      ap->dy = ap->vy;
#line 1619
      ap->dz = ap->vz;
#line 1620
      cx += ap->x;
#line 1621
      cy += ap->y;
#line 1622
      cz += ap->z;
#line 1614
      i ++;
#line 1614
      ap = bp;
    }
#line 1624
    cx /= (double )imax;
#line 1625
    cy /= (double )imax;
#line 1626
    cz /= (double )imax;
#line 1627
    p = 0.;
#line 1628
    Tp = 0.;
#line 1629
    ap = a_next(-1);
#line 1630
    bp = ap;
#line 1631
    i = 0;
#line 1631
    while (i < imax) {
#line 1633
      bp = a_next(1);
#line 1634
      p += (ap->vx * ap->vx) * ap->mass;
#line 1635
      p += (ap->vy * ap->vy) * ap->mass;
#line 1636
      p += (ap->vz * ap->vz) * ap->mass;
#line 1637
      Tp += (ap->x - cx) * (ap->x - cx);
#line 1638
      Tp += (ap->y - cy) * (ap->y - cy);
#line 1639
      Tp += (ap->z - cz) * (ap->z - cz);
#line 1631
      i ++;
#line 1631
      ap = bp;
    }
#line 1641
    Tp = sqrt(Tp / (double )imax);
#line 1642
    Tp = (((((double )4 * 3.1415926535897932384626433) / (double )3) * Tp) * Tp) * Tp;
#line 1643
    Tk = (((double )(3 * imax) * R) * 4.184) * (double )1000;
#line 1644
    Tk = p / Tk;
#line 1645
    if (Tk < 1.e-5) {
#line 1645
      Tk = 1.;
    }
#line 1646
    p = ((p / (double )imax) / Tp) * .5;
#line 1647
    printf("P %f p %f Tp %f\n", P, p, Tp);
#line 1648
    Tk = sqrt(T / Tk);
#line 1649
    dtime = dtime_real / Tk;
#line 1650
    if (dtime > 0.000020) {
#line 1651
     // ptpac(forces, nforces, 1, dtime_real * 0.5, P, T);
#line 1652
    //  ptpac(forces, nforces, 1, dtime_real * 0.5, P, T);
      goto SKIP;
    }
#line 1655
    tmp = pow(p / P, 1. / 3.);
#line 1655
    p = (1. + .1 * tmp) / 1.1;
#line 1657
    ap = a_next(-1);
#line 1658
    bp = ap;
#line 1659
    i = 0;
#line 1659
    while (i < imax) {
#line 1661
      bp = a_next(1);
#line 1662
      ap->vx *= Tk;
#line 1663
      ap->vy *= Tk;
#line 1664
      ap->vz *= Tk;
#line 1665
      ap->dx *= Tk;
#line 1666
      ap->dy *= Tk;
#line 1667
      ap->dz *= Tk;
#line 1668
      ap->x *= p;
#line 1669
      ap->y *= p;
#line 1670
      ap->z *= p;
#line 1659
      i ++;
#line 1659
      ap = bp;
    }
#line 1672
    a_f_zero();
#line 1673
    iforces = 0;
#line 1673
    while (iforces < nforces) {
#line 1674
      //(*(*(ffs___0 + ifs)))(dtime / 2.);
#line 1673
      iforces ++;
    }
#line 1675
    imax = a_number();
#line 1676
    ap = a_next(-1);
#line 1677
    bp = ap;
#line 1678
    i = 0;
#line 1678
    while (i < imax) {
#line 1680
      bp = a_next(1);
#line 1681
      if (ap->mass > 0.) {
#line 1683
        ap->vx = ap->dx + ((ap->fx / ap->mass) * dtime) * 4.184e6;
#line 1684
        ap->vy = ap->dy + ((ap->fy / ap->mass) * dtime) * 4.184e6;
#line 1685
        ap->vz = ap->dz + ((ap->fz / ap->mass) * dtime) * 4.184e6;
      }
#line 1678
      i ++;
#line 1678
      ap = bp;
    }
#line 1688
    imax = a_number();
#line 1689
    ap = a_next(-1);
#line 1690
    bp = ap;
#line 1691
    i = 0;
#line 1691
    while (i < imax) {
#line 1693
      bp = a_next(1);
#line 1694
      if (ap->mass <= 0.) {
#line 1696
        get_bond(ap, bonded, 10, & inbond);
#line 1697
        if (inbond >= 0) {
#line 1699
          ap->vx = (bonded[0])->vx;
#line 1700
          ap->vy = (bonded[0])->vy;
#line 1701
          ap->vz = (bonded[0])->vz;
        }
      }
#line 1691
      i ++;
#line 1691
      ap = bp;
    }
#line 1705
    imax = a_number();
#line 1706
    ap = a_next(-1);
#line 1707
    bp = ap;
#line 1708
    i = 0;
#line 1708
    while (i < imax) {
#line 1710
      bp = a_next(1);
#line 1711
      iflag = 1;
#line 1712
      ap->x += (.5 * (ap->vx + ap->dx)) * dtime;
#line 1713
      ap->y += (.5 * (ap->vy + ap->dy)) * dtime;
#line 1714
      ap->z += (.5 * (ap->vz + ap->dz)) * dtime;
#line 1708
      i ++;
#line 1708
      ap = bp;
    }
    SKIP: 
#line 1609
    istep ++;
  }
#line 1719
  return (1);
}
}
#line 1726 "188.c"
int a_nonbon(double *V , double lambda , int ilow , int ihigh , FILE *op ) 
{ double r ;
  double r0 ;
  double xt ;
  double yt ;
  double zt ;
  double lcutoff ;
  double cutoff ;
  int i ;
  int ii ;
  ATOM *a1 ;
  ATOM *a2 ;
  double dielectric ;
  double ve ;
  double va ;
  double vh ;
  double vel ;
  double val ;
  double vhl ;
  double vtint ;
  double vtout ;
  double vtt ;

  {
#line 1740
  dielectric = get_f_variable("dielec");
#line 1741
  if (dielectric < 1.) {
#line 1741
    dielectric = 1.;
  }
#line 1742
  dielectric = 332.17752 / dielectric;
#line 1743
  cutoff = get_f_variable("cutoff");
#line 1744
  if (cutoff < 1.) {
#line 1744
    cutoff = 1.e10;
  }
#line 1745
  lcutoff = - cutoff;
#line 1746
  vtint = 0.;
#line 1746
  vtout = 0.;
#line 1746
  vtt = 0.;
#line 1747
  ii = ilow;
#line 1747
  while (ii <= ihigh) {
#line 1749
    a1 = a_m_serial(ii);
#line 1750
    if ((unsigned int )a1 == (unsigned int )((void *)0)) {
      goto NOTANATOM;
    }
#line 1751
    ve = 0.;
#line 1751
    va = 0.;
#line 1751
    vh = 0.;
#line 1752
    vel = 0.;
#line 1752
    val = 0.;
#line 1752
    vhl = 0.;
#line 1753
    a2 = a_next(-1);
#line 1754
    while ((unsigned int )a2->next != (unsigned int )((void *)0)) {
#line 1756
      i = 0;
#line 1756
      while (i < a1->dontuse) {
#line 1757
        if ((unsigned int )a2 == (unsigned int )a1->excluded[i]) {
          goto SKIP;
        }
#line 1756
        i ++;
      }
#line 1758
      if (lambda == 0.) {
#line 1760
        xt = a1->x - a2->x;
#line 1761
        if (xt > cutoff) {
          goto SKIP;
        } else {
#line 1761
          if (xt < lcutoff) {
            goto SKIP;
          }
        }
#line 1762
        yt = a1->y - a2->y;
#line 1763
        if (yt > cutoff) {
          goto SKIP;
        } else {
#line 1763
          if (yt < lcutoff) {
            goto SKIP;
          }
        }
#line 1764
        zt = a1->z - a2->z;
#line 1765
        if (zt > cutoff) {
          goto SKIP;
        } else {
#line 1765
          if (zt < lcutoff) {
            goto SKIP;
          }
        }
      } else {
#line 1768
        xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 1769
        if (xt > cutoff) {
          goto SKIP;
        } else {
#line 1769
          if (xt < lcutoff) {
            goto SKIP;
          }
        }
#line 1770
        yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 1771
        if (yt > cutoff) {
          goto SKIP;
        } else {
#line 1771
          if (yt < lcutoff) {
            goto SKIP;
          }
        }
#line 1772
        zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 1773
        if (zt > cutoff) {
          goto SKIP;
        } else {
#line 1773
          if (zt < lcutoff) {
            goto SKIP;
          }
        }
      }
#line 1775
      r = (xt * xt + yt * yt) + zt * zt;
#line 1776
      r0 = sqrt(r);
#line 1776
      r = (r * r) * r;
#line 1777
      ve += ((dielectric * a1->q) * a2->q) / r0;
#line 1778
      va -= (a1->a * a2->a) / r;
#line 1779
      vh += ((a1->b * a2->b) / r) / r;
#line 1780
      if (a2->serial < ilow) {
#line 1782
        vel += ((dielectric * a1->q) * a2->q) / r0;
#line 1783
        val -= (a1->a * a2->a) / r;
#line 1784
        vhl += ((a1->b * a2->b) / r) / r;
      } else {
#line 1780
        if (a2->serial > ihigh) {
#line 1782
          vel += ((dielectric * a1->q) * a2->q) / r0;
#line 1783
          val -= (a1->a * a2->a) / r;
#line 1784
          vhl += ((a1->b * a2->b) / r) / r;
        }
      }
      SKIP: 
#line 1787
      if ((unsigned int )a2->next == (unsigned int )a2) {
#line 1787
        break;
      }
#line 1788
      a2 = (ATOM *)a2->next;
    }
#line 1790
    fprintf(op, "Vnonbon internal %s %d Eq %f E6 %f E12 %f\n", a1->name, ii, ve - vel,
            va - val, vh - vhl);
#line 1792
    fprintf(op, "Vnonbon external %s %d Eq %f E6 %f E12 %f\n", a1->name, ii, vel,
            val, vhl);
#line 1794
    fprintf(op, "Vnonbon total    %s %d Eq %f E6 %f E12 %f\n", a1->name, ii, ve, va,
            vh);
#line 1796
    *V += (ve + va) + vh;
#line 1797
    vtint += ((((ve - vel) + va) - val) + vh) - vhl;
#line 1798
    vtout += (vel + val) + vhl;
#line 1799
    vtt += (ve + va) + vh;
    NOTANATOM: 
#line 1801
    i = i;
#line 1747
    ii ++;
  }
#line 1803
  fprintf(op, " Vnonbon total internal %f \n", vtint);
#line 1804
  fprintf(op, " Vnonbon total external %f \n", vtout);
#line 1805
  fprintf(op, " Vnonbon total          %f \n", vtt);
#line 1806
  return (1);
}
}
#line 1814 "188.c"
ATOM *first  =    (ATOM *)((void *)0);
#line 1815 "188.c"
ATOM *last  =    (ATOM *)((void *)0);
#line 1816 "188.c"
static int atomNUMBER  =    0;
#line 1816 "188.c"
static int atomUPDATE  =    0;
#line 1823
int atom(double x , double y , double z , int serial , double q , double a , double b ,
         double mass , char *name ) ;
#line 1823 "188.c"
static int highest  =    -1;
#line 1823
int atom(double x , double y , double z , int serial , double q , double a , double b ,
         double mass , char *name ) ;
#line 1823 "188.c"
static int lowest  =    -1;
#line 1817 "188.c"
int atom(double x , double y , double z , int serial , double q , double a , double b ,
         double mass , char *name ) 
{ int i ;
  ATOM *new ;
  void *tmp ;

  {
#line 1826
  new = (ATOM *)((void *)0);
#line 1827
  if (highest >= serial) {
#line 1827
    if (lowest <= serial) {
#line 1827
      new = a_m_serial(serial);
    }
  }
#line 1828
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 1830
    tmp = malloc(sizeof(ATOM ));
#line 1830
    new = (ATOM *)tmp;
#line 1830
    if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 1832
      return (0);
    }
#line 1834
    new->dontuse = 0;
#line 1835
    new->dontuse = 1;
#line 1836
    new->excluded[0] = (void *)new;
#line 1837
    new->active = (char)1;
#line 1838
    i = 0;
#line 1838
    while (i < 32) {
#line 1839
      new->exkind[i] = (char)0;
#line 1838
      i ++;
    }
#line 1840
    new->next = (void *)0;
  }
#line 1843
  if ((unsigned int )first == (unsigned int )((void *)0)) {
#line 1843
    first = new;
#line 1844
    highest = serial;
#line 1844
    lowest = serial;
  }
#line 1845
  if ((unsigned int )last == (unsigned int )((void *)0)) {
#line 1845
    last = new;
  }
#line 1846
  new->x = x;
#line 1847
  new->y = y;
#line 1848
  new->z = z;
#line 1849
  new->fx = 0.;
#line 1850
  new->fy = 0.;
#line 1851
  new->fz = 0.;
#line 1852
  new->dx = 0.;
#line 1853
  new->dy = 0.;
#line 1854
  new->dz = 0.;
#line 1855
  new->vx = 0.;
#line 1856
  new->vy = 0.;
#line 1857
  new->vz = 0.;
#line 1858
  new->jaa = (double )-1;
#line 1858
  new->chi = (double )-1;
#line 1859
  new->px = 10e10;
#line 1860
  new->py = 10e10;
#line 1861
  new->pz = 10e10;
#line 1862
  new->q = q;
#line 1863
  new->a = a;
#line 1864
  new->b = b;
#line 1865
  new->serial = serial;
#line 1866
  new->mass = mass;
#line 1867
  i = 0;
#line 1867
  while (i < 8) {
#line 1869
    new->name[i] = *name;
#line 1870
    new->name[i + 1] = (char )'\000';
#line 1871
    if ((int )*name == 0) {
#line 1871
      break;
    }
#line 1872
    name ++;
#line 1867
    i ++;
  }
#line 1874
  if ((unsigned int )new->next == (unsigned int )((void *)0)) {
#line 1876
    new->next = (void *)new;
#line 1877
    last->next = (void *)new;
#line 1878
    last = new;
  }
#line 1880
  atomUPDATE = 1;
#line 1881
  if (highest < serial) {
#line 1881
    highest = serial;
  }
#line 1882
  if (lowest > serial) {
#line 1882
    lowest = serial;
  }
#line 1883
  return (1);
}
}
#line 1885 "188.c"
int a_number(void) 
{ ATOM *ap ;

  {
#line 1888
  if (atomUPDATE) {
#line 1890
    atomUPDATE = 0;
#line 1891
    atomNUMBER = 0;
#line 1892
    if ((unsigned int )first == (unsigned int )((void *)0)) {
#line 1892
      return (0);
    }
#line 1893
    ap = first;
#line 1894
    while (! ((unsigned int )ap->next == (unsigned int )((void *)0))) {
#line 1897
      atomNUMBER ++;
#line 1898
      if ((unsigned int )ap->next == (unsigned int )ap) {
#line 1898
        break;
      }
#line 1899
      ap = (ATOM *)ap->next;
    }
  }
#line 1902
  return (atomNUMBER);
}
}
#line 1907
ATOM *a_m_serial(int serial ) ;
#line 1907 "188.c"
static ATOM *ap  =    (ATOM *)((void *)0);
#line 1908
ATOM *a_m_serial(int serial ) ;
#line 1908 "188.c"
static ATOM *lastmatched  =    (ATOM *)((void *)0);
#line 1904 "188.c"
ATOM *a_m_serial(int serial ) 
{ int i ;
  int n ;

  {
#line 1910
  if (atomUPDATE) {
#line 1910
    n = a_number();
  } else {
#line 1911
    n = atomNUMBER;
  }
#line 1912
  ap = first;
#line 1913
  if ((unsigned int )ap == (unsigned int )((void *)0)) {
#line 1913
    return ((ATOM *)((void *)0));
  }
#line 1914
  if ((unsigned int )lastmatched == (unsigned int )((void *)0)) {
#line 1914
    lastmatched = first;
  }
#line 1916
  if (serial == lastmatched->serial) {
#line 1916
    return (lastmatched);
  }
#line 1917
  if (serial > lastmatched->serial) {
#line 1917
    ap = lastmatched;
  }
#line 1918
  i = 0;
#line 1918
  while (i < n) {
#line 1920
    if (ap->serial == serial) {
#line 1920
      lastmatched = ap;
#line 1920
      return (ap);
    }
#line 1921
    if ((unsigned int )ap == (unsigned int )ap->next) {
#line 1921
      ap = first;
    } else {
#line 1922
      ap = (ATOM *)ap->next;
    }
#line 1918
    i ++;
  }
#line 1924
  return ((ATOM *)((void *)0));
}
}
#line 1929
ATOM *a_next(int flag ) ;
#line 1929 "188.c"
static ATOM *ap___0  =    (ATOM *)((void *)0);
#line 1926 "188.c"
ATOM *a_next(int flag ) 
{ 

  {
#line 1930
  if ((unsigned int )ap___0 == (unsigned int )((void *)0)) {
#line 1930
    ap___0 = first;
  }
#line 1931
  if ((unsigned int )ap___0 == (unsigned int )((void *)0)) {
#line 1931
    return ((ATOM *)((void *)0));
  }
#line 1932
  if (flag <= 0) {
#line 1932
    ap___0 = first;
#line 1932
    return (ap___0);
  }
#line 1933
  if ((unsigned int )ap___0 == (unsigned int )ap___0->next) {
#line 1933
    return ((ATOM *)((void *)0));
  }
#line 1934
  ap___0 = (ATOM *)ap___0->next;
#line 1935
  return (ap___0);
}
}
#line 1937 "188.c"
int a_f_zero(void) 
{ ATOM *ap___1 ;

  {
#line 1940
  ap___1 = first;
#line 1941
  while (1) {
#line 1943
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 1943
      return (0);
    }
#line 1944
    ap___1->fx = 0.;
#line 1944
    ap___1->fy = 0.;
#line 1944
    ap___1->fz = 0.;
#line 1945
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 1945
      return (1);
    }
#line 1946
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 1949 "188.c"
int a_d_zero(void) 
{ ATOM *ap___1 ;

  {
#line 1952
  ap___1 = first;
#line 1953
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 1953
    return (0);
  }
#line 1954
  while (1) {
#line 1956
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 1956
      return (0);
    }
#line 1957
    ap___1->dx = 0.;
#line 1957
    ap___1->dy = 0.;
#line 1957
    ap___1->dz = 0.;
#line 1958
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 1958
      return (1);
    }
#line 1959
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 1962 "188.c"
int a_g_zero(void) 
{ ATOM *ap___1 ;

  {
#line 1965
  ap___1 = first;
#line 1966
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 1966
    return (0);
  }
#line 1967
  while (1) {
#line 1969
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 1969
      return (0);
    }
#line 1970
    ap___1->gx = 0.;
#line 1970
    ap___1->gy = 0.;
#line 1970
    ap___1->gz = 0.;
#line 1971
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 1971
      return (1);
    }
#line 1972
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 1975 "188.c"
int a_v_zero(void) 
{ ATOM *ap___1 ;

  {
#line 1978
  ap___1 = first;
#line 1979
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 1979
    return (0);
  }
#line 1980
  while (1) {
#line 1982
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 1982
      return (0);
    }
#line 1983
    ap___1->vx = 0.;
#line 1983
    ap___1->vy = 0.;
#line 1983
    ap___1->vz = 0.;
#line 1984
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 1984
      return (1);
    }
#line 1985
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 1988 "188.c"
int a_inc_f(double lambda ) 
{ ATOM *ap___1 ;

  {
#line 1992
  ap___1 = first;
#line 1993
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 1993
    return (0);
  }
#line 1994
  while (1) {
#line 1996
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 1996
      return (0);
    }
#line 1997
    ap___1->x += ap___1->fx * lambda;
#line 1998
    ap___1->y += ap___1->fy * lambda;
#line 1998
    ap___1->z += ap___1->fz * lambda;
#line 1999
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 1999
      return (1);
    }
#line 2000
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2003 "188.c"
int a_inc_d(double lambda ) 
{ ATOM *ap___1 ;

  {
#line 2006
  ap___1 = first;
#line 2007
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2007
    return (0);
  }
#line 2008
  while (1) {
#line 2010
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2010
      return (0);
    }
#line 2011
    ap___1->x += ap___1->dx * lambda;
#line 2012
    ap___1->y += ap___1->dy * lambda;
#line 2012
    ap___1->z += ap___1->dz * lambda;
#line 2013
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2013
      return (1);
    }
#line 2014
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2017 "188.c"
int a_inc_v(double lambda ) 
{ ATOM *ap___1 ;

  {
#line 2021
  ap___1 = first;
#line 2022
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2022
    return (0);
  }
#line 2023
  while (1) {
#line 2025
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2025
      return (0);
    }
#line 2026
    ap___1->x += ap___1->vx * lambda;
#line 2027
    ap___1->y += ap___1->vy * lambda;
#line 2027
    ap___1->z += ap___1->vz * lambda;
#line 2028
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2028
      return (1);
    }
#line 2029
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2032 "188.c"
int a_ftodx(double lambda , double lamold ) 
{ ATOM *ap___1 ;

  {
#line 2035
  ap___1 = first;
#line 2036
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2036
    return (0);
  }
#line 2037
  while (1) {
#line 2039
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2039
      return (0);
    }
#line 2040
    ap___1->dx = ap___1->dx * lamold + ap___1->fx * lambda;
#line 2041
    ap___1->dy = ap___1->dy * lamold + ap___1->fy * lambda;
#line 2042
    ap___1->dz = ap___1->dz * lamold + ap___1->fz * lambda;
#line 2043
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2043
      return (1);
    }
#line 2044
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2047 "188.c"
int a_ftogx(double lambda , double lamold ) 
{ ATOM *ap___1 ;

  {
#line 2051
  ap___1 = first;
#line 2052
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2052
    return (0);
  }
#line 2053
  while (1) {
#line 2055
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2055
      return (0);
    }
#line 2056
    ap___1->gx = ap___1->gx * lamold + ap___1->fx * lambda;
#line 2057
    ap___1->gy = ap___1->gy * lamold + ap___1->fy * lambda;
#line 2058
    ap___1->gz = ap___1->gz * lamold + ap___1->fz * lambda;
#line 2059
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2059
      return (1);
    }
#line 2060
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2063 "188.c"
int a_ftovx(double lambda , double lamold ) 
{ ATOM *ap___1 ;

  {
#line 2067
  ap___1 = first;
#line 2068
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2068
    return (0);
  }
#line 2069
  while (1) {
#line 2071
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2071
      return (0);
    }
#line 2072
    ap___1->vx = ap___1->vx * lamold + ap___1->fx * lambda;
#line 2073
    ap___1->vy = ap___1->vy * lamold + ap___1->fy * lambda;
#line 2074
    ap___1->vz = ap___1->vz * lamold + ap___1->fz * lambda;
#line 2075
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2075
      return (1);
    }
#line 2076
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2079 "188.c"
double a_max_f(void) 
{ double l2norm ;
  double l2max ;
  ATOM *ap___1 ;

  {
#line 2083
  ap___1 = first;
#line 2084
  l2max = - 1.;
#line 2085
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2085
    return (l2max);
  }
#line 2086
  while (1) {
#line 2088
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2088
      return (l2max);
    }
#line 2089
    l2norm = ap___1->fx * ap___1->fx;
#line 2090
    l2norm += ap___1->fy * ap___1->fy;
#line 2091
    l2norm += ap___1->fz * ap___1->fz;
#line 2092
    if (l2norm > l2max) {
#line 2093
      l2max = l2norm;
    }
#line 2094
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2094
      return (l2max);
    }
#line 2095
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2098 "188.c"
double a_max_d(void) 
{ double l2norm ;
  double l2max ;
  ATOM *ap___1 ;

  {
#line 2102
  ap___1 = first;
#line 2103
  l2max = - 1.;
#line 2104
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2104
    return (l2max);
  }
#line 2105
  while (1) {
#line 2107
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2107
      return (l2max);
    }
#line 2108
    l2norm = ap___1->dx * ap___1->dx;
#line 2109
    l2norm += ap___1->dy * ap___1->dy;
#line 2110
    l2norm += ap___1->dz * ap___1->dz;
#line 2111
    if (l2norm > l2max) {
#line 2112
      l2max = l2norm;
    }
#line 2113
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2113
      return (l2max);
    }
#line 2114
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2117 "188.c"
double a_l2_f(void) 
{ ATOM *ap___1 ;
  double l2 ;

  {
#line 2121
  ap___1 = first;
#line 2122
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2122
    return (0.);
  }
#line 2123
  l2 = 0.;
#line 2124
  while (1) {
#line 2126
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2126
      return (- l2);
    }
#line 2127
    l2 += ap___1->fx * ap___1->fx;
#line 2128
    l2 += ap___1->fy * ap___1->fy;
#line 2129
    l2 += ap___1->fz * ap___1->fz;
#line 2130
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2130
      return (l2);
    }
#line 2131
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2134 "188.c"
double a_l2_g(void) 
{ ATOM *ap___1 ;
  double l2 ;

  {
#line 2138
  ap___1 = first;
#line 2139
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2139
    return (0.);
  }
#line 2140
  l2 = 0.;
#line 2141
  while (1) {
#line 2143
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2143
      return (- l2);
    }
#line 2144
    l2 += ap___1->gx * ap___1->gx;
#line 2145
    l2 += ap___1->gy * ap___1->gy;
#line 2146
    l2 += ap___1->gz * ap___1->gz;
#line 2147
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2147
      return (l2);
    }
#line 2148
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2151 "188.c"
double a_l2_v(void) 
{ ATOM *ap___1 ;
  double l2 ;

  {
#line 2155
  ap___1 = first;
#line 2156
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2156
    return (0.);
  }
#line 2157
  l2 = 0.;
#line 2158
  while (1) {
#line 2160
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2160
      return (- l2);
    }
#line 2161
    l2 += ap___1->vx * ap___1->vx;
#line 2162
    l2 += ap___1->vy * ap___1->vy;
#line 2163
    l2 += ap___1->vz * ap___1->vz;
#line 2164
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2164
      return (l2);
    }
#line 2165
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2168 "188.c"
double a_l2_d(void) 
{ ATOM *ap___1 ;
  double l2 ;

  {
#line 2172
  ap___1 = first;
#line 2173
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2173
    return (0.);
  }
#line 2174
  l2 = 0.;
#line 2175
  while (1) {
#line 2177
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2177
      return (- l2);
    }
#line 2178
    l2 += ap___1->dx * ap___1->dx;
#line 2179
    l2 += ap___1->dy * ap___1->dy;
#line 2180
    l2 += ap___1->dz * ap___1->dz;
#line 2181
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2181
      return (l2);
    }
#line 2182
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2185 "188.c"
void dump_atoms(FILE *where ) 
{ ATOM *a ;

  {
#line 2191
  a = first;
#line 2192
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 2192
    return;
  }
#line 2193
  while ((unsigned int )a->next != (unsigned int )a) {
#line 2195
    if ((unsigned int )a->next == (unsigned int )((void *)0)) {
#line 2195
      return;
    }
#line 2196
    fprintf(where, "atom %f %f %f %d %s %f %f %f %f ;\n", a->x, a->y, a->z, a->serial,
            a->name, a->q, a->a, a->b, a->mass);
#line 2199
    if (a->chi > (double )0) {
#line 2199
      if (a->jaa > (double )0) {
#line 2200
        fprintf(where, "mompar %d %f %f;\n", a->serial, a->chi, a->jaa);
      }
    }
#line 2202
    if (! a->active) {
#line 2202
      fprintf(where, " inactive %d ;\n", a->serial);
    }
#line 2203
    a = (ATOM *)a->next;
  }
#line 2205
  if ((unsigned int )a->next == (unsigned int )((void *)0)) {
#line 2205
    return;
  }
#line 2206
  fprintf(where, "atom %f %f %f %d %s %f %f %f %f ;\n", a->x, a->y, a->z, a->serial,
          a->name, a->q, a->a, a->b, a->mass);
#line 2209
  if (a->chi > (double )0) {
#line 2209
    if (a->jaa > (double )0) {
#line 2210
      fprintf(where, "mompar %d %f %f;\n", a->serial, a->chi, a->jaa);
    }
  }
#line 2212
  if (! a->active) {
#line 2212
    fprintf(where, " inactive %d ;\n", a->serial);
  }
#line 2213
  dump_excludes(where);
#line 2214
  return;
}
}
#line 2219
int get_i_variable(char *name ) ;
#line 2215 "188.c"
void dump_excludes(FILE *where ) 
{ ATOM *a ;
  ATOM *ap___1 ;
  int numatm ;
  int i ;
  int j ;

  {
#line 2222
  numatm = a_number();
#line 2223
  if (numatm <= 0) {
#line 2223
    return;
  }
#line 2224
  i = 0;
#line 2224
  while (i < numatm) {
#line 2226
    a = a_next(i);
#line 2227
    j = 0;
#line 2227
    while (j < a->dontuse) {
#line 2229
      if ((int )a->exkind[j] > 0) {
#line 2230
        ap___1 = (ATOM *)a->excluded[j];
#line 2231
        if (ap___1->serial > a->serial) {
#line 2232
          fprintf(where, " tailor exclude %d %d ;\n", a->serial, ap___1->serial);
        }
      }
#line 2227
      j ++;
    }
#line 2224
    i ++;
  }
#line 2237
  return;
}
}
#line 2238 "188.c"
void dump_velocity(FILE *where ) 
{ ATOM *a ;

  {
#line 2241
  a = first;
#line 2242
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 2242
    return;
  }
#line 2243
  while ((unsigned int )a->next != (unsigned int )a) {
#line 2245
    if ((unsigned int )a->next == (unsigned int )((void *)0)) {
#line 2245
      return;
    }
#line 2246
    fprintf(where, "velocity %d %f %f %f ;\n", a->serial, a->vx, a->vy, a->vz);
#line 2248
    a = (ATOM *)a->next;
  }
#line 2250
  if ((unsigned int )a->next == (unsigned int )((void *)0)) {
#line 2250
    return;
  }
#line 2251
  fprintf(where, "velocity %d %f %f %f ;\n", a->serial, a->vx, a->vy, a->vz);
#line 2253
  return;
}
}
#line 2254 "188.c"
int a_readvelocity(int serial , double vx , double vy , double vz ) 
{ ATOM *ap___1 ;

  {
#line 2259
  ap___1 = a_m_serial(serial);
#line 2260
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2260
    return (0);
  }
#line 2261
  ap___1->vx = vx;
#line 2262
  ap___1->vy = vy;
#line 2263
  ap___1->vz = vz;
#line 2264
  return (1);
}
}
#line 2266 "188.c"
void dump_force(FILE *where ) 
{ ATOM *a ;

  {
#line 2269
  a = first;
#line 2270
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 2270
    return;
  }
#line 2271
  while ((unsigned int )a->next != (unsigned int )a) {
#line 2273
    if ((unsigned int )a->next == (unsigned int )((void *)0)) {
#line 2273
      return;
    }
#line 2274
    fprintf(where, "force %d %f %f %f %f %f %f ;\n", a->serial, a->x, a->y, a->z,
            a->fx, a->fy, a->fz);
#line 2276
    a = (ATOM *)a->next;
  }
#line 2278
  if ((unsigned int )a->next == (unsigned int )((void *)0)) {
#line 2278
    return;
  }
#line 2279
  fprintf(where, "force %d %f %f %f %f %f %f ;\n", a->serial, a->x, a->y, a->z, a->fx,
          a->fy, a->fz);
#line 2281
  return;
}
}
#line 2282 "188.c"
void dump_pdb(FILE *where , int res_mod ) 
{ ATOM *a ;
  char *np ;
  char resid[5] ;
  char atid[5] ;
  int i ;
  int ires ;
  int iatom ;
  int tmp ;
  int __x ;
  int tmp___0 ;
  int __x___0 ;
  int tmp___1 ;
  int __x___1 ;
  int tmp___2 ;
  int __x___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2287
  a = first;
#line 2288
  iatom = 0;
#line 2289
  if ((unsigned int )a == (unsigned int )((void *)0)) {
#line 2289
    return;
  }
#line 2290
  if (res_mod == 0) {
#line 2292
    aaerror((char *)" need a non-zero residue modulus in dump_pdb\n");
#line 2293
    return;
  }
#line 2295
  while ((unsigned int )a->next != (unsigned int )a) {
#line 2297
    if ((unsigned int )a->next == (unsigned int )((void *)0)) {
#line 2297
      return;
    }
#line 2298
    iatom ++;
#line 2299
    ires = a->serial / res_mod;
#line 2300
    np = a->name;
#line 2301
    while (1) {
#line 2301
      tmp = strcmp((char const   *)np, "sna.rkq");
#line 2301
      if (! (tmp == 0)) {
#line 2301
        break;
      }
#line 2302
      a = (ATOM *)a->next;
#line 2303
      if ((unsigned int )a->next == (unsigned int )((void *)0)) {
#line 2303
        return;
      }
#line 2303
      ires = a->serial / res_mod;
#line 2304
      np = a->name;
    }
#line 2305
    i = 0;
#line 2305
    while (i < 5) {
#line 2306
      if ((int )*np != 46) {
#line 2307
        if ((int const   )*((_ctype_ + 1) + (unsigned int )*np) & 2) {
#line 2307
          __x = (int )*np;
#line 2307
          if ((int const   )*((_ctype_ + 1) + (unsigned int )__x) & 2) {
#line 2307
            tmp___0 = (__x - 97) + 65;
          } else {
#line 2307
            tmp___0 = __x;
          }
#line 2307
          resid[i] = (char )tmp___0;
        } else {
#line 2308
          resid[i] = *np;
        }
      } else {
#line 2309
        resid[i] = (char )'\000';
#line 2309
        break;
      }
#line 2310
      if ((int )*np == 0) {
#line 2310
        break;
      }
#line 2311
      np ++;
#line 2305
      i ++;
    }
#line 2313
    if ((int )*np == 46) {
#line 2313
      np ++;
    }
#line 2314
    i = 0;
#line 2314
    while (i < 5) {
#line 2315
      if ((int )*np != 46) {
#line 2316
        if ((int const   )*((_ctype_ + 1) + (unsigned int )*np) & 2) {
#line 2316
          __x___0 = (int )*np;
#line 2316
          if ((int const   )*((_ctype_ + 1) + (unsigned int )__x___0) & 2) {
#line 2316
            tmp___1 = (__x___0 - 97) + 65;
          } else {
#line 2316
            tmp___1 = __x___0;
          }
#line 2316
          atid[i] = (char )tmp___1;
        } else {
#line 2317
          atid[i] = *np;
        }
      } else {
#line 2318
        atid[i] = (char )'\000';
#line 2318
        break;
      }
#line 2319
      if ((int )*np == 0) {
#line 2319
        break;
      }
#line 2320
      np ++;
#line 2314
      i ++;
    }
#line 2322
    if ((int )atid[0] == 72) {
#line 2323
      fprintf(where, "ATOM  %5d %-4s%c%-3s  %4d    %8.3f%8.3f%8.3f%6.2f%6.2f\n", iatom,
              atid, ' ', resid, ires, a->x, a->y, a->z, 1., 10.);
    } else {
#line 2327
      fprintf(where, "ATOM  %5d  %-4s%-3s  %4d    %8.3f%8.3f%8.3f%6.2f%6.2f\n", iatom,
              atid, resid, ires, a->x, a->y, a->z, 1., 10.);
    }
#line 2330
    a = (ATOM *)a->next;
  }
#line 2332
  if ((unsigned int )a->next == (unsigned int )((void *)0)) {
#line 2332
    return;
  }
#line 2333
  iatom ++;
#line 2334
  ires = a->serial / res_mod;
#line 2335
  np = a->name;
#line 2336
  tmp___4 = strcmp((char const   *)np, "sna.rkq");
#line 2336
  if (tmp___4 != 0) {
#line 2338
    i = 0;
#line 2338
    while (i < 5) {
#line 2339
      if ((int )*np != 46) {
#line 2340
        if ((int const   )*((_ctype_ + 1) + (unsigned int )*np) & 2) {
#line 2340
          __x___1 = (int )*np;
#line 2340
          if ((int const   )*((_ctype_ + 1) + (unsigned int )__x___1) & 2) {
#line 2340
            tmp___2 = (__x___1 - 97) + 65;
          } else {
#line 2340
            tmp___2 = __x___1;
          }
#line 2340
          resid[i] = (char )tmp___2;
        } else {
#line 2341
          resid[i] = *np;
        }
      } else {
#line 2342
        resid[i] = (char )'\000';
#line 2342
        break;
      }
#line 2343
      if ((int )*np == 0) {
#line 2343
        break;
      }
#line 2344
      np ++;
#line 2338
      i ++;
    }
#line 2346
    if ((int )*np == 46) {
#line 2346
      np ++;
    }
#line 2347
    i = 0;
#line 2347
    while (i < 5) {
#line 2348
      if ((int )*np != 46) {
#line 2349
        if ((int const   )*((_ctype_ + 1) + (unsigned int )*np) & 2) {
#line 2349
          __x___2 = (int )*np;
#line 2349
          if ((int const   )*((_ctype_ + 1) + (unsigned int )__x___2) & 2) {
#line 2349
            tmp___3 = (__x___2 - 97) + 65;
          } else {
#line 2349
            tmp___3 = __x___2;
          }
#line 2349
          atid[i] = (char )tmp___3;
        } else {
#line 2350
          atid[i] = *np;
        }
      } else {
#line 2351
        atid[i] = (char )'\000';
#line 2351
        break;
      }
#line 2352
      if ((int )*np == 0) {
#line 2352
        break;
      }
#line 2353
      np ++;
#line 2347
      i ++;
    }
#line 2355
    if ((int )atid[0] == 72) {
#line 2356
      fprintf(where, "ATOM  %5d %-4s%c%-3s  %4d    %8.3f%8.3f%8.3f%6.2f%6.2f\n", iatom,
              atid, ' ', resid, ires, a->x, a->y, a->z, 1., 10.);
    } else {
#line 2360
      fprintf(where, "ATOM  %5d  %-4s%-3s  %4d    %8.3f%8.3f%8.3f%6.2f%6.2f\n", iatom,
              atid, resid, ires, a->x, a->y, a->z, 1., 10.);
    }
  }
#line 2364
  fprintf(where, "END   \n");
#line 2365
  return;
}
}
#line 2366 "188.c"
double a_pr_beta(void) 
{ double a ;
  double b ;
  ATOM *ap___1 ;

  {
#line 2370
  ap___1 = first;
#line 2371
  a = 0.;
#line 2371
  b = 0.;
#line 2372
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 2372
    return (a);
  }
#line 2373
  while (1) {
#line 2375
    if ((unsigned int )ap___1->next == (unsigned int )((void *)0)) {
#line 2375
      return (0.);
    }
#line 2376
    a += ap___1->fx * ap___1->fx;
#line 2377
    a += ap___1->fy * ap___1->fy;
#line 2378
    a += ap___1->fz * ap___1->fz;
#line 2379
    a -= ap___1->gx * ap___1->fx;
#line 2380
    a -= ap___1->gy * ap___1->fy;
#line 2381
    a -= ap___1->gz * ap___1->fz;
#line 2382
    b += ap___1->gx * ap___1->gx;
#line 2383
    b += ap___1->gy * ap___1->gy;
#line 2384
    b += ap___1->gz * ap___1->gz;
#line 2385
    if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 2387
      if (b <= 1.e-5) {
#line 2387
        a = 0.;
#line 2387
        b = 1.;
      }
#line 2388
      return (a / b);
    }
#line 2390
    ap___1 = (ATOM *)ap___1->next;
  }
}
}
#line 2393 "188.c"
int inactivate_non_zero(int i1 , int i2 ) 
{ int upper ;
  int lower ;
  ATOM *ap___1 ;
  int i ;
  int numatm ;

  {
#line 2399
  if (i2 == 0) {
#line 2401
    ap___1 = a_m_serial(i1);
#line 2402
    if ((unsigned int )ap___1 != (unsigned int )((void *)0)) {
#line 2403
      ap___1->active = (char)0;
    }
#line 2404
    return (0);
  }
#line 2406
  upper = i2;
#line 2406
  lower = i1;
#line 2407
  if (i2 < i1) {
#line 2407
    lower = i2;
#line 2407
    upper = i1;
  }
#line 2408
  numatm = a_number();
#line 2409
  i = 0;
#line 2409
  while (i < numatm) {
#line 2411
    ap___1 = a_next(i);
#line 2412
    if (ap___1->serial >= lower) {
#line 2412
      if (ap___1->serial <= upper) {
#line 2413
        if (ap___1->x != 0.) {
#line 2413
          if (ap___1->y != 0.) {
#line 2413
            if (ap___1->z != 0.) {
#line 2414
              ap___1->active = (char)0;
            }
          }
        }
      }
    }
#line 2409
    i ++;
  }
#line 2416
  return (0);
}
}
#line 2418 "188.c"
int inactivate(int i1 , int i2 ) 
{ int upper ;
  int lower ;
  ATOM *ap___1 ;
  int i ;
  int numatm ;

  {
#line 2424
  if (i2 == 0) {
#line 2426
    ap___1 = a_m_serial(i1);
#line 2427
    if ((unsigned int )ap___1 != (unsigned int )((void *)0)) {
#line 2428
      ap___1->active = (char)0;
    }
#line 2429
    return (0);
  }
#line 2431
  upper = i2;
#line 2431
  lower = i1;
#line 2432
  if (i2 < i1) {
#line 2432
    lower = i2;
#line 2432
    upper = i1;
  }
#line 2433
  numatm = a_number();
#line 2434
  i = 0;
#line 2434
  while (i < numatm) {
#line 2436
    ap___1 = a_next(i);
#line 2437
    if (ap___1->serial >= lower) {
#line 2437
      if (ap___1->serial <= upper) {
#line 2438
        ap___1->active = (char)0;
      }
    }
#line 2434
    i ++;
  }
#line 2440
  return (0);
}
}
#line 2442 "188.c"
int activate(int i1 , int i2 ) 
{ int upper ;
  int lower ;
  ATOM *ap___1 ;
  int i ;
  int numatm ;

  {
#line 2448
  if (i2 == 0) {
#line 2450
    ap___1 = a_m_serial(i1);
#line 2451
    if ((unsigned int )ap___1 != (unsigned int )((void *)0)) {
#line 2452
      ap___1->active = (char)1;
    }
#line 2453
    return (0);
  }
#line 2455
  upper = i2;
#line 2455
  lower = i1;
#line 2456
  if (i2 < i1) {
#line 2456
    lower = i2;
#line 2456
    upper = i1;
  }
#line 2457
  numatm = a_number();
#line 2458
  i = 0;
#line 2458
  while (i < numatm) {
#line 2460
    ap___1 = a_next(i);
#line 2461
    if (ap___1->serial >= lower) {
#line 2461
      if (ap___1->serial <= upper) {
#line 2462
        ap___1->active = (char)1;
      }
    }
#line 2458
    i ++;
  }
#line 2464
  return (0);
}
}
#line 2466 "188.c"
void a_inactive_f_zero(void) 
{ int i ;
  int numatom ;
  ATOM *ap___1 ;

  {
#line 2470
  numatom = a_number();
#line 2471
  i = 0;
#line 2471
  while (i < numatom) {
#line 2473
    ap___1 = a_next(i);
#line 2474
    if ((int )ap___1->active == 0) {
#line 2475
      ap___1->fx = 0.;
#line 2475
      ap___1->fy = 0.;
#line 2475
      ap___1->fz = 0.;
    }
#line 2471
    i ++;
  }
#line 2477
  return;
}
}
#line 2491 "188.c"
BOND *bond_first  =    (BOND *)((void *)0);
#line 2492 "188.c"
BOND *bond_last  =    (BOND *)((void *)0);
#line 2493 "188.c"
int bond(int p1 , int p2 , double bl , double fk ) 
{ ATOM *ap1 ;
  ATOM *ap2 ;
  BOND *new ;
  int i ;
  char line[80] ;
  void *tmp ;

  {
#line 2501
  ap1 = a_m_serial(p1);
#line 2502
  ap2 = a_m_serial(p2);
#line 2503
  if ((unsigned int )ap1 == (unsigned int )((void *)0)) {
#line 2505
    sprintf(line, "undefined atom in bond %d %d \000", p1, p2);
#line 2506
    aaerror(line);
#line 2507
    return (0);
  } else {
#line 2503
    if ((unsigned int )ap2 == (unsigned int )((void *)0)) {
#line 2505
      sprintf(line, "undefined atom in bond %d %d \000", p1, p2);
#line 2506
      aaerror(line);
#line 2507
      return (0);
    }
  }
#line 2509
  tmp = malloc(sizeof(BOND ));
#line 2509
  new = (BOND *)tmp;
#line 2509
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 2511
    return (0);
  }
#line 2514
  if ((unsigned int )bond_first == (unsigned int )((void *)0)) {
#line 2514
    bond_first = new;
  }
#line 2515
  if ((unsigned int )bond_last == (unsigned int )((void *)0)) {
#line 2515
    bond_last = new;
  }
#line 2516
  new->atom1 = ap1;
#line 2517
  new->atom2 = ap2;
#line 2518
  new->length = bl;
#line 2519
  new->k = fk;
#line 2520
  new->next = (void *)new;
#line 2521
  if (ap1->dontuse < 32) {
#line 2523
    i = 0;
#line 2523
    while (i < ap1->dontuse) {
#line 2524
      if ((unsigned int )ap1->excluded[i] == (unsigned int )ap2) {
        goto excluded1;
      }
#line 2523
      i ++;
    }
#line 2525
    ap1->excluded[ap1->dontuse] = (void *)ap2;
#line 2525
    (ap1->dontuse) ++;
  } else {
#line 2527
    aaerror((char *)" too many bonds to an atom increase NEXCLUDE in ammp.h");
#line 2528
    exit(0);
  }
  excluded1: 
#line 2531
  if (ap2->dontuse < 32) {
#line 2533
    i = 0;
#line 2533
    while (i < ap2->dontuse) {
#line 2534
      if ((unsigned int )ap2->excluded[i] == (unsigned int )ap1) {
        goto excluded2;
      }
#line 2533
      i ++;
    }
#line 2535
    ap2->excluded[ap2->dontuse] = (void *)ap1;
#line 2535
    (ap2->dontuse) ++;
  } else {
#line 2537
    aaerror((char *)" too many bonds to an atom increase NEXCLUDE in ammp.h");
#line 2538
    exit(0);
  }
  excluded2: 
#line 2541
  bond_last->next = (void *)new;
#line 2542
  bond_last = new;
#line 2543
  return (1);
}
}
#line 2545 "188.c"
int v_bond(double *V , double lambda ) 
{ BOND *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 2551
  bp = bond_first;
#line 2552
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2552
    return (1);
  }
#line 2553
  while (1) {
#line 2555
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2555
      return (0);
    }
#line 2556
    a1 = bp->atom1;
#line 2556
    a2 = bp->atom2;
#line 2557
    if (a1->active) {
      goto _L;
    } else {
#line 2557
      if (a2->active) {
        _L: /* CIL Label */ 
#line 2559
        if (lambda == 0.) {
#line 2561
          r = (a1->x - a2->x) * (a1->x - a2->x);
#line 2562
          r += (a1->y - a2->y) * (a1->y - a2->y);
#line 2563
          r += (a1->z - a2->z) * (a1->z - a2->z);
        } else {
#line 2566
          xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 2567
          yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 2568
          zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 2569
          r = (xt * xt + yt * yt) + zt * zt;
        }
#line 2571
        r = sqrt(r);
#line 2571
        *V += (bp->k * (r - bp->length)) * (r - bp->length);
      }
    }
#line 2573
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 2573
      return (1);
    }
#line 2574
    bp = (BOND *)bp->next;
  }
}
}
#line 2577 "188.c"
int f_bond(double lambda ) 
{ BOND *bp ;
  double r ;
  double k ;
  double ux ;
  double uy ;
  double uz ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 2583
  bp = bond_first;
#line 2584
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2584
    return (1);
  }
#line 2585
  while (1) {
#line 2587
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2587
      return (0);
    }
#line 2588
    k = bp->k;
#line 2589
    a1 = bp->atom1;
#line 2589
    a2 = bp->atom2;
#line 2590
    if (a1->active) {
      goto _L;
    } else {
#line 2590
      if (a2->active) {
        _L: /* CIL Label */ 
#line 2592
        if (lambda == 0.) {
#line 2594
          ux = a2->x - a1->x;
#line 2595
          uy = a2->y - a1->y;
#line 2596
          uz = a2->z - a1->z;
        } else {
#line 2598
          ux = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 2599
          uy = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 2600
          uz = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
        }
#line 2602
        r = (ux * ux + uy * uy) + uz * uz;
#line 2604
        if (r <= 1.e-15) {
#line 2605
          r = (double )0;
#line 2605
          ux = 1.;
#line 2605
          uy = 0.;
#line 2605
          uz = 0.;
        } else {
#line 2606
          r = sqrt(r);
#line 2606
          ux /= r;
#line 2606
          uy /= r;
#line 2606
          uz /= r;
        }
#line 2608
        ux = (((double )2 * k) * (r - bp->length)) * ux;
#line 2609
        uy = (((double )2 * k) * (r - bp->length)) * uy;
#line 2610
        uz = (((double )2 * k) * (r - bp->length)) * uz;
#line 2611
        if (a1->active) {
#line 2612
          a1->fx += ux;
#line 2613
          a1->fy += uy;
#line 2614
          a1->fz += uz;
        }
#line 2616
        if (a2->active) {
#line 2617
          a2->fx -= ux;
#line 2618
          a2->fy -= uy;
#line 2619
          a2->fz -= uz;
        }
      }
    }
#line 2622
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 2622
      return (1);
    }
#line 2623
    bp = (BOND *)bp->next;
  }
}
}
#line 2626 "188.c"
void get_bond(ATOM *a1 , ATOM **bonded , int mbond , int *inbond ) 
{ BOND *mine ;
  int tmp ;
  int tmp___0 ;

  {
#line 2629
  mine = bond_first;
#line 2630
  *inbond = 0;
#line 2631
  while (1) {
#line 2633
    if ((unsigned int )mine == (unsigned int )((void *)0)) {
#line 2635
      return;
    }
#line 2637
    if ((unsigned int )mine->atom1 == (unsigned int )a1) {
#line 2639
      tmp = *inbond;
#line 2639
      (*inbond) ++;
#line 2639
      *(bonded + tmp) = mine->atom2;
    }
#line 2641
    if ((unsigned int )mine->atom2 == (unsigned int )a1) {
#line 2643
      tmp___0 = *inbond;
#line 2643
      (*inbond) ++;
#line 2643
      *(bonded + tmp___0) = mine->atom1;
    }
#line 2645
    if ((unsigned int )mine == (unsigned int )mine->next) {
#line 2645
      return;
    }
#line 2646
    mine = (BOND *)mine->next;
#line 2647
    if (*inbond == mbond) {
#line 2647
      return;
    }
  }
}
}
#line 2650 "188.c"
void dump_bonds(FILE *where ) 
{ BOND *b ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 2654
  b = bond_first;
#line 2655
  if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 2655
    return;
  }
#line 2656
  while ((unsigned int )b->next != (unsigned int )b) {
#line 2658
    if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 2658
      return;
    }
#line 2659
    a1 = b->atom1;
#line 2659
    a2 = b->atom2;
#line 2660
    fprintf(where, "bond %d %d %f %f ;\n", a1->serial, a2->serial, b->length, b->k);
#line 2662
    b = (BOND *)b->next;
  }
#line 2664
  if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 2664
    return;
  }
#line 2665
  a1 = b->atom1;
#line 2665
  a2 = b->atom2;
#line 2666
  fprintf(where, "bond %d %d %f %f ;\n", a1->serial, a2->serial, b->length, b->k);
#line 2668
  return;
}
}
#line 2669 "188.c"
int v_mmbond(double *V , double lambda ) 
{ BOND *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 2675
  bp = bond_first;
#line 2676
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2676
    return (1);
  }
#line 2677
  while (1) {
#line 2679
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2679
      return (0);
    }
#line 2680
    a1 = bp->atom1;
#line 2680
    a2 = bp->atom2;
#line 2681
    if (a1->active) {
      goto _L;
    } else {
#line 2681
      if (a2->active) {
        _L: /* CIL Label */ 
#line 2683
        if (lambda == 0.) {
#line 2685
          r = (a1->x - a2->x) * (a1->x - a2->x);
#line 2686
          r += (a1->y - a2->y) * (a1->y - a2->y);
#line 2687
          r += (a1->z - a2->z) * (a1->z - a2->z);
        } else {
#line 2690
          xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 2691
          yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 2692
          zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 2693
          r = (xt * xt + yt * yt) + zt * zt;
        }
#line 2695
        r = sqrt(r);
#line 2696
        r -= bp->length;
#line 2697
        *V += ((bp->k * r) * r) * ((1. - 2.55 * r) + (((7. * 2.55) / (double )12) * r) * r);
      }
    }
#line 2699
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 2699
      return (1);
    }
#line 2700
    bp = (BOND *)bp->next;
  }
}
}
#line 2703 "188.c"
int f_mmbond(double lambda ) 
{ BOND *bp ;
  double r ;
  double k ;
  double ux ;
  double uy ;
  double uz ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 2709
  bp = bond_first;
#line 2710
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2710
    return (1);
  }
#line 2711
  while (1) {
#line 2713
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2713
      return (0);
    }
#line 2714
    k = bp->k;
#line 2715
    a1 = bp->atom1;
#line 2715
    a2 = bp->atom2;
#line 2716
    if (a1->active) {
      goto _L;
    } else {
#line 2716
      if (a2->active) {
        _L: /* CIL Label */ 
#line 2718
        if (lambda == 0.) {
#line 2720
          ux = a2->x - a1->x;
#line 2721
          uy = a2->y - a1->y;
#line 2722
          uz = a2->z - a1->z;
        } else {
#line 2724
          ux = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 2725
          uy = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 2726
          uz = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
        }
#line 2728
        r = (ux * ux + uy * uy) + uz * uz;
#line 2730
        if (r <= 1.e-5) {
#line 2731
          r = (double )0;
#line 2731
          ux = 1.;
#line 2731
          uy = 0.;
#line 2731
          uz = 0.;
        } else {
#line 2732
          r = sqrt(r);
#line 2732
          ux /= r;
#line 2732
          uy /= r;
#line 2732
          uz /= r;
        }
#line 2734
        r -= bp->length;
#line 2735
        ux = ((k * r) * ((2. - ((double )3 * 2.55) * r) + ((((double )28 * 2.55) * r) * r) / (double )12)) * ux;
#line 2736
        uy = ((k * r) * ((2. - ((double )3 * 2.55) * r) + ((((double )28 * 2.55) * r) * r) / (double )12)) * uy;
#line 2737
        uz = ((k * r) * ((2. - ((double )3 * 2.55) * r) + ((((double )28 * 2.55) * r) * r) / (double )12)) * uz;
#line 2738
        if (a1->active) {
#line 2739
          a1->fx += ux;
#line 2740
          a1->fy += uy;
#line 2741
          a1->fz += uz;
        }
#line 2743
        if (a2->active) {
#line 2744
          a2->fx -= ux;
#line 2745
          a2->fy -= uy;
#line 2746
          a2->fz -= uz;
        }
      }
    }
#line 2749
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 2749
      return (1);
    }
#line 2750
    bp = (BOND *)bp->next;
  }
}
}
#line 2753 "188.c"
int a_bond(double *V , double lambda , int ilow , int ihigh , FILE *op ) 
{ BOND *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 2761
  bp = bond_first;
#line 2762
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2762
    return (1);
  }
#line 2763
  while (1) {
#line 2765
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2765
      return (0);
    }
#line 2766
    a1 = bp->atom1;
#line 2766
    a2 = bp->atom2;
#line 2767
    if (a1->active) {
      goto _L___1;
    } else {
#line 2767
      if (a2->active) {
        _L___1: /* CIL Label */ 
#line 2768
        if (a1->serial >= ilow) {
#line 2768
          if (a1->serial <= ihigh) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 2768
          if (a2->serial >= ilow) {
#line 2768
            if (a2->serial <= ihigh) {
              _L: /* CIL Label */ 
#line 2771
              if (lambda == 0.) {
#line 2773
                r = (a1->x - a2->x) * (a1->x - a2->x);
#line 2774
                r += (a1->y - a2->y) * (a1->y - a2->y);
#line 2775
                r += (a1->z - a2->z) * (a1->z - a2->z);
              } else {
#line 2778
                xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 2779
                yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 2780
                zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 2781
                r = (xt * xt + yt * yt) + zt * zt;
              }
#line 2783
              r = sqrt(r);
#line 2783
              zt = (bp->k * (r - bp->length)) * (r - bp->length);
#line 2784
              *V += zt;
#line 2785
              fprintf(op, "Bond %s %d %s %d E %f value %f error %f\n", a1->name, a1->serial,
                      a2->name, a2->serial, zt, r, r - bp->length);
            }
          }
        }
      }
    }
#line 2788
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 2788
      return (1);
    }
#line 2789
    bp = (BOND *)bp->next;
  }
}
}
#line 2792 "188.c"
int a_mmbond(double *V , double lambda , int ilow , int ihigh , FILE *op ) 
{ BOND *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 2800
  bp = bond_first;
#line 2801
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2801
    return (1);
  }
#line 2802
  while (1) {
#line 2804
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2804
      return (0);
    }
#line 2805
    a1 = bp->atom1;
#line 2805
    a2 = bp->atom2;
#line 2806
    if (a1->serial >= ilow) {
#line 2806
      if (a1->serial <= ihigh) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2806
      if (a2->serial >= ilow) {
#line 2806
        if (a2->serial <= ihigh) {
          _L: /* CIL Label */ 
#line 2809
          if (lambda == 0.) {
#line 2811
            r = (a1->x - a2->x) * (a1->x - a2->x);
#line 2812
            r += (a1->y - a2->y) * (a1->y - a2->y);
#line 2813
            r += (a1->z - a2->z) * (a1->z - a2->z);
          } else {
#line 2816
            xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 2817
            yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 2818
            zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 2819
            r = (xt * xt + yt * yt) + zt * zt;
          }
#line 2821
          r = sqrt(r);
#line 2822
          r -= bp->length;
#line 2823
          zt = ((bp->k * r) * r) * ((1. - 2.55 * r) + (((7. * 2.55) / (double )12) * r) * r);
#line 2824
          *V += zt;
#line 2825
          fprintf(op, "mmBond %s %d %s %d E %f value %f error %f\n", a1->name, a1->serial,
                  a2->name, a2->serial, zt, r + bp->length, r);
        }
      }
    }
#line 2828
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 2828
      return (1);
    }
#line 2829
    bp = (BOND *)bp->next;
  }
}
}
#line 2832 "188.c"
double bond_length(ATOM *a1 , ATOM *a2 ) 
{ BOND *bp ;

  {
#line 2836
  bp = bond_first;
#line 2837
  while (1) {
#line 2839
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2839
      return (- 1.);
    }
#line 2840
    if ((unsigned int )a1 == (unsigned int )bp->atom1) {
#line 2840
      if ((unsigned int )a2 == (unsigned int )bp->atom2) {
#line 2840
        return (bp->length);
      }
    }
#line 2841
    if ((unsigned int )a2 == (unsigned int )bp->atom1) {
#line 2841
      if ((unsigned int )a1 == (unsigned int )bp->atom2) {
#line 2841
        return (bp->length);
      }
    }
#line 2842
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 2842
      return (- 1.);
    }
#line 2843
    bp = (BOND *)bp->next;
  }
}
}
#line 2846 "188.c"
int gsdg_bond(ATOM *who ) 
{ BOND *bp ;
  ATOM *ap___1 ;

  {
#line 2851
  bp = bond_first;
#line 2852
  while (1) {
#line 2853
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2853
      return (1);
    }
#line 2854
    if ((unsigned int )bp->atom1 == (unsigned int )who) {
#line 2855
      ap___1 = bp->atom2;
#line 2855
      ap___1->vx = bp->length * bp->length;
#line 2855
      ap___1->vy = bp->k;
    }
#line 2856
    if ((unsigned int )bp->atom2 == (unsigned int )who) {
#line 2857
      ap___1 = bp->atom1;
#line 2857
      ap___1->vx = bp->length * bp->length;
#line 2857
      ap___1->vy = bp->k;
    }
#line 2858
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 2858
      return (1);
    }
#line 2859
    bp = (BOND *)bp->next;
  }
#line 2861
  return 0;
}
}
#line 2863 "188.c"
BOND *get_bond_pointer(ATOM *a1 , ATOM *a2 ) 
{ BOND *bp ;

  {
#line 2867
  bp = bond_first;
#line 2868
  while (1) {
#line 2870
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2870
      return ((BOND *)((void *)0));
    }
#line 2871
    if ((unsigned int )a1 == (unsigned int )bp->atom1) {
#line 2871
      if ((unsigned int )a2 == (unsigned int )bp->atom2) {
#line 2871
        return (bp);
      }
    }
#line 2872
    if ((unsigned int )a1 == (unsigned int )bp->atom2) {
#line 2872
      if ((unsigned int )a2 == (unsigned int )bp->atom1) {
#line 2872
        return (bp);
      }
    }
#line 2873
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 2873
      return ((BOND *)((void *)0));
    }
#line 2874
    bp = (BOND *)bp->next;
  }
#line 2876
  return ((BOND *)((void *)0));
}
}
#line 2878 "188.c"
int v_ho_bond(double *V , double lambda ) 
{ BOND *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;
  ATOM *a2 ;
  double hol ;
  double target ;

  {
#line 2886
  hol = get_f_variable("lambda");
#line 2887
  if (hol < 0.) {
#line 2887
    hol = 0.;
  }
#line 2888
  if (hol > 1.) {
#line 2888
    hol = 1.;
  }
#line 2889
  bp = bond_first;
#line 2890
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2890
    return (1);
  }
#line 2891
  while (1) {
#line 2893
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2893
      return (0);
    }
#line 2894
    a1 = bp->atom1;
#line 2894
    a2 = bp->atom2;
#line 2895
    if (a1->active) {
      goto _L;
    } else {
#line 2895
      if (a2->active) {
        _L: /* CIL Label */ 
#line 2897
        if (lambda == 0.) {
#line 2899
          r = (a1->x - a2->x) * (a1->x - a2->x);
#line 2900
          r += (a1->y - a2->y) * (a1->y - a2->y);
#line 2901
          r += (a1->z - a2->z) * (a1->z - a2->z);
        } else {
#line 2904
          xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 2905
          yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 2906
          zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 2907
          r = (xt * xt + yt * yt) + zt * zt;
        }
#line 2909
        r = sqrt(r);
#line 2910
        target = hol * r + (1. - hol) * bp->length;
#line 2911
        *V += (bp->k * (r - target)) * (r - target);
      }
    }
#line 2913
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 2913
      return (1);
    }
#line 2914
    bp = (BOND *)bp->next;
  }
}
}
#line 2917 "188.c"
int f_ho_bond(double lambda ) 
{ BOND *bp ;
  double r ;
  double k ;
  double ux ;
  double uy ;
  double uz ;
  ATOM *a1 ;
  ATOM *a2 ;
  double hol ;
  double target ;

  {
#line 2925
  hol = get_f_variable("lambda");
#line 2926
  if (hol < 0.) {
#line 2926
    hol = 0.;
  }
#line 2927
  if (hol > 1.) {
#line 2927
    hol = 1.;
  }
#line 2928
  bp = bond_first;
#line 2929
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2929
    return (1);
  }
#line 2930
  while (1) {
#line 2932
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 2932
      return (0);
    }
#line 2933
    k = bp->k;
#line 2934
    a1 = bp->atom1;
#line 2934
    a2 = bp->atom2;
#line 2935
    if (a1->active) {
      goto _L;
    } else {
#line 2935
      if (a2->active) {
        _L: /* CIL Label */ 
#line 2937
        if (lambda == 0.) {
#line 2939
          ux = a2->x - a1->x;
#line 2940
          uy = a2->y - a1->y;
#line 2941
          uz = a2->z - a1->z;
        } else {
#line 2943
          ux = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 2944
          uy = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 2945
          uz = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
        }
#line 2947
        r = (ux * ux + uy * uy) + uz * uz;
#line 2949
        if (r <= 1.e-15) {
#line 2950
          r = (double )0;
#line 2950
          ux = 1.;
#line 2950
          uy = 0.;
#line 2950
          uz = 0.;
        } else {
#line 2951
          r = sqrt(r);
#line 2951
          ux /= r;
#line 2951
          uy /= r;
#line 2951
          uz /= r;
        }
#line 2953
        target = hol * r + (1. - hol) * bp->length;
#line 2954
        ux = ((((double )2 * k) * (r - target)) * (1. - hol)) * ux;
#line 2955
        uy = ((((double )2 * k) * (r - target)) * (1. - hol)) * uy;
#line 2956
        uz = ((((double )2 * k) * (r - target)) * (1. - hol)) * uz;
#line 2957
        if (a1->active) {
#line 2958
          a1->fx += ux;
#line 2959
          a1->fy += uy;
#line 2960
          a1->fz += uz;
        }
#line 2962
        if (a2->active) {
#line 2963
          a2->fx -= ux;
#line 2964
          a2->fy -= uy;
#line 2965
          a2->fz -= uz;
        }
      }
    }
#line 2968
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 2968
      return (1);
    }
#line 2969
    bp = (BOND *)bp->next;
  }
}
}
#line 2977 "188.c"
int v_box(double *V , double lambda ) 
{ 

  {
#line 2980
  return (0);
}
}
#line 2982 "188.c"
int f_box(double lambda ) 
{ double bbox ;
  double xc ;
  double yc ;
  double zc ;
  double rx ;
  double ry ;
  double rz ;
  double rad ;
  double vmod ;
  double vf ;
  double vdot ;
  ATOM *ap___1 ;
  int natom ;
  int i ;
  double tmp ;

  {
#line 2992
  natom = a_number();
#line 2993
  if (natom < 1) {
#line 2993
    return (0);
  }
#line 2994
  bbox = get_f_variable("bbox");
#line 2995
  if (bbox < 1.) {
#line 2995
    return (0);
  }
#line 2996
  xc = 0.;
#line 2996
  yc = 0.;
#line 2996
  zc = 0.;
#line 2997
  i = 0;
#line 2997
  while (i < natom) {
#line 2999
    ap___1 = a_next(i);
#line 3000
    xc += ap___1->x;
#line 3001
    yc += ap___1->y;
#line 3002
    zc += ap___1->z;
#line 2997
    i ++;
  }
#line 3004
  xc /= (double )natom;
#line 3005
  yc /= (double )natom;
#line 3006
  zc /= (double )natom;
#line 3007
  bbox *= bbox;
#line 3008
  i = 0;
#line 3008
  while (i < natom) {
#line 3010
    ap___1 = a_next(i);
#line 3011
    rx = ap___1->x - xc;
#line 3012
    ry = ap___1->y - yc;
#line 3013
    rz = ap___1->z - zc;
#line 3014
    rad = (rx * rx + ry * ry) + rz * rz;
#line 3015
    if (rad > bbox) {
#line 3017
      tmp = sqrt(rad);
#line 3017
      rad = 1. / tmp;
#line 3018
      rx *= rad;
#line 3019
      ry *= rad;
#line 3020
      rz *= rad;
#line 3021
      vmod = (ap___1->vx * ap___1->vx + ap___1->vy * ap___1->vy) + ap___1->vz * ap___1->vz;
#line 3022
      vdot = (ap___1->vx * rx + ap___1->vy * ry) + ap___1->vz * rz;
#line 3023
      if (vdot > 0.) {
#line 3024
        ap___1->vx -= vdot * rx;
#line 3025
        ap___1->vx -= vdot * rx;
#line 3026
        ap___1->vy -= vdot * ry;
#line 3027
        ap___1->vy -= vdot * ry;
#line 3028
        ap___1->vz -= vdot * rz;
#line 3029
        ap___1->vz -= vdot * rz;
#line 3030
        vf = (ap___1->vx * ap___1->vx + ap___1->vy * ap___1->vy) + ap___1->vz * ap___1->vz;
#line 3031
        if (vf > 0.) {
#line 3031
          vmod = sqrt(vmod / vf);
        }
#line 3033
        ap___1->vx *= vmod;
#line 3034
        ap___1->vy *= vmod;
#line 3035
        ap___1->vz *= vmod;
#line 3036
        ap___1->dx = ap___1->vx;
#line 3037
        ap___1->dy = ap___1->vy;
#line 3038
        ap___1->dz = ap___1->vz;
      }
    }
#line 3008
    i ++;
  }
#line 3045
  return (0);
}
}
#line 3074
int loadloop(FILE *ip , FILE *tp , char *label ) ;
#line 3083
int eval(FILE *ip , FILE *op , char *line ) ;
#line 3075 "188.c"
void read_eval_do(FILE *ip , FILE *op ) 
{ char line[4096] ;
  int inbuff ;
  int inliteral ;
  int tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
#line 3084
  inliteral = 0;
#line 3085
  if ((unsigned int )ip == (unsigned int )((void *)0)) {
#line 3087
    aaerror((char *)" cannot use input file \n");
#line 3088
    return;
  }
#line 3090
  if ((unsigned int )op == (unsigned int )((void *)0)) {
#line 3092
    aaerror((char *)" cannot use output file \n");
#line 3093
    return;
  }
#line 3095
  inbuff = 0;
#line 3096
  while (1) {
#line 3096
    tmp___1 = fgetc(ip);
#line 3096
    tmp___0 = (char )tmp___1;
#line 3096
    line[inbuff] = tmp___0;
#line 3096
    if (! ((int )tmp___0 != -1)) {
#line 3096
      break;
    }
#line 3098
    if (! inliteral) {
#line 3098
      if ((int )line[inbuff] == 34) {
#line 3098
        inliteral = 1;
      }
    }
#line 3099
    if (inliteral) {
#line 3099
      if ((int )line[inbuff] == 34) {
#line 3099
        inliteral = 0;
      }
    }
#line 3100
    if (! inliteral) {
#line 3101
      if ((int )line[inbuff] == 44) {
#line 3101
        line[inbuff] = (char )' ';
      }
#line 3102
      if ((int )line[inbuff] == 9) {
#line 3102
        line[inbuff] = (char )' ';
      }
#line 3103
      if ((int )line[inbuff] == 10) {
#line 3103
        line[inbuff] = (char )' ';
      }
#line 3104
      if ((int )line[inbuff] == 59) {
#line 3106
        line[inbuff] = (char )'\000';
#line 3107
        tmp = eval(ip, op, line);
#line 3107
        if (tmp < 0) {
#line 3107
          return;
        }
#line 3108
        inbuff = 0;
      } else {
#line 3109
        if ((int )line[inbuff] != 10) {
#line 3109
          inbuff ++;
        }
      }
    }
  }
#line 3112
  return;
}
}
#line 3113 "188.c"
int (*potentials[10])()  ;
#line 3113 "188.c"
int (*forces[10])()  ;
#line 3113 "188.c"
int nused  =    -1;
#line 3122
int tisvariable(char *p ) ;
#line 3122
int tisint(char *p ) ;
#line 3124
int eval(FILE *ip , FILE *op , char *line ) ;
#line 3124 "188.c"
static int echo  =    1;
#line 3125
int eval(FILE *ip , FILE *op , char *line ) ;
#line 3125 "188.c"
static int inloop  =    1;
#line 3139
int alltether(double fk ) ;
#line 3140
int v_ho_tether(double *V , double lambda ) ;
#line 3140
int f_ho_tether(double lambda ) ;
#line 3141
int hybrid(int p1 , int p2 , int p3 , int p4 , double fk , double off ) ;
#line 3142
int noel(int p1 , int p2 , double d , double dm , double dh , double km , double kh ) ;
#line 3142
int f_noel(double lambda ) ;
#line 3143
int f_ho_noel(double lambda ) ;
#line 3144
int math(char (*tokens)[80] , double *fvalue , int *ivalue , FILE *ip , FILE *op ,
         int echo___0 ) ;
#line 3148
int significance(FILE *op ) ;
#line 3149
void gsdg(int (**vfs)() , int nfs , int niter , int low_serial , int high_serial ) ;
#line 3151
void AMMPmonitor(int (**vfs)() , int (**ffs___0)() , int nfs , FILE *op ) ;
#line 3152
void AMMPmonitor_mute(int (**vfs)() , int (**ffs___0)() , int nfs , FILE *op ) ;
#line 3153
void mom_add(int s1 , int s2 ) ;
#line 3153
void mom(FILE *op , double tq , int niter ) ;
#line 3154
void tailor_qab(int who , double q , double a , double b ) ;
#line 3155
void tailor_include(int from , int to ) ;
#line 3156
void tailor_exclude(int from , int to ) ;
#line 3318
int tgroup(int which , int context , int b1 , int b2 , int b3 , double base , int ntry ) ;
#line 3323
int tsearch(int t1 , int t2 , int t3 , int t4 , int t5 , int t6 , int t7 , int t8 ) ;
#line 3328
int tset(FILE *op , int echo___0 , int i1 , int i2 , int i3 , int i4 , double alpha ) ;
#line 3333
int tmin(FILE *op , int echo___0 , int i1 , int i2 , int i3 , int i4 , int nstep ,
         int (**vfs)() , int nfs ) ;
#line 3338
int tmap(FILE *op , int echo___0 , int (**vfs)() , int nfs , int i1 , int i2 , int i3 ,
         int i4 , int j1___0 , int j2 , int j3 , int j4 , int nistep , int njstep ) ;
#line 3574
int steep(int (**vfs)() , int (**ffs___0)() , int nfs , int nstep , double toler ) ;
#line 3586
int cngdel(int (**vfs)() , int (**ffs___0)() , int nfs , int nstep , int nreset ,
           double toler , int echo___0 ) ;
#line 3114 "188.c"
int eval(FILE *ip , FILE *op , char *line ) 
{ FILE *newfile ;
  char token[20][80] ;
  char *ap___1 ;
  char *ap1 ;
  char errmes[80] ;
  int itemp[20] ;
  int itoken ;
  double ftemp[20] ;
  char *tmp ;
  char *tmp___0 ;
  int __x ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  double tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  struct _reent *tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  clock_t tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;

  {
#line 3160
  if (nused == -1) {
#line 3161
    potentials[0] = (int (*)())(& v_bond);
#line 3162
    potentials[1] = (int (*)())(& v_angle);
#line 3163
    potentials[2] = & u_v_nonbon;
#line 3164
    potentials[3] = & v_torsion;
#line 3165
    potentials[4] = & v_hybrid;
#line 3166
    forces[0] = (int (*)())(& f_bond);
#line 3167
    forces[1] = (int (*)())(& f_angle);
#line 3168
    forces[2] = & u_f_nonbon;
#line 3169
    forces[3] = & f_torsion;
#line 3170
    forces[4] = & f_hybrid;
#line 3171
    nused = 5;
  }
#line 3173
  itoken = 0;
#line 3173
  while (itoken < 20) {
#line 3175
    token[itoken][0] = (char )'\000';
#line 3176
    itemp[itoken] = 0;
#line 3176
    ftemp[itoken] = 0.;
#line 3173
    itoken ++;
  }
#line 3178
  if (echo) {
#line 3178
    fprintf(op, "%s;\n", line);
  }
#line 3179
  ap___1 = line;
#line 3180
  itoken = 0;
#line 3180
  while (itoken < 20) {
#line 3182
    ap1 = & token[itoken][0];
#line 3183
    *ap1 = (char )'\000';
#line 3184
    while ((int )*ap___1 == 32) {
#line 3184
      ap___1 ++;
    }
#line 3185
    if ((int )*ap___1 == 34) {
#line 3186
      ap___1 ++;
#line 3187
      while (1) {
#line 3187
        if ((int )*ap___1 != 34) {
#line 3187
          if (! ((int )*ap___1 != 0)) {
#line 3187
            break;
          }
        } else {
#line 3187
          break;
        }
#line 3189
        tmp = ap1;
#line 3189
        ap1 ++;
#line 3189
        tmp___0 = ap___1;
#line 3189
        ap___1 ++;
#line 3189
        *tmp = *tmp___0;
      }
#line 3191
      if ((int )*ap___1 == 34) {
#line 3191
        ap___1 ++;
      }
    } else {
#line 3193
      if (itoken == 0) {
#line 3193
        if ((int )*ap___1 == 35) {
#line 3193
          return (1);
        }
      }
#line 3194
      while (1) {
#line 3194
        if ((int )*ap___1 != 32) {
#line 3194
          if (! ((int )*ap___1 != 0)) {
#line 3194
            break;
          }
        } else {
#line 3194
          break;
        }
#line 3196
        if (itoken == 0) {
          goto _L;
        } else {
#line 3196
          tmp___2 = strcmp((char const   *)(& token[0][0]), "read");
#line 3196
          if (tmp___2 != 0) {
#line 3196
            tmp___3 = strcmp((char const   *)(& token[0][0]), "output");
#line 3196
            if (tmp___3 != 0) {
              _L: /* CIL Label */ 
#line 3199
              if ((int const   )*((_ctype_ + 1) + (unsigned int )*ap___1) & 1) {
#line 3200
                __x = (int )*ap___1;
#line 3200
                if ((int const   )*((_ctype_ + 1) + (unsigned int )__x) & 1) {
#line 3200
                  tmp___1 = (__x - 65) + 97;
                } else {
#line 3200
                  tmp___1 = __x;
                }
#line 3200
                *ap1 = (char )tmp___1;
              } else {
#line 3200
                *ap1 = *ap___1;
              }
#line 3201
              ap1 ++;
#line 3201
              ap___1 ++;
            } else {
#line 3203
              *ap1 = *ap___1;
#line 3203
              ap1 ++;
#line 3203
              ap___1 ++;
            }
          } else {
#line 3203
            *ap1 = *ap___1;
#line 3203
            ap1 ++;
#line 3203
            ap___1 ++;
          }
        }
      }
    }
#line 3207
    *ap1 = (char )'\000';
#line 3208
    ap1 = & token[itoken][0];
#line 3209
    tmp___5 = tisvariable(ap1);
#line 3209
    if (tmp___5) {
#line 3211
      ftemp[itoken] = get_f_variable(ap1);
#line 3212
      itemp[itoken] = get_i_variable(ap1);
    } else {
#line 3214
      tmp___4 = tisint(ap1);
#line 3214
      if (tmp___4 == 1) {
#line 3216
        itemp[itoken] = atoi((char const   *)ap1);
#line 3217
        ftemp[itoken] = (double )itemp[itoken];
      } else {
#line 3219
        ftemp[itoken] = atof((char const   *)ap1);
#line 3220
        itemp[itoken] = (int )ftemp[itoken];
      }
    }
#line 3223
    if ((int )*ap___1 == 0) {
#line 3223
      break;
    }
#line 3180
    itoken ++;
  }
#line 3225
  if ((int )token[0][0] == 0) {
#line 3225
    return (1);
  }
#line 3227
  tmp___7 = strcmp((char const   *)(& token[0][0]), "atom");
#line 3227
  if (tmp___7 == 0) {
#line 3229
    tmp___6 = atom(ftemp[1], ftemp[2], ftemp[3], itemp[4], ftemp[6], ftemp[7], ftemp[8],
                   ftemp[9], & token[5][0]);
#line 3229
    if (! tmp___6) {
#line 3232
      aaerror((char *)" cannot add to atom structure -data structure error");
#line 3233
      exit(0);
    }
    goto DONE;
  }
#line 3236
  tmp___9 = strcmp((char const   *)(& token[0][0]), "bond");
#line 3236
  if (tmp___9 == 0) {
#line 3238
    tmp___8 = bond(itemp[1], itemp[2], ftemp[3], ftemp[4]);
#line 3238
    if (! tmp___8) {
#line 3241
      aaerror((char *)" cannot add to bond structure -data structure error");
#line 3242
      exit(0);
    }
    goto DONE;
  }
#line 3245
  tmp___11 = strcmp((char const   *)(& token[0][0]), "restrain");
#line 3245
  if (tmp___11 == 0) {
#line 3247
    tmp___10 = restrain(itemp[1], itemp[2], ftemp[3], ftemp[4]);
#line 3247
    if (! tmp___10) {
#line 3249
      aaerror((char *)" cannot add to restrain structure -data structure error");
#line 3250
      exit(0);
    }
    goto DONE;
  }
#line 3253
  tmp___13 = strcmp((char const   *)(& token[0][0]), "angle");
#line 3253
  if (tmp___13 == 0) {
#line 3255
    ftemp[2] = 3.141592653589793 / 180.;
#line 3256
    ftemp[5] *= ftemp[2];
#line 3257
    tmp___12 = angle(itemp[1], itemp[2], itemp[3], ftemp[4], ftemp[5]);
#line 3257
    if (! tmp___12) {
#line 3259
      aaerror((char *)" cannot add to angle structure -data structure error");
#line 3260
      exit(0);
    }
    goto DONE;
  }
#line 3263
  tmp___15 = strcmp((char const   *)(& token[0][0]), "noel");
#line 3263
  if (tmp___15 == 0) {
#line 3265
    tmp___14 = noel(itemp[1], itemp[2], ftemp[3], ftemp[4], ftemp[5], ftemp[6], ftemp[7]);
#line 3265
    if (! tmp___14) {
#line 3269
      aaerror((char *)" cannot add to noel structure -data structure error");
#line 3270
      exit(0);
    }
    goto DONE;
  }
#line 3273
  tmp___18 = strcmp((char const   *)(& token[0][0]), "torsion");
#line 3273
  if (tmp___18 == 0) {
#line 3275
    tmp___16 = acos(- 1.);
#line 3275
    ftemp[2] = tmp___16 / 180.;
#line 3275
    ftemp[7] *= ftemp[2];
#line 3276
    tmp___17 = torsion(itemp[1], itemp[2], itemp[3], itemp[4], ftemp[5], itemp[6],
                       ftemp[7]);
#line 3276
    if (! tmp___17) {
#line 3279
      aaerror((char *)" cannot add to torsion structure -data structure error");
#line 3280
      exit(0);
    }
    goto DONE;
  }
#line 3283
  tmp___20 = strcmp((char const   *)(& token[0][0]), "hybrid");
#line 3283
  if (tmp___20 == 0) {
#line 3285
    tmp___19 = hybrid(itemp[1], itemp[2], itemp[3], itemp[4], ftemp[5], ftemp[6]);
#line 3285
    if (! tmp___19) {
#line 3287
      aaerror((char *)" cannot add to hybrid structure -data structure error");
#line 3288
      exit(0);
    }
    goto DONE;
  }
#line 3291
  tmp___22 = strcmp((char const   *)(& token[0][0]), "velocity");
#line 3291
  if (tmp___22 == 0) {
#line 3293
    tmp___21 = a_readvelocity(itemp[1], ftemp[2], ftemp[3], ftemp[4]);
#line 3293
    if (! tmp___21) {
#line 3295
      aaerror((char *)" cannot update velocity -is this atom defined? ");
#line 3296
      exit(0);
    }
    goto DONE;
  }
#line 3299
  tmp___26 = strcmp((char const   *)(& token[0][0]), "tether");
#line 3299
  if (tmp___26 == 0) {
#line 3301
    tmp___25 = strcmp((char const   *)(& token[1][0]), "all");
#line 3301
    if (tmp___25 == 0) {
#line 3303
      tmp___23 = alltether(ftemp[2]);
#line 3303
      if (! tmp___23) {
#line 3305
        aaerror((char *)" cannot add to tether structure -data structure error");
#line 3306
        exit(0);
      }
    } else {
#line 3309
      tmp___24 = tether(itemp[1], ftemp[2], ftemp[3], ftemp[4], ftemp[5]);
#line 3309
      if (! tmp___24) {
#line 3311
        aaerror((char *)" cannot add to tether structure -data structure error");
#line 3312
        exit(0);
      }
    }
    goto DONE;
  }
#line 3316
  tmp___27 = strcmp((char const   *)(& token[0][0]), "tgroup");
#line 3316
  if (tmp___27 == 0) {
#line 3318
    tgroup(itemp[1], itemp[2], itemp[3], itemp[4], itemp[5], ftemp[6], itemp[7]);
    goto DONE;
  }
#line 3321
  tmp___28 = strcmp((char const   *)(& token[0][0]), "tsearch");
#line 3321
  if (tmp___28 == 0) {
#line 3323
    tsearch(itemp[1], itemp[2], itemp[3], itemp[4], itemp[5], itemp[6], itemp[7],
            itemp[8]);
    goto DONE;
  }
#line 3326
  tmp___29 = strcmp((char const   *)(& token[0][0]), "tset");
#line 3326
  if (tmp___29 == 0) {
#line 3328
    tset(op, echo, itemp[1], itemp[2], itemp[3], itemp[4], (ftemp[5] * 3.141592653589793) / 180.);
    goto DONE;
  }
#line 3331
  tmp___30 = strcmp((char const   *)(& token[0][0]), "tmin");
#line 3331
  if (tmp___30 == 0) {
#line 3333
    tmin(op, echo, itemp[1], itemp[2], itemp[3], itemp[4], itemp[5], potentials, nused);
    goto DONE;
  }
#line 3336
  tmp___31 = strcmp((char const   *)(& token[0][0]), "tmap");
#line 3336
  if (tmp___31 == 0) {
#line 3338
    tmap(op, echo, potentials, nused, itemp[1], itemp[2], itemp[3], itemp[4], itemp[5],
         itemp[6], itemp[7], itemp[8], itemp[9], itemp[10]);
    goto DONE;
  }
#line 3344
  tmp___32 = strcmp((char const   *)(& token[0][0]), "mompar");
#line 3344
  if (tmp___32 == 0) {
#line 3346
    mom_param(itemp[1], ftemp[2], ftemp[3]);
    goto DONE;
  }
#line 3349
  tmp___33 = strcmp((char const   *)(& token[0][0]), "momadd");
#line 3349
  if (tmp___33 == 0) {
#line 3351
    mom_add(itemp[1], itemp[2]);
    goto DONE;
  }
#line 3354
  tmp___34 = strcmp((char const   *)(& token[0][0]), "mom");
#line 3354
  if (tmp___34 == 0) {
#line 3356
    mom(op, ftemp[1], itemp[2]);
    goto DONE;
  }
#line 3359
  tmp___35 = strcmp((char const   *)(& token[0][0]), "monitor");
#line 3359
  if (tmp___35 == 0) {
#line 3361
    AMMPmonitor(potentials, forces, nused, op);
    goto DONE;
  }
#line 3364
  tmp___36 = strcmp((char const   *)(& token[0][0]), "mon2");
#line 3364
  if (tmp___36 == 0) {
#line 3366
    AMMPmonitor_mute(potentials, forces, nused, op);
    goto DONE;
  }
#line 3369
  tmp___37 = strcmp((char const   *)(& token[0][0]), "nzinactive");
#line 3369
  if (tmp___37 == 0) {
#line 3371
    inactivate_non_zero(itemp[1], itemp[2]);
    goto DONE;
  }
#line 3374
  tmp___38 = strcmp((char const   *)(& token[0][0]), "inactive");
#line 3374
  if (tmp___38 == 0) {
#line 3376
    inactivate(itemp[1], itemp[2]);
    goto DONE;
  }
#line 3379
  tmp___39 = strcmp((char const   *)(& token[0][0]), "active");
#line 3379
  if (tmp___39 == 0) {
#line 3381
    activate(itemp[1], itemp[2]);
    goto DONE;
  }
#line 3384
  tmp___40 = strcmp((char const   *)(& token[0][0]), "signify");
#line 3384
  if (tmp___40 == 0) {
#line 3386
    significance(op);
    goto DONE;
  }
#line 3389
  tmp___41 = strcmp((char const   *)(& token[0][0]), "analyze");
#line 3389
  if (tmp___41 == 0) {
#line 3391
    analyze(potentials, nused, itemp[1], itemp[2], op);
    goto DONE;
  }
#line 3394
  tmp___45 = strcmp((char const   *)(& token[0][0]), "tailor");
#line 3394
  if (tmp___45 == 0) {
#line 3396
    tmp___42 = strcmp((char const   *)(& token[1][0]), "qab");
#line 3396
    if (tmp___42 == 0) {
#line 3398
      tailor_qab(itemp[2], ftemp[3], ftemp[4], ftemp[5]);
      goto DONE;
    }
#line 3401
    tmp___43 = strcmp((char const   *)(& token[1][0]), "include");
#line 3401
    if (tmp___43 == 0) {
#line 3403
      tailor_include(itemp[2], itemp[3]);
      goto DONE;
    }
#line 3406
    tmp___44 = strcmp((char const   *)(& token[1][0]), "exclude");
#line 3406
    if (tmp___44 == 0) {
#line 3408
      tailor_exclude(itemp[2], itemp[3]);
      goto DONE;
    }
#line 3411
    aaerror((char *)" undefined tailor option ");
#line 3411
    aaerror(& token[1][0]);
    goto DONE;
  }
#line 3414
  tmp___46 = strcmp((char const   *)(& token[0][0]), "read");
#line 3414
  if (tmp___46 == 0) {
#line 3416
    newfile = fopen((char const   *)(& token[1][0]), "r");
#line 3417
    if ((unsigned int )newfile == (unsigned int )((void *)0)) {
#line 3418
      aaerror((char *)" cannot open file for read ");
#line 3418
      aaerror(& token[1][0]);
    } else {
#line 3420
     // read_eval_do(newfile, op);
#line 3420
      fclose(newfile);
    }
    goto DONE;
  }
#line 3423
  tmp___47 = strcmp((char const   *)(& token[0][0]), "output");
#line 3423
  if (tmp___47 == 0) {
#line 3425
    if (itemp[2] > 0) {
#line 3427
      sprintf(errmes, "%s.%d", & token[1][0], itemp[2]);
#line 3428
      newfile = fopen((char const   *)(errmes), "w");
    } else {
#line 3430
      newfile = fopen((char const   *)(& token[1][0]), "w");
    }
#line 3432
    if ((unsigned int )newfile == (unsigned int )((void *)0)) {
#line 3433
      aaerror((char *)" cannot open file for write ");
#line 3433
      aaerror(& token[1][0]);
    } else {
#line 3435
    //  read_eval_do(ip, newfile);
    }
    goto DONE;
  }
#line 3438
  tmp___61 = strcmp((char const   *)(& token[0][0]), "dump");
#line 3438
  if (tmp___61 == 0) {
#line 3440
    itoken = 1;
#line 3440
    while (itoken < 20) {
#line 3441
      if ((int )token[itoken][0] == 0) {
        goto DONE;
      }
#line 3442
      tmp___48 = strcmp((char const   *)(& token[itoken][0]), "atom");
#line 3442
      if (tmp___48 == 0) {
#line 3442
        dump_atoms(op);
      }
#line 3443
      tmp___49 = strcmp((char const   *)(& token[itoken][0]), "bond");
#line 3443
      if (tmp___49 == 0) {
#line 3443
        dump_bonds(op);
      }
#line 3444
      tmp___50 = strcmp((char const   *)(& token[itoken][0]), "noel");
#line 3444
      if (tmp___50 == 0) {
#line 3444
        dump_noels(op);
      }
#line 3445
      tmp___51 = strcmp((char const   *)(& token[itoken][0]), "angle");
#line 3445
      if (tmp___51 == 0) {
#line 3445
        dump_angles(op);
      }
#line 3446
      tmp___52 = strcmp((char const   *)(& token[itoken][0]), "torsion");
#line 3446
      if (tmp___52 == 0) {
#line 3446
        dump_torsions(op);
      }
#line 3447
      tmp___53 = strcmp((char const   *)(& token[itoken][0]), "hybrid");
#line 3447
      if (tmp___53 == 0) {
#line 3447
        dump_hybrids(op);
      }
#line 3448
      tmp___54 = strcmp((char const   *)(& token[itoken][0]), "restrain");
#line 3448
      if (tmp___54 == 0) {
#line 3448
        dump_restrains(op);
      }
#line 3449
      tmp___55 = strcmp((char const   *)(& token[itoken][0]), "pdb");
#line 3449
      if (tmp___55 == 0) {
#line 3449
        dump_pdb(op, 100);
      }
#line 3450
      tmp___56 = strcmp((char const   *)(& token[itoken][0]), "variable");
#line 3450
      if (tmp___56 == 0) {
#line 3450
        dump_variable(op);
      }
#line 3451
      tmp___57 = strcmp((char const   *)(& token[itoken][0]), "velocity");
#line 3451
      if (tmp___57 == 0) {
#line 3451
        dump_velocity(op);
      }
#line 3452
      tmp___58 = strcmp((char const   *)(& token[itoken][0]), "force");
#line 3452
      if (tmp___58 == 0) {
#line 3452
        dump_force(op);
      }
#line 3453
      tmp___59 = strcmp((char const   *)(& token[itoken][0]), "tether");
#line 3453
      if (tmp___59 == 0) {
#line 3453
        dump_tethers(op);
      }
#line 3454
      tmp___60 = strcmp((char const   *)(& token[itoken][0]), "tgroup");
#line 3454
      if (tmp___60 == 0) {
#line 3454
        dump_tgroup(op);
      }
#line 3440
      itoken ++;
    }
    goto DONE;
  }
#line 3458
  tmp___95 = strcmp((char const   *)(& token[0][0]), "use");
#line 3458
  if (tmp___95 == 0) {
#line 3460
    itoken = 1;
#line 3460
    while (itoken < 20) {
#line 3462
      if ((int )token[itoken][0] == 0) {
        goto DONE;
      }
#line 3463
      tmp___62 = strcmp((char const   *)(& token[itoken][0]), "none");
#line 3463
      if (tmp___62 == 0) {
#line 3463
        nused = 0;
      }
#line 3464
      tmp___64 = strcmp((char const   *)(& token[itoken][0]), "nonbon");
#line 3464
      if (tmp___64 == 0) {
#line 3465
        forces[nused] = & u_f_nonbon;
#line 3465
        tmp___63 = nused;
#line 3465
        nused ++;
#line 3465
        potentials[tmp___63] = & u_v_nonbon;
      }
#line 3466
      tmp___66 = strcmp((char const   *)(& token[itoken][0]), "bond");
#line 3466
      if (tmp___66 == 0) {
#line 3467
        forces[nused] = (int (*)())(& f_bond);
#line 3467
        tmp___65 = nused;
#line 3467
        nused ++;
#line 3467
        potentials[tmp___65] = (int (*)())(& v_bond);
      }
#line 3468
      tmp___68 = strcmp((char const   *)(& token[itoken][0]), "mmbond");
#line 3468
      if (tmp___68 == 0) {
#line 3469
        forces[nused] = (int (*)())(& f_mmbond);
#line 3469
        tmp___67 = nused;
#line 3469
        nused ++;
#line 3469
        potentials[tmp___67] = (int (*)())(& v_mmbond);
      }
#line 3470
      tmp___70 = strcmp((char const   *)(& token[itoken][0]), "hobond");
#line 3470
      if (tmp___70 == 0) {
#line 3471
        forces[nused] = (int (*)())(& f_ho_bond);
#line 3471
        tmp___69 = nused;
#line 3471
        nused ++;
#line 3471
        potentials[tmp___69] = (int (*)())(& v_ho_bond);
      }
#line 3472
      tmp___72 = strcmp((char const   *)(& token[itoken][0]), "tether");
#line 3472
      if (tmp___72 == 0) {
#line 3473
        forces[nused] = & f_tether;
#line 3473
        tmp___71 = nused;
#line 3473
        nused ++;
#line 3473
        potentials[tmp___71] = & v_tether;
      }
#line 3474
      tmp___74 = strcmp((char const   *)(& token[itoken][0]), "hotether");
#line 3474
      if (tmp___74 == 0) {
#line 3475
        forces[nused] = & f_ho_tether;
#line 3475
        tmp___73 = nused;
#line 3475
        nused ++;
#line 3475
        potentials[tmp___73] = & v_ho_tether;
      }
#line 3476
      tmp___76 = strcmp((char const   *)(& token[itoken][0]), "restrain");
#line 3476
      if (tmp___76 == 0) {
#line 3477
        forces[nused] = & f_restrain;
#line 3477
        tmp___75 = nused;
#line 3477
        nused ++;
#line 3477
        potentials[tmp___75] = & v_restrain;
      }
#line 3478
      tmp___78 = strcmp((char const   *)(& token[itoken][0]), "angle");
#line 3478
      if (tmp___78 == 0) {
#line 3479
        forces[nused] = (int (*)())(& f_angle);
#line 3479
        tmp___77 = nused;
#line 3479
        nused ++;
#line 3479
        potentials[tmp___77] = (int (*)())(& v_angle);
      }
#line 3480
      tmp___80 = strcmp((char const   *)(& token[itoken][0]), "hoangle");
#line 3480
      if (tmp___80 == 0) {
#line 3481
        forces[nused] = (int (*)())(& f_ho_angle);
#line 3481
        tmp___79 = nused;
#line 3481
        nused ++;
#line 3481
        potentials[tmp___79] = (int (*)())(& v_ho_angle);
      }
#line 3482
      tmp___82 = strcmp((char const   *)(& token[itoken][0]), "mmangle");
#line 3482
      if (tmp___82 == 0) {
#line 3483
        forces[nused] = (int (*)())(& f_mmangle);
#line 3483
        tmp___81 = nused;
#line 3483
        nused ++;
#line 3483
        potentials[tmp___81] = (int (*)())(& v_mmangle);
      }
#line 3484
      tmp___84 = strcmp((char const   *)(& token[itoken][0]), "cangle");
#line 3484
      if (tmp___84 == 0) {
#line 3485
        forces[nused] = (int (*)())(& f_c_angle);
#line 3485
        tmp___83 = nused;
#line 3485
        nused ++;
#line 3485
        potentials[tmp___83] = (int (*)())(& v_c_angle);
      }
#line 3486
      tmp___86 = strcmp((char const   *)(& token[itoken][0]), "torsion");
#line 3486
      if (tmp___86 == 0) {
#line 3487
        forces[nused] = & f_torsion;
#line 3487
        tmp___85 = nused;
#line 3487
        nused ++;
#line 3487
        potentials[tmp___85] = & v_torsion;
      }
#line 3488
      tmp___88 = strcmp((char const   *)(& token[itoken][0]), "hybrid");
#line 3488
      if (tmp___88 == 0) {
#line 3489
        forces[nused] = & f_hybrid;
#line 3489
        tmp___87 = nused;
#line 3489
        nused ++;
#line 3489
        potentials[tmp___87] = & v_hybrid;
      }
#line 3490
      tmp___90 = strcmp((char const   *)(& token[itoken][0]), "honoel");
#line 3490
      if (tmp___90 == 0) {
#line 3491
        forces[nused] = & f_ho_noel;
#line 3491
        tmp___89 = nused;
#line 3491
        nused ++;
#line 3491
        potentials[tmp___89] = & v_ho_noel;
      }
#line 3492
      tmp___92 = strcmp((char const   *)(& token[itoken][0]), "noel");
#line 3492
      if (tmp___92 == 0) {
#line 3493
        forces[nused] = & f_noel;
#line 3493
        tmp___91 = nused;
#line 3493
        nused ++;
#line 3493
        potentials[tmp___91] = & v_noel;
      }
#line 3494
      tmp___94 = strcmp((char const   *)(& token[itoken][0]), "box");
#line 3494
      if (tmp___94 == 0) {
#line 3495
        forces[nused] = (int (*)())(& f_box);
#line 3495
        tmp___93 = nused;
#line 3495
        nused ++;
#line 3495
        potentials[tmp___93] = (int (*)())(& v_box);
      }
#line 3460
      itoken ++;
    }
    goto DONE;
  }
#line 3499
  tmp___97 = strcmp((char const   *)(& token[0][0]), "close");
#line 3499
  if (tmp___97 == 0) {
#line 3501
    tmp___96 = __getreent();
#line 3501
    if ((unsigned int )op != (unsigned int )tmp___96->_stdout) {
#line 3503
      fclose(op);
#line 3504
      return (-1);
    }
    goto DONE;
  }
#line 3507
  tmp___98 = strcmp((char const   *)(& token[0][0]), "seti");
#line 3507
  if (tmp___98 == 0) {
#line 3509
    if ((int )token[1][0] == 0) {
#line 3510
      aaerror((char *)"seti requires a variable name: seti <name> value");
      goto DONE;
    }
#line 3513
    set_i_variable(& token[1][0], itemp[2]);
    goto DONE;
  }
#line 3516
  tmp___99 = strcmp((char const   *)(& token[0][0]), "setf");
#line 3516
  if (tmp___99 == 0) {
#line 3518
    if ((int )token[1][0] == 0) {
#line 3519
      aaerror((char *)"setf requires a variable name: setf <name> value");
      goto DONE;
    }
#line 3522
    set_f_variable(& token[1][0], ftemp[2]);
    goto DONE;
  }
#line 3525
  tmp___100 = math(token, ftemp, itemp, ip, op, echo);
#line 3525
  if (tmp___100 > 0) {
    goto DONE;
  }
#line 3526
  tmp___101 = strcmp((char const   *)(& token[0][0]), "v_maxwell");
#line 3526
  if (tmp___101 == 0) {
#line 3528
    v_maxwell(ftemp[1], ftemp[2], ftemp[3], ftemp[4]);
    goto DONE;
  }
#line 3531
  tmp___102 = strcmp((char const   *)(& token[0][0]), "v_rescale");
#line 3531
  if (tmp___102 == 0) {
#line 3533
    v_rescale(ftemp[1]);
    goto DONE;
  }
#line 3536
  tmp___103 = strcmp((char const   *)(& token[0][0]), "verlet");
#line 3536
  if (tmp___103 == 0) {
#line 3538
    verlet(forces, nused, itemp[1], ftemp[2]);
    goto DONE;
  }
#line 3541
  tmp___104 = strcmp((char const   *)(& token[0][0]), "pac");
#line 3541
  if (tmp___104 == 0) {
#line 3543
    pac(forces, nused, itemp[1], ftemp[2]);
    goto DONE;
  }
#line 3546
  tmp___105 = strcmp((char const   *)(& token[0][0]), "tpac");
#line 3546
  if (tmp___105 == 0) {
#line 3548
    tpac(forces, nused, itemp[1], ftemp[2], ftemp[3]);
    goto DONE;
  }
#line 3551
  tmp___106 = strcmp((char const   *)(& token[0][0]), "ppac");
#line 3551
  if (tmp___106 == 0) {
#line 3553
    ppac(forces, nused, itemp[1], ftemp[2], ftemp[3]);
    goto DONE;
  }
#line 3556
  tmp___107 = strcmp((char const   *)(& token[0][0]), "ptpac");
#line 3556
  if (tmp___107 == 0) {
#line 3558
    ptpac(forces, nused, itemp[1], ftemp[2], ftemp[3], ftemp[4]);
    goto DONE;
  }
#line 3561
  tmp___108 = strcmp((char const   *)(& token[0][0]), "hpac");
#line 3561
  if (tmp___108 == 0) {
#line 3563
    hpac(forces, potentials, nused, itemp[1], ftemp[2], ftemp[3]);
    goto DONE;
  }
#line 3566
  tmp___109 = strcmp((char const   *)(& token[0][0]), "pacpac");
#line 3566
  if (tmp___109 == 0) {
#line 3568
    pacpac(forces, nused, itemp[1], ftemp[2]);
    goto DONE;
  }
#line 3571
  tmp___110 = strcmp((char const   *)(& token[0][0]), "steep");
#line 3571
  if (tmp___110 == 0) {
#line 3573
    if (nused <= 0) {
      goto DONE;
    }
#line 3574
    steep(potentials, forces, nused, itemp[1], ftemp[2]);
    goto DONE;
  }
#line 3577
  tmp___111 = strcmp((char const   *)(& token[0][0]), "gsdg");
#line 3577
  if (tmp___111 == 0) {
#line 3579
    if (nused <= 0) {
      goto DONE;
    }
#line 3580
    gsdg(potentials, nused, itemp[1], itemp[2], itemp[3]);
    goto DONE;
  }
#line 3583
  tmp___112 = strcmp((char const   *)(& token[0][0]), "cngdel");
#line 3583
  if (tmp___112 == 0) {
#line 3585
    if (nused <= 0) {
      goto DONE;
    }
#line 3586
    cngdel(potentials, forces, nused, itemp[1], itemp[2], ftemp[3], echo);
    goto DONE;
  }
#line 3590
  tmp___114 = strcmp((char const   *)(& token[0][0]), "time");
#line 3590
  if (tmp___114 == 0) {
#line 3592
    tmp___113 = clock();
#line 3592
    fprintf(op, " %f CPU \n", (double )tmp___113 / (double )1000);
    goto DONE;
  }
#line 3596
  tmp___116 = strcmp((char const   *)(& token[0][0]), "echo");
#line 3596
  if (tmp___116 == 0) {
#line 3598
    echo = 1;
#line 3599
    tmp___115 = strcmp((char const   *)(& token[1][0]), "off");
#line 3599
    if (tmp___115 == 0) {
#line 3599
      echo = 0;
    }
    goto DONE;
  }
#line 3602
  tmp___117 = strcmp((char const   *)(& token[0][0]), "exit");
#line 3602
  if (tmp___117 == 0) {
#line 3602
    exit(0);
  }
#line 3603
  tmp___120 = strcmp((char const   *)(& token[0][0]), "loopi");
#line 3603
  if (tmp___120 == 0) {
#line 3605
    if ((int )token[1][0] == 0) {
#line 3606
      aaerror((char *)" must have a label to loop to ");
      goto DONE;
    }
#line 3607
    if (itemp[4] == 0) {
#line 3607
      itemp[4] = 1;
    }
#line 3608
    newfile = tmpfile();
#line 3609
    if ((unsigned int )newfile == (unsigned int )((void *)0)) {
#line 3610
      aaerror((char *)" cannot open temporary file in loopi");
      goto DONE;
    }
#line 3611
    loadloop(ip, newfile, & token[1][0]);
#line 3612
    if (itemp[4] > 0) {
#line 3614
      itemp[0] = itemp[2];
#line 3614
      while (itemp[0] < itemp[3]) {
#line 3616
        inloop = -1;
#line 3617
        tmp___118 = tisvariable(& token[2][0]);
#line 3617
        if (tmp___118) {
#line 3618
          set_i_variable(& token[2][0], itemp[0]);
        }
#line 3619
        rewind(newfile);
#line 3620
        //read_eval_do(newfile, op);
#line 3614
        itemp[0] += itemp[4];
      }
    } else {
#line 3623
      itemp[0] = itemp[2];
#line 3623
      while (itemp[0] < itemp[3]) {
#line 3625
        inloop = -1;
#line 3626
        tmp___119 = tisvariable(& token[2][0]);
#line 3626
        if (tmp___119) {
#line 3627
          set_i_variable(& token[2][0], itemp[0]);
        }
#line 3628
        rewind(newfile);
#line 3629
      //  read_eval_do(newfile, op);
#line 3623
        itemp[0] += itemp[4];
      }
    }
#line 3632
    inloop = 1;
#line 3633
    fclose(newfile);
    goto DONE;
  }
#line 3636
  tmp___123 = strcmp((char const   *)(& token[0][0]), "loopf");
#line 3636
  if (tmp___123 == 0) {
#line 3638
    if ((int )token[1][0] == 0) {
#line 3639
      aaerror((char *)" must have a label to loop to ");
      goto DONE;
    }
#line 3640
    if (ftemp[4] == 0.) {
#line 3640
      ftemp[4] = 1.;
    }
#line 3641
    newfile = tmpfile();
#line 3642
    if ((unsigned int )newfile == (unsigned int )((void *)0)) {
#line 3643
      aaerror((char *)" cannot open temporary file in loopi");
      goto DONE;
    }
#line 3644
    loadloop(ip, newfile, & token[1][0]);
#line 3645
    if (ftemp[4] > 0.) {
#line 3647
      ftemp[0] = ftemp[2];
#line 3647
      while (ftemp[0] < ftemp[3]) {
#line 3649
        inloop = -1;
#line 3650
        tmp___121 = tisvariable(& token[2][0]);
#line 3650
        if (tmp___121) {
#line 3651
          set_f_variable(& token[2][0], ftemp[0]);
        }
#line 3652
        rewind(newfile);
#line 3653
       // read_eval_do(newfile, op);
#line 3647
        ftemp[0] += ftemp[4];
      }
    } else {
#line 3656
      ftemp[0] = ftemp[2];
#line 3656
      while (ftemp[0] > ftemp[3]) {
#line 3658
        inloop = -1;
#line 3659
        tmp___122 = tisvariable(& token[2][0]);
#line 3659
        if (tmp___122) {
#line 3660
          set_f_variable(& token[2][0], ftemp[0]);
        }
#line 3661
        rewind(newfile);
#line 3662
       // read_eval_do(newfile, op);
#line 3656
        ftemp[0] += ftemp[4];
      }
    }
#line 3665
    inloop = 1;
    goto DONE;
  }
#line 3668
  itemp[0] = 0;
#line 3668
  while (itemp[0] < 80) {
#line 3670
    if ((int )token[0][itemp[0]] == 0) {
      goto _L___0;
    } else {
#line 3670
      if ((int )token[0][itemp[0]] == 32) {
        _L___0: /* CIL Label */ 
#line 3672
        if (itemp[0] == 0) {
#line 3672
          break;
        }
#line 3673
        if ((int )token[0][itemp[0] - 1] == 58) {
#line 3673
          return (inloop);
        }
      }
    }
#line 3668
    (itemp[0]) ++;
  }
#line 3676
  sprintf(& errmes[0], " unrecognized token >%s<", & token[0][0]);
#line 3677
  aaerror(errmes);
  DONE: 
#line 3679
  return (1);
}
}
#line 3681 "188.c"
void aaerror(char *line ) 
{ struct _reent *tmp ;

  {
#line 3683
  tmp = __getreent();
#line 3683
  fprintf(tmp->_stderr, "%s \n", line);
#line 3684
  return;
}
}
#line 3686 "188.c"
int tisvariable(char *p ) 
{ 

  {
#line 3689
  if ((int )*p != 43) {
#line 3689
    if ((int )*p != 45) {
#line 3689
      if (! ((int const   )*((_ctype_ + 1) + (unsigned int )((int )*p)) & 4)) {
#line 3689
        if ((int )*p != 46) {
#line 3690
          return (1);
        }
      }
    }
  }
#line 3691
  p ++;
#line 3692
  while (1) {
#line 3692
    if ((int )*p != 0) {
#line 3692
      if (! ((int const   )*((_ctype_ + 1) + (unsigned int )((int )*p)) & 4)) {
#line 3692
        break;
      }
    } else {
#line 3692
      break;
    }
#line 3692
    p ++;
  }
#line 3693
  if ((int )*p == 0) {
#line 3693
    return (0);
  }
#line 3694
  if ((int )*p != 46) {
#line 3694
    if ((int )*p != 101) {
#line 3694
      return (1);
    }
  }
#line 3695
  p ++;
#line 3696
  if (! ((int const   )*((_ctype_ + 1) + (unsigned int )((int )*p)) & 4)) {
#line 3697
    if ((int )*p == 0) {
#line 3697
      return (0);
    }
#line 3698
    if ((int )*p != 46) {
#line 3698
      if ((int )*p != 101) {
#line 3698
        return (1);
      }
    }
#line 3699
    p ++;
  }
#line 3701
  if ((int )*p == 0) {
#line 3701
    return (0);
  }
#line 3702
  if ((int )*p != 43) {
#line 3702
    if ((int )*p != 45) {
#line 3702
      if (! ((int const   )*((_ctype_ + 1) + (unsigned int )((int )*p)) & 4)) {
#line 3702
        if ((int )*p != 46) {
#line 3703
          return (1);
        }
      }
    }
  }
#line 3704
  p ++;
#line 3705
  if ((int )*p == 0) {
#line 3705
    return (0);
  }
#line 3706
  while (1) {
#line 3706
    if ((int )*p != 0) {
#line 3706
      if (! ((int const   )*((_ctype_ + 1) + (unsigned int )((int )*p)) & 4)) {
#line 3706
        if (! ((int )*p == 46)) {
#line 3706
          break;
        }
      }
    } else {
#line 3706
      break;
    }
#line 3706
    p ++;
  }
#line 3707
  if ((int )*p == 0) {
#line 3707
    return (0);
  }
#line 3708
  return (1);
}
}
#line 3710 "188.c"
int tisint(char *p ) 
{ char *pp ;

  {
#line 3714
  pp = p;
#line 3715
  while ((int )*pp != 0) {
#line 3716
    if ((int )*pp == 46) {
#line 3716
      return (0);
    }
#line 3716
    pp ++;
  }
#line 3717
  if ((int )*p != 43) {
#line 3717
    if ((int )*p != 45) {
#line 3717
      if (! ((int const   )*((_ctype_ + 1) + (unsigned int )((int )*p)) & 4)) {
#line 3717
        return (0);
      }
    }
  }
#line 3718
  p ++;
#line 3719
  while ((int )*p != 0) {
#line 3721
    if (! ((int const   )*((_ctype_ + 1) + (unsigned int )((int )*p)) & 4)) {
#line 3721
      return (0);
    }
#line 3722
    p ++;
  }
#line 3724
  return (1);
}
}
#line 3726 "188.c"
int loadloop(FILE *ip , FILE *tp , char *label ) 
{ char line[256] ;
  char *sp ;
  char *wp ;
  int __x ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 3731
  while (1) {
#line 3731
    tmp___1 = fgets(line, 256, ip);
#line 3731
    if (! ((unsigned int )tmp___1 != (unsigned int )((void *)0))) {
#line 3731
      break;
    }
#line 3733
    fputs((char const   *)(line), tp);
#line 3734
    fputs("\n", tp);
#line 3735
    sp = line;
#line 3736
    while (1) {
#line 3736
      if ((int )*sp == 32) {
#line 3736
        if (! ((int )*sp != 0)) {
#line 3736
          break;
        }
      } else {
#line 3736
        break;
      }
#line 3736
      sp ++;
    }
#line 3737
    if ((int )*sp != 0) {
#line 3739
      wp = sp;
#line 3740
      while (1) {
#line 3740
        if ((int )*wp != 59) {
#line 3740
          if ((int )*wp != 32) {
#line 3740
            if (! ((int )*wp != 0)) {
#line 3740
              break;
            }
          } else {
#line 3740
            break;
          }
        } else {
#line 3740
          break;
        }
#line 3741
        if ((int const   )*((_ctype_ + 1) + (unsigned int )*wp) & 1) {
#line 3741
          __x = (int )*wp;
#line 3741
          if ((int const   )*((_ctype_ + 1) + (unsigned int )__x) & 1) {
#line 3741
            tmp = (__x - 65) + 97;
          } else {
#line 3741
            tmp = __x;
          }
#line 3741
          *wp = (char )tmp;
        }
#line 3742
        wp ++;
      }
#line 3743
      if ((int )*wp == 32) {
#line 3743
        *wp = (char )'\000';
      }
#line 3744
      if ((int )*wp == 59) {
#line 3744
        *wp = (char )'\000';
      }
#line 3745
      tmp___0 = strcmp((char const   *)sp, (char const   *)label);
#line 3745
      if (tmp___0 == 0) {
#line 3745
        return (1);
      }
    }
  }
#line 3748
  aaerror((char *)" must have a label for looping ");
#line 3749
  sprintf(line, " where is >%s< label ?\n", label);
#line 3750
  aaerror(line);
#line 3751
  return (0);
}
}
#line 3768
double gsdg_line_search(double *vect , double *step , ATOM *who ) ;
#line 3810
int gsdg_noel(ATOM *ap___1 ) ;
#line 3811
int gsdg_hybrid(ATOM *who ) ;
#line 3758 "188.c"
void gsdg(int (**vfs)() , int nfs , int niter , int low_serial , int high_serial ) 
{ ATOM *ap___1 ;
  ATOM *bp ;
  int numatm ;
  int iter ;
  int i ;
  int j ;
  int k ;
  double svec[3] ;
  double rvec[3] ;
  double x ;
  double y ;
  struct _reent *tmp ;

  {
#line 3772
  numatm = a_number();
#line 3773
  if (low_serial > high_serial) {
#line 3774
    i = low_serial;
#line 3774
    low_serial = high_serial;
#line 3774
    high_serial = i;
  }
#line 3775
  if (high_serial <= 0) {
#line 3776
    i = 0;
#line 3776
    while (i < numatm) {
#line 3777
      ap___1 = a_next(i);
#line 3778
      if (high_serial < ap___1->serial) {
#line 3778
        high_serial = ap___1->serial;
      }
#line 3776
      i ++;
    }
  }
#line 3781
  iter = 0;
#line 3781
  while (iter < niter) {
#line 3783
    printf(" iter %d starting ", iter);
#line 3784
    tmp = __getreent();
#line 3784
    fflush(tmp->_stdout);
#line 3785
    ap___1 = a_next(-1);
#line 3786
    i = 0;
#line 3786
    while (i < numatm) {
#line 3788
      if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 3788
        break;
      }
#line 3789
      if (ap___1->serial >= low_serial) {
#line 3789
        if (ap___1->serial <= high_serial) {
#line 3791
          if (ap___1->active) {
#line 3792
            j = 0;
#line 3792
            while (j < numatm) {
#line 3793
              bp = a_next(j);
#line 3794
              bp->vx = 16.;
#line 3795
              bp->vy = 0.;
#line 3792
              j ++;
            }
#line 3797
            j = 0;
#line 3797
            while (j < nfs) {
#line 3799
              if ((unsigned int )*(vfs + j) == (unsigned int )(& v_nonbon)) {
                goto _L;
              } else {
#line 3799
                if ((unsigned int )*(vfs + j) == (unsigned int )(& u_v_nonbon)) {
                  _L: /* CIL Label */ 
#line 3800
                  k = 0;
#line 3800
                  while (k < numatm) {
#line 3801
                    bp = a_next(k);
#line 3802
                    bp->vy = (double )-10;
#line 3800
                    k ++;
                  }
#line 3803
                  break;
                }
              }
#line 3797
              j ++;
            }
#line 3806
            j = 0;
#line 3806
            while (j < nfs) {
#line 3808
              if ((unsigned int )*(vfs + j) == (unsigned int )(& v_bond)) {
#line 3808
                gsdg_bond(ap___1);
              } else {
#line 3808
                if ((unsigned int )*(vfs + j) == (unsigned int )(& v_mmbond)) {
#line 3808
                  gsdg_bond(ap___1);
                }
              }
#line 3809
              if ((unsigned int )*(vfs + j) == (unsigned int )(& v_angle)) {
#line 3809
                gsdg_angle(ap___1);
              } else {
#line 3809
                if ((unsigned int )*(vfs + j) == (unsigned int )(& v_mmangle)) {
#line 3809
                  gsdg_angle(ap___1);
                } else {
#line 3809
                  if ((unsigned int )*(vfs + j) == (unsigned int )(& v_c_angle)) {
#line 3809
                    gsdg_angle(ap___1);
                  }
                }
              }
#line 3810
              if ((unsigned int )*(vfs + j) == (unsigned int )(& v_noel)) {
#line 3810
                gsdg_noel(ap___1);
              }
#line 3811
              if ((unsigned int )*(vfs + j) == (unsigned int )(& v_hybrid)) {
#line 3811
                gsdg_hybrid(ap___1);
              }
#line 3806
              j ++;
            }
#line 3813
            rvec[0] = (double )0;
#line 3814
            rvec[1] = (double )0;
#line 3815
            rvec[2] = (double )0;
#line 3816
            rand3(& svec[0], & svec[1], & svec[2]);
#line 3817
            x = gsdg_line_search(svec, & y, ap___1);
#line 3818
            rvec[0] += y * svec[0];
#line 3819
            rvec[1] += y * svec[1];
#line 3820
            rvec[2] += y * svec[2];
#line 3821
            rand3(& svec[0], & svec[1], & svec[2]);
#line 3822
            x = gsdg_line_search(svec, & y, ap___1);
#line 3823
            rvec[0] += y * svec[0];
#line 3824
            rvec[1] += y * svec[1];
#line 3825
            rvec[2] += y * svec[2];
#line 3826
            rand3(& svec[0], & svec[1], & svec[2]);
#line 3827
            x = gsdg_line_search(svec, & y, ap___1);
#line 3828
            rvec[0] += y * svec[0];
#line 3829
            rvec[1] += y * svec[1];
#line 3830
            rvec[2] += y * svec[2];
#line 3831
            x = gsdg_line_search(rvec, & y, ap___1);
#line 3832
            ap___1->x += y * rvec[0];
#line 3833
            ap___1->y += y * rvec[1];
#line 3834
            ap___1->z += y * rvec[2];
          }
        }
      }
#line 3837
      if ((unsigned int )ap___1 == (unsigned int )ap___1->next) {
#line 3837
        break;
      }
#line 3838
      ap___1 = (ATOM *)ap___1->next;
#line 3786
      i ++;
    }
#line 3840
    printf(" done \n");
#line 3781
    iter ++;
  }
#line 3842
  return;
}
}
#line 3851
double gsdg_dgeom(double *vect , double lam , ATOM *who ) ;
#line 3843 "188.c"
double gsdg_line_search(double *vect , double *step , ATOM *who ) 
{ double val ;
  double vt ;
  double lam ;
  int i ;
  int j ;
  double dstep ;

  {
#line 3852
  val = gsdg_dgeom(vect, 0., who);
#line 3853
  lam = (double )0;
#line 3854
  *step = (double )0;
#line 3855
  dstep = - .5;
#line 3856
  i = 0;
#line 3856
  while (i < 3) {
#line 3858
    dstep *= - .5;
#line 3859
    j = 0;
#line 3859
    while (j < 200) {
#line 3861
      lam += dstep;
#line 3862
      vt = gsdg_dgeom(vect, lam, who);
#line 3863
      if (vt < val) {
#line 3863
        *step = lam;
#line 3863
        val = vt;
      } else {
#line 3863
        break;
      }
#line 3859
      j ++;
    }
#line 3865
    if (j == 200) {
#line 3865
      dstep *= (double )-2;
    }
#line 3856
    i ++;
  }
#line 3867
  return (val);
}
}
#line 3869 "188.c"
double gsdg_dgeom(double *vect , double lam , ATOM *who ) 
{ int numatm ;
  int i ;
  double x ;
  double y ;
  double z ;
  ATOM *ap___1 ;
  double dt ;
  double dsum ;

  {
#line 3879
  numatm = a_number();
#line 3880
  x = who->x + *(vect + 0) * lam;
#line 3881
  y = who->y + *(vect + 1) * lam;
#line 3882
  z = who->z + *(vect + 2) * lam;
#line 3883
  dsum = 0.;
#line 3884
  i = 0;
#line 3884
  while (i < numatm) {
#line 3886
    ap___1 = a_next(i);
#line 3887
    if ((unsigned int )ap___1 != (unsigned int )who) {
#line 3889
      dt = (x - ap___1->x) * (x - ap___1->x);
#line 3890
      dt += (y - ap___1->y) * (y - ap___1->y);
#line 3891
      dt += (z - ap___1->z) * (z - ap___1->z);
#line 3892
      if (ap___1->vy > (double )0) {
#line 3894
        dsum += (ap___1->vy * (ap___1->vx - dt)) * (ap___1->vx - dt);
      } else {
#line 3896
        if (ap___1->vx > dt) {
#line 3897
          dsum -= (ap___1->vy * (ap___1->vx - dt)) * (ap___1->vx - dt);
        }
      }
    }
#line 3884
    i ++;
  }
#line 3901
  return (dsum);
}
}
#line 3903 "188.c"
int v_trace(double *V , double lambda ) 
{ int numatm ;
  int i ;
  ATOM *ap___1 ;
  double xc ;
  double yc ;
  double zc ;
  double xt ;
  double yt ;
  double zt ;
  double l_trace ;

  {
#line 3911
  numatm = a_number();
#line 3912
  if (numatm < 2) {
#line 3912
    return (0);
  }
#line 3913
  l_trace = get_f_variable("trace");
#line 3914
  if (l_trace == 0.) {
#line 3914
    l_trace = 1. / (double )numatm;
  }
#line 3916
  xc = 0.;
#line 3916
  yc = 0.;
#line 3916
  zc = 0.;
#line 3917
  i = 0;
#line 3917
  while (i < numatm) {
#line 3919
    ap___1 = a_next(i);
#line 3920
    xc += ap___1->x + lambda * ap___1->dx;
#line 3921
    yc += ap___1->y + lambda * ap___1->dy;
#line 3922
    zc += ap___1->z + lambda * ap___1->dz;
#line 3917
    i ++;
  }
#line 3924
  xc /= (double )numatm;
#line 3924
  yc /= (double )numatm;
#line 3924
  zc /= (double )numatm;
#line 3925
  i = 0;
#line 3925
  while (i < numatm) {
#line 3927
    ap___1 = a_next(i);
#line 3928
    xt = (ap___1->x + lambda * ap___1->dx) - xc;
#line 3929
    yt = (ap___1->y + lambda * ap___1->dy) - yc;
#line 3930
    zt = (ap___1->z + lambda * ap___1->dz) - zc;
#line 3931
    *V -= l_trace * ((xt * xt + yt * yt) + zt * zt);
#line 3925
    i ++;
  }
#line 3933
  return (0);
}
}
#line 3935 "188.c"
int f_trace(double lambda ) 
{ int numatm ;
  int i ;
  ATOM *ap___1 ;
  double xc ;
  double yc ;
  double zc ;
  double xt ;
  double yt ;
  double zt ;
  double l_trace ;

  {
#line 3943
  numatm = a_number();
#line 3944
  if (numatm < 2) {
#line 3944
    return (0);
  }
#line 3945
  l_trace = get_f_variable("trace");
#line 3946
  if (l_trace == 0.) {
#line 3946
    l_trace = 1. / (double )numatm;
  }
#line 3948
  xc = 0.;
#line 3948
  yc = 0.;
#line 3948
  zc = 0.;
#line 3949
  i = 0;
#line 3949
  while (i < numatm) {
#line 3951
    ap___1 = a_next(i);
#line 3952
    xc += ap___1->x + lambda * ap___1->dx;
#line 3953
    yc += ap___1->y + lambda * ap___1->dy;
#line 3954
    zc += ap___1->z + lambda * ap___1->dz;
#line 3949
    i ++;
  }
#line 3956
  xc /= (double )numatm;
#line 3956
  yc /= (double )numatm;
#line 3956
  zc /= (double )numatm;
#line 3957
  l_trace = ((double )2 * l_trace) * (1. - 1. / (double )numatm);
#line 3958
  i = 0;
#line 3958
  while (i < numatm) {
#line 3960
    ap___1 = a_next(i);
#line 3961
    xt = (ap___1->x + lambda * ap___1->dx) - xc;
#line 3962
    yt = (ap___1->y + lambda * ap___1->dy) - yc;
#line 3963
    zt = (ap___1->z + lambda * ap___1->dz) - zc;
#line 3964
    ap___1->fx += l_trace * xt;
#line 3965
    ap___1->fy += l_trace * yt;
#line 3966
    ap___1->fz += l_trace * zt;
#line 3958
    i ++;
  }
#line 3968
  return (0);
}
}
#line 3981 "188.c"
HYBRID *hybrid_first  =    (HYBRID *)((void *)0);
#line 3982 "188.c"
HYBRID *hybrid_last  =    (HYBRID *)((void *)0);
#line 3983 "188.c"
int hybrid(int p1 , int p2 , int p3 , int p4 , double fk , double off ) 
{ HYBRID *new ;
  ATOM *ap1 ;
  ATOM *ap2 ;
  ATOM *ap3 ;
  ATOM *ap4 ;
  char line[80] ;
  void *tmp ;

  {
#line 3990
  ap1 = a_m_serial(p1);
#line 3991
  ap2 = a_m_serial(p2);
#line 3992
  ap3 = a_m_serial(p3);
#line 3993
  ap4 = a_m_serial(p4);
#line 3994
  if ((unsigned int )ap1 == (unsigned int )((void *)0)) {
#line 3996
    sprintf(line, "undefined atom in hybrid %d %d %d %d \000", p1, p2, p3, p4);
#line 3997
    aaerror(line);
#line 3998
    return (0);
  } else {
#line 3994
    if ((unsigned int )ap2 == (unsigned int )((void *)0)) {
#line 3996
      sprintf(line, "undefined atom in hybrid %d %d %d %d \000", p1, p2, p3, p4);
#line 3997
      aaerror(line);
#line 3998
      return (0);
    } else {
#line 3994
      if ((unsigned int )ap3 == (unsigned int )((void *)0)) {
#line 3996
        sprintf(line, "undefined atom in hybrid %d %d %d %d \000", p1, p2, p3, p4);
#line 3997
        aaerror(line);
#line 3998
        return (0);
      } else {
#line 3994
        if ((unsigned int )ap4 == (unsigned int )((void *)0)) {
#line 3996
          sprintf(line, "undefined atom in hybrid %d %d %d %d \000", p1, p2, p3, p4);
#line 3997
          aaerror(line);
#line 3998
          return (0);
        }
      }
    }
  }
#line 4000
  tmp = malloc(sizeof(HYBRID ));
#line 4000
  new = (HYBRID *)tmp;
#line 4000
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 4002
    return (0);
  }
#line 4005
  if ((unsigned int )hybrid_first == (unsigned int )((void *)0)) {
#line 4005
    hybrid_first = new;
  }
#line 4006
  if ((unsigned int )hybrid_last == (unsigned int )((void *)0)) {
#line 4006
    hybrid_last = new;
  }
#line 4007
  new->atom1 = ap1;
#line 4008
  new->atom2 = ap2;
#line 4009
  new->atom3 = ap3;
#line 4010
  new->atom4 = ap4;
#line 4011
  new->offset = off;
#line 4012
  new->k = fk;
#line 4013
  new->next = (void *)new;
#line 4014
  hybrid_last->next = (void *)new;
#line 4015
  hybrid_last = new;
#line 4016
  return (1);
}
}
#line 4018 "188.c"
int v_hybrid(double *V , double lambda ) 
{ HYBRID *bp ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double x3 ;
  double y3 ;
  double z3 ;
  double r ;
  double cx1 ;
  double cy1 ;
  double cz1 ;
  double hite ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;

  {
#line 4026
  bp = hybrid_first;
#line 4027
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 4027
    return (1);
  }
#line 4028
  while (1) {
#line 4030
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 4030
      return (0);
    }
#line 4031
    a1 = bp->atom1;
#line 4031
    a2 = bp->atom2;
#line 4031
    a3 = bp->atom3;
#line 4032
    a4 = bp->atom4;
#line 4033
    if (a1->active) {
      goto _L;
    } else {
#line 4033
      if (a2->active) {
        goto _L;
      } else {
#line 4033
        if (a3->active) {
          goto _L;
        } else {
#line 4033
          if (a4->active) {
            _L: /* CIL Label */ 
#line 4034
            x1 = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 4035
            y1___0 = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 4036
            z1 = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
#line 4037
            x2 = (a3->x - a1->x) + lambda * (a3->dx - a1->dx);
#line 4038
            y2 = (a3->y - a1->y) + lambda * (a3->dy - a1->dy);
#line 4039
            z2 = (a3->z - a1->z) + lambda * (a3->dz - a1->dz);
#line 4040
            x3 = (a4->x - a1->x) + lambda * (a4->dx - a1->dx);
#line 4041
            y3 = (a4->y - a1->y) + lambda * (a4->dy - a1->dy);
#line 4042
            z3 = (a4->z - a1->z) + lambda * (a4->dz - a1->dz);
#line 4043
            cx1 = y1___0 * z2 - y2 * z1;
#line 4044
            cy1 = - x1 * z2 + x2 * z1;
#line 4045
            cz1 = x1 * y2 - x2 * y1___0;
#line 4046
            r = (cx1 * cx1 + cy1 * cy1) + cz1 * cz1;
#line 4047
            if (r < 1.e-16) {
              goto SKIP;
            }
#line 4048
            r = sqrt(r);
#line 4049
            hite = (cx1 * x3 + cy1 * y3) + cz1 * z3;
#line 4049
            hite /= r;
#line 4050
            *V += (bp->k * (hite - bp->offset)) * (hite - bp->offset);
          }
        }
      }
    }
    SKIP: 
#line 4053
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 4053
      return (1);
    }
#line 4054
    bp = (HYBRID *)bp->next;
  }
}
}
#line 4057 "188.c"
int f_hybrid(double lambda ) 
{ HYBRID *bp ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double x3 ;
  double y3 ;
  double z3 ;
  double r ;
  double cx1 ;
  double cy1 ;
  double cz1 ;
  double dx ;
  double dy ;
  double dz ;
  double hite ;
  double df ;
  double r3 ;
  double c ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;
  ATOM *at ;
  int i ;

  {
#line 4069
  bp = hybrid_first;
#line 4070
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 4070
    return (1);
  }
#line 4071
  while (1) {
#line 4073
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 4073
      return (0);
    }
#line 4074
    a1 = bp->atom1;
#line 4074
    a2 = bp->atom2;
#line 4074
    a3 = bp->atom3;
#line 4075
    a4 = bp->atom4;
#line 4076
    if (a1->active) {
      goto _L;
    } else {
#line 4076
      if (a2->active) {
        goto _L;
      } else {
#line 4076
        if (a3->active) {
          goto _L;
        } else {
#line 4076
          if (a4->active) {
            _L: /* CIL Label */ 
#line 4077
            i = 0;
#line 4077
            while (i < 3) {
#line 4079
              x1 = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 4080
              y1___0 = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 4081
              z1 = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
#line 4082
              x2 = (a3->x - a1->x) + lambda * (a3->dx - a1->dx);
#line 4083
              y2 = (a3->y - a1->y) + lambda * (a3->dy - a1->dy);
#line 4084
              z2 = (a3->z - a1->z) + lambda * (a3->dz - a1->dz);
#line 4085
              x3 = (a4->x - a1->x) + lambda * (a4->dx - a1->dx);
#line 4086
              y3 = (a4->y - a1->y) + lambda * (a4->dy - a1->dy);
#line 4087
              z3 = (a4->z - a1->z) + lambda * (a4->dz - a1->dz);
#line 4088
              cx1 = y1___0 * z2 - y2 * z1;
#line 4089
              cy1 = - x1 * z2 + x2 * z1;
#line 4090
              cz1 = x1 * y2 - x2 * y1___0;
#line 4091
              r = (cx1 * cx1 + cy1 * cy1) + cz1 * cz1;
#line 4092
              if (r < 1.e-16) {
                goto SKIP;
              }
#line 4093
              r = sqrt(r);
#line 4093
              r3 = (r * r) * r;
#line 4094
              hite = (cx1 * x3 + cy1 * y3) + cz1 * z3;
#line 4094
              hite /= r;
#line 4095
              df = (((double )2 * bp->k) * (bp->offset - hite)) / (double )3;
#line 4096
              a4->fx += (df / r) * cx1;
#line 4097
              a4->fy += (df / r) * cy1;
#line 4098
              a4->fz += (df / r) * cz1;
#line 4099
              a1->fx -= (df / r) * cx1;
#line 4100
              a1->fy -= (df / r) * cy1;
#line 4101
              a1->fz -= (df / r) * cz1;
#line 4102
              dx = ((- cx1 * x3) / r3) * df;
#line 4103
              dy = ((- cy1 * y3) / r3) * df;
#line 4104
              dz = ((- cz1 * z3) / r3) * df;
#line 4105
              c = df * ((- y3 * z2 + z3 * y2) / r);
#line 4106
              c += dx * (y2 * (x1 * y2 - x2 * y1___0) - z2 * (x2 * z1 - x1 * z2));
#line 4107
              a2->fx += c;
#line 4107
              a1->fx -= c;
#line 4108
              c = df * ((- z3 * x2 + x3 * z2) / r);
#line 4109
              c += dy * (z2 * (y1___0 * z2 - y2 * z1) - x2 * (x1 * y2 - x2 * y1___0));
#line 4110
              a2->fy += c;
#line 4110
              a1->fy -= c;
#line 4111
              c = df * ((- x3 * y2 + y3 * x2) / r);
#line 4112
              c += dz * (x2 * (x2 * z1 - x1 * z2) - y2 * (y1___0 * z2 - y2 * z1));
#line 4113
              a2->fz += c;
#line 4113
              a1->fz -= c;
#line 4114
              c = df * ((- z3 * y1___0 + y3 * z1) / r);
#line 4115
              c -= dx * (y1___0 * (x1 * y2 - x2 * y1___0) - z1 * (x2 * z1 - x1 * z2));
#line 4116
              a3->fx += c;
#line 4116
              a1->fx -= c;
#line 4117
              c = df * ((- x3 * z1 + z3 * x1) / r);
#line 4118
              c -= dy * (z1 * (y1___0 * z2 - y2 * z1) - x1 * (x1 * y2 - x2 * y1___0));
#line 4119
              a3->fy += c;
#line 4119
              a1->fy -= c;
#line 4120
              c = df * ((- y3 * x1 + x3 * y1___0) / r);
#line 4121
              c -= dz * (x1 * (x2 * z1 - x1 * z2) - y1___0 * (y1___0 * z2 - y2 * z1));
#line 4122
              a3->fz += c;
#line 4122
              a1->fz -= c;
#line 4123
              at = a1;
#line 4123
              a1 = a2;
#line 4123
              a2 = a3;
#line 4123
              a3 = at;
#line 4077
              i ++;
            }
#line 4125
            if ((int )a1->active == 0) {
#line 4125
              a1->fx = (double )0;
#line 4125
              a1->fy = 0.;
#line 4125
              a1->fz = (double )0;
            }
#line 4126
            if ((int )a2->active == 0) {
#line 4126
              a2->fx = (double )0;
#line 4126
              a2->fy = 0.;
#line 4126
              a2->fz = (double )0;
            }
#line 4127
            if ((int )a3->active == 0) {
#line 4127
              a3->fx = (double )0;
#line 4127
              a3->fy = 0.;
#line 4127
              a3->fz = (double )0;
            }
#line 4128
            if ((int )a4->active == 0) {
#line 4128
              a4->fx = (double )0;
#line 4128
              a4->fy = 0.;
#line 4128
              a4->fz = (double )0;
            }
          }
        }
      }
    }
    SKIP: 
#line 4131
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 4131
      return (1);
    }
#line 4132
    bp = (HYBRID *)bp->next;
  }
}
}
#line 4135 "188.c"
void get_hybrid(ATOM *a1 , ATOM **bonded , int mbond , int *inbond ) 
{ HYBRID *mine ;
  int tmp ;
  int tmp___0 ;

  {
#line 4140
  mine = hybrid_first;
#line 4141
  *inbond = 0;
#line 4142
  while (1) {
#line 4144
    if ((unsigned int )mine == (unsigned int )((void *)0)) {
#line 4146
      return;
    }
#line 4148
    if ((unsigned int )mine->atom1 == (unsigned int )a1) {
#line 4150
      tmp = *inbond;
#line 4150
      (*inbond) ++;
#line 4150
      *(bonded + tmp) = mine->atom4;
    }
#line 4152
    if ((unsigned int )mine->atom4 == (unsigned int )a1) {
#line 4154
      tmp___0 = *inbond;
#line 4154
      (*inbond) ++;
#line 4154
      *(bonded + tmp___0) = mine->atom1;
    }
#line 4156
    if ((unsigned int )mine == (unsigned int )mine->next) {
#line 4156
      return;
    }
#line 4157
    mine = (HYBRID *)mine->next;
#line 4158
    if (*inbond == mbond) {
#line 4158
      return;
    }
  }
}
}
#line 4161 "188.c"
void dump_hybrids(FILE *where ) 
{ HYBRID *b ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;

  {
#line 4165
  b = hybrid_first;
#line 4166
  if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 4166
    return;
  }
#line 4167
  while ((unsigned int )b->next != (unsigned int )b) {
#line 4169
    if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 4169
      return;
    }
#line 4170
    a1 = b->atom1;
#line 4170
    a2 = b->atom2;
#line 4170
    a3 = b->atom3;
#line 4170
    a4 = b->atom4;
#line 4171
    fprintf(where, "hybrid %d %d %d %d %f %f ;\n", a1->serial, a2->serial, a3->serial,
            a4->serial, b->k, b->offset);
#line 4174
    b = (HYBRID *)b->next;
  }
#line 4176
  if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 4176
    return;
  }
#line 4177
  a1 = b->atom1;
#line 4177
  a2 = b->atom2;
#line 4177
  a3 = b->atom3;
#line 4177
  a4 = b->atom4;
#line 4178
  fprintf(where, "hybrid %d %d %d %d %f %f ;\n", a1->serial, a2->serial, a3->serial,
          a4->serial, b->k, b->offset);
#line 4181
  return;
}
}
#line 4182 "188.c"
int a_hybrid(double *V , double lambda , int ilow , int ihigh , FILE *op ) 
{ HYBRID *bp ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double x3 ;
  double y3 ;
  double z3 ;
  double r ;
  double cx1 ;
  double cy1 ;
  double cz1 ;
  double hite ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;

  {
#line 4192
  bp = hybrid_first;
#line 4193
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 4193
    return (1);
  }
#line 4194
  while (1) {
#line 4196
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 4196
      return (0);
    }
#line 4197
    a1 = bp->atom1;
#line 4197
    a2 = bp->atom2;
#line 4197
    a3 = bp->atom3;
#line 4198
    a4 = bp->atom4;
#line 4199
    if (a1->serial >= ilow) {
#line 4199
      if (a1->serial <= ihigh) {
        goto _L;
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 4199
      if (a2->serial >= ilow) {
#line 4199
        if (a2->serial <= ihigh) {
          goto _L;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 4199
        if (a3->serial >= ilow) {
#line 4199
          if (a3->serial <= ihigh) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 4199
          if (a4->serial >= ilow) {
#line 4199
            if (a4->serial <= ihigh) {
              _L: /* CIL Label */ 
#line 4204
              x1 = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 4205
              y1___0 = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 4206
              z1 = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
#line 4207
              x2 = (a3->x - a1->x) + lambda * (a3->dx - a1->dx);
#line 4208
              y2 = (a3->y - a1->y) + lambda * (a3->dy - a1->dy);
#line 4209
              z2 = (a3->z - a1->z) + lambda * (a3->dz - a1->dz);
#line 4210
              x3 = (a4->x - a1->x) + lambda * (a4->dx - a1->dx);
#line 4211
              y3 = (a4->y - a1->y) + lambda * (a4->dy - a1->dy);
#line 4212
              z3 = (a4->z - a1->z) + lambda * (a4->dz - a1->dz);
#line 4213
              cx1 = y1___0 * z2 - y2 * z1;
#line 4214
              cy1 = - x1 * z2 + x2 * z1;
#line 4215
              cz1 = x1 * y2 - x2 * y1___0;
#line 4216
              r = (cx1 * cx1 + cy1 * cy1) + cz1 * cz1;
#line 4217
              if (r < 1.e-16) {
                goto SKIP;
              }
#line 4218
              r = sqrt(r);
#line 4219
              hite = (cx1 * x3 + cy1 * y3) + cz1 * z3;
#line 4219
              hite /= r;
#line 4220
              z2 = (bp->k * (hite - bp->offset)) * (hite - bp->offset);
#line 4221
              *V += z2;
#line 4222
              fprintf(op, "Hybrid %s %d %s %d %s %d %s %d E %f value %f error %f\n",
                      a1->name, a1->serial, a2->name, a2->serial, a3->name, a3->serial,
                      a4->name, a4->serial, z2, hite, hite - bp->offset);
            }
          }
        }
      }
    }
    SKIP: 
#line 4227
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 4227
      return (1);
    }
#line 4228
    bp = (HYBRID *)bp->next;
  }
}
}
#line 4231 "188.c"
int v_ho_hybrid(double *V , double lambda ) 
{ HYBRID *bp ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double x3 ;
  double y3 ;
  double z3 ;
  double r ;
  double cx1 ;
  double cy1 ;
  double cz1 ;
  double hite ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;
  double hol ;

  {
#line 4241
  hol = get_f_variable("lambda");
#line 4242
  if (hol >= 1.) {
#line 4242
    return (0);
  }
#line 4243
  if (hol <= 0.) {
#line 4243
    hol = 0.;
  }
#line 4244
  bp = hybrid_first;
#line 4245
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 4245
    return (1);
  }
#line 4246
  while (1) {
#line 4248
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 4248
      return (0);
    }
#line 4249
    a1 = bp->atom1;
#line 4249
    a2 = bp->atom2;
#line 4249
    a3 = bp->atom3;
#line 4250
    a4 = bp->atom4;
#line 4251
    if (a1->active) {
      goto _L;
    } else {
#line 4251
      if (a2->active) {
        goto _L;
      } else {
#line 4251
        if (a3->active) {
          goto _L;
        } else {
#line 4251
          if (a4->active) {
            _L: /* CIL Label */ 
#line 4252
            x1 = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 4253
            y1___0 = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 4254
            z1 = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
#line 4255
            x2 = (a3->x - a1->x) + lambda * (a3->dx - a1->dx);
#line 4256
            y2 = (a3->y - a1->y) + lambda * (a3->dy - a1->dy);
#line 4257
            z2 = (a3->z - a1->z) + lambda * (a3->dz - a1->dz);
#line 4258
            x3 = (a4->x - a1->x) + lambda * (a4->dx - a1->dx);
#line 4259
            y3 = (a4->y - a1->y) + lambda * (a4->dy - a1->dy);
#line 4260
            z3 = (a4->z - a1->z) + lambda * (a4->dz - a1->dz);
#line 4261
            cx1 = y1___0 * z2 - y2 * z1;
#line 4262
            cy1 = - x1 * z2 + x2 * z1;
#line 4263
            cz1 = x1 * y2 - x2 * y1___0;
#line 4264
            r = (cx1 * cx1 + cy1 * cy1) + cz1 * cz1;
#line 4265
            if (r < 1.e-16) {
              goto SKIP;
            }
#line 4266
            r = sqrt(r);
#line 4267
            hite = (cx1 * x3 + cy1 * y3) + cz1 * z3;
#line 4267
            hite /= r;
#line 4268
            r = hite * (1. + hol) - bp->offset * (1. - hol);
#line 4269
            *V += (bp->k * r) * r;
          }
        }
      }
    }
    SKIP: 
#line 4272
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 4272
      return (1);
    }
#line 4273
    bp = (HYBRID *)bp->next;
  }
}
}
#line 4276 "188.c"
int f_ho_hybrid(double lambda ) 
{ HYBRID *bp ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double x3 ;
  double y3 ;
  double z3 ;
  double r ;
  double cx1 ;
  double cy1 ;
  double cz1 ;
  double dx ;
  double dy ;
  double dz ;
  double hite ;
  double df ;
  double r3 ;
  double c ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;
  ATOM *at ;
  int i ;
  double hol ;

  {
#line 4289
  hol = get_f_variable("lambda");
#line 4290
  if (hol >= 1.) {
#line 4290
    return (0);
  }
#line 4291
  if (hol <= 0.) {
#line 4291
    hol = 0.;
  }
#line 4292
  bp = hybrid_first;
#line 4293
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 4293
    return (1);
  }
#line 4294
  while (1) {
#line 4296
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 4296
      return (0);
    }
#line 4297
    a1 = bp->atom1;
#line 4297
    a2 = bp->atom2;
#line 4297
    a3 = bp->atom3;
#line 4298
    a4 = bp->atom4;
#line 4299
    if (a1->active) {
      goto _L;
    } else {
#line 4299
      if (a2->active) {
        goto _L;
      } else {
#line 4299
        if (a3->active) {
          goto _L;
        } else {
#line 4299
          if (a4->active) {
            _L: /* CIL Label */ 
#line 4300
            i = 0;
#line 4300
            while (i < 3) {
#line 4302
              x1 = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 4303
              y1___0 = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 4304
              z1 = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
#line 4305
              x2 = (a3->x - a1->x) + lambda * (a3->dx - a1->dx);
#line 4306
              y2 = (a3->y - a1->y) + lambda * (a3->dy - a1->dy);
#line 4307
              z2 = (a3->z - a1->z) + lambda * (a3->dz - a1->dz);
#line 4308
              x3 = (a4->x - a1->x) + lambda * (a4->dx - a1->dx);
#line 4309
              y3 = (a4->y - a1->y) + lambda * (a4->dy - a1->dy);
#line 4310
              z3 = (a4->z - a1->z) + lambda * (a4->dz - a1->dz);
#line 4311
              cx1 = y1___0 * z2 - y2 * z1;
#line 4312
              cy1 = - x1 * z2 + x2 * z1;
#line 4313
              cz1 = x1 * y2 - x2 * y1___0;
#line 4314
              r = (cx1 * cx1 + cy1 * cy1) + cz1 * cz1;
#line 4315
              if (r < 1.e-16) {
                goto SKIP;
              }
#line 4316
              r = sqrt(r);
#line 4316
              r3 = (r * r) * r;
#line 4317
              hite = (cx1 * x3 + cy1 * y3) + cz1 * z3;
#line 4317
              hite /= r;
#line 4318
              df = ((((double )2 * bp->k) * (1. - hol)) * ((1. - hol) * bp->offset - (1. + hol) * hite)) / (double )3;
#line 4319
              a4->fx += (df / r) * cx1;
#line 4320
              a4->fy += (df / r) * cy1;
#line 4321
              a4->fz += (df / r) * cz1;
#line 4322
              a1->fx -= (df / r) * cx1;
#line 4323
              a1->fy -= (df / r) * cy1;
#line 4324
              a1->fz -= (df / r) * cz1;
#line 4325
              dx = ((- cx1 * x3) / r3) * df;
#line 4326
              dy = ((- cy1 * y3) / r3) * df;
#line 4327
              dz = ((- cz1 * z3) / r3) * df;
#line 4328
              c = df * ((- y3 * z2 + z3 * y2) / r);
#line 4329
              c += dx * (y2 * (x1 * y2 - x2 * y1___0) - z2 * (x2 * z1 - x1 * z2));
#line 4330
              a2->fx += c;
#line 4330
              a1->fx -= c;
#line 4331
              c = df * ((- z3 * x2 + x3 * z2) / r);
#line 4332
              c += dy * (z2 * (y1___0 * z2 - y2 * z1) - x2 * (x1 * y2 - x2 * y1___0));
#line 4333
              a2->fy += c;
#line 4333
              a1->fy -= c;
#line 4334
              c = df * ((- x3 * y2 + y3 * x2) / r);
#line 4335
              c += dz * (x2 * (x2 * z1 - x1 * z2) - y2 * (y1___0 * z2 - y2 * z1));
#line 4336
              a2->fz += c;
#line 4336
              a1->fz -= c;
#line 4337
              c = df * ((- z3 * y1___0 + y3 * z1) / r);
#line 4338
              c -= dx * (y1___0 * (x1 * y2 - x2 * y1___0) - z1 * (x2 * z1 - x1 * z2));
#line 4339
              a3->fx += c;
#line 4339
              a1->fx -= c;
#line 4340
              c = df * ((- x3 * z1 + z3 * x1) / r);
#line 4341
              c -= dy * (z1 * (y1___0 * z2 - y2 * z1) - x1 * (x1 * y2 - x2 * y1___0));
#line 4342
              a3->fy += c;
#line 4342
              a1->fy -= c;
#line 4343
              c = df * ((- y3 * x1 + x3 * y1___0) / r);
#line 4344
              c -= dz * (x1 * (x2 * z1 - x1 * z2) - y1___0 * (y1___0 * z2 - y2 * z1));
#line 4345
              a3->fz += c;
#line 4345
              a1->fz -= c;
#line 4346
              at = a1;
#line 4346
              a1 = a2;
#line 4346
              a2 = a3;
#line 4346
              a3 = at;
#line 4300
              i ++;
            }
#line 4348
            if ((int )a1->active == 0) {
#line 4348
              a1->fx = (double )0;
#line 4348
              a1->fy = 0.;
#line 4348
              a1->fz = (double )0;
            }
#line 4349
            if ((int )a2->active == 0) {
#line 4349
              a2->fx = (double )0;
#line 4349
              a2->fy = 0.;
#line 4349
              a2->fz = (double )0;
            }
#line 4350
            if ((int )a3->active == 0) {
#line 4350
              a3->fx = (double )0;
#line 4350
              a3->fy = 0.;
#line 4350
              a3->fz = (double )0;
            }
#line 4351
            if ((int )a4->active == 0) {
#line 4351
              a4->fx = (double )0;
#line 4351
              a4->fy = 0.;
#line 4351
              a4->fz = (double )0;
            }
          }
        }
      }
    }
    SKIP: 
#line 4354
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 4354
      return (1);
    }
#line 4355
    bp = (HYBRID *)bp->next;
  }
}
}
#line 4358 "188.c"
int gsdg_hybrid(ATOM *who ) 
{ ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;
  double x3 ;
  double y3 ;
  double z3 ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double hite ;
  double r ;
  double cx1 ;
  double cy1 ;
  double cz1 ;
  HYBRID *hp ;

  {
#line 4368
  if ((unsigned int )hybrid_first == (unsigned int )((void *)0)) {
#line 4368
    return (0);
  }
#line 4369
  hp = hybrid_first;
#line 4370
  if (! who->active) {
#line 4370
    return (0);
  }
#line 4371
  while ((unsigned int )hp != (unsigned int )((void *)0)) {
#line 4374
    a1 = hp->atom1;
#line 4374
    a2 = hp->atom2;
#line 4374
    a3 = hp->atom3;
#line 4375
    a4 = hp->atom4;
#line 4376
    if ((unsigned int )a4 == (unsigned int )who) {
#line 4377
      x1 = a2->x - a1->x;
#line 4378
      y1___0 = a2->y - a1->y;
#line 4379
      z1 = a2->z - a1->z;
#line 4380
      x2 = a3->x - a1->x;
#line 4381
      y2 = a3->y - a1->y;
#line 4382
      z2 = a3->z - a1->z;
#line 4383
      x3 = a4->x - a1->x;
#line 4384
      y3 = a4->y - a1->y;
#line 4385
      z3 = a4->z - a1->z;
#line 4386
      cx1 = y1___0 * z2 - y2 * z1;
#line 4387
      cy1 = - x1 * z2 + x2 * z1;
#line 4388
      cz1 = x1 * y2 - x2 * y1___0;
#line 4389
      r = (cx1 * cx1 + cy1 * cy1) + cz1 * cz1;
#line 4390
      if (r < 1.e-16) {
        goto SKIP;
      }
#line 4391
      r = sqrt(r);
#line 4391
      r = 1. / r;
#line 4392
      cx1 *= r;
#line 4393
      cy1 *= r;
#line 4394
      cz1 *= r;
#line 4395
      hite = (cx1 * x3 + cy1 * y3) + cz1 * z3;
#line 4396
      hite = hp->offset - hite;
#line 4397
      cx1 *= hite;
#line 4398
      cy1 *= hite;
#line 4399
      cz1 *= hite;
#line 4400
      a4->x += cx1;
#line 4401
      a4->y += cy1;
#line 4402
      a4->z += cz1;
      SKIP: ;
    }
#line 4405
    if ((unsigned int )hp->next == (unsigned int )hp) {
#line 4405
      break;
    }
#line 4406
    hp = (HYBRID *)hp->next;
  }
#line 4408
  return (1);
}
}
#line 4429
int math_findlabel(FILE *fp , char *label ) ;
#line 4430
int math_match_atom(char *who , ATOM *ap___1 ) ;
#line 4444
double randf(void) ;
#line 4446
struct __anonstruct_VARIABLE_25 *match_variable(char *name ) ;
#line 4447
double *getatomdata(char *who ) ;
#line 4448
int validatom(char *who ) ;
#line 4454
double linmin(int (**ffs___0)() , int nfs , double damp ) ;
#line 4432 "188.c"
int math(char (*tokens)[80] , double *fvalue , int *ivalue , FILE *ip , FILE *op ,
         int echo___0 ) 
{ int adata ;
  int atype ;
  int btype ;
  double *foutpointer ;
  double *fp ;
  double fa ;
  double fb ;
  int *ioutpointer ;
  int ia ;
  int ib ;
  VARIABLE *vp ;
  VARIABLE *vos ;
  ATOM *ap___1 ;
  int i ;
  int j ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  int tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
#line 4455
  tmp = a_number();
#line 4455
  set_i_variable("numatm", tmp);
#line 4456
  tmp___0 = a_l2_f();
#line 4456
  set_f_variable((char *)"l2f", tmp___0);
#line 4457
  tmp___1 = a_max_f();
#line 4457
  set_f_variable((char *)"lmaxf", tmp___1);
#line 4459
  vp = match_variable(& (*(tokens + 1))[0]);
#line 4459
  if ((unsigned int )vp != (unsigned int )((void *)0)) {
#line 4461
    adata = 2;
#line 4462
    atype = vp->type;
#line 4463
    vos = vp;
#line 4464
    if (atype == 1) {
#line 4464
      fa = vp->value.f;
    }
#line 4465
    foutpointer = & vp->value.f;
#line 4466
    if (atype == 0) {
#line 4466
      ia = vp->value.i;
    }
#line 4467
    ioutpointer = & vp->value.i;
    goto AFOUND;
  }
#line 4470
  foutpointer = getatomdata(& (*(tokens + 1))[0]);
#line 4470
  if ((unsigned int )foutpointer != (unsigned int )((void *)0)) {
#line 4472
    adata = 0;
#line 4473
    atype = 1;
#line 4474
    fa = *foutpointer;
    goto AFOUND;
  }
#line 4477
  tmp___2 = validatom(& (*(tokens + 1))[0]);
#line 4477
  if (tmp___2 != 0) {
#line 4477
    return (1);
  }
#line 4478
  foutpointer = (double *)((void *)0);
#line 4479
  adata = 1;
#line 4480
  fa = *(fvalue + 1);
#line 4481
  ia = *(ivalue + 1);
#line 4482
  atype = 1;
#line 4483
  tmp___3 = tisint(& (*(tokens + 1))[0]);
#line 4483
  if (tmp___3 == 1) {
#line 4483
    atype = 0;
  }
  AFOUND: 
#line 4485
  vp = match_variable(& (*(tokens + 2))[0]);
#line 4485
  if ((unsigned int )vp != (unsigned int )((void *)0)) {
#line 4487
    btype = vp->type;
#line 4488
    if (btype == 1) {
#line 4488
      fb = vp->value.f;
    }
#line 4489
    if (btype == 0) {
#line 4489
      ib = vp->value.i;
    }
    goto BFOUND;
  }
#line 4492
  fp = getatomdata(& (*(tokens + 2))[0]);
#line 4492
  if ((unsigned int )fp != (unsigned int )((void *)0)) {
#line 4494
    btype = 1;
#line 4495
    fb = *fp;
    goto BFOUND;
  }
#line 4498
  tmp___4 = validatom(& (*(tokens + 2))[0]);
#line 4498
  if (tmp___4 != 0) {
#line 4498
    return (1);
  }
#line 4499
  fb = *(fvalue + 2);
#line 4500
  ib = *(ivalue + 2);
#line 4501
  btype = 1;
#line 4502
  tmp___5 = tisint(& (*(tokens + 2))[0]);
#line 4502
  if (tmp___5 == 1) {
#line 4502
    btype = 0;
  }
  BFOUND: 
#line 4504
  if (atype == 1) {
#line 4504
    ia = (int )fa;
  }
#line 4505
  if (atype == 0) {
#line 4505
    fa = (double )ia;
  }
#line 4506
  if (btype == 1) {
#line 4506
    ib = (int )fb;
  }
#line 4507
  if (btype == 0) {
#line 4507
    fb = (double )ib;
  }
#line 4508
  tmp___6 = strcmp((char const   *)(& (*(tokens + 0))[0]), "add");
#line 4508
  if (tmp___6 == 0) {
#line 4510
    if (atype == 1) {
#line 4510
      fa += fb;
    }
#line 4511
    if (atype == 0) {
#line 4511
      ia += ib;
    }
    goto GOOD_OP;
  }
#line 4514
  tmp___7 = strcmp((char const   *)(& (*(tokens + 0))[0]), "sub");
#line 4514
  if (tmp___7 == 0) {
#line 4516
    if (atype == 1) {
#line 4516
      fa -= fb;
    }
#line 4517
    if (atype == 0) {
#line 4517
      ia -= ib;
    }
    goto GOOD_OP;
  }
#line 4520
  tmp___8 = strcmp((char const   *)(& (*(tokens + 0))[0]), "mul");
#line 4520
  if (tmp___8 == 0) {
#line 4522
    if (atype == 1) {
#line 4522
      fa *= fb;
    }
#line 4523
    if (atype == 0) {
#line 4523
      ia *= ib;
    }
    goto GOOD_OP;
  }
#line 4526
  tmp___9 = strcmp((char const   *)(& (*(tokens + 0))[0]), "div");
#line 4526
  if (tmp___9 == 0) {
#line 4528
    if (atype == 1) {
#line 4528
      fa /= fb;
    }
#line 4529
    if (atype == 0) {
#line 4529
      ia /= ib;
    }
    goto GOOD_OP;
  }
#line 4532
  tmp___10 = strcmp((char const   *)(& (*(tokens + 0))[0]), "fix");
#line 4532
  if (tmp___10 == 0) {
#line 4534
    if (adata == 0) {
#line 4535
      ia = (int )fa;
#line 4536
      *foutpointer = (double )ia;
#line 4537
      if (echo___0) {
#line 4537
        fprintf(op, "%d \n", ia);
      }
#line 4538
      return (1);
    }
#line 4540
    if (atype == 1) {
#line 4540
      atype = 0;
#line 4540
      ia = (int )fa;
    }
    goto GOOD_OP;
  }
#line 4543
  tmp___13 = strcmp((char const   *)(& (*(tokens + 0))[0]), "sqrt");
#line 4543
  if (tmp___13 == 0) {
#line 4545
    if (adata == 0) {
#line 4546
      if (fa > 0.) {
#line 4547
        *foutpointer = sqrt(fa);
      } else {
#line 4549
        tmp___11 = sqrt(- fa);
#line 4549
        *foutpointer = - tmp___11;
      }
#line 4550
      if (echo___0) {
#line 4550
        fprintf(op, "%f \n", *foutpointer);
      }
#line 4551
      return (1);
    }
#line 4553
    atype = 1;
#line 4554
    if (fa > (double )0) {
#line 4554
      fa = sqrt(fa);
    } else {
#line 4555
      tmp___12 = sqrt(- fa);
#line 4555
      fa = - tmp___12;
    }
    goto GOOD_OP;
  }
#line 4558
  tmp___16 = strcmp((char const   *)(& (*(tokens + 0))[0]), "linmin");
#line 4558
  if (tmp___16 == 0) {
#line 4560
    fa = 0.;
#line 4561
    tmp___14 = a_max_d();
#line 4561
    tmp___15 = sqrt(tmp___14);
#line 4561
    fa = linmin(potentials, nused, tmp___15);
#line 4562
    if (echo___0) {
#line 4562
      fprintf(op, "%f step to minimum\n", fa);
    }
#line 4563
    a_inc_d(fa);
    goto GOOD_OP;
  }
#line 4566
  tmp___17 = strcmp((char const   *)(& (*(tokens + 0))[0]), "nop");
#line 4566
  if (tmp___17 == 0) {
    goto GOOD_OP;
  }
#line 4570
  tmp___18 = strcmp((char const   *)(& (*(tokens + 0))[0]), "mov");
#line 4570
  if (tmp___18 == 0) {
#line 4572
    ia = ib;
#line 4573
    fa = fb;
#line 4574
    atype = btype;
    goto GOOD_OP;
  }
#line 4577
  tmp___19 = strcmp((char const   *)(& (*(tokens + 0))[0]), "max");
#line 4577
  if (tmp___19 == 0) {
#line 4579
    if (atype == 1) {
#line 4579
      if (fa < fb) {
#line 4579
        fa = fb;
      }
    }
#line 4580
    if (atype == 0) {
#line 4580
      if (ia < ib) {
#line 4580
        ia = ib;
      }
    }
    goto GOOD_OP;
  }
#line 4583
  tmp___20 = strcmp((char const   *)(& (*(tokens + 0))[0]), "min");
#line 4583
  if (tmp___20 == 0) {
#line 4585
    if (atype == 1) {
#line 4585
      if (fa > fb) {
#line 4585
        fa = fb;
      }
    }
#line 4586
    if (atype == 0) {
#line 4586
      if (ia > ib) {
#line 4586
        ia = ib;
      }
    }
    goto GOOD_OP;
  }
#line 4589
  tmp___21 = strcmp((char const   *)(& (*(tokens + 0))[0]), "randf");
#line 4589
  if (tmp___21 == 0) {
#line 4591
    atype = 1;
#line 4592
    fa = randf();
    goto GOOD_OP;
  }
#line 4595
  tmp___23 = strcmp((char const   *)(& (*(tokens + 0))[0]), "serial");
#line 4595
  if (tmp___23 == 0) {
#line 4597
    ia = 100 * ib - 1;
#line 4598
    j = ia + 100;
#line 4599
    i = -1;
#line 4600
    while (1) {
#line 4600
      ap___1 = a_next(i);
#line 4600
      if (! ((unsigned int )ap___1 != (unsigned int )((void *)0))) {
#line 4600
        break;
      }
#line 4602
      i = 1;
#line 4603
      if (ap___1->serial > ia) {
#line 4603
        if (ap___1->serial < j) {
#line 4604
          tmp___22 = math_match_atom(& (*(tokens + 3))[0], ap___1);
#line 4604
          if (tmp___22 != 0) {
#line 4605
            atype = 0;
#line 4606
            ia = ap___1->serial;
            goto GOOD_OP;
          }
        }
      }
    }
#line 4610
    ia = -1;
#line 4611
    atype = 0;
    goto GOOD_OP;
  }
#line 4614
  tmp___24 = strcmp((char const   *)(& (*(tokens + 0))[0]), "index");
#line 4614
  if (tmp___24 == 0) {
#line 4616
    ap___1 = a_next(-1);
#line 4617
    i = 0;
#line 4617
    while (i < ib) {
#line 4618
      ap___1 = a_next(i);
#line 4617
      i ++;
    }
#line 4619
    ia = ap___1->serial;
#line 4620
    atype = 0;
    goto GOOD_OP;
  }
#line 4623
  tmp___26 = strcmp((char const   *)(& (*(tokens + 0))[0]), "jes");
#line 4623
  if (tmp___26 == 0) {
#line 4625
    if ((int )(*(tokens + 3))[0] == 0) {
#line 4626
      aaerror((char *)"label: required for a jump \n");
      goto GOOD_OP;
    }
#line 4627
    ap___1 = a_m_serial(ia);
#line 4627
    if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 4627
      return (1);
    }
#line 4628
    tmp___25 = strcmp((char const   *)(& ap___1->name[0]), (char const   *)(& (*(tokens + 2))[0]));
#line 4628
    if (tmp___25 == 0) {
#line 4630
      rewind(ip);
#line 4631
      math_findlabel(ip, & (*(tokens + 3))[0]);
    }
    goto GOOD_OP;
  }
#line 4635
  tmp___28 = strcmp((char const   *)(& (*(tokens + 0))[0]), "jnes");
#line 4635
  if (tmp___28 == 0) {
#line 4637
    if ((int )(*(tokens + 3))[0] == 0) {
#line 4638
      aaerror((char *)"label: required for a jump \n");
      goto GOOD_OP;
    }
#line 4639
    ap___1 = a_m_serial(ia);
#line 4640
    if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 4641
      rewind(ip);
#line 4642
      math_findlabel(ip, & (*(tokens + 3))[0]);
      goto GOOD_OP;
    }
#line 4645
    tmp___27 = strcmp((char const   *)(& ap___1->name[0]), (char const   *)(& (*(tokens + 2))[0]));
#line 4645
    if (tmp___27 != 0) {
#line 4647
      rewind(ip);
#line 4648
      math_findlabel(ip, & (*(tokens + 3))[0]);
    }
    goto GOOD_OP;
  }
#line 4652
  tmp___29 = strcmp((char const   *)(& (*(tokens + 0))[0]), "jne");
#line 4652
  if (tmp___29 == 0) {
#line 4654
    if ((int )(*(tokens + 3))[0] == 0) {
#line 4655
      aaerror((char *)"label: required for a jump \n");
      goto GOOD_OP;
    }
#line 4656
    if (atype == 0) {
#line 4656
      if (ia != ib) {
#line 4659
        rewind(ip);
#line 4660
        math_findlabel(ip, & (*(tokens + 3))[0]);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 4656
      if (atype == 1) {
#line 4656
        if (fa != fb) {
#line 4659
          rewind(ip);
#line 4660
          math_findlabel(ip, & (*(tokens + 3))[0]);
        }
      }
    }
    goto GOOD_OP;
  }
#line 4664
  tmp___30 = strcmp((char const   *)(& (*(tokens + 0))[0]), "je");
#line 4664
  if (tmp___30 == 0) {
#line 4666
    if ((int )(*(tokens + 3))[0] == 0) {
#line 4667
      aaerror((char *)"label: required for a jump \n");
      goto GOOD_OP;
    }
#line 4668
    if (atype == 0) {
#line 4668
      if (ia == ib) {
#line 4671
        rewind(ip);
#line 4672
        math_findlabel(ip, & (*(tokens + 3))[0]);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 4668
      if (atype == 1) {
#line 4668
        if (fa == fb) {
#line 4671
          rewind(ip);
#line 4672
          math_findlabel(ip, & (*(tokens + 3))[0]);
        }
      }
    }
    goto GOOD_OP;
  }
#line 4676
  tmp___31 = strcmp((char const   *)(& (*(tokens + 0))[0]), "jg");
#line 4676
  if (tmp___31 == 0) {
#line 4678
    if ((int )(*(tokens + 3))[0] == 0) {
#line 4679
      aaerror((char *)"label: required for a jump \n");
      goto GOOD_OP;
    }
#line 4680
    if (atype == 0) {
#line 4680
      if (ia > ib) {
#line 4683
        rewind(ip);
#line 4684
        math_findlabel(ip, & (*(tokens + 3))[0]);
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 4680
      if (atype == 1) {
#line 4680
        if (fa > fb) {
#line 4683
          rewind(ip);
#line 4684
          math_findlabel(ip, & (*(tokens + 3))[0]);
        }
      }
    }
    goto GOOD_OP;
  }
#line 4688
  tmp___32 = strcmp((char const   *)(& (*(tokens + 0))[0]), "jl");
#line 4688
  if (tmp___32 == 0) {
#line 4690
    if ((int )(*(tokens + 3))[0] == 0) {
#line 4691
      aaerror((char *)"label: required for a jump \n");
      goto GOOD_OP;
    }
#line 4692
    if (atype == 0) {
#line 4692
      if (ia < ib) {
#line 4695
        rewind(ip);
#line 4696
        math_findlabel(ip, & (*(tokens + 3))[0]);
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 4692
      if (atype == 1) {
#line 4692
        if (fa < fb) {
#line 4695
          rewind(ip);
#line 4696
          math_findlabel(ip, & (*(tokens + 3))[0]);
        }
      }
    }
    goto GOOD_OP;
  }
#line 4700
  return (-1);
  GOOD_OP: 
#line 4702
  tmp___33 = tisvariable(& (*(tokens + 1))[0]);
#line 4702
  if (tmp___33) {
#line 4702
    if ((int )(*(tokens + 1))[0] != 0) {
#line 4702
      if (adata == 1) {
#line 4703
        set_i_variable(& (*(tokens + 1))[0], 0);
#line 4703
        adata = 2;
#line 4704
        vos = match_variable(& (*(tokens + 1))[0]);
#line 4705
        foutpointer = & vos->value.f;
#line 4706
        ioutpointer = & vos->value.i;
      }
    }
  }
#line 4707
  if (adata != 1) {
#line 4709
    if (adata == 2) {
#line 4709
      vos->type = atype;
    }
#line 4710
    if (adata == 0) {
#line 4711
      if (atype == 0) {
#line 4711
        atype = 1;
      }
    }
#line 4713
    if (atype == 1) {
#line 4713
      if ((unsigned int )foutpointer != (unsigned int )((void *)0)) {
#line 4713
        *foutpointer = fa;
      }
    }
#line 4714
    if (atype == 0) {
#line 4714
      if ((unsigned int )ioutpointer != (unsigned int )((void *)0)) {
#line 4714
        *ioutpointer = ia;
      }
    }
  }
#line 4716
  if (echo___0) {
#line 4716
    if (atype == 0) {
#line 4716
      fprintf(op, "%d \n", ia);
    }
  }
#line 4717
  if (echo___0) {
#line 4717
    if (atype == 1) {
#line 4717
      fprintf(op, "%f \n", fa);
    }
  }
#line 4718
  return (1);
}
}
#line 4723 "188.c"
int validatom(char *who ) 
{ char *cp ;
  char *pp ;
  char *cp1 ;
  char *cp2 ;
  char *cp3 ;
  int i ;

  {
#line 4728
  cp = who;
#line 4729
  i = 0;
#line 4730
  while ((int )*cp != 0) {
#line 4732
    if ((int )*cp == 46) {
#line 4732
      i ++;
#line 4732
      pp = cp;
    }
#line 4733
    cp ++;
  }
#line 4735
  if (i != 1) {
#line 4735
    return (0);
  }
#line 4736
  cp = pp;
#line 4736
  cp ++;
#line 4737
  cp1 = cp;
#line 4737
  cp1 ++;
#line 4738
  cp2 = cp1;
#line 4738
  cp2 ++;
#line 4739
  cp3 = cp2;
#line 4739
  cp3 ++;
#line 4740
  if ((int )*cp1 == 0) {
#line 4742
    if ((int )*cp == 120) {
#line 4742
      return (1);
    }
#line 4743
    if ((int )*cp == 121) {
#line 4743
      return (2);
    }
#line 4744
    if ((int )*cp == 122) {
#line 4744
      return (3);
    }
#line 4745
    if ((int )*cp == 113) {
#line 4745
      return (13);
    }
#line 4746
    if ((int )*cp == 97) {
#line 4746
      return (14);
    }
#line 4747
    if ((int )*cp == 98) {
#line 4747
      return (15);
    }
#line 4748
    if ((int )*cp == 109) {
#line 4748
      return (16);
    }
#line 4749
    return (0);
  }
#line 4751
  if ((int )*cp2 == 0) {
#line 4753
    if ((int )*cp == 102) {
#line 4754
      if ((int )*cp1 == 120) {
#line 4754
        return (4);
      }
#line 4755
      if ((int )*cp1 == 121) {
#line 4755
        return (5);
      }
#line 4756
      if ((int )*cp1 == 122) {
#line 4756
        return (6);
      }
    }
#line 4758
    if ((int )*cp == 100) {
#line 4759
      if ((int )*cp1 == 120) {
#line 4759
        return (7);
      }
#line 4760
      if ((int )*cp1 == 121) {
#line 4760
        return (8);
      }
#line 4761
      if ((int )*cp1 == 122) {
#line 4761
        return (9);
      }
    }
#line 4763
    if ((int )*cp == 118) {
#line 4764
      if ((int )*cp1 == 120) {
#line 4764
        return (10);
      }
#line 4765
      if ((int )*cp1 == 121) {
#line 4765
        return (11);
      }
#line 4766
      if ((int )*cp1 == 122) {
#line 4766
        return (12);
      }
    }
#line 4768
    if ((int )*cp == 110) {
#line 4769
      if ((int )*cp1 == 97) {
#line 4769
        return (19);
      }
    }
  }
#line 4772
  if ((int )*cp3 == 0) {
#line 4774
    if ((int )*cp == 99) {
#line 4774
      if ((int )*cp1 == 104) {
#line 4774
        if ((int )*cp2 == 105) {
#line 4774
          return (17);
        }
      }
    }
#line 4775
    if ((int )*cp == 106) {
#line 4775
      if ((int )*cp1 == 97) {
#line 4775
        if ((int )*cp2 == 97) {
#line 4775
          return (18);
        }
      }
    }
  }
#line 4777
  return (0);
}
}
#line 4787 "188.c"
static double fx  ;
#line 4787 "188.c"
static double fy  ;
#line 4787 "188.c"
static double fz  ;
#line 4779 "188.c"
double *getatomdata(char *who ) 
{ int i ;
  int j ;
  char aser[80] ;
  char *cp ;
  ATOM *ap___1 ;
  VARIABLE *vp ;
  int tmp ;

  {
#line 4788
  i = validatom(who);
#line 4789
  if (i == 0) {
#line 4789
    return ((double *)((void *)0));
  }
#line 4791
  cp = who;
#line 4791
  j = 0;
#line 4792
  while ((int )*cp != 46) {
#line 4793
    tmp = j;
#line 4793
    j ++;
#line 4793
    aser[tmp] = *cp;
#line 4793
    cp ++;
  }
#line 4794
  aser[j] = (char )'\000';
#line 4795
  vp = match_variable(aser);
#line 4795
  if ((unsigned int )vp == (unsigned int )((void *)0)) {
#line 4796
    j = atoi((char const   *)(aser));
  } else {
#line 4797
    if (vp->type == 0) {
#line 4797
      j = vp->value.i;
    }
#line 4798
    if (vp->type == 1) {
#line 4798
      j = (int )vp->value.f;
    }
  }
#line 4800
  ap___1 = a_m_serial(j);
#line 4801
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 4801
    return ((double *)((void *)0));
  }
#line 4802
  if (i == 1) {
#line 4802
    return (& ap___1->x);
  }
#line 4803
  if (i == 2) {
#line 4803
    return (& ap___1->y);
  }
#line 4804
  if (i == 3) {
#line 4804
    return (& ap___1->z);
  }
#line 4805
  if (i == 4) {
#line 4805
    fx = ap___1->fx;
#line 4805
    return (& fx);
  }
#line 4806
  if (i == 5) {
#line 4806
    fy = ap___1->fy;
#line 4806
    return (& fy);
  }
#line 4807
  if (i == 6) {
#line 4807
    fz = ap___1->fz;
#line 4807
    return (& fz);
  }
#line 4808
  if (i == 7) {
#line 4808
    return (& ap___1->dx);
  }
#line 4809
  if (i == 8) {
#line 4809
    return (& ap___1->dy);
  }
#line 4810
  if (i == 9) {
#line 4810
    return (& ap___1->dz);
  }
#line 4811
  if (i == 10) {
#line 4811
    return (& ap___1->vx);
  }
#line 4812
  if (i == 11) {
#line 4812
    return (& ap___1->vy);
  }
#line 4813
  if (i == 12) {
#line 4813
    return (& ap___1->vz);
  }
#line 4814
  if (i == 13) {
#line 4814
    return (& ap___1->q);
  }
#line 4815
  if (i == 14) {
#line 4815
    return (& ap___1->a);
  }
#line 4816
  if (i == 15) {
#line 4816
    return (& ap___1->b);
  }
#line 4817
  if (i == 16) {
#line 4817
    return (& ap___1->mass);
  }
#line 4818
  if (i == 17) {
#line 4818
    return (& ap___1->chi);
  }
#line 4819
  if (i == 18) {
#line 4819
    return (& ap___1->jaa);
  }
#line 4820
  return ((double *)((void *)0));
}
}
#line 4822 "188.c"
int math_match_atom(char *who , ATOM *ap___1 ) 
{ char *cp ;
  int tmp ;

  {
#line 4827
  cp = & ap___1->name[0];
#line 4828
  while ((int )*cp != 46) {
#line 4830
    if ((int )*cp == 0) {
#line 4830
      return (0);
    }
#line 4831
    cp ++;
  }
#line 4833
  cp ++;
#line 4834
  tmp = strcmp((char const   *)who, (char const   *)cp);
#line 4834
  if (tmp == 0) {
#line 4835
    return (1);
  }
#line 4836
  return (0);
}
}
#line 4838 "188.c"
int math_findlabel(FILE *fp , char *label ) 
{ char *cp ;
  char *lp ;
  char llabel[80] ;
  char myline[80] ;
  int inmyline ;
  int i ;
  char ac ;
  int tmp ;
  int tmp___0 ;

  {
#line 4846
  cp = label;
#line 4847
  lp = & llabel[0];
#line 4848
  while ((int )*cp != 0) {
#line 4850
    *lp = *cp;
#line 4850
    lp ++;
#line 4850
    cp ++;
  }
#line 4852
  cp = lp;
#line 4852
  cp --;
#line 4853
  if ((int )*cp != 58) {
#line 4853
    *lp = (char )':';
#line 4853
    lp ++;
  }
#line 4854
  *lp = (char )'\000';
#line 4855
  inmyline = 0;
#line 4856
  lp = & llabel[0];
#line 4857
  while (1) {
#line 4857
    i = fgetc(fp);
#line 4857
    if (! (i != -1)) {
#line 4857
      break;
    }
#line 4859
    ac = (char )i;
#line 4860
    if (! ((int const   )*((_ctype_ + 1) + (unsigned int )((int )ac)) & 8)) {
#line 4862
      if ((int )ac == 59) {
#line 4864
        myline[inmyline] = (char )'\000';
#line 4865
        tmp = strcmp((char const   *)lp, (char const   *)(& myline[0]));
#line 4865
        if (tmp == 0) {
#line 4865
          return (0);
        }
#line 4866
        inmyline = 0;
      } else {
#line 4868
        if (inmyline > 80) {
#line 4868
          inmyline = 0;
        }
#line 4869
        tmp___0 = inmyline;
#line 4869
        inmyline ++;
#line 4869
        myline[tmp___0] = ac;
      }
    }
  }
#line 4873
  return (0);
}
}
#line 4881 "188.c"
ATOM *mom_list[100]  ;
#line 4882 "188.c"
int in_mom_list  =    0;
#line 4892
double mom_jab(double r , double j1___0 , double j2 ) ;
#line 4926
int mom_solve(double (*matrix)[] , double (*vector)[] , int irow , int ilead ) ;
#line 4883 "188.c"
void mom(FILE *op , double tq , int niter ) 
{ double (*v)[] ;
  double (*Z)[] ;
  double (*Zk)[] ;
  double r ;
  double dx ;
  double dy ;
  double dz ;
  double dv ;
  double tv ;
  int i ;
  int j ;
  int row ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 4893
  if (in_mom_list == 0) {
#line 4893
    return;
  }
#line 4894
  if (niter <= 0) {
#line 4894
    niter = 20;
  }
#line 4895
  tmp = malloc((unsigned int )in_mom_list * sizeof(double ));
#line 4895
  v = (double (*)[])tmp;
#line 4896
  tmp___0 = malloc((unsigned int )(in_mom_list * in_mom_list) * sizeof(double ));
#line 4896
  Z = (double (*)[])tmp___0;
#line 4897
  tmp___1 = malloc((unsigned int )(in_mom_list * in_mom_list) * sizeof(double ));
#line 4897
  Zk = (double (*)[])tmp___1;
#line 4898
  if ((unsigned int )v == (unsigned int )((void *)0)) {
#line 4899
    aaerror((char *)" cannot allocate memory in mom\n");
#line 4899
    return;
  } else {
#line 4898
    if ((unsigned int )Z == (unsigned int )((void *)0)) {
#line 4899
      aaerror((char *)" cannot allocate memory in mom\n");
#line 4899
      return;
    } else {
#line 4898
      if ((unsigned int )Zk == (unsigned int )((void *)0)) {
#line 4899
        aaerror((char *)" cannot allocate memory in mom\n");
#line 4899
        return;
      }
    }
  }
#line 4900
  row = in_mom_list;
#line 4901
  i = 0;
#line 4901
  while (i < row) {
#line 4902
    j = i + 1;
#line 4902
    while (j < row) {
#line 4904
      dx = (mom_list[j])->x - (mom_list[i])->x;
#line 4905
      dy = (mom_list[j])->y - (mom_list[i])->y;
#line 4906
      dz = (mom_list[j])->z - (mom_list[i])->z;
#line 4907
      r = sqrt((dx * dx + dy * dy) + dz * dz);
#line 4908
      (*Zk)[i + j * row] = mom_jab(r, (mom_list[i])->jaa, (mom_list[j])->jaa);
#line 4909
      (*Zk)[j + i * row] = (*Zk)[i + j * row];
#line 4902
      j ++;
    }
#line 4901
    i ++;
  }
#line 4911
  i = 0;
#line 4911
  while (i < row) {
#line 4912
    (*Zk)[i + i * row] = (mom_list[i])->jaa / (double )2;
#line 4911
    i ++;
  }
#line 4913
  dv = (double )0;
#line 4914
  j = 0;
#line 4914
  while (j < niter) {
#line 4916
    i = 0;
#line 4916
    while (i < row * row) {
#line 4917
      (*Z)[i] = (*Zk)[i];
#line 4916
      i ++;
    }
#line 4918
    i = 0;
#line 4918
    while (i < row) {
#line 4919
      (*v)[i] = - (mom_list[i])->chi;
#line 4918
      i ++;
    }
#line 4920
    tv = 0.;
#line 4921
    i = 0;
#line 4921
    while (i < row) {
#line 4922
      tv += (*v)[i];
#line 4921
      i ++;
    }
#line 4923
    tv = tv / (double )row + dv;
#line 4924
    i = 0;
#line 4924
    while (i < row) {
#line 4925
      (*v)[i] -= tv;
#line 4924
      i ++;
    }
#line 4926
    mom_solve(Z, v, row, row);
#line 4927
    tv = 0.;
#line 4928
    i = 0;
#line 4928
    while (i < row) {
#line 4930
      tv += (*v)[i];
#line 4928
      i ++;
    }
#line 4933
    dv += ((14.4 * (tv - tq)) / (double )row) * .25;
#line 4934
    fprintf(op, "MoM iter %d error %e\n", j, tv - tq);
#line 4914
    j ++;
  }
#line 4936
  i = 0;
#line 4936
  while (i < row) {
#line 4938
    (mom_list[i])->q = (*v)[i];
#line 4936
    i ++;
  }
#line 4940
  free((void *)Zk);
#line 4940
  free((void *)Z);
#line 4940
  free((void *)v);
#line 4940
  in_mom_list = 0;
#line 4941
  return;
}
}
#line 4942 "188.c"
void mom_add(int s1 , int s2 ) 
{ int i ;
  int j ;
  ATOM *ap___1 ;
  int numatm ;
  int tmp ;
  int tmp___0 ;

  {
#line 4948
  numatm = a_number();
#line 4949
  if (numatm == 0) {
#line 4949
    return;
  }
#line 4950
  if (s2 > 0) {
#line 4950
    if (s1 > s2) {
#line 4951
      i = s1;
#line 4951
      s1 = s2;
#line 4951
      s2 = i;
    }
  }
#line 4952
  if (s2 > s1) {
#line 4954
    i = 0;
#line 4954
    while (i < numatm) {
#line 4956
      ap___1 = a_next(i);
#line 4957
      if (ap___1->serial >= s1) {
#line 4957
        if (ap___1->serial <= s2) {
#line 4959
          if (ap___1->chi > 0.) {
#line 4959
            if (ap___1->jaa > 0.) {
#line 4961
              j = 0;
#line 4961
              while (j < in_mom_list) {
#line 4962
                if ((unsigned int )mom_list[j] == (unsigned int )ap___1) {
                  goto THERE_NOW;
                }
#line 4961
                j ++;
              }
#line 4963
              tmp = in_mom_list;
#line 4963
              in_mom_list ++;
#line 4963
              mom_list[tmp] = ap___1;
              THERE_NOW: 
#line 4965
              if (in_mom_list == 100) {
#line 4965
                in_mom_list --;
              }
            }
          }
        }
      }
#line 4954
      i ++;
    }
#line 4969
    return;
  }
#line 4971
  ap___1 = a_m_serial(s1);
#line 4971
  if ((unsigned int )ap___1 != (unsigned int )((void *)0)) {
#line 4973
    if (ap___1->chi > 0.) {
#line 4973
      if (ap___1->jaa > 0.) {
#line 4975
        j = 0;
#line 4975
        while (j < in_mom_list) {
#line 4976
          if ((unsigned int )ap___1 == (unsigned int )mom_list[j]) {
            goto THERE_AGAIN;
          }
#line 4975
          j ++;
        }
#line 4977
        tmp___0 = in_mom_list;
#line 4977
        in_mom_list ++;
#line 4977
        mom_list[tmp___0] = ap___1;
        THERE_AGAIN: 
#line 4979
        if (in_mom_list == 100) {
#line 4979
          in_mom_list --;
        }
      }
    }
  }
#line 4982
  return;
}
}
#line 4983 "188.c"
void mom_param(int serial , double chi , double jaa ) 
{ ATOM *ap___1 ;

  {
#line 4986
  ap___1 = a_m_serial(serial);
#line 4986
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 4987
    aaerror((char *)" MOM> cannot modify non-extant atom ");
#line 4987
    return;
  }
#line 4988
  ap___1->chi = chi;
#line 4989
  ap___1->jaa = jaa;
#line 4990
  return;
}
}
#line 4991 "188.c"
double mom_jab(double r , double j1___0 , double j2 ) 
{ double a ;
  double b ;
  double b2 ;
  double tmp ;

  {
#line 4996
  if (r < 30.) {
#line 4999
    tmp = sqrt(j1___0 * j2);
#line 4999
    a = tmp / 2.;
#line 5001
    r = 1.1 * r;
#line 5002
    b = exp(- r);
#line 5003
    b2 = 1. + (((double )15 * r - ((double )9 * r) * r) - (r * r) * r) / 48.;
#line 5004
    return ((a / r) * (b * b2));
  }
#line 5006
  return ((14.4 / r) / (double )2);
}
}
#line 5008 "188.c"
int mom_solve(double (*matrix)[] , double (*vector)[] , int irow , int ilead ) 
{ double quotient ;
  int i ;
  int j ;
  int k ;
  int mpi ;
  int mpj ;
  int mpk ;

  {
#line 5016
  mpi = 0;
#line 5017
  i = 0;
#line 5017
  while (i < irow - 1) {
#line 5019
    j = i;
#line 5020
    mpj = mpi;
#line 5021
    while ((*matrix)[mpi + i] == (double )0) {
#line 5023
      if (j == irow) {
#line 5024
        return (-1);
      }
#line 5025
      j ++;
#line 5026
      mpj += ilead;
#line 5027
      (*vector)[i] += (*vector)[j];
#line 5028
      k = i;
#line 5028
      while (k < irow) {
#line 5029
        (*matrix)[mpi + k] += (*matrix)[mpj + k];
#line 5028
        k ++;
      }
    }
#line 5031
    mpj = mpi + ilead;
#line 5032
    j = i + 1;
#line 5032
    while (j < irow) {
#line 5034
      if ((*matrix)[mpj + i] != (double )0) {
#line 5036
        quotient = (*matrix)[mpj + i] / (*matrix)[mpi + i];
#line 5037
        (*vector)[j] -= (*vector)[i] * quotient;
#line 5038
        k = i;
#line 5038
        while (k < irow) {
#line 5039
          (*matrix)[mpj + k] -= (*matrix)[mpi + k] * quotient;
#line 5038
          k ++;
        }
      }
#line 5041
      mpj += ilead;
#line 5032
      j ++;
    }
#line 5043
    mpi += ilead;
#line 5017
    i ++;
  }
#line 5045
  mpi = 0;
#line 5046
  i = 0;
#line 5046
  while (i < irow - 1) {
#line 5048
    k = (irow - i) - 1;
#line 5049
    mpj = 0;
#line 5050
    mpk = k * ilead;
#line 5051
    j = 0;
#line 5051
    while (j < k) {
#line 5052
      (*vector)[j] -= ((*matrix)[mpj + k] / (*matrix)[mpk + k]) * (*vector)[k];
#line 5053
      mpj += ilead;
#line 5051
      j ++;
    }
#line 5046
    i ++;
  }
#line 5055
  mpi = 0;
#line 5056
  i = 0;
#line 5056
  while (i < irow) {
#line 5057
    (*vector)[i] /= (*matrix)[mpi + i];
#line 5058
    mpi += ilead;
#line 5056
    i ++;
  }
#line 5059
  return (0);
}
}
#line 5066 "188.c"
void AMMPmonitor(int (**vfs)() , int (**ffs___0)() , int nfs , FILE *op ) 
{ double mxdq ;
  double V ;
  double T ;
  double vt ;
  ATOM *ap___1 ;
  int ifs ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 5089
  tmp = a_number();
#line 5089
  if (tmp < 1) {
#line 5090
    aaerror((char *)" no atoms defined - nothing to calculate \n");
#line 5090
    return;
  }
#line 5091
  V = 0.;
#line 5091
  T = 0.;
#line 5092
  a_f_zero();
#line 5093
  ifs = 0;
#line 5093
  while (ifs < nfs) {
#line 5095
    vt = 0.;
#line 5096
  //  (*(*(vfs + ifs)))(& vt, 0.);
#line 5097
    mxdq = get_f_variable("mxdq");
#line 5098
    set_f_variable((char *)"mxdq", 100.);
#line 5099
   // (*(*(ffs___0 + ifs)))(0.);
#line 5100
    set_f_variable((char *)"mxdq", mxdq);
#line 5101
    V += vt;
#line 5102
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_bond)) {
#line 5103
      fprintf(op, " %f bond energy\n", vt);
      goto DONE;
    }
#line 5104
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_ho_bond)) {
#line 5105
      fprintf(op, " %f homotopy bond energy\n", vt);
#line 5106
      vt = (double )0;
#line 5106
      v_bond(& vt, 0.);
#line 5107
      fprintf(op, " %f bond energy\n", vt);
      goto DONE;
    }
#line 5109
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_mmbond)) {
#line 5110
      fprintf(op, " %f mm bond energy\n", vt);
      goto DONE;
    }
#line 5111
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_c_angle)) {
#line 5112
      fprintf(op, " %f cangle energy\n", vt);
      goto DONE;
    }
#line 5113
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_mmangle)) {
#line 5114
      fprintf(op, " %f mm angle energy\n", vt);
      goto DONE;
    }
#line 5115
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_angle)) {
#line 5116
      fprintf(op, " %f angle energy\n", vt);
      goto DONE;
    }
#line 5117
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_ho_angle)) {
#line 5118
      fprintf(op, " %f homotopy angle energy\n", vt);
#line 5119
      vt = 0.;
#line 5119
      v_angle(& vt, 0.);
#line 5120
      fprintf(op, " %f angle energy\n", vt);
      goto DONE;
    }
#line 5122
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_noel)) {
#line 5123
      fprintf(op, " %f noel energy\n", vt);
      goto DONE;
    }
#line 5124
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_ho_noel)) {
#line 5125
      fprintf(op, " %f homotopy noel energy\n", vt);
#line 5126
      vt = 0.;
#line 5126
      v_noel(& vt, 0.);
#line 5127
      fprintf(op, " %f noel energy\n", vt);
      goto DONE;
    }
#line 5129
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& u_v_nonbon)) {
#line 5130
      fprintf(op, " %f non-bonded energy\n", vt);
      goto DONE;
    }
#line 5131
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_nonbon)) {
#line 5132
      fprintf(op, " %f non-bonded energy\n", vt);
      goto DONE;
    }
#line 5133
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_torsion)) {
#line 5134
      fprintf(op, " %f torsion energy\n", vt);
      goto DONE;
    }
#line 5135
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_hybrid)) {
#line 5136
      fprintf(op, " %f hybrid energy\n", vt);
      goto DONE;
    }
#line 5137
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_tether)) {
#line 5138
      fprintf(op, " %f tether restraint energy\n", vt);
      goto DONE;
    }
#line 5139
    if ((unsigned int )*(vfs + ifs) == (unsigned int )(& v_restrain)) {
#line 5140
      fprintf(op, " %f restraint bond energy\n", vt);
      goto DONE;
    }
#line 5141
    fprintf(op, " %f unknown potential type\n", vt);
    DONE: 
#line 5143
    vt = 0.;
#line 5093
    ifs ++;
  }
#line 5145
  fprintf(op, " %f total potential energy\n", V);
#line 5146
  tmp___0 = a_l2_f();
#line 5146
  set_f_variable((char *)"l2f", tmp___0);
#line 5147
  tmp___1 = a_max_f();
#line 5147
  set_f_variable((char *)"lmaxf", tmp___1);
#line 5148
  set_f_variable((char *)"totalp", V);
#line 5149
  ifs = -1;
#line 5150
  while (1) {
#line 5150
    ap___1 = a_next(ifs);
#line 5150
    if (! ((unsigned int )ap___1 != (unsigned int )((void *)0))) {
#line 5150
      break;
    }
#line 5152
    ifs = 1;
#line 5153
    T += (ap___1->vx * ap___1->vx) * ap___1->mass;
#line 5154
    T += (ap___1->vy * ap___1->vy) * ap___1->mass;
#line 5155
    T += (ap___1->vz * ap___1->vz) * ap___1->mass;
  }
#line 5157
  T = (((T * .5) / 4.184) / (double )1000) / (double )1000;
#line 5158
  set_f_variable((char *)"totalk", T);
#line 5159
  fprintf(op, " %f total kinetic energy\n", T);
#line 5160
  fprintf(op, " %f total energy\n", T + V);
#line 5161
  fprintf(op, " %f total action\n", T - V);
#line 5162
  return;
}
}
#line 5163 "188.c"
void AMMPmonitor_mute(int (**vfs)() , int (**ffs___0)() , int nfs , FILE *op ) 
{ double mxdq ;
  double V ;
  double T ;
  double vt ;
  ATOM *ap___1 ;
  int ifs ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 5186
  tmp = a_number();
#line 5186
  if (tmp < 1) {
#line 5187
    aaerror((char *)" no atoms defined - nothing to calculate \n");
#line 5187
    return;
  }
#line 5188
  V = 0.;
#line 5188
  T = 0.;
#line 5189
  a_f_zero();
#line 5190
  ifs = 0;
#line 5190
  while (ifs < nfs) {
#line 5192
    vt = 0.;
#line 5193
   // (*(*(vfs + ifs)))(& vt, 0.);
#line 5194
    mxdq = get_f_variable("mxdq");
#line 5195
    set_f_variable((char *)"mxdq", 100.);
#line 5196
   // (*(*(ffs___0 + ifs)))(0.);
#line 5197
    set_f_variable((char *)"mxdq", mxdq);
#line 5198
    V += vt;
#line 5190
    ifs ++;
  }
#line 5244
  tmp___0 = a_l2_f();
#line 5244
  set_f_variable((char *)"l2f", tmp___0);
#line 5245
  tmp___1 = a_max_f();
#line 5245
  set_f_variable((char *)"lmaxf", tmp___1);
#line 5246
  set_f_variable((char *)"totalp", V);
#line 5247
  ifs = -1;
#line 5248
  while (1) {
#line 5248
    ap___1 = a_next(ifs);
#line 5248
    if (! ((unsigned int )ap___1 != (unsigned int )((void *)0))) {
#line 5248
      break;
    }
#line 5250
    ifs = 1;
#line 5251
    T += (ap___1->vx * ap___1->vx) * ap___1->mass;
#line 5252
    T += (ap___1->vy * ap___1->vy) * ap___1->mass;
#line 5253
    T += (ap___1->vz * ap___1->vz) * ap___1->mass;
  }
#line 5255
  T = (((T * .5) / 4.184) / (double )1000) / (double )1000;
#line 5256
  set_f_variable((char *)"totalk", T);
#line 5257
  fprintf(op, " %f total energy\n", T + V);
#line 5258
  return;
}
}
#line 5270 "188.c"
NOEL *noel_first  =    (NOEL *)((void *)0);
#line 5271 "188.c"
NOEL *noel_last  =    (NOEL *)((void *)0);
#line 5272 "188.c"
int noel(int p1 , int p2 , double d , double dm , double dh , double km , double kh ) 
{ ATOM *ap1 ;
  ATOM *ap2 ;
  NOEL *new ;
  char line[80] ;
  void *tmp ;

  {
#line 5279
  ap1 = a_m_serial(p1);
#line 5280
  ap2 = a_m_serial(p2);
#line 5281
  if ((unsigned int )ap1 == (unsigned int )((void *)0)) {
#line 5283
    sprintf(line, "undefined atom in noel %d %d \000", p1, p2);
#line 5284
    aaerror(line);
#line 5285
    return (0);
  } else {
#line 5281
    if ((unsigned int )ap2 == (unsigned int )((void *)0)) {
#line 5283
      sprintf(line, "undefined atom in noel %d %d \000", p1, p2);
#line 5284
      aaerror(line);
#line 5285
      return (0);
    }
  }
#line 5287
  new = noel_first;
#line 5288
  if ((unsigned int )new != (unsigned int )((void *)0)) {
#line 5290
    while (! ((unsigned int )new == (unsigned int )((void *)0))) {
#line 5293
      if ((unsigned int )new->atom1 == (unsigned int )ap1) {
#line 5293
        if ((unsigned int )new->atom2 == (unsigned int )ap2) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 5293
        if ((unsigned int )new->atom1 == (unsigned int )ap2) {
#line 5293
          if ((unsigned int )new->atom2 == (unsigned int )ap1) {
            _L: /* CIL Label */ 
#line 5296
            new->d = d;
#line 5296
            new->dm = dm;
#line 5296
            new->dh = dh;
#line 5297
            new->km = km;
#line 5297
            new->kh = kh;
#line 5297
            return (1);
          }
        }
      }
#line 5299
      if ((unsigned int )new == (unsigned int )new->next) {
#line 5299
        break;
      }
#line 5300
      new = (NOEL *)new->next;
    }
  }
#line 5303
  tmp = malloc(sizeof(NOEL ));
#line 5303
  new = (NOEL *)tmp;
#line 5303
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 5305
    return (0);
  }
#line 5308
  if ((unsigned int )noel_first == (unsigned int )((void *)0)) {
#line 5308
    noel_first = new;
  }
#line 5309
  if ((unsigned int )noel_last == (unsigned int )((void *)0)) {
#line 5309
    noel_last = new;
  }
#line 5310
  new->atom1 = ap1;
#line 5311
  new->atom2 = ap2;
#line 5312
  new->d = d;
#line 5312
  new->dm = dm;
#line 5312
  new->dh = dh;
#line 5313
  new->km = km;
#line 5313
  new->kh = kh;
#line 5314
  new->next = (void *)new;
#line 5315
  noel_last->next = (void *)new;
#line 5316
  noel_last = new;
#line 5317
  return (1);
}
}
#line 5319 "188.c"
int v_noel(double *V , double lambda ) 
{ NOEL *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 5325
  bp = noel_first;
#line 5326
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 5326
    return (1);
  }
#line 5327
  while (1) {
#line 5329
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 5329
      return (0);
    }
#line 5330
    a1 = bp->atom1;
#line 5330
    a2 = bp->atom2;
#line 5331
    if (a1->active) {
      goto _L;
    } else {
#line 5331
      if (a2->active) {
        _L: /* CIL Label */ 
#line 5332
        if (lambda == 0.) {
#line 5334
          r = (a1->x - a2->x) * (a1->x - a2->x);
#line 5335
          r += (a1->y - a2->y) * (a1->y - a2->y);
#line 5336
          r += (a1->z - a2->z) * (a1->z - a2->z);
        } else {
#line 5339
          xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 5340
          yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 5341
          zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 5342
          r = (xt * xt + yt * yt) + zt * zt;
        }
#line 5344
        r = sqrt(r);
#line 5345
        if (r < bp->d - bp->dm) {
#line 5347
          r = (r - bp->d) + bp->dm;
#line 5348
          *V += (bp->km * r) * r;
        } else {
#line 5349
          if (r > bp->d + bp->dh) {
#line 5350
            r = (r - bp->d) - bp->dh;
#line 5351
            *V += (bp->kh * r) * r;
          }
        }
      }
    }
#line 5354
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 5354
      return (1);
    }
#line 5355
    bp = (NOEL *)bp->next;
  }
}
}
#line 5358 "188.c"
int f_noel(double lambda ) 
{ NOEL *bp ;
  double r ;
  double ux ;
  double uy ;
  double uz ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 5364
  bp = noel_first;
#line 5365
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 5365
    return (1);
  }
#line 5366
  while (1) {
#line 5368
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 5368
      return (0);
    }
#line 5369
    a1 = bp->atom1;
#line 5369
    a2 = bp->atom2;
#line 5370
    if (a1->active) {
      goto _L;
    } else {
#line 5370
      if (a2->active) {
        _L: /* CIL Label */ 
#line 5371
        if (lambda == 0.) {
#line 5373
          ux = a2->x - a1->x;
#line 5374
          uy = a2->y - a1->y;
#line 5375
          uz = a2->z - a1->z;
        } else {
#line 5377
          ux = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 5378
          uy = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 5379
          uz = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
        }
#line 5381
        r = (ux * ux + uy * uy) + uz * uz;
#line 5383
        if (r <= 1.e-5) {
#line 5384
          r = (double )0;
#line 5384
          ux = 1.;
#line 5384
          uy = 0.;
#line 5384
          uz = 0.;
        } else {
#line 5385
          r = sqrt(r);
#line 5385
          ux /= r;
#line 5385
          uy /= r;
#line 5385
          uz /= r;
        }
#line 5387
        if (r < bp->d - bp->dm) {
#line 5389
          r = (r - bp->d) + bp->dm;
#line 5390
          ux = (((double )2 * bp->km) * r) * ux;
#line 5391
          uy = (((double )2 * bp->km) * r) * uy;
#line 5392
          uz = (((double )2 * bp->km) * r) * uz;
        } else {
#line 5393
          if (r > bp->d + bp->dh) {
#line 5394
            r = (r - bp->d) - bp->dh;
#line 5395
            ux = (((double )2 * bp->kh) * r) * ux;
#line 5396
            uy = (((double )2 * bp->kh) * r) * uy;
#line 5397
            uz = (((double )2 * bp->kh) * r) * uz;
          } else {
#line 5399
            ux = 0.;
#line 5399
            uy = 0.;
#line 5399
            uz = 0.;
          }
        }
#line 5401
        if (a1->active) {
#line 5402
          a1->fx += ux;
#line 5403
          a1->fy += uy;
#line 5404
          a1->fz += uz;
        }
#line 5406
        if (a2->active) {
#line 5407
          a2->fx -= ux;
#line 5408
          a2->fy -= uy;
#line 5409
          a2->fz -= uz;
        }
      }
    }
#line 5412
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 5412
      return (1);
    }
#line 5413
    bp = (NOEL *)bp->next;
  }
}
}
#line 5416 "188.c"
void get_noel(ATOM *a1 , ATOM **noeled , int mnoel , int *innoel ) 
{ NOEL *mine ;
  int tmp ;
  int tmp___0 ;

  {
#line 5421
  mine = noel_first;
#line 5422
  *innoel = 0;
#line 5423
  while (1) {
#line 5425
    if ((unsigned int )mine == (unsigned int )((void *)0)) {
#line 5427
      return;
    }
#line 5429
    if ((unsigned int )mine->atom1 == (unsigned int )a1) {
#line 5431
      tmp = *innoel;
#line 5431
      (*innoel) ++;
#line 5431
      *(noeled + tmp) = mine->atom2;
    }
#line 5433
    if ((unsigned int )mine->atom2 == (unsigned int )a1) {
#line 5435
      tmp___0 = *innoel;
#line 5435
      (*innoel) ++;
#line 5435
      *(noeled + tmp___0) = mine->atom1;
    }
#line 5437
    if ((unsigned int )mine == (unsigned int )mine->next) {
#line 5437
      return;
    }
#line 5438
    mine = (NOEL *)mine->next;
#line 5439
    if (*innoel == mnoel) {
#line 5439
      return;
    }
  }
}
}
#line 5442 "188.c"
void dump_noels(FILE *where ) 
{ NOEL *b ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 5446
  b = noel_first;
#line 5447
  if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 5447
    return;
  }
#line 5448
  while ((unsigned int )b->next != (unsigned int )b) {
#line 5450
    if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 5450
      return;
    }
#line 5451
    a1 = b->atom1;
#line 5451
    a2 = b->atom2;
#line 5452
    fprintf(where, "noel %d %d %f %f %f %f %f;\n", a1->serial, a2->serial, b->d, b->dm,
            b->dh, b->km, b->kh);
#line 5454
    b = (NOEL *)b->next;
  }
#line 5456
  if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 5456
    return;
  }
#line 5457
  a1 = b->atom1;
#line 5457
  a2 = b->atom2;
#line 5458
  fprintf(where, "noel %d %d %f %f %f %f %f ;\n", a1->serial, a2->serial, b->d, b->dm,
          b->dh, b->km, b->kh);
#line 5460
  return;
}
}
#line 5461 "188.c"
int a_noel(double *V , double lambda , int ilow , int ihigh , FILE *op ) 
{ NOEL *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 5469
  bp = noel_first;
#line 5470
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 5470
    return (1);
  }
#line 5471
  while (1) {
#line 5473
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 5473
      return (0);
    }
#line 5474
    a1 = bp->atom1;
#line 5474
    a2 = bp->atom2;
#line 5475
    if (a1->serial >= ilow) {
#line 5475
      if (a1->serial <= ihigh) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 5475
      if (a2->serial >= ilow) {
#line 5475
        if (a2->serial <= ihigh) {
          _L: /* CIL Label */ 
#line 5478
          if (lambda == 0.) {
#line 5480
            r = (a1->x - a2->x) * (a1->x - a2->x);
#line 5481
            r += (a1->y - a2->y) * (a1->y - a2->y);
#line 5482
            r += (a1->z - a2->z) * (a1->z - a2->z);
          } else {
#line 5485
            xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 5486
            yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 5487
            zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 5488
            r = (xt * xt + yt * yt) + zt * zt;
          }
#line 5490
          r = sqrt(r);
#line 5491
          zt = (double )0;
#line 5492
          if (r < bp->d - bp->dm) {
#line 5493
            zt = (bp->km * ((r - bp->d) + bp->dm)) * ((r - bp->d) + bp->dm);
          }
#line 5494
          if (r > bp->d + bp->dh) {
#line 5495
            zt = (bp->kh * ((r - bp->d) - bp->dh)) * ((r - bp->d) - bp->dh);
          }
#line 5496
          *V += zt;
#line 5497
          fprintf(op, "NOEl %s %d %s %d E %f value %f error %f\n", a1->name, a1->serial,
                  a2->name, a2->serial, zt, r, r - bp->d);
        }
      }
    }
#line 5500
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 5500
      return (1);
    }
#line 5501
    bp = (NOEL *)bp->next;
  }
}
}
#line 5504 "188.c"
int gsdg_noel(ATOM *ap___1 ) 
{ ATOM *bp ;
  NOEL *np ;

  {
#line 5509
  np = noel_first;
#line 5510
  while (1) {
#line 5511
    if ((unsigned int )np == (unsigned int )((void *)0)) {
#line 5511
      return (1);
    }
#line 5512
    if ((unsigned int )np->atom1 == (unsigned int )ap___1) {
#line 5513
      bp = np->atom2;
#line 5513
      bp->vx = np->d * np->d;
#line 5514
      bp->vy = np->km;
    }
#line 5515
    if ((unsigned int )np->atom2 == (unsigned int )ap___1) {
#line 5516
      bp = np->atom1;
#line 5516
      bp->vx = np->d * np->d;
#line 5517
      bp->vy = np->km;
    }
#line 5518
    if ((unsigned int )np == (unsigned int )np->next) {
#line 5518
      return (1);
    }
#line 5519
    np = (NOEL *)np->next;
  }
#line 5521
  return (0);
}
}
#line 5523 "188.c"
int v_ho_noel(double *V , double lambda ) 
{ NOEL *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;
  ATOM *a2 ;
  double hol ;
  double target ;

  {
#line 5530
  hol = get_f_variable("lambda");
#line 5531
  if (hol > 1.) {
#line 5531
    hol = 1.;
  }
#line 5532
  if (hol < 0.) {
#line 5532
    hol = 0.;
  }
#line 5533
  bp = noel_first;
#line 5534
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 5534
    return (1);
  }
#line 5535
  while (1) {
#line 5537
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 5537
      return (0);
    }
#line 5538
    a1 = bp->atom1;
#line 5538
    a2 = bp->atom2;
#line 5539
    if (a1->active) {
      goto _L;
    } else {
#line 5539
      if (a2->active) {
        _L: /* CIL Label */ 
#line 5540
        if (lambda == 0.) {
#line 5542
          r = (a1->x - a2->x) * (a1->x - a2->x);
#line 5543
          r += (a1->y - a2->y) * (a1->y - a2->y);
#line 5544
          r += (a1->z - a2->z) * (a1->z - a2->z);
        } else {
#line 5547
          xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 5548
          yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 5549
          zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 5550
          r = (xt * xt + yt * yt) + zt * zt;
        }
#line 5552
        r = sqrt(r);
#line 5553
        if (r < bp->d - bp->dm) {
#line 5555
          target = hol * r + (1. - hol) * (bp->d - bp->dm);
#line 5556
          r -= target;
#line 5557
          *V += (bp->km * r) * r;
        } else {
#line 5558
          if (r > bp->d + bp->dh) {
#line 5559
            target = hol * r + (1. - hol) * (bp->d + bp->dh);
#line 5560
            r -= target;
#line 5561
            *V += (bp->kh * r) * r;
          }
        }
      }
    }
#line 5564
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 5564
      return (1);
    }
#line 5565
    bp = (NOEL *)bp->next;
  }
}
}
#line 5568 "188.c"
int f_ho_noel(double lambda ) 
{ NOEL *bp ;
  double r ;
  double ux ;
  double uy ;
  double uz ;
  ATOM *a1 ;
  ATOM *a2 ;
  double hol ;
  double target ;

  {
#line 5575
  hol = get_f_variable("lambda");
#line 5576
  if (hol > 1.) {
#line 5576
    hol = 1.;
  }
#line 5577
  if (hol < 0.) {
#line 5577
    hol = 0.;
  }
#line 5578
  bp = noel_first;
#line 5579
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 5579
    return (1);
  }
#line 5580
  while (1) {
#line 5582
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 5582
      return (0);
    }
#line 5583
    a1 = bp->atom1;
#line 5583
    a2 = bp->atom2;
#line 5584
    if (a1->active) {
      goto _L;
    } else {
#line 5584
      if (a2->active) {
        _L: /* CIL Label */ 
#line 5585
        if (lambda == 0.) {
#line 5587
          ux = a2->x - a1->x;
#line 5588
          uy = a2->y - a1->y;
#line 5589
          uz = a2->z - a1->z;
        } else {
#line 5591
          ux = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 5592
          uy = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 5593
          uz = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
        }
#line 5595
        r = (ux * ux + uy * uy) + uz * uz;
#line 5597
        if (r <= 1.e-5) {
#line 5598
          r = (double )0;
#line 5598
          ux = 1.;
#line 5598
          uy = 0.;
#line 5598
          uz = 0.;
        } else {
#line 5599
          r = sqrt(r);
#line 5599
          ux /= r;
#line 5599
          uy /= r;
#line 5599
          uz /= r;
        }
#line 5601
        if (r < bp->d - bp->dm) {
#line 5603
          target = hol * r + (1. - hol) * (bp->d - bp->dm);
#line 5604
          r -= target;
#line 5605
          ux = ((((double )2 * bp->km) * r) * (1. - hol)) * ux;
#line 5606
          uy = ((((double )2 * bp->km) * r) * (1. - hol)) * uy;
#line 5607
          uz = ((((double )2 * bp->km) * r) * (1. - hol)) * uz;
        } else {
#line 5608
          if (r > bp->d + bp->dh) {
#line 5609
            target = hol * r + (1. - hol) * (bp->d + bp->dh);
#line 5610
            r -= target;
#line 5611
            ux = ((((double )2 * bp->kh) * r) * (1. - hol)) * ux;
#line 5612
            uy = ((((double )2 * bp->kh) * r) * (1. - hol)) * uy;
#line 5613
            uz = ((((double )2 * bp->kh) * r) * (1. - hol)) * uz;
          } else {
#line 5615
            ux = 0.;
#line 5615
            uy = 0.;
#line 5615
            uz = 0.;
          }
        }
#line 5617
        if (a1->active) {
#line 5618
          a1->fx += ux;
#line 5619
          a1->fy += uy;
#line 5620
          a1->fz += uz;
        }
#line 5622
        if (a2->active) {
#line 5623
          a2->fx -= ux;
#line 5624
          a2->fy -= uy;
#line 5625
          a2->fz -= uz;
        }
      }
    }
#line 5628
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 5628
      return (1);
    }
#line 5629
    bp = (NOEL *)bp->next;
  }
}
}
#line 5639 "188.c"
int steep(int (**vfs)() , int (**ffs___0)() , int nfs , int nstep , double toler ) 
{ int i ;
  int j ;
  int ifs ;
  double vb ;
  double vt ;
  double vto ;
  double lam ;
  double tmp ;

  {
#line 5647
  i = 0;
#line 5647
  while (i < nstep) {
#line 5649
    vb = 0.;
#line 5650
    ifs = 0;
#line 5650
    while (ifs < nfs) {
#line 5651
    //  (*(*(vfs + ifs)))(& vb, 0.);
#line 5650
      ifs ++;
    }
#line 5652
    a_f_zero();
#line 5653
    ifs = 0;
#line 5653
    while (ifs < nfs) {
#line 5654
     // (*(*(ffs___0 + ifs)))(0.);
#line 5653
      ifs ++;
    }
#line 5655
    lam = a_max_f();
#line 5656
    if (lam <= toler) {
#line 5656
      return (1);
    }
#line 5657
    if (lam <= 1.) {
#line 5658
      a_ftodx(1., 0.);
    } else {
#line 5658
      tmp = sqrt(lam);
#line 5658
      a_ftodx(1. / tmp, 0.);
    }
#line 5659
    vto = vb;
#line 5660
    lam = 0.;
#line 5661
    j = 0;
#line 5661
    while (j < 200) {
#line 5663
      vt = 0.;
#line 5664
      lam += .01 * (double )j;
#line 5665
      ifs = 0;
#line 5665
      while (ifs < nfs) {
#line 5666
       // (*(*(vfs + ifs)))(& vt, lam);
#line 5665
        ifs ++;
      }
#line 5667
      if (vt > vto) {
#line 5667
        if (j == 0) {
#line 5668
          a_ftodx(0., .1);
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 5669
        if (vt > vto) {
#line 5670
          lam -= .01 * (double )j;
#line 5670
          break;
        }
      }
#line 5671
      vto = vt;
#line 5661
      j ++;
    }
#line 5673
    a_inc_d(lam);
#line 5647
    i ++;
  }
#line 5675
  return (0);
}
}
#line 5677 "188.c"
int cngdel(int (**vfs)() , int (**ffs___0)() , int nfs , int nstep , int nreset ,
           double toler , int echo___0 ) 
{ int i ;
  int ifs ;
  double vb ;
  double lam ;
  double beta ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 5690
  if (nreset < 1) {
#line 5690
    nreset = nstep;
  }
#line 5691
  a_g_zero();
#line 5692
  a_d_zero();
#line 5693
  i = 0;
#line 5693
  while (i < nstep) {
#line 5695
    vb = 0.;
#line 5696
    ifs = 0;
#line 5696
    while (ifs < nfs) {
#line 5697
     // (*(*(vfs + ifs)))(& vb, 0.);
#line 5696
      ifs ++;
    }
#line 5698
    a_f_zero();
#line 5699
    ifs = 0;
#line 5699
    while (ifs < nfs) {
#line 5700
     // (*(*(ffs___0 + ifs)))(0.);
#line 5699
      ifs ++;
    }
#line 5701
    lam = a_max_f();
#line 5702
    beta = a_pr_beta();
#line 5703
    if (i % nreset == 0) {
#line 5703
      beta = 0.;
    }
#line 5704
    if (echo___0) {
#line 5704
      printf(" vb, maxf %f %f %f \n", vb, lam, beta);
    }
#line 5705
    if (lam <= toler) {
#line 5705
      return (1);
    }
#line 5706
    lam = a_max_f();
#line 5707
    a_ftodx(1., beta);
#line 5708
    a_ftogx(1., 0.);
#line 5709
    tmp = a_max_d();
#line 5709
    tmp___0 = sqrt(tmp);
#line 5709
    lam = linmin(vfs, nfs, tmp___0);
#line 5710
    if (lam < 1.e-6) {
#line 5712
      a_f_zero();
#line 5713
      ifs = 0;
#line 5713
      while (ifs < nfs) {
#line 5714
      //  (*(*(ffs___0 + ifs)))(0.);
#line 5713
        ifs ++;
      }
#line 5715
      tmp___1 = a_max_f();
#line 5715
      lam = sqrt(tmp___1);
#line 5715
      if (lam < 1.) {
#line 5715
        lam = 1.;
      }
#line 5716
      a_ftodx(1. / lam, 0.);
#line 5717
      lam = linmin(vfs, nfs, 1.);
#line 5718
      if (lam < 1.e-6) {
#line 5718
        return (0);
      }
    }
#line 5720
    a_inc_d(lam);
#line 5693
    i ++;
  }
#line 5722
  return (0);
}
}
#line 5724 "188.c"
double linmin(int (**ffs___0)() , int nfs , double damp ) 
{ int i ;
  int iter ;
  int jter ;
  int imin ;
  double alpha[401] ;
  double fval[401] ;
  double dstep ;
  double step ;
  double stpmin ;
  double fvt ;
  double fmin___0 ;
  double fold ;
  int nostep ;
  double mxdq ;
  int tmp ;

  {
#line 5733
  nostep = get_i_variable("nostep");
#line 5734
  if (nostep < 1) {
#line 5734
    nostep = 8;
  }
#line 5735
  mxdq = get_f_variable("mxdq");
#line 5736
  set_f_variable((char *)"mxdq", 100.);
#line 5738
  dstep = 1.;
#line 5739
  step = (double )0;
#line 5740
  stpmin = 0.;
#line 5741
  imin = 0;
#line 5742
  alpha[0] = (double )0;
#line 5743
  fval[0] = (double )0;
#line 5744
  if (damp < 1.) {
#line 5744
    dstep = .25;
  } else {
#line 5744
    dstep = 1. / damp;
  }
#line 5745
  i = 0;
#line 5745
  while (i < nfs) {
#line 5746
   // (*(*(ffs___0 + i)))(& fval[0], 0.);
#line 5745
    i ++;
  }
#line 5747
  fmin___0 = fval[0];
#line 5747
  fold = fmin___0;
#line 5748
  imin ++;
  recheck: 
#line 5750
  alpha[imin] = dstep;
#line 5751
  fval[imin] = 0.;
#line 5752
  i = 0;
#line 5752
  while (i < nfs) {
#line 5753
    //(*(*(ffs___0 + i)))(& fval[imin], dstep);
#line 5752
    i ++;
  }
#line 5754
  if (fval[imin] > fval[0]) {
#line 5756
    dstep *= .25;
#line 5757
    if (dstep > 1.e-8) {
      goto recheck;
    }
    goto cleanup;
  }
#line 5760
  iter = 0;
#line 5760
  while (iter < nostep) {
#line 5762
    jter = 1;
#line 5762
    while (jter < 100) {
#line 5764
      step += dstep;
#line 5765
      i = 0;
#line 5765
      while (i < imin) {
#line 5767
        if (alpha[i] == step) {
#line 5769
          fvt = fval[i];
          goto FOUND;
        }
#line 5765
        i ++;
      }
#line 5772
      fvt = 0.;
#line 5773
      i = 0;
#line 5773
      while (i < nfs) {
#line 5774
       // (*(*(ffs___0 + i)))(& fvt, step);
#line 5773
        i ++;
      }
#line 5775
      alpha[imin] = step;
#line 5775
      tmp = imin;
#line 5775
      imin ++;
#line 5775
      fval[tmp] = fvt;
#line 5776
      if (imin > 400) {
#line 5776
        imin = 400;
      }
      FOUND: 
#line 5778
      if (fvt < fmin___0) {
#line 5780
        fmin___0 = fvt;
#line 5780
        stpmin = step;
      }
#line 5782
      if (fvt > fold) {
#line 5784
        dstep = - dstep / (double )2;
#line 5784
        break;
      }
#line 5786
      fold = fvt;
#line 5762
      jter ++;
    }
#line 5760
    iter ++;
  }
  cleanup: 
#line 5791
  set_f_variable((char *)"mxdq", mxdq);
#line 5792
  return (stpmin);
}
}
#line 5798 "188.c"
static double buff[55]  ;
#line 5799
double randf(void) ;
#line 5799 "188.c"
static int ip  =    0;
#line 5799
double randf(void) ;
#line 5799 "188.c"
static int jp  =    0;
#line 5799 "188.c"
static int kp  ;
#line 5796 "188.c"
double randf(void) 
{ int i ;
  int seed ;
  double xva ;

  {
#line 5802
  if (ip == 0) {
#line 5802
    if (jp == 0) {
#line 5804
      seed = get_i_variable("seed");
#line 5805
      ip = 0;
#line 5805
      while (ip < 55) {
#line 5806
        seed = (seed * 2349 + 14867) % 32767;
#line 5807
        buff[ip] = (double )seed / 32767.;
#line 5808
        if (buff[ip] > 1.) {
#line 5808
          buff[ip] -= 1.;
        }
#line 5809
        if (buff[ip] < 0.) {
#line 5809
          buff[ip] += 1.;
        }
#line 5805
        ip ++;
      }
#line 5811
      ip = 24;
#line 5811
      jp = 55 - ip;
#line 5811
      kp = 0;
    }
  }
#line 5813
  i = kp;
#line 5814
  xva = buff[jp] + buff[ip];
#line 5815
  if (xva > 1.) {
#line 5815
    xva -= 1.;
  }
#line 5816
  buff[kp] = xva;
#line 5817
  kp = (kp + 1) % 55;
#line 5818
  ip = (ip + 1) % 55;
#line 5819
  jp = (jp + 1) % 55;
#line 5820
  return (buff[i]);
}
}
#line 5822 "188.c"
double randg(void) 
{ double x1 ;
  double x2 ;
  double norm ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 5827
  norm = 2.;
#line 5828
  while (norm > 1.) {
#line 5830
    tmp = randf();
#line 5830
    x1 = 2. * tmp - (double )1;
#line 5830
    tmp___0 = randf();
#line 5830
    x2 = 2. * tmp___0 - (double )1;
#line 5831
    norm = x1 * x1 + x2 * x2;
  }
#line 5833
  if (norm < 1.e-9) {
#line 5833
    norm = 1.e-9;
  }
#line 5834
  tmp___1 = log(norm);
#line 5834
  tmp___2 = sqrt((- 2. * tmp___1) / norm);
#line 5834
  return (x1 * tmp___2);
}
}
#line 5836 "188.c"
void rand3(double *x , double *y , double *z ) 
{ double norm ;
  double x1 ;
  double x2 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 5840
  norm = 2.;
#line 5841
  while (norm > 1.) {
#line 5843
    tmp = randf();
#line 5843
    x1 = 2. * tmp - (double )1;
#line 5843
    tmp___0 = randf();
#line 5843
    x2 = 2. * tmp___0 - (double )1;
#line 5844
    norm = x1 * x1 + x2 * x2;
  }
#line 5846
  *x = x1;
#line 5846
  *y = x2;
#line 5847
  norm = sqrt(1. - norm);
#line 5848
  *z = norm;
#line 5849
  tmp___1 = randf();
#line 5849
  if (tmp___1 < 0.5) {
#line 5849
    *z = - norm;
  }
#line 5850
  return;
}
}
#line 5873 "188.c"
int mm_fv_update_nonbon(double lambda ) 
{ double r ;
  double r0 ;
  double xt ;
  double yt ;
  double zt ;
  double xt2 ;
  double xt3 ;
  double xt4 ;
  double yt2 ;
  double yt3 ;
  double yt4 ;
  double zt2 ;
  double zt3 ;
  double zt4 ;
  double k ;
  double k1 ;
  double k2 ;
  double ka2 ;
  double kb2 ;
  double c1 ;
  double c2 ;
  double c3 ;
  double c4 ;
  double c5 ;
  int i ;
  ATOM *ap___1 ;
  ATOM *a1 ;
  ATOM *a2 ;
  int ii ;
  int j ;
  int jj ;
  int imax ;
  int inclose ;
  double (*vector)[] ;
  ATOM *(*atomall)[] ;
  double dielectric ;
  double mxcut ;
  double mmbox ;
  double xmax ;
  double xmin ;
  double ymax ;
  double ymin ;
  double zmax ;
  double zmin ;
  int nx ;
  int ny ;
  int nz ;
  int ix ;
  int iy ;
  int iz ;
  int inode ;
  int naybor[27] ;
  char line[80] ;
  MMNODE (*nodelist)[] ;
  MMATOM (*atomlist)[] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 5899
  mmbox = get_f_variable("mmbox");
#line 5900
  mxcut = get_f_variable("mxcut");
#line 5901
  if (mxcut < 0.) {
#line 5901
    mxcut = 5.;
  }
#line 5902
  dielectric = get_f_variable("dielec");
#line 5903
  if (dielectric <= 0.) {
#line 5903
    dielectric = 1.;
  }
#line 5904
  dielectric = 332.17752 / dielectric;
#line 5906
  i = a_number();
#line 5907
  tmp = malloc((unsigned int )(4 * i) * sizeof(double ));
#line 5907
  vector = (double (*)[])tmp;
#line 5908
  if ((unsigned int )vector == (unsigned int )((void *)0)) {
#line 5909
    aaerror((char *)"cannot allocate memory in mm_fv_update\n");
#line 5909
    return (0);
  }
#line 5910
  tmp___0 = malloc((unsigned int )i * sizeof(ATOM *));
#line 5910
  atomall = (ATOM *(*)[])tmp___0;
#line 5911
  if ((unsigned int )atomall == (unsigned int )((void *)0)) {
#line 5912
    aaerror((char *)"cannot allocate memory in mm_fv_update\n");
#line 5912
    return (0);
  }
#line 5913
  tmp___1 = malloc((unsigned int )i * sizeof(MMATOM ));
#line 5913
  atomlist = (MMATOM (*)[])tmp___1;
#line 5914
  if ((unsigned int )atomlist == (unsigned int )((void *)0)) {
#line 5915
    aaerror((char *)"cannot allocate memory in mm_fv_update\n");
#line 5915
    return (0);
  }
#line 5916
  imax = a_number();
#line 5917
  jj = imax;
#line 5918
  i = 0;
#line 5918
  while (i < imax) {
#line 5920
    (*atomall)[i] = a_next(i);
#line 5921
    (*atomlist)[i].who = (*atomall)[i];
#line 5918
    i ++;
  }
#line 5923
  ii = 0;
#line 5923
  while (ii < imax) {
#line 5925
    a1 = (*atomall)[ii];
#line 5926
    j = ii * 4;
#line 5927
    (*vector)[j] = a1->dx * lambda + a1->x;
#line 5928
    (*vector)[j + 1] = a1->dy * lambda + a1->y;
#line 5929
    (*vector)[j + 2] = a1->dz * lambda + a1->z;
#line 5923
    ii ++;
  }
#line 5931
  xmax = - 10e10;
#line 5932
  ymax = - 10e10;
#line 5933
  zmax = - 10e10;
#line 5934
  xmin = 10e10;
#line 5935
  ymin = 10e10;
#line 5936
  zmin = 10e10;
#line 5937
  ii = 0;
#line 5937
  while (ii < imax) {
#line 5939
    j = ii * 4;
#line 5940
    if (xmax < (*vector)[j]) {
#line 5940
      xmax = (*vector)[j];
    }
#line 5941
    if (ymax < (*vector)[j + 1]) {
#line 5941
      ymax = (*vector)[j + 1];
    }
#line 5942
    if (zmax < (*vector)[j + 2]) {
#line 5942
      zmax = (*vector)[j + 2];
    }
#line 5943
    if (xmin > (*vector)[j]) {
#line 5943
      xmin = (*vector)[j];
    }
#line 5944
    if (ymin > (*vector)[j + 1]) {
#line 5944
      ymin = (*vector)[j + 1];
    }
#line 5945
    if (zmin > (*vector)[j + 2]) {
#line 5945
      zmin = (*vector)[j + 2];
    }
#line 5937
    ii ++;
  }
#line 5947
  nx = (int )((xmax - xmin) / mmbox + (double )1);
#line 5948
  ny = (int )((ymax - ymin) / mmbox + (double )1);
#line 5949
  nz = (int )((zmax - zmin) / mmbox + (double )1);
#line 5950
  tmp___2 = malloc((unsigned int )((nx * ny) * nz) * sizeof(MMNODE ));
#line 5950
  nodelist = (MMNODE (*)[])tmp___2;
#line 5951
  if ((unsigned int )nodelist == (unsigned int )((void *)0)) {
#line 5952
    aaerror((char *)"cannot allocate node memory in mm_fv_update (doubling grid )\n");
#line 5953
    sprintf(line, "mmbox %f nx %d ny %d nz %d ", mmbox, nx, ny, nz);
#line 5954
    aaerror(line);
#line 5955
    sprintf(line, " xmin xmax %f %f ymin ymax %f %f zmin zmax %f %f", xmin, xmax,
            ymin, ymax, zmin, zmax);
#line 5957
    aaerror(line);
#line 5958
    mmbox *= (double )2;
#line 5959
    set_f_variable((char *)"mmbox", mmbox);
#line 5960
    nx = (int )((xmax - xmin) / mmbox + (double )1);
#line 5961
    ny = (int )((ymax - ymin) / mmbox + (double )1);
#line 5962
    nz = (int )((zmax - zmin) / mmbox + (double )1);
#line 5963
    tmp___3 = malloc((unsigned int )((nx * ny) * nz) * sizeof(MMNODE ));
#line 5963
    nodelist = (MMNODE (*)[])tmp___3;
#line 5964
    if ((unsigned int )nodelist == (unsigned int )((void *)0)) {
#line 5965
      aaerror((char *)"cannot allocate node memory in mm_fv_update (cannot do it)\n");
#line 5965
      return (0);
    }
  }
#line 5967
  ix = 0;
#line 5967
  while (ix < nx) {
#line 5968
    iy = 0;
#line 5968
    while (iy < ny) {
#line 5969
      iz = 0;
#line 5969
      while (iz < nz) {
#line 5971
        inode = (iz * ny + iy) * nx + ix;
#line 5972
        (*nodelist)[inode].xc = ((double )ix * mmbox + .5 * mmbox) + xmin;
#line 5973
        (*nodelist)[inode].yc = ((double )iy * mmbox + .5 * mmbox) + ymin;
#line 5974
        (*nodelist)[inode].zc = ((double )iz * mmbox + .5 * mmbox) + zmin;
#line 5969
        iz ++;
      }
#line 5968
      iy ++;
    }
#line 5967
    ix ++;
  }
#line 5976
  ii = 0;
#line 5976
  while (ii < (nx * ny) * nz) {
#line 5978
    (*nodelist)[ii].sqp = 0.;
#line 5979
    (*nodelist)[ii].sa = 0.;
#line 5980
    (*nodelist)[ii].xa = 0.;
#line 5981
    (*nodelist)[ii].ya = 0.;
#line 5982
    (*nodelist)[ii].za = 0.;
#line 5983
    (*nodelist)[ii].q100 = 0.;
#line 5984
    (*nodelist)[ii].q010 = 0.;
#line 5985
    (*nodelist)[ii].q001 = 0.;
#line 5986
    (*nodelist)[ii].q200 = 0.;
#line 5987
    (*nodelist)[ii].q020 = 0.;
#line 5988
    (*nodelist)[ii].q002 = 0.;
#line 5989
    (*nodelist)[ii].q101 = 0.;
#line 5990
    (*nodelist)[ii].q110 = 0.;
#line 5991
    (*nodelist)[ii].q011 = 0.;
#line 5992
    (*nodelist)[ii].q300 = 0.;
#line 5993
    (*nodelist)[ii].q030 = 0.;
#line 5994
    (*nodelist)[ii].q003 = 0.;
#line 5995
    (*nodelist)[ii].q210 = 0.;
#line 5996
    (*nodelist)[ii].q120 = 0.;
#line 5997
    (*nodelist)[ii].q201 = 0.;
#line 5998
    (*nodelist)[ii].q102 = 0.;
#line 5999
    (*nodelist)[ii].q021 = 0.;
#line 6000
    (*nodelist)[ii].q012 = 0.;
#line 6001
    (*nodelist)[ii].q111 = 0.;
#line 6042
    (*nodelist)[ii].first = -1;
#line 6043
    (*nodelist)[ii].last = -1;
#line 6044
    (*nodelist)[ii].innode = 0;
#line 5976
    ii ++;
  }
#line 6047
  ii = 0;
#line 6047
  while (ii < imax) {
#line 6049
    j = ii * 4;
#line 6050
    ix = (int )(((*vector)[j] - xmin) / mmbox);
#line 6051
    iy = (int )(((*vector)[j + 1] - ymin) / mmbox);
#line 6052
    iz = (int )(((*vector)[j + 2] - zmin) / mmbox);
#line 6053
    inode = (iz * ny + iy) * nx + ix;
#line 6054
    (*atomlist)[ii].which = inode;
#line 6047
    ii ++;
  }
#line 6056
  inode = 0;
#line 6056
  while (inode < (nx * ny) * nz) {
#line 6059
    ii = 0;
#line 6059
    while (ii < imax) {
#line 6061
      if ((*atomlist)[ii].which == inode) {
#line 6063
        (*nodelist)[inode].first = ii;
#line 6064
        (*nodelist)[inode].last = ii;
#line 6065
        ((*nodelist)[inode].innode) ++;
#line 6066
        ap___1 = (*atomlist)[ii].who;
#line 6067
        break;
      }
#line 6059
      ii ++;
    }
#line 6071
    if (ii != imax) {
#line 6073
      ii = (*nodelist)[inode].first;
#line 6073
      while (ii < imax) {
#line 6075
        if ((*atomlist)[ii].which == inode) {
#line 6077
          (*atomlist)[(*nodelist)[inode].last].next = ii;
#line 6078
          (*nodelist)[inode].last = ii;
#line 6079
          ((*nodelist)[inode].innode) ++;
#line 6080
          ap___1 = (*atomlist)[ii].who;
#line 6081
          xt = (ap___1->x + lambda * ap___1->dx) - (*nodelist)[inode].xc;
#line 6082
          yt = (ap___1->y + lambda * ap___1->dy) - (*nodelist)[inode].yc;
#line 6083
          zt = (ap___1->z + lambda * ap___1->dz) - (*nodelist)[inode].zc;
#line 6084
          (*nodelist)[inode].sqp += ap___1->q;
#line 6085
          (*nodelist)[inode].sa += ap___1->a;
#line 6086
          (*nodelist)[inode].xa += ap___1->a * xt;
#line 6087
          (*nodelist)[inode].ya += ap___1->a * yt;
#line 6088
          (*nodelist)[inode].za += ap___1->a * zt;
#line 6089
          xt2 = xt * xt;
#line 6090
          xt3 = xt2 * xt;
#line 6091
          xt4 = xt3 * xt;
#line 6092
          yt2 = yt * yt;
#line 6093
          yt3 = yt2 * yt;
#line 6094
          yt4 = yt3 * yt;
#line 6095
          zt2 = zt * zt;
#line 6096
          zt3 = zt2 * zt;
#line 6097
          zt4 = zt3 * zt;
#line 6098
          (*nodelist)[inode].q100 += ap___1->q * xt;
#line 6099
          (*nodelist)[inode].q010 += ap___1->q * yt;
#line 6100
          (*nodelist)[inode].q001 += ap___1->q * zt;
#line 6101
          (*nodelist)[inode].q200 += ap___1->q * xt2;
#line 6102
          (*nodelist)[inode].q020 += ap___1->q * yt2;
#line 6103
          (*nodelist)[inode].q002 += ap___1->q * zt2;
#line 6104
          (*nodelist)[inode].q101 += (ap___1->q * xt) * zt;
#line 6105
          (*nodelist)[inode].q110 += (ap___1->q * xt) * yt;
#line 6106
          (*nodelist)[inode].q011 += (ap___1->q * yt) * zt;
#line 6107
          (*nodelist)[inode].q300 += ap___1->q * xt3;
#line 6108
          (*nodelist)[inode].q030 += ap___1->q * yt3;
#line 6109
          (*nodelist)[inode].q003 += ap___1->q * zt3;
#line 6110
          (*nodelist)[inode].q210 += (ap___1->q * xt2) * yt;
#line 6111
          (*nodelist)[inode].q120 += (ap___1->q * xt) * yt2;
#line 6112
          (*nodelist)[inode].q201 += (ap___1->q * xt2) * zt;
#line 6113
          (*nodelist)[inode].q102 += (ap___1->q * xt) * zt2;
#line 6114
          (*nodelist)[inode].q021 += (ap___1->q * yt2) * zt;
#line 6115
          (*nodelist)[inode].q012 += (ap___1->q * yt) * zt2;
#line 6116
          (*nodelist)[inode].q111 += ((ap___1->q * xt) * yt) * zt;
        }
#line 6073
        ii ++;
      }
    }
#line 6056
    inode ++;
  }
#line 6162
  k = dielectric * .5;
#line 6163
  xt = .5 / 3.;
#line 6164
  yt = xt / 4.;
#line 6165
  zt = yt / 5.;
#line 6166
  ii = 0;
#line 6166
  while (ii < (nx * ny) * nz) {
#line 6168
    (*nodelist)[ii].sqp *= k;
#line 6169
    (*nodelist)[ii].q100 *= k;
#line 6170
    (*nodelist)[ii].q010 *= k;
#line 6171
    (*nodelist)[ii].q001 *= k;
#line 6172
    (*nodelist)[ii].q200 *= .5 * k;
#line 6173
    (*nodelist)[ii].q020 *= .5 * k;
#line 6174
    (*nodelist)[ii].q002 *= .5 * k;
#line 6175
    (*nodelist)[ii].q101 *= k;
#line 6176
    (*nodelist)[ii].q110 *= k;
#line 6177
    (*nodelist)[ii].q011 *= k;
#line 6178
    (*nodelist)[ii].q300 *= xt * k;
#line 6179
    (*nodelist)[ii].q030 *= xt * k;
#line 6180
    (*nodelist)[ii].q003 *= xt * k;
#line 6181
    (*nodelist)[ii].q210 *= 0.5 * k;
#line 6182
    (*nodelist)[ii].q120 *= 0.5 * k;
#line 6183
    (*nodelist)[ii].q201 *= 0.5 * k;
#line 6184
    (*nodelist)[ii].q102 *= 0.5 * k;
#line 6185
    (*nodelist)[ii].q021 *= 0.5 * k;
#line 6186
    (*nodelist)[ii].q012 *= 0.5 * k;
#line 6187
    (*nodelist)[ii].q111 *= k;
#line 6229
    if ((*nodelist)[ii].sa != 0.) {
#line 6231
      (*nodelist)[ii].xa /= (*nodelist)[ii].sa;
#line 6232
      (*nodelist)[ii].ya /= (*nodelist)[ii].sa;
#line 6233
      (*nodelist)[ii].za /= (*nodelist)[ii].sa;
    }
#line 6235
    (*nodelist)[ii].xa += (*nodelist)[ii].xc;
#line 6236
    (*nodelist)[ii].ya += (*nodelist)[ii].yc;
#line 6237
    (*nodelist)[ii].za += (*nodelist)[ii].zc;
#line 6238
    (*nodelist)[ii].sa *= .5;
#line 6166
    ii ++;
  }
#line 6240
  ii = 0;
#line 6240
  while (ii < jj) {
#line 6242
    a1 = (*atomall)[ii];
#line 6243
    a1->px = a1->x + lambda * a1->dx;
#line 6244
    a1->py = a1->y + lambda * a1->dy;
#line 6245
    a1->pz = a1->z + lambda * a1->dz;
#line 6246
    a1->VP = 0.;
#line 6247
    a1->dpx = 0.;
#line 6248
    a1->dpy = 0.;
#line 6249
    a1->dpz = 0.;
#line 6250
    a1->qxx = 0.;
#line 6251
    a1->qxy = 0.;
#line 6252
    a1->qxz = 0.;
#line 6253
    a1->qyy = 0.;
#line 6254
    a1->qyz = 0.;
#line 6255
    a1->qzz = 0.;
#line 6268
    j = 0;
#line 6268
    while (j < 200) {
#line 6269
      a1->close[j] = (void *)0;
#line 6268
      j ++;
    }
#line 6240
    ii ++;
  }
#line 6271
  ii = 0;
#line 6271
  
  while (ii < jj) {
#line 6273
    a1 = (*atomlist)[ii].who;
#line 6274
    inclose = 0;
#line 6275
    ix = (int )((a1->px - xmin) / mmbox);
#line 6276
    iy = (int )((a1->py - ymin) / mmbox);
#line 6277
    iz = (int )((a1->pz - zmin) / mmbox);
#line 6278
    naybor[0] = (iz * ny + iy) * nx + ix;
#line 6279
    naybor[1] = ((iz * ny + iy) * nx + ix) + 1;
#line 6280
    naybor[2] = ((iz * ny + iy) * nx + ix) - 1;
#line 6281
    naybor[3] = ((iz * ny + iy) * nx + nx) + ix;
#line 6282
    naybor[4] = ((iz * ny + iy) * nx - nx) + ix;
#line 6283
    naybor[5] = (((iz * ny + iy) * nx + nx) + ix) + 1;
#line 6284
    naybor[6] = (((iz * ny + iy) * nx + nx) + ix) - 1;
#line 6285
    naybor[7] = (((iz * ny + iy) * nx - nx) + ix) + 1;
#line 6286
    naybor[8] = (((iz * ny + iy) * nx - nx) + ix) - 1;
#line 6287
    naybor[9] = ((iz * ny + ny) + iy) * nx + ix;
#line 6288
    naybor[10] = (((iz * ny + ny) + iy) * nx + ix) + 1;
#line 6289
    naybor[11] = (((iz * ny + ny) + iy) * nx + ix) - 1;
#line 6290
    naybor[12] = (((iz * ny + ny) + iy) * nx + nx) + ix;
#line 6291
    naybor[13] = (((iz * ny + ny) + iy) * nx - nx) + ix;
#line 6292
    naybor[14] = ((((iz * ny + ny) + iy) * nx + nx) + ix) + 1;
#line 6293
    naybor[15] = ((((iz * ny + ny) + iy) * nx + nx) + ix) - 1;
#line 6294
    naybor[16] = ((((iz * ny + ny) + iy) * nx - nx) + ix) + 1;
#line 6295
    naybor[17] = ((((iz * ny + ny) + iy) * nx - nx) + ix) - 1;
#line 6296
    naybor[18] = ((iz * ny - ny) + iy) * nx + ix;
#line 6297
    naybor[19] = (((iz * ny - ny) + iy) * nx + ix) + 1;
#line 6298
    naybor[20] = (((iz * ny - ny) + iy) * nx + ix) - 1;
#line 6299
    naybor[21] = (((iz * ny - ny) + iy) * nx + nx) + ix;
#line 6300
    naybor[22] = (((iz * ny - ny) + iy) * nx - nx) + ix;
#line 6301
    naybor[23] = ((((iz * ny - ny) + iy) * nx + nx) + ix) + 1;
#line 6302
    naybor[24] = ((((iz * ny - ny) + iy) * nx + nx) + ix) - 1;
#line 6303
    naybor[25] = ((((iz * ny - ny) + iy) * nx - nx) + ix) + 1;
#line 6304
    naybor[26] = ((((iz * ny - ny) + iy) * nx - nx) + ix) - 1;
#line 6305
    inode = 0;
#line 6305
    while (inode < (nx * ny) * nz) {
#line 6308
      j = 0;
#line 6308
      while (j < 27) {
#line 6310
        if (inode == naybor[j]) {
#line 6310
          break;
        }
#line 6308
        j ++;
      }
#line 6311
      if (j == 27) {
#line 6313
        if ((*nodelist)[inode].innode > 0) {
#line 6316
          xt = (*nodelist)[inode].xc - a1->px;
#line 6317
          yt = (*nodelist)[inode].yc - a1->py;
#line 6318
          zt = (*nodelist)[inode].zc - a1->pz;
#line 6319
          r = 1. / ((xt * xt + yt * yt) + zt * zt);
#line 6320
          r0 = sqrt(r);
#line 6321
          c1 = - r * r0;
#line 6322
          c2 = (- 3. * c1) * r;
#line 6323
          c3 = (- 5. * c2) * r;
#line 6324
          c4 = (- 7. * c3) * r;
#line 6325
          c5 = (- 9. * c4) * r;
#line 6326
          xt2 = xt * xt;
#line 6327
          xt3 = xt2 * xt;
#line 6328
          xt4 = xt3 * xt;
#line 6329
          yt2 = yt * yt;
#line 6330
          yt3 = yt2 * yt;
#line 6331
          yt4 = yt3 * yt;
#line 6332
          zt2 = zt * zt;
#line 6333
          zt3 = zt2 * zt;
#line 6334
          zt4 = zt3 * zt;
#line 6335
          a1->VP += ((*nodelist)[inode].sqp * a1->q) * r0;
#line 6336
          k = (c1 * a1->q) * xt;
#line 6337
          a1->VP += k * (*nodelist)[inode].q100;
#line 6338
          a1->dpx += k * (*nodelist)[inode].sqp;
#line 6339
          k = (c1 * a1->q) * yt;
#line 6340
          a1->VP += k * (*nodelist)[inode].q010;
#line 6341
          a1->dpy += k * (*nodelist)[inode].sqp;
#line 6342
          k = (c1 * a1->q) * zt;
#line 6343
          a1->VP += k * (*nodelist)[inode].q001;
#line 6344
          a1->dpz += k * (*nodelist)[inode].sqp;
#line 6345
          k = (c2 * xt2 + c1) * a1->q;
#line 6346
          a1->VP += k * (*nodelist)[inode].q200;
#line 6347
          a1->dpx += k * (*nodelist)[inode].q100;
#line 6348
          a1->qxx += k * (*nodelist)[inode].sqp;
#line 6349
          k = (c2 * yt2 + c1) * a1->q;
#line 6350
          a1->VP += k * (*nodelist)[inode].q020;
#line 6351
          a1->dpy += k * (*nodelist)[inode].q010;
#line 6352
          a1->qyy += k * (*nodelist)[inode].sqp;
#line 6353
          k = (c2 * zt2 + c1) * a1->q;
#line 6354
          a1->VP += k * (*nodelist)[inode].q002;
#line 6355
          a1->dpz += k * (*nodelist)[inode].q001;
#line 6356
          a1->qzz += k * (*nodelist)[inode].sqp;
#line 6357
          k = ((c2 * xt) * yt) * a1->q;
#line 6358
          a1->VP += k * (*nodelist)[inode].q110;
#line 6359
          a1->dpx += k * (*nodelist)[inode].q010;
#line 6360
          a1->dpy += k * (*nodelist)[inode].q100;
#line 6361
          a1->qxy += k * (*nodelist)[inode].sqp;
#line 6362
          k = ((c2 * xt) * zt) * a1->q;
#line 6363
          a1->VP += k * (*nodelist)[inode].q101;
#line 6364
          a1->dpx += k * (*nodelist)[inode].q001;
#line 6365
          a1->dpz += k * (*nodelist)[inode].q100;
#line 6366
          a1->qxz += k * (*nodelist)[inode].sqp;
#line 6367
          k = ((c2 * yt) * zt) * a1->q;
#line 6368
          a1->VP += k * (*nodelist)[inode].q011;
#line 6369
          a1->dpy += k * (*nodelist)[inode].q001;
#line 6370
          a1->dpz += k * (*nodelist)[inode].q010;
#line 6371
          a1->qyz += k * (*nodelist)[inode].sqp;
#line 6372
          k = (c3 * xt3 + ((double )3 * c2) * xt) * a1->q;
#line 6373
          a1->VP += k * (*nodelist)[inode].q300;
#line 6374
          a1->dpx += k * (*nodelist)[inode].q200;
#line 6375
          a1->qxx += k * (*nodelist)[inode].q100;
#line 6376
          k = (c3 * yt3 + ((double )3 * c2) * yt) * a1->q;
#line 6377
          a1->VP += k * (*nodelist)[inode].q030;
#line 6378
          a1->dpy += k * (*nodelist)[inode].q020;
#line 6379
          a1->qyy += k * (*nodelist)[inode].q010;
#line 6380
          k = (c3 * zt3 + ((double )3 * c2) * zt) * a1->q;
#line 6381
          a1->VP += k * (*nodelist)[inode].q003;
#line 6382
          a1->dpz += k * (*nodelist)[inode].q002;
#line 6383
          a1->qzz += k * (*nodelist)[inode].q001;
#line 6384
          k = ((c3 * xt2) * yt + c2 * yt) * a1->q;
#line 6385
          a1->VP += k * (*nodelist)[inode].q210;
#line 6386
          a1->dpx += k * (*nodelist)[inode].q110;
#line 6387
          a1->dpy += k * (*nodelist)[inode].q200;
#line 6388
          a1->qxx += k * (*nodelist)[inode].q010;
#line 6389
          a1->qxy += k * (*nodelist)[inode].q100;
#line 6390
          k = ((c3 * yt2) * xt + c2 * xt) * a1->q;
#line 6391
          a1->VP += k * (*nodelist)[inode].q120;
#line 6392
          a1->dpx += k * (*nodelist)[inode].q020;
#line 6393
          a1->dpy += k * (*nodelist)[inode].q110;
#line 6394
          a1->qyy += k * (*nodelist)[inode].q100;
#line 6395
          a1->qxy += k * (*nodelist)[inode].q010;
#line 6396
          k = ((c3 * xt2) * zt + c2 * zt) * a1->q;
#line 6397
          a1->VP += k * (*nodelist)[inode].q201;
#line 6398
          a1->dpx += k * (*nodelist)[inode].q101;
#line 6399
          a1->dpz += k * (*nodelist)[inode].q200;
#line 6400
          a1->qxx += k * (*nodelist)[inode].q001;
#line 6401
          a1->qxz += k * (*nodelist)[inode].q100;
#line 6402
          k = ((c3 * zt2) * xt + c2 * xt) * a1->q;
#line 6403
          a1->VP += k * (*nodelist)[inode].q102;
#line 6404
          a1->dpx += k * (*nodelist)[inode].q002;
#line 6405
          a1->dpz += k * (*nodelist)[inode].q101;
#line 6406
          a1->qzz += k * (*nodelist)[inode].q100;
#line 6407
          a1->qxz += k * (*nodelist)[inode].q001;
#line 6408
          k = ((c3 * yt2) * zt + c2 * zt) * a1->q;
#line 6409
          a1->VP += k * (*nodelist)[inode].q021;
#line 6410
          a1->dpy += k * (*nodelist)[inode].q011;
#line 6411
          a1->dpz += k * (*nodelist)[inode].q020;
#line 6412
          a1->qyy += k * (*nodelist)[inode].q001;
#line 6413
          a1->qyz += k * (*nodelist)[inode].q010;
#line 6414
          k = ((c3 * zt2) * yt + c2 * yt) * a1->q;
#line 6415
          a1->VP += k * (*nodelist)[inode].q012;
#line 6416
          a1->dpy += k * (*nodelist)[inode].q002;
#line 6417
          a1->dpz += k * (*nodelist)[inode].q011;
#line 6418
          a1->qzz += k * (*nodelist)[inode].q010;
#line 6419
          a1->qyz += k * (*nodelist)[inode].q001;
#line 6420
          k = (((c3 * zt) * yt) * xt) * a1->q;
#line 6421
          a1->VP += k * (*nodelist)[inode].q111;
#line 6422
          a1->dpx += k * (*nodelist)[inode].q011;
#line 6423
          a1->dpy += k * (*nodelist)[inode].q101;
#line 6424
          a1->dpz += k * (*nodelist)[inode].q110;
        }
      } else {
#line 6667
        if ((*nodelist)[inode].innode > 0) {
#line 6669
          imax = 0;
#line 6670
          i = (*nodelist)[inode].first;
#line 6671
          if ((*nodelist)[inode].innode > 0) {
#line 6671
            if (((*atomlist)[i].who)->serial > a1->serial) {
#line 6673
              tmp___4 = imax;
#line 6673
              imax ++;
#line 6673
              (*atomall)[tmp___4] = (*atomlist)[i].who;
            }
          }
#line 6674
          j = 1;
#line 6674
          while (j < (*nodelist)[inode].innode - 1) {
#line 6676
            i = (*atomlist)[i].next;
#line 6677
            if (((*atomlist)[i].who)->serial > a1->serial) {
#line 6678
              tmp___5 = imax;
#line 6678
              imax ++;
#line 6678
              (*atomall)[tmp___5] = (*atomlist)[i].who;
            }
#line 6674
            j ++;
          }
#line 6681
          i = 0;
#line 6681
          while (i < imax) {
#line 6683
            a2 = (*atomall)[i];
#line 6684
            j = i * 4;
#line 6685
            (*vector)[j] = a2->px - a1->px;
#line 6686
            (*vector)[j + 1] = a2->py - a1->py;
#line 6687
            (*vector)[j + 2] = a2->pz - a1->pz;
#line 6681
            i ++;
          }
#line 6689
          i = 0;
#line 6689
          while (i < imax) {
#line 6691
            j = i * 4;
#line 6692
            (*vector)[j + 3] = sqrt(((*vector)[j] * (*vector)[j] + (*vector)[j + 1] * (*vector)[j + 1]) + (*vector)[j + 2] * (*vector)[j + 2]);
#line 6689
            i ++;
          }
#line 6696
          i = 0;
#line 6696
          while (i < imax) {
#line 6698
            a2 = (*atomall)[i];
#line 6699
            j = 0;
#line 6699
            while (j < a1->dontuse) {
#line 6700
              if ((unsigned int )a2 == (unsigned int )a1->excluded[j]) {
                goto SKIPNEW;
              }
#line 6699
              j ++;
            }
#line 6701
            j = i * 4;
#line 6702
            if ((*vector)[j + 3] > mxcut) {
              goto _L;
            } else {
#line 6702
              if (inclose > 200) {
                _L: /* CIL Label */ 
#line 6704
                r0 = 1. / (*vector)[j + 3];
#line 6705
                r = r0 * r0;
#line 6706
                r = (r * r) * r;
#line 6707
                xt = ((a1->q * a2->q) * dielectric) * r0;
#line 6708
                yt = (a1->a * a2->a) * r;
#line 6709
                zt = ((a1->b * a2->b) * r) * r;
#line 6710
                k = (xt - yt) + zt;
#line 6711
                xt *= r0;
#line 6711
                yt *= r0;
#line 6711
                zt *= r0;
#line 6712
                k1 = (xt - yt * 6.) + zt * 12.;
#line 6713
                xt *= r0;
#line 6713
                yt *= r0;
#line 6713
                zt *= r0;
#line 6714
                k2 = xt * 3.;
#line 6714
                ka2 = (- yt * 6.) * 8.;
#line 6714
                kb2 = (zt * 12.) * (double )14;
#line 6719
                k1 = - k1;
#line 6720
                xt = (*vector)[j] * r0;
#line 6721
                yt = (*vector)[j + 1] * r0;
#line 6722
                zt = (*vector)[j + 2] * r0;
#line 6724
                a1->VP += k;
#line 6725
                a2->dpx -= k1 * xt;
#line 6726
                a1->dpx += k1 * xt;
#line 6727
                a2->dpy -= k1 * yt;
#line 6728
                a1->dpy += k1 * yt;
#line 6729
                a2->dpz -= k1 * zt;
#line 6730
                a1->dpz += k1 * zt;
#line 6731
                xt2 = xt * xt;
#line 6731
                yt2 = yt * yt;
#line 6731
                zt2 = zt * zt;
#line 6732
                a2->qxx -= (k2 * (xt2 - 1. / (double )3) + ka2 * (xt2 - 1. / (double )8)) + kb2 * (xt2 - 1. / (double )14);
#line 6733
                a1->qxx -= (k2 * (xt2 - 1. / (double )3) + ka2 * (xt2 - 1. / (double )8)) + kb2 * (xt2 - 1. / (double )14);
#line 6734
                a2->qxy -= (((k2 + ka2) + kb2) * yt) * xt;
#line 6735
                a1->qxy -= (((k2 + ka2) + kb2) * yt) * xt;
#line 6736
                a2->qxz -= (((k2 + ka2) + kb2) * zt) * xt;
#line 6737
                a1->qxz -= (((k2 + ka2) + kb2) * zt) * xt;
#line 6738
                a2->qyy -= (k2 * (yt2 - 1. / (double )3) + ka2 * (yt2 - 1. / (double )8)) + kb2 * (yt2 - 1. / (double )14);
#line 6739
                a1->qyy -= (k2 * (yt2 - 1. / (double )3) + ka2 * (yt2 - 1. / (double )8)) + kb2 * (yt2 - 1. / (double )14);
#line 6740
                a2->qyz -= (((k2 + ka2) + kb2) * yt) * zt;
#line 6741
                a1->qyz -= (((k2 + ka2) + kb2) * yt) * zt;
#line 6742
                a2->qzz -= (k2 * (zt2 - 1. / (double )3) + ka2 * (zt2 - 1. / (double )8)) + kb2 * (zt2 - 1. / (double )14);
#line 6743
                a1->qzz -= (k2 * (zt2 - 1. / (double )3) + ka2 * (zt2 - 1. / (double )8)) + kb2 * (zt2 - 1. / (double )14);
              } else {
#line 6803
                tmp___6 = inclose;
#line 6803
                inclose ++;
#line 6803
                a1->close[tmp___6] = (void *)(*atomall)[i];
#line 6804
                if (inclose == 200) {
#line 6806
                  aaerror((char *)" fv_update_nonbon> too many atoms increase NCLOSE or decrease mxcut");
                }
              }
            }
            SKIPNEW: 
#line 6810
            j = j;
#line 6696
            i ++;
          }
        }
      }
#line 6305
      inode ++;
    }
#line 6815
    a1->px = a1->dx * lambda + a1->x;
#line 6816
    a1->py = a1->dy * lambda + a1->y;
#line 6817
    a1->pz = a1->dz * lambda + a1->z;
#line 6271
    ii ++;
  }
#line 6820
  a_inactive_f_zero();
#line 6821
  free((void *)atomlist);
#line 6822
  free((void *)nodelist);
#line 6823
  free((void *)vector);
#line 6824
  free((void *)atomall);
#line 6825
  return (1);
}
}
#line 6838 "188.c"
RESTRAIN *restrain_first  =    (RESTRAIN *)((void *)0);
#line 6839 "188.c"
RESTRAIN *restrain_last  =    (RESTRAIN *)((void *)0);
#line 6840 "188.c"
int restrain(int p1 , int p2 , double bl , double fk ) 
{ ATOM *ap1 ;
  ATOM *ap2 ;
  RESTRAIN *new ;
  char line[80] ;
  void *tmp ;

  {
#line 6847
  ap1 = a_m_serial(p1);
#line 6848
  ap2 = a_m_serial(p2);
#line 6849
  if ((unsigned int )ap1 == (unsigned int )((void *)0)) {
#line 6851
    sprintf(line, "undefined atom in restrain %d %d \000", p1, p2);
#line 6852
    aaerror(line);
#line 6853
    return (0);
  } else {
#line 6849
    if ((unsigned int )ap2 == (unsigned int )((void *)0)) {
#line 6851
      sprintf(line, "undefined atom in restrain %d %d \000", p1, p2);
#line 6852
      aaerror(line);
#line 6853
      return (0);
    }
  }
#line 6855
  new = restrain_first;
#line 6856
  if ((unsigned int )new != (unsigned int )((void *)0)) {
#line 6858
    while (! ((unsigned int )new == (unsigned int )((void *)0))) {
#line 6861
      if ((unsigned int )new->atom1 == (unsigned int )ap1) {
#line 6861
        if ((unsigned int )new->atom2 == (unsigned int )ap2) {
#line 6864
          new->length = bl;
#line 6864
          new->k = fk;
#line 6864
          return (1);
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 6861
        if ((unsigned int )new->atom1 == (unsigned int )ap2) {
#line 6861
          if ((unsigned int )new->atom2 == (unsigned int )ap1) {
#line 6864
            new->length = bl;
#line 6864
            new->k = fk;
#line 6864
            return (1);
          }
        }
      }
#line 6866
      if ((unsigned int )new == (unsigned int )new->next) {
#line 6866
        break;
      }
#line 6867
      new = (RESTRAIN *)new->next;
    }
  }
#line 6870
  tmp = malloc(sizeof(RESTRAIN ));
#line 6870
  new = (RESTRAIN *)tmp;
#line 6870
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 6872
    return (0);
  }
#line 6875
  if ((unsigned int )restrain_first == (unsigned int )((void *)0)) {
#line 6875
    restrain_first = new;
  }
#line 6876
  if ((unsigned int )restrain_last == (unsigned int )((void *)0)) {
#line 6876
    restrain_last = new;
  }
#line 6877
  new->atom1 = ap1;
#line 6878
  new->atom2 = ap2;
#line 6879
  new->length = bl;
#line 6880
  new->k = fk;
#line 6881
  new->next = (void *)new;
#line 6882
  restrain_last->next = (void *)new;
#line 6883
  restrain_last = new;
#line 6884
  return (1);
}
}
#line 6886 "188.c"
int v_restrain(double *V , double lambda ) 
{ RESTRAIN *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 6892
  bp = restrain_first;
#line 6893
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 6893
    return (1);
  }
#line 6894
  while (1) {
#line 6896
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 6896
      return (0);
    }
#line 6897
    a1 = bp->atom1;
#line 6897
    a2 = bp->atom2;
#line 6898
    if (lambda == 0.) {
#line 6900
      r = (a1->x - a2->x) * (a1->x - a2->x);
#line 6901
      r += (a1->y - a2->y) * (a1->y - a2->y);
#line 6902
      r += (a1->z - a2->z) * (a1->z - a2->z);
    } else {
#line 6905
      xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 6906
      yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 6907
      zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 6908
      r = (xt * xt + yt * yt) + zt * zt;
    }
#line 6910
    r = sqrt(r);
#line 6910
    *V += (bp->k * (r - bp->length)) * (r - bp->length);
#line 6911
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 6911
      return (1);
    }
#line 6912
    bp = (RESTRAIN *)bp->next;
  }
}
}
#line 6915 "188.c"
int f_restrain(double lambda ) 
{ RESTRAIN *bp ;
  double r ;
  double k ;
  double ux ;
  double uy ;
  double uz ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 6921
  bp = restrain_first;
#line 6922
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 6922
    return (1);
  }
#line 6923
  while (1) {
#line 6925
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 6925
      return (0);
    }
#line 6926
    k = bp->k;
#line 6927
    a1 = bp->atom1;
#line 6927
    a2 = bp->atom2;
#line 6928
    if (lambda == 0.) {
#line 6930
      ux = a2->x - a1->x;
#line 6931
      uy = a2->y - a1->y;
#line 6932
      uz = a2->z - a1->z;
    } else {
#line 6934
      ux = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 6935
      uy = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 6936
      uz = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
    }
#line 6938
    r = (ux * ux + uy * uy) + uz * uz;
#line 6940
    if (r <= 1.e-5) {
#line 6941
      r = (double )0;
#line 6941
      ux = 1.;
#line 6941
      uy = 0.;
#line 6941
      uz = 0.;
    } else {
#line 6942
      r = sqrt(r);
#line 6942
      ux /= r;
#line 6942
      uy /= r;
#line 6942
      uz /= r;
    }
#line 6944
    ux = (((double )2 * k) * (r - bp->length)) * ux;
#line 6945
    uy = (((double )2 * k) * (r - bp->length)) * uy;
#line 6946
    uz = (((double )2 * k) * (r - bp->length)) * uz;
#line 6947
    a1->fx += ux;
#line 6948
    a1->fy += uy;
#line 6949
    a1->fz += uz;
#line 6950
    a2->fx -= ux;
#line 6951
    a2->fy -= uy;
#line 6952
    a2->fz -= uz;
#line 6953
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 6953
      return (1);
    }
#line 6954
    bp = (RESTRAIN *)bp->next;
  }
}
}
#line 6957 "188.c"
void get_restrain(ATOM *a1 , ATOM **restrained , int mrestrain , int *inrestrain ) 
{ RESTRAIN *mine ;
  int tmp ;
  int tmp___0 ;

  {
#line 6962
  mine = restrain_first;
#line 6963
  *inrestrain = 0;
#line 6964
  while (1) {
#line 6966
    if ((unsigned int )mine == (unsigned int )((void *)0)) {
#line 6968
      return;
    }
#line 6970
    if ((unsigned int )mine->atom1 == (unsigned int )a1) {
#line 6972
      tmp = *inrestrain;
#line 6972
      (*inrestrain) ++;
#line 6972
      *(restrained + tmp) = mine->atom2;
    }
#line 6974
    if ((unsigned int )mine->atom2 == (unsigned int )a1) {
#line 6976
      tmp___0 = *inrestrain;
#line 6976
      (*inrestrain) ++;
#line 6976
      *(restrained + tmp___0) = mine->atom1;
    }
#line 6978
    if ((unsigned int )mine == (unsigned int )mine->next) {
#line 6978
      return;
    }
#line 6979
    mine = (RESTRAIN *)mine->next;
#line 6980
    if (*inrestrain == mrestrain) {
#line 6980
      return;
    }
  }
}
}
#line 6983 "188.c"
void dump_restrains(FILE *where ) 
{ RESTRAIN *b ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 6987
  b = restrain_first;
#line 6988
  if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 6988
    return;
  }
#line 6989
  while ((unsigned int )b->next != (unsigned int )b) {
#line 6991
    if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 6991
      return;
    }
#line 6992
    a1 = b->atom1;
#line 6992
    a2 = b->atom2;
#line 6993
    fprintf(where, "restrain %d %d %f %f ;\n", a1->serial, a2->serial, b->length,
            b->k);
#line 6995
    b = (RESTRAIN *)b->next;
  }
#line 6997
  if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 6997
    return;
  }
#line 6998
  a1 = b->atom1;
#line 6998
  a2 = b->atom2;
#line 6999
  fprintf(where, "restrain %d %d %f %f ;\n", a1->serial, a2->serial, b->length, b->k);
#line 7001
  return;
}
}
#line 7002 "188.c"
int a_restrain(double *V , double lambda , int ilow , int ihigh , FILE *op ) 
{ RESTRAIN *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;
  ATOM *a2 ;

  {
#line 7010
  bp = restrain_first;
#line 7011
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7011
    return (1);
  }
#line 7012
  while (1) {
#line 7014
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7014
      return (0);
    }
#line 7015
    a1 = bp->atom1;
#line 7015
    a2 = bp->atom2;
#line 7016
    if (a1->serial >= ilow) {
#line 7016
      if (a1->serial <= ihigh) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 7016
      if (a2->serial >= ilow) {
#line 7016
        if (a2->serial <= ihigh) {
          _L: /* CIL Label */ 
#line 7019
          if (lambda == 0.) {
#line 7021
            r = (a1->x - a2->x) * (a1->x - a2->x);
#line 7022
            r += (a1->y - a2->y) * (a1->y - a2->y);
#line 7023
            r += (a1->z - a2->z) * (a1->z - a2->z);
          } else {
#line 7026
            xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 7027
            yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 7028
            zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 7029
            r = (xt * xt + yt * yt) + zt * zt;
          }
#line 7031
          r = sqrt(r);
#line 7031
          zt = (bp->k * (r - bp->length)) * (r - bp->length);
#line 7032
          *V += zt;
#line 7033
          fprintf(op, "Restrain %d %d E %f value %f error %f\n", a1->serial, a2->serial,
                  zt, r, r - bp->length);
        }
      }
    }
#line 7036
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 7036
      return (1);
    }
#line 7037
    bp = (RESTRAIN *)bp->next;
  }
}
}
#line 7042 "188.c"
int significance(FILE *op ) 
{ int ns ;
  int na ;
  double delta ;
  double rmsd ;

  {
#line 7049
  ns = get_i_variable("numstp");
#line 7050
  na = a_number();
#line 7051
  delta = get_f_variable("delta");
#line 7052
  rmsd = get_f_variable("rmsdev");
#line 7053
  if (ns <= 0) {
#line 7054
    fprintf(op, " you are cheating, seti numstp <number of MD steps>\n");
  }
#line 7057
  if (delta > 20.) {
#line 7059
    fprintf(op, " The drift in the total energy is too high\n");
#line 7060
    return (0);
  } else {
#line 7057
    if (delta < - 20.) {
#line 7059
      fprintf(op, " The drift in the total energy is too high\n");
#line 7060
      return (0);
    }
  }
#line 7062
  if (ns < 100) {
#line 7062
    if (rmsd > 0.01) {
#line 7064
      fprintf(op, " The RMSD is too high \n");
#line 7065
      return (0);
    }
  }
#line 7067
  if (ns < 1000) {
#line 7067
    if (ns > 99) {
#line 7067
      if (rmsd > 0.1) {
#line 7069
        fprintf(op, " The RMSD is too high \n");
#line 7070
        return (0);
      }
    }
  }
#line 7072
  if (ns < 10000) {
#line 7072
    if (ns > 999) {
#line 7072
      if (rmsd > 1.0) {
#line 7074
        fprintf(op, " The RMSD is too high \n");
#line 7075
        return (0);
      }
    }
  }
#line 7077
  fprintf(op, " The run is ok\n");
#line 7078
  return (0);
}
}
#line 7085 "188.c"
void tailor_qab(int who , double q , double a , double b ) 
{ ATOM *ap___1 ;

  {
#line 7090
  ap___1 = a_m_serial(who);
#line 7091
  if ((unsigned int )ap___1 == (unsigned int )((void *)0)) {
#line 7091
    aaerror((char *)" undefined atom in tailor_qab");
#line 7091
    return;
  }
#line 7092
  ap___1->q = q;
#line 7092
  ap___1->a = a;
#line 7092
  ap___1->b = b;
#line 7093
  return;
}
}
#line 7095 "188.c"
void tailor_include(int from , int to ) 
{ ATOM *ap1 ;
  ATOM *ap2 ;
  int i ;

  {
#line 7100
  ap1 = a_m_serial(from);
#line 7101
  if ((unsigned int )ap1 == (unsigned int )((void *)0)) {
#line 7101
    aaerror((char *)" undefined atom in tailor_include");
#line 7101
    return;
  }
#line 7102
  ap2 = a_m_serial(to);
#line 7103
  if ((unsigned int )ap2 == (unsigned int )((void *)0)) {
#line 7103
    aaerror((char *)" undefined atom in tailor_include");
#line 7103
    return;
  }
#line 7104
  i = 0;
#line 7104
  while (i < ap1->dontuse) {
#line 7105
    if ((unsigned int )ap1->excluded[i] == (unsigned int )ap2) {
#line 7105
      break;
    }
#line 7104
    i ++;
  }
#line 7106
  if (i < ap1->dontuse - 1) {
#line 7108
    while (i < ap1->dontuse - 1) {
#line 7110
      ap1->excluded[i] = ap1->excluded[i + 1];
#line 7111
      ap1->exkind[i] = ap1->exkind[i + 1];
#line 7108
      i ++;
    }
  }
#line 7114
  ap1->exkind[ap1->dontuse] = (char)0;
#line 7115
  (ap1->dontuse) --;
#line 7116
  i = 0;
#line 7116
  while (i < ap2->dontuse) {
#line 7117
    if ((unsigned int )ap2->excluded[i] == (unsigned int )ap1) {
#line 7117
      break;
    }
#line 7116
    i ++;
  }
#line 7118
  if (i < ap2->dontuse - 1) {
#line 7120
    while (i < ap2->dontuse - 1) {
#line 7122
      ap2->excluded[i] = ap2->excluded[i + 1];
#line 7123
      ap2->exkind[i] = ap2->exkind[i + 1];
#line 7120
      i ++;
    }
  }
#line 7126
  ap2->exkind[ap2->dontuse] = (char)0;
#line 7127
  (ap2->dontuse) --;
#line 7128
  return;
}
}
#line 7129 "188.c"
void tailor_exclude(int from , int to ) 
{ ATOM *ap1 ;
  ATOM *ap2 ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 7135
  ap1 = a_m_serial(from);
#line 7136
  if ((unsigned int )ap1 == (unsigned int )((void *)0)) {
#line 7136
    aaerror((char *)" undefined atom in tailor_exclude");
#line 7136
    return;
  }
#line 7137
  ap2 = a_m_serial(to);
#line 7138
  if ((unsigned int )ap2 == (unsigned int )((void *)0)) {
#line 7138
    aaerror((char *)" undefined atom in tailor_exclude");
#line 7138
    return;
  }
#line 7139
  if (ap1->dontuse == 32) {
#line 7140
    aaerror((char *)" cannot add an atom to the exclude list ");
#line 7140
    return;
  }
#line 7141
  i = 0;
#line 7141
  while (i < ap1->dontuse) {
#line 7142
    if ((unsigned int )ap1->excluded[i] == (unsigned int )ap2) {
      goto FOUND;
    }
#line 7141
    i ++;
  }
#line 7143
  ap1->exkind[ap1->dontuse] = (char)1;
#line 7144
  tmp = ap1->dontuse;
#line 7144
  (ap1->dontuse) ++;
#line 7144
  ap1->excluded[tmp] = (void *)ap2;
  FOUND: 
#line 7146
  if (ap2->dontuse == 32) {
#line 7147
    aaerror((char *)" cannot add an atom to the exclude list ");
#line 7147
    return;
  }
#line 7148
  i = 0;
#line 7148
  while (i < ap2->dontuse) {
#line 7149
    if ((unsigned int )ap2->excluded[i] == (unsigned int )ap1) {
#line 7149
      return;
    }
#line 7148
    i ++;
  }
#line 7150
  ap2->exkind[ap2->dontuse] = (char)1;
#line 7151
  tmp___0 = ap2->dontuse;
#line 7151
  (ap2->dontuse) ++;
#line 7151
  ap2->excluded[tmp___0] = (void *)ap1;
#line 7152
  i = 0;
#line 7153
  i = get_i_variable("numtail");
#line 7154
  i ++;
#line 7155
  set_i_variable("numtail", i);
#line 7156
  return;
}
}
#line 7168 "188.c"
TETHER *tether_first  =    (TETHER *)((void *)0);
#line 7169 "188.c"
TETHER *tether_last  =    (TETHER *)((void *)0);
#line 7170 "188.c"
int tether(int p1 , double fk , double x , double y , double z ) 
{ ATOM *ap1 ;
  TETHER *new ;
  char line[80] ;
  void *tmp ;

  {
#line 7177
  ap1 = a_m_serial(p1);
#line 7178
  if ((unsigned int )ap1 == (unsigned int )((void *)0)) {
#line 7180
    sprintf(line, "undefined atom in tether %d \000", p1);
#line 7181
    aaerror(line);
#line 7182
    return (0);
  }
#line 7184
  if ((unsigned int )tether_first != (unsigned int )((void *)0)) {
#line 7186
    new = tether_first;
#line 7187
    while (! ((unsigned int )new->next == (unsigned int )((void *)0))) {
#line 7190
      if ((unsigned int )new->atom1 == (unsigned int )ap1) {
#line 7192
        new->k = fk;
#line 7193
        new->x = x;
#line 7194
        new->y = y;
#line 7195
        new->z = z;
#line 7196
        return (1);
      }
#line 7198
      if ((unsigned int )new->next == (unsigned int )new) {
#line 7198
        break;
      }
#line 7199
      new = (TETHER *)new->next;
    }
  }
#line 7202
  tmp = malloc(sizeof(TETHER ));
#line 7202
  new = (TETHER *)tmp;
#line 7202
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 7204
    return (0);
  }
#line 7207
  if ((unsigned int )tether_first == (unsigned int )((void *)0)) {
#line 7207
    tether_first = new;
  }
#line 7208
  if ((unsigned int )tether_last == (unsigned int )((void *)0)) {
#line 7208
    tether_last = new;
  }
#line 7209
  new->atom1 = ap1;
#line 7210
  new->k = fk;
#line 7211
  new->x = x;
#line 7212
  new->y = y;
#line 7213
  new->z = z;
#line 7214
  new->next = (void *)new;
#line 7215
  tether_last->next = (void *)new;
#line 7216
  tether_last = new;
#line 7217
  return (1);
}
}
#line 7219 "188.c"
int alltether(double fk ) 
{ ATOM *ap1 ;
  int i ;
  int numatm ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 7225
  numatm = a_number();
#line 7226
  if (numatm < 1) {
#line 7226
    return (0);
  }
#line 7227
  i = 0;
#line 7227
  while (i < numatm) {
#line 7229
    ap1 = a_next(i);
#line 7230
    tmp___2 = fabs(ap1->x);
#line 7230
    if (tmp___2 > 1.e-8) {
#line 7231
      tmp___1 = fabs(ap1->y);
#line 7231
      if (tmp___1 > 1.e-8) {
#line 7232
        tmp___0 = fabs(ap1->z);
#line 7232
        if (tmp___0 > 1.e-8) {
#line 7234
          tmp = tether(ap1->serial, fk, ap1->x, ap1->y, ap1->z);
#line 7234
          if (! tmp) {
#line 7235
            return (0);
          }
        }
      }
    }
#line 7227
    i ++;
  }
#line 7238
  return (numatm);
}
}
#line 7240 "188.c"
int v_tether(double *V , double lambda ) 
{ TETHER *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;

  {
#line 7246
  bp = tether_first;
#line 7247
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7247
    return (1);
  }
#line 7248
  while (1) {
#line 7250
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7250
      return (0);
    }
#line 7251
    a1 = bp->atom1;
#line 7252
    if (a1->active) {
#line 7253
      if (lambda == 0.) {
#line 7255
        r = (a1->x - bp->x) * (a1->x - bp->x);
#line 7256
        r += (a1->y - bp->y) * (a1->y - bp->y);
#line 7257
        r += (a1->z - bp->z) * (a1->z - bp->z);
      } else {
#line 7260
        xt = (a1->x - bp->x) + lambda * a1->dx;
#line 7261
        yt = (a1->y - bp->y) + lambda * a1->dy;
#line 7262
        zt = (a1->z - bp->z) + lambda * a1->dz;
#line 7263
        r = (xt * xt + yt * yt) + zt * zt;
      }
#line 7265
      *V += bp->k * r;
    }
#line 7267
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 7267
      return (1);
    }
#line 7268
    bp = (TETHER *)bp->next;
  }
}
}
#line 7271 "188.c"
int f_tether(double lambda ) 
{ TETHER *bp ;
  double r ;
  double k ;
  double ux ;
  double uy ;
  double uz ;
  ATOM *a1 ;

  {
#line 7277
  bp = tether_first;
#line 7278
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7278
    return (1);
  }
#line 7279
  while (1) {
#line 7281
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7281
      return (0);
    }
#line 7282
    k = bp->k;
#line 7283
    a1 = bp->atom1;
#line 7284
    if (a1->active) {
#line 7285
      if (lambda == 0.) {
#line 7287
        ux = a1->x - bp->x;
#line 7288
        uy = a1->y - bp->y;
#line 7289
        uz = a1->z - bp->z;
      } else {
#line 7291
        ux = (a1->x - bp->x) + lambda * a1->dx;
#line 7292
        uy = (a1->y - bp->y) + lambda * a1->dy;
#line 7293
        uz = (a1->z - bp->z) + lambda * a1->dz;
      }
#line 7295
      r = (ux * ux + uy * uy) + uz * uz;
#line 7297
      if (r <= 1.e-5) {
        goto SKIP;
      } else {
#line 7299
        r = sqrt(r);
#line 7299
        ux /= r;
#line 7299
        uy /= r;
#line 7299
        uz /= r;
      }
#line 7301
      ux = (((double )2 * k) * r) * ux;
#line 7302
      uy = (((double )2 * k) * r) * uy;
#line 7303
      uz = (((double )2 * k) * r) * uz;
#line 7304
      a1->fx -= ux;
#line 7305
      a1->fy -= uy;
#line 7306
      a1->fz -= uz;
    }
    SKIP: 
#line 7309
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 7309
      return (1);
    }
#line 7310
    bp = (TETHER *)bp->next;
  }
}
}
#line 7313 "188.c"
void dump_tethers(FILE *where ) 
{ TETHER *b ;
  ATOM *a1 ;

  {
#line 7317
  b = tether_first;
#line 7318
  if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 7318
    return;
  }
#line 7319
  while ((unsigned int )b->next != (unsigned int )b) {
#line 7321
    if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 7321
      return;
    }
#line 7322
    a1 = b->atom1;
#line 7323
    fprintf(where, "tether %d %f %f %f %f ;\n", a1->serial, b->k, b->x, b->y, b->z);
#line 7325
    b = (TETHER *)b->next;
  }
#line 7327
  if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 7327
    return;
  }
#line 7328
  a1 = b->atom1;
#line 7329
  fprintf(where, "tether %d %f %f %f %f ;\n", a1->serial, b->k, b->x, b->y, b->z);
#line 7331
  return;
}
}
#line 7342
double bstrot(double *x , double *y , double *z , double *xx , double *yy , double *zz ,
              int na , double (*matrix)[3] , double *delta ) ;
#line 7332 "188.c"
int a_tether(double *V , double lambda , int ilow , int ihigh , FILE *op ) 
{ TETHER *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  double rms ;
  double rmax ;
  int tried ;
  int imax ;
  ATOM *a1 ;
  double (*x)[] ;
  double (*y)[] ;
  double (*z)[] ;
  double (*xx)[] ;
  double (*yy)[] ;
  double (*zz)[] ;
  double matrix[3][3] ;
  double delta[3] ;
  int numatm ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;

  {
#line 7347
  rms = 0.;
#line 7347
  rmax = - 1.;
#line 7348
  tried = 0;
#line 7349
  bp = tether_first;
#line 7350
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7350
    return (1);
  }
#line 7351
  numatm = a_number();
#line 7352
  tmp = malloc((unsigned int )numatm * sizeof(double ));
#line 7352
  x = (double (*)[])tmp;
#line 7353
  tmp___0 = malloc((unsigned int )numatm * sizeof(double ));
#line 7353
  y = (double (*)[])tmp___0;
#line 7354
  tmp___1 = malloc((unsigned int )numatm * sizeof(double ));
#line 7354
  z = (double (*)[])tmp___1;
#line 7355
  tmp___2 = malloc((unsigned int )numatm * sizeof(double ));
#line 7355
  xx = (double (*)[])tmp___2;
#line 7356
  tmp___3 = malloc((unsigned int )numatm * sizeof(double ));
#line 7356
  yy = (double (*)[])tmp___3;
#line 7357
  tmp___4 = malloc((unsigned int )numatm * sizeof(double ));
#line 7357
  zz = (double (*)[])tmp___4;
#line 7358
  if ((unsigned int )x == (unsigned int )((void *)0)) {
#line 7360
    aaerror((char *)"cannot allocate memory");
#line 7360
    return (1);
  } else {
#line 7358
    if ((unsigned int )y == (unsigned int )((void *)0)) {
#line 7360
      aaerror((char *)"cannot allocate memory");
#line 7360
      return (1);
    } else {
#line 7358
      if ((unsigned int )z == (unsigned int )((void *)0)) {
#line 7360
        aaerror((char *)"cannot allocate memory");
#line 7360
        return (1);
      } else {
#line 7358
        if ((unsigned int )xx == (unsigned int )((void *)0)) {
#line 7360
          aaerror((char *)"cannot allocate memory");
#line 7360
          return (1);
        } else {
#line 7358
          if ((unsigned int )yy == (unsigned int )((void *)0)) {
#line 7360
            aaerror((char *)"cannot allocate memory");
#line 7360
            return (1);
          } else {
#line 7358
            if ((unsigned int )zz == (unsigned int )((void *)0)) {
#line 7360
              aaerror((char *)"cannot allocate memory");
#line 7360
              return (1);
            }
          }
        }
      }
    }
  }
#line 7361
  while (1) {
#line 7363
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7363
      return (0);
    }
#line 7364
    a1 = bp->atom1;
#line 7365
    if (a1->serial >= ilow) {
#line 7365
      if (a1->serial <= ihigh) {
#line 7367
        if (lambda == 0.) {
#line 7369
          r = (a1->x - bp->x) * (a1->x - bp->x);
#line 7370
          r += (a1->y - bp->y) * (a1->y - bp->y);
#line 7371
          r += (a1->z - bp->z) * (a1->z - bp->z);
        } else {
#line 7374
          xt = (a1->x - bp->x) + lambda * a1->dx;
#line 7375
          yt = (a1->y - bp->y) + lambda * a1->dy;
#line 7376
          zt = (a1->z - bp->z) + lambda * a1->dz;
#line 7377
          r = (xt * xt + yt * yt) + zt * zt;
        }
#line 7379
        (*x)[tried] = a1->x + lambda * a1->dx;
#line 7380
        (*y)[tried] = a1->y + lambda * a1->dy;
#line 7381
        (*z)[tried] = a1->z + lambda * a1->dz;
#line 7382
        (*xx)[tried] = bp->x;
#line 7383
        (*yy)[tried] = bp->y;
#line 7384
        (*zz)[tried] = bp->z;
#line 7385
        tried ++;
#line 7386
        rms += r;
#line 7387
        if (r > rmax) {
#line 7387
          rmax = r;
#line 7387
          imax = a1->serial;
        }
#line 7388
        zt = bp->k * r;
#line 7389
        *V += zt;
#line 7391
        tmp___5 = sqrt(r);
#line 7391
        fprintf(op, "Tether %d E %f error %f\n", a1->serial, zt, tmp___5);
      }
    }
#line 7394
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 7394
      break;
    }
#line 7395
    bp = (TETHER *)bp->next;
  }
#line 7397
  if (tried > 0) {
#line 7398
    rms = sqrt(rms / (double )tried);
#line 7398
    rmax = sqrt(rmax);
#line 7399
    fprintf(op, " RMSD %f Maximum Deviation %f \n", rms, rmax);
#line 7400
    tmp___6 = bstrot(& (*x)[0], & (*y)[0], & (*z)[0], & (*xx)[0], & (*yy)[0], & (*zz)[0],
                     tried, matrix, delta);
#line 7400
    fprintf(op, " RMSD after superposition %f\n", tmp___6);
#line 7403
    set_f_variable((char *)"rmsdev", rms);
  }
#line 7405
  free((void *)zz);
#line 7405
  free((void *)yy);
#line 7405
  free((void *)xx);
#line 7405
  free((void *)z);
#line 7405
  free((void *)y);
#line 7405
  free((void *)x);
#line 7406
  return (1);
}
}
#line 7419
void cpyvec(double *orig , double *copy , int n ) ;
#line 7420
void matmul(double *a , double *b , double *c , int n , int m ) ;
#line 7408 "188.c"
double bstrot(double *x , double *y , double *z , double *xx , double *yy , double *zz ,
              int na , double (*matrix)[3] , double *delta ) 
{ double tensor[3][3] ;
  double cx ;
  double cy ;
  double cz ;
  double cxx ;
  double cyy ;
  double czz ;
  double tx ;
  double ty ;
  double tz ;
  double txx ;
  double tyy ;
  double tzz ;
  double rms ;
  double sx[3][3] ;
  double sy[3][3] ;
  double sz[3][3] ;
  double sq[3][3] ;
  int i ;
  int j ;
  int ipass ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 7422
  if (na < 1) {
#line 7422
    return (- 1.);
  }
#line 7423
  cx = 0.;
#line 7424
  cy = 0.;
#line 7425
  cz = 0.;
#line 7426
  cxx = 0.;
#line 7427
  cyy = 0.;
#line 7428
  czz = 0.;
#line 7429
  i = 0;
#line 7429
  while (i < na) {
#line 7431
    cx += *(x + i);
#line 7432
    cy += *(y + i);
#line 7433
    cz += *(z + i);
#line 7434
    cxx += *(xx + i);
#line 7435
    cyy += *(yy + i);
#line 7436
    czz += *(zz + i);
#line 7429
    i ++;
  }
#line 7438
  cx /= (double )na;
#line 7439
  cy /= (double )na;
#line 7440
  cz /= (double )na;
#line 7441
  cxx /= (double )na;
#line 7442
  cyy /= (double )na;
#line 7443
  czz /= (double )na;
#line 7444
  i = 0;
#line 7444
  while (i < 3) {
#line 7445
    j = 0;
#line 7445
    while (j < 3) {
#line 7447
      tensor[i][j] = 0.;
#line 7448
      (*(matrix + i))[j] = 0.;
#line 7449
      sx[i][j] = 0.;
#line 7450
      sy[i][j] = 0.;
#line 7451
      sz[i][j] = 0.;
#line 7445
      j ++;
    }
#line 7444
    i ++;
  }
#line 7453
  (*(matrix + 0))[0] = 1.;
#line 7454
  (*(matrix + 1))[1] = 1.;
#line 7455
  (*(matrix + 2))[2] = 1.;
#line 7456
  sx[0][0] = 1.;
#line 7457
  sy[1][1] = 1.;
#line 7458
  sz[2][2] = 1.;
#line 7459
  i = 0;
#line 7459
  while (i < na) {
#line 7461
    tx = *(x + i) - cx;
#line 7462
    ty = *(y + i) - cy;
#line 7463
    tz = *(z + i) - cz;
#line 7464
    txx = *(xx + i) - cxx;
#line 7465
    tyy = *(yy + i) - cyy;
#line 7466
    tzz = *(zz + i) - czz;
#line 7467
    tensor[0][0] += tx * txx;
#line 7468
    tensor[0][1] += tx * tyy;
#line 7469
    tensor[0][2] += tx * tzz;
#line 7470
    tensor[1][0] += ty * txx;
#line 7471
    tensor[1][1] += ty * tyy;
#line 7472
    tensor[1][2] += ty * tzz;
#line 7473
    tensor[2][0] += tz * txx;
#line 7474
    tensor[2][1] += tz * tyy;
#line 7475
    tensor[2][2] += tz * tzz;
#line 7459
    i ++;
  }
#line 7477
  ipass = 0;
#line 7477
  while (ipass < 20) {
#line 7479
    rms = 0.;
#line 7481
    tx = atan2(tensor[2][1] - tensor[1][2], tensor[1][1] + tensor[2][2]);
#line 7483
    tmp = fabs(tx);
#line 7483
    rms += tmp;
#line 7484
    ty = cos(tx);
#line 7484
    tz = sin(tx);
#line 7485
    sx[1][1] = ty;
#line 7486
    sx[2][1] = - tz;
#line 7487
    sx[1][2] = tz;
#line 7488
    sx[2][2] = ty;
#line 7489
    matmul(sx, tensor, sq, 3, 3);
#line 7490
    cpyvec(sq, tensor, 9);
#line 7491
    matmul(sx, matrix, sq, 3, 3);
#line 7492
    cpyvec(sq, matrix, 9);
#line 7494
    tx = atan2(tensor[2][0] - tensor[0][2], tensor[0][0] + tensor[2][2]);
#line 7496
    tmp___0 = fabs(tx);
#line 7496
    rms += tmp___0;
#line 7497
    ty = cos(tx);
#line 7497
    tz = sin(tx);
#line 7498
    sy[0][0] = ty;
#line 7499
    sy[2][0] = - tz;
#line 7500
    sy[0][2] = tz;
#line 7501
    sy[2][2] = ty;
#line 7502
    matmul(sy, tensor, sq, 3, 3);
#line 7503
    cpyvec(sq, tensor, 9);
#line 7504
    matmul(sy, matrix, sq, 3, 3);
#line 7505
    cpyvec(sq, matrix, 9);
#line 7507
    tx = atan2(tensor[0][1] - tensor[1][0], tensor[1][1] + tensor[0][0]);
#line 7509
    tmp___1 = fabs(tx);
#line 7509
    rms += tmp___1;
#line 7510
    ty = cos(tx);
#line 7510
    tz = sin(tx);
#line 7511
    sz[1][1] = ty;
#line 7512
    sz[0][1] = - tz;
#line 7513
    sz[1][0] = tz;
#line 7514
    sz[0][0] = ty;
#line 7515
    matmul(sz, tensor, sq, 3, 3);
#line 7516
    cpyvec(sq, tensor, 9);
#line 7517
    matmul(sz, matrix, sq, 3, 3);
#line 7518
    cpyvec(sq, matrix, 9);
#line 7519
    if (rms < 1.e-7) {
#line 7519
      break;
    }
#line 7477
    ipass ++;
  }
#line 7521
  rms = 0.;
#line 7522
  i = 0;
#line 7522
  while (i < na) {
#line 7524
    txx = *(xx + i) - cxx;
#line 7525
    tyy = *(yy + i) - cyy;
#line 7526
    tzz = *(zz + i) - czz;
#line 7527
    tx = ((*(matrix + 0))[0] * txx + (*(matrix + 1))[0] * tyy) + (*(matrix + 2))[0] * tzz;
#line 7528
    ty = ((*(matrix + 0))[1] * txx + (*(matrix + 1))[1] * tyy) + (*(matrix + 2))[1] * tzz;
#line 7529
    tz = ((*(matrix + 0))[2] * txx + (*(matrix + 1))[2] * tyy) + (*(matrix + 2))[2] * tzz;
#line 7530
    tx += cx - *(x + i);
#line 7531
    ty += cy - *(y + i);
#line 7532
    tz += cz - *(z + i);
#line 7533
    rms += (tx * tx + ty * ty) + tz * tz;
#line 7522
    i ++;
  }
#line 7535
  tx = ((*(matrix + 0))[0] * cxx + (*(matrix + 1))[0] * cyy) + (*(matrix + 2))[0] * czz;
#line 7536
  ty = ((*(matrix + 0))[1] * cxx + (*(matrix + 1))[1] * cyy) + (*(matrix + 2))[1] * czz;
#line 7537
  tz = ((*(matrix + 0))[2] * cxx + (*(matrix + 1))[2] * cyy) + (*(matrix + 2))[2] * czz;
#line 7538
  *(delta + 0) = cx - tx;
#line 7539
  *(delta + 1) = cy - ty;
#line 7540
  *(delta + 2) = cz - tz;
#line 7541
  tmp___2 = sqrt(rms / (double )na);
#line 7541
  return (tmp___2);
}
}
#line 7543 "188.c"
void cpyvec(double *orig , double *copy , int n ) 
{ int i ;

  {
#line 7548
  i = 0;
#line 7548
  while (i < n) {
#line 7549
    *(copy + i) = *(orig + i);
#line 7548
    i ++;
  }
#line 7550
  return;
}
}
#line 7551 "188.c"
void matmul(double *a , double *b , double *c , int n , int m ) 
{ int i ;
  int j ;
  int k ;
  int ioff ;
  int koff ;

  {
#line 7556
  i = 0;
#line 7556
  while (i < n * n) {
#line 7557
    *(c + i) = 0.;
#line 7556
    i ++;
  }
#line 7558
  i = 0;
#line 7558
  while (i < n) {
#line 7560
    ioff = i * n;
#line 7561
    j = 0;
#line 7561
    while (j < n) {
#line 7563
      koff = (int )0.;
#line 7564
      k = 0;
#line 7564
      while (k < m) {
#line 7566
        *(c + (ioff + j)) += *(a + (ioff + k)) * *(b + (j + koff));
#line 7567
        koff += m;
#line 7564
        k ++;
      }
#line 7561
      j ++;
    }
#line 7558
    i ++;
  }
#line 7571
  return;
}
}
#line 7572 "188.c"
int v_ho_tether(double *V , double lambda ) 
{ TETHER *bp ;
  double r ;
  double xt ;
  double yt ;
  double zt ;
  ATOM *a1 ;
  double hol ;

  {
#line 7579
  hol = get_f_variable("lambda");
#line 7580
  if (hol < 0.) {
#line 7580
    hol = 0.;
  }
#line 7581
  if (hol > 1.) {
#line 7581
    hol = 1.;
  }
#line 7582
  if (hol == 1.) {
#line 7582
    return (0);
  }
#line 7583
  bp = tether_first;
#line 7584
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7584
    return (1);
  }
#line 7585
  while (1) {
#line 7587
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7587
      return (0);
    }
#line 7588
    a1 = bp->atom1;
#line 7589
    if (a1->active) {
#line 7590
      if (lambda == 0.) {
#line 7592
        xt = a1->x - bp->x;
#line 7593
        yt = a1->y - bp->y;
#line 7594
        zt = a1->z - bp->z;
      } else {
#line 7597
        xt = (a1->x + lambda * a1->dx) - bp->x;
#line 7598
        yt = (a1->y + lambda * a1->dy) - bp->y;
#line 7599
        zt = (a1->z + lambda * a1->dz) - bp->z;
      }
#line 7601
      r = (((xt * xt + yt * yt) + zt * zt) * (1. - hol)) * (1. - hol);
#line 7602
      *V += bp->k * r;
    }
#line 7604
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 7604
      return (1);
    }
#line 7605
    bp = (TETHER *)bp->next;
  }
}
}
#line 7608 "188.c"
int f_ho_tether(double lambda ) 
{ TETHER *bp ;
  double r ;
  double k ;
  double ux ;
  double uy ;
  double uz ;
  ATOM *a1 ;
  double hol ;

  {
#line 7615
  hol = get_f_variable("lambda");
#line 7616
  if (hol < 0.) {
#line 7616
    hol = 0.;
  }
#line 7617
  if (hol > 1.) {
#line 7617
    hol = 1.;
  }
#line 7618
  if (hol == 1.) {
#line 7618
    return (0);
  }
#line 7619
  bp = tether_first;
#line 7620
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7620
    return (1);
  }
#line 7621
  while (1) {
#line 7623
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 7623
      return (0);
    }
#line 7624
    k = bp->k;
#line 7625
    a1 = bp->atom1;
#line 7626
    if (a1->active) {
#line 7627
      if (lambda == 0.) {
#line 7629
        ux = a1->x - bp->x;
#line 7630
        uy = a1->y - bp->y;
#line 7631
        uz = a1->z - bp->z;
      } else {
#line 7633
        ux = (a1->x - bp->x) + lambda * a1->dx;
#line 7634
        uy = (a1->y - bp->y) + lambda * a1->dy;
#line 7635
        uz = (a1->z - bp->z) + lambda * a1->dz;
      }
#line 7637
      r = (ux * ux + uy * uy) + uz * uz;
#line 7639
      if (r <= 1.e-5) {
        goto SKIP;
      } else {
#line 7641
        r = sqrt(r);
#line 7641
        ux /= r;
#line 7641
        uy /= r;
#line 7641
        uz /= r;
      }
#line 7643
      ux = ((((double )2 * k) * r) * ux) * (1. - hol);
#line 7644
      uy = ((((double )2 * k) * r) * uy) * (1. - hol);
#line 7645
      uz = ((((double )2 * k) * r) * uz) * (1. - hol);
#line 7646
      a1->fx -= ux;
#line 7647
      a1->fy -= uy;
#line 7648
      a1->fz -= uz;
    }
    SKIP: 
#line 7651
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 7651
      return (1);
    }
#line 7652
    bp = (TETHER *)bp->next;
  }
}
}
#line 7668 "188.c"
TGROUP *tg_first  =    (TGROUP *)((void *)0);
#line 7670 "188.c"
int tgroup(int which , int context , int b1 , int b2 , int b3 , double base , int ntry ) 
{ TGROUP *tgp ;
  TGROUP *tgo ;
  ATOM *bonded[20] ;
  ATOM *newest[100] ;
  ATOM *newer[100] ;
  int in_newest ;
  int in_newer ;
  int i ;
  int j ;
  int k ;
  int l ;
  int ll ;
  char line[80] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 7682
  if (ntry == 0) {
#line 7683
    base = 0.;
#line 7683
    ntry = 6;
  }
#line 7684
  tgp = tg_first;
#line 7685
  tgo = tgp;
#line 7686
  if (which == 0) {
#line 7687
    aaerror((char *)"warning tg_group 0 will never be accessed\n");
#line 7687
    return (0);
  }
#line 7688
  while ((unsigned int )tgp != (unsigned int )((void *)0)) {
#line 7690
    if (tgp->which == which) {
      goto found;
    }
#line 7691
    tgo = tgp;
#line 7692
    tgp = (TGROUP *)tgp->next;
  }
#line 7694
  tmp = malloc(sizeof(TGROUP ));
#line 7694
  tgp = (TGROUP *)tmp;
#line 7694
  if ((unsigned int )tgp == (unsigned int )((void *)0)) {
#line 7695
    aaerror((char *)" cannot allocate memory for a tg_group\n");
#line 7695
    exit(0);
  }
#line 7696
  if ((unsigned int )tgo != (unsigned int )((void *)0)) {
#line 7696
    tgo->next = (void *)tgp;
  }
#line 7697
  if ((unsigned int )tgo == (unsigned int )((void *)0)) {
#line 7697
    tg_first = tgp;
  }
#line 7698
  tgp->next = (void *)0;
  found: 
#line 7700
  if (context < 0) {
    goto _L;
  } else {
#line 7700
    if (b1 < 0) {
      goto _L;
    } else {
#line 7700
      if (b2 < 0) {
        goto _L;
      } else {
#line 7700
        if (b3 < 0) {
          _L: /* CIL Label */ 
#line 7702
          if ((unsigned int )tgo != (unsigned int )((void *)0)) {
#line 7702
            tgo->next = tgp->next;
          }
#line 7703
          if ((unsigned int )tgo == (unsigned int )((void *)0)) {
#line 7703
            tg_first = (TGROUP *)tgp->next;
          }
#line 7704
          free((void *)tgp);
#line 7705
          return (1);
        }
      }
    }
  }
#line 7707
  tgp->which = which;
#line 7708
  tgp->context = a_m_serial(context);
#line 7709
  tgp->b1 = a_m_serial(b1);
#line 7710
  tgp->b2 = a_m_serial(b2);
#line 7711
  tgp->b3 = a_m_serial(b3);
#line 7712
  if ((unsigned int )tgp->context == (unsigned int )((void *)0)) {
#line 7714
    sprintf(line, " tgroup %d  %d atom not defined cannot define tgroup ", which,
            context);
#line 7715
    aaerror(line);
#line 7716
    return (1);
  }
#line 7717
  if ((unsigned int )tgp->b1 == (unsigned int )((void *)0)) {
#line 7719
    sprintf(line, " tgroup %d  %d atom not defined cannot define tgroup ", which,
            b1);
#line 7720
    aaerror(line);
#line 7721
    return (1);
  }
#line 7722
  if ((unsigned int )tgp->b2 == (unsigned int )((void *)0)) {
#line 7724
    sprintf(line, " tgroup %d  %d atom not defined cannot define tgroup ", which,
            b2);
#line 7725
    aaerror(line);
#line 7726
    return (1);
  }
#line 7727
  if ((unsigned int )tgp->b3 == (unsigned int )((void *)0)) {
#line 7729
    sprintf(line, " tgroup %d  %d atom not defined cannot define tgroup ", which,
            b3);
#line 7730
    aaerror(line);
#line 7731
    return (1);
  }
#line 7732
  tgp->base = (base * 3.1415926589793) / 180.;
#line 7733
  k = 0;
#line 7733
  while (k < 100) {
#line 7734
    tgp->group[k] = (ATOM *)((void *)0);
#line 7733
    k ++;
  }
#line 7735
  if (ntry > 24) {
#line 7735
    ntry = 24;
  }
#line 7736
  tgp->ntry = ntry;
#line 7737
  get_bond(tgp->b2, bonded, 20, & j);
#line 7738
  k = 0;
#line 7738
  while (k < j) {
#line 7740
    if ((unsigned int )bonded[k] != (unsigned int )tgp->context) {
#line 7740
      if ((unsigned int )bonded[k] != (unsigned int )tgp->b3) {
#line 7740
        if ((unsigned int )bonded[k] != (unsigned int )tgp->b1) {
#line 7742
          break;
        }
      }
    }
#line 7738
    k ++;
  }
#line 7744
  newest[0] = tgp->b3;
#line 7745
  tgp->group[0] = tgp->b3;
#line 7746
  tgp->ingroup = 1;
#line 7747
  in_newest = 1;
#line 7748
  if (k != j) {
#line 7749
    newest[1] = bonded[k];
#line 7750
    tgp->group[1] = bonded[k];
#line 7751
    tgp->ingroup = 2;
#line 7752
    in_newest = 2;
#line 7753
    i = 0;
#line 7753
    while (i < j) {
#line 7755
      l = 1;
#line 7756
      k = 0;
#line 7756
      while (k < in_newest) {
#line 7757
        if ((unsigned int )newest[k] == (unsigned int )bonded[i]) {
#line 7757
          l = 0;
#line 7757
          break;
        }
#line 7756
        k ++;
      }
#line 7758
      if ((unsigned int )bonded[i] == (unsigned int )tgp->context) {
#line 7758
        l = 0;
      }
#line 7759
      if ((unsigned int )bonded[i] == (unsigned int )tgp->b1) {
#line 7759
        l = 0;
      }
#line 7760
      if ((unsigned int )bonded[i] == (unsigned int )tgp->b2) {
#line 7760
        l = 0;
      }
#line 7761
      if ((unsigned int )bonded[i] == (unsigned int )tgp->b3) {
#line 7761
        l = 0;
      }
#line 7762
      if (l == 1) {
#line 7763
        tmp___0 = tgp->ingroup;
#line 7763
        (tgp->ingroup) ++;
#line 7763
        tgp->group[tmp___0] = bonded[i];
#line 7764
        tmp___1 = in_newest;
#line 7764
        in_newest ++;
#line 7764
        newest[tmp___1] = bonded[i];
      }
#line 7753
      i ++;
    }
  }
#line 7768
  while (in_newest > 0) {
#line 7770
    in_newer = 0;
#line 7771
    l = 0;
#line 7771
    while (l < in_newest) {
#line 7773
      get_bond(newest[l], bonded, 20, & j);
#line 7774
      i = 0;
#line 7774
      while (i < j) {
#line 7776
        ll = 1;
#line 7777
        k = 0;
#line 7777
        while (k < tgp->ingroup) {
#line 7778
          if ((unsigned int )tgp->group[k] == (unsigned int )bonded[i]) {
#line 7779
            ll = 0;
#line 7779
            break;
          }
#line 7777
          k ++;
        }
#line 7781
        if ((unsigned int )bonded[i] == (unsigned int )tgp->context) {
#line 7781
          ll = 0;
        }
#line 7782
        if ((unsigned int )bonded[i] == (unsigned int )tgp->b1) {
#line 7782
          ll = 0;
        }
#line 7783
        if ((unsigned int )bonded[i] == (unsigned int )tgp->b2) {
#line 7783
          ll = 0;
        }
#line 7784
        if ((unsigned int )bonded[i] == (unsigned int )tgp->b3) {
#line 7784
          ll = 0;
        }
#line 7785
        if (ll == 1) {
#line 7787
          tmp___2 = tgp->ingroup;
#line 7787
          (tgp->ingroup) ++;
#line 7787
          tgp->group[tmp___2] = bonded[i];
#line 7788
          tmp___3 = in_newer;
#line 7788
          in_newer ++;
#line 7788
          newer[tmp___3] = bonded[i];
#line 7789
          if (tgp->ingroup > 100) {
#line 7790
            aaerror((char *)" too many atoms in a tgroup - must exit\n");
#line 7790
            exit(0);
          }
        }
#line 7774
        i ++;
      }
#line 7771
      l ++;
    }
#line 7794
    i = 0;
#line 7794
    while (i < in_newer) {
#line 7795
      newest[i] = newer[i];
#line 7794
      i ++;
    }
#line 7796
    in_newest = in_newer;
  }
#line 7798
  if (tgp->ingroup > 100) {
#line 7799
    aaerror((char *)" too many atoms in a tgroup - must exit\n");
#line 7799
    exit(0);
  }
#line 
  return (1);
}
}
#line 7805
TGROUP *match_tgroup(int i ) ;
#line 7809
void tg_do_search(double *Vp , TGROUP **gl , int *bl , int igl , int ngl ) ;
#line 7810
void tg_gen_con(TGROUP **gl , int *bl , int ngl ) ;
#line 7810
void tg_init(TGROUP **gl , int *ng , int deep ) ;
#line 7810
void tg_apply(TGROUP *tgp , int num ) ;
#line 7802 "188.c"
int tsearch(int t1 , int t2 , int t3 , int t4 , int t5 , int t6 , int t7 , int t8 ) 
{ TGROUP *grouplist[8] ;
  int ngroup ;
  int i ;
  int j ;
  int bestlist[8] ;
  double V ;

  {
#line 7811
  ngroup = 8;
#line 7812
  i = 0;
#line 7812
  while (i < ngroup) {
#line 7813
    grouplist[i] = (TGROUP *)((void *)0);
#line 7812
    i ++;
  }
#line 7814
  if (t8 <= 0) {
#line 7814
    ngroup = 7;
  }
#line 7815
  if (t7 <= 0) {
#line 7815
    ngroup = 6;
  }
#line 7816
  if (t6 <= 0) {
#line 7816
    ngroup = 5;
  }
#line 7817
  if (t5 <= 0) {
#line 7817
    ngroup = 4;
  }
#line 7818
  if (t4 <= 0) {
#line 7818
    ngroup = 3;
  }
#line 7819
  if (t3 <= 0) {
#line 7819
    ngroup = 2;
  }
#line 7820
  if (t2 <= 0) {
#line 7820
    ngroup = 1;
  }
#line 7821
  if (t1 <= 0) {
#line 7821
    ngroup = 0;
  }
#line 7822
  if (ngroup == 0) {
#line 7822
    return (1);
  }
#line 7823
  grouplist[7] = match_tgroup(t8);
#line 7824
  grouplist[6] = match_tgroup(t7);
#line 7825
  grouplist[5] = match_tgroup(t6);
#line 7826
  grouplist[4] = match_tgroup(t5);
#line 7827
  grouplist[3] = match_tgroup(t4);
#line 7828
  grouplist[2] = match_tgroup(t3);
#line 7829
  grouplist[1] = match_tgroup(t2);
#line 7830
  grouplist[0] = match_tgroup(t1);
#line 7831
  i = 0;
#line 7831
  while (i < ngroup) {
#line 7833
    if ((unsigned int )grouplist[i] != (unsigned int )((void *)0)) {
#line 7834
      j = 0;
#line 7834
      while (j < (grouplist[i])->ingroup) {
#line 7835
        if (! ((grouplist[i])->group[j])->active) {
#line 7836
          grouplist[i] = (TGROUP *)((void *)0);
#line 7836
          break;
        }
#line 7834
        j ++;
      }
#line 7837
      if ((unsigned int )grouplist[i] != (unsigned int )((void *)0)) {
#line 7838
        if (! ((grouplist[i])->b3)->active) {
#line 7839
          grouplist[i] = (TGROUP *)((void *)0);
        }
      }
    }
#line 7831
    i ++;
  }
#line 7842
  i = 0;
#line 7842
  while (i < ngroup) {
#line 7844
    if ((unsigned int )grouplist[i] == (unsigned int )((void *)0)) {
#line 7846
      j = i;
#line 7846
      while (j < ngroup - 1) {
#line 7847
        grouplist[j] = grouplist[j + 1];
#line 7846
        j ++;
      }
#line 7848
      ngroup --;
    }
#line 7842
    i ++;
  }
#line 7851
  //tg_init(grouplist, & ngroup, 0);
#line 7852
  //tg_do_search(& V, grouplist, bestlist, 0, ngroup);
#line 7853
  tg_gen_con(grouplist, bestlist, ngroup);
#line 7854
  return (0);
}
}
#line 7855 "188.c"
void tg_gen_con(TGROUP **gl , int *bl , int ngl ) 
{ ATOM *a1 ;
  int i ;
  int j ;

  {
#line 7862
  i = 0;
#line 7862
  while (i < ngl) {
#line 7864
    j = (ngl - i) - 1;
#line 7865
    tg_apply(*(gl + j), *(bl + j));
#line 7862
    i ++;
  }
#line 7867
  i = ngl - 1;
#line 7867
  while (i > -1) {
#line 7869
    j = 0;
#line 7869
    while (j < (*(gl + i))->ingroup) {
#line 7871
      a1 = (*(gl + i))->group[j];
#line 7872
      a1->x = a1->dx;
#line 7873
      a1->y = a1->dy;
#line 7874
      a1->z = a1->dz;
#line 7869
      j ++;
    }
#line 7867
    i --;
  }
#line 7877
  return;
}
}
#line 7888
void tg_d_apply(TGROUP *tgp , double off ) ;
#line 7878 "188.c"
void tg_init(TGROUP **gl , int *ng , int deep ) 
{ ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double x3 ;
  double y3 ;
  double z3 ;
  double cx1 ;
  double cy1 ;
  double cz1 ;
  double cx2 ;
  double cy2 ;
  double cz2 ;
  double dp ;
  double r ;
  int i ;
  int j ;
  int ngl ;

  {
#line 7891
  if (deep == 0) {
#line 7893
    j = a_number();
#line 7894
    i = 0;
#line 7894
    while (i < j) {
#line 7896
      a1 = a_next(i);
#line 7897
      a1->dx = a1->x;
#line 7898
      a1->dy = a1->y;
#line 7899
      a1->dz = a1->z;
#line 7894
      i ++;
    }
  }
#line 7902
  ngl = *ng;
#line 7903
  i = ngl - 1;
#line 7903
  while (i > -1) {
#line 7905
    if ((unsigned int )*(gl + i) == (unsigned int )((void *)0)) {
#line 7905
      if (i == 0) {
#line 7905
        *ng = 0;
#line 7905
        return;
      }
#line 7906
      *ng = i;
#line 7906
     // tg_init(gl, ng, deep + 1);
#line 7906
      return;
    }
#line 7907
    j = 0;
#line 7907
    while (j < (*(gl + i))->ingroup) {
#line 7909
      a1 = (*(gl + i))->group[j];
#line 7910
      if ((unsigned int )a1 == (unsigned int )((void *)0)) {
#line 7910
        return;
      }
#line 7911
      a1->dx = a1->x;
#line 7912
      a1->dy = a1->y;
#line 7913
      a1->dz = a1->z;
#line 7907
      j ++;
    }
#line 7915
    a1 = (*(gl + i))->context;
#line 7916
    a2 = (*(gl + i))->b1;
#line 7917
    a3 = (*(gl + i))->b2;
#line 7918
    a4 = (*(gl + i))->b3;
#line 7919
    a1->dx = a1->x;
#line 7920
    a1->dy = a1->y;
#line 7921
    a1->dz = a1->z;
#line 7922
    a2->dx = a2->x;
#line 7923
    a2->dy = a2->y;
#line 7924
    a2->dz = a2->z;
#line 7925
    a3->dx = a3->x;
#line 7926
    a3->dy = a3->y;
#line 7927
    a3->dz = a3->z;
#line 7928
    a4->dx = a4->x;
#line 7929
    a4->dy = a4->y;
#line 7930
    a4->dz = a4->z;
#line 7931
    x1 = a1->x - a2->x;
#line 7932
    y1___0 = a1->y - a2->y;
#line 7933
    z1 = a1->z - a2->z;
#line 7934
    x2 = a3->x - a2->x;
#line 7935
    y2 = a3->y - a2->y;
#line 7936
    z2 = a3->z - a2->z;
#line 7937
    x3 = a4->x - a3->x;
#line 7938
    y3 = a4->y - a3->y;
#line 7939
    z3 = a4->z - a3->z;
#line 7940
    cx1 = y1___0 * z2 - y2 * z1;
#line 7941
    cy1 = - x1 * z2 + x2 * z1;
#line 7942
    cz1 = x1 * y2 - x2 * y1___0;
#line 7943
    r = (cx1 * cx1 + cy1 * cy1) + cz1 * cz1;
#line 7944
    if (r < 1.e-4) {
      goto SKIP;
    }
#line 7945
    r = sqrt(r);
#line 7946
    cx1 /= r;
#line 7947
    cy1 /= r;
#line 7948
    cz1 /= r;
#line 7949
    cx2 = y3 * z2 - y2 * z3;
#line 7950
    cy2 = - x3 * z2 + x2 * z3;
#line 7951
    cz2 = x3 * y2 - x2 * y3;
#line 7952
    r = (cx2 * cx2 + cy2 * cy2) + cz2 * cz2;
#line 7953
    if (r < 1.e-4) {
      goto SKIP;
    }
#line 7954
    r = sqrt(r);
#line 7955
    cx2 /= r;
#line 7956
    cy2 /= r;
#line 7957
    cz2 /= r;
#line 7958
    dp = (cx1 * cx2 + cy1 * cy2) + cz1 * cz2;
#line 7959
    if (dp > 1.) {
#line 7959
      dp = 1.;
    }
#line 7959
    if (dp < - 1.) {
#line 7959
      dp = - 1.;
    }
#line 7960
    dp = acos(dp);
#line 7961
    r = (cx1 * x3 + cy1 * y3) + cz1 * z3;
#line 7962
    if (r > (double )0) {
#line 7962
      dp = - dp;
    }
#line 7963
    r = (*(gl + i))->base - dp;
#line 7964
    tg_d_apply(*(gl + i), r);
#line 7965
    j = 0;
#line 7965
    while (j < (*(gl + i))->ingroup) {
#line 7967
      a1 = (*(gl + i))->group[j];
#line 7968
      a1->x = a1->dx;
#line 7969
      a1->y = a1->dy;
#line 7970
      a1->z = a1->dz;
#line 7965
      j ++;
    }
    SKIP: 
#line 7972
    i = i;
#line 7903
    i --;
  }
#line 7975
  return;
}
}
#line 7993
int tg_nonbon(double *V , TGROUP *tgp ) ;
#line 7976 "188.c"
void tg_do_search(double *Vp , TGROUP **gl , int *bl , int igl , int ngl ) 
{ double vl[24] ;
  double vb ;
  int i ;
  int ibest ;
  int bestlist[24][8] ;
  int lbl[8] ;

  {
#line 7986
  if (igl == 8) {
#line 7986
    return;
  }
#line 7987
  if ((unsigned int )*(gl + igl) == (unsigned int )((void *)0)) {
#line 7987
    return;
  }
#line 7988
  if (igl > ngl) {
#line 7988
    return;
  }
#line 7990
  i = 0;
#line 7990
  while (i < (*(gl + igl))->ntry) {
#line 7992
   // tg_do_search(& vl[i], gl, lbl, igl + 1, ngl);
#line 7993
    tg_nonbon(& vl[i], *(gl + igl));
#line 7994
    ibest = 0;
#line 7994
    while (ibest < 8) {
#line 7995
      bestlist[i][ibest] = lbl[ibest];
#line 7994
      ibest ++;
    }
#line 7996
    if ((*(gl + igl))->ntry > 1) {
#line 7998
      tg_apply(*(gl + igl), 1);
    }
#line 7990
    i ++;
  }
#line 8001
  vb = 10e20;
#line 8002
  ibest = 0;
#line 8003
  i = 0;
#line 8003
  while (i < (*(gl + igl))->ntry) {
#line 8005
    if (vl[i] < vb) {
#line 8005
      vb = vl[i];
#line 8005
      ibest = i;
    }
#line 8003
    i ++;
  }
#line 8007
  bestlist[ibest][igl] = ibest;
#line 8008
  i = 0;
#line 8008
  while (i < 8) {
#line 8009
    *(bl + i) = bestlist[ibest][i];
#line 8008
    i ++;
  }
#line 8010
  *Vp = vl[ibest];
#line 8011
  return;
}
}
#line 8012 "188.c"
void tg_apply(TGROUP *tgp , int num ) 
{ double nx ;
  double ny ;
  double nz ;
  double phi ;
  double cphi ;
  double sphi ;
  double rx ;
  double ry ;
  double rz ;
  double nnrx ;
  double nnry ;
  double nnrz ;
  double rnx ;
  double rny ;
  double rnz ;
  ATOM *b1 ;
  ATOM *b2 ;
  int i ;

  {
#line 8021
  b1 = tgp->b1;
#line 8022
  b2 = tgp->b2;
#line 8023
  nx = b2->dx - b1->dx;
#line 8024
  ny = b2->dy - b1->dy;
#line 8025
  nz = b2->dz - b1->dz;
#line 8026
  rx = sqrt((nx * nx + ny * ny) + nz * nz);
#line 8027
  if (rx < 1.e-6) {
#line 8028
    aaerror((char *)" bad torsion radius in tg_apply \n");
#line 8028
    return;
  }
#line 8029
  nx /= rx;
#line 8030
  ny /= rx;
#line 8031
  nz /= rx;
#line 8032
  phi = ((2. * 3.141592653589793) / (double )tgp->ntry) * (double )num;
#line 8033
  cphi = cos(phi);
#line 8033
  sphi = sin(phi);
#line 8034
  i = 0;
#line 8034
  while (i < tgp->ingroup) {
#line 8036
    rx = (tgp->group[i])->dx - b1->dx;
#line 8037
    ry = (tgp->group[i])->dy - b1->dy;
#line 8038
    rz = (tgp->group[i])->dz - b1->dz;
#line 8039
    phi = (nx * rx + ny * ry) + nz * rz;
#line 8040
    nnrx = phi * nx;
#line 8041
    nnry = phi * ny;
#line 8042
    nnrz = phi * nz;
#line 8043
    rnx = ny * rz - nz * ry;
#line 8044
    rny = - nx * rz + nz * rx;
#line 8045
    rnz = nx * ry - ny * rx;
#line 8046
    phi = 1. - cphi;
#line 8047
    rx = (cphi * rx + phi * nnrx) + sphi * rnx;
#line 8048
    ry = (cphi * ry + phi * nnry) + sphi * rny;
#line 8049
    rz = (cphi * rz + phi * nnrz) + sphi * rnz;
#line 8050
    (tgp->group[i])->dx = rx + b1->dx;
#line 8051
    (tgp->group[i])->dy = ry + b1->dy;
#line 8052
    (tgp->group[i])->dz = rz + b1->dz;
#line 8034
    i ++;
  }
#line 8054
  return;
}
}
#line 8055 "188.c"
void tg_d_apply(TGROUP *tgp , double off ) 
{ double nx ;
  double ny ;
  double nz ;
  double phi ;
  double cphi ;
  double sphi ;
  double rx ;
  double ry ;
  double rz ;
  double nnrx ;
  double nnry ;
  double nnrz ;
  double rnx ;
  double rny ;
  double rnz ;
  ATOM *b1 ;
  ATOM *b2 ;
  int i ;

  {
#line 8064
  b1 = tgp->b1;
#line 8065
  b2 = tgp->b2;
#line 8066
  nx = b2->dx - b1->dx;
#line 8067
  ny = b2->dy - b1->dy;
#line 8068
  nz = b2->dz - b1->dz;
#line 8069
  rx = sqrt((nx * nx + ny * ny) + nz * nz);
#line 8070
  if (rx < 1.e-6) {
#line 8071
    aaerror((char *)" bad torsion radius in tg_apply \n");
#line 8071
    return;
  }
#line 8072
  nx /= rx;
#line 8073
  ny /= rx;
#line 8074
  nz /= rx;
#line 8075
  phi = off;
#line 8076
  cphi = cos(phi);
#line 8076
  sphi = sin(phi);
#line 8077
  i = 0;
#line 8077
  while (i < tgp->ingroup) {
#line 8079
    rx = (tgp->group[i])->dx - b1->dx;
#line 8080
    ry = (tgp->group[i])->dy - b1->dy;
#line 8081
    rz = (tgp->group[i])->dz - b1->dz;
#line 8082
    phi = (nx * rx + ny * ry) + nz * rz;
#line 8083
    nnrx = phi * nx;
#line 8084
    nnry = phi * ny;
#line 8085
    nnrz = phi * nz;
#line 8086
    rnx = ny * rz - nz * ry;
#line 8087
    rny = - nx * rz + nz * rx;
#line 8088
    rnz = nx * ry - ny * rx;
#line 8089
    phi = 1. - cphi;
#line 8090
    rx = (cphi * rx + phi * nnrx) + sphi * rnx;
#line 8091
    ry = (cphi * ry + phi * nnry) + sphi * rny;
#line 8092
    rz = (cphi * rz + phi * nnrz) + sphi * rnz;
#line 8093
    (tgp->group[i])->dx = rx + b1->dx;
#line 8094
    (tgp->group[i])->dy = ry + b1->dy;
#line 8095
    (tgp->group[i])->dz = rz + b1->dz;
#line 8077
    i ++;
  }
#line 8097
  return;
}
}
#line 8098 "188.c"
void dump_tgroup(FILE *where ) 
{ TGROUP *tgp ;

  {
#line 8101
  tgp = tg_first;
#line 8102
  while ((unsigned int )tgp != (unsigned int )((void *)0)) {
#line 8104
    fprintf(where, " tgroup %d %d %d %d %d %f %d ;\n", tgp->which, (tgp->context)->serial,
            (tgp->b1)->serial, (tgp->b2)->serial, (tgp->b3)->serial, (tgp->base * 180.) / 3.141592653589793,
            tgp->ntry);
#line 8110
    tgp = (TGROUP *)tgp->next;
  }
#line 8112
  return;
}
}
#line 8113 "188.c"
TGROUP *match_tgroup(int i ) 
{ TGROUP *tgp ;

  {
#line 8117
  tgp = tg_first;
#line 8118
  while ((unsigned int )tgp != (unsigned int )((void *)0)) {
#line 8120
    if (tgp->which == i) {
#line 8122
      if ((unsigned int )tgp->context == (unsigned int )((void *)0)) {
#line 8122
        return ((TGROUP *)((void *)0));
      }
#line 8123
      if ((unsigned int )tgp->b1 == (unsigned int )((void *)0)) {
#line 8123
        return ((TGROUP *)((void *)0));
      }
#line 8124
      if ((unsigned int )tgp->b2 == (unsigned int )((void *)0)) {
#line 8124
        return ((TGROUP *)((void *)0));
      }
#line 8125
      if ((unsigned int )tgp->b3 == (unsigned int )((void *)0)) {
#line 8125
        return ((TGROUP *)((void *)0));
      }
#line 8126
      return (tgp);
    }
#line 8128
    tgp = (TGROUP *)tgp->next;
  }
#line 8130
  return ((TGROUP *)((void *)0));
}
}
#line 8132 "188.c"
int tg_nonbon(double *V , TGROUP *tgp ) 
{ double r ;
  double r0 ;
  double xt ;
  double yt ;
  double zt ;
  double lcutoff ;
  double cutoff ;
  int i ;
  int ii ;
  ATOM *a1 ;
  ATOM *a2 ;
  double dielectric ;
  double ve ;
  double va ;
  double vh ;

  {
#line 8143
  dielectric = get_f_variable("dielec");
#line 8144
  if (dielectric < 1.) {
#line 8144
    dielectric = 1.;
  }
#line 8145
  dielectric = 332.17752 / dielectric;
#line 8146
  cutoff = get_f_variable("cutoff");
#line 8147
  if (cutoff < 1.) {
#line 8147
    cutoff = 1.e10;
  }
#line 8148
  lcutoff = - cutoff;
#line 8149
  *V = 0.;
#line 8150
  if ((unsigned int )tgp == (unsigned int )((void *)0)) {
#line 8150
    return (1);
  }
#line 8151
  ii = 0;
#line 8151
  while (ii <= tgp->ingroup) {
#line 8153
    a1 = tgp->group[ii];
#line 8154
    if ((unsigned int )a1 == (unsigned int )((void *)0)) {
      goto NOTANATOM;
    }
#line 8155
    ve = 0.;
#line 8155
    va = 0.;
#line 8155
    vh = 0.;
#line 8156
    a2 = a_next(-1);
#line 8157
    while (1) {
#line 8157
      if ((unsigned int )a2 != (unsigned int )((void *)0)) {
#line 8157
        if ((unsigned int )a2->next != (unsigned int )((void *)0)) {
#line 8157
          if (! ((unsigned int )a2->next != (unsigned int )a2)) {
#line 8157
            break;
          }
        } else {
#line 8157
          break;
        }
      } else {
#line 8157
        break;
      }
#line 8159
      if ((unsigned int )a2 == (unsigned int )a1) {
        goto SKIP;
      }
#line 8160
      i = 0;
#line 8160
      while (i < a1->dontuse) {
#line 8161
        if ((unsigned int )a2 == (unsigned int )a1->excluded[i]) {
          goto SKIP;
        }
#line 8160
        i ++;
      }
#line 8162
      xt = a1->dx - a2->dx;
#line 8163
      if (xt > cutoff) {
        goto SKIP;
      } else {
#line 8163
        if (xt < lcutoff) {
          goto SKIP;
        }
      }
#line 8164
      yt = a1->dy - a2->dy;
#line 8165
      if (yt > cutoff) {
        goto SKIP;
      } else {
#line 8165
        if (yt < lcutoff) {
          goto SKIP;
        }
      }
#line 8166
      zt = a1->dz - a2->dz;
#line 8167
      if (zt > cutoff) {
        goto SKIP;
      } else {
#line 8167
        if (zt < lcutoff) {
          goto SKIP;
        }
      }
#line 8168
      r = (xt * xt + yt * yt) + zt * zt;
#line 8169
      if (r < 1.) {
#line 8169
        r = 1.;
      }
#line 8170
      r0 = sqrt(r);
#line 8170
      r = (r * r) * r;
#line 8171
      ve += ((dielectric * a1->q) * a2->q) / r0;
#line 8172
      va -= (a1->a * a2->a) / r;
#line 8173
      vh += ((a1->b * a2->b) / r) / r;
      SKIP: 
#line 8175
      if ((unsigned int )a2->next == (unsigned int )a2) {
#line 8175
        break;
      }
#line 8176
      a2 = (ATOM *)a2->next;
    }
#line 8178
    *V += (ve + va) + vh;
    NOTANATOM: 
#line 8180
    i = i;
#line 8151
    ii ++;
  }
#line 8182
  return (1);
}
}
#line 8198 "188.c"
TORSION *torsion_first  =    (TORSION *)((void *)0);
#line 8199 "188.c"
TORSION *torsion_last  =    (TORSION *)((void *)0);
#line 8200 "188.c"
int torsion(int p1 , int p2 , int p3 , int p4 , double fk , int n , double off ) 
{ TORSION *new ;
  ATOM *ap1 ;
  ATOM *ap2 ;
  ATOM *ap3 ;
  ATOM *ap4 ;
  char line[80] ;
  void *tmp ;

  {
#line 8207
  if (p1 == p2) {
#line 8210
    sprintf(line, " same atom in torsion %d %d %d %d \000", p1, p2, p3, p4);
#line 8211
    aaerror(line);
#line 8212
    return (1);
  } else {
#line 8207
    if (p1 == p3) {
#line 8210
      sprintf(line, " same atom in torsion %d %d %d %d \000", p1, p2, p3, p4);
#line 8211
      aaerror(line);
#line 8212
      return (1);
    } else {
#line 8207
      if (p1 == p4) {
#line 8210
        sprintf(line, " same atom in torsion %d %d %d %d \000", p1, p2, p3, p4);
#line 8211
        aaerror(line);
#line 8212
        return (1);
      } else {
#line 8207
        if (p2 == p3) {
#line 8210
          sprintf(line, " same atom in torsion %d %d %d %d \000", p1, p2, p3, p4);
#line 8211
          aaerror(line);
#line 8212
          return (1);
        } else {
#line 8207
          if (p2 == p4) {
#line 8210
            sprintf(line, " same atom in torsion %d %d %d %d \000", p1, p2, p3, p4);
#line 8211
            aaerror(line);
#line 8212
            return (1);
          } else {
#line 8207
            if (p3 == p4) {
#line 8210
              sprintf(line, " same atom in torsion %d %d %d %d \000", p1, p2, p3,
                      p4);
#line 8211
              aaerror(line);
#line 8212
              return (1);
            }
          }
        }
      }
    }
  }
#line 8214
  if (fk == 0.) {
#line 8214
    return (1);
  }
#line 8215
  ap1 = a_m_serial(p1);
#line 8216
  ap2 = a_m_serial(p2);
#line 8217
  ap3 = a_m_serial(p3);
#line 8218
  ap4 = a_m_serial(p4);
#line 8219
  if ((unsigned int )ap1 == (unsigned int )((void *)0)) {
#line 8221
    sprintf(line, "undefined atom in torsion %d %d %d %d \000", p1, p2, p3, p4);
#line 8222
    aaerror(line);
#line 8223
    return (0);
  } else {
#line 8219
    if ((unsigned int )ap2 == (unsigned int )((void *)0)) {
#line 8221
      sprintf(line, "undefined atom in torsion %d %d %d %d \000", p1, p2, p3, p4);
#line 8222
      aaerror(line);
#line 8223
      return (0);
    } else {
#line 8219
      if ((unsigned int )ap3 == (unsigned int )((void *)0)) {
#line 8221
        sprintf(line, "undefined atom in torsion %d %d %d %d \000", p1, p2, p3, p4);
#line 8222
        aaerror(line);
#line 8223
        return (0);
      } else {
#line 8219
        if ((unsigned int )ap4 == (unsigned int )((void *)0)) {
#line 8221
          sprintf(line, "undefined atom in torsion %d %d %d %d \000", p1, p2, p3,
                  p4);
#line 8222
          aaerror(line);
#line 8223
          return (0);
        }
      }
    }
  }
#line 8225
  tmp = malloc(sizeof(TORSION ));
#line 8225
  new = (TORSION *)tmp;
#line 8225
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 8227
    return (0);
  }
#line 8230
  if ((unsigned int )torsion_first == (unsigned int )((void *)0)) {
#line 8230
    torsion_first = new;
  }
#line 8231
  if ((unsigned int )torsion_last == (unsigned int )((void *)0)) {
#line 8231
    torsion_last = new;
  }
#line 8232
  new->atom1 = ap1;
#line 8233
  new->atom2 = ap2;
#line 8234
  new->atom3 = ap3;
#line 8235
  new->atom4 = ap4;
#line 8236
  new->offset = off;
#line 8237
  new->k = fk;
#line 8238
  new->n = n;
#line 8239
  new->next = (void *)new;
#line 8240
  torsion_last->next = (void *)new;
#line 8241
  torsion_last = new;
#line 8242
  return (1);
}
}
#line 8244 "188.c"
int v_torsion(double *V , double lambda ) 
{ TORSION *bp ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double x3 ;
  double y3 ;
  double z3 ;
  double r ;
  double cx1 ;
  double cy1 ;
  double cz1 ;
  double cx2 ;
  double cy2 ;
  double cz2 ;
  double dp ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 8252
  bp = torsion_first;
#line 8253
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 8253
    return (1);
  }
#line 8254
  while (1) {
#line 8256
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 8256
      return (0);
    }
#line 8257
    a1 = bp->atom1;
#line 8257
    a2 = bp->atom2;
#line 8257
    a3 = bp->atom3;
#line 8258
    a4 = bp->atom4;
#line 8259
    if (a1->active) {
      goto _L;
    } else {
#line 8259
      if (a2->active) {
        goto _L;
      } else {
#line 8259
        if (a3->active) {
          goto _L;
        } else {
#line 8259
          if (a4->active) {
            _L: /* CIL Label */ 
#line 8260
            x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 8261
            y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 8262
            z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 8263
            x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 8264
            y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 8265
            z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 8266
            x3 = (a4->x - a3->x) + lambda * (a4->dx - a3->dx);
#line 8267
            y3 = (a4->y - a3->y) + lambda * (a4->dy - a3->dy);
#line 8268
            z3 = (a4->z - a3->z) + lambda * (a4->dz - a3->dz);
#line 8269
            cx1 = y1___0 * z2 - y2 * z1;
#line 8270
            cy1 = - x1 * z2 + x2 * z1;
#line 8271
            cz1 = x1 * y2 - x2 * y1___0;
#line 8272
            r = (cx1 * cx1 + cy1 * cy1) + cz1 * cz1;
#line 8273
            if (r < 1.e-8) {
              goto SKIP;
            }
#line 8274
            tmp = sqrt(r);
#line 8274
            r = 1. / tmp;
#line 8275
            cx1 *= r;
#line 8276
            cy1 *= r;
#line 8277
            cz1 *= r;
#line 8278
            cx2 = y3 * z2 - y2 * z3;
#line 8279
            cy2 = - x3 * z2 + x2 * z3;
#line 8280
            cz2 = x3 * y2 - x2 * y3;
#line 8281
            r = (cx2 * cx2 + cy2 * cy2) + cz2 * cz2;
#line 8282
            if (r < 1.e-8) {
              goto SKIP;
            }
#line 8283
            tmp___0 = sqrt(r);
#line 8283
            r = 1. / tmp___0;
#line 8284
            cx2 *= r;
#line 8285
            cy2 *= r;
#line 8286
            cz2 *= r;
#line 8287
            dp = (cx1 * cx2 + cy1 * cy2) + cz1 * cz2;
#line 8288
            if (dp > 1.) {
#line 8288
              dp = 1.;
            }
#line 8288
            if (dp < - 1.) {
#line 8288
              dp = - 1.;
            }
#line 8289
            dp = acos(dp);
#line 8290
            r = (cx1 * x3 + cy1 * y3) + cz1 * z3;
#line 8291
            if (r > (double )0) {
#line 8291
              dp = - dp;
            }
#line 8292
            tmp___1 = cos((double )bp->n * dp - bp->offset);
#line 8292
            *V += (.5 * bp->k) * (1. + tmp___1);
          }
        }
      }
    }
    SKIP: 
#line 8295
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 8295
      return (1);
    }
#line 8296
    bp = (TORSION *)bp->next;
  }
}
}
#line 8299 "188.c"
int f_torsion(double lambda ) 
{ TORSION *bp ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double x3 ;
  double y3 ;
  double z3 ;
  double r ;
  double cx1 ;
  double cy1 ;
  double cz1 ;
  double cx2 ;
  double cy2 ;
  double cz2 ;
  double dp ;
  double sdp ;
  double r1 ;
  double r2 ;
  double r3 ;
  double c1 ;
  double c2 ;
  double s1 ;
  double s2 ;
  double ux ;
  double uy ;
  double uz ;
  int i ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
#line 8310
  bp = torsion_first;
#line 8311
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 8311
    return (1);
  }
#line 8312
  i = 0;
#line 8313
  while (1) {
#line 8315
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 8315
      return (0);
    }
#line 8316
    a1 = bp->atom1;
#line 8316
    a2 = bp->atom2;
#line 8316
    a3 = bp->atom3;
#line 8317
    a4 = bp->atom4;
#line 8318
    if (a1->active) {
      goto _L;
    } else {
#line 8318
      if (a2->active) {
        goto _L;
      } else {
#line 8318
        if (a3->active) {
          goto _L;
        } else {
#line 8318
          if (a4->active) {
            _L: /* CIL Label */ 
#line 8319
            x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 8320
            y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 8321
            z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 8322
            x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 8323
            y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 8324
            z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 8325
            x3 = (a4->x - a3->x) + lambda * (a4->dx - a3->dx);
#line 8326
            y3 = (a4->y - a3->y) + lambda * (a4->dy - a3->dy);
#line 8327
            z3 = (a4->z - a3->z) + lambda * (a4->dz - a3->dz);
#line 8328
            r1 = sqrt((x1 * x1 + y1___0 * y1___0) + z1 * z1);
#line 8329
            r2 = sqrt((x2 * x2 + y2 * y2) + z2 * z2);
#line 8330
            r3 = sqrt((x3 * x3 + y3 * y3) + z3 * z3);
#line 8331
            c1 = (((x1 * x2 + y1___0 * y2) + z1 * z2) / r1) / r2;
#line 8332
            c2 = (- ((x2 * x3 + y2 * y3) + z2 * z3) / r2) / r3;
#line 8334
            s1 = 1. - c1 * c1;
#line 8334
            s2 = 1. - c2 * c2;
#line 8335
            if (s1 < 1.e-8) {
              goto SKIP;
            }
#line 8336
            if (s2 < 1.e-8) {
              goto SKIP;
            }
#line 8337
            cx1 = y1___0 * z2 - y2 * z1;
#line 8338
            cy1 = - x1 * z2 + x2 * z1;
#line 8339
            cz1 = x1 * y2 - x2 * y1___0;
#line 8340
            r = (cx1 * cx1 + cy1 * cy1) + cz1 * cz1;
#line 8341
            if (r < 1.e-8) {
              goto SKIP;
            }
#line 8342
            tmp = sqrt(r);
#line 8342
            r = 1. / tmp;
#line 8343
            cx1 *= r;
#line 8344
            cy1 *= r;
#line 8345
            cz1 *= r;
#line 8346
            cx2 = y3 * z2 - y2 * z3;
#line 8347
            cy2 = - x3 * z2 + x2 * z3;
#line 8348
            cz2 = x3 * y2 - x2 * y3;
#line 8349
            r = (cx2 * cx2 + cy2 * cy2) + cz2 * cz2;
#line 8350
            if (r < 1.e-8) {
              goto SKIP;
            }
#line 8351
            tmp___0 = sqrt(r);
#line 8351
            r = 1. / tmp___0;
#line 8352
            cx2 *= r;
#line 8353
            cy2 *= r;
#line 8354
            cz2 *= r;
#line 8355
            dp = (cx1 * cx2 + cy1 * cy2) + cz1 * cz2;
#line 8356
            if (dp > 1.) {
#line 8356
              dp = 1.;
            }
#line 8356
            if (dp < - 1.) {
#line 8356
              dp = - 1.;
            }
#line 8357
            dp = acos(dp);
#line 8358
            tmp___1 = sqrt((x3 * x3 + y3 * y3) + z3 * z3);
#line 8358
            tmp___2 = sqrt((x2 * x2 + y2 * y2) + z2 * z2);
#line 8358
            r = tmp___1 * tmp___2;
#line 8360
            sdp = (x3 * x2 + y3 * y2) + z3 * z2;
#line 8361
            sdp /= r;
#line 8362
            ux = x3 - sdp * x2;
#line 8363
            uy = y3 - sdp * y2;
#line 8364
            uz = z3 - sdp * z2;
#line 8365
            r = (cx1 * ux + cy1 * uy) + cz1 * uz;
#line 8366
            if (r >= (double )0) {
#line 8366
              dp = - dp;
            }
#line 8367
            tmp___3 = sin((double )bp->n * dp - bp->offset);
#line 8367
            r = ((- .5 * bp->k) * (double )bp->n) * tmp___3;
#line 8369
            s1 = 1. / s1;
#line 8370
            s2 = 1. / s2;
#line 8371
            if (a1->active) {
#line 8372
              a1->fx -= ((r * cx1) / r1) * s1;
#line 8373
              a1->fy -= ((r * cy1) / r1) * s1;
#line 8374
              a1->fz -= ((r * cz1) / r1) * s1;
            }
#line 8376
            if (a2->active) {
#line 8377
              a2->fx += ((((r * cx1) * (r2 - c1 * r1)) / r2) / r1) * s1;
#line 8378
              a2->fy += ((((r * cy1) * (r2 - c1 * r1)) / r2) / r1) * s1;
#line 8379
              a2->fz += ((((r * cz1) * (r2 - c1 * r1)) / r2) / r1) * s1;
#line 8380
              a2->fx -= (((r * cx2) * c2) / r2) * s2;
#line 8381
              a2->fy -= (((r * cy2) * c2) / r2) * s2;
#line 8382
              a2->fz -= (((r * cz2) * c2) / r2) * s2;
            }
#line 8384
            if (a3->active) {
#line 8385
              a3->fx -= ((((r * cx2) * (r2 - c2 * r3)) / r2) / r3) * s2;
#line 8386
              a3->fy -= ((((r * cy2) * (r2 - c2 * r3)) / r2) / r3) * s2;
#line 8387
              a3->fz -= ((((r * cz2) * (r2 - c2 * r3)) / r2) / r3) * s2;
#line 8388
              a3->fx += (((r * cx1) * c1) / r2) * s1;
#line 8389
              a3->fy += (((r * cy1) * c1) / r2) * s1;
#line 8390
              a3->fz += (((r * cz1) * c1) / r2) * s1;
            }
#line 8392
            if (a4->active) {
#line 8393
              a4->fx += ((r * cx2) / r3) * s2;
#line 8394
              a4->fy += ((r * cy2) / r3) * s2;
#line 8395
              a4->fz += ((r * cz2) / r3) * s2;
            }
          }
        }
      }
    }
    SKIP: 
#line 8399
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 8399
      return (1);
    }
#line 8400
    bp = (TORSION *)bp->next;
  }
}
}
#line 8403 "188.c"
void get_torsion(ATOM *a1 , ATOM **bonded , int mbond , int *inbond ) 
{ TORSION *mine ;
  int tmp ;
  int tmp___0 ;

  {
#line 8408
  mine = torsion_first;
#line 8409
  *inbond = 0;
#line 8410
  while (1) {
#line 8412
    if ((unsigned int )mine == (unsigned int )((void *)0)) {
#line 8414
      return;
    }
#line 8416
    if ((unsigned int )mine->atom1 == (unsigned int )a1) {
#line 8418
      tmp = *inbond;
#line 8418
      (*inbond) ++;
#line 8418
      *(bonded + tmp) = mine->atom4;
    }
#line 8420
    if ((unsigned int )mine->atom4 == (unsigned int )a1) {
#line 8422
      tmp___0 = *inbond;
#line 8422
      (*inbond) ++;
#line 8422
      *(bonded + tmp___0) = mine->atom1;
    }
#line 8424
    if ((unsigned int )mine == (unsigned int )mine->next) {
#line 8424
      return;
    }
#line 8425
    mine = (TORSION *)mine->next;
#line 8426
    if (*inbond == mbond) {
#line 8426
      return;
    }
  }
}
}
#line 8429 "188.c"
void dump_torsions(FILE *where ) 
{ TORSION *b ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;
  double rtodeg ;
  double tmp ;

  {
#line 8434
  b = torsion_first;
#line 8435
  if ((unsigned int )b == (unsigned int )((void *)0)) {
#line 8435
    return;
  }
#line 8436
  tmp = acos(- 1.);
#line 8436
  rtodeg = 180. / tmp;
#line 8437
  while ((unsigned int )b->next != (unsigned int )b) {
#line 8439
    if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 8439
      return;
    }
#line 8440
    a1 = b->atom1;
#line 8440
    a2 = b->atom2;
#line 8440
    a3 = b->atom3;
#line 8440
    a4 = b->atom4;
#line 8441
    fprintf(where, "torsion %d %d %d %d %f %d %f ;\n", a1->serial, a2->serial, a3->serial,
            a4->serial, b->k, b->n, b->offset * rtodeg);
#line 8444
    b = (TORSION *)b->next;
  }
#line 8446
  if ((unsigned int )b->next == (unsigned int )((void *)0)) {
#line 8446
    return;
  }
#line 8447
  a1 = b->atom1;
#line 8447
  a2 = b->atom2;
#line 8447
  a3 = b->atom3;
#line 8447
  a4 = b->atom4;
#line 8448
  fprintf(where, "torsion %d %d %d %d %f %d %f ;\n", a1->serial, a2->serial, a3->serial,
          a4->serial, b->k, b->n, b->offset * rtodeg);
#line 8451
  return;
}
}
#line 8452 "188.c"
int a_torsion(double *V , double lambda , int ilow , int ihigh , FILE *op ) 
{ TORSION *bp ;
  double x1 ;
  double y1___0 ;
  double z1 ;
  double x2 ;
  double y2 ;
  double z2 ;
  double x3 ;
  double y3 ;
  double z3 ;
  double r ;
  double cx1 ;
  double cy1 ;
  double cz1 ;
  double cx2 ;
  double cy2 ;
  double cz2 ;
  double dp ;
  ATOM *a1 ;
  ATOM *a2 ;
  ATOM *a3 ;
  ATOM *a4 ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 8462
  bp = torsion_first;
#line 8463
  if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 8463
    return (1);
  }
#line 8464
  while (1) {
#line 8466
    if ((unsigned int )bp == (unsigned int )((void *)0)) {
#line 8466
      return (0);
    }
#line 8467
    a1 = bp->atom1;
#line 8467
    a2 = bp->atom2;
#line 8467
    a3 = bp->atom3;
#line 8468
    a4 = bp->atom4;
#line 8469
    if (a1->serial >= ilow) {
#line 8469
      if (a1->serial <= ihigh) {
        goto _L;
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 8469
      if (a2->serial >= ilow) {
#line 8469
        if (a2->serial <= ihigh) {
          goto _L;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 8469
        if (a3->serial >= ilow) {
#line 8469
          if (a3->serial <= ihigh) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 8469
          if (a4->serial >= ilow) {
#line 8469
            if (a4->serial <= ihigh) {
              _L: /* CIL Label */ 
#line 8474
              x1 = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 8475
              y1___0 = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 8476
              z1 = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 8477
              x2 = (a3->x - a2->x) + lambda * (a3->dx - a2->dx);
#line 8478
              y2 = (a3->y - a2->y) + lambda * (a3->dy - a2->dy);
#line 8479
              z2 = (a3->z - a2->z) + lambda * (a3->dz - a2->dz);
#line 8480
              x3 = (a4->x - a3->x) + lambda * (a4->dx - a3->dx);
#line 8481
              y3 = (a4->y - a3->y) + lambda * (a4->dy - a3->dy);
#line 8482
              z3 = (a4->z - a3->z) + lambda * (a4->dz - a3->dz);
#line 8483
              cx1 = y1___0 * z2 - y2 * z1;
#line 8484
              cy1 = - x1 * z2 + x2 * z1;
#line 8485
              cz1 = x1 * y2 - x2 * y1___0;
#line 8486
              r = (cx1 * cx1 + cy1 * cy1) + cz1 * cz1;
#line 8487
              if (r < 1.e-8) {
                goto SKIP;
              }
#line 8488
              r = sqrt(r);
#line 8489
              cx1 /= r;
#line 8490
              cy1 /= r;
#line 8491
              cz1 /= r;
#line 8492
              cx2 = y3 * z2 - y2 * z3;
#line 8493
              cy2 = - x3 * z2 + x2 * z3;
#line 8494
              cz2 = x3 * y2 - x2 * y3;
#line 8495
              r = (cx2 * cx2 + cy2 * cy2) + cz2 * cz2;
#line 8496
              if (r < 1.e-8) {
                goto SKIP;
              }
#line 8497
              r = sqrt(r);
#line 8498
              cx2 /= r;
#line 8499
              cy2 /= r;
#line 8500
              cz2 /= r;
#line 8501
              dp = (cx1 * cx2 + cy1 * cy2) + cz1 * cz2;
#line 8502
              if (dp > 1.) {
#line 8502
                dp = 1.;
              }
#line 8502
              if (dp < - 1.) {
#line 8502
                dp = - 1.;
              }
#line 8503
              dp = acos(dp);
#line 8504
              r = (cx1 * x3 + cy1 * y3) + cz1 * z3;
#line 8505
              if (r > (double )0) {
#line 8505
                dp = - dp;
              }
#line 8506
              tmp = cos((double )bp->n * dp - bp->offset);
#line 8506
              z2 = (.5 * bp->k) * (1. + tmp);
#line 8507
              *V += z2;
#line 8508
              tmp___0 = cos((double )bp->n * dp - bp->offset);
#line 8508
              tmp___1 = acos(- tmp___0);
#line 8508
              fprintf(op, "Torsion %s %d %s %d %s %d %s %d E %f Angle %f error %f\n",
                      a1->name, a1->serial, a2->name, a2->serial, a3->name, a3->serial,
                      a4->name, a4->serial, z2, (dp * 180.) / 3.14159265, (tmp___1 * 180.) / 3.14159265);
            }
          }
        }
      }
    }
    SKIP: 
#line 8514
    if ((unsigned int )bp == (unsigned int )bp->next) {
#line 8514
      return (1);
    }
#line 8515
    bp = (TORSION *)bp->next;
  }
}
}
#line 8518 "188.c"
int gsdg_torsion(ATOM *ap___1 ) 
{ TORSION *tp ;
  double b1 ;
  double b2 ;
  double b3 ;

  {
#line 8524
  tp = torsion_first;
#line 8525
  while (1) {
#line 8527
    if ((unsigned int )tp == (unsigned int )((void *)0)) {
#line 8527
      return (0);
    }
#line 8528
    if ((unsigned int )tp->atom1 == (unsigned int )ap___1) {
#line 8530
      b1 = bond_length(ap___1, tp->atom2);
#line 8531
      b2 = bond_length(tp->atom2, tp->atom3);
#line 8532
      b3 = bond_length(tp->atom3, tp->atom4);
#line 8533
      ap___1->vx = b2 + .75 * (b1 + b3);
#line 8534
      ap___1->vx *= ap___1->vx;
#line 8535
      ap___1->vy = 10.;
    }
#line 8537
    if ((unsigned int )tp->atom4 == (unsigned int )ap___1) {
#line 8539
      b1 = bond_length(ap___1, tp->atom3);
#line 8540
      b2 = bond_length(tp->atom2, tp->atom3);
#line 8541
      b3 = bond_length(tp->atom2, tp->atom1);
#line 8542
      ap___1->vx = b2 + .75 * (b1 + b3);
#line 8543
      ap___1->vx *= ap___1->vx;
#line 8544
      ap___1->vy = 10.;
    }
#line 8546
    if ((unsigned int )tp == (unsigned int )tp->next) {
#line 8546
      return (0);
    }
#line 8547
    tp = (TORSION *)tp->next;
  }
}
}
#line 8555
int set_torsion(ATOM *ap1 , ATOM *ap2 , ATOM *ap3 , ATOM *ap4 , double howmuch ) ;
#line 8556
int tset_bond_build(ATOM *ap1 , ATOM *ap2 , ATOM *ap3 , ATOM *ap4 ) ;
#line 8568
double get_torsion_value(ATOM *a1 , ATOM *a2 , ATOM *a3 , ATOM *a4 ) ;
#line 8560 "188.c"
int tset(FILE *op , int echo___0 , int i1 , int i2 , int i3 , int i4 , double alpha ) 
{ ATOM *ap1 ;
  ATOM *ap2 ;
  ATOM *ap3 ;
  ATOM *ap4 ;
  double original ;
  double delta ;
  int numatom ;
  double tmp ;
  double tmp___0 ;

  {
#line 8571
  numatom = a_number();
#line 8572
  if (numatom <= 0) {
#line 8572
    return (1);
  }
#line 8573
  ap1 = a_m_serial(i1);
#line 8574
  if ((unsigned int )ap1 == (unsigned int )((void *)0)) {
#line 8575
    aaerror((char *)"An atom in tset is not defined");
#line 8576
    return (1);
  }
#line 8577
  ap2 = a_m_serial(i2);
#line 8578
  if ((unsigned int )ap2 == (unsigned int )((void *)0)) {
#line 8579
    aaerror((char *)"An atom in tset is not defined");
#line 8580
    return (1);
  }
#line 8581
  ap3 = a_m_serial(i3);
#line 8582
  if ((unsigned int )ap3 == (unsigned int )((void *)0)) {
#line 8583
    aaerror((char *)"An atom in tset is not defined");
#line 8584
    return (1);
  }
#line 8585
  ap4 = a_m_serial(i4);
#line 8586
  if ((unsigned int )ap4 == (unsigned int )((void *)0)) {
#line 8587
    aaerror((char *)"An atom in tset is not defined");
#line 8588
    return (1);
  }
#line 8589
  original = get_torsion_value(ap1, ap2, ap3, ap4);
#line 8590
  tmp = fabs(original - alpha);
#line 8590
  if (tmp < 1.e-3) {
#line 8590
    return (1);
  }
#line 8591
  tset_bond_build(ap1, ap2, ap3, ap4);
#line 8592
  delta = alpha - original;
#line 8593
  set_torsion(ap1, ap2, ap3, ap4, delta);
#line 8594
  if (echo___0) {
#line 8595
    tmp___0 = get_torsion_value(ap1, ap2, ap3, ap4);
#line 8595
    fprintf(op, "tset> original  %f delta %f final %f\n", (original * (double )180) / 3.14159,
            (delta * (double )180) / 3.14159, (tmp___0 * (double )180) / 3.14159);
  }
#line 8597
  return (0);
}
}
#line 8602 "188.c"
int tmin(FILE *op , int echo___0 , int i1 , int i2 , int i3 , int i4 , int nstep ,
         int (**vfs)() , int nfs ) 
{ ATOM *ap1 ;
  ATOM *ap2 ;
  ATOM *ap3 ;
  ATOM *ap4 ;
  double original ;
  double delta ;
  double vtemp ;
  double vmax ;
  int numatom ;
  int i ;
  int imax ;
  int ifs ;
  double tmp ;

  {
#line 8615
  numatom = a_number();
#line 8616
  if (numatom <= 0) {
#line 8616
    return (1);
  }
#line 8617
  ap1 = a_m_serial(i1);
#line 8618
  if ((unsigned int )ap1 == (unsigned int )((void *)0)) {
#line 8619
    aaerror((char *)"An atom in tset is not defined");
#line 8620
    return (1);
  }
#line 8621
  ap2 = a_m_serial(i2);
#line 8622
  if ((unsigned int )ap2 == (unsigned int )((void *)0)) {
#line 8623
    aaerror((char *)"An atom in tset is not defined");
#line 8624
    return (1);
  }
#line 8625
  ap3 = a_m_serial(i3);
#line 8626
  if ((unsigned int )ap3 == (unsigned int )((void *)0)) {
#line 8627
    aaerror((char *)"An atom in tset is not defined");
#line 8628
    return (1);
  }
#line 8629
  ap4 = a_m_serial(i4);
#line 8630
  if ((unsigned int )ap4 == (unsigned int )((void *)0)) {
#line 8631
    aaerror((char *)"An atom in tset is not defined");
#line 8632
    return (1);
  }
#line 8633
  if (nstep <= 0) {
#line 8633
    nstep = 12;
  }
#line 8634
  original = get_torsion_value(ap1, ap2, ap3, ap4);
#line 8635
  tset_bond_build(ap1, ap2, ap3, ap4);
#line 8636
  delta = - original;
#line 8637
  set_torsion(ap1, ap2, ap3, ap4, delta);
#line 8638
  imax = -1;
#line 8639
  vmax = 10e20;
#line 8640
  delta = ((double )2 * 3.141592653589793) / (double )nstep;
#line 8641
  i = 0;
#line 8641
  while (i < nstep) {
#line 8643
    vtemp = 0.;
#line 8644
    ifs = 0;
#line 8644
    while (ifs < nfs) {
#line 8645
    //  (*(*(vfs + ifs)))(& vtemp, 0.);
#line 8644
      ifs ++;
    }
#line 8646
    if (vtemp < vmax) {
#line 8647
      vmax = vtemp;
#line 8647
      imax = i;
    }
#line 8648
    set_torsion(ap1, ap2, ap3, ap4, delta);
#line 8641
    i ++;
  }
#line 8650
  set_torsion(ap1, ap2, ap3, ap4, (double )imax * delta);
#line 8651
  if (echo___0) {
#line 8652
    tmp = get_torsion_value(ap1, ap2, ap3, ap4);
#line 8652
    fprintf(op, "tset> original  %f  final %f\n", (original * (double )180) / 3.14159,
            (tmp * (double )180) / 3.14159);
  }
#line 8654
  return (0);
}
}
#line 8656 "188.c"
int tset_bond_build(ATOM *ap1 , ATOM *ap2 , ATOM *ap3 , ATOM *ap4 ) 
{ ATOM *ap___1 ;
  ATOM *bonded[20] ;
  int i ;
  int numatom ;
  int inbond ;
  int j ;
  int tobonded ;

  {
#line 8662
  numatom = a_number();
#line 8663
  i = 0;
#line 8663
  while (i < numatom) {
#line 8664
    ap___1 = a_next(i);
#line 8665
    ap___1->gx = - 1.;
#line 8663
    i ++;
  }
#line 8667
  tobonded = 0;
#line 8668
  get_bond(ap3, bonded, 20, & inbond);
#line 8669
  i = 0;
#line 8669
  while (i < inbond) {
#line 8671
    if ((unsigned int )bonded[i] != (unsigned int )ap1) {
#line 8671
      if ((unsigned int )bonded[i] != (unsigned int )ap2) {
#line 8672
        (bonded[i])->gx = 0.;
#line 8672
        tobonded ++;
      }
    }
#line 8669
    i ++;
  }
#line 8674
  get_bond(ap4, bonded, 20, & inbond);
#line 8675
  i = 0;
#line 8675
  while (i < inbond) {
#line 8677
    if ((unsigned int )bonded[i] != (unsigned int )ap1) {
#line 8677
      if ((unsigned int )bonded[i] != (unsigned int )ap2) {
#line 8678
        (bonded[i])->gx = 0.;
#line 8678
        tobonded ++;
      }
    }
#line 8675
    i ++;
  }
#line 8680
  ap3->gx = 1.;
#line 8681
  ap4->gx = 1.;
#line 8682
  while (tobonded > 0) {
#line 8684
    tobonded = 0;
#line 8685
    i = 0;
#line 8685
    while (i < numatom) {
#line 8687
      ap___1 = a_next(i);
#line 8688
      if ((unsigned int )ap___1 != (unsigned int )ap1) {
#line 8688
        if ((unsigned int )ap___1 != (unsigned int )ap2) {
#line 8689
          if (ap___1->gx == 0.) {
#line 8691
            ap___1->gx = 1.;
#line 8692
            get_bond(ap___1, bonded, 20, & inbond);
#line 8693
            j = 0;
#line 8693
            while (j < inbond) {
#line 8695
              if ((bonded[j])->gx < 1.) {
#line 8696
                (bonded[j])->gx = 0.;
#line 8696
                tobonded ++;
              }
#line 8693
              j ++;
            }
          }
        }
      }
#line 8685
      i ++;
    }
  }
#line 8702
  return (1);
}
}
#line 8704 "188.c"
double get_torsion_value(ATOM *a1 , ATOM *a2 , ATOM *a3 , ATOM *a4 ) 
{ double x1 ;
  double x2 ;
  double x3 ;
  double y1___0 ;
  double y2 ;
  double y3 ;
  double z1 ;
  double z2 ;
  double z3 ;
  double cx1 ;
  double cy1 ;
  double cz1 ;
  double cx2 ;
  double cy2 ;
  double cz2 ;
  double dp ;
  double r ;
  double tmp ;
  double tmp___0 ;

  {
#line 8711
  x1 = a1->x - a2->x;
#line 8712
  y1___0 = a1->y - a2->y;
#line 8713
  z1 = a1->z - a2->z;
#line 8714
  x2 = a3->x - a2->x;
#line 8715
  y2 = a3->y - a2->y;
#line 8716
  z2 = a3->z - a2->z;
#line 8717
  x3 = a4->x - a3->x;
#line 8718
  y3 = a4->y - a3->y;
#line 8719
  z3 = a4->z - a3->z;
#line 8720
  cx1 = y1___0 * z2 - y2 * z1;
#line 8721
  cy1 = - x1 * z2 + x2 * z1;
#line 8722
  cz1 = x1 * y2 - x2 * y1___0;
#line 8723
  r = (cx1 * cx1 + cy1 * cy1) + cz1 * cz1;
#line 8724
  if (r < 1.e-4) {
    goto SKIP;
  }
#line 8725
  tmp = sqrt(r);
#line 8725
  r = 1. / tmp;
#line 8726
  cx1 *= r;
#line 8727
  cy1 *= r;
#line 8728
  cz1 *= r;
#line 8729
  cx2 = y3 * z2 - y2 * z3;
#line 8730
  cy2 = - x3 * z2 + x2 * z3;
#line 8731
  cz2 = x3 * y2 - x2 * y3;
#line 8732
  r = (cx2 * cx2 + cy2 * cy2) + cz2 * cz2;
#line 8733
  if (r < 1.e-4) {
    goto SKIP;
  }
#line 8734
  tmp___0 = sqrt(r);
#line 8734
  r = 1. / tmp___0;
#line 8735
  cx2 *= r;
#line 8736
  cy2 *= r;
#line 8737
  cz2 *= r;
#line 8738
  dp = (cx1 * cx2 + cy1 * cy2) + cz1 * cz2;
#line 8739
  if (dp > 1.) {
#line 8739
    dp = 1.;
  }
#line 8739
  if (dp < - 1.) {
#line 8739
    dp = - 1.;
  }
#line 8740
  dp = acos(dp);
#line 8741
  r = (cx1 * x3 + cy1 * y3) + cz1 * z3;
#line 8742
  if (r > (double )0) {
#line 8742
    dp = - dp;
  }
#line 8743
  return (dp);
  SKIP: 
#line 8745
  return ((double )0);
}
}
#line 8747 "188.c"
int set_torsion(ATOM *ap1 , ATOM *ap2 , ATOM *ap3 , ATOM *ap4 , double howmuch ) 
{ double nx ;
  double ny ;
  double nz ;
  double phi ;
  double cphi ;
  double sphi ;
  double xphi ;
  double rx ;
  double ry ;
  double rz ;
  double nnrx ;
  double nnry ;
  double nnrz ;
  double rnx ;
  double rny ;
  double rnz ;
  ATOM *ap___1 ;
  ATOM *b1 ;
  ATOM *b2 ;
  int numatom ;
  int i ;

  {
#line 8755
  numatom = a_number();
#line 8756
  b1 = ap2;
#line 8756
  b2 = ap3;
#line 8757
  nx = b2->x - b1->x;
#line 8758
  ny = b2->y - b1->y;
#line 8759
  nz = b2->z - b1->z;
#line 8760
  rx = sqrt((nx * nx + ny * ny) + nz * nz);
#line 8761
  if (rx < 1.e-6) {
#line 8762
    aaerror((char *)" bad torsion radius in set_torsion \n");
#line 8762
    return (1);
  }
#line 8763
  nx /= rx;
#line 8764
  ny /= rx;
#line 8765
  nz /= rx;
#line 8766
  cphi = cos(howmuch);
#line 8766
  sphi = sin(howmuch);
#line 8767
  phi = 1. - cphi;
#line 8768
  i = 0;
#line 8768
  while (i < numatom) {
#line 8770
    ap___1 = a_next(i);
#line 8771
    if (ap___1->gx > 0.) {
#line 8771
      if ((unsigned int )ap___1 != (unsigned int )b2) {
#line 8773
        rx = ap___1->x - b1->x;
#line 8774
        ry = ap___1->y - b1->y;
#line 8775
        rz = ap___1->z - b1->z;
#line 8776
        xphi = (nx * rx + ny * ry) + nz * rz;
#line 8777
        nnrx = xphi * nx;
#line 8778
        nnry = xphi * ny;
#line 8779
        nnrz = xphi * nz;
#line 8780
        rnx = ny * rz - nz * ry;
#line 8781
        rny = - nx * rz + nz * rx;
#line 8782
        rnz = nx * ry - ny * rx;
#line 8783
        rx = (cphi * rx + phi * nnrx) + sphi * rnx;
#line 8784
        ry = (cphi * ry + phi * nnry) + sphi * rny;
#line 8785
        rz = (cphi * rz + phi * nnrz) + sphi * rnz;
#line 8786
        ap___1->x = rx + b1->x;
#line 8787
        ap___1->y = ry + b1->y;
#line 8788
        ap___1->z = rz + b1->z;
      }
    }
#line 8768
    i ++;
  }
#line 8791
  return (1);
}
}
#line 8797 "188.c"
int tmap(FILE *op , int echo___0 , int (**vfs)() , int nfs , int i1 , int i2 , int i3 ,
         int i4 , int j1___0 , int j2 , int j3 , int j4 , int nistep , int njstep ) 
{ ATOM *ap___1 ;
  int numatm ;
  int i ;
  int j ;
  int ifs ;
  double V ;
  double x ;
  double dx ;
  double y ;
  double dy ;

  {
#line 8811
  numatm = a_number();
#line 8812
  if (numatm < 5) {
#line 8812
    return (1);
  }
#line 8813
  i = 0;
#line 8813
  while (i < numatm) {
#line 8815
    ap___1 = a_next(i);
#line 8816
    ap___1->vx = ap___1->x;
#line 8817
    ap___1->vy = ap___1->y;
#line 8818
    ap___1->vz = ap___1->z;
#line 8813
    i ++;
  }
#line 8820
  x = 0.;
#line 8821
  y = 0.;
#line 8822
  x = - 3.141592653589793;
#line 8823
  dx = 0.;
#line 8824
  dy = 0.;
#line 8825
  if (nistep > 1) {
#line 8826
    dx = (3.141592653589793 * 2.) / (double )nistep;
  }
#line 8827
  if (njstep > 1) {
#line 8828
    dy = (3.141592653589793 * 2.) / (double )njstep;
  }
#line 8829
  fprintf(op, "%d %d Torsion map  %f %f steps\n", nistep, njstep, (dx * 180.) / 3.141592653589793,
          (dy * 180.) / 3.141592653589793);
#line 8831
  i = 0;
#line 8831
  while (i < nistep) {
#line 8833
    tset(op, 0, i1, i2, i3, i4, x);
#line 8834
    y = 0.;
#line 8835
    y = - 3.141592653589793;
#line 8836
    j = 0;
#line 8836
    while (j < njstep) {
#line 8838
      tset(op, 0, j1___0, j2, j3, j4, y);
#line 8839
      V = 0.;
#line 8840
      ifs = 0;
#line 8840
      while (ifs < nfs) {
#line 8841
    //    (*(*(vfs + ifs)))(& V, 0.);
#line 8840
        ifs ++;
      }
#line 8842
      fprintf(op, "%f ", V);
#line 8843
      y += dy;
#line 8836
      j ++;
    }
#line 8845
    fprintf(op, "\n");
#line 8846
    x += dx;
#line 8831
    i ++;
  }
#line 8848
  i = 0;
#line 8848
  while (i < numatm) {
#line 8850
    ap___1 = a_next(i);
#line 8851
    ap___1->x = ap___1->vx;
#line 8852
    ap___1->y = ap___1->vy;
#line 8853
    ap___1->z = ap___1->vz;
#line 8848
    i ++;
  }
#line 8855
  return (1);
}
}
#line 8872
int uselist(ATOM *(**thelist)[] , int *thesize , double cutoff ) ;
#line 8862 "188.c"
int u_v_nonbon(double *V , double lambda ) 
{ double r ;
  double r0 ;
  double xt ;
  double yt ;
  double zt ;
  double cutoff ;
  double rdebye ;
  int i ;
  ATOM *a1 ;
  ATOM *(*use)[] ;
  int nuse ;
  int used ;
  ATOM *bp ;
  int inbuffer ;
  double (*buffer)[] ;
  double xx ;
  double yy ;
  double zz ;
  int jj ;
  int imax ;
  double (*vector)[] ;
  ATOM *(*atms)[] ;
  double dielectric ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;

  {
#line 8880
  cutoff = get_f_variable("cutoff");
#line 8881
  if (cutoff < 1.) {
#line 8883
    v_nonbon(V, lambda);
#line 8884
    return (1);
  }
#line 8886
  rdebye = cutoff / 2.;
#line 8887
  dielectric = get_f_variable("dielec");
#line 8888
  if (dielectric < 1.) {
#line 8888
    dielectric = 1.;
  }
#line 8889
  dielectric = 332.17752 / dielectric;
#line 8890
  tmp = uselist(& use, & nuse, cutoff);
#line 8890
  if (! tmp) {
#line 8890
    return (0);
  }
#line 8891
  i = a_number();
#line 8892
  tmp___0 = malloc((unsigned int )(3 * i) * sizeof(double ));
#line 8892
  buffer = (double (*)[])tmp___0;
#line 8893
  if ((unsigned int )buffer == (unsigned int )((void *)0)) {
#line 8894
    aaerror((char *)"cannot allocate memory in u_v_nonbon\n");
#line 8894
    return (0);
  }
#line 8895
  tmp___1 = malloc((unsigned int )i * sizeof(double ));
#line 8895
  vector = (double (*)[])tmp___1;
#line 8896
  if ((unsigned int )vector == (unsigned int )((void *)0)) {
#line 8897
    aaerror((char *)"cannot allocate memory in u_v_nonbon\n");
#line 8897
    return (0);
  }
#line 8898
  tmp___2 = malloc((unsigned int )i * sizeof(ATOM *));
#line 8898
  atms = (ATOM *(*)[])tmp___2;
#line 8899
  if ((unsigned int )atms == (unsigned int )((void *)0)) {
#line 8900
    aaerror((char *)"cannot allocate memory in u_v_nonbon\n");
#line 8900
    return (0);
  }
#line 8901
  a1 = a_next(-1);
#line 8902
  a1 = (ATOM *)a1->next;
#line 8903
  imax = a_number();
#line 8904
  used = 0;
#line 8905
  jj = 1;
#line 8905
  while (jj < imax) {
#line 8907
    bp = (ATOM *)a1->next;
#line 8908
    inbuffer = 0;
#line 8909
    if ((unsigned int )(*use)[used] == (unsigned int )a1) {
#line 8910
      used ++;
    } else {
#line 8911
      aaerror((char *)"error in uselist - must abort");
#line 8911
      return (0);
    }
#line 8912
    while ((unsigned int )(*use)[used] != (unsigned int )a1) {
#line 8914
      tmp___3 = inbuffer;
#line 8914
      inbuffer ++;
#line 8914
      (*atms)[tmp___3] = (*use)[used];
#line 8915
      used ++;
    }
#line 8917
    used ++;
#line 8918
    if (inbuffer > 0) {
#line 8920
      i = 0;
#line 8920
      while (i < inbuffer) {
#line 8922
        (*buffer)[3 * i] = ((*atms)[i])->x;
#line 8923
        (*buffer)[3 * i + 1] = ((*atms)[i])->y;
#line 8924
        (*buffer)[3 * i + 2] = ((*atms)[i])->z;
#line 8920
        i ++;
      }
#line 8926
      if (lambda != 0.) {
#line 8928
        i = 0;
#line 8928
        while (i < inbuffer) {
#line 8930
          (*buffer)[3 * i] = ((*atms)[i])->x + ((*atms)[i])->dx * lambda;
#line 8931
          (*buffer)[3 * i + 1] = ((*atms)[i])->y + ((*atms)[i])->dy * lambda;
#line 8932
          (*buffer)[3 * i + 2] = ((*atms)[i])->z + ((*atms)[i])->dz * lambda;
#line 8928
          i ++;
        }
      }
#line 8935
      xx = a1->x + lambda * a1->dx;
#line 8936
      yy = a1->y + lambda * a1->dy;
#line 8937
      zz = a1->z + lambda * a1->dz;
#line 8938
      i = 0;
#line 8938
      while (i < inbuffer) {
#line 8940
        xt = xx - (*buffer)[3 * i];
#line 8941
        yt = yy - (*buffer)[3 * i + 1];
#line 8942
        zt = zz - (*buffer)[3 * i + 2];
#line 8943
        r = (xt * xt + yt * yt) + zt * zt;
#line 8944
        if (r < 2.) {
#line 8944
          r = 2.;
        }
#line 8945
        r0 = sqrt(r);
#line 8945
        r = (r * r) * r;
#line 8946
        tmp___4 = exp(- r0 / rdebye);
#line 8946
        (*vector)[i] = ((((a1->q * ((*atms)[i])->q) / r0) * dielectric) * tmp___4 - (a1->a * ((*atms)[i])->a) / r) + ((a1->b * ((*atms)[i])->b) / r) / r;
#line 8938
        i ++;
      }
#line 8950
      i = 0;
#line 8950
      while (i < inbuffer) {
#line 8951
        *V += (*vector)[i];
#line 8950
        i ++;
      }
    }
#line 8905
    jj ++;
#line 8905
    a1 = bp;
  }
#line 8954
  free((void *)atms);
#line 8954
  free((void *)buffer);
#line 8955
  free((void *)vector);
#line 8956
  return (1);
}
}
#line 8958 "188.c"
int u_f_nonbon(double lambda ) 
{ double r ;
  double r0 ;
  double xt ;
  double yt ;
  double zt ;
  double cutoff ;
  double rdebye ;
  int i ;
  ATOM *a1 ;
  ATOM *(*use)[] ;
  int nuse ;
  int used ;
  ATOM *bp ;
  int inbuffer ;
  double (*buffer)[] ;
  double xx ;
  double yy ;
  double zz ;
  double k ;
  int jj ;
  int imax ;
  double (*vector)[] ;
  ATOM *(*atms)[] ;
  double dielectric ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;

  {
#line 8976
  cutoff = get_f_variable("cutoff");
#line 8977
  if (cutoff < 1.) {
#line 8979
    f_nonbon(lambda);
#line 8980
    return (1);
  }
#line 8982
  rdebye = cutoff / 2.;
#line 8983
  dielectric = get_f_variable("dielec");
#line 8984
  if (dielectric < 1.) {
#line 8984
    dielectric = 1.;
  }
#line 8985
  dielectric = 332.17752 / dielectric;
#line 8986
  tmp = uselist(& use, & nuse, cutoff);
#line 8986
  if (! tmp) {
#line 8986
    return (0);
  }
#line 8987
  i = a_number();
#line 8988
  tmp___0 = malloc((unsigned int )(3 * i) * sizeof(double ));
#line 8988
  buffer = (double (*)[])tmp___0;
#line 8989
  if ((unsigned int )buffer == (unsigned int )((void *)0)) {
#line 8990
    aaerror((char *)"cannot allocate memory in u_v_nonbon\n");
#line 8990
    return (0);
  }
#line 8991
  tmp___1 = malloc((unsigned int )(3 * i) * sizeof(double ));
#line 8991
  vector = (double (*)[])tmp___1;
#line 8992
  if ((unsigned int )vector == (unsigned int )((void *)0)) {
#line 8993
    aaerror((char *)"cannot allocate memory in u_v_nonbon\n");
#line 8993
    return (0);
  }
#line 8994
  tmp___2 = malloc((unsigned int )i * sizeof(ATOM *));
#line 8994
  atms = (ATOM *(*)[])tmp___2;
#line 8995
  if ((unsigned int )atms == (unsigned int )((void *)0)) {
#line 8996
    aaerror((char *)"cannot allocate memory in u_v_nonbon\n");
#line 8996
    return (0);
  }
#line 8997
  a1 = a_next(-1);
#line 8998
  a1 = (ATOM *)a1->next;
#line 8999
  imax = a_number();
#line 9000
  used = 0;
#line 9001
  jj = 1;
#line 9001
  while (jj < imax) {
#line 9003
    bp = (ATOM *)a1->next;
#line 9004
    inbuffer = 0;
#line 9005
    if ((unsigned int )(*use)[used] == (unsigned int )a1) {
#line 9006
      used ++;
    } else {
#line 9007
      aaerror((char *)"error in uselist - must abort");
#line 9007
      return (0);
    }
#line 9008
    while ((unsigned int )(*use)[used] != (unsigned int )a1) {
#line 9010
      tmp___3 = inbuffer;
#line 9010
      inbuffer ++;
#line 9010
      (*atms)[tmp___3] = (*use)[used];
#line 9011
      used ++;
    }
#line 9013
    used ++;
#line 9014
    if (inbuffer > 0) {
#line 9016
      i = 0;
#line 9016
      while (i < inbuffer) {
#line 9018
        (*buffer)[3 * i] = ((*atms)[i])->x;
#line 9019
        (*buffer)[3 * i + 1] = ((*atms)[i])->y;
#line 9020
        (*buffer)[3 * i + 2] = ((*atms)[i])->z;
#line 9016
        i ++;
      }
#line 9022
      if (lambda != 0.) {
#line 9024
        i = 0;
#line 9024
        while (i < inbuffer) {
#line 9026
          (*buffer)[3 * i] = ((*atms)[i])->x + ((*atms)[i])->dx * lambda;
#line 9027
          (*buffer)[3 * i + 1] = ((*atms)[i])->y + ((*atms)[i])->dy * lambda;
#line 9028
          (*buffer)[3 * i + 2] = ((*atms)[i])->z + ((*atms)[i])->dz * lambda;
#line 9024
          i ++;
        }
      }
#line 9031
      xx = a1->x + lambda * a1->dx;
#line 9032
      yy = a1->y + lambda * a1->dy;
#line 9033
      zz = a1->z + lambda * a1->dz;
#line 9034
      i = 0;
#line 9034
      while (i < inbuffer) {
#line 9036
        xt = xx - (*buffer)[3 * i];
#line 9037
        yt = yy - (*buffer)[3 * i + 1];
#line 9038
        zt = zz - (*buffer)[3 * i + 2];
#line 9039
        r = (xt * xt + yt * yt) + zt * zt;
#line 9041
        if (r <= 1.) {
#line 9042
          r = 1.;
        }
#line 9043
        r0 = sqrt(r);
#line 9043
        xt /= r0;
#line 9043
        yt /= r0;
#line 9043
        zt /= r0;
#line 9044
        tmp___4 = exp(- r0 / rdebye);
#line 9044
        k = (((- a1->q * ((*atms)[i])->q) * dielectric) * tmp___4) * (1. / (rdebye * r0) + 1. / r);
#line 9046
        r = (r * r) * r;
#line 9047
        k += (((a1->a * ((*atms)[i])->a) / r) / r0) * (double )6;
#line 9048
        k -= ((((a1->b * ((*atms)[i])->b) / r) / r) / r0) * (double )12;
#line 9049
        (*vector)[3 * i] = xt * k;
#line 9050
        (*vector)[3 * i + 1] = yt * k;
#line 9051
        (*vector)[3 * i + 2] = zt * k;
#line 9034
        i ++;
      }
#line 9053
      i = 0;
#line 9053
      while (i < inbuffer) {
#line 9055
        a1->fx -= (*vector)[3 * i];
#line 9056
        a1->fy -= (*vector)[3 * i + 1];
#line 9057
        a1->fz -= (*vector)[3 * i + 2];
#line 9058
        ((*atms)[i])->fx += (*vector)[3 * i];
#line 9059
        ((*atms)[i])->fy += (*vector)[3 * i + 1];
#line 9060
        ((*atms)[i])->fz += (*vector)[3 * i + 2];
#line 9053
        i ++;
      }
    }
#line 9001
    jj ++;
#line 9001
    a1 = bp;
  }
#line 9064
  free((void *)atms);
#line 9064
  free((void *)buffer);
#line 9065
  free((void *)vector);
#line 9066
  return (1);
}
}
#line 9073
int uselist(ATOM *(**thelist)[] , int *thesize , double cutoff ) ;
#line 9073 "188.c"
static int oldatomnumber  =    0;
#line 9074
int uselist(ATOM *(**thelist)[] , int *thesize , double cutoff ) ;
#line 9074 "188.c"
static int since  =    0;
#line 9074 "188.c"
static int lsize  ;
#line 9075 "188.c"
static ATOM *(*local)[]  ;
#line 9076
int uselist(ATOM *(**thelist)[] , int *thesize , double cutoff ) ;
#line 9076 "188.c"
static double oldcutoff  =    (double )-1;
#line 9068 "188.c"
int uselist(ATOM *(**thelist)[] , int *thesize , double cutoff ) 
{ ATOM *a1 ;
  ATOM *a2 ;
  ATOM *ap___1 ;
  ATOM *bp ;
  int i ;
  int j ;
  int k ;
  int max ;
  double lcutoff ;
  double x ;
  double y ;
  double z ;
  double r ;
  double rcut ;
  void *tmp ;

  {
#line 9083
  i = a_number();
#line 9084
  j = get_i_variable("nbstep");
#line 9085
  if (j <= 0) {
#line 9085
    j = 10;
  }
#line 9086
  if (i == oldatomnumber) {
#line 9086
    if (since < j) {
#line 9086
      if (cutoff == oldcutoff) {
#line 9088
        *thelist = local;
#line 9089
        *thesize = lsize;
#line 9090
        since ++;
#line 9091
        return (1);
      }
    }
  }
  RESET: 
#line 9094
  if (oldatomnumber > 0) {
#line 9094
    free((void *)local);
  }
#line 9095
  oldcutoff = cutoff;
#line 9096
  lcutoff = - cutoff;
#line 9097
  since = 0;
#line 9098
  oldatomnumber = i;
#line 9099
  j = get_i_variable("nbdeep");
#line 9100
  if (j <= 0) {
#line 9100
    j = 20;
  }
#line 9101
  max = i * j;
#line 9102
  tmp = malloc((unsigned int )max * sizeof(ATOM *));
#line 9102
  local = (ATOM *(*)[])tmp;
#line 9103
  if ((unsigned int )local == (unsigned int )((void *)0)) {
#line 9104
    aaerror((char *)"cannot allocate uselist memory");
#line 9104
    exit(0);
  }
#line 9105
  *thelist = local;
#line 9106
  *thesize = 0;
#line 9107
  rcut = cutoff * cutoff;
#line 9108
  a1 = a_next(-1);
#line 9109
  a1 = (ATOM *)a1->next;
#line 9110
  i = 1;
#line 9110
  while (i < oldatomnumber) {
#line 9112
    ap___1 = (ATOM *)a1->next;
#line 9113
    (*local)[*thesize] = a1;
#line 9114
    (*thesize) ++;
#line 9115
    a2 = a_next(-1);
#line 9116
    j = 0;
#line 9116
    while (j < i) {
#line 9118
      k = 0;
#line 9118
      while (k < a1->dontuse) {
#line 9120
        if ((unsigned int )a2 == (unsigned int )a1->excluded[k]) {
          goto SKIP;
        }
#line 9118
        k ++;
      }
#line 9122
      if (a2->x - a1->x > cutoff) {
        goto SKIP;
      }
#line 9123
      if (a2->x - a1->x < lcutoff) {
        goto SKIP;
      }
#line 9124
      if (a2->y - a1->y > cutoff) {
        goto SKIP;
      }
#line 9125
      if (a2->y - a1->y < lcutoff) {
        goto SKIP;
      }
#line 9126
      if (a2->z - a1->z > cutoff) {
        goto SKIP;
      }
#line 9127
      if (a2->z - a1->z < lcutoff) {
        goto SKIP;
      }
#line 9128
      x = a2->x - a1->x;
#line 9129
      y = a2->y - a1->y;
#line 9130
      z = a2->z - a1->z;
#line 9131
      r = (x * x + y * y) + z * z;
#line 9132
      if (r > rcut) {
        goto SKIP;
      }
#line 9134
      (*local)[*thesize] = a2;
#line 9135
      (*thesize) ++;
#line 9136
      if (*thesize >= max) {
#line 9137
        aaerror((char *)"please increase nbdeep (seti nbdeep (>20);)");
#line 9138
        i = a_number();
#line 9139
        j = get_i_variable("nbdeep");
#line 9140
        if (j == 0) {
#line 9140
          j = 20;
        }
#line 9141
        if (j == i + 2) {
#line 9142
          aaerror((char *)"Terrible error in uselist, too many interactions");
#line 9143
          exit(0);
        }
#line 9144
        j = 2 * j;
#line 9144
        if (j > i + 2) {
#line 9144
          j = i + 2;
        }
#line 9145
        set_i_variable("nbdeep", j);
        goto RESET;
      }
      SKIP: 
#line 9149
      bp = a_next(1);
#line 9116
      j ++;
#line 9116
      a2 = bp;
    }
#line 9151
    (*local)[*thesize] = a1;
#line 9152
    (*thesize) ++;
#line 9153
    lsize = *thesize;
#line 9110
    i ++;
#line 9110
    a1 = ap___1;
  }
#line 9155
  return (1);
}
}
#line 9172 "188.c"
VARIABLE___0 *variableFIRST  =    (VARIABLE___0 *)((void *)0);
#line 9173 "188.c"
VARIABLE___0 *variableLAST  =    (VARIABLE___0 *)((void *)0);
#line 9175 "188.c"
struct __anonstruct_VARIABLE_25 *match_variable(char *name ) 
{ VARIABLE___0 *vp ;
  int tmp ;

  {
#line 9179
  vp = variableFIRST;
#line 9180
  while (1) {
#line 9182
    if ((unsigned int )vp == (unsigned int )((void *)0)) {
#line 9182
      return ((struct __anonstruct_VARIABLE_25 *)vp);
    }
#line 9183
    tmp = strcmp((char const   *)(& vp->name[0]), (char const   *)name);
#line 9183
    if (tmp == 0) {
#line 9183
      return ((struct __anonstruct_VARIABLE_25 *)vp);
    }
#line 9184
    if ((unsigned int )vp == (unsigned int )vp->next) {
#line 9184
      return ((struct __anonstruct_VARIABLE_25 *)((void *)0));
    }
#line 9185
    vp = (VARIABLE___0 *)vp->next;
  }
}
}
#line 9188 "188.c"
int set_f_variable(char *name , double f ) 
{ VARIABLE___0 *new ;
  int i ;
  struct __anonstruct_VARIABLE_25 *tmp ;
  void *tmp___0 ;

  {
#line 9193
  tmp = match_variable(name);
#line 9193
  new = (VARIABLE___0 *)tmp;
#line 9194
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 9196
    tmp___0 = malloc(sizeof(VARIABLE___0 ));
#line 9196
    new = (VARIABLE___0 *)tmp___0;
#line 9196
    if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 9198
      return (0);
    }
#line 9200
    new->next = (void *)0;
#line 9201
    if ((unsigned int )variableFIRST == (unsigned int )((void *)0)) {
#line 9201
      variableFIRST = new;
    }
#line 9202
    if ((unsigned int )variableLAST == (unsigned int )((void *)0)) {
#line 9202
      variableLAST = new;
    }
  }
#line 9204
  new->value.f = f;
#line 9205
  new->type = 1;
#line 9206
  i = 0;
#line 9206
  while (i < 7) {
#line 9208
    new->name[i] = *name;
#line 9209
    if ((int )*name == 0) {
#line 9209
      break;
    }
#line 9210
    name ++;
#line 9206
    i ++;
  }
#line 9212
  if ((unsigned int )new->next == (unsigned int )((void *)0)) {
#line 9214
    new->next = (void *)new;
#line 9215
    variableLAST->next = (void *)new;
#line 9216
    variableLAST = new;
  }
  
#line 9218
  return (1);
}
}
#line 9220 "188.c"
int set_i_variable(char *name , int f ) 
{ VARIABLE___0 *new ;
  int i ;
  struct __anonstruct_VARIABLE_25 *tmp ;
  void *tmp___0 ;

  {
#line 9227
  tmp = match_variable(name);
#line 9227
  new = (VARIABLE___0 *)tmp;
#line 9228
  if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 9230
    tmp___0 = malloc(sizeof(VARIABLE___0 ));
#line 9230
    new = (VARIABLE___0 *)tmp___0;
#line 9230
    if ((unsigned int )new == (unsigned int )((void *)0)) {
#line 9232
      return (0);
   }
#line 9234
    new->next = (void *)0;
#line 9235
    if ((unsigned int )variableFIRST == (unsigned int )((void *)0)) {
#line 9235
      variableFIRST = new;
    }
#line 9236
    if ((unsigned int )variableLAST == (unsigned int )((void *)0)) {
#line 9236
      variableLAST = new;
    }
  }
#line 9238
  new->value.i = f;
#line 9239
  new->type = 0;
#line 9240
  i = 0;
#line 9240
  while (i < 7) {
#line 9242
    new->name[i] = *name;
#line 9243
    if ((int )*name == 0) {
#line 9243
      break;
    }
#line 9244
    name ++;
#line 9240
    i ++;
  }
#line 9246
  if ((unsigned int )new->next == (unsigned int )((void *)0)) {
#line 9248
    new->next = (void *)new;
#line 9249
    variableLAST->next = (void *)new;
#line 9250
    variableLAST = new;
  }
  /*if(new != 0){
	goto ERROR;
	ERROR:exit(0);
  }*/
#line 9252
  return (1);
}
}
#line 9254 "188.c"
double get_f_variable(char *name ) 
{ VARIABLE___0 *vp ;
  struct __anonstruct_VARIABLE_25 *tmp ;

  {
#line 9259
  tmp = match_variable(name);
#line 9259
  vp = (VARIABLE___0 *)tmp;
#line 9260
  if ((unsigned int )vp == (unsigned int )((void *)0)) {
#line 9260
    return (0.);
  }
#line 9261
  if (vp->type == 1) {
#line 9261
    return (vp->value.f);
  }
#line 9262
  return ((double )vp->value.i);
}
}
#line 9264 "188.c"
int get_i_variable(char *name ) 
{ VARIABLE___0 *vp ;
  struct __anonstruct_VARIABLE_25 *tmp ;

  {
#line 9269
  tmp = match_variable(name);
#line 9269
  vp = (VARIABLE___0 *)tmp;
#line 9270
  if ((unsigned int )vp == (unsigned int )((void *)0)) {
#line 9270
    return (0);
  }
#line 9271
  if (vp->type == 0) {
#line 9271
    return (vp->value.i);
  }
#line 9272
  return ((int )vp->value.f);
}
}
#line 9274 "188.c"
void dump_variable(FILE *where ) 
{ VARIABLE___0 *vp ;

  {
#line 9277
  vp = variableFIRST;
#line 9278
  while (1) {
#line 9280
    if ((unsigned int )vp->next == (unsigned int )((void *)0)) {
#line 9280
      return;
    }
#line 9281
    if (vp->type == 0) {
#line 9283
      fprintf(where, "seti %s %d ;\n", & vp->name[0], vp->value.i);
    } else {
#line 9286
      fprintf(where, "setf %s %f ;\n", & vp->name[0], vp->value.f);
    }
#line 9288
    if ((unsigned int )vp->next == (unsigned int )vp) {
#line 9288
      return;
    }
#line 9289
    vp = (VARIABLE___0 *)vp->next;
  }
}
}
#line 9315
int fv_update_nonbon(double lambda ) ;
#line 9315 "188.c"
static double dielecold  =    - 1.;
#line 9298 "188.c"
int fv_update_nonbon(double lambda ) 
{ double r ;
  double r0 ;
  double xt ;
  double yt ;
  double zt ;
  double k ;
  double k1 ;
  double k2 ;
  double ka2 ;
  double kb2 ;
  int i ;
  ATOM *a1 ;
  ATOM *a2 ;
  int (*indexes)[] ;
  int inindex ;
  int in ;
  int ii ;
  int j ;
  int imax ;
  int inclose ;
  double (*vector)[] ;
  ATOM *(*atomall)[] ;
  double mxdq ;
  double dielectric ;
  double mxcut ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 9316
  mxdq = get_f_variable((char *)"mxdq");
#line 9317
  mxcut = get_f_variable((char *)"mxcut");
#line 9318
  if (mxcut < 0.) {
#line 9318
    mxcut = 5.;
  }
#line 9319
  if (mxdq > 0.) {
#line 9319
    mxdq *= mxdq;
  }
#line 9320
  dielectric = get_f_variable((char *)"dielec");
#line 9321
  if (dielectric < 1.) {
#line 9321
    dielectric = 1.;
  }
#line 9322
  if (dielecold != dielectric) {
#line 9324
    dielecold = dielectric;
#line 9325
    mxdq = - 1.;
  }
#line 9327
  dielectric = 332.17752 / dielectric;
#line 9329
  i = a_number();
#line 9330
  tmp = malloc((unsigned int )(4 * i) * sizeof(double ));
#line 9330
  vector = (double (*)[])tmp;
#line 9331
  if ((unsigned int )vector == (unsigned int )((void *)0)) {
#line 9332
    aaerror((char *)"cannot allocate memory in v_nonbon\n");
#line 9332
    return (0);
  }
#line 9333
  tmp___0 = malloc((unsigned int )i * sizeof(ATOM *));
#line 9333
  atomall = (ATOM *(*)[])tmp___0;
#line 9334
  if ((unsigned int )atomall == (unsigned int )((void *)0)) {
#line 9335
    aaerror((char *)"cannot allocate memory in v_nonbon\n");
#line 9335
    return (0);
  }
#line 9336
  imax = a_number();
#line 9337
  i = 0;
#line 9337
  while (i < imax) {
#line 9339
    (*atomall)[i] = a_next(i);
#line 9337
    i ++;
  }
#line 9341
  ii = 0;
#line 9341
  while (ii < imax) {
#line 9343
    a1 = (*atomall)[ii];
#line 9344
    xt = (a1->dx * lambda + a1->x) - a1->px;
#line 9345
    yt = (a1->dy * lambda + a1->y) - a1->py;
#line 9346
    zt = (a1->dz * lambda + a1->z) - a1->pz;
#line 9347
    r = (xt * xt + yt * yt) + zt * zt;
#line 9348
    if (r > mxdq) {
      goto DOIT;
    }
#line 9341
    ii ++;
  }
#line 9351
  free((void *)vector);
#line 9352
  free((void *)atomall);
#line 9353
  return (1);
  DOIT: 
#line 9355
  xt = get_f_variable((char *)"mmbox");
#line 9356
  if (xt > 0.) {
#line 9357
    free((void *)vector);
#line 9357
    free((void *)atomall);
#line 9357
    mm_fv_update_nonbon(lambda);
#line 9357
    return (1);
  }
#line 9358
  tmp___1 = malloc((unsigned int )imax * sizeof(int ));
#line 9358
  indexes = (int (*)[])tmp___1;
#line 9359
  if ((unsigned int )indexes == (unsigned int )((void *)0)) {
#line 9360
    aaerror((char *)" cannot allocate memory in fv_update\n");
#line 9361
    return (0);
  }
#line 9362
  ii = 0;
#line 9362
  while (ii < imax) {
#line 9364
    a1 = (*atomall)[ii];
#line 9365
    a1->VP = 0.;
#line 9366
    a1->dpx = 0.;
#line 9367
    a1->dpy = 0.;
#line 9368
    a1->dpz = 0.;
#line 9369
    a1->qxx = 0.;
#line 9370
    a1->qxy = 0.;
#line 9371
    a1->qxz = 0.;
#line 9372
    a1->qyy = 0.;
#line 9373
    a1->qyz = 0.;
#line 9374
    a1->qzz = 0.;
#line 9387
    j = 0;
#line 9387
    while (j < 200) {
#line 9388
      a1->close[j] = (void *)0;
#line 9387
      j ++;
    }
#line 9362
    ii ++;
  }
#line 9390
  ii = 0;
#line 9390
  while (ii < imax) {
#line 9392
    a1 = (*atomall)[ii];
#line 9393
    inclose = 0;
#line 9394
    if (lambda != 0.) {
#line 9396
      i = ii + 1;
#line 9396
      while (i < imax) {
#line 9398
        a2 = (*atomall)[i];
#line 9399
        j = i * 4;
#line 9400
        (*vector)[j] = (a2->x - a1->x) + lambda * (a2->dx - a1->dx);
#line 9401
        (*vector)[j + 1] = (a2->y - a1->y) + lambda * (a2->dy - a1->dy);
#line 9402
        (*vector)[j + 2] = (a2->z - a1->z) + lambda * (a2->dz - a1->dz);
#line 9396
        i ++;
      }
    } else {
#line 9405
      i = ii + 1;
#line 9405
      while (i < imax) {
#line 9407
        a2 = (*atomall)[i];
#line 9408
        j = i * 4;
#line 9409
        (*vector)[j] = a2->x - a1->x;
#line 9410
        (*vector)[j + 1] = a2->y - a1->y;
#line 9411
        (*vector)[j + 2] = a2->z - a1->z;
#line 9405
        i ++;
      }
    }
#line 9414
    i = ii + 1;
#line 9414
    while (i < imax) {
#line 9416
      j = i * 4;
#line 9417
      (*vector)[j + 3] = sqrt(((*vector)[j] * (*vector)[j] + (*vector)[j + 1] * (*vector)[j + 1]) + (*vector)[j + 2] * (*vector)[j + 2]);
#line 9414
      i ++;
    }
#line 9421
    inindex = 0;
#line 9422
    i = ii + 1;
#line 9422
    while (i < imax) {
#line 9424
      a2 = (*atomall)[i];
#line 9425
      j = 0;
#line 9425
      while (j < a1->dontuse) {
#line 9426
        if ((unsigned int )a2 == (unsigned int )a1->excluded[j]) {
          goto SKIPNEW;
        }
#line 9425
        j ++;
      }
#line 9427
      j = i * 4;
#line 9428
      if ((*vector)[j + 3] > mxcut) {
#line 9430
        tmp___2 = inindex;
#line 9430
        inindex ++;
#line 9430
        (*indexes)[tmp___2] = i;
      } else {
#line 9428
        if (inclose > 200) {
#line 9430
          tmp___2 = inindex;
#line 9430
          inindex ++;
#line 9430
          (*indexes)[tmp___2] = i;
        } else {
#line 9432
          tmp___3 = inclose;
#line 9432
          inclose ++;
#line 9432
          a1->close[tmp___3] = (void *)(*atomall)[i];
        }
      }
#line 9434
      if (inclose == 200) {
#line 9436
        aaerror((char *)" fv_update_nonbon> too many atoms increase NCLOSE or decrease mxcut");
      }
      SKIPNEW: 
#line 9439
      i = i;
#line 9422
      i ++;
    }
#line 9442
    in = 0;
#line 9442
    while (in < inindex) {
#line 9444
      i = (*indexes)[in];
#line 9445
      a2 = (*atomall)[i];
#line 9446
      j = i * 4;
#line 9447
      r0 = 1. / (*vector)[j + 3];
#line 9448
      r = r0 * r0;
#line 9449
      r = (r * r) * r;
#line 9450
      xt = ((a1->q * a2->q) * dielectric) * r0;
#line 9451
      yt = (a1->a * a2->a) * r;
#line 9452
      zt = ((a1->b * a2->b) * r) * r;
#line 9453
      k = (xt - yt) + zt;
#line 9454
      xt *= r0;
#line 9454
      yt *= r0;
#line 9454
      zt *= r0;
#line 9455
      k1 = (xt - yt * 6.) + zt * 12.;
#line 9456
      xt *= r0;
#line 9456
      yt *= r0;
#line 9456
      zt *= r0;
#line 9458
      k2 = xt * 3.;
#line 9458
      ka2 = - yt * 48.;
#line 9458
      kb2 = zt * 168.;
#line 9463
      k1 = - k1;
#line 9464
      xt = (*vector)[j] * r0;
#line 9465
      yt = (*vector)[j + 1] * r0;
#line 9466
      zt = (*vector)[j + 2] * r0;
#line 9468
      a1->VP += k;
#line 9469
      a2->dpx -= k1 * xt;
#line 9470
      a1->dpx += k1 * xt;
#line 9471
      a2->dpy -= k1 * yt;
#line 9472
      a1->dpy += k1 * yt;
#line 9473
      a2->dpz -= k1 * zt;
#line 9474
      a1->dpz += k1 * zt;
#line 9475
      a2->qxx -= (k2 * (xt * xt - 1. / (double )3) + ka2 * (xt * xt - 1. / (double )8)) + kb2 * (xt * xt - 1. / (double )14);
#line 9476
      a1->qxx -= (k2 * (xt * xt - 1. / (double )3) + ka2 * (xt * xt - 1. / (double )8)) + kb2 * (xt * xt - 1. / (double )14);
#line 9477
      a2->qxy -= (((k2 + ka2) + kb2) * yt) * xt;
#line 9478
      a1->qxy -= (((k2 + ka2) + kb2) * yt) * xt;
#line 9479
      a2->qxz -= (((k2 + ka2) + kb2) * zt) * xt;
#line 9480
      a1->qxz -= (((k2 + ka2) + kb2) * zt) * xt;
#line 9481
      a2->qyy -= (k2 * (yt * yt - 1. / (double )3) + ka2 * (yt * yt - 1. / (double )8)) + kb2 * (yt * yt - 1. / (double )14);
#line 9482
      a1->qyy -= (k2 * (yt * yt - 1. / (double )3) + ka2 * (yt * yt - 1. / (double )8)) + kb2 * (yt * yt - 1. / (double )14);
#line 9483
      a2->qyz -= (((k2 + ka2) + kb2) * yt) * zt;
#line 9484
      a1->qyz -= (((k2 + ka2) + kb2) * yt) * zt;
#line 9485
      a2->qzz -= (k2 * (zt * zt - 1. / (double )3) + ka2 * (zt * zt - 1. / (double )8)) + kb2 * (zt * zt - 1. / (double )14);
#line 9486
      a1->qzz -= (k2 * (zt * zt - 1. / (double )3) + ka2 * (zt * zt - 1. / (double )8)) + kb2 * (zt * zt - 1. / (double )14);
#line 9442
      in ++;
    }
#line 9547
    a1->px = a1->dx * lambda + a1->x;
#line 9548
    a1->py = a1->dy * lambda + a1->y;
#line 9549
    a1->pz = a1->dz * lambda + a1->z;
#line 9390
    ii ++;
  }
#line 9552
  a_inactive_f_zero();
#line 9553
  free((void *)indexes);
#line 9554
  free((void *)vector);
#line 9555
  free((void *)atomall);
#line 9556
  return (1);
}
}
#line 9558 "188.c"
int f_nonbon(double lambda ) 
{ double ux ;
  double uy ;
  double uz ;
  double k ;
  double r ;
  double r0 ;
  double xt ;
  double yt ;
  double zt ;
  int i ;
  ATOM *a1 ;
  ATOM *a2 ;
  int imax ;
  int ii ;
  int jj ;
  ATOM *(*atomall)[] ;
  double dielectric ;
  double fx___0 ;
  double fy___0 ;
  double fz___0 ;
  void *tmp ;

  {
#line 9577
  fv_update_nonbon(lambda);
#line 9578
  dielectric = get_f_variable((char *)"dielec");
#line 9579
  if (dielectric < 1.) {
#line 9579
    dielectric = 1.;
  }
#line 9580
  dielectric = 332.17752 / dielectric;
#line 9581
  i = a_number();
#line 9582
  tmp = malloc((unsigned int )i * sizeof(ATOM *));
#line 9582
  atomall = (ATOM *(*)[])tmp;
#line 9583
  if ((unsigned int )atomall == (unsigned int )((void *)0)) {
#line 9584
    aaerror((char *)"cannot allocate memory in f_nonbon");
#line 9584
    return (0);
  }
#line 9585
  imax = a_number();
#line 9586
  i = 0;
#line 9586
  while (i < imax) {
#line 9588
    (*atomall)[i] = a_next(i);
#line 9586
    i ++;
  }
#line 9590
  i = 0;
#line 9590
  while (i < imax) {
#line 9592
    fx___0 = 0.;
#line 9592
    fy___0 = 0.;
#line 9592
    fz___0 = 0.;
#line 9593
    a1 = (*atomall)[i];
#line 9594
    xt = (a1->dx * lambda + a1->x) - a1->px;
#line 9595
    yt = (a1->dy * lambda + a1->y) - a1->py;
#line 9596
    zt = (a1->dz * lambda + a1->z) - a1->pz;
#line 9597
    fx___0 = (a1->qxx * xt + a1->qxy * yt) + a1->qxz * zt;
#line 9599
    fy___0 = (a1->qxy * xt + a1->qyy * yt) + a1->qyz * zt;
#line 9601
    fz___0 = (a1->qxz * xt + a1->qyz * yt) + a1->qzz * zt;
#line 9645
    a1->fx += fx___0 + a1->dpx;
#line 9646
    a1->fy += fy___0 + a1->dpy;
#line 9647
    a1->fz += fz___0 + a1->dpz;
#line 9648
    jj = 0;
#line 9648
    while (jj < 200) {
#line 9649
      if ((unsigned int )a1->close[jj] == (unsigned int )((void *)0)) {
#line 9649
        break;
      }
#line 9648
      jj ++;
    }
#line 9650
    ii = 0;
#line 9650
    while (ii < jj) {
#line 9652
      a2 = (ATOM *)a1->close[ii];
#line 9653
      ux = (a2->dx - a1->dx) * lambda + (a2->x - a1->x);
#line 9654
      uy = (a2->dy - a1->dy) * lambda + (a2->y - a1->y);
#line 9655
      uz = (a2->dz - a1->dz) * lambda + (a2->z - a1->z);
#line 9656
      r = 1. / ((ux * ux + uy * uy) + uz * uz);
#line 9656
      r0 = sqrt(r);
#line 9657
      ux *= r0;
#line 9657
      uy *= r0;
#line 9657
      uz *= r0;
#line 9658
      k = ((- dielectric * a1->q) * a2->q) * r;
#line 9659
      r = (r * r) * r;
#line 9660
      k += (((a1->a * a2->a) * r) * r0) * 6.;
#line 9661
      k -= ((((a1->b * a2->b) * r) * r) * r0) * 12.;
#line 9662
      a1->fx += ux * k;
#line 9663
      a1->fy += uy * k;
#line 9664
      a1->fz += uz * k;
#line 9665
      a2->fx -= ux * k;
#line 9666
      a2->fy -= uy * k;
#line 9667
      a2->fz -= uz * k;
#line 9650
      ii ++;
    }
#line 9590
    i ++;
  }
#line 9670
  a_inactive_f_zero();
#line 9671
  free((void *)atomall);
#line 9671
  return (1);
}
}
#line 9673 "188.c"
int v_nonbon(double *V , double lambda ) 
{ double r ;
  double r0 ;
  double xt ;
  double yt ;
  double zt ;
  double k ;
  int i ;
  ATOM *a1 ;
  ATOM *a2 ;
  int ii ;
  int jj ;
  int imax ;
  double vx ;
  ATOM *(*atomall)[] ;
  double dielectric ;
  void *tmp ;

  {
#line 9692
  fv_update_nonbon(lambda);
#line 9693
  dielectric = get_f_variable((char *)"dielec");
#line 9694
  if (dielectric < 1.) {
#line 9694
    dielectric = 1.;
  }
#line 9695
  dielectric = 332.17752 / dielectric;
#line 9696
  i = a_number();
#line 9697
  tmp = malloc((unsigned int )i * sizeof(ATOM *));
#line 9697
  atomall = (ATOM *(*)[])tmp;
#line 9698
  if ((unsigned int )atomall == (unsigned int )((void *)0)) {
#line 9699
    aaerror((char *)"cannot allocate memory in v_nonbon");
#line 9699
    return (0);
  }
#line 9700
  imax = a_number();
#line 9701
  i = 0;
#line 9701
  while (i < imax) {
#line 9703
    (*atomall)[i] = a_next(i);
#line 9701
    i ++;
  }
#line 9705
  i = 0;
#line 9705
  while (i < imax) {
#line 9707
    a1 = (*atomall)[i];
#line 9708
    vx = a1->VP;
#line 9709
    xt = (a1->dx * lambda + a1->x) - a1->px;
#line 9710
    yt = (a1->dy * lambda + a1->y) - a1->py;
#line 9711
    zt = (a1->dz * lambda + a1->z) - a1->pz;
#line 9712
    vx -= (a1->dpx * xt + a1->dpy * yt) + a1->dpz * zt;
#line 9714
    vx -= (xt * (((.5 * a1->qxx) * xt + a1->qxy * yt) + a1->qxz * zt) + yt * ((.5 * a1->qyy) * yt + a1->qyz * zt)) + ((.5 * zt) * a1->qzz) * zt;
#line 9742
    jj = 0;
#line 9742
    while (jj < 200) {
#line 9743
      if ((unsigned int )a1->close[jj] == (unsigned int )((void *)0)) {
#line 9743
        break;
      }
#line 9742
      jj ++;
    }
#line 9744
    ii = 0;
#line 9744
    while (ii < jj) {
#line 9746
      a2 = (ATOM *)a1->close[ii];
#line 9747
      xt = (a2->dx - a1->dx) * lambda + (a2->x - a1->x);
#line 9748
      yt = (a2->dy - a1->dy) * lambda + (a2->y - a1->y);
#line 9749
      zt = (a2->dz - a1->dz) * lambda + (a2->z - a1->z);
#line 9750
      r = 1. / ((xt * xt + yt * yt) + zt * zt);
#line 9750
      r0 = sqrt(r);
#line 9751
      k = ((dielectric * a1->q) * a2->q) * r0;
#line 9752
      r = (r * r) * r;
#line 9753
      k -= (a1->a * a2->a) * r;
#line 9754
      k += ((a1->b * a2->b) * r) * r;
#line 9755
      vx += k;
#line 9744
      ii ++;
    }
#line 9757
    *V += vx;
#line 9705
    i ++;
  }
#line 9759
  a_inactive_f_zero();
#line 9760
  free((void *)atomall);
#line 9760
  return (1);
}
}
#line 9762 "188.c"
int zone_nonbon(double *V , double lambda , ATOM *(*alist)[] , int inalist ) 
{ double r ;
  double r0 ;
  double xt ;
  double yt ;
  double zt ;
  double lcutoff ;
  double cutoff ;
  int i ;
  int ii ;
  ATOM *a1 ;
  ATOM *a2 ;
  double dielectric ;
  double ve ;
  double va ;
  double vh ;

  {
#line 9774
  if (inalist <= 0) {
#line 9774
    return (1);
  }
#line 9775
  dielectric = get_f_variable((char *)"dielec");
#line 9776
  if (dielectric < 1.) {
#line 9776
    dielectric = 1.;
  }
#line 9777
  dielectric = 332.17752 / dielectric;
#line 9778
  cutoff = get_f_variable((char *)"cutoff");
#line 9779
  if (cutoff < 1.) {
#line 9779
    cutoff = 1.e10;
  }
#line 9780
  lcutoff = - cutoff;
#line 9781
  ii = 0;
#line 9781
  while (ii < inalist) {
#line 9783
    a1 = (*alist)[ii];
#line 9784
    if ((unsigned int )a1 == (unsigned int )((void *)0)) {
      goto NOTANATOM;
    }
#line 9785
    ve = 0.;
#line 9785
    va = 0.;
#line 9785
    vh = 0.;
#line 9786
    a2 = a_next(-1);
#line 9787
    while (1) {
#line 9787
      if ((unsigned int )a2 != (unsigned int )((void *)0)) {
#line 9787
        if ((unsigned int )a2->next != (unsigned int )((void *)0)) {
#line 9787
          if (! ((unsigned int )a2->next != (unsigned int )a2)) {
#line 9787
            break;
          }
        } else {
#line 9787
          break;
        }
      } else {
#line 9787
        break;
      }
#line 9789
      if ((unsigned int )a2 == (unsigned int )a1) {
        goto SKIP;
      }
#line 9790
      i = 0;
#line 9790
      while (i < a1->dontuse) {
#line 9791
        if ((unsigned int )a2 == (unsigned int )a1->excluded[i]) {
          goto SKIP;
        }
#line 9790
        i ++;
      }
#line 9792
      xt = (a1->x - a2->x) + lambda * (a1->dx - a2->dx);
#line 9793
      if (xt > cutoff) {
        goto SKIP;
      } else {
#line 9793
        if (xt < lcutoff) {
          goto SKIP;
        }
      }
#line 9794
      yt = (a1->y - a2->y) + lambda * (a1->dy - a2->dy);
#line 9795
      if (yt > cutoff) {
        goto SKIP;
      } else {
#line 9795
        if (yt < lcutoff) {
          goto SKIP;
        }
      }
#line 9796
      zt = (a1->z - a2->z) + lambda * (a1->dz - a2->dz);
#line 9797
      if (zt > cutoff) {
        goto SKIP;
      } else {
#line 9797
        if (zt < lcutoff) {
          goto SKIP;
        }
      }
#line 9798
      r = (xt * xt + yt * yt) + zt * zt;
#line 9799
      if (r < 1.) {
#line 9799
        r = 1.;
      }
#line 9800
      r0 = sqrt(r);
#line 9800
      r = (r * r) * r;
#line 9801
      ve += ((dielectric * a1->q) * a2->q) / r0;
#line 9802
      va -= (a1->a * a2->a) / r;
#line 9803
      vh += ((a1->b * a2->b) / r) / r;
      SKIP: 
#line 9805
      if ((unsigned int )a2->next == (unsigned int )a2) {
#line 9805
        break;
      }
#line 9806
      a2 = (ATOM *)a2->next;
    }
#line 9808
    *V += (ve + va) + vh;
    NOTANATOM: 
#line 9810
    i = i;
#line 9781
    ii ++;
  }
#line 9812
  return (1);
}
}
