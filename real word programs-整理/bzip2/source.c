/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 213 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int size_t;
#line 14 "/usr/include/sys/lock.h"
typedef void *_LOCK_T;
#line 15 "/usr/include/sys/_types.h"
typedef long long _off64_t;
#line 18 "/usr/include/sys/_types.h"
typedef int _ssize_t;
#line 354 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int wint_t;
#line 27 "/usr/include/sys/_types.h"
union __anonunion___value_2 {
	wint_t __wch;
	unsigned char __wchb[4];
};
#line 27 "/usr/include/sys/_types.h"
struct __anonstruct__mbstate_t_1 {
	int __count;
	union __anonunion___value_2 __value;
};
#line 27 "/usr/include/sys/_types.h"
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
#line 37 "/usr/include/sys/_types.h"
typedef _LOCK_T _flock_t;
#line 19 "/usr/include/sys/reent.h"
typedef unsigned long __ULong;
#line 40 "/usr/include/sys/reent.h"
struct _Bigint {
	struct _Bigint *_next;
	int _k;
	int _maxwds;
	int _sign;
	int _wds;
	__ULong _x[1];
};
#line 48 "/usr/include/sys/reent.h"
struct __tm {
	int __tm_sec;
	int __tm_min;
	int __tm_hour;
	int __tm_mday;
	int __tm_mon;
	int __tm_year;
	int __tm_wday;
	int __tm_yday;
	int __tm_isdst;
};
#line 67 "/usr/include/sys/reent.h"
struct _on_exit_args {
	void *_fnargs[32];
	void *_dso_handle[32];
	__ULong _fntypes;
	__ULong _is_cxa;
};
#line 85 "/usr/include/sys/reent.h"
struct _atexit {
	struct _atexit *_next;
	int _ind;
	void(*_fns[32])(void);
	struct _on_exit_args _on_exit_args;
};
#line 101 "/usr/include/sys/reent.h"
struct __sbuf {
	unsigned char *_base;
	int _size;
};
#line 111 "/usr/include/sys/reent.h"
typedef long _fpos_t;
#line 115 "/usr/include/sys/reent.h"
typedef _off64_t _fpos64_t;
#line 166
struct _reent;
#line 214 "/usr/include/sys/reent.h"
struct __sFILE64 {
	unsigned char *_p;
	int _r;
	int _w;
	short _flags;
	short _file;
	struct __sbuf _bf;
	int _lbfsize;
	struct _reent *_data;
	void *_cookie;
	_ssize_t(__attribute__((__cdecl__)) (*_read))(void *_cookie, char *_buf, int _n);
	_ssize_t(__attribute__((__cdecl__)) (*_write))(void *_cookie, char const   *_buf,
		int _n);
	_fpos_t(__attribute__((__cdecl__)) (*_seek))(void *_cookie, _fpos_t _offset,
		int _whence);
	int (__attribute__((__cdecl__)) (*_close))(void *_cookie);
	struct __sbuf _ub;
	unsigned char *_up;
	int _ur;
	unsigned char _ubuf[3];
	unsigned char _nbuf[1];
	struct __sbuf _lb;
	int _blksize;
	int _flags2;
	_off64_t _offset;
	_fpos64_t(__attribute__((__cdecl__)) (*_seek64))(void *_cookie, _fpos64_t _offset,
		int _whence);
	_flock_t _lock;
};
#line 257 "/usr/include/sys/reent.h"
typedef struct __sFILE64 __FILE;
#line 262 "/usr/include/sys/reent.h"
struct _glue {
	struct _glue *_next;
	int _niobs;
	__FILE *_iobs;
};
#line 290 "/usr/include/sys/reent.h"
struct _rand48 {
	unsigned short _seed[3];
	unsigned short _mult[3];
	unsigned short _add;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__reent_4 {
	unsigned int _unused_rand;
	char *_strtok_last;
	char _asctime_buf[26];
	struct __tm _localtime_buf;
	int _gamma_signgam;
	unsigned long long _rand_next;
	struct _rand48 _r48;
	_mbstate_t _mblen_state;
	_mbstate_t _mbtowc_state;
	_mbstate_t _wctomb_state;
	char _l64a_buf[8];
	char _signal_buf[24];
	int _getdate_err;
	_mbstate_t _mbrlen_state;
	_mbstate_t _mbrtowc_state;
	_mbstate_t _mbsrtowcs_state;
	_mbstate_t _wcrtomb_state;
	_mbstate_t _wcsrtombs_state;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__unused_5 {
	unsigned char *_nextf[30];
	unsigned int _nmalloc[30];
};
#line 565 "/usr/include/sys/reent.h"
union __anonunion__new_3 {
	struct __anonstruct__reent_4 _reent;
	struct __anonstruct__unused_5 _unused;
};
#line 565 "/usr/include/sys/reent.h"
struct _reent {
	int _errno;
	__FILE *_stdin;
	__FILE *_stdout;
	__FILE *_stderr;
	int _inc;
	char _emergency[25];
	int _current_category;
	char const   *_current_locale;
	int __sdidinit;
	void (__attribute__((__cdecl__)) (*__cleanup))(struct _reent *);
	struct _Bigint *_result;
	int _result_k;
	struct _Bigint *_p5s;
	struct _Bigint **_freelist;
	int _cvtlen;
	char *_cvtbuf;
	union __anonunion__new_3 _new;
	struct _atexit *_atexit;
	struct _atexit _atexit0;
	void(**_sig_func)(int);
	struct _glue __sglue;
	__FILE __sf[3];
};
#line 50 "/usr/include/stdio.h"
typedef __FILE FILE;
#line 44 "/usr/include/cygwin/signal.h"
#pragma pack(push,4)
#line 101
#pragma pack(pop)
#line 38 "spec.c"
struct spec_fd_t {
	int limit;
	int len;
	int pos;
	unsigned char *buf;
};
#line 44 "/usr/include/cygwin/signal.h"
#pragma pack(push,4)
#line 101
#pragma pack(pop)
#line 1795 "bzip2.c"
struct __anonstruct_StackElem_21 {
	int ll;
	int hh;
	int dd;
};
#line 1795 "bzip2.c"
typedef struct __anonstruct_StackElem_21 StackElem;
#line 1 "spec.o"
#pragma merger(0,"./spec.i","")
#line 810 "/usr/include/sys/reent.h"
extern struct _reent *(__attribute__((__cdecl__)) __getreent)(void);
#line 177 "/usr/include/stdio.h"
extern int (__attribute__((__cdecl__)) fprintf)(FILE *, char const   *, ...);
#line 179
extern int (__attribute__((__cdecl__)) printf)(char const   *, ...);
#line 68 "/usr/include/stdlib.h"
extern int (__attribute__((__cdecl__)) atoi)(char const   *__nptr);
#line 79
extern  __attribute__((__noreturn__)) void (__attribute__((__cdecl__)) exit)(int __status);
#line 87
extern void *(__attribute__((__cdecl__)) malloc)(size_t __size);
#line 15 "/usr/include/sys/errno.h"
extern int *__errno(void);
#line 166 "/usr/include/sys/fcntl.h"
extern int open(char const   *, int, ...);
#line 24 "/usr/include/string.h"
extern void *(__attribute__((__cdecl__)) memcpy)(void *, void const   *, size_t);
#line 26
extern void *(__attribute__((__cdecl__)) memset)(void *, int, size_t);
#line 33
extern char *(__attribute__((__cdecl__)) strerror)(int);
#line 12 "spec.c"
unsigned char uncompressStream(int zStream, int stream);
#line 13
void compressStream(int stream, int zStream);
#line 14
void allocateCompressStructures(void);
#line 16
void spec_initbufs(void);
#line 17
void spec_compress(int in, int out, int lev);
#line 18
void spec_uncompress(int in, int out, int lev);
#line 19
int spec_init(void);
#line 20
int spec_random_load(int fd);
#line 21
int spec_load(int num, char *filename, int size);
#line 22
int spec_read(int fd, unsigned char *buf, int size);
#line 23
int spec_getc(int fd);
#line 24
int spec_ungetc(unsigned char ch, int fd);
#line 25
int spec_rewind(int fd);
#line 26
int spec_reset(int fd);
#line 27
int spec_write(int fd, unsigned char *buf, int size);
#line 28
int spec_putc(unsigned char ch, int fd);
#line 29
int debug_time(void);
#line 33 "spec.c"
int dbglvl = 4;
#line 34 "spec.c"
void debug(int level, int str)
{

	{
#line 34
		if (level < dbglvl) {
#line 34
			printf((char const   *)str);
		}
#line 34
		return;
	}
}
#line 35 "spec.c"
void debug1(int level, int str, int a)
{

	{
#line 35
		if (level < dbglvl) {
#line 35
			printf((char const   *)str, a);
		}
#line 35
		return;
	}
}
#line 36 "spec.c"
void debug2(int level, int str, int a, int b)
{

	{
#line 36
		if (level < dbglvl) {
#line 36
			printf((char const   *)str, a, b);
		}
#line 36
		return;
	}
}
#line 37 "spec.c"
void debug3(int level, int str, int a, int b, int c)
{

	{
#line 37
		if (level < dbglvl) {
#line 37
			printf((char const   *)str, a, b, c);
		}
#line 37
		return;
	}
}
#line 38 "spec.c"
struct spec_fd_t spec_fd[3];
#line 45 "spec.c"
long seedi;
#line 46 "spec.c"
double ran(void)
{
	long lo;
	long hi;
	long test;

	{
#line 52
		hi = seedi / 127773L;
#line 53
		lo = seedi % 127773L;
#line 54
		test = 16807L * lo - 2836L * hi;
#line 55
		if (test > 0L) {
#line 56
			seedi = test;
		}
		else {
#line 58
			seedi = test + 2147483647L;
		}
#line 60
		return ((double)((float)seedi / (float)2147483647));
	}
}
#line 64 "spec.c"
int spec_init(void)
{
	int i;
	int j;
	int limit___0;
	void *tmp;

	{
#line 68
		if (3 < dbglvl) {
#line 68
			printf("spec_init\n");
		}
#line 73
		i = 0;
#line 73
		while (i < 3) {
#line 74
			limit___0 = spec_fd[i].limit;
#line 75
			memset((void *)(&spec_fd[i]), 0, sizeof(spec_fd[0]));
#line 76
			spec_fd[i].limit = limit___0;
#line 77
			tmp = malloc((unsigned int)(limit___0 + 102400));
#line 77
			spec_fd[i].buf = (unsigned char *)tmp;
#line 78
			if ((unsigned int)spec_fd[i].buf == (unsigned int)((void *)0)) {
#line 79
				printf("spec_init: Error mallocing memory!\n");
#line 80
				exit(1);
			}
#line 82
			j = 0;
#line 82
			while (j < limit___0) {
#line 83
				* (spec_fd[i].buf + j) = (unsigned char)0;
#line 82
				j += 1024;
			}
#line 73
			i++;
		}
#line 86
		return (0);
	}
}
#line 89 "spec.c"
int spec_random_load(int fd)
{
	int i;
	int j;
	char random_text[32][131072];
	double tmp;
	double tmp___0;

	{
#line 99
		debug(4, (int)"Creating Chunks\n");
#line 102
		i = 0;
#line 102
		while (i < 32) {
#line 103
			debug1(5, (int)"Creating Chunk %d\n", i);
#line 104
			j = 0;
#line 104
			while (j < 131072) {
#line 105
				tmp = ran();
#line 105
				random_text[i][j] = (char)((int)(tmp * (double)256));
#line 104
				j++;
			}
#line 102
			i++;
		}
#line 109
		debug(4, (int)"Filling input file\n");
#line 111
		i = 0;
#line 111
		while (i < spec_fd[fd].limit) {
#line 112
			tmp___0 = ran();
#line 112
			memcpy((void *)(spec_fd[fd].buf + i), (void const   *)(random_text[(int)(tmp___0 * (double)32)]),
				131072U);
#line 111
			i += 131072;
		}
#line 116
		spec_fd[fd].len = 1048576;
#line 117
		return (0);
	}
}
#line 130
extern int( /* missing proto */  read)();
#line 138
extern int( /* missing proto */  close)();
#line 120 "spec.c"
int spec_load(int num, char *filename, int size)
{
	int fd;
	int rc;
	int i;
	int *tmp;
	char *tmp___0;
	struct _reent *tmp___1;
	int tmp___2;
	int *tmp___3;
	char *tmp___4;
	struct _reent *tmp___5;
	int tmp___6;

	{
#line 123
		fd = open((char const   *)filename, 65536);
#line 124
		if (fd < 0) {
#line 125
			tmp = __errno();
#line 125
			tmp___0 = strerror(*tmp);
#line 125
			tmp___1 = __getreent();
#line 125
			fprintf(tmp___1->_stderr, "Can\'t open file %s: %s\n", filename, tmp___0);
#line 126
			exit(1);
		}
#line 128
		tmp___2 = 0;
#line 128
		spec_fd[num].len = tmp___2;
#line 128
		spec_fd[num].pos = tmp___2;
#line 129
		i = 0;
#line 129
		while (i < size) {
#line 130
			rc = read(fd, spec_fd[num].buf + i, 131072);
#line 131
			if (rc == 0) {
#line 131
				break;
			}
#line 132
			if (rc < 0) {
#line 133
				tmp___3 = __errno();
#line 133
				tmp___4 = strerror(*tmp___3);
#line 133
				tmp___5 = __getreent();
#line 133
				fprintf(tmp___5->_stderr, "Error reading from %s: %s\n", filename, tmp___4);
#line 134
				exit(1);
			}
#line 136
			spec_fd[num].len += rc;
#line 129
			i += rc;
		}
#line 138
		close(fd);
#line 139
		while (spec_fd[num].len < size) {
#line 140
			tmp___6 = size - spec_fd[num].len;
#line 141
			if (tmp___6 > spec_fd[num].len) {
#line 141
				tmp___6 = spec_fd[num].len;
			}
#line 142
			debug1(3, (int)"Duplicating %d bytes\n", tmp___6);
#line 143
			memcpy((void *)(spec_fd[num].buf + spec_fd[num].len), (void const   *)spec_fd[num].buf,
				(unsigned int)tmp___6);
#line 144
			spec_fd[num].len += tmp___6;
		}
#line 146
		return (0);
	}
}
#line 149 "spec.c"
int spec_read(int fd, unsigned char *buf, int size)
{
	int rc;
	struct _reent *tmp;

	{
#line 150
		rc = 0;
#line 151
		debug3(4, (int)"spec_read: %d, %p, %d = ", fd, (int)((void *)buf), size);
#line 152
		if (fd > 3) {
#line 153
			tmp = __getreent();
#line 153
			fprintf(tmp->_stderr, "spec_read: fd=%d, > 3!\n", fd);
#line 154
			exit(1);
		}
#line 156
		if (spec_fd[fd].pos >= spec_fd[fd].len) {
#line 157
			debug(4, (int)"-1\n");
#line 158
			return (-1);
		}
#line 160
		if (spec_fd[fd].pos + size >= spec_fd[fd].len) {
#line 161
			rc = spec_fd[fd].len - spec_fd[fd].pos;
		}
		else {
#line 163
			rc = size;
		}
#line 165
		memcpy((void *)buf, (void const   *)(spec_fd[fd].buf + spec_fd[fd].pos), (unsigned int)rc);
#line 166
		spec_fd[fd].pos += rc;
#line 167
		debug1(4, (int)"%d\n", rc);
#line 168
		return (rc);
	}
}
#line 170 "spec.c"
int spec_getc(int fd)
{
	int rc;
	struct _reent *tmp;
	int tmp___0;

	{
#line 171
		rc = 0;
#line 172
		debug1(4, (int)"spec_getc: %d = ", fd);
#line 173
		if (fd > 3) {
#line 174
			tmp = __getreent();
#line 174
			fprintf(tmp->_stderr, "spec_read: fd=%d, > 3!\n", fd);
#line 175
			exit(1);
		}
#line 177
		if (spec_fd[fd].pos >= spec_fd[fd].len) {
#line 178
			debug(4, (int)"-1\n");
#line 179
			return (-1);
		}
#line 181
		tmp___0 = spec_fd[fd].pos;
#line 181
		(spec_fd[fd].pos)++;
#line 181
		rc = (int)*(spec_fd[fd].buf + tmp___0);
#line 182
		debug1(4, (int)"%d\n", rc);
#line 183
		return (rc);
	}
}
#line 185 "spec.c"
int spec_ungetc(unsigned char ch, int fd)
{
	int rc;
	struct _reent *tmp;
	struct _reent *tmp___0;
	struct _reent *tmp___1;

	{
#line 186
		rc = 0;
#line 187
		debug1(4, (int)"spec_ungetc: %d = ", fd);
#line 188
		if (fd > 3) {
#line 189
			tmp = __getreent();
#line 189
			fprintf(tmp->_stderr, "spec_read: fd=%d, > 3!\n", fd);
#line 190
			exit(1);
		}
#line 192
		if (spec_fd[fd].pos <= 0) {
#line 193
			tmp___0 = __getreent();
#line 193
			fprintf(tmp___0->_stderr, "spec_ungetc: pos %d <= 0\n", spec_fd[fd].pos);
#line 194
			exit(1);
		}
#line 197
		(spec_fd[fd].pos)--;
#line 197
		if ((int)*(spec_fd[fd].buf + spec_fd[fd].pos) != (int)ch) {
#line 198
			tmp___1 = __getreent();
#line 198
			fprintf(tmp___1->_stderr, "spec_ungetc: can\'t unget something that wasn\'t what was in the buffer!\n");
#line 199
			exit(1);
		}
#line 201
		debug1(4, (int)"%d\n", rc);
#line 202
		return ((int)ch);
	}
}
#line 204 "spec.c"
int spec_rewind(int fd)
{

	{
#line 205
		spec_fd[fd].pos = 0;
#line 206
		return (0);
	}
}
#line 208 "spec.c"
int spec_reset(int fd)
{
	int tmp;

	{
#line 209
		memset((void *)spec_fd[fd].buf, 0, (unsigned int)spec_fd[fd].len);
#line 210
		tmp = 0;
#line 210
		spec_fd[fd].len = tmp;
#line 210
		spec_fd[fd].pos = tmp;
#line 211
		return (0);
	}
}
#line 214 "spec.c"
int spec_write(int fd, unsigned char *buf, int size)
{
	struct _reent *tmp;

	{
#line 215
		debug3(4, (int)"spec_write: %d, %p, %d = ", fd, (int)((void *)buf), size);
#line 216
		if (fd > 3) {
#line 217
			tmp = __getreent();
#line 217
			fprintf(tmp->_stderr, "spec_write: fd=%d, > 3!\n", fd);
#line 218
			exit(1);
		}
#line 220
		memcpy((void *)(spec_fd[fd].buf + spec_fd[fd].pos), (void const   *)buf, (unsigned int)size);
#line 221
		spec_fd[fd].len += size;
#line 222
		spec_fd[fd].pos += size;
#line 223
		debug1(4, (int)"%d\n", size);
#line 224
		return (size);
	}
}
#line 226 "spec.c"
int spec_putc(unsigned char ch, int fd)
{
	struct _reent *tmp;
	int tmp___0;

	{
#line 227
		debug2(4, (int)"spec_putc: %d, %d = ", (int)ch, fd);
#line 228
		if (fd > 3) {
#line 229
			tmp = __getreent();
#line 229
			fprintf(tmp->_stderr, "spec_write: fd=%d, > 3!\n", fd);
#line 230
			exit(1);
		}
#line 232
		tmp___0 = spec_fd[fd].pos;
#line 232
		(spec_fd[fd].pos)++;
#line 232
		* (spec_fd[fd].buf + tmp___0) = ch;
#line 233
		(spec_fd[fd].len)++;
#line 234
		return ((int)ch);
	}
}
#line 238 "spec.c"
int temp_level = 0;
int temp_argc = 0;
unsigned char *temp_validate_array = 0;
int main(int argc, char **argv)
{
	temp_argc = argc;
	int i;
	int level;
	int input_size;
	int compressed_size;
	char *input_name;
	unsigned char *validate_array;
	void *tmp;

	{
#line 240
		input_size = 64;
#line 242
		input_name = (char *)"F:\\output.txt";
#line 244
		seedi = 10L;
#line 246
		if (argc > 1) {
#line 246
			input_name = *(argv + 1);
		}
#line 247
		if (argc > 2) {
#line 247
			input_size = atoi((char const   *)*(argv + 2));
		}
#line 248
		if (argc > 3) {
#line 249
			compressed_size = atoi((char const   *)*(argv + 3));
		}
		else {
#line 251
			compressed_size = input_size;
		}
#line 253
		spec_fd[0].limit = input_size * 1048576;
#line 254
		spec_fd[1].limit = compressed_size * 1048576;
#line 255
		spec_fd[2].limit = input_size * 1048576;
#line 256
		spec_init();
#line 258
		debug_time();
#line 259
		debug(2, (int)"Loading Input Data\n");
#line 260
		spec_load(0, input_name, input_size * 1048576);
#line 261
		debug1(3, (int)"Input data %d bytes in length\n", spec_fd[0].len);
#line 263
		tmp = malloc((unsigned int)((input_size * 1048576) / 1024));
#line 263
		temp_validate_array=validate_array = (unsigned char *)tmp;
#line 264
		if ((unsigned int)validate_array == (unsigned int)((void *)0)) {
#line 265
			printf("main: Error mallocing memory!\n");
#line 266
			exit(1);
		}
#line 269
		i = 0;
#line 269
		while (i * 1027 < input_size * 1048576) {
#line 270
			* (validate_array + i) = *(spec_fd[0].buf + i * 1027);
#line 269
			i++;
		}
#line 275
		spec_initbufs();
#line 277
		level = 7;
		temp_level = level;
#line 277
		while (level <= 9) {
#line 278
			debug_time();
#line 279
			debug1(2, (int)"Compressing Input Data, level %d\n", level);
#line 281
			spec_compress(0, 1, level);
#line 283
			debug_time();
#line 284
			debug1(3, (int)"Compressed data %d bytes in length\n", spec_fd[1].len);
#line 287
			spec_reset(0);
#line 288
			spec_rewind(1);
#line 290
			debug_time();
#line 291
			debug(2, (int)"Uncompressing Data\n");
#line 292
			spec_uncompress(1, 0, level);
#line 293
			debug_time();
#line 294
			debug1(3, (int)"Uncompressed data %d bytes in length\n", spec_fd[0].len);
#line 296
			i = 0;
#line 296
			while (i * 1027 < input_size * 1048576) {
#line 297
				if ((int)*(validate_array + i) != (int)*(spec_fd[0].buf + i * 1027)) {
#line 298
					printf("Tested %dMB buffer: Miscompared!!\n", input_size);
#line 299
					exit(1);
				}
#line 296
				i++;
			}
#line 302
			debug_time();
#line 303
			debug(3, (int)"Uncompressed data compared correctly\n");
#line 304
			spec_reset(1);
#line 305
			spec_rewind(0);
#line 277
			level += 2;
		}
#line 307
		printf("Tested %dMB buffer: OK!\n", input_size);
		temp_level = level;
#line 309
		return (0);
	}
}
#line 313
unsigned char smallMode;
#line 314
int verbosity;
#line 315
int bsStream;
#line 316
int workFactor;
#line 316
int blockSize100k;
#line 317 "spec.c"
void spec_initbufs(void)
{

	{
#line 318
		smallMode = (unsigned char)0;
#line 319
		verbosity = 0;
#line 320
		blockSize100k = 9;
#line 321
		bsStream = 0;
#line 322
		workFactor = 30;
#line 323
		allocateCompressStructures();
#line 324
		return;
	}
}
#line 325 "spec.c"
void spec_compress(int in, int out, int lev)
{

	{
#line 326
		blockSize100k = lev;
#line 327
		compressStream(in, out);
#line 328
		return;
	}
}
#line 329 "spec.c"
void spec_uncompress(int in, int out, int lev)
{

	{
#line 330
		blockSize100k = 0;
#line 331
		uncompressStream(in, out);
#line 332
		return;
	}
}
#line 335 "spec.c"
int debug_time(void)
{

	{
#line 336
		return (0);
	}
}
#line 1 "bzip2.o"
#pragma merger(0,"./bzip2.i","")
#line 172 "/usr/include/stdio.h"
extern int (__attribute__((__cdecl__)) fclose)(FILE *);
#line 214
extern void (__attribute__((__cdecl__)) perror)(char const   *);
#line 218
extern int (__attribute__((__cdecl__)) remove)(char const   *);
#line 80 "/usr/include/stdlib.h"
extern void (__attribute__((__cdecl__)) free)(void *);
#line 120 "bzip2.c"
void ioError(void);
#line 122
void panic(char *s);
#line 124
void compressOutOfMemory(int draw, int blockSize);
#line 125
void uncompressOutOfMemory(int draw, int blockSize);
#line 126
void blockOverrun(void);
#line 127
void badBlockHeader(void);
#line 128
void badBGLengths(void);
#line 129
void crcError(unsigned int crcStored, unsigned int crcComputed);
#line 130
void bitStreamEOF(void);
#line 131
void cleanUpAndFail(int ec);
#line 132
void compressedStreamEOF(void);
#line 136 "bzip2.c"
void ERROR_IF_EOF(int i)
{

	{
#line 136
		if (i == -1) {
#line 136
			ioError();
		}
#line 136
		return;
	}
}
#line 137 "bzip2.c"
void ERROR_IF_NOT_ZERO(int i)
{

	{
#line 137
		if (i != 0) {
#line 137
			ioError();
		}
#line 137
		return;
	}
}
#line 138 "bzip2.c"
void ERROR_IF_MINUS_ONE(int i)
{

	{
#line 138
		if (i == -1) {
#line 138
			ioError();
		}
#line 138
		return;
	}
}
#line 288 "bzip2.c"
unsigned int bytesIn;
#line 288 "bzip2.c"
unsigned int bytesOut;
#line 290 "bzip2.c"
int verbosity;
#line 292 "bzip2.c"
unsigned char keepInputFiles;
#line 292 "bzip2.c"
unsigned char smallMode;
#line 292 "bzip2.c"
unsigned char testFailsExist;
#line 293 "bzip2.c"
unsigned int globalCrc;
#line 294 "bzip2.c"
int numFileNames = 0;
#line 294 "bzip2.c"
int numFilesProcessed = 0;
#line 303 "bzip2.c"
int opMode;
#line 304 "bzip2.c"
int srcMode;
#line 307 "bzip2.c"
int longestFileName;
#line 308 "bzip2.c"
char inName[1024];
#line 309 "bzip2.c"
char outName[1024];
#line 310 "bzip2.c"
char *progName;
#line 311 "bzip2.c"
char progNameReally[1024];
#line 312 "bzip2.c"
int outputHandleJustInCase;
#line 314 "bzip2.c"
int syf;
#line 316 "bzip2.c"
int yk_j = 0;
#line 352 "bzip2.c"
unsigned char *block;
#line 353 "bzip2.c"
unsigned int *quadrant;
#line 354 "bzip2.c"
int *zptr;
#line 355 "bzip2.c"
unsigned int *szptr;
#line 356 "bzip2.c"
int *ftab;
#line 358 "bzip2.c"
unsigned int *ll16;
#line 359 "bzip2.c"
unsigned char *ll4;
#line 361 "bzip2.c"
int *tt;
#line 362 "bzip2.c"
unsigned char *ll8;
#line 369 "bzip2.c"
int unzftab[256];
#line 376 "bzip2.c"
int last;
#line 382 "bzip2.c"
int origPtr;
#line 390 "bzip2.c"
int blockSize100k;
#line 401 "bzip2.c"
int workFactor;
#line 403 "bzip2.c"
int workDone;
#line 404 "bzip2.c"
int workLimit;
#line 405 "bzip2.c"
unsigned char blockRandomised;
#line 406 "bzip2.c"
unsigned char firstAttempt;
#line 407 "bzip2.c"
int nBlocksRandomised;
#line 421 "bzip2.c"
unsigned char inUse[256];
#line 422 "bzip2.c"
int nInUse;
#line 424 "bzip2.c"
unsigned char seqToUnseq[256];
#line 425 "bzip2.c"
unsigned char unseqToSeq[256];
#line 427 "bzip2.c"
unsigned char selector[18002];
#line 428 "bzip2.c"
unsigned char selectorMtf[18002];
#line 430 "bzip2.c"
int nMTF;
#line 432 "bzip2.c"
int mtfFreq[258];
#line 434 "bzip2.c"
unsigned char len[6][258];
#line 437 "bzip2.c"
int limit[6][258];
#line 438 "bzip2.c"
int base[6][258];
#line 439 "bzip2.c"
int perm[6][258];
#line 440 "bzip2.c"
int minLens[6];
#line 443 "bzip2.c"
int code[6][258];
#line 444 "bzip2.c"
int rfreq[6][258];
#line 458 "bzip2.c"
unsigned int crc32Table[256] =
#line 458
{ 0U, 79764919U, 159529838U, 222504665U,
319059676U, 398814059U, 445009330U, 507990021U,
638119352U, 583659535U, 797628118U, 726387553U,
890018660U, 835552979U, 1015980042U, 944750013U,
1276238704U, 1221641927U, 1167319070U, 1095957929U,
1595256236U, 1540665371U, 1452775106U, 1381403509U,
1780037320U, 1859660671U, 1671105958U, 1733955601U,
2031960084U, 2111593891U, 1889500026U, 1952343757U,
2552477408U, 2632100695U, 2443283854U, 2506133561U,
2334638140U, 2414271883U, 2191915858U, 2254759653U,
3190512472U, 3135915759U, 3081330742U, 3009969537U,
2905550212U, 2850959411U, 2762807018U, 2691435357U,
3560074640U, 3505614887U, 3719321342U, 3648080713U,
3342211916U, 3287746299U, 3467911202U, 3396681109U,
4063920168U, 4143685023U, 4223187782U, 4286162673U,
3779000052U, 3858754371U, 3904687514U, 3967668269U,
881225847U, 809987520U, 1023691545U, 969234094U,
662832811U, 591600412U, 771767749U, 717299826U,
311336399U, 374308984U, 453813921U, 533576470U,
25881363U, 88864420U, 134795389U, 214552010U,
2023205639U, 2086057648U, 1897238633U, 1976864222U,
1804852699U, 1867694188U, 1645340341U, 1724971778U,
1587496639U, 1516133128U, 1461550545U, 1406951526U,
1302016099U, 1230646740U, 1142491917U, 1087903418U,
2896545431U, 2825181984U, 2770861561U, 2716262478U,
3215044683U, 3143675388U, 3055782693U, 3001194130U,
2326604591U, 2389456536U, 2200899649U, 2280525302U,
2578013683U, 2640855108U, 2418763421U, 2498394922U,
3769900519U, 3832873040U, 3912640137U, 3992402750U,
4088425275U, 4151408268U, 4197601365U, 4277358050U,
3334271071U, 3263032808U, 3476998961U, 3422541446U,
3585640067U, 3514407732U, 3694837229U, 3640369242U,
1762451694U, 1842216281U, 1619975040U, 1682949687U,
2047383090U, 2127137669U, 1938468188U, 2001449195U,
1325665622U, 1271206113U, 1183200824U, 1111960463U,
1543535498U, 1489069629U, 1434599652U, 1363369299U,
622672798U, 568075817U, 748617968U, 677256519U,
907627842U, 853037301U, 1067152940U, 995781531U,
51762726U, 131386257U, 177728840U, 240578815U,
269590778U, 349224269U, 429104020U, 491947555U,
4046411278U, 4126034873U, 4172115296U, 4234965207U,
3794477266U, 3874110821U, 3953728444U, 4016571915U,
3609705398U, 3555108353U, 3735388376U, 3664026991U,
3290680682U, 3236090077U, 3449943556U, 3378572211U,
3174993278U, 3120533705U, 3032266256U, 2961025959U,
2923101090U, 2868635157U, 2813903052U, 2742672763U,
2604032198U, 2683796849U, 2461293480U, 2524268063U,
2284983834U, 2364738477U, 2175806836U, 2238787779U,
1569362073U, 1498123566U, 1409854455U, 1355396672U,
1317987909U, 1246755826U, 1192025387U, 1137557660U,
2072149281U, 2135122070U, 1912620623U, 1992383480U,
1753615357U, 1816598090U, 1627664531U, 1707420964U,
295390185U, 358241886U, 404320391U, 483945776U,
43990325U, 106832002U, 186451547U, 266083308U,
932423249U, 861060070U, 1041341759U, 986742920U,
613929101U, 542559546U, 756411363U, 701822548U,
3316196985U, 3244833742U, 3425377559U, 3370778784U,
3601682597U, 3530312978U, 3744426955U, 3689838204U,
3819031489U, 3881883254U, 3928223919U, 4007849240U,
4037393693U, 4100235434U, 4180117107U, 4259748804U,
2310601993U, 2373574846U, 2151335527U, 2231098320U,
2596047829U, 2659030626U, 2470359227U, 2550115596U,
2947551409U, 2876312838U, 2788305887U, 2733848168U,
3165939309U, 3094707162U, 3040238851U, 2985771188U };
#line 530 "bzip2.c"
void initialiseCRC(void)
{

	{
#line 532
		globalCrc = 4294967295U;
#line 533
		return;
	}
}
#line 537 "bzip2.c"
unsigned int getFinalCRC(void)
{

	{
#line 539
		return (~globalCrc);
	}
}
#line 544 "bzip2.c"
unsigned int getGlobalCRC(void)
{

	{
#line 546
		return (globalCrc);
	}
}
#line 551 "bzip2.c"
void setGlobalCRC(unsigned int newCrc)
{

	{
#line 553
		globalCrc = newCrc;
#line 554
		return;
	}
}
#line 564 "bzip2.c"
unsigned int bsBuff;
#line 565 "bzip2.c"
int bsLive;
#line 566 "bzip2.c"
int bsStream;
#line 568 "bzip2.c"
unsigned char bsWriting;
#line 572 "bzip2.c"
void bsSetStream(int f, unsigned char wr)
{

	{
#line 574
		bsStream = f;
#line 575
		bsLive = 0;
#line 576
		bsBuff = 0U;
#line 577
		bytesOut = 0U;
#line 578
		bytesIn = 0U;
#line 579
		bsWriting = wr;
#line 580
		return;
	}
}
#line 584 "bzip2.c"
void bsFinishedWithStream(void)
{

	{
#line 586
		if (bsWriting) {
#line 587
			while (bsLive > 0) {
#line 588
				spec_putc((unsigned char)(bsBuff >> 24), bsStream);
#line 589
				bsBuff <<= 8;
#line 590
				bsLive -= 8;
#line 591
				bytesOut++;
			}
		}
#line 594
		bsStream = 0;
#line 596
		return;
	}
}
#line 606 "bzip2.c"
unsigned int bsR(int n)
{
	unsigned int v;
	int zzi;
	int tmp;

	{
#line 609
		while (bsLive < n) {
#line 611
			tmp = spec_getc(bsStream);
#line 611
			zzi = tmp;
#line 612
			if (zzi == -1) {
#line 612
				compressedStreamEOF();
			}
#line 613
			bsBuff = (bsBuff << 8) | (unsigned int)(zzi & 255);
#line 614
			bsLive += 8;
		}
#line 616
		v = (bsBuff >> (bsLive - n)) & (unsigned int)((1 << n) - 1);
#line 617
		bsLive -= n;
#line 618
		return (v);
	}
}
#line 623 "bzip2.c"
void bsW(int n, unsigned int v)
{

	{
#line 625
		while (bsLive >= 8) {
#line 626
			spec_putc((unsigned char)(bsBuff >> 24), bsStream);
#line 628
			bsBuff <<= 8;
#line 629
			bsLive -= 8;
#line 630
			bytesOut++;
		}
#line 632
		bsBuff |= v << ((32 - bsLive) - n);
#line 633
		bsLive += n;
#line 634
		return;
	}
}
#line 638 "bzip2.c"
unsigned char bsGetUChar(void)
{
	unsigned int tmp;

	{
#line 640
		tmp = bsR(8);
#line 640
		return ((unsigned char)tmp);
	}
}
#line 645 "bzip2.c"
void bsPutUChar(unsigned char c)
{

	{
#line 647
		bsW(8, (unsigned int)c);
#line 648
		return;
	}
}
#line 652 "bzip2.c"
int bsGetUInt32(void)
{
	unsigned int u;
	unsigned int tmp;
	unsigned int tmp___0;
	unsigned int tmp___1;
	unsigned int tmp___2;

	{
#line 655
		u = 0U;
#line 656
		tmp = bsR(8);
#line 656
		u = (u << 8) | tmp;
#line 657
		tmp___0 = bsR(8);
#line 657
		u = (u << 8) | tmp___0;
#line 658
		tmp___1 = bsR(8);
#line 658
		u = (u << 8) | tmp___1;
#line 659
		tmp___2 = bsR(8);
#line 659
		u = (u << 8) | tmp___2;
#line 660
		return ((int)u);
	}
}
#line 665 "bzip2.c"
unsigned int bsGetIntVS(unsigned int numBits)
{
	unsigned int tmp;

	{
#line 667
		tmp = bsR((int)numBits);
#line 667
		return (tmp);
	}
}
#line 672 "bzip2.c"
unsigned int bsGetInt32(void)
{
	int tmp;

	{
#line 674
		tmp = bsGetUInt32();
#line 674
		return ((unsigned int)tmp);
	}
}
#line 679 "bzip2.c"
void bsPutUInt32(unsigned int u)
{

	{
#line 681
		bsW(8, (u >> 24) & 255U);
#line 682
		bsW(8, (u >> 16) & 255U);
#line 683
		bsW(8, (u >> 8) & 255U);
#line 684
		bsW(8, u & 255U);
#line 685
		return;
	}
}
#line 689 "bzip2.c"
void bsPutInt32(int c)
{

	{
#line 691
		bsPutUInt32((unsigned int)c);
#line 692
		return;
	}
}
#line 696 "bzip2.c"
void bsPutIntVS(int numBits, unsigned int c)
{

	{
#line 698
		bsW(numBits, c);
#line 699
		return;
	}
}
#line 711 "bzip2.c"
void hbMakeCodeLengths(unsigned char *len___0, int *freq, int alphaSize, int maxLen)
{
	int nNodes;
	int nHeap;
	int n1;
	int n2;
	int i;
	int j;
	int k;
	unsigned char tooLong;
	int heap[260];
	int weight[516];
	int parent[516];
	int tmp;
	int zz;
	int tmp___0;
	int zz___0;
	int yy;
	int tmp___1;
	int tmp___2;
	int tmp___3;

	{
#line 727
		i = 0;
#line 727
		while (i < alphaSize) {
#line 728
			if (*(freq + i) == 0) {
#line 728
				tmp = 1;
			}
			else {
#line 728
				tmp = *(freq + i);
			}
#line 728
			weight[i + 1] = tmp << 8;
#line 727
			i++;
		}
#line 730
		while (1) {
#line 732
			nNodes = alphaSize;
#line 733
			nHeap = 0;
#line 735
			heap[0] = 0;
#line 736
			weight[0] = 0;
#line 737
			parent[0] = -2;
#line 739
			i = 1;
#line 739
			while (i <= alphaSize) {
#line 740
				parent[i] = -1;
#line 741
				nHeap++;
#line 742
				heap[nHeap] = i;
#line 746
				zz = nHeap;
#line 746
				tmp___0 = heap[zz];
#line 747
				while (weight[tmp___0] < weight[heap[zz >> 1]]) {
#line 748
					heap[zz] = heap[zz >> 1];
#line 749
					zz >>= 1;
				}
#line 751
				heap[zz] = tmp___0;
#line 739
				i++;
			}
#line 753
			if (!(nHeap < 260)) {
#line 754
				panic((char *)"hbMakeCodeLengths(1)");
			}
#line 756
			while (nHeap > 1) {
#line 757
				n1 = heap[1];
#line 757
				heap[1] = heap[nHeap];
#line 757
				nHeap--;
#line 761
				zz___0 = 1;
#line 761
				tmp___1 = heap[zz___0];
#line 762
				while (1) {
#line 763
					yy = zz___0 << 1;
#line 764
					if (yy > nHeap) {
#line 764
						break;
					}
#line 765
					if (yy < nHeap) {
#line 765
						if (weight[heap[yy + 1]] < weight[heap[yy]]) {
#line 767
							yy++;
						}
					}
#line 768
					if (weight[tmp___1] < weight[heap[yy]]) {
#line 768
						break;
					}
#line 769
					heap[zz___0] = heap[yy];
#line 770
					zz___0 = yy;
				}
#line 772
				heap[zz___0] = tmp___1;
#line 773
				n2 = heap[1];
#line 773
				heap[1] = heap[nHeap];
#line 773
				nHeap--;
#line 777
				zz___0 = 1;
#line 777
				tmp___1 = heap[zz___0];
#line 778
				while (1) {
#line 779
					yy = zz___0 << 1;
#line 780
					if (yy > nHeap) {
#line 780
						break;
					}
#line 781
					if (yy < nHeap) {
#line 781
						if (weight[heap[yy + 1]] < weight[heap[yy]]) {
#line 783
							yy++;
						}
					}
#line 784
					if (weight[tmp___1] < weight[heap[yy]]) {
#line 784
						break;
					}
#line 785
					heap[zz___0] = heap[yy];
#line 786
					zz___0 = yy;
				}
#line 788
				heap[zz___0] = tmp___1;
#line 791
				nNodes++;
#line 792
				tmp___2 = nNodes;
#line 792
				parent[n2] = tmp___2;
#line 792
				parent[n1] = tmp___2;
#line 794
				if (1 + (weight[n1] & 255) > (weight[n2] & 255)) {
#line 794
					tmp___3 = weight[n1] & 255;
				}
				else {
#line 794
					tmp___3 = weight[n2] & 255;
				}
#line 794
				weight[nNodes] = (int)((((unsigned int)weight[n1] & 4294967040U) + ((unsigned int)weight[n2] & 4294967040U)) | (unsigned int)tmp___3);
#line 797
				parent[nNodes] = -1;
#line 798
				nHeap++;
#line 799
				heap[nHeap] = nNodes;
#line 803
				zz___0 = nHeap;
#line 803
				tmp___1 = heap[zz___0];
#line 804
				while (weight[tmp___1] < weight[heap[zz___0 >> 1]]) {
#line 805
					heap[zz___0] = heap[zz___0 >> 1];
#line 806
					zz___0 >>= 1;
				}
#line 808
				heap[zz___0] = tmp___1;
			}
#line 810
			if (!(nNodes < 516)) {
#line 811
				panic((char *)"hbMakeCodeLengths(2)");
			}
#line 813
			tooLong = (unsigned char)0;
#line 814
			i = 1;
#line 814
			while (i <= alphaSize) {
#line 815
				j = 0;
#line 816
				k = i;
#line 817
				while (parent[k] >= 0) {
#line 817
					k = parent[k];
#line 817
					j++;
				}
#line 818
				* (len___0 + (i - 1)) = (unsigned char)j;
#line 819
				if (j > maxLen) {
#line 819
					tooLong = (unsigned char)1;
				}
#line 814
				i++;
			}
#line 822
			if (!tooLong) {
#line 822
				break;
			}
#line 824
			i = 1;
#line 824
			while (i < alphaSize) {
#line 825
				j = weight[i] >> 8;
#line 826
				j = 1 + j / 2;
#line 827
				weight[i] = j << 8;
#line 824
				i++;
			}
		}
#line 830
		return;
	}
}
#line 834 "bzip2.c"
void hbAssignCodes(int *code___0, unsigned char *length, int minLen, int maxLen,
	int alphaSize)
{
	int n;
	int vec;
	int i;

	{
#line 842
		vec = 0;
#line 843
		n = minLen;
#line 843
		while (n <= maxLen) {
#line 844
			i = 0;
#line 844
			while (i < alphaSize) {
#line 845
				if ((int)*(length + i) == n) {
#line 845
					* (code___0 + i) = vec;
#line 845
					vec++;
				}
#line 844
				i++;
			}
#line 846
			vec <<= 1;
#line 843
			n++;
		}
#line 848
		return;
	}
}
#line 852 "bzip2.c"
void hbCreateDecodeTables(int *limit___0, int *base___0, int *perm___0, unsigned char *length,
	int minLen, int maxLen, int alphaSize)
{
	int pp;
	int i;
	int j;
	int vec;

	{
#line 862
		pp = 0;
#line 863
		i = minLen;
#line 863
		while (i <= maxLen) {
#line 864
			j = 0;
#line 864
			while (j < alphaSize) {
#line 865
				if ((int)*(length + j) == i) {
#line 865
					* (perm___0 + pp) = j;
#line 865
					pp++;
				}
#line 864
				j++;
			}
#line 863
			i++;
		}
#line 867
		i = 0;
#line 867
		while (i < 23) {
#line 867
			* (base___0 + i) = 0;
#line 867
			i++;
		}
#line 868
		i = 0;
#line 868
		while (i < alphaSize) {
#line 868
			(*(base___0 + ((int)*(length + i) + 1)))++;
#line 868
			i++;
		}
#line 870
		i = 1;
#line 870
		while (i < 23) {
#line 870
			* (base___0 + i) += *(base___0 + (i - 1));
#line 870
			i++;
		}
#line 872
		i = 0;
#line 872
		while (i < 23) {
#line 872
			* (limit___0 + i) = 0;
#line 872
			i++;
		}
#line 873
		vec = 0;
#line 875
		i = minLen;
#line 875
		while (i <= maxLen) {
#line 876
			vec += *(base___0 + (i + 1)) - *(base___0 + i);
#line 877
			* (limit___0 + i) = vec - 1;
#line 878
			vec <<= 1;
#line 875
			i++;
		}
#line 880
		i = minLen + 1;
#line 880
		while (i <= maxLen) {
#line 881
			* (base___0 + i) = ((*(limit___0 + (i - 1)) + 1) << 1) - *(base___0 + i);
#line 880
			i++;
		}
#line 882
		return;
	}
}
#line 891 "bzip2.c"
void SET_LL4(int i, int n)
{

	{
#line 892
		if ((i & 1) == 0) {
#line 893
			* (ll4 + (i >> 1)) = (unsigned char)(((int)*(ll4 + (i >> 1)) & 240) | n);
		}
		else {
#line 895
			* (ll4 + (i >> 1)) = (unsigned char)(((int)*(ll4 + (i >> 1)) & 15) | (n << 4));
		}
#line 896
		return;
	}
}
#line 917 "bzip2.c"
void allocateCompressStructures(void)
{
	int n;
	void *tmp;
	void *tmp___0;
	void *tmp___1;
	void *tmp___2;
	int totalDraw;

	{
#line 919
		n = 100000 * blockSize100k;
#line 920
		tmp = malloc((unsigned int)((n + 1) + 20) * sizeof(unsigned char));
#line 920
		block = (unsigned char *)tmp;
#line 921
		tmp___0 = malloc((unsigned int)((n + 20) * 16));
#line 921
		quadrant = (unsigned int *)tmp___0;
#line 922
		tmp___1 = malloc((unsigned int)n * sizeof(int));
#line 922
		zptr = (int *)tmp___1;
#line 923
		tmp___2 = malloc(65537U * sizeof(int));
#line 923
		ftab = (int *)tmp___2;
#line 925
		if ((unsigned int)block == (unsigned int)((void *)0)) {
#line 927
			totalDraw = (int)((((unsigned int)((n + 1) + 20) * sizeof(unsigned char) + (unsigned int)((n + 20) * 16)) + (unsigned int)n * sizeof(int)) + 65537U * sizeof(int));
#line 933
			compressOutOfMemory(totalDraw, n);
		}
		else {
#line 925
			if ((unsigned int)quadrant == (unsigned int)((void *)0)) {
#line 927
				totalDraw = (int)((((unsigned int)((n + 1) + 20) * sizeof(unsigned char) + (unsigned int)((n + 20) * 16)) + (unsigned int)n * sizeof(int)) + 65537U * sizeof(int));
#line 933
				compressOutOfMemory(totalDraw, n);
			}
			else {
#line 925
				if ((unsigned int)zptr == (unsigned int)((void *)0)) {
#line 927
					totalDraw = (int)((((unsigned int)((n + 1) + 20) * sizeof(unsigned char) + (unsigned int)((n + 20) * 16)) + (unsigned int)n * sizeof(int)) + 65537U * sizeof(int));
#line 933
					compressOutOfMemory(totalDraw, n);
				}
				else {
#line 925
					if ((unsigned int)ftab == (unsigned int)((void *)0)) {
#line 927
						totalDraw = (int)((((unsigned int)((n + 1) + 20) * sizeof(unsigned char) + (unsigned int)((n + 20) * 16)) + (unsigned int)n * sizeof(int)) + 65537U * sizeof(int));
#line 933
						compressOutOfMemory(totalDraw, n);
					}
				}
			}
		}
#line 941
		block++;
#line 953
		szptr = (unsigned int *)zptr;
#line 954
		return;
	}
}
#line 958 "bzip2.c"
void setDecompressStructureSizes(int newSize100k)
{
	int n;
	void *tmp;
	void *tmp___0;
	int totalDraw;
	int n___0;
	void *tmp___1;
	void *tmp___2;
	int totalDraw___0;

	{
#line 960
		if (0 <= newSize100k) {
#line 960
			if (newSize100k <= 9) {
#line 960
				if (0 <= blockSize100k) {
#line 960
					if (!(blockSize100k <= 9)) {
#line 962
						panic((char *)"setDecompressStructureSizes");
					}
				}
				else {
#line 962
					panic((char *)"setDecompressStructureSizes");
				}
			}
			else {
#line 962
				panic((char *)"setDecompressStructureSizes");
			}
		}
		else {
#line 962
			panic((char *)"setDecompressStructureSizes");
		}
#line 964
		if (newSize100k == blockSize100k) {
#line 964
			return;
		}
#line 966
		blockSize100k = newSize100k;
#line 968
		if ((unsigned int)ll16 != (unsigned int)((void *)0)) {
#line 968
			free((void *)ll16);
		}
#line 969
		if ((unsigned int)ll4 != (unsigned int)((void *)0)) {
#line 969
			free((void *)ll4);
		}
#line 970
		if ((unsigned int)ll8 != (unsigned int)((void *)0)) {
#line 970
			free((void *)ll8);
		}
#line 971
		if ((unsigned int)tt != (unsigned int)((void *)0)) {
#line 971
			free((void *)tt);
		}
#line 973
		if (newSize100k == 0) {
#line 973
			return;
		}
#line 975
		if (smallMode) {
#line 977
			n = 100000 * newSize100k;
#line 978
			tmp = malloc((unsigned int)n * sizeof(unsigned int));
#line 978
			ll16 = (unsigned int *)tmp;
#line 979
			tmp___0 = malloc((unsigned int)((n + 1) >> 1) * sizeof(unsigned char));
#line 979
			ll4 = (unsigned char *)tmp___0;
#line 981
			if ((unsigned int)ll4 == (unsigned int)((void *)0)) {
#line 982
				totalDraw = (int)((unsigned int)(n * 16) + (unsigned int)((n + 1) >> 1) * sizeof(unsigned char));
#line 984
				uncompressOutOfMemory(totalDraw, n);
			}
			else {
#line 981
				if ((unsigned int)ll16 == (unsigned int)((void *)0)) {
#line 982
					totalDraw = (int)((unsigned int)(n * 16) + (unsigned int)((n + 1) >> 1) * sizeof(unsigned char));
#line 984
					uncompressOutOfMemory(totalDraw, n);
				}
			}
		}
		else {
#line 989
			n___0 = 100000 * newSize100k;
#line 990
			tmp___1 = malloc((unsigned int)n___0 * sizeof(unsigned char));
#line 990
			ll8 = (unsigned char *)tmp___1;
#line 991
			tmp___2 = malloc((unsigned int)n___0 * sizeof(int));
#line 991
			tt = (int *)tmp___2;
#line 993
			if ((unsigned int)ll8 == (unsigned int)((void *)0)) {
#line 994
				totalDraw___0 = (int)((unsigned int)n___0 * sizeof(unsigned char) + (unsigned int)n___0 * sizeof(unsigned int));
#line 996
				uncompressOutOfMemory(totalDraw___0, n___0);
			}
			else {
#line 993
				if ((unsigned int)tt == (unsigned int)((void *)0)) {
#line 994
					totalDraw___0 = (int)((unsigned int)n___0 * sizeof(unsigned char) + (unsigned int)n___0 * sizeof(unsigned int));
#line 996
					uncompressOutOfMemory(totalDraw___0, n___0);
				}
			}
		}
#line 1000
		return;
	}
}
#line 1009 "bzip2.c"
void makeMaps(void)
{
	int i;

	{
#line 1012
		nInUse = 0;
#line 1013
		i = 0;
#line 1013
		while (i < 256) {
#line 1014
			if (inUse[i]) {
#line 1015
				seqToUnseq[nInUse] = (unsigned char)i;
#line 1016
				unseqToSeq[i] = (unsigned char)nInUse;
#line 1017
				nInUse++;
			}
#line 1013
			i++;
		}
#line 1019
		return;
	}
}
#line 1023 "bzip2.c"
void generateMTFValues(void)
{
	unsigned char yy[256];
	int i;
	int j;
	unsigned char tmp;
	unsigned char tmp2;
	int zPend;
	int wr;
	int EOB;
	unsigned char ll_i;

	{
#line 1033
		makeMaps();
#line 1034
		EOB = nInUse + 1;
#line 1036
		i = 0;
#line 1036
		while (i <= EOB) {
#line 1036
			mtfFreq[i] = 0;
#line 1036
			i++;
		}
#line 1038
		wr = 0;
#line 1039
		zPend = 0;
#line 1040
		i = 0;
#line 1040
		while (i < nInUse) {
#line 1040
			yy[i] = (unsigned char)i;
#line 1040
			i++;
		}
#line 1043
		i = 0;
#line 1043
		while (i <= last) {
#line 1048
			ll_i = unseqToSeq[*(block + (*(zptr + i) - 1))];
#line 1050
			j = 0;
#line 1051
			tmp = yy[j];
#line 1052
			while ((int)ll_i != (int)tmp) {
#line 1053
				j++;
#line 1054
				tmp2 = tmp;
#line 1055
				tmp = yy[j];
#line 1056
				yy[j] = tmp2;
			}
#line 1058
			yy[0] = tmp;
#line 1060
			if (j == 0) {
#line 1061
				zPend++;
			}
			else {
#line 1063
				if (zPend > 0) {
#line 1064
					zPend--;
#line 1065
					while (1) {
#line 1066
						switch (zPend % 2) {
						case 0:
#line 1067
							* (szptr + wr) = 0U;
#line 1067
							wr++;
#line 1067
							(mtfFreq[0])++;
#line 1067
							break;
						case 1:
#line 1068
							* (szptr + wr) = 1U;
#line 1068
							wr++;
#line 1068
							(mtfFreq[1])++;
#line 1068
							break;
						}
#line 1070
						if (zPend < 2) {
#line 1070
							break;
						}
#line 1071
						zPend = (zPend - 2) / 2;
					}
#line 1073
					zPend = 0;
				}
#line 1075
				* (szptr + wr) = (unsigned int)(j + 1);
#line 1075
				wr++;
#line 1075
				(mtfFreq[j + 1])++;
			}
#line 1043
			i++;
		}
#line 1079
		if (zPend > 0) {
#line 1080
			zPend--;
#line 1081
			while (1) {
#line 1082
				switch (zPend % 2) {
				case 0:
#line 1083
					* (szptr + wr) = 0U;
#line 1083
					wr++;
#line 1083
					(mtfFreq[0])++;
#line 1083
					break;
				case 1:
#line 1084
					* (szptr + wr) = 1U;
#line 1084
					wr++;
#line 1084
					(mtfFreq[1])++;
#line 1084
					break;
				}
#line 1086
				if (zPend < 2) {
#line 1086
					break;
				}
#line 1087
				zPend = (zPend - 2) / 2;
			}
		}
#line 1091
		* (szptr + wr) = (unsigned int)EOB;
#line 1091
		wr++;
#line 1091
		(mtfFreq[EOB])++;
#line 1093
		nMTF = wr;
#line 1094
		return;
	}
}
#line 1098 "bzip2.c"
void sendMTFValues(void)
{
	int v;
	int t;
	int i;
	int j;
	int gs;
	int ge;
	int totc;
	int bt;
	int bc;
	int iter;
	int nSelectors;
	int alphaSize;
	int minLen;
	int maxLen;
	int selCtr;
	int nGroups;
	int nBytes;
	unsigned int cost[6];
	int fave[6];
	struct _reent *tmp;
	int nPart;
	int remF;
	int tFreq;
	int aFreq;
	struct _reent *tmp___0;
	unsigned int cost0;
	unsigned int cost1;
	unsigned int cost2;
	unsigned int cost3;
	unsigned int cost4;
	unsigned int cost5;
	unsigned int icv;
	unsigned int icv___0;
	struct _reent *tmp___1;
	struct _reent *tmp___2;
	struct _reent *tmp___3;
	unsigned char pos[6];
	unsigned char ll_i;
	unsigned char tmp2;
	unsigned char tmp___4;
	unsigned char inUse16[16];
	struct _reent *tmp___5;
	struct _reent *tmp___6;
	int curr;
	struct _reent *tmp___7;
	struct _reent *tmp___8;

	{
#line 1118
		if (verbosity >= 3) {
#line 1119
			tmp = __getreent();
#line 1119
			fprintf(tmp->_stderr, "      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\n",
				last + 1, nMTF, nInUse);
		}
#line 1123
		alphaSize = nInUse + 2;
#line 1124
		t = 0;
#line 1124
		while (t < 6) {
#line 1125
			v = 0;
#line 1125
			while (v < alphaSize) {
#line 1126
				len[t][v] = (unsigned char)15;
#line 1125
				v++;
			}
#line 1124
			t++;
		}
#line 1129
		if (nMTF <= 0) {
#line 1129
			panic((char *)"sendMTFValues(0)");
		}
#line 1130
		if (nMTF < 200) {
#line 1130
			nGroups = 2;
		}
		else {
#line 1131
			if (nMTF < 800) {
#line 1131
				nGroups = 4;
			}
			else {
#line 1132
				nGroups = 6;
			}
		}
#line 1138
		nPart = nGroups;
#line 1139
		remF = nMTF;
#line 1140
		gs = 0;
#line 1141
		while (nPart > 0) {
#line 1142
			tFreq = remF / nPart;
#line 1143
			ge = gs - 1;
#line 1144
			aFreq = 0;
#line 1145
			while (1) {
#line 1145
				if (aFreq < tFreq) {
#line 1145
					if (!(ge < alphaSize - 1)) {
#line 1145
						break;
					}
				}
				else {
#line 1145
					break;
				}
#line 1146
				ge++;
#line 1147
				aFreq += mtfFreq[ge];
			}
#line 1150
			if (ge > gs) {
#line 1150
				if (nPart != nGroups) {
#line 1150
					if (nPart != 1) {
#line 1150
						if ((nGroups - nPart) % 2 == 1) {
#line 1153
							aFreq -= mtfFreq[ge];
#line 1154
							ge--;
						}
					}
				}
			}
#line 1157
			if (verbosity >= 3) {
#line 1158
				tmp___0 = __getreent();
#line 1158
				fprintf(tmp___0->_stderr, "      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\n",
					nPart, gs, ge, aFreq, (100.0 * (double)((float)aFreq)) / (double)((float)nMTF));
			}
#line 1163
			v = 0;
#line 1163
			while (v < alphaSize) {
#line 1164
				if (v >= gs) {
#line 1164
					if (v <= ge) {
#line 1165
						len[nPart - 1][v] = (unsigned char)0;
					}
					else {
#line 1166
						len[nPart - 1][v] = (unsigned char)15;
					}
				}
				else {
#line 1166
					len[nPart - 1][v] = (unsigned char)15;
				}
#line 1163
				v++;
			}
#line 1168
			nPart--;
#line 1169
			gs = ge + 1;
#line 1170
			remF -= aFreq;
		}
#line 1177
		iter = 0;
#line 1177
		while (iter < 4) {
#line 1179
			t = 0;
#line 1179
			while (t < nGroups) {
#line 1179
				fave[t] = 0;
#line 1179
				t++;
			}
#line 1181
			t = 0;
#line 1181
			while (t < nGroups) {
#line 1182
				v = 0;
#line 1182
				while (v < alphaSize) {
#line 1183
					rfreq[t][v] = 0;
#line 1182
					v++;
				}
#line 1181
				t++;
			}
#line 1185
			nSelectors = 0;
#line 1186
			totc = 0;
#line 1187
			gs = 0;
#line 1188
			while (!(gs >= nMTF)) {
#line 1192
				ge = (gs + 50) - 1;
#line 1193
				if (ge >= nMTF) {
#line 1193
					ge = nMTF - 1;
				}
#line 1199
				t = 0;
#line 1199
				while (t < nGroups) {
#line 1199
					cost[t] = 0U;
#line 1199
					t++;
				}
#line 1201
				if (nGroups == 6) {
#line 1203
					cost5 = 0U;
#line 1203
					cost4 = cost5;
#line 1203
					cost3 = cost4;
#line 1203
					cost2 = cost3;
#line 1203
					cost1 = cost2;
#line 1203
					cost0 = cost1;
#line 1204
					i = gs;
#line 1204
					while (i <= ge) {
#line 1205
						icv = *(szptr + i);
#line 1206
						cost0 += (unsigned int)len[0][icv];
#line 1207
						cost1 += (unsigned int)len[1][icv];
#line 1208
						cost2 += (unsigned int)len[2][icv];
#line 1209
						cost3 += (unsigned int)len[3][icv];
#line 1210
						cost4 += (unsigned int)len[4][icv];
#line 1211
						cost5 += (unsigned int)len[5][icv];
#line 1204
						i++;
					}
#line 1213
					cost[0] = cost0;
#line 1213
					cost[1] = cost1;
#line 1213
					cost[2] = cost2;
#line 1214
					cost[3] = cost3;
#line 1214
					cost[4] = cost4;
#line 1214
					cost[5] = cost5;
				}
				else {
#line 1216
					i = gs;
#line 1216
					while (i <= ge) {
#line 1217
						icv___0 = *(szptr + i);
#line 1218
						t = 0;
#line 1218
						while (t < nGroups) {
#line 1218
							cost[t] += (unsigned int)len[t][icv___0];
#line 1218
							t++;
						}
#line 1216
						i++;
					}
				}
#line 1226
				bc = 999999999;
#line 1226
				bt = -1;
#line 1227
				t = 0;
#line 1227
				while (t < nGroups) {
#line 1228
					if (cost[t] < (unsigned int)bc) {
#line 1228
						bc = (int)cost[t];
#line 1228
						bt = t;
					}
#line 1227
					t++;
				}
#line 1229
				totc += bc;
#line 1230
				(fave[bt])++;
#line 1231
				selector[nSelectors] = (unsigned char)bt;
#line 1232
				nSelectors++;
#line 1237
				i = gs;
#line 1237
				while (i <= ge) {
#line 1238
					(rfreq[bt][*(szptr + i)])++;
#line 1237
					i++;
				}
#line 1240
				gs = ge + 1;
			}
#line 1242
			if (verbosity >= 3) {
#line 1243
				tmp___1 = __getreent();
#line 1243
				fprintf(tmp___1->_stderr, "      pass %d: size is %d, grp uses are ", iter + 1,
					totc / 8);
#line 1246
				t = 0;
#line 1246
				while (t < nGroups) {
#line 1247
					tmp___2 = __getreent();
#line 1247
					fprintf(tmp___2->_stderr, "%d ", fave[t]);
#line 1246
					t++;
				}
#line 1248
				tmp___3 = __getreent();
#line 1248
				fprintf(tmp___3->_stderr, "\n");
			}
#line 1254
			t = 0;
#line 1254
			while (t < nGroups) {
#line 1255
				hbMakeCodeLengths(&len[t][0], &rfreq[t][0], alphaSize, 20);
#line 1254
				t++;
			}
#line 1177
			iter++;
		}
#line 1259
		if (!(nGroups < 8)) {
#line 1259
			panic((char *)"sendMTFValues(1)");
		}
#line 1260
		if (nSelectors < 32768) {
#line 1260
			if (!(nSelectors <= 18002)) {
#line 1262
				panic((char *)"sendMTFValues(2)");
			}
		}
		else {
#line 1262
			panic((char *)"sendMTFValues(2)");
		}
#line 1268
		i = 0;
#line 1268
		while (i < nGroups) {
#line 1268
			pos[i] = (unsigned char)i;
#line 1268
			i++;
		}
#line 1269
		i = 0;
#line 1269
		while (i < nSelectors) {
#line 1270
			ll_i = selector[i];
#line 1271
			j = 0;
#line 1272
			tmp___4 = pos[j];
#line 1273
			while ((int)ll_i != (int)tmp___4) {
#line 1274
				j++;
#line 1275
				tmp2 = tmp___4;
#line 1276
				tmp___4 = pos[j];
#line 1277
				pos[j] = tmp2;
			}
#line 1279
			pos[0] = tmp___4;
#line 1280
			selectorMtf[i] = (unsigned char)j;
#line 1269
			i++;
		}
#line 1285
		t = 0;
#line 1285
		while (t < nGroups) {
#line 1286
			minLen = 32;
#line 1287
			maxLen = 0;
#line 1288
			i = 0;
#line 1288
			while (i < alphaSize) {
#line 1289
				if ((int)len[t][i] > maxLen) {
#line 1289
					maxLen = (int)len[t][i];
				}
#line 1290
				if ((int)len[t][i] < minLen) {
#line 1290
					minLen = (int)len[t][i];
				}
#line 1288
				i++;
			}
#line 1292
			if (maxLen > 20) {
#line 1292
				panic((char *)"sendMTFValues(3)");
			}
#line 1293
			if (minLen < 1) {
#line 1293
				panic((char *)"sendMTFValues(4)");
			}
#line 1294
			hbAssignCodes(&code[t][0], &len[t][0], minLen, maxLen, alphaSize);
#line 1285
			t++;
		}
#line 1301
		i = 0;
#line 1301
		while (i < 16) {
#line 1302
			inUse16[i] = (unsigned char)0;
#line 1303
			j = 0;
#line 1303
			while (j < 16) {
#line 1304
				if (inUse[i * 16 + j]) {
#line 1304
					inUse16[i] = (unsigned char)1;
				}
#line 1303
				j++;
			}
#line 1301
			i++;
		}
#line 1307
		nBytes = (int)bytesOut;
#line 1308
		i = 0;
#line 1308
		while (i < 16) {
#line 1309
			if (inUse16[i]) {
#line 1309
				bsW(1, 1U);
			}
			else {
#line 1309
				bsW(1, 0U);
			}
#line 1308
			i++;
		}
#line 1311
		i = 0;
#line 1311
		while (i < 16) {
#line 1312
			if (inUse16[i]) {
#line 1313
				j = 0;
#line 1313
				while (j < 16) {
#line 1314
					if (inUse[i * 16 + j]) {
#line 1315
						bsW(1, 1U);
					}
					else {
#line 1317
						bsW(1, 0U);
					}
#line 1313
					j++;
				}
			}
#line 1311
			i++;
		}
#line 1322
		if (verbosity >= 3) {
#line 1323
			tmp___5 = __getreent();
#line 1323
			fprintf(tmp___5->_stderr, "      bytes: mapping %d, ", bytesOut - (unsigned int)nBytes);
		}
#line 1327
		nBytes = (int)bytesOut;
#line 1328
		bsW(3, (unsigned int)nGroups);
#line 1329
		bsW(15, (unsigned int)nSelectors);
#line 1330
		i = 0;
#line 1330
		while (i < nSelectors) {
#line 1331
			j = 0;
#line 1331
			while (j < (int)selectorMtf[i]) {
#line 1331
				bsW(1, 1U);
#line 1331
				j++;
			}
#line 1332
			bsW(1, 0U);
#line 1330
			i++;
		}
#line 1334
		if (verbosity >= 3) {
#line 1335
			tmp___6 = __getreent();
#line 1335
			fprintf(tmp___6->_stderr, "selectors %d, ", bytesOut - (unsigned int)nBytes);
		}
#line 1338
		nBytes = (int)bytesOut;
#line 1340
		t = 0;
#line 1340
		while (t < nGroups) {
#line 1341
			curr = (int)len[t][0];
#line 1342
			bsW(5, (unsigned int)curr);
#line 1343
			i = 0;
#line 1343
			while (i < alphaSize) {
#line 1344
				while (curr < (int)len[t][i]) {
#line 1344
					bsW(2, 2U);
#line 1344
					curr++;
				}
#line 1345
				while (curr >(int)len[t][i]) {
#line 1345
					bsW(2, 3U);
#line 1345
					curr--;
				}
#line 1346
				bsW(1, 0U);
#line 1343
				i++;
			}
#line 1340
			t++;
		}
#line 1350
		if (verbosity >= 3) {
#line 1351
			tmp___7 = __getreent();
#line 1351
			fprintf(tmp___7->_stderr, "code lengths %d, ", bytesOut - (unsigned int)nBytes);
		}
#line 1354
		nBytes = (int)bytesOut;
#line 1355
		selCtr = 0;
#line 1356
		gs = 0;
#line 1357
		while (!(gs >= nMTF)) {
#line 1359
			ge = (gs + 50) - 1;
#line 1360
			if (ge >= nMTF) {
#line 1360
				ge = nMTF - 1;
			}
#line 1361
			i = gs;
#line 1361
			while (i <= ge) {
#line 1362
				bsW((int)len[selector[selCtr]][*(szptr + i)], (unsigned int)code[selector[selCtr]][*(szptr + i)]);
#line 1361
				i++;
			}
#line 1366
			gs = ge + 1;
#line 1367
			selCtr++;
		}
#line 1369
		if (!(selCtr == nSelectors)) {
#line 1369
			panic((char *)"sendMTFValues(5)");
		}
#line 1371
		if (verbosity >= 3) {
#line 1372
			tmp___8 = __getreent();
#line 1372
			fprintf(tmp___8->_stderr, "codes %d\n", bytesOut - (unsigned int)nBytes);
		}
#line 1373
		return;
	}
}
#line 1377 "bzip2.c"
void moveToFrontCodeAndSend(void)
{

	{
#line 1379
		bsPutIntVS(24, (unsigned int)origPtr);
#line 1380
		generateMTFValues();
#line 1381
		sendMTFValues();
#line 1382
		return;
	}
}
#line 1386 "bzip2.c"
void recvDecodingTables(void)
{
	int i;
	int j;
	int t;
	int nGroups;
	int nSelectors;
	int alphaSize;
	int minLen;
	int maxLen;
	unsigned char inUse16[16];
	unsigned int tmp;
	unsigned int tmp___0;
	unsigned int tmp___1;
	unsigned int tmp___2;
	unsigned int tmp___3;
	unsigned char pos[6];
	unsigned char tmp___4;
	unsigned char v;
	int curr;
	unsigned int tmp___5;
	unsigned int tmp___6;
	unsigned int tmp___7;

	{
#line 1393
		i = 0;
#line 1393
		while (i < 16) {
#line 1394
			tmp = bsR(1);
#line 1394
			if (tmp == 1U) {
#line 1395
				inUse16[i] = (unsigned char)1;
			}
			else {
#line 1396
				inUse16[i] = (unsigned char)0;
			}
#line 1393
			i++;
		}
#line 1398
		i = 0;
#line 1398
		while (i < 256) {
#line 1398
			inUse[i] = (unsigned char)0;
#line 1398
			i++;
		}
#line 1400
		i = 0;
#line 1400
		while (i < 16) {
#line 1401
			if (inUse16[i]) {
#line 1402
				j = 0;
#line 1402
				while (j < 16) {
#line 1403
					tmp___0 = bsR(1);
#line 1403
					if (tmp___0 == 1U) {
#line 1403
						inUse[i * 16 + j] = (unsigned char)1;
					}
#line 1402
					j++;
				}
			}
#line 1400
			i++;
		}
#line 1405
		makeMaps();
#line 1406
		alphaSize = nInUse + 2;
#line 1409
		tmp___1 = bsR(3);
#line 1409
		nGroups = (int)tmp___1;
#line 1410
		tmp___2 = bsR(15);
#line 1410
		nSelectors = (int)tmp___2;
#line 1411
		i = 0;
#line 1411
		while (i < nSelectors) {
#line 1412
			j = 0;
#line 1413
			while (1) {
#line 1413
				tmp___3 = bsR(1);
#line 1413
				if (!(tmp___3 == 1U)) {
#line 1413
					break;
				}
#line 1413
				j++;
			}
#line 1414
			selectorMtf[i] = (unsigned char)j;
#line 1411
			i++;
		}
#line 1420
		v = (unsigned char)0;
#line 1420
		while ((int)v < nGroups) {
#line 1420
			pos[v] = v;
#line 1420
			v = (unsigned char)((int)v + 1);
		}
#line 1422
		i = 0;
#line 1422
		while (i < nSelectors) {
#line 1423
			v = selectorMtf[i];
#line 1424
			tmp___4 = pos[v];
#line 1425
			while ((int)v > 0) {
#line 1425
				pos[v] = pos[(int)v - 1];
#line 1425
				v = (unsigned char)((int)v - 1);
			}
#line 1426
			pos[0] = tmp___4;
#line 1427
			selector[i] = tmp___4;
#line 1422
			i++;
		}
#line 1432
		t = 0;
#line 1432
		while (t < nGroups) {
#line 1433
			tmp___5 = bsR(5);
#line 1433
			curr = (int)tmp___5;
#line 1434
			i = 0;
#line 1434
			while (i < alphaSize) {
#line 1435
				while (1) {
#line 1435
					tmp___7 = bsR(1);
#line 1435
					if (!(tmp___7 == 1U)) {
#line 1435
						break;
					}
#line 1436
					tmp___6 = bsR(1);
#line 1436
					if (tmp___6 == 0U) {
#line 1436
						curr++;
					}
					else {
#line 1436
						curr--;
					}
				}
#line 1438
				len[t][i] = (unsigned char)curr;
#line 1434
				i++;
			}
#line 1432
			t++;
		}
#line 1443
		t = 0;
#line 1443
		while (t < nGroups) {
#line 1444
			minLen = 32;
#line 1445
			maxLen = 0;
#line 1446
			i = 0;
#line 1446
			while (i < alphaSize) {
#line 1447
				if ((int)len[t][i] > maxLen) {
#line 1447
					maxLen = (int)len[t][i];
				}
#line 1448
				if ((int)len[t][i] < minLen) {
#line 1448
					minLen = (int)len[t][i];
				}
#line 1446
				i++;
			}
#line 1450
			hbCreateDecodeTables(&limit[t][0], &base[t][0], &perm[t][0], &len[t][0], minLen,
				maxLen, alphaSize);
#line 1454
			minLens[t] = minLen;
#line 1443
			t++;
		}
#line 1456
		return;
	}
}
#line 1462 "bzip2.c"
void getAndMoveToFrontDecode(void)
{
	unsigned char yy[256];
	int i;
	int j;
	int nextSym;
	int limitLast;
	int EOB;
	int groupNo;
	int groupPos;
	unsigned int tmp;
	int zt;
	int zn;
	int zvec;
	int zj;
	unsigned int tmp___0;
	int zzi;
	int tmp___1;
	unsigned char ch;
	int s;
	int N;
	int zt___0;
	int zn___0;
	int zvec___0;
	int zj___0;
	unsigned int tmp___2;
	int zzi___0;
	int tmp___3;
	unsigned char tmp___4;
	int zt___1;
	int zn___1;
	int zvec___1;
	int zj___1;
	unsigned int tmp___5;
	int zzi___1;
	int tmp___6;

	{
#line 1468
		limitLast = 100000 * blockSize100k;
#line 1469
		tmp = bsGetIntVS(24U);
#line 1469
		origPtr = (int)tmp;
#line 1471
		recvDecodingTables();
#line 1472
		EOB = nInUse + 1;
#line 1473
		groupNo = -1;
#line 1474
		groupPos = 0;
#line 1482
		i = 0;
#line 1482
		while (i <= 255) {
#line 1482
			unzftab[i] = 0;
#line 1482
			i++;
		}
#line 1484
		i = 0;
#line 1484
		while (i <= 255) {
#line 1484
			yy[i] = (unsigned char)i;
#line 1484
			i++;
		}
#line 1486
		last = -1;
#line 1491
		if (groupPos == 0) {
#line 1492
			groupNo++;
#line 1493
			groupPos = 50;
		}
#line 1495
		groupPos--;
#line 1496
		zt = (int)selector[groupNo];
#line 1497
		zn = minLens[zt];
#line 1498
		tmp___0 = bsR(zn);
#line 1498
		zvec = (int)tmp___0;
#line 1499
		while (zvec > limit[zt][zn]) {
#line 1500
			zn++;
#line 1501
			while (bsLive < 1) {
#line 1502
				tmp___1 = spec_getc(bsStream);
#line 1502
				zzi = tmp___1;
#line 1503
				if (zzi == -1) {
#line 1503
					compressedStreamEOF();
				}
#line 1504
				bsBuff = (bsBuff << 8) | (unsigned int)(zzi & 255);
#line 1505
				bsLive += 8;
			}
#line 1507
			zj = (int)((bsBuff >> (bsLive - 1)) & 1U);
#line 1508
			bsLive--;
#line 1508
			zvec = (zvec << 1) | zj;
		}
#line 1511
		nextSym = perm[zt][zvec - base[zt][zn]];
#line 1513
		while (!(nextSym == EOB)) {
#line 1517
			if (nextSym == 0) {
				goto _L;
			}
			else {
#line 1517
				if (nextSym == 1) {
				_L: /* CIL Label */
#line 1519
					s = -1;
#line 1520
					N = 1;
#line 1521
					while (1) {
#line 1522
						if (nextSym == 0) {
#line 1522
							s += N;
						}
						else {
#line 1523
							if (nextSym == 1) {
#line 1523
								s += 2 * N;
							}
						}
#line 1524
						N *= 2;
#line 1526
						if (groupPos == 0) {
#line 1527
							groupNo++;
#line 1528
							groupPos = 50;
						}
#line 1530
						groupPos--;
#line 1531
						zt___0 = (int)selector[groupNo];
#line 1532
						zn___0 = minLens[zt___0];
#line 1533
						tmp___2 = bsR(zn___0);
#line 1533
						zvec___0 = (int)tmp___2;
#line 1534
						while (zvec___0 > limit[zt___0][zn___0]) {
#line 1535
							zn___0++;
#line 1536
							while (bsLive < 1) {
#line 1537
								tmp___3 = spec_getc(bsStream);
#line 1537
								zzi___0 = tmp___3;
#line 1538
								if (zzi___0 == -1) {
#line 1538
									compressedStreamEOF();
								}
#line 1539
								bsBuff = (bsBuff << 8) | (unsigned int)(zzi___0 & 255);
#line 1540
								bsLive += 8;
							}
#line 1542
							zj___0 = (int)((bsBuff >> (bsLive - 1)) & 1U);
#line 1543
							bsLive--;
#line 1543
							zvec___0 = (zvec___0 << 1) | zj___0;
						}
#line 1546
						nextSym = perm[zt___0][zvec___0 - base[zt___0][zn___0]];
#line 1521
						if (!(nextSym == 0)) {
#line 1521
							if (!(nextSym == 1)) {
#line 1521
								break;
							}
						}
					}
#line 1550
					s++;
#line 1551
					ch = seqToUnseq[yy[0]];
#line 1552
					unzftab[ch] += s;
#line 1554
					if (smallMode) {
#line 1555
						while (s > 0) {
#line 1556
							last++;
#line 1557
							* (ll16 + last) = (unsigned int)ch;
#line 1558
							s--;
						}
					}
					else {
#line 1561
						while (s > 0) {
#line 1562
							last++;
#line 1563
							* (ll8 + last) = ch;
#line 1564
							s--;
						}
					}
#line 1567
					if (last >= limitLast) {
#line 1567
						blockOverrun();
					}
#line 1568
					continue;
				}
				else {
#line 1573
					last++;
#line 1573
					if (last >= limitLast) {
#line 1573
						blockOverrun();
					}
#line 1575
					tmp___4 = yy[nextSym - 1];
#line 1576
					(unzftab[seqToUnseq[tmp___4]])++;
#line 1577
					if (smallMode) {
#line 1578
						* (ll16 + last) = (unsigned int)seqToUnseq[tmp___4];
					}
					else {
#line 1579
						* (ll8 + last) = seqToUnseq[tmp___4];
					}
#line 1588
					j = nextSym - 1;
#line 1589
					while (j > 3) {
#line 1590
						yy[j] = yy[j - 1];
#line 1591
						yy[j - 1] = yy[j - 2];
#line 1592
						yy[j - 2] = yy[j - 3];
#line 1593
						yy[j - 3] = yy[j - 4];
#line 1589
						j -= 4;
					}
#line 1595
					while (j > 0) {
#line 1595
						yy[j] = yy[j - 1];
#line 1595
						j--;
					}
#line 1597
					yy[0] = tmp___4;
#line 1599
					if (groupPos == 0) {
#line 1600
						groupNo++;
#line 1601
						groupPos = 50;
					}
#line 1603
					groupPos--;
#line 1604
					zt___1 = (int)selector[groupNo];
#line 1605
					zn___1 = minLens[zt___1];
#line 1606
					tmp___5 = bsR(zn___1);
#line 1606
					zvec___1 = (int)tmp___5;
#line 1607
					while (zvec___1 > limit[zt___1][zn___1]) {
#line 1608
						zn___1++;
#line 1609
						while (bsLive < 1) {
#line 1610
							tmp___6 = spec_getc(bsStream);
#line 1610
							zzi___1 = tmp___6;
#line 1611
							if (zzi___1 == -1) {
#line 1611
								compressedStreamEOF();
							}
#line 1612
							bsBuff = (bsBuff << 8) | (unsigned int)(zzi___1 & 255);
#line 1613
							bsLive += 8;
						}
#line 1615
						zj___1 = (int)((bsBuff >> (bsLive - 1)) & 1U);
#line 1616
						bsLive--;
#line 1616
						zvec___1 = (zvec___1 << 1) | zj___1;
					}
#line 1619
					nextSym = perm[zt___1][zvec___1 - base[zt___1][zn___1]];
#line 1620
					continue;
				}
			}
		}
#line 1623
		return;
	}
}
#line 1640 "bzip2.c"
unsigned char fullGtU(int i1, int i2)
{
	int k;
	int i;
	unsigned char c1;
	unsigned char c2;
	unsigned int s1;
	unsigned int s2;

	{
#line 1646
		i = 0;
#line 1648
		while (i < 6) {
#line 1650
			c1 = *(block + i1);
#line 1651
			c2 = *(block + i2);
#line 1652
			if ((int)c1 != (int)c2) {
#line 1652
				return ((unsigned char)((int)c1 >(int)c2));
			}
#line 1653
			i1++;
#line 1653
			i2++;
#line 1653
			i++;
		}
#line 1656
		k = last + 1;
#line 1658
		while (1) {
#line 1659
			i = 0;
#line 1660
			while (i < 4) {
#line 1662
				c1 = *(block + i1);
#line 1663
				c2 = *(block + i2);
#line 1664
				if ((int)c1 != (int)c2) {
#line 1664
					return ((unsigned char)((int)c1 >(int)c2));
				}
#line 1665
				s1 = *(quadrant + i1);
#line 1666
				s2 = *(quadrant + i2);
#line 1667
				if (s1 != s2) {
#line 1667
					return ((unsigned char)(s1 > s2));
				}
#line 1668
				i1++;
#line 1668
				i2++;
#line 1668
				i++;
			}
#line 1671
			if (i1 > last) {
#line 1671
				i1 -= last;
#line 1671
				i1--;
			}
#line 1672
			if (i2 > last) {
#line 1672
				i2 -= last;
#line 1672
				i2--;
			}
#line 1674
			k -= 4;
#line 1675
			workDone++;
#line 1658
			if (!(k >= 0)) {
#line 1658
				break;
			}
		}
#line 1679
		return ((unsigned char)0);
	}
}
#line 1689 "bzip2.c"
int incs[14] =
#line 1689
{ 1, 4, 13, 40,
121, 364, 1093, 3280,
9841, 29524, 88573, 265720,
797161, 2391484 };
#line 1693 "bzip2.c"
void simpleSort(int lo, int hi, int d)
{
	int i;
	int j;
	int h;
	int bigN;
	int hp;
	int v;
	struct _reent *tmp;
	unsigned char tmp___0;
	unsigned char tmp___1;
	unsigned char tmp___2;

	{
#line 1698
		bigN = (hi - lo) + 1;
#line 1699
		if (bigN < 2) {
#line 1699
			return;
		}
#line 1702
		hp = 0;
#line 1703
		while (incs[hp] < bigN) {
#line 1703
			hp++;
		}
#line 1704
		hp--;
#line 1706
		while (hp >= 0) {
#line 1707
			h = incs[hp];
#line 1708
			if (verbosity >= 5) {
#line 1709
				tmp = __getreent();
#line 1709
				fprintf(tmp->_stderr, "          shell increment %d\n", h);
			}
#line 1711
			i = lo + h;
#line 1712
			while (!(i > hi)) {
#line 1716
				v = *(zptr + i);
#line 1717
				j = i;
#line 1721
				while (1) {
#line 1721
					tmp___0 = fullGtU(*(zptr + (j - h)) + d, v + d);
#line 1721
					if (!tmp___0) {
#line 1721
						break;
					}
#line 1722
					* (zptr + j) = *(zptr + (j - h));
#line 1723
					j -= h;
#line 1724
					if (j <= (lo + h) - 1) {
#line 1724
						break;
					}
				}
#line 1726
				* (zptr + j) = v;
#line 1727
				i++;
#line 1730
				if (i > hi) {
#line 1730
					break;
				}
#line 1731
				v = *(zptr + i);
#line 1732
				j = i;
#line 1735
				while (1) {
#line 1735
					tmp___1 = fullGtU(*(zptr + (j - h)) + d, v + d);
#line 1735
					if (!tmp___1) {
#line 1735
						break;
					}
#line 1736
					* (zptr + j) = *(zptr + (j - h));
#line 1737
					j -= h;
#line 1738
					if (j <= (lo + h) - 1) {
#line 1738
						break;
					}
				}
#line 1740
				* (zptr + j) = v;
#line 1741
				i++;
#line 1744
				if (i > hi) {
#line 1744
					break;
				}
#line 1745
				v = *(zptr + i);
#line 1746
				j = i;
#line 1749
				while (1) {
#line 1749
					tmp___2 = fullGtU(*(zptr + (j - h)) + d, v + d);
#line 1749
					if (!tmp___2) {
#line 1749
						break;
					}
#line 1750
					* (zptr + j) = *(zptr + (j - h));
#line 1751
					j -= h;
#line 1752
					if (j <= (lo + h) - 1) {
#line 1752
						break;
					}
				}
#line 1754
				* (zptr + j) = v;
#line 1755
				i++;
#line 1757
				if (workDone > workLimit) {
#line 1757
					if (firstAttempt) {
#line 1757
						return;
					}
				}
			}
#line 1706
			hp--;
		}
#line 1760
		return;
	}
}
#line 1773 "bzip2.c"
void vswap(int p1, int p2, int n)
{
	int tmp;

	{
#line 1775
		while (n > 0) {
#line 1776
			tmp = *(zptr + p1);
#line 1776
			* (zptr + p1) = *(zptr + p2);
#line 1776
			* (zptr + p2) = tmp;
#line 1779
			p1++;
#line 1779
			p2++;
#line 1779
			n--;
		}
#line 1781
		return;
	}
}
#line 1783 "bzip2.c"
unsigned char med3(unsigned char a, unsigned char b, unsigned char c)
{
	unsigned char t;

	{
#line 1786
		if ((int)a > (int)b) {
#line 1786
			t = a;
#line 1786
			a = b;
#line 1786
			b = t;
		}
#line 1787
		if ((int)b > (int)c) {
#line 1787
			t = b;
#line 1787
			b = c;
#line 1787
			c = t;
		}
#line 1788
		if ((int)a > (int)b) {
#line 1788
			b = a;
		}
#line 1789
		return (b);
	}
}
#line 1814 "bzip2.c"
void qSort3(int loSt, int hiSt, int dSt)
{
	int unLo;
	int unHi;
	int ltLo;
	int gtHi;
	int med;
	int n;
	int m;
	int sp;
	int lo;
	int hi;
	int d;
	StackElem stack[1000];
	unsigned char tmp;
	int tmp___0;
	int tmp___1;
	int tmp___2;

	{
#line 1820
		sp = 0;
#line 1823
		stack[sp].ll = loSt;
#line 1824
		stack[sp].hh = hiSt;
#line 1825
		stack[sp].dd = dSt;
#line 1826
		sp++;
#line 1828
		while (sp > 0) {
#line 1830
			if (sp >= 1000) {
#line 1830
				panic((char *)"stack overflow in qSort3");
			}
#line 1833
			sp--;
#line 1834
			lo = stack[sp].ll;
#line 1835
			hi = stack[sp].hh;
#line 1836
			d = stack[sp].dd;
#line 1838
			if (hi - lo < 20) {
				goto _L;
			}
			else {
#line 1838
				if (d > 10) {
				_L: /* CIL Label */
#line 1840
					if (syf == 255) {
#line 1840
						yk_j++;
					}
#line 1842
					simpleSort(lo, hi, d);
#line 1843
					if (workDone > workLimit) {
#line 1843
						if (firstAttempt) {
#line 1843
							return;
						}
					}
#line 1844
					continue;
				}
			}
#line 1847
			tmp = med3(*(block + (*(zptr + lo) + d)), *(block + (*(zptr + hi) + d)), *(block + (*(zptr + ((lo + hi) >> 1)) + d)));
#line 1847
			med = (int)tmp;
#line 1851
			ltLo = lo;
#line 1851
			unLo = ltLo;
#line 1852
			gtHi = hi;
#line 1852
			unHi = gtHi;
#line 1857
			while (1) {
#line 1858
				while (!(unLo > unHi)) {
#line 1860
					n = (int)*(block + (*(zptr + unLo) + d)) - med;
#line 1861
					if (n == 0) {
#line 1862
						tmp___0 = *(zptr + unLo);
#line 1862
						* (zptr + unLo) = *(zptr + ltLo);
#line 1862
						* (zptr + ltLo) = tmp___0;
#line 1863
						ltLo++;
#line 1863
						unLo++;
#line 1863
						continue;
					}
#line 1864
					if (n > 0) {
#line 1864
						break;
					}
#line 1865
					unLo++;
				}
#line 1867
				while (!(unLo > unHi)) {
#line 1869
					n = (int)*(block + (*(zptr + unHi) + d)) - med;
#line 1870
					if (n == 0) {
#line 1871
						tmp___1 = *(zptr + unHi);
#line 1871
						* (zptr + unHi) = *(zptr + gtHi);
#line 1871
						* (zptr + gtHi) = tmp___1;
#line 1872
						gtHi--;
#line 1872
						unHi--;
#line 1872
						continue;
					}
#line 1873
					if (n < 0) {
#line 1873
						break;
					}
#line 1874
					unHi--;
				}
#line 1876
				if (unLo > unHi) {
#line 1876
					break;
				}
#line 1877
				tmp___2 = *(zptr + unLo);
#line 1877
				* (zptr + unLo) = *(zptr + unHi);
#line 1877
				* (zptr + unHi) = tmp___2;
#line 1878
				unLo++;
#line 1878
				unHi--;
			}
#line 1882
			if (gtHi < ltLo) {
#line 1885
				stack[sp].ll = lo;
#line 1886
				stack[sp].hh = hi;
#line 1887
				stack[sp].dd = d + 1;
#line 1888
				sp++;
#line 1890
				continue;
			}
#line 1893
			if (ltLo - lo < unLo - ltLo) {
#line 1893
				n = ltLo - lo;
			}
			else {
#line 1893
				n = unLo - ltLo;
			}
#line 1894
			vswap(lo, unLo - n, n);
#line 1895
			if (hi - gtHi < gtHi - unHi) {
#line 1895
				m = hi - gtHi;
			}
			else {
#line 1895
				m = gtHi - unHi;
			}
#line 1896
			vswap(unLo, (hi - m) + 1, m);
#line 1900
			n = ((lo + unLo) - ltLo) - 1;
#line 1901
			m = (hi - (gtHi - unHi)) + 1;
#line 1904
			stack[sp].ll = lo;
#line 1905
			stack[sp].hh = n;
#line 1906
			stack[sp].dd = d;
#line 1907
			sp++;
#line 1910
			stack[sp].ll = n + 1;
#line 1911
			stack[sp].hh = m - 1;
#line 1912
			stack[sp].dd = d + 1;
#line 1913
			sp++;
#line 1916
			stack[sp].ll = m;
#line 1917
			stack[sp].hh = hi;
#line 1918
			stack[sp].dd = d;
#line 1919
			sp++;
		}
#line 1921
		return;
	}
}
#line 1928 "bzip2.c"
void sortIt(void)
{
	int i;
	int j;
	int ss;
	int sb;
	int runningOrder[256];
	int copy[256];
	unsigned char bigDone[256];
	unsigned char c1;
	unsigned char c2;
	int numQSorted;
	struct _reent *tmp;
	struct _reent *tmp___0;
	struct _reent *tmp___1;
	struct _reent *tmp___2;
	int vv;
	int h;
	int lo;
	int hi;
	struct _reent *tmp___3;
	int bbStart;
	int bbSize;
	int shifts;
	int a2update;
	unsigned int qVal;
	struct _reent *tmp___4;

	{
#line 1941
		if (verbosity >= 4) {
#line 1941
			tmp = __getreent();
#line 1941
			fprintf(tmp->_stderr, "        sort initialise ...\n");
		}
#line 1942
		i = 0;
#line 1942
		while (i < 20) {
#line 1943
			* (block + ((last + i) + 1)) = *(block + i % (last + 1));
#line 1942
			i++;
		}
#line 1944
		i = 0;
#line 1944
		while (i <= last + 20) {
#line 1945
			* (quadrant + i) = 0U;
#line 1944
			i++;
		}
#line 1947
		* (block + -1) = *(block + last);
#line 1949
		if (last < 4000) {
#line 1955
			if (verbosity >= 4) {
#line 1955
				tmp___0 = __getreent();
#line 1955
				fprintf(tmp___0->_stderr, "        simpleSort ...\n");
			}
#line 1956
			i = 0;
#line 1956
			while (i <= last) {
#line 1956
				* (zptr + i) = i;
#line 1956
				i++;
			}
#line 1957
			firstAttempt = (unsigned char)0;
#line 1958
			workLimit = 0;
#line 1958
			workDone = workLimit;
#line 1959
			simpleSort(0, last, 0);
#line 1960
			if (verbosity >= 4) {
#line 1960
				tmp___1 = __getreent();
#line 1960
				fprintf(tmp___1->_stderr, "        simpleSort done.\n");
			}
		}
		else {
#line 1964
			numQSorted = 0;
#line 1965
			i = 0;
#line 1965
			while (i <= 255) {
#line 1965
				bigDone[i] = (unsigned char)0;
#line 1965
				i++;
			}
#line 1967
			if (verbosity >= 4) {
#line 1967
				tmp___2 = __getreent();
#line 1967
				fprintf(tmp___2->_stderr, "        bucket sorting ...\n");
			}
#line 1969
			i = 0;
#line 1969
			while (i <= 65536) {
#line 1969
				* (ftab + i) = 0;
#line 1969
				i++;
			}
#line 1971
			c1 = *(block + -1);
#line 1973
			i = 0;
#line 1973
			while (i <= last) {
#line 1974
				c2 = *(block + i);
#line 1975
				(*(ftab + (((int)c1 << 8) + (int)c2)))++;
#line 1976
				c1 = c2;
#line 1973
				i++;
			}
#line 1979
			i = 1;
#line 1979
			while (i <= 65536) {
#line 1979
				* (ftab + i) += *(ftab + (i - 1));
#line 1979
				i++;
			}
#line 1981
			c1 = *(block + 0);
#line 1982
			i = 0;
#line 1982
			while (i < last) {
#line 1983
				c2 = *(block + (i + 1));
#line 1984
				j = ((int)c1 << 8) + (int)c2;
#line 1985
				c1 = c2;
#line 1986
				(*(ftab + j))--;
#line 1987
				* (zptr + *(ftab + j)) = i;
#line 1982
				i++;
			}
#line 1991
			j = ((int)*(block + last) << 8) + (int)*(block + 0);
#line 1992
			(*(ftab + j))--;
#line 1993
			* (zptr + *(ftab + j)) = last;
#line 2001
			i = 0;
#line 2001
			while (i <= 255) {
#line 2001
				runningOrder[i] = i;
#line 2001
				i++;
			}
#line 2005
			h = 1;
#line 2006
			while (1) {
#line 2006
				h = 3 * h + 1;
#line 2006
				if (!(h <= 256)) {
#line 2006
					break;
				}
			}
#line 2007
			while (1) {
#line 2008
				h /= 3;
#line 2009
				i = h;
#line 2009
				while (i <= 255) {
#line 2010
					vv = runningOrder[i];
#line 2011
					j = i;
#line 2013
					while (*(ftab + ((runningOrder[j - h] + 1) << 8)) - *(ftab + (runningOrder[j - h] << 8)) > *(ftab + ((vv + 1) << 8)) - *(ftab + (vv << 8))) {
#line 2015
						runningOrder[j] = runningOrder[j - h];
#line 2016
						j -= h;
#line 2017
						if (j <= h - 1) {
							goto zero;
						}
					}
				zero:
#line 2020
					runningOrder[j] = vv;
#line 2009
					i++;
				}
#line 2007
				if (!(h != 1)) {
#line 2007
					break;
				}
			}
#line 2029
			i = 0;
#line 2029
			while (i <= 255) {
#line 2034
				ss = runningOrder[i];
#line 2043
				j = 0;
#line 2043
				while (j <= 255) {
#line 2044
					sb = (ss << 8) + j;
#line 2045
					if (!(*(ftab + sb) & (1 << 21))) {
#line 2046
						lo = *(ftab + sb) & ~(1 << 21);
#line 2047
						hi = (*(ftab + (sb + 1)) & ~(1 << 21)) - 1;
#line 2049
						if (hi > lo) {
#line 2050
							if (verbosity >= 4) {
#line 2051
								tmp___3 = __getreent();
#line 2051
								fprintf(tmp___3->_stderr, "        qsort [0x%x, 0x%x]   done %d   this %d\n",
									ss, j, numQSorted, (hi - lo) + 1);
							}
#line 2054
							syf = i;
#line 2057
							qSort3(lo, hi, 2);
#line 2058
							numQSorted += (hi - lo) + 1;
#line 2059
							if (workDone > workLimit) {
#line 2059
								if (firstAttempt) {
#line 2060
									return;
								}
							}
						}
#line 2062
						* (ftab + sb) |= 1 << 21;
					}
#line 2043
					j++;
				}
#line 2074
				bigDone[ss] = (unsigned char)1;
#line 2076
				if (i < 255) {
#line 2077
					bbStart = *(ftab + (ss << 8)) & ~(1 << 21);
#line 2078
					bbSize = (*(ftab + ((ss + 1) << 8)) & ~(1 << 21)) - bbStart;
#line 2079
					shifts = 0;
#line 2080
					while (bbSize >> shifts > 65534) {
#line 2080
						shifts++;
					}
#line 2082
					j = 0;
#line 2082
					while (j < bbSize) {
#line 2083
						a2update = *(zptr + (bbStart + j));
#line 2084
						qVal = (unsigned int)(j >> shifts);
#line 2085
						* (quadrant + a2update) = qVal;
#line 2086
						if (a2update < 20) {
#line 2087
							* (quadrant + ((a2update + last) + 1)) = qVal;
						}
#line 2082
						j++;
					}
#line 2090
					if (!((bbSize - 1) >> shifts <= 65535)) {
#line 2090
						panic((char *)"sortIt");
					}
				}
#line 2097
				j = 0;
#line 2097
				while (j <= 255) {
#line 2098
					copy[j] = *(ftab + ((j << 8) + ss)) & ~(1 << 21);
#line 2097
					j++;
				}
#line 2100
				j = *(ftab + (ss << 8)) & ~(1 << 21);
#line 2100
				while (j < (*(ftab + ((ss + 1) << 8)) & ~(1 << 21))) {
#line 2103
					c1 = *(block + (*(zptr + j) - 1));
#line 2104
					if (!bigDone[c1]) {
#line 2105
						if (*(zptr + j) == 0) {
#line 2105
							* (zptr + copy[c1]) = last;
						}
						else {
#line 2105
							* (zptr + copy[c1]) = *(zptr + j) - 1;
						}
#line 2106
						(copy[c1])++;
					}
#line 2100
					j++;
				}
#line 2110
				j = 0;
#line 2110
				while (j <= 255) {
#line 2110
					* (ftab + ((j << 8) + ss)) |= 1 << 21;
#line 2110
					j++;
				}
#line 2029
				i++;
			}
#line 2112
			if (verbosity >= 4) {
#line 2113
				tmp___4 = __getreent();
#line 2113
				fprintf(tmp___4->_stderr, "        %d pointers, %d sorted, %d scanned\n", last + 1,
					numQSorted, (last + 1) - numQSorted);
			}
		}
#line 2116
		return;
	}
}
#line 2124 "bzip2.c"
int rNums[512] =
#line 2124
{ 619, 720, 127, 481,
931, 816, 813, 233,
566, 247, 985, 724,
205, 454, 863, 491,
741, 242, 949, 214,
733, 859, 335, 708,
621, 574, 73, 654,
730, 472, 419, 436,
278, 496, 867, 210,
399, 680, 480, 51,
878, 465, 811, 169,
869, 675, 611, 697,
867, 561, 862, 687,
507, 283, 482, 129,
807, 591, 733, 623,
150, 238, 59, 379,
684, 877, 625, 169,
643, 105, 170, 607,
520, 932, 727, 476,
693, 425, 174, 647,
73, 122, 335, 530,
442, 853, 695, 249,
445, 515, 909, 545,
703, 919, 874, 474,
882, 500, 594, 612,
641, 801, 220, 162,
819, 984, 589, 513,
495, 799, 161, 604,
958, 533, 221, 400,
386, 867, 600, 782,
382, 596, 414, 171,
516, 375, 682, 485,
911, 276, 98, 553,
163, 354, 666, 933,
424, 341, 533, 870,
227, 730, 475, 186,
263, 647, 537, 686,
600, 224, 469, 68,
770, 919, 190, 373,
294, 822, 808, 206,
184, 943, 795, 384,
383, 461, 404, 758,
839, 887, 715, 67,
618, 276, 204, 918,
873, 777, 604, 560,
951, 160, 578, 722,
79, 804, 96, 409,
713, 940, 652, 934,
970, 447, 318, 353,
859, 672, 112, 785,
645, 863, 803, 350,
139, 93, 354, 99,
820, 908, 609, 772,
154, 274, 580, 184,
79, 626, 630, 742,
653, 282, 762, 623,
680, 81, 927, 626,
789, 125, 411, 521,
938, 300, 821, 78,
343, 175, 128, 250,
170, 774, 972, 275,
999, 639, 495, 78,
352, 126, 857, 956,
358, 619, 580, 124,
737, 594, 701, 612,
669, 112, 134, 694,
363, 992, 809, 743,
168, 974, 944, 375,
748, 52, 600, 747,
642, 182, 862, 81,
344, 805, 988, 739,
511, 655, 814, 334,
249, 515, 897, 955,
664, 981, 649, 113,
974, 459, 893, 228,
433, 837, 553, 268,
926, 240, 102, 654,
459, 51, 686, 754,
806, 760, 493, 403,
415, 394, 687, 700,
946, 670, 656, 610,
738, 392, 760, 799,
887, 653, 978, 321,
576, 617, 626, 502,
894, 679, 243, 440,
680, 879, 194, 572,
640, 724, 926, 56,
204, 700, 707, 151,
457, 449, 797, 195,
791, 558, 945, 679,
297, 59, 87, 824,
713, 663, 412, 693,
342, 606, 134, 108,
571, 364, 631, 212,
174, 643, 304, 329,
343, 97, 430, 751,
497, 314, 983, 374,
822, 928, 140, 206,
73, 263, 980, 736,
876, 478, 430, 305,
170, 514, 364, 692,
829, 82, 855, 953,
676, 246, 369, 970,
294, 750, 807, 827,
150, 790, 288, 923,
804, 378, 215, 828,
592, 281, 565, 555,
710, 82, 896, 831,
547, 261, 524, 462,
293, 465, 502, 56,
661, 821, 976, 991,
658, 869, 905, 758,
745, 193, 768, 550,
608, 933, 378, 286,
215, 979, 792, 961,
61, 688, 793, 644,
986, 403, 106, 366,
905, 644, 372, 567,
466, 434, 645, 210,
389, 550, 919, 135,
780, 773, 635, 389,
707, 100, 626, 958,
165, 504, 920, 176,
193, 713, 857, 265,
203, 50, 668, 108,
645, 990, 626, 197,
510, 357, 358, 850,
858, 364, 936, 638 };
#line 2189 "bzip2.c"
void randomiseBlock(void)
{
	int i;
	int rNToGo;
	int rTPos;
	int tmp;

	{
#line 2192
		rNToGo = 0;
#line 2193
		rTPos = 0;
#line 2194
		i = 0;
#line 2194
		while (i < 256) {
#line 2194
			inUse[i] = (unsigned char)0;
#line 2194
			i++;
		}
#line 2196
		i = 0;
#line 2196
		while (i <= last) {
#line 2197
			if (rNToGo == 0) {
#line 2198
				rNToGo = rNums[rTPos];
#line 2199
				rTPos++;
#line 2199
				if (rTPos == 512) {
#line 2199
					rTPos = 0;
				}
			}
#line 2201
			rNToGo--;
#line 2202
			if (rNToGo == 1) {
#line 2202
				tmp = 1;
			}
			else {
#line 2202
				tmp = 0;
			}
#line 2202
			* (block + i) = (unsigned char)((int)*(block + i) ^ tmp);
#line 2203
			inUse[*(block + i)] = (unsigned char)1;
#line 2196
			i++;
		}
#line 2205
		return;
	}
}
#line 2209 "bzip2.c"
void doReversibleTransformation(void)
{
	int i;
	struct _reent *tmp;
	struct _reent *tmp___0;
	struct _reent *tmp___1;
	struct _reent *tmp___2;

	{
#line 2213
		if (verbosity >= 2) {
#line 2213
			tmp = __getreent();
#line 2213
			fprintf(tmp->_stderr, "\n");
		}
#line 2215
		workLimit = workFactor * last;
#line 2216
		workDone = 0;
#line 2217
		blockRandomised = (unsigned char)0;
#line 2218
		firstAttempt = (unsigned char)1;
#line 2220
		sortIt();
#line 2222
		if (verbosity >= 3) {
#line 2223
			tmp___0 = __getreent();
#line 2223
			fprintf(tmp___0->_stderr, "      %d work, %d block, ratio %5.2f\n", workDone,
				last, (float)workDone / (float)last);
		}
#line 2226
		if (workDone > workLimit) {
#line 2226
			if (firstAttempt) {
#line 2227
				if (verbosity >= 2) {
#line 2228
					tmp___1 = __getreent();
#line 2228
					fprintf(tmp___1->_stderr, "    sorting aborted; randomising block\n");
				}
#line 2229
				randomiseBlock();
#line 2230
				workDone = 0;
#line 2230
				workLimit = workDone;
#line 2231
				blockRandomised = (unsigned char)1;
#line 2232
				firstAttempt = (unsigned char)0;
#line 2233
				sortIt();
#line 2234
				if (verbosity >= 3) {
#line 2235
					tmp___2 = __getreent();
#line 2235
					fprintf(tmp___2->_stderr, "      %d work, %d block, ratio %f\n", workDone,
						last, (float)workDone / (float)last);
				}
			}
		}
#line 2239
		origPtr = -1;
#line 2240
		i = 0;
#line 2240
		while (i <= last) {
#line 2241
			if (*(zptr + i) == 0) {
#line 2242
				origPtr = i;
#line 2242
				break;
			}
#line 2240
			i++;
		}
#line 2244
		if (origPtr == -1) {
#line 2244
			panic((char *)"doReversibleTransformation");
		}
#line 2245
		return;
	}
}
#line 2250 "bzip2.c"
int indexIntoF(int indx, int *cftab)
{
	int nb;
	int na;
	int mid;

	{
#line 2253
		nb = 0;
#line 2254
		na = 256;
#line 2255
		while (1) {
#line 2256
			mid = (nb + na) >> 1;
#line 2257
			if (indx >= *(cftab + mid)) {
#line 2257
				nb = mid;
			}
			else {
#line 2257
				na = mid;
			}
#line 2255
			if (!(na - nb != 1)) {
#line 2255
				break;
			}
		}
#line 2260
		return (nb);
	}
}
#line 2268 "bzip2.c"
void undoReversibleTransformation_small(int dst)
{
	int cftab[257];
	int cftabAlso[257];
	int i;
	int j;
	int tmp;
	int tPos;
	unsigned char ch;
	int retVal;
	int i2;
	int count;
	int chPrev;
	int ch2;
	unsigned int localCrc;
	int rNToGo;
	int rTPos;
	int tmp___0;
	int j2;
	unsigned char z;
	int tmp___1;
	int tmp___2;

	{
#line 2281
		cftab[0] = 0;
#line 2282
		i = 1;
#line 2282
		while (i <= 256) {
#line 2282
			cftab[i] = unzftab[i - 1];
#line 2282
			i++;
		}
#line 2283
		i = 1;
#line 2283
		while (i <= 256) {
#line 2283
			cftab[i] += cftab[i - 1];
#line 2283
			i++;
		}
#line 2286
		i = 0;
#line 2286
		while (i <= 256) {
#line 2286
			cftabAlso[i] = cftab[i];
#line 2286
			i++;
		}
#line 2289
		i = 0;
#line 2289
		while (i <= last) {
#line 2290
			ch = (unsigned char)*(ll16 + i);
#line 2293
			* (ll16 + i) = (unsigned int)(cftabAlso[ch] & 65535);
#line 2294
			SET_LL4(i, cftabAlso[ch] >> 16);
#line 2296
			* (ll16 + i) = (unsigned int)(cftabAlso[ch] & 65535);
#line 2297
			SET_LL4(i, cftabAlso[ch] >> 16);
#line 2298
			(cftabAlso[ch])++;
#line 2289
			i++;
		}
#line 2318
		i = origPtr;
#line 2319
		j = (int)(*(ll16 + i) | ((((unsigned int)*(ll4 + (i >> 1)) >> ((i << 2) & 4)) & 15U) << 16));
#line 2320
		while (1) {
#line 2321
			tmp = (int)(*(ll16 + j) | ((((unsigned int)*(ll4 + (j >> 1)) >> ((j << 2) & 4)) & 15U) << 16));
#line 2322
			* (ll16 + j) = (unsigned int)(i & 65535);
#line 2323
			SET_LL4(j, i >> 16);
#line 2324
			* (ll16 + j) = (unsigned int)(i & 65535);
#line 2325
			SET_LL4(j, i >> 16);
#line 2327
			i = j;
#line 2328
			j = tmp;
#line 2320
			if (!(i != origPtr)) {
#line 2320
				break;
			}
		}
#line 2338
		tPos = origPtr;
#line 2358
		count = 0;
#line 2359
		i2 = 0;
#line 2360
		ch2 = 256;
#line 2361
		localCrc = getGlobalCRC();
#line 2364
		rNToGo = 0;
#line 2365
		rTPos = 0;
#line 2366
		while (i2 <= last) {
#line 2367
			chPrev = ch2;
#line 2369
			ch2 = indexIntoF(tPos, cftab);
#line 2369
			tPos = (int)(*(ll16 + tPos) | ((((unsigned int)*(ll4 + (tPos >> 1)) >> ((tPos << 2) & 4)) & 15U) << 16));
#line 2371
			if (blockRandomised) {
#line 2372
				if (rNToGo == 0) {
#line 2373
					rNToGo = rNums[rTPos];
#line 2374
					rTPos++;
#line 2374
					if (rTPos == 512) {
#line 2374
						rTPos = 0;
					}
				}
#line 2376
				rNToGo--;
#line 2377
				if (rNToGo == 1) {
#line 2377
					tmp___0 = 1;
				}
				else {
#line 2377
					tmp___0 = 0;
				}
#line 2377
				ch2 = (int)((unsigned int)ch2 ^ (unsigned int)tmp___0);
			}
#line 2379
			i2++;
#line 2381
			if (dst) {
#line 2382
				retVal = spec_putc((unsigned char)ch2, dst);
			}
#line 2386
			localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int)((unsigned char)ch2)];
#line 2392
			if (ch2 != chPrev) {
#line 2393
				count = 1;
			}
			else {
#line 2395
				count++;
#line 2396
				if (count >= 4) {
#line 2400
					tmp___1 = indexIntoF(tPos, cftab);
#line 2400
					z = (unsigned char)tmp___1;
#line 2400
					tPos = (int)(*(ll16 + tPos) | ((((unsigned int)*(ll4 + (tPos >> 1)) >> ((tPos << 2) & 4)) & 15U) << 16));
#line 2402
					if (blockRandomised) {
#line 2403
						if (rNToGo == 0) {
#line 2404
							rNToGo = rNums[rTPos];
#line 2405
							rTPos++;
#line 2405
							if (rTPos == 512) {
#line 2405
								rTPos = 0;
							}
						}
#line 2407
						rNToGo--;
#line 2408
						if (rNToGo == 1) {
#line 2408
							tmp___2 = 1;
						}
						else {
#line 2408
							tmp___2 = 0;
						}
#line 2408
						z = (unsigned char)((int)z ^ tmp___2);
					}
#line 2410
					j2 = 0;
#line 2410
					while (j2 < (int)z) {
#line 2411
						if (dst) {
#line 2411
							retVal = spec_putc((unsigned char)ch2, dst);
						}
#line 2414
						localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int)((unsigned char)ch2)];
#line 2410
						j2++;
					}
#line 2419
					i2++;
#line 2420
					count = 0;
				}
			}
		}
#line 2426
		setGlobalCRC(localCrc);
#line 2429
		return;
	}
}
#line 2437 "bzip2.c"
void undoReversibleTransformation_fast(int dst)
{
	int cftab[257];
	int i;
	int tPos;
	unsigned char ch;
	int retVal;
	int i2;
	int count;
	int chPrev;
	int ch2;
	unsigned int localCrc;
	int rNToGo;
	int rTPos;
	int tmp;
	int j2;
	unsigned char z;
	int tmp___0;
	int j2___0;
	unsigned char z___0;

	{
#line 2450
		cftab[0] = 0;
#line 2451
		i = 1;
#line 2451
		while (i <= 256) {
#line 2451
			cftab[i] = unzftab[i - 1];
#line 2451
			i++;
		}
#line 2452
		i = 1;
#line 2452
		while (i <= 256) {
#line 2452
			cftab[i] += cftab[i - 1];
#line 2452
			i++;
		}
#line 2455
		i = 0;
#line 2455
		while (i <= last) {
#line 2456
			ch = *(ll8 + i);
#line 2457
			* (tt + cftab[ch]) = i;
#line 2458
			(cftab[ch])++;
#line 2455
			i++;
		}
#line 2467
		tPos = *(tt + origPtr);
#line 2483
		count = 0;
#line 2484
		i2 = 0;
#line 2485
		ch2 = 256;
#line 2486
		localCrc = getGlobalCRC();
#line 2488
		if (blockRandomised) {
#line 2489
			rNToGo = 0;
#line 2490
			rTPos = 0;
#line 2491
			while (i2 <= last) {
#line 2492
				chPrev = ch2;
#line 2493
				ch2 = (int)*(ll8 + tPos);
#line 2494
				tPos = *(tt + tPos);
#line 2495
				if (rNToGo == 0) {
#line 2496
					rNToGo = rNums[rTPos];
#line 2497
					rTPos++;
#line 2497
					if (rTPos == 512) {
#line 2497
						rTPos = 0;
					}
				}
#line 2499
				rNToGo--;
#line 2500
				if (rNToGo == 1) {
#line 2500
					tmp = 1;
				}
				else {
#line 2500
					tmp = 0;
				}
#line 2500
				ch2 = (int)((unsigned int)ch2 ^ (unsigned int)tmp);
#line 2501
				i2++;
#line 2503
				retVal = spec_putc((unsigned char)ch2, dst);
#line 2506
				localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int)((unsigned char)ch2)];
#line 2510
				if (ch2 != chPrev) {
#line 2511
					count = 1;
				}
				else {
#line 2513
					count++;
#line 2514
					if (count >= 4) {
#line 2517
						z = *(ll8 + tPos);
#line 2518
						tPos = *(tt + tPos);
#line 2519
						if (rNToGo == 0) {
#line 2520
							rNToGo = rNums[rTPos];
#line 2521
							rTPos++;
#line 2521
							if (rTPos == 512) {
#line 2521
								rTPos = 0;
							}
						}
#line 2523
						rNToGo--;
#line 2524
						if (rNToGo == 1) {
#line 2524
							tmp___0 = 1;
						}
						else {
#line 2524
							tmp___0 = 0;
						}
#line 2524
						z = (unsigned char)((int)z ^ tmp___0);
#line 2525
						j2 = 0;
#line 2525
						while (j2 < (int)z) {
#line 2526
							retVal = spec_putc((unsigned char)ch2, dst);
#line 2528
							localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int)((unsigned char)ch2)];
#line 2525
							j2++;
						}
#line 2532
						i2++;
#line 2533
						count = 0;
					}
				}
			}
		}
		else {
#line 2540
			while (i2 <= last) {
#line 2541
				chPrev = ch2;
#line 2543
				ch2 = (int)*(ll8 + tPos);
#line 2544
				tPos = *(tt + tPos);
#line 2545
				i2++;
#line 2547
				retVal = spec_putc((unsigned char)ch2, dst);
#line 2549
				localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int)((unsigned char)ch2)];
#line 2553
				if (ch2 != chPrev) {
#line 2554
					count = 1;
				}
				else {
#line 2556
					count++;
#line 2557
					if (count >= 4) {
#line 2561
						z___0 = *(ll8 + tPos);
#line 2562
						tPos = *(tt + tPos);
#line 2563
						j2___0 = 0;
#line 2563
						while (j2___0 < (int)z___0) {
#line 2564
							retVal = spec_putc((unsigned char)ch2, dst);
#line 2566
							localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int)((unsigned char)ch2)];
#line 2563
							j2___0++;
						}
#line 2570
						i2++;
#line 2571
						count = 0;
					}
				}
			}
		}
#line 2578
		setGlobalCRC(localCrc);
#line 2581
		return;
	}
}
#line 2596 "bzip2.c"
int getRLEpair(int src)
{
	int runLength;
	int ch;
	int chLatest;
	int tmp;
	int i;

	{
#line 2602
		ch = spec_getc(src);
#line 2604
		if (ch == -1) {
#line 2605
			ERROR_IF_NOT_ZERO(0);
#line 2606
			return ((1 << 16) | 257);
		}
#line 2609
		runLength = 0;
#line 2610
		while (1) {
#line 2611
			chLatest = spec_getc(src);
#line 2612
			runLength++;
#line 2613
			bytesIn++;
#line 2610
			if (ch == chLatest) {
#line 2610
				if (!(runLength < 255)) {
#line 2610
					break;
				}
			}
			else {
#line 2610
				break;
			}
		}
#line 2617
		if (chLatest != -1) {
#line 2618
			tmp = spec_ungetc((unsigned char)chLatest, src);
#line 2618
			if (tmp == -1) {
#line 2619
				panic((char *)"getRLEpair: ungetc failed");
			}
		}
		else {
#line 2621
			ERROR_IF_NOT_ZERO(0);
		}
#line 2625
		if (runLength == 1) {
#line 2627
			globalCrc = (globalCrc << 8) ^ crc32Table[(globalCrc >> 24) ^ (unsigned int)((unsigned char)ch)];
#line 2630
			return ((1 << 16) | ch);
		}
		else {
#line 2633
			i = 1;
#line 2633
			while (i <= runLength) {
#line 2635
				globalCrc = (globalCrc << 8) ^ crc32Table[(globalCrc >> 24) ^ (unsigned int)((unsigned char)ch)];
#line 2633
				i++;
			}
#line 2638
			return ((runLength << 16) | ch);
		}
	}
}
#line 2644 "bzip2.c"
void loadAndRLEsource(int src)
{
	int ch;
	int allowableBlockSize;
	int i;
	int rlePair;
	int runLen;

	{
#line 2648
		last = -1;
#line 2649
		ch = 0;
#line 2651
		i = 0;
#line 2651
		while (i < 256) {
#line 2651
			inUse[i] = (unsigned char)0;
#line 2651
			i++;
		}
#line 2654
		allowableBlockSize = 100000 * blockSize100k - 20;
#line 2656
		while (1) {
#line 2656
			if (last < allowableBlockSize) {
#line 2656
				if (!(ch != 257)) {
#line 2656
					break;
				}
			}
			else {
#line 2656
				break;
			}
#line 2658
			rlePair = getRLEpair(src);
#line 2659
			ch = rlePair & 65535;
#line 2660
			runLen = (int)((unsigned int)rlePair >> 16);
#line 2661
			if (ch != 257) {
#line 2662
				inUse[ch] = (unsigned char)1;
#line 2663
				switch (runLen) {
				case 1:
#line 2665
					last++;
#line 2665
					* (block + last) = (unsigned char)ch;
#line 2665
					break;
				case 2:
#line 2667
					last++;
#line 2667
					* (block + last) = (unsigned char)ch;
#line 2668
					last++;
#line 2668
					* (block + last) = (unsigned char)ch;
#line 2668
					break;
				case 3:
#line 2670
					last++;
#line 2670
					* (block + last) = (unsigned char)ch;
#line 2671
					last++;
#line 2671
					* (block + last) = (unsigned char)ch;
#line 2672
					last++;
#line 2672
					* (block + last) = (unsigned char)ch;
#line 2672
					break;
				default:
#line 2674
					inUse[runLen - 4] = (unsigned char)1;
#line 2675
					last++;
#line 2675
					* (block + last) = (unsigned char)ch;
#line 2676
					last++;
#line 2676
					* (block + last) = (unsigned char)ch;
#line 2677
					last++;
#line 2677
					* (block + last) = (unsigned char)ch;
#line 2678
					last++;
#line 2678
					* (block + last) = (unsigned char)ch;
#line 2679
					last++;
#line 2679
					* (block + last) = (unsigned char)(runLen - 4);
#line 2679
					break;
				}
			}
		}
#line 2683
		return;
	}
}
#line 2691 "bzip2.c"
void compressStream(int stream, int zStream)
{
	int retVal;
	unsigned int blockCRC;
	unsigned int combinedCRC;
	int blockNo;
	struct _reent *tmp;
	struct _reent *tmp___0;
	char const   *tmp___1;
	struct _reent *tmp___2;
	struct _reent *tmp___3;
	struct _reent *tmp___4;

	{
#line 2698
		blockNo = 0;
#line 2699
		bytesIn = 0U;
#line 2700
		bytesOut = 0U;
#line 2701
		nBlocksRandomised = 0;
#line 2706
		ERROR_IF_NOT_ZERO(0);
#line 2707
		ERROR_IF_NOT_ZERO(0);
#line 2709
		bsSetStream(zStream, (unsigned char)1);
#line 2715
		bsPutUChar((unsigned char)'B');
#line 2716
		bsPutUChar((unsigned char)'Z');
#line 2717
		bsPutUChar((unsigned char)'h');
#line 2718
		bsPutUChar((unsigned char)(48 + blockSize100k));
#line 2720
		combinedCRC = 0U;
#line 2722
		if (verbosity >= 2) {
#line 2722
			tmp = __getreent();
#line 2722
			fprintf(tmp->_stderr, "\n");
		}
#line 2724
		while (1) {
#line 2726
			blockNo++;
#line 2727
			initialiseCRC();
#line 2728
			loadAndRLEsource(stream);
#line 2729
			ERROR_IF_NOT_ZERO(0);
#line 2730
			if (last == -1) {
#line 2730
				break;
			}
#line 2732
			blockCRC = getFinalCRC();
#line 2733
			combinedCRC = (combinedCRC << 1) | (combinedCRC >> 31);
#line 2734
			combinedCRC ^= blockCRC;
#line 2736
			if (verbosity >= 2) {
#line 2737
				tmp___0 = __getreent();
#line 2737
				fprintf(tmp___0->_stderr, "    block %d: crc = 0x%8x, combined CRC = 0x%8x, size = %d",
					blockNo, blockCRC, combinedCRC, last + 1);
			}
#line 2741
			doReversibleTransformation();
#line 2755
			bsPutUChar((unsigned char)49);
#line 2755
			bsPutUChar((unsigned char)65);
#line 2756
			bsPutUChar((unsigned char)89);
#line 2756
			bsPutUChar((unsigned char)38);
#line 2757
			bsPutUChar((unsigned char)83);
#line 2757
			bsPutUChar((unsigned char)89);
#line 2760
			bsPutUInt32(blockCRC);
#line 2763
			if (blockRandomised) {
#line 2764
				bsW(1, 1U);
#line 2764
				nBlocksRandomised++;
			}
			else {
#line 2766
				bsW(1, 0U);
			}
#line 2769
			moveToFrontCodeAndSend();
#line 2771
			ERROR_IF_NOT_ZERO(0);
		}
#line 2774
		if (verbosity >= 2) {
#line 2774
			if (nBlocksRandomised > 0) {
#line 2775
				if (nBlocksRandomised == 1) {
#line 2775
					tmp___1 = "";
				}
				else {
#line 2775
					tmp___1 = "s";
				}
#line 2775
				tmp___2 = __getreent();
#line 2775
				fprintf(tmp___2->_stderr, "    %d block%s needed randomisation\n", nBlocksRandomised,
					tmp___1);
			}
		}
#line 2787
		bsPutUChar((unsigned char)23);
#line 2787
		bsPutUChar((unsigned char)114);
#line 2788
		bsPutUChar((unsigned char)69);
#line 2788
		bsPutUChar((unsigned char)56);
#line 2789
		bsPutUChar((unsigned char)80);
#line 2789
		bsPutUChar((unsigned char)144);
#line 2791
		bsPutUInt32(combinedCRC);
#line 2792
		if (verbosity >= 2) {
#line 2793
			tmp___3 = __getreent();
#line 2793
			fprintf(tmp___3->_stderr, "    final combined CRC = 0x%x\n   ", combinedCRC);
		}
#line 2796
		bsFinishedWithStream();
#line 2798
		ERROR_IF_NOT_ZERO(0);
#line 2799
		retVal = 0;
#line 2800
		ERROR_IF_EOF(retVal);
#line 2801
		retVal = 0;
#line 2802
		ERROR_IF_EOF(retVal);
#line 2804
		ERROR_IF_NOT_ZERO(0);
#line 2805
		retVal = 0;
#line 2806
		ERROR_IF_EOF(retVal);
#line 2808
		if (bytesIn == 0U) {
#line 2808
			bytesIn = 1U;
		}
#line 2809
		if (bytesOut == 0U) {
#line 2809
			bytesOut = 1U;
		}
#line 2811
		if (verbosity >= 1) {
#line 2812
			tmp___4 = __getreent();
#line 2812
			fprintf(tmp___4->_stderr, "%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %d in, %d out.\n",
				(float)bytesIn / (float)bytesOut, (8.0 * (double)((float)bytesOut)) / (double)((float)bytesIn),
				100.0 * (1.0 - (double)((float)bytesOut / (float)bytesIn)), bytesIn,
				bytesOut);
		}
#line 2820
		return;
	}
}
#line 2825 "bzip2.c"
unsigned char uncompressStream(int zStream, int stream)
{
	unsigned char magic1;
	unsigned char magic2;
	unsigned char magic3;
	unsigned char magic4;
	unsigned char magic5;
	unsigned char magic6;
	unsigned int storedBlockCRC;
	unsigned int storedCombinedCRC;
	unsigned int computedBlockCRC;
	unsigned int computedCombinedCRC;
	int currBlockNo;
	int retVal;
	struct _reent *tmp;
	int tmp___0;
	unsigned int tmp___1;
	struct _reent *tmp___2;
	struct _reent *tmp___3;
	struct _reent *tmp___4;
	struct _reent *tmp___5;
	struct _reent *tmp___6;
	int tmp___7;
	struct _reent *tmp___8;

	{
#line 2837
		ERROR_IF_NOT_ZERO(0);
#line 2838
		ERROR_IF_NOT_ZERO(0);
#line 2840
		bsSetStream(zStream, (unsigned char)0);
#line 2846
		magic1 = bsGetUChar();
#line 2847
		magic2 = bsGetUChar();
#line 2848
		magic3 = bsGetUChar();
#line 2849
		magic4 = bsGetUChar();
#line 2850
		if ((int)magic1 != 66) {
#line 2855
			bsFinishedWithStream();
#line 2856
			retVal = 0;
#line 2857
			ERROR_IF_EOF(retVal);
#line 2858
			return ((unsigned char)0);
		}
		else {
#line 2850
			if ((int)magic2 != 90) {
#line 2855
				bsFinishedWithStream();
#line 2856
				retVal = 0;
#line 2857
				ERROR_IF_EOF(retVal);
#line 2858
				return ((unsigned char)0);
			}
			else {
#line 2850
				if ((int)magic3 != 104) {
#line 2855
					bsFinishedWithStream();
#line 2856
					retVal = 0;
#line 2857
					ERROR_IF_EOF(retVal);
#line 2858
					return ((unsigned char)0);
				}
				else {
#line 2850
					if ((int)magic4 < 49) {
#line 2855
						bsFinishedWithStream();
#line 2856
						retVal = 0;
#line 2857
						ERROR_IF_EOF(retVal);
#line 2858
						return ((unsigned char)0);
					}
					else {
#line 2850
						if ((int)magic4 > 57) {
#line 2855
							bsFinishedWithStream();
#line 2856
							retVal = 0;
#line 2857
							ERROR_IF_EOF(retVal);
#line 2858
							return ((unsigned char)0);
						}
					}
				}
			}
		}
#line 2861
		setDecompressStructureSizes((int)magic4 - 48);
#line 2862
		computedCombinedCRC = 0U;
#line 2864
		if (verbosity >= 2) {
#line 2864
			tmp = __getreent();
#line 2864
			fprintf(tmp->_stderr, "\n    ");
		}
#line 2865
		currBlockNo = 0;
#line 2867
		while (1) {
#line 2868
			magic1 = bsGetUChar();
#line 2869
			magic2 = bsGetUChar();
#line 2870
			magic3 = bsGetUChar();
#line 2871
			magic4 = bsGetUChar();
#line 2872
			magic5 = bsGetUChar();
#line 2873
			magic6 = bsGetUChar();
#line 2874
			if ((int)magic1 == 23) {
#line 2874
				if ((int)magic2 == 114) {
#line 2874
					if ((int)magic3 == 69) {
#line 2874
						if ((int)magic4 == 56) {
#line 2874
							if ((int)magic5 == 80) {
#line 2874
								if ((int)magic6 == 144) {
#line 2876
									break;
								}
							}
						}
					}
				}
			}
#line 2878
			if ((int)magic1 != 49) {
#line 2880
				badBlockHeader();
			}
			else {
#line 2878
				if ((int)magic2 != 65) {
#line 2880
					badBlockHeader();
				}
				else {
#line 2878
					if ((int)magic3 != 89) {
#line 2880
						badBlockHeader();
					}
					else {
#line 2878
						if ((int)magic4 != 38) {
#line 2880
							badBlockHeader();
						}
						else {
#line 2878
							if ((int)magic5 != 83) {
#line 2880
								badBlockHeader();
							}
							else {
#line 2878
								if ((int)magic6 != 89) {
#line 2880
									badBlockHeader();
								}
							}
						}
					}
				}
			}
#line 2882
			tmp___0 = bsGetUInt32();
#line 2882
			storedBlockCRC = (unsigned int)tmp___0;
#line 2884
			tmp___1 = bsR(1);
#line 2884
			if (tmp___1 == 1U) {
#line 2885
				blockRandomised = (unsigned char)1;
			}
			else {
#line 2886
				blockRandomised = (unsigned char)0;
			}
#line 2888
			currBlockNo++;
#line 2889
			if (verbosity >= 2) {
#line 2890
				tmp___2 = __getreent();
#line 2890
				fprintf(tmp___2->_stderr, "[%d: huff+mtf ", currBlockNo);
			}
#line 2891
			getAndMoveToFrontDecode();
#line 2892
			ERROR_IF_NOT_ZERO(0);
#line 2894
			initialiseCRC();
#line 2895
			if (verbosity >= 2) {
#line 2895
				tmp___3 = __getreent();
#line 2895
				fprintf(tmp___3->_stderr, "rt+rld");
			}
#line 2896
			if (smallMode) {
#line 2897
				undoReversibleTransformation_small(stream);
			}
			else {
#line 2899
				undoReversibleTransformation_fast(stream);
			}
#line 2901
			ERROR_IF_NOT_ZERO(0);
#line 2903
			computedBlockCRC = getFinalCRC();
#line 2904
			if (verbosity >= 3) {
#line 2905
				tmp___4 = __getreent();
#line 2905
				fprintf(tmp___4->_stderr, " {0x%x, 0x%x}", storedBlockCRC, computedBlockCRC);
			}
#line 2906
			if (verbosity >= 2) {
#line 2906
				tmp___5 = __getreent();
#line 2906
				fprintf(tmp___5->_stderr, "] ");
			}
#line 2909
			if (storedBlockCRC != computedBlockCRC) {
#line 2910
				crcError(storedBlockCRC, computedBlockCRC);
			}
#line 2912
			computedCombinedCRC = (computedCombinedCRC << 1) | (computedCombinedCRC >> 31);
#line 2913
			computedCombinedCRC ^= computedBlockCRC;
		}
#line 2916
		if (verbosity >= 2) {
#line 2916
			tmp___6 = __getreent();
#line 2916
			fprintf(tmp___6->_stderr, "\n    ");
		}
#line 2918
		tmp___7 = bsGetUInt32();
#line 2918
		storedCombinedCRC = (unsigned int)tmp___7;
#line 2919
		if (verbosity >= 2) {
#line 2920
			tmp___8 = __getreent();
#line 2920
			fprintf(tmp___8->_stderr, "combined CRCs: stored = 0x%x, computed = 0x%x\n    ",
				storedCombinedCRC, computedCombinedCRC);
		}
#line 2923
		if (storedCombinedCRC != computedCombinedCRC) {
#line 2924
			crcError(storedCombinedCRC, computedCombinedCRC);
		}
#line 2927
		bsFinishedWithStream();
#line 2928
		ERROR_IF_NOT_ZERO(0);
#line 2929
		retVal = 0;
#line 2930
		ERROR_IF_EOF(retVal);
#line 2932
		ERROR_IF_NOT_ZERO(0);
#line 2933
		retVal = 0;
#line 2934
		ERROR_IF_NOT_ZERO(retVal);
#line 2935
		return ((unsigned char)1);
	}
}
#line 2940 "bzip2.c"
unsigned char testStream(int zStream)
{
	unsigned char magic1;
	unsigned char magic2;
	unsigned char magic3;
	unsigned char magic4;
	unsigned char magic5;
	unsigned char magic6;
	unsigned int storedBlockCRC;
	unsigned int storedCombinedCRC;
	unsigned int computedBlockCRC;
	unsigned int computedCombinedCRC;
	int currBlockNo;
	int retVal;
	struct _reent *tmp;
	struct _reent *tmp___0;
	struct _reent *tmp___1;
	int tmp___2;
	unsigned int tmp___3;
	struct _reent *tmp___4;
	struct _reent *tmp___5;
	struct _reent *tmp___6;
	struct _reent *tmp___7;
	struct _reent *tmp___8;
	struct _reent *tmp___9;
	int tmp___10;
	struct _reent *tmp___11;
	struct _reent *tmp___12;

	{
#line 2950
		ERROR_IF_NOT_ZERO(0);
#line 2952
		bsSetStream(zStream, (unsigned char)0);
#line 2954
		magic1 = bsGetUChar();
#line 2955
		magic2 = bsGetUChar();
#line 2956
		magic3 = bsGetUChar();
#line 2957
		magic4 = bsGetUChar();
#line 2958
		if ((int)magic1 != 66) {
#line 2963
			bsFinishedWithStream();
#line 2964
			fclose((FILE *)zStream);
#line 2965
			tmp = __getreent();
#line 2965
			fprintf(tmp->_stderr, "\n%s: bad magic number (ie, not created by bzip2)\n", inName);
#line 2967
			return ((unsigned char)0);
		}
		else {
#line 2958
			if ((int)magic2 != 90) {
#line 2963
				bsFinishedWithStream();
#line 2964
				fclose((FILE *)zStream);
#line 2965
				tmp = __getreent();
#line 2965
				fprintf(tmp->_stderr, "\n%s: bad magic number (ie, not created by bzip2)\n",
					inName);
#line 2967
				return ((unsigned char)0);
			}
			else {
#line 2958
				if ((int)magic3 != 104) {
#line 2963
					bsFinishedWithStream();
#line 2964
					fclose((FILE *)zStream);
#line 2965
					tmp = __getreent();
#line 2965
					fprintf(tmp->_stderr, "\n%s: bad magic number (ie, not created by bzip2)\n",
						inName);
#line 2967
					return ((unsigned char)0);
				}
				else {
#line 2958
					if ((int)magic4 < 49) {
#line 2963
						bsFinishedWithStream();
#line 2964
						fclose((FILE *)zStream);
#line 2965
						tmp = __getreent();
#line 2965
						fprintf(tmp->_stderr, "\n%s: bad magic number (ie, not created by bzip2)\n",
							inName);
#line 2967
						return ((unsigned char)0);
					}
					else {
#line 2958
						if ((int)magic4 > 57) {
#line 2963
							bsFinishedWithStream();
#line 2964
							fclose((FILE *)zStream);
#line 2965
							tmp = __getreent();
#line 2965
							fprintf(tmp->_stderr, "\n%s: bad magic number (ie, not created by bzip2)\n",
								inName);
#line 2967
							return ((unsigned char)0);
						}
					}
				}
			}
		}
#line 2970
		smallMode = (unsigned char)1;
#line 2971
		setDecompressStructureSizes((int)magic4 - 48);
#line 2972
		computedCombinedCRC = 0U;
#line 2974
		if (verbosity >= 2) {
#line 2974
			tmp___0 = __getreent();
#line 2974
			fprintf(tmp___0->_stderr, "\n");
		}
#line 2975
		currBlockNo = 0;
#line 2977
		while (1) {
#line 2978
			magic1 = bsGetUChar();
#line 2979
			magic2 = bsGetUChar();
#line 2980
			magic3 = bsGetUChar();
#line 2981
			magic4 = bsGetUChar();
#line 2982
			magic5 = bsGetUChar();
#line 2983
			magic6 = bsGetUChar();
#line 2984
			if ((int)magic1 == 23) {
#line 2984
				if ((int)magic2 == 114) {
#line 2984
					if ((int)magic3 == 69) {
#line 2984
						if ((int)magic4 == 56) {
#line 2984
							if ((int)magic5 == 80) {
#line 2984
								if ((int)magic6 == 144) {
#line 2986
									break;
								}
							}
						}
					}
				}
			}
#line 2988
			currBlockNo++;
#line 2989
			if ((int)magic1 != 49) {
#line 2992
				bsFinishedWithStream();
#line 2993
				fclose((FILE *)zStream);
#line 2994
				tmp___1 = __getreent();
#line 2994
				fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
					inName, currBlockNo);
#line 2997
				return ((unsigned char)0);
			}
			else {
#line 2989
				if ((int)magic2 != 65) {
#line 2992
					bsFinishedWithStream();
#line 2993
					fclose((FILE *)zStream);
#line 2994
					tmp___1 = __getreent();
#line 2994
					fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
						inName, currBlockNo);
#line 2997
					return ((unsigned char)0);
				}
				else {
#line 2989
					if ((int)magic3 != 89) {
#line 2992
						bsFinishedWithStream();
#line 2993
						fclose((FILE *)zStream);
#line 2994
						tmp___1 = __getreent();
#line 2994
						fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
							inName, currBlockNo);
#line 2997
						return ((unsigned char)0);
					}
					else {
#line 2989
						if ((int)magic4 != 38) {
#line 2992
							bsFinishedWithStream();
#line 2993
							fclose((FILE *)zStream);
#line 2994
							tmp___1 = __getreent();
#line 2994
							fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
								inName, currBlockNo);
#line 2997
							return ((unsigned char)0);
						}
						else {
#line 2989
							if ((int)magic5 != 83) {
#line 2992
								bsFinishedWithStream();
#line 2993
								fclose((FILE *)zStream);
#line 2994
								tmp___1 = __getreent();
#line 2994
								fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
									inName, currBlockNo);
#line 2997
								return ((unsigned char)0);
							}
							else {
#line 2989
								if ((int)magic6 != 89) {
#line 2992
									bsFinishedWithStream();
#line 2993
									fclose((FILE *)zStream);
#line 2994
									tmp___1 = __getreent();
#line 2994
									fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
										inName, currBlockNo);
#line 2997
									return ((unsigned char)0);
								}
							}
						}
					}
				}
			}
#line 2999
			tmp___2 = bsGetUInt32();
#line 2999
			storedBlockCRC = (unsigned int)tmp___2;
#line 3001
			tmp___3 = bsR(1);
#line 3001
			if (tmp___3 == 1U) {
#line 3002
				blockRandomised = (unsigned char)1;
			}
			else {
#line 3003
				blockRandomised = (unsigned char)0;
			}
#line 3005
			if (verbosity >= 2) {
#line 3006
				tmp___4 = __getreent();
#line 3006
				fprintf(tmp___4->_stderr, "    block [%d: huff+mtf ", currBlockNo);
			}
#line 3007
			getAndMoveToFrontDecode();
#line 3008
			ERROR_IF_NOT_ZERO(0);
#line 3010
			initialiseCRC();
#line 3011
			if (verbosity >= 2) {
#line 3011
				tmp___5 = __getreent();
#line 3011
				fprintf(tmp___5->_stderr, "rt+rld");
			}
#line 3013
			undoReversibleTransformation_small(0);
#line 3016
			computedBlockCRC = getFinalCRC();
#line 3017
			if (verbosity >= 3) {
#line 3018
				tmp___6 = __getreent();
#line 3018
				fprintf(tmp___6->_stderr, " {0x%x, 0x%x}", storedBlockCRC, computedBlockCRC);
			}
#line 3019
			if (verbosity >= 2) {
#line 3019
				tmp___7 = __getreent();
#line 3019
				fprintf(tmp___7->_stderr, "] ");
			}
#line 3021
			if (storedBlockCRC != computedBlockCRC) {
#line 3022
				bsFinishedWithStream();
#line 3023
				fclose((FILE *)zStream);
#line 3024
				tmp___8 = __getreent();
#line 3024
				fprintf(tmp___8->_stderr, "\n%s, block %d: computed CRC does not match stored one\n",
					inName, currBlockNo);
#line 3026
				return ((unsigned char)0);
			}
#line 3029
			if (verbosity >= 2) {
#line 3029
				tmp___9 = __getreent();
#line 3029
				fprintf(tmp___9->_stderr, "ok\n");
			}
#line 3030
			computedCombinedCRC = (computedCombinedCRC << 1) | (computedCombinedCRC >> 31);
#line 3031
			computedCombinedCRC ^= computedBlockCRC;
		}
#line 3034
		tmp___10 = bsGetUInt32();
#line 3034
		storedCombinedCRC = (unsigned int)tmp___10;
#line 3035
		if (verbosity >= 2) {
#line 3036
			tmp___11 = __getreent();
#line 3036
			fprintf(tmp___11->_stderr, "    combined CRCs: stored = 0x%x, computed = 0x%x\n    ",
				storedCombinedCRC, computedCombinedCRC);
		}
#line 3039
		if (storedCombinedCRC != computedCombinedCRC) {
#line 3040
			bsFinishedWithStream();
#line 3041
			fclose((FILE *)zStream);
#line 3042
			tmp___12 = __getreent();
#line 3042
			fprintf(tmp___12->_stderr, "\n%s: computed CRC does not match stored one\n", inName);
#line 3044
			return ((unsigned char)0);
		}
#line 3047
		bsFinishedWithStream();
#line 3048
		ERROR_IF_NOT_ZERO(0);
#line 3049
		retVal = 0;
#line 3050
		ERROR_IF_EOF(retVal);
#line 3051
		return ((unsigned char)1);
	}
}
#line 3061 "bzip2.c"
void cadvise(void)
{
	struct _reent *tmp;

	{
#line 3063
		tmp = __getreent();
#line 3063
		fprintf(tmp->_stderr, "\nIt is possible that the compressed file(s) have become corrupted.\nYou can use the -tvv option to test integrity of such files.\n\nYou can use the `bzip2recover\' program to *attempt* to recover\ndata from undamaged sections of corrupted files.\n\n");
#line 3070
		return;
	}
}
#line 3074 "bzip2.c"
void showFileNames(void)
{
	char const   *tmp;
	char const   *tmp___0;
	struct _reent *tmp___1;

	{
#line 3076
		if ((unsigned int)(outName) == (unsigned int)((void *)0)) {
#line 3076
			tmp = "(null)";
		}
		else {
#line 3076
			tmp = (char const   *)(outName);
		}
#line 3076
		if ((unsigned int)(inName) == (unsigned int)((void *)0)) {
#line 3076
			tmp___0 = "(null)";
		}
		else {
#line 3076
			tmp___0 = (char const   *)(inName);
		}
#line 3076
		tmp___1 = __getreent();
#line 3076
		fprintf(tmp___1->_stderr, "\tInput file = %s, output file = %s\n", tmp___0, tmp);
#line 3082
		return;
	}
}
#line 3086 "bzip2.c"
void cleanUpAndFail(int ec)
{
	int retVal;
	char const   *tmp;
	struct _reent *tmp___0;
	struct _reent *tmp___1;
	struct _reent *tmp___2;

	{
#line 3090
		if (srcMode == 3) {
#line 3090
			if (opMode != 3) {
#line 3091
				if ((unsigned int)(outName) == (unsigned int)((void *)0)) {
#line 3091
					tmp = "(null)";
				}
				else {
#line 3091
					tmp = (char const   *)(outName);
				}
#line 3091
				tmp___0 = __getreent();
#line 3091
				fprintf(tmp___0->_stderr, "%s: Deleting output file %s, if it exists.\n", progName,
					tmp);
#line 3094
				retVal = remove((char const   *)(outName));
#line 3095
				if (retVal != 0) {
#line 3096
					tmp___1 = __getreent();
#line 3096
					fprintf(tmp___1->_stderr, "%s: WARNING: deletion of output file (apparently) failed.\n",
						progName);
				}
			}
		}
#line 3100
		if (numFileNames > 0) {
#line 3100
			if (numFilesProcessed < numFileNames) {
#line 3101
				tmp___2 = __getreent();
#line 3101
				fprintf(tmp___2->_stderr, "%s: WARNING: some files have not been processed:\n\t%d specified on command line, %d not processed yet.\n\n",
					progName, numFileNames, numFileNames - numFilesProcessed);
			}
		}
#line 3107
		exit(ec);
	}
}
#line 3112 "bzip2.c"
void panic(char *s)
{
	struct _reent *tmp;

	{
#line 3114
		tmp = __getreent();
#line 3114
		fprintf(tmp->_stderr, "\n%s: PANIC -- internal consistency error:\n\t%s\n\tThis is a BUG.  Please report it to me at:\n\tjseward@acm.org\n",
			progName, s);
#line 3120
		showFileNames();
#line 3121
		cleanUpAndFail(3);
#line 3122
		return;
	}
}
#line 3126 "bzip2.c"
void badBGLengths(void)
{
	struct _reent *tmp;

	{
#line 3128
		tmp = __getreent();
#line 3128
		fprintf(tmp->_stderr, "\n%s: error when reading background model code lengths,\n\twhich probably means the compressed file is corrupted.\n",
			progName);
#line 3132
		showFileNames();
#line 3133
		cadvise();
#line 3134
		cleanUpAndFail(2);
#line 3135
		return;
	}
}
#line 3139 "bzip2.c"
void crcError(unsigned int crcStored, unsigned int crcComputed)
{
	struct _reent *tmp;

	{
#line 3141
		tmp = __getreent();
#line 3141
		fprintf(tmp->_stderr, "\n%s: Data integrity error when decompressing.\n\tStored CRC = 0x%x, computed CRC = 0x%x\n",
			progName, crcStored, crcComputed);
#line 3145
		showFileNames();
#line 3146
		cadvise();
#line 3147
		cleanUpAndFail(2);
#line 3148
		return;
	}
}
#line 3152 "bzip2.c"
void compressedStreamEOF(void)
{
	struct _reent *tmp;

	{
#line 3154
		tmp = __getreent();
#line 3154
		fprintf(tmp->_stderr, "\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n",
			progName);
#line 3158
		perror((char const   *)progName);
#line 3159
		showFileNames();
#line 3160
		cadvise();
#line 3161
		cleanUpAndFail(2);
#line 3162
		return;
	}
}
#line 3166 "bzip2.c"
void ioError(void)
{
	struct _reent *tmp;

	{
#line 3168
		tmp = __getreent();
#line 3168
		fprintf(tmp->_stderr, "\n%s: I/O or other error, bailing out.  Possible reason follows.\n",
			progName);
#line 3171
		perror((char const   *)progName);
#line 3172
		showFileNames();
#line 3173
		cleanUpAndFail(1);
#line 3174
		return;
	}
}
#line 3178 "bzip2.c"
void blockOverrun(void)
{
	struct _reent *tmp;

	{
#line 3180
		tmp = __getreent();
#line 3180
		fprintf(tmp->_stderr, "\n%s: block overrun during decompression,\n\twhich probably means the compressed file\n\tis corrupted.\n",
			progName);
#line 3185
		showFileNames();
#line 3186
		cadvise();
#line 3187
		cleanUpAndFail(2);
#line 3188
		return;
	}
}
#line 3192 "bzip2.c"
void badBlockHeader(void)
{
	struct _reent *tmp;

	{
#line 3194
		tmp = __getreent();
#line 3194
		fprintf(tmp->_stderr, "\n%s: bad block header in the compressed file,\n\twhich probably means it is corrupted.\n",
			progName);
#line 3198
		showFileNames();
#line 3199
		cadvise();
#line 3200
		cleanUpAndFail(2);
#line 3201
		return;
	}
}
#line 3205 "bzip2.c"
void bitStreamEOF(void)
{
	struct _reent *tmp;

	{
#line 3207
		tmp = __getreent();
#line 3207
		fprintf(tmp->_stderr, "\n%s: read past the end of compressed data,\n\twhich probably means it is corrupted.\n",
			progName);
#line 3211
		showFileNames();
#line 3212
		cadvise();
#line 3213
		cleanUpAndFail(2);
#line 3214
		return;
	}
}
#line 3218 "bzip2.c"
void mySignalCatcher(int n)
{
	struct _reent *tmp;

	{
#line 3220
		tmp = __getreent();
#line 3220
		fprintf(tmp->_stderr, "\n%s: Control-C (or similar) caught, quitting.\n", progName);
#line 3223
		cleanUpAndFail(1);
#line 3224
		return;
	}
}
#line 3228 "bzip2.c"
void mySIGSEGVorSIGBUScatcher(int n)
{
	struct _reent *tmp;
	struct _reent *tmp___0;

	{
#line 3230
		if (opMode == 1) {
#line 3231
			tmp = __getreent();
#line 3231
			fprintf(tmp->_stderr, "\n%s: Caught a SIGSEGV or SIGBUS whilst compressing,\n\twhich probably indicates a bug in bzip2.  Please\n\treport it to me at: jseward@acm.org\n",
				progName);
		}
		else {
#line 3237
			tmp___0 = __getreent();
#line 3237
			fprintf(tmp___0->_stderr, "\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing,\n\twhich probably indicates that the compressed data\n\tis corrupted.\n",
				progName);
		}
#line 3243
		showFileNames();
#line 3244
		if (opMode == 1) {
#line 3245
			cleanUpAndFail(3);
		}
		else {
#line 3246
			cadvise();
#line 3246
			cleanUpAndFail(2);
		}
#line 3247
		return;
	}
}
#line 3251 "bzip2.c"
void uncompressOutOfMemory(int draw, int blockSize)
{
	struct _reent *tmp;

	{
#line 3253
		tmp = __getreent();
#line 3253
		fprintf(tmp->_stderr, "\n%s: Can\'t allocate enough memory for decompression.\n\tRequested %d bytes for a block size of %d.\n\tTry selecting space-economic decompress (with flag -s)\n\tand failing that, find a machine with more memory.\n",
			progName, draw, blockSize);
#line 3259
		showFileNames();
#line 3260
		cleanUpAndFail(1);
#line 3261
		return;
	}
}
#line 3265 "bzip2.c"
void compressOutOfMemory(int draw, int blockSize)
{
	struct _reent *tmp;

	{
#line 3267
		tmp = __getreent();
#line 3267
		fprintf(tmp->_stderr, "\n%s: Can\'t allocate enough memory for compression.\n\tRequested %d bytes for a block size of %d.\n\tTry selecting a small block size (with flag -s).\n",
			progName, draw, blockSize);
#line 3272
		showFileNames();
#line 3273
		cleanUpAndFail(1);
#line 3274
		return;
	}
}
