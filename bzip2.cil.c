/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 213 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int size_t;
#line 14 "/usr/include/sys/lock.h"
typedef void *_LOCK_T;
#line 15 "/usr/include/sys/_types.h"
typedef long long _off64_t;
#line 18 "/usr/include/sys/_types.h"
typedef int _ssize_t;
#line 354 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int wint_t;
#line 27 "/usr/include/sys/_types.h"
union __anonunion___value_2 {
   wint_t __wch ;
   unsigned char __wchb[4] ;
};
#line 27 "/usr/include/sys/_types.h"
struct __anonstruct__mbstate_t_1 {
   int __count ;
   union __anonunion___value_2 __value ;
};
#line 27 "/usr/include/sys/_types.h"
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
#line 37 "/usr/include/sys/_types.h"
typedef _LOCK_T _flock_t;
#line 19 "/usr/include/sys/reent.h"
typedef unsigned long __ULong;
#line 40 "/usr/include/sys/reent.h"
struct _Bigint {
   struct _Bigint *_next ;
   int _k ;
   int _maxwds ;
   int _sign ;
   int _wds ;
   __ULong _x[1] ;
};
#line 48 "/usr/include/sys/reent.h"
struct __tm {
   int __tm_sec ;
   int __tm_min ;
   int __tm_hour ;
   int __tm_mday ;
   int __tm_mon ;
   int __tm_year ;
   int __tm_wday ;
   int __tm_yday ;
   int __tm_isdst ;
};
#line 67 "/usr/include/sys/reent.h"
struct _on_exit_args {
   void *_fnargs[32] ;
   void *_dso_handle[32] ;
   __ULong _fntypes ;
   __ULong _is_cxa ;
};
#line 85 "/usr/include/sys/reent.h"
struct _atexit {
   struct _atexit *_next ;
   int _ind ;
   void (*_fns[32])(void) ;
   struct _on_exit_args _on_exit_args ;
};
#line 101 "/usr/include/sys/reent.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 111 "/usr/include/sys/reent.h"
typedef long _fpos_t;
#line 115 "/usr/include/sys/reent.h"
typedef _off64_t _fpos64_t;
#line 166
struct _reent;
#line 214 "/usr/include/sys/reent.h"
struct __sFILE64 {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   struct _reent *_data ;
   void *_cookie ;
   _ssize_t ( __attribute__((__cdecl__)) (*_read))(void *_cookie , char *_buf , int _n ) ;
   _ssize_t ( __attribute__((__cdecl__)) (*_write))(void *_cookie , char const   *_buf ,
                                                    int _n ) ;
   _fpos_t ( __attribute__((__cdecl__)) (*_seek))(void *_cookie , _fpos_t _offset ,
                                                  int _whence ) ;
   int ( __attribute__((__cdecl__)) (*_close))(void *_cookie ) ;
   struct __sbuf _ub ;
   unsigned char *_up ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   int _flags2 ;
   _off64_t _offset ;
   _fpos64_t ( __attribute__((__cdecl__)) (*_seek64))(void *_cookie , _fpos64_t _offset ,
                                                      int _whence ) ;
   _flock_t _lock ;
};
#line 257 "/usr/include/sys/reent.h"
typedef struct __sFILE64 __FILE;
#line 262 "/usr/include/sys/reent.h"
struct _glue {
   struct _glue *_next ;
   int _niobs ;
   __FILE *_iobs ;
};
#line 290 "/usr/include/sys/reent.h"
struct _rand48 {
   unsigned short _seed[3] ;
   unsigned short _mult[3] ;
   unsigned short _add ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__reent_4 {
   unsigned int _unused_rand ;
   char *_strtok_last ;
   char _asctime_buf[26] ;
   struct __tm _localtime_buf ;
   int _gamma_signgam ;
   unsigned long long _rand_next ;
   struct _rand48 _r48 ;
   _mbstate_t _mblen_state ;
   _mbstate_t _mbtowc_state ;
   _mbstate_t _wctomb_state ;
   char _l64a_buf[8] ;
   char _signal_buf[24] ;
   int _getdate_err ;
   _mbstate_t _mbrlen_state ;
   _mbstate_t _mbrtowc_state ;
   _mbstate_t _mbsrtowcs_state ;
   _mbstate_t _wcrtomb_state ;
   _mbstate_t _wcsrtombs_state ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__unused_5 {
   unsigned char *_nextf[30] ;
   unsigned int _nmalloc[30] ;
};
#line 565 "/usr/include/sys/reent.h"
union __anonunion__new_3 {
   struct __anonstruct__reent_4 _reent ;
   struct __anonstruct__unused_5 _unused ;
};
#line 565 "/usr/include/sys/reent.h"
struct _reent {
   int _errno ;
   __FILE *_stdin ;
   __FILE *_stdout ;
   __FILE *_stderr ;
   int _inc ;
   char _emergency[25] ;
   int _current_category ;
   char const   *_current_locale ;
   int __sdidinit ;
   void ( __attribute__((__cdecl__)) (*__cleanup))(struct _reent * ) ;
   struct _Bigint *_result ;
   int _result_k ;
   struct _Bigint *_p5s ;
   struct _Bigint **_freelist ;
   int _cvtlen ;
   char *_cvtbuf ;
   union __anonunion__new_3 _new ;
   struct _atexit *_atexit ;
   struct _atexit _atexit0 ;
   void (**_sig_func)(int  ) ;
   struct _glue __sglue ;
   __FILE __sf[3] ;
};
#line 50 "/usr/include/stdio.h"
typedef __FILE FILE;
#line 44 "/usr/include/cygwin/signal.h"
#pragma pack(push,4)
#line 101
#pragma pack(pop)
#line 38 "spec.c"
struct spec_fd_t {
   int limit ;
   int len ;
   int pos ;
   unsigned char *buf ;
};
#line 44 "/usr/include/cygwin/signal.h"
#pragma pack(push,4)
#line 101
#pragma pack(pop)
#line 1795 "bzip2.c"
struct __anonstruct_StackElem_21 {
   int ll ;
   int hh ;
   int dd ;
};
#line 1795 "bzip2.c"
typedef struct __anonstruct_StackElem_21 StackElem;
#line 1 "spec.o"
#pragma merger(0,"./spec.i","")
#line 810 "/usr/include/sys/reent.h"
extern struct _reent *( __attribute__((__cdecl__)) __getreent)(void) ;
#line 177 "/usr/include/stdio.h"
extern int ( __attribute__((__cdecl__)) fprintf)(FILE * , char const   *  , ...) ;
#line 179
extern int ( __attribute__((__cdecl__)) printf)(char const   *  , ...) ;
#line 68 "/usr/include/stdlib.h"
extern int ( __attribute__((__cdecl__)) atoi)(char const   *__nptr ) ;
#line 79
extern  __attribute__((__noreturn__)) void ( __attribute__((__cdecl__)) exit)(int __status ) ;
#line 87
extern void *( __attribute__((__cdecl__)) malloc)(size_t __size ) ;
#line 15 "/usr/include/sys/errno.h"
extern int *__errno(void) ;
#line 166 "/usr/include/sys/fcntl.h"
extern int open(char const   * , int   , ...) ;
#line 24 "/usr/include/string.h"
extern void *( __attribute__((__cdecl__)) memcpy)(void * , void const   * , size_t  ) ;
#line 26
extern void *( __attribute__((__cdecl__)) memset)(void * , int  , size_t  ) ;
#line 33
extern char *( __attribute__((__cdecl__)) strerror)(int  ) ;
#line 12 "spec.c"
unsigned char uncompressStream(int zStream , int stream ) ;
#line 13
void compressStream(int stream , int zStream ) ;
#line 14
void allocateCompressStructures(void) ;
#line 16
void spec_initbufs(void) ;
#line 17
void spec_compress(int in , int out , int lev ) ;
#line 18
void spec_uncompress(int in , int out , int lev ) ;
#line 19
int spec_init(void) ;
#line 20
int spec_random_load(int fd ) ;
#line 21
int spec_load(int num , char *filename , int size ) ;
#line 22
int spec_read(int fd , unsigned char *buf , int size ) ;
#line 23
int spec_getc(int fd ) ;
#line 24
int spec_ungetc(unsigned char ch , int fd ) ;
#line 25
int spec_rewind(int fd ) ;
#line 26
int spec_reset(int fd ) ;
#line 27
int spec_write(int fd , unsigned char *buf , int size ) ;
#line 28
int spec_putc(unsigned char ch , int fd ) ;
#line 29
int debug_time(void) ;
#line 33 "spec.c"
int dbglvl  =    4;
#line 34 "spec.c"
void debug(int level , int str ) 
{ 

  {
#line 34
  if (level < dbglvl) {
#line 34
    printf((char const   *)str);
  }
#line 34
  return;
}
}
#line 35 "spec.c"
void debug1(int level , int str , int a ) 
{ 

  {
#line 35
  if (level < dbglvl) {
#line 35
    printf((char const   *)str, a);
  }
#line 35
  return;
}
}
#line 36 "spec.c"
void debug2(int level , int str , int a , int b ) 
{ 

  {
#line 36
  if (level < dbglvl) {
#line 36
    printf((char const   *)str, a, b);
  }
#line 36
  return;
}
}
#line 37 "spec.c"
void debug3(int level , int str , int a , int b , int c ) 
{ 

  {
#line 37
  if (level < dbglvl) {
#line 37
    printf((char const   *)str, a, b, c);
  }
#line 37
  return;
}
}
#line 38 "spec.c"
struct spec_fd_t spec_fd[3]  ;
#line 45 "spec.c"
long seedi  ;
#line 46 "spec.c"
double ran(void) 
{ long lo ;
  long hi ;
  long test ;

  {
#line 52
  hi = seedi / 127773L;
#line 53
  lo = seedi % 127773L;
#line 54
  test = 16807L * lo - 2836L * hi;
#line 55
  if (test > 0L) {
#line 56
    seedi = test;
  } else {
#line 58
    seedi = test + 2147483647L;
  }
#line 60
  return ((double )((float )seedi / (float )2147483647));
}
}
#line 64 "spec.c"
int spec_init(void) 
{ int i ;
  int j ;
  int limit___0 ;
  void *tmp ;

  {
#line 68
  if (3 < dbglvl) {
#line 68
    printf("spec_init\n");
  }
#line 73
  i = 0;
#line 73
  while (i < 3) {
#line 74
    limit___0 = spec_fd[i].limit;
#line 75
    memset((void *)(& spec_fd[i]), 0, sizeof(spec_fd[0]));
#line 76
    spec_fd[i].limit = limit___0;
#line 77
    tmp = malloc((unsigned int )(limit___0 + 102400));
#line 77
    spec_fd[i].buf = (unsigned char *)tmp;
#line 78
    if ((unsigned int )spec_fd[i].buf == (unsigned int )((void *)0)) {
#line 79
      printf("spec_init: Error mallocing memory!\n");
#line 80
      exit(1);
    }
#line 82
    j = 0;
#line 82
    while (j < limit___0) {
#line 83
      *(spec_fd[i].buf + j) = (unsigned char)0;
#line 82
      j += 1024;
    }
#line 73
    i ++;
  }
#line 86
  return (0);
}
}
#line 89 "spec.c"
int spec_random_load(int fd ) 
{ int i ;
  int j ;
  char random_text[32][131072] ;
  double tmp ;
  double tmp___0 ;

  {
#line 99
  debug(4, (int )"Creating Chunks\n");
#line 102
  i = 0;
#line 102
  while (i < 32) {
#line 103
    debug1(5, (int )"Creating Chunk %d\n", i);
#line 104
    j = 0;
#line 104
    while (j < 131072) {
#line 105
      tmp = ran();
#line 105
      random_text[i][j] = (char )((int )(tmp * (double )256));
#line 104
      j ++;
    }
#line 102
    i ++;
  }
#line 109
  debug(4, (int )"Filling input file\n");
#line 111
  i = 0;
#line 111
  while (i < spec_fd[fd].limit) {
#line 112
    tmp___0 = ran();
#line 112
    memcpy((void *)(spec_fd[fd].buf + i), (void const   *)(random_text[(int )(tmp___0 * (double )32)]),
           131072U);
#line 111
    i += 131072;
  }
#line 116
  spec_fd[fd].len = 1048576;
#line 117
  return (0);
}
}
#line 130
extern int ( /* missing proto */  read)() ;
#line 138
extern int ( /* missing proto */  close)() ;
#line 120 "spec.c"
int spec_load(int num , char *filename , int size ) 
{ int fd ;
  int rc ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  struct _reent *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  struct _reent *tmp___5 ;
  int tmp___6 ;

  {
#line 123
  fd = open((char const   *)filename, 65536);
#line 124
  if (fd < 0) {
#line 125
    tmp = __errno();
#line 125
    tmp___0 = strerror(*tmp);
#line 125
    tmp___1 = __getreent();
#line 125
    fprintf(tmp___1->_stderr, "Can\'t open file %s: %s\n", filename, tmp___0);
#line 126
    exit(1);
  }
#line 128
  tmp___2 = 0;
#line 128
  spec_fd[num].len = tmp___2;
#line 128
  spec_fd[num].pos = tmp___2;
#line 129
  i = 0;
#line 129
  while (i < size) {
#line 130
    rc = read(fd, spec_fd[num].buf + i, 131072);
#line 131
    if (rc == 0) {
#line 131
      break;
    }
#line 132
    if (rc < 0) {
#line 133
      tmp___3 = __errno();
#line 133
      tmp___4 = strerror(*tmp___3);
#line 133
      tmp___5 = __getreent();
#line 133
      fprintf(tmp___5->_stderr, "Error reading from %s: %s\n", filename, tmp___4);
#line 134
      exit(1);
    }
#line 136
    spec_fd[num].len += rc;
#line 129
    i += rc;
  }
#line 138
  close(fd);
#line 139
  while (spec_fd[num].len < size) {
#line 140
    tmp___6 = size - spec_fd[num].len;
#line 141
    if (tmp___6 > spec_fd[num].len) {
#line 141
      tmp___6 = spec_fd[num].len;
    }
#line 142
    debug1(3, (int )"Duplicating %d bytes\n", tmp___6);
#line 143
    memcpy((void *)(spec_fd[num].buf + spec_fd[num].len), (void const   *)spec_fd[num].buf,
           (unsigned int )tmp___6);
#line 144
    spec_fd[num].len += tmp___6;
  }
#line 146
  return (0);
}
}
#line 149 "spec.c"
int spec_read(int fd , unsigned char *buf , int size ) 
{ int rc ;
  struct _reent *tmp ;

  {
#line 150
  rc = 0;
#line 151
  debug3(4, (int )"spec_read: %d, %p, %d = ", fd, (int )((void *)buf), size);
#line 152
  if (fd > 3) {
#line 153
    tmp = __getreent();
#line 153
    fprintf(tmp->_stderr, "spec_read: fd=%d, > 3!\n", fd);
#line 154
    exit(1);
  }
#line 156
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
#line 157
    debug(4, (int )"-1\n");
#line 158
    return (-1);
  }
#line 160
  if (spec_fd[fd].pos + size >= spec_fd[fd].len) {
#line 161
    rc = spec_fd[fd].len - spec_fd[fd].pos;
  } else {
#line 163
    rc = size;
  }
#line 165
  memcpy((void *)buf, (void const   *)(spec_fd[fd].buf + spec_fd[fd].pos), (unsigned int )rc);
#line 166
  spec_fd[fd].pos += rc;
#line 167
  debug1(4, (int )"%d\n", rc);
#line 168
  return (rc);
}
}
#line 170 "spec.c"
int spec_getc(int fd ) 
{ int rc ;
  struct _reent *tmp ;
  int tmp___0 ;

  {
#line 171
  rc = 0;
#line 172
  debug1(4, (int )"spec_getc: %d = ", fd);
#line 173
  if (fd > 3) {
#line 174
    tmp = __getreent();
#line 174
    fprintf(tmp->_stderr, "spec_read: fd=%d, > 3!\n", fd);
#line 175
    exit(1);
  }
#line 177
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
#line 178
    debug(4, (int )"-1\n");
#line 179
    return (-1);
  }
#line 181
  tmp___0 = spec_fd[fd].pos;
#line 181
  (spec_fd[fd].pos) ++;
#line 181
  rc = (int )*(spec_fd[fd].buf + tmp___0);
#line 182
  debug1(4, (int )"%d\n", rc);
#line 183
  return (rc);
}
}
#line 185 "spec.c"
int spec_ungetc(unsigned char ch , int fd ) 
{ int rc ;
  struct _reent *tmp ;
  struct _reent *tmp___0 ;
  struct _reent *tmp___1 ;

  {
#line 186
  rc = 0;
#line 187
  debug1(4, (int )"spec_ungetc: %d = ", fd);
#line 188
  if (fd > 3) {
#line 189
    tmp = __getreent();
#line 189
    fprintf(tmp->_stderr, "spec_read: fd=%d, > 3!\n", fd);
#line 190
    exit(1);
  }
#line 192
  if (spec_fd[fd].pos <= 0) {
#line 193
    tmp___0 = __getreent();
#line 193
    fprintf(tmp___0->_stderr, "spec_ungetc: pos %d <= 0\n", spec_fd[fd].pos);
#line 194
    exit(1);
  }
#line 197
  (spec_fd[fd].pos) --;
#line 197
  if ((int )*(spec_fd[fd].buf + spec_fd[fd].pos) != (int )ch) {
#line 198
    tmp___1 = __getreent();
#line 198
    fprintf(tmp___1->_stderr, "spec_ungetc: can\'t unget something that wasn\'t what was in the buffer!\n");
#line 199
    exit(1);
  }
#line 201
  debug1(4, (int )"%d\n", rc);
#line 202
  return ((int )ch);
}
}
#line 204 "spec.c"
int spec_rewind(int fd ) 
{ 

  {
#line 205
  spec_fd[fd].pos = 0;
#line 206
  return (0);
}
}
#line 208 "spec.c"
int spec_reset(int fd ) 
{ int tmp ;

  {
#line 209
  memset((void *)spec_fd[fd].buf, 0, (unsigned int )spec_fd[fd].len);
#line 210
  tmp = 0;
#line 210
  spec_fd[fd].len = tmp;
#line 210
  spec_fd[fd].pos = tmp;
#line 211
  return (0);
}
}
#line 214 "spec.c"
int spec_write(int fd , unsigned char *buf , int size ) 
{ struct _reent *tmp ;

  {
#line 215
  debug3(4, (int )"spec_write: %d, %p, %d = ", fd, (int )((void *)buf), size);
#line 216
  if (fd > 3) {
#line 217
    tmp = __getreent();
#line 217
    fprintf(tmp->_stderr, "spec_write: fd=%d, > 3!\n", fd);
#line 218
    exit(1);
  }
#line 220
  memcpy((void *)(spec_fd[fd].buf + spec_fd[fd].pos), (void const   *)buf, (unsigned int )size);
#line 221
  spec_fd[fd].len += size;
#line 222
  spec_fd[fd].pos += size;
#line 223
  debug1(4, (int )"%d\n", size);
#line 224
  return (size);
}
}
#line 226 "spec.c"
int spec_putc(unsigned char ch , int fd ) 
{ struct _reent *tmp ;
  int tmp___0 ;

  {
#line 227
  debug2(4, (int )"spec_putc: %d, %d = ", (int )ch, fd);
#line 228
  if (fd > 3) {
#line 229
    tmp = __getreent();
#line 229
    fprintf(tmp->_stderr, "spec_write: fd=%d, > 3!\n", fd);
#line 230
    exit(1);
  }
#line 232
  tmp___0 = spec_fd[fd].pos;
#line 232
  (spec_fd[fd].pos) ++;
#line 232
  *(spec_fd[fd].buf + tmp___0) = ch;
#line 233
  (spec_fd[fd].len) ++;
#line 234
  return ((int )ch);
}
}
#line 238 "spec.c"
int main(int argc , char **argv ) 
{ int i ;
  int level ;
  int input_size ;
  int compressed_size ;
  char *input_name ;
  unsigned char *validate_array ;
  void *tmp ;

  {
#line 240
  input_size = 64;
#line 242
  input_name = (char *)"F:\\output.txt";
#line 244
  seedi = 10L;
#line 246
  if (argc > 1) {
#line 246
    input_name = *(argv + 1);
  }
#line 247
  if (argc > 2) {
#line 247
    input_size = atoi((char const   *)*(argv + 2));
  }
#line 248
  if (argc > 3) {
#line 249
    compressed_size = atoi((char const   *)*(argv + 3));
  } else {
#line 251
    compressed_size = input_size;
  }
#line 253
  spec_fd[0].limit = input_size * 1048576;
#line 254
  spec_fd[1].limit = compressed_size * 1048576;
#line 255
  spec_fd[2].limit = input_size * 1048576;
#line 256
  spec_init();
#line 258
  debug_time();
#line 259
  debug(2, (int )"Loading Input Data\n");
#line 260
  spec_load(0, input_name, input_size * 1048576);
#line 261
  debug1(3, (int )"Input data %d bytes in length\n", spec_fd[0].len);
#line 263
  tmp = malloc((unsigned int )((input_size * 1048576) / 1024));
#line 263
  validate_array = (unsigned char *)tmp;
#line 264
  if ((unsigned int )validate_array == (unsigned int )((void *)0)) {
#line 265
    printf("main: Error mallocing memory!\n");
#line 266
    exit(1);
  }
#line 269
  i = 0;
#line 269
  while (i * 1027 < input_size * 1048576) {
#line 270
    *(validate_array + i) = *(spec_fd[0].buf + i * 1027);
#line 269
    i ++;
  }
#line 275
  spec_initbufs();
#line 277
  level = 7;
#line 277
  while (level <= 9) {
#line 278
    debug_time();
#line 279
    debug1(2, (int )"Compressing Input Data, level %d\n", level);
#line 281
    spec_compress(0, 1, level);
#line 283
    debug_time();
#line 284
    debug1(3, (int )"Compressed data %d bytes in length\n", spec_fd[1].len);
#line 287
    spec_reset(0);
#line 288
    spec_rewind(1);
#line 290
    debug_time();
#line 291
    debug(2, (int )"Uncompressing Data\n");
#line 292
    spec_uncompress(1, 0, level);
#line 293
    debug_time();
#line 294
    debug1(3, (int )"Uncompressed data %d bytes in length\n", spec_fd[0].len);
#line 296
    i = 0;
#line 296
    while (i * 1027 < input_size * 1048576) {
#line 297
      if ((int )*(validate_array + i) != (int )*(spec_fd[0].buf + i * 1027)) {
#line 298
        printf("Tested %dMB buffer: Miscompared!!\n", input_size);
#line 299
        exit(1);
      }
#line 296
      i ++;
    }
#line 302
    debug_time();
#line 303
    debug(3, (int )"Uncompressed data compared correctly\n");
#line 304
    spec_reset(1);
#line 305
    spec_rewind(0);
#line 277
    level += 2;
  }
#line 307
  printf("Tested %dMB buffer: OK!\n", input_size);
#line 309
  return (0);
}
}
#line 313
unsigned char smallMode ;
#line 314
int verbosity ;
#line 315
int bsStream ;
#line 316
int workFactor ;
#line 316
int blockSize100k ;
#line 317 "spec.c"
void spec_initbufs(void) 
{ 

  {
#line 318
  smallMode = (unsigned char)0;
#line 319
  verbosity = 0;
#line 320
  blockSize100k = 9;
#line 321
  bsStream = 0;
#line 322
  workFactor = 30;
#line 323
  allocateCompressStructures();
#line 324
  return;
}
}
#line 325 "spec.c"
void spec_compress(int in , int out , int lev ) 
{ 

  {
#line 326
  blockSize100k = lev;
#line 327
  compressStream(in, out);
#line 328
  return;
}
}
#line 329 "spec.c"
void spec_uncompress(int in , int out , int lev ) 
{ 

  {
#line 330
  blockSize100k = 0;
#line 331
  uncompressStream(in, out);
#line 332
  return;
}
}
#line 335 "spec.c"
int debug_time(void) 
{ 

  {
#line 336
  return (0);
}
}
#line 1 "bzip2.o"
#pragma merger(0,"./bzip2.i","")
#line 172 "/usr/include/stdio.h"
extern int ( __attribute__((__cdecl__)) fclose)(FILE * ) ;
#line 214
extern void ( __attribute__((__cdecl__)) perror)(char const   * ) ;
#line 218
extern int ( __attribute__((__cdecl__)) remove)(char const   * ) ;
#line 80 "/usr/include/stdlib.h"
extern void ( __attribute__((__cdecl__)) free)(void * ) ;
#line 120 "bzip2.c"
void ioError(void) ;
#line 122
void panic(char *s ) ;
#line 124
void compressOutOfMemory(int draw , int blockSize ) ;
#line 125
void uncompressOutOfMemory(int draw , int blockSize ) ;
#line 126
void blockOverrun(void) ;
#line 127
void badBlockHeader(void) ;
#line 128
void badBGLengths(void) ;
#line 129
void crcError(unsigned int crcStored , unsigned int crcComputed ) ;
#line 130
void bitStreamEOF(void) ;
#line 131
void cleanUpAndFail(int ec ) ;
#line 132
void compressedStreamEOF(void) ;
#line 136 "bzip2.c"
void ERROR_IF_EOF(int i ) 
{ 

  {
#line 136
  if (i == -1) {
#line 136
    ioError();
  }
#line 136
  return;
}
}
#line 137 "bzip2.c"
void ERROR_IF_NOT_ZERO(int i ) 
{ 

  {
#line 137
  if (i != 0) {
#line 137
    ioError();
  }
#line 137
  return;
}
}
#line 138 "bzip2.c"
void ERROR_IF_MINUS_ONE(int i ) 
{ 

  {
#line 138
  if (i == -1) {
#line 138
    ioError();
  }
#line 138
  return;
}
}
#line 288 "bzip2.c"
unsigned int bytesIn  ;
#line 288 "bzip2.c"
unsigned int bytesOut  ;
#line 290 "bzip2.c"
int verbosity  ;
#line 292 "bzip2.c"
unsigned char keepInputFiles  ;
#line 292 "bzip2.c"
unsigned char smallMode  ;
#line 292 "bzip2.c"
unsigned char testFailsExist  ;
#line 293 "bzip2.c"
unsigned int globalCrc  ;
#line 294 "bzip2.c"
int numFileNames  =    0;
#line 294 "bzip2.c"
int numFilesProcessed  =    0;
#line 303 "bzip2.c"
int opMode  ;
#line 304 "bzip2.c"
int srcMode  ;
#line 307 "bzip2.c"
int longestFileName  ;
#line 308 "bzip2.c"
char inName[1024]  ;
#line 309 "bzip2.c"
char outName[1024]  ;
#line 310 "bzip2.c"
char *progName  ;
#line 311 "bzip2.c"
char progNameReally[1024]  ;
#line 312 "bzip2.c"
int outputHandleJustInCase  ;
#line 314 "bzip2.c"
int syf  ;
#line 316 "bzip2.c"
int yk_j  =    0;
#line 352 "bzip2.c"
unsigned char *block  ;
#line 353 "bzip2.c"
unsigned int *quadrant  ;
#line 354 "bzip2.c"
int *zptr  ;
#line 355 "bzip2.c"
unsigned int *szptr  ;
#line 356 "bzip2.c"
int *ftab  ;
#line 358 "bzip2.c"
unsigned int *ll16  ;
#line 359 "bzip2.c"
unsigned char *ll4  ;
#line 361 "bzip2.c"
int *tt  ;
#line 362 "bzip2.c"
unsigned char *ll8  ;
#line 369 "bzip2.c"
int unzftab[256]  ;
#line 376 "bzip2.c"
int last  ;
#line 382 "bzip2.c"
int origPtr  ;
#line 390 "bzip2.c"
int blockSize100k  ;
#line 401 "bzip2.c"
int workFactor  ;
#line 403 "bzip2.c"
int workDone  ;
#line 404 "bzip2.c"
int workLimit  ;
#line 405 "bzip2.c"
unsigned char blockRandomised  ;
#line 406 "bzip2.c"
unsigned char firstAttempt  ;
#line 407 "bzip2.c"
int nBlocksRandomised  ;
#line 421 "bzip2.c"
unsigned char inUse[256]  ;
#line 422 "bzip2.c"
int nInUse  ;
#line 424 "bzip2.c"
unsigned char seqToUnseq[256]  ;
#line 425 "bzip2.c"
unsigned char unseqToSeq[256]  ;
#line 427 "bzip2.c"
unsigned char selector[18002]  ;
#line 428 "bzip2.c"
unsigned char selectorMtf[18002]  ;
#line 430 "bzip2.c"
int nMTF  ;
#line 432 "bzip2.c"
int mtfFreq[258]  ;
#line 434 "bzip2.c"
unsigned char len[6][258]  ;
#line 437 "bzip2.c"
int limit[6][258]  ;
#line 438 "bzip2.c"
int base[6][258]  ;
#line 439 "bzip2.c"
int perm[6][258]  ;
#line 440 "bzip2.c"
int minLens[6]  ;
#line 443 "bzip2.c"
int code[6][258]  ;
#line 444 "bzip2.c"
int rfreq[6][258]  ;
#line 458 "bzip2.c"
unsigned int crc32Table[256]  = 
#line 458
  {      0U,      79764919U,      159529838U,      222504665U, 
        319059676U,      398814059U,      445009330U,      507990021U, 
        638119352U,      583659535U,      797628118U,      726387553U, 
        890018660U,      835552979U,      1015980042U,      944750013U, 
        1276238704U,      1221641927U,      1167319070U,      1095957929U, 
        1595256236U,      1540665371U,      1452775106U,      1381403509U, 
        1780037320U,      1859660671U,      1671105958U,      1733955601U, 
        2031960084U,      2111593891U,      1889500026U,      1952343757U, 
        2552477408U,      2632100695U,      2443283854U,      2506133561U, 
        2334638140U,      2414271883U,      2191915858U,      2254759653U, 
        3190512472U,      3135915759U,      3081330742U,      3009969537U, 
        2905550212U,      2850959411U,      2762807018U,      2691435357U, 
        3560074640U,      3505614887U,      3719321342U,      3648080713U, 
        3342211916U,      3287746299U,      3467911202U,      3396681109U, 
        4063920168U,      4143685023U,      4223187782U,      4286162673U, 
        3779000052U,      3858754371U,      3904687514U,      3967668269U, 
        881225847U,      809987520U,      1023691545U,      969234094U, 
        662832811U,      591600412U,      771767749U,      717299826U, 
        311336399U,      374308984U,      453813921U,      533576470U, 
        25881363U,      88864420U,      134795389U,      214552010U, 
        2023205639U,      2086057648U,      1897238633U,      1976864222U, 
        1804852699U,      1867694188U,      1645340341U,      1724971778U, 
        1587496639U,      1516133128U,      1461550545U,      1406951526U, 
        1302016099U,      1230646740U,      1142491917U,      1087903418U, 
        2896545431U,      2825181984U,      2770861561U,      2716262478U, 
        3215044683U,      3143675388U,      3055782693U,      3001194130U, 
        2326604591U,      2389456536U,      2200899649U,      2280525302U, 
        2578013683U,      2640855108U,      2418763421U,      2498394922U, 
        3769900519U,      3832873040U,      3912640137U,      3992402750U, 
        4088425275U,      4151408268U,      4197601365U,      4277358050U, 
        3334271071U,      3263032808U,      3476998961U,      3422541446U, 
        3585640067U,      3514407732U,      3694837229U,      3640369242U, 
        1762451694U,      1842216281U,      1619975040U,      1682949687U, 
        2047383090U,      2127137669U,      1938468188U,      2001449195U, 
        1325665622U,      1271206113U,      1183200824U,      1111960463U, 
        1543535498U,      1489069629U,      1434599652U,      1363369299U, 
        622672798U,      568075817U,      748617968U,      677256519U, 
        907627842U,      853037301U,      1067152940U,      995781531U, 
        51762726U,      131386257U,      177728840U,      240578815U, 
        269590778U,      349224269U,      429104020U,      491947555U, 
        4046411278U,      4126034873U,      4172115296U,      4234965207U, 
        3794477266U,      3874110821U,      3953728444U,      4016571915U, 
        3609705398U,      3555108353U,      3735388376U,      3664026991U, 
        3290680682U,      3236090077U,      3449943556U,      3378572211U, 
        3174993278U,      3120533705U,      3032266256U,      2961025959U, 
        2923101090U,      2868635157U,      2813903052U,      2742672763U, 
        2604032198U,      2683796849U,      2461293480U,      2524268063U, 
        2284983834U,      2364738477U,      2175806836U,      2238787779U, 
        1569362073U,      1498123566U,      1409854455U,      1355396672U, 
        1317987909U,      1246755826U,      1192025387U,      1137557660U, 
        2072149281U,      2135122070U,      1912620623U,      1992383480U, 
        1753615357U,      1816598090U,      1627664531U,      1707420964U, 
        295390185U,      358241886U,      404320391U,      483945776U, 
        43990325U,      106832002U,      186451547U,      266083308U, 
        932423249U,      861060070U,      1041341759U,      986742920U, 
        613929101U,      542559546U,      756411363U,      701822548U, 
        3316196985U,      3244833742U,      3425377559U,      3370778784U, 
        3601682597U,      3530312978U,      3744426955U,      3689838204U, 
        3819031489U,      3881883254U,      3928223919U,      4007849240U, 
        4037393693U,      4100235434U,      4180117107U,      4259748804U, 
        2310601993U,      2373574846U,      2151335527U,      2231098320U, 
        2596047829U,      2659030626U,      2470359227U,      2550115596U, 
        2947551409U,      2876312838U,      2788305887U,      2733848168U, 
        3165939309U,      3094707162U,      3040238851U,      2985771188U};
#line 530 "bzip2.c"
void initialiseCRC(void) 
{ 

  {
#line 532
  globalCrc = 4294967295U;
#line 533
  return;
}
}
#line 537 "bzip2.c"
unsigned int getFinalCRC(void) 
{ 

  {
#line 539
  return (~ globalCrc);
}
}
#line 544 "bzip2.c"
unsigned int getGlobalCRC(void) 
{ 

  {
#line 546
  return (globalCrc);
}
}
#line 551 "bzip2.c"
void setGlobalCRC(unsigned int newCrc ) 
{ 

  {
#line 553
  globalCrc = newCrc;
#line 554
  return;
}
}
#line 564 "bzip2.c"
unsigned int bsBuff  ;
#line 565 "bzip2.c"
int bsLive  ;
#line 566 "bzip2.c"
int bsStream  ;
#line 568 "bzip2.c"
unsigned char bsWriting  ;
#line 572 "bzip2.c"
void bsSetStream(int f , unsigned char wr ) 
{ 

  {
#line 574
  bsStream = f;
#line 575
  bsLive = 0;
#line 576
  bsBuff = 0U;
#line 577
  bytesOut = 0U;
#line 578
  bytesIn = 0U;
#line 579
  bsWriting = wr;
#line 580
  return;
}
}
#line 584 "bzip2.c"
void bsFinishedWithStream(void) 
{ 

  {
#line 586
  if (bsWriting) {
#line 587
    while (bsLive > 0) {
#line 588
      spec_putc((unsigned char )(bsBuff >> 24), bsStream);
#line 589
      bsBuff <<= 8;
#line 590
      bsLive -= 8;
#line 591
      bytesOut ++;
    }
  }
#line 594
  bsStream = 0;
#line 596
  return;
}
}
#line 606 "bzip2.c"
unsigned int bsR(int n ) 
{ unsigned int v ;
  int zzi ;
  int tmp ;

  {
#line 609
  while (bsLive < n) {
#line 611
    tmp = spec_getc(bsStream);
#line 611
    zzi = tmp;
#line 612
    if (zzi == -1) {
#line 612
      compressedStreamEOF();
    }
#line 613
    bsBuff = (bsBuff << 8) | (unsigned int )(zzi & 255);
#line 614
    bsLive += 8;
  }
#line 616
  v = (bsBuff >> (bsLive - n)) & (unsigned int )((1 << n) - 1);
#line 617
  bsLive -= n;
#line 618
  return (v);
}
}
#line 623 "bzip2.c"
void bsW(int n , unsigned int v ) 
{ 

  {
#line 625
  while (bsLive >= 8) {
#line 626
    spec_putc((unsigned char )(bsBuff >> 24), bsStream);
#line 628
    bsBuff <<= 8;
#line 629
    bsLive -= 8;
#line 630
    bytesOut ++;
  }
#line 632
  bsBuff |= v << ((32 - bsLive) - n);
#line 633
  bsLive += n;
#line 634
  return;
}
}
#line 638 "bzip2.c"
unsigned char bsGetUChar(void) 
{ unsigned int tmp ;

  {
#line 640
  tmp = bsR(8);
#line 640
  return ((unsigned char )tmp);
}
}
#line 645 "bzip2.c"
void bsPutUChar(unsigned char c ) 
{ 

  {
#line 647
  bsW(8, (unsigned int )c);
#line 648
  return;
}
}
#line 652 "bzip2.c"
int bsGetUInt32(void) 
{ unsigned int u ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 655
  u = 0U;
#line 656
  tmp = bsR(8);
#line 656
  u = (u << 8) | tmp;
#line 657
  tmp___0 = bsR(8);
#line 657
  u = (u << 8) | tmp___0;
#line 658
  tmp___1 = bsR(8);
#line 658
  u = (u << 8) | tmp___1;
#line 659
  tmp___2 = bsR(8);
#line 659
  u = (u << 8) | tmp___2;
#line 660
  return ((int )u);
}
}
#line 665 "bzip2.c"
unsigned int bsGetIntVS(unsigned int numBits ) 
{ unsigned int tmp ;

  {
#line 667
  tmp = bsR((int )numBits);
#line 667
  return (tmp);
}
}
#line 672 "bzip2.c"
unsigned int bsGetInt32(void) 
{ int tmp ;

  {
#line 674
  tmp = bsGetUInt32();
#line 674
  return ((unsigned int )tmp);
}
}
#line 679 "bzip2.c"
void bsPutUInt32(unsigned int u ) 
{ 

  {
#line 681
  bsW(8, (u >> 24) & 255U);
#line 682
  bsW(8, (u >> 16) & 255U);
#line 683
  bsW(8, (u >> 8) & 255U);
#line 684
  bsW(8, u & 255U);
#line 685
  return;
}
}
#line 689 "bzip2.c"
void bsPutInt32(int c ) 
{ 

  {
#line 691
  bsPutUInt32((unsigned int )c);
#line 692
  return;
}
}
#line 696 "bzip2.c"
void bsPutIntVS(int numBits , unsigned int c ) 
{ 

  {
#line 698
  bsW(numBits, c);
#line 699
  return;
}
}
#line 711 "bzip2.c"
void hbMakeCodeLengths(unsigned char *len___0 , int *freq , int alphaSize , int maxLen ) 
{ int nNodes ;
  int nHeap ;
  int n1 ;
  int n2 ;
  int i ;
  int j ;
  int k ;
  unsigned char tooLong ;
  int heap[260] ;
  int weight[516] ;
  int parent[516] ;
  int tmp ;
  int zz ;
  int tmp___0 ;
  int zz___0 ;
  int yy ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 727
  i = 0;
#line 727
  while (i < alphaSize) {
#line 728
    if (*(freq + i) == 0) {
#line 728
      tmp = 1;
    } else {
#line 728
      tmp = *(freq + i);
    }
#line 728
    weight[i + 1] = tmp << 8;
#line 727
    i ++;
  }
#line 730
  while (1) {
#line 732
    nNodes = alphaSize;
#line 733
    nHeap = 0;
#line 735
    heap[0] = 0;
#line 736
    weight[0] = 0;
#line 737
    parent[0] = -2;
#line 739
    i = 1;
#line 739
    while (i <= alphaSize) {
#line 740
      parent[i] = -1;
#line 741
      nHeap ++;
#line 742
      heap[nHeap] = i;
#line 746
      zz = nHeap;
#line 746
      tmp___0 = heap[zz];
#line 747
      while (weight[tmp___0] < weight[heap[zz >> 1]]) {
#line 748
        heap[zz] = heap[zz >> 1];
#line 749
        zz >>= 1;
      }
#line 751
      heap[zz] = tmp___0;
#line 739
      i ++;
    }
#line 753
    if (! (nHeap < 260)) {
#line 754
      panic((char *)"hbMakeCodeLengths(1)");
    }
#line 756
    while (nHeap > 1) {
#line 757
      n1 = heap[1];
#line 757
      heap[1] = heap[nHeap];
#line 757
      nHeap --;
#line 761
      zz___0 = 1;
#line 761
      tmp___1 = heap[zz___0];
#line 762
      while (1) {
#line 763
        yy = zz___0 << 1;
#line 764
        if (yy > nHeap) {
#line 764
          break;
        }
#line 765
        if (yy < nHeap) {
#line 765
          if (weight[heap[yy + 1]] < weight[heap[yy]]) {
#line 767
            yy ++;
          }
        }
#line 768
        if (weight[tmp___1] < weight[heap[yy]]) {
#line 768
          break;
        }
#line 769
        heap[zz___0] = heap[yy];
#line 770
        zz___0 = yy;
      }
#line 772
      heap[zz___0] = tmp___1;
#line 773
      n2 = heap[1];
#line 773
      heap[1] = heap[nHeap];
#line 773
      nHeap --;
#line 777
      zz___0 = 1;
#line 777
      tmp___1 = heap[zz___0];
#line 778
      while (1) {
#line 779
        yy = zz___0 << 1;
#line 780
        if (yy > nHeap) {
#line 780
          break;
        }
#line 781
        if (yy < nHeap) {
#line 781
          if (weight[heap[yy + 1]] < weight[heap[yy]]) {
#line 783
            yy ++;
          }
        }
#line 784
        if (weight[tmp___1] < weight[heap[yy]]) {
#line 784
          break;
        }
#line 785
        heap[zz___0] = heap[yy];
#line 786
        zz___0 = yy;
      }
#line 788
      heap[zz___0] = tmp___1;
#line 791
      nNodes ++;
#line 792
      tmp___2 = nNodes;
#line 792
      parent[n2] = tmp___2;
#line 792
      parent[n1] = tmp___2;
#line 794
      if (1 + (weight[n1] & 255) > (weight[n2] & 255)) {
#line 794
        tmp___3 = weight[n1] & 255;
      } else {
#line 794
        tmp___3 = weight[n2] & 255;
      }
#line 794
      weight[nNodes] = (int )((((unsigned int )weight[n1] & 4294967040U) + ((unsigned int )weight[n2] & 4294967040U)) | (unsigned int )tmp___3);
#line 797
      parent[nNodes] = -1;
#line 798
      nHeap ++;
#line 799
      heap[nHeap] = nNodes;
#line 803
      zz___0 = nHeap;
#line 803
      tmp___1 = heap[zz___0];
#line 804
      while (weight[tmp___1] < weight[heap[zz___0 >> 1]]) {
#line 805
        heap[zz___0] = heap[zz___0 >> 1];
#line 806
        zz___0 >>= 1;
      }
#line 808
      heap[zz___0] = tmp___1;
    }
#line 810
    if (! (nNodes < 516)) {
#line 811
      panic((char *)"hbMakeCodeLengths(2)");
    }
#line 813
    tooLong = (unsigned char)0;
#line 814
    i = 1;
#line 814
    while (i <= alphaSize) {
#line 815
      j = 0;
#line 816
      k = i;
#line 817
      while (parent[k] >= 0) {
#line 817
        k = parent[k];
#line 817
        j ++;
      }
#line 818
      *(len___0 + (i - 1)) = (unsigned char )j;
#line 819
      if (j > maxLen) {
#line 819
        tooLong = (unsigned char)1;
      }
#line 814
      i ++;
    }
#line 822
    if (! tooLong) {
#line 822
      break;
    }
#line 824
    i = 1;
#line 824
    while (i < alphaSize) {
#line 825
      j = weight[i] >> 8;
#line 826
      j = 1 + j / 2;
#line 827
      weight[i] = j << 8;
#line 824
      i ++;
    }
  }
#line 830
  return;
}
}
#line 834 "bzip2.c"
void hbAssignCodes(int *code___0 , unsigned char *length , int minLen , int maxLen ,
                   int alphaSize ) 
{ int n ;
  int vec ;
  int i ;

  {
#line 842
  vec = 0;
#line 843
  n = minLen;
#line 843
  while (n <= maxLen) {
#line 844
    i = 0;
#line 844
    while (i < alphaSize) {
#line 845
      if ((int )*(length + i) == n) {
#line 845
        *(code___0 + i) = vec;
#line 845
        vec ++;
      }
#line 844
      i ++;
    }
#line 846
    vec <<= 1;
#line 843
    n ++;
  }
#line 848
  return;
}
}
#line 852 "bzip2.c"
void hbCreateDecodeTables(int *limit___0 , int *base___0 , int *perm___0 , unsigned char *length ,
                          int minLen , int maxLen , int alphaSize ) 
{ int pp ;
  int i ;
  int j ;
  int vec ;

  {
#line 862
  pp = 0;
#line 863
  i = minLen;
#line 863
  while (i <= maxLen) {
#line 864
    j = 0;
#line 864
    while (j < alphaSize) {
#line 865
      if ((int )*(length + j) == i) {
#line 865
        *(perm___0 + pp) = j;
#line 865
        pp ++;
      }
#line 864
      j ++;
    }
#line 863
    i ++;
  }
#line 867
  i = 0;
#line 867
  while (i < 23) {
#line 867
    *(base___0 + i) = 0;
#line 867
    i ++;
  }
#line 868
  i = 0;
#line 868
  while (i < alphaSize) {
#line 868
    (*(base___0 + ((int )*(length + i) + 1))) ++;
#line 868
    i ++;
  }
#line 870
  i = 1;
#line 870
  while (i < 23) {
#line 870
    *(base___0 + i) += *(base___0 + (i - 1));
#line 870
    i ++;
  }
#line 872
  i = 0;
#line 872
  while (i < 23) {
#line 872
    *(limit___0 + i) = 0;
#line 872
    i ++;
  }
#line 873
  vec = 0;
#line 875
  i = minLen;
#line 875
  while (i <= maxLen) {
#line 876
    vec += *(base___0 + (i + 1)) - *(base___0 + i);
#line 877
    *(limit___0 + i) = vec - 1;
#line 878
    vec <<= 1;
#line 875
    i ++;
  }
#line 880
  i = minLen + 1;
#line 880
  while (i <= maxLen) {
#line 881
    *(base___0 + i) = ((*(limit___0 + (i - 1)) + 1) << 1) - *(base___0 + i);
#line 880
    i ++;
  }
#line 882
  return;
}
}
#line 891 "bzip2.c"
void SET_LL4(int i , int n ) 
{ 

  {
#line 892
  if ((i & 1) == 0) {
#line 893
    *(ll4 + (i >> 1)) = (unsigned char )(((int )*(ll4 + (i >> 1)) & 240) | n);
  } else {
#line 895
    *(ll4 + (i >> 1)) = (unsigned char )(((int )*(ll4 + (i >> 1)) & 15) | (n << 4));
  }
#line 896
  return;
}
}
#line 917 "bzip2.c"
void allocateCompressStructures(void) 
{ int n ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int totalDraw ;

  {
#line 919
  n = 100000 * blockSize100k;
#line 920
  tmp = malloc((unsigned int )((n + 1) + 20) * sizeof(unsigned char ));
#line 920
  block = (unsigned char *)tmp;
#line 921
  tmp___0 = malloc((unsigned int )((n + 20) * 16));
#line 921
  quadrant = (unsigned int *)tmp___0;
#line 922
  tmp___1 = malloc((unsigned int )n * sizeof(int ));
#line 922
  zptr = (int *)tmp___1;
#line 923
  tmp___2 = malloc(65537U * sizeof(int ));
#line 923
  ftab = (int *)tmp___2;
#line 925
  if ((unsigned int )block == (unsigned int )((void *)0)) {
#line 927
    totalDraw = (int )((((unsigned int )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned int )((n + 20) * 16)) + (unsigned int )n * sizeof(int )) + 65537U * sizeof(int ));
#line 933
    compressOutOfMemory(totalDraw, n);
  } else {
#line 925
    if ((unsigned int )quadrant == (unsigned int )((void *)0)) {
#line 927
      totalDraw = (int )((((unsigned int )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned int )((n + 20) * 16)) + (unsigned int )n * sizeof(int )) + 65537U * sizeof(int ));
#line 933
      compressOutOfMemory(totalDraw, n);
    } else {
#line 925
      if ((unsigned int )zptr == (unsigned int )((void *)0)) {
#line 927
        totalDraw = (int )((((unsigned int )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned int )((n + 20) * 16)) + (unsigned int )n * sizeof(int )) + 65537U * sizeof(int ));
#line 933
        compressOutOfMemory(totalDraw, n);
      } else {
#line 925
        if ((unsigned int )ftab == (unsigned int )((void *)0)) {
#line 927
          totalDraw = (int )((((unsigned int )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned int )((n + 20) * 16)) + (unsigned int )n * sizeof(int )) + 65537U * sizeof(int ));
#line 933
          compressOutOfMemory(totalDraw, n);
        }
      }
    }
  }
#line 941
  block ++;
#line 953
  szptr = (unsigned int *)zptr;
#line 954
  return;
}
}
#line 958 "bzip2.c"
void setDecompressStructureSizes(int newSize100k ) 
{ int n ;
  void *tmp ;
  void *tmp___0 ;
  int totalDraw ;
  int n___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int totalDraw___0 ;

  {
#line 960
  if (0 <= newSize100k) {
#line 960
    if (newSize100k <= 9) {
#line 960
      if (0 <= blockSize100k) {
#line 960
        if (! (blockSize100k <= 9)) {
#line 962
          panic((char *)"setDecompressStructureSizes");
        }
      } else {
#line 962
        panic((char *)"setDecompressStructureSizes");
      }
    } else {
#line 962
      panic((char *)"setDecompressStructureSizes");
    }
  } else {
#line 962
    panic((char *)"setDecompressStructureSizes");
  }
#line 964
  if (newSize100k == blockSize100k) {
#line 964
    return;
  }
#line 966
  blockSize100k = newSize100k;
#line 968
  if ((unsigned int )ll16 != (unsigned int )((void *)0)) {
#line 968
    free((void *)ll16);
  }
#line 969
  if ((unsigned int )ll4 != (unsigned int )((void *)0)) {
#line 969
    free((void *)ll4);
  }
#line 970
  if ((unsigned int )ll8 != (unsigned int )((void *)0)) {
#line 970
    free((void *)ll8);
  }
#line 971
  if ((unsigned int )tt != (unsigned int )((void *)0)) {
#line 971
    free((void *)tt);
  }
#line 973
  if (newSize100k == 0) {
#line 973
    return;
  }
#line 975
  if (smallMode) {
#line 977
    n = 100000 * newSize100k;
#line 978
    tmp = malloc((unsigned int )n * sizeof(unsigned int ));
#line 978
    ll16 = (unsigned int *)tmp;
#line 979
    tmp___0 = malloc((unsigned int )((n + 1) >> 1) * sizeof(unsigned char ));
#line 979
    ll4 = (unsigned char *)tmp___0;
#line 981
    if ((unsigned int )ll4 == (unsigned int )((void *)0)) {
#line 982
      totalDraw = (int )((unsigned int )(n * 16) + (unsigned int )((n + 1) >> 1) * sizeof(unsigned char ));
#line 984
      uncompressOutOfMemory(totalDraw, n);
    } else {
#line 981
      if ((unsigned int )ll16 == (unsigned int )((void *)0)) {
#line 982
        totalDraw = (int )((unsigned int )(n * 16) + (unsigned int )((n + 1) >> 1) * sizeof(unsigned char ));
#line 984
        uncompressOutOfMemory(totalDraw, n);
      }
    }
  } else {
#line 989
    n___0 = 100000 * newSize100k;
#line 990
    tmp___1 = malloc((unsigned int )n___0 * sizeof(unsigned char ));
#line 990
    ll8 = (unsigned char *)tmp___1;
#line 991
    tmp___2 = malloc((unsigned int )n___0 * sizeof(int ));
#line 991
    tt = (int *)tmp___2;
#line 993
    if ((unsigned int )ll8 == (unsigned int )((void *)0)) {
#line 994
      totalDraw___0 = (int )((unsigned int )n___0 * sizeof(unsigned char ) + (unsigned int )n___0 * sizeof(unsigned int ));
#line 996
      uncompressOutOfMemory(totalDraw___0, n___0);
    } else {
#line 993
      if ((unsigned int )tt == (unsigned int )((void *)0)) {
#line 994
        totalDraw___0 = (int )((unsigned int )n___0 * sizeof(unsigned char ) + (unsigned int )n___0 * sizeof(unsigned int ));
#line 996
        uncompressOutOfMemory(totalDraw___0, n___0);
      }
    }
  }
#line 1000
  return;
}
}
#line 1009 "bzip2.c"
void makeMaps(void) 
{ int i ;

  {
#line 1012
  nInUse = 0;
#line 1013
  i = 0;
#line 1013
  while (i < 256) {
#line 1014
    if (inUse[i]) {
#line 1015
      seqToUnseq[nInUse] = (unsigned char )i;
#line 1016
      unseqToSeq[i] = (unsigned char )nInUse;
#line 1017
      nInUse ++;
    }
#line 1013
    i ++;
  }
#line 1019
  return;
}
}
#line 1023 "bzip2.c"
void generateMTFValues(void) 
{ unsigned char yy[256] ;
  int i ;
  int j ;
  unsigned char tmp ;
  unsigned char tmp2 ;
  int zPend ;
  int wr ;
  int EOB ;
  unsigned char ll_i ;

  {
#line 1033
  makeMaps();
#line 1034
  EOB = nInUse + 1;
#line 1036
  i = 0;
#line 1036
  while (i <= EOB) {
#line 1036
    mtfFreq[i] = 0;
#line 1036
    i ++;
  }
#line 1038
  wr = 0;
#line 1039
  zPend = 0;
#line 1040
  i = 0;
#line 1040
  while (i < nInUse) {
#line 1040
    yy[i] = (unsigned char )i;
#line 1040
    i ++;
  }
#line 1043
  i = 0;
#line 1043
  while (i <= last) {
#line 1048
    ll_i = unseqToSeq[*(block + (*(zptr + i) - 1))];
#line 1050
    j = 0;
#line 1051
    tmp = yy[j];
#line 1052
    while ((int )ll_i != (int )tmp) {
#line 1053
      j ++;
#line 1054
      tmp2 = tmp;
#line 1055
      tmp = yy[j];
#line 1056
      yy[j] = tmp2;
    }
#line 1058
    yy[0] = tmp;
#line 1060
    if (j == 0) {
#line 1061
      zPend ++;
    } else {
#line 1063
      if (zPend > 0) {
#line 1064
        zPend --;
#line 1065
        while (1) {
#line 1066
          switch (zPend % 2) {
          case 0: 
#line 1067
          *(szptr + wr) = 0U;
#line 1067
          wr ++;
#line 1067
          (mtfFreq[0]) ++;
#line 1067
          break;
          case 1: 
#line 1068
          *(szptr + wr) = 1U;
#line 1068
          wr ++;
#line 1068
          (mtfFreq[1]) ++;
#line 1068
          break;
          }
#line 1070
          if (zPend < 2) {
#line 1070
            break;
          }
#line 1071
          zPend = (zPend - 2) / 2;
        }
#line 1073
        zPend = 0;
      }
#line 1075
      *(szptr + wr) = (unsigned int )(j + 1);
#line 1075
      wr ++;
#line 1075
      (mtfFreq[j + 1]) ++;
    }
#line 1043
    i ++;
  }
#line 1079
  if (zPend > 0) {
#line 1080
    zPend --;
#line 1081
    while (1) {
#line 1082
      switch (zPend % 2) {
      case 0: 
#line 1083
      *(szptr + wr) = 0U;
#line 1083
      wr ++;
#line 1083
      (mtfFreq[0]) ++;
#line 1083
      break;
      case 1: 
#line 1084
      *(szptr + wr) = 1U;
#line 1084
      wr ++;
#line 1084
      (mtfFreq[1]) ++;
#line 1084
      break;
      }
#line 1086
      if (zPend < 2) {
#line 1086
        break;
      }
#line 1087
      zPend = (zPend - 2) / 2;
    }
  }
#line 1091
  *(szptr + wr) = (unsigned int )EOB;
#line 1091
  wr ++;
#line 1091
  (mtfFreq[EOB]) ++;
#line 1093
  nMTF = wr;
#line 1094
  return;
}
}
#line 1098 "bzip2.c"
void sendMTFValues(void) 
{ int v ;
  int t ;
  int i ;
  int j ;
  int gs ;
  int ge ;
  int totc ;
  int bt ;
  int bc ;
  int iter ;
  int nSelectors ;
  int alphaSize ;
  int minLen ;
  int maxLen ;
  int selCtr ;
  int nGroups ;
  int nBytes ;
  unsigned int cost[6] ;
  int fave[6] ;
  struct _reent *tmp ;
  int nPart ;
  int remF ;
  int tFreq ;
  int aFreq ;
  struct _reent *tmp___0 ;
  unsigned int cost0 ;
  unsigned int cost1 ;
  unsigned int cost2 ;
  unsigned int cost3 ;
  unsigned int cost4 ;
  unsigned int cost5 ;
  unsigned int icv ;
  unsigned int icv___0 ;
  struct _reent *tmp___1 ;
  struct _reent *tmp___2 ;
  struct _reent *tmp___3 ;
  unsigned char pos[6] ;
  unsigned char ll_i ;
  unsigned char tmp2 ;
  unsigned char tmp___4 ;
  unsigned char inUse16[16] ;
  struct _reent *tmp___5 ;
  struct _reent *tmp___6 ;
  int curr ;
  struct _reent *tmp___7 ;
  struct _reent *tmp___8 ;

  {
#line 1118
  if (verbosity >= 3) {
#line 1119
    tmp = __getreent();
#line 1119
    fprintf(tmp->_stderr, "      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\n",
            last + 1, nMTF, nInUse);
  }
#line 1123
  alphaSize = nInUse + 2;
#line 1124
  t = 0;
#line 1124
  while (t < 6) {
#line 1125
    v = 0;
#line 1125
    while (v < alphaSize) {
#line 1126
      len[t][v] = (unsigned char)15;
#line 1125
      v ++;
    }
#line 1124
    t ++;
  }
#line 1129
  if (nMTF <= 0) {
#line 1129
    panic((char *)"sendMTFValues(0)");
  }
#line 1130
  if (nMTF < 200) {
#line 1130
    nGroups = 2;
  } else {
#line 1131
    if (nMTF < 800) {
#line 1131
      nGroups = 4;
    } else {
#line 1132
      nGroups = 6;
    }
  }
#line 1138
  nPart = nGroups;
#line 1139
  remF = nMTF;
#line 1140
  gs = 0;
#line 1141
  while (nPart > 0) {
#line 1142
    tFreq = remF / nPart;
#line 1143
    ge = gs - 1;
#line 1144
    aFreq = 0;
#line 1145
    while (1) {
#line 1145
      if (aFreq < tFreq) {
#line 1145
        if (! (ge < alphaSize - 1)) {
#line 1145
          break;
        }
      } else {
#line 1145
        break;
      }
#line 1146
      ge ++;
#line 1147
      aFreq += mtfFreq[ge];
    }
#line 1150
    if (ge > gs) {
#line 1150
      if (nPart != nGroups) {
#line 1150
        if (nPart != 1) {
#line 1150
          if ((nGroups - nPart) % 2 == 1) {
#line 1153
            aFreq -= mtfFreq[ge];
#line 1154
            ge --;
          }
        }
      }
    }
#line 1157
    if (verbosity >= 3) {
#line 1158
      tmp___0 = __getreent();
#line 1158
      fprintf(tmp___0->_stderr, "      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\n",
              nPart, gs, ge, aFreq, (100.0 * (double )((float )aFreq)) / (double )((float )nMTF));
    }
#line 1163
    v = 0;
#line 1163
    while (v < alphaSize) {
#line 1164
      if (v >= gs) {
#line 1164
        if (v <= ge) {
#line 1165
          len[nPart - 1][v] = (unsigned char)0;
        } else {
#line 1166
          len[nPart - 1][v] = (unsigned char)15;
        }
      } else {
#line 1166
        len[nPart - 1][v] = (unsigned char)15;
      }
#line 1163
      v ++;
    }
#line 1168
    nPart --;
#line 1169
    gs = ge + 1;
#line 1170
    remF -= aFreq;
  }
#line 1177
  iter = 0;
#line 1177
  while (iter < 4) {
#line 1179
    t = 0;
#line 1179
    while (t < nGroups) {
#line 1179
      fave[t] = 0;
#line 1179
      t ++;
    }
#line 1181
    t = 0;
#line 1181
    while (t < nGroups) {
#line 1182
      v = 0;
#line 1182
      while (v < alphaSize) {
#line 1183
        rfreq[t][v] = 0;
#line 1182
        v ++;
      }
#line 1181
      t ++;
    }
#line 1185
    nSelectors = 0;
#line 1186
    totc = 0;
#line 1187
    gs = 0;
#line 1188
    while (! (gs >= nMTF)) {
#line 1192
      ge = (gs + 50) - 1;
#line 1193
      if (ge >= nMTF) {
#line 1193
        ge = nMTF - 1;
      }
#line 1199
      t = 0;
#line 1199
      while (t < nGroups) {
#line 1199
        cost[t] = 0U;
#line 1199
        t ++;
      }
#line 1201
      if (nGroups == 6) {
#line 1203
        cost5 = 0U;
#line 1203
        cost4 = cost5;
#line 1203
        cost3 = cost4;
#line 1203
        cost2 = cost3;
#line 1203
        cost1 = cost2;
#line 1203
        cost0 = cost1;
#line 1204
        i = gs;
#line 1204
        while (i <= ge) {
#line 1205
          icv = *(szptr + i);
#line 1206
          cost0 += (unsigned int )len[0][icv];
#line 1207
          cost1 += (unsigned int )len[1][icv];
#line 1208
          cost2 += (unsigned int )len[2][icv];
#line 1209
          cost3 += (unsigned int )len[3][icv];
#line 1210
          cost4 += (unsigned int )len[4][icv];
#line 1211
          cost5 += (unsigned int )len[5][icv];
#line 1204
          i ++;
        }
#line 1213
        cost[0] = cost0;
#line 1213
        cost[1] = cost1;
#line 1213
        cost[2] = cost2;
#line 1214
        cost[3] = cost3;
#line 1214
        cost[4] = cost4;
#line 1214
        cost[5] = cost5;
      } else {
#line 1216
        i = gs;
#line 1216
        while (i <= ge) {
#line 1217
          icv___0 = *(szptr + i);
#line 1218
          t = 0;
#line 1218
          while (t < nGroups) {
#line 1218
            cost[t] += (unsigned int )len[t][icv___0];
#line 1218
            t ++;
          }
#line 1216
          i ++;
        }
      }
#line 1226
      bc = 999999999;
#line 1226
      bt = -1;
#line 1227
      t = 0;
#line 1227
      while (t < nGroups) {
#line 1228
        if (cost[t] < (unsigned int )bc) {
#line 1228
          bc = (int )cost[t];
#line 1228
          bt = t;
        }
#line 1227
        t ++;
      }
#line 1229
      totc += bc;
#line 1230
      (fave[bt]) ++;
#line 1231
      selector[nSelectors] = (unsigned char )bt;
#line 1232
      nSelectors ++;
#line 1237
      i = gs;
#line 1237
      while (i <= ge) {
#line 1238
        (rfreq[bt][*(szptr + i)]) ++;
#line 1237
        i ++;
      }
#line 1240
      gs = ge + 1;
    }
#line 1242
    if (verbosity >= 3) {
#line 1243
      tmp___1 = __getreent();
#line 1243
      fprintf(tmp___1->_stderr, "      pass %d: size is %d, grp uses are ", iter + 1,
              totc / 8);
#line 1246
      t = 0;
#line 1246
      while (t < nGroups) {
#line 1247
        tmp___2 = __getreent();
#line 1247
        fprintf(tmp___2->_stderr, "%d ", fave[t]);
#line 1246
        t ++;
      }
#line 1248
      tmp___3 = __getreent();
#line 1248
      fprintf(tmp___3->_stderr, "\n");
    }
#line 1254
    t = 0;
#line 1254
    while (t < nGroups) {
#line 1255
      hbMakeCodeLengths(& len[t][0], & rfreq[t][0], alphaSize, 20);
#line 1254
      t ++;
    }
#line 1177
    iter ++;
  }
#line 1259
  if (! (nGroups < 8)) {
#line 1259
    panic((char *)"sendMTFValues(1)");
  }
#line 1260
  if (nSelectors < 32768) {
#line 1260
    if (! (nSelectors <= 18002)) {
#line 1262
      panic((char *)"sendMTFValues(2)");
    }
  } else {
#line 1262
    panic((char *)"sendMTFValues(2)");
  }
#line 1268
  i = 0;
#line 1268
  while (i < nGroups) {
#line 1268
    pos[i] = (unsigned char )i;
#line 1268
    i ++;
  }
#line 1269
  i = 0;
#line 1269
  while (i < nSelectors) {
#line 1270
    ll_i = selector[i];
#line 1271
    j = 0;
#line 1272
    tmp___4 = pos[j];
#line 1273
    while ((int )ll_i != (int )tmp___4) {
#line 1274
      j ++;
#line 1275
      tmp2 = tmp___4;
#line 1276
      tmp___4 = pos[j];
#line 1277
      pos[j] = tmp2;
    }
#line 1279
    pos[0] = tmp___4;
#line 1280
    selectorMtf[i] = (unsigned char )j;
#line 1269
    i ++;
  }
#line 1285
  t = 0;
#line 1285
  while (t < nGroups) {
#line 1286
    minLen = 32;
#line 1287
    maxLen = 0;
#line 1288
    i = 0;
#line 1288
    while (i < alphaSize) {
#line 1289
      if ((int )len[t][i] > maxLen) {
#line 1289
        maxLen = (int )len[t][i];
      }
#line 1290
      if ((int )len[t][i] < minLen) {
#line 1290
        minLen = (int )len[t][i];
      }
#line 1288
      i ++;
    }
#line 1292
    if (maxLen > 20) {
#line 1292
      panic((char *)"sendMTFValues(3)");
    }
#line 1293
    if (minLen < 1) {
#line 1293
      panic((char *)"sendMTFValues(4)");
    }
#line 1294
    hbAssignCodes(& code[t][0], & len[t][0], minLen, maxLen, alphaSize);
#line 1285
    t ++;
  }
#line 1301
  i = 0;
#line 1301
  while (i < 16) {
#line 1302
    inUse16[i] = (unsigned char)0;
#line 1303
    j = 0;
#line 1303
    while (j < 16) {
#line 1304
      if (inUse[i * 16 + j]) {
#line 1304
        inUse16[i] = (unsigned char)1;
      }
#line 1303
      j ++;
    }
#line 1301
    i ++;
  }
#line 1307
  nBytes = (int )bytesOut;
#line 1308
  i = 0;
#line 1308
  while (i < 16) {
#line 1309
    if (inUse16[i]) {
#line 1309
      bsW(1, 1U);
    } else {
#line 1309
      bsW(1, 0U);
    }
#line 1308
    i ++;
  }
#line 1311
  i = 0;
#line 1311
  while (i < 16) {
#line 1312
    if (inUse16[i]) {
#line 1313
      j = 0;
#line 1313
      while (j < 16) {
#line 1314
        if (inUse[i * 16 + j]) {
#line 1315
          bsW(1, 1U);
        } else {
#line 1317
          bsW(1, 0U);
        }
#line 1313
        j ++;
      }
    }
#line 1311
    i ++;
  }
#line 1322
  if (verbosity >= 3) {
#line 1323
    tmp___5 = __getreent();
#line 1323
    fprintf(tmp___5->_stderr, "      bytes: mapping %d, ", bytesOut - (unsigned int )nBytes);
  }
#line 1327
  nBytes = (int )bytesOut;
#line 1328
  bsW(3, (unsigned int )nGroups);
#line 1329
  bsW(15, (unsigned int )nSelectors);
#line 1330
  i = 0;
#line 1330
  while (i < nSelectors) {
#line 1331
    j = 0;
#line 1331
    while (j < (int )selectorMtf[i]) {
#line 1331
      bsW(1, 1U);
#line 1331
      j ++;
    }
#line 1332
    bsW(1, 0U);
#line 1330
    i ++;
  }
#line 1334
  if (verbosity >= 3) {
#line 1335
    tmp___6 = __getreent();
#line 1335
    fprintf(tmp___6->_stderr, "selectors %d, ", bytesOut - (unsigned int )nBytes);
  }
#line 1338
  nBytes = (int )bytesOut;
#line 1340
  t = 0;
#line 1340
  while (t < nGroups) {
#line 1341
    curr = (int )len[t][0];
#line 1342
    bsW(5, (unsigned int )curr);
#line 1343
    i = 0;
#line 1343
    while (i < alphaSize) {
#line 1344
      while (curr < (int )len[t][i]) {
#line 1344
        bsW(2, 2U);
#line 1344
        curr ++;
      }
#line 1345
      while (curr > (int )len[t][i]) {
#line 1345
        bsW(2, 3U);
#line 1345
        curr --;
      }
#line 1346
      bsW(1, 0U);
#line 1343
      i ++;
    }
#line 1340
    t ++;
  }
#line 1350
  if (verbosity >= 3) {
#line 1351
    tmp___7 = __getreent();
#line 1351
    fprintf(tmp___7->_stderr, "code lengths %d, ", bytesOut - (unsigned int )nBytes);
  }
#line 1354
  nBytes = (int )bytesOut;
#line 1355
  selCtr = 0;
#line 1356
  gs = 0;
#line 1357
  while (! (gs >= nMTF)) {
#line 1359
    ge = (gs + 50) - 1;
#line 1360
    if (ge >= nMTF) {
#line 1360
      ge = nMTF - 1;
    }
#line 1361
    i = gs;
#line 1361
    while (i <= ge) {
#line 1362
      bsW((int )len[selector[selCtr]][*(szptr + i)], (unsigned int )code[selector[selCtr]][*(szptr + i)]);
#line 1361
      i ++;
    }
#line 1366
    gs = ge + 1;
#line 1367
    selCtr ++;
  }
#line 1369
  if (! (selCtr == nSelectors)) {
#line 1369
    panic((char *)"sendMTFValues(5)");
  }
#line 1371
  if (verbosity >= 3) {
#line 1372
    tmp___8 = __getreent();
#line 1372
    fprintf(tmp___8->_stderr, "codes %d\n", bytesOut - (unsigned int )nBytes);
  }
#line 1373
  return;
}
}
#line 1377 "bzip2.c"
void moveToFrontCodeAndSend(void) 
{ 

  {
#line 1379
  bsPutIntVS(24, (unsigned int )origPtr);
#line 1380
  generateMTFValues();
#line 1381
  sendMTFValues();
#line 1382
  return;
}
}
#line 1386 "bzip2.c"
void recvDecodingTables(void) 
{ int i ;
  int j ;
  int t ;
  int nGroups ;
  int nSelectors ;
  int alphaSize ;
  int minLen ;
  int maxLen ;
  unsigned char inUse16[16] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned char pos[6] ;
  unsigned char tmp___4 ;
  unsigned char v ;
  int curr ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 1393
  i = 0;
#line 1393
  while (i < 16) {
#line 1394
    tmp = bsR(1);
#line 1394
    if (tmp == 1U) {
#line 1395
      inUse16[i] = (unsigned char)1;
    } else {
#line 1396
      inUse16[i] = (unsigned char)0;
    }
#line 1393
    i ++;
  }
#line 1398
  i = 0;
#line 1398
  while (i < 256) {
#line 1398
    inUse[i] = (unsigned char)0;
#line 1398
    i ++;
  }
#line 1400
  i = 0;
#line 1400
  while (i < 16) {
#line 1401
    if (inUse16[i]) {
#line 1402
      j = 0;
#line 1402
      while (j < 16) {
#line 1403
        tmp___0 = bsR(1);
#line 1403
        if (tmp___0 == 1U) {
#line 1403
          inUse[i * 16 + j] = (unsigned char)1;
        }
#line 1402
        j ++;
      }
    }
#line 1400
    i ++;
  }
#line 1405
  makeMaps();
#line 1406
  alphaSize = nInUse + 2;
#line 1409
  tmp___1 = bsR(3);
#line 1409
  nGroups = (int )tmp___1;
#line 1410
  tmp___2 = bsR(15);
#line 1410
  nSelectors = (int )tmp___2;
#line 1411
  i = 0;
#line 1411
  while (i < nSelectors) {
#line 1412
    j = 0;
#line 1413
    while (1) {
#line 1413
      tmp___3 = bsR(1);
#line 1413
      if (! (tmp___3 == 1U)) {
#line 1413
        break;
      }
#line 1413
      j ++;
    }
#line 1414
    selectorMtf[i] = (unsigned char )j;
#line 1411
    i ++;
  }
#line 1420
  v = (unsigned char)0;
#line 1420
  while ((int )v < nGroups) {
#line 1420
    pos[v] = v;
#line 1420
    v = (unsigned char )((int )v + 1);
  }
#line 1422
  i = 0;
#line 1422
  while (i < nSelectors) {
#line 1423
    v = selectorMtf[i];
#line 1424
    tmp___4 = pos[v];
#line 1425
    while ((int )v > 0) {
#line 1425
      pos[v] = pos[(int )v - 1];
#line 1425
      v = (unsigned char )((int )v - 1);
    }
#line 1426
    pos[0] = tmp___4;
#line 1427
    selector[i] = tmp___4;
#line 1422
    i ++;
  }
#line 1432
  t = 0;
#line 1432
  while (t < nGroups) {
#line 1433
    tmp___5 = bsR(5);
#line 1433
    curr = (int )tmp___5;
#line 1434
    i = 0;
#line 1434
    while (i < alphaSize) {
#line 1435
      while (1) {
#line 1435
        tmp___7 = bsR(1);
#line 1435
        if (! (tmp___7 == 1U)) {
#line 1435
          break;
        }
#line 1436
        tmp___6 = bsR(1);
#line 1436
        if (tmp___6 == 0U) {
#line 1436
          curr ++;
        } else {
#line 1436
          curr --;
        }
      }
#line 1438
      len[t][i] = (unsigned char )curr;
#line 1434
      i ++;
    }
#line 1432
    t ++;
  }
#line 1443
  t = 0;
#line 1443
  while (t < nGroups) {
#line 1444
    minLen = 32;
#line 1445
    maxLen = 0;
#line 1446
    i = 0;
#line 1446
    while (i < alphaSize) {
#line 1447
      if ((int )len[t][i] > maxLen) {
#line 1447
        maxLen = (int )len[t][i];
      }
#line 1448
      if ((int )len[t][i] < minLen) {
#line 1448
        minLen = (int )len[t][i];
      }
#line 1446
      i ++;
    }
#line 1450
    hbCreateDecodeTables(& limit[t][0], & base[t][0], & perm[t][0], & len[t][0], minLen,
                         maxLen, alphaSize);
#line 1454
    minLens[t] = minLen;
#line 1443
    t ++;
  }
#line 1456
  return;
}
}
#line 1462 "bzip2.c"
void getAndMoveToFrontDecode(void) 
{ unsigned char yy[256] ;
  int i ;
  int j ;
  int nextSym ;
  int limitLast ;
  int EOB ;
  int groupNo ;
  int groupPos ;
  unsigned int tmp ;
  int zt ;
  int zn ;
  int zvec ;
  int zj ;
  unsigned int tmp___0 ;
  int zzi ;
  int tmp___1 ;
  unsigned char ch ;
  int s ;
  int N ;
  int zt___0 ;
  int zn___0 ;
  int zvec___0 ;
  int zj___0 ;
  unsigned int tmp___2 ;
  int zzi___0 ;
  int tmp___3 ;
  unsigned char tmp___4 ;
  int zt___1 ;
  int zn___1 ;
  int zvec___1 ;
  int zj___1 ;
  unsigned int tmp___5 ;
  int zzi___1 ;
  int tmp___6 ;

  {
#line 1468
  limitLast = 100000 * blockSize100k;
#line 1469
  tmp = bsGetIntVS(24U);
#line 1469
  origPtr = (int )tmp;
#line 1471
  recvDecodingTables();
#line 1472
  EOB = nInUse + 1;
#line 1473
  groupNo = -1;
#line 1474
  groupPos = 0;
#line 1482
  i = 0;
#line 1482
  while (i <= 255) {
#line 1482
    unzftab[i] = 0;
#line 1482
    i ++;
  }
#line 1484
  i = 0;
#line 1484
  while (i <= 255) {
#line 1484
    yy[i] = (unsigned char )i;
#line 1484
    i ++;
  }
#line 1486
  last = -1;
#line 1491
  if (groupPos == 0) {
#line 1492
    groupNo ++;
#line 1493
    groupPos = 50;
  }
#line 1495
  groupPos --;
#line 1496
  zt = (int )selector[groupNo];
#line 1497
  zn = minLens[zt];
#line 1498
  tmp___0 = bsR(zn);
#line 1498
  zvec = (int )tmp___0;
#line 1499
  while (zvec > limit[zt][zn]) {
#line 1500
    zn ++;
#line 1501
    while (bsLive < 1) {
#line 1502
      tmp___1 = spec_getc(bsStream);
#line 1502
      zzi = tmp___1;
#line 1503
      if (zzi == -1) {
#line 1503
        compressedStreamEOF();
      }
#line 1504
      bsBuff = (bsBuff << 8) | (unsigned int )(zzi & 255);
#line 1505
      bsLive += 8;
    }
#line 1507
    zj = (int )((bsBuff >> (bsLive - 1)) & 1U);
#line 1508
    bsLive --;
#line 1508
    zvec = (zvec << 1) | zj;
  }
#line 1511
  nextSym = perm[zt][zvec - base[zt][zn]];
#line 1513
  while (! (nextSym == EOB)) {
#line 1517
    if (nextSym == 0) {
      goto _L;
    } else {
#line 1517
      if (nextSym == 1) {
        _L: /* CIL Label */ 
#line 1519
        s = -1;
#line 1520
        N = 1;
#line 1521
        while (1) {
#line 1522
          if (nextSym == 0) {
#line 1522
            s += N;
          } else {
#line 1523
            if (nextSym == 1) {
#line 1523
              s += 2 * N;
            }
          }
#line 1524
          N *= 2;
#line 1526
          if (groupPos == 0) {
#line 1527
            groupNo ++;
#line 1528
            groupPos = 50;
          }
#line 1530
          groupPos --;
#line 1531
          zt___0 = (int )selector[groupNo];
#line 1532
          zn___0 = minLens[zt___0];
#line 1533
          tmp___2 = bsR(zn___0);
#line 1533
          zvec___0 = (int )tmp___2;
#line 1534
          while (zvec___0 > limit[zt___0][zn___0]) {
#line 1535
            zn___0 ++;
#line 1536
            while (bsLive < 1) {
#line 1537
              tmp___3 = spec_getc(bsStream);
#line 1537
              zzi___0 = tmp___3;
#line 1538
              if (zzi___0 == -1) {
#line 1538
                compressedStreamEOF();
              }
#line 1539
              bsBuff = (bsBuff << 8) | (unsigned int )(zzi___0 & 255);
#line 1540
              bsLive += 8;
            }
#line 1542
            zj___0 = (int )((bsBuff >> (bsLive - 1)) & 1U);
#line 1543
            bsLive --;
#line 1543
            zvec___0 = (zvec___0 << 1) | zj___0;
          }
#line 1546
          nextSym = perm[zt___0][zvec___0 - base[zt___0][zn___0]];
#line 1521
          if (! (nextSym == 0)) {
#line 1521
            if (! (nextSym == 1)) {
#line 1521
              break;
            }
          }
        }
#line 1550
        s ++;
#line 1551
        ch = seqToUnseq[yy[0]];
#line 1552
        unzftab[ch] += s;
#line 1554
        if (smallMode) {
#line 1555
          while (s > 0) {
#line 1556
            last ++;
#line 1557
            *(ll16 + last) = (unsigned int )ch;
#line 1558
            s --;
          }
        } else {
#line 1561
          while (s > 0) {
#line 1562
            last ++;
#line 1563
            *(ll8 + last) = ch;
#line 1564
            s --;
          }
        }
#line 1567
        if (last >= limitLast) {
#line 1567
          blockOverrun();
        }
#line 1568
        continue;
      } else {
#line 1573
        last ++;
#line 1573
        if (last >= limitLast) {
#line 1573
          blockOverrun();
        }
#line 1575
        tmp___4 = yy[nextSym - 1];
#line 1576
        (unzftab[seqToUnseq[tmp___4]]) ++;
#line 1577
        if (smallMode) {
#line 1578
          *(ll16 + last) = (unsigned int )seqToUnseq[tmp___4];
        } else {
#line 1579
          *(ll8 + last) = seqToUnseq[tmp___4];
        }
#line 1588
        j = nextSym - 1;
#line 1589
        while (j > 3) {
#line 1590
          yy[j] = yy[j - 1];
#line 1591
          yy[j - 1] = yy[j - 2];
#line 1592
          yy[j - 2] = yy[j - 3];
#line 1593
          yy[j - 3] = yy[j - 4];
#line 1589
          j -= 4;
        }
#line 1595
        while (j > 0) {
#line 1595
          yy[j] = yy[j - 1];
#line 1595
          j --;
        }
#line 1597
        yy[0] = tmp___4;
#line 1599
        if (groupPos == 0) {
#line 1600
          groupNo ++;
#line 1601
          groupPos = 50;
        }
#line 1603
        groupPos --;
#line 1604
        zt___1 = (int )selector[groupNo];
#line 1605
        zn___1 = minLens[zt___1];
#line 1606
        tmp___5 = bsR(zn___1);
#line 1606
        zvec___1 = (int )tmp___5;
#line 1607
        while (zvec___1 > limit[zt___1][zn___1]) {
#line 1608
          zn___1 ++;
#line 1609
          while (bsLive < 1) {
#line 1610
            tmp___6 = spec_getc(bsStream);
#line 1610
            zzi___1 = tmp___6;
#line 1611
            if (zzi___1 == -1) {
#line 1611
              compressedStreamEOF();
            }
#line 1612
            bsBuff = (bsBuff << 8) | (unsigned int )(zzi___1 & 255);
#line 1613
            bsLive += 8;
          }
#line 1615
          zj___1 = (int )((bsBuff >> (bsLive - 1)) & 1U);
#line 1616
          bsLive --;
#line 1616
          zvec___1 = (zvec___1 << 1) | zj___1;
        }
#line 1619
        nextSym = perm[zt___1][zvec___1 - base[zt___1][zn___1]];
#line 1620
        continue;
      }
    }
  }
#line 1623
  return;
}
}
#line 1640 "bzip2.c"
unsigned char fullGtU(int i1 , int i2 ) 
{ int k ;
  int i ;
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned int s1 ;
  unsigned int s2 ;

  {
#line 1646
  i = 0;
#line 1648
  while (i < 6) {
#line 1650
    c1 = *(block + i1);
#line 1651
    c2 = *(block + i2);
#line 1652
    if ((int )c1 != (int )c2) {
#line 1652
      return ((unsigned char )((int )c1 > (int )c2));
    }
#line 1653
    i1 ++;
#line 1653
    i2 ++;
#line 1653
    i ++;
  }
#line 1656
  k = last + 1;
#line 1658
  while (1) {
#line 1659
    i = 0;
#line 1660
    while (i < 4) {
#line 1662
      c1 = *(block + i1);
#line 1663
      c2 = *(block + i2);
#line 1664
      if ((int )c1 != (int )c2) {
#line 1664
        return ((unsigned char )((int )c1 > (int )c2));
      }
#line 1665
      s1 = *(quadrant + i1);
#line 1666
      s2 = *(quadrant + i2);
#line 1667
      if (s1 != s2) {
#line 1667
        return ((unsigned char )(s1 > s2));
      }
#line 1668
      i1 ++;
#line 1668
      i2 ++;
#line 1668
      i ++;
    }
#line 1671
    if (i1 > last) {
#line 1671
      i1 -= last;
#line 1671
      i1 --;
    }
#line 1672
    if (i2 > last) {
#line 1672
      i2 -= last;
#line 1672
      i2 --;
    }
#line 1674
    k -= 4;
#line 1675
    workDone ++;
#line 1658
    if (! (k >= 0)) {
#line 1658
      break;
    }
  }
#line 1679
  return ((unsigned char)0);
}
}
#line 1689 "bzip2.c"
int incs[14]  = 
#line 1689
  {      1,      4,      13,      40, 
        121,      364,      1093,      3280, 
        9841,      29524,      88573,      265720, 
        797161,      2391484};
#line 1693 "bzip2.c"
void simpleSort(int lo , int hi , int d ) 
{ int i ;
  int j ;
  int h ;
  int bigN ;
  int hp ;
  int v ;
  struct _reent *tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;

  {
#line 1698
  bigN = (hi - lo) + 1;
#line 1699
  if (bigN < 2) {
#line 1699
    return;
  }
#line 1702
  hp = 0;
#line 1703
  while (incs[hp] < bigN) {
#line 1703
    hp ++;
  }
#line 1704
  hp --;
#line 1706
  while (hp >= 0) {
#line 1707
    h = incs[hp];
#line 1708
    if (verbosity >= 5) {
#line 1709
      tmp = __getreent();
#line 1709
      fprintf(tmp->_stderr, "          shell increment %d\n", h);
    }
#line 1711
    i = lo + h;
#line 1712
    while (! (i > hi)) {
#line 1716
      v = *(zptr + i);
#line 1717
      j = i;
#line 1721
      while (1) {
#line 1721
        tmp___0 = fullGtU(*(zptr + (j - h)) + d, v + d);
#line 1721
        if (! tmp___0) {
#line 1721
          break;
        }
#line 1722
        *(zptr + j) = *(zptr + (j - h));
#line 1723
        j -= h;
#line 1724
        if (j <= (lo + h) - 1) {
#line 1724
          break;
        }
      }
#line 1726
      *(zptr + j) = v;
#line 1727
      i ++;
#line 1730
      if (i > hi) {
#line 1730
        break;
      }
#line 1731
      v = *(zptr + i);
#line 1732
      j = i;
#line 1735
      while (1) {
#line 1735
        tmp___1 = fullGtU(*(zptr + (j - h)) + d, v + d);
#line 1735
        if (! tmp___1) {
#line 1735
          break;
        }
#line 1736
        *(zptr + j) = *(zptr + (j - h));
#line 1737
        j -= h;
#line 1738
        if (j <= (lo + h) - 1) {
#line 1738
          break;
        }
      }
#line 1740
      *(zptr + j) = v;
#line 1741
      i ++;
#line 1744
      if (i > hi) {
#line 1744
        break;
      }
#line 1745
      v = *(zptr + i);
#line 1746
      j = i;
#line 1749
      while (1) {
#line 1749
        tmp___2 = fullGtU(*(zptr + (j - h)) + d, v + d);
#line 1749
        if (! tmp___2) {
#line 1749
          break;
        }
#line 1750
        *(zptr + j) = *(zptr + (j - h));
#line 1751
        j -= h;
#line 1752
        if (j <= (lo + h) - 1) {
#line 1752
          break;
        }
      }
#line 1754
      *(zptr + j) = v;
#line 1755
      i ++;
#line 1757
      if (workDone > workLimit) {
#line 1757
        if (firstAttempt) {
#line 1757
          return;
        }
      }
    }
#line 1706
    hp --;
  }
#line 1760
  return;
}
}
#line 1773 "bzip2.c"
void vswap(int p1 , int p2 , int n ) 
{ int tmp ;

  {
#line 1775
  while (n > 0) {
#line 1776
    tmp = *(zptr + p1);
#line 1776
    *(zptr + p1) = *(zptr + p2);
#line 1776
    *(zptr + p2) = tmp;
#line 1779
    p1 ++;
#line 1779
    p2 ++;
#line 1779
    n --;
  }
#line 1781
  return;
}
}
#line 1783 "bzip2.c"
unsigned char med3(unsigned char a , unsigned char b , unsigned char c ) 
{ unsigned char t ;

  {
#line 1786
  if ((int )a > (int )b) {
#line 1786
    t = a;
#line 1786
    a = b;
#line 1786
    b = t;
  }
#line 1787
  if ((int )b > (int )c) {
#line 1787
    t = b;
#line 1787
    b = c;
#line 1787
    c = t;
  }
#line 1788
  if ((int )a > (int )b) {
#line 1788
    b = a;
  }
#line 1789
  return (b);
}
}
#line 1814 "bzip2.c"
void qSort3(int loSt , int hiSt , int dSt ) 
{ int unLo ;
  int unHi ;
  int ltLo ;
  int gtHi ;
  int med ;
  int n ;
  int m ;
  int sp ;
  int lo ;
  int hi ;
  int d ;
  StackElem stack[1000] ;
  unsigned char tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1820
  sp = 0;
#line 1823
  stack[sp].ll = loSt;
#line 1824
  stack[sp].hh = hiSt;
#line 1825
  stack[sp].dd = dSt;
#line 1826
  sp ++;
#line 1828
  while (sp > 0) {
#line 1830
    if (sp >= 1000) {
#line 1830
      panic((char *)"stack overflow in qSort3");
    }
#line 1833
    sp --;
#line 1834
    lo = stack[sp].ll;
#line 1835
    hi = stack[sp].hh;
#line 1836
    d = stack[sp].dd;
#line 1838
    if (hi - lo < 20) {
      goto _L;
    } else {
#line 1838
      if (d > 10) {
        _L: /* CIL Label */ 
#line 1840
        if (syf == 255) {
#line 1840
          yk_j ++;
        }
#line 1842
        simpleSort(lo, hi, d);
#line 1843
        if (workDone > workLimit) {
#line 1843
          if (firstAttempt) {
#line 1843
            return;
          }
        }
#line 1844
        continue;
      }
    }
#line 1847
    tmp = med3(*(block + (*(zptr + lo) + d)), *(block + (*(zptr + hi) + d)), *(block + (*(zptr + ((lo + hi) >> 1)) + d)));
#line 1847
    med = (int )tmp;
#line 1851
    ltLo = lo;
#line 1851
    unLo = ltLo;
#line 1852
    gtHi = hi;
#line 1852
    unHi = gtHi;
#line 1857
    while (1) {
#line 1858
      while (! (unLo > unHi)) {
#line 1860
        n = (int )*(block + (*(zptr + unLo) + d)) - med;
#line 1861
        if (n == 0) {
#line 1862
          tmp___0 = *(zptr + unLo);
#line 1862
          *(zptr + unLo) = *(zptr + ltLo);
#line 1862
          *(zptr + ltLo) = tmp___0;
#line 1863
          ltLo ++;
#line 1863
          unLo ++;
#line 1863
          continue;
        }
#line 1864
        if (n > 0) {
#line 1864
          break;
        }
#line 1865
        unLo ++;
      }
#line 1867
      while (! (unLo > unHi)) {
#line 1869
        n = (int )*(block + (*(zptr + unHi) + d)) - med;
#line 1870
        if (n == 0) {
#line 1871
          tmp___1 = *(zptr + unHi);
#line 1871
          *(zptr + unHi) = *(zptr + gtHi);
#line 1871
          *(zptr + gtHi) = tmp___1;
#line 1872
          gtHi --;
#line 1872
          unHi --;
#line 1872
          continue;
        }
#line 1873
        if (n < 0) {
#line 1873
          break;
        }
#line 1874
        unHi --;
      }
#line 1876
      if (unLo > unHi) {
#line 1876
        break;
      }
#line 1877
      tmp___2 = *(zptr + unLo);
#line 1877
      *(zptr + unLo) = *(zptr + unHi);
#line 1877
      *(zptr + unHi) = tmp___2;
#line 1878
      unLo ++;
#line 1878
      unHi --;
    }
#line 1882
    if (gtHi < ltLo) {
#line 1885
      stack[sp].ll = lo;
#line 1886
      stack[sp].hh = hi;
#line 1887
      stack[sp].dd = d + 1;
#line 1888
      sp ++;
#line 1890
      continue;
    }
#line 1893
    if (ltLo - lo < unLo - ltLo) {
#line 1893
      n = ltLo - lo;
    } else {
#line 1893
      n = unLo - ltLo;
    }
#line 1894
    vswap(lo, unLo - n, n);
#line 1895
    if (hi - gtHi < gtHi - unHi) {
#line 1895
      m = hi - gtHi;
    } else {
#line 1895
      m = gtHi - unHi;
    }
#line 1896
    vswap(unLo, (hi - m) + 1, m);
#line 1900
    n = ((lo + unLo) - ltLo) - 1;
#line 1901
    m = (hi - (gtHi - unHi)) + 1;
#line 1904
    stack[sp].ll = lo;
#line 1905
    stack[sp].hh = n;
#line 1906
    stack[sp].dd = d;
#line 1907
    sp ++;
#line 1910
    stack[sp].ll = n + 1;
#line 1911
    stack[sp].hh = m - 1;
#line 1912
    stack[sp].dd = d + 1;
#line 1913
    sp ++;
#line 1916
    stack[sp].ll = m;
#line 1917
    stack[sp].hh = hi;
#line 1918
    stack[sp].dd = d;
#line 1919
    sp ++;
  }
#line 1921
  return;
}
}
#line 1928 "bzip2.c"
void sortIt(void) 
{ int i ;
  int j ;
  int ss ;
  int sb ;
  int runningOrder[256] ;
  int copy[256] ;
  unsigned char bigDone[256] ;
  unsigned char c1 ;
  unsigned char c2 ;
  int numQSorted ;
  struct _reent *tmp ;
  struct _reent *tmp___0 ;
  struct _reent *tmp___1 ;
  struct _reent *tmp___2 ;
  int vv ;
  int h ;
  int lo ;
  int hi ;
  struct _reent *tmp___3 ;
  int bbStart ;
  int bbSize ;
  int shifts ;
  int a2update ;
  unsigned int qVal ;
  struct _reent *tmp___4 ;

  {
#line 1941
  if (verbosity >= 4) {
#line 1941
    tmp = __getreent();
#line 1941
    fprintf(tmp->_stderr, "        sort initialise ...\n");
  }
#line 1942
  i = 0;
#line 1942
  while (i < 20) {
#line 1943
    *(block + ((last + i) + 1)) = *(block + i % (last + 1));
#line 1942
    i ++;
  }
#line 1944
  i = 0;
#line 1944
  while (i <= last + 20) {
#line 1945
    *(quadrant + i) = 0U;
#line 1944
    i ++;
  }
#line 1947
  *(block + -1) = *(block + last);
#line 1949
  if (last < 4000) {
#line 1955
    if (verbosity >= 4) {
#line 1955
      tmp___0 = __getreent();
#line 1955
      fprintf(tmp___0->_stderr, "        simpleSort ...\n");
    }
#line 1956
    i = 0;
#line 1956
    while (i <= last) {
#line 1956
      *(zptr + i) = i;
#line 1956
      i ++;
    }
#line 1957
    firstAttempt = (unsigned char)0;
#line 1958
    workLimit = 0;
#line 1958
    workDone = workLimit;
#line 1959
    simpleSort(0, last, 0);
#line 1960
    if (verbosity >= 4) {
#line 1960
      tmp___1 = __getreent();
#line 1960
      fprintf(tmp___1->_stderr, "        simpleSort done.\n");
    }
  } else {
#line 1964
    numQSorted = 0;
#line 1965
    i = 0;
#line 1965
    while (i <= 255) {
#line 1965
      bigDone[i] = (unsigned char)0;
#line 1965
      i ++;
    }
#line 1967
    if (verbosity >= 4) {
#line 1967
      tmp___2 = __getreent();
#line 1967
      fprintf(tmp___2->_stderr, "        bucket sorting ...\n");
    }
#line 1969
    i = 0;
#line 1969
    while (i <= 65536) {
#line 1969
      *(ftab + i) = 0;
#line 1969
      i ++;
    }
#line 1971
    c1 = *(block + -1);
#line 1973
    i = 0;
#line 1973
    while (i <= last) {
#line 1974
      c2 = *(block + i);
#line 1975
      (*(ftab + (((int )c1 << 8) + (int )c2))) ++;
#line 1976
      c1 = c2;
#line 1973
      i ++;
    }
#line 1979
    i = 1;
#line 1979
    while (i <= 65536) {
#line 1979
      *(ftab + i) += *(ftab + (i - 1));
#line 1979
      i ++;
    }
#line 1981
    c1 = *(block + 0);
#line 1982
    i = 0;
#line 1982
    while (i < last) {
#line 1983
      c2 = *(block + (i + 1));
#line 1984
      j = ((int )c1 << 8) + (int )c2;
#line 1985
      c1 = c2;
#line 1986
      (*(ftab + j)) --;
#line 1987
      *(zptr + *(ftab + j)) = i;
#line 1982
      i ++;
    }
#line 1991
    j = ((int )*(block + last) << 8) + (int )*(block + 0);
#line 1992
    (*(ftab + j)) --;
#line 1993
    *(zptr + *(ftab + j)) = last;
#line 2001
    i = 0;
#line 2001
    while (i <= 255) {
#line 2001
      runningOrder[i] = i;
#line 2001
      i ++;
    }
#line 2005
    h = 1;
#line 2006
    while (1) {
#line 2006
      h = 3 * h + 1;
#line 2006
      if (! (h <= 256)) {
#line 2006
        break;
      }
    }
#line 2007
    while (1) {
#line 2008
      h /= 3;
#line 2009
      i = h;
#line 2009
      while (i <= 255) {
#line 2010
        vv = runningOrder[i];
#line 2011
        j = i;
#line 2013
        while (*(ftab + ((runningOrder[j - h] + 1) << 8)) - *(ftab + (runningOrder[j - h] << 8)) > *(ftab + ((vv + 1) << 8)) - *(ftab + (vv << 8))) {
#line 2015
          runningOrder[j] = runningOrder[j - h];
#line 2016
          j -= h;
#line 2017
          if (j <= h - 1) {
            goto zero;
          }
        }
        zero: 
#line 2020
        runningOrder[j] = vv;
#line 2009
        i ++;
      }
#line 2007
      if (! (h != 1)) {
#line 2007
        break;
      }
    }
#line 2029
    i = 0;
#line 2029
    while (i <= 255) {
#line 2034
      ss = runningOrder[i];
#line 2043
      j = 0;
#line 2043
      while (j <= 255) {
#line 2044
        sb = (ss << 8) + j;
#line 2045
        if (! (*(ftab + sb) & (1 << 21))) {
#line 2046
          lo = *(ftab + sb) & ~ (1 << 21);
#line 2047
          hi = (*(ftab + (sb + 1)) & ~ (1 << 21)) - 1;
#line 2049
          if (hi > lo) {
#line 2050
            if (verbosity >= 4) {
#line 2051
              tmp___3 = __getreent();
#line 2051
              fprintf(tmp___3->_stderr, "        qsort [0x%x, 0x%x]   done %d   this %d\n",
                      ss, j, numQSorted, (hi - lo) + 1);
            }
#line 2054
            syf = i;
#line 2057
            qSort3(lo, hi, 2);
#line 2058
            numQSorted += (hi - lo) + 1;
#line 2059
            if (workDone > workLimit) {
#line 2059
              if (firstAttempt) {
#line 2060
                return;
              }
            }
          }
#line 2062
          *(ftab + sb) |= 1 << 21;
        }
#line 2043
        j ++;
      }
#line 2074
      bigDone[ss] = (unsigned char)1;
#line 2076
      if (i < 255) {
#line 2077
        bbStart = *(ftab + (ss << 8)) & ~ (1 << 21);
#line 2078
        bbSize = (*(ftab + ((ss + 1) << 8)) & ~ (1 << 21)) - bbStart;
#line 2079
        shifts = 0;
#line 2080
        while (bbSize >> shifts > 65534) {
#line 2080
          shifts ++;
        }
#line 2082
        j = 0;
#line 2082
        while (j < bbSize) {
#line 2083
          a2update = *(zptr + (bbStart + j));
#line 2084
          qVal = (unsigned int )(j >> shifts);
#line 2085
          *(quadrant + a2update) = qVal;
#line 2086
          if (a2update < 20) {
#line 2087
            *(quadrant + ((a2update + last) + 1)) = qVal;
          }
#line 2082
          j ++;
        }
#line 2090
        if (! ((bbSize - 1) >> shifts <= 65535)) {
#line 2090
          panic((char *)"sortIt");
        }
      }
#line 2097
      j = 0;
#line 2097
      while (j <= 255) {
#line 2098
        copy[j] = *(ftab + ((j << 8) + ss)) & ~ (1 << 21);
#line 2097
        j ++;
      }
#line 2100
      j = *(ftab + (ss << 8)) & ~ (1 << 21);
#line 2100
      while (j < (*(ftab + ((ss + 1) << 8)) & ~ (1 << 21))) {
#line 2103
        c1 = *(block + (*(zptr + j) - 1));
#line 2104
        if (! bigDone[c1]) {
#line 2105
          if (*(zptr + j) == 0) {
#line 2105
            *(zptr + copy[c1]) = last;
          } else {
#line 2105
            *(zptr + copy[c1]) = *(zptr + j) - 1;
          }
#line 2106
          (copy[c1]) ++;
        }
#line 2100
        j ++;
      }
#line 2110
      j = 0;
#line 2110
      while (j <= 255) {
#line 2110
        *(ftab + ((j << 8) + ss)) |= 1 << 21;
#line 2110
        j ++;
      }
#line 2029
      i ++;
    }
#line 2112
    if (verbosity >= 4) {
#line 2113
      tmp___4 = __getreent();
#line 2113
      fprintf(tmp___4->_stderr, "        %d pointers, %d sorted, %d scanned\n", last + 1,
              numQSorted, (last + 1) - numQSorted);
    }
  }
#line 2116
  return;
}
}
#line 2124 "bzip2.c"
int rNums[512]  = 
#line 2124
  {      619,      720,      127,      481, 
        931,      816,      813,      233, 
        566,      247,      985,      724, 
        205,      454,      863,      491, 
        741,      242,      949,      214, 
        733,      859,      335,      708, 
        621,      574,      73,      654, 
        730,      472,      419,      436, 
        278,      496,      867,      210, 
        399,      680,      480,      51, 
        878,      465,      811,      169, 
        869,      675,      611,      697, 
        867,      561,      862,      687, 
        507,      283,      482,      129, 
        807,      591,      733,      623, 
        150,      238,      59,      379, 
        684,      877,      625,      169, 
        643,      105,      170,      607, 
        520,      932,      727,      476, 
        693,      425,      174,      647, 
        73,      122,      335,      530, 
        442,      853,      695,      249, 
        445,      515,      909,      545, 
        703,      919,      874,      474, 
        882,      500,      594,      612, 
        641,      801,      220,      162, 
        819,      984,      589,      513, 
        495,      799,      161,      604, 
        958,      533,      221,      400, 
        386,      867,      600,      782, 
        382,      596,      414,      171, 
        516,      375,      682,      485, 
        911,      276,      98,      553, 
        163,      354,      666,      933, 
        424,      341,      533,      870, 
        227,      730,      475,      186, 
        263,      647,      537,      686, 
        600,      224,      469,      68, 
        770,      919,      190,      373, 
        294,      822,      808,      206, 
        184,      943,      795,      384, 
        383,      461,      404,      758, 
        839,      887,      715,      67, 
        618,      276,      204,      918, 
        873,      777,      604,      560, 
        951,      160,      578,      722, 
        79,      804,      96,      409, 
        713,      940,      652,      934, 
        970,      447,      318,      353, 
        859,      672,      112,      785, 
        645,      863,      803,      350, 
        139,      93,      354,      99, 
        820,      908,      609,      772, 
        154,      274,      580,      184, 
        79,      626,      630,      742, 
        653,      282,      762,      623, 
        680,      81,      927,      626, 
        789,      125,      411,      521, 
        938,      300,      821,      78, 
        343,      175,      128,      250, 
        170,      774,      972,      275, 
        999,      639,      495,      78, 
        352,      126,      857,      956, 
        358,      619,      580,      124, 
        737,      594,      701,      612, 
        669,      112,      134,      694, 
        363,      992,      809,      743, 
        168,      974,      944,      375, 
        748,      52,      600,      747, 
        642,      182,      862,      81, 
        344,      805,      988,      739, 
        511,      655,      814,      334, 
        249,      515,      897,      955, 
        664,      981,      649,      113, 
        974,      459,      893,      228, 
        433,      837,      553,      268, 
        926,      240,      102,      654, 
        459,      51,      686,      754, 
        806,      760,      493,      403, 
        415,      394,      687,      700, 
        946,      670,      656,      610, 
        738,      392,      760,      799, 
        887,      653,      978,      321, 
        576,      617,      626,      502, 
        894,      679,      243,      440, 
        680,      879,      194,      572, 
        640,      724,      926,      56, 
        204,      700,      707,      151, 
        457,      449,      797,      195, 
        791,      558,      945,      679, 
        297,      59,      87,      824, 
        713,      663,      412,      693, 
        342,      606,      134,      108, 
        571,      364,      631,      212, 
        174,      643,      304,      329, 
        343,      97,      430,      751, 
        497,      314,      983,      374, 
        822,      928,      140,      206, 
        73,      263,      980,      736, 
        876,      478,      430,      305, 
        170,      514,      364,      692, 
        829,      82,      855,      953, 
        676,      246,      369,      970, 
        294,      750,      807,      827, 
        150,      790,      288,      923, 
        804,      378,      215,      828, 
        592,      281,      565,      555, 
        710,      82,      896,      831, 
        547,      261,      524,      462, 
        293,      465,      502,      56, 
        661,      821,      976,      991, 
        658,      869,      905,      758, 
        745,      193,      768,      550, 
        608,      933,      378,      286, 
        215,      979,      792,      961, 
        61,      688,      793,      644, 
        986,      403,      106,      366, 
        905,      644,      372,      567, 
        466,      434,      645,      210, 
        389,      550,      919,      135, 
        780,      773,      635,      389, 
        707,      100,      626,      958, 
        165,      504,      920,      176, 
        193,      713,      857,      265, 
        203,      50,      668,      108, 
        645,      990,      626,      197, 
        510,      357,      358,      850, 
        858,      364,      936,      638};
#line 2189 "bzip2.c"
void randomiseBlock(void) 
{ int i ;
  int rNToGo ;
  int rTPos ;
  int tmp ;

  {
#line 2192
  rNToGo = 0;
#line 2193
  rTPos = 0;
#line 2194
  i = 0;
#line 2194
  while (i < 256) {
#line 2194
    inUse[i] = (unsigned char)0;
#line 2194
    i ++;
  }
#line 2196
  i = 0;
#line 2196
  while (i <= last) {
#line 2197
    if (rNToGo == 0) {
#line 2198
      rNToGo = rNums[rTPos];
#line 2199
      rTPos ++;
#line 2199
      if (rTPos == 512) {
#line 2199
        rTPos = 0;
      }
    }
#line 2201
    rNToGo --;
#line 2202
    if (rNToGo == 1) {
#line 2202
      tmp = 1;
    } else {
#line 2202
      tmp = 0;
    }
#line 2202
    *(block + i) = (unsigned char )((int )*(block + i) ^ tmp);
#line 2203
    inUse[*(block + i)] = (unsigned char)1;
#line 2196
    i ++;
  }
#line 2205
  return;
}
}
#line 2209 "bzip2.c"
void doReversibleTransformation(void) 
{ int i ;
  struct _reent *tmp ;
  struct _reent *tmp___0 ;
  struct _reent *tmp___1 ;
  struct _reent *tmp___2 ;

  {
#line 2213
  if (verbosity >= 2) {
#line 2213
    tmp = __getreent();
#line 2213
    fprintf(tmp->_stderr, "\n");
  }
#line 2215
  workLimit = workFactor * last;
#line 2216
  workDone = 0;
#line 2217
  blockRandomised = (unsigned char)0;
#line 2218
  firstAttempt = (unsigned char)1;
#line 2220
  sortIt();
#line 2222
  if (verbosity >= 3) {
#line 2223
    tmp___0 = __getreent();
#line 2223
    fprintf(tmp___0->_stderr, "      %d work, %d block, ratio %5.2f\n", workDone,
            last, (float )workDone / (float )last);
  }
#line 2226
  if (workDone > workLimit) {
#line 2226
    if (firstAttempt) {
#line 2227
      if (verbosity >= 2) {
#line 2228
        tmp___1 = __getreent();
#line 2228
        fprintf(tmp___1->_stderr, "    sorting aborted; randomising block\n");
      }
#line 2229
      randomiseBlock();
#line 2230
      workDone = 0;
#line 2230
      workLimit = workDone;
#line 2231
      blockRandomised = (unsigned char)1;
#line 2232
      firstAttempt = (unsigned char)0;
#line 2233
      sortIt();
#line 2234
      if (verbosity >= 3) {
#line 2235
        tmp___2 = __getreent();
#line 2235
        fprintf(tmp___2->_stderr, "      %d work, %d block, ratio %f\n", workDone,
                last, (float )workDone / (float )last);
      }
    }
  }
#line 2239
  origPtr = -1;
#line 2240
  i = 0;
#line 2240
  while (i <= last) {
#line 2241
    if (*(zptr + i) == 0) {
#line 2242
      origPtr = i;
#line 2242
      break;
    }
#line 2240
    i ++;
  }
#line 2244
  if (origPtr == -1) {
#line 2244
    panic((char *)"doReversibleTransformation");
  }
#line 2245
  return;
}
}
#line 2250 "bzip2.c"
int indexIntoF(int indx , int *cftab ) 
{ int nb ;
  int na ;
  int mid ;

  {
#line 2253
  nb = 0;
#line 2254
  na = 256;
#line 2255
  while (1) {
#line 2256
    mid = (nb + na) >> 1;
#line 2257
    if (indx >= *(cftab + mid)) {
#line 2257
      nb = mid;
    } else {
#line 2257
      na = mid;
    }
#line 2255
    if (! (na - nb != 1)) {
#line 2255
      break;
    }
  }
#line 2260
  return (nb);
}
}
#line 2268 "bzip2.c"
void undoReversibleTransformation_small(int dst ) 
{ int cftab[257] ;
  int cftabAlso[257] ;
  int i ;
  int j ;
  int tmp ;
  int tPos ;
  unsigned char ch ;
  int retVal ;
  int i2 ;
  int count ;
  int chPrev ;
  int ch2 ;
  unsigned int localCrc ;
  int rNToGo ;
  int rTPos ;
  int tmp___0 ;
  int j2 ;
  unsigned char z ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2281
  cftab[0] = 0;
#line 2282
  i = 1;
#line 2282
  while (i <= 256) {
#line 2282
    cftab[i] = unzftab[i - 1];
#line 2282
    i ++;
  }
#line 2283
  i = 1;
#line 2283
  while (i <= 256) {
#line 2283
    cftab[i] += cftab[i - 1];
#line 2283
    i ++;
  }
#line 2286
  i = 0;
#line 2286
  while (i <= 256) {
#line 2286
    cftabAlso[i] = cftab[i];
#line 2286
    i ++;
  }
#line 2289
  i = 0;
#line 2289
  while (i <= last) {
#line 2290
    ch = (unsigned char )*(ll16 + i);
#line 2293
    *(ll16 + i) = (unsigned int )(cftabAlso[ch] & 65535);
#line 2294
    SET_LL4(i, cftabAlso[ch] >> 16);
#line 2296
    *(ll16 + i) = (unsigned int )(cftabAlso[ch] & 65535);
#line 2297
    SET_LL4(i, cftabAlso[ch] >> 16);
#line 2298
    (cftabAlso[ch]) ++;
#line 2289
    i ++;
  }
#line 2318
  i = origPtr;
#line 2319
  j = (int )(*(ll16 + i) | ((((unsigned int )*(ll4 + (i >> 1)) >> ((i << 2) & 4)) & 15U) << 16));
#line 2320
  while (1) {
#line 2321
    tmp = (int )(*(ll16 + j) | ((((unsigned int )*(ll4 + (j >> 1)) >> ((j << 2) & 4)) & 15U) << 16));
#line 2322
    *(ll16 + j) = (unsigned int )(i & 65535);
#line 2323
    SET_LL4(j, i >> 16);
#line 2324
    *(ll16 + j) = (unsigned int )(i & 65535);
#line 2325
    SET_LL4(j, i >> 16);
#line 2327
    i = j;
#line 2328
    j = tmp;
#line 2320
    if (! (i != origPtr)) {
#line 2320
      break;
    }
  }
#line 2338
  tPos = origPtr;
#line 2358
  count = 0;
#line 2359
  i2 = 0;
#line 2360
  ch2 = 256;
#line 2361
  localCrc = getGlobalCRC();
#line 2364
  rNToGo = 0;
#line 2365
  rTPos = 0;
#line 2366
  while (i2 <= last) {
#line 2367
    chPrev = ch2;
#line 2369
    ch2 = indexIntoF(tPos, cftab);
#line 2369
    tPos = (int )(*(ll16 + tPos) | ((((unsigned int )*(ll4 + (tPos >> 1)) >> ((tPos << 2) & 4)) & 15U) << 16));
#line 2371
    if (blockRandomised) {
#line 2372
      if (rNToGo == 0) {
#line 2373
        rNToGo = rNums[rTPos];
#line 2374
        rTPos ++;
#line 2374
        if (rTPos == 512) {
#line 2374
          rTPos = 0;
        }
      }
#line 2376
      rNToGo --;
#line 2377
      if (rNToGo == 1) {
#line 2377
        tmp___0 = 1;
      } else {
#line 2377
        tmp___0 = 0;
      }
#line 2377
      ch2 = (int )((unsigned int )ch2 ^ (unsigned int )tmp___0);
    }
#line 2379
    i2 ++;
#line 2381
    if (dst) {
#line 2382
      retVal = spec_putc((unsigned char )ch2, dst);
    }
#line 2386
    localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
#line 2392
    if (ch2 != chPrev) {
#line 2393
      count = 1;
    } else {
#line 2395
      count ++;
#line 2396
      if (count >= 4) {
#line 2400
        tmp___1 = indexIntoF(tPos, cftab);
#line 2400
        z = (unsigned char )tmp___1;
#line 2400
        tPos = (int )(*(ll16 + tPos) | ((((unsigned int )*(ll4 + (tPos >> 1)) >> ((tPos << 2) & 4)) & 15U) << 16));
#line 2402
        if (blockRandomised) {
#line 2403
          if (rNToGo == 0) {
#line 2404
            rNToGo = rNums[rTPos];
#line 2405
            rTPos ++;
#line 2405
            if (rTPos == 512) {
#line 2405
              rTPos = 0;
            }
          }
#line 2407
          rNToGo --;
#line 2408
          if (rNToGo == 1) {
#line 2408
            tmp___2 = 1;
          } else {
#line 2408
            tmp___2 = 0;
          }
#line 2408
          z = (unsigned char )((int )z ^ tmp___2);
        }
#line 2410
        j2 = 0;
#line 2410
        while (j2 < (int )z) {
#line 2411
          if (dst) {
#line 2411
            retVal = spec_putc((unsigned char )ch2, dst);
          }
#line 2414
          localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
#line 2410
          j2 ++;
        }
#line 2419
        i2 ++;
#line 2420
        count = 0;
      }
    }
  }
#line 2426
  setGlobalCRC(localCrc);
#line 2429
  return;
}
}
#line 2437 "bzip2.c"
void undoReversibleTransformation_fast(int dst ) 
{ int cftab[257] ;
  int i ;
  int tPos ;
  unsigned char ch ;
  int retVal ;
  int i2 ;
  int count ;
  int chPrev ;
  int ch2 ;
  unsigned int localCrc ;
  int rNToGo ;
  int rTPos ;
  int tmp ;
  int j2 ;
  unsigned char z ;
  int tmp___0 ;
  int j2___0 ;
  unsigned char z___0 ;

  {
#line 2450
  cftab[0] = 0;
#line 2451
  i = 1;
#line 2451
  while (i <= 256) {
#line 2451
    cftab[i] = unzftab[i - 1];
#line 2451
    i ++;
  }
#line 2452
  i = 1;
#line 2452
  while (i <= 256) {
#line 2452
    cftab[i] += cftab[i - 1];
#line 2452
    i ++;
  }
#line 2455
  i = 0;
#line 2455
  while (i <= last) {
#line 2456
    ch = *(ll8 + i);
#line 2457
    *(tt + cftab[ch]) = i;
#line 2458
    (cftab[ch]) ++;
#line 2455
    i ++;
  }
#line 2467
  tPos = *(tt + origPtr);
#line 2483
  count = 0;
#line 2484
  i2 = 0;
#line 2485
  ch2 = 256;
#line 2486
  localCrc = getGlobalCRC();
#line 2488
  if (blockRandomised) {
#line 2489
    rNToGo = 0;
#line 2490
    rTPos = 0;
#line 2491
    while (i2 <= last) {
#line 2492
      chPrev = ch2;
#line 2493
      ch2 = (int )*(ll8 + tPos);
#line 2494
      tPos = *(tt + tPos);
#line 2495
      if (rNToGo == 0) {
#line 2496
        rNToGo = rNums[rTPos];
#line 2497
        rTPos ++;
#line 2497
        if (rTPos == 512) {
#line 2497
          rTPos = 0;
        }
      }
#line 2499
      rNToGo --;
#line 2500
      if (rNToGo == 1) {
#line 2500
        tmp = 1;
      } else {
#line 2500
        tmp = 0;
      }
#line 2500
      ch2 = (int )((unsigned int )ch2 ^ (unsigned int )tmp);
#line 2501
      i2 ++;
#line 2503
      retVal = spec_putc((unsigned char )ch2, dst);
#line 2506
      localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
#line 2510
      if (ch2 != chPrev) {
#line 2511
        count = 1;
      } else {
#line 2513
        count ++;
#line 2514
        if (count >= 4) {
#line 2517
          z = *(ll8 + tPos);
#line 2518
          tPos = *(tt + tPos);
#line 2519
          if (rNToGo == 0) {
#line 2520
            rNToGo = rNums[rTPos];
#line 2521
            rTPos ++;
#line 2521
            if (rTPos == 512) {
#line 2521
              rTPos = 0;
            }
          }
#line 2523
          rNToGo --;
#line 2524
          if (rNToGo == 1) {
#line 2524
            tmp___0 = 1;
          } else {
#line 2524
            tmp___0 = 0;
          }
#line 2524
          z = (unsigned char )((int )z ^ tmp___0);
#line 2525
          j2 = 0;
#line 2525
          while (j2 < (int )z) {
#line 2526
            retVal = spec_putc((unsigned char )ch2, dst);
#line 2528
            localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
#line 2525
            j2 ++;
          }
#line 2532
          i2 ++;
#line 2533
          count = 0;
        }
      }
    }
  } else {
#line 2540
    while (i2 <= last) {
#line 2541
      chPrev = ch2;
#line 2543
      ch2 = (int )*(ll8 + tPos);
#line 2544
      tPos = *(tt + tPos);
#line 2545
      i2 ++;
#line 2547
      retVal = spec_putc((unsigned char )ch2, dst);
#line 2549
      localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
#line 2553
      if (ch2 != chPrev) {
#line 2554
        count = 1;
      } else {
#line 2556
        count ++;
#line 2557
        if (count >= 4) {
#line 2561
          z___0 = *(ll8 + tPos);
#line 2562
          tPos = *(tt + tPos);
#line 2563
          j2___0 = 0;
#line 2563
          while (j2___0 < (int )z___0) {
#line 2564
            retVal = spec_putc((unsigned char )ch2, dst);
#line 2566
            localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
#line 2563
            j2___0 ++;
          }
#line 2570
          i2 ++;
#line 2571
          count = 0;
        }
      }
    }
  }
#line 2578
  setGlobalCRC(localCrc);
#line 2581
  return;
}
}
#line 2596 "bzip2.c"
int getRLEpair(int src ) 
{ int runLength ;
  int ch ;
  int chLatest ;
  int tmp ;
  int i ;

  {
#line 2602
  ch = spec_getc(src);
#line 2604
  if (ch == -1) {
#line 2605
    ERROR_IF_NOT_ZERO(0);
#line 2606
    return ((1 << 16) | 257);
  }
#line 2609
  runLength = 0;
#line 2610
  while (1) {
#line 2611
    chLatest = spec_getc(src);
#line 2612
    runLength ++;
#line 2613
    bytesIn ++;
#line 2610
    if (ch == chLatest) {
#line 2610
      if (! (runLength < 255)) {
#line 2610
        break;
      }
    } else {
#line 2610
      break;
    }
  }
#line 2617
  if (chLatest != -1) {
#line 2618
    tmp = spec_ungetc((unsigned char )chLatest, src);
#line 2618
    if (tmp == -1) {
#line 2619
      panic((char *)"getRLEpair: ungetc failed");
    }
  } else {
#line 2621
    ERROR_IF_NOT_ZERO(0);
  }
#line 2625
  if (runLength == 1) {
#line 2627
    globalCrc = (globalCrc << 8) ^ crc32Table[(globalCrc >> 24) ^ (unsigned int )((unsigned char )ch)];
#line 2630
    return ((1 << 16) | ch);
  } else {
#line 2633
    i = 1;
#line 2633
    while (i <= runLength) {
#line 2635
      globalCrc = (globalCrc << 8) ^ crc32Table[(globalCrc >> 24) ^ (unsigned int )((unsigned char )ch)];
#line 2633
      i ++;
    }
#line 2638
    return ((runLength << 16) | ch);
  }
}
}
#line 2644 "bzip2.c"
void loadAndRLEsource(int src ) 
{ int ch ;
  int allowableBlockSize ;
  int i ;
  int rlePair ;
  int runLen ;

  {
#line 2648
  last = -1;
#line 2649
  ch = 0;
#line 2651
  i = 0;
#line 2651
  while (i < 256) {
#line 2651
    inUse[i] = (unsigned char)0;
#line 2651
    i ++;
  }
#line 2654
  allowableBlockSize = 100000 * blockSize100k - 20;
#line 2656
  while (1) {
#line 2656
    if (last < allowableBlockSize) {
#line 2656
      if (! (ch != 257)) {
#line 2656
        break;
      }
    } else {
#line 2656
      break;
    }
#line 2658
    rlePair = getRLEpair(src);
#line 2659
    ch = rlePair & 65535;
#line 2660
    runLen = (int )((unsigned int )rlePair >> 16);
#line 2661
    if (ch != 257) {
#line 2662
      inUse[ch] = (unsigned char)1;
#line 2663
      switch (runLen) {
      case 1: 
#line 2665
      last ++;
#line 2665
      *(block + last) = (unsigned char )ch;
#line 2665
      break;
      case 2: 
#line 2667
      last ++;
#line 2667
      *(block + last) = (unsigned char )ch;
#line 2668
      last ++;
#line 2668
      *(block + last) = (unsigned char )ch;
#line 2668
      break;
      case 3: 
#line 2670
      last ++;
#line 2670
      *(block + last) = (unsigned char )ch;
#line 2671
      last ++;
#line 2671
      *(block + last) = (unsigned char )ch;
#line 2672
      last ++;
#line 2672
      *(block + last) = (unsigned char )ch;
#line 2672
      break;
      default: 
#line 2674
      inUse[runLen - 4] = (unsigned char)1;
#line 2675
      last ++;
#line 2675
      *(block + last) = (unsigned char )ch;
#line 2676
      last ++;
#line 2676
      *(block + last) = (unsigned char )ch;
#line 2677
      last ++;
#line 2677
      *(block + last) = (unsigned char )ch;
#line 2678
      last ++;
#line 2678
      *(block + last) = (unsigned char )ch;
#line 2679
      last ++;
#line 2679
      *(block + last) = (unsigned char )(runLen - 4);
#line 2679
      break;
      }
    }
  }
#line 2683
  return;
}
}
#line 2691 "bzip2.c"
void compressStream(int stream , int zStream ) 
{ int retVal ;
  unsigned int blockCRC ;
  unsigned int combinedCRC ;
  int blockNo ;
  struct _reent *tmp ;
  struct _reent *tmp___0 ;
  char const   *tmp___1 ;
  struct _reent *tmp___2 ;
  struct _reent *tmp___3 ;
  struct _reent *tmp___4 ;

  {
#line 2698
  blockNo = 0;
#line 2699
  bytesIn = 0U;
#line 2700
  bytesOut = 0U;
#line 2701
  nBlocksRandomised = 0;
#line 2706
  ERROR_IF_NOT_ZERO(0);
#line 2707
  ERROR_IF_NOT_ZERO(0);
#line 2709
  bsSetStream(zStream, (unsigned char)1);
#line 2715
  bsPutUChar((unsigned char )'B');
#line 2716
  bsPutUChar((unsigned char )'Z');
#line 2717
  bsPutUChar((unsigned char )'h');
#line 2718
  bsPutUChar((unsigned char )(48 + blockSize100k));
#line 2720
  combinedCRC = 0U;
#line 2722
  if (verbosity >= 2) {
#line 2722
    tmp = __getreent();
#line 2722
    fprintf(tmp->_stderr, "\n");
  }
#line 2724
  while (1) {
#line 2726
    blockNo ++;
#line 2727
    initialiseCRC();
#line 2728
    loadAndRLEsource(stream);
#line 2729
    ERROR_IF_NOT_ZERO(0);
#line 2730
    if (last == -1) {
#line 2730
      break;
    }
#line 2732
    blockCRC = getFinalCRC();
#line 2733
    combinedCRC = (combinedCRC << 1) | (combinedCRC >> 31);
#line 2734
    combinedCRC ^= blockCRC;
#line 2736
    if (verbosity >= 2) {
#line 2737
      tmp___0 = __getreent();
#line 2737
      fprintf(tmp___0->_stderr, "    block %d: crc = 0x%8x, combined CRC = 0x%8x, size = %d",
              blockNo, blockCRC, combinedCRC, last + 1);
    }
#line 2741
    doReversibleTransformation();
#line 2755
    bsPutUChar((unsigned char)49);
#line 2755
    bsPutUChar((unsigned char)65);
#line 2756
    bsPutUChar((unsigned char)89);
#line 2756
    bsPutUChar((unsigned char)38);
#line 2757
    bsPutUChar((unsigned char)83);
#line 2757
    bsPutUChar((unsigned char)89);
#line 2760
    bsPutUInt32(blockCRC);
#line 2763
    if (blockRandomised) {
#line 2764
      bsW(1, 1U);
#line 2764
      nBlocksRandomised ++;
    } else {
#line 2766
      bsW(1, 0U);
    }
#line 2769
    moveToFrontCodeAndSend();
#line 2771
    ERROR_IF_NOT_ZERO(0);
  }
#line 2774
  if (verbosity >= 2) {
#line 2774
    if (nBlocksRandomised > 0) {
#line 2775
      if (nBlocksRandomised == 1) {
#line 2775
        tmp___1 = "";
      } else {
#line 2775
        tmp___1 = "s";
      }
#line 2775
      tmp___2 = __getreent();
#line 2775
      fprintf(tmp___2->_stderr, "    %d block%s needed randomisation\n", nBlocksRandomised,
              tmp___1);
    }
  }
#line 2787
  bsPutUChar((unsigned char)23);
#line 2787
  bsPutUChar((unsigned char)114);
#line 2788
  bsPutUChar((unsigned char)69);
#line 2788
  bsPutUChar((unsigned char)56);
#line 2789
  bsPutUChar((unsigned char)80);
#line 2789
  bsPutUChar((unsigned char)144);
#line 2791
  bsPutUInt32(combinedCRC);
#line 2792
  if (verbosity >= 2) {
#line 2793
    tmp___3 = __getreent();
#line 2793
    fprintf(tmp___3->_stderr, "    final combined CRC = 0x%x\n   ", combinedCRC);
  }
#line 2796
  bsFinishedWithStream();
#line 2798
  ERROR_IF_NOT_ZERO(0);
#line 2799
  retVal = 0;
#line 2800
  ERROR_IF_EOF(retVal);
#line 2801
  retVal = 0;
#line 2802
  ERROR_IF_EOF(retVal);
#line 2804
  ERROR_IF_NOT_ZERO(0);
#line 2805
  retVal = 0;
#line 2806
  ERROR_IF_EOF(retVal);
#line 2808
  if (bytesIn == 0U) {
#line 2808
    bytesIn = 1U;
  }
#line 2809
  if (bytesOut == 0U) {
#line 2809
    bytesOut = 1U;
  }
#line 2811
  if (verbosity >= 1) {
#line 2812
    tmp___4 = __getreent();
#line 2812
    fprintf(tmp___4->_stderr, "%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %d in, %d out.\n",
            (float )bytesIn / (float )bytesOut, (8.0 * (double )((float )bytesOut)) / (double )((float )bytesIn),
            100.0 * (1.0 - (double )((float )bytesOut / (float )bytesIn)), bytesIn,
            bytesOut);
  }
#line 2820
  return;
}
}
#line 2825 "bzip2.c"
unsigned char uncompressStream(int zStream , int stream ) 
{ unsigned char magic1 ;
  unsigned char magic2 ;
  unsigned char magic3 ;
  unsigned char magic4 ;
  unsigned char magic5 ;
  unsigned char magic6 ;
  unsigned int storedBlockCRC ;
  unsigned int storedCombinedCRC ;
  unsigned int computedBlockCRC ;
  unsigned int computedCombinedCRC ;
  int currBlockNo ;
  int retVal ;
  struct _reent *tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  struct _reent *tmp___2 ;
  struct _reent *tmp___3 ;
  struct _reent *tmp___4 ;
  struct _reent *tmp___5 ;
  struct _reent *tmp___6 ;
  int tmp___7 ;
  struct _reent *tmp___8 ;

  {
#line 2837
  ERROR_IF_NOT_ZERO(0);
#line 2838
  ERROR_IF_NOT_ZERO(0);
#line 2840
  bsSetStream(zStream, (unsigned char)0);
#line 2846
  magic1 = bsGetUChar();
#line 2847
  magic2 = bsGetUChar();
#line 2848
  magic3 = bsGetUChar();
#line 2849
  magic4 = bsGetUChar();
#line 2850
  if ((int )magic1 != 66) {
#line 2855
    bsFinishedWithStream();
#line 2856
    retVal = 0;
#line 2857
    ERROR_IF_EOF(retVal);
#line 2858
    return ((unsigned char)0);
  } else {
#line 2850
    if ((int )magic2 != 90) {
#line 2855
      bsFinishedWithStream();
#line 2856
      retVal = 0;
#line 2857
      ERROR_IF_EOF(retVal);
#line 2858
      return ((unsigned char)0);
    } else {
#line 2850
      if ((int )magic3 != 104) {
#line 2855
        bsFinishedWithStream();
#line 2856
        retVal = 0;
#line 2857
        ERROR_IF_EOF(retVal);
#line 2858
        return ((unsigned char)0);
      } else {
#line 2850
        if ((int )magic4 < 49) {
#line 2855
          bsFinishedWithStream();
#line 2856
          retVal = 0;
#line 2857
          ERROR_IF_EOF(retVal);
#line 2858
          return ((unsigned char)0);
        } else {
#line 2850
          if ((int )magic4 > 57) {
#line 2855
            bsFinishedWithStream();
#line 2856
            retVal = 0;
#line 2857
            ERROR_IF_EOF(retVal);
#line 2858
            return ((unsigned char)0);
          }
        }
      }
    }
  }
#line 2861
  setDecompressStructureSizes((int )magic4 - 48);
#line 2862
  computedCombinedCRC = 0U;
#line 2864
  if (verbosity >= 2) {
#line 2864
    tmp = __getreent();
#line 2864
    fprintf(tmp->_stderr, "\n    ");
  }
#line 2865
  currBlockNo = 0;
#line 2867
  while (1) {
#line 2868
    magic1 = bsGetUChar();
#line 2869
    magic2 = bsGetUChar();
#line 2870
    magic3 = bsGetUChar();
#line 2871
    magic4 = bsGetUChar();
#line 2872
    magic5 = bsGetUChar();
#line 2873
    magic6 = bsGetUChar();
#line 2874
    if ((int )magic1 == 23) {
#line 2874
      if ((int )magic2 == 114) {
#line 2874
        if ((int )magic3 == 69) {
#line 2874
          if ((int )magic4 == 56) {
#line 2874
            if ((int )magic5 == 80) {
#line 2874
              if ((int )magic6 == 144) {
#line 2876
                break;
              }
            }
          }
        }
      }
    }
#line 2878
    if ((int )magic1 != 49) {
#line 2880
      badBlockHeader();
    } else {
#line 2878
      if ((int )magic2 != 65) {
#line 2880
        badBlockHeader();
      } else {
#line 2878
        if ((int )magic3 != 89) {
#line 2880
          badBlockHeader();
        } else {
#line 2878
          if ((int )magic4 != 38) {
#line 2880
            badBlockHeader();
          } else {
#line 2878
            if ((int )magic5 != 83) {
#line 2880
              badBlockHeader();
            } else {
#line 2878
              if ((int )magic6 != 89) {
#line 2880
                badBlockHeader();
              }
            }
          }
        }
      }
    }
#line 2882
    tmp___0 = bsGetUInt32();
#line 2882
    storedBlockCRC = (unsigned int )tmp___0;
#line 2884
    tmp___1 = bsR(1);
#line 2884
    if (tmp___1 == 1U) {
#line 2885
      blockRandomised = (unsigned char)1;
    } else {
#line 2886
      blockRandomised = (unsigned char)0;
    }
#line 2888
    currBlockNo ++;
#line 2889
    if (verbosity >= 2) {
#line 2890
      tmp___2 = __getreent();
#line 2890
      fprintf(tmp___2->_stderr, "[%d: huff+mtf ", currBlockNo);
    }
#line 2891
    getAndMoveToFrontDecode();
#line 2892
    ERROR_IF_NOT_ZERO(0);
#line 2894
    initialiseCRC();
#line 2895
    if (verbosity >= 2) {
#line 2895
      tmp___3 = __getreent();
#line 2895
      fprintf(tmp___3->_stderr, "rt+rld");
    }
#line 2896
    if (smallMode) {
#line 2897
      undoReversibleTransformation_small(stream);
    } else {
#line 2899
      undoReversibleTransformation_fast(stream);
    }
#line 2901
    ERROR_IF_NOT_ZERO(0);
#line 2903
    computedBlockCRC = getFinalCRC();
#line 2904
    if (verbosity >= 3) {
#line 2905
      tmp___4 = __getreent();
#line 2905
      fprintf(tmp___4->_stderr, " {0x%x, 0x%x}", storedBlockCRC, computedBlockCRC);
    }
#line 2906
    if (verbosity >= 2) {
#line 2906
      tmp___5 = __getreent();
#line 2906
      fprintf(tmp___5->_stderr, "] ");
    }
#line 2909
    if (storedBlockCRC != computedBlockCRC) {
#line 2910
      crcError(storedBlockCRC, computedBlockCRC);
    }
#line 2912
    computedCombinedCRC = (computedCombinedCRC << 1) | (computedCombinedCRC >> 31);
#line 2913
    computedCombinedCRC ^= computedBlockCRC;
  }
#line 2916
  if (verbosity >= 2) {
#line 2916
    tmp___6 = __getreent();
#line 2916
    fprintf(tmp___6->_stderr, "\n    ");
  }
#line 2918
  tmp___7 = bsGetUInt32();
#line 2918
  storedCombinedCRC = (unsigned int )tmp___7;
#line 2919
  if (verbosity >= 2) {
#line 2920
    tmp___8 = __getreent();
#line 2920
    fprintf(tmp___8->_stderr, "combined CRCs: stored = 0x%x, computed = 0x%x\n    ",
            storedCombinedCRC, computedCombinedCRC);
  }
#line 2923
  if (storedCombinedCRC != computedCombinedCRC) {
#line 2924
    crcError(storedCombinedCRC, computedCombinedCRC);
  }
#line 2927
  bsFinishedWithStream();
#line 2928
  ERROR_IF_NOT_ZERO(0);
#line 2929
  retVal = 0;
#line 2930
  ERROR_IF_EOF(retVal);
#line 2932
  ERROR_IF_NOT_ZERO(0);
#line 2933
  retVal = 0;
#line 2934
  ERROR_IF_NOT_ZERO(retVal);
#line 2935
  return ((unsigned char)1);
}
}
#line 2940 "bzip2.c"
unsigned char testStream(int zStream ) 
{ unsigned char magic1 ;
  unsigned char magic2 ;
  unsigned char magic3 ;
  unsigned char magic4 ;
  unsigned char magic5 ;
  unsigned char magic6 ;
  unsigned int storedBlockCRC ;
  unsigned int storedCombinedCRC ;
  unsigned int computedBlockCRC ;
  unsigned int computedCombinedCRC ;
  int currBlockNo ;
  int retVal ;
  struct _reent *tmp ;
  struct _reent *tmp___0 ;
  struct _reent *tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  struct _reent *tmp___4 ;
  struct _reent *tmp___5 ;
  struct _reent *tmp___6 ;
  struct _reent *tmp___7 ;
  struct _reent *tmp___8 ;
  struct _reent *tmp___9 ;
  int tmp___10 ;
  struct _reent *tmp___11 ;
  struct _reent *tmp___12 ;

  {
#line 2950
  ERROR_IF_NOT_ZERO(0);
#line 2952
  bsSetStream(zStream, (unsigned char)0);
#line 2954
  magic1 = bsGetUChar();
#line 2955
  magic2 = bsGetUChar();
#line 2956
  magic3 = bsGetUChar();
#line 2957
  magic4 = bsGetUChar();
#line 2958
  if ((int )magic1 != 66) {
#line 2963
    bsFinishedWithStream();
#line 2964
    fclose((FILE *)zStream);
#line 2965
    tmp = __getreent();
#line 2965
    fprintf(tmp->_stderr, "\n%s: bad magic number (ie, not created by bzip2)\n", inName);
#line 2967
    return ((unsigned char)0);
  } else {
#line 2958
    if ((int )magic2 != 90) {
#line 2963
      bsFinishedWithStream();
#line 2964
      fclose((FILE *)zStream);
#line 2965
      tmp = __getreent();
#line 2965
      fprintf(tmp->_stderr, "\n%s: bad magic number (ie, not created by bzip2)\n",
              inName);
#line 2967
      return ((unsigned char)0);
    } else {
#line 2958
      if ((int )magic3 != 104) {
#line 2963
        bsFinishedWithStream();
#line 2964
        fclose((FILE *)zStream);
#line 2965
        tmp = __getreent();
#line 2965
        fprintf(tmp->_stderr, "\n%s: bad magic number (ie, not created by bzip2)\n",
                inName);
#line 2967
        return ((unsigned char)0);
      } else {
#line 2958
        if ((int )magic4 < 49) {
#line 2963
          bsFinishedWithStream();
#line 2964
          fclose((FILE *)zStream);
#line 2965
          tmp = __getreent();
#line 2965
          fprintf(tmp->_stderr, "\n%s: bad magic number (ie, not created by bzip2)\n",
                  inName);
#line 2967
          return ((unsigned char)0);
        } else {
#line 2958
          if ((int )magic4 > 57) {
#line 2963
            bsFinishedWithStream();
#line 2964
            fclose((FILE *)zStream);
#line 2965
            tmp = __getreent();
#line 2965
            fprintf(tmp->_stderr, "\n%s: bad magic number (ie, not created by bzip2)\n",
                    inName);
#line 2967
            return ((unsigned char)0);
          }
        }
      }
    }
  }
#line 2970
  smallMode = (unsigned char)1;
#line 2971
  setDecompressStructureSizes((int )magic4 - 48);
#line 2972
  computedCombinedCRC = 0U;
#line 2974
  if (verbosity >= 2) {
#line 2974
    tmp___0 = __getreent();
#line 2974
    fprintf(tmp___0->_stderr, "\n");
  }
#line 2975
  currBlockNo = 0;
#line 2977
  while (1) {
#line 2978
    magic1 = bsGetUChar();
#line 2979
    magic2 = bsGetUChar();
#line 2980
    magic3 = bsGetUChar();
#line 2981
    magic4 = bsGetUChar();
#line 2982
    magic5 = bsGetUChar();
#line 2983
    magic6 = bsGetUChar();
#line 2984
    if ((int )magic1 == 23) {
#line 2984
      if ((int )magic2 == 114) {
#line 2984
        if ((int )magic3 == 69) {
#line 2984
          if ((int )magic4 == 56) {
#line 2984
            if ((int )magic5 == 80) {
#line 2984
              if ((int )magic6 == 144) {
#line 2986
                break;
              }
            }
          }
        }
      }
    }
#line 2988
    currBlockNo ++;
#line 2989
    if ((int )magic1 != 49) {
#line 2992
      bsFinishedWithStream();
#line 2993
      fclose((FILE *)zStream);
#line 2994
      tmp___1 = __getreent();
#line 2994
      fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
              inName, currBlockNo);
#line 2997
      return ((unsigned char)0);
    } else {
#line 2989
      if ((int )magic2 != 65) {
#line 2992
        bsFinishedWithStream();
#line 2993
        fclose((FILE *)zStream);
#line 2994
        tmp___1 = __getreent();
#line 2994
        fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
                inName, currBlockNo);
#line 2997
        return ((unsigned char)0);
      } else {
#line 2989
        if ((int )magic3 != 89) {
#line 2992
          bsFinishedWithStream();
#line 2993
          fclose((FILE *)zStream);
#line 2994
          tmp___1 = __getreent();
#line 2994
          fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
                  inName, currBlockNo);
#line 2997
          return ((unsigned char)0);
        } else {
#line 2989
          if ((int )magic4 != 38) {
#line 2992
            bsFinishedWithStream();
#line 2993
            fclose((FILE *)zStream);
#line 2994
            tmp___1 = __getreent();
#line 2994
            fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
                    inName, currBlockNo);
#line 2997
            return ((unsigned char)0);
          } else {
#line 2989
            if ((int )magic5 != 83) {
#line 2992
              bsFinishedWithStream();
#line 2993
              fclose((FILE *)zStream);
#line 2994
              tmp___1 = __getreent();
#line 2994
              fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
                      inName, currBlockNo);
#line 2997
              return ((unsigned char)0);
            } else {
#line 2989
              if ((int )magic6 != 89) {
#line 2992
                bsFinishedWithStream();
#line 2993
                fclose((FILE *)zStream);
#line 2994
                tmp___1 = __getreent();
#line 2994
                fprintf(tmp___1->_stderr, "\n%s, block %d: bad header (not == 0x314159265359)\n",
                        inName, currBlockNo);
#line 2997
                return ((unsigned char)0);
              }
            }
          }
        }
      }
    }
#line 2999
    tmp___2 = bsGetUInt32();
#line 2999
    storedBlockCRC = (unsigned int )tmp___2;
#line 3001
    tmp___3 = bsR(1);
#line 3001
    if (tmp___3 == 1U) {
#line 3002
      blockRandomised = (unsigned char)1;
    } else {
#line 3003
      blockRandomised = (unsigned char)0;
    }
#line 3005
    if (verbosity >= 2) {
#line 3006
      tmp___4 = __getreent();
#line 3006
      fprintf(tmp___4->_stderr, "    block [%d: huff+mtf ", currBlockNo);
    }
#line 3007
    getAndMoveToFrontDecode();
#line 3008
    ERROR_IF_NOT_ZERO(0);
#line 3010
    initialiseCRC();
#line 3011
    if (verbosity >= 2) {
#line 3011
      tmp___5 = __getreent();
#line 3011
      fprintf(tmp___5->_stderr, "rt+rld");
    }
#line 3013
    undoReversibleTransformation_small(0);
#line 3016
    computedBlockCRC = getFinalCRC();
#line 3017
    if (verbosity >= 3) {
#line 3018
      tmp___6 = __getreent();
#line 3018
      fprintf(tmp___6->_stderr, " {0x%x, 0x%x}", storedBlockCRC, computedBlockCRC);
    }
#line 3019
    if (verbosity >= 2) {
#line 3019
      tmp___7 = __getreent();
#line 3019
      fprintf(tmp___7->_stderr, "] ");
    }
#line 3021
    if (storedBlockCRC != computedBlockCRC) {
#line 3022
      bsFinishedWithStream();
#line 3023
      fclose((FILE *)zStream);
#line 3024
      tmp___8 = __getreent();
#line 3024
      fprintf(tmp___8->_stderr, "\n%s, block %d: computed CRC does not match stored one\n",
              inName, currBlockNo);
#line 3026
      return ((unsigned char)0);
    }
#line 3029
    if (verbosity >= 2) {
#line 3029
      tmp___9 = __getreent();
#line 3029
      fprintf(tmp___9->_stderr, "ok\n");
    }
#line 3030
    computedCombinedCRC = (computedCombinedCRC << 1) | (computedCombinedCRC >> 31);
#line 3031
    computedCombinedCRC ^= computedBlockCRC;
  }
#line 3034
  tmp___10 = bsGetUInt32();
#line 3034
  storedCombinedCRC = (unsigned int )tmp___10;
#line 3035
  if (verbosity >= 2) {
#line 3036
    tmp___11 = __getreent();
#line 3036
    fprintf(tmp___11->_stderr, "    combined CRCs: stored = 0x%x, computed = 0x%x\n    ",
            storedCombinedCRC, computedCombinedCRC);
  }
#line 3039
  if (storedCombinedCRC != computedCombinedCRC) {
#line 3040
    bsFinishedWithStream();
#line 3041
    fclose((FILE *)zStream);
#line 3042
    tmp___12 = __getreent();
#line 3042
    fprintf(tmp___12->_stderr, "\n%s: computed CRC does not match stored one\n", inName);
#line 3044
    return ((unsigned char)0);
  }
#line 3047
  bsFinishedWithStream();
#line 3048
  ERROR_IF_NOT_ZERO(0);
#line 3049
  retVal = 0;
#line 3050
  ERROR_IF_EOF(retVal);
#line 3051
  return ((unsigned char)1);
}
}
#line 3061 "bzip2.c"
void cadvise(void) 
{ struct _reent *tmp ;

  {
#line 3063
  tmp = __getreent();
#line 3063
  fprintf(tmp->_stderr, "\nIt is possible that the compressed file(s) have become corrupted.\nYou can use the -tvv option to test integrity of such files.\n\nYou can use the `bzip2recover\' program to *attempt* to recover\ndata from undamaged sections of corrupted files.\n\n");
#line 3070
  return;
}
}
#line 3074 "bzip2.c"
void showFileNames(void) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  struct _reent *tmp___1 ;

  {
#line 3076
  if ((unsigned int )(outName) == (unsigned int )((void *)0)) {
#line 3076
    tmp = "(null)";
  } else {
#line 3076
    tmp = (char const   *)(outName);
  }
#line 3076
  if ((unsigned int )(inName) == (unsigned int )((void *)0)) {
#line 3076
    tmp___0 = "(null)";
  } else {
#line 3076
    tmp___0 = (char const   *)(inName);
  }
#line 3076
  tmp___1 = __getreent();
#line 3076
  fprintf(tmp___1->_stderr, "\tInput file = %s, output file = %s\n", tmp___0, tmp);
#line 3082
  return;
}
}
#line 3086 "bzip2.c"
void cleanUpAndFail(int ec ) 
{ int retVal ;
  char const   *tmp ;
  struct _reent *tmp___0 ;
  struct _reent *tmp___1 ;
  struct _reent *tmp___2 ;

  {
#line 3090
  if (srcMode == 3) {
#line 3090
    if (opMode != 3) {
#line 3091
      if ((unsigned int )(outName) == (unsigned int )((void *)0)) {
#line 3091
        tmp = "(null)";
      } else {
#line 3091
        tmp = (char const   *)(outName);
      }
#line 3091
      tmp___0 = __getreent();
#line 3091
      fprintf(tmp___0->_stderr, "%s: Deleting output file %s, if it exists.\n", progName,
              tmp);
#line 3094
      retVal = remove((char const   *)(outName));
#line 3095
      if (retVal != 0) {
#line 3096
        tmp___1 = __getreent();
#line 3096
        fprintf(tmp___1->_stderr, "%s: WARNING: deletion of output file (apparently) failed.\n",
                progName);
      }
    }
  }
#line 3100
  if (numFileNames > 0) {
#line 3100
    if (numFilesProcessed < numFileNames) {
#line 3101
      tmp___2 = __getreent();
#line 3101
      fprintf(tmp___2->_stderr, "%s: WARNING: some files have not been processed:\n\t%d specified on command line, %d not processed yet.\n\n",
              progName, numFileNames, numFileNames - numFilesProcessed);
    }
  }
#line 3107
  exit(ec);
}
}
#line 3112 "bzip2.c"
void panic(char *s ) 
{ struct _reent *tmp ;

  {
#line 3114
  tmp = __getreent();
#line 3114
  fprintf(tmp->_stderr, "\n%s: PANIC -- internal consistency error:\n\t%s\n\tThis is a BUG.  Please report it to me at:\n\tjseward@acm.org\n",
          progName, s);
#line 3120
  showFileNames();
#line 3121
  cleanUpAndFail(3);
#line 3122
  return;
}
}
#line 3126 "bzip2.c"
void badBGLengths(void) 
{ struct _reent *tmp ;

  {
#line 3128
  tmp = __getreent();
#line 3128
  fprintf(tmp->_stderr, "\n%s: error when reading background model code lengths,\n\twhich probably means the compressed file is corrupted.\n",
          progName);
#line 3132
  showFileNames();
#line 3133
  cadvise();
#line 3134
  cleanUpAndFail(2);
#line 3135
  return;
}
}
#line 3139 "bzip2.c"
void crcError(unsigned int crcStored , unsigned int crcComputed ) 
{ struct _reent *tmp ;

  {
#line 3141
  tmp = __getreent();
#line 3141
  fprintf(tmp->_stderr, "\n%s: Data integrity error when decompressing.\n\tStored CRC = 0x%x, computed CRC = 0x%x\n",
          progName, crcStored, crcComputed);
#line 3145
  showFileNames();
#line 3146
  cadvise();
#line 3147
  cleanUpAndFail(2);
#line 3148
  return;
}
}
#line 3152 "bzip2.c"
void compressedStreamEOF(void) 
{ struct _reent *tmp ;

  {
#line 3154
  tmp = __getreent();
#line 3154
  fprintf(tmp->_stderr, "\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n",
          progName);
#line 3158
  perror((char const   *)progName);
#line 3159
  showFileNames();
#line 3160
  cadvise();
#line 3161
  cleanUpAndFail(2);
#line 3162
  return;
}
}
#line 3166 "bzip2.c"
void ioError(void) 
{ struct _reent *tmp ;

  {
#line 3168
  tmp = __getreent();
#line 3168
  fprintf(tmp->_stderr, "\n%s: I/O or other error, bailing out.  Possible reason follows.\n",
          progName);
#line 3171
  perror((char const   *)progName);
#line 3172
  showFileNames();
#line 3173
  cleanUpAndFail(1);
#line 3174
  return;
}
}
#line 3178 "bzip2.c"
void blockOverrun(void) 
{ struct _reent *tmp ;

  {
#line 3180
  tmp = __getreent();
#line 3180
  fprintf(tmp->_stderr, "\n%s: block overrun during decompression,\n\twhich probably means the compressed file\n\tis corrupted.\n",
          progName);
#line 3185
  showFileNames();
#line 3186
  cadvise();
#line 3187
  cleanUpAndFail(2);
#line 3188
  return;
}
}
#line 3192 "bzip2.c"
void badBlockHeader(void) 
{ struct _reent *tmp ;

  {
#line 3194
  tmp = __getreent();
#line 3194
  fprintf(tmp->_stderr, "\n%s: bad block header in the compressed file,\n\twhich probably means it is corrupted.\n",
          progName);
#line 3198
  showFileNames();
#line 3199
  cadvise();
#line 3200
  cleanUpAndFail(2);
#line 3201
  return;
}
}
#line 3205 "bzip2.c"
void bitStreamEOF(void) 
{ struct _reent *tmp ;

  {
#line 3207
  tmp = __getreent();
#line 3207
  fprintf(tmp->_stderr, "\n%s: read past the end of compressed data,\n\twhich probably means it is corrupted.\n",
          progName);
#line 3211
  showFileNames();
#line 3212
  cadvise();
#line 3213
  cleanUpAndFail(2);
#line 3214
  return;
}
}
#line 3218 "bzip2.c"
void mySignalCatcher(int n ) 
{ struct _reent *tmp ;

  {
#line 3220
  tmp = __getreent();
#line 3220
  fprintf(tmp->_stderr, "\n%s: Control-C (or similar) caught, quitting.\n", progName);
#line 3223
  cleanUpAndFail(1);
#line 3224
  return;
}
}
#line 3228 "bzip2.c"
void mySIGSEGVorSIGBUScatcher(int n ) 
{ struct _reent *tmp ;
  struct _reent *tmp___0 ;

  {
#line 3230
  if (opMode == 1) {
#line 3231
    tmp = __getreent();
#line 3231
    fprintf(tmp->_stderr, "\n%s: Caught a SIGSEGV or SIGBUS whilst compressing,\n\twhich probably indicates a bug in bzip2.  Please\n\treport it to me at: jseward@acm.org\n",
            progName);
  } else {
#line 3237
    tmp___0 = __getreent();
#line 3237
    fprintf(tmp___0->_stderr, "\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing,\n\twhich probably indicates that the compressed data\n\tis corrupted.\n",
            progName);
  }
#line 3243
  showFileNames();
#line 3244
  if (opMode == 1) {
#line 3245
    cleanUpAndFail(3);
  } else {
#line 3246
    cadvise();
#line 3246
    cleanUpAndFail(2);
  }
#line 3247
  return;
}
}
#line 3251 "bzip2.c"
void uncompressOutOfMemory(int draw , int blockSize ) 
{ struct _reent *tmp ;

  {
#line 3253
  tmp = __getreent();
#line 3253
  fprintf(tmp->_stderr, "\n%s: Can\'t allocate enough memory for decompression.\n\tRequested %d bytes for a block size of %d.\n\tTry selecting space-economic decompress (with flag -s)\n\tand failing that, find a machine with more memory.\n",
          progName, draw, blockSize);
#line 3259
  showFileNames();
#line 3260
  cleanUpAndFail(1);
#line 3261
  return;
}
}
#line 3265 "bzip2.c"
void compressOutOfMemory(int draw , int blockSize ) 
{ struct _reent *tmp ;

  {
#line 3267
  tmp = __getreent();
#line 3267
  fprintf(tmp->_stderr, "\n%s: Can\'t allocate enough memory for compression.\n\tRequested %d bytes for a block size of %d.\n\tTry selecting a small block size (with flag -s).\n",
          progName, draw, blockSize);
#line 3272
  showFileNames();
#line 3273
  cleanUpAndFail(1);
#line 3274
  return;
}
}
