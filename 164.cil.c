/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 213 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int size_t;
#line 14 "/usr/include/sys/lock.h"
typedef void *_LOCK_T;
#line 15 "/usr/include/sys/_types.h"
typedef long long _off64_t;
#line 18 "/usr/include/sys/_types.h"
typedef int _ssize_t;
#line 354 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int wint_t;
#line 27 "/usr/include/sys/_types.h"
union __anonunion___value_2 {
   wint_t __wch ;
   unsigned char __wchb[4] ;
};
#line 27 "/usr/include/sys/_types.h"
struct __anonstruct__mbstate_t_1 {
   int __count ;
   union __anonunion___value_2 __value ;
};
#line 27 "/usr/include/sys/_types.h"
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
#line 37 "/usr/include/sys/_types.h"
typedef _LOCK_T _flock_t;
#line 19 "/usr/include/sys/reent.h"
typedef unsigned long __ULong;
#line 40 "/usr/include/sys/reent.h"
struct _Bigint {
   struct _Bigint *_next ;
   int _k ;
   int _maxwds ;
   int _sign ;
   int _wds ;
   __ULong _x[1] ;
};
#line 48 "/usr/include/sys/reent.h"
struct __tm {
   int __tm_sec ;
   int __tm_min ;
   int __tm_hour ;
   int __tm_mday ;
   int __tm_mon ;
   int __tm_year ;
   int __tm_wday ;
   int __tm_yday ;
   int __tm_isdst ;
};
#line 67 "/usr/include/sys/reent.h"
struct _on_exit_args {
   void *_fnargs[32] ;
   void *_dso_handle[32] ;
   __ULong _fntypes ;
   __ULong _is_cxa ;
};
#line 85 "/usr/include/sys/reent.h"
struct _atexit {
   struct _atexit *_next ;
   int _ind ;
   void (*_fns[32])(void) ;
   struct _on_exit_args _on_exit_args ;
};
#line 101 "/usr/include/sys/reent.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 111 "/usr/include/sys/reent.h"
typedef long _fpos_t;
#line 115 "/usr/include/sys/reent.h"
typedef _off64_t _fpos64_t;
#line 166
struct _reent;
#line 214 "/usr/include/sys/reent.h"
struct __sFILE64 {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   struct _reent *_data ;
   void *_cookie ;
   _ssize_t ( __attribute__((__cdecl__)) (*_read))(void *_cookie , char *_buf , int _n ) ;
   _ssize_t ( __attribute__((__cdecl__)) (*_write))(void *_cookie , char const   *_buf ,
                                                    int _n ) ;
   _fpos_t ( __attribute__((__cdecl__)) (*_seek))(void *_cookie , _fpos_t _offset ,
                                                  int _whence ) ;
   int ( __attribute__((__cdecl__)) (*_close))(void *_cookie ) ;
   struct __sbuf _ub ;
   unsigned char *_up ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   int _flags2 ;
   _off64_t _offset ;
   _fpos64_t ( __attribute__((__cdecl__)) (*_seek64))(void *_cookie , _fpos64_t _offset ,
                                                      int _whence ) ;
   _flock_t _lock ;
};
#line 257 "/usr/include/sys/reent.h"
typedef struct __sFILE64 __FILE;
#line 262 "/usr/include/sys/reent.h"
struct _glue {
   struct _glue *_next ;
   int _niobs ;
   __FILE *_iobs ;
};
#line 290 "/usr/include/sys/reent.h"
struct _rand48 {
   unsigned short _seed[3] ;
   unsigned short _mult[3] ;
   unsigned short _add ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__reent_4 {
   unsigned int _unused_rand ;
   char *_strtok_last ;
   char _asctime_buf[26] ;
   struct __tm _localtime_buf ;
   int _gamma_signgam ;
   unsigned long long _rand_next ;
   struct _rand48 _r48 ;
   _mbstate_t _mblen_state ;
   _mbstate_t _mbtowc_state ;
   _mbstate_t _wctomb_state ;
   char _l64a_buf[8] ;
   char _signal_buf[24] ;
   int _getdate_err ;
   _mbstate_t _mbrlen_state ;
   _mbstate_t _mbrtowc_state ;
   _mbstate_t _mbsrtowcs_state ;
   _mbstate_t _wcrtomb_state ;
   _mbstate_t _wcsrtombs_state ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__unused_5 {
   unsigned char *_nextf[30] ;
   unsigned int _nmalloc[30] ;
};
#line 565 "/usr/include/sys/reent.h"
union __anonunion__new_3 {
   struct __anonstruct__reent_4 _reent ;
   struct __anonstruct__unused_5 _unused ;
};
#line 565 "/usr/include/sys/reent.h"
struct _reent {
   int _errno ;
   __FILE *_stdin ;
   __FILE *_stdout ;
   __FILE *_stderr ;
   int _inc ;
   char _emergency[25] ;
   int _current_category ;
   char const   *_current_locale ;
   int __sdidinit ;
   void ( __attribute__((__cdecl__)) (*__cleanup))(struct _reent * ) ;
   struct _Bigint *_result ;
   int _result_k ;
   struct _Bigint *_p5s ;
   struct _Bigint **_freelist ;
   int _cvtlen ;
   char *_cvtbuf ;
   union __anonunion__new_3 _new ;
   struct _atexit *_atexit ;
   struct _atexit _atexit0 ;
   void (**_sig_func)(int  ) ;
   struct _glue __sglue ;
   __FILE __sf[3] ;
};
#line 109 "/usr/include/sys/types.h"
typedef long time_t;
#line 114 "/usr/include/sys/types.h"
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
#line 203 "/usr/include/sys/types.h"
typedef unsigned short nlink_t;
#line 31 "/usr/include/cygwin/types.h"
typedef struct timespec timestruc_t;
#line 37 "/usr/include/cygwin/types.h"
typedef _off64_t off_t;
#line 48 "/usr/include/cygwin/types.h"
typedef unsigned long __dev32_t;
#line 50 "/usr/include/cygwin/types.h"
typedef __dev32_t dev_t;
#line 58 "/usr/include/cygwin/types.h"
typedef long blksize_t;
#line 64 "/usr/include/cygwin/types.h"
typedef long long __blkcnt64_t;
#line 66 "/usr/include/cygwin/types.h"
typedef __blkcnt64_t blkcnt_t;
#line 85 "/usr/include/cygwin/types.h"
typedef unsigned long __uid32_t;
#line 87 "/usr/include/cygwin/types.h"
typedef __uid32_t uid_t;
#line 96 "/usr/include/cygwin/types.h"
typedef unsigned long __gid32_t;
#line 98 "/usr/include/cygwin/types.h"
typedef __gid32_t gid_t;
#line 107 "/usr/include/cygwin/types.h"
typedef unsigned long long __ino64_t;
#line 109 "/usr/include/cygwin/types.h"
typedef __ino64_t ino_t;
#line 205 "/usr/include/cygwin/types.h"
typedef unsigned int mode_t;
#line 50 "/usr/include/stdio.h"
typedef __FILE FILE;
#line 44 "/usr/include/cygwin/signal.h"
#pragma pack(push,4)
#line 101
#pragma pack(pop)
#line 160 "/usr/include/cygwin/signal.h"
typedef void (*_sig_func_ptr)(int  );
#line 15 "/usr/include/signal.h"
struct _reent;
#line 62 "/usr/include/cygwin/stat.h"
struct stat {
   dev_t st_dev ;
   ino_t st_ino ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   off_t st_size ;
   timestruc_t st_atim ;
   timestruc_t st_mtim ;
   timestruc_t st_ctim ;
   blksize_t st_blksize ;
   blkcnt_t st_blocks ;
   long st_spare4[2] ;
};
#line 330 "D:/a/test/164.c"
typedef void *voidp;
#line 353 "D:/a/test/164.c"
typedef unsigned char uch;
#line 354 "D:/a/test/164.c"
typedef unsigned short ush;
#line 355 "D:/a/test/164.c"
typedef unsigned long ulg;
#line 437 "D:/a/test/164.c"
typedef int file_t;
#line 666 "D:/a/test/164.c"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 1568 "D:/a/test/164.c"
typedef unsigned char char_type;
#line 1569 "D:/a/test/164.c"
typedef long code_int;
#line 2358 "D:/a/test/164.c"
typedef unsigned int IPos;
#line 2373 "D:/a/test/164.c"
struct config {
   ush good_length ;
   ush max_lazy ;
   ush nice_length ;
   ush max_chain ;
};
#line 2373 "D:/a/test/164.c"
typedef struct config config;
#line 2694
enum __anonenum_ordering_22 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 4078 "D:/a/test/164.c"
union __anonunion_v_23 {
   ush n ;
   struct huft *t ;
};
#line 4078 "D:/a/test/164.c"
struct huft {
   uch e ;
   uch b ;
   union __anonunion_v_23 v ;
};
#line 4664 "D:/a/test/164.c"
struct spec_fd_t {
   int limit ;
   int len ;
   int pos ;
   unsigned char *buf ;
};
#line 4958 "D:/a/test/164.c"
union __anonunion_fc_24 {
   ush freq ;
   ush code ;
};
#line 4958 "D:/a/test/164.c"
union __anonunion_dl_25 {
   ush dad ;
   ush len ;
};
#line 4958 "D:/a/test/164.c"
struct ct_data {
   union __anonunion_fc_24 fc ;
   union __anonunion_dl_25 dl ;
};
#line 4958 "D:/a/test/164.c"
typedef struct ct_data ct_data;
#line 4978 "D:/a/test/164.c"
struct tree_desc {
   ct_data *dyn_tree ;
   ct_data *static_tree ;
   int *extra_bits ;
   int extra_base ;
   int elems ;
   int max_length ;
   int max_code ;
};
#line 4978 "D:/a/test/164.c"
typedef struct tree_desc tree_desc;
#line 810 "/usr/include/sys/reent.h"
extern struct _reent *( __attribute__((__cdecl__)) __getreent)(void) ;
#line 173 "/usr/include/stdio.h"
extern int ( __attribute__((__cdecl__)) fflush)(FILE * ) ;
#line 177
extern int ( __attribute__((__cdecl__)) fprintf)(FILE * , char const   *  , ...) ;
#line 179
extern int ( __attribute__((__cdecl__)) printf)(char const   *  , ...) ;
#line 186
extern char *( __attribute__((__cdecl__)) fgets)(char * , int  , FILE * ) ;
#line 192
extern int ( __attribute__((__cdecl__)) putc)(int  , FILE * ) ;
#line 214
extern void ( __attribute__((__cdecl__)) perror)(char const   * ) ;
#line 264
extern int ( __attribute__((__cdecl__)) fileno)(FILE * ) ;
#line 23 "/usr/include/string.h"
extern int ( __attribute__((__cdecl__)) memcmp)(void const   * , void const   * ,
                                                size_t  ) ;
#line 24
extern void *( __attribute__((__cdecl__)) memcpy)(void * , void const   * , size_t  ) ;
#line 26
extern void *( __attribute__((__cdecl__)) memset)(void * , int  , size_t  ) ;
#line 27
extern char *( __attribute__((__cdecl__)) strcat)(char * , char const   * ) ;
#line 29
extern int ( __attribute__((__cdecl__)) strcmp)(char const   * , char const   * ) ;
#line 31
extern char *( __attribute__((__cdecl__)) strcpy)(char * , char const   * ) ;
#line 32
extern size_t ( __attribute__((__cdecl__)) strcspn)(char const   * , char const   * ) ;
#line 33
extern char *( __attribute__((__cdecl__)) strerror)(int  ) ;
#line 34
extern size_t ( __attribute__((__cdecl__)) strlen)(char const   * ) ;
#line 36
extern int ( __attribute__((__cdecl__)) strncmp)(char const   * , char const   * ,
                                                 size_t  ) ;
#line 37
extern char *( __attribute__((__cdecl__)) strncpy)(char * , char const   * , size_t  ) ;
#line 39
extern char *( __attribute__((__cdecl__)) strrchr)(char const   * , int  ) ;
#line 40
extern size_t ( __attribute__((__cdecl__)) strspn)(char const   * , char const   * ) ;
#line 74
char *( __attribute__((__cdecl__)) strlwr)(char *s ) ;
#line 21 "/usr/include/signal.h"
extern _sig_func_ptr ( __attribute__((__cdecl__)) signal)(int  , void (*)(int  ) ) ;
#line 52 "/usr/include/time.h"
extern char *( __attribute__((__cdecl__)) ctime)(time_t const   *_time ) ;
#line 121 "/usr/include/sys/stat.h"
extern int ( __attribute__((__cdecl__)) fstat)(int __fd , struct stat *__sbuf ) ;
#line 124
extern int ( __attribute__((__cdecl__)) stat)(char const   *__path , struct stat *__sbuf ) ;
#line 128
extern int ( __attribute__((__cdecl__)) lstat)(char const   *__path , struct stat *__buf ) ;
#line 166 "/usr/include/sys/fcntl.h"
extern int open(char const   * , int   , ...) ;
#line 10 "D:/a/test/164.c"
int spec_read(int fd , unsigned char *buf , int size ) ;
#line 11
void flush_outbuf(void) ;
#line 12
void clear_bufs(void) ;
#line 13
extern int close(int  ) ;
#line 14
int fill_inbuf(int eof_ok ) ;
#line 16
void flush_window(void) ;
#line 17
int inflate(void) ;
#line 18
int spec_write(int fd , unsigned char *buf , int size ) ;
#line 19
void write_error(void) ;
#line 20
void read_error(void) ;
#line 21
char *gzipbasename(char *fname ) ;
#line 22
extern int isupper(int  ) ;
#line 23 "D:/a/test/164.c"
int errno  =    0;
#line 24 "D:/a/test/164.c"
char *optarg  =    (char *)0;
#line 25 "D:/a/test/164.c"
int optind  =    0;
#line 26 "D:/a/test/164.c"
static char *nextchar  ;
#line 27 "D:/a/test/164.c"
int opterr  =    1;
#line 29 "D:/a/test/164.c"
int optopt  =    '\000';
#line 309
int zip(int in , int out ) ;
#line 315
extern off_t lseek(int fd , off_t offset , int whence ) ;
#line 334
voidp xmalloc(unsigned int size ) ;
#line 356
extern ulg updcrc(ush s , unsigned int n ) ;
#line 404 "D:/a/test/164.c"
uch *inbuf  ;
#line 405 "D:/a/test/164.c"
uch *outbuf  ;
#line 406 "D:/a/test/164.c"
ush *d_buf  ;
#line 407 "D:/a/test/164.c"
uch *window  ;
#line 412 "D:/a/test/164.c"
ush *prev  ;
#line 419 "D:/a/test/164.c"
unsigned int insize  ;
#line 420 "D:/a/test/164.c"
unsigned int inptr  ;
#line 421 "D:/a/test/164.c"
unsigned int outcnt  ;
#line 423 "D:/a/test/164.c"
long bytes_in  ;
#line 424 "D:/a/test/164.c"
long bytes_out  ;
#line 425 "D:/a/test/164.c"
long header_bytes  ;
#line 428 "D:/a/test/164.c"
int ifd  ;
#line 429 "D:/a/test/164.c"
int ofd  ;
#line 430 "D:/a/test/164.c"
char ifname[1024]  ;
#line 431 "D:/a/test/164.c"
char ofname[1024]  ;
#line 432 "D:/a/test/164.c"
char *progname  ;
#line 434 "D:/a/test/164.c"
long time_stamp  ;
#line 435 "D:/a/test/164.c"
long ifile_size  ;
#line 461 "D:/a/test/164.c"
int decrypt  ;
#line 462
int exit_code ;
#line 463
int verbose ;
#line 464
int quiet ;
#line 465
int level ;
#line 466
int test ;
#line 467
int to_stdout ;
#line 468 "D:/a/test/164.c"
int save_orig_name  ;
#line 512
void abort_gzip(void) ;
#line 513
void lm_init(int pack_level , ush *flags ) ;
#line 514
ulg deflate(void) ;
#line 515
void ct_init(ush *attr , int *methodp ) ;
#line 516
int ct_tally(int dist , int lc ) ;
#line 517
ulg flush_block(char *buf , ulg stored_len , int eof ) ;
#line 518
void bi_init(file_t zipfile ) ;
#line 519
void send_bits(int value , int length ) ;
#line 520
unsigned int bi_reverse(unsigned int code , int len ) ;
#line 521
void bi_windup(void) ;
#line 522
void copy_block(char *buf , unsigned int len , int header ) ;
#line 540 "D:/a/test/164.c"
static ulg orig_len  ;
#line 541 "D:/a/test/164.c"
static int max_len  ;
#line 542 "D:/a/test/164.c"
static uch literal[256]  ;
#line 543 "D:/a/test/164.c"
static int lit_base[26]  ;
#line 544 "D:/a/test/164.c"
static int leaves[26]  ;
#line 545 "D:/a/test/164.c"
static int parents[26]  ;
#line 546 "D:/a/test/164.c"
static int peek_bits  ;
#line 550 "D:/a/test/164.c"
static ulg bitbuf  ;
#line 551 "D:/a/test/164.c"
static int valid  ;
#line 559
static void read_tree(void) ;
#line 560
static void build_tree1(void) ;
#line 570
void error(char *m ) ;
#line 561 "D:/a/test/164.c"
static void read_tree(void) 
{ int len ;
  int base ;
  int n ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 566
  orig_len = 0UL;
#line 567
  n = 1;
#line 567
  while (n <= 4) {
#line 567
    if (inptr < insize) {
#line 567
      tmp = inptr;
#line 567
      inptr ++;
#line 567
      tmp___1 = (int )*(inbuf + tmp);
    } else {
#line 567
      tmp___0 = fill_inbuf(0);
#line 567
      tmp___1 = tmp___0;
    }
#line 567
    orig_len = (orig_len << 8) | (unsigned long )tmp___1;
#line 567
    n ++;
  }
#line 568
  if (inptr < insize) {
#line 568
    tmp___2 = inptr;
#line 568
    inptr ++;
#line 568
    tmp___4 = (int )*(inbuf + tmp___2);
  } else {
#line 568
    tmp___3 = fill_inbuf(0);
#line 568
    tmp___4 = tmp___3;
  }
#line 568
  max_len = tmp___4;
#line 569
  if (max_len > 25) {
#line 570
    error("invalid compressed data -- Huffman code > 32 bits");
  }
#line 572
  n = 0;
#line 573
  len = 1;
#line 573
  while (len <= max_len) {
#line 574
    if (inptr < insize) {
#line 574
      tmp___5 = inptr;
#line 574
      inptr ++;
#line 574
      tmp___7 = (int )*(inbuf + tmp___5);
    } else {
#line 574
      tmp___6 = fill_inbuf(0);
#line 574
      tmp___7 = tmp___6;
    }
#line 574
    leaves[len] = tmp___7;
#line 575
    n += leaves[len];
#line 573
    len ++;
  }
#line 577
  if (n > 256) {
#line 578
    error("too many leaves in Huffman tree");
  }
#line 582
  (leaves[max_len]) ++;
#line 583
  base = 0;
#line 584
  len = 1;
#line 584
  while (len <= max_len) {
#line 586
    lit_base[len] = base;
#line 588
    n = leaves[len];
#line 588
    while (n > 0) {
#line 589
      tmp___8 = base;
#line 589
      base ++;
#line 589
      if (inptr < insize) {
#line 589
        tmp___9 = inptr;
#line 589
        inptr ++;
#line 589
        tmp___11 = (int )*(inbuf + tmp___9);
      } else {
#line 589
        tmp___10 = fill_inbuf(0);
#line 589
        tmp___11 = tmp___10;
      }
#line 589
      literal[tmp___8] = (unsigned char )tmp___11;
#line 588
      n --;
    }
#line 584
    len ++;
  }
#line 592
  (leaves[max_len]) ++;
#line 593
  return;
}
}
#line 594 "D:/a/test/164.c"
static void build_tree1(void) 
{ int nodes ;
  int len ;
  uch *prefixp ;
  int prefixes ;
  int tmp ;

  {
#line 596
  nodes = 0;
#line 599
  len = max_len;
#line 599
  while (len >= 1) {
#line 601
    nodes >>= 1;
#line 602
    parents[len] = nodes;
#line 604
    lit_base[len] -= nodes;
#line 606
    nodes += leaves[len];
#line 599
    len --;
  }
#line 608
  if (max_len <= 12) {
#line 608
    peek_bits = max_len;
  } else {
#line 608
    peek_bits = 12;
  }
#line 609
  prefixp = outbuf + (1 << peek_bits);
#line 610
  len = 1;
#line 610
  while (len <= peek_bits) {
#line 611
    prefixes = leaves[len] << (peek_bits - len);
#line 612
    while (1) {
#line 612
      tmp = prefixes;
#line 612
      prefixes --;
#line 612
      if (! tmp) {
#line 612
        break;
      }
#line 612
      prefixp --;
#line 612
      *prefixp = (unsigned char )len;
    }
#line 610
    len ++;
  }
#line 614
  while ((unsigned int )prefixp > (unsigned int )outbuf) {
#line 614
    prefixp --;
#line 614
    *prefixp = (unsigned char)0;
  }
#line 615
  return;
}
}
#line 616 "D:/a/test/164.c"
int unpack(int in , int out ) 
{ int len ;
  unsigned int eob ;
  register unsigned int peek ;
  unsigned int peek_mask ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ulg mask ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 623
  ifd = in;
#line 624
  ofd = out;
#line 625
  read_tree();
#line 626
  build_tree1();
#line 627
  valid = 0;
#line 627
  bitbuf = 0UL;
#line 628
  peek_mask = (unsigned int )((1 << peek_bits) - 1);
#line 629
  eob = (unsigned int )(leaves[max_len] - 1);
#line 631
  while (1) {
#line 633
    while (valid < peek_bits) {
#line 633
      if (inptr < insize) {
#line 633
        tmp = inptr;
#line 633
        inptr ++;
#line 633
        tmp___1 = (int )*(inbuf + tmp);
      } else {
#line 633
        tmp___0 = fill_inbuf(0);
#line 633
        tmp___1 = tmp___0;
      }
#line 633
      bitbuf = (bitbuf << 8) | (unsigned long )tmp___1;
#line 633
      valid += 8;
    }
#line 633
    peek = (unsigned int )((bitbuf >> (valid - peek_bits)) & (unsigned long )peek_mask);
#line 634
    len = (int )*(outbuf + peek);
#line 635
    if (len > 0) {
#line 636
      peek >>= peek_bits - len;
    } else {
#line 639
      mask = (ulg )peek_mask;
#line 640
      len = peek_bits;
#line 641
      while (1) {
#line 642
        len ++;
#line 642
        mask = (mask << 1) + 1UL;
#line 643
        while (valid < len) {
#line 643
          if (inptr < insize) {
#line 643
            tmp___2 = inptr;
#line 643
            inptr ++;
#line 643
            tmp___4 = (int )*(inbuf + tmp___2);
          } else {
#line 643
            tmp___3 = fill_inbuf(0);
#line 643
            tmp___4 = tmp___3;
          }
#line 643
          bitbuf = (bitbuf << 8) | (unsigned long )tmp___4;
#line 643
          valid += 8;
        }
#line 643
        peek = (unsigned int )((bitbuf >> (valid - len)) & mask);
#line 641
        if (! (peek < (unsigned int )parents[len])) {
#line 641
          break;
        }
      }
    }
#line 648
    if (peek == eob) {
#line 648
      if (len == max_len) {
#line 648
        break;
      }
    }
#line 649
    tmp___5 = outcnt;
#line 649
    outcnt ++;
#line 649
    *(window + tmp___5) = literal[peek + (unsigned int )lit_base[len]];
#line 649
    if (outcnt == 32768U) {
#line 649
      flush_window();
    }
#line 652
    valid -= len;
  }
#line 654
  flush_window();
#line 656
  if (orig_len != (unsigned long )bytes_out) {
#line 657
    error("invalid compressed data--length error");
  }
#line 659
  return (0);
}
}
#line 696 "D:/a/test/164.c"
static char *license_msg[15]  = 
#line 696
  {      (char *)"   Copyright (C) 1992-1993 Jean-loup Gailly",      (char *)"   This program is free software; you can redistribute it and/or modify",      (char *)"   it under the terms of the GNU General Public License as published by",      (char *)"   the Free Software Foundation; either version 2, or (at your option)", 
        (char *)"   any later version.",      (char *)"",      (char *)"   This program is distributed in the hope that it will be useful,",      (char *)"   but WITHOUT ANY WARRANTY; without even the implied warranty of", 
        (char *)"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",      (char *)"   GNU General Public License for more details.",      (char *)"",      (char *)"   You should have received a copy of the GNU General Public License", 
        (char *)"   along with this program; if not, write to the Free Software",      (char *)"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",      (char *)0};
#line 68 "/usr/include/stdlib.h"
extern int ( __attribute__((__cdecl__)) atoi)(char const   *__nptr ) ;
#line 77
extern void *( __attribute__((__cdecl__)) calloc)(size_t __nmemb , size_t __size ) ;
#line 79
extern  __attribute__((__noreturn__)) void ( __attribute__((__cdecl__)) exit)(int __status ) ;
#line 80
extern void ( __attribute__((__cdecl__)) free)(void * ) ;
#line 81
extern char *( __attribute__((__cdecl__)) getenv)(char const   *__string ) ;
#line 87
extern void *( __attribute__((__cdecl__)) malloc)(size_t __size ) ;
#line 838 "D:/a/test/164.c"
int ascii  =    0;
#line 839 "D:/a/test/164.c"
int to_stdout  =    0;
#line 840 "D:/a/test/164.c"
int decompress  =    0;
#line 841 "D:/a/test/164.c"
int force  =    0;
#line 842 "D:/a/test/164.c"
int no_name  =    -1;
#line 843 "D:/a/test/164.c"
int no_time  =    -1;
#line 844 "D:/a/test/164.c"
int recursive  =    0;
#line 845 "D:/a/test/164.c"
int list  =    0;
#line 846 "D:/a/test/164.c"
int verbose  =    0;
#line 847 "D:/a/test/164.c"
int quiet  =    0;
#line 848 "D:/a/test/164.c"
int do_lzw  =    0;
#line 849 "D:/a/test/164.c"
int test  =    0;
#line 850 "D:/a/test/164.c"
int foreground  ;
#line 852 "D:/a/test/164.c"
int maxbits  =    16;
#line 853 "D:/a/test/164.c"
int method  =    8;
#line 854 "D:/a/test/164.c"
int level  =    6;
#line 855 "D:/a/test/164.c"
int exit_code  =    0;
#line 857 "D:/a/test/164.c"
int last_member  ;
#line 858 "D:/a/test/164.c"
int part_nb  ;
#line 861 "D:/a/test/164.c"
char *env  ;
#line 862 "D:/a/test/164.c"
char **args  =    (char **)((void *)0);
#line 863 "D:/a/test/164.c"
char z_suffix[31]  ;
#line 864 "D:/a/test/164.c"
int z_len  ;
#line 867 "D:/a/test/164.c"
long total_in  =    0L;
#line 868 "D:/a/test/164.c"
long total_out  =    0L;
#line 871 "D:/a/test/164.c"
int remove_ofname  =    0;
#line 872 "D:/a/test/164.c"
struct stat istat  ;
#line 878 "D:/a/test/164.c"
struct option longopts[24]  = 
#line 878
  {      {"ascii", 0, (int *)0, 'a'}, 
        {"to-stdout", 0, (int *)0, 'c'}, 
        {"stdout", 0, (int *)0, 'c'}, 
        {"decompress", 0, (int *)0, 'd'}, 
        {"uncompress", 0, (int *)0, 'd'}, 
        {"force", 0, (int *)0, 'f'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"list", 0, (int *)0, 'l'}, 
        {"license", 0, (int *)0, 'L'}, 
        {"no-name", 0, (int *)0, 'n'}, 
        {"name", 0, (int *)0, 'N'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"silent", 0, (int *)0, 'q'}, 
        {"recursive", 0, (int *)0, 'r'}, 
        {"suffix", 1, (int *)0, 'S'}, 
        {"test", 0, (int *)0, 't'}, 
        {"no-time", 0, (int *)0, 'T'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"fast", 0, (int *)0, '1'}, 
        {"best", 0, (int *)0, '9'}, 
        {"lzw", 0, (int *)0, 'Z'}, 
        {"bits", 1, (int *)0, 'b'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 905
static void usage(void) ;
#line 906
static void help(void) ;
#line 907
static void license(void) ;
#line 908
static void version(void) ;
#line 909
static void treat_stdin(void) ;
#line 910
static void treat_file(char *iname ) ;
#line 911
static int create_outfile(void) ;
#line 912
static int do_stat(char *name , struct stat *sbuf ) ;
#line 913
static char *get_suffix(char *name ) ;
#line 914
static int get_istat(char *iname , struct stat *sbuf ) ;
#line 915
static int make_ofname(void) ;
#line 916
static int same_file(struct stat *stat1 , struct stat *stat2 ) ;
#line 917
static int name_too_long(char *name , struct stat *statb ) ;
#line 918
static void shorten_name(char *name ) ;
#line 919
int get_method(int in ) ;
#line 920
static void do_list(int ifd___0 , int method___0 ) ;
#line 921
static int check_ofname(void) ;
#line 922
static void copy_stat(struct stat *ifstat ) ;
#line 923
static void do_exit(int exitcode ) ;
#line 924
int main(int argc , char **argv ) ;
#line 925 "D:/a/test/164.c"
int (*work)(int infile , int outfile )  =    & zip;
#line 933 "D:/a/test/164.c"
static void usage(void) 
{ struct _reent *tmp ;

  {
#line 935
  tmp = __getreent();
#line 935
  fprintf(tmp->_stderr, "usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n",
          progname, "a", "");
#line 948
  return;
}
}
#line 951
static void help(void) ;
#line 951 "D:/a/test/164.c"
static char *help_msg[17]  = 
#line 951
  {      (char *)" -c --stdout      write on standard output, keep original files unchanged",      (char *)" -d --decompress  decompress",      (char *)" -f --force       force overwrite of output file and compress links",      (char *)" -h --help        give this help", 
        (char *)" -l --list        list compressed file contents",      (char *)" -L --license     display software license",      (char *)" -n --no-name     do not save or restore the original name and time stamp",      (char *)" -N --name        save or restore the original name and time stamp", 
        (char *)" -q --quiet       suppress all warnings",      (char *)" -S .suf  --suffix .suf     use suffix .suf on compressed files",      (char *)" -t --test        test compressed file integrity",      (char *)" -v --verbose     verbose mode", 
        (char *)" -V --version     display version number",      (char *)" -1 --fast        compress faster",      (char *)" -9 --best        compress better",      (char *)" file...          files to (de)compress. If none given, use standard input.", 
        (char *)0};
#line 949 "D:/a/test/164.c"
static void help(void) 
{ char **p ;
  char **tmp ;
  struct _reent *tmp___0 ;

  {
#line 982
  p = help_msg;
#line 984
  usage();
#line 985
  while (*p) {
#line 985
    tmp = p;
#line 985
    p ++;
#line 985
    tmp___0 = __getreent();
#line 985
    fprintf(tmp___0->_stderr, "%s\n", *tmp);
  }
#line 986
  return;
}
}
#line 987 "D:/a/test/164.c"
static void license(void) 
{ char **p ;
  char **tmp ;
  struct _reent *tmp___0 ;

  {
#line 989
  p = license_msg;
#line 991
  while (*p) {
#line 991
    tmp = p;
#line 991
    p ++;
#line 991
    tmp___0 = __getreent();
#line 991
    fprintf(tmp___0->_stderr, "%s\n", *tmp);
  }
#line 992
  return;
}
}
#line 993 "D:/a/test/164.c"
static void version(void) 
{ struct _reent *tmp ;
  struct _reent *tmp___0 ;
  struct _reent *tmp___1 ;
  struct _reent *tmp___2 ;
  struct _reent *tmp___3 ;

  {
#line 996
  tmp = __getreent();
#line 996
  fprintf(tmp->_stderr, "Compilation options:\n%s %s ", "NO_DIR", "NO_UTIME");
#line 1016
  tmp___0 = __getreent();
#line 1016
  fprintf(tmp___0->_stderr, "NO_CHOWN ");
#line 1019
  tmp___1 = __getreent();
#line 1019
  fprintf(tmp___1->_stderr, "PROTO ");
#line 1028
  tmp___2 = __getreent();
#line 1028
  fprintf(tmp___2->_stderr, "DYN_ALLOC ");
#line 1033
  tmp___3 = __getreent();
#line 1033
  fprintf(tmp___3->_stderr, "\n");
#line 1034
  return;
}
}
#line 1054 "D:/a/test/164.c"
char *key  ;
#line 1055 "D:/a/test/164.c"
int pkzip  =    0;
#line 1056 "D:/a/test/164.c"
int ext_header  =    0;
#line 1057 "D:/a/test/164.c"
int check_zipfile(int in ) 
{ uch *h ;
  struct _reent *tmp ;
  struct _reent *tmp___0 ;
  struct _reent *tmp___1 ;

  {
#line 1060
  h = inbuf + inptr;
#line 1061
  ifd = in;
#line 1062
  inptr += (unsigned int )((30 + ((int )((unsigned short )*((h + 26) + 0)) | ((int )((unsigned short )*((h + 26) + 1)) << 8))) + ((int )((unsigned short )*((h + 28) + 0)) | ((int )((unsigned short )*((h + 28) + 1)) << 8)));
#line 1063
  if (inptr > insize) {
#line 1064
    tmp = __getreent();
#line 1064
    fprintf(tmp->_stderr, "\n%s: %s: not a valid zip file\n", progname, ifname);
#line 1066
    exit_code = 1;
#line 1067
    return (1);
  } else {
#line 1063
    if (((unsigned long )((int )((unsigned short )*(h + 0)) | ((int )((unsigned short )*(h + 1)) << 8)) | ((unsigned long )((int )((unsigned short )*((h + 2) + 0)) | ((int )((unsigned short )*((h + 2) + 1)) << 8)) << 16)) != 67324752UL) {
#line 1064
      tmp = __getreent();
#line 1064
      fprintf(tmp->_stderr, "\n%s: %s: not a valid zip file\n", progname, ifname);
#line 1066
      exit_code = 1;
#line 1067
      return (1);
    }
  }
#line 1069
  method = (int )*(h + 8);
#line 1070
  if (method != 0) {
#line 1070
    if (method != 8) {
#line 1071
      tmp___0 = __getreent();
#line 1071
      fprintf(tmp___0->_stderr, "\n%s: %s: first entry not deflated or stored -- use unzip\n",
              progname, ifname);
#line 1074
      exit_code = 1;
#line 1075
      return (1);
    }
  }
#line 1077
  decrypt = (int )*(h + 6) & 1;
#line 1077
  if (decrypt != 0) {
#line 1078
    tmp___1 = __getreent();
#line 1078
    fprintf(tmp___1->_stderr, "\n%s: %s: encrypted file -- use unzip\n", progname,
            ifname);
#line 1080
    exit_code = 1;
#line 1081
    return (1);
  }
#line 1083
  ext_header = ((int )*(h + 6) & 8) != 0;
#line 1084
  pkzip = 1;
#line 1085
  return (0);
}
}
#line 1087 "D:/a/test/164.c"
int unzip(int in , int out ) 
{ ulg orig_crc ;
  ulg orig_len___0 ;
  int n ;
  uch buf[16] ;
  int res ;
  int tmp ;
  register ulg n___0 ;
  struct _reent *tmp___0 ;
  int tmp___1 ;
  uch c ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  ulg tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  ulg tmp___13 ;
  struct _reent *tmp___14 ;
  struct _reent *tmp___15 ;

  {
#line 1090
  orig_crc = (ulg )0;
#line 1091
  orig_len___0 = (ulg )0;
#line 1094
  ifd = in;
#line 1095
  ofd = out;
#line 1096
  updcrc((unsigned short )((void *)0), 0U);
#line 1097
  if (pkzip) {
#line 1097
    if (! ext_header) {
#line 1098
      orig_crc = (unsigned long )((int )((unsigned short )*((inbuf + 14) + 0)) | ((int )((unsigned short )*((inbuf + 14) + 1)) << 8)) | ((unsigned long )((int )((unsigned short )*(((inbuf + 14) + 2) + 0)) | ((int )((unsigned short )*(((inbuf + 14) + 2) + 1)) << 8)) << 16);
#line 1099
      orig_len___0 = (unsigned long )((int )((unsigned short )*((inbuf + 22) + 0)) | ((int )((unsigned short )*((inbuf + 22) + 1)) << 8)) | ((unsigned long )((int )((unsigned short )*(((inbuf + 22) + 2) + 0)) | ((int )((unsigned short )*(((inbuf + 22) + 2) + 1)) << 8)) << 16);
    }
  }
#line 1101
  if (method == 8) {
#line 1102
    tmp = inflate();
#line 1102
    res = tmp;
#line 1103
    if (res == 3) {
#line 1104
      error("out of memory");
    } else {
#line 1105
      if (res != 0) {
#line 1106
        error("invalid compressed data--format violated");
      }
    }
  } else {
#line 1108
    if (pkzip) {
#line 1108
      if (method == 0) {
#line 1109
        n___0 = (unsigned long )((int )((unsigned short )*((inbuf + 22) + 0)) | ((int )((unsigned short )*((inbuf + 22) + 1)) << 8)) | ((unsigned long )((int )((unsigned short )*(((inbuf + 22) + 2) + 0)) | ((int )((unsigned short )*(((inbuf + 22) + 2) + 1)) << 8)) << 16);
#line 1110
        if (decrypt) {
#line 1110
          tmp___1 = 12;
        } else {
#line 1110
          tmp___1 = 0;
        }
#line 1110
        if (n___0 != ((unsigned long )((int )((unsigned short )*((inbuf + 18) + 0)) | ((int )((unsigned short )*((inbuf + 18) + 1)) << 8)) | ((unsigned long )((int )((unsigned short )*(((inbuf + 18) + 2) + 0)) | ((int )((unsigned short )*(((inbuf + 18) + 2) + 1)) << 8)) << 16)) - (unsigned long )tmp___1) {
#line 1111
          tmp___0 = __getreent();
#line 1111
          fprintf(tmp___0->_stderr, "len %ld, siz %ld\n", n___0, (unsigned long )((int )((unsigned short )*((inbuf + 18) + 0)) | ((int )((unsigned short )*((inbuf + 18) + 1)) << 8)) | ((unsigned long )((int )((unsigned short )*(((inbuf + 18) + 2) + 0)) | ((int )((unsigned short )*(((inbuf + 18) + 2) + 1)) << 8)) << 16));
#line 1112
          error("invalid compressed data--length mismatch");
        }
#line 1114
        while (1) {
#line 1114
          tmp___6 = n___0;
#line 1114
          n___0 --;
#line 1114
          if (! tmp___6) {
#line 1114
            break;
          }
#line 1115
          if (inptr < insize) {
#line 1115
            tmp___2 = inptr;
#line 1115
            inptr ++;
#line 1115
            tmp___4 = (int )*(inbuf + tmp___2);
          } else {
#line 1115
            tmp___3 = fill_inbuf(0);
#line 1115
            tmp___4 = tmp___3;
          }
#line 1115
          c = (unsigned char )tmp___4;
#line 1119
          tmp___5 = outcnt;
#line 1119
          outcnt ++;
#line 1119
          *(window + tmp___5) = c;
#line 1119
          if (outcnt == 32768U) {
#line 1119
            flush_window();
          }
        }
#line 1121
        flush_window();
      } else {
#line 1123
        error("internal error, invalid method");
      }
    } else {
#line 1123
      error("internal error, invalid method");
    }
  }
#line 1125
  if (! pkzip) {
#line 1126
    n = 0;
#line 1126
    while (n < 8) {
#line 1127
      if (inptr < insize) {
#line 1127
        tmp___7 = inptr;
#line 1127
        inptr ++;
#line 1127
        tmp___9 = (int )*(inbuf + tmp___7);
      } else {
#line 1127
        tmp___8 = fill_inbuf(0);
#line 1127
        tmp___9 = tmp___8;
      }
#line 1127
      buf[n] = (unsigned char )tmp___9;
#line 1126
      n ++;
    }
#line 1129
    orig_crc = (unsigned long )((int )((unsigned short )buf[0]) | ((int )((unsigned short )buf[1]) << 8)) | ((unsigned long )((int )((unsigned short )*((buf + 2) + 0)) | ((int )((unsigned short )*((buf + 2) + 1)) << 8)) << 16);
#line 1130
    orig_len___0 = (unsigned long )((int )((unsigned short )*((buf + 4) + 0)) | ((int )((unsigned short )*((buf + 4) + 1)) << 8)) | ((unsigned long )((int )((unsigned short )*(((buf + 4) + 2) + 0)) | ((int )((unsigned short )*(((buf + 4) + 2) + 1)) << 8)) << 16);
  } else {
#line 1131
    if (ext_header) {
#line 1133
      n = 0;
#line 1133
      while (n < 16) {
#line 1134
        if (inptr < insize) {
#line 1134
          tmp___10 = inptr;
#line 1134
          inptr ++;
#line 1134
          tmp___12 = (int )*(inbuf + tmp___10);
        } else {
#line 1134
          tmp___11 = fill_inbuf(0);
#line 1134
          tmp___12 = tmp___11;
        }
#line 1134
        buf[n] = (unsigned char )tmp___12;
#line 1133
        n ++;
      }
#line 1136
      orig_crc = (unsigned long )((int )((unsigned short )*((buf + 4) + 0)) | ((int )((unsigned short )*((buf + 4) + 1)) << 8)) | ((unsigned long )((int )((unsigned short )*(((buf + 4) + 2) + 0)) | ((int )((unsigned short )*(((buf + 4) + 2) + 1)) << 8)) << 16);
#line 1137
      orig_len___0 = (unsigned long )((int )((unsigned short )*((buf + 12) + 0)) | ((int )((unsigned short )*((buf + 12) + 1)) << 8)) | ((unsigned long )((int )((unsigned short )*(((buf + 12) + 2) + 0)) | ((int )((unsigned short )*(((buf + 12) + 2) + 1)) << 8)) << 16);
    }
  }
#line 1139
  tmp___13 = updcrc((unsigned short )outbuf, 0U);
#line 1139
  if (orig_crc != tmp___13) {
#line 1140
    error("invalid compressed data--crc error");
  }
#line 1142
  if (orig_len___0 != (unsigned long )bytes_out) {
#line 1143
    error("invalid compressed data--length error");
  }
#line 1145
  if (pkzip) {
#line 1145
    if (inptr + 4U < insize) {
#line 1145
      if (((unsigned long )((int )((unsigned short )*((inbuf + inptr) + 0)) | ((int )((unsigned short )*((inbuf + inptr) + 1)) << 8)) | ((unsigned long )((int )((unsigned short )*(((inbuf + inptr) + 2) + 0)) | ((int )((unsigned short )*(((inbuf + inptr) + 2) + 1)) << 8)) << 16)) == 67324752UL) {
#line 1146
        if (to_stdout) {
#line 1147
          if (! quiet) {
#line 1147
            tmp___14 = __getreent();
#line 1147
            fprintf(tmp___14->_stderr, "%s: %s has more than one entry--rest ignored\n",
                    progname, ifname);
          }
#line 1147
          if (exit_code == 0) {
#line 1147
            exit_code = 2;
          }
        } else {
#line 1152
          tmp___15 = __getreent();
#line 1152
          fprintf(tmp___15->_stderr, "%s: %s has more than one entry -- unchanged\n",
                  progname, ifname);
#line 1155
          exit_code = 1;
#line 1156
          pkzip = 0;
#line 1156
          ext_header = pkzip;
#line 1157
          return (1);
        }
      }
    }
  }
#line 1160
  pkzip = 0;
#line 1160
  ext_header = pkzip;
#line 1161
  return (0);
}
}
#line 1174 "D:/a/test/164.c"
static ulg crc  ;
#line 1176 "D:/a/test/164.c"
ulg crc_32_tab[256]  = 
#line 1176
  {      (ulg )0L,      (ulg )1996959894L,      3993919788UL,      2567524794UL, 
        (ulg )124634137L,      (ulg )1886057615L,      3915621685UL,      2657392035UL, 
        (ulg )249268274L,      (ulg )2044508324L,      3772115230UL,      2547177864UL, 
        (ulg )162941995L,      (ulg )2125561021L,      3887607047UL,      2428444049UL, 
        (ulg )498536548L,      (ulg )1789927666L,      4089016648UL,      2227061214UL, 
        (ulg )450548861L,      (ulg )1843258603L,      4107580753UL,      2211677639UL, 
        (ulg )325883990L,      (ulg )1684777152L,      4251122042UL,      2321926636UL, 
        (ulg )335633487L,      (ulg )1661365465L,      4195302755UL,      2366115317UL, 
        (ulg )997073096L,      (ulg )1281953886L,      3579855332UL,      2724688242UL, 
        (ulg )1006888145L,      (ulg )1258607687L,      3524101629UL,      2768942443UL, 
        (ulg )901097722L,      (ulg )1119000684L,      3686517206UL,      2898065728UL, 
        (ulg )853044451L,      (ulg )1172266101L,      3705015759UL,      2882616665UL, 
        (ulg )651767980L,      (ulg )1373503546L,      3369554304UL,      3218104598UL, 
        (ulg )565507253L,      (ulg )1454621731L,      3485111705UL,      3099436303UL, 
        (ulg )671266974L,      (ulg )1594198024L,      3322730930UL,      2970347812UL, 
        (ulg )795835527L,      (ulg )1483230225L,      3244367275UL,      3060149565UL, 
        (ulg )1994146192L,      (ulg )31158534L,      2563907772UL,      4023717930UL, 
        (ulg )1907459465L,      (ulg )112637215L,      2680153253UL,      3904427059UL, 
        (ulg )2013776290L,      (ulg )251722036L,      2517215374UL,      3775830040UL, 
        (ulg )2137656763L,      (ulg )141376813L,      2439277719UL,      3865271297UL, 
        (ulg )1802195444L,      (ulg )476864866L,      2238001368UL,      4066508878UL, 
        (ulg )1812370925L,      (ulg )453092731L,      2181625025UL,      4111451223UL, 
        (ulg )1706088902L,      (ulg )314042704L,      2344532202UL,      4240017532UL, 
        (ulg )1658658271L,      (ulg )366619977L,      2362670323UL,      4224994405UL, 
        (ulg )1303535960L,      (ulg )984961486L,      2747007092UL,      3569037538UL, 
        (ulg )1256170817L,      (ulg )1037604311L,      2765210733UL,      3554079995UL, 
        (ulg )1131014506L,      (ulg )879679996L,      2909243462UL,      3663771856UL, 
        (ulg )1141124467L,      (ulg )855842277L,      2852801631UL,      3708648649UL, 
        (ulg )1342533948L,      (ulg )654459306L,      3188396048UL,      3373015174UL, 
        (ulg )1466479909L,      (ulg )544179635L,      3110523913UL,      3462522015UL, 
        (ulg )1591671054L,      (ulg )702138776L,      2966460450UL,      3352799412UL, 
        (ulg )1504918807L,      (ulg )783551873L,      3082640443UL,      3233442989UL, 
        3988292384UL,      2596254646UL,      (ulg )62317068L,      (ulg )1957810842L, 
        3939845945UL,      2647816111UL,      (ulg )81470997L,      (ulg )1943803523L, 
        3814918930UL,      2489596804UL,      (ulg )225274430L,      (ulg )2053790376L, 
        3826175755UL,      2466906013UL,      (ulg )167816743L,      (ulg )2097651377L, 
        4027552580UL,      2265490386UL,      (ulg )503444072L,      (ulg )1762050814L, 
        4150417245UL,      2154129355UL,      (ulg )426522225L,      (ulg )1852507879L, 
        4275313526UL,      2312317920UL,      (ulg )282753626L,      (ulg )1742555852L, 
        4189708143UL,      2394877945UL,      (ulg )397917763L,      (ulg )1622183637L, 
        3604390888UL,      2714866558UL,      (ulg )953729732L,      (ulg )1340076626L, 
        3518719985UL,      2797360999UL,      (ulg )1068828381L,      (ulg )1219638859L, 
        3624741850UL,      2936675148UL,      (ulg )906185462L,      (ulg )1090812512L, 
        3747672003UL,      2825379669UL,      (ulg )829329135L,      (ulg )1181335161L, 
        3412177804UL,      3160834842UL,      (ulg )628085408L,      (ulg )1382605366L, 
        3423369109UL,      3138078467UL,      (ulg )570562233L,      (ulg )1426400815L, 
        3317316542UL,      2998733608UL,      (ulg )733239954L,      (ulg )1555261956L, 
        3268935591UL,      3050360625UL,      (ulg )752459403L,      (ulg )1541320221L, 
        2607071920UL,      3965973030UL,      (ulg )1969922972L,      (ulg )40735498L, 
        2617837225UL,      3943577151UL,      (ulg )1913087877L,      (ulg )83908371L, 
        2512341634UL,      3803740692UL,      (ulg )2075208622L,      (ulg )213261112L, 
        2463272603UL,      3855990285UL,      (ulg )2094854071L,      (ulg )198958881L, 
        2262029012UL,      4057260610UL,      (ulg )1759359992L,      (ulg )534414190L, 
        2176718541UL,      4139329115UL,      (ulg )1873836001L,      (ulg )414664567L, 
        2282248934UL,      4279200368UL,      (ulg )1711684554L,      (ulg )285281116L, 
        2405801727UL,      4167216745UL,      (ulg )1634467795L,      (ulg )376229701L, 
        2685067896UL,      3608007406UL,      (ulg )1308918612L,      (ulg )956543938L, 
        2808555105UL,      3495958263UL,      (ulg )1231636301L,      (ulg )1047427035L, 
        2932959818UL,      3654703836UL,      (ulg )1088359270L,      (ulg )936918000L, 
        2847714899UL,      3736837829UL,      (ulg )1202900863L,      (ulg )817233897L, 
        3183342108UL,      3401237130UL,      (ulg )1404277552L,      (ulg )615818150L, 
        3134207493UL,      3453421203UL,      (ulg )1423857449L,      (ulg )601450431L, 
        3009837614UL,      3294710456UL,      (ulg )1567103746L,      (ulg )711928724L, 
        3020668471UL,      3272380065UL,      (ulg )1510334235L,      (ulg )755167117L};
#line 1247 "D:/a/test/164.c"
void write_buf(int fd , voidp buf , unsigned int cnt ) 
{ unsigned int n ;
  int tmp ;

  {
#line 1253
  while (1) {
#line 1253
    tmp = spec_write(fd, (unsigned char *)buf, (int )cnt);
#line 1253
    n = (unsigned int )tmp;
#line 1253
    if (! (n != cnt)) {
#line 1253
      break;
    }
#line 1254
    if (n == 4294967295U) {
#line 1255
      write_error();
    }
#line 1257
    cnt -= n;
#line 1258
    buf = (void *)((char *)buf + n);
  }
#line 1260
  return;
}
}
#line 1261 "D:/a/test/164.c"
int copy(int in , int out ) 
{ int tmp ;

  {
#line 1264
  errno = 0;
#line 1265
  while (1) {
#line 1265
    if (insize != 0U) {
#line 1265
      if (! ((int )insize != -1)) {
#line 1265
        break;
      }
    } else {
#line 1265
      break;
    }
#line 1266
    write_buf(out, (void *)((char *)inbuf), insize);
#line 1267
    bytes_out = (long )((unsigned long )bytes_out + (unsigned long )insize);
#line 1268
    tmp = spec_read(in, (unsigned char *)((char *)inbuf), 32768);
#line 1268
    insize = (unsigned int )tmp;
  }
#line 1270
  if ((int )insize == -1) {
#line 1270
    if (errno != 0) {
#line 1271
      read_error();
    }
  }
#line 1273
  bytes_in = bytes_out;
#line 1274
  return (0);
}
}
#line 1277 "D:/a/test/164.c"
void clear_bufs(void) 
{ 

  {
#line 1279
  outcnt = 0U;
#line 1280
  inptr = 0U;
#line 1280
  insize = inptr;
#line 1281
  bytes_out = 0L;
#line 1281
  bytes_in = bytes_out;
#line 1282
  return;
}
}
#line 1283 "D:/a/test/164.c"
int fill_inbuf(int eof_ok ) 
{ int len ;

  {
#line 1287
  insize = 0U;
#line 1288
  errno = 0;
#line 1289
  while (1) {
#line 1290
    len = spec_read(ifd, (unsigned char *)((char *)inbuf + insize), (int )(32768U - insize));
#line 1291
    if (len == 0) {
#line 1291
      break;
    } else {
#line 1291
      if (len == -1) {
#line 1291
        break;
      }
    }
#line 1292
    insize += (unsigned int )len;
#line 1289
    if (! (insize < 32768U)) {
#line 1289
      break;
    }
  }
#line 1294
  if (insize == 0U) {
#line 1295
    if (eof_ok) {
#line 1295
      return (-1);
    }
#line 1296
    read_error();
  }
#line 1298
  bytes_in = (long )((unsigned long )bytes_in + (unsigned long )insize);
#line 1299
  inptr = 1U;
#line 1300
  return ((int )*(inbuf + 0));
}
}
#line 1302 "D:/a/test/164.c"
void flush_outbuf(void) 
{ 

  {
#line 1304
  if (outcnt == 0U) {
#line 1304
    return;
  }
#line 1305
  write_buf(ofd, (void *)((char *)outbuf), outcnt);
#line 1306
  bytes_out = (long )((unsigned long )bytes_out + (unsigned long )outcnt);
#line 1307
  outcnt = 0U;
#line 1308
  return;
}
}
#line 1309 "D:/a/test/164.c"
int zip(int in , int out ) 
{ uch flags ;
  ush attr ;
  ush deflate_flags ;
  int method___0 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  char *p ;
  char *tmp___13 ;
  unsigned int tmp___14 ;
  char *tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;

  {
#line 1312
  flags = (uch )0;
#line 1313
  attr = (ush )0;
#line 1314
  deflate_flags = (ush )0;
#line 1315
  ifd = in;
#line 1316
  ofd = out;
#line 1317
  outcnt = 0U;
#line 1318
  method___0 = 8;
#line 1319
  tmp = outcnt;
#line 1319
  outcnt ++;
#line 1319
  *(outbuf + tmp) = (unsigned char )*("\037\213" + 0);
#line 1319
  if (outcnt == 16384U) {
#line 1319
    flush_outbuf();
  }
#line 1320
  tmp___0 = outcnt;
#line 1320
  outcnt ++;
#line 1320
  *(outbuf + tmp___0) = (unsigned char )*("\037\213" + 1);
#line 1320
  if (outcnt == 16384U) {
#line 1320
    flush_outbuf();
  }
#line 1321
  tmp___1 = outcnt;
#line 1321
  outcnt ++;
#line 1321
  *(outbuf + tmp___1) = (unsigned char)8;
#line 1321
  if (outcnt == 16384U) {
#line 1321
    flush_outbuf();
  }
#line 1322
  if (save_orig_name) {
#line 1323
    flags = (unsigned char )((int )flags | 8);
  }
#line 1325
  tmp___2 = outcnt;
#line 1325
  outcnt ++;
#line 1325
  *(outbuf + tmp___2) = flags;
#line 1325
  if (outcnt == 16384U) {
#line 1325
    flush_outbuf();
  }
#line 1326
  if (outcnt < 16382U) {
#line 1326
    tmp___3 = outcnt;
#line 1326
    outcnt ++;
#line 1326
    *(outbuf + tmp___3) = (unsigned char )((time_stamp & 65535L) & 255L);
#line 1326
    tmp___4 = outcnt;
#line 1326
    outcnt ++;
#line 1326
    *(outbuf + tmp___4) = (unsigned char )((int )((unsigned short )(time_stamp & 65535L)) >> 8);
  } else {
#line 1326
    tmp___5 = outcnt;
#line 1326
    outcnt ++;
#line 1326
    *(outbuf + tmp___5) = (unsigned char )((time_stamp & 65535L) & 255L);
#line 1326
    if (outcnt == 16384U) {
#line 1326
      flush_outbuf();
    }
#line 1326
    tmp___6 = outcnt;
#line 1326
    outcnt ++;
#line 1326
    *(outbuf + tmp___6) = (unsigned char )((int )((unsigned short )(time_stamp & 65535L)) >> 8);
#line 1326
    if (outcnt == 16384U) {
#line 1326
      flush_outbuf();
    }
  }
#line 1326
  if (outcnt < 16382U) {
#line 1326
    tmp___7 = outcnt;
#line 1326
    outcnt ++;
#line 1326
    *(outbuf + tmp___7) = (unsigned char )(((unsigned long )time_stamp >> 16) & 255UL);
#line 1326
    tmp___8 = outcnt;
#line 1326
    outcnt ++;
#line 1326
    *(outbuf + tmp___8) = (unsigned char )((int )((unsigned short )((unsigned long )time_stamp >> 16)) >> 8);
  } else {
#line 1326
    tmp___9 = outcnt;
#line 1326
    outcnt ++;
#line 1326
    *(outbuf + tmp___9) = (unsigned char )(((unsigned long )time_stamp >> 16) & 255UL);
#line 1326
    if (outcnt == 16384U) {
#line 1326
      flush_outbuf();
    }
#line 1326
    tmp___10 = outcnt;
#line 1326
    outcnt ++;
#line 1326
    *(outbuf + tmp___10) = (unsigned char )((int )((unsigned short )((unsigned long )time_stamp >> 16)) >> 8);
#line 1326
    if (outcnt == 16384U) {
#line 1326
      flush_outbuf();
    }
  }
#line 1327
  crc = updcrc((unsigned short)0, 0U);
#line 1328
  bi_init(out);
#line 1329
  ct_init(& attr, & method___0);
#line 1330
  lm_init(level, & deflate_flags);
#line 1331
  tmp___11 = outcnt;
#line 1331
  outcnt ++;
#line 1331
  *(outbuf + tmp___11) = (unsigned char )deflate_flags;
#line 1331
  if (outcnt == 16384U) {
#line 1331
    flush_outbuf();
  }
#line 1332
  tmp___12 = outcnt;
#line 1332
  outcnt ++;
#line 1332
  *(outbuf + tmp___12) = (unsigned char)7;
#line 1332
  if (outcnt == 16384U) {
#line 1332
    flush_outbuf();
  }
#line 1333
  if (save_orig_name) {
#line 1334
    tmp___13 = gzipbasename(ifname);
#line 1334
    p = tmp___13;
#line 1335
    while (1) {
#line 1336
      tmp___14 = outcnt;
#line 1336
      outcnt ++;
#line 1336
      *(outbuf + tmp___14) = (unsigned char )*p;
#line 1336
      if (outcnt == 16384U) {
#line 1336
        flush_outbuf();
      }
#line 1335
      tmp___15 = p;
#line 1335
      p ++;
#line 1335
      if (! *tmp___15) {
#line 1335
        break;
      }
    }
  }
#line 1339
  header_bytes = (long )outcnt;
#line 1340
  deflate();
#line 1348
  if (outcnt < 16382U) {
#line 1348
    tmp___16 = outcnt;
#line 1348
    outcnt ++;
#line 1348
    *(outbuf + tmp___16) = (unsigned char )((crc & 65535UL) & 255UL);
#line 1348
    tmp___17 = outcnt;
#line 1348
    outcnt ++;
#line 1348
    *(outbuf + tmp___17) = (unsigned char )((int )((unsigned short )(crc & 65535UL)) >> 8);
  } else {
#line 1348
    tmp___18 = outcnt;
#line 1348
    outcnt ++;
#line 1348
    *(outbuf + tmp___18) = (unsigned char )((crc & 65535UL) & 255UL);
#line 1348
    if (outcnt == 16384U) {
#line 1348
      flush_outbuf();
    }
#line 1348
    tmp___19 = outcnt;
#line 1348
    outcnt ++;
#line 1348
    *(outbuf + tmp___19) = (unsigned char )((int )((unsigned short )(crc & 65535UL)) >> 8);
#line 1348
    if (outcnt == 16384U) {
#line 1348
      flush_outbuf();
    }
  }
#line 1348
  if (outcnt < 16382U) {
#line 1348
    tmp___20 = outcnt;
#line 1348
    outcnt ++;
#line 1348
    *(outbuf + tmp___20) = (unsigned char )((crc >> 16) & 255UL);
#line 1348
    tmp___21 = outcnt;
#line 1348
    outcnt ++;
#line 1348
    *(outbuf + tmp___21) = (unsigned char )((int )((unsigned short )(crc >> 16)) >> 8);
  } else {
#line 1348
    tmp___22 = outcnt;
#line 1348
    outcnt ++;
#line 1348
    *(outbuf + tmp___22) = (unsigned char )((crc >> 16) & 255UL);
#line 1348
    if (outcnt == 16384U) {
#line 1348
      flush_outbuf();
    }
#line 1348
    tmp___23 = outcnt;
#line 1348
    outcnt ++;
#line 1348
    *(outbuf + tmp___23) = (unsigned char )((int )((unsigned short )(crc >> 16)) >> 8);
#line 1348
    if (outcnt == 16384U) {
#line 1348
      flush_outbuf();
    }
  }
#line 1349
  if (outcnt < 16382U) {
#line 1349
    tmp___24 = outcnt;
#line 1349
    outcnt ++;
#line 1349
    *(outbuf + tmp___24) = (unsigned char )((bytes_in & 65535L) & 255L);
#line 1349
    tmp___25 = outcnt;
#line 1349
    outcnt ++;
#line 1349
    *(outbuf + tmp___25) = (unsigned char )((int )((unsigned short )(bytes_in & 65535L)) >> 8);
  } else {
#line 1349
    tmp___26 = outcnt;
#line 1349
    outcnt ++;
#line 1349
    *(outbuf + tmp___26) = (unsigned char )((bytes_in & 65535L) & 255L);
#line 1349
    if (outcnt == 16384U) {
#line 1349
      flush_outbuf();
    }
#line 1349
    tmp___27 = outcnt;
#line 1349
    outcnt ++;
#line 1349
    *(outbuf + tmp___27) = (unsigned char )((int )((unsigned short )(bytes_in & 65535L)) >> 8);
#line 1349
    if (outcnt == 16384U) {
#line 1349
      flush_outbuf();
    }
  }
#line 1349
  if (outcnt < 16382U) {
#line 1349
    tmp___28 = outcnt;
#line 1349
    outcnt ++;
#line 1349
    *(outbuf + tmp___28) = (unsigned char )(((unsigned long )bytes_in >> 16) & 255UL);
#line 1349
    tmp___29 = outcnt;
#line 1349
    outcnt ++;
#line 1349
    *(outbuf + tmp___29) = (unsigned char )((int )((unsigned short )((unsigned long )bytes_in >> 16)) >> 8);
  } else {
#line 1349
    tmp___30 = outcnt;
#line 1349
    outcnt ++;
#line 1349
    *(outbuf + tmp___30) = (unsigned char )(((unsigned long )bytes_in >> 16) & 255UL);
#line 1349
    if (outcnt == 16384U) {
#line 1349
      flush_outbuf();
    }
#line 1349
    tmp___31 = outcnt;
#line 1349
    outcnt ++;
#line 1349
    *(outbuf + tmp___31) = (unsigned char )((int )((unsigned short )((unsigned long )bytes_in >> 16)) >> 8);
#line 1349
    if (outcnt == 16384U) {
#line 1349
      flush_outbuf();
    }
  }
#line 1350
  header_bytes = (long )((unsigned long )header_bytes + (unsigned long )(2U * sizeof(long )));
#line 1351
  flush_outbuf();
#line 1352
  return (0);
}
}
#line 1354 "D:/a/test/164.c"
void flush_window(void) 
{ 

  {
#line 1356
  if (outcnt == 0U) {
#line 1356
    return;
  }
#line 1357
  updcrc((unsigned short )window, outcnt);
#line 1358
  if (! test) {
#line 1359
    write_buf(ofd, (void *)((char *)window), outcnt);
  }
#line 1361
  bytes_out = (long )((unsigned long )bytes_out + (unsigned long )outcnt);
#line 1362
  outcnt = 0U;
#line 1363
  return;
}
}
#line 1365 "D:/a/test/164.c"
char *( __attribute__((__cdecl__)) strlwr)(char *s ) 
{ char *t ;
  int tmp___0 ;

  {
#line 1369
  t = s;
#line 1369
  while (*t) {
#line 1369
    tmp___0 = isupper((int )*t);
#line 1369
    if (tmp___0) {
#line 1369
      *t = (char )(((int )*t - 65) + 97);
    } else {
#line 1369
      *t = *t;
    }
#line 1369
    t ++;
  }
#line 1370
  return (s);
}
}
#line 1372 "D:/a/test/164.c"
char *gzipbasename(char *fname ) 
{ char *p ;

  {
#line 1376
  p = strrchr((char const   *)fname, ':');
#line 1376
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 1376
    fname = p + 1;
  }
#line 1387
  return (fname);
}
}
#line 1389 "D:/a/test/164.c"
void make_simple_name(char *name ) 
{ char *p ;
  char *tmp ;

  {
#line 1392
  tmp = strrchr((char const   *)name, '.');
#line 1392
  p = tmp;
#line 1393
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1393
    return;
  }
#line 1394
  if ((unsigned int )p == (unsigned int )name) {
#line 1394
    p ++;
  }
#line 1395
  while (1) {
#line 1396
    p --;
#line 1396
    if ((int )*p == 46) {
#line 1396
      *p = (char )'_';
    }
#line 1395
    if (! ((unsigned int )p != (unsigned int )name)) {
#line 1395
      break;
    }
  }
#line 1398
  return;
}
}
#line 1434 "D:/a/test/164.c"
char *add_envopt(int *argcp , char ***argvp , char *env___0 ) 
{ char *p ;
  char **oargv ;
  char **nargv ;
  int oargc ;
  int nargc ;
  char *tmp ;
  size_t tmp___0 ;
  voidp tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char **tmp___8 ;
  size_t tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  char **tmp___12 ;
  char **tmp___13 ;
  int tmp___14 ;

  {
#line 1442
  oargc = *argcp;
#line 1443
  nargc = 0;
#line 1444
  tmp = getenv((char const   *)env___0);
#line 1444
  env___0 = tmp;
#line 1445
  if ((unsigned int )env___0 == (unsigned int )((void *)0)) {
#line 1445
    return ((char *)((void *)0));
  }
#line 1446
  tmp___0 = strlen((char const   *)env___0);
#line 1446
  tmp___1 = xmalloc(tmp___0 + 1U);
#line 1446
  p = (char *)tmp___1;
#line 1447
  env___0 = strcpy(p, (char const   *)env___0);
#line 1448
  p = env___0;
#line 1448
  while (*p) {
#line 1449
    tmp___2 = strspn((char const   *)p, " \t");
#line 1449
    p += tmp___2;
#line 1450
    if ((int )*p == 0) {
#line 1450
      break;
    }
#line 1451
    tmp___3 = strcspn((char const   *)p, " \t");
#line 1451
    p += tmp___3;
#line 1452
    if (*p) {
#line 1452
      tmp___4 = p;
#line 1452
      p ++;
#line 1452
      *tmp___4 = (char )'\000';
    }
#line 1448
    nargc ++;
  }
#line 1454
  if (nargc == 0) {
#line 1455
    free((void *)env___0);
#line 1456
    return ((char *)((void *)0));
  }
#line 1458
  *argcp += nargc;
#line 1459
  tmp___5 = calloc((unsigned int )(*argcp + 1), sizeof(char *));
#line 1459
  nargv = (char **)tmp___5;
#line 1460
  if ((unsigned int )nargv == (unsigned int )((void *)0)) {
#line 1460
    error("out of memory");
  }
#line 1461
  oargv = *argvp;
#line 1462
  *argvp = nargv;
#line 1463
  tmp___6 = oargc;
#line 1463
  oargc --;
#line 1463
  if (tmp___6 < 0) {
#line 1463
    error("argc<=0");
  }
#line 1464
  tmp___7 = nargv;
#line 1464
  nargv ++;
#line 1464
  tmp___8 = oargv;
#line 1464
  oargv ++;
#line 1464
  *tmp___7 = *tmp___8;
#line 1465
  p = env___0;
#line 1465
  while (nargc > 0) {
#line 1466
    tmp___9 = strspn((char const   *)p, " \t");
#line 1466
    p += tmp___9;
#line 1467
    tmp___10 = nargv;
#line 1467
    nargv ++;
#line 1467
    *tmp___10 = p;
#line 1468
    while (1) {
#line 1468
      tmp___11 = p;
#line 1468
      p ++;
#line 1468
      if (! *tmp___11) {
#line 1468
        break;
      }
    }
#line 1465
    nargc --;
  }
#line 1470
  while (1) {
#line 1470
    tmp___14 = oargc;
#line 1470
    oargc --;
#line 1470
    if (! tmp___14) {
#line 1470
      break;
    }
#line 1470
    tmp___12 = nargv;
#line 1470
    nargv ++;
#line 1470
    tmp___13 = oargv;
#line 1470
    oargv ++;
#line 1470
    *tmp___12 = *tmp___13;
  }
#line 1471
  *nargv = (char *)((void *)0);
#line 1472
  return (env___0);
}
}
#line 1474 "D:/a/test/164.c"
void error(char *m ) 
{ struct _reent *tmp ;

  {
#line 1477
  tmp = __getreent();
#line 1477
  fprintf(tmp->_stderr, "\n%s: %s: %s\n", progname, ifname, m);
#line 1478
  abort_gzip();
#line 1479
  return;
}
}
#line 1480 "D:/a/test/164.c"
void warn(char *a , char *b ) 
{ struct _reent *tmp ;

  {
#line 1483
  if (! quiet) {
#line 1483
    tmp = __getreent();
#line 1483
    fprintf(tmp->_stderr, "%s: %s: warning: %s%s\n", progname, ifname, a, b);
  }
#line 1483
  if (exit_code == 0) {
#line 1483
    exit_code = 2;
  }
#line 1484
  return;
}
}
#line 1485 "D:/a/test/164.c"
void read_error(void) 
{ struct _reent *tmp ;
  struct _reent *tmp___0 ;

  {
#line 1487
  tmp = __getreent();
#line 1487
  fprintf(tmp->_stderr, "\n%s: ", progname);
#line 1488
  if (errno != 0) {
#line 1489
    perror((char const   *)(ifname));
  } else {
#line 1491
    tmp___0 = __getreent();
#line 1491
    fprintf(tmp___0->_stderr, "%s: unexpected end of file\n", ifname);
  }
#line 1493
  abort_gzip();
#line 1494
  return;
}
}
#line 1495 "D:/a/test/164.c"
void write_error(void) 
{ struct _reent *tmp ;

  {
#line 1497
  tmp = __getreent();
#line 1497
  fprintf(tmp->_stderr, "\n%s: ", progname);
#line 1498
  perror((char const   *)(ofname));
#line 1499
  abort_gzip();
#line 1500
  return;
}
}
#line 1501 "D:/a/test/164.c"
void display_ratio(long num , long den , FILE *file ) 
{ long ratio ;

  {
#line 1507
  if (den == 0L) {
#line 1508
    ratio = 0L;
  } else {
#line 1509
    if (den < 2147483L) {
#line 1510
      ratio = (1000L * num) / den;
    } else {
#line 1512
      ratio = num / (den / 1000L);
    }
  }
#line 1514
  if (ratio < 0L) {
#line 1515
    putc('-', file);
#line 1516
    ratio = - ratio;
  } else {
#line 1518
    putc(' ', file);
  }
#line 1520
  fprintf(file, "%2ld.%1ld%%", ratio / 10L, ratio % 10L);
#line 1521
  return;
}
}
#line 1522 "D:/a/test/164.c"
voidp xmalloc(unsigned int size ) 
{ voidp cp ;
  void *tmp ;

  {
#line 1525
  tmp = malloc(size);
#line 1525
  cp = tmp;
#line 1526
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1526
    error((char *)"out of memory");
  }
#line 1527
  return (cp);
}
}
#line 1545 "D:/a/test/164.c"
static int msg_done  =    0;
#line 1546 "D:/a/test/164.c"
int lzw(int in , int out ) 
{ struct _reent *tmp ;

  {
#line 1549
  if (msg_done) {
#line 1549
    return (1);
  }
#line 1550
  msg_done = 1;
#line 1551
  tmp = __getreent();
#line 1551
  fprintf(tmp->_stderr, "output in compress .Z format not supported\n");
#line 1552
  if (in != out) {
#line 1553
    exit_code = 1;
  }
#line 1555
  return (1);
}
}
#line 1710 "D:/a/test/164.c"
int block_mode  =    128;
#line 1711 "D:/a/test/164.c"
int unlzw(int in , int out ) 
{ register char_type *stackp ;
  code_int code ;
  int finchar ;
  code_int oldcode ;
  code_int incode ;
  long inbits ;
  long posbits ;
  int outpos ;
  unsigned int bitmask ;
  code_int free_ent ;
  code_int maxcode ;
  code_int maxmaxcode ;
  int n_bits ;
  int rsize ;
  unsigned int tmp ;
  int tmp___0 ;
  struct _reent *tmp___1 ;
  struct _reent *tmp___2 ;
  register int i ;
  int e ;
  int o ;
  register char_type *p ;
  int tmp___3 ;
  char const   *tmp___4 ;
  register int i___0 ;

  {
#line 1732
  if (inptr < insize) {
#line 1732
    tmp = inptr;
#line 1732
    inptr ++;
#line 1732
    maxbits = (int )*(inbuf + tmp);
  } else {
#line 1732
    tmp___0 = fill_inbuf(0);
#line 1732
    maxbits = tmp___0;
  }
#line 1733
  block_mode = maxbits & 128;
#line 1734
  if ((maxbits & 96) != 0) {
#line 1735
    if (! quiet) {
#line 1735
      tmp___1 = __getreent();
#line 1735
      fprintf(tmp___1->_stderr, "\n%s: %s: warning, unknown flags 0x%x\n", progname,
              ifname, maxbits & 96);
    }
#line 1735
    if (exit_code == 0) {
#line 1735
      exit_code = 2;
    }
  }
#line 1738
  maxbits &= 31;
#line 1739
  maxmaxcode = 1L << maxbits;
#line 1740
  if (maxbits > 16) {
#line 1741
    tmp___2 = __getreent();
#line 1741
    fprintf(tmp___2->_stderr, "\n%s: %s: compressed with %d bits, can only handle %d bits\n",
            progname, ifname, maxbits, 16);
#line 1744
    exit_code = 1;
#line 1745
    return (1);
  }
#line 1747
  rsize = (int )insize;
#line 1748
  n_bits = 9;
#line 1748
  maxcode = (1L << n_bits) - 1L;
#line 1749
  bitmask = (unsigned int )((1 << n_bits) - 1);
#line 1750
  oldcode = -1L;
#line 1751
  finchar = 0;
#line 1752
  outpos = 0;
#line 1753
  posbits = (long )(inptr << 3);
#line 1754
  if (block_mode) {
#line 1754
    free_ent = 257L;
  } else {
#line 1754
    free_ent = 256L;
  }
#line 1755
  memset((void *)prev, 0, 256U);
#line 1756
  code = 255L;
#line 1756
  while (code >= 0L) {
#line 1757
    *(window + code) = (unsigned char )code;
#line 1756
    code --;
  }
#line 1759
  while (1) {
    resetbuf: 
#line 1765
    o = (int )(posbits >> 3);
#line 1765
    e = (int )(insize - (unsigned int )o);
#line 1767
    i = 0;
#line 1767
    while (i < e) {
#line 1768
      *(inbuf + i) = *(inbuf + (i + o));
#line 1767
      i ++;
    }
#line 1770
    insize = (unsigned int )e;
#line 1771
    posbits = 0L;
#line 1773
    if (insize < 64U) {
#line 1774
      rsize = spec_read(in, (unsigned char *)((char *)inbuf + insize), 32768);
#line 1774
      if (rsize == -1) {
#line 1775
        read_error();
      }
#line 1777
      insize += (unsigned int )rsize;
#line 1778
      bytes_in = (long )((unsigned long )bytes_in + (unsigned long )rsize);
    }
#line 1780
    if (rsize != 0) {
#line 1780
      inbits = (long )(((unsigned long )((long )insize) - (unsigned long )(insize % (unsigned int )n_bits)) << 3);
    } else {
#line 1780
      inbits = ((long )insize << 3) - (long )(n_bits - 1);
    }
#line 1783
    while (inbits > posbits) {
#line 1784
      if (free_ent > maxcode) {
#line 1785
        posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
#line 1787
        n_bits ++;
#line 1788
        if (n_bits == maxbits) {
#line 1789
          maxcode = maxmaxcode;
        } else {
#line 1791
          maxcode = (1L << n_bits) - 1L;
        }
#line 1793
        bitmask = (unsigned int )((1 << n_bits) - 1);
        goto resetbuf;
      }
#line 1796
      p = inbuf + (posbits >> 3);
#line 1796
      code = (long )((unsigned long )((((long )*(p + 0) | ((long )*(p + 1) << 8)) | ((long )*(p + 2) << 16)) >> (posbits & 7L)) & (unsigned long )bitmask);
#line 1796
      posbits += (long )n_bits;
#line 1798
      if (oldcode == -1L) {
#line 1799
        if (code >= 256L) {
#line 1799
          error((char *)"corrupt input.");
        }
#line 1800
        tmp___3 = outpos;
#line 1800
        outpos ++;
#line 1800
        oldcode = code;
#line 1800
        finchar = (int )oldcode;
#line 1800
        *(outbuf + tmp___3) = (unsigned char )finchar;
#line 1801
        continue;
      }
#line 1803
      if (code == 256L) {
#line 1803
        if (block_mode) {
#line 1804
          memset((void *)prev, 0, 256U);
#line 1805
          free_ent = 256L;
#line 1806
          posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
#line 1808
          n_bits = 9;
#line 1808
          maxcode = (1L << n_bits) - 1L;
#line 1809
          bitmask = (unsigned int )((1 << n_bits) - 1);
          goto resetbuf;
        }
      }
#line 1812
      incode = code;
#line 1813
      stackp = (char_type *)(d_buf + 32767);
#line 1815
      if (code >= free_ent) {
#line 1816
        if (code > free_ent) {
#line 1828
          if (! test) {
#line 1828
            if (outpos > 0) {
#line 1829
              write_buf(out, (void *)((char *)outbuf), (unsigned int )outpos);
#line 1830
              bytes_out = (long )((unsigned long )bytes_out + (unsigned long )outpos);
            }
          }
#line 1832
          if (to_stdout) {
#line 1832
            tmp___4 = "corrupt input.";
          } else {
#line 1832
            tmp___4 = "corrupt input. Use zcat to recover some data.";
          }
#line 1832
          error((char *)tmp___4);
        }
#line 1835
        stackp --;
#line 1835
        *stackp = (unsigned char )finchar;
#line 1836
        code = oldcode;
      }
#line 1838
      while ((unsigned long )code >= 256UL) {
#line 1840
        stackp --;
#line 1840
        *stackp = *(window + code);
#line 1841
        code = (long )*(prev + code);
      }
#line 1843
      stackp --;
#line 1843
      finchar = (int )*(window + code);
#line 1843
      *stackp = (unsigned char )finchar;
#line 1849
      i___0 = (char_type *)(d_buf + 32767) - stackp;
#line 1849
      if (outpos + i___0 >= 16384) {
#line 1850
        while (1) {
#line 1851
          if (i___0 > 16384 - outpos) {
#line 1851
            i___0 = 16384 - outpos;
          }
#line 1852
          if (i___0 > 0) {
#line 1853
            memcpy((void *)(outbuf + outpos), (void const   *)stackp, (unsigned int )i___0);
#line 1854
            outpos += i___0;
          }
#line 1856
          if (outpos >= 16384) {
#line 1857
            if (! test) {
#line 1858
              write_buf(out, (void *)((char *)outbuf), (unsigned int )outpos);
#line 1859
              bytes_out = (long )((unsigned long )bytes_out + (unsigned long )outpos);
            }
#line 1861
            outpos = 0;
          }
#line 1863
          stackp += i___0;
#line 1850
          i___0 = (char_type *)(d_buf + 32767) - stackp;
#line 1850
          if (! (i___0 > 0)) {
#line 1850
            break;
          }
        }
      } else {
#line 1866
        memcpy((void *)(outbuf + outpos), (void const   *)stackp, (unsigned int )i___0);
#line 1867
        outpos += i___0;
      }
#line 1870
      code = free_ent;
#line 1870
      if (code < maxmaxcode) {
#line 1871
        *(prev + code) = (unsigned short )oldcode;
#line 1872
        *(window + code) = (unsigned char )finchar;
#line 1873
        free_ent = code + 1L;
      }
#line 1875
      oldcode = incode;
    }
#line 1759
    if (! (rsize != 0)) {
#line 1759
      break;
    }
  }
#line 1878
  if (! test) {
#line 1878
    if (outpos > 0) {
#line 1879
      write_buf(out, (void *)((char *)outbuf), (unsigned int )outpos);
#line 1880
      bytes_out = (long )((unsigned long )bytes_out + (unsigned long )outpos);
    }
  }
#line 1882
  return (0);
}
}
#line 1889
static unsigned int decode(unsigned int count , uch *buffer ) ;
#line 1890
static void decode_start(void) ;
#line 1891
static void huf_decode_start(void) ;
#line 1892
static unsigned int decode_c(void) ;
#line 1893
static unsigned int decode_p(void) ;
#line 1894
static void read_pt_len(int nn , int nbit , int i_special ) ;
#line 1895
static void read_c_len(void) ;
#line 1896
static void fillbuf(int n ) ;
#line 1897
static unsigned int getbits(int n ) ;
#line 1898
static void init_getbits(void) ;
#line 1899
static void make_table(int nchar , uch *bitlen , int tablebits , ush *table ) ;
#line 1934 "D:/a/test/164.c"
static uch pt_len[19]  ;
#line 1935 "D:/a/test/164.c"
static unsigned int blocksize  ;
#line 1936 "D:/a/test/164.c"
static ush pt_table[256]  ;
#line 1942 "D:/a/test/164.c"
static unsigned int subbitbuf  ;
#line 1943 "D:/a/test/164.c"
static int bitcount  ;
#line 1944 "D:/a/test/164.c"
static void fillbuf(int n ) 
{ unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1947
  bitbuf <<= n;
#line 1948
  while (n > bitcount) {
#line 1949
    n -= bitcount;
#line 1949
    bitbuf |= (unsigned long )(subbitbuf << n);
#line 1950
    if (inptr < insize) {
#line 1950
      tmp = inptr;
#line 1950
      inptr ++;
#line 1950
      tmp___1 = (int )*(inbuf + tmp);
    } else {
#line 1950
      tmp___0 = fill_inbuf(1);
#line 1950
      tmp___1 = tmp___0;
    }
#line 1950
    subbitbuf = (unsigned int )tmp___1;
#line 1951
    if ((int )subbitbuf == -1) {
#line 1951
      subbitbuf = 0U;
    }
#line 1952
    bitcount = 8;
  }
#line 1954
  bitcount -= n;
#line 1954
  bitbuf |= (unsigned long )(subbitbuf >> bitcount);
#line 1955
  return;
}
}
#line 1956 "D:/a/test/164.c"
static unsigned int getbits(int n ) 
{ unsigned int x ;

  {
#line 1960
  x = (unsigned int )(bitbuf >> (16U * sizeof(char ) - (unsigned int )n));
#line 1960
  fillbuf(n);
#line 1961
  return (x);
}
}
#line 1963 "D:/a/test/164.c"
static void init_getbits(void) 
{ 

  {
#line 1965
  bitbuf = 0UL;
#line 1965
  subbitbuf = 0U;
#line 1965
  bitcount = 0;
#line 1966
  fillbuf((int )(16U * sizeof(char )));
#line 1967
  return;
}
}
#line 1968 "D:/a/test/164.c"
static void make_table(int nchar , uch *bitlen , int tablebits , ush *table ) 
{ ush count[17] ;
  ush weight[17] ;
  ush start[18] ;
  ush *p ;
  unsigned int i ;
  unsigned int k ;
  unsigned int len ;
  unsigned int ch ;
  unsigned int jutbits ;
  unsigned int avail ;
  unsigned int nextcode ;
  unsigned int mask ;
  unsigned int tmp ;
  ush tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1976
  i = 1U;
#line 1976
  while (i <= 16U) {
#line 1976
    count[i] = (unsigned short)0;
#line 1976
    i ++;
  }
#line 1977
  i = 0U;
#line 1977
  while (i < (unsigned int )nchar) {
#line 1977
    count[*(bitlen + i)] = (ush )((int )count[*(bitlen + i)] + 1);
#line 1977
    i ++;
  }
#line 1978
  start[1] = (unsigned short)0;
#line 1979
  i = 1U;
#line 1979
  while (i <= 16U) {
#line 1980
    start[i + 1U] = (unsigned short )((int )start[i] + ((int )count[i] << (16U - i)));
#line 1979
    i ++;
  }
#line 1981
  if (((int )start[17] & 65535) != 0) {
#line 1982
    error((char *)"Bad table\n");
  }
#line 1983
  jutbits = (unsigned int )(16 - tablebits);
#line 1984
  i = 1U;
#line 1984
  while (i <= (unsigned int )tablebits) {
#line 1985
    start[i] = (unsigned short )((int )start[i] >> jutbits);
#line 1986
    weight[i] = (unsigned short )(1U << ((unsigned int )tablebits - i));
#line 1984
    i ++;
  }
#line 1988
  while (i <= 16U) {
#line 1989
    weight[i] = (unsigned short )(1U << (16U - i));
#line 1990
    i ++;
  }
#line 1992
  i = (unsigned int )((int )start[tablebits + 1] >> jutbits);
#line 1993
  if (i != 0U) {
#line 1994
    k = (unsigned int )(1 << tablebits);
#line 1995
    while (i != k) {
#line 1995
      tmp = i;
#line 1995
      i ++;
#line 1995
      *(table + tmp) = (unsigned short)0;
    }
  }
#line 1997
  avail = (unsigned int )nchar;
#line 1998
  mask = 1U << (15 - tablebits);
#line 1999
  ch = 0U;
#line 1999
  while (ch < (unsigned int )nchar) {
#line 2000
    len = (unsigned int )*(bitlen + ch);
#line 2000
    if (len == 0U) {
      goto __Cont;
    }
#line 2001
    nextcode = (unsigned int )((int )start[len] + (int )weight[len]);
#line 2002
    if (len <= (unsigned int )tablebits) {
#line 2003
      i = (unsigned int )start[len];
#line 2003
      while (i < nextcode) {
#line 2003
        *(table + i) = (unsigned short )ch;
#line 2003
        i ++;
      }
    } else {
#line 2005
      k = (unsigned int )start[len];
#line 2006
      p = table + (k >> jutbits);
#line 2007
      i = len - (unsigned int )tablebits;
#line 2008
      while (i != 0U) {
#line 2009
        if ((int )*p == 0) {
#line 2010
          tmp___0 = (unsigned short)0;
#line 2010
          *(prev + avail) = tmp___0;
#line 2010
          *((prev + 32768) + avail) = tmp___0;
#line 2011
          tmp___1 = avail;
#line 2011
          avail ++;
#line 2011
          *p = (unsigned short )tmp___1;
        }
#line 2013
        if (k & mask) {
#line 2013
          p = (prev + 32768) + *p;
        } else {
#line 2014
          p = prev + *p;
        }
#line 2015
        k <<= 1;
#line 2015
        i --;
      }
#line 2017
      *p = (unsigned short )ch;
    }
#line 2019
    start[len] = (unsigned short )nextcode;
    __Cont: /* CIL Label */ 
#line 1999
    ch ++;
  }
#line 2021
  return;
}
}
#line 2022 "D:/a/test/164.c"
static void read_pt_len(int nn , int nbit , int i_special ) 
{ int i ;
  int c ;
  int n ;
  unsigned int mask ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2029
  tmp = getbits(nbit);
#line 2029
  n = (int )tmp;
#line 2030
  if (n == 0) {
#line 2031
    tmp___0 = getbits(nbit);
#line 2031
    c = (int )tmp___0;
#line 2032
    i = 0;
#line 2032
    while (i < nn) {
#line 2032
      pt_len[i] = (unsigned char)0;
#line 2032
      i ++;
    }
#line 2033
    i = 0;
#line 2033
    while (i < 256) {
#line 2033
      pt_table[i] = (unsigned short )c;
#line 2033
      i ++;
    }
  } else {
#line 2035
    i = 0;
#line 2036
    while (i < n) {
#line 2037
      c = (int )(bitbuf >> (16U * sizeof(char ) - 3U));
#line 2038
      if (c == 7) {
#line 2039
        mask = 1U << ((16U * sizeof(char ) - 1U) - 3U);
#line 2040
        while ((unsigned long )mask & bitbuf) {
#line 2040
          mask >>= 1;
#line 2040
          c ++;
        }
      }
#line 2042
      if (c < 7) {
#line 2042
        tmp___1 = 3;
      } else {
#line 2042
        tmp___1 = c - 3;
      }
#line 2042
      fillbuf(tmp___1);
#line 2043
      tmp___2 = i;
#line 2043
      i ++;
#line 2043
      pt_len[tmp___2] = (unsigned char )c;
#line 2044
      if (i == i_special) {
#line 2045
        tmp___3 = getbits(2);
#line 2045
        c = (int )tmp___3;
#line 2046
        while (1) {
#line 2046
          c --;
#line 2046
          if (! (c >= 0)) {
#line 2046
            break;
          }
#line 2046
          tmp___4 = i;
#line 2046
          i ++;
#line 2046
          pt_len[tmp___4] = (unsigned char)0;
        }
      }
    }
#line 2049
    while (i < nn) {
#line 2049
      tmp___5 = i;
#line 2049
      i ++;
#line 2049
      pt_len[tmp___5] = (unsigned char)0;
    }
#line 2050
    make_table(nn, pt_len, 8, pt_table);
  }
#line 2052
  return;
}
}
#line 2053 "D:/a/test/164.c"
static void read_c_len(void) 
{ int i ;
  int c ;
  int n ;
  unsigned int mask ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2057
  tmp = getbits(9);
#line 2057
  n = (int )tmp;
#line 2058
  if (n == 0) {
#line 2059
    tmp___0 = getbits(9);
#line 2059
    c = (int )tmp___0;
#line 2060
    i = 0;
#line 2060
    while (i < 510) {
#line 2060
      *(outbuf + i) = (unsigned char)0;
#line 2060
      i ++;
    }
#line 2061
    i = 0;
#line 2061
    while (i < 4096) {
#line 2061
      *(d_buf + i) = (unsigned short )c;
#line 2061
      i ++;
    }
  } else {
#line 2063
    i = 0;
#line 2064
    while (i < n) {
#line 2065
      c = (int )pt_table[bitbuf >> (16U * sizeof(char ) - 8U)];
#line 2066
      if (c >= 19) {
#line 2067
        mask = 1U << ((16U * sizeof(char ) - 1U) - 8U);
#line 2068
        while (1) {
#line 2069
          if (bitbuf & (unsigned long )mask) {
#line 2069
            c = (int )*((prev + 32768) + c);
          } else {
#line 2070
            c = (int )*(prev + c);
          }
#line 2071
          mask >>= 1;
#line 2068
          if (! (c >= 19)) {
#line 2068
            break;
          }
        }
      }
#line 2074
      fillbuf((int )pt_len[c]);
#line 2075
      if (c <= 2) {
#line 2076
        if (c == 0) {
#line 2076
          c = 1;
        } else {
#line 2077
          if (c == 1) {
#line 2077
            tmp___1 = getbits(4);
#line 2077
            c = (int )(tmp___1 + 3U);
          } else {
#line 2078
            tmp___2 = getbits(9);
#line 2078
            c = (int )(tmp___2 + 20U);
          }
        }
#line 2079
        while (1) {
#line 2079
          c --;
#line 2079
          if (! (c >= 0)) {
#line 2079
            break;
          }
#line 2079
          tmp___3 = i;
#line 2079
          i ++;
#line 2079
          *(outbuf + tmp___3) = (unsigned char)0;
        }
      } else {
#line 2080
        tmp___4 = i;
#line 2080
        i ++;
#line 2080
        *(outbuf + tmp___4) = (unsigned char )(c - 2);
      }
    }
#line 2082
    while (i < 510) {
#line 2082
      tmp___5 = i;
#line 2082
      i ++;
#line 2082
      *(outbuf + tmp___5) = (unsigned char)0;
    }
#line 2083
    make_table(510, outbuf, 12, d_buf);
  }
#line 2085
  return;
}
}
#line 2086 "D:/a/test/164.c"
static unsigned int decode_c(void) 
{ unsigned int j ;
  unsigned int mask ;

  {
#line 2089
  if (blocksize == 0U) {
#line 2090
    blocksize = getbits(16);
#line 2091
    if (blocksize == 0U) {
#line 2092
      return (510U);
    }
#line 2094
    read_pt_len(19, 5, 3);
#line 2095
    read_c_len();
#line 2096
    read_pt_len(14, 4, -1);
  }
#line 2098
  blocksize --;
#line 2099
  j = (unsigned int )*(d_buf + (bitbuf >> (16U * sizeof(char ) - 12U)));
#line 2100
  if (j >= 510U) {
#line 2101
    mask = 1U << ((16U * sizeof(char ) - 1U) - 12U);
#line 2102
    while (1) {
#line 2103
      if (bitbuf & (unsigned long )mask) {
#line 2103
        j = (unsigned int )*((prev + 32768) + j);
      } else {
#line 2104
        j = (unsigned int )*(prev + j);
      }
#line 2105
      mask >>= 1;
#line 2102
      if (! (j >= 510U)) {
#line 2102
        break;
      }
    }
  }
#line 2108
  fillbuf((int )*(outbuf + j));
#line 2109
  return (j);
}
}
#line 2111 "D:/a/test/164.c"
static unsigned int decode_p(void) 
{ unsigned int j ;
  unsigned int mask ;
  unsigned int tmp ;

  {
#line 2114
  j = (unsigned int )pt_table[bitbuf >> (16U * sizeof(char ) - 8U)];
#line 2115
  if (j >= 14U) {
#line 2116
    mask = 1U << ((16U * sizeof(char ) - 1U) - 8U);
#line 2117
    while (1) {
#line 2118
      if (bitbuf & (unsigned long )mask) {
#line 2118
        j = (unsigned int )*((prev + 32768) + j);
      } else {
#line 2119
        j = (unsigned int )*(prev + j);
      }
#line 2120
      mask >>= 1;
#line 2117
      if (! (j >= 14U)) {
#line 2117
        break;
      }
    }
  }
#line 2123
  fillbuf((int )pt_len[j]);
#line 2124
  if (j != 0U) {
#line 2124
    tmp = getbits((int )(j - 1U));
#line 2124
    j = (1U << (j - 1U)) + tmp;
  }
#line 2125
  return (j);
}
}
#line 2127 "D:/a/test/164.c"
static void huf_decode_start(void) 
{ 

  {
#line 2129
  init_getbits();
#line 2129
  blocksize = 0U;
#line 2130
  return;
}
}
#line 2131 "D:/a/test/164.c"
static int j  ;
#line 2132 "D:/a/test/164.c"
static int done  ;
#line 2133 "D:/a/test/164.c"
static void decode_start(void) 
{ 

  {
#line 2135
  huf_decode_start();
#line 2136
  j = 0;
#line 2137
  done = 0;
#line 2138
  return;
}
}
#line 2143 "D:/a/test/164.c"
static unsigned int i  ;
#line 2139 "D:/a/test/164.c"
static unsigned int decode(unsigned int count , uch *buffer ) 
{ unsigned int r ;
  unsigned int c ;
  unsigned int tmp ;

  {
#line 2145
  r = 0U;
#line 2146
  while (1) {
#line 2146
    j --;
#line 2146
    if (! (j >= 0)) {
#line 2146
      break;
    }
#line 2147
    *(buffer + r) = *(buffer + i);
#line 2148
    i = (i + 1U) & ((1U << 13) - 1U);
#line 2149
    r ++;
#line 2149
    if (r == count) {
#line 2149
      return (r);
    }
  }
#line 2151
  while (1) {
#line 2152
    c = decode_c();
#line 2153
    if (c == 510U) {
#line 2154
      done = 1;
#line 2155
      return (r);
    }
#line 2157
    if (c <= 255U) {
#line 2158
      *(buffer + r) = (unsigned char )c;
#line 2159
      r ++;
#line 2159
      if (r == count) {
#line 2159
        return (r);
      }
    } else {
#line 2161
      j = (int )(c - 253U);
#line 2162
      tmp = decode_p();
#line 2162
      i = ((r - tmp) - 1U) & ((1U << 13) - 1U);
#line 2163
      while (1) {
#line 2163
        j --;
#line 2163
        if (! (j >= 0)) {
#line 2163
          break;
        }
#line 2164
        *(buffer + r) = *(buffer + i);
#line 2165
        i = (i + 1U) & ((1U << 13) - 1U);
#line 2166
        r ++;
#line 2166
        if (r == count) {
#line 2166
          return (r);
        }
      }
    }
  }
}
}
#line 2171 "D:/a/test/164.c"
int unlzh(int in , int out ) 
{ unsigned int n ;

  {
#line 2176
  ifd = in;
#line 2177
  ofd = out;
#line 2178
  decode_start();
#line 2179
  while (! done) {
#line 2180
    n = decode(1U << 13, window);
#line 2181
    if (! test) {
#line 2181
      if (n > 0U) {
#line 2182
        write_buf(out, (void *)((char *)window), n);
      }
    }
  }
#line 2185
  return (0);
}
}
#line 2207
ulg updcrc1(uch *s , unsigned int n ) ;
#line 2207 "D:/a/test/164.c"
static ulg crc___0  =    4294967295UL;
#line 2202 "D:/a/test/164.c"
ulg updcrc1(uch *s , unsigned int n ) 
{ register ulg c ;
  uch *tmp ;

  {
#line 2208
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 2209
    c = 4294967295UL;
  } else {
#line 2211
    c = crc___0;
#line 2212
    if (n) {
#line 2212
      while (1) {
#line 2213
        tmp = s;
#line 2213
        s ++;
#line 2213
        c = crc_32_tab[((int )c ^ (int )*tmp) & 255] ^ (c >> 8);
#line 2212
        n --;
#line 2212
        if (! n) {
#line 2212
          break;
        }
      }
    }
  }
#line 2216
  crc___0 = c;
#line 2217
  return (c ^ 4294967295UL);
}
}
#line 2219 "D:/a/test/164.c"
int file_read(char *buf , unsigned int size ) 
{ unsigned int len ;
  int tmp ;

  {
#line 2225
  tmp = spec_read(ifd, (unsigned char *)buf, (int )size);
#line 2225
  len = (unsigned int )tmp;
#line 2226
  if (len == 4294967295U) {
#line 2226
    return ((int )len);
  } else {
#line 2226
    if (len == 0U) {
#line 2226
      return ((int )len);
    }
  }
#line 2227
  crc = updcrc1((uch *)buf, len);
#line 2228
  bytes_in = (long )((unsigned long )bytes_in + (unsigned long )len);
#line 2229
  return ((int )len);
}
}
#line 2240 "D:/a/test/164.c"
static file_t zfile  ;
#line 2241 "D:/a/test/164.c"
static unsigned short bi_buf  =    (unsigned short)0;
#line 2243 "D:/a/test/164.c"
static int bi_valid  =    0;
#line 2244 "D:/a/test/164.c"
int (*read_buf)(char *buf , unsigned int size )  ;
#line 2248 "D:/a/test/164.c"
void bi_init(file_t zipfile ) 
{ 

  {
#line 2251
  zfile = zipfile;
#line 2252
  bi_buf = (unsigned short)0;
#line 2253
  bi_valid = 0;
#line 2257
  if (zfile != -1) {
#line 2258
    read_buf = & file_read;
  }
#line 2260
  return;
}
}
#line 2261 "D:/a/test/164.c"
void send_bits(int value , int length ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 2270
  if (bi_valid > (int )(16U * sizeof(char )) - length) {
#line 2271
    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
#line 2272
    if (outcnt < 16382U) {
#line 2272
      tmp = outcnt;
#line 2272
      outcnt ++;
#line 2272
      *(outbuf + tmp) = (unsigned char )((int )bi_buf & 255);
#line 2272
      tmp___0 = outcnt;
#line 2272
      outcnt ++;
#line 2272
      *(outbuf + tmp___0) = (unsigned char )((int )bi_buf >> 8);
    } else {
#line 2272
      tmp___1 = outcnt;
#line 2272
      outcnt ++;
#line 2272
      *(outbuf + tmp___1) = (unsigned char )((int )bi_buf & 255);
#line 2272
      if (outcnt == 16384U) {
#line 2272
        flush_outbuf();
      }
#line 2272
      tmp___2 = outcnt;
#line 2272
      outcnt ++;
#line 2272
      *(outbuf + tmp___2) = (unsigned char )((int )bi_buf >> 8);
#line 2272
      if (outcnt == 16384U) {
#line 2272
        flush_outbuf();
      }
    }
#line 2273
    bi_buf = (unsigned short )((int )((unsigned short )value) >> (16U * sizeof(char ) - (unsigned int )bi_valid));
#line 2274
    bi_valid = (int )((unsigned int )bi_valid + ((unsigned int )length - 16U * sizeof(char )));
  } else {
#line 2276
    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
#line 2277
    bi_valid += length;
  }
#line 2279
  return;
}
}
#line 2280 "D:/a/test/164.c"
unsigned int bi_reverse(unsigned int code , int len ) 
{ register unsigned int res ;

  {
#line 2284
  res = 0U;
#line 2285
  while (1) {
#line 2286
    res |= code & 1U;
#line 2287
    code >>= 1;
#line 2287
    res <<= 1;
#line 2285
    len --;
#line 2285
    if (! (len > 0)) {
#line 2285
      break;
    }
  }
#line 2289
  return (res >> 1);
}
}
#line 2291 "D:/a/test/164.c"
void bi_windup(void) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 2293
  if (bi_valid > 8) {
#line 2294
    if (outcnt < 16382U) {
#line 2294
      tmp = outcnt;
#line 2294
      outcnt ++;
#line 2294
      *(outbuf + tmp) = (unsigned char )((int )bi_buf & 255);
#line 2294
      tmp___0 = outcnt;
#line 2294
      outcnt ++;
#line 2294
      *(outbuf + tmp___0) = (unsigned char )((int )bi_buf >> 8);
    } else {
#line 2294
      tmp___1 = outcnt;
#line 2294
      outcnt ++;
#line 2294
      *(outbuf + tmp___1) = (unsigned char )((int )bi_buf & 255);
#line 2294
      if (outcnt == 16384U) {
#line 2294
        flush_outbuf();
      }
#line 2294
      tmp___2 = outcnt;
#line 2294
      outcnt ++;
#line 2294
      *(outbuf + tmp___2) = (unsigned char )((int )bi_buf >> 8);
#line 2294
      if (outcnt == 16384U) {
#line 2294
        flush_outbuf();
      }
    }
  } else {
#line 2295
    if (bi_valid > 0) {
#line 2296
      tmp___3 = outcnt;
#line 2296
      outcnt ++;
#line 2296
      *(outbuf + tmp___3) = (unsigned char )bi_buf;
#line 2296
      if (outcnt == 16384U) {
#line 2296
        flush_outbuf();
      }
    }
  }
#line 2298
  bi_buf = (unsigned short)0;
#line 2299
  bi_valid = 0;
#line 2303
  return;
}
}
#line 2304 "D:/a/test/164.c"
void copy_block(char *buf , unsigned int len , int header ) 
{ unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 2309
  bi_windup();
#line 2310
  if (header) {
#line 2311
    if (outcnt < 16382U) {
#line 2311
      tmp = outcnt;
#line 2311
      outcnt ++;
#line 2311
      *(outbuf + tmp) = (unsigned char )((int )((unsigned short )len) & 255);
#line 2311
      tmp___0 = outcnt;
#line 2311
      outcnt ++;
#line 2311
      *(outbuf + tmp___0) = (unsigned char )((int )((unsigned short )len) >> 8);
    } else {
#line 2311
      tmp___1 = outcnt;
#line 2311
      outcnt ++;
#line 2311
      *(outbuf + tmp___1) = (unsigned char )((int )((unsigned short )len) & 255);
#line 2311
      if (outcnt == 16384U) {
#line 2311
        flush_outbuf();
      }
#line 2311
      tmp___2 = outcnt;
#line 2311
      outcnt ++;
#line 2311
      *(outbuf + tmp___2) = (unsigned char )((int )((unsigned short )len) >> 8);
#line 2311
      if (outcnt == 16384U) {
#line 2311
        flush_outbuf();
      }
    }
#line 2312
    if (outcnt < 16382U) {
#line 2312
      tmp___3 = outcnt;
#line 2312
      outcnt ++;
#line 2312
      *(outbuf + tmp___3) = (unsigned char )((int )((unsigned short )(~ len)) & 255);
#line 2312
      tmp___4 = outcnt;
#line 2312
      outcnt ++;
#line 2312
      *(outbuf + tmp___4) = (unsigned char )((int )((unsigned short )(~ len)) >> 8);
    } else {
#line 2312
      tmp___5 = outcnt;
#line 2312
      outcnt ++;
#line 2312
      *(outbuf + tmp___5) = (unsigned char )((int )((unsigned short )(~ len)) & 255);
#line 2312
      if (outcnt == 16384U) {
#line 2312
        flush_outbuf();
      }
#line 2312
      tmp___6 = outcnt;
#line 2312
      outcnt ++;
#line 2312
      *(outbuf + tmp___6) = (unsigned char )((int )((unsigned short )(~ len)) >> 8);
#line 2312
      if (outcnt == 16384U) {
#line 2312
        flush_outbuf();
      }
    }
  }
#line 2320
  while (1) {
#line 2320
    tmp___9 = len;
#line 2320
    len --;
#line 2320
    if (! tmp___9) {
#line 2320
      break;
    }
#line 2325
    tmp___7 = outcnt;
#line 2325
    outcnt ++;
#line 2325
    tmp___8 = buf;
#line 2325
    buf ++;
#line 2325
    *(outbuf + tmp___7) = (unsigned char )*tmp___8;
#line 2325
    if (outcnt == 16384U) {
#line 2325
      flush_outbuf();
    }
  }
#line 2327
  return;
}
}
#line 2359 "D:/a/test/164.c"
ulg window_size  =    65536UL;
#line 2360 "D:/a/test/164.c"
long block_start  ;
#line 2361 "D:/a/test/164.c"
static unsigned int ins_h  ;
#line 2363 "D:/a/test/164.c"
unsigned int prev_length  ;
#line 2364 "D:/a/test/164.c"
unsigned int strstart  ;
#line 2365 "D:/a/test/164.c"
unsigned int match_start  ;
#line 2366 "D:/a/test/164.c"
static int eofile  ;
#line 2367 "D:/a/test/164.c"
static unsigned int lookahead  ;
#line 2368 "D:/a/test/164.c"
unsigned int max_chain_length  ;
#line 2369 "D:/a/test/164.c"
static unsigned int max_lazy_match  ;
#line 2371 "D:/a/test/164.c"
static int compr_level  ;
#line 2372 "D:/a/test/164.c"
unsigned int good_match  ;
#line 2382 "D:/a/test/164.c"
int nice_match  ;
#line 2384 "D:/a/test/164.c"
static config configuration_table[10]  = 
#line 2384
  {      {(ush )0, (ush )0, (ush )0, (ush )0}, 
        {(ush )4, (ush )4, (ush )8, (ush )4}, 
        {(ush )4, (ush )5, (ush )16, (ush )8}, 
        {(ush )4, (ush )6, (ush )32, (ush )32}, 
        {(ush )4, (ush )4, (ush )16, (ush )16}, 
        {(ush )8, (ush )16, (ush )32, (ush )32}, 
        {(ush )8, (ush )16, (ush )128, (ush )128}, 
        {(ush )8, (ush )32, (ush )128, (ush )256}, 
        {(ush )32, (ush )128, (ush )258, (ush )1024}, 
        {(ush )32, (ush )258, (ush )258, (ush )4096}};
#line 2396
static void fill_window(void) ;
#line 2397
static ulg deflate_fast(void) ;
#line 2398
int longest_match(IPos cur_match ) ;
#line 2410 "D:/a/test/164.c"
void lm_init(int pack_level , ush *flags ) 
{ register unsigned int j___0 ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 2415
  if (pack_level < 1) {
#line 2415
    printf("bad pack level");
  } else {
#line 2415
    if (pack_level > 9) {
#line 2415
      printf("bad pack level");
    }
  }
#line 2416
  compr_level = pack_level;
#line 2420
  memset((void *)((char *)(prev + 32768)), 0, (unsigned int )(1 << 15) * sizeof(*(prev + 32768)));
#line 2422
  max_lazy_match = (unsigned int )configuration_table[pack_level].max_lazy;
#line 2423
  good_match = (unsigned int )configuration_table[pack_level].good_length;
#line 2425
  nice_match = (int )configuration_table[pack_level].nice_length;
#line 2427
  max_chain_length = (unsigned int )configuration_table[pack_level].max_chain;
#line 2428
  if (pack_level == 1) {
#line 2429
    *flags = (unsigned short )((int )*flags | 4);
  } else {
#line 2430
    if (pack_level == 9) {
#line 2431
      *flags = (unsigned short )((int )*flags | 2);
    }
  }
#line 2433
  strstart = 0U;
#line 2434
  block_start = 0L;
#line 2438
  if (sizeof(int ) <= 2U) {
#line 2438
    tmp = 32768U;
  } else {
#line 2438
    tmp = 65536U;
  }
#line 2438
  tmp___0 = (*read_buf)((char *)window, tmp);
#line 2438
  lookahead = (unsigned int )tmp___0;
#line 2440
  if (lookahead == 0U) {
#line 2441
    eofile = 1;
#line 2441
    lookahead = 0U;
#line 2442
    return;
  } else {
#line 2440
    if (lookahead == 4294967295U) {
#line 2441
      eofile = 1;
#line 2441
      lookahead = 0U;
#line 2442
      return;
    }
  }
#line 2444
  eofile = 0;
#line 2445
  while (1) {
#line 2445
    if (lookahead < 262U) {
#line 2445
      if (! (! eofile)) {
#line 2445
        break;
      }
    } else {
#line 2445
      break;
    }
#line 2445
    fill_window();
  }
#line 2446
  ins_h = 0U;
#line 2447
  j___0 = 0U;
#line 2447
  while (j___0 < 2U) {
#line 2447
    ins_h = ((ins_h << 5) ^ (unsigned int )*(window + j___0)) & ((unsigned int )(1 << 15) - 1U);
#line 2447
    j___0 ++;
  }
#line 2448
  return;
}
}
#line 2450 "D:/a/test/164.c"
int longest_match(IPos cur_match ) 
{ unsigned int chain_length ;
  register uch *scan ;
  register uch *match ;
  register int len ;
  int best_len ;
  IPos limit ;
  unsigned int tmp ;
  register uch *strend ;
  register uch scan_end1 ;
  register uch scan_end ;

  {
#line 2453
  chain_length = max_chain_length;
#line 2454
  scan = window + strstart;
#line 2457
  best_len = (int )prev_length;
#line 2458
  if (strstart > 32506U) {
#line 2458
    tmp = strstart - 32506U;
  } else {
#line 2458
    tmp = 0U;
  }
#line 2458
  limit = tmp;
#line 2468
  strend = (window + strstart) + 258;
#line 2469
  scan_end1 = *(scan + (best_len - 1));
#line 2470
  scan_end = *(scan + best_len);
#line 2472
  if (prev_length >= good_match) {
#line 2473
    chain_length >>= 2;
  }
#line 2476
  while (1) {
#line 2478
    match = window + cur_match;
#line 2495
    if ((int )*(match + best_len) != (int )scan_end) {
      goto __Cont;
    } else {
#line 2495
      if ((int )*(match + (best_len - 1)) != (int )scan_end1) {
        goto __Cont;
      } else {
#line 2495
        if ((int )*match != (int )*scan) {
          goto __Cont;
        } else {
#line 2495
          match ++;
#line 2495
          if ((int )*match != (int )*(scan + 1)) {
            goto __Cont;
          }
        }
      }
    }
#line 2499
    scan += 2;
#line 2499
    match ++;
#line 2500
    while (1) {
#line 2500
      scan ++;
#line 2500
      match ++;
#line 2500
      if ((int )*scan == (int )*match) {
#line 2500
        scan ++;
#line 2500
        match ++;
#line 2500
        if ((int )*scan == (int )*match) {
#line 2500
          scan ++;
#line 2500
          match ++;
#line 2500
          if ((int )*scan == (int )*match) {
#line 2500
            scan ++;
#line 2500
            match ++;
#line 2500
            if ((int )*scan == (int )*match) {
#line 2500
              scan ++;
#line 2500
              match ++;
#line 2500
              if ((int )*scan == (int )*match) {
#line 2500
                scan ++;
#line 2500
                match ++;
#line 2500
                if ((int )*scan == (int )*match) {
#line 2500
                  scan ++;
#line 2500
                  match ++;
#line 2500
                  if ((int )*scan == (int )*match) {
#line 2500
                    scan ++;
#line 2500
                    match ++;
#line 2500
                    if ((int )*scan == (int )*match) {
#line 2500
                      if (! ((unsigned int )scan < (unsigned int )strend)) {
#line 2500
                        break;
                      }
                    } else {
#line 2500
                      break;
                    }
                  } else {
#line 2500
                    break;
                  }
                } else {
#line 2500
                  break;
                }
              } else {
#line 2500
                break;
              }
            } else {
#line 2500
              break;
            }
          } else {
#line 2500
            break;
          }
        } else {
#line 2500
          break;
        }
      } else {
#line 2500
        break;
      }
    }
#line 2506
    len = 258 - (strend - scan);
#line 2507
    scan = strend - 258;
#line 2509
    if (len > best_len) {
#line 2510
      match_start = cur_match;
#line 2511
      best_len = len;
#line 2512
      if (len >= nice_match) {
#line 2512
        break;
      }
#line 2517
      scan_end1 = *(scan + (best_len - 1));
#line 2518
      scan_end = *(scan + best_len);
    }
    __Cont: /* CIL Label */ 
#line 2476
    cur_match = (unsigned int )*(prev + (cur_match & 32767U));
#line 2476
    if (cur_match > limit) {
#line 2476
      chain_length --;
#line 2476
      if (! (chain_length != 0U)) {
#line 2476
        break;
      }
    } else {
#line 2476
      break;
    }
  }
#line 2523
  return (best_len);
}
}
#line 2546 "D:/a/test/164.c"
static void fill_window(void) 
{ register unsigned int n ;
  register unsigned int m ;
  unsigned int more ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 2549
  more = (unsigned int )((window_size - (unsigned long )lookahead) - (unsigned long )strstart);
#line 2550
  if (more == 4294967295U) {
#line 2551
    more --;
  } else {
#line 2552
    if (strstart >= 65274U) {
#line 2554
      memcpy((void *)((char *)window), (void const   *)((char *)window + 32768), 32768U);
#line 2555
      match_start -= 32768U;
#line 2556
      strstart -= 32768U;
#line 2557
      block_start -= 32768L;
#line 2558
      n = 0U;
#line 2558
      while (n < (unsigned int )(1 << 15)) {
#line 2559
        m = (unsigned int )*((prev + 32768) + n);
#line 2560
        if (m >= 32768U) {
#line 2560
          tmp = m - 32768U;
        } else {
#line 2560
          tmp = 0U;
        }
#line 2560
        *((prev + 32768) + n) = (unsigned short )tmp;
#line 2558
        n ++;
      }
#line 2562
      n = 0U;
#line 2562
      while (n < 32768U) {
#line 2563
        m = (unsigned int )*(prev + n);
#line 2564
        if (m >= 32768U) {
#line 2564
          tmp___0 = m - 32768U;
        } else {
#line 2564
          tmp___0 = 0U;
        }
#line 2564
        *(prev + n) = (unsigned short )tmp___0;
#line 2562
        n ++;
      }
#line 2566
      more += 32768U;
    }
  }
#line 2568
  if (! eofile) {
#line 2569
    tmp___1 = (*read_buf)(((char *)window + strstart) + lookahead, more);
#line 2569
    n = (unsigned int )tmp___1;
#line 2570
    if (n == 0U) {
#line 2571
      eofile = 1;
    } else {
#line 2570
      if (n == 4294967295U) {
#line 2571
        eofile = 1;
      } else {
#line 2573
        lookahead += n;
      }
    }
  }
#line 2576
  return;
}
}
#line 2580 "D:/a/test/164.c"
static ulg deflate_fast(void) 
{ IPos hash_head ;
  int flush ;
  unsigned int match_length ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  ulg tmp___2 ;

  {
#line 2584
  match_length = 0U;
#line 2585
  prev_length = 2U;
#line 2586
  while (lookahead != 0U) {
#line 2587
    ins_h = ((ins_h << 5) ^ (unsigned int )*(window + ((strstart + 3U) - 1U))) & ((unsigned int )(1 << 15) - 1U);
#line 2587
    hash_head = (unsigned int )*((prev + 32768) + ins_h);
#line 2587
    *(prev + (strstart & 32767U)) = (unsigned short )hash_head;
#line 2587
    *((prev + 32768) + ins_h) = (unsigned short )strstart;
#line 2588
    if (hash_head != 0U) {
#line 2588
      if (strstart - hash_head <= 32506U) {
#line 2589
        tmp = longest_match(hash_head);
#line 2589
        match_length = (unsigned int )tmp;
#line 2590
        if (match_length > lookahead) {
#line 2590
          match_length = lookahead;
        }
      }
    }
#line 2592
    if (match_length >= 3U) {
#line 2594
      flush = ct_tally((int )(strstart - match_start), (int )(match_length - 3U));
#line 2595
      lookahead -= match_length;
#line 2597
      if (match_length <= max_lazy_match) {
#line 2598
        match_length --;
#line 2599
        while (1) {
#line 2600
          strstart ++;
#line 2601
          ins_h = ((ins_h << 5) ^ (unsigned int )*(window + ((strstart + 3U) - 1U))) & ((unsigned int )(1 << 15) - 1U);
#line 2601
          hash_head = (unsigned int )*((prev + 32768) + ins_h);
#line 2601
          *(prev + (strstart & 32767U)) = (unsigned short )hash_head;
#line 2601
          *((prev + 32768) + ins_h) = (unsigned short )strstart;
#line 2599
          match_length --;
#line 2599
          if (! (match_length != 0U)) {
#line 2599
            break;
          }
        }
#line 2603
        strstart ++;
      } else {
#line 2605
        strstart += match_length;
#line 2606
        match_length = 0U;
#line 2607
        ins_h = (unsigned int )*(window + strstart);
#line 2608
        ins_h = ((ins_h << 5) ^ (unsigned int )*(window + (strstart + 1U))) & ((unsigned int )(1 << 15) - 1U);
      }
    } else {
#line 2615
      flush = ct_tally(0, (int )*(window + strstart));
#line 2616
      lookahead --;
#line 2617
      strstart ++;
    }
#line 2619
    if (flush) {
#line 2619
      if (block_start >= 0L) {
#line 2619
        tmp___0 = (char *)(window + (unsigned int )block_start);
      } else {
#line 2619
        tmp___0 = (char *)((void *)0);
      }
#line 2619
      flush_block(tmp___0, (unsigned long )((long )strstart - block_start), 0);
#line 2619
      block_start = (long )strstart;
    }
#line 2620
    while (1) {
#line 2620
      if (lookahead < 262U) {
#line 2620
        if (! (! eofile)) {
#line 2620
          break;
        }
      } else {
#line 2620
        break;
      }
#line 2620
      fill_window();
    }
  }
#line 2622
  if (block_start >= 0L) {
#line 2622
    tmp___1 = (char *)(window + (unsigned int )block_start);
  } else {
#line 2622
    tmp___1 = (char *)((void *)0);
  }
#line 2622
  tmp___2 = flush_block(tmp___1, (unsigned long )((long )strstart - block_start),
                        1);
#line 2622
  return (tmp___2);
}
}
#line 2624 "D:/a/test/164.c"
ulg deflate(void) 
{ IPos hash_head ;
  IPos prev_match ;
  int flush ;
  int match_available ;
  register unsigned int match_length ;
  ulg tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  ulg tmp___5 ;

  {
#line 2629
  match_available = 0;
#line 2630
  match_length = 2U;
#line 2634
  if (compr_level <= 3) {
#line 2634
    tmp = deflate_fast();
#line 2634
    return (tmp);
  }
#line 2635
  while (lookahead != 0U) {
#line 2636
    ins_h = ((ins_h << 5) ^ (unsigned int )*(window + ((strstart + 3U) - 1U))) & ((unsigned int )(1 << 15) - 1U);
#line 2636
    hash_head = (unsigned int )*((prev + 32768) + ins_h);
#line 2636
    *(prev + (strstart & 32767U)) = (unsigned short )hash_head;
#line 2636
    *((prev + 32768) + ins_h) = (unsigned short )strstart;
#line 2637
    prev_length = match_length;
#line 2637
    prev_match = match_start;
#line 2638
    match_length = 2U;
#line 2639
    if (hash_head != 0U) {
#line 2639
      if (prev_length < max_lazy_match) {
#line 2639
        if (strstart - hash_head <= 32506U) {
#line 2641
          tmp___0 = longest_match(hash_head);
#line 2641
          match_length = (unsigned int )tmp___0;
#line 2642
          if (match_length > lookahead) {
#line 2642
            match_length = lookahead;
          }
#line 2643
          if (match_length == 3U) {
#line 2643
            if (strstart - match_start > 4096U) {
#line 2644
              match_length --;
            }
          }
        }
      }
    }
#line 2647
    if (prev_length >= 3U) {
#line 2647
      if (match_length <= prev_length) {
#line 2649
        flush = ct_tally((int )((strstart - 1U) - prev_match), (int )(prev_length - 3U));
#line 2650
        lookahead -= prev_length - 1U;
#line 2651
        prev_length -= 2U;
#line 2652
        while (1) {
#line 2653
          strstart ++;
#line 2654
          ins_h = ((ins_h << 5) ^ (unsigned int )*(window + ((strstart + 3U) - 1U))) & ((unsigned int )(1 << 15) - 1U);
#line 2654
          hash_head = (unsigned int )*((prev + 32768) + ins_h);
#line 2654
          *(prev + (strstart & 32767U)) = (unsigned short )hash_head;
#line 2654
          *((prev + 32768) + ins_h) = (unsigned short )strstart;
#line 2652
          prev_length --;
#line 2652
          if (! (prev_length != 0U)) {
#line 2652
            break;
          }
        }
#line 2656
        match_available = 0;
#line 2657
        match_length = 2U;
#line 2658
        strstart ++;
#line 2659
        if (flush) {
#line 2659
          if (block_start >= 0L) {
#line 2659
            tmp___1 = (char *)(window + (unsigned int )block_start);
          } else {
#line 2659
            tmp___1 = (char *)((void *)0);
          }
#line 2659
          flush_block(tmp___1, (unsigned long )((long )strstart - block_start), 0);
#line 2659
          block_start = (long )strstart;
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2660
      if (match_available) {
#line 2662
        tmp___3 = ct_tally(0, (int )*(window + (strstart - 1U)));
#line 2662
        if (tmp___3) {
#line 2663
          if (block_start >= 0L) {
#line 2663
            tmp___2 = (char *)(window + (unsigned int )block_start);
          } else {
#line 2663
            tmp___2 = (char *)((void *)0);
          }
#line 2663
          flush_block(tmp___2, (unsigned long )((long )strstart - block_start), 0);
#line 2663
          block_start = (long )strstart;
        }
#line 2665
        strstart ++;
#line 2666
        lookahead --;
      } else {
#line 2668
        match_available = 1;
#line 2669
        strstart ++;
#line 2670
        lookahead --;
      }
    }
#line 2673
    while (1) {
#line 2673
      if (lookahead < 262U) {
#line 2673
        if (! (! eofile)) {
#line 2673
          break;
        }
      } else {
#line 2673
        break;
      }
#line 2673
      fill_window();
    }
  }
#line 2675
  if (match_available) {
#line 2675
    ct_tally(0, (int )*(window + (strstart - 1U)));
  }
#line 2676
  if (block_start >= 0L) {
#line 2676
    tmp___4 = (char *)(window + (unsigned int )block_start);
  } else {
#line 2676
    tmp___4 = (char *)((void *)0);
  }
#line 2676
  tmp___5 = flush_block(tmp___4, (unsigned long )((long )strstart - block_start),
                        1);
#line 2676
  return (tmp___5);
}
}
#line 2694 "D:/a/test/164.c"
static enum __anonenum_ordering_22 ordering  ;
#line 2706
static int my_strlen(char const   *str ) ;
#line 2707
static char *my_index(char const   *str , int chr ) ;
#line 2711 "D:/a/test/164.c"
static int my_strlen(char const   *str ) 
{ int n ;
  char const   *tmp ;

  {
#line 2715
  n = 0;
#line 2716
  while (1) {
#line 2716
    tmp = str;
#line 2716
    str ++;
#line 2716
    if (! *tmp) {
#line 2716
      break;
    }
#line 2717
    n ++;
  }
#line 2718
  return (n);
}
}
#line 2720 "D:/a/test/164.c"
static char *my_index(char const   *str , int chr ) 
{ 

  {
#line 2725
  while (*str) {
#line 2727
    if ((int const   )*str == (int const   )chr) {
#line 2728
      return ((char *)str);
    }
#line 2729
    str ++;
  }
#line 2731
  return ((char *)0);
}
}
#line 2734 "D:/a/test/164.c"
static int first_nonopt  ;
#line 2735 "D:/a/test/164.c"
static int last_nonopt  ;
#line 2737
static void exchange(char **argv ) ;
#line 2739 "D:/a/test/164.c"
static void exchange(char **argv ) 
{ char *temp ;
  char **first ;
  char **last ;

  {
#line 2744
  first = argv + first_nonopt;
#line 2745
  last = argv + (optind - 1);
#line 2746
  while ((unsigned int )first < (unsigned int )last) {
#line 2747
    temp = *first;
#line 2747
    *first = *last;
#line 2747
    *last = temp;
#line 2747
    first ++;
#line 2747
    last --;
  }
#line 2749
  first = argv + first_nonopt;
#line 2750
  first_nonopt += optind - last_nonopt;
#line 2751
  last = argv + (first_nonopt - 1);
#line 2752
  while ((unsigned int )first < (unsigned int )last) {
#line 2753
    temp = *first;
#line 2753
    *first = *last;
#line 2753
    *last = temp;
#line 2753
    first ++;
#line 2753
    last --;
  }
#line 2755
  first = argv + first_nonopt;
#line 2756
  last_nonopt = optind;
#line 2757
  last = argv + (last_nonopt - 1);
#line 2758
  while ((unsigned int )first < (unsigned int )last) {
#line 2759
    temp = *first;
#line 2759
    *first = *last;
#line 2759
    *last = temp;
#line 2759
    first ++;
#line 2759
    last --;
  }
#line 2761
  return;
}
}
#line 2762 "D:/a/test/164.c"
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts___0 ,
                     int *longind , int long_only ) 
{ int option_index ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct option  const  *p ;
  char *s ;
  int exact ;
  int ambig ;
  struct option  const  *pfound ;
  int indfound ;
  int tmp___3 ;
  int tmp___4 ;
  struct _reent *tmp___5 ;
  int tmp___6 ;
  struct _reent *tmp___7 ;
  struct _reent *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct _reent *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  struct _reent *tmp___15 ;
  struct _reent *tmp___16 ;
  char *tmp___17 ;
  char c ;
  char *tmp___18 ;
  char *temp ;
  char *tmp___19 ;
  struct _reent *tmp___20 ;
  struct _reent *tmp___21 ;
  int tmp___22 ;

  {
#line 2772
  optarg = (char *)0;
#line 2773
  if (optind == 0) {
#line 2775
    optind = 1;
#line 2775
    last_nonopt = optind;
#line 2775
    first_nonopt = last_nonopt;
#line 2776
    nextchar = (char *)((void *)0);
#line 2777
    if ((int const   )*(optstring + 0) == 45) {
#line 2779
      ordering = (enum __anonenum_ordering_22 )2;
#line 2780
      optstring ++;
    } else {
#line 2782
      if ((int const   )*(optstring + 0) == 43) {
#line 2784
        ordering = (enum __anonenum_ordering_22 )0;
#line 2785
        optstring ++;
      } else {
#line 2787
        tmp = getenv("POSIXLY_CORRECT");
#line 2787
        if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 2788
          ordering = (enum __anonenum_ordering_22 )0;
        } else {
#line 2790
          ordering = (enum __anonenum_ordering_22 )1;
        }
      }
    }
  }
#line 2792
  if ((unsigned int )nextchar == (unsigned int )((void *)0)) {
    goto _L___2;
  } else {
#line 2792
    if ((int )*nextchar == 0) {
      _L___2: /* CIL Label */ 
#line 2794
      if ((unsigned int )ordering == 1U) {
#line 2797
        if (first_nonopt != last_nonopt) {
#line 2797
          if (last_nonopt != optind) {
#line 2798
            exchange((char **)argv);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 2799
          if (last_nonopt != optind) {
#line 2800
            first_nonopt = optind;
          }
        }
#line 2802
        while (1) {
#line 2802
          if (optind < argc) {
#line 2802
            if (! ((int )*(*(argv + optind) + 0) != 45)) {
#line 2802
              if (! ((int )*(*(argv + optind) + 1) == 0)) {
#line 2802
                break;
              }
            }
          } else {
#line 2802
            break;
          }
#line 2809
          optind ++;
        }
#line 2810
        last_nonopt = optind;
      }
#line 2812
      if (optind != argc) {
#line 2812
        tmp___0 = strcmp((char const   *)*(argv + optind), "--");
#line 2812
        if (! tmp___0) {
#line 2814
          optind ++;
#line 2815
          if (first_nonopt != last_nonopt) {
#line 2815
            if (last_nonopt != optind) {
#line 2816
              exchange((char **)argv);
            } else {
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 2817
            if (first_nonopt == last_nonopt) {
#line 2818
              first_nonopt = optind;
            }
          }
#line 2819
          last_nonopt = argc;
#line 2820
          optind = argc;
        }
      }
#line 2822
      if (optind == argc) {
#line 2825
        if (first_nonopt != last_nonopt) {
#line 2826
          optind = first_nonopt;
        }
#line 2827
        return (-1);
      }
#line 2829
      if ((int )*(*(argv + optind) + 0) != 45) {
        goto _L___1;
      } else {
#line 2829
        if ((int )*(*(argv + optind) + 1) == 0) {
          _L___1: /* CIL Label */ 
#line 2836
          if ((unsigned int )ordering == 0U) {
#line 2837
            return (-1);
          }
#line 2838
          tmp___1 = optind;
#line 2838
          optind ++;
#line 2838
          optarg = (char *)*(argv + tmp___1);
#line 2839
          return (1);
        }
      }
#line 2841
      if ((unsigned int )longopts___0 != (unsigned int )((void *)0)) {
#line 2841
        if ((int )*(*(argv + optind) + 1) == 45) {
#line 2841
          tmp___2 = 1;
        } else {
#line 2841
          tmp___2 = 0;
        }
      } else {
#line 2841
        tmp___2 = 0;
      }
#line 2841
      nextchar = (char *)((*(argv + optind) + 1) + tmp___2);
    }
  }
#line 2844
  if ((unsigned int )longopts___0 != (unsigned int )((void *)0)) {
#line 2844
    if ((int )*(*(argv + optind) + 0) == 45) {
#line 2844
      if ((int )*(*(argv + optind) + 1) == 45) {
        goto _L___4;
      } else {
#line 2844
        if (long_only) {
          _L___4: /* CIL Label */ 
#line 2853
          s = nextchar;
#line 2854
          exact = 0;
#line 2855
          ambig = 0;
#line 2856
          pfound = (struct option  const  *)((void *)0);
#line 2857
          indfound = 0;
#line 2858
          while (1) {
#line 2858
            if (*s) {
#line 2858
              if (! ((int )*s != 61)) {
#line 2858
                break;
              }
            } else {
#line 2858
              break;
            }
#line 2859
            s ++;
          }
#line 2860
          p = longopts___0;
#line 2860
          option_index = 0;
#line 2860
          while (p->name) {
#line 2862
            tmp___4 = strncmp((char const   *)p->name, (char const   *)nextchar, (unsigned int )(s - nextchar));
#line 2862
            if (! tmp___4) {
#line 2864
              tmp___3 = my_strlen((char const   *)p->name);
#line 2864
              if (s - nextchar == tmp___3) {
#line 2867
                pfound = p;
#line 2868
                indfound = option_index;
#line 2869
                exact = 1;
#line 2870
                break;
              } else {
#line 2872
                if ((unsigned int )pfound == (unsigned int )((void *)0)) {
#line 2875
                  pfound = p;
#line 2876
                  indfound = option_index;
                } else {
#line 2880
                  ambig = 1;
                }
              }
            }
#line 2860
            p ++;
#line 2860
            option_index ++;
          }
#line 2882
          if (ambig) {
#line 2882
            if (! exact) {
#line 2884
              if (opterr) {
#line 2885
                tmp___5 = __getreent();
#line 2885
                fprintf(tmp___5->_stderr, "%s: option `%s\' is ambiguous\n", *(argv + 0),
                        *(argv + optind));
              }
#line 2887
              tmp___6 = my_strlen((char const   *)nextchar);
#line 2887
              nextchar += tmp___6;
#line 2888
              optind ++;
#line 2889
              return ('\000');
            }
          }
#line 2891
          if ((unsigned int )pfound != (unsigned int )((void *)0)) {
#line 2893
            option_index = indfound;
#line 2894
            optind ++;
#line 2895
            if (*s) {
#line 2898
              if (pfound->has_arg) {
#line 2899
                optarg = s + 1;
              } else {
#line 2902
                if (opterr) {
#line 2904
                  if ((int )*(*(argv + (optind - 1)) + 1) == 45) {
#line 2906
                    tmp___7 = __getreent();
#line 2906
                    fprintf(tmp___7->_stderr, "%s: option `--%s\' doesn\'t allow an argument\n",
                            *(argv + 0), pfound->name);
                  } else {
#line 2911
                    tmp___8 = __getreent();
#line 2911
                    fprintf(tmp___8->_stderr, "%s: option `%c%s\' doesn\'t allow an argument\n",
                            *(argv + 0), *(*(argv + (optind - 1)) + 0), pfound->name);
                  }
                }
#line 2915
                tmp___9 = my_strlen((char const   *)nextchar);
#line 2915
                nextchar += tmp___9;
#line 2916
                return ('\000');
              }
            } else {
#line 2919
              if (pfound->has_arg == 1) {
#line 2921
                if (optind < argc) {
#line 2922
                  tmp___10 = optind;
#line 2922
                  optind ++;
#line 2922
                  optarg = (char *)*(argv + tmp___10);
                } else {
#line 2925
                  if (opterr) {
#line 2926
                    tmp___11 = __getreent();
#line 2926
                    fprintf(tmp___11->_stderr, "%s: option `%s\' requires an argument\n",
                            *(argv + 0), *(argv + (optind - 1)));
                  }
#line 2928
                  tmp___12 = my_strlen((char const   *)nextchar);
#line 2928
                  nextchar += tmp___12;
#line 2929
                  if ((int const   )*(optstring + 0) == 58) {
#line 2929
                    tmp___13 = ':';
                  } else {
#line 2929
                    tmp___13 = '\000';
                  }
#line 2929
                  return (tmp___13);
                }
              }
            }
#line 2932
            tmp___14 = my_strlen((char const   *)nextchar);
#line 2932
            nextchar += tmp___14;
#line 2933
            if ((unsigned int )longind != (unsigned int )((void *)0)) {
#line 2934
              *longind = option_index;
            }
#line 2935
            if (pfound->flag) {
#line 2937
              *(pfound->flag) = (int )pfound->val;
#line 2938
              return (0);
            }
#line 2940
            return ((int )pfound->val);
          }
#line 2942
          if (! long_only) {
            goto _L___3;
          } else {
#line 2942
            if ((int )*(*(argv + optind) + 1) == 45) {
              goto _L___3;
            } else {
#line 2942
              tmp___17 = my_index(optstring, (int )*nextchar);
#line 2942
              if ((unsigned int )tmp___17 == (unsigned int )((void *)0)) {
                _L___3: /* CIL Label */ 
#line 2948
                if (opterr) {
#line 2950
                  if ((int )*(*(argv + optind) + 1) == 45) {
#line 2952
                    tmp___15 = __getreent();
#line 2952
                    fprintf(tmp___15->_stderr, "%s: unrecognized option `--%s\'\n",
                            *(argv + 0), nextchar);
                  } else {
#line 2956
                    tmp___16 = __getreent();
#line 2956
                    fprintf(tmp___16->_stderr, "%s: unrecognized option `%c%s\'\n",
                            *(argv + 0), *(*(argv + optind) + 0), nextchar);
                  }
                }
#line 2959
                nextchar = (char *)"";
#line 2960
                optind ++;
#line 2961
                return ('\000');
              }
            }
          }
        }
      }
    }
  }
#line 2965
  tmp___18 = nextchar;
#line 2965
  nextchar ++;
#line 2965
  c = *tmp___18;
#line 2966
  tmp___19 = my_index(optstring, (int )c);
#line 2966
  temp = tmp___19;
#line 2967
  if ((int )*nextchar == 0) {
#line 2968
    optind ++;
  }
#line 2969
  if ((unsigned int )temp == (unsigned int )((void *)0)) {
    goto _L___5;
  } else {
#line 2969
    if ((int )c == 58) {
      _L___5: /* CIL Label */ 
#line 2971
      if (opterr) {
#line 2981
        tmp___20 = __getreent();
#line 2981
        fprintf(tmp___20->_stderr, "%s: illegal option -- %c\n", *(argv + 0), c);
      }
#line 2984
      optopt = (int )c;
#line 2985
      return ('\000');
    }
  }
#line 2987
  if ((int )*(temp + 1) == 58) {
#line 2989
    if ((int )*(temp + 2) == 58) {
#line 2992
      if ((int )*nextchar != 0) {
#line 2994
        optarg = nextchar;
#line 2995
        optind ++;
      } else {
#line 2998
        optarg = (char *)0;
      }
#line 2999
      nextchar = (char *)((void *)0);
    } else {
#line 3004
      if ((int )*nextchar != 0) {
#line 3006
        optarg = nextchar;
#line 3008
        optind ++;
      } else {
#line 3010
        if (optind == argc) {
#line 3012
          if (opterr) {
#line 3019
            tmp___21 = __getreent();
#line 3019
            fprintf(tmp___21->_stderr, "%s: option requires an argument -- %c\n",
                    *(argv + 0), c);
          }
#line 3023
          optopt = (int )c;
#line 3024
          if ((int const   )*(optstring + 0) == 58) {
#line 3025
            c = (char )':';
          } else {
#line 3027
            c = (char )'\000';
          }
        } else {
#line 3031
          tmp___22 = optind;
#line 3031
          optind ++;
#line 3031
          optarg = (char *)*(argv + tmp___22);
        }
      }
#line 3032
      nextchar = (char *)((void *)0);
    }
  }
#line 3035
  return ((int )c);
}
}
#line 3038 "D:/a/test/164.c"
int getopt(int argc , char * const  *argv , char const   *optstring ) 
{ int tmp ;

  {
#line 3044
  tmp = _getopt_internal(argc, argv, optstring, (struct option  const  *)0, (int *)0,
                         0);
#line 3044
  return (tmp);
}
}
#line 3049 "D:/a/test/164.c"
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                int *opt_index ) 
{ int tmp ;

  {
#line 3057
  tmp = _getopt_internal(argc, argv, options, long_options, opt_index, 0);
#line 3057
  return (tmp);
}
}
#line 3065 "D:/a/test/164.c"
int main(int argc , char **argv ) 
{ int file_count ;
  int proglen ;
  int optc ;
  size_t tmp ;
  int tmp___0 ;
  _sig_func_ptr tmp___1 ;
  _sig_func_ptr tmp___2 ;
  _sig_func_ptr tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  struct _reent *tmp___9 ;
  size_t tmp___10 ;
  struct _reent *tmp___11 ;
  struct _reent *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  int tmp___18 ;

  {
#line 3073
  progname = gzipbasename(*(argv + 0));
#line 3074
  if ((unsigned int )progname == (unsigned int )((char *)0)) {
#line 3075
    progname = (char *)"gzipbmk";
  }
#line 3077
  tmp = strlen((char const   *)progname);
#line 3077
  proglen = (int )tmp;
#line 3078
  if (proglen > 4) {
#line 3078
    tmp___0 = strcmp((char const   *)((progname + proglen) - 4), ".exe");
#line 3078
    if (tmp___0 == 0) {
#line 3079
      *(progname + (proglen - 4)) = (char )'\000';
    }
  }
#line 3081
  env = add_envopt(& argc, & argv, (char *)"GZIP");
#line 3082
  if ((unsigned int )env != (unsigned int )((void *)0)) {
#line 3082
    args = argv;
  }
#line 3083
  tmp___1 = signal(2, (void (*)(int  ))1);
#line 3083
  foreground = (unsigned int )tmp___1 != (unsigned int )((void (*)(int  ))1);
#line 3084
  if (foreground) {
#line 3085
    signal(2, (void (*)(int  ))(& abort_gzip));
  }
#line 3088
  tmp___2 = signal(15, (void (*)(int  ))1);
#line 3088
  if ((unsigned int )tmp___2 != (unsigned int )((void (*)(int  ))1)) {
#line 3089
    signal(15, (void (*)(int  ))(& abort_gzip));
  }
#line 3093
  tmp___3 = signal(1, (void (*)(int  ))1);
#line 3093
  if ((unsigned int )tmp___3 != (unsigned int )((void (*)(int  ))1)) {
#line 3094
    signal(1, (void (*)(int  ))(& abort_gzip));
  }
#line 3098
  tmp___6 = strncmp((char const   *)progname, "un", 2U);
#line 3098
  if (tmp___6 == 0) {
#line 3100
    decompress = 1;
  } else {
#line 3098
    tmp___7 = strncmp((char const   *)progname, "gun", 3U);
#line 3098
    if (tmp___7 == 0) {
#line 3100
      decompress = 1;
    } else {
#line 3101
      tmp___4 = strcmp((char const   *)(progname + 1), "cat");
#line 3101
      if (tmp___4 == 0) {
#line 3103
        to_stdout = 1;
#line 3103
        decompress = to_stdout;
      } else {
#line 3101
        tmp___5 = strcmp((char const   *)progname, "gzcat");
#line 3101
        if (tmp___5 == 0) {
#line 3103
          to_stdout = 1;
#line 3103
          decompress = to_stdout;
        }
      }
    }
  }
#line 3106
  strncpy(z_suffix, ".gz", sizeof(z_suffix) - 1U);
#line 3107
  tmp___8 = strlen((char const   *)(z_suffix));
#line 3107
  z_len = (int )tmp___8;
#line 3108
  while (1) {
#line 3108
    optc = getopt_long(argc, (char * const  *)argv, "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
                       (struct option  const  *)(longopts), (int *)0);
#line 3108
    if (! (optc != -1)) {
#line 3108
      break;
    }
#line 3110
    switch (optc) {
    case 97: 
#line 3112
    ascii = 1;
#line 3112
    break;
    case 98: 
#line 3114
    maxbits = atoi((char const   *)optarg);
#line 3115
    break;
    case 99: 
#line 3117
    to_stdout = 1;
#line 3117
    break;
    case 100: 
#line 3119
    decompress = 1;
#line 3119
    break;
    case 102: 
#line 3121
    force ++;
#line 3121
    break;
    case 104: 
    case 72: 
    case 63: 
#line 3123
    help();
#line 3123
    do_exit(0);
#line 3123
    break;
    case 108: 
#line 3125
    to_stdout = 1;
#line 3125
    decompress = to_stdout;
#line 3125
    list = decompress;
#line 3125
    break;
    case 76: 
#line 3127
    license();
#line 3127
    do_exit(0);
#line 3127
    break;
    case 109: 
#line 3129
    no_time = 1;
#line 3129
    break;
    case 77: 
#line 3131
    no_time = 0;
#line 3131
    break;
    case 110: 
#line 3133
    no_time = 1;
#line 3133
    no_name = no_time;
#line 3133
    break;
    case 78: 
#line 3135
    no_time = 0;
#line 3135
    no_name = no_time;
#line 3135
    break;
    case 113: 
#line 3137
    quiet = 1;
#line 3137
    verbose = 0;
#line 3137
    break;
    case 114: 
#line 3140
    tmp___9 = __getreent();
#line 3140
    fprintf(tmp___9->_stderr, "%s: -r not supported on this system\n", progname);
#line 3141
    usage();
#line 3142
    do_exit(1);
#line 3142
    break;
    case 83: 
#line 3150
    tmp___10 = strlen((char const   *)optarg);
#line 3150
    z_len = (int )tmp___10;
#line 3151
    strcpy(z_suffix, (char const   *)optarg);
#line 3152
    break;
    case 116: 
#line 3154
    to_stdout = 1;
#line 3154
    decompress = to_stdout;
#line 3154
    test = decompress;
#line 3155
    break;
    case 118: 
#line 3157
    verbose ++;
#line 3157
    quiet = 0;
#line 3157
    break;
    case 86: 
#line 3159
    version();
#line 3159
    do_exit(0);
#line 3159
    break;
    case 90: 
#line 3164
    tmp___11 = __getreent();
#line 3164
    fprintf(tmp___11->_stderr, "%s: -Z not supported in this version\n", progname);
#line 3166
    usage();
#line 3167
    do_exit(1);
#line 3167
    break;
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
#line 3171
    level = optc - 48;
#line 3172
    break;
    default: 
#line 3175
    usage();
#line 3176
    do_exit(1);
    }
  }
#line 3179
  if (no_time < 0) {
#line 3179
    no_time = decompress;
  }
#line 3180
  if (no_name < 0) {
#line 3180
    no_name = decompress;
  }
#line 3181
  file_count = argc - optind;
#line 3189
  if (z_len == 0) {
#line 3189
    if (! decompress) {
#line 3190
      tmp___12 = __getreent();
#line 3190
      fprintf(tmp___12->_stderr, "%s: incorrect suffix \'%s\'\n", progname, optarg);
#line 3192
      do_exit(1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 3189
    if (z_len > 30) {
#line 3190
      tmp___12 = __getreent();
#line 3190
      fprintf(tmp___12->_stderr, "%s: incorrect suffix \'%s\'\n", progname, optarg);
#line 3192
      do_exit(1);
    }
  }
#line 3194
  if (do_lzw) {
#line 3194
    if (! decompress) {
#line 3194
      work = & lzw;
    }
  }
#line 3195
  tmp___13 = malloc(16416U * (2U * sizeof(uch )));
#line 3195
  inbuf = (uch *)tmp___13;
#line 3195
  if ((unsigned int )inbuf == (unsigned int )((void *)0)) {
#line 3195
    error((char *)"insufficient memory");
  }
#line 3196
  tmp___14 = malloc(9216U * (2U * sizeof(uch )));
#line 3196
  outbuf = (uch *)tmp___14;
#line 3196
  if ((unsigned int )outbuf == (unsigned int )((void *)0)) {
#line 3196
    error((char *)"insufficient memory");
  }
#line 3197
  tmp___15 = malloc(16384U * (2U * sizeof(ush )));
#line 3197
  d_buf = (ush *)tmp___15;
#line 3197
  if ((unsigned int )d_buf == (unsigned int )((void *)0)) {
#line 3197
    error((char *)"insufficient memory");
  }
#line 3198
  tmp___16 = malloc(32768U * (2U * sizeof(uch )));
#line 3198
  window = (uch *)tmp___16;
#line 3198
  if ((unsigned int )window == (unsigned int )((void *)0)) {
#line 3198
    error((char *)"insufficient memory");
  }
#line 3200
  tmp___17 = malloc((unsigned int )(((1L << 16) + 1L) / 2L) * (2U * sizeof(ush )));
#line 3200
  prev = (ush *)tmp___17;
#line 3200
  if ((unsigned int )prev == (unsigned int )((void *)0)) {
#line 3200
    error((char *)"insufficient memory");
  }
#line 3205
  if (file_count != 0) {
#line 3206
    if (to_stdout) {
#line 3206
      if (! test) {
#line 3206
        if (! list) {
#line 3206
          if (! (! decompress)) {
#line 3206
            if (! ascii) {

            }
          }
        }
      }
    }
#line 3209
    while (optind < argc) {
#line 3210
      tmp___18 = optind;
#line 3210
      optind ++;
#line 3210
      treat_file(*(argv + tmp___18));
    }
  } else {
#line 3213
    treat_stdin();
  }
#line 3215
  if (list) {
#line 3215
    if (! quiet) {
#line 3215
      if (file_count > 1) {
#line 3216
        do_list(-1, -1);
      }
    }
  }
#line 3218
  do_exit(exit_code);
#line 3219
  return (exit_code);
}
}
#line 3222 "D:/a/test/164.c"
static void treat_stdin(void) 
{ struct _reent *tmp ;
  int tmp___0 ;
  struct _reent *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct _reent *tmp___4 ;
  struct _reent *tmp___5 ;
  struct _reent *tmp___6 ;

  {
#line 3234
  if (! decompress) {
#line 3234
    if (! ascii) {

    }
  }
#line 3237
  if (! test) {
#line 3237
    if (! list) {
#line 3237
      if (! (! decompress)) {
#line 3237
        if (! ascii) {

        }
      }
    }
  }
#line 3240
  strcpy(ifname, "stdin");
#line 3241
  strcpy(ofname, "stdout");
#line 3242
  time_stamp = 0L;
#line 3256
  ifile_size = -1L;
#line 3257
  clear_bufs();
#line 3258
  to_stdout = 1;
#line 3259
  part_nb = 0;
#line 3260
  if (decompress) {
#line 3261
    method = get_method(ifd);
#line 3262
    if (method < 0) {
#line 3263
      do_exit(exit_code);
    }
  }
#line 3266
  if (list) {
#line 3267
    do_list(ifd, method);
#line 3268
    return;
  }
#line 3270
  while (1) {
#line 3271
    tmp = __getreent();
#line 3271
    tmp___0 = fileno(tmp->_stdout);
#line 3271
    tmp___1 = __getreent();
#line 3271
    tmp___2 = fileno(tmp___1->_stdin);
#line 3271
    tmp___3 = (*work)(tmp___2, tmp___0);
#line 3271
    if (tmp___3 != 0) {
#line 3271
      return;
    }
#line 3272
    if (! decompress) {
#line 3272
      break;
    } else {
#line 3272
      if (last_member) {
#line 3272
        break;
      } else {
#line 3272
        if (inptr == insize) {
#line 3272
          break;
        }
      }
    }
#line 3274
    method = get_method(ifd);
#line 3275
    if (method < 0) {
#line 3275
      return;
    }
#line 3276
    bytes_out = 0L;
  }
#line 3278
  if (verbose) {
#line 3279
    if (test) {
#line 3280
      tmp___4 = __getreent();
#line 3280
      fprintf(tmp___4->_stderr, " OK\n");
    } else {
#line 3281
      if (! decompress) {
#line 3282
        tmp___5 = __getreent();
#line 3282
        display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, tmp___5->_stderr);
#line 3283
        tmp___6 = __getreent();
#line 3283
        fprintf(tmp___6->_stderr, "\n");
      }
    }
  }
#line 3291
  return;
}
}
#line 3389
extern int ( /* missing proto */  unlink)(char * a) ;
#line 3292 "D:/a/test/164.c"
static void treat_file(char *iname ) 
{ int cflag ;
  int tmp ;
  int tmp___0 ;
  struct _reent *tmp___1 ;
  struct _reent *tmp___2 ;
  int tmp___3 ;
  struct _reent *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct _reent *tmp___7 ;
  struct _reent *tmp___8 ;
  int tmp___9 ;
  struct _reent *tmp___10 ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  char const   *tmp___15 ;
  size_t tmp___16 ;
  struct _reent *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  struct _reent *tmp___20 ;
  struct _reent *tmp___21 ;
  struct _reent *tmp___22 ;
  struct _reent *tmp___23 ;
  struct _reent *tmp___24 ;

  {
#line 3295
  tmp = strcmp((char const   *)iname, "-");
#line 3295
  if (tmp == 0) {
#line 3296
    cflag = to_stdout;
#line 3297
    treat_stdin();
#line 3298
    to_stdout = cflag;
#line 3299
    return;
  }
#line 3301
  tmp___0 = get_istat(iname, & istat);
#line 3301
  if (tmp___0 != 0) {
#line 3301
    return;
  }
#line 3302
  if ((istat.st_mode & 61440U) == 16384U) {
#line 3314
    if (! quiet) {
#line 3314
      tmp___1 = __getreent();
#line 3314
      fprintf(tmp___1->_stderr, "%s: %s is a directory -- ignored\n", progname, ifname);
    }
#line 3314
    if (exit_code == 0) {
#line 3314
      exit_code = 2;
    }
#line 3315
    return;
  }
#line 3317
  if (! ((istat.st_mode & 61440U) == 32768U)) {
#line 3318
    if (! quiet) {
#line 3318
      tmp___2 = __getreent();
#line 3318
      fprintf(tmp___2->_stderr, "%s: %s is not a directory or a regular file - ignored\n",
              progname, ifname);
    }
#line 3318
    if (exit_code == 0) {
#line 3318
      exit_code = 2;
    }
#line 3321
    return;
  }
#line 3323
  if ((int )istat.st_nlink > 1) {
#line 3323
    if (! to_stdout) {
#line 3323
      if (! force) {
#line 3324
        if (! quiet) {
#line 3324
          if ((int )istat.st_nlink > 2) {
#line 3324
            tmp___3 = 's';
          } else {
#line 3324
            tmp___3 = ' ';
          }
#line 3324
          tmp___4 = __getreent();
#line 3324
          fprintf(tmp___4->_stderr, "%s: %s has %d other link%c -- unchanged\n", progname,
                  ifname, (int )istat.st_nlink - 1, tmp___3);
        }
#line 3324
        if (exit_code == 0) {
#line 3324
          exit_code = 2;
        }
#line 3327
        return;
      }
    }
  }
#line 3329
  ifile_size = (long )istat.st_size;
#line 3330
  if (no_time) {
#line 3330
    if (! list) {
#line 3330
      time_stamp = 0L;
    } else {
#line 3330
      time_stamp = istat.st_mtim.tv_sec;
    }
  } else {
#line 3330
    time_stamp = istat.st_mtim.tv_sec;
  }
#line 3331
  if (to_stdout) {
#line 3331
    if (! list) {
#line 3331
      if (! test) {
#line 3332
        strcpy(ofname, "stdout");
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 3333
    tmp___5 = make_ofname();
#line 3333
    if (tmp___5 != 0) {
#line 3334
      return;
    }
  }
#line 3336
  if (ascii) {
#line 3336
    if (! decompress) {
#line 3336
      tmp___6 = 0;
    } else {
#line 3336
      tmp___6 = 65536;
    }
  } else {
#line 3336
    tmp___6 = 65536;
  }
#line 3336
  ifd = open((char const   *)(ifname), tmp___6);
#line 3338
  if (ifd == -1) {
#line 3339
    tmp___7 = __getreent();
#line 3339
    fprintf(tmp___7->_stderr, "%s: ", progname);
#line 3340
    perror((char const   *)(ifname));
#line 3341
    exit_code = 1;
#line 3342
    return;
  }
#line 3344
  clear_bufs();
#line 3345
  part_nb = 0;
#line 3346
  if (decompress) {
#line 3347
    method = get_method(ifd);
#line 3348
    if (method < 0) {
#line 3349
      close(ifd);
#line 3350
      return;
    }
  }
#line 3353
  if (list) {
#line 3354
    do_list(ifd, method);
#line 3355
    close(ifd);
#line 3356
    return;
  }
#line 3358
  if (to_stdout) {
#line 3359
    tmp___8 = __getreent();
#line 3359
    ofd = fileno(tmp___8->_stdout);
  } else {
#line 3362
    tmp___9 = create_outfile();
#line 3362
    if (tmp___9 != 0) {
#line 3362
      return;
    }
#line 3363
    if (! decompress) {
#line 3363
      if (save_orig_name) {
#line 3363
        if (! verbose) {
#line 3363
          if (! quiet) {
#line 3364
            tmp___10 = __getreent();
#line 3364
            fprintf(tmp___10->_stderr, "%s: %s compressed to %s\n", progname, ifname,
                    ofname);
          }
        }
      }
    }
  }
#line 3368
  if (! save_orig_name) {
#line 3368
    save_orig_name = ! no_name;
  }
#line 3369
  if (verbose) {
#line 3370
    tmp___16 = strlen((char const   *)(ifname));
#line 3370
    if ((int )tmp___16 >= 15) {
#line 3370
      tmp___15 = "";
    } else {
#line 3370
      tmp___14 = strlen((char const   *)(ifname));
#line 3370
      if ((int )tmp___14 >= 7) {
#line 3370
        tmp___13 = "\t";
      } else {
#line 3370
        tmp___13 = "\t\t";
      }
#line 3370
      tmp___15 = tmp___13;
    }
#line 3370
    tmp___17 = __getreent();
#line 3370
    fprintf(tmp___17->_stderr, "%s:\t%s", ifname, tmp___15);
  }
#line 3373
  while (1) {
#line 3374
    tmp___18 = (*work)(ifd, ofd);
#line 3374
    if (tmp___18 != 0) {
#line 3375
      method = -1;
#line 3376
      break;
    }
#line 3378
    if (! decompress) {
#line 3378
      break;
    } else {
#line 3378
      if (last_member) {
#line 3378
        break;
      } else {
#line 3378
        if (inptr == insize) {
#line 3378
          break;
        }
      }
    }
#line 3380
    method = get_method(ifd);
#line 3381
    if (method < 0) {
#line 3381
      break;
    }
#line 3382
    bytes_out = 0L;
  }
#line 3384
  close(ifd);
#line 3385
  if (! to_stdout) {
#line 3385
    tmp___19 = close(ofd);
#line 3385
    if (tmp___19) {
#line 3386
      write_error();
    }
  }
#line 3388
  if (method == -1) {
#line 3389
    if (! to_stdout) {
#line 3389
      unlink(ofname);
    }
#line 3390
    return;
  }
#line 3392
  if (verbose) {
#line 3393
    if (test) {
#line 3394
      tmp___20 = __getreent();
#line 3394
      fprintf(tmp___20->_stderr, " OK");
    } else {
#line 3395
      if (decompress) {
#line 3396
        tmp___21 = __getreent();
#line 3396
        display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, tmp___21->_stderr);
      } else {
#line 3398
        tmp___22 = __getreent();
#line 3398
        display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, tmp___22->_stderr);
      }
    }
#line 3400
    if (! test) {
#line 3400
      if (! to_stdout) {
#line 3401
        tmp___23 = __getreent();
#line 3401
        fprintf(tmp___23->_stderr, " -- replaced with %s", ofname);
      }
    }
#line 3403
    tmp___24 = __getreent();
#line 3403
    fprintf(tmp___24->_stderr, "\n");
  }
#line 3405
  if (! to_stdout) {
#line 3406
    copy_stat(& istat);
  }
#line 3408
  return;
}
}
#line 3409 "D:/a/test/164.c"
static int create_outfile(void) 
{ struct stat ostat ;
  int flags ;
  int tmp ;
  struct _reent *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct _reent *tmp___3 ;

  {
#line 3412
  flags = 68097;
#line 3413
  if (ascii) {
#line 3413
    if (decompress) {
#line 3414
      flags &= -65537;
    }
  }
#line 3416
  while (1) {
#line 3418
    tmp = check_ofname();
#line 3418
    if (tmp != 0) {
#line 3419
      close(ifd);
#line 3420
      return (1);
    }
#line 3423
    remove_ofname = 1;
#line 3424
    ofd = open((char const   *)(ofname), flags);
#line 3425
    if (ofd == -1) {
#line 3426
      perror((char const   *)(ofname));
#line 3427
      close(ifd);
#line 3428
      exit_code = 1;
#line 3429
      return (1);
    }
#line 3435
    tmp___1 = fstat(ofd, & ostat);
#line 3435
    if (tmp___1 != 0) {
#line 3437
      tmp___0 = __getreent();
#line 3437
      fprintf(tmp___0->_stderr, "%s: ", progname);
#line 3438
      perror((char const   *)(ofname));
#line 3439
      close(ifd);
#line 3439
      close(ofd);
#line 3440
      unlink(ofname);
#line 3441
      exit_code = 1;
#line 3442
      return (1);
    }
#line 3444
    tmp___2 = name_too_long(ofname, & ostat);
#line 3444
    if (! tmp___2) {
#line 3444
      return (0);
    }
#line 3445
    if (decompress) {
#line 3447
      if (! quiet) {
#line 3447
        tmp___3 = __getreent();
#line 3447
        fprintf(tmp___3->_stderr, "%s: %s: warning, name truncated\n", progname, ofname);
      }
#line 3447
      if (exit_code == 0) {
#line 3447
        exit_code = 2;
      }
#line 3449
      return (0);
    }
#line 3451
    close(ofd);
#line 3452
    unlink(ofname);
#line 3458
    shorten_name(ofname);
  }
}
}
#line 3461 "D:/a/test/164.c"
static int do_stat(char *name , struct stat *sbuf ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 3465
  errno = 0;
#line 3467
  if (! to_stdout) {
#line 3467
    if (! force) {
#line 3468
      tmp = lstat((char const   *)name, sbuf);
#line 3468
      return (tmp);
    }
  }
#line 3471
  tmp___0 = stat((char const   *)name, sbuf);
#line 3471
  return (tmp___0);
}
}
#line 3478
static char *get_suffix(char *name ) ;
#line 3478 "D:/a/test/164.c"
static char *known_suffixes[9]  = 
#line 3478
  {      z_suffix,      (char *)".gz",      (char *)".z",      (char *)".taz", 
        (char *)".tgz",      (char *)"-gz",      (char *)"-z",      (char *)"_z", 
        (char *)((void *)0)};
#line 3473 "D:/a/test/164.c"
static char *get_suffix(char *name ) 
{ int nlen ;
  int slen ;
  char suffix[33] ;
  char **suf ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int s ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 3484
  suf = known_suffixes;
#line 3485
  tmp = strcmp((char const   *)(z_suffix), "z");
#line 3485
  if (tmp == 0) {
#line 3485
    suf ++;
  }
#line 3492
  tmp___0 = strlen((char const   *)name);
#line 3492
  nlen = (int )tmp___0;
#line 3493
  if (nlen <= 32) {
#line 3494
    strcpy(suffix, (char const   *)name);
  } else {
#line 3496
    strcpy(suffix, (char const   *)(((name + nlen) - 30) - 2));
  }
#line 3498
  strlwr(suffix);
#line 3499
  tmp___1 = strlen((char const   *)(suffix));
#line 3499
  slen = (int )tmp___1;
#line 3500
  while (1) {
#line 3501
    tmp___2 = strlen((char const   *)*suf);
#line 3501
    s = (int )tmp___2;
#line 3502
    if (slen > s) {
#line 3502
      if ((int )suffix[(slen - s) - 1] != 58) {
#line 3502
        tmp___3 = strcmp((char const   *)((suffix + slen) - s), (char const   *)*suf);
#line 3502
        if (tmp___3 == 0) {
#line 3504
          return ((name + nlen) - s);
        }
      }
    }
#line 3500
    suf ++;
#line 3500
    if (! ((unsigned int )*suf != (unsigned int )((void *)0))) {
#line 3500
      break;
    }
  }
#line 3507
  return ((char *)((void *)0));
}
}
#line 3514
static int get_istat(char *iname , struct stat *sbuf ) ;
#line 3514 "D:/a/test/164.c"
static char *suffixes[6]  = {      z_suffix,      (char *)".gz",      (char *)".z",      (char *)"-z", 
        (char *)".Z",      (char *)((void *)0)};
#line 3509 "D:/a/test/164.c"
static int get_istat(char *iname , struct stat *sbuf ) 
{ int ilen ;
  char **suf ;
  char *s ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3515
  suf = suffixes;
#line 3520
  strcpy(ifname, (char const   *)iname);
#line 3521
  tmp = do_stat(ifname, sbuf);
#line 3521
  if (tmp == 0) {
#line 3521
    return (0);
  }
#line 3522
  if (! decompress) {
#line 3523
    perror((char const   *)(ifname));
#line 3524
    exit_code = 1;
#line 3525
    return (1);
  }
#line 3527
  s = get_suffix(ifname);
#line 3528
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 3529
    perror((char const   *)(ifname));
#line 3530
    exit_code = 1;
#line 3531
    return (1);
  }
#line 3540
  tmp___0 = strlen((char const   *)(ifname));
#line 3540
  ilen = (int )tmp___0;
#line 3541
  tmp___1 = strcmp((char const   *)(z_suffix), ".gz");
#line 3541
  if (tmp___1 == 0) {
#line 3541
    suf ++;
  }
#line 3542
  while (1) {
#line 3543
    s = *suf;
#line 3552
    strcat(ifname, (char const   *)s);
#line 3553
    tmp___2 = do_stat(ifname, sbuf);
#line 3553
    if (tmp___2 == 0) {
#line 3553
      return (0);
    }
#line 3554
    ifname[ilen] = (char )'\000';
#line 3542
    suf ++;
#line 3542
    if (! ((unsigned int )*suf != (unsigned int )((void *)0))) {
#line 3542
      break;
    }
  }
#line 3561
  strcat(ifname, (char const   *)(z_suffix));
#line 3562
  perror((char const   *)(ifname));
#line 3563
  exit_code = 1;
#line 3564
  return (1);
}
}
#line 3566 "D:/a/test/164.c"
static int make_ofname(void) 
{ char *suff ;
  struct _reent *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct _reent *tmp___2 ;

  {
#line 3569
  strcpy(ofname, (char const   *)(ifname));
#line 3570
  suff = get_suffix(ofname);
#line 3571
  if (decompress) {
#line 3572
    if ((unsigned int )suff == (unsigned int )((void *)0)) {
#line 3574
      if (! recursive) {
#line 3574
        if (list) {
#line 3574
          return (0);
        } else {
#line 3574
          if (test) {
#line 3574
            return (0);
          }
        }
      }
#line 3576
      if (verbose) {
        goto _L;
      } else {
#line 3576
        if (! recursive) {
#line 3576
          if (! quiet) {
            _L: /* CIL Label */ 
#line 3577
            if (! quiet) {
#line 3577
              tmp = __getreent();
#line 3577
              fprintf(tmp->_stderr, "%s: %s: unknown suffix -- ignored\n", progname,
                      ifname);
            }
#line 3577
            if (exit_code == 0) {
#line 3577
              exit_code = 2;
            }
          }
        }
      }
#line 3580
      return (2);
    }
#line 3583
    strlwr(suff);
#line 3584
    tmp___0 = strcmp((char const   *)suff, ".tgz");
#line 3584
    if (tmp___0 == 0) {
#line 3585
      strcpy(suff, ".tar");
    } else {
#line 3584
      tmp___1 = strcmp((char const   *)suff, ".taz");
#line 3584
      if (tmp___1 == 0) {
#line 3585
        strcpy(suff, ".tar");
      } else {
#line 3587
        *suff = (char )'\000';
      }
    }
  } else {
#line 3589
    if ((unsigned int )suff != (unsigned int )((void *)0)) {
#line 3591
      if (verbose) {
#line 3592
        tmp___2 = __getreent();
#line 3592
        fprintf(tmp___2->_stderr, "%s: %s already has %s suffix -- unchanged\n", progname,
                ifname, suff);
      } else {
#line 3591
        if (! recursive) {
#line 3591
          if (! quiet) {
#line 3592
            tmp___2 = __getreent();
#line 3592
            fprintf(tmp___2->_stderr, "%s: %s already has %s suffix -- unchanged\n",
                    progname, ifname, suff);
          }
        }
      }
#line 3595
      if (exit_code == 0) {
#line 3595
        exit_code = 2;
      }
#line 3596
      return (2);
    } else {
#line 3598
      save_orig_name = 0;
#line 3614
      strcat(ofname, (char const   *)(z_suffix));
    }
  }
#line 3616
  return (0);
}
}
#line 3618 "D:/a/test/164.c"
int get_method(int in ) 
{ uch flags ;
  char magic[2] ;
  ulg stamp ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  struct _reent *tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  struct _reent *tmp___18 ;
  struct _reent *tmp___19 ;
  struct _reent *tmp___20 ;
  unsigned int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  unsigned int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int part ;
  unsigned int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  unsigned int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  struct _reent *tmp___41 ;
  unsigned int len ;
  unsigned int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  unsigned int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  struct _reent *tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  char c ;
  unsigned int tmp___51 ;
  int tmp___52 ;
  char *p ;
  char *tmp___53 ;
  char *base ;
  unsigned int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char *tmp___57 ;
  unsigned int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  struct _reent *tmp___69 ;
  struct _reent *tmp___70 ;

  {
#line 3624
  if (force) {
#line 3624
    if (to_stdout) {
#line 3625
      if (inptr < insize) {
#line 3625
        tmp = inptr;
#line 3625
        inptr ++;
#line 3625
        tmp___1 = (int )*(inbuf + tmp);
      } else {
#line 3625
        tmp___0 = fill_inbuf(1);
#line 3625
        tmp___1 = tmp___0;
      }
#line 3625
      magic[0] = (char )tmp___1;
#line 3626
      if (inptr < insize) {
#line 3626
        tmp___2 = inptr;
#line 3626
        inptr ++;
#line 3626
        tmp___4 = (int )*(inbuf + tmp___2);
      } else {
#line 3626
        tmp___3 = fill_inbuf(1);
#line 3626
        tmp___4 = tmp___3;
      }
#line 3626
      magic[1] = (char )tmp___4;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 3629
    if (inptr < insize) {
#line 3629
      tmp___5 = inptr;
#line 3629
      inptr ++;
#line 3629
      tmp___7 = (int )*(inbuf + tmp___5);
    } else {
#line 3629
      tmp___6 = fill_inbuf(0);
#line 3629
      tmp___7 = tmp___6;
    }
#line 3629
    magic[0] = (char )tmp___7;
#line 3630
    if (inptr < insize) {
#line 3630
      tmp___8 = inptr;
#line 3630
      inptr ++;
#line 3630
      tmp___10 = (int )*(inbuf + tmp___8);
    } else {
#line 3630
      tmp___9 = fill_inbuf(0);
#line 3630
      tmp___10 = tmp___9;
    }
#line 3630
    magic[1] = (char )tmp___10;
  }
#line 3632
  method = -1;
#line 3633
  part_nb ++;
#line 3634
  header_bytes = 0L;
#line 3635
  last_member = 0;
#line 3636
  tmp___67 = memcmp((void const   *)(magic), (void const   *)"\037\213", 2U);
#line 3636
  if (tmp___67 == 0) {
    goto _L___4;
  } else {
#line 3636
    tmp___68 = memcmp((void const   *)(magic), (void const   *)"\037\236", 2U);
#line 3636
    if (tmp___68 == 0) {
      _L___4: /* CIL Label */ 
#line 3638
      if (inptr < insize) {
#line 3638
        tmp___11 = inptr;
#line 3638
        inptr ++;
#line 3638
        tmp___13 = (int )*(inbuf + tmp___11);
      } else {
#line 3638
        tmp___12 = fill_inbuf(0);
#line 3638
        tmp___13 = tmp___12;
      }
#line 3638
      method = tmp___13;
#line 3639
      if (method != 8) {
#line 3640
        tmp___14 = __getreent();
#line 3640
        fprintf(tmp___14->_stderr, "%s: %s: unknown method %d -- get newer version of gzip\n",
                progname, ifname, method);
#line 3643
        exit_code = 1;
#line 3644
        return (-1);
      }
#line 3646
      work = & unzip;
#line 3647
      if (inptr < insize) {
#line 3647
        tmp___15 = inptr;
#line 3647
        inptr ++;
#line 3647
        tmp___17 = (int )*(inbuf + tmp___15);
      } else {
#line 3647
        tmp___16 = fill_inbuf(0);
#line 3647
        tmp___17 = tmp___16;
      }
#line 3647
      flags = (unsigned char )tmp___17;
#line 3648
      if (((int )flags & 32) != 0) {
#line 3649
        tmp___18 = __getreent();
#line 3649
        fprintf(tmp___18->_stderr, "%s: %s is encrypted -- get newer version of gzip\n",
                progname, ifname);
#line 3652
        exit_code = 1;
#line 3653
        return (-1);
      }
#line 3655
      if (((int )flags & 2) != 0) {
#line 3656
        tmp___19 = __getreent();
#line 3656
        fprintf(tmp___19->_stderr, "%s: %s is a a multi-part gzip file -- get newer version of gzip\n",
                progname, ifname);
#line 3659
        exit_code = 1;
#line 3660
        if (force <= 1) {
#line 3660
          return (-1);
        }
      }
#line 3662
      if (((int )flags & 192) != 0) {
#line 3663
        tmp___20 = __getreent();
#line 3663
        fprintf(tmp___20->_stderr, "%s: %s has flags 0x%x -- get newer version of gzip\n",
                progname, ifname, flags);
#line 3666
        exit_code = 1;
#line 3667
        if (force <= 1) {
#line 3667
          return (-1);
        }
      }
#line 3669
      if (inptr < insize) {
#line 3669
        tmp___21 = inptr;
#line 3669
        inptr ++;
#line 3669
        tmp___23 = (int )*(inbuf + tmp___21);
      } else {
#line 3669
        tmp___22 = fill_inbuf(0);
#line 3669
        tmp___23 = tmp___22;
      }
#line 3669
      stamp = (unsigned long )tmp___23;
#line 3670
      if (inptr < insize) {
#line 3670
        tmp___24 = inptr;
#line 3670
        inptr ++;
#line 3670
        tmp___26 = (int )*(inbuf + tmp___24);
      } else {
#line 3670
        tmp___25 = fill_inbuf(0);
#line 3670
        tmp___26 = tmp___25;
      }
#line 3670
      stamp |= (unsigned long )tmp___26 << 8;
#line 3671
      if (inptr < insize) {
#line 3671
        tmp___27 = inptr;
#line 3671
        inptr ++;
#line 3671
        tmp___29 = (int )*(inbuf + tmp___27);
      } else {
#line 3671
        tmp___28 = fill_inbuf(0);
#line 3671
        tmp___29 = tmp___28;
      }
#line 3671
      stamp |= (unsigned long )tmp___29 << 16;
#line 3672
      if (inptr < insize) {
#line 3672
        tmp___30 = inptr;
#line 3672
        inptr ++;
#line 3672
        tmp___32 = (int )*(inbuf + tmp___30);
      } else {
#line 3672
        tmp___31 = fill_inbuf(0);
#line 3672
        tmp___32 = tmp___31;
      }
#line 3672
      stamp |= (unsigned long )tmp___32 << 24;
#line 3673
      if (stamp != 0UL) {
#line 3673
        if (! no_time) {
#line 3673
          time_stamp = (long )stamp;
        }
      }
#line 3674
      if (inptr < insize) {
#line 3674
        tmp___33 = inptr;
#line 3674
        inptr ++;
      } else {
#line 3674
        fill_inbuf(0);
      }
#line 3675
      if (inptr < insize) {
#line 3675
        tmp___34 = inptr;
#line 3675
        inptr ++;
      } else {
#line 3675
        fill_inbuf(0);
      }
#line 3676
      if (((int )flags & 2) != 0) {
#line 3677
        if (inptr < insize) {
#line 3677
          tmp___35 = inptr;
#line 3677
          inptr ++;
#line 3677
          tmp___37 = (int )*(inbuf + tmp___35);
        } else {
#line 3677
          tmp___36 = fill_inbuf(0);
#line 3677
          tmp___37 = tmp___36;
        }
#line 3677
        part = (unsigned int )tmp___37;
#line 3678
        if (inptr < insize) {
#line 3678
          tmp___38 = inptr;
#line 3678
          inptr ++;
#line 3678
          tmp___40 = (int )*(inbuf + tmp___38);
        } else {
#line 3678
          tmp___39 = fill_inbuf(0);
#line 3678
          tmp___40 = tmp___39;
        }
#line 3678
        part |= (unsigned int )tmp___40 << 8;
#line 3679
        if (verbose) {
#line 3680
          tmp___41 = __getreent();
#line 3680
          fprintf(tmp___41->_stderr, "%s: %s: part number %u\n", progname, ifname,
                  part);
        }
      }
#line 3684
      if (((int )flags & 4) != 0) {
#line 3685
        if (inptr < insize) {
#line 3685
          tmp___42 = inptr;
#line 3685
          inptr ++;
#line 3685
          tmp___44 = (int )*(inbuf + tmp___42);
        } else {
#line 3685
          tmp___43 = fill_inbuf(0);
#line 3685
          tmp___44 = tmp___43;
        }
#line 3685
        len = (unsigned int )tmp___44;
#line 3686
        if (inptr < insize) {
#line 3686
          tmp___45 = inptr;
#line 3686
          inptr ++;
#line 3686
          tmp___47 = (int )*(inbuf + tmp___45);
        } else {
#line 3686
          tmp___46 = fill_inbuf(0);
#line 3686
          tmp___47 = tmp___46;
        }
#line 3686
        len |= (unsigned int )tmp___47 << 8;
#line 3687
        if (verbose) {
#line 3688
          tmp___48 = __getreent();
#line 3688
          fprintf(tmp___48->_stderr, "%s: %s: extra field of %u bytes ignored\n",
                  progname, ifname, len);
        }
#line 3691
        while (1) {
#line 3691
          tmp___50 = len;
#line 3691
          len --;
#line 3691
          if (! tmp___50) {
#line 3691
            break;
          }
#line 3691
          if (inptr < insize) {
#line 3691
            tmp___49 = inptr;
#line 3691
            inptr ++;
          } else {
#line 3691
            fill_inbuf(0);
          }
        }
      }
#line 3694
      if (((int )flags & 8) != 0) {
#line 3695
        if (no_name) {
          goto _L___0;
        } else {
#line 3695
          if (to_stdout) {
#line 3695
            if (! list) {
              goto _L___0;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 3695
            if (part_nb > 1) {
              _L___0: /* CIL Label */ 
#line 3698
              while (1) {
#line 3698
                if (inptr < insize) {
#line 3698
                  tmp___51 = inptr;
#line 3698
                  inptr ++;
#line 3698
                  c = (char )*(inbuf + tmp___51);
                } else {
#line 3698
                  tmp___52 = fill_inbuf(0);
#line 3698
                  c = (char )tmp___52;
                }
#line 3698
                if (! ((int )c != 0)) {
#line 3698
                  break;
                }
              }
            } else {
#line 3701
              tmp___53 = gzipbasename(ofname);
#line 3701
              p = tmp___53;
#line 3702
              base = p;
#line 3703
              while (1) {
#line 3704
                if (inptr < insize) {
#line 3704
                  tmp___54 = inptr;
#line 3704
                  inptr ++;
#line 3704
                  tmp___56 = (int )*(inbuf + tmp___54);
                } else {
#line 3704
                  tmp___55 = fill_inbuf(0);
#line 3704
                  tmp___56 = tmp___55;
                }
#line 3704
                *p = (char )tmp___56;
#line 3705
                tmp___57 = p;
#line 3705
                p ++;
#line 3705
                if ((int )*tmp___57 == 0) {
#line 3705
                  break;
                }
#line 3706
                if ((unsigned int )p >= (unsigned int )(ofname + sizeof(ofname))) {
#line 3707
                  error((char *)"corrupted input -- file name too large");
                }
              }
#line 3710
              if (! list) {
#line 3712
                if (base) {
#line 3712
                  list = 0;
                }
              }
            }
          }
        }
      }
#line 3717
      if (((int )flags & 16) != 0) {
#line 3718
        while (1) {
#line 3718
          if (inptr < insize) {
#line 3718
            tmp___58 = inptr;
#line 3718
            inptr ++;
#line 3718
            tmp___60 = (int )*(inbuf + tmp___58);
          } else {
#line 3718
            tmp___59 = fill_inbuf(0);
#line 3718
            tmp___60 = tmp___59;
          }
#line 3718
          if (! (tmp___60 != 0)) {
#line 3718
            break;
          }
        }
      }
#line 3720
      if (part_nb == 1) {
#line 3721
        header_bytes = (long )(inptr + 2U * sizeof(long ));
      }
    } else {
#line 3723
      tmp___65 = memcmp((void const   *)(magic), (void const   *)"PK\003\004", 2U);
#line 3723
      if (tmp___65 == 0) {
#line 3723
        if (inptr == 2U) {
#line 3723
          tmp___66 = memcmp((void const   *)((char *)inbuf), (void const   *)"PK\003\004",
                            4U);
#line 3723
          if (tmp___66 == 0) {
#line 3726
            inptr = 0U;
#line 3727
            work = & unzip;
#line 3728
            tmp___61 = check_zipfile(in);
#line 3728
            if (tmp___61 != 0) {
#line 3728
              return (-1);
            }
#line 3730
            last_member = 1;
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 3731
        tmp___64 = memcmp((void const   *)(magic), (void const   *)"\037\036", 2U);
#line 3731
        if (tmp___64 == 0) {
#line 3732
          work = & unpack;
#line 3733
          method = 2;
        } else {
#line 3734
          tmp___63 = memcmp((void const   *)(magic), (void const   *)"\037\235", 2U);
#line 3734
          if (tmp___63 == 0) {
#line 3735
            work = & unlzw;
#line 3736
            method = 1;
#line 3737
            last_member = 1;
          } else {
#line 3738
            tmp___62 = memcmp((void const   *)(magic), (void const   *)"\037\240",
                              2U);
#line 3738
            if (tmp___62 == 0) {
#line 3739
              work = & unlzh;
#line 3740
              method = 3;
#line 3741
              last_member = 1;
            } else {
#line 3742
              if (force) {
#line 3742
                if (to_stdout) {
#line 3742
                  if (! list) {
#line 3743
                    method = 0;
#line 3744
                    work = & copy;
#line 3745
                    inptr = 0U;
#line 3746
                    last_member = 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3748
  if (method >= 0) {
#line 3748
    return (method);
  }
#line 3749
  if (part_nb == 1) {
#line 3750
    tmp___69 = __getreent();
#line 3750
    fprintf(tmp___69->_stderr, "\n%s: %s: not in gzip format\n", progname, ifname);
#line 3751
    exit_code = 1;
#line 3752
    return (-1);
  } else {
#line 3754
    if (! quiet) {
#line 3754
      tmp___70 = __getreent();
#line 3754
      fprintf(tmp___70->_stderr, "\n%s: %s: decompression OK, trailing garbage ignored\n",
              progname, ifname);
    }
#line 3754
    if (exit_code == 0) {
#line 3754
      exit_code = 2;
    }
#line 3756
    return (-2);
  }
}
}
#line 3764
static void do_list(int ifd___0 , int method___0 ) ;
#line 3764 "D:/a/test/164.c"
static int first_time  =    1;
#line 3765
static void do_list(int ifd___0 , int method___0 ) ;
#line 3765 "D:/a/test/164.c"
static char *methods[9]  = 
#line 3765
  {      (char *)"store",      (char *)"compr",      (char *)"pack ",      (char *)"lzh  ", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"defla"};
#line 3759 "D:/a/test/164.c"
static void do_list(int ifd___0 , int method___0 ) 
{ ulg crc___1 ;
  char *date ;
  struct _reent *tmp ;
  off_t tmp___0 ;
  uch buf[8] ;
  int tmp___1 ;
  char *tmp___2 ;
  struct _reent *tmp___3 ;

  {
#line 3773
  if (first_time) {
#line 3773
    if (method___0 >= 0) {
#line 3774
      first_time = 0;
#line 3775
      if (verbose) {
#line 3776
        printf("method  crc     date  time  ");
      }
#line 3778
      if (! quiet) {
#line 3779
        printf("compressed  uncompr. ratio uncompressed_name\n");
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 3781
    if (method___0 < 0) {
#line 3782
      if (total_in <= 0L) {
#line 3782
        return;
      } else {
#line 3782
        if (total_out <= 0L) {
#line 3782
          return;
        }
      }
#line 3783
      if (verbose) {
#line 3784
        printf("                            %9lu %9lu ", total_in, total_out);
      } else {
#line 3786
        if (! quiet) {
#line 3787
          printf("%9ld %9ld ", total_in, total_out);
        }
      }
#line 3789
      tmp = __getreent();
#line 3789
      display_ratio(total_out - (total_in - header_bytes), total_out, tmp->_stdout);
#line 3791
      printf(" (totals)\n");
#line 3792
      return;
    }
  }
#line 3794
  crc___1 = (unsigned long )(~ 0);
#line 3795
  bytes_out = -1L;
#line 3796
  bytes_in = ifile_size;
#line 3798
  if (method___0 == 8) {
#line 3798
    if (! last_member) {
#line 3799
      tmp___0 = lseek(ifd___0, -8LL, 2);
#line 3799
      bytes_in = (long )tmp___0;
#line 3800
      if (bytes_in != -1L) {
#line 3802
        bytes_in += 8L;
#line 3803
        tmp___1 = spec_read(ifd___0, (unsigned char *)((char *)(buf)), (int )sizeof(buf));
#line 3803
        if ((unsigned int )tmp___1 != sizeof(buf)) {
#line 3804
          read_error();
        }
#line 3806
        crc___1 = (unsigned long )((int )((unsigned short )buf[0]) | ((int )((unsigned short )buf[1]) << 8)) | ((unsigned long )((int )((unsigned short )*((buf + 2) + 0)) | ((int )((unsigned short )*((buf + 2) + 1)) << 8)) << 16);
#line 3807
        bytes_out = (long )((unsigned long )((int )((unsigned short )*((buf + 4) + 0)) | ((int )((unsigned short )*((buf + 4) + 1)) << 8)) | ((unsigned long )((int )((unsigned short )*(((buf + 4) + 2) + 0)) | ((int )((unsigned short )*(((buf + 4) + 2) + 1)) << 8)) << 16));
      }
    }
  }
#line 3811
  tmp___2 = ctime((time_t const   *)(& time_stamp));
#line 3811
  date = tmp___2 + 4;
#line 3812
  *(date + 12) = (char )'\000';
#line 3813
  if (verbose) {
#line 3814
    printf("%5s %08lx %11s ", methods[method___0], crc___1, date);
  }
#line 3816
  printf("%9ld %9ld ", bytes_in, bytes_out);
#line 3817
  if (bytes_in == -1L) {
#line 3818
    total_in = -1L;
#line 3819
    header_bytes = 0L;
#line 3819
    bytes_out = header_bytes;
#line 3819
    bytes_in = bytes_out;
  } else {
#line 3820
    if (total_in >= 0L) {
#line 3821
      total_in += bytes_in;
    }
  }
#line 3823
  if (bytes_out == -1L) {
#line 3824
    total_out = -1L;
#line 3825
    header_bytes = 0L;
#line 3825
    bytes_out = header_bytes;
#line 3825
    bytes_in = bytes_out;
  } else {
#line 3826
    if (total_out >= 0L) {
#line 3827
      total_out += bytes_out;
    }
  }
#line 3829
  tmp___3 = __getreent();
#line 3829
  display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, tmp___3->_stdout);
#line 3830
  printf(" %s\n", ofname);
#line 3831
  return;
}
}
#line 3832 "D:/a/test/164.c"
static int same_file(struct stat *stat1 , struct stat *stat2 ) 
{ int tmp ;

  {
#line 3836
  if (stat1->st_ino == stat2->st_ino) {
#line 3836
    if (stat1->st_dev == stat2->st_dev) {
#line 3836
      tmp = 1;
    } else {
#line 3836
      tmp = 0;
    }
  } else {
#line 3836
    tmp = 0;
  }
#line 3836
  return (tmp);
}
}
#line 3849 "D:/a/test/164.c"
static int name_too_long(char *name , struct stat *statb ) 
{ int s ;
  size_t tmp ;
  char c ;
  struct stat tstat ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3853
  tmp = strlen((char const   *)name);
#line 3853
  s = (int )tmp;
#line 3854
  c = *(name + (s - 1));
#line 3857
  tstat = *statb;
#line 3858
  *(name + (s - 1)) = (char )'\000';
#line 3859
  tmp___0 = stat((char const   *)name, & tstat);
#line 3859
  if (tmp___0 == 0) {
#line 3859
    tmp___1 = same_file(statb, & tstat);
#line 3859
    if (tmp___1) {
#line 3859
      tmp___2 = 1;
    } else {
#line 3859
      tmp___2 = 0;
    }
  } else {
#line 3859
    tmp___2 = 0;
  }
#line 3859
  res = tmp___2;
#line 3860
  *(name + (s - 1)) = c;
#line 3862
  return (res);
}
}
#line 3864 "D:/a/test/164.c"
static void shorten_name(char *name ) 
{ int len ;
  char *trunc___0 ;
  int plen ;
  int min_part ;
  char *p ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 3868
  trunc___0 = (char *)((void *)0);
#line 3870
  min_part = 3;
#line 3872
  tmp = strlen((char const   *)name);
#line 3872
  len = (int )tmp;
#line 3873
  if (decompress) {
#line 3874
    if (len <= 1) {
#line 3874
      error((char *)"name too short");
    }
#line 3875
    *(name + (len - 1)) = (char )'\000';
#line 3876
    return;
  }
#line 3878
  p = get_suffix(name);
#line 3879
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 3879
    error((char *)"can\'t recover suffix\n");
  }
#line 3880
  *p = (char )'\000';
#line 3881
  save_orig_name = 1;
#line 3882
  if (len > 4) {
#line 3882
    tmp___0 = strcmp((char const   *)(p - 4), ".tar");
#line 3882
    if (tmp___0 == 0) {
#line 3883
      strcpy(p - 4, ".tgz");
#line 3884
      return;
    }
  }
#line 3886
  while (1) {
#line 3887
    p = strrchr((char const   *)name, ':');
#line 3888
    if (p) {
#line 3888
      p ++;
    } else {
#line 3888
      p = name;
    }
#line 3889
    while (*p) {
#line 3890
      tmp___1 = strcspn((char const   *)p, ".");
#line 3890
      plen = (int )tmp___1;
#line 3891
      p += plen;
#line 3892
      if (plen > min_part) {
#line 3892
        trunc___0 = p - 1;
      }
#line 3893
      if (*p) {
#line 3893
        p ++;
      }
    }
#line 3886
    if ((unsigned int )trunc___0 == (unsigned int )((void *)0)) {
#line 3886
      min_part --;
#line 3886
      if (! (min_part != 0)) {
#line 3886
        break;
      }
    } else {
#line 3886
      break;
    }
  }
#line 3896
  if ((unsigned int )trunc___0 != (unsigned int )((void *)0)) {
#line 3897
    while (1) {
#line 3898
      *(trunc___0 + 0) = *(trunc___0 + 1);
#line 3897
      tmp___2 = trunc___0;
#line 3897
      trunc___0 ++;
#line 3897
      if (! *tmp___2) {
#line 3897
        break;
      }
    }
#line 3900
    trunc___0 --;
  } else {
#line 3902
    trunc___0 = strrchr((char const   *)name, (int )*("." + 0));
#line 3903
    if ((unsigned int )trunc___0 == (unsigned int )((void *)0)) {
#line 3903
      error((char *)"internal error in shorten_name");
    }
#line 3904
    if ((int )*(trunc___0 + 1) == 0) {
#line 3904
      trunc___0 --;
    }
  }
#line 3906
  strcpy(trunc___0, (char const   *)(z_suffix));
#line 3907
  return;
}
}
#line 3908 "D:/a/test/164.c"
static int check_ofname(void) 
{ struct stat ostat ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  struct _reent *tmp___3 ;
  struct _reent *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char response[80] ;
  struct _reent *tmp___7 ;
  struct _reent *tmp___8 ;
  struct _reent *tmp___9 ;
  struct _reent *tmp___10 ;
  struct _reent *tmp___11 ;
  int tmp___12 ;
  struct _reent *tmp___13 ;
  int tmp___15 ;
  int tmp___16 ;
  struct _reent *tmp___17 ;
  int tmp___18 ;

  {
#line 3918
  tmp = stat((char const   *)(ofname), & ostat);
#line 3918
  if (tmp != 0) {
#line 3918
    return (0);
  }
#line 3920
  if (! decompress) {
#line 3920
    tmp___1 = name_too_long(ofname, & ostat);
#line 3920
    if (tmp___1) {
#line 3921
      shorten_name(ofname);
#line 3922
      tmp___0 = stat((char const   *)(ofname), & ostat);
#line 3922
      if (tmp___0 != 0) {
#line 3922
        return (0);
      }
    }
  }
#line 3924
  tmp___6 = same_file(& istat, & ostat);
#line 3924
  if (tmp___6) {
#line 3925
    tmp___5 = strcmp((char const   *)(ifname), (char const   *)(ofname));
#line 3925
    if (tmp___5 == 0) {
#line 3926
      if (decompress) {
#line 3926
        tmp___2 = "de";
      } else {
#line 3926
        tmp___2 = "";
      }
#line 3926
      tmp___3 = __getreent();
#line 3926
      fprintf(tmp___3->_stderr, "%s: %s: cannot %scompress onto itself\n", progname,
              ifname, tmp___2);
    } else {
#line 3929
      tmp___4 = __getreent();
#line 3929
      fprintf(tmp___4->_stderr, "%s: %s and %s are the same file\n", progname, ifname,
              ofname);
    }
#line 3932
    exit_code = 1;
#line 3933
    return (1);
  }
#line 3935
  if (! force) {
#line 3937
    strcpy(response, "n");
#line 3938
    tmp___7 = __getreent();
#line 3938
    fprintf(tmp___7->_stderr, "%s: %s already exists;", progname, ofname);
#line 3939
    if (foreground) {
#line 3939
      tmp___11 = __getreent();
#line 3939
      tmp___12 = fileno(tmp___11->_stdin);
#line 3939
      if (tmp___12 <= 2) {
#line 3940
        tmp___8 = __getreent();
#line 3940
        fprintf(tmp___8->_stderr, " do you wish to overwrite (y or n)? ");
#line 3941
        tmp___9 = __getreent();
#line 3941
        fflush(tmp___9->_stderr);
#line 3942
        tmp___10 = __getreent();
#line 3942
        fgets(response, (int )(sizeof(response) - 1U), tmp___10->_stdin);
      }
    }
#line 3944
    tmp___16 = isupper((int )response[0]);
#line 3944
    if (tmp___16) {
#line 3944
      tmp___15 = ((int )response[0] - 65) + 97;
    } else {
#line 3944
      tmp___15 = (int )response[0];
    }
#line 3944
    if (tmp___15 != 121) {
#line 3945
      tmp___13 = __getreent();
#line 3945
      fprintf(tmp___13->_stderr, "\tnot overwritten\n");
#line 3946
      if (exit_code == 0) {
#line 3946
        exit_code = 2;
      }
#line 3947
      return (1);
    }
  }
#line 3951
  tmp___18 = unlink(ofname);
#line 3951
  if (tmp___18) {
#line 3952
    tmp___17 = __getreent();
#line 3952
    fprintf(tmp___17->_stderr, "%s: ", progname);
#line 3953
    perror((char const   *)(ofname));
#line 3954
    exit_code = 1;
#line 3955
    return (1);
  }
#line 3957
  return (0);
}
}
#line 3973 "D:/a/test/164.c"
static void copy_stat(struct stat *ifstat ) 
{ struct _reent *tmp___0 ;
  int tmp___1 ;

  {
#line 3992
  remove_ofname = 0;
#line 3994
  tmp___1 = unlink(ifname);
#line 3994
  if (tmp___1) {
#line 3995
    if (! quiet) {
#line 3995
      tmp___0 = __getreent();
#line 3995
      fprintf(tmp___0->_stderr, "%s: ", progname);
    }
#line 3995
    if (exit_code == 0) {
#line 3995
      exit_code = 2;
    }
#line 3996
    if (! quiet) {
#line 3996
      perror((char const   *)(ifname));
    }
  }
#line 3998
  return;
}
}
#line 4044
static void do_exit(int exitcode ) ;
#line 4044 "D:/a/test/164.c"
static int in_exit  =    0;
#line 4041 "D:/a/test/164.c"
static void do_exit(int exitcode ) 
{ 

  {
#line 4045
  if (in_exit) {
#line 4045
    exit(exitcode);
  }
#line 4046
  in_exit = 1;
#line 4047
  if ((unsigned int )env != (unsigned int )((void *)0)) {
#line 4047
    free((void *)env);
#line 4047
    env = (char *)((void *)0);
  }
#line 4048
  if ((unsigned int )args != (unsigned int )((void *)0)) {
#line 4048
    free((void *)((char *)args));
#line 4048
    args = (char **)((void *)0);
  }
#line 4049
  if ((unsigned int )inbuf != (unsigned int )((void *)0)) {
#line 4049
    free((void *)inbuf);
#line 4049
    inbuf = (uch *)((void *)0);
  }
#line 4050
  if ((unsigned int )outbuf != (unsigned int )((void *)0)) {
#line 4050
    free((void *)outbuf);
#line 4050
    outbuf = (uch *)((void *)0);
  }
#line 4051
  if ((unsigned int )d_buf != (unsigned int )((void *)0)) {
#line 4051
    free((void *)d_buf);
#line 4051
    d_buf = (ush *)((void *)0);
  }
#line 4052
  if ((unsigned int )window != (unsigned int )((void *)0)) {
#line 4052
    free((void *)window);
#line 4052
    window = (uch *)((void *)0);
  }
#line 4054
  if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 4054
    free((void *)prev);
#line 4054
    prev = (ush *)((void *)0);
  }
#line 4059
  exit(exitcode);
}
}
#line 4061 "D:/a/test/164.c"
void abort_gzip(void) 
{ 

  {
#line 4063
  if (remove_ofname) {
#line 4064
    close(ofd);
#line 4065
    unlink(ofname);
  }
#line 4067
  do_exit(1);
#line 4068
  return;
}
}
#line 4086
int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush *d , ush *e ,
               struct huft **t , int *m ) ;
#line 4088
int huft_free(struct huft *t ) ;
#line 4089
int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) ;
#line 4090
int inflate_stored(void) ;
#line 4091
int inflate_fixed(void) ;
#line 4092
int inflate_dynamic(void) ;
#line 4093
int inflate_block(int *e ) ;
#line 4097 "D:/a/test/164.c"
static unsigned int border[19]  = 
#line 4097
  {      16U,      17U,      18U,      0U, 
        8U,      7U,      9U,      6U, 
        10U,      5U,      11U,      4U, 
        12U,      3U,      13U,      2U, 
        14U,      1U,      15U};
#line 4099 "D:/a/test/164.c"
static ush cplens[31]  = 
#line 4099
  {      (ush )3,      (ush )4,      (ush )5,      (ush )6, 
        (ush )7,      (ush )8,      (ush )9,      (ush )10, 
        (ush )11,      (ush )13,      (ush )15,      (ush )17, 
        (ush )19,      (ush )23,      (ush )27,      (ush )31, 
        (ush )35,      (ush )43,      (ush )51,      (ush )59, 
        (ush )67,      (ush )83,      (ush )99,      (ush )115, 
        (ush )131,      (ush )163,      (ush )195,      (ush )227, 
        (ush )258,      (ush )0,      (ush )0};
#line 4102 "D:/a/test/164.c"
static ush cplext[31]  = 
#line 4102
  {      (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )1,      (ush )1,      (ush )1,      (ush )1, 
        (ush )2,      (ush )2,      (ush )2,      (ush )2, 
        (ush )3,      (ush )3,      (ush )3,      (ush )3, 
        (ush )4,      (ush )4,      (ush )4,      (ush )4, 
        (ush )5,      (ush )5,      (ush )5,      (ush )5, 
        (ush )0,      (ush )99,      (ush )99};
#line 4105 "D:/a/test/164.c"
static ush cpdist[30]  = 
#line 4105
  {      (ush )1,      (ush )2,      (ush )3,      (ush )4, 
        (ush )5,      (ush )7,      (ush )9,      (ush )13, 
        (ush )17,      (ush )25,      (ush )33,      (ush )49, 
        (ush )65,      (ush )97,      (ush )129,      (ush )193, 
        (ush )257,      (ush )385,      (ush )513,      (ush )769, 
        (ush )1025,      (ush )1537,      (ush )2049,      (ush )3073, 
        (ush )4097,      (ush )6145,      (ush )8193,      (ush )12289, 
        (ush )16385,      (ush )24577};
#line 4109 "D:/a/test/164.c"
static ush cpdext[30]  = 
#line 4109
  {      (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )1,      (ush )1,      (ush )2,      (ush )2, 
        (ush )3,      (ush )3,      (ush )4,      (ush )4, 
        (ush )5,      (ush )5,      (ush )6,      (ush )6, 
        (ush )7,      (ush )7,      (ush )8,      (ush )8, 
        (ush )9,      (ush )9,      (ush )10,      (ush )10, 
        (ush )11,      (ush )11,      (ush )12,      (ush )12, 
        (ush )13,      (ush )13};
#line 4113 "D:/a/test/164.c"
ulg bb  ;
#line 4114 "D:/a/test/164.c"
unsigned int bk  ;
#line 4115 "D:/a/test/164.c"
ush mask_bits[17]  = 
#line 4115
  {      (ush )0,      (ush )1,      (ush )3,      (ush )7, 
        (ush )15,      (ush )31,      (ush )63,      (ush )127, 
        (ush )255,      (ush )511,      (ush )1023,      (ush )2047, 
        (ush )4095,      (ush )8191,      (ush )16383,      (ush )32767, 
        (ush )65535};
#line 4129 "D:/a/test/164.c"
int lbits  =    9;
#line 4130 "D:/a/test/164.c"
int dbits  =    6;
#line 4133 "D:/a/test/164.c"
unsigned int hufts  ;
#line 4134 "D:/a/test/164.c"
int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush *d , ush *e ,
               struct huft **t , int *m ) 
{ unsigned int a ;
  unsigned int c[17] ;
  unsigned int f ;
  int g ;
  int h ;
  register unsigned int i___0 ;
  register unsigned int j___0 ;
  register int k ;
  int l ;
  register unsigned int *p ;
  register struct huft *q ;
  struct huft r ;
  struct huft *u[16] ;
  unsigned int v[288] ;
  register int w ;
  unsigned int x[17] ;
  unsigned int *xp ;
  int y ;
  unsigned int z ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned int *tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;

  {
#line 4162
  memset((void *)(c), 0, sizeof(c));
#line 4163
  p = b;
#line 4163
  i___0 = n;
#line 4164
  while (1) {
#line 4167
    (c[*p]) ++;
#line 4168
    p ++;
#line 4164
    i___0 --;
#line 4164
    if (! i___0) {
#line 4164
      break;
    }
  }
#line 4170
  if (c[0] == n) {
#line 4172
    *t = (struct huft *)((void *)0);
#line 4173
    *m = 0;
#line 4174
    return (0);
  }
#line 4176
  l = *m;
#line 4177
  j___0 = 1U;
#line 4177
  while (j___0 <= 16U) {
#line 4178
    if (c[j___0]) {
#line 4179
      break;
    }
#line 4177
    j___0 ++;
  }
#line 4180
  k = (int )j___0;
#line 4181
  if ((unsigned int )l < j___0) {
#line 4182
    l = (int )j___0;
  }
#line 4183
  i___0 = 16U;
#line 4183
  while (i___0) {
#line 4184
    if (c[i___0]) {
#line 4185
      break;
    }
#line 4183
    i___0 --;
  }
#line 4186
  g = (int )i___0;
#line 4187
  if ((unsigned int )l > i___0) {
#line 4188
    l = (int )i___0;
  }
#line 4189
  *m = l;
#line 4190
  y = 1 << j___0;
#line 4190
  while (j___0 < i___0) {
#line 4191
    y = (int )((unsigned int )y - c[j___0]);
#line 4191
    if (y < 0) {
#line 4192
      return (2);
    }
#line 4190
    j___0 ++;
#line 4190
    y <<= 1;
  }
#line 4193
  y = (int )((unsigned int )y - c[i___0]);
#line 4193
  if (y < 0) {
#line 4194
    return (2);
  }
#line 4195
  c[i___0] += (unsigned int )y;
#line 4196
  j___0 = 0U;
#line 4196
  x[1] = j___0;
#line 4197
  p = c + 1;
#line 4197
  xp = x + 2;
#line 4198
  while (1) {
#line 4198
    i___0 --;
#line 4198
    if (! i___0) {
#line 4198
      break;
    }
#line 4199
    tmp = xp;
#line 4199
    xp ++;
#line 4199
    tmp___0 = p;
#line 4199
    p ++;
#line 4199
    j___0 += *tmp___0;
#line 4199
    *tmp = j___0;
  }
#line 4201
  p = b;
#line 4201
  i___0 = 0U;
#line 4202
  while (1) {
#line 4203
    tmp___2 = p;
#line 4203
    p ++;
#line 4203
    j___0 = *tmp___2;
#line 4203
    if (j___0 != 0U) {
#line 4204
      tmp___1 = x[j___0];
#line 4204
      (x[j___0]) ++;
#line 4204
      v[tmp___1] = i___0;
    }
#line 4202
    i___0 ++;
#line 4202
    if (! (i___0 < n)) {
#line 4202
      break;
    }
  }
#line 4206
  i___0 = 0U;
#line 4206
  x[0] = i___0;
#line 4207
  p = v;
#line 4208
  h = -1;
#line 4209
  w = - l;
#line 4210
  u[0] = (struct huft *)((void *)0);
#line 4211
  q = (struct huft *)((void *)0);
#line 4212
  z = 0U;
#line 4213
  while (k <= g) {
#line 4215
    a = c[k];
#line 4216
    while (1) {
#line 4216
      tmp___6 = a;
#line 4216
      a --;
#line 4216
      if (! tmp___6) {
#line 4216
        break;
      }
#line 4218
      while (k > w + l) {
#line 4220
        h ++;
#line 4221
        w += l;
#line 4222
        z = (unsigned int )(g - w);
#line 4222
        if (z > (unsigned int )l) {
#line 4222
          z = (unsigned int )l;
        } else {
#line 4222
          z = z;
        }
#line 4223
        j___0 = (unsigned int )(k - w);
#line 4223
        f = (unsigned int )(1 << j___0);
#line 4223
        if (f > a + 1U) {
#line 4225
          f -= a + 1U;
#line 4226
          xp = c + k;
#line 4227
          while (1) {
#line 4227
            j___0 ++;
#line 4227
            if (! (j___0 < z)) {
#line 4227
              break;
            }
#line 4229
            f <<= 1;
#line 4229
            xp ++;
#line 4229
            if (f <= *xp) {
#line 4230
              break;
            }
#line 4231
            f -= *xp;
          }
        }
#line 4234
        z = (unsigned int )(1 << j___0);
#line 4235
        tmp___3 = malloc((z + 1U) * sizeof(struct huft ));
#line 4235
        q = (struct huft *)tmp___3;
#line 4235
        if ((unsigned int )q == (unsigned int )((struct huft *)((void *)0))) {
#line 4238
          if (h) {
#line 4239
            huft_free(u[0]);
          }
#line 4240
          return (3);
        }
#line 4242
        hufts += z + 1U;
#line 4243
        *t = q + 1;
#line 4244
        t = & q->v.t;
#line 4244
        *t = (struct huft *)((void *)0);
#line 4245
        q ++;
#line 4245
        u[h] = q;
#line 4246
        if (h) {
#line 4248
          x[h] = i___0;
#line 4249
          r.b = (unsigned char )l;
#line 4250
          r.e = (unsigned char )(16U + j___0);
#line 4251
          r.v.t = q;
#line 4252
          j___0 = i___0 >> (w - l);
#line 4253
          *(u[h - 1] + j___0) = r;
        }
      }
#line 4256
      r.b = (unsigned char )(k - w);
#line 4257
      if ((unsigned int )p >= (unsigned int )(v + n)) {
#line 4258
        r.e = (unsigned char)99;
      } else {
#line 4259
        if (*p < s) {
#line 4261
          if (*p < 256U) {
#line 4261
            tmp___4 = 16;
          } else {
#line 4261
            tmp___4 = 15;
          }
#line 4261
          r.e = (unsigned char )tmp___4;
#line 4262
          r.v.n = (unsigned short )*p;
#line 4263
          p ++;
        } else {
#line 4267
          r.e = (unsigned char )*(e + (*p - s));
#line 4268
          tmp___5 = p;
#line 4268
          p ++;
#line 4268
          r.v.n = *(d + (*tmp___5 - s));
        }
      }
#line 4270
      f = (unsigned int )(1 << (k - w));
#line 4271
      j___0 = i___0 >> w;
#line 4271
      while (j___0 < z) {
#line 4272
        *(q + j___0) = r;
#line 4271
        j___0 += f;
      }
#line 4273
      j___0 = (unsigned int )(1 << (k - 1));
#line 4273
      while (i___0 & j___0) {
#line 4274
        i___0 ^= j___0;
#line 4273
        j___0 >>= 1;
      }
#line 4275
      i___0 ^= j___0;
#line 4276
      while ((i___0 & (unsigned int )((1 << w) - 1)) != x[h]) {
#line 4278
        h --;
#line 4279
        w -= l;
      }
    }
#line 4213
    k ++;
  }
#line 4283
  if (y != 0) {
#line 4283
    if (g != 1) {
#line 4283
      tmp___7 = 1;
    } else {
#line 4283
      tmp___7 = 0;
    }
  } else {
#line 4283
    tmp___7 = 0;
  }
#line 4283
  return (tmp___7);
}
}
#line 4285 "D:/a/test/164.c"
int huft_free(struct huft *t ) 
{ register struct huft *p ;
  register struct huft *q ;

  {
#line 4289
  p = t;
#line 4290
  while ((unsigned int )p != (unsigned int )((struct huft *)((void *)0))) {
#line 4292
    p --;
#line 4292
    q = p->v.t;
#line 4293
    free((void *)((char *)p));
#line 4294
    p = q;
  }
#line 4296
  return (0);
}
}
#line 4298 "D:/a/test/164.c"
int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) 
{ register unsigned int e ;
  unsigned int n ;
  unsigned int d ;
  unsigned int w ;
  struct huft *t ;
  unsigned int ml ;
  unsigned int md ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;

  {
#line 4309
  b = bb;
#line 4310
  k = bk;
#line 4311
  w = outcnt;
#line 4312
  ml = (unsigned int )mask_bits[bl];
#line 4313
  md = (unsigned int )mask_bits[bd];
#line 4314
  while (1) {
#line 4316
    while (k < (unsigned int )bl) {
#line 4316
      if (inptr < insize) {
#line 4316
        tmp = inptr;
#line 4316
        inptr ++;
#line 4316
        tmp___1 = (int )*(inbuf + tmp);
      } else {
#line 4316
        tmp___0 = fill_inbuf(0);
#line 4316
        tmp___1 = tmp___0;
      }
#line 4316
      b |= (unsigned long )((unsigned char )tmp___1) << k;
#line 4316
      k += 8U;
    }
#line 4317
    t = tl + ((unsigned int )b & ml);
#line 4317
    e = (unsigned int )t->e;
#line 4317
    if (e > 16U) {
#line 4318
      while (1) {
#line 4319
        if (e == 99U) {
#line 4320
          return (1);
        }
#line 4321
        b >>= (int )t->b;
#line 4321
        k -= (unsigned int )t->b;
#line 4322
        e -= 16U;
#line 4323
        while (k < e) {
#line 4323
          if (inptr < insize) {
#line 4323
            tmp___2 = inptr;
#line 4323
            inptr ++;
#line 4323
            tmp___4 = (int )*(inbuf + tmp___2);
          } else {
#line 4323
            tmp___3 = fill_inbuf(0);
#line 4323
            tmp___4 = tmp___3;
          }
#line 4323
          b |= (unsigned long )((unsigned char )tmp___4) << k;
#line 4323
          k += 8U;
        }
#line 4318
        t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 4318
        e = (unsigned int )t->e;
#line 4318
        if (! (e > 16U)) {
#line 4318
          break;
        }
      }
    }
#line 4325
    b >>= (int )t->b;
#line 4325
    k -= (unsigned int )t->b;
#line 4326
    if (e == 16U) {
#line 4328
      tmp___5 = w;
#line 4328
      w ++;
#line 4328
      *(window + tmp___5) = (unsigned char )t->v.n;
#line 4330
      if (w == 32768U) {
#line 4332
        outcnt = w;
#line 4332
        flush_window();
#line 4333
        w = 0U;
      }
    } else {
#line 4338
      if (e == 15U) {
#line 4339
        break;
      }
#line 4340
      while (k < e) {
#line 4340
        if (inptr < insize) {
#line 4340
          tmp___6 = inptr;
#line 4340
          inptr ++;
#line 4340
          tmp___8 = (int )*(inbuf + tmp___6);
        } else {
#line 4340
          tmp___7 = fill_inbuf(0);
#line 4340
          tmp___8 = tmp___7;
        }
#line 4340
        b |= (unsigned long )((unsigned char )tmp___8) << k;
#line 4340
        k += 8U;
      }
#line 4341
      n = (unsigned int )t->v.n + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 4342
      b >>= e;
#line 4342
      k -= e;
#line 4343
      while (k < (unsigned int )bd) {
#line 4343
        if (inptr < insize) {
#line 4343
          tmp___9 = inptr;
#line 4343
          inptr ++;
#line 4343
          tmp___11 = (int )*(inbuf + tmp___9);
        } else {
#line 4343
          tmp___10 = fill_inbuf(0);
#line 4343
          tmp___11 = tmp___10;
        }
#line 4343
        b |= (unsigned long )((unsigned char )tmp___11) << k;
#line 4343
        k += 8U;
      }
#line 4344
      t = td + ((unsigned int )b & md);
#line 4344
      e = (unsigned int )t->e;
#line 4344
      if (e > 16U) {
#line 4345
        while (1) {
#line 4346
          if (e == 99U) {
#line 4347
            return (1);
          }
#line 4348
          b >>= (int )t->b;
#line 4348
          k -= (unsigned int )t->b;
#line 4349
          e -= 16U;
#line 4350
          while (k < e) {
#line 4350
            if (inptr < insize) {
#line 4350
              tmp___12 = inptr;
#line 4350
              inptr ++;
#line 4350
              tmp___14 = (int )*(inbuf + tmp___12);
            } else {
#line 4350
              tmp___13 = fill_inbuf(0);
#line 4350
              tmp___14 = tmp___13;
            }
#line 4350
            b |= (unsigned long )((unsigned char )tmp___14) << k;
#line 4350
            k += 8U;
          }
#line 4345
          t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 4345
          e = (unsigned int )t->e;
#line 4345
          if (! (e > 16U)) {
#line 4345
            break;
          }
        }
      }
#line 4352
      b >>= (int )t->b;
#line 4352
      k -= (unsigned int )t->b;
#line 4353
      while (k < e) {
#line 4353
        if (inptr < insize) {
#line 4353
          tmp___15 = inptr;
#line 4353
          inptr ++;
#line 4353
          tmp___17 = (int )*(inbuf + tmp___15);
        } else {
#line 4353
          tmp___16 = fill_inbuf(0);
#line 4353
          tmp___17 = tmp___16;
        }
#line 4353
        b |= (unsigned long )((unsigned char )tmp___17) << k;
#line 4353
        k += 8U;
      }
#line 4354
      d = (w - (unsigned int )t->v.n) - ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 4355
      b >>= e;
#line 4355
      k -= e;
#line 4357
      while (1) {
#line 4358
        d &= 32767U;
#line 4358
        if (d > w) {
#line 4358
          tmp___19 = d;
        } else {
#line 4358
          tmp___19 = w;
        }
#line 4358
        e = 32768U - tmp___19;
#line 4358
        if (e > n) {
#line 4358
          e = n;
        } else {
#line 4358
          e = e;
        }
#line 4358
        n -= e;
#line 4360
        if (w - d >= e) {
#line 4362
          memcpy((void *)(window + w), (void const   *)(window + d), e);
#line 4363
          w += e;
#line 4364
          d += e;
        } else {
#line 4368
          while (1) {
#line 4369
            tmp___20 = w;
#line 4369
            w ++;
#line 4369
            tmp___21 = d;
#line 4369
            d ++;
#line 4369
            *(window + tmp___20) = *(window + tmp___21);
#line 4368
            e --;
#line 4368
            if (! e) {
#line 4368
              break;
            }
          }
        }
#line 4372
        if (w == 32768U) {
#line 4374
          outcnt = w;
#line 4374
          flush_window();
#line 4375
          w = 0U;
        }
#line 4357
        if (! n) {
#line 4357
          break;
        }
      }
    }
  }
#line 4380
  outcnt = w;
#line 4381
  bb = b;
#line 4382
  bk = k;
#line 4383
  return (0);
}
}
#line 4385 "D:/a/test/164.c"
int inflate_stored(void) 
{ unsigned int n ;
  unsigned int w ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 4391
  b = bb;
#line 4392
  k = bk;
#line 4393
  w = outcnt;
#line 4394
  n = k & 7U;
#line 4395
  b >>= n;
#line 4395
  k -= n;
#line 4396
  while (k < 16U) {
#line 4396
    if (inptr < insize) {
#line 4396
      tmp = inptr;
#line 4396
      inptr ++;
#line 4396
      tmp___1 = (int )*(inbuf + tmp);
    } else {
#line 4396
      tmp___0 = fill_inbuf(0);
#line 4396
      tmp___1 = tmp___0;
    }
#line 4396
    b |= (unsigned long )((unsigned char )tmp___1) << k;
#line 4396
    k += 8U;
  }
#line 4397
  n = (unsigned int )b & 65535U;
#line 4398
  b >>= 16;
#line 4398
  k -= 16U;
#line 4399
  while (k < 16U) {
#line 4399
    if (inptr < insize) {
#line 4399
      tmp___2 = inptr;
#line 4399
      inptr ++;
#line 4399
      tmp___4 = (int )*(inbuf + tmp___2);
    } else {
#line 4399
      tmp___3 = fill_inbuf(0);
#line 4399
      tmp___4 = tmp___3;
    }
#line 4399
    b |= (unsigned long )((unsigned char )tmp___4) << k;
#line 4399
    k += 8U;
  }
#line 4400
  if (n != (unsigned int )(~ b & 65535UL)) {
#line 4401
    return (1);
  }
#line 4402
  b >>= 16;
#line 4402
  k -= 16U;
#line 4403
  while (1) {
#line 4403
    tmp___9 = n;
#line 4403
    n --;
#line 4403
    if (! tmp___9) {
#line 4403
      break;
    }
#line 4405
    while (k < 8U) {
#line 4405
      if (inptr < insize) {
#line 4405
        tmp___5 = inptr;
#line 4405
        inptr ++;
#line 4405
        tmp___7 = (int )*(inbuf + tmp___5);
      } else {
#line 4405
        tmp___6 = fill_inbuf(0);
#line 4405
        tmp___7 = tmp___6;
      }
#line 4405
      b |= (unsigned long )((unsigned char )tmp___7) << k;
#line 4405
      k += 8U;
    }
#line 4406
    tmp___8 = w;
#line 4406
    w ++;
#line 4406
    *(window + tmp___8) = (unsigned char )b;
#line 4407
    if (w == 32768U) {
#line 4409
      outcnt = w;
#line 4409
      flush_window();
#line 4410
      w = 0U;
    }
#line 4412
    b >>= 8;
#line 4412
    k -= 8U;
  }
#line 4414
  outcnt = w;
#line 4415
  bb = b;
#line 4416
  bk = k;
#line 4417
  return (0);
}
}
#line 4419 "D:/a/test/164.c"
int inflate_fixed(void) 
{ int i___0 ;
  struct huft *tl ;
  struct huft *td ;
  int bl ;
  int bd ;
  unsigned int l[288] ;
  int tmp ;

  {
#line 4427
  i___0 = 0;
#line 4427
  while (i___0 < 144) {
#line 4428
    l[i___0] = 8U;
#line 4427
    i___0 ++;
  }
#line 4429
  while (i___0 < 256) {
#line 4430
    l[i___0] = 9U;
#line 4429
    i___0 ++;
  }
#line 4431
  while (i___0 < 280) {
#line 4432
    l[i___0] = 7U;
#line 4431
    i___0 ++;
  }
#line 4433
  while (i___0 < 288) {
#line 4434
    l[i___0] = 8U;
#line 4433
    i___0 ++;
  }
#line 4435
  bl = 7;
#line 4436
  i___0 = huft_build(l, 288U, 257U, cplens, cplext, & tl, & bl);
#line 4436
  if (i___0 != 0) {
#line 4437
    return (i___0);
  }
#line 4438
  i___0 = 0;
#line 4438
  while (i___0 < 30) {
#line 4439
    l[i___0] = 5U;
#line 4438
    i___0 ++;
  }
#line 4440
  bd = 5;
#line 4441
  i___0 = huft_build(l, 30U, 0U, cpdist, cpdext, & td, & bd);
#line 4441
  if (i___0 > 1) {
#line 4443
    huft_free(tl);
#line 4444
    return (i___0);
  }
#line 4446
  tmp = inflate_codes(tl, td, bl, bd);
#line 4446
  if (tmp) {
#line 4447
    return (1);
  }
#line 4448
  huft_free(tl);
#line 4449
  huft_free(td);
#line 4450
  return (0);
}
}
#line 4452 "D:/a/test/164.c"
int inflate_dynamic(void) 
{ int i___0 ;
  unsigned int j___0 ;
  unsigned int l ;
  unsigned int m ;
  unsigned int n ;
  struct huft *tl ;
  struct huft *td ;
  int bl ;
  int bd ;
  unsigned int nb ;
  unsigned int nl ;
  unsigned int nd ;
  unsigned int ll[316] ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  unsigned int tmp___29 ;
  struct _reent *tmp___30 ;
  struct _reent *tmp___31 ;
  int tmp___32 ;

  {
#line 4473
  b = bb;
#line 4474
  k = bk;
#line 4475
  while (k < 5U) {
#line 4475
    if (inptr < insize) {
#line 4475
      tmp = inptr;
#line 4475
      inptr ++;
#line 4475
      tmp___1 = (int )*(inbuf + tmp);
    } else {
#line 4475
      tmp___0 = fill_inbuf(0);
#line 4475
      tmp___1 = tmp___0;
    }
#line 4475
    b |= (unsigned long )((unsigned char )tmp___1) << k;
#line 4475
    k += 8U;
  }
#line 4476
  nl = 257U + ((unsigned int )b & 31U);
#line 4477
  b >>= 5;
#line 4477
  k -= 5U;
#line 4478
  while (k < 5U) {
#line 4478
    if (inptr < insize) {
#line 4478
      tmp___2 = inptr;
#line 4478
      inptr ++;
#line 4478
      tmp___4 = (int )*(inbuf + tmp___2);
    } else {
#line 4478
      tmp___3 = fill_inbuf(0);
#line 4478
      tmp___4 = tmp___3;
    }
#line 4478
    b |= (unsigned long )((unsigned char )tmp___4) << k;
#line 4478
    k += 8U;
  }
#line 4479
  nd = 1U + ((unsigned int )b & 31U);
#line 4480
  b >>= 5;
#line 4480
  k -= 5U;
#line 4481
  while (k < 4U) {
#line 4481
    if (inptr < insize) {
#line 4481
      tmp___5 = inptr;
#line 4481
      inptr ++;
#line 4481
      tmp___7 = (int )*(inbuf + tmp___5);
    } else {
#line 4481
      tmp___6 = fill_inbuf(0);
#line 4481
      tmp___7 = tmp___6;
    }
#line 4481
    b |= (unsigned long )((unsigned char )tmp___7) << k;
#line 4481
    k += 8U;
  }
#line 4482
  nb = 4U + ((unsigned int )b & 15U);
#line 4483
  b >>= 4;
#line 4483
  k -= 4U;
#line 4487
  if (nl > 286U) {
#line 4489
    return (1);
  } else {
#line 4487
    if (nd > 30U) {
#line 4489
      return (1);
    }
  }
#line 4490
  j___0 = 0U;
#line 4490
  while (j___0 < nb) {
#line 4492
    while (k < 3U) {
#line 4492
      if (inptr < insize) {
#line 4492
        tmp___8 = inptr;
#line 4492
        inptr ++;
#line 4492
        tmp___10 = (int )*(inbuf + tmp___8);
      } else {
#line 4492
        tmp___9 = fill_inbuf(0);
#line 4492
        tmp___10 = tmp___9;
      }
#line 4492
      b |= (unsigned long )((unsigned char )tmp___10) << k;
#line 4492
      k += 8U;
    }
#line 4493
    ll[border[j___0]] = (unsigned int )b & 7U;
#line 4494
    b >>= 3;
#line 4494
    k -= 3U;
#line 4490
    j___0 ++;
  }
#line 4496
  while (j___0 < 19U) {
#line 4497
    ll[border[j___0]] = 0U;
#line 4496
    j___0 ++;
  }
#line 4498
  bl = 7;
#line 4499
  i___0 = huft_build(ll, 19U, 19U, (ush *)((void *)0), (ush *)((void *)0), & tl, & bl);
#line 4499
  if (i___0 != 0) {
#line 4501
    if (i___0 == 1) {
#line 4502
      huft_free(tl);
    }
#line 4503
    return (i___0);
  }
#line 4505
  n = nl + nd;
#line 4506
  m = (unsigned int )mask_bits[bl];
#line 4507
  l = 0U;
#line 4507
  i___0 = (int )l;
#line 4508
  while ((unsigned int )i___0 < n) {
#line 4510
    while (k < (unsigned int )bl) {
#line 4510
      if (inptr < insize) {
#line 4510
        tmp___11 = inptr;
#line 4510
        inptr ++;
#line 4510
        tmp___13 = (int )*(inbuf + tmp___11);
      } else {
#line 4510
        tmp___12 = fill_inbuf(0);
#line 4510
        tmp___13 = tmp___12;
      }
#line 4510
      b |= (unsigned long )((unsigned char )tmp___13) << k;
#line 4510
      k += 8U;
    }
#line 4511
    td = tl + ((unsigned int )b & m);
#line 4511
    j___0 = (unsigned int )td->b;
#line 4512
    b >>= j___0;
#line 4512
    k -= j___0;
#line 4513
    j___0 = (unsigned int )td->v.n;
#line 4514
    if (j___0 < 16U) {
#line 4515
      tmp___14 = i___0;
#line 4515
      i___0 ++;
#line 4515
      l = j___0;
#line 4515
      ll[tmp___14] = l;
    } else {
#line 4516
      if (j___0 == 16U) {
#line 4518
        while (k < 2U) {
#line 4518
          if (inptr < insize) {
#line 4518
            tmp___15 = inptr;
#line 4518
            inptr ++;
#line 4518
            tmp___17 = (int )*(inbuf + tmp___15);
          } else {
#line 4518
            tmp___16 = fill_inbuf(0);
#line 4518
            tmp___17 = tmp___16;
          }
#line 4518
          b |= (unsigned long )((unsigned char )tmp___17) << k;
#line 4518
          k += 8U;
        }
#line 4519
        j___0 = 3U + ((unsigned int )b & 3U);
#line 4520
        b >>= 2;
#line 4520
        k -= 2U;
#line 4521
        if ((unsigned int )i___0 + j___0 > n) {
#line 4522
          return (1);
        }
#line 4523
        while (1) {
#line 4523
          tmp___19 = j___0;
#line 4523
          j___0 --;
#line 4523
          if (! tmp___19) {
#line 4523
            break;
          }
#line 4524
          tmp___18 = i___0;
#line 4524
          i___0 ++;
#line 4524
          ll[tmp___18] = l;
        }
      } else {
#line 4526
        if (j___0 == 17U) {
#line 4528
          while (k < 3U) {
#line 4528
            if (inptr < insize) {
#line 4528
              tmp___20 = inptr;
#line 4528
              inptr ++;
#line 4528
              tmp___22 = (int )*(inbuf + tmp___20);
            } else {
#line 4528
              tmp___21 = fill_inbuf(0);
#line 4528
              tmp___22 = tmp___21;
            }
#line 4528
            b |= (unsigned long )((unsigned char )tmp___22) << k;
#line 4528
            k += 8U;
          }
#line 4529
          j___0 = 3U + ((unsigned int )b & 7U);
#line 4530
          b >>= 3;
#line 4530
          k -= 3U;
#line 4531
          if ((unsigned int )i___0 + j___0 > n) {
#line 4532
            return (1);
          }
#line 4533
          while (1) {
#line 4533
            tmp___24 = j___0;
#line 4533
            j___0 --;
#line 4533
            if (! tmp___24) {
#line 4533
              break;
            }
#line 4534
            tmp___23 = i___0;
#line 4534
            i___0 ++;
#line 4534
            ll[tmp___23] = 0U;
          }
#line 4535
          l = 0U;
        } else {
#line 4539
          while (k < 7U) {
#line 4539
            if (inptr < insize) {
#line 4539
              tmp___25 = inptr;
#line 4539
              inptr ++;
#line 4539
              tmp___27 = (int )*(inbuf + tmp___25);
            } else {
#line 4539
              tmp___26 = fill_inbuf(0);
#line 4539
              tmp___27 = tmp___26;
            }
#line 4539
            b |= (unsigned long )((unsigned char )tmp___27) << k;
#line 4539
            k += 8U;
          }
#line 4540
          j___0 = 11U + ((unsigned int )b & 127U);
#line 4541
          b >>= 7;
#line 4541
          k -= 7U;
#line 4542
          if ((unsigned int )i___0 + j___0 > n) {
#line 4543
            return (1);
          }
#line 4544
          while (1) {
#line 4544
            tmp___29 = j___0;
#line 4544
            j___0 --;
#line 4544
            if (! tmp___29) {
#line 4544
              break;
            }
#line 4545
            tmp___28 = i___0;
#line 4545
            i___0 ++;
#line 4545
            ll[tmp___28] = 0U;
          }
#line 4546
          l = 0U;
        }
      }
    }
  }
#line 4549
  huft_free(tl);
#line 4550
  bb = b;
#line 4551
  bk = k;
#line 4552
  bl = lbits;
#line 4553
  i___0 = huft_build(ll, nl, 257U, cplens, cplext, & tl, & bl);
#line 4553
  if (i___0 != 0) {
#line 4555
    if (i___0 == 1) {
#line 4556
      tmp___30 = __getreent();
#line 4556
      fprintf(tmp___30->_stderr, " incomplete literal tree\n");
#line 4557
      huft_free(tl);
    }
#line 4559
    return (i___0);
  }
#line 4561
  bd = dbits;
#line 4562
  i___0 = huft_build(ll + nl, nd, 0U, cpdist, cpdext, & td, & bd);
#line 4562
  if (i___0 != 0) {
#line 4564
    if (i___0 == 1) {
#line 4565
      tmp___31 = __getreent();
#line 4565
      fprintf(tmp___31->_stderr, " incomplete distance tree\n");
#line 4570
      huft_free(td);
    }
#line 4572
    huft_free(tl);
#line 4573
    return (i___0);
  }
#line 4576
  tmp___32 = inflate_codes(tl, td, bl, bd);
#line 4576
  if (tmp___32) {
#line 4577
    return (1);
  }
#line 4578
  huft_free(tl);
#line 4579
  huft_free(td);
#line 4580
  return (0);
}
}
#line 4582 "D:/a/test/164.c"
int inflate_block(int *e ) 
{ unsigned int t ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 4588
  b = bb;
#line 4589
  k = bk;
#line 4590
  while (k < 1U) {
#line 4590
    if (inptr < insize) {
#line 4590
      tmp = inptr;
#line 4590
      inptr ++;
#line 4590
      tmp___1 = (int )*(inbuf + tmp);
    } else {
#line 4590
      tmp___0 = fill_inbuf(0);
#line 4590
      tmp___1 = tmp___0;
    }
#line 4590
    b |= (unsigned long )((unsigned char )tmp___1) << k;
#line 4590
    k += 8U;
  }
#line 4591
  *e = (int )b & 1;
#line 4592
  b >>= 1;
#line 4592
  k --;
#line 4593
  while (k < 2U) {
#line 4593
    if (inptr < insize) {
#line 4593
      tmp___2 = inptr;
#line 4593
      inptr ++;
#line 4593
      tmp___4 = (int )*(inbuf + tmp___2);
    } else {
#line 4593
      tmp___3 = fill_inbuf(0);
#line 4593
      tmp___4 = tmp___3;
    }
#line 4593
    b |= (unsigned long )((unsigned char )tmp___4) << k;
#line 4593
    k += 8U;
  }
#line 4594
  t = (unsigned int )b & 3U;
#line 4595
  b >>= 2;
#line 4595
  k -= 2U;
#line 4596
  bb = b;
#line 4597
  bk = k;
#line 4598
  if (t == 2U) {
#line 4599
    tmp___5 = inflate_dynamic();
#line 4599
    return (tmp___5);
  }
#line 4600
  if (t == 0U) {
#line 4601
    tmp___6 = inflate_stored();
#line 4601
    return (tmp___6);
  }
#line 4602
  if (t == 1U) {
#line 4603
    tmp___7 = inflate_fixed();
#line 4603
    return (tmp___7);
  }
#line 4604
  return (2);
}
}
#line 4606 "D:/a/test/164.c"
int inflate(void) 
{ int e ;
  int r ;
  unsigned int h ;

  {
#line 4611
  outcnt = 0U;
#line 4612
  bk = 0U;
#line 4613
  bb = 0UL;
#line 4614
  h = 0U;
#line 4615
  while (1) {
#line 4616
    hufts = 0U;
#line 4617
    r = inflate_block(& e);
#line 4617
    if (r != 0) {
#line 4618
      return (r);
    }
#line 4619
    if (hufts > h) {
#line 4620
      h = hufts;
    }
#line 4615
    if (! (! e)) {
#line 4615
      break;
    }
  }
#line 4622
  while (bk >= 8U) {
#line 4623
    bk -= 8U;
#line 4624
    inptr --;
  }
#line 4626
  outcnt = outcnt;
#line 4626
  flush_window();
#line 4630
  return (0);
}
}
#line 4645
void spec_initbufs(void) ;
#line 4646
void spec_compress(int in , int out , int lev ) ;
#line 4647
void spec_uncompress(int in , int out , int lev ) ;
#line 4650 "D:/a/test/164.c"
int dbglvl  =    4;
#line 4664 "D:/a/test/164.c"
struct spec_fd_t spec_fd[3]  ;
#line 4670 "D:/a/test/164.c"
long seedi  ;
#line 4671 "D:/a/test/164.c"
double ran(void) 
{ long lo ;
  long hi ;
  long test___0 ;

  {
#line 4680
  hi = seedi / 127773L;
#line 4681
  lo = seedi % 127773L;
#line 4682
  test___0 = 16807L * lo - 2836L * hi;
#line 4683
  if (test___0 > 0L) {
#line 4684
    seedi = test___0;
  } else {
#line 4686
    seedi = test___0 + 2147483647L;
  }
#line 4688
  return ((double )((float )seedi / (float )2147483647L));
}
}
#line 4690 "D:/a/test/164.c"
int spec_init(void) 
{ int i___0 ;
  int j___0 ;
  int limit ;
  void *tmp ;

  {
#line 4692
  if (3 < dbglvl) {
#line 4692
    printf("spec_init\n");
  }
#line 4693
  i___0 = 0;
#line 4693
  while (i___0 < 3) {
#line 4694
    limit = spec_fd[i___0].limit;
#line 4695
    memset((void *)(& spec_fd[i___0]), 0, sizeof(spec_fd[0]));
#line 4696
    spec_fd[i___0].limit = limit;
#line 4697
    tmp = malloc((unsigned int )(limit + 102400));
#line 4697
    spec_fd[i___0].buf = (unsigned char *)tmp;
#line 4698
    if ((unsigned int )spec_fd[i___0].buf == (unsigned int )((void *)0)) {
#line 4699
      printf("spec_init: Error mallocing memory!\n");
#line 4700
      exit(1);
    }
#line 4702
    j___0 = 0;
#line 4702
    while (j___0 < limit) {
#line 4703
      *(spec_fd[i___0].buf + j___0) = (unsigned char)0;
#line 4702
      j___0 += 1024;
    }
#line 4693
    i___0 ++;
  }
#line 4706
  return (0);
}
}
#line 4708 "D:/a/test/164.c"
int spec_random_load(int fd ) 
{ int i___0 ;
  int j___0 ;
  char random_text[32][131072] ;
  double tmp ;
  double tmp___0 ;

  {
#line 4713
  if (4 < dbglvl) {
#line 4713
    printf("Creating Chunks\n");
  }
#line 4714
  i___0 = 0;
#line 4714
  while (i___0 < 32) {
#line 4715
    if (5 < dbglvl) {
#line 4715
      printf("Creating Chunk %d\n", i___0);
    }
#line 4716
    j___0 = 0;
#line 4716
    while (j___0 < 131072) {
#line 4717
      tmp = ran();
#line 4717
      random_text[i___0][j___0] = (char )((int )(tmp * (double )256));
#line 4716
      j___0 ++;
    }
#line 4714
    i___0 ++;
  }
#line 4720
  if (4 < dbglvl) {
#line 4720
    printf("Filling input file\n");
  }
#line 4721
  i___0 = 0;
#line 4721
  while (i___0 < spec_fd[fd].limit) {
#line 4722
    tmp___0 = ran();
#line 4722
    memcpy((void *)(spec_fd[fd].buf + i___0), (void const   *)(random_text[(int )(tmp___0 * (double )32)]),
           131072U);
#line 4721
    i___0 += 131072;
  }
#line 4725
  spec_fd[fd].len = 1048576;
#line 4726
  return (0);
}
}
#line 4728 "D:/a/test/164.c"
int spec_load(int num , char *filename , int size ) 
{ int fd ;
  int rc ;
  int i___0 ;
  char *tmp ;
  struct _reent *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  struct _reent *tmp___3 ;
  int tmp___4 ;

  {
#line 4734
  fd = open((char const   *)filename, 65536);
#line 4735
  if (fd < 0) {
#line 4736
    tmp = strerror(errno);
#line 4736
    tmp___0 = __getreent();
#line 4736
    fprintf(tmp___0->_stderr, "Can\'t open file %s: %s\n", filename, tmp);
#line 4737
    exit(1);
  }
#line 4739
  tmp___1 = 0;
#line 4739
  spec_fd[num].len = tmp___1;
#line 4739
  spec_fd[num].pos = tmp___1;
#line 4740
  i___0 = 0;
#line 4740
  while (i___0 < size) {
#line 4741
    rc = spec_read(fd, spec_fd[num].buf + i___0, 131072);
#line 4742
    if (rc == 0) {
#line 4742
      break;
    }
#line 4743
    if (rc < 0) {
#line 4744
      tmp___2 = strerror(errno);
#line 4744
      tmp___3 = __getreent();
#line 4744
      fprintf(tmp___3->_stderr, "Error reading from %s: %s\n", filename, tmp___2);
#line 4745
      exit(1);
    }
#line 4747
    spec_fd[num].len += rc;
#line 4740
    i___0 += rc;
  }
#line 4749
  close(fd);
#line 4750
  while (spec_fd[num].len < size) {
#line 4751
    tmp___4 = size - spec_fd[num].len;
#line 4752
    if (tmp___4 > spec_fd[num].len) {
#line 4752
      tmp___4 = spec_fd[num].len;
    }
#line 4753
    if (3 < dbglvl) {
#line 4753
      printf("Duplicating %d bytes\n", tmp___4);
    }
#line 4754
    memcpy((void *)(spec_fd[num].buf + spec_fd[num].len), (void const   *)spec_fd[num].buf,
           (unsigned int )tmp___4);
#line 4755
    spec_fd[num].len += tmp___4;
  }
#line 4757
  return (0);
}
}
#line 4759 "D:/a/test/164.c"
int spec_read(int fd , unsigned char *buf , int size ) 
{ int rc ;
  struct _reent *tmp ;

  {
#line 4760
  rc = 0;
#line 4761
  if (4 < dbglvl) {
#line 4761
    printf("spec_read: %d, %x, %d = ", fd, buf, size);
  }
#line 4762
  if (fd > 3) {
#line 4763
    tmp = __getreent();
#line 4763
    fprintf(tmp->_stderr, "spec_read: fd=%d, > MAX_SPEC_FD!\n", fd);
#line 4764
    exit(1);
  }
#line 4766
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
#line 4767
    if (4 < dbglvl) {
#line 4767
      printf("EOF\n");
    }
#line 4768
    return (-1);
  }
#line 4770
  if (spec_fd[fd].pos + size >= spec_fd[fd].len) {
#line 4771
    rc = spec_fd[fd].len - spec_fd[fd].pos;
  } else {
#line 4773
    rc = size;
  }
#line 4775
  memcpy((void *)buf, (void const   *)(spec_fd[fd].buf + spec_fd[fd].pos), (unsigned int )rc);
#line 4776
  spec_fd[fd].pos += rc;
#line 4777
  if (4 < dbglvl) {
#line 4777
    printf("%d\n", rc);
  }
#line 4778
  return (rc);
}
}
#line 4780 "D:/a/test/164.c"
int spec_getc(int fd ) 
{ int rc ;
  struct _reent *tmp ;
  int tmp___0 ;

  {
#line 4781
  rc = 0;
#line 4782
  if (4 < dbglvl) {
#line 4782
    printf("spec_getc: %d = ", fd);
  }
#line 4783
  if (fd > 3) {
#line 4784
    tmp = __getreent();
#line 4784
    fprintf(tmp->_stderr, "spec_read: fd=%d, > MAX_SPEC_FD!\n", fd);
#line 4785
    exit(1);
  }
#line 4787
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
#line 4788
    if (4 < dbglvl) {
#line 4788
      printf("EOF\n");
    }
#line 4789
    return (-1);
  }
#line 4791
  tmp___0 = spec_fd[fd].pos;
#line 4791
  (spec_fd[fd].pos) ++;
#line 4791
  rc = (int )*(spec_fd[fd].buf + tmp___0);
#line 4792
  if (4 < dbglvl) {
#line 4792
    printf("%d\n", rc);
  }
#line 4793
  return (rc);
}
}
#line 4795 "D:/a/test/164.c"
int spec_ungetc(unsigned char ch , int fd ) 
{ int rc ;
  struct _reent *tmp ;
  struct _reent *tmp___0 ;
  struct _reent *tmp___1 ;

  {
#line 4796
  rc = 0;
#line 4797
  if (4 < dbglvl) {
#line 4797
    printf("spec_ungetc: %d = ", fd);
  }
#line 4798
  if (fd > 3) {
#line 4799
    tmp = __getreent();
#line 4799
    fprintf(tmp->_stderr, "spec_read: fd=%d, > MAX_SPEC_FD!\n", fd);
#line 4800
    exit(1);
  }
#line 4802
  if (spec_fd[fd].pos <= 0) {
#line 4803
    tmp___0 = __getreent();
#line 4803
    fprintf(tmp___0->_stderr, "spec_ungetc: pos %d <= 0\n", spec_fd[fd].pos);
#line 4804
    exit(1);
  }
#line 4806
  (spec_fd[fd].pos) --;
#line 4806
  if ((int )*(spec_fd[fd].buf + spec_fd[fd].pos) != (int )ch) {
#line 4807
    tmp___1 = __getreent();
#line 4807
    fprintf(tmp___1->_stderr, "spec_ungetc: can\'t unget something that wasn\'t what was in the buffer!\n");
#line 4808
    exit(1);
  }
#line 4810
  if (4 < dbglvl) {
#line 4810
    printf("%d\n", rc);
  }
#line 4811
  return ((int )ch);
}
}
#line 4813 "D:/a/test/164.c"
int spec_rewind(int fd ) 
{ 

  {
#line 4814
  spec_fd[fd].pos = 0;
#line 4815
  return (0);
}
}
#line 4817 "D:/a/test/164.c"
int spec_reset(int fd ) 
{ int tmp ;

  {
#line 4818
  memset((void *)spec_fd[fd].buf, 0, (unsigned int )spec_fd[fd].len);
#line 4819
  tmp = 0;
#line 4819
  spec_fd[fd].len = tmp;
#line 4819
  spec_fd[fd].pos = tmp;
#line 4820
  return (0);
}
}
#line 4822 "D:/a/test/164.c"
int spec_write(int fd , unsigned char *buf , int size ) 
{ struct _reent *tmp ;

  {
#line 4823
  if (4 < dbglvl) {
#line 4823
    printf("spec_write: %d, %x, %d = ", fd, buf, size);
  }
#line 4824
  if (fd > 3) {
#line 4825
    tmp = __getreent();
#line 4825
    fprintf(tmp->_stderr, "spec_write: fd=%d, > MAX_SPEC_FD!\n", fd);
#line 4826
    exit(1);
  }
#line 4828
  memcpy((void *)(spec_fd[fd].buf + spec_fd[fd].pos), (void const   *)buf, (unsigned int )size);
#line 4829
  spec_fd[fd].len += size;
#line 4830
  spec_fd[fd].pos += size;
#line 4831
  if (4 < dbglvl) {
#line 4831
    printf("%d\n", size);
  }
#line 4832
  return (size);
}
}
#line 4834 "D:/a/test/164.c"
int spec_putc(unsigned char ch , int fd ) 
{ struct _reent *tmp ;
  int tmp___0 ;

  {
#line 4835
  if (4 < dbglvl) {
#line 4835
    printf("spec_putc: %d, %d = ", ch, fd);
  }
#line 4836
  if (fd > 3) {
#line 4837
    tmp = __getreent();
#line 4837
    fprintf(tmp->_stderr, "spec_write: fd=%d, > MAX_SPEC_FD!\n", fd);
#line 4838
    exit(1);
  }
#line 4840
  tmp___0 = spec_fd[fd].pos;
#line 4840
  (spec_fd[fd].pos) ++;
#line 4840
  *(spec_fd[fd].buf + tmp___0) = ch;
#line 4841
  (spec_fd[fd].len) ++;
#line 4842
  return ((int )ch);
}
}
#line 4880 "D:/a/test/164.c"
void spec_initbufs(void) 
{ 

  {
#line 4881
  no_name = 0;
#line 4882
  no_time = 0;
#line 4883
  time_stamp = 0L;
#line 4884
  save_orig_name = 0;
#line 4885
  ifile_size = -1L;
#line 4886
  to_stdout = 1;
#line 4887
  return;
}
}
#line 4888 "D:/a/test/164.c"
void spec_compress(int in , int out , int lev ) 
{ 

  {
#line 4889
  level = lev;
#line 4890
  part_nb = 0;
#line 4891
  clear_bufs();
#line 4892
  ifd = in;
#line 4892
  ofd = out;
#line 4893
  zip(ifd, ofd);
#line 4894
  return;
}
}
#line 4895 "D:/a/test/164.c"
void spec_uncompress(int in , int out , int lev ) 
{ 

  {
#line 4896
  level = lev;
#line 4897
  part_nb = 0;
#line 4898
  clear_bufs();
#line 4899
  ifd = in;
#line 4899
  ofd = out;
#line 4900
  method = get_method(1);
#line 4901
  unzip(ifd, ofd);
#line 4902
  return;
}
}
#line 4906 "D:/a/test/164.c"
int debug_time(void) 
{ 

  {
#line 4914
  return (0);
}
}
#line 4930 "D:/a/test/164.c"
static int extra_lbits[29]  = 
#line 4930
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        1,      1,      1,      1, 
        2,      2,      2,      2, 
        3,      3,      3,      3, 
        4,      4,      4,      4, 
        5,      5,      5,      5, 
        0};
#line 4932 "D:/a/test/164.c"
static int extra_dbits[30]  = 
#line 4932
  {      0,      0,      0,      0, 
        1,      1,      2,      2, 
        3,      3,      4,      4, 
        5,      5,      6,      6, 
        7,      7,      8,      8, 
        9,      9,      10,      10, 
        11,      11,      12,      12, 
        13,      13};
#line 4934 "D:/a/test/164.c"
static int extra_blbits[19]  = 
#line 4934
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        2,      3,      7};
#line 4973 "D:/a/test/164.c"
static ct_data dyn_ltree[573]  ;
#line 4974 "D:/a/test/164.c"
static ct_data dyn_dtree[61]  ;
#line 4975 "D:/a/test/164.c"
static ct_data static_ltree[288]  ;
#line 4976 "D:/a/test/164.c"
static ct_data static_dtree[30]  ;
#line 4977 "D:/a/test/164.c"
static ct_data bl_tree[39]  ;
#line 4987 "D:/a/test/164.c"
static tree_desc l_desc  =    {dyn_ltree, static_ltree, extra_lbits, 257, 286, 15, 0};
#line 4989 "D:/a/test/164.c"
static tree_desc d_desc  =    {dyn_dtree, static_dtree, extra_dbits, 0, 30, 15, 0};
#line 4991 "D:/a/test/164.c"
static tree_desc bl_desc  =    {bl_tree, (ct_data *)0, extra_blbits, 0, 19, 7, 0};
#line 4993 "D:/a/test/164.c"
static ush bl_count[16]  ;
#line 4994 "D:/a/test/164.c"
static uch bl_order[19]  = 
#line 4994
  {      (uch )16,      (uch )17,      (uch )18,      (uch )0, 
        (uch )8,      (uch )7,      (uch )9,      (uch )6, 
        (uch )10,      (uch )5,      (uch )11,      (uch )4, 
        (uch )12,      (uch )3,      (uch )13,      (uch )2, 
        (uch )14,      (uch )1,      (uch )15};
#line 4996 "D:/a/test/164.c"
static int heap[573]  ;
#line 4997 "D:/a/test/164.c"
static int heap_len  ;
#line 4998 "D:/a/test/164.c"
static int heap_max  ;
#line 4999 "D:/a/test/164.c"
static uch depth[573]  ;
#line 5000 "D:/a/test/164.c"
static uch length_code[256]  ;
#line 5001 "D:/a/test/164.c"
static uch dist_code[512]  ;
#line 5002 "D:/a/test/164.c"
static int base_length[29]  ;
#line 5003 "D:/a/test/164.c"
static int base_dist[30]  ;
#line 5005 "D:/a/test/164.c"
static uch flag_buf[4096]  ;
#line 5006 "D:/a/test/164.c"
static unsigned int last_lit  ;
#line 5007 "D:/a/test/164.c"
static unsigned int last_dist  ;
#line 5008 "D:/a/test/164.c"
static unsigned int last_flags  ;
#line 5009 "D:/a/test/164.c"
static uch flags  ;
#line 5010 "D:/a/test/164.c"
static uch flag_bit  ;
#line 5011 "D:/a/test/164.c"
static ulg opt_len  ;
#line 5012 "D:/a/test/164.c"
static ulg static_len  ;
#line 5013 "D:/a/test/164.c"
static ulg compressed_len  ;
#line 5014 "D:/a/test/164.c"
static ulg input_len  ;
#line 5015 "D:/a/test/164.c"
ush *file_type  ;
#line 5016 "D:/a/test/164.c"
int *file_method  ;
#line 5023
static void init_block(void) ;
#line 5024
static void pqdownheap(ct_data *tree , int k ) ;
#line 5025
static void gen_bitlen(tree_desc *desc ) ;
#line 5026
static void gen_codes(ct_data *tree , int max_code ) ;
#line 5027
static void build_tree(tree_desc *desc ) ;
#line 5028
static void scan_tree(ct_data *tree , int max_code ) ;
#line 5029
static void send_tree(ct_data *tree , int max_code ) ;
#line 5030
static int build_bl_tree(void) ;
#line 5031
static void send_all_trees(int lcodes , int dcodes , int blcodes ) ;
#line 5032
static void compress_block(ct_data *ltree , ct_data *dtree ) ;
#line 5033
static void set_file_type(void) ;
#line 5044 "D:/a/test/164.c"
void ct_init(ush *attr , int *methodp ) 
{ int n ;
  int bits ;
  int length ;
  int code ;
  int dist ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 5053
  file_type = attr;
#line 5054
  file_method = methodp;
#line 5055
  input_len = 0UL;
#line 5055
  compressed_len = input_len;
#line 5056
  if ((int )static_dtree[0].dl.len != 0) {
#line 5056
    return;
  }
#line 5057
  length = 0;
#line 5058
  code = 0;
#line 5058
  while (code < 28) {
#line 5059
    base_length[code] = length;
#line 5060
    n = 0;
#line 5060
    while (n < 1 << extra_lbits[code]) {
#line 5061
      tmp = length;
#line 5061
      length ++;
#line 5061
      length_code[tmp] = (unsigned char )code;
#line 5060
      n ++;
    }
#line 5058
    code ++;
  }
#line 5065
  length_code[length - 1] = (unsigned char )code;
#line 5066
  dist = 0;
#line 5067
  code = 0;
#line 5067
  while (code < 16) {
#line 5068
    base_dist[code] = dist;
#line 5069
    n = 0;
#line 5069
    while (n < 1 << extra_dbits[code]) {
#line 5070
      tmp___0 = dist;
#line 5070
      dist ++;
#line 5070
      dist_code[tmp___0] = (unsigned char )code;
#line 5069
      n ++;
    }
#line 5067
    code ++;
  }
#line 5074
  dist >>= 7;
#line 5075
  while (code < 30) {
#line 5076
    base_dist[code] = dist << 7;
#line 5077
    n = 0;
#line 5077
    while (n < 1 << (extra_dbits[code] - 7)) {
#line 5078
      tmp___1 = dist;
#line 5078
      dist ++;
#line 5078
      dist_code[256 + tmp___1] = (unsigned char )code;
#line 5077
      n ++;
    }
#line 5075
    code ++;
  }
#line 5082
  bits = 0;
#line 5082
  while (bits <= 15) {
#line 5082
    bl_count[bits] = (unsigned short)0;
#line 5082
    bits ++;
  }
#line 5083
  n = 0;
#line 5084
  while (n <= 143) {
#line 5084
    tmp___2 = n;
#line 5084
    n ++;
#line 5084
    static_ltree[tmp___2].dl.len = (unsigned short)8;
#line 5084
    bl_count[8] = (ush )((int )bl_count[8] + 1);
  }
#line 5085
  while (n <= 255) {
#line 5085
    tmp___3 = n;
#line 5085
    n ++;
#line 5085
    static_ltree[tmp___3].dl.len = (unsigned short)9;
#line 5085
    bl_count[9] = (ush )((int )bl_count[9] + 1);
  }
#line 5086
  while (n <= 279) {
#line 5086
    tmp___4 = n;
#line 5086
    n ++;
#line 5086
    static_ltree[tmp___4].dl.len = (unsigned short)7;
#line 5086
    bl_count[7] = (ush )((int )bl_count[7] + 1);
  }
#line 5087
  while (n <= 287) {
#line 5087
    tmp___5 = n;
#line 5087
    n ++;
#line 5087
    static_ltree[tmp___5].dl.len = (unsigned short)8;
#line 5087
    bl_count[8] = (ush )((int )bl_count[8] + 1);
  }
#line 5088
  gen_codes(static_ltree, 287);
#line 5089
  n = 0;
#line 5089
  while (n < 30) {
#line 5090
    static_dtree[n].dl.len = (unsigned short)5;
#line 5091
    tmp___6 = bi_reverse((unsigned int )n, 5);
#line 5091
    static_dtree[n].fc.code = (unsigned short )tmp___6;
#line 5089
    n ++;
  }
#line 5093
  init_block();
#line 5094
  return;
}
}
#line 5095 "D:/a/test/164.c"
static void init_block(void) 
{ int n ;

  {
#line 5098
  n = 0;
#line 5098
  while (n < 286) {
#line 5098
    dyn_ltree[n].fc.freq = (unsigned short)0;
#line 5098
    n ++;
  }
#line 5099
  n = 0;
#line 5099
  while (n < 30) {
#line 5099
    dyn_dtree[n].fc.freq = (unsigned short)0;
#line 5099
    n ++;
  }
#line 5100
  n = 0;
#line 5100
  while (n < 19) {
#line 5100
    bl_tree[n].fc.freq = (unsigned short)0;
#line 5100
    n ++;
  }
#line 5101
  dyn_ltree[256].fc.freq = (unsigned short)1;
#line 5102
  static_len = 0UL;
#line 5102
  opt_len = static_len;
#line 5103
  last_flags = 0U;
#line 5103
  last_dist = last_flags;
#line 5103
  last_lit = last_dist;
#line 5104
  flags = (unsigned char)0;
#line 5104
  flag_bit = (unsigned char)1;
#line 5105
  return;
}
}
#line 5116 "D:/a/test/164.c"
static void pqdownheap(ct_data *tree , int k ) 
{ int v ;
  int j___0 ;

  {
#line 5120
  v = heap[k];
#line 5121
  j___0 = k << 1;
#line 5122
  while (j___0 <= heap_len) {
#line 5123
    if (j___0 < heap_len) {
#line 5123
      if ((int )(tree + heap[j___0 + 1])->fc.freq < (int )(tree + heap[j___0])->fc.freq) {
#line 5123
        j___0 ++;
      } else {
#line 5123
        if ((int )(tree + heap[j___0 + 1])->fc.freq == (int )(tree + heap[j___0])->fc.freq) {
#line 5123
          if ((int )depth[heap[j___0 + 1]] <= (int )depth[heap[j___0]]) {
#line 5123
            j___0 ++;
          }
        }
      }
    }
#line 5124
    if ((int )(tree + v)->fc.freq < (int )(tree + heap[j___0])->fc.freq) {
#line 5124
      break;
    } else {
#line 5124
      if ((int )(tree + v)->fc.freq == (int )(tree + heap[j___0])->fc.freq) {
#line 5124
        if ((int )depth[v] <= (int )depth[heap[j___0]]) {
#line 5124
          break;
        }
      }
    }
#line 5125
    heap[k] = heap[j___0];
#line 5125
    k = j___0;
#line 5126
    j___0 <<= 1;
  }
#line 5128
  heap[k] = v;
#line 5129
  return;
}
}
#line 5130 "D:/a/test/164.c"
static void gen_bitlen(tree_desc *desc ) 
{ ct_data *tree ;
  int *extra ;
  int base ;
  int max_code ;
  int max_length ;
  ct_data *stree ;
  int h ;
  int n ;
  int m ;
  int bits ;
  int xbits ;
  ush f ;
  int overflow ;

  {
#line 5133
  tree = desc->dyn_tree;
#line 5134
  extra = desc->extra_bits;
#line 5135
  base = desc->extra_base;
#line 5136
  max_code = desc->max_code;
#line 5137
  max_length = desc->max_length;
#line 5138
  stree = desc->static_tree;
#line 5144
  overflow = 0;
#line 5145
  bits = 0;
#line 5145
  while (bits <= 15) {
#line 5145
    bl_count[bits] = (unsigned short)0;
#line 5145
    bits ++;
  }
#line 5146
  (tree + heap[heap_max])->dl.len = (unsigned short)0;
#line 5147
  h = heap_max + 1;
#line 5147
  while (h < 573) {
#line 5148
    n = heap[h];
#line 5149
    bits = (int )(tree + (tree + n)->dl.dad)->dl.len + 1;
#line 5150
    if (bits > max_length) {
#line 5150
      bits = max_length;
#line 5150
      overflow ++;
    }
#line 5151
    (tree + n)->dl.len = (unsigned short )bits;
#line 5152
    if (n > max_code) {
      goto __Cont;
    }
#line 5153
    bl_count[bits] = (ush )((int )bl_count[bits] + 1);
#line 5154
    xbits = 0;
#line 5155
    if (n >= base) {
#line 5155
      xbits = *(extra + (n - base));
    }
#line 5156
    f = (tree + n)->fc.freq;
#line 5157
    opt_len += (unsigned long )f * (unsigned long )(bits + xbits);
#line 5158
    if (stree) {
#line 5158
      static_len += (unsigned long )f * (unsigned long )((int )(stree + n)->dl.len + xbits);
    }
    __Cont: /* CIL Label */ 
#line 5147
    h ++;
  }
#line 5160
  if (overflow == 0) {
#line 5160
    return;
  }
#line 5162
  while (1) {
#line 5163
    bits = max_length - 1;
#line 5164
    while ((int )bl_count[bits] == 0) {
#line 5164
      bits --;
    }
#line 5165
    bl_count[bits] = (ush )((int )bl_count[bits] - 1);
#line 5166
    bl_count[bits + 1] = (unsigned short )((int )bl_count[bits + 1] + 2);
#line 5167
    bl_count[max_length] = (ush )((int )bl_count[max_length] - 1);
#line 5168
    overflow -= 2;
#line 5162
    if (! (overflow > 0)) {
#line 5162
      break;
    }
  }
#line 5170
  bits = max_length;
#line 5170
  while (bits != 0) {
#line 5171
    n = (int )bl_count[bits];
#line 5172
    while (n != 0) {
#line 5173
      h --;
#line 5173
      m = heap[h];
#line 5174
      if (m > max_code) {
#line 5174
        continue;
      }
#line 5175
      if ((unsigned int )(tree + m)->dl.len != (unsigned int )bits) {
#line 5177
        opt_len += (ulg )(((long )bits - (long )(tree + m)->dl.len) * (long )(tree + m)->fc.freq);
#line 5178
        (tree + m)->dl.len = (unsigned short )bits;
      }
#line 5180
      n --;
    }
#line 5170
    bits --;
  }
#line 5183
  return;
}
}
#line 5184 "D:/a/test/164.c"
static void gen_codes(ct_data *tree , int max_code ) 
{ ush next_code[16] ;
  ush code ;
  int bits ;
  int n ;
  int len ;
  ush tmp ;
  unsigned int tmp___0 ;

  {
#line 5189
  code = (ush )0;
#line 5192
  bits = 1;
#line 5192
  while (bits <= 15) {
#line 5193
    code = (unsigned short )(((int )code + (int )bl_count[bits - 1]) << 1);
#line 5193
    next_code[bits] = code;
#line 5192
    bits ++;
  }
#line 5198
  n = 0;
#line 5198
  while (n <= max_code) {
#line 5199
    len = (int )(tree + n)->dl.len;
#line 5200
    if (len == 0) {
      goto __Cont;
    }
#line 5201
    tmp = next_code[len];
#line 5201
    next_code[len] = (ush )((int )next_code[len] + 1);
#line 5201
    tmp___0 = bi_reverse((unsigned int )tmp, len);
#line 5201
    (tree + n)->fc.code = (unsigned short )tmp___0;
    __Cont: /* CIL Label */ 
#line 5198
    n ++;
  }
#line 5205
  return;
}
}
#line 5206 "D:/a/test/164.c"
static void build_tree(tree_desc *desc ) 
{ ct_data *tree ;
  ct_data *stree ;
  int elems ;
  int n ;
  int m ;
  int max_code ;
  int node ;
  int new ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ush tmp___2 ;
  int tmp___3 ;

  {
#line 5209
  tree = desc->dyn_tree;
#line 5210
  stree = desc->static_tree;
#line 5211
  elems = desc->elems;
#line 5213
  max_code = -1;
#line 5214
  node = elems;
#line 5215
  heap_len = 0;
#line 5215
  heap_max = 573;
#line 5216
  n = 0;
#line 5216
  while (n < elems) {
#line 5217
    if ((int )(tree + n)->fc.freq != 0) {
#line 5218
      heap_len ++;
#line 5218
      max_code = n;
#line 5218
      heap[heap_len] = max_code;
#line 5219
      depth[n] = (unsigned char)0;
    } else {
#line 5221
      (tree + n)->dl.len = (unsigned short)0;
    }
#line 5216
    n ++;
  }
#line 5224
  while (heap_len < 2) {
#line 5225
    heap_len ++;
#line 5225
    if (max_code < 2) {
#line 5225
      max_code ++;
#line 5225
      tmp = max_code;
    } else {
#line 5225
      tmp = 0;
    }
#line 5225
    heap[heap_len] = tmp;
#line 5225
    new = tmp;
#line 5226
    (tree + new)->fc.freq = (unsigned short)1;
#line 5227
    depth[new] = (unsigned char)0;
#line 5228
    opt_len --;
#line 5228
    if (stree) {
#line 5228
      static_len -= (ulg )(stree + new)->dl.len;
    }
  }
#line 5230
  desc->max_code = max_code;
#line 5231
  n = heap_len / 2;
#line 5231
  while (n >= 1) {
#line 5231
    pqdownheap(tree, n);
#line 5231
    n --;
  }
#line 5232
  while (1) {
#line 5233
    n = heap[1];
#line 5233
    tmp___0 = heap_len;
#line 5233
    heap_len --;
#line 5233
    heap[1] = heap[tmp___0];
#line 5233
    pqdownheap(tree, 1);
#line 5234
    m = heap[1];
#line 5235
    heap_max --;
#line 5235
    heap[heap_max] = n;
#line 5236
    heap_max --;
#line 5236
    heap[heap_max] = m;
#line 5237
    (tree + node)->fc.freq = (unsigned short )((int )(tree + n)->fc.freq + (int )(tree + m)->fc.freq);
#line 5238
    if ((int )depth[n] >= (int )depth[m]) {
#line 5238
      tmp___1 = (int )depth[n];
    } else {
#line 5238
      tmp___1 = (int )depth[m];
    }
#line 5238
    depth[node] = (unsigned char )(tmp___1 + 1);
#line 5239
    tmp___2 = (unsigned short )node;
#line 5239
    (tree + m)->dl.dad = tmp___2;
#line 5239
    (tree + n)->dl.dad = tmp___2;
#line 5246
    tmp___3 = node;
#line 5246
    node ++;
#line 5246
    heap[1] = tmp___3;
#line 5247
    pqdownheap(tree, 1);
#line 5232
    if (! (heap_len >= 2)) {
#line 5232
      break;
    }
  }
#line 5249
  heap_max --;
#line 5249
  heap[heap_max] = heap[1];
#line 5250
  gen_bitlen(desc);
#line 5251
  gen_codes(tree, max_code);
#line 5252
  return;
}
}
#line 5253 "D:/a/test/164.c"
static void scan_tree(ct_data *tree , int max_code ) 
{ int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;

  {
#line 5258
  prevlen = -1;
#line 5260
  nextlen = (int )(tree + 0)->dl.len;
#line 5261
  count = 0;
#line 5262
  max_count = 7;
#line 5263
  min_count = 4;
#line 5264
  if (nextlen == 0) {
#line 5264
    max_count = 138;
#line 5264
    min_count = 3;
  }
#line 5265
  (tree + (max_code + 1))->dl.len = (unsigned short)65535;
#line 5266
  n = 0;
#line 5266
  while (n <= max_code) {
#line 5267
    curlen = nextlen;
#line 5267
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 5268
    count ++;
#line 5268
    if (count < max_count) {
#line 5268
      if (curlen == nextlen) {
        goto __Cont;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 5270
      if (count < min_count) {
#line 5271
        bl_tree[curlen].fc.freq = (unsigned short )((int )bl_tree[curlen].fc.freq + count);
      } else {
#line 5272
        if (curlen != 0) {
#line 5273
          if (curlen != prevlen) {
#line 5273
            bl_tree[curlen].fc.freq = (ush )((int )bl_tree[curlen].fc.freq + 1);
          }
#line 5274
          bl_tree[16].fc.freq = (ush )((int )bl_tree[16].fc.freq + 1);
        } else {
#line 5275
          if (count <= 10) {
#line 5276
            bl_tree[17].fc.freq = (ush )((int )bl_tree[17].fc.freq + 1);
          } else {
#line 5278
            bl_tree[18].fc.freq = (ush )((int )bl_tree[18].fc.freq + 1);
          }
        }
      }
    }
#line 5280
    count = 0;
#line 5280
    prevlen = curlen;
#line 5281
    if (nextlen == 0) {
#line 5282
      max_count = 138;
#line 5282
      min_count = 3;
    } else {
#line 5283
      if (curlen == nextlen) {
#line 5284
        max_count = 6;
#line 5284
        min_count = 3;
      } else {
#line 5286
        max_count = 7;
#line 5286
        min_count = 4;
      }
    }
    __Cont: /* CIL Label */ 
#line 5266
    n ++;
  }
#line 5289
  return;
}
}
#line 5290 "D:/a/test/164.c"
static void send_tree(ct_data *tree , int max_code ) 
{ int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;
  struct _reent *tmp ;
  struct _reent *tmp___0 ;
  struct _reent *tmp___1 ;
  struct _reent *tmp___2 ;
  struct _reent *tmp___3 ;

  {
#line 5295
  prevlen = -1;
#line 5297
  nextlen = (int )(tree + 0)->dl.len;
#line 5298
  count = 0;
#line 5299
  max_count = 7;
#line 5300
  min_count = 4;
#line 5301
  if (nextlen == 0) {
#line 5301
    max_count = 138;
#line 5301
    min_count = 3;
  }
#line 5302
  n = 0;
#line 5302
  while (n <= max_code) {
#line 5303
    curlen = nextlen;
#line 5303
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 5304
    count ++;
#line 5304
    if (count < max_count) {
#line 5304
      if (curlen == nextlen) {
        goto __Cont;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 5306
      if (count < min_count) {
#line 5307
        while (1) {
#line 5307
          if (verbose > 1) {
#line 5307
            tmp = __getreent();
#line 5307
            fprintf(tmp->_stderr, "\ncd %3d ", curlen);
          }
#line 5307
          send_bits((int )bl_tree[curlen].fc.code, (int )bl_tree[curlen].dl.len);
#line 5307
          count --;
#line 5307
          if (! (count != 0)) {
#line 5307
            break;
          }
        }
      } else {
#line 5308
        if (curlen != 0) {
#line 5309
          if (curlen != prevlen) {
#line 5310
            if (verbose > 1) {
#line 5310
              tmp___0 = __getreent();
#line 5310
              fprintf(tmp___0->_stderr, "\ncd %3d ", curlen);
            }
#line 5310
            send_bits((int )bl_tree[curlen].fc.code, (int )bl_tree[curlen].dl.len);
#line 5310
            count --;
          }
#line 5313
          if (verbose > 1) {
#line 5313
            tmp___1 = __getreent();
#line 5313
            fprintf(tmp___1->_stderr, "\ncd %3d ", 16);
          }
#line 5313
          send_bits((int )bl_tree[16].fc.code, (int )bl_tree[16].dl.len);
#line 5313
          send_bits(count - 3, 2);
        } else {
#line 5314
          if (count <= 10) {
#line 5315
            if (verbose > 1) {
#line 5315
              tmp___2 = __getreent();
#line 5315
              fprintf(tmp___2->_stderr, "\ncd %3d ", 17);
            }
#line 5315
            send_bits((int )bl_tree[17].fc.code, (int )bl_tree[17].dl.len);
#line 5315
            send_bits(count - 3, 3);
          } else {
#line 5317
            if (verbose > 1) {
#line 5317
              tmp___3 = __getreent();
#line 5317
              fprintf(tmp___3->_stderr, "\ncd %3d ", 18);
            }
#line 5317
            send_bits((int )bl_tree[18].fc.code, (int )bl_tree[18].dl.len);
#line 5317
            send_bits(count - 11, 7);
          }
        }
      }
    }
#line 5319
    count = 0;
#line 5319
    prevlen = curlen;
#line 5320
    if (nextlen == 0) {
#line 5321
      max_count = 138;
#line 5321
      min_count = 3;
    } else {
#line 5322
      if (curlen == nextlen) {
#line 5323
        max_count = 6;
#line 5323
        min_count = 3;
      } else {
#line 5325
        max_count = 7;
#line 5325
        min_count = 4;
      }
    }
    __Cont: /* CIL Label */ 
#line 5302
    n ++;
  }
#line 5328
  return;
}
}
#line 5329 "D:/a/test/164.c"
static int build_bl_tree(void) 
{ int max_blindex ;

  {
#line 5332
  scan_tree(dyn_ltree, l_desc.max_code);
#line 5333
  scan_tree(dyn_dtree, d_desc.max_code);
#line 5334
  build_tree(& bl_desc);
#line 5335
  max_blindex = 18;
#line 5335
  while (max_blindex >= 3) {
#line 5336
    if ((int )bl_tree[bl_order[max_blindex]].dl.len != 0) {
#line 5336
      break;
    }
#line 5335
    max_blindex --;
  }
#line 5338
  opt_len += (ulg )(((3 * (max_blindex + 1) + 5) + 5) + 4);
#line 5340
  return (max_blindex);
}
}
#line 5342 "D:/a/test/164.c"
static void send_all_trees(int lcodes , int dcodes , int blcodes ) 
{ int rank ;

  {
#line 5350
  send_bits(lcodes - 257, 5);
#line 5351
  send_bits(dcodes - 1, 5);
#line 5352
  send_bits(blcodes - 4, 4);
#line 5353
  rank = 0;
#line 5353
  while (rank < blcodes) {
#line 5355
    send_bits((int )bl_tree[bl_order[rank]].dl.len, 3);
#line 5353
    rank ++;
  }
#line 5358
  send_tree(dyn_ltree, lcodes - 1);
#line 5360
  send_tree(dyn_dtree, dcodes - 1);
#line 5362
  return;
}
}
#line 5363 "D:/a/test/164.c"
ulg flush_block(char *buf , ulg stored_len , int eof ) 
{ ulg opt_lenb ;
  ulg static_lenb ;
  int max_blindex ;

  {
#line 5370
  flag_buf[last_flags] = flags;
#line 5371
  if ((int )*file_type == 65535) {
#line 5371
    set_file_type();
  }
#line 5372
  build_tree(& l_desc);
#line 5374
  build_tree(& d_desc);
#line 5376
  max_blindex = build_bl_tree();
#line 5377
  opt_lenb = ((opt_len + 3UL) + 7UL) >> 3;
#line 5378
  static_lenb = ((static_len + 3UL) + 7UL) >> 3;
#line 5379
  input_len += stored_len;
#line 5383
  if (static_lenb <= opt_lenb) {
#line 5383
    opt_lenb = static_lenb;
  }
#line 5387
  if (stored_len <= opt_lenb) {
#line 5387
    if (eof) {
#line 5387
      if (compressed_len == 0UL) {
        goto _L___2;
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 5396
    if (stored_len + 4UL <= opt_lenb) {
#line 5396
      if ((unsigned int )buf != (unsigned int )((char *)0)) {
#line 5398
        send_bits(eof, 3);
#line 5399
        compressed_len = ((compressed_len + 3UL) + 7UL) & 4294967288UL;
#line 5400
        compressed_len += (stored_len + 4UL) << 3;
#line 5401
        copy_block(buf, (unsigned int )stored_len, 1);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 5405
      if (static_lenb == opt_lenb) {
#line 5407
        send_bits((1 << 1) + eof, 3);
#line 5408
        compress_block(static_ltree, static_dtree);
#line 5409
        compressed_len += 3UL + static_len;
      } else {
#line 5411
        send_bits((2 << 1) + eof, 3);
#line 5412
        send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
#line 5413
        compress_block(dyn_ltree, dyn_dtree);
#line 5414
        compressed_len += 3UL + opt_len;
      }
    }
  }
#line 5417
  init_block();
#line 5418
  if (eof) {
#line 5420
    bi_windup();
#line 5421
    compressed_len += 7UL;
  }
#line 5425
  return (compressed_len >> 3);
}
}
#line 5427 "D:/a/test/164.c"
int ct_tally(int dist , int lc ) 
{ unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  ulg out_length ;
  ulg in_length ;
  int dcode ;
  int tmp___3 ;

  {
#line 5431
  tmp = last_lit;
#line 5431
  last_lit ++;
#line 5431
  *(inbuf + tmp) = (unsigned char )lc;
#line 5432
  if (dist == 0) {
#line 5433
    dyn_ltree[lc].fc.freq = (ush )((int )dyn_ltree[lc].fc.freq + 1);
  } else {
#line 5435
    dist --;
#line 5439
    dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq = (ush )((int )dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq + 1);
#line 5440
    if (dist < 256) {
#line 5440
      tmp___0 = (int )dist_code[dist];
    } else {
#line 5440
      tmp___0 = (int )dist_code[256 + (dist >> 7)];
    }
#line 5440
    dyn_dtree[tmp___0].fc.freq = (ush )((int )dyn_dtree[tmp___0].fc.freq + 1);
#line 5441
    tmp___1 = last_dist;
#line 5441
    last_dist ++;
#line 5441
    *(d_buf + tmp___1) = (unsigned short )dist;
#line 5442
    flags = (unsigned char )((int )flags | (int )flag_bit);
  }
#line 5444
  flag_bit = (unsigned char )((int )flag_bit << 1);
#line 5445
  if ((last_lit & 7U) == 0U) {
#line 5446
    tmp___2 = last_flags;
#line 5446
    last_flags ++;
#line 5446
    flag_buf[tmp___2] = flags;
#line 5447
    flags = (unsigned char)0;
#line 5447
    flag_bit = (unsigned char)1;
  }
#line 5449
  if (level > 2) {
#line 5449
    if ((last_lit & 4095U) == 0U) {
#line 5450
      out_length = (unsigned long )last_lit * 8UL;
#line 5451
      in_length = (unsigned long )strstart - (unsigned long )block_start;
#line 5453
      dcode = 0;
#line 5453
      while (dcode < 30) {
#line 5454
        out_length += (unsigned long )dyn_dtree[dcode].fc.freq * (unsigned long )(5L + (long )extra_dbits[dcode]);
#line 5453
        dcode ++;
      }
#line 5456
      out_length >>= 3;
#line 5460
      if (last_dist < last_lit / 2U) {
#line 5460
        if (out_length < in_length / 2UL) {
#line 5460
          return (1);
        }
      }
    }
  }
#line 5462
  if (last_lit == 32767U) {
#line 5462
    tmp___3 = 1;
  } else {
#line 5462
    if (last_dist == 32768U) {
#line 5462
      tmp___3 = 1;
    } else {
#line 5462
      tmp___3 = 0;
    }
  }
#line 5462
  return (tmp___3);
}
}
#line 5464 "D:/a/test/164.c"
static void compress_block(ct_data *ltree , ct_data *dtree ) 
{ unsigned int dist ;
  int lc ;
  unsigned int lx ;
  unsigned int dx ;
  unsigned int fx ;
  uch flag ;
  unsigned int code ;
  int extra ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  struct _reent *tmp___1 ;
  struct _reent *tmp___2 ;
  unsigned int tmp___3 ;
  struct _reent *tmp___4 ;
  struct _reent *tmp___5 ;

  {
#line 5470
  lx = 0U;
#line 5471
  dx = 0U;
#line 5472
  fx = 0U;
#line 5473
  flag = (uch )0;
#line 5476
  if (last_lit != 0U) {
#line 5476
    while (1) {
#line 5477
      if ((lx & 7U) == 0U) {
#line 5477
        tmp = fx;
#line 5477
        fx ++;
#line 5477
        flag = flag_buf[tmp];
      }
#line 5478
      tmp___0 = lx;
#line 5478
      lx ++;
#line 5478
      lc = (int )*(inbuf + tmp___0);
#line 5479
      if (((int )flag & 1) == 0) {
#line 5480
        if (verbose > 1) {
#line 5480
          tmp___1 = __getreent();
#line 5480
          fprintf(tmp___1->_stderr, "\ncd %3d ", lc);
        }
#line 5480
        send_bits((int )(ltree + lc)->fc.code, (int )(ltree + lc)->dl.len);
      } else {
#line 5483
        code = (unsigned int )length_code[lc];
#line 5484
        if (verbose > 1) {
#line 5484
          tmp___2 = __getreent();
#line 5484
          fprintf(tmp___2->_stderr, "\ncd %3d ", (code + 256U) + 1U);
        }
#line 5484
        send_bits((int )(ltree + ((code + 256U) + 1U))->fc.code, (int )(ltree + ((code + 256U) + 1U))->dl.len);
#line 5485
        extra = extra_lbits[code];
#line 5486
        if (extra != 0) {
#line 5487
          lc -= base_length[code];
#line 5488
          send_bits(lc, extra);
        }
#line 5490
        tmp___3 = dx;
#line 5490
        dx ++;
#line 5490
        dist = (unsigned int )*(d_buf + tmp___3);
#line 5491
        if (dist < 256U) {
#line 5491
          code = (unsigned int )dist_code[dist];
        } else {
#line 5491
          code = (unsigned int )dist_code[256U + (dist >> 7)];
        }
#line 5493
        if (verbose > 1) {
#line 5493
          tmp___4 = __getreent();
#line 5493
          fprintf(tmp___4->_stderr, "\ncd %3d ", code);
        }
#line 5493
        send_bits((int )(dtree + code)->fc.code, (int )(dtree + code)->dl.len);
#line 5494
        extra = extra_dbits[code];
#line 5495
        if (extra != 0) {
#line 5496
          dist -= (unsigned int )base_dist[code];
#line 5497
          send_bits((int )dist, extra);
        }
      }
#line 5500
      flag = (unsigned char )((int )flag >> 1);
#line 5476
      if (! (lx < last_lit)) {
#line 5476
        break;
      }
    }
  }
#line 5502
  if (verbose > 1) {
#line 5502
    tmp___5 = __getreent();
#line 5502
    fprintf(tmp___5->_stderr, "\ncd %3d ", 256);
  }
#line 5502
  send_bits((int )(ltree + 256)->fc.code, (int )(ltree + 256)->dl.len);
#line 5503
  return;
}
}
#line 5504 "D:/a/test/164.c"
static void set_file_type(void) 
{ int n ;
  unsigned int ascii_freq ;
  unsigned int bin_freq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 5506
  n = 0;
#line 5507
  ascii_freq = 0U;
#line 5508
  bin_freq = 0U;
#line 5509
  while (n < 7) {
#line 5509
    tmp = n;
#line 5509
    n ++;
#line 5509
    bin_freq += (unsigned int )dyn_ltree[tmp].fc.freq;
  }
#line 5510
  while (n < 128) {
#line 5510
    tmp___0 = n;
#line 5510
    n ++;
#line 5510
    ascii_freq += (unsigned int )dyn_ltree[tmp___0].fc.freq;
  }
#line 5511
  while (n < 256) {
#line 5511
    tmp___1 = n;
#line 5511
    n ++;
#line 5511
    bin_freq += (unsigned int )dyn_ltree[tmp___1].fc.freq;
  }
#line 5512
  if (bin_freq > ascii_freq >> 2) {
#line 5512
    *file_type = (unsigned short)0;
  } else {
#line 5512
    *file_type = (unsigned short)1;
  }
#line 5513
  if ((int )*file_type == 0) {

  }
#line 5516
  return;
}
}
