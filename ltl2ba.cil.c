/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 14 "/usr/include/sys/lock.h"
typedef void *_LOCK_T;
#line 15 "/usr/include/sys/_types.h"
typedef long long _off64_t;
#line 18 "/usr/include/sys/_types.h"
typedef int _ssize_t;
#line 354 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int wint_t;
#line 27 "/usr/include/sys/_types.h"
union __anonunion___value_2 {
   wint_t __wch ;
   unsigned char __wchb[4] ;
};
#line 27 "/usr/include/sys/_types.h"
struct __anonstruct__mbstate_t_1 {
   int __count ;
   union __anonunion___value_2 __value ;
};
#line 27 "/usr/include/sys/_types.h"
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
#line 37 "/usr/include/sys/_types.h"
typedef _LOCK_T _flock_t;
#line 19 "/usr/include/sys/reent.h"
typedef unsigned long __ULong;
#line 40 "/usr/include/sys/reent.h"
struct _Bigint {
   struct _Bigint *_next ;
   int _k ;
   int _maxwds ;
   int _sign ;
   int _wds ;
   __ULong _x[1] ;
};
#line 48 "/usr/include/sys/reent.h"
struct __tm {
   int __tm_sec ;
   int __tm_min ;
   int __tm_hour ;
   int __tm_mday ;
   int __tm_mon ;
   int __tm_year ;
   int __tm_wday ;
   int __tm_yday ;
   int __tm_isdst ;
};
#line 67 "/usr/include/sys/reent.h"
struct _on_exit_args {
   void *_fnargs[32] ;
   void *_dso_handle[32] ;
   __ULong _fntypes ;
   __ULong _is_cxa ;
};
#line 85 "/usr/include/sys/reent.h"
struct _atexit {
   struct _atexit *_next ;
   int _ind ;
   void (*_fns[32])(void) ;
   struct _on_exit_args _on_exit_args ;
};
#line 101 "/usr/include/sys/reent.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 111 "/usr/include/sys/reent.h"
typedef long _fpos_t;
#line 115 "/usr/include/sys/reent.h"
typedef _off64_t _fpos64_t;
#line 166
struct _reent;
#line 214 "/usr/include/sys/reent.h"
struct __sFILE64 {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   struct _reent *_data ;
   void *_cookie ;
   _ssize_t ( __attribute__((__cdecl__)) (*_read))(void *_cookie , char *_buf , int _n ) ;
   _ssize_t ( __attribute__((__cdecl__)) (*_write))(void *_cookie , char const   *_buf ,
                                                    int _n ) ;
   _fpos_t ( __attribute__((__cdecl__)) (*_seek))(void *_cookie , _fpos_t _offset ,
                                                  int _whence ) ;
   int ( __attribute__((__cdecl__)) (*_close))(void *_cookie ) ;
   struct __sbuf _ub ;
   unsigned char *_up ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   int _flags2 ;
   _off64_t _offset ;
   _fpos64_t ( __attribute__((__cdecl__)) (*_seek64))(void *_cookie , _fpos64_t _offset ,
                                                      int _whence ) ;
   _flock_t _lock ;
};
#line 257 "/usr/include/sys/reent.h"
typedef struct __sFILE64 __FILE;
#line 262 "/usr/include/sys/reent.h"
struct _glue {
   struct _glue *_next ;
   int _niobs ;
   __FILE *_iobs ;
};
#line 290 "/usr/include/sys/reent.h"
struct _rand48 {
   unsigned short _seed[3] ;
   unsigned short _mult[3] ;
   unsigned short _add ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__reent_4 {
   unsigned int _unused_rand ;
   char *_strtok_last ;
   char _asctime_buf[26] ;
   struct __tm _localtime_buf ;
   int _gamma_signgam ;
   unsigned long long _rand_next ;
   struct _rand48 _r48 ;
   _mbstate_t _mblen_state ;
   _mbstate_t _mbtowc_state ;
   _mbstate_t _wctomb_state ;
   char _l64a_buf[8] ;
   char _signal_buf[24] ;
   int _getdate_err ;
   _mbstate_t _mbrlen_state ;
   _mbstate_t _mbrtowc_state ;
   _mbstate_t _mbsrtowcs_state ;
   _mbstate_t _wcrtomb_state ;
   _mbstate_t _wcsrtombs_state ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__unused_5 {
   unsigned char *_nextf[30] ;
   unsigned int _nmalloc[30] ;
};
#line 565 "/usr/include/sys/reent.h"
union __anonunion__new_3 {
   struct __anonstruct__reent_4 _reent ;
   struct __anonstruct__unused_5 _unused ;
};
#line 565 "/usr/include/sys/reent.h"
struct _reent {
   int _errno ;
   __FILE *_stdin ;
   __FILE *_stdout ;
   __FILE *_stderr ;
   int _inc ;
   char _emergency[25] ;
   int _current_category ;
   char const   *_current_locale ;
   int __sdidinit ;
   void ( __attribute__((__cdecl__)) (*__cleanup))(struct _reent * ) ;
   struct _Bigint *_result ;
   int _result_k ;
   struct _Bigint *_p5s ;
   struct _Bigint **_freelist ;
   int _cvtlen ;
   char *_cvtbuf ;
   union __anonunion__new_3 _new ;
   struct _atexit *_atexit ;
   struct _atexit _atexit0 ;
   void (**_sig_func)(int  ) ;
   struct _glue __sglue ;
   __FILE __sf[3] ;
};
#line 50 "/usr/include/stdio.h"
typedef __FILE FILE;
#line 39 "ltl2ba.h"
struct Symbol {
   char *name ;
   struct Symbol *next ;
};
#line 44 "ltl2ba.h"
struct Node {
   short ntyp ;
   struct Symbol *sym ;
   struct Node *lft ;
   struct Node *rgt ;
   struct Node *nxt ;
};
#line 44 "ltl2ba.h"
typedef struct Node Node;
#line 74 "ltl2ba.h"
struct ATrans {
   int *to ;
   int *pos ;
   int *neg ;
   struct ATrans *nxt ;
};
#line 74 "ltl2ba.h"
typedef struct ATrans ATrans;
#line 90
struct GState;
#line 90 "ltl2ba.h"
struct GTrans {
   int *pos ;
   int *neg ;
   struct GState *to ;
   int *final ;
   struct GTrans *nxt ;
};
#line 90 "ltl2ba.h"
typedef struct GTrans GTrans;
#line 98 "ltl2ba.h"
struct GState {
   int id ;
   int incoming ;
   int *nodes_set ;
   struct GTrans *trans ;
   struct GState *nxt ;
   struct GState *prv ;
};
#line 98 "ltl2ba.h"
typedef struct GState GState;
#line 107
struct BState;
#line 107 "ltl2ba.h"
struct BTrans {
   struct BState *to ;
   int *pos ;
   int *neg ;
   struct BTrans *nxt ;
};
#line 107 "ltl2ba.h"
typedef struct BTrans BTrans;
#line 114 "ltl2ba.h"
struct BState {
   struct GState *gstate ;
   int id ;
   int incoming ;
   int final ;
   struct BTrans *trans ;
   struct BState *nxt ;
   struct BState *prv ;
};
#line 114 "ltl2ba.h"
typedef struct BState BState;
#line 131 "ltl2ba.h"
struct BScc {
   struct BState *bstate ;
   int rank ;
   int theta ;
   struct BScc *nxt ;
};
#line 131 "ltl2ba.h"
typedef struct BScc BScc;
#line 35 "cache.cpp"
struct Cache {
   Node *before ;
   Node *after ;
   int same ;
   struct Cache *nxt ;
};
#line 35 "cache.cpp"
typedef struct Cache Cache;
#line 81 "ltl2ba.h"
struct AProd {
   int astate ;
   struct ATrans *prod ;
   struct ATrans *trans ;
   struct AProd *nxt ;
   struct AProd *prv ;
};
#line 81 "ltl2ba.h"
typedef struct AProd AProd;
#line 124 "ltl2ba.h"
struct GScc {
   struct GState *gstate ;
   int rank ;
   int theta ;
   struct GScc *nxt ;
};
#line 124 "ltl2ba.h"
typedef struct GScc GScc;
#line 213 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int size_t;
#line 39 "ltl2ba.h"
typedef struct Symbol Symbol;
#line 238 "ltl2ba.h"
typedef Node *Nodeptr;
#line 61 "mem.cpp"
union M {
   long size ;
   union M *link ;
};
#line 1 "alternating.o"
#pragma merger(0,"./alternating.i","")
#line 177 "/usr/include/stdio.h"
//extern int ( __attribute__((__cdecl__)) fprintf)(FILE * , char const   *  , ...) ;
#line 29 "/usr/include/string.h"
extern int ( __attribute__((__cdecl__)) strcmp)(char const   * , char const   * ) ;
#line 174 "ltl2ba.h"
int isequal(Node *a , Node *b ) ;
#line 177
void *tl_emalloc(int U ) ;
#line 178
ATrans *emalloc_atrans(void) ;
#line 179
void free_atrans(ATrans *t , int rec ) ;
#line 188
void dump(Node *n ) ;
#line 192
void releasenode(int all_levels , Node *n ) ;
#line 193
void tfree(void *v ) ;
#line 200
void mk_alternating(Node *p ) ;
#line 204
ATrans *dup_trans(ATrans *trans___0 ) ;
#line 205
ATrans *merge_trans(ATrans *trans1 , ATrans *trans2 ) ;
#line 206
void do_merge_trans(ATrans **result , ATrans *trans1 , ATrans *trans2 ) ;
#line 209
int *clear_set(int *l , int type ) ;
#line 210
int *make_set(int n , int type ) ;
#line 211
void copy_set(int *from , int *to , int type ) ;
#line 213
void merge_sets(int *l1 , int *l2 , int type ) ;
#line 214
void do_merge_sets(int *l , int *l1 , int *l2 , int type ) ;
#line 216
void add_set(int *l , int n ) ;
#line 219
void print_set(int *l , int type ) ;
#line 220
int empty_set(int *l , int type ) ;
#line 221
int empty_intersect_sets(int *l1 , int *l2 , int type ) ;
#line 223
int included_set(int *l1 , int *l2 , int type ) ;
#line 224
int in_set(int *l , int n ) ;
#line 36 "alternating.cpp"
FILE *tl_out ;
#line 37
int tl_verbose ;
#line 37
int tl_stats ;
#line 37
int tl_simp_diff ;
#line 39 "alternating.cpp"
Node **label  ;
#line 40 "alternating.cpp"
char **sym_table  ;
#line 41 "alternating.cpp"
ATrans **transition  ;
#line 44 "alternating.cpp"
int *final_set  ;
#line 44 "alternating.cpp"
int node_id  =    1;
#line 44 "alternating.cpp"
int sym_id  =    0;
#line 44 "alternating.cpp"
int node_size  ;
#line 44 "alternating.cpp"
int sym_size  ;
#line 45 "alternating.cpp"
int astate_count  =    0;
#line 45 "alternating.cpp"
int atrans_count  =    0;
#line 47
ATrans *build_alternating(Node *p ) ;
#line 53 "alternating.cpp"
int calculate_node_size(Node *p ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 55
  switch ((int )p->ntyp) {
  case 258: 
  case 264: 
  case 267: 
  case 268: 
#line 60
  tmp = calculate_node_size(p->lft);
#line 60
  tmp___0 = calculate_node_size(p->rgt);
#line 60
  return ((tmp + tmp___0) + 1);
  default: ;
#line 66
  return (1);
#line 67
  break;
  }
#line 69
  return (0);
}
}
#line 71 "alternating.cpp"
int calculate_sym_size(Node *p ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 73
  switch ((int )p->ntyp) {
  case 258: 
  case 264: 
  case 267: 
  case 268: 
#line 78
  tmp = calculate_sym_size(p->lft);
#line 78
  tmp___0 = calculate_sym_size(p->rgt);
#line 78
  return (tmp + tmp___0);
  case 263: 
  case 265: 
#line 85
  return (1);
  default: ;
#line 87
  return (0);
  }
}
}
#line 91 "alternating.cpp"
ATrans *dup_trans(ATrans *trans___0 ) 
{ ATrans *result ;

  {
#line 94
  if (! trans___0) {
#line 94
    return (trans___0);
  }
#line 95
  result = emalloc_atrans();
#line 96
  copy_set(trans___0->to, result->to, 0);
#line 97
  copy_set(trans___0->pos, result->pos, 1);
#line 98
  copy_set(trans___0->neg, result->neg, 1);
#line 99
  return (result);
}
}
#line 102 "alternating.cpp"
void do_merge_trans(ATrans **result , ATrans *trans1 , ATrans *trans2 ) 
{ int tmp ;

  {
#line 104
  if (! trans1) {
#line 105
    free_atrans(*result, 0);
#line 106
    *result = (ATrans *)0;
#line 107
    return;
  } else {
#line 104
    if (! trans2) {
#line 105
      free_atrans(*result, 0);
#line 106
      *result = (ATrans *)0;
#line 107
      return;
    }
  }
#line 109
  if (! *result) {
#line 110
    *result = emalloc_atrans();
  }
#line 111
  do_merge_sets((*result)->to, trans1->to, trans2->to, 0);
#line 112
  do_merge_sets((*result)->pos, trans1->pos, trans2->pos, 1);
#line 113
  do_merge_sets((*result)->neg, trans1->neg, trans2->neg, 1);
#line 114
  tmp = empty_intersect_sets((*result)->pos, (*result)->neg, 1);
#line 114
  if (! tmp) {
#line 115
    free_atrans(*result, 0);
#line 116
    *result = (ATrans *)0;
  }
#line 118
  return;
}
}
#line 120 "alternating.cpp"
ATrans *merge_trans(ATrans *trans1 , ATrans *trans2 ) 
{ ATrans *result ;
  ATrans *tmp ;

  {
#line 122
  tmp = emalloc_atrans();
#line 122
  result = tmp;
#line 123
  do_merge_trans(& result, trans1, trans2);
#line 124
  return (result);
}
}
#line 127 "alternating.cpp"
int already_done(Node *p ) 
{ int i ;
  int tmp ;

  {
#line 130
  i = 1;
#line 130
  while (i < node_id) {
#line 131
    tmp = isequal(p, *(label + i));
#line 131
    if (tmp) {
#line 132
      return (i);
    }
#line 130
    i ++;
  }
#line 133
  return (-1);
}
}
#line 136 "alternating.cpp"
int get_sym_id(char *s ) 
{ int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 139
  i = 0;
#line 139
  while (i < sym_id) {
#line 140
    tmp = strcmp((char const   *)s, (char const   *)*(sym_table + i));
#line 140
    if (! tmp) {
#line 141
      return (i);
    }
#line 139
    i ++;
  }
#line 142
  *(sym_table + sym_id) = s;
#line 143
  tmp___0 = sym_id;
#line 143
  sym_id ++;
#line 143
  return (tmp___0);
}
}
#line 146 "alternating.cpp"
ATrans *boolean(Node *p ) 
{ ATrans *t1 ;
  ATrans *t2 ;
  ATrans *lft ;
  ATrans *rgt ;
  ATrans *result ;
  ATrans *tmp ;
  ATrans *tmp___0 ;
  ATrans *tmp___1 ;
  ATrans *tmp___2 ;
  ATrans *tmp___3 ;
  ATrans *tmp___4 ;
  int tmp___5 ;

  {
#line 148
  result = (ATrans *)0;
#line 150
  switch ((int )p->ntyp) {
  case 266: 
#line 152
  result = emalloc_atrans();
#line 153
  clear_set(result->to, 0);
#line 154
  clear_set(result->pos, 1);
#line 155
  clear_set(result->neg, 1);
  case 261: 
#line 157
  break;
  case 258: 
#line 159
  lft = boolean(p->lft);
#line 160
  rgt = boolean(p->rgt);
#line 161
  t1 = lft;
#line 161
  while (t1) {
#line 162
    t2 = rgt;
#line 162
    while (t2) {
#line 163
      tmp___0 = merge_trans(t1, t2);
#line 163
      tmp = tmp___0;
#line 164
      if (tmp) {
#line 165
        tmp->nxt = result;
#line 166
        result = tmp;
      }
#line 162
      t2 = t2->nxt;
    }
#line 161
    t1 = t1->nxt;
  }
#line 170
  free_atrans(lft, 1);
#line 171
  free_atrans(rgt, 1);
#line 172
  break;
  case 264: 
#line 174
  lft = boolean(p->lft);
#line 175
  t1 = lft;
#line 175
  while (t1) {
#line 176
    tmp___2 = dup_trans(t1);
#line 176
    tmp___1 = tmp___2;
#line 177
    tmp___1->nxt = result;
#line 178
    result = tmp___1;
#line 175
    t1 = t1->nxt;
  }
#line 180
  free_atrans(lft, 1);
#line 181
  rgt = boolean(p->rgt);
#line 182
  t1 = rgt;
#line 182
  while (t1) {
#line 183
    tmp___4 = dup_trans(t1);
#line 183
    tmp___3 = tmp___4;
#line 184
    tmp___3->nxt = result;
#line 185
    result = tmp___3;
#line 182
    t1 = t1->nxt;
  }
#line 187
  free_atrans(rgt, 1);
#line 188
  break;
  default: 
#line 190
  build_alternating(p);
#line 191
  result = emalloc_atrans();
#line 192
  clear_set(result->to, 0);
#line 193
  clear_set(result->pos, 1);
#line 194
  clear_set(result->neg, 1);
#line 195
  tmp___5 = already_done(p);
#line 195
  add_set(result->to, tmp___5);
  }
#line 197
  return (result);
}
}
#line 200 "alternating.cpp"
ATrans *build_alternating(Node *p ) 
{ ATrans *t1 ;
  ATrans *t2 ;
  ATrans *t ;
  int node ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ATrans *tmp___2 ;
  ATrans *tmp___3 ;
  ATrans *tmp___4 ;
  ATrans *tmp___5 ;
  ATrans *tmp___6 ;
  ATrans *tmp___7 ;
  ATrans *tmp___8 ;
  ATrans *tmp___9 ;
  ATrans *tmp___10 ;
  ATrans *tmp___11 ;
  ATrans *tmp___12 ;
  int tmp___13 ;

  {
#line 202
  t = (ATrans *)0;
#line 203
  tmp = already_done(p);
#line 203
  node = tmp;
#line 204
  if (node >= 0) {
#line 204
    return (*(transition + node));
  }
#line 206
  switch ((int )p->ntyp) {
  case 266: 
#line 209
  t = emalloc_atrans();
#line 210
  clear_set(t->to, 0);
#line 211
  clear_set(t->pos, 1);
#line 212
  clear_set(t->neg, 1);
  case 261: 
#line 214
  break;
  case 265: 
#line 217
  t = emalloc_atrans();
#line 218
  clear_set(t->to, 0);
#line 219
  clear_set(t->pos, 1);
#line 220
  clear_set(t->neg, 1);
#line 221
  tmp___0 = get_sym_id((p->sym)->name);
#line 221
  add_set(t->pos, tmp___0);
#line 222
  break;
  case 263: 
#line 225
  t = emalloc_atrans();
#line 226
  clear_set(t->to, 0);
#line 227
  clear_set(t->pos, 1);
#line 228
  clear_set(t->neg, 1);
#line 229
  tmp___1 = get_sym_id(((p->lft)->sym)->name);
#line 229
  add_set(t->neg, tmp___1);
#line 230
  break;
  case 267: 
#line 239
  t2 = build_alternating(p->rgt);
#line 239
  while (t2) {
#line 240
    tmp___3 = dup_trans(t2);
#line 240
    tmp___2 = tmp___3;
#line 241
    tmp___2->nxt = t;
#line 242
    t = tmp___2;
#line 239
    t2 = t2->nxt;
  }
#line 244
  t1 = build_alternating(p->lft);
#line 244
  while (t1) {
#line 245
    tmp___5 = dup_trans(t1);
#line 245
    tmp___4 = tmp___5;
#line 246
    add_set(tmp___4->to, node_id);
#line 247
    tmp___4->nxt = t;
#line 248
    t = tmp___4;
#line 244
    t1 = t1->nxt;
  }
#line 250
  add_set(final_set, node_id);
#line 251
  break;
  case 268: 
#line 254
  t1 = build_alternating(p->rgt);
#line 254
  while (t1) {
#line 257
    t2 = build_alternating(p->lft);
#line 257
    while (t2) {
#line 258
      tmp___6 = merge_trans(t1, t2);
#line 259
      if (tmp___6) {
#line 260
        tmp___6->nxt = t;
#line 261
        t = tmp___6;
      }
#line 257
      t2 = t2->nxt;
    }
#line 265
    tmp___6 = dup_trans(t1);
#line 266
    add_set(tmp___6->to, node_id);
#line 267
    tmp___6->nxt = t;
#line 268
    t = tmp___6;
#line 254
    t1 = t1->nxt;
  }
#line 270
  break;
  case 258: 
#line 273
  t = (ATrans *)0;
#line 274
  t1 = build_alternating(p->lft);
#line 274
  while (t1) {
#line 275
    t2 = build_alternating(p->rgt);
#line 275
    while (t2) {
#line 276
      tmp___8 = merge_trans(t1, t2);
#line 276
      tmp___7 = tmp___8;
#line 277
      if (tmp___7) {
#line 278
        tmp___7->nxt = t;
#line 279
        t = tmp___7;
      }
#line 275
      t2 = t2->nxt;
    }
#line 274
    t1 = t1->nxt;
  }
#line 283
  break;
  case 264: 
#line 286
  t = (ATrans *)0;
#line 287
  t1 = build_alternating(p->lft);
#line 287
  while (t1) {
#line 288
    tmp___10 = dup_trans(t1);
#line 288
    tmp___9 = tmp___10;
#line 289
    tmp___9->nxt = t;
#line 290
    t = tmp___9;
#line 287
    t1 = t1->nxt;
  }
#line 292
  t1 = build_alternating(p->rgt);
#line 292
  while (t1) {
#line 293
    tmp___12 = dup_trans(t1);
#line 293
    tmp___11 = tmp___12;
#line 294
    tmp___11->nxt = t;
#line 295
    t = tmp___11;
#line 292
    t1 = t1->nxt;
  }
#line 297
  break;
  default: ;
#line 300
  break;
  }
#line 303
  *(transition + node_id) = t;
#line 304
  tmp___13 = node_id;
#line 304
  node_id ++;
#line 304
  *(label + tmp___13) = p;
#line 305
  return (t);
}
}
#line 312 "alternating.cpp"
void simplify_atrans(ATrans **trans___0 ) 
{ ATrans *t ;
  ATrans *father ;
  ATrans *t1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 314
  father = (ATrans *)0;
#line 315
  t = *trans___0;
#line 315
  while (t) {
#line 317
    t1 = *trans___0;
#line 317
    while (t1) {
#line 318
      if ((unsigned int )t1 != (unsigned int )t) {
#line 318
        tmp = included_set(t1->to, t->to, 0);
#line 318
        if (tmp) {
#line 318
          tmp___0 = included_set(t1->pos, t->pos, 1);
#line 318
          if (tmp___0) {
#line 318
            tmp___1 = included_set(t1->neg, t->neg, 1);
#line 318
            if (tmp___1) {
#line 322
              break;
            }
          }
        }
      }
#line 317
      t1 = t1->nxt;
    }
#line 324
    if (t1) {
#line 325
      if (father) {
#line 326
        father->nxt = t->nxt;
      } else {
#line 328
        *trans___0 = t->nxt;
      }
#line 329
      free_atrans(t, 0);
#line 330
      if (father) {
#line 331
        t = father->nxt;
      } else {
#line 333
        t = *trans___0;
      }
      goto __Cont;
    }
#line 336
    atrans_count ++;
#line 337
    father = t;
#line 338
    t = t->nxt;
    __Cont: /* CIL Label */ ;
  }
#line 340
  return;
}
}
#line 342 "alternating.cpp"
void simplify_astates(void) 
{ ATrans *t ;
  int i ;
  int *acc ;
  int *tmp ;
  int tmp___0 ;

  {
#line 345
  tmp = make_set(-1, 0);
#line 345
  acc = tmp;
#line 347
  t = *(transition + 0);
#line 347
  while (t) {
#line 348
    merge_sets(acc, t->to, 0);
#line 347
    t = t->nxt;
#line 347
    i = 0;
  }
#line 350
  i = node_id - 1;
#line 350
  while (i > 0) {
#line 351
    tmp___0 = in_set(acc, i);
#line 351
    if (! tmp___0) {
#line 352
      *(label + i) = (Node *)0;
#line 353
      free_atrans(*(transition + i), 1);
#line 354
      *(transition + i) = (ATrans *)0;
      goto __Cont;
    }
#line 357
    astate_count ++;
#line 358
    simplify_atrans(transition + i);
#line 359
    t = *(transition + i);
#line 359
    while (t) {
#line 360
      merge_sets(acc, t->to, 0);
#line 359
      t = t->nxt;
    }
    __Cont: /* CIL Label */ 
#line 350
    i --;
  }
#line 363
  tfree((void *)acc);
#line 364
  return;
}
}
#line 370 "alternating.cpp"
void print_alternating(void) 
{ int i ;
  ATrans *t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 375
  fprintf(tl_out, "init :\n");
#line 376
  t = *(transition + 0);
#line 376
  while (t) {
#line 377
    print_set(t->to, 0);
#line 378
    fprintf(tl_out, "\n");
#line 376
    t = t->nxt;
  }
#line 381
  i = node_id - 1;
#line 381
  while (i > 0) {
#line 382
    if (! *(label + i)) {
      goto __Cont;
    }
#line 384
    fprintf(tl_out, "state %i : ", i);
#line 385
    dump(*(label + i));
#line 386
    fprintf(tl_out, "\n");
#line 387
    t = *(transition + i);
#line 387
    while (t) {
#line 388
      tmp = empty_set(t->pos, 1);
#line 388
      if (tmp) {
#line 388
        tmp___0 = empty_set(t->neg, 1);
#line 388
        if (tmp___0) {
#line 389
          fprintf(tl_out, "1");
        }
      }
#line 390
      print_set(t->pos, 1);
#line 391
      tmp___1 = empty_set(t->pos, 1);
#line 391
      if (! tmp___1) {
#line 391
        tmp___2 = empty_set(t->neg, 1);
#line 391
        if (! tmp___2) {
#line 391
          fprintf(tl_out, " & ");
        }
      }
#line 392
      print_set(t->neg, 2);
#line 393
      fprintf(tl_out, " -> ");
#line 394
      print_set(t->to, 0);
#line 395
      fprintf(tl_out, "\n");
#line 387
      t = t->nxt;
    }
    __Cont: /* CIL Label */ 
#line 381
    i --;
  }
#line 398
  return;
}
}
#line 404 "alternating.cpp"
void mk_alternating(Node *p ) 
{ int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 408
  tmp = calculate_node_size(p);
#line 408
  node_size = tmp + 1;
#line 409
  tmp___0 = tl_emalloc((int )((unsigned int )node_size * sizeof(Node *)));
#line 409
  label = (Node **)tmp___0;
#line 410
  tmp___1 = tl_emalloc((int )((unsigned int )node_size * sizeof(ATrans *)));
#line 410
  transition = (ATrans **)tmp___1;
#line 411
  node_size = (int )((unsigned int )node_size / (8U * sizeof(int )) + 1U);
#line 413
  sym_size = calculate_sym_size(p);
#line 414
  if (sym_size) {
#line 414
    tmp___2 = tl_emalloc((int )((unsigned int )sym_size * sizeof(char *)));
#line 414
    sym_table = (char **)tmp___2;
  }
#line 415
  sym_size = (int )((unsigned int )sym_size / (8U * sizeof(int )) + 1U);
#line 417
  final_set = make_set(-1, 0);
#line 418
  *(transition + 0) = boolean(p);
#line 420
  if (tl_verbose) {
#line 421
    fprintf(tl_out, "\nAlternating automaton before simplification\n");
#line 422
    print_alternating();
  }
#line 425
  if (tl_simp_diff) {
#line 426
    simplify_astates();
#line 427
    if (tl_verbose) {
#line 428
      fprintf(tl_out, "\nAlternating automaton after simplification\n");
#line 429
      print_alternating();
    }
  }
#line 433
  if (tl_stats) {

  }
#line 441
  releasenode(1, p);
#line 442
  tfree((void *)label);
#line 443
  return;
}
}
#line 1 "buchi.o"
#pragma merger(0,"./buchi.i","")
#line 183 "ltl2ba.h"
BTrans *emalloc_btrans(void) ;
#line 184
void free_btrans(BTrans *t , BTrans *sentinel , int fly ) ;
#line 202
void mk_buchi(void) ;
#line 218
void spin_print_set(int *pos , int *neg ) ;
#line 222
int same_sets(int *l1 , int *l2 , int type ) ;
#line 226
void put_uform(void) ;
#line 36 "buchi.cpp"
GState **init ;
#line 39
int tl_simp_fly ;
#line 39
int tl_simp_scc ;
#line 39
int init_size ;
#line 39
int *final ;
#line 44 "buchi.cpp"
BState *bstack  ;
#line 44 "buchi.cpp"
BState *bstates  ;
#line 44 "buchi.cpp"
BState *bremoved  ;
#line 45 "buchi.cpp"
BScc *bscc_stack  ;
#line 46 "buchi.cpp"
int accept  ;
#line 46 "buchi.cpp"
int bstate_count  =    0;
#line 46 "buchi.cpp"
int btrans_count  =    0;
#line 47
int rank ;
#line 53 "buchi.cpp"
void free_bstate(BState *s ) 
{ 

  {
#line 55
  free_btrans((s->trans)->nxt, s->trans, 1);
#line 56
  tfree((void *)s);
#line 57
  return;
}
}
#line 59 "buchi.cpp"
BState *remove_bstate(BState *s , BState *s1 ) 
{ BState *prv ;

  {
#line 61
  prv = s->prv;
#line 62
  (s->prv)->nxt = s->nxt;
#line 63
  (s->nxt)->prv = s->prv;
#line 64
  free_btrans((s->trans)->nxt, s->trans, 0);
#line 65
  s->trans = (BTrans *)0;
#line 66
  s->nxt = bremoved->nxt;
#line 67
  bremoved->nxt = s;
#line 68
  s->prv = s1;
#line 69
  s1 = bremoved->nxt;
#line 69
  while ((unsigned int )s1 != (unsigned int )bremoved) {
#line 70
    if ((unsigned int )s1->prv == (unsigned int )s) {
#line 71
      s1->prv = s->prv;
    }
#line 69
    s1 = s1->nxt;
  }
#line 72
  return (prv);
}
}
#line 75 "buchi.cpp"
void copy_btrans(BTrans *from , BTrans *to ) 
{ 

  {
#line 76
  to->to = from->to;
#line 77
  copy_set(from->pos, to->pos, 1);
#line 78
  copy_set(from->neg, to->neg, 1);
#line 79
  return;
}
}
#line 81 "buchi.cpp"
int simplify_btrans(void) 
{ BState *s ;
  BTrans *t ;
  BTrans *t1 ;
  int changed ;
  int tmp ;
  int tmp___0 ;
  BTrans *free ;

  {
#line 85
  changed = 0;
#line 89
  s = bstates->nxt;
#line 89
  while ((unsigned int )s != (unsigned int )bstates) {
#line 90
    t = (s->trans)->nxt;
#line 90
    while ((unsigned int )t != (unsigned int )s->trans) {
#line 91
      t1 = (s->trans)->nxt;
#line 92
      copy_btrans(t, s->trans);
#line 93
      while (1) {
#line 93
        if (! ((unsigned int )t == (unsigned int )t1)) {
#line 93
          if (! ((unsigned int )t->to != (unsigned int )t1->to)) {
#line 93
            tmp = included_set(t1->pos, t->pos, 1);
#line 93
            if (tmp) {
#line 93
              tmp___0 = included_set(t1->neg, t->neg, 1);
#line 93
              if (tmp___0) {
#line 93
                break;
              }
            }
          }
        }
#line 96
        t1 = t1->nxt;
      }
#line 97
      if ((unsigned int )t1 != (unsigned int )s->trans) {
#line 98
        free = t->nxt;
#line 99
        t->to = free->to;
#line 100
        copy_set(free->pos, t->pos, 1);
#line 101
        copy_set(free->neg, t->neg, 1);
#line 102
        t->nxt = free->nxt;
#line 103
        if ((unsigned int )free == (unsigned int )s->trans) {
#line 103
          s->trans = t;
        }
#line 104
        free_btrans(free, (BTrans *)0, 0);
#line 105
        changed ++;
      } else {
#line 108
        t = t->nxt;
      }
    }
#line 89
    s = s->nxt;
  }
#line 111
  if (tl_stats) {
#line 116
    fprintf(tl_out, "\n%i transitions removed\n", changed);
  }
#line 119
  return (changed);
}
}
#line 122 "buchi.cpp"
int same_btrans(BTrans *s , BTrans *t ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 124
  if ((unsigned int )s->to == (unsigned int )t->to) {
#line 124
    tmp = same_sets(s->pos, t->pos, 1);
#line 124
    if (tmp) {
#line 124
      tmp___0 = same_sets(s->neg, t->neg, 1);
#line 124
      if (tmp___0) {
#line 124
        tmp___1 = 1;
      } else {
#line 124
        tmp___1 = 0;
      }
    } else {
#line 124
      tmp___1 = 0;
    }
  } else {
#line 124
    tmp___1 = 0;
  }
#line 124
  return (tmp___1);
}
}
#line 129 "buchi.cpp"
void remove_btrans(BState *to ) 
{ BState *s ;
  BTrans *t ;
  BTrans *free ;

  {
#line 134
  s = bstates->nxt;
#line 134
  while ((unsigned int )s != (unsigned int )bstates) {
#line 135
    t = (s->trans)->nxt;
#line 135
    while ((unsigned int )t != (unsigned int )s->trans) {
#line 136
      if ((unsigned int )t->to == (unsigned int )to) {
#line 137
        free = t->nxt;
#line 138
        t->to = free->to;
#line 139
        copy_set(free->pos, t->pos, 1);
#line 140
        copy_set(free->neg, t->neg, 1);
#line 141
        t->nxt = free->nxt;
#line 142
        if ((unsigned int )free == (unsigned int )s->trans) {
#line 142
          s->trans = t;
        }
#line 143
        free_btrans(free, (BTrans *)0, 0);
      }
#line 135
      t = t->nxt;
    }
#line 134
    s = s->nxt;
  }
#line 145
  return;
}
}
#line 147 "buchi.cpp"
void retarget_all_btrans(void) 
{ BState *s ;
  BTrans *t ;
  BTrans *free ;

  {
#line 151
  s = bstates->nxt;
#line 151
  while ((unsigned int )s != (unsigned int )bstates) {
#line 152
    t = (s->trans)->nxt;
#line 152
    while ((unsigned int )t != (unsigned int )s->trans) {
#line 153
      if (! (t->to)->trans) {
#line 154
        t->to = (t->to)->prv;
#line 155
        if (! t->to) {
#line 156
          free = t->nxt;
#line 157
          t->to = free->to;
#line 158
          copy_set(free->pos, t->pos, 1);
#line 159
          copy_set(free->neg, t->neg, 1);
#line 160
          t->nxt = free->nxt;
#line 161
          if ((unsigned int )free == (unsigned int )s->trans) {
#line 161
            s->trans = t;
          }
#line 162
          free_btrans(free, (BTrans *)0, 0);
        }
      }
#line 152
      t = t->nxt;
    }
#line 151
    s = s->nxt;
  }
#line 165
  while ((unsigned int )bremoved->nxt != (unsigned int )bremoved) {
#line 166
    s = bremoved->nxt;
#line 167
    bremoved->nxt = (bremoved->nxt)->nxt;
#line 168
    tfree((void *)s);
  }
#line 170
  return;
}
}
#line 172 "buchi.cpp"
int all_btrans_match(BState *a , BState *b ) 
{ BTrans *s ;
  BTrans *t ;
  int tmp ;
  int tmp___0 ;

  {
#line 175
  if (a->final == accept) {
    goto _L;
  } else {
#line 175
    if (b->final == accept) {
      _L: /* CIL Label */ 
#line 175
      if (a->final + b->final != 2 * accept) {
#line 175
        if (a->incoming >= 0) {
#line 175
          if (b->incoming >= 0) {
#line 177
            return (0);
          }
        }
      }
    }
  }
#line 180
  s = (a->trans)->nxt;
#line 180
  while ((unsigned int )s != (unsigned int )a->trans) {
#line 183
    copy_btrans(s, b->trans);
#line 184
    t = (b->trans)->nxt;
#line 185
    while (1) {
#line 185
      tmp = same_btrans(s, t);
#line 185
      if (tmp) {
#line 185
        break;
      }
#line 187
      t = t->nxt;
    }
#line 189
    if ((unsigned int )t == (unsigned int )b->trans) {
#line 189
      return (0);
    }
#line 180
    s = s->nxt;
  }
#line 191
  s = (b->trans)->nxt;
#line 191
  while ((unsigned int )s != (unsigned int )b->trans) {
#line 194
    copy_btrans(s, a->trans);
#line 195
    t = (a->trans)->nxt;
#line 196
    while (1) {
#line 196
      tmp___0 = same_btrans(s, t);
#line 196
      if (tmp___0) {
#line 196
        break;
      }
#line 198
      t = t->nxt;
    }
#line 200
    if ((unsigned int )t == (unsigned int )a->trans) {
#line 200
      return (0);
    }
#line 191
    s = s->nxt;
  }
#line 202
  return (1);
}
}
#line 205 "buchi.cpp"
int simplify_bstates(void) 
{ BState *s ;
  BState *s1 ;
  int changed ;
  int tmp ;

  {
#line 208
  changed = 0;
#line 212
  s = bstates->nxt;
#line 212
  while ((unsigned int )s != (unsigned int )bstates) {
#line 213
    if ((unsigned int )s->trans == (unsigned int )(s->trans)->nxt) {
#line 214
      s = remove_bstate(s, (BState *)0);
#line 215
      changed ++;
      goto __Cont;
    }
#line 218
    bstates->trans = s->trans;
#line 219
    bstates->final = s->final;
#line 220
    s1 = s->nxt;
#line 221
    while (1) {
#line 221
      tmp = all_btrans_match(s, s1);
#line 221
      if (tmp) {
#line 221
        break;
      }
#line 222
      s1 = s1->nxt;
    }
#line 223
    if ((unsigned int )s1 != (unsigned int )bstates) {
#line 224
      if (s1->incoming == -1) {
#line 225
        s1->final = s->final;
      }
#line 226
      s = remove_bstate(s, s1);
#line 227
      changed ++;
    }
    __Cont: /* CIL Label */ 
#line 212
    s = s->nxt;
  }
#line 230
  retarget_all_btrans();
#line 240
  return (changed);
}
}
#line 243 "buchi.cpp"
int bdfs(BState *s ) 
{ BTrans *t ;
  BScc *c ;
  BScc *scc ;
  void *tmp ;
  int tmp___0 ;
  int result ;
  int tmp___1 ;

  {
#line 246
  tmp = tl_emalloc((int )sizeof(BScc ));
#line 246
  scc = (BScc *)tmp;
#line 247
  scc->bstate = s;
#line 248
  scc->rank = rank;
#line 249
  tmp___0 = rank;
#line 249
  rank ++;
#line 249
  scc->theta = tmp___0;
#line 250
  scc->nxt = bscc_stack;
#line 251
  bscc_stack = scc;
#line 253
  s->incoming = 1;
#line 255
  t = (s->trans)->nxt;
#line 255
  while ((unsigned int )t != (unsigned int )s->trans) {
#line 256
    if ((t->to)->incoming == 0) {
#line 257
      tmp___1 = bdfs(t->to);
#line 257
      result = tmp___1;
#line 258
      if (scc->theta < result) {
#line 258
        scc->theta = scc->theta;
      } else {
#line 258
        scc->theta = result;
      }
    } else {
#line 261
      c = bscc_stack->nxt;
#line 261
      while ((unsigned int )c != (unsigned int )((BScc *)0)) {
#line 262
        if ((unsigned int )c->bstate == (unsigned int )t->to) {
#line 263
          if (scc->theta < c->rank) {
#line 263
            scc->theta = scc->theta;
          } else {
#line 263
            scc->theta = c->rank;
          }
#line 264
          break;
        }
#line 261
        c = c->nxt;
      }
    }
#line 255
    t = t->nxt;
  }
#line 268
  if (scc->rank == scc->theta) {
#line 269
    if ((unsigned int )bscc_stack == (unsigned int )scc) {
#line 270
      s->incoming = -1;
#line 271
      t = (s->trans)->nxt;
#line 271
      while ((unsigned int )t != (unsigned int )s->trans) {
#line 272
        if ((unsigned int )t->to == (unsigned int )s) {
#line 273
          s->incoming = 1;
        }
#line 271
        t = t->nxt;
      }
    }
#line 275
    bscc_stack = scc->nxt;
  }
#line 277
  return (scc->theta);
}
}
#line 280 "buchi.cpp"
void simplify_bscc(void) 
{ BState *s ;

  {
#line 282
  rank = 1;
#line 283
  bscc_stack = (BScc *)0;
#line 285
  if ((unsigned int )bstates == (unsigned int )bstates->nxt) {
#line 285
    return;
  }
#line 287
  s = bstates->nxt;
#line 287
  while ((unsigned int )s != (unsigned int )bstates) {
#line 288
    s->incoming = 0;
#line 287
    s = s->nxt;
  }
#line 290
  bdfs(bstates->prv);
#line 292
  s = bstates->nxt;
#line 292
  while ((unsigned int )s != (unsigned int )bstates) {
#line 293
    if (s->incoming == 0) {
#line 294
      remove_bstate(s, (BState *)0);
    }
#line 292
    s = s->nxt;
  }
#line 295
  return;
}
}
#line 304 "buchi.cpp"
BState *find_bstate(GState **state , int final___0 , BState *s ) 
{ void *tmp ;

  {
#line 306
  if ((unsigned int )s->gstate == (unsigned int )*state) {
#line 306
    if (s->final == final___0) {
#line 306
      return (s);
    }
  }
#line 308
  s = bstack->nxt;
#line 309
  bstack->gstate = *state;
#line 310
  bstack->final = final___0;
#line 311
  while (1) {
#line 311
    if (! (! ((unsigned int )s->gstate == (unsigned int )*state))) {
#line 311
      if (! (! (s->final == final___0))) {
#line 311
        break;
      }
    }
#line 312
    s = s->nxt;
  }
#line 313
  if ((unsigned int )s != (unsigned int )bstack) {
#line 313
    return (s);
  }
#line 315
  s = bstates->nxt;
#line 316
  bstates->gstate = *state;
#line 317
  bstates->final = final___0;
#line 318
  while (1) {
#line 318
    if (! (! ((unsigned int )s->gstate == (unsigned int )*state))) {
#line 318
      if (! (! (s->final == final___0))) {
#line 318
        break;
      }
    }
#line 319
    s = s->nxt;
  }
#line 320
  if ((unsigned int )s != (unsigned int )bstates) {
#line 320
    return (s);
  }
#line 322
  s = bremoved->nxt;
#line 323
  bremoved->gstate = *state;
#line 324
  bremoved->final = final___0;
#line 325
  while (1) {
#line 325
    if (! (! ((unsigned int )s->gstate == (unsigned int )*state))) {
#line 325
      if (! (! (s->final == final___0))) {
#line 325
        break;
      }
    }
#line 326
    s = s->nxt;
  }
#line 327
  if ((unsigned int )s != (unsigned int )bremoved) {
#line 327
    return (s);
  }
#line 329
  tmp = tl_emalloc((int )sizeof(BState ));
#line 329
  s = (BState *)tmp;
#line 330
  s->gstate = *state;
#line 331
  s->id = (*state)->id;
#line 332
  s->incoming = 0;
#line 333
  s->final = final___0;
#line 334
  s->trans = emalloc_btrans();
#line 335
  (s->trans)->nxt = s->trans;
#line 336
  s->nxt = bstack->nxt;
#line 337
  bstack->nxt = s;
#line 338
  return (s);
}
}
#line 341 "buchi.cpp"
int next_final(int *set , int fin___0 ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 343
  if (fin___0 != accept) {
#line 343
    tmp___0 = in_set(set, *(final + (fin___0 + 1)));
#line 343
    if (tmp___0) {
#line 344
      tmp = next_final(set, fin___0 + 1);
#line 344
      return (tmp);
    }
  }
#line 345
  return (fin___0);
}
}
#line 348 "buchi.cpp"
void make_btrans(BState *s ) 
{ int state_trans ;
  GTrans *t ;
  BTrans *t1 ;
  BState *s1 ;
  int fin___0 ;
  int tmp ;
  int tmp___0 ;
  BState *to ;
  BState *tmp___1 ;
  BTrans *free ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  BTrans *trans___0 ;
  BTrans *tmp___6 ;
  int tmp___7 ;

  {
#line 350
  state_trans = 0;
#line 354
  if ((s->gstate)->trans) {
#line 355
    t = ((s->gstate)->trans)->nxt;
#line 355
    while ((unsigned int )t != (unsigned int )(s->gstate)->trans) {
#line 356
      if (s->final == accept) {
#line 356
        tmp = 0;
      } else {
#line 356
        tmp = s->final;
      }
#line 356
      tmp___0 = next_final(t->final, tmp);
#line 356
      fin___0 = tmp___0;
#line 357
      tmp___1 = find_bstate(& t->to, fin___0, s);
#line 357
      to = tmp___1;
#line 359
      t1 = (s->trans)->nxt;
#line 359
      while ((unsigned int )t1 != (unsigned int )s->trans) {
#line 360
        if (tl_simp_fly) {
#line 360
          if ((unsigned int )to == (unsigned int )t1->to) {
#line 360
            tmp___4 = included_set(t->pos, t1->pos, 1);
#line 360
            if (tmp___4) {
#line 360
              tmp___5 = included_set(t->neg, t1->neg, 1);
#line 360
              if (tmp___5) {
#line 364
                free = t1->nxt;
#line 365
                ((t1->to)->incoming) --;
#line 366
                t1->to = free->to;
#line 367
                copy_set(free->pos, t1->pos, 1);
#line 368
                copy_set(free->neg, t1->neg, 1);
#line 369
                t1->nxt = free->nxt;
#line 370
                if ((unsigned int )free == (unsigned int )s->trans) {
#line 370
                  s->trans = t1;
                }
#line 371
                free_btrans(free, (BTrans *)0, 0);
#line 372
                state_trans --;
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 374
          if (tl_simp_fly) {
#line 374
            if ((unsigned int )t1->to == (unsigned int )to) {
#line 374
              tmp___2 = included_set(t1->pos, t->pos, 1);
#line 374
              if (tmp___2) {
#line 374
                tmp___3 = included_set(t1->neg, t->neg, 1);
#line 374
                if (tmp___3) {
#line 378
                  break;
                } else {
#line 380
                  t1 = t1->nxt;
                }
              } else {
#line 380
                t1 = t1->nxt;
              }
            } else {
#line 380
              t1 = t1->nxt;
            }
          } else {
#line 380
            t1 = t1->nxt;
          }
        }
      }
#line 382
      if ((unsigned int )t1 == (unsigned int )s->trans) {
#line 383
        tmp___6 = emalloc_btrans();
#line 383
        trans___0 = tmp___6;
#line 384
        trans___0->to = to;
#line 385
        ((trans___0->to)->incoming) ++;
#line 386
        copy_set(t->pos, trans___0->pos, 1);
#line 387
        copy_set(t->neg, trans___0->neg, 1);
#line 388
        trans___0->nxt = (s->trans)->nxt;
#line 389
        (s->trans)->nxt = trans___0;
#line 390
        state_trans ++;
      }
#line 355
      t = t->nxt;
    }
  }
#line 394
  if (tl_simp_fly) {
#line 395
    if ((unsigned int )s->trans == (unsigned int )(s->trans)->nxt) {
#line 396
      free_btrans((s->trans)->nxt, s->trans, 1);
#line 397
      s->trans = (BTrans *)0;
#line 398
      s->prv = (BState *)0;
#line 399
      s->nxt = bremoved->nxt;
#line 400
      bremoved->nxt = s;
#line 401
      s1 = bremoved->nxt;
#line 401
      while ((unsigned int )s1 != (unsigned int )bremoved) {
#line 402
        if ((unsigned int )s1->prv == (unsigned int )s) {
#line 403
          s1->prv = (BState *)0;
        }
#line 401
        s1 = s1->nxt;
      }
#line 404
      return;
    }
#line 406
    bstates->trans = s->trans;
#line 407
    bstates->final = s->final;
#line 408
    s1 = bstates->nxt;
#line 409
    while (1) {
#line 409
      tmp___7 = all_btrans_match(s, s1);
#line 409
      if (tmp___7) {
#line 409
        break;
      }
#line 410
      s1 = s1->nxt;
    }
#line 411
    if ((unsigned int )s1 != (unsigned int )bstates) {
#line 412
      free_btrans((s->trans)->nxt, s->trans, 1);
#line 413
      s->trans = (BTrans *)0;
#line 414
      s->prv = s1;
#line 415
      s->nxt = bremoved->nxt;
#line 416
      bremoved->nxt = s;
#line 417
      s1 = bremoved->nxt;
#line 417
      while ((unsigned int )s1 != (unsigned int )bremoved) {
#line 418
        if ((unsigned int )s1->prv == (unsigned int )s) {
#line 419
          s1->prv = s->prv;
        }
#line 417
        s1 = s1->nxt;
      }
#line 420
      return;
    }
  }
#line 423
  s->nxt = bstates->nxt;
#line 424
  s->prv = bstates;
#line 425
  (s->nxt)->prv = s;
#line 426
  bstates->nxt = s;
#line 427
  btrans_count += state_trans;
#line 428
  bstate_count ++;
#line 429
  return;
}
}
#line 435 "buchi.cpp"
void print_buchi(BState *s ) 
{ BTrans *t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 438
  if ((unsigned int )s == (unsigned int )bstates) {
#line 438
    return;
  }
#line 440
  print_buchi(s->nxt);
#line 442
  fprintf(tl_out, "state ");
#line 443
  if (s->id == -1) {
#line 444
    fprintf(tl_out, "init");
  } else {
#line 446
    if (s->final == accept) {
#line 447
      fprintf(tl_out, "accept");
    } else {
#line 449
      fprintf(tl_out, "T%i", s->final);
    }
#line 450
    fprintf(tl_out, "_%i", s->id);
  }
#line 452
  fprintf(tl_out, "\n");
#line 453
  t = (s->trans)->nxt;
#line 453
  while ((unsigned int )t != (unsigned int )s->trans) {
#line 454
    tmp = empty_set(t->pos, 1);
#line 454
    if (tmp) {
#line 454
      tmp___0 = empty_set(t->neg, 1);
#line 454
      if (tmp___0) {
#line 455
        fprintf(tl_out, "1");
      }
    }
#line 456
    print_set(t->pos, 1);
#line 457
    tmp___1 = empty_set(t->pos, 1);
#line 457
    if (! tmp___1) {
#line 457
      tmp___2 = empty_set(t->neg, 1);
#line 457
      if (! tmp___2) {
#line 457
        fprintf(tl_out, " & ");
      }
    }
#line 458
    print_set(t->neg, 2);
#line 459
    fprintf(tl_out, " -> ");
#line 460
    if ((t->to)->id == -1) {
#line 461
      fprintf(tl_out, "init\n");
    } else {
#line 463
      if ((t->to)->final == accept) {
#line 464
        fprintf(tl_out, "accept");
      } else {
#line 466
        fprintf(tl_out, "T%i", (t->to)->final);
      }
#line 467
      fprintf(tl_out, "_%i\n", (t->to)->id);
    }
#line 453
    t = t->nxt;
  }
#line 470
  return;
}
}
#line 472 "buchi.cpp"
void print_spin_buchi(void) 
{ BTrans *t ;
  BState *s ;
  int accept_all ;
  int init_count ;
  BTrans *t1 ;

  {
#line 475
  accept_all = 0;
#line 475
  init_count = 0;
#line 476
  if ((unsigned int )bstates->nxt == (unsigned int )bstates) {
#line 477
    fprintf(tl_out, "never {    /* ");
#line 478
    put_uform();
#line 479
    fprintf(tl_out, " */\n");
#line 480
    fprintf(tl_out, "T0_init:\n");
#line 481
    fprintf(tl_out, "\tfalse;\n");
#line 482
    fprintf(tl_out, "}\n");
#line 483
    return;
  }
#line 485
  if ((unsigned int )(bstates->nxt)->nxt == (unsigned int )bstates) {
#line 485
    if ((bstates->nxt)->id == 0) {
#line 486
      fprintf(tl_out, "never {    /* ");
#line 487
      put_uform();
#line 488
      fprintf(tl_out, " */\n");
#line 489
      fprintf(tl_out, "accept_init:\n");
#line 490
      fprintf(tl_out, "\tif\n");
#line 491
      fprintf(tl_out, "\t:: (1) -> goto accept_init\n");
#line 492
      fprintf(tl_out, "\tfi;\n");
#line 493
      fprintf(tl_out, "}\n");
#line 494
      return;
    }
  }
#line 497
  fprintf(tl_out, "never { /* ");
#line 498
  put_uform();
#line 499
  fprintf(tl_out, " */\n");
#line 500
  s = bstates->prv;
#line 500
  while ((unsigned int )s != (unsigned int )bstates) {
#line 501
    if (s->id == 0) {
#line 502
      accept_all = 1;
      goto __Cont;
    }
#line 505
    if (s->final == accept) {
#line 506
      fprintf(tl_out, "accept_");
    } else {
#line 507
      fprintf(tl_out, "T%i_", s->final);
    }
#line 508
    if (s->id == -1) {
#line 509
      fprintf(tl_out, "init:\n");
    } else {
#line 510
      fprintf(tl_out, "S%i:\n", s->id);
    }
#line 511
    if ((unsigned int )(s->trans)->nxt == (unsigned int )s->trans) {
#line 512
      fprintf(tl_out, "\tfalse;\n");
      goto __Cont;
    }
#line 515
    fprintf(tl_out, "\tif\n");
#line 516
    t = (s->trans)->nxt;
#line 516
    while ((unsigned int )t != (unsigned int )s->trans) {
#line 518
      fprintf(tl_out, "\t:: (");
#line 519
      spin_print_set(t->pos, t->neg);
#line 520
      t1 = t;
#line 520
      while ((unsigned int )t1->nxt != (unsigned int )s->trans) {
#line 521
        if (((t1->nxt)->to)->id == (t->to)->id) {
#line 521
          if (((t1->nxt)->to)->final == (t->to)->final) {
#line 523
            fprintf(tl_out, ") || (");
#line 524
            spin_print_set((t1->nxt)->pos, (t1->nxt)->neg);
#line 525
            t1->nxt = (t1->nxt)->nxt;
          } else {
#line 527
            t1 = t1->nxt;
          }
        } else {
#line 527
          t1 = t1->nxt;
        }
      }
#line 528
      fprintf(tl_out, ") -> goto ");
#line 529
      if ((t->to)->final == accept) {
#line 530
        fprintf(tl_out, "accept_");
      } else {
#line 531
        fprintf(tl_out, "T%i_", (t->to)->final);
      }
#line 532
      if ((t->to)->id == 0) {
#line 533
        fprintf(tl_out, "all\n");
      } else {
#line 534
        if ((t->to)->id == -1) {
#line 535
          fprintf(tl_out, "init\n");
        } else {
#line 536
          fprintf(tl_out, "S%i\n", (t->to)->id);
        }
      }
#line 516
      t = t->nxt;
    }
#line 538
    fprintf(tl_out, "\tfi;\n");
    __Cont: /* CIL Label */ 
#line 500
    s = s->prv;
  }
#line 540
  if (accept_all) {
#line 541
    fprintf(tl_out, "accept_all:\n");
#line 542
    fprintf(tl_out, "\tskip\n");
  }
#line 544
  fprintf(tl_out, "}\n");
#line 545
  return;
}
}
#line 551 "buchi.cpp"
void mk_buchi(void) 
{ int i ;
  BState *s ;
  void *tmp ;
  GTrans *t ;
  BTrans *t1 ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int fin___0 ;
  int tmp___3 ;
  BState *to ;
  BState *tmp___4 ;
  BTrans *free ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  BTrans *trans___0 ;
  BTrans *tmp___9 ;
  int tmp___10 ;

  {
#line 554
  tmp = tl_emalloc((int )sizeof(BState ));
#line 554
  s = (BState *)tmp;
#line 557
  rank = 0;
#line 558
  accept = *(final + 0) - 1;
#line 560
  tmp___0 = tl_emalloc((int )sizeof(BState ));
#line 560
  bstack = (BState *)tmp___0;
#line 561
  bstack->nxt = bstack;
#line 562
  tmp___1 = tl_emalloc((int )sizeof(BState ));
#line 562
  bremoved = (BState *)tmp___1;
#line 563
  bremoved->nxt = bremoved;
#line 564
  tmp___2 = tl_emalloc((int )sizeof(BState ));
#line 564
  bstates = (BState *)tmp___2;
#line 565
  bstates->nxt = s;
#line 566
  bstates->prv = s;
#line 568
  s->nxt = bstates;
#line 569
  s->prv = bstates;
#line 570
  s->id = -1;
#line 571
  s->incoming = 1;
#line 572
  s->final = 0;
#line 573
  s->gstate = (struct GState *)0;
#line 574
  s->trans = emalloc_btrans();
#line 575
  (s->trans)->nxt = s->trans;
#line 576
  i = 0;
#line 576
  while (i < init_size) {
#line 578
    if (*(init + i)) {
#line 580
      t = ((*(init + i))->trans)->nxt;
#line 580
      while ((unsigned int )t != (unsigned int )(*(init + i))->trans) {
#line 582
        tmp___3 = next_final(t->final, 0);
#line 582
        fin___0 = tmp___3;
#line 583
        tmp___4 = find_bstate(& t->to, fin___0, s);
#line 583
        to = tmp___4;
#line 584
        t1 = (s->trans)->nxt;
#line 584
        while ((unsigned int )t1 != (unsigned int )s->trans) {
#line 586
          if (tl_simp_fly) {
#line 586
            if ((unsigned int )to == (unsigned int )t1->to) {
#line 586
              tmp___7 = included_set(t->pos, t1->pos, 1);
#line 586
              if (tmp___7) {
#line 586
                tmp___8 = included_set(t->neg, t1->neg, 1);
#line 586
                if (tmp___8) {
#line 588
                  free = t1->nxt;
#line 589
                  ((t1->to)->incoming) --;
#line 590
                  t1->to = free->to;
#line 591
                  copy_set(free->pos, t1->pos, 1);
#line 592
                  copy_set(free->neg, t1->neg, 1);
#line 593
                  t1->nxt = free->nxt;
#line 594
                  if ((unsigned int )free == (unsigned int )s->trans) {
#line 594
                    s->trans = t1;
                  }
#line 595
                  free_btrans(free, (BTrans *)0, 0);
                } else {
                  goto _L___1;
                }
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 597
            if (tl_simp_fly) {
#line 597
              if ((unsigned int )t1->to == (unsigned int )to) {
#line 597
                tmp___5 = included_set(t1->pos, t->pos, 1);
#line 597
                if (tmp___5) {
#line 597
                  tmp___6 = included_set(t1->neg, t->neg, 1);
#line 597
                  if (tmp___6) {
#line 599
                    break;
                  } else {
#line 603
                    t1 = t1->nxt;
                  }
                } else {
#line 603
                  t1 = t1->nxt;
                }
              } else {
#line 603
                t1 = t1->nxt;
              }
            } else {
#line 603
              t1 = t1->nxt;
            }
          }
        }
#line 606
        if ((unsigned int )t1 == (unsigned int )s->trans) {
#line 608
          tmp___9 = emalloc_btrans();
#line 608
          trans___0 = tmp___9;
#line 609
          trans___0->to = to;
#line 610
          ((trans___0->to)->incoming) ++;
#line 611
          copy_set(t->pos, trans___0->pos, 1);
#line 612
          copy_set(t->neg, trans___0->neg, 1);
#line 613
          trans___0->nxt = (s->trans)->nxt;
#line 614
          (s->trans)->nxt = trans___0;
        }
#line 580
        t = t->nxt;
      }
    }
#line 576
    i ++;
  }
#line 620
  while ((unsigned int )bstack->nxt != (unsigned int )bstack) {
#line 622
    s = bstack->nxt;
#line 623
    bstack->nxt = (bstack->nxt)->nxt;
#line 624
    if (! s->incoming) {
#line 626
      free_bstate(s);
#line 627
      continue;
    }
#line 629
    make_btrans(s);
  }
#line 632
  retarget_all_btrans();
#line 634
  if (tl_verbose) {
#line 635
    fprintf(tl_out, "\nBuchi automaton before simplification\n");
#line 636
    print_buchi(bstates->nxt);
#line 637
    if ((unsigned int )bstates == (unsigned int )bstates->nxt) {
#line 638
      fprintf(tl_out, "empty automaton, refuses all words\n");
    }
  }
#line 641
  if (tl_simp_diff) {
#line 642
    simplify_btrans();
#line 643
    if (tl_simp_scc) {
#line 643
      simplify_bscc();
    }
#line 644
    while (1) {
#line 644
      tmp___10 = simplify_bstates();
#line 644
      if (! tmp___10) {
#line 644
        break;
      }
#line 645
      simplify_btrans();
#line 646
      if (tl_simp_scc) {
#line 646
        simplify_bscc();
      }
    }
#line 649
    if (tl_verbose) {
#line 650
      fprintf(tl_out, "\nBuchi automaton after simplification\n");
#line 651
      print_buchi(bstates->nxt);
#line 652
      if ((unsigned int )bstates == (unsigned int )bstates->nxt) {
#line 653
        fprintf(tl_out, "empty automaton, refuses all words\n");
      }
#line 654
      fprintf(tl_out, "\n");
    }
  }
#line 658
  print_spin_buchi();
#line 659
  return;
}
}
#line 1 "cache.o"
#pragma merger(0,"./cache.i","")
#line 179 "/usr/include/stdio.h"
//extern int ( __attribute__((__cdecl__)) printf)(char const   *  , ...) ;
#line 156 "ltl2ba.h"
Node *Canonical(Node *n ) ;
#line 158
Node *cached(Node *n ) ;
#line 159
Node *dupnode(Node *n ) ;
#line 160
Node *getnode(Node *p ) ;
#line 161
Node *in_cache(Node *n ) ;
#line 164
Node *tl_nn(int t , Node *ll , Node *rl ) ;
#line 172
int anywhere(int tok , Node *srch , Node *in ) ;
#line 187
void cache_stats(void) ;
#line 190
void fatal(char *s1 , char *s2 ) ;
#line 42 "cache.cpp"
static Cache *stored  =    (Cache *)0;
#line 43 "cache.cpp"
static unsigned long Caches  ;
#line 43 "cache.cpp"
static unsigned long CacheHits  ;
#line 45
static int ismatch(Node *a , Node *b ) ;
#line 47
int sameform(Node *a , Node *b ) ;
#line 49 "cache.cpp"
void cache_dump(void) 
{ Cache *d ;
  int nr ;

  {
#line 51
  nr = 0;
#line 53
  printf("\nCACHE DUMP:\n");
#line 54
  d = stored;
#line 54
  while (d) {
#line 55
    if (d->same) {
      goto __Cont;
    }
#line 56
    printf("B%3d: ", nr);
#line 56
    dump(d->before);
#line 56
    printf("\n");
#line 57
    printf("A%3d: ", nr);
#line 57
    dump(d->after);
#line 57
    printf("\n");
    __Cont: /* CIL Label */ 
#line 54
    d = d->nxt;
#line 54
    nr ++;
  }
#line 59
  printf("============\n");
#line 60
  return;
}
}
#line 62 "cache.cpp"
Node *in_cache(Node *n ) 
{ Cache *d ;
  int nr ;
  int tmp ;
  Node *tmp___0 ;
  int tmp___1 ;

  {
#line 64
  nr = 0;
#line 66
  d = stored;
#line 66
  while (d) {
#line 67
    tmp___1 = isequal(d->before, n);
#line 67
    if (tmp___1) {
#line 68
      CacheHits ++;
#line 69
      if (d->same) {
#line 69
        tmp = ismatch(n, d->before);
#line 69
        if (tmp) {
#line 69
          return (n);
        }
      }
#line 70
      tmp___0 = dupnode(d->after);
#line 70
      return (tmp___0);
    }
#line 66
    d = d->nxt;
#line 66
    nr ++;
  }
#line 72
  return ((Node *)0);
}
}
#line 75 "cache.cpp"
Node *cached(Node *n ) 
{ Cache *d ;
  Node *m ;
  void *tmp ;
  int tmp___0 ;
  Node *tmp___1 ;

  {
#line 80
  if (! n) {
#line 80
    return (n);
  }
#line 81
  m = in_cache(n);
#line 81
  if (m) {
#line 82
    return (m);
  }
#line 84
  Caches ++;
#line 85
  tmp = tl_emalloc((int )sizeof(Cache ));
#line 85
  d = (Cache *)tmp;
#line 86
  d->before = dupnode(n);
#line 87
  d->after = Canonical(n);
#line 89
  tmp___0 = ismatch(d->before, d->after);
#line 89
  if (tmp___0) {
#line 90
    d->same = 1;
#line 91
    releasenode(1, d->after);
#line 92
    d->after = d->before;
  }
#line 94
  d->nxt = stored;
#line 95
  stored = d;
#line 96
  tmp___1 = dupnode(d->after);
#line 96
  return (tmp___1);
}
}
#line 99 "cache.cpp"
void cache_stats(void) 
{ 

  {
#line 102
  printf("cache stores     : %9ld\n", Caches);
#line 103
  printf("cache hits       : %9ld\n", CacheHits);
#line 104
  return;
}
}
#line 106 "cache.cpp"
void releasenode(int all_levels , Node *n ) 
{ 

  {
#line 109
  if (! n) {
#line 109
    return;
  }
#line 111
  if (all_levels) {
#line 112
    releasenode(1, n->lft);
#line 113
    n->lft = (Node *)0;
#line 114
    releasenode(1, n->rgt);
#line 115
    n->rgt = (Node *)0;
  }
#line 117
  tfree((void *)n);
#line 118
  return;
}
}
#line 120 "cache.cpp"
Node *tl_nn(int t , Node *ll , Node *rl ) 
{ Node *n ;
  void *tmp ;

  {
#line 122
  tmp = tl_emalloc((int )sizeof(Node ));
#line 122
  n = (Node *)tmp;
#line 124
  n->ntyp = (short )t;
#line 125
  n->lft = ll;
#line 126
  n->rgt = rl;
#line 128
  return (n);
}
}
#line 131 "cache.cpp"
Node *getnode(Node *p ) 
{ Node *n ;
  void *tmp ;

  {
#line 135
  if (! p) {
#line 135
    return (p);
  }
#line 137
  tmp = tl_emalloc((int )sizeof(Node ));
#line 137
  n = (Node *)tmp;
#line 138
  n->ntyp = p->ntyp;
#line 139
  n->sym = p->sym;
#line 140
  n->lft = p->lft;
#line 141
  n->rgt = p->rgt;
#line 143
  return (n);
}
}
#line 146 "cache.cpp"
Node *dupnode(Node *n ) 
{ Node *d ;

  {
#line 150
  if (! n) {
#line 150
    return (n);
  }
#line 151
  d = getnode(n);
#line 152
  d->lft = dupnode(n->lft);
#line 153
  d->rgt = dupnode(n->rgt);
#line 154
  return (d);
}
}
#line 157 "cache.cpp"
int one_lft(int ntyp , Node *x , Node *in ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 160
  if (! x) {
#line 160
    return (1);
  }
#line 161
  if (! in) {
#line 161
    return (0);
  }
#line 163
  tmp = sameform(x, in);
#line 163
  if (tmp) {
#line 164
    return (1);
  }
#line 166
  if ((int )in->ntyp != ntyp) {
#line 167
    return (0);
  }
#line 169
  tmp___0 = one_lft(ntyp, x, in->lft);
#line 169
  if (tmp___0) {
#line 170
    return (1);
  }
#line 172
  tmp___1 = one_lft(ntyp, x, in->rgt);
#line 172
  return (tmp___1);
}
}
#line 175 "cache.cpp"
int all_lfts(int ntyp , Node *from , Node *in ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 178
  if (! from) {
#line 178
    return (1);
  }
#line 180
  if ((int )from->ntyp != ntyp) {
#line 181
    tmp = one_lft(ntyp, from, in);
#line 181
    return (tmp);
  }
#line 183
  tmp___0 = one_lft(ntyp, from->lft, in);
#line 183
  if (! tmp___0) {
#line 184
    return (0);
  }
#line 186
  tmp___1 = all_lfts(ntyp, from->rgt, in);
#line 186
  return (tmp___1);
}
}
#line 189 "cache.cpp"
int sametrees(int ntyp , Node *a , Node *b ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 195
  tmp = all_lfts(ntyp, a, b);
#line 195
  if (! tmp) {
#line 196
    return (0);
  }
#line 198
  tmp___0 = all_lfts(ntyp, b, a);
#line 198
  return (tmp___0);
}
}
#line 201 "cache.cpp"
int sameform(Node *a , Node *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 204
  if (! a) {
#line 204
    if (! b) {
#line 204
      return (1);
    }
  }
#line 205
  if (! a) {
#line 205
    return (0);
  } else {
#line 205
    if (! b) {
#line 205
      return (0);
    }
  }
#line 206
  if ((int )a->ntyp != (int )b->ntyp) {
#line 206
    return (0);
  }
#line 208
  if (a->sym) {
#line 208
    if (b->sym) {
#line 208
      tmp = strcmp((char const   *)(a->sym)->name, (char const   *)(b->sym)->name);
#line 208
      if (tmp != 0) {
#line 211
        return (0);
      }
    }
  }
#line 213
  switch ((int )a->ntyp) {
  case 266: 
  case 261: 
#line 216
  return (1);
  case 265: 
#line 218
  if (! a->sym) {
#line 218
    fatal((char *)"sameform...", (char *)0);
  } else {
#line 218
    if (! b->sym) {
#line 218
      fatal((char *)"sameform...", (char *)0);
    }
  }
#line 219
  tmp___0 = strcmp((char const   *)(a->sym)->name, (char const   *)(b->sym)->name);
#line 219
  if (tmp___0) {
#line 219
    tmp___1 = 0;
  } else {
#line 219
    tmp___1 = 1;
  }
#line 219
  return (tmp___1);
  case 263: 
#line 225
  tmp___2 = sameform(a->lft, b->lft);
#line 225
  return (tmp___2);
  case 267: 
  case 268: 
#line 228
  tmp___3 = sameform(a->lft, b->lft);
#line 228
  if (! tmp___3) {
#line 229
    return (0);
  }
#line 230
  tmp___4 = sameform(a->rgt, b->rgt);
#line 230
  if (! tmp___4) {
#line 231
    return (0);
  }
#line 232
  return (1);
  case 258: 
  case 264: 
#line 236
  tmp___5 = sametrees((int )a->ntyp, a, b);
#line 236
  return (tmp___5);
  default: 
#line 239
  printf("type: %d\n", a->ntyp);
#line 240
  fatal((char *)"cannot happen, sameform", (char *)0);
  }
#line 243
  return (0);
}
}
#line 246 "cache.cpp"
int isequal(Node *a , Node *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 249
  if (! a) {
#line 249
    if (! b) {
#line 250
      return (1);
    }
  }
#line 252
  if (! a) {
    goto _L;
  } else {
#line 252
    if (! b) {
      _L: /* CIL Label */ 
#line 253
      if (! a) {
#line 254
        if ((int )b->ntyp == 266) {
#line 255
          return (1);
        }
      } else {
#line 257
        if ((int )a->ntyp == 266) {
#line 258
          return (1);
        }
      }
#line 260
      return (0);
    }
  }
#line 262
  if ((int )a->ntyp != (int )b->ntyp) {
#line 263
    return (0);
  }
#line 265
  if (a->sym) {
#line 265
    if (b->sym) {
#line 265
      tmp = strcmp((char const   *)(a->sym)->name, (char const   *)(b->sym)->name);
#line 265
      if (tmp != 0) {
#line 268
        return (0);
      }
    }
  }
#line 270
  tmp___0 = isequal(a->lft, b->lft);
#line 270
  if (tmp___0) {
#line 270
    tmp___1 = isequal(a->rgt, b->rgt);
#line 270
    if (tmp___1) {
#line 272
      return (1);
    }
  }
#line 274
  tmp___2 = sameform(a, b);
#line 274
  return (tmp___2);
}
}
#line 277 "cache.cpp"
static int ismatch(Node *a , Node *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 280
  if (! a) {
#line 280
    if (! b) {
#line 280
      return (1);
    }
  }
#line 281
  if (! a) {
#line 281
    return (0);
  } else {
#line 281
    if (! b) {
#line 281
      return (0);
    }
  }
#line 282
  if ((int )a->ntyp != (int )b->ntyp) {
#line 282
    return (0);
  }
#line 284
  if (a->sym) {
#line 284
    if (b->sym) {
#line 284
      tmp = strcmp((char const   *)(a->sym)->name, (char const   *)(b->sym)->name);
#line 284
      if (tmp != 0) {
#line 287
        return (0);
      }
    }
  }
#line 289
  tmp___0 = ismatch(a->lft, b->lft);
#line 289
  if (tmp___0) {
#line 289
    tmp___1 = ismatch(a->rgt, b->rgt);
#line 289
    if (tmp___1) {
#line 291
      return (1);
    }
  }
#line 293
  return (0);
}
}
#line 296 "cache.cpp"
int any_term(Node *srch , Node *in ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 299
  if (! in) {
#line 299
    return (0);
  }
#line 301
  if ((int )in->ntyp == 258) {
#line 302
    tmp = any_term(srch, in->lft);
#line 302
    if (tmp) {
#line 302
      tmp___1 = 1;
    } else {
#line 302
      tmp___0 = any_term(srch, in->rgt);
#line 302
      if (tmp___0) {
#line 302
        tmp___1 = 1;
      } else {
#line 302
        tmp___1 = 0;
      }
    }
#line 302
    return (tmp___1);
  }
#line 305
  tmp___2 = isequal(in, srch);
#line 305
  return (tmp___2);
}
}
#line 308 "cache.cpp"
int any_and(Node *srch , Node *in ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 311
  if (! in) {
#line 311
    return (0);
  }
#line 313
  if ((int )srch->ntyp == 258) {
#line 314
    tmp = any_and(srch->lft, in);
#line 314
    if (tmp) {
#line 314
      tmp___0 = any_and(srch->rgt, in);
#line 314
      if (tmp___0) {
#line 314
        tmp___1 = 1;
      } else {
#line 314
        tmp___1 = 0;
      }
    } else {
#line 314
      tmp___1 = 0;
    }
#line 314
    return (tmp___1);
  }
#line 317
  tmp___2 = any_term(srch, in);
#line 317
  return (tmp___2);
}
}
#line 320 "cache.cpp"
int any_lor(Node *srch , Node *in ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 323
  if (! in) {
#line 323
    return (0);
  }
#line 325
  if ((int )in->ntyp == 264) {
#line 326
    tmp = any_lor(srch, in->lft);
#line 326
    if (tmp) {
#line 326
      tmp___1 = 1;
    } else {
#line 326
      tmp___0 = any_lor(srch, in->rgt);
#line 326
      if (tmp___0) {
#line 326
        tmp___1 = 1;
      } else {
#line 326
        tmp___1 = 0;
      }
    }
#line 326
    return (tmp___1);
  }
#line 329
  tmp___2 = isequal(in, srch);
#line 329
  return (tmp___2);
}
}
#line 332 "cache.cpp"
int anywhere(int tok , Node *srch , Node *in ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 335
  if (! in) {
#line 335
    return (0);
  }
#line 337
  switch (tok) {
  case 258: 
#line 338
  tmp = any_and(srch, in);
#line 338
  return (tmp);
  case 264: 
#line 339
  tmp___0 = any_lor(srch, in);
#line 339
  return (tmp___0);
  case 0: 
#line 340
  tmp___1 = any_term(srch, in);
#line 340
  return (tmp___1);
  }
#line 342
  fatal((char *)"cannot happen, anywhere", (char *)0);
#line 343
  return (0);
}
}
#line 1 "generalized.o"
#pragma merger(0,"./generalized.i","")
#line 180 "ltl2ba.h"
void free_all_atrans(void) ;
#line 181
GTrans *emalloc_gtrans(void) ;
#line 182
void free_gtrans(GTrans *t , GTrans *sentinel , int fly ) ;
#line 201
void mk_generalized(void) ;
#line 208
int *new_set(int type ) ;
#line 212
int *dup_set(int *l , int type ) ;
#line 217
void rem_set(int *l , int n ) ;
#line 225
int *list_set(int *l , int type ) ;
#line 40 "generalized.cpp"
int tl_fjtofj ;
#line 44 "generalized.cpp"
GState *gstack  ;
#line 44 "generalized.cpp"
GState *gremoved  ;
#line 44 "generalized.cpp"
GState *gstates  ;
#line 44 "generalized.cpp"
GState **init  ;
#line 45 "generalized.cpp"
GScc *gscc_stack  ;
#line 46 "generalized.cpp"
int init_size  =    0;
#line 46 "generalized.cpp"
int gstate_id  =    1;
#line 46 "generalized.cpp"
int gstate_count  =    0;
#line 46 "generalized.cpp"
int gtrans_count  =    0;
#line 47 "generalized.cpp"
int *fin  ;
#line 47 "generalized.cpp"
int *final  ;
#line 47 "generalized.cpp"
int rank  ;
#line 47 "generalized.cpp"
int scc_id  ;
#line 47 "generalized.cpp"
int scc_size  ;
#line 47 "generalized.cpp"
int *bad_scc  ;
#line 49
void print_generalized(void) ;
#line 55 "generalized.cpp"
void free_gstate(GState *s ) 
{ 

  {
#line 57
  free_gtrans((s->trans)->nxt, s->trans, 1);
#line 58
  tfree((void *)s->nodes_set);
#line 59
  tfree((void *)s);
#line 60
  return;
}
}
#line 62 "generalized.cpp"
GState *remove_gstate(GState *s , GState *s1 ) 
{ GState *prv ;

  {
#line 64
  prv = s->prv;
#line 65
  (s->prv)->nxt = s->nxt;
#line 66
  (s->nxt)->prv = s->prv;
#line 67
  free_gtrans((s->trans)->nxt, s->trans, 0);
#line 68
  s->trans = (GTrans *)0;
#line 69
  tfree((void *)s->nodes_set);
#line 70
  s->nodes_set = (int *)0;
#line 71
  s->nxt = gremoved->nxt;
#line 72
  gremoved->nxt = s;
#line 73
  s->prv = s1;
#line 74
  s1 = gremoved->nxt;
#line 74
  while ((unsigned int )s1 != (unsigned int )gremoved) {
#line 75
    if ((unsigned int )s1->prv == (unsigned int )s) {
#line 76
      s1->prv = s->prv;
    }
#line 74
    s1 = s1->nxt;
  }
#line 77
  return (prv);
}
}
#line 80 "generalized.cpp"
void copy_gtrans(GTrans *from , GTrans *to ) 
{ 

  {
#line 82
  to->to = from->to;
#line 83
  copy_set(from->pos, to->pos, 1);
#line 84
  copy_set(from->neg, to->neg, 1);
#line 85
  copy_set(from->final, to->final, 0);
#line 86
  return;
}
}
#line 88 "generalized.cpp"
int same_gtrans(GState *a , GTrans *s , GState *b , GTrans *t , int use_scc ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 90
  if ((unsigned int )s->to != (unsigned int )t->to) {
#line 93
    return (0);
  } else {
#line 90
    tmp = same_sets(s->pos, t->pos, 1);
#line 90
    if (tmp) {
#line 90
      tmp___0 = same_sets(s->neg, t->neg, 1);
#line 90
      if (! tmp___0) {
#line 93
        return (0);
      }
    } else {
#line 93
      return (0);
    }
  }
#line 94
  tmp___1 = same_sets(s->final, t->final, 0);
#line 94
  if (tmp___1) {
#line 95
    return (1);
  }
#line 97
  if (use_scc) {
#line 97
    tmp___2 = in_set(bad_scc, a->incoming);
#line 97
    if (tmp___2) {
#line 102
      return (1);
    } else {
#line 97
      tmp___3 = in_set(bad_scc, b->incoming);
#line 97
      if (tmp___3) {
#line 102
        return (1);
      } else {
#line 97
        if (a->incoming != (s->to)->incoming) {
#line 102
          return (1);
        } else {
#line 97
          if (b->incoming != (t->to)->incoming) {
#line 102
            return (1);
          }
        }
      }
    }
  }
#line 103
  return (0);
#line 105
  if (! use_scc) {
#line 106
    return (0);
  }
#line 107
  if (a->incoming == b->incoming) {
#line 107
    if (a->incoming == (s->to)->incoming) {
#line 108
      return (0);
    }
  }
#line 112
  return (1);
}
}
#line 115 "generalized.cpp"
int simplify_gtrans(void) 
{ int changed ;
  GState *s ;
  GTrans *t ;
  GTrans *t1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  GTrans *free ;

  {
#line 117
  changed = 0;
#line 123
  s = gstates->nxt;
#line 123
  while ((unsigned int )s != (unsigned int )gstates) {
#line 124
    t = (s->trans)->nxt;
#line 125
    while ((unsigned int )t != (unsigned int )s->trans) {
#line 126
      copy_gtrans(t, s->trans);
#line 127
      t1 = (s->trans)->nxt;
#line 128
      while (1) {
#line 128
        if ((unsigned int )t != (unsigned int )t1) {
#line 128
          if ((unsigned int )t1->to == (unsigned int )t->to) {
#line 128
            tmp = included_set(t1->pos, t->pos, 1);
#line 128
            if (tmp) {
#line 128
              tmp___0 = included_set(t1->neg, t->neg, 1);
#line 128
              if (tmp___0) {
#line 128
                tmp___1 = included_set(t->final, t1->final, 0);
#line 128
                if (tmp___1) {
#line 128
                  break;
                } else {
#line 128
                  if (tl_simp_scc) {
#line 128
                    if (s->incoming != (t->to)->incoming) {
#line 128
                      break;
                    } else {
#line 128
                      tmp___2 = in_set(bad_scc, s->incoming);
#line 128
                      if (tmp___2) {
#line 128
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 134
        t1 = t1->nxt;
      }
#line 135
      if ((unsigned int )t1 != (unsigned int )s->trans) {
#line 136
        free = t->nxt;
#line 137
        t->to = free->to;
#line 138
        copy_set(free->pos, t->pos, 1);
#line 139
        copy_set(free->neg, t->neg, 1);
#line 140
        copy_set(free->final, t->final, 0);
#line 141
        t->nxt = free->nxt;
#line 142
        if ((unsigned int )free == (unsigned int )s->trans) {
#line 142
          s->trans = t;
        }
#line 143
        free_gtrans(free, (GTrans *)0, 0);
#line 144
        changed ++;
      } else {
#line 147
        t = t->nxt;
      }
    }
#line 123
    s = s->nxt;
  }
#line 159
  return (changed);
}
}
#line 162 "generalized.cpp"
void retarget_all_gtrans(void) 
{ GState *s ;
  GTrans *t ;
  int i ;
  GTrans *free ;

  {
#line 167
  i = 0;
#line 167
  while (i < init_size) {
#line 168
    if (*(init + i)) {
#line 168
      if (! (*(init + i))->trans) {
#line 169
        *(init + i) = (*(init + i))->prv;
      }
    }
#line 167
    i ++;
  }
#line 170
  s = gstates->nxt;
#line 170
  while ((unsigned int )s != (unsigned int )gstates) {
#line 171
    t = (s->trans)->nxt;
#line 171
    while ((unsigned int )t != (unsigned int )s->trans) {
#line 172
      if (! (t->to)->trans) {
#line 173
        t->to = (t->to)->prv;
#line 174
        if (! t->to) {
#line 175
          free = t->nxt;
#line 176
          t->to = free->to;
#line 177
          copy_set(free->pos, t->pos, 1);
#line 178
          copy_set(free->neg, t->neg, 1);
#line 179
          copy_set(free->final, t->final, 0);
#line 180
          t->nxt = free->nxt;
#line 181
          if ((unsigned int )free == (unsigned int )s->trans) {
#line 181
            s->trans = t;
          }
#line 182
          free_gtrans(free, (GTrans *)0, 0);
        } else {
#line 185
          t = t->nxt;
        }
      } else {
#line 188
        t = t->nxt;
      }
    }
#line 170
    s = s->nxt;
  }
#line 189
  while ((unsigned int )gremoved->nxt != (unsigned int )gremoved) {
#line 190
    s = gremoved->nxt;
#line 191
    gremoved->nxt = (gremoved->nxt)->nxt;
#line 192
    if (s->nodes_set) {
#line 192
      tfree((void *)s->nodes_set);
    }
#line 193
    tfree((void *)s);
  }
#line 195
  return;
}
}
#line 197 "generalized.cpp"
int all_gtrans_match(GState *a , GState *b , int use_scc ) 
{ GTrans *s ;
  GTrans *t ;
  int tmp ;
  int tmp___0 ;

  {
#line 200
  s = (a->trans)->nxt;
#line 200
  while ((unsigned int )s != (unsigned int )a->trans) {
#line 202
    copy_gtrans(s, b->trans);
#line 203
    t = (b->trans)->nxt;
#line 204
    while (1) {
#line 204
      tmp = same_gtrans(a, s, b, t, use_scc);
#line 204
      if (tmp) {
#line 204
        break;
      }
#line 204
      t = t->nxt;
    }
#line 205
    if ((unsigned int )t == (unsigned int )b->trans) {
#line 205
      return (0);
    }
#line 200
    s = s->nxt;
  }
#line 207
  t = (b->trans)->nxt;
#line 207
  while ((unsigned int )t != (unsigned int )b->trans) {
#line 209
    copy_gtrans(t, a->trans);
#line 210
    s = (a->trans)->nxt;
#line 211
    while (1) {
#line 211
      tmp___0 = same_gtrans(a, s, b, t, use_scc);
#line 211
      if (tmp___0) {
#line 211
        break;
      }
#line 211
      s = s->nxt;
    }
#line 212
    if ((unsigned int )s == (unsigned int )a->trans) {
#line 212
      return (0);
    }
#line 207
    t = t->nxt;
  }
#line 214
  return (1);
}
}
#line 217 "generalized.cpp"
int simplify_gstates(void) 
{ int changed ;
  GState *a ;
  GState *b ;
  int tmp ;

  {
#line 219
  changed = 0;
#line 224
  a = gstates->nxt;
#line 224
  while ((unsigned int )a != (unsigned int )gstates) {
#line 225
    if ((unsigned int )a->trans == (unsigned int )(a->trans)->nxt) {
#line 226
      a = remove_gstate(a, (GState *)0);
#line 227
      changed ++;
      goto __Cont;
    }
#line 230
    gstates->trans = a->trans;
#line 231
    b = a->nxt;
#line 232
    while (1) {
#line 232
      tmp = all_gtrans_match(a, b, tl_simp_scc);
#line 232
      if (tmp) {
#line 232
        break;
      }
#line 232
      b = b->nxt;
    }
#line 233
    if ((unsigned int )b != (unsigned int )gstates) {
#line 235
      if (a->incoming > b->incoming) {
#line 236
        a = remove_gstate(a, b);
      } else {
#line 238
        remove_gstate(b, a);
      }
#line 239
      changed ++;
    }
    __Cont: /* CIL Label */ 
#line 224
    a = a->nxt;
  }
#line 242
  retarget_all_gtrans();
#line 252
  return (changed);
}
}
#line 255 "generalized.cpp"
int gdfs(GState *s ) 
{ GTrans *t ;
  GScc *c ;
  GScc *scc ;
  void *tmp ;
  int tmp___0 ;
  int result ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 258
  tmp = tl_emalloc((int )sizeof(GScc ));
#line 258
  scc = (GScc *)tmp;
#line 259
  scc->gstate = s;
#line 260
  scc->rank = rank;
#line 261
  tmp___0 = rank;
#line 261
  rank ++;
#line 261
  scc->theta = tmp___0;
#line 262
  scc->nxt = gscc_stack;
#line 263
  gscc_stack = scc;
#line 265
  s->incoming = 1;
#line 267
  t = (s->trans)->nxt;
#line 267
  while ((unsigned int )t != (unsigned int )s->trans) {
#line 268
    if ((t->to)->incoming == 0) {
#line 269
      tmp___1 = gdfs(t->to);
#line 269
      result = tmp___1;
#line 270
      if (scc->theta < result) {
#line 270
        scc->theta = scc->theta;
      } else {
#line 270
        scc->theta = result;
      }
    } else {
#line 273
      c = gscc_stack->nxt;
#line 273
      while ((unsigned int )c != (unsigned int )((GScc *)0)) {
#line 274
        if ((unsigned int )c->gstate == (unsigned int )t->to) {
#line 275
          if (scc->theta < c->rank) {
#line 275
            scc->theta = scc->theta;
          } else {
#line 275
            scc->theta = c->rank;
          }
#line 276
          break;
        }
#line 273
        c = c->nxt;
      }
    }
#line 267
    t = t->nxt;
  }
#line 280
  if (scc->rank == scc->theta) {
#line 281
    while ((unsigned int )gscc_stack != (unsigned int )scc) {
#line 282
      (gscc_stack->gstate)->incoming = scc_id;
#line 283
      gscc_stack = gscc_stack->nxt;
    }
#line 285
    tmp___2 = scc_id;
#line 285
    scc_id ++;
#line 285
    (scc->gstate)->incoming = tmp___2;
#line 286
    gscc_stack = scc->nxt;
  }
#line 288
  return (scc->theta);
}
}
#line 291 "generalized.cpp"
void simplify_gscc(void) 
{ GState *s ;
  GTrans *t ;
  int i ;
  int **scc_final ;
  void *tmp ;
  int tmp___0 ;

  {
#line 295
  rank = 1;
#line 296
  gscc_stack = (GScc *)0;
#line 297
  scc_id = 1;
#line 299
  if ((unsigned int )gstates == (unsigned int )gstates->nxt) {
#line 299
    return;
  }
#line 301
  s = gstates->nxt;
#line 301
  while ((unsigned int )s != (unsigned int )gstates) {
#line 302
    s->incoming = 0;
#line 301
    s = s->nxt;
  }
#line 304
  i = 0;
#line 304
  while (i < init_size) {
#line 305
    if (*(init + i)) {
#line 305
      if ((*(init + i))->incoming == 0) {
#line 306
        gdfs(*(init + i));
      }
    }
#line 304
    i ++;
  }
#line 308
  tmp = tl_emalloc((int )((unsigned int )scc_id * sizeof(int *)));
#line 308
  scc_final = (int **)tmp;
#line 309
  i = 0;
#line 309
  while (i < scc_id) {
#line 310
    *(scc_final + i) = make_set(-1, 0);
#line 309
    i ++;
  }
#line 312
  s = gstates->nxt;
#line 312
  while ((unsigned int )s != (unsigned int )gstates) {
#line 313
    if (s->incoming == 0) {
#line 314
      s = remove_gstate(s, (GState *)0);
    } else {
#line 316
      t = (s->trans)->nxt;
#line 316
      while ((unsigned int )t != (unsigned int )s->trans) {
#line 317
        if ((t->to)->incoming == s->incoming) {
#line 318
          merge_sets(*(scc_final + s->incoming), t->final, 0);
        }
#line 316
        t = t->nxt;
      }
    }
#line 312
    s = s->nxt;
  }
#line 320
  scc_size = (int )((unsigned int )(scc_id + 1) / (8U * sizeof(int )) + 1U);
#line 321
  bad_scc = make_set(-1, 2);
#line 323
  i = 0;
#line 323
  while (i < scc_id) {
#line 324
    tmp___0 = included_set(final_set, *(scc_final + i), 0);
#line 324
    if (! tmp___0) {
#line 325
      add_set(bad_scc, i);
    }
#line 323
    i ++;
  }
#line 327
  i = 0;
#line 327
  while (i < scc_id) {
#line 328
    tfree((void *)*(scc_final + i));
#line 327
    i ++;
  }
#line 329
  tfree((void *)scc_final);
#line 330
  return;
}
}
#line 336 "generalized.cpp"
int is_final(int *from , ATrans *at , int i ) 
{ ATrans *t ;
  int in_to ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 340
  if (tl_fjtofj) {
#line 340
    tmp = in_set(at->to, i);
#line 340
    if (tmp) {
      goto _L;
    } else {
#line 341
      return (1);
    }
  } else {
    _L: /* CIL Label */ 
#line 340
    if (! tl_fjtofj) {
#line 340
      tmp___0 = in_set(from, i);
#line 340
      if (! tmp___0) {
#line 341
        return (1);
      }
    }
  }
#line 342
  in_to = in_set(at->to, i);
#line 343
  rem_set(at->to, i);
#line 344
  t = *(transition + i);
#line 344
  while (t) {
#line 345
    tmp___1 = included_set(t->to, at->to, 0);
#line 345
    if (tmp___1) {
#line 345
      tmp___2 = included_set(t->pos, at->pos, 1);
#line 345
      if (tmp___2) {
#line 345
        tmp___3 = included_set(t->neg, at->neg, 1);
#line 345
        if (tmp___3) {
#line 348
          if (in_to) {
#line 348
            add_set(at->to, i);
          }
#line 349
          return (1);
        }
      }
    }
#line 344
    t = t->nxt;
  }
#line 351
  if (in_to) {
#line 351
    add_set(at->to, i);
  }
#line 352
  return (0);
}
}
#line 355 "generalized.cpp"
GState *find_gstate(int *set , GState *s ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 358
  tmp = same_sets(set, s->nodes_set, 0);
#line 358
  if (tmp) {
#line 358
    return (s);
  }
#line 360
  s = gstack->nxt;
#line 361
  gstack->nodes_set = set;
#line 362
  while (1) {
#line 362
    tmp___0 = same_sets(set, s->nodes_set, 0);
#line 362
    if (tmp___0) {
#line 362
      break;
    }
#line 363
    s = s->nxt;
  }
#line 364
  if ((unsigned int )s != (unsigned int )gstack) {
#line 364
    return (s);
  }
#line 366
  s = gstates->nxt;
#line 367
  gstates->nodes_set = set;
#line 368
  while (1) {
#line 368
    tmp___1 = same_sets(set, s->nodes_set, 0);
#line 368
    if (tmp___1) {
#line 368
      break;
    }
#line 369
    s = s->nxt;
  }
#line 370
  if ((unsigned int )s != (unsigned int )gstates) {
#line 370
    return (s);
  }
#line 372
  s = gremoved->nxt;
#line 373
  gremoved->nodes_set = set;
#line 374
  while (1) {
#line 374
    tmp___2 = same_sets(set, s->nodes_set, 0);
#line 374
    if (tmp___2) {
#line 374
      break;
    }
#line 375
    s = s->nxt;
  }
#line 376
  if ((unsigned int )s != (unsigned int )gremoved) {
#line 376
    return (s);
  }
#line 378
  tmp___3 = tl_emalloc((int )sizeof(GState ));
#line 378
  s = (GState *)tmp___3;
#line 379
  tmp___6 = empty_set(set, 0);
#line 379
  if (tmp___6) {
#line 379
    s->id = 0;
  } else {
#line 379
    tmp___5 = gstate_id;
#line 379
    gstate_id ++;
#line 379
    s->id = tmp___5;
  }
#line 380
  s->incoming = 0;
#line 381
  s->nodes_set = dup_set(set, 0);
#line 382
  s->trans = emalloc_gtrans();
#line 383
  (s->trans)->nxt = s->trans;
#line 384
  s->nxt = gstack->nxt;
#line 385
  gstack->nxt = s;
#line 386
  return (s);
}
}
#line 389 "generalized.cpp"
void make_gtrans(GState *s ) 
{ int i ;
  int *list ;
  int state_trans ;
  int trans_exist ;
  GState *s1 ;
  ATrans *t1 ;
  AProd *prod ;
  void *tmp ;
  AProd *p ;
  void *tmp___0 ;
  AProd *p___0 ;
  GTrans *trans___0 ;
  GTrans *t2 ;
  int tmp___1 ;
  GTrans *free___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  AProd *p___1 ;
  int tmp___10 ;

  {
#line 390
  state_trans = 0;
#line 390
  trans_exist = 1;
#line 394
  tmp = tl_emalloc((int )sizeof(AProd ));
#line 394
  prod = (AProd *)tmp;
#line 395
  prod->nxt = prod;
#line 396
  prod->prv = prod;
#line 397
  prod->prod = emalloc_atrans();
#line 398
  clear_set((prod->prod)->to, 0);
#line 399
  clear_set((prod->prod)->pos, 1);
#line 400
  clear_set((prod->prod)->neg, 1);
#line 401
  prod->trans = prod->prod;
#line 402
  (prod->trans)->nxt = prod->prod;
#line 403
  list = list_set(s->nodes_set, 0);
#line 405
  i = 1;
#line 405
  while (i < *(list + 0)) {
#line 406
    tmp___0 = tl_emalloc((int )sizeof(AProd ));
#line 406
    p = (AProd *)tmp___0;
#line 407
    p->astate = *(list + i);
#line 408
    p->trans = *(transition + *(list + i));
#line 409
    if (! p->trans) {
#line 409
      trans_exist = 0;
    }
#line 410
    p->prod = merge_trans((prod->nxt)->prod, p->trans);
#line 411
    p->nxt = prod->nxt;
#line 412
    p->prv = prod;
#line 413
    (p->nxt)->prv = p;
#line 414
    (p->prv)->nxt = p;
#line 405
    i ++;
  }
#line 417
  while (trans_exist) {
#line 418
    p___0 = prod->nxt;
#line 419
    t1 = p___0->prod;
#line 420
    if (t1) {
#line 422
      clear_set(fin, 0);
#line 423
      i = 1;
#line 423
      while (i < *(final + 0)) {
#line 425
        tmp___1 = is_final(s->nodes_set, t1, *(final + i));
#line 425
        if (tmp___1) {
#line 426
          add_set(fin, *(final + i));
        }
#line 423
        i ++;
      }
#line 429
      t2 = (s->trans)->nxt;
#line 429
      while ((unsigned int )t2 != (unsigned int )s->trans) {
#line 431
        if (tl_simp_fly) {
#line 431
          tmp___6 = included_set(t1->to, (t2->to)->nodes_set, 0);
#line 431
          if (tmp___6) {
#line 431
            tmp___7 = included_set(t1->pos, t2->pos, 1);
#line 431
            if (tmp___7) {
#line 431
              tmp___8 = included_set(t1->neg, t2->neg, 1);
#line 431
              if (tmp___8) {
#line 431
                tmp___9 = same_sets(fin, t2->final, 0);
#line 431
                if (tmp___9) {
#line 436
                  free___0 = t2->nxt;
#line 437
                  ((t2->to)->incoming) --;
#line 438
                  t2->to = free___0->to;
#line 439
                  copy_set(free___0->pos, t2->pos, 1);
#line 440
                  copy_set(free___0->neg, t2->neg, 1);
#line 441
                  copy_set(free___0->final, t2->final, 0);
#line 442
                  t2->nxt = free___0->nxt;
#line 443
                  if ((unsigned int )free___0 == (unsigned int )s->trans) {
#line 443
                    s->trans = t2;
                  }
#line 444
                  free_gtrans(free___0, (GTrans *)0, 0);
#line 445
                  state_trans --;
                } else {
                  goto _L___2;
                }
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 447
          if (tl_simp_fly) {
#line 447
            tmp___2 = included_set((t2->to)->nodes_set, t1->to, 0);
#line 447
            if (tmp___2) {
#line 447
              tmp___3 = included_set(t2->pos, t1->pos, 1);
#line 447
              if (tmp___3) {
#line 447
                tmp___4 = included_set(t2->neg, t1->neg, 1);
#line 447
                if (tmp___4) {
#line 447
                  tmp___5 = same_sets(t2->final, fin, 0);
#line 447
                  if (tmp___5) {
#line 452
                    break;
                  } else {
#line 455
                    t2 = t2->nxt;
                  }
                } else {
#line 455
                  t2 = t2->nxt;
                }
              } else {
#line 455
                t2 = t2->nxt;
              }
            } else {
#line 455
              t2 = t2->nxt;
            }
          } else {
#line 455
            t2 = t2->nxt;
          }
        }
      }
#line 458
      if ((unsigned int )t2 == (unsigned int )s->trans) {
#line 459
        trans___0 = emalloc_gtrans();
#line 460
        trans___0->to = find_gstate(t1->to, s);
#line 461
        ((trans___0->to)->incoming) ++;
#line 462
        copy_set(t1->pos, trans___0->pos, 1);
#line 463
        copy_set(t1->neg, trans___0->neg, 1);
#line 464
        copy_set(fin, trans___0->final, 0);
#line 465
        trans___0->nxt = (s->trans)->nxt;
#line 466
        (s->trans)->nxt = trans___0;
#line 467
        state_trans ++;
      }
    }
#line 470
    if (! p___0->trans) {
#line 471
      break;
    }
#line 472
    while (! (p___0->trans)->nxt) {
#line 473
      p___0 = p___0->nxt;
    }
#line 474
    if ((unsigned int )p___0 == (unsigned int )prod) {
#line 475
      break;
    }
#line 476
    p___0->trans = (p___0->trans)->nxt;
#line 477
    do_merge_trans(& p___0->prod, (p___0->nxt)->prod, p___0->trans);
#line 478
    p___0 = p___0->prv;
#line 479
    while ((unsigned int )p___0 != (unsigned int )prod) {
#line 480
      p___0->trans = *(transition + p___0->astate);
#line 481
      do_merge_trans(& p___0->prod, (p___0->nxt)->prod, p___0->trans);
#line 482
      p___0 = p___0->prv;
    }
  }
#line 486
  tfree((void *)list);
#line 487
  while ((unsigned int )prod->nxt != (unsigned int )prod) {
#line 488
    p___1 = prod->nxt;
#line 489
    prod->nxt = p___1->nxt;
#line 490
    free_atrans(p___1->prod, 0);
#line 491
    tfree((void *)p___1);
  }
#line 493
  free_atrans(prod->prod, 0);
#line 494
  tfree((void *)prod);
#line 496
  if (tl_simp_fly) {
#line 497
    if ((unsigned int )s->trans == (unsigned int )(s->trans)->nxt) {
#line 498
      free_gtrans((s->trans)->nxt, s->trans, 1);
#line 499
      s->trans = (GTrans *)0;
#line 500
      s->prv = (GState *)0;
#line 501
      s->nxt = gremoved->nxt;
#line 502
      gremoved->nxt = s;
#line 503
      s1 = gremoved->nxt;
#line 503
      while ((unsigned int )s1 != (unsigned int )gremoved) {
#line 504
        if ((unsigned int )s1->prv == (unsigned int )s) {
#line 505
          s1->prv = (GState *)0;
        }
#line 503
        s1 = s1->nxt;
      }
#line 506
      return;
    }
#line 509
    gstates->trans = s->trans;
#line 510
    s1 = gstates->nxt;
#line 511
    while (1) {
#line 511
      tmp___10 = all_gtrans_match(s, s1, 0);
#line 511
      if (tmp___10) {
#line 511
        break;
      }
#line 512
      s1 = s1->nxt;
    }
#line 513
    if ((unsigned int )s1 != (unsigned int )gstates) {
#line 514
      free_gtrans((s->trans)->nxt, s->trans, 1);
#line 515
      s->trans = (GTrans *)0;
#line 516
      s->prv = s1;
#line 517
      s->nxt = gremoved->nxt;
#line 518
      gremoved->nxt = s;
#line 519
      s1 = gremoved->nxt;
#line 519
      while ((unsigned int )s1 != (unsigned int )gremoved) {
#line 520
        if ((unsigned int )s1->prv == (unsigned int )s) {
#line 521
          s1->prv = s->prv;
        }
#line 519
        s1 = s1->nxt;
      }
#line 522
      return;
    }
  }
#line 526
  s->nxt = gstates->nxt;
#line 527
  s->prv = gstates;
#line 528
  (s->nxt)->prv = s;
#line 529
  gstates->nxt = s;
#line 530
  gtrans_count += state_trans;
#line 531
  gstate_count ++;
#line 532
  return;
}
}
#line 538 "generalized.cpp"
void reverse_print_generalized(GState *s ) 
{ GTrans *t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 541
  if ((unsigned int )s == (unsigned int )gstates) {
#line 541
    return;
  }
#line 543
  reverse_print_generalized(s->nxt);
#line 545
  fprintf(tl_out, "state %i (", s->id);
#line 546
  print_set(s->nodes_set, 0);
#line 547
  fprintf(tl_out, ") : %i\n", s->incoming);
#line 548
  t = (s->trans)->nxt;
#line 548
  while ((unsigned int )t != (unsigned int )s->trans) {
#line 549
    tmp = empty_set(t->pos, 1);
#line 549
    if (tmp) {
#line 549
      tmp___0 = empty_set(t->neg, 1);
#line 549
      if (tmp___0) {
#line 550
        fprintf(tl_out, "1");
      }
    }
#line 551
    print_set(t->pos, 1);
#line 552
    tmp___1 = empty_set(t->pos, 1);
#line 552
    if (! tmp___1) {
#line 552
      tmp___2 = empty_set(t->neg, 1);
#line 552
      if (! tmp___2) {
#line 552
        fprintf(tl_out, " & ");
      }
    }
#line 553
    print_set(t->neg, 1);
#line 554
    fprintf(tl_out, " -> %i : ", (t->to)->id);
#line 555
    print_set(t->final, 0);
#line 556
    fprintf(tl_out, "\n");
#line 548
    t = t->nxt;
  }
#line 558
  return;
}
}
#line 560 "generalized.cpp"
void print_generalized(void) 
{ int i ;

  {
#line 562
  fprintf(tl_out, "init :\n");
#line 563
  i = 0;
#line 563
  while (i < init_size) {
#line 564
    if (*(init + i)) {
#line 565
      fprintf(tl_out, "%i\n", (*(init + i))->id);
    }
#line 563
    i ++;
  }
#line 566
  reverse_print_generalized(gstates->nxt);
#line 567
  return;
}
}
#line 573 "generalized.cpp"
void mk_generalized(void) 
{ ATrans *t ;
  GState *s ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 581
  fin = new_set(0);
#line 582
  bad_scc = (int *)0;
#line 583
  final = list_set(final_set, 0);
#line 585
  tmp = tl_emalloc((int )sizeof(GState ));
#line 585
  gstack = (GState *)tmp;
#line 586
  gstack->nxt = gstack;
#line 587
  tmp___0 = tl_emalloc((int )sizeof(GState ));
#line 587
  gremoved = (GState *)tmp___0;
#line 588
  gremoved->nxt = gremoved;
#line 589
  tmp___1 = tl_emalloc((int )sizeof(GState ));
#line 589
  gstates = (GState *)tmp___1;
#line 590
  gstates->nxt = gstates;
#line 591
  gstates->prv = gstates;
#line 593
  t = *(transition + 0);
#line 593
  while (t) {
#line 594
    tmp___2 = tl_emalloc((int )sizeof(GState ));
#line 594
    s = (GState *)tmp___2;
#line 595
    tmp___5 = empty_set(t->to, 0);
#line 595
    if (tmp___5) {
#line 595
      s->id = 0;
    } else {
#line 595
      tmp___4 = gstate_id;
#line 595
      gstate_id ++;
#line 595
      s->id = tmp___4;
    }
#line 596
    s->incoming = 1;
#line 597
    s->nodes_set = dup_set(t->to, 0);
#line 598
    s->trans = emalloc_gtrans();
#line 599
    (s->trans)->nxt = s->trans;
#line 600
    s->nxt = gstack->nxt;
#line 601
    gstack->nxt = s;
#line 602
    init_size ++;
#line 593
    t = t->nxt;
  }
#line 605
  if (init_size) {
#line 605
    tmp___6 = tl_emalloc((int )((unsigned int )init_size * sizeof(GState *)));
#line 605
    init = (GState **)tmp___6;
  }
#line 606
  init_size = 0;
#line 607
  s = gstack->nxt;
#line 607
  while ((unsigned int )s != (unsigned int )gstack) {
#line 608
    tmp___7 = init_size;
#line 608
    init_size ++;
#line 608
    *(init + tmp___7) = s;
#line 607
    s = s->nxt;
  }
#line 610
  while ((unsigned int )gstack->nxt != (unsigned int )gstack) {
#line 611
    s = gstack->nxt;
#line 612
    gstack->nxt = (gstack->nxt)->nxt;
#line 613
    if (! s->incoming) {
#line 614
      free_gstate(s);
#line 615
      continue;
    }
#line 617
    make_gtrans(s);
  }
#line 620
  retarget_all_gtrans();
#line 630
  tfree((void *)gstack);
#line 633
  free_all_atrans();
#line 634
  tfree((void *)transition);
#line 636
  if (tl_verbose) {
#line 637
    fprintf(tl_out, "\nGeneralized Buchi automaton before simplification\n");
#line 638
    print_generalized();
  }
#line 641
  if (tl_simp_diff) {
#line 642
    if (tl_simp_scc) {
#line 642
      simplify_gscc();
    }
#line 643
    simplify_gtrans();
#line 644
    if (tl_simp_scc) {
#line 644
      simplify_gscc();
    }
#line 645
    while (1) {
#line 645
      tmp___8 = simplify_gstates();
#line 645
      if (! tmp___8) {
#line 645
        break;
      }
#line 646
      if (tl_simp_scc) {
#line 646
        simplify_gscc();
      }
#line 647
      simplify_gtrans();
#line 648
      if (tl_simp_scc) {
#line 648
        simplify_gscc();
      }
    }
#line 651
    if (tl_verbose) {
#line 652
      fprintf(tl_out, "\nGeneralized Buchi automaton after simplification\n");
#line 653
      print_generalized();
    }
  }
#line 656
  return;
}
}
#line 1 "lex.o"
#pragma merger(0,"./lex.i","")
#line 10 "/usr/include/ctype.h"
extern int ( __attribute__((__cdecl__)) isalnum)(int  ) ;
#line 15
extern int ( __attribute__((__cdecl__)) islower)(int  ) ;
#line 217 "/usr/include/stdio.h"
//extern int ( __attribute__((__cdecl__)) sprintf)(char * , char const   *  , ...) ;
#line 31 "/usr/include/string.h"
extern char *( __attribute__((__cdecl__)) strcpy)(char * , char const   * ) ;
#line 34
extern size_t ( __attribute__((__cdecl__)) strlen)(char const   * ) ;
#line 166 "ltl2ba.h"
Symbol *tl_lookup(char *s ) ;
#line 167
Symbol *getsym(Symbol *s ) ;
#line 175
int tl_Getchar(void) ;
#line 195
void tl_UnGetchar(void) ;
#line 197
void tl_yyerror(char *s1 ) ;
#line 37 "lex.cpp"
static Symbol *symtab[256]  ;
#line 38
static int tl_lex(void) ;
#line 40
Nodeptr tl_yylval ;
#line 41 "lex.cpp"
char yytext[2048]  ;
#line 45 "lex.cpp"
int isalnum_(int c ) 
{ int tmp ;
  int tmp___0 ;

  {
#line 47
  tmp = isalnum(c);
#line 47
  if (tmp) {
#line 47
    tmp___0 = 1;
  } else {
#line 47
    if (c == 95) {
#line 47
      tmp___0 = 1;
    } else {
#line 47
      tmp___0 = 0;
    }
  }
#line 47
  return (tmp___0);
}
}
#line 50 "lex.cpp"
int hash(char *s ) 
{ int h ;
  char *tmp ;

  {
#line 52
  h = 0;
#line 54
  while (*s) {
#line 55
    tmp = s;
#line 55
    s ++;
#line 55
    h += (int )*tmp;
#line 56
    h <<= 1;
#line 57
    if (h & 256) {
#line 58
      h |= 1;
    }
  }
#line 60
  return (h & 255);
}
}
#line 63 "lex.cpp"
static void getword(int first , int (*tst)(int  ) ) 
{ int i ;
  char c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 65
  i = 0;
#line 67
  tmp = i;
#line 67
  i ++;
#line 67
  yytext[tmp] = (char )first;
#line 68
  while (1) {
#line 68
    tmp___1 = tl_Getchar();
#line 68
    c = (char )tmp___1;
#line 68
    tmp___2 = (*tst)((int )c);
#line 68
    if (! tmp___2) {
#line 68
      break;
    }
#line 69
    tmp___0 = i;
#line 69
    i ++;
#line 69
    yytext[tmp___0] = c;
  }
#line 70
  yytext[i] = (char )'\000';
#line 71
  tl_UnGetchar();
#line 72
  return;
}
}
#line 78
int tl_yychar ;
#line 74 "lex.cpp"
static int follow(int tok , int ifyes , int ifno ) 
{ int c ;
  char buf[32] ;

  {
#line 80
  c = tl_Getchar();
#line 80
  if (c == tok) {
#line 81
    return (ifyes);
  }
#line 82
  tl_UnGetchar();
#line 83
  tl_yychar = c;
#line 84
  sprintf(buf, "expected \'%c\'", tok);
#line 85
  tl_yyerror(buf);
#line 86
  return (ifno);
}
}
#line 89 "lex.cpp"
int tl_yylex(void) 
{ int c ;
  int tmp ;

  {
#line 91
  tmp = tl_lex();
#line 91
  c = tmp;
#line 95
  return (c);
}
}
#line 98 "lex.cpp"
static int tl_lex(void) 
{ int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 102
  while (1) {
#line 103
    c = tl_Getchar();
#line 104
    yytext[0] = (char )c;
#line 105
    yytext[1] = (char )'\000';
#line 107
    if (c <= 0) {
#line 108
      tl_yylval = tl_nn(';', (Node *)0, (Node *)0);
#line 108
      return (';');
    }
#line 102
    if (! (c == 32)) {
#line 102
      break;
    }
  }
#line 113
  tmp___1 = islower(c);
#line 113
  if (tmp___1) {
#line 114
    getword(c, & isalnum_);
#line 115
    tmp = strcmp("true", (char const   *)(yytext));
#line 115
    if (tmp == 0) {
#line 116
      tl_yylval = tl_nn(266, (Node *)0, (Node *)0);
#line 116
      return (266);
    }
#line 118
    tmp___0 = strcmp("false", (char const   *)(yytext));
#line 118
    if (tmp___0 == 0) {
#line 119
      tl_yylval = tl_nn(261, (Node *)0, (Node *)0);
#line 119
      return (261);
    }
#line 121
    tl_yylval = tl_nn(265, (Node *)0, (Node *)0);
#line 122
    tl_yylval->sym = tl_lookup(yytext);
#line 123
    return (265);
  }
#line 125
  if (c == 60) {
#line 126
    c = tl_Getchar();
#line 127
    if (c == 62) {
#line 128
      tl_yylval = tl_nn(260, (Node *)0, (Node *)0);
#line 128
      return (260);
    }
#line 130
    if (c != 45) {
#line 131
      tl_UnGetchar();
#line 132
      tl_yyerror((char *)"expected \'<>\' or \'<->\'");
    }
#line 134
    c = tl_Getchar();
#line 135
    if (c == 62) {
#line 136
      tl_yylval = tl_nn(259, (Node *)0, (Node *)0);
#line 136
      return (259);
    }
#line 138
    tl_UnGetchar();
#line 139
    tl_yyerror((char *)"expected \'<->\'");
  }
#line 142
  switch (c) {
  case 47: 
#line 143
  c = follow('\\', 258, '/');
#line 143
  break;
  case 92: 
#line 144
  c = follow('/', 264, '\\');
#line 144
  break;
  case 38: 
#line 145
  c = follow('&', 258, '&');
#line 145
  break;
  case 124: 
#line 146
  c = follow('|', 264, '|');
#line 146
  break;
  case 91: 
#line 147
  c = follow(']', 257, '[');
#line 147
  break;
  case 45: 
#line 148
  c = follow('>', 262, '-');
#line 148
  break;
  case 33: 
#line 149
  c = 263;
#line 149
  break;
  case 85: 
#line 150
  c = 267;
#line 150
  break;
  case 86: 
#line 151
  c = 268;
#line 151
  break;
  default: ;
#line 155
  break;
  }
#line 157
  tl_yylval = tl_nn(c, (Node *)0, (Node *)0);
#line 157
  return (c);
}
}
#line 160 "lex.cpp"
Symbol *tl_lookup(char *s ) 
{ Symbol *sp ;
  int h ;
  int tmp ;
  int j ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 163
  tmp = hash(s);
#line 163
  h = tmp;
#line 164
  j = 0;
#line 164
  while (j < 256) {
#line 166
    symtab[j] = (Symbol *)0;
#line 164
    j ++;
  }
#line 169
  sp = symtab[h];
#line 169
  while (sp) {
#line 170
    tmp___0 = strcmp((char const   *)sp->name, (char const   *)s);
#line 170
    if (tmp___0 == 0) {
#line 171
      return (sp);
    }
#line 169
    sp = sp->next;
  }
#line 173
  tmp___1 = tl_emalloc((int )sizeof(Symbol ));
#line 173
  sp = (Symbol *)tmp___1;
#line 174
  tmp___2 = strlen((char const   *)s);
#line 174
  tmp___3 = tl_emalloc((int )(tmp___2 + 1U));
#line 174
  sp->name = (char *)tmp___3;
#line 175
  strcpy(sp->name, (char const   *)s);
#line 176
  sp->next = symtab[h];
#line 177
  symtab[h] = sp;
#line 179
  return (sp);
}
}
#line 182 "lex.cpp"
Symbol *getsym(Symbol *s ) 
{ Symbol *n ;
  void *tmp ;

  {
#line 184
  tmp = tl_emalloc((int )sizeof(Symbol ));
#line 184
  n = (Symbol *)tmp;
#line 186
  n->name = s->name;
#line 187
  return (n);
}
}
#line 1 "main.o"
#pragma merger(0,"./main.i","")
#line 810 "/usr/include/sys/reent.h"
extern struct _reent *( __attribute__((__cdecl__)) __getreent)(void) ;
#line 172 "/usr/include/stdio.h"
extern int ( __attribute__((__cdecl__)) fclose)(FILE * ) ;
#line 173
extern int ( __attribute__((__cdecl__)) fflush)(FILE * ) ;
#line 186
extern char *( __attribute__((__cdecl__)) fgets)(char * , int  , FILE * ) ;
#line 216
extern FILE *( __attribute__((__cdecl__)) fopen)(char const   *_name , char const   *_type ) ;
#line 26 "/usr/include/string.h"
extern void *( __attribute__((__cdecl__)) memset)(void * , int  , size_t  ) ;
#line 170 "ltl2ba.h"
char *emalloc(int n ) ;
#line 185
void a_stats(void) ;
#line 189
void Fatal(char *s1 , char *s2 ) ;
#line 194
void tl_explain(int n ) ;
#line 196
void tl_parse(void) ;
#line 35 "main.cpp"
FILE *tl_out  ;
#line 37 "main.cpp"
int tl_stats  =    0;
#line 38 "main.cpp"
int tl_simp_log  =    1;
#line 39 "main.cpp"
int tl_simp_diff  =    1;
#line 40 "main.cpp"
int tl_simp_fly  =    1;
#line 41 "main.cpp"
int tl_simp_scc  =    1;
#line 42 "main.cpp"
int tl_fjtofj  =    1;
#line 43 "main.cpp"
int tl_errs  =    0;
#line 44 "main.cpp"
int tl_verbose  =    0;
#line 45 "main.cpp"
int tl_terse  =    0;
#line 46 "main.cpp"
unsigned long All_Mem  =    0UL;
#line 48 "main.cpp"
static char uform[4096]  ;
#line 49 "main.cpp"
static int hasuform  =    0;
#line 49 "main.cpp"
static int cnt  =    0;
#line 50 "main.cpp"
static char **ltl_file  =    (char **)0;
#line 51 "main.cpp"
static char **add_ltl  =    (char **)0;
#line 52 "main.cpp"
static char out1[64]  ;
#line 54
static void tl_endstats(void) ;
#line 55
static void non_fatal(char *s1 , char *s2 ) ;
#line 61
extern int ( /* missing proto */  unlink)() ;
#line 62
extern int ( /* missing proto */  exit)() ;
#line 57 "main.cpp"
void alldone(int estatus ) 
{ size_t tmp ;

  {
#line 60
  tmp = strlen((char const   *)(out1));
#line 60
  if (tmp > 0U) {
#line 61
    unlink((char const   *)(out1));
  }
#line 62
  exit(estatus);
}
}
#line 65 "main.cpp"
FILE *cpyfile(char *src , char *tgt ) 
{ FILE *inp ;
  FILE *out ;
  char buf[1024] ;
  char *tmp ;

  {
#line 70
  inp = fopen((char const   *)src, "r");
#line 71
  out = fopen((char const   *)tgt, "w");
#line 72
  if (! inp) {
#line 73
    printf("ltl2ba: cannot cp %s to %s\n", src, tgt);
#line 74
    alldone(1);
  } else {
#line 72
    if (! out) {
#line 73
      printf("ltl2ba: cannot cp %s to %s\n", src, tgt);
#line 74
      alldone(1);
    }
  }
#line 76
  while (1) {
#line 76
    tmp = fgets(buf, 1024, inp);
#line 76
    if (! tmp) {
#line 76
      break;
    }
#line 77
    fprintf(out, "%s", buf);
  }
#line 78
  fclose(inp);
#line 79
  return (out);
}
}
#line 86
extern int ( /* missing proto */  malloc)() ;
#line 82 "main.cpp"
char *emalloc(int n ) 
{ char *tmp ;
  int tmp___0 ;

  {
#line 86
  tmp___0 = malloc(n);
#line 86
  tmp = (char *)tmp___0;
#line 86
  if (! tmp) {
#line 87
    fatal((char *)"not enough memory", (char *)0);
  }
#line 88
  memset((void *)tmp, 0, (unsigned int )n);
#line 89
  return (tmp);
}
}
#line 92 "main.cpp"
int tl_Getchar(void) 
{ int tmp ;

  {
#line 95
  if (cnt < hasuform) {
#line 96
    tmp = cnt;
#line 96
    cnt ++;
#line 96
    return ((int )uform[tmp]);
  }
#line 97
  cnt ++;
#line 98
  return (-1);
}
}
#line 101 "main.cpp"
void put_uform(void) 
{ 

  {
#line 104
  fprintf(tl_out, "%s", uform);
#line 105
  return;
}
}
#line 107 "main.cpp"
void tl_UnGetchar(void) 
{ 

  {
#line 110
  if (cnt > 0) {
#line 110
    cnt --;
  }
#line 111
  return;
}
}
#line 113 "main.cpp"
void usage(void) 
{ 

  {
#line 116
  printf("usage: ltl2ba [-flag] -f formula\n");
#line 117
  printf("                   or -F file\n");
#line 118
  printf(" -f \"formula\"\ttranslate LTL ");
#line 119
  printf("into never claim\n");
#line 120
  printf(" -F file\tlike -f, but with the LTL ");
#line 121
  printf("formula stored in a 1-line file\n");
#line 122
  printf(" -d\t\tdisplay automata (D)escription at each step\n");
#line 123
  printf(" -s\t\tcomputing time and automata sizes (S)tatistics\n");
#line 124
  printf(" -l\t\tdisable (L)ogic formula simplification\n");
#line 125
  printf(" -p\t\tdisable a-(P)osteriori simplification\n");
#line 126
  printf(" -o\t\tdisable (O)n-the-fly simplification\n");
#line 127
  printf(" -c\t\tdisable strongly (C)onnected components simplification\n");
#line 128
  printf(" -a\t\tdisable trick in (A)ccepting conditions\n");
#line 130
  alldone(1);
#line 131
  return;
}
}
#line 133 "main.cpp"
int tl_main(int argc , char **argv ) 
{ int i ;
  size_t tmp ;

  {
#line 136
  while (1) {
#line 136
    if (argc > 1) {
#line 136
      if (! ((int )*(*(argv + 1) + 0) == 45)) {
#line 136
        break;
      }
    } else {
#line 136
      break;
    }
#line 137
    switch ((int )*(*(argv + 1) + 1)) {
    case 102: 
#line 138
    argc --;
#line 138
    argv ++;
#line 139
    i = 0;
#line 139
    while (i < (int )*(*(argv + 1) + i)) {
#line 140
      if ((int )*(*(argv + 1) + i) == 9) {
#line 143
        *(*(argv + 1) + i) = (char )' ';
      } else {
#line 140
        if ((int )*(*(argv + 1) + i) == 34) {
#line 143
          *(*(argv + 1) + i) = (char )' ';
        } else {
#line 140
          if ((int )*(*(argv + 1) + i) == 10) {
#line 143
            *(*(argv + 1) + i) = (char )' ';
          }
        }
      }
#line 139
      i ++;
    }
#line 145
    strcpy(uform, (char const   *)*(argv + 1));
#line 146
    tmp = strlen((char const   *)(uform));
#line 146
    hasuform = (int )tmp;
#line 147
    break;
    default: 
#line 148
    usage();
    }
#line 150
    argc --;
#line 150
    argv ++;
  }
#line 152
  if (hasuform == 0) {
#line 152
    usage();
  }
#line 153
  tl_parse();
#line 154
  if (tl_stats) {
#line 154
    tl_endstats();
  }
#line 155
  return (tl_errs);
}
}
#line 158 "main.cpp"
int main(int argc , char **argv ) 
{, struct _reent *tmp ;
  char formula[4096] ;
  struct _reent *tmp___0 ;
  char out2[64] ;
  int tmp___1 ;

  {
#line 161
  tmp = __getreent();
#line 161
  tl_out = tmp->_stdout;
#line 163
  while (1) {
#line 163
    if (argc > 1) {
#line 163
      if (! ((int )*(*(argv + 1) + 0) == 45)) {
#line 163
        break;
      }
    } else {
#line 163
      break;
    }
#line 164
    switch ((int )*(*(argv + 1) + 1)) {
    case 70: 
#line 165
    ltl_file = argv + 2;
#line 166
    argc --;
#line 166
    argv ++;
#line 166
    break;
    case 102: 
#line 167
    add_ltl = argv;
#line 168
    argc --;
#line 168
    argv ++;
#line 168
    break;
    case 97: 
#line 169
    tl_fjtofj = 0;
#line 169
    break;
    case 99: 
#line 170
    tl_simp_scc = 0;
#line 170
    break;
    case 111: 
#line 171
    tl_simp_fly = 0;
#line 171
    break;
    case 112: 
#line 172
    tl_simp_diff = 0;
#line 172
    break;
    case 108: 
#line 173
    tl_simp_log = 0;
#line 173
    break;
    case 100: 
#line 174
    tl_verbose = 1;
#line 174
    break;
    case 115: 
#line 175
    tl_stats = 1;
#line 175
    break;
    default: 
#line 176
    usage();
#line 176
    break;
    }
#line 178
    argc --;
#line 178
    argv ++;
  }
#line 181
  if (! ltl_file) {
#line 181
    if (! add_ltl) {
#line 182
      usage();
    }
  }
#line 184
  if (ltl_file) {
#line 186
    add_ltl = ltl_file - 2;
#line 186
    *(*(add_ltl + 1) + 1) = (char )'f';
#line 187
    tl_out = fopen((char const   *)*ltl_file, "r");
#line 187
    if (! tl_out) {
#line 188
      printf("ltl2ba: cannot open %s\n", *ltl_file);
#line 189
      alldone(1);
    }
#line 191
    fgets(formula, 4096, tl_out);
#line 192
    fclose(tl_out);
#line 193
    tmp___0 = __getreent();
#line 193
    tl_out = tmp___0->_stdout;
#line 194
    *ltl_file = formula;
  }
#line 196
  if (argc > 1) {
#line 198
    strcpy(out1, "_tmp1_");
#line 199
    strcpy(out2, "_tmp2_");
#line 200
    tl_out = cpyfile(*(argv + 1), out2);
#line 201
    tl_main(2, add_ltl);
#line 202
    fclose(tl_out);
  } else {
#line 205
    if (argc > 0) {
#line 206
      tmp___1 = tl_main(2, add_ltl);
#line 206
      exit(tmp___1);
    }
#line 207
    usage();
  }
#line 209
  return (0);
}
}
#line 230 "main.cpp"
static void tl_endstats(void) 
{ 

  {
#line 233
  printf("\ntotal memory used: %9ld\n", All_Mem);
#line 236
  a_stats();
#line 237
  return;
}
}
#line 246 "main.cpp"
void dump(Node *n ) 
{ 

  {
#line 249
  if (! n) {
#line 249
    return;
  }
#line 251
  switch ((int )n->ntyp) {
  case 264: 
#line 252
  fprintf(tl_out, "(");
#line 252
  dump(n->lft);
#line 252
  fprintf(tl_out, " || ");
#line 252
  dump(n->rgt);
#line 252
  fprintf(tl_out, ")");
#line 252
  break;
  case 258: 
#line 253
  fprintf(tl_out, "(");
#line 253
  dump(n->lft);
#line 253
  fprintf(tl_out, " && ");
#line 253
  dump(n->rgt);
#line 253
  fprintf(tl_out, ")");
#line 253
  break;
  case 267: 
#line 254
  fprintf(tl_out, "(");
#line 254
  dump(n->lft);
#line 254
  fprintf(tl_out, " U ");
#line 254
  dump(n->rgt);
#line 254
  fprintf(tl_out, ")");
#line 254
  break;
  case 268: 
#line 255
  fprintf(tl_out, "(");
#line 255
  dump(n->lft);
#line 255
  fprintf(tl_out, " V ");
#line 255
  dump(n->rgt);
#line 255
  fprintf(tl_out, ")");
#line 255
  break;
  case 263: 
#line 265
  fprintf(tl_out, "!");
#line 266
  fprintf(tl_out, " (");
#line 267
  dump(n->lft);
#line 268
  fprintf(tl_out, ")");
#line 269
  break;
  case 261: 
#line 271
  fprintf(tl_out, "false");
#line 272
  break;
  case 266: 
#line 274
  fprintf(tl_out, "true");
#line 275
  break;
  case 265: 
#line 277
  fprintf(tl_out, "(%s)", (n->sym)->name);
#line 278
  break;
  case -1: 
#line 280
  fprintf(tl_out, " D ");
#line 281
  break;
  default: 
#line 283
  printf("Unknown token: ");
#line 284
  tl_explain((int )n->ntyp);
#line 285
  break;
  }
#line 287
  return;
}
}
#line 289 "main.cpp"
void tl_explain(int n ) 
{ 

  {
#line 292
  switch (n) {
  case 257: 
#line 293
  printf("[]");
#line 293
  break;
  case 260: 
#line 294
  printf("<>");
#line 294
  break;
  case 262: 
#line 295
  printf("->");
#line 295
  break;
  case 259: 
#line 296
  printf("<->");
#line 296
  break;
  case 265: 
#line 297
  printf("predicate");
#line 297
  break;
  case 264: 
#line 298
  printf("||");
#line 298
  break;
  case 258: 
#line 299
  printf("&&");
#line 299
  break;
  case 263: 
#line 300
  printf("!");
#line 300
  break;
  case 267: 
#line 301
  printf("U");
#line 301
  break;
  case 268: 
#line 302
  printf("V");
#line 302
  break;
  case 266: 
#line 306
  printf("true");
#line 306
  break;
  case 261: 
#line 307
  printf("false");
#line 307
  break;
  case 59: 
#line 308
  printf("end of formula");
#line 308
  break;
  default: 
#line 309
  printf("%c", n);
#line 309
  break;
  }
#line 311
  return;
}
}
#line 313 "main.cpp"
static void non_fatal(char *s1 , char *s2 ) 
{ int i ;
  struct _reent *tmp ;

  {
#line 318
  printf("ltl2ba: ");
#line 319
  if (s2) {
#line 320
    printf((char const   *)s1, s2);
  } else {
#line 322
    printf((char const   *)s1);
  }
#line 323
  if (tl_yychar != -1) {
#line 323
    if (tl_yychar != 0) {
#line 324
      printf(", saw \'");
#line 325
      tl_explain(tl_yychar);
#line 326
      printf("\'");
    }
  }
#line 328
  printf("\nltl2ba: %s\n---------", uform);
#line 329
  i = 0;
#line 329
  while (i < cnt) {
#line 330
    printf("-");
#line 329
    i ++;
  }
#line 331
  printf("^\n");
#line 332
  tmp = __getreent();
#line 332
  fflush(tmp->_stdout);
#line 333
  tl_errs ++;
#line 334
  return;
}
}
#line 336 "main.cpp"
void tl_yyerror(char *s1 ) 
{ 

  {
#line 339
  Fatal(s1, (char *)0);
#line 340
  return;
}
}
#line 342 "main.cpp"
void Fatal(char *s1 , char *s2 ) 
{ 

  {
#line 345
  non_fatal(s1, s2);
#line 346
  alldone(1);
#line 347
  return;
}
}
#line 349 "main.cpp"
void fatal(char *s1 , char *s2 ) 
{ 

  {
#line 352
  non_fatal(s1, s2);
#line 353
  alldone(1);
#line 354
  return;
}
}
#line 1 "mem.o"
#pragma merger(0,"./mem.i","")
#line 53 "mem.cpp"
ATrans *atrans_list  =    (ATrans *)0;
#line 54 "mem.cpp"
GTrans *gtrans_list  =    (GTrans *)0;
#line 55 "mem.cpp"
BTrans *btrans_list  =    (BTrans *)0;
#line 57 "mem.cpp"
int aallocs  =    0;
#line 57 "mem.cpp"
int afrees  =    0;
#line 57 "mem.cpp"
int apool  =    0;
#line 58 "mem.cpp"
int gallocs  =    0;
#line 58 "mem.cpp"
int gfrees  =    0;
#line 58 "mem.cpp"
int gpool  =    0;
#line 59 "mem.cpp"
int ballocs  =    0;
#line 59 "mem.cpp"
int bfrees  =    0;
#line 59 "mem.cpp"
int bpool  =    0;
#line 66 "mem.cpp"
static union M *freelist[80]  ;
#line 67 "mem.cpp"
static long req[80]  ;
#line 68 "mem.cpp"
static long event[3][80]  ;
#line 70 "mem.cpp"
void *tl_emalloc(int U ) 
{ union M *m ;
  long r ;
  long u ;
  void *rp ;
  char *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;

  {
#line 76
  u = (long )((unsigned int )(U - 1) / sizeof(union M ) + 2U);
#line 78
  if (u >= 80L) {
#line 79
    (event[1][0]) ++;
#line 80
    if (tl_verbose) {
#line 81
      printf("tl_spin: memalloc %ld bytes\n", u);
    }
#line 82
    tmp = emalloc((int )((unsigned int )((int )u) * sizeof(union M )));
#line 82
    m = (union M *)tmp;
#line 83
    All_Mem += (unsigned long )u * (unsigned long )sizeof(union M );
  } else {
#line 85
    if (! freelist[u]) {
#line 86
      if (req[u]) {
#line 86
        tmp___0 = req[u];
      } else {
#line 86
        tmp___0 = 1L;
      }
#line 86
      req[u] += tmp___0;
#line 86
      r = req[u];
#line 87
      if (r >= 32768L) {
#line 88
        tmp___1 = 32768L;
#line 88
        req[u] = tmp___1;
#line 88
        r = tmp___1;
      }
#line 89
      event[0][(int )u] += r;
#line 90
      tmp___2 = emalloc((int )((unsigned long )((long )((int )r) * u) * (unsigned long )sizeof(union M )));
#line 90
      freelist[u] = (union M *)tmp___2;
#line 92
      All_Mem += ((unsigned long )r * (unsigned long )u) * (unsigned long )sizeof(union M );
#line 93
      m = freelist[u] + (r - 2L) * u;
#line 94
      while ((unsigned int )m >= (unsigned int )freelist[u]) {
#line 95
        m->link = m + u;
#line 94
        m -= u;
      }
    }
#line 97
    (event[1][(int )u]) ++;
#line 98
    m = freelist[u];
#line 99
    freelist[u] = m->link;
  }
#line 101
  m->size = u | 1426063360L;
#line 103
  r = 1L;
#line 103
  while (r < u) {
#line 104
    tmp___3 = r;
#line 104
    r ++;
#line 104
    *(& m->size + tmp___3) = 0L;
  }
#line 106
  rp = (void *)(m + 1);
#line 107
  memset(rp, 0, (unsigned int )U);
#line 111
  return (rp);
}
}
#line 114 "mem.cpp"
void tfree(void *v ) 
{ 

  {
#line 132
  return;
}
}
#line 134 "mem.cpp"
ATrans *emalloc_atrans(void) 
{ ATrans *result ;
  void *tmp ;

  {
#line 136
  if (! atrans_list) {
#line 137
    tmp = tl_emalloc((int )sizeof(GTrans ));
#line 137
    result = (ATrans *)tmp;
#line 138
    result->pos = new_set(1);
#line 139
    result->neg = new_set(1);
#line 140
    result->to = new_set(0);
#line 141
    apool ++;
  } else {
#line 144
    result = atrans_list;
#line 145
    atrans_list = atrans_list->nxt;
#line 146
    result->nxt = (ATrans *)0;
  }
#line 148
  aallocs ++;
#line 149
  return (result);
}
}
#line 152 "mem.cpp"
void free_atrans(ATrans *t , int rec ) 
{ 

  {
#line 153
  if (! t) {
#line 153
    return;
  }
#line 154
  if (rec) {
#line 154
    free_atrans(t->nxt, rec);
  }
#line 155
  t->nxt = atrans_list;
#line 156
  atrans_list = t;
#line 157
  afrees ++;
#line 158
  return;
}
}
#line 160 "mem.cpp"
void free_all_atrans(void) 
{ ATrans *t ;

  {
#line 162
  while (atrans_list) {
#line 163
    t = atrans_list;
#line 164
    atrans_list = t->nxt;
#line 165
    tfree((void *)t->to);
#line 166
    tfree((void *)t->pos);
#line 167
    tfree((void *)t->neg);
#line 168
    tfree((void *)t);
  }
#line 170
  return;
}
}
#line 172 "mem.cpp"
GTrans *emalloc_gtrans(void) 
{ GTrans *result ;
  void *tmp ;

  {
#line 174
  if (! gtrans_list) {
#line 175
    tmp = tl_emalloc((int )sizeof(GTrans ));
#line 175
    result = (GTrans *)tmp;
#line 176
    result->pos = new_set(1);
#line 177
    result->neg = new_set(1);
#line 178
    result->final = new_set(0);
#line 179
    gpool ++;
  } else {
#line 182
    result = gtrans_list;
#line 183
    gtrans_list = gtrans_list->nxt;
  }
#line 185
  gallocs ++;
#line 186
  return (result);
}
}
#line 189 "mem.cpp"
void free_gtrans(GTrans *t , GTrans *sentinel , int fly ) 
{ 

  {
#line 190
  gfrees ++;
#line 191
  if (sentinel) {
#line 191
    if ((unsigned int )t != (unsigned int )sentinel) {
#line 192
      free_gtrans(t->nxt, sentinel, fly);
#line 193
      if (fly) {
#line 193
        ((t->to)->incoming) --;
      }
    }
  }
#line 195
  t->nxt = gtrans_list;
#line 196
  gtrans_list = t;
#line 197
  return;
}
}
#line 199 "mem.cpp"
BTrans *emalloc_btrans(void) 
{ BTrans *result ;
  void *tmp ;

  {
#line 201
  if (! btrans_list) {
#line 202
    tmp = tl_emalloc((int )sizeof(BTrans ));
#line 202
    result = (BTrans *)tmp;
#line 203
    result->pos = new_set(1);
#line 204
    result->neg = new_set(1);
#line 205
    bpool ++;
  } else {
#line 208
    result = btrans_list;
#line 209
    btrans_list = btrans_list->nxt;
  }
#line 211
  ballocs ++;
#line 212
  return (result);
}
}
#line 215 "mem.cpp"
void free_btrans(BTrans *t , BTrans *sentinel , int fly ) 
{ 

  {
#line 216
  bfrees ++;
#line 217
  if (sentinel) {
#line 217
    if ((unsigned int )t != (unsigned int )sentinel) {
#line 218
      free_btrans(t->nxt, sentinel, fly);
#line 219
      if (fly) {
#line 219
        ((t->to)->incoming) --;
      }
    }
  }
#line 221
  t->nxt = btrans_list;
#line 222
  btrans_list = t;
#line 223
  return;
}
}
#line 225 "mem.cpp"
void a_stats(void) 
{ long p ;
  long a ;
  long f ;
  int i ;

  {
#line 230
  printf(" size\t  pool\tallocs\t frees\n");
#line 232
  i = 0;
#line 232
  while (i < 80) {
#line 233
    p = event[0][i];
#line 234
    a = event[1][i];
#line 235
    f = event[2][i];
#line 237
    if ((p | a) | f) {
#line 238
      printf("%5d\t%6ld\t%6ld\t%6ld\n", i, p, a, f);
    }
#line 232
    i ++;
  }
#line 242
  printf("atrans\t%6d\t%6d\t%6d\n", apool, aallocs, afrees);
#line 244
  printf("gtrans\t%6d\t%6d\t%6d\n", gpool, gallocs, gfrees);
#line 246
  printf("btrans\t%6d\t%6d\t%6d\n", bpool, ballocs, bfrees);
#line 248
  return;
}
}
#line 1 "parse.o"
#pragma merger(0,"./parse.i","")
#line 157 "ltl2ba.h"
Node *canonical(Node *n ) ;
#line 162
Node *push_negation(Node *n ) ;
#line 163
Node *right_linked(Node *n ) ;
#line 198
void trans(Node *p ) ;
#line 38 "parse.cpp"
int tl_yychar  =    0;
#line 39 "parse.cpp"
Nodeptr tl_yylval  ;
#line 41
static Node *tl_formula(void) ;
#line 42
static Node *tl_factor(void) ;
#line 43
static Node *tl_level(int nr ) ;
#line 45 "parse.cpp"
static int prec[2][4]  = { {        267,        268,        0,        0}, 
   {        264,        258,        262,        259}};
#line 50 "parse.cpp"
static int implies(Node *a , Node *b ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 53
  tmp = isequal(a, b);
#line 53
  if (tmp) {
#line 53
    tmp___16 = 1;
  } else {
#line 53
    if ((int )b->ntyp == 266) {
#line 53
      tmp___16 = 1;
    } else {
#line 53
      if ((int )a->ntyp == 261) {
#line 53
        tmp___16 = 1;
      } else {
#line 53
        if ((int )b->ntyp == 258) {
#line 53
          tmp___0 = implies(a, b->lft);
#line 53
          if (tmp___0) {
#line 53
            tmp___1 = implies(a, b->rgt);
#line 53
            if (tmp___1) {
#line 53
              tmp___16 = 1;
            } else {
              goto _L___11;
            }
          } else {
            goto _L___11;
          }
        } else {
          _L___11: /* CIL Label */ 
#line 53
          if ((int )a->ntyp == 264) {
#line 53
            tmp___2 = implies(a->lft, b);
#line 53
            if (tmp___2) {
#line 53
              tmp___3 = implies(a->rgt, b);
#line 53
              if (tmp___3) {
#line 53
                tmp___16 = 1;
              } else {
                goto _L___9;
              }
            } else {
              goto _L___9;
            }
          } else {
            _L___9: /* CIL Label */ 
#line 53
            if ((int )a->ntyp == 258) {
#line 53
              tmp___4 = implies(a->lft, b);
#line 53
              if (tmp___4) {
#line 53
                tmp___16 = 1;
              } else {
#line 53
                tmp___5 = implies(a->rgt, b);
#line 53
                if (tmp___5) {
#line 53
                  tmp___16 = 1;
                } else {
                  goto _L___7;
                }
              }
            } else {
              _L___7: /* CIL Label */ 
#line 53
              if ((int )b->ntyp == 264) {
#line 53
                tmp___6 = implies(a, b->lft);
#line 53
                if (tmp___6) {
#line 53
                  tmp___16 = 1;
                } else {
#line 53
                  tmp___7 = implies(a, b->rgt);
#line 53
                  if (tmp___7) {
#line 53
                    tmp___16 = 1;
                  } else {
                    goto _L___6;
                  }
                }
              } else {
                _L___6: /* CIL Label */ 
#line 53
                if ((int )b->ntyp == 267) {
#line 53
                  tmp___8 = implies(a, b->rgt);
#line 53
                  if (tmp___8) {
#line 53
                    tmp___16 = 1;
                  } else {
                    goto _L___5;
                  }
                } else {
                  _L___5: /* CIL Label */ 
#line 53
                  if ((int )a->ntyp == 268) {
#line 53
                    tmp___9 = implies(a->rgt, b);
#line 53
                    if (tmp___9) {
#line 53
                      tmp___16 = 1;
                    } else {
                      goto _L___4;
                    }
                  } else {
                    _L___4: /* CIL Label */ 
#line 53
                    if ((int )a->ntyp == 267) {
#line 53
                      tmp___10 = implies(a->lft, b);
#line 53
                      if (tmp___10) {
#line 53
                        tmp___11 = implies(a->rgt, b);
#line 53
                        if (tmp___11) {
#line 53
                          tmp___16 = 1;
                        } else {
                          goto _L___3;
                        }
                      } else {
                        goto _L___3;
                      }
                    } else {
                      _L___3: /* CIL Label */ 
#line 53
                      if ((int )b->ntyp == 268) {
#line 53
                        tmp___12 = implies(a, b->lft);
#line 53
                        if (tmp___12) {
#line 53
                          tmp___13 = implies(a, b->rgt);
#line 53
                          if (tmp___13) {
#line 53
                            tmp___16 = 1;
                          } else {
                            goto _L___1;
                          }
                        } else {
                          goto _L___1;
                        }
                      } else {
                        _L___1: /* CIL Label */ 
#line 53
                        if ((int )a->ntyp == 267) {
                          goto _L;
                        } else {
#line 53
                          if ((int )a->ntyp == 268) {
                            _L: /* CIL Label */ 
#line 53
                            if ((int )a->ntyp == (int )b->ntyp) {
#line 53
                              tmp___14 = implies(a->lft, b->lft);
#line 53
                              if (tmp___14) {
#line 53
                                tmp___15 = implies(a->rgt, b->rgt);
#line 53
                                if (tmp___15) {
#line 53
                                  tmp___16 = 1;
                                } else {
#line 53
                                  tmp___16 = 0;
                                }
                              } else {
#line 53
                                tmp___16 = 0;
                              }
                            } else {
#line 53
                              tmp___16 = 0;
                            }
                          } else {
#line 53
                            tmp___16 = 0;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 53
  return (tmp___16);
}
}
#line 69 "parse.cpp"
static Node *bin_simpler(Node *ptr ) 
{ Node *a ;
  Node *b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Node *tmp___2 ;
  Node *tmp___3 ;
  Node *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  Node *tmp___8 ;
  Node *tmp___9 ;
  Node *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  Node *tmp___13 ;
  Node *tmp___14 ;
  Node *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  Node *tmp___18 ;
  Node *tmp___19 ;
  Node *tmp___20 ;
  Node *tmp___21 ;
  Node *tmp___22 ;
  Node *tmp___23 ;
  Node *tmp___24 ;
  Node *tmp___25 ;
  Node *tmp___26 ;
  Node *tmp___27 ;
  Node *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  Node *tmp___33 ;
  int tmp___34 ;
  Node *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  Node *tmp___41 ;
  Node *tmp___42 ;
  Node *tmp___43 ;
  Node *tmp___44 ;
  Node *tmp___45 ;
  Node *tmp___46 ;
  Node *tmp___47 ;
  int tmp___48 ;
  Node *tmp___49 ;
  Node *tmp___50 ;
  Node *tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  Node *tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  Node *tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  Node *tmp___63 ;
  Node *tmp___64 ;
  Node *tmp___65 ;
  Node *tmp___66 ;
  Node *tmp___67 ;
  Node *tmp___68 ;
  Node *tmp___69 ;
  int tmp___70 ;
  Node *tmp___71 ;
  Node *tmp___72 ;
  Node *tmp___73 ;
  int tmp___74 ;

  {
#line 73
  if (ptr) {
#line 74
    switch ((int )ptr->ntyp) {
    case 267: 
#line 76
    if ((int )(ptr->rgt)->ntyp == 266) {
#line 79
      ptr = ptr->rgt;
#line 80
      break;
    } else {
#line 76
      if ((int )(ptr->rgt)->ntyp == 261) {
#line 79
        ptr = ptr->rgt;
#line 80
        break;
      } else {
#line 76
        if ((int )(ptr->lft)->ntyp == 261) {
#line 79
          ptr = ptr->rgt;
#line 80
          break;
        }
      }
    }
#line 82
    tmp = implies(ptr->lft, ptr->rgt);
#line 82
    if (tmp) {
#line 83
      ptr = ptr->rgt;
#line 84
      break;
    }
#line 86
    if ((int )(ptr->lft)->ntyp == 267) {
#line 86
      tmp___0 = isequal((ptr->lft)->lft, ptr->rgt);
#line 86
      if (tmp___0) {
#line 89
        ptr->lft = (ptr->lft)->rgt;
#line 90
        break;
      }
    }
#line 92
    if ((int )(ptr->rgt)->ntyp == 267) {
#line 92
      tmp___1 = implies(ptr->lft, (ptr->rgt)->lft);
#line 92
      if (tmp___1) {
#line 95
        ptr = ptr->rgt;
#line 96
        break;
      }
    }
#line 119
    if ((int )(ptr->lft)->ntyp == 266) {
#line 119
      if ((int )(ptr->rgt)->ntyp == 268) {
#line 119
        if ((int )((ptr->rgt)->lft)->ntyp == 261) {
#line 119
          if ((int )((ptr->rgt)->rgt)->ntyp == 267) {
#line 119
            if ((int )(((ptr->rgt)->rgt)->lft)->ntyp == 266) {
#line 124
              ptr = ptr->rgt;
#line 125
              break;
            }
          }
        }
      }
    }
#line 129
    if ((int )(ptr->lft)->ntyp != 266) {
#line 129
      tmp___2 = dupnode(ptr->rgt);
#line 129
      tmp___3 = tl_nn(263, tmp___2, (Node *)0);
#line 129
      tmp___4 = push_negation(tmp___3);
#line 129
      tmp___5 = implies(tmp___4, ptr->lft);
#line 129
      if (tmp___5) {
#line 132
        ptr->lft = tl_nn(266, (Node *)0, (Node *)0);
#line 133
        break;
      }
    }
#line 135
    break;
    case 268: 
#line 137
    if ((int )(ptr->rgt)->ntyp == 261) {
#line 140
      ptr = ptr->rgt;
#line 141
      break;
    } else {
#line 137
      if ((int )(ptr->rgt)->ntyp == 266) {
#line 140
        ptr = ptr->rgt;
#line 141
        break;
      } else {
#line 137
        if ((int )(ptr->lft)->ntyp == 266) {
#line 140
          ptr = ptr->rgt;
#line 141
          break;
        }
      }
    }
#line 143
    tmp___6 = implies(ptr->rgt, ptr->lft);
#line 143
    if (tmp___6) {
#line 145
      ptr = ptr->rgt;
#line 146
      break;
    }
#line 149
    if ((int )(ptr->lft)->ntyp == 261) {
#line 149
      if ((int )(ptr->rgt)->ntyp == 268) {
#line 151
        ptr->rgt = (ptr->rgt)->rgt;
#line 152
        break;
      }
    }
#line 163
    if ((int )(ptr->lft)->ntyp == 261) {
#line 163
      if ((int )(ptr->rgt)->ntyp == 267) {
#line 163
        if ((int )((ptr->rgt)->lft)->ntyp == 266) {
#line 163
          if ((int )((ptr->rgt)->rgt)->ntyp == 268) {
#line 163
            if ((int )(((ptr->rgt)->rgt)->lft)->ntyp == 261) {
#line 168
              ptr = ptr->rgt;
#line 169
              break;
            }
          }
        }
      }
    }
#line 173
    if ((int )(ptr->rgt)->ntyp == 268) {
#line 173
      tmp___7 = implies((ptr->rgt)->lft, ptr->lft);
#line 173
      if (tmp___7) {
#line 175
        ptr = ptr->rgt;
#line 176
        break;
      }
    }
#line 180
    if ((int )(ptr->lft)->ntyp != 261) {
#line 180
      tmp___8 = dupnode(ptr->rgt);
#line 180
      tmp___9 = tl_nn(263, tmp___8, (Node *)0);
#line 180
      tmp___10 = push_negation(tmp___9);
#line 180
      tmp___11 = implies(ptr->lft, tmp___10);
#line 180
      if (tmp___11) {
#line 183
        ptr->lft = tl_nn(261, (Node *)0, (Node *)0);
#line 184
        break;
      }
    }
#line 186
    break;
    case 262: 
#line 208
    tmp___12 = implies(ptr->lft, ptr->rgt);
#line 208
    if (tmp___12) {
#line 209
      ptr = tl_nn(266, (Node *)0, (Node *)0);
#line 210
      break;
    }
#line 212
    tmp___13 = tl_nn(263, ptr->lft, (Node *)0);
#line 212
    tmp___14 = push_negation(tmp___13);
#line 212
    ptr = tl_nn(264, tmp___14, ptr->rgt);
#line 213
    tmp___15 = right_linked(ptr);
#line 213
    ptr = canonical(tmp___15);
#line 214
    break;
    case 259: 
#line 216
    tmp___16 = implies(ptr->lft, ptr->rgt);
#line 216
    if (tmp___16) {
#line 216
      tmp___17 = implies(ptr->rgt, ptr->lft);
#line 216
      if (tmp___17) {
#line 218
        ptr = tl_nn(266, (Node *)0, (Node *)0);
#line 219
        break;
      }
    }
#line 221
    tmp___18 = dupnode(ptr->rgt);
#line 221
    tmp___19 = dupnode(ptr->lft);
#line 221
    tmp___20 = tl_nn(258, tmp___19, tmp___18);
#line 221
    tmp___21 = right_linked(tmp___20);
#line 221
    a = canonical(tmp___21);
#line 224
    tmp___22 = tl_nn(263, ptr->rgt, (Node *)0);
#line 224
    tmp___23 = push_negation(tmp___22);
#line 224
    tmp___24 = tl_nn(263, ptr->lft, (Node *)0);
#line 224
    tmp___25 = push_negation(tmp___24);
#line 224
    tmp___26 = tl_nn(258, tmp___25, tmp___23);
#line 224
    tmp___27 = right_linked(tmp___26);
#line 224
    b = canonical(tmp___27);
#line 227
    ptr = tl_nn(264, a, b);
#line 228
    tmp___28 = right_linked(ptr);
#line 228
    ptr = canonical(tmp___28);
#line 229
    break;
    case 258: 
#line 232
    if ((int )(ptr->rgt)->ntyp == 267) {
#line 232
      tmp___29 = isequal((ptr->rgt)->rgt, ptr->lft);
#line 232
      if (tmp___29) {
#line 234
        ptr = ptr->lft;
#line 235
        break;
      }
    }
#line 237
    if ((int )(ptr->lft)->ntyp == 267) {
#line 237
      tmp___30 = isequal((ptr->lft)->rgt, ptr->rgt);
#line 237
      if (tmp___30) {
#line 239
        ptr = ptr->rgt;
#line 240
        break;
      }
    }
#line 244
    if ((int )(ptr->rgt)->ntyp == 268) {
#line 244
      tmp___31 = isequal((ptr->rgt)->rgt, ptr->lft);
#line 244
      if (tmp___31) {
#line 246
        ptr = ptr->rgt;
#line 247
        break;
      }
    }
#line 249
    if ((int )(ptr->lft)->ntyp == 268) {
#line 249
      tmp___32 = isequal((ptr->lft)->rgt, ptr->rgt);
#line 249
      if (tmp___32) {
#line 251
        ptr = ptr->lft;
#line 252
        break;
      }
    }
#line 256
    if ((int )(ptr->rgt)->ntyp == 267) {
#line 256
      if ((int )(ptr->lft)->ntyp == 267) {
#line 256
        tmp___34 = isequal((ptr->rgt)->rgt, (ptr->lft)->rgt);
#line 256
        if (tmp___34) {
#line 259
          tmp___33 = tl_nn(258, (ptr->lft)->lft, (ptr->rgt)->lft);
#line 259
          ptr = tl_nn(267, tmp___33, (ptr->lft)->rgt);
#line 262
          break;
        }
      }
    }
#line 266
    if ((int )(ptr->rgt)->ntyp == 268) {
#line 266
      if ((int )(ptr->lft)->ntyp == 268) {
#line 266
        tmp___36 = isequal((ptr->rgt)->lft, (ptr->lft)->lft);
#line 266
        if (tmp___36) {
#line 269
          tmp___35 = tl_nn(258, (ptr->lft)->rgt, (ptr->rgt)->rgt);
#line 269
          ptr = tl_nn(268, (ptr->rgt)->lft, tmp___35);
#line 272
          break;
        }
      }
    }
#line 287
    if ((int )(ptr->rgt)->ntyp == 267) {
#line 287
      if ((int )(ptr->lft)->ntyp == 268) {
#line 287
        tmp___37 = isequal((ptr->lft)->rgt, (ptr->rgt)->rgt);
#line 287
        if (tmp___37) {
#line 290
          ptr = ptr->lft;
#line 291
          break;
        }
      }
    }
#line 294
    tmp___38 = isequal(ptr->lft, ptr->rgt);
#line 294
    if (tmp___38) {
#line 298
      ptr = ptr->rgt;
#line 299
      break;
    } else {
#line 294
      if ((int )(ptr->rgt)->ntyp == 261) {
#line 298
        ptr = ptr->rgt;
#line 299
        break;
      } else {
#line 294
        if ((int )(ptr->lft)->ntyp == 266) {
#line 298
          ptr = ptr->rgt;
#line 299
          break;
        } else {
#line 294
          tmp___39 = implies(ptr->rgt, ptr->lft);
#line 294
          if (tmp___39) {
#line 298
            ptr = ptr->rgt;
#line 299
            break;
          }
        }
      }
    }
#line 301
    if ((int )(ptr->rgt)->ntyp == 266) {
#line 304
      ptr = ptr->lft;
#line 305
      break;
    } else {
#line 301
      if ((int )(ptr->lft)->ntyp == 261) {
#line 304
        ptr = ptr->lft;
#line 305
        break;
      } else {
#line 301
        tmp___40 = implies(ptr->lft, ptr->rgt);
#line 301
        if (tmp___40) {
#line 304
          ptr = ptr->lft;
#line 305
          break;
        }
      }
    }
#line 309
    if ((int )(ptr->lft)->ntyp == 267) {
#line 309
      if ((int )((ptr->lft)->lft)->ntyp == 266) {
#line 309
        if ((int )((ptr->lft)->rgt)->ntyp == 268) {
#line 309
          if ((int )(((ptr->lft)->rgt)->lft)->ntyp == 261) {
#line 309
            if ((int )(ptr->rgt)->ntyp == 267) {
#line 309
              if ((int )((ptr->rgt)->lft)->ntyp == 266) {
#line 309
                if ((int )((ptr->rgt)->rgt)->ntyp == 268) {
#line 309
                  if ((int )(((ptr->rgt)->rgt)->lft)->ntyp == 261) {
#line 318
                    tmp___41 = tl_nn(258, ((ptr->lft)->rgt)->rgt, ((ptr->rgt)->rgt)->rgt);
#line 318
                    tmp___42 = tl_nn(261, (Node *)0, (Node *)0);
#line 318
                    tmp___43 = tl_nn(268, tmp___42, tmp___41);
#line 318
                    tmp___44 = tl_nn(266, (Node *)0, (Node *)0);
#line 318
                    ptr = tl_nn(267, tmp___44, tmp___43);
#line 322
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 326
    tmp___45 = dupnode(ptr->rgt);
#line 326
    tmp___46 = tl_nn(263, tmp___45, (Node *)0);
#line 326
    tmp___47 = push_negation(tmp___46);
#line 326
    tmp___48 = implies(ptr->lft, tmp___47);
#line 326
    if (tmp___48) {
#line 330
      ptr = tl_nn(261, (Node *)0, (Node *)0);
#line 331
      break;
    } else {
#line 326
      tmp___49 = dupnode(ptr->lft);
#line 326
      tmp___50 = tl_nn(263, tmp___49, (Node *)0);
#line 326
      tmp___51 = push_negation(tmp___50);
#line 326
      tmp___52 = implies(ptr->rgt, tmp___51);
#line 326
      if (tmp___52) {
#line 330
        ptr = tl_nn(261, (Node *)0, (Node *)0);
#line 331
        break;
      }
    }
#line 333
    break;
    case 264: 
#line 337
    if ((int )(ptr->rgt)->ntyp == 267) {
#line 337
      tmp___53 = isequal((ptr->rgt)->rgt, ptr->lft);
#line 337
      if (tmp___53) {
#line 339
        ptr = ptr->rgt;
#line 340
        break;
      }
    }
#line 344
    if ((int )(ptr->rgt)->ntyp == 268) {
#line 344
      tmp___54 = isequal((ptr->rgt)->rgt, ptr->lft);
#line 344
      if (tmp___54) {
#line 346
        ptr = ptr->lft;
#line 347
        break;
      }
    }
#line 351
    if ((int )(ptr->rgt)->ntyp == 267) {
#line 351
      if ((int )(ptr->lft)->ntyp == 267) {
#line 351
        tmp___56 = isequal((ptr->rgt)->lft, (ptr->lft)->lft);
#line 351
        if (tmp___56) {
#line 354
          tmp___55 = tl_nn(264, (ptr->lft)->rgt, (ptr->rgt)->rgt);
#line 354
          ptr = tl_nn(267, (ptr->rgt)->lft, tmp___55);
#line 357
          break;
        }
      }
    }
#line 360
    tmp___57 = isequal(ptr->lft, ptr->rgt);
#line 360
    if (tmp___57) {
#line 364
      ptr = ptr->lft;
#line 365
      break;
    } else {
#line 360
      if ((int )(ptr->rgt)->ntyp == 261) {
#line 364
        ptr = ptr->lft;
#line 365
        break;
      } else {
#line 360
        if ((int )(ptr->lft)->ntyp == 266) {
#line 364
          ptr = ptr->lft;
#line 365
          break;
        } else {
#line 360
          tmp___58 = implies(ptr->rgt, ptr->lft);
#line 360
          if (tmp___58) {
#line 364
            ptr = ptr->lft;
#line 365
            break;
          }
        }
      }
    }
#line 367
    if ((int )(ptr->rgt)->ntyp == 266) {
#line 370
      ptr = ptr->rgt;
#line 371
      break;
    } else {
#line 367
      if ((int )(ptr->lft)->ntyp == 261) {
#line 370
        ptr = ptr->rgt;
#line 371
        break;
      } else {
#line 367
        tmp___59 = implies(ptr->lft, ptr->rgt);
#line 367
        if (tmp___59) {
#line 370
          ptr = ptr->rgt;
#line 371
          break;
        }
      }
    }
#line 375
    if ((int )(ptr->rgt)->ntyp == 268) {
#line 375
      if ((int )(ptr->lft)->ntyp == 268) {
#line 375
        tmp___61 = isequal((ptr->lft)->rgt, (ptr->rgt)->rgt);
#line 375
        if (tmp___61) {
#line 378
          tmp___60 = tl_nn(264, (ptr->lft)->lft, (ptr->rgt)->lft);
#line 378
          ptr = tl_nn(268, tmp___60, (ptr->rgt)->rgt);
#line 381
          break;
        }
      }
    }
#line 385
    if ((int )(ptr->rgt)->ntyp == 267) {
#line 385
      if ((int )(ptr->lft)->ntyp == 268) {
#line 385
        tmp___62 = isequal((ptr->lft)->rgt, (ptr->rgt)->rgt);
#line 385
        if (tmp___62) {
#line 388
          ptr = ptr->rgt;
#line 389
          break;
        }
      }
    }
#line 393
    if ((int )(ptr->lft)->ntyp == 268) {
#line 393
      if ((int )((ptr->lft)->lft)->ntyp == 261) {
#line 393
        if ((int )((ptr->lft)->rgt)->ntyp == 267) {
#line 393
          if ((int )(((ptr->lft)->rgt)->lft)->ntyp == 266) {
#line 393
            if ((int )(ptr->rgt)->ntyp == 268) {
#line 393
              if ((int )((ptr->rgt)->lft)->ntyp == 261) {
#line 393
                if ((int )((ptr->rgt)->rgt)->ntyp == 267) {
#line 393
                  if ((int )(((ptr->rgt)->rgt)->lft)->ntyp == 266) {
#line 402
                    tmp___63 = tl_nn(264, ((ptr->lft)->rgt)->rgt, ((ptr->rgt)->rgt)->rgt);
#line 402
                    tmp___64 = tl_nn(266, (Node *)0, (Node *)0);
#line 402
                    tmp___65 = tl_nn(267, tmp___64, tmp___63);
#line 402
                    tmp___66 = tl_nn(261, (Node *)0, (Node *)0);
#line 402
                    ptr = tl_nn(268, tmp___66, tmp___65);
#line 406
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 410
    tmp___67 = dupnode(ptr->rgt);
#line 410
    tmp___68 = tl_nn(263, tmp___67, (Node *)0);
#line 410
    tmp___69 = push_negation(tmp___68);
#line 410
    tmp___70 = implies(tmp___69, ptr->lft);
#line 410
    if (tmp___70) {
#line 414
      ptr = tl_nn(266, (Node *)0, (Node *)0);
#line 415
      break;
    } else {
#line 410
      tmp___71 = dupnode(ptr->lft);
#line 410
      tmp___72 = tl_nn(263, tmp___71, (Node *)0);
#line 410
      tmp___73 = push_negation(tmp___72);
#line 410
      tmp___74 = implies(tmp___73, ptr->rgt);
#line 410
      if (tmp___74) {
#line 414
        ptr = tl_nn(266, (Node *)0, (Node *)0);
#line 415
        break;
      }
    }
#line 417
    break;
    }
  }
#line 419
  return (ptr);
}
}
#line 422 "parse.cpp"
static Node *bin_minimal(Node *ptr ) 
{ Node *tmp ;
  Node *tmp___0 ;
  Node *tmp___1 ;
  Node *tmp___2 ;
  Node *tmp___3 ;
  Node *tmp___4 ;
  Node *tmp___5 ;
  Node *tmp___6 ;
  Node *tmp___7 ;
  Node *tmp___8 ;
  Node *tmp___9 ;
  Node *tmp___10 ;

  {
#line 424
  if (ptr) {
#line 425
    switch ((int )ptr->ntyp) {
    case 262: 
#line 427
    tmp = tl_nn(263, ptr->lft, (Node *)0);
#line 427
    tmp___0 = push_negation(tmp);
#line 427
    tmp___1 = tl_nn(264, tmp___0, ptr->rgt);
#line 427
    return (tmp___1);
    case 259: 
#line 429
    tmp___2 = tl_nn(263, ptr->rgt, (Node *)0);
#line 429
    tmp___3 = push_negation(tmp___2);
#line 429
    tmp___4 = tl_nn(263, ptr->lft, (Node *)0);
#line 429
    tmp___5 = push_negation(tmp___4);
#line 429
    tmp___6 = tl_nn(258, tmp___5, tmp___3);
#line 429
    tmp___7 = dupnode(ptr->rgt);
#line 429
    tmp___8 = dupnode(ptr->lft);
#line 429
    tmp___9 = tl_nn(258, tmp___8, tmp___7);
#line 429
    tmp___10 = tl_nn(264, tmp___9, tmp___6);
#line 429
    return (tmp___10);
    }
  }
#line 433
  return (ptr);
}
}
#line 436 "parse.cpp"
static Node *tl_factor(void) 
{ Node *ptr ;
  Node *tmp ;
  Node *tmp___0 ;

  {
#line 438
  ptr = (Node *)0;
#line 440
  switch (tl_yychar) {
  case 40: 
#line 442
  ptr = tl_formula();
#line 443
  if (tl_yychar != 41) {
#line 444
    tl_yyerror((char *)"expected \')\'");
  }
#line 445
  tl_yychar = tl_yylex();
  goto simpl;
  case 263: 
#line 448
  ptr = tl_yylval;
#line 449
  tl_yychar = tl_yylex();
#line 450
  ptr->lft = tl_factor();
#line 451
  ptr = push_negation(ptr);
  goto simpl;
  case 257: 
#line 454
  tl_yychar = tl_yylex();
#line 456
  ptr = tl_factor();
#line 458
  if (tl_simp_log) {
#line 459
    if ((int )ptr->ntyp == 261) {
#line 461
      break;
    } else {
#line 459
      if ((int )ptr->ntyp == 266) {
#line 461
        break;
      }
    }
#line 463
    if ((int )ptr->ntyp == 268) {
#line 464
      if ((int )(ptr->lft)->ntyp == 261) {
#line 465
        break;
      }
#line 467
      ptr = ptr->rgt;
    }
  }
#line 471
  tmp = tl_nn(261, (Node *)0, (Node *)0);
#line 471
  ptr = tl_nn(268, tmp, ptr);
  goto simpl;
  case 260: 
#line 486
  tl_yychar = tl_yylex();
#line 488
  ptr = tl_factor();
#line 490
  if (tl_simp_log) {
#line 491
    if ((int )ptr->ntyp == 266) {
#line 493
      break;
    } else {
#line 491
      if ((int )ptr->ntyp == 261) {
#line 493
        break;
      }
    }
#line 495
    if ((int )ptr->ntyp == 267) {
#line 495
      if ((int )(ptr->lft)->ntyp == 266) {
#line 497
        break;
      }
    }
#line 499
    if ((int )ptr->ntyp == 267) {
#line 501
      ptr = ptr->rgt;
    }
  }
#line 506
  tmp___0 = tl_nn(266, (Node *)0, (Node *)0);
#line 506
  ptr = tl_nn(267, tmp___0, ptr);
  simpl: 
#line 508
  if (tl_simp_log) {
#line 509
    ptr = bin_simpler(ptr);
  }
#line 510
  break;
  case 265: 
#line 512
  ptr = tl_yylval;
#line 513
  tl_yychar = tl_yylex();
#line 514
  break;
  case 266: 
  case 261: 
#line 517
  ptr = tl_yylval;
#line 518
  tl_yychar = tl_yylex();
#line 519
  break;
  }
#line 521
  if (! ptr) {
#line 521
    tl_yyerror((char *)"expected predicate");
  }
#line 527
  return (ptr);
}
}
#line 530 "parse.cpp"
static Node *tl_level(int nr ) 
{ int i ;
  Node *ptr ;
  Node *tmp ;
  Node *tmp___0 ;

  {
#line 532
  ptr = (Node *)0;
#line 534
  if (nr < 0) {
#line 535
    tmp = tl_factor();
#line 535
    return (tmp);
  }
#line 537
  ptr = tl_level(nr - 1);
  again: 
#line 539
  i = 0;
#line 539
  while (i < 4) {
#line 540
    if (tl_yychar == prec[nr][i]) {
#line 541
      tl_yychar = tl_yylex();
#line 542
      tmp___0 = tl_level(nr - 1);
#line 542
      ptr = tl_nn(prec[nr][i], ptr, tmp___0);
#line 543
      if (tl_simp_log) {
#line 543
        ptr = bin_simpler(ptr);
      } else {
#line 544
        ptr = bin_minimal(ptr);
      }
      goto again;
    }
#line 539
    i ++;
  }
#line 547
  if (! ptr) {
#line 547
    tl_yyerror((char *)"syntax error");
  }
#line 553
  return (ptr);
}
}
#line 556 "parse.cpp"
static Node *tl_formula(void) 
{ Node *tmp ;

  {
#line 558
  tl_yychar = tl_yylex();
#line 559
  tmp = tl_level(1);
#line 559
  return (tmp);
}
}
#line 562 "parse.cpp"
void tl_parse(void) 
{ Node *n ;
  Node *tmp ;

  {
#line 565
  tmp = tl_formula();
#line 565
  n = tmp;
#line 566
  if (tl_verbose) {
#line 567
    printf("formula: ");
#line 568
    put_uform();
#line 569
    printf("\n");
  }
#line 571
  trans(n);
#line 572
  return;
}
}
#line 1 "rewrt.o"
#pragma merger(0,"./rewrt.i","")
#line 168 "ltl2ba.h"
Symbol *DoDump(Node *n ) ;
#line 37 "rewrt.cpp"
static Node *can  =    (Node *)0;
#line 39 "rewrt.cpp"
Node *right_linked(Node *n ) 
{ Node *tmp ;

  {
#line 42
  if (! n) {
#line 42
    return (n);
  }
#line 44
  if ((int )n->ntyp == 258) {
    goto _L;
  } else {
#line 44
    if ((int )n->ntyp == 264) {
      _L: /* CIL Label */ 
#line 45
      while (1) {
#line 45
        if (n->lft) {
#line 45
          if (! ((int )(n->lft)->ntyp == (int )n->ntyp)) {
#line 45
            break;
          }
        } else {
#line 45
          break;
        }
#line 46
        tmp = n->lft;
#line 47
        n->lft = tmp->rgt;
#line 48
        tmp->rgt = n;
#line 49
        n = tmp;
      }
    }
  }
#line 52
  n->lft = right_linked(n->lft);
#line 53
  n->rgt = right_linked(n->rgt);
#line 55
  return (n);
}
}
#line 58 "rewrt.cpp"
Node *canonical(Node *n ) 
{ Node *m ;
  Node *tmp ;

  {
#line 62
  if (! n) {
#line 62
    return (n);
  }
#line 63
  m = in_cache(n);
#line 63
  if (m) {
#line 64
    return (m);
  }
#line 66
  n->rgt = canonical(n->rgt);
#line 67
  n->lft = canonical(n->lft);
#line 69
  tmp = cached(n);
#line 69
  return (tmp);
}
}
#line 72 "rewrt.cpp"
Node *push_negation(Node *n ) 
{ Node *m ;
  Node *tmp ;
  Node *tmp___0 ;
  Node *tmp___1 ;

  {
#line 76
  if (! ((int )n->ntyp == 263)) {
#line 76
    tl_explain((int )n->ntyp);
#line 76
    Fatal((char *)": assertion failed\n", (char *)0);
  }
#line 78
  switch ((int )(n->lft)->ntyp) {
  case 266: 
#line 80
  releasenode(0, n->lft);
#line 81
  n->lft = (Node *)0;
#line 82
  n->ntyp = (short)261;
#line 83
  break;
  case 261: 
#line 85
  releasenode(0, n->lft);
#line 86
  n->lft = (Node *)0;
#line 87
  n->ntyp = (short)266;
#line 88
  break;
  case 263: 
#line 90
  m = (n->lft)->lft;
#line 91
  releasenode(0, n->lft);
#line 92
  n->lft = (Node *)0;
#line 93
  releasenode(0, n);
#line 94
  n = m;
#line 95
  break;
  case 268: 
#line 97
  n->ntyp = (short)267;
  goto same;
  case 267: 
#line 100
  n->ntyp = (short)268;
  goto same;
  case 258: 
#line 110
  n->ntyp = (short)264;
  goto same;
  case 264: 
#line 113
  n->ntyp = (short)258;
  same: 
#line 115
  m = (n->lft)->rgt;
#line 116
  (n->lft)->rgt = (Node *)0;
#line 118
  tmp = tl_nn(263, m, (Node *)0);
#line 118
  n->rgt = push_negation(tmp);
#line 119
  (n->lft)->ntyp = (short)263;
#line 120
  m = n->lft;
#line 121
  n->lft = push_negation(m);
#line 122
  break;
  }
#line 125
  tmp___0 = right_linked(n);
#line 125
  tmp___1 = canonical(tmp___0);
#line 125
  return (tmp___1);
}
}
#line 128 "rewrt.cpp"
static void addcan(int tok , Node *n ) 
{ Node *m ;
  Node *prev ;
  Node **ptr ;
  Node *N ;
  Symbol *s ;
  Symbol *t ;
  int cmp ;

  {
#line 130
  prev = (Node *)0;
#line 135
  if (! n) {
#line 135
    return;
  }
#line 137
  if ((int )n->ntyp == tok) {
#line 138
    addcan(tok, n->rgt);
#line 139
    addcan(tok, n->lft);
#line 140
    return;
  }
#line 147
  N = dupnode(n);
#line 148
  if (! can) {
#line 149
    can = N;
#line 150
    return;
  }
#line 153
  s = DoDump(N);
#line 154
  if ((int )can->ntyp != tok) {
#line 155
    ptr = & can;
    goto insert;
  }
#line 160
  prev = (Node *)0;
#line 161
  m = can;
#line 161
  while (1) {
#line 161
    if ((int )m->ntyp == tok) {
#line 161
      if (! m->rgt) {
#line 161
        break;
      }
    } else {
#line 161
      break;
    }
#line 162
    t = DoDump(m->lft);
#line 163
    cmp = strcmp((char const   *)s->name, (char const   *)t->name);
#line 164
    if (cmp == 0) {
#line 165
      return;
    }
#line 166
    if (cmp < 0) {
#line 167
      if (! prev) {
#line 168
        can = tl_nn(tok, N, can);
#line 169
        return;
      } else {
#line 171
        ptr = & prev->rgt;
        goto insert;
      }
    }
#line 161
    prev = m;
#line 161
    m = m->rgt;
  }
#line 176
  ptr = & prev->rgt;
  insert: 
#line 178
  t = DoDump(*ptr);
#line 179
  cmp = strcmp((char const   *)s->name, (char const   *)t->name);
#line 180
  if (cmp == 0) {
#line 181
    return;
  }
#line 182
  if (cmp < 0) {
#line 183
    *ptr = tl_nn(tok, N, *ptr);
  } else {
#line 185
    *ptr = tl_nn(tok, *ptr, N);
  }
#line 186
  return;
}
}
#line 188 "rewrt.cpp"
static void marknode(int tok , Node *m ) 
{ 

  {
#line 191
  if ((int )m->ntyp != tok) {
#line 192
    releasenode(0, m->rgt);
#line 193
    m->rgt = (Node *)0;
  }
#line 195
  m->ntyp = (short)-1;
#line 196
  return;
}
}
#line 198 "rewrt.cpp"
Node *Canonical(Node *n ) 
{ Node *m ;
  Node *p ;
  Node *k1 ;
  Node *k2 ;
  Node *prev ;
  Node *dflt ;
  int tok ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct Node *tmp___5 ;

  {
#line 200
  dflt = (Node *)0;
#line 203
  if (! n) {
#line 203
    return (n);
  }
#line 205
  tok = (int )n->ntyp;
#line 206
  if (tok != 258) {
#line 206
    if (tok != 264) {
#line 207
      return (n);
    }
  }
#line 209
  can = (Node *)0;
#line 210
  addcan(tok, n);
#line 215
  releasenode(1, n);
#line 218
  if (tok == 258) {
#line 219
    m = can;
#line 219
    while (m) {
#line 220
      if ((int )m->ntyp == 258) {
#line 220
        k1 = m->lft;
      } else {
#line 220
        k1 = m;
      }
#line 221
      if ((int )k1->ntyp == 266) {
#line 222
        marknode(258, m);
#line 223
        dflt = tl_nn(266, (Node *)0, (Node *)0);
        goto __Cont;
      }
#line 226
      if ((int )k1->ntyp == 261) {
#line 227
        releasenode(1, can);
#line 228
        can = tl_nn(261, (Node *)0, (Node *)0);
        goto out;
      }
      __Cont: /* CIL Label */ 
#line 219
      if ((int )m->ntyp == 258) {
#line 219
        m = m->rgt;
      } else {
#line 219
        m = (Node *)0;
      }
    }
#line 231
    m = can;
#line 231
    while (m) {
#line 232
      p = can;
#line 232
      while (p) {
#line 233
        if ((unsigned int )p == (unsigned int )m) {
          goto __Cont___0;
        } else {
#line 233
          if ((int )p->ntyp == -1) {
            goto __Cont___0;
          } else {
#line 233
            if ((int )m->ntyp == -1) {
              goto __Cont___0;
            }
          }
        }
#line 237
        if ((int )m->ntyp == 258) {
#line 237
          k1 = m->lft;
        } else {
#line 237
          k1 = m;
        }
#line 238
        if ((int )p->ntyp == 258) {
#line 238
          k2 = p->lft;
        } else {
#line 238
          k2 = p;
        }
#line 240
        tmp = isequal(k1, k2);
#line 240
        if (tmp) {
#line 241
          marknode(258, p);
          goto __Cont___0;
        }
#line 244
        tmp___0 = anywhere(264, k1, k2);
#line 244
        if (tmp___0) {
#line 245
          marknode(258, p);
          goto __Cont___0;
        }
#line 248
        if ((int )k2->ntyp == 267) {
#line 248
          tmp___1 = anywhere(258, k2->rgt, can);
#line 248
          if (tmp___1) {
#line 250
            marknode(258, p);
            goto __Cont___0;
          }
        }
        __Cont___0: /* CIL Label */ 
#line 232
        if ((int )p->ntyp == 258) {
#line 232
          p = p->rgt;
        } else {
#line 232
          p = (Node *)0;
        }
      }
#line 231
      if ((int )m->ntyp == 258) {
#line 231
        m = m->rgt;
      } else {
#line 231
        m = (Node *)0;
      }
    }
  }
#line 254
  if (tok == 264) {
#line 255
    m = can;
#line 255
    while (m) {
#line 256
      if ((int )m->ntyp == 264) {
#line 256
        k1 = m->lft;
      } else {
#line 256
        k1 = m;
      }
#line 257
      if ((int )k1->ntyp == 261) {
#line 258
        marknode(264, m);
#line 259
        dflt = tl_nn(261, (Node *)0, (Node *)0);
        goto __Cont___1;
      }
#line 262
      if ((int )k1->ntyp == 266) {
#line 263
        releasenode(1, can);
#line 264
        can = tl_nn(266, (Node *)0, (Node *)0);
        goto out;
      }
      __Cont___1: /* CIL Label */ 
#line 255
      if ((int )m->ntyp == 264) {
#line 255
        m = m->rgt;
      } else {
#line 255
        m = (Node *)0;
      }
    }
#line 267
    m = can;
#line 267
    while (m) {
#line 268
      p = can;
#line 268
      while (p) {
#line 269
        if ((unsigned int )p == (unsigned int )m) {
          goto __Cont___2;
        } else {
#line 269
          if ((int )p->ntyp == -1) {
            goto __Cont___2;
          } else {
#line 269
            if ((int )m->ntyp == -1) {
              goto __Cont___2;
            }
          }
        }
#line 273
        if ((int )m->ntyp == 264) {
#line 273
          k1 = m->lft;
        } else {
#line 273
          k1 = m;
        }
#line 274
        if ((int )p->ntyp == 264) {
#line 274
          k2 = p->lft;
        } else {
#line 274
          k2 = p;
        }
#line 276
        tmp___2 = isequal(k1, k2);
#line 276
        if (tmp___2) {
#line 277
          marknode(264, p);
          goto __Cont___2;
        }
#line 280
        tmp___3 = anywhere(258, k1, k2);
#line 280
        if (tmp___3) {
#line 281
          marknode(264, p);
          goto __Cont___2;
        }
#line 284
        if ((int )k2->ntyp == 268) {
#line 284
          if ((int )(k2->lft)->ntyp == 261) {
#line 284
            tmp___4 = anywhere(258, k2->rgt, can);
#line 284
            if (tmp___4) {
#line 287
              marknode(264, p);
              goto __Cont___2;
            }
          }
        }
        __Cont___2: /* CIL Label */ 
#line 268
        if ((int )p->ntyp == 264) {
#line 268
          p = p->rgt;
        } else {
#line 268
          p = (Node *)0;
        }
      }
#line 267
      if ((int )m->ntyp == 264) {
#line 267
        m = m->rgt;
      } else {
#line 267
        m = (Node *)0;
      }
    }
  }
#line 291
  m = can;
#line 291
  prev = (Node *)0;
#line 291
  while (m) {
#line 292
    if ((int )m->ntyp == -1) {
#line 293
      k2 = m->rgt;
#line 294
      releasenode(0, m);
#line 295
      if (! prev) {
#line 296
        can = can->rgt;
#line 296
        m = can;
      } else {
#line 298
        tmp___5 = k2;
#line 298
        prev->rgt = tmp___5;
#line 298
        m = tmp___5;
#line 300
        if (! prev->rgt) {
#line 300
          if (prev->lft) {
#line 300
            if ((int )prev->ntyp == 258) {
              goto _L;
            } else {
#line 300
              if ((int )prev->ntyp == 264) {
                _L: /* CIL Label */ 
#line 302
                k1 = prev->lft;
#line 303
                prev->ntyp = (prev->lft)->ntyp;
#line 304
                prev->sym = (prev->lft)->sym;
#line 305
                prev->rgt = (prev->lft)->rgt;
#line 306
                prev->lft = (prev->lft)->lft;
#line 307
                releasenode(0, k1);
              }
            }
          }
        }
      }
      goto __Cont___3;
    }
#line 312
    prev = m;
#line 313
    m = m->rgt;
    __Cont___3: /* CIL Label */ ;
  }
  out: ;
#line 319
  if (! can) {
#line 320
    if (! dflt) {
#line 321
      fatal((char *)"cannot happen, Canonical", (char *)0);
    }
#line 322
    return (dflt);
  }
#line 325
  return (can);
}
}
#line 1 "set.o"
#pragma merger(0,"./set.i","")
#line 215 "ltl2ba.h"
int *intersect_sets(int *l1 , int *l2 , int type ) ;
#line 36 "set.cpp"
int mod  =    (int )(8U * sizeof(int ));
#line 43 "set.cpp"
int *new_set(int type ) 
{ int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 45
  if (type == 1) {
#line 45
    tmp___0 = sym_size;
  } else {
#line 45
    if (type == 2) {
#line 45
      tmp = scc_size;
    } else {
#line 45
      tmp = node_size;
    }
#line 45
    tmp___0 = tmp;
  }
#line 45
  tmp___1 = tl_emalloc((int )((unsigned int )tmp___0 * sizeof(int )));
#line 45
  return ((int *)tmp___1);
}
}
#line 48 "set.cpp"
int *clear_set(int *l , int type ) 
{ int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 51
  i = 0;
#line 51
  while (1) {
#line 51
    if (type == 1) {
#line 51
      tmp___0 = sym_size;
    } else {
#line 51
      if (type == 2) {
#line 51
        tmp = scc_size;
      } else {
#line 51
        tmp = node_size;
      }
#line 51
      tmp___0 = tmp;
    }
#line 51
    if (! (i < tmp___0)) {
#line 51
      break;
    }
#line 52
    *(l + i) = 0;
#line 51
    i ++;
  }
#line 54
  return (l);
}
}
#line 57 "set.cpp"
int *make_set(int n , int type ) 
{ int *l ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 59
  tmp = new_set(type);
#line 59
  tmp___0 = clear_set(tmp, type);
#line 59
  l = tmp___0;
#line 60
  if (n == -1) {
#line 60
    return (l);
  }
#line 61
  *(l + n / mod) = 1 << n % mod;
#line 62
  return (l);
}
}
#line 65 "set.cpp"
void copy_set(int *from , int *to , int type ) 
{ int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 68
  i = 0;
#line 68
  while (1) {
#line 68
    if (type == 1) {
#line 68
      tmp___0 = sym_size;
    } else {
#line 68
      if (type == 2) {
#line 68
        tmp = scc_size;
      } else {
#line 68
        tmp = node_size;
      }
#line 68
      tmp___0 = tmp;
    }
#line 68
    if (! (i < tmp___0)) {
#line 68
      break;
    }
#line 69
    *(to + i) = *(from + i);
#line 68
    i ++;
  }
#line 70
  return;
}
}
#line 72 "set.cpp"
int *dup_set(int *l , int type ) 
{ int i ;
  int *m ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 74
  tmp = new_set(type);
#line 74
  m = tmp;
#line 75
  i = 0;
#line 75
  while (1) {
#line 75
    if (type == 1) {
#line 75
      tmp___1 = sym_size;
    } else {
#line 75
      if (type == 2) {
#line 75
        tmp___0 = scc_size;
      } else {
#line 75
        tmp___0 = node_size;
      }
#line 75
      tmp___1 = tmp___0;
    }
#line 75
    if (! (i < tmp___1)) {
#line 75
      break;
    }
#line 76
    *(m + i) = *(l + i);
#line 75
    i ++;
  }
#line 77
  return (m);
}
}
#line 80 "set.cpp"
void merge_sets(int *l1 , int *l2 , int type ) 
{ int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 83
  i = 0;
#line 83
  while (1) {
#line 83
    if (type == 1) {
#line 83
      tmp___0 = sym_size;
    } else {
#line 83
      if (type == 2) {
#line 83
        tmp = scc_size;
      } else {
#line 83
        tmp = node_size;
      }
#line 83
      tmp___0 = tmp;
    }
#line 83
    if (! (i < tmp___0)) {
#line 83
      break;
    }
#line 84
    *(l1 + i) |= *(l2 + i);
#line 83
    i ++;
  }
#line 85
  return;
}
}
#line 87 "set.cpp"
void do_merge_sets(int *l , int *l1 , int *l2 , int type ) 
{ int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 90
  i = 0;
#line 90
  while (1) {
#line 90
    if (type == 1) {
#line 90
      tmp___0 = sym_size;
    } else {
#line 90
      if (type == 2) {
#line 90
        tmp = scc_size;
      } else {
#line 90
        tmp = node_size;
      }
#line 90
      tmp___0 = tmp;
    }
#line 90
    if (! (i < tmp___0)) {
#line 90
      break;
    }
#line 91
    *(l + i) = *(l1 + i) | *(l2 + i);
#line 90
    i ++;
  }
#line 92
  return;
}
}
#line 94 "set.cpp"
int *intersect_sets(int *l1 , int *l2 , int type ) 
{ int i ;
  int *l ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 96
  tmp = new_set(type);
#line 96
  l = tmp;
#line 97
  i = 0;
#line 97
  while (1) {
#line 97
    if (type == 1) {
#line 97
      tmp___1 = sym_size;
    } else {
#line 97
      if (type == 2) {
#line 97
        tmp___0 = scc_size;
      } else {
#line 97
        tmp___0 = node_size;
      }
#line 97
      tmp___1 = tmp___0;
    }
#line 97
    if (! (i < tmp___1)) {
#line 97
      break;
    }
#line 98
    *(l + i) = *(l1 + i) & *(l2 + i);
#line 97
    i ++;
  }
#line 99
  return (l);
}
}
#line 102 "set.cpp"
int empty_intersect_sets(int *l1 , int *l2 , int type ) 
{ int i ;
  int test ;
  int tmp ;
  int tmp___0 ;

  {
#line 104
  test = 0;
#line 105
  i = 0;
#line 105
  while (1) {
#line 105
    if (type == 1) {
#line 105
      tmp___0 = sym_size;
    } else {
#line 105
      if (type == 2) {
#line 105
        tmp = scc_size;
      } else {
#line 105
        tmp = node_size;
      }
#line 105
      tmp___0 = tmp;
    }
#line 105
    if (! (i < tmp___0)) {
#line 105
      break;
    }
#line 106
    test |= *(l1 + i) & *(l2 + i);
#line 105
    i ++;
  }
#line 107
  return (! test);
}
}
#line 110 "set.cpp"
void add_set(int *l , int n ) 
{ 

  {
#line 112
  *(l + n / mod) |= 1 << n % mod;
#line 113
  return;
}
}
#line 115 "set.cpp"
void rem_set(int *l , int n ) 
{ 

  {
#line 117
  *(l + n / mod) &= -1 - (1 << n % mod);
#line 118
  return;
}
}
#line 120 "set.cpp"
void spin_print_set(int *pos , int *neg ) 
{ int i ;
  int j ;
  int start ;

  {
#line 122
  start = 1;
#line 123
  i = 0;
#line 123
  while (i < sym_size) {
#line 124
    j = 0;
#line 124
    while (j < mod) {
#line 125
      if (*(pos + i) & (1 << j)) {
#line 126
        if (! start) {
#line 127
          fprintf(tl_out, " && ");
        }
#line 128
        fprintf(tl_out, "%s", *(sym_table + (mod * i + j)));
#line 129
        start = 0;
      }
#line 131
      if (*(neg + i) & (1 << j)) {
#line 132
        if (! start) {
#line 133
          fprintf(tl_out, " && ");
        }
#line 134
        fprintf(tl_out, "!%s", *(sym_table + (mod * i + j)));
#line 135
        start = 0;
      }
#line 124
      j ++;
    }
#line 123
    i ++;
  }
#line 138
  if (start) {
#line 139
    fprintf(tl_out, "1");
  }
#line 140
  return;
}
}
#line 142 "set.cpp"
void print_set(int *l , int type ) 
{ int i ;
  int j ;
  int start ;
  int tmp ;
  int tmp___0 ;

  {
#line 144
  start = 1;
#line 145
  if (type != 1) {
#line 145
    fprintf(tl_out, "{");
  }
#line 146
  i = 0;
#line 146
  while (1) {
#line 146
    if (type == 1) {
#line 146
      tmp___0 = sym_size;
    } else {
#line 146
      if (type == 2) {
#line 146
        tmp = scc_size;
      } else {
#line 146
        tmp = node_size;
      }
#line 146
      tmp___0 = tmp;
    }
#line 146
    if (! (i < tmp___0)) {
#line 146
      break;
    }
#line 147
    j = 0;
#line 147
    while (j < mod) {
#line 148
      if (*(l + i) & (1 << j)) {
#line 149
        switch (type) {
        case 0: 
        case 2: 
#line 151
        if (! start) {
#line 151
          fprintf(tl_out, ",");
        }
#line 152
        fprintf(tl_out, "%i", mod * i + j);
#line 153
        break;
        case 1: 
#line 155
        if (! start) {
#line 155
          fprintf(tl_out, " & ");
        }
#line 156
        fprintf(tl_out, "%s", *(sym_table + (mod * i + j)));
#line 157
        break;
        }
#line 159
        start = 0;
      }
#line 147
      j ++;
    }
#line 146
    i ++;
  }
#line 161
  if (type != 1) {
#line 161
    fprintf(tl_out, "}");
  }
#line 162
  return;
}
}
#line 164 "set.cpp"
int empty_set(int *l , int type ) 
{ int i ;
  int test ;
  int tmp ;
  int tmp___0 ;

  {
#line 166
  test = 0;
#line 167
  i = 0;
#line 167
  while (1) {
#line 167
    if (type == 1) {
#line 167
      tmp___0 = sym_size;
    } else {
#line 167
      if (type == 2) {
#line 167
        tmp = scc_size;
      } else {
#line 167
        tmp = node_size;
      }
#line 167
      tmp___0 = tmp;
    }
#line 167
    if (! (i < tmp___0)) {
#line 167
      break;
    }
#line 168
    test |= *(l + i);
#line 167
    i ++;
  }
#line 169
  return (! test);
}
}
#line 172 "set.cpp"
int same_sets(int *l1 , int *l2 , int type ) 
{ int i ;
  int test ;
  int tmp ;
  int tmp___0 ;

  {
#line 174
  test = 1;
#line 175
  i = 0;
#line 175
  while (1) {
#line 175
    if (type == 1) {
#line 175
      tmp___0 = sym_size;
    } else {
#line 175
      if (type == 2) {
#line 175
        tmp = scc_size;
      } else {
#line 175
        tmp = node_size;
      }
#line 175
      tmp___0 = tmp;
    }
#line 175
    if (! (i < tmp___0)) {
#line 175
      break;
    }
#line 176
    test &= *(l1 + i) == *(l2 + i);
#line 175
    i ++;
  }
#line 177
  return (test);
}
}
#line 180 "set.cpp"
int included_set(int *l1 , int *l2 , int type ) 
{ int i ;
  int test ;
  int tmp ;
  int tmp___0 ;

  {
#line 182
  test = 0;
#line 183
  i = 0;
#line 183
  while (1) {
#line 183
    if (type == 1) {
#line 183
      tmp___0 = sym_size;
    } else {
#line 183
      if (type == 2) {
#line 183
        tmp = scc_size;
      } else {
#line 183
        tmp = node_size;
      }
#line 183
      tmp___0 = tmp;
    }
#line 183
    if (! (i < tmp___0)) {
#line 183
      break;
    }
#line 184
    test |= *(l1 + i) & ~ *(l2 + i);
#line 183
    i ++;
  }
#line 185
  return (! test);
}
}
#line 188 "set.cpp"
int in_set(int *l , int n ) 
{ 

  {
#line 190
  return (*(l + n / mod) & (1 << n % mod));
}
}
#line 193 "set.cpp"
int *list_set(int *l , int type ) 
{ int i ;
  int j ;
  int size ;
  int *list ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 195
  size = 1;
#line 196
  i = 0;
#line 196
  while (1) {
#line 196
    if (type == 1) {
#line 196
      tmp___0 = sym_size;
    } else {
#line 196
      if (type == 2) {
#line 196
        tmp = scc_size;
      } else {
#line 196
        tmp = node_size;
      }
#line 196
      tmp___0 = tmp;
    }
#line 196
    if (! (i < tmp___0)) {
#line 196
      break;
    }
#line 197
    j = 0;
#line 197
    while (j < mod) {
#line 198
      if (*(l + i) & (1 << j)) {
#line 199
        size ++;
      }
#line 197
      j ++;
    }
#line 196
    i ++;
  }
#line 200
  tmp___1 = tl_emalloc((int )((unsigned int )size * sizeof(int )));
#line 200
  list = (int *)tmp___1;
#line 201
  *(list + 0) = size;
#line 202
  size = 1;
#line 203
  i = 0;
#line 203
  while (1) {
#line 203
    if (type == 1) {
#line 203
      tmp___4 = sym_size;
    } else {
#line 203
      if (type == 2) {
#line 203
        tmp___3 = scc_size;
      } else {
#line 203
        tmp___3 = node_size;
      }
#line 203
      tmp___4 = tmp___3;
    }
#line 203
    if (! (i < tmp___4)) {
#line 203
      break;
    }
#line 204
    j = 0;
#line 204
    while (j < mod) {
#line 205
      if (*(l + i) & (1 << j)) {
#line 206
        tmp___2 = size;
#line 206
        size ++;
#line 206
        *(list + tmp___2) = mod * i + j;
      }
#line 204
      j ++;
    }
#line 203
    i ++;
  }
#line 207
  return (list);
}
}
#line 1 "trans.o"
#pragma merger(0,"./trans.i","")
#line 27 "/usr/include/string.h"
extern char *( __attribute__((__cdecl__)) strcat)(char * , char const   * ) ;
#line 173 "ltl2ba.h"
int dump_cond(Node *pp , Node *r , int first ) ;
#line 38 "trans.cpp"
int Stack_mx  =    0;
#line 38 "trans.cpp"
int Max_Red  =    0;
#line 38 "trans.cpp"
int Total  =    0;
#line 39 "trans.cpp"
static char dumpbuf[2048]  ;
#line 57 "trans.cpp"
int dump_cond(Node *pp , Node *r , int first ) 
{ Node *q ;
  int frst ;
  Node *tmp ;
  int tmp___0 ;

  {
#line 60
  frst = first;
#line 62
  if (! pp) {
#line 62
    return (frst);
  }
#line 64
  q = dupnode(pp);
#line 65
  tmp = right_linked(q);
#line 65
  q = canonical(tmp);
#line 67
  if ((int )q->ntyp == 265) {
    goto _L___0;
  } else {
#line 67
    if ((int )q->ntyp == 263) {
      goto _L___0;
    } else {
#line 67
      if ((int )q->ntyp == 264) {
        goto _L___0;
      } else {
#line 67
        if ((int )q->ntyp == 261) {
          _L___0: /* CIL Label */ 
#line 73
          if (! frst) {
#line 73
            fprintf(tl_out, " && ");
          }
#line 74
          dump(q);
#line 75
          frst = 0;
        } else {
#line 103
          if ((int )q->ntyp == 268) {
#line 103
            tmp___0 = anywhere(258, q->rgt, r);
#line 103
            if (tmp___0) {
              goto _L;
            } else {
#line 105
              frst = dump_cond(q->rgt, r, frst);
            }
          } else {
            _L: /* CIL Label */ 
#line 106
            if ((int )q->ntyp == 258) {
#line 108
              frst = dump_cond(q->lft, r, frst);
#line 109
              frst = dump_cond(q->rgt, r, frst);
            }
          }
        }
      }
    }
  }
#line 112
  return (frst);
}
}
#line 115 "trans.cpp"
static void sdump(Node *n ) 
{ 

  {
#line 118
  switch ((int )n->ntyp) {
  case 265: 
#line 119
  strcat(dumpbuf, (char const   *)(n->sym)->name);
#line 120
  break;
  case 267: 
#line 121
  strcat(dumpbuf, "U");
  goto common2;
  case 268: 
#line 123
  strcat(dumpbuf, "V");
  goto common2;
  case 264: 
#line 125
  strcat(dumpbuf, "|");
  goto common2;
  case 258: 
#line 127
  strcat(dumpbuf, "&");
  common2: 
#line 128
  sdump(n->rgt);
  common1: 
#line 129
  sdump(n->lft);
#line 130
  break;
  case 263: 
#line 135
  strcat(dumpbuf, "!");
  goto common1;
  case 266: 
#line 137
  strcat(dumpbuf, "T");
#line 138
  break;
  case 261: 
#line 139
  strcat(dumpbuf, "F");
#line 140
  break;
  default: 
#line 141
  strcat(dumpbuf, "?");
#line 142
  break;
  }
#line 144
  return;
}
}
#line 146 "trans.cpp"
Symbol *DoDump(Node *n ) 
{ Symbol *tmp ;

  {
#line 149
  if (! n) {
#line 149
    return ((Symbol *)0);
  }
#line 151
  if ((int )n->ntyp == 265) {
#line 152
    return (n->sym);
  }
#line 154
  dumpbuf[0] = (char )'\000';
#line 155
  sdump(n);
#line 156
  tmp = tl_lookup(dumpbuf);
#line 156
  return (tmp);
}
}
#line 159 "trans.cpp"
void trans(Node *p ) 
{ 

  {
#line 161
  if (! p) {
#line 161
    return;
  } else {
#line 161
    if (tl_errs) {
#line 161
      return;
    }
  }
#line 163
  if (tl_verbose) {
#line 164
    fprintf(tl_out, "\t/* Normlzd: ");
#line 165
    dump(p);
#line 166
    fprintf(tl_out, " */\n");
  } else {
#line 163
    if (tl_terse) {
#line 164
      fprintf(tl_out, "\t/* Normlzd: ");
#line 165
      dump(p);
#line 166
      fprintf(tl_out, " */\n");
    }
  }
#line 168
  if (tl_terse) {
#line 169
    return;
  }
#line 171
  mk_alternating(p);
#line 172
  mk_generalized();
#line 173
  mk_buchi();
#line 175
  return;
}
}
