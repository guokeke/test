/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 213 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int size_t;
#line 14 "/usr/include/sys/lock.h"
typedef void *_LOCK_T;
#line 15 "/usr/include/sys/_types.h"
typedef long long _off64_t;
#line 18 "/usr/include/sys/_types.h"
typedef int _ssize_t;
#line 354 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int wint_t;
#line 27 "/usr/include/sys/_types.h"
union __anonunion___value_2 {
   wint_t __wch ;
   unsigned char __wchb[4] ;
};
#line 27 "/usr/include/sys/_types.h"
struct __anonstruct__mbstate_t_1 {
   int __count ;
   union __anonunion___value_2 __value ;
};
#line 27 "/usr/include/sys/_types.h"
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
#line 37 "/usr/include/sys/_types.h"
typedef _LOCK_T _flock_t;
#line 19 "/usr/include/sys/reent.h"
typedef unsigned long __ULong;
#line 40 "/usr/include/sys/reent.h"
struct _Bigint {
   struct _Bigint *_next ;
   int _k ;
   int _maxwds ;
   int _sign ;
   int _wds ;
   __ULong _x[1] ;
};
#line 48 "/usr/include/sys/reent.h"
struct __tm {
   int __tm_sec ;
   int __tm_min ;
   int __tm_hour ;
   int __tm_mday ;
   int __tm_mon ;
   int __tm_year ;
   int __tm_wday ;
   int __tm_yday ;
   int __tm_isdst ;
};
#line 67 "/usr/include/sys/reent.h"
struct _on_exit_args {
   void *_fnargs[32] ;
   void *_dso_handle[32] ;
   __ULong _fntypes ;
   __ULong _is_cxa ;
};
#line 85 "/usr/include/sys/reent.h"
struct _atexit {
   struct _atexit *_next ;
   int _ind ;
   void (*_fns[32])(void) ;
   struct _on_exit_args _on_exit_args ;
};
#line 101 "/usr/include/sys/reent.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 111 "/usr/include/sys/reent.h"
typedef long _fpos_t;
#line 115 "/usr/include/sys/reent.h"
typedef _off64_t _fpos64_t;
#line 166
struct _reent;
#line 214 "/usr/include/sys/reent.h"
struct __sFILE64 {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   struct _reent *_data ;
   void *_cookie ;
   _ssize_t ( __attribute__((__cdecl__)) (*_read))(void *_cookie , char *_buf , int _n ) ;
   _ssize_t ( __attribute__((__cdecl__)) (*_write))(void *_cookie , char const   *_buf ,
                                                    int _n ) ;
   _fpos_t ( __attribute__((__cdecl__)) (*_seek))(void *_cookie , _fpos_t _offset ,
                                                  int _whence ) ;
   int ( __attribute__((__cdecl__)) (*_close))(void *_cookie ) ;
   struct __sbuf _ub ;
   unsigned char *_up ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   int _flags2 ;
   _off64_t _offset ;
   _fpos64_t ( __attribute__((__cdecl__)) (*_seek64))(void *_cookie , _fpos64_t _offset ,
                                                      int _whence ) ;
   _flock_t _lock ;
};
#line 257 "/usr/include/sys/reent.h"
typedef struct __sFILE64 __FILE;
#line 262 "/usr/include/sys/reent.h"
struct _glue {
   struct _glue *_next ;
   int _niobs ;
   __FILE *_iobs ;
};
#line 290 "/usr/include/sys/reent.h"
struct _rand48 {
   unsigned short _seed[3] ;
   unsigned short _mult[3] ;
   unsigned short _add ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__reent_4 {
   unsigned int _unused_rand ;
   char *_strtok_last ;
   char _asctime_buf[26] ;
   struct __tm _localtime_buf ;
   int _gamma_signgam ;
   unsigned long long _rand_next ;
   struct _rand48 _r48 ;
   _mbstate_t _mblen_state ;
   _mbstate_t _mbtowc_state ;
   _mbstate_t _wctomb_state ;
   char _l64a_buf[8] ;
   char _signal_buf[24] ;
   int _getdate_err ;
   _mbstate_t _mbrlen_state ;
   _mbstate_t _mbrtowc_state ;
   _mbstate_t _mbsrtowcs_state ;
   _mbstate_t _wcrtomb_state ;
   _mbstate_t _wcsrtombs_state ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__unused_5 {
   unsigned char *_nextf[30] ;
   unsigned int _nmalloc[30] ;
};
#line 565 "/usr/include/sys/reent.h"
union __anonunion__new_3 {
   struct __anonstruct__reent_4 _reent ;
   struct __anonstruct__unused_5 _unused ;
};
#line 565 "/usr/include/sys/reent.h"
struct _reent {
   int _errno ;
   __FILE *_stdin ;
   __FILE *_stdout ;
   __FILE *_stderr ;
   int _inc ;
   char _emergency[25] ;
   int _current_category ;
   char const   *_current_locale ;
   int __sdidinit ;
   void ( __attribute__((__cdecl__)) (*__cleanup))(struct _reent * ) ;
   struct _Bigint *_result ;
   int _result_k ;
   struct _Bigint *_p5s ;
   struct _Bigint **_freelist ;
   int _cvtlen ;
   char *_cvtbuf ;
   union __anonunion__new_3 _new ;
   struct _atexit *_atexit ;
   struct _atexit _atexit0 ;
   void (**_sig_func)(int  ) ;
   struct _glue __sglue ;
   __FILE __sf[3] ;
};
#line 50 "/usr/include/stdio.h"
typedef __FILE FILE;
#line 44 "/usr/include/cygwin/signal.h"
#pragma pack(push,4)
#line 101
#pragma pack(pop)
#line 15 "/usr/include/signal.h"
struct _reent;
#line 12 "D:/a/test/300.c"
struct netbox {
   struct netbox *nterm ;
   int terminal ;
   int extint ;
   int xpos ;
   int ypos ;
   int newx ;
   int newy ;
   short row ;
   short cell ;
   short net ;
   char pinloc ;
   char unequiv ;
   char flag ;
   char layer ;
};
#line 12 "D:/a/test/300.c"
typedef struct netbox *NBOXPTR;
#line 12 "D:/a/test/300.c"
typedef struct netbox NBOX;
#line 112 "D:/a/test/300.c"
struct blockbox {
   int bxcenter ;
   int bycenter ;
   short bleft ;
   short bright ;
   short bbottom ;
   short btop ;
   short bheight ;
   short blength ;
   short desire ;
   short oldsize ;
   short newsize ;
   short bclass ;
   short borient ;
};
#line 112 "D:/a/test/300.c"
typedef struct blockbox *BBOXPTR;
#line 112 "D:/a/test/300.c"
typedef struct blockbox BBOX;
#line 128 "D:/a/test/300.c"
struct termbox {
   struct termbox *nextterm ;
   NBOXPTR termptr ;
   int cellterm ;
   int ei ;
   short net ;
   short txpos[2] ;
   short typos[2] ;
   short ue ;
};
#line 128 "D:/a/test/300.c"
typedef struct termbox *TEBOXPTR;
#line 128 "D:/a/test/300.c"
typedef struct termbox TEBOX;
#line 138 "D:/a/test/300.c"
struct tilebox {
   short left ;
   short right ;
   short bottom ;
   short top ;
   TEBOXPTR termsptr ;
};
#line 138 "D:/a/test/300.c"
typedef struct tilebox *TIBOXPTR;
#line 138 "D:/a/test/300.c"
typedef struct tilebox TIBOX;
#line 147 "D:/a/test/300.c"
struct cellbox {
   char *cname ;
   char corient ;
   char orflag ;
   int cxcenter ;
   int cycenter ;
   short cclass ;
   short cheight ;
   short clength ;
   short border ;
   short cblock ;
   short numterms ;
   short padside ;
   TIBOXPTR tileptr ;
};
#line 147 "D:/a/test/300.c"
typedef struct cellbox *CBOXPTR;
#line 147 "D:/a/test/300.c"
typedef struct cellbox CBOX;
#line 164 "D:/a/test/300.c"
struct dimbox {
   NBOXPTR netptr ;
   char *name ;
   char dflag ;
   char feedflag ;
   char ignore ;
   int old_total ;
   int new_total ;
   int xmin ;
   int newxmin ;
   int xmax ;
   int newxmax ;
   int ymin ;
   int newymin ;
   int ymax ;
   int newymax ;
   short Lnum ;
   short newLnum ;
   short Rnum ;
   short newRnum ;
   short Bnum ;
   short newBnum ;
   short Tnum ;
   short newTnum ;
   short numpins ;
   double Vweight ;
   double Hweight ;
};
#line 164 "D:/a/test/300.c"
typedef struct dimbox *DBOXPTR;
#line 164 "D:/a/test/300.c"
typedef struct dimbox DBOX;
#line 194 "D:/a/test/300.c"
struct hash {
   char *hname ;
   int hnum ;
   struct hash *hnext ;
};
#line 194 "D:/a/test/300.c"
typedef struct hash HASHBOX;
#line 194 "D:/a/test/300.c"
typedef struct hash *HASHPTR;
#line 201 "D:/a/test/300.c"
struct rowbox {
   int startx ;
   int endx ;
   int endx1 ;
   int startx2 ;
   int ypos ;
   int desiredL ;
};
#line 201 "D:/a/test/300.c"
typedef struct rowbox ROWBOX;
#line 209 "D:/a/test/300.c"
struct binbox {
   int left ;
   int right ;
   int *cell ;
   int penalty ;
   int nupenalty ;
};
#line 209 "D:/a/test/300.c"
typedef struct binbox BINBOX;
#line 209 "D:/a/test/300.c"
typedef struct binbox *BINPTR;
#line 217
struct densitybox;
#line 217 "D:/a/test/300.c"
struct changrdbox {
   NBOXPTR netptr ;
   short tracks ;
   short ntracks ;
   short SegType ;
   short nSegType ;
   struct changrdbox *prevgrd ;
   struct changrdbox *nprevgrd ;
   struct changrdbox *nextgrd ;
   struct changrdbox *nnextgrd ;
   struct densitybox *dptr ;
};
#line 217 "D:/a/test/300.c"
typedef struct changrdbox *CHANGRDPTR;
#line 217 "D:/a/test/300.c"
typedef struct changrdbox CHANGRDBOX;
#line 231 "D:/a/test/300.c"
struct tgridbox {
   CHANGRDPTR up ;
   CHANGRDPTR down ;
};
#line 231 "D:/a/test/300.c"
typedef struct tgridbox *TGRIDPTR;
#line 231 "D:/a/test/300.c"
typedef struct tgridbox TGRIDBOX;
#line 237 "D:/a/test/300.c"
struct densitybox {
   CHANGRDPTR grdptr ;
   struct densitybox *next ;
   struct densitybox *nnext ;
   struct densitybox *back ;
   struct densitybox *nback ;
};
#line 237 "D:/a/test/300.c"
typedef struct densitybox *DENSITYPTR;
#line 237 "D:/a/test/300.c"
typedef struct densitybox DENSITYBOX;
#line 246 "D:/a/test/300.c"
struct segbox {
   short channel ;
   int pin1 ;
   int pin2 ;
   CHANGRDPTR pin1ptr ;
   CHANGRDPTR pin2ptr ;
};
#line 246 "D:/a/test/300.c"
typedef struct segbox *SEGBOXPTR;
#line 246 "D:/a/test/300.c"
typedef struct segbox SEGBOX;
#line 255 "D:/a/test/300.c"
struct switchbox {
   int net ;
   char nflag ;
   char ncurrent ;
   char nswYorN ;
   char current ;
   char swYorN ;
   short key ;
   short nkey ;
   SEGBOXPTR ntop ;
   SEGBOXPTR nbot ;
   SEGBOXPTR top ;
   SEGBOXPTR bot ;
};
#line 255 "D:/a/test/300.c"
typedef struct switchbox SWITCHBOX;
#line 271 "D:/a/test/300.c"
struct edgeBox {
   short group1 ;
   short group2 ;
   short cost ;
   short marked ;
   short poison ;
   short done ;
};
#line 271 "D:/a/test/300.c"
typedef struct edgeBox *edgeBptr;
#line 271 "D:/a/test/300.c"
typedef struct edgeBox edgeBox;
#line 281 "D:/a/test/300.c"
struct chkBox {
   short lowx ;
   short highx ;
   short ming ;
   short maxg ;
   short chky ;
};
#line 281 "D:/a/test/300.c"
typedef struct chkBox chkBox;
#line 290 "D:/a/test/300.c"
struct csPinBox {
   int pin ;
   short xloc ;
   short yloc ;
   short top ;
};
#line 290 "D:/a/test/300.c"
typedef struct csPinBox csPinBox;
#line 298 "D:/a/test/300.c"
struct csGroup {
   int extint ;
   int aveX ;
   int aveY ;
   short poison ;
   short edge1 ;
   short edge2 ;
   short unequiv ;
   short block ;
   short check ;
   short numPins ;
   short pinLimit ;
   short flag ;
   csPinBox *pinArray ;
};
#line 298 "D:/a/test/300.c"
typedef struct csGroup csGroup;
#line 1014 "D:/a/test/300.c"
struct macrobox {
   int mx ;
   int my ;
};
#line 1014 "D:/a/test/300.c"
typedef struct macrobox MACROBOX;
#line 2504 "D:/a/test/300.c"
struct ipbox {
   struct ipbox *npin ;
   int ixpos ;
   int iypos ;
   int layer ;
   char *ipname ;
};
#line 2504 "D:/a/test/300.c"
typedef struct ipbox IPBOX;
#line 2504 "D:/a/test/300.c"
typedef struct ipbox *IPBOXPTR;
#line 2511 "D:/a/test/300.c"
struct ibox {
   struct ibox *niptr ;
   int iactive ;
   int aveXpos ;
   int icell ;
   IPBOXPTR iptr ;
};
#line 2511 "D:/a/test/300.c"
typedef struct ibox IBOX;
#line 2511 "D:/a/test/300.c"
typedef struct ibox *IBOXPTR;
#line 8805 "D:/a/test/300.c"
struct impbox {
   int x ;
   struct impbox *next_pin ;
};
#line 8805 "D:/a/test/300.c"
typedef struct impbox IMPBOX;
#line 8809 "D:/a/test/300.c"
struct celltype {
   struct celltype *next_cell ;
   char *name ;
   struct impbox *first_imp ;
};
#line 8809 "D:/a/test/300.c"
typedef struct celltype CELLTYPE;
#line 9682 "D:/a/test/300.c"
struct tmpmerg {
   int value ;
   int next ;
   int first ;
};
#line 9682 "D:/a/test/300.c"
typedef struct tmpmerg TEMPMERG;
#line 9841 "D:/a/test/300.c"
struct MTA {
   int sp ;
   int stk[100][3][3] ;
   int t[3][3] ;
   int ti[3][3] ;
};
#line 9841 "D:/a/test/300.c"
typedef struct MTA MTMY;
#line 9972
enum __anonenum_Bool_21 {
    false = 0,
    true = 1
} ;
#line 9972 "D:/a/test/300.c"
typedef enum __anonenum_Bool_21 Bool;
#line 17330 "D:/a/test/300.c"
struct int2 {
   int sleft ;
   int srite ;
};
#line 17330 "D:/a/test/300.c"
typedef struct int2 INT2;
#line 810 "/usr/include/sys/reent.h"
extern struct _reent *( __attribute__((__cdecl__)) __getreent)(void) ;
#line 172 "/usr/include/stdio.h"
extern int ( __attribute__((__cdecl__)) fclose)(FILE * ) ;
#line 173
extern int ( __attribute__((__cdecl__)) fflush)(FILE * ) ;
#line 177
extern int ( __attribute__((__cdecl__)) fprintf)(FILE * , char const   *  , ...) ;
#line 178
extern int ( __attribute__((__cdecl__)) fscanf)(FILE * , char const   *  , ...) ;
#line 179
extern int ( __attribute__((__cdecl__)) printf)(char const   *  , ...) ;
#line 210
extern void ( __attribute__((__cdecl__)) rewind)(FILE * ) ;
#line 216
extern FILE *( __attribute__((__cdecl__)) fopen)(char const   *_name , char const   *_type ) ;
#line 217
extern int ( __attribute__((__cdecl__)) sprintf)(char * , char const   *  , ...) ;
#line 219
extern int ( __attribute__((__cdecl__)) rename)(char const   * , char const   * ) ;
#line 77 "/usr/include/stdlib.h"
extern void *( __attribute__((__cdecl__)) calloc)(size_t __nmemb , size_t __size ) ;
#line 79
extern  __attribute__((__noreturn__)) void ( __attribute__((__cdecl__)) exit)(int __status ) ;
#line 80
extern void ( __attribute__((__cdecl__)) free)(void * ) ;
#line 87
extern void *( __attribute__((__cdecl__)) malloc)(size_t __size ) ;
#line 106
extern void *( __attribute__((__cdecl__)) realloc)(void *__r , size_t __size ) ;
#line 29 "/usr/include/string.h"
extern int ( __attribute__((__cdecl__)) strcmp)(char const   * , char const   * ) ;
#line 31
extern char *( __attribute__((__cdecl__)) strcpy)(char * , char const   * ) ;
#line 34
extern size_t ( __attribute__((__cdecl__)) strlen)(char const   * ) ;
#line 96 "/usr/include/math.h"
extern double exp(double  ) ;
#line 100
extern double pow(double  , double  ) ;
#line 101
extern double sqrt(double  ) ;
#line 314 "D:/a/test/300.c"
FILE *fpo  ;
#line 315
extern unsigned int randomSeed ;
#line 316
extern unsigned int randomSeed2 ;
#line 317
extern char cktName[128] ;
#line 318
extern int connection_machine ;
#line 319
extern int estimate_feeds ;
#line 320
extern int tw_fast ;
#line 321
extern int gate_array_special ;
#line 322
extern int pin_layers_given ;
#line 323
extern int no_feeds_side_nets ;
#line 324
extern int no_net_normalize ;
#line 325
extern int route2act ;
#line 326
extern int routeGrid ;
#line 327
extern int gridCell ;
#line 328
extern int feedLayer ;
#line 329
extern int resume_run ;
#line 330
extern int attmax ;
#line 331
extern int maxCellO ;
#line 332
extern int iteration ;
#line 333
extern int iwire ;
#line 334
extern int iwirex ;
#line 335
extern int iwirey ;
#line 336
extern int fwire ;
#line 337
extern int fwirex ;
#line 338
extern int fwirey ;
#line 339
extern int blkxspan ;
#line 340
extern int blkyspan ;
#line 341
extern int ffeeds ;
#line 342
extern int addFeeds ;
#line 343
extern int fdWidth ;
#line 344
extern int lrtxspan ;
#line 345
extern int lrtyspan ;
#line 346
extern int **pairArray ;
#line 347
extern int attprcel ;
#line 348
extern int doglobal ;
#line 349
extern int cswaps ;
#line 350
extern int costonly ;
#line 351
extern int restart ;
#line 352
extern int ifrange ;
#line 353
extern int *fixarray ;
#line 355
extern int tw_slow ;
#line 356
extern double T1 ;
#line 357
extern double Tzero ;
#line 358
extern double *desired_accept ;
#line 359
extern double imprange ;
#line 360
extern double binpenCon ;
#line 361
extern double indent ;
#line 362
extern double rowSep ;
#line 363
extern double roLenCon ;
#line 364
extern double stopdeg ;
#line 365
extern double macspace[16] ;
#line 366
extern double cost_scale_factor ;
#line 369 "D:/a/test/300.c"
int tracks  ;
#line 370 "D:/a/test/300.c"
int numChans  ;
#line 371 "D:/a/test/300.c"
int *maxTrack  ;
#line 372 "D:/a/test/300.c"
int rowHeight  ;
#line 373 "D:/a/test/300.c"
int maxterm  ;
#line 374 "D:/a/test/300.c"
int fdthrus  ;
#line 375 "D:/a/test/300.c"
int numSegs  ;
#line 376 "D:/a/test/300.c"
int impcount  ;
#line 377 "D:/a/test/300.c"
int *nofeed  ;
#line 378 "D:/a/test/300.c"
int stage  ;
#line 379 "D:/a/test/300.c"
int *pinlist  ;
#line 380
extern int one_pin_feedthru ;
#line 388
extern HASHPTR *hashtab ;
#line 389
extern int netctr ;
#line 390
extern CBOXPTR *carray ;
#line 391
extern DBOXPTR *netarray ;
#line 392
extern NBOXPTR *tearray ;
#line 393
extern BBOXPTR *barray ;
#line 394
extern ROWBOX *rowArray ;
#line 395
extern BINBOX ***binptr ;
#line 396
extern CHANGRDPTR ULgrdptr ;
#line 396
extern CHANGRDPTR URgrdptr ;
#line 396
extern CHANGRDPTR LLgrdptr ;
#line 396
extern CHANGRDPTR LRgrdptr ;
#line 396
extern CHANGRDPTR *Shuffle ;
#line 397
extern int bdxlen ;
#line 397
extern int bdylen ;
#line 398
extern int numblock ;
#line 399
extern int numcells ;
#line 400
extern int numterms ;
#line 401
extern int numnets ;
#line 402
extern int numRows ;
#line 403
extern int penalty ;
#line 404
extern int funccost ;
#line 405
extern int Trybin ;
#line 406
extern int binpenal ;
#line 407
extern int rowpenal ;
#line 408
extern int newrowpenal ;
#line 409
extern int newbinpenal ;
#line 410
extern int Left_bound ;
#line 410
extern int Rite_bound ;
#line 411
extern int **cedgebin ;
#line 411
extern int cedge_binwidth ;
#line 411
extern int num_edgebin ;
#line 412
extern int gtopChan ;
#line 412
extern int gbotChan ;
#line 414
extern int numBins ;
#line 415
extern int binWidth ;
#line 416
extern int binOffst ;
#line 418
extern int feeds ;
#line 419
extern short **rowgrid ;
#line 420
extern int windx ;
#line 421
extern int randVar ;
#line 422
extern int max_blklength ;
#line 423
extern int desiredL ;
#line 424
extern int implicit_feed_count ;
#line 425
extern int *feeds_in_row ;
#line 427
extern int uneven_cell_height ;
#line 428
extern int track_spacing ;
#line 433 "D:/a/test/300.c"
int celllen  ;
#line 434 "D:/a/test/300.c"
int *fixLRBT  ;
#line 435 "D:/a/test/300.c"
double *padspace  ;
#line 452
int maketabl(void) ;
#line 626
int addhash(char *hname ) ;
#line 872
char *safe_malloc(unsigned int size ) ;
#line 436 "D:/a/test/300.c"
int parser(FILE *fp ) 
{ DBOXPTR nptr ;
  int cell ;
  int test ;
  int layer ;
  int block ;
  int left ;
  int right ;
  int bottom ;
  int top ;
  int xpos ;
  int ypos ;
  int orient ;
  int from ;
  int orderchk ;
  int length ;
  int terms ;
  int term ;
  int i ;
  int pinctr ;
  double space ;
  char input[1024] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  DBOXPTR tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;

  {
#line 448
  celllen = 0;
#line 449
  cell = 0;
#line 450
  terms = 0;
#line 451
  pinctr = 0;
#line 452
  maketabl();
#line 453
  while (1) {
#line 453
    tmp___32 = fscanf(fp, " %s ", input);
#line 453
    if (! (tmp___32 == 1)) {
#line 453
      break;
    }
#line 454
    tmp___31 = strcmp((char const   *)(input), "cell");
#line 454
    if (tmp___31 == 0) {
#line 455
      cell ++;
#line 456
      orderchk = 0;
#line 457
      test = fscanf(fp, " %s ", input);
#line 458
      if (test != 1) {
#line 459
        fprintf(fpo, "Failed to input dummy cell number/name ");
#line 460
        fprintf(fpo, "in the .cel file\n");
#line 461
        fprintf(fpo, "Current cell: %d\n", cell);
#line 462
        exit(1);
      }
#line 464
      fscanf(fp, " %s ", input);
    } else {
#line 465
      tmp___30 = strcmp((char const   *)(input), "left");
#line 465
      if (tmp___30 == 0) {
#line 466
        test = fscanf(fp, " %d ", & left);
#line 467
        if (test != 1) {
#line 468
          fprintf(fpo, "Failed to input left ");
#line 469
          fprintf(fpo, "in the .cel file\n");
#line 470
          fprintf(fpo, "Current cell: %d\n", cell);
#line 471
          exit(1);
        }
#line 473
        fscanf(fp, " %s ", input);
#line 474
        tmp = strcmp((char const   *)(input), "right");
#line 474
        if (tmp == 0) {
#line 475
          test = fscanf(fp, " %d ", & right);
#line 476
          if (test != 1) {
#line 477
            fprintf(fpo, "Failed to input right ");
#line 478
            fprintf(fpo, "in the .cel file\n");
#line 479
            fprintf(fpo, "Current cell: %d\n", cell);
#line 480
            exit(1);
          }
        } else {
#line 483
          fprintf(fpo, "Failed to find keyword right ");
#line 484
          fprintf(fpo, "for a cell\n");
#line 485
          fprintf(fpo, "Current cell: %d\n", cell);
#line 486
          exit(1);
        }
#line 488
        fscanf(fp, " %s ", input);
#line 489
        tmp___0 = strcmp((char const   *)(input), "bottom");
#line 489
        if (tmp___0 == 0) {
#line 490
          test = fscanf(fp, " %d ", & bottom);
#line 491
          if (test != 1) {
#line 492
            fprintf(fpo, "Failed to input bottom ");
#line 493
            fprintf(fpo, "in the .cel file\n");
#line 494
            fprintf(fpo, "Current cell: %d\n", cell);
#line 495
            exit(1);
          }
        } else {
#line 498
          fprintf(fpo, "Failed to find keyword bottom ");
#line 499
          fprintf(fpo, "for a cell\n");
#line 500
          fprintf(fpo, "Current cell: %d\n", cell);
#line 501
          exit(1);
        }
#line 503
        fscanf(fp, " %s ", input);
#line 504
        tmp___1 = strcmp((char const   *)(input), "top");
#line 504
        if (tmp___1 == 0) {
#line 505
          test = fscanf(fp, " %d ", & top);
#line 506
          if (test != 1) {
#line 507
            fprintf(fpo, "Failed to input top ");
#line 508
            fprintf(fpo, "in the .cel file\n");
#line 509
            fprintf(fpo, "Current cell: %d\n", cell);
#line 510
            exit(1);
          }
        } else {
#line 513
          fprintf(fpo, "Failed to find keyword top ");
#line 514
          fprintf(fpo, "for a cell\n");
#line 515
          fprintf(fpo, "Current cell: %d\n", cell);
#line 516
          exit(1);
        }
#line 518
        if (right + left != 0) {
#line 518
          if (right + left != 1) {
#line 519
            fprintf(fpo, "The given center of the cell ");
#line 520
            fprintf(fpo, "is not (right + left) div 2\n");
#line 521
            fprintf(fpo, "Where the remainder is truncated\n");
#line 522
            fprintf(fpo, "Current cell: %d\n", cell);
#line 523
            exit(1);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 518
          if (left > 0) {
#line 519
            fprintf(fpo, "The given center of the cell ");
#line 520
            fprintf(fpo, "is not (right + left) div 2\n");
#line 521
            fprintf(fpo, "Where the remainder is truncated\n");
#line 522
            fprintf(fpo, "Current cell: %d\n", cell);
#line 523
            exit(1);
          }
        }
#line 525
        if (top + bottom != 0) {
#line 525
          if (top + bottom != 1) {
#line 526
            fprintf(fpo, "The given center of the cell ");
#line 527
            fprintf(fpo, "is not (top + bottom) div 2\n");
#line 528
            fprintf(fpo, "Where the remainder is truncated\n");
#line 529
            fprintf(fpo, "Current cell: %d\n", cell);
#line 530
            exit(1);
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 525
          if (bottom > 0) {
#line 526
            fprintf(fpo, "The given center of the cell ");
#line 527
            fprintf(fpo, "is not (top + bottom) div 2\n");
#line 528
            fprintf(fpo, "Where the remainder is truncated\n");
#line 529
            fprintf(fpo, "Current cell: %d\n", cell);
#line 530
            exit(1);
          }
        }
#line 532
        length = right - left;
#line 533
        celllen += length;
      } else {
#line 534
        tmp___29 = strcmp((char const   *)(input), "initially");
#line 534
        if (tmp___29 == 0) {
#line 535
          if (orderchk != 0) {
#line 536
            fprintf(fpo, "cannot preplace fixed sequence\n");
#line 537
            fprintf(fpo, "in the .cel file\n");
#line 538
            fprintf(fpo, "Current cell: %d\n", cell);
#line 539
            exit(1);
          }
#line 541
          orderchk = 1;
#line 542
          fscanf(fp, " %s ", input);
#line 543
          tmp___3 = strcmp((char const   *)(input), "fixed");
#line 543
          if (! (tmp___3 == 0)) {
#line 544
            tmp___2 = strcmp((char const   *)(input), "nonfixed");
#line 544
            if (! (tmp___2 == 0)) {
#line 546
              fprintf(fpo, "Failed to find fixed or nonfixed\n");
#line 547
              fprintf(fpo, "Current cell: %d\n", cell);
#line 548
              exit(1);
            }
          }
#line 550
          test = fscanf(fp, " %d ", & from);
#line 551
          if (test != 1) {
#line 552
            fprintf(fpo, "Failed to input amount from following ");
#line 553
            fprintf(fpo, "(fixed,nonfixed) in the .cel file");
#line 554
            fprintf(fpo, "Current cell: %d\n", cell);
#line 555
            exit(1);
          }
#line 557
          fscanf(fp, " %s ", input);
#line 558
          tmp___4 = strcmp((char const   *)(input), "from");
#line 558
          if (tmp___4 != 0) {
#line 559
            fprintf(fpo, "Failed to find keyword from ");
#line 560
            fprintf(fpo, "in the .cel file");
#line 561
            fprintf(fpo, "Current cell: %d\n", cell);
#line 562
            exit(1);
          }
#line 564
          fscanf(fp, " %s ", input);
#line 565
          tmp___6 = strcmp((char const   *)(input), "left");
#line 565
          if (! (tmp___6 == 0)) {
#line 566
            tmp___5 = strcmp((char const   *)(input), "right");
#line 566
            if (! (tmp___5 == 0)) {
#line 568
              fprintf(fpo, "Failed to find left or right\n");
#line 569
              fprintf(fpo, "following from in the .cel file");
#line 570
              fprintf(fpo, "Current cell: %d\n", cell);
#line 571
              exit(1);
            }
          }
#line 573
          fscanf(fp, " %s ", input);
#line 574
          tmp___7 = strcmp((char const   *)(input), "of");
#line 574
          if (tmp___7 != 0) {
#line 575
            fprintf(fpo, "Failed to find keyword of ");
#line 576
            fprintf(fpo, "in the .cel file");
#line 577
            fprintf(fpo, "Current cell: %d\n", cell);
#line 578
            exit(1);
          }
#line 580
          fscanf(fp, " %s ", input);
#line 581
          tmp___8 = strcmp((char const   *)(input), "block");
#line 581
          if (tmp___8 != 0) {
#line 582
            fprintf(fpo, "Failed to find keyword block ");
#line 583
            fprintf(fpo, "in the .cel file");
#line 584
            fprintf(fpo, "Current cell: %d\n", cell);
#line 585
            exit(1);
          }
#line 587
          test = fscanf(fp, " %d ", & block);
#line 588
          if (test != 1) {
#line 589
            fprintf(fpo, "Failed to input amount from following ");
#line 590
            fprintf(fpo, "(fixed,nonfixed) in the .cel file");
#line 591
            fprintf(fpo, "Current cell: %d\n", cell);
#line 592
            exit(1);
          }
        } else {
#line 595
          tmp___28 = strcmp((char const   *)(input), "nomirror");
#line 595
          if (! (tmp___28 == 0)) {
#line 596
            tmp___27 = strcmp((char const   *)(input), "pin");
#line 596
            if (tmp___27 == 0) {
#line 597
              fscanf(fp, " %s ", input);
#line 598
              tmp___9 = strcmp((char const   *)(input), "name");
#line 598
              if (tmp___9 != 0) {
#line 599
                fprintf(fpo, "Failed to find keyword name ");
#line 600
                fprintf(fpo, "for a pin\n");
#line 601
                fprintf(fpo, "Current cell: %d\n", cell);
#line 602
                exit(1);
              }
#line 604
              test = fscanf(fp, " %s ", input);
#line 605
              if (test != 1) {
#line 606
                fprintf(fpo, "Failed to input pin name ");
#line 607
                fprintf(fpo, "in the .cel file\n");
#line 608
                fprintf(fpo, "Current cell: %d\n", cell);
#line 609
                exit(1);
              }
#line 611
              fscanf(fp, " %s ", input);
#line 612
              tmp___10 = strcmp((char const   *)(input), "signal");
#line 612
              if (tmp___10 != 0) {
#line 613
                fprintf(fpo, "Failed to find keyword signal ");
#line 614
                fprintf(fpo, "for a pin\n");
#line 615
                fprintf(fpo, "Current cell: %d\n", cell);
#line 616
                exit(1);
              }
#line 618
              test = fscanf(fp, " %s ", input);
#line 619
              if (test != 1) {
#line 620
                fprintf(fpo, "Failed to input signal name ");
#line 621
                fprintf(fpo, "in the .cel file\n");
#line 622
                fprintf(fpo, "Current cell: %d\n", cell);
#line 623
                exit(1);
              }
#line 625
              tmp___11 = strcmp((char const   *)(input), "TW_PASS_THRU");
#line 625
              if (tmp___11 != 0) {
#line 626
                addhash(input);
#line 627
                pinctr ++;
              }
#line 629
              if (pin_layers_given != 0) {
#line 630
                fscanf(fp, " %s ", input);
#line 631
                tmp___12 = strcmp((char const   *)(input), "layer");
#line 631
                if (tmp___12 != 0) {
#line 632
                  fprintf(fpo, "Failed to find keyword layer ");
#line 633
                  fprintf(fpo, "for a pin\n");
#line 634
                  fprintf(fpo, "Current cell: %d\n", cell);
#line 635
                  exit(1);
                }
#line 637
                test = fscanf(fp, " %d ", & layer);
#line 638
                if (test != 1) {
#line 639
                  fprintf(fpo, "Failed to input layer number ");
#line 640
                  fprintf(fpo, "in the .cel file\n");
#line 641
                  fprintf(fpo, "Current cell: %d\n", cell);
#line 642
                  exit(1);
                }
#line 644
                if (layer != 1) {
#line 644
                  if (layer != 2) {
#line 644
                    if (layer != 3) {
#line 645
                      fprintf(fpo, "Currently, a layer number ");
#line 646
                      fprintf(fpo, "in the .cel file must be either 1, 2,\n");
#line 647
                      fprintf(fpo, "or 3.   Current cell: %d\n", cell);
#line 648
                      exit(1);
                    }
                  }
                }
              }
#line 651
              test = fscanf(fp, " %d %d ", & xpos, & ypos);
#line 652
              if (test != 2) {
#line 653
                fprintf(fpo, "Failed to input 2 items ");
#line 654
                fprintf(fpo, "for pin in the .cel file\n");
#line 655
                fprintf(fpo, "Current cell: %d\n", cell);
#line 656
                exit(1);
              }
            } else {
#line 658
              tmp___26 = strcmp((char const   *)(input), "equiv");
#line 658
              if (tmp___26 == 0) {
#line 659
                fscanf(fp, " %s ", input);
#line 660
                tmp___13 = strcmp((char const   *)(input), "name");
#line 660
                if (tmp___13 != 0) {
#line 661
                  fprintf(fpo, "Failed to find keyword name ");
#line 662
                  fprintf(fpo, "for an equiv pin\n");
#line 663
                  fprintf(fpo, "Current cell: %d\n", cell);
#line 664
                  exit(1);
                }
#line 666
                test = fscanf(fp, " %s ", input);
#line 667
                if (test != 1) {
#line 668
                  fprintf(fpo, "Failed to input equiv pin name ");
#line 669
                  fprintf(fpo, "in the .cel file\n");
#line 670
                  fprintf(fpo, "Current cell: %d\n", cell);
#line 671
                  exit(1);
                }
#line 673
                if (pin_layers_given != 0) {
#line 674
                  fscanf(fp, " %s ", input);
#line 675
                  tmp___14 = strcmp((char const   *)(input), "layer");
#line 675
                  if (tmp___14 != 0) {
#line 676
                    fprintf(fpo, "Failed to find keyword layer ");
#line 677
                    fprintf(fpo, "for an equiv pin\n");
#line 678
                    fprintf(fpo, "Current cell: %d\n", cell);
#line 679
                    exit(1);
                  }
#line 681
                  test = fscanf(fp, " %d ", & layer);
#line 682
                  if (test != 1) {
#line 683
                    fprintf(fpo, "Failed to input layer number ");
#line 684
                    fprintf(fpo, "in the .cel file\n");
#line 685
                    fprintf(fpo, "Current cell: %d\n", cell);
#line 686
                    exit(1);
                  }
#line 688
                  if (layer != 1) {
#line 688
                    if (layer != 2) {
#line 688
                      if (layer != 3) {
#line 689
                        fprintf(fpo, "Currently, a layer number ");
#line 690
                        fprintf(fpo, "in the .cel file must be either 1, 2,\n");
#line 691
                        fprintf(fpo, "or 3.   Current cell: %d\n", cell);
#line 692
                        exit(1);
                      }
                    }
                  }
                }
#line 695
                test = fscanf(fp, " %d %d ", & xpos, & ypos);
#line 696
                if (test != 2) {
#line 697
                  fprintf(fpo, "Failed to input 2 items ");
#line 698
                  fprintf(fpo, "for equiv in the .cel file\n");
#line 699
                  fprintf(fpo, "Current cell: %d\n", cell);
#line 700
                  exit(1);
                }
              } else {
#line 702
                tmp___25 = strcmp((char const   *)(input), "unequiv");
#line 702
                if (tmp___25 == 0) {
#line 703
                  fscanf(fp, " %s ", input);
#line 704
                  tmp___15 = strcmp((char const   *)(input), "name");
#line 704
                  if (tmp___15 != 0) {
#line 705
                    fprintf(fpo, "Failed to find keyword name ");
#line 706
                    fprintf(fpo, "for an unequiv pin\n");
#line 707
                    fprintf(fpo, "Current cell: %d\n", cell);
#line 708
                    exit(1);
                  }
#line 710
                  test = fscanf(fp, " %s ", input);
#line 711
                  if (test != 1) {
#line 712
                    fprintf(fpo, "Failed to input unequiv pin name ");
#line 713
                    fprintf(fpo, "in the .cel file\n");
#line 714
                    fprintf(fpo, "Current cell: %d\n", cell);
#line 715
                    exit(1);
                  }
#line 717
                  if (pin_layers_given != 0) {
#line 718
                    fscanf(fp, " %s ", input);
#line 719
                    tmp___16 = strcmp((char const   *)(input), "layer");
#line 719
                    if (tmp___16 != 0) {
#line 720
                      fprintf(fpo, "Failed to find keyword layer ");
#line 721
                      fprintf(fpo, "for an unequiv pin\n");
#line 722
                      fprintf(fpo, "Current cell: %d\n", cell);
#line 723
                      exit(1);
                    }
#line 725
                    test = fscanf(fp, " %d ", & layer);
#line 726
                    if (test != 1) {
#line 727
                      fprintf(fpo, "Failed to input layer number ");
#line 728
                      fprintf(fpo, "in the .cel file\n");
#line 729
                      fprintf(fpo, "Current cell: %d\n", cell);
#line 730
                      exit(1);
                    }
#line 732
                    if (layer != 1) {
#line 732
                      if (layer != 2) {
#line 732
                        if (layer != 3) {
#line 733
                          fprintf(fpo, "Currently, a layer number ");
#line 734
                          fprintf(fpo, "in the .cel file must be either 1, 2,\n");
#line 735
                          fprintf(fpo, "or 3.   Current cell: %d\n", cell);
#line 736
                          exit(1);
                        }
                      }
                    }
                  }
#line 739
                  test = fscanf(fp, " %d %d ", & xpos, & ypos);
#line 740
                  if (test != 2) {
#line 741
                    fprintf(fpo, "Failed to input 2 items ");
#line 742
                    fprintf(fpo, "for unequiv in the .cel file\n");
#line 743
                    fprintf(fpo, "Current cell: %d\n", cell);
#line 744
                    exit(1);
                  }
                } else {
#line 746
                  tmp___24 = strcmp((char const   *)(input), "pad");
#line 746
                  if (tmp___24 == 0) {
#line 747
                    terms ++;
#line 748
                    test = fscanf(fp, " %s ", input);
#line 749
                    if (test != 1) {
#line 750
                      fprintf(fpo, "Failed to input dummy pad number/name ");
#line 751
                      fprintf(fpo, "in the .cel file\n");
#line 752
                      fprintf(fpo, "Current cell: %d\n", cell);
#line 753
                      exit(1);
                    }
#line 755
                    fscanf(fp, " %s ", input);
#line 756
                    fscanf(fp, " %s ", input);
#line 757
                    tmp___17 = strcmp((char const   *)(input), "orient");
#line 757
                    if (tmp___17 == 0) {
#line 758
                      test = fscanf(fp, " %d ", & orient);
#line 759
                      if (test != 1) {
#line 760
                        fprintf(fpo, "Failed to input orient ");
#line 761
                        fprintf(fpo, "in the .cel file\n");
#line 762
                        fprintf(fpo, "Current cell: %d\n", cell);
#line 763
                        exit(1);
                      }
                    } else {
#line 766
                      fprintf(fpo, "Failed to find keyword orient ");
#line 767
                      fprintf(fpo, "for a pad\n");
#line 768
                      fprintf(fpo, "Current cell: %d\n", cell);
#line 769
                      exit(1);
                    }
#line 771
                    fscanf(fp, " %s ", input);
#line 772
                    tmp___18 = strcmp((char const   *)(input), "padside");
#line 772
                    if (tmp___18 == 0) {
#line 773
                      test = fscanf(fp, " %s ", input);
#line 774
                      if (test != 1) {
#line 775
                        fprintf(fpo, "Failed to input padside ");
#line 776
                        fprintf(fpo, "in the .cel file\n");
#line 777
                        fprintf(fpo, "Current cell: %d\n", cell);
#line 778
                        exit(1);
                      }
                    } else {
#line 781
                      fprintf(fpo, "Failed to find keyword padside ");
#line 782
                      fprintf(fpo, "for a pad\n");
#line 783
                      fprintf(fpo, "Current cell: %d\n", cell);
#line 784
                      exit(1);
                    }
#line 786
                    fscanf(fp, " %s ", input);
#line 787
                    tmp___19 = strcmp((char const   *)(input), "left");
#line 787
                    if (tmp___19 == 0) {
#line 788
                      test = fscanf(fp, " %d ", & left);
#line 789
                      if (test != 1) {
#line 790
                        fprintf(fpo, "Failed to input left ");
#line 791
                        fprintf(fpo, "in the .cel file\n");
#line 792
                        fprintf(fpo, "Current cell: %d\n", cell);
#line 793
                        exit(1);
                      }
                    } else {
#line 796
                      fprintf(fpo, "Failed to find keyword left ");
#line 797
                      fprintf(fpo, "for a pad\n");
#line 798
                      fprintf(fpo, "Current cell: %d\n", cell);
#line 799
                      exit(1);
                    }
#line 801
                    fscanf(fp, " %s ", input);
#line 802
                    tmp___20 = strcmp((char const   *)(input), "right");
#line 802
                    if (tmp___20 == 0) {
#line 803
                      test = fscanf(fp, " %d ", & right);
#line 804
                      if (test != 1) {
#line 805
                        fprintf(fpo, "Failed to input right ");
#line 806
                        fprintf(fpo, "in the .cel file\n");
#line 807
                        fprintf(fpo, "Current cell: %d\n", cell);
#line 808
                        exit(1);
                      }
                    } else {
#line 811
                      fprintf(fpo, "Failed to find keyword right ");
#line 812
                      fprintf(fpo, "for a pad\n");
#line 813
                      fprintf(fpo, "Current cell: %d\n", cell);
#line 814
                      exit(1);
                    }
#line 816
                    if (right + left != 0) {
#line 816
                      if (right + left != 1) {
#line 817
                        fprintf(fpo, "The given center of the cell ");
#line 818
                        fprintf(fpo, "is not (right + left) div 2\n");
#line 819
                        fprintf(fpo, "Where the remainder is truncated\n");
#line 820
                        fprintf(fpo, "Current cell: %d\n", cell);
#line 821
                        exit(1);
                      }
                    }
#line 823
                    fscanf(fp, " %s ", input);
#line 824
                    tmp___21 = strcmp((char const   *)(input), "bottom");
#line 824
                    if (tmp___21 == 0) {
#line 825
                      test = fscanf(fp, " %d ", & bottom);
#line 826
                      if (test != 1) {
#line 827
                        fprintf(fpo, "Failed to input bottom ");
#line 828
                        fprintf(fpo, "in the .cel file\n");
#line 829
                        fprintf(fpo, "Current cell: %d\n", cell);
#line 830
                        exit(1);
                      }
                    } else {
#line 833
                      fprintf(fpo, "Failed to find keyword bottom ");
#line 834
                      fprintf(fpo, "for a pad\n");
#line 835
                      fprintf(fpo, "Current cell: %d\n", cell);
#line 836
                      exit(1);
                    }
#line 838
                    fscanf(fp, " %s ", input);
#line 839
                    tmp___22 = strcmp((char const   *)(input), "top");
#line 839
                    if (tmp___22 == 0) {
#line 840
                      test = fscanf(fp, " %d ", & top);
#line 841
                      if (test != 1) {
#line 842
                        fprintf(fpo, "Failed to input top ");
#line 843
                        fprintf(fpo, "in the .cel file\n");
#line 844
                        fprintf(fpo, "Current cell: %d\n", cell);
#line 845
                        exit(1);
                      }
                    } else {
#line 848
                      fprintf(fpo, "Failed to find keyword top ");
#line 849
                      fprintf(fpo, "for a pad\n");
#line 850
                      fprintf(fpo, "Current cell: %d\n", cell);
#line 851
                      exit(1);
                    }
#line 853
                    if (top + bottom != 0) {
#line 853
                      if (top + bottom != 1) {
#line 854
                        fprintf(fpo, "The given center of the cell ");
#line 855
                        fprintf(fpo, "is not (top + bottom) div 2\n");
#line 856
                        fprintf(fpo, "Where the remainder is truncated\n");
#line 857
                        fprintf(fpo, "Current cell: %d\n", cell);
#line 858
                        exit(1);
                      }
                    }
                  } else {
#line 860
                    tmp___23 = strcmp((char const   *)(input), "sidespace");
#line 860
                    if (tmp___23 == 0) {
#line 861
                      test = fscanf(fp, " %lf ", & space);
                    } else {
#line 863
                      fprintf(fpo, "Found unparsable keyword in ");
#line 864
                      fprintf(fpo, "the .cel file\n");
#line 865
                      fprintf(fpo, "Current cell: %d\n", cell);
#line 866
                      exit(1);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 869
  rewind(fp);
#line 870
  numcells = cell;
#line 871
  numterms = terms;
#line 872
  tmp___33 = (int )safe_malloc((unsigned int )(numterms + 1) * sizeof(double ));
#line 872
  padspace = (double *)tmp___33;
#line 873
  i = 1;
#line 873
  while (i <= numterms) {
#line 874
    *(padspace + i) = 0.0;
#line 873
    i ++;
  }
#line 876
  tmp___34 = (int )safe_malloc(4U * sizeof(int ));
#line 876
  fixLRBT = (int *)tmp___34;
#line 877
  *(fixLRBT + 0) = 0;
#line 878
  *(fixLRBT + 1) = 0;
#line 879
  *(fixLRBT + 2) = 0;
#line 880
  *(fixLRBT + 3) = 0;
#line 881
  tmp___35 = (int )safe_malloc((unsigned int )(netctr + 1) * sizeof(DBOXPTR ));
#line 881
  netarray = (DBOXPTR *)tmp___35;
#line 882
  i = 1;
#line 882
  while (i <= netctr) {
#line 883
    tmp___37 = (int )safe_malloc(sizeof(DBOX ));
#line 883
    tmp___36 = (struct dimbox *)tmp___37;
#line 883
    *(netarray + i) = tmp___36;
#line 883
    nptr = tmp___36;
#line 884
    nptr->netptr = (struct netbox *)((void *)0);
#line 885
    nptr->name = (char *)((void *)0);
#line 886
    nptr->dflag = (char)0;
#line 887
    nptr->xmin = 0;
#line 888
    nptr->newxmin = 0;
#line 889
    nptr->xmax = 0;
#line 890
    nptr->newxmax = 0;
#line 891
    nptr->ymin = 0;
#line 892
    nptr->newymin = 0;
#line 893
    nptr->ymax = 0;
#line 894
    nptr->newymax = 0;
#line 895
    nptr->Hweight = 1.0;
#line 896
    nptr->Vweight = 1.0;
#line 897
    nptr->feedflag = (char)0;
#line 898
    nptr->ignore = (char)0;
#line 882
    i ++;
  }
#line 900
  numnets = netctr;
#line 901
  tmp___38 = (int )safe_malloc((unsigned int )(pinctr + 1) * sizeof(NBOXPTR ));
#line 901
  tearray = (NBOXPTR *)tmp___38;
#line 902
  term = 1;
#line 902
  while (term <= pinctr) {
#line 903
    *(tearray + term) = (struct netbox *)((void *)0);
#line 902
    term ++;
  }
#line 905
  maxterm = pinctr;
#line 906
  return 0;
}
}
#line 911 "D:/a/test/300.c"
double *relativeLen  ;
#line 912 "D:/a/test/300.c"
int readblck(FILE *fp ) 
{ int test ;
  int block ;
  int class ;
  int height ;
  int row ;
  double relLen ;
  char input[32] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 918
  block = 0;
#line 919
  while (1) {
#line 919
    tmp___5 = fscanf(fp, " %s ", input);
#line 919
    if (! (tmp___5 == 1)) {
#line 919
      break;
    }
#line 920
    tmp___4 = strcmp((char const   *)(input), "block");
#line 920
    if (tmp___4 == 0) {
#line 921
      block ++;
#line 922
      fscanf(fp, " %s ", input);
#line 923
      tmp = strcmp((char const   *)(input), "height");
#line 923
      if (tmp == 0) {
#line 924
        test = fscanf(fp, " %d ", & height);
#line 925
        if (test != 1) {
#line 926
          fprintf(fpo, "Failed to input height of a block\n");
#line 927
          fprintf(fpo, "at position height\n");
#line 928
          exit(1);
        }
      } else {
#line 931
        fprintf(fpo, "unexpected keyword in the .blk file\n");
#line 932
        fprintf(fpo, "at position height\n");
#line 933
        fprintf(fpo, "current block: %d\n", block);
#line 934
        exit(1);
      }
#line 936
      fscanf(fp, " %s ", input);
#line 937
      tmp___0 = strcmp((char const   *)(input), "class");
#line 937
      if (tmp___0 == 0) {
#line 938
        test = fscanf(fp, " %d ", & class);
#line 939
        if (test != 1) {
#line 940
          fprintf(fpo, "Failed to input class of a block\n");
#line 941
          fprintf(fpo, "current block: %d\n", block);
#line 942
          exit(1);
        }
      } else {
#line 945
        fprintf(fpo, "unexpected keyword in the .blk file\n");
#line 946
        fprintf(fpo, "at position class\n");
#line 947
        fprintf(fpo, "current block: %d\n", block);
#line 948
        exit(1);
      }
    } else {
#line 950
      tmp___3 = strcmp((char const   *)(input), "mirror");
#line 950
      if (! (tmp___3 == 0)) {
#line 951
        tmp___2 = strcmp((char const   *)(input), "nofeeds");
#line 951
        if (! (tmp___2 == 0)) {
#line 952
          tmp___1 = strcmp((char const   *)(input), "relative_length");
#line 952
          if (tmp___1 == 0) {
#line 953
            test = fscanf(fp, " %f ", & relLen);
          } else {
#line 955
            fprintf(fpo, "unexpected keyword in the .blk file\n");
#line 956
            fprintf(fpo, "current block: %d\n", block);
#line 957
            exit(1);
          }
        }
      }
    }
  }
#line 960
  numblock = block;
#line 961
  rewind(fp);
#line 962
  tmp___6 = (int )safe_malloc((unsigned int )(numblock + 1) * sizeof(BBOXPTR ));
#line 962
  barray = (BBOXPTR *)tmp___6;
#line 963
  tmp___7 = (int )safe_malloc((unsigned int )(numblock + 2) * sizeof(int ));
#line 963
  nofeed = (int *)tmp___7;
#line 964
  row = 0;
#line 964
  while (row <= numblock + 1) {
#line 965
    *(nofeed + row) = 0;
#line 964
    row ++;
  }
#line 967
  tmp___8 = (int )safe_malloc((unsigned int )(numblock + 1) * sizeof(double ));
#line 967
  relativeLen = (double *)tmp___8;
#line 968
  block = 1;
#line 968
  while (block <= numblock) {
#line 969
    *(relativeLen + block) = 1.0;
#line 968
    block ++;
  }
#line 971
  block = 1;
#line 971
  while (block <= numblock) {
#line 972
    tmp___9 = (int )safe_malloc(sizeof(BBOX ));
#line 972
    *(barray + block) = (struct blockbox *)tmp___9;
#line 973
    (*(barray + block))->bxcenter = 0;
#line 974
    (*(barray + block))->bycenter = 0;
#line 975
    (*(barray + block))->bleft = (short)0;
#line 976
    (*(barray + block))->bright = (short)0;
#line 977
    (*(barray + block))->bbottom = (short)0;
#line 978
    (*(barray + block))->btop = (short)0;
#line 979
    (*(barray + block))->bheight = (short)0;
#line 980
    (*(barray + block))->blength = (short)0;
#line 981
    (*(barray + block))->bclass = (short)0;
#line 982
    (*(barray + block))->borient = (short)0;
#line 983
    (*(barray + block))->desire = (short)0;
#line 984
    (*(barray + block))->oldsize = (short)0;
#line 985
    (*(barray + block))->newsize = (short)0;
#line 971
    block ++;
  }
#line 987
  block = 0;
#line 988
  while (1) {
#line 988
    tmp___14 = fscanf(fp, " %s ", input);
#line 988
    if (! (tmp___14 == 1)) {
#line 988
      break;
    }
#line 989
    tmp___13 = strcmp((char const   *)(input), "block");
#line 989
    if (tmp___13 == 0) {
#line 990
      block ++;
#line 991
      fscanf(fp, " %s ", input);
#line 992
      fscanf(fp, " %d ", & height);
#line 993
      (*(barray + block))->btop = (short )(height - height / 2);
#line 994
      (*(barray + block))->bbottom = (short )(- height / 2);
#line 995
      (*(barray + block))->bheight = (short )height;
#line 996
      fscanf(fp, " %s ", input);
#line 997
      fscanf(fp, " %d ", & class);
#line 998
      (*(barray + block))->bclass = (short )class;
#line 999
      (*(barray + block))->borient = (short)1;
    } else {
#line 1000
      tmp___12 = strcmp((char const   *)(input), "mirror");
#line 1000
      if (tmp___12 == 0) {
#line 1001
        (*(barray + block))->borient = (short)2;
      } else {
#line 1002
        tmp___11 = strcmp((char const   *)(input), "nofeeds");
#line 1002
        if (tmp___11 == 0) {
#line 1003
          *(nofeed + block) = 1;
        } else {
#line 1004
          tmp___10 = strcmp((char const   *)(input), "relative_length");
#line 1004
          if (tmp___10 == 0) {
#line 1005
            fscanf(fp, " %f ", & relLen);
#line 1006
            *(relativeLen + block) = relLen;
          }
        }
      }
    }
  }
#line 1009

  return 0;
}
}
#line 1018 "D:/a/test/300.c"
int *blkToRow  ;
#line 1020 "D:/a/test/300.c"
BBOXPTR boxptr  ;
#line 1020 "D:/a/test/300.c"
BBOXPTR *oldbarray  ;
#line 1021 "D:/a/test/300.c"
CBOXPTR cellptr  ;
#line 1022 "D:/a/test/300.c"
MACROBOX *macroArray  ;
#line 1023 "D:/a/test/300.c"
int *filledTo  ;
#line 1023 "D:/a/test/300.c"
int *endRow  ;
#line 1024 "D:/a/test/300.c"
int macNumber  ;
#line 1024 "D:/a/test/300.c"
int row  ;
#line 1024 "D:/a/test/300.c"
int totalR  ;
#line 1025 "D:/a/test/300.c"
int totalBlock  ;
#line 1025 "D:/a/test/300.c"
int borient  ;
#line 1025 "D:/a/test/300.c"
int empty  ;
#line 1025 "D:/a/test/300.c"
int cell  ;
#line 1025 "D:/a/test/300.c"
int middleRow  ;
#line 1026 "D:/a/test/300.c"
int extraSpace  ;
#line 1026 "D:/a/test/300.c"
int pad  ;
#line 1026 "D:/a/test/300.c"
int height  ;
#line 1026 "D:/a/test/300.c"
int width  ;
#line 1026 "D:/a/test/300.c"
int bot  ;
#line 1026 "D:/a/test/300.c"
int top  ;
#line 1026 "D:/a/test/300.c"
int trow  ;
#line 1027 "D:/a/test/300.c"
static int rows1  ;
#line 1028 "D:/a/test/300.c"
int brow  ;
#line 1028 "D:/a/test/300.c"
int rite  ;
#line 1028 "D:/a/test/300.c"
int left  ;
#line 1028 "D:/a/test/300.c"
int coreHeight  ;
#line 1028 "D:/a/test/300.c"
int coreWidth  ;
#line 1028 "D:/a/test/300.c"
int count  ;
#line 1028 "D:/a/test/300.c"
int macro  ;
#line 1029 "D:/a/test/300.c"
int maxHeight  ;
#line 1029 "D:/a/test/300.c"
int space  ;
#line 1029 "D:/a/test/300.c"
int separation  ;
#line 1029 "D:/a/test/300.c"
int yshift  ;
#line 1029 "D:/a/test/300.c"
int xshift  ;
#line 1029 "D:/a/test/300.c"
int last  ;
#line 1030 "D:/a/test/300.c"
int coreTop  ;
#line 1030 "D:/a/test/300.c"
int coreRite  ;
#line 1030 "D:/a/test/300.c"
int block  ;
#line 1030 "D:/a/test/300.c"
int maxWidth  ;
#line 1030 "D:/a/test/300.c"
int *padArray  ;
#line 1030 "D:/a/test/300.c"
int numMacro  ;
#line 1031 "D:/a/test/300.c"
int URmacro  ;
#line 1031 "D:/a/test/300.c"
int Rmacro  ;
#line 1031 "D:/a/test/300.c"
int edge  ;
#line 1032 "D:/a/test/300.c"
int k  ;
#line 1032 "D:/a/test/300.c"
int blk  ;
#line 1032 "D:/a/test/300.c"
int zxshift  ;
#line 1032 "D:/a/test/300.c"
int zyshift  ;
#line 1033 "D:/a/test/300.c"
int mttshift  ;
#line 1033 "D:/a/test/300.c"
int mbbshift  ;
#line 1034 "D:/a/test/300.c"
double dsum  ;
#line 1034 "D:/a/test/300.c"
double ratio  ;
#line 1035 "D:/a/test/300.c"
int config1(void) 
{ double totalF ;
  double modulation ;
  double constant ;
  int M ;
  int r ;
  int topRowY ;
  int centerY ;
  int count_mtt ;
  int count_mbb ;
  CBOXPTR padptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1041
  tmp = (int )safe_malloc(51U * sizeof(MACROBOX ));
#line 1041
  macroArray = (MACROBOX *)tmp;
#line 1042
  macNumber = 0;
#line 1043
  numRows = numblock;
#line 1044
  tmp___0 = (int )safe_malloc((unsigned int )(numRows + 1) * sizeof(ROWBOX ));
#line 1044
  rowArray = (ROWBOX *)tmp___0;
#line 1045
  row = 1;
#line 1045
  while (row <= numRows) {
#line 1046
    (rowArray + row)->endx1 = -1;
#line 1047
    (rowArray + row)->startx2 = -1;
#line 1045
    row ++;
  }
#line 1049
  totalR = celllen;
#line 1050
  rowHeight = 0;
#line 1051
  row = 1;
#line 1051
  while (row <= numRows) {
#line 1052
    rowHeight += (int )(*(barray + row))->btop - (int )(*(barray + row))->bbottom;
#line 1051
    row ++;
  }
#line 1054
  rowHeight /= numRows;
#line 1055
  row = 1;
#line 1055
  while (row <= numRows) {
#line 1056
    (rowArray + row)->startx = 0;
#line 1057
    (rowArray + row)->ypos = (int )(((double )(row - 1) * (rowSep + (double )1)) * (double )rowHeight + (double )(rowHeight / 2));
#line 1055
    row ++;
  }
#line 1060
  if (numRows > 1) {
#line 1061
    totalF = 0.0;
#line 1062
    r = 1;
#line 1062
    while (r <= numRows) {
#line 1063
      totalF += *(relativeLen + r);
#line 1062
      r ++;
    }
#line 1065
    topRowY = (rowArray + numRows)->ypos;
#line 1066
    centerY = (topRowY + (rowArray + 1)->ypos) / 2;
#line 1067
    M = (int )((double )totalR / totalF);
#line 1068
    dsum = 0.0;
#line 1069
    r = 1;
#line 1069
    while (r <= numRows) {
#line 1070
      if ((rowArray + r)->ypos - centerY >= 0) {
#line 1070
        tmp___1 = (rowArray + r)->ypos - centerY;
      } else {
#line 1070
        tmp___1 = - ((rowArray + r)->ypos - centerY);
      }
#line 1070
      dsum += *(relativeLen + r) * (double )tmp___1;
#line 1069
      r ++;
    }
#line 1073
    dsum /= totalF;
#line 1074
    dsum *= 1.0 / (double )(topRowY - centerY);
#line 1075
    constant = 1.0 + (1.0 - indent) * (1.0 - dsum);
#line 1076
    r = 1;
#line 1076
    while (r <= numRows) {
#line 1077
      (rowArray + r)->endx = (int )(((double )M * constant) * *(relativeLen + r));
#line 1079
      if ((rowArray + r)->ypos - centerY >= 0) {
#line 1079
        tmp___2 = (rowArray + r)->ypos - centerY;
      } else {
#line 1079
        tmp___2 = - ((rowArray + r)->ypos - centerY);
      }
#line 1079
      modulation = 1.0 + (1.0 - indent) * ((double )tmp___2 / (double )(topRowY - centerY) - dsum);
#line 1082
      (rowArray + r)->desiredL = (int )(((double )M * *(relativeLen + r)) * modulation) + 1;
#line 1076
      r ++;
    }
  } else {
#line 1086
    (rowArray + 1)->endx = totalR;
#line 1087
    (rowArray + 1)->desiredL = (rowArray + 1)->endx;
  }
#line 1089
  extraSpace = (int )(rowSep * (double )rowHeight);
#line 1090
  k = 1;
#line 1090
  while (k <= 15) {
#line 1091
    if (macspace[k] < 0.0) {
#line 1092
      macspace[k] = (double )extraSpace;
    } else {
#line 1094
      macspace[k] *= (double )rowHeight;
    }
#line 1090
    k ++;
  }
#line 1097
  middleRow = numRows / 2;
#line 1098
  tmp___3 = (int )safe_malloc((unsigned int )(numterms + 1) * sizeof(int ));
#line 1098
  padArray = (int *)tmp___3;
#line 1099
  pad = 1;
#line 1099
  while (pad <= numterms) {
#line 1100
    *(padArray + pad) = 0;
#line 1099
    pad ++;
  }
#line 1102
  numMacro = 0;
#line 1103
  pad = numcells + 1;
#line 1103
  while (pad <= numcells + numterms) {
#line 1104
    if ((int )(*(carray + pad))->padside == 5) {
#line 1106
      numMacro ++;
#line 1106
      *(padArray + numMacro) = pad;
    } else {
#line 1104
      if ((int )(*(carray + pad))->padside == 9) {
#line 1106
        numMacro ++;
#line 1106
        *(padArray + numMacro) = pad;
      } else {
#line 1104
        if ((int )(*(carray + pad))->padside == 7) {
#line 1106
          numMacro ++;
#line 1106
          *(padArray + numMacro) = pad;
        }
      }
    }
#line 1103
    pad ++;
  }
#line 1109
  pad = numcells + 1;
#line 1109
  while (pad <= numcells + numterms) {
#line 1110
    if ((int )(*(carray + pad))->padside == 12) {
#line 1112
      numMacro ++;
#line 1112
      *(padArray + numMacro) = pad;
    } else {
#line 1110
      if ((int )(*(carray + pad))->padside == 13) {
#line 1112
        numMacro ++;
#line 1112
        *(padArray + numMacro) = pad;
      } else {
#line 1110
        if ((int )(*(carray + pad))->padside == 11) {
#line 1112
          numMacro ++;
#line 1112
          *(padArray + numMacro) = pad;
        }
      }
    }
#line 1109
    pad ++;
  }
#line 1115
  pad = numcells + 1;
#line 1115
  while (pad <= numcells + numterms) {
#line 1116
    if ((int )(*(carray + pad))->padside == 6) {
#line 1117
      numMacro ++;
#line 1117
      *(padArray + numMacro) = pad;
#line 1118
      URmacro = numMacro;
    }
#line 1115
    pad ++;
  }
#line 1121
  pad = numcells + 1;
#line 1121
  while (pad <= numcells + numterms) {
#line 1122
    if ((int )(*(carray + pad))->padside == 10) {
#line 1123
      numMacro ++;
#line 1123
      *(padArray + numMacro) = pad;
#line 1124
      Rmacro = numMacro;
    }
#line 1121
    pad ++;
  }
#line 1127
  pad = numcells + 1;
#line 1127
  while (pad <= numcells + numterms) {
#line 1128
    if ((int )(*(carray + pad))->padside == 8) {
#line 1129
      numMacro ++;
#line 1129
      *(padArray + numMacro) = pad;
    }
#line 1127
    pad ++;
  }
#line 1132
  macro = 1;
#line 1132
  while (macro <= numMacro) {
#line 1133
    pad = *(padArray + macro);
#line 1134
    padptr = *(carray + pad);
#line 1135
    height = (int )(padptr->tileptr)->top - (int )(padptr->tileptr)->bottom;
#line 1136
    width = (int )(padptr->tileptr)->right - (int )(padptr->tileptr)->left;
#line 1137
    macNumber ++;
#line 1138
    switch ((int )padptr->padside) {
    case 5: 
#line 1139
    row = numRows;
#line 1139
    while (row >= 1) {
#line 1140
      if ((double )(rowArray + row)->ypos + (rowSep * (double )rowHeight) * 0.33 <= (double )((rowArray + numRows)->ypos - height)) {
#line 1143
        break;
      }
#line 1139
      row --;
    }
#line 1147
    rows1 = numRows - row;
#line 1148
    row ++;
#line 1148
    while (row <= numRows) {
#line 1149
      (rowArray + row)->startx = (int )((double )width + macspace[5]);
#line 1150
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL - ((double )width + macspace[5]));
#line 1148
      row ++;
    }
#line 1152
    row = 1;
#line 1152
    while (row <= numRows) {
#line 1153
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx + ((double )rows1 * ((double )width + macspace[5])) / (double )numRows);
#line 1155
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL + ((double )rows1 * ((double )width + macspace[5])) / (double )numRows);
#line 1152
      row ++;
    }
#line 1158
    (macroArray + macNumber)->mx = width / 2;
#line 1159
    (macroArray + macNumber)->my = ((rowArray + numRows)->ypos + rowHeight / 2) - height / 2;
#line 1162
    break;
    case 6: 
#line 1163
    row = numRows;
#line 1163
    while (row >= 1) {
#line 1164
      if ((double )(rowArray + row)->ypos + (rowSep * (double )rowHeight) * 0.33 <= (double )((rowArray + numRows)->ypos - height)) {
#line 1167
        break;
      }
#line 1163
      row --;
    }
#line 1171
    rows1 = numRows - row;
#line 1172
    row ++;
#line 1172
    while (row <= numRows) {
#line 1173
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx - ((double )width + macspace[6]));
#line 1174
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL - ((double )width + macspace[6]));
#line 1172
      row ++;
    }
#line 1176
    row = 1;
#line 1176
    while (row <= numRows) {
#line 1177
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx + ((double )rows1 * ((double )width + macspace[6])) / (double )numRows);
#line 1179
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL + ((double )rows1 * ((double )width + macspace[6])) / (double )numRows);
#line 1176
      row ++;
    }
#line 1182
    (macroArray + macNumber)->mx = (int )(((double )(rowArray + numRows)->endx + macspace[6]) + (double )(width / 2));
#line 1184
    (macroArray + macNumber)->my = ((rowArray + numRows)->ypos + rowHeight / 2) - height / 2;
#line 1187
    break;
    case 7: 
#line 1188
    row = 1;
#line 1188
    while (row <= numRows) {
#line 1189
      if ((double )(rowArray + row)->ypos - (rowSep * (double )rowHeight) * 0.33 >= (double )((rowArray + 1)->ypos + height)) {
#line 1192
        break;
      }
#line 1188
      row ++;
    }
#line 1196
    rows1 = row - 1;
#line 1197
    row --;
#line 1197
    while (row >= 1) {
#line 1198
      (rowArray + row)->startx = (int )((double )width + macspace[7]);
#line 1199
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL - ((double )width + macspace[7]));
#line 1197
      row --;
    }
#line 1201
    row = 1;
#line 1201
    while (row <= numRows) {
#line 1202
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx + ((double )rows1 * ((double )width + macspace[7])) / (double )numRows);
#line 1204
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL + ((double )rows1 * ((double )width + macspace[7])) / (double )numRows);
#line 1201
      row ++;
    }
#line 1207
    (macroArray + macNumber)->mx = width / 2;
#line 1208
    (macroArray + macNumber)->my = ((rowArray + 1)->ypos - rowHeight / 2) + height / 2;
#line 1211
    break;
    case 8: 
#line 1212
    row = 1;
#line 1212
    while (row <= numRows) {
#line 1213
      if ((double )(rowArray + row)->ypos - (rowSep * (double )rowHeight) * 0.33 >= (double )((rowArray + 1)->ypos + height)) {
#line 1216
        break;
      }
#line 1212
      row ++;
    }
#line 1220
    rows1 = row - 1;
#line 1221
    row --;
#line 1221
    while (row >= 1) {
#line 1222
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx - ((double )width + macspace[8]));
#line 1223
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL - ((double )width + macspace[8]));
#line 1221
      row --;
    }
#line 1225
    row = 1;
#line 1225
    while (row <= numRows) {
#line 1226
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx + ((double )rows1 * ((double )width + macspace[8])) / (double )numRows);
#line 1228
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL + ((double )rows1 * ((double )width + macspace[8])) / (double )numRows);
#line 1225
      row ++;
    }
#line 1231
    if (URmacro != 0) {
#line 1232
      (macroArray + URmacro)->mx = (int )((double )(macroArray + URmacro)->mx + ((double )rows1 * ((double )width + macspace[8])) / (double )numRows);
    }
#line 1235
    if (Rmacro != 0) {
#line 1236
      (macroArray + Rmacro)->mx = (int )((double )(macroArray + Rmacro)->mx + ((double )rows1 * ((double )width + macspace[8])) / (double )numRows);
    }
#line 1239
    (macroArray + macNumber)->mx = (int )(((double )(rowArray + 1)->endx + macspace[8]) + (double )(width / 2));
#line 1241
    (macroArray + macNumber)->my = ((rowArray + 1)->ypos - rowHeight / 2) + height / 2;
#line 1244
    break;
    case 9: 
#line 1245
    bot = (rowArray + middleRow)->ypos - height / 2;
#line 1246
    top = bot + height;
#line 1247
    row = 1;
#line 1247
    while (row <= numRows) {
#line 1248
      if ((double )((rowArray + row)->ypos - rowHeight / 2) - (rowSep * (double )rowHeight) * 0.33 >= (double )top) {
#line 1250
        break;
      }
#line 1247
      row ++;
    }
#line 1253
    trow = row;
#line 1254
    row = numRows;
#line 1254
    while (row >= 1) {
#line 1255
      if ((double )((rowArray + row)->ypos + rowHeight / 2) + (rowSep * (double )rowHeight) * 0.33 <= (double )bot) {
#line 1257
        break;
      }
#line 1254
      row --;
    }
#line 1260
    brow = row;
#line 1262
    rows1 = (trow - brow) - 1;
#line 1263
    row = brow + 1;
#line 1263
    while (row < trow) {
#line 1264
      (rowArray + row)->startx = (int )((double )width + macspace[9]);
#line 1265
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL - ((double )width + macspace[9]));
#line 1263
      row ++;
    }
#line 1267
    row = 1;
#line 1267
    while (row <= numRows) {
#line 1268
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx + ((double )rows1 * ((double )width + macspace[9])) / (double )numRows);
#line 1270
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL + ((double )rows1 * ((double )width + macspace[9])) / (double )numRows);
#line 1267
      row ++;
    }
#line 1273
    (macroArray + macNumber)->mx = width / 2;
#line 1274
    (macroArray + macNumber)->my = (rowArray + middleRow)->ypos;
#line 1275
    break;
    case 10: 
#line 1276
    bot = (rowArray + middleRow)->ypos - height / 2;
#line 1277
    top = bot + height;
#line 1278
    row = 1;
#line 1278
    while (row <= numRows) {
#line 1279
      if ((double )((rowArray + row)->ypos - rowHeight / 2) - (rowSep * (double )rowHeight) * 0.33 >= (double )top) {
#line 1281
        break;
      }
#line 1278
      row ++;
    }
#line 1284
    trow = row;
#line 1285
    row = numRows;
#line 1285
    while (row >= 1) {
#line 1286
      if ((double )((rowArray + row)->ypos + rowHeight / 2) + (rowSep * (double )rowHeight) * 0.33 <= (double )bot) {
#line 1288
        break;
      }
#line 1285
      row --;
    }
#line 1291
    brow = row;
#line 1293
    rows1 = (trow - brow) - 1;
#line 1294
    row = brow + 1;
#line 1294
    while (row < trow) {
#line 1295
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx - ((double )width + macspace[10]));
#line 1296
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL - ((double )width + macspace[10]));
#line 1294
      row ++;
    }
#line 1298
    row = 1;
#line 1298
    while (row <= numRows) {
#line 1299
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx + ((double )rows1 * ((double )width + macspace[10])) / (double )numRows);
#line 1301
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL + ((double )rows1 * ((double )width + macspace[10])) / (double )numRows);
#line 1298
      row ++;
    }
#line 1304
    if (URmacro != 0) {
#line 1305
      (macroArray + URmacro)->mx = (int )((double )(macroArray + URmacro)->mx + ((double )rows1 * ((double )width + macspace[10])) / (double )numRows);
    }
#line 1308
    (macroArray + macNumber)->mx = (int )(((double )(rowArray + middleRow)->endx + macspace[10]) + (double )(width / 2));
#line 1311
    (macroArray + macNumber)->my = (rowArray + middleRow)->ypos;
#line 1312
    break;
    case 13: 
#line 1313
    bot = (rowArray + middleRow)->ypos - height / 2;
#line 1314
    top = bot + height;
#line 1316
    left = ((rowArray + middleRow)->startx + (rowArray + middleRow)->endx) / 2;
#line 1318
    rite = left + width;
#line 1319
    row = 1;
#line 1319
    while (row <= numRows) {
#line 1320
      if ((double )((rowArray + row)->ypos - rowHeight / 2) - (rowSep * (double )rowHeight) * 0.67 >= (double )top) {
#line 1322
        break;
      }
#line 1319
      row ++;
    }
#line 1325
    trow = row;
#line 1326
    row = numRows;
#line 1326
    while (row >= 1) {
#line 1327
      if ((double )((rowArray + row)->ypos + rowHeight / 2) + (rowSep * (double )rowHeight) * 0.67 <= (double )bot) {
#line 1329
        break;
      }
#line 1326
      row --;
    }
#line 1332
    brow = row;
#line 1334
    rows1 = (trow - brow) - 1;
#line 1335
    row = brow + 1;
#line 1335
    while (row < trow) {
#line 1336
      (rowArray + row)->endx1 = (int )((double )left - macspace[13]);
#line 1337
      (rowArray + row)->startx2 = (int )((double )rite + macspace[13]);
#line 1338
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL - ((double )width + (double )2 * macspace[13]));
#line 1335
      row ++;
    }
#line 1340
    row = 1;
#line 1340
    while (row <= numRows) {
#line 1341
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx + ((double )rows1 * ((double )width + (double )2 * macspace[13])) / (double )numRows);
#line 1343
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL + ((double )rows1 * ((double )width + (double )2 * macspace[13])) / (double )numRows);
#line 1340
      row ++;
    }
#line 1346
    (macroArray + macNumber)->mx = (left + rite) / 2;
#line 1347
    (macroArray + macNumber)->my = (bot + top) / 2;
#line 1348
    break;
    case 11: 
#line 1349
    bot = (rowArray + 1)->ypos - rowHeight / 2;
#line 1350
    top = bot + height;
#line 1351
    left = ((rowArray + 1)->startx + (rowArray + 1)->endx) / 2 - width / 2;
#line 1353
    rite = left + width;
#line 1354
    row = 1;
#line 1354
    while (row <= numRows) {
#line 1355
      if ((double )((rowArray + row)->ypos - rowHeight / 2) - (rowSep * (double )rowHeight) * 0.67 >= (double )top) {
#line 1357
        break;
      }
#line 1354
      row ++;
    }
#line 1360
    trow = row;
#line 1361
    brow = 0;
#line 1363
    rows1 = (trow - brow) - 1;
#line 1364
    row = brow + 1;
#line 1364
    while (row < trow) {
#line 1365
      (rowArray + row)->endx1 = (int )((double )left - macspace[11]);
#line 1366
      (rowArray + row)->startx2 = (int )((double )rite + macspace[11]);
#line 1367
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL - ((double )width + (double )2 * macspace[11]));
#line 1364
      row ++;
    }
#line 1369
    row = 1;
#line 1369
    while (row <= numRows) {
#line 1370
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx + ((double )rows1 * ((double )width + (double )2 * macspace[11])) / (double )numRows);
#line 1372
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL + ((double )rows1 * ((double )width + (double )2 * macspace[11])) / (double )numRows);
#line 1369
      row ++;
    }
#line 1375
    (macroArray + macNumber)->mx = (left + rite) / 2;
#line 1376
    (macroArray + macNumber)->my = (bot + top) / 2;
#line 1377
    break;
    case 12: 
#line 1378
    top = (rowArray + numRows)->ypos + rowHeight / 2;
#line 1379
    bot = top - height;
#line 1380
    left = ((rowArray + numRows)->startx + (rowArray + numRows)->endx) / 2 - width / 2;
#line 1382
    rite = left + width;
#line 1383
    trow = numRows + 1;
#line 1384
    row = numRows;
#line 1384
    while (row >= 1) {
#line 1385
      if ((double )((rowArray + row)->ypos + rowHeight / 2) + (rowSep * (double )rowHeight) * 0.67 <= (double )bot) {
#line 1387
        break;
      }
#line 1384
      row --;
    }
#line 1390
    brow = row;
#line 1392
    rows1 = (trow - brow) - 1;
#line 1393
    row = brow + 1;
#line 1393
    while (row < trow) {
#line 1394
      (rowArray + row)->endx1 = (int )((double )left - macspace[12]);
#line 1395
      (rowArray + row)->startx2 = (int )((double )rite + macspace[12]);
#line 1396
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL - ((double )width + (double )2 * macspace[12]));
#line 1393
      row ++;
    }
#line 1398
    row = 1;
#line 1398
    while (row <= numRows) {
#line 1399
      (rowArray + row)->endx = (int )((double )(rowArray + row)->endx + ((double )rows1 * ((double )width + (double )2 * macspace[12])) / (double )numRows);
#line 1401
      (rowArray + row)->desiredL = (int )((double )(rowArray + row)->desiredL + ((double )rows1 * ((double )width + (double )2 * macspace[12])) / (double )numRows);
#line 1398
      row ++;
    }
#line 1404
    (macroArray + macNumber)->mx = (left + rite) / 2;
#line 1405
    (macroArray + macNumber)->my = (bot + top) / 2;
#line 1406
    break;
    default: 
#line 1407
    fprintf(fpo, "screwup in finding padside\n");
#line 1408
    exit(1);
#line 1409
    break;
    }
#line 1132
    macro ++;
  }
#line 1412
  coreHeight = ((rowArray + numRows)->ypos + rowHeight) - rowHeight / 2;
#line 1413
  coreWidth = 0;
#line 1414
  row = 1;
#line 1414
  while (row <= numRows) {
#line 1415
    if ((rowArray + row)->endx > coreWidth) {
#line 1416
      coreWidth = (rowArray + row)->endx;
    }
#line 1414
    row ++;
  }
#line 1419
  macro = 1;
#line 1419
  while (macro <= numMacro) {
#line 1420
    pad = *(padArray + macro);
#line 1421
    edge = (macroArray + macro)->mx + (int )((*(carray + pad))->tileptr)->right;
#line 1422
    if (edge > coreWidth) {
#line 1423
      coreWidth = edge;
    }
#line 1419
    macro ++;
  }
#line 1426
  mbbshift = 0;
#line 1427
  height = 0;
#line 1428
  width = 0;
#line 1429
  count_mbb = 0;
#line 1430
  pad = numcells + 1;
#line 1430
  while (pad <= numcells + numterms) {
#line 1431
    padptr = *(carray + pad);
#line 1432
    if ((int )padptr->padside == 15) {
#line 1433
      if ((int )(padptr->tileptr)->top - (int )(padptr->tileptr)->bottom > height) {
#line 1434
        height = (int )(padptr->tileptr)->top - (int )(padptr->tileptr)->bottom;
      }
#line 1436
      width += (int )(padptr->tileptr)->right - (int )(padptr->tileptr)->left;
#line 1437
      count_mbb ++;
    }
#line 1430
    pad ++;
  }
#line 1440
  if (count_mbb > 0) {
#line 1441
    mbbshift = (int )((double )height + rowSep * (double )rowHeight);
#line 1442
    row = 1;
#line 1442
    while (row <= numRows) {
#line 1443
      (rowArray + row)->ypos += mbbshift;
#line 1442
      row ++;
    }
#line 1445
    coreHeight += mbbshift;
#line 1446
    if (width > coreWidth) {
#line 1447
      coreWidth = width;
    }
#line 1449
    space = coreWidth - width;
#line 1450
    separation = space / (count_mbb + 1);
#line 1451
    if (separation < 0) {
#line 1452
      separation = 0;
    }
#line 1454
    maxHeight = height;
#line 1455
    height = 0;
#line 1456
    width = 0;
#line 1457
    last = separation;
#line 1458
    pad = numcells + 1;
#line 1458
    while (pad <= numcells + numterms) {
#line 1459
      padptr = *(carray + pad);
#line 1460
      if ((int )padptr->padside == 15) {
#line 1461
        height = (int )(padptr->tileptr)->top - (int )(padptr->tileptr)->bottom;
#line 1462
        width = (int )(padptr->tileptr)->right - (int )(padptr->tileptr)->left;
#line 1463
        padptr->cxcenter = last + width / 2;
#line 1464
        padptr->cycenter = (maxHeight - height / 2) - 1;
#line 1465
        last += separation + width;
      }
#line 1458
      pad ++;
    }
  }
#line 1469
  mttshift = 0;
#line 1470
  height = 0;
#line 1471
  width = 0;
#line 1472
  count_mtt = 0;
#line 1473
  pad = numcells + 1;
#line 1473
  while (pad <= numcells + numterms) {
#line 1474
    padptr = *(carray + pad);
#line 1475
    if ((int )padptr->padside == 14) {
#line 1476
      if ((int )(padptr->tileptr)->top - (int )(padptr->tileptr)->bottom > height) {
#line 1477
        height = (int )(padptr->tileptr)->top - (int )(padptr->tileptr)->bottom;
      }
#line 1479
      width += (int )(padptr->tileptr)->right - (int )(padptr->tileptr)->left;
#line 1480
      count_mtt ++;
    }
#line 1473
    pad ++;
  }
#line 1483
  if (count_mtt > 0) {
#line 1484
    mttshift = (int )((double )height + rowSep * (double )rowHeight);
#line 1485
    coreHeight += mttshift;
#line 1486
    if (width > coreWidth) {
#line 1487
      coreWidth = width;
    }
#line 1489
    space = coreWidth - width;
#line 1490
    separation = space / (count_mtt + 1);
#line 1491
    if (separation < 0) {
#line 1492
      separation = 0;
    }
#line 1494
    height = 0;
#line 1495
    width = 0;
#line 1496
    last = separation;
#line 1497
    pad = numcells + 1;
#line 1497
    while (pad <= numcells + numterms) {
#line 1498
      padptr = *(carray + pad);
#line 1499
      if ((int )padptr->padside == 14) {
#line 1500
        height = (int )(padptr->tileptr)->top - (int )(padptr->tileptr)->bottom;
#line 1501
        width = (int )(padptr->tileptr)->right - (int )(padptr->tileptr)->left;
#line 1502
        padptr->cxcenter = last + width / 2;
#line 1503
        padptr->cycenter = (int )(((double )coreHeight + rowSep * (double )rowHeight) + (double )(height / 2));
#line 1505
        last += separation + width;
      }
#line 1497
      pad ++;
    }
  }
#line 1509
  return 0;
}
}
#line 1511 "D:/a/test/300.c"
int a  ;
#line 1511 "D:/a/test/300.c"
int b  ;
#line 1511 "D:/a/test/300.c"
int ablock  ;
#line 1511 "D:/a/test/300.c"
int bblock  ;
#line 1514
double partition(int C_initial , int k_initial , int p_initial , int R_initial ) ;
#line 1515
double compute_and_combination(int C , int k___0 , int p , int RM ) ;
#line 1516
double combination(int numerator , int denominator ) ;
#line 1517
double expected_value(int C_initial , int k_initial , int p_initial , int R_initial ) ;
#line 1518
double expected_svalue(int C_initial , int k_initial , int p_initial , int R_initial ) ;
#line 1519 "D:/a/test/300.c"
double finalRowControl  ;
#line 1520 "D:/a/test/300.c"
double initialRowControl  ;
#line 1521 "D:/a/test/300.c"
int newpenal  ;
#line 1522 "D:/a/test/300.c"
int Apost  ;
#line 1522 "D:/a/test/300.c"
int Bpost  ;
#line 1523 "D:/a/test/300.c"
int *cellaptr  ;
#line 1523 "D:/a/test/300.c"
int *cellbptr  ;
#line 1524 "D:/a/test/300.c"
int earlyRej  ;
#line 1524 "D:/a/test/300.c"
int Rej_error  ;
#line 1526 "D:/a/test/300.c"
int wire_chg  ;
#line 1526 "D:/a/test/300.c"
int binpen_chg  ;
#line 1526 "D:/a/test/300.c"
int rowpen_chg  ;
#line 1528 "D:/a/test/300.c"
int attempts  ;
#line 1529 "D:/a/test/300.c"
int delta_vert_cost  ;
#line 1530 "D:/a/test/300.c"
int tot_num_feeds  ;
#line 1531 "D:/a/test/300.c"
int tot_missing_rows  ;
#line 1533 "D:/a/test/300.c"
int *num_feeds  ;
#line 1534 "D:/a/test/300.c"
int *tmp_num_feeds  ;
#line 1535 "D:/a/test/300.c"
int *missing_rows  ;
#line 1536 "D:/a/test/300.c"
int *tmp_missing_rows  ;
#line 1537 "D:/a/test/300.c"
static char **rows  ;
#line 1538 "D:/a/test/300.c"
char **tmp_rows  ;
#line 1543 "D:/a/test/300.c"
int axcenter  ;
#line 1543 "D:/a/test/300.c"
int aycenter  ;
#line 1543 "D:/a/test/300.c"
int bxcenter  ;
#line 1543 "D:/a/test/300.c"
int bycenter  ;
#line 1544 "D:/a/test/300.c"
int anxcenter  ;
#line 1544 "D:/a/test/300.c"
int bnxcenter  ;
#line 1545 "D:/a/test/300.c"
int aleft  ;
#line 1545 "D:/a/test/300.c"
int aright  ;
#line 1545 "D:/a/test/300.c"
int bleft  ;
#line 1545 "D:/a/test/300.c"
int bright  ;
#line 1546 "D:/a/test/300.c"
int potential_errors  ;
#line 1546 "D:/a/test/300.c"
int error_count  ;
#line 1546 "D:/a/test/300.c"
int P_limit  ;
#line 1547 "D:/a/test/300.c"
double total_wire_chg  ;
#line 1548 "D:/a/test/300.c"
double sigma_wire_chg  ;
#line 1549 "D:/a/test/300.c"
double mean_wire_chg  ;
#line 1550 "D:/a/test/300.c"
int wire_chgs  ;
#line 1586
int new_old(int c ) ;
#line 1587
int find_new_pos(void) ;
#line 1596
int old_assgnto_new2(int a1lobin , int a1hibin , int a2lobin , int a2hibin , int b1lobin ,
                     int b1hibin , int b2lobin , int b2hibin ) ;
#line 1598
int sub_penal(int startx , int endx , int block___0 , int LoBin , int HiBin ) ;
#line 1600
int add_penal(int startx , int endx , int block___0 , int LoBin , int HiBin ) ;
#line 1617
int term_newpos_a(TEBOXPTR antrmptr , int xcenter , int ycenter , int newaor ) ;
#line 1618
int term_newpos_b(TEBOXPTR antrmptr , int xcenter , int ycenter , int newaor ) ;
#line 1620
int term_newpos(TEBOXPTR antrmptr , int xcenter , int ycenter , int newaor ) ;
#line 1626
int new_dbox_a(TEBOXPTR antrmptr , int *costptr ) ;
#line 1629
int new_dbox(TEBOXPTR antrmptr , int *costptr ) ;
#line 1633
int acceptt(int delta_cost ) ;
#line 1638
int new_assgnto_old2(int a1lobin , int a1hibin , int a2lobin , int a2hibin , int b1lobin ,
                     int b1hibin , int b2lobin , int b2hibin ) ;
#line 1641
int dbox_pos_2(TEBOXPTR antrmptr ) ;
#line 1644
int dbox_pos(TEBOXPTR antrmptr ) ;
#line 1650
extern int ( /* missing proto */  remv_cell)(int x,int y) ;
#line 1652
int add_cell(int **cellptr___0 , int c ) ;
#line 1552 "D:/a/test/300.c"
int ucxx2(void) 
{ CBOXPTR acellptr ;
  CBOXPTR bcellptr ;
  TIBOXPTR atileptr ;
  TIBOXPTR btileptr ;
  TEBOXPTR atermptr ;
  TEBOXPTR btermptr ;
  int error_light_is_on ;
  int cost ;
  int aorient ;
  int borient___0 ;
  int a1LoBin ;
  int a1HiBin ;
  int b1LoBin ;
  int b1HiBin ;
  int a2LoBin ;
  int a2HiBin ;
  int b2LoBin ;
  int b2HiBin ;
  int startxa1 ;
  int endxa1 ;
  int startxa2 ;
  int endxa2 ;
  int startxb1 ;
  int endxb1 ;
  int startxb2 ;
  int endxb2 ;
  int anbin ;
  int bnbin ;
  int i ;
  int truth ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1567
  acellptr = *(carray + a);
#line 1568
  axcenter = acellptr->cxcenter;
#line 1569
  aycenter = acellptr->cycenter;
#line 1570
  aorient = (int )acellptr->corient;
#line 1571
  atileptr = acellptr->tileptr;
#line 1572
  aleft = (int )atileptr->left;
#line 1573
  aright = (int )atileptr->right;
#line 1574
  atermptr = atileptr->termsptr;
#line 1575
  bcellptr = *(carray + b);
#line 1576
  bxcenter = bcellptr->cxcenter;
#line 1577
  bycenter = bcellptr->cycenter;
#line 1578
  borient___0 = (int )bcellptr->corient;
#line 1579
  btileptr = bcellptr->tileptr;
#line 1580
  bleft = (int )btileptr->left;
#line 1581
  bright = (int )btileptr->right;
#line 1582
  btermptr = btileptr->termsptr;
#line 1583
  newbinpenal = binpenal;
#line 1584
  newrowpenal = rowpenal;
#line 1585
  newpenal = penalty;
#line 1586
  new_old(((bright - bleft) - aright) + aleft);
#line 1587
  find_new_pos();
#line 1588
  startxa1 = axcenter + aleft;
#line 1588
  Trybin = (startxa1 - binOffst) / binWidth;
#line 1588
  if (Trybin < 0) {
#line 1588
    a1LoBin = 0;
  } else {
#line 1588
    if (Trybin > numBins) {
#line 1588
      tmp = numBins;
    } else {
#line 1588
      tmp = Trybin;
    }
#line 1588
    a1LoBin = tmp;
  }
#line 1589
  endxa1 = axcenter + aright;
#line 1589
  Trybin = (endxa1 - binOffst) / binWidth;
#line 1589
  if (Trybin < 0) {
#line 1589
    a1HiBin = 0;
  } else {
#line 1589
    if (Trybin > numBins) {
#line 1589
      tmp___0 = numBins;
    } else {
#line 1589
      tmp___0 = Trybin;
    }
#line 1589
    a1HiBin = tmp___0;
  }
#line 1590
  startxb1 = bxcenter + bleft;
#line 1590
  Trybin = (startxb1 - binOffst) / binWidth;
#line 1590
  if (Trybin < 0) {
#line 1590
    b1LoBin = 0;
  } else {
#line 1590
    if (Trybin > numBins) {
#line 1590
      tmp___1 = numBins;
    } else {
#line 1590
      tmp___1 = Trybin;
    }
#line 1590
    b1LoBin = tmp___1;
  }
#line 1591
  endxb1 = bxcenter + bright;
#line 1591
  Trybin = (endxb1 - binOffst) / binWidth;
#line 1591
  if (Trybin < 0) {
#line 1591
    b1HiBin = 0;
  } else {
#line 1591
    if (Trybin > numBins) {
#line 1591
      tmp___2 = numBins;
    } else {
#line 1591
      tmp___2 = Trybin;
    }
#line 1591
    b1HiBin = tmp___2;
  }
#line 1592
  startxa2 = anxcenter + aleft;
#line 1592
  Trybin = (startxa2 - binOffst) / binWidth;
#line 1592
  if (Trybin < 0) {
#line 1592
    a2LoBin = 0;
  } else {
#line 1592
    if (Trybin > numBins) {
#line 1592
      tmp___3 = numBins;
    } else {
#line 1592
      tmp___3 = Trybin;
    }
#line 1592
    a2LoBin = tmp___3;
  }
#line 1593
  endxa2 = anxcenter + aright;
#line 1593
  Trybin = (endxa2 - binOffst) / binWidth;
#line 1593
  if (Trybin < 0) {
#line 1593
    a2HiBin = 0;
  } else {
#line 1593
    if (Trybin > numBins) {
#line 1593
      tmp___4 = numBins;
    } else {
#line 1593
      tmp___4 = Trybin;
    }
#line 1593
    a2HiBin = tmp___4;
  }
#line 1594
  startxb2 = bnxcenter + bleft;
#line 1594
  Trybin = (startxb2 - binOffst) / binWidth;
#line 1594
  if (Trybin < 0) {
#line 1594
    b2LoBin = 0;
  } else {
#line 1594
    if (Trybin > numBins) {
#line 1594
      tmp___5 = numBins;
    } else {
#line 1594
      tmp___5 = Trybin;
    }
#line 1594
    b2LoBin = tmp___5;
  }
#line 1595
  endxb2 = bnxcenter + bright;
#line 1595
  Trybin = (endxb2 - binOffst) / binWidth;
#line 1595
  if (Trybin < 0) {
#line 1595
    b2HiBin = 0;
  } else {
#line 1595
    if (Trybin > numBins) {
#line 1595
      tmp___6 = numBins;
    } else {
#line 1595
      tmp___6 = Trybin;
    }
#line 1595
    b2HiBin = tmp___6;
  }
#line 1596
  old_assgnto_new2(a1LoBin, a1HiBin, b1LoBin, b1HiBin, a2LoBin, a2HiBin, b2LoBin,
                   b2HiBin);
#line 1598
  sub_penal(startxa1, endxa1, ablock, a1LoBin, a1HiBin);
#line 1599
  sub_penal(startxb1, endxb1, bblock, b1LoBin, b1HiBin);
#line 1600
  add_penal(startxa2, endxa2, bblock, a2LoBin, a2HiBin);
#line 1601
  add_penal(startxb2, endxb2, ablock, b2LoBin, b2HiBin);
#line 1602
  binpen_chg = newbinpenal - binpenal;
#line 1603
  rowpen_chg = newrowpenal - rowpenal;
#line 1604
  newpenal = (int )(roLenCon * (double )newrowpenal + binpenCon * (double )newbinpenal);
#line 1606
  error_light_is_on = 0;
#line 1607
  if (newpenal - penalty > P_limit) {
#line 1608
    if (potential_errors < 100) {
#line 1609
      potential_errors ++;
#line 1610
      error_light_is_on = 1;
    } else {
#line 1612
      earlyRej ++;
#line 1613
      return (-1);
    }
  }
#line 1616
  if (ablock != bblock) {
#line 1617
    term_newpos_a(atermptr, anxcenter, bycenter, aorient);
#line 1618
    term_newpos_b(btermptr, bnxcenter, aycenter, borient___0);
  } else {
#line 1620
    term_newpos(atermptr, anxcenter, bycenter, aorient);
#line 1621
    term_newpos(btermptr, bnxcenter, aycenter, borient___0);
  }
#line 1623
  cost = funccost;
#line 1624
  delta_vert_cost = 0;
#line 1625
  if (ablock != bblock) {
#line 1626
    new_dbox_a(atermptr, & cost);
#line 1627
    new_dbox_a(btermptr, & cost);
  } else {
#line 1629
    new_dbox(atermptr, & cost);
#line 1630
    new_dbox(btermptr, & cost);
  }
#line 1632
  wire_chg = cost - funccost;
#line 1633
  truth = acceptt((((funccost + penalty) - cost) - newpenal) - delta_vert_cost);
#line 1634
  if (truth == 1) {
#line 1635
    if (error_light_is_on) {
#line 1636
      error_count ++;
    }
#line 1638
    new_assgnto_old2(a1LoBin, a1HiBin, b1LoBin, b1HiBin, a2LoBin, a2HiBin, b2LoBin,
                     b2HiBin);
#line 1640
    if (ablock != bblock) {
#line 1641
      dbox_pos_2(atermptr);
#line 1642
      dbox_pos_2(btermptr);
    } else {
#line 1644
      dbox_pos(atermptr);
#line 1645
      dbox_pos(btermptr);
    }
#line 1647
    Trybin = (anxcenter - binOffst) / binWidth;
#line 1647
    if (Trybin < 0) {
#line 1647
      anbin = 0;
    } else {
#line 1647
      if (Trybin > numBins) {
#line 1647
        tmp___7 = numBins;
      } else {
#line 1647
        tmp___7 = Trybin;
      }
#line 1647
      anbin = tmp___7;
    }
#line 1648
    Trybin = (bnxcenter - binOffst) / binWidth;
#line 1648
    if (Trybin < 0) {
#line 1648
      bnbin = 0;
    } else {
#line 1648
      if (Trybin > numBins) {
#line 1648
        tmp___8 = numBins;
      } else {
#line 1648
        tmp___8 = Trybin;
      }
#line 1648
      bnbin = tmp___8;
    }
#line 1649
    if ((unsigned int )cellaptr != (unsigned int )cellbptr) {
#line 1650
      remv_cell(cellaptr, Apost);
#line 1651
      remv_cell(cellbptr, Bpost);
#line 1652
      add_cell(& (*(*(binptr + bblock) + anbin))->cell, a);
#line 1653
      add_cell(& (*(*(binptr + ablock) + bnbin))->cell, b);
    } else {
#line 1655
      remv_cell(cellaptr, Apost);
#line 1656
      i = 1;
#line 1656
      while (i <= *cellaptr) {
#line 1657
        if (*(cellaptr + i) == b) {
#line 1658
          break;
        }
#line 1656
        i ++;
      }
#line 1661
      remv_cell(cellaptr, i);
#line 1662
      add_cell(& (*(*(binptr + ablock) + anbin))->cell, a);
#line 1663
      add_cell(& (*(*(binptr + ablock) + bnbin))->cell, b);
    }
#line 1665
    if (wire_chg < 0) {
#line 1666
      temp = (double )(- wire_chg);
#line 1667
      total_wire_chg += temp;
#line 1668
      sigma_wire_chg += (temp - mean_wire_chg) * (temp - mean_wire_chg);
#line 1670
      wire_chgs ++;
    }
#line 1672
    acellptr->cblock = (short )bblock;
#line 1673
    acellptr->cxcenter = anxcenter;
#line 1674
    acellptr->cycenter = bycenter;
#line 1675
    bcellptr->cblock = (short )ablock;
#line 1676
    bcellptr->cxcenter = bnxcenter;
#line 1677
    bcellptr->cycenter = aycenter;
#line 1678
    funccost = cost;
#line 1679
    binpenal = newbinpenal;
#line 1680
    rowpenal = newrowpenal;
#line 1681
    penalty = newpenal;
#line 1682
    if (ablock != bblock) {
#line 1683
      (*(barray + ablock))->oldsize = (*(barray + ablock))->newsize;
#line 1684
      (*(barray + bblock))->oldsize = (*(barray + bblock))->newsize;
    }
#line 1686
    return (1);
  } else {
#line 1688
    return (0);
  }
}
}
#line 1691 "D:/a/test/300.c"
int minxspan  ;
#line 1692 "D:/a/test/300.c"
double mean_width  ;
#line 1693 "D:/a/test/300.c"
int offset_limit  ;
#line 1694 "D:/a/test/300.c"
int blkleft  ;
#line 1694 "D:/a/test/300.c"
int blkrite  ;
#line 1695 "D:/a/test/300.c"
double table1[1024]  ;
#line 1695 "D:/a/test/300.c"
double table2[1024]  ;
#line 1695 "D:/a/test/300.c"
double table3[1024]  ;
#line 1696 "D:/a/test/300.c"
int moveable_cells  ;
#line 1700 "D:/a/test/300.c"
int *xfeeds_in_row  ;
#line 1701 "D:/a/test/300.c"
int est_fds  ;
#line 1702 "D:/a/test/300.c"
short **row_map  ;
#line 1703 "D:/a/test/300.c"
short num_calls  =    (short)0;
#line 1723 "D:/a/test/300.c"
static double avg_VW  ;
#line 1764
int controlf(void) ;
#line 1800
int Yacm_random(void) ;
#line 1827
int XPICK_INT(int l , int u , int c ) ;
#line 1869
int uc0(int a___0 , int newaor ) ;
#line 1864
int ucxx1(int bxcenter___0 , int bycenter___0 ) ;
#line 1873
int ucxxo1(int bxcenter___0 , int bycenter___0 , int newaor ) ;
#line 1934
int ucxxo2(int newaor , int newbor ) ;
#line 2005
int vert_statistics(void) ;
#line 2016
int rowcon(void) ;
#line 1705 "D:/a/test/300.c"
int uloop(void) 
{ CBOXPTR acellptr ;
  CBOXPTR bcellptr ;
  BBOXPTR ablckptr ;
  BBOXPTR bblckptr ;
  DBOXPTR dimptr ;
  int botblk ;
  int topblk ;
  int flips ;
  int rejects ;
  int axcenter___0 ;
  int bxcenter___0 ;
  int bycenter___0 ;
  int aorient ;
  int borient___0 ;
  int bleft___0 ;
  int bright___0 ;
  int blk___0 ;
  int pairflips ;
  int i ;
  int r ;
  int l ;
  int t ;
  int abin ;
  int bbin ;
  int firstTry ;
  int fds ;
  int net ;
  int cost ;
  double target_row_penalty ;
  double target_bin_penalty ;
  double temp ;
  double accept_deviation ;
  double fp_ratio ;
  double percent_error ;
  double factor ;
  double total_feed_length ;
  double target_feed_length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 1724
  attempts = 0;
#line 1725
  flips = 0;
#line 1726
  rejects = 0;
#line 1727
  pairflips = 0;
#line 1728
  earlyRej = 0;
#line 1729
  Rej_error = 0;
#line 1730
  potential_errors = 0;
#line 1731
  error_count = 0;
#line 1732
  if (iteration == 0) {
#line 1733
    P_limit = (int )(10.0 * mean_width);
  } else {
#line 1732
    if (resume_run == 1) {
#line 1733
      P_limit = (int )(10.0 * mean_width);
    } else {
#line 1735
      if (wire_chgs > 0) {
#line 1736
        mean_wire_chg = total_wire_chg / (double )wire_chgs;
#line 1737
        if (iteration > 1) {
#line 1738
          sigma_wire_chg = sqrt(sigma_wire_chg / (double )wire_chgs);
        } else {
#line 1740
          sigma_wire_chg = 3.0 * mean_wire_chg;
        }
      } else {
#line 1743
        mean_wire_chg = 0.0;
#line 1744
        sigma_wire_chg = 0.0;
      }
#line 1746
      P_limit = (int )((mean_wire_chg + 1.3 * sigma_wire_chg) + (double )2 / cost_scale_factor);
    }
  }
#line 1749
  sigma_wire_chg = 0.0;
#line 1750
  total_wire_chg = 0.0;
#line 1751
  wire_chgs = 0;
#line 1752
  windx = minxspan;
#line 1753
  attmax = (int )(((double )((int )(((double )iteration / 121.0) * (double )(2 * attprcel - attprcel / 2))) + (double )(attprcel / 2)) * (double )moveable_cells);
#line 1756
  if (tw_fast) {
#line 1757
    attmax /= tw_fast;
  }
#line 1759
  if (tw_slow) {
#line 1760
    attmax *= tw_slow;
  }
#line 1762
  fds = 0;
#line 1763
  if (iteration >= 4) {
#line 1764
    fds = controlf();
#line 1765
    if (iteration <= 105) {
#line 1766
      total_feed_length = (double )est_fds;
#line 1767
      target_feed_length = 0.7 * (double )implicit_feed_count - ((0.5 * (double )implicit_feed_count) / 105.0) * (double )iteration;
#line 1770
      if (implicit_feed_count > 0) {
#line 1771
        factor = (total_feed_length - target_feed_length) / (double )implicit_feed_count;
      } else {
#line 1774
        factor = 0.0;
      }
#line 1776
      cost = 0;
#line 1777
      net = 1;
#line 1777
      while (net <= numnets) {
#line 1778
        dimptr = *(netarray + net);
#line 1779
        if (dimptr->Vweight <= 1.0) {
#line 1780
          dimptr->Vweight *= 1.0 + factor;
#line 1781
          if (dimptr->Vweight < 0.5) {
#line 1782
            dimptr->Vweight = 0.5;
          } else {
#line 1783
            if (dimptr->Vweight > 1.0) {
#line 1784
              dimptr->Vweight = 1.0;
            }
          }
        }
#line 1787
        avg_VW += dimptr->Vweight;
#line 1788
        cost += (int )(dimptr->Hweight * (double )(dimptr->xmax - dimptr->xmin)) + (int )(dimptr->Vweight * (double )(dimptr->ymax - dimptr->ymin));
#line 1777
        net ++;
      }
#line 1793
      avg_VW /= (double )numnets;
#line 1794
      funccost = cost;
    }
  } else {
#line 1797
    avg_VW = 0.0;
  }
#line 1799
  while (attempts < attmax) {
#line 1800
    if (1 < numcells) {
#line 1800
      tmp = Yacm_random();
#line 1800
      a = tmp % ((numcells - 1) + 1) + 1;
    } else {
#line 1800
      a = 1;
    }
#line 1801
    acellptr = *(carray + a);
#line 1802
    if ((int )acellptr->cclass == -1) {
#line 1803
      continue;
    }
#line 1805
    ablock = (int )acellptr->cblock;
#line 1806
    ablckptr = *(barray + ablock);
#line 1807
    axcenter___0 = acellptr->cxcenter;
#line 1808
    aorient = (int )acellptr->corient;
#line 1809
    Trybin = (axcenter___0 - binOffst) / binWidth;
#line 1809
    if (Trybin < 0) {
#line 1809
      abin = 0;
    } else {
#line 1809
      if (Trybin > numBins) {
#line 1809
        tmp___0 = numBins;
      } else {
#line 1809
        tmp___0 = Trybin;
      }
#line 1809
      abin = tmp___0;
    }
#line 1810
    cellaptr = (*(*(binptr + ablock) + abin))->cell;
#line 1811
    i = 1;
#line 1811
    while (i <= *cellaptr) {
#line 1812
      if (*(cellaptr + i) == a) {
#line 1813
        Apost = i;
#line 1814
        break;
      }
#line 1811
      i ++;
    }
#line 1817
    bblock = 0;
#line 1818
    firstTry = 0;
#line 1819
    botblk = ablock - 1;
#line 1819
    if (botblk < 1) {
#line 1820
      botblk = 1;
    }
#line 1822
    topblk = ablock + 1;
#line 1822
    if (topblk > numblock) {
#line 1823
      topblk = numblock;
    }
#line 1825
    i = 1;
#line 1825
    while (1) {
#line 1826
      while (1) {
#line 1827
        blk___0 = XPICK_INT(botblk, topblk, firstTry);
#line 1828
        bblckptr = *(barray + blk___0);
#line 1826
        if (! ((int )ablckptr->bclass != (int )bblckptr->bclass)) {
#line 1826
          break;
        }
      }
#line 1831
      bleft___0 = bblckptr->bxcenter + (int )bblckptr->bleft;
#line 1832
      bright___0 = bblckptr->bxcenter + (int )bblckptr->bright;
#line 1833
      if (bleft___0 >= axcenter___0 - windx) {
#line 1833
        l = bleft___0;
      } else {
#line 1833
        l = axcenter___0 - windx;
      }
#line 1834
      if (bright___0 <= axcenter___0 + windx) {
#line 1834
        r = bright___0;
      } else {
#line 1834
        r = axcenter___0 + windx;
      }
#line 1835
      if (l > r) {
#line 1836
        if (i == 1) {
#line 1837
          firstTry = blk___0;
          goto __Cont;
        } else {
#line 1839
          if (i == 3) {
#line 1840
            if (r < bleft___0) {
#line 1841
              r = bleft___0;
#line 1841
              l = r;
            } else {
#line 1843
              r = bright___0;
#line 1843
              l = r;
            }
          } else {
#line 1846
            firstTry = - ablock;
            goto __Cont;
          }
        }
      }
#line 1850
      bblock = blk___0;
#line 1851
      bycenter___0 = bblckptr->bycenter;
#line 1852
      if (bblock == ablock) {
#line 1853
        bxcenter___0 = XPICK_INT(l, r, axcenter___0);
      } else {
#line 1855
        bxcenter___0 = XPICK_INT(l, r, 0);
      }
#line 1857
      break;
      __Cont: /* CIL Label */ 
#line 1825
      i ++;
    }
#line 1859
    Trybin = (bxcenter___0 - binOffst) / binWidth;
#line 1859
    if (Trybin < 0) {
#line 1859
      bbin = 0;
    } else {
#line 1859
      if (Trybin > numBins) {
#line 1859
        tmp___1 = numBins;
      } else {
#line 1859
        tmp___1 = Trybin;
      }
#line 1859
      bbin = tmp___1;
    }
#line 1860
    cellbptr = (*(*(binptr + bblock) + bbin))->cell;
#line 1861
    if (*cellbptr == 0) {
#line 1862
      if ((int )ablckptr->borient == 1) {
#line 1863
        if ((int )bblckptr->borient == 1) {
#line 1864
          tmp___3 = ucxx1(bxcenter___0, bycenter___0);
#line 1864
          if (tmp___3) {
#line 1865
            flips ++;
          } else {
#line 1867
            rejects ++;
#line 1868
            if (rejects % 6 == 0) {
#line 1868
              if ((int )acellptr->orflag != 0) {
#line 1869
                if (aorient == 0) {
#line 1869
                  tmp___2 = 2;
                } else {
#line 1869
                  tmp___2 = 0;
                }
#line 1869
                uc0(a, tmp___2);
              }
            }
          }
        } else {
#line 1873
          if (aorient == 0) {
#line 1873
            tmp___5 = 1;
          } else {
#line 1873
            tmp___5 = 3;
          }
#line 1873
          tmp___6 = ucxxo1(bxcenter___0, bycenter___0, tmp___5);
#line 1873
          if (tmp___6) {
#line 1874
            flips ++;
          } else {
#line 1876
            rejects ++;
#line 1877
            if (rejects % 6 == 0) {
#line 1877
              if ((int )acellptr->orflag != 0) {
#line 1878
                if (aorient == 0) {
#line 1878
                  tmp___4 = 2;
                } else {
#line 1878
                  tmp___4 = 0;
                }
#line 1878
                uc0(a, tmp___4);
              }
            }
          }
        }
      } else {
#line 1883
        if ((int )bblckptr->borient == 1) {
#line 1884
          if (aorient == 1) {
#line 1884
            tmp___8 = 0;
          } else {
#line 1884
            tmp___8 = 2;
          }
#line 1884
          tmp___9 = ucxxo1(bxcenter___0, bycenter___0, tmp___8);
#line 1884
          if (tmp___9) {
#line 1886
            flips ++;
          } else {
#line 1888
            rejects ++;
#line 1889
            if (rejects % 6 == 0) {
#line 1889
              if ((int )acellptr->orflag != 0) {
#line 1890
                if (aorient == 1) {
#line 1890
                  tmp___7 = 3;
                } else {
#line 1890
                  tmp___7 = 1;
                }
#line 1890
                uc0(a, tmp___7);
              }
            }
          }
        } else {
#line 1894
          tmp___11 = ucxx1(bxcenter___0, bycenter___0);
#line 1894
          if (tmp___11) {
#line 1895
            flips ++;
          } else {
#line 1897
            rejects ++;
#line 1898
            if (rejects % 6 == 0) {
#line 1898
              if ((int )acellptr->orflag != 0) {
#line 1899
                if (aorient == 1) {
#line 1899
                  tmp___10 = 3;
                } else {
#line 1899
                  tmp___10 = 1;
                }
#line 1899
                uc0(a, tmp___10);
              }
            }
          }
        }
      }
    } else {
#line 1905
      if (1 < *cellbptr) {
#line 1905
        tmp___12 = Yacm_random();
#line 1905
        Bpost = tmp___12 % ((*cellbptr - 1) + 1) + 1;
      } else {
#line 1905
        Bpost = 1;
      }
#line 1906
      b = *(cellbptr + Bpost);
#line 1907
      bcellptr = *(carray + b);
#line 1908
      bblock = (int )bcellptr->cblock;
#line 1909
      bblckptr = *(barray + bblock);
#line 1910
      if ((int )acellptr->cclass != (int )bcellptr->cclass) {
#line 1911
        continue;
      } else {
#line 1910
        if (a == b) {
#line 1911
          continue;
        }
      }
#line 1914
      borient___0 = (int )bcellptr->corient;
#line 1915
      if ((int )ablckptr->borient == 1) {
#line 1916
        if ((int )bblckptr->borient == 1) {
#line 1917
          t = ucxx2();
#line 1918
          if (t == -1) {
#line 1919
            rejects ++;
#line 1920
            if (rejects % 6 == 0) {
#line 1920
              if ((int )acellptr->orflag != 0) {
#line 1921
                if (aorient == 0) {
#line 1921
                  tmp___13 = 2;
                } else {
#line 1921
                  tmp___13 = 0;
                }
#line 1921
                uc0(a, tmp___13);
              }
            }
#line 1923
            attempts ++;
#line 1924
            continue;
          } else {
#line 1925
            if (t == 1) {
#line 1926
              pairflips ++;
            } else {
#line 1928
              rejects ++;
#line 1929
              if (rejects % 6 == 0) {
#line 1929
                if ((int )acellptr->orflag != 0) {
#line 1930
                  if (aorient == 0) {
#line 1930
                    tmp___14 = 2;
                  } else {
#line 1930
                    tmp___14 = 0;
                  }
#line 1930
                  uc0(a, tmp___14);
                }
              }
            }
          }
        } else {
#line 1934
          if (borient___0 == 1) {
#line 1934
            tmp___15 = 0;
          } else {
#line 1934
            tmp___15 = 2;
          }
#line 1934
          if (aorient == 0) {
#line 1934
            tmp___16 = 1;
          } else {
#line 1934
            tmp___16 = 3;
          }
#line 1934
          t = ucxxo2(tmp___16, tmp___15);
#line 1936
          if (t == -1) {
#line 1937
            rejects ++;
#line 1938
            if (rejects % 6 == 0) {
#line 1938
              if ((int )acellptr->orflag != 0) {
#line 1939
                if (aorient == 0) {
#line 1939
                  tmp___17 = 2;
                } else {
#line 1939
                  tmp___17 = 0;
                }
#line 1939
                uc0(a, tmp___17);
              }
            }
#line 1941
            attempts ++;
#line 1942
            continue;
          } else {
#line 1943
            if (t == 1) {
#line 1944
              pairflips ++;
            } else {
#line 1946
              rejects ++;
#line 1947
              if (rejects % 6 == 0) {
#line 1947
                if ((int )acellptr->orflag != 0) {
#line 1948
                  if (aorient == 0) {
#line 1948
                    tmp___18 = 2;
                  } else {
#line 1948
                    tmp___18 = 0;
                  }
#line 1948
                  uc0(a, tmp___18);
                }
              }
            }
          }
        }
      } else {
#line 1953
        if ((int )bblckptr->borient == 1) {
#line 1954
          if (borient___0 == 0) {
#line 1954
            tmp___19 = 1;
          } else {
#line 1954
            tmp___19 = 3;
          }
#line 1954
          if (aorient == 1) {
#line 1954
            tmp___20 = 0;
          } else {
#line 1954
            tmp___20 = 2;
          }
#line 1954
          t = ucxxo2(tmp___20, tmp___19);
#line 1956
          if (t == -1) {
#line 1957
            rejects ++;
#line 1958
            if (rejects % 6 == 0) {
#line 1958
              if ((int )acellptr->orflag != 0) {
#line 1959
                if (aorient == 1) {
#line 1959
                  tmp___21 = 3;
                } else {
#line 1959
                  tmp___21 = 1;
                }
#line 1959
                uc0(a, tmp___21);
              }
            }
#line 1961
            attempts ++;
#line 1962
            continue;
          } else {
#line 1963
            if (t == 1) {
#line 1964
              pairflips ++;
            } else {
#line 1966
              rejects ++;
#line 1967
              if (rejects % 6 == 0) {
#line 1967
                if ((int )acellptr->orflag != 0) {
#line 1968
                  if (aorient == 1) {
#line 1968
                    tmp___22 = 3;
                  } else {
#line 1968
                    tmp___22 = 1;
                  }
#line 1968
                  uc0(a, tmp___22);
                }
              }
            }
          }
        } else {
#line 1972
          t = ucxx2();
#line 1973
          if (t == -1) {
#line 1974
            rejects ++;
#line 1975
            if (rejects % 6 == 0) {
#line 1975
              if ((int )acellptr->orflag != 0) {
#line 1976
                if (aorient == 1) {
#line 1976
                  tmp___23 = 3;
                } else {
#line 1976
                  tmp___23 = 1;
                }
#line 1976
                uc0(a, tmp___23);
              }
            }
#line 1978
            attempts ++;
#line 1979
            continue;
          } else {
#line 1980
            if (t == 1) {
#line 1981
              pairflips ++;
            } else {
#line 1983
              rejects ++;
#line 1984
              if (rejects % 6 == 0) {
#line 1984
                if ((int )acellptr->orflag != 0) {
#line 1985
                  if (aorient == 1) {
#line 1985
                    tmp___24 = 3;
                  } else {
#line 1985
                    tmp___24 = 1;
                  }
#line 1985
                  uc0(a, tmp___24);
                }
              }
            }
          }
        }
      }
    }
#line 1991
    attempts ++;
  }
#line 1993
  if (potential_errors > 0) {
#line 1994
    percent_error = (double )error_count / (double )potential_errors;
  } else {
#line 1996
    percent_error = 0.0;
  }
#line 1998
  percent_error *= 100.0;
#line 1999
  temp = (100.0 * (double )(pairflips + flips)) / (double )attmax;
#line 2000
  if ((double )pairflips > 0.0001) {
#line 2001
    fp_ratio = (100.0 * (double )flips) / (double )pairflips;
  } else {
#line 2003
    fp_ratio = 100.0;
  }
#line 2005
  vert_statistics();
#line 2006
  fprintf(fpo, "%3d %3d %4d %8d %7d %5d %4.1f %4.1f %4.1f %4.1f %4.1f", iteration + 1,
          2, fds, funccost, penalty, P_limit, percent_error, binpenCon, roLenCon,
          temp, fp_ratio);
#line 2009
  if (tot_missing_rows >= 0) {
#line 2009
    tmp___25 = tot_missing_rows;
  } else {
#line 2009
    tmp___25 = - tot_missing_rows;
  }
#line 2009
  fprintf(fpo, " %4.1f %5d %6d\n", (100.0 * (double )earlyRej) / (double )attmax,
          tot_num_feeds, tmp___25);
#line 2011
  fflush(fpo);
#line 2012
  if (iteration < 1) {
    goto _L;
  } else {
#line 2012
    if (resume_run == 1) {
      _L: /* CIL Label */ 
#line 2013
      if (iteration < 1) {
#line 2014
        cost_scale_factor = 1.0;
      }
#line 2016
      rowcon();
#line 2017
      resume_run = 0;
    } else {
#line 2018
      if (iteration < 100) {
#line 2019
        accept_deviation = (temp - *(desired_accept + iteration)) / 40.0;
#line 2020
        cost_scale_factor *= 1.0 + accept_deviation;
      }
    }
  }
#line 2022
  if (iteration <= 104) {
#line 2023
    target_bin_penalty = (1.40 - (1.15 / 105.0) * ((double )iteration + 1.0)) * (double )totalR;
#line 2025
    binpenCon += ((double )binpenal - target_bin_penalty) / (double )totalR;
#line 2027
    if (binpenCon > 0.5) {
#line 2027
      binpenCon = binpenCon;
    } else {
#line 2027
      binpenCon = 0.5;
    }
#line 2028
    target_row_penalty = (initialRowControl - ((initialRowControl - finalRowControl) / 105.0) * ((double )iteration + 1.0)) * (double )totalR;
#line 2031
    roLenCon += ((double )rowpenal - target_row_penalty) / target_row_penalty;
#line 2034
    if (roLenCon > 0.5) {
#line 2034
      roLenCon = roLenCon;
    } else {
#line 2034
      roLenCon = 0.5;
    }
#line 2035
    penalty = (int )(binpenCon * (double )binpenal + roLenCon * (double )rowpenal);
  }
#line 2038
  return 0;
}
}
#line 2043 "D:/a/test/300.c"
int check_cost(void) 
{ DBOXPTR dimptr ;
  NBOXPTR netptr ;
  int old_mean ;
  int oldx ;
  int net ;
  int initial_cost ;
  int total ;
  int tmp ;

  {
#line 2049
  initial_cost = 0;
#line 2050
  net = 1;
#line 2050
  while (net <= numnets) {
#line 2051
    dimptr = *(netarray + net);
#line 2052
    total = 0;
#line 2053
    netptr = dimptr->netptr;
#line 2053
    while (netptr) {
#line 2054
      total += netptr->xpos;
#line 2053
      netptr = netptr->nterm;
    }
#line 2056
    old_mean = total / (int )dimptr->numpins;
#line 2057
    netptr = dimptr->netptr;
#line 2057
    while (netptr) {
#line 2058
      oldx = netptr->xpos;
#line 2059
      if (oldx - old_mean >= 0) {
#line 2059
        tmp = oldx - old_mean;
      } else {
#line 2059
        tmp = - (oldx - old_mean);
      }
#line 2059
      initial_cost += tmp;
#line 2057
      netptr = netptr->nterm;
    }
#line 2050
    net ++;
  }
#line 2062
  return (initial_cost);
}
}
#line 2064 "D:/a/test/300.c"
int initialize_cost(void) 
{ DBOXPTR dimptr ;
  NBOXPTR netptr ;
  int old_mean ;
  int oldx ;
  int net ;
  int initial_cost ;
  int tmp ;

  {
#line 2070
  initial_cost = 0;
#line 2071
  net = 1;
#line 2071
  while (net <= numnets) {
#line 2072
    dimptr = *(netarray + net);
#line 2073
    dimptr->old_total = 0;
#line 2074
    netptr = dimptr->netptr;
#line 2074
    while (netptr) {
#line 2075
      dimptr->old_total += netptr->xpos;
#line 2074
      netptr = netptr->nterm;
    }
#line 2077
    old_mean = dimptr->old_total / (int )dimptr->numpins;
#line 2078
    netptr = dimptr->netptr;
#line 2078
    while (netptr) {
#line 2079
      oldx = netptr->xpos;
#line 2080
      if (oldx - old_mean >= 0) {
#line 2080
        tmp = oldx - old_mean;
      } else {
#line 2080
        tmp = - (oldx - old_mean);
      }
#line 2080
      initial_cost += tmp;
#line 2078
      netptr = netptr->nterm;
    }
#line 2071
    net ++;
  }
#line 2083
  return (initial_cost);
}
}
#line 2085 "D:/a/test/300.c"
int new_dbox(TEBOXPTR antrmptr , int *costptr ) 
{ NBOXPTR netptr ;
  DBOXPTR dimptr ;
  TEBOXPTR termptr ;
  int old_mean ;
  int new_mean ;
  int oldx ;
  int newx ;
  int tmp ;
  int tmp___0 ;

  {
#line 2093
  termptr = antrmptr;
#line 2093
  while (termptr) {
#line 2094
    dimptr = *(netarray + termptr->net);
#line 2095
    if ((int )dimptr->dflag == 0) {
      goto __Cont;
    }
#line 2098
    dimptr->dflag = (char)0;
#line 2099
    new_mean = dimptr->new_total / (int )dimptr->numpins;
#line 2100
    old_mean = dimptr->old_total / (int )dimptr->numpins;
#line 2101
    netptr = dimptr->netptr;
#line 2101
    while (netptr) {
#line 2102
      oldx = netptr->xpos;
#line 2103
      if ((int )netptr->flag == 1) {
#line 2104
        newx = netptr->newx;
#line 2105
        netptr->flag = (char)0;
      } else {
#line 2107
        newx = oldx;
      }
#line 2109
      if (newx - new_mean >= 0) {
#line 2109
        tmp = newx - new_mean;
      } else {
#line 2109
        tmp = - (newx - new_mean);
      }
#line 2109
      if (oldx - old_mean >= 0) {
#line 2109
        tmp___0 = oldx - old_mean;
      } else {
#line 2109
        tmp___0 = - (oldx - old_mean);
      }
#line 2109
      *costptr += tmp - tmp___0;
#line 2101
      netptr = netptr->nterm;
    }
    __Cont: /* CIL Label */ 
#line 2093
    termptr = termptr->nextterm;
  }
#line 2112
  return 0;
}
}
#line 2114 "D:/a/test/300.c"
int new_dbox_a(TEBOXPTR antrmptr , int *costptr ) 
{ DBOXPTR dimptr ;
  NBOXPTR netptr ;
  TEBOXPTR termptr ;
  int old_mean ;
  int new_mean ;
  int oldx ;
  int newx ;
  int f ;
  int m ;
  int min ;
  int max ;
  int row___0 ;
  int net ;
  char *rowsptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 2124
  termptr = antrmptr;
#line 2124
  while (termptr) {
#line 2125
    net = (int )termptr->net;
#line 2126
    dimptr = *(netarray + net);
#line 2127
    if ((int )dimptr->dflag == 0) {
      goto __Cont;
    }
#line 2130
    dimptr->dflag = (char)0;
#line 2131
    new_mean = dimptr->new_total / (int )dimptr->numpins;
#line 2132
    old_mean = dimptr->old_total / (int )dimptr->numpins;
#line 2133
    netptr = dimptr->netptr;
#line 2133
    while (netptr) {
#line 2134
      oldx = netptr->xpos;
#line 2135
      if ((int )netptr->flag == 1) {
#line 2136
        newx = netptr->newx;
#line 2137
        netptr->flag = (char)0;
      } else {
#line 2139
        newx = oldx;
      }
#line 2141
      if (newx - new_mean >= 0) {
#line 2141
        tmp = newx - new_mean;
      } else {
#line 2141
        tmp = - (newx - new_mean);
      }
#line 2141
      if (oldx - old_mean >= 0) {
#line 2141
        tmp___0 = oldx - old_mean;
      } else {
#line 2141
        tmp___0 = - (oldx - old_mean);
      }
#line 2141
      *costptr += tmp - tmp___0;
#line 2133
      netptr = netptr->nterm;
    }
#line 2143
    f = 0;
#line 2144
    m = 0;
#line 2145
    rowsptr = *(tmp_rows + net);
#line 2146
    row___0 = 0;
#line 2146
    while ((int )*(rowsptr + row___0) == 0) {
#line 2146
      row___0 ++;
    }
#line 2147
    min = row___0;
#line 2148
    row___0 = numRows + 1;
#line 2148
    while ((int )*(rowsptr + row___0) == 0) {
#line 2148
      row___0 --;
    }
#line 2149
    max = row___0;
#line 2150
    row___0 = min;
#line 2150
    while (row___0 <= max) {
#line 2151
      if ((int )*(rowsptr + row___0) == 0) {
#line 2152
        f ++;
      } else {
#line 2154
        m ++;
      }
#line 2150
      row___0 ++;
    }
#line 2157
    *(tmp_num_feeds + net) = f;
#line 2158
    if (min < max) {
#line 2159
      m += 2;
    } else {
#line 2160
      if (min == max) {
#line 2161
        m ++;
      } else {
#line 2163
        m = 0;
      }
    }
#line 2165
    *(tmp_missing_rows + net) = - m;
#line 2166
    delta_vert_cost += (((*(tmp_num_feeds + net) - *(num_feeds + net)) + (*(tmp_missing_rows + net) - *(missing_rows + net))) * 2) * rowHeight;
    __Cont: /* CIL Label */ 
#line 2124
    termptr = termptr->nextterm;
  }
#line 2170
  return 0;
}
}
#line 2172 "D:/a/test/300.c"
int term_newpos(TEBOXPTR antrmptr , int xcenter , int ycenter , int newaor ) 
{ TEBOXPTR termptr ;
  NBOXPTR ttermptr ;
  DBOXPTR dimptr ;

  {
#line 2179
  termptr = antrmptr;
#line 2179
  while (termptr) {
#line 2180
    ttermptr = termptr->termptr;
#line 2181
    ttermptr->flag = (char)1;
#line 2182
    ttermptr->newx = (int )termptr->txpos[newaor / 2] + xcenter;
#line 2183
    dimptr = *(netarray + termptr->net);
#line 2184
    if ((int )dimptr->dflag == 0) {
#line 2185
      dimptr->dflag = (char)1;
#line 2186
      dimptr->new_total = (dimptr->old_total + ttermptr->newx) - ttermptr->xpos;
    } else {
#line 2189
      dimptr->new_total += ttermptr->newx - ttermptr->xpos;
    }
#line 2179
    termptr = termptr->nextterm;
  }
#line 2192
  return 0;
}
}
#line 2194 "D:/a/test/300.c"
int term_newpos_a(TEBOXPTR antrmptr , int xcenter , int ycenter , int newaor ) 
{ TEBOXPTR termptr ;
  NBOXPTR ttermptr ;
  DBOXPTR dimptr ;
  char *rowsptr1 ;
  char *rowsptr2 ;
  int net ;
  int row___0 ;

  {
#line 2203
  termptr = antrmptr;
#line 2203
  while (termptr) {
#line 2204
    ttermptr = termptr->termptr;
#line 2205
    ttermptr->flag = (char)1;
#line 2206
    ttermptr->newx = (int )termptr->txpos[newaor / 2] + xcenter;
#line 2207
    net = (int )termptr->net;
#line 2208
    dimptr = *(netarray + net);
#line 2209
    rowsptr2 = *(tmp_rows + net);
#line 2210
    if ((int )dimptr->dflag == 0) {
#line 2211
      dimptr->dflag = (char)1;
#line 2212
      rowsptr1 = *(rows + net);
#line 2213
      row___0 = 0;
#line 2213
      while (row___0 <= numRows + 1) {
#line 2214
        *(rowsptr2 + row___0) = *(rowsptr1 + row___0);
#line 2213
        row___0 ++;
      }
#line 2216
      *(rowsptr2 + ablock) = (char )((int )*(rowsptr2 + ablock) - 1);
#line 2217
      *(rowsptr2 + bblock) = (char )((int )*(rowsptr2 + bblock) + 1);
#line 2218
      dimptr->new_total = (dimptr->old_total + ttermptr->newx) - ttermptr->xpos;
    } else {
#line 2221
      *(rowsptr2 + ablock) = (char )((int )*(rowsptr2 + ablock) - 1);
#line 2222
      *(rowsptr2 + bblock) = (char )((int )*(rowsptr2 + bblock) + 1);
#line 2223
      dimptr->new_total += ttermptr->newx - ttermptr->xpos;
    }
#line 2203
    termptr = termptr->nextterm;
  }
#line 2226
  return 0;
}
}
#line 2228 "D:/a/test/300.c"
int term_newpos_b(TEBOXPTR antrmptr , int xcenter , int ycenter , int newaor ) 
{ TEBOXPTR termptr ;
  NBOXPTR ttermptr ;
  DBOXPTR dimptr ;
  char *rowsptr1 ;
  char *rowsptr2 ;
  int net ;
  int row___0 ;

  {
#line 2237
  termptr = antrmptr;
#line 2237
  while (termptr) {
#line 2238
    ttermptr = termptr->termptr;
#line 2239
    ttermptr->flag = (char)1;
#line 2240
    ttermptr->newx = (int )termptr->txpos[newaor / 2] + xcenter;
#line 2241
    net = (int )termptr->net;
#line 2242
    dimptr = *(netarray + net);
#line 2243
    rowsptr2 = *(tmp_rows + net);
#line 2244
    if ((int )dimptr->dflag == 0) {
#line 2245
      dimptr->dflag = (char)1;
#line 2246
      rowsptr1 = *(rows + net);
#line 2247
      row___0 = 0;
#line 2247
      while (row___0 <= numRows + 1) {
#line 2248
        *(rowsptr2 + row___0) = *(rowsptr1 + row___0);
#line 2247
        row___0 ++;
      }
#line 2250
      *(rowsptr2 + bblock) = (char )((int )*(rowsptr2 + bblock) - 1);
#line 2251
      *(rowsptr2 + ablock) = (char )((int )*(rowsptr2 + ablock) + 1);
#line 2252
      dimptr->new_total = (dimptr->old_total + ttermptr->newx) - ttermptr->xpos;
    } else {
#line 2255
      *(rowsptr2 + bblock) = (char )((int )*(rowsptr2 + bblock) - 1);
#line 2256
      *(rowsptr2 + ablock) = (char )((int )*(rowsptr2 + ablock) + 1);
#line 2257
      dimptr->new_total += ttermptr->newx - ttermptr->xpos;
    }
#line 2237
    termptr = termptr->nextterm;
  }
#line 2260
  return 0;
}
}
#line 2262 "D:/a/test/300.c"
int dbox_pos(TEBOXPTR antrmptr ) 
{ DBOXPTR dimptr ;
  TEBOXPTR termptr ;

  {
#line 2267
  termptr = antrmptr;
#line 2267
  while (termptr) {
#line 2268
    dimptr = *(netarray + termptr->net);
#line 2269
    dimptr->old_total = dimptr->new_total;
#line 2270
    (termptr->termptr)->xpos = (termptr->termptr)->newx;
#line 2267
    termptr = termptr->nextterm;
  }
#line 2272
  return 0;
}
}
#line 2274 "D:/a/test/300.c"
int dbox_pos_2(TEBOXPTR antrmptr ) 
{ DBOXPTR dimptr ;
  TEBOXPTR termptr ;
  int net ;
  int row___0 ;
  register char *rowsptr1 ;
  register char *rowsptr2 ;

  {
#line 2282
  termptr = antrmptr;
#line 2282
  while (termptr) {
#line 2283
    net = (int )termptr->net;
#line 2284
    dimptr = *(netarray + net);
#line 2285
    dimptr->old_total = dimptr->new_total;
#line 2286
    (termptr->termptr)->xpos = (termptr->termptr)->newx;
#line 2287
    *(missing_rows + net) = *(tmp_missing_rows + net);
#line 2288
    *(num_feeds + net) = *(tmp_num_feeds + net);
#line 2289
    rowsptr1 = *(rows + net);
#line 2290
    rowsptr2 = *(tmp_rows + net);
#line 2291
    row___0 = 0;
#line 2291
    while (row___0 <= numRows + 1) {
#line 2292
      *(rowsptr1 + row___0) = *(rowsptr2 + row___0);
#line 2291
      row___0 ++;
    }
#line 2282
    termptr = termptr->nextterm;
  }
#line 2295
  return 0;
}
}
#line 2297 "D:/a/test/300.c"
int initialize_rows(void) 
{ TEBOXPTR termptr ;
  int net ;
  int row___0 ;
  int cell___0 ;
  int min ;
  int max ;
  int f ;
  int m ;
  char *rowsptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2302
  tmp = (int )safe_malloc((unsigned int )(1 + numnets) * sizeof(int ));
#line 2302
  num_feeds = (int *)tmp;
#line 2303
  tmp___0 = (int )safe_malloc((unsigned int )(1 + numnets) * sizeof(int ));
#line 2303
  tmp_num_feeds = (int *)tmp___0;
#line 2304
  tmp___1 = (int )safe_malloc((unsigned int )(1 + numnets) * sizeof(int ));
#line 2304
  missing_rows = (int *)tmp___1;
#line 2305
  tmp___2 = (int )safe_malloc((unsigned int )(1 + numnets) * sizeof(int ));
#line 2305
  tmp_missing_rows = (int *)tmp___2;
#line 2306
  tmp___3 = (int )safe_malloc((unsigned int )(1 + numnets) * sizeof(char *));
#line 2306
  rows = (char **)tmp___3;
#line 2307
  tmp___4 = (int )safe_malloc((unsigned int )(1 + numnets) * sizeof(char *));
#line 2307
  tmp_rows = (char **)tmp___4;
#line 2308
  net = 1;
#line 2308
  while (net <= numnets) {
#line 2309
    tmp___5 = (int )safe_malloc((unsigned int )(2 + numRows) * sizeof(char ));
#line 2309
    *(rows + net) = (char *)tmp___5;
#line 2310
    tmp___6 = (int )safe_malloc((unsigned int )(2 + numRows) * sizeof(char ));
#line 2310
    *(tmp_rows + net) = (char *)tmp___6;
#line 2311
    row___0 = 0;
#line 2311
    while (row___0 <= numRows + 1) {
#line 2312
      *(*(rows + net) + row___0) = (char)0;
#line 2313
      *(*(tmp_rows + net) + row___0) = (char)0;
#line 2311
      row___0 ++;
    }
#line 2315
    *(missing_rows + net) = 0;
#line 2316
    *(tmp_missing_rows + net) = 0;
#line 2317
    *(num_feeds + net) = 0;
#line 2318
    *(tmp_num_feeds + net) = 0;
#line 2308
    net ++;
  }
#line 2320
  cell___0 = 1;
#line 2320
  while (cell___0 <= numcells + numterms) {
#line 2321
    if (cell___0 > numcells) {
#line 2322
      if ((int )(*(carray + cell___0))->padside != 2) {
#line 2322
        if ((int )(*(carray + cell___0))->padside != 4) {
#line 2322
          if ((int )(*(carray + cell___0))->padside != 14) {
#line 2322
            if ((int )(*(carray + cell___0))->padside != 15) {
              goto __Cont;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 2327
        if ((int )(*(carray + cell___0))->padside == 2) {
#line 2329
          row___0 = numRows + 1;
#line 2329
          (*(carray + cell___0))->cblock = (short )row___0;
        } else {
#line 2327
          if ((int )(*(carray + cell___0))->padside == 14) {
#line 2329
            row___0 = numRows + 1;
#line 2329
            (*(carray + cell___0))->cblock = (short )row___0;
          } else {
#line 2331
            row___0 = 0;
#line 2331
            (*(carray + cell___0))->cblock = (short )row___0;
          }
        }
      }
    } else {
#line 2334
      row___0 = (int )(*(carray + cell___0))->cblock;
    }
#line 2336
    termptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 2336
    while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 2338
      *(*(rows + termptr->net) + row___0) = (char )((int )*(*(rows + termptr->net) + row___0) + 1);
#line 2336
      termptr = termptr->nextterm;
    }
    __Cont: /* CIL Label */ 
#line 2320
    cell___0 ++;
  }
#line 2341
  net = 1;
#line 2341
  while (net <= numnets) {
#line 2342
    f = 0;
#line 2343
    m = 0;
#line 2344
    rowsptr = *(rows + net);
#line 2345
    row___0 = 0;
#line 2345
    while ((int )*(rowsptr + row___0) == 0) {
#line 2345
      row___0 ++;
    }
#line 2346
    min = row___0;
#line 2347
    row___0 = numRows + 1;
#line 2347
    while ((int )*(rowsptr + row___0) == 0) {
#line 2347
      row___0 --;
    }
#line 2348
    max = row___0;
#line 2349
    row___0 = min;
#line 2349
    while (row___0 <= max) {
#line 2350
      if ((int )*(rowsptr + row___0) == 0) {
#line 2351
        f ++;
      } else {
#line 2353
        m ++;
      }
#line 2349
      row___0 ++;
    }
#line 2356
    *(num_feeds + net) = f;
#line 2357
    if (min < max) {
#line 2358
      m += 2;
    } else {
#line 2359
      if (min == max) {
#line 2360
        m ++;
      } else {
#line 2362
        m = 0;
      }
    }
#line 2364
    *(missing_rows + net) = - m;
#line 2341
    net ++;
  }
#line 2366
  return 0;
}
}
#line 2431
int safe_free(char *ptr ) ;
#line 2368 "D:/a/test/300.c"
int check_row_values(void) 
{ TEBOXPTR termptr ;
  int net ;
  int row___0 ;
  int cell___0 ;
  int min ;
  int max ;
  int f ;
  int m ;
  int fds ;
  int mrs ;
  char *rowsptr ;
  char **check_rows ;
  int *check_feeds ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct _reent *tmp___2 ;

  {
#line 2374
  tmp = (int )safe_malloc((unsigned int )(1 + numnets) * sizeof(int ));
#line 2374
  check_feeds = (int *)tmp;
#line 2375
  tmp___0 = (int )safe_malloc((unsigned int )(1 + numnets) * sizeof(char *));
#line 2375
  check_rows = (char **)tmp___0;
#line 2376
  net = 1;
#line 2376
  while (net <= numnets) {
#line 2377
    tmp___1 = (int )safe_malloc((unsigned int )(2 + numRows) * sizeof(char ));
#line 2377
    *(check_rows + net) = (char *)tmp___1;
#line 2378
    row___0 = 0;
#line 2378
    while (row___0 <= numRows + 1) {
#line 2379
      *(*(check_rows + net) + row___0) = (char)0;
#line 2378
      row___0 ++;
    }
#line 2381
    *(check_feeds + net) = 0;
#line 2376
    net ++;
  }
#line 2383
  cell___0 = 1;
#line 2383
  while (cell___0 <= numcells + numterms) {
#line 2384
    if (cell___0 > numcells) {
#line 2385
      if ((int )(*(carray + cell___0))->padside != 2) {
#line 2385
        if ((int )(*(carray + cell___0))->padside != 4) {
#line 2385
          if ((int )(*(carray + cell___0))->padside != 14) {
#line 2385
            if ((int )(*(carray + cell___0))->padside != 15) {
              goto __Cont;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 2390
        if ((int )(*(carray + cell___0))->padside == 2) {
#line 2392
          row___0 = numRows + 1;
#line 2392
          (*(carray + cell___0))->cblock = (short )row___0;
        } else {
#line 2390
          if ((int )(*(carray + cell___0))->padside == 14) {
#line 2392
            row___0 = numRows + 1;
#line 2392
            (*(carray + cell___0))->cblock = (short )row___0;
          } else {
#line 2394
            row___0 = 0;
#line 2394
            (*(carray + cell___0))->cblock = (short )row___0;
          }
        }
      }
    } else {
#line 2397
      row___0 = (int )(*(carray + cell___0))->cblock;
    }
#line 2399
    termptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 2399
    while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 2401
      *(*(check_rows + termptr->net) + row___0) = (char )((int )*(*(check_rows + termptr->net) + row___0) + 1);
#line 2399
      termptr = termptr->nextterm;
    }
    __Cont: /* CIL Label */ 
#line 2383
    cell___0 ++;
  }
#line 2404
  fds = 0;
#line 2405
  mrs = 0;
#line 2406
  net = 1;
#line 2406
  while (net <= numnets) {
#line 2407
    f = 0;
#line 2408
    m = 0;
#line 2409
    rowsptr = *(check_rows + net);
#line 2410
    row___0 = 0;
#line 2410
    while ((int )*(rowsptr + row___0) == 0) {
#line 2410
      row___0 ++;
    }
#line 2411
    min = row___0;
#line 2412
    row___0 = numRows + 1;
#line 2412
    while ((int )*(rowsptr + row___0) == 0) {
#line 2412
      row___0 --;
    }
#line 2413
    max = row___0;
#line 2414
    row___0 = min;
#line 2414
    while (row___0 <= max) {
#line 2415
      if ((int )*(rowsptr + row___0) == 0) {
#line 2416
        f ++;
      } else {
#line 2418
        m ++;
      }
#line 2414
      row___0 ++;
    }
#line 2421
    fds += f;
#line 2422
    if (min < max) {
#line 2423
      m += 2;
    } else {
#line 2424
      if (min == max) {
#line 2425
        m ++;
      } else {
#line 2427
        m = 0;
      }
    }
#line 2429
    mrs -= m;
#line 2406
    net ++;
  }
#line 2431
  safe_free(check_feeds);
#line 2432
  net = 1;
#line 2432
  while (net <= numnets) {
#line 2433
    safe_free(*(check_rows + net));
#line 2432
    net ++;
  }
#line 2435
  safe_free(check_rows);
#line 2436
  fprintf(fpo, "FEEDS:%d     MRs:%d\n", fds, mrs);
#line 2437
  printf("FEEDS:%d     MRs:%d\n", fds, mrs);
#line 2438
  tmp___2 = __getreent();
#line 2438
  fflush(tmp___2->_stdout);
#line 2439
  fflush(fpo);
#line 2440
  return 0;
}
}
#line 2442 "D:/a/test/300.c"
int vert_statistics(void) 
{ int net ;

  {
#line 2445
  tot_missing_rows = 0;
#line 2446
  tot_num_feeds = 0;
#line 2447
  net = 1;
#line 2447
  while (net <= numnets) {
#line 2448
    tot_missing_rows += *(missing_rows + net);
#line 2449
    tot_num_feeds += *(num_feeds + net);
#line 2447
    net ++;
  }
#line 2451
  return 0;
}
}
#line 2467 "D:/a/test/300.c"
int acceptt(int delta_cost ) 
{ int truth ;
  double fred ;
  register unsigned int fract ;
  int tmp ;
  int tmp___0 ;

  {
#line 2473
  fred = ((double )delta_cost * cost_scale_factor) / (double )2;
#line 2474
  if (fred >= 0.0) {
#line 2475
    truth = 1;
  } else {
#line 2476
    if (fred < - 80.0) {
#line 2477
      truth = 0;
    } else {
#line 2478
      if (fred > - 0.0001) {
#line 2479
        tmp = Yacm_random();
#line 2479
        if (1.0 + fred > (double )tmp / (double )2147483647) {
#line 2480
          truth = 1;
        } else {
#line 2482
          truth = 0;
        }
      } else {
#line 2485
        fract = (unsigned int )((int )(- fred * 8388608.0));
#line 2486
        tmp___0 = Yacm_random();
#line 2486
        if ((table1[(fract >> 20) & 1023U] * table2[(fract >> 10) & 1023U]) * table3[fract & 1023U] > (double )tmp___0 / (double )2147483647) {
#line 2490
          truth = 1;
        } else {
#line 2492
          truth = 0;
        }
      }
    }
  }
#line 2495
  return (truth);
}
}
#line 2497 "D:/a/test/300.c"
int *act_feeds_in_row  ;
#line 2498 "D:/a/test/300.c"
int pad_line  ;
#line 2499 "D:/a/test/300.c"
int last_feed  ;
#line 2503 "D:/a/test/300.c"
int *feed_location  ;
#line 2520 "D:/a/test/300.c"
IBOXPTR siptr  ;
#line 2521 "D:/a/test/300.c"
IBOXPTR *impFeeds  ;
#line 2523 "D:/a/test/300.c"
int *top_row_for_this_net  ;
#line 2524 "D:/a/test/300.c"
int *bot_row_for_this_net  ;
#line 2527 "D:/a/test/300.c"
char **pinnames  ;
#line 2531 "D:/a/test/300.c"
int addimp(int row___0 , int net ) 
{ CBOXPTR ptr ;
  TEBOXPTR termptr ;
  IPBOXPTR ipptr ;
  IPBOXPTR tipptr ;
  IPBOXPTR bipptr ;
  NBOXPTR nptr ;
  NBOXPTR n1ptr ;
  NBOXPTR n2ptr ;
  int pin ;
  int orient ;
  int realcell ;
  struct termbox *tmp ;
  int tmp___0 ;
  TEBOXPTR tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct netbox *tmp___10 ;
  int tmp___11 ;
  struct netbox *tmp___12 ;
  int tmp___13 ;

  {
#line 2539
  realcell = siptr->icell;
#line 2540
  ptr = *(carray + realcell);
#line 2541
  ptr->numterms = (short )((int )ptr->numterms + 2);
#line 2542
  ipptr = siptr->iptr;
#line 2542
  while (! (ipptr->iypos > 0)) {
#line 2542
    ipptr = ipptr->npin;
  }
#line 2547
  tipptr = ipptr;
#line 2548
  ipptr = siptr->iptr;
#line 2548
  while (! (ipptr->iypos < 0)) {
#line 2548
    ipptr = ipptr->npin;
  }
#line 2553
  bipptr = ipptr;
#line 2554
  termptr = (ptr->tileptr)->termsptr;
#line 2555
  if ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 2556
    while ((unsigned int )termptr->nextterm != (unsigned int )((struct termbox *)((void *)0))) {
#line 2557
      termptr = termptr->nextterm;
    }
#line 2559
    tmp___0 = (int )safe_malloc(sizeof(TEBOX ));
#line 2559
    tmp = (struct termbox *)tmp___0;
#line 2559
    termptr->nextterm = tmp;
#line 2559
    termptr = tmp;
  } else {
#line 2561
    tmp___2 = (int )safe_malloc(sizeof(TEBOX ));
#line 2561
    tmp___1 = (struct termbox *)tmp___2;
#line 2561
    (ptr->tileptr)->termsptr = tmp___1;
#line 2561
    termptr = tmp___1;
  }
#line 2564
  maxterm ++;
#line 2564
  termptr->cellterm = maxterm;
#line 2565
  tmp___3 = strlen((char const   *)tipptr->ipname);
#line 2565
  tmp___4 = (int )safe_malloc((tmp___3 + 1U) * sizeof(char ));
#line 2565
  *(pinnames + maxterm) = (char *)tmp___4;
#line 2567
  sprintf(*(pinnames + maxterm), "%s", tipptr->ipname);
#line 2568
  termptr->ei = maxterm;
#line 2569
  termptr->ue = (short)0;
#line 2570
  tmp___5 = (int )safe_malloc(sizeof(NBOX ));
#line 2570
  *(tearray + maxterm) = (struct netbox *)tmp___5;
#line 2571
  tmp___6 = (int )safe_malloc(sizeof(TEBOX ));
#line 2571
  termptr->nextterm = (struct termbox *)tmp___6;
#line 2572
  (termptr->nextterm)->nextterm = (struct termbox *)((void *)0);
#line 2573
  (termptr->nextterm)->ei = maxterm;
#line 2574
  (termptr->nextterm)->ue = (short)0;
#line 2575
  maxterm ++;
#line 2575
  (termptr->nextterm)->cellterm = maxterm;
#line 2576
  tmp___7 = strlen((char const   *)bipptr->ipname);
#line 2576
  tmp___8 = (int )safe_malloc((tmp___7 + 1U) * sizeof(char ));
#line 2576
  *(pinnames + maxterm) = (char *)tmp___8;
#line 2578
  sprintf(*(pinnames + maxterm), "%s", bipptr->ipname);
#line 2579
  tmp___9 = (int )safe_malloc(sizeof(NBOX ));
#line 2579
  *(tearray + maxterm) = (struct netbox *)tmp___9;
#line 2580
  termptr->txpos[0] = (short )tipptr->ixpos;
#line 2581
  termptr->typos[0] = (short )tipptr->iypos;
#line 2582
  termptr->txpos[1] = (short )(- ((int )termptr->txpos[0]));
#line 2583
  termptr->typos[1] = (short )(- ((int )termptr->typos[0]));
#line 2584
  if ((int )ptr->clength % 2 != 0) {
#line 2585
    termptr->txpos[1] = (short )((int )termptr->txpos[1] + 1);
  }
#line 2587
  if ((int )ptr->cheight % 2 != 0) {
#line 2588
    termptr->typos[1] = (short )((int )termptr->typos[1] + 1);
  }
#line 2590
  pin = termptr->cellterm;
#line 2591
  nptr = (*(netarray + net))->netptr;
#line 2592
  while ((unsigned int )nptr->nterm != (unsigned int )((struct netbox *)((void *)0))) {
#line 2592
    nptr = nptr->nterm;
  }
#line 2593
  tmp___11 = (int )safe_malloc(sizeof(NBOX ));
#line 2593
  tmp___10 = (struct netbox *)tmp___11;
#line 2593
  nptr->nterm = tmp___10;
#line 2593
  nptr = tmp___10;
#line 2594
  *(tearray + pin) = nptr;
#line 2595
  nptr->terminal = pin;
#line 2596
  nptr->flag = (char)0;
#line 2597
  nptr->row = (short )row___0;
#line 2598
  nptr->cell = (short )realcell;
#line 2599
  nptr->net = (short )net;
#line 2600
  nptr->extint = termptr->ei;
#line 2601
  nptr->unequiv = (char )termptr->ue;
#line 2602
  nptr->layer = (char )tipptr->layer;
#line 2603
  n1ptr = nptr;
#line 2604
  termptr = termptr->nextterm;
#line 2605
  termptr->txpos[0] = (short )bipptr->ixpos;
#line 2606
  termptr->typos[0] = (short )bipptr->iypos;
#line 2607
  termptr->txpos[1] = (short )(- ((int )termptr->txpos[0]));
#line 2608
  termptr->typos[1] = (short )(- ((int )termptr->typos[0]));
#line 2609
  if ((int )ptr->clength % 2 != 0) {
#line 2610
    termptr->txpos[1] = (short )((int )termptr->txpos[1] + 1);
  }
#line 2612
  if ((int )ptr->cheight % 2 != 0) {
#line 2613
    termptr->typos[1] = (short )((int )termptr->typos[1] + 1);
  }
#line 2615
  pin = termptr->cellterm;
#line 2616
  tmp___13 = (int )safe_malloc(sizeof(NBOX ));
#line 2616
  tmp___12 = (struct netbox *)tmp___13;
#line 2616
  nptr->nterm = tmp___12;
#line 2616
  nptr = tmp___12;
#line 2617
  *(tearray + pin) = nptr;
#line 2618
  nptr->nterm = (struct netbox *)((void *)0);
#line 2619
  nptr->terminal = pin;
#line 2620
  nptr->flag = (char)0;
#line 2621
  nptr->row = (short )row___0;
#line 2622
  nptr->cell = (short )realcell;
#line 2623
  nptr->net = (short )net;
#line 2624
  nptr->extint = termptr->ei;
#line 2625
  nptr->unequiv = (char )termptr->ue;
#line 2626
  nptr->layer = (char )bipptr->layer;
#line 2627
  n2ptr = nptr;
#line 2628
  orient = (int )ptr->corient;
#line 2629
  if (orient == 0) {
#line 2630
    n1ptr->pinloc = (char)1;
#line 2631
    n2ptr->pinloc = (char)-1;
  } else {
#line 2629
    if (orient == 2) {
#line 2630
      n1ptr->pinloc = (char)1;
#line 2631
      n2ptr->pinloc = (char)-1;
    } else {
#line 2633
      n1ptr->pinloc = (char)-1;
#line 2634
      n2ptr->pinloc = (char)1;
    }
  }
#line 2636
  return 0;
}
}
#line 2671
int re_place(int *rowptr , int cell___0 , int index___0 , int x_location ) ;
#line 2642 "D:/a/test/300.c"
int alignfeed(void) 
{ int row___0 ;
  int last_up ;
  int last_dn ;
  int up ;
  int dn ;
  int cell_up ;
  int cell_dn ;
  int net_up ;
  int net_dn ;
  int x_up ;
  int distance ;
  int tmp ;

  {
#line 2646
  distance = 0;
#line 2647
  row___0 = numRows - 1;
#line 2647
  while (row___0 >= 1) {
#line 2648
    last_up = *(*(pairArray + (row___0 + 1)) + 0);
#line 2649
    last_dn = *(*(pairArray + row___0) + 0);
#line 2650
    up = 1;
#line 2650
    while (up <= last_up) {
#line 2651
      cell_up = *(*(pairArray + (row___0 + 1)) + up);
#line 2652
      if (cell_up >= (numcells - fdthrus) + 1) {
#line 2653
        if ((unsigned int )((*(carray + cell_up))->tileptr)->termsptr == (unsigned int )((struct termbox *)((void *)0))) {
          goto __Cont;
        }
#line 2656
        net_up = (int )(*(tearray + (((*(carray + cell_up))->tileptr)->termsptr)->cellterm))->net;
#line 2658
        x_up = (*(carray + cell_up))->cxcenter;
#line 2659
        dn = 1;
#line 2659
        while (dn <= last_dn) {
#line 2660
          cell_dn = *(*(pairArray + row___0) + dn);
#line 2661
          if (cell_dn >= (numcells - fdthrus) + 1) {
#line 2662
            if ((unsigned int )((*(carray + cell_dn))->tileptr)->termsptr == (unsigned int )((struct termbox *)((void *)0))) {
              goto __Cont___0;
            }
#line 2666
            net_dn = (int )(*(tearray + (((*(carray + cell_dn))->tileptr)->termsptr)->cellterm))->net;
#line 2668
            if (net_dn != net_up) {
              goto __Cont___0;
            }
#line 2671
            tmp = re_place(*(pairArray + row___0), cell_dn, dn, x_up);
#line 2671
            distance += tmp;
#line 2673
            break;
          }
          __Cont___0: /* CIL Label */ 
#line 2659
          dn ++;
        }
      }
      __Cont: /* CIL Label */ 
#line 2650
      up ++;
    }
#line 2647
    row___0 --;
  }
#line 2679
  return (distance);
}
}
#line 2681 "D:/a/test/300.c"
int re_place(int *rowptr , int cell___0 , int index___0 , int x_location ) 
{ int i ;
  int j ;
  int last___0 ;
  int prev_x ;
  int tmp ;

  {
#line 2685
  last___0 = *(rowptr + 0);
#line 2686
  if ((*(carray + *(rowptr + 1)))->cxcenter >= x_location) {
#line 2687
    i = 0;
  } else {
#line 2688
    if ((*(carray + *(rowptr + last___0)))->cxcenter <= x_location) {
#line 2689
      i = last___0;
    } else {
#line 2691
      i = 1;
#line 2691
      while (i < last___0) {
#line 2692
        if ((*(carray + *(rowptr + i)))->cxcenter <= x_location) {
#line 2692
          if ((*(carray + *(rowptr + (i + 1))))->cxcenter >= x_location) {
#line 2694
            break;
          }
        }
#line 2691
        i ++;
      }
    }
  }
#line 2698
  prev_x = (*(carray + cell___0))->cxcenter;
#line 2699
  if (index___0 > i + 1) {
#line 2700
    j = index___0 - 1;
#line 2700
    while (j >= i + 1) {
#line 2701
      (*(carray + *(rowptr + j)))->cxcenter += fdWidth;
#line 2702
      *(rowptr + (j + 1)) = *(rowptr + j);
#line 2700
      j --;
    }
#line 2704
    *(rowptr + (i + 1)) = cell___0;
#line 2705
    (*(carray + cell___0))->cxcenter = ((*(carray + *(rowptr + (i + 2))))->cxcenter + (int )((*(carray + *(rowptr + (i + 2))))->tileptr)->left) - (fdWidth - fdWidth / 2);
  } else {
#line 2707
    if (index___0 < i) {
#line 2708
      j = index___0 + 1;
#line 2708
      while (j <= i) {
#line 2709
        (*(carray + *(rowptr + j)))->cxcenter -= fdWidth;
#line 2710
        *(rowptr + (j - 1)) = *(rowptr + j);
#line 2708
        j ++;
      }
#line 2712
      *(rowptr + i) = cell___0;
#line 2713
      (*(carray + cell___0))->cxcenter = ((*(carray + *(rowptr + (i - 1))))->cxcenter + (int )((*(carray + *(rowptr + (i - 1))))->tileptr)->right) + fdWidth / 2;
    }
  }
#line 2716
  if ((*(carray + cell___0))->cxcenter - prev_x >= 0) {
#line 2716
    tmp = (*(carray + cell___0))->cxcenter - prev_x;
  } else {
#line 2716
    tmp = - ((*(carray + cell___0))->cxcenter - prev_x);
  }
#line 2716
  return (tmp);
}
}
#line 2718 "D:/a/test/300.c"
int align_init(void) 
{ int row___0 ;
  int i ;
  int cell___0 ;
  int *rowptr ;
  int j ;
  int last___0 ;
  int width___0 ;

  {
#line 2721
  row___0 = 1;
#line 2721
  while (row___0 <= numRows) {
#line 2722
    last___0 = *(*(pairArray + row___0) + 0);
#line 2723
    i = 1;
#line 2723
    while (i <= last___0) {
#line 2724
      cell___0 = *(*(pairArray + row___0) + i);
#line 2725
      if (cell___0 < (numcells - fdthrus) + 1) {
#line 2726
        break;
      }
#line 2723
      i ++;
    }
#line 2729
    if (i > 1) {
#line 2729
      if (i <= last___0) {
#line 2730
        rowptr = *(pairArray + row___0);
#line 2731
        width___0 = (int )((*(carray + cell___0))->tileptr)->right - (int )((*(carray + cell___0))->tileptr)->left;
#line 2733
        j = i - 1;
#line 2733
        while (j >= 1) {
#line 2734
          (*(carray + *(rowptr + j)))->cxcenter += width___0;
#line 2735
          *(rowptr + (j + 1)) = *(rowptr + j);
#line 2733
          j --;
        }
#line 2737
        *(rowptr + 1) = cell___0;
#line 2738
        (*(carray + cell___0))->cxcenter = ((*(carray + *(rowptr + 2)))->cxcenter + (int )((*(carray + *(rowptr + 2)))->tileptr)->left) - (width___0 - width___0 / 2);
      }
    }
#line 2741
    i = last___0;
#line 2741
    while (i >= 1) {
#line 2742
      cell___0 = *(*(pairArray + row___0) + i);
#line 2743
      if (cell___0 < (numcells - fdthrus) + 1) {
#line 2744
        break;
      }
#line 2741
      i --;
    }
#line 2747
    if (i < last___0) {
#line 2747
      if (i >= 1) {
#line 2748
        rowptr = *(pairArray + row___0);
#line 2749
        width___0 = (int )((*(carray + cell___0))->tileptr)->right - (int )((*(carray + cell___0))->tileptr)->left;
#line 2751
        j = i + 1;
#line 2751
        while (j <= last___0) {
#line 2752
          (*(carray + *(rowptr + j)))->cxcenter -= width___0;
#line 2753
          *(rowptr + (j - 1)) = *(rowptr + j);
#line 2751
          j ++;
        }
#line 2755
        *(rowptr + last___0) = cell___0;
#line 2756
        (*(carray + cell___0))->cxcenter = ((*(carray + *(rowptr + (last___0 - 1))))->cxcenter + (int )((*(carray + *(rowptr + (last___0 - 1))))->tileptr)->right) + width___0 / 2;
      }
    }
#line 2721
    row___0 ++;
  }
#line 2760
  return 0;
}
}
#line 2765 "D:/a/test/300.c"
IPBOXPTR xipptr  ;
#line 2768 "D:/a/test/300.c"
int buildimp(int icell , int xrel , int yrel , char *pname , int flag , int layer ) 
{ CBOXPTR ptr ;
  IBOXPTR iptr ;
  int row___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 2775
  if (flag == 1) {
#line 2776
    ptr = *(carray + icell);
#line 2777
    row___0 = *(blkToRow + ptr->cblock);
#line 2778
    iptr = *(impFeeds + row___0);
#line 2779
    if ((unsigned int )iptr != (unsigned int )((struct ibox *)((void *)0))) {
#line 2780
      while ((unsigned int )iptr->niptr != (unsigned int )((struct ibox *)((void *)0))) {
#line 2781
        iptr = iptr->niptr;
      }
#line 2783
      tmp = (int )safe_malloc(sizeof(IBOX ));
#line 2783
      iptr->niptr = (struct ibox *)tmp;
#line 2784
      iptr = iptr->niptr;
    } else {
#line 2786
      tmp___0 = (int )safe_malloc(sizeof(IBOX ));
#line 2786
      *(impFeeds + row___0) = (struct ibox *)tmp___0;
#line 2787
      iptr = *(impFeeds + row___0);
    }
#line 2789
    iptr->icell = icell;
#line 2790
    iptr->iactive = 0;
#line 2791
    iptr->aveXpos = ptr->cxcenter + xrel;
#line 2792
    iptr->niptr = (struct ibox *)((void *)0);
#line 2793
    tmp___1 = (int )safe_malloc(sizeof(IPBOX ));
#line 2793
    iptr->iptr = (struct ipbox *)tmp___1;
#line 2794
    xipptr = iptr->iptr;
#line 2795
    xipptr->ixpos = xrel;
#line 2796
    xipptr->iypos = yrel;
#line 2797
    xipptr->layer = layer;
#line 2798
    tmp___2 = strlen((char const   *)pname);
#line 2798
    tmp___3 = (int )safe_malloc((tmp___2 + 1U) * sizeof(char ));
#line 2798
    xipptr->ipname = (char *)tmp___3;
#line 2799
    sprintf(xipptr->ipname, "%s", pname);
#line 2800
    xipptr->npin = (struct ipbox *)((void *)0);
  } else {
#line 2802
    tmp___4 = (int )safe_malloc(sizeof(IPBOX ));
#line 2802
    xipptr->npin = (struct ipbox *)tmp___4;
#line 2803
    xipptr = xipptr->npin;
#line 2804
    xipptr->ixpos = xrel;
#line 2805
    xipptr->iypos = yrel;
#line 2806
    xipptr->layer = layer;
#line 2807
    tmp___5 = strlen((char const   *)pname);
#line 2807
    tmp___6 = (int )safe_malloc((tmp___5 + 1U) * sizeof(char ));
#line 2807
    xipptr->ipname = (char *)tmp___6;
#line 2808
    sprintf(xipptr->ipname, "%s", pname);
#line 2809
    xipptr->npin = (struct ipbox *)((void *)0);
  }
#line 2811
  return 0;
}
}
#line 2813 "D:/a/test/300.c"
int build_feed_imp(int feed , int x , int row___0 ) 
{ IBOXPTR iptr ;
  char pname[128] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  struct ipbox *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
#line 2818
  iptr = *(impFeeds + row___0);
#line 2819
  if ((unsigned int )iptr != (unsigned int )((struct ibox *)((void *)0))) {
#line 2820
    while ((unsigned int )iptr->niptr != (unsigned int )((struct ibox *)((void *)0))) {
#line 2821
      iptr = iptr->niptr;
    }
#line 2823
    tmp = (int )safe_malloc(sizeof(IBOX ));
#line 2823
    iptr->niptr = (struct ibox *)tmp;
#line 2824
    iptr = iptr->niptr;
  } else {
#line 2826
    tmp___0 = (int )safe_malloc(sizeof(IBOX ));
#line 2826
    *(impFeeds + row___0) = (struct ibox *)tmp___0;
#line 2827
    iptr = *(impFeeds + row___0);
  }
#line 2829
  iptr->icell = numcells + feed;
#line 2830
  iptr->iactive = -1;
#line 2831
  iptr->aveXpos = x - fdWidth / 2;
#line 2832
  iptr->niptr = (struct ibox *)((void *)0);
#line 2833
  tmp___1 = (int )safe_malloc(sizeof(IPBOX ));
#line 2833
  iptr->iptr = (struct ipbox *)tmp___1;
#line 2834
  xipptr = iptr->iptr;
#line 2835
  xipptr->ixpos = - fdWidth / 2;
#line 2836
  xipptr->iypos = (int )(*(barray + 1))->bheight - (int )(*(barray + 1))->bheight / 2;
#line 2837
  xipptr->layer = 0;
#line 2838
  sprintf(pname, "%s.%d", "twfeed", feed);
#line 2839
  tmp___2 = strlen((char const   *)(pname));
#line 2839
  tmp___3 = (int )safe_malloc((tmp___2 + 1U) * sizeof(char ));
#line 2839
  xipptr->ipname = (char *)tmp___3;
#line 2840
  sprintf(xipptr->ipname, "%s", pname);
#line 2841
  tmp___5 = (int )safe_malloc(sizeof(IPBOX ));
#line 2841
  tmp___4 = (struct ipbox *)tmp___5;
#line 2841
  xipptr->npin = tmp___4;
#line 2841
  xipptr = tmp___4;
#line 2842
  xipptr->ixpos = - fdWidth / 2;
#line 2843
  xipptr->iypos = - ((int )(*(barray + 1))->bheight) / 2;
#line 2844
  xipptr->layer = 0;
#line 2845
  tmp___6 = strlen((char const   *)(pname));
#line 2845
  tmp___7 = (int )safe_malloc((tmp___6 + 1U) * sizeof(char ));
#line 2845
  xipptr->ipname = (char *)tmp___7;
#line 2846
  sprintf(xipptr->ipname, "%s", pname);
#line 2847
  xipptr->npin = (struct ipbox *)((void *)0);
#line 2848
  return 0;
}
}
#line 2865 "D:/a/test/300.c"
int attlimit  ;
#line 2866 "D:/a/test/300.c"
SWITCHBOX *aNetSeg  ;
#line 2867 "D:/a/test/300.c"
CHANGRDPTR *Begin  ;
#line 2867 "D:/a/test/300.c"
CHANGRDPTR *End  ;
#line 2868 "D:/a/test/300.c"
TGRIDPTR *Tgrid  ;
#line 2869 "D:/a/test/300.c"
DENSITYPTR **Densebox  ;
#line 2869 "D:/a/test/300.c"
DENSITYPTR **DboxHead  ;
#line 2870 "D:/a/test/300.c"
int *anet  ;
#line 2870 "D:/a/test/300.c"
int *netchgs  ;
#line 2870 "D:/a/test/300.c"
int *fixnetseg  ;
#line 2871 "D:/a/test/300.c"
int numSwSegs  ;
#line 2872 "D:/a/test/300.c"
int *nmaxTrack  ;
#line 2872 "D:/a/test/300.c"
int max_tdensity  ;
#line 2888 "D:/a/test/300.c"
int **pseudoPins  ;
#line 2889 "D:/a/test/300.c"
int **pseudoEdge  ;
#line 2892 "D:/a/test/300.c"
csGroup *groupArray  ;
#line 2893 "D:/a/test/300.c"
int MPG  ;
#line 2894 "D:/a/test/300.c"
int ME  ;
#line 2895 "D:/a/test/300.c"
edgeBox *edgeArray  ;
#line 2896 "D:/a/test/300.c"
chkBox *checkArray  ;
#line 2897 "D:/a/test/300.c"
int *key_queue  ;
#line 2898 "D:/a/test/300.c"
int numEdges  ;
#line 2898 "D:/a/test/300.c"
int numGroups  ;
#line 2898 "D:/a/test/300.c"
int numPins  ;
#line 2899 "D:/a/test/300.c"
int gxstart  ;
#line 2899 "D:/a/test/300.c"
int gxstop  ;
#line 2899 "D:/a/test/300.c"
int top_row  ;
#line 2913
char *safe_calloc(unsigned int size , unsigned int num ) ;
#line 3005
int qsortgdx(char *base , int n , int size ) ;
#line 3060
int safe_cfree(char *ptr ) ;
#line 2906 "D:/a/test/300.c"
int changrid(void) 
{ CHANGRDPTR **gdptr ;
  CHANGRDPTR grdptr ;
  CHANGRDPTR cgdptr ;
  CHANGRDPTR ngdptr ;
  NBOXPTR netptr ;
  int row___0 ;
  int net ;
  int channel ;
  int terminal ;
  int *numPins___0 ;
  int *PinInChan ;
  int count___0 ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  CHANGRDPTR tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 2913
  tmp = (int )safe_calloc(sizeof(int ), numChans + 1);
#line 2913
  numPins___0 = (int *)tmp;
#line 2914
  tmp___0 = (int )safe_calloc(sizeof(int ), numChans + 1);
#line 2914
  PinInChan = (int *)tmp___0;
#line 2915
  net = 1;
#line 2915
  while (net <= numnets) {
#line 2916
    netptr = (*(netarray + net))->netptr;
#line 2916
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 2918
      if ((int )netptr->pinloc == -1) {
#line 2919
        (*(numPins___0 + netptr->row)) ++;
      } else {
#line 2920
        if ((int )netptr->pinloc == 1) {
#line 2921
          (*(numPins___0 + ((int )netptr->row + 1))) ++;
        } else {
#line 2923
          if ((int )netptr->row > 0) {
#line 2924
            (*(numPins___0 + netptr->row)) ++;
          }
#line 2926
          if ((int )netptr->row < numChans) {
#line 2927
            (*(numPins___0 + ((int )netptr->row + 1))) ++;
          }
        }
      }
#line 2916
      netptr = netptr->nterm;
    }
#line 2915
    net ++;
  }
#line 2932
  tmp___1 = (int )safe_malloc((unsigned int )(numChans + 1) * sizeof(CHANGRDPTR *));
#line 2932
  gdptr = (CHANGRDPTR **)tmp___1;
#line 2934
  channel = 1;
#line 2934
  while (channel <= numChans) {
#line 2935
    tmp___2 = (int )safe_malloc((unsigned int )(*(numPins___0 + channel) + 1) * sizeof(CHANGRDPTR ));
#line 2935
    *(gdptr + channel) = (CHANGRDPTR *)tmp___2;
#line 2934
    channel ++;
  }
#line 2938
  tmp___3 = (int )safe_malloc((unsigned int )((maxterm + 2 * numChans) + 1) * sizeof(TGRIDPTR ));
#line 2938
  Tgrid = (TGRIDPTR *)tmp___3;
#line 2940
  terminal = 1;
#line 2940
  while (terminal <= maxterm + 2 * numChans) {
#line 2941
    tmp___4 = (int )safe_malloc(sizeof(TGRIDBOX ));
#line 2941
    *(Tgrid + terminal) = (struct tgridbox *)tmp___4;
#line 2940
    terminal ++;
  }
#line 2943
  net = 1;
#line 2943
  while (net <= numnets) {
#line 2944
    netptr = (*(netarray + net))->netptr;
#line 2944
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 2946
      row___0 = (int )netptr->row;
#line 2947
      terminal = netptr->terminal;
#line 2948
      tmp___5 = (int )safe_malloc(sizeof(CHANGRDBOX ));
#line 2948
      grdptr = (struct changrdbox *)tmp___5;
#line 2949
      if ((int )netptr->pinloc == -1) {
#line 2950
        channel = row___0;
#line 2951
        (*(PinInChan + channel)) ++;
#line 2951
        count___0 = *(PinInChan + channel);
#line 2952
        *(*(gdptr + channel) + count___0) = grdptr;
#line 2953
        (*(Tgrid + terminal))->up = grdptr;
#line 2954
        (*(Tgrid + terminal))->down = grdptr;
#line 2955
        grdptr->netptr = *(tearray + terminal);
#line 2956
        grdptr->tracks = (short)0;
#line 2957
        grdptr->SegType = (short)0;
      } else {
#line 2958
        if ((int )netptr->pinloc == 1) {
#line 2959
          channel = row___0 + 1;
#line 2960
          (*(PinInChan + channel)) ++;
#line 2960
          count___0 = *(PinInChan + channel);
#line 2961
          *(*(gdptr + channel) + count___0) = grdptr;
#line 2962
          (*(Tgrid + terminal))->up = grdptr;
#line 2963
          (*(Tgrid + terminal))->down = grdptr;
#line 2964
          grdptr->netptr = *(tearray + terminal);
#line 2965
          grdptr->tracks = (short)0;
#line 2966
          grdptr->SegType = (short)0;
        } else {
#line 2968
          if (1 <= row___0) {
#line 2968
            if (row___0 <= numChans - 1) {
#line 2969
              channel = row___0;
#line 2970
              (*(PinInChan + channel)) ++;
#line 2970
              count___0 = *(PinInChan + channel);
#line 2971
              *(*(gdptr + channel) + count___0) = grdptr;
#line 2972
              (*(Tgrid + terminal))->down = grdptr;
#line 2973
              grdptr->netptr = *(tearray + terminal);
#line 2974
              grdptr->tracks = (short)0;
#line 2975
              grdptr->SegType = (short)0;
#line 2976
              channel = row___0 + 1;
#line 2977
              (*(PinInChan + channel)) ++;
#line 2977
              count___0 = *(PinInChan + channel);
#line 2978
              tmp___7 = (int )safe_malloc(sizeof(CHANGRDBOX ));
#line 2978
              tmp___6 = (struct changrdbox *)tmp___7;
#line 2978
              *(*(gdptr + channel) + count___0) = tmp___6;
#line 2978
              grdptr = tmp___6;
#line 2980
              (*(Tgrid + terminal))->up = grdptr;
#line 2981
              grdptr->netptr = *(tearray + terminal);
#line 2982
              grdptr->tracks = (short)0;
#line 2983
              grdptr->SegType = (short)0;
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 2984
            if (row___0 == 0) {
#line 2985
              (*(PinInChan + 1)) ++;
#line 2985
              count___0 = *(PinInChan + 1);
#line 2986
              *(*(gdptr + 1) + count___0) = grdptr;
#line 2987
              (*(Tgrid + terminal))->up = grdptr;
#line 2988
              (*(Tgrid + terminal))->down = grdptr;
#line 2989
              grdptr->netptr = *(tearray + terminal);
#line 2990
              grdptr->tracks = (short)0;
#line 2991
              grdptr->SegType = (short)0;
            } else {
#line 2993
              (*(PinInChan + numChans)) ++;
#line 2993
              count___0 = *(PinInChan + numChans);
#line 2994
              *(*(gdptr + numChans) + count___0) = grdptr;
#line 2995
              (*(Tgrid + terminal))->up = grdptr;
#line 2996
              (*(Tgrid + terminal))->down = grdptr;
#line 2997
              grdptr->netptr = *(tearray + terminal);
#line 2998
              grdptr->tracks = (short)0;
#line 2999
              grdptr->SegType = (short)0;
            }
          }
        }
      }
#line 2944
      netptr = netptr->nterm;
    }
#line 2943
    net ++;
  }
#line 3004
  channel = 1;
#line 3004
  while (channel <= numChans) {
#line 3005
    qsortgdx((char *)(*(gdptr + channel) + 1), *(numPins___0 + channel), sizeof(CHANGRDPTR ));
#line 3004
    channel ++;
  }
#line 3008
  tmp___8 = (int )safe_malloc((unsigned int )(numChans + 1) * sizeof(CHANGRDPTR ));
#line 3008
  Begin = (CHANGRDPTR *)tmp___8;
#line 3010
  tmp___9 = (int )safe_malloc((unsigned int )(numChans + 1) * sizeof(CHANGRDPTR ));
#line 3010
  End = (CHANGRDPTR *)tmp___9;
#line 3012
  channel = 1;
#line 3012
  while (channel <= numChans) {
#line 3013
    tmp___10 = (int )safe_calloc(sizeof(CHANGRDBOX ), 1);
#line 3013
    *(Begin + channel) = (struct changrdbox *)tmp___10;
#line 3014
    tmp___11 = (int )safe_calloc(sizeof(NBOX ), 1);
#line 3014
    (*(Begin + channel))->netptr = (struct netbox *)tmp___11;
#line 3015
    ((*(Begin + channel))->netptr)->xpos = gxstart - 1;
#line 3016
    ((*(Begin + channel))->netptr)->terminal = maxterm + channel;
#line 3017
    ((*(Begin + channel))->netptr)->row = (short )channel;
#line 3018
    ((*(Begin + channel))->netptr)->pinloc = (char)-1;
#line 3019
    *(tearray + (maxterm + channel)) = (*(Begin + channel))->netptr;
#line 3020
    tmp___12 = (int )safe_calloc(sizeof(CHANGRDBOX ), 1);
#line 3020
    *(End + channel) = (struct changrdbox *)tmp___12;
#line 3021
    tmp___13 = (int )safe_calloc(sizeof(NBOX ), 1);
#line 3021
    (*(End + channel))->netptr = (struct netbox *)tmp___13;
#line 3022
    ((*(End + channel))->netptr)->xpos = gxstop + 1;
#line 3023
    ((*(End + channel))->netptr)->terminal = (maxterm + numChans) + channel;
#line 3024
    ((*(End + channel))->netptr)->row = (short )channel;
#line 3025
    ((*(End + channel))->netptr)->pinloc = (char)-1;
#line 3026
    *(tearray + ((maxterm + numChans) + channel)) = (*(End + channel))->netptr;
#line 3012
    channel ++;
  }
#line 3028
  channel = 1;
#line 3028
  while (channel <= numChans) {
#line 3029
    (*(Tgrid + (maxterm + channel)))->up = *(Begin + channel);
#line 3030
    (*(Tgrid + (maxterm + channel)))->down = *(Begin + channel);
#line 3031
    (*(Tgrid + ((maxterm + numChans) + channel)))->up = *(End + channel);
#line 3032
    (*(Tgrid + ((maxterm + numChans) + channel)))->down = *(End + channel);
#line 3028
    channel ++;
  }
#line 3034
  channel = 1;
#line 3034
  while (channel <= numChans) {
#line 3035
    if (*(numPins___0 + channel) == 0) {
#line 3036
      (*(Begin + channel))->nextgrd = (struct changrdbox *)((void *)0);
#line 3037
      (*(End + channel))->prevgrd = (struct changrdbox *)((void *)0);
    } else {
#line 3038
      if (*(numPins___0 + channel) == 1) {
#line 3039
        (*(Begin + channel))->nextgrd = *(*(gdptr + channel) + 1);
#line 3040
        (*(*(gdptr + channel) + 1))->prevgrd = *(Begin + channel);
#line 3041
        (*(End + channel))->prevgrd = *(*(gdptr + channel) + 1);
#line 3042
        (*(*(gdptr + channel) + 1))->nextgrd = *(End + channel);
      } else {
#line 3044
        (*(Begin + channel))->nextgrd = *(*(gdptr + channel) + 1);
#line 3045
        (*(*(gdptr + channel) + 1))->prevgrd = *(Begin + channel);
#line 3046
        i = 1;
#line 3046
        while (i <= *(numPins___0 + channel) - 1) {
#line 3047
          cgdptr = *(*(gdptr + channel) + i);
#line 3048
          ngdptr = *(*(gdptr + channel) + (i + 1));
#line 3049
          cgdptr->nextgrd = ngdptr;
#line 3050
          ngdptr->prevgrd = cgdptr;
#line 3046
          i ++;
        }
#line 3052
        ngdptr->nextgrd = *(End + channel);
#line 3053
        (*(End + channel))->prevgrd = ngdptr;
      }
    }
#line 3034
    channel ++;
  }
#line 3056
  channel = 1;
#line 3056
  while (channel <= numChans) {
#line 3057
    safe_free(*(gdptr + channel));
#line 3056
    channel ++;
  }
#line 3059
  safe_free(gdptr);
#line 3060
  safe_cfree(numPins___0);
#line 3061
  safe_cfree(PinInChan);
#line 3062
  return (0);
}
}
#line 3072 "D:/a/test/300.c"
int new_old(int c ) 
{ int old ;
  int new ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3076
  if (ablock != bblock) {
#line 3077
    (*(barray + ablock))->newsize = (short )((int )(*(barray + ablock))->oldsize + c);
#line 3078
    (*(barray + bblock))->newsize = (short )((int )(*(barray + bblock))->oldsize - c);
#line 3079
    if ((int )(*(barray + ablock))->oldsize - (int )(*(barray + ablock))->desire >= 0) {
#line 3079
      tmp = (int )(*(barray + ablock))->oldsize - (int )(*(barray + ablock))->desire;
    } else {
#line 3079
      tmp = - ((int )(*(barray + ablock))->oldsize - (int )(*(barray + ablock))->desire);
    }
#line 3079
    if ((int )(*(barray + bblock))->oldsize - (int )(*(barray + bblock))->desire >= 0) {
#line 3079
      tmp___0 = (int )(*(barray + bblock))->oldsize - (int )(*(barray + bblock))->desire;
    } else {
#line 3079
      tmp___0 = - ((int )(*(barray + bblock))->oldsize - (int )(*(barray + bblock))->desire);
    }
#line 3079
    old = tmp + tmp___0;
#line 3081
    if ((int )(*(barray + ablock))->newsize - (int )(*(barray + ablock))->desire >= 0) {
#line 3081
      tmp___1 = (int )(*(barray + ablock))->newsize - (int )(*(barray + ablock))->desire;
    } else {
#line 3081
      tmp___1 = - ((int )(*(barray + ablock))->newsize - (int )(*(barray + ablock))->desire);
    }
#line 3081
    if ((int )(*(barray + bblock))->newsize - (int )(*(barray + bblock))->desire >= 0) {
#line 3081
      tmp___2 = (int )(*(barray + bblock))->newsize - (int )(*(barray + bblock))->desire;
    } else {
#line 3081
      tmp___2 = - ((int )(*(barray + bblock))->newsize - (int )(*(barray + bblock))->desire);
    }
#line 3081
    new = tmp___1 + tmp___2;
#line 3083
    newrowpenal += new - old;
  }
#line 3085
  return (0);
}
}
#line 3086 "D:/a/test/300.c"
int old_assgnto_new1(int alobin , int ahibin , int anewlobin , int anewhibin ) 
{ int bin ;
  int lobin ;
  int hibin ;

  {
#line 3090
  if (ablock == bblock) {
#line 3091
    if (alobin <= anewlobin) {
#line 3091
      lobin = alobin;
    } else {
#line 3091
      lobin = anewlobin;
    }
#line 3092
    if (ahibin >= anewhibin) {
#line 3092
      hibin = ahibin;
    } else {
#line 3092
      hibin = anewhibin;
    }
#line 3093
    bin = lobin;
#line 3093
    while (bin <= hibin) {
#line 3094
      (*(*(binptr + ablock) + bin))->nupenalty = (*(*(binptr + ablock) + bin))->penalty;
#line 3093
      bin ++;
    }
  } else {
#line 3098
    bin = alobin;
#line 3098
    while (bin <= ahibin) {
#line 3099
      (*(*(binptr + ablock) + bin))->nupenalty = (*(*(binptr + ablock) + bin))->penalty;
#line 3098
      bin ++;
    }
#line 3102
    bin = anewlobin;
#line 3102
    while (bin <= anewhibin) {
#line 3103
      (*(*(binptr + bblock) + bin))->nupenalty = (*(*(binptr + bblock) + bin))->penalty;
#line 3102
      bin ++;
    }
  }
#line 3107
  return (0);
}
}
#line 3108 "D:/a/test/300.c"
int new_assgnto_old1(int alobin , int ahibin , int anewlobin , int anewhibin ) 
{ int bin ;
  int lobin ;
  int hibin ;

  {
#line 3112
  if (ablock == bblock) {
#line 3113
    if (alobin <= anewlobin) {
#line 3113
      lobin = alobin;
    } else {
#line 3113
      lobin = anewlobin;
    }
#line 3114
    if (ahibin >= anewhibin) {
#line 3114
      hibin = ahibin;
    } else {
#line 3114
      hibin = anewhibin;
    }
#line 3115
    bin = lobin;
#line 3115
    while (bin <= hibin) {
#line 3116
      (*(*(binptr + ablock) + bin))->penalty = (*(*(binptr + ablock) + bin))->nupenalty;
#line 3115
      bin ++;
    }
  } else {
#line 3120
    bin = alobin;
#line 3120
    while (bin <= ahibin) {
#line 3121
      (*(*(binptr + ablock) + bin))->penalty = (*(*(binptr + ablock) + bin))->nupenalty;
#line 3120
      bin ++;
    }
#line 3124
    bin = anewlobin;
#line 3124
    while (bin <= anewhibin) {
#line 3125
      (*(*(binptr + bblock) + bin))->penalty = (*(*(binptr + bblock) + bin))->nupenalty;
#line 3124
      bin ++;
    }
  }
#line 3129
  return (0);
}
}
#line 3130 "D:/a/test/300.c"
int old_assgnto_new2(int a1lobin , int a1hibin , int a2lobin , int a2hibin , int b1lobin ,
                     int b1hibin , int b2lobin , int b2hibin ) 
{ int clobin ;
  int chibin ;
  int dlobin ;
  int dhibin ;
  int lobin ;
  int hibin ;
  int bin ;

  {
#line 3137
  if (a1lobin <= b2lobin) {
#line 3137
    clobin = a1lobin;
  } else {
#line 3137
    clobin = b2lobin;
  }
#line 3138
  if (a1hibin >= b2hibin) {
#line 3138
    chibin = a1hibin;
  } else {
#line 3138
    chibin = b2hibin;
  }
#line 3139
  if (a2lobin <= b1lobin) {
#line 3139
    dlobin = a2lobin;
  } else {
#line 3139
    dlobin = b1lobin;
  }
#line 3140
  if (a2hibin >= b1hibin) {
#line 3140
    dhibin = a2hibin;
  } else {
#line 3140
    dhibin = b1hibin;
  }
#line 3141
  if (ablock == bblock) {
#line 3142
    if (clobin <= dlobin) {
#line 3142
      lobin = clobin;
    } else {
#line 3142
      lobin = dlobin;
    }
#line 3143
    if (chibin >= dhibin) {
#line 3143
      hibin = chibin;
    } else {
#line 3143
      hibin = dhibin;
    }
#line 3144
    bin = lobin;
#line 3144
    while (bin <= hibin) {
#line 3145
      (*(*(binptr + ablock) + bin))->nupenalty = (*(*(binptr + ablock) + bin))->penalty;
#line 3144
      bin ++;
    }
  } else {
#line 3149
    bin = clobin;
#line 3149
    while (bin <= chibin) {
#line 3150
      (*(*(binptr + ablock) + bin))->nupenalty = (*(*(binptr + ablock) + bin))->penalty;
#line 3149
      bin ++;
    }
#line 3153
    bin = dlobin;
#line 3153
    while (bin <= dhibin) {
#line 3154
      (*(*(binptr + bblock) + bin))->nupenalty = (*(*(binptr + bblock) + bin))->penalty;
#line 3153
      bin ++;
    }
  }
#line 3158
  return (0);
}
}
#line 3160 "D:/a/test/300.c"
int new_assgnto_old2(int a1lobin , int a1hibin , int a2lobin , int a2hibin , int b1lobin ,
                     int b1hibin , int b2lobin , int b2hibin ) 
{ int clobin ;
  int chibin ;
  int dlobin ;
  int dhibin ;
  int lobin ;
  int hibin ;
  int bin ;

  {
#line 3167
  if (a1lobin <= b2lobin) {
#line 3167
    clobin = a1lobin;
  } else {
#line 3167
    clobin = b2lobin;
  }
#line 3168
  if (a1hibin >= b2hibin) {
#line 3168
    chibin = a1hibin;
  } else {
#line 3168
    chibin = b2hibin;
  }
#line 3169
  if (a2lobin <= b1lobin) {
#line 3169
    dlobin = a2lobin;
  } else {
#line 3169
    dlobin = b1lobin;
  }
#line 3170
  if (a2hibin >= b1hibin) {
#line 3170
    dhibin = a2hibin;
  } else {
#line 3170
    dhibin = b1hibin;
  }
#line 3171
  if (ablock == bblock) {
#line 3172
    if (clobin <= dlobin) {
#line 3172
      lobin = clobin;
    } else {
#line 3172
      lobin = dlobin;
    }
#line 3173
    if (chibin >= dhibin) {
#line 3173
      hibin = chibin;
    } else {
#line 3173
      hibin = dhibin;
    }
#line 3174
    bin = lobin;
#line 3174
    while (bin <= hibin) {
#line 3175
      (*(*(binptr + ablock) + bin))->penalty = (*(*(binptr + ablock) + bin))->nupenalty;
#line 3174
      bin ++;
    }
  } else {
#line 3179
    bin = clobin;
#line 3179
    while (bin <= chibin) {
#line 3180
      (*(*(binptr + ablock) + bin))->penalty = (*(*(binptr + ablock) + bin))->nupenalty;
#line 3179
      bin ++;
    }
#line 3183
    bin = dlobin;
#line 3183
    while (bin <= dhibin) {
#line 3184
      (*(*(binptr + bblock) + bin))->penalty = (*(*(binptr + bblock) + bin))->nupenalty;
#line 3183
      bin ++;
    }
  }
#line 3188
  return (0);
}
}
#line 3189 "D:/a/test/300.c"
int sub_penal(int startx , int endx , int block___0 , int LoBin , int HiBin ) 
{ BINPTR bptr ;
  int bin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 3194
  if (LoBin == HiBin) {
#line 3195
    bptr = *(*(binptr + block___0) + LoBin);
#line 3196
    if (bptr->nupenalty >= 0) {
#line 3196
      tmp = bptr->nupenalty;
    } else {
#line 3196
      tmp = - bptr->nupenalty;
    }
#line 3196
    newbinpenal -= tmp;
#line 3197
    bptr->nupenalty -= endx - startx;
#line 3198
    if (bptr->nupenalty >= 0) {
#line 3198
      tmp___0 = bptr->nupenalty;
    } else {
#line 3198
      tmp___0 = - bptr->nupenalty;
    }
#line 3198
    newbinpenal += tmp___0;
  } else {
#line 3200
    bin = LoBin;
#line 3200
    while (bin <= HiBin) {
#line 3201
      bptr = *(*(binptr + block___0) + bin);
#line 3202
      if (bin == LoBin) {
#line 3203
        if (bptr->nupenalty >= 0) {
#line 3203
          tmp___1 = bptr->nupenalty;
        } else {
#line 3203
          tmp___1 = - bptr->nupenalty;
        }
#line 3203
        newbinpenal -= tmp___1;
#line 3204
        bptr->nupenalty -= bptr->right - startx;
#line 3205
        if (bptr->nupenalty >= 0) {
#line 3205
          tmp___2 = bptr->nupenalty;
        } else {
#line 3205
          tmp___2 = - bptr->nupenalty;
        }
#line 3205
        newbinpenal += tmp___2;
      } else {
#line 3206
        if (bin == HiBin) {
#line 3207
          if (bptr->nupenalty >= 0) {
#line 3207
            tmp___3 = bptr->nupenalty;
          } else {
#line 3207
            tmp___3 = - bptr->nupenalty;
          }
#line 3207
          newbinpenal -= tmp___3;
#line 3208
          bptr->nupenalty -= endx - bptr->left;
#line 3209
          if (bptr->nupenalty >= 0) {
#line 3209
            tmp___4 = bptr->nupenalty;
          } else {
#line 3209
            tmp___4 = - bptr->nupenalty;
          }
#line 3209
          newbinpenal += tmp___4;
        } else {
#line 3211
          if (bptr->nupenalty >= 0) {
#line 3211
            tmp___5 = bptr->nupenalty;
          } else {
#line 3211
            tmp___5 = - bptr->nupenalty;
          }
#line 3211
          newbinpenal -= tmp___5;
#line 3212
          bptr->nupenalty -= binWidth;
#line 3213
          if (bptr->nupenalty >= 0) {
#line 3213
            tmp___6 = bptr->nupenalty;
          } else {
#line 3213
            tmp___6 = - bptr->nupenalty;
          }
#line 3213
          newbinpenal += tmp___6;
        }
      }
#line 3200
      bin ++;
    }
  }
#line 3217
  return (0);
}
}
#line 3218 "D:/a/test/300.c"
int add_penal(int startx , int endx , int block___0 , int LoBin , int HiBin ) 
{ BINPTR bptr ;
  int bin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 3223
  if (LoBin == HiBin) {
#line 3224
    bptr = *(*(binptr + block___0) + LoBin);
#line 3225
    if (bptr->nupenalty >= 0) {
#line 3225
      tmp = bptr->nupenalty;
    } else {
#line 3225
      tmp = - bptr->nupenalty;
    }
#line 3225
    newbinpenal -= tmp;
#line 3226
    bptr->nupenalty += endx - startx;
#line 3227
    if (bptr->nupenalty >= 0) {
#line 3227
      tmp___0 = bptr->nupenalty;
    } else {
#line 3227
      tmp___0 = - bptr->nupenalty;
    }
#line 3227
    newbinpenal += tmp___0;
  } else {
#line 3229
    bin = LoBin;
#line 3229
    while (bin <= HiBin) {
#line 3230
      bptr = *(*(binptr + block___0) + bin);
#line 3231
      if (bin == LoBin) {
#line 3232
        if (bptr->nupenalty >= 0) {
#line 3232
          tmp___1 = bptr->nupenalty;
        } else {
#line 3232
          tmp___1 = - bptr->nupenalty;
        }
#line 3232
        newbinpenal -= tmp___1;
#line 3233
        bptr->nupenalty += bptr->right - startx;
#line 3234
        if (bptr->nupenalty >= 0) {
#line 3234
          tmp___2 = bptr->nupenalty;
        } else {
#line 3234
          tmp___2 = - bptr->nupenalty;
        }
#line 3234
        newbinpenal += tmp___2;
      } else {
#line 3235
        if (bin == HiBin) {
#line 3236
          if (bptr->nupenalty >= 0) {
#line 3236
            tmp___3 = bptr->nupenalty;
          } else {
#line 3236
            tmp___3 = - bptr->nupenalty;
          }
#line 3236
          newbinpenal -= tmp___3;
#line 3237
          bptr->nupenalty += endx - bptr->left;
#line 3238
          if (bptr->nupenalty >= 0) {
#line 3238
            tmp___4 = bptr->nupenalty;
          } else {
#line 3238
            tmp___4 = - bptr->nupenalty;
          }
#line 3238
          newbinpenal += tmp___4;
        } else {
#line 3240
          if (bptr->nupenalty >= 0) {
#line 3240
            tmp___5 = bptr->nupenalty;
          } else {
#line 3240
            tmp___5 = - bptr->nupenalty;
          }
#line 3240
          newbinpenal -= tmp___5;
#line 3241
          bptr->nupenalty += binWidth;
#line 3242
          if (bptr->nupenalty >= 0) {
#line 3242
            tmp___6 = bptr->nupenalty;
          } else {
#line 3242
            tmp___6 = - bptr->nupenalty;
          }
#line 3242
          newbinpenal += tmp___6;
        }
      }
#line 3229
      bin ++;
    }
  }
#line 3246
  return (0);
}
}
#line 3263 "D:/a/test/300.c"
int closepins(FILE *tw , int net ) 
{ int pin ;
  int pin1 ;
  int pin2 ;
  int minP1 ;
  int minP2 ;
  int minX ;
  int sepT ;
  int sepB ;
  int edge___0 ;
  int left___0 ;
  int right ;
  int group1 ;
  int group2 ;
  int block1 ;
  int block2 ;
  int p1 ;
  int p2 ;
  int minTop ;
  int minBottom ;
  int maxTpin ;
  int maxBpin ;
  int otherTpin ;
  int otherBpin ;
  int maxTop ;
  int maxBottom ;
  int key_count ;
  int key_flag ;
  int segment_count ;
  int super_edge ;
  int next_edge ;
  int e1 ;
  int e2 ;
  int g1 ;
  int g2 ;
  int next_g ;
  int save_count ;
  int ltop ;
  int rtop ;
  int lbot ;
  int rbot ;
  csPinBox *pArray1 ;
  csPinBox *pArray2 ;
  csPinBox *pArray ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3275
  key_count = 0;
#line 3276
  segment_count = 0;
#line 3277
  super_edge = 0;
#line 3278
  fprintf(tw, "net %d\n", net);
#line 3279
  while (1) {
#line 3280
    if (key_count > 0) {
#line 3281
      tmp = key_count;
#line 3281
      key_count --;
#line 3281
      edge___0 = *(key_queue + tmp);
#line 3282
      group1 = (int )(edgeArray + edge___0)->group1;
#line 3283
      key_flag = save_count;
#line 3284
      rbot = -1;
#line 3284
      rtop = rbot;
#line 3284
      lbot = rtop;
#line 3284
      ltop = lbot;
    } else {
#line 3287
      while (1) {
#line 3287
        super_edge ++;
#line 3287
        if (! (super_edge <= numEdges)) {
#line 3287
          break;
        }
#line 3288
        if ((int )(edgeArray + super_edge)->marked == 0) {
#line 3289
          continue;
        }
#line 3291
        if ((int )(edgeArray + super_edge)->done == 0) {
#line 3292
          break;
        }
      }
#line 3295
      if (super_edge > numEdges) {
#line 3296
        break;
      }
#line 3298
      edge___0 = super_edge;
#line 3299
      key_flag = 0;
#line 3300
      rbot = 0;
#line 3300
      rtop = rbot;
#line 3300
      lbot = rtop;
#line 3300
      ltop = lbot;
    }
#line 3303
    segment_count ++;
#line 3304
    maxTop = -1000000000;
#line 3305
    maxBottom = -1000000000;
#line 3306
    maxTpin = 0;
#line 3307
    maxBpin = 0;
#line 3308
    group1 = (int )(edgeArray + edge___0)->group1;
#line 3309
    pArray1 = (groupArray + group1)->pinArray;
#line 3310
    block1 = (int )(groupArray + group1)->block;
#line 3311
    group2 = (int )(edgeArray + edge___0)->group2;
#line 3312
    pArray2 = (groupArray + group2)->pinArray;
#line 3313
    block2 = (int )(groupArray + group2)->block;
#line 3314
    if ((int )(edgeArray + edge___0)->poison == 0) {
#line 3314
      if (key_flag == 0) {
#line 3315
        save_count = segment_count;
#line 3316
        (edgeArray + edge___0)->done = (short)1;
#line 3317
        key_flag = save_count;
#line 3319
        e1 = edge___0;
#line 3320
        g1 = (int )(edgeArray + e1)->group1;
#line 3321
        while (! ((int )(groupArray + g1)->poison == 1)) {
#line 3326
          if ((int )(groupArray + g1)->edge1 == e1) {
#line 3327
            next_edge = (int )(groupArray + g1)->edge2;
          } else {
#line 3329
            next_edge = (int )(groupArray + g1)->edge1;
          }
#line 3331
          if (next_edge == 0) {
#line 3332
            break;
          }
#line 3334
          next_g = (int )(edgeArray + next_edge)->group1;
#line 3335
          if (next_g == g1) {
#line 3336
            g1 = (int )(edgeArray + next_edge)->group2;
          } else {
#line 3338
            g1 = next_g;
          }
#line 3340
          e1 = next_edge;
#line 3341
          (edgeArray + e1)->done = (short)1;
#line 3342
          key_count ++;
#line 3342
          *(key_queue + key_count) = e1;
        }
#line 3344
        e2 = edge___0;
#line 3345
        g2 = (int )(edgeArray + e2)->group2;
#line 3346
        while (! ((int )(groupArray + g2)->poison == 1)) {
#line 3350
          if ((int )(groupArray + g2)->edge1 == e2) {
#line 3351
            next_edge = (int )(groupArray + g2)->edge2;
          } else {
#line 3353
            next_edge = (int )(groupArray + g2)->edge1;
          }
#line 3355
          if (next_edge == 0) {
#line 3356
            break;
          }
#line 3358
          next_g = (int )(edgeArray + next_edge)->group1;
#line 3359
          if (next_g == g2) {
#line 3360
            g2 = (int )(edgeArray + next_edge)->group2;
          } else {
#line 3362
            g2 = next_g;
          }
#line 3364
          e2 = next_edge;
#line 3365
          (edgeArray + e2)->done = (short)1;
#line 3366
          key_count ++;
#line 3366
          *(key_queue + key_count) = e2;
        }
#line 3368
        if ((groupArray + g1)->aveX <= (groupArray + g2)->aveX) {
#line 3369
          pArray = (groupArray + g1)->pinArray;
#line 3370
          pin = 1;
#line 3370
          while (pin <= (int )(groupArray + g1)->numPins) {
#line 3371
            if ((int )(pArray + pin)->top == 1) {
#line 3372
              ltop = (pArray + pin)->pin;
            } else {
#line 3371
              if ((int )(pArray + pin)->top == 0) {
#line 3372
                ltop = (pArray + pin)->pin;
              }
            }
#line 3374
            if ((int )(pArray + pin)->top == -1) {
#line 3375
              lbot = (pArray + pin)->pin;
            } else {
#line 3374
              if ((int )(pArray + pin)->top == 0) {
#line 3375
                lbot = (pArray + pin)->pin;
              }
            }
#line 3370
            pin ++;
          }
#line 3378
          pArray = (groupArray + g2)->pinArray;
#line 3379
          pin = 1;
#line 3379
          while (pin <= (int )(groupArray + g2)->numPins) {
#line 3380
            if ((int )(pArray + pin)->top == 1) {
#line 3381
              rtop = (pArray + pin)->pin;
            } else {
#line 3380
              if ((int )(pArray + pin)->top == 0) {
#line 3381
                rtop = (pArray + pin)->pin;
              }
            }
#line 3383
            if ((int )(pArray + pin)->top == -1) {
#line 3384
              rbot = (pArray + pin)->pin;
            } else {
#line 3383
              if ((int )(pArray + pin)->top == 0) {
#line 3384
                rbot = (pArray + pin)->pin;
              }
            }
#line 3379
            pin ++;
          }
        } else {
#line 3388
          pArray = (groupArray + g2)->pinArray;
#line 3389
          pin = 1;
#line 3389
          while (pin <= (int )(groupArray + g2)->numPins) {
#line 3390
            if ((int )(pArray + pin)->top == 1) {
#line 3391
              ltop = (pArray + pin)->pin;
            } else {
#line 3390
              if ((int )(pArray + pin)->top == 0) {
#line 3391
                ltop = (pArray + pin)->pin;
              }
            }
#line 3393
            if ((int )(pArray + pin)->top == -1) {
#line 3394
              lbot = (pArray + pin)->pin;
            } else {
#line 3393
              if ((int )(pArray + pin)->top == 0) {
#line 3394
                lbot = (pArray + pin)->pin;
              }
            }
#line 3389
            pin ++;
          }
#line 3397
          pArray = (groupArray + g1)->pinArray;
#line 3398
          pin = 1;
#line 3398
          while (pin <= (int )(groupArray + g1)->numPins) {
#line 3399
            if ((int )(pArray + pin)->top == 1) {
#line 3400
              rtop = (pArray + pin)->pin;
            } else {
#line 3399
              if ((int )(pArray + pin)->top == 0) {
#line 3400
                rtop = (pArray + pin)->pin;
              }
            }
#line 3402
            if ((int )(pArray + pin)->top == -1) {
#line 3403
              rbot = (pArray + pin)->pin;
            } else {
#line 3402
              if ((int )(pArray + pin)->top == 0) {
#line 3403
                rbot = (pArray + pin)->pin;
              }
            }
#line 3398
            pin ++;
          }
        }
      }
    }
#line 3408
    if (block1 == block2) {
#line 3410
      if ((groupArray + group1)->aveX <= (groupArray + group2)->aveX) {
#line 3411
        pin = 1;
#line 3411
        while (pin <= (int )(groupArray + group1)->numPins) {
#line 3412
          if ((int )(pArray1 + pin)->top == 1) {
            goto _L;
          } else {
#line 3412
            if ((int )(pArray1 + pin)->top == 0) {
              _L: /* CIL Label */ 
#line 3413
              if ((int )(pArray1 + pin)->xloc > maxTop) {
#line 3414
                maxTop = (int )(pArray1 + pin)->xloc;
#line 3415
                maxTpin = (pArray1 + pin)->pin;
              }
            }
          }
#line 3418
          if ((int )(pArray1 + pin)->top == -1) {
            goto _L___0;
          } else {
#line 3418
            if ((int )(pArray1 + pin)->top == 0) {
              _L___0: /* CIL Label */ 
#line 3419
              if ((int )(pArray1 + pin)->xloc > maxBottom) {
#line 3420
                maxBottom = (int )(pArray1 + pin)->xloc;
#line 3421
                maxBpin = (pArray1 + pin)->pin;
              }
            }
          }
#line 3411
          pin ++;
        }
#line 3425
        sepT = 1000000000;
#line 3426
        sepB = 1000000000;
#line 3427
        otherTpin = 0;
#line 3428
        otherBpin = 0;
#line 3429
        pin = 1;
#line 3429
        while (pin <= (int )(groupArray + group2)->numPins) {
#line 3430
          if ((int )(pArray2 + pin)->top == 1) {
            goto _L___1;
          } else {
#line 3430
            if ((int )(pArray2 + pin)->top == 0) {
              _L___1: /* CIL Label */ 
#line 3431
              if ((int )(pArray2 + pin)->xloc - maxTop >= 0) {
#line 3431
                tmp___0 = (int )(pArray2 + pin)->xloc - maxTop;
              } else {
#line 3431
                tmp___0 = - ((int )(pArray2 + pin)->xloc - maxTop);
              }
#line 3431
              if (tmp___0 < sepT) {
#line 3432
                otherTpin = (pArray2 + pin)->pin;
#line 3433
                minTop = (int )(pArray2 + pin)->xloc;
#line 3434
                if (minTop - maxTop >= 0) {
#line 3434
                  sepT = minTop - maxTop;
                } else {
#line 3434
                  sepT = - (minTop - maxTop);
                }
              }
            }
          }
#line 3437
          if ((int )(pArray2 + pin)->top == -1) {
            goto _L___2;
          } else {
#line 3437
            if ((int )(pArray2 + pin)->top == 0) {
              _L___2: /* CIL Label */ 
#line 3438
              if ((int )(pArray2 + pin)->xloc - maxBottom >= 0) {
#line 3438
                tmp___1 = (int )(pArray2 + pin)->xloc - maxBottom;
              } else {
#line 3438
                tmp___1 = - ((int )(pArray2 + pin)->xloc - maxBottom);
              }
#line 3438
              if (tmp___1 < sepB) {
#line 3439
                otherBpin = (pArray2 + pin)->pin;
#line 3440
                minBottom = (int )(pArray2 + pin)->xloc;
#line 3441
                if (minBottom - maxBottom >= 0) {
#line 3441
                  sepB = minBottom - maxBottom;
                } else {
#line 3441
                  sepB = - (minBottom - maxBottom);
                }
              }
            }
          }
#line 3429
          pin ++;
        }
#line 3445
        if (maxTpin != 0) {
#line 3445
          if (otherTpin != 0) {
#line 3445
            if (block1 < numChans) {
#line 3445
              if (maxBpin != 0) {
#line 3445
                if (otherBpin != 0) {
#line 3445
                  if (maxBpin != 0) {
#line 3445
                    if (otherBpin != 0) {
#line 3445
                      if (maxBottom != minBottom) {
                        _L___7: /* CIL Label */ 
#line 3449
                        if (maxBpin != 0) {
#line 3449
                          if (otherBpin != 0) {
#line 3449
                            if (block1 > 0) {
#line 3449
                              if (maxTop != minTop) {
#line 3452
                                fprintf(tw, "segment switchable %d\n", key_flag);
#line 3453
                                fprintf(tw, "top channel %d\n", block1 + 1);
#line 3454
                                if (maxTop <= minTop) {
#line 3455
                                  p1 = maxTpin;
#line 3456
                                  p2 = otherTpin;
                                } else {
#line 3458
                                  p1 = otherTpin;
#line 3459
                                  p2 = maxTpin;
                                }
#line 3461
                                fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, ltop,
                                        rtop);
#line 3463
                                fprintf(tw, "bottom channel %d\n", block1);
#line 3464
                                if (maxBottom <= minBottom) {
#line 3465
                                  p1 = maxBpin;
#line 3466
                                  p2 = otherBpin;
                                } else {
#line 3468
                                  p1 = otherBpin;
#line 3469
                                  p2 = maxBpin;
                                }
#line 3471
                                fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, lbot,
                                        rbot);
                              } else {
                                goto _L___5;
                              }
                            } else {
                              goto _L___5;
                            }
                          } else {
                            goto _L___5;
                          }
                        } else {
                          _L___5: /* CIL Label */ 
#line 3474
                          fprintf(tw, "segment channel %d\n", block1 + 1);
#line 3475
                          if (maxTop <= minTop) {
#line 3476
                            p1 = maxTpin;
#line 3477
                            p2 = otherTpin;
                          } else {
#line 3479
                            p1 = otherTpin;
#line 3480
                            p2 = maxTpin;
                          }
#line 3482
                          fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, ltop, rtop);
                        }
                      } else {
                        goto _L___9;
                      }
                    } else {
                      goto _L___9;
                    }
                  } else {
                    goto _L___9;
                  }
                } else {
                  goto _L___7;
                }
              } else {
                goto _L___7;
              }
            } else {
              goto _L___9;
            }
          } else {
            goto _L___9;
          }
        } else {
          _L___9: /* CIL Label */ 
#line 3485
          if (maxBpin != 0) {
#line 3485
            if (otherBpin != 0) {
#line 3487
              fprintf(tw, "segment channel %d\n", block1);
#line 3488
              if (maxBottom <= minBottom) {
#line 3489
                p1 = maxBpin;
#line 3490
                p2 = otherBpin;
              } else {
#line 3492
                p1 = otherBpin;
#line 3493
                p2 = maxBpin;
              }
#line 3495
              fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, lbot, rbot);
            }
          }
        }
      } else {
#line 3499
        pin = 1;
#line 3499
        while (pin <= (int )(groupArray + group2)->numPins) {
#line 3500
          if ((int )(pArray2 + pin)->top == 1) {
            goto _L___10;
          } else {
#line 3500
            if ((int )(pArray2 + pin)->top == 0) {
              _L___10: /* CIL Label */ 
#line 3501
              if ((int )(pArray2 + pin)->xloc > maxTop) {
#line 3502
                maxTop = (int )(pArray2 + pin)->xloc;
#line 3503
                maxTpin = (pArray2 + pin)->pin;
              }
            }
          }
#line 3506
          if ((int )(pArray2 + pin)->top == -1) {
            goto _L___11;
          } else {
#line 3506
            if ((int )(pArray2 + pin)->top == 0) {
              _L___11: /* CIL Label */ 
#line 3507
              if ((int )(pArray2 + pin)->xloc > maxBottom) {
#line 3508
                maxBottom = (int )(pArray2 + pin)->xloc;
#line 3509
                maxBpin = (pArray2 + pin)->pin;
              }
            }
          }
#line 3499
          pin ++;
        }
#line 3513
        sepT = 1000000000;
#line 3514
        sepB = 1000000000;
#line 3515
        otherTpin = 0;
#line 3516
        otherBpin = 0;
#line 3517
        pin = 1;
#line 3517
        while (pin <= (int )(groupArray + group1)->numPins) {
#line 3518
          if ((int )(pArray1 + pin)->top == 1) {
            goto _L___12;
          } else {
#line 3518
            if ((int )(pArray1 + pin)->top == 0) {
              _L___12: /* CIL Label */ 
#line 3519
              if ((int )(pArray1 + pin)->xloc - maxTop >= 0) {
#line 3519
                tmp___2 = (int )(pArray1 + pin)->xloc - maxTop;
              } else {
#line 3519
                tmp___2 = - ((int )(pArray1 + pin)->xloc - maxTop);
              }
#line 3519
              if (tmp___2 < sepT) {
#line 3520
                otherTpin = (pArray1 + pin)->pin;
#line 3521
                minTop = (int )(pArray1 + pin)->xloc;
#line 3522
                if (minTop - maxTop >= 0) {
#line 3522
                  sepT = minTop - maxTop;
                } else {
#line 3522
                  sepT = - (minTop - maxTop);
                }
              }
            }
          }
#line 3525
          if ((int )(pArray1 + pin)->top == -1) {
            goto _L___13;
          } else {
#line 3525
            if ((int )(pArray1 + pin)->top == 0) {
              _L___13: /* CIL Label */ 
#line 3526
              if ((int )(pArray1 + pin)->xloc - maxBottom >= 0) {
#line 3526
                tmp___3 = (int )(pArray1 + pin)->xloc - maxBottom;
              } else {
#line 3526
                tmp___3 = - ((int )(pArray1 + pin)->xloc - maxBottom);
              }
#line 3526
              if (tmp___3 < sepB) {
#line 3527
                otherBpin = (pArray1 + pin)->pin;
#line 3528
                minBottom = (int )(pArray1 + pin)->xloc;
#line 3529
                if (minBottom - maxBottom >= 0) {
#line 3529
                  sepB = minBottom - maxBottom;
                } else {
#line 3529
                  sepB = - (minBottom - maxBottom);
                }
              }
            }
          }
#line 3517
          pin ++;
        }
#line 3533
        if (maxTpin != 0) {
#line 3533
          if (otherTpin != 0) {
#line 3533
            if (block1 < numChans) {
#line 3533
              if (maxBpin != 0) {
#line 3533
                if (otherBpin != 0) {
#line 3533
                  if (maxBpin != 0) {
#line 3533
                    if (otherBpin != 0) {
#line 3533
                      if (maxBottom != minBottom) {
                        _L___18: /* CIL Label */ 
#line 3537
                        if (maxBpin != 0) {
#line 3537
                          if (otherBpin != 0) {
#line 3537
                            if (block1 > 0) {
#line 3537
                              if (maxTop != minTop) {
#line 3540
                                fprintf(tw, "segment switchable %d\n", key_flag);
#line 3541
                                fprintf(tw, "top channel %d\n", block1 + 1);
#line 3542
                                if (maxTop <= minTop) {
#line 3543
                                  p1 = maxTpin;
#line 3544
                                  p2 = otherTpin;
                                } else {
#line 3546
                                  p1 = otherTpin;
#line 3547
                                  p2 = maxTpin;
                                }
#line 3549
                                fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, ltop,
                                        rtop);
#line 3551
                                fprintf(tw, "bottom channel %d\n", block1);
#line 3552
                                if (maxBottom <= minBottom) {
#line 3553
                                  p1 = maxBpin;
#line 3554
                                  p2 = otherBpin;
                                } else {
#line 3556
                                  p1 = otherBpin;
#line 3557
                                  p2 = maxBpin;
                                }
#line 3559
                                fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, lbot,
                                        rbot);
                              } else {
                                goto _L___16;
                              }
                            } else {
                              goto _L___16;
                            }
                          } else {
                            goto _L___16;
                          }
                        } else {
                          _L___16: /* CIL Label */ 
#line 3562
                          fprintf(tw, "segment channel %d\n", block1 + 1);
#line 3563
                          if (maxTop <= minTop) {
#line 3564
                            p1 = maxTpin;
#line 3565
                            p2 = otherTpin;
                          } else {
#line 3567
                            p1 = otherTpin;
#line 3568
                            p2 = maxTpin;
                          }
#line 3570
                          fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, ltop, rtop);
                        }
                      } else {
                        goto _L___20;
                      }
                    } else {
                      goto _L___20;
                    }
                  } else {
                    goto _L___20;
                  }
                } else {
                  goto _L___18;
                }
              } else {
                goto _L___18;
              }
            } else {
              goto _L___20;
            }
          } else {
            goto _L___20;
          }
        } else {
          _L___20: /* CIL Label */ 
#line 3573
          if (maxBpin != 0) {
#line 3573
            if (otherBpin != 0) {
#line 3575
              fprintf(tw, "segment channel %d\n", block1);
#line 3576
              if (maxBottom <= minBottom) {
#line 3577
                p1 = maxBpin;
#line 3578
                p2 = otherBpin;
              } else {
#line 3580
                p1 = otherBpin;
#line 3581
                p2 = maxBpin;
              }
#line 3583
              fprintf(tw, "pin1 %d  pin2 %d %d %d\n", p1, p2, lbot, rbot);
            }
          }
        }
      }
    } else {
#line 3588
      minX = 1000000000;
#line 3589
      minP1 = 0;
#line 3590
      minP2 = 0;
#line 3591
      if (block1 > block2) {
#line 3592
        pin1 = 1;
#line 3592
        while (pin1 <= (int )(groupArray + group1)->numPins) {
#line 3593
          if ((int )(pArray1 + pin1)->top == -1) {
            goto _L___22;
          } else {
#line 3593
            if ((int )(pArray1 + pin1)->top == 0) {
              _L___22: /* CIL Label */ 
#line 3595
              pin2 = 1;
#line 3596
              while (pin2 <= (int )(groupArray + group2)->numPins) {
#line 3597
                if ((int )(pArray2 + pin2)->top == 1) {
                  goto _L___21;
                } else {
#line 3597
                  if ((int )(pArray2 + pin2)->top == 0) {
                    _L___21: /* CIL Label */ 
#line 3599
                    if ((int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc >= 0) {
#line 3599
                      tmp___4 = (int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc;
                    } else {
#line 3599
                      tmp___4 = - ((int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc);
                    }
#line 3599
                    if (tmp___4 < minX) {
#line 3601
                      left___0 = (int )(pArray1 + pin1)->xloc;
#line 3602
                      right = (int )(pArray2 + pin2)->xloc;
#line 3603
                      if (left___0 - right >= 0) {
#line 3603
                        minX = left___0 - right;
                      } else {
#line 3603
                        minX = - (left___0 - right);
                      }
#line 3604
                      minP1 = (pArray1 + pin1)->pin;
#line 3605
                      minP2 = (pArray2 + pin2)->pin;
                    }
                  }
                }
#line 3596
                pin2 ++;
              }
            }
          }
#line 3592
          pin1 ++;
        }
#line 3611
        if (minP1 != 0) {
#line 3611
          if (minP2 != 0) {
#line 3612
            fprintf(tw, "segment channel %d\n", block1);
#line 3613
            if (left___0 > right) {
#line 3614
              fprintf(tw, " pin1 %d  pin2 %d %d %d\n", minP2, minP1, ltop, rtop);
            } else {
#line 3617
              fprintf(tw, " pin1 %d  pin2 %d %d %d\n", minP1, minP2, ltop, rtop);
            }
          }
        }
      } else {
#line 3622
        pin1 = 1;
#line 3623
        while (pin1 <= (int )(groupArray + group1)->numPins) {
#line 3624
          if ((int )(pArray1 + pin1)->top == 1) {
            goto _L___24;
          } else {
#line 3624
            if ((int )(pArray1 + pin1)->top == 0) {
              _L___24: /* CIL Label */ 
#line 3626
              pin2 = 1;
#line 3627
              while (pin2 <= (int )(groupArray + group2)->numPins) {
#line 3628
                if ((int )(pArray2 + pin2)->top == -1) {
                  goto _L___23;
                } else {
#line 3628
                  if ((int )(pArray2 + pin2)->top == 0) {
                    _L___23: /* CIL Label */ 
#line 3630
                    if ((int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc >= 0) {
#line 3630
                      tmp___5 = (int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc;
                    } else {
#line 3630
                      tmp___5 = - ((int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc);
                    }
#line 3630
                    if (tmp___5 < minX) {
#line 3632
                      left___0 = (int )(pArray1 + pin1)->xloc;
#line 3633
                      right = (int )(pArray2 + pin2)->xloc;
#line 3634
                      if (left___0 - right >= 0) {
#line 3634
                        minX = left___0 - right;
                      } else {
#line 3634
                        minX = - (left___0 - right);
                      }
#line 3635
                      minP1 = (pArray1 + pin1)->pin;
#line 3636
                      minP2 = (pArray2 + pin2)->pin;
                    }
                  }
                }
#line 3627
                pin2 ++;
              }
            }
          }
#line 3623
          pin1 ++;
        }
#line 3642
        if (minP1 != 0) {
#line 3642
          if (minP2 != 0) {
#line 3643
            fprintf(tw, "segment channel %d\n", block2);
#line 3644
            if (left___0 > right) {
#line 3645
              fprintf(tw, " pin1 %d  pin2 %d %d %d\n", minP2, minP1, ltop, rtop);
            } else {
#line 3648
              fprintf(tw, " pin1 %d  pin2 %d %d %d\n", minP1, minP2, ltop, rtop);
            }
          }
        }
      }
    }
  }
#line 3655
  return 0;
}
}
#line 3665 "D:/a/test/300.c"
double ckt_size_factor  ;
#line 4115
int RtoB(int row___0 , int from ) ;
#line 3666 "D:/a/test/300.c"
int configure(void) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3668
  config1();
#line 3669
  xshift = 0;
#line 3670
  yshift = 0;
#line 3671
  zxshift = 0;
#line 3672
  zyshift = 0;
#line 3673
  pad = numcells + 1;
#line 3673
  while (pad <= numcells + numterms) {
#line 3674
    if ((int )(*(carray + pad))->padside == 4) {
#line 3675
      count = 1;
#line 3676
      height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3678
      width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3680
      pad ++;
#line 3680
      while (pad <= numcells + numterms) {
#line 3681
        if ((int )(*(carray + pad))->padside != 4) {
#line 3682
          break;
        }
#line 3684
        count ++;
#line 3685
        if ((int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom > height) {
#line 3687
          height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
        }
#line 3690
        width += (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3680
        pad ++;
      }
#line 3693
      maxHeight = height;
#line 3694
      if (*(fixLRBT + 2) == 0) {
#line 3695
        space = coreWidth - width;
#line 3696
        separation = space / (count + 1);
#line 3697
        if (separation < 0) {
#line 3698
          separation = 0;
#line 3699
          if (space >= 0) {
#line 3699
            zxshift = space;
          } else {
#line 3699
            zxshift = - space;
          }
        }
      } else {
#line 3702
        if (coreWidth >= width) {
#line 3702
          space = coreWidth;
        } else {
#line 3702
          space = width;
        }
      }
#line 3705
      yshift = maxHeight + extraSpace;
#line 3706
      row = 1;
#line 3706
      while (row <= numRows) {
#line 3707
        (rowArray + row)->ypos += yshift;
#line 3706
        row ++;
      }
#line 3709
      pad = numcells + 1;
#line 3709
      while (pad <= numcells + numterms) {
#line 3710
        if ((int )(*(carray + pad))->padside == 4) {
#line 3711
          height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3713
          width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3715
          if (*(fixLRBT + 2) == 0) {
#line 3716
            (*(carray + pad))->cxcenter = separation + width / 2;
          } else {
#line 3718
            (*(carray + pad))->cxcenter = (int )(*(padspace + (pad - numcells)) * (double )space);
          }
#line 3721
          (*(carray + pad))->cycenter = (maxHeight - height / 2) - 1;
#line 3722
          last = separation + width;
#line 3723
          pad ++;
#line 3723
          while (pad <= numcells + numterms) {
#line 3724
            if ((int )(*(carray + pad))->padside != 4) {
#line 3725
              break;
            }
#line 3727
            height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3729
            width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3731
            if (*(fixLRBT + 2) == 0) {
#line 3732
              (*(carray + pad))->cxcenter = (last + separation) + width / 2;
            } else {
#line 3735
              (*(carray + pad))->cxcenter = (int )(*(padspace + (pad - numcells)) * (double )space);
            }
#line 3738
            (*(carray + pad))->cycenter = (maxHeight - height / 2) - 1;
#line 3740
            last += separation + width;
#line 3723
            pad ++;
          }
        }
#line 3709
        pad ++;
      }
    }
#line 3673
    pad ++;
  }
#line 3746
  pad = numcells + 1;
#line 3746
  while (pad <= numcells + numterms) {
#line 3747
    if ((int )(*(carray + pad))->padside == 2) {
#line 3748
      count = 1;
#line 3749
      width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3751
      pad ++;
#line 3751
      while (pad <= numcells + numterms) {
#line 3752
        if ((int )(*(carray + pad))->padside != 2) {
#line 3753
          break;
        }
#line 3755
        count ++;
#line 3756
        width += (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3751
        pad ++;
      }
#line 3759
      if (*(fixLRBT + 3) == 0) {
#line 3760
        space = coreWidth - width;
#line 3761
        separation = space / (count + 1);
#line 3762
        if (separation < 0) {
#line 3763
          separation = 0;
#line 3764
          if (space >= 0) {
#line 3764
            tmp = space;
          } else {
#line 3764
            tmp = - space;
          }
#line 3764
          if (tmp > zxshift) {
#line 3765
            if (space >= 0) {
#line 3765
              zxshift = space;
            } else {
#line 3765
              zxshift = - space;
            }
          }
        }
      } else {
#line 3769
        if (coreWidth >= width) {
#line 3769
          space = coreWidth;
        } else {
#line 3769
          space = width;
        }
      }
#line 3772
      coreTop = (((rowArray + numRows)->ypos + rowHeight / 2) + extraSpace) + mttshift;
#line 3774
      pad = numcells + 1;
#line 3774
      while (pad <= numcells + numterms) {
#line 3775
        if ((int )(*(carray + pad))->padside == 2) {
#line 3776
          height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3778
          width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3780
          if (*(fixLRBT + 3) == 0) {
#line 3781
            (*(carray + pad))->cxcenter = separation + width / 2;
          } else {
#line 3783
            (*(carray + pad))->cxcenter = (int )(*(padspace + (pad - numcells)) * (double )space);
          }
#line 3786
          (*(carray + pad))->cycenter = coreTop + height / 2;
#line 3787
          last = separation + width;
#line 3788
          pad ++;
#line 3788
          while (pad <= numcells + numterms) {
#line 3789
            if ((int )(*(carray + pad))->padside != 2) {
#line 3790
              break;
            }
#line 3792
            height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3794
            width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3796
            if (*(fixLRBT + 3) == 0) {
#line 3797
              (*(carray + pad))->cxcenter = (last + separation) + width / 2;
            } else {
#line 3800
              (*(carray + pad))->cxcenter = (int )(*(padspace + (pad - numcells)) * (double )space);
            }
#line 3803
            (*(carray + pad))->cycenter = coreTop + height / 2;
#line 3804
            last += separation + width;
#line 3788
            pad ++;
          }
        }
#line 3774
        pad ++;
      }
    }
#line 3746
    pad ++;
  }
#line 3810
  pad = numcells + 1;
#line 3810
  while (pad <= numcells + numterms) {
#line 3811
    if ((int )(*(carray + pad))->padside == 1) {
#line 3812
      count = 1;
#line 3813
      height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3815
      width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3817
      pad ++;
#line 3817
      while (pad <= numcells + numterms) {
#line 3818
        if ((int )(*(carray + pad))->padside != 1) {
#line 3819
          break;
        }
#line 3821
        count ++;
#line 3822
        if ((int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left > width) {
#line 3824
          width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
        }
#line 3827
        height += (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3817
        pad ++;
      }
#line 3830
      maxWidth = width;
#line 3831
      if (*(fixLRBT + 0) == 0) {
#line 3832
        space = coreHeight - height;
#line 3833
        separation = space / (count + 1);
#line 3834
        if (separation < 0) {
#line 3835
          separation = 0;
#line 3836
          if (space >= 0) {
#line 3836
            zyshift = space;
          } else {
#line 3836
            zyshift = - space;
          }
        }
      } else {
#line 3839
        if (coreHeight >= height) {
#line 3839
          space = coreHeight;
        } else {
#line 3839
          space = height;
        }
      }
#line 3842
      xshift = maxWidth + extraSpace;
#line 3843
      row = 1;
#line 3843
      while (row <= numRows) {
#line 3844
        (rowArray + row)->startx += xshift;
#line 3845
        (rowArray + row)->endx += xshift;
#line 3846
        if ((rowArray + row)->endx1 > 0) {
#line 3847
          (rowArray + row)->endx1 += xshift;
#line 3848
          (rowArray + row)->startx2 += xshift;
        }
#line 3843
        row ++;
      }
#line 3851
      pad = numcells + 1;
#line 3851
      while (pad <= numcells + numterms) {
#line 3852
        if ((int )(*(carray + pad))->padside == 1) {
#line 3853
          height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3855
          width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3857
          if (*(fixLRBT + 0) == 0) {
#line 3858
            (*(carray + pad))->cycenter = ((((rowArray + 1)->ypos - rowHeight / 2) + separation) + height / 2) - mbbshift;
          } else {
#line 3862
            (*(carray + pad))->cycenter = (int )((double )(((rowArray + 1)->ypos - rowHeight / 2) - mbbshift) + *(padspace + (pad - numcells)) * (double )space);
          }
#line 3866
          (*(carray + pad))->cxcenter = (maxWidth - width / 2) - 1;
#line 3867
          last = ((((rowArray + 1)->ypos - rowHeight / 2) + separation) + height) - mbbshift;
#line 3869
          pad ++;
#line 3869
          while (pad <= numcells + numterms) {
#line 3870
            if ((int )(*(carray + pad))->padside != 1) {
#line 3871
              break;
            }
#line 3873
            height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3875
            width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3877
            if (*(fixLRBT + 0) == 0) {
#line 3878
              (*(carray + pad))->cycenter = (last + separation) + height / 2;
            } else {
#line 3881
              (*(carray + pad))->cycenter = (int )((double )(((rowArray + 1)->ypos - rowHeight / 2) - mbbshift) + *(padspace + (pad - numcells)) * (double )space);
            }
#line 3885
            (*(carray + pad))->cxcenter = (maxWidth - width / 2) - 1;
#line 3887
            last += separation + height;
#line 3869
            pad ++;
          }
        }
#line 3851
        pad ++;
      }
    }
#line 3810
    pad ++;
  }
#line 3893
  pad = numcells + 1;
#line 3893
  while (pad <= numcells + numterms) {
#line 3894
    if ((int )(*(carray + pad))->padside == 3) {
#line 3895
      count = 1;
#line 3896
      height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3898
      pad ++;
#line 3898
      while (pad <= numcells + numterms) {
#line 3899
        if ((int )(*(carray + pad))->padside != 3) {
#line 3900
          break;
        }
#line 3902
        count ++;
#line 3903
        height += (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3898
        pad ++;
      }
#line 3906
      if (*(fixLRBT + 1) == 0) {
#line 3907
        space = coreHeight - height;
#line 3908
        separation = space / (count + 1);
#line 3909
        if (separation < 0) {
#line 3910
          separation = 0;
#line 3911
          if (space >= 0) {
#line 3911
            tmp___0 = space;
          } else {
#line 3911
            tmp___0 = - space;
          }
#line 3911
          if (tmp___0 > zyshift) {
#line 3912
            if (space >= 0) {
#line 3912
              zyshift = space;
            } else {
#line 3912
              zyshift = - space;
            }
          }
        }
      } else {
#line 3916
        if (coreHeight >= height) {
#line 3916
          space = coreHeight;
        } else {
#line 3916
          space = height;
        }
      }
#line 3918
      coreRite = (coreWidth + xshift) + extraSpace;
#line 3919
      pad = numcells + 1;
#line 3919
      while (pad <= numcells + numterms) {
#line 3920
        if ((int )(*(carray + pad))->padside == 3) {
#line 3921
          height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3923
          width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3925
          if (*(fixLRBT + 1) == 0) {
#line 3926
            (*(carray + pad))->cycenter = ((((rowArray + 1)->ypos - rowHeight / 2) + separation) + height / 2) - mbbshift;
          } else {
#line 3930
            (*(carray + pad))->cycenter = (int )((double )(((rowArray + 1)->ypos - rowHeight / 2) - mbbshift) + *(padspace + (pad - numcells)) * (double )space);
          }
#line 3934
          (*(carray + pad))->cxcenter = coreRite + width / 2;
#line 3935
          last = ((((rowArray + 1)->ypos - rowHeight / 2) + separation) + height) - mbbshift;
#line 3937
          pad ++;
#line 3937
          while (pad <= numcells + numterms) {
#line 3938
            if ((int )(*(carray + pad))->padside != 3) {
#line 3939
              break;
            }
#line 3941
            height = (int )((*(carray + pad))->tileptr)->top - (int )((*(carray + pad))->tileptr)->bottom;
#line 3943
            width = (int )((*(carray + pad))->tileptr)->right - (int )((*(carray + pad))->tileptr)->left;
#line 3945
            if (*(fixLRBT + 1) == 0) {
#line 3946
              (*(carray + pad))->cycenter = (last + separation) + height / 2;
            } else {
#line 3949
              (*(carray + pad))->cycenter = (int )((double )(((rowArray + 1)->ypos - rowHeight / 2) - mbbshift) + *(padspace + (pad - numcells)) * (double )space);
            }
#line 3953
            (*(carray + pad))->cxcenter = coreRite + width / 2;
#line 3954
            last += separation + height;
#line 3937
            pad ++;
          }
        }
#line 3919
        pad ++;
      }
    }
#line 3893
    pad ++;
  }
#line 3960
  macro = 1;
#line 3960
  while (macro <= numMacro) {
#line 3961
    pad = *(padArray + macro);
#line 3962
    (*(carray + pad))->cxcenter = (macroArray + macro)->mx + xshift;
#line 3963
    (*(carray + pad))->cycenter = ((macroArray + macro)->my + yshift) + mbbshift;
#line 3960
    macro ++;
  }
#line 3966
  pad = numcells + 1;
#line 3966
  while (pad <= numcells + numterms) {
#line 3967
    if ((int )(*(carray + pad))->padside == 4) {
#line 3968
      (*(carray + pad))->cxcenter += xshift;
    } else {
#line 3967
      if ((int )(*(carray + pad))->padside == 2) {
#line 3968
        (*(carray + pad))->cxcenter += xshift;
      } else {
#line 3969
        if ((int )(*(carray + pad))->padside == 14) {
#line 3971
          (*(carray + pad))->cxcenter += xshift;
#line 3972
          (*(carray + pad))->cycenter += yshift;
        } else {
#line 3969
          if ((int )(*(carray + pad))->padside == 15) {
#line 3971
            (*(carray + pad))->cxcenter += xshift;
#line 3972
            (*(carray + pad))->cycenter += yshift;
          }
        }
      }
    }
#line 3966
    pad ++;
  }
#line 3975
  row = 1;
#line 3975
  while (row <= numRows) {
#line 3976
    (rowArray + row)->startx += zxshift / 2;
#line 3977
    (rowArray + row)->endx += zxshift / 2;
#line 3978
    if ((rowArray + row)->endx1 > 0) {
#line 3979
      (rowArray + row)->endx1 += zxshift / 2;
#line 3980
      (rowArray + row)->startx2 += zxshift / 2;
    }
#line 3975
    row ++;
  }
#line 3983
  macro = 1;
#line 3983
  while (macro <= numMacro) {
#line 3984
    pad = *(padArray + macro);
#line 3985
    (*(carray + pad))->cxcenter += zxshift / 2;
#line 3983
    macro ++;
  }
#line 3987
  pad = numcells + 1;
#line 3987
  while (pad <= numcells + numterms) {
#line 3988
    if ((int )(*(carray + pad))->padside == 3) {
#line 3989
      (*(carray + pad))->cxcenter += zxshift;
    } else {
#line 3990
      if ((int )(*(carray + pad))->padside == 14) {
#line 3992
        (*(carray + pad))->cxcenter += zxshift / 2;
      } else {
#line 3990
        if ((int )(*(carray + pad))->padside == 15) {
#line 3992
          (*(carray + pad))->cxcenter += zxshift / 2;
        }
      }
    }
#line 3987
    pad ++;
  }
#line 3995
  yshift = (maxHeight + rowHeight) + extraSpace;
#line 3996
  row = 1;
#line 3996
  while (row <= numRows) {
#line 3997
    (rowArray + row)->ypos += zyshift / 2;
#line 3996
    row ++;
  }
#line 3999
  macro = 1;
#line 3999
  while (macro <= numMacro) {
#line 4000
    pad = *(padArray + macro);
#line 4001
    (*(carray + pad))->cycenter += zyshift / 2;
#line 3999
    macro ++;
  }
#line 4003
  pad = numcells + 1;
#line 4003
  while (pad <= numcells + numterms) {
#line 4004
    if ((int )(*(carray + pad))->padside == 2) {
#line 4005
      (*(carray + pad))->cycenter += zyshift;
    } else {
#line 4006
      if ((int )(*(carray + pad))->padside == 14) {
#line 4008
        (*(carray + pad))->cycenter += zyshift / 2;
      } else {
#line 4006
        if ((int )(*(carray + pad))->padside == 15) {
#line 4008
          (*(carray + pad))->cycenter += zyshift / 2;
        }
      }
    }
#line 4003
    pad ++;
  }
#line 4011
  block = 0;
#line 4012
  row = 1;
#line 4012
  while (row <= numRows) {
#line 4013
    block ++;
#line 4014
    if ((rowArray + row)->endx1 > 0) {
#line 4015
      block ++;
    }
#line 4012
    row ++;
  }
#line 4018
  totalBlock = block;
#line 4019
  oldbarray = barray;
#line 4020
  tmp___1 = (int )safe_malloc((unsigned int )(totalBlock + 1) * sizeof(int ));
#line 4020
  blkToRow = (int *)tmp___1;
#line 4021
  tmp___2 = (int )safe_malloc((unsigned int )(totalBlock + 1) * sizeof(BBOXPTR ));
#line 4021
  barray = (BBOXPTR *)tmp___2;
#line 4022
  block = 1;
#line 4022
  while (block <= totalBlock) {
#line 4023
    tmp___3 = (int )safe_malloc(sizeof(BBOX ));
#line 4023
    *(barray + block) = (struct blockbox *)tmp___3;
#line 4022
    block ++;
  }
#line 4025
  block = 0;
#line 4026
  row = 1;
#line 4026
  while (row <= numRows) {
#line 4027
    boxptr = *(oldbarray + row);
#line 4028
    if ((rowArray + row)->endx1 > 0) {
#line 4029
      block ++;
#line 4030
      *(blkToRow + block) = row;
#line 4031
      (*(barray + block))->bxcenter = ((rowArray + row)->startx + (rowArray + row)->endx1) / 2;
#line 4033
      (*(barray + block))->bycenter = (rowArray + row)->ypos;
#line 4034
      (*(barray + block))->bleft = (short )((rowArray + row)->startx - (*(barray + block))->bxcenter);
#line 4036
      (*(barray + block))->bright = (short )((rowArray + row)->endx1 - (*(barray + block))->bxcenter);
#line 4038
      (*(barray + block))->bbottom = boxptr->bbottom;
#line 4039
      (*(barray + block))->btop = boxptr->btop;
#line 4040
      (*(barray + block))->bheight = (short )((int )boxptr->btop - (int )boxptr->bbottom);
#line 4041
      (*(barray + block))->blength = (short )((rowArray + row)->endx1 - (rowArray + row)->startx);
#line 4043
      (*(barray + block))->bclass = boxptr->bclass;
#line 4044
      (*(barray + block))->borient = boxptr->borient;
#line 4045
      (*(barray + block))->oldsize = (short)0;
#line 4046
      block ++;
#line 4047
      *(blkToRow + block) = row;
#line 4048
      (*(barray + block))->bxcenter = ((rowArray + row)->startx2 + (rowArray + row)->endx) / 2;
#line 4050
      (*(barray + block))->bycenter = (rowArray + row)->ypos;
#line 4051
      (*(barray + block))->bleft = (short )((rowArray + row)->startx2 - (*(barray + block))->bxcenter);
#line 4053
      (*(barray + block))->bright = (short )((rowArray + row)->endx - (*(barray + block))->bxcenter);
#line 4055
      (*(barray + block))->bbottom = boxptr->bbottom;
#line 4056
      (*(barray + block))->btop = boxptr->btop;
#line 4057
      (*(barray + block))->bheight = (short )((int )boxptr->btop - (int )boxptr->bbottom);
#line 4058
      (*(barray + block))->blength = (short )((rowArray + row)->endx - (rowArray + row)->startx2);
#line 4060
      (*(barray + block))->bclass = boxptr->bclass;
#line 4061
      (*(barray + block))->borient = boxptr->borient;
#line 4062
      ratio = (double )(*(barray + (block - 1)))->blength / (double )((int )(*(barray + (block - 1)))->blength + (int )(*(barray + block))->blength);
#line 4064
      (*(barray + block))->desire = (short )(1 + (int )((1.0 - ratio) * (double )(rowArray + row)->desiredL));
#line 4066
      (*(barray + (block - 1)))->desire = (short )(1 + (int )(ratio * (double )(rowArray + row)->desiredL));
#line 4068
      (*(barray + block))->oldsize = (short)0;
    } else {
#line 4070
      block ++;
#line 4071
      *(blkToRow + block) = row;
#line 4072
      (*(barray + block))->bxcenter = ((rowArray + row)->startx + (rowArray + row)->endx) / 2;
#line 4074
      (*(barray + block))->bycenter = (rowArray + row)->ypos;
#line 4075
      (*(barray + block))->bleft = (short )((rowArray + row)->startx - (*(barray + block))->bxcenter);
#line 4077
      (*(barray + block))->bright = (short )((rowArray + row)->endx - (*(barray + block))->bxcenter);
#line 4079
      (*(barray + block))->bbottom = boxptr->bbottom;
#line 4080
      (*(barray + block))->btop = boxptr->btop;
#line 4081
      (*(barray + block))->bheight = (short )((int )boxptr->btop - (int )boxptr->bbottom);
#line 4082
      (*(barray + block))->blength = (short )((rowArray + row)->endx - (rowArray + row)->startx);
#line 4084
      (*(barray + block))->bclass = boxptr->bclass;
#line 4085
      (*(barray + block))->borient = boxptr->borient;
#line 4086
      (*(barray + block))->desire = (short )(rowArray + row)->desiredL;
#line 4087
      (*(barray + block))->oldsize = (short)0;
    }
#line 4026
    row ++;
  }
#line 4090
  row = 1;
#line 4090
  while (row <= numblock) {
#line 4091
    safe_free(*(oldbarray + row));
#line 4090
    row ++;
  }
#line 4093
  safe_free(oldbarray);
#line 4094
  numblock = totalBlock;
#line 4095
  fprintf(fpo, "\n******************\nBLOCK DATA\n");
#line 4096
  desiredL = 0;
#line 4097
  block = 1;
#line 4097
  while (block <= numblock) {
#line 4098
    desiredL += (int )(*(barray + block))->desire;
#line 4099
    fprintf(fpo, "block:%d desire:%d\n", block, (*(barray + block))->desire);
#line 4097
    block ++;
  }
#line 4101
  fprintf(fpo, "Total Desired Length: %d\n", desiredL);
#line 4102
  ckt_size_factor = (double )desiredL;
#line 4103
  tmp___4 = (int )safe_malloc((unsigned int )(numblock + 1) * sizeof(int ));
#line 4103
  filledTo = (int *)tmp___4;
#line 4104
  tmp___5 = (int )safe_malloc((unsigned int )(numblock + 1) * sizeof(int ));
#line 4104
  endRow = (int *)tmp___5;
#line 4105
  row = 1;
#line 4105
  while (row <= numblock) {
#line 4106
    *(filledTo + row) = (*(barray + row))->bxcenter + (int )(*(barray + row))->bleft;
#line 4107
    *(endRow + row) = (*(barray + row))->bxcenter + (int )(*(barray + row))->bright;
#line 4105
    row ++;
  }
#line 4109
  cell = 1;
#line 4109
  while (cell <= numcells) {
#line 4110
    cellptr = *(carray + cell);
#line 4111
    row = (int )cellptr->cblock;
#line 4112
    if (row == 0) {
      goto __Cont;
    }
#line 4115
    blk = RtoB(row, cellptr->cycenter);
#line 4116
    borient = (int )(*(barray + blk))->borient;
#line 4117
    cellptr->cblock = (short )blk;
#line 4118
    width = (int )(cellptr->tileptr)->right - (int )(cellptr->tileptr)->left;
#line 4119
    if (cellptr->cycenter > 0) {
#line 4120
      (*(carray + cell))->cxcenter = (((*(barray + blk))->bxcenter + (int )(*(barray + blk))->bleft) + cellptr->cxcenter) + width / 2;
#line 4123
      (*(carray + cell))->cycenter = (*(barray + blk))->bycenter;
    } else {
#line 4125
      (*(carray + cell))->cxcenter = (((*(barray + blk))->bxcenter + (int )(*(barray + blk))->bright) + cellptr->cxcenter) - (width - width / 2);
#line 4128
      (*(carray + cell))->cycenter = (*(barray + blk))->bycenter;
    }
#line 4130
    if (borient == 2) {
#line 4131
      cellptr->corient = (char)1;
    } else {
#line 4133
      cellptr->corient = (char)0;
    }
    __Cont: /* CIL Label */ 
#line 4109
    cell ++;
  }
#line 4136
  cell = 1;
#line 4136
  while (cell <= numcells) {
#line 4137
    if ((int )(*(carray + cell))->cblock != 0) {
      goto __Cont___0;
    }
#line 4140
    empty = -32000;
#line 4141
    row = 1;
#line 4141
    while (row <= numblock) {
#line 4142
      if (*(endRow + row) - *(filledTo + row) > empty) {
#line 4143
        empty = *(endRow + row) - *(filledTo + row);
#line 4144
        block = row;
      }
#line 4141
      row ++;
    }
#line 4147
    borient = (int )(*(barray + block))->borient;
#line 4148
    width = (int )((*(carray + cell))->tileptr)->right - (int )((*(carray + cell))->tileptr)->left;
#line 4149
    (*(carray + cell))->cblock = (short )block;
#line 4150
    if (borient > 0) {
#line 4151
      (*(carray + cell))->cxcenter = *(filledTo + block) + width / 2;
#line 4152
      (*(carray + cell))->cycenter = (*(barray + block))->bycenter;
#line 4153
      if (borient == 2) {
#line 4154
        (*(carray + cell))->corient = (char)1;
      } else {
#line 4156
        (*(carray + cell))->corient = (char)0;
      }
    } else {
#line 4159
      (*(carray + cell))->cycenter = *(filledTo + block) + width / 2;
#line 4160
      (*(carray + cell))->cxcenter = (*(barray + block))->bxcenter;
#line 4161
      if (borient == -2) {
#line 4162
        (*(carray + cell))->corient = (char)4;
      } else {
#line 4164
        (*(carray + cell))->corient = (char)7;
      }
    }
#line 4167
    *(filledTo + block) += width;
    __Cont___0: /* CIL Label */ 
#line 4136
    cell ++;
  }
#line 4169
  return 0;
}
}
#line 4171 "D:/a/test/300.c"
int RtoB(int row___0 , int from ) 
{ int y ;
  int block___0 ;
  int block1 ;
  int block2 ;
  int endx1 ;
  int startx2 ;

  {
#line 4175
  y = (rowArray + row___0)->ypos;
#line 4176
  block1 = 0;
#line 4177
  block2 = 0;
#line 4178
  block___0 = 1;
#line 4178
  while (block___0 <= numblock) {
#line 4179
    if ((*(barray + block___0))->bycenter == y) {
#line 4180
      block1 = block___0;
#line 4181
      break;
    }
#line 4178
    block___0 ++;
  }
#line 4184
  block___0 ++;
#line 4184
  while (block___0 <= numblock) {
#line 4185
    if ((*(barray + block___0))->bycenter == y) {
#line 4186
      block2 = block___0;
#line 4187
      break;
    }
#line 4184
    block___0 ++;
  }
#line 4190
  if (block1 == 0) {
#line 4191
    fprintf(fpo, "RtoB failed to find block corresponding");
#line 4192
    fprintf(fpo, " to row:%d\n", row___0);
#line 4193
    exit(1);
  }
#line 4195
  if (block2 == 0) {
#line 4196
    block___0 = block1;
  } else {
#line 4198
    endx1 = (*(barray + block1))->bxcenter + (int )(*(barray + block1))->bright;
#line 4199
    startx2 = (*(barray + block2))->bxcenter + (int )(*(barray + block2))->bleft;
#line 4200
    if (from > 0) {
#line 4201
      if (endx1 < startx2) {
#line 4202
        block___0 = block1;
      } else {
#line 4204
        block___0 = block2;
      }
    } else {
#line 4207
      if (startx2 > endx1) {
#line 4208
        block___0 = block2;
      } else {
#line 4210
        block___0 = block1;
      }
    }
  }
#line 4214
  return (block___0);
}
}
#line 4219 "D:/a/test/300.c"
int old_feed_length  =    0;
#line 4220 "D:/a/test/300.c"
int configuref(int feed_length ) 
{ CBOXPTR padptr ;
  int core_left ;
  int core_right ;
  int core_span ;
  int row___0 ;
  int pad___0 ;
  int right ;
  int shift_amount ;

  {
#line 4226
  shift_amount = feed_length / numRows - old_feed_length / numRows;
#line 4227
  if (shift_amount == 0) {
#line 4228
    row___0 = 1;
#line 4228
    while (row___0 <= numRows) {
#line 4229
      (*(barray + row___0))->oldsize = (short)0;
#line 4228
      row___0 ++;
    }
#line 4231
    return 0;
  }
#line 4233
  core_right = 0;
#line 4234
  core_left = 10000000;
#line 4235
  row___0 = 1;
#line 4235
  while (row___0 <= numRows) {
#line 4236
    (*(barray + row___0))->bright = (short )((int )(*(barray + row___0))->bright + shift_amount);
#line 4237
    (*(barray + row___0))->blength = (short )((int )(*(barray + row___0))->blength + shift_amount);
#line 4238
    (*(barray + row___0))->desire = (short )((int )(*(barray + row___0))->desire + shift_amount);
#line 4239
    (*(barray + row___0))->oldsize = (short)0;
#line 4240
    (rowArray + row___0)->endx += shift_amount;
#line 4241
    if ((rowArray + row___0)->startx < core_left) {
#line 4242
      core_left = (rowArray + row___0)->startx;
    }
#line 4244
    if ((rowArray + row___0)->endx > core_right) {
#line 4245
      core_right = (rowArray + row___0)->endx;
    }
#line 4235
    row___0 ++;
  }
#line 4248
  core_span = core_right - core_left;
#line 4249
  pad___0 = numcells + 1;
#line 4249
  while (pad___0 <= numcells + numterms) {
#line 4250
    padptr = *(carray + pad___0);
#line 4251
    if ((int )padptr->padside == 3) {
#line 4253
      padptr->cxcenter += shift_amount;
    } else {
#line 4251
      if ((int )padptr->padside == 10) {
#line 4253
        padptr->cxcenter += shift_amount;
      } else {
#line 4251
        if ((int )padptr->padside == 6) {
#line 4253
          padptr->cxcenter += shift_amount;
        } else {
#line 4251
          if ((int )padptr->padside == 8) {
#line 4253
            padptr->cxcenter += shift_amount;
          } else {
#line 4254
            if ((int )padptr->padside == 2) {
#line 4256
              right = (padptr->cxcenter + (int )(padptr->tileptr)->right) - core_left;
#line 4257
              padptr->cxcenter += (int )(((double )right / (double )core_span) * (double )shift_amount);
            } else {
#line 4254
              if ((int )padptr->padside == 4) {
#line 4256
                right = (padptr->cxcenter + (int )(padptr->tileptr)->right) - core_left;
#line 4257
                padptr->cxcenter += (int )(((double )right / (double )core_span) * (double )shift_amount);
              } else {
#line 4254
                if ((int )padptr->padside == 14) {
#line 4256
                  right = (padptr->cxcenter + (int )(padptr->tileptr)->right) - core_left;
#line 4257
                  padptr->cxcenter += (int )(((double )right / (double )core_span) * (double )shift_amount);
                } else {
#line 4254
                  if ((int )padptr->padside == 15) {
#line 4256
                    right = (padptr->cxcenter + (int )(padptr->tileptr)->right) - core_left;
#line 4257
                    padptr->cxcenter += (int )(((double )right / (double )core_span) * (double )shift_amount);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 4249
    pad___0 ++;
  }
#line 4262
  old_feed_length = feed_length;
#line 4263
  return 0;
}
}
#line 4270
int countf(void) ;
#line 4272
int findcostf(void) ;
#line 4267 "D:/a/test/300.c"
int controlf(void) 
{ int feed_length ;

  {
#line 4270
  feed_length = countf();
#line 4271
  configuref(feed_length);
#line 4272
  funccost = findcostf();
#line 4273
  return (feed_length / fdWidth);
}
}
#line 4288
int prep_feed_count_1(void) ;
#line 4295
int insert_row(int flag ) ;
#line 4297
int prep_feed_count(void) ;
#line 4324
int feed_situation(int row___0 , int net ) ;
#line 4278 "D:/a/test/300.c"
int countf(void) 
{ NBOXPTR netptr ;
  CBOXPTR cellptr___0 ;
  int check ;
  int a___0 ;
  int value ;
  int net ;
  int i ;
  int row___0 ;
  int toprow ;
  int botrow ;
  int TOP_ROW_FOR_NET ;
  int orig_toprow ;
  int orig_botrow ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4286
  if ((int )num_calls == 0) {
#line 4287
    num_calls = (short)1;
#line 4288
    prep_feed_count_1();
#line 4289
    tmp = (int )safe_malloc((unsigned int )(numRows + 2) * sizeof(short *));
#line 4289
    row_map = (short **)tmp;
#line 4291
    row___0 = 0;
#line 4291
    while (row___0 <= numRows + 1) {
#line 4292
      tmp___0 = (int )safe_malloc(3U * sizeof(short ));
#line 4292
      *(row_map + row___0) = (short *)tmp___0;
#line 4291
      row___0 ++;
    }
#line 4295
    insert_row(0);
  } else {
#line 4297
    prep_feed_count();
#line 4298
    insert_row(1);
  }
#line 4300
  net = 1;
#line 4300
  while (net <= numnets) {
#line 4301
    netptr = (*(netarray + net))->netptr;
#line 4301
    if ((unsigned int )netptr == (unsigned int )((struct netbox *)((void *)0))) {
      goto __Cont;
    }
#line 4304
    i = 0;
#line 4304
    while (i <= numRows + 1) {
#line 4305
      *(*(row_map + i) + 1) = (short)-1000;
#line 4306
      *(*(row_map + i) + 2) = (short)-2;
#line 4304
      i ++;
    }
#line 4308
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 4309
      cellptr___0 = *(carray + netptr->cell);
#line 4310
      if ((int )netptr->cell > numcells) {
#line 4310
        if ((int )cellptr___0->padside == 1) {
          goto __Cont___0;
        } else {
#line 4310
          if ((int )cellptr___0->padside == 9) {
            goto __Cont___0;
          } else {
#line 4310
            if ((int )cellptr___0->padside == 5) {
              goto __Cont___0;
            } else {
#line 4310
              if ((int )cellptr___0->padside == 7) {
                goto __Cont___0;
              } else {
#line 4310
                if ((int )cellptr___0->padside == 3) {
                  goto __Cont___0;
                } else {
#line 4310
                  if ((int )cellptr___0->padside == 10) {
                    goto __Cont___0;
                  } else {
#line 4310
                    if ((int )cellptr___0->padside == 6) {
                      goto __Cont___0;
                    } else {
#line 4310
                      if ((int )cellptr___0->padside == 8) {
                        goto __Cont___0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 4321
      row___0 = (int )netptr->row;
#line 4322
      *(*(row_map + row___0) + 1) = (short )netptr->xpos;
#line 4323
      if ((int )*(*(row_map + row___0) + 2) == -2) {
#line 4324
        tmp___1 = feed_situation(row___0, net);
#line 4324
        *(*(row_map + row___0) + 2) = (short )tmp___1;
      }
      __Cont___0: /* CIL Label */ 
#line 4308
      netptr = netptr->nterm;
    }
#line 4328
    botrow = 0;
#line 4329
    toprow = numRows + 1;
#line 4330
    while (botrow <= numRows + 1) {
#line 4331
      if ((int )*(*(row_map + botrow) + 1) != -1000) {
#line 4332
        break;
      }
#line 4330
      botrow ++;
    }
#line 4335
    while (toprow >= 0) {
#line 4336
      if ((int )*(*(row_map + toprow) + 1) != -1000) {
#line 4337
        break;
      }
#line 4335
      toprow --;
    }
#line 4340
    orig_toprow = toprow;
#line 4341
    orig_botrow = botrow;
#line 4342
    netptr = (*(netarray + net))->netptr;
#line 4343
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 4344
      if ((int )netptr->cell <= numcells) {
        goto __Cont___1;
      }
#line 4347
      cellptr___0 = *(carray + netptr->cell);
#line 4348
      if ((int )cellptr___0->padside != 1) {
#line 4348
        if ((int )cellptr___0->padside != 9) {
#line 4348
          if ((int )cellptr___0->padside != 5) {
#line 4348
            if ((int )cellptr___0->padside != 7) {
#line 4348
              if ((int )cellptr___0->padside != 3) {
#line 4348
                if ((int )cellptr___0->padside != 10) {
#line 4348
                  if ((int )cellptr___0->padside != 6) {
#line 4348
                    if ((int )cellptr___0->padside != 8) {
                      goto __Cont___1;
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 4358
      row___0 = (int )netptr->row;
#line 4359
      if (row___0 <= orig_toprow) {
#line 4359
        if (row___0 >= orig_botrow) {
          goto __Cont___1;
        }
      }
#line 4362
      if (row___0 > toprow) {
#line 4363
        toprow = row___0;
      }
#line 4365
      if (row___0 < botrow) {
#line 4366
        botrow = row___0;
      }
#line 4368
      *(*(row_map + row___0) + 1) = (short )netptr->xpos;
#line 4369
      if ((int )*(*(row_map + row___0) + 2) == -2) {
#line 4370
        tmp___2 = feed_situation(row___0, net);
#line 4370
        *(*(row_map + row___0) + 2) = (short )tmp___2;
      }
      __Cont___1: /* CIL Label */ 
#line 4343
      netptr = netptr->nterm;
    }
#line 4373
    if (toprow != botrow) {
#line 4374
      row___0 = toprow;
#line 4375
      TOP_ROW_FOR_NET = 1;
#line 4376
      row___0 --;
#line 4376
      while (row___0 >= botrow) {
#line 4377
        if ((int )*(*(row_map + row___0) + 1) == -1000) {
          goto __Cont___2;
        }
#line 4380
        if (TOP_ROW_FOR_NET == 1) {
#line 4381
          if ((int )*(*(row_map + toprow) + 2) == 1) {
#line 4383
            (*(feeds_in_row + toprow)) ++;
#line 4384
            (*(xfeeds_in_row + toprow)) ++;
          } else {
#line 4381
            if ((int )*(*(row_map + toprow) + 2) == 3) {
#line 4383
              (*(feeds_in_row + toprow)) ++;
#line 4384
              (*(xfeeds_in_row + toprow)) ++;
            }
          }
        }
#line 4387
        if (row___0 > botrow) {
#line 4388
          if ((int )*(*(row_map + row___0) + 2) != 4) {
#line 4389
            (*(feeds_in_row + row___0)) ++;
#line 4390
            (*(xfeeds_in_row + row___0)) ++;
          }
        }
#line 4393
        if (row___0 == botrow) {
#line 4394
          if ((int )*(*(row_map + botrow) + 2) == 2) {
#line 4396
            (*(feeds_in_row + botrow)) ++;
#line 4397
            (*(xfeeds_in_row + botrow)) ++;
          } else {
#line 4394
            if ((int )*(*(row_map + botrow) + 2) == 3) {
#line 4396
              (*(feeds_in_row + botrow)) ++;
#line 4397
              (*(xfeeds_in_row + botrow)) ++;
            }
          }
        }
#line 4400
        check = (toprow - row___0) - 1;
#line 4401
        if (check != 0) {
#line 4402
          a___0 = toprow - 1;
#line 4402
          while (a___0 > row___0) {
#line 4403
            (*(feeds_in_row + a___0)) ++;
#line 4404
            (*(xfeeds_in_row + a___0)) ++;
#line 4402
            a___0 --;
          }
        }
#line 4407
        toprow = row___0;
#line 4408
        TOP_ROW_FOR_NET = 0;
        __Cont___2: /* CIL Label */ 
#line 4376
        row___0 --;
      }
    } else {
#line 4411
      if ((int )*(*(row_map + toprow) + 2) == 3) {
#line 4412
        (*(feeds_in_row + toprow)) ++;
#line 4413
        (*(xfeeds_in_row + toprow)) ++;
      }
    }
    __Cont: /* CIL Label */ 
#line 4300
    net ++;
  }
#line 4417
  est_fds = 0;
#line 4418
  row___0 = 1;
#line 4418
  while (row___0 <= numRows) {
#line 4419
    if (*(xfeeds_in_row + row___0) > 0) {
#line 4420
      est_fds += *(xfeeds_in_row + row___0);
    }
#line 4422
    value = (*(feeds_in_row + row___0) * fdWidth) / binWidth;
#line 4423
    if (*(feeds_in_row + row___0) > 0) {
#line 4424
      *(feeds_in_row + row___0) = 1 + value;
    } else {
#line 4426
      *(feeds_in_row + row___0) = 0;
    }
#line 4418
    row___0 ++;
  }
#line 4429
  value = 0;
#line 4430
  row___0 = 1;
#line 4430
  while (row___0 <= numRows) {
#line 4431
    value += *(feeds_in_row + row___0);
#line 4430
    row___0 ++;
  }
#line 4433
  return (value * binWidth);
}
}
#line 4435 "D:/a/test/300.c"
int prep_feed_count_1(void) 
{ TEBOXPTR pinptr ;
  int cell___0 ;
  int corient ;
  int offset ;
  int row___0 ;
  double total_row_len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4440
  total_row_len = (double )0;
#line 4441
  row___0 = 1;
#line 4441
  while (row___0 <= numRows) {
#line 4442
    total_row_len += (double )(*(barray + row___0))->blength;
#line 4441
    row___0 ++;
  }
#line 4444
  tmp = (int )safe_malloc((unsigned int )(1 + numRows) * sizeof(int ));
#line 4444
  feeds_in_row = (int *)tmp;
#line 4445
  tmp___0 = (int )safe_malloc((unsigned int )(1 + numRows) * sizeof(int ));
#line 4445
  xfeeds_in_row = (int *)tmp___0;
#line 4446
  offset = - ((int )((double )implicit_feed_count * 0.90));
#line 4447
  row___0 = 1;
#line 4447
  while (row___0 <= numRows) {
#line 4448
    *(feeds_in_row + row___0) = (int )((double )offset * ((double )(*(barray + row___0))->blength / total_row_len));
#line 4450
    *(xfeeds_in_row + row___0) = 0;
#line 4447
    row___0 ++;
  }
#line 4452
  cell___0 = 1;
#line 4452
  while (cell___0 <= numcells + numterms) {
#line 4453
    if (cell___0 <= numcells) {
#line 4454
      pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 4455
      corient = (int )(*(carray + cell___0))->corient;
#line 4456
      while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 4457
        (*(tearray + pinptr->cellterm))->unequiv = (char )pinptr->ue;
#line 4458
        (*(tearray + pinptr->cellterm))->cell = (short )cell___0;
#line 4459
        if ((int )pinptr->typos[corient % 2] >= 0) {
#line 4459
          tmp___1 = (int )pinptr->typos[corient % 2];
        } else {
#line 4459
          tmp___1 = - ((int )pinptr->typos[corient % 2]);
        }
#line 4459
        if (tmp___1 > 1) {
#line 4460
          if ((int )pinptr->typos[corient % 2] > 0) {
#line 4461
            (*(tearray + pinptr->cellterm))->pinloc = (char)1;
          } else {
#line 4463
            (*(tearray + pinptr->cellterm))->pinloc = (char)-1;
          }
        } else {
#line 4466
          (*(tearray + pinptr->cellterm))->pinloc = (char)0;
        }
#line 4456
        pinptr = pinptr->nextterm;
      }
    } else {
#line 4469
      if (cell___0 > numcells) {
#line 4470
        pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 4471
        while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 4472
          (*(tearray + pinptr->cellterm))->unequiv = (char )pinptr->ue;
#line 4473
          (*(tearray + pinptr->cellterm))->cell = (short )cell___0;
#line 4474
          (*(tearray + pinptr->cellterm))->pinloc = (char)0;
#line 4471
          pinptr = pinptr->nextterm;
        }
      }
    }
#line 4452
    cell___0 ++;
  }
#line 4478
  return 0;
}
}
#line 4480 "D:/a/test/300.c"
int prep_feed_count(void) 
{ TEBOXPTR pinptr ;
  int cell___0 ;
  int corient ;
  int offset ;
  int row___0 ;
  double total_row_len ;
  int tmp ;

  {
#line 4485
  total_row_len = (double )0;
#line 4486
  row___0 = 1;
#line 4486
  while (row___0 <= numRows) {
#line 4487
    total_row_len += (double )(*(barray + row___0))->blength;
#line 4486
    row___0 ++;
  }
#line 4489
  offset = - ((int )((double )implicit_feed_count * 0.90));
#line 4490
  row___0 = 1;
#line 4490
  while (row___0 <= numRows) {
#line 4491
    *(feeds_in_row + row___0) = (int )((double )offset * ((double )(*(barray + row___0))->blength / total_row_len));
#line 4493
    *(xfeeds_in_row + row___0) = 0;
#line 4490
    row___0 ++;
  }
#line 4495
  cell___0 = 1;
#line 4495
  while (cell___0 <= numcells) {
#line 4496
    pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 4497
    corient = (int )(*(carray + cell___0))->corient;
#line 4498
    while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 4499
      if ((int )pinptr->typos[corient % 2] >= 0) {
#line 4499
        tmp = (int )pinptr->typos[corient % 2];
      } else {
#line 4499
        tmp = - ((int )pinptr->typos[corient % 2]);
      }
#line 4499
      if (tmp > 1) {
#line 4500
        if ((int )pinptr->typos[corient % 2] > 0) {
#line 4501
          (*(tearray + pinptr->cellterm))->pinloc = (char)1;
        } else {
#line 4503
          (*(tearray + pinptr->cellterm))->pinloc = (char)-1;
        }
      } else {
#line 4506
        (*(tearray + pinptr->cellterm))->pinloc = (char)0;
      }
#line 4498
      pinptr = pinptr->nextterm;
    }
#line 4495
    cell___0 ++;
  }
#line 4510
  return 0;
}
}
#line 4512 "D:/a/test/300.c"
int insert_row(int flag ) 
{ TEBOXPTR pinptr ;
  int row___0 ;
  int cell___0 ;
  int pad___0 ;
  int yc ;
  int yb ;
  int blk___0 ;

  {
#line 4518
  cell___0 = 1;
#line 4518
  while (cell___0 <= numcells) {
#line 4519
    row___0 = (int )(*(carray + cell___0))->cblock;
#line 4520
    pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 4521
    while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 4522
      (*(tearray + pinptr->cellterm))->row = (short )row___0;
#line 4521
      pinptr = pinptr->nextterm;
    }
#line 4518
    cell___0 ++;
  }
#line 4525
  if (flag == 0) {
#line 4526
    pad___0 = numcells + 1;
#line 4526
    while (pad___0 <= numcells + numterms) {
#line 4527
      if ((int )(*(carray + pad___0))->padside == 2) {
        goto _L___0;
      } else {
#line 4527
        if ((int )(*(carray + pad___0))->padside == 14) {
          _L___0: /* CIL Label */ 
#line 4528
          row___0 = numRows + 1;
#line 4529
          pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 4530
          while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 4531
            (*(tearray + pinptr->cellterm))->row = (short )row___0;
#line 4530
            pinptr = pinptr->nextterm;
          }
        } else {
#line 4533
          if ((int )(*(carray + pad___0))->padside == 4) {
            goto _L;
          } else {
#line 4533
            if ((int )(*(carray + pad___0))->padside == 15) {
              _L: /* CIL Label */ 
#line 4535
              row___0 = 0;
#line 4536
              pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 4537
              while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 4538
                (*(tearray + pinptr->cellterm))->row = (short )row___0;
#line 4537
                pinptr = pinptr->nextterm;
              }
            } else {
#line 4541
              pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 4542
              while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 4543
                yc = (*(carray + pad___0))->cycenter + (int )pinptr->typos[1];
#line 4544
                blk___0 = 1;
#line 4544
                while (blk___0 <= numRows) {
#line 4545
                  if ((rowArray + blk___0)->ypos >= yc) {
#line 4546
                    break;
                  }
#line 4544
                  blk___0 ++;
                }
#line 4549
                if (blk___0 == 1) {
#line 4550
                  row___0 = 1;
                } else {
#line 4551
                  if (blk___0 > numRows) {
#line 4552
                    row___0 = numRows;
                  } else {
#line 4554
                    yb = (rowArray + blk___0)->ypos;
#line 4555
                    if (yb - yc < yc - (rowArray + (blk___0 - 1))->ypos) {
#line 4556
                      row___0 = blk___0;
                    } else {
#line 4558
                      row___0 = blk___0 - 1;
                    }
                  }
                }
#line 4561
                (*(tearray + pinptr->cellterm))->row = (short )row___0;
#line 4542
                pinptr = pinptr->nextterm;
              }
            }
          }
        }
      }
#line 4526
      pad___0 ++;
    }
  }
#line 4566
  return 0;
}
}
#line 4568 "D:/a/test/300.c"
int feed_situation(int row___0 , int net ) 
{ NBOXPTR nptr ;
  CBOXPTR cellptr___0 ;
  int pinup ;
  int pindown ;
  int pinloc ;

  {
#line 4574
  pinup = 0;
#line 4575
  pindown = 0;
#line 4576
  nptr = (*(netarray + net))->netptr;
#line 4577
  while ((unsigned int )nptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 4578
    if ((int )nptr->row != row___0) {
      goto __Cont;
    } else {
#line 4578
      if ((int )nptr->unequiv == 1) {
        goto __Cont;
      }
    }
#line 4581
    cellptr___0 = *(carray + nptr->cell);
#line 4582
    if ((int )nptr->cell > numcells) {
#line 4582
      if ((int )cellptr___0->padside == 1) {
        goto __Cont;
      } else {
#line 4582
        if ((int )cellptr___0->padside == 9) {
          goto __Cont;
        } else {
#line 4582
          if ((int )cellptr___0->padside == 5) {
            goto __Cont;
          } else {
#line 4582
            if ((int )cellptr___0->padside == 7) {
              goto __Cont;
            } else {
#line 4582
              if ((int )cellptr___0->padside == 3) {
                goto __Cont;
              } else {
#line 4582
                if ((int )cellptr___0->padside == 10) {
                  goto __Cont;
                } else {
#line 4582
                  if ((int )cellptr___0->padside == 6) {
                    goto __Cont;
                  } else {
#line 4582
                    if ((int )cellptr___0->padside == 8) {
                      goto __Cont;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 4593
    pinloc = (int )nptr->pinloc;
#line 4594
    if (pinloc == 0) {
#line 4595
      return (4);
    }
#line 4597
    if (pinloc > 0) {
#line 4598
      pinup = 1;
    } else {
#line 4600
      pindown = 1;
    }
    __Cont: /* CIL Label */ 
#line 4577
    nptr = nptr->nterm;
  }
#line 4603
  if (pinup == 1) {
#line 4603
    if (pindown == 0) {
#line 4604
      return (1);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 4605
    if (pinup == 0) {
#line 4605
      if (pindown == 1) {
#line 4606
        return (2);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 4607
      if (pinup == 1) {
#line 4607
        if (pindown == 1) {
#line 4608
          return (3);
        } else {
#line 4610
          return (0);
        }
      } else {
#line 4610
        return (0);
      }
    }
  }
}
}
#line 4620
char *strclone(char *str ) ;
#line 4618 "D:/a/test/300.c"
char *getCompileDate(void) 
{ char *tmp ;

  {
#line 4621
  tmp = strclone("Mon Jan 25 18:50:36 EST 1988");
#line 4621
  return (tmp);
}
}
#line 4631
FILE *openFile(char *filename , char *readwrite , int abort___0 ) ;
#line 4625 "D:/a/test/300.c"
int cellbox_data(int first_cell , int last_cell ) 
{ FILE *fp ;
  CBOXPTR ptr ;
  int cell___0 ;
  int tmp ;

  {
#line 4631
  tmp = (int )openFile("debug.cellbox", "a", 1);
#line 4631
  fp = (FILE *)tmp;
#line 4632
  fprintf(fp, " cell xcenter ycenter corient padside left right\n");
#line 4633
  cell___0 = first_cell;
#line 4633
  while (cell___0 <= last_cell) {
#line 4634
    ptr = *(carray + cell___0);
#line 4635
    fprintf(fp, "%5d  %6d  %6d      %2d      %2d %4d  %4d\n", cell___0, ptr->cxcenter,
            ptr->cycenter, ptr->corient, ptr->padside, (ptr->tileptr)->left, (ptr->tileptr)->right);
#line 4633
    cell___0 ++;
  }
#line 4639
  fclose(fp);
#line 4640
  return (0);
}
}
#line 4641 "D:/a/test/300.c"
int cellterm_data(int first_cell , int last_cell ) 
{ FILE *fp ;
  CBOXPTR ptr ;
  TEBOXPTR termptr ;
  NBOXPTR ttermptr ;
  int cell___0 ;
  int corient ;
  int tmp ;

  {
#line 4649
  tmp = (int )openFile("debug.cellterm", "a", 1);
#line 4649
  fp = (FILE *)tmp;
#line 4650
  cell___0 = first_cell;
#line 4650
  while (cell___0 <= last_cell) {
#line 4651
    fprintf(fp, "\n cell xcenter ycenter corient padside left right\n");
#line 4652
    ptr = *(carray + cell___0);
#line 4653
    corient = (int )ptr->corient;
#line 4654
    fprintf(fp, "%5d  %6d  %6d      %2d      %2d %4d  %4d\n", cell___0, ptr->cxcenter,
            ptr->cycenter, corient, ptr->padside, (ptr->tileptr)->left, (ptr->tileptr)->right);
#line 4657
    fprintf(fp, "   pin  net   tx   ty   xpos   ypos   newx   newy ");
#line 4658
    fprintf(fp, "loc ue flag\n");
#line 4659
    if (cell___0 <= numcells) {
#line 4660
      termptr = (ptr->tileptr)->termsptr;
#line 4660
      while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 4662
        ttermptr = *(tearray + termptr->cellterm);
#line 4663
        fprintf(fp, " %5d %4d %4d %4d %6d %6d %6d %6d %3d %2d  %2d\n", termptr->cellterm,
                ttermptr->net, termptr->txpos[corient / 2], termptr->typos[corient % 2],
                ttermptr->xpos, ttermptr->ypos, ttermptr->newx, ttermptr->newy, ttermptr->pinloc,
                ttermptr->unequiv, ttermptr->flag);
#line 4660
        termptr = termptr->nextterm;
      }
    } else {
#line 4671
      termptr = (ptr->tileptr)->termsptr;
#line 4671
      while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 4673
        ttermptr = *(tearray + termptr->cellterm);
#line 4674
        fprintf(fp, " %5d %4d %4d %4d %6d %6d %6d %6d %3d %2d  %2d\n", termptr->cellterm,
                ttermptr->net, termptr->txpos[1], termptr->typos[1], ttermptr->xpos,
                ttermptr->ypos, ttermptr->newx, ttermptr->newy, ttermptr->pinloc,
                ttermptr->unequiv, ttermptr->flag);
#line 4671
        termptr = termptr->nextterm;
      }
    }
#line 4650
    cell___0 ++;
  }
#line 4682
  fclose(fp);
#line 4683
  return (0);
}
}
#line 4684 "D:/a/test/300.c"
int terminal(int first_net , int last_net ) 
{ FILE *fp ;
  NBOXPTR netptr ;
  int net ;
  int tmp ;

  {
#line 4690
  tmp = (int )openFile("debug.terminal", "a", 1);
#line 4690
  fp = (FILE *)tmp;
#line 4691
  net = first_net;
#line 4691
  while (net <= last_net) {
#line 4692
    fprintf(fp, "net %d\n", net);
#line 4693
    fprintf(fp, " terminal  xpos  ypos  newx  newy  cell loc ue flag extint\n");
#line 4694
    netptr = (*(netarray + net))->netptr;
#line 4694
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 4696
      fprintf(fp, "    %5d %5d %5d %5d %5d %5d %3d %2d    %1d %6d\n", netptr->terminal,
              netptr->xpos, netptr->ypos, netptr->newx, netptr->newy, netptr->cell,
              netptr->pinloc, netptr->unequiv, netptr->flag, netptr->extint);
#line 4694
      netptr = netptr->nterm;
    }
#line 4691
    net ++;
  }
#line 4702
  fclose(fp);
#line 4703
  return (0);
}
}
#line 4704 "D:/a/test/300.c"
int pairCheck(int first_row , int last_row ) 
{ FILE *fp ;
  CBOXPTR cellptr___0 ;
  TIBOXPTR tileptr ;
  int row___0 ;
  int i ;
  int j ;
  int bin_left_edge ;
  int *Aray ;
  int cell___0 ;
  int bin ;
  int most_left ;
  int most_rite ;
  int tmp ;

  {
#line 4712
  tmp = (int )openFile("dbg.pairCheck", "a", 1);
#line 4712
  fp = (FILE *)tmp;
#line 4713
  fprintf(fp, "cedge_binwidth = %d num_edgebin = %d\n", cedge_binwidth, num_edgebin);
#line 4715
  row___0 = first_row;
#line 4715
  while (row___0 <= last_row) {
#line 4716
    Aray = *(pairArray + row___0);
#line 4717
    fprintf(fp, "\nROW %d\n", row___0);
#line 4718
    fprintf(fp, " total number of cells in this row = %d\n", *(Aray + 0));
#line 4719
    cellptr___0 = *(carray + *(Aray + 1));
#line 4720
    most_left = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->left;
#line 4721
    cellptr___0 = *(carray + *(Aray + *(Aray + 0)));
#line 4722
    most_rite = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
#line 4723
    fprintf(fp, " most_left is at %d most_rite is at \n", most_left, most_rite);
#line 4725
    fprintf(fp, "   i  cell  left right height   top bottom\n");
#line 4726
    i = 1;
#line 4726
    while (i <= *(Aray + 0)) {
#line 4727
      cell___0 = *(Aray + i);
#line 4728
      cellptr___0 = *(carray + cell___0);
#line 4729
      tileptr = cellptr___0->tileptr;
#line 4730
      fprintf(fp, " %3d %5d %5d %5d %6d %5d %6d\n", i, cell___0, (int )tileptr->left + cellptr___0->cxcenter,
              (int )tileptr->right + cellptr___0->cxcenter, cellptr___0->cheight,
              tileptr->top, - ((int )tileptr->bottom));
#line 4726
      i ++;
    }
#line 4735
    fprintf(fp, " bin index cell bin_left_edge\n");
#line 4736
    bin_left_edge = most_left;
#line 4737
    bin = 1;
#line 4737
    while (bin <= num_edgebin) {
#line 4738
      j = *(*(cedgebin + row___0) + bin);
#line 4739
      fprintf(fp, " %3d %5d %4d        %5d\n", bin, j, *(Aray + j), bin_left_edge);
#line 4741
      bin_left_edge += cedge_binwidth;
#line 4737
      bin ++;
    }
#line 4715
    row___0 ++;
  }
#line 4744
  fclose(fp);
#line 4745
  return (0);
}
}
#line 4758
int fcellheight(int pin , int *fcell , int status ) ;
#line 4746 "D:/a/test/300.c"
int trackdebug(int status ) 
{ int fcell ;
  int cht ;
  int fht ;
  int newtrack ;
  FILE *fp ;
  CHANGRDPTR gdptr ;
  NBOXPTR netptr ;
  int tmp ;

  {
#line 4754
  tmp = (int )openFile("trackdbg", "a", 1);
#line 4754
  fp = (FILE *)tmp;
#line 4755
  fprintf(fp, "\n S nS tk nt Tk rs   pin  xpos  newx  cell  fcel cht fht\n");
#line 4756
  gdptr = ULgrdptr;
#line 4756
  while ((unsigned int )gdptr != (unsigned int )URgrdptr->nextgrd) {
#line 4757
    netptr = gdptr->netptr;
#line 4758
    fht = fcellheight(netptr->terminal, & fcell, status);
#line 4759
    if ((int )netptr->pinloc == 1) {
#line 4760
      cht = (int )((*(carray + netptr->cell))->tileptr)->top;
    } else {
#line 4761
      if ((int )netptr->pinloc == 0) {
#line 4762
        cht = 0;
      } else {
#line 4764
        cht = - ((int )((*(carray + netptr->cell))->tileptr)->bottom);
      }
    }
#line 4766
    if (status == 0) {
#line 4767
      newtrack = (int )gdptr->tracks - (cht + fht) / track_spacing;
    } else {
#line 4769
      newtrack = (int )gdptr->ntracks - (cht + fht) / track_spacing;
    }
#line 4771
    fprintf(fp, "%2d %2d %2d %2d %2d %2d %5d %5d %5d %5d %5d %3d %3d\n", gdptr->SegType,
            gdptr->nSegType, gdptr->tracks, gdptr->ntracks, newtrack, (cht + fht) / track_spacing,
            netptr->terminal, netptr->xpos, netptr->newx, netptr->cell, fcell, cht,
            fht);
#line 4776
    if (status == 0) {
#line 4777
      gdptr = gdptr->nextgrd;
    } else {
#line 4779
      gdptr = gdptr->nnextgrd;
    }
  }
#line 4782
  fprintf(fp, "\n S nS tk nt Tk rs   pin  xpos  newx  cell  fcel cht fht\n");
#line 4783
  gdptr = LLgrdptr;
#line 4783
  while ((unsigned int )gdptr != (unsigned int )LRgrdptr->nextgrd) {
#line 4784
    netptr = gdptr->netptr;
#line 4785
    fht = fcellheight(netptr->terminal, & fcell, status);
#line 4786
    if ((int )netptr->pinloc == 1) {
#line 4787
      cht = (int )((*(carray + netptr->cell))->tileptr)->top;
    } else {
#line 4788
      if ((int )netptr->pinloc == 0) {
#line 4789
        cht = 0;
      } else {
#line 4791
        cht = - ((int )((*(carray + netptr->cell))->tileptr)->bottom);
      }
    }
#line 4793
    if (status == 0) {
#line 4794
      newtrack = (int )gdptr->tracks - (cht + fht) / track_spacing;
    } else {
#line 4796
      newtrack = (int )gdptr->ntracks - (cht + fht) / track_spacing;
    }
#line 4798
    fprintf(fp, "%2d %2d %2d %2d %2d %2d %5d %5d %5d %5d %5d %3d %3d\n", gdptr->SegType,
            gdptr->nSegType, gdptr->tracks, gdptr->ntracks, newtrack, (cht + fht) / track_spacing,
            netptr->terminal, netptr->xpos, netptr->newx, netptr->cell, fcell, cht,
            fht);
#line 4803
    if (status == 0) {
#line 4804
      gdptr = gdptr->nextgrd;
    } else {
#line 4806
      gdptr = gdptr->nnextgrd;
    }
  }
#line 4809
  fclose(fp);
#line 4810
  return (0);
}
}
#line 4811 "D:/a/test/300.c"
int fcellheight(int pin , int *fcell , int status ) 
{ CBOXPTR cellptr___0 ;
  int bin ;
  int i ;
  int *Aray ;
  int most_left ;
  int most_rite ;
  int nrow ;
  int pin_x ;
  int crite ;
  int row___0 ;
  int pinloc ;

  {
#line 4817
  row___0 = (int )(*(tearray + pin))->row;
#line 4818
  pinloc = (int )(*(tearray + pin))->pinloc;
#line 4819
  if (1 <= row___0) {
#line 4819
    if (row___0 <= numRows) {
#line 4820
      nrow = row___0 + pinloc;
#line 4821
      if (nrow == 0) {
#line 4822
        *fcell = 0;
#line 4823
        return (0);
      } else {
#line 4821
        if (nrow == numChans) {
#line 4822
          *fcell = 0;
#line 4823
          return (0);
        } else {
#line 4821
          if (pinloc == 0) {
#line 4822
            *fcell = 0;
#line 4823
            return (0);
          }
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 4825
    if (row___0 == 0) {
#line 4826
      nrow = 1;
    } else {
#line 4828
      nrow = numRows;
    }
  }
#line 4830
  Aray = *(pairArray + nrow);
#line 4831
  if (status == 0) {
#line 4832
    pin_x = (*(tearray + pin))->newx;
  } else {
#line 4834
    pin_x = (*(tearray + pin))->xpos;
  }
#line 4836
  cellptr___0 = *(carray + *(Aray + 1));
#line 4837
  most_left = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->left;
#line 4838
  cellptr___0 = *(carray + *(Aray + *(Aray + 0)));
#line 4839
  most_rite = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
#line 4840
  if (pin_x < most_left) {
#line 4841
    *fcell = 0;
#line 4842
    return (0);
  } else {
#line 4840
    if (pin_x > most_rite) {
#line 4841
      *fcell = 0;
#line 4842
      return (0);
    }
  }
#line 4844
  bin = (pin_x - most_left) / cedge_binwidth + 1;
#line 4845
  i = *(*(cedgebin + nrow) + bin);
#line 4845
  if (i == 0) {
#line 4846
    *fcell = 0;
#line 4847
    return (0);
  }
#line 4849
  *fcell = *(Aray + i);
#line 4850
  cellptr___0 = *(carray + *fcell);
#line 4851
  crite = (int )(cellptr___0->tileptr)->right + cellptr___0->cxcenter;
#line 4852
  while (1) {
#line 4852
    if (crite < pin_x) {
#line 4852
      if (! (i < *(Aray + 0))) {
#line 4852
        break;
      }
    } else {
#line 4852
      break;
    }
#line 4853
    i ++;
#line 4853
    *fcell = *(Aray + i);
#line 4854
    cellptr___0 = *(carray + *fcell);
#line 4855
    crite += (int )cellptr___0->clength;
  }
#line 4857
  if (crite == pin_x) {
#line 4857
    if (i != *(Aray + 0)) {
#line 4858
      if ((int )(*(carray + *(Aray + (i + 1))))->cheight > (int )cellptr___0->cheight) {
#line 4859
        *fcell = *(Aray + (i + 1));
#line 4860
        cellptr___0 = *(carray + *fcell);
      }
    }
  }
#line 4863
  if (1 <= row___0) {
#line 4863
    if (row___0 <= numRows) {
#line 4864
      if (pinloc == 1) {
#line 4865
        return (- ((int )(cellptr___0->tileptr)->bottom));
      } else {
#line 4867
        return ((int )(cellptr___0->tileptr)->top);
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 4869
    if (row___0 == 0) {
#line 4870
      return (- ((int )(cellptr___0->tileptr)->bottom));
    } else {
#line 4872
      return ((int )(cellptr___0->tileptr)->top);
    }
  }
}
}
#line 4875 "D:/a/test/300.c"
int chan_debug(int start_chan , int end_chan , int status ) 
{ int fcell ;
  int cht ;
  int fht ;
  int chan ;
  int newtrack ;
  FILE *fp ;
  CHANGRDPTR gdptr ;
  NBOXPTR netptr ;
  int tmp ;

  {
#line 4883
  tmp = (int )openFile("chandbg", "a", 1);
#line 4883
  fp = (FILE *)tmp;
#line 4884
  chan = start_chan;
#line 4884
  while (chan <= end_chan) {
#line 4885
    fprintf(fp, "\n channel = %d\n", chan);
#line 4886
    fprintf(fp, "\n S nS tk nt Tk rs   pin  xpos  newx  cell  fcel cht fht\n");
#line 4887
    if (status == 0) {
#line 4888
      gdptr = (*(Begin + chan))->nextgrd;
    } else {
#line 4890
      gdptr = (*(Begin + chan))->nnextgrd;
    }
#line 4892
    while ((unsigned int )gdptr != (unsigned int )*(End + chan)) {
#line 4893
      netptr = gdptr->netptr;
#line 4894
      fht = fcellheight(netptr->terminal, & fcell, status);
#line 4895
      if ((int )netptr->pinloc == 1) {
#line 4896
        cht = (int )((*(carray + netptr->cell))->tileptr)->top;
      } else {
#line 4897
        if ((int )netptr->pinloc == 0) {
#line 4898
          cht = 0;
        } else {
#line 4900
          cht = - ((int )((*(carray + netptr->cell))->tileptr)->bottom);
        }
      }
#line 4902
      if (status == 0) {
#line 4903
        newtrack = (int )gdptr->tracks - (cht + fht) / track_spacing;
      } else {
#line 4905
        newtrack = (int )gdptr->ntracks - (cht + fht) / track_spacing;
      }
#line 4907
      fprintf(fp, "%2d %2d %2d %2d %2d %2d %5d %5d %5d %5d %5d %3d %3d\n", gdptr->SegType,
              gdptr->nSegType, gdptr->tracks, gdptr->ntracks, newtrack, (cht + fht) / track_spacing,
              netptr->terminal, netptr->xpos, netptr->newx, netptr->cell, fcell, cht,
              fht);
#line 4912
      if (status == 0) {
#line 4913
        gdptr = gdptr->nextgrd;
      } else {
#line 4915
        gdptr = gdptr->nnextgrd;
      }
    }
#line 4884
    chan ++;
  }
#line 4919
  fclose(fp);
#line 4920
  return (0);
}
}
#line 4921 "D:/a/test/300.c"
int negative(void) 
{ NBOXPTR netptr ;
  CHANGRDPTR gdptr ;
  int channel ;

  {
#line 4926
  channel = 1;
#line 4926
  while (channel <= numChans) {
#line 4927
    gdptr = (*(Begin + channel))->nnextgrd;
#line 4927
    while ((unsigned int )gdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 4929
      netptr = gdptr->netptr;
#line 4930
      if ((int )gdptr->ntracks < 0) {
#line 4931
        printf("channel   pin  xpos  newx  cell   net\n");
#line 4932
        printf("    %3d %5d %5d %5d %5d %5d\n", channel, netptr->terminal, netptr->xpos,
               netptr->newx, netptr->cell, netptr->net);
      }
#line 4927
      gdptr = gdptr->nnextgrd;
    }
#line 4926
    channel ++;
  }
#line 4938
  return (0);
}
}
#line 4950 "D:/a/test/300.c"
int finalwire(void) 
{ DBOXPTR dimptr ;
  NBOXPTR netptr ;
  int x ;
  int y ;
  int net ;
  int cost ;
  int tmp ;
  int tmp___0 ;

  {
#line 4954
  cost = 0;
#line 4955
  fwirex = 0;
#line 4956
  fwirey = 0;
#line 4957
  net = 1;
#line 4957
  while (net <= numnets) {
#line 4958
    dimptr = *(netarray + net);
#line 4959
    netptr = dimptr->netptr;
#line 4959
    if ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 4960
      tmp = netptr->xpos;
#line 4960
      dimptr->xmax = tmp;
#line 4960
      dimptr->xmin = tmp;
#line 4961
      tmp___0 = netptr->ypos;
#line 4961
      dimptr->ymax = tmp___0;
#line 4961
      dimptr->ymin = tmp___0;
#line 4962
      netptr = netptr->nterm;
    }
#line 4964
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 4965
      x = netptr->xpos;
#line 4966
      y = netptr->ypos;
#line 4967
      if (x < dimptr->xmin) {
#line 4968
        dimptr->xmin = x;
      } else {
#line 4969
        if (x > dimptr->xmax) {
#line 4970
          dimptr->xmax = x;
        }
      }
#line 4972
      if (y < dimptr->ymin) {
#line 4973
        dimptr->ymin = y;
      } else {
#line 4974
        if (y > dimptr->ymax) {
#line 4975
          dimptr->ymax = y;
        }
      }
#line 4964
      netptr = netptr->nterm;
    }
#line 4978
    cost += (int )(dimptr->Hweight * (double )(dimptr->xmax - dimptr->xmin)) + (int )(dimptr->Vweight * (double )(dimptr->ymax - dimptr->ymin));
#line 4982
    fwirex += dimptr->xmax - dimptr->xmin;
#line 4983
    fwirey += dimptr->ymax - dimptr->ymin;
#line 4957
    net ++;
  }
#line 4985
  fwire = cost;
#line 4986
  fprintf(fpo, "\nInitial Wiring Cost: %d   Final Wiring Cost: %d\n", iwire, fwire);
#line 4988
  if (iwire != 0) {
#line 4989
    fprintf(fpo, "############## Percent Wire Cost Reduction: %d\n\n", 100 - (int )(((double )fwire / (double )iwire) * 100.0));
  }
#line 4992
  fprintf(fpo, "\nInitial Wire Length: %d   Final Wire Length: %d\n", iwirex + iwirey,
          fwirex + fwirey);
#line 4994
  if (iwirex + iwirey != 0) {
#line 4995
    fprintf(fpo, "************** Percent Wire Length Reduction: %d\n\n", 100 - (int )(((double )(fwirex + fwirey) / (double )(iwirex + iwirey)) * 100.0));
  }
#line 4999
  fprintf(fpo, "\nInitial Horiz. Wire: %d   Final Horiz. Wire: %d\n", iwirex, fwirex);
#line 5001
  if (iwirex != 0) {
#line 5002
    fprintf(fpo, "$$$$$$$$$$$ Percent H-Wire Length Reduction: %d\n\n", 100 - (int )(((double )fwirex / (double )iwirex) * 100.0));
  }
#line 5005
  fprintf(fpo, "\nInitial Vert. Wire: %d   Final Vert. Wire: %d\n", iwirey, fwirey);
#line 5007
  if (iwirey != 0) {
#line 5008
    fprintf(fpo, "@@@@@@@@@@@ Percent V-Wire Length Reduction: %d\n\n", 100 - (int )(((double )fwirey / (double )iwirey) * 100.0));
  }
#line 5011
  return (0);
}
}
#line 5092
int TW_oldin(FILE *fp ) ;
#line 5095
int sortpin(void) ;
#line 5285
char *safe_realloc(char *obj , unsigned int size ) ;
#line 5015 "D:/a/test/300.c"
int findcost(void) 
{ FILE *fp ;
  TIBOXPTR tile ;
  TIBOXPTR tileptr1 ;
  CBOXPTR cellptr1 ;
  CBOXPTR ptr ;
  DBOXPTR dimptr ;
  NBOXPTR netptr ;
  NBOXPTR termptr ;
  TEBOXPTR term ;
  BINPTR bptr ;
  char filename[64] ;
  int left___0 ;
  int right ;
  int corient ;
  int bin ;
  int LoBin ;
  int HiBin ;
  int block___0 ;
  int cell___0 ;
  int net ;
  int blk___0 ;
  int startx ;
  int endx ;
  int x ;
  int y ;
  int cost ;
  int temp ;
  int n ;
  int k___0 ;
  int cbin ;
  int net_pin_num[11] ;
  int *adjust_left ;
  double deviation ;
  double factor ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  short tmp___5 ;
  short tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 5029
  cost = 0;
#line 5033
  blkleft = 32000;
#line 5034
  blkrite = 0;
#line 5035
  tmp = (int )safe_malloc((unsigned int )(numblock + 1) * sizeof(int ));
#line 5035
  adjust_left = (int *)tmp;
#line 5036
  block___0 = 1;
#line 5036
  while (block___0 <= numblock) {
#line 5037
    if ((*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bleft < blkleft) {
#line 5039
      blkleft = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bleft;
    }
#line 5042
    if ((*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bright > blkrite) {
#line 5044
      blkrite = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bright;
    }
#line 5047
    *(adjust_left + block___0) = 32000;
#line 5036
    block___0 ++;
  }
#line 5049
  binOffst = blkleft;
#line 5050
  max_blklength = blkrite - blkleft;
#line 5051
  deviation = (double )0;
#line 5052
  temp = 0;
#line 5053
  factor = 0.0;
#line 5054
  cell___0 = 1;
#line 5054
  while (cell___0 <= numcells) {
#line 5055
    temp += (int )(*(carray + cell___0))->clength;
#line 5054
    cell___0 ++;
  }
#line 5057
  mean_width = (double )(temp / numcells);
#line 5058
  cell___0 = 1;
#line 5058
  while (cell___0 <= numcells) {
#line 5059
    deviation += ((double )(*(carray + cell___0))->clength - mean_width) * ((double )(*(carray + cell___0))->clength - mean_width);
#line 5058
    cell___0 ++;
  }
#line 5062
  deviation = sqrt(deviation / (double )numcells);
#line 5063
  binWidth = (int )(factor * deviation + mean_width) + 1;
#line 5064
  numBins = (blkrite - binOffst) / binWidth;
#line 5065
  if (blkrite - binOffst > numBins * binWidth) {
#line 5066
    numBins ++;
  }
#line 5068
  fprintf(fpo, "numBins automatically set to:%d\n", numBins);
#line 5069
  fprintf(fpo, "binWidth = average_cell_width + %g sigma", factor);
#line 5070
  fprintf(fpo, "= %d\n", binWidth);
#line 5071
  fprintf(fpo, "average_cell_width is:%g\n", mean_width);
#line 5072
  fprintf(fpo, "standard deviation of cell length is:%g\n", deviation);
#line 5075
  minxspan = (int )(mean_width + 3.0 * deviation);
#line 5076
  offset_limit = (int )(((0.05 * mean_width) * (double )numcells) / (double )numblock);
#line 5078
  sprintf(filename, "%s.res", cktName);
#line 5079
  tmp___0 = (int )openFile(filename, "r", 0);
#line 5079
  fp = (FILE *)tmp___0;
#line 5080
  if (! fp) {
#line 5081
    if (resume_run == 1) {
#line 5082
      fprintf(fpo, "Could not use resume file: %s  ", filename);
#line 5083
      fprintf(fpo, "since it could not be found\n");
    } else {
#line 5085
      fprintf(fpo, "TimberWolfSC starting from the beginning\n");
    }
  } else {
#line 5087
    if (resume_run == 0) {
#line 5088
      fprintf(fpo, "Use of resume file: %s was not requested\n", filename);
    } else {
#line 5090
      fprintf(fpo, "Resuming TimberWolf from previous saved ");
#line 5091
      fprintf(fpo, "placement in %s\n", filename);
#line 5092
      TW_oldin(fp);
#line 5093
      fclose(fp);
    }
  }
#line 5095
  sortpin();
#line 5096
  cell___0 = 1;
#line 5096
  while (cell___0 <= numcells + numterms) {
#line 5097
    ptr = *(carray + cell___0);
#line 5098
    corient = (int )ptr->corient;
#line 5099
    block___0 = (int )ptr->cblock;
#line 5100
    tile = ptr->tileptr;
#line 5101
    if (cell___0 <= numcells) {
#line 5102
      ptr->cycenter = (*(barray + block___0))->bycenter;
#line 5103
      if (*(adjust_left + block___0) > ptr->cxcenter + (int )tile->left) {
#line 5104
        *(adjust_left + block___0) = ptr->cxcenter + (int )tile->left;
      }
#line 5106
      term = tile->termsptr;
#line 5106
      while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 5108
        termptr = *(tearray + term->cellterm);
#line 5109
        termptr->xpos = (int )term->txpos[corient / 2] + ptr->cxcenter;
#line 5110
        termptr->ypos = (int )term->typos[corient % 2] + ptr->cycenter;
#line 5106
        term = term->nextterm;
      }
    } else {
#line 5113
      term = tile->termsptr;
#line 5113
      while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 5115
        termptr = *(tearray + term->cellterm);
#line 5116
        termptr->xpos = (int )term->txpos[1] + ptr->cxcenter;
#line 5117
        termptr->ypos = (int )term->typos[1] + ptr->cycenter;
#line 5113
        term = term->nextterm;
      }
    }
#line 5096
    cell___0 ++;
  }
#line 5121
  iwirex = 0;
#line 5122
  iwirey = 0;
#line 5123
  net = 1;
#line 5123
  while (net <= numnets) {
#line 5124
    dimptr = *(netarray + net);
#line 5125
    netptr = dimptr->netptr;
#line 5125
    if ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 5126
      tmp___1 = netptr->xpos;
#line 5126
      dimptr->xmax = tmp___1;
#line 5126
      dimptr->xmin = tmp___1;
#line 5127
      tmp___2 = netptr->ypos;
#line 5127
      dimptr->ymax = tmp___2;
#line 5127
      dimptr->ymin = tmp___2;
    }
#line 5129
    netptr = netptr->nterm;
#line 5129
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 5131
      x = netptr->xpos;
#line 5132
      y = netptr->ypos;
#line 5133
      if (x < dimptr->xmin) {
#line 5134
        dimptr->xmin = x;
      } else {
#line 5135
        if (x > dimptr->xmax) {
#line 5136
          dimptr->xmax = x;
        }
      }
#line 5138
      if (y < dimptr->ymin) {
#line 5139
        dimptr->ymin = y;
      } else {
#line 5140
        if (y > dimptr->ymax) {
#line 5141
          dimptr->ymax = y;
        }
      }
#line 5129
      netptr = netptr->nterm;
    }
#line 5144
    cost += (int )(dimptr->Hweight * (double )(dimptr->xmax - dimptr->xmin)) + (int )(dimptr->Vweight * (double )(dimptr->ymax - dimptr->ymin));
#line 5148
    iwirex += dimptr->xmax - dimptr->xmin;
#line 5149
    iwirey += dimptr->ymax - dimptr->ymin;
#line 5123
    net ++;
  }
#line 5151
  fprintf(fpo, "\n\n\nTHIS IS THE ROUTE COST OF THE ");
#line 5152
  fprintf(fpo, "ORIGINAL PLACEMENT: %d\n", cost);
#line 5153
  if (resume_run == 0) {
#line 5154
    cell___0 = 1;
#line 5154
    while (cell___0 <= numcells) {
#line 5155
      ptr = *(carray + cell___0);
#line 5156
      corient = (int )ptr->corient;
#line 5157
      block___0 = (int )ptr->cblock;
#line 5158
      ptr->cxcenter -= (*(adjust_left + block___0) - (*(barray + block___0))->bxcenter) - (int )(*(barray + block___0))->bleft;
#line 5160
      term = (ptr->tileptr)->termsptr;
#line 5160
      while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 5162
        termptr = *(tearray + term->cellterm);
#line 5163
        termptr->xpos = (int )term->txpos[corient / 2] + ptr->cxcenter;
#line 5164
        termptr->ypos = (int )term->typos[corient % 2] + ptr->cycenter;
#line 5160
        term = term->nextterm;
      }
#line 5154
      cell___0 ++;
    }
  }
#line 5168
  cost = 0;
#line 5169
  iwirex = 0;
#line 5170
  iwirey = 0;
#line 5171
  net = 1;
#line 5171
  while (net <= numnets) {
#line 5172
    dimptr = *(netarray + net);
#line 5173
    netptr = dimptr->netptr;
#line 5173
    if ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 5174
      tmp___3 = netptr->xpos;
#line 5174
      dimptr->xmax = tmp___3;
#line 5174
      dimptr->xmin = tmp___3;
#line 5175
      tmp___4 = netptr->ypos;
#line 5175
      dimptr->ymax = tmp___4;
#line 5175
      dimptr->ymin = tmp___4;
#line 5176
      tmp___5 = (short)1;
#line 5176
      dimptr->Rnum = tmp___5;
#line 5176
      dimptr->Lnum = tmp___5;
#line 5177
      tmp___6 = (short)1;
#line 5177
      dimptr->Tnum = tmp___6;
#line 5177
      dimptr->Bnum = tmp___6;
#line 5178
      netptr = netptr->nterm;
    }
#line 5180
    n = 1;
#line 5181
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 5182
      x = netptr->xpos;
#line 5183
      y = netptr->ypos;
#line 5184
      if (x < dimptr->xmin) {
#line 5185
        dimptr->xmin = x;
#line 5186
        dimptr->Lnum = (short)1;
      } else {
#line 5187
        if (x == dimptr->xmin) {
#line 5188
          dimptr->Lnum = (short )((int )dimptr->Lnum + 1);
#line 5189
          if (x == dimptr->xmax) {
#line 5190
            dimptr->Rnum = (short )((int )dimptr->Rnum + 1);
          }
        } else {
#line 5192
          if (x > dimptr->xmax) {
#line 5193
            dimptr->xmax = x;
#line 5194
            dimptr->Rnum = (short)1;
          } else {
#line 5195
            if (x == dimptr->xmax) {
#line 5196
              dimptr->Rnum = (short )((int )dimptr->Rnum + 1);
            }
          }
        }
      }
#line 5198
      if (y < dimptr->ymin) {
#line 5199
        dimptr->ymin = y;
#line 5200
        dimptr->Bnum = (short)1;
      } else {
#line 5201
        if (y == dimptr->ymin) {
#line 5202
          dimptr->Bnum = (short )((int )dimptr->Bnum + 1);
#line 5203
          if (y == dimptr->ymax) {
#line 5204
            dimptr->Tnum = (short )((int )dimptr->Tnum + 1);
          }
        } else {
#line 5206
          if (y > dimptr->ymax) {
#line 5207
            dimptr->ymax = y;
#line 5208
            dimptr->Tnum = (short)1;
          } else {
#line 5209
            if (y == dimptr->ymax) {
#line 5210
              dimptr->Tnum = (short )((int )dimptr->Tnum + 1);
            }
          }
        }
      }
#line 5212
      n ++;
#line 5181
      netptr = netptr->nterm;
    }
#line 5214
    dimptr->numpins = (short )n;
#line 5215
    cost += (int )(dimptr->Hweight * (double )(dimptr->xmax - dimptr->xmin)) + (int )(dimptr->Vweight * (double )(dimptr->ymax - dimptr->ymin));
#line 5219
    iwirex += dimptr->xmax - dimptr->xmin;
#line 5220
    iwirey += dimptr->ymax - dimptr->ymin;
#line 5171
    net ++;
  }
#line 5222
  iwire = cost;
#line 5223
  n = 1;
#line 5223
  while (n <= 10) {
#line 5224
    net_pin_num[n] = 0;
#line 5223
    n ++;
  }
#line 5226
  net = 1;
#line 5226
  while (net <= numnets) {
#line 5227
    dimptr = *(netarray + net);
#line 5228
    if ((int )dimptr->numpins >= 10) {
#line 5229
      (net_pin_num[10]) ++;
    } else {
#line 5231
      (net_pin_num[dimptr->numpins]) ++;
    }
#line 5226
    net ++;
  }
#line 5234
  n = 1;
#line 5234
  while (n <= 9) {
#line 5235
    fprintf(fpo, "The number of nets with %d pin is %d\n", n, net_pin_num[n]);
#line 5234
    n ++;
  }
#line 5238
  fprintf(fpo, "The number of nets with 10 pin or more is %d\n", net_pin_num[10]);
#line 5240
  binpenal = 0;
#line 5241
  rowpenal = 0;
#line 5242
  penalty = 0;
#line 5243
  tmp___7 = (int )safe_malloc((unsigned int )(numblock + 1) * sizeof(BINPTR *));
#line 5243
  binptr = (BINPTR **)tmp___7;
#line 5245
  block___0 = 1;
#line 5245
  while (block___0 <= numblock) {
#line 5246
    tmp___8 = (int )safe_malloc((unsigned int )(numBins + 1) * sizeof(BINPTR ));
#line 5246
    *(binptr + block___0) = (BINPTR *)tmp___8;
#line 5248
    left___0 = (int )(*(barray + block___0))->bleft + (*(barray + block___0))->bxcenter;
#line 5249
    right = ((int )(*(barray + block___0))->bleft + (*(barray + block___0))->bxcenter) + (int )(*(barray + block___0))->desire;
#line 5251
    Trybin = (left___0 - binOffst) / binWidth;
#line 5251
    if (Trybin < 0) {
#line 5251
      LoBin = 0;
    } else {
#line 5251
      if (Trybin > numBins) {
#line 5251
        tmp___9 = numBins;
      } else {
#line 5251
        tmp___9 = Trybin;
      }
#line 5251
      LoBin = tmp___9;
    }
#line 5252
    Trybin = (right - binOffst) / binWidth;
#line 5252
    if (Trybin < 0) {
#line 5252
      HiBin = 0;
    } else {
#line 5252
      if (Trybin > numBins) {
#line 5252
        tmp___10 = numBins;
      } else {
#line 5252
        tmp___10 = Trybin;
      }
#line 5252
      HiBin = tmp___10;
    }
#line 5253
    bin = 0;
#line 5253
    while (bin <= numBins) {
#line 5254
      tmp___11 = (int )safe_malloc(sizeof(BINBOX ));
#line 5254
      *(*(binptr + block___0) + bin) = (BINBOX *)tmp___11;
#line 5256
      tmp___12 = (int )safe_malloc(10U * sizeof(int ));
#line 5256
      (*(*(binptr + block___0) + bin))->cell = (int *)tmp___12;
#line 5258
      bptr = *(*(binptr + block___0) + bin);
#line 5259
      *(bptr->cell + 0) = 0;
#line 5260
      bptr->right = binOffst + bin * binWidth;
#line 5261
      bptr->left = bptr->right - binWidth;
#line 5262
      if (bin == LoBin) {
#line 5263
        bptr->penalty = left___0 - bptr->right;
      } else {
#line 5264
        if (bin == HiBin) {
#line 5265
          bptr->penalty = bptr->left - right;
        } else {
#line 5266
          if (bin > HiBin) {
#line 5267
            bptr->penalty = 0;
          } else {
#line 5266
            if (bin < LoBin) {
#line 5267
              bptr->penalty = 0;
            } else {
#line 5269
              bptr->penalty = - binWidth;
            }
          }
        }
      }
#line 5253
      bin ++;
    }
#line 5245
    block___0 ++;
  }
#line 5273
  cell___0 = 1;
#line 5273
  while (cell___0 <= numcells) {
#line 5274
    cellptr1 = *(carray + cell___0);
#line 5275
    tileptr1 = cellptr1->tileptr;
#line 5276
    block___0 = (int )cellptr1->cblock;
#line 5277
    startx = cellptr1->cxcenter + (int )tileptr1->left;
#line 5278
    endx = cellptr1->cxcenter + (int )tileptr1->right;
#line 5279
    (*(barray + block___0))->oldsize = (short )((int )(*(barray + block___0))->oldsize + (endx - startx));
#line 5280
    Trybin = (cellptr1->cxcenter - binOffst) / binWidth;
#line 5280
    if (Trybin < 0) {
#line 5280
      cbin = 0;
    } else {
#line 5280
      if (Trybin > numBins) {
#line 5280
        tmp___13 = numBins;
      } else {
#line 5280
        tmp___13 = Trybin;
      }
#line 5280
      cbin = tmp___13;
    }
#line 5281
    Trybin = (startx - binOffst) / binWidth;
#line 5281
    if (Trybin < 0) {
#line 5281
      LoBin = 0;
    } else {
#line 5281
      if (Trybin > numBins) {
#line 5281
        tmp___14 = numBins;
      } else {
#line 5281
        tmp___14 = Trybin;
      }
#line 5281
      LoBin = tmp___14;
    }
#line 5282
    Trybin = (endx - binOffst) / binWidth;
#line 5282
    if (Trybin < 0) {
#line 5282
      HiBin = 0;
    } else {
#line 5282
      if (Trybin > numBins) {
#line 5282
        tmp___15 = numBins;
      } else {
#line 5282
        tmp___15 = Trybin;
      }
#line 5282
      HiBin = tmp___15;
    }
#line 5283
    (*((*(*(binptr + block___0) + cbin))->cell + 0)) ++;
#line 5283
    k___0 = *((*(*(binptr + block___0) + cbin))->cell + 0);
#line 5284
    if (k___0 % 10 == 0) {
#line 5285
      tmp___16 = (int )safe_realloc((*(*(binptr + block___0) + cbin))->cell, (unsigned int )(k___0 + 10) * sizeof(int ));
#line 5285
      (*(*(binptr + block___0) + cbin))->cell = (int *)tmp___16;
    }
#line 5288
    *((*(*(binptr + block___0) + cbin))->cell + k___0) = cell___0;
#line 5289
    if (LoBin == HiBin) {
#line 5290
      (*(*(binptr + block___0) + LoBin))->penalty += endx - startx;
    } else {
#line 5292
      bptr = *(*(binptr + block___0) + LoBin);
#line 5293
      bptr->penalty += bptr->right - startx;
#line 5294
      bptr = *(*(binptr + block___0) + HiBin);
#line 5295
      bptr->penalty += endx - bptr->left;
#line 5296
      if (LoBin + 1 < HiBin) {
#line 5297
        bin = LoBin + 1;
#line 5297
        while (bin <= HiBin - 1) {
#line 5298
          (*(*(binptr + block___0) + bin))->penalty += binWidth;
#line 5297
          bin ++;
        }
      }
    }
#line 5273
    cell___0 ++;
  }
#line 5303
  block___0 = 1;
#line 5303
  while (block___0 <= numblock) {
#line 5304
    bin = 0;
#line 5304
    while (bin <= numBins) {
#line 5305
      if ((*(*(binptr + block___0) + bin))->penalty >= 0) {
#line 5305
        tmp___17 = (*(*(binptr + block___0) + bin))->penalty;
      } else {
#line 5305
        tmp___17 = - (*(*(binptr + block___0) + bin))->penalty;
      }
#line 5305
      binpenal += tmp___17;
#line 5304
      bin ++;
    }
#line 5303
    block___0 ++;
  }
#line 5308
  blk___0 = 1;
#line 5308
  while (blk___0 <= numblock) {
#line 5309
    if ((int )(*(barray + blk___0))->oldsize - (int )(*(barray + blk___0))->desire >= 0) {
#line 5309
      tmp___18 = (int )(*(barray + blk___0))->oldsize - (int )(*(barray + blk___0))->desire;
    } else {
#line 5309
      tmp___18 = - ((int )(*(barray + blk___0))->oldsize - (int )(*(barray + blk___0))->desire);
    }
#line 5309
    rowpenal += tmp___18;
#line 5308
    blk___0 ++;
  }
#line 5311
  penalty = (int )(binpenCon * (double )binpenal + roLenCon * (double )rowpenal);
#line 5313

  return (cost);
}
}
#line 5466
int installf(void) ;
#line 5322 "D:/a/test/300.c"
int findcostf(void) 
{ TIBOXPTR tile ;
  TIBOXPTR tileptr1 ;
  CBOXPTR cellptr1 ;
  CBOXPTR ptr ;
  DBOXPTR dimptr ;
  NBOXPTR netptr ;
  NBOXPTR termptr ;
  TEBOXPTR term ;
  BINPTR bptr ;
  int left___0 ;
  int right ;
  int corient ;
  int bin ;
  int LoBin ;
  int HiBin ;
  int block___0 ;
  int cell___0 ;
  int net ;
  int blk___0 ;
  int startx ;
  int endx ;
  int x ;
  int y ;
  int cost ;
  int k___0 ;
  int cbin ;
  int old_numBins ;
  int tmp ;
  int tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 5334
  cost = 0;
#line 5337
  blkleft = 32000;
#line 5338
  blkrite = 0;
#line 5339
  block___0 = 1;
#line 5339
  while (block___0 <= numblock) {
#line 5340
    if ((*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bleft < blkleft) {
#line 5342
      blkleft = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bleft;
    }
#line 5345
    if ((*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bright > blkrite) {
#line 5347
      blkrite = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bright;
    }
#line 5339
    block___0 ++;
  }
#line 5351
  binOffst = blkleft;
#line 5352
  max_blklength = blkrite - blkleft;
#line 5353
  old_numBins = numBins;
#line 5354
  numBins = (blkrite - binOffst) / binWidth;
#line 5355
  if (blkrite - binOffst > numBins * binWidth) {
#line 5356
    numBins ++;
  }
#line 5358
  sortpin();
#line 5359
  cell___0 = 1;
#line 5359
  while (cell___0 <= numcells + numterms) {
#line 5360
    ptr = *(carray + cell___0);
#line 5361
    corient = (int )ptr->corient;
#line 5362
    block___0 = (int )ptr->cblock;
#line 5363
    tile = ptr->tileptr;
#line 5364
    if (cell___0 <= numcells) {
#line 5365
      ptr->cycenter = (*(barray + block___0))->bycenter;
#line 5366
      term = tile->termsptr;
#line 5366
      while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 5368
        termptr = *(tearray + term->cellterm);
#line 5369
        termptr->xpos = (int )term->txpos[corient / 2] + ptr->cxcenter;
#line 5370
        termptr->ypos = (int )term->typos[corient % 2] + ptr->cycenter;
#line 5366
        term = term->nextterm;
      }
    } else {
#line 5373
      term = tile->termsptr;
#line 5373
      while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 5375
        termptr = *(tearray + term->cellterm);
#line 5376
        termptr->xpos = (int )term->txpos[1] + ptr->cxcenter;
#line 5377
        termptr->ypos = (int )term->typos[1] + ptr->cycenter;
#line 5373
        term = term->nextterm;
      }
    }
#line 5359
    cell___0 ++;
  }
#line 5381
  cost = 0;
#line 5382
  net = 1;
#line 5382
  while (net <= numnets) {
#line 5383
    dimptr = *(netarray + net);
#line 5384
    netptr = dimptr->netptr;
#line 5384
    if ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 5385
      tmp = netptr->xpos;
#line 5385
      dimptr->xmax = tmp;
#line 5385
      dimptr->xmin = tmp;
#line 5386
      tmp___0 = netptr->ypos;
#line 5386
      dimptr->ymax = tmp___0;
#line 5386
      dimptr->ymin = tmp___0;
#line 5387
      tmp___1 = (short)1;
#line 5387
      dimptr->Rnum = tmp___1;
#line 5387
      dimptr->Lnum = tmp___1;
#line 5388
      tmp___2 = (short)1;
#line 5388
      dimptr->Tnum = tmp___2;
#line 5388
      dimptr->Bnum = tmp___2;
#line 5389
      netptr = netptr->nterm;
    }
#line 5391
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 5392
      x = netptr->xpos;
#line 5393
      y = netptr->ypos;
#line 5394
      if (x < dimptr->xmin) {
#line 5395
        dimptr->xmin = x;
#line 5396
        dimptr->Lnum = (short)1;
      } else {
#line 5397
        if (x == dimptr->xmin) {
#line 5398
          dimptr->Lnum = (short )((int )dimptr->Lnum + 1);
#line 5399
          if (x == dimptr->xmax) {
#line 5400
            dimptr->Rnum = (short )((int )dimptr->Rnum + 1);
          }
        } else {
#line 5402
          if (x > dimptr->xmax) {
#line 5403
            dimptr->xmax = x;
#line 5404
            dimptr->Rnum = (short)1;
          } else {
#line 5405
            if (x == dimptr->xmax) {
#line 5406
              dimptr->Rnum = (short )((int )dimptr->Rnum + 1);
            }
          }
        }
      }
#line 5408
      if (y < dimptr->ymin) {
#line 5409
        dimptr->ymin = y;
#line 5410
        dimptr->Bnum = (short)1;
      } else {
#line 5411
        if (y == dimptr->ymin) {
#line 5412
          dimptr->Bnum = (short )((int )dimptr->Bnum + 1);
#line 5413
          if (y == dimptr->ymax) {
#line 5414
            dimptr->Tnum = (short )((int )dimptr->Tnum + 1);
          }
        } else {
#line 5416
          if (y > dimptr->ymax) {
#line 5417
            dimptr->ymax = y;
#line 5418
            dimptr->Tnum = (short)1;
          } else {
#line 5419
            if (y == dimptr->ymax) {
#line 5420
              dimptr->Tnum = (short )((int )dimptr->Tnum + 1);
            }
          }
        }
      }
#line 5391
      netptr = netptr->nterm;
    }
#line 5423
    cost += (int )(dimptr->Hweight * (double )(dimptr->xmax - dimptr->xmin)) + (int )(dimptr->Vweight * (double )(dimptr->ymax - dimptr->ymin));
#line 5382
    net ++;
  }
#line 5428
  binpenal = 0;
#line 5429
  rowpenal = 0;
#line 5430
  penalty = 0;
#line 5431
  block___0 = 1;
#line 5431
  while (block___0 <= numblock) {
#line 5432
    bin = 0;
#line 5432
    while (bin <= old_numBins) {
#line 5433
      safe_free((*(*(binptr + block___0) + bin))->cell);
#line 5434
      safe_free(*(*(binptr + block___0) + bin));
#line 5432
      bin ++;
    }
#line 5436
    safe_free(*(binptr + block___0));
#line 5431
    block___0 ++;
  }
#line 5438
  block___0 = 1;
#line 5438
  while (block___0 <= numblock) {
#line 5439
    tmp___3 = (int )safe_malloc((unsigned int )(numBins + 1) * sizeof(BINPTR ));
#line 5439
    *(binptr + block___0) = (BINPTR *)tmp___3;
#line 5441
    left___0 = (int )(*(barray + block___0))->bleft + (*(barray + block___0))->bxcenter;
#line 5442
    right = ((int )(*(barray + block___0))->bleft + (*(barray + block___0))->bxcenter) + (int )(*(barray + block___0))->desire;
#line 5444
    Trybin = (left___0 - binOffst) / binWidth;
#line 5444
    if (Trybin < 0) {
#line 5444
      LoBin = 0;
    } else {
#line 5444
      if (Trybin > numBins) {
#line 5444
        tmp___4 = numBins;
      } else {
#line 5444
        tmp___4 = Trybin;
      }
#line 5444
      LoBin = tmp___4;
    }
#line 5445
    Trybin = (right - binOffst) / binWidth;
#line 5445
    if (Trybin < 0) {
#line 5445
      HiBin = 0;
    } else {
#line 5445
      if (Trybin > numBins) {
#line 5445
        tmp___5 = numBins;
      } else {
#line 5445
        tmp___5 = Trybin;
      }
#line 5445
      HiBin = tmp___5;
    }
#line 5446
    bin = 0;
#line 5446
    while (bin <= numBins) {
#line 5447
      tmp___6 = (int )safe_malloc(sizeof(BINBOX ));
#line 5447
      *(*(binptr + block___0) + bin) = (BINBOX *)tmp___6;
#line 5449
      tmp___7 = (int )safe_malloc(10U * sizeof(int ));
#line 5449
      (*(*(binptr + block___0) + bin))->cell = (int *)tmp___7;
#line 5451
      bptr = *(*(binptr + block___0) + bin);
#line 5452
      *(bptr->cell + 0) = 0;
#line 5453
      bptr->right = binOffst + bin * binWidth;
#line 5454
      bptr->left = bptr->right - binWidth;
#line 5455
      if (bin == LoBin) {
#line 5456
        bptr->penalty = left___0 - bptr->right;
      } else {
#line 5457
        if (bin == HiBin) {
#line 5458
          bptr->penalty = bptr->left - right;
        } else {
#line 5459
          if (bin > HiBin) {
#line 5460
            bptr->penalty = 0;
          } else {
#line 5459
            if (bin < LoBin) {
#line 5460
              bptr->penalty = 0;
            } else {
#line 5462
              bptr->penalty = - binWidth;
            }
          }
        }
      }
#line 5446
      bin ++;
    }
#line 5438
    block___0 ++;
  }
#line 5466
  installf();
#line 5467
  cell___0 = 1;
#line 5467
  while (cell___0 <= numcells) {
#line 5468
    cellptr1 = *(carray + cell___0);
#line 5469
    tileptr1 = cellptr1->tileptr;
#line 5470
    block___0 = (int )cellptr1->cblock;
#line 5471
    startx = cellptr1->cxcenter + (int )tileptr1->left;
#line 5472
    endx = cellptr1->cxcenter + (int )tileptr1->right;
#line 5473
    (*(barray + block___0))->oldsize = (short )((int )(*(barray + block___0))->oldsize + (endx - startx));
#line 5474
    Trybin = (cellptr1->cxcenter - binOffst) / binWidth;
#line 5474
    if (Trybin < 0) {
#line 5474
      cbin = 0;
    } else {
#line 5474
      if (Trybin > numBins) {
#line 5474
        tmp___8 = numBins;
      } else {
#line 5474
        tmp___8 = Trybin;
      }
#line 5474
      cbin = tmp___8;
    }
#line 5475
    Trybin = (startx - binOffst) / binWidth;
#line 5475
    if (Trybin < 0) {
#line 5475
      LoBin = 0;
    } else {
#line 5475
      if (Trybin > numBins) {
#line 5475
        tmp___9 = numBins;
      } else {
#line 5475
        tmp___9 = Trybin;
      }
#line 5475
      LoBin = tmp___9;
    }
#line 5476
    Trybin = (endx - binOffst) / binWidth;
#line 5476
    if (Trybin < 0) {
#line 5476
      HiBin = 0;
    } else {
#line 5476
      if (Trybin > numBins) {
#line 5476
        tmp___10 = numBins;
      } else {
#line 5476
        tmp___10 = Trybin;
      }
#line 5476
      HiBin = tmp___10;
    }
#line 5477
    (*((*(*(binptr + block___0) + cbin))->cell + 0)) ++;
#line 5477
    k___0 = *((*(*(binptr + block___0) + cbin))->cell + 0);
#line 5478
    if (k___0 % 10 == 0) {
#line 5479
      tmp___11 = (int )safe_realloc((*(*(binptr + block___0) + cbin))->cell, (unsigned int )(k___0 + 10) * sizeof(int ));
#line 5479
      (*(*(binptr + block___0) + cbin))->cell = (int *)tmp___11;
    }
#line 5482
    *((*(*(binptr + block___0) + cbin))->cell + k___0) = cell___0;
#line 5483
    if (LoBin == HiBin) {
#line 5484
      (*(*(binptr + block___0) + LoBin))->penalty += endx - startx;
    } else {
#line 5486
      bptr = *(*(binptr + block___0) + LoBin);
#line 5487
      bptr->penalty += bptr->right - startx;
#line 5488
      bptr = *(*(binptr + block___0) + HiBin);
#line 5489
      bptr->penalty += endx - bptr->left;
#line 5490
      if (LoBin + 1 < HiBin) {
#line 5491
        bin = LoBin + 1;
#line 5491
        while (bin <= HiBin - 1) {
#line 5492
          (*(*(binptr + block___0) + bin))->penalty += binWidth;
#line 5491
          bin ++;
        }
      }
    }
#line 5467
    cell___0 ++;
  }
#line 5497
  block___0 = 1;
#line 5497
  while (block___0 <= numblock) {
#line 5498
    bin = 0;
#line 5498
    while (bin <= numBins) {
#line 5499
      if ((*(*(binptr + block___0) + bin))->penalty >= 0) {
#line 5499
        tmp___12 = (*(*(binptr + block___0) + bin))->penalty;
      } else {
#line 5499
        tmp___12 = - (*(*(binptr + block___0) + bin))->penalty;
      }
#line 5499
      binpenal += tmp___12;
#line 5498
      bin ++;
    }
#line 5497
    block___0 ++;
  }
#line 5502
  blk___0 = 1;
#line 5502
  while (blk___0 <= numblock) {
#line 5503
    if ((int )(*(barray + blk___0))->oldsize - (int )(*(barray + blk___0))->desire >= 0) {
#line 5503
      tmp___13 = (int )(*(barray + blk___0))->oldsize - (int )(*(barray + blk___0))->desire;
    } else {
#line 5503
      tmp___13 = - ((int )(*(barray + blk___0))->oldsize - (int )(*(barray + blk___0))->desire);
    }
#line 5503
    rowpenal += tmp___13;
#line 5502
    blk___0 ++;
  }
#line 5505
  penalty = (int )(binpenCon * (double )binpenal + roLenCon * (double )rowpenal);
#line 5507
  return (cost);
}
}
#line 5509 "D:/a/test/300.c"
int installf(void) 
{ int row___0 ;
  int n ;
  int left___0 ;
  int length ;
  int sep ;
  int i ;
  int bin ;
  int tmp ;

  {
#line 5512
  row___0 = 1;
#line 5512
  while (row___0 <= numRows) {
#line 5513
    n = *(feeds_in_row + row___0);
#line 5514
    if (n < 1) {
      goto __Cont;
    }
#line 5517
    left___0 = (*(barray + row___0))->bxcenter + (int )(*(barray + row___0))->bleft;
#line 5518
    length = (int )(*(barray + row___0))->bright - (int )(*(barray + row___0))->bleft;
#line 5519
    sep = (length - n * binWidth) / (n + 1);
#line 5520
    i = 1;
#line 5520
    while (i <= n) {
#line 5521
      Trybin = (((left___0 + sep * i) + binWidth / 2) - binOffst) / binWidth;
#line 5521
      if (Trybin < 0) {
#line 5521
        bin = 0;
      } else {
#line 5521
        if (Trybin > numBins) {
#line 5521
          tmp = numBins;
        } else {
#line 5521
          tmp = Trybin;
        }
#line 5521
        bin = tmp;
      }
#line 5522
      (*(*(binptr + row___0) + bin))->penalty += binWidth;
#line 5523
      (*(barray + row___0))->oldsize = (short )((int )(*(barray + row___0))->oldsize + binWidth);
#line 5520
      i ++;
    }
    __Cont: /* CIL Label */ 
#line 5512
    row___0 ++;
  }
#line 5526
  return 0;
}
}
#line 5530 "D:/a/test/300.c"
int assignro(void) 
{ TEBOXPTR pinptr ;
  NBOXPTR tmptr ;
  int row___0 ;
  int cell___0 ;
  int pad___0 ;
  int yc ;
  int yb ;
  int blk___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 5536
  tmp = (int )safe_malloc((unsigned int )(numRows + 2) * sizeof(short *));
#line 5536
  rowgrid = (short **)tmp;
#line 5538
  row___0 = 0;
#line 5538
  while (row___0 <= numRows + 1) {
#line 5539
    tmp___0 = (int )safe_malloc(3U * sizeof(short ));
#line 5539
    *(rowgrid + row___0) = (short *)tmp___0;
#line 5538
    row___0 ++;
  }
#line 5541
  cell___0 = 1;
#line 5541
  while (cell___0 <= numcells) {
#line 5542
    pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 5543
    row___0 = *(blkToRow + (*(carray + cell___0))->cblock);
#line 5544
    while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 5545
      tmptr = *(tearray + pinptr->cellterm);
#line 5546
      tmptr->row = (short )row___0;
#line 5544
      pinptr = pinptr->nextterm;
    }
#line 5541
    cell___0 ++;
  }
#line 5549
  pad___0 = numcells + 1;
#line 5549
  while (pad___0 <= numcells + numterms) {
#line 5550
    if ((int )(*(carray + pad___0))->padside == 2) {
      goto _L___0;
    } else {
#line 5550
      if ((int )(*(carray + pad___0))->padside == 14) {
        _L___0: /* CIL Label */ 
#line 5551
        row___0 = numRows + 1;
#line 5552
        pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 5553
        while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 5554
          tmptr = *(tearray + pinptr->cellterm);
#line 5555
          tmptr->row = (short )row___0;
#line 5553
          pinptr = pinptr->nextterm;
        }
      } else {
#line 5557
        if ((int )(*(carray + pad___0))->padside == 4) {
          goto _L;
        } else {
#line 5557
          if ((int )(*(carray + pad___0))->padside == 15) {
            _L: /* CIL Label */ 
#line 5558
            row___0 = 0;
#line 5559
            pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 5560
            while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 5561
              tmptr = *(tearray + pinptr->cellterm);
#line 5562
              tmptr->row = (short )row___0;
#line 5560
              pinptr = pinptr->nextterm;
            }
          } else {
#line 5565
            pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 5566
            while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 5567
              tmptr = *(tearray + pinptr->cellterm);
#line 5568
              if (no_feeds_side_nets == 1) {
#line 5569
                if ((int )(*(carray + pad___0))->padside == 1) {
#line 5571
                  (*(netarray + tmptr->net))->feedflag = (char)1;
                } else {
#line 5569
                  if ((int )(*(carray + pad___0))->padside == 3) {
#line 5571
                    (*(netarray + tmptr->net))->feedflag = (char)1;
                  }
                }
              }
#line 5574
              yc = (*(carray + pad___0))->cycenter + (int )pinptr->typos[1];
#line 5575
              blk___0 = 1;
#line 5575
              while (blk___0 <= numRows) {
#line 5576
                if ((rowArray + blk___0)->ypos >= yc) {
#line 5577
                  break;
                }
#line 5575
                blk___0 ++;
              }
#line 5580
              if (blk___0 == 1) {
#line 5581
                row___0 = 1;
              } else {
#line 5582
                if (blk___0 > numRows) {
#line 5583
                  row___0 = numRows;
                } else {
#line 5585
                  yb = (rowArray + blk___0)->ypos;
#line 5586
                  if (yb - yc < yc - (rowArray + (blk___0 - 1))->ypos) {
#line 5587
                    row___0 = blk___0;
                  } else {
#line 5589
                    row___0 = blk___0 - 1;
                  }
                }
              }
#line 5592
              tmptr->row = (short )row___0;
#line 5566
              pinptr = pinptr->nextterm;
            }
          }
        }
      }
    }
#line 5549
    pad___0 ++;
  }
#line 5596
  return 0;
}
}
#line 5598 "D:/a/test/300.c"
int reassign(void) 
{ TEBOXPTR pinptr ;
  NBOXPTR tmptr ;
  int row___0 ;
  int cell___0 ;
  int pad___0 ;
  int yc ;
  int yb ;
  int blk___0 ;

  {
#line 5604
  cell___0 = 1;
#line 5604
  while (cell___0 <= numcells) {
#line 5605
    pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 5606
    row___0 = *(blkToRow + (*(carray + cell___0))->cblock);
#line 5607
    while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 5608
      tmptr = *(tearray + pinptr->cellterm);
#line 5609
      tmptr->row = (short )row___0;
#line 5607
      pinptr = pinptr->nextterm;
    }
#line 5604
    cell___0 ++;
  }
#line 5612
  pad___0 = numcells + 1;
#line 5612
  while (pad___0 <= numcells + numterms) {
#line 5613
    if ((int )(*(carray + pad___0))->padside == 2) {
      goto _L___0;
    } else {
#line 5613
      if ((int )(*(carray + pad___0))->padside == 14) {
        _L___0: /* CIL Label */ 
#line 5614
        row___0 = numRows + 1;
#line 5615
        pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 5616
        while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 5617
          tmptr = *(tearray + pinptr->cellterm);
#line 5618
          tmptr->row = (short )row___0;
#line 5616
          pinptr = pinptr->nextterm;
        }
      } else {
#line 5620
        if ((int )(*(carray + pad___0))->padside == 4) {
          goto _L;
        } else {
#line 5620
          if ((int )(*(carray + pad___0))->padside == 15) {
            _L: /* CIL Label */ 
#line 5621
            row___0 = 0;
#line 5622
            pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 5623
            while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 5624
              tmptr = *(tearray + pinptr->cellterm);
#line 5625
              tmptr->row = (short )row___0;
#line 5623
              pinptr = pinptr->nextterm;
            }
          } else {
#line 5628
            pinptr = ((*(carray + pad___0))->tileptr)->termsptr;
#line 5629
            while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 5630
              tmptr = *(tearray + pinptr->cellterm);
#line 5631
              if (no_feeds_side_nets == 1) {
#line 5632
                if ((int )(*(carray + pad___0))->padside == 1) {
#line 5634
                  (*(netarray + tmptr->net))->feedflag = (char)1;
                } else {
#line 5632
                  if ((int )(*(carray + pad___0))->padside == 2) {
#line 5634
                    (*(netarray + tmptr->net))->feedflag = (char)1;
                  }
                }
              }
#line 5637
              yc = (*(carray + pad___0))->cycenter + (int )pinptr->typos[1];
#line 5638
              blk___0 = 1;
#line 5638
              while (blk___0 <= numRows) {
#line 5639
                if ((rowArray + blk___0)->ypos >= yc) {
#line 5640
                  break;
                }
#line 5638
                blk___0 ++;
              }
#line 5643
              if (blk___0 == 1) {
#line 5644
                row___0 = 1;
              } else {
#line 5645
                if (blk___0 > numRows) {
#line 5646
                  row___0 = numRows;
                } else {
#line 5648
                  yb = (rowArray + blk___0)->ypos;
#line 5649
                  if (yb - yc < yc - (rowArray + (blk___0 - 1))->ypos) {
#line 5650
                    row___0 = blk___0;
                  } else {
#line 5652
                    row___0 = blk___0 - 1;
                  }
                }
              }
#line 5655
              tmptr->row = (short )row___0;
#line 5629
              pinptr = pinptr->nextterm;
            }
          }
        }
      }
    }
#line 5612
    pad___0 ++;
  }
#line 5659
  return 0;
}
}
#line 5661 "D:/a/test/300.c"
int *add_to_row  ;
#line 5662 "D:/a/test/300.c"
int *length_of_row  ;
#line 5675
int prepglob(int degree ) ;
#line 5684
int impfix(void) ;
#line 5722
int del_pin(int cell___0 , int pin ) ;
#line 5766
int detfeed(int flag , int row___0 , int net ) ;
#line 5980
int implfeeds(int row___0 , int xc ) ;
#line 5995
int addfeed(int row___0 , int pos , int feednum , int net ) ;
#line 6169
int impclobr(void) ;
#line 5664 "D:/a/test/300.c"
int findfeeds(int flag ) 
{ NBOXPTR netptr ;
  NBOXPTR saveptr ;
  int check ;
  int a___0 ;
  int net ;
  int i ;
  int row___0 ;
  int l ;
  int r ;
  int toprow ;
  int botrow ;
  int orig_toprow ;
  int orig_botrow ;
  int TOP_ROW_FOR_NET ;
  int position ;
  int max_row_length ;
  int first_ok ;
  int second_ok ;
  int rowb ;
  int rowt ;
  int have_to_check ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 5673
  feeds = 0;
#line 5674
  if (! flag) {
#line 5675
    prepglob(0);
#line 5676
    impcount = 0;
#line 5677
    tmp = (int )safe_malloc((unsigned int )(1 + numRows) * sizeof(int ));
#line 5677
    act_feeds_in_row = (int *)tmp;
#line 5679
    row___0 = 1;
#line 5679
    while (row___0 <= numRows) {
#line 5680
      *(act_feeds_in_row + row___0) = 0;
#line 5679
      row___0 ++;
    }
  } else {
#line 5683
    pad_line = (numcells + ffeeds) + *(add_to_row + 0);
#line 5684
    impfix();
  }
#line 5686
  tmp___0 = (int )safe_malloc((unsigned int )(1 + numnets) * sizeof(int ));
#line 5686
  feed_location = (int *)tmp___0;
#line 5687
  net = 0;
#line 5687
  while (net <= numnets) {
#line 5688
    *(feed_location + net) = 0;
#line 5687
    net ++;
  }
#line 5690
  net = 1;
#line 5690
  while (net <= numnets) {
#line 5691
    if ((int )(*(netarray + net))->feedflag == 1) {
      goto __Cont;
    }
#line 5694
    netptr = (*(netarray + net))->netptr;
#line 5694
    if ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 5695
      i = 0;
#line 5695
      while (i <= numRows + 1) {
#line 5696
        *(*(rowgrid + i) + 0) = (short)32000;
#line 5697
        *(*(rowgrid + i) + 1) = (short)-1000;
#line 5698
        *(*(rowgrid + i) + 2) = (short)-2;
#line 5695
        i ++;
      }
#line 5700
      while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 5701
        if (flag == 0) {
#line 5701
          if ((int )netptr->cell > numcells) {
            goto _L___1;
          } else {
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 5701
          if (flag == 1) {
#line 5701
            if ((int )netptr->cell > pad_line) {
              _L___1: /* CIL Label */ 
#line 5703
              if ((int )(*(carray + netptr->cell))->padside == 1) {
                goto __Cont___0;
              } else {
#line 5703
                if ((int )(*(carray + netptr->cell))->padside == 9) {
                  goto __Cont___0;
                } else {
#line 5703
                  if ((int )(*(carray + netptr->cell))->padside == 5) {
                    goto __Cont___0;
                  } else {
#line 5703
                    if ((int )(*(carray + netptr->cell))->padside == 7) {
                      goto __Cont___0;
                    } else {
#line 5703
                      if ((int )(*(carray + netptr->cell))->padside == 3) {
                        goto __Cont___0;
                      } else {
#line 5703
                        if ((int )(*(carray + netptr->cell))->padside == 10) {
                          goto __Cont___0;
                        } else {
#line 5703
                          if ((int )(*(carray + netptr->cell))->padside == 6) {
                            goto __Cont___0;
                          } else {
#line 5703
                            if ((int )(*(carray + netptr->cell))->padside == 8) {
                              goto __Cont___0;
                            } else {
#line 5712
                              if ((unsigned int )netptr->nterm != (unsigned int )((void *)0)) {
#line 5713
                                if ((netptr->nterm)->extint == netptr->extint) {
#line 5714
                                  while (1) {
#line 5715
                                    if ((netptr->nterm)->extint == netptr->extint) {
#line 5716
                                      if ((int )netptr->row > numRows) {
#line 5716
                                        if (netptr->ypos <= (netptr->nterm)->ypos) {
#line 5720
                                          saveptr = netptr->nterm;
#line 5721
                                          netptr->nterm = saveptr->nterm;
#line 5722
                                          del_pin(saveptr->cell, saveptr->terminal);
#line 5724
                                          safe_free(saveptr);
                                        } else {
                                          goto _L___0;
                                        }
                                      } else {
                                        _L___0: /* CIL Label */ 
#line 5716
                                        if ((int )netptr->row < 1) {
#line 5716
                                          if (netptr->ypos >= (netptr->nterm)->ypos) {
#line 5720
                                            saveptr = netptr->nterm;
#line 5721
                                            netptr->nterm = saveptr->nterm;
#line 5722
                                            del_pin(saveptr->cell, saveptr->terminal);
#line 5724
                                            safe_free(saveptr);
                                          } else {
                                            goto _L;
                                          }
                                        } else {
                                          _L: /* CIL Label */ 
#line 5726
                                          if ((unsigned int )netptr == (unsigned int )(*(netarray + net))->netptr) {
#line 5727
                                            (*(netarray + net))->netptr = netptr->nterm;
#line 5728
                                            del_pin(netptr->cell, netptr->terminal);
#line 5730
                                            safe_free(netptr);
#line 5731
                                            netptr = (*(netarray + net))->netptr;
                                          } else {
#line 5733
                                            saveptr = (*(netarray + net))->netptr;
#line 5734
                                            while (1) {
#line 5735
                                              if ((unsigned int )saveptr->nterm == (unsigned int )netptr) {
#line 5736
                                                break;
                                              } else {
#line 5738
                                                saveptr = saveptr->nterm;
                                              }
                                            }
#line 5741
                                            saveptr->nterm = netptr->nterm;
#line 5742
                                            del_pin(netptr->cell, netptr->terminal);
#line 5744
                                            safe_free(netptr);
#line 5745
                                            netptr = saveptr->nterm;
                                          }
                                        }
                                      }
#line 5748
                                      if ((unsigned int )netptr->nterm == (unsigned int )((void *)0)) {
#line 5749
                                        break;
                                      }
                                    } else {
#line 5752
                                      break;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 5758
        row___0 = (int )netptr->row;
#line 5759
        if (netptr->xpos > (int )*(*(rowgrid + row___0) + 1)) {
#line 5760
          *(*(rowgrid + row___0) + 1) = (short )netptr->xpos;
        }
#line 5762
        if (netptr->xpos < (int )*(*(rowgrid + row___0) + 0)) {
#line 5763
          *(*(rowgrid + row___0) + 0) = (short )netptr->xpos;
        }
#line 5765
        if ((int )*(*(rowgrid + row___0) + 2) == -2) {
#line 5766
          tmp___1 = detfeed(flag, row___0, net);
#line 5766
          *(*(rowgrid + row___0) + 2) = (short )tmp___1;
        }
        __Cont___0: /* CIL Label */ 
#line 5700
        netptr = netptr->nterm;
      }
#line 5769
      botrow = 0;
#line 5770
      toprow = numRows + 1;
#line 5771
      while (botrow <= numRows + 1) {
#line 5772
        if ((int )*(*(rowgrid + botrow) + 1) != -1000) {
#line 5773
          break;
        }
#line 5771
        botrow ++;
      }
#line 5776
      while (toprow >= 0) {
#line 5777
        if ((int )*(*(rowgrid + toprow) + 1) != -1000) {
#line 5778
          break;
        }
#line 5776
        toprow --;
      }
#line 5782
      orig_toprow = toprow;
#line 5783
      orig_botrow = botrow;
#line 5784
      netptr = (*(netarray + net))->netptr;
#line 5785
      while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 5786
        if (flag == 0) {
#line 5786
          if ((int )netptr->cell <= numcells) {
            goto __Cont___1;
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 5786
          if (flag == 1) {
#line 5786
            if ((int )netptr->cell <= pad_line) {
              goto __Cont___1;
            }
          }
        }
#line 5790
        if ((int )(*(carray + netptr->cell))->padside != 1) {
#line 5790
          if ((int )(*(carray + netptr->cell))->padside != 9) {
#line 5790
            if ((int )(*(carray + netptr->cell))->padside != 5) {
#line 5790
              if ((int )(*(carray + netptr->cell))->padside != 7) {
#line 5790
                if ((int )(*(carray + netptr->cell))->padside != 3) {
#line 5790
                  if ((int )(*(carray + netptr->cell))->padside != 10) {
#line 5790
                    if ((int )(*(carray + netptr->cell))->padside != 6) {
#line 5790
                      if ((int )(*(carray + netptr->cell))->padside != 8) {
                        goto __Cont___1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 5800
        if ((unsigned int )netptr->nterm != (unsigned int )((void *)0)) {
#line 5801
          if ((netptr->nterm)->extint == netptr->extint) {
#line 5802
            have_to_check = 1;
          } else {
#line 5804
            have_to_check = 0;
          }
        } else {
#line 5807
          have_to_check = 0;
        }
#line 5809
        if (have_to_check) {
#line 5810
          while (1) {
#line 5811
            if ((netptr->nterm)->extint == netptr->extint) {
#line 5813
              row___0 = (int )netptr->row;
#line 5814
              if (row___0 <= toprow) {
#line 5814
                if (row___0 >= botrow) {
#line 5815
                  first_ok = 0;
                }
              }
#line 5817
              if (row___0 > toprow) {
#line 5818
                first_ok = row___0 - toprow;
              }
#line 5820
              if (row___0 < botrow) {
#line 5821
                first_ok = botrow - row___0;
              }
#line 5823
              row___0 = (int )(netptr->nterm)->row;
#line 5824
              if (row___0 <= toprow) {
#line 5824
                if (row___0 >= botrow) {
#line 5825
                  second_ok = 0;
                }
              }
#line 5827
              if (row___0 > toprow) {
#line 5828
                second_ok = row___0 - toprow;
              }
#line 5830
              if (row___0 < botrow) {
#line 5831
                second_ok = botrow - row___0;
              }
#line 5833
              if (first_ok == second_ok) {
#line 5834
                first_ok = 1000000;
#line 5835
                if ((int )netptr->row - 1 >= 0) {
#line 5835
                  rowb = (int )netptr->row - 1;
                } else {
#line 5835
                  rowb = 0;
                }
#line 5837
                if ((int )netptr->row + 1 <= numRows + 1) {
#line 5837
                  rowt = (int )netptr->row + 1;
                } else {
#line 5837
                  rowt = numRows + 1;
                }
#line 5839
                row___0 = rowb;
#line 5839
                while (row___0 <= rowt) {
#line 5840
                  if ((int )*(*(rowgrid + row___0) + 1) == -1000) {
                    goto __Cont___2;
                  }
#line 5843
                  if (netptr->xpos <= (int )*(*(rowgrid + row___0) + 1)) {
#line 5843
                    if (netptr->xpos >= (int )*(*(rowgrid + row___0) + 0)) {
#line 5847
                      first_ok = 0;
                    } else {
                      goto _L___4;
                    }
                  } else {
                    _L___4: /* CIL Label */ 
#line 5848
                    if (netptr->xpos > (int )*(*(rowgrid + row___0) + 1)) {
#line 5850
                      if (netptr->xpos - (int )*(*(rowgrid + row___0) + 1) < first_ok) {
#line 5853
                        first_ok = netptr->xpos - (int )*(*(rowgrid + row___0) + 1);
                      }
                    } else {
#line 5857
                      if ((int )*(*(rowgrid + row___0) + 0) - netptr->xpos < first_ok) {
#line 5859
                        first_ok = (int )*(*(rowgrid + row___0) + 0) - netptr->xpos;
                      }
                    }
                  }
                  __Cont___2: /* CIL Label */ 
#line 5839
                  row___0 ++;
                }
#line 5864
                second_ok = 1000000;
#line 5865
                if ((int )(netptr->nterm)->row - 1 >= 0) {
#line 5865
                  rowb = (int )(netptr->nterm)->row - 1;
                } else {
#line 5865
                  rowb = 0;
                }
#line 5867
                if ((int )(netptr->nterm)->row + 1 <= numRows + 1) {
#line 5867
                  rowt = (int )(netptr->nterm)->row + 1;
                } else {
#line 5867
                  rowt = numRows + 1;
                }
#line 5870
                row___0 = rowb;
#line 5870
                while (row___0 <= rowt) {
#line 5871
                  if ((int )*(*(rowgrid + row___0) + 1) == -1000) {
                    goto __Cont___3;
                  }
#line 5874
                  if ((netptr->nterm)->xpos <= (int )*(*(rowgrid + row___0) + 1)) {
#line 5874
                    if ((netptr->nterm)->xpos >= (int )*(*(rowgrid + row___0) + 0)) {
#line 5878
                      second_ok = 0;
                    } else {
                      goto _L___5;
                    }
                  } else {
                    _L___5: /* CIL Label */ 
#line 5879
                    if ((netptr->nterm)->xpos > (int )*(*(rowgrid + row___0) + 1)) {
#line 5881
                      if ((netptr->nterm)->xpos - (int )*(*(rowgrid + row___0) + 1) < second_ok) {
#line 5884
                        second_ok = (netptr->nterm)->xpos - (int )*(*(rowgrid + row___0) + 1);
                      }
                    } else {
#line 5888
                      if ((int )*(*(rowgrid + row___0) + 0) - (netptr->nterm)->xpos < second_ok) {
#line 5890
                        second_ok = (int )*(*(rowgrid + row___0) + 0) - (netptr->nterm)->xpos;
                      }
                    }
                  }
                  __Cont___3: /* CIL Label */ 
#line 5870
                  row___0 ++;
                }
              }
#line 5896
              if (first_ok <= second_ok) {
#line 5897
                saveptr = netptr->nterm;
#line 5898
                netptr->nterm = saveptr->nterm;
#line 5899
                del_pin(saveptr->cell, saveptr->terminal);
#line 5900
                safe_free(saveptr);
              } else {
#line 5902
                if ((unsigned int )netptr == (unsigned int )(*(netarray + net))->netptr) {
#line 5903
                  (*(netarray + net))->netptr = netptr->nterm;
#line 5904
                  del_pin(netptr->cell, netptr->terminal);
#line 5905
                  safe_free(netptr);
#line 5906
                  netptr = (*(netarray + net))->netptr;
                } else {
#line 5908
                  saveptr = (*(netarray + net))->netptr;
#line 5909
                  while (1) {
#line 5910
                    if ((unsigned int )saveptr->nterm == (unsigned int )netptr) {
#line 5911
                      break;
                    } else {
#line 5913
                      saveptr = saveptr->nterm;
                    }
                  }
#line 5916
                  saveptr->nterm = netptr->nterm;
#line 5917
                  del_pin(netptr->cell, netptr->terminal);
#line 5918
                  safe_free(netptr);
#line 5919
                  netptr = saveptr->nterm;
                }
              }
#line 5922
              if ((unsigned int )netptr->nterm == (unsigned int )((void *)0)) {
#line 5923
                break;
              }
            } else {
#line 5926
              break;
            }
          }
        }
#line 5931
        row___0 = (int )netptr->row;
#line 5932
        if (row___0 <= orig_toprow) {
#line 5932
          if (row___0 >= orig_botrow) {
            goto __Cont___1;
          }
        }
#line 5935
        if (row___0 > toprow) {
#line 5936
          toprow = row___0;
        }
#line 5938
        if (row___0 < botrow) {
#line 5939
          botrow = row___0;
        }
#line 5941
        if (netptr->xpos > (int )*(*(rowgrid + row___0) + 1)) {
#line 5942
          *(*(rowgrid + row___0) + 1) = (short )netptr->xpos;
        }
#line 5944
        if (netptr->xpos < (int )*(*(rowgrid + row___0) + 0)) {
#line 5945
          *(*(rowgrid + row___0) + 0) = (short )netptr->xpos;
        }
#line 5947
        if ((int )*(*(rowgrid + row___0) + 2) == -2) {
#line 5948
          tmp___2 = detfeed(flag, row___0, net);
#line 5948
          *(*(rowgrid + row___0) + 2) = (short )tmp___2;
        }
        __Cont___1: /* CIL Label */ 
#line 5785
        netptr = netptr->nterm;
      }
#line 5952
      if (toprow != botrow) {
#line 5953
        row___0 = toprow;
#line 5954
        TOP_ROW_FOR_NET = 1;
#line 5955
        row___0 --;
#line 5955
        while (row___0 >= botrow) {
#line 5956
          if ((int )*(*(rowgrid + row___0) + 1) == -1000) {
            goto __Cont___4;
          }
#line 5959
          if ((int )*(*(rowgrid + toprow) + 0) <= (int )*(*(rowgrid + row___0) + 0)) {
#line 5959
            l = (int )*(*(rowgrid + toprow) + 0);
          } else {
#line 5959
            l = (int )*(*(rowgrid + row___0) + 0);
          }
#line 5963
          if ((int )*(*(rowgrid + toprow) + 1) >= (int )*(*(rowgrid + row___0) + 1)) {
#line 5963
            r = (int )*(*(rowgrid + toprow) + 1);
          } else {
#line 5963
            r = (int )*(*(rowgrid + row___0) + 1);
          }
#line 5967
          position = (l + r) / 2;
#line 5968
          if (gate_array_special) {
#line 5969
            if (*(feed_location + net) == 0) {
#line 5970
              *(feed_location + net) = position;
            } else {
#line 5972
              position = *(feed_location + net);
            }
          }
#line 5975
          if (TOP_ROW_FOR_NET == 1) {
#line 5976
            if ((int )*(*(rowgrid + toprow) + 2) == 1) {
              goto _L___6;
            } else {
#line 5976
              if ((int )*(*(rowgrid + toprow) + 2) == 3) {
                _L___6: /* CIL Label */ 
#line 5978
                if (! *(nofeed + toprow)) {
#line 5979
                  if (flag == 0) {
#line 5980
                    tmp___3 = implfeeds(toprow, position);
#line 5980
                    if (tmp___3) {
#line 5981
                      impcount ++;
                    } else {
#line 5983
                      feeds ++;
#line 5984
                      (*(act_feeds_in_row + toprow)) ++;
#line 5985
                      if (gate_array_special == 1) {
#line 5986
                        build_feed_imp(feeds, position - fdWidth / 2, toprow);
                      }
                    }
                  } else {
#line 5992
                    tmp___4 = implfeeds(toprow, position);
#line 5992
                    if (tmp___4) {
#line 5993
                      addimp(toprow, net);
                    } else {
#line 5995
                      feeds ++;
#line 5995
                      addfeed(toprow, position, feeds, net);
#line 5997
                      if (gate_array_special == 1) {
#line 5998
                        build_feed_imp(feeds, position - fdWidth / 2, toprow);
                      }
                    }
                  }
                }
              }
            }
          }
#line 6007
          if (row___0 > botrow) {
#line 6008
            if ((int )*(*(rowgrid + row___0) + 2) != 4) {
#line 6009
              if (! *(nofeed + row___0)) {
#line 6010
                if (flag == 0) {
#line 6011
                  tmp___5 = implfeeds(row___0, position);
#line 6011
                  if (tmp___5) {
#line 6012
                    impcount ++;
                  } else {
#line 6014
                    feeds ++;
#line 6015
                    (*(act_feeds_in_row + row___0)) ++;
#line 6016
                    if (gate_array_special == 1) {
#line 6017
                      build_feed_imp(feeds, position - fdWidth / 2, row___0);
                    }
                  }
                } else {
#line 6023
                  tmp___6 = implfeeds(row___0, position);
#line 6023
                  if (tmp___6) {
#line 6024
                    addimp(row___0, net);
                  } else {
#line 6026
                    feeds ++;
#line 6026
                    addfeed(row___0, position, feeds, net);
#line 6028
                    if (gate_array_special == 1) {
#line 6029
                      build_feed_imp(feeds, position - fdWidth / 2, row___0);
                    }
                  }
                }
              }
            }
          }
#line 6038
          if (row___0 == botrow) {
#line 6039
            if ((int )*(*(rowgrid + botrow) + 2) == 2) {
              goto _L___7;
            } else {
#line 6039
              if ((int )*(*(rowgrid + botrow) + 2) == 3) {
                _L___7: /* CIL Label */ 
#line 6041
                if (! *(nofeed + botrow)) {
#line 6042
                  if (flag == 0) {
#line 6043
                    tmp___7 = implfeeds(botrow, position);
#line 6043
                    if (tmp___7) {
#line 6044
                      impcount ++;
                    } else {
#line 6046
                      feeds ++;
#line 6047
                      (*(act_feeds_in_row + botrow)) ++;
#line 6048
                      if (gate_array_special == 1) {
#line 6049
                        build_feed_imp(feeds, position - fdWidth / 2, botrow);
                      }
                    }
                  } else {
#line 6055
                    tmp___8 = implfeeds(botrow, position);
#line 6055
                    if (tmp___8) {
#line 6056
                      addimp(botrow, net);
                    } else {
#line 6058
                      feeds ++;
#line 6058
                      addfeed(botrow, position, feeds, net);
#line 6060
                      if (gate_array_special == 1) {
#line 6061
                        build_feed_imp(feeds, position - fdWidth / 2, botrow);
                      }
                    }
                  }
                }
              }
            }
          }
#line 6070
          check = (toprow - row___0) - 1;
#line 6071
          if (check != 0) {
#line 6072
            a___0 = toprow - 1;
#line 6072
            while (a___0 > row___0) {
#line 6073
              if (! *(nofeed + a___0)) {
#line 6074
                if (flag == 0) {
#line 6075
                  tmp___9 = implfeeds(a___0, position);
#line 6075
                  if (tmp___9) {
#line 6076
                    impcount ++;
                  } else {
#line 6078
                    feeds ++;
#line 6079
                    (*(act_feeds_in_row + a___0)) ++;
#line 6080
                    if (gate_array_special == 1) {
#line 6081
                      build_feed_imp(feeds, position - fdWidth / 2, a___0);
                    }
                  }
                } else {
#line 6086
                  tmp___10 = implfeeds(a___0, position);
#line 6086
                  if (tmp___10) {
#line 6087
                    addimp(a___0, net);
                  } else {
#line 6089
                    feeds ++;
#line 6089
                    addfeed(a___0, position, feeds, net);
#line 6091
                    if (gate_array_special == 1) {
#line 6092
                      build_feed_imp(feeds, position - fdWidth / 2, a___0);
                    }
                  }
                }
              }
#line 6072
              a___0 --;
            }
          }
#line 6100
          toprow = row___0;
#line 6101
          TOP_ROW_FOR_NET = 0;
          __Cont___4: /* CIL Label */ 
#line 5955
          row___0 --;
        }
      } else {
#line 6104
        if ((int )(*(netarray + net))->feedflag == 0) {
#line 6105
          if ((int )*(*(rowgrid + toprow) + 2) == 3) {
#line 6106
            if (! *(nofeed + toprow)) {
#line 6107
              l = (int )*(*(rowgrid + toprow) + 0);
#line 6108
              r = (int )*(*(rowgrid + toprow) + 1);
#line 6109
              position = (l + r) / 2;
#line 6110
              if (gate_array_special) {
#line 6111
                if (*(feed_location + net) == 0) {
#line 6112
                  *(feed_location + net) = position;
                } else {
#line 6114
                  position = *(feed_location + net);
                }
              }
#line 6117
              if (flag == 0) {
#line 6118
                tmp___11 = implfeeds(toprow, position);
#line 6118
                if (tmp___11) {
#line 6119
                  impcount ++;
                } else {
#line 6121
                  feeds ++;
#line 6122
                  (*(act_feeds_in_row + toprow)) ++;
#line 6123
                  if (gate_array_special == 1) {
#line 6124
                    build_feed_imp(feeds, position - fdWidth / 2, toprow);
                  }
                }
              } else {
#line 6130
                tmp___12 = implfeeds(toprow, position);
#line 6130
                if (tmp___12) {
#line 6131
                  addimp(toprow, net);
                } else {
#line 6133
                  feeds ++;
#line 6133
                  addfeed(toprow, position, feeds, net);
#line 6134
                  if (gate_array_special == 1) {
#line 6135
                    build_feed_imp(feeds, position - fdWidth / 2, toprow);
                  }
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 5690
    net ++;
  }
#line 6147
  if (flag == 0) {
#line 6148
    ffeeds = feeds;
#line 6149
    row___0 = 1;
#line 6149
    while (row___0 <= numRows) {
#line 6150
      *(length_of_row + row___0) += *(act_feeds_in_row + row___0) * fdWidth;
#line 6149
      row___0 ++;
    }
#line 6152
    max_row_length = 0;
#line 6153
    row___0 = 1;
#line 6153
    while (row___0 <= numRows) {
#line 6154
      if (*(length_of_row + row___0) > max_row_length) {
#line 6155
        max_row_length = *(length_of_row + row___0);
      }
#line 6153
      row___0 ++;
    }
#line 6158
    *(add_to_row + 0) = 0;
#line 6159
    row___0 = 1;
#line 6159
    while (row___0 <= numRows) {
#line 6160
      *(add_to_row + row___0) = (max_row_length - *(length_of_row + row___0)) / fdWidth;
#line 6162
      *(add_to_row + 0) += *(add_to_row + row___0);
#line 6159
      row___0 ++;
    }
#line 6164
    safe_free(length_of_row);
#line 6165
    if (addFeeds) {
#line 6166
      prepglob(1);
    }
  } else {
#line 6169
    impclobr();
#line 6170
    last_feed = feeds;
  }
#line 6172
  safe_free(feed_location);
#line 6173
  return (feeds);
}
}
#line 6175 "D:/a/test/300.c"
int del_pin(int cell___0 , int pin ) 
{ TEBOXPTR tptr ;
  TEBOXPTR sptr ;

  {
#line 6179
  (*(carray + cell___0))->numterms = (short )((int )(*(carray + cell___0))->numterms - 1);
#line 6180
  tptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 6181
  if (tptr->cellterm == pin) {
#line 6182
    sptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 6183
    ((*(carray + cell___0))->tileptr)->termsptr = tptr->nextterm;
#line 6184
    safe_free(sptr);
  } else {
#line 6186
    while (1) {
#line 6187
      if ((tptr->nextterm)->cellterm == pin) {
#line 6188
        break;
      } else {
#line 6190
        tptr = tptr->nextterm;
      }
    }
#line 6193
    sptr = tptr->nextterm;
#line 6194
    tptr->nextterm = sptr->nextterm;
#line 6195
    safe_free(sptr);
  }
#line 6197
  return 0;
}
}
#line 6199 "D:/a/test/300.c"
int fixwolf(int nfeed ) 
{ CBOXPTR *newarray ;
  CBOXPTR ptr ;
  int i ;
  int j ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 6204
  n = numcells;
#line 6205
  tmp = (int )safe_malloc((unsigned int )((((1 + numcells) + numterms) + 2 * numblock) + nfeed) * sizeof(CBOXPTR ));
#line 6205
  newarray = (CBOXPTR *)tmp;
#line 6207
  tmp___0 = (int )safe_realloc(tearray, (unsigned int )((2 * (((nfeed + impcount) + numblock) + 1) + maxterm) + 1) * sizeof(NBOXPTR ));
#line 6207
  tearray = (NBOXPTR *)tmp___0;
#line 6209
  tmp___1 = (int )safe_realloc(pinnames, (unsigned int )((1 + maxterm) + 2 * (nfeed + impcount)) * sizeof(char *));
#line 6209
  pinnames = (char **)tmp___1;
#line 6211
  i = 1;
#line 6211
  while (i <= n) {
#line 6212
    *(newarray + i) = *(carray + i);
#line 6211
    i ++;
  }
#line 6214
  j = n + 1;
#line 6214
  while (j <= n + nfeed) {
#line 6215
    tmp___2 = (int )safe_malloc(sizeof(CBOX ));
#line 6215
    ptr = (struct cellbox *)tmp___2;
#line 6215
    *(newarray + j) = ptr;
#line 6216
    ptr->corient = (char)0;
#line 6217
    ptr->cclass = (short)0;
#line 6218
    if (gate_array_special) {
#line 6219
      ptr->orflag = (char)1;
    } else {
#line 6221
      ptr->orflag = (char)0;
    }
#line 6223
    ptr->numterms = (short)2;
#line 6224
    tmp___3 = (int )safe_malloc(sizeof(TIBOX ));
#line 6224
    ptr->tileptr = (struct tilebox *)tmp___3;
#line 6225
    tmp___4 = (int )safe_malloc(sizeof(TEBOX ));
#line 6225
    (ptr->tileptr)->termsptr = (struct termbox *)tmp___4;
#line 6226
    maxterm ++;
#line 6226
    ((ptr->tileptr)->termsptr)->cellterm = maxterm;
#line 6227
    tmp___5 = (int )safe_malloc(16U * sizeof(char ));
#line 6227
    *(pinnames + maxterm) = (char *)tmp___5;
#line 6228
    sprintf(*(pinnames + maxterm), "twfeed%d", maxterm);
#line 6229
    ((ptr->tileptr)->termsptr)->ei = maxterm;
#line 6230
    ((ptr->tileptr)->termsptr)->ue = (short)0;
#line 6231
    tmp___6 = (int )safe_malloc(sizeof(TEBOX ));
#line 6231
    ((ptr->tileptr)->termsptr)->nextterm = (struct termbox *)tmp___6;
#line 6233
    (((ptr->tileptr)->termsptr)->nextterm)->nextterm = (struct termbox *)((void *)0);
#line 6234
    (((ptr->tileptr)->termsptr)->nextterm)->ei = maxterm;
#line 6235
    (((ptr->tileptr)->termsptr)->nextterm)->ue = (short)0;
#line 6236
    maxterm ++;
#line 6236
    (((ptr->tileptr)->termsptr)->nextterm)->cellterm = maxterm;
#line 6237
    tmp___7 = (int )safe_malloc(16U * sizeof(char ));
#line 6237
    *(pinnames + maxterm) = (char *)tmp___7;
#line 6238
    sprintf(*(pinnames + maxterm), "twfeed%d", maxterm);
#line 6214
    j ++;
  }
#line 6240
  while (i <= numcells + numterms) {
#line 6241
    *(newarray + j) = *(carray + i);
#line 6240
    i ++;
#line 6240
    j ++;
  }
#line 6243
  safe_free(carray);
#line 6244
  tmp___8 = (int )safe_realloc(newarray, (unsigned int )((((1 + numcells) + numterms) + 2 * numblock) + nfeed) * sizeof(CBOXPTR ));
#line 6244
  carray = (CBOXPTR *)tmp___8;
#line 6246
  return 0;
}
}
#line 6256
int rowToBlk(int row___0 , int pos ) ;
#line 6248 "D:/a/test/300.c"
int addfeed(int row___0 , int pos , int feednum , int net ) 
{ CBOXPTR cellptr___0 ;
  TIBOXPTR tileptr ;
  NBOXPTR nptr ;
  TEBOXPTR termptr ;
  int pin ;
  int blk___0 ;
  int corient ;
  int tmp ;
  struct netbox *tmp___0 ;
  int tmp___1 ;
  struct netbox *tmp___2 ;
  int tmp___3 ;

  {
#line 6256
  blk___0 = rowToBlk(row___0, pos);
#line 6257
  cellptr___0 = *(carray + (numcells + feednum));
#line 6258
  cellptr___0->padside = (short)0;
#line 6259
  cellptr___0->cxcenter = pos;
#line 6260
  cellptr___0->cycenter = (*(barray + blk___0))->bycenter;
#line 6261
  cellptr___0->cheight = (*(barray + blk___0))->bheight;
#line 6262
  cellptr___0->clength = (short )fdWidth;
#line 6263
  if ((int )(*(barray + blk___0))->borient == 2) {
#line 6264
    cellptr___0->corient = (char)1;
  }
#line 6266
  tileptr = cellptr___0->tileptr;
#line 6267
  tmp = (int )safe_malloc(16U * sizeof(char ));
#line 6267
  cellptr___0->cname = (char *)tmp;
#line 6268
  if (gate_array_special) {
#line 6269
    sprintf(cellptr___0->cname, "twfeed");
  } else {
#line 6272
    sprintf(cellptr___0->cname, "twfeed%d", feednum);
  }
#line 6277
  cellptr___0->cblock = (short )blk___0;
#line 6278
  tileptr->left = (short )(- fdWidth / 2);
#line 6279
  tileptr->right = (short )(fdWidth + (int )tileptr->left);
#line 6280
  tileptr->bottom = (short )(- ((int )(*(barray + blk___0))->bheight) / 2);
#line 6281
  tileptr->top = (short )((int )(*(barray + blk___0))->bheight + (int )tileptr->bottom);
#line 6282
  termptr = tileptr->termsptr;
#line 6283
  termptr->txpos[0] = (short)0;
#line 6284
  termptr->txpos[1] = (short)0;
#line 6285
  corient = (int )cellptr___0->corient;
#line 6286
  if (corient == 0) {
#line 6287
    termptr->typos[0] = tileptr->top;
#line 6288
    termptr->typos[1] = tileptr->bottom;
  } else {
#line 6290
    termptr->typos[0] = tileptr->bottom;
#line 6291
    termptr->typos[1] = tileptr->top;
  }
#line 6293
  termptr = termptr->nextterm;
#line 6294
  termptr->txpos[0] = (short)0;
#line 6295
  termptr->txpos[1] = (short)0;
#line 6296
  if (corient == 0) {
#line 6297
    termptr->typos[0] = tileptr->bottom;
#line 6298
    termptr->typos[1] = tileptr->top;
  } else {
#line 6300
    termptr->typos[0] = tileptr->top;
#line 6301
    termptr->typos[1] = tileptr->bottom;
  }
#line 6303
  pin = (tileptr->termsptr)->cellterm;
#line 6304
  nptr = (*(netarray + net))->netptr;
#line 6305
  if ((unsigned int )nptr == (unsigned int )((struct netbox *)((void *)0))) {
#line 6306
    fprintf(fpo, "no pins in net to be ");
#line 6307
    fprintf(fpo, "connected to feed thru\n");
#line 6308
    exit(1);
  }
#line 6310
  while ((unsigned int )nptr->nterm != (unsigned int )((struct netbox *)((void *)0))) {
#line 6310
    nptr = nptr->nterm;
  }
#line 6311
  tmp___1 = (int )safe_malloc(sizeof(NBOX ));
#line 6311
  tmp___0 = (struct netbox *)tmp___1;
#line 6311
  nptr->nterm = tmp___0;
#line 6311
  nptr = tmp___0;
#line 6312
  *(tearray + pin) = nptr;
#line 6313
  nptr->terminal = pin;
#line 6314
  nptr->flag = (char)0;
#line 6315
  nptr->row = (short )row___0;
#line 6316
  nptr->cell = (short )(numcells + feednum);
#line 6317
  nptr->net = (short )net;
#line 6318
  nptr->extint = (tileptr->termsptr)->ei;
#line 6319
  nptr->unequiv = (char )(tileptr->termsptr)->ue;
#line 6320
  nptr->layer = (char )feedLayer;
#line 6321
  nptr->pinloc = (char)1;
#line 6322
  pin = ((tileptr->termsptr)->nextterm)->cellterm;
#line 6323
  tmp___3 = (int )safe_malloc(sizeof(NBOX ));
#line 6323
  tmp___2 = (struct netbox *)tmp___3;
#line 6323
  nptr->nterm = tmp___2;
#line 6323
  nptr = tmp___2;
#line 6324
  *(tearray + pin) = nptr;
#line 6325
  nptr->nterm = (struct netbox *)((void *)0);
#line 6326
  nptr->terminal = pin;
#line 6327
  nptr->flag = (char)0;
#line 6328
  nptr->row = (short )row___0;
#line 6329
  nptr->cell = (short )(numcells + feednum);
#line 6330
  nptr->net = (short )net;
#line 6331
  nptr->extint = ((tileptr->termsptr)->nextterm)->ei;
#line 6332
  nptr->unequiv = (char )((tileptr->termsptr)->nextterm)->ue;
#line 6333
  nptr->layer = (char )feedLayer;
#line 6334
  nptr->pinloc = (char)-1;
#line 6335
  return 0;
}
}
#line 6337 "D:/a/test/300.c"
int rowToBlk(int row___0 , int pos ) 
{ int y ;
  int block___0 ;
  int block1 ;
  int block2 ;
  int startx1 ;
  int endx1 ;
  int startx2 ;
  int endx2 ;

  {
#line 6342
  y = (rowArray + row___0)->ypos;
#line 6343
  block1 = 0;
#line 6344
  block2 = 0;
#line 6345
  block___0 = 1;
#line 6345
  while (block___0 <= numblock) {
#line 6346
    if ((*(barray + block___0))->bycenter == y) {
#line 6347
      block1 = block___0;
#line 6348
      break;
    }
#line 6345
    block___0 ++;
  }
#line 6351
  block___0 ++;
#line 6351
  while (block___0 <= numblock) {
#line 6352
    if ((*(barray + block___0))->bycenter == y) {
#line 6353
      block2 = block___0;
#line 6354
      break;
    }
#line 6351
    block___0 ++;
  }
#line 6357
  if (block1 == 0) {
#line 6358
    fprintf(fpo, "rowToBlk failed to find block corresponding\n");
#line 6359
    fprintf(fpo, "to row:%d\n", row___0);
#line 6360
    exit(1);
  }
#line 6362
  if (block2 == 0) {
#line 6363
    block___0 = block1;
  } else {
#line 6365
    startx1 = (*(barray + block1))->bxcenter + (int )(*(barray + block1))->bleft;
#line 6366
    endx1 = (*(barray + block1))->bxcenter + (int )(*(barray + block1))->bright;
#line 6367
    startx2 = (*(barray + block2))->bxcenter + (int )(*(barray + block2))->bleft;
#line 6368
    endx2 = (*(barray + block2))->bxcenter + (int )(*(barray + block2))->bright;
#line 6369
    if (pos >= startx1) {
#line 6369
      if (pos <= endx1) {
#line 6370
        block___0 = block1;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 6371
      if (pos >= startx2) {
#line 6371
        if (pos <= endx2) {
#line 6372
          block___0 = block2;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 6375
        if (endx2 < startx1) {
#line 6376
          if (pos - endx2 <= startx1 - pos) {
#line 6377
            block___0 = block2;
          } else {
#line 6379
            block___0 = block1;
          }
        } else {
#line 6382
          if (pos - endx1 <= startx2 - pos) {
#line 6383
            block___0 = block1;
          } else {
#line 6385
            block___0 = block2;
          }
        }
      }
    }
  }
#line 6390
  return (block___0);
}
}
#line 6392 "D:/a/test/300.c"
int prepglob(int degree ) 
{ TEBOXPTR pinptr ;
  int cell___0 ;
  int corient ;
  int tmp ;

  {
#line 6397
  if (degree == 0) {
#line 6398
    cell___0 = 1;
#line 6398
    while (cell___0 <= numcells + numterms) {
#line 6399
      if (cell___0 <= numcells) {
#line 6400
        pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 6401
        corient = (int )(*(carray + cell___0))->corient;
#line 6402
        while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 6403
          (*(tearray + pinptr->cellterm))->extint = pinptr->ei;
#line 6404
          (*(tearray + pinptr->cellterm))->unequiv = (char )pinptr->ue;
#line 6405
          if ((int )pinptr->typos[corient % 2] >= 0) {
#line 6405
            tmp = (int )pinptr->typos[corient % 2];
          } else {
#line 6405
            tmp = - ((int )pinptr->typos[corient % 2]);
          }
#line 6405
          if (tmp > 1) {
#line 6406
            if ((int )pinptr->typos[corient % 2] > 0) {
#line 6407
              (*(tearray + pinptr->cellterm))->pinloc = (char)1;
            } else {
#line 6409
              (*(tearray + pinptr->cellterm))->pinloc = (char)-1;
            }
          } else {
#line 6412
            (*(tearray + pinptr->cellterm))->pinloc = (char)0;
          }
#line 6402
          pinptr = pinptr->nextterm;
        }
      } else {
#line 6415
        if (cell___0 > numcells) {
#line 6416
          pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 6417
          while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 6418
            (*(tearray + pinptr->cellterm))->cell = (short )cell___0;
#line 6419
            (*(tearray + pinptr->cellterm))->extint = pinptr->ei;
#line 6420
            (*(tearray + pinptr->cellterm))->unequiv = (char )pinptr->ue;
#line 6421
            (*(tearray + pinptr->cellterm))->pinloc = (char)0;
#line 6417
            pinptr = pinptr->nextterm;
          }
        }
      }
#line 6398
      cell___0 ++;
    }
  } else {
#line 6426
    cell___0 = numcells + 1;
#line 6426
    while (cell___0 <= numcells + numterms) {
#line 6427
      pinptr = ((*(carray + cell___0))->tileptr)->termsptr;
#line 6428
      while ((unsigned int )pinptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 6429
        (*(tearray + pinptr->cellterm))->cell = (short )((cell___0 + ffeeds) + *(add_to_row + 0));
#line 6428
        pinptr = pinptr->nextterm;
      }
#line 6426
      cell___0 ++;
    }
  }
#line 6434
  return 0;
}
}
#line 6436 "D:/a/test/300.c"
int detfeed(int flag , int row___0 , int net ) 
{ CBOXPTR cellptr___0 ;
  NBOXPTR nptr ;
  NBOXPTR nptr2 ;
  int pinup ;
  int pindown ;
  int extint ;
  int pinloc ;

  {
#line 6445
  pinup = 0;
#line 6446
  pindown = 0;
#line 6447
  nptr = (*(netarray + net))->netptr;
#line 6447
  while ((unsigned int )nptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 6448
    if ((int )nptr->row != row___0) {
      goto __Cont;
    } else {
#line 6448
      if ((int )nptr->unequiv == 1) {
        goto __Cont;
      }
    }
#line 6451
    if (flag == 0) {
#line 6451
      if ((int )nptr->cell > numcells) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 6451
      if (flag == 1) {
#line 6451
        if ((int )nptr->cell > pad_line) {
          _L: /* CIL Label */ 
#line 6453
          cellptr___0 = *(carray + nptr->cell);
#line 6454
          if ((int )cellptr___0->padside == 1) {
            goto __Cont;
          } else {
#line 6454
            if ((int )cellptr___0->padside == 9) {
              goto __Cont;
            } else {
#line 6454
              if ((int )cellptr___0->padside == 5) {
                goto __Cont;
              } else {
#line 6454
                if ((int )cellptr___0->padside == 7) {
                  goto __Cont;
                } else {
#line 6454
                  if ((int )cellptr___0->padside == 3) {
                    goto __Cont;
                  } else {
#line 6454
                    if ((int )cellptr___0->padside == 10) {
                      goto __Cont;
                    } else {
#line 6454
                      if ((int )cellptr___0->padside == 6) {
                        goto __Cont;
                      } else {
#line 6454
                        if ((int )cellptr___0->padside == 8) {
                          goto __Cont;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 6465
    extint = nptr->extint;
#line 6466
    pinloc = (int )nptr->pinloc;
#line 6467
    if (pinloc == 0) {
#line 6468
      return (4);
    }
#line 6470
    if (pinloc > 0) {
#line 6471
      pinup = 1;
    } else {
#line 6473
      pindown = 1;
    }
#line 6475
    nptr2 = nptr->nterm;
#line 6476
    while ((unsigned int )nptr2 != (unsigned int )((struct netbox *)((void *)0))) {
#line 6477
      if ((int )nptr2->row != row___0) {
        goto __Cont___0;
      } else {
#line 6477
        if ((int )nptr2->unequiv == 1) {
          goto __Cont___0;
        }
      }
#line 6480
      if (flag == 0) {
#line 6480
        if ((int )nptr2->cell > numcells) {
          goto _L___1;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 6480
        if (flag == 1) {
#line 6480
          if ((int )nptr2->cell > pad_line) {
            _L___1: /* CIL Label */ 
#line 6482
            cellptr___0 = *(carray + nptr2->cell);
#line 6483
            if ((int )cellptr___0->padside == 1) {
              goto __Cont___0;
            } else {
#line 6483
              if ((int )cellptr___0->padside == 9) {
                goto __Cont___0;
              } else {
#line 6483
                if ((int )cellptr___0->padside == 5) {
                  goto __Cont___0;
                } else {
#line 6483
                  if ((int )cellptr___0->padside == 7) {
                    goto __Cont___0;
                  } else {
#line 6483
                    if ((int )cellptr___0->padside == 3) {
                      goto __Cont___0;
                    } else {
#line 6483
                      if ((int )cellptr___0->padside == 10) {
                        goto __Cont___0;
                      } else {
#line 6483
                        if ((int )cellptr___0->padside == 6) {
                          goto __Cont___0;
                        } else {
#line 6483
                          if ((int )cellptr___0->padside == 8) {
                            goto __Cont___0;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 6494
      if ((int )nptr2->pinloc == 0) {
#line 6495
        return (4);
      }
#line 6497
      if (nptr2->extint == extint) {
#line 6498
        if ((int )nptr2->pinloc != pinloc) {
#line 6499
          return (4);
        }
      } else {
#line 6502
        if ((int )nptr2->pinloc > 0) {
#line 6503
          pinup = 1;
        } else {
#line 6505
          pindown = 1;
        }
      }
      __Cont___0: /* CIL Label */ 
#line 6476
      nptr2 = nptr2->nterm;
    }
    __Cont: /* CIL Label */ 
#line 6447
    nptr = nptr->nterm;
  }
#line 6510
  if (pinup == 1) {
#line 6510
    if (pindown == 0) {
#line 6511
      return (1);
    } else {
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
#line 6512
    if (pinup == 0) {
#line 6512
      if (pindown == 1) {
#line 6513
        return (2);
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 6514
      if (pinup == 1) {
#line 6514
        if (pindown == 1) {
#line 6515
          return (3);
        } else {
#line 6517
          return (0);
        }
      } else {
#line 6517
        return (0);
      }
    }
  }
}
}
#line 6643
int reset_ntrack(void) ;
#line 6649
int debug(int chan , CHANGRDPTR gdptr ) ;
#line 6522 "D:/a/test/300.c"
int findrchk(void) 
{ SEGBOXPTR segptr ;
  CHANGRDPTR ptr1 ;
  CHANGRDPTR ptr2 ;
  CHANGRDPTR bptr ;
  CHANGRDPTR fptr ;
  CHANGRDPTR sptr ;
  CHANGRDPTR eptr ;
  CHANGRDPTR ptr ;
  CHANGRDPTR gdptr ;
  int chan ;
  int segment ;
  int pin1 ;
  int pin2 ;
  int x1 ;
  int x2 ;
  int net ;
  int Flag ;

  {
#line 6529
  chan = 1;
#line 6529
  while (chan <= numChans) {
#line 6530
    gdptr = *(Begin + chan);
#line 6530
    while ((unsigned int )gdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 6532
      gdptr->ntracks = (short)0;
#line 6533
      gdptr->nSegType = (short)0;
#line 6530
      gdptr = gdptr->nnextgrd;
    }
#line 6529
    chan ++;
  }
#line 6536
  segment = 1;
#line 6536
  while (segment <= numSegs) {
#line 6537
    if ((int )(aNetSeg + segment)->key != 0) {
#line 6538
      (aNetSeg + segment)->current = (aNetSeg + (aNetSeg + segment)->key)->current;
    }
#line 6541
    if ((int )(aNetSeg + segment)->current == 0) {
#line 6542
      segptr = (aNetSeg + segment)->top;
    } else {
#line 6544
      segptr = (aNetSeg + segment)->bot;
    }
#line 6546
    pin1 = segptr->pin1;
#line 6547
    pin2 = segptr->pin2;
#line 6548
    if (pin1 > maxterm) {
#line 6548
      if (pin2 > maxterm) {
        goto __Cont;
      }
    }
#line 6551
    ptr1 = segptr->pin1ptr;
#line 6552
    ptr2 = segptr->pin2ptr;
#line 6553
    x1 = (ptr1->netptr)->xpos;
#line 6554
    x2 = (ptr2->netptr)->xpos;
#line 6555
    if (x1 == x2) {
      goto __Cont;
    }
#line 6558
    net = (aNetSeg + segment)->net;
#line 6559
    if ((int )ptr1->nSegType >= 0) {
#line 6560
      Flag = 0;
#line 6561
      bptr = ptr1;
#line 6562
      while (1) {
#line 6562
        if ((unsigned int )bptr->nprevgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 6562
          if (! (((bptr->nprevgrd)->netptr)->xpos == x1)) {
#line 6562
            break;
          }
        } else {
#line 6562
          break;
        }
#line 6564
        if (net == (int )(*(tearray + ((bptr->nprevgrd)->netptr)->terminal))->net) {
#line 6564
          if ((int )(bptr->nprevgrd)->nSegType < 0) {
#line 6566
            Flag = 1;
#line 6567
            sptr = ptr1->nnextgrd;
#line 6568
            while ((sptr->netptr)->xpos == x1) {
#line 6569
              sptr = sptr->nnextgrd;
            }
#line 6571
            break;
          } else {
#line 6573
            bptr = bptr->nprevgrd;
          }
        } else {
#line 6573
          bptr = bptr->nprevgrd;
        }
      }
#line 6576
      if (! Flag) {
#line 6577
        sptr = ptr1->nnextgrd;
#line 6578
        while ((sptr->netptr)->xpos == x1) {
#line 6579
          if (net == (int )(*(tearray + (sptr->netptr)->terminal))->net) {
#line 6579
            if ((int )sptr->nSegType < 0) {
#line 6581
              Flag = 1;
            }
          }
#line 6583
          sptr = sptr->nnextgrd;
        }
      }
#line 6586
      if (! Flag) {
#line 6587
        sptr = bptr;
      }
    } else {
#line 6590
      sptr = ptr1->nnextgrd;
#line 6591
      while ((sptr->netptr)->xpos == x1) {
#line 6592
        sptr = sptr->nnextgrd;
      }
    }
#line 6595
    if ((int )ptr2->nSegType <= 0) {
#line 6596
      Flag = 0;
#line 6597
      fptr = ptr2;
#line 6598
      while (1) {
#line 6598
        if ((unsigned int )fptr->nnextgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 6598
          if (! (((fptr->nnextgrd)->netptr)->xpos == x2)) {
#line 6598
            break;
          }
        } else {
#line 6598
          break;
        }
#line 6600
        if (net == (int )(*(tearray + ((fptr->nnextgrd)->netptr)->terminal))->net) {
#line 6600
          if ((int )(fptr->nnextgrd)->nSegType > 0) {
#line 6602
            Flag = 1;
#line 6603
            eptr = ptr2->nprevgrd;
#line 6604
            while ((eptr->netptr)->xpos == x2) {
#line 6605
              eptr = eptr->nprevgrd;
            }
#line 6607
            break;
          } else {
#line 6609
            fptr = fptr->nnextgrd;
          }
        } else {
#line 6609
          fptr = fptr->nnextgrd;
        }
      }
#line 6612
      if (! Flag) {
#line 6613
        eptr = ptr2->nprevgrd;
#line 6614
        while ((eptr->netptr)->xpos == x2) {
#line 6615
          if (net == (int )(*(tearray + (eptr->netptr)->terminal))->net) {
#line 6615
            if ((int )eptr->nSegType > 0) {
#line 6617
              Flag = 1;
            }
          }
#line 6619
          eptr = eptr->nprevgrd;
        }
      }
#line 6622
      if (! Flag) {
#line 6623
        eptr = fptr;
      }
    } else {
#line 6626
      eptr = ptr2->nprevgrd;
#line 6627
      while ((eptr->netptr)->xpos == x2) {
#line 6628
        eptr = eptr->nprevgrd;
      }
    }
#line 6631
    eptr = eptr->nnextgrd;
#line 6632
    ptr = sptr;
#line 6632
    while ((unsigned int )ptr != (unsigned int )eptr) {
#line 6633
      ptr->ntracks = (short )((int )ptr->ntracks + 1);
#line 6632
      ptr = ptr->nnextgrd;
    }
#line 6635
    if (pin1 <= maxterm) {
#line 6636
      ptr1->nSegType = (short )((int )ptr1->nSegType + 1);
    }
#line 6638
    if (pin2 <= maxterm) {
#line 6639
      ptr2->nSegType = (short )((int )ptr2->nSegType + -1);
    }
    __Cont: /* CIL Label */ 
#line 6536
    segment ++;
  }
#line 6642
  if (uneven_cell_height) {
#line 6643
    reset_ntrack();
  }
#line 6645
  chan = 1;
#line 6645
  while (chan <= numChans) {
#line 6646
    gdptr = *(Begin + chan);
#line 6646
    while ((unsigned int )gdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 6648
      if ((int )gdptr->tracks != (int )gdptr->ntracks) {
#line 6649
        debug(chan, gdptr);
#line 6650
        return 0;
      }
#line 6646
      gdptr = gdptr->nnextgrd;
    }
#line 6645
    chan ++;
  }
#line 6654
  return (0);
}
}
#line 6655 "D:/a/test/300.c"
int debug(int chan , CHANGRDPTR gdptr ) 
{ FILE *fpb ;
  char filename[64] ;
  NBOXPTR netptr ;
  int i ;
  int tmp ;

  {
#line 6663
  sprintf(filename, "%s.debug", cktName);
#line 6664
  tmp = (int )openFile(filename, "w", 1);
#line 6664
  fpb = (FILE *)tmp;
#line 6665
  fprintf(fpb, " channel = %2d nmaxTrack = %2d maxTrack = %2d\n", chan, *(nmaxTrack + chan),
          *(maxTrack + chan));
#line 6667
  fprintf(fpb, "SegType nSegType track ntrack  pin xpos newx cell  net\n");
#line 6668
  i = 5;
#line 6668
  while (i >= 0) {
#line 6669
    if ((unsigned int )gdptr->prevgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 6670
      gdptr = gdptr->prevgrd;
    }
#line 6668
    i --;
  }
#line 6673
  while (i <= 12) {
#line 6674
    if ((unsigned int )gdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 6675
      netptr = gdptr->netptr;
#line 6676
      fprintf(fpb, "%7d %8d %5d %6d %4d %4d %4d %4d %4d\n", gdptr->SegType, gdptr->nSegType,
              gdptr->tracks, gdptr->ntracks, netptr->terminal, netptr->xpos, netptr->newx,
              netptr->cell, (*(tearray + netptr->terminal))->net);
#line 6680
      gdptr = gdptr->nextgrd;
    }
#line 6673
    i ++;
  }
#line 6683
  return (0);
}
}
#line 6701
int facing_cellheight(int pin , int row___0 , int pinloc , int status ) ;
#line 6684 "D:/a/test/300.c"
int reset_ntrack(void) 
{ CBOXPTR cellptr___0 ;
  TIBOXPTR tileptr ;
  TEBOXPTR termptr ;
  int cell___0 ;
  int pin ;
  int pinloc ;
  int row___0 ;
  int top___0 ;
  int bottom ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 6690
  cell___0 = 1;
#line 6690
  while (cell___0 <= numcells) {
#line 6691
    cellptr___0 = *(carray + cell___0);
#line 6692
    tileptr = cellptr___0->tileptr;
#line 6693
    top___0 = (int )tileptr->top;
#line 6694
    bottom = - ((int )tileptr->bottom);
#line 6695
    row___0 = (int )cellptr___0->cblock;
#line 6696
    termptr = tileptr->termsptr;
#line 6696
    while ((unsigned int )termptr != (unsigned int )((void *)0)) {
#line 6698
      pin = termptr->cellterm;
#line 6699
      pinloc = (int )(*(tearray + pin))->pinloc;
#line 6700
      if (pinloc == 1) {
#line 6701
        tmp = facing_cellheight(pin, row___0, 1, 1);
#line 6701
        ((*(Tgrid + pin))->up)->ntracks = (short )((int )((*(Tgrid + pin))->up)->ntracks + (top___0 + tmp) / track_spacing);
      } else {
#line 6703
        if (pinloc == -1) {
#line 6704
          tmp___0 = facing_cellheight(pin, row___0, -1, 1);
#line 6704
          ((*(Tgrid + pin))->up)->ntracks = (short )((int )((*(Tgrid + pin))->up)->ntracks + (bottom + tmp___0) / track_spacing);
        } else {
#line 6707
          tmp___1 = facing_cellheight(pin, row___0, 1, 1);
#line 6707
          ((*(Tgrid + pin))->up)->ntracks = (short )((int )((*(Tgrid + pin))->up)->ntracks + (top___0 + tmp___1) / track_spacing);
#line 6709
          tmp___2 = facing_cellheight(pin, row___0, -1, 1);
#line 6709
          ((*(Tgrid + pin))->down)->ntracks = (short )((int )((*(Tgrid + pin))->down)->ntracks + (bottom + tmp___2) / track_spacing);
        }
      }
#line 6696
      termptr = termptr->nextterm;
    }
#line 6690
    cell___0 ++;
  }
#line 6714
  while (cell___0 <= numcells + numterms) {
#line 6715
    cellptr___0 = *(carray + cell___0);
#line 6716
    tileptr = cellptr___0->tileptr;
#line 6717
    termptr = tileptr->termsptr;
#line 6717
    while ((unsigned int )termptr != (unsigned int )((void *)0)) {
#line 6719
      pin = termptr->cellterm;
#line 6720
      row___0 = (int )(*(tearray + pin))->row;
#line 6721
      tmp___3 = facing_cellheight(pin, row___0, 0, 1);
#line 6721
      ((*(Tgrid + pin))->up)->ntracks = (short )((int )((*(Tgrid + pin))->up)->ntracks + tmp___3 / track_spacing);
#line 6717
      termptr = termptr->nextterm;
    }
#line 6714
    cell___0 ++;
  }
#line 6725
  return (0);
}
}
#line 6845
int set_cedgebin(void) ;
#line 6846
int reset_track(void) ;
#line 6728 "D:/a/test/300.c"
int findrcost(void) 
{ SEGBOXPTR segptr ;
  CHANGRDPTR ptr1 ;
  CHANGRDPTR ptr2 ;
  CHANGRDPTR bptr ;
  CHANGRDPTR fptr ;
  CHANGRDPTR sptr ;
  CHANGRDPTR eptr ;
  CHANGRDPTR ptr ;
  CHANGRDPTR gdptr ;
  DENSITYPTR denptr ;
  int chan ;
  int segment ;
  int track ;
  int max_trk ;
  int pin1 ;
  int pin2 ;
  int x1 ;
  int x2 ;
  int net ;
  int Flag ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  DENSITYPTR tmp___6 ;
  int tmp___7 ;
  struct densitybox *tmp___8 ;
  int tmp___9 ;

  {
#line 6737
  segment = 1;
#line 6737
  while (segment <= numSegs) {
#line 6738
    if ((int )(aNetSeg + segment)->current == 0) {
#line 6739
      segptr = (aNetSeg + segment)->top;
    } else {
#line 6741
      segptr = (aNetSeg + segment)->bot;
    }
#line 6743
    pin1 = segptr->pin1;
#line 6744
    pin2 = segptr->pin2;
#line 6745
    ptr1 = segptr->pin1ptr;
#line 6746
    ptr2 = segptr->pin2ptr;
#line 6747
    x1 = (ptr1->netptr)->xpos;
#line 6748
    x2 = (ptr2->netptr)->xpos;
#line 6749
    if (x1 == x2) {
      goto __Cont;
    }
#line 6752
    net = (aNetSeg + segment)->net;
#line 6753
    if ((int )ptr1->SegType >= 0) {
#line 6754
      Flag = 0;
#line 6755
      bptr = ptr1;
#line 6756
      while (1) {
#line 6756
        if ((unsigned int )bptr->prevgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 6756
          if (! (((bptr->prevgrd)->netptr)->xpos == x1)) {
#line 6756
            break;
          }
        } else {
#line 6756
          break;
        }
#line 6758
        if (net == (int )(*(tearray + ((bptr->prevgrd)->netptr)->terminal))->net) {
#line 6758
          if ((int )(bptr->prevgrd)->SegType < 0) {
#line 6760
            Flag = 1;
#line 6761
            sptr = ptr1->nextgrd;
#line 6762
            while ((sptr->netptr)->xpos == x1) {
#line 6763
              sptr = sptr->nextgrd;
            }
#line 6765
            break;
          } else {
#line 6767
            bptr = bptr->prevgrd;
          }
        } else {
#line 6767
          bptr = bptr->prevgrd;
        }
      }
#line 6770
      if (! Flag) {
#line 6771
        sptr = ptr1->nextgrd;
#line 6772
        while ((sptr->netptr)->xpos == x1) {
#line 6773
          if (net == (int )(*(tearray + (sptr->netptr)->terminal))->net) {
#line 6773
            if ((int )sptr->SegType < 0) {
#line 6775
              Flag = 1;
            }
          }
#line 6777
          sptr = sptr->nextgrd;
        }
      }
#line 6780
      if (! Flag) {
#line 6781
        sptr = bptr;
      }
    } else {
#line 6784
      sptr = ptr1->nextgrd;
#line 6785
      while ((sptr->netptr)->xpos == x1) {
#line 6786
        sptr = sptr->nextgrd;
      }
    }
#line 6789
    if ((int )ptr2->SegType <= 0) {
#line 6790
      Flag = 0;
#line 6791
      fptr = ptr2;
#line 6792
      while (1) {
#line 6792
        if ((unsigned int )fptr->nextgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 6792
          if (! (((fptr->nextgrd)->netptr)->xpos == x2)) {
#line 6792
            break;
          }
        } else {
#line 6792
          break;
        }
#line 6794
        if (net == (int )(*(tearray + ((fptr->nextgrd)->netptr)->terminal))->net) {
#line 6794
          if ((int )(fptr->nextgrd)->SegType > 0) {
#line 6796
            Flag = 1;
#line 6797
            eptr = ptr2->prevgrd;
#line 6798
            while ((eptr->netptr)->xpos == x2) {
#line 6799
              eptr = eptr->prevgrd;
            }
#line 6801
            break;
          } else {
#line 6803
            fptr = fptr->nextgrd;
          }
        } else {
#line 6803
          fptr = fptr->nextgrd;
        }
      }
#line 6806
      if (! Flag) {
#line 6807
        eptr = ptr2->prevgrd;
#line 6808
        while ((eptr->netptr)->xpos == x2) {
#line 6809
          if (net == (int )(*(tearray + (eptr->netptr)->terminal))->net) {
#line 6809
            if ((int )eptr->SegType > 0) {
#line 6811
              Flag = 1;
            }
          }
#line 6813
          eptr = eptr->prevgrd;
        }
      }
#line 6816
      if (! Flag) {
#line 6817
        eptr = fptr;
      }
    } else {
#line 6820
      eptr = ptr2->prevgrd;
#line 6821
      while ((eptr->netptr)->xpos == x2) {
#line 6822
        eptr = eptr->prevgrd;
      }
    }
#line 6825
    eptr = eptr->nextgrd;
#line 6826
    ptr = sptr;
#line 6826
    while ((unsigned int )ptr != (unsigned int )eptr) {
#line 6827
      ptr->tracks = (short )((int )ptr->tracks + 1);
#line 6826
      ptr = ptr->nextgrd;
    }
#line 6829
    if (pin1 <= maxterm) {
#line 6830
      ptr1->SegType = (short )((int )ptr1->SegType + 1);
    }
#line 6832
    if (pin2 <= maxterm) {
#line 6833
      ptr2->SegType = (short )((int )ptr2->SegType + -1);
    }
    __Cont: /* CIL Label */ 
#line 6737
    segment ++;
  }
#line 6836
  tmp = (int )safe_calloc(sizeof(DENSITYPTR *), numChans + 1);
#line 6836
  DboxHead = (DENSITYPTR **)tmp;
#line 6838
  tmp___0 = (int )safe_calloc(sizeof(DENSITYPTR *), numChans + 1);
#line 6838
  Densebox = (DENSITYPTR **)tmp___0;
#line 6840
  tmp___1 = (int )safe_malloc((unsigned int )(numChans + 1) * sizeof(int ));
#line 6840
  maxTrack = (int *)tmp___1;
#line 6841
  tmp___2 = (int )safe_malloc((unsigned int )(numChans + 1) * sizeof(int ));
#line 6841
  nmaxTrack = (int *)tmp___2;
#line 6842
  max_tdensity = 0;
#line 6843
  tracks = 0;
#line 6844
  if (uneven_cell_height) {
#line 6845
    set_cedgebin();
#line 6846
    reset_track();
  }
#line 6848
  chan = 1;
#line 6848
  while (chan <= numChans) {
#line 6849
    max_trk = 0;
#line 6850
    gdptr = *(Begin + chan);
#line 6850
    while ((unsigned int )gdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 6852
      if ((int )gdptr->tracks > max_trk) {
#line 6853
        max_trk = (int )gdptr->tracks;
      }
#line 6850
      gdptr = gdptr->nextgrd;
    }
#line 6856
    *(maxTrack + chan) = max_trk;
#line 6857
    if (max_trk > max_tdensity) {
#line 6858
      max_tdensity = max_trk;
    }
#line 6860
    tracks += max_trk;
#line 6848
    chan ++;
  }
#line 6862
  chan = 1;
#line 6862
  while (chan <= numChans) {
#line 6863
    tmp___3 = (int )safe_calloc(sizeof(DENSITYPTR ), max_tdensity + 101);
#line 6863
    *(DboxHead + chan) = (DENSITYPTR *)tmp___3;
#line 6865
    tmp___4 = (int )safe_calloc(sizeof(DENSITYPTR ), max_tdensity + 101);
#line 6865
    *(Densebox + chan) = (DENSITYPTR *)tmp___4;
#line 6867
    track = 0;
#line 6867
    while (track <= max_tdensity + 100) {
#line 6868
      tmp___5 = (int )safe_calloc(sizeof(DENSITYBOX ), 1);
#line 6868
      *(*(DboxHead + chan) + track) = (struct densitybox *)tmp___5;
#line 6867
      track ++;
    }
#line 6871
    gdptr = *(Begin + chan);
#line 6871
    while ((unsigned int )gdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 6873
      track = (int )gdptr->tracks;
#line 6874
      if ((unsigned int )(*(*(DboxHead + chan) + track))->next == (unsigned int )((void *)0)) {
#line 6875
        tmp___7 = (int )safe_calloc(sizeof(DENSITYBOX ), 1);
#line 6875
        tmp___6 = (struct densitybox *)tmp___7;
#line 6875
        *(*(Densebox + chan) + track) = tmp___6;
#line 6875
        (*(*(DboxHead + chan) + track))->next = tmp___6;
#line 6877
        (*(*(Densebox + chan) + track))->back = *(*(DboxHead + chan) + track);
#line 6878
        (*(*(Densebox + chan) + track))->grdptr = gdptr;
#line 6879
        gdptr->dptr = *(*(Densebox + chan) + track);
      } else {
#line 6881
        tmp___9 = (int )safe_calloc(sizeof(DENSITYBOX ), 1);
#line 6881
        tmp___8 = (struct densitybox *)tmp___9;
#line 6881
        (*(*(Densebox + chan) + track))->next = tmp___8;
#line 6881
        denptr = tmp___8;
#line 6883
        denptr->back = *(*(Densebox + chan) + track);
#line 6884
        denptr->grdptr = gdptr;
#line 6885
        gdptr->dptr = denptr;
#line 6886
        *(*(Densebox + chan) + track) = denptr;
      }
#line 6871
      gdptr = gdptr->nextgrd;
    }
#line 6862
    chan ++;
  }
#line 6890
  return (0);
}
}
#line 6891 "D:/a/test/300.c"
int set_cedgebin(void) 
{ CBOXPTR cellptr___0 ;
  int channel ;
  int row___0 ;
  int bin ;
  int bin_rite_edge ;
  int crite ;
  int most_left ;
  int most_rite ;
  int rite___0 ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 6896
  tmp = (int )safe_malloc((unsigned int )(numChans + 1) * sizeof(int *));
#line 6896
  cedgebin = (int **)tmp;
#line 6897
  cedge_binwidth = (int )(2.0 * mean_width);
#line 6898
  cellptr___0 = *(carray + *(*(pairArray + 1) + *(*(pairArray + 1) + 0)));
#line 6899
  most_rite = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
#line 6900
  row___0 = 2;
#line 6900
  while (row___0 <= numRows) {
#line 6901
    cellptr___0 = *(carray + *(*(pairArray + row___0) + *(*(pairArray + row___0) + 0)));
#line 6902
    rite___0 = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
#line 6903
    if (rite___0 > most_rite) {
#line 6904
      most_rite = rite___0;
    }
#line 6900
    row___0 ++;
  }
#line 6907
  num_edgebin = (most_rite - blkleft) / cedge_binwidth + 1;
#line 6908
  channel = 1;
#line 6908
  while (channel <= numChans) {
#line 6909
    tmp___0 = (int )safe_malloc((unsigned int )(num_edgebin + 1) * sizeof(int ));
#line 6909
    *(cedgebin + channel) = (int *)tmp___0;
#line 6908
    channel ++;
  }
#line 6912
  row___0 = 1;
#line 6912
  while (row___0 <= numRows) {
#line 6913
    cellptr___0 = *(carray + *(*(pairArray + row___0) + 1));
#line 6914
    most_left = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->left;
#line 6915
    bin_rite_edge = most_left + cedge_binwidth;
#line 6916
    *(*(cedgebin + row___0) + 1) = 1;
#line 6917
    bin = 1;
#line 6918
    i = 1;
#line 6918
    while (i <= *(*(pairArray + row___0) + 0)) {
#line 6919
      cellptr___0 = *(carray + *(*(pairArray + row___0) + i));
#line 6920
      crite = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
#line 6921
      if (bin_rite_edge < crite) {
#line 6922
        while (bin_rite_edge <= crite) {
#line 6923
          bin ++;
#line 6923
          *(*(cedgebin + row___0) + bin) = i;
#line 6924
          bin_rite_edge += cedge_binwidth;
        }
      }
#line 6918
      i ++;
    }
#line 6928
    bin ++;
#line 6928
    while (bin <= num_edgebin) {
#line 6929
      *(*(cedgebin + row___0) + bin) = 0;
#line 6928
      bin ++;
    }
#line 6912
    row___0 ++;
  }
#line 6932
  return (0);
}
}
#line 6933 "D:/a/test/300.c"
int reset_track(void) 
{ CBOXPTR cellptr___0 ;
  TIBOXPTR tileptr ;
  TEBOXPTR termptr ;
  int cell___0 ;
  int pin ;
  int pinloc ;
  int row___0 ;
  int top___0 ;
  int bottom ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 6939
  cell___0 = 1;
#line 6939
  while (cell___0 <= numcells) {
#line 6940
    cellptr___0 = *(carray + cell___0);
#line 6941
    tileptr = cellptr___0->tileptr;
#line 6942
    row___0 = (int )cellptr___0->cblock;
#line 6943
    top___0 = (int )tileptr->top;
#line 6944
    bottom = - ((int )tileptr->bottom);
#line 6945
    termptr = tileptr->termsptr;
#line 6945
    while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 6947
      pin = termptr->cellterm;
#line 6948
      pinloc = (int )(*(tearray + pin))->pinloc;
#line 6949
      if (pinloc == 1) {
#line 6950
        tmp = facing_cellheight(pin, row___0, 1, 1);
#line 6950
        ((*(Tgrid + pin))->up)->tracks = (short )((int )((*(Tgrid + pin))->up)->tracks + (top___0 + tmp) / track_spacing);
      } else {
#line 6952
        if (pinloc == -1) {
#line 6953
          tmp___0 = facing_cellheight(pin, row___0, -1, 1);
#line 6953
          ((*(Tgrid + pin))->up)->tracks = (short )((int )((*(Tgrid + pin))->up)->tracks + (bottom + tmp___0) / track_spacing);
        } else {
#line 6956
          tmp___1 = facing_cellheight(pin, row___0, 1, 1);
#line 6956
          ((*(Tgrid + pin))->up)->tracks = (short )((int )((*(Tgrid + pin))->up)->tracks + (top___0 + tmp___1) / track_spacing);
#line 6958
          tmp___2 = facing_cellheight(pin, row___0, -1, 1);
#line 6958
          ((*(Tgrid + pin))->down)->tracks = (short )((int )((*(Tgrid + pin))->down)->tracks + (bottom + tmp___2) / track_spacing);
        }
      }
#line 6945
      termptr = termptr->nextterm;
    }
#line 6939
    cell___0 ++;
  }
#line 6963
  while (cell___0 <= numcells + numterms) {
#line 6964
    cellptr___0 = *(carray + cell___0);
#line 6965
    tileptr = cellptr___0->tileptr;
#line 6966
    termptr = tileptr->termsptr;
#line 6966
    while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 6968
      pin = termptr->cellterm;
#line 6969
      row___0 = (int )(*(tearray + pin))->row;
#line 6970
      tmp___3 = facing_cellheight(pin, row___0, 0, 1);
#line 6970
      ((*(Tgrid + pin))->up)->tracks = (short )((int )((*(Tgrid + pin))->up)->tracks + tmp___3 / track_spacing);
#line 6966
      termptr = termptr->nextterm;
    }
#line 6963
    cell___0 ++;
  }
#line 6974
  return (0);
}
}
#line 6975 "D:/a/test/300.c"
int facing_cellheight(int pin , int row___0 , int pinloc , int status ) 
{ CBOXPTR cellptr___0 ;
  int bin ;
  int i ;
  int *Aray ;
  int most_left ;
  int most_rite ;
  int nrow ;
  int pin_x ;
  int crite ;

  {
#line 6981
  if (1 <= row___0) {
#line 6981
    if (row___0 <= numRows) {
#line 6982
      nrow = row___0 + pinloc;
#line 6983
      if (nrow == 0) {
#line 6984
        return (0);
      } else {
#line 6983
        if (nrow == numChans) {
#line 6984
          return (0);
        } else {
#line 6983
          if (pinloc == 0) {
#line 6984
            return (0);
          }
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 6986
    if (row___0 == 0) {
#line 6987
      nrow = 1;
    } else {
#line 6989
      nrow = numRows;
    }
  }
#line 6991
  Aray = *(pairArray + nrow);
#line 6992
  if (status == 0) {
#line 6993
    pin_x = (*(tearray + pin))->newx;
  } else {
#line 6995
    pin_x = (*(tearray + pin))->xpos;
  }
#line 6997
  cellptr___0 = *(carray + *(Aray + 1));
#line 6998
  most_left = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->left;
#line 6999
  cellptr___0 = *(carray + *(Aray + *(Aray + 0)));
#line 7000
  most_rite = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
#line 7001
  if (pin_x < most_left) {
#line 7002
    return (0);
  } else {
#line 7001
    if (pin_x > most_rite) {
#line 7002
      return (0);
    }
  }
#line 7004
  bin = (pin_x - most_left) / cedge_binwidth + 1;
#line 7005
  i = *(*(cedgebin + nrow) + bin);
#line 7005
  if (i == 0) {
#line 7006
    return (0);
  }
#line 7008
  cellptr___0 = *(carray + *(Aray + i));
#line 7009
  if ((int )(cellptr___0->tileptr)->left + cellptr___0->cxcenter == pin_x) {
#line 7009
    if (bin >= 2) {
#line 7011
      if ((int )(*(carray + *(Aray + (i - 1))))->cheight > (int )cellptr___0->cheight) {
#line 7012
        i --;
#line 7012
        cellptr___0 = *(carray + *(Aray + i));
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 7015
    crite = (int )(cellptr___0->tileptr)->right + cellptr___0->cxcenter;
#line 7016
    while (1) {
#line 7016
      if (crite < pin_x) {
#line 7016
        if (! (i < *(Aray + 0))) {
#line 7016
          break;
        }
      } else {
#line 7016
        break;
      }
#line 7017
      i ++;
#line 7017
      cellptr___0 = *(carray + *(Aray + i));
#line 7018
      crite += (int )cellptr___0->clength;
    }
#line 7020
    if (crite == pin_x) {
#line 7020
      if (i != *(Aray + 0)) {
#line 7021
        if ((int )(*(carray + *(Aray + (i + 1))))->cheight > (int )cellptr___0->cheight) {
#line 7022
          cellptr___0 = *(carray + *(Aray + (i + 1)));
        }
      }
    }
  }
#line 7026
  if (1 <= row___0) {
#line 7026
    if (row___0 <= numRows) {
#line 7027
      if (pinloc == 1) {
#line 7028
        return (- ((int )(cellptr___0->tileptr)->bottom));
      } else {
#line 7030
        return ((int )(cellptr___0->tileptr)->top);
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 7032
    if (row___0 == 0) {
#line 7033
      return (- ((int )(cellptr___0->tileptr)->bottom));
    } else {
#line 7035
      return ((int )(cellptr___0->tileptr)->top);
    }
  }
}
}
#line 7059
int unlap(int flag ) ;
#line 7041 "D:/a/test/300.c"
int findunlap(int before_feeds ) 
{ CBOXPTR cellptr___0 ;
  CBOXPTR ptr ;
  TIBOXPTR tileptr ;
  TEBOXPTR term ;
  DBOXPTR dimptr ;
  NBOXPTR termptr ;
  NBOXPTR netptr ;
  int cost ;
  int corient ;
  int block___0 ;
  int cell___0 ;
  int bin ;
  int i ;
  int n ;
  int bigblkx ;
  int net ;
  int x ;
  int y ;
  int *blklen ;
  int row___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  short tmp___2 ;
  short tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 7054
  tmp = (int )safe_malloc((unsigned int )(numblock + 1) * sizeof(int ));
#line 7054
  blklen = (int *)tmp;
#line 7055
  i = 0;
#line 7055
  while (i <= numblock) {
#line 7056
    *(blklen + i) = 0;
#line 7055
    i ++;
  }
#line 7058
  if (before_feeds == 1) {
#line 7059
    unlap(1);
  } else {
#line 7060
    if (before_feeds == 0) {
#line 7061
      unlap(0);
    }
  }
#line 7063
  if (before_feeds == 1) {
#line 7064
    block___0 = 1;
#line 7064
    while (block___0 <= numblock) {
#line 7065
      bin = 0;
#line 7065
      while (bin <= numBins) {
#line 7066
        safe_free((*(*(binptr + block___0) + bin))->cell);
#line 7067
        safe_free(*(*(binptr + block___0) + bin));
#line 7065
        bin ++;
      }
#line 7069
      safe_free(*(binptr + block___0));
#line 7064
      block___0 ++;
    }
#line 7071
    safe_free(binptr);
  }
#line 7073
  cell___0 = 1;
#line 7073
  while (cell___0 <= numcells) {
#line 7074
    ptr = *(carray + cell___0);
#line 7075
    corient = (int )ptr->corient;
#line 7076
    term = (ptr->tileptr)->termsptr;
#line 7076
    while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 7078
      termptr = *(tearray + term->cellterm);
#line 7079
      termptr->xpos = (int )term->txpos[corient / 2] + ptr->cxcenter;
#line 7080
      termptr->ypos = (int )term->typos[corient % 2] + ptr->cycenter;
#line 7076
      term = term->nextterm;
    }
#line 7073
    cell___0 ++;
  }
#line 7083
  cell___0 = numcells + 1;
#line 7083
  while (cell___0 <= numcells + numterms) {
#line 7084
    ptr = *(carray + cell___0);
#line 7085
    term = (ptr->tileptr)->termsptr;
#line 7085
    while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 7087
      termptr = *(tearray + term->cellterm);
#line 7088
      termptr->xpos = (int )term->txpos[1] + ptr->cxcenter;
#line 7089
      termptr->ypos = (int )term->typos[1] + ptr->cycenter;
#line 7085
      term = term->nextterm;
    }
#line 7083
    cell___0 ++;
  }
#line 7092
  cost = 0;
#line 7093
  net = 1;
#line 7093
  while (net <= numnets) {
#line 7094
    dimptr = *(netarray + net);
#line 7095
    netptr = dimptr->netptr;
#line 7095
    if ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 7096
      tmp___0 = netptr->xpos;
#line 7096
      dimptr->xmax = tmp___0;
#line 7096
      dimptr->xmin = tmp___0;
#line 7097
      tmp___1 = netptr->ypos;
#line 7097
      dimptr->ymax = tmp___1;
#line 7097
      dimptr->ymin = tmp___1;
#line 7098
      tmp___2 = (short)1;
#line 7098
      dimptr->Rnum = tmp___2;
#line 7098
      dimptr->Lnum = tmp___2;
#line 7099
      tmp___3 = (short)1;
#line 7099
      dimptr->Tnum = tmp___3;
#line 7099
      dimptr->Bnum = tmp___3;
#line 7100
      netptr = netptr->nterm;
    }
#line 7102
    n = 1;
#line 7103
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 7104
      x = netptr->xpos;
#line 7105
      y = netptr->ypos;
#line 7106
      if (x < dimptr->xmin) {
#line 7107
        dimptr->xmin = x;
#line 7108
        dimptr->Lnum = (short)1;
      } else {
#line 7109
        if (x == dimptr->xmin) {
#line 7110
          dimptr->Lnum = (short )((int )dimptr->Lnum + 1);
#line 7111
          if (x == dimptr->xmax) {
#line 7112
            dimptr->Rnum = (short )((int )dimptr->Rnum + 1);
          }
        } else {
#line 7114
          if (x > dimptr->xmax) {
#line 7115
            dimptr->xmax = x;
#line 7116
            dimptr->Rnum = (short)1;
          } else {
#line 7117
            if (x == dimptr->xmax) {
#line 7118
              dimptr->Rnum = (short )((int )dimptr->Rnum + 1);
            }
          }
        }
      }
#line 7120
      if (y < dimptr->ymin) {
#line 7121
        dimptr->ymin = y;
#line 7122
        dimptr->Bnum = (short)1;
      } else {
#line 7123
        if (y == dimptr->ymin) {
#line 7124
          dimptr->Bnum = (short )((int )dimptr->Bnum + 1);
#line 7125
          if (y == dimptr->ymax) {
#line 7126
            dimptr->Tnum = (short )((int )dimptr->Tnum + 1);
          }
        } else {
#line 7128
          if (y > dimptr->ymax) {
#line 7129
            dimptr->ymax = y;
#line 7130
            dimptr->Tnum = (short)1;
          } else {
#line 7131
            if (y == dimptr->ymax) {
#line 7132
              dimptr->Tnum = (short )((int )dimptr->Tnum + 1);
            }
          }
        }
      }
#line 7134
      n ++;
#line 7103
      netptr = netptr->nterm;
    }
#line 7136
    dimptr->numpins = (short )n;
#line 7137
    cost += (int )(dimptr->Hweight * (double )(dimptr->xmax - dimptr->xmin)) + (int )(dimptr->Vweight * (double )(dimptr->ymax - dimptr->ymin));
#line 7093
    net ++;
  }
#line 7142
  funccost = cost;
#line 7143
  cell___0 = 1;
#line 7143
  while (cell___0 <= numcells) {
#line 7144
    cellptr___0 = *(carray + cell___0);
#line 7145
    tileptr = cellptr___0->tileptr;
#line 7146
    block___0 = (int )cellptr___0->cblock;
#line 7147
    *(blklen + block___0) += (int )tileptr->right - (int )tileptr->left;
#line 7143
    cell___0 ++;
  }
#line 7149
  if (before_feeds == 1) {
#line 7150
    tmp___4 = (int )safe_malloc((unsigned int )(numRows + 1) * sizeof(int ));
#line 7150
    length_of_row = (int *)tmp___4;
#line 7151
    tmp___5 = (int )safe_malloc((unsigned int )(numRows + 1) * sizeof(int ));
#line 7151
    add_to_row = (int *)tmp___5;
#line 7152
    row___0 = 1;
#line 7152
    while (row___0 <= numRows) {
#line 7153
      *(length_of_row + row___0) = *(blklen + row___0);
#line 7154
      *(add_to_row + row___0) = 0;
#line 7152
      row___0 ++;
    }
  }
#line 7157
  if (before_feeds >= 0) {
#line 7158
    bigblkx = 0;
#line 7159
    if (before_feeds == 1) {
#line 7160
      fprintf(fpo, "Before Feeds are Added:\n");
    }
#line 7162
    fprintf(fpo, "BLOCK      TOTAL CELL LENGTHS      OVER/UNDER TARGET\n");
#line 7163
    i = 1;
#line 7163
    while (i <= numblock) {
#line 7164
      if (*(blklen + i) > *(blklen + bigblkx)) {
#line 7165
        bigblkx = i;
      }
#line 7167
      fprintf(fpo, "%3d            %7d                %6d\n", i, *(blklen + i), *(blklen + i) - (int )(*(barray + i))->desire);
#line 7163
      i ++;
    }
#line 7170
    fprintf(fpo, "\nLONGEST Block is:%d   Its length is:%d\n", bigblkx, *(blklen + bigblkx));
  }
#line 7173
  safe_free(blklen);
#line 7174
  return 0;
}
}
#line 7370
int qsortg(char *base , int n , int size ) ;
#line 7373
int detGroup(int g ) ;
#line 7374
int searchG(int g , int type , int block___0 ) ;
#line 7433
int qsorte(char *base , int n , int size ) ;
#line 7506
int addEdge(int g1 , int g2 ) ;
#line 7178 "D:/a/test/300.c"
int globe(void) 
{ FILE *twfile ;
  NBOXPTR netptr ;
  NBOXPTR net_ptr ;
  CBOXPTR cellptr1 ;
  CBOXPTR cellptr2 ;
  char filename[64] ;
  int group1 ;
  int group2 ;
  int edge___0 ;
  int i ;
  int pin ;
  int net ;
  int group ;
  int jj ;
  int cell___0 ;
  int cx ;
  int cl ;
  int cr ;
  int top___0 ;
  int extint ;
  int block___0 ;
  int locX ;
  int locY ;
  int flag1 ;
  int flag2 ;
  int xstart ;
  int xstop ;
  int found ;
  int type1 ;
  int unequiv ;
  int added_an_edge ;
  int ue_grp ;
  int g1 ;
  int g2 ;
  int ei1 ;
  int ei2 ;
  int edge2 ;
  int done ;
  int ei ;
  int cell1 ;
  int cell2 ;
  int a1 ;
  int b1 ;
  int a2 ;
  int b2 ;
  int edge1 ;
  int ya ;
  int yb ;
  int max_group ;
  int max_size ;
  int size ;
  int max_local_group ;
  int single_pin1 ;
  int single_pin2 ;
  int unequiv1 ;
  int unequiv2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 7194
  max_group = 2;
#line 7195
  max_size = 2;
#line 7196
  net = 1;
#line 7196
  while (net <= numnets) {
#line 7197
    net_ptr = (*(netarray + net))->netptr;
#line 7198
    max_local_group = 0;
#line 7199
    size = 1;
#line 7200
    extint = -1;
#line 7201
    while ((unsigned int )net_ptr != (unsigned int )((void *)0)) {
#line 7202
      if (net_ptr->extint != extint) {
#line 7203
        extint = net_ptr->extint;
#line 7204
        max_local_group ++;
#line 7205
        if (size > max_size) {
#line 7206
          max_size = size;
        }
#line 7208
        size = 1;
      } else {
#line 7210
        size ++;
#line 7211
        if ((int )net_ptr->unequiv != 0) {
#line 7212
          max_local_group ++;
        }
      }
#line 7201
      net_ptr = net_ptr->nterm;
    }
#line 7216
    if (size > max_size) {
#line 7217
      max_size = size;
    }
#line 7219
    if (max_local_group > max_group) {
#line 7220
      max_group = max_local_group;
    }
#line 7196
    net ++;
  }
#line 7223
  max_group += 2 * (numRows + 2);
#line 7224
  MPG = max_group;
#line 7225
  ME = max_group * (max_group - 1);
#line 7226
  tmp = (int )safe_malloc(101U * sizeof(int ));
#line 7226
  key_queue = (int *)tmp;
#line 7227
  tmp___0 = (int )safe_malloc((unsigned int )(MPG + 1) * sizeof(csGroup ));
#line 7227
  groupArray = (csGroup *)tmp___0;
#line 7228
  tmp___1 = (int )safe_malloc((unsigned int )(MPG + 1) * sizeof(chkBox ));
#line 7228
  checkArray = (chkBox *)tmp___1;
#line 7229
  tmp___2 = (int )safe_malloc((unsigned int )(ME + 1) * sizeof(edgeBox ));
#line 7229
  edgeArray = (edgeBox *)tmp___2;
#line 7230
  i = 0;
#line 7230
  while (i <= MPG) {
#line 7231
    (groupArray + i)->numPins = (short)0;
#line 7232
    (groupArray + i)->flag = (short)0;
#line 7233
    (groupArray + i)->poison = (short)0;
#line 7234
    (groupArray + i)->unequiv = (short)0;
#line 7235
    (groupArray + i)->extint = 0;
#line 7236
    (groupArray + i)->edge1 = (short)0;
#line 7237
    (groupArray + i)->edge2 = (short)0;
#line 7238
    (groupArray + i)->check = (short)0;
#line 7239
    tmp___3 = (int )safe_malloc((unsigned int )(max_size + 1) * sizeof(csPinBox ));
#line 7239
    (groupArray + i)->pinArray = (csPinBox *)tmp___3;
#line 7230
    i ++;
  }
#line 7242
  i = 0;
#line 7242
  while (i <= ME) {
#line 7243
    (edgeArray + i)->marked = (short)0;
#line 7244
    (edgeArray + i)->done = (short)0;
#line 7245
    (edgeArray + i)->poison = (short)0;
#line 7242
    i ++;
  }
#line 7247
  tmp___4 = (int )safe_malloc((unsigned int )(numRows + 2) * sizeof(int *));
#line 7247
  pseudoPins = (int **)tmp___4;
#line 7248
  jj = 0;
#line 7248
  while (jj <= numRows + 1) {
#line 7249
    tmp___5 = (int )safe_malloc(2U * sizeof(int ));
#line 7249
    *(pseudoPins + jj) = (int *)tmp___5;
#line 7248
    jj ++;
  }
#line 7251
  tmp___6 = (int )safe_malloc((unsigned int )(numRows + 2) * sizeof(int *));
#line 7251
  pseudoEdge = (int **)tmp___6;
#line 7252
  jj = 0;
#line 7252
  while (jj <= numRows + 1) {
#line 7253
    tmp___7 = (int )safe_malloc(2U * sizeof(int ));
#line 7253
    *(pseudoEdge + jj) = (int *)tmp___7;
#line 7252
    jj ++;
  }
#line 7255
  numChans = numRows + 1;
#line 7256
  xstart = 32000;
#line 7257
  xstop = 0;
#line 7258
  cell___0 = 1;
#line 7258
  while (cell___0 <= numcells + numterms) {
#line 7259
    cx = (*(carray + cell___0))->cxcenter;
#line 7260
    cl = (int )((*(carray + cell___0))->tileptr)->left;
#line 7261
    cr = (int )((*(carray + cell___0))->tileptr)->right;
#line 7262
    if (cx + cr > xstop) {
#line 7263
      xstop = cx + cr;
    }
#line 7265
    if (cx + cl < xstart) {
#line 7266
      xstart = cx + cl;
    }
#line 7258
    cell___0 ++;
  }
#line 7269
  gxstart = xstart;
#line 7270
  gxstop = xstop;
#line 7271
  sprintf(filename, "%s.twf", cktName);
#line 7272
  tmp___8 = (int )openFile(filename, "w", 1);
#line 7272
  twfile = (FILE *)tmp___8;
#line 7273
  net = 1;
#line 7273
  while (net <= numnets) {
#line 7274
    jj = 0;
#line 7274
    while (jj <= numRows + 1) {
#line 7275
      *(*(pseudoPins + jj) + 0) = 0;
#line 7276
      *(*(pseudoPins + jj) + 1) = 0;
#line 7277
      *(*(pseudoEdge + jj) + 0) = 0;
#line 7278
      *(*(pseudoEdge + jj) + 1) = 0;
#line 7274
      jj ++;
    }
#line 7280
    numEdges = 0;
#line 7281
    top_row = -1;
#line 7282
    netptr = (*(netarray + net))->netptr;
#line 7283
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 7284
      top___0 = (int )netptr->pinloc;
#line 7285
      extint = netptr->extint;
#line 7286
      unequiv = (int )netptr->unequiv;
#line 7287
      block___0 = (int )netptr->row;
#line 7288
      if (block___0 > top_row) {
#line 7289
        if ((int )netptr->cell <= numcells) {
#line 7290
          top_row = block___0;
        } else {
#line 7291
          if ((int )(*(carray + netptr->cell))->padside != 1) {
#line 7291
            if ((int )(*(carray + netptr->cell))->padside != 3) {
#line 7293
              top_row = block___0;
            }
          }
        }
      }
#line 7296
      locX = netptr->xpos;
#line 7297
      locY = netptr->ypos;
#line 7298
      pin = netptr->terminal;
#line 7299
      found = 0;
#line 7300
      group = 1;
#line 7301
      while (1) {
#line 7301
        if ((int )(groupArray + group)->numPins != 0) {
#line 7301
          if (! (found == 0)) {
#line 7301
            break;
          }
        } else {
#line 7301
          break;
        }
#line 7302
        if ((groupArray + group)->extint == extint) {
#line 7302
          if (unequiv == 0) {
#line 7303
            found = 1;
          } else {
#line 7305
            group ++;
          }
        } else {
#line 7305
          group ++;
        }
      }
#line 7308
      (groupArray + group)->numPins = (short )((int )(groupArray + group)->numPins + 1);
#line 7308
      numPins = (groupArray + group)->numPins;
#line 7309
      ((groupArray + group)->pinArray + numPins)->xloc = (short )locX;
#line 7310
      ((groupArray + group)->pinArray + numPins)->yloc = (short )locY;
#line 7311
      ((groupArray + group)->pinArray + numPins)->top = (short )top___0;
#line 7312
      ((groupArray + group)->pinArray + numPins)->pin = pin;
#line 7313
      if (found == 0) {
#line 7314
        (groupArray + group)->aveX = locX;
#line 7315
        (groupArray + group)->aveY = locY;
#line 7316
        (groupArray + group)->extint = extint;
#line 7317
        (groupArray + group)->unequiv = (short )unequiv;
#line 7318
        (groupArray + group)->block = (short )block___0;
      } else {
#line 7321
        (groupArray + group)->aveX += locX;
#line 7322
        (groupArray + group)->aveY += locY;
      }
#line 7283
      netptr = netptr->nterm;
    }
#line 7325
    group = 1;
#line 7325
    while ((int )(groupArray + group)->numPins != 0) {
#line 7326
      numPins = (int )(groupArray + group)->numPins;
#line 7327
      if (numPins > 1) {
#line 7328
        (groupArray + group)->aveX /= numPins;
#line 7329
        (groupArray + group)->aveY /= numPins;
      }
#line 7325
      group ++;
    }
#line 7332
    numGroups = group - 1;
#line 7333
    if (numGroups == 2) {
#line 7334
      if ((int )(groupArray + 1)->unequiv == 1) {
#line 7334
        if ((int )(groupArray + 2)->unequiv == 1) {
#line 7335
          i = 1;
#line 7335
          while (i <= numGroups) {
#line 7336
            (groupArray + i)->numPins = (short)0;
#line 7337
            (groupArray + i)->flag = (short)0;
#line 7338
            (groupArray + i)->poison = (short)0;
#line 7339
            (groupArray + i)->unequiv = (short)0;
#line 7340
            (groupArray + i)->extint = 0;
#line 7341
            (groupArray + i)->edge1 = (short)0;
#line 7342
            (groupArray + i)->edge2 = (short)0;
#line 7343
            (groupArray + i)->check = (short)0;
#line 7335
            i ++;
          }
#line 7345
          i = 1;
#line 7345
          while (i <= numEdges) {
#line 7346
            (edgeArray + i)->marked = (short)0;
#line 7347
            (edgeArray + i)->done = (short)0;
#line 7348
            (edgeArray + i)->poison = (short)0;
#line 7345
            i ++;
          }
          goto __Cont;
        }
      }
    } else {
#line 7352
      if (numGroups <= 1) {
#line 7353
        i = 1;
#line 7353
        while (i <= numGroups) {
#line 7354
          (groupArray + i)->numPins = (short)0;
#line 7355
          (groupArray + i)->flag = (short)0;
#line 7356
          (groupArray + i)->poison = (short)0;
#line 7357
          (groupArray + i)->unequiv = (short)0;
#line 7358
          (groupArray + i)->extint = 0;
#line 7359
          (groupArray + i)->edge1 = (short)0;
#line 7360
          (groupArray + i)->edge2 = (short)0;
#line 7361
          (groupArray + i)->check = (short)0;
#line 7353
          i ++;
        }
#line 7363
        i = 1;
#line 7363
        while (i <= numEdges) {
#line 7364
          (edgeArray + i)->marked = (short)0;
#line 7365
          (edgeArray + i)->done = (short)0;
#line 7366
          (edgeArray + i)->poison = (short)0;
#line 7363
          i ++;
        }
        goto __Cont;
      }
    }
#line 7370
    qsortg((char *)(groupArray + 1), numGroups, sizeof(csGroup ));
#line 7371
    group = 1;
#line 7371
    while (group < numGroups) {
#line 7372
      block___0 = (int )(groupArray + group)->block;
#line 7373
      type1 = detGroup(group);
#line 7374
      searchG(group, type1, block___0);
#line 7371
      group ++;
    }
#line 7376
    edge1 = 1;
#line 7376
    while (edge1 <= numEdges) {
#line 7377
      a1 = (int )(edgeArray + edge1)->group1;
#line 7378
      a2 = (int )(edgeArray + edge1)->group2;
#line 7379
      if ((int )(groupArray + a1)->block != (int )(groupArray + a2)->block) {
        goto __Cont___0;
      }
#line 7382
      edge2 = edge1 + 1;
#line 7382
      while (edge2 <= numEdges) {
#line 7383
        b1 = (int )(edgeArray + edge2)->group1;
#line 7384
        b2 = (int )(edgeArray + edge2)->group2;
#line 7385
        if ((int )(groupArray + b1)->block != (int )(groupArray + b2)->block) {
          goto __Cont___1;
        }
#line 7388
        if ((int )(groupArray + a1)->unequiv == 1) {
#line 7388
          if ((int )(groupArray + b1)->unequiv == 1) {
#line 7388
            if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
#line 7388
              if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
                goto _L;
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 7388
          if ((int )(groupArray + a2)->unequiv == 1) {
#line 7388
            if ((int )(groupArray + b2)->unequiv == 1) {
#line 7388
              if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
#line 7388
                if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
                  _L: /* CIL Label */ 
#line 7396
                  ya = ((groupArray + a1)->aveY + (groupArray + a2)->aveY) / 2;
#line 7398
                  yb = ((groupArray + b1)->aveY + (groupArray + b2)->aveY) / 2;
#line 7400
                  if ((int )(groupArray + a1)->block == top_row) {
#line 7401
                    if (ya < yb) {
#line 7402
                      if ((int )(edgeArray + edge2)->cost <= (int )(edgeArray + edge1)->cost) {
#line 7404
                        (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost + 1);
                      }
                    } else {
#line 7408
                      if ((int )(edgeArray + edge2)->cost >= (int )(edgeArray + edge1)->cost) {
#line 7410
                        (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost - 1);
                      }
                    }
                  } else {
#line 7415
                    if (ya < yb) {
#line 7416
                      if ((int )(edgeArray + edge2)->cost >= (int )(edgeArray + edge1)->cost) {
#line 7418
                        (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost - 1);
                      }
                    } else {
#line 7422
                      if ((int )(edgeArray + edge2)->cost <= (int )(edgeArray + edge1)->cost) {
#line 7424
                        (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost + 1);
                      }
                    }
                  }
#line 7429
                  break;
                }
              }
            }
          }
        }
        __Cont___1: /* CIL Label */ 
#line 7382
        edge2 ++;
      }
      __Cont___0: /* CIL Label */ 
#line 7376
      edge1 ++;
    }
#line 7433
    qsorte((char *)(edgeArray + 1), numEdges, sizeof(edgeBox ));
#line 7435
    group = 1;
#line 7435
    while (group <= numGroups) {
#line 7436
      (groupArray + group)->flag = (short )group;
#line 7435
      group ++;
    }
#line 7438
    edge___0 = 1;
#line 7438
    while (edge___0 <= numEdges) {
#line 7439
      group1 = (int )(edgeArray + edge___0)->group1;
#line 7440
      flag1 = (int )(groupArray + group1)->flag;
#line 7441
      group2 = (int )(edgeArray + edge___0)->group2;
#line 7442
      flag2 = (int )(groupArray + group2)->flag;
#line 7443
      if (flag1 <= 0) {
        goto __Cont___2;
      } else {
#line 7443
        if (flag2 <= 0) {
          goto __Cont___2;
        } else {
#line 7443
          if (flag1 == flag2) {
            goto __Cont___2;
          }
        }
      }
#line 7446
      added_an_edge = 0;
#line 7447
      (edgeArray + edge___0)->marked = (short)1;
#line 7448
      group = 1;
#line 7448
      while (group <= numGroups) {
#line 7449
        if ((int )(groupArray + group)->flag == flag2) {
#line 7450
          (groupArray + group)->flag = (short )flag1;
        }
#line 7448
        group ++;
      }
#line 7453
      cell1 = (int )(*(tearray + ((groupArray + group1)->pinArray + 1)->pin))->cell;
#line 7454
      cell2 = (int )(*(tearray + ((groupArray + group2)->pinArray + 1)->pin))->cell;
#line 7455
      cellptr1 = *(carray + cell1);
#line 7456
      cellptr2 = *(carray + cell2);
#line 7457
      if (cell1 > numcells) {
#line 7457
        if ((int )cellptr1->padside != 2) {
#line 7457
          if ((int )cellptr1->padside != 14) {
#line 7457
            if ((int )cellptr1->padside != 15) {
#line 7457
              if ((int )cellptr1->padside != 4) {
#line 7461
                if (cell2 <= numcells) {
#line 7462
                  (groupArray + group1)->flag = (short)0;
                }
              }
            }
          }
        }
      }
#line 7465
      if (cell2 > numcells) {
#line 7465
        if ((int )cellptr2->padside != 2) {
#line 7465
          if ((int )cellptr2->padside != 14) {
#line 7465
            if ((int )cellptr2->padside != 15) {
#line 7465
              if ((int )cellptr2->padside != 4) {
#line 7469
                if (cell1 <= numcells) {
#line 7470
                  (groupArray + group2)->flag = (short)0;
                }
              }
            }
          }
        }
      }
#line 7473
      if ((int )(groupArray + group1)->unequiv == 1) {
#line 7474
        ei1 = (groupArray + group1)->extint;
#line 7475
        ue_grp = 1;
#line 7475
        while (ue_grp <= numGroups) {
#line 7476
          if (ue_grp == group1) {
            goto __Cont___3;
          }
#line 7479
          if ((groupArray + ue_grp)->extint == ei1) {
#line 7480
            break;
          }
          __Cont___3: /* CIL Label */ 
#line 7475
          ue_grp ++;
        }
#line 7483
        if ((int )(groupArray + ue_grp)->flag > 0) {
#line 7484
          g2 = 0;
#line 7484
          g1 = g2;
#line 7485
          (groupArray + ue_grp)->flag = (short)-1;
#line 7486
          edge2 = edge___0 + 1;
#line 7486
          while (edge2 <= numEdges) {
#line 7487
            if (g2 == 0) {
#line 7488
              if ((int )(edgeArray + edge2)->group1 == ue_grp) {
#line 7489
                g2 = (int )(edgeArray + edge2)->group2;
#line 7490
                if ((int )(groupArray + g2)->flag < 0) {
#line 7491
                  g2 = 0;
                }
                goto __Cont___4;
              }
            }
#line 7496
            if (g1 == 0) {
#line 7497
              if ((int )(edgeArray + edge2)->group2 == ue_grp) {
#line 7498
                g1 = (int )(edgeArray + edge2)->group1;
#line 7499
                if ((int )(groupArray + g1)->flag < 0) {
#line 7500
                  g1 = 0;
                }
              }
            }
            __Cont___4: /* CIL Label */ 
#line 7486
            edge2 ++;
          }
#line 7505
          if (g1 != 0) {
#line 7505
            if (g2 != 0) {
#line 7506
              addEdge(g1, g2);
#line 7507
              added_an_edge = 1;
            }
          }
        }
      }
#line 7511
      if ((int )(groupArray + group2)->unequiv == 1) {
#line 7512
        ei2 = (groupArray + group2)->extint;
#line 7513
        ue_grp = 1;
#line 7513
        while (ue_grp <= numGroups) {
#line 7514
          if (ue_grp == group2) {
            goto __Cont___5;
          }
#line 7517
          if ((groupArray + ue_grp)->extint == ei2) {
#line 7518
            break;
          }
          __Cont___5: /* CIL Label */ 
#line 7513
          ue_grp ++;
        }
#line 7521
        if ((int )(groupArray + ue_grp)->flag > 0) {
#line 7522
          g2 = 0;
#line 7522
          g1 = g2;
#line 7523
          (groupArray + ue_grp)->flag = (short)-1;
#line 7524
          edge2 = edge___0 + 1;
#line 7524
          while (edge2 <= numEdges) {
#line 7525
            if (g2 == 0) {
#line 7526
              if ((int )(edgeArray + edge2)->group1 == ue_grp) {
#line 7527
                g2 = (int )(edgeArray + edge2)->group2;
#line 7528
                if ((int )(groupArray + g2)->flag < 0) {
#line 7529
                  g2 = 0;
                }
                goto __Cont___6;
              }
            }
#line 7534
            if (g1 == 0) {
#line 7535
              if ((int )(edgeArray + edge2)->group2 == ue_grp) {
#line 7536
                g1 = (int )(edgeArray + edge2)->group1;
#line 7537
                if ((int )(groupArray + g1)->flag < 0) {
#line 7538
                  g1 = 0;
                }
              }
            }
            __Cont___6: /* CIL Label */ 
#line 7524
            edge2 ++;
          }
#line 7543
          if (g1 != 0) {
#line 7543
            if (g2 != 0) {
#line 7544
              addEdge(g1, g2);
#line 7545
              added_an_edge = 1;
            }
          }
        }
      }
#line 7549
      if (added_an_edge == 1) {
#line 7550
        edge1 = edge___0 + 1;
#line 7550
        while (edge1 <= numEdges) {
#line 7551
          a1 = (int )(edgeArray + edge1)->group1;
#line 7552
          a2 = (int )(edgeArray + edge1)->group2;
#line 7553
          if ((int )(groupArray + a1)->block != (int )(groupArray + a2)->block) {
            goto __Cont___7;
          }
#line 7556
          edge2 = edge1 + 1;
#line 7556
          while (edge2 <= numEdges) {
#line 7557
            b1 = (int )(edgeArray + edge2)->group1;
#line 7558
            b2 = (int )(edgeArray + edge2)->group2;
#line 7559
            if ((int )(groupArray + b1)->block != (int )(groupArray + b2)->block) {
              goto __Cont___8;
            }
#line 7562
            if ((int )(groupArray + a1)->unequiv == 1) {
#line 7562
              if ((int )(groupArray + b1)->unequiv == 1) {
#line 7562
                if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
#line 7562
                  if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
                    goto _L___3;
                  } else {
                    goto _L___6;
                  }
                } else {
                  goto _L___6;
                }
              } else {
                goto _L___6;
              }
            } else {
              _L___6: /* CIL Label */ 
#line 7562
              if ((int )(groupArray + a2)->unequiv == 1) {
#line 7562
                if ((int )(groupArray + b2)->unequiv == 1) {
#line 7562
                  if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
#line 7562
                    if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
                      _L___3: /* CIL Label */ 
#line 7574
                      ya = ((groupArray + a1)->aveY + (groupArray + a2)->aveY) / 2;
#line 7576
                      yb = ((groupArray + b1)->aveY + (groupArray + b2)->aveY) / 2;
#line 7578
                      if ((int )(groupArray + a1)->block == top_row) {
#line 7579
                        if (ya < yb) {
#line 7580
                          if ((int )(edgeArray + edge2)->cost <= (int )(edgeArray + edge1)->cost) {
#line 7582
                            (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost + 1);
                          }
                        } else {
#line 7586
                          if ((int )(edgeArray + edge2)->cost >= (int )(edgeArray + edge1)->cost) {
#line 7588
                            (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost - 1);
                          }
                        }
                      } else {
#line 7593
                        if (ya < yb) {
#line 7594
                          if ((int )(edgeArray + edge2)->cost >= (int )(edgeArray + edge1)->cost) {
#line 7596
                            (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost - 1);
                          }
                        } else {
#line 7600
                          if ((int )(edgeArray + edge2)->cost <= (int )(edgeArray + edge1)->cost) {
#line 7602
                            (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost + 1);
                          }
                        }
                      }
#line 7607
                      break;
                    }
                  }
                }
              }
            }
            __Cont___8: /* CIL Label */ 
#line 7556
            edge2 ++;
          }
          __Cont___7: /* CIL Label */ 
#line 7550
          edge1 ++;
        }
#line 7611
        qsorte((char *)((edgeArray + 1) + edge___0), numEdges - edge___0, sizeof(edgeBox ));
      }
      __Cont___2: /* CIL Label */ 
#line 7438
      edge___0 ++;
    }
#line 7615
    group = 1;
#line 7615
    while (group <= numGroups) {
#line 7616
      if ((int )(groupArray + group)->flag < 0) {
        goto __Cont___9;
      }
#line 7619
      if ((int )(groupArray + group)->unequiv != 1) {
        goto __Cont___9;
      }
#line 7622
      ei = (groupArray + group)->extint;
#line 7623
      group2 = group + 1;
#line 7623
      while (group2 <= numGroups) {
#line 7624
        if ((groupArray + group2)->extint == ei) {
#line 7625
          if ((int )(groupArray + group2)->flag >= 0) {
#line 7626
            (groupArray + group2)->flag = (short)-1;
          }
#line 7628
          break;
        }
#line 7623
        group2 ++;
      }
      __Cont___9: /* CIL Label */ 
#line 7615
      group ++;
    }
#line 7632
    done = 0;
#line 7633
    while (done == 0) {
#line 7634
      done = 1;
#line 7635
      edge___0 = 1;
#line 7635
      while (edge___0 <= numEdges) {
#line 7636
        if ((int )(edgeArray + edge___0)->marked == 1) {
#line 7636
          if ((int )(edgeArray + edge___0)->poison == 0) {
#line 7638
            g1 = (int )(edgeArray + edge___0)->group1;
#line 7639
            g2 = (int )(edgeArray + edge___0)->group2;
#line 7640
            unequiv1 = (int )(groupArray + g1)->unequiv;
#line 7641
            if (unequiv1 == 0) {
#line 7642
              if ((int )(groupArray + g1)->numPins == 1) {
#line 7642
                if ((int )((groupArray + g1)->pinArray + 1)->top != 0) {
#line 7644
                  single_pin1 = 1;
#line 7645
                  unequiv1 = 1;
                }
              }
            }
#line 7648
            unequiv2 = (int )(groupArray + g2)->unequiv;
#line 7649
            if (unequiv2 == 0) {
#line 7650
              if ((int )(groupArray + g2)->numPins == 1) {
#line 7650
                if ((int )((groupArray + g2)->pinArray + 1)->top != 0) {
#line 7652
                  single_pin2 = 1;
#line 7653
                  unequiv2 = 1;
                }
              }
            }
#line 7656
            if ((int )(groupArray + g1)->poison == 1) {
              goto _L___8;
            } else {
#line 7656
              if ((int )(groupArray + g2)->poison == 1) {
                _L___8: /* CIL Label */ 
#line 7658
                done = 0;
#line 7659
                (edgeArray + edge___0)->poison = (short)1;
#line 7660
                if (unequiv1 == 1) {
#line 7661
                  (groupArray + g1)->poison = (short)1;
                }
#line 7663
                if (unequiv2 == 1) {
#line 7664
                  (groupArray + g2)->poison = (short)1;
                }
              } else {
#line 7666
                if ((int )(groupArray + g1)->block != (int )(groupArray + g2)->block) {
#line 7667
                  done = 0;
#line 7668
                  (edgeArray + edge___0)->poison = (short)1;
#line 7669
                  if (unequiv1 == 1) {
#line 7670
                    (groupArray + g1)->poison = (short)1;
                  }
#line 7672
                  if (unequiv2 == 1) {
#line 7673
                    (groupArray + g2)->poison = (short)1;
                  }
                } else {
#line 7675
                  if (single_pin1 == 1) {
                    goto _L___7;
                  } else {
#line 7675
                    if (single_pin2 == 1) {
                      _L___7: /* CIL Label */ 
#line 7676
                      done = 0;
#line 7677
                      (edgeArray + edge___0)->poison = (short)1;
#line 7678
                      if (unequiv1 == 1) {
#line 7679
                        (groupArray + g1)->poison = (short)1;
                      }
#line 7681
                      if (unequiv2 == 1) {
#line 7682
                        (groupArray + g2)->poison = (short)1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 7635
        edge___0 ++;
      }
    }
#line 7688
    edge___0 = 1;
#line 7688
    while (edge___0 <= numEdges) {
#line 7689
      if ((int )(edgeArray + edge___0)->marked == 1) {
#line 7689
        if ((int )(edgeArray + edge___0)->poison == 0) {
#line 7691
          g1 = (int )(edgeArray + edge___0)->group1;
#line 7692
          g2 = (int )(edgeArray + edge___0)->group2;
#line 7693
          if ((int )(groupArray + g1)->unequiv == 0) {
#line 7693
            if ((int )(groupArray + g2)->unequiv == 0) {
#line 7694
              (edgeArray + edge___0)->poison = (short)1;
            }
          }
#line 7696
          if ((int )(groupArray + g1)->unequiv == 0) {
#line 7697
            (groupArray + g1)->poison = (short)1;
          }
#line 7699
          if ((int )(groupArray + g2)->unequiv == 0) {
#line 7700
            (groupArray + g2)->poison = (short)1;
          }
        }
      }
#line 7688
      edge___0 ++;
    }
#line 7704
    edge___0 = 1;
#line 7704
    while (edge___0 <= numEdges) {
#line 7705
      if ((int )(edgeArray + edge___0)->marked == 1) {
#line 7705
        if ((int )(edgeArray + edge___0)->poison == 0) {
#line 7707
          g1 = (int )(edgeArray + edge___0)->group1;
#line 7708
          g2 = (int )(edgeArray + edge___0)->group2;
#line 7709
          if ((int )(groupArray + g1)->edge1 == 0) {
#line 7710
            (groupArray + g1)->edge1 = (short )edge___0;
          } else {
#line 7712
            (groupArray + g1)->edge2 = (short )edge___0;
          }
#line 7714
          if ((int )(groupArray + g2)->edge1 == 0) {
#line 7715
            (groupArray + g2)->edge1 = (short )edge___0;
          } else {
#line 7717
            (groupArray + g2)->edge2 = (short )edge___0;
          }
#line 7719
          if ((int )(groupArray + g1)->poison == 0) {
#line 7720
            ei = (groupArray + g1)->extint;
#line 7721
            group = 1;
#line 7721
            while (1) {
#line 7722
              if (group == g1) {
                goto __Cont___10;
              } else {
#line 7722
                if ((groupArray + group)->extint != ei) {
                  goto __Cont___10;
                }
              }
#line 7725
              break;
              __Cont___10: /* CIL Label */ 
#line 7721
              group ++;
            }
#line 7727
            (groupArray + g1)->numPins = (short)2;
#line 7728
            ((groupArray + g1)->pinArray + 2)->xloc = ((groupArray + group)->pinArray + 1)->xloc;
#line 7729
            ((groupArray + g1)->pinArray + 2)->yloc = ((groupArray + group)->pinArray + 1)->yloc;
#line 7730
            ((groupArray + g1)->pinArray + 2)->top = ((groupArray + group)->pinArray + 1)->top;
#line 7731
            ((groupArray + g1)->pinArray + 2)->pin = ((groupArray + group)->pinArray + 1)->pin;
          }
#line 7733
          if ((int )(groupArray + g2)->poison == 0) {
#line 7734
            ei = (groupArray + g2)->extint;
#line 7735
            group = 1;
#line 7735
            while (1) {
#line 7736
              if (group == g2) {
                goto __Cont___11;
              } else {
#line 7736
                if ((groupArray + group)->extint != ei) {
                  goto __Cont___11;
                }
              }
#line 7739
              break;
              __Cont___11: /* CIL Label */ 
#line 7735
              group ++;
            }
#line 7741
            (groupArray + g2)->numPins = (short)2;
#line 7742
            ((groupArray + g2)->pinArray + 2)->xloc = ((groupArray + group)->pinArray + 1)->xloc;
#line 7743
            ((groupArray + g2)->pinArray + 2)->yloc = ((groupArray + group)->pinArray + 1)->yloc;
#line 7744
            ((groupArray + g2)->pinArray + 2)->top = ((groupArray + group)->pinArray + 1)->top;
#line 7745
            ((groupArray + g2)->pinArray + 2)->pin = ((groupArray + group)->pinArray + 1)->pin;
          }
        }
      }
#line 7704
      edge___0 ++;
    }
#line 7749
    edge___0 = 1;
#line 7749
    while (edge___0 <= numEdges) {
#line 7750
      if ((int )(edgeArray + edge___0)->marked == 1) {
#line 7750
        if ((int )(edgeArray + edge___0)->poison == 0) {
#line 7752
          g1 = (int )(edgeArray + edge___0)->group1;
#line 7753
          g2 = (int )(edgeArray + edge___0)->group2;
#line 7754
          if ((int )(groupArray + g1)->edge2 == 0) {
#line 7754
            if ((int )(groupArray + g2)->edge2 == 0) {
#line 7755
              (edgeArray + edge___0)->poison = (short)1;
            }
          }
        }
      }
#line 7749
      edge___0 ++;
    }
#line 7759
    closepins(twfile, net);
#line 7760
    i = 1;
#line 7760
    while (i <= numGroups) {
#line 7761
      (groupArray + i)->numPins = (short)0;
#line 7762
      (groupArray + i)->flag = (short)0;
#line 7763
      (groupArray + i)->poison = (short)0;
#line 7764
      (groupArray + i)->unequiv = (short)0;
#line 7765
      (groupArray + i)->extint = 0;
#line 7766
      (groupArray + i)->edge1 = (short)0;
#line 7767
      (groupArray + i)->edge2 = (short)0;
#line 7768
      (groupArray + i)->check = (short)0;
#line 7760
      i ++;
    }
#line 7770
    i = 1;
#line 7770
    while (i <= numEdges) {
#line 7771
      (edgeArray + i)->marked = (short)0;
#line 7772
      (edgeArray + i)->done = (short)0;
#line 7773
      (edgeArray + i)->poison = (short)0;
#line 7770
      i ++;
    }
    __Cont: /* CIL Label */ 
#line 7273
    net ++;
  }
#line 7776
  fclose(twfile);
#line 7777
  return 0;
}
}
#line 7779 "D:/a/test/300.c"
int chkGroup(int g1 , int g2 , int direction ) 
{ int g1type ;
  int g2type ;

  {
#line 7783
  g1type = detGroup(g1);
#line 7784
  g2type = detGroup(g2);
#line 7785
  if (direction == 0) {
#line 7786
    if (g1type == 0) {
#line 7787
      return (1);
    } else {
#line 7788
      if (g1type == 1) {
#line 7789
        if (g2type == 0) {
#line 7790
          return (1);
        } else {
#line 7789
          if (g2type == 1) {
#line 7790
            return (1);
          } else {
#line 7792
            return (0);
          }
        }
      } else {
#line 7795
        if (g2type == 0) {
#line 7796
          return (1);
        } else {
#line 7795
          if (g2type == -1) {
#line 7796
            return (1);
          } else {
#line 7798
            return (0);
          }
        }
      }
    }
  } else {
#line 7801
    if (direction == 1) {
#line 7802
      if (g1type == 0) {
        goto _L;
      } else {
#line 7802
        if (g1type == 1) {
          _L: /* CIL Label */ 
#line 7802
          if (g2type == 0) {
#line 7804
            return (1);
          } else {
#line 7802
            if (g2type == -1) {
#line 7804
              return (1);
            } else {
#line 7806
              return (0);
            }
          }
        } else {
#line 7806
          return (0);
        }
      }
    } else {
#line 7809
      if (g1type == 0) {
        goto _L___0;
      } else {
#line 7809
        if (g1type == -1) {
          _L___0: /* CIL Label */ 
#line 7809
          if (g2type == 0) {
#line 7811
            return (1);
          } else {
#line 7809
            if (g2type == 1) {
#line 7811
              return (1);
            } else {
#line 7813
              return (0);
            }
          }
        } else {
#line 7813
          return (0);
        }
      }
    }
  }
}
}
#line 7817 "D:/a/test/300.c"
int detGroup(int g ) 
{ int p ;
  int pt ;
  int pb ;
  int p0 ;

  {
#line 7821
  pt = 0;
#line 7822
  pb = 0;
#line 7823
  p0 = 0;
#line 7824
  p = 1;
#line 7824
  while (p <= (int )(groupArray + g)->numPins) {
#line 7825
    if ((int )((groupArray + g)->pinArray + p)->top == 0) {
#line 7826
      p0 = 1;
    } else {
#line 7827
      if ((int )((groupArray + g)->pinArray + p)->top == 1) {
#line 7828
        pt = 1;
      } else {
#line 7830
        pb = 1;
      }
    }
#line 7824
    p ++;
  }
#line 7833
  if (p0 == 1) {
#line 7834
    return (0);
  } else {
#line 7833
    if (pt == 1) {
#line 7833
      if (pb == 1) {
#line 7834
        return (0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 7835
      if (pt == 1) {
#line 7836
        return (1);
      } else {
#line 7838
        return (-1);
      }
    }
  }
}
}
#line 7841 "D:/a/test/300.c"
int addEdge(int g1 , int g2 ) 
{ 

  {
#line 7844
  numEdges ++;
#line 7844
  if ((groupArray + g1)->aveX - (groupArray + g2)->aveX >= 0) {
#line 7844
    (edgeArray + numEdges)->cost = (short )((groupArray + g1)->aveX - (groupArray + g2)->aveX);
  } else {
#line 7844
    (edgeArray + numEdges)->cost = (short )(- ((groupArray + g1)->aveX - (groupArray + g2)->aveX));
  }
#line 7846
  (edgeArray + numEdges)->group1 = (short )g1;
#line 7847
  (edgeArray + numEdges)->group2 = (short )g2;
#line 7848
  return 0;
}
}
#line 7850 "D:/a/test/300.c"
int searchG(int g , int type , int block___0 ) 
{ int og ;
  int uptarget ;
  int dntarget ;
  int type2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 7854
  uptarget = 0;
#line 7855
  dntarget = 0;
#line 7856
  if (type == 0) {
#line 7857
    og = g + 1;
#line 7857
    while (og <= numGroups) {
#line 7858
      if ((int )(groupArray + og)->block == block___0) {
#line 7859
        tmp = chkGroup(g, og, 0);
#line 7859
        if (tmp) {
#line 7860
          type2 = detGroup(og);
#line 7861
          if (type2 == 0) {
#line 7862
            if (uptarget == 0) {
#line 7862
              if (dntarget == 0) {
#line 7863
                addEdge(g, og);
              }
            }
#line 7865
            uptarget = 1;
#line 7866
            dntarget = 1;
          } else {
#line 7867
            if (type2 == 1) {
#line 7868
              if (uptarget == 0) {
#line 7869
                addEdge(g, og);
#line 7870
                uptarget = 1;
              }
            } else {
#line 7873
              if (dntarget == 0) {
#line 7874
                addEdge(g, og);
#line 7875
                dntarget = 1;
              }
            }
          }
        }
#line 7879
        if (uptarget == 1) {
#line 7879
          if (dntarget == 1) {
#line 7880
            break;
          }
        }
      } else {
#line 7882
        if ((int )(groupArray + og)->block == block___0 - 1) {
#line 7883
          tmp___0 = chkGroup(g, og, -1);
#line 7883
          if (tmp___0) {
#line 7884
            if (dntarget == 0) {
#line 7885
              addEdge(g, og);
#line 7886
              dntarget = 1;
            }
          }
#line 7889
          if (uptarget == 1) {
#line 7889
            if (dntarget == 1) {
#line 7890
              break;
            }
          }
        } else {
#line 7892
          if ((int )(groupArray + og)->block == block___0 + 1) {
#line 7893
            tmp___1 = chkGroup(g, og, 1);
#line 7893
            if (tmp___1) {
#line 7894
              if (uptarget == 0) {
#line 7895
                addEdge(g, og);
#line 7896
                uptarget = 1;
              }
            }
#line 7899
            if (uptarget == 1) {
#line 7899
              if (dntarget == 1) {
#line 7900
                break;
              }
            }
          }
        }
      }
#line 7857
      og ++;
    }
  } else {
#line 7904
    if (type == 1) {
#line 7905
      og = g + 1;
#line 7905
      while (og <= numGroups) {
#line 7906
        if ((int )(groupArray + og)->block == block___0) {
#line 7907
          tmp___2 = chkGroup(g, og, 0);
#line 7907
          if (tmp___2) {
#line 7908
            addEdge(g, og);
#line 7909
            break;
          }
        } else {
#line 7911
          if ((int )(groupArray + og)->block == block___0 + 1) {
#line 7912
            tmp___3 = chkGroup(g, og, 1);
#line 7912
            if (tmp___3) {
#line 7913
              addEdge(g, og);
#line 7914
              break;
            }
          }
        }
#line 7905
        og ++;
      }
    } else {
#line 7919
      og = g + 1;
#line 7919
      while (og <= numGroups) {
#line 7920
        if ((int )(groupArray + og)->block == block___0) {
#line 7921
          tmp___4 = chkGroup(g, og, 0);
#line 7921
          if (tmp___4) {
#line 7922
            addEdge(g, og);
#line 7923
            break;
          }
        } else {
#line 7925
          if ((int )(groupArray + og)->block == block___0 - 1) {
#line 7926
            tmp___5 = chkGroup(g, og, -1);
#line 7926
            if (tmp___5) {
#line 7927
              addEdge(g, og);
#line 7928
              break;
            }
          }
        }
#line 7919
        og ++;
      }
    }
  }
#line 7933
  return 0;
}
}
#line 7959
void checkPos(NBOXPTR pin , int pos , int llx , int lly , int urx , int ury ) ;
#line 7952 "D:/a/test/300.c"
int globedbg(int lowerNet , int upperNet ) 
{ int block___0 ;
  int left___0 ;
  int rite___0 ;
  int bot___0 ;
  int top___0 ;
  int cell___0 ;
  int b___0 ;
  int e ;
  int pin1 ;
  int pin2 ;
  int net ;
  int seg ;
  int term1 ;
  int curExtint ;
  int separation___0 ;
  int factor ;
  int llx ;
  int lly ;
  int urx ;
  int ury ;
  SEGBOXPTR sptr ;
  CBOXPTR cellptr___0 ;
  NBOXPTR curTerm ;
  FILE *fp ;
  FILE *fpp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 7964
  tmp = (int )openFile("cell.file", "w", 1);
#line 7964
  fp = (FILE *)tmp;
#line 7965
  block___0 = 1;
#line 7965
  while (block___0 <= numblock) {
#line 7966
    left___0 = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bleft;
#line 7967
    bot___0 = (*(barray + block___0))->bycenter + (int )(*(barray + block___0))->bbottom;
#line 7968
    top___0 = (*(barray + block___0))->bycenter + (int )(*(barray + block___0))->btop;
#line 7969
    if (*(*(pairArray + block___0) + 0) > 0) {
#line 7970
      cell___0 = *(*(pairArray + block___0) + *(*(pairArray + block___0) + 0));
#line 7971
      rite___0 = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->right;
    } else {
#line 7973
      rite___0 = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bright;
    }
#line 7975
    fprintf(fp, "%d, %d, %d, %d, color: %s, label: row:%d\n", left___0, bot___0, rite___0,
            top___0, "aquamarine", block___0);
#line 7965
    block___0 ++;
  }
#line 7978
  llx = 2147483647;
#line 7979
  lly = 2147483647;
#line 7980
  urx = (-0x7FFFFFFF-1);
#line 7981
  ury = (-0x7FFFFFFF-1);
#line 7982
  cell___0 = numcells + 1;
#line 7982
  while (cell___0 <= numcells + numterms) {
#line 7983
    cellptr___0 = *(carray + cell___0);
#line 7984
    left___0 = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->left;
#line 7985
    rite___0 = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
#line 7986
    bot___0 = cellptr___0->cycenter + (int )(cellptr___0->tileptr)->bottom;
#line 7987
    top___0 = cellptr___0->cycenter + (int )(cellptr___0->tileptr)->top;
#line 7988
    fprintf(fp, "%d, %d, %d, %d, color: %s, label: pad:%s\n", left___0, bot___0, rite___0,
            top___0, "aquamarine", cellptr___0->cname);
#line 7990
    if (left___0 < llx) {
#line 7991
      llx = left___0;
    }
#line 7993
    if (rite___0 > urx) {
#line 7994
      urx = rite___0;
    }
#line 7996
    if (bot___0 < lly) {
#line 7997
      lly = bot___0;
    }
#line 7999
    if (top___0 > ury) {
#line 8000
      ury = top___0;
    }
#line 7982
    cell___0 ++;
  }
#line 8003
  fclose(fp);
#line 8004
  tmp___0 = (int )openFile("net.file", "w", 1);
#line 8004
  fp = (FILE *)tmp___0;
#line 8005
  tmp___1 = (int )openFile("pin.file", "w", 1);
#line 8005
  fpp = (FILE *)tmp___1;
#line 8006
  separation___0 = ((int )rowSep * rowHeight) / 3;
#line 8007
  net = lowerNet;
#line 8007
  while (net <= upperNet) {
#line 8008
    b___0 = *(anet + net);
#line 8009
    e = *(anet + (net + 1)) - 1;
#line 8010
    seg = b___0;
#line 8010
    while (seg <= e) {
#line 8011
      if ((int )(aNetSeg + seg)->nflag == 0) {
#line 8014
        if ((int )(aNetSeg + seg)->current == 0) {
#line 8015
          sptr = (aNetSeg + seg)->top;
        } else {
#line 8017
          sptr = (aNetSeg + seg)->bot;
        }
#line 8019
        pin1 = sptr->pin1;
#line 8020
        pin2 = sptr->pin2;
#line 8021
        checkPos(*(tearray + pin1), 1, llx, lly, urx, ury);
#line 8022
        checkPos(*(tearray + pin2), 1, llx, lly, urx, ury);
#line 8023
        if ((*(tearray + pin1))->ypos != (*(tearray + pin2))->ypos) {
#line 8024
          fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
                  (*(tearray + pin1))->ypos, (*(tearray + pin2))->xpos, (*(tearray + pin2))->ypos,
                  "red");
        } else {
#line 8032
          if ((int )(*(tearray + pin1))->pinloc == -1) {
#line 8033
            factor = -1;
          } else {
#line 8035
            factor = 1;
          }
#line 8037
          fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
                  (*(tearray + pin1))->ypos, ((*(tearray + pin1))->xpos + (*(tearray + pin2))->xpos) / 2,
                  (*(tearray + pin2))->ypos + factor * separation___0, "red");
#line 8044
          fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, ((*(tearray + pin1))->xpos + (*(tearray + pin2))->xpos) / 2,
                  (*(tearray + pin2))->ypos + factor * separation___0, (*(tearray + pin2))->xpos,
                  (*(tearray + pin2))->ypos, "red");
        }
#line 8053
        term1 = (*(tearray + pin1))->terminal;
#line 8054
        curExtint = (*(tearray + pin1))->extint;
#line 8055
        curTerm = (*(netarray + net))->netptr;
#line 8055
        while (curTerm) {
#line 8056
          if (curTerm->extint == curExtint) {
#line 8056
            if (curTerm->terminal != term1) {
#line 8057
              if (curTerm->unequiv) {
#line 8058
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
                        (*(tearray + pin1))->ypos, curTerm->xpos, curTerm->ypos, "blue");
              } else {
#line 8066
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
                        (*(tearray + pin1))->ypos, curTerm->xpos, curTerm->ypos, "orange");
              }
            }
          }
#line 8055
          curTerm = curTerm->nterm;
        }
#line 8077
        term1 = (*(tearray + pin2))->terminal;
#line 8078
        curExtint = (*(tearray + pin2))->extint;
#line 8079
        curTerm = (*(netarray + net))->netptr;
#line 8079
        while (curTerm) {
#line 8080
          if (curTerm->extint == curExtint) {
#line 8080
            if (curTerm->terminal != term1) {
#line 8081
              if (curTerm->unequiv) {
#line 8082
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->xpos,
                        (*(tearray + pin2))->ypos, curTerm->xpos, curTerm->ypos, "blue");
              } else {
#line 8090
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->xpos,
                        (*(tearray + pin2))->ypos, curTerm->xpos, curTerm->ypos, "orange");
              }
            }
          }
#line 8079
          curTerm = curTerm->nterm;
        }
#line 8100
        fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin1))->xpos - 1,
                (*(tearray + pin1))->ypos - 1, (*(tearray + pin1))->xpos + 1, (*(tearray + pin1))->ypos + 1,
                "white", pin1);
#line 8108
        fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin2))->xpos - 1,
                (*(tearray + pin2))->ypos - 1, (*(tearray + pin2))->xpos + 1, (*(tearray + pin2))->ypos + 1,
                "white", pin2);
      } else {
#line 8117
        if ((int )(aNetSeg + seg)->current == 0) {
#line 8118
          sptr = (aNetSeg + seg)->top;
        } else {
#line 8120
          sptr = (aNetSeg + seg)->bot;
        }
#line 8122
        pin1 = sptr->pin1;
#line 8123
        pin2 = sptr->pin2;
#line 8125
        checkPos(*(tearray + pin1), 1, llx, lly, urx, ury);
#line 8126
        checkPos(*(tearray + pin2), 1, llx, lly, urx, ury);
#line 8127
        checkPos(*(tearray + pin1), 0, llx, lly, urx, ury);
#line 8128
        checkPos(*(tearray + pin2), 0, llx, lly, urx, ury);
#line 8129
        if ((*(tearray + pin1))->newy != (*(tearray + pin2))->newy) {
#line 8130
          fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->newx,
                  (*(tearray + pin1))->newy, (*(tearray + pin1))->newx - 2, ((*(tearray + pin1))->newy + (*(tearray + pin2))->newy) / 2,
                  "green");
#line 8137
          fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->newx - 2,
                  ((*(tearray + pin1))->newy + (*(tearray + pin2))->newy) / 2, (*(tearray + pin2))->newx,
                  (*(tearray + pin2))->newy, "green");
        } else {
#line 8145
          if ((int )(*(tearray + pin1))->pinloc == -1) {
#line 8146
            factor = -1;
          } else {
#line 8148
            factor = 1;
          }
#line 8150
          fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->newx,
                  (*(tearray + pin1))->newy, ((*(tearray + pin1))->newx + (*(tearray + pin2))->newx) / 2,
                  (*(tearray + pin2))->newy + ((factor * separation___0) * 3) / 4,
                  "green");
#line 8157
          fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, ((*(tearray + pin1))->newx + (*(tearray + pin2))->newx) / 2,
                  (*(tearray + pin2))->newy + ((factor * separation___0) * 3) / 4,
                  (*(tearray + pin2))->newx, (*(tearray + pin2))->newy, "green");
        }
#line 8166
        term1 = (*(tearray + pin1))->terminal;
#line 8167
        curExtint = (*(tearray + pin1))->extint;
#line 8168
        curTerm = (*(netarray + net))->netptr;
#line 8168
        while (curTerm) {
#line 8169
          if (curTerm->extint == curExtint) {
#line 8169
            if (curTerm->terminal != term1) {
#line 8170
              if (curTerm->unequiv) {
#line 8171
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->newx,
                        (*(tearray + pin1))->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin1))->newy) / 2,
                        "blue");
#line 8178
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, curTerm->newx,
                        curTerm->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin1))->newy) / 2,
                        "blue");
              } else {
#line 8186
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->newx,
                        (*(tearray + pin1))->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin1))->newy) / 2,
                        "orange");
#line 8193
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, curTerm->newx,
                        curTerm->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin1))->newy) / 2,
                        "orange");
              }
            }
          }
#line 8168
          curTerm = curTerm->nterm;
        }
#line 8204
        term1 = (*(tearray + pin2))->terminal;
#line 8205
        curExtint = (*(tearray + pin2))->extint;
#line 8206
        curTerm = (*(netarray + net))->netptr;
#line 8206
        while (curTerm) {
#line 8207
          if (curTerm->extint == curExtint) {
#line 8207
            if (curTerm->terminal != term1) {
#line 8208
              if (curTerm->unequiv) {
#line 8209
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->newx,
                        (*(tearray + pin2))->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin2))->newy) / 2,
                        "blue");
#line 8216
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, curTerm->newx,
                        curTerm->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin2))->newy) / 2,
                        "blue");
              } else {
#line 8224
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->newx,
                        (*(tearray + pin2))->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin2))->newy) / 2,
                        "orange");
#line 8231
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, curTerm->newx,
                        curTerm->newy, curTerm->newx - 2, (curTerm->newy + (*(tearray + pin2))->newy) / 2,
                        "orange");
              }
            }
          }
#line 8206
          curTerm = curTerm->nterm;
        }
#line 8241
        fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin1))->newx - 2,
                (*(tearray + pin1))->newy - 2, (*(tearray + pin1))->newx + 2, (*(tearray + pin1))->newy + 2,
                "black", pin1);
#line 8249
        fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin2))->newx - 2,
                (*(tearray + pin2))->newy - 2, (*(tearray + pin2))->newx + 2, (*(tearray + pin2))->newy + 2,
                "black", pin2);
#line 8257
        if ((int )(aNetSeg + seg)->ncurrent == 0) {
#line 8258
          sptr = (aNetSeg + seg)->ntop;
        } else {
#line 8260
          sptr = (aNetSeg + seg)->nbot;
        }
#line 8262
        pin1 = sptr->pin1;
#line 8263
        pin2 = sptr->pin2;
#line 8264
        if ((*(tearray + pin1))->ypos != (*(tearray + pin2))->ypos) {
#line 8265
          fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
                  (*(tearray + pin1))->ypos, (*(tearray + pin2))->xpos, (*(tearray + pin2))->ypos,
                  "red");
        } else {
#line 8273
          if ((int )(*(tearray + pin1))->pinloc == -1) {
#line 8274
            factor = -1;
          } else {
#line 8276
            factor = 1;
          }
#line 8278
          fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
                  (*(tearray + pin1))->ypos, ((*(tearray + pin1))->xpos + (*(tearray + pin2))->xpos) / 2,
                  (*(tearray + pin2))->ypos + factor * separation___0, "red");
#line 8285
          fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, ((*(tearray + pin1))->xpos + (*(tearray + pin2))->xpos) / 2,
                  (*(tearray + pin2))->ypos + factor * separation___0, (*(tearray + pin2))->xpos,
                  (*(tearray + pin2))->ypos, "red");
        }
#line 8293
        term1 = (*(tearray + pin1))->terminal;
#line 8294
        curExtint = (*(tearray + pin1))->extint;
#line 8295
        curTerm = (*(netarray + net))->netptr;
#line 8295
        while (curTerm) {
#line 8296
          if (curTerm->extint == curExtint) {
#line 8296
            if (curTerm->terminal != term1) {
#line 8297
              if (curTerm->unequiv) {
#line 8298
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
                        (*(tearray + pin1))->ypos, curTerm->xpos, curTerm->ypos, "blue");
              } else {
#line 8306
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin1))->xpos,
                        (*(tearray + pin1))->ypos, curTerm->xpos, curTerm->ypos, "orange");
              }
            }
          }
#line 8295
          curTerm = curTerm->nterm;
        }
#line 8317
        term1 = (*(tearray + pin2))->terminal;
#line 8318
        curExtint = (*(tearray + pin2))->extint;
#line 8319
        curTerm = (*(netarray + net))->netptr;
#line 8319
        while (curTerm) {
#line 8320
          if (curTerm->extint == curExtint) {
#line 8320
            if (curTerm->terminal != term1) {
#line 8321
              if (curTerm->unequiv) {
#line 8322
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->xpos,
                        (*(tearray + pin2))->ypos, curTerm->xpos, curTerm->ypos, "blue");
              } else {
#line 8330
                fprintf(fp, "%d, %d, %d, %d, %d, color: %s\n", net, (*(tearray + pin2))->xpos,
                        (*(tearray + pin2))->ypos, curTerm->xpos, curTerm->ypos, "orange");
              }
            }
          }
#line 8319
          curTerm = curTerm->nterm;
        }
#line 8340
        fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin1))->xpos - 1,
                (*(tearray + pin1))->ypos - 1, (*(tearray + pin1))->xpos + 1, (*(tearray + pin1))->ypos + 1,
                "white", pin1);
#line 8348
        fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label: %d\n", net, (*(tearray + pin2))->xpos - 1,
                (*(tearray + pin2))->ypos - 1, (*(tearray + pin2))->xpos + 1, (*(tearray + pin2))->ypos + 1,
                "white", pin2);
      }
#line 8010
      seg ++;
    }
#line 8007
    net ++;
  }
#line 8359
  fclose(fp);
#line 8360
  fclose(fpp);
#line 8361
  return 0;
}
}
#line 8363 "D:/a/test/300.c"
void checkPos(NBOXPTR pin , int pos , int llx , int lly , int urx , int ury ) 
{ 

  {
#line 8371
  if (pos == 1) {
#line 8372
    if (pin->xpos > urx) {
#line 8373
      printf("ERROR:pin xpos > urx ; set to urx ;");
#line 8374
      pin->xpos = urx;
    }
#line 8376
    if (pin->xpos < llx) {
#line 8377
      printf("ERROR:pin xpos < llx ; set to llx ;");
#line 8378
      pin->xpos = llx;
    }
#line 8380
    if (pin->ypos > ury) {
#line 8381
      printf("ERROR:pin ypos > ury ; set to ury ;");
#line 8382
      pin->ypos = ury;
    }
#line 8384
    if (pin->ypos < lly) {
#line 8385
      printf("ERROR:pin ypos < lly ; set to lly ;");
#line 8386
      pin->ypos = ury;
    }
  } else {
#line 8389
    if (pin->newx > urx) {
#line 8390
      printf("ERROR:pin newx > urx ; set to urx ;");
#line 8391
      pin->newx = urx;
    }
#line 8393
    if (pin->newx < llx) {
#line 8394
      printf("ERROR:pin newx < llx ; set to llx ;");
#line 8395
      pin->newx = llx;
    }
#line 8397
    if (pin->newy > ury) {
#line 8398
      printf("ERROR:pin newy > ury ; set to ury ;");
#line 8399
      pin->newy = ury;
    }
#line 8401
    if (pin->newy < lly) {
#line 8402
      printf("ERROR:pin newy < lly ; set to lly ;");
#line 8403
      pin->newy = ury;
    }
  }
#line 8406
  return ;
}
}
#line 8407 "D:/a/test/300.c"
void dumpEdgeArray(int net ) 
{ int edge___0 ;
  FILE *fp ;
  FILE *fpp ;
  int block___0 ;
  int left___0 ;
  int rite___0 ;
  int bot___0 ;
  int top___0 ;
  int cell___0 ;
  int g1 ;
  int g2 ;
  int llx ;
  int lly ;
  int urx ;
  int ury ;
  CBOXPTR cellptr___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 8416
  tmp = (int )openFile("cell.file", "w", 1);
#line 8416
  fp = (FILE *)tmp;
#line 8417
  block___0 = 1;
#line 8417
  while (block___0 <= numblock) {
#line 8418
    left___0 = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bleft;
#line 8419
    bot___0 = (*(barray + block___0))->bycenter + (int )(*(barray + block___0))->bbottom;
#line 8420
    top___0 = (*(barray + block___0))->bycenter + (int )(*(barray + block___0))->btop;
#line 8421
    if (*(*(pairArray + block___0) + 0) > 0) {
#line 8422
      cell___0 = *(*(pairArray + block___0) + *(*(pairArray + block___0) + 0));
#line 8423
      rite___0 = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->right;
    } else {
#line 8425
      rite___0 = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bright;
    }
#line 8427
    fprintf(fp, "%d, %d, %d, %d, color: %s, label: row:%d\n", left___0, bot___0, rite___0,
            top___0, "aquamarine", block___0);
#line 8417
    block___0 ++;
  }
#line 8430
  llx = 2147483647;
#line 8431
  lly = 2147483647;
#line 8432
  urx = (-0x7FFFFFFF-1);
#line 8433
  ury = (-0x7FFFFFFF-1);
#line 8434
  cell___0 = numcells + 1;
#line 8434
  while (cell___0 <= numcells + numterms) {
#line 8435
    cellptr___0 = *(carray + cell___0);
#line 8436
    left___0 = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->left;
#line 8437
    rite___0 = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
#line 8438
    bot___0 = cellptr___0->cycenter + (int )(cellptr___0->tileptr)->bottom;
#line 8439
    top___0 = cellptr___0->cycenter + (int )(cellptr___0->tileptr)->top;
#line 8440
    fprintf(fp, "%d, %d, %d, %d, color: %s, label: pad:%s\n", left___0, bot___0, rite___0,
            top___0, "aquamarine", cellptr___0->cname);
#line 8442
    if (left___0 < llx) {
#line 8443
      llx = left___0;
    }
#line 8445
    if (rite___0 > urx) {
#line 8446
      urx = rite___0;
    }
#line 8448
    if (bot___0 < lly) {
#line 8449
      lly = bot___0;
    }
#line 8451
    if (top___0 > ury) {
#line 8452
      ury = top___0;
    }
#line 8434
    cell___0 ++;
  }
#line 8455
  fclose(fp);
#line 8456
  tmp___0 = (int )openFile("net.file", "w", 1);
#line 8456
  fp = (FILE *)tmp___0;
#line 8457
  tmp___1 = (int )openFile("pin.file", "w", 1);
#line 8457
  fpp = (FILE *)tmp___1;
#line 8458
  edge___0 = 1;
#line 8458
  while (edge___0 <= numEdges) {
#line 8460
    g1 = (int )(edgeArray + edge___0)->group1;
#line 8461
    g2 = (int )(edgeArray + edge___0)->group2;
#line 8462
    if ((int )(edgeArray + edge___0)->marked == 1) {
#line 8463
      fprintf(fp, "%d, %d, %d, %d, %d, color: %s, label:%d\n", net, (groupArray + g1)->aveX,
              (groupArray + g1)->aveY, (groupArray + g2)->aveX, (groupArray + g2)->aveY,
              "red", edge___0);
#line 8471
      fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label:G%d\n", net, (groupArray + g1)->aveX - 1,
              (groupArray + g1)->aveY - 1, (groupArray + g1)->aveX + 1, (groupArray + g1)->aveY + 1,
              "white", g1);
#line 8479
      fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label:G%d\n", net, (groupArray + g2)->aveX - 1,
              (groupArray + g2)->aveY - 1, (groupArray + g2)->aveX + 1, (groupArray + g2)->aveY + 1,
              "white", g2);
    } else {
#line 8488
      fprintf(fp, "%d, %d, %d, %d, %d, color: %s, label:%d\n", net, (groupArray + g1)->aveX,
              (groupArray + g1)->aveY, (groupArray + g2)->aveX, (groupArray + g2)->aveY,
              "blue", edge___0);
#line 8496
      fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label:G%d\n", net, (groupArray + g1)->aveX - 1,
              (groupArray + g1)->aveY - 1, (groupArray + g1)->aveX + 1, (groupArray + g1)->aveY + 1,
              "black", g1);
#line 8504
      fprintf(fpp, "%d, %d, %d, %d, %d, color: %s, label:G%d\n", net, (groupArray + g2)->aveX - 1,
              (groupArray + g2)->aveY - 1, (groupArray + g2)->aveX + 1, (groupArray + g2)->aveY + 1,
              "black", g2);
    }
#line 8458
    edge___0 ++;
  }
#line 8514
  fclose(fp);
#line 8515
  fclose(fpp);
#line 8516
  return ;
}
}
#line 8541
int readseg(FILE *fp ) ;
#line 8594
int urcost(int segment ) ;
#line 8522 "D:/a/test/300.c"
int globroute(void) 
{ FILE *fp ;
  char filename[64] ;
  int attperseg ;
  int swSeg ;
  int flips ;
  int attempts___0 ;
  int seg ;
  int breakpoint ;
  int stoppoint ;
  int found ;
  SEGBOXPTR segptr ;
  DENSITYPTR denptr ;
  CHANGRDPTR gdptr ;
  CHANGRDPTR ptr1 ;
  CHANGRDPTR ptr2 ;
  int x ;
  int x1 ;
  int x2 ;
  int channel ;
  int track ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 8534
  attperseg = 40;
#line 8535
  randVar = (int )randomSeed2;
#line 8536
  fprintf(fpo, "\nThe rand generator seed was at globroute() : %d\n\n", randVar);
#line 8538
  sprintf(filename, "%s.twf", cktName);
#line 8539
  tmp = (int )openFile(filename, "r", 1);
#line 8539
  fp = (FILE *)tmp;
#line 8540
  changrid();
#line 8541
  readseg(fp);
#line 8542
  fclose(fp);
#line 8543
  if (stage == 3) {
#line 8544
    seg = 1;
#line 8544
    while (seg <= numSegs) {
#line 8545
      (aNetSeg + seg)->current = (char )*(fixarray + seg);
#line 8544
      seg ++;
    }
  }
#line 8548
  findrcost();
#line 8549
  fprintf(fpo, "\n\nTHIS IS THE ORIGINAL NUMBER OF TRACKS: %d\n\n\n", tracks);
#line 8551
  fflush(fpo);
#line 8552
  attlimit = attperseg * numSwSegs;
#line 8553
  attempts___0 = 0;
#line 8554
  flips = 0;
#line 8555
  stoppoint = 10 * numSwSegs;
#line 8556
  breakpoint = 0;
#line 8557
  while (attempts___0 < attlimit) {
#line 8558
    while (1) {
#line 8559
      while (1) {
#line 8560
        tmp___0 = Yacm_random();
#line 8560
        swSeg = (int )((double )numSegs * ((double )tmp___0 / (double )2147483647)) + 1;
#line 8559
        if (! (swSeg == numSegs + 1)) {
#line 8559
          break;
        }
      }
#line 8563
      if ((int )(aNetSeg + swSeg)->swYorN == 1) {
#line 8563
        if ((int )(aNetSeg + swSeg)->key == 0) {
#line 8564
          break;
        }
      }
    }
#line 8567
    if ((int )(aNetSeg + swSeg)->current == 0) {
#line 8568
      segptr = (aNetSeg + swSeg)->top;
    } else {
#line 8570
      segptr = (aNetSeg + swSeg)->bot;
    }
#line 8572
    channel = (int )segptr->channel;
#line 8573
    ptr1 = segptr->pin1ptr;
#line 8574
    ptr2 = segptr->pin2ptr;
#line 8575
    x1 = (ptr1->netptr)->xpos;
#line 8576
    x2 = (ptr2->netptr)->xpos;
#line 8577
    found = 0;
#line 8579
    denptr = (*(*(DboxHead + channel) + *(maxTrack + channel)))->next;
#line 8579
    while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 8581
      x = ((denptr->grdptr)->netptr)->xpos;
#line 8582
      if (x1 <= x) {
#line 8582
        if (x2 >= x) {
#line 8583
          found = 1;
#line 8584
          break;
        }
      }
#line 8579
      denptr = denptr->next;
    }
#line 8587
    if (! found) {
#line 8588
      breakpoint ++;
#line 8588
      if (breakpoint > stoppoint) {
#line 8589
        break;
      }
#line 8591
      attempts___0 ++;
#line 8592
      continue;
    }
#line 8594
    tmp___1 = urcost(swSeg);
#line 8594
    if (tmp___1) {
#line 8595
      flips ++;
#line 8596
      attempts___0 ++;
#line 8597
      breakpoint = 0;
    } else {
#line 8599
      breakpoint ++;
#line 8599
      if (breakpoint > stoppoint) {
#line 8600
        break;
      }
#line 8602
      attempts___0 ++;
    }
  }
#line 8605
  channel = 1;
#line 8605
  while (channel <= numChans) {
#line 8606
    gdptr = *(Begin + channel);
#line 8606
    while ((unsigned int )gdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 8608
      gdptr->ntracks = gdptr->tracks;
#line 8609
      gdptr->nSegType = gdptr->SegType;
#line 8610
      gdptr->nnextgrd = gdptr->nextgrd;
#line 8611
      gdptr->nprevgrd = gdptr->prevgrd;
#line 8612
      (gdptr->netptr)->newx = (gdptr->netptr)->xpos;
#line 8613
      (gdptr->netptr)->newy = (gdptr->netptr)->ypos;
#line 8606
      gdptr = gdptr->nextgrd;
    }
#line 8615
    track = 0;
#line 8615
    while (track <= max_tdensity + 100) {
#line 8616
      denptr = *(*(DboxHead + channel) + track);
#line 8616
      while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 8618
        denptr->nnext = denptr->next;
#line 8619
        denptr->nback = denptr->back;
#line 8616
        denptr = denptr->next;
      }
#line 8615
      track ++;
    }
#line 8622
    *(nmaxTrack + channel) = *(maxTrack + channel);
#line 8605
    channel ++;
  }
#line 8624
  fprintf(fpo, "no. of accepted flips: %d\n", flips);
#line 8625
  fprintf(fpo, "no. of attempted flips: %d\n", attempts___0);
#line 8626
  if (numSwSegs != 0) {
#line 8627
    fprintf(fpo, "no. of attempted flips / numSwSegs: %.1f\n", (double )attempts___0 / (double )numSwSegs);
  }
#line 8630
  fprintf(fpo, "THIS IS THE NUMBER OF TRACKS: %d\n\n\n", tracks);
#line 8631
  fflush(fpo);
#line 8632
  return 0;
}
}
#line 8636 "D:/a/test/300.c"
int gparser(FILE *fp ) 
{ int cell___0 ;
  int term ;
  int pinctr ;
  int i ;
  int layer ;
  int block___0 ;
  int left___0 ;
  int right ;
  int bottom ;
  int top___0 ;
  int xpos ;
  int ypos ;
  int orient ;
  int from ;
  double space___0 ;
  char input[1024] ;
  char netname[1024] ;
  NBOXPTR nptr ;
  NBOXPTR zapptr ;
  CBOXPTR ptr ;
  TEBOXPTR cptr ;
  TEBOXPTR koptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 8649
  cell___0 = 0;
#line 8650
  pinctr = 0;
#line 8651
  netctr = 0;
#line 8652
  maketabl();
#line 8653
  while (1) {
#line 8653
    tmp___10 = fscanf(fp, " %s ", input);
#line 8653
    if (! (tmp___10 == 1)) {
#line 8653
      break;
    }
#line 8654
    tmp___9 = strcmp((char const   *)(input), "cell");
#line 8654
    if (tmp___9 == 0) {
#line 8655
      cell___0 ++;
#line 8656
      fscanf(fp, " %s ", input);
#line 8657
      fscanf(fp, " %s ", input);
#line 8658
      fscanf(fp, " %s ", input);
#line 8659
      fscanf(fp, " %d ", & block___0);
    } else {
#line 8660
      tmp___8 = strcmp((char const   *)(input), "initially");
#line 8660
      if (tmp___8 == 0) {
#line 8661
        fscanf(fp, " %s ", input);
#line 8662
        fscanf(fp, " %d ", & from);
#line 8663
        fscanf(fp, " %s ", input);
#line 8664
        fscanf(fp, " %s ", input);
#line 8665
        fscanf(fp, " %s ", input);
#line 8666
        fscanf(fp, " %s ", input);
#line 8667
        fscanf(fp, " %d ", & block___0);
      } else {
#line 8668
        tmp___7 = strcmp((char const   *)(input), "nomirror");
#line 8668
        if (! (tmp___7 == 0)) {
#line 8669
          tmp___6 = strcmp((char const   *)(input), "left");
#line 8669
          if (tmp___6 == 0) {
#line 8670
            fscanf(fp, " %d ", & left___0);
#line 8671
            fscanf(fp, " %s ", input);
#line 8672
            fscanf(fp, " %d ", & right);
#line 8673
            fscanf(fp, " %s ", input);
#line 8674
            fscanf(fp, " %d ", & bottom);
#line 8675
            fscanf(fp, " %s ", input);
#line 8676
            fscanf(fp, " %d ", & top___0);
          } else {
#line 8677
            tmp___5 = strcmp((char const   *)(input), "pin");
#line 8677
            if (tmp___5 == 0) {
#line 8678
              fscanf(fp, " %s ", input);
#line 8679
              fscanf(fp, " %s ", input);
#line 8680
              fscanf(fp, " %s ", input);
#line 8681
              fscanf(fp, " %s ", input);
#line 8682
              strcpy(netname, (char const   *)(input));
#line 8683
              tmp = strcmp((char const   *)(input), "TW_PASS_THRU");
#line 8683
              if (tmp != 0) {
#line 8684
                pinctr ++;
#line 8685
                addhash(input);
              }
#line 8687
              if (pin_layers_given != 0) {
#line 8688
                fscanf(fp, " %s ", input);
#line 8689
                fscanf(fp, " %d ", & layer);
              }
#line 8691
              fscanf(fp, " %d %d ", & xpos, & ypos);
            } else {
#line 8692
              tmp___4 = strcmp((char const   *)(input), "equiv");
#line 8692
              if (tmp___4 == 0) {
#line 8693
                fscanf(fp, " %s ", input);
#line 8694
                fscanf(fp, " %s ", input);
#line 8695
                if (pin_layers_given != 0) {
#line 8696
                  fscanf(fp, " %s ", input);
#line 8697
                  fscanf(fp, " %d ", & layer);
                }
#line 8699
                fscanf(fp, " %d %d ", & xpos, & ypos);
#line 8700
                tmp___0 = strcmp((char const   *)(netname), "TW_PASS_THRU");
#line 8700
                if (tmp___0 != 0) {
#line 8701
                  pinctr ++;
                }
              } else {
#line 8703
                tmp___3 = strcmp((char const   *)(input), "unequiv");
#line 8703
                if (tmp___3 == 0) {
#line 8704
                  fscanf(fp, " %s ", input);
#line 8705
                  fscanf(fp, " %s ", input);
#line 8706
                  if (pin_layers_given != 0) {
#line 8707
                    fscanf(fp, " %s ", input);
#line 8708
                    fscanf(fp, " %d ", & layer);
                  }
#line 8710
                  fscanf(fp, " %d %d ", & xpos, & ypos);
#line 8711
                  pinctr ++;
                } else {
#line 8712
                  tmp___2 = strcmp((char const   *)(input), "pad");
#line 8712
                  if (tmp___2 == 0) {
#line 8713
                    fscanf(fp, " %s ", input);
#line 8714
                    fscanf(fp, " %s ", input);
#line 8715
                    fscanf(fp, " %s ", input);
#line 8716
                    fscanf(fp, " %d ", & orient);
#line 8717
                    fscanf(fp, " %s ", input);
#line 8718
                    fscanf(fp, " %d ", input);
#line 8719
                    fscanf(fp, " %s ", input);
#line 8720
                    fscanf(fp, " %d ", & left___0);
#line 8721
                    fscanf(fp, " %s ", input);
#line 8722
                    fscanf(fp, " %d ", & right);
#line 8723
                    fscanf(fp, " %s ", input);
#line 8724
                    fscanf(fp, " %d ", & bottom);
#line 8725
                    fscanf(fp, " %s ", input);
#line 8726
                    fscanf(fp, " %d ", & top___0);
                  } else {
#line 8727
                    tmp___1 = strcmp((char const   *)(input), "sidespace");
#line 8727
                    if (tmp___1 == 0) {
#line 8728
                      fscanf(fp, " %lf ", & space___0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 8731
  rewind(fp);
#line 8732
  tmp___11 = (int )safe_malloc((unsigned int )(numnets + 1) * sizeof(int ));
#line 8732
  top_row_for_this_net = (int *)tmp___11;
#line 8734
  tmp___12 = (int )safe_malloc((unsigned int )(numnets + 1) * sizeof(int ));
#line 8734
  bot_row_for_this_net = (int *)tmp___12;
#line 8736
  i = 1;
#line 8736
  while (i <= numnets) {
#line 8737
    *(top_row_for_this_net + i) = -1;
#line 8738
    *(bot_row_for_this_net + i) = 10000000;
#line 8736
    i ++;
  }
#line 8740
  insert_row(1);
#line 8741
  i = 1;
#line 8741
  while (i <= numnets) {
#line 8742
    nptr = (*(netarray + i))->netptr;
#line 8743
    while (nptr) {
#line 8744
      if ((int )nptr->row > *(top_row_for_this_net + i)) {
#line 8745
        *(top_row_for_this_net + i) = (int )nptr->row;
      }
#line 8747
      if ((int )nptr->row < *(bot_row_for_this_net + i)) {
#line 8748
        *(bot_row_for_this_net + i) = (int )nptr->row;
      }
#line 8743
      nptr = nptr->nterm;
    }
#line 8741
    i ++;
  }
#line 8752
  i = 1;
#line 8752
  while (i <= numnets) {
#line 8753
    nptr = (*(netarray + i))->netptr;
#line 8754
    (*(netarray + i))->netptr = (struct netbox *)((void *)0);
#line 8755
    if ((unsigned int )nptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 8756
      zapptr = nptr;
#line 8757
      while ((unsigned int )nptr->nterm != (unsigned int )((struct netbox *)((void *)0))) {
#line 8758
        nptr = nptr->nterm;
#line 8759
        safe_free(zapptr);
#line 8760
        zapptr = nptr;
      }
#line 8762
      safe_free(nptr);
    }
#line 8752
    i ++;
  }
#line 8765
  safe_free(tearray);
#line 8766
  tmp___13 = (int )safe_malloc((unsigned int )(pinctr + 1) * sizeof(NBOXPTR ));
#line 8766
  tearray = (NBOXPTR *)tmp___13;
#line 8767
  term = 1;
#line 8767
  while (term <= pinctr) {
#line 8768
    *(tearray + term) = (struct netbox *)((void *)0);
#line 8767
    term ++;
  }
#line 8770
  maxterm = pinctr;
#line 8771
  tmp___14 = (int )safe_malloc((unsigned int )(pinctr + 1) * sizeof(char *));
#line 8771
  pinnames = (char **)tmp___14;
#line 8772
  cell___0 = 1;
#line 8772
  while (cell___0 <= numcells + numterms) {
#line 8773
    ptr = *(carray + cell___0);
#line 8774
    ptr->numterms = (short)0;
#line 8775
    cptr = (ptr->tileptr)->termsptr;
#line 8776
    (ptr->tileptr)->termsptr = (struct termbox *)((void *)0);
#line 8777
    if ((unsigned int )cptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 8778
      koptr = cptr;
#line 8779
      while ((unsigned int )cptr->nextterm != (unsigned int )((struct termbox *)((void *)0))) {
#line 8780
        cptr = cptr->nextterm;
#line 8781
        safe_free(koptr);
#line 8782
        koptr = cptr;
      }
#line 8784
      safe_free(cptr);
    }
#line 8772
    cell___0 ++;
  }
#line 8787
  return 0;
}
}
#line 8799
int move(int moveType ) ;
#line 8800
int rect(short *l , short *b___0 , short *r , short *t ) ;
#line 8801
int point(short *x , short *y ) ;
#line 8814 "D:/a/test/300.c"
CELLTYPE *head_type  ;
#line 8814 "D:/a/test/300.c"
CELLTYPE *active_cell_type  ;
#line 8815 "D:/a/test/300.c"
IMPBOX *pin_ptr  ;
#line 8816 "D:/a/test/300.c"
int active_type  ;
#line 8851
int add_type(char *type ) ;
#line 8884
int hashfind(char *hname ) ;
#line 8936
int add_pin(int x ) ;
#line 9085
int delHtab(void) ;
#line 8817 "D:/a/test/300.c"
int grdcell(FILE *fp ) 
{ int i ;
  int cell___0 ;
  int orient ;
  int corient ;
  int block___0 ;
  int left___0 ;
  int right ;
  int bottom ;
  int top___0 ;
  int xpos ;
  int ypos ;
  int pinctr ;
  int netx ;
  int from ;
  int pick_top_pin ;
  int hack_off_a_pin ;
  int terms ;
  int net ;
  int extint ;
  int layer ;
  char input[1024] ;
  char netname[1024] ;
  char pname[1024] ;
  double space___0 ;
  CBOXPTR ptr ;
  TIBOXPTR tile ;
  TIBOXPTR tptr ;
  TEBOXPTR term ;
  TEBOXPTR tmptr ;
  NBOXPTR netptr ;
  NBOXPTR termptr ;
  NBOXPTR saveptr ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  TEBOXPTR tmp___2 ;
  int tmp___3 ;
  struct termbox *tmp___4 ;
  int tmp___5 ;
  NBOXPTR tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  struct termbox *tmp___11 ;
  int tmp___12 ;
  NBOXPTR tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  struct termbox *tmp___18 ;
  int tmp___19 ;
  NBOXPTR tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
#line 8834
  gparser(fp);
#line 8835
  tmp = (int )safe_malloc((unsigned int )(numRows + 1) * sizeof(IBOXPTR ));
#line 8835
  impFeeds = (IBOXPTR *)tmp;
#line 8836
  i = 1;
#line 8836
  while (i <= numRows) {
#line 8837
    *(impFeeds + i) = (struct ibox *)((void *)0);
#line 8836
    i ++;
  }
#line 8839
  cell___0 = 0;
#line 8840
  terms = 0;
#line 8841
  pinctr = 0;
#line 8842
  extint = 0;
#line 8843
  while (1) {
#line 8843
    tmp___36 = fscanf(fp, " %s ", input);
#line 8843
    if (! (tmp___36 == 1)) {
#line 8843
      break;
    }
#line 8844
    tmp___35 = strcmp((char const   *)(input), "cell");
#line 8844
    if (tmp___35 == 0) {
#line 8846
      cell___0 ++;
#line 8847
      ptr = *(carray + cell___0);
#line 8848
      fscanf(fp, " %s ", input);
#line 8849
      fscanf(fp, " %s ", input);
#line 8850
      if (gate_array_special) {
#line 8851
        active_type = add_type(input);
      }
    } else {
#line 8853
      tmp___34 = strcmp((char const   *)(input), "initially");
#line 8853
      if (tmp___34 == 0) {
#line 8854
        fscanf(fp, " %s ", input);
#line 8855
        fscanf(fp, " %d ", & from);
#line 8856
        fscanf(fp, " %s ", input);
#line 8857
        fscanf(fp, " %s ", input);
#line 8858
        fscanf(fp, " %s ", input);
#line 8859
        fscanf(fp, " %s ", input);
#line 8860
        fscanf(fp, " %d ", & block___0);
      } else {
#line 8861
        tmp___33 = strcmp((char const   *)(input), "nomirror");
#line 8861
        if (! (tmp___33 == 0)) {
#line 8862
          tmp___32 = strcmp((char const   *)(input), "left");
#line 8862
          if (tmp___32 == 0) {
#line 8863
            tile = ptr->tileptr;
#line 8864
            fscanf(fp, " %d ", & left___0);
          } else {
#line 8865
            tmp___31 = strcmp((char const   *)(input), "right");
#line 8865
            if (tmp___31 == 0) {
#line 8866
              fscanf(fp, " %d ", & right);
            } else {
#line 8867
              tmp___30 = strcmp((char const   *)(input), "bottom");
#line 8867
              if (tmp___30 == 0) {
#line 8868
                fscanf(fp, " %d ", & bottom);
              } else {
#line 8869
                tmp___29 = strcmp((char const   *)(input), "top");
#line 8869
                if (tmp___29 == 0) {
#line 8870
                  fscanf(fp, " %d ", & top___0);
                } else {
#line 8871
                  tmp___28 = strcmp((char const   *)(input), "pin");
#line 8871
                  if (tmp___28 == 0) {
#line 8872
                    fscanf(fp, " %s ", input);
#line 8873
                    fscanf(fp, " %s ", input);
#line 8874
                    strcpy(pname, (char const   *)(input));
#line 8875
                    fscanf(fp, " %s ", input);
#line 8876
                    fscanf(fp, " %s ", input);
#line 8877
                    strcpy(netname, (char const   *)(input));
#line 8878
                    tmp___8 = strcmp((char const   *)(netname), "TW_PASS_THRU");
#line 8878
                    if (tmp___8 != 0) {
#line 8879
                      pinctr ++;
#line 8880
                      extint ++;
#line 8881
                      tmp___0 = strlen((char const   *)(pname));
#line 8881
                      tmp___1 = (int )safe_malloc((tmp___0 + 1U) * sizeof(char ));
#line 8881
                      *(pinnames + pinctr) = (char *)tmp___1;
#line 8883
                      sprintf(*(pinnames + pinctr), "%s", pname);
#line 8884
                      netx = hashfind(input);
#line 8885
                      ptr->numterms = (short )((int )ptr->numterms + 1);
#line 8885
                      if (ptr->numterms == 1) {
#line 8886
                        tmp___3 = (int )safe_malloc(sizeof(TEBOX ));
#line 8886
                        tmp___2 = (struct termbox *)tmp___3;
#line 8886
                        tile->termsptr = tmp___2;
#line 8886
                        term = tmp___2;
                      } else {
#line 8889
                        tmp___5 = (int )safe_malloc(sizeof(TEBOX ));
#line 8889
                        tmp___4 = (struct termbox *)tmp___5;
#line 8889
                        term->nextterm = tmp___4;
#line 8889
                        term = tmp___4;
                      }
#line 8892
                      term->nextterm = (struct termbox *)((void *)0);
#line 8893
                      term->cellterm = pinctr;
#line 8894
                      term->ei = extint;
#line 8895
                      term->ue = (short)0;
#line 8896
                      saveptr = (*(netarray + netx))->netptr;
#line 8897
                      tmp___7 = (int )safe_malloc(sizeof(NBOX ));
#line 8897
                      tmp___6 = (struct netbox *)tmp___7;
#line 8897
                      (*(netarray + netx))->netptr = tmp___6;
#line 8897
                      netptr = tmp___6;
#line 8899
                      netptr->nterm = saveptr;
#line 8900
                      netptr->terminal = pinctr;
#line 8901
                      if (terms == 0) {
#line 8902
                        netptr->cell = (short )cell___0;
                      }
#line 8904
                      netptr->net = (short )netx;
#line 8905
                      netptr->xpos = 0;
#line 8906
                      netptr->ypos = 0;
#line 8907
                      netptr->newx = 0;
#line 8908
                      netptr->newy = 0;
#line 8909
                      netptr->flag = (char)0;
#line 8910
                      netptr->unequiv = (char)0;
#line 8911
                      if (pin_layers_given != 0) {
#line 8912
                        fscanf(fp, " %s ", input);
#line 8913
                        fscanf(fp, " %d ", & layer);
                      } else {
#line 8915
                        layer = 1;
                      }
#line 8917
                      fscanf(fp, " %d %d ", & xpos, & ypos);
#line 8918
                      netptr->layer = (char )(layer - 1);
#line 8919
                      term->txpos[0] = (short )xpos;
#line 8920
                      term->typos[0] = (short )ypos;
                    } else {
#line 8922
                      if (pin_layers_given != 0) {
#line 8923
                        fscanf(fp, " %s ", input);
#line 8924
                        fscanf(fp, " %d ", & layer);
                      } else {
#line 8926
                        layer = 1;
                      }
#line 8928
                      fscanf(fp, " %d %d ", & xpos, & ypos);
#line 8929
                      if (one_pin_feedthru) {
#line 8930
                        buildimp(cell___0, xpos, top___0, pname, 1, layer - 1);
#line 8931
                        buildimp(cell___0, xpos, bottom, pname, 0, layer - 1);
                      } else {
#line 8933
                        buildimp(cell___0, xpos, ypos, pname, 1, layer - 1);
                      }
#line 8935
                      if (gate_array_special) {
#line 8935
                        if (active_type) {
#line 8936
                          add_pin(xpos);
                        }
                      }
                    }
                  } else {
#line 8939
                    tmp___27 = strcmp((char const   *)(input), "equiv");
#line 8939
                    if (tmp___27 == 0) {
#line 8940
                      fscanf(fp, " %s ", input);
#line 8941
                      fscanf(fp, " %s ", input);
#line 8942
                      strcpy(pname, (char const   *)(input));
#line 8943
                      if (pin_layers_given != 0) {
#line 8944
                        fscanf(fp, " %s ", input);
#line 8945
                        fscanf(fp, " %d ", & layer);
                      } else {
#line 8947
                        layer = 1;
                      }
#line 8949
                      fscanf(fp, " %d %d ", & xpos, & ypos);
#line 8950
                      tmp___15 = strcmp((char const   *)(netname), "TW_PASS_THRU");
#line 8950
                      if (tmp___15 != 0) {
#line 8951
                        pinctr ++;
#line 8952
                        tmp___9 = strlen((char const   *)(pname));
#line 8952
                        tmp___10 = (int )safe_malloc((tmp___9 + 1U) * sizeof(char ));
#line 8952
                        *(pinnames + pinctr) = (char *)tmp___10;
#line 8954
                        sprintf(*(pinnames + pinctr), "%s", pname);
#line 8955
                        ptr->numterms = (short )((int )ptr->numterms + 1);
#line 8956
                        tmp___12 = (int )safe_malloc(sizeof(TEBOX ));
#line 8956
                        tmp___11 = (struct termbox *)tmp___12;
#line 8956
                        term->nextterm = tmp___11;
#line 8956
                        term = tmp___11;
#line 8958
                        term->nextterm = (struct termbox *)((void *)0);
#line 8959
                        term->cellterm = pinctr;
#line 8960
                        term->ei = extint;
#line 8961
                        term->ue = (short)0;
#line 8962
                        saveptr = (*(netarray + netx))->netptr;
#line 8963
                        tmp___14 = (int )safe_malloc(sizeof(NBOX ));
#line 8963
                        tmp___13 = (struct netbox *)tmp___14;
#line 8963
                        (*(netarray + netx))->netptr = tmp___13;
#line 8963
                        netptr = tmp___13;
#line 8965
                        netptr->nterm = saveptr;
#line 8966
                        netptr->terminal = pinctr;
#line 8967
                        netptr->net = (short )netx;
#line 8968
                        if (terms == 0) {
#line 8969
                          netptr->cell = (short )cell___0;
                        }
#line 8971
                        netptr->xpos = 0;
#line 8972
                        netptr->ypos = 0;
#line 8973
                        netptr->newx = 0;
#line 8974
                        netptr->newy = 0;
#line 8975
                        netptr->flag = (char)0;
#line 8976
                        netptr->unequiv = (char)0;
#line 8977
                        netptr->layer = (char )(layer - 1);
#line 8978
                        term->txpos[0] = (short )xpos;
#line 8979
                        term->typos[0] = (short )ypos;
                      } else {
#line 8981
                        buildimp(cell___0, xpos, ypos, pname, 0, layer - 1);
                      }
                    } else {
#line 8983
                      tmp___26 = strcmp((char const   *)(input), "unequiv");
#line 8983
                      if (tmp___26 == 0) {
#line 8984
                        fscanf(fp, " %s ", input);
#line 8985
                        fscanf(fp, " %s ", input);
#line 8986
                        strcpy(pname, (char const   *)(input));
#line 8987
                        if (pin_layers_given != 0) {
#line 8988
                          fscanf(fp, " %s ", input);
#line 8989
                          fscanf(fp, " %d ", & layer);
                        } else {
#line 8991
                          layer = 1;
                        }
#line 8993
                        fscanf(fp, " %d %d ", & xpos, & ypos);
#line 8994
                        hack_off_a_pin = 0;
#line 8995
                        if ((int )(*(netarray + netx))->numpins >= 10) {
#line 8996
                          hack_off_a_pin = 1;
#line 8997
                          if (*(top_row_for_this_net + netx) % 2 == 0) {
#line 8999
                            if ((int )(*(carray + cell___0))->cblock != *(bot_row_for_this_net + netx)) {
#line 9001
                              if ((int )(*(carray + cell___0))->cblock % 2 == 0) {
#line 9002
                                pick_top_pin = 0;
                              } else {
#line 9004
                                pick_top_pin = 1;
                              }
                            } else {
#line 9007
                              pick_top_pin = 1;
                            }
                          } else {
#line 9010
                            if ((int )(*(carray + cell___0))->cblock != *(bot_row_for_this_net + netx)) {
#line 9012
                              if ((int )(*(carray + cell___0))->cblock % 2 == 1) {
#line 9013
                                pick_top_pin = 0;
                              } else {
#line 9015
                                pick_top_pin = 1;
                              }
                            } else {
#line 9018
                              pick_top_pin = 1;
                            }
                          }
#line 9021
                          if ((int )(*(barray + (*(carray + cell___0))->cblock))->borient == 2) {
#line 9022
                            if (pick_top_pin == 0) {
#line 9023
                              pick_top_pin = 1;
                            } else {
#line 9025
                              pick_top_pin = 0;
                            }
                          }
                        }
#line 9029
                        if (hack_off_a_pin == 0) {
#line 9030
                          pinctr ++;
#line 9031
                          tmp___16 = strlen((char const   *)(pname));
#line 9031
                          tmp___17 = (int )safe_malloc((tmp___16 + 1U) * sizeof(char ));
#line 9031
                          *(pinnames + pinctr) = (char *)tmp___17;
#line 9033
                          sprintf(*(pinnames + pinctr), "%s", pname);
#line 9034
                          ptr->numterms = (short )((int )ptr->numterms + 1);
#line 9035
                          term->ue = (short)1;
#line 9036
                          tmp___19 = (int )safe_malloc(sizeof(TEBOX ));
#line 9036
                          tmp___18 = (struct termbox *)tmp___19;
#line 9036
                          term->nextterm = tmp___18;
#line 9036
                          term = tmp___18;
#line 9038
                          term->nextterm = (struct termbox *)((void *)0);
#line 9039
                          term->cellterm = pinctr;
#line 9040
                          term->ei = extint;
#line 9041
                          term->ue = (short)1;
#line 9042
                          saveptr = (*(netarray + netx))->netptr;
#line 9043
                          saveptr->unequiv = (char)1;
#line 9044
                          tmp___21 = (int )safe_malloc(sizeof(NBOX ));
#line 9044
                          tmp___20 = (struct netbox *)tmp___21;
#line 9044
                          (*(netarray + netx))->netptr = tmp___20;
#line 9044
                          netptr = tmp___20;
#line 9046
                          netptr->nterm = saveptr;
#line 9047
                          netptr->terminal = pinctr;
#line 9048
                          netptr->net = (short )netx;
#line 9049
                          if (terms == 0) {
#line 9050
                            netptr->cell = (short )cell___0;
                          }
#line 9052
                          netptr->xpos = 0;
#line 9053
                          netptr->ypos = 0;
#line 9054
                          netptr->newx = 0;
#line 9055
                          netptr->newy = 0;
#line 9056
                          netptr->flag = (char)0;
#line 9057
                          netptr->unequiv = (char)1;
#line 9058
                          netptr->layer = (char )(layer - 1);
#line 9059
                          term->txpos[0] = (short )xpos;
#line 9060
                          term->typos[0] = (short )ypos;
                        } else {
#line 9062
                          if (ypos < -1) {
#line 9062
                            if (pick_top_pin == 1) {
#line 9064
                              continue;
                            } else {
                              goto _L;
                            }
                          } else {
                            _L: /* CIL Label */ 
#line 9062
                            if (ypos > 1) {
#line 9062
                              if (pick_top_pin == 0) {
#line 9064
                                continue;
                              } else {
#line 9066
                                sprintf(*(pinnames + pinctr), "%s", pname);
#line 9067
                                term->txpos[0] = (short )xpos;
#line 9068
                                term->typos[0] = (short )ypos;
                              }
                            } else {
#line 9066
                              sprintf(*(pinnames + pinctr), "%s", pname);
#line 9067
                              term->txpos[0] = (short )xpos;
#line 9068
                              term->typos[0] = (short )ypos;
                            }
                          }
                        }
                      } else {
#line 9071
                        tmp___25 = strcmp((char const   *)(input), "pad");
#line 9071
                        if (tmp___25 == 0) {
#line 9072
                          terms ++;
#line 9073
                          fscanf(fp, " %s ", input);
#line 9074
                          fscanf(fp, " %s ", input);
#line 9075
                          ptr = *(carray + (numcells + terms));
                        } else {
#line 9076
                          tmp___24 = strcmp((char const   *)(input), "orient");
#line 9076
                          if (tmp___24 == 0) {
#line 9077
                            fscanf(fp, " %d ", & orient);
                          } else {
#line 9078
                            tmp___23 = strcmp((char const   *)(input), "padside");
#line 9078
                            if (tmp___23 == 0) {
#line 9079
                              fscanf(fp, " %s ", input);
                            } else {
#line 9080
                              tmp___22 = strcmp((char const   *)(input), "sidespace");
#line 9080
                              if (tmp___22 == 0) {
#line 9081
                                fscanf(fp, " %lf ", & space___0);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 9084
  safe_free(top_row_for_this_net);
#line 9085
  delHtab();
#line 9086
  net = 1;
#line 9086
  while (net <= numnets) {
#line 9087
    netptr = (*(netarray + net))->netptr;
#line 9087
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 9089
      *(tearray + netptr->terminal) = netptr;
#line 9087
      netptr = netptr->nterm;
    }
#line 9086
    net ++;
  }
#line 9092
  cell___0 = 1;
#line 9092
  while (cell___0 <= numcells) {
#line 9093
    ptr = *(carray + cell___0);
#line 9094
    tptr = ptr->tileptr;
#line 9095
    tmptr = tptr->termsptr;
#line 9095
    while ((unsigned int )tmptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 9097
      if ((int )ptr->clength % 2 != 0) {
#line 9098
        tmptr->txpos[1] = (short )(- ((int )tmptr->txpos[0]) + 1);
      } else {
#line 9100
        tmptr->txpos[1] = (short )(- ((int )tmptr->txpos[0]));
      }
#line 9102
      if ((int )ptr->cheight % 2 != 0) {
#line 9103
        tmptr->typos[1] = (short )(- ((int )tmptr->typos[0]) + 1);
      } else {
#line 9105
        tmptr->typos[1] = (short )(- ((int )tmptr->typos[0]));
      }
#line 9095
      tmptr = tmptr->nextterm;
    }
#line 9092
    cell___0 ++;
  }
#line 9109
  cell___0 = numcells + 1;
#line 9109
  while (cell___0 <= numcells + numterms) {
#line 9110
    ptr = *(carray + cell___0);
#line 9111
    tptr = ptr->tileptr;
#line 9112
    move(ptr->corient);
#line 9113
    tmptr = tptr->termsptr;
#line 9113
    while ((unsigned int )tmptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 9115
      tmptr->txpos[1] = tmptr->txpos[0];
#line 9116
      tmptr->typos[1] = tmptr->typos[0];
#line 9117
      point(& tmptr->txpos[1], & tmptr->typos[1]);
#line 9118
      if ((int )ptr->cheight % 2 != 0) {
#line 9118
        if (orient == 4) {
#line 9120
          tmptr->txpos[1] = (short )((int )tmptr->txpos[1] + 1);
        } else {
#line 9118
          if (orient == 6) {
#line 9120
            tmptr->txpos[1] = (short )((int )tmptr->txpos[1] + 1);
          } else {
            goto _L___0;
          }
        }
      } else {
        _L___0: /* CIL Label */ 
#line 9118
        if ((int )ptr->clength % 2 != 0) {
#line 9118
          if (orient == 2) {
#line 9120
            tmptr->txpos[1] = (short )((int )tmptr->txpos[1] + 1);
          } else {
#line 9118
            if (orient == 3) {
#line 9120
              tmptr->txpos[1] = (short )((int )tmptr->txpos[1] + 1);
            }
          }
        }
      }
#line 9122
      if ((int )ptr->cheight % 2 != 0) {
#line 9122
        if (orient == 1) {
#line 9124
          tmptr->typos[1] = (short )((int )tmptr->typos[1] + 1);
        } else {
#line 9122
          if (orient == 3) {
#line 9124
            tmptr->typos[1] = (short )((int )tmptr->typos[1] + 1);
          } else {
            goto _L___1;
          }
        }
      } else {
        _L___1: /* CIL Label */ 
#line 9122
        if ((int )ptr->clength % 2 != 0) {
#line 9122
          if (orient == 4) {
#line 9124
            tmptr->typos[1] = (short )((int )tmptr->typos[1] + 1);
          } else {
#line 9122
            if (orient == 7) {
#line 9124
              tmptr->typos[1] = (short )((int )tmptr->typos[1] + 1);
            }
          }
        }
      }
#line 9113
      tmptr = tmptr->nextterm;
    }
#line 9109
    cell___0 ++;
  }
#line 9128
  cell___0 = 1;
#line 9128
  while (cell___0 <= numcells) {
#line 9129
    ptr = *(carray + cell___0);
#line 9130
    tile = ptr->tileptr;
#line 9131
    corient = (int )ptr->corient;
#line 9132
    term = tile->termsptr;
#line 9132
    while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 9134
      termptr = *(tearray + term->cellterm);
#line 9135
      termptr->xpos = (int )term->txpos[corient / 2] + ptr->cxcenter;
#line 9136
      termptr->ypos = (int )term->typos[corient % 2] + ptr->cycenter;
#line 9132
      term = term->nextterm;
    }
#line 9128
    cell___0 ++;
  }
#line 9139
  cell___0 = numcells + 1;
#line 9139
  while (cell___0 <= numcells + numterms) {
#line 9140
    ptr = *(carray + cell___0);
#line 9141
    tile = ptr->tileptr;
#line 9142
    term = tile->termsptr;
#line 9142
    while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 9144
      termptr = *(tearray + term->cellterm);
#line 9145
      termptr->xpos = (int )term->txpos[1] + ptr->cxcenter;
#line 9146
      termptr->ypos = (int )term->typos[1] + ptr->cycenter;
#line 9142
      term = term->nextterm;
    }
#line 9139
    cell___0 ++;
  }
#line 9149
  return 0;
}
}
#line 9151 "D:/a/test/300.c"
int add_type(char *type ) 
{ CELLTYPE *cell_ptr ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 9155
  if ((unsigned int )head_type == (unsigned int )((void *)0)) {
#line 9156
    tmp = (int )safe_malloc(sizeof(CELLTYPE ));
#line 9156
    head_type = (CELLTYPE *)tmp;
#line 9157
    head_type->next_cell = (struct celltype *)((void *)0);
#line 9158
    head_type->first_imp = (struct impbox *)((void *)0);
#line 9159
    tmp___0 = strlen((char const   *)type);
#line 9159
    tmp___1 = (int )safe_malloc((tmp___0 + 1U) * sizeof(char ));
#line 9159
    head_type->name = (char *)tmp___1;
#line 9161
    sprintf(head_type->name, "%s", type);
#line 9162
    pin_ptr = (IMPBOX *)((void *)0);
#line 9163
    active_cell_type = head_type;
#line 9164
    return (1);
  } else {
#line 9166
    cell_ptr = head_type;
#line 9167
    while (1) {
#line 9168
      tmp___2 = strcmp((char const   *)cell_ptr->name, (char const   *)type);
#line 9168
      if (tmp___2 == 0) {
#line 9169
        return (0);
      }
#line 9171
      if ((unsigned int )cell_ptr->next_cell != (unsigned int )((void *)0)) {
#line 9172
        cell_ptr = cell_ptr->next_cell;
      } else {
#line 9174
        tmp___3 = (int )safe_malloc(sizeof(CELLTYPE ));
#line 9174
        cell_ptr->next_cell = (CELLTYPE *)tmp___3;
#line 9176
        (cell_ptr->next_cell)->next_cell = (struct celltype *)((void *)0);
#line 9177
        (cell_ptr->next_cell)->first_imp = (struct impbox *)((void *)0);
#line 9178
        tmp___4 = strlen((char const   *)type);
#line 9178
        tmp___5 = (int )safe_malloc((tmp___4 + 1U) * sizeof(char ));
#line 9178
        (cell_ptr->next_cell)->name = (char *)tmp___5;
#line 9180
        sprintf((cell_ptr->next_cell)->name, "%s", type);
#line 9181
        pin_ptr = (IMPBOX *)((void *)0);
#line 9182
        active_cell_type = cell_ptr->next_cell;
#line 9183
        return (1);
      }
    }
  }
}
}
#line 9188 "D:/a/test/300.c"
int add_pin(int x ) 
{ struct impbox *tmp ;
  int tmp___0 ;
  struct impbox *tmp___1 ;
  int tmp___2 ;

  {
#line 9191
  if ((unsigned int )pin_ptr == (unsigned int )((void *)0)) {
#line 9192
    tmp___0 = (int )safe_malloc(sizeof(IMPBOX ));
#line 9192
    tmp = (IMPBOX *)tmp___0;
#line 9192
    active_cell_type->first_imp = tmp;
#line 9192
    pin_ptr = tmp;
  } else {
#line 9195
    tmp___2 = (int )safe_malloc(sizeof(IMPBOX ));
#line 9195
    tmp___1 = (IMPBOX *)tmp___2;
#line 9195
    pin_ptr->next_pin = tmp___1;
#line 9195
    pin_ptr = tmp___1;
  }
#line 9197
  pin_ptr->x = x;
#line 9198
  pin_ptr->next_pin = (struct impbox *)((void *)0);
#line 9199
  return 0;
}
}
#line 9201 "D:/a/test/300.c"
int find_imp_x(char *name , int x ) 
{ int tmp ;
  struct _reent *tmp___0 ;
  int tmp___1 ;
  struct _reent *tmp___2 ;

  {
#line 9205
  tmp = strcmp("twfeed", (char const   *)name);
#line 9205
  if (tmp == 0) {
#line 9206
    if (x < 0) {
#line 9207
      return (0);
    } else {
#line 9209
      return (- fdWidth / 2);
    }
  }
#line 9212
  active_cell_type = head_type;
#line 9213
  while (1) {
#line 9214
    if ((unsigned int )active_cell_type == (unsigned int )((void *)0)) {
#line 9215
      fprintf(fpo, "Failed to find implicit type\n");
#line 9216
      printf("Failed to find implicit type: <%s>\n", name);
#line 9217
      tmp___0 = __getreent();
#line 9217
      fflush(tmp___0->_stdout);
#line 9218
      exit(1);
    }
#line 9220
    tmp___1 = strcmp((char const   *)active_cell_type->name, (char const   *)name);
#line 9220
    if (tmp___1 == 0) {
#line 9221
      break;
    }
#line 9223
    active_cell_type = active_cell_type->next_cell;
  }
#line 9225
  pin_ptr = active_cell_type->first_imp;
#line 9226
  while (1) {
#line 9227
    if ((unsigned int )pin_ptr == (unsigned int )((void *)0)) {
#line 9228
      fprintf(fpo, "Failed to find implicit pin\n");
#line 9229
      printf("Failed to find implicit pin at x=<%d>\n", x);
#line 9230
      tmp___2 = __getreent();
#line 9230
      fflush(tmp___2->_stdout);
#line 9231
      exit(1);
    }
#line 9233
    if (pin_ptr->x == x) {
#line 9234
      break;
    }
#line 9236
    pin_ptr = pin_ptr->next_pin;
  }
#line 9238
  if ((unsigned int )pin_ptr->next_pin == (unsigned int )((void *)0)) {
#line 9239
    return ((active_cell_type->first_imp)->x);
  } else {
#line 9241
    return (- (pin_ptr->next_pin)->x);
  }
}
}
#line 9247 "D:/a/test/300.c"
int maketabl(void) 
{ int i ;
  int tmp ;

  {
#line 9250
  tmp = (int )safe_malloc(3001U * sizeof(HASHPTR ));
#line 9250
  hashtab = (HASHPTR *)tmp;
#line 9251
  i = 0;
#line 9251
  while (i < 3001) {
#line 9252
    *(hashtab + i) = (struct hash *)((void *)0);
#line 9251
    i ++;
  }
#line 9254
  return 0;
}
}
#line 9256 "D:/a/test/300.c"
int delHtab(void) 
{ int i ;
  HASHPTR hptr ;
  HASHPTR zapptr ;

  {
#line 9260
  i = 0;
#line 9260
  while (i < 3001) {
#line 9261
    hptr = *(hashtab + i);
#line 9262
    if ((unsigned int )hptr != (unsigned int )((struct hash *)((void *)0))) {
#line 9263
      zapptr = hptr;
#line 9264
      while ((unsigned int )hptr->hnext != (unsigned int )((struct hash *)((void *)0))) {
#line 9265
        hptr = hptr->hnext;
#line 9266
        safe_free(zapptr);
#line 9267
        zapptr = hptr;
      }
#line 9269
      safe_free(hptr);
    }
#line 9260
    i ++;
  }
#line 9272
  safe_free(hashtab);
#line 9273
  return 0;
}
}
#line 9275 "D:/a/test/300.c"
int addhash(char *hname ) 
{ int i ;
  HASHPTR hptr ;
  unsigned int hsum ;
  size_t tmp ;
  HASHPTR tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct hash *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
#line 9280
  hsum = 0U;
#line 9281
  i = 0;
#line 9281
  while (1) {
#line 9281
    tmp = strlen((char const   *)hname);
#line 9281
    if (! ((size_t )i < tmp)) {
#line 9281
      break;
    }
#line 9282
    hsum += (unsigned int )*(hname + i);
#line 9281
    i ++;
  }
#line 9284
  hsum %= 3001U;
#line 9285
  hptr = *(hashtab + hsum);
#line 9285
  if ((unsigned int )hptr == (unsigned int )((struct hash *)((void *)0))) {
#line 9286
    tmp___1 = (int )safe_malloc(sizeof(HASHBOX ));
#line 9286
    tmp___0 = (struct hash *)tmp___1;
#line 9286
    *(hashtab + hsum) = tmp___0;
#line 9286
    hptr = tmp___0;
#line 9287
    hptr->hnext = (struct hash *)((void *)0);
#line 9288
    netctr ++;
#line 9288
    hptr->hnum = netctr;
#line 9289
    tmp___2 = strlen((char const   *)hname);
#line 9289
    tmp___3 = (int )safe_malloc((tmp___2 + 1U) * sizeof(char ));
#line 9289
    hptr->hname = (char *)tmp___3;
#line 9291
    sprintf(hptr->hname, "%s", hname);
#line 9292
    return (1);
  } else {
#line 9294
    while (1) {
#line 9295
      tmp___4 = strcmp((char const   *)hname, (char const   *)hptr->hname);
#line 9295
      if (tmp___4 == 0) {
#line 9296
        return (0);
      }
#line 9298
      if ((unsigned int )hptr->hnext == (unsigned int )((struct hash *)((void *)0))) {
#line 9299
        tmp___6 = (int )safe_malloc(sizeof(HASHBOX ));
#line 9299
        tmp___5 = (struct hash *)tmp___6;
#line 9299
        hptr->hnext = tmp___5;
#line 9299
        hptr = tmp___5;
#line 9300
        hptr->hnext = (struct hash *)((void *)0);
#line 9301
        netctr ++;
#line 9301
        hptr->hnum = netctr;
#line 9302
        tmp___7 = strlen((char const   *)hname);
#line 9302
        tmp___8 = (int )safe_malloc((tmp___7 + 1U) * sizeof(char ));
#line 9302
        hptr->hname = (char *)tmp___8;
#line 9304
        sprintf(hptr->hname, "%s", hname);
#line 9305
        return (1);
      } else {
#line 9307
        hptr = hptr->hnext;
      }
    }
  }
}
}
#line 9312 "D:/a/test/300.c"
int hashfind(char *hname ) 
{ int i ;
  HASHPTR hptr ;
  unsigned int hsum ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 9317
  hsum = 0U;
#line 9318
  i = 0;
#line 9318
  while (1) {
#line 9318
    tmp = strlen((char const   *)hname);
#line 9318
    if (! ((size_t )i < tmp)) {
#line 9318
      break;
    }
#line 9319
    hsum += (unsigned int )*(hname + i);
#line 9318
    i ++;
  }
#line 9321
  hsum %= 3001U;
#line 9322
  hptr = *(hashtab + hsum);
#line 9322
  if ((unsigned int )hptr == (unsigned int )((struct hash *)((void *)0))) {
#line 9323
    return (0);
  } else {
#line 9325
    while (1) {
#line 9326
      tmp___0 = strcmp((char const   *)hname, (char const   *)hptr->hname);
#line 9326
      if (tmp___0 == 0) {
#line 9327
        return (hptr->hnum);
      }
#line 9329
      if ((unsigned int )hptr->hnext == (unsigned int )((struct hash *)((void *)0))) {
#line 9330
        return (0);
      } else {
#line 9332
        hptr = hptr->hnext;
      }
    }
  }
}
}
#line 9339 "D:/a/test/300.c"
int implfeeds(int row___0 , int xc ) 
{ IBOXPTR iptr ;
  int minspan ;
  int tmp ;

  {
#line 9344
  minspan = 32000;
#line 9345
  siptr = (struct ibox *)((void *)0);
#line 9346
  iptr = *(impFeeds + row___0);
#line 9346
  while ((unsigned int )iptr != (unsigned int )((struct ibox *)((void *)0))) {
#line 9347
    if (iptr->iactive <= 0) {
#line 9348
      if (iptr->aveXpos - xc >= 0) {
#line 9348
        tmp = iptr->aveXpos - xc;
      } else {
#line 9348
        tmp = - (iptr->aveXpos - xc);
      }
#line 9348
      if (tmp < minspan) {
#line 9349
        if (iptr->aveXpos - xc >= 0) {
#line 9349
          minspan = iptr->aveXpos - xc;
        } else {
#line 9349
          minspan = - (iptr->aveXpos - xc);
        }
#line 9350
        siptr = iptr;
      }
    }
#line 9346
    iptr = iptr->niptr;
  }
#line 9354
  if ((unsigned int )siptr != (unsigned int )((struct ibox *)((void *)0))) {
#line 9354
    if (minspan <= ifrange) {
#line 9355
      if (siptr->iactive == 0) {
#line 9356
        siptr->iactive = 1;
      } else {
#line 9358
        siptr->iactive = 2;
      }
#line 9360
      return (1);
    } else {
#line 9362
      return (0);
    }
  } else {
#line 9362
    return (0);
  }
}
}
#line 9365 "D:/a/test/300.c"
int impfix(void) 
{ IBOXPTR iptr ;
  IBOXPTR niptr ;
  IPBOXPTR ipptr ;
  IPBOXPTR nipptr ;
  int row___0 ;

  {
#line 9370
  row___0 = 1;
#line 9370
  while (row___0 <= numRows) {
#line 9371
    iptr = *(impFeeds + row___0);
#line 9372
    if ((unsigned int )iptr == (unsigned int )((struct ibox *)((void *)0))) {
      goto __Cont;
    }
#line 9375
    if (iptr->iactive != 1) {
#line 9376
      ipptr = iptr->iptr;
#line 9377
      while ((unsigned int )ipptr != (unsigned int )((struct ipbox *)((void *)0))) {
#line 9378
        nipptr = ipptr->npin;
#line 9379
        safe_free(ipptr);
#line 9380
        ipptr = nipptr;
      }
#line 9382
      niptr = iptr->niptr;
#line 9383
      safe_free(iptr);
#line 9384
      iptr = niptr;
#line 9385
      while ((unsigned int )iptr != (unsigned int )((struct ibox *)((void *)0))) {
#line 9386
        if (iptr->iactive == 1) {
#line 9387
          break;
        } else {
#line 9389
          ipptr = iptr->iptr;
#line 9389
          while ((unsigned int )ipptr != (unsigned int )((struct ipbox *)((void *)0))) {
#line 9390
            nipptr = ipptr->npin;
#line 9391
            safe_free(ipptr);
#line 9392
            ipptr = nipptr;
          }
#line 9394
          niptr = iptr->niptr;
#line 9395
          safe_free(iptr);
#line 9396
          iptr = niptr;
        }
      }
#line 9399
      *(impFeeds + row___0) = iptr;
    }
#line 9401
    if ((unsigned int )iptr != (unsigned int )((struct ibox *)((void *)0))) {
#line 9402
      niptr = iptr->niptr;
#line 9403
      while ((unsigned int )niptr != (unsigned int )((struct ibox *)((void *)0))) {
#line 9404
        if (niptr->iactive != 1) {
#line 9405
          ipptr = niptr->iptr;
#line 9405
          while ((unsigned int )ipptr != (unsigned int )((struct ipbox *)((void *)0))) {
#line 9406
            nipptr = ipptr->npin;
#line 9407
            safe_free(ipptr);
#line 9408
            ipptr = nipptr;
          }
#line 9410
          iptr->niptr = niptr->niptr;
#line 9411
          safe_free(niptr);
#line 9412
          niptr = iptr->niptr;
        } else {
#line 9414
          iptr = niptr;
#line 9415
          niptr = iptr->niptr;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 9370
    row___0 ++;
  }
#line 9420
  row___0 = 1;
#line 9420
  while (row___0 <= numRows) {
#line 9421
    iptr = *(impFeeds + row___0);
#line 9421
    while ((unsigned int )iptr != (unsigned int )((struct ibox *)((void *)0))) {
#line 9422
      iptr->iactive = 0;
#line 9421
      iptr = iptr->niptr;
    }
#line 9420
    row___0 ++;
  }
#line 9425
  return 0;
}
}
#line 9427 "D:/a/test/300.c"
int impclobr(void) 
{ IBOXPTR iptr ;
  IBOXPTR niptr ;
  IPBOXPTR ipptr ;
  IPBOXPTR nipptr ;
  int row___0 ;

  {
#line 9432
  row___0 = 1;
#line 9432
  while (row___0 <= numRows) {
#line 9433
    iptr = *(impFeeds + row___0);
#line 9434
    while ((unsigned int )iptr != (unsigned int )((struct ibox *)((void *)0))) {
#line 9435
      niptr = iptr->niptr;
#line 9436
      ipptr = iptr->iptr;
#line 9436
      while ((unsigned int )ipptr != (unsigned int )((struct ipbox *)((void *)0))) {
#line 9437
        nipptr = ipptr->npin;
#line 9438
        safe_free(ipptr);
#line 9439
        ipptr = nipptr;
      }
#line 9441
      safe_free(iptr);
#line 9442
      iptr = niptr;
    }
#line 9432
    row___0 ++;
  }
#line 9445
  safe_free(impFeeds);
#line 9446
  return 0;
}
}
#line 9476
int initProgram(char *name , char *version ) ;
#line 9477
int readParFile(void) ;
#line 9478
int Yset_random_seed(int seed ) ;
#line 9492
int readcell(FILE *fp ) ;
#line 9496
int readnets(FILE *fp ) ;
#line 9589
int utemp(void) ;
#line 9594
int outcm(void) ;
#line 9614
int add_dummy_feeds(int feednum ) ;
#line 9621
int fixfdpos(FILE *fp ) ;
#line 9648
int ugpair(void) ;
#line 9657
int mergplist(void) ;
#line 9658
int outpins(void) ;
#line 9659
int output(void) ;
#line 9675
int print_stats(FILE *fp ) ;
#line 9458 "D:/a/test/300.c"
int main(int argc , char **argv ) 
{ FILE *fp ;
  char filename[64] ;
  int block___0 ;
  int i ;
  int net ;
  int changes ;
  int l ;
  int r ;
  int b___0 ;
  int t ;
  int cx ;
  int cy ;
  int cl ;
  int cr ;
  int cb ;
  int ct ;
  int cell___0 ;
  int row___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 9468
  if (argc != 2) {
#line 9469
    printf("circuit name not entered properly on command line\n");
#line 9470
    printf("Proper syntax: TimberwolfSC circuitName\n");
#line 9471
    exit(1);
  }
#line 9473
  sprintf(cktName, "%s", *(argv + 1));
#line 9474
  sprintf(filename, "%s.out", cktName);
#line 9475
  tmp = (int )openFile(filename, "w", 1);
#line 9475
  fpo = (FILE *)tmp;
#line 9476
  initProgram("TimberWolfSC", "v4.3a");
#line 9477
 // readParFile();
#line 9478
  Yset_random_seed(randomSeed);
#line 9479
  sprintf(filename, "%s.blk", cktName);
#line 9480
  tmp___0 = (int )openFile(filename, "r", 1);
#line 9480
  fp = (FILE *)tmp___0;
#line 9481
  readblck(fp);
#line 9482
  fclose(fp);
#line 9483
  maxCellO = 0;
#line 9484
  block___0 = 1;
#line 9484
  while (block___0 <= numblock) {
#line 9485
    if ((int )(*(barray + block___0))->borient == 2) {
#line 9486
      maxCellO = 1;
#line 9487
      break;
    }
#line 9484
    block___0 ++;
  }
#line 9490
  sprintf(filename, "%s.cel", cktName);
#line 9491
  tmp___1 = (int )openFile(filename, "r", 1);
#line 9491
  fp = (FILE *)tmp___1;
#line 9492
  readcell(fp);
#line 9493
  fclose(fp);
#line 9494
  sprintf(filename, "%s.net", cktName);
#line 9495
  tmp___2 = (int )openFile(filename, "r", 1);
#line 9495
  fp = (FILE *)tmp___2;
#line 9496
  readnets(fp);
#line 9497
  fclose(fp);
#line 9498
  iteration = 0;
#line 9499
  T1 = 500.0;
#line 9500
  t = 0;
#line 9501
  b___0 = 32000;
#line 9502
  r = 0;
#line 9503
  l = 32000;
#line 9504
  block___0 = 1;
#line 9504
  while (block___0 <= numblock) {
#line 9505
    cx = (*(barray + block___0))->bxcenter;
#line 9506
    cy = (*(barray + block___0))->bycenter;
#line 9507
    cl = (int )(*(barray + block___0))->bleft;
#line 9508
    cr = (int )(*(barray + block___0))->bright;
#line 9509
    cb = (int )(*(barray + block___0))->bbottom;
#line 9510
    ct = (int )(*(barray + block___0))->btop;
#line 9511
    if (cx + cr > r) {
#line 9512
      r = cx + cr;
    }
#line 9514
    if (cx + cl < l) {
#line 9515
      l = cx + cl;
    }
#line 9517
    if (cy + ct > t) {
#line 9518
      t = cy + ct;
    }
#line 9520
    if (cy + cb < b___0) {
#line 9521
      b___0 = cy + cb;
    }
#line 9504
    block___0 ++;
  }
#line 9524
  blkxspan = r - l;
#line 9525
  blkyspan = t - b___0;
#line 9526
  ifrange = (int )((double )blkxspan * imprange);
#line 9527
  fprintf(fpo, "block x-span:%d  block y-span:%d\n", blkxspan, blkyspan);
#line 9528
  fprintf(fpo, "implicit feed thru range: %d\n", ifrange);
#line 9529
  cell___0 = 1;
#line 9529
  while (cell___0 <= numcells + numterms) {
#line 9530
    cx = (*(carray + cell___0))->cxcenter;
#line 9531
    cy = (*(carray + cell___0))->cycenter;
#line 9532
    cl = (int )((*(carray + cell___0))->tileptr)->left;
#line 9533
    cr = (int )((*(carray + cell___0))->tileptr)->right;
#line 9534
    cb = (int )((*(carray + cell___0))->tileptr)->bottom;
#line 9535
    ct = (int )((*(carray + cell___0))->tileptr)->top;
#line 9536
    if (cx + cr > r) {
#line 9537
      r = cx + cr;
    }
#line 9539
    if (cx + cl < l) {
#line 9540
      l = cx + cl;
    }
#line 9542
    if (cy + ct > t) {
#line 9543
      t = cy + ct;
    }
#line 9545
    if (cy + cb < b___0) {
#line 9546
      b___0 = cy + cb;
    }
#line 9529
    cell___0 ++;
  }
#line 9549
  bdxlen = r - l;
#line 9550
  bdylen = t - b___0;
#line 9551
  lrtxspan = r;
#line 9552
  lrtyspan = t;
#line 9553
  net = 1;
#line 9553
  while (net <= numnets) {
#line 9554
    (*(netarray + net))->Vweight *= 2.0 / (rowSep + 1.0);
#line 9553
    net ++;
  }
#line 9556
  binpenCon = 4.0 * (((double )numcells / (double )numblock) / 39.0);
#line 9557
  if (binpenCon > 4.0) {
#line 9557
    binpenCon = binpenCon;
  } else {
#line 9557
    binpenCon = 4.0;
  }
#line 9558
  binpenCon = 1.0;
#line 9559
  roLenCon = 3.0;
#line 9560
  fprintf(fpo, "Using default value of bin.penalty.control:%f\n", binpenCon);
#line 9562
  funccost = findcost();
#line 9563
  assignro();
#line 9564
  initialize_rows();
#line 9565
  tmp___3 = initialize_cost();
#line 9565
  fprintf(fpo, "\nNew Cost Function: Initial Horizontal Cost:%d\n", tmp___3);
#line 9567
  vert_statistics();
#line 9568
  fprintf(fpo, "New Cost Function: FEEDS:%d   MISSING_ROWS:%d\n\n", tot_num_feeds,
          tot_missing_rows);
#line 9570
  fprintf(fpo, "bdxlen:%d  bdylen:%d\n", bdxlen, bdylen);
#line 9571
  fprintf(fpo, "l:%d  t:%d  r:%d  b:%d\n", l, t, r, b___0);
#line 9573
  fprintf(fpo, "\n\n\nTHIS IS THE ROUTE COST OF THE ");
#line 9574
  fprintf(fpo, "CURRENT PLACEMENT: %d\n", funccost);
#line 9575
  fprintf(fpo, "\n\n\nTHIS IS THE PENALTY OF THE ");
#line 9576
  fprintf(fpo, "CURRENT PLACEMENT: %d\n", penalty);
#line 9577
  fflush(fpo);
#line 9578
  if (! costonly) {
#line 9579
    Tzero = 0.1;
#line 9580
    tmp___4 = (int )safe_malloc(117U * sizeof(double ));
#line 9580
    desired_accept = (double *)tmp___4;
#line 9581
    i = 0;
#line 9581
    while (i <= 116) {
#line 9582
      if (i < 7) {
#line 9583
        *(desired_accept + i) = 50.0;
      } else {
#line 9585
        *(desired_accept + i) = 50.5 - (50.0 / 110.0) * (double )(i - 6);
      }
#line 9581
      i ++;
    }
#line 9589
    utemp();
  } else {
#line 9591
    if (connection_machine) {
#line 9592
      unlap(-1);
#line 9593
      findunlap(-1);
#line 9594
      outcm();
    }
#line 9596
    if (doglobal) {
#line 9597
      countf();
#line 9598
      sprintf(filename, "%s.cel", cktName);
#line 9599
      tmp___5 = (int )openFile(filename, "r", 1);
#line 9599
      fp = (FILE *)tmp___5;
#line 9600
      grdcell(fp);
#line 9601
      fclose(fp);
#line 9602
      reassign();
#line 9603
      if (addFeeds == 0) {
#line 9604
        row___0 = 1;
#line 9604
        while (row___0 <= numblock) {
#line 9605
          *(nofeed + row___0) = 1;
#line 9604
          row___0 ++;
        }
      }
#line 9608
      findunlap(1);
#line 9609
      fdthrus = findfeeds(0);
#line 9610
      fdthrus += *(add_to_row + 0);
#line 9611
      fixwolf(fdthrus);
#line 9612
      findfeeds(1);
#line 9613
      unlap(-2);
#line 9614
      add_dummy_feeds(last_feed);
#line 9615
      numcells += fdthrus;
#line 9616
      if (stage >= 2) {
#line 9617
        sprintf(filename, "%s.rs2", cktName);
#line 9618
        tmp___6 = (int )openFile(filename, "r", 0);
#line 9618
        fp = (FILE *)tmp___6;
#line 9620
        if (fp) {
#line 9621
          fixfdpos(fp);
#line 9622
          fclose(fp);
        }
      }
#line 9625
      findunlap(0);
#line 9629
      i = 1;
#line 9629
      while (i <= 8) {
#line 9630
        align_init();
#line 9631
        changes = alignfeed();
#line 9632
        fprintf(fpo, "Total Feed-Alignment Movement (Pass %d): %d\n", i, changes);
#line 9629
        i ++;
      }
#line 9635
      align_init();
#line 9637
      findunlap(-1);
#line 9638
      moveable_cells = 0;
#line 9639
      cell___0 = 1;
#line 9639
      while (cell___0 <= numcells) {
#line 9640
        if ((int )(*(carray + cell___0))->cclass < 0) {
          goto __Cont;
        }
#line 9643
        moveable_cells ++;
        __Cont: /* CIL Label */ 
#line 9639
        cell___0 ++;
      }
#line 9645
      globe();
#line 9646
      globroute();
#line 9647
      if (cswaps) {
#line 9648
        ugpair();
      }
#line 9650
      findrchk();
#line 9651
      fprintf(fpo, "\nFINAL NUMBER OF ROUTING TRACKS: %d\n\n", tracks);
#line 9653
      i = 1;
#line 9653
      while (i <= numChans) {
#line 9654
        fprintf(fpo, "MAX OF CHANNEL:%3d  is: %3d\n", i, *(maxTrack + i));
#line 9653
        i ++;
      }
#line 9657
      mergplist();
#line 9658
      outpins();
#line 9659
      output();
#line 9660
      safe_free(pinlist);
    } else {
#line 9662
      reassign();
#line 9663
      findunlap(1);
#line 9664
      output();
    }
  }
#line 9667
  fprintf(fpo, "Number of Feed Thrus: %d\n", ffeeds);
#line 9668
  fprintf(fpo, "Number of Implicit Feed Thrus: %d\n", impcount);
#line 9669
  fprintf(fpo, "\nStatistics:\n");
#line 9670
  fprintf(fpo, "Number of Standard Cells: %d\n", numcells - fdthrus);
#line 9672
  fprintf(fpo, "Number of Pads: %d \n", numterms);
#line 9673
  fprintf(fpo, "Number of Nets: %d \n", numnets);
#line 9674
  fprintf(fpo, "Number of Pins: %d \n", maxterm);
#line 9675
  print_stats(fpo);
#line 9676
  fclose(fpo);
#line 9677
  exit(0);
}
}
#line 9688 "D:/a/test/300.c"
TEMPMERG *tmp_pinlist  ;
#line 9693 "D:/a/test/300.c"
int pinGroup  ;
#line 9694 "D:/a/test/300.c"
int *merge_array  ;
#line 9695 "D:/a/test/300.c"
int array_length  ;
#line 9737
int assign_group_values(void) ;
#line 9738
int initialize_pins(void) ;
#line 9741
int merge_pins(int segment ) ;
#line 9696 "D:/a/test/300.c"
int mergplist(void) 
{ int segment ;
  int i ;
  int current_net ;
  int chan ;
  int track ;
  int terminal___0 ;
  DENSITYPTR denptr ;
  DENSITYPTR temptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 9701
  chan = 1;
#line 9701
  while (chan <= numChans) {
#line 9702
    track = 0;
#line 9702
    while (track <= max_tdensity + 100) {
#line 9703
      denptr = (*(*(DboxHead + chan) + track))->next;
#line 9704
      while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 9705
        temptr = denptr->next;
#line 9706
        safe_free(denptr->grdptr);
#line 9707
        safe_cfree(denptr);
#line 9708
        denptr = temptr;
      }
#line 9710
      safe_cfree(*(*(DboxHead + chan) + track));
#line 9702
      track ++;
    }
#line 9712
    safe_cfree(*(DboxHead + chan));
#line 9701
    chan ++;
  }
#line 9714
  safe_cfree(DboxHead);
#line 9715
  terminal___0 = 1;
#line 9715
  while (terminal___0 <= maxterm + 2 * numChans) {
#line 9716
    safe_free(*(Tgrid + terminal___0));
#line 9715
    terminal___0 ++;
  }
#line 9718
  safe_free(Tgrid);
#line 9719
  pinGroup = 0;
#line 9720
  tmp = (int )safe_malloc((unsigned int )(maxterm + 1) * sizeof(int ));
#line 9720
  pinlist = (int *)tmp;
#line 9721
  i = 1;
#line 9721
  while (i <= maxterm) {
#line 9722
    *(pinlist + i) = 0;
#line 9721
    i ++;
  }
#line 9724
  tmp___0 = (int )safe_malloc(100U * sizeof(int ));
#line 9724
  merge_array = (int *)tmp___0;
#line 9725
  *(merge_array + 0) = 0;
#line 9726
  tmp___1 = (int )safe_malloc(100U * sizeof(TEMPMERG ));
#line 9726
  tmp_pinlist = (TEMPMERG *)tmp___1;
#line 9727
  i = 0;
#line 9727
  while (i < 100) {
#line 9728
    (tmp_pinlist + i)->value = 0;
#line 9729
    (tmp_pinlist + i)->next = 0;
#line 9730
    (tmp_pinlist + i)->first = i;
#line 9727
    i ++;
  }
#line 9732
  array_length = 100;
#line 9733
  current_net = (aNetSeg + 1)->net;
#line 9734
  segment = 1;
#line 9734
  while (segment <= numSegs + 1) {
#line 9735
    if (segment <= numSegs) {
#line 9736
      if ((aNetSeg + segment)->net != current_net) {
#line 9737
        assign_group_values();
#line 9738
        initialize_pins();
#line 9739
        current_net = (aNetSeg + segment)->net;
      }
#line 9741
      merge_pins(segment);
    } else {
#line 9743
      assign_group_values();
    }
#line 9734
    segment ++;
  }
#line 9746
  return 0;
}
}
#line 9748 "D:/a/test/300.c"
int initialize_pins(void) 
{ int i ;

  {
#line 9751
  i = 1;
#line 9751
  while (i <= *(merge_array + 0)) {
#line 9752
    (tmp_pinlist + i)->value = 0;
#line 9753
    (tmp_pinlist + i)->next = 0;
#line 9754
    (tmp_pinlist + i)->first = i;
#line 9751
    i ++;
  }
#line 9756
  *(merge_array + 0) = 0;
#line 9757
  return 0;
}
}
#line 9759 "D:/a/test/300.c"
int add_pins(int pin ) 
{ int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 9763
  i = 1;
#line 9763
  while (i <= *(merge_array + 0)) {
#line 9764
    if (pin == *(merge_array + i)) {
#line 9765
      return (i);
    }
#line 9763
    i ++;
  }
#line 9768
  (*(merge_array + 0)) ++;
#line 9768
  if (*(merge_array + 0) >= array_length) {
#line 9769
    array_length += 100;
#line 9770
    tmp = (int )safe_realloc(merge_array, (unsigned int )array_length * sizeof(int ));
#line 9770
    merge_array = (int *)tmp;
#line 9772
    tmp___0 = (int )safe_realloc(tmp_pinlist, (unsigned int )array_length * sizeof(TEMPMERG ));
#line 9772
    tmp_pinlist = (TEMPMERG *)tmp___0;
#line 9774
    i = *(merge_array + 0);
#line 9774
    while (i < *(merge_array + 0) + 100) {
#line 9775
      (tmp_pinlist + i)->value = 0;
#line 9776
      (tmp_pinlist + i)->next = 0;
#line 9777
      (tmp_pinlist + i)->first = i;
#line 9774
      i ++;
    }
  }
#line 9780
  *(merge_array + *(merge_array + 0)) = pin;
#line 9781
  return (*(merge_array + 0));
}
}
#line 9783 "D:/a/test/300.c"
int assign_group_values(void) 
{ int i ;

  {
#line 9786
  i = 1;
#line 9786
  while (i <= *(merge_array + 0)) {
#line 9787
    *(pinlist + *(merge_array + i)) = (tmp_pinlist + i)->value;
#line 9786
    i ++;
  }
#line 9789
  return 0;
}
}
#line 9807
int merge(int i , int j ) ;
#line 9791 "D:/a/test/300.c"
int merge_pins(int segment ) 
{ SEGBOXPTR boxptr___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 9795
  if ((int )(aNetSeg + segment)->key != 0) {
#line 9796
    (aNetSeg + segment)->current = (aNetSeg + (aNetSeg + segment)->key)->current;
  }
#line 9798
  if ((int )(aNetSeg + segment)->current == 0) {
#line 9799
    boxptr___0 = (aNetSeg + segment)->top;
  } else {
#line 9801
    boxptr___0 = (aNetSeg + segment)->bot;
  }
#line 9803
  if (boxptr___0->pin1 != boxptr___0->pin2) {
#line 9803
    if (*(pinlist + boxptr___0->pin1) != *(pinlist + boxptr___0->pin2)) {
#line 9807
      tmp = add_pins(boxptr___0->pin2);
#line 9807
      tmp___0 = add_pins(boxptr___0->pin1);
#line 9807
      merge(tmp___0, tmp);
    } else {
#line 9803
      if (*(pinlist + boxptr___0->pin1) == 0) {
#line 9803
        if (*(pinlist + boxptr___0->pin2) == 0) {
#line 9807
          tmp = add_pins(boxptr___0->pin2);
#line 9807
          tmp___0 = add_pins(boxptr___0->pin1);
#line 9807
          merge(tmp___0, tmp);
        }
      }
    }
  }
#line 9809
  return 0;
}
}
#line 9811 "D:/a/test/300.c"
int merge(int i , int j ) 
{ int newval ;
  int next ;
  int first ;
  int secfirst ;

  {
#line 9815
  pinGroup ++;
#line 9815
  newval = pinGroup;
#line 9816
  secfirst = (tmp_pinlist + j)->first;
#line 9817
  first = (tmp_pinlist + i)->first;
#line 9818
  next = secfirst;
#line 9819
  while (1) {
#line 9820
    (tmp_pinlist + next)->value = newval;
#line 9821
    (tmp_pinlist + next)->first = first;
#line 9822
    next = (tmp_pinlist + next)->next;
#line 9819
    if (! (next != 0)) {
#line 9819
      break;
    }
  }
#line 9824
  next = first;
#line 9825
  while (1) {
#line 9826
    (tmp_pinlist + next)->value = newval;
#line 9827
    if ((tmp_pinlist + next)->next != 0) {
#line 9828
      next = (tmp_pinlist + next)->next;
    } else {
#line 9830
      (tmp_pinlist + next)->next = secfirst;
#line 9831
      break;
    }
  }
#line 9834
  return 0;
}
}
#line 9848 "D:/a/test/300.c"
static MTMY *mt  =    (MTMY *)((void *)0);
#line 9858
int MTPoint(MTMY *t , int *x , int *y ) ;
#line 9849 "D:/a/test/300.c"
int point(short *x , short *y ) 
{ int xx ;
  int yy ;

  {
#line 9853
  if ((unsigned int )mt == (unsigned int )((MTMY *)((void *)0))) {
#line 9854
    return 0;
  }
#line 9856
  xx = (int )*x;
#line 9857
  yy = (int )*y;
#line 9858
  MTPoint(mt, & xx, & yy);
#line 9859
  *x = (short )xx;
#line 9860
  *y = (short )yy;
#line 9861
  return 0;
}
}
#line 9863 "D:/a/test/300.c"
int rect(short *l , short *b___0 , short *r , short *t ) 
{ short temp ;

  {
#line 9867
  point(l, b___0);
#line 9868
  point(r, t);
#line 9869
  if ((int )*l > (int )*r) {
#line 9870
    temp = *l;
#line 9871
    *l = *r;
#line 9872
    *r = temp;
  }
#line 9874
  if ((int )*b___0 > (int )*t) {
#line 9875
    temp = *b___0;
#line 9876
    *b___0 = *t;
#line 9877
    *t = temp;
  }
#line 9879
  return 0;
}
}
#line 9885
MTMY *MTBegin(void) ;
#line 9887
void MTIdenti(MTMY *t ) ;
#line 9892
int MTM(MTMY *t ) ;
#line 9895
int MTMX(MTMY *t ) ;
#line 9898
int MTRotate(MTMY *t , int x , int y ) ;
#line 9881 "D:/a/test/300.c"
int move(int moveType ) 
{ int tmp ;

  {
#line 9884
  if ((unsigned int )mt == (unsigned int )((MTMY *)((void *)0))) {
#line 9885
    tmp = (int )MTBegin();
#line 9885
    mt = (MTMY *)tmp;
  }
#line 9887
  MTIdenti(mt);
#line 9888
  switch (moveType) {
  case 0: 
#line 9890
  return 0;
  case 1: 
#line 9892
  MTM(mt);
#line 9893
  return 0;
  case 2: 
#line 9895
  MTMX(mt);
#line 9896
  return 0;
  case 3: 
#line 9898
  MTRotate(mt, -1, 0);
#line 9899
  return 0;
  case 4: 
#line 9901
  MTMX(mt);
#line 9902
  MTRotate(mt, 0, 1);
#line 9903
  return 0;
  case 5: 
#line 9905
  MTMX(mt);
#line 9906
  MTRotate(mt, 0, -1);
#line 9907
  return 0;
  case 6: 
#line 9909
  MTRotate(mt, 0, 1);
#line 9910
  return 0;
  case 7: 
#line 9912
  MTRotate(mt, 0, -1);
#line 9913
  return 0;
  }
#line 9915
  return (0);
}
}
#line 9974
static void MTInvert(MTMY *t ) ;
#line 9975 "D:/a/test/300.c"
MTMY *MTBegin(void) 
{ MTMY *t ;
  int tmp ;

  {
#line 9978
  tmp = (int )safe_malloc(sizeof(MTMY ));
#line 9978
  t = (MTMY *)tmp;
#line 9978
  if ((unsigned int )t == (unsigned int )((void *)0)) {
#line 9979
    return ((MTMY *)((void *)0));
  }
#line 9980
  t->sp = 0;
#line 9981
  MTIdenti(t);
#line 9982
  return (t);
}
}
#line 9984 "D:/a/test/300.c"
int MTEnd(MTMY *t ) 
{ 

  {
#line 9987
  free((void *)t);
#line 9988
  return (0);
}
}
#line 9989 "D:/a/test/300.c"
void MTIdenti(MTMY *t ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 9992
  tmp___3 = 1;
#line 9992
  t->t[2][2] = tmp___3;
#line 9992
  tmp___2 = tmp___3;
#line 9992
  t->t[1][1] = tmp___2;
#line 9992
  tmp___1 = tmp___2;
#line 9992
  t->t[0][0] = tmp___1;
#line 9992
  tmp___0 = tmp___1;
#line 9992
  t->ti[2][2] = tmp___0;
#line 9992
  tmp = tmp___0;
#line 9992
  t->ti[1][1] = tmp;
#line 9992
  t->ti[0][0] = tmp;
#line 9994
  tmp___14 = 0;
#line 9994
  t->ti[2][1] = tmp___14;
#line 9994
  tmp___13 = tmp___14;
#line 9994
  t->ti[2][0] = tmp___13;
#line 9994
  tmp___12 = tmp___13;
#line 9994
  t->ti[1][2] = tmp___12;
#line 9994
  tmp___11 = tmp___12;
#line 9994
  t->ti[0][2] = tmp___11;
#line 9994
  tmp___10 = tmp___11;
#line 9994
  t->ti[1][0] = tmp___10;
#line 9994
  tmp___9 = tmp___10;
#line 9994
  t->ti[0][1] = tmp___9;
#line 9994
  tmp___8 = tmp___9;
#line 9994
  t->t[2][1] = tmp___8;
#line 9994
  tmp___7 = tmp___8;
#line 9994
  t->t[2][0] = tmp___7;
#line 9994
  tmp___6 = tmp___7;
#line 9994
  t->t[1][2] = tmp___6;
#line 9994
  tmp___5 = tmp___6;
#line 9994
  t->t[0][2] = tmp___5;
#line 9994
  tmp___4 = tmp___5;
#line 9994
  t->t[1][0] = tmp___4;
#line 9994
  t->t[0][1] = tmp___4;
#line 9997
  return ;
}
}
#line 9998 "D:/a/test/300.c"
int MTTransl(MTMY *t , int x , int y ) 
{ 

  {
#line 10002
  t->t[2][0] += x;
#line 10003
  t->t[2][1] += y;
#line 10004
  MTInvert(t);
#line 10005
  return (0);
}
}
#line 10006 "D:/a/test/300.c"
int MTM(MTMY *t ) 
{ 

  {
#line 10009
  t->t[0][1] = - t->t[0][1];
#line 10010
  t->t[1][1] = - t->t[1][1];
#line 10011
  t->t[2][1] = - t->t[2][1];
#line 10012
  MTInvert(t);
#line 10013
  return (0);
}
}
#line 10014 "D:/a/test/300.c"
int MTMX(MTMY *t ) 
{ 

  {
#line 10017
  t->t[0][0] = - t->t[0][0];
#line 10018
  t->t[1][0] = - t->t[1][0];
#line 10019
  t->t[2][0] = - t->t[2][0];
#line 10020
  MTInvert(t);
#line 10021
  return (0);
}
}
#line 10022 "D:/a/test/300.c"
int MTRotate(MTMY *t , int x , int y ) 
{ register int i1 ;
  int tmp ;
  int tmp___0 ;
  register int i ;
  register int j ;

  {
#line 10027
  if (x == 0) {
#line 10028
    if (y >= 0) {
#line 10028
      tmp = y;
    } else {
#line 10028
      tmp = - y;
    }
#line 10028
    if (tmp > 1) {
#line 10029
      if (y < 0) {
#line 10030
        y = -1;
      } else {
#line 10031
        y = 1;
      }
    }
  } else {
#line 10032
    if (y == 0) {
#line 10033
      if (x >= 0) {
#line 10033
        tmp___0 = x;
      } else {
#line 10033
        tmp___0 = - x;
      }
#line 10033
      if (tmp___0 > 1) {
#line 10034
        if (x < 0) {
#line 10035
          x = -1;
        } else {
#line 10036
          x = 1;
        }
      }
    }
  }
#line 10037
  if (x == 1) {
#line 10037
    if (y == 0) {
#line 10038
      return 0;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 10039
    if (x == 0) {
#line 10039
      if (y == -1) {
#line 10040
        i1 = t->t[0][0];
#line 10041
        t->t[0][0] = t->t[0][1];
#line 10042
        t->t[0][1] = - i1;
#line 10043
        i1 = t->t[1][0];
#line 10044
        t->t[1][0] = t->t[1][1];
#line 10045
        t->t[1][1] = - i1;
#line 10046
        i1 = t->t[2][0];
#line 10047
        t->t[2][0] = t->t[2][1];
#line 10048
        t->t[2][1] = - i1;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 10049
      if (x == 0) {
#line 10049
        if (y == 1) {
#line 10050
          i1 = t->t[0][0];
#line 10051
          t->t[0][0] = - t->t[0][1];
#line 10052
          t->t[0][1] = i1;
#line 10053
          i1 = t->t[1][0];
#line 10054
          t->t[1][0] = - t->t[1][1];
#line 10055
          t->t[1][1] = i1;
#line 10056
          i1 = t->t[2][0];
#line 10057
          t->t[2][0] = - t->t[2][1];
#line 10058
          t->t[2][1] = i1;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 10059
        if (x == -1) {
#line 10059
          if (y == 0) {
#line 10061
            i = 0;
#line 10061
            while (i < 3) {
#line 10062
              j = 0;
#line 10062
              while (j < 2) {
#line 10063
                t->t[i][j] = - t->t[i][j];
#line 10062
                j ++;
              }
#line 10061
              i ++;
            }
          }
        }
      }
    }
  }
#line 10064
  MTInvert(t);
#line 10065
  return (0);
}
}
#line 10066 "D:/a/test/300.c"
int MTConcat(MTMY *t , int (*a___0)[3] ) 
{ register int i1 ;
  register int i2 ;
  register int i3 ;
  register int i4 ;
  register int i5 ;
  register int i6 ;

  {
#line 10071
  i1 = t->t[0][0] * (*(a___0 + 0))[0] + t->t[0][1] * (*(a___0 + 1))[0];
#line 10073
  i2 = t->t[0][0] * (*(a___0 + 0))[1] + t->t[0][1] * (*(a___0 + 1))[1];
#line 10075
  i3 = t->t[1][0] * (*(a___0 + 0))[0] + t->t[1][1] * (*(a___0 + 1))[0];
#line 10077
  i4 = t->t[1][0] * (*(a___0 + 0))[1] + t->t[1][1] * (*(a___0 + 1))[1];
#line 10079
  i5 = (t->t[2][0] * (*(a___0 + 0))[0] + t->t[2][1] * (*(a___0 + 1))[0]) + (*(a___0 + 2))[0];
#line 10082
  i6 = (t->t[2][0] * (*(a___0 + 0))[1] + t->t[2][1] * (*(a___0 + 1))[1]) + (*(a___0 + 2))[1];
#line 10085
  t->t[0][0] = i1;
#line 10086
  t->t[0][1] = i2;
#line 10087
  t->t[1][0] = i3;
#line 10088
  t->t[1][1] = i4;
#line 10089
  t->t[2][0] = i5;
#line 10090
  t->t[2][1] = i6;
#line 10091
  MTInvert(t);
#line 10092
  return (0);
}
}
#line 10093 "D:/a/test/300.c"
int MTPoint(MTMY *t , int *x , int *y ) 
{ int i1 ;

  {
#line 10098
  i1 = (*x * t->t[0][0] + *y * t->t[1][0]) + t->t[2][0];
#line 10100
  *y = (*x * t->t[0][1] + *y * t->t[1][1]) + t->t[2][1];
#line 10102
  *x = i1;
#line 10103
  return (0);
}
}
#line 10104 "D:/a/test/300.c"
int MTIPoint(MTMY *t , int *x , int *y ) 
{ int i1 ;

  {
#line 10109
  i1 = (*x * t->ti[0][0] + *y * t->ti[1][0]) + t->ti[2][0];
#line 10111
  *y = (*x * t->ti[0][1] + *y * t->ti[1][1]) + t->ti[2][1];
#line 10113
  *x = i1;
#line 10114
  return (0);
}
}
#line 10115 "D:/a/test/300.c"
Bool MTPushP(MTMY *t ) 
{ register int i ;
  register int j ;

  {
#line 10119
  if (t->sp == 100) {
#line 10120
    return ((enum __anonenum_Bool_21 )0);
  }
#line 10121
  i = 0;
#line 10121
  while (i < 3) {
#line 10122
    j = 0;
#line 10122
    while (j < 2) {
#line 10123
      t->stk[t->sp][i][j] = t->t[i][j];
#line 10122
      j ++;
    }
#line 10121
    i ++;
  }
#line 10125
  (t->sp) ++;
#line 10126
  return ((enum __anonenum_Bool_21 )1);
}
}
#line 10128 "D:/a/test/300.c"
Bool MTPopP(MTMY *t ) 
{ register int i ;
  register int j ;

  {
#line 10132
  if (t->sp == 0) {
#line 10133
    return ((enum __anonenum_Bool_21 )0);
  }
#line 10134
  (t->sp) --;
#line 10135
  i = 0;
#line 10135
  while (i < 3) {
#line 10136
    j = 0;
#line 10136
    while (j < 2) {
#line 10137
      t->t[i][j] = t->stk[t->sp][i][j];
#line 10136
      j ++;
    }
#line 10135
    i ++;
  }
#line 10139
  MTInvert(t);
#line 10140
  return ((enum __anonenum_Bool_21 )1);
}
}
#line 10142 "D:/a/test/300.c"
Bool MTPremul(MTMY *t ) 
{ register int i1 ;
  register int i2 ;
  register int i3 ;
  register int i4 ;
  register int i5 ;
  register int i6 ;
  register int sp ;

  {
#line 10146
  if (t->sp == 0) {
#line 10147
    return ((enum __anonenum_Bool_21 )0);
  }
#line 10148
  sp = t->sp - 1;
#line 10149
  i1 = t->t[0][0] * t->stk[sp][0][0] + t->t[0][1] * t->stk[sp][1][0];
#line 10151
  i2 = t->t[0][0] * t->stk[sp][0][1] + t->t[0][1] * t->stk[sp][1][1];
#line 10153
  i3 = t->t[1][0] * t->stk[sp][0][0] + t->t[1][1] * t->stk[sp][1][0];
#line 10155
  i4 = t->t[1][0] * t->stk[sp][0][1] + t->t[1][1] * t->stk[sp][1][1];
#line 10157
  i5 = (t->t[2][0] * t->stk[sp][0][0] + t->t[2][1] * t->stk[sp][1][0]) + t->stk[sp][2][0];
#line 10160
  i6 = (t->t[2][0] * t->stk[sp][0][1] + t->t[2][1] * t->stk[sp][1][1]) + t->stk[sp][2][1];
#line 10163
  t->t[0][0] = i1;
#line 10164
  t->t[0][1] = i2;
#line 10165
  t->t[1][0] = i3;
#line 10166
  t->t[1][1] = i4;
#line 10167
  t->t[2][0] = i5;
#line 10168
  t->t[2][1] = i6;
#line 10169
  MTInvert(t);
#line 10170
  return ((enum __anonenum_Bool_21 )1);
}
}
#line 10177 "D:/a/test/300.c"
static char cif[81]  ;
#line 10172 "D:/a/test/300.c"
Bool MTDecode(MTMY *t , char **s ) 
{ register int a___0 ;
  register int b___0 ;
  register int c ;
  register int d ;
  register int tx ;
  register int ty ;
  Bool tmp ;

  {
#line 10178
  tmp = MTPushP(t);
#line 10178
  if (! tmp) {
#line 10179
    return ((enum __anonenum_Bool_21 )0);
  }
#line 10180
  a___0 = t->t[0][0];
#line 10181
  b___0 = t->t[1][0];
#line 10182
  c = t->t[0][1];
#line 10183
  d = t->t[1][1];
#line 10184
  tx = t->t[2][0];
#line 10185
  ty = t->t[2][1];
#line 10186
  MTIdenti(t);
#line 10187
  if (a___0 == 0) {
#line 10187
    if (b___0 == 1) {
#line 10187
      if (c == 1) {
#line 10187
        if (d == 0) {
#line 10188
          MTMX(t);
#line 10189
          MTRotate(t, 0, -1);
#line 10190
          MTTransl(t, tx, ty);
#line 10191
          if (tx != 0) {
#line 10192
            sprintf(cif, "MX R 0 -1 T %d %d", tx, ty);
          } else {
#line 10191
            if (ty != 0) {
#line 10192
              sprintf(cif, "MX R 0 -1 T %d %d", tx, ty);
            } else {
#line 10193
              sprintf(cif, "MX R 0 -1");
            }
          }
        } else {
          goto _L___19;
        }
      } else {
        goto _L___19;
      }
    } else {
      goto _L___19;
    }
  } else {
    _L___19: /* CIL Label */ 
#line 10194
    if (a___0 == 0) {
#line 10194
      if (b___0 == -1) {
#line 10194
        if (c == -1) {
#line 10194
          if (d == 0) {
#line 10195
            MTMX(t);
#line 10196
            MTRotate(t, 0, 1);
#line 10197
            MTTransl(t, tx, ty);
#line 10198
            if (tx != 0) {
#line 10199
              sprintf(cif, "MX R 0 1 T %d %d", tx, ty);
            } else {
#line 10198
              if (ty != 0) {
#line 10199
                sprintf(cif, "MX R 0 1 T %d %d", tx, ty);
              } else {
#line 10200
                sprintf(cif, "MX R 0 1");
              }
            }
          } else {
            goto _L___16;
          }
        } else {
          goto _L___16;
        }
      } else {
        goto _L___16;
      }
    } else {
      _L___16: /* CIL Label */ 
#line 10201
      if (a___0 == 0) {
#line 10201
        if (b___0 == 1) {
#line 10201
          if (c == -1) {
#line 10201
            if (d == 0) {
#line 10202
              MTRotate(t, 0, -1);
#line 10203
              MTTransl(t, tx, ty);
#line 10204
              if (tx != 0) {
#line 10205
                sprintf(cif, "R 0 -1 T %d %d", tx, ty);
              } else {
#line 10204
                if (ty != 0) {
#line 10205
                  sprintf(cif, "R 0 -1 T %d %d", tx, ty);
                } else {
#line 10206
                  sprintf(cif, "R 0 -1");
                }
              }
            } else {
              goto _L___13;
            }
          } else {
            goto _L___13;
          }
        } else {
          goto _L___13;
        }
      } else {
        _L___13: /* CIL Label */ 
#line 10207
        if (a___0 == 0) {
#line 10207
          if (b___0 == -1) {
#line 10207
            if (c == 1) {
#line 10207
              if (d == 0) {
#line 10208
                MTRotate(t, 0, 1);
#line 10209
                MTTransl(t, tx, ty);
#line 10210
                if (tx != 0) {
#line 10211
                  sprintf(cif, "R 0 1 T %d %d", tx, ty);
                } else {
#line 10210
                  if (ty != 0) {
#line 10211
                    sprintf(cif, "R 0 1 T %d %d", tx, ty);
                  } else {
#line 10212
                    sprintf(cif, "R 0 1");
                  }
                }
              } else {
                goto _L___10;
              }
            } else {
              goto _L___10;
            }
          } else {
            goto _L___10;
          }
        } else {
          _L___10: /* CIL Label */ 
#line 10213
          if (a___0 == 1) {
#line 10213
            if (b___0 == 0) {
#line 10213
              if (c == 0) {
#line 10213
                if (d == 1) {
#line 10214
                  MTTransl(t, tx, ty);
#line 10215
                  if (tx != 0) {
#line 10216
                    sprintf(cif, "T %d %d", tx, ty);
                  } else {
#line 10215
                    if (ty != 0) {
#line 10216
                      sprintf(cif, "T %d %d", tx, ty);
                    } else {
#line 10217
                      cif[0] = (char )'\000';
                    }
                  }
                } else {
                  goto _L___7;
                }
              } else {
                goto _L___7;
              }
            } else {
              goto _L___7;
            }
          } else {
            _L___7: /* CIL Label */ 
#line 10218
            if (a___0 == -1) {
#line 10218
              if (b___0 == 0) {
#line 10218
                if (c == 0) {
#line 10218
                  if (d == -1) {
#line 10219
                    MTRotate(t, -1, 0);
#line 10220
                    MTTransl(t, tx, ty);
#line 10221
                    if (tx != 0) {
#line 10222
                      sprintf(cif, "R -1 0 T %d %d", tx, ty);
                    } else {
#line 10221
                      if (ty != 0) {
#line 10222
                        sprintf(cif, "R -1 0 T %d %d", tx, ty);
                      } else {
#line 10223
                        sprintf(cif, "R -1 0");
                      }
                    }
                  } else {
                    goto _L___4;
                  }
                } else {
                  goto _L___4;
                }
              } else {
                goto _L___4;
              }
            } else {
              _L___4: /* CIL Label */ 
#line 10224
              if (a___0 == -1) {
#line 10224
                if (b___0 == 0) {
#line 10224
                  if (c == 0) {
#line 10224
                    if (d == 1) {
#line 10225
                      MTMX(t);
#line 10226
                      MTTransl(t, tx, ty);
#line 10227
                      if (tx != 0) {
#line 10228
                        sprintf(cif, "MX T %d %d", tx, ty);
                      } else {
#line 10227
                        if (ty != 0) {
#line 10228
                          sprintf(cif, "MX T %d %d", tx, ty);
                        } else {
#line 10229
                          sprintf(cif, "MX");
                        }
                      }
                    } else {
                      goto _L___1;
                    }
                  } else {
                    goto _L___1;
                  }
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
#line 10230
                if (a___0 == 1) {
#line 10230
                  if (b___0 == 0) {
#line 10230
                    if (c == 0) {
#line 10230
                      if (d == -1) {
#line 10231
                        MTM(t);
#line 10232
                        MTTransl(t, tx, ty);
#line 10233
                        if (tx != 0) {
#line 10234
                          sprintf(cif, "MY T %d %d", tx, ty);
                        } else {
#line 10233
                          if (ty != 0) {
#line 10234
                            sprintf(cif, "MY T %d %d", tx, ty);
                          } else {
#line 10235
                            sprintf(cif, "MY");
                          }
                        }
                      } else {
#line 10237
                        MTPopP(t);
#line 10238
                        return ((enum __anonenum_Bool_21 )0);
                      }
                    } else {
#line 10237
                      MTPopP(t);
#line 10238
                      return ((enum __anonenum_Bool_21 )0);
                    }
                  } else {
#line 10237
                    MTPopP(t);
#line 10238
                    return ((enum __anonenum_Bool_21 )0);
                  }
                } else {
#line 10237
                  MTPopP(t);
#line 10238
                  return ((enum __anonenum_Bool_21 )0);
                }
              }
            }
          }
        }
      }
    }
  }
#line 10239
  if (t->t[0][0] == a___0) {
#line 10239
    if (t->t[0][1] == c) {
#line 10239
      if (t->t[1][0] == b___0) {
#line 10239
        if (t->t[1][1] == d) {
#line 10241
          MTPopP(t);
#line 10242
          *s = cif;
#line 10243
          return ((enum __anonenum_Bool_21 )1);
        } else {
#line 10245
          MTPopP(t);
#line 10246
          return ((enum __anonenum_Bool_21 )0);
        }
      } else {
#line 10245
        MTPopP(t);
#line 10246
        return ((enum __anonenum_Bool_21 )0);
      }
    } else {
#line 10245
      MTPopP(t);
#line 10246
      return ((enum __anonenum_Bool_21 )0);
    }
  } else {
#line 10245
    MTPopP(t);
#line 10246
    return ((enum __anonenum_Bool_21 )0);
  }
}
}
#line 10248 "D:/a/test/300.c"
static void MTInvert(MTMY *t ) 
{ int tmp ;

  {
#line 10251
  t->ti[0][0] = t->t[0][0];
#line 10252
  t->ti[0][1] = t->t[1][0];
#line 10253
  t->ti[1][0] = t->t[0][1];
#line 10254
  t->ti[1][1] = t->t[1][1];
#line 10255
  t->ti[2][0] = - t->t[2][0] * t->t[0][0] - t->t[2][1] * t->t[0][1];
#line 10256
  t->ti[2][1] = - t->t[2][0] * t->t[1][0] - t->t[2][1] * t->t[1][1];
#line 10257
  tmp = 0;
#line 10257
  t->ti[1][2] = tmp;
#line 10257
  t->ti[0][2] = tmp;
#line 10258
  t->ti[2][2] = 1;
#line 10259
  return ;
}
}
#line 10272
int cleanupHandler(int status , char *function ) ;
#line 10266 "D:/a/test/300.c"
char *safe_malloc(unsigned int size ) 
{ char *p ;
  void *tmp ;

  {
#line 10271
  tmp = malloc(size);
#line 10271
  p = (char *)tmp;
#line 10271
  if ((unsigned int )p == (unsigned int )((char *)0)) {
#line 10272
    cleanupHandler(1074135042, "safe_malloc");
  }
#line 10274
  return (p);
}
}
#line 10276 "D:/a/test/300.c"
char *safe_realloc(char *obj , unsigned int size ) 
{ char *p ;
  void *tmp ;

  {
#line 10282
  tmp = realloc((void *)obj, size);
#line 10282
  p = (char *)tmp;
#line 10282
  if ((unsigned int )p == (unsigned int )((char *)0)) {
#line 10283
    cleanupHandler(1074135042, "safe_realloc");
  }
#line 10285
  return (p);
}
}
#line 10287 "D:/a/test/300.c"
char *safe_calloc(unsigned int size , unsigned int num ) 
{ char *p ;
  void *tmp ;

  {
#line 10292
  tmp = calloc(size, num);
#line 10292
  p = (char *)tmp;
#line 10292
  if ((unsigned int )p == (unsigned int )((char *)0)) {
#line 10293
    cleanupHandler(1074135042, "safe_calloc");
  }
#line 10295
  return (p);
}
}
#line 10297 "D:/a/test/300.c"
int safe_free(char *ptr ) 
{ 

  {
#line 10300
  free((void *)ptr);
#line 10301
  return 0;
}
}
#line 10307
extern int ( /* missing proto */  cfree)(char *p) ;
#line 10303 "D:/a/test/300.c"
int safe_cfree(char *ptr ) 
{ 

  {
#line 10307
  cfree(ptr);
#line 10309
  return 0;
}
}
#line 10311 "D:/a/test/300.c"
int cleanup(int sigNum ) 
{ 

  {
#line 10314
  cleanupHandler(- sigNum, (void *)0);
#line 10315
  return (0);
}
}
#line 10316 "D:/a/test/300.c"
int cleanupHandler(int status , char *function ) 
{ 

  {
#line 10320
  exit(1);
}
}
#line 10324 "D:/a/test/300.c"
int outcm(void) 
{ char filename[64] ;
  FILE *fp ;
  NBOXPTR netptr ;
  int net ;
  int x ;
  int local_pin_count ;
  int pin_count ;
  int cell___0 ;
  int row___0 ;
  int length ;
  int xstart ;
  int tmp ;

  {
#line 10331
  sprintf(filename, "%s.cm", cktName);
#line 10332
  tmp = (int )openFile(filename, "w", 1);
#line 10332
  fp = (FILE *)tmp;
#line 10333
  pin_count = 0;
#line 10334
  net = 1;
#line 10334
  while (net <= numnets) {
#line 10335
    local_pin_count = 0;
#line 10336
    netptr = (*(netarray + net))->netptr;
#line 10336
    while (netptr) {
#line 10337
      if ((int )netptr->cell <= numcells) {
#line 10338
        local_pin_count ++;
      }
#line 10336
      netptr = netptr->nterm;
    }
#line 10341
    if (local_pin_count > 1) {
#line 10342
      pin_count += local_pin_count;
    }
#line 10334
    net ++;
  }
#line 10345
  fprintf(fp, "%d\n", pin_count);
#line 10346
  net = 1;
#line 10346
  while (net <= numnets) {
#line 10347
    local_pin_count = 0;
#line 10348
    netptr = (*(netarray + net))->netptr;
#line 10348
    while (netptr) {
#line 10349
      if ((int )netptr->cell <= numcells) {
#line 10350
        local_pin_count ++;
      }
#line 10348
      netptr = netptr->nterm;
    }
#line 10353
    if (local_pin_count <= 1) {
      goto __Cont;
    }
#line 10356
    netptr = (*(netarray + net))->netptr;
#line 10356
    while (netptr) {
#line 10357
      if ((int )netptr->cell > numcells) {
        goto __Cont___0;
      }
#line 10360
      cell___0 = (int )netptr->cell;
#line 10361
      row___0 = (int )(*(carray + cell___0))->cblock;
#line 10362
      x = netptr->xpos;
#line 10363
      length = (int )((*(carray + cell___0))->tileptr)->right - (int )((*(carray + cell___0))->tileptr)->left;
#line 10365
      xstart = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->left;
#line 10366
      fprintf(fp, "%8d %8d %8d %8d %8d %8d\n", row___0, cell___0, net, x, length,
              xstart);
      __Cont___0: /* CIL Label */ 
#line 10356
      netptr = netptr->nterm;
    }
    __Cont: /* CIL Label */ 
#line 10346
    net ++;
  }
#line 10370
  fclose(fp);
#line 10371
  return 0;
}
}
#line 10491
int min_l_chan_edge(int channel ) ;
#line 10563
int min_r_chan_edge(int channel ) ;
#line 10380 "D:/a/test/300.c"
int outpins(void) 
{ char filename[64] ;
  FILE *fp ;
  NBOXPTR netptr ;
  SEGBOXPTR sptr ;
  int net ;
  int b___0 ;
  int e ;
  int seg ;
  int x ;
  int y ;
  int pin ;
  int pinloc ;
  int chan ;
  int xx ;
  int chan1 ;
  int chan2 ;
  int r_core_edge ;
  int l_core_edge ;
  int l_end ;
  int r_end ;
  int cell___0 ;
  int blk___0 ;
  int pin2_1 ;
  int pin2_2 ;
  int tmp ;

  {
#line 10390
  sprintf(filename, "%s.pin", cktName);
#line 10391
  tmp = (int )openFile(filename, "w", 1);
#line 10391
  fp = (FILE *)tmp;
#line 10392
  r_core_edge = 0;
#line 10393
  l_core_edge = 32000;
#line 10394
  blk___0 = 1;
#line 10394
  while (blk___0 <= numblock) {
#line 10395
    cell___0 = *(*(pairArray + blk___0) + *(*(pairArray + blk___0) + 0));
#line 10396
    r_end = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->right;
#line 10397
    cell___0 = *(*(pairArray + blk___0) + 1);
#line 10398
    l_end = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->left;
#line 10399
    if (r_end > r_core_edge) {
#line 10400
      r_core_edge = r_end;
    }
#line 10402
    if (l_end < l_core_edge) {
#line 10403
      l_core_edge = l_end;
    }
#line 10394
    blk___0 ++;
  }
#line 10406
  net = 1;
#line 10406
  while (net <= numnets) {
#line 10407
    netptr = (*(netarray + net))->netptr;
#line 10408
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 10409
      pin = netptr->terminal;
#line 10410
      if (*(pinlist + pin) == 0) {
        goto __Cont;
      }
#line 10413
      pinloc = - ((int )netptr->pinloc);
#line 10414
      x = netptr->xpos;
#line 10415
      y = netptr->ypos;
#line 10416
      b___0 = *(anet + net);
#line 10417
      e = *(anet + (net + 1)) - 1;
#line 10419
      chan1 = -10;
#line 10420
      chan2 = -10;
#line 10421
      seg = b___0;
#line 10421
      while (seg <= e) {
#line 10422
        if ((int )(aNetSeg + seg)->current == 0) {
#line 10423
          sptr = (aNetSeg + seg)->top;
        } else {
#line 10425
          sptr = (aNetSeg + seg)->bot;
        }
#line 10427
        if (pin == sptr->pin1) {
          goto _L;
        } else {
#line 10427
          if (pin == sptr->pin2) {
            _L: /* CIL Label */ 
#line 10428
            chan = (int )sptr->channel;
#line 10429
            if (chan1 < 0) {
#line 10430
              chan1 = chan;
#line 10431
              if (pin == sptr->pin1) {
#line 10432
                pin2_1 = sptr->pin2;
              } else {
#line 10434
                pin2_1 = sptr->pin1;
              }
            } else {
#line 10436
              if (chan1 == chan) {
                goto __Cont___0;
              } else {
#line 10438
                if (chan2 < 0) {
#line 10439
                  chan2 = chan;
#line 10440
                  if (pin == sptr->pin1) {
#line 10441
                    pin2_2 = sptr->pin2;
                  } else {
#line 10443
                    pin2_2 = sptr->pin1;
                  }
#line 10445
                  break;
                }
              }
            }
          }
        }
        __Cont___0: /* CIL Label */ 
#line 10421
        seg ++;
      }
#line 10449
      if ((int )netptr->cell <= numcells) {
#line 10449
        if (pinloc != 0) {
          goto _L___4;
        } else {
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
#line 10449
        if ((int )netptr->cell > numcells) {
#line 10449
          if ((int )(*(carray + netptr->cell))->padside == 2) {
            goto _L___4;
          } else {
#line 10449
            if ((int )(*(carray + netptr->cell))->padside == 4) {
              goto _L___4;
            } else {
#line 10449
              if ((int )(*(carray + netptr->cell))->padside == 14) {
                goto _L___4;
              } else {
#line 10449
                if ((int )(*(carray + netptr->cell))->padside == 15) {
                  _L___4: /* CIL Label */ 
#line 10455
                  if ((int )netptr->cell > numcells) {
#line 10456
                    if ((int )(*(carray + netptr->cell))->padside == 2) {
#line 10458
                      fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                              *(pinlist + pin), (*(carray + netptr->cell))->cname,
                              *(pinnames + pin), x, y, chan1, 1);
                    } else {
#line 10456
                      if ((int )(*(carray + netptr->cell))->padside == 14) {
#line 10458
                        fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                                *(pinlist + pin), (*(carray + netptr->cell))->cname,
                                *(pinnames + pin), x, y, chan1, 1);
                      } else {
#line 10462
                        if ((int )(*(carray + netptr->cell))->padside == 4) {
#line 10464
                          fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                                  *(pinlist + pin), (*(carray + netptr->cell))->cname,
                                  *(pinnames + pin), x, y, chan1, -1);
                        } else {
#line 10462
                          if ((int )(*(carray + netptr->cell))->padside == 15) {
#line 10464
                            fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                                    *(pinlist + pin), (*(carray + netptr->cell))->cname,
                                    *(pinnames + pin), x, y, chan1, -1);
                          }
                        }
                      }
                    }
                  } else {
#line 10470
                    fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                            *(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
                            x, y, chan1, pinloc);
                  }
                } else {
                  goto _L___3;
                }
              }
            }
          }
        } else {
          _L___3: /* CIL Label */ 
#line 10475
          if ((int )netptr->cell > numcells) {
#line 10476
            if ((int )(*(carray + netptr->cell))->padside == 1) {
              goto _L___1;
            } else {
#line 10476
              if ((int )(*(carray + netptr->cell))->padside == 5) {
                goto _L___1;
              } else {
#line 10476
                if ((int )(*(carray + netptr->cell))->padside == 9) {
                  goto _L___1;
                } else {
#line 10476
                  if ((int )(*(carray + netptr->cell))->padside == 7) {
                    _L___1: /* CIL Label */ 
#line 10480
                    fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                            *(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
                            x, y, -1, 1);
#line 10484
                    if ((int )(*(carray + (*(tearray + pin2_1))->cell))->padside != 1) {
#line 10484
                      if ((int )(*(carray + (*(tearray + pin2_1))->cell))->padside != 5) {
#line 10484
                        if ((int )(*(carray + (*(tearray + pin2_1))->cell))->padside != 9) {
#line 10484
                          if ((int )(*(carray + (*(tearray + pin2_1))->cell))->padside != 7) {
#line 10488
                            if ((int )(*(carray + netptr->cell))->padside == 1) {
#line 10489
                              xx = l_core_edge;
                            } else {
#line 10491
                              xx = min_l_chan_edge(chan1);
#line 10492
                              if ((*(tearray + pin2_1))->xpos < xx) {
#line 10493
                                xx = x;
                              }
                            }
#line 10496
                            if ((int )netptr->row == chan1) {
#line 10497
                              y = (*(barray + netptr->row))->bycenter - rowHeight;
                            } else {
#line 10500
                              y = (*(barray + netptr->row))->bycenter + rowHeight;
                            }
#line 10503
                            fprintf(fp, " %s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                                    *(pinlist + pin), "PSEUDO_CELL", "PSEUDO_PIN",
                                    xx, y, chan1, -2);
#line 10507
                            fprintf(fp, " %s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                                    *(pinlist + pin), "PSEUDO_CELL", "PSEUDO_PIN",
                                    xx, y, -1, -1);
#line 10511
                            if (chan2 > 0) {
#line 10512
                              if ((int )(*(carray + (*(tearray + pin2_2))->cell))->padside != 1) {
#line 10512
                                if ((int )(*(carray + (*(tearray + pin2_2))->cell))->padside != 5) {
#line 10512
                                  if ((int )(*(carray + (*(tearray + pin2_2))->cell))->padside != 9) {
#line 10512
                                    if ((int )(*(carray + (*(tearray + pin2_2))->cell))->padside != 7) {
#line 10520
                                      if ((int )(*(carray + netptr->cell))->padside == 1) {
#line 10521
                                        xx = l_core_edge;
                                      } else {
#line 10523
                                        xx = min_l_chan_edge(chan2);
#line 10524
                                        if ((*(tearray + pin2_2))->xpos < xx) {
#line 10525
                                          xx = x;
                                        }
                                      }
#line 10528
                                      if ((int )netptr->row == chan2) {
#line 10529
                                        y = (*(barray + netptr->row))->bycenter - rowHeight;
                                      } else {
#line 10532
                                        y = (*(barray + netptr->row))->bycenter + rowHeight;
                                      }
#line 10535
                                      fprintf(fp, " %s %d %s %s %d %d %d %d 0\n",
                                              (*(netarray + net))->name, *(pinlist + pin),
                                              "PSEUDO_CELL", "PSEUDO_PIN", xx, y,
                                              chan2, -2);
#line 10540
                                      fprintf(fp, " %s %d %s %s %d %d %d %d 0\n",
                                              (*(netarray + net))->name, *(pinlist + pin),
                                              "PSEUDO_CELL", "PSEUDO_PIN", xx, y,
                                              -1, -1);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
#line 10548
                    if ((int )(*(carray + netptr->cell))->padside == 3) {
                      goto _L___0;
                    } else {
#line 10548
                      if ((int )(*(carray + netptr->cell))->padside == 6) {
                        goto _L___0;
                      } else {
#line 10548
                        if ((int )(*(carray + netptr->cell))->padside == 10) {
                          goto _L___0;
                        } else {
#line 10548
                          if ((int )(*(carray + netptr->cell))->padside == 8) {
                            _L___0: /* CIL Label */ 
#line 10552
                            fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                                    *(pinlist + pin), (*(carray + netptr->cell))->cname,
                                    *(pinnames + pin), x, y, -2, 1);
#line 10556
                            if ((int )(*(carray + (*(tearray + pin2_1))->cell))->padside != 3) {
#line 10556
                              if ((int )(*(carray + (*(tearray + pin2_1))->cell))->padside != 6) {
#line 10556
                                if ((int )(*(carray + (*(tearray + pin2_1))->cell))->padside != 10) {
#line 10556
                                  if ((int )(*(carray + (*(tearray + pin2_1))->cell))->padside != 8) {
#line 10560
                                    if ((int )(*(carray + netptr->cell))->padside == 3) {
#line 10561
                                      xx = r_core_edge;
                                    } else {
#line 10563
                                      xx = min_r_chan_edge(chan1);
#line 10564
                                      if ((*(tearray + pin2_1))->xpos > xx) {
#line 10565
                                        xx = x;
                                      }
                                    }
#line 10568
                                    if ((int )netptr->row == chan1) {
#line 10569
                                      y = (*(barray + netptr->row))->bycenter - rowHeight;
                                    } else {
#line 10572
                                      y = (*(barray + netptr->row))->bycenter + rowHeight;
                                    }
#line 10575
                                    fprintf(fp, " %s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                                            *(pinlist + pin), "PSEUDO_CELL", "PSEUDO_PIN",
                                            xx, y, chan1, 2);
#line 10579
                                    fprintf(fp, " %s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                                            *(pinlist + pin), "PSEUDO_CELL", "PSEUDO_PIN",
                                            xx, y, -2, -1);
#line 10583
                                    if (chan2 > 0) {
#line 10584
                                      if ((int )(*(carray + (*(tearray + pin2_2))->cell))->padside != 3) {
#line 10584
                                        if ((int )(*(carray + (*(tearray + pin2_2))->cell))->padside != 6) {
#line 10584
                                          if ((int )(*(carray + (*(tearray + pin2_2))->cell))->padside != 10) {
#line 10584
                                            if ((int )(*(carray + (*(tearray + pin2_2))->cell))->padside != 8) {
#line 10592
                                              if ((int )(*(carray + netptr->cell))->padside == 3) {
#line 10593
                                                xx = r_core_edge;
                                              } else {
#line 10595
                                                xx = min_r_chan_edge(chan2);
#line 10596
                                                if ((*(tearray + pin2_2))->xpos > xx) {
#line 10597
                                                  xx = x;
                                                }
                                              }
#line 10600
                                              if ((int )netptr->row == chan2) {
#line 10601
                                                y = (*(barray + netptr->row))->bycenter - rowHeight;
                                              } else {
#line 10604
                                                y = (*(barray + netptr->row))->bycenter + rowHeight;
                                              }
#line 10607
                                              fprintf(fp, " %s %d %s %s %d %d %d %d 0\n",
                                                      (*(netarray + net))->name, *(pinlist + pin),
                                                      "PSEUDO_CELL", "PSEUDO_PIN",
                                                      xx, y, chan2, 2);
#line 10612
                                              fprintf(fp, " %s %d %s %s %d %d %d %d 0\n",
                                                      (*(netarray + net))->name, *(pinlist + pin),
                                                      "PSEUDO_CELL", "PSEUDO_PIN",
                                                      xx, y, -2, -1);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
#line 10622
            if (chan1 == (int )netptr->row) {
#line 10623
              fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                      *(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
                      x, y, chan1, 1);
            } else {
#line 10630
              fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                      *(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
                      x, y, chan1, -1);
            }
#line 10637
            if (chan2 > 0) {
#line 10638
              if (chan2 == (int )netptr->row) {
#line 10639
                fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                        *(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
                        x, y, chan2, 1);
              } else {
#line 10646
                fprintf(fp, "%s %d %s %s %d %d %d %d 0\n", (*(netarray + net))->name,
                        *(pinlist + pin), (*(carray + netptr->cell))->cname, *(pinnames + pin),
                        x, y, chan2, -1);
              }
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 10408
      netptr = netptr->nterm;
    }
#line 10406
    net ++;
  }
#line 10657
  fclose(fp);
#line 10658
  return 0;
}
}
#line 10660 "D:/a/test/300.c"
int min_r_chan_edge(int channel ) 
{ int cell___0 ;
  int end ;
  int end2 ;

  {
#line 10664
  if (channel == 1) {
#line 10665
    cell___0 = *(*(pairArray + 1) + *(*(pairArray + 1) + 0));
#line 10666
    end = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->right;
  } else {
#line 10667
    if (channel == numblock + 1) {
#line 10668
      cell___0 = *(*(pairArray + numblock) + *(*(pairArray + numblock) + 0));
#line 10669
      end = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->right;
    } else {
#line 10671
      cell___0 = *(*(pairArray + (channel - 1)) + *(*(pairArray + (channel - 1)) + 0));
#line 10672
      end = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->right;
#line 10673
      cell___0 = *(*(pairArray + channel) + *(*(pairArray + channel) + 0));
#line 10674
      end2 = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->right;
#line 10675
      if (end < end2) {
#line 10675
        end = end;
      } else {
#line 10675
        end = end2;
      }
    }
  }
#line 10677
  return (end);
}
}
#line 10679 "D:/a/test/300.c"
int min_l_chan_edge(int channel ) 
{ int cell___0 ;
  int end ;
  int end2 ;

  {
#line 10683
  if (channel == 1) {
#line 10684
    cell___0 = *(*(pairArray + 1) + 1);
#line 10685
    end = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->left;
  } else {
#line 10686
    if (channel == numblock + 1) {
#line 10687
      cell___0 = *(*(pairArray + numblock) + 1);
#line 10688
      end = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->left;
    } else {
#line 10690
      cell___0 = *(*(pairArray + (channel - 1)) + 1);
#line 10691
      end = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->left;
#line 10692
      cell___0 = *(*(pairArray + channel) + 1);
#line 10693
      end2 = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->left;
#line 10694
      if (end > end2) {
#line 10694
        end = end;
      } else {
#line 10694
        end = end2;
      }
    }
  }
#line 10696
  return (end);
}
}
#line 10700
int comparex(int *a___0 , int *b___0 ) ;
#line 10706 "D:/a/test/300.c"
int output(void) 
{ FILE *fpp1 ;
  FILE *fpp2 ;
  int locx ;
  int locy ;
  int height___0 ;
  int width___0 ;
  int xloc ;
  int i ;
  int cell___0 ;
  int block___0 ;
  int orient ;
  int num ;
  int xloc2 ;
  int yloc2 ;
  int yloc ;
  int *array ;
  int desire ;
  int left___0 ;
  int right ;
  int bottom ;
  int top___0 ;
  int end ;
  char filename[64] ;
  CBOXPTR cellptr___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 10717
  sprintf(filename, "%s.pl1", cktName);
#line 10718
  tmp = (int )openFile(filename, "w", 1);
#line 10718
  fpp1 = (FILE *)tmp;
#line 10719
  sprintf(filename, "%s.pl2", cktName);
#line 10720
  tmp___0 = (int )openFile(filename, "w", 1);
#line 10720
  fpp2 = (FILE *)tmp___0;
#line 10721
  block___0 = 1;
#line 10721
  while (block___0 <= numblock) {
#line 10722
    left___0 = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bleft;
#line 10723
    right = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bright;
#line 10724
    bottom = (*(barray + block___0))->bycenter + (int )(*(barray + block___0))->bbottom;
#line 10725
    top___0 = (*(barray + block___0))->bycenter + (int )(*(barray + block___0))->btop;
#line 10726
    if (restart == 0) {
#line 10726
      if (costonly == 1) {
#line 10727
        desire = (int )(*(barray + block___0))->desire;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 10729
      if (*(*(pairArray + block___0) + 0) > 0) {
#line 10730
        cell___0 = *(*(pairArray + block___0) + *(*(pairArray + block___0) + 0));
#line 10731
        end = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->right;
#line 10733
        desire = end - left___0;
      } else {
#line 10735
        desire = 0;
      }
    }
#line 10738
    if ((int )(*(barray + block___0))->borient > 0) {
#line 10739
      fprintf(fpp2, "%d %d %d  %d %d  0 0\n", block___0, left___0, bottom, left___0 + desire,
              top___0);
    } else {
#line 10742
      fprintf(fpp2, "%d %d %d  %d %d  0 0\n", block___0, left___0, bottom, right,
              bottom + desire);
    }
#line 10745
    num = *(*(pairArray + block___0) + 0);
#line 10746
    if (num == 0) {
      goto __Cont;
    }
#line 10749
    array = *(pairArray + block___0) + 1;
#line 10750
    i = 0;
#line 10750
    while (i < num) {
#line 10751
      cell___0 = *(array + i);
#line 10752
      cellptr___0 = *(carray + cell___0);
#line 10753
      orient = (int )cellptr___0->corient;
#line 10754
      xloc = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->left;
#line 10755
      yloc = cellptr___0->cycenter + (int )(cellptr___0->tileptr)->bottom;
#line 10756
      xloc2 = (int )(cellptr___0->tileptr)->right - (int )(cellptr___0->tileptr)->left;
#line 10758
      yloc2 = (int )(cellptr___0->tileptr)->top - (int )(cellptr___0->tileptr)->bottom;
#line 10760
      fprintf(fpp1, "%s %d %d  %d %d  %d %d\n", cellptr___0->cname, xloc, yloc, xloc + xloc2,
              yloc + yloc2, orient, block___0);
#line 10750
      i ++;
    }
    __Cont: /* CIL Label */ 
#line 10721
    block___0 ++;
  }
#line 10766
  i = numcells + 1;
#line 10766
  while (i <= numcells + numterms) {
#line 10767
    cellptr___0 = *(carray + i);
#line 10768
    orient = (int )cellptr___0->corient;
#line 10769
    locx = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->left;
#line 10770
    locy = cellptr___0->cycenter + (int )(cellptr___0->tileptr)->bottom;
#line 10771
    height___0 = (int )(cellptr___0->tileptr)->top - (int )(cellptr___0->tileptr)->bottom;
#line 10772
    width___0 = (int )(cellptr___0->tileptr)->right - (int )(cellptr___0->tileptr)->left;
#line 10773
    fprintf(fpp1, "%s %d %d  %d %d  %d 0\n", cellptr___0->cname, locx, locy, locx + width___0,
            locy + height___0, orient);
#line 10776
    fprintf(fpp2, "%s %d %d  %d %d  %d 0\n", cellptr___0->cname, locx, locy, locx + width___0,
            locy + height___0, orient);
#line 10766
    i ++;
  }
#line 10780
  fclose(fpp1);
#line 10781
  fclose(fpp2);
#line 10782
  return 0;
}
}
#line 10784 "D:/a/test/300.c"
int comparex(int *a___0 , int *b___0 ) 
{ 

  {
#line 10787
  return ((*(carray + *a___0))->cxcenter - (*(carray + *b___0))->cxcenter);
}
}
#line 10793 "D:/a/test/300.c"
int purcost(int segment ) 
{ SEGBOXPTR top___0 ;
  SEGBOXPTR bot___0 ;
  SEGBOXPTR asegptr ;
  SEGBOXPTR bsegptr ;
  CHANGRDPTR aptr1 ;
  CHANGRDPTR aptr2 ;
  CHANGRDPTR bptr1 ;
  CHANGRDPTR bptr2 ;
  CHANGRDPTR bptr ;
  CHANGRDPTR fptr ;
  CHANGRDPTR ptr ;
  CHANGRDPTR saptr ;
  CHANGRDPTR eaptr ;
  CHANGRDPTR sbptr ;
  CHANGRDPTR ebptr ;
  DENSITYPTR denptr ;
  DENSITYPTR headptr ;
  int penalty___0 ;
  int current ;
  int check ;
  int x ;
  int achannel ;
  int bchannel ;
  int aMaxVal ;
  int bMaxVal ;
  int maxaa ;
  int maxbb ;
  int aoutside ;
  int binside ;
  int ax1 ;
  int ax2 ;
  int bx1 ;
  int bx2 ;
  int net ;
  int Flag ;
  int track ;

  {
#line 10806
  penalty___0 = 0;
#line 10807
  if ((int )(aNetSeg + segment)->nflag == 0) {
#line 10808
    top___0 = (aNetSeg + segment)->top;
#line 10809
    bot___0 = (aNetSeg + segment)->bot;
#line 10810
    current = (int )(aNetSeg + segment)->current;
  } else {
#line 10812
    top___0 = (aNetSeg + segment)->ntop;
#line 10813
    bot___0 = (aNetSeg + segment)->nbot;
#line 10814
    current = (int )(aNetSeg + segment)->ncurrent;
  }
#line 10816
  if (current == 0) {
#line 10817
    asegptr = top___0;
#line 10818
    bsegptr = bot___0;
  } else {
#line 10820
    asegptr = bot___0;
#line 10821
    bsegptr = top___0;
  }
#line 10823
  achannel = (int )asegptr->channel;
#line 10824
  bchannel = (int )bsegptr->channel;
#line 10825
  aptr1 = asegptr->pin1ptr;
#line 10826
  aptr2 = asegptr->pin2ptr;
#line 10827
  bptr1 = bsegptr->pin1ptr;
#line 10828
  bptr2 = bsegptr->pin2ptr;
#line 10829
  aMaxVal = *(nmaxTrack + achannel);
#line 10830
  bMaxVal = *(nmaxTrack + bchannel);
#line 10831
  ax1 = (aptr1->netptr)->xpos;
#line 10832
  ax2 = (aptr2->netptr)->xpos;
#line 10833
  bx1 = (bptr1->netptr)->xpos;
#line 10834
  bx2 = (bptr2->netptr)->xpos;
#line 10835
  net = (aNetSeg + segment)->net;
#line 10836
  if ((int )aptr1->nSegType > 0) {
#line 10837
    Flag = 0;
#line 10838
    bptr = aptr1;
#line 10839
    while (1) {
#line 10839
      if ((unsigned int )bptr->nprevgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 10839
        if (! (((bptr->nprevgrd)->netptr)->xpos == ax1)) {
#line 10839
          break;
        }
      } else {
#line 10839
        break;
      }
#line 10841
      if (net == (int )(*(tearray + ((bptr->nprevgrd)->netptr)->terminal))->net) {
#line 10841
        if ((int )(bptr->nprevgrd)->nSegType < 0) {
#line 10843
          Flag = 1;
#line 10844
          saptr = aptr1->nnextgrd;
#line 10845
          while ((saptr->netptr)->xpos == ax1) {
#line 10846
            saptr = saptr->nnextgrd;
          }
#line 10848
          break;
        } else {
#line 10850
          bptr = bptr->nprevgrd;
        }
      } else {
#line 10850
        bptr = bptr->nprevgrd;
      }
    }
#line 10853
    if (! Flag) {
#line 10854
      saptr = aptr1->nnextgrd;
#line 10855
      while ((saptr->netptr)->xpos == ax1) {
#line 10856
        if (net == (int )(*(tearray + (saptr->netptr)->terminal))->net) {
#line 10856
          if ((int )saptr->nSegType < 0) {
#line 10858
            Flag = 1;
          }
        }
#line 10860
        saptr = saptr->nnextgrd;
      }
    }
#line 10863
    if (! Flag) {
#line 10864
      saptr = bptr;
    }
  } else {
#line 10867
    if (ax1 != gxstart) {
#line 10868
      saptr = aptr1->nnextgrd;
#line 10869
      while ((saptr->netptr)->xpos == ax1) {
#line 10870
        saptr = saptr->nnextgrd;
      }
    } else {
#line 10873
      saptr = aptr1;
    }
  }
#line 10876
  if ((int )aptr2->nSegType < 0) {
#line 10877
    Flag = 0;
#line 10878
    fptr = aptr2;
#line 10879
    while (1) {
#line 10879
      if ((unsigned int )fptr->nnextgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 10879
        if (! (((fptr->nnextgrd)->netptr)->xpos == ax2)) {
#line 10879
          break;
        }
      } else {
#line 10879
        break;
      }
#line 10881
      if (net == (int )(*(tearray + ((fptr->nnextgrd)->netptr)->terminal))->net) {
#line 10881
        if ((int )(fptr->nnextgrd)->nSegType > 0) {
#line 10883
          Flag = 1;
#line 10884
          eaptr = aptr2->nprevgrd;
#line 10885
          while ((eaptr->netptr)->xpos == ax2) {
#line 10886
            eaptr = eaptr->nprevgrd;
          }
#line 10888
          break;
        } else {
#line 10890
          fptr = fptr->nnextgrd;
        }
      } else {
#line 10890
        fptr = fptr->nnextgrd;
      }
    }
#line 10893
    if (! Flag) {
#line 10894
      eaptr = aptr2->nprevgrd;
#line 10895
      while ((eaptr->netptr)->xpos == ax2) {
#line 10896
        if (net == (int )(*(tearray + (eaptr->netptr)->terminal))->net) {
#line 10896
          if ((int )eaptr->nSegType > 0) {
#line 10898
            Flag = 1;
          }
        }
#line 10900
        eaptr = eaptr->nprevgrd;
      }
    }
#line 10903
    if (! Flag) {
#line 10904
      eaptr = fptr;
    }
  } else {
#line 10907
    if (ax2 != gxstop) {
#line 10908
      eaptr = aptr2->nprevgrd;
#line 10909
      while ((eaptr->netptr)->xpos == ax2) {
#line 10910
        eaptr = eaptr->nprevgrd;
      }
    } else {
#line 10913
      eaptr = aptr2;
    }
  }
#line 10916
  if ((int )bptr1->nSegType >= 0) {
#line 10917
    Flag = 0;
#line 10918
    bptr = bptr1;
#line 10919
    while (1) {
#line 10919
      if ((unsigned int )bptr->nprevgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 10919
        if (! (((bptr->nprevgrd)->netptr)->xpos == bx1)) {
#line 10919
          break;
        }
      } else {
#line 10919
        break;
      }
#line 10921
      if (net == (int )(*(tearray + ((bptr->nprevgrd)->netptr)->terminal))->net) {
#line 10921
        if ((int )(bptr->nprevgrd)->nSegType < 0) {
#line 10923
          Flag = 1;
#line 10924
          sbptr = bptr1->nnextgrd;
#line 10925
          while ((sbptr->netptr)->xpos == bx1) {
#line 10926
            sbptr = sbptr->nnextgrd;
          }
#line 10928
          break;
        } else {
#line 10930
          bptr = bptr->nprevgrd;
        }
      } else {
#line 10930
        bptr = bptr->nprevgrd;
      }
    }
#line 10933
    if (! Flag) {
#line 10934
      sbptr = bptr1->nnextgrd;
#line 10935
      while ((sbptr->netptr)->xpos == bx1) {
#line 10936
        if (net == (int )(*(tearray + (sbptr->netptr)->terminal))->net) {
#line 10936
          if ((int )sbptr->nSegType < 0) {
#line 10938
            Flag = 1;
          }
        }
#line 10940
        sbptr = sbptr->nnextgrd;
      }
    }
#line 10943
    if (! Flag) {
#line 10944
      sbptr = bptr;
    }
  } else {
#line 10947
    sbptr = bptr1->nnextgrd;
#line 10948
    while ((sbptr->netptr)->xpos == bx1) {
#line 10949
      sbptr = sbptr->nnextgrd;
    }
  }
#line 10952
  if ((int )bptr2->nSegType <= 0) {
#line 10953
    Flag = 0;
#line 10954
    fptr = bptr2;
#line 10955
    while (1) {
#line 10955
      if ((unsigned int )fptr->nnextgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 10955
        if (! (((fptr->nnextgrd)->netptr)->xpos == bx2)) {
#line 10955
          break;
        }
      } else {
#line 10955
        break;
      }
#line 10957
      if (net == (int )(*(tearray + ((fptr->nnextgrd)->netptr)->terminal))->net) {
#line 10957
        if ((int )(fptr->nnextgrd)->nSegType > 0) {
#line 10959
          Flag = 1;
#line 10960
          ebptr = bptr2->nprevgrd;
#line 10961
          while ((ebptr->netptr)->xpos == bx2) {
#line 10962
            ebptr = ebptr->nprevgrd;
          }
#line 10964
          break;
        } else {
#line 10966
          fptr = fptr->nnextgrd;
        }
      } else {
#line 10966
        fptr = fptr->nnextgrd;
      }
    }
#line 10969
    if (! Flag) {
#line 10970
      ebptr = bptr2->nprevgrd;
#line 10971
      while ((ebptr->netptr)->xpos == bx2) {
#line 10972
        if (net == (int )(*(tearray + (ebptr->netptr)->terminal))->net) {
#line 10972
          if ((int )ebptr->nSegType > 0) {
#line 10974
            Flag = 1;
          }
        }
#line 10976
        ebptr = ebptr->nprevgrd;
      }
    }
#line 10979
    if (! Flag) {
#line 10980
      ebptr = fptr;
    }
  } else {
#line 10983
    ebptr = bptr2->nprevgrd;
#line 10984
    while ((ebptr->netptr)->xpos == bx2) {
#line 10985
      ebptr = ebptr->nprevgrd;
    }
  }
#line 10988
  aoutside = 0;
#line 10989
  ax1 = (saptr->netptr)->xpos;
#line 10990
  ax2 = (eaptr->netptr)->xpos;
#line 10991
  denptr = (*(*(DboxHead + achannel) + aMaxVal))->nnext;
#line 10992
  while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 10993
    x = ((denptr->grdptr)->netptr)->xpos;
#line 10994
    if (ax1 <= x) {
#line 10994
      if (! (ax2 >= x)) {
#line 10995
        aoutside = 1;
#line 10996
        break;
      }
    } else {
#line 10995
      aoutside = 1;
#line 10996
      break;
    }
#line 10992
    denptr = denptr->nnext;
  }
#line 10999
  if (aoutside == 0) {
#line 11000
    penalty___0 --;
  }
#line 11002
  binside = 0;
#line 11003
  bx1 = (sbptr->netptr)->xpos;
#line 11004
  bx2 = (ebptr->netptr)->xpos;
#line 11005
  denptr = (*(*(DboxHead + bchannel) + bMaxVal))->nnext;
#line 11006
  while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 11007
    x = ((denptr->grdptr)->netptr)->xpos;
#line 11008
    if (bx1 <= x) {
#line 11008
      if (bx2 >= x) {
#line 11009
        binside = 1;
#line 11010
        break;
      }
    }
#line 11006
    denptr = denptr->nnext;
  }
#line 11013
  if (binside == 1) {
#line 11014
    penalty___0 ++;
  }
#line 11016
  eaptr = eaptr->nnextgrd;
#line 11017
  ebptr = ebptr->nnextgrd;
#line 11018
  if (penalty___0 == 0) {
#line 11019
    if (binside == 1) {
#line 11019
      if (aoutside == 0) {
#line 11021
        check = (bMaxVal - aMaxVal) + 2;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 11023
      maxaa = 0;
#line 11024
      maxbb = 0;
#line 11025
      ptr = saptr;
#line 11025
      while ((unsigned int )ptr != (unsigned int )eaptr) {
#line 11026
        if ((int )ptr->ntracks > maxaa) {
#line 11027
          maxaa = (int )ptr->ntracks;
        }
#line 11025
        ptr = ptr->nnextgrd;
      }
#line 11030
      ptr = sbptr;
#line 11030
      while ((unsigned int )ptr != (unsigned int )ebptr) {
#line 11031
        if ((int )ptr->ntracks > maxbb) {
#line 11032
          maxbb = (int )ptr->ntracks;
        }
#line 11030
        ptr = ptr->nnextgrd;
      }
#line 11035
      maxaa = (aMaxVal - maxaa) + 1;
#line 11036
      maxbb = (bMaxVal - maxbb) - 1;
#line 11037
      check = maxaa - maxbb;
    }
  } else {
#line 11040
    check = penalty___0;
  }
#line 11042
  if (check <= 0) {
#line 11043
    if (asegptr->pin1 <= maxterm) {
#line 11044
      aptr1->nSegType = (short )((int )aptr1->nSegType - 1);
    }
#line 11046
    if (asegptr->pin2 <= maxterm) {
#line 11047
      aptr2->nSegType = (short )((int )aptr2->nSegType - -1);
    }
#line 11049
    if (bsegptr->pin1 <= maxterm) {
#line 11050
      bptr1->nSegType = (short )((int )bptr1->nSegType + 1);
    }
#line 11052
    if (bsegptr->pin2 <= maxterm) {
#line 11053
      bptr2->nSegType = (short )((int )bptr2->nSegType + -1);
    }
#line 11055
    ptr = saptr;
#line 11055
    while ((unsigned int )ptr != (unsigned int )eaptr) {
#line 11056
      denptr = ptr->dptr;
#line 11057
      if ((unsigned int )denptr->nnext != (unsigned int )((struct densitybox *)((void *)0))) {
#line 11058
        (denptr->nnext)->nback = denptr->nback;
      }
#line 11060
      (denptr->nback)->nnext = denptr->nnext;
#line 11061
      ptr->ntracks = (short )((int )ptr->ntracks - 1);
#line 11061
      track = ptr->ntracks;
#line 11062
      headptr = (*(*(DboxHead + achannel) + track))->nnext;
#line 11063
      if ((unsigned int )headptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 11064
        (*(*(DboxHead + achannel) + track))->nnext = denptr;
#line 11065
        denptr->nnext = headptr;
#line 11066
        headptr->nback = denptr;
#line 11067
        denptr->nback = *(*(DboxHead + achannel) + track);
      } else {
#line 11069
        (*(*(DboxHead + achannel) + track))->nnext = denptr;
#line 11070
        denptr->nnext = (struct densitybox *)((void *)0);
#line 11071
        denptr->nback = *(*(DboxHead + achannel) + track);
      }
#line 11055
      ptr = ptr->nnextgrd;
    }
#line 11074
    if (aoutside == 0) {
#line 11075
      (*(nmaxTrack + achannel)) --;
    }
#line 11077
    ptr = sbptr;
#line 11077
    while ((unsigned int )ptr != (unsigned int )ebptr) {
#line 11078
      denptr = ptr->dptr;
#line 11079
      if ((unsigned int )denptr->nnext != (unsigned int )((struct densitybox *)((void *)0))) {
#line 11080
        (denptr->nnext)->nback = denptr->nback;
      }
#line 11082
      (denptr->nback)->nnext = denptr->nnext;
#line 11083
      ptr->ntracks = (short )((int )ptr->ntracks + 1);
#line 11083
      track = ptr->ntracks;
#line 11084
      headptr = (*(*(DboxHead + bchannel) + track))->nnext;
#line 11085
      if ((unsigned int )headptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 11086
        (*(*(DboxHead + bchannel) + track))->nnext = denptr;
#line 11087
        denptr->nnext = headptr;
#line 11088
        headptr->nback = denptr;
#line 11089
        denptr->nback = *(*(DboxHead + bchannel) + track);
      } else {
#line 11091
        (*(*(DboxHead + bchannel) + track))->nnext = denptr;
#line 11092
        denptr->nnext = (struct densitybox *)((void *)0);
#line 11093
        denptr->nback = *(*(DboxHead + bchannel) + track);
      }
#line 11077
      ptr = ptr->nnextgrd;
    }
#line 11096
    if (binside == 1) {
#line 11097
      (*(nmaxTrack + bchannel)) ++;
    }
#line 11099
    if ((int )(aNetSeg + segment)->nflag == 0) {
#line 11100
      if (current == 1) {
#line 11101
        (aNetSeg + segment)->current = (char)0;
      } else {
#line 11103
        (aNetSeg + segment)->current = (char)1;
      }
    } else {
#line 11106
      if (current == 1) {
#line 11107
        (aNetSeg + segment)->ncurrent = (char)0;
      } else {
#line 11109
        (aNetSeg + segment)->ncurrent = (char)1;
      }
    }
#line 11112
    tracks += penalty___0;
#line 11113
    return (1);
  } else {
#line 11115
    return (0);
  }
}
}
#line 11123 "D:/a/test/300.c"
int qsz  ;
#line 11124 "D:/a/test/300.c"
int thresh  ;
#line 11125 "D:/a/test/300.c"
int mthresh  ;
#line 11140
int qste(char *base , char *max ) ;
#line 11146
int comparee(edgeBptr a___0 , edgeBptr b___0 ) ;
#line 11126 "D:/a/test/300.c"
int qsorte(char *base , int n , int size ) 
{ register char c ;
  register char *i ;
  register char *j ;
  register char *lo ;
  register char *hi ;
  char *min ;
  char *max ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 11133
  if (n <= 1) {
#line 11134
    return 0;
  }
#line 11135
  qsz = size;
#line 11136
  thresh = qsz * 4;
#line 11137
  mthresh = qsz * 6;
#line 11138
  max = base + n * qsz;
#line 11139
  if (n >= 4) {
#line 11140
    qste(base, max);
#line 11141
    hi = base + thresh;
  } else {
#line 11143
    hi = max;
  }
#line 11145
  lo = base;
#line 11145
  j = lo;
#line 11145
  while (1) {
#line 11145
    lo += qsz;
#line 11145
    if (! ((unsigned int )lo < (unsigned int )hi)) {
#line 11145
      break;
    }
#line 11146
    tmp = comparee(j, lo);
#line 11146
    if (tmp > 0) {
#line 11147
      j = lo;
    }
  }
#line 11148
  if ((unsigned int )j != (unsigned int )base) {
#line 11150
    i = base;
#line 11150
    hi = base + qsz;
#line 11150
    while ((unsigned int )i < (unsigned int )hi) {
#line 11151
      c = *j;
#line 11152
      tmp___0 = j;
#line 11152
      j ++;
#line 11152
      *tmp___0 = *i;
#line 11153
      tmp___1 = i;
#line 11153
      i ++;
#line 11153
      *tmp___1 = c;
    }
  }
#line 11156
  min = base;
#line 11156
  while (1) {
#line 11156
    min += qsz;
#line 11156
    hi = min;
#line 11156
    if (! ((unsigned int )hi < (unsigned int )max)) {
#line 11156
      break;
    }
#line 11157
    while (1) {
#line 11157
      hi -= qsz;
#line 11157
      tmp___2 = comparee(hi, min);
#line 11157
      if (! (tmp___2 > 0)) {
#line 11157
        break;
      }
    }
#line 11159
    hi += qsz;
#line 11159
    if ((unsigned int )hi != (unsigned int )min) {
#line 11160
      lo = min + qsz;
#line 11160
      while (1) {
#line 11160
        lo --;
#line 11160
        if (! ((unsigned int )lo >= (unsigned int )min)) {
#line 11160
          break;
        }
#line 11161
        c = *lo;
#line 11162
        j = lo;
#line 11162
        i = j;
#line 11162
        while (1) {
#line 11162
          j -= qsz;
#line 11162
          if (! ((unsigned int )j >= (unsigned int )hi)) {
#line 11162
            break;
          }
#line 11163
          *i = *j;
#line 11162
          i = j;
        }
#line 11164
        *i = c;
      }
    }
  }
#line 11168
  return (0);
}
}
#line 11169 "D:/a/test/300.c"
int qste(char *base , char *max ) 
{ register char c ;
  register char *i ;
  register char *j ;
  register char *jj ;
  register int ii ;
  char *mid ;
  char *tmp ;
  int lo ;
  int hi ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 11176
  lo = max - base;
#line 11177
  while (1) {
#line 11178
    i = base + qsz * (lo / qsz >> 1);
#line 11178
    mid = i;
#line 11179
    if (lo >= mthresh) {
#line 11180
      jj = base;
#line 11180
      tmp___1 = comparee(jj, i);
#line 11180
      if (tmp___1 > 0) {
#line 11180
        j = jj;
      } else {
#line 11180
        j = i;
      }
#line 11181
      tmp = max - qsz;
#line 11181
      tmp___3 = comparee(j, tmp);
#line 11181
      if (tmp___3 > 0) {
#line 11183
        if ((unsigned int )j == (unsigned int )jj) {
#line 11183
          j = i;
        } else {
#line 11183
          j = jj;
        }
#line 11184
        tmp___2 = comparee(j, tmp);
#line 11184
        if (tmp___2 < 0) {
#line 11185
          j = tmp;
        }
      }
#line 11187
      if ((unsigned int )j != (unsigned int )i) {
#line 11188
        ii = qsz;
#line 11189
        while (1) {
#line 11190
          c = *i;
#line 11191
          tmp___4 = i;
#line 11191
          i ++;
#line 11191
          *tmp___4 = *j;
#line 11192
          tmp___5 = j;
#line 11192
          j ++;
#line 11192
          *tmp___5 = c;
#line 11189
          ii --;
#line 11189
          if (! ii) {
#line 11189
            break;
          }
        }
      }
    }
#line 11197
    i = base;
#line 11197
    j = max - qsz;
#line 11197
    while (1) {
#line 11198
      while (1) {
#line 11198
        if ((unsigned int )i < (unsigned int )mid) {
#line 11198
          tmp___6 = comparee(i, mid);
#line 11198
          if (! (tmp___6 <= 0)) {
#line 11198
            break;
          }
        } else {
#line 11198
          break;
        }
#line 11199
        i += qsz;
      }
#line 11200
      while ((unsigned int )j > (unsigned int )mid) {
#line 11201
        tmp___7 = comparee(mid, j);
#line 11201
        if (tmp___7 <= 0) {
#line 11202
          j -= qsz;
#line 11203
          continue;
        }
#line 11205
        tmp = i + qsz;
#line 11206
        if ((unsigned int )i == (unsigned int )mid) {
#line 11208
          jj = j;
#line 11208
          mid = jj;
        } else {
#line 11211
          jj = j;
#line 11212
          j -= qsz;
        }
        goto swap;
      }
#line 11216
      if ((unsigned int )i == (unsigned int )mid) {
#line 11217
        break;
      } else {
#line 11220
        jj = mid;
#line 11221
        mid = i;
#line 11221
        tmp = mid;
#line 11222
        j -= qsz;
      }
      swap: 
#line 11225
      ii = qsz;
#line 11226
      while (1) {
#line 11227
        c = *i;
#line 11228
        tmp___8 = i;
#line 11228
        i ++;
#line 11228
        *tmp___8 = *jj;
#line 11229
        tmp___9 = jj;
#line 11229
        jj ++;
#line 11229
        *tmp___9 = c;
#line 11226
        ii --;
#line 11226
        if (! ii) {
#line 11226
          break;
        }
      }
#line 11231
      i = tmp;
    }
#line 11233
    j = mid;
#line 11233
    i = j + qsz;
#line 11234
    lo = j - base;
#line 11234
    hi = max - i;
#line 11234
    if (lo <= hi) {
#line 11235
      if (lo >= thresh) {
#line 11236
        qste(base, j);
      }
#line 11237
      base = i;
#line 11238
      lo = hi;
    } else {
#line 11240
      if (hi >= thresh) {
#line 11241
        qste(i, max);
      }
#line 11242
      max = j;
    }
#line 11177
    if (! (lo >= thresh)) {
#line 11177
      break;
    }
  }
#line 11245
  return (0);
}
}
#line 11246 "D:/a/test/300.c"
int comparee(edgeBptr a___0 , edgeBptr b___0 ) 
{ 

  {
#line 11249
  return ((int )a___0->cost - (int )b___0->cost);
}
}
#line 11272
int qstg(char *base , char *max ) ;
#line 11278
int compareg(csGroup *a___0 , csGroup *b___0 ) ;
#line 11258 "D:/a/test/300.c"
int qsortg(char *base , int n , int size ) 
{ register char c ;
  register char *i ;
  register char *j ;
  register char *lo ;
  register char *hi ;
  char *min ;
  char *max ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 11265
  if (n <= 1) {
#line 11266
    return 0;
  }
#line 11267
  qsz = size;
#line 11268
  thresh = qsz * 4;
#line 11269
  mthresh = qsz * 6;
#line 11270
  max = base + n * qsz;
#line 11271
  if (n >= 4) {
#line 11272
    qstg(base, max);
#line 11273
    hi = base + thresh;
  } else {
#line 11275
    hi = max;
  }
#line 11277
  lo = base;
#line 11277
  j = lo;
#line 11277
  while (1) {
#line 11277
    lo += qsz;
#line 11277
    if (! ((unsigned int )lo < (unsigned int )hi)) {
#line 11277
      break;
    }
#line 11278
    tmp = compareg(j, lo);
#line 11278
    if (tmp > 0) {
#line 11279
      j = lo;
    }
  }
#line 11280
  if ((unsigned int )j != (unsigned int )base) {
#line 11282
    i = base;
#line 11282
    hi = base + qsz;
#line 11282
    while ((unsigned int )i < (unsigned int )hi) {
#line 11283
      c = *j;
#line 11284
      tmp___0 = j;
#line 11284
      j ++;
#line 11284
      *tmp___0 = *i;
#line 11285
      tmp___1 = i;
#line 11285
      i ++;
#line 11285
      *tmp___1 = c;
    }
  }
#line 11288
  min = base;
#line 11288
  while (1) {
#line 11288
    min += qsz;
#line 11288
    hi = min;
#line 11288
    if (! ((unsigned int )hi < (unsigned int )max)) {
#line 11288
      break;
    }
#line 11289
    while (1) {
#line 11289
      hi -= qsz;
#line 11289
      tmp___2 = compareg(hi, min);
#line 11289
      if (! (tmp___2 > 0)) {
#line 11289
        break;
      }
    }
#line 11291
    hi += qsz;
#line 11291
    if ((unsigned int )hi != (unsigned int )min) {
#line 11292
      lo = min + qsz;
#line 11292
      while (1) {
#line 11292
        lo --;
#line 11292
        if (! ((unsigned int )lo >= (unsigned int )min)) {
#line 11292
          break;
        }
#line 11293
        c = *lo;
#line 11294
        j = lo;
#line 11294
        i = j;
#line 11294
        while (1) {
#line 11294
          j -= qsz;
#line 11294
          if (! ((unsigned int )j >= (unsigned int )hi)) {
#line 11294
            break;
          }
#line 11295
          *i = *j;
#line 11294
          i = j;
        }
#line 11296
        *i = c;
      }
    }
  }
#line 11300
  return (0);
}
}
#line 11301 "D:/a/test/300.c"
int qstg(char *base , char *max ) 
{ register char c ;
  register char *i ;
  register char *j ;
  register char *jj ;
  register int ii ;
  char *mid ;
  char *tmp ;
  int lo ;
  int hi ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 11308
  lo = max - base;
#line 11309
  while (1) {
#line 11310
    i = base + qsz * (lo / qsz >> 1);
#line 11310
    mid = i;
#line 11311
    if (lo >= mthresh) {
#line 11312
      jj = base;
#line 11312
      tmp___1 = compareg(jj, i);
#line 11312
      if (tmp___1 > 0) {
#line 11312
        j = jj;
      } else {
#line 11312
        j = i;
      }
#line 11313
      tmp = max - qsz;
#line 11313
      tmp___3 = compareg(j, tmp);
#line 11313
      if (tmp___3 > 0) {
#line 11315
        if ((unsigned int )j == (unsigned int )jj) {
#line 11315
          j = i;
        } else {
#line 11315
          j = jj;
        }
#line 11316
        tmp___2 = compareg(j, tmp);
#line 11316
        if (tmp___2 < 0) {
#line 11317
          j = tmp;
        }
      }
#line 11319
      if ((unsigned int )j != (unsigned int )i) {
#line 11320
        ii = qsz;
#line 11321
        while (1) {
#line 11322
          c = *i;
#line 11323
          tmp___4 = i;
#line 11323
          i ++;
#line 11323
          *tmp___4 = *j;
#line 11324
          tmp___5 = j;
#line 11324
          j ++;
#line 11324
          *tmp___5 = c;
#line 11321
          ii --;
#line 11321
          if (! ii) {
#line 11321
            break;
          }
        }
      }
    }
#line 11329
    i = base;
#line 11329
    j = max - qsz;
#line 11329
    while (1) {
#line 11330
      while (1) {
#line 11330
        if ((unsigned int )i < (unsigned int )mid) {
#line 11330
          tmp___6 = compareg(i, mid);
#line 11330
          if (! (tmp___6 <= 0)) {
#line 11330
            break;
          }
        } else {
#line 11330
          break;
        }
#line 11331
        i += qsz;
      }
#line 11332
      while ((unsigned int )j > (unsigned int )mid) {
#line 11333
        tmp___7 = compareg(mid, j);
#line 11333
        if (tmp___7 <= 0) {
#line 11334
          j -= qsz;
#line 11335
          continue;
        }
#line 11337
        tmp = i + qsz;
#line 11338
        if ((unsigned int )i == (unsigned int )mid) {
#line 11340
          jj = j;
#line 11340
          mid = jj;
        } else {
#line 11343
          jj = j;
#line 11344
          j -= qsz;
        }
        goto swap;
      }
#line 11348
      if ((unsigned int )i == (unsigned int )mid) {
#line 11349
        break;
      } else {
#line 11352
        jj = mid;
#line 11353
        mid = i;
#line 11353
        tmp = mid;
#line 11354
        j -= qsz;
      }
      swap: 
#line 11357
      ii = qsz;
#line 11358
      while (1) {
#line 11359
        c = *i;
#line 11360
        tmp___8 = i;
#line 11360
        i ++;
#line 11360
        *tmp___8 = *jj;
#line 11361
        tmp___9 = jj;
#line 11361
        jj ++;
#line 11361
        *tmp___9 = c;
#line 11358
        ii --;
#line 11358
        if (! ii) {
#line 11358
          break;
        }
      }
#line 11363
      i = tmp;
    }
#line 11365
    j = mid;
#line 11365
    i = j + qsz;
#line 11366
    lo = j - base;
#line 11366
    hi = max - i;
#line 11366
    if (lo <= hi) {
#line 11367
      if (lo >= thresh) {
#line 11368
        qstg(base, j);
      }
#line 11369
      base = i;
#line 11370
      lo = hi;
    } else {
#line 11372
      if (hi >= thresh) {
#line 11373
        qstg(i, max);
      }
#line 11374
      max = j;
    }
#line 11309
    if (! (lo >= thresh)) {
#line 11309
      break;
    }
  }
#line 11377
  return (0);
}
}
#line 11378 "D:/a/test/300.c"
int compareg(csGroup *a___0 , csGroup *b___0 ) 
{ 

  {
#line 11381
  return (a___0->aveX - b___0->aveX);
}
}
#line 11405
int qstgdx(char *base , char *max ) ;
#line 11411
int comparegdx(CHANGRDPTR *a___0 , CHANGRDPTR *b___0 ) ;
#line 11391 "D:/a/test/300.c"
int qsortgdx(char *base , int n , int size ) 
{ register char c ;
  register char *i ;
  register char *j ;
  register char *lo ;
  register char *hi ;
  char *min ;
  char *max ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 11398
  if (n <= 1) {
#line 11399
    return 0;
  }
#line 11400
  qsz = size;
#line 11401
  thresh = qsz * 4;
#line 11402
  mthresh = qsz * 6;
#line 11403
  max = base + n * qsz;
#line 11404
  if (n >= 4) {
#line 11405
    qstgdx(base, max);
#line 11406
    hi = base + thresh;
  } else {
#line 11408
    hi = max;
  }
#line 11410
  lo = base;
#line 11410
  j = lo;
#line 11410
  while (1) {
#line 11410
    lo += qsz;
#line 11410
    if (! ((unsigned int )lo < (unsigned int )hi)) {
#line 11410
      break;
    }
#line 11411
    tmp = comparegdx(j, lo);
#line 11411
    if (tmp > 0) {
#line 11412
      j = lo;
    }
  }
#line 11413
  if ((unsigned int )j != (unsigned int )base) {
#line 11415
    i = base;
#line 11415
    hi = base + qsz;
#line 11415
    while ((unsigned int )i < (unsigned int )hi) {
#line 11416
      c = *j;
#line 11417
      tmp___0 = j;
#line 11417
      j ++;
#line 11417
      *tmp___0 = *i;
#line 11418
      tmp___1 = i;
#line 11418
      i ++;
#line 11418
      *tmp___1 = c;
    }
  }
#line 11421
  min = base;
#line 11421
  while (1) {
#line 11421
    min += qsz;
#line 11421
    hi = min;
#line 11421
    if (! ((unsigned int )hi < (unsigned int )max)) {
#line 11421
      break;
    }
#line 11422
    while (1) {
#line 11422
      hi -= qsz;
#line 11422
      tmp___2 = comparegdx(hi, min);
#line 11422
      if (! (tmp___2 > 0)) {
#line 11422
        break;
      }
    }
#line 11424
    hi += qsz;
#line 11424
    if ((unsigned int )hi != (unsigned int )min) {
#line 11425
      lo = min + qsz;
#line 11425
      while (1) {
#line 11425
        lo --;
#line 11425
        if (! ((unsigned int )lo >= (unsigned int )min)) {
#line 11425
          break;
        }
#line 11426
        c = *lo;
#line 11427
        j = lo;
#line 11427
        i = j;
#line 11427
        while (1) {
#line 11427
          j -= qsz;
#line 11427
          if (! ((unsigned int )j >= (unsigned int )hi)) {
#line 11427
            break;
          }
#line 11428
          *i = *j;
#line 11427
          i = j;
        }
#line 11429
        *i = c;
      }
    }
  }
#line 11433
  return (0);
}
}
#line 11434 "D:/a/test/300.c"
int qstgdx(char *base , char *max ) 
{ register char c ;
  register char *i ;
  register char *j ;
  register char *jj ;
  register int ii ;
  char *mid ;
  char *tmp ;
  int lo ;
  int hi ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 11441
  lo = max - base;
#line 11442
  while (1) {
#line 11443
    i = base + qsz * (lo / qsz >> 1);
#line 11443
    mid = i;
#line 11444
    if (lo >= mthresh) {
#line 11445
      jj = base;
#line 11445
      tmp___1 = comparegdx(jj, i);
#line 11445
      if (tmp___1 > 0) {
#line 11445
        j = jj;
      } else {
#line 11445
        j = i;
      }
#line 11446
      tmp = max - qsz;
#line 11446
      tmp___3 = comparegdx(j, tmp);
#line 11446
      if (tmp___3 > 0) {
#line 11448
        if ((unsigned int )j == (unsigned int )jj) {
#line 11448
          j = i;
        } else {
#line 11448
          j = jj;
        }
#line 11449
        tmp___2 = comparegdx(j, tmp);
#line 11449
        if (tmp___2 < 0) {
#line 11450
          j = tmp;
        }
      }
#line 11452
      if ((unsigned int )j != (unsigned int )i) {
#line 11453
        ii = qsz;
#line 11454
        while (1) {
#line 11455
          c = *i;
#line 11456
          tmp___4 = i;
#line 11456
          i ++;
#line 11456
          *tmp___4 = *j;
#line 11457
          tmp___5 = j;
#line 11457
          j ++;
#line 11457
          *tmp___5 = c;
#line 11454
          ii --;
#line 11454
          if (! ii) {
#line 11454
            break;
          }
        }
      }
    }
#line 11462
    i = base;
#line 11462
    j = max - qsz;
#line 11462
    while (1) {
#line 11463
      while (1) {
#line 11463
        if ((unsigned int )i < (unsigned int )mid) {
#line 11463
          tmp___6 = comparegdx(i, mid);
#line 11463
          if (! (tmp___6 <= 0)) {
#line 11463
            break;
          }
        } else {
#line 11463
          break;
        }
#line 11464
        i += qsz;
      }
#line 11465
      while ((unsigned int )j > (unsigned int )mid) {
#line 11466
        tmp___7 = comparegdx(mid, j);
#line 11466
        if (tmp___7 <= 0) {
#line 11467
          j -= qsz;
#line 11468
          continue;
        }
#line 11470
        tmp = i + qsz;
#line 11471
        if ((unsigned int )i == (unsigned int )mid) {
#line 11473
          jj = j;
#line 11473
          mid = jj;
        } else {
#line 11476
          jj = j;
#line 11477
          j -= qsz;
        }
        goto swap;
      }
#line 11481
      if ((unsigned int )i == (unsigned int )mid) {
#line 11482
        break;
      } else {
#line 11485
        jj = mid;
#line 11486
        mid = i;
#line 11486
        tmp = mid;
#line 11487
        j -= qsz;
      }
      swap: 
#line 11490
      ii = qsz;
#line 11491
      while (1) {
#line 11492
        c = *i;
#line 11493
        tmp___8 = i;
#line 11493
        i ++;
#line 11493
        *tmp___8 = *jj;
#line 11494
        tmp___9 = jj;
#line 11494
        jj ++;
#line 11494
        *tmp___9 = c;
#line 11491
        ii --;
#line 11491
        if (! ii) {
#line 11491
          break;
        }
      }
#line 11496
      i = tmp;
    }
#line 11498
    j = mid;
#line 11498
    i = j + qsz;
#line 11499
    lo = j - base;
#line 11499
    hi = max - i;
#line 11499
    if (lo <= hi) {
#line 11500
      if (lo >= thresh) {
#line 11501
        qstgdx(base, j);
      }
#line 11502
      base = i;
#line 11503
      lo = hi;
    } else {
#line 11505
      if (hi >= thresh) {
#line 11506
        qstgdx(i, max);
      }
#line 11507
      max = j;
    }
#line 11442
    if (! (lo >= thresh)) {
#line 11442
      break;
    }
  }
#line 11510
  return (0);
}
}
#line 11511 "D:/a/test/300.c"
int comparegdx(CHANGRDPTR *a___0 , CHANGRDPTR *b___0 ) 
{ 

  {
#line 11514
  return (((*a___0)->netptr)->xpos - ((*b___0)->netptr)->xpos);
}
}
#line 11537
int qst(char *base , char *max ) ;
#line 11523 "D:/a/test/300.c"
int qsortx(char *base , int n , int size ) 
{ register char c ;
  register char *i ;
  register char *j ;
  register char *lo ;
  register char *hi ;
  char *min ;
  char *max ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 11530
  if (n <= 1) {
#line 11531
    return 0;
  }
#line 11532
  qsz = size;
#line 11533
  thresh = qsz * 4;
#line 11534
  mthresh = qsz * 6;
#line 11535
  max = base + n * qsz;
#line 11536
  if (n >= 4) {
#line 11537
    qst(base, max);
#line 11538
    hi = base + thresh;
  } else {
#line 11540
    hi = max;
  }
#line 11542
  lo = base;
#line 11542
  j = lo;
#line 11542
  while (1) {
#line 11542
    lo += qsz;
#line 11542
    if (! ((unsigned int )lo < (unsigned int )hi)) {
#line 11542
      break;
    }
#line 11543
    tmp = comparex((int *)j, (int *)lo);
#line 11543
    if (tmp > 0) {
#line 11544
      j = lo;
    }
  }
#line 11545
  if ((unsigned int )j != (unsigned int )base) {
#line 11547
    i = base;
#line 11547
    hi = base + qsz;
#line 11547
    while ((unsigned int )i < (unsigned int )hi) {
#line 11548
      c = *j;
#line 11549
      tmp___0 = j;
#line 11549
      j ++;
#line 11549
      *tmp___0 = *i;
#line 11550
      tmp___1 = i;
#line 11550
      i ++;
#line 11550
      *tmp___1 = c;
    }
  }
#line 11553
  min = base;
#line 11553
  while (1) {
#line 11553
    min += qsz;
#line 11553
    hi = min;
#line 11553
    if (! ((unsigned int )hi < (unsigned int )max)) {
#line 11553
      break;
    }
#line 11554
    while (1) {
#line 11554
      hi -= qsz;
#line 11554
      tmp___2 = comparex((int *)hi, (int *)min);
#line 11554
      if (! (tmp___2 > 0)) {
#line 11554
        break;
      }
    }
#line 11556
    hi += qsz;
#line 11556
    if ((unsigned int )hi != (unsigned int )min) {
#line 11557
      lo = min + qsz;
#line 11557
      while (1) {
#line 11557
        lo --;
#line 11557
        if (! ((unsigned int )lo >= (unsigned int )min)) {
#line 11557
          break;
        }
#line 11558
        c = *lo;
#line 11559
        j = lo;
#line 11559
        i = j;
#line 11559
        while (1) {
#line 11559
          j -= qsz;
#line 11559
          if (! ((unsigned int )j >= (unsigned int )hi)) {
#line 11559
            break;
          }
#line 11560
          *i = *j;
#line 11559
          i = j;
        }
#line 11561
        *i = c;
      }
    }
  }
#line 11565
  return (0);
}
}
#line 11566 "D:/a/test/300.c"
int qst(char *base , char *max ) 
{ register char c ;
  register char *i ;
  register char *j ;
  register char *jj ;
  register int ii ;
  char *mid ;
  char *tmp ;
  int lo ;
  int hi ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 11573
  lo = max - base;
#line 11574
  while (1) {
#line 11575
    i = base + qsz * (lo / qsz >> 1);
#line 11575
    mid = i;
#line 11576
    if (lo >= mthresh) {
#line 11577
      jj = base;
#line 11577
      tmp___1 = comparex((int *)jj, (int *)i);
#line 11577
      if (tmp___1 > 0) {
#line 11577
        j = jj;
      } else {
#line 11577
        j = i;
      }
#line 11578
      tmp = max - qsz;
#line 11578
      tmp___3 = comparex((int *)j, (int *)tmp);
#line 11578
      if (tmp___3 > 0) {
#line 11580
        if ((unsigned int )j == (unsigned int )jj) {
#line 11580
          j = i;
        } else {
#line 11580
          j = jj;
        }
#line 11581
        tmp___2 = comparex((int *)j, (int *)tmp);
#line 11581
        if (tmp___2 < 0) {
#line 11582
          j = tmp;
        }
      }
#line 11584
      if ((unsigned int )j != (unsigned int )i) {
#line 11585
        ii = qsz;
#line 11586
        while (1) {
#line 11587
          c = *i;
#line 11588
          tmp___4 = i;
#line 11588
          i ++;
#line 11588
          *tmp___4 = *j;
#line 11589
          tmp___5 = j;
#line 11589
          j ++;
#line 11589
          *tmp___5 = c;
#line 11586
          ii --;
#line 11586
          if (! ii) {
#line 11586
            break;
          }
        }
      }
    }
#line 11594
    i = base;
#line 11594
    j = max - qsz;
#line 11594
    while (1) {
#line 11595
      while (1) {
#line 11595
        if ((unsigned int )i < (unsigned int )mid) {
#line 11595
          tmp___6 = comparex((int *)i, (int *)mid);
#line 11595
          if (! (tmp___6 <= 0)) {
#line 11595
            break;
          }
        } else {
#line 11595
          break;
        }
#line 11596
        i += qsz;
      }
#line 11597
      while ((unsigned int )j > (unsigned int )mid) {
#line 11598
        tmp___7 = comparex((int *)mid, (int *)j);
#line 11598
        if (tmp___7 <= 0) {
#line 11599
          j -= qsz;
#line 11600
          continue;
        }
#line 11602
        tmp = i + qsz;
#line 11603
        if ((unsigned int )i == (unsigned int )mid) {
#line 11605
          jj = j;
#line 11605
          mid = jj;
        } else {
#line 11608
          jj = j;
#line 11609
          j -= qsz;
        }
        goto swap;
      }
#line 11613
      if ((unsigned int )i == (unsigned int )mid) {
#line 11614
        break;
      } else {
#line 11617
        jj = mid;
#line 11618
        mid = i;
#line 11618
        tmp = mid;
#line 11619
        j -= qsz;
      }
      swap: 
#line 11622
      ii = qsz;
#line 11623
      while (1) {
#line 11624
        c = *i;
#line 11625
        tmp___8 = i;
#line 11625
        i ++;
#line 11625
        *tmp___8 = *jj;
#line 11626
        tmp___9 = jj;
#line 11626
        jj ++;
#line 11626
        *tmp___9 = c;
#line 11623
        ii --;
#line 11623
        if (! ii) {
#line 11623
          break;
        }
      }
#line 11628
      i = tmp;
    }
#line 11631
    j = mid;
#line 11631
    i = j + qsz;
#line 11632
    lo = j - base;
#line 11632
    hi = max - i;
#line 11632
    if (lo <= hi) {
#line 11633
      if (lo >= thresh) {
#line 11634
        qst(base, j);
      }
#line 11635
      base = i;
#line 11636
      lo = hi;
    } else {
#line 11638
      if (hi >= thresh) {
#line 11639
        qst(i, max);
      }
#line 11640
      max = j;
    }
#line 11574
    if (! (lo >= thresh)) {
#line 11574
      break;
    }
  }
#line 11643
  return (0);
}
}
#line 11651 "D:/a/test/300.c"
static int randVarS  ;
#line 11658 "D:/a/test/300.c"
int Yacm_random(void) 
{ register int k_rand ;

  {
#line 11661
  k_rand = (int )((long )randVarS / 127773L);
#line 11662
  randVarS = (int )(16807L * ((long )randVarS - (long )k_rand * 127773L) - (long )k_rand * 2836L);
#line 11663
  if (randVarS < 0) {
#line 11664
    randVarS = (int )((long )randVarS + 2147483647L);
  }
#line 11666
  return (randVarS);
}
}
#line 11668 "D:/a/test/300.c"
int Yset_random_seed(int seed ) 
{ 

  {
#line 11671
  if (seed >= 0) {
#line 11671
    seed = seed;
  } else {
#line 11671
    seed = - seed;
  }
#line 11672
  if (seed == 0) {
#line 11673
    seed ++;
  }
#line 11675
  randVarS = seed;
#line 11676
  return (0);
}
}
#line 11682 "D:/a/test/300.c"
int totallen  ;
#line 11692 "D:/a/test/300.c"
int readcell(FILE *fp ) 
{ int cell___0 ;
  int orient ;
  int layer ;
  int block___0 ;
  int left___0 ;
  int right ;
  int bottom ;
  int top___0 ;
  int xpos ;
  int ypos ;
  int from ;
  int terms ;
  int pinctr ;
  int netx ;
  int tot ;
  int totx ;
  int toty ;
  char input[1024] ;
  char netname[1024] ;
  double space___0 ;
  CBOXPTR ptr ;
  TIBOXPTR tile ;
  TIBOXPTR tptr ;
  TEBOXPTR term ;
  TEBOXPTR tmptr ;
  NBOXPTR netptr ;
  NBOXPTR saveptr ;
  char *tmp ;
  CBOXPTR tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  TIBOXPTR tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  TEBOXPTR tmp___12 ;
  char *tmp___13 ;
  struct termbox *tmp___14 ;
  char *tmp___15 ;
  NBOXPTR tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;

  {
#line 11707
  parser(fp);
#line 11708
  tmp = safe_malloc((unsigned int )((1 + numcells) + numterms) * sizeof(CBOXPTR ));
#line 11708
  carray = (CBOXPTR *)tmp;
#line 11710
  cell___0 = 1;
#line 11710
  while (cell___0 <= numcells + numterms) {
#line 11711
    tmp___1 = safe_malloc(sizeof(CBOX ));
#line 11711
    tmp___0 = (struct cellbox *)tmp___1;
#line 11711
    *(carray + cell___0) = tmp___0;
#line 11711
    ptr = tmp___0;
#line 11712
    ptr->cxcenter = 0;
#line 11713
    ptr->cycenter = 0;
#line 11714
    ptr->cheight = (short)0;
#line 11715
    ptr->clength = (short)0;
#line 11716
    ptr->cblock = (short)0;
#line 11717
    ptr->cclass = (short)0;
#line 11718
    ptr->corient = (char)0;
#line 11719
    ptr->orflag = (char)1;
#line 11720
    ptr->numterms = (short)0;
#line 11721
    ptr->padside = (short)0;
#line 11722
    ptr->tileptr = (struct tilebox *)((void *)0);
#line 11710
    cell___0 ++;
  }
#line 11724
  implicit_feed_count = 0;
#line 11725
  cell___0 = 0;
#line 11726
  terms = 0;
#line 11727
  pinctr = 0;
#line 11728
  while (1) {
#line 11728
    tmp___51 = fscanf(fp, " %s ", input);
#line 11728
    if (! (tmp___51 == 1)) {
#line 11728
      break;
    }
#line 11729
    tmp___50 = strcmp((char const   *)(input), "cell");
#line 11729
    if (tmp___50 == 0) {
#line 11731
      cell___0 ++;
#line 11732
      ptr = *(carray + cell___0);
#line 11733
      ptr->corient = (char)0;
#line 11734
      fscanf(fp, " %s ", input);
#line 11735
      fscanf(fp, " %s ", input);
#line 11736
      tmp___2 = strlen((char const   *)(input));
#line 11736
      tmp___3 = safe_malloc((tmp___2 + 1U) * sizeof(char ));
#line 11736
      ptr->cname = tmp___3;
#line 11738
      sprintf(ptr->cname, "%s", input);
    } else {
#line 11739
      tmp___49 = strcmp((char const   *)(input), "nomirror");
#line 11739
      if (tmp___49 == 0) {
#line 11740
        ptr->orflag = (char)0;
      } else {
#line 11741
        tmp___48 = strcmp((char const   *)(input), "initially");
#line 11741
        if (tmp___48 == 0) {
#line 11742
          fscanf(fp, " %s ", input);
#line 11743
          tmp___5 = strcmp((char const   *)(input), "fixed");
#line 11743
          if (tmp___5 == 0) {
#line 11744
            ptr->cclass = (short)-1;
#line 11745
            ptr->orflag = (char)0;
          } else {
#line 11746
            tmp___4 = strcmp((char const   *)(input), "nonfixed");
#line 11746
            if (tmp___4 == 0) {
#line 11747
              ptr->cclass = (short)0;
            }
          }
#line 11749
          fscanf(fp, " %d ", & from);
#line 11750
          fscanf(fp, " %s ", input);
#line 11751
          fscanf(fp, " %s ", input);
#line 11752
          tmp___7 = strcmp((char const   *)(input), "left");
#line 11752
          if (tmp___7 == 0) {
#line 11753
            ptr->cxcenter = from;
#line 11754
            ptr->cycenter = 1;
          } else {
#line 11755
            tmp___6 = strcmp((char const   *)(input), "right");
#line 11755
            if (tmp___6 == 0) {
#line 11756
              ptr->cxcenter = - from;
#line 11757
              ptr->cycenter = -1;
            }
          }
#line 11759
          fscanf(fp, " %s ", input);
#line 11760
          fscanf(fp, " %s ", input);
#line 11761
          fscanf(fp, " %d ", & block___0);
#line 11762
          ptr->cblock = (short )block___0;
        } else {
#line 11763
          tmp___47 = strcmp((char const   *)(input), "left");
#line 11763
          if (tmp___47 == 0) {
#line 11764
            tmp___9 = safe_malloc(sizeof(TIBOX ));
#line 11764
            tmp___8 = (struct tilebox *)tmp___9;
#line 11764
            ptr->tileptr = tmp___8;
#line 11764
            tile = tmp___8;
#line 11765
            tile->termsptr = (struct termbox *)((void *)0);
#line 11766
            fscanf(fp, " %d ", & left___0);
#line 11767
            tile->left = (short )left___0;
          } else {
#line 11768
            tmp___46 = strcmp((char const   *)(input), "right");
#line 11768
            if (tmp___46 == 0) {
#line 11769
              fscanf(fp, " %d ", & right);
#line 11770
              tile->right = (short )right;
            } else {
#line 11771
              tmp___45 = strcmp((char const   *)(input), "bottom");
#line 11771
              if (tmp___45 == 0) {
#line 11772
                fscanf(fp, " %d ", & bottom);
#line 11773
                tile->bottom = (short )bottom;
              } else {
#line 11774
                tmp___44 = strcmp((char const   *)(input), "top");
#line 11774
                if (tmp___44 == 0) {
#line 11775
                  fscanf(fp, " %d ", & top___0);
#line 11776
                  tile->top = (short )top___0;
#line 11777
                  ptr->cheight = (short )(top___0 - bottom);
#line 11778
                  ptr->clength = (short )(right - left___0);
                } else {
#line 11779
                  tmp___43 = strcmp((char const   *)(input), "pin");
#line 11779
                  if (tmp___43 == 0) {
#line 11780
                    fscanf(fp, " %s ", input);
#line 11781
                    fscanf(fp, " %s ", input);
#line 11782
                    fscanf(fp, " %s ", input);
#line 11783
                    fscanf(fp, " %s ", input);
#line 11784
                    strcpy(netname, (char const   *)(input));
#line 11785
                    tmp___18 = strcmp((char const   *)(input), "TW_PASS_THRU");
#line 11785
                    if (tmp___18 != 0) {
#line 11786
                      netx = hashfind(input);
#line 11787
                      if ((unsigned int )(*(netarray + netx))->name == (unsigned int )((void *)0)) {
#line 11788
                        tmp___10 = strlen((char const   *)(input));
#line 11788
                        tmp___11 = safe_malloc((tmp___10 + 1U) * sizeof(char ));
#line 11788
                        (*(netarray + netx))->name = tmp___11;
#line 11790
                        sprintf((*(netarray + netx))->name, "%s", input);
                      }
#line 11792
                      tot = 1;
#line 11793
                      ptr->numterms = (short )((int )ptr->numterms + 1);
#line 11794
                      if ((int )ptr->numterms == 1) {
#line 11795
                        tmp___13 = safe_malloc(sizeof(TEBOX ));
#line 11795
                        tmp___12 = (struct termbox *)tmp___13;
#line 11795
                        (ptr->tileptr)->termsptr = tmp___12;
#line 11795
                        term = tmp___12;
                      } else {
#line 11798
                        tmp___15 = safe_malloc(sizeof(TEBOX ));
#line 11798
                        tmp___14 = (struct termbox *)tmp___15;
#line 11798
                        term->nextterm = tmp___14;
#line 11798
                        term = tmp___14;
                      }
#line 11801
                      term->nextterm = (struct termbox *)((void *)0);
#line 11802
                      pinctr ++;
#line 11802
                      term->cellterm = pinctr;
#line 11803
                      term->ue = (short)0;
#line 11804
                      saveptr = (*(netarray + netx))->netptr;
#line 11805
                      tmp___17 = safe_malloc(sizeof(NBOX ));
#line 11805
                      tmp___16 = (struct netbox *)tmp___17;
#line 11805
                      (*(netarray + netx))->netptr = tmp___16;
#line 11805
                      netptr = tmp___16;
#line 11807
                      netptr->nterm = saveptr;
#line 11808
                      netptr->terminal = pinctr;
#line 11809
                      netptr->net = (short )netx;
#line 11810
                      netptr->xpos = 0;
#line 11811
                      netptr->ypos = 0;
#line 11812
                      netptr->newx = 0;
#line 11813
                      netptr->newy = 0;
#line 11814
                      netptr->flag = (char)0;
#line 11815
                      netptr->cell = (short )(cell___0 + terms);
#line 11816
                      if (pin_layers_given != 0) {
#line 11817
                        fscanf(fp, " %s ", input);
#line 11818
                        fscanf(fp, " %d ", & layer);
                      }
#line 11820
                      fscanf(fp, " %d %d ", & xpos, & ypos);
#line 11821
                      totx = xpos;
#line 11822
                      toty = ypos;
#line 11823
                      term->txpos[0] = (short )xpos;
#line 11824
                      term->typos[0] = (short )ypos;
                    } else {
#line 11826
                      implicit_feed_count ++;
#line 11827
                      if (pin_layers_given != 0) {
#line 11828
                        fscanf(fp, " %s ", input);
#line 11829
                        fscanf(fp, " %d ", & layer);
                      }
#line 11831
                      fscanf(fp, " %d %d ", & xpos, & ypos);
                    }
                  } else {
#line 11833
                    tmp___42 = strcmp((char const   *)(input), "equiv");
#line 11833
                    if (tmp___42 == 0) {
#line 11834
                      fscanf(fp, " %s ", input);
#line 11835
                      fscanf(fp, " %s ", input);
#line 11836
                      if (pin_layers_given != 0) {
#line 11837
                        fscanf(fp, " %s ", input);
#line 11838
                        fscanf(fp, " %d ", & layer);
                      }
#line 11840
                      fscanf(fp, " %d %d ", & xpos, & ypos);
#line 11841
                      tmp___19 = strcmp((char const   *)(netname), "TW_PASS_THRU");
#line 11841
                      if (tmp___19 != 0) {
#line 11842
                        tot ++;
#line 11843
                        totx += xpos;
#line 11844
                        toty += ypos;
#line 11845
                        term->txpos[0] = (short )(totx / tot);
#line 11846
                        if (terms == 0) {
#line 11847
                          term->typos[0] = (short)0;
                        } else {
#line 11849
                          term->typos[0] = (short )(toty / tot);
                        }
                      }
                    } else {
#line 11852
                      tmp___41 = strcmp((char const   *)(input), "unequiv");
#line 11852
                      if (tmp___41 == 0) {
#line 11853
                        fscanf(fp, " %s ", input);
#line 11854
                        fscanf(fp, " %s ", input);
#line 11855
                        if (pin_layers_given != 0) {
#line 11856
                          fscanf(fp, " %s ", input);
#line 11857
                          fscanf(fp, " %d ", & layer);
                        }
#line 11859
                        fscanf(fp, " %d %d ", & xpos, & ypos);
#line 11860
                        tot ++;
#line 11861
                        totx += xpos;
#line 11862
                        term->txpos[0] = (short )(totx / tot);
#line 11863
                        term->typos[0] = (short)0;
#line 11864
                        term->ue = (short)1;
                      } else {
#line 11865
                        tmp___40 = strcmp((char const   *)(input), "pad");
#line 11865
                        if (tmp___40 == 0) {
#line 11866
                          terms ++;
#line 11867
                          fscanf(fp, " %s ", input);
#line 11868
                          fscanf(fp, " %s ", input);
#line 11869
                          ptr = *(carray + (numcells + terms));
#line 11870
                          tmp___20 = strlen((char const   *)(input));
#line 11870
                          tmp___21 = safe_malloc((tmp___20 + 1U) * sizeof(char ));
#line 11870
                          ptr->cname = tmp___21;
#line 11872
                          sprintf(ptr->cname, "%s", input);
#line 11873
                          ptr->cclass = (short)0;
#line 11874
                          ptr->orflag = (char)0;
                        } else {
#line 11875
                          tmp___39 = strcmp((char const   *)(input), "orient");
#line 11875
                          if (tmp___39 == 0) {
#line 11876
                            fscanf(fp, " %d ", & orient);
#line 11877
                            ptr->corient = (char )orient;
                          } else {
#line 11878
                            tmp___38 = strcmp((char const   *)(input), "padside");
#line 11878
                            if (tmp___38 == 0) {
#line 11879
                              fscanf(fp, " %s ", input);
#line 11880
                              tmp___36 = strcmp((char const   *)(input), "L");
#line 11880
                              if (tmp___36 == 0) {
#line 11881
                                ptr->padside = (short)1;
                              } else {
#line 11882
                                tmp___35 = strcmp((char const   *)(input), "T");
#line 11882
                                if (tmp___35 == 0) {
#line 11883
                                  ptr->padside = (short)2;
                                } else {
#line 11884
                                  tmp___34 = strcmp((char const   *)(input), "R");
#line 11884
                                  if (tmp___34 == 0) {
#line 11885
                                    ptr->padside = (short)3;
                                  } else {
#line 11886
                                    tmp___33 = strcmp((char const   *)(input), "B");
#line 11886
                                    if (tmp___33 == 0) {
#line 11887
                                      ptr->padside = (short)4;
                                    } else {
#line 11888
                                      tmp___32 = strcmp((char const   *)(input), "MUL");
#line 11888
                                      if (tmp___32 == 0) {
#line 11889
                                        ptr->padside = (short)5;
                                      } else {
#line 11890
                                        tmp___31 = strcmp((char const   *)(input),
                                                          "MUR");
#line 11890
                                        if (tmp___31 == 0) {
#line 11891
                                          ptr->padside = (short)6;
                                        } else {
#line 11892
                                          tmp___30 = strcmp((char const   *)(input),
                                                            "MLL");
#line 11892
                                          if (tmp___30 == 0) {
#line 11893
                                            ptr->padside = (short)7;
                                          } else {
#line 11894
                                            tmp___29 = strcmp((char const   *)(input),
                                                              "MLR");
#line 11894
                                            if (tmp___29 == 0) {
#line 11895
                                              ptr->padside = (short)8;
                                            } else {
#line 11896
                                              tmp___28 = strcmp((char const   *)(input),
                                                                "ML");
#line 11896
                                              if (tmp___28 == 0) {
#line 11897
                                                ptr->padside = (short)9;
                                              } else {
#line 11898
                                                tmp___27 = strcmp((char const   *)(input),
                                                                  "MR");
#line 11898
                                                if (tmp___27 == 0) {
#line 11899
                                                  ptr->padside = (short)10;
                                                } else {
#line 11900
                                                  tmp___26 = strcmp((char const   *)(input),
                                                                    "MB");
#line 11900
                                                  if (tmp___26 == 0) {
#line 11901
                                                    printf("macro at position MB is no longer supported -- sorry!\n");
#line 11902
                                                    exit(1);
#line 11903
                                                    ptr->padside = (short)11;
                                                  } else {
#line 11904
                                                    tmp___25 = strcmp((char const   *)(input),
                                                                      "MT");
#line 11904
                                                    if (tmp___25 == 0) {
#line 11905
                                                      printf("macro at position MT is no longer supported -- sorry!\n");
#line 11906
                                                      exit(1);
#line 11907
                                                      ptr->padside = (short)12;
                                                    } else {
#line 11908
                                                      tmp___24 = strcmp((char const   *)(input),
                                                                        "MM");
#line 11908
                                                      if (tmp___24 == 0) {
#line 11909
                                                        printf("macro at position MM is no longer supported -- sorry!\n");
#line 11910
                                                        exit(1);
#line 11911
                                                        ptr->padside = (short)13;
                                                      } else {
#line 11912
                                                        tmp___23 = strcmp((char const   *)(input),
                                                                          "MTT");
#line 11912
                                                        if (tmp___23 == 0) {
#line 11913
                                                          ptr->padside = (short)14;
                                                        } else {
#line 11914
                                                          tmp___22 = strcmp((char const   *)(input),
                                                                            "MBB");
#line 11914
                                                          if (tmp___22 == 0) {
#line 11915
                                                            ptr->padside = (short)15;
                                                          } else {
#line 11917
                                                            fprintf(fpo, "padside not specified properly for ");
#line 11918
                                                            fprintf(fpo, "pad: %s\n",
                                                                    ptr->cname);
#line 11919
                                                            exit(1);
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            } else {
#line 11921
                              tmp___37 = strcmp((char const   *)(input), "sidespace");
#line 11921
                              if (tmp___37 == 0) {
#line 11922
                                fscanf(fp, " %lf ", & space___0);
#line 11923
                                if ((int )ptr->padside == 1) {
#line 11924
                                  *(fixLRBT + 0) = 1;
#line 11925
                                  *(padspace + terms) = space___0;
                                } else {
#line 11926
                                  if ((int )ptr->padside == 3) {
#line 11927
                                    *(fixLRBT + 1) = 1;
#line 11928
                                    *(padspace + terms) = space___0;
                                  } else {
#line 11929
                                    if ((int )ptr->padside == 4) {
#line 11930
                                      *(fixLRBT + 2) = 1;
#line 11931
                                      *(padspace + terms) = space___0;
                                    } else {
#line 11932
                                      if ((int )ptr->padside == 2) {
#line 11933
                                        *(fixLRBT + 3) = 1;
#line 11934
                                        *(padspace + terms) = space___0;
                                      } else {
#line 11936
                                        macspace[ptr->padside] = space___0;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 11940
  cell___0 = 1;
#line 11940
  while (cell___0 <= numcells) {
#line 11941
    if ((int )(*(carray + cell___0))->orflag == 1) {
#line 11942
      if (maxCellO == 0) {
#line 11943
        maxCellO = 2;
      } else {
#line 11944
        if (maxCellO == 1) {
#line 11945
          maxCellO = 3;
        }
      }
#line 11947
      break;
    }
#line 11940
    cell___0 ++;
  }
#line 11950
  cell___0 = 1;
#line 11950
  while (cell___0 <= numcells) {
#line 11951
    ptr = *(carray + cell___0);
#line 11952
    tptr = ptr->tileptr;
#line 11953
    tmptr = tptr->termsptr;
#line 11953
    while ((unsigned int )tmptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 11955
      if ((int )ptr->clength % 2 != 0) {
#line 11956
        tmptr->txpos[1] = (short )(- ((int )tmptr->txpos[0]) + 1);
      } else {
#line 11958
        tmptr->txpos[1] = (short )(- ((int )tmptr->txpos[0]));
      }
#line 11960
      if ((int )ptr->cheight % 2 != 0) {
#line 11961
        tmptr->typos[1] = (short )(- ((int )tmptr->typos[0]) + 1);
      } else {
#line 11963
        tmptr->typos[1] = (short )(- ((int )tmptr->typos[0]));
      }
#line 11953
      tmptr = tmptr->nextterm;
    }
#line 11950
    cell___0 ++;
  }
#line 11967
  cell___0 = numcells + 1;
#line 11967
  while (cell___0 <= numcells + numterms) {
#line 11968
    ptr = *(carray + cell___0);
#line 11969
    tptr = ptr->tileptr;
#line 11970
    orient = (int )ptr->corient;
#line 11971
    move(orient);
#line 11972
    rect(& tptr->left, & tptr->bottom, & tptr->right, & tptr->top);
#line 11974
    if ((int )ptr->cheight % 2 != 0) {
#line 11974
      if (orient == 4) {
#line 11976
        tptr->left = (short )((int )tptr->left + 1);
#line 11977
        tptr->right = (short )((int )tptr->right + 1);
      } else {
#line 11974
        if (orient == 6) {
#line 11976
          tptr->left = (short )((int )tptr->left + 1);
#line 11977
          tptr->right = (short )((int )tptr->right + 1);
        } else {
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
#line 11974
      if ((int )ptr->clength % 2 != 0) {
#line 11974
        if (orient == 2) {
#line 11976
          tptr->left = (short )((int )tptr->left + 1);
#line 11977
          tptr->right = (short )((int )tptr->right + 1);
        } else {
#line 11974
          if (orient == 3) {
#line 11976
            tptr->left = (short )((int )tptr->left + 1);
#line 11977
            tptr->right = (short )((int )tptr->right + 1);
          }
        }
      }
    }
#line 11979
    if ((int )ptr->cheight % 2 != 0) {
#line 11979
      if (orient == 1) {
#line 11981
        tptr->bottom = (short )((int )tptr->bottom + 1);
#line 11982
        tptr->top = (short )((int )tptr->top + 1);
      } else {
#line 11979
        if (orient == 3) {
#line 11981
          tptr->bottom = (short )((int )tptr->bottom + 1);
#line 11982
          tptr->top = (short )((int )tptr->top + 1);
        } else {
          goto _L___0;
        }
      }
    } else {
      _L___0: /* CIL Label */ 
#line 11979
      if ((int )ptr->clength % 2 != 0) {
#line 11979
        if (orient == 4) {
#line 11981
          tptr->bottom = (short )((int )tptr->bottom + 1);
#line 11982
          tptr->top = (short )((int )tptr->top + 1);
        } else {
#line 11979
          if (orient == 7) {
#line 11981
            tptr->bottom = (short )((int )tptr->bottom + 1);
#line 11982
            tptr->top = (short )((int )tptr->top + 1);
          }
        }
      }
    }
#line 11984
    tmptr = tptr->termsptr;
#line 11984
    while ((unsigned int )tmptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 11986
      tmptr->txpos[1] = tmptr->txpos[0];
#line 11987
      tmptr->typos[1] = tmptr->typos[0];
#line 11988
      point(& tmptr->txpos[1], & tmptr->typos[1]);
#line 11989
      if ((int )ptr->cheight % 2 != 0) {
#line 11989
        if (orient == 4) {
#line 11991
          tmptr->txpos[1] = (short )((int )tmptr->txpos[1] + 1);
        } else {
#line 11989
          if (orient == 6) {
#line 11991
            tmptr->txpos[1] = (short )((int )tmptr->txpos[1] + 1);
          } else {
            goto _L___1;
          }
        }
      } else {
        _L___1: /* CIL Label */ 
#line 11989
        if ((int )ptr->clength % 2 != 0) {
#line 11989
          if (orient == 2) {
#line 11991
            tmptr->txpos[1] = (short )((int )tmptr->txpos[1] + 1);
          } else {
#line 11989
            if (orient == 3) {
#line 11991
              tmptr->txpos[1] = (short )((int )tmptr->txpos[1] + 1);
            }
          }
        }
      }
#line 11993
      if ((int )ptr->cheight % 2 != 0) {
#line 11993
        if (orient == 1) {
#line 11995
          tmptr->typos[1] = (short )((int )tmptr->typos[1] + 1);
        } else {
#line 11993
          if (orient == 3) {
#line 11995
            tmptr->typos[1] = (short )((int )tmptr->typos[1] + 1);
          } else {
            goto _L___2;
          }
        }
      } else {
        _L___2: /* CIL Label */ 
#line 11993
        if ((int )ptr->clength % 2 != 0) {
#line 11993
          if (orient == 4) {
#line 11995
            tmptr->typos[1] = (short )((int )tmptr->typos[1] + 1);
          } else {
#line 11993
            if (orient == 7) {
#line 11995
              tmptr->typos[1] = (short )((int )tmptr->typos[1] + 1);
            }
          }
        }
      }
#line 11984
      tmptr = tmptr->nextterm;
    }
#line 11967
    cell___0 ++;
  }
#line 11999
  configure();
#line 12000
  tmp___52 = safe_realloc((char *)carray, (unsigned int )((1 + numcells) + numterms) * sizeof(CBOXPTR ));
#line 12000
  carray = (CBOXPTR *)tmp___52;
#line 12002
  block___0 = 1;
#line 12002
  while (block___0 <= numblock) {
#line 12003
    totallen += (int )(*(barray + block___0))->blength;
#line 12002
    block___0 ++;
  }
#line 12005
  fprintf(fpo, "total cell length: %d\n", celllen);
#line 12006
  fprintf(fpo, "total block length: %d\n", totallen);
#line 12007
  return 0;
}
}
#line 12012 "D:/a/test/300.c"
int readnets(FILE *fp ) 
{ int net ;
  int test ;
  int status ;
  double Hweight ;
  double Vweight ;
  double beta ;
  double total_weight ;
  NBOXPTR netptr ;
  char input[1024] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 12019
  fscanf(fp, " %s ", input);
#line 12020
  tmp = strcmp((char const   *)(input), "allnets");
#line 12020
  if (tmp != 0) {
#line 12021
    fprintf(fpo, "The keyword allnets was ");
#line 12022
    fprintf(fpo, "not properly entered in the .net file\n");
#line 12023
    exit(1);
  }
#line 12025
  fscanf(fp, " %s ", input);
#line 12026
  tmp___0 = strcmp((char const   *)(input), "HVweights");
#line 12026
  if (tmp___0 != 0) {
#line 12027
    fprintf(fpo, "The keyword HVweights was ");
#line 12028
    fprintf(fpo, "not properly entered in the .net file\n");
#line 12029
    exit(1);
  }
#line 12031
  test = fscanf(fp, "%lf %lf", & Hweight, & Vweight);
#line 12032
  if (test != 2) {
#line 12033
    fprintf(fpo, "The net weights for allnets were ");
#line 12034
    fprintf(fpo, "not properly entered in the .net file\n");
#line 12035
    exit(1);
  }
#line 12037
  if (Hweight <= 0.0) {
#line 12038
    fprintf(fpo, "A global net weight was ");
#line 12039
    fprintf(fpo, "zero or negative in the \n");
#line 12040
    fprintf(fpo, ".net file\n");
#line 12041
    fprintf(fpo, "This is not allowed; choose .0001 instead\n");
#line 12042
    exit(1);
  } else {
#line 12037
    if (Vweight <= 0.0) {
#line 12038
      fprintf(fpo, "A global net weight was ");
#line 12039
      fprintf(fpo, "zero or negative in the \n");
#line 12040
      fprintf(fpo, ".net file\n");
#line 12041
      fprintf(fpo, "This is not allowed; choose .0001 instead\n");
#line 12042
      exit(1);
    }
  }
#line 12044
  if (Vweight < 1.0) {
#line 12045
    Vweight = 1.0;
  }
#line 12047
  net = 1;
#line 12047
  while (net <= numnets) {
#line 12048
    (*(netarray + net))->Hweight = Hweight;
#line 12049
    (*(netarray + net))->Vweight = Vweight;
#line 12047
    net ++;
  }
#line 12051
  while (1) {
#line 12051
    tmp___5 = fscanf(fp, " %s ", input);
#line 12051
    if (! (tmp___5 == 1)) {
#line 12051
      break;
    }
#line 12052
    tmp___4 = strcmp((char const   *)(input), "net");
#line 12052
    if (tmp___4 == 0) {
#line 12053
      fscanf(fp, " %s ", input);
#line 12054
      status = hashfind(input);
#line 12055
      if (status == 0) {
#line 12056
        fprintf(fpo, "The net named: %s  in the .net file\n", input);
#line 12058
        fprintf(fpo, "was not encountered while reading\n");
#line 12059
        fprintf(fpo, "the .cel file --- FATAL error\n");
#line 12060
        exit(1);
      }
    } else {
#line 12062
      tmp___3 = strcmp((char const   *)(input), "HVweights");
#line 12062
      if (tmp___3 == 0) {
#line 12063
        test = fscanf(fp, "%lf %lf", & Hweight, & Vweight);
#line 12064
        if (test != 2) {
#line 12065
          fprintf(fpo, "The critical net weights were ");
#line 12066
          fprintf(fpo, "not properly entered\n");
#line 12067
          fprintf(fpo, "in the .net file after net: %s\n", input);
#line 12069
          exit(1);
        }
#line 12071
        if (Hweight <= 0.0) {
#line 12072
          fprintf(fpo, "A critical net weight was ");
#line 12073
          fprintf(fpo, "zero or negative in the \n");
#line 12074
          fprintf(fpo, ".net file after net: %s\n", input);
#line 12075
          fprintf(fpo, "This is not allowed; choose .0001 instead\n");
#line 12076
          exit(1);
        } else {
#line 12071
          if (Vweight <= 0.0) {
#line 12072
            fprintf(fpo, "A critical net weight was ");
#line 12073
            fprintf(fpo, "zero or negative in the \n");
#line 12074
            fprintf(fpo, ".net file after net: %s\n", input);
#line 12075
            fprintf(fpo, "This is not allowed; choose .0001 instead\n");
#line 12076
            exit(1);
          }
        }
#line 12078
        (*(netarray + status))->Hweight = Hweight;
#line 12079
        (*(netarray + status))->Vweight = Vweight;
      } else {
#line 12080
        tmp___2 = strcmp((char const   *)(input), "nofeeds");
#line 12080
        if (tmp___2 == 0) {
#line 12081
          (*(netarray + status))->feedflag = (char)1;
        } else {
#line 12082
          tmp___1 = strcmp((char const   *)(input), "ignore");
#line 12082
          if (tmp___1 == 0) {
#line 12083
            (*(netarray + status))->ignore = (char)1;
          } else {
#line 12085
            fprintf(fpo, "unexpected keyword in the .net file\n");
#line 12086
            exit(1);
          }
        }
      }
    }
  }
#line 12089
  delHtab();
#line 12090
  if (! no_net_normalize) {
#line 12091
    total_weight = (double )0;
#line 12092
    net = 1;
#line 12092
    while (net <= numnets) {
#line 12093
      total_weight += (*(netarray + net))->Hweight + (*(netarray + net))->Vweight;
#line 12092
      net ++;
    }
#line 12095
    beta = (2.0 * (double )numnets) / total_weight;
#line 12096
    net = 1;
#line 12096
    while (net <= numnets) {
#line 12097
      (*(netarray + net))->Hweight *= beta;
#line 12098
      (*(netarray + net))->Vweight *= beta;
#line 12096
      net ++;
    }
  }
#line 12101
  net = 1;
#line 12101
  while (net <= numnets) {
#line 12102
    netptr = (*(netarray + net))->netptr;
#line 12102
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 12104
      *(tearray + netptr->terminal) = netptr;
#line 12105
      (*(tearray + netptr->terminal))->net = (short )net;
#line 12102
      netptr = netptr->nterm;
    }
#line 12101
    net ++;
  }
#line 12108
  return 0;
}
}
#line 12112 "D:/a/test/300.c"
int readParFile(void) 
{ FILE *fp ;
  char filename[64] ;
  char input[64] ;
  int test ;
  double f ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
#line 12118
  sprintf(filename, "%s.par", cktName);
#line 12119
  tmp = (int )openFile(filename, "r", 1);
#line 12119
  fp = (FILE *)tmp;
#line 12120
  route2act = -1;
#line 12121
  routeGrid = -1;
#line 12122
  gridCell = -1;
#line 12123
  while (1) {
#line 12123
    tmp___26 = fscanf(fp, " %s ", input);
#line 12123
    if (! (tmp___26 == 1)) {
#line 12123
      break;
    }
#line 12124
    tmp___25 = strcmp((char const   *)(input), "implicit.feed.thru.range");
#line 12124
    if (tmp___25 == 0) {
#line 12125
      test = fscanf(fp, " %lf ", & imprange);
#line 12126
      if (test != 1) {
#line 12127
        fprintf(fpo, "The value of implicit.feed.thru.range");
#line 12128
        fprintf(fpo, " was not properly");
#line 12129
        fprintf(fpo, "entered in the .par file\n");
#line 12130
        exit(1);
      }
    } else {
#line 12132
      tmp___24 = strcmp((char const   *)(input), "fast");
#line 12132
      if (tmp___24 == 0) {
#line 12133
        test = fscanf(fp, " %d ", & tw_fast);
#line 12134
        if (test != 1) {
#line 12135
          fprintf(fpo, "The value of fast was not ");
#line 12136
          fprintf(fpo, "properly entered in the .par file\n");
#line 12137
          exit(1);
        }
      } else {
#line 12139
        tmp___23 = strcmp((char const   *)(input), "slow");
#line 12139
        if (tmp___23 == 0) {
#line 12140
          test = fscanf(fp, " %d ", & tw_slow);
#line 12141
          if (test != 1) {
#line 12142
            fprintf(fpo, "The value of fast was not ");
#line 12143
            fprintf(fpo, "properly entered in the .par file\n");
#line 12144
            exit(1);
          }
        } else {
#line 12146
          tmp___22 = strcmp((char const   *)(input), "pin_layers_given");
#line 12146
          if (tmp___22 == 0) {
#line 12147
            pin_layers_given = 1;
          } else {
#line 12148
            tmp___21 = strcmp((char const   *)(input), "gate_array_special");
#line 12148
            if (tmp___21 == 0) {
#line 12149
              gate_array_special = 1;
            } else {
#line 12150
              tmp___20 = strcmp((char const   *)(input), "connection_machine");
#line 12150
              if (tmp___20 == 0) {
#line 12151
                connection_machine = 1;
              } else {
#line 12152
                tmp___19 = strcmp((char const   *)(input), "no_feeds_side_nets");
#line 12152
                if (tmp___19 == 0) {
#line 12153
                  no_feeds_side_nets = 0;
                } else {
#line 12154
                  tmp___18 = strcmp((char const   *)(input), "no_net_normalize");
#line 12154
                  if (tmp___18 == 0) {
#line 12155
                    no_net_normalize = 1;
                  } else {
#line 12156
                    tmp___17 = strcmp((char const   *)(input), "estimate_feeds");
#line 12156
                    if (tmp___17 == 0) {
#line 12157
                      estimate_feeds = 1;
                    } else {
#line 12158
                      tmp___16 = strcmp((char const   *)(input), "cost_only");
#line 12158
                      if (tmp___16 == 0) {
#line 12159
                        costonly = 1;
                      } else {
#line 12160
                        tmp___15 = strcmp((char const   *)(input), "do.global.route");
#line 12160
                        if (tmp___15 == 0) {
#line 12161
                          doglobal = 1;
                        } else {
#line 12162
                          tmp___14 = strcmp((char const   *)(input), "do.global.route.cell.swaps");
#line 12162
                          if (tmp___14 == 0) {
#line 12163
                            cswaps = 1;
#line 12164
                            stopdeg = 0.3;
                          } else {
#line 12165
                            tmp___13 = strcmp((char const   *)(input), "full");
#line 12165
                            if (tmp___13 == 0) {
#line 12166
                              if (cswaps) {
#line 12167
                                stopdeg = 0.5;
                              }
                            } else {
#line 12169
                              tmp___12 = strcmp((char const   *)(input), "feedThruWidth");
#line 12169
                              if (tmp___12 == 0) {
#line 12170
                                test = fscanf(fp, " %d ", & fdWidth);
#line 12171
                                if (test != 1) {
#line 12172
                                  fprintf(fpo, "The value of feedThruWidth was not ");
#line 12173
                                  fprintf(fpo, "properly entered in the .par file\n");
#line 12174
                                  exit(1);
                                }
                              } else {
#line 12176
                                tmp___11 = strcmp((char const   *)(input), "layer");
#line 12176
                                if (tmp___11 == 0) {
#line 12177
                                  test = fscanf(fp, " %d ", & feedLayer);
#line 12178
                                  if (test != 1) {
#line 12179
                                    fprintf(fpo, "The value of layer was not ");
#line 12180
                                    fprintf(fpo, "properly entered in the .par file\n");
#line 12181
                                    exit(1);
                                  }
#line 12183
                                  if (feedLayer != 1) {
#line 12183
                                    if (feedLayer != 2) {
#line 12183
                                      if (feedLayer != 3) {
#line 12184
                                        fprintf(fpo, "The value of layer must currently be one of ");
#line 12185
                                        fprintf(fpo, "1, 2, or 3 \n");
#line 12186
                                        exit(1);
                                      } else {
#line 12188
                                        feedLayer --;
                                      }
                                    } else {
#line 12188
                                      feedLayer --;
                                    }
                                  } else {
#line 12188
                                    feedLayer --;
                                  }
                                } else {
#line 12190
                                  tmp___10 = strcmp((char const   *)(input), "addFeeds");
#line 12190
                                  if (tmp___10 == 0) {
#line 12191
                                    addFeeds = 1;
                                  } else {
#line 12192
                                    tmp___9 = strcmp((char const   *)(input), "indent");
#line 12192
                                    if (tmp___9 == 0) {
#line 12193
                                      test = fscanf(fp, " %lf ", & indent);
#line 12194
                                      indent = 1.0;
                                    } else {
#line 12196
                                      tmp___8 = strcmp((char const   *)(input), "random.seed");
#line 12196
                                      if (tmp___8 == 0) {
#line 12197
                                        test = fscanf(fp, " %d ", & randomSeed);
#line 12198
                                        if (test != 1) {
#line 12199
                                          fprintf(fpo, "The value of random.seed was not ");
#line 12200
                                          fprintf(fpo, "properly entered in the .par file\n");
#line 12201
                                          exit(1);
                                        }
                                      } else {
#line 12203
                                        tmp___7 = strcmp((char const   *)(input),
                                                         "random.seed2");
#line 12203
                                        if (tmp___7 == 0) {
#line 12204
                                          test = fscanf(fp, " %d ", & randomSeed2);
#line 12205
                                          if (test != 1) {
#line 12206
                                            fprintf(fpo, "The value of random.seed2 was not ");
#line 12207
                                            fprintf(fpo, "properly entered in the .par file\n");
#line 12208
                                            exit(1);
                                          }
                                        } else {
#line 12210
                                          tmp___6 = strcmp((char const   *)(input),
                                                           "rowSep");
#line 12210
                                          if (tmp___6 == 0) {
#line 12211
                                            test = fscanf(fp, " %lf ", & rowSep);
#line 12212
                                            if (test != 1) {
#line 12213
                                              fprintf(fpo, "The value of rowSep was not properly");
#line 12214
                                              fprintf(fpo, "entered in the .par file\n");
#line 12215
                                              exit(1);
                                            }
                                          } else {
#line 12217
                                            tmp___5 = strcmp((char const   *)(input),
                                                             "restart");
#line 12217
                                            if (tmp___5 == 0) {
#line 12218
                                              resume_run = 1;
                                            } else {
#line 12219
                                              tmp___4 = strcmp((char const   *)(input),
                                                               "track.spacing");
#line 12219
                                              if (tmp___4 == 0) {
#line 12220
                                                uneven_cell_height = 1;
#line 12221
                                                test = fscanf(fp, " %d ", & track_spacing);
#line 12222
                                                if (test != 1) {
#line 12223
                                                  fprintf(fpo, "The value of trackSpacing was not properly");
#line 12224
                                                  fprintf(fpo, "entered in the .par file\n");
#line 12225
                                                  exit(1);
                                                }
                                              } else {
#line 12227
                                                tmp___3 = strcmp((char const   *)(input),
                                                                 "one.pin.feedthru");
#line 12227
                                                if (tmp___3 == 0) {
#line 12228
                                                  one_pin_feedthru = 1;
                                                } else {
#line 12229
                                                  tmp___2 = strcmp((char const   *)(input),
                                                                   "route2act");
#line 12229
                                                  if (tmp___2 == 0) {
#line 12230
                                                    test = fscanf(fp, " %d ", & route2act);
#line 12231
                                                    if (test != 1) {
#line 12232
                                                      fprintf(fpo, "The value of route2act was not properly");
#line 12233
                                                      fprintf(fpo, "entered in the .par file\n");
#line 12234
                                                      exit(1);
                                                    }
                                                  } else {
#line 12236
                                                    tmp___1 = strcmp((char const   *)(input),
                                                                     "gridCell");
#line 12236
                                                    if (tmp___1 == 0) {
#line 12237
                                                      test = fscanf(fp, " %d ", & gridCell);
#line 12238
                                                      if (test != 1) {
#line 12239
                                                        fprintf(fpo, "The value of gridCell was not properly");
#line 12240
                                                        fprintf(fpo, "entered in the .par file\n");
#line 12241
                                                        exit(1);
                                                      }
                                                    } else {
#line 12243
                                                      tmp___0 = strcmp((char const   *)(input),
                                                                       "routeGrid");
#line 12243
                                                      if (tmp___0 == 0) {
#line 12244
                                                        test = fscanf(fp, " %d ",
                                                                      & routeGrid);
#line 12245
                                                        if (test != 1) {
#line 12246
                                                          fprintf(fpo, "The value of routeGrid was not properly");
#line 12247
                                                          fprintf(fpo, "entered in the .par file\n");
#line 12248
                                                          exit(1);
                                                        }
                                                      } else {
#line 12251
                                                        fprintf(fpo, "Unparsable keyword>>> %s\n",
                                                                input);
#line 12252
                                                        fprintf(fpo, "was found in the .par file\n");
#line 12253
                                                        exit(1);
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 12256
  fclose(fp);
#line 12257
  sprintf(filename, "%s.rs2", cktName);
#line 12258
  tmp___27 = (int )openFile(filename, "r", 0);
#line 12258
  fp = (FILE *)tmp___27;
#line 12258
  if (fp) {
#line 12258
    if (resume_run == 1) {
#line 12259
      fscanf(fp, "%lf", & f);
#line 12260
      fscanf(fp, "%d", & stage);
#line 12261
      fscanf(fp, "%d", & stage);
#line 12262
      fscanf(fp, "%d", & stage);
#line 12263
      fprintf(fpo, "\n\nNOTE: Restart file .rs2 will be used \n\n");
#line 12264
      fclose(fp);
#line 12265
      restart = 1;
    } else {
#line 12267
      stage = 1;
#line 12268
      fprintf(fpo, "\n\nNOTE: Restart file .rs2 not used\n\n");
#line 12269
      restart = 0;
    }
  } else {
#line 12267
    stage = 1;
#line 12268
    fprintf(fpo, "\n\nNOTE: Restart file .rs2 not used\n\n");
#line 12269
    restart = 0;
  }
#line 12271
  if (cswaps != 0) {
#line 12272
    if (doglobal == 0) {
#line 12273
      fprintf(fpo, "user specified cell swaps ");
#line 12274
      fprintf(fpo, "without requesting do.global.route\n");
#line 12275
      exit(1);
    }
  }
#line 12278
  if (doglobal) {
#line 12279
    fprintf(fpo, "TimberWolf will perform a global route step\n");
  }
#line 12281
  if (cswaps) {
#line 12282
    fprintf(fpo, "TimberWolf will perform final cell placements\n");
#line 12283
    fprintf(fpo, " by swapping cells based on minimization of\n");
#line 12284
    fprintf(fpo, " the total number of routing tracks required\n");
  }
#line 12286
  if (addFeeds) {
#line 12286
    if (imprange < 0.0) {
#line 12287
      fprintf(fpo, "implicit.feed.thru.range was ");
#line 12288
      fprintf(fpo, "not entered in the .par file\n");
#line 12289
      exit(1);
    }
  }
#line 12291
  if (rowSep < 0.0) {
#line 12292
    fprintf(fpo, "rowSep was not entered in the .par file\n");
#line 12293
    exit(1);
  } else {
#line 12295
    fprintf(fpo, "rowSep: %f\n", rowSep);
  }
#line 12297
  if (addFeeds == 1) {
#line 12297
    if (fdWidth == -1) {
#line 12298
      fprintf(fpo, "feedThruWidth was not entered in the .par file\n");
#line 12299
      exit(1);
    } else {
#line 12301
      fprintf(fpo, "feedThruWidth: %d\n", fdWidth);
    }
  } else {
#line 12301
    fprintf(fpo, "feedThruWidth: %d\n", fdWidth);
  }
#line 12329
  return 0;
}
}
#line 12336 "D:/a/test/300.c"
int readseg(FILE *fp ) 
{ int segment ;
  int net ;
  int net1 ;
  int net2 ;
  int key_flag ;
  int channel ;
  int pin1 ;
  int pin2 ;
  int ltop ;
  int rtop ;
  int lbot ;
  int rbot ;
  int Tleft ;
  int Tright ;
  int Bleft ;
  int Bright ;
  char input[16] ;
  SEGBOXPTR tmp_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 12345
  segment = 0;
#line 12346
  numSwSegs = 0;
#line 12347
  numSegs = 0;
#line 12348
  while (1) {
#line 12348
    tmp___2 = fscanf(fp, " %s ", input);
#line 12348
    if (! (tmp___2 == 1)) {
#line 12348
      break;
    }
#line 12349
    tmp___1 = strcmp((char const   *)(input), "net");
#line 12349
    if (tmp___1 == 0) {
#line 12350
      fscanf(fp, " %d ", & net);
    } else {
#line 12351
      tmp___0 = strcmp((char const   *)(input), "segment");
#line 12351
      if (tmp___0 == 0) {
#line 12352
        numSegs ++;
#line 12353
        fscanf(fp, " %s ", input);
#line 12354
        tmp = strcmp((char const   *)(input), "channel");
#line 12354
        if (tmp == 0) {
#line 12355
          fscanf(fp, "%d", & channel);
#line 12356
          fscanf(fp, " %s ", input);
#line 12357
          fscanf(fp, "%d", & pin1);
#line 12358
          fscanf(fp, " %s ", input);
#line 12359
          fscanf(fp, "%d", & pin2);
#line 12360
          fscanf(fp, "%d", & ltop);
#line 12361
          fscanf(fp, "%d", & rtop);
        } else {
#line 12363
          numSwSegs ++;
#line 12364
          fscanf(fp, "%d", & key_flag);
#line 12365
          fscanf(fp, " %s ", input);
#line 12366
          fscanf(fp, " %s ", input);
#line 12367
          fscanf(fp, "%d", & channel);
#line 12368
          fscanf(fp, " %s ", input);
#line 12369
          fscanf(fp, "%d", & pin1);
#line 12370
          fscanf(fp, " %s ", input);
#line 12371
          fscanf(fp, "%d", & pin2);
#line 12372
          fscanf(fp, "%d", & ltop);
#line 12373
          fscanf(fp, "%d", & rtop);
#line 12374
          fscanf(fp, " %s ", input);
#line 12375
          fscanf(fp, " %s ", input);
#line 12376
          fscanf(fp, "%d", & channel);
#line 12377
          fscanf(fp, " %s ", input);
#line 12378
          fscanf(fp, "%d", & pin1);
#line 12379
          fscanf(fp, " %s ", input);
#line 12380
          fscanf(fp, "%d", & pin2);
#line 12381
          fscanf(fp, "%d", & lbot);
#line 12382
          fscanf(fp, "%d", & rbot);
        }
      }
    }
  }
#line 12386
  fprintf(fpo, "\nTotal Number of Net Segments: %d\n", numSegs);
#line 12387
  fprintf(fpo, "Number of Switchable Net Segments: %d\n\n", numSwSegs);
#line 12388
  fprintf(fpo, "Number of channels: %d\n\n", numChans);
#line 12389
  rewind(fp);
#line 12390
  tmp___3 = safe_malloc((unsigned int )(numSegs + 1) * sizeof(SWITCHBOX ));
#line 12390
  aNetSeg = (struct switchbox *)tmp___3;
#line 12392
  tmp___4 = safe_malloc((unsigned int )(numSegs + 1) * sizeof(int ));
#line 12392
  fixnetseg = (int *)tmp___4;
#line 12393
  tmp___5 = safe_malloc((unsigned int )(numnets + 2) * sizeof(int ));
#line 12393
  anet = (int *)tmp___5;
#line 12394
  net = 0;
#line 12394
  while (net <= numnets + 1) {
#line 12395
    *(anet + net) = 0;
#line 12394
    net ++;
  }
#line 12397
  tmp___6 = safe_malloc((unsigned int )(numnets + 1) * sizeof(int ));
#line 12397
  netchgs = (int *)tmp___6;
#line 12398
  while (1) {
#line 12398
    tmp___18 = fscanf(fp, " %s ", input);
#line 12398
    if (! (tmp___18 == 1)) {
#line 12398
      break;
    }
#line 12399
    tmp___17 = strcmp((char const   *)(input), "net");
#line 12399
    if (tmp___17 == 0) {
#line 12400
      fscanf(fp, " %d ", & net);
#line 12401
      *(anet + net) = segment + 1;
    } else {
#line 12402
      tmp___16 = strcmp((char const   *)(input), "segment");
#line 12402
      if (tmp___16 == 0) {
#line 12403
        segment ++;
#line 12404
        fscanf(fp, " %s ", input);
#line 12405
        tmp___15 = strcmp((char const   *)(input), "channel");
#line 12405
        if (tmp___15 == 0) {
#line 12406
          fscanf(fp, "%d", & channel);
#line 12407
          fscanf(fp, " %s ", input);
#line 12408
          fscanf(fp, "%d", & pin1);
#line 12409
          fscanf(fp, " %s ", input);
#line 12410
          fscanf(fp, "%d", & pin2);
#line 12411
          fscanf(fp, "%d", & ltop);
#line 12412
          fscanf(fp, "%d", & rtop);
#line 12413
          tmp___7 = safe_malloc(sizeof(SEGBOX ));
#line 12413
          (aNetSeg + segment)->top = (struct segbox *)tmp___7;
#line 12415
          tmp___8 = safe_malloc(sizeof(SEGBOX ));
#line 12415
          (aNetSeg + segment)->bot = (struct segbox *)tmp___8;
#line 12417
          tmp___9 = safe_malloc(sizeof(SEGBOX ));
#line 12417
          (aNetSeg + segment)->ntop = (struct segbox *)tmp___9;
#line 12419
          tmp___10 = safe_malloc(sizeof(SEGBOX ));
#line 12419
          (aNetSeg + segment)->nbot = (struct segbox *)tmp___10;
#line 12421
          (aNetSeg + segment)->net = net;
#line 12422
          (aNetSeg + segment)->nflag = (char)0;
#line 12423
          (aNetSeg + segment)->current = (char)0;
#line 12424
          (aNetSeg + segment)->swYorN = (char)0;
#line 12425
          (aNetSeg + segment)->key = (short)0;
#line 12426
          (aNetSeg + segment)->nkey = (short)0;
#line 12427
          ((aNetSeg + segment)->top)->channel = (short )channel;
#line 12428
          ((aNetSeg + segment)->top)->pin1 = pin1;
#line 12429
          ((aNetSeg + segment)->top)->pin2 = pin2;
#line 12430
          ((aNetSeg + segment)->top)->pin1ptr = (*(Tgrid + pin1))->up;
#line 12431
          if ((int )(*(tearray + pin1))->pinloc == 0) {
#line 12431
            if ((int )(*(tearray + pin1))->row == channel) {
#line 12433
              ((aNetSeg + segment)->top)->pin1ptr = (*(Tgrid + pin1))->down;
            }
          }
#line 12435
          ((aNetSeg + segment)->top)->pin2ptr = (*(Tgrid + pin2))->up;
#line 12436
          if ((int )(*(tearray + pin2))->pinloc == 0) {
#line 12436
            if ((int )(*(tearray + pin2))->row == channel) {
#line 12438
              ((aNetSeg + segment)->top)->pin2ptr = (*(Tgrid + pin2))->down;
            }
          }
        } else {
#line 12441
          fscanf(fp, "%d", & key_flag);
#line 12442
          fscanf(fp, " %s ", input);
#line 12443
          fscanf(fp, " %s ", input);
#line 12444
          fscanf(fp, "%d", & channel);
#line 12445
          fscanf(fp, " %s ", input);
#line 12446
          fscanf(fp, "%d", & pin1);
#line 12447
          fscanf(fp, " %s ", input);
#line 12448
          fscanf(fp, "%d", & pin2);
#line 12449
          fscanf(fp, "%d", & ltop);
#line 12450
          fscanf(fp, "%d", & rtop);
#line 12451
          tmp___11 = safe_malloc(sizeof(SEGBOX ));
#line 12451
          (aNetSeg + segment)->top = (struct segbox *)tmp___11;
#line 12453
          tmp___12 = safe_malloc(sizeof(SEGBOX ));
#line 12453
          (aNetSeg + segment)->bot = (struct segbox *)tmp___12;
#line 12455
          tmp___13 = safe_malloc(sizeof(SEGBOX ));
#line 12455
          (aNetSeg + segment)->ntop = (struct segbox *)tmp___13;
#line 12457
          tmp___14 = safe_malloc(sizeof(SEGBOX ));
#line 12457
          (aNetSeg + segment)->nbot = (struct segbox *)tmp___14;
#line 12459
          (aNetSeg + segment)->net = net;
#line 12460
          (aNetSeg + segment)->nflag = (char)0;
#line 12461
          (aNetSeg + segment)->current = (char)0;
#line 12462
          (aNetSeg + segment)->swYorN = (char)1;
#line 12463
          if (key_flag == 0) {
#line 12465
            (aNetSeg + segment)->key = (short)0;
          } else {
#line 12463
            if ((*(anet + net) - 1) + key_flag == segment) {
#line 12465
              (aNetSeg + segment)->key = (short)0;
            } else {
#line 12467
              (aNetSeg + segment)->key = (short )((key_flag + *(anet + net)) - 1);
            }
          }
#line 12469
          (aNetSeg + segment)->nkey = (short)0;
#line 12470
          ((aNetSeg + segment)->top)->channel = (short )channel;
#line 12471
          ((aNetSeg + segment)->top)->pin1 = pin1;
#line 12472
          ((aNetSeg + segment)->top)->pin2 = pin2;
#line 12473
          if (ltop == -1) {
#line 12474
            pin1 = pin2;
          } else {
#line 12475
            if (ltop > 0) {
#line 12476
              pin1 = ltop;
#line 12477
              pin2 = rtop;
            }
          }
#line 12479
          Tleft = (*(tearray + pin1))->xpos;
#line 12480
          ((aNetSeg + segment)->top)->pin1ptr = (*(Tgrid + pin1))->up;
#line 12481
          if ((int )(*(tearray + pin1))->pinloc == 0) {
#line 12481
            if ((int )(*(tearray + pin1))->row == channel) {
#line 12483
              ((aNetSeg + segment)->top)->pin1ptr = (*(Tgrid + pin1))->down;
            }
          }
#line 12485
          Tright = (*(tearray + pin2))->xpos;
#line 12486
          ((aNetSeg + segment)->top)->pin2ptr = (*(Tgrid + pin2))->up;
#line 12487
          if ((int )(*(tearray + pin2))->pinloc == 0) {
#line 12487
            if ((int )(*(tearray + pin2))->row == channel) {
#line 12489
              ((aNetSeg + segment)->top)->pin2ptr = (*(Tgrid + pin2))->down;
            }
          }
#line 12491
          fscanf(fp, " %s ", input);
#line 12492
          fscanf(fp, " %s ", input);
#line 12493
          fscanf(fp, "%d", & channel);
#line 12494
          fscanf(fp, " %s ", input);
#line 12495
          fscanf(fp, "%d", & pin1);
#line 12496
          fscanf(fp, " %s ", input);
#line 12497
          fscanf(fp, "%d", & pin2);
#line 12498
          fscanf(fp, "%d", & lbot);
#line 12499
          fscanf(fp, "%d", & rbot);
#line 12500
          ((aNetSeg + segment)->bot)->channel = (short )channel;
#line 12501
          ((aNetSeg + segment)->bot)->pin1 = pin1;
#line 12502
          ((aNetSeg + segment)->bot)->pin2 = pin2;
#line 12503
          if (lbot == -1) {
#line 12504
            pin1 = pin2;
          } else {
#line 12505
            if (lbot > 0) {
#line 12506
              pin1 = lbot;
#line 12507
              pin2 = rbot;
            }
          }
#line 12509
          Bleft = (*(tearray + pin1))->xpos;
#line 12510
          ((aNetSeg + segment)->bot)->pin1ptr = (*(Tgrid + pin1))->up;
#line 12511
          if ((int )(*(tearray + pin1))->pinloc == 0) {
#line 12511
            if ((int )(*(tearray + pin1))->row == channel) {
#line 12513
              ((aNetSeg + segment)->bot)->pin1ptr = (*(Tgrid + pin1))->down;
            }
          }
#line 12515
          Bright = (*(tearray + pin2))->xpos;
#line 12516
          ((aNetSeg + segment)->bot)->pin2ptr = (*(Tgrid + pin2))->up;
#line 12517
          if ((int )(*(tearray + pin2))->pinloc == 0) {
#line 12517
            if ((int )(*(tearray + pin2))->row == channel) {
#line 12519
              ((aNetSeg + segment)->bot)->pin2ptr = (*(Tgrid + pin2))->down;
            }
          }
#line 12521
          if (Bleft == Bright) {
            goto _L;
          } else {
#line 12521
            if (Tleft == Tright) {
              _L: /* CIL Label */ 
#line 12522
              (aNetSeg + segment)->swYorN = (char)0;
#line 12523
              if (Bleft == Bright) {
#line 12523
                if (Tleft != Tright) {
#line 12524
                  tmp_ptr = (aNetSeg + segment)->top;
#line 12525
                  (aNetSeg + segment)->top = (aNetSeg + segment)->bot;
#line 12527
                  (aNetSeg + segment)->bot = tmp_ptr;
                }
              }
            }
          }
        }
      }
    }
  }
#line 12533
  net2 = net + 1;
#line 12534
  *(anet + net2) = segment + 1;
#line 12535
  net = 1;
#line 12535
  while (net < net2) {
#line 12536
    if (*(anet + net) == 0) {
#line 12537
      net1 = net + 1;
#line 12537
      while (net1 <= net2) {
#line 12538
        if (*(anet + net1) != 0) {
#line 12539
          *(anet + net) = *(anet + net1);
#line 12540
          break;
        }
#line 12537
        net1 ++;
      }
    }
#line 12535
    net ++;
  }
#line 12545
  return 0;
}
}
#line 12556 "D:/a/test/300.c"
int last_level  ;
#line 12566
double cpu_time(void) ;
#line 12568
int savewolf(int level ) ;
#line 12568 "D:/a/test/300.c"
static double last_time  =    0.0;
#line 12625
extern int ( /* missing proto */  unlink)(char *s) ;
#line 12557 "D:/a/test/300.c"
int savewolf(int level ) 
{ FILE *fp ;
  int xcenter ;
  int ycenter ;
  int cell___0 ;
  int block___0 ;
  int orient ;
  int seg ;
  char filename[64] ;
  char file1[1024] ;
  char file2[1024] ;
  CBOXPTR cellptr___0 ;
  double current_time ;
  int tmp ;

  {
#line 12570
  current_time = cpu_time();
#line 12571
  if (current_time - last_time < 600.0) {
#line 12571
    if (level == last_level) {
#line 12571
      if (level <= 1) {
#line 12573
        return 0;
      }
    }
  }
#line 12575
  last_time = current_time;
#line 12576
  last_level = level;
#line 12591
  sprintf(filename, "%s.tmp", cktName);
#line 12592
  tmp = (int )openFile(filename, "w", 1);
#line 12592
  fp = (FILE *)tmp;
#line 12594
  fprintf(fp, "%f\n", 2);
#line 12595
  fprintf(fp, "%d\n", iteration);
#line 12596
  fprintf(fp, "%d\n", ffeeds);
#line 12597
  fprintf(fp, "%d\n", level);
#line 12598
  fprintf(fp, "%f\n", binpenCon);
#line 12599
  fprintf(fp, "%f\n", roLenCon);
#line 12600
  fprintf(fp, "%f\n", cost_scale_factor);
#line 12601
  fprintf(fp, "%d\n", estimate_feeds);
#line 12602
  if (level == 3) {
#line 12603
    fprintf(fp, "%d\n", numSegs);
#line 12604
    seg = 1;
#line 12604
    while (seg <= numSegs) {
#line 12605
      fprintf(fp, "%d\n", (aNetSeg + seg)->current);
#line 12604
      seg ++;
    }
  }
#line 12608
  cell___0 = 1;
#line 12608
  while (cell___0 <= numcells + numterms) {
#line 12609
    cellptr___0 = *(carray + cell___0);
#line 12610
    orient = (int )cellptr___0->corient;
#line 12611
    block___0 = (int )cellptr___0->cblock;
#line 12612
    xcenter = cellptr___0->cxcenter;
#line 12613
    ycenter = cellptr___0->cycenter;
#line 12614
    fprintf(fp, "%d %d %d %d %d\n", cell___0, block___0, orient, xcenter, ycenter);
#line 12608
    cell___0 ++;
  }
#line 12617
  fclose(fp);
#line 12619
  sprintf(file1, "%s.tmp", cktName);
#line 12620
  if (level == 1) {
#line 12621
    sprintf(file2, "%s.sav", cktName);
  } else {
#line 12623
    sprintf(file2, "%s.sv2", cktName);
  }
#line 12625
  unlink(file2);
#line 12626
  rename((char const   *)(file1), (char const   *)(file2));
#line 12628
  return 0;
}
}
#line 12630 "D:/a/test/300.c"
int TW_oldin(FILE *fp ) 
{ int cell___0 ;
  int orient ;
  int numfds ;
  int block___0 ;
  int xcenter ;
  int ycenter ;
  int dummy ;
  CBOXPTR ptr ;
  TEBOXPTR term ;
  NBOXPTR termptr ;
  int tmp ;

  {
#line 12638
  fscanf(fp, "%lf", & T1);
#line 12639
  fscanf(fp, "%d", & iteration);
#line 12640
  fscanf(fp, "%d", & numfds);
#line 12641
  fscanf(fp, "%d", & dummy);
#line 12642
  fscanf(fp, "%lf", & binpenCon);
#line 12643
  fscanf(fp, "%lf", & roLenCon);
#line 12644
  fscanf(fp, "%lf", & cost_scale_factor);
#line 12645
  fscanf(fp, "%d", & estimate_feeds);
#line 12646
  while (1) {
#line 12646
    tmp = fscanf(fp, " %d %d %d %d %d ", & cell___0, & block___0, & orient, & xcenter,
                 & ycenter);
#line 12646
    if (! (tmp == 5)) {
#line 12646
      break;
    }
#line 12648
    ptr = *(carray + cell___0);
#line 12649
    ptr->cblock = (short )block___0;
#line 12650
    ptr->corient = (char )orient;
#line 12651
    ptr->cxcenter = xcenter;
#line 12652
    ptr->cycenter = ycenter;
#line 12653
    if (cell___0 <= numcells) {
#line 12654
      term = (ptr->tileptr)->termsptr;
#line 12654
      while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 12656
        termptr = *(tearray + term->cellterm);
#line 12657
        termptr->xpos = (int )term->txpos[orient / 2] + xcenter;
#line 12658
        termptr->ypos = (int )term->typos[orient % 2] + ycenter;
#line 12654
        term = term->nextterm;
      }
    } else {
#line 12661
      term = (ptr->tileptr)->termsptr;
#line 12661
      while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 12663
        termptr = *(tearray + term->cellterm);
#line 12664
        termptr->xpos = (int )term->txpos[1] + xcenter;
#line 12665
        termptr->ypos = (int )term->typos[1] + ycenter;
#line 12661
        term = term->nextterm;
      }
    }
  }
#line 12669
  return 0;
}
}
#line 12671 "D:/a/test/300.c"
int fixfdpos(FILE *fp ) 
{ int cell___0 ;
  int orient ;
  int numfds ;
  int dummy ;
  int number ;
  int seg ;
  int current ;
  int block___0 ;
  int xcenter ;
  int ycenter ;
  int junk ;
  double d_dummy ;
  CBOXPTR ptr ;
  char *tmp ;
  int tmp___0 ;

  {
#line 12678
  fscanf(fp, "%lf", & T1);
#line 12679
  fscanf(fp, "%d", & iteration);
#line 12680
  fscanf(fp, "%d", & numfds);
#line 12681
  fscanf(fp, "%d", & dummy);
#line 12682
  fscanf(fp, "%lf", & d_dummy);
#line 12683
  fscanf(fp, "%lf", & d_dummy);
#line 12684
  fscanf(fp, "%lf", & d_dummy);
#line 12685
  fscanf(fp, "%d", & junk);
#line 12686
  if (dummy == 3) {
#line 12687
    fscanf(fp, "%d", & number);
#line 12688
    tmp = safe_malloc((unsigned int )(number + 1) * sizeof(int ));
#line 12688
    fixarray = (int *)tmp;
#line 12689
    seg = 1;
#line 12689
    while (seg <= number) {
#line 12690
      fscanf(fp, "%d", & current);
#line 12691
      *(fixarray + seg) = current;
#line 12689
      seg ++;
    }
  }
#line 12694
  while (1) {
#line 12694
    tmp___0 = fscanf(fp, " %d %d %d %d %d ", & cell___0, & block___0, & orient, & xcenter,
                     & ycenter);
#line 12694
    if (! (tmp___0 == 5)) {
#line 12694
      break;
    }
#line 12696
    ptr = *(carray + cell___0);
#line 12697
    ptr->cxcenter = xcenter;
#line 12698
    ptr->cycenter = ycenter;
#line 12699
    ptr->corient = (char )orient;
  }
#line 12701
  return 0;
}
}
#line 12726
int shellsort(TEBOXPTR *term , int n ) ;
#line 12705 "D:/a/test/300.c"
int sortpin(void) 
{ int j ;
  int n ;
  int cell___0 ;
  CBOXPTR ptr ;
  TIBOXPTR tile ;
  TEBOXPTR term ;
  TEBOXPTR *xpptr ;
  NBOXPTR termptr ;
  char *tmp ;

  {
#line 12712
  tmp = safe_malloc(300U * sizeof(TEBOXPTR ));
#line 12712
  xpptr = (TEBOXPTR *)tmp;
#line 12713
  cell___0 = 1;
#line 12713
  while (cell___0 <= numcells + numterms) {
#line 12714
    ptr = *(carray + cell___0);
#line 12715
    tile = ptr->tileptr;
#line 12715
    if ((unsigned int )tile == (unsigned int )((struct tilebox *)((void *)0))) {
      goto __Cont;
    }
#line 12718
    n = 0;
#line 12719
    term = tile->termsptr;
#line 12719
    while ((unsigned int )term != (unsigned int )((struct termbox *)((void *)0))) {
#line 12721
      termptr = *(tearray + term->cellterm);
#line 12722
      term->net = termptr->net;
#line 12723
      term->termptr = termptr;
#line 12724
      n ++;
#line 12724
      *(xpptr + n) = term;
#line 12719
      term = term->nextterm;
    }
#line 12726
    shellsort(xpptr, n);
#line 12727
    *(xpptr + (n + 1)) = (struct termbox *)((void *)0);
#line 12728
    (ptr->tileptr)->termsptr = *(xpptr + 1);
#line 12729
    j = 1;
#line 12729
    while (j <= n) {
#line 12730
      (*(xpptr + j))->nextterm = *(xpptr + (j + 1));
#line 12729
      j ++;
    }
    __Cont: /* CIL Label */ 
#line 12713
    cell___0 ++;
  }
#line 12733
  safe_free((char *)xpptr);
#line 12734
  return (0);
}
}
#line 12735 "D:/a/test/300.c"
int shellsort(TEBOXPTR *term , int n ) 
{ TEBOXPTR ptr ;
  int incr ;
  int i ;
  int j ;

  {
#line 12741
  incr = n / 2;
#line 12741
  while (incr > 0) {
#line 12742
    i = incr + 1;
#line 12742
    while (i <= n) {
#line 12743
      j = i - incr;
#line 12743
      while (1) {
#line 12743
        if (j > 0) {
#line 12743
          if (! ((int )(*(term + j))->net > (int )(*(term + (j + incr)))->net)) {
#line 12743
            break;
          }
        } else {
#line 12743
          break;
        }
#line 12745
        ptr = *(term + j);
#line 12746
        *(term + j) = *(term + (j + incr));
#line 12747
        *(term + (j + incr)) = ptr;
#line 12743
        j -= incr;
      }
#line 12742
      i ++;
    }
#line 12741
    incr /= 2;
  }
#line 12751
  return (0);
}
}
#line 12756 "D:/a/test/300.c"
int print_stats(FILE *fp ) 
{ 

  {
#line 12759
  fprintf(fp, "Usage statistics not available\n");
#line 12760
  return (0);
}
}
#line 12761 "D:/a/test/300.c"
double cpu_time(void) 
{ 

  {
#line 12763
  return (0.0);
}
}
#line 12767 "D:/a/test/300.c"
int uc0(int a___0 , int newaor ) 
{ CBOXPTR acellptr ;
  TEBOXPTR antrmptr ;
  int cost ;
  int truth ;

  {
#line 12773
  acellptr = *(carray + a___0);
#line 12774
  antrmptr = (acellptr->tileptr)->termsptr;
#line 12775
  term_newpos(antrmptr, acellptr->cxcenter, acellptr->cycenter, newaor);
#line 12776
  cost = funccost;
#line 12777
  new_dbox(antrmptr, & cost);
#line 12778
  truth = acceptt(funccost - cost);
#line 12779
  if (truth == 1) {
#line 12780
    dbox_pos(antrmptr);
#line 12781
    acellptr->corient = (char )newaor;
#line 12782
    funccost = cost;
  }
#line 12784
  return 0;
}
}
#line 12880
int sub_reset1(int a___0 ) ;
#line 12883
int uglobe(void) ;
#line 12788 "D:/a/test/300.c"
int ucg0(int a___0 , int newaor ) 
{ CBOXPTR acellptr ;
  NBOXPTR tmptr ;
  TIBOXPTR antilptr ;
  TEBOXPTR termptr ;
  TEBOXPTR antrmptr ;
  SEGBOXPTR segptr ;
  DENSITYPTR denptr ;
  CHANGRDPTR gdptr ;
  CHANGRDPTR endgrd ;
  int x ;
  int y ;
  int oldtracks ;
  int track ;
  int axcenter___0 ;
  int aycenter___0 ;
  int i ;
  int b___0 ;
  int e ;
  int seg ;
  int chan ;
  int net ;
  int UpperLeft ;
  int UpperRight ;
  int LowerLeft ;
  int LowerRight ;
  int ULpin ;
  int URpin ;
  int LLpin ;
  int LRpin ;
  int leftx ;
  int ritex ;
  int topchan ;
  int botchan ;

  {
#line 12804
  acellptr = *(carray + a___0);
#line 12805
  axcenter___0 = acellptr->cxcenter;
#line 12806
  aycenter___0 = acellptr->cycenter;
#line 12807
  antilptr = acellptr->tileptr;
#line 12808
  antrmptr = antilptr->termsptr;
#line 12809
  LowerLeft = gxstop;
#line 12809
  UpperLeft = LowerLeft;
#line 12810
  LowerRight = gxstart;
#line 12810
  UpperRight = LowerRight;
#line 12811
  LRpin = 0;
#line 12811
  LLpin = LRpin;
#line 12811
  URpin = LLpin;
#line 12811
  ULpin = URpin;
#line 12812
  *(netchgs + 0) = 0;
#line 12813
  termptr = antrmptr;
#line 12813
  while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 12815
    x = (int )termptr->txpos[newaor / 2] + axcenter___0;
#line 12816
    y = (int )termptr->typos[newaor % 2] + aycenter___0;
#line 12817
    tmptr = *(tearray + termptr->cellterm);
#line 12818
    if ((int )tmptr->pinloc == 1) {
#line 12819
      if (tmptr->newx < UpperLeft) {
#line 12820
        UpperLeft = tmptr->newx;
#line 12821
        ULpin = termptr->cellterm;
      }
#line 12823
      if (tmptr->newx > UpperRight) {
#line 12824
        UpperRight = tmptr->newx;
#line 12825
        URpin = termptr->cellterm;
      }
    } else {
#line 12828
      if (tmptr->newx < LowerLeft) {
#line 12829
        LowerLeft = tmptr->newx;
#line 12830
        LLpin = termptr->cellterm;
      }
#line 12832
      if (tmptr->newx > LowerRight) {
#line 12833
        LowerRight = tmptr->newx;
#line 12834
        LRpin = termptr->cellterm;
      }
    }
#line 12837
    tmptr->xpos = x;
#line 12838
    tmptr->ypos = y;
#line 12839
    i = 1;
#line 12839
    while (i <= *(netchgs + 0)) {
#line 12840
      if ((int )tmptr->net == *(netchgs + i)) {
#line 12841
        break;
      }
#line 12839
      i ++;
    }
#line 12844
    if (i > *(netchgs + 0)) {
#line 12845
      (*(netchgs + 0)) ++;
#line 12845
      *(netchgs + *(netchgs + 0)) = (int )tmptr->net;
    }
#line 12813
    termptr = termptr->nextterm;
  }
#line 12848
  if (*(netchgs + 0) == 0) {
#line 12849
    return (0);
  }
#line 12851
  leftx = axcenter___0 + (int )antilptr->left;
#line 12852
  ritex = axcenter___0 + (int )antilptr->right;
#line 12853
  if (ULpin != 0) {
#line 12854
    ULgrdptr = ((*(Tgrid + ULpin))->up)->prevgrd;
#line 12855
    while ((ULgrdptr->netptr)->newx >= leftx) {
#line 12856
      ULgrdptr = ULgrdptr->prevgrd;
    }
#line 12858
    URgrdptr = ((*(Tgrid + URpin))->up)->nextgrd;
#line 12859
    while ((URgrdptr->netptr)->newx <= ritex) {
#line 12860
      URgrdptr = URgrdptr->nextgrd;
    }
  } else {
#line 12863
    ULgrdptr = (struct changrdbox *)((void *)0);
  }
#line 12865
  if (LLpin != 0) {
#line 12866
    LLgrdptr = ((*(Tgrid + LLpin))->down)->prevgrd;
#line 12867
    while ((LLgrdptr->netptr)->newx >= leftx) {
#line 12868
      LLgrdptr = LLgrdptr->prevgrd;
    }
#line 12870
    LRgrdptr = ((*(Tgrid + LRpin))->down)->nextgrd;
#line 12871
    while ((LRgrdptr->netptr)->newx <= ritex) {
#line 12872
      LRgrdptr = LRgrdptr->nextgrd;
    }
  } else {
#line 12875
    LLgrdptr = (struct changrdbox *)((void *)0);
  }
#line 12877
  Left_bound = leftx - (ritex - leftx);
#line 12878
  Rite_bound = ritex + (ritex - leftx);
#line 12879
  if (uneven_cell_height) {
#line 12880
    sub_reset1(a___0);
  }
#line 12882
  oldtracks = tracks;
#line 12883
  uglobe();
#line 12884
  topchan = gtopChan + 1;
#line 12885
  botchan = gbotChan - 1;
#line 12886
  if (topchan > numChans) {
#line 12887
    topchan = numChans;
  }
#line 12889
  if (botchan < 1) {
#line 12890
    botchan = 1;
  }
#line 12892
  if (tracks < oldtracks) {
#line 12893
    i = 1;
#line 12893
    while (i <= *(netchgs + 0)) {
#line 12894
      net = *(netchgs + i);
#line 12895
      b___0 = *(anet + net);
#line 12896
      e = *(anet + (net + 1)) - 1;
#line 12897
      seg = b___0;
#line 12897
      while (seg <= e) {
#line 12898
        (aNetSeg + seg)->current = (aNetSeg + seg)->ncurrent;
#line 12899
        (aNetSeg + seg)->swYorN = (aNetSeg + seg)->nswYorN;
#line 12900
        (aNetSeg + seg)->key = (aNetSeg + seg)->nkey;
#line 12901
        (aNetSeg + seg)->nflag = (char)0;
#line 12902
        segptr = (aNetSeg + seg)->top;
#line 12903
        (aNetSeg + seg)->top = (aNetSeg + seg)->ntop;
#line 12904
        (aNetSeg + seg)->ntop = segptr;
#line 12905
        segptr = (aNetSeg + seg)->bot;
#line 12906
        (aNetSeg + seg)->bot = (aNetSeg + seg)->nbot;
#line 12907
        (aNetSeg + seg)->nbot = segptr;
#line 12897
        seg ++;
      }
#line 12893
      i ++;
    }
#line 12910
    termptr = antrmptr;
#line 12910
    while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 12912
      tmptr = *(tearray + termptr->cellterm);
#line 12913
      tmptr->newx = tmptr->xpos;
#line 12914
      tmptr->newy = tmptr->ypos;
#line 12910
      termptr = termptr->nextterm;
    }
#line 12916
    seg = 1;
#line 12916
    while (seg <= numSegs) {
#line 12917
      *(fixnetseg + seg) = (int )(aNetSeg + seg)->current;
#line 12916
      seg ++;
    }
#line 12919
    chan = botchan;
#line 12919
    while (chan <= topchan) {
#line 12920
      gdptr = *(Begin + chan);
#line 12920
      while ((unsigned int )gdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 12922
        gdptr->tracks = gdptr->ntracks;
#line 12923
        gdptr->SegType = gdptr->nSegType;
#line 12920
        gdptr = gdptr->nnextgrd;
      }
#line 12925
      track = 0;
#line 12925
      while (track <= max_tdensity + 30) {
#line 12926
        denptr = *(*(DboxHead + chan) + track);
#line 12926
        while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 12928
          denptr->next = denptr->nnext;
#line 12929
          denptr->back = denptr->nback;
#line 12926
          denptr = denptr->nnext;
        }
#line 12925
        track ++;
      }
#line 12932
      *(maxTrack + chan) = *(nmaxTrack + chan);
#line 12919
      chan ++;
    }
#line 12934
    if ((unsigned int )ULgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 12935
      endgrd = URgrdptr->nnextgrd;
#line 12936
      gdptr = ULgrdptr;
#line 12936
      while ((unsigned int )gdptr != (unsigned int )endgrd) {
#line 12938
        gdptr->nextgrd = gdptr->nnextgrd;
#line 12939
        gdptr->prevgrd = gdptr->nprevgrd;
#line 12936
        gdptr = gdptr->nnextgrd;
      }
    }
#line 12942
    if ((unsigned int )LLgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 12943
      endgrd = LRgrdptr->nnextgrd;
#line 12944
      gdptr = LLgrdptr;
#line 12944
      while ((unsigned int )gdptr != (unsigned int )endgrd) {
#line 12946
        gdptr->nextgrd = gdptr->nnextgrd;
#line 12947
        gdptr->prevgrd = gdptr->nprevgrd;
#line 12944
        gdptr = gdptr->nnextgrd;
      }
    }
#line 12950
    acellptr->corient = (char )newaor;
#line 12951
    return (1);
  } else {
#line 12953
    termptr = antrmptr;
#line 12953
    while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 12955
      tmptr = *(tearray + termptr->cellterm);
#line 12956
      tmptr->xpos = tmptr->newx;
#line 12957
      tmptr->ypos = tmptr->newy;
#line 12953
      termptr = termptr->nextterm;
    }
#line 12959
    i = 1;
#line 12959
    while (i <= *(netchgs + 0)) {
#line 12960
      net = *(netchgs + i);
#line 12961
      b___0 = *(anet + net);
#line 12962
      e = *(anet + (net + 1)) - 1;
#line 12963
      seg = b___0;
#line 12963
      while (seg <= e) {
#line 12964
        (aNetSeg + seg)->nflag = (char)0;
#line 12963
        seg ++;
      }
#line 12959
      i ++;
    }
#line 12967
    seg = 1;
#line 12967
    while (seg <= numSegs) {
#line 12968
      (aNetSeg + seg)->current = (char )*(fixnetseg + seg);
#line 12967
      seg ++;
    }
#line 12970
    chan = botchan;
#line 12970
    while (chan <= topchan) {
#line 12971
      gdptr = *(Begin + chan);
#line 12971
      while ((unsigned int )gdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 12973
        gdptr->ntracks = gdptr->tracks;
#line 12974
        gdptr->nSegType = gdptr->SegType;
#line 12971
        gdptr = gdptr->nextgrd;
      }
#line 12976
      track = 0;
#line 12976
      while (track <= max_tdensity + 30) {
#line 12977
        denptr = *(*(DboxHead + chan) + track);
#line 12977
        while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 12979
          denptr->nnext = denptr->next;
#line 12980
          denptr->nback = denptr->back;
#line 12977
          denptr = denptr->next;
        }
#line 12976
        track ++;
      }
#line 12983
      *(nmaxTrack + chan) = *(maxTrack + chan);
#line 12970
      chan ++;
    }
#line 12985
    if ((unsigned int )ULgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 12986
      endgrd = URgrdptr->nextgrd;
#line 12987
      gdptr = ULgrdptr;
#line 12987
      while ((unsigned int )gdptr != (unsigned int )endgrd) {
#line 12989
        gdptr->nnextgrd = gdptr->nextgrd;
#line 12990
        gdptr->nprevgrd = gdptr->prevgrd;
#line 12987
        gdptr = gdptr->nextgrd;
      }
    }
#line 12993
    if ((unsigned int )LLgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 12994
      endgrd = LRgrdptr->nextgrd;
#line 12995
      gdptr = LLgrdptr;
#line 12995
      while ((unsigned int )gdptr != (unsigned int )endgrd) {
#line 12997
        gdptr->nnextgrd = gdptr->nextgrd;
#line 12998
        gdptr->nprevgrd = gdptr->prevgrd;
#line 12995
        gdptr = gdptr->nextgrd;
      }
    }
#line 13001
    tracks = oldtracks;
#line 13002
    return (0);
  }
}
}
#line 13005 "D:/a/test/300.c"
int sub_reset1(int a___0 ) 
{ int row___0 ;
  int pinloc ;
  int self_reset ;
  NBOXPTR netptr ;
  CHANGRDPTR grdptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 13012
  row___0 = (int )(*(carray + a___0))->cblock;
#line 13013
  if ((unsigned int )ULgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 13014
    grdptr = ULgrdptr;
#line 13014
    while ((unsigned int )grdptr != (unsigned int )URgrdptr) {
#line 13016
      netptr = grdptr->netptr;
#line 13017
      pinloc = (int )netptr->pinloc;
#line 13018
      if (pinloc == 1) {
#line 13019
        self_reset = (int )((*(carray + netptr->cell))->tileptr)->top;
      } else {
#line 13020
        if (pinloc == -1) {
#line 13021
          self_reset = - ((int )((*(carray + netptr->cell))->tileptr)->bottom);
        } else {
#line 13023
          self_reset = 0;
        }
      }
#line 13025
      tmp = facing_cellheight(netptr->terminal, (int )netptr->row, pinloc, 0);
#line 13025
      grdptr->ntracks = (short )((int )grdptr->ntracks - (self_reset + tmp) / track_spacing);
#line 13014
      grdptr = grdptr->nextgrd;
    }
  }
#line 13030
  if ((unsigned int )LLgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 13031
    grdptr = LLgrdptr;
#line 13031
    while ((unsigned int )grdptr != (unsigned int )LRgrdptr) {
#line 13033
      netptr = grdptr->netptr;
#line 13034
      pinloc = (int )netptr->pinloc;
#line 13035
      if (pinloc == 1) {
#line 13036
        self_reset = (int )((*(carray + netptr->cell))->tileptr)->top;
      } else {
#line 13037
        if (pinloc == -1) {
#line 13038
          self_reset = - ((int )((*(carray + netptr->cell))->tileptr)->bottom);
        } else {
#line 13040
          self_reset = 0;
        }
      }
#line 13042
      tmp___0 = facing_cellheight(netptr->terminal, (int )netptr->row, pinloc, 0);
#line 13042
      grdptr->ntracks = (short )((int )grdptr->ntracks - (self_reset + tmp___0) / track_spacing);
#line 13031
      grdptr = grdptr->nextgrd;
    }
  }
#line 13047
  return (0);
}
}
#line 13050 "D:/a/test/300.c"
static int na_i  ;
#line 13050 "D:/a/test/300.c"
static int nb_i  ;
#line 13050 "D:/a/test/300.c"
static int start_i  ;
#line 13050 "D:/a/test/300.c"
static int end_i  ;
#line 13051 "D:/a/test/300.c"
static int startcbin  ;
#line 13051 "D:/a/test/300.c"
static int endcbin  ;
#line 13051 "D:/a/test/300.c"
static int rowleft  ;
#line 13052 "D:/a/test/300.c"
static int leftx  ;
#line 13052 "D:/a/test/300.c"
static int ritex  ;
#line 13053 "D:/a/test/300.c"
static int old_axcenter  ;
#line 13053 "D:/a/test/300.c"
static int old_bxcenter  ;
#line 13054 "D:/a/test/300.c"
static CBOXPTR acellptr  ;
#line 13054 "D:/a/test/300.c"
static CBOXPTR bcellptr  ;
#line 13188
int sub_reset2(int a___0 , int b___0 , int anxcenter___0 , int bnxcenter___0 ) ;
#line 13055 "D:/a/test/300.c"
int ucgxp(int a___0 , int b___0 , int anxcenter___0 , int bnxcenter___0 ) 
{ CBOXPTR cellptr___0 ;
  NBOXPTR tmptr ;
  TIBOXPTR atileptr ;
  TIBOXPTR btileptr ;
  TEBOXPTR termptr ;
  TEBOXPTR atermptr ;
  TEBOXPTR btermptr ;
  SEGBOXPTR segptr ;
  DENSITYPTR denptr ;
  CHANGRDPTR gdptr ;
  CHANGRDPTR endgrd ;
  int oldtracks ;
  int track ;
  int x ;
  int row___0 ;
  int aorient ;
  int borient___0 ;
  int bin ;
  int bin_rite_edge ;
  int crite ;
  int i ;
  int bb ;
  int e ;
  int seg ;
  int chan ;
  int net ;
  int UpperLeft ;
  int UpperRight ;
  int LowerLeft ;
  int LowerRight ;
  int ULpin ;
  int URpin ;
  int LLpin ;
  int LRpin ;
  int topchan ;
  int botchan ;

  {
#line 13071
  acellptr = *(carray + a___0);
#line 13072
  aorient = (int )acellptr->corient / 2;
#line 13073
  atileptr = acellptr->tileptr;
#line 13074
  atermptr = atileptr->termsptr;
#line 13075
  bcellptr = *(carray + b___0);
#line 13076
  borient___0 = (int )bcellptr->corient / 2;
#line 13077
  btileptr = bcellptr->tileptr;
#line 13078
  btermptr = btileptr->termsptr;
#line 13079
  LowerLeft = gxstop;
#line 13079
  UpperLeft = LowerLeft;
#line 13080
  LowerRight = gxstart;
#line 13080
  UpperRight = LowerRight;
#line 13081
  LRpin = 0;
#line 13081
  LLpin = LRpin;
#line 13081
  URpin = LLpin;
#line 13081
  ULpin = URpin;
#line 13082
  *(netchgs + 0) = 0;
#line 13083
  termptr = atermptr;
#line 13083
  while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 13085
    x = (int )termptr->txpos[aorient] + anxcenter___0;
#line 13086
    tmptr = *(tearray + termptr->cellterm);
#line 13087
    if ((int )tmptr->pinloc == 1) {
#line 13088
      if (tmptr->newx < UpperLeft) {
#line 13089
        UpperLeft = tmptr->newx;
#line 13090
        ULpin = termptr->cellterm;
      }
#line 13092
      if (tmptr->newx > UpperRight) {
#line 13093
        UpperRight = tmptr->newx;
#line 13094
        URpin = termptr->cellterm;
      }
    } else {
#line 13098
      if (tmptr->newx < LowerLeft) {
#line 13099
        LowerLeft = tmptr->newx;
#line 13100
        LLpin = termptr->cellterm;
      }
#line 13102
      if (tmptr->newx > LowerRight) {
#line 13103
        LowerRight = tmptr->newx;
#line 13104
        LRpin = termptr->cellterm;
      }
    }
#line 13107
    tmptr->xpos = x;
#line 13108
    i = 1;
#line 13108
    while (i <= *(netchgs + 0)) {
#line 13109
      if ((int )tmptr->net == *(netchgs + i)) {
#line 13110
        break;
      }
#line 13108
      i ++;
    }
#line 13113
    if (i > *(netchgs + 0)) {
#line 13114
      (*(netchgs + 0)) ++;
#line 13114
      *(netchgs + *(netchgs + 0)) = (int )tmptr->net;
    }
#line 13083
    termptr = termptr->nextterm;
  }
#line 13117
  termptr = btermptr;
#line 13117
  while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 13119
    x = (int )termptr->txpos[borient___0] + bnxcenter___0;
#line 13120
    tmptr = *(tearray + termptr->cellterm);
#line 13121
    if ((int )tmptr->pinloc == 1) {
#line 13122
      if (tmptr->newx < UpperLeft) {
#line 13123
        UpperLeft = tmptr->newx;
#line 13124
        ULpin = termptr->cellterm;
      }
#line 13126
      if (tmptr->newx > UpperRight) {
#line 13127
        UpperRight = tmptr->newx;
#line 13128
        URpin = termptr->cellterm;
      }
    } else {
#line 13132
      if (tmptr->newx < LowerLeft) {
#line 13133
        LowerLeft = tmptr->newx;
#line 13134
        LLpin = termptr->cellterm;
      }
#line 13136
      if (tmptr->newx > LowerRight) {
#line 13137
        LowerRight = tmptr->newx;
#line 13138
        LRpin = termptr->cellterm;
      }
    }
#line 13141
    tmptr->xpos = x;
#line 13142
    i = 1;
#line 13142
    while (i <= *(netchgs + 0)) {
#line 13143
      if ((int )tmptr->net == *(netchgs + i)) {
#line 13144
        break;
      }
#line 13142
      i ++;
    }
#line 13147
    if (i > *(netchgs + 0)) {
#line 13148
      (*(netchgs + 0)) ++;
#line 13148
      *(netchgs + *(netchgs + 0)) = (int )tmptr->net;
    }
#line 13117
    termptr = termptr->nextterm;
  }
#line 13151
  if (*(netchgs + 0) == 0) {
#line 13152
    return (0);
  }
#line 13154
  if (anxcenter___0 < bnxcenter___0) {
#line 13155
    leftx = anxcenter___0 + (int )atileptr->left;
#line 13156
    ritex = bnxcenter___0 + (int )btileptr->right;
  } else {
#line 13158
    leftx = bnxcenter___0 + (int )btileptr->left;
#line 13159
    ritex = anxcenter___0 + (int )atileptr->right;
  }
#line 13161
  if (ULpin != 0) {
#line 13162
    ULgrdptr = ((*(Tgrid + ULpin))->up)->prevgrd;
#line 13163
    while ((ULgrdptr->netptr)->newx >= leftx) {
#line 13164
      ULgrdptr = ULgrdptr->prevgrd;
    }
#line 13166
    URgrdptr = ((*(Tgrid + URpin))->up)->nextgrd;
#line 13167
    while ((URgrdptr->netptr)->newx <= ritex) {
#line 13168
      URgrdptr = URgrdptr->nextgrd;
    }
  } else {
#line 13171
    ULgrdptr = (struct changrdbox *)((void *)0);
  }
#line 13173
  if (LLpin != 0) {
#line 13174
    LLgrdptr = ((*(Tgrid + LLpin))->down)->prevgrd;
#line 13175
    while ((LLgrdptr->netptr)->newx >= leftx) {
#line 13176
      LLgrdptr = LLgrdptr->prevgrd;
    }
#line 13178
    LRgrdptr = ((*(Tgrid + LRpin))->down)->nextgrd;
#line 13179
    while ((LRgrdptr->netptr)->newx <= ritex) {
#line 13180
      LRgrdptr = LRgrdptr->nextgrd;
    }
  } else {
#line 13183
    LLgrdptr = (struct changrdbox *)((void *)0);
  }
#line 13185
  Left_bound = leftx - (ritex - leftx);
#line 13186
  Rite_bound = ritex + (ritex - leftx);
#line 13187
  if (uneven_cell_height) {
#line 13188
    sub_reset2(a___0, b___0, anxcenter___0, bnxcenter___0);
  }
#line 13190
  oldtracks = tracks;
#line 13191
  uglobe();
#line 13192
  topchan = gtopChan + 1;
#line 13193
  botchan = gbotChan - 1;
#line 13194
  if (topchan > numChans) {
#line 13195
    topchan = numChans;
  }
#line 13197
  if (botchan < 1) {
#line 13198
    botchan = 1;
  }
#line 13200
  if (tracks <= oldtracks) {
#line 13201
    if (! uneven_cell_height) {
#line 13202
      acellptr->cxcenter = anxcenter___0;
#line 13203
      bcellptr->cxcenter = bnxcenter___0;
    }
#line 13205
    termptr = atermptr;
#line 13205
    while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 13207
      tmptr = *(tearray + termptr->cellterm);
#line 13208
      tmptr->newx = tmptr->xpos;
#line 13205
      termptr = termptr->nextterm;
    }
#line 13210
    termptr = btermptr;
#line 13210
    while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 13212
      tmptr = *(tearray + termptr->cellterm);
#line 13213
      tmptr->newx = tmptr->xpos;
#line 13210
      termptr = termptr->nextterm;
    }
#line 13215
    i = 1;
#line 13215
    while (i <= *(netchgs + 0)) {
#line 13216
      net = *(netchgs + i);
#line 13217
      bb = *(anet + net);
#line 13218
      e = *(anet + (net + 1)) - 1;
#line 13219
      seg = bb;
#line 13219
      while (seg <= e) {
#line 13220
        (aNetSeg + seg)->current = (aNetSeg + seg)->ncurrent;
#line 13221
        (aNetSeg + seg)->swYorN = (aNetSeg + seg)->nswYorN;
#line 13222
        (aNetSeg + seg)->key = (aNetSeg + seg)->nkey;
#line 13223
        (aNetSeg + seg)->nflag = (char)0;
#line 13224
        segptr = (aNetSeg + seg)->top;
#line 13225
        (aNetSeg + seg)->top = (aNetSeg + seg)->ntop;
#line 13226
        (aNetSeg + seg)->ntop = segptr;
#line 13227
        segptr = (aNetSeg + seg)->bot;
#line 13228
        (aNetSeg + seg)->bot = (aNetSeg + seg)->nbot;
#line 13229
        (aNetSeg + seg)->nbot = segptr;
#line 13219
        seg ++;
      }
#line 13215
      i ++;
    }
#line 13232
    seg = 1;
#line 13232
    while (seg <= numSegs) {
#line 13233
      *(fixnetseg + seg) = (int )(aNetSeg + seg)->current;
#line 13232
      seg ++;
    }
#line 13235
    chan = botchan;
#line 13235
    while (chan <= topchan) {
#line 13236
      gdptr = *(Begin + chan);
#line 13236
      while ((unsigned int )gdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 13238
        gdptr->tracks = gdptr->ntracks;
#line 13239
        gdptr->SegType = gdptr->nSegType;
#line 13236
        gdptr = gdptr->nnextgrd;
      }
#line 13241
      track = 0;
#line 13241
      while (track <= max_tdensity + 30) {
#line 13242
        denptr = *(*(DboxHead + chan) + track);
#line 13242
        while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 13244
          denptr->next = denptr->nnext;
#line 13245
          denptr->back = denptr->nback;
#line 13242
          denptr = denptr->nnext;
        }
#line 13241
        track ++;
      }
#line 13248
      *(maxTrack + chan) = *(nmaxTrack + chan);
#line 13235
      chan ++;
    }
#line 13250
    if ((unsigned int )ULgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 13251
      endgrd = URgrdptr->nnextgrd;
#line 13252
      gdptr = ULgrdptr;
#line 13252
      while ((unsigned int )gdptr != (unsigned int )endgrd) {
#line 13254
        gdptr->nextgrd = gdptr->nnextgrd;
#line 13255
        gdptr->prevgrd = gdptr->nprevgrd;
#line 13252
        gdptr = gdptr->nnextgrd;
      }
    }
#line 13258
    if ((unsigned int )LLgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 13259
      endgrd = LRgrdptr->nnextgrd;
#line 13260
      gdptr = LLgrdptr;
#line 13260
      while ((unsigned int )gdptr != (unsigned int )endgrd) {
#line 13262
        gdptr->nextgrd = gdptr->nnextgrd;
#line 13263
        gdptr->prevgrd = gdptr->nprevgrd;
#line 13260
        gdptr = gdptr->nnextgrd;
      }
    }
#line 13266
    return (1);
  } else {
#line 13268
    if (uneven_cell_height) {
#line 13269
      acellptr->cxcenter = old_axcenter;
#line 13270
      bcellptr->cxcenter = old_bxcenter;
    }
#line 13272
    termptr = atermptr;
#line 13272
    while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 13274
      tmptr = *(tearray + termptr->cellterm);
#line 13275
      tmptr->xpos = tmptr->newx;
#line 13272
      termptr = termptr->nextterm;
    }
#line 13277
    termptr = btermptr;
#line 13277
    while ((unsigned int )termptr != (unsigned int )((struct termbox *)((void *)0))) {
#line 13279
      tmptr = *(tearray + termptr->cellterm);
#line 13280
      tmptr->xpos = tmptr->newx;
#line 13277
      termptr = termptr->nextterm;
    }
#line 13282
    i = 1;
#line 13282
    while (i <= *(netchgs + 0)) {
#line 13283
      net = *(netchgs + i);
#line 13284
      bb = *(anet + net);
#line 13285
      e = *(anet + (net + 1)) - 1;
#line 13286
      seg = bb;
#line 13286
      while (seg <= e) {
#line 13287
        (aNetSeg + seg)->nflag = (char)0;
#line 13286
        seg ++;
      }
#line 13282
      i ++;
    }
#line 13290
    seg = 1;
#line 13290
    while (seg <= numSegs) {
#line 13291
      (aNetSeg + seg)->current = (char )*(fixnetseg + seg);
#line 13290
      seg ++;
    }
#line 13293
    chan = botchan;
#line 13293
    while (chan <= topchan) {
#line 13294
      gdptr = *(Begin + chan);
#line 13294
      while ((unsigned int )gdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 13296
        gdptr->ntracks = gdptr->tracks;
#line 13297
        gdptr->nSegType = gdptr->SegType;
#line 13294
        gdptr = gdptr->nextgrd;
      }
#line 13299
      track = 0;
#line 13299
      while (track <= max_tdensity + 30) {
#line 13300
        denptr = *(*(DboxHead + chan) + track);
#line 13300
        while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 13302
          denptr->nnext = denptr->next;
#line 13303
          denptr->nback = denptr->back;
#line 13300
          denptr = denptr->next;
        }
#line 13299
        track ++;
      }
#line 13306
      *(nmaxTrack + chan) = *(maxTrack + chan);
#line 13293
      chan ++;
    }
#line 13308
    if ((unsigned int )ULgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 13309
      endgrd = URgrdptr->nextgrd;
#line 13310
      gdptr = ULgrdptr;
#line 13310
      while ((unsigned int )gdptr != (unsigned int )endgrd) {
#line 13312
        gdptr->nnextgrd = gdptr->nextgrd;
#line 13313
        gdptr->nprevgrd = gdptr->prevgrd;
#line 13310
        gdptr = gdptr->nextgrd;
      }
    }
#line 13316
    if ((unsigned int )LLgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 13317
      endgrd = LRgrdptr->nextgrd;
#line 13318
      gdptr = LLgrdptr;
#line 13318
      while ((unsigned int )gdptr != (unsigned int )endgrd) {
#line 13320
        gdptr->nnextgrd = gdptr->nextgrd;
#line 13321
        gdptr->nprevgrd = gdptr->prevgrd;
#line 13318
        gdptr = gdptr->nextgrd;
      }
    }
#line 13324
    tracks = oldtracks;
#line 13325
    if (uneven_cell_height) {
#line 13326
      row___0 = (int )(*(carray + a___0))->cblock;
#line 13327
      *(*(pairArray + row___0) + nb_i) = a___0;
#line 13328
      *(*(pairArray + row___0) + na_i) = b___0;
#line 13329
      bin = startcbin;
#line 13330
      bin --;
#line 13330
      bin_rite_edge = rowleft + bin * cedge_binwidth;
#line 13331
      i = start_i;
#line 13331
      while (i <= end_i) {
#line 13332
        cellptr___0 = *(carray + *(*(pairArray + row___0) + i));
#line 13333
        crite = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
#line 13334
        while (bin_rite_edge < crite) {
#line 13335
          bin ++;
#line 13335
          *(*(cedgebin + row___0) + bin) = i;
#line 13336
          bin_rite_edge += cedge_binwidth;
        }
#line 13331
        i ++;
      }
    }
#line 13340
    return (0);
  }
}
}
#line 13343 "D:/a/test/300.c"
int sub_reset2(int a___0 , int b___0 , int anxcenter___0 , int bnxcenter___0 ) 
{ int row___0 ;
  int bin ;
  int *Aray ;
  int i ;
  int cell___0 ;
  int bin_rite_edge ;
  int crite ;
  int pinloc ;
  int self_reset ;
  NBOXPTR netptr ;
  CBOXPTR cellptr___0 ;
  CHANGRDPTR grdptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 13352
  row___0 = (int )(*(carray + a___0))->cblock;
#line 13353
  if ((unsigned int )ULgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 13354
    grdptr = ULgrdptr;
#line 13354
    while ((unsigned int )grdptr != (unsigned int )URgrdptr) {
#line 13356
      netptr = grdptr->netptr;
#line 13357
      pinloc = (int )netptr->pinloc;
#line 13358
      if (pinloc == 1) {
#line 13359
        self_reset = (int )((*(carray + netptr->cell))->tileptr)->top;
      } else {
#line 13360
        if (pinloc == -1) {
#line 13361
          self_reset = - ((int )((*(carray + netptr->cell))->tileptr)->bottom);
        } else {
#line 13363
          self_reset = 0;
        }
      }
#line 13365
      tmp = facing_cellheight(netptr->terminal, (int )netptr->row, pinloc, 0);
#line 13365
      grdptr->ntracks = (short )((int )grdptr->ntracks - (self_reset + tmp) / track_spacing);
#line 13354
      grdptr = grdptr->nextgrd;
    }
  }
#line 13370
  if ((unsigned int )LLgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 13371
    grdptr = LLgrdptr;
#line 13371
    while ((unsigned int )grdptr != (unsigned int )LRgrdptr) {
#line 13373
      netptr = grdptr->netptr;
#line 13374
      pinloc = (int )netptr->pinloc;
#line 13375
      if (pinloc == 1) {
#line 13376
        self_reset = (int )((*(carray + netptr->cell))->tileptr)->top;
      } else {
#line 13377
        if (pinloc == -1) {
#line 13378
          self_reset = - ((int )((*(carray + netptr->cell))->tileptr)->bottom);
        } else {
#line 13380
          self_reset = 0;
        }
      }
#line 13382
      tmp___0 = facing_cellheight(netptr->terminal, (int )netptr->row, pinloc, 0);
#line 13382
      grdptr->ntracks = (short )((int )grdptr->ntracks - (self_reset + tmp___0) / track_spacing);
#line 13371
      grdptr = grdptr->nextgrd;
    }
  }
#line 13387
  old_axcenter = acellptr->cxcenter;
#line 13388
  old_bxcenter = bcellptr->cxcenter;
#line 13389
  acellptr->cxcenter = anxcenter___0;
#line 13390
  bcellptr->cxcenter = bnxcenter___0;
#line 13391
  Aray = *(pairArray + row___0);
#line 13392
  rowleft = (*(carray + *(Aray + 1)))->cxcenter + (int )((*(carray + *(Aray + 1)))->tileptr)->left;
#line 13393
  startcbin = (leftx - rowleft) / cedge_binwidth + 1;
#line 13394
  endcbin = (ritex - rowleft) / cedge_binwidth + 1;
#line 13395
  start_i = *(*(cedgebin + row___0) + startcbin);
#line 13396
  end_i = *(*(cedgebin + row___0) + endcbin);
#line 13397
  bin = startcbin;
#line 13398
  i = start_i;
#line 13399
  cell___0 = *(Aray + i);
#line 13399
  while (cell___0 != a___0) {
#line 13399
    i ++;
#line 13399
    cell___0 = *(Aray + i);
  }
#line 13400
  if (anxcenter___0 < bnxcenter___0) {
#line 13401
    na_i = i - 1;
#line 13402
    nb_i = i;
  } else {
#line 13404
    na_i = i + 1;
#line 13405
    nb_i = i;
  }
#line 13407
  *(Aray + na_i) = a___0;
#line 13408
  *(Aray + nb_i) = b___0;
#line 13409
  bin --;
#line 13409
  bin_rite_edge = rowleft + bin * cedge_binwidth;
#line 13410
  i = start_i;
#line 13410
  while (i <= end_i) {
#line 13411
    cellptr___0 = *(carray + *(Aray + i));
#line 13412
    crite = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
#line 13413
    while (bin_rite_edge < crite) {
#line 13414
      bin ++;
#line 13414
      *(*(cedgebin + row___0) + bin) = i;
#line 13415
      bin_rite_edge += cedge_binwidth;
    }
#line 13410
    i ++;
  }
#line 13418
  return (0);
}
}
#line 13429 "D:/a/test/300.c"
int uclosepns(int net ) 
{ int pin ;
  int pin1 ;
  int pin2 ;
  int minP1 ;
  int minP2 ;
  int minX ;
  int sepT ;
  int sepB ;
  int edge___0 ;
  int group1 ;
  int group2 ;
  int block1 ;
  int block2 ;
  int p1 ;
  int p2 ;
  int Tleft ;
  int Tright ;
  int Bleft ;
  int Bright ;
  int minTop ;
  int minBottom ;
  int maxTpin ;
  int maxBpin ;
  int otherTpin ;
  int otherBpin ;
  int maxTop ;
  int maxBottom ;
  int segIndex ;
  int k_left ;
  int k_right ;
  int super_edge ;
  int e1 ;
  int e2 ;
  int g1 ;
  int g2 ;
  int next_edge ;
  int next_g ;
  int save_count ;
  int key_flag ;
  int key_count ;
  int fault_line ;
  int channel ;
  int left___0 ;
  int right ;
  int ltop ;
  int rtop ;
  int lbot ;
  int rbot ;
  csPinBox *pArray1 ;
  csPinBox *pArray2 ;
  csPinBox *pArray ;
  SEGBOXPTR tmp_ptr ;
  int tmp ;
  struct _reent *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct _reent *tmp___7 ;

  {
#line 13444
  key_count = 0;
#line 13445
  super_edge = 0;
#line 13446
  segIndex = *(anet + net) - 1;
#line 13447
  fault_line = *(anet + (net + 1));
#line 13448
  while (1) {
#line 13449
    if (key_count > 0) {
#line 13450
      tmp = key_count;
#line 13450
      key_count --;
#line 13450
      edge___0 = *(key_queue + tmp);
#line 13451
      group1 = (int )(edgeArray + edge___0)->group1;
#line 13452
      k_left = (groupArray + group1)->aveX;
#line 13453
      k_right = k_left;
#line 13454
      key_flag = save_count;
    } else {
#line 13456
      while (1) {
#line 13456
        super_edge ++;
#line 13456
        if (! (super_edge <= numEdges)) {
#line 13456
          break;
        }
#line 13457
        if ((int )(edgeArray + super_edge)->marked == 0) {
#line 13458
          continue;
        }
#line 13460
        if ((int )(edgeArray + super_edge)->done == 0) {
#line 13461
          break;
        }
      }
#line 13464
      if (super_edge > numEdges) {
#line 13465
        break;
      }
#line 13467
      edge___0 = super_edge;
#line 13468
      key_flag = 0;
    }
#line 13470
    segIndex ++;
#line 13472
    if (segIndex >= fault_line) {
#line 13473
      printf("Serious fault detected in function: uclosepns():");
#line 13474
      printf("   Net:%d\n", net);
#line 13475
      tmp___0 = __getreent();
#line 13475
      fflush(tmp___0->_stdout);
    }
#line 13478
    (aNetSeg + segIndex)->nflag = (char)1;
#line 13479
    maxTop = -1000000000;
#line 13480
    maxBottom = -1000000000;
#line 13481
    maxTpin = 0;
#line 13482
    maxBpin = 0;
#line 13483
    group1 = (int )(edgeArray + edge___0)->group1;
#line 13484
    pArray1 = (groupArray + group1)->pinArray;
#line 13485
    block1 = (int )(groupArray + group1)->block;
#line 13486
    group2 = (int )(edgeArray + edge___0)->group2;
#line 13487
    pArray2 = (groupArray + group2)->pinArray;
#line 13488
    block2 = (int )(groupArray + group2)->block;
#line 13489
    if ((int )(edgeArray + edge___0)->poison == 0) {
#line 13489
      if (key_flag == 0) {
#line 13490
        save_count = segIndex;
#line 13491
        (edgeArray + edge___0)->done = (short)1;
#line 13492
        key_flag = save_count;
#line 13494
        e1 = edge___0;
#line 13495
        g1 = (int )(edgeArray + e1)->group1;
#line 13496
        while (! ((int )(groupArray + g1)->poison == 1)) {
#line 13500
          if ((int )(groupArray + g1)->edge1 == e1) {
#line 13501
            next_edge = (int )(groupArray + g1)->edge2;
          } else {
#line 13503
            next_edge = (int )(groupArray + g1)->edge1;
          }
#line 13505
          if (next_edge == 0) {
#line 13506
            break;
          }
#line 13508
          next_g = (int )(edgeArray + next_edge)->group1;
#line 13509
          if (next_g == g1) {
#line 13510
            g1 = (int )(edgeArray + next_edge)->group2;
          } else {
#line 13512
            g1 = next_g;
          }
#line 13514
          e1 = next_edge;
#line 13515
          (edgeArray + e1)->done = (short)1;
#line 13516
          key_count ++;
#line 13516
          *(key_queue + key_count) = e1;
        }
#line 13518
        e2 = edge___0;
#line 13519
        g2 = (int )(edgeArray + e2)->group2;
#line 13520
        while (! ((int )(groupArray + g2)->poison == 1)) {
#line 13524
          if ((int )(groupArray + g2)->edge1 == e2) {
#line 13525
            next_edge = (int )(groupArray + g2)->edge2;
          } else {
#line 13527
            next_edge = (int )(groupArray + g2)->edge1;
          }
#line 13529
          if (next_edge == 0) {
#line 13530
            break;
          }
#line 13532
          next_g = (int )(edgeArray + next_edge)->group1;
#line 13533
          if (next_g == g2) {
#line 13534
            g2 = (int )(edgeArray + next_edge)->group2;
          } else {
#line 13536
            g2 = next_g;
          }
#line 13538
          e2 = next_edge;
#line 13539
          (edgeArray + e2)->done = (short)1;
#line 13540
          key_count ++;
#line 13540
          *(key_queue + key_count) = e2;
        }
#line 13542
        if ((groupArray + g1)->aveX <= (groupArray + g2)->aveX) {
#line 13543
          k_left = (groupArray + g1)->aveX;
#line 13544
          k_right = (groupArray + g2)->aveX;
#line 13545
          pArray = (groupArray + g1)->pinArray;
#line 13546
          pin = 1;
#line 13546
          while (pin <= (int )(groupArray + g1)->numPins) {
#line 13547
            if ((int )(pArray + pin)->top == 1) {
#line 13548
              ltop = (pArray + pin)->pin;
            } else {
#line 13547
              if ((int )(pArray + pin)->top == 0) {
#line 13548
                ltop = (pArray + pin)->pin;
              }
            }
#line 13550
            if ((int )(pArray + pin)->top == -1) {
#line 13551
              lbot = (pArray + pin)->pin;
            } else {
#line 13550
              if ((int )(pArray + pin)->top == 0) {
#line 13551
                lbot = (pArray + pin)->pin;
              }
            }
#line 13546
            pin ++;
          }
#line 13554
          pArray = (groupArray + g2)->pinArray;
#line 13555
          pin = 1;
#line 13555
          while (pin <= (int )(groupArray + g2)->numPins) {
#line 13556
            if ((int )(pArray + pin)->top == 1) {
#line 13557
              rtop = (pArray + pin)->pin;
            } else {
#line 13556
              if ((int )(pArray + pin)->top == 0) {
#line 13557
                rtop = (pArray + pin)->pin;
              }
            }
#line 13559
            if ((int )(pArray + pin)->top == -1) {
#line 13560
              rbot = (pArray + pin)->pin;
            } else {
#line 13559
              if ((int )(pArray + pin)->top == 0) {
#line 13560
                rbot = (pArray + pin)->pin;
              }
            }
#line 13555
            pin ++;
          }
        } else {
#line 13564
          k_left = (groupArray + g2)->aveX;
#line 13565
          k_right = (groupArray + g1)->aveX;
#line 13566
          pArray = (groupArray + g2)->pinArray;
#line 13567
          pin = 1;
#line 13567
          while (pin <= (int )(groupArray + g2)->numPins) {
#line 13568
            if ((int )(pArray + pin)->top == 1) {
#line 13569
              ltop = (pArray + pin)->pin;
            } else {
#line 13568
              if ((int )(pArray + pin)->top == 0) {
#line 13569
                ltop = (pArray + pin)->pin;
              }
            }
#line 13571
            if ((int )(pArray + pin)->top == -1) {
#line 13572
              lbot = (pArray + pin)->pin;
            } else {
#line 13571
              if ((int )(pArray + pin)->top == 0) {
#line 13572
                lbot = (pArray + pin)->pin;
              }
            }
#line 13567
            pin ++;
          }
#line 13575
          pArray = (groupArray + g1)->pinArray;
#line 13576
          pin = 1;
#line 13576
          while (pin <= (int )(groupArray + g1)->numPins) {
#line 13577
            if ((int )(pArray + pin)->top == 1) {
#line 13578
              rtop = (pArray + pin)->pin;
            } else {
#line 13577
              if ((int )(pArray + pin)->top == 0) {
#line 13578
                rtop = (pArray + pin)->pin;
              }
            }
#line 13580
            if ((int )(pArray + pin)->top == -1) {
#line 13581
              rbot = (pArray + pin)->pin;
            } else {
#line 13580
              if ((int )(pArray + pin)->top == 0) {
#line 13581
                rbot = (pArray + pin)->pin;
              }
            }
#line 13576
            pin ++;
          }
        }
      }
    }
#line 13586
    if (block1 == block2) {
#line 13588
      if ((groupArray + group1)->aveX <= (groupArray + group2)->aveX) {
#line 13589
        pin = 1;
#line 13589
        while (pin <= (int )(groupArray + group1)->numPins) {
#line 13590
          if ((int )(pArray1 + pin)->top == 1) {
            goto _L;
          } else {
#line 13590
            if ((int )(pArray1 + pin)->top == 0) {
              _L: /* CIL Label */ 
#line 13591
              if ((int )(pArray1 + pin)->xloc > maxTop) {
#line 13592
                maxTop = (int )(pArray1 + pin)->xloc;
#line 13593
                maxTpin = (pArray1 + pin)->pin;
              }
            }
          }
#line 13596
          if ((int )(pArray1 + pin)->top == -1) {
            goto _L___0;
          } else {
#line 13596
            if ((int )(pArray1 + pin)->top == 0) {
              _L___0: /* CIL Label */ 
#line 13597
              if ((int )(pArray1 + pin)->xloc > maxBottom) {
#line 13598
                maxBottom = (int )(pArray1 + pin)->xloc;
#line 13599
                maxBpin = (pArray1 + pin)->pin;
              }
            }
          }
#line 13589
          pin ++;
        }
#line 13603
        sepT = 1000000000;
#line 13604
        sepB = 1000000000;
#line 13605
        otherTpin = 0;
#line 13606
        otherBpin = 0;
#line 13607
        pin = 1;
#line 13607
        while (pin <= (int )(groupArray + group2)->numPins) {
#line 13608
          if ((int )(pArray2 + pin)->top == 1) {
            goto _L___1;
          } else {
#line 13608
            if ((int )(pArray2 + pin)->top == 0) {
              _L___1: /* CIL Label */ 
#line 13609
              if ((int )(pArray2 + pin)->xloc - maxTop >= 0) {
#line 13609
                tmp___1 = (int )(pArray2 + pin)->xloc - maxTop;
              } else {
#line 13609
                tmp___1 = - ((int )(pArray2 + pin)->xloc - maxTop);
              }
#line 13609
              if (tmp___1 < sepT) {
#line 13610
                otherTpin = (pArray2 + pin)->pin;
#line 13611
                minTop = (int )(pArray2 + pin)->xloc;
#line 13612
                if (minTop - maxTop >= 0) {
#line 13612
                  sepT = minTop - maxTop;
                } else {
#line 13612
                  sepT = - (minTop - maxTop);
                }
              }
            }
          }
#line 13615
          if ((int )(pArray2 + pin)->top == -1) {
            goto _L___2;
          } else {
#line 13615
            if ((int )(pArray2 + pin)->top == 0) {
              _L___2: /* CIL Label */ 
#line 13616
              if ((int )(pArray2 + pin)->xloc - maxBottom >= 0) {
#line 13616
                tmp___2 = (int )(pArray2 + pin)->xloc - maxBottom;
              } else {
#line 13616
                tmp___2 = - ((int )(pArray2 + pin)->xloc - maxBottom);
              }
#line 13616
              if (tmp___2 < sepB) {
#line 13617
                otherBpin = (pArray2 + pin)->pin;
#line 13618
                minBottom = (int )(pArray2 + pin)->xloc;
#line 13619
                if (minBottom - maxBottom >= 0) {
#line 13619
                  sepB = minBottom - maxBottom;
                } else {
#line 13619
                  sepB = - (minBottom - maxBottom);
                }
              }
            }
          }
#line 13607
          pin ++;
        }
#line 13623
        if (maxTpin != 0) {
#line 13623
          if (otherTpin != 0) {
#line 13623
            if (block1 < numChans) {
#line 13625
              if (maxBpin != 0) {
#line 13625
                if (otherBpin != 0) {
#line 13625
                  if (block1 > 0) {
#line 13627
                    (aNetSeg + segIndex)->nswYorN = (char)1;
#line 13628
                    if (key_flag == 0) {
#line 13629
                      (aNetSeg + segIndex)->nkey = (short)0;
                    } else {
#line 13628
                      if (key_flag == segIndex) {
#line 13629
                        (aNetSeg + segIndex)->nkey = (short)0;
                      } else {
#line 13631
                        (aNetSeg + segIndex)->nkey = (short )key_flag;
                      }
                    }
#line 13633
                    (aNetSeg + segIndex)->ncurrent = (char)0;
#line 13634
                    if (maxTop <= minTop) {
#line 13635
                      Tleft = maxTop;
#line 13636
                      Tright = minTop;
#line 13637
                      p1 = maxTpin;
#line 13638
                      p2 = otherTpin;
                    } else {
#line 13640
                      Tleft = minTop;
#line 13641
                      Tright = maxTop;
#line 13642
                      p1 = otherTpin;
#line 13643
                      p2 = maxTpin;
                    }
#line 13645
                    if (key_flag != 0) {
#line 13646
                      Tleft = k_left;
#line 13647
                      Tright = k_right;
                    }
#line 13649
                    ((aNetSeg + segIndex)->ntop)->channel = (short )(block1 + 1);
#line 13650
                    ((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 13651
                    ((aNetSeg + segIndex)->ntop)->pin2 = p2;
#line 13652
                    if (maxBottom <= minBottom) {
#line 13653
                      Bleft = maxBottom;
#line 13654
                      Bright = minBottom;
#line 13655
                      p1 = maxBpin;
#line 13656
                      p2 = otherBpin;
                    } else {
#line 13658
                      Bleft = minBottom;
#line 13659
                      Bright = maxBottom;
#line 13660
                      p1 = otherBpin;
#line 13661
                      p2 = maxBpin;
                    }
#line 13663
                    if (key_flag != 0) {
#line 13664
                      Bleft = k_left;
#line 13665
                      Bright = k_right;
                    }
#line 13667
                    ((aNetSeg + segIndex)->nbot)->channel = (short )block1;
#line 13668
                    ((aNetSeg + segIndex)->nbot)->pin1 = p1;
#line 13669
                    ((aNetSeg + segIndex)->nbot)->pin2 = p2;
#line 13670
                    if (Bleft == Bright) {
                      goto _L___3;
                    } else {
#line 13670
                      if (Tleft == Tright) {
                        _L___3: /* CIL Label */ 
#line 13671
                        (aNetSeg + segIndex)->nswYorN = (char)0;
#line 13672
                        if (Bleft == Bright) {
#line 13672
                          if (Tleft != Tright) {
#line 13673
                            tmp_ptr = (aNetSeg + segIndex)->ntop;
#line 13674
                            (aNetSeg + segIndex)->ntop = (aNetSeg + segIndex)->nbot;
#line 13676
                            (aNetSeg + segIndex)->nbot = tmp_ptr;
                          }
                        }
                      }
                    }
                  } else {
                    goto _L___5;
                  }
                } else {
                  goto _L___5;
                }
              } else {
                _L___5: /* CIL Label */ 
#line 13680
                (aNetSeg + segIndex)->nswYorN = (char)0;
#line 13681
                (aNetSeg + segIndex)->nkey = (short)0;
#line 13682
                (aNetSeg + segIndex)->ncurrent = (char)0;
#line 13683
                if (maxTop <= minTop) {
#line 13684
                  p1 = maxTpin;
#line 13685
                  p2 = otherTpin;
                } else {
#line 13687
                  p1 = otherTpin;
#line 13688
                  p2 = maxTpin;
                }
#line 13690
                ((aNetSeg + segIndex)->ntop)->channel = (short )(block1 + 1);
#line 13691
                ((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 13692
                ((aNetSeg + segIndex)->ntop)->pin2 = p2;
              }
            } else {
              goto _L___7;
            }
          } else {
            goto _L___7;
          }
        } else {
          _L___7: /* CIL Label */ 
#line 13694
          if (maxBpin != 0) {
#line 13694
            if (otherBpin != 0) {
#line 13696
              (aNetSeg + segIndex)->nswYorN = (char)0;
#line 13697
              (aNetSeg + segIndex)->nkey = (short)0;
#line 13698
              (aNetSeg + segIndex)->ncurrent = (char)0;
#line 13699
              if (maxBottom <= minBottom) {
#line 13700
                p1 = maxBpin;
#line 13701
                p2 = otherBpin;
              } else {
#line 13703
                p1 = otherBpin;
#line 13704
                p2 = maxBpin;
              }
#line 13706
              ((aNetSeg + segIndex)->ntop)->channel = (short )block1;
#line 13707
              ((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 13708
              ((aNetSeg + segIndex)->ntop)->pin2 = p2;
            }
          }
        }
      } else {
#line 13711
        pin = 1;
#line 13711
        while (pin <= (int )(groupArray + group2)->numPins) {
#line 13712
          if ((int )(pArray2 + pin)->top == 1) {
            goto _L___8;
          } else {
#line 13712
            if ((int )(pArray2 + pin)->top == 0) {
              _L___8: /* CIL Label */ 
#line 13713
              if ((int )(pArray2 + pin)->xloc > maxTop) {
#line 13714
                maxTop = (int )(pArray2 + pin)->xloc;
#line 13715
                maxTpin = (pArray2 + pin)->pin;
              }
            }
          }
#line 13718
          if ((int )(pArray2 + pin)->top == -1) {
            goto _L___9;
          } else {
#line 13718
            if ((int )(pArray2 + pin)->top == 0) {
              _L___9: /* CIL Label */ 
#line 13719
              if ((int )(pArray2 + pin)->xloc > maxBottom) {
#line 13720
                maxBottom = (int )(pArray2 + pin)->xloc;
#line 13721
                maxBpin = (pArray2 + pin)->pin;
              }
            }
          }
#line 13711
          pin ++;
        }
#line 13725
        sepT = 1000000000;
#line 13726
        sepB = 1000000000;
#line 13727
        otherTpin = 0;
#line 13728
        otherBpin = 0;
#line 13729
        pin = 1;
#line 13729
        while (pin <= (int )(groupArray + group1)->numPins) {
#line 13730
          if ((int )(pArray1 + pin)->top == 1) {
            goto _L___10;
          } else {
#line 13730
            if ((int )(pArray1 + pin)->top == 0) {
              _L___10: /* CIL Label */ 
#line 13731
              if ((int )(pArray1 + pin)->xloc - maxTop >= 0) {
#line 13731
                tmp___3 = (int )(pArray1 + pin)->xloc - maxTop;
              } else {
#line 13731
                tmp___3 = - ((int )(pArray1 + pin)->xloc - maxTop);
              }
#line 13731
              if (tmp___3 < sepT) {
#line 13732
                otherTpin = (pArray1 + pin)->pin;
#line 13733
                minTop = (int )(pArray1 + pin)->xloc;
#line 13734
                if (minTop - maxTop >= 0) {
#line 13734
                  sepT = minTop - maxTop;
                } else {
#line 13734
                  sepT = - (minTop - maxTop);
                }
              }
            }
          }
#line 13737
          if ((int )(pArray1 + pin)->top == -1) {
            goto _L___11;
          } else {
#line 13737
            if ((int )(pArray1 + pin)->top == 0) {
              _L___11: /* CIL Label */ 
#line 13738
              if ((int )(pArray1 + pin)->xloc - maxBottom >= 0) {
#line 13738
                tmp___4 = (int )(pArray1 + pin)->xloc - maxBottom;
              } else {
#line 13738
                tmp___4 = - ((int )(pArray1 + pin)->xloc - maxBottom);
              }
#line 13738
              if (tmp___4 < sepB) {
#line 13739
                otherBpin = (pArray1 + pin)->pin;
#line 13740
                minBottom = (int )(pArray1 + pin)->xloc;
#line 13741
                if (minBottom - maxBottom >= 0) {
#line 13741
                  sepB = minBottom - maxBottom;
                } else {
#line 13741
                  sepB = - (minBottom - maxBottom);
                }
              }
            }
          }
#line 13729
          pin ++;
        }
#line 13745
        if (maxTpin != 0) {
#line 13745
          if (otherTpin != 0) {
#line 13745
            if (block1 < numChans) {
#line 13747
              if (maxBpin != 0) {
#line 13747
                if (otherBpin != 0) {
#line 13747
                  if (block1 > 0) {
#line 13749
                    (aNetSeg + segIndex)->nswYorN = (char)1;
#line 13750
                    if (key_flag == 0) {
#line 13751
                      (aNetSeg + segIndex)->nkey = (short)0;
                    } else {
#line 13750
                      if (key_flag == segIndex) {
#line 13751
                        (aNetSeg + segIndex)->nkey = (short)0;
                      } else {
#line 13753
                        (aNetSeg + segIndex)->nkey = (short )key_flag;
                      }
                    }
#line 13755
                    (aNetSeg + segIndex)->ncurrent = (char)0;
#line 13756
                    if (maxTop <= minTop) {
#line 13757
                      Tleft = maxTop;
#line 13758
                      Tright = minTop;
#line 13759
                      p1 = maxTpin;
#line 13760
                      p2 = otherTpin;
                    } else {
#line 13762
                      Tleft = minTop;
#line 13763
                      Tright = maxTop;
#line 13764
                      p1 = otherTpin;
#line 13765
                      p2 = maxTpin;
                    }
#line 13767
                    if (key_flag != 0) {
#line 13768
                      Tleft = k_left;
#line 13769
                      Tright = k_right;
                    }
#line 13771
                    ((aNetSeg + segIndex)->ntop)->channel = (short )(block1 + 1);
#line 13772
                    ((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 13773
                    ((aNetSeg + segIndex)->ntop)->pin2 = p2;
#line 13774
                    if (maxBottom <= minBottom) {
#line 13775
                      Bleft = maxBottom;
#line 13776
                      Bright = minBottom;
#line 13777
                      p1 = maxBpin;
#line 13778
                      p2 = otherBpin;
                    } else {
#line 13780
                      Bleft = minBottom;
#line 13781
                      Bright = maxBottom;
#line 13782
                      p1 = otherBpin;
#line 13783
                      p2 = maxBpin;
                    }
#line 13785
                    if (key_flag != 0) {
#line 13786
                      Bleft = k_left;
#line 13787
                      Bright = k_right;
                    }
#line 13789
                    ((aNetSeg + segIndex)->nbot)->channel = (short )block1;
#line 13790
                    ((aNetSeg + segIndex)->nbot)->pin1 = p1;
#line 13791
                    ((aNetSeg + segIndex)->nbot)->pin2 = p2;
#line 13792
                    if (Bleft == Bright) {
                      goto _L___12;
                    } else {
#line 13792
                      if (Tleft == Tright) {
                        _L___12: /* CIL Label */ 
#line 13793
                        (aNetSeg + segIndex)->nswYorN = (char)0;
#line 13794
                        if (Bleft == Bright) {
#line 13794
                          if (Tleft != Tright) {
#line 13795
                            tmp_ptr = (aNetSeg + segIndex)->ntop;
#line 13796
                            (aNetSeg + segIndex)->ntop = (aNetSeg + segIndex)->nbot;
#line 13798
                            (aNetSeg + segIndex)->nbot = tmp_ptr;
                          }
                        }
                      }
                    }
                  } else {
                    goto _L___14;
                  }
                } else {
                  goto _L___14;
                }
              } else {
                _L___14: /* CIL Label */ 
#line 13802
                (aNetSeg + segIndex)->nswYorN = (char)0;
#line 13803
                (aNetSeg + segIndex)->nkey = (short)0;
#line 13804
                (aNetSeg + segIndex)->ncurrent = (char)0;
#line 13805
                if (maxTop <= minTop) {
#line 13806
                  p1 = maxTpin;
#line 13807
                  p2 = otherTpin;
                } else {
#line 13809
                  p1 = otherTpin;
#line 13810
                  p2 = maxTpin;
                }
#line 13812
                ((aNetSeg + segIndex)->ntop)->channel = (short )(block1 + 1);
#line 13813
                ((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 13814
                ((aNetSeg + segIndex)->ntop)->pin2 = p2;
              }
            } else {
              goto _L___16;
            }
          } else {
            goto _L___16;
          }
        } else {
          _L___16: /* CIL Label */ 
#line 13816
          if (maxBpin != 0) {
#line 13816
            if (otherBpin != 0) {
#line 13818
              (aNetSeg + segIndex)->nswYorN = (char)0;
#line 13819
              (aNetSeg + segIndex)->nkey = (short)0;
#line 13820
              (aNetSeg + segIndex)->ncurrent = (char)0;
#line 13821
              if (maxBottom <= minBottom) {
#line 13822
                p1 = maxBpin;
#line 13823
                p2 = otherBpin;
              } else {
#line 13825
                p1 = otherBpin;
#line 13826
                p2 = maxBpin;
              }
#line 13828
              ((aNetSeg + segIndex)->ntop)->channel = (short )block1;
#line 13829
              ((aNetSeg + segIndex)->ntop)->pin1 = p1;
#line 13830
              ((aNetSeg + segIndex)->ntop)->pin2 = p2;
            }
          }
        }
      }
#line 13833
      if ((int )(aNetSeg + segIndex)->nswYorN == 1) {
        goto _L___17;
      } else {
#line 13833
        if (key_flag != 0) {
          _L___17: /* CIL Label */ 
#line 13834
          channel = (int )((aNetSeg + segIndex)->ntop)->channel;
#line 13835
          if (key_flag == 0) {
#line 13836
            pin1 = ((aNetSeg + segIndex)->ntop)->pin1;
#line 13837
            pin2 = ((aNetSeg + segIndex)->ntop)->pin2;
          } else {
#line 13839
            if (k_right > k_left) {
#line 13840
              pin1 = ltop;
#line 13841
              pin2 = rtop;
            } else {
#line 13843
              pin2 = ((aNetSeg + segIndex)->ntop)->pin1;
#line 13843
              pin1 = pin2;
            }
          }
#line 13846
          ((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->up;
#line 13847
          if ((int )(*(tearray + pin1))->pinloc == 0) {
#line 13847
            if ((int )(*(tearray + pin1))->row == channel) {
#line 13849
              ((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->down;
            }
          }
#line 13851
          ((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->up;
#line 13852
          if ((int )(*(tearray + pin2))->pinloc == 0) {
#line 13852
            if ((int )(*(tearray + pin2))->row == channel) {
#line 13854
              ((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->down;
            }
          }
#line 13856
          channel = (int )((aNetSeg + segIndex)->nbot)->channel;
#line 13857
          if (key_flag == 0) {
#line 13858
            pin1 = ((aNetSeg + segIndex)->nbot)->pin1;
#line 13859
            pin2 = ((aNetSeg + segIndex)->nbot)->pin2;
          } else {
#line 13861
            if (k_right > k_left) {
#line 13862
              pin1 = lbot;
#line 13863
              pin2 = rbot;
            } else {
#line 13865
              pin2 = ((aNetSeg + segIndex)->nbot)->pin1;
#line 13865
              pin1 = pin2;
            }
          }
#line 13868
          ((aNetSeg + segIndex)->nbot)->pin1ptr = (*(Tgrid + pin1))->up;
#line 13869
          if ((int )(*(tearray + pin1))->pinloc == 0) {
#line 13869
            if ((int )(*(tearray + pin1))->row == channel) {
#line 13871
              ((aNetSeg + segIndex)->nbot)->pin1ptr = (*(Tgrid + pin1))->down;
            }
          }
#line 13873
          ((aNetSeg + segIndex)->nbot)->pin2ptr = (*(Tgrid + pin2))->up;
#line 13874
          if ((int )(*(tearray + pin2))->pinloc == 0) {
#line 13874
            if ((int )(*(tearray + pin2))->row == channel) {
#line 13876
              ((aNetSeg + segIndex)->nbot)->pin2ptr = (*(Tgrid + pin2))->down;
            }
          }
        } else {
#line 13879
          channel = (int )((aNetSeg + segIndex)->ntop)->channel;
#line 13880
          if (key_flag == 0) {
#line 13881
            pin1 = ((aNetSeg + segIndex)->ntop)->pin1;
#line 13882
            pin2 = ((aNetSeg + segIndex)->ntop)->pin2;
          } else {
#line 13884
            if (k_right > k_left) {
#line 13885
              pin1 = ltop;
#line 13886
              pin2 = rtop;
            } else {
#line 13888
              pin2 = ((aNetSeg + segIndex)->ntop)->pin1;
#line 13888
              pin1 = pin2;
            }
          }
#line 13891
          ((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->up;
#line 13892
          if ((int )(*(tearray + pin1))->pinloc == 0) {
#line 13892
            if ((int )(*(tearray + pin1))->row == channel) {
#line 13894
              ((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->down;
            }
          }
#line 13896
          ((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->up;
#line 13897
          if ((int )(*(tearray + pin2))->pinloc == 0) {
#line 13897
            if ((int )(*(tearray + pin2))->row == channel) {
#line 13899
              ((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->down;
            }
          }
        }
      }
    } else {
#line 13903
      minX = 1000000000;
#line 13904
      minP1 = 0;
#line 13905
      minP2 = 0;
#line 13906
      if (block1 > block2) {
#line 13907
        pin1 = 1;
#line 13907
        while (pin1 <= (int )(groupArray + group1)->numPins) {
#line 13908
          if ((int )(pArray1 + pin1)->top == -1) {
            goto _L___19;
          } else {
#line 13908
            if ((int )(pArray1 + pin1)->top == 0) {
              _L___19: /* CIL Label */ 
#line 13910
              pin2 = 1;
#line 13911
              while (pin2 <= (int )(groupArray + group2)->numPins) {
#line 13912
                if ((int )(pArray2 + pin2)->top == 1) {
                  goto _L___18;
                } else {
#line 13912
                  if ((int )(pArray2 + pin2)->top == 0) {
                    _L___18: /* CIL Label */ 
#line 13914
                    if ((int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc >= 0) {
#line 13914
                      tmp___5 = (int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc;
                    } else {
#line 13914
                      tmp___5 = - ((int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc);
                    }
#line 13914
                    if (tmp___5 < minX) {
#line 13916
                      left___0 = (int )(pArray1 + pin1)->xloc;
#line 13917
                      right = (int )(pArray2 + pin2)->xloc;
#line 13918
                      if (left___0 - right >= 0) {
#line 13918
                        minX = left___0 - right;
                      } else {
#line 13918
                        minX = - (left___0 - right);
                      }
#line 13919
                      minP1 = (pArray1 + pin1)->pin;
#line 13920
                      minP2 = (pArray2 + pin2)->pin;
                    }
                  }
                }
#line 13911
                pin2 ++;
              }
            }
          }
#line 13907
          pin1 ++;
        }
#line 13926
        if (minP1 != 0) {
#line 13926
          if (minP2 != 0) {
#line 13927
            (aNetSeg + segIndex)->nswYorN = (char)0;
#line 13928
            (aNetSeg + segIndex)->nkey = (short)0;
#line 13929
            (aNetSeg + segIndex)->ncurrent = (char)0;
#line 13930
            if (left___0 > right) {
#line 13931
              ((aNetSeg + segIndex)->ntop)->channel = (short )block1;
#line 13932
              ((aNetSeg + segIndex)->ntop)->pin1 = minP2;
#line 13933
              ((aNetSeg + segIndex)->ntop)->pin2 = minP1;
            } else {
#line 13935
              ((aNetSeg + segIndex)->ntop)->channel = (short )block1;
#line 13936
              ((aNetSeg + segIndex)->ntop)->pin1 = minP1;
#line 13937
              ((aNetSeg + segIndex)->ntop)->pin2 = minP2;
            }
          }
        }
      } else {
#line 13941
        pin1 = 1;
#line 13942
        while (pin1 <= (int )(groupArray + group1)->numPins) {
#line 13943
          if ((int )(pArray1 + pin1)->top == 1) {
            goto _L___21;
          } else {
#line 13943
            if ((int )(pArray1 + pin1)->top == 0) {
              _L___21: /* CIL Label */ 
#line 13945
              pin2 = 1;
#line 13946
              while (pin2 <= (int )(groupArray + group2)->numPins) {
#line 13947
                if ((int )(pArray2 + pin2)->top == -1) {
                  goto _L___20;
                } else {
#line 13947
                  if ((int )(pArray2 + pin2)->top == 0) {
                    _L___20: /* CIL Label */ 
#line 13949
                    if ((int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc >= 0) {
#line 13949
                      tmp___6 = (int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc;
                    } else {
#line 13949
                      tmp___6 = - ((int )(pArray1 + pin1)->xloc - (int )(pArray2 + pin2)->xloc);
                    }
#line 13949
                    if (tmp___6 < minX) {
#line 13951
                      left___0 = (int )(pArray1 + pin1)->xloc;
#line 13952
                      right = (int )(pArray2 + pin2)->xloc;
#line 13953
                      if (left___0 - right >= 0) {
#line 13953
                        minX = left___0 - right;
                      } else {
#line 13953
                        minX = - (left___0 - right);
                      }
#line 13954
                      minP1 = (pArray1 + pin1)->pin;
#line 13955
                      minP2 = (pArray2 + pin2)->pin;
                    }
                  }
                }
#line 13946
                pin2 ++;
              }
            }
          }
#line 13942
          pin1 ++;
        }
#line 13961
        if (minP1 != 0) {
#line 13961
          if (minP2 != 0) {
#line 13962
            (aNetSeg + segIndex)->nswYorN = (char)0;
#line 13963
            (aNetSeg + segIndex)->nkey = (short)0;
#line 13964
            (aNetSeg + segIndex)->ncurrent = (char)0;
#line 13965
            if (left___0 > right) {
#line 13966
              ((aNetSeg + segIndex)->ntop)->channel = (short )block2;
#line 13967
              ((aNetSeg + segIndex)->ntop)->pin1 = minP2;
#line 13968
              ((aNetSeg + segIndex)->ntop)->pin2 = minP1;
            } else {
#line 13970
              ((aNetSeg + segIndex)->ntop)->channel = (short )block2;
#line 13971
              ((aNetSeg + segIndex)->ntop)->pin1 = minP1;
#line 13972
              ((aNetSeg + segIndex)->ntop)->pin2 = minP2;
            }
          }
        }
      }
#line 13976
      channel = (int )((aNetSeg + segIndex)->ntop)->channel;
#line 13977
      pin1 = ((aNetSeg + segIndex)->ntop)->pin1;
#line 13978
      pin2 = ((aNetSeg + segIndex)->ntop)->pin2;
#line 13979
      ((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->up;
#line 13980
      if ((int )(*(tearray + pin1))->pinloc == 0) {
#line 13980
        if ((int )(*(tearray + pin1))->row == channel) {
#line 13982
          ((aNetSeg + segIndex)->ntop)->pin1ptr = (*(Tgrid + pin1))->down;
        }
      }
#line 13984
      ((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->up;
#line 13985
      if ((int )(*(tearray + pin2))->pinloc == 0) {
#line 13985
        if ((int )(*(tearray + pin2))->row == channel) {
#line 13987
          ((aNetSeg + segIndex)->ntop)->pin2ptr = (*(Tgrid + pin2))->down;
        }
      }
    }
  }
#line 13992
  if (segIndex != fault_line - 1) {
#line 13993
    printf("Serious FAULT detected in function: uclosepns():");
#line 13994
    printf("   Net:%d\n", net);
#line 13995
    tmp___7 = __getreent();
#line 13995
    fflush(tmp___7->_stdout);
  }
#line 13998
  return 0;
}
}
#line 14002 "D:/a/test/300.c"
int ucxx1(int bxcenter___0 , int bycenter___0 ) 
{ CBOXPTR acellptr___0 ;
  TIBOXPTR atileptr ;
  TEBOXPTR atermptr ;
  int cost ;
  int axcenter___0 ;
  int aleft___0 ;
  int aright___0 ;
  int a1LoBin ;
  int a1HiBin ;
  int b1LoBin ;
  int b1HiBin ;
  int startxa1 ;
  int endxa1 ;
  int startxb1 ;
  int endxb1 ;
  int truth ;
  int aorient ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 14014
  acellptr___0 = *(carray + a);
#line 14015
  aorient = (int )acellptr___0->corient;
#line 14016
  axcenter___0 = acellptr___0->cxcenter;
#line 14017
  atileptr = acellptr___0->tileptr;
#line 14018
  aleft___0 = (int )atileptr->left;
#line 14019
  aright___0 = (int )atileptr->right;
#line 14020
  atermptr = atileptr->termsptr;
#line 14021
  newbinpenal = binpenal;
#line 14022
  newrowpenal = rowpenal;
#line 14023
  newpenal = penalty;
#line 14024
  new_old(aleft___0 - aright___0);
#line 14025
  startxa1 = axcenter___0 + aleft___0;
#line 14025
  Trybin = (startxa1 - binOffst) / binWidth;
#line 14025
  if (Trybin < 0) {
#line 14025
    a1LoBin = 0;
  } else {
#line 14025
    if (Trybin > numBins) {
#line 14025
      tmp = numBins;
    } else {
#line 14025
      tmp = Trybin;
    }
#line 14025
    a1LoBin = tmp;
  }
#line 14026
  endxa1 = axcenter___0 + aright___0;
#line 14026
  Trybin = (endxa1 - binOffst) / binWidth;
#line 14026
  if (Trybin < 0) {
#line 14026
    a1HiBin = 0;
  } else {
#line 14026
    if (Trybin > numBins) {
#line 14026
      tmp___0 = numBins;
    } else {
#line 14026
      tmp___0 = Trybin;
    }
#line 14026
    a1HiBin = tmp___0;
  }
#line 14027
  startxb1 = bxcenter___0 + aleft___0;
#line 14027
  Trybin = (startxb1 - binOffst) / binWidth;
#line 14027
  if (Trybin < 0) {
#line 14027
    b1LoBin = 0;
  } else {
#line 14027
    if (Trybin > numBins) {
#line 14027
      tmp___1 = numBins;
    } else {
#line 14027
      tmp___1 = Trybin;
    }
#line 14027
    b1LoBin = tmp___1;
  }
#line 14028
  endxb1 = bxcenter___0 + aright___0;
#line 14028
  Trybin = (endxb1 - binOffst) / binWidth;
#line 14028
  if (Trybin < 0) {
#line 14028
    b1HiBin = 0;
  } else {
#line 14028
    if (Trybin > numBins) {
#line 14028
      tmp___2 = numBins;
    } else {
#line 14028
      tmp___2 = Trybin;
    }
#line 14028
    b1HiBin = tmp___2;
  }
#line 14029
  old_assgnto_new1(a1LoBin, a1HiBin, b1LoBin, b1HiBin);
#line 14030
  sub_penal(startxa1, endxa1, ablock, a1LoBin, a1HiBin);
#line 14031
  add_penal(startxb1, endxb1, bblock, b1LoBin, b1HiBin);
#line 14032
  if (ablock != bblock) {
#line 14033
    term_newpos_a(atermptr, bxcenter___0, bycenter___0, aorient);
  } else {
#line 14035
    term_newpos(atermptr, bxcenter___0, bycenter___0, aorient);
  }
#line 14037
  cost = funccost;
#line 14038
  delta_vert_cost = 0;
#line 14039
  if (ablock != bblock) {
#line 14040
    new_dbox_a(atermptr, & cost);
  } else {
#line 14042
    new_dbox(atermptr, & cost);
  }
#line 14044
  wire_chg = cost - funccost;
#line 14045
  binpen_chg = newbinpenal - binpenal;
#line 14046
  rowpen_chg = newrowpenal - rowpenal;
#line 14047
  newpenal = (int )(roLenCon * (double )newrowpenal + binpenCon * (double )newbinpenal);
#line 14049
  truth = acceptt((((funccost + penalty) - cost) - newpenal) - delta_vert_cost);
#line 14050
  if (truth == 1) {
#line 14051
    new_assgnto_old1(a1LoBin, a1HiBin, b1LoBin, b1HiBin);
#line 14052
    if (ablock != bblock) {
#line 14053
      dbox_pos_2(atermptr);
    } else {
#line 14055
      dbox_pos(atermptr);
    }
#line 14057
    if (*cellaptr != Apost) {
#line 14057
      *(cellaptr + Apost) = *(cellaptr + *cellaptr);
#line 14057
      (*cellaptr) --;
    } else {
#line 14057
      (*cellaptr) --;
    }
#line 14058
    add_cell(& cellbptr, a);
#line 14059
    acellptr___0->cblock = (short )bblock;
#line 14060
    acellptr___0->cxcenter = bxcenter___0;
#line 14061
    acellptr___0->cycenter = bycenter___0;
#line 14062
    funccost = cost;
#line 14063
    binpenal = newbinpenal;
#line 14064
    rowpenal = newrowpenal;
#line 14065
    penalty = newpenal;
#line 14066
    if (ablock != bblock) {
#line 14067
      (*(barray + ablock))->oldsize = (*(barray + ablock))->newsize;
#line 14068
      (*(barray + bblock))->oldsize = (*(barray + bblock))->newsize;
    }
#line 14070
    return (1);
  } else {
#line 14072
    return (0);
  }
}
}
#line 14076 "D:/a/test/300.c"
int find_new_pos(void) 
{ int newA_l ;
  int newA_r ;
  int newB_l ;
  int newB_r ;
  int oldA_l ;
  int oldA_r ;
  int oldB_l ;
  int oldB_r ;
  int span ;
  int target ;
  int target_l ;
  int target_r ;
  int blkLeft ;
  int blkRite ;
  int dist1 ;
  int dist2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 14082
  newA_l = bxcenter + aleft;
#line 14083
  newA_r = bxcenter + aright;
#line 14084
  newB_l = axcenter + bleft;
#line 14085
  newB_r = axcenter + bright;
#line 14086
  if (ablock == bblock) {
#line 14086
    if (newA_l >= newB_r) {
#line 14127
      anxcenter = bxcenter;
#line 14128
      bnxcenter = axcenter;
    } else {
#line 14086
      if (newB_l >= newA_r) {
#line 14127
        anxcenter = bxcenter;
#line 14128
        bnxcenter = axcenter;
      } else {
#line 14087
        oldA_l = axcenter + aleft;
#line 14088
        oldA_r = axcenter + aright;
#line 14089
        oldB_l = bxcenter + bleft;
#line 14090
        oldB_r = bxcenter + bright;
#line 14091
        if (oldA_l >= oldB_r) {
          goto _L;
        } else {
#line 14091
          if (oldB_l >= oldA_r) {
            _L: /* CIL Label */ 
#line 14118
            if (oldA_l <= oldB_l) {
#line 14119
              bnxcenter = oldA_l - bleft;
#line 14120
              anxcenter = oldB_r - aright;
            } else {
#line 14122
              anxcenter = oldB_l - aleft;
#line 14123
              bnxcenter = oldA_r - bright;
            }
          } else {
#line 14093
            span = ((aright - aleft) + bright) - bleft;
#line 14094
            if (oldA_l <= oldB_l) {
#line 14094
              tmp = oldA_l;
            } else {
#line 14094
              tmp = oldB_l;
            }
#line 14094
            if (oldA_r >= oldB_r) {
#line 14094
              tmp___0 = oldA_r;
            } else {
#line 14094
              tmp___0 = oldB_r;
            }
#line 14094
            target = (tmp + tmp___0) / 2;
#line 14096
            target_l = target - span / 2;
#line 14097
            target_r = target_l + span;
#line 14098
            blkLeft = (*(barray + ablock))->bxcenter + (int )(*(barray + ablock))->bleft;
#line 14099
            blkRite = blkLeft + (int )(*(barray + ablock))->desire;
#line 14100
            if (target_l < blkLeft) {
#line 14101
              target_l += blkLeft - target_l;
#line 14102
              target_r += blkLeft - target_l;
            } else {
#line 14103
              if (target_r > blkRite) {
#line 14104
                target_l -= target_r - blkRite;
#line 14105
                target_r -= target_r - blkRite;
              }
            }
#line 14107
            dist1 = newA_r - newB_l;
#line 14108
            dist2 = newB_r - newA_l;
#line 14109
            if (dist1 <= dist2) {
#line 14110
              anxcenter = target_l - aleft;
#line 14111
              bnxcenter = target_r - bright;
            } else {
#line 14113
              anxcenter = target_r - aright;
#line 14114
              bnxcenter = target_l - bleft;
            }
          }
        }
      }
    }
  } else {
#line 14127
    anxcenter = bxcenter;
#line 14128
    bnxcenter = axcenter;
  }
#line 14130
  return 0;
}
}
#line 14132 "D:/a/test/300.c"
int add_cell(int **cellptr___0 , int c ) 
{ int k___0 ;
  char *tmp ;

  {
#line 14136
  (*(*cellptr___0)) ++;
#line 14136
  k___0 = *(*cellptr___0);
#line 14136
  if (k___0 % 10 == 0) {
#line 14137
    tmp = safe_realloc((char *)*cellptr___0, (unsigned int )(k___0 + 10) * sizeof(int ));
#line 14137
    *cellptr___0 = (int *)tmp;
  }
#line 14139
  *(*cellptr___0 + k___0) = c;
#line 14140
  return 0;
}
}
#line 14144 "D:/a/test/300.c"
int ucxxo1(int bxcenter___0 , int bycenter___0 , int newaor ) 
{ CBOXPTR acellptr___0 ;
  TIBOXPTR atileptr ;
  TEBOXPTR antrmptr ;
  int cost ;
  int axcenter___0 ;
  int aleft___0 ;
  int aright___0 ;
  int a1LoBin ;
  int a1HiBin ;
  int b1LoBin ;
  int b1HiBin ;
  int startxa1 ;
  int endxa1 ;
  int startxb1 ;
  int endxb1 ;
  int truth ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 14156
  acellptr___0 = *(carray + a);
#line 14157
  axcenter___0 = acellptr___0->cxcenter;
#line 14158
  atileptr = acellptr___0->tileptr;
#line 14159
  aleft___0 = (int )atileptr->left;
#line 14160
  aright___0 = (int )atileptr->right;
#line 14161
  antrmptr = atileptr->termsptr;
#line 14162
  newbinpenal = binpenal;
#line 14163
  newrowpenal = rowpenal;
#line 14164
  newpenal = penalty;
#line 14165
  new_old(aleft___0 - aright___0);
#line 14166
  startxa1 = axcenter___0 + aleft___0;
#line 14166
  Trybin = (startxa1 - binOffst) / binWidth;
#line 14166
  if (Trybin < 0) {
#line 14166
    a1LoBin = 0;
  } else {
#line 14166
    if (Trybin > numBins) {
#line 14166
      tmp = numBins;
    } else {
#line 14166
      tmp = Trybin;
    }
#line 14166
    a1LoBin = tmp;
  }
#line 14167
  endxa1 = axcenter___0 + aright___0;
#line 14167
  Trybin = (endxa1 - binOffst) / binWidth;
#line 14167
  if (Trybin < 0) {
#line 14167
    a1HiBin = 0;
  } else {
#line 14167
    if (Trybin > numBins) {
#line 14167
      tmp___0 = numBins;
    } else {
#line 14167
      tmp___0 = Trybin;
    }
#line 14167
    a1HiBin = tmp___0;
  }
#line 14168
  startxb1 = bxcenter___0 + aleft___0;
#line 14168
  Trybin = (startxb1 - binOffst) / binWidth;
#line 14168
  if (Trybin < 0) {
#line 14168
    b1LoBin = 0;
  } else {
#line 14168
    if (Trybin > numBins) {
#line 14168
      tmp___1 = numBins;
    } else {
#line 14168
      tmp___1 = Trybin;
    }
#line 14168
    b1LoBin = tmp___1;
  }
#line 14169
  endxb1 = bxcenter___0 + aright___0;
#line 14169
  Trybin = (endxb1 - binOffst) / binWidth;
#line 14169
  if (Trybin < 0) {
#line 14169
    b1HiBin = 0;
  } else {
#line 14169
    if (Trybin > numBins) {
#line 14169
      tmp___2 = numBins;
    } else {
#line 14169
      tmp___2 = Trybin;
    }
#line 14169
    b1HiBin = tmp___2;
  }
#line 14170
  old_assgnto_new1(a1LoBin, a1HiBin, b1LoBin, b1HiBin);
#line 14171
  sub_penal(startxa1, endxa1, ablock, a1LoBin, a1HiBin);
#line 14172
  add_penal(startxb1, endxb1, bblock, b1LoBin, b1HiBin);
#line 14173
  if (ablock != bblock) {
#line 14174
    term_newpos_a(antrmptr, bxcenter___0, bycenter___0, newaor);
  } else {
#line 14176
    term_newpos(antrmptr, bxcenter___0, bycenter___0, newaor);
  }
#line 14178
  cost = funccost;
#line 14179
  delta_vert_cost = 0;
#line 14180
  if (ablock != bblock) {
#line 14181
    new_dbox_a(antrmptr, & cost);
  } else {
#line 14183
    new_dbox(antrmptr, & cost);
  }
#line 14185
  wire_chg = cost - funccost;
#line 14186
  binpen_chg = newbinpenal - binpenal;
#line 14187
  rowpen_chg = newrowpenal - rowpenal;
#line 14188
  newpenal = (int )(roLenCon * (double )newrowpenal + binpenCon * (double )newbinpenal);
#line 14190
  truth = acceptt((((funccost + penalty) - cost) - newpenal) - delta_vert_cost);
#line 14191
  if (truth == 1) {
#line 14192
    new_assgnto_old1(a1LoBin, a1HiBin, b1LoBin, b1HiBin);
#line 14193
    if (ablock != bblock) {
#line 14194
      dbox_pos_2(antrmptr);
    } else {
#line 14196
      dbox_pos(antrmptr);
    }
#line 14198
    if (*cellaptr != Apost) {
#line 14198
      *(cellaptr + Apost) = *(cellaptr + *cellaptr);
#line 14198
      (*cellaptr) --;
    } else {
#line 14198
      (*cellaptr) --;
    }
#line 14199
    add_cell(& cellbptr, a);
#line 14200
    acellptr___0->cblock = (short )bblock;
#line 14201
    acellptr___0->cxcenter = bxcenter___0;
#line 14202
    acellptr___0->cycenter = bycenter___0;
#line 14203
    acellptr___0->corient = (char )newaor;
#line 14204
    funccost = cost;
#line 14205
    binpenal = newbinpenal;
#line 14206
    rowpenal = newrowpenal;
#line 14207
    penalty = newpenal;
#line 14208
    if (ablock != bblock) {
#line 14209
      (*(barray + ablock))->oldsize = (*(barray + ablock))->newsize;
#line 14210
      (*(barray + bblock))->oldsize = (*(barray + bblock))->newsize;
    }
#line 14212
    return (1);
  } else {
#line 14214
    return (0);
  }
}
}
#line 14226 "D:/a/test/300.c"
int ucxxo2(int newaor , int newbor ) 
{ CBOXPTR acellptr___0 ;
  CBOXPTR bcellptr___0 ;
  TIBOXPTR atileptr ;
  TIBOXPTR btileptr ;
  TEBOXPTR antrmptr ;
  TEBOXPTR bntrmptr ;
  double temp ;
  int cost ;
  int error_light_is_on ;
  int axcenter___0 ;
  int aycenter___0 ;
  int bxcenter___0 ;
  int bycenter___0 ;
  int aleft___0 ;
  int aright___0 ;
  int bleft___0 ;
  int bright___0 ;
  int a1LoBin ;
  int a2LoBin ;
  int b1LoBin ;
  int b2LoBin ;
  int a1HiBin ;
  int a2HiBin ;
  int b1HiBin ;
  int b2HiBin ;
  int startxa1 ;
  int endxa1 ;
  int startxa2 ;
  int endxa2 ;
  int startxb1 ;
  int endxb1 ;
  int startxb2 ;
  int endxb2 ;
  int truth ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 14242
  acellptr___0 = *(carray + a);
#line 14243
  axcenter___0 = acellptr___0->cxcenter;
#line 14244
  aycenter___0 = acellptr___0->cycenter;
#line 14245
  atileptr = acellptr___0->tileptr;
#line 14246
  aleft___0 = (int )atileptr->left;
#line 14247
  aright___0 = (int )atileptr->right;
#line 14248
  antrmptr = atileptr->termsptr;
#line 14249
  bcellptr___0 = *(carray + b);
#line 14250
  bxcenter___0 = bcellptr___0->cxcenter;
#line 14251
  bycenter___0 = bcellptr___0->cycenter;
#line 14252
  btileptr = bcellptr___0->tileptr;
#line 14253
  bleft___0 = (int )btileptr->left;
#line 14254
  bright___0 = (int )btileptr->right;
#line 14255
  bntrmptr = btileptr->termsptr;
#line 14256
  newbinpenal = binpenal;
#line 14257
  newrowpenal = rowpenal;
#line 14258
  newpenal = penalty;
#line 14259
  new_old(((bright___0 - bleft___0) - aright___0) + aleft___0);
#line 14260
  startxa1 = axcenter___0 + aleft___0;
#line 14260
  Trybin = (startxa1 - binOffst) / binWidth;
#line 14260
  if (Trybin < 0) {
#line 14260
    a1LoBin = 0;
  } else {
#line 14260
    if (Trybin > numBins) {
#line 14260
      tmp = numBins;
    } else {
#line 14260
      tmp = Trybin;
    }
#line 14260
    a1LoBin = tmp;
  }
#line 14261
  endxa1 = axcenter___0 + aright___0;
#line 14261
  Trybin = (endxa1 - binOffst) / binWidth;
#line 14261
  if (Trybin < 0) {
#line 14261
    a1HiBin = 0;
  } else {
#line 14261
    if (Trybin > numBins) {
#line 14261
      tmp___0 = numBins;
    } else {
#line 14261
      tmp___0 = Trybin;
    }
#line 14261
    a1HiBin = tmp___0;
  }
#line 14262
  startxb1 = bxcenter___0 + bleft___0;
#line 14262
  Trybin = (startxb1 - binOffst) / binWidth;
#line 14262
  if (Trybin < 0) {
#line 14262
    b1LoBin = 0;
  } else {
#line 14262
    if (Trybin > numBins) {
#line 14262
      tmp___1 = numBins;
    } else {
#line 14262
      tmp___1 = Trybin;
    }
#line 14262
    b1LoBin = tmp___1;
  }
#line 14263
  endxb1 = bxcenter___0 + bright___0;
#line 14263
  Trybin = (endxb1 - binOffst) / binWidth;
#line 14263
  if (Trybin < 0) {
#line 14263
    b1HiBin = 0;
  } else {
#line 14263
    if (Trybin > numBins) {
#line 14263
      tmp___2 = numBins;
    } else {
#line 14263
      tmp___2 = Trybin;
    }
#line 14263
    b1HiBin = tmp___2;
  }
#line 14264
  startxa2 = bxcenter___0 + aleft___0;
#line 14264
  Trybin = (startxa2 - binOffst) / binWidth;
#line 14264
  if (Trybin < 0) {
#line 14264
    a2LoBin = 0;
  } else {
#line 14264
    if (Trybin > numBins) {
#line 14264
      tmp___3 = numBins;
    } else {
#line 14264
      tmp___3 = Trybin;
    }
#line 14264
    a2LoBin = tmp___3;
  }
#line 14265
  endxa2 = bxcenter___0 + aright___0;
#line 14265
  Trybin = (endxa2 - binOffst) / binWidth;
#line 14265
  if (Trybin < 0) {
#line 14265
    a2HiBin = 0;
  } else {
#line 14265
    if (Trybin > numBins) {
#line 14265
      tmp___4 = numBins;
    } else {
#line 14265
      tmp___4 = Trybin;
    }
#line 14265
    a2HiBin = tmp___4;
  }
#line 14266
  startxb2 = axcenter___0 + bleft___0;
#line 14266
  Trybin = (startxb2 - binOffst) / binWidth;
#line 14266
  if (Trybin < 0) {
#line 14266
    b2LoBin = 0;
  } else {
#line 14266
    if (Trybin > numBins) {
#line 14266
      tmp___5 = numBins;
    } else {
#line 14266
      tmp___5 = Trybin;
    }
#line 14266
    b2LoBin = tmp___5;
  }
#line 14267
  endxb2 = axcenter___0 + bright___0;
#line 14267
  Trybin = (endxb2 - binOffst) / binWidth;
#line 14267
  if (Trybin < 0) {
#line 14267
    b2HiBin = 0;
  } else {
#line 14267
    if (Trybin > numBins) {
#line 14267
      tmp___6 = numBins;
    } else {
#line 14267
      tmp___6 = Trybin;
    }
#line 14267
    b2HiBin = tmp___6;
  }
#line 14268
  old_assgnto_new2(a1LoBin, a1HiBin, b1LoBin, b1HiBin, a2LoBin, a2HiBin, b2LoBin,
                   b2HiBin);
#line 14270
  sub_penal(startxa1, endxa1, ablock, a1LoBin, a1HiBin);
#line 14271
  sub_penal(startxb1, endxb1, bblock, b1LoBin, b1HiBin);
#line 14272
  add_penal(startxa2, endxa2, bblock, a2LoBin, a2HiBin);
#line 14273
  add_penal(startxb2, endxb2, ablock, b2LoBin, b2HiBin);
#line 14274
  binpen_chg = newbinpenal - binpenal;
#line 14275
  rowpen_chg = newrowpenal - rowpenal;
#line 14276
  newpenal = (int )(roLenCon * (double )newrowpenal + binpenCon * (double )newbinpenal);
#line 14278
  error_light_is_on = 0;
#line 14279
  if (newpenal - penalty > P_limit) {
#line 14280
    if (potential_errors < 100) {
#line 14281
      potential_errors ++;
#line 14282
      error_light_is_on = 1;
    } else {
#line 14284
      earlyRej ++;
#line 14285
      return (-1);
    }
  }
#line 14288
  if (ablock != bblock) {
#line 14289
    term_newpos_a(antrmptr, bxcenter___0, bycenter___0, newaor);
#line 14290
    term_newpos_b(bntrmptr, axcenter___0, aycenter___0, newbor);
  } else {
#line 14292
    term_newpos(antrmptr, bxcenter___0, bycenter___0, newaor);
#line 14293
    term_newpos(bntrmptr, axcenter___0, aycenter___0, newbor);
  }
#line 14295
  cost = funccost;
#line 14296
  delta_vert_cost = 0;
#line 14297
  if (ablock != bblock) {
#line 14298
    new_dbox_a(antrmptr, & cost);
#line 14299
    new_dbox_a(bntrmptr, & cost);
  } else {
#line 14301
    new_dbox(antrmptr, & cost);
#line 14302
    new_dbox(bntrmptr, & cost);
  }
#line 14304
  wire_chg = cost - funccost;
#line 14305
  truth = acceptt((((funccost + penalty) - cost) - newpenal) - delta_vert_cost);
#line 14306
  if (truth == 1) {
#line 14307
    if (error_light_is_on) {
#line 14308
      error_count ++;
    }
#line 14310
    new_assgnto_old2(a1LoBin, a1HiBin, b1LoBin, b1HiBin, a2LoBin, a2HiBin, b2LoBin,
                     b2HiBin);
#line 14312
    if (ablock != bblock) {
#line 14313
      dbox_pos_2(antrmptr);
#line 14314
      dbox_pos_2(bntrmptr);
    } else {
#line 14316
      dbox_pos(antrmptr);
#line 14317
      dbox_pos(bntrmptr);
    }
#line 14319
    if ((unsigned int )cellaptr != (unsigned int )cellbptr) {
#line 14320
      if (*cellaptr != Apost) {
#line 14320
        *(cellaptr + Apost) = *(cellaptr + *cellaptr);
#line 14320
        (*cellaptr) --;
      } else {
#line 14320
        (*cellaptr) --;
      }
#line 14321
      if (*cellbptr != Bpost) {
#line 14321
        *(cellbptr + Bpost) = *(cellbptr + *cellbptr);
#line 14321
        (*cellbptr) --;
      } else {
#line 14321
        (*cellbptr) --;
      }
#line 14322
      add_cell(& cellbptr, a);
#line 14323
      add_cell(& cellaptr, b);
    }
#line 14325
    if (wire_chg < 0) {
#line 14326
      temp = (double )(- wire_chg);
#line 14327
      total_wire_chg += temp;
#line 14328
      sigma_wire_chg += (temp - mean_wire_chg) * (temp - mean_wire_chg);
#line 14330
      wire_chgs ++;
    }
#line 14332
    acellptr___0->cblock = (short )bblock;
#line 14333
    acellptr___0->cxcenter = bxcenter___0;
#line 14334
    acellptr___0->cycenter = bycenter___0;
#line 14335
    bcellptr___0->cblock = (short )ablock;
#line 14336
    bcellptr___0->cxcenter = axcenter___0;
#line 14337
    bcellptr___0->cycenter = aycenter___0;
#line 14338
    acellptr___0->corient = (char )newaor;
#line 14339
    bcellptr___0->corient = (char )newbor;
#line 14340
    funccost = cost;
#line 14341
    binpenal = newbinpenal;
#line 14342
    rowpenal = newrowpenal;
#line 14343
    penalty = newpenal;
#line 14344
    if (ablock != bblock) {
#line 14345
      (*(barray + ablock))->oldsize = (*(barray + ablock))->newsize;
#line 14346
      (*(barray + bblock))->oldsize = (*(barray + bblock))->newsize;
    }
#line 14348
    return (1);
  } else {
#line 14350
    return (0);
  }
}
}
#line 14355 "D:/a/test/300.c"
int ucxxp(int a___0 , int b___0 , int anxcenter___0 , int bnxcenter___0 ) 
{ CBOXPTR acellptr___0 ;
  CBOXPTR bcellptr___0 ;
  TIBOXPTR atileptr ;
  TIBOXPTR btileptr ;
  TEBOXPTR atermptr ;
  TEBOXPTR btermptr ;
  int cost ;
  int aorient ;
  int borient___0 ;
  int aycenter___0 ;
  int bycenter___0 ;
  int truth ;

  {
#line 14365
  acellptr___0 = *(carray + a___0);
#line 14366
  aycenter___0 = acellptr___0->cycenter;
#line 14367
  aorient = (int )acellptr___0->corient;
#line 14368
  atileptr = acellptr___0->tileptr;
#line 14369
  atermptr = atileptr->termsptr;
#line 14370
  bcellptr___0 = *(carray + b___0);
#line 14371
  bycenter___0 = bcellptr___0->cycenter;
#line 14372
  borient___0 = (int )bcellptr___0->corient;
#line 14373
  btileptr = bcellptr___0->tileptr;
#line 14374
  btermptr = btileptr->termsptr;
#line 14375
  term_newpos(atermptr, anxcenter___0, bycenter___0, aorient);
#line 14376
  term_newpos(btermptr, bnxcenter___0, aycenter___0, borient___0);
#line 14377
  cost = funccost;
#line 14378
  new_dbox(atermptr, & cost);
#line 14379
  new_dbox(btermptr, & cost);
#line 14380
  truth = acceptt(funccost - cost);
#line 14381
  if (truth == 1) {
#line 14382
    dbox_pos(atermptr);
#line 14383
    dbox_pos(btermptr);
#line 14384
    acellptr___0->cxcenter = anxcenter___0;
#line 14385
    acellptr___0->cycenter = bycenter___0;
#line 14386
    bcellptr___0->cxcenter = bnxcenter___0;
#line 14387
    bcellptr___0->cycenter = aycenter___0;
#line 14388
    funccost = cost;
#line 14389
    return (1);
  } else {
#line 14391
    return (0);
  }
}
}
#line 14943
int uglobrout(void) ;
#line 14410 "D:/a/test/300.c"
int uglobe(void) 
{ NBOXPTR netptr ;
  CBOXPTR cellptr1 ;
  CBOXPTR cellptr2 ;
  int group1 ;
  int group2 ;
  int edge___0 ;
  int i ;
  int pin ;
  int net ;
  int group ;
  int cell1 ;
  int cell2 ;
  int top___0 ;
  int extint ;
  int block___0 ;
  int locX ;
  int locY ;
  int flag1 ;
  int flag2 ;
  int chgloop ;
  int found ;
  int type1 ;
  int unequiv ;
  int added_an_edge ;
  int ue_grp ;
  int g1 ;
  int g2 ;
  int ei1 ;
  int ei2 ;
  int ei ;
  int done ;
  int edge2 ;
  int jj ;
  int a1 ;
  int b1 ;
  int a2 ;
  int b2 ;
  int edge1 ;
  int ya ;
  int yb ;
  int single_pin1 ;
  int single_pin2 ;
  int unequiv1 ;
  int unequiv2 ;

  {
#line 14422
  i = 0;
#line 14422
  while (i <= MPG) {
#line 14423
    (groupArray + i)->numPins = (short)0;
#line 14424
    (groupArray + i)->flag = (short)0;
#line 14425
    (groupArray + i)->poison = (short)0;
#line 14426
    (groupArray + i)->unequiv = (short)0;
#line 14427
    (groupArray + i)->extint = 0;
#line 14428
    (groupArray + i)->edge1 = (short)0;
#line 14429
    (groupArray + i)->edge2 = (short)0;
#line 14430
    (groupArray + i)->check = (short)0;
#line 14422
    i ++;
  }
#line 14432
  i = 0;
#line 14432
  while (i <= ME) {
#line 14433
    (edgeArray + i)->marked = (short)0;
#line 14434
    (edgeArray + i)->done = (short)0;
#line 14435
    (edgeArray + i)->poison = (short)0;
#line 14432
    i ++;
  }
#line 14437
  chgloop = 1;
#line 14437
  while (chgloop <= *(netchgs + 0)) {
#line 14438
    net = *(netchgs + chgloop);
#line 14439
    numEdges = 0;
#line 14440
    top_row = -1;
#line 14441
    jj = 0;
#line 14441
    while (jj <= numRows + 1) {
#line 14442
      *(*(pseudoPins + jj) + 0) = 0;
#line 14443
      *(*(pseudoPins + jj) + 1) = 0;
#line 14444
      *(*(pseudoEdge + jj) + 0) = 0;
#line 14445
      *(*(pseudoEdge + jj) + 1) = 0;
#line 14441
      jj ++;
    }
#line 14447
    netptr = (*(netarray + net))->netptr;
#line 14448
    while ((unsigned int )netptr != (unsigned int )((struct netbox *)((void *)0))) {
#line 14449
      top___0 = (int )netptr->pinloc;
#line 14450
      extint = netptr->extint;
#line 14451
      unequiv = (int )netptr->unequiv;
#line 14452
      block___0 = (int )netptr->row;
#line 14453
      if (block___0 > top_row) {
#line 14454
        if ((int )netptr->cell <= numcells) {
#line 14455
          top_row = block___0;
        } else {
#line 14456
          if ((int )(*(carray + netptr->cell))->padside != 1) {
#line 14456
            if ((int )(*(carray + netptr->cell))->padside != 3) {
#line 14458
              top_row = block___0;
            }
          }
        }
      }
#line 14461
      locX = netptr->xpos;
#line 14462
      locY = netptr->ypos;
#line 14463
      pin = netptr->terminal;
#line 14464
      found = 0;
#line 14465
      group = 1;
#line 14466
      while (1) {
#line 14466
        if ((int )(groupArray + group)->numPins != 0) {
#line 14466
          if (! (found == 0)) {
#line 14466
            break;
          }
        } else {
#line 14466
          break;
        }
#line 14467
        if ((groupArray + group)->extint == extint) {
#line 14467
          if (unequiv == 0) {
#line 14468
            found = 1;
          } else {
#line 14470
            group ++;
          }
        } else {
#line 14470
          group ++;
        }
      }
#line 14473
      numPins = (int )(groupArray + group)->numPins + 1;
#line 14474
      (groupArray + group)->numPins = (short )numPins;
#line 14475
      ((groupArray + group)->pinArray + numPins)->xloc = (short )locX;
#line 14476
      ((groupArray + group)->pinArray + numPins)->yloc = (short )locY;
#line 14477
      ((groupArray + group)->pinArray + numPins)->top = (short )top___0;
#line 14478
      ((groupArray + group)->pinArray + numPins)->pin = pin;
#line 14479
      if (found == 0) {
#line 14480
        (groupArray + group)->aveX = locX;
#line 14481
        (groupArray + group)->aveY = locY;
#line 14482
        (groupArray + group)->extint = extint;
#line 14483
        (groupArray + group)->unequiv = (short )unequiv;
#line 14484
        (groupArray + group)->block = (short )block___0;
      } else {
#line 14487
        (groupArray + group)->aveX += locX;
#line 14488
        (groupArray + group)->aveY += locY;
      }
#line 14448
      netptr = netptr->nterm;
    }
#line 14491
    group = 1;
#line 14492
    group = 1;
#line 14492
    while ((int )(groupArray + group)->numPins != 0) {
#line 14493
      numPins = (int )(groupArray + group)->numPins;
#line 14494
      if (numPins > 1) {
#line 14495
        (groupArray + group)->aveX /= numPins;
#line 14496
        (groupArray + group)->aveY /= numPins;
      }
#line 14492
      group ++;
    }
#line 14499
    numGroups = 0;
#line 14500
    while ((int )(groupArray + (numGroups + 1))->numPins != 0) {
#line 14501
      numGroups ++;
    }
#line 14503
    if (numGroups == 2) {
#line 14504
      if ((int )(groupArray + 1)->unequiv == 1) {
#line 14504
        if ((int )(groupArray + 2)->unequiv == 1) {
#line 14505
          i = 1;
#line 14505
          while (i <= numGroups) {
#line 14506
            (groupArray + i)->numPins = (short)0;
#line 14507
            (groupArray + i)->flag = (short)0;
#line 14508
            (groupArray + i)->poison = (short)0;
#line 14509
            (groupArray + i)->unequiv = (short)0;
#line 14510
            (groupArray + i)->extint = 0;
#line 14511
            (groupArray + i)->edge1 = (short)0;
#line 14512
            (groupArray + i)->edge2 = (short)0;
#line 14513
            (groupArray + i)->check = (short)0;
#line 14505
            i ++;
          }
#line 14515
          i = 1;
#line 14515
          while (i <= numEdges) {
#line 14516
            (edgeArray + i)->marked = (short)0;
#line 14517
            (edgeArray + i)->done = (short)0;
#line 14518
            (edgeArray + i)->poison = (short)0;
#line 14515
            i ++;
          }
          goto __Cont;
        }
      }
    } else {
#line 14522
      if (numGroups <= 1) {
#line 14523
        i = 1;
#line 14523
        while (i <= numGroups) {
#line 14524
          (groupArray + i)->numPins = (short)0;
#line 14525
          (groupArray + i)->flag = (short)0;
#line 14526
          (groupArray + i)->poison = (short)0;
#line 14527
          (groupArray + i)->unequiv = (short)0;
#line 14528
          (groupArray + i)->extint = 0;
#line 14529
          (groupArray + i)->edge1 = (short)0;
#line 14530
          (groupArray + i)->edge2 = (short)0;
#line 14531
          (groupArray + i)->check = (short)0;
#line 14523
          i ++;
        }
#line 14533
        i = 1;
#line 14533
        while (i <= numEdges) {
#line 14534
          (edgeArray + i)->marked = (short)0;
#line 14535
          (edgeArray + i)->done = (short)0;
#line 14536
          (edgeArray + i)->poison = (short)0;
#line 14533
          i ++;
        }
        goto __Cont;
      }
    }
#line 14540
    qsortg((char *)(groupArray + 1), numGroups, (int )sizeof(csGroup ));
#line 14541
    group = 1;
#line 14541
    while (group < numGroups) {
#line 14542
      block___0 = (int )(groupArray + group)->block;
#line 14543
      type1 = detGroup(group);
#line 14544
      searchG(group, type1, block___0);
#line 14541
      group ++;
    }
#line 14546
    edge1 = 1;
#line 14546
    while (edge1 <= numEdges) {
#line 14547
      a1 = (int )(edgeArray + edge1)->group1;
#line 14548
      a2 = (int )(edgeArray + edge1)->group2;
#line 14549
      if ((int )(groupArray + a1)->block != (int )(groupArray + a2)->block) {
        goto __Cont___0;
      }
#line 14552
      edge2 = edge1 + 1;
#line 14552
      while (edge2 <= numEdges) {
#line 14553
        b1 = (int )(edgeArray + edge2)->group1;
#line 14554
        b2 = (int )(edgeArray + edge2)->group2;
#line 14555
        if ((int )(groupArray + b1)->block != (int )(groupArray + b2)->block) {
          goto __Cont___1;
        }
#line 14558
        if ((int )(groupArray + a1)->unequiv == 1) {
#line 14558
          if ((int )(groupArray + b1)->unequiv == 1) {
#line 14558
            if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
#line 14558
              if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
                goto _L;
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 14558
          if ((int )(groupArray + a2)->unequiv == 1) {
#line 14558
            if ((int )(groupArray + b2)->unequiv == 1) {
#line 14558
              if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
#line 14558
                if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
                  _L: /* CIL Label */ 
#line 14566
                  ya = ((groupArray + a1)->aveY + (groupArray + a2)->aveY) / 2;
#line 14567
                  yb = ((groupArray + b1)->aveY + (groupArray + b2)->aveY) / 2;
#line 14568
                  if ((int )(groupArray + a1)->block == top_row) {
#line 14569
                    if (ya < yb) {
#line 14570
                      if ((int )(edgeArray + edge2)->cost <= (int )(edgeArray + edge1)->cost) {
#line 14572
                        (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost + 1);
                      }
                    } else {
#line 14576
                      if ((int )(edgeArray + edge2)->cost >= (int )(edgeArray + edge1)->cost) {
#line 14578
                        (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost - 1);
                      }
                    }
                  } else {
#line 14583
                    if (ya < yb) {
#line 14584
                      if ((int )(edgeArray + edge2)->cost >= (int )(edgeArray + edge1)->cost) {
#line 14586
                        (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost - 1);
                      }
                    } else {
#line 14590
                      if ((int )(edgeArray + edge2)->cost <= (int )(edgeArray + edge1)->cost) {
#line 14592
                        (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost + 1);
                      }
                    }
                  }
#line 14597
                  break;
                }
              }
            }
          }
        }
        __Cont___1: /* CIL Label */ 
#line 14552
        edge2 ++;
      }
      __Cont___0: /* CIL Label */ 
#line 14546
      edge1 ++;
    }
#line 14601
    qsorte((char *)(edgeArray + 1), numEdges, (int )sizeof(edgeBox ));
#line 14602
    group = 1;
#line 14602
    while (group <= numGroups) {
#line 14603
      (groupArray + group)->flag = (short )group;
#line 14602
      group ++;
    }
#line 14605
    edge___0 = 1;
#line 14605
    while (edge___0 <= numEdges) {
#line 14606
      group1 = (int )(edgeArray + edge___0)->group1;
#line 14607
      flag1 = (int )(groupArray + group1)->flag;
#line 14608
      group2 = (int )(edgeArray + edge___0)->group2;
#line 14609
      flag2 = (int )(groupArray + group2)->flag;
#line 14610
      if (flag1 <= 0) {
        goto __Cont___2;
      } else {
#line 14610
        if (flag2 <= 0) {
          goto __Cont___2;
        } else {
#line 14610
          if (flag1 == flag2) {
            goto __Cont___2;
          }
        }
      }
#line 14613
      added_an_edge = 0;
#line 14614
      (edgeArray + edge___0)->marked = (short)1;
#line 14615
      group = 1;
#line 14615
      while (group <= numGroups) {
#line 14616
        if ((int )(groupArray + group)->flag == flag2) {
#line 14617
          (groupArray + group)->flag = (short )flag1;
        }
#line 14615
        group ++;
      }
#line 14620
      cell1 = (int )(*(tearray + ((groupArray + group1)->pinArray + 1)->pin))->cell;
#line 14621
      cell2 = (int )(*(tearray + ((groupArray + group2)->pinArray + 1)->pin))->cell;
#line 14622
      cellptr1 = *(carray + cell1);
#line 14623
      cellptr2 = *(carray + cell2);
#line 14624
      if (cell1 > numcells) {
#line 14624
        if ((int )cellptr1->padside != 2) {
#line 14624
          if ((int )cellptr1->padside != 14) {
#line 14624
            if ((int )cellptr1->padside != 15) {
#line 14624
              if ((int )cellptr1->padside != 4) {
#line 14628
                if (cell2 <= numcells) {
#line 14629
                  (groupArray + group1)->flag = (short)0;
                }
              }
            }
          }
        }
      }
#line 14632
      if (cell2 > numcells) {
#line 14632
        if ((int )cellptr2->padside != 2) {
#line 14632
          if ((int )cellptr2->padside != 14) {
#line 14632
            if ((int )cellptr2->padside != 15) {
#line 14632
              if ((int )cellptr2->padside != 4) {
#line 14636
                if (cell1 <= numcells) {
#line 14637
                  (groupArray + group2)->flag = (short)0;
                }
              }
            }
          }
        }
      }
#line 14640
      if ((int )(groupArray + group1)->unequiv == 1) {
#line 14641
        ei1 = (groupArray + group1)->extint;
#line 14642
        ue_grp = 1;
#line 14642
        while (ue_grp <= numGroups) {
#line 14643
          if (ue_grp == group1) {
            goto __Cont___3;
          }
#line 14646
          if ((groupArray + ue_grp)->extint == ei1) {
#line 14647
            break;
          }
          __Cont___3: /* CIL Label */ 
#line 14642
          ue_grp ++;
        }
#line 14650
        if ((int )(groupArray + ue_grp)->flag > 0) {
#line 14651
          g2 = 0;
#line 14651
          g1 = g2;
#line 14652
          (groupArray + ue_grp)->flag = (short)-1;
#line 14653
          edge2 = edge___0 + 1;
#line 14653
          while (edge2 <= numEdges) {
#line 14654
            if (g2 == 0) {
#line 14655
              if ((int )(edgeArray + edge2)->group1 == ue_grp) {
#line 14656
                g2 = (int )(edgeArray + edge2)->group2;
#line 14657
                if ((int )(groupArray + g2)->flag < 0) {
#line 14658
                  g2 = 0;
                }
                goto __Cont___4;
              }
            }
#line 14663
            if (g1 == 0) {
#line 14664
              if ((int )(edgeArray + edge2)->group2 == ue_grp) {
#line 14665
                g1 = (int )(edgeArray + edge2)->group1;
#line 14666
                if ((int )(groupArray + g1)->flag < 0) {
#line 14667
                  g1 = 0;
                }
              }
            }
            __Cont___4: /* CIL Label */ 
#line 14653
            edge2 ++;
          }
#line 14672
          if (g1 != 0) {
#line 14672
            if (g2 != 0) {
#line 14673
              addEdge(g1, g2);
#line 14674
              added_an_edge = 1;
            }
          }
        }
      }
#line 14678
      if ((int )(groupArray + group2)->unequiv == 1) {
#line 14679
        ei2 = (groupArray + group2)->extint;
#line 14680
        ue_grp = 1;
#line 14680
        while (ue_grp <= numGroups) {
#line 14681
          if (ue_grp == group2) {
            goto __Cont___5;
          }
#line 14684
          if ((groupArray + ue_grp)->extint == ei2) {
#line 14685
            break;
          }
          __Cont___5: /* CIL Label */ 
#line 14680
          ue_grp ++;
        }
#line 14688
        if ((int )(groupArray + ue_grp)->flag > 0) {
#line 14689
          g2 = 0;
#line 14689
          g1 = g2;
#line 14690
          (groupArray + ue_grp)->flag = (short)-1;
#line 14691
          edge2 = edge___0 + 1;
#line 14691
          while (edge2 <= numEdges) {
#line 14692
            if (g2 == 0) {
#line 14693
              if ((int )(edgeArray + edge2)->group1 == ue_grp) {
#line 14694
                g2 = (int )(edgeArray + edge2)->group2;
#line 14695
                if ((int )(groupArray + g2)->flag < 0) {
#line 14696
                  g2 = 0;
                }
                goto __Cont___6;
              }
            }
#line 14701
            if (g1 == 0) {
#line 14702
              if ((int )(edgeArray + edge2)->group2 == ue_grp) {
#line 14703
                g1 = (int )(edgeArray + edge2)->group1;
#line 14704
                if ((int )(groupArray + g1)->flag < 0) {
#line 14705
                  g1 = 0;
                }
              }
            }
            __Cont___6: /* CIL Label */ 
#line 14691
            edge2 ++;
          }
#line 14710
          if (g1 != 0) {
#line 14710
            if (g2 != 0) {
#line 14711
              addEdge(g1, g2);
#line 14712
              added_an_edge = 1;
            }
          }
        }
      }
#line 14716
      if (added_an_edge == 1) {
#line 14717
        edge1 = edge___0 + 1;
#line 14717
        while (edge1 <= numEdges) {
#line 14718
          a1 = (int )(edgeArray + edge1)->group1;
#line 14719
          a2 = (int )(edgeArray + edge1)->group2;
#line 14720
          if ((int )(groupArray + a1)->block != (int )(groupArray + a2)->block) {
            goto __Cont___7;
          }
#line 14723
          edge2 = edge1 + 1;
#line 14723
          while (edge2 <= numEdges) {
#line 14724
            b1 = (int )(edgeArray + edge2)->group1;
#line 14725
            b2 = (int )(edgeArray + edge2)->group2;
#line 14726
            if ((int )(groupArray + b1)->block != (int )(groupArray + b2)->block) {
              goto __Cont___8;
            }
#line 14729
            if ((int )(groupArray + a1)->unequiv == 1) {
#line 14729
              if ((int )(groupArray + b1)->unequiv == 1) {
#line 14729
                if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
#line 14729
                  if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
                    goto _L___3;
                  } else {
                    goto _L___6;
                  }
                } else {
                  goto _L___6;
                }
              } else {
                goto _L___6;
              }
            } else {
              _L___6: /* CIL Label */ 
#line 14729
              if ((int )(groupArray + a2)->unequiv == 1) {
#line 14729
                if ((int )(groupArray + b2)->unequiv == 1) {
#line 14729
                  if ((groupArray + a2)->extint == (groupArray + b2)->extint) {
#line 14729
                    if ((groupArray + a1)->extint == (groupArray + b1)->extint) {
                      _L___3: /* CIL Label */ 
#line 14741
                      ya = ((groupArray + a1)->aveY + (groupArray + a2)->aveY) / 2;
#line 14743
                      yb = ((groupArray + b1)->aveY + (groupArray + b2)->aveY) / 2;
#line 14745
                      if ((int )(groupArray + a1)->block == top_row) {
#line 14746
                        if (ya < yb) {
#line 14747
                          if ((int )(edgeArray + edge2)->cost <= (int )(edgeArray + edge1)->cost) {
#line 14749
                            (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost + 1);
                          }
                        } else {
#line 14753
                          if ((int )(edgeArray + edge2)->cost >= (int )(edgeArray + edge1)->cost) {
#line 14755
                            (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost - 1);
                          }
                        }
                      } else {
#line 14760
                        if (ya < yb) {
#line 14761
                          if ((int )(edgeArray + edge2)->cost >= (int )(edgeArray + edge1)->cost) {
#line 14763
                            (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost - 1);
                          }
                        } else {
#line 14767
                          if ((int )(edgeArray + edge2)->cost <= (int )(edgeArray + edge1)->cost) {
#line 14769
                            (edgeArray + edge2)->cost = (short )((int )(edgeArray + edge1)->cost + 1);
                          }
                        }
                      }
#line 14774
                      break;
                    }
                  }
                }
              }
            }
            __Cont___8: /* CIL Label */ 
#line 14723
            edge2 ++;
          }
          __Cont___7: /* CIL Label */ 
#line 14717
          edge1 ++;
        }
#line 14778
        qsorte((char *)((edgeArray + 1) + edge___0), numEdges - edge___0, (int )sizeof(edgeBox ));
      }
      __Cont___2: /* CIL Label */ 
#line 14605
      edge___0 ++;
    }
#line 14782
    group = 1;
#line 14782
    while (group <= numGroups) {
#line 14783
      if ((int )(groupArray + group)->flag < 0) {
        goto __Cont___9;
      }
#line 14786
      if ((int )(groupArray + group)->unequiv != 1) {
        goto __Cont___9;
      }
#line 14789
      ei = (groupArray + group)->extint;
#line 14790
      group2 = group + 1;
#line 14790
      while (group2 <= numGroups) {
#line 14791
        if ((groupArray + group2)->extint == ei) {
#line 14792
          if ((int )(groupArray + group2)->flag >= 0) {
#line 14793
            (groupArray + group2)->flag = (short)-1;
          }
#line 14795
          break;
        }
#line 14790
        group2 ++;
      }
      __Cont___9: /* CIL Label */ 
#line 14782
      group ++;
    }
#line 14799
    done = 0;
#line 14800
    while (done == 0) {
#line 14801
      done = 1;
#line 14802
      edge___0 = 1;
#line 14802
      while (edge___0 <= numEdges) {
#line 14803
        if ((int )(edgeArray + edge___0)->marked == 1) {
#line 14803
          if ((int )(edgeArray + edge___0)->poison == 0) {
#line 14804
            g1 = (int )(edgeArray + edge___0)->group1;
#line 14805
            g2 = (int )(edgeArray + edge___0)->group2;
#line 14806
            unequiv1 = (int )(groupArray + g1)->unequiv;
#line 14807
            if (unequiv1 == 0) {
#line 14808
              if ((int )(groupArray + g1)->numPins == 1) {
#line 14808
                if ((int )((groupArray + g1)->pinArray + 1)->top != 0) {
#line 14810
                  single_pin1 = 1;
#line 14811
                  unequiv1 = 1;
                }
              }
            }
#line 14814
            unequiv2 = (int )(groupArray + g2)->unequiv;
#line 14815
            if (unequiv2 == 0) {
#line 14816
              if ((int )(groupArray + g2)->numPins == 1) {
#line 14816
                if ((int )((groupArray + g2)->pinArray + 1)->top != 0) {
#line 14818
                  single_pin2 = 1;
#line 14819
                  unequiv2 = 1;
                }
              }
            }
#line 14822
            if ((int )(groupArray + g1)->poison == 1) {
              goto _L___8;
            } else {
#line 14822
              if ((int )(groupArray + g2)->poison == 1) {
                _L___8: /* CIL Label */ 
#line 14824
                done = 0;
#line 14825
                (edgeArray + edge___0)->poison = (short)1;
#line 14826
                if (unequiv1 == 1) {
#line 14827
                  (groupArray + g1)->poison = (short)1;
                }
#line 14829
                if (unequiv2 == 1) {
#line 14830
                  (groupArray + g2)->poison = (short)1;
                }
              } else {
#line 14832
                if ((int )(groupArray + g1)->block != (int )(groupArray + g2)->block) {
#line 14833
                  done = 0;
#line 14834
                  (edgeArray + edge___0)->poison = (short)1;
#line 14835
                  if (unequiv1 == 1) {
#line 14836
                    (groupArray + g1)->poison = (short)1;
                  }
#line 14838
                  if (unequiv2 == 1) {
#line 14839
                    (groupArray + g2)->poison = (short)1;
                  }
                } else {
#line 14841
                  if (single_pin1 == 1) {
                    goto _L___7;
                  } else {
#line 14841
                    if (single_pin2 == 1) {
                      _L___7: /* CIL Label */ 
#line 14842
                      done = 0;
#line 14843
                      (edgeArray + edge___0)->poison = (short)1;
#line 14844
                      if (unequiv1 == 1) {
#line 14845
                        (groupArray + g1)->poison = (short)1;
                      }
#line 14847
                      if (unequiv2 == 1) {
#line 14848
                        (groupArray + g2)->poison = (short)1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 14802
        edge___0 ++;
      }
    }
#line 14854
    edge___0 = 1;
#line 14854
    while (edge___0 <= numEdges) {
#line 14855
      if ((int )(edgeArray + edge___0)->marked == 1) {
#line 14855
        if ((int )(edgeArray + edge___0)->poison == 0) {
#line 14857
          g1 = (int )(edgeArray + edge___0)->group1;
#line 14858
          g2 = (int )(edgeArray + edge___0)->group2;
#line 14859
          if ((int )(groupArray + g1)->unequiv == 0) {
#line 14859
            if ((int )(groupArray + g2)->unequiv == 0) {
#line 14861
              (edgeArray + edge___0)->poison = (short)1;
            }
          }
#line 14863
          if ((int )(groupArray + g1)->unequiv == 0) {
#line 14864
            (groupArray + g1)->poison = (short)1;
          }
#line 14866
          if ((int )(groupArray + g2)->unequiv == 0) {
#line 14867
            (groupArray + g2)->poison = (short)1;
          }
        }
      }
#line 14854
      edge___0 ++;
    }
#line 14871
    edge___0 = 1;
#line 14871
    while (edge___0 <= numEdges) {
#line 14872
      if ((int )(edgeArray + edge___0)->marked == 1) {
#line 14872
        if ((int )(edgeArray + edge___0)->poison == 0) {
#line 14874
          g1 = (int )(edgeArray + edge___0)->group1;
#line 14875
          g2 = (int )(edgeArray + edge___0)->group2;
#line 14876
          if ((int )(groupArray + g1)->edge1 == 0) {
#line 14877
            (groupArray + g1)->edge1 = (short )edge___0;
          } else {
#line 14879
            (groupArray + g1)->edge2 = (short )edge___0;
          }
#line 14881
          if ((int )(groupArray + g2)->edge1 == 0) {
#line 14882
            (groupArray + g2)->edge1 = (short )edge___0;
          } else {
#line 14884
            (groupArray + g2)->edge2 = (short )edge___0;
          }
#line 14886
          if ((int )(groupArray + g1)->poison == 0) {
#line 14887
            ei = (groupArray + g1)->extint;
#line 14888
            group = 1;
#line 14888
            while (1) {
#line 14889
              if (group == g1) {
                goto __Cont___10;
              } else {
#line 14889
                if ((groupArray + group)->extint != ei) {
                  goto __Cont___10;
                }
              }
#line 14892
              break;
              __Cont___10: /* CIL Label */ 
#line 14888
              group ++;
            }
#line 14894
            (groupArray + g1)->numPins = (short)2;
#line 14895
            ((groupArray + g1)->pinArray + 2)->xloc = ((groupArray + group)->pinArray + 1)->xloc;
#line 14896
            ((groupArray + g1)->pinArray + 2)->yloc = ((groupArray + group)->pinArray + 1)->yloc;
#line 14897
            ((groupArray + g1)->pinArray + 2)->top = ((groupArray + group)->pinArray + 1)->top;
#line 14898
            ((groupArray + g1)->pinArray + 2)->pin = ((groupArray + group)->pinArray + 1)->pin;
          }
#line 14900
          if ((int )(groupArray + g2)->poison == 0) {
#line 14901
            ei = (groupArray + g2)->extint;
#line 14902
            group = 1;
#line 14902
            while (1) {
#line 14903
              if (group == g2) {
                goto __Cont___11;
              } else {
#line 14903
                if ((groupArray + group)->extint != ei) {
                  goto __Cont___11;
                }
              }
#line 14906
              break;
              __Cont___11: /* CIL Label */ 
#line 14902
              group ++;
            }
#line 14908
            (groupArray + g2)->numPins = (short)2;
#line 14909
            ((groupArray + g2)->pinArray + 2)->xloc = ((groupArray + group)->pinArray + 1)->xloc;
#line 14910
            ((groupArray + g2)->pinArray + 2)->yloc = ((groupArray + group)->pinArray + 1)->yloc;
#line 14911
            ((groupArray + g2)->pinArray + 2)->top = ((groupArray + group)->pinArray + 1)->top;
#line 14912
            ((groupArray + g2)->pinArray + 2)->pin = ((groupArray + group)->pinArray + 1)->pin;
          }
        }
      }
#line 14871
      edge___0 ++;
    }
#line 14916
    edge___0 = 1;
#line 14916
    while (edge___0 <= numEdges) {
#line 14917
      if ((int )(edgeArray + edge___0)->marked == 1) {
#line 14917
        if ((int )(edgeArray + edge___0)->poison == 0) {
#line 14919
          g1 = (int )(edgeArray + edge___0)->group1;
#line 14920
          g2 = (int )(edgeArray + edge___0)->group2;
#line 14921
          if ((int )(groupArray + g1)->edge2 == 0) {
#line 14921
            if ((int )(groupArray + g2)->edge2 == 0) {
#line 14922
              (edgeArray + edge___0)->poison = (short)1;
            }
          }
        }
      }
#line 14916
      edge___0 ++;
    }
#line 14926
    uclosepns(net);
#line 14927
    i = 1;
#line 14927
    while (i <= numGroups) {
#line 14928
      (groupArray + i)->numPins = (short)0;
#line 14929
      (groupArray + i)->flag = (short)0;
#line 14930
      (groupArray + i)->poison = (short)0;
#line 14931
      (groupArray + i)->unequiv = (short)0;
#line 14932
      (groupArray + i)->extint = 0;
#line 14933
      (groupArray + i)->edge1 = (short)0;
#line 14934
      (groupArray + i)->edge2 = (short)0;
#line 14935
      (groupArray + i)->check = (short)0;
#line 14927
      i ++;
    }
#line 14937
    i = 1;
#line 14937
    while (i <= numEdges) {
#line 14938
      (edgeArray + i)->marked = (short)0;
#line 14939
      (edgeArray + i)->done = (short)0;
#line 14940
      (edgeArray + i)->poison = (short)0;
#line 14937
      i ++;
    }
    __Cont: /* CIL Label */ 
#line 14437
    chgloop ++;
  }
#line 14943
  uglobrout();
#line 14944
  return 0;
}
}
#line 14962
int unetseg(void) ;
#line 14952 "D:/a/test/300.c"
int uglobrout(void) 
{ int attperseg ;
  int attlimit___0 ;
  int attempts___0 ;
  int swSeg ;
  int stoppoint ;
  int breakpoint ;
  int found ;
  int channel ;
  int x ;
  int x1 ;
  int x2 ;
  SEGBOXPTR segptr ;
  DENSITYPTR denptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 14961
  attperseg = 5;
#line 14962
  unetseg();
#line 14963
  attlimit___0 = attperseg * numSwSegs;
#line 14964
  attempts___0 = 0;
#line 14965
  breakpoint = 0;
#line 14966
  stoppoint = (int )(1.5 * (double )numSwSegs);
#line 14967
  while (attempts___0 < attlimit___0) {
#line 14968
    while (1) {
#line 14969
      while (1) {
#line 14970
        tmp = Yacm_random();
#line 14970
        swSeg = (int )((double )numSegs * ((double )tmp / (double )2147483647)) + 1;
#line 14969
        if (! (swSeg == numSegs + 1)) {
#line 14969
          break;
        }
      }
#line 14973
      if ((int )(aNetSeg + swSeg)->nflag == 1) {
#line 14974
        if ((int )(aNetSeg + swSeg)->nswYorN == 1) {
#line 14974
          if ((int )(aNetSeg + swSeg)->nkey == 0) {
#line 14976
            break;
          }
        }
      } else {
#line 14979
        if ((int )(aNetSeg + swSeg)->swYorN == 1) {
#line 14979
          if ((int )(aNetSeg + swSeg)->key == 0) {
#line 14981
            break;
          }
        }
      }
    }
#line 14985
    if ((int )(aNetSeg + swSeg)->nflag == 0) {
#line 14986
      if ((int )(aNetSeg + swSeg)->current == 0) {
#line 14987
        segptr = (aNetSeg + swSeg)->top;
      } else {
#line 14989
        segptr = (aNetSeg + swSeg)->bot;
      }
    } else {
#line 14992
      if ((int )(aNetSeg + swSeg)->ncurrent == 0) {
#line 14993
        segptr = (aNetSeg + swSeg)->ntop;
      } else {
#line 14995
        segptr = (aNetSeg + swSeg)->nbot;
      }
    }
#line 14998
    channel = (int )segptr->channel;
#line 14999
    x1 = ((segptr->pin1ptr)->netptr)->xpos;
#line 15000
    x2 = ((segptr->pin2ptr)->netptr)->xpos;
#line 15001
    if (channel > gtopChan) {
#line 15003
      attempts___0 ++;
#line 15004
      continue;
    } else {
#line 15001
      if (channel < gbotChan) {
#line 15003
        attempts___0 ++;
#line 15004
        continue;
      } else {
#line 15001
        if (x2 < Left_bound) {
#line 15003
          attempts___0 ++;
#line 15004
          continue;
        } else {
#line 15001
          if (x1 > Rite_bound) {
#line 15003
            attempts___0 ++;
#line 15004
            continue;
          }
        }
      }
    }
#line 15006
    found = 0;
#line 15007
    denptr = (*(*(DboxHead + channel) + *(nmaxTrack + channel)))->nnext;
#line 15007
    while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 15009
      x = ((denptr->grdptr)->netptr)->xpos;
#line 15010
      if (x1 <= x) {
#line 15010
        if (x2 >= x) {
#line 15011
          found = 1;
#line 15012
          break;
        }
      }
#line 15007
      denptr = denptr->nnext;
    }
#line 15015
    if (! found) {
#line 15016
      breakpoint ++;
#line 15016
      if (breakpoint > stoppoint) {
#line 15017
        break;
      }
#line 15019
      attempts___0 ++;
#line 15020
      continue;
    }
#line 15022
    tmp___0 = purcost(swSeg);
#line 15022
    if (tmp___0) {
#line 15023
      attempts___0 ++;
#line 15024
      breakpoint = 0;
    } else {
#line 15026
      breakpoint ++;
#line 15026
      if (breakpoint > stoppoint) {
#line 15027
        break;
      }
#line 15029
      attempts___0 ++;
    }
  }
#line 15032
  return 0;
}
}
#line 15041 "D:/a/test/300.c"
int ugpair(void) 
{ CBOXPTR acellptr___0 ;
  CBOXPTR bcellptr___0 ;
  BBOXPTR ablckptr ;
  DENSITYPTR denptr ;
  int a___0 ;
  int b___0 ;
  int ablock___0 ;
  int lowValue ;
  int flips ;
  int attempts___0 ;
  int segment ;
  int axcenter___0 ;
  int bnxcenter___0 ;
  int anxcenter___0 ;
  int aleft___0 ;
  int aright___0 ;
  int aorient ;
  int startx1 ;
  int endx1 ;
  int cellleft ;
  int cellrite ;
  int x ;
  int leftEdge ;
  int riteEdge ;
  int aptr ;
  int chan1 ;
  int chan2 ;
  int found ;
  int breakpoint ;
  int stoppoint ;
  double r ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 15057
  lowValue = tracks;
#line 15058
  tmp = safe_malloc(251U * sizeof(CHANGRDPTR ));
#line 15058
  Shuffle = (CHANGRDPTR *)tmp;
#line 15059
  segment = 1;
#line 15059
  while (segment <= numSegs) {
#line 15060
    *(fixnetseg + segment) = (int )(aNetSeg + segment)->current;
#line 15059
    segment ++;
  }
#line 15062
  flips = 0;
#line 15063
  attempts___0 = 0;
#line 15064
  breakpoint = 0;
#line 15065
  stoppoint = (int )((double )moveable_cells * stopdeg);
#line 15066
  while (breakpoint < stoppoint) {
#line 15067
    while (1) {
#line 15068
      tmp___0 = Yacm_random();
#line 15068
      ablock___0 = (int )((double )numblock * ((double )tmp___0 / (double )2147483647)) + 1;
#line 15067
      if (! (ablock___0 == numblock + 1)) {
#line 15067
        break;
      }
    }
#line 15071
    if (*(*(pairArray + ablock___0) + 0) <= 1) {
#line 15072
      continue;
    }
#line 15074
    chan1 = *(blkToRow + ablock___0) + 1;
#line 15075
    chan2 = *(blkToRow + ablock___0);
#line 15076
    found = 0;
#line 15076
    while (found == 0) {
#line 15077
      while (1) {
#line 15078
        tmp___1 = Yacm_random();
#line 15078
        aptr = (int )((double )*(*(pairArray + ablock___0) + 0) * ((double )tmp___1 / (double )2147483647)) + 1;
#line 15077
        if (! (aptr == *(*(pairArray + ablock___0) + 0) + 1)) {
#line 15077
          break;
        }
      }
#line 15082
      a___0 = *(*(pairArray + ablock___0) + aptr);
#line 15083
      acellptr___0 = *(carray + a___0);
#line 15084
      aorient = (int )acellptr___0->corient;
#line 15085
      axcenter___0 = acellptr___0->cxcenter;
#line 15086
      aleft___0 = (int )(acellptr___0->tileptr)->left;
#line 15087
      aright___0 = (int )(acellptr___0->tileptr)->right;
#line 15088
      startx1 = axcenter___0 + aleft___0;
#line 15089
      endx1 = axcenter___0 + aright___0;
#line 15090
      denptr = (*(*(DboxHead + chan1) + *(maxTrack + chan1)))->next;
#line 15090
      while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 15092
        x = ((denptr->grdptr)->netptr)->newx;
#line 15093
        if (startx1 <= x) {
#line 15093
          if (endx1 >= x) {
#line 15094
            found = 1;
#line 15095
            break;
          }
        }
#line 15090
        denptr = denptr->next;
      }
#line 15098
      if (found == 0) {
#line 15099
        denptr = (*(*(DboxHead + chan2) + *(maxTrack + chan2)))->next;
#line 15099
        while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 15101
          x = ((denptr->grdptr)->netptr)->newx;
#line 15102
          if (startx1 <= x) {
#line 15102
            if (endx1 >= x) {
#line 15103
              found = 1;
#line 15104
              break;
            }
          }
#line 15099
          denptr = denptr->next;
        }
      }
    }
#line 15109
    ablckptr = *(barray + ablock___0);
#line 15110
    if (aptr > 1) {
#line 15111
      cellleft = *(*(pairArray + ablock___0) + (aptr - 1));
    } else {
#line 15113
      cellleft = 0;
    }
#line 15115
    if (aptr < *(*(pairArray + ablock___0) + 0)) {
#line 15116
      cellrite = *(*(pairArray + ablock___0) + (aptr + 1));
    } else {
#line 15118
      cellrite = 0;
    }
#line 15120
    if (cellleft != 0) {
#line 15120
      if (cellrite != 0) {
#line 15120
        if ((int )(*(carray + cellleft))->cclass != -1) {
#line 15120
          if ((int )acellptr___0->cclass != -1) {
#line 15120
            if ((int )(*(carray + cellrite))->cclass != -1) {
#line 15124
              tmp___2 = Yacm_random();
#line 15124
              r = (double )tmp___2 / (double )2147483647;
#line 15125
              if (r >= 0.5) {
#line 15127
                b___0 = cellleft;
#line 15128
                bcellptr___0 = *(carray + b___0);
#line 15129
                leftEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->left;
#line 15130
                anxcenter___0 = leftEdge - aleft___0;
#line 15131
                bnxcenter___0 = endx1 - (int )(bcellptr___0->tileptr)->right;
#line 15132
                tmp___4 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 15132
                if (tmp___4) {
#line 15133
                  flips ++;
#line 15134
                  attempts___0 ++;
#line 15135
                  if (attempts___0 % 50 == 0) {
#line 15136
                    fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 15138
                    fflush(fpo);
                  }
#line 15140
                  if (attempts___0 % 150 == 0) {
#line 15141
                    savewolf(3);
                  }
#line 15143
                  if (tracks < lowValue) {
#line 15144
                    lowValue = tracks;
#line 15145
                    fprintf(fpo, "Routing tracks reduced ");
#line 15146
                    fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0);
#line 15148
                    fflush(fpo);
                  } else {
#line 15150
                    breakpoint ++;
                  }
#line 15152
                  if (! uneven_cell_height) {
#line 15153
                    *(*(pairArray + ablock___0) + aptr) = b___0;
#line 15154
                    *(*(pairArray + ablock___0) + (aptr - 1)) = a___0;
                  }
                } else {
#line 15157
                  breakpoint ++;
#line 15158
                  attempts___0 ++;
#line 15159
                  if (attempts___0 % 50 == 0) {
#line 15160
                    fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 15162
                    fflush(fpo);
                  }
#line 15164
                  if (attempts___0 % 150 == 0) {
#line 15165
                    savewolf(3);
                  }
#line 15167
                  b___0 = cellrite;
#line 15168
                  bcellptr___0 = *(carray + b___0);
#line 15169
                  riteEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->right;
#line 15171
                  anxcenter___0 = riteEdge - aright___0;
#line 15172
                  bnxcenter___0 = startx1 - (int )(bcellptr___0->tileptr)->left;
#line 15173
                  tmp___3 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 15173
                  if (tmp___3) {
#line 15174
                    flips ++;
#line 15175
                    if (tracks < lowValue) {
#line 15176
                      lowValue = tracks;
#line 15177
                      fprintf(fpo, "Routing tracks reduced ");
#line 15178
                      fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0 + 1);
#line 15180
                      fflush(fpo);
                    } else {
#line 15182
                      breakpoint ++;
                    }
#line 15184
                    if (! uneven_cell_height) {
#line 15185
                      *(*(pairArray + ablock___0) + aptr) = b___0;
#line 15186
                      *(*(pairArray + ablock___0) + (aptr + 1)) = a___0;
                    }
                  } else {
#line 15189
                    breakpoint ++;
                  }
#line 15191
                  attempts___0 ++;
#line 15192
                  if (attempts___0 % 50 == 0) {
#line 15193
                    fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 15195
                    fflush(fpo);
                  }
#line 15197
                  if (attempts___0 % 150 == 0) {
#line 15198
                    savewolf(3);
                  }
                }
              } else {
#line 15202
                b___0 = cellrite;
#line 15203
                bcellptr___0 = *(carray + b___0);
#line 15204
                riteEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->right;
#line 15205
                anxcenter___0 = riteEdge - aright___0;
#line 15206
                bnxcenter___0 = startx1 - (int )(bcellptr___0->tileptr)->left;
#line 15207
                tmp___6 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 15207
                if (tmp___6) {
#line 15208
                  flips ++;
#line 15209
                  attempts___0 ++;
#line 15210
                  if (attempts___0 % 50 == 0) {
#line 15211
                    fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 15213
                    fflush(fpo);
                  }
#line 15215
                  if (attempts___0 % 150 == 0) {
#line 15216
                    savewolf(3);
                  }
#line 15218
                  if (tracks < lowValue) {
#line 15219
                    lowValue = tracks;
#line 15220
                    fprintf(fpo, "Routing tracks reduced ");
#line 15221
                    fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0);
#line 15223
                    fflush(fpo);
                  } else {
#line 15225
                    breakpoint ++;
                  }
#line 15227
                  if (! uneven_cell_height) {
#line 15228
                    *(*(pairArray + ablock___0) + aptr) = b___0;
#line 15229
                    *(*(pairArray + ablock___0) + (aptr + 1)) = a___0;
                  }
                } else {
#line 15232
                  attempts___0 ++;
#line 15233
                  if (attempts___0 % 50 == 0) {
#line 15234
                    fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 15236
                    fflush(fpo);
                  }
#line 15238
                  if (attempts___0 % 150 == 0) {
#line 15239
                    savewolf(3);
                  }
#line 15241
                  breakpoint ++;
#line 15242
                  b___0 = cellleft;
#line 15243
                  bcellptr___0 = *(carray + b___0);
#line 15244
                  leftEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->left;
#line 15245
                  anxcenter___0 = leftEdge - aleft___0;
#line 15246
                  bnxcenter___0 = endx1 - (int )(bcellptr___0->tileptr)->right;
#line 15247
                  tmp___5 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 15247
                  if (tmp___5) {
#line 15248
                    flips ++;
#line 15249
                    if (tracks < lowValue) {
#line 15250
                      lowValue = tracks;
#line 15251
                      fprintf(fpo, "Routing tracks reduced ");
#line 15252
                      fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0 + 1);
#line 15254
                      fflush(fpo);
                    } else {
#line 15256
                      breakpoint ++;
                    }
#line 15258
                    if (! uneven_cell_height) {
#line 15259
                      *(*(pairArray + ablock___0) + aptr) = b___0;
#line 15260
                      *(*(pairArray + ablock___0) + (aptr - 1)) = a___0;
                    }
                  } else {
#line 15263
                    breakpoint ++;
                  }
#line 15265
                  attempts___0 ++;
#line 15266
                  if (attempts___0 % 50 == 0) {
#line 15267
                    fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 15269
                    fflush(fpo);
                  }
#line 15271
                  if (attempts___0 % 150 == 0) {
#line 15272
                    savewolf(3);
                  }
                }
              }
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          goto _L___4;
        }
      } else {
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 15277
      if (cellleft != 0) {
#line 15277
        if ((int )(*(carray + cellleft))->cclass != -1) {
#line 15277
          if ((int )acellptr___0->cclass != -1) {
#line 15280
            b___0 = cellleft;
#line 15281
            bcellptr___0 = *(carray + b___0);
#line 15282
            leftEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->left;
#line 15283
            anxcenter___0 = leftEdge - aleft___0;
#line 15284
            bnxcenter___0 = endx1 - (int )(bcellptr___0->tileptr)->right;
#line 15285
            tmp___7 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 15285
            if (tmp___7) {
#line 15286
              flips ++;
#line 15287
              if (tracks < lowValue) {
#line 15288
                lowValue = tracks;
#line 15289
                fprintf(fpo, "Routing tracks reduced ");
#line 15290
                fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0 + 1);
#line 15292
                fflush(fpo);
              } else {
#line 15294
                breakpoint ++;
              }
#line 15296
              if (! uneven_cell_height) {
#line 15297
                *(*(pairArray + ablock___0) + aptr) = b___0;
#line 15298
                *(*(pairArray + ablock___0) + (aptr - 1)) = a___0;
              }
            } else {
#line 15301
              breakpoint ++;
            }
#line 15303
            attempts___0 ++;
#line 15304
            if (attempts___0 % 50 == 0) {
#line 15305
              fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 15307
              fflush(fpo);
            }
#line 15309
            if (attempts___0 % 150 == 0) {
#line 15310
              savewolf(3);
            }
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 15312
        if (cellrite != 0) {
#line 15312
          if ((int )(*(carray + cellrite))->cclass != -1) {
#line 15312
            if ((int )acellptr___0->cclass != -1) {
#line 15315
              b___0 = cellrite;
#line 15316
              bcellptr___0 = *(carray + b___0);
#line 15317
              riteEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->right;
#line 15318
              anxcenter___0 = riteEdge - aright___0;
#line 15319
              bnxcenter___0 = startx1 - (int )(bcellptr___0->tileptr)->left;
#line 15320
              tmp___8 = ucgxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 15320
              if (tmp___8) {
#line 15321
                flips ++;
#line 15322
                if (tracks < lowValue) {
#line 15323
                  lowValue = tracks;
#line 15324
                  fprintf(fpo, "Routing tracks reduced ");
#line 15325
                  fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0 + 1);
#line 15327
                  fflush(fpo);
                } else {
#line 15329
                  breakpoint ++;
                }
#line 15331
                if (! uneven_cell_height) {
#line 15332
                  *(*(pairArray + ablock___0) + aptr) = b___0;
#line 15333
                  *(*(pairArray + ablock___0) + (aptr + 1)) = a___0;
                }
              } else {
#line 15336
                breakpoint ++;
              }
#line 15338
              attempts___0 ++;
#line 15339
              if (attempts___0 % 50 == 0) {
#line 15340
                fprintf(fpo, "current iteration:%d\n", attempts___0);
#line 15342
                fflush(fpo);
              }
#line 15344
              if (attempts___0 % 150 == 0) {
#line 15345
                savewolf(3);
              }
            }
          }
        }
      }
    }
#line 15349
    switch ((int )ablckptr->borient) {
    case 1: 
#line 15351
    if ((int )acellptr___0->orflag != 0) {
#line 15352
      if (aorient == 0) {
#line 15352
        tmp___9 = 2;
      } else {
#line 15352
        tmp___9 = 0;
      }
#line 15352
      tmp___10 = ucg0(a___0, tmp___9);
#line 15352
      if (tmp___10) {
#line 15353
        if (tracks < lowValue) {
#line 15354
          lowValue = tracks;
#line 15355
          fprintf(fpo, "Routing tracks reduced ");
#line 15356
          fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0);
#line 15358
          fprintf(fpo, "  ----by an orientation change\n");
#line 15359
          fflush(fpo);
        }
      }
    }
#line 15363
    break;
    case 2: 
#line 15365
    if ((int )acellptr___0->orflag != 0) {
#line 15366
      if (aorient == 1) {
#line 15366
        tmp___11 = 3;
      } else {
#line 15366
        tmp___11 = 1;
      }
#line 15366
      tmp___12 = ucg0(a___0, tmp___11);
#line 15366
      if (tmp___12) {
#line 15367
        if (tracks < lowValue) {
#line 15368
          lowValue = tracks;
#line 15369
          fprintf(fpo, "Routing tracks reduced ");
#line 15370
          fprintf(fpo, "to: %d  on iteration:%d\n", tracks, attempts___0);
#line 15372
          fprintf(fpo, "  ----by an orientation change\n");
#line 15373
          fflush(fpo);
        }
      }
    }
#line 15377
    break;
    }
  }
#line 15380
  if (attempts___0 != 0) {
#line 15381
    fprintf(fpo, "    no. of accepted gflips: %d --->%d%s\n", flips, (int )((100.0 * (double )flips) / (double )attempts___0),
            "%");
#line 15384
    fflush(fpo);
  }
#line 15386
  safe_free((char *)Shuffle);
#line 15387
  return 0;
}
}
#line 15390 "D:/a/test/300.c"
int rowcon(void) 
{ int C ;
  int RM ;
  int p_first ;
  int totalCells ;
  int cellsPerRow ;
  int temp_R ;
  int over ;
  int under ;
  double states ;
  double value ;
  double expect ;
  double variance ;
  double expectedExtraRowLength ;
  double rowControl ;
  double x ;
  double minDev ;
  double tmp ;

  {
#line 15396
  totalCells = numcells;
#line 15397
  RM = numRows;
#line 15398
  cellsPerRow = totalCells / RM;
#line 15399
  temp_R = RM - RM / 3;
#line 15400
  rowControl = 0.0;
#line 15401
  while (1) {
#line 15402
    rowControl += 0.001;
#line 15403
    C = (int )((rowControl * (double )totalCells) / 2.0);
#line 15404
    if (2.0 * (double )(C + 1) - rowControl * (double )totalCells <= rowControl * (double )totalCells - 2.0 * (double )C) {
#line 15406
      C ++;
    }
#line 15401
    if (! (2 * C < temp_R)) {
#line 15401
      break;
    }
  }
#line 15409
  p_first = C / RM;
#line 15410
  if (p_first * RM < C) {
#line 15411
    p_first ++;
  }
#line 15413
  RM -= RM / 3;
#line 15414
  under = 0;
#line 15415
  over = 0;
#line 15416
  while (1) {
#line 15417
    value = expected_value(C, 0, p_first, RM);
#line 15418
    states = combination((C + RM) - 1, C);
#line 15419
    expect = value / states;
#line 15420
    expectedExtraRowLength = (100.0 * expect) / (double )cellsPerRow;
#line 15421
    value = expected_svalue(C, 0, p_first, RM);
#line 15422
    variance = value / states - expect * expect;
#line 15423
    tmp = sqrt(variance);
#line 15423
    x = (100.0 * tmp) / (double )cellsPerRow;
#line 15424
    minDev = 100.0 / (double )cellsPerRow;
#line 15425
    value = (x + expectedExtraRowLength) - minDev;
#line 15426
    if (value > 2.7) {
#line 15426
      if (value < 3.3) {
#line 15427
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 15428
      if (value <= 2.7) {
#line 15429
        rowControl += 0.001;
#line 15430
        if (! over) {
#line 15431
          under = 1;
        } else {
#line 15433
          break;
        }
      } else {
#line 15435
        if (value >= 3.3) {
#line 15436
          if (! under) {
#line 15437
            rowControl -= 0.001;
#line 15438
            over = 1;
          } else {
#line 15440
            break;
          }
        }
      }
    }
#line 15443
    C = (int )((rowControl * (double )totalCells) / 2.0);
#line 15444
    if (2.0 * (double )(C + 1) - rowControl * (double )totalCells <= rowControl * (double )totalCells - 2.0 * (double )C) {
#line 15446
      C ++;
    }
#line 15448
    p_first = C / RM;
#line 15449
    if (p_first * RM < C) {
#line 15450
      p_first ++;
    }
  }
#line 15453
  initialRowControl = 5.5 * rowControl;
#line 15454
  finalRowControl = rowControl;
#line 15455
  return 0;
}
}
#line 15457 "D:/a/test/300.c"
double partition(int C_initial , int k_initial , int p_initial , int R_initial ) 
{ int RM ;
  int C ;
  int k___0 ;
  int p ;
  int k_limit ;
  int p_limit ;
  double states ;
  double equivs ;
  double tmp ;
  double tmp___0 ;

  {
#line 15462
  states = 0.0;
#line 15463
  k_limit = R_initial - k_initial;
#line 15463
  RM = k_limit;
#line 15464
  C = C_initial - p_initial * k_initial;
#line 15465
  k___0 = 1;
#line 15465
  while (k___0 <= k_limit) {
#line 15466
    equivs = combination(RM, k___0);
#line 15467
    p_limit = C / k___0;
#line 15468
    p = p_initial;
#line 15468
    while (p <= p_limit) {
#line 15469
      if (C - (p - 1) * RM > k___0) {
        goto __Cont;
      }
#line 15472
      tmp = compute_and_combination(C, k___0, p, RM);
#line 15472
      tmp___0 = partition(C, k___0, p, RM);
#line 15472
      states += equivs * (tmp - tmp___0);
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 15468
      p ++;
    }
#line 15465
    k___0 ++;
  }
#line 15477
  return (states);
}
}
#line 15479 "D:/a/test/300.c"
double expected_value(int C_initial , int k_initial , int p_initial , int R_initial ) 
{ int RM ;
  int C ;
  int k___0 ;
  int p ;
  int k_limit ;
  int p_limit ;
  double value ;
  double equivs ;
  double tmp ;
  double tmp___0 ;

  {
#line 15484
  value = 0.0;
#line 15485
  k_limit = R_initial - k_initial;
#line 15485
  RM = k_limit;
#line 15486
  C = C_initial - p_initial * k_initial;
#line 15487
  k___0 = 1;
#line 15487
  while (k___0 <= k_limit) {
#line 15488
    equivs = combination(RM, k___0);
#line 15489
    p_limit = C / k___0;
#line 15490
    p = p_initial;
#line 15490
    while (p <= p_limit) {
#line 15491
      if (C - (p - 1) * RM > k___0) {
        goto __Cont;
      }
#line 15494
      tmp = compute_and_combination(C, k___0, p, RM);
#line 15494
      tmp___0 = partition(C, k___0, p, RM);
#line 15494
      value += ((double )p * equivs) * (tmp - tmp___0);
      __Cont: /* CIL Label */ 
#line 15490
      p ++;
    }
#line 15487
    k___0 ++;
  }
#line 15499
  return (value);
}
}
#line 15501 "D:/a/test/300.c"
double expected_svalue(int C_initial , int k_initial , int p_initial , int R_initial ) 
{ int RM ;
  int C ;
  int k___0 ;
  int p ;
  int k_limit ;
  int p_limit ;
  double value ;
  double equivs ;
  double tmp ;
  double tmp___0 ;

  {
#line 15506
  value = 0.0;
#line 15507
  k_limit = R_initial - k_initial;
#line 15507
  RM = k_limit;
#line 15508
  C = C_initial - p_initial * k_initial;
#line 15509
  k___0 = 1;
#line 15509
  while (k___0 <= k_limit) {
#line 15510
    equivs = combination(RM, k___0);
#line 15511
    p_limit = C / k___0;
#line 15512
    p = p_initial;
#line 15512
    while (p <= p_limit) {
#line 15513
      if (C - (p - 1) * RM > k___0) {
        goto __Cont;
      }
#line 15516
      tmp = compute_and_combination(C, k___0, p, RM);
#line 15516
      tmp___0 = partition(C, k___0, p, RM);
#line 15516
      value += ((double )(p * p) * equivs) * (tmp - tmp___0);
      __Cont: /* CIL Label */ 
#line 15512
      p ++;
    }
#line 15509
    k___0 ++;
  }
#line 15521
  return (value);
}
}
#line 15523 "D:/a/test/300.c"
double compute_and_combination(int C , int k___0 , int p , int RM ) 
{ int numerator ;
  int denom1 ;
  int denom2 ;
  int temp ;
  double states ;

  {
#line 15528
  states = 1.0;
#line 15529
  numerator = (((C - k___0 * p) + RM) - k___0) - 1;
#line 15530
  denom1 = C - k___0 * p;
#line 15531
  denom2 = (RM - k___0) - 1;
#line 15532
  if (denom1 > denom2) {
#line 15533
    temp = denom1;
#line 15534
    denom1 = denom2;
#line 15535
    denom2 = temp;
  }
#line 15537
  while (numerator > denom2) {
#line 15538
    states *= (double )numerator;
#line 15539
    states /= (double )denom1;
#line 15537
    numerator --;
#line 15537
    denom1 --;
  }
#line 15541
  return (states);
}
}
#line 15543 "D:/a/test/300.c"
double combination(int numerator , int denominator ) 
{ double states ;
  int temp ;
  int denom1 ;
  int denom2 ;

  {
#line 15548
  states = 1.0;
#line 15549
  denom1 = denominator;
#line 15550
  denom2 = numerator - denominator;
#line 15551
  if (denom1 > denom2) {
#line 15552
    temp = denom1;
#line 15553
    denom1 = denom2;
#line 15554
    denom2 = temp;
  }
#line 15556
  while (numerator > denom2) {
#line 15557
    states *= (double )numerator;
#line 15558
    states /= (double )denom1;
#line 15556
    numerator --;
#line 15556
    denom1 --;
  }
#line 15560
  return (states);
}
}
#line 15568 "D:/a/test/300.c"
int uloop2(void) 
{ CBOXPTR acellptr___0 ;
  CBOXPTR bcellptr___0 ;
  BBOXPTR ablckptr ;
  BBOXPTR bblckptr ;
  int botblk ;
  int topblk ;
  int flips ;
  int axcenter___0 ;
  int bxcenter___0 ;
  int bycenter___0 ;
  int aorient ;
  int borient___0 ;
  int bleft___0 ;
  int bright___0 ;
  int blk___0 ;
  int pairflips ;
  int i ;
  int r ;
  int l ;
  int t ;
  int abin ;
  int bbin ;
  int firstTry ;
  int fds ;
  double temp ;
  double fp_ratio ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 15582
  attempts = 0;
#line 15583
  flips = 0;
#line 15584
  pairflips = 0;
#line 15585
  earlyRej = 0;
#line 15586
  P_limit = -1;
#line 15587
  windx = minxspan;
#line 15588
  attmax = (2 * attprcel) * numcells;
#line 15589
  binpenCon = 0.0;
#line 15590
  fds = 0;
#line 15591
  if (estimate_feeds) {
#line 15592
    fds = controlf();
  }
#line 15594
  while (attempts < attmax) {
#line 15595
    if (1 < numcells) {
#line 15595
      tmp = Yacm_random();
#line 15595
      a = tmp % ((numcells - 1) + 1) + 1;
    } else {
#line 15595
      a = 1;
    }
#line 15596
    acellptr___0 = *(carray + a);
#line 15597
    if ((int )acellptr___0->cclass == -1) {
#line 15598
      continue;
    }
#line 15600
    ablock = (int )acellptr___0->cblock;
#line 15601
    ablckptr = *(barray + ablock);
#line 15602
    axcenter___0 = acellptr___0->cxcenter;
#line 15603
    aorient = (int )acellptr___0->corient;
#line 15604
    Trybin = (axcenter___0 - binOffst) / binWidth;
#line 15604
    if (Trybin < 0) {
#line 15604
      abin = 0;
    } else {
#line 15604
      if (Trybin > numBins) {
#line 15604
        tmp___0 = numBins;
      } else {
#line 15604
        tmp___0 = Trybin;
      }
#line 15604
      abin = tmp___0;
    }
#line 15605
    cellaptr = (*(*(binptr + ablock) + abin))->cell;
#line 15606
    i = 1;
#line 15606
    while (i <= *cellaptr) {
#line 15607
      if (*(cellaptr + i) == a) {
#line 15608
        Apost = i;
#line 15609
        break;
      }
#line 15606
      i ++;
    }
#line 15612
    bblock = 0;
#line 15613
    firstTry = 0;
#line 15614
    botblk = ablock - 1;
#line 15614
    if (botblk < 1) {
#line 15615
      botblk = 1;
    }
#line 15617
    topblk = ablock + 1;
#line 15617
    if (topblk > numblock) {
#line 15618
      topblk = numblock;
    }
#line 15620
    i = 1;
#line 15620
    while (1) {
#line 15621
      while (1) {
#line 15622
        blk___0 = XPICK_INT(botblk, topblk, firstTry);
#line 15623
        bblckptr = *(barray + blk___0);
#line 15621
        if (! (ablock == blk___0)) {
#line 15621
          if (! ((int )ablckptr->bclass != (int )bblckptr->bclass)) {
#line 15621
            break;
          }
        }
      }
#line 15627
      bleft___0 = bblckptr->bxcenter + (int )bblckptr->bleft;
#line 15628
      bright___0 = bblckptr->bxcenter + (int )bblckptr->bright;
#line 15629
      if (bleft___0 >= axcenter___0 - windx) {
#line 15629
        l = bleft___0;
      } else {
#line 15629
        l = axcenter___0 - windx;
      }
#line 15630
      if (bright___0 <= axcenter___0 + windx) {
#line 15630
        r = bright___0;
      } else {
#line 15630
        r = axcenter___0 + windx;
      }
#line 15631
      if (l > r) {
#line 15632
        if (i == 1) {
#line 15633
          firstTry = blk___0;
          goto __Cont;
        } else {
#line 15635
          if (i == 3) {
#line 15636
            if (r < bleft___0) {
#line 15637
              r = bleft___0;
#line 15637
              l = r;
            } else {
#line 15639
              r = bright___0;
#line 15639
              l = r;
            }
          } else {
#line 15642
            firstTry = - ablock;
            goto __Cont;
          }
        }
      }
#line 15646
      bblock = blk___0;
#line 15647
      bycenter___0 = bblckptr->bycenter;
#line 15648
      if (bblock == ablock) {
#line 15649
        bxcenter___0 = XPICK_INT(l, r, axcenter___0);
      } else {
#line 15651
        bxcenter___0 = XPICK_INT(l, r, 0);
      }
#line 15653
      break;
      __Cont: /* CIL Label */ 
#line 15620
      i ++;
    }
#line 15655
    Trybin = (bxcenter___0 - binOffst) / binWidth;
#line 15655
    if (Trybin < 0) {
#line 15655
      bbin = 0;
    } else {
#line 15655
      if (Trybin > numBins) {
#line 15655
        tmp___1 = numBins;
      } else {
#line 15655
        tmp___1 = Trybin;
      }
#line 15655
      bbin = tmp___1;
    }
#line 15656
    cellbptr = (*(*(binptr + bblock) + bbin))->cell;
#line 15657
    if (*cellbptr == 0) {
#line 15658
      if ((int )ablckptr->borient == 1) {
#line 15659
        if ((int )bblckptr->borient == 1) {
#line 15660
          tmp___2 = ucxx1(bxcenter___0, bycenter___0);
#line 15660
          if (tmp___2) {
#line 15661
            flips ++;
          }
        } else {
#line 15664
          if (aorient == 0) {
#line 15664
            tmp___3 = 1;
          } else {
#line 15664
            tmp___3 = 3;
          }
#line 15664
          tmp___4 = ucxxo1(bxcenter___0, bycenter___0, tmp___3);
#line 15664
          if (tmp___4) {
#line 15665
            flips ++;
          }
        }
      } else {
#line 15669
        if ((int )bblckptr->borient == 1) {
#line 15670
          if (aorient == 1) {
#line 15670
            tmp___5 = 0;
          } else {
#line 15670
            tmp___5 = 2;
          }
#line 15670
          tmp___6 = ucxxo1(bxcenter___0, bycenter___0, tmp___5);
#line 15670
          if (tmp___6) {
#line 15672
            flips ++;
          }
        } else {
#line 15675
          tmp___7 = ucxx1(bxcenter___0, bycenter___0);
#line 15675
          if (tmp___7) {
#line 15676
            flips ++;
          }
        }
      }
    } else {
#line 15681
      if (1 < *cellbptr) {
#line 15681
        tmp___8 = Yacm_random();
#line 15681
        Bpost = tmp___8 % ((*cellbptr - 1) + 1) + 1;
      } else {
#line 15681
        Bpost = 1;
      }
#line 15682
      b = *(cellbptr + Bpost);
#line 15683
      bcellptr___0 = *(carray + b);
#line 15684
      bblock = (int )bcellptr___0->cblock;
#line 15685
      bblckptr = *(barray + bblock);
#line 15686
      if ((int )bcellptr___0->cclass == -1) {
#line 15687
        continue;
      } else {
#line 15686
        if (a == b) {
#line 15687
          continue;
        }
      }
#line 15690
      borient___0 = (int )bcellptr___0->corient;
#line 15691
      if ((int )ablckptr->borient == 1) {
#line 15692
        if ((int )bblckptr->borient == 1) {
#line 15693
          t = ucxx2();
#line 15694
          if (t == 1) {
#line 15695
            pairflips ++;
          }
        } else {
#line 15698
          if (borient___0 == 1) {
#line 15698
            tmp___9 = 0;
          } else {
#line 15698
            tmp___9 = 2;
          }
#line 15698
          if (aorient == 0) {
#line 15698
            tmp___10 = 1;
          } else {
#line 15698
            tmp___10 = 3;
          }
#line 15698
          t = ucxxo2(tmp___10, tmp___9);
#line 15700
          if (t == 1) {
#line 15701
            pairflips ++;
          }
        }
      } else {
#line 15705
        if ((int )bblckptr->borient == 1) {
#line 15706
          if (borient___0 == 0) {
#line 15706
            tmp___11 = 1;
          } else {
#line 15706
            tmp___11 = 3;
          }
#line 15706
          if (aorient == 1) {
#line 15706
            tmp___12 = 0;
          } else {
#line 15706
            tmp___12 = 2;
          }
#line 15706
          t = ucxxo2(tmp___12, tmp___11);
#line 15708
          if (t == 1) {
#line 15709
            pairflips ++;
          }
        } else {
#line 15712
          t = ucxx2();
#line 15713
          if (t == 1) {
#line 15714
            pairflips ++;
          }
        }
      }
    }
#line 15719
    attempts ++;
  }
#line 15721
  temp = (100.0 * (double )(pairflips + flips)) / (double )attmax;
#line 15722
  if ((double )pairflips > 0.0001) {
#line 15723
    fp_ratio = (100.0 * (double )flips) / (double )pairflips;
  } else {
#line 15725
    fp_ratio = 100.0;
  }
#line 15727
  fprintf(fpo, "%3d %3d %4d %8d %7d %5d 0.0 %4.1f %4.1f %4.1f %4.1f", iteration + 1,
          2, fds, funccost, penalty, P_limit, binpenCon, roLenCon, temp, fp_ratio);
#line 15730
  fprintf(fpo, " %4.1f\n", (100.0 * (double )earlyRej) / (double )attmax);
#line 15731
  fflush(fpo);
#line 15732
  return 0;
}
}
#line 15736 "D:/a/test/300.c"
int unetseg(void) 
{ SEGBOXPTR segptr ;
  CHANGRDPTR ptr1 ;
  CHANGRDPTR ptr2 ;
  CHANGRDPTR bptr ;
  CHANGRDPTR fptr ;
  CHANGRDPTR sptr ;
  CHANGRDPTR eptr ;
  CHANGRDPTR ptr ;
  CHANGRDPTR gdptr ;
  CHANGRDPTR tryptr[500] ;
  DENSITYPTR denptr ;
  DENSITYPTR headptr ;
  NBOXPTR netptr ;
  int pin1 ;
  int pin2 ;
  int x1 ;
  int x2 ;
  int x ;
  int i ;
  int channel ;
  int chan ;
  int up_channel ;
  int segment ;
  int Flag ;
  int changes ;
  int index___0 ;
  int b___0 ;
  int e ;
  int net ;
  int track ;
  int dtrack ;
  int Ucount ;
  int Lcount ;
  int j ;
  int t ;
  int tryFlag[500] ;
  int trynet ;
  int pinloc ;
  int self_reset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 15748
  gtopChan = 1;
#line 15749
  gbotChan = numChans;
#line 15750
  tracks = 0;
#line 15751
  index___0 = 1;
#line 15751
  while (index___0 <= *(netchgs + 0)) {
#line 15752
    net = *(netchgs + index___0);
#line 15753
    b___0 = *(anet + net);
#line 15754
    e = *(anet + (net + 1)) - 1;
#line 15755
    segment = b___0;
#line 15755
    while (segment <= e) {
#line 15756
      if ((int )(aNetSeg + segment)->current == 0) {
#line 15757
        segptr = (aNetSeg + segment)->top;
      } else {
#line 15759
        segptr = (aNetSeg + segment)->bot;
      }
#line 15761
      pin1 = segptr->pin1;
#line 15762
      pin2 = segptr->pin2;
#line 15763
      if (pin1 > maxterm) {
#line 15763
        if (pin2 > maxterm) {
          goto __Cont;
        }
      }
#line 15766
      ptr1 = segptr->pin1ptr;
#line 15767
      ptr2 = segptr->pin2ptr;
#line 15768
      x1 = (ptr1->netptr)->newx;
#line 15769
      x2 = (ptr2->netptr)->newx;
#line 15770
      if (x1 == x2) {
        goto __Cont;
      }
#line 15773
      channel = (int )segptr->channel;
#line 15774
      if (channel > gtopChan) {
#line 15775
        gtopChan = channel;
      }
#line 15777
      if (channel < gbotChan) {
#line 15778
        gbotChan = channel;
      }
#line 15780
      net = (aNetSeg + segment)->net;
#line 15781
      if ((int )ptr1->nSegType > 0) {
#line 15782
        Flag = 0;
#line 15783
        bptr = ptr1;
#line 15784
        while (1) {
#line 15784
          if ((unsigned int )bptr->prevgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 15784
            if (! (((bptr->prevgrd)->netptr)->newx == x1)) {
#line 15784
              break;
            }
          } else {
#line 15784
            break;
          }
#line 15786
          if (net == (int )(*(tearray + ((bptr->prevgrd)->netptr)->terminal))->net) {
#line 15786
            if ((int )(bptr->prevgrd)->nSegType < 0) {
#line 15788
              Flag = 1;
#line 15789
              sptr = ptr1->nextgrd;
#line 15790
              while ((sptr->netptr)->newx == x1) {
#line 15791
                sptr = sptr->nextgrd;
              }
#line 15793
              break;
            } else {
#line 15795
              bptr = bptr->prevgrd;
            }
          } else {
#line 15795
            bptr = bptr->prevgrd;
          }
        }
#line 15798
        if (! Flag) {
#line 15799
          sptr = ptr1->nextgrd;
#line 15800
          while ((sptr->netptr)->newx == x1) {
#line 15801
            if (net == (int )(*(tearray + (sptr->netptr)->terminal))->net) {
#line 15801
              if ((int )sptr->nSegType < 0) {
#line 15803
                Flag = 1;
              }
            }
#line 15805
            sptr = sptr->nextgrd;
          }
        }
#line 15808
        if (! Flag) {
#line 15809
          sptr = bptr;
        }
      } else {
#line 15812
        if (x1 != gxstart) {
#line 15813
          sptr = ptr1->nextgrd;
#line 15814
          while ((sptr->netptr)->newx == x1) {
#line 15815
            sptr = sptr->nextgrd;
          }
        } else {
#line 15818
          sptr = ptr1;
        }
      }
#line 15821
      if ((int )ptr2->nSegType < 0) {
#line 15822
        Flag = 0;
#line 15823
        fptr = ptr2;
#line 15824
        while (1) {
#line 15824
          if ((unsigned int )fptr->nextgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 15824
            if (! (((fptr->nextgrd)->netptr)->newx == x2)) {
#line 15824
              break;
            }
          } else {
#line 15824
            break;
          }
#line 15826
          if (net == (int )(*(tearray + ((fptr->nextgrd)->netptr)->terminal))->net) {
#line 15826
            if ((int )(fptr->nextgrd)->nSegType > 0) {
#line 15828
              Flag = 1;
#line 15829
              eptr = ptr2->prevgrd;
#line 15830
              while ((eptr->netptr)->newx == x2) {
#line 15831
                eptr = eptr->prevgrd;
              }
#line 15833
              break;
            } else {
#line 15835
              fptr = fptr->nextgrd;
            }
          } else {
#line 15835
            fptr = fptr->nextgrd;
          }
        }
#line 15838
        if (! Flag) {
#line 15839
          eptr = ptr2->prevgrd;
#line 15840
          while ((eptr->netptr)->newx == x2) {
#line 15841
            if (net == (int )(*(tearray + (eptr->netptr)->terminal))->net) {
#line 15841
              if ((int )eptr->nSegType > 0) {
#line 15843
                Flag = 1;
              }
            }
#line 15845
            eptr = eptr->prevgrd;
          }
        }
#line 15848
        if (! Flag) {
#line 15849
          eptr = fptr;
        }
      } else {
#line 15852
        if (x2 != gxstop) {
#line 15853
          eptr = ptr2->prevgrd;
#line 15854
          while ((eptr->netptr)->newx == x2) {
#line 15855
            eptr = eptr->prevgrd;
          }
        } else {
#line 15858
          eptr = ptr2;
        }
      }
#line 15861
      eptr = eptr->nextgrd;
#line 15862
      if (pin1 <= maxterm) {
#line 15863
        ptr1->nSegType = (short )((int )ptr1->nSegType - 1);
      }
#line 15865
      if (pin2 <= maxterm) {
#line 15866
        ptr2->nSegType = (short )((int )ptr2->nSegType - -1);
      }
#line 15868
      ptr = sptr;
#line 15868
      while ((unsigned int )ptr != (unsigned int )eptr) {
#line 15869
        denptr = ptr->dptr;
#line 15870
        if ((unsigned int )denptr->nnext != (unsigned int )((struct densitybox *)((void *)0))) {
#line 15871
          (denptr->nnext)->nback = denptr->nback;
        }
#line 15873
        (denptr->nback)->nnext = denptr->nnext;
#line 15874
        ptr->ntracks = (short )((int )ptr->ntracks - 1);
#line 15874
        track = ptr->ntracks;
#line 15875
        headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 15876
        if ((unsigned int )headptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 15877
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 15878
          denptr->nnext = headptr;
#line 15879
          headptr->nback = denptr;
#line 15880
          denptr->nback = *(*(DboxHead + channel) + track);
        } else {
#line 15882
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 15883
          denptr->nnext = (struct densitybox *)((void *)0);
#line 15884
          denptr->nback = *(*(DboxHead + channel) + track);
        }
#line 15868
        ptr = ptr->nextgrd;
      }
      __Cont: /* CIL Label */ 
#line 15755
      segment ++;
    }
#line 15751
    index___0 ++;
  }
#line 15889
  Lcount = 0;
#line 15889
  Ucount = Lcount;
#line 15890
  if ((unsigned int )ULgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 15891
    if ((int )(ULgrdptr->netptr)->pinloc == 0) {
#line 15892
      gdptr = ULgrdptr->nnextgrd;
#line 15893
      while ((int )(gdptr->netptr)->pinloc == 0) {
#line 15894
        gdptr = gdptr->nnextgrd;
      }
#line 15896
      if ((int )(gdptr->netptr)->pinloc == -1) {
#line 15897
        channel = (int )(gdptr->netptr)->row;
      } else {
#line 15899
        channel = (int )(gdptr->netptr)->row + 1;
      }
    } else {
#line 15902
      if ((int )(ULgrdptr->netptr)->pinloc == -1) {
#line 15903
        channel = (int )(ULgrdptr->netptr)->row;
      } else {
#line 15905
        channel = (int )(ULgrdptr->netptr)->row + 1;
      }
    }
  } else {
#line 15909
    if ((int )(LLgrdptr->netptr)->pinloc == 0) {
#line 15910
      gdptr = LLgrdptr->nnextgrd;
#line 15911
      while ((int )(gdptr->netptr)->pinloc == 0) {
#line 15912
        gdptr = gdptr->nnextgrd;
      }
#line 15914
      if ((int )(gdptr->netptr)->pinloc == -1) {
#line 15915
        channel = (int )(gdptr->netptr)->row;
      } else {
#line 15917
        channel = (int )(gdptr->netptr)->row + 1;
      }
    } else {
#line 15920
      if ((int )(LLgrdptr->netptr)->pinloc == -1) {
#line 15921
        channel = (int )(LLgrdptr->netptr)->row;
      } else {
#line 15923
        channel = (int )(LLgrdptr->netptr)->row + 1;
      }
    }
#line 15926
    channel ++;
  }
#line 15928
  up_channel = channel;
#line 15929
  if ((unsigned int )ULgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 15930
    gdptr = ULgrdptr->nextgrd;
#line 15930
    while ((unsigned int )gdptr != (unsigned int )URgrdptr) {
#line 15932
      tmp = Ucount;
#line 15932
      Ucount ++;
#line 15932
      *(Shuffle + tmp) = gdptr;
#line 15930
      gdptr = gdptr->nextgrd;
    }
#line 15934
    qsortgdx((char *)Shuffle, Ucount, (int )sizeof(CHANGRDPTR ));
#line 15935
    ULgrdptr->nnextgrd = *(Shuffle + 0);
#line 15936
    (*(Shuffle + 0))->nprevgrd = ULgrdptr;
#line 15937
    if (Ucount >= 2) {
#line 15938
      i = 0;
#line 15938
      while (i <= Ucount - 2) {
#line 15939
        (*(Shuffle + i))->nnextgrd = *(Shuffle + (i + 1));
#line 15940
        (*(Shuffle + (i + 1)))->nprevgrd = *(Shuffle + i);
#line 15938
        i ++;
      }
    }
#line 15943
    (*(Shuffle + (Ucount - 1)))->nnextgrd = URgrdptr;
#line 15944
    URgrdptr->nprevgrd = *(Shuffle + (Ucount - 1));
#line 15945
    gdptr = ULgrdptr->nnextgrd;
#line 15945
    while ((unsigned int )gdptr != (unsigned int )URgrdptr) {
#line 15947
      x = (gdptr->netptr)->xpos;
#line 15948
      dtrack = 0;
#line 15949
      if (x != (gdptr->netptr)->newx) {
#line 15950
        denptr = gdptr->dptr;
#line 15951
        if ((unsigned int )denptr->nnext != (unsigned int )((struct densitybox *)((void *)0))) {
#line 15952
          (denptr->nnext)->nback = denptr->nback;
        }
#line 15954
        (denptr->nback)->nnext = denptr->nnext;
#line 15955
        tryptr[0] = gdptr->nprevgrd;
#line 15956
        if (((tryptr[0])->netptr)->xpos != x) {
#line 15957
          t = 0;
#line 15957
          tryFlag[t] = 0;
#line 15958
          while (1) {
#line 15958
            if ((unsigned int )(tryptr[t])->nprevgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 15958
              if (! ((((tryptr[t])->nprevgrd)->netptr)->xpos == ((tryptr[0])->netptr)->xpos)) {
#line 15958
                break;
              }
            } else {
#line 15958
              break;
            }
#line 15961
            t ++;
#line 15962
            tryptr[t] = (tryptr[t - 1])->nprevgrd;
#line 15963
            tryFlag[t] = 0;
          }
#line 15965
          i = 0;
#line 15965
          while (i <= t) {
#line 15966
            if (tryFlag[i] == 0) {
#line 15967
              changes = 0;
#line 15968
              trynet = (int )(*(tearray + ((tryptr[i])->netptr)->terminal))->net;
#line 15970
              changes += (int )(tryptr[i])->nSegType;
#line 15971
              j = i + 1;
#line 15971
              while (j <= t) {
#line 15972
                if ((int )(*(tearray + ((tryptr[j])->netptr)->terminal))->net == trynet) {
#line 15974
                  tryFlag[j] = 1;
#line 15975
                  changes += (int )(tryptr[j])->nSegType;
                }
#line 15971
                j ++;
              }
#line 15978
              if (changes < 0) {
#line 15979
                dtrack += changes;
              }
            }
#line 15965
            i ++;
          }
#line 15983
          tryptr[0] = gdptr->nnextgrd;
#line 15984
          if (((tryptr[0])->netptr)->xpos == x) {
#line 15985
            t = 0;
#line 15985
            tryFlag[t] = 0;
#line 15986
            while (1) {
#line 15986
              if ((unsigned int )(tryptr[t])->nnextgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 15986
                if (! ((((tryptr[t])->nnextgrd)->netptr)->xpos == ((tryptr[0])->netptr)->xpos)) {
#line 15986
                  break;
                }
              } else {
#line 15986
                break;
              }
#line 15989
              t ++;
#line 15990
              tryptr[t] = (tryptr[t - 1])->nnextgrd;
#line 15991
              tryFlag[t] = 0;
            }
#line 15993
            i = 0;
#line 15993
            while (i <= t) {
#line 15994
              if (tryFlag[i] == 0) {
#line 15995
                changes = 0;
#line 15996
                trynet = (int )(*(tearray + ((tryptr[i])->netptr)->terminal))->net;
#line 15998
                changes += (int )(tryptr[i])->nSegType;
#line 15999
                j = i + 1;
#line 15999
                while (j <= t) {
#line 16000
                  if ((int )(*(tearray + ((tryptr[j])->netptr)->terminal))->net == trynet) {
#line 16002
                    tryFlag[j] = 1;
#line 16003
                    changes += (int )(tryptr[j])->nSegType;
                  }
#line 15999
                  j ++;
                }
#line 16006
                if (changes > 0) {
#line 16007
                  dtrack += changes;
                }
              }
#line 15993
              i ++;
            }
          }
        }
#line 16014
        gdptr->ntracks = (short )((int )(gdptr->nprevgrd)->ntracks + dtrack);
#line 16015
        track = (int )gdptr->ntracks;
#line 16016
        headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 16017
        if ((unsigned int )headptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16018
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 16019
          denptr->nnext = headptr;
#line 16020
          headptr->nback = denptr;
#line 16021
          denptr->nback = *(*(DboxHead + channel) + track);
        } else {
#line 16023
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 16024
          denptr->nnext = (struct densitybox *)((void *)0);
#line 16025
          denptr->nback = *(*(DboxHead + channel) + track);
        }
      }
#line 15945
      gdptr = gdptr->nnextgrd;
    }
  }
#line 16030
  if ((unsigned int )LLgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 16031
    channel --;
#line 16032
    gdptr = LLgrdptr->nextgrd;
#line 16032
    while ((unsigned int )gdptr != (unsigned int )LRgrdptr) {
#line 16034
      tmp___0 = Lcount;
#line 16034
      Lcount ++;
#line 16034
      *(Shuffle + tmp___0) = gdptr;
#line 16032
      gdptr = gdptr->nextgrd;
    }
#line 16036
    qsortgdx((char *)Shuffle, Lcount, (int )sizeof(CHANGRDPTR ));
#line 16037
    LLgrdptr->nnextgrd = *(Shuffle + 0);
#line 16038
    (*(Shuffle + 0))->nprevgrd = LLgrdptr;
#line 16039
    if (Lcount >= 2) {
#line 16040
      i = 0;
#line 16040
      while (i <= Lcount - 2) {
#line 16041
        (*(Shuffle + i))->nnextgrd = *(Shuffle + (i + 1));
#line 16042
        (*(Shuffle + (i + 1)))->nprevgrd = *(Shuffle + i);
#line 16040
        i ++;
      }
    }
#line 16045
    (*(Shuffle + (Lcount - 1)))->nnextgrd = LRgrdptr;
#line 16046
    LRgrdptr->nprevgrd = *(Shuffle + (Lcount - 1));
#line 16047
    gdptr = LLgrdptr->nnextgrd;
#line 16047
    while ((unsigned int )gdptr != (unsigned int )LRgrdptr) {
#line 16049
      x = (gdptr->netptr)->xpos;
#line 16050
      dtrack = 0;
#line 16051
      if (x != (gdptr->netptr)->newx) {
#line 16052
        denptr = gdptr->dptr;
#line 16053
        if ((unsigned int )denptr->nnext != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16054
          (denptr->nnext)->nback = denptr->nback;
        }
#line 16056
        (denptr->nback)->nnext = denptr->nnext;
#line 16057
        tryptr[0] = gdptr->nprevgrd;
#line 16058
        if (((tryptr[0])->netptr)->xpos != x) {
#line 16059
          t = 0;
#line 16059
          tryFlag[t] = 0;
#line 16060
          while (1) {
#line 16060
            if ((unsigned int )(tryptr[t])->nprevgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 16060
              if (! ((((tryptr[t])->nprevgrd)->netptr)->xpos == ((tryptr[0])->netptr)->xpos)) {
#line 16060
                break;
              }
            } else {
#line 16060
              break;
            }
#line 16063
            t ++;
#line 16064
            tryptr[t] = (tryptr[t - 1])->nprevgrd;
#line 16065
            tryFlag[t] = 0;
          }
#line 16067
          i = 0;
#line 16067
          while (i <= t) {
#line 16068
            if (tryFlag[i] == 0) {
#line 16069
              changes = 0;
#line 16070
              trynet = (int )(*(tearray + ((tryptr[i])->netptr)->terminal))->net;
#line 16072
              changes += (int )(tryptr[i])->nSegType;
#line 16073
              j = i + 1;
#line 16073
              while (j <= t) {
#line 16074
                if ((int )(*(tearray + ((tryptr[j])->netptr)->terminal))->net == trynet) {
#line 16076
                  tryFlag[j] = 1;
#line 16077
                  changes += (int )(tryptr[j])->nSegType;
                }
#line 16073
                j ++;
              }
#line 16080
              if (changes < 0) {
#line 16081
                dtrack += changes;
              }
            }
#line 16067
            i ++;
          }
#line 16085
          tryptr[0] = gdptr->nnextgrd;
#line 16086
          if (((tryptr[0])->netptr)->xpos == x) {
#line 16087
            t = 0;
#line 16087
            tryFlag[t] = 0;
#line 16088
            while (1) {
#line 16088
              if ((unsigned int )(tryptr[t])->nnextgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 16088
                if (! ((((tryptr[t])->nnextgrd)->netptr)->xpos == ((tryptr[0])->netptr)->xpos)) {
#line 16088
                  break;
                }
              } else {
#line 16088
                break;
              }
#line 16091
              t ++;
#line 16092
              tryptr[t] = (tryptr[t - 1])->nnextgrd;
#line 16093
              tryFlag[t] = 0;
            }
#line 16095
            i = 0;
#line 16095
            while (i <= t) {
#line 16096
              if (tryFlag[i] == 0) {
#line 16097
                changes = 0;
#line 16098
                trynet = (int )(*(tearray + ((tryptr[i])->netptr)->terminal))->net;
#line 16100
                changes += (int )(tryptr[i])->nSegType;
#line 16101
                j = i + 1;
#line 16101
                while (j <= t) {
#line 16102
                  if ((int )(*(tearray + ((tryptr[j])->netptr)->terminal))->net == trynet) {
#line 16104
                    tryFlag[j] = 1;
#line 16105
                    changes += (int )(tryptr[j])->nSegType;
                  }
#line 16101
                  j ++;
                }
#line 16108
                if (changes > 0) {
#line 16109
                  dtrack += changes;
                }
              }
#line 16095
              i ++;
            }
          }
        }
#line 16116
        gdptr->ntracks = (short )((int )(gdptr->nprevgrd)->ntracks + dtrack);
#line 16117
        track = (int )gdptr->ntracks;
#line 16118
        headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 16119
        if ((unsigned int )headptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16120
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 16121
          denptr->nnext = headptr;
#line 16122
          headptr->nback = denptr;
#line 16123
          denptr->nback = *(*(DboxHead + channel) + track);
        } else {
#line 16125
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 16126
          denptr->nnext = (struct densitybox *)((void *)0);
#line 16127
          denptr->nback = *(*(DboxHead + channel) + track);
        }
      }
#line 16047
      gdptr = gdptr->nnextgrd;
    }
  }
#line 16132
  if (uneven_cell_height) {
#line 16133
    if ((unsigned int )ULgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 16134
      channel = up_channel;
#line 16135
      gdptr = ULgrdptr;
#line 16135
      while ((unsigned int )gdptr != (unsigned int )URgrdptr) {
#line 16137
        netptr = gdptr->netptr;
#line 16138
        pinloc = (int )netptr->pinloc;
#line 16139
        if (pinloc == 1) {
#line 16140
          self_reset = (int )((*(carray + netptr->cell))->tileptr)->top;
        } else {
#line 16141
          if (pinloc == -1) {
#line 16142
            self_reset = - ((int )((*(carray + netptr->cell))->tileptr)->bottom);
          } else {
#line 16144
            self_reset = 0;
          }
        }
#line 16146
        tmp___1 = facing_cellheight(netptr->terminal, (int )netptr->row, pinloc, 1);
#line 16146
        gdptr->ntracks = (short )((int )gdptr->ntracks + (self_reset + tmp___1) / track_spacing);
#line 16149
        denptr = gdptr->dptr;
#line 16150
        if ((unsigned int )denptr->nnext != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16151
          (denptr->nnext)->nback = denptr->nback;
        }
#line 16153
        (denptr->nback)->nnext = denptr->nnext;
#line 16154
        track = (int )gdptr->ntracks;
#line 16155
        headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 16156
        if ((unsigned int )headptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16157
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 16158
          denptr->nnext = headptr;
#line 16159
          headptr->nback = denptr;
#line 16160
          denptr->nback = *(*(DboxHead + channel) + track);
        } else {
#line 16162
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 16163
          denptr->nnext = (struct densitybox *)((void *)0);
#line 16164
          denptr->nback = *(*(DboxHead + channel) + track);
        }
#line 16135
        gdptr = gdptr->nnextgrd;
      }
    }
#line 16168
    if ((unsigned int )LLgrdptr != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 16169
      channel = up_channel - 1;
#line 16170
      gdptr = LLgrdptr;
#line 16170
      while ((unsigned int )gdptr != (unsigned int )LRgrdptr) {
#line 16172
        netptr = gdptr->netptr;
#line 16173
        pinloc = (int )netptr->pinloc;
#line 16174
        if (pinloc == 1) {
#line 16175
          self_reset = (int )((*(carray + netptr->cell))->tileptr)->top;
        } else {
#line 16176
          if (pinloc == -1) {
#line 16177
            self_reset = - ((int )((*(carray + netptr->cell))->tileptr)->bottom);
          } else {
#line 16179
            self_reset = 0;
          }
        }
#line 16181
        tmp___2 = facing_cellheight(netptr->terminal, (int )netptr->row, pinloc, 1);
#line 16181
        gdptr->ntracks = (short )((int )gdptr->ntracks + (self_reset + tmp___2) / track_spacing);
#line 16184
        denptr = gdptr->dptr;
#line 16185
        if ((unsigned int )denptr->nnext != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16186
          (denptr->nnext)->nback = denptr->nback;
        }
#line 16188
        (denptr->nback)->nnext = denptr->nnext;
#line 16189
        track = (int )gdptr->ntracks;
#line 16190
        headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 16191
        if ((unsigned int )headptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16192
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 16193
          denptr->nnext = headptr;
#line 16194
          headptr->nback = denptr;
#line 16195
          denptr->nback = *(*(DboxHead + channel) + track);
        } else {
#line 16197
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 16198
          denptr->nnext = (struct densitybox *)((void *)0);
#line 16199
          denptr->nback = *(*(DboxHead + channel) + track);
        }
#line 16170
        gdptr = gdptr->nnextgrd;
      }
    }
  }
#line 16204
  index___0 = 1;
#line 16204
  while (index___0 <= *(netchgs + 0)) {
#line 16205
    net = *(netchgs + index___0);
#line 16206
    b___0 = *(anet + net);
#line 16207
    e = *(anet + (net + 1)) - 1;
#line 16208
    segment = b___0;
#line 16208
    while (segment <= e) {
#line 16209
      if ((int )(aNetSeg + segment)->ncurrent == 0) {
#line 16210
        segptr = (aNetSeg + segment)->ntop;
      } else {
#line 16212
        segptr = (aNetSeg + segment)->nbot;
      }
#line 16214
      pin1 = segptr->pin1;
#line 16215
      pin2 = segptr->pin2;
#line 16216
      if (pin1 > maxterm) {
#line 16216
        if (pin2 > maxterm) {
          goto __Cont___0;
        }
      }
#line 16219
      ptr1 = segptr->pin1ptr;
#line 16220
      ptr2 = segptr->pin2ptr;
#line 16221
      x1 = (ptr1->netptr)->xpos;
#line 16222
      x2 = (ptr2->netptr)->xpos;
#line 16223
      if (x1 == x2) {
        goto __Cont___0;
      }
#line 16226
      channel = (int )segptr->channel;
#line 16227
      if (channel > gtopChan) {
#line 16228
        gtopChan = channel;
      }
#line 16230
      if (channel < gbotChan) {
#line 16231
        gbotChan = channel;
      }
#line 16233
      net = (aNetSeg + segment)->net;
#line 16234
      if ((int )ptr1->nSegType >= 0) {
#line 16235
        Flag = 0;
#line 16236
        bptr = ptr1;
#line 16237
        while (1) {
#line 16237
          if ((unsigned int )bptr->nprevgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 16237
            if (! (((bptr->nprevgrd)->netptr)->xpos == x1)) {
#line 16237
              break;
            }
          } else {
#line 16237
            break;
          }
#line 16239
          if ((int )(*(tearray + ((bptr->nprevgrd)->netptr)->terminal))->net == net) {
#line 16239
            if ((int )(bptr->nprevgrd)->nSegType < 0) {
#line 16241
              Flag = 1;
#line 16242
              sptr = ptr1->nnextgrd;
#line 16243
              while ((sptr->netptr)->xpos == x1) {
#line 16244
                sptr = sptr->nnextgrd;
              }
#line 16246
              break;
            } else {
#line 16248
              bptr = bptr->nprevgrd;
            }
          } else {
#line 16248
            bptr = bptr->nprevgrd;
          }
        }
#line 16251
        if (! Flag) {
#line 16252
          sptr = ptr1->nnextgrd;
#line 16253
          while ((sptr->netptr)->xpos == x1) {
#line 16254
            if (net == (int )(*(tearray + (sptr->netptr)->terminal))->net) {
#line 16254
              if ((int )sptr->nSegType < 0) {
#line 16256
                Flag = 1;
              }
            }
#line 16258
            sptr = sptr->nnextgrd;
          }
        }
#line 16261
        if (! Flag) {
#line 16262
          sptr = bptr;
        }
      } else {
#line 16265
        sptr = ptr1->nnextgrd;
#line 16266
        while ((sptr->netptr)->xpos == x1) {
#line 16267
          sptr = sptr->nnextgrd;
        }
      }
#line 16270
      if ((int )ptr2->nSegType <= 0) {
#line 16271
        Flag = 0;
#line 16272
        fptr = ptr2;
#line 16273
        while (1) {
#line 16273
          if ((unsigned int )fptr->nnextgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 16273
            if (! (((fptr->nnextgrd)->netptr)->xpos == x2)) {
#line 16273
              break;
            }
          } else {
#line 16273
            break;
          }
#line 16275
          if ((int )(*(tearray + ((fptr->nnextgrd)->netptr)->terminal))->net == net) {
#line 16275
            if ((int )(fptr->nnextgrd)->nSegType > 0) {
#line 16277
              Flag = 1;
#line 16278
              eptr = ptr2->nprevgrd;
#line 16279
              while ((eptr->netptr)->xpos == x2) {
#line 16280
                eptr = eptr->nprevgrd;
              }
#line 16282
              break;
            } else {
#line 16284
              fptr = fptr->nnextgrd;
            }
          } else {
#line 16284
            fptr = fptr->nnextgrd;
          }
        }
#line 16287
        if (! Flag) {
#line 16288
          eptr = ptr2->nprevgrd;
#line 16289
          while ((eptr->netptr)->xpos == x2) {
#line 16290
            if (net == (int )(*(tearray + (eptr->netptr)->terminal))->net) {
#line 16290
              if ((int )eptr->nSegType > 0) {
#line 16292
                Flag = 1;
              }
            }
#line 16294
            eptr = eptr->nprevgrd;
          }
        }
#line 16297
        if (! Flag) {
#line 16298
          eptr = fptr;
        }
      } else {
#line 16301
        eptr = ptr2->nprevgrd;
#line 16302
        while ((eptr->netptr)->xpos == x2) {
#line 16303
          eptr = eptr->nprevgrd;
        }
      }
#line 16306
      eptr = eptr->nnextgrd;
#line 16307
      if (pin1 <= maxterm) {
#line 16308
        ptr1->nSegType = (short )((int )ptr1->nSegType + 1);
      }
#line 16310
      if (pin2 <= maxterm) {
#line 16311
        ptr2->nSegType = (short )((int )ptr2->nSegType + -1);
      }
#line 16313
      ptr = sptr;
#line 16313
      while ((unsigned int )ptr != (unsigned int )eptr) {
#line 16314
        denptr = ptr->dptr;
#line 16315
        if ((unsigned int )denptr->nnext != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16316
          (denptr->nnext)->nback = denptr->nback;
        }
#line 16318
        (denptr->nback)->nnext = denptr->nnext;
#line 16319
        ptr->ntracks = (short )((int )ptr->ntracks + 1);
#line 16319
        track = ptr->ntracks;
#line 16320
        headptr = (*(*(DboxHead + channel) + track))->nnext;
#line 16321
        if ((unsigned int )headptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16322
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 16323
          denptr->nnext = headptr;
#line 16324
          headptr->nback = denptr;
#line 16325
          denptr->nback = *(*(DboxHead + channel) + track);
        } else {
#line 16327
          (*(*(DboxHead + channel) + track))->nnext = denptr;
#line 16328
          denptr->nnext = (struct densitybox *)((void *)0);
#line 16329
          denptr->nback = *(*(DboxHead + channel) + track);
        }
#line 16313
        ptr = ptr->nnextgrd;
      }
      __Cont___0: /* CIL Label */ 
#line 16208
      segment ++;
    }
#line 16204
    index___0 ++;
  }
#line 16334
  chan = 1;
#line 16334
  while (chan <= numChans) {
#line 16335
    track = max_tdensity + 30;
#line 16335
    while (track >= 0) {
#line 16336
      if ((unsigned int )(*(*(DboxHead + chan) + track))->nnext != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16337
        break;
      }
#line 16335
      track --;
    }
#line 16340
    *(nmaxTrack + chan) = track;
#line 16341
    tracks += track;
#line 16334
    chan ++;
  }
#line 16343
  return 0;
}
}
#line 16349 "D:/a/test/300.c"
int first_time_in_unlap  =    1;
#line 16353 "D:/a/test/300.c"
int noPairs  ;
#line 16496
int xcompact(void) ;
#line 16354 "D:/a/test/300.c"
int unlap(int flag ) 
{ CBOXPTR cellptr___0 ;
  int *num ;
  int i ;
  int cell_count ;
  int space___0 ;
  int cell___0 ;
  int block___0 ;
  int cell_left ;
  int left_edge ;
  int right_edge ;
  int fixed ;
  int unfixed ;
  int *left_queue ;
  int *right_queue ;
  int *center_queue ;
  int max_cell_in_blk ;
  int min_right_fixed_cell ;
  int max_left_fixed_cell ;
  int pair_array_index ;
  int total_cells ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 16367
  tmp = safe_malloc((unsigned int )(numblock + 1) * sizeof(int ));
#line 16367
  num = (int *)tmp;
#line 16368
  block___0 = 0;
#line 16368
  while (block___0 <= numblock) {
#line 16369
    *(num + block___0) = 0;
#line 16368
    block___0 ++;
  }
#line 16371
  if (flag == -2) {
#line 16372
    total_cells = numcells + ffeeds;
  } else {
#line 16374
    total_cells = numcells;
  }
#line 16376
  cell___0 = 1;
#line 16376
  while (cell___0 <= total_cells) {
#line 16377
    (*(num + (*(carray + cell___0))->cblock)) ++;
#line 16376
    cell___0 ++;
  }
#line 16379
  if (! first_time_in_unlap) {
#line 16380
    block___0 = 1;
#line 16380
    while (block___0 <= numblock) {
#line 16381
      safe_free((char *)*(pairArray + block___0));
#line 16380
      block___0 ++;
    }
#line 16383
    safe_free((char *)pairArray);
  } else {
#line 16385
    first_time_in_unlap = 0;
  }
#line 16387
  tmp___0 = safe_malloc((unsigned int )(numblock + 1) * sizeof(int *));
#line 16387
  pairArray = (int **)tmp___0;
#line 16389
  max_cell_in_blk = 0;
#line 16390
  block___0 = 1;
#line 16390
  while (block___0 <= numblock) {
#line 16391
    tmp___1 = safe_malloc((unsigned int )(*(num + block___0) + 1) * sizeof(int ));
#line 16391
    *(pairArray + block___0) = (int *)tmp___1;
#line 16393
    *(*(pairArray + block___0) + 0) = *(num + block___0);
#line 16394
    if (*(num + block___0) > max_cell_in_blk) {
#line 16395
      max_cell_in_blk = *(num + block___0);
    }
#line 16390
    block___0 ++;
  }
#line 16398
  tmp___2 = safe_malloc((unsigned int )(max_cell_in_blk + 1) * sizeof(int ));
#line 16398
  left_queue = (int *)tmp___2;
#line 16399
  tmp___3 = safe_malloc((unsigned int )(max_cell_in_blk + 1) * sizeof(int ));
#line 16399
  right_queue = (int *)tmp___3;
#line 16400
  tmp___4 = safe_malloc((unsigned int )(max_cell_in_blk + 1) * sizeof(int ));
#line 16400
  center_queue = (int *)tmp___4;
#line 16401
  cell___0 = 1;
#line 16401
  while (cell___0 <= total_cells) {
#line 16402
    block___0 = (int )(*(carray + cell___0))->cblock;
#line 16403
    tmp___5 = *(num + block___0);
#line 16403
    (*(num + block___0)) --;
#line 16403
    *(*(pairArray + block___0) + tmp___5) = cell___0;
#line 16401
    cell___0 ++;
  }
#line 16405
  block___0 = 1;
#line 16405
  while (block___0 <= numblock) {
#line 16406
    qsortx((char *)(*(pairArray + block___0) + 1), *(*(pairArray + block___0) + 0),
           (int )sizeof(int ));
#line 16405
    block___0 ++;
  }
#line 16409
  block___0 = 1;
#line 16409
  while (block___0 <= numblock) {
#line 16410
    left_edge = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bleft;
#line 16411
    right_edge = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bright;
#line 16412
    cell_count = *(*(pairArray + block___0) + 0);
#line 16412
    if (cell_count > 1) {
#line 16413
      noPairs = 0;
    }
#line 16415
    fixed = 0;
#line 16416
    unfixed = 0;
#line 16417
    i = 1;
#line 16417
    while (i <= cell_count) {
#line 16418
      if ((int )(*(carray + *(*(pairArray + block___0) + i)))->cclass == -1) {
#line 16419
        fixed = 1;
      } else {
#line 16421
        unfixed = 1;
      }
#line 16417
      i ++;
    }
#line 16424
    if (fixed == 1) {
#line 16424
      if (unfixed == 1) {
#line 16425
        i = 0;
#line 16425
        while (i <= max_cell_in_blk) {
#line 16426
          *(left_queue + i) = 0;
#line 16427
          *(right_queue + i) = 0;
#line 16428
          *(center_queue + i) = 0;
#line 16425
          i ++;
        }
#line 16430
        max_left_fixed_cell = 0;
#line 16431
        i = 1;
#line 16431
        while (i <= cell_count) {
#line 16432
          cellptr___0 = *(carray + *(*(pairArray + block___0) + i));
#line 16433
          if ((int )cellptr___0->cclass == -1) {
#line 16434
            if (left_edge == cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->left) {
#line 16436
              left_edge += (int )cellptr___0->clength;
#line 16437
              (*left_queue) ++;
#line 16437
              *(left_queue + *left_queue) = *(*(pairArray + block___0) + i);
#line 16438
              max_left_fixed_cell = i;
            } else {
#line 16440
              break;
            }
          }
#line 16431
          i ++;
        }
#line 16444
        min_right_fixed_cell = cell_count + 1;
#line 16445
        i = cell_count;
#line 16445
        while (i >= 1) {
#line 16446
          cellptr___0 = *(carray + *(*(pairArray + block___0) + i));
#line 16447
          if ((int )cellptr___0->cclass == -1) {
#line 16448
            if (right_edge == cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right) {
#line 16450
              right_edge -= (int )cellptr___0->clength;
#line 16451
              (*right_queue) ++;
#line 16451
              *(right_queue + *right_queue) = *(*(pairArray + block___0) + i);
#line 16452
              min_right_fixed_cell = i;
            } else {
#line 16454
              break;
            }
          }
#line 16445
          i --;
        }
#line 16458
        i = 1;
#line 16458
        while (i <= cell_count) {
#line 16459
          cellptr___0 = *(carray + *(*(pairArray + block___0) + i));
#line 16460
          if ((int )cellptr___0->cclass != -1) {
#line 16463
            (*center_queue) ++;
#line 16463
            *(center_queue + *center_queue) = *(*(pairArray + block___0) + i);
          } else {
#line 16460
            if ((int )cellptr___0->cclass == -1) {
#line 16460
              if (i > max_left_fixed_cell) {
#line 16460
                if (i < min_right_fixed_cell) {
#line 16463
                  (*center_queue) ++;
#line 16463
                  *(center_queue + *center_queue) = *(*(pairArray + block___0) + i);
                }
              }
            }
          }
#line 16458
          i ++;
        }
#line 16466
        pair_array_index = 0;
#line 16467
        i = 1;
#line 16467
        while (i <= *left_queue) {
#line 16468
          pair_array_index ++;
#line 16468
          *(*(pairArray + block___0) + pair_array_index) = *(left_queue + i);
#line 16467
          i ++;
        }
#line 16470
        i = 1;
#line 16470
        while (i <= *center_queue) {
#line 16471
          pair_array_index ++;
#line 16471
          *(*(pairArray + block___0) + pair_array_index) = *(center_queue + i);
#line 16470
          i ++;
        }
#line 16473
        i = *right_queue;
#line 16473
        while (i >= 1) {
#line 16474
          pair_array_index ++;
#line 16474
          *(*(pairArray + block___0) + pair_array_index) = *(right_queue + i);
#line 16473
          i --;
        }
      }
    }
#line 16477
    left_edge = (*(barray + block___0))->bxcenter + (int )(*(barray + block___0))->bleft;
#line 16478
    if (flag == 1) {
#line 16479
      space___0 = (int )((double )(*(feeds_in_row + block___0) * binWidth) / (double )(cell_count - 1));
    } else {
#line 16482
      space___0 = 0;
    }
#line 16484
    i = 1;
#line 16484
    while (i <= cell_count) {
#line 16485
      cellptr___0 = *(carray + *(*(pairArray + block___0) + i));
#line 16486
      cell_left = (int )(cellptr___0->tileptr)->left;
#line 16487
      cellptr___0->cxcenter = left_edge - cell_left;
#line 16488
      left_edge += ((int )(cellptr___0->tileptr)->right - cell_left) + space___0;
#line 16484
      i ++;
    }
#line 16409
    block___0 ++;
  }
#line 16491
  safe_free((char *)num);
#line 16492
  safe_free((char *)left_queue);
#line 16493
  safe_free((char *)right_queue);
#line 16494
  safe_free((char *)center_queue);
#line 16495
  if (flag >= 0) {
#line 16496
    xcompact();
  }
#line 16498
  return 0;
}
}
#line 16508 "D:/a/test/300.c"
int upair(void) 
{ CBOXPTR acellptr___0 ;
  CBOXPTR bcellptr___0 ;
  BBOXPTR ablckptr ;
  int a___0 ;
  int b___0 ;
  int ablock___0 ;
  int aorient ;
  int flips ;
  int attempts___0 ;
  int axcenter___0 ;
  int anxcenter___0 ;
  int bnxcenter___0 ;
  int aleft___0 ;
  int aright___0 ;
  int startx1 ;
  int endx1 ;
  int cellleft ;
  int cellrite ;
  int leftEdge ;
  int riteEdge ;
  int aptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 16520
  flips = 0;
#line 16521
  attempts___0 = 0;
#line 16522
  while (attempts___0 < attmax) {
#line 16523
    if (1 < numblock) {
#line 16523
      tmp = Yacm_random();
#line 16523
      ablock___0 = tmp % ((numblock - 1) + 1) + 1;
    } else {
#line 16523
      ablock___0 = 1;
    }
#line 16524
    if (*(*(pairArray + ablock___0) + 0) <= 1) {
#line 16525
      continue;
    }
#line 16527
    if (1 < *(*(pairArray + ablock___0) + 0)) {
#line 16527
      tmp___0 = Yacm_random();
#line 16527
      aptr = tmp___0 % ((*(*(pairArray + ablock___0) + 0) - 1) + 1) + 1;
    } else {
#line 16527
      aptr = 1;
    }
#line 16528
    a___0 = *(*(pairArray + ablock___0) + aptr);
#line 16529
    acellptr___0 = *(carray + a___0);
#line 16530
    if ((int )acellptr___0->cclass == -1) {
#line 16531
      continue;
    }
#line 16533
    aorient = (int )acellptr___0->corient;
#line 16534
    ablckptr = *(barray + ablock___0);
#line 16535
    axcenter___0 = acellptr___0->cxcenter;
#line 16536
    aleft___0 = (int )(acellptr___0->tileptr)->left;
#line 16537
    aright___0 = (int )(acellptr___0->tileptr)->right;
#line 16538
    startx1 = axcenter___0 + aleft___0;
#line 16539
    endx1 = axcenter___0 + aright___0;
#line 16540
    if (aptr > 1) {
#line 16541
      cellleft = *(*(pairArray + ablock___0) + (aptr - 1));
#line 16542
      if ((int )(*(carray + cellleft))->cclass == -1) {
#line 16543
        cellleft = 0;
      }
    } else {
#line 16546
      cellleft = 0;
    }
#line 16548
    if (aptr < *(*(pairArray + ablock___0) + 0)) {
#line 16549
      cellrite = *(*(pairArray + ablock___0) + (aptr + 1));
#line 16550
      if ((int )(*(carray + cellrite))->cclass == -1) {
#line 16551
        cellrite = 0;
      }
    } else {
#line 16554
      cellrite = 0;
    }
#line 16556
    if (cellleft == 0) {
#line 16556
      if (cellrite == 0) {
#line 16557
        continue;
      }
    }
#line 16559
    if (cellleft != 0) {
#line 16559
      if (cellrite != 0) {
#line 16560
        tmp___5 = Yacm_random();
#line 16560
        if (tmp___5 % 2 + 1 == 1) {
#line 16562
          b___0 = cellleft;
#line 16563
          bcellptr___0 = *(carray + b___0);
#line 16564
          leftEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->left;
#line 16565
          anxcenter___0 = leftEdge - aleft___0;
#line 16566
          bnxcenter___0 = endx1 - (int )(bcellptr___0->tileptr)->right;
#line 16567
          tmp___2 = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 16567
          if (tmp___2) {
#line 16568
            flips ++;
#line 16569
            attempts___0 ++;
#line 16570
            *(*(pairArray + ablock___0) + aptr) = b___0;
#line 16571
            *(*(pairArray + ablock___0) + (aptr - 1)) = a___0;
          } else {
#line 16573
            attempts___0 ++;
#line 16574
            b___0 = cellrite;
#line 16575
            bcellptr___0 = *(carray + b___0);
#line 16576
            riteEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->right;
#line 16578
            anxcenter___0 = riteEdge - aright___0;
#line 16579
            bnxcenter___0 = startx1 - (int )(bcellptr___0->tileptr)->left;
#line 16580
            tmp___1 = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 16580
            if (tmp___1) {
#line 16581
              flips ++;
#line 16582
              *(*(pairArray + ablock___0) + aptr) = b___0;
#line 16583
              *(*(pairArray + ablock___0) + (aptr + 1)) = a___0;
            }
#line 16585
            attempts___0 ++;
          }
        } else {
#line 16588
          b___0 = cellrite;
#line 16589
          bcellptr___0 = *(carray + b___0);
#line 16590
          riteEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->right;
#line 16591
          anxcenter___0 = riteEdge - aright___0;
#line 16592
          bnxcenter___0 = startx1 - (int )(bcellptr___0->tileptr)->left;
#line 16593
          tmp___4 = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 16593
          if (tmp___4) {
#line 16594
            flips ++;
#line 16595
            attempts___0 ++;
#line 16596
            *(*(pairArray + ablock___0) + aptr) = b___0;
#line 16597
            *(*(pairArray + ablock___0) + (aptr + 1)) = a___0;
          } else {
#line 16599
            attempts___0 ++;
#line 16600
            b___0 = cellleft;
#line 16601
            bcellptr___0 = *(carray + b___0);
#line 16602
            leftEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->left;
#line 16603
            anxcenter___0 = leftEdge - aleft___0;
#line 16604
            bnxcenter___0 = endx1 - (int )(bcellptr___0->tileptr)->right;
#line 16605
            tmp___3 = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 16605
            if (tmp___3) {
#line 16606
              flips ++;
#line 16607
              *(*(pairArray + ablock___0) + aptr) = b___0;
#line 16608
              *(*(pairArray + ablock___0) + (aptr - 1)) = a___0;
            }
#line 16610
            attempts___0 ++;
          }
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 16614
      if (cellleft) {
#line 16615
        b___0 = cellleft;
#line 16616
        bcellptr___0 = *(carray + b___0);
#line 16617
        leftEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->left;
#line 16618
        anxcenter___0 = leftEdge - aleft___0;
#line 16619
        bnxcenter___0 = endx1 - (int )(bcellptr___0->tileptr)->right;
#line 16620
        tmp___6 = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 16620
        if (tmp___6) {
#line 16621
          flips ++;
#line 16622
          *(*(pairArray + ablock___0) + aptr) = b___0;
#line 16623
          *(*(pairArray + ablock___0) + (aptr - 1)) = a___0;
        }
#line 16625
        attempts___0 ++;
      } else {
#line 16626
        if (cellrite != 0) {
#line 16626
          if ((int )(*(carray + cellrite))->cclass != -1) {
#line 16626
            if ((int )acellptr___0->cclass != -1) {
#line 16629
              b___0 = cellrite;
#line 16630
              bcellptr___0 = *(carray + b___0);
#line 16631
              riteEdge = bcellptr___0->cxcenter + (int )(bcellptr___0->tileptr)->right;
#line 16632
              anxcenter___0 = riteEdge - aright___0;
#line 16633
              bnxcenter___0 = startx1 - (int )(bcellptr___0->tileptr)->left;
#line 16634
              tmp___7 = ucxxp(a___0, b___0, anxcenter___0, bnxcenter___0);
#line 16634
              if (tmp___7) {
#line 16635
                flips ++;
#line 16636
                *(*(pairArray + ablock___0) + aptr) = b___0;
#line 16637
                *(*(pairArray + ablock___0) + (aptr + 1)) = a___0;
              }
#line 16639
              attempts___0 ++;
            }
          }
        }
      }
    }
#line 16642
    if ((int )ablckptr->borient == 1) {
#line 16643
      if ((int )acellptr___0->orflag != 0) {
#line 16644
        if (aorient == 0) {
#line 16644
          tmp___8 = 2;
        } else {
#line 16644
          tmp___8 = 0;
        }
#line 16644
        uc0(a___0, tmp___8);
      }
    } else {
#line 16647
      if ((int )acellptr___0->orflag != 0) {
#line 16648
        if (aorient == 1) {
#line 16648
          tmp___9 = 3;
        } else {
#line 16648
          tmp___9 = 1;
        }
#line 16648
        uc0(a___0, tmp___9);
      }
    }
  }
#line 16652
  fprintf(fpo, " %3d %6.3f %9d  %3d%s\n", iteration + 1, 2, funccost, (int )((100.0 * (double )flips) / (double )attmax),
          "%");
#line 16654
  fflush(fpo);
#line 16655
  return 0;
}
}
#line 16659 "D:/a/test/300.c"
int urcost(int segment ) 
{ SEGBOXPTR asegptr ;
  SEGBOXPTR bsegptr ;
  CHANGRDPTR aptr1 ;
  CHANGRDPTR aptr2 ;
  CHANGRDPTR bptr1 ;
  CHANGRDPTR bptr2 ;
  CHANGRDPTR bptr ;
  CHANGRDPTR fptr ;
  CHANGRDPTR ptr ;
  CHANGRDPTR saptr ;
  CHANGRDPTR eaptr ;
  CHANGRDPTR sbptr ;
  CHANGRDPTR ebptr ;
  DENSITYPTR denptr ;
  DENSITYPTR headptr ;
  int penalty___0 ;
  int check ;
  int x ;
  int achannel ;
  int bchannel ;
  int aMaxVal ;
  int bMaxVal ;
  int maxaa ;
  int maxbb ;
  int aoutside ;
  int binside ;
  int ax1 ;
  int ax2 ;
  int bx1 ;
  int bx2 ;
  int net ;
  int Flag ;
  int track ;

  {
#line 16672
  penalty___0 = 0;
#line 16673
  net = (aNetSeg + segment)->net;
#line 16674
  if ((int )(aNetSeg + segment)->current == 0) {
#line 16675
    asegptr = (aNetSeg + segment)->top;
#line 16676
    bsegptr = (aNetSeg + segment)->bot;
  } else {
#line 16678
    asegptr = (aNetSeg + segment)->bot;
#line 16679
    bsegptr = (aNetSeg + segment)->top;
  }
#line 16681
  achannel = (int )asegptr->channel;
#line 16682
  bchannel = (int )bsegptr->channel;
#line 16683
  aptr1 = asegptr->pin1ptr;
#line 16684
  aptr2 = asegptr->pin2ptr;
#line 16685
  bptr1 = bsegptr->pin1ptr;
#line 16686
  bptr2 = bsegptr->pin2ptr;
#line 16687
  aMaxVal = *(maxTrack + achannel);
#line 16688
  bMaxVal = *(maxTrack + bchannel);
#line 16689
  ax1 = (aptr1->netptr)->xpos;
#line 16690
  ax2 = (aptr2->netptr)->xpos;
#line 16691
  bx1 = (bptr1->netptr)->xpos;
#line 16692
  bx2 = (bptr2->netptr)->xpos;
#line 16693
  net = (aNetSeg + segment)->net;
#line 16694
  if ((int )aptr1->SegType > 0) {
#line 16695
    Flag = 0;
#line 16696
    bptr = aptr1;
#line 16697
    while (1) {
#line 16697
      if ((unsigned int )bptr->prevgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 16697
        if (! (((bptr->prevgrd)->netptr)->xpos == ax1)) {
#line 16697
          break;
        }
      } else {
#line 16697
        break;
      }
#line 16699
      if (net == (int )(*(tearray + ((bptr->prevgrd)->netptr)->terminal))->net) {
#line 16699
        if ((int )(bptr->prevgrd)->SegType < 0) {
#line 16701
          Flag = 1;
#line 16702
          saptr = aptr1->nextgrd;
#line 16703
          while ((saptr->netptr)->xpos == ax1) {
#line 16704
            saptr = saptr->nextgrd;
          }
#line 16706
          break;
        } else {
#line 16708
          bptr = bptr->prevgrd;
        }
      } else {
#line 16708
        bptr = bptr->prevgrd;
      }
    }
#line 16711
    if (! Flag) {
#line 16712
      saptr = aptr1->nextgrd;
#line 16713
      while ((saptr->netptr)->xpos == ax1) {
#line 16714
        if (net == (int )(*(tearray + (saptr->netptr)->terminal))->net) {
#line 16714
          if ((int )saptr->SegType < 0) {
#line 16716
            Flag = 1;
          }
        }
#line 16718
        saptr = saptr->nextgrd;
      }
    }
#line 16721
    if (! Flag) {
#line 16722
      saptr = bptr;
    }
  } else {
#line 16725
    if (ax1 != gxstart) {
#line 16726
      saptr = aptr1->nextgrd;
#line 16727
      while ((saptr->netptr)->xpos == ax1) {
#line 16728
        saptr = saptr->nextgrd;
      }
    } else {
#line 16731
      saptr = aptr1;
    }
  }
#line 16734
  if ((int )aptr2->SegType < 0) {
#line 16735
    Flag = 0;
#line 16736
    fptr = aptr2;
#line 16737
    while (1) {
#line 16737
      if ((unsigned int )fptr->nextgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 16737
        if (! (((fptr->nextgrd)->netptr)->xpos == ax2)) {
#line 16737
          break;
        }
      } else {
#line 16737
        break;
      }
#line 16739
      if (net == (int )(*(tearray + ((fptr->nextgrd)->netptr)->terminal))->net) {
#line 16739
        if ((int )(fptr->nextgrd)->SegType > 0) {
#line 16741
          Flag = 1;
#line 16742
          eaptr = aptr2->prevgrd;
#line 16743
          while ((eaptr->netptr)->xpos == ax2) {
#line 16744
            eaptr = eaptr->prevgrd;
          }
#line 16746
          break;
        } else {
#line 16748
          fptr = fptr->nextgrd;
        }
      } else {
#line 16748
        fptr = fptr->nextgrd;
      }
    }
#line 16751
    if (! Flag) {
#line 16752
      eaptr = aptr2->prevgrd;
#line 16753
      while ((eaptr->netptr)->xpos == ax2) {
#line 16754
        if (net == (int )(*(tearray + (eaptr->netptr)->terminal))->net) {
#line 16754
          if ((int )eaptr->SegType > 0) {
#line 16756
            Flag = 1;
          }
        }
#line 16758
        eaptr = eaptr->prevgrd;
      }
    }
#line 16761
    if (! Flag) {
#line 16762
      eaptr = fptr;
    }
  } else {
#line 16765
    if (ax2 != gxstop) {
#line 16766
      eaptr = aptr2->prevgrd;
#line 16767
      while ((eaptr->netptr)->xpos == ax2) {
#line 16768
        eaptr = eaptr->prevgrd;
      }
    } else {
#line 16771
      eaptr = aptr2;
    }
  }
#line 16774
  if ((int )bptr1->SegType >= 0) {
#line 16775
    Flag = 0;
#line 16776
    bptr = bptr1;
#line 16777
    while (1) {
#line 16777
      if ((unsigned int )bptr->prevgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 16777
        if (! (((bptr->prevgrd)->netptr)->xpos == bx1)) {
#line 16777
          break;
        }
      } else {
#line 16777
        break;
      }
#line 16779
      if (net == (int )(*(tearray + ((bptr->prevgrd)->netptr)->terminal))->net) {
#line 16779
        if ((int )(bptr->prevgrd)->SegType < 0) {
#line 16781
          Flag = 1;
#line 16782
          sbptr = bptr1->nextgrd;
#line 16783
          while ((sbptr->netptr)->xpos == bx1) {
#line 16784
            sbptr = sbptr->nextgrd;
          }
#line 16786
          break;
        } else {
#line 16788
          bptr = bptr->prevgrd;
        }
      } else {
#line 16788
        bptr = bptr->prevgrd;
      }
    }
#line 16791
    if (! Flag) {
#line 16792
      sbptr = bptr1->nextgrd;
#line 16793
      while ((sbptr->netptr)->xpos == bx1) {
#line 16794
        if (net == (int )(*(tearray + (sbptr->netptr)->terminal))->net) {
#line 16794
          if ((int )sbptr->SegType < 0) {
#line 16796
            Flag = 1;
          }
        }
#line 16798
        sbptr = sbptr->nextgrd;
      }
    }
#line 16801
    if (! Flag) {
#line 16802
      sbptr = bptr;
    }
  } else {
#line 16805
    sbptr = bptr1->nextgrd;
#line 16806
    while ((sbptr->netptr)->xpos == bx1) {
#line 16807
      sbptr = sbptr->nextgrd;
    }
  }
#line 16810
  if ((int )bptr2->SegType <= 0) {
#line 16811
    Flag = 0;
#line 16812
    fptr = bptr2;
#line 16813
    while (1) {
#line 16813
      if ((unsigned int )fptr->nextgrd != (unsigned int )((struct changrdbox *)((void *)0))) {
#line 16813
        if (! (((fptr->nextgrd)->netptr)->xpos == bx2)) {
#line 16813
          break;
        }
      } else {
#line 16813
        break;
      }
#line 16815
      if (net == (int )(*(tearray + ((fptr->nextgrd)->netptr)->terminal))->net) {
#line 16815
        if ((int )(fptr->nextgrd)->SegType > 0) {
#line 16817
          Flag = 1;
#line 16818
          ebptr = bptr2->prevgrd;
#line 16819
          while ((ebptr->netptr)->xpos == bx2) {
#line 16820
            ebptr = ebptr->prevgrd;
          }
#line 16822
          break;
        } else {
#line 16824
          fptr = fptr->nextgrd;
        }
      } else {
#line 16824
        fptr = fptr->nextgrd;
      }
    }
#line 16827
    if (! Flag) {
#line 16828
      ebptr = bptr2->prevgrd;
#line 16829
      while ((ebptr->netptr)->xpos == bx2) {
#line 16830
        if (net == (int )(*(tearray + (ebptr->netptr)->terminal))->net) {
#line 16830
          if ((int )ebptr->SegType > 0) {
#line 16832
            Flag = 1;
          }
        }
#line 16834
        ebptr = ebptr->prevgrd;
      }
    }
#line 16837
    if (! Flag) {
#line 16838
      ebptr = fptr;
    }
  } else {
#line 16841
    ebptr = bptr2->prevgrd;
#line 16842
    while ((ebptr->netptr)->xpos == bx2) {
#line 16843
      ebptr = ebptr->prevgrd;
    }
  }
#line 16846
  aoutside = 0;
#line 16847
  ax1 = (saptr->netptr)->xpos;
#line 16848
  ax2 = (eaptr->netptr)->xpos;
#line 16849
  denptr = (*(*(DboxHead + achannel) + aMaxVal))->next;
#line 16850
  while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16851
    x = ((denptr->grdptr)->netptr)->xpos;
#line 16852
    if (ax1 <= x) {
#line 16852
      if (! (ax2 >= x)) {
#line 16853
        aoutside = 1;
#line 16854
        break;
      }
    } else {
#line 16853
      aoutside = 1;
#line 16854
      break;
    }
#line 16850
    denptr = denptr->next;
  }
#line 16857
  if (aoutside == 0) {
#line 16858
    penalty___0 --;
  }
#line 16860
  binside = 0;
#line 16861
  bx1 = (sbptr->netptr)->xpos;
#line 16862
  bx2 = (ebptr->netptr)->xpos;
#line 16863
  denptr = (*(*(DboxHead + bchannel) + bMaxVal))->next;
#line 16864
  while ((unsigned int )denptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16865
    x = ((denptr->grdptr)->netptr)->xpos;
#line 16866
    if (bx1 <= x) {
#line 16866
      if (bx2 >= x) {
#line 16867
        binside = 1;
#line 16868
        break;
      }
    }
#line 16864
    denptr = denptr->next;
  }
#line 16871
  if (binside == 1) {
#line 16872
    penalty___0 ++;
  }
#line 16874
  eaptr = eaptr->nextgrd;
#line 16875
  ebptr = ebptr->nextgrd;
#line 16876
  if (penalty___0 == 0) {
#line 16877
    if (binside == 1) {
#line 16877
      if (aoutside == 0) {
#line 16879
        check = (bMaxVal - aMaxVal) + 2;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 16881
      maxaa = 0;
#line 16882
      maxbb = 0;
#line 16883
      ptr = saptr;
#line 16883
      while ((unsigned int )ptr != (unsigned int )eaptr) {
#line 16884
        if ((int )ptr->tracks > maxaa) {
#line 16885
          maxaa = (int )ptr->tracks;
        }
#line 16883
        ptr = ptr->nextgrd;
      }
#line 16888
      ptr = sbptr;
#line 16888
      while ((unsigned int )ptr != (unsigned int )ebptr) {
#line 16889
        if ((int )ptr->tracks > maxbb) {
#line 16890
          maxbb = (int )ptr->tracks;
        }
#line 16888
        ptr = ptr->nextgrd;
      }
#line 16893
      maxaa = (aMaxVal - maxaa) + 1;
#line 16894
      maxbb = (bMaxVal - maxbb) - 1;
#line 16895
      check = maxaa - maxbb;
    }
  } else {
#line 16898
    check = penalty___0;
  }
#line 16900
  if (check <= 0) {
#line 16901
    if (asegptr->pin1 <= maxterm) {
#line 16902
      aptr1->SegType = (short )((int )aptr1->SegType - 1);
    }
#line 16904
    if (asegptr->pin2 <= maxterm) {
#line 16905
      aptr2->SegType = (short )((int )aptr2->SegType - -1);
    }
#line 16907
    if (bsegptr->pin1 <= maxterm) {
#line 16908
      bptr1->SegType = (short )((int )bptr1->SegType + 1);
    }
#line 16910
    if (bsegptr->pin2 <= maxterm) {
#line 16911
      bptr2->SegType = (short )((int )bptr2->SegType + -1);
    }
#line 16913
    ptr = saptr;
#line 16913
    while ((unsigned int )ptr != (unsigned int )eaptr) {
#line 16914
      denptr = ptr->dptr;
#line 16915
      if ((unsigned int )denptr->next != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16916
        (denptr->next)->back = denptr->back;
      }
#line 16918
      (denptr->back)->next = denptr->next;
#line 16919
      ptr->tracks = (short )((int )ptr->tracks - 1);
#line 16919
      track = ptr->tracks;
#line 16920
      headptr = (*(*(DboxHead + achannel) + track))->next;
#line 16921
      if ((unsigned int )headptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16922
        (*(*(DboxHead + achannel) + track))->next = denptr;
#line 16923
        denptr->next = headptr;
#line 16924
        headptr->back = denptr;
#line 16925
        denptr->back = *(*(DboxHead + achannel) + track);
      } else {
#line 16927
        (*(*(DboxHead + achannel) + track))->next = denptr;
#line 16928
        denptr->next = (struct densitybox *)((void *)0);
#line 16929
        denptr->back = *(*(DboxHead + achannel) + track);
      }
#line 16913
      ptr = ptr->nextgrd;
    }
#line 16932
    if (aoutside == 0) {
#line 16933
      (*(maxTrack + achannel)) --;
    }
#line 16935
    ptr = sbptr;
#line 16935
    while ((unsigned int )ptr != (unsigned int )ebptr) {
#line 16936
      denptr = ptr->dptr;
#line 16937
      if ((unsigned int )denptr->next != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16938
        (denptr->next)->back = denptr->back;
      }
#line 16940
      (denptr->back)->next = denptr->next;
#line 16941
      ptr->tracks = (short )((int )ptr->tracks + 1);
#line 16941
      track = ptr->tracks;
#line 16942
      headptr = (*(*(DboxHead + bchannel) + track))->next;
#line 16943
      if ((unsigned int )headptr != (unsigned int )((struct densitybox *)((void *)0))) {
#line 16944
        (*(*(DboxHead + bchannel) + track))->next = denptr;
#line 16945
        denptr->next = headptr;
#line 16946
        headptr->back = denptr;
#line 16947
        denptr->back = *(*(DboxHead + bchannel) + track);
      } else {
#line 16949
        (*(*(DboxHead + bchannel) + track))->next = denptr;
#line 16950
        denptr->next = (struct densitybox *)((void *)0);
#line 16951
        denptr->back = *(*(DboxHead + bchannel) + track);
      }
#line 16935
      ptr = ptr->nextgrd;
    }
#line 16954
    if (binside == 1) {
#line 16955
      (*(maxTrack + bchannel)) ++;
    }
#line 16957
    if ((int )(aNetSeg + segment)->current == 1) {
#line 16958
      (aNetSeg + segment)->current = (char)0;
    } else {
#line 16960
      (aNetSeg + segment)->current = (char)1;
    }
#line 16962
    tracks += penalty___0;
#line 16963
    return (1);
  } else {
#line 16965
    return (0);
  }
}
}
#line 16969 "D:/a/test/300.c"
int utemp(void) 
{ double TloRange ;
  double Tfactor ;
  int pairtest ;
  int check ;
  unsigned int i2 ;
  double **tempfile ;
  char filename[64] ;
  int t ;
  int i ;
  int row___0 ;
  int freeze ;
  int cell___0 ;
  int changes ;
  FILE *fp ;
  double tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct _reent *tmp___4 ;

  {
#line 16978
  last_level = -1;
#line 16979
  if (stage >= 2) {
#line 16980
    pairtest = 1;
  } else {
#line 16982
    pairtest = 0;
  }
#line 16984
  initialRowControl = 0.0;
#line 16985
  finalRowControl = 0.0;
#line 16986
  check = 0;
#line 16987
  freeze = 10000000;
#line 16988
  randVar = (int )randomSeed;
#line 16989
  fprintf(fpo, "\nThe rand generator seed was at utemp() : %d\n\n\n", randVar);
#line 16991
  table1[0] = 1.0;
#line 16992
  table2[0] = 1.0;
#line 16993
  table3[0] = 1.0;
#line 16994
  i2 = 1U;
#line 16994
  while (i2 <= 1023U) {
#line 16995
    table1[i2] = exp(- ((double )i2) / 8.0);
#line 16996
    table2[i2] = exp(- ((double )i2) / 8192.0);
#line 16997
    table3[i2] = exp(- ((double )i2) / 8388608.0);
#line 16994
    i2 ++;
  }
#line 16999
  moveable_cells = 0;
#line 17000
  cell___0 = 1;
#line 17000
  while (cell___0 <= numcells) {
#line 17001
    if ((int )(*(carray + cell___0))->cclass < 0) {
      goto __Cont;
    }
#line 17004
    moveable_cells ++;
    __Cont: /* CIL Label */ 
#line 17000
    cell___0 ++;
  }
#line 17006
  if (moveable_cells <= 500) {
#line 17007
    attprcel = 25;
  } else {
#line 17009
    tmp = pow((double )moveable_cells / 500.0, 1.0 / 3.0);
#line 17009
    attprcel = (int )(25.0 * tmp);
  }
#line 17012
  if (tw_fast) {
#line 17013
    attprcel /= 5;
  }
#line 17015
  tmp___0 = safe_malloc(4U * sizeof(double *));
#line 17015
  tempfile = (double **)tmp___0;
#line 17016
  t = 0;
#line 17016
  while (t <= 3) {
#line 17017
    tmp___1 = safe_malloc(2U * sizeof(double ));
#line 17017
    *(tempfile + t) = (double *)tmp___1;
#line 17016
    t ++;
  }
#line 17019
  *(*(tempfile + 0) + 0) = 0.9825;
#line 17020
  *(*(tempfile + 0) + 1) = 90.0;
#line 17021
  fprintf(fpo, "  tempfile[0][0] = %f    ", *(*(tempfile + 0) + 0));
#line 17022
  fprintf(fpo, "tempfile[0][1] = %f\n  ", *(*(tempfile + 0) + 1));
#line 17023
  *(*(tempfile + 1) + 0) = 0.915;
#line 17024
  *(*(tempfile + 1) + 1) = 20.0;
#line 17025
  fprintf(fpo, "tempfile[1][0] = %f    ", *(*(tempfile + 1) + 0));
#line 17026
  fprintf(fpo, "tempfile[1][1] = %f\n  ", *(*(tempfile + 1) + 1));
#line 17027
  *(*(tempfile + 2) + 0) = 0.70;
#line 17028
  *(*(tempfile + 2) + 1) = 10.0;
#line 17029
  fprintf(fpo, "tempfile[2][0] = %f    ", *(*(tempfile + 2) + 0));
#line 17030
  fprintf(fpo, "tempfile[2][1] = %f\n  ", *(*(tempfile + 2) + 1));
#line 17031
  *(*(tempfile + 3) + 0) = 0.10;
#line 17032
  *(*(tempfile + 3) + 1) = 0.0;
#line 17033
  fprintf(fpo, "tempfile[3][0] = %f    ", *(*(tempfile + 3) + 0));
#line 17034
  fprintf(fpo, "tempfile[3][1] = %f\n\n", *(*(tempfile + 3) + 1));
#line 17035
  TloRange = 10000000000.0;
#line 17036
  t = -1;
#line 17037
  fprintf(fpo, "  I   T  fds     Wire Penalty P_lim Epct ");
#line 17038
  fprintf(fpo, "binC rowC  acc  s/p early  FDs    MRs\n");
#line 17039
  while (1) {
#line 17040
    while (T1 < TloRange) {
#line 17041
      t ++;
#line 17042
      if (t > 3) {
#line 17043
        fprintf(fpo, "exceeded tempfile array in ");
#line 17044
        fprintf(fpo, "utemp.c \n");
#line 17045
        exit(1);
      }
#line 17047
      Tfactor = *(*(tempfile + t) + 0);
#line 17048
      TloRange = *(*(tempfile + t) + 1);
    }
#line 17050
    if (pairtest == 0) {
#line 17051
      uloop();
#line 17052
      if (T1 < Tzero) {
#line 17053
        pairtest = 1;
      }
#line 17055
      savewolf(1);
    } else {
#line 17057
      if (check == 0) {
#line 17058
        check = 1;
#line 17059
        if (stage == 1) {
#line 17060
          uloop2();
#line 17061
          iteration ++;
        }
#line 17063
        last_level = -1;
#line 17064
        savewolf(1);
#line 17065
        freeze = iteration;
#line 17066
        if (connection_machine) {
#line 17067
          unlap(-1);
#line 17068
          findunlap(-1);
#line 17069
          outcm();
        }
#line 17071
        countf();
#line 17072
        if (doglobal) {
#line 17073
          sprintf(filename, "%s.cel", cktName);
#line 17074
          tmp___2 = (int )openFile(filename, "r", 1);
#line 17074
          fp = (FILE *)tmp___2;
#line 17075
          finalwire();
#line 17076
          grdcell(fp);
#line 17077
          fclose(fp);
        }
#line 17079
        reassign();
#line 17080
        if (doglobal) {
#line 17081
          if (addFeeds == 0) {
#line 17082
            row___0 = 1;
#line 17082
            while (row___0 <= numblock) {
#line 17083
              *(nofeed + row___0) = 1;
#line 17082
              row___0 ++;
            }
          }
#line 17086
          findunlap(1);
#line 17087
          fdthrus = findfeeds(0);
#line 17088
          fdthrus += *(add_to_row + 0);
#line 17089
          fixwolf(fdthrus);
#line 17090
          findfeeds(1);
#line 17091
          unlap(-2);
#line 17092
          add_dummy_feeds(last_feed);
#line 17093
          numcells += fdthrus;
#line 17094
          moveable_cells += fdthrus;
#line 17095
          if (stage >= 2) {
#line 17096
            sprintf(filename, "%s.rs2", cktName);
#line 17097
            tmp___3 = (int )openFile(filename, "r", 0);
#line 17097
            fp = (FILE *)tmp___3;
#line 17097
            if (fp) {
#line 17098
              fixfdpos(fp);
#line 17099
              fclose(fp);
            }
          }
        }
#line 17103
        sortpin();
#line 17104
        findunlap(0);
#line 17105
        penalty = 0;
#line 17106
        initialize_cost();
#line 17108
        fprintf(fpo, "Added: %d  feed-through cells\n\n", fdthrus);
#line 17109
        fprintf(fpo, "Removed the cell overlaps --- ");
#line 17110
        fprintf(fpo, "Will do neighbor interchanges only now\n");
#line 17111
        fprintf(fpo, "\nTOTAL INTERCONNECT LENGTH: %d\n", funccost);
#line 17112
        fprintf(fpo, "OVERLAP PENALTY: %d\n\n", penalty);
#line 17113
        fprintf(fpo, "initialRowControl:%8.3f\n", initialRowControl);
#line 17114
        fprintf(fpo, "finalRowControl:%8.3f\n", finalRowControl);
#line 17115
        fflush(fpo);
#line 17116
        attmax = 5 * moveable_cells;
#line 17117
        if (stage != 3) {
#line 17118
          if (noPairs == 0) {
#line 17119
            T1 = 0.001;
#line 17120
            fprintf(fpo, "iter      T      Wire accept\n");
#line 17121
            upair();
#line 17122
            savewolf(2);
          }
        }
      } else {
#line 17126
        if (noPairs == 0) {
#line 17127
          T1 = 0.001;
#line 17128
          upair();
#line 17129
          savewolf(2);
        }
      }
    }
#line 17133
    if (stage != 3) {
#line 17134
      iteration ++;
#line 17134
      printf("%3d ", iteration);
#line 17135
      if (iteration % 15 == 0) {
#line 17136
        printf("\n");
      }
#line 17138
      tmp___4 = __getreent();
#line 17138
      fflush(tmp___4->_stdout);
    }
#line 17140
    if (iteration >= freeze + 3) {
      goto _L;
    } else {
#line 17140
      if (stage == 3) {
        _L: /* CIL Label */ 
#line 17143
        i = 1;
#line 17143
        while (i <= 8) {
#line 17144
          align_init();
#line 17145
          changes = alignfeed();
#line 17146
          fprintf(fpo, "Total Feed-Alignment Movement (Pass %d): %d\n", i, changes);
#line 17143
          i ++;
        }
#line 17149
        align_init();
#line 17151
        findunlap(-1);
#line 17152
        if (doglobal) {
#line 17153
          globe();
#line 17154
          globroute();
#line 17155
          if (cswaps) {
#line 17156
            if (noPairs == 0) {
#line 17157
              ugpair();
            }
          }
#line 17160
          findrchk();
#line 17161
          fprintf(fpo, "\nFINAL NUMBER OF ROUTING TRACKS: %d\n\n", tracks);
#line 17163
          i = 1;
#line 17163
          while (i <= numChans) {
#line 17164
            fprintf(fpo, "MAX OF CHANNEL:%3d  is: %3d\n", i, *(maxTrack + i));
#line 17163
            i ++;
          }
#line 17167
          mergplist();
#line 17168
          outpins();
#line 17169
          output();
        } else {
#line 17171
          output();
        }
#line 17173
        fprintf(fpo, "FINAL TOTAL INTERCONNECT LENGTH: %d\n", funccost);
#line 17174
        fprintf(fpo, "FINAL OVERLAP PENALTY: %d    ", penalty);
#line 17175
        fprintf(fpo, "FINAL VALUE OF TOTAL COST IS: %d\n", funccost + penalty);
#line 17177
        fprintf(fpo, "MAX NUMBER OF ATTEMPTED FLIPS PER T:%8d\n", attmax);
#line 17178
        break;
      } else {
#line 17180
        T1 = Tfactor * T1;
      }
    }
  }
#line 17183
if(tempfile!=0){
 goto ERROR;
 ERROR:return 0;
}
  fprintf(fpo, "\n\ncost_scale_factor:%g\n\n", cost_scale_factor);
#line 17184
  return 0;
}
}
#line 17186 "D:/a/test/300.c"
int add_dummy_feeds(int feednum ) 
{ CBOXPTR cellptr___0 ;
  TIBOXPTR tileptr ;
  int pos ;
  int row___0 ;
  int i ;
  int last_cell ;
  char *tmp ;

  {
#line 17193
  row___0 = 1;
#line 17193
  while (row___0 <= numRows) {
#line 17194
    last_cell = *(*(pairArray + row___0) + *(*(pairArray + row___0) + 0));
#line 17195
    pos = ((*(carray + last_cell))->cxcenter + (int )((*(carray + last_cell))->tileptr)->right) - fdWidth;
#line 17197
    i = 1;
#line 17197
    while (i <= *(add_to_row + row___0)) {
#line 17198
      pos += fdWidth;
#line 17199
      feednum ++;
#line 17199
      cellptr___0 = *(carray + (numcells + feednum));
#line 17200
      cellptr___0->padside = (short)0;
#line 17201
      cellptr___0->cxcenter = pos;
#line 17202
      cellptr___0->cycenter = (*(barray + row___0))->bycenter;
#line 17203
      cellptr___0->cheight = (*(barray + row___0))->bheight;
#line 17204
      cellptr___0->clength = (short )fdWidth;
#line 17205
      if ((int )(*(barray + row___0))->borient == 2) {
#line 17206
        cellptr___0->corient = (char)1;
      }
#line 17208
      tileptr = cellptr___0->tileptr;
#line 17209
      tmp = safe_malloc(16U * sizeof(char ));
#line 17209
      cellptr___0->cname = tmp;
#line 17211
      sprintf(cellptr___0->cname, "twfeed%d", feednum);
#line 17215
      cellptr___0->cblock = (short )row___0;
#line 17216
      tileptr->left = (short )(- fdWidth / 2);
#line 17217
      tileptr->right = (short )(fdWidth + (int )tileptr->left);
#line 17218
      tileptr->bottom = (short )(- ((int )(*(barray + row___0))->bheight) / 2);
#line 17219
      tileptr->top = (short )((int )(*(barray + row___0))->bheight + (int )tileptr->bottom);
#line 17220
      safe_free((char *)(tileptr->termsptr)->nextterm);
#line 17221
      safe_free((char *)tileptr->termsptr);
#line 17222
      tileptr->termsptr = (struct termbox *)((void *)0);
#line 17197
      i ++;
    }
#line 17193
    row___0 ++;
  }
#line 17225
  return 0;
}
}
#line 17231 "D:/a/test/300.c"
static char programName[255]  ;
#line 17232 "D:/a/test/300.c"
static char progVersion[255]  ;
#line 17233 "D:/a/test/300.c"
static char progDate[255]  ;
#line 17234 "D:/a/test/300.c"
int initProgram(char *name , char *version ) 
{ char *date ;
  int i ;

  {
#line 17242
  sprintf(programName, "%s", name);
#line 17243
  sprintf(progVersion, "%s", version);
#line 17244
  date = getCompileDate();
#line 17244
  if (date) {
#line 17245
    sprintf(progDate, "%s", date);
  } else {
#line 17247
    sprintf(progDate, "unknown");
  }
#line 17249
  fprintf(fpo, "\n%s version:%s date:%s\n", programName, progVersion, progDate);
#line 17250
  fprintf(fpo, "Standard Cell Placement and Global Routing Program\n");
#line 17251
  fprintf(fpo, "Authors: Carl Sechen, Bill Swartz\n");
#line 17252
  fprintf(fpo, "          Yale University\n");
#line 17253
  printf("\n%s version:%s date:%s\n", programName, progVersion, progDate);
#line 17254
  printf("Standard Cell Placement and Global Routing Program\n");
#line 17255
  printf("Authors: Carl Sechen, Bill Swartz\n");
#line 17256
  printf("         Yale University\n");
#line 17257
  safe_free(date);
#line 17261
  randomSeed = 123456789U;
#line 17262
  fixarray = (int *)((void *)0);
#line 17263
  ffeeds = 0;
#line 17264
  i = 1;
#line 17264
  while (i <= 15) {
#line 17265
    macspace[i] = - 1.0;
#line 17264
    i ++;
  }
#line 17267
  costonly = 0;
#line 17268
  fdthrus = 0;
#line 17269
  doglobal = 0;
#line 17270
  cswaps = 0;
#line 17271
  imprange = - 1.0;
#line 17272
  attprcel = 0;
#line 17273
  addFeeds = 0;
#line 17274
  fdWidth = -1;
#line 17275
  rowSep = - 1.0;
#line 17276
  indent = 1.0;
#line 17277
  numSegs = 0;
#line 17278
  resume_run = 0;
#line 17279
  pin_layers_given = 0;
#line 17280
  no_feeds_side_nets = 0;
#line 17281
  no_net_normalize = 0;
#line 17282
  cost_scale_factor = 1.0;
#line 17283
  feedLayer = 0;
#line 17284
  tw_fast = 0;
#line 17285
  estimate_feeds = 1;
#line 17286
  connection_machine = 0;
#line 17287
  gate_array_special = 0;
#line 17291
  randomSeed2 = 987654321U;
#line 17292
  return (0);
}
}
#line 17293 "D:/a/test/300.c"
char *getProgName(void) 
{ char *tmp ;

  {
#line 17295
  tmp = strclone(programName);
#line 17295
  return (tmp);
}
}
#line 17297 "D:/a/test/300.c"
char *strclone(char *str ) 
{ char *copy ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 17301
  if (str) {
#line 17302
    if (*str) {
#line 17303
      tmp = strlen((char const   *)str);
#line 17303
      tmp___0 = safe_malloc(tmp + 1U);
#line 17303
      copy = tmp___0;
#line 17304
      sprintf(copy, "%s", str);
#line 17305
      return (copy);
    }
  }
#line 17308
  return ((char *)((void *)0));
}
}
#line 17310 "D:/a/test/300.c"
FILE *openFile(char *filename , char *readwrite , int abort___0 ) 
{ FILE *fileptr ;

  {
#line 17316
  fileptr = fopen((char const   *)filename, (char const   *)readwrite);
#line 17317
  if (! fileptr) {
#line 17317
    if (abort___0) {
#line 17318
      printf("could not open file %s\n", filename);
#line 17319
      exit(1);
    }
  }
#line 17321
  return (fileptr);
}
}
#line 17326 "D:/a/test/300.c"
int *blklist  ;
#line 17334 "D:/a/test/300.c"
INT2 *blkshifts  ;
#line 17372
int findblks(int bot___0 , int top___0 , int rite___0 , int direction ) ;
#line 17351 "D:/a/test/300.c"
int xcompact(void) 
{ int blk___0 ;
  int pad___0 ;
  int k___0 ;
  int bot___0 ;
  int top___0 ;
  int rite___0 ;
  int left___0 ;
  int maxd ;
  int cell___0 ;
  int end ;
  int mind ;
  int padside ;
  CBOXPTR padptr ;
  CBOXPTR cellptr___0 ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 17356
  tmp = safe_malloc((unsigned int )(numblock + 1) * sizeof(int ));
#line 17356
  blklist = (int *)tmp;
#line 17357
  tmp___0 = safe_malloc((unsigned int )(numblock + 1) * sizeof(INT2 ));
#line 17357
  blkshifts = (INT2 *)tmp___0;
#line 17358
  blk___0 = 1;
#line 17358
  while (blk___0 <= numblock) {
#line 17359
    (blkshifts + blk___0)->sleft = -1000;
#line 17358
    blk___0 ++;
  }
#line 17361
  pad___0 = numcells + 1;
#line 17361
  while (pad___0 <= numcells + numterms) {
#line 17362
    if ((int )(*(carray + pad___0))->padside == 12) {
      goto _L;
    } else {
#line 17362
      if ((int )(*(carray + pad___0))->padside == 13) {
        goto _L;
      } else {
#line 17362
        if ((int )(*(carray + pad___0))->padside == 11) {
          _L: /* CIL Label */ 
#line 17364
          padptr = *(carray + pad___0);
#line 17365
          padside = (int )padptr->padside;
#line 17366
          rite___0 = padptr->cxcenter + (int )(padptr->tileptr)->right;
#line 17367
          left___0 = padptr->cxcenter + (int )(padptr->tileptr)->left;
#line 17368
          bot___0 = (int )((double )(padptr->cycenter + (int )(padptr->tileptr)->bottom) - (rowSep * (double )rowHeight) * 0.67);
#line 17370
          top___0 = (int )((double )(padptr->cycenter + (int )(padptr->tileptr)->top) + (rowSep * (double )rowHeight) * 0.67);
#line 17372
          findblks(bot___0, top___0, rite___0, -1);
#line 17373
          maxd = 0;
#line 17374
          k___0 = 1;
#line 17374
          while (k___0 <= *(blklist + 0)) {
#line 17375
            blk___0 = *(blklist + k___0);
#line 17376
            cell___0 = *(*(pairArray + blk___0) + *(*(pairArray + blk___0) + 0));
#line 17377
            cellptr___0 = *(carray + cell___0);
#line 17378
            if (cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right > maxd) {
#line 17379
              maxd = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
            }
#line 17374
            k___0 ++;
          }
#line 17382
          k___0 = 1;
#line 17382
          while (k___0 <= *(blklist + 0)) {
#line 17383
            blk___0 = *(blklist + k___0);
#line 17384
            (blkshifts + blk___0)->srite = maxd;
#line 17385
            (blkshifts + blk___0)->sleft = (*(barray + blk___0))->bxcenter + (int )(*(barray + blk___0))->bleft;
#line 17382
            k___0 ++;
          }
#line 17388
          findblks(bot___0, top___0, rite___0, 1);
#line 17389
          (*(carray + pad___0))->cxcenter = (int )((double )(*(carray + pad___0))->cxcenter + (macspace[padside] - (double )(left___0 - maxd)));
#line 17390
          k___0 = 1;
#line 17390
          while (k___0 <= *(blklist + 0)) {
#line 17391
            blk___0 = *(blklist + k___0);
#line 17392
            (*(barray + blk___0))->bxcenter = (int )((double )(*(barray + blk___0))->bxcenter + (macspace[padside] - (double )(left___0 - maxd)));
#line 17394
            k___0 = 1;
#line 17394
            while (k___0 <= *(*(pairArray + blk___0) + 0)) {
#line 17395
              cell___0 = *(*(pairArray + blk___0) + k___0);
#line 17396
              (*(carray + cell___0))->cxcenter = (int )((double )(*(carray + cell___0))->cxcenter + (macspace[padside] - (double )(left___0 - maxd)));
#line 17394
              k___0 ++;
            }
#line 17390
            k___0 ++;
          }
        }
      }
    }
#line 17361
    pad___0 ++;
  }
#line 17402
  pad___0 = numcells + 1;
#line 17402
  while (pad___0 <= numcells + numterms) {
#line 17403
    padptr = *(carray + pad___0);
#line 17404
    if ((int )padptr->padside == 6) {
      goto _L___0;
    } else {
#line 17404
      if ((int )padptr->padside == 10) {
        goto _L___0;
      } else {
#line 17404
        if ((int )padptr->padside == 8) {
          _L___0: /* CIL Label */ 
#line 17406
          padside = (int )padptr->padside;
#line 17407
          rite___0 = padptr->cxcenter + (int )(padptr->tileptr)->right;
#line 17408
          left___0 = padptr->cxcenter + (int )(padptr->tileptr)->left;
#line 17409
          bot___0 = (int )((double )(padptr->cycenter + (int )(padptr->tileptr)->bottom) - (rowSep * (double )rowHeight) * 0.33);
#line 17411
          top___0 = (int )((double )(padptr->cycenter + (int )(padptr->tileptr)->top) + (rowSep * (double )rowHeight) * 0.33);
#line 17413
          findblks(bot___0, top___0, rite___0, -1);
#line 17414
          maxd = 0;
#line 17415
          k___0 = 1;
#line 17415
          while (k___0 <= *(blklist + 0)) {
#line 17416
            blk___0 = *(blklist + k___0);
#line 17417
            cell___0 = *(*(pairArray + blk___0) + *(*(pairArray + blk___0) + 0));
#line 17418
            cellptr___0 = *(carray + cell___0);
#line 17419
            if (cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right > maxd) {
#line 17420
              maxd = cellptr___0->cxcenter + (int )(cellptr___0->tileptr)->right;
            }
#line 17415
            k___0 ++;
          }
#line 17423
          k___0 = 1;
#line 17423
          while (k___0 <= *(blklist + 0)) {
#line 17424
            blk___0 = *(blklist + k___0);
#line 17425
            (blkshifts + blk___0)->srite = maxd;
#line 17426
            (blkshifts + blk___0)->sleft = (*(barray + blk___0))->bxcenter + (int )(*(barray + blk___0))->bleft;
#line 17423
            k___0 ++;
          }
#line 17429
          (*(carray + pad___0))->cxcenter = (int )((double )(*(carray + pad___0))->cxcenter + (macspace[padside] - (double )(left___0 - maxd)));
        }
      }
    }
#line 17402
    pad___0 ++;
  }
#line 17432
  maxd = 0;
#line 17433
  blk___0 = 1;
#line 17433
  while (blk___0 <= numblock) {
#line 17434
    if (*(*(pairArray + blk___0) + 0) <= 0) {
      goto __Cont;
    }
#line 17437
    cell___0 = *(*(pairArray + blk___0) + *(*(pairArray + blk___0) + 0));
#line 17438
    end = (*(carray + cell___0))->cxcenter + (int )((*(carray + cell___0))->tileptr)->right;
#line 17439
    if (end > maxd) {
#line 17440
      maxd = end;
    }
    __Cont: /* CIL Label */ 
#line 17433
    blk___0 ++;
  }
#line 17443
  pad___0 = numcells + 1;
#line 17443
  while (pad___0 <= numcells + numterms) {
#line 17444
    padptr = *(carray + pad___0);
#line 17445
    if ((int )padptr->padside == 6) {
      goto _L___1;
    } else {
#line 17445
      if ((int )padptr->padside == 10) {
        goto _L___1;
      } else {
#line 17445
        if ((int )padptr->padside == 8) {
          goto _L___1;
        } else {
#line 17445
          if ((int )padptr->padside == 14) {
            goto _L___1;
          } else {
#line 17445
            if ((int )padptr->padside == 15) {
              _L___1: /* CIL Label */ 
#line 17448
              if (padptr->cxcenter + (int )(padptr->tileptr)->right > maxd) {
#line 17449
                maxd = padptr->cxcenter + (int )(padptr->tileptr)->right;
              }
            }
          }
        }
      }
    }
#line 17443
    pad___0 ++;
  }
#line 17453
  blk___0 = 1;
#line 17453
  while (blk___0 <= numblock) {
#line 17454
    if ((blkshifts + blk___0)->sleft == -1000) {
#line 17455
      (blkshifts + blk___0)->srite = maxd;
#line 17456
      (blkshifts + blk___0)->sleft = (*(barray + blk___0))->bxcenter + (int )(*(barray + blk___0))->bleft;
    }
#line 17453
    blk___0 ++;
  }
#line 17460
  mind = 32000;
#line 17461
  pad___0 = numcells + 1;
#line 17461
  while (pad___0 <= numcells + numterms) {
#line 17462
    padptr = *(carray + pad___0);
#line 17463
    if ((int )padptr->padside == 3) {
#line 17464
      if (padptr->cxcenter + (int )(padptr->tileptr)->left < mind) {
#line 17465
        mind = padptr->cxcenter + (int )(padptr->tileptr)->left;
      }
    }
#line 17461
    pad___0 ++;
  }
#line 17469
  pad___0 = numcells + 1;
#line 17469
  while (pad___0 <= numcells + numterms) {
#line 17470
    if ((int )(*(carray + pad___0))->padside == 3) {
#line 17471
      (*(carray + pad___0))->cxcenter = (int )((double )(*(carray + pad___0))->cxcenter + (rowSep * (double )rowHeight - (double )(mind - maxd)));
    }
#line 17469
    pad___0 ++;
  }
#line 17475
  blk___0 = 1;
#line 17475
  while (blk___0 <= numblock) {
#line 17476
    fprintf(fpo, "blk:%d  sleft:%d  srite:%d\n", blk___0, (blkshifts + blk___0)->sleft,
            (blkshifts + blk___0)->srite);
#line 17475
    blk___0 ++;
  }
#line 17480
  return 0;
}
}
#line 17482 "D:/a/test/300.c"
int findblks(int bot___0 , int top___0 , int rite___0 , int direction ) 
{ int blk___0 ;

  {
#line 17486
  *(blklist + 0) = 0;
#line 17487
  blk___0 = 1;
#line 17487
  while (blk___0 <= numblock) {
#line 17488
    if ((*(barray + blk___0))->bycenter > bot___0) {
#line 17488
      if ((*(barray + blk___0))->bycenter < top___0) {
#line 17489
        if (direction == -1) {
#line 17490
          if ((*(barray + blk___0))->bxcenter + (int )(*(barray + blk___0))->bright < rite___0) {
#line 17491
            if ((blkshifts + blk___0)->sleft == -1000) {
#line 17492
              (*(blklist + 0)) ++;
#line 17492
              *(blklist + *(blklist + 0)) = blk___0;
            }
          }
        } else {
#line 17496
          if ((*(barray + blk___0))->bxcenter + (int )(*(barray + blk___0))->bleft > rite___0) {
#line 17497
            (*(blklist + 0)) ++;
#line 17497
            *(blklist + *(blklist + 0)) = blk___0;
          }
        }
      }
    }
#line 17487
    blk___0 ++;
  }
#line 17502
  return 0;
}
}
#line 17509 "D:/a/test/300.c"
int XPICK_INT(int l , int u , int c ) 
{ int d ;
  int tmp ;

  {
#line 17513
  if (c < 0) {
#line 17514
    return (- c);
  } else {
#line 17516
    while (1) {
#line 17517
      if (l < u) {
#line 17517
        tmp = Yacm_random();
#line 17517
        d = tmp % ((u - l) + 1) + l;
      } else {
#line 17517
        d = l;
      }
#line 17516
      if (! (d == c)) {
#line 17516
        break;
      }
    }
#line 17519
    return (d);
  }
}
}
