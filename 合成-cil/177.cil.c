/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 213 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int size_t;
#line 14 "/usr/include/sys/lock.h"
typedef void *_LOCK_T;
#line 15 "/usr/include/sys/_types.h"
typedef long long _off64_t;
#line 18 "/usr/include/sys/_types.h"
typedef int _ssize_t;
#line 354 "/cygdrive/d/cygwin/bin/../lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int wint_t;
#line 27 "/usr/include/sys/_types.h"
union __anonunion___value_2 {
   wint_t __wch ;
   unsigned char __wchb[4] ;
};
#line 27 "/usr/include/sys/_types.h"
struct __anonstruct__mbstate_t_1 {
   int __count ;
   union __anonunion___value_2 __value ;
};
#line 27 "/usr/include/sys/_types.h"
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
#line 37 "/usr/include/sys/_types.h"
typedef _LOCK_T _flock_t;
#line 19 "/usr/include/sys/reent.h"
typedef unsigned long __ULong;
#line 40 "/usr/include/sys/reent.h"
struct _Bigint {
   struct _Bigint *_next ;
   int _k ;
   int _maxwds ;
   int _sign ;
   int _wds ;
   __ULong _x[1] ;
};
#line 48 "/usr/include/sys/reent.h"
struct __tm {
   int __tm_sec ;
   int __tm_min ;
   int __tm_hour ;
   int __tm_mday ;
   int __tm_mon ;
   int __tm_year ;
   int __tm_wday ;
   int __tm_yday ;
   int __tm_isdst ;
};
#line 67 "/usr/include/sys/reent.h"
struct _on_exit_args {
   void *_fnargs[32] ;
   void *_dso_handle[32] ;
   __ULong _fntypes ;
   __ULong _is_cxa ;
};
#line 85 "/usr/include/sys/reent.h"
struct _atexit {
   struct _atexit *_next ;
   int _ind ;
   void (*_fns[32])(void) ;
   struct _on_exit_args _on_exit_args ;
};
#line 101 "/usr/include/sys/reent.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 111 "/usr/include/sys/reent.h"
typedef long _fpos_t;
#line 115 "/usr/include/sys/reent.h"
typedef _off64_t _fpos64_t;
#line 166
struct _reent;
#line 214 "/usr/include/sys/reent.h"
struct __sFILE64 {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   struct _reent *_data ;
   void *_cookie ;
   _ssize_t ( __attribute__((__cdecl__)) (*_read))(void *_cookie , char *_buf , int _n ) ;
   _ssize_t ( __attribute__((__cdecl__)) (*_write))(void *_cookie , char const   *_buf ,
                                                    int _n ) ;
   _fpos_t ( __attribute__((__cdecl__)) (*_seek))(void *_cookie , _fpos_t _offset ,
                                                  int _whence ) ;
   int ( __attribute__((__cdecl__)) (*_close))(void *_cookie ) ;
   struct __sbuf _ub ;
   unsigned char *_up ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   int _flags2 ;
   _off64_t _offset ;
   _fpos64_t ( __attribute__((__cdecl__)) (*_seek64))(void *_cookie , _fpos64_t _offset ,
                                                      int _whence ) ;
   _flock_t _lock ;
};
#line 257 "/usr/include/sys/reent.h"
typedef struct __sFILE64 __FILE;
#line 262 "/usr/include/sys/reent.h"
struct _glue {
   struct _glue *_next ;
   int _niobs ;
   __FILE *_iobs ;
};
#line 290 "/usr/include/sys/reent.h"
struct _rand48 {
   unsigned short _seed[3] ;
   unsigned short _mult[3] ;
   unsigned short _add ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__reent_4 {
   unsigned int _unused_rand ;
   char *_strtok_last ;
   char _asctime_buf[26] ;
   struct __tm _localtime_buf ;
   int _gamma_signgam ;
   unsigned long long _rand_next ;
   struct _rand48 _r48 ;
   _mbstate_t _mblen_state ;
   _mbstate_t _mbtowc_state ;
   _mbstate_t _wctomb_state ;
   char _l64a_buf[8] ;
   char _signal_buf[24] ;
   int _getdate_err ;
   _mbstate_t _mbrlen_state ;
   _mbstate_t _mbrtowc_state ;
   _mbstate_t _mbsrtowcs_state ;
   _mbstate_t _wcrtomb_state ;
   _mbstate_t _wcsrtombs_state ;
};
#line 565 "/usr/include/sys/reent.h"
struct __anonstruct__unused_5 {
   unsigned char *_nextf[30] ;
   unsigned int _nmalloc[30] ;
};
#line 565 "/usr/include/sys/reent.h"
union __anonunion__new_3 {
   struct __anonstruct__reent_4 _reent ;
   struct __anonstruct__unused_5 _unused ;
};
#line 565 "/usr/include/sys/reent.h"
struct _reent {
   int _errno ;
   __FILE *_stdin ;
   __FILE *_stdout ;
   __FILE *_stderr ;
   int _inc ;
   char _emergency[25] ;
   int _current_category ;
   char const   *_current_locale ;
   int __sdidinit ;
   void ( __attribute__((__cdecl__)) (*__cleanup))(struct _reent * ) ;
   struct _Bigint *_result ;
   int _result_k ;
   struct _Bigint *_p5s ;
   struct _Bigint **_freelist ;
   int _cvtlen ;
   char *_cvtbuf ;
   union __anonunion__new_3 _new ;
   struct _atexit *_atexit ;
   struct _atexit _atexit0 ;
   void (**_sig_func)(int  ) ;
   struct _glue __sglue ;
   __FILE __sf[3] ;
};
#line 50 "/usr/include/stdio.h"
typedef __FILE FILE;
#line 44 "/usr/include/cygwin/signal.h"
#pragma pack(push,4)
#line 101
#pragma pack(pop)
#line 15 "/usr/include/signal.h"
struct _reent;
#line 741 "D:/a/test/177.c"
typedef int GLenum;
#line 744 "D:/a/test/177.c"
typedef unsigned int GLbitfield;
#line 745 "D:/a/test/177.c"
typedef void GLvoid;
#line 746 "D:/a/test/177.c"
typedef unsigned char GLboolean;
#line 747 "D:/a/test/177.c"
typedef signed char GLbyte;
#line 748 "D:/a/test/177.c"
typedef short GLshort;
#line 749 "D:/a/test/177.c"
typedef int GLint;
#line 750 "D:/a/test/177.c"
typedef unsigned char GLubyte;
#line 751 "D:/a/test/177.c"
typedef unsigned short GLushort;
#line 752 "D:/a/test/177.c"
typedef unsigned int GLuint;
#line 753 "D:/a/test/177.c"
typedef int GLsizei;
#line 755 "D:/a/test/177.c"
typedef float GLclampf;
#line 756 "D:/a/test/177.c"
typedef double GLdouble;
#line 757 "D:/a/test/177.c"
typedef double GLclampd;
#line 758
struct gl_visual;
#line 758 "D:/a/test/177.c"
typedef struct gl_visual GLvisual;
#line 759
struct gl_context;
#line 759 "D:/a/test/177.c"
typedef struct gl_context GLcontext;
#line 760
struct gl_frame_buffer;
#line 760 "D:/a/test/177.c"
typedef struct gl_frame_buffer GLframebuffer;
#line 761 "D:/a/test/177.c"
struct osmesa_context {
   GLcontext *gl_ctx ;
   GLvisual *gl_visual ;
   GLframebuffer *gl_buffer ;
   GLenum format ;
   void *buffer ;
   GLint width ;
   GLint height ;
   GLuint pixel ;
   GLuint clearpixel ;
   GLint rowlength ;
   GLint userRowLength ;
   GLint rshift ;
   GLint gshift ;
   GLint bshift ;
   GLint ashift ;
   GLint rind ;
   GLint gind ;
   GLint bind ;
   void *rowaddr[400] ;
   GLboolean yup ;
};
#line 778 "D:/a/test/177.c"
typedef struct osmesa_context *OSMesaContext;
#line 781 "D:/a/test/177.c"
typedef void (*line_func)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv );
#line 782 "D:/a/test/177.c"
typedef void (*triangle_func)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 ,
                              GLuint pv );
#line 788
struct gl_texture_object;
#line 788
struct gl_texture_object;
#line 795 "D:/a/test/177.c"
struct gl_image {
   GLint Width ;
   GLint Height ;
   GLint Depth ;
   GLint Components ;
   GLenum Format ;
   GLenum Type ;
   GLvoid *Data ;
   GLboolean Interleaved ;
   GLint RefCount ;
};
#line 806 "D:/a/test/177.c"
struct gl_texture_image {
   GLenum Format ;
   GLenum IntFormat ;
   GLuint Border ;
   GLuint Width ;
   GLuint Height ;
   GLuint Depth ;
   GLuint Width2 ;
   GLuint Height2 ;
   GLuint Depth2 ;
   GLuint WidthLog2 ;
   GLuint HeightLog2 ;
   GLuint DepthLog2 ;
   GLuint MaxLog2 ;
   GLubyte *Data ;
   void *DriverData ;
};
#line 824 "D:/a/test/177.c"
typedef GLbyte GLaccum;
#line 825 "D:/a/test/177.c"
typedef GLubyte GLstencil;
#line 826 "D:/a/test/177.c"
typedef GLushort GLdepth;
#line 1219 "D:/a/test/177.c"
struct gl_light {
   float Ambient[4] ;
   float Diffuse[4] ;
   float Specular[4] ;
   float Position[4] ;
   float Direction[4] ;
   float SpotExponent ;
   float SpotCutoff ;
   float CosCutoff ;
   float ConstantAttenuation ;
   float LinearAttenuation ;
   float QuadraticAttenuation ;
   GLboolean Enabled ;
   struct gl_light *NextEnabled ;
   float VP_inf_norm[3] ;
   float h_inf_norm[3] ;
   float NormDirection[3] ;
   float SpotExpTable[512][2] ;
   float MatAmbient[2][3] ;
   float MatDiffuse[2][3] ;
   float MatSpecular[2][3] ;
   float dli ;
   float sli ;
};
#line 1244 "D:/a/test/177.c"
struct gl_lightmodel {
   float Ambient[4] ;
   GLboolean LocalViewer ;
   GLboolean TwoSide ;
};
#line 1249 "D:/a/test/177.c"
struct gl_material {
   float Ambient[4] ;
   float Diffuse[4] ;
   float Specular[4] ;
   float Emission[4] ;
   float Shininess ;
   float AmbientIndex ;
   float DiffuseIndex ;
   float SpecularIndex ;
   float ShineTable[200] ;
};
#line 1260 "D:/a/test/177.c"
struct gl_accum_attrib {
   float ClearColor[4] ;
};
#line 1263 "D:/a/test/177.c"
struct gl_colorbuffer_attrib {
   GLuint ClearIndex ;
   float ClearColor[4] ;
   GLuint IndexMask ;
   GLuint ColorMask ;
   GLboolean SWmasking ;
   GLenum DrawBuffer ;
   GLboolean AlphaEnabled ;
   GLenum AlphaFunc ;
   float AlphaRef ;
   GLubyte AlphaRefUbyte ;
   GLboolean BlendEnabled ;
   GLenum BlendSrc ;
   GLenum BlendDst ;
   GLenum BlendEquation ;
   float BlendColor[4] ;
   GLenum LogicOp ;
   GLboolean IndexLogicOpEnabled ;
   GLboolean ColorLogicOpEnabled ;
   GLboolean SWLogicOpEnabled ;
   GLboolean DitherFlag ;
};
#line 1288 "D:/a/test/177.c"
struct gl_current_attrib {
   GLubyte ByteColor[4] ;
   GLuint Index ;
   float Normal[3] ;
   float TexCoord[4] ;
   float RasterPos[4] ;
   float RasterDistance ;
   float RasterColor[4] ;
   GLuint RasterIndex ;
   float RasterTexCoord[4] ;
   GLboolean RasterPosValid ;
   GLboolean EdgeFlag ;
};
#line 1301 "D:/a/test/177.c"
struct gl_depthbuffer_attrib {
   GLenum Func ;
   float Clear ;
   GLboolean Test ;
   GLboolean Mask ;
};
#line 1307 "D:/a/test/177.c"
struct gl_enable_attrib {
   GLboolean AlphaTest ;
   GLboolean AutoNormal ;
   GLboolean Blend ;
   GLboolean ClipPlane[6] ;
   GLboolean ColorMaterial ;
   GLboolean CullFace ;
   GLboolean DepthTest ;
   GLboolean Dither ;
   GLboolean Fog ;
   GLboolean Light[8] ;
   GLboolean Lighting ;
   GLboolean LineSmooth ;
   GLboolean LineStipple ;
   GLboolean IndexLogicOp ;
   GLboolean ColorLogicOp ;
   GLboolean Map1Color4 ;
   GLboolean Map1Index ;
   GLboolean Map1Normal ;
   GLboolean Map1TextureCoord1 ;
   GLboolean Map1TextureCoord2 ;
   GLboolean Map1TextureCoord3 ;
   GLboolean Map1TextureCoord4 ;
   GLboolean Map1Vertex3 ;
   GLboolean Map1Vertex4 ;
   GLboolean Map2Color4 ;
   GLboolean Map2Index ;
   GLboolean Map2Normal ;
   GLboolean Map2TextureCoord1 ;
   GLboolean Map2TextureCoord2 ;
   GLboolean Map2TextureCoord3 ;
   GLboolean Map2TextureCoord4 ;
   GLboolean Map2Vertex3 ;
   GLboolean Map2Vertex4 ;
   GLboolean Normalize ;
   GLboolean PointSmooth ;
   GLboolean PolygonOffsetPoint ;
   GLboolean PolygonOffsetLine ;
   GLboolean PolygonOffsetFill ;
   GLboolean PolygonSmooth ;
   GLboolean PolygonStipple ;
   GLboolean Scissor ;
   GLboolean Stencil ;
   GLuint Texture ;
   GLuint TexGen ;
};
#line 1353 "D:/a/test/177.c"
struct gl_eval_attrib {
   GLboolean Map1Color4 ;
   GLboolean Map1Index ;
   GLboolean Map1Normal ;
   GLboolean Map1TextureCoord1 ;
   GLboolean Map1TextureCoord2 ;
   GLboolean Map1TextureCoord3 ;
   GLboolean Map1TextureCoord4 ;
   GLboolean Map1Vertex3 ;
   GLboolean Map1Vertex4 ;
   GLboolean Map2Color4 ;
   GLboolean Map2Index ;
   GLboolean Map2Normal ;
   GLboolean Map2TextureCoord1 ;
   GLboolean Map2TextureCoord2 ;
   GLboolean Map2TextureCoord3 ;
   GLboolean Map2TextureCoord4 ;
   GLboolean Map2Vertex3 ;
   GLboolean Map2Vertex4 ;
   GLboolean AutoNormal ;
   GLuint MapGrid1un ;
   float MapGrid1u1 ;
   float MapGrid1u2 ;
   GLuint MapGrid2un ;
   GLuint MapGrid2vn ;
   float MapGrid2u1 ;
   float MapGrid2u2 ;
   float MapGrid2v1 ;
   float MapGrid2v2 ;
};
#line 1381 "D:/a/test/177.c"
struct gl_fog_attrib {
   GLboolean Enabled ;
   float Color[4] ;
   float Density ;
   float Start ;
   float End ;
   float Index ;
   GLenum Mode ;
};
#line 1390 "D:/a/test/177.c"
struct gl_hint_attrib {
   GLenum PerspectiveCorrection ;
   GLenum PointSmooth ;
   GLenum LineSmooth ;
   GLenum PolygonSmooth ;
   GLenum Fog ;
};
#line 1398 "D:/a/test/177.c"
struct gl_light_attrib {
   struct gl_light Light[8] ;
   struct gl_lightmodel Model ;
   struct gl_material Material[2] ;
   GLboolean Enabled ;
   GLenum ShadeModel ;
   GLenum ColorMaterialFace ;
   GLenum ColorMaterialMode ;
   GLuint ColorMaterialBitmask ;
   GLboolean ColorMaterialEnabled ;
   struct gl_light *FirstEnabled ;
   GLboolean Fast ;
   float BaseColor[2][4] ;
};
#line 1412 "D:/a/test/177.c"
struct gl_line_attrib {
   GLboolean SmoothFlag ;
   GLboolean StippleFlag ;
   GLushort StipplePattern ;
   GLint StippleFactor ;
   float Width ;
};
#line 1419 "D:/a/test/177.c"
struct gl_list_attrib {
   GLuint ListBase ;
};
#line 1422 "D:/a/test/177.c"
struct gl_pixel_attrib {
   GLenum ReadBuffer ;
   float RedBias ;
   float RedScale ;
   float GreenBias ;
   float GreenScale ;
   float BlueBias ;
   float BlueScale ;
   float AlphaBias ;
   float AlphaScale ;
   float DepthBias ;
   float DepthScale ;
   GLint IndexShift ;
   GLint IndexOffset ;
   GLboolean MapColorFlag ;
   GLboolean MapStencilFlag ;
   float ZoomX ;
   float ZoomY ;
   GLint MapStoSsize ;
   GLint MapItoIsize ;
   GLint MapItoRsize ;
   GLint MapItoGsize ;
   GLint MapItoBsize ;
   GLint MapItoAsize ;
   GLint MapRtoRsize ;
   GLint MapGtoGsize ;
   GLint MapBtoBsize ;
   GLint MapAtoAsize ;
   GLint MapStoS[256] ;
   GLint MapItoI[256] ;
   float MapItoR[256] ;
   float MapItoG[256] ;
   float MapItoB[256] ;
   float MapItoA[256] ;
   float MapRtoR[256] ;
   float MapGtoG[256] ;
   float MapBtoB[256] ;
   float MapAtoA[256] ;
};
#line 1457 "D:/a/test/177.c"
struct gl_point_attrib {
   GLboolean SmoothFlag ;
   float Size ;
   float Params[3] ;
   float MinSize ;
   float MaxSize ;
   float Threshold ;
};
#line 1465 "D:/a/test/177.c"
struct gl_polygon_attrib {
   GLenum FrontFace ;
   GLenum FrontMode ;
   GLenum BackMode ;
   GLboolean Unfilled ;
   GLboolean CullFlag ;
   GLenum CullFaceMode ;
   GLuint CullBits ;
   GLboolean SmoothFlag ;
   GLboolean StippleFlag ;
   float OffsetFactor ;
   float OffsetUnits ;
   GLboolean OffsetPoint ;
   GLboolean OffsetLine ;
   GLboolean OffsetFill ;
   GLboolean OffsetAny ;
};
#line 1482 "D:/a/test/177.c"
struct gl_scissor_attrib {
   GLboolean Enabled ;
   GLint X ;
   GLint Y ;
   GLsizei Width ;
   GLsizei Height ;
};
#line 1487 "D:/a/test/177.c"
struct gl_stencil_attrib {
   GLboolean Enabled ;
   GLenum Function ;
   GLenum FailFunc ;
   GLenum ZPassFunc ;
   GLenum ZFailFunc ;
   GLstencil Ref ;
   GLstencil ValueMask ;
   GLstencil Clear ;
   GLstencil WriteMask ;
};
#line 1505 "D:/a/test/177.c"
struct gl_texture_attrib {
   GLuint Enabled ;
   GLenum EnvMode ;
   float EnvColor[4] ;
   GLuint TexGenEnabled ;
   GLenum GenModeS ;
   GLenum GenModeT ;
   GLenum GenModeR ;
   GLenum GenModeQ ;
   float ObjectPlaneS[4] ;
   float ObjectPlaneT[4] ;
   float ObjectPlaneR[4] ;
   float ObjectPlaneQ[4] ;
   float EyePlaneS[4] ;
   float EyePlaneT[4] ;
   float EyePlaneR[4] ;
   float EyePlaneQ[4] ;
   struct gl_texture_object *Current1D ;
   struct gl_texture_object *Current2D ;
   struct gl_texture_object *Current3D ;
   struct gl_texture_object *Current ;
   struct gl_texture_object *Proxy1D ;
   struct gl_texture_object *Proxy2D ;
   struct gl_texture_object *Proxy3D ;
   GLboolean SharedPalette ;
   GLubyte Palette[1024] ;
   GLuint PaletteSize ;
   GLenum PaletteIntFormat ;
   GLenum PaletteFormat ;
};
#line 1538 "D:/a/test/177.c"
struct gl_transform_attrib {
   GLenum MatrixMode ;
   float ClipEquation[6][4] ;
   GLboolean ClipEnabled[6] ;
   GLboolean AnyClip ;
   GLboolean Normalize ;
};
#line 1545 "D:/a/test/177.c"
struct gl_viewport_attrib {
   GLint X ;
   GLint Y ;
   GLsizei Width ;
   GLsizei Height ;
   float Near ;
   float Far ;
   float Sx ;
   float Sy ;
   float Sz ;
   float Tx ;
   float Ty ;
   float Tz ;
};
#line 1552 "D:/a/test/177.c"
struct gl_attrib_node {
   GLbitfield kind ;
   void *data ;
   struct gl_attrib_node *next ;
};
#line 1557 "D:/a/test/177.c"
struct gl_pixelstore_attrib {
   GLint Alignment ;
   GLint RowLength ;
   GLint SkipPixels ;
   GLint SkipRows ;
   GLint ImageHeight ;
   GLint SkipImages ;
   GLboolean SwapBytes ;
   GLboolean LsbFirst ;
};
#line 1567 "D:/a/test/177.c"
struct gl_array_attrib {
   GLint VertexSize ;
   GLenum VertexType ;
   GLsizei VertexStride ;
   GLsizei VertexStrideB ;
   void *VertexPtr ;
   GLboolean VertexEnabled ;
   GLenum NormalType ;
   GLsizei NormalStride ;
   GLsizei NormalStrideB ;
   void *NormalPtr ;
   GLboolean NormalEnabled ;
   GLint ColorSize ;
   GLenum ColorType ;
   GLsizei ColorStride ;
   GLsizei ColorStrideB ;
   void *ColorPtr ;
   GLboolean ColorEnabled ;
   GLenum IndexType ;
   GLsizei IndexStride ;
   GLsizei IndexStrideB ;
   void *IndexPtr ;
   GLboolean IndexEnabled ;
   GLint TexCoordSize ;
   GLenum TexCoordType ;
   GLsizei TexCoordStride ;
   GLsizei TexCoordStrideB ;
   void *TexCoordPtr ;
   GLboolean TexCoordEnabled ;
   GLsizei EdgeFlagStride ;
   GLsizei EdgeFlagStrideB ;
   GLboolean *EdgeFlagPtr ;
   GLboolean EdgeFlagEnabled ;
};
#line 1601 "D:/a/test/177.c"
struct gl_feedback {
   GLenum Type ;
   GLuint Mask ;
   float *Buffer ;
   GLuint BufferSize ;
   GLuint Count ;
};
#line 1608 "D:/a/test/177.c"
struct gl_selection {
   GLuint *Buffer ;
   GLuint BufferSize ;
   GLuint BufferCount ;
   GLuint Hits ;
   GLuint NameStackDepth ;
   GLuint NameStack[64] ;
   GLboolean HitFlag ;
   float HitMinZ ;
   float HitMaxZ ;
};
#line 1618 "D:/a/test/177.c"
struct gl_1d_map {
   GLuint Order ;
   float u1 ;
   float u2 ;
   float *Points ;
   GLboolean Retain ;
};
#line 1625 "D:/a/test/177.c"
struct gl_2d_map {
   GLuint Uorder ;
   GLuint Vorder ;
   float u1 ;
   float u2 ;
   float v1 ;
   float v2 ;
   float *Points ;
   GLboolean Retain ;
};
#line 1633 "D:/a/test/177.c"
struct gl_evaluators {
   struct gl_1d_map Map1Vertex3 ;
   struct gl_1d_map Map1Vertex4 ;
   struct gl_1d_map Map1Index ;
   struct gl_1d_map Map1Color4 ;
   struct gl_1d_map Map1Normal ;
   struct gl_1d_map Map1Texture1 ;
   struct gl_1d_map Map1Texture2 ;
   struct gl_1d_map Map1Texture3 ;
   struct gl_1d_map Map1Texture4 ;
   struct gl_2d_map Map2Vertex3 ;
   struct gl_2d_map Map2Vertex4 ;
   struct gl_2d_map Map2Index ;
   struct gl_2d_map Map2Color4 ;
   struct gl_2d_map Map2Normal ;
   struct gl_2d_map Map2Texture1 ;
   struct gl_2d_map Map2Texture2 ;
   struct gl_2d_map Map2Texture3 ;
   struct gl_2d_map Map2Texture4 ;
};
#line 1655 "D:/a/test/177.c"
struct gl_texture_object {
   GLint RefCount ;
   GLuint Name ;
   GLuint Dimensions ;
   float Priority ;
   GLint BorderColor[4] ;
   GLenum WrapS ;
   GLenum WrapT ;
   GLenum WrapR ;
   GLenum MinFilter ;
   GLenum MagFilter ;
   float MinMagThresh ;
   struct gl_texture_image *Image[11] ;
   GLubyte Palette[1024] ;
   GLuint PaletteSize ;
   GLenum PaletteIntFormat ;
   GLenum PaletteFormat ;
   GLboolean Dirty ;
   void *DriverData ;
   GLboolean Complete ;
   void (*SampleFunc)(struct gl_texture_object  const  *tObj , GLuint n , float const   *s ,
                      float const   *t , float const   *u , float const   *lambda ,
                      GLubyte *r , GLubyte *g , GLubyte *b , GLubyte *a ) ;
   struct gl_texture_object *Next ;
};
#line 1680
struct HashTable;
#line 1680 "D:/a/test/177.c"
struct gl_shared_state {
   GLint RefCount ;
   struct HashTable *DisplayList ;
   struct HashTable *TexObjects ;
   struct gl_texture_object *TexObjectList ;
   struct gl_texture_object *Default1D ;
   struct gl_texture_object *Default2D ;
   struct gl_texture_object *Default3D ;
};
#line 1689 "D:/a/test/177.c"
struct gl_visual {
   GLboolean RGBAflag ;
   GLboolean DBflag ;
   float RedScale ;
   float GreenScale ;
   float BlueScale ;
   float AlphaScale ;
   GLboolean EightBitColor ;
   float InvRedScale ;
   float InvGreenScale ;
   float InvBlueScale ;
   float InvAlphaScale ;
   GLint RedBits ;
   GLint GreenBits ;
   GLint BlueBits ;
   GLint AlphaBits ;
   GLint IndexBits ;
   GLint AccumBits ;
   GLint DepthBits ;
   GLint StencilBits ;
   GLboolean FrontAlphaEnabled ;
   GLboolean BackAlphaEnabled ;
};
#line 1715 "D:/a/test/177.c"
struct gl_frame_buffer {
   GLvisual *Visual ;
   GLint Width ;
   GLint Height ;
   GLdepth *Depth ;
   GLstencil *Stencil ;
   GLaccum *Accum ;
   GLubyte *FrontAlpha ;
   GLubyte *BackAlpha ;
   GLubyte *Alpha ;
   GLint Xmin ;
   GLint Xmax ;
   GLint Ymin ;
   GLint Ymax ;
};
#line 1734 "D:/a/test/177.c"
struct dd_function_table {
   char const   *(*RendererString)(void) ;
   void (*UpdateState)(GLcontext *ctx ) ;
   void (*ClearIndex)(GLcontext *ctx , GLuint index ) ;
   void (*ClearColor)(GLcontext *ctx , GLubyte red , GLubyte green , GLubyte blue ,
                      GLubyte alpha ) ;
   void (*Clear)(GLcontext *ctx , GLboolean all , GLint x , GLint y , GLint width ,
                 GLint height ) ;
   void (*Index)(GLcontext *ctx , GLuint index ) ;
   void (*Color)(GLcontext *ctx , GLubyte red , GLubyte green , GLubyte glue , GLubyte alpha ) ;
   GLboolean (*SetBuffer)(GLcontext *ctx , GLenum mode ) ;
   void (*GetBufferSize)(GLcontext *ctx , GLuint *width , GLuint *height ) ;
   void (*WriteColorSpan)(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte const   *red ,
                          GLubyte const   *green , GLubyte const   *blue , GLubyte const   *alpha ,
                          GLubyte const   *mask ) ;
   void (*WriteMonocolorSpan)(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte const   *mask ) ;
   void (*WriteColorPixels)(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                            GLubyte const   *red , GLubyte const   *green , GLubyte const   *blue ,
                            GLubyte const   *alpha , GLubyte const   *mask ) ;
   void (*WriteMonocolorPixels)(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                                GLubyte const   *mask ) ;
   void (*WriteIndexSpan)(GLcontext *ctx , GLuint n , GLint x , GLint y , GLuint const   *index ,
                          GLubyte const   *mask ) ;
   void (*WriteMonoindexSpan)(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte const   *mask ) ;
   void (*WriteIndexPixels)(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                            GLuint const   *index , GLubyte const   *mask ) ;
   void (*WriteMonoindexPixels)(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                                GLubyte const   *mask ) ;
   void (*ReadIndexSpan)(GLcontext *ctx , GLuint n , GLint x , GLint y , GLuint *index ) ;
   void (*ReadColorSpan)(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *red ,
                         GLubyte *green , GLubyte *blue , GLubyte *alpha ) ;
   void (*ReadIndexPixels)(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                           GLuint *indx , GLubyte const   *mask ) ;
   void (*ReadColorPixels)(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                           GLubyte *red , GLubyte *green , GLubyte *blue , GLubyte *alpha ,
                           GLubyte const   *mask ) ;
   void (*Finish)(GLcontext *ctx ) ;
   void (*Flush)(GLcontext *ctx ) ;
   GLboolean (*IndexMask)(GLcontext *ctx , GLuint mask ) ;
   GLboolean (*ColorMask)(GLcontext *ctx , GLboolean rmask , GLboolean gmask , GLboolean bmask ,
                          GLboolean amask ) ;
   GLboolean (*LogicOp)(GLcontext *ctx , GLenum op ) ;
   void (*Dither)(GLcontext *ctx , GLboolean enable ) ;
   void (*Error)(GLcontext *ctx ) ;
   void (*NearFar)(GLcontext *ctx , float nearVal , float farVal ) ;
   void (*AllocDepthBuffer)(GLcontext *ctx ) ;
   void (*ClearDepthBuffer)(GLcontext *ctx ) ;
   GLuint (*DepthTestSpan)(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth const   *z ,
                           GLubyte *mask ) ;
   void (*DepthTestPixels)(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                           GLdepth const   *z , GLubyte *mask ) ;
   void (*ReadDepthSpanFloat)(GLcontext *ctx , GLuint n , GLint x , GLint y , float *depth ) ;
   void (*ReadDepthSpanInt)(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth *depth ) ;
   void (*PointsFunc)(GLcontext *ctx , GLuint first , GLuint last ) ;
   void (*LineFunc)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ) ;
   void (*TriangleFunc)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 , GLuint pv ) ;
   void (*QuadFunc)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 , GLuint v4 ,
                    GLuint pv ) ;
   void (*RectFunc)(GLcontext *ctx , GLint x , GLint y , GLint width , GLint height ) ;
   GLboolean (*DrawPixels)(GLcontext *ctx , GLint x , GLint y , GLsizei width , GLsizei height ,
                           GLenum format , GLenum type , GLboolean packed , GLvoid const   *pixels ) ;
   GLboolean (*Bitmap)(GLcontext *ctx , GLsizei width , GLsizei height , float xorig ,
                       float yorig , float xmove , float ymove , struct gl_image  const  *bitmap ) ;
   void (*Begin)(GLcontext *ctx , GLenum mode ) ;
   void (*End)(GLcontext *ctx ) ;
   void (*RasterSetup)(GLcontext *ctx , GLuint start , GLuint end ) ;
   GLboolean (*RenderVB)(GLcontext *ctx , GLboolean allDone ) ;
   void (*TexEnv)(GLcontext *ctx , GLenum pname , float const   *param ) ;
   void (*TexImage)(GLcontext *ctx , GLenum target , struct gl_texture_object *tObj ,
                    GLint level , GLint internalFormat , struct gl_texture_image  const  *image ) ;
   void (*TexParameter)(GLcontext *ctx , GLenum target , struct gl_texture_object *tObj ,
                        GLenum pname , float const   *params ) ;
   void (*BindTexture)(GLcontext *ctx , GLenum target , struct gl_texture_object *tObj ) ;
   void (*DeleteTexture)(GLcontext *ctx , struct gl_texture_object *tObj ) ;
   void (*UpdateTexturePalette)(GLcontext *ctx , struct gl_texture_object *tObj ) ;
   void (*UseGlobalTexturePalette)(GLcontext *ctx , GLboolean state ) ;
};
#line 1844 "D:/a/test/177.c"
struct gl_api_table {
   void (*Accum)(GLcontext * , GLenum  , float  ) ;
   void (*AlphaFunc)(GLcontext * , GLenum  , GLclampf  ) ;
   GLboolean (*AreTexturesResident)(GLcontext * , GLsizei  , GLuint const   * , GLboolean * ) ;
   void (*ArrayElement)(GLcontext * , GLint  ) ;
   void (*Begin)(GLcontext * , GLenum  ) ;
   void (*BindTexture)(GLcontext * , GLenum  , GLuint  ) ;
   void (*Bitmap)(GLcontext * , GLsizei  , GLsizei  , float  , float  , float  , float  ,
                  struct gl_image  const  *bitmap ) ;
   void (*BlendColor)(GLcontext * , GLclampf  , GLclampf  , GLclampf  , GLclampf  ) ;
   void (*BlendEquation)(GLcontext * , GLenum  ) ;
   void (*BlendFunc)(GLcontext * , GLenum  , GLenum  ) ;
   void (*CallList)(GLcontext * , GLuint list ) ;
   void (*CallLists)(GLcontext * , GLsizei  , GLenum  , GLvoid const   * ) ;
   void (*Clear)(GLcontext * , GLbitfield  ) ;
   void (*ClearAccum)(GLcontext * , float  , float  , float  , float  ) ;
   void (*ClearColor)(GLcontext * , GLclampf  , GLclampf  , GLclampf  , GLclampf  ) ;
   void (*ClearDepth)(GLcontext * , GLclampd  ) ;
   void (*ClearIndex)(GLcontext * , float  ) ;
   void (*ClearStencil)(GLcontext * , GLint  ) ;
   void (*ClipPlane)(GLcontext * , GLenum  , float const   * ) ;
   void (*Color3f)(GLcontext * , float  , float  , float  ) ;
   void (*Color3fv)(GLcontext * , float const   * ) ;
   void (*Color4f)(GLcontext * , float  , float  , float  , float  ) ;
   void (*Color4fv)(GLcontext * , float const   * ) ;
   void (*Color4ub)(GLcontext * , GLubyte  , GLubyte  , GLubyte  , GLubyte  ) ;
   void (*Color4ubv)(GLcontext * , GLubyte const   * ) ;
   void (*ColorMask)(GLcontext * , GLboolean  , GLboolean  , GLboolean  , GLboolean  ) ;
   void (*ColorMaterial)(GLcontext * , GLenum  , GLenum  ) ;
   void (*ColorPointer)(GLcontext * , GLint  , GLenum  , GLsizei  , GLvoid const   * ) ;
   void (*ColorTable)(GLcontext * , GLenum  , GLenum  , struct gl_image * ) ;
   void (*ColorSubTable)(GLcontext * , GLenum  , GLsizei  , struct gl_image * ) ;
   void (*CopyPixels)(GLcontext * , GLint  , GLint  , GLsizei  , GLsizei  , GLenum  ) ;
   void (*CopyTexImage1D)(GLcontext * , GLenum  , GLint  , GLenum  , GLint  , GLint  ,
                          GLsizei  , GLint  ) ;
   void (*CopyTexImage2D)(GLcontext * , GLenum  , GLint  , GLenum  , GLint  , GLint  ,
                          GLsizei  , GLsizei  , GLint  ) ;
   void (*CopyTexSubImage1D)(GLcontext * , GLenum  , GLint  , GLint  , GLint  , GLint  ,
                             GLsizei  ) ;
   void (*CopyTexSubImage2D)(GLcontext * , GLenum  , GLint  , GLint  , GLint  , GLint  ,
                             GLint  , GLsizei  , GLsizei  ) ;
   void (*CopyTexSubImage3DEXT)(GLcontext * , GLenum  , GLint  , GLint  , GLint  ,
                                GLint  , GLint  , GLint  , GLsizei  , GLsizei  ) ;
   void (*CullFace)(GLcontext * , GLenum  ) ;
   void (*DeleteLists)(GLcontext * , GLuint  , GLsizei  ) ;
   void (*DeleteTextures)(GLcontext * , GLsizei  , GLuint const   * ) ;
   void (*DepthFunc)(GLcontext * , GLenum  ) ;
   void (*DepthMask)(GLcontext * , GLboolean  ) ;
   void (*DepthRange)(GLcontext * , GLclampd  , GLclampd  ) ;
   void (*Disable)(GLcontext * , GLenum  ) ;
   void (*DisableClientState)(GLcontext * , GLenum  ) ;
   void (*DrawArrays)(GLcontext * , GLenum  , GLint  , GLsizei  ) ;
   void (*DrawBuffer)(GLcontext * , GLenum  ) ;
   void (*DrawElements)(GLcontext * , GLenum  , GLsizei  , GLenum  , GLvoid const   * ) ;
   void (*DrawPixels)(GLcontext * , GLsizei  , GLsizei  , GLenum  , GLenum  , GLvoid const   * ) ;
   void (*EdgeFlag)(GLcontext * , GLboolean  ) ;
   void (*EdgeFlagPointer)(GLcontext * , GLsizei  , GLboolean const   * ) ;
   void (*Enable)(GLcontext * , GLenum  ) ;
   void (*EnableClientState)(GLcontext * , GLenum  ) ;
   void (*End)(GLcontext * ) ;
   void (*EndList)(GLcontext * ) ;
   void (*EvalCoord1f)(GLcontext * , float  ) ;
   void (*EvalCoord2f)(GLcontext * , float  , float  ) ;
   void (*EvalMesh1)(GLcontext * , GLenum  , GLint  , GLint  ) ;
   void (*EvalMesh2)(GLcontext * , GLenum  , GLint  , GLint  , GLint  , GLint  ) ;
   void (*EvalPoint1)(GLcontext * , GLint  ) ;
   void (*EvalPoint2)(GLcontext * , GLint  , GLint  ) ;
   void (*FeedbackBuffer)(GLcontext * , GLsizei  , GLenum  , float * ) ;
   void (*Finish)(GLcontext * ) ;
   void (*Flush)(GLcontext * ) ;
   void (*Fogfv)(GLcontext * , GLenum  , float const   * ) ;
   void (*FrontFace)(GLcontext * , GLenum  ) ;
   void (*Frustum)(GLcontext * , GLdouble  , GLdouble  , GLdouble  , GLdouble  , GLdouble  ,
                   GLdouble  ) ;
   GLuint (*GenLists)(GLcontext * , GLsizei  ) ;
   void (*GenTextures)(GLcontext * , GLsizei  , GLuint * ) ;
   void (*GetBooleanv)(GLcontext * , GLenum  , GLboolean * ) ;
   void (*GetClipPlane)(GLcontext * , GLenum  , GLdouble * ) ;
   void (*GetColorTable)(GLcontext * , GLenum  , GLenum  , GLenum  , GLvoid * ) ;
   void (*GetColorTableParameteriv)(GLcontext * , GLenum  , GLenum  , GLint * ) ;
   void (*GetDoublev)(GLcontext * , GLenum  , GLdouble * ) ;
   GLenum (*GetError)(GLcontext * ) ;
   void (*GetFloatv)(GLcontext * , GLenum  , float * ) ;
   void (*GetIntegerv)(GLcontext * , GLenum  , GLint * ) ;
   GLubyte const   *(*GetString)(GLcontext * , GLenum name ) ;
   void (*GetLightfv)(GLcontext * , GLenum light , GLenum  , float * ) ;
   void (*GetLightiv)(GLcontext * , GLenum light , GLenum  , GLint * ) ;
   void (*GetMapdv)(GLcontext * , GLenum  , GLenum  , GLdouble * ) ;
   void (*GetMapfv)(GLcontext * , GLenum  , GLenum  , float * ) ;
   void (*GetMapiv)(GLcontext * , GLenum  , GLenum  , GLint * ) ;
   void (*GetMaterialfv)(GLcontext * , GLenum  , GLenum  , float * ) ;
   void (*GetMaterialiv)(GLcontext * , GLenum  , GLenum  , GLint * ) ;
   void (*GetPixelMapfv)(GLcontext * , GLenum  , float * ) ;
   void (*GetPixelMapuiv)(GLcontext * , GLenum  , GLuint * ) ;
   void (*GetPixelMapusv)(GLcontext * , GLenum  , GLushort * ) ;
   void (*GetPointerv)(GLcontext * , GLenum  , GLvoid ** ) ;
   void (*GetPolygonStipple)(GLcontext * , GLubyte * ) ;
   void (*PrioritizeTextures)(GLcontext * , GLsizei  , GLuint const   * , GLclampf const   * ) ;
   void (*GetTexEnvfv)(GLcontext * , GLenum  , GLenum  , float * ) ;
   void (*GetTexEnviv)(GLcontext * , GLenum  , GLenum  , GLint * ) ;
   void (*GetTexGendv)(GLcontext * , GLenum coord , GLenum  , GLdouble * ) ;
   void (*GetTexGenfv)(GLcontext * , GLenum coord , GLenum  , float * ) ;
   void (*GetTexGeniv)(GLcontext * , GLenum coord , GLenum  , GLint * ) ;
   void (*GetTexImage)(GLcontext * , GLenum  , GLint level , GLenum  , GLenum  , GLvoid * ) ;
   void (*GetTexLevelParameterfv)(GLcontext * , GLenum  , GLint  , GLenum  , float * ) ;
   void (*GetTexLevelParameteriv)(GLcontext * , GLenum  , GLint  , GLenum  , GLint * ) ;
   void (*GetTexParameterfv)(GLcontext * , GLenum  , GLenum  , float * ) ;
   void (*GetTexParameteriv)(GLcontext * , GLenum  , GLenum  , GLint * ) ;
   void (*Hint)(GLcontext * , GLenum  , GLenum  ) ;
   void (*IndexMask)(GLcontext * , GLuint  ) ;
   void (*Indexf)(GLcontext * , float c ) ;
   void (*Indexi)(GLcontext * , GLint c ) ;
   void (*IndexPointer)(GLcontext * , GLenum  , GLsizei  , GLvoid const   * ) ;
   void (*InitNames)(GLcontext * ) ;
   void (*InterleavedArrays)(GLcontext * , GLenum  , GLsizei  , GLvoid const   * ) ;
   GLboolean (*IsEnabled)(GLcontext * , GLenum  ) ;
   GLboolean (*IsList)(GLcontext * , GLuint  ) ;
   GLboolean (*IsTexture)(GLcontext * , GLuint  ) ;
   void (*LightModelfv)(GLcontext * , GLenum  , float const   * ) ;
   void (*Lightfv)(GLcontext * , GLenum light , GLenum  , float const   * , GLint  ) ;
   void (*LineStipple)(GLcontext * , GLint factor , GLushort  ) ;
   void (*LineWidth)(GLcontext * , float  ) ;
   void (*ListBase)(GLcontext * , GLuint  ) ;
   void (*LoadIdentity)(GLcontext * ) ;
   void (*LoadMatrixf)(GLcontext * , float const   * ) ;
   void (*LoadName)(GLcontext * , GLuint  ) ;
   void (*LogicOp)(GLcontext * , GLenum  ) ;
   void (*Map1f)(GLcontext * , GLenum  , float  , float  , GLint  , GLint  , float const   * ,
                 GLboolean  ) ;
   void (*Map2f)(GLcontext * , GLenum  , float  , float  , GLint  , GLint  , float  ,
                 float  , GLint  , GLint  , float const   * , GLboolean  ) ;
   void (*MapGrid1f)(GLcontext * , GLint  , float  , float  ) ;
   void (*MapGrid2f)(GLcontext * , GLint  , float  , float  , GLint  , float  , float  ) ;
   void (*Materialfv)(GLcontext * , GLenum  , GLenum  , float const   * ) ;
   void (*MatrixMode)(GLcontext * , GLenum  ) ;
   void (*MultMatrixf)(GLcontext * , float const   * ) ;
   void (*NewList)(GLcontext * , GLuint list , GLenum  ) ;
   void (*Normal3f)(GLcontext * , float  , float  , float  ) ;
   void (*Normal3fv)(GLcontext * , float const   * ) ;
   void (*NormalPointer)(GLcontext * , GLenum  , GLsizei  , GLvoid const   * ) ;
   void (*Ortho)(GLcontext * , GLdouble  , GLdouble  , GLdouble  , GLdouble  , GLdouble  ,
                 GLdouble  ) ;
   void (*PassThrough)(GLcontext * , float  ) ;
   void (*PixelMapfv)(GLcontext * , GLenum  , GLint  , float const   * ) ;
   void (*PixelStorei)(GLcontext * , GLenum  , GLint  ) ;
   void (*PixelTransferf)(GLcontext * , GLenum  , float  ) ;
   void (*PixelZoom)(GLcontext * , float  , float  ) ;
   void (*PointParameterfvEXT)(GLcontext * , GLenum  , float const   * ) ;
   void (*PointSize)(GLcontext * , float  ) ;
   void (*PolygonMode)(GLcontext * , GLenum  , GLenum  ) ;
   void (*PolygonOffset)(GLcontext * , float  , float  ) ;
   void (*PolygonStipple)(GLcontext * , GLubyte const   * ) ;
   void (*PopAttrib)(GLcontext * ) ;
   void (*PopClientAttrib)(GLcontext * ) ;
   void (*PopMatrix)(GLcontext * ) ;
   void (*PopName)(GLcontext * ) ;
   void (*PushAttrib)(GLcontext * , GLbitfield  ) ;
   void (*PushClientAttrib)(GLcontext * , GLbitfield  ) ;
   void (*PushMatrix)(GLcontext * ) ;
   void (*PushName)(GLcontext * , GLuint  ) ;
   void (*RasterPos4f)(GLcontext * , float x , float y , float z , float w ) ;
   void (*ReadBuffer)(GLcontext * , GLenum  ) ;
   void (*ReadPixels)(GLcontext * , GLint  , GLint  , GLsizei  , GLsizei  , GLenum  ,
                      GLenum  , GLvoid * ) ;
   void (*Rectf)(GLcontext * , float  , float  , float  , float  ) ;
   GLint (*RenderMode)(GLcontext * , GLenum  ) ;
   void (*Rotatef)(GLcontext * , float  , float  , float  , float  ) ;
   void (*Scalef)(GLcontext * , float  , float  , float  ) ;
   void (*Scissor)(GLcontext * , GLint  , GLint  , GLsizei  , GLsizei  ) ;
   void (*SelectBuffer)(GLcontext * , GLsizei  , GLuint * ) ;
   void (*ShadeModel)(GLcontext * , GLenum  ) ;
   void (*StencilFunc)(GLcontext * , GLenum  , GLint  , GLuint  ) ;
   void (*StencilMask)(GLcontext * , GLuint  ) ;
   void (*StencilOp)(GLcontext * , GLenum  , GLenum  , GLenum  ) ;
   void (*TexCoord2f)(GLcontext * , float  , float  ) ;
   void (*TexCoord4f)(GLcontext * , float  , float  , float  , float  ) ;
   void (*TexCoordPointer)(GLcontext * , GLint  , GLenum  , GLsizei  , GLvoid const   * ) ;
   void (*TexEnvfv)(GLcontext * , GLenum  , GLenum  , float const   * ) ;
   void (*TexGenfv)(GLcontext * , GLenum coord , GLenum  , float const   * ) ;
   void (*TexImage1D)(GLcontext * , GLenum  , GLint  , GLint  , GLsizei  , GLint  ,
                      GLenum  , GLenum  , struct gl_image * ) ;
   void (*TexImage2D)(GLcontext * , GLenum  , GLint  , GLint  , GLsizei  , GLsizei  ,
                      GLint  , GLenum  , GLenum  , struct gl_image * ) ;
   void (*TexSubImage1D)(GLcontext * , GLenum  , GLint  , GLint  , GLsizei  , GLenum  ,
                         GLenum  , struct gl_image * ) ;
   void (*TexSubImage2D)(GLcontext * , GLenum  , GLint  , GLint  , GLint  , GLsizei  ,
                         GLsizei  , GLenum  , GLenum  , struct gl_image * ) ;
   void (*TexImage3DEXT)(GLcontext * , GLenum  , GLint  , GLint  , GLsizei  , GLsizei  ,
                         GLsizei  , GLint  , GLenum  , GLenum  , struct gl_image * ) ;
   void (*TexSubImage3DEXT)(GLcontext * , GLenum  , GLint  , GLint  , GLint  , GLint  ,
                            GLsizei  , GLsizei  , GLsizei  , GLenum  , GLenum  , struct gl_image * ) ;
   void (*TexParameterfv)(GLcontext * , GLenum  , GLenum  , float const   * ) ;
   void (*Translatef)(GLcontext * , float  , float  , float  ) ;
   void (*Vertex2f)(GLcontext * , float  , float  ) ;
   void (*Vertex3f)(GLcontext * , float  , float  , float  ) ;
   void (*Vertex4f)(GLcontext * , float  , float  , float  , float  ) ;
   void (*Vertex3fv)(GLcontext * , float const   * ) ;
   void (*VertexPointer)(GLcontext * , GLint  , GLenum  , GLsizei  , GLvoid const   * ) ;
   void (*Viewport)(GLcontext * , GLint  , GLint  , GLsizei  , GLsizei  ) ;
   void (*WindowPos4fMESA)(GLcontext * , float  , float  , float  , float  ) ;
   void (*ResizeBuffersMESA)(GLcontext * ) ;
};
#line 2077 "D:/a/test/177.c"
struct vertex_buffer {
   float Obj[504][4] ;
   float Eye[504][4] ;
   float Clip[504][4] ;
   float Win[504][3] ;
   float Normal[504][3] ;
   GLubyte Fcolor[504][4] ;
   GLubyte Bcolor[504][4] ;
   GLubyte (*Color)[4] ;
   GLuint Findex[504] ;
   GLuint Bindex[504] ;
   GLuint *Index ;
   GLboolean Edgeflag[504] ;
   float TexCoord[504][4] ;
   GLubyte ClipMask[504] ;
   GLubyte ClipOrMask ;
   GLubyte ClipAndMask ;
   GLuint Start ;
   GLuint Count ;
   GLuint Free ;
   GLuint VertexSizeMask ;
   GLuint TexCoordSize ;
   GLboolean MonoColor ;
   GLboolean MonoNormal ;
   GLboolean MonoMaterial ;
   GLuint MaterialMask[504] ;
   struct gl_material Material[504][2] ;
};
#line 2105 "D:/a/test/177.c"
struct pixel_buffer {
   GLint x[1920] ;
   GLint y[1920] ;
   GLdepth z[1920] ;
   GLubyte r[1920] ;
   GLubyte g[1920] ;
   GLubyte b[1920] ;
   GLubyte a[1920] ;
   GLuint i[1920] ;
   float s[1920] ;
   float t[1920] ;
   float u[1920] ;
   float lambda[1920] ;
   GLint color[4] ;
   GLuint index ;
   GLuint count ;
   GLboolean mono ;
   GLenum primitive ;
};
#line 2124 "D:/a/test/177.c"
struct gl_context {
   struct gl_shared_state *Shared ;
   struct gl_api_table API ;
   struct gl_api_table Save ;
   struct gl_api_table Exec ;
   GLvisual *Visual ;
   GLframebuffer *Buffer ;
   struct dd_function_table Driver ;
   void *DriverCtx ;
   void *DriverMgrCtx ;
   GLboolean NewModelViewMatrix ;
   GLuint ModelViewMatrixType ;
   float ModelViewMatrix[16] ;
   float ModelViewInv[16] ;
   GLuint ModelViewStackDepth ;
   float ModelViewStack[32][16] ;
   GLboolean NewProjectionMatrix ;
   GLuint ProjectionMatrixType ;
   float ProjectionMatrix[16] ;
   GLuint ProjectionStackDepth ;
   float ProjectionStack[32][16] ;
   float NearFarStack[32][2] ;
   GLboolean NewTextureMatrix ;
   GLuint TextureMatrixType ;
   float TextureMatrix[16] ;
   GLuint TextureStackDepth ;
   float TextureStack[10][16] ;
   GLuint CallDepth ;
   GLboolean ExecuteFlag ;
   GLboolean CompileFlag ;
   GLuint AttribStackDepth ;
   struct gl_attrib_node *AttribStack[16] ;
   struct gl_accum_attrib Accum ;
   struct gl_colorbuffer_attrib Color ;
   struct gl_current_attrib Current ;
   struct gl_depthbuffer_attrib Depth ;
   struct gl_eval_attrib Eval ;
   struct gl_fog_attrib Fog ;
   struct gl_hint_attrib Hint ;
   struct gl_light_attrib Light ;
   struct gl_line_attrib Line ;
   struct gl_list_attrib List ;
   struct gl_pixel_attrib Pixel ;
   struct gl_point_attrib Point ;
   struct gl_polygon_attrib Polygon ;
   GLuint PolygonStipple[32] ;
   struct gl_scissor_attrib Scissor ;
   struct gl_stencil_attrib Stencil ;
   struct gl_texture_attrib Texture ;
   struct gl_transform_attrib Transform ;
   struct gl_viewport_attrib Viewport ;
   GLuint ClientAttribStackDepth ;
   struct gl_attrib_node *ClientAttribStack[16] ;
   struct gl_array_attrib Array ;
   struct gl_pixelstore_attrib Pack ;
   struct gl_pixelstore_attrib Unpack ;
   struct gl_evaluators EvalMap ;
   struct gl_feedback Feedback ;
   struct gl_selection Select ;
   GLenum ErrorValue ;
   GLboolean DirectContext ;
   GLuint NewState ;
   GLenum RenderMode ;
   GLenum Primitive ;
   GLuint StippleCounter ;
   GLuint ClipMask ;
   GLuint RasterMask ;
   GLboolean LightTwoSide ;
   GLboolean DirectTriangles ;
   float PolygonZoffset ;
   float LineZoffset ;
   float PointZoffset ;
   GLboolean NeedNormals ;
   GLboolean FastDrawPixels ;
   GLboolean MutablePixels ;
   GLboolean MonoPixels ;
   void (*PointsFunc)(GLcontext *ctx , GLuint first , GLuint last ) ;
   void (*LineFunc)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ) ;
   void (*TriangleFunc)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 , GLuint pv ) ;
   void (*QuadFunc)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 , GLuint v4 ,
                    GLuint pv ) ;
   void (*RectFunc)(GLcontext *ctx , GLint x , GLint y , GLint width , GLint height ) ;
   struct vertex_buffer *VB ;
   struct pixel_buffer *PB ;
   GLboolean NoRaster ;
   GLboolean NoDither ;
};
#line 10873
enum __anonenum_OpCode_24 {
    OPCODE_ACCUM = 0,
    OPCODE_ALPHA_FUNC = 1,
    OPCODE_BEGIN = 2,
    OPCODE_BIND_TEXTURE = 3,
    OPCODE_BITMAP = 4,
    OPCODE_BLEND_COLOR = 5,
    OPCODE_BLEND_EQUATION = 6,
    OPCODE_BLEND_FUNC = 7,
    OPCODE_CALL_LIST = 8,
    OPCODE_CALL_LIST_OFFSET = 9,
    OPCODE_CLEAR = 10,
    OPCODE_CLEAR_ACCUM = 11,
    OPCODE_CLEAR_COLOR = 12,
    OPCODE_CLEAR_DEPTH = 13,
    OPCODE_CLEAR_INDEX = 14,
    OPCODE_CLEAR_STENCIL = 15,
    OPCODE_CLIP_PLANE = 16,
    OPCODE_COLOR_3F = 17,
    OPCODE_COLOR_4F = 18,
    OPCODE_COLOR_4UB = 19,
    OPCODE_COLOR_MASK = 20,
    OPCODE_COLOR_MATERIAL = 21,
    OPCODE_COLOR_TABLE = 22,
    OPCODE_COLOR_SUB_TABLE = 23,
    OPCODE_COPY_PIXELS = 24,
    OPCODE_COPY_TEX_IMAGE1D = 25,
    OPCODE_COPY_TEX_IMAGE2D = 26,
    OPCODE_COPY_TEX_IMAGE3D = 27,
    OPCODE_COPY_TEX_SUB_IMAGE1D = 28,
    OPCODE_COPY_TEX_SUB_IMAGE2D = 29,
    OPCODE_COPY_TEX_SUB_IMAGE3D = 30,
    OPCODE_CULL_FACE = 31,
    OPCODE_DEPTH_FUNC = 32,
    OPCODE_DEPTH_MASK = 33,
    OPCODE_DEPTH_RANGE = 34,
    OPCODE_DISABLE = 35,
    OPCODE_DRAW_BUFFER = 36,
    OPCODE_DRAW_PIXELS = 37,
    OPCODE_EDGE_FLAG = 38,
    OPCODE_ENABLE = 39,
    OPCODE_END = 40,
    OPCODE_EVALCOORD1 = 41,
    OPCODE_EVALCOORD2 = 42,
    OPCODE_EVALMESH1 = 43,
    OPCODE_EVALMESH2 = 44,
    OPCODE_EVALPOINT1 = 45,
    OPCODE_EVALPOINT2 = 46,
    OPCODE_FOG = 47,
    OPCODE_FRONT_FACE = 48,
    OPCODE_FRUSTUM = 49,
    OPCODE_HINT = 50,
    OPCODE_INDEX = 51,
    OPCODE_INDEX_MASK = 52,
    OPCODE_INIT_NAMES = 53,
    OPCODE_LIGHT = 54,
    OPCODE_LIGHT_MODEL = 55,
    OPCODE_LINE_STIPPLE = 56,
    OPCODE_LINE_WIDTH = 57,
    OPCODE_LIST_BASE = 58,
    OPCODE_LOAD_IDENTITY = 59,
    OPCODE_LOAD_MATRIX = 60,
    OPCODE_LOAD_NAME = 61,
    OPCODE_LOGIC_OP = 62,
    OPCODE_MAP1 = 63,
    OPCODE_MAP2 = 64,
    OPCODE_MAPGRID1 = 65,
    OPCODE_MAPGRID2 = 66,
    OPCODE_MATERIAL = 67,
    OPCODE_MATRIX_MODE = 68,
    OPCODE_MULT_MATRIX = 69,
    OPCODE_NORMAL = 70,
    OPCODE_ORTHO = 71,
    OPCODE_PASSTHROUGH = 72,
    OPCODE_PIXEL_MAP = 73,
    OPCODE_PIXEL_TRANSFER = 74,
    OPCODE_PIXEL_ZOOM = 75,
    OPCODE_POINT_SIZE = 76,
    OPCODE_POINT_PARAMETERS = 77,
    OPCODE_POLYGON_MODE = 78,
    OPCODE_POLYGON_STIPPLE = 79,
    OPCODE_POLYGON_OFFSET = 80,
    OPCODE_POP_ATTRIB = 81,
    OPCODE_POP_MATRIX = 82,
    OPCODE_POP_NAME = 83,
    OPCODE_PRIORITIZE_TEXTURE = 84,
    OPCODE_PUSH_ATTRIB = 85,
    OPCODE_PUSH_MATRIX = 86,
    OPCODE_PUSH_NAME = 87,
    OPCODE_RASTER_POS = 88,
    OPCODE_RECTF = 89,
    OPCODE_READ_BUFFER = 90,
    OPCODE_SCALE = 91,
    OPCODE_SCISSOR = 92,
    OPCODE_SHADE_MODEL = 93,
    OPCODE_STENCIL_FUNC = 94,
    OPCODE_STENCIL_MASK = 95,
    OPCODE_STENCIL_OP = 96,
    OPCODE_TEXCOORD2 = 97,
    OPCODE_TEXCOORD4 = 98,
    OPCODE_TEXENV = 99,
    OPCODE_TEXGEN = 100,
    OPCODE_TEXPARAMETER = 101,
    OPCODE_TEX_IMAGE1D = 102,
    OPCODE_TEX_IMAGE2D = 103,
    OPCODE_TEX_IMAGE3D = 104,
    OPCODE_TEX_SUB_IMAGE1D = 105,
    OPCODE_TEX_SUB_IMAGE2D = 106,
    OPCODE_TEX_SUB_IMAGE3D = 107,
    OPCODE_TRANSLATE = 108,
    OPCODE_VERTEX2 = 109,
    OPCODE_VERTEX3 = 110,
    OPCODE_VERTEX4 = 111,
    OPCODE_VIEWPORT = 112,
    OPCODE_WINDOW_POS = 113,
    OPCODE_CONTINUE = 114,
    OPCODE_END_OF_LIST = 115
} ;
#line 10873 "D:/a/test/177.c"
typedef enum __anonenum_OpCode_24 OpCode;
#line 10992 "D:/a/test/177.c"
union node {
   OpCode opcode ;
   GLboolean b ;
   GLbitfield bf ;
   GLubyte ub ;
   GLshort s ;
   GLushort us ;
   GLint i ;
   GLuint ui ;
   GLenum e ;
   float f ;
   GLvoid *data ;
   void *next ;
};
#line 10992 "D:/a/test/177.c"
typedef union node Node;
#line 20926 "D:/a/test/177.c"
struct HashEntry {
   GLuint Key ;
   void *Data ;
   struct HashEntry *Next ;
};
#line 20931 "D:/a/test/177.c"
struct HashTable {
   struct HashEntry *Table[1001] ;
   GLuint MaxKey ;
};
#line 24089 "D:/a/test/177.c"
typedef float Mat2[2][2];
#line 26032 "D:/a/test/177.c"
struct __anonstruct_EdgeT_26 {
   GLint v0 ;
   GLint v1 ;
   float dx ;
   float dy ;
   int fdxdy ;
   int fsx ;
   int fsy ;
   float adjy ;
   GLint lines ;
   int fx0 ;
};
#line 26032 "D:/a/test/177.c"
typedef struct __anonstruct_EdgeT_26 EdgeT;
#line 810 "/usr/include/sys/reent.h"
extern struct _reent *( __attribute__((__cdecl__)) __getreent)(void) ;
#line 172 "/usr/include/stdio.h"
extern int ( __attribute__((__cdecl__)) fclose)(FILE * ) ;
#line 177
extern int ( __attribute__((__cdecl__)) fprintf)(FILE * , char const   *  , ...) ;
#line 178
extern int ( __attribute__((__cdecl__)) fscanf)(FILE * , char const   *  , ...) ;
#line 179
extern int ( __attribute__((__cdecl__)) printf)(char const   *  , ...) ;
#line 216
extern FILE *( __attribute__((__cdecl__)) fopen)(char const   *_name , char const   *_type ) ;
#line 217
extern int ( __attribute__((__cdecl__)) sprintf)(char * , char const   *  , ...) ;
#line 68 "/usr/include/stdlib.h"
extern int ( __attribute__((__cdecl__)) atoi)(char const   *__nptr ) ;
#line 77
extern void *( __attribute__((__cdecl__)) calloc)(size_t __nmemb , size_t __size ) ;
#line 79
extern  __attribute__((__noreturn__)) void ( __attribute__((__cdecl__)) exit)(int __status ) ;
#line 80
extern void ( __attribute__((__cdecl__)) free)(void * ) ;
#line 81
extern char *( __attribute__((__cdecl__)) getenv)(char const   *__string ) ;
#line 87
extern void *( __attribute__((__cdecl__)) malloc)(size_t __size ) ;//47
#line 24 "/usr/include/string.h"
extern void *( __attribute__((__cdecl__)) memcpy)(void * , void const   * , size_t  ) ;
#line 26
extern void *( __attribute__((__cdecl__)) memset)(void * , int  , size_t  ) ;
#line 27
extern char *( __attribute__((__cdecl__)) strcat)(char * , char const   * ) ;
#line 29
extern int ( __attribute__((__cdecl__)) strcmp)(char const   * , char const   * ) ;
#line 31
extern char *( __attribute__((__cdecl__)) strcpy)(char * , char const   * ) ;
#line 76 "/usr/include/math.h"
extern double cos(double  ) ;
#line 77
extern double sin(double  ) ;
#line 84
extern double floor(double  ) ;
#line 96
extern double exp(double  ) ;
#line 100
extern double pow(double  , double  ) ;
#line 101
extern double sqrt(double  ) ;
#line 930 "D:/a/test/177.c"
static int NumRows  ;
#line 930 "D:/a/test/177.c"
static int NumColumns  ;
#line 931 "D:/a/test/177.c"
static float *SurfaceV  ;
#line 932 "D:/a/test/177.c"
static float *SurfaceN  ;
#line 935 "D:/a/test/177.c"
static float Xrot  =    (float )(- 35.0);
#line 935 "D:/a/test/177.c"
static float Yrot  =    (float )40.0;
#line 936 "D:/a/test/177.c"
static void ReadMesh(char const   *filename ) 
{ int i ;
  int j ;
  FILE *f ;
  FILE *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int k ;
  float vx ;
  float vy ;
  float vz ;
  float nx ;
  float ny ;
  float nz ;

  {
#line 939
  tmp = fopen(filename, "r");
#line 939
  f = tmp;
#line 940
  if (! f) {
#line 941
    printf("Error: couldn\'t open input mesh file: %s\n", filename);
#line 942
    exit(1);
  }
#line 944
  fscanf(f, "%d %d\n", & NumRows, & NumColumns);
#line 945
  if (NumRows < 2) {
#line 946
    printf("Error: number of mesh rows invalid\n");
#line 947
    exit(1);
  }
#line 949
  if (NumColumns < 2) {
#line 950
    printf("Error: number of mesh columns invalid\n");
#line 951
    exit(1);
  }
#line 953
  tmp___0 = malloc((unsigned int )((NumRows * NumColumns) * 3) * sizeof(float ));//48
#line 953
  SurfaceV = (float *)tmp___0;
#line 954
  tmp___1 = malloc((unsigned int )((NumRows * NumColumns) * 3) * sizeof(float ));//49
#line 954
  SurfaceN = (float *)tmp___1;
#line 955
  if (! SurfaceV) {
#line 956
    printf("Error: unable to allocate memory for mesh data\n");
#line 957
    exit(1);
  } else {
#line 955
    if (! SurfaceN) {
#line 956
      printf("Error: unable to allocate memory for mesh data\n");
#line 957
      exit(1);
    }
  }
#line 959
  i = 0;
#line 959
  while (i < NumRows) {
#line 960
    j = 0;
#line 960
    while (j < NumColumns) {
#line 961
      k = (i * NumColumns + j) * 3;
#line 963
      fscanf(f, "%f %f %f  %f %f %f\n", & vx, & vy, & vz, & nx, & ny, & nz);
#line 964
      *(SurfaceV + k) = vx;
#line 965
      *(SurfaceV + (k + 1)) = vy;
#line 966
      *(SurfaceV + (k + 2)) = vz;
#line 967
      *(SurfaceN + k) = nx;
#line 968
      *(SurfaceN + (k + 1)) = ny;
#line 969
      *(SurfaceN + (k + 2)) = nz;
#line 960
      j ++;
    }
#line 959
    i ++;
  }
#line 972
  fclose(f);
#line 973
  return;
}
}
#line 978
void glBegin(GLenum mode ) ;
#line 982
void glNormal3fv(float const   *v ) ;
#line 983
void glVertex3fv(float const   *v ) ;
#line 987
void glEnd(void) ;
#line 974 "D:/a/test/177.c"
static void DrawMesh(void) 
{ int i ;
  int j ;
  int k0 ;
  int k1 ;

  {
#line 977
  i = 0;
#line 977
  while (i < NumRows - 1) {
#line 978
    glBegin(5);
#line 979
    j = 0;
#line 979
    while (j < NumColumns) {
#line 980
      k0 = (i * NumColumns + j) * 3;
#line 981
      k1 = ((i + 1) * NumColumns + j) * 3;
#line 982
      glNormal3fv(SurfaceN + k0);
#line 983
      glVertex3fv(SurfaceV + k0);
#line 984
      glNormal3fv(SurfaceN + k1);
#line 985
      glVertex3fv(SurfaceV + k1);
#line 979
      j ++;
    }
#line 987
    glEnd();
#line 977
    i ++;
  }
#line 989
  return;
}
}
#line 990 "D:/a/test/177.c"
static void SPECWriteIntermediateImage(FILE *fip , FILE *fop , int width , int height ,
                                       void const   *buffer , int frame_count ) 
{ int i ;
  int x ;
  int y ;
  GLubyte *ptr ;
  int counter ;

  {
#line 993
  ptr = (GLubyte *)buffer;
#line 994
  counter = 0;
#line 995
  if (fip) {
#line 997
    fscanf(fip, "%d %d", & x, & y);
#line 998
    y %= height;
#line 999
    x %= width;
#line 1000
    i = (y * width + x) * 4;
  }
#line 1002
  if (fop) {
#line 1004
    fprintf(fop, "%d %d %d %d\n", i, *(ptr + i), *(ptr + (i + 1)), *(ptr + (i + 2)));
  }
#line 1006
  return;
}
}
#line 1024
void glClear(GLbitfield mask ) ;
#line 1025
void glPushMatrix(void) ;
#line 1026
void glRotatef(float angle , float x , float y , float z ) ;
#line 1031
void glPopMatrix(void) ;
#line 1007 "D:/a/test/177.c"
static void Render(int frames , int width , int height , void const   *buffer ) 
{ int i ;
  FILE *fip ;
  FILE *tmp ;
  FILE *fop ;
  FILE *tmp___0 ;

  {
#line 1010
  tmp = fopen("numbers", "r");
#line 1010
  fip = tmp;
#line 1011
  tmp___0 = fopen("mesa.log", "w");
#line 1011
  fop = tmp___0;
#line 1012
  Yrot = - 5.0F * (float )(frames - 1);
#line 1013
  i = 0;
#line 1013
  while (i < frames) {
#line 1014
    if (Yrot > 360.0F) {
#line 1015
      while (Yrot > 360.0F) {
#line 1016
        Yrot -= 360.0F;
      }
    } else {
#line 1019
      if (Yrot < 0.0F) {
#line 1020
        while (Yrot < 0.0F) {
#line 1021
          Yrot += 360.0F;
        }
      }
    }
#line 1024
    glClear(16640);
#line 1025
    glPushMatrix();
#line 1026
    glRotatef(- Xrot, 1, 0, 0);
#line 1027
    glRotatef(Yrot, 0, 1, 0);
#line 1028
    glRotatef(-90, 1, 0, 0);
#line 1029
    SPECWriteIntermediateImage(fip, fop, width, height, buffer, i);
#line 1030
    DrawMesh();
#line 1031
    glPopMatrix();
#line 1033
    Yrot += 5.0F;
#line 1013
    i ++;
  }
#line 1035
  return;
}
}
#line 1039
void glViewport(GLint x , GLint y , GLsizei width , GLsizei height ) ;
#line 1040
void glMatrixMode(GLenum mode ) ;
#line 1041
void glLoadIdentity(void) ;
#line 1042
void glFrustum(GLdouble left , GLdouble right , GLdouble bottom , GLdouble top , GLdouble nearval ,
               GLdouble farval ) ;
#line 1045
void glTranslatef(float x , float y , float z ) ;
#line 1036 "D:/a/test/177.c"
static void Reshape(int width , int height ) 
{ float w ;

  {
#line 1038
  w = (float )width / (float )height;
#line 1039
  glViewport(0, 0, width, height);
#line 1040
  glMatrixMode(5889);
#line 1041
  glLoadIdentity();
#line 1042
  glFrustum((double )(- w) * 1.1, (double )w * 1.1, - 1.1, 1.1, 5.0, 100.0);
#line 1043
  glMatrixMode(5888);
#line 1044
  glLoadIdentity();
#line 1045
  glTranslatef(0.0, 0.0, - 60.0);
#line 1046
  return;
}
}
#line 1051
static void Init(void) ;
#line 1051 "D:/a/test/177.c"
static float texPlane[4]  = {      (float )0.0,      (float )0.0,      (float )0.1,      (float )0.0};
#line 1052
static void Init(void) ;
#line 1052 "D:/a/test/177.c"
static float blue[4]  = {      (float )0.2,      (float )0.2,      (float )1.0,      (float )1.0};
#line 1053
static void Init(void) ;
#line 1053 "D:/a/test/177.c"
static float white[4]  = {      (float )1.0,      (float )1.0,      (float )1.0,      (float )1.0};
#line 1054
static void Init(void) ;
#line 1054 "D:/a/test/177.c"
static float posred[4]  = {      (float )0.0,      (float )2.0,      (float )5.0,      (float )0.0};
#line 1055
static void Init(void) ;
#line 1055 "D:/a/test/177.c"
static float posgreen[4]  = {      (float )0.0,      (float )2.5,      (float )5.0,      (float )0.0};
#line 1056
static void Init(void) ;
#line 1056 "D:/a/test/177.c"
static float posblue[4]  = {      (float )0.0,      (float )2.0,      (float )6.0,      (float )0.0};
#line 1057
static void Init(void) ;
#line 1057 "D:/a/test/177.c"
static float grayred[4]  = {      0.43F,      0.125F,      0.0625F,      1.0F};
#line 1058
static void Init(void) ;
#line 1058 "D:/a/test/177.c"
static float graygreen[4]  = {      0.0625F,      0.45F,      0.125F,      1.0F};
#line 1059
static void Init(void) ;
#line 1059 "D:/a/test/177.c"
static float grayblue[4]  = {      0.125F,      0.0625F,      0.47F,      1.0F};
#line 1060
void glEnable(GLenum cap ) ;
#line 1064
void glMaterialfv(GLenum face , GLenum pname , float const   *params ) ;
#line 1066
void glMaterialf(GLenum face , GLenum pname , float param ) ;
#line 1067
void glLightfv(GLenum light , GLenum pname , float const   *params ) ;
#line 1085
void glTexImage1D(GLenum target , GLint level , GLint internalformat , GLsizei width ,
                  GLint border , GLenum format , GLenum type , GLvoid const   *pixels ) ;
#line 1087
void glTexParameteri(GLenum target , GLenum pname , GLint param ) ;
#line 1090
void glTexGeni(GLenum coord , GLenum pname , GLint param ) ;
#line 1091
void glTexGenfv(GLenum coord , GLenum pname , float const   *params ) ;
#line 1047 "D:/a/test/177.c"
static void Init(void) 
{ GLint i ;
  GLubyte texture[256] ;

  {
#line 1060
  glEnable(2896);
#line 1061
  glEnable(16384);
#line 1062
  glEnable(16385);
#line 1063
  glEnable(16386);
#line 1064
  glMaterialfv(1032, 5634, blue);
#line 1065
  glMaterialfv(1032, 4610, white);
#line 1066
  glMaterialf(1032, 5633, 15.0);
#line 1067
  glLightfv(16384, 4611, posred);
#line 1068
  glLightfv(16384, 4609, grayred);
#line 1069
  glLightfv(16384, 4610, grayred);
#line 1070
  glLightfv(16385, 4611, posgreen);
#line 1071
  glLightfv(16385, 4609, graygreen);
#line 1072
  glLightfv(16385, 4610, graygreen);
#line 1073
  glLightfv(16386, 4611, posblue);
#line 1074
  glLightfv(16386, 4609, grayblue);
#line 1075
  glLightfv(16386, 4610, grayblue);
#line 1076
  glEnable(2929);
#line 1077
  i = 0;
#line 1077
  while (i < 256) {
#line 1078
    if (i % 16 < 1) {
#line 1079
      texture[i] = (unsigned char)0;
    } else {
#line 1082
      texture[i] = (unsigned char)255;
    }
#line 1077
    i ++;
  }
#line 1085
  glTexImage1D(3552, 0, 1, 256, 0, 6409, 5121, texture);
#line 1087
  glTexParameteri(3552, 10241, 9729);
#line 1088
  glTexParameteri(3552, 10240, 9729);
#line 1089
  glEnable(3552);
#line 1090
  glTexGeni(8192, 9472, 9217);
#line 1091
  glTexGenfv(8192, 9473, texPlane);
#line 1092
  glEnable(3168);
#line 1093
  Reshape(1280, 1024);
#line 1094
  return;
}
}
#line 1095 "D:/a/test/177.c"
static void WriteImage(char const   *filename , int width , int height , void const   *buffer ) 
{ FILE *f ;
  FILE *tmp ;
  int i ;
  int x ;
  int y ;
  GLubyte *ptr ;
  int counter ;

  {
#line 1098
  tmp = fopen(filename, "w");
#line 1098
  f = tmp;
#line 1099
  if (f) {
#line 1101
    ptr = (GLubyte *)buffer;
#line 1102
    counter = 0;
#line 1103
    fprintf(f, "P3\n");
#line 1104
    fprintf(f, "# ascii ppm file created by %s\n", "SPEC mesa177");
#line 1105
    fprintf(f, "%i %i\n", width, height);
#line 1106
    fprintf(f, "255\n");
#line 1107
    y = 1023;
#line 1107
    while (y >= 0) {
#line 1108
      x = 0;
#line 1108
      while (x < 1280) {
#line 1109
        i = (y * 1280 + x) * 4;
#line 1110
        fprintf(f, " %d %d %d", *(ptr + i), *(ptr + (i + 1)), *(ptr + (i + 2)));
#line 1111
        counter ++;
#line 1112
        if (counter % 5 == 0) {
#line 1113
          fprintf(f, "\n");
        }
#line 1108
        x ++;
      }
#line 1107
      y --;
    }
#line 1116
    fclose(f);
  }
#line 1118
  return;
}
}
#line 3520
void gl_error(GLcontext *ctx , GLenum error , char const   *s ) ;
#line 3510 "D:/a/test/177.c"
void gl_alloc_accum_buffer(GLcontext *ctx ) 
{ GLint n ;
  void *tmp ;

  {
#line 3513
  if ((ctx->Buffer)->Accum) {
#line 3514
    free((void *)(ctx->Buffer)->Accum);
#line 3515
    (ctx->Buffer)->Accum = (GLaccum *)((void *)0);
  }
#line 3517
  n = (int )((unsigned int )(((ctx->Buffer)->Width * (ctx->Buffer)->Height) * 4) * sizeof(GLaccum ));
#line 3518
  tmp = malloc((unsigned int )n);//50
#line 3518
  (ctx->Buffer)->Accum = (GLaccum *)tmp;
#line 3519
  if (! (ctx->Buffer)->Accum) {
#line 3520
    gl_error(ctx, 1285, "glAccum");
  }
#line 3522
  return;
}
}
#line 3523 "D:/a/test/177.c"
void gl_ClearAccum(GLcontext *ctx , float red , float green , float blue___0 , float alpha ) 
{ double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 3526
  if (ctx->Primitive != 6656) {
#line 3527
    gl_error(ctx, 1282, "glAccum");
#line 3528
    return;
  }
#line 3530
  if ((double )red < - 1.0) {
#line 3530
    ctx->Accum.ClearColor[0] = (float )(- 1.0);
  } else {
#line 3530
    if ((double )red > 1.0) {
#line 3530
      tmp = 1.0;
    } else {
#line 3530
      tmp = (double )red;
    }
#line 3530
    ctx->Accum.ClearColor[0] = (float )tmp;
  }
#line 3531
  if ((double )green < - 1.0) {
#line 3531
    ctx->Accum.ClearColor[1] = (float )(- 1.0);
  } else {
#line 3531
    if ((double )green > 1.0) {
#line 3531
      tmp___0 = 1.0;
    } else {
#line 3531
      tmp___0 = (double )green;
    }
#line 3531
    ctx->Accum.ClearColor[1] = (float )tmp___0;
  }
#line 3532
  if ((double )blue___0 < - 1.0) {
#line 3532
    ctx->Accum.ClearColor[2] = (float )(- 1.0);
  } else {
#line 3532
    if ((double )blue___0 > 1.0) {
#line 3532
      tmp___1 = 1.0;
    } else {
#line 3532
      tmp___1 = (double )blue___0;
    }
#line 3532
    ctx->Accum.ClearColor[2] = (float )tmp___1;
  }
#line 3533
  if ((double )alpha < - 1.0) {
#line 3533
    ctx->Accum.ClearColor[3] = (float )(- 1.0);
  } else {
#line 3533
    if ((double )alpha > 1.0) {
#line 3533
      tmp___2 = 1.0;
    } else {
#line 3533
      tmp___2 = (double )alpha;
    }
#line 3533
    ctx->Accum.ClearColor[3] = (float )tmp___2;
  }
#line 3534
  return;
}
}
#line 3544
void gl_warning(GLcontext const   *ctx , char const   *s ) ;
#line 3535 "D:/a/test/177.c"
void gl_Accum(GLcontext *ctx , GLenum op , float value ) 
{ GLuint xpos ;
  GLuint ypos ;
  GLuint width ;
  GLuint height ;
  float acc_scale ;
  GLaccum ival ;
  GLaccum *acc ;
  GLuint i ;
  GLuint j ;
  GLaccum *acc___0 ;
  GLuint i___0 ;
  GLuint j___0 ;
  GLaccum *acc___1 ;
  GLubyte red[640] ;
  GLubyte green[640] ;
  GLubyte blue___0[640] ;
  GLubyte alpha[640] ;
  float rscale ;
  float gscale ;
  float bscale ;
  float ascale ;
  GLuint i___1 ;
  GLuint j___1 ;
  struct dd_function_table myd ;
  GLaccum *acc___2 ;
  GLubyte red___0[640] ;
  GLubyte green___0[640] ;
  GLubyte blue___1[640] ;
  GLubyte alpha___0[640] ;
  float rscale___0 ;
  float gscale___0 ;
  float bscale___0 ;
  float ascale___0 ;
  GLuint i___2 ;
  GLuint j___2 ;
  GLaccum *tmp ;
  GLaccum *tmp___0 ;
  GLaccum *tmp___1 ;
  GLaccum *tmp___2 ;
  GLubyte red___1[640] ;
  GLubyte green___1[640] ;
  GLubyte blue___2[640] ;
  GLubyte alpha___1[640] ;
  GLaccum *acc___3 ;
  float rscale___1 ;
  float gscale___1 ;
  float bscale___1 ;
  float ascale___1 ;
  GLint rmax ;
  GLint gmax ;
  GLint bmax ;
  GLint amax ;
  GLuint i___3 ;
  GLuint j___3 ;
  GLint r ;
  GLint g ;
  GLint b ;
  GLint a ;
  GLaccum *tmp___3 ;
  GLaccum *tmp___4 ;
  GLaccum *tmp___5 ;
  GLaccum *tmp___6 ;
  GLint tmp___7 ;
  GLint tmp___8 ;
  GLint tmp___9 ;
  GLint tmp___10 ;

  {
#line 3539
  if (ctx->Primitive != 6656) {
#line 3540
    gl_error(ctx, 1282, "glAccum");
#line 3541
    return;
  }
#line 3543
  if ((ctx->Visual)->AccumBits == 0) {
#line 3544
    gl_warning(ctx, "Calling glAccum() without an accumulation buffer");
#line 3545
    return;
  } else {
#line 3543
    if (! (ctx->Buffer)->Accum) {
#line 3544
      gl_warning(ctx, "Calling glAccum() without an accumulation buffer");
#line 3545
      return;
    }
  }
#line 3547
  if (sizeof(GLaccum ) == 1U) {
#line 3548
    acc_scale = (float )127.0;
  } else {
#line 3550
    if (sizeof(GLaccum ) == 2U) {
#line 3551
      acc_scale = (float )32767.0;
    } else {
#line 3554
      acc_scale = (float )32767;
    }
  }
#line 3556
  if (ctx->Scissor.Enabled) {
#line 3557
    xpos = (unsigned int )ctx->Scissor.X;
#line 3558
    ypos = (unsigned int )ctx->Scissor.Y;
#line 3559
    width = (unsigned int )ctx->Scissor.Width;
#line 3560
    height = (unsigned int )ctx->Scissor.Height;
  } else {
#line 3563
    xpos = 0U;
#line 3564
    ypos = 0U;
#line 3565
    width = (unsigned int )(ctx->Buffer)->Width;
#line 3566
    height = (unsigned int )(ctx->Buffer)->Height;
  }
#line 3568
  switch (op) {
  case 260: 
#line 3573
  ival = (signed char )(value * acc_scale);
#line 3574
  j = 0U;
#line 3574
  while (j < height) {
#line 3575
    acc = (ctx->Buffer)->Accum + (ypos * (GLuint )(ctx->Buffer)->Width + xpos) * 4U;
#line 3577
    i = 0U;
#line 3577
    while (i < width) {
#line 3578
      *acc = (signed char )((int )*acc + (int )ival);
#line 3578
      acc ++;
#line 3579
      *acc = (signed char )((int )*acc + (int )ival);
#line 3579
      acc ++;
#line 3580
      *acc = (signed char )((int )*acc + (int )ival);
#line 3580
      acc ++;
#line 3581
      *acc = (signed char )((int )*acc + (int )ival);
#line 3581
      acc ++;
#line 3577
      i ++;
    }
#line 3583
    ypos ++;
#line 3574
    j ++;
  }
#line 3586
  break;
  case 259: 
#line 3591
  j___0 = 0U;
#line 3591
  while (j___0 < height) {
#line 3592
    acc___0 = (ctx->Buffer)->Accum + (ypos * (GLuint )(ctx->Buffer)->Width + xpos) * 4U;
#line 3594
    i___0 = 0U;
#line 3594
    while (i___0 < width) {
#line 3595
      *acc___0 = (signed char )((float )*acc___0 * value);
#line 3595
      acc___0 ++;
#line 3596
      *acc___0 = (signed char )((float )*acc___0 * value);
#line 3596
      acc___0 ++;
#line 3597
      *acc___0 = (signed char )((float )*acc___0 * value);
#line 3597
      acc___0 ++;
#line 3598
      *acc___0 = (signed char )((float )*acc___0 * value);
#line 3598
      acc___0 ++;
#line 3594
      i___0 ++;
    }
#line 3600
    ypos ++;
#line 3591
    j___0 ++;
  }
#line 3603
  break;
  case 256: 
#line 3611
  myd = ctx->Driver;
#line 3612
  (*(ctx->Driver.SetBuffer))(ctx, ctx->Pixel.ReadBuffer);
#line 3613
  rscale = (value * acc_scale) * (ctx->Visual)->InvRedScale;
#line 3614
  gscale = (value * acc_scale) * (ctx->Visual)->InvGreenScale;
#line 3615
  bscale = (value * acc_scale) * (ctx->Visual)->InvBlueScale;
#line 3616
  ascale = (value * acc_scale) * (ctx->Visual)->InvAlphaScale;
#line 3617
  j___1 = 0U;
#line 3617
  while (j___1 < height) {
#line 3618
    (*(ctx->Driver.ReadColorSpan))(ctx, width, (int )xpos, (int )ypos, red, green,
                                   blue___0, alpha);
#line 3620
    acc___1 = (ctx->Buffer)->Accum + (ypos * (GLuint )(ctx->Buffer)->Width + xpos) * 4U;
#line 3622
    i___1 = 0U;
#line 3622
    while (i___1 < width) {
#line 3623
      *acc___1 = (signed char )((int )*acc___1 + (int )((signed char )((float )red[i___1] * rscale)));
#line 3623
      acc___1 ++;
#line 3624
      *acc___1 = (signed char )((int )*acc___1 + (int )((signed char )((float )green[i___1] * gscale)));
#line 3624
      acc___1 ++;
#line 3625
      *acc___1 = (signed char )((int )*acc___1 + (int )((signed char )((float )blue___0[i___1] * bscale)));
#line 3625
      acc___1 ++;
#line 3626
      *acc___1 = (signed char )((int )*acc___1 + (int )((signed char )((float )alpha[i___1] * ascale)));
#line 3626
      acc___1 ++;
#line 3622
      i___1 ++;
    }
#line 3628
    ypos ++;
#line 3617
    j___1 ++;
  }
#line 3630
  (*(ctx->Driver.SetBuffer))(ctx, ctx->Color.DrawBuffer);
#line 3632
  break;
  case 257: 
#line 3640
  (*(ctx->Driver.SetBuffer))(ctx, ctx->Pixel.ReadBuffer);
#line 3642
  rscale___0 = (value * acc_scale) * (ctx->Visual)->InvRedScale;
#line 3643
  gscale___0 = (value * acc_scale) * (ctx->Visual)->InvGreenScale;
#line 3644
  bscale___0 = (value * acc_scale) * (ctx->Visual)->InvBlueScale;
#line 3645
  ascale___0 = (value * acc_scale) * (ctx->Visual)->InvAlphaScale;
#line 3646
  j___2 = 0U;
#line 3646
  while (j___2 < height) {
#line 3647
    (*(ctx->Driver.ReadColorSpan))(ctx, width, (int )xpos, (int )ypos, red___0, green___0,
                                   blue___1, alpha___0);
#line 3649
    acc___2 = (ctx->Buffer)->Accum + (ypos * (GLuint )(ctx->Buffer)->Width + xpos) * 4U;
#line 3651
    i___2 = 0U;
#line 3651
    while (i___2 < width) {
#line 3652
      tmp = acc___2;
#line 3652
      acc___2 ++;
#line 3652
      *tmp = (signed char )((float )red___0[i___2] * rscale___0);
#line 3653
      tmp___0 = acc___2;
#line 3653
      acc___2 ++;
#line 3653
      *tmp___0 = (signed char )((float )green___0[i___2] * gscale___0);
#line 3654
      tmp___1 = acc___2;
#line 3654
      acc___2 ++;
#line 3654
      *tmp___1 = (signed char )((float )blue___1[i___2] * bscale___0);
#line 3655
      tmp___2 = acc___2;
#line 3655
      acc___2 ++;
#line 3655
      *tmp___2 = (signed char )((float )alpha___0[i___2] * ascale___0);
#line 3651
      i___2 ++;
    }
#line 3657
    ypos ++;
#line 3646
    j___2 ++;
  }
#line 3659
  (*(ctx->Driver.SetBuffer))(ctx, ctx->Color.DrawBuffer);
#line 3661
  break;
  case 258: 
#line 3670
  rscale___1 = (value / acc_scale) * (ctx->Visual)->RedScale;
#line 3671
  gscale___1 = (value / acc_scale) * (ctx->Visual)->GreenScale;
#line 3672
  bscale___1 = (value / acc_scale) * (ctx->Visual)->BlueScale;
#line 3673
  ascale___1 = (value / acc_scale) * (ctx->Visual)->AlphaScale;
#line 3674
  rmax = (int )(ctx->Visual)->RedScale;
#line 3675
  gmax = (int )(ctx->Visual)->GreenScale;
#line 3676
  bmax = (int )(ctx->Visual)->BlueScale;
#line 3677
  amax = (int )(ctx->Visual)->AlphaScale;
#line 3678
  j___3 = 0U;
#line 3678
  while (j___3 < height) {
#line 3679
    acc___3 = (ctx->Buffer)->Accum + (ypos * (GLuint )(ctx->Buffer)->Width + xpos) * 4U;
#line 3681
    i___3 = 0U;
#line 3681
    while (i___3 < width) {
#line 3683
      tmp___3 = acc___3;
#line 3683
      acc___3 ++;
#line 3683
      r = (int )((float )*tmp___3 * rscale___1 + 0.5F);
#line 3684
      tmp___4 = acc___3;
#line 3684
      acc___3 ++;
#line 3684
      g = (int )((float )*tmp___4 * gscale___1 + 0.5F);
#line 3685
      tmp___5 = acc___3;
#line 3685
      acc___3 ++;
#line 3685
      b = (int )((float )*tmp___5 * bscale___1 + 0.5F);
#line 3686
      tmp___6 = acc___3;
#line 3686
      acc___3 ++;
#line 3686
      a = (int )((float )*tmp___6 * ascale___1 + 0.5F);
#line 3687
      if (r < 0) {
#line 3687
        red___1[i___3] = (unsigned char)0;
      } else {
#line 3687
        if (r > rmax) {
#line 3687
          tmp___7 = rmax;
        } else {
#line 3687
          tmp___7 = r;
        }
#line 3687
        red___1[i___3] = (unsigned char )tmp___7;
      }
#line 3688
      if (g < 0) {
#line 3688
        green___1[i___3] = (unsigned char)0;
      } else {
#line 3688
        if (g > gmax) {
#line 3688
          tmp___8 = gmax;
        } else {
#line 3688
          tmp___8 = g;
        }
#line 3688
        green___1[i___3] = (unsigned char )tmp___8;
      }
#line 3689
      if (b < 0) {
#line 3689
        blue___2[i___3] = (unsigned char)0;
      } else {
#line 3689
        if (b > bmax) {
#line 3689
          tmp___9 = bmax;
        } else {
#line 3689
          tmp___9 = b;
        }
#line 3689
        blue___2[i___3] = (unsigned char )tmp___9;
      }
#line 3690
      if (a < 0) {
#line 3690
        alpha___1[i___3] = (unsigned char)0;
      } else {
#line 3690
        if (a > amax) {
#line 3690
          tmp___10 = amax;
        } else {
#line 3690
          tmp___10 = a;
        }
#line 3690
        alpha___1[i___3] = (unsigned char )tmp___10;
      }
#line 3681
      i___3 ++;
    }
#line 3692
    (*(ctx->Driver.WriteColorSpan))(ctx, width, (int )xpos, (int )ypos, (GLubyte const   *)(red___1),
                                    (GLubyte const   *)(green___1), (GLubyte const   *)(blue___2),
                                    (GLubyte const   *)(alpha___1), (GLubyte const   *)((void *)0));
#line 3694
    ypos ++;
#line 3678
    j___3 ++;
  }
#line 3697
  break;
  default: 
#line 3699
  gl_error(ctx, 1280, "glAccum");
  }
#line 3701
  return;
}
}
#line 3702 "D:/a/test/177.c"
void gl_clear_accum_buffer(GLcontext *ctx ) 
{ GLuint buffersize ;
  float acc_scale ;
  void *tmp ;
  GLaccum r ;
  GLaccum g ;
  GLaccum b ;
  GLaccum a ;
  GLint i ;
  GLint j ;
  GLint width ;
  GLint height ;
  GLaccum *row ;
  GLaccum *acc ;
  GLaccum r___0 ;
  GLaccum g___0 ;
  GLaccum b___0 ;
  GLaccum a___0 ;
  GLuint i___0 ;
  GLaccum *tmp___0 ;
  GLaccum *tmp___1 ;
  GLaccum *tmp___2 ;
  GLaccum *tmp___3 ;

  {
#line 3706
  if ((ctx->Visual)->AccumBits == 0) {
#line 3707
    return;
  }
#line 3709
  if (sizeof(GLaccum ) == 1U) {
#line 3710
    acc_scale = (float )127.0;
  } else {
#line 3712
    if (sizeof(GLaccum ) == 2U) {
#line 3713
      acc_scale = (float )32767.0;
    } else {
#line 3716
      acc_scale = (float )32767;
    }
  }
#line 3718
  buffersize = (unsigned int )((ctx->Buffer)->Width * (ctx->Buffer)->Height);
#line 3719
  if (! (ctx->Buffer)->Accum) {
#line 3720
    tmp = malloc((buffersize * 4U) * sizeof(GLaccum ));//51
#line 3720
    (ctx->Buffer)->Accum = (GLaccum *)tmp;
  }
#line 3723
  if ((ctx->Buffer)->Accum) {
#line 3724
    if (ctx->Scissor.Enabled) {
#line 3730
      r = (signed char )(ctx->Accum.ClearColor[0] * acc_scale);
#line 3731
      g = (signed char )(ctx->Accum.ClearColor[1] * acc_scale);
#line 3732
      b = (signed char )(ctx->Accum.ClearColor[2] * acc_scale);
#line 3733
      a = (signed char )(ctx->Accum.ClearColor[3] * acc_scale);
#line 3734
      width = 4 * (((ctx->Buffer)->Xmax - (ctx->Buffer)->Xmin) + 1);
#line 3735
      height = ((ctx->Buffer)->Ymax - (ctx->Buffer)->Ymin) + 1;
#line 3736
      row = (ctx->Buffer)->Accum + 4 * ((ctx->Buffer)->Ymin * (ctx->Buffer)->Width + (ctx->Buffer)->Xmin);
#line 3739
      j = 0;
#line 3739
      while (j < height) {
#line 3740
        i = 0;
#line 3740
        while (i < width) {
#line 3741
          *(row + i) = r;
#line 3742
          *(row + (i + 1)) = g;
#line 3743
          *(row + (i + 2)) = b;
#line 3744
          *(row + (i + 3)) = a;
#line 3740
          i += 4;
        }
#line 3746
        row += 4 * (ctx->Buffer)->Width;
#line 3739
        j ++;
      }
    } else {
#line 3751
      if ((double )ctx->Accum.ClearColor[0] == 0.0) {
#line 3751
        if ((double )ctx->Accum.ClearColor[1] == 0.0) {
#line 3751
          if ((double )ctx->Accum.ClearColor[2] == 0.0) {
#line 3751
            if ((double )ctx->Accum.ClearColor[3] == 0.0) {
#line 3756
              memset((void *)(ctx->Buffer)->Accum, 0, (buffersize * 4U) * sizeof(GLaccum ));
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 3762
        acc = (ctx->Buffer)->Accum;
#line 3763
        r___0 = (signed char )(ctx->Accum.ClearColor[0] * acc_scale);
#line 3764
        g___0 = (signed char )(ctx->Accum.ClearColor[1] * acc_scale);
#line 3765
        b___0 = (signed char )(ctx->Accum.ClearColor[2] * acc_scale);
#line 3766
        a___0 = (signed char )(ctx->Accum.ClearColor[3] * acc_scale);
#line 3767
        i___0 = 0U;
#line 3767
        while (i___0 < buffersize) {
#line 3768
          tmp___0 = acc;
#line 3768
          acc ++;
#line 3768
          *tmp___0 = r___0;
#line 3769
          tmp___1 = acc;
#line 3769
          acc ++;
#line 3769
          *tmp___1 = g___0;
#line 3770
          tmp___2 = acc;
#line 3770
          acc ++;
#line 3770
          *tmp___2 = b___0;
#line 3771
          tmp___3 = acc;
#line 3771
          acc ++;
#line 3771
          *tmp___3 = a___0;
#line 3767
          i___0 ++;
        }
      }
    }
  }
#line 3776
  return;
}
}
#line 3782 "D:/a/test/177.c"
void gl_AlphaFunc(GLcontext *ctx , GLenum func , GLclampf ref ) 
{ float tmp ;

  {
#line 3784
  if (ctx->Primitive != 6656) {
#line 3785
    gl_error(ctx, 1282, "glAlphaFunc");
#line 3786
    return;
  }
#line 3788
  switch (func) {
  case 512: 
  case 513: 
  case 514: 
  case 515: 
  case 516: 
  case 517: 
  case 518: 
  case 519: 
#line 3797
  ctx->Color.AlphaFunc = func;
#line 3798
  if (ref < 0.0F) {
#line 3798
    ctx->Color.AlphaRef = 0.0F;
  } else {
#line 3798
    if (ref > 1.0F) {
#line 3798
      tmp = 1.0F;
    } else {
#line 3798
      tmp = ref;
    }
#line 3798
    ctx->Color.AlphaRef = tmp;
  }
#line 3799
  ctx->Color.AlphaRefUbyte = (unsigned char )(ctx->Color.AlphaRef * (ctx->Visual)->AlphaScale);
#line 3801
  break;
  default: 
#line 3803
  gl_error(ctx, 1280, "glAlphaFunc(func)");
#line 3804
  break;
  }
#line 3806
  return;
}
}
#line 3849
void gl_problem(GLcontext const   *ctx , char const   *s ) ;
#line 3807 "D:/a/test/177.c"
GLint gl_alpha_test(GLcontext *ctx , GLuint n , GLubyte const   *alpha , GLubyte *mask ) 
{ GLuint i ;
  GLubyte ref ;

  {
#line 3811
  ref = ctx->Color.AlphaRefUbyte;
#line 3812
  switch (ctx->Color.AlphaFunc) {
  case 513: 
#line 3814
  i = 0U;
#line 3814
  while (i < n) {
#line 3815
    *(mask + i) = (unsigned char )((int )*(mask + i) & ((int const   )*(alpha + i) < (int const   )ref));
#line 3814
    i ++;
  }
#line 3817
  return (1);
  case 515: 
#line 3819
  i = 0U;
#line 3819
  while (i < n) {
#line 3820
    *(mask + i) = (unsigned char )((int )*(mask + i) & ((int const   )*(alpha + i) <= (int const   )ref));
#line 3819
    i ++;
  }
#line 3822
  return (1);
  case 518: 
#line 3824
  i = 0U;
#line 3824
  while (i < n) {
#line 3825
    *(mask + i) = (unsigned char )((int )*(mask + i) & ((int const   )*(alpha + i) >= (int const   )ref));
#line 3824
    i ++;
  }
#line 3827
  return (1);
  case 516: 
#line 3829
  i = 0U;
#line 3829
  while (i < n) {
#line 3830
    *(mask + i) = (unsigned char )((int )*(mask + i) & ((int const   )*(alpha + i) > (int const   )ref));
#line 3829
    i ++;
  }
#line 3832
  return (1);
  case 517: 
#line 3834
  i = 0U;
#line 3834
  while (i < n) {
#line 3835
    *(mask + i) = (unsigned char )((int )*(mask + i) & ((int const   )*(alpha + i) != (int const   )ref));
#line 3834
    i ++;
  }
#line 3837
  return (1);
  case 514: 
#line 3839
  i = 0U;
#line 3839
  while (i < n) {
#line 3840
    *(mask + i) = (unsigned char )((int )*(mask + i) & ((int const   )*(alpha + i) == (int const   )ref));
#line 3839
    i ++;
  }
#line 3842
  return (1);
  case 519: 
#line 3845
  return (1);
  case 512: 
#line 3847
  return (0);
  default: 
#line 3849
  gl_problem(ctx, "Invalid alpha test in gl_alpha_test");
#line 3850
  return (0);
  }
#line 3852
  return (1);
}
}
#line 3860 "D:/a/test/177.c"
void gl_alloc_alpha_buffers(GLcontext *ctx ) 
{ GLint bytes ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 3862
  bytes = (GLint )((unsigned int )((ctx->Buffer)->Width * (ctx->Buffer)->Height) * sizeof(GLubyte ));
#line 3863
  if ((ctx->Visual)->FrontAlphaEnabled) {
#line 3864
    if ((ctx->Buffer)->FrontAlpha) {
#line 3865
      free((void *)(ctx->Buffer)->FrontAlpha);
    }
#line 3867
    tmp = malloc((unsigned int )bytes);//52
#line 3867
    (ctx->Buffer)->FrontAlpha = (GLubyte *)tmp;
#line 3868
    if (! (ctx->Buffer)->FrontAlpha) {
#line 3869
      gl_error(ctx, 1285, "Couldn\'t allocate front alpha buffer");
    }
  }
#line 3872
  if ((ctx->Visual)->BackAlphaEnabled) {
#line 3873
    if ((ctx->Buffer)->BackAlpha) {
#line 3874
      free((void *)(ctx->Buffer)->BackAlpha);
    }
#line 3876
    tmp___0 = malloc((unsigned int )bytes);//54
#line 3876
    (ctx->Buffer)->BackAlpha = (GLubyte *)tmp___0;
#line 3877
    if (! (ctx->Buffer)->BackAlpha) {
#line 3878
      gl_error(ctx, 1285, "Couldn\'t allocate back alpha buffer");
    }
  }
#line 3881
  if (ctx->Color.DrawBuffer == 1028) {
#line 3882
    (ctx->Buffer)->Alpha = (ctx->Buffer)->FrontAlpha;
  }
#line 3884
  if (ctx->Color.DrawBuffer == 1029) {
#line 3885
    (ctx->Buffer)->Alpha = (ctx->Buffer)->BackAlpha;
  }
#line 3887
  return;
}
}
#line 3888 "D:/a/test/177.c"
void gl_clear_alpha_buffers(GLcontext *ctx ) 
{ GLint buffer ;
  GLubyte *abuffer ;
  GLubyte aclear ;
  GLint i ;
  GLint j ;
  GLubyte *aptr ;
  GLubyte *tmp ;

  {
#line 3891
  buffer = 0;
#line 3891
  while (buffer < 2) {
#line 3892
    abuffer = (GLubyte *)((void *)0);
#line 3893
    if (buffer == 0) {
#line 3893
      if (ctx->Color.DrawBuffer == 1028) {
        goto _L___3;
      } else {
#line 3893
        if (ctx->Color.DrawBuffer == 1032) {
          _L___3: /* CIL Label */ 
#line 3893
          if ((ctx->Visual)->FrontAlphaEnabled) {
#line 3893
            if ((ctx->Buffer)->FrontAlpha) {
#line 3897
              abuffer = (ctx->Buffer)->FrontAlpha;
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      }
    } else {
      _L___2: /* CIL Label */ 
#line 3899
      if (buffer == 1) {
#line 3899
        if (ctx->Color.DrawBuffer == 1029) {
          goto _L;
        } else {
#line 3899
          if (ctx->Color.DrawBuffer == 1032) {
            _L: /* CIL Label */ 
#line 3899
            if ((ctx->Visual)->BackAlphaEnabled) {
#line 3899
              if ((ctx->Buffer)->BackAlpha) {
#line 3903
                abuffer = (ctx->Buffer)->BackAlpha;
              }
            }
          }
        }
      }
    }
#line 3905
    if (abuffer) {
#line 3906
      aclear = (GLubyte )((int )(ctx->Color.ClearColor[3] * (ctx->Visual)->AlphaScale));
#line 3908
      if (ctx->Scissor.Enabled) {
#line 3910
        j = 0;
#line 3910
        while (j < ctx->Scissor.Height) {
#line 3911
          aptr = ((ctx->Buffer)->Alpha + ((ctx->Buffer)->Ymin + j) * (ctx->Buffer)->Width) + (ctx->Buffer)->Xmin;
#line 3913
          i = 0;
#line 3913
          while (i < ctx->Scissor.Width) {
#line 3914
            tmp = aptr;
#line 3914
            aptr ++;
#line 3914
            *tmp = aclear;
#line 3913
            i ++;
          }
#line 3910
          j ++;
        }
      } else {
#line 3919
        memset((void *)abuffer, (int )aclear, (unsigned int )((ctx->Buffer)->Width * (ctx->Buffer)->Height));
      }
    }
#line 3891
    buffer ++;
  }
#line 3923
  return;
}
}
#line 3924 "D:/a/test/177.c"
void gl_write_alpha_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *alpha ,
                         GLubyte *mask ) 
{ GLubyte *aptr ;
  GLuint i ;
  GLubyte *tmp ;

  {
#line 3927
  aptr = ((ctx->Buffer)->Alpha + y * (ctx->Buffer)->Width) + x;
#line 3929
  if (mask) {
#line 3930
    i = 0U;
#line 3930
    while (i < n) {
#line 3931
      if (*(mask + i)) {
#line 3932
        *aptr = *(alpha + i);
      }
#line 3934
      aptr ++;
#line 3930
      i ++;
    }
  } else {
#line 3938
    i = 0U;
#line 3938
    while (i < n) {
#line 3939
      tmp = aptr;
#line 3939
      aptr ++;
#line 3939
      *tmp = *(alpha + i);
#line 3938
      i ++;
    }
  }
#line 3942
  return;
}
}
#line 3943 "D:/a/test/177.c"
void gl_write_mono_alpha_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte alpha ,
                              GLubyte *mask ) 
{ GLubyte *aptr ;
  GLuint i ;
  GLubyte *tmp ;

  {
#line 3946
  aptr = ((ctx->Buffer)->Alpha + y * (ctx->Buffer)->Width) + x;
#line 3948
  if (mask) {
#line 3949
    i = 0U;
#line 3949
    while (i < n) {
#line 3950
      if (*(mask + i)) {
#line 3951
        *aptr = alpha;
      }
#line 3953
      aptr ++;
#line 3949
      i ++;
    }
  } else {
#line 3957
    i = 0U;
#line 3957
    while (i < n) {
#line 3958
      tmp = aptr;
#line 3958
      aptr ++;
#line 3958
      *tmp = alpha;
#line 3957
      i ++;
    }
  }
#line 3961
  return;
}
}
#line 3962 "D:/a/test/177.c"
void gl_write_alpha_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                           GLubyte const   *alpha , GLubyte const   *mask ) 
{ GLuint i ;
  GLubyte *aptr ;
  GLubyte *aptr___0 ;

  {
#line 3967
  if (mask) {
#line 3968
    i = 0U;
#line 3968
    while (i < n) {
#line 3969
      if (*(mask + i)) {
#line 3970
        aptr = ((ctx->Buffer)->Alpha + *(y + i) * (GLint const   )(ctx->Buffer)->Width) + *(x + i);
#line 3971
        *aptr = (unsigned char )*(alpha + i);
      }
#line 3968
      i ++;
    }
  } else {
#line 3976
    i = 0U;
#line 3976
    while (i < n) {
#line 3977
      aptr___0 = ((ctx->Buffer)->Alpha + *(y + i) * (GLint const   )(ctx->Buffer)->Width) + *(x + i);
#line 3978
      *aptr___0 = (unsigned char )*(alpha + i);
#line 3976
      i ++;
    }
  }
#line 3981
  return;
}
}
#line 3982 "D:/a/test/177.c"
void gl_write_mono_alpha_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                                GLubyte alpha , GLubyte const   *mask ) 
{ GLuint i ;
  GLubyte *aptr ;
  GLubyte *aptr___0 ;

  {
#line 3987
  if (mask) {
#line 3988
    i = 0U;
#line 3988
    while (i < n) {
#line 3989
      if (*(mask + i)) {
#line 3990
        aptr = ((ctx->Buffer)->Alpha + *(y + i) * (GLint const   )(ctx->Buffer)->Width) + *(x + i);
#line 3991
        *aptr = alpha;
      }
#line 3988
      i ++;
    }
  } else {
#line 3996
    i = 0U;
#line 3996
    while (i < n) {
#line 3997
      aptr___0 = ((ctx->Buffer)->Alpha + *(y + i) * (GLint const   )(ctx->Buffer)->Width) + *(x + i);
#line 3998
      *aptr___0 = alpha;
#line 3996
      i ++;
    }
  }
#line 4001
  return;
}
}
#line 4002 "D:/a/test/177.c"
void gl_read_alpha_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *alpha ) 
{ GLubyte *aptr ;
  GLuint i ;
  GLubyte *tmp ;

  {
#line 4005
  aptr = ((ctx->Buffer)->Alpha + y * (ctx->Buffer)->Width) + x;
#line 4007
  i = 0U;
#line 4007
  while (i < n) {
#line 4008
    tmp = aptr;
#line 4008
    aptr ++;
#line 4008
    *(alpha + i) = *tmp;
#line 4007
    i ++;
  }
#line 4010
  return;
}
}
#line 4011 "D:/a/test/177.c"
void gl_read_alpha_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                          GLubyte *alpha , GLubyte const   *mask ) 
{ GLuint i ;
  GLubyte *aptr ;

  {
#line 4016
  i = 0U;
#line 4016
  while (i < n) {
#line 4017
    if (*(mask + i)) {
#line 4018
      aptr = ((ctx->Buffer)->Alpha + *(y + i) * (GLint const   )(ctx->Buffer)->Width) + *(x + i);
#line 4019
      *(alpha + i) = *aptr;
    }
#line 4016
    i ++;
  }
#line 4022
  return;
}
}
#line 4037
extern int ( /* missing proto */  gl_get_thread_context)() ;
#line 4035 "D:/a/test/177.c"
void glAccum(GLenum op , float value ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4037
  tmp = gl_get_thread_context();
#line 4037
  CC = (GLcontext *)tmp;
#line 4038
  if (! CC) {
#line 4038
    tmp___1 = getenv("MESA_DEBUG");
#line 4038
    if (tmp___1) {
#line 4038
      tmp___0 = __getreent();
#line 4038
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4038
    return;
  }
#line 4039
  (*(CC->API.Accum))(CC, op, value);
#line 4040
  return;
}
}
#line 4041 "D:/a/test/177.c"
void glAlphaFunc(GLenum func , GLclampf ref ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4043
  tmp = gl_get_thread_context();
#line 4043
  CC = (GLcontext *)tmp;
#line 4044
  if (! CC) {
#line 4044
    tmp___1 = getenv("MESA_DEBUG");
#line 4044
    if (tmp___1) {
#line 4044
      tmp___0 = __getreent();
#line 4044
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4044
    return;
  }
#line 4045
  (*(CC->API.AlphaFunc))(CC, func, ref);
#line 4046
  return;
}
}
#line 4051
extern int ( /* missing proto */  CHECK_CONTEXT_RETURN)(int x) ;
#line 4047 "D:/a/test/177.c"
GLboolean glAreTexturesResident(GLsizei n , GLuint const   *textures , GLboolean *residences ) 
{ GLcontext *CC ;
  int tmp ;
  GLboolean tmp___0 ;

  {
#line 4050
  tmp = gl_get_thread_context();
#line 4050
  CC = (GLcontext *)tmp;
#line 4051
  CHECK_CONTEXT_RETURN(0);
#line 4052
  tmp___0 = (*(CC->API.AreTexturesResident))(CC, n, textures, residences);
#line 4052
  return (tmp___0);
}
}
#line 4054 "D:/a/test/177.c"
void glArrayElement(GLint i ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4056
  tmp = gl_get_thread_context();
#line 4056
  CC = (GLcontext *)tmp;
#line 4057
  if (! CC) {
#line 4057
    tmp___1 = getenv("MESA_DEBUG");
#line 4057
    if (tmp___1) {
#line 4057
      tmp___0 = __getreent();
#line 4057
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4057
    return;
  }
#line 4058
  (*(CC->API.ArrayElement))(CC, i);
#line 4059
  return;
}
}
#line 4060 "D:/a/test/177.c"
void glBegin(GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4062
  tmp = gl_get_thread_context();
#line 4062
  CC = (GLcontext *)tmp;
#line 4063
  if (! CC) {
#line 4063
    tmp___1 = getenv("MESA_DEBUG");
#line 4063
    if (tmp___1) {
#line 4063
      tmp___0 = __getreent();
#line 4063
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4063
    return;
  }
#line 4064
  (*(CC->API.Begin))(CC, mode);
#line 4065
  return;
}
}
#line 4066 "D:/a/test/177.c"
void glBindTexture(GLenum target , GLuint texture ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4068
  tmp = gl_get_thread_context();
#line 4068
  CC = (GLcontext *)tmp;
#line 4069
  if (! CC) {
#line 4069
    tmp___1 = getenv("MESA_DEBUG");
#line 4069
    if (tmp___1) {
#line 4069
      tmp___0 = __getreent();
#line 4069
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4069
    return;
  }
#line 4070
  (*(CC->API.BindTexture))(CC, target, texture);
#line 4071
  return;
}
}
#line 4097
struct gl_image *gl_unpack_bitmap(GLcontext *ctx , GLsizei width , GLsizei height ,
                                  GLubyte const   *bitmap ) ;
#line 4101
void gl_free_image(struct gl_image *image ) ;
#line 4072 "D:/a/test/177.c"
void glBitmap(GLsizei width , GLsizei height , float xorig , float yorig , float xmove ,
              float ymove , GLubyte const   *bitmap ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  struct gl_image image ;
  struct gl_image *image___0 ;
  int tmp___2 ;
  struct gl_image *image___1 ;
  int tmp___3 ;

  {
#line 4077
  tmp = gl_get_thread_context();
#line 4077
  CC = (GLcontext *)tmp;
#line 4078
  if (! CC) {
#line 4078
    tmp___1 = getenv("MESA_DEBUG");
#line 4078
    if (tmp___1) {
#line 4078
      tmp___0 = __getreent();
#line 4078
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4078
    return;
  }
#line 4079
  if (! CC->CompileFlag) {
#line 4080
    if ((int )CC->Unpack.LsbFirst == 0) {
#line 4080
      if (CC->Unpack.Alignment == 1) {
#line 4080
        if (CC->Unpack.RowLength == 0) {
#line 4080
          if (CC->Unpack.SkipPixels == 0) {
#line 4080
            if (CC->Unpack.SkipRows == 0) {
#line 4086
              image.Width = width;
#line 4087
              image.Height = height;
#line 4088
              image.Components = 0;
#line 4089
              image.Type = 6656;
#line 4090
              image.Format = 6400;
#line 4091
              image.Data = (GLvoid *)bitmap;
#line 4092
              (*(CC->Exec.Bitmap))(CC, width, height, xorig, yorig, xmove, ymove,
                                   (struct gl_image  const  *)(& image));
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 4097
      tmp___2 = (int )gl_unpack_bitmap(CC, width, height, bitmap);
#line 4097
      image___0 = (struct gl_image *)tmp___2;
#line 4098
      (*(CC->Exec.Bitmap))(CC, width, height, xorig, yorig, xmove, ymove, (struct gl_image  const  *)image___0);
#line 4100
      if (image___0) {
#line 4101
        gl_free_image(image___0);
      }
    }
  } else {
#line 4107
    tmp___3 = (int )gl_unpack_bitmap(CC, width, height, bitmap);
#line 4107
    image___1 = (struct gl_image *)tmp___3;
#line 4108
    (*(CC->API.Bitmap))(CC, width, height, xorig, yorig, xmove, ymove, (struct gl_image  const  *)image___1);
  }
#line 4110
  return;
}
}
#line 4111 "D:/a/test/177.c"
void glBlendFunc(GLenum sfactor , GLenum dfactor ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4113
  tmp = gl_get_thread_context();
#line 4113
  CC = (GLcontext *)tmp;
#line 4114
  if (! CC) {
#line 4114
    tmp___1 = getenv("MESA_DEBUG");
#line 4114
    if (tmp___1) {
#line 4114
      tmp___0 = __getreent();
#line 4114
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4114
    return;
  }
#line 4115
  (*(CC->API.BlendFunc))(CC, sfactor, dfactor);
#line 4116
  return;
}
}
#line 4117 "D:/a/test/177.c"
void glCallList(GLuint list ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4119
  tmp = gl_get_thread_context();
#line 4119
  CC = (GLcontext *)tmp;
#line 4120
  if (! CC) {
#line 4120
    tmp___1 = getenv("MESA_DEBUG");
#line 4120
    if (tmp___1) {
#line 4120
      tmp___0 = __getreent();
#line 4120
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4120
    return;
  }
#line 4121
  (*(CC->API.CallList))(CC, list);
#line 4122
  return;
}
}
#line 4123 "D:/a/test/177.c"
void glCallLists(GLsizei n , GLenum type , GLvoid const   *lists ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4125
  tmp = gl_get_thread_context();
#line 4125
  CC = (GLcontext *)tmp;
#line 4126
  if (! CC) {
#line 4126
    tmp___1 = getenv("MESA_DEBUG");
#line 4126
    if (tmp___1) {
#line 4126
      tmp___0 = __getreent();
#line 4126
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4126
    return;
  }
#line 4127
  (*(CC->API.CallLists))(CC, n, type, lists);
#line 4128
  return;
}
}
#line 4129 "D:/a/test/177.c"
void glClear(GLbitfield mask ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4131
  tmp = gl_get_thread_context();
#line 4131
  CC = (GLcontext *)tmp;
#line 4132
  if (! CC) {
#line 4132
    tmp___1 = getenv("MESA_DEBUG");
#line 4132
    if (tmp___1) {
#line 4132
      tmp___0 = __getreent();
#line 4132
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4132
    return;
  }
#line 4133
  (*(CC->API.Clear))(CC, mask);
#line 4134
  return;
}
}
#line 4135 "D:/a/test/177.c"
void glClearAccum(float red , float green , float blue___0 , float alpha ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4138
  tmp = gl_get_thread_context();
#line 4138
  CC = (GLcontext *)tmp;
#line 4139
  if (! CC) {
#line 4139
    tmp___1 = getenv("MESA_DEBUG");
#line 4139
    if (tmp___1) {
#line 4139
      tmp___0 = __getreent();
#line 4139
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4139
    return;
  }
#line 4140
  (*(CC->API.ClearAccum))(CC, red, green, blue___0, alpha);
#line 4141
  return;
}
}
#line 4142 "D:/a/test/177.c"
void glClearIndex(float c ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4144
  tmp = gl_get_thread_context();
#line 4144
  CC = (GLcontext *)tmp;
#line 4145
  if (! CC) {
#line 4145
    tmp___1 = getenv("MESA_DEBUG");
#line 4145
    if (tmp___1) {
#line 4145
      tmp___0 = __getreent();
#line 4145
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4145
    return;
  }
#line 4146
  (*(CC->API.ClearIndex))(CC, c);
#line 4147
  return;
}
}
#line 4148 "D:/a/test/177.c"
void glClearColor(GLclampf red , GLclampf green , GLclampf blue___0 , GLclampf alpha ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4153
  tmp = gl_get_thread_context();
#line 4153
  CC = (GLcontext *)tmp;
#line 4154
  if (! CC) {
#line 4154
    tmp___1 = getenv("MESA_DEBUG");
#line 4154
    if (tmp___1) {
#line 4154
      tmp___0 = __getreent();
#line 4154
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4154
    return;
  }
#line 4155
  (*(CC->API.ClearColor))(CC, red, green, blue___0, alpha);
#line 4156
  return;
}
}
#line 4157 "D:/a/test/177.c"
void glClearDepth(GLclampd depth ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4159
  tmp = gl_get_thread_context();
#line 4159
  CC = (GLcontext *)tmp;
#line 4160
  if (! CC) {
#line 4160
    tmp___1 = getenv("MESA_DEBUG");
#line 4160
    if (tmp___1) {
#line 4160
      tmp___0 = __getreent();
#line 4160
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4160
    return;
  }
#line 4161
  (*(CC->API.ClearDepth))(CC, depth);
#line 4162
  return;
}
}
#line 4163 "D:/a/test/177.c"
void glClearStencil(GLint s ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4165
  tmp = gl_get_thread_context();
#line 4165
  CC = (GLcontext *)tmp;
#line 4166
  if (! CC) {
#line 4166
    tmp___1 = getenv("MESA_DEBUG");
#line 4166
    if (tmp___1) {
#line 4166
      tmp___0 = __getreent();
#line 4166
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4166
    return;
  }
#line 4167
  (*(CC->API.ClearStencil))(CC, s);
#line 4168
  return;
}
}
#line 4169 "D:/a/test/177.c"
void glClipPlane(GLenum plane , GLdouble const   *equation ) 
{ float eq[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4172
  tmp = gl_get_thread_context();
#line 4172
  CC = (GLcontext *)tmp;
#line 4173
  if (! CC) {
#line 4173
    tmp___1 = getenv("MESA_DEBUG");
#line 4173
    if (tmp___1) {
#line 4173
      tmp___0 = __getreent();
#line 4173
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4173
    return;
  }
#line 4174
  eq[0] = (float )*(equation + 0);
#line 4175
  eq[1] = (float )*(equation + 1);
#line 4176
  eq[2] = (float )*(equation + 2);
#line 4177
  eq[3] = (float )*(equation + 3);
#line 4178
  (*(CC->API.ClipPlane))(CC, plane, (float const   *)(eq));
#line 4179
  return;
}
}
#line 4180 "D:/a/test/177.c"
void glColor3b(GLbyte red , GLbyte green , GLbyte blue___0 ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4182
  tmp = gl_get_thread_context();
#line 4182
  CC = (GLcontext *)tmp;
#line 4183
  (*(CC->API.Color3f))(CC, (2.0F * (float )red + 1.0F) * (1.0F / 255.0F), (2.0F * (float )green + 1.0F) * (1.0F / 255.0F),
                       (2.0F * (float )blue___0 + 1.0F) * (1.0F / 255.0F));
#line 4185
  return;
}
}
#line 4186 "D:/a/test/177.c"
void glColor3d(GLdouble red , GLdouble green , GLdouble blue___0 ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4188
  tmp = gl_get_thread_context();
#line 4188
  CC = (GLcontext *)tmp;
#line 4189
  (*(CC->API.Color3f))(CC, (float )red, (float )green, (float )blue___0);
#line 4190
  return;
}
}
#line 4191 "D:/a/test/177.c"
void glColor3f(float red , float green , float blue___0 ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4193
  tmp = gl_get_thread_context();
#line 4193
  CC = (GLcontext *)tmp;
#line 4194
  (*(CC->API.Color3f))(CC, red, green, blue___0);
#line 4195
  return;
}
}
#line 4196 "D:/a/test/177.c"
void glColor3i(GLint red , GLint green , GLint blue___0 ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4198
  tmp = gl_get_thread_context();
#line 4198
  CC = (GLcontext *)tmp;
#line 4199
  (*(CC->API.Color3f))(CC, (2.0F * (float )red + 1.0F) * (1.0F / 4294967294.0F), (2.0F * (float )green + 1.0F) * (1.0F / 4294967294.0F),
                       (2.0F * (float )blue___0 + 1.0F) * (1.0F / 4294967294.0F));
#line 4201
  return;
}
}
#line 4202 "D:/a/test/177.c"
void glColor3s(GLshort red , GLshort green , GLshort blue___0 ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4204
  tmp = gl_get_thread_context();
#line 4204
  CC = (GLcontext *)tmp;
#line 4205
  (*(CC->API.Color3f))(CC, (2.0F * (float )red + 1.0F) * (1.0F / 65535.0F), (2.0F * (float )green + 1.0F) * (1.0F / 65535.0F),
                       (2.0F * (float )blue___0 + 1.0F) * (1.0F / 65535.0F));
#line 4207
  return;
}
}
#line 4208 "D:/a/test/177.c"
void glColor3ub(GLubyte red , GLubyte green , GLubyte blue___0 ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4210
  tmp = gl_get_thread_context();
#line 4210
  CC = (GLcontext *)tmp;
#line 4211
  (*(CC->API.Color4ub))(CC, red, green, blue___0, (unsigned char)255);
#line 4212
  return;
}
}
#line 4213 "D:/a/test/177.c"
void glColor3ui(GLuint red , GLuint green , GLuint blue___0 ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4215
  tmp = gl_get_thread_context();
#line 4215
  CC = (GLcontext *)tmp;
#line 4216
  (*(CC->API.Color3f))(CC, (float )red * (1.0F / 4294967295.0F), (float )green * (1.0F / 4294967295.0F),
                       (float )blue___0 * (1.0F / 4294967295.0F));
#line 4218
  return;
}
}
#line 4219 "D:/a/test/177.c"
void glColor3us(GLushort red , GLushort green , GLushort blue___0 ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4221
  tmp = gl_get_thread_context();
#line 4221
  CC = (GLcontext *)tmp;
#line 4222
  (*(CC->API.Color3f))(CC, (float )red * (1.0F / 65535.0F), (float )green * (1.0F / 65535.0F),
                       (float )blue___0 * (1.0F / 65535.0F));
#line 4224
  return;
}
}
#line 4225 "D:/a/test/177.c"
void glColor4b(GLbyte red , GLbyte green , GLbyte blue___0 , GLbyte alpha ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4227
  tmp = gl_get_thread_context();
#line 4227
  CC = (GLcontext *)tmp;
#line 4228
  (*(CC->API.Color4f))(CC, (2.0F * (float )red + 1.0F) * (1.0F / 255.0F), (2.0F * (float )green + 1.0F) * (1.0F / 255.0F),
                       (2.0F * (float )blue___0 + 1.0F) * (1.0F / 255.0F), (2.0F * (float )alpha + 1.0F) * (1.0F / 255.0F));
#line 4230
  return;
}
}
#line 4231 "D:/a/test/177.c"
void glColor4d(GLdouble red , GLdouble green , GLdouble blue___0 , GLdouble alpha ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4233
  tmp = gl_get_thread_context();
#line 4233
  CC = (GLcontext *)tmp;
#line 4234
  (*(CC->API.Color4f))(CC, (float )red, (float )green, (float )blue___0, (float )alpha);
#line 4236
  return;
}
}
#line 4237 "D:/a/test/177.c"
void glColor4f(float red , float green , float blue___0 , float alpha ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4239
  tmp = gl_get_thread_context();
#line 4239
  CC = (GLcontext *)tmp;
#line 4240
  (*(CC->API.Color4f))(CC, red, green, blue___0, alpha);
#line 4241
  return;
}
}
#line 4242 "D:/a/test/177.c"
void glColor4i(GLint red , GLint green , GLint blue___0 , GLint alpha ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4244
  tmp = gl_get_thread_context();
#line 4244
  CC = (GLcontext *)tmp;
#line 4245
  (*(CC->API.Color4f))(CC, (2.0F * (float )red + 1.0F) * (1.0F / 4294967294.0F), (2.0F * (float )green + 1.0F) * (1.0F / 4294967294.0F),
                       (2.0F * (float )blue___0 + 1.0F) * (1.0F / 4294967294.0F),
                       (2.0F * (float )alpha + 1.0F) * (1.0F / 4294967294.0F));
#line 4247
  return;
}
}
#line 4248 "D:/a/test/177.c"
void glColor4s(GLshort red , GLshort green , GLshort blue___0 , GLshort alpha ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4250
  tmp = gl_get_thread_context();
#line 4250
  CC = (GLcontext *)tmp;
#line 4251
  (*(CC->API.Color4f))(CC, (2.0F * (float )red + 1.0F) * (1.0F / 65535.0F), (2.0F * (float )green + 1.0F) * (1.0F / 65535.0F),
                       (2.0F * (float )blue___0 + 1.0F) * (1.0F / 65535.0F), (2.0F * (float )alpha + 1.0F) * (1.0F / 65535.0F));
#line 4253
  return;
}
}
#line 4254 "D:/a/test/177.c"
void glColor4ub(GLubyte red , GLubyte green , GLubyte blue___0 , GLubyte alpha ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4256
  tmp = gl_get_thread_context();
#line 4256
  CC = (GLcontext *)tmp;
#line 4257
  (*(CC->API.Color4ub))(CC, red, green, blue___0, alpha);
#line 4258
  return;
}
}
#line 4259 "D:/a/test/177.c"
void glColor4ui(GLuint red , GLuint green , GLuint blue___0 , GLuint alpha ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4261
  tmp = gl_get_thread_context();
#line 4261
  CC = (GLcontext *)tmp;
#line 4262
  (*(CC->API.Color4f))(CC, (float )red * (1.0F / 4294967295.0F), (float )green * (1.0F / 4294967295.0F),
                       (float )blue___0 * (1.0F / 4294967295.0F), (float )alpha * (1.0F / 4294967295.0F));
#line 4264
  return;
}
}
#line 4265 "D:/a/test/177.c"
void glColor4us(GLushort red , GLushort green , GLushort blue___0 , GLushort alpha ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4267
  tmp = gl_get_thread_context();
#line 4267
  CC = (GLcontext *)tmp;
#line 4268
  (*(CC->API.Color4f))(CC, (float )red * (1.0F / 65535.0F), (float )green * (1.0F / 65535.0F),
                       (float )blue___0 * (1.0F / 65535.0F), (float )alpha * (1.0F / 65535.0F));
#line 4270
  return;
}
}
#line 4271 "D:/a/test/177.c"
void glColor3bv(GLbyte const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4273
  tmp = gl_get_thread_context();
#line 4273
  CC = (GLcontext *)tmp;
#line 4274
  (*(CC->API.Color3f))(CC, (2.0F * (float )*(v + 0) + 1.0F) * (1.0F / 255.0F), (2.0F * (float )*(v + 1) + 1.0F) * (1.0F / 255.0F),
                       (2.0F * (float )*(v + 2) + 1.0F) * (1.0F / 255.0F));
#line 4276
  return;
}
}
#line 4277 "D:/a/test/177.c"
void glColor3dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4279
  tmp = gl_get_thread_context();
#line 4279
  CC = (GLcontext *)tmp;
#line 4280
  (*(CC->API.Color3f))(CC, (float )((double )*(v + 0)), (float )((double )*(v + 1)),
                       (float )((double )*(v + 2)));
#line 4281
  return;
}
}
#line 4282 "D:/a/test/177.c"
void glColor3fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4284
  tmp = gl_get_thread_context();
#line 4284
  CC = (GLcontext *)tmp;
#line 4285
  (*(CC->API.Color3fv))(CC, v);
#line 4286
  return;
}
}
#line 4287 "D:/a/test/177.c"
void glColor3iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4289
  tmp = gl_get_thread_context();
#line 4289
  CC = (GLcontext *)tmp;
#line 4290
  (*(CC->API.Color3f))(CC, (2.0F * (float )*(v + 0) + 1.0F) * (1.0F / 4294967294.0F),
                       (2.0F * (float )*(v + 1) + 1.0F) * (1.0F / 4294967294.0F),
                       (2.0F * (float )*(v + 2) + 1.0F) * (1.0F / 4294967294.0F));
#line 4292
  return;
}
}
#line 4293 "D:/a/test/177.c"
void glColor3sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4295
  tmp = gl_get_thread_context();
#line 4295
  CC = (GLcontext *)tmp;
#line 4296
  (*(CC->API.Color3f))(CC, (2.0F * (float )*(v + 0) + 1.0F) * (1.0F / 65535.0F), (2.0F * (float )*(v + 1) + 1.0F) * (1.0F / 65535.0F),
                       (2.0F * (float )*(v + 2) + 1.0F) * (1.0F / 65535.0F));
#line 4298
  return;
}
}
#line 4299 "D:/a/test/177.c"
void glColor3ubv(GLubyte const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4301
  tmp = gl_get_thread_context();
#line 4301
  CC = (GLcontext *)tmp;
#line 4302
  (*(CC->API.Color4ub))(CC, (unsigned char )*(v + 0), (unsigned char )*(v + 1), (unsigned char )*(v + 2),
                        (unsigned char)255);
#line 4303
  return;
}
}
#line 4304 "D:/a/test/177.c"
void glColor3uiv(GLuint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4306
  tmp = gl_get_thread_context();
#line 4306
  CC = (GLcontext *)tmp;
#line 4307
  (*(CC->API.Color3f))(CC, (float )*(v + 0) * (1.0F / 4294967295.0F), (float )*(v + 1) * (1.0F / 4294967295.0F),
                       (float )*(v + 2) * (1.0F / 4294967295.0F));
#line 4309
  return;
}
}
#line 4310 "D:/a/test/177.c"
void glColor3usv(GLushort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4312
  tmp = gl_get_thread_context();
#line 4312
  CC = (GLcontext *)tmp;
#line 4313
  (*(CC->API.Color3f))(CC, (float )*(v + 0) * (1.0F / 65535.0F), (float )*(v + 1) * (1.0F / 65535.0F),
                       (float )*(v + 2) * (1.0F / 65535.0F));
#line 4315
  return;
}
}
#line 4316 "D:/a/test/177.c"
void glColor4bv(GLbyte const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4318
  tmp = gl_get_thread_context();
#line 4318
  CC = (GLcontext *)tmp;
#line 4319
  (*(CC->API.Color4f))(CC, (2.0F * (float )*(v + 0) + 1.0F) * (1.0F / 255.0F), (2.0F * (float )*(v + 1) + 1.0F) * (1.0F / 255.0F),
                       (2.0F * (float )*(v + 2) + 1.0F) * (1.0F / 255.0F), (2.0F * (float )*(v + 3) + 1.0F) * (1.0F / 255.0F));
#line 4321
  return;
}
}
#line 4322 "D:/a/test/177.c"
void glColor4dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4324
  tmp = gl_get_thread_context();
#line 4324
  CC = (GLcontext *)tmp;
#line 4325
  (*(CC->API.Color4f))(CC, (float )((double )*(v + 0)), (float )((double )*(v + 1)),
                       (float )((double )*(v + 2)), (float )((double )*(v + 3)));
#line 4327
  return;
}
}
#line 4328 "D:/a/test/177.c"
void glColor4fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4330
  tmp = gl_get_thread_context();
#line 4330
  CC = (GLcontext *)tmp;
#line 4331
  (*(CC->API.Color4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2), (float )*(v + 3));
#line 4332
  return;
}
}
#line 4333 "D:/a/test/177.c"
void glColor4iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4335
  tmp = gl_get_thread_context();
#line 4335
  CC = (GLcontext *)tmp;
#line 4336
  (*(CC->API.Color4f))(CC, (2.0F * (float )*(v + 0) + 1.0F) * (1.0F / 4294967294.0F),
                       (2.0F * (float )*(v + 1) + 1.0F) * (1.0F / 4294967294.0F),
                       (2.0F * (float )*(v + 2) + 1.0F) * (1.0F / 4294967294.0F),
                       (2.0F * (float )*(v + 3) + 1.0F) * (1.0F / 4294967294.0F));
#line 4338
  return;
}
}
#line 4339 "D:/a/test/177.c"
void glColor4sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4341
  tmp = gl_get_thread_context();
#line 4341
  CC = (GLcontext *)tmp;
#line 4342
  (*(CC->API.Color4f))(CC, (2.0F * (float )*(v + 0) + 1.0F) * (1.0F / 65535.0F), (2.0F * (float )*(v + 1) + 1.0F) * (1.0F / 65535.0F),
                       (2.0F * (float )*(v + 2) + 1.0F) * (1.0F / 65535.0F), (2.0F * (float )*(v + 3) + 1.0F) * (1.0F / 65535.0F));
#line 4344
  return;
}
}
#line 4345 "D:/a/test/177.c"
void glColor4ubv(GLubyte const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4347
  tmp = gl_get_thread_context();
#line 4347
  CC = (GLcontext *)tmp;
#line 4348
  (*(CC->API.Color4ubv))(CC, v);
#line 4349
  return;
}
}
#line 4350 "D:/a/test/177.c"
void glColor4uiv(GLuint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4352
  tmp = gl_get_thread_context();
#line 4352
  CC = (GLcontext *)tmp;
#line 4353
  (*(CC->API.Color4f))(CC, (float )*(v + 0) * (1.0F / 4294967295.0F), (float )*(v + 1) * (1.0F / 4294967295.0F),
                       (float )*(v + 2) * (1.0F / 4294967295.0F), (float )*(v + 3) * (1.0F / 4294967295.0F));
#line 4355
  return;
}
}
#line 4356 "D:/a/test/177.c"
void glColor4usv(GLushort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4358
  tmp = gl_get_thread_context();
#line 4358
  CC = (GLcontext *)tmp;
#line 4359
  (*(CC->API.Color4f))(CC, (float )*(v + 0) * (1.0F / 65535.0F), (float )*(v + 1) * (1.0F / 65535.0F),
                       (float )*(v + 2) * (1.0F / 65535.0F), (float )*(v + 3) * (1.0F / 65535.0F));
#line 4361
  return;
}
}
#line 4362 "D:/a/test/177.c"
void glColorMask(GLboolean red , GLboolean green , GLboolean blue___0 , GLboolean alpha ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4365
  tmp = gl_get_thread_context();
#line 4365
  CC = (GLcontext *)tmp;
#line 4366
  if (! CC) {
#line 4366
    tmp___1 = getenv("MESA_DEBUG");
#line 4366
    if (tmp___1) {
#line 4366
      tmp___0 = __getreent();
#line 4366
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4366
    return;
  }
#line 4367
  (*(CC->API.ColorMask))(CC, red, green, blue___0, alpha);
#line 4368
  return;
}
}
#line 4369 "D:/a/test/177.c"
void glColorMaterial(GLenum face , GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4371
  tmp = gl_get_thread_context();
#line 4371
  CC = (GLcontext *)tmp;
#line 4372
  if (! CC) {
#line 4372
    tmp___1 = getenv("MESA_DEBUG");
#line 4372
    if (tmp___1) {
#line 4372
      tmp___0 = __getreent();
#line 4372
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4372
    return;
  }
#line 4373
  (*(CC->API.ColorMaterial))(CC, face, mode);
#line 4374
  return;
}
}
#line 4375 "D:/a/test/177.c"
void glColorPointer(GLint size , GLenum type , GLsizei stride , GLvoid const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4378
  tmp = gl_get_thread_context();
#line 4378
  CC = (GLcontext *)tmp;
#line 4379
  if (! CC) {
#line 4379
    tmp___1 = getenv("MESA_DEBUG");
#line 4379
    if (tmp___1) {
#line 4379
      tmp___0 = __getreent();
#line 4379
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4379
    return;
  }
#line 4380
  (*(CC->API.ColorPointer))(CC, size, type, stride, ptr);
#line 4381
  return;
}
}
#line 4389
struct gl_image *gl_unpack_image(GLcontext *ctx , GLint width , GLint height , GLenum srcFormat ,
                                 GLenum srcType , GLvoid const   *pixels ) ;
#line 4382 "D:/a/test/177.c"
void glColorTableEXT(GLenum target , GLenum internalFormat , GLsizei width , GLenum format ,
                     GLenum type , GLvoid const   *table ) 
{ struct gl_image *image ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 4387
  tmp = gl_get_thread_context();
#line 4387
  CC = (GLcontext *)tmp;
#line 4388
  if (! CC) {
#line 4388
    tmp___1 = getenv("MESA_DEBUG");
#line 4388
    if (tmp___1) {
#line 4388
      tmp___0 = __getreent();
#line 4388
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4388
    return;
  }
#line 4389
  tmp___2 = (int )gl_unpack_image(CC, width, 1, format, type, table);
#line 4389
  image = (struct gl_image *)tmp___2;
#line 4390
  (*(CC->API.ColorTable))(CC, target, internalFormat, image);
#line 4391
  if (image->RefCount == 0) {
#line 4392
    gl_free_image(image);
  }
#line 4393
  return;
}
}
#line 4394 "D:/a/test/177.c"
void glColorSubTableEXT(GLenum target , GLsizei start , GLsizei count , GLenum format ,
                        GLenum type , GLvoid const   *data ) 
{ struct gl_image *image ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 4399
  tmp = gl_get_thread_context();
#line 4399
  CC = (GLcontext *)tmp;
#line 4400
  if (! CC) {
#line 4400
    tmp___1 = getenv("MESA_DEBUG");
#line 4400
    if (tmp___1) {
#line 4400
      tmp___0 = __getreent();
#line 4400
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4400
    return;
  }
#line 4401
  tmp___2 = (int )gl_unpack_image(CC, count, 1, format, type, data);
#line 4401
  image = (struct gl_image *)tmp___2;
#line 4402
  (*(CC->API.ColorSubTable))(CC, target, start, image);
#line 4403
  if (image->RefCount == 0) {
#line 4404
    gl_free_image(image);
  }
#line 4405
  return;
}
}
#line 4406 "D:/a/test/177.c"
void glCopyPixels(GLint x , GLint y , GLsizei width , GLsizei height , GLenum type ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4409
  tmp = gl_get_thread_context();
#line 4409
  CC = (GLcontext *)tmp;
#line 4410
  if (! CC) {
#line 4410
    tmp___1 = getenv("MESA_DEBUG");
#line 4410
    if (tmp___1) {
#line 4410
      tmp___0 = __getreent();
#line 4410
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4410
    return;
  }
#line 4411
  (*(CC->API.CopyPixels))(CC, x, y, width, height, type);
#line 4412
  return;
}
}
#line 4413 "D:/a/test/177.c"
void glCopyTexImage1D(GLenum target , GLint level , GLenum internalformat , GLint x ,
                      GLint y , GLsizei width , GLint border ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4418
  tmp = gl_get_thread_context();
#line 4418
  CC = (GLcontext *)tmp;
#line 4419
  if (! CC) {
#line 4419
    tmp___1 = getenv("MESA_DEBUG");
#line 4419
    if (tmp___1) {
#line 4419
      tmp___0 = __getreent();
#line 4419
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4419
    return;
  }
#line 4420
  (*(CC->API.CopyTexImage1D))(CC, target, level, internalformat, x, y, width, border);
#line 4422
  return;
}
}
#line 4423 "D:/a/test/177.c"
void glCopyTexImage2D(GLenum target , GLint level , GLenum internalformat , GLint x ,
                      GLint y , GLsizei width , GLsizei height , GLint border ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4428
  tmp = gl_get_thread_context();
#line 4428
  CC = (GLcontext *)tmp;
#line 4429
  if (! CC) {
#line 4429
    tmp___1 = getenv("MESA_DEBUG");
#line 4429
    if (tmp___1) {
#line 4429
      tmp___0 = __getreent();
#line 4429
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4429
    return;
  }
#line 4430
  (*(CC->API.CopyTexImage2D))(CC, target, level, internalformat, x, y, width, height,
                              border);
#line 4432
  return;
}
}
#line 4433 "D:/a/test/177.c"
void glCopyTexSubImage1D(GLenum target , GLint level , GLint xoffset , GLint x , GLint y ,
                         GLsizei width ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4437
  tmp = gl_get_thread_context();
#line 4437
  CC = (GLcontext *)tmp;
#line 4438
  if (! CC) {
#line 4438
    tmp___1 = getenv("MESA_DEBUG");
#line 4438
    if (tmp___1) {
#line 4438
      tmp___0 = __getreent();
#line 4438
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4438
    return;
  }
#line 4439
  (*(CC->API.CopyTexSubImage1D))(CC, target, level, xoffset, x, y, width);
#line 4440
  return;
}
}
#line 4441 "D:/a/test/177.c"
void glCopyTexSubImage2D(GLenum target , GLint level , GLint xoffset , GLint yoffset ,
                         GLint x , GLint y , GLsizei width , GLsizei height ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4446
  tmp = gl_get_thread_context();
#line 4446
  CC = (GLcontext *)tmp;
#line 4447
  if (! CC) {
#line 4447
    tmp___1 = getenv("MESA_DEBUG");
#line 4447
    if (tmp___1) {
#line 4447
      tmp___0 = __getreent();
#line 4447
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4447
    return;
  }
#line 4448
  (*(CC->API.CopyTexSubImage2D))(CC, target, level, xoffset, yoffset, x, y, width,
                                 height);
#line 4450
  return;
}
}
#line 4451 "D:/a/test/177.c"
void glCullFace(GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4453
  tmp = gl_get_thread_context();
#line 4453
  CC = (GLcontext *)tmp;
#line 4454
  if (! CC) {
#line 4454
    tmp___1 = getenv("MESA_DEBUG");
#line 4454
    if (tmp___1) {
#line 4454
      tmp___0 = __getreent();
#line 4454
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4454
    return;
  }
#line 4455
  (*(CC->API.CullFace))(CC, mode);
#line 4456
  return;
}
}
#line 4457 "D:/a/test/177.c"
void glDepthFunc(GLenum func ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4459
  tmp = gl_get_thread_context();
#line 4459
  CC = (GLcontext *)tmp;
#line 4460
  if (! CC) {
#line 4460
    tmp___1 = getenv("MESA_DEBUG");
#line 4460
    if (tmp___1) {
#line 4460
      tmp___0 = __getreent();
#line 4460
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4460
    return;
  }
#line 4461
  (*(CC->API.DepthFunc))(CC, func);
#line 4462
  return;
}
}
#line 4463 "D:/a/test/177.c"
void glDepthMask(GLboolean flag ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4465
  tmp = gl_get_thread_context();
#line 4465
  CC = (GLcontext *)tmp;
#line 4466
  if (! CC) {
#line 4466
    tmp___1 = getenv("MESA_DEBUG");
#line 4466
    if (tmp___1) {
#line 4466
      tmp___0 = __getreent();
#line 4466
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4466
    return;
  }
#line 4467
  (*(CC->API.DepthMask))(CC, flag);
#line 4468
  return;
}
}
#line 4469 "D:/a/test/177.c"
void glDepthRange(GLclampd near_val , GLclampd far_val ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4471
  tmp = gl_get_thread_context();
#line 4471
  CC = (GLcontext *)tmp;
#line 4472
  if (! CC) {
#line 4472
    tmp___1 = getenv("MESA_DEBUG");
#line 4472
    if (tmp___1) {
#line 4472
      tmp___0 = __getreent();
#line 4472
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4472
    return;
  }
#line 4473
  (*(CC->API.DepthRange))(CC, near_val, far_val);
#line 4474
  return;
}
}
#line 4475 "D:/a/test/177.c"
void glDeleteLists(GLuint list , GLsizei range ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4477
  tmp = gl_get_thread_context();
#line 4477
  CC = (GLcontext *)tmp;
#line 4478
  if (! CC) {
#line 4478
    tmp___1 = getenv("MESA_DEBUG");
#line 4478
    if (tmp___1) {
#line 4478
      tmp___0 = __getreent();
#line 4478
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4478
    return;
  }
#line 4479
  (*(CC->API.DeleteLists))(CC, list, range);
#line 4480
  return;
}
}
#line 4481 "D:/a/test/177.c"
void glDeleteTextures(GLsizei n , GLuint const   *textures ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4483
  tmp = gl_get_thread_context();
#line 4483
  CC = (GLcontext *)tmp;
#line 4484
  if (! CC) {
#line 4484
    tmp___1 = getenv("MESA_DEBUG");
#line 4484
    if (tmp___1) {
#line 4484
      tmp___0 = __getreent();
#line 4484
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4484
    return;
  }
#line 4485
  (*(CC->API.DeleteTextures))(CC, n, textures);
#line 4486
  return;
}
}
#line 4487 "D:/a/test/177.c"
void glDisable(GLenum cap ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4489
  tmp = gl_get_thread_context();
#line 4489
  CC = (GLcontext *)tmp;
#line 4490
  if (! CC) {
#line 4490
    tmp___1 = getenv("MESA_DEBUG");
#line 4490
    if (tmp___1) {
#line 4490
      tmp___0 = __getreent();
#line 4490
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4490
    return;
  }
#line 4491
  (*(CC->API.Disable))(CC, cap);
#line 4492
  return;
}
}
#line 4493 "D:/a/test/177.c"
void glDisableClientState(GLenum cap ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4495
  tmp = gl_get_thread_context();
#line 4495
  CC = (GLcontext *)tmp;
#line 4496
  if (! CC) {
#line 4496
    tmp___1 = getenv("MESA_DEBUG");
#line 4496
    if (tmp___1) {
#line 4496
      tmp___0 = __getreent();
#line 4496
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4496
    return;
  }
#line 4497
  (*(CC->API.DisableClientState))(CC, cap);
#line 4498
  return;
}
}
#line 4499 "D:/a/test/177.c"
void glDrawArrays(GLenum mode , GLint first , GLsizei count ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4501
  tmp = gl_get_thread_context();
#line 4501
  CC = (GLcontext *)tmp;
#line 4502
  if (! CC) {
#line 4502
    tmp___1 = getenv("MESA_DEBUG");
#line 4502
    if (tmp___1) {
#line 4502
      tmp___0 = __getreent();
#line 4502
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4502
    return;
  }
#line 4503
  (*(CC->API.DrawArrays))(CC, mode, first, count);
#line 4504
  return;
}
}
#line 4505 "D:/a/test/177.c"
void glDrawBuffer(GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4507
  tmp = gl_get_thread_context();
#line 4507
  CC = (GLcontext *)tmp;
#line 4508
  if (! CC) {
#line 4508
    tmp___1 = getenv("MESA_DEBUG");
#line 4508
    if (tmp___1) {
#line 4508
      tmp___0 = __getreent();
#line 4508
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4508
    return;
  }
#line 4509
  (*(CC->API.DrawBuffer))(CC, mode);
#line 4510
  return;
}
}
#line 4511 "D:/a/test/177.c"
void glDrawElements(GLenum mode , GLsizei count , GLenum type , GLvoid const   *indices ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4514
  tmp = gl_get_thread_context();
#line 4514
  CC = (GLcontext *)tmp;
#line 4515
  if (! CC) {
#line 4515
    tmp___1 = getenv("MESA_DEBUG");
#line 4515
    if (tmp___1) {
#line 4515
      tmp___0 = __getreent();
#line 4515
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4515
    return;
  }
#line 4516
  (*(CC->API.DrawElements))(CC, mode, count, type, indices);
#line 4517
  return;
}
}
#line 4518 "D:/a/test/177.c"
void glDrawPixels(GLsizei width , GLsizei height , GLenum format , GLenum type , GLvoid const   *pixels ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4521
  tmp = gl_get_thread_context();
#line 4521
  CC = (GLcontext *)tmp;
#line 4522
  if (! CC) {
#line 4522
    tmp___1 = getenv("MESA_DEBUG");
#line 4522
    if (tmp___1) {
#line 4522
      tmp___0 = __getreent();
#line 4522
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4522
    return;
  }
#line 4523
  (*(CC->API.DrawPixels))(CC, width, height, format, type, pixels);
#line 4524
  return;
}
}
#line 4525 "D:/a/test/177.c"
void glEnable(GLenum cap ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4527
  tmp = gl_get_thread_context();
#line 4527
  CC = (GLcontext *)tmp;
#line 4528
  if (! CC) {
#line 4528
    tmp___1 = getenv("MESA_DEBUG");
#line 4528
    if (tmp___1) {
#line 4528
      tmp___0 = __getreent();
#line 4528
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4528
    return;
  }
#line 4529
  (*(CC->API.Enable))(CC, cap);
#line 4530
  return;
}
}
#line 4531 "D:/a/test/177.c"
void glEnableClientState(GLenum cap ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4533
  tmp = gl_get_thread_context();
#line 4533
  CC = (GLcontext *)tmp;
#line 4534
  if (! CC) {
#line 4534
    tmp___1 = getenv("MESA_DEBUG");
#line 4534
    if (tmp___1) {
#line 4534
      tmp___0 = __getreent();
#line 4534
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4534
    return;
  }
#line 4535
  (*(CC->API.EnableClientState))(CC, cap);
#line 4536
  return;
}
}
#line 4537 "D:/a/test/177.c"
void glEnd(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4539
  tmp = gl_get_thread_context();
#line 4539
  CC = (GLcontext *)tmp;
#line 4540
  if (! CC) {
#line 4540
    tmp___1 = getenv("MESA_DEBUG");
#line 4540
    if (tmp___1) {
#line 4540
      tmp___0 = __getreent();
#line 4540
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4540
    return;
  }
#line 4541
  (*(CC->API.End))(CC);
#line 4542
  return;
}
}
#line 4543 "D:/a/test/177.c"
void glEndList(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4545
  tmp = gl_get_thread_context();
#line 4545
  CC = (GLcontext *)tmp;
#line 4546
  if (! CC) {
#line 4546
    tmp___1 = getenv("MESA_DEBUG");
#line 4546
    if (tmp___1) {
#line 4546
      tmp___0 = __getreent();
#line 4546
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4546
    return;
  }
#line 4547
  (*(CC->API.EndList))(CC);
#line 4548
  return;
}
}
#line 4549 "D:/a/test/177.c"
void glEvalCoord1d(GLdouble u ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4551
  tmp = gl_get_thread_context();
#line 4551
  CC = (GLcontext *)tmp;
#line 4552
  if (! CC) {
#line 4552
    tmp___1 = getenv("MESA_DEBUG");
#line 4552
    if (tmp___1) {
#line 4552
      tmp___0 = __getreent();
#line 4552
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4552
    return;
  }
#line 4553
  (*(CC->API.EvalCoord1f))(CC, (float )u);
#line 4554
  return;
}
}
#line 4555 "D:/a/test/177.c"
void glEvalCoord1f(float u ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4557
  tmp = gl_get_thread_context();
#line 4557
  CC = (GLcontext *)tmp;
#line 4558
  if (! CC) {
#line 4558
    tmp___1 = getenv("MESA_DEBUG");
#line 4558
    if (tmp___1) {
#line 4558
      tmp___0 = __getreent();
#line 4558
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4558
    return;
  }
#line 4559
  (*(CC->API.EvalCoord1f))(CC, u);
#line 4560
  return;
}
}
#line 4561 "D:/a/test/177.c"
void glEvalCoord1dv(GLdouble const   *u ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4563
  tmp = gl_get_thread_context();
#line 4563
  CC = (GLcontext *)tmp;
#line 4564
  if (! CC) {
#line 4564
    tmp___1 = getenv("MESA_DEBUG");
#line 4564
    if (tmp___1) {
#line 4564
      tmp___0 = __getreent();
#line 4564
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4564
    return;
  }
#line 4565
  (*(CC->API.EvalCoord1f))(CC, (float )*u);
#line 4566
  return;
}
}
#line 4567 "D:/a/test/177.c"
void glEvalCoord1fv(float const   *u ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4569
  tmp = gl_get_thread_context();
#line 4569
  CC = (GLcontext *)tmp;
#line 4570
  if (! CC) {
#line 4570
    tmp___1 = getenv("MESA_DEBUG");
#line 4570
    if (tmp___1) {
#line 4570
      tmp___0 = __getreent();
#line 4570
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4570
    return;
  }
#line 4571
  (*(CC->API.EvalCoord1f))(CC, (float )*u);
#line 4572
  return;
}
}
#line 4573 "D:/a/test/177.c"
void glEvalCoord2d(GLdouble u , GLdouble v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4575
  tmp = gl_get_thread_context();
#line 4575
  CC = (GLcontext *)tmp;
#line 4576
  if (! CC) {
#line 4576
    tmp___1 = getenv("MESA_DEBUG");
#line 4576
    if (tmp___1) {
#line 4576
      tmp___0 = __getreent();
#line 4576
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4576
    return;
  }
#line 4577
  (*(CC->API.EvalCoord2f))(CC, (float )u, (float )v);
#line 4578
  return;
}
}
#line 4579 "D:/a/test/177.c"
void glEvalCoord2f(float u , float v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4581
  tmp = gl_get_thread_context();
#line 4581
  CC = (GLcontext *)tmp;
#line 4582
  if (! CC) {
#line 4582
    tmp___1 = getenv("MESA_DEBUG");
#line 4582
    if (tmp___1) {
#line 4582
      tmp___0 = __getreent();
#line 4582
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4582
    return;
  }
#line 4583
  (*(CC->API.EvalCoord2f))(CC, u, v);
#line 4584
  return;
}
}
#line 4585 "D:/a/test/177.c"
void glEvalCoord2dv(GLdouble const   *u ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4587
  tmp = gl_get_thread_context();
#line 4587
  CC = (GLcontext *)tmp;
#line 4588
  if (! CC) {
#line 4588
    tmp___1 = getenv("MESA_DEBUG");
#line 4588
    if (tmp___1) {
#line 4588
      tmp___0 = __getreent();
#line 4588
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4588
    return;
  }
#line 4589
  (*(CC->API.EvalCoord2f))(CC, (float )*(u + 0), (float )*(u + 1));
#line 4590
  return;
}
}
#line 4591 "D:/a/test/177.c"
void glEvalCoord2fv(float const   *u ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4593
  tmp = gl_get_thread_context();
#line 4593
  CC = (GLcontext *)tmp;
#line 4594
  if (! CC) {
#line 4594
    tmp___1 = getenv("MESA_DEBUG");
#line 4594
    if (tmp___1) {
#line 4594
      tmp___0 = __getreent();
#line 4594
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4594
    return;
  }
#line 4595
  (*(CC->API.EvalCoord2f))(CC, (float )*(u + 0), (float )*(u + 1));
#line 4596
  return;
}
}
#line 4597 "D:/a/test/177.c"
void glEvalPoint1(GLint i ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4599
  tmp = gl_get_thread_context();
#line 4599
  CC = (GLcontext *)tmp;
#line 4600
  if (! CC) {
#line 4600
    tmp___1 = getenv("MESA_DEBUG");
#line 4600
    if (tmp___1) {
#line 4600
      tmp___0 = __getreent();
#line 4600
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4600
    return;
  }
#line 4601
  (*(CC->API.EvalPoint1))(CC, i);
#line 4602
  return;
}
}
#line 4603 "D:/a/test/177.c"
void glEvalPoint2(GLint i , GLint j ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4605
  tmp = gl_get_thread_context();
#line 4605
  CC = (GLcontext *)tmp;
#line 4606
  if (! CC) {
#line 4606
    tmp___1 = getenv("MESA_DEBUG");
#line 4606
    if (tmp___1) {
#line 4606
      tmp___0 = __getreent();
#line 4606
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4606
    return;
  }
#line 4607
  (*(CC->API.EvalPoint2))(CC, i, j);
#line 4608
  return;
}
}
#line 4609 "D:/a/test/177.c"
void glEvalMesh1(GLenum mode , GLint i1 , GLint i2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4611
  tmp = gl_get_thread_context();
#line 4611
  CC = (GLcontext *)tmp;
#line 4612
  if (! CC) {
#line 4612
    tmp___1 = getenv("MESA_DEBUG");
#line 4612
    if (tmp___1) {
#line 4612
      tmp___0 = __getreent();
#line 4612
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4612
    return;
  }
#line 4613
  (*(CC->API.EvalMesh1))(CC, mode, i1, i2);
#line 4614
  return;
}
}
#line 4615 "D:/a/test/177.c"
void glEdgeFlag(GLboolean flag ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4617
  tmp = gl_get_thread_context();
#line 4617
  CC = (GLcontext *)tmp;
#line 4618
  if (! CC) {
#line 4618
    tmp___1 = getenv("MESA_DEBUG");
#line 4618
    if (tmp___1) {
#line 4618
      tmp___0 = __getreent();
#line 4618
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4618
    return;
  }
#line 4619
  (*(CC->API.EdgeFlag))(CC, flag);
#line 4620
  return;
}
}
#line 4621 "D:/a/test/177.c"
void glEdgeFlagv(GLboolean const   *flag ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4623
  tmp = gl_get_thread_context();
#line 4623
  CC = (GLcontext *)tmp;
#line 4624
  if (! CC) {
#line 4624
    tmp___1 = getenv("MESA_DEBUG");
#line 4624
    if (tmp___1) {
#line 4624
      tmp___0 = __getreent();
#line 4624
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4624
    return;
  }
#line 4625
  (*(CC->API.EdgeFlag))(CC, (unsigned char )*flag);
#line 4626
  return;
}
}
#line 4627 "D:/a/test/177.c"
void glEdgeFlagPointer(GLsizei stride , GLboolean const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4629
  tmp = gl_get_thread_context();
#line 4629
  CC = (GLcontext *)tmp;
#line 4630
  if (! CC) {
#line 4630
    tmp___1 = getenv("MESA_DEBUG");
#line 4630
    if (tmp___1) {
#line 4630
      tmp___0 = __getreent();
#line 4630
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4630
    return;
  }
#line 4631
  (*(CC->API.EdgeFlagPointer))(CC, stride, ptr);
#line 4632
  return;
}
}
#line 4633 "D:/a/test/177.c"
void glEvalMesh2(GLenum mode , GLint i1 , GLint i2 , GLint j1___0 , GLint j2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4635
  tmp = gl_get_thread_context();
#line 4635
  CC = (GLcontext *)tmp;
#line 4636
  if (! CC) {
#line 4636
    tmp___1 = getenv("MESA_DEBUG");
#line 4636
    if (tmp___1) {
#line 4636
      tmp___0 = __getreent();
#line 4636
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4636
    return;
  }
#line 4637
  (*(CC->API.EvalMesh2))(CC, mode, i1, i2, j1___0, j2);
#line 4638
  return;
}
}
#line 4639 "D:/a/test/177.c"
void glFeedbackBuffer(GLsizei size , GLenum type , float *buffer ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4641
  tmp = gl_get_thread_context();
#line 4641
  CC = (GLcontext *)tmp;
#line 4642
  if (! CC) {
#line 4642
    tmp___1 = getenv("MESA_DEBUG");
#line 4642
    if (tmp___1) {
#line 4642
      tmp___0 = __getreent();
#line 4642
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4642
    return;
  }
#line 4643
  (*(CC->API.FeedbackBuffer))(CC, size, type, buffer);
#line 4644
  return;
}
}
#line 4645 "D:/a/test/177.c"
void glFinish(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4647
  tmp = gl_get_thread_context();
#line 4647
  CC = (GLcontext *)tmp;
#line 4648
  if (! CC) {
#line 4648
    tmp___1 = getenv("MESA_DEBUG");
#line 4648
    if (tmp___1) {
#line 4648
      tmp___0 = __getreent();
#line 4648
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4648
    return;
  }
#line 4649
  (*(CC->API.Finish))(CC);
#line 4650
  return;
}
}
#line 4651 "D:/a/test/177.c"
void glFlush(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4653
  tmp = gl_get_thread_context();
#line 4653
  CC = (GLcontext *)tmp;
#line 4654
  if (! CC) {
#line 4654
    tmp___1 = getenv("MESA_DEBUG");
#line 4654
    if (tmp___1) {
#line 4654
      tmp___0 = __getreent();
#line 4654
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4654
    return;
  }
#line 4655
  (*(CC->API.Flush))(CC);
#line 4656
  return;
}
}
#line 4657 "D:/a/test/177.c"
void glFogf(GLenum pname , float param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4659
  tmp = gl_get_thread_context();
#line 4659
  CC = (GLcontext *)tmp;
#line 4660
  if (! CC) {
#line 4660
    tmp___1 = getenv("MESA_DEBUG");
#line 4660
    if (tmp___1) {
#line 4660
      tmp___0 = __getreent();
#line 4660
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4660
    return;
  }
#line 4661
  (*(CC->API.Fogfv))(CC, pname, (float const   *)(& param));
#line 4662
  return;
}
}
#line 4663 "D:/a/test/177.c"
void glFogi(GLenum pname , GLint param ) 
{ float fparam ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4665
  fparam = (float )param;
#line 4666
  tmp = gl_get_thread_context();
#line 4666
  CC = (GLcontext *)tmp;
#line 4667
  if (! CC) {
#line 4667
    tmp___1 = getenv("MESA_DEBUG");
#line 4667
    if (tmp___1) {
#line 4667
      tmp___0 = __getreent();
#line 4667
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4667
    return;
  }
#line 4668
  (*(CC->API.Fogfv))(CC, pname, (float const   *)(& fparam));
#line 4669
  return;
}
}
#line 4670 "D:/a/test/177.c"
void glFogfv(GLenum pname , float const   *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4672
  tmp = gl_get_thread_context();
#line 4672
  CC = (GLcontext *)tmp;
#line 4673
  if (! CC) {
#line 4673
    tmp___1 = getenv("MESA_DEBUG");
#line 4673
    if (tmp___1) {
#line 4673
      tmp___0 = __getreent();
#line 4673
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4673
    return;
  }
#line 4674
  (*(CC->API.Fogfv))(CC, pname, params);
#line 4675
  return;
}
}
#line 4676 "D:/a/test/177.c"
void glFogiv(GLenum pname , GLint const   *params ) 
{ float p[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4679
  tmp = gl_get_thread_context();
#line 4679
  CC = (GLcontext *)tmp;
#line 4680
  if (! CC) {
#line 4680
    tmp___1 = getenv("MESA_DEBUG");
#line 4680
    if (tmp___1) {
#line 4680
      tmp___0 = __getreent();
#line 4680
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4680
    return;
  }
#line 4681
  switch (pname) {
  case 2917: 
  case 2914: 
  case 2915: 
  case 2916: 
  case 2913: 
#line 4687
  p[0] = (float )*params;
#line 4688
  break;
  case 2918: 
#line 4690
  p[0] = (2.0F * (float )*(params + 0) + 1.0F) * (1.0F / 4294967294.0F);
#line 4691
  p[1] = (2.0F * (float )*(params + 1) + 1.0F) * (1.0F / 4294967294.0F);
#line 4692
  p[2] = (2.0F * (float )*(params + 2) + 1.0F) * (1.0F / 4294967294.0F);
#line 4693
  p[3] = (2.0F * (float )*(params + 3) + 1.0F) * (1.0F / 4294967294.0F);
#line 4694
  break;
  default: ;
  }
#line 4698
  (*(CC->API.Fogfv))(CC, pname, (float const   *)(p));
#line 4699
  return;
}
}
#line 4700 "D:/a/test/177.c"
void glFrontFace(GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4702
  tmp = gl_get_thread_context();
#line 4702
  CC = (GLcontext *)tmp;
#line 4703
  if (! CC) {
#line 4703
    tmp___1 = getenv("MESA_DEBUG");
#line 4703
    if (tmp___1) {
#line 4703
      tmp___0 = __getreent();
#line 4703
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4703
    return;
  }
#line 4704
  (*(CC->API.FrontFace))(CC, mode);
#line 4705
  return;
}
}
#line 4706 "D:/a/test/177.c"
void glFrustum(GLdouble left , GLdouble right , GLdouble bottom , GLdouble top , GLdouble nearval ,
               GLdouble farval ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4710
  tmp = gl_get_thread_context();
#line 4710
  CC = (GLcontext *)tmp;
#line 4711
  if (! CC) {
#line 4711
    tmp___1 = getenv("MESA_DEBUG");
#line 4711
    if (tmp___1) {
#line 4711
      tmp___0 = __getreent();
#line 4711
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4711
    return;
  }
#line 4712
  (*(CC->API.Frustum))(CC, left, right, bottom, top, nearval, farval);
#line 4713
  return;
}
}
#line 4714 "D:/a/test/177.c"
GLuint glGenLists(GLsizei range ) 
{ GLcontext *CC ;
  int tmp ;
  GLuint tmp___0 ;

  {
#line 4716
  tmp = gl_get_thread_context();
#line 4716
  CC = (GLcontext *)tmp;
#line 4717
  CHECK_CONTEXT_RETURN(0);
#line 4718
  tmp___0 = (*(CC->API.GenLists))(CC, range);
#line 4718
  return (tmp___0);
}
}
#line 4720 "D:/a/test/177.c"
void glGenTextures(GLsizei n , GLuint *textures ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4722
  tmp = gl_get_thread_context();
#line 4722
  CC = (GLcontext *)tmp;
#line 4723
  if (! CC) {
#line 4723
    tmp___1 = getenv("MESA_DEBUG");
#line 4723
    if (tmp___1) {
#line 4723
      tmp___0 = __getreent();
#line 4723
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4723
    return;
  }
#line 4724
  (*(CC->API.GenTextures))(CC, n, textures);
#line 4725
  return;
}
}
#line 4726 "D:/a/test/177.c"
void glGetBooleanv(GLenum pname , GLboolean *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4728
  tmp = gl_get_thread_context();
#line 4728
  CC = (GLcontext *)tmp;
#line 4729
  if (! CC) {
#line 4729
    tmp___1 = getenv("MESA_DEBUG");
#line 4729
    if (tmp___1) {
#line 4729
      tmp___0 = __getreent();
#line 4729
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4729
    return;
  }
#line 4730
  (*(CC->API.GetBooleanv))(CC, pname, params);
#line 4731
  return;
}
}
#line 4732 "D:/a/test/177.c"
void glGetClipPlane(GLenum plane , GLdouble *equation ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4734
  tmp = gl_get_thread_context();
#line 4734
  CC = (GLcontext *)tmp;
#line 4735
  if (! CC) {
#line 4735
    tmp___1 = getenv("MESA_DEBUG");
#line 4735
    if (tmp___1) {
#line 4735
      tmp___0 = __getreent();
#line 4735
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4735
    return;
  }
#line 4736
  (*(CC->API.GetClipPlane))(CC, plane, equation);
#line 4737
  return;
}
}
#line 4738 "D:/a/test/177.c"
void glGetColorTableEXT(GLenum target , GLenum format , GLenum type , GLvoid *table ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4741
  tmp = gl_get_thread_context();
#line 4741
  CC = (GLcontext *)tmp;
#line 4742
  if (! CC) {
#line 4742
    tmp___1 = getenv("MESA_DEBUG");
#line 4742
    if (tmp___1) {
#line 4742
      tmp___0 = __getreent();
#line 4742
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4742
    return;
  }
#line 4743
  (*(CC->API.GetColorTable))(CC, target, format, type, table);
#line 4744
  return;
}
}
#line 4745 "D:/a/test/177.c"
void glGetColorTableParameterivEXT(GLenum target , GLenum pname , GLint *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4748
  tmp = gl_get_thread_context();
#line 4748
  CC = (GLcontext *)tmp;
#line 4749
  if (! CC) {
#line 4749
    tmp___1 = getenv("MESA_DEBUG");
#line 4749
    if (tmp___1) {
#line 4749
      tmp___0 = __getreent();
#line 4749
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4749
    return;
  }
#line 4750
  (*(CC->API.GetColorTableParameteriv))(CC, target, pname, params);
#line 4751
  return;
}
}
#line 4752 "D:/a/test/177.c"
void glGetColorTableParameterfvEXT(GLenum target , GLenum pname , float *params ) 
{ GLint iparams ;

  {
#line 4756
  glGetColorTableParameterivEXT(target, pname, & iparams);
#line 4757
  *params = (float )iparams;
#line 4758
  return;
}
}
#line 4759 "D:/a/test/177.c"
void glGetDoublev(GLenum pname , GLdouble *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4761
  tmp = gl_get_thread_context();
#line 4761
  CC = (GLcontext *)tmp;
#line 4762
  if (! CC) {
#line 4762
    tmp___1 = getenv("MESA_DEBUG");
#line 4762
    if (tmp___1) {
#line 4762
      tmp___0 = __getreent();
#line 4762
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4762
    return;
  }
#line 4763
  (*(CC->API.GetDoublev))(CC, pname, params);
#line 4764
  return;
}
}
#line 4765 "D:/a/test/177.c"
GLenum glGetError(void) 
{ GLcontext *CC ;
  int tmp ;
  GLenum tmp___0 ;

  {
#line 4767
  tmp = gl_get_thread_context();
#line 4767
  CC = (GLcontext *)tmp;
#line 4768
  if (! CC) {
#line 4769
    return (0);
  }
#line 4771
  tmp___0 = (*(CC->API.GetError))(CC);
#line 4771
  return (tmp___0);
}
}
#line 4773 "D:/a/test/177.c"
void glGetFloatv(GLenum pname , float *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4775
  tmp = gl_get_thread_context();
#line 4775
  CC = (GLcontext *)tmp;
#line 4776
  if (! CC) {
#line 4776
    tmp___1 = getenv("MESA_DEBUG");
#line 4776
    if (tmp___1) {
#line 4776
      tmp___0 = __getreent();
#line 4776
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4776
    return;
  }
#line 4777
  (*(CC->API.GetFloatv))(CC, pname, params);
#line 4778
  return;
}
}
#line 4779 "D:/a/test/177.c"
void glGetIntegerv(GLenum pname , GLint *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4781
  tmp = gl_get_thread_context();
#line 4781
  CC = (GLcontext *)tmp;
#line 4782
  if (! CC) {
#line 4782
    tmp___1 = getenv("MESA_DEBUG");
#line 4782
    if (tmp___1) {
#line 4782
      tmp___0 = __getreent();
#line 4782
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4782
    return;
  }
#line 4783
  (*(CC->API.GetIntegerv))(CC, pname, params);
#line 4784
  return;
}
}
#line 4785 "D:/a/test/177.c"
void glGetLightfv(GLenum light , GLenum pname , float *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4787
  tmp = gl_get_thread_context();
#line 4787
  CC = (GLcontext *)tmp;
#line 4788
  if (! CC) {
#line 4788
    tmp___1 = getenv("MESA_DEBUG");
#line 4788
    if (tmp___1) {
#line 4788
      tmp___0 = __getreent();
#line 4788
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4788
    return;
  }
#line 4789
  (*(CC->API.GetLightfv))(CC, light, pname, params);
#line 4790
  return;
}
}
#line 4791 "D:/a/test/177.c"
void glGetLightiv(GLenum light , GLenum pname , GLint *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4793
  tmp = gl_get_thread_context();
#line 4793
  CC = (GLcontext *)tmp;
#line 4794
  if (! CC) {
#line 4794
    tmp___1 = getenv("MESA_DEBUG");
#line 4794
    if (tmp___1) {
#line 4794
      tmp___0 = __getreent();
#line 4794
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4794
    return;
  }
#line 4795
  (*(CC->API.GetLightiv))(CC, light, pname, params);
#line 4796
  return;
}
}
#line 4797 "D:/a/test/177.c"
void glGetMapdv(GLenum target , GLenum query , GLdouble *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4799
  tmp = gl_get_thread_context();
#line 4799
  CC = (GLcontext *)tmp;
#line 4800
  if (! CC) {
#line 4800
    tmp___1 = getenv("MESA_DEBUG");
#line 4800
    if (tmp___1) {
#line 4800
      tmp___0 = __getreent();
#line 4800
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4800
    return;
  }
#line 4801
  (*(CC->API.GetMapdv))(CC, target, query, v);
#line 4802
  return;
}
}
#line 4803 "D:/a/test/177.c"
void glGetMapfv(GLenum target , GLenum query , float *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4805
  tmp = gl_get_thread_context();
#line 4805
  CC = (GLcontext *)tmp;
#line 4806
  if (! CC) {
#line 4806
    tmp___1 = getenv("MESA_DEBUG");
#line 4806
    if (tmp___1) {
#line 4806
      tmp___0 = __getreent();
#line 4806
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4806
    return;
  }
#line 4807
  (*(CC->API.GetMapfv))(CC, target, query, v);
#line 4808
  return;
}
}
#line 4809 "D:/a/test/177.c"
void glGetMapiv(GLenum target , GLenum query , GLint *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4811
  tmp = gl_get_thread_context();
#line 4811
  CC = (GLcontext *)tmp;
#line 4812
  if (! CC) {
#line 4812
    tmp___1 = getenv("MESA_DEBUG");
#line 4812
    if (tmp___1) {
#line 4812
      tmp___0 = __getreent();
#line 4812
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4812
    return;
  }
#line 4813
  (*(CC->API.GetMapiv))(CC, target, query, v);
#line 4814
  return;
}
}
#line 4815 "D:/a/test/177.c"
void glGetMaterialfv(GLenum face , GLenum pname , float *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4817
  tmp = gl_get_thread_context();
#line 4817
  CC = (GLcontext *)tmp;
#line 4818
  if (! CC) {
#line 4818
    tmp___1 = getenv("MESA_DEBUG");
#line 4818
    if (tmp___1) {
#line 4818
      tmp___0 = __getreent();
#line 4818
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4818
    return;
  }
#line 4819
  (*(CC->API.GetMaterialfv))(CC, face, pname, params);
#line 4820
  return;
}
}
#line 4821 "D:/a/test/177.c"
void glGetMaterialiv(GLenum face , GLenum pname , GLint *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4823
  tmp = gl_get_thread_context();
#line 4823
  CC = (GLcontext *)tmp;
#line 4824
  if (! CC) {
#line 4824
    tmp___1 = getenv("MESA_DEBUG");
#line 4824
    if (tmp___1) {
#line 4824
      tmp___0 = __getreent();
#line 4824
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4824
    return;
  }
#line 4825
  (*(CC->API.GetMaterialiv))(CC, face, pname, params);
#line 4826
  return;
}
}
#line 4827 "D:/a/test/177.c"
void glGetPixelMapfv(GLenum map , float *values ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4829
  tmp = gl_get_thread_context();
#line 4829
  CC = (GLcontext *)tmp;
#line 4830
  if (! CC) {
#line 4830
    tmp___1 = getenv("MESA_DEBUG");
#line 4830
    if (tmp___1) {
#line 4830
      tmp___0 = __getreent();
#line 4830
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4830
    return;
  }
#line 4831
  (*(CC->API.GetPixelMapfv))(CC, map, values);
#line 4832
  return;
}
}
#line 4833 "D:/a/test/177.c"
void glGetPixelMapuiv(GLenum map , GLuint *values ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4835
  tmp = gl_get_thread_context();
#line 4835
  CC = (GLcontext *)tmp;
#line 4836
  if (! CC) {
#line 4836
    tmp___1 = getenv("MESA_DEBUG");
#line 4836
    if (tmp___1) {
#line 4836
      tmp___0 = __getreent();
#line 4836
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4836
    return;
  }
#line 4837
  (*(CC->API.GetPixelMapuiv))(CC, map, values);
#line 4838
  return;
}
}
#line 4839 "D:/a/test/177.c"
void glGetPixelMapusv(GLenum map , GLushort *values ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4841
  tmp = gl_get_thread_context();
#line 4841
  CC = (GLcontext *)tmp;
#line 4842
  if (! CC) {
#line 4842
    tmp___1 = getenv("MESA_DEBUG");
#line 4842
    if (tmp___1) {
#line 4842
      tmp___0 = __getreent();
#line 4842
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4842
    return;
  }
#line 4843
  (*(CC->API.GetPixelMapusv))(CC, map, values);
#line 4844
  return;
}
}
#line 4845 "D:/a/test/177.c"
void glGetPointerv(GLenum pname , GLvoid **params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4847
  tmp = gl_get_thread_context();
#line 4847
  CC = (GLcontext *)tmp;
#line 4848
  if (! CC) {
#line 4848
    tmp___1 = getenv("MESA_DEBUG");
#line 4848
    if (tmp___1) {
#line 4848
      tmp___0 = __getreent();
#line 4848
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4848
    return;
  }
#line 4849
  (*(CC->API.GetPointerv))(CC, pname, params);
#line 4850
  return;
}
}
#line 4851 "D:/a/test/177.c"
void glGetPolygonStipple(GLubyte *mask ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4853
  tmp = gl_get_thread_context();
#line 4853
  CC = (GLcontext *)tmp;
#line 4854
  if (! CC) {
#line 4854
    tmp___1 = getenv("MESA_DEBUG");
#line 4854
    if (tmp___1) {
#line 4854
      tmp___0 = __getreent();
#line 4854
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4854
    return;
  }
#line 4855
  (*(CC->API.GetPolygonStipple))(CC, mask);
#line 4856
  return;
}
}
#line 4857 "D:/a/test/177.c"
GLubyte const   *glGetString(GLenum name ) 
{ GLcontext *CC ;
  int tmp ;
  GLubyte const   *tmp___0 ;

  {
#line 4859
  tmp = gl_get_thread_context();
#line 4859
  CC = (GLcontext *)tmp;
#line 4860
  CHECK_CONTEXT_RETURN((void *)0);
#line 4861
  tmp___0 = (*(CC->API.GetString))(CC, name);
#line 4861
  return (tmp___0);
}
}
#line 4863 "D:/a/test/177.c"
void glGetTexEnvfv(GLenum target , GLenum pname , float *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4865
  tmp = gl_get_thread_context();
#line 4865
  CC = (GLcontext *)tmp;
#line 4866
  if (! CC) {
#line 4866
    tmp___1 = getenv("MESA_DEBUG");
#line 4866
    if (tmp___1) {
#line 4866
      tmp___0 = __getreent();
#line 4866
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4866
    return;
  }
#line 4867
  (*(CC->API.GetTexEnvfv))(CC, target, pname, params);
#line 4868
  return;
}
}
#line 4869 "D:/a/test/177.c"
void glGetTexEnviv(GLenum target , GLenum pname , GLint *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4871
  tmp = gl_get_thread_context();
#line 4871
  CC = (GLcontext *)tmp;
#line 4872
  if (! CC) {
#line 4872
    tmp___1 = getenv("MESA_DEBUG");
#line 4872
    if (tmp___1) {
#line 4872
      tmp___0 = __getreent();
#line 4872
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4872
    return;
  }
#line 4873
  (*(CC->API.GetTexEnviv))(CC, target, pname, params);
#line 4874
  return;
}
}
#line 4875 "D:/a/test/177.c"
void glGetTexGeniv(GLenum coord , GLenum pname , GLint *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4877
  tmp = gl_get_thread_context();
#line 4877
  CC = (GLcontext *)tmp;
#line 4878
  if (! CC) {
#line 4878
    tmp___1 = getenv("MESA_DEBUG");
#line 4878
    if (tmp___1) {
#line 4878
      tmp___0 = __getreent();
#line 4878
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4878
    return;
  }
#line 4879
  (*(CC->API.GetTexGeniv))(CC, coord, pname, params);
#line 4880
  return;
}
}
#line 4881 "D:/a/test/177.c"
void glGetTexGendv(GLenum coord , GLenum pname , GLdouble *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4883
  tmp = gl_get_thread_context();
#line 4883
  CC = (GLcontext *)tmp;
#line 4884
  if (! CC) {
#line 4884
    tmp___1 = getenv("MESA_DEBUG");
#line 4884
    if (tmp___1) {
#line 4884
      tmp___0 = __getreent();
#line 4884
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4884
    return;
  }
#line 4885
  (*(CC->API.GetTexGendv))(CC, coord, pname, params);
#line 4886
  return;
}
}
#line 4887 "D:/a/test/177.c"
void glGetTexGenfv(GLenum coord , GLenum pname , float *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4889
  tmp = gl_get_thread_context();
#line 4889
  CC = (GLcontext *)tmp;
#line 4890
  if (! CC) {
#line 4890
    tmp___1 = getenv("MESA_DEBUG");
#line 4890
    if (tmp___1) {
#line 4890
      tmp___0 = __getreent();
#line 4890
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4890
    return;
  }
#line 4891
  (*(CC->API.GetTexGenfv))(CC, coord, pname, params);
#line 4892
  return;
}
}
#line 4893 "D:/a/test/177.c"
void glGetTexImage(GLenum target , GLint level , GLenum format , GLenum type , GLvoid *pixels ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4896
  tmp = gl_get_thread_context();
#line 4896
  CC = (GLcontext *)tmp;
#line 4897
  if (! CC) {
#line 4897
    tmp___1 = getenv("MESA_DEBUG");
#line 4897
    if (tmp___1) {
#line 4897
      tmp___0 = __getreent();
#line 4897
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4897
    return;
  }
#line 4898
  (*(CC->API.GetTexImage))(CC, target, level, format, type, pixels);
#line 4899
  return;
}
}
#line 4900 "D:/a/test/177.c"
void glGetTexLevelParameterfv(GLenum target , GLint level , GLenum pname , float *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4903
  tmp = gl_get_thread_context();
#line 4903
  CC = (GLcontext *)tmp;
#line 4904
  if (! CC) {
#line 4904
    tmp___1 = getenv("MESA_DEBUG");
#line 4904
    if (tmp___1) {
#line 4904
      tmp___0 = __getreent();
#line 4904
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4904
    return;
  }
#line 4905
  (*(CC->API.GetTexLevelParameterfv))(CC, target, level, pname, params);
#line 4906
  return;
}
}
#line 4907 "D:/a/test/177.c"
void glGetTexLevelParameteriv(GLenum target , GLint level , GLenum pname , GLint *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4910
  tmp = gl_get_thread_context();
#line 4910
  CC = (GLcontext *)tmp;
#line 4911
  if (! CC) {
#line 4911
    tmp___1 = getenv("MESA_DEBUG");
#line 4911
    if (tmp___1) {
#line 4911
      tmp___0 = __getreent();
#line 4911
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4911
    return;
  }
#line 4912
  (*(CC->API.GetTexLevelParameteriv))(CC, target, level, pname, params);
#line 4913
  return;
}
}
#line 4914 "D:/a/test/177.c"
void glGetTexParameterfv(GLenum target , GLenum pname , float *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4916
  tmp = gl_get_thread_context();
#line 4916
  CC = (GLcontext *)tmp;
#line 4917
  if (! CC) {
#line 4917
    tmp___1 = getenv("MESA_DEBUG");
#line 4917
    if (tmp___1) {
#line 4917
      tmp___0 = __getreent();
#line 4917
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4917
    return;
  }
#line 4918
  (*(CC->API.GetTexParameterfv))(CC, target, pname, params);
#line 4919
  return;
}
}
#line 4920 "D:/a/test/177.c"
void glGetTexParameteriv(GLenum target , GLenum pname , GLint *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4922
  tmp = gl_get_thread_context();
#line 4922
  CC = (GLcontext *)tmp;
#line 4923
  if (! CC) {
#line 4923
    tmp___1 = getenv("MESA_DEBUG");
#line 4923
    if (tmp___1) {
#line 4923
      tmp___0 = __getreent();
#line 4923
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4923
    return;
  }
#line 4924
  (*(CC->API.GetTexParameteriv))(CC, target, pname, params);
#line 4925
  return;
}
}
#line 4926 "D:/a/test/177.c"
void glHint(GLenum target , GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4928
  tmp = gl_get_thread_context();
#line 4928
  CC = (GLcontext *)tmp;
#line 4929
  if (! CC) {
#line 4929
    tmp___1 = getenv("MESA_DEBUG");
#line 4929
    if (tmp___1) {
#line 4929
      tmp___0 = __getreent();
#line 4929
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4929
    return;
  }
#line 4930
  (*(CC->API.Hint))(CC, target, mode);
#line 4931
  return;
}
}
#line 4932 "D:/a/test/177.c"
void glIndexd(GLdouble c ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4934
  tmp = gl_get_thread_context();
#line 4934
  CC = (GLcontext *)tmp;
#line 4935
  (*(CC->API.Indexf))(CC, (float )c);
#line 4936
  return;
}
}
#line 4937 "D:/a/test/177.c"
void glIndexf(float c ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4939
  tmp = gl_get_thread_context();
#line 4939
  CC = (GLcontext *)tmp;
#line 4940
  (*(CC->API.Indexf))(CC, c);
#line 4941
  return;
}
}
#line 4942 "D:/a/test/177.c"
void glIndexi(GLint c ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4944
  tmp = gl_get_thread_context();
#line 4944
  CC = (GLcontext *)tmp;
#line 4945
  (*(CC->API.Indexi))(CC, c);
#line 4946
  return;
}
}
#line 4947 "D:/a/test/177.c"
void glIndexs(GLshort c ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4949
  tmp = gl_get_thread_context();
#line 4949
  CC = (GLcontext *)tmp;
#line 4950
  (*(CC->API.Indexi))(CC, (int )c);
#line 4951
  return;
}
}
#line 4959 "D:/a/test/177.c"
void glIndexdv(GLdouble const   *c ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4961
  tmp = gl_get_thread_context();
#line 4961
  CC = (GLcontext *)tmp;
#line 4962
  (*(CC->API.Indexf))(CC, (float )*c);
#line 4963
  return;
}
}
#line 4964 "D:/a/test/177.c"
void glIndexfv(float const   *c ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4966
  tmp = gl_get_thread_context();
#line 4966
  CC = (GLcontext *)tmp;
#line 4967
  (*(CC->API.Indexf))(CC, (float )*c);
#line 4968
  return;
}
}
#line 4969 "D:/a/test/177.c"
void glIndexiv(GLint const   *c ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4971
  tmp = gl_get_thread_context();
#line 4971
  CC = (GLcontext *)tmp;
#line 4972
  (*(CC->API.Indexi))(CC, (int )*c);
#line 4973
  return;
}
}
#line 4974 "D:/a/test/177.c"
void glIndexsv(GLshort const   *c ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4976
  tmp = gl_get_thread_context();
#line 4976
  CC = (GLcontext *)tmp;
#line 4977
  (*(CC->API.Indexi))(CC, (int )*c);
#line 4978
  return;
}
}
#line 4986 "D:/a/test/177.c"
void glIndexMask(GLuint mask ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 4988
  tmp = gl_get_thread_context();
#line 4988
  CC = (GLcontext *)tmp;
#line 4989
  (*(CC->API.IndexMask))(CC, mask);
#line 4990
  return;
}
}
#line 4991 "D:/a/test/177.c"
void glIndexPointer(GLenum type , GLsizei stride , GLvoid const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 4993
  tmp = gl_get_thread_context();
#line 4993
  CC = (GLcontext *)tmp;
#line 4994
  if (! CC) {
#line 4994
    tmp___1 = getenv("MESA_DEBUG");
#line 4994
    if (tmp___1) {
#line 4994
      tmp___0 = __getreent();
#line 4994
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 4994
    return;
  }
#line 4995
  (*(CC->API.IndexPointer))(CC, type, stride, ptr);
#line 4996
  return;
}
}
#line 4997 "D:/a/test/177.c"
void glInterleavedArrays(GLenum format , GLsizei stride , GLvoid const   *pointer ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5000
  tmp = gl_get_thread_context();
#line 5000
  CC = (GLcontext *)tmp;
#line 5001
  if (! CC) {
#line 5001
    tmp___1 = getenv("MESA_DEBUG");
#line 5001
    if (tmp___1) {
#line 5001
      tmp___0 = __getreent();
#line 5001
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5001
    return;
  }
#line 5002
  (*(CC->API.InterleavedArrays))(CC, format, stride, pointer);
#line 5003
  return;
}
}
#line 5004 "D:/a/test/177.c"
void glInitNames(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5006
  tmp = gl_get_thread_context();
#line 5006
  CC = (GLcontext *)tmp;
#line 5007
  if (! CC) {
#line 5007
    tmp___1 = getenv("MESA_DEBUG");
#line 5007
    if (tmp___1) {
#line 5007
      tmp___0 = __getreent();
#line 5007
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5007
    return;
  }
#line 5008
  (*(CC->API.InitNames))(CC);
#line 5009
  return;
}
}
#line 5010 "D:/a/test/177.c"
GLboolean glIsList(GLuint list ) 
{ GLcontext *CC ;
  int tmp ;
  GLboolean tmp___0 ;

  {
#line 5012
  tmp = gl_get_thread_context();
#line 5012
  CC = (GLcontext *)tmp;
#line 5013
  CHECK_CONTEXT_RETURN(0);
#line 5014
  tmp___0 = (*(CC->API.IsList))(CC, list);
#line 5014
  return (tmp___0);
}
}
#line 5016 "D:/a/test/177.c"
GLboolean glIsTexture(GLuint texture ) 
{ GLcontext *CC ;
  int tmp ;
  GLboolean tmp___0 ;

  {
#line 5018
  tmp = gl_get_thread_context();
#line 5018
  CC = (GLcontext *)tmp;
#line 5019
  CHECK_CONTEXT_RETURN(0);
#line 5020
  tmp___0 = (*(CC->API.IsTexture))(CC, texture);
#line 5020
  return (tmp___0);
}
}
#line 5022 "D:/a/test/177.c"
void glLightf(GLenum light , GLenum pname , float param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5024
  tmp = gl_get_thread_context();
#line 5024
  CC = (GLcontext *)tmp;
#line 5025
  if (! CC) {
#line 5025
    tmp___1 = getenv("MESA_DEBUG");
#line 5025
    if (tmp___1) {
#line 5025
      tmp___0 = __getreent();
#line 5025
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5025
    return;
  }
#line 5026
  (*(CC->API.Lightfv))(CC, light, pname, (float const   *)(& param), 1);
#line 5027
  return;
}
}
#line 5028 "D:/a/test/177.c"
void glLighti(GLenum light , GLenum pname , GLint param ) 
{ float fparam ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5030
  fparam = (float )param;
#line 5031
  tmp = gl_get_thread_context();
#line 5031
  CC = (GLcontext *)tmp;
#line 5032
  if (! CC) {
#line 5032
    tmp___1 = getenv("MESA_DEBUG");
#line 5032
    if (tmp___1) {
#line 5032
      tmp___0 = __getreent();
#line 5032
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5032
    return;
  }
#line 5033
  (*(CC->API.Lightfv))(CC, light, pname, (float const   *)(& fparam), 1);
#line 5034
  return;
}
}
#line 5035 "D:/a/test/177.c"
void glLightfv(GLenum light , GLenum pname , float const   *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5037
  tmp = gl_get_thread_context();
#line 5037
  CC = (GLcontext *)tmp;
#line 5038
  if (! CC) {
#line 5038
    tmp___1 = getenv("MESA_DEBUG");
#line 5038
    if (tmp___1) {
#line 5038
      tmp___0 = __getreent();
#line 5038
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5038
    return;
  }
#line 5039
  (*(CC->API.Lightfv))(CC, light, pname, params, 4);
#line 5040
  return;
}
}
#line 5041 "D:/a/test/177.c"
void glLightiv(GLenum light , GLenum pname , GLint const   *params ) 
{ float fparam[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5044
  tmp = gl_get_thread_context();
#line 5044
  CC = (GLcontext *)tmp;
#line 5045
  if (! CC) {
#line 5045
    tmp___1 = getenv("MESA_DEBUG");
#line 5045
    if (tmp___1) {
#line 5045
      tmp___0 = __getreent();
#line 5045
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5045
    return;
  }
#line 5046
  switch (pname) {
  case 4608: 
  case 4609: 
  case 4610: 
#line 5050
  fparam[0] = (2.0F * (float )*(params + 0) + 1.0F) * (1.0F / 4294967294.0F);
#line 5051
  fparam[1] = (2.0F * (float )*(params + 1) + 1.0F) * (1.0F / 4294967294.0F);
#line 5052
  fparam[2] = (2.0F * (float )*(params + 2) + 1.0F) * (1.0F / 4294967294.0F);
#line 5053
  fparam[3] = (2.0F * (float )*(params + 3) + 1.0F) * (1.0F / 4294967294.0F);
#line 5054
  break;
  case 4611: 
#line 5056
  fparam[0] = (float )*(params + 0);
#line 5057
  fparam[1] = (float )*(params + 1);
#line 5058
  fparam[2] = (float )*(params + 2);
#line 5059
  fparam[3] = (float )*(params + 3);
#line 5060
  break;
  case 4612: 
#line 5062
  fparam[0] = (float )*(params + 0);
#line 5063
  fparam[1] = (float )*(params + 1);
#line 5064
  fparam[2] = (float )*(params + 2);
#line 5065
  break;
  case 4613: 
  case 4614: 
  case 4615: 
  case 4616: 
  case 4617: 
#line 5071
  fparam[0] = (float )*(params + 0);
#line 5072
  break;
  default: ;
  }
#line 5077
  (*(CC->API.Lightfv))(CC, light, pname, (float const   *)(fparam), 4);
#line 5078
  return;
}
}
#line 5079 "D:/a/test/177.c"
void glLightModelf(GLenum pname , float param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5081
  tmp = gl_get_thread_context();
#line 5081
  CC = (GLcontext *)tmp;
#line 5082
  if (! CC) {
#line 5082
    tmp___1 = getenv("MESA_DEBUG");
#line 5082
    if (tmp___1) {
#line 5082
      tmp___0 = __getreent();
#line 5082
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5082
    return;
  }
#line 5083
  (*(CC->API.LightModelfv))(CC, pname, (float const   *)(& param));
#line 5084
  return;
}
}
#line 5085 "D:/a/test/177.c"
void glLightModeli(GLenum pname , GLint param ) 
{ float fparam[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5088
  tmp = gl_get_thread_context();
#line 5088
  CC = (GLcontext *)tmp;
#line 5089
  if (! CC) {
#line 5089
    tmp___1 = getenv("MESA_DEBUG");
#line 5089
    if (tmp___1) {
#line 5089
      tmp___0 = __getreent();
#line 5089
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5089
    return;
  }
#line 5090
  fparam[0] = (float )param;
#line 5091
  (*(CC->API.LightModelfv))(CC, pname, (float const   *)(fparam));
#line 5092
  return;
}
}
#line 5093 "D:/a/test/177.c"
void glLightModelfv(GLenum pname , float const   *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5095
  tmp = gl_get_thread_context();
#line 5095
  CC = (GLcontext *)tmp;
#line 5096
  if (! CC) {
#line 5096
    tmp___1 = getenv("MESA_DEBUG");
#line 5096
    if (tmp___1) {
#line 5096
      tmp___0 = __getreent();
#line 5096
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5096
    return;
  }
#line 5097
  (*(CC->API.LightModelfv))(CC, pname, params);
#line 5098
  return;
}
}
#line 5099 "D:/a/test/177.c"
void glLightModeliv(GLenum pname , GLint const   *params ) 
{ float fparam[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5102
  tmp = gl_get_thread_context();
#line 5102
  CC = (GLcontext *)tmp;
#line 5103
  if (! CC) {
#line 5103
    tmp___1 = getenv("MESA_DEBUG");
#line 5103
    if (tmp___1) {
#line 5103
      tmp___0 = __getreent();
#line 5103
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5103
    return;
  }
#line 5104
  switch (pname) {
  case 2899: 
#line 5106
  fparam[0] = (2.0F * (float )*(params + 0) + 1.0F) * (1.0F / 4294967294.0F);
#line 5107
  fparam[1] = (2.0F * (float )*(params + 1) + 1.0F) * (1.0F / 4294967294.0F);
#line 5108
  fparam[2] = (2.0F * (float )*(params + 2) + 1.0F) * (1.0F / 4294967294.0F);
#line 5109
  fparam[3] = (2.0F * (float )*(params + 3) + 1.0F) * (1.0F / 4294967294.0F);
#line 5110
  break;
  case 2897: 
  case 2898: 
#line 5113
  fparam[0] = (float )*(params + 0);
#line 5114
  break;
  default: ;
  }
#line 5118
  (*(CC->API.LightModelfv))(CC, pname, (float const   *)(fparam));
#line 5119
  return;
}
}
#line 5120 "D:/a/test/177.c"
void glLineWidth(float width ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5122
  tmp = gl_get_thread_context();
#line 5122
  CC = (GLcontext *)tmp;
#line 5123
  if (! CC) {
#line 5123
    tmp___1 = getenv("MESA_DEBUG");
#line 5123
    if (tmp___1) {
#line 5123
      tmp___0 = __getreent();
#line 5123
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5123
    return;
  }
#line 5124
  (*(CC->API.LineWidth))(CC, width);
#line 5125
  return;
}
}
#line 5126 "D:/a/test/177.c"
void glLineStipple(GLint factor , GLushort pattern ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5128
  tmp = gl_get_thread_context();
#line 5128
  CC = (GLcontext *)tmp;
#line 5129
  if (! CC) {
#line 5129
    tmp___1 = getenv("MESA_DEBUG");
#line 5129
    if (tmp___1) {
#line 5129
      tmp___0 = __getreent();
#line 5129
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5129
    return;
  }
#line 5130
  (*(CC->API.LineStipple))(CC, factor, pattern);
#line 5131
  return;
}
}
#line 5132 "D:/a/test/177.c"
void glListBase(GLuint base ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5134
  tmp = gl_get_thread_context();
#line 5134
  CC = (GLcontext *)tmp;
#line 5135
  if (! CC) {
#line 5135
    tmp___1 = getenv("MESA_DEBUG");
#line 5135
    if (tmp___1) {
#line 5135
      tmp___0 = __getreent();
#line 5135
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5135
    return;
  }
#line 5136
  (*(CC->API.ListBase))(CC, base);
#line 5137
  return;
}
}
#line 5138 "D:/a/test/177.c"
void glLoadIdentity(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5140
  tmp = gl_get_thread_context();
#line 5140
  CC = (GLcontext *)tmp;
#line 5141
  if (! CC) {
#line 5141
    tmp___1 = getenv("MESA_DEBUG");
#line 5141
    if (tmp___1) {
#line 5141
      tmp___0 = __getreent();
#line 5141
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5141
    return;
  }
#line 5142
  (*(CC->API.LoadIdentity))(CC);
#line 5143
  return;
}
}
#line 5144 "D:/a/test/177.c"
void glLoadMatrixd(GLdouble const   *m ) 
{ float fm[16] ;
  GLuint i ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5148
  tmp = gl_get_thread_context();
#line 5148
  CC = (GLcontext *)tmp;
#line 5149
  if (! CC) {
#line 5149
    tmp___1 = getenv("MESA_DEBUG");
#line 5149
    if (tmp___1) {
#line 5149
      tmp___0 = __getreent();
#line 5149
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5149
    return;
  }
#line 5150
  i = 0U;
#line 5150
  while (i < 16U) {
#line 5151
    fm[i] = (float )*(m + i);
#line 5150
    i ++;
  }
#line 5153
  (*(CC->API.LoadMatrixf))(CC, (float const   *)(fm));
#line 5154
  return;
}
}
#line 5155 "D:/a/test/177.c"
void glLoadMatrixf(float const   *m ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5157
  tmp = gl_get_thread_context();
#line 5157
  CC = (GLcontext *)tmp;
#line 5158
  if (! CC) {
#line 5158
    tmp___1 = getenv("MESA_DEBUG");
#line 5158
    if (tmp___1) {
#line 5158
      tmp___0 = __getreent();
#line 5158
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5158
    return;
  }
#line 5159
  (*(CC->API.LoadMatrixf))(CC, m);
#line 5160
  return;
}
}
#line 5161 "D:/a/test/177.c"
void glLoadName(GLuint name ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5163
  tmp = gl_get_thread_context();
#line 5163
  CC = (GLcontext *)tmp;
#line 5164
  if (! CC) {
#line 5164
    tmp___1 = getenv("MESA_DEBUG");
#line 5164
    if (tmp___1) {
#line 5164
      tmp___0 = __getreent();
#line 5164
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5164
    return;
  }
#line 5165
  (*(CC->API.LoadName))(CC, name);
#line 5166
  return;
}
}
#line 5167 "D:/a/test/177.c"
void glLogicOp(GLenum opcode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5169
  tmp = gl_get_thread_context();
#line 5169
  CC = (GLcontext *)tmp;
#line 5170
  if (! CC) {
#line 5170
    tmp___1 = getenv("MESA_DEBUG");
#line 5170
    if (tmp___1) {
#line 5170
      tmp___0 = __getreent();
#line 5170
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5170
    return;
  }
#line 5171
  (*(CC->API.LogicOp))(CC, opcode);
#line 5172
  return;
}
}
#line 5180
float *gl_copy_map_points1d(GLenum target , GLint ustride , GLint uorder , GLdouble const   *points ) ;
#line 5173 "D:/a/test/177.c"
void glMap1d(GLenum target , GLdouble u1 , GLdouble u2 , GLint stride , GLint order ,
             GLdouble const   *points ) 
{ float *pnts ;
  GLboolean retain ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 5178
  tmp = gl_get_thread_context();
#line 5178
  CC = (GLcontext *)tmp;
#line 5179
  if (! CC) {
#line 5179
    tmp___1 = getenv("MESA_DEBUG");
#line 5179
    if (tmp___1) {
#line 5179
      tmp___0 = __getreent();
#line 5179
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5179
    return;
  }
#line 5180
  tmp___2 = (int )gl_copy_map_points1d(target, stride, order, points);
#line 5180
  pnts = (float *)tmp___2;
#line 5181
  retain = CC->CompileFlag;
#line 5182
  (*(CC->API.Map1f))(CC, target, (float )u1, (float )u2, stride, order, (float const   *)pnts,
                     retain);

#line 5183
  return;
}
}
#line 5191
float *gl_copy_map_points1f(GLenum target , GLint ustride , GLint uorder , float const   *points ) ;
#line 5184 "D:/a/test/177.c"
void glMap1f(GLenum target , float u1 , float u2 , GLint stride , GLint order , float const   *points ) 
{ float *pnts ;
  GLboolean retain ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 5189
  tmp = gl_get_thread_context();
#line 5189
  CC = (GLcontext *)tmp;
#line 5190
  if (! CC) {
#line 5190
    tmp___1 = getenv("MESA_DEBUG");
#line 5190
    if (tmp___1) {
#line 5190
      tmp___0 = __getreent();
#line 5190
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5190
    return;
  }
#line 5191
  tmp___2 = (int )gl_copy_map_points1f(target, stride, order, points);
#line 5191
  pnts = (float *)tmp___2;
#line 5192
  retain = CC->CompileFlag;
#line 5193
  (*(CC->API.Map1f))(CC, target, u1, u2, stride, order, (float const   *)pnts, retain);
#line 5194
  return;
}
}
#line 5204
float *gl_copy_map_points2d(GLenum target , GLint ustride , GLint uorder , GLint vstride ,
                            GLint vorder , GLdouble const   *points ) ;
#line 5195 "D:/a/test/177.c"
void glMap2d(GLenum target , GLdouble u1 , GLdouble u2 , GLint ustride , GLint uorder ,
             GLdouble v1 , GLdouble v2 , GLint vstride , GLint vorder , GLdouble const   *points ) 
{ float *pnts ;
  GLboolean retain ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 5202
  tmp = gl_get_thread_context();
#line 5202
  CC = (GLcontext *)tmp;
#line 5203
  if (! CC) {
#line 5203
    tmp___1 = getenv("MESA_DEBUG");
#line 5203
    if (tmp___1) {
#line 5203
      tmp___0 = __getreent();
#line 5203
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5203
    return;
  }
#line 5204
  tmp___2 = (int )gl_copy_map_points2d(target, ustride, uorder, vstride, vorder, points);
#line 5204
  pnts = (float *)tmp___2;
#line 5206
  retain = CC->CompileFlag;
#line 5207
  (*(CC->API.Map2f))(CC, target, (float )u1, (float )u2, ustride, uorder, (float )v1,
                     (float )v2, vstride, vorder, (float const   *)pnts, retain);
#line 5209
  return;
}
}
#line 5219
float *gl_copy_map_points2f(GLenum target , GLint ustride , GLint uorder , GLint vstride ,
                            GLint vorder , float const   *points ) ;
#line 5210 "D:/a/test/177.c"
void glMap2f(GLenum target , float u1 , float u2 , GLint ustride , GLint uorder ,
             float v1 , float v2 , GLint vstride , GLint vorder , float const   *points ) 
{ float *pnts ;
  GLboolean retain ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 5217
  tmp = gl_get_thread_context();
#line 5217
  CC = (GLcontext *)tmp;
#line 5218
  if (! CC) {
#line 5218
    tmp___1 = getenv("MESA_DEBUG");
#line 5218
    if (tmp___1) {
#line 5218
      tmp___0 = __getreent();
#line 5218
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5218
    return;
  }
#line 5219
  tmp___2 = (int )gl_copy_map_points2f(target, ustride, uorder, vstride, vorder, points);
#line 5219
  pnts = (float *)tmp___2;
#line 5221
  retain = CC->CompileFlag;
#line 5222
  (*(CC->API.Map2f))(CC, target, u1, u2, ustride, uorder, v1, v2, vstride, vorder,
                     (float const   *)pnts, retain);
#line 5224
  return;
}
}
#line 5225 "D:/a/test/177.c"
void glMapGrid1d(GLint un , GLdouble u1 , GLdouble u2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5227
  tmp = gl_get_thread_context();
#line 5227
  CC = (GLcontext *)tmp;
#line 5228
  if (! CC) {
#line 5228
    tmp___1 = getenv("MESA_DEBUG");
#line 5228
    if (tmp___1) {
#line 5228
      tmp___0 = __getreent();
#line 5228
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5228
    return;
  }
#line 5229
  (*(CC->API.MapGrid1f))(CC, un, (float )u1, (float )u2);
#line 5230
  return;
}
}
#line 5231 "D:/a/test/177.c"
void glMapGrid1f(GLint un , float u1 , float u2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5233
  tmp = gl_get_thread_context();
#line 5233
  CC = (GLcontext *)tmp;
#line 5234
  if (! CC) {
#line 5234
    tmp___1 = getenv("MESA_DEBUG");
#line 5234
    if (tmp___1) {
#line 5234
      tmp___0 = __getreent();
#line 5234
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5234
    return;
  }
#line 5235
  (*(CC->API.MapGrid1f))(CC, un, u1, u2);
#line 5236
  return;
}
}
#line 5237 "D:/a/test/177.c"
void glMapGrid2d(GLint un , GLdouble u1 , GLdouble u2 , GLint vn , GLdouble v1 , GLdouble v2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5240
  tmp = gl_get_thread_context();
#line 5240
  CC = (GLcontext *)tmp;
#line 5241
  if (! CC) {
#line 5241
    tmp___1 = getenv("MESA_DEBUG");
#line 5241
    if (tmp___1) {
#line 5241
      tmp___0 = __getreent();
#line 5241
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5241
    return;
  }
#line 5242
  (*(CC->API.MapGrid2f))(CC, un, (float )u1, (float )u2, vn, (float )v1, (float )v2);
#line 5244
  return;
}
}
#line 5245 "D:/a/test/177.c"
void glMapGrid2f(GLint un , float u1 , float u2 , GLint vn , float v1 , float v2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5248
  tmp = gl_get_thread_context();
#line 5248
  CC = (GLcontext *)tmp;
#line 5249
  if (! CC) {
#line 5249
    tmp___1 = getenv("MESA_DEBUG");
#line 5249
    if (tmp___1) {
#line 5249
      tmp___0 = __getreent();
#line 5249
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5249
    return;
  }
#line 5250
  (*(CC->API.MapGrid2f))(CC, un, u1, u2, vn, v1, v2);
#line 5251
  return;
}
}
#line 5252 "D:/a/test/177.c"
void glMaterialf(GLenum face , GLenum pname , float param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5254
  tmp = gl_get_thread_context();
#line 5254
  CC = (GLcontext *)tmp;
#line 5255
  if (! CC) {
#line 5255
    tmp___1 = getenv("MESA_DEBUG");
#line 5255
    if (tmp___1) {
#line 5255
      tmp___0 = __getreent();
#line 5255
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5255
    return;
  }
#line 5256
  (*(CC->API.Materialfv))(CC, face, pname, (float const   *)(& param));
#line 5257
  return;
}
}
#line 5258 "D:/a/test/177.c"
void glMateriali(GLenum face , GLenum pname , GLint param ) 
{ float fparam[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5261
  tmp = gl_get_thread_context();
#line 5261
  CC = (GLcontext *)tmp;
#line 5262
  if (! CC) {
#line 5262
    tmp___1 = getenv("MESA_DEBUG");
#line 5262
    if (tmp___1) {
#line 5262
      tmp___0 = __getreent();
#line 5262
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5262
    return;
  }
#line 5263
  fparam[0] = (float )param;
#line 5264
  (*(CC->API.Materialfv))(CC, face, pname, (float const   *)(fparam));
#line 5265
  return;
}
}
#line 5266 "D:/a/test/177.c"
void glMaterialfv(GLenum face , GLenum pname , float const   *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5268
  tmp = gl_get_thread_context();
#line 5268
  CC = (GLcontext *)tmp;
#line 5269
  if (! CC) {
#line 5269
    tmp___1 = getenv("MESA_DEBUG");
#line 5269
    if (tmp___1) {
#line 5269
      tmp___0 = __getreent();
#line 5269
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5269
    return;
  }
#line 5270
  (*(CC->API.Materialfv))(CC, face, pname, params);
#line 5271
  return;
}
}
#line 5272 "D:/a/test/177.c"
void glMaterialiv(GLenum face , GLenum pname , GLint const   *params ) 
{ float fparam[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5275
  tmp = gl_get_thread_context();
#line 5275
  CC = (GLcontext *)tmp;
#line 5276
  if (! CC) {
#line 5276
    tmp___1 = getenv("MESA_DEBUG");
#line 5276
    if (tmp___1) {
#line 5276
      tmp___0 = __getreent();
#line 5276
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5276
    return;
  }
#line 5277
  switch (pname) {
  case 4608: 
  case 4609: 
  case 4610: 
  case 5632: 
  case 5634: 
#line 5283
  fparam[0] = (2.0F * (float )*(params + 0) + 1.0F) * (1.0F / 4294967294.0F);
#line 5284
  fparam[1] = (2.0F * (float )*(params + 1) + 1.0F) * (1.0F / 4294967294.0F);
#line 5285
  fparam[2] = (2.0F * (float )*(params + 2) + 1.0F) * (1.0F / 4294967294.0F);
#line 5286
  fparam[3] = (2.0F * (float )*(params + 3) + 1.0F) * (1.0F / 4294967294.0F);
#line 5287
  break;
  case 5633: 
#line 5289
  fparam[0] = (float )*(params + 0);
#line 5290
  break;
  case 5635: 
#line 5292
  fparam[0] = (float )*(params + 0);
#line 5293
  fparam[1] = (float )*(params + 1);
#line 5294
  fparam[2] = (float )*(params + 2);
#line 5295
  break;
  default: ;
  }
#line 5299
  (*(CC->API.Materialfv))(CC, face, pname, (float const   *)(fparam));
#line 5300
  return;
}
}
#line 5301 "D:/a/test/177.c"
void glMatrixMode(GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5303
  tmp = gl_get_thread_context();
#line 5303
  CC = (GLcontext *)tmp;
#line 5304
  if (! CC) {
#line 5304
    tmp___1 = getenv("MESA_DEBUG");
#line 5304
    if (tmp___1) {
#line 5304
      tmp___0 = __getreent();
#line 5304
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5304
    return;
  }
#line 5305
  (*(CC->API.MatrixMode))(CC, mode);
#line 5306
  return;
}
}
#line 5307 "D:/a/test/177.c"
void glMultMatrixd(GLdouble const   *m ) 
{ float fm[16] ;
  GLuint i ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5311
  tmp = gl_get_thread_context();
#line 5311
  CC = (GLcontext *)tmp;
#line 5312
  if (! CC) {
#line 5312
    tmp___1 = getenv("MESA_DEBUG");
#line 5312
    if (tmp___1) {
#line 5312
      tmp___0 = __getreent();
#line 5312
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5312
    return;
  }
#line 5313
  i = 0U;
#line 5313
  while (i < 16U) {
#line 5314
    fm[i] = (float )*(m + i);
#line 5313
    i ++;
  }
#line 5316
  (*(CC->API.MultMatrixf))(CC, (float const   *)(fm));
#line 5317
  return;
}
}
#line 5318 "D:/a/test/177.c"
void glMultMatrixf(float const   *m ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5320
  tmp = gl_get_thread_context();
#line 5320
  CC = (GLcontext *)tmp;
#line 5321
  if (! CC) {
#line 5321
    tmp___1 = getenv("MESA_DEBUG");
#line 5321
    if (tmp___1) {
#line 5321
      tmp___0 = __getreent();
#line 5321
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5321
    return;
  }
#line 5322
  (*(CC->API.MultMatrixf))(CC, m);
#line 5323
  return;
}
}
#line 5324 "D:/a/test/177.c"
void glNewList(GLuint list , GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5326
  tmp = gl_get_thread_context();
#line 5326
  CC = (GLcontext *)tmp;
#line 5327
  if (! CC) {
#line 5327
    tmp___1 = getenv("MESA_DEBUG");
#line 5327
    if (tmp___1) {
#line 5327
      tmp___0 = __getreent();
#line 5327
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5327
    return;
  }
#line 5328
  (*(CC->API.NewList))(CC, list, mode);
#line 5329
  return;
}
}
#line 5330 "D:/a/test/177.c"
void glNormal3b(GLbyte nx , GLbyte ny , GLbyte nz ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5332
  tmp = gl_get_thread_context();
#line 5332
  CC = (GLcontext *)tmp;
#line 5333
  (*(CC->API.Normal3f))(CC, (2.0F * (float )nx + 1.0F) * (1.0F / 255.0F), (2.0F * (float )ny + 1.0F) * (1.0F / 255.0F),
                        (2.0F * (float )nz + 1.0F) * (1.0F / 255.0F));
#line 5335
  return;
}
}
#line 5336 "D:/a/test/177.c"
void glNormal3d(GLdouble nx , GLdouble ny , GLdouble nz ) 
{ float fx ;
  float fy ;
  float fz ;
  GLcontext *CC ;
  int tmp ;
  GLdouble tmp___0 ;
  GLdouble tmp___1 ;
  GLdouble tmp___2 ;

  {
#line 5339
  tmp = gl_get_thread_context();
#line 5339
  CC = (GLcontext *)tmp;
#line 5340
  if (nx < 0.0) {
#line 5340
    tmp___0 = - nx;
  } else {
#line 5340
    tmp___0 = nx;
  }
#line 5340
  if (tmp___0 < 0.00001) {
#line 5340
    fx = 0.0F;
  } else {
#line 5340
    fx = (float )nx;
  }
#line 5341
  if (ny < 0.0) {
#line 5341
    tmp___1 = - ny;
  } else {
#line 5341
    tmp___1 = ny;
  }
#line 5341
  if (tmp___1 < 0.00001) {
#line 5341
    fy = 0.0F;
  } else {
#line 5341
    fy = (float )ny;
  }
#line 5342
  if (nz < 0.0) {
#line 5342
    tmp___2 = - nz;
  } else {
#line 5342
    tmp___2 = nz;
  }
#line 5342
  if (tmp___2 < 0.00001) {
#line 5342
    fz = 0.0F;
  } else {
#line 5342
    fz = (float )nz;
  }
#line 5343
  (*(CC->API.Normal3f))(CC, fx, fy, fz);
#line 5344
  return;
}
}
#line 5345 "D:/a/test/177.c"
void glNormal3f(float nx , float ny , float nz ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5347
  tmp = gl_get_thread_context();
#line 5347
  CC = (GLcontext *)tmp;
#line 5359
  (*(CC->API.Normal3f))(CC, nx, ny, nz);
#line 5361
  return;
}
}
#line 5362 "D:/a/test/177.c"
void glNormal3i(GLint nx , GLint ny , GLint nz ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5364
  tmp = gl_get_thread_context();
#line 5364
  CC = (GLcontext *)tmp;
#line 5365
  (*(CC->API.Normal3f))(CC, (2.0F * (float )nx + 1.0F) * (1.0F / 4294967294.0F), (2.0F * (float )ny + 1.0F) * (1.0F / 4294967294.0F),
                        (2.0F * (float )nz + 1.0F) * (1.0F / 4294967294.0F));
#line 5367
  return;
}
}
#line 5368 "D:/a/test/177.c"
void glNormal3s(GLshort nx , GLshort ny , GLshort nz ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5370
  tmp = gl_get_thread_context();
#line 5370
  CC = (GLcontext *)tmp;
#line 5371
  (*(CC->API.Normal3f))(CC, (2.0F * (float )nx + 1.0F) * (1.0F / 65535.0F), (2.0F * (float )ny + 1.0F) * (1.0F / 65535.0F),
                        (2.0F * (float )nz + 1.0F) * (1.0F / 65535.0F));
#line 5373
  return;
}
}
#line 5374 "D:/a/test/177.c"
void glNormal3bv(GLbyte const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5376
  tmp = gl_get_thread_context();
#line 5376
  CC = (GLcontext *)tmp;
#line 5377
  (*(CC->API.Normal3f))(CC, (2.0F * (float )*(v + 0) + 1.0F) * (1.0F / 255.0F), (2.0F * (float )*(v + 1) + 1.0F) * (1.0F / 255.0F),
                        (2.0F * (float )*(v + 2) + 1.0F) * (1.0F / 255.0F));
#line 5379
  return;
}
}
#line 5380 "D:/a/test/177.c"
void glNormal3dv(GLdouble const   *v ) 
{ float fx ;
  float fy ;
  float fz ;
  GLcontext *CC ;
  int tmp ;
  GLdouble tmp___0 ;
  GLdouble tmp___1 ;
  GLdouble tmp___2 ;

  {
#line 5383
  tmp = gl_get_thread_context();
#line 5383
  CC = (GLcontext *)tmp;
#line 5384
  if (*(v + 0) < (GLdouble const   )0.0) {
#line 5384
    tmp___0 = - *(v + 0);
  } else {
#line 5384
    tmp___0 = *(v + 0);
  }
#line 5384
  if (tmp___0 < (GLdouble const   )0.00001) {
#line 5384
    fx = 0.0F;
  } else {
#line 5384
    fx = (float )*(v + 0);
  }
#line 5385
  if (*(v + 1) < (GLdouble const   )0.0) {
#line 5385
    tmp___1 = - *(v + 1);
  } else {
#line 5385
    tmp___1 = *(v + 1);
  }
#line 5385
  if (tmp___1 < (GLdouble const   )0.00001) {
#line 5385
    fy = 0.0F;
  } else {
#line 5385
    fy = (float )*(v + 1);
  }
#line 5386
  if (*(v + 2) < (GLdouble const   )0.0) {
#line 5386
    tmp___2 = - *(v + 2);
  } else {
#line 5386
    tmp___2 = *(v + 2);
  }
#line 5386
  if (tmp___2 < (GLdouble const   )0.00001) {
#line 5386
    fz = 0.0F;
  } else {
#line 5386
    fz = (float )*(v + 2);
  }
#line 5387
  (*(CC->API.Normal3f))(CC, fx, fy, fz);
#line 5388
  return;
}
}
#line 5389 "D:/a/test/177.c"
void glNormal3fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5391
  tmp = gl_get_thread_context();
#line 5391
  CC = (GLcontext *)tmp;
#line 5404
  (*(CC->API.Normal3fv))(CC, v);
#line 5406
  return;
}
}
#line 5407 "D:/a/test/177.c"
void glNormal3iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5409
  tmp = gl_get_thread_context();
#line 5409
  CC = (GLcontext *)tmp;
#line 5410
  (*(CC->API.Normal3f))(CC, (2.0F * (float )*(v + 0) + 1.0F) * (1.0F / 4294967294.0F),
                        (2.0F * (float )*(v + 1) + 1.0F) * (1.0F / 4294967294.0F),
                        (2.0F * (float )*(v + 2) + 1.0F) * (1.0F / 4294967294.0F));
#line 5412
  return;
}
}
#line 5413 "D:/a/test/177.c"
void glNormal3sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5415
  tmp = gl_get_thread_context();
#line 5415
  CC = (GLcontext *)tmp;
#line 5416
  (*(CC->API.Normal3f))(CC, (2.0F * (float )*(v + 0) + 1.0F) * (1.0F / 65535.0F),
                        (2.0F * (float )*(v + 1) + 1.0F) * (1.0F / 65535.0F), (2.0F * (float )*(v + 2) + 1.0F) * (1.0F / 65535.0F));
#line 5418
  return;
}
}
#line 5419 "D:/a/test/177.c"
void glNormalPointer(GLenum type , GLsizei stride , GLvoid const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5421
  tmp = gl_get_thread_context();
#line 5421
  CC = (GLcontext *)tmp;
#line 5422
  if (! CC) {
#line 5422
    tmp___1 = getenv("MESA_DEBUG");
#line 5422
    if (tmp___1) {
#line 5422
      tmp___0 = __getreent();
#line 5422
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5422
    return;
  }
#line 5423
  (*(CC->API.NormalPointer))(CC, type, stride, ptr);
#line 5424
  return;
}
}
#line 5430 "D:/a/test/177.c"
void glOrtho(GLdouble left , GLdouble right , GLdouble bottom , GLdouble top , GLdouble nearval ,
             GLdouble farval ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5434
  tmp = gl_get_thread_context();
#line 5434
  CC = (GLcontext *)tmp;
#line 5435
  if (! CC) {
#line 5435
    tmp___1 = getenv("MESA_DEBUG");
#line 5435
    if (tmp___1) {
#line 5435
      tmp___0 = __getreent();
#line 5435
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5435
    return;
  }
#line 5436
  (*(CC->API.Ortho))(CC, left, right, bottom, top, nearval, farval);
#line 5437
  return;
}
}
#line 5438 "D:/a/test/177.c"
void glPassThrough(float token ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5440
  tmp = gl_get_thread_context();
#line 5440
  CC = (GLcontext *)tmp;
#line 5441
  if (! CC) {
#line 5441
    tmp___1 = getenv("MESA_DEBUG");
#line 5441
    if (tmp___1) {
#line 5441
      tmp___0 = __getreent();
#line 5441
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5441
    return;
  }
#line 5442
  (*(CC->API.PassThrough))(CC, token);
#line 5443
  return;
}
}
#line 5444 "D:/a/test/177.c"
void glPixelMapfv(GLenum map , GLint mapsize , float const   *values ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5446
  tmp = gl_get_thread_context();
#line 5446
  CC = (GLcontext *)tmp;
#line 5447
  if (! CC) {
#line 5447
    tmp___1 = getenv("MESA_DEBUG");
#line 5447
    if (tmp___1) {
#line 5447
      tmp___0 = __getreent();
#line 5447
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5447
    return;
  }
#line 5448
  (*(CC->API.PixelMapfv))(CC, map, mapsize, values);
#line 5449
  return;
}
}
#line 5450 "D:/a/test/177.c"
void glPixelMapuiv(GLenum map , GLint mapsize , GLuint const   *values ) 
{ float fvalues[256] ;
  GLuint i ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5454
  tmp = gl_get_thread_context();
#line 5454
  CC = (GLcontext *)tmp;
#line 5455
  if (! CC) {
#line 5455
    tmp___1 = getenv("MESA_DEBUG");
#line 5455
    if (tmp___1) {
#line 5455
      tmp___0 = __getreent();
#line 5455
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5455
    return;
  }
#line 5456
  if (map == 3184) {
    goto _L;
  } else {
#line 5456
    if (map == 3185) {
      _L: /* CIL Label */ 
#line 5457
      i = 0U;
#line 5457
      while (i < (GLuint )mapsize) {
#line 5458
        fvalues[i] = (float )*(values + i);
#line 5457
        i ++;
      }
    } else {
#line 5462
      i = 0U;
#line 5462
      while (i < (GLuint )mapsize) {
#line 5463
        fvalues[i] = (float )*(values + i) * (1.0F / 4294967295.0F);
#line 5462
        i ++;
      }
    }
  }
#line 5466
  (*(CC->API.PixelMapfv))(CC, map, mapsize, (float const   *)(fvalues));
#line 5467
  return;
}
}
#line 5468 "D:/a/test/177.c"
void glPixelMapusv(GLenum map , GLint mapsize , GLushort const   *values ) 
{ float fvalues[256] ;
  GLuint i ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5472
  tmp = gl_get_thread_context();
#line 5472
  CC = (GLcontext *)tmp;
#line 5473
  if (! CC) {
#line 5473
    tmp___1 = getenv("MESA_DEBUG");
#line 5473
    if (tmp___1) {
#line 5473
      tmp___0 = __getreent();
#line 5473
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5473
    return;
  }
#line 5474
  if (map == 3184) {
    goto _L;
  } else {
#line 5474
    if (map == 3185) {
      _L: /* CIL Label */ 
#line 5475
      i = 0U;
#line 5475
      while (i < (GLuint )mapsize) {
#line 5476
        fvalues[i] = (float )*(values + i);
#line 5475
        i ++;
      }
    } else {
#line 5480
      i = 0U;
#line 5480
      while (i < (GLuint )mapsize) {
#line 5481
        fvalues[i] = (float )*(values + i) * (1.0F / 65535.0F);
#line 5480
        i ++;
      }
    }
  }
#line 5484
  (*(CC->API.PixelMapfv))(CC, map, mapsize, (float const   *)(fvalues));
#line 5485
  return;
}
}
#line 5486 "D:/a/test/177.c"
void glPixelStoref(GLenum pname , float param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5488
  tmp = gl_get_thread_context();
#line 5488
  CC = (GLcontext *)tmp;
#line 5489
  if (! CC) {
#line 5489
    tmp___1 = getenv("MESA_DEBUG");
#line 5489
    if (tmp___1) {
#line 5489
      tmp___0 = __getreent();
#line 5489
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5489
    return;
  }
#line 5490
  (*(CC->API.PixelStorei))(CC, pname, (int )param);
#line 5491
  return;
}
}
#line 5492 "D:/a/test/177.c"
void glPixelStorei(GLenum pname , GLint param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5494
  tmp = gl_get_thread_context();
#line 5494
  CC = (GLcontext *)tmp;
#line 5495
  if (! CC) {
#line 5495
    tmp___1 = getenv("MESA_DEBUG");
#line 5495
    if (tmp___1) {
#line 5495
      tmp___0 = __getreent();
#line 5495
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5495
    return;
  }
#line 5496
  (*(CC->API.PixelStorei))(CC, pname, param);
#line 5497
  return;
}
}
#line 5498 "D:/a/test/177.c"
void glPixelTransferf(GLenum pname , float param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5500
  tmp = gl_get_thread_context();
#line 5500
  CC = (GLcontext *)tmp;
#line 5501
  if (! CC) {
#line 5501
    tmp___1 = getenv("MESA_DEBUG");
#line 5501
    if (tmp___1) {
#line 5501
      tmp___0 = __getreent();
#line 5501
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5501
    return;
  }
#line 5502
  (*(CC->API.PixelTransferf))(CC, pname, param);
#line 5503
  return;
}
}
#line 5504 "D:/a/test/177.c"
void glPixelTransferi(GLenum pname , GLint param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5506
  tmp = gl_get_thread_context();
#line 5506
  CC = (GLcontext *)tmp;
#line 5507
  if (! CC) {
#line 5507
    tmp___1 = getenv("MESA_DEBUG");
#line 5507
    if (tmp___1) {
#line 5507
      tmp___0 = __getreent();
#line 5507
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5507
    return;
  }
#line 5508
  (*(CC->API.PixelTransferf))(CC, pname, (float )param);
#line 5509
  return;
}
}
#line 5510 "D:/a/test/177.c"
void glPixelZoom(float xfactor , float yfactor ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5512
  tmp = gl_get_thread_context();
#line 5512
  CC = (GLcontext *)tmp;
#line 5513
  if (! CC) {
#line 5513
    tmp___1 = getenv("MESA_DEBUG");
#line 5513
    if (tmp___1) {
#line 5513
      tmp___0 = __getreent();
#line 5513
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5513
    return;
  }
#line 5514
  (*(CC->API.PixelZoom))(CC, xfactor, yfactor);
#line 5515
  return;
}
}
#line 5516 "D:/a/test/177.c"
void glPointSize(float size ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5518
  tmp = gl_get_thread_context();
#line 5518
  CC = (GLcontext *)tmp;
#line 5519
  if (! CC) {
#line 5519
    tmp___1 = getenv("MESA_DEBUG");
#line 5519
    if (tmp___1) {
#line 5519
      tmp___0 = __getreent();
#line 5519
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5519
    return;
  }
#line 5520
  (*(CC->API.PointSize))(CC, size);
#line 5521
  return;
}
}
#line 5522 "D:/a/test/177.c"
void glPolygonMode(GLenum face , GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5524
  tmp = gl_get_thread_context();
#line 5524
  CC = (GLcontext *)tmp;
#line 5525
  if (! CC) {
#line 5525
    tmp___1 = getenv("MESA_DEBUG");
#line 5525
    if (tmp___1) {
#line 5525
      tmp___0 = __getreent();
#line 5525
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5525
    return;
  }
#line 5526
  (*(CC->API.PolygonMode))(CC, face, mode);
#line 5527
  return;
}
}
#line 5528 "D:/a/test/177.c"
void glPolygonOffset(float factor , float units ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5530
  tmp = gl_get_thread_context();
#line 5530
  CC = (GLcontext *)tmp;
#line 5531
  if (! CC) {
#line 5531
    tmp___1 = getenv("MESA_DEBUG");
#line 5531
    if (tmp___1) {
#line 5531
      tmp___0 = __getreent();
#line 5531
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5531
    return;
  }
#line 5532
  (*(CC->API.PolygonOffset))(CC, factor, units);
#line 5533
  return;
}
}
#line 5540 "D:/a/test/177.c"
void glPolygonStipple(GLubyte const   *mask ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5542
  tmp = gl_get_thread_context();
#line 5542
  CC = (GLcontext *)tmp;
#line 5543
  if (! CC) {
#line 5543
    tmp___1 = getenv("MESA_DEBUG");
#line 5543
    if (tmp___1) {
#line 5543
      tmp___0 = __getreent();
#line 5543
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5543
    return;
  }
#line 5544
  (*(CC->API.PolygonStipple))(CC, mask);
#line 5545
  return;
}
}
#line 5546 "D:/a/test/177.c"
void glPopAttrib(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5548
  tmp = gl_get_thread_context();
#line 5548
  CC = (GLcontext *)tmp;
#line 5549
  if (! CC) {
#line 5549
    tmp___1 = getenv("MESA_DEBUG");
#line 5549
    if (tmp___1) {
#line 5549
      tmp___0 = __getreent();
#line 5549
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5549
    return;
  }
#line 5550
  (*(CC->API.PopAttrib))(CC);
#line 5551
  return;
}
}
#line 5552 "D:/a/test/177.c"
void glPopClientAttrib(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5554
  tmp = gl_get_thread_context();
#line 5554
  CC = (GLcontext *)tmp;
#line 5555
  if (! CC) {
#line 5555
    tmp___1 = getenv("MESA_DEBUG");
#line 5555
    if (tmp___1) {
#line 5555
      tmp___0 = __getreent();
#line 5555
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5555
    return;
  }
#line 5556
  (*(CC->API.PopClientAttrib))(CC);
#line 5557
  return;
}
}
#line 5558 "D:/a/test/177.c"
void glPopMatrix(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5560
  tmp = gl_get_thread_context();
#line 5560
  CC = (GLcontext *)tmp;
#line 5561
  if (! CC) {
#line 5561
    tmp___1 = getenv("MESA_DEBUG");
#line 5561
    if (tmp___1) {
#line 5561
      tmp___0 = __getreent();
#line 5561
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5561
    return;
  }
#line 5562
  (*(CC->API.PopMatrix))(CC);
#line 5563
  return;
}
}
#line 5564 "D:/a/test/177.c"
void glPopName(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5566
  tmp = gl_get_thread_context();
#line 5566
  CC = (GLcontext *)tmp;
#line 5567
  if (! CC) {
#line 5567
    tmp___1 = getenv("MESA_DEBUG");
#line 5567
    if (tmp___1) {
#line 5567
      tmp___0 = __getreent();
#line 5567
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5567
    return;
  }
#line 5568
  (*(CC->API.PopName))(CC);
#line 5569
  return;
}
}
#line 5570 "D:/a/test/177.c"
void glPrioritizeTextures(GLsizei n , GLuint const   *textures , GLclampf const   *priorities ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5573
  tmp = gl_get_thread_context();
#line 5573
  CC = (GLcontext *)tmp;
#line 5574
  if (! CC) {
#line 5574
    tmp___1 = getenv("MESA_DEBUG");
#line 5574
    if (tmp___1) {
#line 5574
      tmp___0 = __getreent();
#line 5574
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5574
    return;
  }
#line 5575
  (*(CC->API.PrioritizeTextures))(CC, n, textures, priorities);
#line 5576
  return;
}
}
#line 5577 "D:/a/test/177.c"
void glPushMatrix(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5579
  tmp = gl_get_thread_context();
#line 5579
  CC = (GLcontext *)tmp;
#line 5580
  if (! CC) {
#line 5580
    tmp___1 = getenv("MESA_DEBUG");
#line 5580
    if (tmp___1) {
#line 5580
      tmp___0 = __getreent();
#line 5580
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5580
    return;
  }
#line 5581
  (*(CC->API.PushMatrix))(CC);
#line 5582
  return;
}
}
#line 5583 "D:/a/test/177.c"
void glRasterPos2d(GLdouble x , GLdouble y ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5585
  tmp = gl_get_thread_context();
#line 5585
  CC = (GLcontext *)tmp;
#line 5586
  if (! CC) {
#line 5586
    tmp___1 = getenv("MESA_DEBUG");
#line 5586
    if (tmp___1) {
#line 5586
      tmp___0 = __getreent();
#line 5586
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5586
    return;
  }
#line 5587
  (*(CC->API.RasterPos4f))(CC, (float )x, (float )y, 0.0F, 1.0F);
#line 5588
  return;
}
}
#line 5589 "D:/a/test/177.c"
void glRasterPos2f(float x , float y ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5591
  tmp = gl_get_thread_context();
#line 5591
  CC = (GLcontext *)tmp;
#line 5592
  if (! CC) {
#line 5592
    tmp___1 = getenv("MESA_DEBUG");
#line 5592
    if (tmp___1) {
#line 5592
      tmp___0 = __getreent();
#line 5592
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5592
    return;
  }
#line 5593
  (*(CC->API.RasterPos4f))(CC, x, y, 0.0F, 1.0F);
#line 5594
  return;
}
}
#line 5595 "D:/a/test/177.c"
void glRasterPos2i(GLint x , GLint y ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5597
  tmp = gl_get_thread_context();
#line 5597
  CC = (GLcontext *)tmp;
#line 5598
  if (! CC) {
#line 5598
    tmp___1 = getenv("MESA_DEBUG");
#line 5598
    if (tmp___1) {
#line 5598
      tmp___0 = __getreent();
#line 5598
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5598
    return;
  }
#line 5599
  (*(CC->API.RasterPos4f))(CC, (float )x, (float )y, 0.0F, 1.0F);
#line 5600
  return;
}
}
#line 5601 "D:/a/test/177.c"
void glRasterPos2s(GLshort x , GLshort y ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5603
  tmp = gl_get_thread_context();
#line 5603
  CC = (GLcontext *)tmp;
#line 5604
  if (! CC) {
#line 5604
    tmp___1 = getenv("MESA_DEBUG");
#line 5604
    if (tmp___1) {
#line 5604
      tmp___0 = __getreent();
#line 5604
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5604
    return;
  }
#line 5605
  (*(CC->API.RasterPos4f))(CC, (float )x, (float )y, 0.0F, 1.0F);
#line 5606
  return;
}
}
#line 5607 "D:/a/test/177.c"
void glRasterPos3d(GLdouble x , GLdouble y , GLdouble z ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5609
  tmp = gl_get_thread_context();
#line 5609
  CC = (GLcontext *)tmp;
#line 5610
  if (! CC) {
#line 5610
    tmp___1 = getenv("MESA_DEBUG");
#line 5610
    if (tmp___1) {
#line 5610
      tmp___0 = __getreent();
#line 5610
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5610
    return;
  }
#line 5611
  (*(CC->API.RasterPos4f))(CC, (float )x, (float )y, (float )z, 1.0F);
#line 5612
  return;
}
}
#line 5613 "D:/a/test/177.c"
void glRasterPos3f(float x , float y , float z ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5615
  tmp = gl_get_thread_context();
#line 5615
  CC = (GLcontext *)tmp;
#line 5616
  if (! CC) {
#line 5616
    tmp___1 = getenv("MESA_DEBUG");
#line 5616
    if (tmp___1) {
#line 5616
      tmp___0 = __getreent();
#line 5616
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5616
    return;
  }
#line 5617
  (*(CC->API.RasterPos4f))(CC, x, y, z, 1.0F);
#line 5618
  return;
}
}
#line 5619 "D:/a/test/177.c"
void glRasterPos3i(GLint x , GLint y , GLint z ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5621
  tmp = gl_get_thread_context();
#line 5621
  CC = (GLcontext *)tmp;
#line 5622
  if (! CC) {
#line 5622
    tmp___1 = getenv("MESA_DEBUG");
#line 5622
    if (tmp___1) {
#line 5622
      tmp___0 = __getreent();
#line 5622
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5622
    return;
  }
#line 5623
  (*(CC->API.RasterPos4f))(CC, (float )x, (float )y, (float )z, 1.0F);
#line 5624
  return;
}
}
#line 5625 "D:/a/test/177.c"
void glRasterPos3s(GLshort x , GLshort y , GLshort z ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5627
  tmp = gl_get_thread_context();
#line 5627
  CC = (GLcontext *)tmp;
#line 5628
  if (! CC) {
#line 5628
    tmp___1 = getenv("MESA_DEBUG");
#line 5628
    if (tmp___1) {
#line 5628
      tmp___0 = __getreent();
#line 5628
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5628
    return;
  }
#line 5629
  (*(CC->API.RasterPos4f))(CC, (float )x, (float )y, (float )z, 1.0F);
#line 5630
  return;
}
}
#line 5631 "D:/a/test/177.c"
void glRasterPos4d(GLdouble x , GLdouble y , GLdouble z , GLdouble w ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5633
  tmp = gl_get_thread_context();
#line 5633
  CC = (GLcontext *)tmp;
#line 5634
  if (! CC) {
#line 5634
    tmp___1 = getenv("MESA_DEBUG");
#line 5634
    if (tmp___1) {
#line 5634
      tmp___0 = __getreent();
#line 5634
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5634
    return;
  }
#line 5635
  (*(CC->API.RasterPos4f))(CC, (float )x, (float )y, (float )z, (float )w);
#line 5637
  return;
}
}
#line 5638 "D:/a/test/177.c"
void glRasterPos4f(float x , float y , float z , float w ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5640
  tmp = gl_get_thread_context();
#line 5640
  CC = (GLcontext *)tmp;
#line 5641
  if (! CC) {
#line 5641
    tmp___1 = getenv("MESA_DEBUG");
#line 5641
    if (tmp___1) {
#line 5641
      tmp___0 = __getreent();
#line 5641
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5641
    return;
  }
#line 5642
  (*(CC->API.RasterPos4f))(CC, x, y, z, w);
#line 5643
  return;
}
}
#line 5644 "D:/a/test/177.c"
void glRasterPos4i(GLint x , GLint y , GLint z , GLint w ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5646
  tmp = gl_get_thread_context();
#line 5646
  CC = (GLcontext *)tmp;
#line 5647
  if (! CC) {
#line 5647
    tmp___1 = getenv("MESA_DEBUG");
#line 5647
    if (tmp___1) {
#line 5647
      tmp___0 = __getreent();
#line 5647
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5647
    return;
  }
#line 5648
  (*(CC->API.RasterPos4f))(CC, (float )x, (float )y, (float )z, (float )w);
#line 5650
  return;
}
}
#line 5651 "D:/a/test/177.c"
void glRasterPos4s(GLshort x , GLshort y , GLshort z , GLshort w ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5653
  tmp = gl_get_thread_context();
#line 5653
  CC = (GLcontext *)tmp;
#line 5654
  if (! CC) {
#line 5654
    tmp___1 = getenv("MESA_DEBUG");
#line 5654
    if (tmp___1) {
#line 5654
      tmp___0 = __getreent();
#line 5654
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5654
    return;
  }
#line 5655
  (*(CC->API.RasterPos4f))(CC, (float )x, (float )y, (float )z, (float )w);
#line 5657
  return;
}
}
#line 5658 "D:/a/test/177.c"
void glRasterPos2dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5660
  tmp = gl_get_thread_context();
#line 5660
  CC = (GLcontext *)tmp;
#line 5661
  if (! CC) {
#line 5661
    tmp___1 = getenv("MESA_DEBUG");
#line 5661
    if (tmp___1) {
#line 5661
      tmp___0 = __getreent();
#line 5661
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5661
    return;
  }
#line 5662
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), 0.0F, 1.0F);
#line 5663
  return;
}
}
#line 5664 "D:/a/test/177.c"
void glRasterPos2fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5666
  tmp = gl_get_thread_context();
#line 5666
  CC = (GLcontext *)tmp;
#line 5667
  if (! CC) {
#line 5667
    tmp___1 = getenv("MESA_DEBUG");
#line 5667
    if (tmp___1) {
#line 5667
      tmp___0 = __getreent();
#line 5667
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5667
    return;
  }
#line 5668
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), 0.0F, 1.0F);
#line 5669
  return;
}
}
#line 5670 "D:/a/test/177.c"
void glRasterPos2iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5672
  tmp = gl_get_thread_context();
#line 5672
  CC = (GLcontext *)tmp;
#line 5673
  if (! CC) {
#line 5673
    tmp___1 = getenv("MESA_DEBUG");
#line 5673
    if (tmp___1) {
#line 5673
      tmp___0 = __getreent();
#line 5673
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5673
    return;
  }
#line 5674
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), 0.0F, 1.0F);
#line 5675
  return;
}
}
#line 5676 "D:/a/test/177.c"
void glRasterPos2sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5678
  tmp = gl_get_thread_context();
#line 5678
  CC = (GLcontext *)tmp;
#line 5679
  if (! CC) {
#line 5679
    tmp___1 = getenv("MESA_DEBUG");
#line 5679
    if (tmp___1) {
#line 5679
      tmp___0 = __getreent();
#line 5679
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5679
    return;
  }
#line 5680
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), 0.0F, 1.0F);
#line 5681
  return;
}
}
#line 5682 "D:/a/test/177.c"
void glRasterPos3dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5684
  tmp = gl_get_thread_context();
#line 5684
  CC = (GLcontext *)tmp;
#line 5685
  if (! CC) {
#line 5685
    tmp___1 = getenv("MESA_DEBUG");
#line 5685
    if (tmp___1) {
#line 5685
      tmp___0 = __getreent();
#line 5685
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5685
    return;
  }
#line 5686
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                           1.0F);
#line 5688
  return;
}
}
#line 5689 "D:/a/test/177.c"
void glRasterPos3fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5691
  tmp = gl_get_thread_context();
#line 5691
  CC = (GLcontext *)tmp;
#line 5692
  if (! CC) {
#line 5692
    tmp___1 = getenv("MESA_DEBUG");
#line 5692
    if (tmp___1) {
#line 5692
      tmp___0 = __getreent();
#line 5692
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5692
    return;
  }
#line 5693
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                           1.0F);
#line 5695
  return;
}
}
#line 5696 "D:/a/test/177.c"
void glRasterPos3iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5698
  tmp = gl_get_thread_context();
#line 5698
  CC = (GLcontext *)tmp;
#line 5699
  if (! CC) {
#line 5699
    tmp___1 = getenv("MESA_DEBUG");
#line 5699
    if (tmp___1) {
#line 5699
      tmp___0 = __getreent();
#line 5699
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5699
    return;
  }
#line 5700
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                           1.0F);
#line 5702
  return;
}
}
#line 5703 "D:/a/test/177.c"
void glRasterPos3sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5705
  tmp = gl_get_thread_context();
#line 5705
  CC = (GLcontext *)tmp;
#line 5706
  if (! CC) {
#line 5706
    tmp___1 = getenv("MESA_DEBUG");
#line 5706
    if (tmp___1) {
#line 5706
      tmp___0 = __getreent();
#line 5706
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5706
    return;
  }
#line 5707
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                           1.0F);
#line 5709
  return;
}
}
#line 5710 "D:/a/test/177.c"
void glRasterPos4dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5712
  tmp = gl_get_thread_context();
#line 5712
  CC = (GLcontext *)tmp;
#line 5713
  if (! CC) {
#line 5713
    tmp___1 = getenv("MESA_DEBUG");
#line 5713
    if (tmp___1) {
#line 5713
      tmp___0 = __getreent();
#line 5713
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5713
    return;
  }
#line 5714
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                           (float )*(v + 3));
#line 5716
  return;
}
}
#line 5717 "D:/a/test/177.c"
void glRasterPos4fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5719
  tmp = gl_get_thread_context();
#line 5719
  CC = (GLcontext *)tmp;
#line 5720
  if (! CC) {
#line 5720
    tmp___1 = getenv("MESA_DEBUG");
#line 5720
    if (tmp___1) {
#line 5720
      tmp___0 = __getreent();
#line 5720
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5720
    return;
  }
#line 5721
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                           (float )*(v + 3));
#line 5722
  return;
}
}
#line 5723 "D:/a/test/177.c"
void glRasterPos4iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5725
  tmp = gl_get_thread_context();
#line 5725
  CC = (GLcontext *)tmp;
#line 5726
  if (! CC) {
#line 5726
    tmp___1 = getenv("MESA_DEBUG");
#line 5726
    if (tmp___1) {
#line 5726
      tmp___0 = __getreent();
#line 5726
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5726
    return;
  }
#line 5727
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                           (float )*(v + 3));
#line 5729
  return;
}
}
#line 5730 "D:/a/test/177.c"
void glRasterPos4sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5732
  tmp = gl_get_thread_context();
#line 5732
  CC = (GLcontext *)tmp;
#line 5733
  if (! CC) {
#line 5733
    tmp___1 = getenv("MESA_DEBUG");
#line 5733
    if (tmp___1) {
#line 5733
      tmp___0 = __getreent();
#line 5733
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5733
    return;
  }
#line 5734
  (*(CC->API.RasterPos4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                           (float )*(v + 3));
#line 5736
  return;
}
}
#line 5737 "D:/a/test/177.c"
void glReadBuffer(GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5739
  tmp = gl_get_thread_context();
#line 5739
  CC = (GLcontext *)tmp;
#line 5740
  if (! CC) {
#line 5740
    tmp___1 = getenv("MESA_DEBUG");
#line 5740
    if (tmp___1) {
#line 5740
      tmp___0 = __getreent();
#line 5740
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5740
    return;
  }
#line 5741
  (*(CC->API.ReadBuffer))(CC, mode);
#line 5742
  return;
}
}
#line 5743 "D:/a/test/177.c"
void glReadPixels(GLint x , GLint y , GLsizei width , GLsizei height , GLenum format ,
                  GLenum type , GLvoid *pixels ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5746
  tmp = gl_get_thread_context();
#line 5746
  CC = (GLcontext *)tmp;
#line 5747
  if (! CC) {
#line 5747
    tmp___1 = getenv("MESA_DEBUG");
#line 5747
    if (tmp___1) {
#line 5747
      tmp___0 = __getreent();
#line 5747
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5747
    return;
  }
#line 5748
  (*(CC->API.ReadPixels))(CC, x, y, width, height, format, type, pixels);
#line 5749
  return;
}
}
#line 5750 "D:/a/test/177.c"
void glRectd(GLdouble x1 , GLdouble y1___0 , GLdouble x2 , GLdouble y2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5752
  tmp = gl_get_thread_context();
#line 5752
  CC = (GLcontext *)tmp;
#line 5753
  if (! CC) {
#line 5753
    tmp___1 = getenv("MESA_DEBUG");
#line 5753
    if (tmp___1) {
#line 5753
      tmp___0 = __getreent();
#line 5753
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5753
    return;
  }
#line 5754
  (*(CC->API.Rectf))(CC, (float )x1, (float )y1___0, (float )x2, (float )y2);
#line 5756
  return;
}
}
#line 5757 "D:/a/test/177.c"
void glRectf(float x1 , float y1___0 , float x2 , float y2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5759
  tmp = gl_get_thread_context();
#line 5759
  CC = (GLcontext *)tmp;
#line 5760
  if (! CC) {
#line 5760
    tmp___1 = getenv("MESA_DEBUG");
#line 5760
    if (tmp___1) {
#line 5760
      tmp___0 = __getreent();
#line 5760
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5760
    return;
  }
#line 5761
  (*(CC->API.Rectf))(CC, x1, y1___0, x2, y2);
#line 5762
  return;
}
}
#line 5763 "D:/a/test/177.c"
void glRecti(GLint x1 , GLint y1___0 , GLint x2 , GLint y2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5765
  tmp = gl_get_thread_context();
#line 5765
  CC = (GLcontext *)tmp;
#line 5766
  if (! CC) {
#line 5766
    tmp___1 = getenv("MESA_DEBUG");
#line 5766
    if (tmp___1) {
#line 5766
      tmp___0 = __getreent();
#line 5766
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5766
    return;
  }
#line 5767
  (*(CC->API.Rectf))(CC, (float )x1, (float )y1___0, (float )x2, (float )y2);
#line 5769
  return;
}
}
#line 5770 "D:/a/test/177.c"
void glRects(GLshort x1 , GLshort y1___0 , GLshort x2 , GLshort y2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5772
  tmp = gl_get_thread_context();
#line 5772
  CC = (GLcontext *)tmp;
#line 5773
  if (! CC) {
#line 5773
    tmp___1 = getenv("MESA_DEBUG");
#line 5773
    if (tmp___1) {
#line 5773
      tmp___0 = __getreent();
#line 5773
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5773
    return;
  }
#line 5774
  (*(CC->API.Rectf))(CC, (float )x1, (float )y1___0, (float )x2, (float )y2);
#line 5776
  return;
}
}
#line 5777 "D:/a/test/177.c"
void glRectdv(GLdouble const   *v1 , GLdouble const   *v2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5779
  tmp = gl_get_thread_context();
#line 5779
  CC = (GLcontext *)tmp;
#line 5780
  if (! CC) {
#line 5780
    tmp___1 = getenv("MESA_DEBUG");
#line 5780
    if (tmp___1) {
#line 5780
      tmp___0 = __getreent();
#line 5780
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5780
    return;
  }
#line 5781
  (*(CC->API.Rectf))(CC, (float )*(v1 + 0), (float )*(v1 + 1), (float )*(v2 + 0),
                     (float )*(v2 + 1));
#line 5783
  return;
}
}
#line 5784 "D:/a/test/177.c"
void glRectfv(float const   *v1 , float const   *v2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5786
  tmp = gl_get_thread_context();
#line 5786
  CC = (GLcontext *)tmp;
#line 5787
  if (! CC) {
#line 5787
    tmp___1 = getenv("MESA_DEBUG");
#line 5787
    if (tmp___1) {
#line 5787
      tmp___0 = __getreent();
#line 5787
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5787
    return;
  }
#line 5788
  (*(CC->API.Rectf))(CC, (float )*(v1 + 0), (float )*(v1 + 1), (float )*(v2 + 0),
                     (float )*(v2 + 1));
#line 5789
  return;
}
}
#line 5790 "D:/a/test/177.c"
void glRectiv(GLint const   *v1 , GLint const   *v2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5792
  tmp = gl_get_thread_context();
#line 5792
  CC = (GLcontext *)tmp;
#line 5793
  if (! CC) {
#line 5793
    tmp___1 = getenv("MESA_DEBUG");
#line 5793
    if (tmp___1) {
#line 5793
      tmp___0 = __getreent();
#line 5793
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5793
    return;
  }
#line 5794
  (*(CC->API.Rectf))(CC, (float )*(v1 + 0), (float )*(v1 + 1), (float )*(v2 + 0),
                     (float )*(v2 + 1));
#line 5796
  return;
}
}
#line 5797 "D:/a/test/177.c"
void glRectsv(GLshort const   *v1 , GLshort const   *v2 ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5799
  tmp = gl_get_thread_context();
#line 5799
  CC = (GLcontext *)tmp;
#line 5800
  if (! CC) {
#line 5800
    tmp___1 = getenv("MESA_DEBUG");
#line 5800
    if (tmp___1) {
#line 5800
      tmp___0 = __getreent();
#line 5800
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5800
    return;
  }
#line 5801
  (*(CC->API.Rectf))(CC, (float )*(v1 + 0), (float )*(v1 + 1), (float )*(v2 + 0),
                     (float )*(v2 + 1));
#line 5803
  return;
}
}
#line 5804 "D:/a/test/177.c"
void glScissor(GLint x , GLint y , GLsizei width , GLsizei height ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5806
  tmp = gl_get_thread_context();
#line 5806
  CC = (GLcontext *)tmp;
#line 5807
  if (! CC) {
#line 5807
    tmp___1 = getenv("MESA_DEBUG");
#line 5807
    if (tmp___1) {
#line 5807
      tmp___0 = __getreent();
#line 5807
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5807
    return;
  }
#line 5808
  (*(CC->API.Scissor))(CC, x, y, width, height);
#line 5809
  return;
}
}
#line 5810 "D:/a/test/177.c"
GLboolean glIsEnabled(GLenum cap ) 
{ GLcontext *CC ;
  int tmp ;
  GLboolean tmp___0 ;

  {
#line 5812
  tmp = gl_get_thread_context();
#line 5812
  CC = (GLcontext *)tmp;
#line 5813
  CHECK_CONTEXT_RETURN(0);
#line 5814
  tmp___0 = (*(CC->API.IsEnabled))(CC, cap);
#line 5814
  return (tmp___0);
}
}
#line 5816 "D:/a/test/177.c"
void glPushAttrib(GLbitfield mask ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5818
  tmp = gl_get_thread_context();
#line 5818
  CC = (GLcontext *)tmp;
#line 5819
  if (! CC) {
#line 5819
    tmp___1 = getenv("MESA_DEBUG");
#line 5819
    if (tmp___1) {
#line 5819
      tmp___0 = __getreent();
#line 5819
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5819
    return;
  }
#line 5820
  (*(CC->API.PushAttrib))(CC, mask);
#line 5821
  return;
}
}
#line 5822 "D:/a/test/177.c"
void glPushClientAttrib(GLbitfield mask ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5824
  tmp = gl_get_thread_context();
#line 5824
  CC = (GLcontext *)tmp;
#line 5825
  if (! CC) {
#line 5825
    tmp___1 = getenv("MESA_DEBUG");
#line 5825
    if (tmp___1) {
#line 5825
      tmp___0 = __getreent();
#line 5825
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5825
    return;
  }
#line 5826
  (*(CC->API.PushClientAttrib))(CC, mask);
#line 5827
  return;
}
}
#line 5828 "D:/a/test/177.c"
void glPushName(GLuint name ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5830
  tmp = gl_get_thread_context();
#line 5830
  CC = (GLcontext *)tmp;
#line 5831
  if (! CC) {
#line 5831
    tmp___1 = getenv("MESA_DEBUG");
#line 5831
    if (tmp___1) {
#line 5831
      tmp___0 = __getreent();
#line 5831
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5831
    return;
  }
#line 5832
  (*(CC->API.PushName))(CC, name);
#line 5833
  return;
}
}
#line 5834 "D:/a/test/177.c"
GLint glRenderMode(GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  GLint tmp___0 ;

  {
#line 5836
  tmp = gl_get_thread_context();
#line 5836
  CC = (GLcontext *)tmp;
#line 5837
  CHECK_CONTEXT_RETURN(0);
#line 5838
  tmp___0 = (*(CC->API.RenderMode))(CC, mode);
#line 5838
  return (tmp___0);
}
}
#line 5840 "D:/a/test/177.c"
void glRotated(GLdouble angle , GLdouble x , GLdouble y , GLdouble z ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5842
  tmp = gl_get_thread_context();
#line 5842
  CC = (GLcontext *)tmp;
#line 5843
  if (! CC) {
#line 5843
    tmp___1 = getenv("MESA_DEBUG");
#line 5843
    if (tmp___1) {
#line 5843
      tmp___0 = __getreent();
#line 5843
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5843
    return;
  }
#line 5844
  (*(CC->API.Rotatef))(CC, (float )angle, (float )x, (float )y, (float )z);
#line 5846
  return;
}
}
#line 5847 "D:/a/test/177.c"
void glRotatef(float angle , float x , float y , float z ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5849
  tmp = gl_get_thread_context();
#line 5849
  CC = (GLcontext *)tmp;
#line 5850
  if (! CC) {
#line 5850
    tmp___1 = getenv("MESA_DEBUG");
#line 5850
    if (tmp___1) {
#line 5850
      tmp___0 = __getreent();
#line 5850
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5850
    return;
  }
#line 5851
  (*(CC->API.Rotatef))(CC, angle, x, y, z);
#line 5852
  return;
}
}
#line 5853 "D:/a/test/177.c"
void glSelectBuffer(GLsizei size , GLuint *buffer ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5855
  tmp = gl_get_thread_context();
#line 5855
  CC = (GLcontext *)tmp;
#line 5856
  if (! CC) {
#line 5856
    tmp___1 = getenv("MESA_DEBUG");
#line 5856
    if (tmp___1) {
#line 5856
      tmp___0 = __getreent();
#line 5856
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5856
    return;
  }
#line 5857
  (*(CC->API.SelectBuffer))(CC, size, buffer);
#line 5858
  return;
}
}
#line 5859 "D:/a/test/177.c"
void glScaled(GLdouble x , GLdouble y , GLdouble z ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5861
  tmp = gl_get_thread_context();
#line 5861
  CC = (GLcontext *)tmp;
#line 5862
  if (! CC) {
#line 5862
    tmp___1 = getenv("MESA_DEBUG");
#line 5862
    if (tmp___1) {
#line 5862
      tmp___0 = __getreent();
#line 5862
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5862
    return;
  }
#line 5863
  (*(CC->API.Scalef))(CC, (float )x, (float )y, (float )z);
#line 5864
  return;
}
}
#line 5865 "D:/a/test/177.c"
void glScalef(float x , float y , float z ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5867
  tmp = gl_get_thread_context();
#line 5867
  CC = (GLcontext *)tmp;
#line 5868
  if (! CC) {
#line 5868
    tmp___1 = getenv("MESA_DEBUG");
#line 5868
    if (tmp___1) {
#line 5868
      tmp___0 = __getreent();
#line 5868
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5868
    return;
  }
#line 5869
  (*(CC->API.Scalef))(CC, x, y, z);
#line 5870
  return;
}
}
#line 5871 "D:/a/test/177.c"
void glShadeModel(GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5873
  tmp = gl_get_thread_context();
#line 5873
  CC = (GLcontext *)tmp;
#line 5874
  if (! CC) {
#line 5874
    tmp___1 = getenv("MESA_DEBUG");
#line 5874
    if (tmp___1) {
#line 5874
      tmp___0 = __getreent();
#line 5874
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5874
    return;
  }
#line 5875
  (*(CC->API.ShadeModel))(CC, mode);
#line 5876
  return;
}
}
#line 5877 "D:/a/test/177.c"
void glStencilFunc(GLenum func , GLint ref , GLuint mask ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5879
  tmp = gl_get_thread_context();
#line 5879
  CC = (GLcontext *)tmp;
#line 5880
  if (! CC) {
#line 5880
    tmp___1 = getenv("MESA_DEBUG");
#line 5880
    if (tmp___1) {
#line 5880
      tmp___0 = __getreent();
#line 5880
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5880
    return;
  }
#line 5881
  (*(CC->API.StencilFunc))(CC, func, ref, mask);
#line 5882
  return;
}
}
#line 5883 "D:/a/test/177.c"
void glStencilMask(GLuint mask ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5885
  tmp = gl_get_thread_context();
#line 5885
  CC = (GLcontext *)tmp;
#line 5886
  if (! CC) {
#line 5886
    tmp___1 = getenv("MESA_DEBUG");
#line 5886
    if (tmp___1) {
#line 5886
      tmp___0 = __getreent();
#line 5886
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5886
    return;
  }
#line 5887
  (*(CC->API.StencilMask))(CC, mask);
#line 5888
  return;
}
}
#line 5889 "D:/a/test/177.c"
void glStencilOp(GLenum fail , GLenum zfail , GLenum zpass ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 5891
  tmp = gl_get_thread_context();
#line 5891
  CC = (GLcontext *)tmp;
#line 5892
  if (! CC) {
#line 5892
    tmp___1 = getenv("MESA_DEBUG");
#line 5892
    if (tmp___1) {
#line 5892
      tmp___0 = __getreent();
#line 5892
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 5892
    return;
  }
#line 5893
  (*(CC->API.StencilOp))(CC, fail, zfail, zpass);
#line 5894
  return;
}
}
#line 5895 "D:/a/test/177.c"
void glTexCoord1d(GLdouble s ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5897
  tmp = gl_get_thread_context();
#line 5897
  CC = (GLcontext *)tmp;
#line 5898
  (*(CC->API.TexCoord4f))(CC, (float )s, (float )0.0, (float )0.0, (float )1.0);
#line 5899
  return;
}
}
#line 5900 "D:/a/test/177.c"
void glTexCoord1f(float s ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5902
  tmp = gl_get_thread_context();
#line 5902
  CC = (GLcontext *)tmp;
#line 5903
  (*(CC->API.TexCoord4f))(CC, s, (float )0.0, (float )0.0, (float )1.0);
#line 5904
  return;
}
}
#line 5905 "D:/a/test/177.c"
void glTexCoord1i(GLint s ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5907
  tmp = gl_get_thread_context();
#line 5907
  CC = (GLcontext *)tmp;
#line 5908
  (*(CC->API.TexCoord4f))(CC, (float )s, (float )0.0, (float )0.0, (float )1.0);
#line 5909
  return;
}
}
#line 5910 "D:/a/test/177.c"
void glTexCoord1s(GLshort s ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5912
  tmp = gl_get_thread_context();
#line 5912
  CC = (GLcontext *)tmp;
#line 5913
  (*(CC->API.TexCoord4f))(CC, (float )s, (float )0.0, (float )0.0, (float )1.0);
#line 5914
  return;
}
}
#line 5915 "D:/a/test/177.c"
void glTexCoord2d(GLdouble s , GLdouble t ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5917
  tmp = gl_get_thread_context();
#line 5917
  CC = (GLcontext *)tmp;
#line 5918
  (*(CC->API.TexCoord2f))(CC, (float )s, (float )t);
#line 5919
  return;
}
}
#line 5920 "D:/a/test/177.c"
void glTexCoord2f(float s , float t ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5922
  tmp = gl_get_thread_context();
#line 5922
  CC = (GLcontext *)tmp;
#line 5923
  (*(CC->API.TexCoord2f))(CC, s, t);
#line 5924
  return;
}
}
#line 5925 "D:/a/test/177.c"
void glTexCoord2i(GLint s , GLint t ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5927
  tmp = gl_get_thread_context();
#line 5927
  CC = (GLcontext *)tmp;
#line 5928
  (*(CC->API.TexCoord2f))(CC, (float )s, (float )t);
#line 5929
  return;
}
}
#line 5930 "D:/a/test/177.c"
void glTexCoord2s(GLshort s , GLshort t ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5932
  tmp = gl_get_thread_context();
#line 5932
  CC = (GLcontext *)tmp;
#line 5933
  (*(CC->API.TexCoord2f))(CC, (float )s, (float )t);
#line 5934
  return;
}
}
#line 5935 "D:/a/test/177.c"
void glTexCoord3d(GLdouble s , GLdouble t , GLdouble r ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5937
  tmp = gl_get_thread_context();
#line 5937
  CC = (GLcontext *)tmp;
#line 5938
  (*(CC->API.TexCoord4f))(CC, (float )s, (float )t, (float )r, (float )1.0);
#line 5939
  return;
}
}
#line 5940 "D:/a/test/177.c"
void glTexCoord3f(float s , float t , float r ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5942
  tmp = gl_get_thread_context();
#line 5942
  CC = (GLcontext *)tmp;
#line 5943
  (*(CC->API.TexCoord4f))(CC, s, t, r, (float )1.0);
#line 5944
  return;
}
}
#line 5945 "D:/a/test/177.c"
void glTexCoord3i(GLint s , GLint t , GLint r ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5947
  tmp = gl_get_thread_context();
#line 5947
  CC = (GLcontext *)tmp;
#line 5948
  (*(CC->API.TexCoord4f))(CC, (float )s, (float )t, (float )r, (float )1.0);
#line 5950
  return;
}
}
#line 5951 "D:/a/test/177.c"
void glTexCoord3s(GLshort s , GLshort t , GLshort r ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5953
  tmp = gl_get_thread_context();
#line 5953
  CC = (GLcontext *)tmp;
#line 5954
  (*(CC->API.TexCoord4f))(CC, (float )s, (float )t, (float )r, (float )1.0);
#line 5956
  return;
}
}
#line 5957 "D:/a/test/177.c"
void glTexCoord4d(GLdouble s , GLdouble t , GLdouble r , GLdouble q ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5959
  tmp = gl_get_thread_context();
#line 5959
  CC = (GLcontext *)tmp;
#line 5960
  (*(CC->API.TexCoord4f))(CC, (float )s, (float )t, (float )r, (float )q);
#line 5962
  return;
}
}
#line 5963 "D:/a/test/177.c"
void glTexCoord4f(float s , float t , float r , float q ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5965
  tmp = gl_get_thread_context();
#line 5965
  CC = (GLcontext *)tmp;
#line 5966
  (*(CC->API.TexCoord4f))(CC, s, t, r, q);
#line 5967
  return;
}
}
#line 5968 "D:/a/test/177.c"
void glTexCoord4i(GLint s , GLint t , GLint r , GLint q ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5970
  tmp = gl_get_thread_context();
#line 5970
  CC = (GLcontext *)tmp;
#line 5971
  (*(CC->API.TexCoord4f))(CC, (float )s, (float )t, (float )r, (float )q);
#line 5973
  return;
}
}
#line 5974 "D:/a/test/177.c"
void glTexCoord4s(GLshort s , GLshort t , GLshort r , GLshort q ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5976
  tmp = gl_get_thread_context();
#line 5976
  CC = (GLcontext *)tmp;
#line 5977
  (*(CC->API.TexCoord4f))(CC, (float )s, (float )t, (float )r, (float )q);
#line 5979
  return;
}
}
#line 5980 "D:/a/test/177.c"
void glTexCoord1dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5982
  tmp = gl_get_thread_context();
#line 5982
  CC = (GLcontext *)tmp;
#line 5983
  (*(CC->API.TexCoord4f))(CC, (float )*v, (float )0.0, (float )0.0, (float )1.0);
#line 5984
  return;
}
}
#line 5985 "D:/a/test/177.c"
void glTexCoord1fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5987
  tmp = gl_get_thread_context();
#line 5987
  CC = (GLcontext *)tmp;
#line 5988
  (*(CC->API.TexCoord4f))(CC, (float )*v, (float )0.0, (float )0.0, (float )1.0);
#line 5989
  return;
}
}
#line 5990 "D:/a/test/177.c"
void glTexCoord1iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5992
  tmp = gl_get_thread_context();
#line 5992
  CC = (GLcontext *)tmp;
#line 5993
  (*(CC->API.TexCoord4f))(CC, (float )*v, (float )0.0, (float )0.0, (float )1.0);
#line 5994
  return;
}
}
#line 5995 "D:/a/test/177.c"
void glTexCoord1sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 5997
  tmp = gl_get_thread_context();
#line 5997
  CC = (GLcontext *)tmp;
#line 5998
  (*(CC->API.TexCoord4f))(CC, (float )*v, (float )0.0, (float )0.0, (float )1.0);
#line 5999
  return;
}
}
#line 6000 "D:/a/test/177.c"
void glTexCoord2dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6002
  tmp = gl_get_thread_context();
#line 6002
  CC = (GLcontext *)tmp;
#line 6003
  (*(CC->API.TexCoord2f))(CC, (float )*(v + 0), (float )*(v + 1));
#line 6004
  return;
}
}
#line 6005 "D:/a/test/177.c"
void glTexCoord2fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6007
  tmp = gl_get_thread_context();
#line 6007
  CC = (GLcontext *)tmp;
#line 6008
  (*(CC->API.TexCoord2f))(CC, (float )*(v + 0), (float )*(v + 1));
#line 6009
  return;
}
}
#line 6010 "D:/a/test/177.c"
void glTexCoord2iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6012
  tmp = gl_get_thread_context();
#line 6012
  CC = (GLcontext *)tmp;
#line 6013
  (*(CC->API.TexCoord2f))(CC, (float )*(v + 0), (float )*(v + 1));
#line 6014
  return;
}
}
#line 6015 "D:/a/test/177.c"
void glTexCoord2sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6017
  tmp = gl_get_thread_context();
#line 6017
  CC = (GLcontext *)tmp;
#line 6018
  (*(CC->API.TexCoord2f))(CC, (float )*(v + 0), (float )*(v + 1));
#line 6019
  return;
}
}
#line 6020 "D:/a/test/177.c"
void glTexCoord3dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6022
  tmp = gl_get_thread_context();
#line 6022
  CC = (GLcontext *)tmp;
#line 6023
  (*(CC->API.TexCoord4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                          (float )1.0);
#line 6025
  return;
}
}
#line 6026 "D:/a/test/177.c"
void glTexCoord3fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6028
  tmp = gl_get_thread_context();
#line 6028
  CC = (GLcontext *)tmp;
#line 6029
  (*(CC->API.TexCoord4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                          (float )1.0);
#line 6030
  return;
}
}
#line 6031 "D:/a/test/177.c"
void glTexCoord3iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6033
  tmp = gl_get_thread_context();
#line 6033
  CC = (GLcontext *)tmp;
#line 6034
  (*(CC->API.TexCoord4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                          (float )1.0);
#line 6036
  return;
}
}
#line 6037 "D:/a/test/177.c"
void glTexCoord3sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6039
  tmp = gl_get_thread_context();
#line 6039
  CC = (GLcontext *)tmp;
#line 6040
  (*(CC->API.TexCoord4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                          (float )1.0);
#line 6042
  return;
}
}
#line 6043 "D:/a/test/177.c"
void glTexCoord4dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6045
  tmp = gl_get_thread_context();
#line 6045
  CC = (GLcontext *)tmp;
#line 6046
  (*(CC->API.TexCoord4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                          (float )*(v + 3));
#line 6048
  return;
}
}
#line 6049 "D:/a/test/177.c"
void glTexCoord4fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6051
  tmp = gl_get_thread_context();
#line 6051
  CC = (GLcontext *)tmp;
#line 6052
  (*(CC->API.TexCoord4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                          (float )*(v + 3));
#line 6053
  return;
}
}
#line 6054 "D:/a/test/177.c"
void glTexCoord4iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6056
  tmp = gl_get_thread_context();
#line 6056
  CC = (GLcontext *)tmp;
#line 6057
  (*(CC->API.TexCoord4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                          (float )*(v + 3));
#line 6059
  return;
}
}
#line 6060 "D:/a/test/177.c"
void glTexCoord4sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6062
  tmp = gl_get_thread_context();
#line 6062
  CC = (GLcontext *)tmp;
#line 6063
  (*(CC->API.TexCoord4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                          (float )*(v + 3));
#line 6065
  return;
}
}
#line 6066 "D:/a/test/177.c"
void glTexCoordPointer(GLint size , GLenum type , GLsizei stride , GLvoid const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6069
  tmp = gl_get_thread_context();
#line 6069
  CC = (GLcontext *)tmp;
#line 6070
  if (! CC) {
#line 6070
    tmp___1 = getenv("MESA_DEBUG");
#line 6070
    if (tmp___1) {
#line 6070
      tmp___0 = __getreent();
#line 6070
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6070
    return;
  }
#line 6071
  (*(CC->API.TexCoordPointer))(CC, size, type, stride, ptr);
#line 6072
  return;
}
}
#line 6073 "D:/a/test/177.c"
void glTexGend(GLenum coord , GLenum pname , GLdouble param ) 
{ float p ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6075
  p = (float )param;
#line 6076
  tmp = gl_get_thread_context();
#line 6076
  CC = (GLcontext *)tmp;
#line 6077
  if (! CC) {
#line 6077
    tmp___1 = getenv("MESA_DEBUG");
#line 6077
    if (tmp___1) {
#line 6077
      tmp___0 = __getreent();
#line 6077
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6077
    return;
  }
#line 6078
  (*(CC->API.TexGenfv))(CC, coord, pname, (float const   *)(& p));
#line 6079
  return;
}
}
#line 6080 "D:/a/test/177.c"
void glTexGenf(GLenum coord , GLenum pname , float param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6082
  tmp = gl_get_thread_context();
#line 6082
  CC = (GLcontext *)tmp;
#line 6083
  if (! CC) {
#line 6083
    tmp___1 = getenv("MESA_DEBUG");
#line 6083
    if (tmp___1) {
#line 6083
      tmp___0 = __getreent();
#line 6083
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6083
    return;
  }
#line 6084
  (*(CC->API.TexGenfv))(CC, coord, pname, (float const   *)(& param));
#line 6085
  return;
}
}
#line 6086 "D:/a/test/177.c"
void glTexGeni(GLenum coord , GLenum pname , GLint param ) 
{ float p ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6088
  p = (float )param;
#line 6089
  tmp = gl_get_thread_context();
#line 6089
  CC = (GLcontext *)tmp;
#line 6090
  if (! CC) {
#line 6090
    tmp___1 = getenv("MESA_DEBUG");
#line 6090
    if (tmp___1) {
#line 6090
      tmp___0 = __getreent();
#line 6090
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6090
    return;
  }
#line 6091
  (*(CC->API.TexGenfv))(CC, coord, pname, (float const   *)(& p));
#line 6092
  return;
}
}
#line 6093 "D:/a/test/177.c"
void glTexGendv(GLenum coord , GLenum pname , GLdouble const   *params ) 
{ float p[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6096
  tmp = gl_get_thread_context();
#line 6096
  CC = (GLcontext *)tmp;
#line 6097
  if (! CC) {
#line 6097
    tmp___1 = getenv("MESA_DEBUG");
#line 6097
    if (tmp___1) {
#line 6097
      tmp___0 = __getreent();
#line 6097
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6097
    return;
  }
#line 6098
  p[0] = (float )*(params + 0);
#line 6099
  p[1] = (float )*(params + 1);
#line 6100
  p[2] = (float )*(params + 2);
#line 6101
  p[3] = (float )*(params + 3);
#line 6102
  (*(CC->API.TexGenfv))(CC, coord, pname, (float const   *)(p));
#line 6103
  return;
}
}
#line 6104 "D:/a/test/177.c"
void glTexGeniv(GLenum coord , GLenum pname , GLint const   *params ) 
{ float p[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6107
  tmp = gl_get_thread_context();
#line 6107
  CC = (GLcontext *)tmp;
#line 6108
  if (! CC) {
#line 6108
    tmp___1 = getenv("MESA_DEBUG");
#line 6108
    if (tmp___1) {
#line 6108
      tmp___0 = __getreent();
#line 6108
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6108
    return;
  }
#line 6109
  p[0] = (float )*(params + 0);
#line 6110
  p[1] = (float )*(params + 1);
#line 6111
  p[2] = (float )*(params + 2);
#line 6112
  p[3] = (float )*(params + 3);
#line 6113
  (*(CC->API.TexGenfv))(CC, coord, pname, (float const   *)(p));
#line 6114
  return;
}
}
#line 6115 "D:/a/test/177.c"
void glTexGenfv(GLenum coord , GLenum pname , float const   *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6117
  tmp = gl_get_thread_context();
#line 6117
  CC = (GLcontext *)tmp;
#line 6118
  if (! CC) {
#line 6118
    tmp___1 = getenv("MESA_DEBUG");
#line 6118
    if (tmp___1) {
#line 6118
      tmp___0 = __getreent();
#line 6118
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6118
    return;
  }
#line 6119
  (*(CC->API.TexGenfv))(CC, coord, pname, params);
#line 6120
  return;
}
}
#line 6121 "D:/a/test/177.c"
void glTexEnvf(GLenum target , GLenum pname , float param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6123
  tmp = gl_get_thread_context();
#line 6123
  CC = (GLcontext *)tmp;
#line 6124
  if (! CC) {
#line 6124
    tmp___1 = getenv("MESA_DEBUG");
#line 6124
    if (tmp___1) {
#line 6124
      tmp___0 = __getreent();
#line 6124
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6124
    return;
  }
#line 6125
  (*(CC->API.TexEnvfv))(CC, target, pname, (float const   *)(& param));
#line 6126
  return;
}
}
#line 6127 "D:/a/test/177.c"
void glTexEnvi(GLenum target , GLenum pname , GLint param ) 
{ float p[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6130
  p[0] = (float )param;
#line 6131
  p[3] = (float )0.0;
#line 6131
  p[2] = p[3];
#line 6131
  p[1] = p[2];
#line 6132
  tmp = gl_get_thread_context();
#line 6132
  CC = (GLcontext *)tmp;
#line 6133
  if (! CC) {
#line 6133
    tmp___1 = getenv("MESA_DEBUG");
#line 6133
    if (tmp___1) {
#line 6133
      tmp___0 = __getreent();
#line 6133
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6133
    return;
  }
#line 6134
  (*(CC->API.TexEnvfv))(CC, target, pname, (float const   *)(p));
#line 6135
  return;
}
}
#line 6136 "D:/a/test/177.c"
void glTexEnvfv(GLenum target , GLenum pname , float const   *param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6138
  tmp = gl_get_thread_context();
#line 6138
  CC = (GLcontext *)tmp;
#line 6139
  if (! CC) {
#line 6139
    tmp___1 = getenv("MESA_DEBUG");
#line 6139
    if (tmp___1) {
#line 6139
      tmp___0 = __getreent();
#line 6139
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6139
    return;
  }
#line 6140
  (*(CC->API.TexEnvfv))(CC, target, pname, param);
#line 6141
  return;
}
}
#line 6142 "D:/a/test/177.c"
void glTexEnviv(GLenum target , GLenum pname , GLint const   *param ) 
{ float p[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6145
  p[0] = (2.0F * (float )*(param + 0) + 1.0F) * (1.0F / 4294967294.0F);
#line 6146
  p[1] = (2.0F * (float )*(param + 1) + 1.0F) * (1.0F / 4294967294.0F);
#line 6147
  p[2] = (2.0F * (float )*(param + 2) + 1.0F) * (1.0F / 4294967294.0F);
#line 6148
  p[3] = (2.0F * (float )*(param + 3) + 1.0F) * (1.0F / 4294967294.0F);
#line 6149
  tmp = gl_get_thread_context();
#line 6149
  CC = (GLcontext *)tmp;
#line 6150
  if (! CC) {
#line 6150
    tmp___1 = getenv("MESA_DEBUG");
#line 6150
    if (tmp___1) {
#line 6150
      tmp___0 = __getreent();
#line 6150
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6150
    return;
  }
#line 6151
  (*(CC->API.TexEnvfv))(CC, target, pname, (float const   *)(p));
#line 6152
  return;
}
}
#line 6153 "D:/a/test/177.c"
void glTexImage1D(GLenum target , GLint level , GLint internalformat , GLsizei width ,
                  GLint border , GLenum format , GLenum type , GLvoid const   *pixels ) 
{ struct gl_image *teximage ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 6158
  tmp = gl_get_thread_context();
#line 6158
  CC = (GLcontext *)tmp;
#line 6159
  if (! CC) {
#line 6159
    tmp___1 = getenv("MESA_DEBUG");
#line 6159
    if (tmp___1) {
#line 6159
      tmp___0 = __getreent();
#line 6159
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6159
    return;
  }
#line 6160
  tmp___2 = (int )gl_unpack_image(CC, width, 1, format, type, pixels);
#line 6160
  teximage = (struct gl_image *)tmp___2;
#line 6161
  (*(CC->API.TexImage1D))(CC, target, level, internalformat, width, border, format,
                          type, teximage);
#line 6163
  return;
}
}
#line 6164 "D:/a/test/177.c"
void glTexImage2D(GLenum target , GLint level , GLint internalformat , GLsizei width ,
                  GLsizei height , GLint border , GLenum format , GLenum type , GLvoid const   *pixels ) 
{ struct gl_image *teximage ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 6176
  tmp = gl_get_thread_context();
#line 6176
  CC = (GLcontext *)tmp;
#line 6177
  if (! CC) {
#line 6177
    tmp___1 = getenv("MESA_DEBUG");
#line 6177
    if (tmp___1) {
#line 6177
      tmp___0 = __getreent();
#line 6177
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6177
    return;
  }
#line 6206
  tmp___2 = (int )gl_unpack_image(CC, width, height, format, type, pixels);
#line 6206
  teximage = (struct gl_image *)tmp___2;
#line 6207
  (*(CC->API.TexImage2D))(CC, target, level, internalformat, width, height, border,
                          format, type, teximage);
#line 6213
  return;
}
}
#line 6214 "D:/a/test/177.c"
void glTexParameterf(GLenum target , GLenum pname , float param ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6216
  tmp = gl_get_thread_context();
#line 6216
  CC = (GLcontext *)tmp;
#line 6217
  if (! CC) {
#line 6217
    tmp___1 = getenv("MESA_DEBUG");
#line 6217
    if (tmp___1) {
#line 6217
      tmp___0 = __getreent();
#line 6217
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6217
    return;
  }
#line 6218
  (*(CC->API.TexParameterfv))(CC, target, pname, (float const   *)(& param));
#line 6219
  return;
}
}
#line 6220 "D:/a/test/177.c"
void glTexParameteri(GLenum target , GLenum pname , GLint param ) 
{ float fparam[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6223
  fparam[0] = (float )param;
#line 6224
  fparam[3] = (float )0.0;
#line 6224
  fparam[2] = fparam[3];
#line 6224
  fparam[1] = fparam[2];
#line 6225
  tmp = gl_get_thread_context();
#line 6225
  CC = (GLcontext *)tmp;
#line 6226
  if (! CC) {
#line 6226
    tmp___1 = getenv("MESA_DEBUG");
#line 6226
    if (tmp___1) {
#line 6226
      tmp___0 = __getreent();
#line 6226
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6226
    return;
  }
#line 6227
  (*(CC->API.TexParameterfv))(CC, target, pname, (float const   *)(fparam));
#line 6228
  return;
}
}
#line 6229 "D:/a/test/177.c"
void glTexParameterfv(GLenum target , GLenum pname , float const   *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6231
  tmp = gl_get_thread_context();
#line 6231
  CC = (GLcontext *)tmp;
#line 6232
  if (! CC) {
#line 6232
    tmp___1 = getenv("MESA_DEBUG");
#line 6232
    if (tmp___1) {
#line 6232
      tmp___0 = __getreent();
#line 6232
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6232
    return;
  }
#line 6233
  (*(CC->API.TexParameterfv))(CC, target, pname, params);
#line 6234
  return;
}
}
#line 6235 "D:/a/test/177.c"
void glTexParameteriv(GLenum target , GLenum pname , GLint const   *params ) 
{ float p[4] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6238
  tmp = gl_get_thread_context();
#line 6238
  CC = (GLcontext *)tmp;
#line 6239
  if (! CC) {
#line 6239
    tmp___1 = getenv("MESA_DEBUG");
#line 6239
    if (tmp___1) {
#line 6239
      tmp___0 = __getreent();
#line 6239
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6239
    return;
  }
#line 6240
  if (pname == 4100) {
#line 6241
    p[0] = (2.0F * (float )*(params + 0) + 1.0F) * (1.0F / 4294967294.0F);
#line 6242
    p[1] = (2.0F * (float )*(params + 1) + 1.0F) * (1.0F / 4294967294.0F);
#line 6243
    p[2] = (2.0F * (float )*(params + 2) + 1.0F) * (1.0F / 4294967294.0F);
#line 6244
    p[3] = (2.0F * (float )*(params + 3) + 1.0F) * (1.0F / 4294967294.0F);
  } else {
#line 6247
    p[0] = (float )*(params + 0);
#line 6248
    p[1] = (float )*(params + 1);
#line 6249
    p[2] = (float )*(params + 2);
#line 6250
    p[3] = (float )*(params + 3);
  }
#line 6252
  (*(CC->API.TexParameterfv))(CC, target, pname, (float const   *)(p));
#line 6253
  return;
}
}
#line 6261
struct gl_image *gl_unpack_texsubimage(GLcontext *ctx , GLint width , GLint height ,
                                       GLint depth , GLenum format , GLenum type ,
                                       GLvoid const   *pixels ) ;
#line 6254 "D:/a/test/177.c"
void glTexSubImage1D(GLenum target , GLint level , GLint xoffset , GLsizei width ,
                     GLenum format , GLenum type , GLvoid const   *pixels ) 
{ struct gl_image *image ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 6259
  tmp = gl_get_thread_context();
#line 6259
  CC = (GLcontext *)tmp;
#line 6260
  if (! CC) {
#line 6260
    tmp___1 = getenv("MESA_DEBUG");
#line 6260
    if (tmp___1) {
#line 6260
      tmp___0 = __getreent();
#line 6260
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6260
    return;
  }
#line 6261
  tmp___2 = (int )gl_unpack_texsubimage(CC, width, 1, 1, format, type, pixels);
#line 6261
  image = (struct gl_image *)tmp___2;
#line 6262
  (*(CC->API.TexSubImage1D))(CC, target, level, xoffset, width, format, type, image);
#line 6264
  return;
}
}
#line 6265 "D:/a/test/177.c"
void glTexSubImage2D(GLenum target , GLint level , GLint xoffset , GLint yoffset ,
                     GLsizei width , GLsizei height , GLenum format , GLenum type ,
                     GLvoid const   *pixels ) 
{ struct gl_image *image ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 6272
  tmp = gl_get_thread_context();
#line 6272
  CC = (GLcontext *)tmp;
#line 6273
  if (! CC) {
#line 6273
    tmp___1 = getenv("MESA_DEBUG");
#line 6273
    if (tmp___1) {
#line 6273
      tmp___0 = __getreent();
#line 6273
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6273
    return;
  }
#line 6274
  tmp___2 = (int )gl_unpack_texsubimage(CC, width, height, 1, format, type, pixels);
#line 6274
  image = (struct gl_image *)tmp___2;
#line 6275
  (*(CC->API.TexSubImage2D))(CC, target, level, xoffset, yoffset, width, height, format,
                             type, image);
#line 6277
  return;
}
}
#line 6278 "D:/a/test/177.c"
void glTranslated(GLdouble x , GLdouble y , GLdouble z ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6280
  tmp = gl_get_thread_context();
#line 6280
  CC = (GLcontext *)tmp;
#line 6281
  if (! CC) {
#line 6281
    tmp___1 = getenv("MESA_DEBUG");
#line 6281
    if (tmp___1) {
#line 6281
      tmp___0 = __getreent();
#line 6281
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6281
    return;
  }
#line 6282
  (*(CC->API.Translatef))(CC, (float )x, (float )y, (float )z);
#line 6283
  return;
}
}
#line 6284 "D:/a/test/177.c"
void glTranslatef(float x , float y , float z ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6286
  tmp = gl_get_thread_context();
#line 6286
  CC = (GLcontext *)tmp;
#line 6287
  if (! CC) {
#line 6287
    tmp___1 = getenv("MESA_DEBUG");
#line 6287
    if (tmp___1) {
#line 6287
      tmp___0 = __getreent();
#line 6287
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6287
    return;
  }
#line 6288
  (*(CC->API.Translatef))(CC, x, y, z);
#line 6289
  return;
}
}
#line 6290 "D:/a/test/177.c"
void glVertex2d(GLdouble x , GLdouble y ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6292
  tmp = gl_get_thread_context();
#line 6292
  CC = (GLcontext *)tmp;
#line 6293
  (*(CC->API.Vertex2f))(CC, (float )x, (float )y);
#line 6294
  return;
}
}
#line 6295 "D:/a/test/177.c"
void glVertex2f(float x , float y ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6297
  tmp = gl_get_thread_context();
#line 6297
  CC = (GLcontext *)tmp;
#line 6298
  (*(CC->API.Vertex2f))(CC, x, y);
#line 6299
  return;
}
}
#line 6300 "D:/a/test/177.c"
void glVertex2i(GLint x , GLint y ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6302
  tmp = gl_get_thread_context();
#line 6302
  CC = (GLcontext *)tmp;
#line 6303
  (*(CC->API.Vertex2f))(CC, (float )x, (float )y);
#line 6304
  return;
}
}
#line 6305 "D:/a/test/177.c"
void glVertex2s(GLshort x , GLshort y ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6307
  tmp = gl_get_thread_context();
#line 6307
  CC = (GLcontext *)tmp;
#line 6308
  (*(CC->API.Vertex2f))(CC, (float )x, (float )y);
#line 6309
  return;
}
}
#line 6310 "D:/a/test/177.c"
void glVertex3d(GLdouble x , GLdouble y , GLdouble z ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6312
  tmp = gl_get_thread_context();
#line 6312
  CC = (GLcontext *)tmp;
#line 6313
  (*(CC->API.Vertex3f))(CC, (float )x, (float )y, (float )z);
#line 6314
  return;
}
}
#line 6315 "D:/a/test/177.c"
void glVertex3f(float x , float y , float z ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6317
  tmp = gl_get_thread_context();
#line 6317
  CC = (GLcontext *)tmp;
#line 6318
  (*(CC->API.Vertex3f))(CC, x, y, z);
#line 6319
  return;
}
}
#line 6320 "D:/a/test/177.c"
void glVertex3i(GLint x , GLint y , GLint z ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6322
  tmp = gl_get_thread_context();
#line 6322
  CC = (GLcontext *)tmp;
#line 6323
  (*(CC->API.Vertex3f))(CC, (float )x, (float )y, (float )z);
#line 6324
  return;
}
}
#line 6325 "D:/a/test/177.c"
void glVertex3s(GLshort x , GLshort y , GLshort z ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6327
  tmp = gl_get_thread_context();
#line 6327
  CC = (GLcontext *)tmp;
#line 6328
  (*(CC->API.Vertex3f))(CC, (float )x, (float )y, (float )z);
#line 6329
  return;
}
}
#line 6330 "D:/a/test/177.c"
void glVertex4d(GLdouble x , GLdouble y , GLdouble z , GLdouble w ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6332
  tmp = gl_get_thread_context();
#line 6332
  CC = (GLcontext *)tmp;
#line 6333
  (*(CC->API.Vertex4f))(CC, (float )x, (float )y, (float )z, (float )w);
#line 6335
  return;
}
}
#line 6336 "D:/a/test/177.c"
void glVertex4f(float x , float y , float z , float w ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6338
  tmp = gl_get_thread_context();
#line 6338
  CC = (GLcontext *)tmp;
#line 6339
  (*(CC->API.Vertex4f))(CC, x, y, z, w);
#line 6340
  return;
}
}
#line 6341 "D:/a/test/177.c"
void glVertex4i(GLint x , GLint y , GLint z , GLint w ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6343
  tmp = gl_get_thread_context();
#line 6343
  CC = (GLcontext *)tmp;
#line 6344
  (*(CC->API.Vertex4f))(CC, (float )x, (float )y, (float )z, (float )w);
#line 6346
  return;
}
}
#line 6347 "D:/a/test/177.c"
void glVertex4s(GLshort x , GLshort y , GLshort z , GLshort w ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6349
  tmp = gl_get_thread_context();
#line 6349
  CC = (GLcontext *)tmp;
#line 6350
  (*(CC->API.Vertex4f))(CC, (float )x, (float )y, (float )z, (float )w);
#line 6352
  return;
}
}
#line 6353 "D:/a/test/177.c"
void glVertex2dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6355
  tmp = gl_get_thread_context();
#line 6355
  CC = (GLcontext *)tmp;
#line 6356
  (*(CC->API.Vertex2f))(CC, (float )*(v + 0), (float )*(v + 1));
#line 6357
  return;
}
}
#line 6358 "D:/a/test/177.c"
void glVertex2fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6360
  tmp = gl_get_thread_context();
#line 6360
  CC = (GLcontext *)tmp;
#line 6361
  (*(CC->API.Vertex2f))(CC, (float )*(v + 0), (float )*(v + 1));
#line 6362
  return;
}
}
#line 6363 "D:/a/test/177.c"
void glVertex2iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6365
  tmp = gl_get_thread_context();
#line 6365
  CC = (GLcontext *)tmp;
#line 6366
  (*(CC->API.Vertex2f))(CC, (float )*(v + 0), (float )*(v + 1));
#line 6367
  return;
}
}
#line 6368 "D:/a/test/177.c"
void glVertex2sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6370
  tmp = gl_get_thread_context();
#line 6370
  CC = (GLcontext *)tmp;
#line 6371
  (*(CC->API.Vertex2f))(CC, (float )*(v + 0), (float )*(v + 1));
#line 6372
  return;
}
}
#line 6373 "D:/a/test/177.c"
void glVertex3dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6375
  tmp = gl_get_thread_context();
#line 6375
  CC = (GLcontext *)tmp;
#line 6376
  (*(CC->API.Vertex3f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2));
#line 6377
  return;
}
}
#line 6378 "D:/a/test/177.c"
void glVertex3fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6380
  tmp = gl_get_thread_context();
#line 6380
  CC = (GLcontext *)tmp;
#line 6381
  (*(CC->API.Vertex3fv))(CC, v);
#line 6382
  return;
}
}
#line 6383 "D:/a/test/177.c"
void glVertex3iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6385
  tmp = gl_get_thread_context();
#line 6385
  CC = (GLcontext *)tmp;
#line 6386
  (*(CC->API.Vertex3f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2));
#line 6387
  return;
}
}
#line 6388 "D:/a/test/177.c"
void glVertex3sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6390
  tmp = gl_get_thread_context();
#line 6390
  CC = (GLcontext *)tmp;
#line 6391
  (*(CC->API.Vertex3f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2));
#line 6392
  return;
}
}
#line 6393 "D:/a/test/177.c"
void glVertex4dv(GLdouble const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6395
  tmp = gl_get_thread_context();
#line 6395
  CC = (GLcontext *)tmp;
#line 6396
  (*(CC->API.Vertex4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                        (float )*(v + 3));
#line 6398
  return;
}
}
#line 6399 "D:/a/test/177.c"
void glVertex4fv(float const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6401
  tmp = gl_get_thread_context();
#line 6401
  CC = (GLcontext *)tmp;
#line 6402
  (*(CC->API.Vertex4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                        (float )*(v + 3));
#line 6403
  return;
}
}
#line 6404 "D:/a/test/177.c"
void glVertex4iv(GLint const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6406
  tmp = gl_get_thread_context();
#line 6406
  CC = (GLcontext *)tmp;
#line 6407
  (*(CC->API.Vertex4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                        (float )*(v + 3));
#line 6409
  return;
}
}
#line 6410 "D:/a/test/177.c"
void glVertex4sv(GLshort const   *v ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6412
  tmp = gl_get_thread_context();
#line 6412
  CC = (GLcontext *)tmp;
#line 6413
  (*(CC->API.Vertex4f))(CC, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2),
                        (float )*(v + 3));
#line 6415
  return;
}
}
#line 6416 "D:/a/test/177.c"
void glVertexPointer(GLint size , GLenum type , GLsizei stride , GLvoid const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6419
  tmp = gl_get_thread_context();
#line 6419
  CC = (GLcontext *)tmp;
#line 6420
  (*(CC->API.VertexPointer))(CC, size, type, stride, ptr);
#line 6421
  return;
}
}
#line 6422 "D:/a/test/177.c"
void glViewport(GLint x , GLint y , GLsizei width , GLsizei height ) 
{ GLcontext *CC ;
  int tmp ;

  {
#line 6424
  tmp = gl_get_thread_context();
#line 6424
  CC = (GLcontext *)tmp;
#line 6425
  (*(CC->API.Viewport))(CC, x, y, width, height);
#line 6426
  return;
}
}
#line 6427 "D:/a/test/177.c"
void glBlendEquationEXT(GLenum mode ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6429
  tmp = gl_get_thread_context();
#line 6429
  CC = (GLcontext *)tmp;
#line 6430
  if (! CC) {
#line 6430
    tmp___1 = getenv("MESA_DEBUG");
#line 6430
    if (tmp___1) {
#line 6430
      tmp___0 = __getreent();
#line 6430
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6430
    return;
  }
#line 6431
  (*(CC->API.BlendEquation))(CC, mode);
#line 6432
  return;
}
}
#line 6433 "D:/a/test/177.c"
void glBlendColorEXT(GLclampf red , GLclampf green , GLclampf blue___0 , GLclampf alpha ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6436
  tmp = gl_get_thread_context();
#line 6436
  CC = (GLcontext *)tmp;
#line 6437
  if (! CC) {
#line 6437
    tmp___1 = getenv("MESA_DEBUG");
#line 6437
    if (tmp___1) {
#line 6437
      tmp___0 = __getreent();
#line 6437
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6437
    return;
  }
#line 6438
  (*(CC->API.BlendColor))(CC, red, green, blue___0, alpha);
#line 6439
  return;
}
}
#line 6440 "D:/a/test/177.c"
void glVertexPointerEXT(GLint size , GLenum type , GLsizei stride , GLsizei count ,
                        GLvoid const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6443
  tmp = gl_get_thread_context();
#line 6443
  CC = (GLcontext *)tmp;
#line 6444
  if (! CC) {
#line 6444
    tmp___1 = getenv("MESA_DEBUG");
#line 6444
    if (tmp___1) {
#line 6444
      tmp___0 = __getreent();
#line 6444
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6444
    return;
  }
#line 6445
  (*(CC->API.VertexPointer))(CC, size, type, stride, ptr);
#line 6446
  return;
}
}
#line 6447 "D:/a/test/177.c"
void glNormalPointerEXT(GLenum type , GLsizei stride , GLsizei count , GLvoid const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6450
  tmp = gl_get_thread_context();
#line 6450
  CC = (GLcontext *)tmp;
#line 6451
  if (! CC) {
#line 6451
    tmp___1 = getenv("MESA_DEBUG");
#line 6451
    if (tmp___1) {
#line 6451
      tmp___0 = __getreent();
#line 6451
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6451
    return;
  }
#line 6452
  (*(CC->API.NormalPointer))(CC, type, stride, ptr);
#line 6453
  return;
}
}
#line 6454 "D:/a/test/177.c"
void glColorPointerEXT(GLint size , GLenum type , GLsizei stride , GLsizei count ,
                       GLvoid const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6457
  tmp = gl_get_thread_context();
#line 6457
  CC = (GLcontext *)tmp;
#line 6458
  if (! CC) {
#line 6458
    tmp___1 = getenv("MESA_DEBUG");
#line 6458
    if (tmp___1) {
#line 6458
      tmp___0 = __getreent();
#line 6458
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6458
    return;
  }
#line 6459
  (*(CC->API.ColorPointer))(CC, size, type, stride, ptr);
#line 6460
  return;
}
}
#line 6461 "D:/a/test/177.c"
void glIndexPointerEXT(GLenum type , GLsizei stride , GLsizei count , GLvoid const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6464
  tmp = gl_get_thread_context();
#line 6464
  CC = (GLcontext *)tmp;
#line 6465
  if (! CC) {
#line 6465
    tmp___1 = getenv("MESA_DEBUG");
#line 6465
    if (tmp___1) {
#line 6465
      tmp___0 = __getreent();
#line 6465
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6465
    return;
  }
#line 6466
  (*(CC->API.IndexPointer))(CC, type, stride, ptr);
#line 6467
  return;
}
}
#line 6468 "D:/a/test/177.c"
void glTexCoordPointerEXT(GLint size , GLenum type , GLsizei stride , GLsizei count ,
                          GLvoid const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6471
  tmp = gl_get_thread_context();
#line 6471
  CC = (GLcontext *)tmp;
#line 6472
  if (! CC) {
#line 6472
    tmp___1 = getenv("MESA_DEBUG");
#line 6472
    if (tmp___1) {
#line 6472
      tmp___0 = __getreent();
#line 6472
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6472
    return;
  }
#line 6473
  (*(CC->API.TexCoordPointer))(CC, size, type, stride, ptr);
#line 6474
  return;
}
}
#line 6475 "D:/a/test/177.c"
void glEdgeFlagPointerEXT(GLsizei stride , GLsizei count , GLboolean const   *ptr ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6478
  tmp = gl_get_thread_context();
#line 6478
  CC = (GLcontext *)tmp;
#line 6479
  if (! CC) {
#line 6479
    tmp___1 = getenv("MESA_DEBUG");
#line 6479
    if (tmp___1) {
#line 6479
      tmp___0 = __getreent();
#line 6479
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6479
    return;
  }
#line 6480
  (*(CC->API.EdgeFlagPointer))(CC, stride, ptr);
#line 6481
  return;
}
}
#line 6482 "D:/a/test/177.c"
void glGetPointervEXT(GLenum pname , GLvoid **params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6484
  tmp = gl_get_thread_context();
#line 6484
  CC = (GLcontext *)tmp;
#line 6485
  if (! CC) {
#line 6485
    tmp___1 = getenv("MESA_DEBUG");
#line 6485
    if (tmp___1) {
#line 6485
      tmp___0 = __getreent();
#line 6485
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6485
    return;
  }
#line 6486
  (*(CC->API.GetPointerv))(CC, pname, params);
#line 6487
  return;
}
}
#line 6488 "D:/a/test/177.c"
void glArrayElementEXT(GLint i ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6490
  tmp = gl_get_thread_context();
#line 6490
  CC = (GLcontext *)tmp;
#line 6491
  if (! CC) {
#line 6491
    tmp___1 = getenv("MESA_DEBUG");
#line 6491
    if (tmp___1) {
#line 6491
      tmp___0 = __getreent();
#line 6491
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6491
    return;
  }
#line 6492
  (*(CC->API.ArrayElement))(CC, i);
#line 6493
  return;
}
}
#line 6494 "D:/a/test/177.c"
void glDrawArraysEXT(GLenum mode , GLint first , GLsizei count ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6496
  tmp = gl_get_thread_context();
#line 6496
  CC = (GLcontext *)tmp;
#line 6497
  if (! CC) {
#line 6497
    tmp___1 = getenv("MESA_DEBUG");
#line 6497
    if (tmp___1) {
#line 6497
      tmp___0 = __getreent();
#line 6497
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6497
    return;
  }
#line 6498
  (*(CC->API.DrawArrays))(CC, mode, first, count);
#line 6499
  return;
}
}
#line 6500 "D:/a/test/177.c"
GLboolean glAreTexturesResidentEXT(GLsizei n , GLuint const   *textures , GLboolean *residences ) 
{ GLboolean tmp ;

  {
#line 6503
  tmp = glAreTexturesResident(n, textures, residences);
#line 6503
  return (tmp);
}
}
#line 6505 "D:/a/test/177.c"
void glBindTextureEXT(GLenum target , GLuint texture ) 
{ 

  {
#line 6507
  glBindTexture(target, texture);
#line 6508
  return;
}
}
#line 6509 "D:/a/test/177.c"
void glDeleteTexturesEXT(GLsizei n , GLuint const   *textures ) 
{ 

  {
#line 6511
  glDeleteTextures(n, textures);
#line 6512
  return;
}
}
#line 6513 "D:/a/test/177.c"
void glGenTexturesEXT(GLsizei n , GLuint *textures ) 
{ 

  {
#line 6515
  glGenTextures(n, textures);
#line 6516
  return;
}
}
#line 6517 "D:/a/test/177.c"
GLboolean glIsTextureEXT(GLuint texture ) 
{ GLboolean tmp ;

  {
#line 6519
  tmp = glIsTexture(texture);
#line 6519
  return (tmp);
}
}
#line 6521 "D:/a/test/177.c"
void glPrioritizeTexturesEXT(GLsizei n , GLuint const   *textures , GLclampf const   *priorities ) 
{ 

  {
#line 6524
  glPrioritizeTextures(n, textures, priorities);
#line 6525
  return;
}
}
#line 6526 "D:/a/test/177.c"
void glCopyTexSubImage3DEXT(GLenum target , GLint level , GLint xoffset , GLint yoffset ,
                            GLint zoffset , GLint x , GLint y , GLsizei width , GLsizei height ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6531
  tmp = gl_get_thread_context();
#line 6531
  CC = (GLcontext *)tmp;
#line 6532
  if (! CC) {
#line 6532
    tmp___1 = getenv("MESA_DEBUG");
#line 6532
    if (tmp___1) {
#line 6532
      tmp___0 = __getreent();
#line 6532
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6532
    return;
  }
#line 6533
  (*(CC->API.CopyTexSubImage3DEXT))(CC, target, level, xoffset, yoffset, zoffset,
                                    x, y, width, height);
#line 6535
  return;
}
}
#line 6544
struct gl_image *gl_unpack_image3D(GLcontext *ctx , GLint width , GLint height , GLint depth ,
                                   GLenum srcFormat , GLenum srcType , GLvoid const   *pixels ) ;
#line 6536 "D:/a/test/177.c"
void glTexImage3DEXT(GLenum target , GLint level , GLenum internalformat , GLsizei width ,
                     GLsizei height , GLsizei depth , GLint border , GLenum format ,
                     GLenum type , GLvoid const   *pixels ) 
{ struct gl_image *teximage ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 6542
  tmp = gl_get_thread_context();
#line 6542
  CC = (GLcontext *)tmp;
#line 6543
  if (! CC) {
#line 6543
    tmp___1 = getenv("MESA_DEBUG");
#line 6543
    if (tmp___1) {
#line 6543
      tmp___0 = __getreent();
#line 6543
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6543
    return;
  }
#line 6544
  tmp___2 = (int )gl_unpack_image3D(CC, width, height, depth, format, type, pixels);
#line 6544
  teximage = (struct gl_image *)tmp___2;
#line 6545
  (*(CC->API.TexImage3DEXT))(CC, target, level, internalformat, width, height, depth,
                             border, format, type, teximage);
#line 6548
  return;
}
}
#line 6549 "D:/a/test/177.c"
void glTexSubImage3DEXT(GLenum target , GLint level , GLint xoffset , GLint yoffset ,
                        GLint zoffset , GLsizei width , GLsizei height , GLsizei depth ,
                        GLenum format , GLenum type , GLvoid const   *pixels ) 
{ struct gl_image *image ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 6555
  tmp = gl_get_thread_context();
#line 6555
  CC = (GLcontext *)tmp;
#line 6556
  if (! CC) {
#line 6556
    tmp___1 = getenv("MESA_DEBUG");
#line 6556
    if (tmp___1) {
#line 6556
      tmp___0 = __getreent();
#line 6556
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6556
    return;
  }
#line 6557
  tmp___2 = (int )gl_unpack_texsubimage(CC, width, height, depth, format, type, pixels);
#line 6557
  image = (struct gl_image *)tmp___2;
#line 6558
  (*(CC->API.TexSubImage3DEXT))(CC, target, level, xoffset, yoffset, zoffset, width,
                                height, depth, format, type, image);
#line 6560
  return;
}
}
#line 6561 "D:/a/test/177.c"
void glPointParameterfEXT(GLenum pname , float param ) 
{ float params[3] ;
  GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6564
  tmp = gl_get_thread_context();
#line 6564
  CC = (GLcontext *)tmp;
#line 6565
  if (! CC) {
#line 6565
    tmp___1 = getenv("MESA_DEBUG");
#line 6565
    if (tmp___1) {
#line 6565
      tmp___0 = __getreent();
#line 6565
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6565
    return;
  }
#line 6566
  params[0] = param;
#line 6567
  params[1] = (float )0.0;
#line 6568
  params[2] = (float )0.0;
#line 6569
  (*(CC->API.PointParameterfvEXT))(CC, pname, (float const   *)(params));
#line 6570
  return;
}
}
#line 6571 "D:/a/test/177.c"
void glPointParameterfvEXT(GLenum pname , float const   *params ) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6573
  tmp = gl_get_thread_context();
#line 6573
  CC = (GLcontext *)tmp;
#line 6574
  if (! CC) {
#line 6574
    tmp___1 = getenv("MESA_DEBUG");
#line 6574
    if (tmp___1) {
#line 6574
      tmp___0 = __getreent();
#line 6574
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6574
    return;
  }
#line 6575
  (*(CC->API.PointParameterfvEXT))(CC, pname, params);
#line 6576
  return;
}
}
#line 6588
void glWindowPos4fMESA(float x , float y , float z , float w ) ;
#line 6586 "D:/a/test/177.c"
void glWindowPos2iMESA(GLint x , GLint y ) 
{ 

  {
#line 6588
  glWindowPos4fMESA((float )x, (float )y, 0.0F, 1.0F);
#line 6589
  return;
}
}
#line 6590 "D:/a/test/177.c"
void glWindowPos2sMESA(GLshort x , GLshort y ) 
{ 

  {
#line 6592
  glWindowPos4fMESA((float )x, (float )y, 0.0F, 1.0F);
#line 6593
  return;
}
}
#line 6594 "D:/a/test/177.c"
void glWindowPos2fMESA(float x , float y ) 
{ 

  {
#line 6596
  glWindowPos4fMESA(x, y, 0.0F, 1.0F);
#line 6597
  return;
}
}
#line 6598 "D:/a/test/177.c"
void glWindowPos2dMESA(GLdouble x , GLdouble y ) 
{ 

  {
#line 6600
  glWindowPos4fMESA((float )x, (float )y, 0.0F, 1.0F);
#line 6601
  return;
}
}
#line 6602 "D:/a/test/177.c"
void glWindowPos2ivMESA(GLint const   *p ) 
{ 

  {
#line 6604
  glWindowPos4fMESA((float )*(p + 0), (float )*(p + 1), 0.0F, 1.0F);
#line 6605
  return;
}
}
#line 6606 "D:/a/test/177.c"
void glWindowPos2svMESA(GLshort const   *p ) 
{ 

  {
#line 6608
  glWindowPos4fMESA((float )*(p + 0), (float )*(p + 1), 0.0F, 1.0F);
#line 6609
  return;
}
}
#line 6610 "D:/a/test/177.c"
void glWindowPos2fvMESA(float const   *p ) 
{ 

  {
#line 6612
  glWindowPos4fMESA(*(p + 0), *(p + 1), 0.0F, 1.0F);
#line 6613
  return;
}
}
#line 6614 "D:/a/test/177.c"
void glWindowPos2dvMESA(GLdouble const   *p ) 
{ 

  {
#line 6616
  glWindowPos4fMESA((float )*(p + 0), (float )*(p + 1), 0.0F, 1.0F);
#line 6617
  return;
}
}
#line 6618 "D:/a/test/177.c"
void glWindowPos3iMESA(GLint x , GLint y , GLint z ) 
{ 

  {
#line 6620
  glWindowPos4fMESA((float )x, (float )y, (float )z, 1.0F);
#line 6621
  return;
}
}
#line 6622 "D:/a/test/177.c"
void glWindowPos3sMESA(GLshort x , GLshort y , GLshort z ) 
{ 

  {
#line 6624
  glWindowPos4fMESA((float )x, (float )y, (float )z, 1.0F);
#line 6625
  return;
}
}
#line 6626 "D:/a/test/177.c"
void glWindowPos3fMESA(float x , float y , float z ) 
{ 

  {
#line 6628
  glWindowPos4fMESA(x, y, z, 1.0F);
#line 6629
  return;
}
}
#line 6630 "D:/a/test/177.c"
void glWindowPos3dMESA(GLdouble x , GLdouble y , GLdouble z ) 
{ 

  {
#line 6632
  glWindowPos4fMESA((float )x, (float )y, (float )z, 1.0F);
#line 6633
  return;
}
}
#line 6634 "D:/a/test/177.c"
void glWindowPos3ivMESA(GLint const   *p ) 
{ 

  {
#line 6636
  glWindowPos4fMESA((float )*(p + 0), (float )*(p + 1), (float )*(p + 2), 1.0F);
#line 6637
  return;
}
}
#line 6638 "D:/a/test/177.c"
void glWindowPos3svMESA(GLshort const   *p ) 
{ 

  {
#line 6640
  glWindowPos4fMESA((float )*(p + 0), (float )*(p + 1), (float )*(p + 2), 1.0F);
#line 6641
  return;
}
}
#line 6642 "D:/a/test/177.c"
void glWindowPos3fvMESA(float const   *p ) 
{ 

  {
#line 6644
  glWindowPos4fMESA(*(p + 0), *(p + 1), *(p + 2), 1.0F);
#line 6645
  return;
}
}
#line 6646 "D:/a/test/177.c"
void glWindowPos3dvMESA(GLdouble const   *p ) 
{ 

  {
#line 6648
  glWindowPos4fMESA((float )*(p + 0), (float )*(p + 1), (float )*(p + 2), 1.0F);
#line 6649
  return;
}
}
#line 6650 "D:/a/test/177.c"
void glWindowPos4iMESA(GLint x , GLint y , GLint z , GLint w ) 
{ 

  {
#line 6652
  glWindowPos4fMESA((float )x, (float )y, (float )z, (float )w);
#line 6653
  return;
}
}
#line 6654 "D:/a/test/177.c"
void glWindowPos4sMESA(GLshort x , GLshort y , GLshort z , GLshort w ) 
{ 

  {
#line 6656
  glWindowPos4fMESA((float )x, (float )y, (float )z, (float )w);
#line 6657
  return;
}
}
#line 6658 "D:/a/test/177.c"
void glWindowPos4dMESA(GLdouble x , GLdouble y , GLdouble z , GLdouble w ) 
{ 

  {
#line 6660
  glWindowPos4fMESA((float )x, (float )y, (float )z, (float )w);
#line 6661
  return;
}
}
#line 6662 "D:/a/test/177.c"
void glWindowPos4ivMESA(GLint const   *p ) 
{ 

  {
#line 6664
  glWindowPos4fMESA((float )*(p + 0), (float )*(p + 1), (float )*(p + 2), (float )*(p + 3));
#line 6666
  return;
}
}
#line 6667 "D:/a/test/177.c"
void glWindowPos4svMESA(GLshort const   *p ) 
{ 

  {
#line 6669
  glWindowPos4fMESA((float )*(p + 0), (float )*(p + 1), (float )*(p + 2), (float )*(p + 3));
#line 6671
  return;
}
}
#line 6672 "D:/a/test/177.c"
void glWindowPos4fvMESA(float const   *p ) 
{ 

  {
#line 6674
  glWindowPos4fMESA(*(p + 0), *(p + 1), *(p + 2), *(p + 3));
#line 6675
  return;
}
}
#line 6676 "D:/a/test/177.c"
void glWindowPos4dvMESA(GLdouble const   *p ) 
{ 

  {
#line 6678
  glWindowPos4fMESA((float )*(p + 0), (float )*(p + 1), (float )*(p + 2), (float )*(p + 3));
#line 6680
  return;
}
}
#line 6681 "D:/a/test/177.c"
void glResizeBuffersMESA(void) 
{ GLcontext *CC ;
  int tmp ;
  struct _reent *tmp___0 ;
  char *tmp___1 ;

  {
#line 6683
  tmp = gl_get_thread_context();
#line 6683
  CC = (GLcontext *)tmp;
#line 6684
  if (! CC) {
#line 6684
    tmp___1 = getenv("MESA_DEBUG");
#line 6684
    if (tmp___1) {
#line 6684
      tmp___0 = __getreent();
#line 6684
      fprintf(tmp___0->_stderr, "Mesa user error: no rendering context.\n");
    }
#line 6684
    return;
  }
#line 6685
  (*(CC->API.ResizeBuffersMESA))(CC);
#line 6686
  return;
}
}
#line 6693 "D:/a/test/177.c"
static struct gl_attrib_node *new_attrib_node(GLbitfield kind ) 
{ struct gl_attrib_node *an ;
  void *tmp ;

  {
#line 6696
  tmp = malloc(sizeof(struct gl_attrib_node ));//55
#line 6696
  an = (struct gl_attrib_node *)tmp;
#line 6697
  if (an) {
#line 6698
    an->kind = kind;
  }
#line 6700
  return (an);
}
}
#line 6702 "D:/a/test/177.c"
void gl_PushAttrib(GLcontext *ctx , GLbitfield mask ) 
{ struct gl_attrib_node *newnode ;
  struct gl_attrib_node *head ;
  struct gl_accum_attrib *attr ;
  void *tmp ;
  struct gl_colorbuffer_attrib *attr___0 ;
  void *tmp___0 ;
  struct gl_current_attrib *attr___1 ;
  void *tmp___1 ;
  struct gl_depthbuffer_attrib *attr___2 ;
  void *tmp___2 ;
  struct gl_enable_attrib *attr___3 ;
  GLuint i ;
  void *tmp___3 ;
  struct gl_eval_attrib *attr___4 ;
  void *tmp___4 ;
  struct gl_fog_attrib *attr___5 ;
  void *tmp___5 ;
  struct gl_hint_attrib *attr___6 ;
  void *tmp___6 ;
  struct gl_light_attrib *attr___7 ;
  void *tmp___7 ;
  struct gl_line_attrib *attr___8 ;
  void *tmp___8 ;
  struct gl_list_attrib *attr___9 ;
  void *tmp___9 ;
  struct gl_pixel_attrib *attr___10 ;
  void *tmp___10 ;
  struct gl_point_attrib *attr___11 ;
  void *tmp___11 ;
  struct gl_polygon_attrib *attr___12 ;
  void *tmp___12 ;
  GLuint *stipple ;
  void *tmp___13 ;
  struct gl_scissor_attrib *attr___13 ;
  void *tmp___14 ;
  struct gl_stencil_attrib *attr___14 ;
  void *tmp___15 ;
  struct gl_texture_attrib *attr___15 ;
  void *tmp___16 ;
  struct gl_transform_attrib *attr___16 ;
  void *tmp___17 ;
  struct gl_viewport_attrib *attr___17 ;
  void *tmp___18 ;

  {
#line 6706
  if (ctx->Primitive != 6656) {
#line 6707
    gl_error(ctx, 1282, "glPushAttrib");
#line 6708
    return;
  }
#line 6710
  if (ctx->AttribStackDepth >= 16U) {
#line 6711
    gl_error(ctx, 1283, "glPushAttrib");
#line 6712
    return;
  }
#line 6714
  head = (struct gl_attrib_node *)((void *)0);
#line 6715
  if (mask & 512U) {
#line 6717
    tmp = malloc(sizeof(struct gl_accum_attrib ));//56
#line 6717
    attr = (struct gl_accum_attrib *)tmp;
#line 6718
    memcpy((void *)attr, (void const   *)((void *)(& ctx->Accum)), sizeof(struct gl_accum_attrib ));
#line 6719
    newnode = new_attrib_node(512U);
#line 6720
    newnode->data = (void *)attr;
#line 6721
    newnode->next = head;
#line 6722
    head = newnode;
  }
#line 6724
  if (mask & 16384U) {
#line 6726
    tmp___0 = malloc(sizeof(struct gl_colorbuffer_attrib ));//57
#line 6726
    attr___0 = (struct gl_colorbuffer_attrib *)tmp___0;
#line 6727
    memcpy((void *)attr___0, (void const   *)((void *)(& ctx->Color)), sizeof(struct gl_colorbuffer_attrib ));
#line 6728
    newnode = new_attrib_node(16384U);
#line 6729
    newnode->data = (void *)attr___0;
#line 6730
    newnode->next = head;
#line 6731
    head = newnode;
  }
#line 6733
  if (mask & 1U) {
#line 6735
    tmp___1 = malloc(sizeof(struct gl_current_attrib ));//58
#line 6735
    attr___1 = (struct gl_current_attrib *)tmp___1;
#line 6736
    memcpy((void *)attr___1, (void const   *)((void *)(& ctx->Current)), sizeof(struct gl_current_attrib ));
#line 6737
    newnode = new_attrib_node(1U);
#line 6738
    newnode->data = (void *)attr___1;
#line 6739
    newnode->next = head;
#line 6740
    head = newnode;
  }
#line 6742
  if (mask & 256U) {
#line 6744
    tmp___2 = malloc(sizeof(struct gl_depthbuffer_attrib ));//1
#line 6744
    attr___2 = (struct gl_depthbuffer_attrib *)tmp___2;
#line 6745
    memcpy((void *)attr___2, (void const   *)((void *)(& ctx->Depth)), sizeof(struct gl_depthbuffer_attrib ));
#line 6746
    newnode = new_attrib_node(256U);
#line 6747
    newnode->data = (void *)attr___2;
#line 6748
    newnode->next = head;
#line 6749
    head = newnode;
  }
#line 6751
  if (mask & 8192U) {
#line 6754
    tmp___3 = malloc(sizeof(struct gl_enable_attrib ));//2
#line 6754
    attr___3 = (struct gl_enable_attrib *)tmp___3;
#line 6755
    attr___3->AlphaTest = ctx->Color.AlphaEnabled;
#line 6756
    attr___3->AutoNormal = ctx->Eval.AutoNormal;
#line 6757
    attr___3->Blend = ctx->Color.BlendEnabled;
#line 6758
    i = 0U;
#line 6758
    while (i < 6U) {
#line 6759
      attr___3->ClipPlane[i] = ctx->Transform.ClipEnabled[i];
#line 6758
      i ++;
    }
#line 6761
    attr___3->ColorMaterial = ctx->Light.ColorMaterialEnabled;
#line 6762
    attr___3->CullFace = ctx->Polygon.CullFlag;
#line 6763
    attr___3->DepthTest = ctx->Depth.Test;
#line 6764
    attr___3->Dither = ctx->Color.DitherFlag;
#line 6765
    attr___3->Fog = ctx->Fog.Enabled;
#line 6766
    i = 0U;
#line 6766
    while (i < 8U) {
#line 6767
      attr___3->Light[i] = ctx->Light.Light[i].Enabled;
#line 6766
      i ++;
    }
#line 6769
    attr___3->Lighting = ctx->Light.Enabled;
#line 6770
    attr___3->LineSmooth = ctx->Line.SmoothFlag;
#line 6771
    attr___3->LineStipple = ctx->Line.StippleFlag;
#line 6772
    attr___3->IndexLogicOp = ctx->Color.IndexLogicOpEnabled;
#line 6773
    attr___3->ColorLogicOp = ctx->Color.ColorLogicOpEnabled;
#line 6774
    attr___3->Map1Color4 = ctx->Eval.Map1Color4;
#line 6775
    attr___3->Map1Index = ctx->Eval.Map1Index;
#line 6776
    attr___3->Map1Normal = ctx->Eval.Map1Normal;
#line 6777
    attr___3->Map1TextureCoord1 = ctx->Eval.Map1TextureCoord1;
#line 6778
    attr___3->Map1TextureCoord2 = ctx->Eval.Map1TextureCoord2;
#line 6779
    attr___3->Map1TextureCoord3 = ctx->Eval.Map1TextureCoord3;
#line 6780
    attr___3->Map1TextureCoord4 = ctx->Eval.Map1TextureCoord4;
#line 6781
    attr___3->Map1Vertex3 = ctx->Eval.Map1Vertex3;
#line 6782
    attr___3->Map1Vertex4 = ctx->Eval.Map1Vertex4;
#line 6783
    attr___3->Map2Color4 = ctx->Eval.Map2Color4;
#line 6784
    attr___3->Map2Index = ctx->Eval.Map2Index;
#line 6785
    attr___3->Map2Normal = ctx->Eval.Map2Normal;
#line 6786
    attr___3->Map2TextureCoord1 = ctx->Eval.Map2TextureCoord1;
#line 6787
    attr___3->Map2TextureCoord2 = ctx->Eval.Map2TextureCoord2;
#line 6788
    attr___3->Map2TextureCoord3 = ctx->Eval.Map2TextureCoord3;
#line 6789
    attr___3->Map2TextureCoord4 = ctx->Eval.Map2TextureCoord4;
#line 6790
    attr___3->Map2Vertex3 = ctx->Eval.Map2Vertex3;
#line 6791
    attr___3->Map2Vertex4 = ctx->Eval.Map2Vertex4;
#line 6792
    attr___3->Normalize = ctx->Transform.Normalize;
#line 6793
    attr___3->PointSmooth = ctx->Point.SmoothFlag;
#line 6794
    attr___3->PolygonOffsetPoint = ctx->Polygon.OffsetPoint;
#line 6795
    attr___3->PolygonOffsetLine = ctx->Polygon.OffsetLine;
#line 6796
    attr___3->PolygonOffsetFill = ctx->Polygon.OffsetFill;
#line 6797
    attr___3->PolygonSmooth = ctx->Polygon.SmoothFlag;
#line 6798
    attr___3->PolygonStipple = ctx->Polygon.StippleFlag;
#line 6799
    attr___3->Scissor = ctx->Scissor.Enabled;
#line 6800
    attr___3->Stencil = ctx->Stencil.Enabled;
#line 6801
    attr___3->Texture = ctx->Texture.Enabled;
#line 6802
    attr___3->TexGen = ctx->Texture.TexGenEnabled;
#line 6803
    newnode = new_attrib_node(8192U);
#line 6804
    newnode->data = (void *)attr___3;
#line 6805
    newnode->next = head;
#line 6806
    head = newnode;
  }
#line 6808
  if (mask & 65536U) {
#line 6810
    tmp___4 = malloc(sizeof(struct gl_eval_attrib ));//3
#line 6810
    attr___4 = (struct gl_eval_attrib *)tmp___4;
#line 6811
    memcpy((void *)attr___4, (void const   *)((void *)(& ctx->Eval)), sizeof(struct gl_eval_attrib ));
#line 6812
    newnode = new_attrib_node(65536U);
#line 6813
    newnode->data = (void *)attr___4;
#line 6814
    newnode->next = head;
#line 6815
    head = newnode;
  }
#line 6817
  if (mask & 128U) {
#line 6819
    tmp___5 = malloc(sizeof(struct gl_fog_attrib ));//4
#line 6819
    attr___5 = (struct gl_fog_attrib *)tmp___5;
#line 6820
    memcpy((void *)attr___5, (void const   *)((void *)(& ctx->Fog)), sizeof(struct gl_fog_attrib ));
#line 6821
    newnode = new_attrib_node(128U);
#line 6822
    newnode->data = (void *)attr___5;
#line 6823
    newnode->next = head;
#line 6824
    head = newnode;
  }
#line 6826
  if (mask & 32768U) {
#line 6828
    tmp___6 = malloc(sizeof(struct gl_hint_attrib ));//5
#line 6828
    attr___6 = (struct gl_hint_attrib *)tmp___6;
#line 6829
    memcpy((void *)attr___6, (void const   *)((void *)(& ctx->Hint)), sizeof(struct gl_hint_attrib ));
#line 6830
    newnode = new_attrib_node(32768U);
#line 6831
    newnode->data = (void *)attr___6;
#line 6832
    newnode->next = head;
#line 6833
    head = newnode;
  }
#line 6835
  if (mask & 64U) {
#line 6837
    tmp___7 = malloc(sizeof(struct gl_light_attrib ));//6
#line 6837
    attr___7 = (struct gl_light_attrib *)tmp___7;
#line 6838
    memcpy((void *)attr___7, (void const   *)((void *)(& ctx->Light)), sizeof(struct gl_light_attrib ));
#line 6839
    newnode = new_attrib_node(64U);
#line 6840
    newnode->data = (void *)attr___7;
#line 6841
    newnode->next = head;
#line 6842
    head = newnode;
  }
#line 6844
  if (mask & 4U) {
#line 6846
    tmp___8 = malloc(sizeof(struct gl_line_attrib ));//7
#line 6846
    attr___8 = (struct gl_line_attrib *)tmp___8;
#line 6847
    memcpy((void *)attr___8, (void const   *)((void *)(& ctx->Line)), sizeof(struct gl_line_attrib ));
#line 6848
    newnode = new_attrib_node(4U);
#line 6849
    newnode->data = (void *)attr___8;
#line 6850
    newnode->next = head;
#line 6851
    head = newnode;
  }
#line 6853
  if (mask & 131072U) {
#line 6855
    tmp___9 = malloc(sizeof(struct gl_list_attrib ));//8
#line 6855
    attr___9 = (struct gl_list_attrib *)tmp___9;
#line 6856
    memcpy((void *)attr___9, (void const   *)((void *)(& ctx->List)), sizeof(struct gl_list_attrib ));
#line 6857
    newnode = new_attrib_node(131072U);
#line 6858
    newnode->data = (void *)attr___9;
#line 6859
    newnode->next = head;
#line 6860
    head = newnode;
  }
#line 6862
  if (mask & 32U) {
#line 6864
    tmp___10 = malloc(sizeof(struct gl_pixel_attrib ));//10
#line 6864
    attr___10 = (struct gl_pixel_attrib *)tmp___10;
#line 6865
    memcpy((void *)attr___10, (void const   *)((void *)(& ctx->Pixel)), sizeof(struct gl_pixel_attrib ));
#line 6866
    newnode = new_attrib_node(32U);
#line 6867
    newnode->data = (void *)attr___10;
#line 6868
    newnode->next = head;
#line 6869
    head = newnode;
  }
#line 6871
  if (mask & 2U) {
#line 6873
    tmp___11 = malloc(sizeof(struct gl_point_attrib ));//11
#line 6873
    attr___11 = (struct gl_point_attrib *)tmp___11;
#line 6874
    memcpy((void *)attr___11, (void const   *)((void *)(& ctx->Point)), sizeof(struct gl_point_attrib ));
#line 6875
    newnode = new_attrib_node(2U);
#line 6876
    newnode->data = (void *)attr___11;
#line 6877
    newnode->next = head;
#line 6878
    head = newnode;
  }
#line 6880
  if (mask & 8U) {
#line 6882
    tmp___12 = malloc(sizeof(struct gl_polygon_attrib ));//12
#line 6882
    attr___12 = (struct gl_polygon_attrib *)tmp___12;
#line 6883
    memcpy((void *)attr___12, (void const   *)((void *)(& ctx->Polygon)), sizeof(struct gl_polygon_attrib ));
#line 6884
    newnode = new_attrib_node(8U);
#line 6885
    newnode->data = (void *)attr___12;
#line 6886
    newnode->next = head;
#line 6887
    head = newnode;
  }
#line 6889
  if (mask & 16U) {
#line 6891
    tmp___13 = malloc(32U * sizeof(GLuint ));//13
#line 6891
    stipple = (GLuint *)tmp___13;
#line 6892
    memcpy((void *)stipple, (void const   *)((void *)(ctx->PolygonStipple)), 32U * sizeof(GLuint ));
#line 6893
    newnode = new_attrib_node(16U);
#line 6894
    newnode->data = (void *)stipple;
#line 6895
    newnode->next = head;
#line 6896
    head = newnode;
  }
#line 6898
  if (mask & 524288U) {
#line 6900
    tmp___14 = malloc(sizeof(struct gl_scissor_attrib ));//14
#line 6900
    attr___13 = (struct gl_scissor_attrib *)tmp___14;
#line 6901
    memcpy((void *)attr___13, (void const   *)((void *)(& ctx->Scissor)), sizeof(struct gl_scissor_attrib ));
#line 6902
    newnode = new_attrib_node(524288U);
#line 6903
    newnode->data = (void *)attr___13;
#line 6904
    newnode->next = head;
#line 6905
    head = newnode;
  }
#line 6907
  if (mask & 1024U) {
#line 6909
    tmp___15 = malloc(sizeof(struct gl_stencil_attrib ));//15
#line 6909
    attr___14 = (struct gl_stencil_attrib *)tmp___15;
#line 6910
    memcpy((void *)attr___14, (void const   *)((void *)(& ctx->Stencil)), sizeof(struct gl_stencil_attrib ));
#line 6911
    newnode = new_attrib_node(1024U);
#line 6912
    newnode->data = (void *)attr___14;
#line 6913
    newnode->next = head;
#line 6914
    head = newnode;
  }
#line 6916
  if (mask & 262144U) {
#line 6918
    tmp___16 = malloc(sizeof(struct gl_texture_attrib ));//16
#line 6918
    attr___15 = (struct gl_texture_attrib *)tmp___16;
#line 6919
    memcpy((void *)attr___15, (void const   *)((void *)(& ctx->Texture)), sizeof(struct gl_texture_attrib ));
#line 6920
    newnode = new_attrib_node(262144U);
#line 6921
    newnode->data = (void *)attr___15;
#line 6922
    newnode->next = head;
#line 6923
    head = newnode;
  }
#line 6925
  if (mask & 4096U) {
#line 6927
    tmp___17 = malloc(sizeof(struct gl_transform_attrib ));//17
#line 6927
    attr___16 = (struct gl_transform_attrib *)tmp___17;
#line 6928
    memcpy((void *)attr___16, (void const   *)((void *)(& ctx->Transform)), sizeof(struct gl_transform_attrib ));
#line 6929
    newnode = new_attrib_node(4096U);
#line 6930
    newnode->data = (void *)attr___16;
#line 6931
    newnode->next = head;
#line 6932
    head = newnode;
  }
#line 6934
  if (mask & 2048U) {
#line 6936
    tmp___18 = malloc(sizeof(struct gl_viewport_attrib ));//18
#line 6936
    attr___17 = (struct gl_viewport_attrib *)tmp___18;
#line 6937
    memcpy((void *)attr___17, (void const   *)((void *)(& ctx->Viewport)), sizeof(struct gl_viewport_attrib ));
#line 6938
    newnode = new_attrib_node(2048U);
#line 6939
    newnode->data = (void *)attr___17;
#line 6940
    newnode->next = head;
#line 6941
    head = newnode;
  }
#line 6943
  ctx->AttribStack[ctx->AttribStackDepth] = head;
#line 6944
  (ctx->AttribStackDepth) ++;
#line 6945
  return;
}
}
#line 6971
void gl_DrawBuffer(GLcontext *ctx , GLenum mode ) ;
#line 6946 "D:/a/test/177.c"
void gl_PopAttrib(GLcontext *ctx ) 
{ struct gl_attrib_node *attr ;
  struct gl_attrib_node *next ;
  struct gl_enable_attrib *enable ;
  GLuint i ;
  GLuint oldDrawBuffer ;
  int tmp ;

  {
#line 6951
  if (ctx->Primitive != 6656) {
#line 6952
    gl_error(ctx, 1282, "glPopAttrib");
#line 6953
    return;
  }
#line 6955
  if (ctx->AttribStackDepth == 0U) {
#line 6956
    gl_error(ctx, 1284, "glPopAttrib");
#line 6957
    return;
  }
#line 6959
  (ctx->AttribStackDepth) --;
#line 6960
  attr = ctx->AttribStack[ctx->AttribStackDepth];
#line 6961
  while (attr) {
#line 6962
    switch ((int )attr->kind) {
    case 512: 
#line 6964
    memcpy((void *)(& ctx->Accum), (void const   *)attr->data, sizeof(struct gl_accum_attrib ));
#line 6965
    break;
    case 16384: 
#line 6967
    oldDrawBuffer = (unsigned int )ctx->Color.DrawBuffer;
#line 6968
    memcpy((void *)(& ctx->Color), (void const   *)attr->data, sizeof(struct gl_colorbuffer_attrib ));
#line 6970
    if ((GLuint )ctx->Color.DrawBuffer != oldDrawBuffer) {
#line 6971
      gl_DrawBuffer(ctx, ctx->Color.DrawBuffer);
    }
#line 6973
    break;
    case 1: 
#line 6975
    memcpy((void *)(& ctx->Current), (void const   *)attr->data, sizeof(struct gl_current_attrib ));
#line 6977
    break;
    case 256: 
#line 6979
    memcpy((void *)(& ctx->Depth), (void const   *)attr->data, sizeof(struct gl_depthbuffer_attrib ));
#line 6981
    break;
    case 8192: 
#line 6983
    enable = (struct gl_enable_attrib *)attr->data;
#line 6984
    ctx->Color.AlphaEnabled = enable->AlphaTest;
#line 6985
    ctx->Transform.Normalize = enable->AutoNormal;
#line 6986
    ctx->Color.BlendEnabled = enable->Blend;
#line 6987
    i = 0U;
#line 6987
    while (i < 6U) {
#line 6988
      ctx->Transform.ClipEnabled[i] = enable->ClipPlane[i];
#line 6987
      i ++;
    }
#line 6990
    ctx->Light.ColorMaterialEnabled = enable->ColorMaterial;
#line 6991
    ctx->Polygon.CullFlag = enable->CullFace;
#line 6992
    ctx->Depth.Test = enable->DepthTest;
#line 6993
    ctx->Color.DitherFlag = enable->Dither;
#line 6994
    ctx->Fog.Enabled = enable->Fog;
#line 6995
    ctx->Light.Enabled = enable->Lighting;
#line 6996
    ctx->Line.SmoothFlag = enable->LineSmooth;
#line 6997
    ctx->Line.StippleFlag = enable->LineStipple;
#line 6998
    ctx->Color.IndexLogicOpEnabled = enable->IndexLogicOp;
#line 6999
    ctx->Color.ColorLogicOpEnabled = enable->ColorLogicOp;
#line 7000
    ctx->Eval.Map1Color4 = enable->Map1Color4;
#line 7001
    ctx->Eval.Map1Index = enable->Map1Index;
#line 7002
    ctx->Eval.Map1Normal = enable->Map1Normal;
#line 7003
    ctx->Eval.Map1TextureCoord1 = enable->Map1TextureCoord1;
#line 7004
    ctx->Eval.Map1TextureCoord2 = enable->Map1TextureCoord2;
#line 7005
    ctx->Eval.Map1TextureCoord3 = enable->Map1TextureCoord3;
#line 7006
    ctx->Eval.Map1TextureCoord4 = enable->Map1TextureCoord4;
#line 7007
    ctx->Eval.Map1Vertex3 = enable->Map1Vertex3;
#line 7008
    ctx->Eval.Map1Vertex4 = enable->Map1Vertex4;
#line 7009
    ctx->Eval.Map2Color4 = enable->Map2Color4;
#line 7010
    ctx->Eval.Map2Index = enable->Map2Index;
#line 7011
    ctx->Eval.Map2Normal = enable->Map2Normal;
#line 7012
    ctx->Eval.Map2TextureCoord1 = enable->Map2TextureCoord1;
#line 7013
    ctx->Eval.Map2TextureCoord2 = enable->Map2TextureCoord2;
#line 7014
    ctx->Eval.Map2TextureCoord3 = enable->Map2TextureCoord3;
#line 7015
    ctx->Eval.Map2TextureCoord4 = enable->Map2TextureCoord4;
#line 7016
    ctx->Eval.Map2Vertex3 = enable->Map2Vertex3;
#line 7017
    ctx->Eval.Map2Vertex4 = enable->Map2Vertex4;
#line 7018
    ctx->Transform.Normalize = enable->Normalize;
#line 7019
    ctx->Point.SmoothFlag = enable->PointSmooth;
#line 7020
    ctx->Polygon.OffsetPoint = enable->PolygonOffsetPoint;
#line 7021
    ctx->Polygon.OffsetLine = enable->PolygonOffsetLine;
#line 7022
    ctx->Polygon.OffsetFill = enable->PolygonOffsetFill;
#line 7023
    if (ctx->Polygon.OffsetPoint) {
#line 7023
      tmp = 1;
    } else {
#line 7023
      if (ctx->Polygon.OffsetLine) {
#line 7023
        tmp = 1;
      } else {
#line 7023
        if (ctx->Polygon.OffsetFill) {
#line 7023
          tmp = 1;
        } else {
#line 7023
          tmp = 0;
        }
      }
    }
#line 7023
    ctx->Polygon.OffsetAny = (unsigned char )tmp;
#line 7026
    ctx->Polygon.SmoothFlag = enable->PolygonSmooth;
#line 7027
    ctx->Polygon.StippleFlag = enable->PolygonStipple;
#line 7028
    ctx->Scissor.Enabled = enable->Scissor;
#line 7029
    ctx->Stencil.Enabled = enable->Stencil;
#line 7030
    ctx->Texture.Enabled = enable->Texture;
#line 7031
    ctx->Texture.TexGenEnabled = enable->TexGen;
#line 7032
    break;
    case 65536: 
#line 7034
    memcpy((void *)(& ctx->Eval), (void const   *)attr->data, sizeof(struct gl_eval_attrib ));
#line 7035
    break;
    case 128: 
#line 7037
    memcpy((void *)(& ctx->Fog), (void const   *)attr->data, sizeof(struct gl_fog_attrib ));
#line 7038
    break;
    case 32768: 
#line 7040
    memcpy((void *)(& ctx->Hint), (void const   *)attr->data, sizeof(struct gl_hint_attrib ));
#line 7041
    break;
    case 64: 
#line 7043
    memcpy((void *)(& ctx->Light), (void const   *)attr->data, sizeof(struct gl_light_attrib ));
#line 7044
    break;
    case 4: 
#line 7046
    memcpy((void *)(& ctx->Line), (void const   *)attr->data, sizeof(struct gl_line_attrib ));
#line 7047
    break;
    case 131072: 
#line 7049
    memcpy((void *)(& ctx->List), (void const   *)attr->data, sizeof(struct gl_list_attrib ));
#line 7050
    break;
    case 32: 
#line 7052
    memcpy((void *)(& ctx->Pixel), (void const   *)attr->data, sizeof(struct gl_pixel_attrib ));
#line 7053
    break;
    case 2: 
#line 7055
    memcpy((void *)(& ctx->Point), (void const   *)attr->data, sizeof(struct gl_point_attrib ));
#line 7056
    break;
    case 8: 
#line 7058
    memcpy((void *)(& ctx->Polygon), (void const   *)attr->data, sizeof(struct gl_polygon_attrib ));
#line 7060
    break;
    case 16: 
#line 7062
    memcpy((void *)(ctx->PolygonStipple), (void const   *)attr->data, 32U * sizeof(GLuint ));
#line 7063
    break;
    case 524288: 
#line 7065
    memcpy((void *)(& ctx->Scissor), (void const   *)attr->data, sizeof(struct gl_scissor_attrib ));
#line 7067
    break;
    case 1024: 
#line 7069
    memcpy((void *)(& ctx->Stencil), (void const   *)attr->data, sizeof(struct gl_stencil_attrib ));
#line 7071
    break;
    case 4096: 
#line 7073
    memcpy((void *)(& ctx->Transform), (void const   *)attr->data, sizeof(struct gl_transform_attrib ));
#line 7075
    break;
    case 262144: 
#line 7077
    memcpy((void *)(& ctx->Texture), (void const   *)attr->data, sizeof(struct gl_texture_attrib ));
#line 7079
    break;
    case 2048: 
#line 7081
    memcpy((void *)(& ctx->Viewport), (void const   *)attr->data, sizeof(struct gl_viewport_attrib ));
#line 7083
    break;
    default: 
#line 7085
    gl_problem(ctx, "Bad attrib flag in PopAttrib");
#line 7086
    break;
    }
#line 7088
    next = attr->next;
#line 7089
    free(attr->data);
#line 7090
    free((void *)attr);
#line 7091
    attr = next;
  }
#line 7093
  ctx->NewState = 15U;
#line 7094
  return;
}
}
#line 7097 "D:/a/test/177.c"
void gl_PushClientAttrib(GLcontext *ctx , GLbitfield mask ) 
{ struct gl_attrib_node *newnode ;
  struct gl_attrib_node *head ;
  struct gl_pixelstore_attrib *attr ;
  void *tmp ;
  void *tmp___0 ;
  struct gl_array_attrib *attr___0 ;
  void *tmp___1 ;

  {
#line 7101
  if (ctx->Primitive != 6656) {
#line 7102
    gl_error(ctx, 1282, "glPushClientAttrib");
#line 7103
    return;
  }
#line 7105
  if (ctx->ClientAttribStackDepth >= 16U) {
#line 7106
    gl_error(ctx, 1283, "glPushClientAttrib");
#line 7107
    return;
  }
#line 7109
  head = (struct gl_attrib_node *)((void *)0);
#line 7110
  if (mask & 1U) {
#line 7112
    tmp = malloc(sizeof(struct gl_pixelstore_attrib ));//19
#line 7112
    attr = (struct gl_pixelstore_attrib *)tmp;
#line 7113
    memcpy((void *)attr, (void const   *)((void *)(& ctx->Pack)), sizeof(struct gl_pixelstore_attrib ));
#line 7114
    newnode = new_attrib_node((unsigned int )(1 << 20));
#line 7115
    newnode->data = (void *)attr;
#line 7116
    newnode->next = head;
#line 7117
    head = newnode;
#line 7118
    tmp___0 = malloc(sizeof(struct gl_pixelstore_attrib ));//20
#line 7118
    attr = (struct gl_pixelstore_attrib *)tmp___0;
#line 7119
    memcpy((void *)attr, (void const   *)((void *)(& ctx->Unpack)), sizeof(struct gl_pixelstore_attrib ));
#line 7120
    newnode = new_attrib_node((unsigned int )(1 << 21));
#line 7121
    newnode->data = (void *)attr;
#line 7122
    newnode->next = head;
#line 7123
    head = newnode;
  }
#line 7125
  if (mask & 2U) {
#line 7127
    tmp___1 = malloc(sizeof(struct gl_array_attrib ));//21
#line 7127
    attr___0 = (struct gl_array_attrib *)tmp___1;
#line 7128
    memcpy((void *)attr___0, (void const   *)((void *)(& ctx->Array)), sizeof(struct gl_array_attrib ));
#line 7129
    newnode = new_attrib_node(2U);
#line 7130
    newnode->data = (void *)attr___0;
#line 7131
    newnode->next = head;
#line 7132
    head = newnode;
  }
#line 7134
  ctx->ClientAttribStack[ctx->ClientAttribStackDepth] = head;
#line 7135
  (ctx->ClientAttribStackDepth) ++;
#line 7136
  return;
}
}
#line 7137 "D:/a/test/177.c"
void gl_PopClientAttrib(GLcontext *ctx ) 
{ struct gl_attrib_node *attr ;
  struct gl_attrib_node *next ;

  {
#line 7140
  if (ctx->Primitive != 6656) {
#line 7141
    gl_error(ctx, 1282, "glPopClientAttrib");
#line 7142
    return;
  }
#line 7144
  if (ctx->ClientAttribStackDepth == 0U) {
#line 7145
    gl_error(ctx, 1284, "glPopClientAttrib");
#line 7146
    return;
  }
#line 7148
  (ctx->ClientAttribStackDepth) --;
#line 7149
  attr = ctx->ClientAttribStack[ctx->ClientAttribStackDepth];
#line 7150
  while (attr) {
#line 7151
    switch ((int )attr->kind) {
    case 1 << 20: 
#line 7153
    memcpy((void *)(& ctx->Pack), (void const   *)attr->data, sizeof(struct gl_pixelstore_attrib ));
#line 7155
    break;
    case 1 << 21: 
#line 7157
    memcpy((void *)(& ctx->Unpack), (void const   *)attr->data, sizeof(struct gl_pixelstore_attrib ));
#line 7159
    break;
    case 2: 
#line 7161
    memcpy((void *)(& ctx->Array), (void const   *)attr->data, sizeof(struct gl_array_attrib ));
#line 7163
    break;
    default: 
#line 7165
    gl_problem(ctx, "Bad attrib flag in PopClientAttrib");
#line 7166
    break;
    }
#line 7168
    next = attr->next;
#line 7169
    free(attr->data);
#line 7170
    free((void *)attr);
#line 7171
    attr = next;
  }
#line 7173
  ctx->NewState = 15U;
#line 7174
  return;
}
}
#line 7180 "D:/a/test/177.c"
struct gl_image *gl_unpack_bitmap(GLcontext *ctx , GLsizei width , GLsizei height ,
                                  GLubyte const   *bitmap ) 
{ int tmp ;

  {
#line 7184
  tmp = (int )gl_unpack_image(ctx, width, height, 6400, 6656, bitmap);
#line 7184
  return ((struct gl_image *)tmp);
}
}
#line 7197
extern int ( /* missing proto */  assert)() ;
#line 7201
void gl_update_state(GLcontext *ctx ) ;
#line 7202
extern int ( /* missing proto */  PB_INIT)(struct pixel_buffer *pb,int x) ;
#line 7210
extern int ( /* missing proto */  PB_SET_COLOR)(GLcontext *c,struct pixel_buffer *pb,GLubyte s,GLubyte d,GLubyte v ,GLubyte x) ;
#line 7213
extern int ( /* missing proto */  PB_SET_INDEX)(GLcontext *c,struct pixel_buffer *pb,GLint  c) ;
#line 7224
extern int ( /* missing proto */  PB_WRITE_PIXEL)(struct pixel_buffer *pb,GLint  c,GLint  a,GLint b) ;
#line 7232
extern int ( /* missing proto */  PB_CHECK_FLUSH)(GLcontext *c,struct pixel_buffer *pb) ;
#line 7235
void gl_flush_pb(GLcontext *ctx ) ;
#line 7187 "D:/a/test/177.c"
void gl_render_bitmap(GLcontext *ctx , GLsizei width , GLsizei height , float xorig ,
                      float yorig , float xmove , float ymove , struct gl_image  const  *bitmap ) 
{ struct pixel_buffer *PB ;
  GLint bx ;
  GLint by ;
  GLint px ;
  GLint py ;
  GLint pz ;
  GLubyte *ptr ;
  GLint r ;
  GLint g ;
  GLint b ;
  GLint a ;
  GLubyte bitmask ;

  {
#line 7193
  PB = ctx->PB;
#line 7197
  //assert(bitmap);
#line 7198
  //assert(bitmap->Type == 6656);
#line 7199
  //assert(bitmap->Format == 6400);
#line 7200
  if (ctx->NewState) {
#line 7201
    gl_update_state(ctx);
#line 7202
    PB_INIT(PB, 6656);
  }
#line 7204
  if ((ctx->Visual)->RGBAflag) {
#line 7206
    r = (int )(ctx->Current.RasterColor[0] * (ctx->Visual)->RedScale);
#line 7207
    g = (int )(ctx->Current.RasterColor[1] * (ctx->Visual)->GreenScale);
#line 7208
    b = (int )(ctx->Current.RasterColor[2] * (ctx->Visual)->BlueScale);
#line 7209
    a = (int )(ctx->Current.RasterColor[3] * (ctx->Visual)->AlphaScale);
#line 7210
    PB_SET_COLOR(ctx, PB, r, g, b, a);
  } else {
#line 7213
    PB_SET_INDEX(ctx, PB, ctx->Current.RasterIndex);
  }
#line 7215
  px = (int )((ctx->Current.RasterPos[0] - xorig) + 0.0F);
#line 7216
  py = (int )((ctx->Current.RasterPos[1] - yorig) + 0.0F);
#line 7217
  pz = (int )(ctx->Current.RasterPos[2] * 65535.0F);
#line 7218
  ptr = (GLubyte *)bitmap->Data;
#line 7219
  by = 0;
#line 7219
  while (by < height) {
#line 7221
    bitmask = (unsigned char)128;
#line 7222
    bx = 0;
#line 7222
    while (bx < width) {
#line 7223
      if ((int )*ptr & (int )bitmask) {
#line 7224
        PB_WRITE_PIXEL(PB, px + bx, py + by, pz);
      }
#line 7226
      bitmask = (unsigned char )((int )bitmask >> 1);
#line 7227
      if ((int )bitmask == 0) {
#line 7228
        ptr ++;
#line 7229
        bitmask = (unsigned char)128;
      }
#line 7222
      bx ++;
    }
#line 7232
    PB_CHECK_FLUSH(ctx, PB);
#line 7233
    if ((int )bitmask != 128) {
#line 7233
      ptr ++;
    }
#line 7219
    by ++;
  }
#line 7235
  gl_flush_pb(ctx);
#line 7236
  return;
}
}
#line 7276
extern int ( /* missing proto */  FEEDBACK_TOKEN)(GLcontext *c,float) ;
#line 7277
void gl_feedback_vertex(GLcontext *ctx , float x , float y , float z , float w , float const   *color ,
                        float index___0 , float const   *texcoord ) ;
#line 7237 "D:/a/test/177.c"
void gl_Bitmap(GLcontext *ctx , GLsizei width , GLsizei height , float xorig , float yorig ,
               float xmove , float ymove , struct gl_image  const  *bitmap ) 
{ GLboolean completed ;
  float color[4] ;
  float texcoord[4] ;
  float invq ;

  {
#line 7243
  if (width < 0) {
#line 7244
    gl_error(ctx, 1281, "glBitmap");
#line 7245
    return;
  } else {
#line 7243
    if (height < 0) {
#line 7244
      gl_error(ctx, 1281, "glBitmap");
#line 7245
      return;
    }
  }
#line 7247
  if (ctx->Primitive != 6656) {
#line 7248
    gl_error(ctx, 1282, "glBitmap");
#line 7249
    return;
  }
#line 7251
  if ((int )ctx->Current.RasterPosValid == 0) {
#line 7252
    return;
  }
#line 7254
  if (ctx->RenderMode == 7168) {
#line 7255
    completed = (GLboolean )0;
#line 7256
    if (ctx->Driver.Bitmap) {
#line 7257
      completed = (*(ctx->Driver.Bitmap))(ctx, width, height, xorig, yorig, xmove,
                                          ymove, bitmap);
    }
#line 7260
    if (! completed) {
#line 7261
      gl_render_bitmap(ctx, width, height, xorig, yorig, xmove, ymove, bitmap);
    }
  } else {
#line 7265
    if (ctx->RenderMode == 7169) {
#line 7267
      color[0] = (float )ctx->Current.ByteColor[0] * (ctx->Visual)->InvRedScale;
#line 7268
      color[1] = (float )ctx->Current.ByteColor[1] * (ctx->Visual)->InvGreenScale;
#line 7269
      color[2] = (float )ctx->Current.ByteColor[2] * (ctx->Visual)->InvBlueScale;
#line 7270
      color[3] = (float )ctx->Current.ByteColor[3] * (ctx->Visual)->InvAlphaScale;
#line 7271
      invq = 1.0F / ctx->Current.TexCoord[3];
#line 7272
      texcoord[0] = ctx->Current.TexCoord[0] * invq;
#line 7273
      texcoord[1] = ctx->Current.TexCoord[1] * invq;
#line 7274
      texcoord[2] = ctx->Current.TexCoord[2] * invq;
#line 7275
      texcoord[3] = ctx->Current.TexCoord[3];
#line 7276
      FEEDBACK_TOKEN(ctx, (float )1796);
#line 7277
      gl_feedback_vertex(ctx, ctx->Current.RasterPos[0] - xorig, ctx->Current.RasterPos[1] - yorig,
                         ctx->Current.RasterPos[2], ctx->Current.RasterPos[3], color,
                         ctx->Current.Index, texcoord);
    } else {
#line 7283
      if (ctx->RenderMode == 7170) {

      }
    }
  }
#line 7285
  ctx->Current.RasterPos[0] += xmove;
#line 7286
  ctx->Current.RasterPos[1] += ymove;
#line 7287
  return;
}
}
#line 7293 "D:/a/test/177.c"
void gl_BlendFunc(GLcontext *ctx , GLenum sfactor , GLenum dfactor ) 
{ 

  {
#line 7295
  if (ctx->Primitive != 6656) {
#line 7296
    gl_error(ctx, 1282, "glBlendFunc");
#line 7297
    return;
  }
#line 7299
  switch (sfactor) {
  case 0: 
  case 1: 
  case 774: 
  case 775: 
  case 770: 
  case 771: 
  case 772: 
  case 773: 
  case 776: 
  case 32769: 
  case 32770: 
  case 32771: 
  case 32772: 
#line 7313
  ctx->Color.BlendSrc = sfactor;
#line 7314
  break;
  default: 
#line 7316
  gl_error(ctx, 1280, "glBlendFunc(sfactor)");
#line 7317
  return;
  }
#line 7319
  switch (dfactor) {
  case 0: 
  case 1: 
  case 768: 
  case 769: 
  case 770: 
  case 771: 
  case 772: 
  case 773: 
  case 32769: 
  case 32770: 
  case 32771: 
  case 32772: 
#line 7332
  ctx->Color.BlendDst = dfactor;
#line 7333
  break;
  default: 
#line 7335
  gl_error(ctx, 1280, "glBlendFunc(dfactor)");
  }
#line 7337
  ctx->NewState |= 2U;
#line 7338
  return;
}
}
#line 7339 "D:/a/test/177.c"
void gl_BlendEquation(GLcontext *ctx , GLenum mode ) 
{ 

  {
#line 7341
  if (ctx->Primitive != 6656) {
#line 7342
    gl_error(ctx, 1282, "glBlendEquation");
#line 7343
    return;
  }
#line 7345
  switch (mode) {
  case 32775: 
  case 32776: 
  case 3057: 
  case 32774: 
  case 32778: 
  case 32779: 
#line 7352
  ctx->Color.BlendEquation = mode;
#line 7353
  break;
  default: 
#line 7355
  gl_error(ctx, 1280, "glBlendEquation");
#line 7356
  return;
  }
#line 7358
  if (mode == 3057) {
#line 7358
    if (ctx->Color.BlendEnabled) {
#line 7359
      ctx->Color.ColorLogicOpEnabled = (unsigned char)1;
    } else {
#line 7362
      ctx->Color.ColorLogicOpEnabled = (unsigned char)0;
    }
  } else {
#line 7362
    ctx->Color.ColorLogicOpEnabled = (unsigned char)0;
  }
#line 7364
  ctx->NewState |= 2U;
#line 7365
  return;
}
}
#line 7366 "D:/a/test/177.c"
void gl_BlendColor(GLcontext *ctx , GLclampf red , GLclampf green , GLclampf blue___0 ,
                   GLclampf alpha ) 
{ double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 7369
  if ((double )red < 0.0) {
#line 7369
    ctx->Color.BlendColor[0] = (float )0.0;
  } else {
#line 7369
    if ((double )red > 1.0) {
#line 7369
      tmp = 1.0;
    } else {
#line 7369
      tmp = (double )red;
    }
#line 7369
    ctx->Color.BlendColor[0] = (float )tmp;
  }
#line 7370
  if ((double )green < 0.0) {
#line 7370
    ctx->Color.BlendColor[1] = (float )0.0;
  } else {
#line 7370
    if ((double )green > 1.0) {
#line 7370
      tmp___0 = 1.0;
    } else {
#line 7370
      tmp___0 = (double )green;
    }
#line 7370
    ctx->Color.BlendColor[1] = (float )tmp___0;
  }
#line 7371
  if ((double )blue___0 < 0.0) {
#line 7371
    ctx->Color.BlendColor[2] = (float )0.0;
  } else {
#line 7371
    if ((double )blue___0 > 1.0) {
#line 7371
      tmp___1 = 1.0;
    } else {
#line 7371
      tmp___1 = (double )blue___0;
    }
#line 7371
    ctx->Color.BlendColor[2] = (float )tmp___1;
  }
#line 7372
  if ((double )alpha < 0.0) {
#line 7372
    ctx->Color.BlendColor[3] = (float )0.0;
  } else {
#line 7372
    if ((double )alpha > 1.0) {
#line 7372
      tmp___2 = 1.0;
    } else {
#line 7372
      tmp___2 = (double )alpha;
    }
#line 7372
    ctx->Color.BlendColor[3] = (float )tmp___2;
  }
#line 7373
  return;
}
}
#line 7374 "D:/a/test/177.c"
static void do_blend(GLcontext *ctx , GLuint n , GLubyte const   *mask , GLubyte *red ,
                     GLubyte *green , GLubyte *blue___0 , GLubyte *alpha , GLubyte const   *rdest ,
                     GLubyte const   *gdest , GLubyte const   *bdest , GLubyte const   *adest ) 
{ GLuint i ;
  float ascale ;
  GLint rmax ;
  GLint gmax ;
  GLint bmax ;
  GLint amax ;
  GLint r ;
  GLint g ;
  GLint b ;
  GLint a ;
  GLint t ;
  GLint s ;
  float rmax___0 ;
  float gmax___0 ;
  float bmax___0 ;
  float amax___0 ;
  float rscale ;
  float gscale ;
  float bscale ;
  float ascale___0 ;
  GLint Rs ;
  GLint Gs ;
  GLint Bs ;
  GLint As ;
  GLint Rd ;
  GLint Gd ;
  GLint Bd ;
  GLint Ad ;
  float sR ;
  float sG ;
  float sB ;
  float sA ;
  float dR ;
  float dG ;
  float dB ;
  float dA ;
  float r___0 ;
  float g___0 ;
  float b___0 ;
  float a___0 ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;

  {
#line 7381
  if (ctx->Color.BlendEquation == 32774) {
#line 7381
    if (ctx->Color.BlendSrc == 770) {
#line 7381
      if (ctx->Color.BlendDst == 771) {
#line 7384
        ascale = 256.0f * (ctx->Visual)->InvAlphaScale;
#line 7385
        rmax = (int )(ctx->Visual)->RedScale;
#line 7386
        gmax = (int )(ctx->Visual)->GreenScale;
#line 7387
        bmax = (int )(ctx->Visual)->BlueScale;
#line 7388
        amax = (int )(ctx->Visual)->AlphaScale;
#line 7389
        i = 0U;
#line 7389
        while (i < n) {
#line 7390
          if (*(mask + i)) {
#line 7392
            t = (int )((float )*(alpha + i) * ascale);
#line 7393
            s = 256 - t;
#line 7394
            r = ((int )*(red + i) * t + (int )((int const   )*(rdest + i) * (int const   )s)) >> 8;
#line 7395
            g = ((int )*(green + i) * t + (int )((int const   )*(gdest + i) * (int const   )s)) >> 8;
#line 7396
            b = ((int )*(blue___0 + i) * t + (int )((int const   )*(bdest + i) * (int const   )s)) >> 8;
#line 7397
            a = ((int )*(alpha + i) * t + (int )((int const   )*(adest + i) * (int const   )s)) >> 8;
#line 7398
            if (r < rmax) {
#line 7398
              *(red + i) = (unsigned char )r;
            } else {
#line 7398
              *(red + i) = (unsigned char )rmax;
            }
#line 7399
            if (g < gmax) {
#line 7399
              *(green + i) = (unsigned char )g;
            } else {
#line 7399
              *(green + i) = (unsigned char )gmax;
            }
#line 7400
            if (b < bmax) {
#line 7400
              *(blue___0 + i) = (unsigned char )b;
            } else {
#line 7400
              *(blue___0 + i) = (unsigned char )bmax;
            }
#line 7401
            if (a < amax) {
#line 7401
              *(alpha + i) = (unsigned char )a;
            } else {
#line 7401
              *(alpha + i) = (unsigned char )amax;
            }
          }
#line 7389
          i ++;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 7405
    if (ctx->Color.BlendEquation == 32774) {
      goto _L;
    } else {
#line 7405
      if (ctx->Color.BlendEquation == 32778) {
        goto _L;
      } else {
#line 7405
        if (ctx->Color.BlendEquation == 32779) {
          _L: /* CIL Label */ 
#line 7408
          rmax___0 = (ctx->Visual)->RedScale;
#line 7409
          gmax___0 = (ctx->Visual)->GreenScale;
#line 7410
          bmax___0 = (ctx->Visual)->BlueScale;
#line 7411
          amax___0 = (ctx->Visual)->AlphaScale;
#line 7412
          rscale = 1.0f / rmax___0;
#line 7413
          gscale = 1.0f / gmax___0;
#line 7414
          bscale = 1.0f / bmax___0;
#line 7415
          ascale___0 = 1.0f / amax___0;
#line 7416
          i = 0U;
#line 7416
          while (i < n) {
#line 7417
            if (*(mask + i)) {
#line 7424
              Rs = (int )*(red + i);
#line 7425
              Gs = (int )*(green + i);
#line 7426
              Bs = (int )*(blue___0 + i);
#line 7427
              As = (int )*(alpha + i);
#line 7429
              Rd = (int )*(rdest + i);
#line 7430
              Gd = (int )*(gdest + i);
#line 7431
              Bd = (int )*(bdest + i);
#line 7432
              Ad = (int )*(adest + i);
#line 7434
              switch (ctx->Color.BlendSrc) {
              case 0: 
#line 7436
              sA = 0.0F;
#line 7436
              sB = sA;
#line 7436
              sG = sB;
#line 7436
              sR = sG;
#line 7437
              break;
              case 1: 
#line 7439
              sA = 1.0F;
#line 7439
              sB = sA;
#line 7439
              sG = sB;
#line 7439
              sR = sG;
#line 7440
              break;
              case 774: 
#line 7442
              sR = (float )Rd * rscale;
#line 7443
              sG = (float )Gd * gscale;
#line 7444
              sB = (float )Bd * bscale;
#line 7445
              sA = (float )Ad * ascale___0;
#line 7446
              break;
              case 775: 
#line 7448
              sR = 1.0F - (float )Rd * rscale;
#line 7449
              sG = 1.0F - (float )Gd * gscale;
#line 7450
              sB = 1.0F - (float )Bd * bscale;
#line 7451
              sA = 1.0F - (float )Ad * ascale___0;
#line 7452
              break;
              case 770: 
#line 7454
              sA = (float )As * ascale___0;
#line 7454
              sB = sA;
#line 7454
              sG = sB;
#line 7454
              sR = sG;
#line 7455
              break;
              case 771: 
#line 7457
              sA = 1.0F - (float )As * ascale___0;
#line 7457
              sB = sA;
#line 7457
              sG = sB;
#line 7457
              sR = sG;
#line 7458
              break;
              case 772: 
#line 7460
              sA = (float )Ad * ascale___0;
#line 7460
              sB = sA;
#line 7460
              sG = sB;
#line 7460
              sR = sG;
#line 7461
              break;
              case 773: 
#line 7463
              sA = 1.0F - (float )Ad * ascale___0;
#line 7463
              sB = sA;
#line 7463
              sG = sB;
#line 7463
              sR = sG;
#line 7464
              break;
              case 776: 
#line 7466
              if ((float )As < 1.0F - (float )Ad * ascale___0) {
#line 7467
                sB = (float )As * ascale___0;
#line 7467
                sG = sB;
#line 7467
                sR = sG;
              } else {
#line 7470
                sB = 1.0F - (float )Ad * ascale___0;
#line 7470
                sG = sB;
#line 7470
                sR = sG;
              }
#line 7472
              sA = (float )1.0;
#line 7473
              break;
              case 32769: 
#line 7475
              sR = ctx->Color.BlendColor[0];
#line 7476
              sG = ctx->Color.BlendColor[1];
#line 7477
              sB = ctx->Color.BlendColor[2];
#line 7478
              sA = ctx->Color.BlendColor[3];
#line 7479
              break;
              case 32770: 
#line 7481
              sR = 1.0F - ctx->Color.BlendColor[0];
#line 7482
              sG = 1.0F - ctx->Color.BlendColor[1];
#line 7483
              sB = 1.0F - ctx->Color.BlendColor[2];
#line 7484
              sA = 1.0F - ctx->Color.BlendColor[3];
#line 7485
              break;
              case 32771: 
#line 7487
              sA = ctx->Color.BlendColor[3];
#line 7487
              sB = sA;
#line 7487
              sG = sB;
#line 7487
              sR = sG;
#line 7488
              break;
              case 32772: 
#line 7490
              sA = 1.0F - ctx->Color.BlendColor[3];
#line 7490
              sB = sA;
#line 7490
              sG = sB;
#line 7490
              sR = sG;
#line 7491
              break;
              default: 
#line 7493
              gl_problem(ctx, "Bad blend source factor in do_blend");
              }
#line 7496
              switch (ctx->Color.BlendDst) {
              case 0: 
#line 7498
              dA = 0.0F;
#line 7498
              dB = dA;
#line 7498
              dG = dB;
#line 7498
              dR = dG;
#line 7499
              break;
              case 1: 
#line 7501
              dA = 1.0F;
#line 7501
              dB = dA;
#line 7501
              dG = dB;
#line 7501
              dR = dG;
#line 7502
              break;
              case 768: 
#line 7504
              dR = (float )Rs * rscale;
#line 7505
              dG = (float )Gs * gscale;
#line 7506
              dB = (float )Bs * bscale;
#line 7507
              dA = (float )As * ascale___0;
#line 7508
              break;
              case 769: 
#line 7510
              dR = 1.0F - (float )Rs * rscale;
#line 7511
              dG = 1.0F - (float )Gs * gscale;
#line 7512
              dB = 1.0F - (float )Bs * bscale;
#line 7513
              dA = 1.0F - (float )As * ascale___0;
#line 7514
              break;
              case 770: 
#line 7516
              dA = (float )As * ascale___0;
#line 7516
              dB = dA;
#line 7516
              dG = dB;
#line 7516
              dR = dG;
#line 7517
              break;
              case 771: 
#line 7519
              dA = 1.0F - (float )As * ascale___0;
#line 7519
              dB = dA;
#line 7519
              dG = dB;
#line 7519
              dR = dG;
#line 7520
              break;
              case 772: 
#line 7522
              dA = (float )Ad * ascale___0;
#line 7522
              dB = dA;
#line 7522
              dG = dB;
#line 7522
              dR = dG;
#line 7523
              break;
              case 773: 
#line 7525
              dA = 1.0F - (float )Ad * ascale___0;
#line 7525
              dB = dA;
#line 7525
              dG = dB;
#line 7525
              dR = dG;
#line 7526
              break;
              case 32769: 
#line 7528
              dR = ctx->Color.BlendColor[0];
#line 7529
              dG = ctx->Color.BlendColor[1];
#line 7530
              dB = ctx->Color.BlendColor[2];
#line 7531
              dA = ctx->Color.BlendColor[3];
#line 7532
              break;
              case 32770: 
#line 7534
              dR = 1.0F - ctx->Color.BlendColor[0];
#line 7535
              dG = 1.0F - ctx->Color.BlendColor[1];
#line 7536
              dB = 1.0F - ctx->Color.BlendColor[2];
#line 7537
              dA = 1.0F - ctx->Color.BlendColor[3];
#line 7538
              break;
              case 32771: 
#line 7540
              dA = ctx->Color.BlendColor[3];
#line 7540
              dB = dA;
#line 7540
              dG = dB;
#line 7540
              dR = dG;
#line 7541
              break;
              case 32772: 
#line 7543
              dA = 1.0F - ctx->Color.BlendColor[3] * ascale___0;
#line 7543
              dB = dA;
#line 7543
              dG = dB;
#line 7543
              dR = dG;
#line 7544
              break;
              default: 
#line 7546
              gl_problem(ctx, "Bad blend dest factor in do_blend");
              }
#line 7559
              if (ctx->Color.BlendEquation == 32774) {
#line 7560
                r___0 = (float )Rs * sR + (float )Rd * dR;
#line 7561
                g___0 = (float )Gs * sG + (float )Gd * dG;
#line 7562
                b___0 = (float )Bs * sB + (float )Bd * dB;
#line 7563
                a___0 = (float )As * sA + (float )Ad * dA;
              } else {
#line 7565
                if (ctx->Color.BlendEquation == 32778) {
#line 7566
                  r___0 = (float )Rs * sR - (float )Rd * dR;
#line 7567
                  g___0 = (float )Gs * sG - (float )Gd * dG;
#line 7568
                  b___0 = (float )Bs * sB - (float )Bd * dB;
#line 7569
                  a___0 = (float )As * sA - (float )Ad * dA;
                } else {
#line 7571
                  if (ctx->Color.BlendEquation == 32779) {
#line 7572
                    r___0 = (float )Rd * dR - (float )Rs * sR;
#line 7573
                    g___0 = (float )Gd * dG - (float )Gs * sG;
#line 7574
                    b___0 = (float )Bd * dB - (float )Bs * sB;
#line 7575
                    a___0 = (float )Ad * dA - (float )As * sA;
                  }
                }
              }
#line 7577
              if (r___0 < 0.0F) {
#line 7577
                tmp___0 = 0.0F;
              } else {
#line 7577
                if (r___0 > rmax___0) {
#line 7577
                  tmp = rmax___0;
                } else {
#line 7577
                  tmp = r___0;
                }
#line 7577
                tmp___0 = tmp;
              }
#line 7577
              *(red + i) = (unsigned char )((int )tmp___0);
#line 7578
              if (g___0 < 0.0F) {
#line 7578
                tmp___2 = 0.0F;
              } else {
#line 7578
                if (g___0 > gmax___0) {
#line 7578
                  tmp___1 = gmax___0;
                } else {
#line 7578
                  tmp___1 = g___0;
                }
#line 7578
                tmp___2 = tmp___1;
              }
#line 7578
              *(green + i) = (unsigned char )((int )tmp___2);
#line 7579
              if (b___0 < 0.0F) {
#line 7579
                tmp___4 = 0.0F;
              } else {
#line 7579
                if (b___0 > bmax___0) {
#line 7579
                  tmp___3 = bmax___0;
                } else {
#line 7579
                  tmp___3 = b___0;
                }
#line 7579
                tmp___4 = tmp___3;
              }
#line 7579
              *(blue___0 + i) = (unsigned char )((int )tmp___4);
#line 7580
              if (a___0 < 0.0F) {
#line 7580
                tmp___6 = 0.0F;
              } else {
#line 7580
                if (a___0 > amax___0) {
#line 7580
                  tmp___5 = amax___0;
                } else {
#line 7580
                  tmp___5 = a___0;
                }
#line 7580
                tmp___6 = tmp___5;
              }
#line 7580
              *(alpha + i) = (unsigned char )((int )tmp___6);
            }
#line 7416
            i ++;
          }
        } else {
#line 7584
          if (ctx->Color.BlendEquation == 32775) {
#line 7585
            i = 0U;
#line 7585
            while (i < n) {
#line 7586
              if (*(mask + i)) {
#line 7587
                if ((int )*(red + i) < (int )*(rdest + i)) {
#line 7587
                  *(red + i) = *(red + i);
                } else {
#line 7587
                  *(red + i) = (unsigned char )*(rdest + i);
                }
#line 7588
                if ((int )*(green + i) < (int )*(gdest + i)) {
#line 7588
                  *(green + i) = *(green + i);
                } else {
#line 7588
                  *(green + i) = (unsigned char )*(gdest + i);
                }
#line 7589
                if ((int )*(blue___0 + i) < (int )*(bdest + i)) {
#line 7589
                  *(blue___0 + i) = *(blue___0 + i);
                } else {
#line 7589
                  *(blue___0 + i) = (unsigned char )*(bdest + i);
                }
#line 7590
                if ((int )*(alpha + i) < (int )*(adest + i)) {
#line 7590
                  *(alpha + i) = *(alpha + i);
                } else {
#line 7590
                  *(alpha + i) = (unsigned char )*(adest + i);
                }
              }
#line 7585
              i ++;
            }
          } else {
#line 7594
            if (ctx->Color.BlendEquation == 32776) {
#line 7595
              i = 0U;
#line 7595
              while (i < n) {
#line 7596
                if (*(mask + i)) {
#line 7597
                  if ((int )*(red + i) > (int )*(rdest + i)) {
#line 7597
                    *(red + i) = *(red + i);
                  } else {
#line 7597
                    *(red + i) = (unsigned char )*(rdest + i);
                  }
#line 7598
                  if ((int )*(green + i) > (int )*(gdest + i)) {
#line 7598
                    *(green + i) = *(green + i);
                  } else {
#line 7598
                    *(green + i) = (unsigned char )*(gdest + i);
                  }
#line 7599
                  if ((int )*(blue___0 + i) > (int )*(bdest + i)) {
#line 7599
                    *(blue___0 + i) = *(blue___0 + i);
                  } else {
#line 7599
                    *(blue___0 + i) = (unsigned char )*(bdest + i);
                  }
#line 7600
                  if ((int )*(alpha + i) > (int )*(adest + i)) {
#line 7600
                    *(alpha + i) = *(alpha + i);
                  } else {
#line 7600
                    *(alpha + i) = (unsigned char )*(adest + i);
                  }
                }
#line 7595
                i ++;
              }
            }
          }
        }
      }
    }
  }
#line 7604
  return;
}
}
#line 7615
void gl_read_color_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *red ,
                        GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) ;
#line 7605 "D:/a/test/177.c"
void gl_blend_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *red ,
                   GLubyte *green , GLubyte *blue___0 , GLubyte *alpha , GLubyte *mask ) 
{ GLubyte rdest[640] ;
  GLubyte gdest[640] ;
  GLubyte bdest[640] ;
  GLubyte adest[640] ;

  {
#line 7612
  if (ctx->Color.BlendEquation == 3057) {
#line 7612
    if (! ctx->Color.SWLogicOpEnabled) {
#line 7613
      return;
    }
  }
#line 7615
  gl_read_color_span(ctx, n, x, y, rdest, gdest, bdest, adest);
#line 7616
  do_blend(ctx, n, (GLubyte const   *)mask, red, green, blue___0, alpha, (GLubyte const   *)(rdest),
           (GLubyte const   *)(gdest), (GLubyte const   *)(bdest), (GLubyte const   *)(adest));
#line 7617
  return;
}
}
#line 7618 "D:/a/test/177.c"
void gl_blend_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                     GLubyte *red , GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ,
                     GLubyte *mask ) 
{ GLubyte rdest[1920] ;
  GLubyte gdest[1920] ;
  GLubyte bdest[1920] ;
  GLubyte adest[1920] ;

  {
#line 7625
  if (ctx->Color.BlendEquation == 3057) {
#line 7625
    if (! ctx->Color.SWLogicOpEnabled) {
#line 7626
      return;
    }
  }
#line 7628
  (*(ctx->Driver.ReadColorPixels))(ctx, n, x, y, rdest, gdest, bdest, adest, (GLubyte const   *)mask);
#line 7629
  if (ctx->RasterMask & 256U) {
#line 7630
    gl_read_alpha_pixels(ctx, n, x, y, adest, (GLubyte const   *)mask);
  }
#line 7632
  do_blend(ctx, n, (GLubyte const   *)mask, red, green, blue___0, alpha, (GLubyte const   *)(rdest),
           (GLubyte const   *)(gdest), (GLubyte const   *)(bdest), (GLubyte const   *)(adest));
#line 7633
  return;
}
}
#line 7642 "D:/a/test/177.c"
static GLuint Space  ;
#line 7643 "D:/a/test/177.c"
static void interpolate_aux(GLcontext *ctx , GLuint dst , float t , GLuint in , GLuint out ) 
{ struct vertex_buffer *VB ;

  {
#line 7646
  VB = ctx->VB;
#line 7647
  if (ctx->ClipMask & 1U) {
#line 7648
    VB->Fcolor[dst][0] = (unsigned char )((float )VB->Fcolor[in][0] + t * (float )((int )VB->Fcolor[out][0] - (int )VB->Fcolor[in][0]));
#line 7649
    VB->Fcolor[dst][1] = (unsigned char )((float )VB->Fcolor[in][1] + t * (float )((int )VB->Fcolor[out][1] - (int )VB->Fcolor[in][1]));
#line 7650
    VB->Fcolor[dst][2] = (unsigned char )((float )VB->Fcolor[in][2] + t * (float )((int )VB->Fcolor[out][2] - (int )VB->Fcolor[in][2]));
#line 7651
    VB->Fcolor[dst][3] = (unsigned char )((float )VB->Fcolor[in][3] + t * (float )((int )VB->Fcolor[out][3] - (int )VB->Fcolor[in][3]));
  } else {
#line 7653
    if (ctx->ClipMask & 4U) {
#line 7654
      VB->Findex[dst] = (unsigned int )((int )((float )VB->Findex[in] + t * ((float )VB->Findex[out] - (float )VB->Findex[in])));
    }
  }
#line 7657
  if (ctx->ClipMask & 2U) {
#line 7658
    VB->Bcolor[dst][0] = (unsigned char )((float )VB->Bcolor[in][0] + t * (float )((int )VB->Bcolor[out][0] - (int )VB->Bcolor[in][0]));
#line 7659
    VB->Bcolor[dst][1] = (unsigned char )((float )VB->Bcolor[in][1] + t * (float )((int )VB->Bcolor[out][1] - (int )VB->Bcolor[in][1]));
#line 7660
    VB->Bcolor[dst][2] = (unsigned char )((float )VB->Bcolor[in][2] + t * (float )((int )VB->Bcolor[out][2] - (int )VB->Bcolor[in][2]));
#line 7661
    VB->Bcolor[dst][3] = (unsigned char )((float )VB->Bcolor[in][3] + t * (float )((int )VB->Bcolor[out][3] - (int )VB->Bcolor[in][3]));
  } else {
#line 7663
    if (ctx->ClipMask & 8U) {
#line 7664
      VB->Bindex[dst] = (unsigned int )((int )((float )VB->Bindex[in] + t * ((float )VB->Bindex[out] - (float )VB->Bindex[in])));
    }
  }
#line 7667
  if (ctx->ClipMask & 16U) {
#line 7668
    if (Space == 2U) {
#line 7670
      VB->Eye[dst][2] = VB->Eye[in][2] + t * (VB->Eye[out][2] - VB->Eye[in][2]);
    }
#line 7672
    VB->TexCoord[dst][0] = VB->TexCoord[in][0] + t * (VB->TexCoord[out][0] - VB->TexCoord[in][0]);
#line 7673
    VB->TexCoord[dst][1] = VB->TexCoord[in][1] + t * (VB->TexCoord[out][1] - VB->TexCoord[in][1]);
#line 7674
    VB->TexCoord[dst][2] = VB->TexCoord[in][2] + t * (VB->TexCoord[out][2] - VB->TexCoord[in][2]);
#line 7675
    VB->TexCoord[dst][3] = VB->TexCoord[in][3] + t * (VB->TexCoord[out][3] - VB->TexCoord[in][3]);
  }
#line 7677
  return;
}
}
#line 7687
void gl_analyze_modelview_matrix(GLcontext *ctx ) ;
#line 7689
void gl_transform_vector(float *u , float const   *v , float const   *m ) ;
#line 7678 "D:/a/test/177.c"
void gl_ClipPlane(GLcontext *ctx , GLenum plane , float const   *equation ) 
{ GLint p ;

  {
#line 7681
  p = plane - 12288;
#line 7682
  if (p < 0) {
#line 7683
    gl_error(ctx, 1280, "glClipPlane");
#line 7684
    return;
  } else {
#line 7682
    if (p >= 6) {
#line 7683
      gl_error(ctx, 1280, "glClipPlane");
#line 7684
      return;
    }
  }
#line 7686
  if (ctx->NewModelViewMatrix) {
#line 7687
    gl_analyze_modelview_matrix(ctx);
  }
#line 7689
  gl_transform_vector(ctx->Transform.ClipEquation[p], equation, ctx->ModelViewInv);
#line 7691
  return;
}
}
#line 7692 "D:/a/test/177.c"
void gl_GetClipPlane(GLcontext *ctx , GLenum plane , GLdouble *equation ) 
{ GLint p ;

  {
#line 7695
  if (ctx->Primitive != 6656) {
#line 7696
    gl_error(ctx, 1282, "glGetClipPlane");
#line 7697
    return;
  }
#line 7699
  p = plane - 12288;
#line 7700
  if (p < 0) {
#line 7701
    gl_error(ctx, 1280, "glGetClipPlane");
#line 7702
    return;
  } else {
#line 7700
    if (p >= 6) {
#line 7701
      gl_error(ctx, 1280, "glGetClipPlane");
#line 7702
      return;
    }
  }
#line 7704
  *(equation + 0) = (double )ctx->Transform.ClipEquation[p][0];
#line 7705
  *(equation + 1) = (double )ctx->Transform.ClipEquation[p][1];
#line 7706
  *(equation + 2) = (double )ctx->Transform.ClipEquation[p][2];
#line 7707
  *(equation + 3) = (double )ctx->Transform.ClipEquation[p][3];
#line 7708
  return;
}
}
#line 7709 "D:/a/test/177.c"
GLuint gl_viewclip_point(float const   *v ) 
{ 

  {
#line 7711
  if (*(v + 0) > *(v + 3)) {
#line 7714
    return (0U);
  } else {
#line 7711
    if (*(v + 0) < - *(v + 3)) {
#line 7714
      return (0U);
    } else {
#line 7711
      if (*(v + 1) > *(v + 3)) {
#line 7714
        return (0U);
      } else {
#line 7711
        if (*(v + 1) < - *(v + 3)) {
#line 7714
          return (0U);
        } else {
#line 7711
          if (*(v + 2) > *(v + 3)) {
#line 7714
            return (0U);
          } else {
#line 7711
            if (*(v + 2) < - *(v + 3)) {
#line 7714
              return (0U);
            } else {
#line 7717
              return (1U);
            }
          }
        }
      }
    }
  }
}
}
#line 7720 "D:/a/test/177.c"
GLuint gl_viewclip_line(GLcontext *ctx , GLuint *i , GLuint *j ) 
{ struct vertex_buffer *VB ;
  float (*coord)[4] ;
  float t ;
  float dx ;
  float dy ;
  float dw ;
  register GLuint ii ;
  register GLuint jj ;

  {
#line 7722
  VB = ctx->VB;
#line 7723
  coord = VB->Clip;
#line 7726
  Space = 2U;
#line 7727
  ii = *i;
#line 7728
  jj = *j;
#line 7772
  if ((*(coord + ii))[0] > (*(coord + ii))[3]) {
#line 7772
    if ((*(coord + jj))[0] > (*(coord + jj))[3]) {
#line 7772
      return (0U);
    } else {
#line 7772
      dx = (*(coord + ii))[0] - (*(coord + jj))[0];
#line 7772
      dw = (*(coord + ii))[3] - (*(coord + jj))[3];
#line 7772
      t = ((*(coord + jj))[0] - (*(coord + jj))[3]) / (dw - dx);
#line 7772
      (*(coord + VB->Free))[0] = (*(coord + jj))[0] + t * dx;
#line 7772
      (*(coord + VB->Free))[1] = (*(coord + jj))[1] + t * ((*(coord + ii))[1] - (*(coord + jj))[1]);
#line 7772
      (*(coord + VB->Free))[2] = (*(coord + jj))[2] + t * ((*(coord + ii))[2] - (*(coord + jj))[2]);
#line 7772
      (*(coord + VB->Free))[3] = (*(coord + jj))[3] + t * dw;
#line 7772
      if (ctx->ClipMask) {
#line 7772
        interpolate_aux(ctx, VB->Free, t, jj, ii);
      }
#line 7772
      ii = VB->Free;
#line 7772
      (VB->Free) ++;
#line 7772
      if (VB->Free == 504U) {
#line 7772
        VB->Free = 1U;
      }
    }
  } else {
#line 7772
    if ((*(coord + jj))[0] > (*(coord + jj))[3]) {
#line 7772
      dx = (*(coord + jj))[0] - (*(coord + ii))[0];
#line 7772
      dw = (*(coord + jj))[3] - (*(coord + ii))[3];
#line 7772
      t = ((*(coord + ii))[0] - (*(coord + ii))[3]) / (dw - dx);
#line 7772
      (*(coord + VB->Free))[0] = (*(coord + ii))[0] + t * dx;
#line 7772
      (*(coord + VB->Free))[1] = (*(coord + ii))[1] + t * ((*(coord + jj))[1] - (*(coord + ii))[1]);
#line 7772
      (*(coord + VB->Free))[2] = (*(coord + ii))[2] + t * ((*(coord + jj))[2] - (*(coord + ii))[2]);
#line 7772
      (*(coord + VB->Free))[3] = (*(coord + ii))[3] + t * dw;
#line 7772
      if (ctx->ClipMask) {
#line 7772
        interpolate_aux(ctx, VB->Free, t, ii, jj);
      }
#line 7772
      jj = VB->Free;
#line 7772
      (VB->Free) ++;
#line 7772
      if (VB->Free == 504U) {
#line 7772
        VB->Free = 1U;
      }
    }
  }
#line 7784
  if ((*(coord + ii))[0] < - (*(coord + ii))[3]) {
#line 7784
    if ((*(coord + jj))[0] < - (*(coord + jj))[3]) {
#line 7784
      return (0U);
    } else {
#line 7784
      dx = (*(coord + ii))[0] - (*(coord + jj))[0];
#line 7784
      dw = (*(coord + ii))[3] - (*(coord + jj))[3];
#line 7784
      t = - ((*(coord + jj))[0] + (*(coord + jj))[3]) / (dw + dx);
#line 7784
      (*(coord + VB->Free))[0] = (*(coord + jj))[0] + t * dx;
#line 7784
      (*(coord + VB->Free))[1] = (*(coord + jj))[1] + t * ((*(coord + ii))[1] - (*(coord + jj))[1]);
#line 7784
      (*(coord + VB->Free))[2] = (*(coord + jj))[2] + t * ((*(coord + ii))[2] - (*(coord + jj))[2]);
#line 7784
      (*(coord + VB->Free))[3] = (*(coord + jj))[3] + t * dw;
#line 7784
      if (ctx->ClipMask) {
#line 7784
        interpolate_aux(ctx, VB->Free, t, jj, ii);
      }
#line 7784
      ii = VB->Free;
#line 7784
      (VB->Free) ++;
#line 7784
      if (VB->Free == 504U) {
#line 7784
        VB->Free = 1U;
      }
    }
  } else {
#line 7784
    if ((*(coord + jj))[0] < - (*(coord + jj))[3]) {
#line 7784
      dx = (*(coord + jj))[0] - (*(coord + ii))[0];
#line 7784
      dw = (*(coord + jj))[3] - (*(coord + ii))[3];
#line 7784
      t = - ((*(coord + ii))[0] + (*(coord + ii))[3]) / (dw + dx);
#line 7784
      (*(coord + VB->Free))[0] = (*(coord + ii))[0] + t * dx;
#line 7784
      (*(coord + VB->Free))[1] = (*(coord + ii))[1] + t * ((*(coord + jj))[1] - (*(coord + ii))[1]);
#line 7784
      (*(coord + VB->Free))[2] = (*(coord + ii))[2] + t * ((*(coord + jj))[2] - (*(coord + ii))[2]);
#line 7784
      (*(coord + VB->Free))[3] = (*(coord + ii))[3] + t * dw;
#line 7784
      if (ctx->ClipMask) {
#line 7784
        interpolate_aux(ctx, VB->Free, t, ii, jj);
      }
#line 7784
      jj = VB->Free;
#line 7784
      (VB->Free) ++;
#line 7784
      if (VB->Free == 504U) {
#line 7784
        VB->Free = 1U;
      }
    }
  }
#line 7796
  if ((*(coord + ii))[1] > (*(coord + ii))[3]) {
#line 7796
    if ((*(coord + jj))[1] > (*(coord + jj))[3]) {
#line 7796
      return (0U);
    } else {
#line 7796
      dy = (*(coord + ii))[1] - (*(coord + jj))[1];
#line 7796
      dw = (*(coord + ii))[3] - (*(coord + jj))[3];
#line 7796
      t = ((*(coord + jj))[1] - (*(coord + jj))[3]) / (dw - dy);
#line 7796
      (*(coord + VB->Free))[0] = (*(coord + jj))[0] + t * ((*(coord + ii))[0] - (*(coord + jj))[0]);
#line 7796
      (*(coord + VB->Free))[1] = (*(coord + jj))[1] + t * dy;
#line 7796
      (*(coord + VB->Free))[2] = (*(coord + jj))[2] + t * ((*(coord + ii))[2] - (*(coord + jj))[2]);
#line 7796
      (*(coord + VB->Free))[3] = (*(coord + jj))[3] + t * dw;
#line 7796
      if (ctx->ClipMask) {
#line 7796
        interpolate_aux(ctx, VB->Free, t, jj, ii);
      }
#line 7796
      ii = VB->Free;
#line 7796
      (VB->Free) ++;
#line 7796
      if (VB->Free == 504U) {
#line 7796
        VB->Free = 1U;
      }
    }
  } else {
#line 7796
    if ((*(coord + jj))[1] > (*(coord + jj))[3]) {
#line 7796
      dy = (*(coord + jj))[1] - (*(coord + ii))[1];
#line 7796
      dw = (*(coord + jj))[3] - (*(coord + ii))[3];
#line 7796
      t = ((*(coord + ii))[1] - (*(coord + ii))[3]) / (dw - dy);
#line 7796
      (*(coord + VB->Free))[0] = (*(coord + ii))[0] + t * ((*(coord + jj))[0] - (*(coord + ii))[0]);
#line 7796
      (*(coord + VB->Free))[1] = (*(coord + ii))[1] + t * dy;
#line 7796
      (*(coord + VB->Free))[2] = (*(coord + ii))[2] + t * ((*(coord + jj))[2] - (*(coord + ii))[2]);
#line 7796
      (*(coord + VB->Free))[3] = (*(coord + ii))[3] + t * dw;
#line 7796
      if (ctx->ClipMask) {
#line 7796
        interpolate_aux(ctx, VB->Free, t, ii, jj);
      }
#line 7796
      jj = VB->Free;
#line 7796
      (VB->Free) ++;
#line 7796
      if (VB->Free == 504U) {
#line 7796
        VB->Free = 1U;
      }
    }
  }
#line 7808
  if ((*(coord + ii))[1] < - (*(coord + ii))[3]) {
#line 7808
    if ((*(coord + jj))[1] < - (*(coord + jj))[3]) {
#line 7808
      return (0U);
    } else {
#line 7808
      dy = (*(coord + ii))[1] - (*(coord + jj))[1];
#line 7808
      dw = (*(coord + ii))[3] - (*(coord + jj))[3];
#line 7808
      t = - ((*(coord + jj))[1] + (*(coord + jj))[3]) / (dw + dy);
#line 7808
      (*(coord + VB->Free))[0] = (*(coord + jj))[0] + t * ((*(coord + ii))[0] - (*(coord + jj))[0]);
#line 7808
      (*(coord + VB->Free))[1] = (*(coord + jj))[1] + t * dy;
#line 7808
      (*(coord + VB->Free))[2] = (*(coord + jj))[2] + t * ((*(coord + ii))[2] - (*(coord + jj))[2]);
#line 7808
      (*(coord + VB->Free))[3] = (*(coord + jj))[3] + t * dw;
#line 7808
      if (ctx->ClipMask) {
#line 7808
        interpolate_aux(ctx, VB->Free, t, jj, ii);
      }
#line 7808
      ii = VB->Free;
#line 7808
      (VB->Free) ++;
#line 7808
      if (VB->Free == 504U) {
#line 7808
        VB->Free = 1U;
      }
    }
  } else {
#line 7808
    if ((*(coord + jj))[1] < - (*(coord + jj))[3]) {
#line 7808
      dy = (*(coord + jj))[1] - (*(coord + ii))[1];
#line 7808
      dw = (*(coord + jj))[3] - (*(coord + ii))[3];
#line 7808
      t = - ((*(coord + ii))[1] + (*(coord + ii))[3]) / (dw + dy);
#line 7808
      (*(coord + VB->Free))[0] = (*(coord + ii))[0] + t * ((*(coord + jj))[0] - (*(coord + ii))[0]);
#line 7808
      (*(coord + VB->Free))[1] = (*(coord + ii))[1] + t * dy;
#line 7808
      (*(coord + VB->Free))[2] = (*(coord + ii))[2] + t * ((*(coord + jj))[2] - (*(coord + ii))[2]);
#line 7808
      (*(coord + VB->Free))[3] = (*(coord + ii))[3] + t * dw;
#line 7808
      if (ctx->ClipMask) {
#line 7808
        interpolate_aux(ctx, VB->Free, t, ii, jj);
      }
#line 7808
      jj = VB->Free;
#line 7808
      (VB->Free) ++;
#line 7808
      if (VB->Free == 504U) {
#line 7808
        VB->Free = 1U;
      }
    }
  }
#line 7835
  *i = ii;
#line 7836
  *j = jj;
#line 7837
  return (1U);
}
}
#line 7839 "D:/a/test/177.c"
GLuint gl_viewclip_polygon(GLcontext *ctx , GLuint n , GLuint *vlist ) 
{ struct vertex_buffer *VB ;
  float (*coord)[4] ;
  GLuint previ ;
  GLuint prevj ;
  GLuint curri ;
  GLuint currj ;
  GLuint vlist2[504] ;
  GLuint n2 ;
  GLdouble dx ;
  GLdouble dy ;
  GLdouble dz ;
  GLdouble dw ;
  GLdouble t ;
  GLdouble neww ;
  int i ;
  int i___0 ;
  int i___1 ;
  int i___2 ;
  int i___3 ;
  int i___4 ;

  {
#line 7841
  VB = ctx->VB;
#line 7842
  coord = VB->Clip;
#line 7848
  Space = 2U;
#line 7935
  if (n < 3U) {
#line 7935
    return (0U);
  }
#line 7935
  previ = n - 1U;
#line 7935
  prevj = *(vlist + previ);
#line 7935
  n2 = 0U;
#line 7935
  curri = 0U;
#line 7935
  while (curri < n) {
#line 7935
    currj = *(vlist + curri);
#line 7935
    if ((*(coord + currj))[0] <= (*(coord + currj))[3]) {
#line 7935
      if ((*(coord + prevj))[0] <= (*(coord + prevj))[3]) {
#line 7935
        vlist2[n2] = currj;
#line 7935
        n2 ++;
      } else {
#line 7935
        dx = (double )((*(coord + prevj))[0] - (*(coord + currj))[0]);
#line 7935
        dw = (double )((*(coord + prevj))[3] - (*(coord + currj))[3]);
#line 7935
        t = (GLdouble )((*(coord + currj))[0] - (*(coord + currj))[3]) / (dw - dx);
#line 7935
        neww = (GLdouble )(*(coord + currj))[3] + t * dw;
#line 7935
        (*(coord + VB->Free))[0] = (float )neww;
#line 7935
        (*(coord + VB->Free))[1] = (float )((GLdouble )(*(coord + currj))[1] + t * (GLdouble )((*(coord + prevj))[1] - (*(coord + currj))[1]));
#line 7935
        (*(coord + VB->Free))[2] = (float )((GLdouble )(*(coord + currj))[2] + t * (GLdouble )((*(coord + prevj))[2] - (*(coord + currj))[2]));
#line 7935
        (*(coord + VB->Free))[3] = (float )neww;
#line 7935
        if (t > 0.0) {
#line 7935
          if (ctx->ClipMask) {
#line 7935
            interpolate_aux(ctx, VB->Free, (float )t, currj, prevj);
          }
#line 7935
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 7935
          vlist2[n2] = VB->Free;
#line 7935
          (VB->Free) ++;
#line 7935
          if (VB->Free == 504U) {
#line 7935
            VB->Free = 1U;
          }
#line 7935
          n2 ++;
        }
#line 7935
        vlist2[n2] = currj;
#line 7935
        n2 ++;
      }
    } else {
#line 7935
      if ((*(coord + prevj))[0] <= (*(coord + prevj))[3]) {
#line 7935
        dx = (double )((*(coord + currj))[0] - (*(coord + prevj))[0]);
#line 7935
        dw = (double )((*(coord + currj))[3] - (*(coord + prevj))[3]);
#line 7935
        t = (GLdouble )((*(coord + prevj))[0] - (*(coord + prevj))[3]) / (dw - dx);
#line 7935
        neww = (GLdouble )(*(coord + prevj))[3] + t * dw;
#line 7935
        (*(coord + VB->Free))[0] = (float )neww;
#line 7935
        (*(coord + VB->Free))[1] = (float )((GLdouble )(*(coord + prevj))[1] + t * (GLdouble )((*(coord + currj))[1] - (*(coord + prevj))[1]));
#line 7935
        (*(coord + VB->Free))[2] = (float )((GLdouble )(*(coord + prevj))[2] + t * (GLdouble )((*(coord + currj))[2] - (*(coord + prevj))[2]));
#line 7935
        (*(coord + VB->Free))[3] = (float )neww;
#line 7935
        if (t > 0.0) {
#line 7935
          if (ctx->ClipMask) {
#line 7935
            interpolate_aux(ctx, VB->Free, (float )t, prevj, currj);
          }
#line 7935
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 7935
          vlist2[n2] = VB->Free;
#line 7935
          (VB->Free) ++;
#line 7935
          if (VB->Free == 504U) {
#line 7935
            VB->Free = 1U;
          }
#line 7935
          n2 ++;
        }
      }
    }
#line 7935
    previ = curri;
#line 7935
    prevj = currj;
#line 7935
    if (n2 >= 503U) {
#line 7935
      if ((unsigned int )(vlist2) == (unsigned int )(vlist2)) {
#line 7935
        i = 0;
#line 7935
        while (i < 504) {
#line 7935
          *(vlist + i) = vlist2[i];
#line 7935
          i ++;
        }
      }
#line 7935
      return (503U);
    }
#line 7935
    curri ++;
  }
#line 7956
  if (n2 < 3U) {
#line 7956
    return (0U);
  }
#line 7956
  previ = n2 - 1U;
#line 7956
  prevj = vlist2[previ];
#line 7956
  n = 0U;
#line 7956
  curri = 0U;
#line 7956
  while (curri < n2) {
#line 7956
    currj = vlist2[curri];
#line 7956
    if ((*(coord + currj))[0] >= - (*(coord + currj))[3]) {
#line 7956
      if ((*(coord + prevj))[0] >= - (*(coord + prevj))[3]) {
#line 7956
        *(vlist + n) = currj;
#line 7956
        n ++;
      } else {
#line 7956
        dx = (double )((*(coord + prevj))[0] - (*(coord + currj))[0]);
#line 7956
        dw = (double )((*(coord + prevj))[3] - (*(coord + currj))[3]);
#line 7956
        t = (GLdouble )(- ((*(coord + currj))[0] + (*(coord + currj))[3])) / (dw + dx);
#line 7956
        neww = (GLdouble )(*(coord + currj))[3] + t * dw;
#line 7956
        (*(coord + VB->Free))[0] = (float )(- neww);
#line 7956
        (*(coord + VB->Free))[1] = (float )((GLdouble )(*(coord + currj))[1] + t * (GLdouble )((*(coord + prevj))[1] - (*(coord + currj))[1]));
#line 7956
        (*(coord + VB->Free))[2] = (float )((GLdouble )(*(coord + currj))[2] + t * (GLdouble )((*(coord + prevj))[2] - (*(coord + currj))[2]));
#line 7956
        (*(coord + VB->Free))[3] = (float )neww;
#line 7956
        if (t > 0.0) {
#line 7956
          if (ctx->ClipMask) {
#line 7956
            interpolate_aux(ctx, VB->Free, (float )t, currj, prevj);
          }
#line 7956
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 7956
          *(vlist + n) = VB->Free;
#line 7956
          (VB->Free) ++;
#line 7956
          if (VB->Free == 504U) {
#line 7956
            VB->Free = 1U;
          }
#line 7956
          n ++;
        }
#line 7956
        *(vlist + n) = currj;
#line 7956
        n ++;
      }
    } else {
#line 7956
      if ((*(coord + prevj))[0] >= - (*(coord + prevj))[3]) {
#line 7956
        dx = (double )((*(coord + currj))[0] - (*(coord + prevj))[0]);
#line 7956
        dw = (double )((*(coord + currj))[3] - (*(coord + prevj))[3]);
#line 7956
        t = (GLdouble )(- ((*(coord + prevj))[0] + (*(coord + prevj))[3])) / (dw + dx);
#line 7956
        neww = (GLdouble )(*(coord + prevj))[3] + t * dw;
#line 7956
        (*(coord + VB->Free))[0] = (float )(- neww);
#line 7956
        (*(coord + VB->Free))[1] = (float )((GLdouble )(*(coord + prevj))[1] + t * (GLdouble )((*(coord + currj))[1] - (*(coord + prevj))[1]));
#line 7956
        (*(coord + VB->Free))[2] = (float )((GLdouble )(*(coord + prevj))[2] + t * (GLdouble )((*(coord + currj))[2] - (*(coord + prevj))[2]));
#line 7956
        (*(coord + VB->Free))[3] = (float )neww;
#line 7956
        if (t > 0.0) {
#line 7956
          if (ctx->ClipMask) {
#line 7956
            interpolate_aux(ctx, VB->Free, (float )t, prevj, currj);
          }
#line 7956
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 7956
          *(vlist + n) = VB->Free;
#line 7956
          (VB->Free) ++;
#line 7956
          if (VB->Free == 504U) {
#line 7956
            VB->Free = 1U;
          }
#line 7956
          n ++;
        }
      }
    }
#line 7956
    previ = curri;
#line 7956
    prevj = currj;
#line 7956
    if (n >= 503U) {
#line 7956
      if ((unsigned int )vlist == (unsigned int )(vlist2)) {
#line 7956
        i___0 = 0;
#line 7956
        while (i___0 < 504) {
#line 7956
          *(vlist + i___0) = *(vlist + i___0);
#line 7956
          i___0 ++;
        }
      }
#line 7956
      return (503U);
    }
#line 7956
    curri ++;
  }
#line 7977
  if (n < 3U) {
#line 7977
    return (0U);
  }
#line 7977
  previ = n - 1U;
#line 7977
  prevj = *(vlist + previ);
#line 7977
  n2 = 0U;
#line 7977
  curri = 0U;
#line 7977
  while (curri < n) {
#line 7977
    currj = *(vlist + curri);
#line 7977
    if ((*(coord + currj))[1] <= (*(coord + currj))[3]) {
#line 7977
      if ((*(coord + prevj))[1] <= (*(coord + prevj))[3]) {
#line 7977
        vlist2[n2] = currj;
#line 7977
        n2 ++;
      } else {
#line 7977
        dy = (double )((*(coord + prevj))[1] - (*(coord + currj))[1]);
#line 7977
        dw = (double )((*(coord + prevj))[3] - (*(coord + currj))[3]);
#line 7977
        t = (GLdouble )((*(coord + currj))[1] - (*(coord + currj))[3]) / (dw - dy);
#line 7977
        neww = (GLdouble )(*(coord + currj))[3] + t * dw;
#line 7977
        (*(coord + VB->Free))[0] = (float )((GLdouble )(*(coord + currj))[0] + t * (GLdouble )((*(coord + prevj))[0] - (*(coord + currj))[0]));
#line 7977
        (*(coord + VB->Free))[1] = (float )neww;
#line 7977
        (*(coord + VB->Free))[2] = (float )((GLdouble )(*(coord + currj))[2] + t * (GLdouble )((*(coord + prevj))[2] - (*(coord + currj))[2]));
#line 7977
        (*(coord + VB->Free))[3] = (float )neww;
#line 7977
        if (t > 0.0) {
#line 7977
          if (ctx->ClipMask) {
#line 7977
            interpolate_aux(ctx, VB->Free, (float )t, currj, prevj);
          }
#line 7977
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 7977
          vlist2[n2] = VB->Free;
#line 7977
          (VB->Free) ++;
#line 7977
          if (VB->Free == 504U) {
#line 7977
            VB->Free = 1U;
          }
#line 7977
          n2 ++;
        }
#line 7977
        vlist2[n2] = currj;
#line 7977
        n2 ++;
      }
    } else {
#line 7977
      if ((*(coord + prevj))[1] <= (*(coord + prevj))[3]) {
#line 7977
        dy = (double )((*(coord + currj))[1] - (*(coord + prevj))[1]);
#line 7977
        dw = (double )((*(coord + currj))[3] - (*(coord + prevj))[3]);
#line 7977
        t = (GLdouble )((*(coord + prevj))[1] - (*(coord + prevj))[3]) / (dw - dy);
#line 7977
        neww = (GLdouble )(*(coord + prevj))[3] + t * dw;
#line 7977
        (*(coord + VB->Free))[0] = (float )((GLdouble )(*(coord + prevj))[0] + t * (GLdouble )((*(coord + currj))[0] - (*(coord + prevj))[0]));
#line 7977
        (*(coord + VB->Free))[1] = (float )neww;
#line 7977
        (*(coord + VB->Free))[2] = (float )((GLdouble )(*(coord + prevj))[2] + t * (GLdouble )((*(coord + currj))[2] - (*(coord + prevj))[2]));
#line 7977
        (*(coord + VB->Free))[3] = (float )neww;
#line 7977
        if (t > 0.0) {
#line 7977
          if (ctx->ClipMask) {
#line 7977
            interpolate_aux(ctx, VB->Free, (float )t, prevj, currj);
          }
#line 7977
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 7977
          vlist2[n2] = VB->Free;
#line 7977
          (VB->Free) ++;
#line 7977
          if (VB->Free == 504U) {
#line 7977
            VB->Free = 1U;
          }
#line 7977
          n2 ++;
        }
      }
    }
#line 7977
    previ = curri;
#line 7977
    prevj = currj;
#line 7977
    if (n2 >= 503U) {
#line 7977
      if ((unsigned int )(vlist2) == (unsigned int )(vlist2)) {
#line 7977
        i___1 = 0;
#line 7977
        while (i___1 < 504) {
#line 7977
          *(vlist + i___1) = vlist2[i___1];
#line 7977
          i___1 ++;
        }
      }
#line 7977
      return (503U);
    }
#line 7977
    curri ++;
  }
#line 7998
  if (n2 < 3U) {
#line 7998
    return (0U);
  }
#line 7998
  previ = n2 - 1U;
#line 7998
  prevj = vlist2[previ];
#line 7998
  n = 0U;
#line 7998
  curri = 0U;
#line 7998
  while (curri < n2) {
#line 7998
    currj = vlist2[curri];
#line 7998
    if ((*(coord + currj))[1] >= - (*(coord + currj))[3]) {
#line 7998
      if ((*(coord + prevj))[1] >= - (*(coord + prevj))[3]) {
#line 7998
        *(vlist + n) = currj;
#line 7998
        n ++;
      } else {
#line 7998
        dy = (double )((*(coord + prevj))[1] - (*(coord + currj))[1]);
#line 7998
        dw = (double )((*(coord + prevj))[3] - (*(coord + currj))[3]);
#line 7998
        t = (GLdouble )(- ((*(coord + currj))[1] + (*(coord + currj))[3])) / (dw + dy);
#line 7998
        neww = (GLdouble )(*(coord + currj))[3] + t * dw;
#line 7998
        (*(coord + VB->Free))[0] = (float )((GLdouble )(*(coord + currj))[0] + t * (GLdouble )((*(coord + prevj))[0] - (*(coord + currj))[0]));
#line 7998
        (*(coord + VB->Free))[1] = (float )(- neww);
#line 7998
        (*(coord + VB->Free))[2] = (float )((GLdouble )(*(coord + currj))[2] + t * (GLdouble )((*(coord + prevj))[2] - (*(coord + currj))[2]));
#line 7998
        (*(coord + VB->Free))[3] = (float )neww;
#line 7998
        if (t > 0.0) {
#line 7998
          if (ctx->ClipMask) {
#line 7998
            interpolate_aux(ctx, VB->Free, (float )t, currj, prevj);
          }
#line 7998
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 7998
          *(vlist + n) = VB->Free;
#line 7998
          (VB->Free) ++;
#line 7998
          if (VB->Free == 504U) {
#line 7998
            VB->Free = 1U;
          }
#line 7998
          n ++;
        }
#line 7998
        *(vlist + n) = currj;
#line 7998
        n ++;
      }
    } else {
#line 7998
      if ((*(coord + prevj))[1] >= - (*(coord + prevj))[3]) {
#line 7998
        dy = (double )((*(coord + currj))[1] - (*(coord + prevj))[1]);
#line 7998
        dw = (double )((*(coord + currj))[3] - (*(coord + prevj))[3]);
#line 7998
        t = (GLdouble )(- ((*(coord + prevj))[1] + (*(coord + prevj))[3])) / (dw + dy);
#line 7998
        neww = (GLdouble )(*(coord + prevj))[3] + t * dw;
#line 7998
        (*(coord + VB->Free))[0] = (float )((GLdouble )(*(coord + prevj))[0] + t * (GLdouble )((*(coord + currj))[0] - (*(coord + prevj))[0]));
#line 7998
        (*(coord + VB->Free))[1] = (float )(- neww);
#line 7998
        (*(coord + VB->Free))[2] = (float )((GLdouble )(*(coord + prevj))[2] + t * (GLdouble )((*(coord + currj))[2] - (*(coord + prevj))[2]));
#line 7998
        (*(coord + VB->Free))[3] = (float )neww;
#line 7998
        if (t > 0.0) {
#line 7998
          if (ctx->ClipMask) {
#line 7998
            interpolate_aux(ctx, VB->Free, (float )t, prevj, currj);
          }
#line 7998
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 7998
          *(vlist + n) = VB->Free;
#line 7998
          (VB->Free) ++;
#line 7998
          if (VB->Free == 504U) {
#line 7998
            VB->Free = 1U;
          }
#line 7998
          n ++;
        }
      }
    }
#line 7998
    previ = curri;
#line 7998
    prevj = currj;
#line 7998
    if (n >= 503U) {
#line 7998
      if ((unsigned int )vlist == (unsigned int )(vlist2)) {
#line 7998
        i___2 = 0;
#line 7998
        while (i___2 < 504) {
#line 7998
          *(vlist + i___2) = *(vlist + i___2);
#line 7998
          i___2 ++;
        }
      }
#line 7998
      return (503U);
    }
#line 7998
    curri ++;
  }
#line 8019
  if (n < 3U) {
#line 8019
    return (0U);
  }
#line 8019
  previ = n - 1U;
#line 8019
  prevj = *(vlist + previ);
#line 8019
  n2 = 0U;
#line 8019
  curri = 0U;
#line 8019
  while (curri < n) {
#line 8019
    currj = *(vlist + curri);
#line 8019
    if ((*(coord + currj))[2] <= (*(coord + currj))[3]) {
#line 8019
      if ((*(coord + prevj))[2] <= (*(coord + prevj))[3]) {
#line 8019
        vlist2[n2] = currj;
#line 8019
        n2 ++;
      } else {
#line 8019
        dz = (double )((*(coord + prevj))[2] - (*(coord + currj))[2]);
#line 8019
        dw = (double )((*(coord + prevj))[3] - (*(coord + currj))[3]);
#line 8019
        t = (GLdouble )((*(coord + currj))[2] - (*(coord + currj))[3]) / (dw - dz);
#line 8019
        neww = (GLdouble )(*(coord + currj))[3] + t * dw;
#line 8019
        (*(coord + VB->Free))[0] = (float )((GLdouble )(*(coord + currj))[0] + t * (GLdouble )((*(coord + prevj))[0] - (*(coord + currj))[0]));
#line 8019
        (*(coord + VB->Free))[1] = (float )((GLdouble )(*(coord + currj))[1] + t * (GLdouble )((*(coord + prevj))[1] - (*(coord + currj))[1]));
#line 8019
        (*(coord + VB->Free))[2] = (float )neww;
#line 8019
        (*(coord + VB->Free))[3] = (float )neww;
#line 8019
        if (t > 0.0) {
#line 8019
          if (ctx->ClipMask) {
#line 8019
            interpolate_aux(ctx, VB->Free, (float )t, currj, prevj);
          }
#line 8019
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 8019
          vlist2[n2] = VB->Free;
#line 8019
          (VB->Free) ++;
#line 8019
          if (VB->Free == 504U) {
#line 8019
            VB->Free = 1U;
          }
#line 8019
          n2 ++;
        }
#line 8019
        vlist2[n2] = currj;
#line 8019
        n2 ++;
      }
    } else {
#line 8019
      if ((*(coord + prevj))[2] <= (*(coord + prevj))[3]) {
#line 8019
        dz = (double )((*(coord + currj))[2] - (*(coord + prevj))[2]);
#line 8019
        dw = (double )((*(coord + currj))[3] - (*(coord + prevj))[3]);
#line 8019
        t = (GLdouble )((*(coord + prevj))[2] - (*(coord + prevj))[3]) / (dw - dz);
#line 8019
        neww = (GLdouble )(*(coord + prevj))[3] + t * dw;
#line 8019
        (*(coord + VB->Free))[0] = (float )((GLdouble )(*(coord + prevj))[0] + t * (GLdouble )((*(coord + currj))[0] - (*(coord + prevj))[0]));
#line 8019
        (*(coord + VB->Free))[1] = (float )((GLdouble )(*(coord + prevj))[1] + t * (GLdouble )((*(coord + currj))[1] - (*(coord + prevj))[1]));
#line 8019
        (*(coord + VB->Free))[2] = (float )neww;
#line 8019
        (*(coord + VB->Free))[3] = (float )neww;
#line 8019
        if (t > 0.0) {
#line 8019
          if (ctx->ClipMask) {
#line 8019
            interpolate_aux(ctx, VB->Free, (float )t, prevj, currj);
          }
#line 8019
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 8019
          vlist2[n2] = VB->Free;
#line 8019
          (VB->Free) ++;
#line 8019
          if (VB->Free == 504U) {
#line 8019
            VB->Free = 1U;
          }
#line 8019
          n2 ++;
        }
      }
    }
#line 8019
    previ = curri;
#line 8019
    prevj = currj;
#line 8019
    if (n2 >= 503U) {
#line 8019
      if ((unsigned int )(vlist2) == (unsigned int )(vlist2)) {
#line 8019
        i___3 = 0;
#line 8019
        while (i___3 < 504) {
#line 8019
          *(vlist + i___3) = vlist2[i___3];
#line 8019
          i___3 ++;
        }
      }
#line 8019
      return (503U);
    }
#line 8019
    curri ++;
  }
#line 8040
  if (n2 < 3U) {
#line 8040
    return (0U);
  }
#line 8040
  previ = n2 - 1U;
#line 8040
  prevj = vlist2[previ];
#line 8040
  n = 0U;
#line 8040
  curri = 0U;
#line 8040
  while (curri < n2) {
#line 8040
    currj = vlist2[curri];
#line 8040
    if ((*(coord + currj))[2] >= - (*(coord + currj))[3]) {
#line 8040
      if ((*(coord + prevj))[2] >= - (*(coord + prevj))[3]) {
#line 8040
        *(vlist + n) = currj;
#line 8040
        n ++;
      } else {
#line 8040
        dz = (double )((*(coord + prevj))[2] - (*(coord + currj))[2]);
#line 8040
        dw = (double )((*(coord + prevj))[3] - (*(coord + currj))[3]);
#line 8040
        t = (GLdouble )(- ((*(coord + currj))[2] + (*(coord + currj))[3])) / (dw + dz);
#line 8040
        neww = (GLdouble )(*(coord + currj))[3] + t * dw;
#line 8040
        (*(coord + VB->Free))[0] = (float )((GLdouble )(*(coord + currj))[0] + t * (GLdouble )((*(coord + prevj))[0] - (*(coord + currj))[0]));
#line 8040
        (*(coord + VB->Free))[1] = (float )((GLdouble )(*(coord + currj))[1] + t * (GLdouble )((*(coord + prevj))[1] - (*(coord + currj))[1]));
#line 8040
        (*(coord + VB->Free))[2] = (float )(- neww);
#line 8040
        (*(coord + VB->Free))[3] = (float )neww;
#line 8040
        if (t > 0.0) {
#line 8040
          if (ctx->ClipMask) {
#line 8040
            interpolate_aux(ctx, VB->Free, (float )t, currj, prevj);
          }
#line 8040
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 8040
          *(vlist + n) = VB->Free;
#line 8040
          (VB->Free) ++;
#line 8040
          if (VB->Free == 504U) {
#line 8040
            VB->Free = 1U;
          }
#line 8040
          n ++;
        }
#line 8040
        *(vlist + n) = currj;
#line 8040
        n ++;
      }
    } else {
#line 8040
      if ((*(coord + prevj))[2] >= - (*(coord + prevj))[3]) {
#line 8040
        dz = (double )((*(coord + currj))[2] - (*(coord + prevj))[2]);
#line 8040
        dw = (double )((*(coord + currj))[3] - (*(coord + prevj))[3]);
#line 8040
        t = (GLdouble )(- ((*(coord + prevj))[2] + (*(coord + prevj))[3])) / (dw + dz);
#line 8040
        neww = (GLdouble )(*(coord + prevj))[3] + t * dw;
#line 8040
        (*(coord + VB->Free))[0] = (float )((GLdouble )(*(coord + prevj))[0] + t * (GLdouble )((*(coord + currj))[0] - (*(coord + prevj))[0]));
#line 8040
        (*(coord + VB->Free))[1] = (float )((GLdouble )(*(coord + prevj))[1] + t * (GLdouble )((*(coord + currj))[1] - (*(coord + prevj))[1]));
#line 8040
        (*(coord + VB->Free))[2] = (float )(- neww);
#line 8040
        (*(coord + VB->Free))[3] = (float )neww;
#line 8040
        if (t > 0.0) {
#line 8040
          if (ctx->ClipMask) {
#line 8040
            interpolate_aux(ctx, VB->Free, (float )t, prevj, currj);
          }
#line 8040
          VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 8040
          *(vlist + n) = VB->Free;
#line 8040
          (VB->Free) ++;
#line 8040
          if (VB->Free == 504U) {
#line 8040
            VB->Free = 1U;
          }
#line 8040
          n ++;
        }
      }
    }
#line 8040
    previ = curri;
#line 8040
    prevj = currj;
#line 8040
    if (n >= 503U) {
#line 8040
      if ((unsigned int )vlist == (unsigned int )(vlist2)) {
#line 8040
        i___4 = 0;
#line 8040
        while (i___4 < 504) {
#line 8040
          *(vlist + i___4) = *(vlist + i___4);
#line 8040
          i___4 ++;
        }
      }
#line 8040
      return (503U);
    }
#line 8040
    curri ++;
  }
#line 8046
  return (n);
}
}
#line 8050 "D:/a/test/177.c"
GLuint gl_userclip_point(GLcontext *ctx , float const   *v ) 
{ GLuint p ;
  float dot ;

  {
#line 8053
  p = 0U;
#line 8053
  while (p < 6U) {
#line 8054
    if (ctx->Transform.ClipEnabled[p]) {
#line 8055
      dot = (float )(((*(v + 0) * (float const   )ctx->Transform.ClipEquation[p][0] + *(v + 1) * (float const   )ctx->Transform.ClipEquation[p][1]) + *(v + 2) * (float const   )ctx->Transform.ClipEquation[p][2]) + *(v + 3) * (float const   )ctx->Transform.ClipEquation[p][3]);
#line 8059
      if (dot < 0.0F) {
#line 8060
        return (0U);
      }
    }
#line 8053
    p ++;
  }
#line 8064
  return (1U);
}
}
#line 8073 "D:/a/test/177.c"
GLuint gl_userclip_line(GLcontext *ctx , GLuint *i , GLuint *j ) 
{ struct vertex_buffer *VB ;
  GLuint p ;
  GLuint ii ;
  GLuint jj ;
  register float a ;
  register float b ;
  register float c ;
  register float d ;
  float dx ;
  float dy ;
  float dz ;
  float dw ;
  float t ;
  float denom ;
  float dx___0 ;
  float dy___0 ;
  float dz___0 ;
  float dw___0 ;
  float t___0 ;
  float denom___0 ;

  {
#line 8075
  VB = ctx->VB;
#line 8077
  Space = 1U;
#line 8078
  ii = *i;
#line 8079
  jj = *j;
#line 8080
  p = 0U;
#line 8080
  while (p < 6U) {
#line 8081
    if (ctx->Transform.ClipEnabled[p]) {
#line 8083
      a = ctx->Transform.ClipEquation[p][0];
#line 8084
      b = ctx->Transform.ClipEquation[p][1];
#line 8085
      c = ctx->Transform.ClipEquation[p][2];
#line 8086
      d = ctx->Transform.ClipEquation[p][3];
#line 8087
      if (((VB->Eye[ii][0] * a + VB->Eye[ii][1] * b) + VB->Eye[ii][2] * c) + VB->Eye[ii][3] * d < - 0.8e-03F) {
#line 8088
        if (((VB->Eye[jj][0] * a + VB->Eye[jj][1] * b) + VB->Eye[jj][2] * c) + VB->Eye[jj][3] * d < - 0.8e-03F) {
#line 8089
          return (0U);
        } else {
#line 8093
          dx = VB->Eye[ii][0] - VB->Eye[jj][0];
#line 8094
          dy = VB->Eye[ii][1] - VB->Eye[jj][1];
#line 8095
          dz = VB->Eye[ii][2] - VB->Eye[jj][2];
#line 8096
          dw = VB->Eye[ii][3] - VB->Eye[jj][3];
#line 8097
          denom = ((dx * a + dy * b) + dz * c) + dw * d;
#line 8098
          if ((double )denom == 0.0) {
#line 8099
            t = (float )0.0;
          } else {
#line 8102
            t = - (((VB->Eye[jj][0] * a + VB->Eye[jj][1] * b) + VB->Eye[jj][2] * c) + VB->Eye[jj][3] * d) / denom;
#line 8104
            if (t > 1.0F) {
#line 8104
              t = 1.0F;
            }
          }
#line 8106
          VB->Eye[VB->Free][0] = VB->Eye[jj][0] + t * dx;
#line 8107
          VB->Eye[VB->Free][1] = VB->Eye[jj][1] + t * dy;
#line 8108
          VB->Eye[VB->Free][2] = VB->Eye[jj][2] + t * dz;
#line 8109
          VB->Eye[VB->Free][3] = VB->Eye[jj][3] + t * dw;
#line 8111
          if (ctx->ClipMask) {
#line 8112
            interpolate_aux(ctx, VB->Free, t, jj, ii);
          }
#line 8113
          ii = VB->Free;
#line 8114
          (VB->Free) ++;
#line 8115
          if (VB->Free == 504U) {
#line 8115
            VB->Free = 1U;
          }
        }
      } else {
#line 8119
        if (((VB->Eye[jj][0] * a + VB->Eye[jj][1] * b) + VB->Eye[jj][2] * c) + VB->Eye[jj][3] * d < - 0.8e-03F) {
#line 8121
          dx___0 = VB->Eye[jj][0] - VB->Eye[ii][0];
#line 8122
          dy___0 = VB->Eye[jj][1] - VB->Eye[ii][1];
#line 8123
          dz___0 = VB->Eye[jj][2] - VB->Eye[ii][2];
#line 8124
          dw___0 = VB->Eye[jj][3] - VB->Eye[ii][3];
#line 8125
          denom___0 = ((dx___0 * a + dy___0 * b) + dz___0 * c) + dw___0 * d;
#line 8126
          if ((double )denom___0 == 0.0) {
#line 8127
            t___0 = (float )0.0;
          } else {
#line 8130
            t___0 = - (((VB->Eye[ii][0] * a + VB->Eye[ii][1] * b) + VB->Eye[ii][2] * c) + VB->Eye[ii][3] * d) / denom___0;
#line 8132
            if (t___0 > 1.0F) {
#line 8132
              t___0 = 1.0F;
            }
          }
#line 8134
          VB->Eye[VB->Free][0] = VB->Eye[ii][0] + t___0 * dx___0;
#line 8135
          VB->Eye[VB->Free][1] = VB->Eye[ii][1] + t___0 * dy___0;
#line 8136
          VB->Eye[VB->Free][2] = VB->Eye[ii][2] + t___0 * dz___0;
#line 8137
          VB->Eye[VB->Free][3] = VB->Eye[ii][3] + t___0 * dw___0;
#line 8139
          if (ctx->ClipMask) {
#line 8140
            interpolate_aux(ctx, VB->Free, t___0, ii, jj);
          }
#line 8141
          jj = VB->Free;
#line 8142
          (VB->Free) ++;
#line 8143
          if (VB->Free == 504U) {
#line 8143
            VB->Free = 1U;
          }
        }
      }
    }
#line 8080
    p ++;
  }
#line 8150
  *i = ii;
#line 8151
  *j = jj;
#line 8152
  return (1U);
}
}
#line 8154 "D:/a/test/177.c"
GLuint gl_userclip_polygon(GLcontext *ctx , GLuint n , GLuint *vlist ) 
{ struct vertex_buffer *VB ;
  GLuint vlist2[504] ;
  GLuint *inlist ;
  GLuint *outlist ;
  GLuint incount ;
  GLuint outcount ;
  GLuint curri ;
  GLuint currj ;
  GLuint previ ;
  GLuint prevj ;
  GLuint p ;
  register float a ;
  register float b ;
  register float c ;
  register float d ;
  GLuint tmp ;
  float dx ;
  float dy ;
  float dz ;
  float dw ;
  float t ;
  float denom ;
  GLuint tmp___0 ;
  GLuint tmp___1 ;
  float dx___0 ;
  float dy___0 ;
  float dz___0 ;
  float dw___0 ;
  float t___0 ;
  float denom___0 ;
  GLuint tmp___2 ;
  GLuint *tmp___3 ;

  {
#line 8156
  VB = ctx->VB;
#line 8163
  Space = 1U;
#line 8164
  incount = n;
#line 8165
  inlist = vlist;
#line 8166
  outlist = vlist2;
#line 8167
  p = 0U;
#line 8167
  while (p < 6U) {
#line 8168
    if (ctx->Transform.ClipEnabled[p]) {
#line 8169
      a = ctx->Transform.ClipEquation[p][0];
#line 8170
      b = ctx->Transform.ClipEquation[p][1];
#line 8171
      c = ctx->Transform.ClipEquation[p][2];
#line 8172
      d = ctx->Transform.ClipEquation[p][3];
#line 8173
      if (incount < 3U) {
#line 8173
        return (0U);
      }
#line 8175
      previ = incount - 1U;
#line 8176
      prevj = *(inlist + previ);
#line 8177
      outcount = 0U;
#line 8178
      curri = 0U;
#line 8178
      while (curri < incount) {
#line 8179
        currj = *(inlist + curri);
#line 8180
        if (((VB->Eye[currj][0] * a + VB->Eye[currj][1] * b) + VB->Eye[currj][2] * c) + VB->Eye[currj][3] * d >= - 0.8e-03F) {
#line 8181
          if (((VB->Eye[prevj][0] * a + VB->Eye[prevj][1] * b) + VB->Eye[prevj][2] * c) + VB->Eye[prevj][3] * d >= - 0.8e-03F) {
#line 8182
            tmp = outcount;
#line 8182
            outcount ++;
#line 8182
            *(outlist + tmp) = currj;
          } else {
#line 8187
            dx = VB->Eye[prevj][0] - VB->Eye[currj][0];
#line 8188
            dy = VB->Eye[prevj][1] - VB->Eye[currj][1];
#line 8189
            dz = VB->Eye[prevj][2] - VB->Eye[currj][2];
#line 8190
            dw = VB->Eye[prevj][3] - VB->Eye[currj][3];
#line 8191
            denom = ((dx * a + dy * b) + dz * c) + dw * d;
#line 8192
            if ((double )denom == 0.0) {
#line 8193
              t = (float )0.0;
            } else {
#line 8196
              t = - (((VB->Eye[currj][0] * a + VB->Eye[currj][1] * b) + VB->Eye[currj][2] * c) + VB->Eye[currj][3] * d) / denom;
#line 8198
              if (t > 1.0F) {
#line 8199
                t = 1.0F;
              }
            }
#line 8203
            VB->Eye[VB->Free][0] = VB->Eye[currj][0] + t * dx;
#line 8204
            VB->Eye[VB->Free][1] = VB->Eye[currj][1] + t * dy;
#line 8205
            VB->Eye[VB->Free][2] = VB->Eye[currj][2] + t * dz;
#line 8206
            VB->Eye[VB->Free][3] = VB->Eye[currj][3] + t * dw;
#line 8208
            if (ctx->ClipMask) {
#line 8209
              interpolate_aux(ctx, VB->Free, t, currj, prevj);
            }
#line 8211
            VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 8213
            tmp___0 = outcount;
#line 8213
            outcount ++;
#line 8213
            *(outlist + tmp___0) = VB->Free;
#line 8214
            (VB->Free) ++;
#line 8215
            if (VB->Free == 504U) {
#line 8215
              VB->Free = 1U;
            }
#line 8217
            tmp___1 = outcount;
#line 8217
            outcount ++;
#line 8217
            *(outlist + tmp___1) = currj;
          }
        } else {
#line 8221
          if (((VB->Eye[prevj][0] * a + VB->Eye[prevj][1] * b) + VB->Eye[prevj][2] * c) + VB->Eye[prevj][3] * d >= - 0.8e-03F) {
#line 8224
            dx___0 = VB->Eye[currj][0] - VB->Eye[prevj][0];
#line 8225
            dy___0 = VB->Eye[currj][1] - VB->Eye[prevj][1];
#line 8226
            dz___0 = VB->Eye[currj][2] - VB->Eye[prevj][2];
#line 8227
            dw___0 = VB->Eye[currj][3] - VB->Eye[prevj][3];
#line 8228
            denom___0 = ((dx___0 * a + dy___0 * b) + dz___0 * c) + dw___0 * d;
#line 8229
            if ((double )denom___0 == 0.0) {
#line 8230
              t___0 = (float )0.0;
            } else {
#line 8233
              t___0 = - (((VB->Eye[prevj][0] * a + VB->Eye[prevj][1] * b) + VB->Eye[prevj][2] * c) + VB->Eye[prevj][3] * d) / denom___0;
#line 8235
              if (t___0 > 1.0F) {
#line 8236
                t___0 = 1.0F;
              }
            }
#line 8240
            VB->Eye[VB->Free][0] = VB->Eye[prevj][0] + t___0 * dx___0;
#line 8241
            VB->Eye[VB->Free][1] = VB->Eye[prevj][1] + t___0 * dy___0;
#line 8242
            VB->Eye[VB->Free][2] = VB->Eye[prevj][2] + t___0 * dz___0;
#line 8243
            VB->Eye[VB->Free][3] = VB->Eye[prevj][3] + t___0 * dw___0;
#line 8245
            if (ctx->ClipMask) {
#line 8246
              interpolate_aux(ctx, VB->Free, t___0, prevj, currj);
            }
#line 8248
            VB->Edgeflag[VB->Free] = VB->Edgeflag[prevj];
#line 8250
            tmp___2 = outcount;
#line 8250
            outcount ++;
#line 8250
            *(outlist + tmp___2) = VB->Free;
#line 8251
            (VB->Free) ++;
#line 8252
            if (VB->Free == 504U) {
#line 8252
              VB->Free = 1U;
            }
          }
        }
#line 8255
        previ = curri;
#line 8256
        prevj = currj;
#line 8258
        if (outcount >= 503U) {
#line 8259
          if ((unsigned int )outlist != (unsigned int )(vlist2)) {
#line 8260
            memcpy((void *)vlist, (void const   *)((void *)(vlist2)), outcount * sizeof(GLuint ));
          }
#line 8262
          return (503U);
        }
#line 8178
        curri ++;
      }
#line 8267
      tmp___3 = inlist;
#line 8268
      inlist = outlist;
#line 8269
      outlist = tmp___3;
#line 8270
      incount = outcount;
    }
#line 8167
    p ++;
  }
#line 8274
  if ((unsigned int )outlist != (unsigned int )(vlist2)) {
#line 8275
    memcpy((void *)vlist, (void const   *)((void *)(vlist2)), outcount * sizeof(GLuint ));
  }
#line 8277
  return (outcount);
}
}
#line 8284 "D:/a/test/177.c"
static GLboolean power_of_two(GLint k ) 
{ GLint i ;
  GLint m ;

  {
#line 8286
  m = 1;
#line 8287
  i = 0;
#line 8287
  while (i < 32) {
#line 8288
    if (k == m) {
#line 8289
      return ((unsigned char)1);
    }
#line 8290
    m <<= 1;
#line 8287
    i ++;
  }
#line 8292
  return ((unsigned char)0);
}
}
#line 8294 "D:/a/test/177.c"
static GLint decode_internal_format(GLint format ) 
{ 

  {
#line 8296
  switch (format) {
  case 6406: 
  case 32827: 
  case 32828: 
  case 32829: 
  case 32830: 
#line 8302
  return (6406);
  case 1: 
  case 6409: 
  case 32831: 
  case 32832: 
  case 32833: 
  case 32834: 
#line 8309
  return (6409);
  case 2: 
  case 6410: 
  case 32835: 
  case 32836: 
  case 32837: 
  case 32838: 
  case 32839: 
  case 32840: 
#line 8318
  return (6410);
  case 32841: 
  case 32842: 
  case 32843: 
  case 32844: 
  case 32845: 
#line 8324
  return (32841);
  case 3: 
  case 6407: 
  case 10768: 
  case 32847: 
  case 32848: 
  case 32849: 
  case 32850: 
  case 32851: 
  case 32852: 
#line 8334
  return (6407);
  case 4: 
  case 6408: 
  case 32853: 
  case 32854: 
  case 32855: 
  case 32856: 
  case 32857: 
  case 32858: 
  case 32859: 
#line 8344
  return (6408);
  default: ;
#line 8346
  return (-1);
  }
}
}
#line 8349 "D:/a/test/177.c"
void gl_ColorTable(GLcontext *ctx , GLenum target , GLenum internalFormat , struct gl_image *table ) 
{ struct gl_texture_object *texObj ;
  GLboolean proxy ;
  GLboolean tmp ;

  {
#line 8353
  proxy = (GLboolean )0;
#line 8354
  if (ctx->Primitive != 6656) {
#line 8355
    gl_error(ctx, 1282, "glGetBooleanv");
#line 8356
    return;
  }
#line 8358
  switch (target) {
  case 3552: 
#line 8360
  texObj = ctx->Texture.Current1D;
#line 8361
  break;
  case 3553: 
#line 8363
  texObj = ctx->Texture.Current2D;
#line 8364
  break;
  case 32879: 
#line 8366
  texObj = ctx->Texture.Current3D;
#line 8367
  break;
  case 32867: 
#line 8369
  texObj = ctx->Texture.Proxy1D;
#line 8370
  proxy = (unsigned char)1;
#line 8371
  break;
  case 32868: 
#line 8373
  texObj = ctx->Texture.Proxy2D;
#line 8374
  proxy = (unsigned char)1;
#line 8375
  break;
  case 32880: 
#line 8377
  texObj = ctx->Texture.Proxy3D;
#line 8378
  proxy = (unsigned char)1;
#line 8379
  break;
  case 33275: 
#line 8381
  texObj = (struct gl_texture_object *)((void *)0);
#line 8382
  break;
  default: 
#line 8384
  gl_error(ctx, 1280, "glColorTableEXT(target)");
#line 8385
  return;
  }
#line 8387
  if (table->Width < 1) {
    goto _L;
  } else {
#line 8387
    if (table->Width > 256) {
      goto _L;
    } else {
#line 8387
      tmp = power_of_two(table->Width);
#line 8387
      if (! tmp) {
        _L: /* CIL Label */ 
#line 8389
        gl_error(ctx, 1281, "glColorTableEXT(width)");
#line 8390
        if (proxy) {
#line 8391
          texObj->PaletteSize = 0U;
#line 8392
          texObj->PaletteIntFormat = 0;
#line 8393
          texObj->PaletteFormat = 0;
        }
#line 8395
        return;
      }
    }
  }
#line 8397
  if (texObj) {
#line 8398
    texObj->PaletteSize = (unsigned int )table->Width;
#line 8399
    texObj->PaletteIntFormat = internalFormat;
#line 8400
    texObj->PaletteFormat = decode_internal_format(internalFormat);
#line 8401
    if (! proxy) {
#line 8402
      memcpy((void *)(texObj->Palette), (void const   *)table->Data, (unsigned int )(table->Width * table->Components));
#line 8403
      if (ctx->Driver.UpdateTexturePalette) {
#line 8404
        (*(ctx->Driver.UpdateTexturePalette))(ctx, texObj);
      }
    }
  } else {
#line 8409
    ctx->Texture.PaletteSize = (unsigned int )table->Width;
#line 8410
    ctx->Texture.PaletteIntFormat = internalFormat;
#line 8411
    ctx->Texture.PaletteFormat = decode_internal_format(internalFormat);
#line 8412
    memcpy((void *)(ctx->Texture.Palette), (void const   *)table->Data, (unsigned int )(table->Width * table->Components));
#line 8413
    if (ctx->Driver.UpdateTexturePalette) {
#line 8414
      (*(ctx->Driver.UpdateTexturePalette))(ctx, (struct gl_texture_object *)((void *)0));
    }
  }
#line 8417
  return;
}
}
#line 8418 "D:/a/test/177.c"
void gl_ColorSubTable(GLcontext *ctx , GLenum target , GLsizei start , struct gl_image *data ) 
{ 

  {
#line 8421
  gl_problem(ctx, "glColorSubTableEXT not implemented");
#line 8422
  return;
}
}
#line 8423 "D:/a/test/177.c"
void gl_GetColorTable(GLcontext *ctx , GLenum target , GLenum format , GLenum type ,
                      GLvoid *table ) 
{ 

  {
#line 8426
  if (ctx->Primitive != 6656) {
#line 8427
    gl_error(ctx, 1282, "glGetBooleanv");
#line 8428
    return;
  }
#line 8430
  switch (target) {
  case 3552: 
#line 8432
  break;
  case 3553: 
#line 8434
  break;
  case 32879: 
#line 8436
  break;
  case 33275: 
#line 8438
  break;
  default: 
#line 8440
  gl_error(ctx, 1280, "glGetColorTableEXT(target)");
#line 8441
  return;
  }
#line 8443
  gl_problem(ctx, "glGetColorTableEXT not implemented!");
#line 8444
  return;
}
}
#line 8449
void gl_GetColorTableParameteriv(GLcontext *ctx , GLenum target , GLenum pname , GLint *params ) ;
#line 8445 "D:/a/test/177.c"
void gl_GetColorTableParameterfv(GLcontext *ctx , GLenum target , GLenum pname , float *params ) 
{ GLint iparams[10] ;

  {
#line 8449
  gl_GetColorTableParameteriv(ctx, target, pname, iparams);
#line 8450
  *params = (float )iparams[0];
#line 8451
  return;
}
}
#line 8452 "D:/a/test/177.c"
void gl_GetColorTableParameteriv(GLcontext *ctx , GLenum target , GLenum pname , GLint *params ) 
{ struct gl_texture_object *texObj ;

  {
#line 8456
  if (ctx->Primitive != 6656) {
#line 8457
    gl_error(ctx, 1282, "glGetColorTableParameter");
#line 8458
    return;
  }
#line 8460
  switch (target) {
  case 3552: 
#line 8462
  texObj = ctx->Texture.Current1D;
#line 8463
  break;
  case 3553: 
#line 8465
  texObj = ctx->Texture.Current2D;
#line 8466
  break;
  case 32879: 
#line 8468
  texObj = ctx->Texture.Current3D;
#line 8469
  break;
  case 33275: 
#line 8471
  texObj = (struct gl_texture_object *)((void *)0);
#line 8472
  break;
  default: 
#line 8474
  gl_error(ctx, 1280, "glGetColorTableParameter(target)");
#line 8475
  return;
  }
#line 8477
  switch (pname) {
  case 32984: 
#line 8479
  if (texObj) {
#line 8480
    *params = texObj->PaletteIntFormat;
  } else {
#line 8482
    *params = ctx->Texture.PaletteIntFormat;
  }
#line 8483
  break;
  case 32985: 
#line 8485
  if (texObj) {
#line 8486
    *params = (int )texObj->PaletteSize;
  } else {
#line 8488
    *params = (int )ctx->Texture.PaletteSize;
  }
#line 8489
  break;
  case 32986: 
#line 8491
  *params = 8;
#line 8492
  break;
  case 32987: 
#line 8494
  *params = 8;
#line 8495
  break;
  case 32988: 
#line 8497
  *params = 8;
#line 8498
  break;
  case 32989: 
#line 8500
  *params = 8;
#line 8501
  break;
  case 32990: 
#line 8503
  *params = 8;
#line 8504
  break;
  case 32991: 
#line 8506
  *params = 8;
#line 8507
  break;
  default: 
#line 8509
  gl_error(ctx, 1280, "glGetColorTableParameter");
#line 8510
  return;
  }
#line 8512
  return;
}
}
#line 8555 "D:/a/test/177.c"
GLcontext *CC  =    (GLcontext *)((void *)0);
#line 8683
struct HashTable *NewHashTable(void) ;
#line 8685
struct gl_texture_object *gl_alloc_texture_object(struct gl_shared_state *shared ,
                                                  GLuint name , GLuint dimensions ) ;
#line 8691
void DeleteHashTable(struct HashTable *table ) ;
#line 8695
void gl_free_texture_object(struct gl_shared_state *shared , struct gl_texture_object *t ) ;
#line 8677 "D:/a/test/177.c"
static struct gl_shared_state *alloc_shared_state(void) 
{ struct gl_shared_state *ss ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 8680
  tmp = calloc(1U, sizeof(struct gl_shared_state ));
#line 8680
  ss = (struct gl_shared_state *)tmp;
#line 8681
  if (! ss) {
#line 8682
    return ((struct gl_shared_state *)((void *)0));
  }
#line 8683
  tmp___0 = (int )NewHashTable();
#line 8683
  ss->DisplayList = (struct HashTable *)tmp___0;
#line 8684
  tmp___1 = (int )NewHashTable();
#line 8684
  ss->TexObjects = (struct HashTable *)tmp___1;
#line 8685
  tmp___2 = (int )gl_alloc_texture_object(ss, 0, 1);
#line 8685
  ss->Default1D = (struct gl_texture_object *)tmp___2;
#line 8686
  tmp___3 = (int )gl_alloc_texture_object(ss, 0, 2);
#line 8686
  ss->Default2D = (struct gl_texture_object *)tmp___3;
#line 8687
  tmp___4 = (int )gl_alloc_texture_object(ss, 0, 3);
#line 8687
  ss->Default3D = (struct gl_texture_object *)tmp___4;
#line 8688
  if (! ss->DisplayList) {
    goto _L;
  } else {
#line 8688
    if (! ss->TexObjects) {
      goto _L;
    } else {
#line 8688
      if (! ss->Default1D) {
        goto _L;
      } else {
#line 8688
        if (! ss->Default2D) {
          goto _L;
        } else {
#line 8688
          if (! ss->Default3D) {
            _L: /* CIL Label */ 
#line 8690
            if (! ss->DisplayList) {
#line 8691
              DeleteHashTable(ss->DisplayList);
            }
#line 8692
            if (! ss->TexObjects) {
#line 8693
              DeleteHashTable(ss->TexObjects);
            }
#line 8694
            if (! ss->Default1D) {
#line 8695
              gl_free_texture_object(ss, ss->Default1D);
            }
#line 8696
            if (! ss->Default2D) {
#line 8697
              gl_free_texture_object(ss, ss->Default2D);
            }
#line 8698
            if (! ss->Default3D) {
#line 8699
              gl_free_texture_object(ss, ss->Default3D);
            }
#line 8700
            free((void *)ss);
#line 8701
            return ((struct gl_shared_state *)((void *)0));
          } else {
#line 8704
            return (ss);
          }
        }
      }
    }
  }
}
}
#line 8710
GLuint HashFirstEntry(struct HashTable  const  *table ) ;
#line 8712
void gl_destroy_list(GLcontext *ctx , GLuint list ) ;
#line 8707 "D:/a/test/177.c"
static void free_shared_state(GLcontext *ctx , struct gl_shared_state *ss ) 
{ GLuint list ;
  int tmp ;

  {
#line 8709
  while (1) {
#line 8710
    tmp = (int )HashFirstEntry(ss->DisplayList);
#line 8710
    list = (GLuint )tmp;
#line 8711
    if (list) {
#line 8712
      gl_destroy_list(ctx, list);
    } else {
#line 8715
      break;
    }
  }
#line 8718
  DeleteHashTable(ss->DisplayList);
#line 8719
  while (ss->TexObjectList) {
#line 8721
    gl_free_texture_object(ss, ss->TexObjectList);
  }
#line 8723
  DeleteHashTable(ss->TexObjects);
#line 8724
  free((void *)ss);
#line 8725
  return;
}
}
#line 8740
void gl_compute_spot_exp_table(struct gl_light *l ) ;
#line 8726 "D:/a/test/177.c"
static void init_light(struct gl_light *l , GLuint n ) 
{ 

  {
#line 8728
  l->Ambient[0] = (float )0.0;
#line 8728
  l->Ambient[1] = (float )0.0;
#line 8728
  l->Ambient[2] = (float )0.0;
#line 8728
  l->Ambient[3] = (float )1.0;
#line 8729
  if (n == 0U) {
#line 8730
    l->Diffuse[0] = (float )1.0;
#line 8730
    l->Diffuse[1] = (float )1.0;
#line 8730
    l->Diffuse[2] = (float )1.0;
#line 8730
    l->Diffuse[3] = (float )1.0;
#line 8731
    l->Specular[0] = (float )1.0;
#line 8731
    l->Specular[1] = (float )1.0;
#line 8731
    l->Specular[2] = (float )1.0;
#line 8731
    l->Specular[3] = (float )1.0;
  } else {
#line 8734
    l->Diffuse[0] = (float )0.0;
#line 8734
    l->Diffuse[1] = (float )0.0;
#line 8734
    l->Diffuse[2] = (float )0.0;
#line 8734
    l->Diffuse[3] = (float )1.0;
#line 8735
    l->Specular[0] = (float )0.0;
#line 8735
    l->Specular[1] = (float )0.0;
#line 8735
    l->Specular[2] = (float )0.0;
#line 8735
    l->Specular[3] = (float )1.0;
  }
#line 8737
  l->Position[0] = (float )0.0;
#line 8737
  l->Position[1] = (float )0.0;
#line 8737
  l->Position[2] = (float )1.0;
#line 8737
  l->Position[3] = (float )0.0;
#line 8738
  l->Direction[0] = (float )0.0;
#line 8738
  l->Direction[1] = (float )0.0;
#line 8738
  l->Direction[2] = (float )(- 1.0);
#line 8739
  l->SpotExponent = (float )0.0;
#line 8740
  gl_compute_spot_exp_table(l);
#line 8741
  l->SpotCutoff = (float )180.0;
#line 8742
  l->CosCutoff = (float )(- 1.0);
#line 8743
  l->ConstantAttenuation = (float )1.0;
#line 8744
  l->LinearAttenuation = (float )0.0;
#line 8745
  l->QuadraticAttenuation = (float )0.0;
#line 8746
  l->Enabled = (unsigned char)0;
#line 8747
  return;
}
}
#line 8748 "D:/a/test/177.c"
static void init_lightmodel(struct gl_lightmodel *lm ) 
{ 

  {
#line 8750
  lm->Ambient[0] = (float )0.2;
#line 8750
  lm->Ambient[1] = (float )0.2;
#line 8750
  lm->Ambient[2] = (float )0.2;
#line 8750
  lm->Ambient[3] = (float )1.0;
#line 8751
  lm->LocalViewer = (unsigned char)0;
#line 8752
  lm->TwoSide = (unsigned char)0;
#line 8753
  return;
}
}
#line 8764
void gl_compute_material_shine_table(struct gl_material *m ) ;
#line 8754 "D:/a/test/177.c"
static void init_material(struct gl_material *m ) 
{ 

  {
#line 8756
  m->Ambient[0] = (float )0.2;
#line 8756
  m->Ambient[1] = (float )0.2;
#line 8756
  m->Ambient[2] = (float )0.2;
#line 8756
  m->Ambient[3] = (float )1.0;
#line 8757
  m->Diffuse[0] = (float )0.8;
#line 8757
  m->Diffuse[1] = (float )0.8;
#line 8757
  m->Diffuse[2] = (float )0.8;
#line 8757
  m->Diffuse[3] = (float )1.0;
#line 8758
  m->Specular[0] = (float )0.0;
#line 8758
  m->Specular[1] = (float )0.0;
#line 8758
  m->Specular[2] = (float )0.0;
#line 8758
  m->Specular[3] = (float )1.0;
#line 8759
  m->Emission[0] = (float )0.0;
#line 8759
  m->Emission[1] = (float )0.0;
#line 8759
  m->Emission[2] = (float )0.0;
#line 8759
  m->Emission[3] = (float )1.0;
#line 8760
  m->Shininess = (float )0.0;
#line 8761
  m->AmbientIndex = (float )0;
#line 8762
  m->DiffuseIndex = (float )1;
#line 8763
  m->SpecularIndex = (float )1;
#line 8764
  gl_compute_material_shine_table(m);
#line 8765
  return;
}
}
#line 8768
static void initialize_context(GLcontext *ctx ) ;
#line 8768 "D:/a/test/177.c"
static float identity[16]  = 
#line 8768
  {      (float )1.0,      (float )0.0,      (float )0.0,      (float )0.0, 
        (float )0.0,      (float )1.0,      (float )0.0,      (float )0.0, 
        (float )0.0,      (float )0.0,      (float )1.0,      (float )0.0, 
        (float )0.0,      (float )0.0,      (float )0.0,      (float )1.0};
#line 8878
GLuint gl_material_bitmask(GLenum face , GLenum pname ) ;
#line 8766 "D:/a/test/177.c"
static void initialize_context(GLcontext *ctx ) 
{ GLuint i ;
  int tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  struct _reent *tmp___5 ;
  char *tmp___6 ;

  {
#line 8775
  if (ctx) {
#line 8776
    ctx->NewModelViewMatrix = (unsigned char)0;
#line 8777
    ctx->ModelViewMatrixType = 1U;
#line 8778
    memcpy((void *)(ctx->ModelViewMatrix), (void const   *)((void *)(identity)), 16U * sizeof(float ));
#line 8779
    memcpy((void *)(ctx->ModelViewInv), (void const   *)((void *)(identity)), 16U * sizeof(float ));
#line 8780
    ctx->ModelViewStackDepth = 0U;
#line 8781
    ctx->NewProjectionMatrix = (unsigned char)0;
#line 8782
    ctx->ProjectionMatrixType = 1U;
#line 8783
    memcpy((void *)(ctx->ProjectionMatrix), (void const   *)((void *)(identity)),
           16U * sizeof(float ));
#line 8784
    ctx->ProjectionStackDepth = 0U;
#line 8785
    ctx->NearFarStack[0][0] = (float )1.0;
#line 8786
    ctx->NearFarStack[0][1] = (float )0.0;
#line 8787
    ctx->NewTextureMatrix = (unsigned char)0;
#line 8788
    ctx->TextureMatrixType = 1U;
#line 8789
    memcpy((void *)(ctx->TextureMatrix), (void const   *)((void *)(identity)), 16U * sizeof(float ));
#line 8790
    ctx->TextureStackDepth = 0U;
#line 8791
    ctx->Accum.ClearColor[0] = (float )0.0;
#line 8791
    ctx->Accum.ClearColor[1] = (float )0.0;
#line 8791
    ctx->Accum.ClearColor[2] = (float )0.0;
#line 8791
    ctx->Accum.ClearColor[3] = (float )0.0;
#line 8792
    ctx->Color.IndexMask = 4294967295U;
#line 8793
    ctx->Color.ColorMask = 15U;
#line 8794
    ctx->Color.SWmasking = (unsigned char)0;
#line 8795
    ctx->Color.ClearIndex = 0U;
#line 8796
    ctx->Color.ClearColor[0] = (float )0.0;
#line 8796
    ctx->Color.ClearColor[1] = (float )0.0;
#line 8796
    ctx->Color.ClearColor[2] = (float )0.0;
#line 8796
    ctx->Color.ClearColor[3] = (float )0.0;
#line 8797
    ctx->Color.DrawBuffer = 1028;
#line 8798
    ctx->Color.AlphaEnabled = (unsigned char)0;
#line 8799
    ctx->Color.AlphaFunc = 519;
#line 8800
    ctx->Color.AlphaRef = (float )0.0;
#line 8801
    ctx->Color.AlphaRefUbyte = (unsigned char)0;
#line 8802
    ctx->Color.BlendEnabled = (unsigned char)0;
#line 8803
    ctx->Color.BlendSrc = 1;
#line 8804
    ctx->Color.BlendDst = 0;
#line 8805
    ctx->Color.BlendEquation = 32774;
#line 8806
    ctx->Color.BlendColor[0] = (float )0.0;
#line 8806
    ctx->Color.BlendColor[1] = (float )0.0;
#line 8806
    ctx->Color.BlendColor[2] = (float )0.0;
#line 8806
    ctx->Color.BlendColor[3] = (float )0.0;
#line 8807
    ctx->Color.IndexLogicOpEnabled = (unsigned char)0;
#line 8808
    ctx->Color.ColorLogicOpEnabled = (unsigned char)0;
#line 8809
    ctx->Color.SWLogicOpEnabled = (unsigned char)0;
#line 8810
    ctx->Color.LogicOp = 5379;
#line 8811
    ctx->Color.DitherFlag = (unsigned char)1;
#line 8812
    ctx->Current.Index = 1U;
#line 8813
    ctx->Current.Normal[0] = (float )0.0;
#line 8813
    ctx->Current.Normal[1] = (float )0.0;
#line 8813
    ctx->Current.Normal[2] = (float )1.0;
#line 8814
    ctx->Current.ByteColor[0] = (unsigned char )((int )(ctx->Visual)->RedScale);
#line 8815
    ctx->Current.ByteColor[1] = (unsigned char )((int )(ctx->Visual)->GreenScale);
#line 8816
    ctx->Current.ByteColor[2] = (unsigned char )((int )(ctx->Visual)->BlueScale);
#line 8817
    ctx->Current.ByteColor[3] = (unsigned char )((int )(ctx->Visual)->AlphaScale);
#line 8818
    ctx->Current.RasterPos[0] = (float )0.0;
#line 8818
    ctx->Current.RasterPos[1] = (float )0.0;
#line 8818
    ctx->Current.RasterPos[2] = (float )0.0;
#line 8818
    ctx->Current.RasterPos[3] = (float )1.0;
#line 8819
    ctx->Current.RasterPosValid = (unsigned char)1;
#line 8820
    ctx->Current.RasterIndex = 1U;
#line 8821
    ctx->Current.TexCoord[0] = (float )0.0;
#line 8821
    ctx->Current.TexCoord[1] = (float )0.0;
#line 8821
    ctx->Current.TexCoord[2] = (float )0.0;
#line 8821
    ctx->Current.TexCoord[3] = (float )1.0;
#line 8822
    ctx->Current.RasterColor[0] = (float )1.0;
#line 8822
    ctx->Current.RasterColor[1] = (float )1.0;
#line 8822
    ctx->Current.RasterColor[2] = (float )1.0;
#line 8822
    ctx->Current.RasterColor[3] = (float )1.0;
#line 8823
    ctx->Current.EdgeFlag = (unsigned char)1;
#line 8824
    ctx->Depth.Test = (unsigned char)0;
#line 8825
    ctx->Depth.Clear = (float )1.0;
#line 8826
    ctx->Depth.Func = 513;
#line 8827
    ctx->Depth.Mask = (unsigned char)1;
#line 8828
    ctx->Eval.Map1Color4 = (unsigned char)0;
#line 8829
    ctx->Eval.Map1Index = (unsigned char)0;
#line 8830
    ctx->Eval.Map1Normal = (unsigned char)0;
#line 8831
    ctx->Eval.Map1TextureCoord1 = (unsigned char)0;
#line 8832
    ctx->Eval.Map1TextureCoord2 = (unsigned char)0;
#line 8833
    ctx->Eval.Map1TextureCoord3 = (unsigned char)0;
#line 8834
    ctx->Eval.Map1TextureCoord4 = (unsigned char)0;
#line 8835
    ctx->Eval.Map1Vertex3 = (unsigned char)0;
#line 8836
    ctx->Eval.Map1Vertex4 = (unsigned char)0;
#line 8837
    ctx->Eval.Map2Color4 = (unsigned char)0;
#line 8838
    ctx->Eval.Map2Index = (unsigned char)0;
#line 8839
    ctx->Eval.Map2Normal = (unsigned char)0;
#line 8840
    ctx->Eval.Map2TextureCoord1 = (unsigned char)0;
#line 8841
    ctx->Eval.Map2TextureCoord2 = (unsigned char)0;
#line 8842
    ctx->Eval.Map2TextureCoord3 = (unsigned char)0;
#line 8843
    ctx->Eval.Map2TextureCoord4 = (unsigned char)0;
#line 8844
    ctx->Eval.Map2Vertex3 = (unsigned char)0;
#line 8845
    ctx->Eval.Map2Vertex4 = (unsigned char)0;
#line 8846
    ctx->Eval.AutoNormal = (unsigned char)0;
#line 8847
    ctx->Eval.MapGrid1un = 1U;
#line 8848
    ctx->Eval.MapGrid1u1 = (float )0.0;
#line 8849
    ctx->Eval.MapGrid1u2 = (float )1.0;
#line 8850
    ctx->Eval.MapGrid2un = 1U;
#line 8851
    ctx->Eval.MapGrid2vn = 1U;
#line 8852
    ctx->Eval.MapGrid2u1 = (float )0.0;
#line 8853
    ctx->Eval.MapGrid2u2 = (float )1.0;
#line 8854
    ctx->Eval.MapGrid2v1 = (float )0.0;
#line 8855
    ctx->Eval.MapGrid2v2 = (float )1.0;
#line 8856
    ctx->Fog.Enabled = (unsigned char)0;
#line 8857
    ctx->Fog.Mode = 2048;
#line 8858
    ctx->Fog.Color[0] = (float )0.0;
#line 8858
    ctx->Fog.Color[1] = (float )0.0;
#line 8858
    ctx->Fog.Color[2] = (float )0.0;
#line 8858
    ctx->Fog.Color[3] = (float )0.0;
#line 8859
    ctx->Fog.Index = (float )0.0;
#line 8860
    ctx->Fog.Density = (float )1.0;
#line 8861
    ctx->Fog.Start = (float )0.0;
#line 8862
    ctx->Fog.End = (float )1.0;
#line 8863
    ctx->Hint.PerspectiveCorrection = 4352;
#line 8864
    ctx->Hint.PointSmooth = 4352;
#line 8865
    ctx->Hint.LineSmooth = 4352;
#line 8866
    ctx->Hint.PolygonSmooth = 4352;
#line 8867
    ctx->Hint.Fog = 4352;
#line 8868
    i = 0U;
#line 8868
    while (i < 8U) {
#line 8869
      init_light(& ctx->Light.Light[i], i);
#line 8868
      i ++;
    }
#line 8871
    init_lightmodel(& ctx->Light.Model);
#line 8872
    init_material(& ctx->Light.Material[0]);
#line 8873
    init_material(& ctx->Light.Material[1]);
#line 8874
    ctx->Light.ShadeModel = 7425;
#line 8875
    ctx->Light.Enabled = (unsigned char)0;
#line 8876
    ctx->Light.ColorMaterialFace = 1032;
#line 8877
    ctx->Light.ColorMaterialMode = 5634;
#line 8878
    tmp = (int )gl_material_bitmask(1032, 5634);
#line 8878
    ctx->Light.ColorMaterialBitmask = (unsigned int )tmp;
#line 8880
    ctx->Light.ColorMaterialEnabled = (unsigned char)0;
#line 8881
    ctx->Line.SmoothFlag = (unsigned char)0;
#line 8882
    ctx->Line.StippleFlag = (unsigned char)0;
#line 8883
    ctx->Line.Width = (float )1.0;
#line 8884
    ctx->Line.StipplePattern = (unsigned short)65535;
#line 8885
    ctx->Line.StippleFactor = 1;
#line 8886
    ctx->List.ListBase = 0U;
#line 8887
    ctx->Pixel.RedBias = (float )0.0;
#line 8888
    ctx->Pixel.RedScale = (float )1.0;
#line 8889
    ctx->Pixel.GreenBias = (float )0.0;
#line 8890
    ctx->Pixel.GreenScale = (float )1.0;
#line 8891
    ctx->Pixel.BlueBias = (float )0.0;
#line 8892
    ctx->Pixel.BlueScale = (float )1.0;
#line 8893
    ctx->Pixel.AlphaBias = (float )0.0;
#line 8894
    ctx->Pixel.AlphaScale = (float )1.0;
#line 8895
    ctx->Pixel.DepthBias = (float )0.0;
#line 8896
    ctx->Pixel.DepthScale = (float )1.0;
#line 8897
    ctx->Pixel.IndexOffset = 0;
#line 8898
    ctx->Pixel.IndexShift = 0;
#line 8899
    ctx->Pixel.ZoomX = (float )1.0;
#line 8900
    ctx->Pixel.ZoomY = (float )1.0;
#line 8901
    ctx->Pixel.MapColorFlag = (unsigned char)0;
#line 8902
    ctx->Pixel.MapStencilFlag = (unsigned char)0;
#line 8903
    ctx->Pixel.MapStoSsize = 1;
#line 8904
    ctx->Pixel.MapItoIsize = 1;
#line 8905
    ctx->Pixel.MapItoRsize = 1;
#line 8906
    ctx->Pixel.MapItoGsize = 1;
#line 8907
    ctx->Pixel.MapItoBsize = 1;
#line 8908
    ctx->Pixel.MapItoAsize = 1;
#line 8909
    ctx->Pixel.MapRtoRsize = 1;
#line 8910
    ctx->Pixel.MapGtoGsize = 1;
#line 8911
    ctx->Pixel.MapBtoBsize = 1;
#line 8912
    ctx->Pixel.MapAtoAsize = 1;
#line 8913
    ctx->Pixel.MapStoS[0] = 0;
#line 8914
    ctx->Pixel.MapItoI[0] = 0;
#line 8915
    ctx->Pixel.MapItoR[0] = (float )0.0;
#line 8916
    ctx->Pixel.MapItoG[0] = (float )0.0;
#line 8917
    ctx->Pixel.MapItoB[0] = (float )0.0;
#line 8918
    ctx->Pixel.MapItoA[0] = (float )0.0;
#line 8919
    ctx->Pixel.MapRtoR[0] = (float )0.0;
#line 8920
    ctx->Pixel.MapGtoG[0] = (float )0.0;
#line 8921
    ctx->Pixel.MapBtoB[0] = (float )0.0;
#line 8922
    ctx->Pixel.MapAtoA[0] = (float )0.0;
#line 8923
    ctx->Point.SmoothFlag = (unsigned char)0;
#line 8924
    ctx->Point.Size = (float )1.0;
#line 8925
    ctx->Point.Params[0] = (float )1.0;
#line 8926
    ctx->Point.Params[1] = (float )0.0;
#line 8927
    ctx->Point.Params[2] = (float )0.0;
#line 8928
    ctx->Point.MinSize = (float )0.0;
#line 8929
    ctx->Point.MaxSize = (float )10.0;
#line 8930
    ctx->Point.Threshold = (float )1.0;
#line 8931
    ctx->Polygon.CullFlag = (unsigned char)0;
#line 8932
    ctx->Polygon.CullFaceMode = 1029;
#line 8933
    ctx->Polygon.FrontFace = 2305;
#line 8934
    ctx->Polygon.FrontMode = 6914;
#line 8935
    ctx->Polygon.BackMode = 6914;
#line 8936
    ctx->Polygon.Unfilled = (unsigned char)0;
#line 8937
    ctx->Polygon.SmoothFlag = (unsigned char)0;
#line 8938
    ctx->Polygon.StippleFlag = (unsigned char)0;
#line 8939
    ctx->Polygon.OffsetFactor = 0.0F;
#line 8940
    ctx->Polygon.OffsetUnits = 0.0F;
#line 8941
    ctx->Polygon.OffsetPoint = (unsigned char)0;
#line 8942
    ctx->Polygon.OffsetLine = (unsigned char)0;
#line 8943
    ctx->Polygon.OffsetFill = (unsigned char)0;
#line 8944
    ctx->Polygon.OffsetAny = (unsigned char)0;
#line 8945
    memset((void *)(ctx->PolygonStipple), 255, 32U * sizeof(GLuint ));
#line 8946
    ctx->Scissor.Enabled = (unsigned char)0;
#line 8947
    ctx->Scissor.X = 0;
#line 8948
    ctx->Scissor.Y = 0;
#line 8949
    ctx->Scissor.Width = 0;
#line 8950
    ctx->Scissor.Height = 0;
#line 8951
    ctx->Stencil.Enabled = (unsigned char)0;
#line 8952
    ctx->Stencil.Function = 519;
#line 8953
    ctx->Stencil.FailFunc = 7680;
#line 8954
    ctx->Stencil.ZPassFunc = 7680;
#line 8955
    ctx->Stencil.ZFailFunc = 7680;
#line 8956
    ctx->Stencil.Ref = (unsigned char)0;
#line 8957
    ctx->Stencil.ValueMask = (unsigned char)255;
#line 8958
    ctx->Stencil.Clear = (unsigned char)0;
#line 8959
    ctx->Stencil.WriteMask = (unsigned char)255;
#line 8960
    ctx->Texture.Enabled = 0U;
#line 8961
    ctx->Texture.EnvMode = 8448;
#line 8962
    ctx->Texture.EnvColor[0] = (float )0.0;
#line 8962
    ctx->Texture.EnvColor[1] = (float )0.0;
#line 8962
    ctx->Texture.EnvColor[2] = (float )0.0;
#line 8962
    ctx->Texture.EnvColor[3] = (float )0.0;
#line 8963
    ctx->Texture.TexGenEnabled = 0U;
#line 8964
    ctx->Texture.GenModeS = 9216;
#line 8965
    ctx->Texture.GenModeT = 9216;
#line 8966
    ctx->Texture.GenModeR = 9216;
#line 8967
    ctx->Texture.GenModeQ = 9216;
#line 8968
    ctx->Texture.ObjectPlaneS[0] = (float )1.0;
#line 8968
    ctx->Texture.ObjectPlaneS[1] = (float )0.0;
#line 8968
    ctx->Texture.ObjectPlaneS[2] = (float )0.0;
#line 8968
    ctx->Texture.ObjectPlaneS[3] = (float )0.0;
#line 8969
    ctx->Texture.ObjectPlaneT[0] = (float )0.0;
#line 8969
    ctx->Texture.ObjectPlaneT[1] = (float )1.0;
#line 8969
    ctx->Texture.ObjectPlaneT[2] = (float )0.0;
#line 8969
    ctx->Texture.ObjectPlaneT[3] = (float )0.0;
#line 8970
    ctx->Texture.ObjectPlaneR[0] = (float )0.0;
#line 8970
    ctx->Texture.ObjectPlaneR[1] = (float )0.0;
#line 8970
    ctx->Texture.ObjectPlaneR[2] = (float )0.0;
#line 8970
    ctx->Texture.ObjectPlaneR[3] = (float )0.0;
#line 8971
    ctx->Texture.ObjectPlaneQ[0] = (float )0.0;
#line 8971
    ctx->Texture.ObjectPlaneQ[1] = (float )0.0;
#line 8971
    ctx->Texture.ObjectPlaneQ[2] = (float )0.0;
#line 8971
    ctx->Texture.ObjectPlaneQ[3] = (float )0.0;
#line 8972
    ctx->Texture.EyePlaneS[0] = (float )1.0;
#line 8972
    ctx->Texture.EyePlaneS[1] = (float )0.0;
#line 8972
    ctx->Texture.EyePlaneS[2] = (float )0.0;
#line 8972
    ctx->Texture.EyePlaneS[3] = (float )0.0;
#line 8973
    ctx->Texture.EyePlaneT[0] = (float )0.0;
#line 8973
    ctx->Texture.EyePlaneT[1] = (float )1.0;
#line 8973
    ctx->Texture.EyePlaneT[2] = (float )0.0;
#line 8973
    ctx->Texture.EyePlaneT[3] = (float )0.0;
#line 8974
    ctx->Texture.EyePlaneR[0] = (float )0.0;
#line 8974
    ctx->Texture.EyePlaneR[1] = (float )0.0;
#line 8974
    ctx->Texture.EyePlaneR[2] = (float )0.0;
#line 8974
    ctx->Texture.EyePlaneR[3] = (float )0.0;
#line 8975
    ctx->Texture.EyePlaneQ[0] = (float )0.0;
#line 8975
    ctx->Texture.EyePlaneQ[1] = (float )0.0;
#line 8975
    ctx->Texture.EyePlaneQ[2] = (float )0.0;
#line 8975
    ctx->Texture.EyePlaneQ[3] = (float )0.0;
#line 8983
    ctx->Texture.Current1D = (ctx->Shared)->Default1D;
#line 8984
    ctx->Texture.Current2D = (ctx->Shared)->Default2D;
#line 8985
    ctx->Texture.Current3D = (ctx->Shared)->Default3D;
#line 8987
    ctx->Texture.SharedPalette = (unsigned char)0;
#line 8988
    ctx->Texture.Palette[0] = (unsigned char)255;
#line 8989
    ctx->Texture.Palette[1] = (unsigned char)255;
#line 8990
    ctx->Texture.Palette[2] = (unsigned char)255;
#line 8991
    ctx->Texture.Palette[3] = (unsigned char)255;
#line 8992
    ctx->Texture.PaletteSize = 1U;
#line 8993
    ctx->Texture.PaletteIntFormat = 6408;
#line 8994
    ctx->Texture.PaletteFormat = 6408;
#line 8995
    ctx->Transform.MatrixMode = 5888;
#line 8996
    ctx->Transform.Normalize = (unsigned char)0;
#line 8997
    i = 0U;
#line 8997
    while (i < 6U) {
#line 8998
      ctx->Transform.ClipEnabled[i] = (unsigned char)0;
#line 8999
      ctx->Transform.ClipEquation[i][0] = (float )0.0;
#line 8999
      ctx->Transform.ClipEquation[i][1] = (float )0.0;
#line 8999
      ctx->Transform.ClipEquation[i][2] = (float )0.0;
#line 8999
      ctx->Transform.ClipEquation[i][3] = (float )0.0;
#line 8997
      i ++;
    }
#line 9001
    ctx->Transform.AnyClip = (unsigned char)0;
#line 9002
    ctx->Viewport.X = 0;
#line 9003
    ctx->Viewport.Y = 0;
#line 9004
    ctx->Viewport.Width = 0;
#line 9005
    ctx->Viewport.Height = 0;
#line 9006
    ctx->Viewport.Near = (float )0.0;
#line 9007
    ctx->Viewport.Far = (float )1.0;
#line 9008
    ctx->Viewport.Sx = (float )0.0;
#line 9009
    ctx->Viewport.Tx = (float )0.0;
#line 9010
    ctx->Viewport.Sy = (float )0.0;
#line 9011
    ctx->Viewport.Ty = (float )0.0;
#line 9012
    ctx->Viewport.Sz = (float )(0.5 * (double )65535.0F);
#line 9013
    ctx->Viewport.Tz = (float )(0.5 * (double )65535.0F);
#line 9014
    ctx->Pack.Alignment = 4;
#line 9015
    ctx->Pack.RowLength = 0;
#line 9016
    ctx->Pack.SkipPixels = 0;
#line 9017
    ctx->Pack.SkipRows = 0;
#line 9018
    ctx->Pack.SwapBytes = (unsigned char)0;
#line 9019
    ctx->Pack.LsbFirst = (unsigned char)0;
#line 9020
    ctx->Unpack.Alignment = 4;
#line 9021
    ctx->Unpack.RowLength = 0;
#line 9022
    ctx->Unpack.SkipPixels = 0;
#line 9023
    ctx->Unpack.SkipRows = 0;
#line 9024
    ctx->Unpack.SwapBytes = (unsigned char)0;
#line 9025
    ctx->Unpack.LsbFirst = (unsigned char)0;
#line 9026
    ctx->Feedback.Type = 1536;
#line 9027
    ctx->Feedback.Buffer = (float *)((void *)0);
#line 9028
    ctx->Feedback.BufferSize = 0U;
#line 9029
    ctx->Feedback.Count = 0U;
#line 9030
    ctx->Select.Buffer = (GLuint *)((void *)0);
#line 9031
    ctx->Select.BufferSize = 0U;
#line 9032
    ctx->Select.BufferCount = 0U;
#line 9033
    ctx->Select.Hits = 0U;
#line 9034
    ctx->Select.NameStackDepth = 0U;
#line 9035
    ctx->AttribStackDepth = 0U;
#line 9036
    ctx->ClientAttribStackDepth = 0U;
#line 9037
    ctx->NewState = 15U;
#line 9038
    ctx->RenderMode = 7168;
#line 9039
    ctx->Primitive = 6656;
#line 9040
    ctx->StippleCounter = 0U;
#line 9041
    ctx->NeedNormals = (unsigned char)0;
#line 9042
    if ((ctx->Visual)->RedScale == 255.0F) {
#line 9042
      if ((ctx->Visual)->GreenScale == 255.0F) {
#line 9042
        if ((ctx->Visual)->BlueScale == 255.0F) {
#line 9042
          if ((ctx->Visual)->AlphaScale == 255.0F) {
#line 9046
            (ctx->Visual)->EightBitColor = (unsigned char)1;
          } else {
#line 9049
            (ctx->Visual)->EightBitColor = (unsigned char)0;
          }
        } else {
#line 9049
          (ctx->Visual)->EightBitColor = (unsigned char)0;
        }
      } else {
#line 9049
        (ctx->Visual)->EightBitColor = (unsigned char)0;
      }
    } else {
#line 9049
      (ctx->Visual)->EightBitColor = (unsigned char)0;
    }
#line 9051
    if ((ctx->Visual)->RGBAflag) {
#line 9051
      if ((ctx->Visual)->EightBitColor) {
#line 9051
        tmp___0 = 1;
      } else {
#line 9051
        tmp___0 = 0;
      }
    } else {
#line 9051
      tmp___0 = 0;
    }
#line 9051
    ctx->FastDrawPixels = (unsigned char )tmp___0;
#line 9057
    ctx->DirectContext = (unsigned char)1;
#line 9058
    ctx->CallDepth = 0U;
#line 9059
    ctx->ExecuteFlag = (unsigned char)1;
#line 9060
    ctx->CompileFlag = (unsigned char)0;
#line 9061
    ctx->ErrorValue = 0;
#line 9062
    tmp___2 = getenv("MESA_NO_RASTER");
#line 9062
    if (tmp___2) {
#line 9062
      ctx->NoRaster = (unsigned char)1;
    } else {
#line 9062
      ctx->NoRaster = (unsigned char)0;
    }
#line 9063
    tmp___4 = getenv("MESA_NO_DITHER");
#line 9063
    if (tmp___4) {
#line 9063
      ctx->NoDither = (unsigned char)1;
    } else {
#line 9063
      ctx->NoDither = (unsigned char)0;
    }
#line 9064
    if (ctx->NoDither) {
#line 9065
      tmp___6 = getenv("MESA_DEBUG");
#line 9065
      if (tmp___6) {
#line 9066
        tmp___5 = __getreent();
#line 9066
        fprintf(tmp___5->_stderr, "MESA_NO_DITHER set - dithering disabled\n");
      }
#line 9068
      ctx->Color.DitherFlag = (unsigned char)0;
    }
  }
#line 9071
  return;
}
}
#line 9072 "D:/a/test/177.c"
GLvisual *gl_create_visual(GLboolean rgb_flag , GLboolean alpha_flag , GLboolean db_flag ,
                           GLint depth_bits , GLint stencil_bits , GLint accum_bits ,
                           GLint index_bits , float red_scale , float green_scale ,
                           float blue_scale , float alpha_scale , GLint red_bits ,
                           GLint green_bits , GLint blue_bits , GLint alpha_bits ) 
{ GLvisual *vis ;
  void *tmp ;

  {
#line 9089
  //assert((double )red_scale <= 255.0);
#line 9090
 // assert((double )green_scale <= 255.0);
#line 9091
 // assert((double )blue_scale <= 255.0);
#line 9092
  //assert((double )alpha_scale <= 255.0);
#line 9093
  if ((unsigned int )depth_bits > 8U * sizeof(GLdepth )) {
#line 9094
    return ((GLvisual *)((void *)0));
  }
#line 9096
  if ((unsigned int )stencil_bits > 8U * sizeof(GLstencil )) {
#line 9097
    return ((GLvisual *)((void *)0));
  }
#line 9099
  if ((unsigned int )accum_bits > 8U * sizeof(GLaccum )) {
#line 9100
    return ((GLvisual *)((void *)0));
  }
#line 9102
  tmp = calloc(1U, sizeof(GLvisual ));
#line 9102
  vis = (GLvisual *)tmp;
#line 9103
  if (! vis) {
#line 9104
    return ((GLvisual *)((void *)0));
  }
#line 9106
  vis->RGBAflag = rgb_flag;
#line 9107
  vis->DBflag = db_flag;
#line 9108
  vis->RedScale = red_scale;
#line 9109
  vis->GreenScale = green_scale;
#line 9110
  vis->BlueScale = blue_scale;
#line 9111
  vis->AlphaScale = alpha_scale;
#line 9112
  if (red_scale) {
#line 9113
    vis->InvRedScale = 1.0F / red_scale;
  }
#line 9115
  if (green_scale) {
#line 9116
    vis->InvGreenScale = 1.0F / green_scale;
  }
#line 9118
  if (blue_scale) {
#line 9119
    vis->InvBlueScale = 1.0F / blue_scale;
  }
#line 9121
  if (alpha_scale) {
#line 9122
    vis->InvAlphaScale = 1.0F / alpha_scale;
  }
#line 9124
  vis->RedBits = red_bits;
#line 9125
  vis->GreenBits = green_bits;
#line 9126
  vis->BlueBits = blue_bits;
#line 9127
  if (alpha_flag) {
#line 9127
    vis->AlphaBits = (int )(8U * sizeof(GLubyte ));
  } else {
#line 9127
    vis->AlphaBits = alpha_bits;
  }
#line 9128
  vis->IndexBits = index_bits;
#line 9129
  if (depth_bits > 0) {
#line 9129
    vis->DepthBits = (int )(8U * sizeof(GLdepth ));
  } else {
#line 9129
    vis->DepthBits = 0;
  }
#line 9130
  if (accum_bits > 0) {
#line 9130
    vis->AccumBits = (int )(8U * sizeof(GLaccum ));
  } else {
#line 9130
    vis->AccumBits = 0;
  }
#line 9131
  if (stencil_bits > 0) {
#line 9131
    vis->StencilBits = (int )(8U * sizeof(GLstencil ));
  } else {
#line 9131
    vis->StencilBits = 0;
  }
#line 9132
  if (red_scale == 255.0F) {
#line 9132
    if (green_scale == 255.0F) {
#line 9132
      if (blue_scale == 255.0F) {
#line 9132
        if (alpha_scale == 255.0F) {
#line 9134
          vis->EightBitColor = (unsigned char)1;
        } else {
#line 9137
          vis->EightBitColor = (unsigned char)0;
        }
      } else {
#line 9137
        vis->EightBitColor = (unsigned char)0;
      }
    } else {
#line 9137
      vis->EightBitColor = (unsigned char)0;
    }
  } else {
#line 9137
    vis->EightBitColor = (unsigned char)0;
  }
#line 9139
  if (alpha_flag) {
#line 9140
    vis->FrontAlphaEnabled = (unsigned char)1;
#line 9141
    if (db_flag) {
#line 9142
      vis->BackAlphaEnabled = (unsigned char)1;
    }
  }
#line 9145
  return (vis);
}
}
#line 9147 "D:/a/test/177.c"
void gl_destroy_visual(GLvisual *vis ) 
{ 

  {
#line 9149
  free((void *)vis);
#line 9150
  return;
}
}
#line 9172
struct gl_texture_image *gl_alloc_texture_image(void) ;
#line 9184
void gl_free_texture_image(struct gl_texture_image *teximage ) ;
#line 9213
void gl_init_math(void) ;
#line 9214
void gl_init_lists(void) ;
#line 9215
void gl_init_eval(void) ;
#line 9223
struct vertex_buffer *gl_alloc_vb(void) ;
#line 9228
struct pixel_buffer *gl_alloc_pb(void) ;
#line 9268
void gl_init_api_function_pointers(GLcontext *ctx ) ;
#line 9202 "D:/a/test/177.c"
GLcontext *gl_create_context(GLvisual *visual , GLcontext *share_list , void *driver_ctx ) 
{ GLcontext *ctx ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 9207
  //assert(sizeof(GLbyte ) == 1U);
#line 9208
  //assert(sizeof(GLshort ) >= 2U);
#line 9209
  //assert(sizeof(GLint ) >= 4U);
#line 9210
  //assert(sizeof(GLubyte ) == 1U);
#line 9211
  //assert(sizeof(GLushort ) >= 2U);
#line 9212
  //assert(sizeof(GLuint ) >= 4U);
#line 9213
  gl_init_math();
#line 9214
  gl_init_lists();
#line 9215
  gl_init_eval();
#line 9216
  tmp = calloc(1U, sizeof(GLcontext ));
#line 9216
  ctx = (GLcontext *)tmp;
#line 9217
  if (! ctx) {
#line 9218
    return ((GLcontext *)((void *)0));
  }
#line 9220
  ctx->DriverCtx = driver_ctx;
#line 9221
  ctx->Visual = visual;
#line 9222
  ctx->Buffer = (GLframebuffer *)((void *)0);
#line 9223
  tmp___0 = (int )gl_alloc_vb();
#line 9223
  ctx->VB = (struct vertex_buffer *)tmp___0;
#line 9224
  if (! ctx->VB) {
#line 9225
    free((void *)ctx);
#line 9226
    return ((GLcontext *)((void *)0));
  }
#line 9228
  tmp___1 = (int )gl_alloc_pb();
#line 9228
  ctx->PB = (struct pixel_buffer *)tmp___1;
#line 9229
  if (! ctx->PB) {
#line 9230
    free((void *)ctx->VB);
#line 9231
    free((void *)ctx);
#line 9232
    return ((GLcontext *)((void *)0));
  }
#line 9234
  if (share_list) {
#line 9235
    ctx->Shared = share_list->Shared;
  } else {
#line 9238
    ctx->Shared = alloc_shared_state();
#line 9239
    if (! ctx->Shared) {
#line 9240
      free((void *)ctx->VB);
#line 9241
      free((void *)ctx->PB);
#line 9242
      free((void *)ctx);
#line 9243
      return ((GLcontext *)((void *)0));
    }
  }
#line 9246
  ((ctx->Shared)->RefCount) ++;
#line 9247
  initialize_context(ctx);
#line 9248
  if (visual->DBflag) {
#line 9249
    ctx->Color.DrawBuffer = 1029;
#line 9250
    ctx->Pixel.ReadBuffer = 1029;
  } else {
#line 9253
    ctx->Color.DrawBuffer = 1028;
#line 9254
    ctx->Pixel.ReadBuffer = 1028;
  }
#line 9268
  gl_init_api_function_pointers(ctx);
#line 9269
  ctx->API = ctx->Exec;
#line 9270
  return (ctx);
}
}
#line 9272 "D:/a/test/177.c"
void gl_destroy_context(GLcontext *ctx ) 
{ 

  {
#line 9274
  if (ctx) {
#line 9280
    free((void *)ctx->PB);
#line 9281
    free((void *)ctx->VB);
#line 9282
    ((ctx->Shared)->RefCount) --;
#line 9283
   // assert((ctx->Shared)->RefCount >= 0);
#line 9284
    if ((ctx->Shared)->RefCount == 0) {
#line 9286
      free_shared_state(ctx, ctx->Shared);
    }
#line 9288
    gl_free_texture_object((void *)0, ctx->Texture.Proxy1D);
#line 9289
    gl_free_texture_object((void *)0, ctx->Texture.Proxy2D);
#line 9290
    gl_free_texture_object((void *)0, ctx->Texture.Proxy3D);
#line 9291
    free((void *)ctx);
#line 9293
    if ((unsigned int )ctx == (unsigned int )CC) {
#line 9294
      CC = (GLcontext *)((void *)0);
    }
  }
#line 9298
  return;
}
}
#line 9299 "D:/a/test/177.c"
GLframebuffer *gl_create_framebuffer(GLvisual *visual ) 
{ GLframebuffer *buffer ;
  void *tmp ;

  {
#line 9302
  tmp = calloc(1U, sizeof(GLframebuffer ));
#line 9302
  buffer = (GLframebuffer *)tmp;
#line 9303
  if (! buffer) {
#line 9304
    return ((GLframebuffer *)((void *)0));
  }
#line 9306
  buffer->Visual = visual;
#line 9307
  return (buffer);
}
}
#line 9309 "D:/a/test/177.c"
void gl_destroy_framebuffer(GLframebuffer *buffer ) 
{ 

  {
#line 9311
  if (buffer) {
#line 9312
    if (buffer->Depth) {
#line 9313
      free((void *)buffer->Depth);
    }
#line 9315
    if (buffer->Accum) {
#line 9316
      free((void *)buffer->Accum);
    }
#line 9318
    if (buffer->Stencil) {
#line 9319
      free((void *)buffer->Stencil);
    }
#line 9321
    if (buffer->FrontAlpha) {
#line 9322
      free((void *)buffer->FrontAlpha);
    }
#line 9324
    if (buffer->BackAlpha) {
#line 9325
      free((void *)buffer->BackAlpha);
    }
#line 9327
    free((void *)buffer);
  }
#line 9329
  return;
}
}
#line 9330 "D:/a/test/177.c"
void gl_make_current(GLcontext *ctx , GLframebuffer *buffer ) 
{ 

  {
#line 9335
  if (CC) {
#line 9335
    if (CC->Buffer) {
#line 9336
      CC->Buffer = (GLframebuffer *)((void *)0);
    }
  }
#line 9338
  CC = ctx;
#line 9340
  if (ctx) {
#line 9340
    if (buffer) {
#line 9341
      ctx->Buffer = buffer;
#line 9342
      ctx->NewState = 15U;
#line 9343
      gl_update_state(ctx);
    }
  }
#line 9345
  return;
}
}
#line 9346 "D:/a/test/177.c"
GLcontext *gl_get_current_context(void) 
{ 

  {
#line 9351
  return (CC);
}
}
#line 9354 "D:/a/test/177.c"
void gl_copy_context(GLcontext const   *src , GLcontext *dst , GLuint mask ) 
{ 

  {
#line 9356
  if (mask & 512U) {
#line 9357
    memcpy((void *)(& dst->Accum), (void const   *)((void *)(& src->Accum)), sizeof(struct gl_accum_attrib ));
  }
#line 9359
  if (mask & 16384U) {
#line 9360
    memcpy((void *)(& dst->Color), (void const   *)((void *)(& src->Color)), sizeof(struct gl_colorbuffer_attrib ));
  }
#line 9362
  if (mask & 1U) {
#line 9363
    memcpy((void *)(& dst->Current), (void const   *)((void *)(& src->Current)), sizeof(struct gl_current_attrib ));
  }
#line 9365
  if (mask & 256U) {
#line 9366
    memcpy((void *)(& dst->Depth), (void const   *)((void *)(& src->Depth)), sizeof(struct gl_depthbuffer_attrib ));
  }
#line 9368
  if (mask & 8192U) {

  }
#line 9370
  if (mask & 65536U) {
#line 9371
    memcpy((void *)(& dst->Eval), (void const   *)((void *)(& src->Eval)), sizeof(struct gl_eval_attrib ));
  }
#line 9373
  if (mask & 128U) {
#line 9374
    memcpy((void *)(& dst->Fog), (void const   *)((void *)(& src->Fog)), sizeof(struct gl_fog_attrib ));
  }
#line 9376
  if (mask & 32768U) {
#line 9377
    memcpy((void *)(& dst->Hint), (void const   *)((void *)(& src->Hint)), sizeof(struct gl_hint_attrib ));
  }
#line 9379
  if (mask & 64U) {
#line 9380
    memcpy((void *)(& dst->Light), (void const   *)((void *)(& src->Light)), sizeof(struct gl_light_attrib ));
  }
#line 9382
  if (mask & 4U) {
#line 9383
    memcpy((void *)(& dst->Line), (void const   *)((void *)(& src->Line)), sizeof(struct gl_line_attrib ));
  }
#line 9385
  if (mask & 131072U) {
#line 9386
    memcpy((void *)(& dst->List), (void const   *)((void *)(& src->List)), sizeof(struct gl_list_attrib ));
  }
#line 9388
  if (mask & 32U) {
#line 9389
    memcpy((void *)(& dst->Pixel), (void const   *)((void *)(& src->Pixel)), sizeof(struct gl_pixel_attrib ));
  }
#line 9391
  if (mask & 2U) {
#line 9392
    memcpy((void *)(& dst->Point), (void const   *)((void *)(& src->Point)), sizeof(struct gl_point_attrib ));
  }
#line 9394
  if (mask & 8U) {
#line 9395
    memcpy((void *)(& dst->Polygon), (void const   *)((void *)(& src->Polygon)), sizeof(struct gl_polygon_attrib ));
  }
#line 9397
  if (mask & 16U) {
#line 9398
    memcpy((void *)(& dst->PolygonStipple), (void const   *)((void *)(& src->PolygonStipple)),
           32U * sizeof(GLuint ));
  }
#line 9400
  if (mask & 524288U) {
#line 9401
    memcpy((void *)(& dst->Scissor), (void const   *)((void *)(& src->Scissor)), sizeof(struct gl_scissor_attrib ));
  }
#line 9403
  if (mask & 1024U) {
#line 9404
    memcpy((void *)(& dst->Stencil), (void const   *)((void *)(& src->Stencil)), sizeof(struct gl_stencil_attrib ));
  }
#line 9406
  if (mask & 262144U) {
#line 9407
    memcpy((void *)(& dst->Texture), (void const   *)((void *)(& src->Texture)), sizeof(struct gl_texture_attrib ));
  }
#line 9409
  if (mask & 4096U) {
#line 9410
    memcpy((void *)(& dst->Transform), (void const   *)((void *)(& src->Transform)),
           sizeof(struct gl_transform_attrib ));
  }
#line 9412
  if (mask & 2048U) {
#line 9413
    memcpy((void *)(& dst->Viewport), (void const   *)((void *)(& src->Viewport)),
           sizeof(struct gl_viewport_attrib ));
  }
#line 9415
  return;
}
}
#line 9416 "D:/a/test/177.c"
void gl_set_api_table(GLcontext *ctx , struct gl_api_table  const  *api ) 
{ 

  {
#line 9418
  if (api) {
#line 9419
    memcpy((void *)(& ctx->API), (void const   *)((void *)api), sizeof(struct gl_api_table ));
  } else {
#line 9422
    memcpy((void *)(& ctx->API), (void const   *)((void *)(& ctx->Exec)), sizeof(struct gl_api_table ));
  }
#line 9424
  return;
}
}
#line 9425 "D:/a/test/177.c"
void gl_problem(GLcontext const   *ctx , char const   *s ) 
{ struct _reent *tmp ;
  struct _reent *tmp___0 ;

  {
#line 9427
  tmp = __getreent();
#line 9427
  fprintf(tmp->_stderr, "Mesa implementation error: %s\n", s);
#line 9428
  tmp___0 = __getreent();
#line 9428
  fprintf(tmp___0->_stderr, "Report to Mesa author.\n");
#line 9429
  return;
}
}
#line 9430 "D:/a/test/177.c"
void gl_warning(GLcontext const   *ctx , char const   *s ) 
{ GLboolean debug ;
  char *tmp ;
  struct _reent *tmp___0 ;

  {
#line 9436
  tmp = getenv("MESA_DEBUG");
#line 9436
  if (tmp) {
#line 9437
    debug = (unsigned char)1;
  } else {
#line 9440
    debug = (unsigned char)0;
  }
#line 9443
  if (debug) {
#line 9444
    tmp___0 = __getreent();
#line 9444
    fprintf(tmp___0->_stderr, "Mesa warning: %s\n", s);
  }
#line 9446
  return;
}
}
#line 9447 "D:/a/test/177.c"
void gl_error(GLcontext *ctx , GLenum error , char const   *s ) 
{ GLboolean debug ;
  char *tmp ;
  char errstr[1000] ;
  struct _reent *tmp___0 ;

  {
#line 9453
  tmp = getenv("MESA_DEBUG");
#line 9453
  if (tmp) {
#line 9454
    debug = (unsigned char)1;
  } else {
#line 9457
    debug = (unsigned char)0;
  }
#line 9460
  if (debug) {
#line 9462
    switch (error) {
    case 0: 
#line 9464
    strcpy(errstr, "GL_NO_ERROR");
#line 9465
    break;
    case 1281: 
#line 9467
    strcpy(errstr, "GL_INVALID_VALUE");
#line 9468
    break;
    case 1280: 
#line 9470
    strcpy(errstr, "GL_INVALID_ENUM");
#line 9471
    break;
    case 1282: 
#line 9473
    strcpy(errstr, "GL_INVALID_OPERATION");
#line 9474
    break;
    case 1283: 
#line 9476
    strcpy(errstr, "GL_STACK_OVERFLOW");
#line 9477
    break;
    case 1284: 
#line 9479
    strcpy(errstr, "GL_STACK_UNDERFLOW");
#line 9480
    break;
    case 1285: 
#line 9482
    strcpy(errstr, "GL_OUT_OF_MEMORY");
#line 9483
    break;
    default: 
#line 9485
    strcpy(errstr, "unknown");
#line 9486
    break;
    }
#line 9488
    tmp___0 = __getreent();
#line 9488
    fprintf(tmp___0->_stderr, "Mesa user error: %s in %s\n", errstr, s);
  }
#line 9490
  if (ctx->ErrorValue == 0) {
#line 9491
    ctx->ErrorValue = error;
  }
#line 9493
  if (ctx->Driver.Error) {
#line 9494
    (*(ctx->Driver.Error))(ctx);
  }
#line 9496
  return;
}
}
#line 9497 "D:/a/test/177.c"
GLenum gl_GetError(GLcontext *ctx ) 
{ GLenum e ;

  {
#line 9500
  if (ctx->Primitive != 6656) {
#line 9501
    gl_error(ctx, 1282, "glGetError");
#line 9502
    return (1282);
  }
#line 9504
  e = ctx->ErrorValue;
#line 9505
  ctx->ErrorValue = 0;
#line 9506
  return (e);
}
}
#line 9521
void gl_alloc_stencil_buffer(GLcontext *ctx ) ;
#line 9508 "D:/a/test/177.c"
void gl_ResizeBuffersMESA(GLcontext *ctx ) 
{ GLint newsize ;
  GLuint buf_width ;
  GLuint buf_height ;
  int tmp ;

  {
#line 9512
  ctx->NewState |= 15U;
#line 9513
  (*(ctx->Driver.GetBufferSize))(ctx, & buf_width, & buf_height);
#line 9514
  if ((GLuint )(ctx->Buffer)->Width != buf_width) {
#line 9514
    tmp = 1;
  } else {
#line 9514
    if ((GLuint )(ctx->Buffer)->Height != buf_height) {
#line 9514
      tmp = 1;
    } else {
#line 9514
      tmp = 0;
    }
  }
#line 9514
  newsize = tmp;
#line 9515
  (ctx->Buffer)->Width = (int )buf_width;
#line 9516
  (ctx->Buffer)->Height = (int )buf_height;
#line 9517
  if (newsize) {
#line 9517
    if ((ctx->Visual)->DepthBits > 0) {
#line 9518
      (*(ctx->Driver.AllocDepthBuffer))(ctx);
    }
  }
#line 9520
  if (newsize) {
#line 9520
    if ((ctx->Visual)->StencilBits > 0) {
#line 9521
      gl_alloc_stencil_buffer(ctx);
    }
  }
#line 9523
  if (newsize) {
#line 9523
    if ((ctx->Visual)->AccumBits > 0) {
#line 9524
      gl_alloc_accum_buffer(ctx);
    }
  }
#line 9526
  if (newsize) {
#line 9526
    if ((ctx->Visual)->FrontAlphaEnabled) {
#line 9528
      gl_alloc_alpha_buffers(ctx);
    } else {
#line 9526
      if ((ctx->Visual)->BackAlphaEnabled) {
#line 9528
        gl_alloc_alpha_buffers(ctx);
      }
    }
  }
#line 9530
  return;
}
}
#line 9531 "D:/a/test/177.c"
static void update_pixel_logic(GLcontext *ctx ) 
{ GLboolean tmp ;
  GLboolean tmp___0 ;

  {
#line 9533
  if ((ctx->Visual)->RGBAflag) {
#line 9534
    if (ctx->Color.ColorLogicOpEnabled) {
#line 9535
      if (ctx->Driver.LogicOp) {
#line 9535
        tmp = (*(ctx->Driver.LogicOp))(ctx, ctx->Color.LogicOp);
#line 9535
        if (tmp) {
#line 9538
          ctx->Color.SWLogicOpEnabled = (unsigned char)0;
        } else {
#line 9542
          ctx->Color.SWLogicOpEnabled = (unsigned char)1;
        }
      } else {
#line 9542
        ctx->Color.SWLogicOpEnabled = (unsigned char)1;
      }
    } else {
#line 9547
      if (ctx->Driver.LogicOp) {
#line 9548
        (*(ctx->Driver.LogicOp))(ctx, 5379);
      }
#line 9550
      ctx->Color.SWLogicOpEnabled = (unsigned char)0;
    }
  } else {
#line 9554
    if (ctx->Color.IndexLogicOpEnabled) {
#line 9555
      if (ctx->Driver.LogicOp) {
#line 9555
        tmp___0 = (*(ctx->Driver.LogicOp))(ctx, ctx->Color.LogicOp);
#line 9555
        if (tmp___0) {
#line 9558
          ctx->Color.SWLogicOpEnabled = (unsigned char)0;
        } else {
#line 9562
          ctx->Color.SWLogicOpEnabled = (unsigned char)1;
        }
      } else {
#line 9562
        ctx->Color.SWLogicOpEnabled = (unsigned char)1;
      }
    } else {
#line 9567
      if (ctx->Driver.LogicOp) {
#line 9568
        (*(ctx->Driver.LogicOp))(ctx, 5379);
      }
#line 9570
      ctx->Color.SWLogicOpEnabled = (unsigned char)0;
    }
  }
#line 9573
  return;
}
}
#line 9574 "D:/a/test/177.c"
static void update_pixel_masking(GLcontext *ctx ) 
{ GLboolean red ;
  int tmp ;
  GLboolean green ;
  int tmp___0 ;
  GLboolean blue___0 ;
  int tmp___1 ;
  GLboolean alpha ;
  int tmp___2 ;
  GLboolean tmp___3 ;
  GLboolean tmp___4 ;

  {
#line 9576
  if ((ctx->Visual)->RGBAflag) {
#line 9577
    if (ctx->Color.ColorMask == 15U) {
#line 9578
      if (ctx->Driver.ColorMask) {
#line 9579
        (*(ctx->Driver.ColorMask))(ctx, (unsigned char)1, (unsigned char)1, (unsigned char)1,
                                   (unsigned char)1);
      }
#line 9581
      ctx->Color.SWmasking = (unsigned char)0;
    } else {
#line 9584
      if (ctx->Color.ColorMask & 8U) {
#line 9584
        tmp = 1;
      } else {
#line 9584
        tmp = 0;
      }
#line 9584
      red = (GLboolean )tmp;
#line 9585
      if (ctx->Color.ColorMask & 4U) {
#line 9585
        tmp___0 = 1;
      } else {
#line 9585
        tmp___0 = 0;
      }
#line 9585
      green = (GLboolean )tmp___0;
#line 9586
      if (ctx->Color.ColorMask & 2U) {
#line 9586
        tmp___1 = 1;
      } else {
#line 9586
        tmp___1 = 0;
      }
#line 9586
      blue___0 = (GLboolean )tmp___1;
#line 9587
      if (ctx->Color.ColorMask & 1U) {
#line 9587
        tmp___2 = 1;
      } else {
#line 9587
        tmp___2 = 0;
      }
#line 9587
      alpha = (GLboolean )tmp___2;
#line 9588
      if (ctx->Driver.ColorMask) {
#line 9588
        tmp___3 = (*(ctx->Driver.ColorMask))(ctx, red, green, blue___0, alpha);
#line 9588
        if (tmp___3) {
#line 9590
          ctx->Color.SWmasking = (unsigned char)0;
        } else {
#line 9593
          ctx->Color.SWmasking = (unsigned char)1;
        }
      } else {
#line 9593
        ctx->Color.SWmasking = (unsigned char)1;
      }
    }
  } else {
#line 9598
    if (ctx->Color.IndexMask == 4294967295U) {
#line 9599
      if (ctx->Driver.IndexMask) {
#line 9600
        (*(ctx->Driver.IndexMask))(ctx, 4294967295U);
      }
#line 9602
      ctx->Color.SWmasking = (unsigned char)0;
    } else {
#line 9605
      if (ctx->Driver.IndexMask) {
#line 9605
        tmp___4 = (*(ctx->Driver.IndexMask))(ctx, ctx->Color.IndexMask);
#line 9605
        if (tmp___4) {
#line 9607
          ctx->Color.SWmasking = (unsigned char)0;
        } else {
#line 9610
          ctx->Color.SWmasking = (unsigned char)1;
        }
      } else {
#line 9610
        ctx->Color.SWmasking = (unsigned char)1;
      }
    }
  }
#line 9614
  return;
}
}
#line 9615 "D:/a/test/177.c"
static void update_rasterflags(GLcontext *ctx ) 
{ 

  {
#line 9617
  ctx->RasterMask = 0U;
#line 9618
  if (ctx->Color.AlphaEnabled) {
#line 9618
    ctx->RasterMask |= 1U;
  }
#line 9619
  if (ctx->Color.BlendEnabled) {
#line 9619
    ctx->RasterMask |= 2U;
  }
#line 9620
  if (ctx->Depth.Test) {
#line 9620
    ctx->RasterMask |= 4U;
  }
#line 9621
  if (ctx->Fog.Enabled) {
#line 9621
    ctx->RasterMask |= 8U;
  }
#line 9622
  if (ctx->Color.SWLogicOpEnabled) {
#line 9622
    ctx->RasterMask |= 16U;
  }
#line 9623
  if (ctx->Scissor.Enabled) {
#line 9623
    ctx->RasterMask |= 32U;
  }
#line 9624
  if (ctx->Stencil.Enabled) {
#line 9624
    ctx->RasterMask |= 64U;
  }
#line 9625
  if (ctx->Color.SWmasking) {
#line 9625
    ctx->RasterMask |= 128U;
  }
#line 9626
  if ((ctx->Visual)->FrontAlphaEnabled) {
#line 9626
    ctx->RasterMask |= 256U;
  }
#line 9627
  if ((ctx->Visual)->BackAlphaEnabled) {
#line 9627
    ctx->RasterMask |= 256U;
  }
#line 9628
  if (ctx->Viewport.X < 0) {
#line 9632
    ctx->RasterMask |= 512U;
  } else {
#line 9628
    if (ctx->Viewport.X + ctx->Viewport.Width > (ctx->Buffer)->Width) {
#line 9632
      ctx->RasterMask |= 512U;
    } else {
#line 9628
      if (ctx->Viewport.Y < 0) {
#line 9632
        ctx->RasterMask |= 512U;
      } else {
#line 9628
        if (ctx->Viewport.Y + ctx->Viewport.Height > (ctx->Buffer)->Height) {
#line 9632
          ctx->RasterMask |= 512U;
        }
      }
    }
  }
#line 9634
  if (ctx->Color.DrawBuffer == 1032) {
#line 9635
    ctx->RasterMask |= 1024U;
  }
#line 9637
  if (ctx->Color.DrawBuffer == 0) {
#line 9638
    ctx->RasterMask |= 2048U;
  } else {
#line 9640
    if ((ctx->Visual)->RGBAflag) {
#line 9640
      if (ctx->Color.ColorMask == 0U) {
#line 9641
        ctx->RasterMask |= 2048U;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 9643
      if (! (ctx->Visual)->RGBAflag) {
#line 9643
        if (ctx->Color.IndexMask == 0U) {
#line 9644
          ctx->RasterMask |= 2048U;
        }
      }
    }
  }
#line 9646
  return;
}
}
#line 9647 "D:/a/test/177.c"
static void update_clipmask(GLcontext *ctx ) 
{ 

  {
#line 9649
  ctx->ClipMask = 0U;
#line 9650
  if (ctx->Texture.Enabled) {
#line 9651
    ctx->ClipMask |= 16U;
  }
#line 9653
  if (ctx->Light.ShadeModel == 7425) {
#line 9654
    if ((ctx->Visual)->RGBAflag) {
#line 9655
      ctx->ClipMask |= 1U;
#line 9656
      if (ctx->Light.Model.TwoSide) {
#line 9657
        ctx->ClipMask |= 2U;
      }
    } else {
#line 9661
      ctx->ClipMask |= 4U;
#line 9662
      if (ctx->Light.Model.TwoSide) {
#line 9663
        ctx->ClipMask |= 8U;
      }
    }
  }
#line 9667
  return;
}
}
#line 9677
 extern int  Z_ADDRESS(GLcontext *c,GLint x,GLint y) ;
#line 9668 "D:/a/test/177.c"
void gl_clear_depth_buffer(GLcontext *ctx ) 
{ GLdepth clear_value ;
  GLint y ;
  GLdepth *d ;
  int tmp ;
  GLint n ;
  GLdepth *tmp___0 ;
  GLdepth *d___0 ;
  GLint n___0 ;
  GLdepth *tmp___1 ;

  {
#line 9670
  clear_value = (unsigned short )(ctx->Depth.Clear * 65535.0F);
#line 9671
  if ((ctx->Visual)->DepthBits == 0) {
#line 9672
    return;
  } else {
#line 9671
    if (! (ctx->Buffer)->Depth) {
#line 9672
      return;
    }
  }
#line 9674
  if (ctx->Scissor.Enabled) {
#line 9676
    y = (ctx->Buffer)->Ymin;
#line 9676
    while (y <= (ctx->Buffer)->Ymax) {
#line 9677
      tmp = Z_ADDRESS(ctx, (ctx->Buffer)->Xmin, y);
#line 9677
      d = (GLdepth *)tmp;
#line 9678
      n = ((ctx->Buffer)->Xmax - (ctx->Buffer)->Xmin) + 1;
#line 9679
      while (1) {
#line 9680
        tmp___0 = d;
#line 9680
        d ++;
#line 9680
        *tmp___0 = clear_value;
#line 9681
        n --;
#line 9679
        if (! n) {
#line 9679
          break;
        }
      }
#line 9676
      y ++;
    }
  } else {
#line 9686
    if (sizeof(GLdepth ) == 2U) {
#line 9686
      if (((int )clear_value & 255) == (int )clear_value >> 8) {
#line 9687
        memset((void *)(ctx->Buffer)->Depth, (int )clear_value & 255, (unsigned int )((2 * (ctx->Buffer)->Width) * (ctx->Buffer)->Height));
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 9691
      d___0 = (ctx->Buffer)->Depth;
#line 9692
      n___0 = (ctx->Buffer)->Width * (ctx->Buffer)->Height;
#line 9693
      while (n___0 >= 16) {
#line 9694
        *(d___0 + 0) = clear_value;
#line 9694
        *(d___0 + 1) = clear_value;
#line 9695
        *(d___0 + 2) = clear_value;
#line 9695
        *(d___0 + 3) = clear_value;
#line 9696
        *(d___0 + 4) = clear_value;
#line 9696
        *(d___0 + 5) = clear_value;
#line 9697
        *(d___0 + 6) = clear_value;
#line 9697
        *(d___0 + 7) = clear_value;
#line 9698
        *(d___0 + 8) = clear_value;
#line 9698
        *(d___0 + 9) = clear_value;
#line 9699
        *(d___0 + 10) = clear_value;
#line 9699
        *(d___0 + 11) = clear_value;
#line 9700
        *(d___0 + 12) = clear_value;
#line 9700
        *(d___0 + 13) = clear_value;
#line 9701
        *(d___0 + 14) = clear_value;
#line 9701
        *(d___0 + 15) = clear_value;
#line 9702
        d___0 += 16;
#line 9703
        n___0 -= 16;
      }
#line 9705
      while (n___0 > 0) {
#line 9706
        tmp___1 = d___0;
#line 9706
        d___0 ++;
#line 9706
        *tmp___1 = clear_value;
#line 9707
        n___0 --;
      }
    }
  }
#line 9711
  return;
}
}
#line 9713 "D:/a/test/177.c"
void gl_alloc_depth_buffer(GLcontext *ctx ) 
{ void *tmp ;

  {
#line 9715
  if ((ctx->Buffer)->Depth) {
#line 9716
    free((void *)(ctx->Buffer)->Depth);
#line 9717
    (ctx->Buffer)->Depth = (GLdepth *)((void *)0);
  }
#line 9719
  tmp = malloc((unsigned int )((ctx->Buffer)->Width * (ctx->Buffer)->Height) * sizeof(GLdepth ));//22
#line 9719
  (ctx->Buffer)->Depth = (GLdepth *)tmp;
#line 9722
  if (! (ctx->Buffer)->Depth) {
#line 9723
    ctx->Depth.Test = (unsigned char)0;
#line 9724
    gl_error(ctx, 1285, "Couldn\'t allocate depth buffer");
  }
#line 9726
  return;
}
}
#line 9727 "D:/a/test/177.c"
GLuint gl_depth_test_span_less(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth const   *z ,
                               GLubyte *mask ) 
{ GLdepth *zptr ;
  int tmp ;
  GLuint i ;
  GLuint passed ;

  {
#line 9731
  tmp = Z_ADDRESS(ctx, x, y);
#line 9731
  zptr = (GLdepth *)tmp;
#line 9733
  passed = (GLuint )0;
#line 9734
  i = 0U;
#line 9734
  while (i < n) {
#line 9735
    if (*(mask + i)) {
#line 9736
      if ((int const   )*(z + i) < (int const   )*(zptr + i)) {
#line 9737
        *(zptr + i) = (unsigned short )*(z + i);
#line 9738
        passed ++;
      } else {
#line 9741
        *(mask + i) = (unsigned char)0;
      }
    }
#line 9734
    i ++;
  }
#line 9745
  return (passed);
}
}
#line 9747 "D:/a/test/177.c"
GLuint gl_depth_test_span_greater(GLcontext *ctx , GLuint n , GLint x , GLint y ,
                                  GLdepth const   *z , GLubyte *mask ) 
{ GLdepth *zptr ;
  int tmp ;
  GLuint i ;
  GLuint passed ;

  {
#line 9752
  tmp = Z_ADDRESS(ctx, x, y);
#line 9752
  zptr = (GLdepth *)tmp;
#line 9754
  passed = (GLuint )0;
#line 9755
  i = 0U;
#line 9755
  while (i < n) {
#line 9756
    if (*(mask + i)) {
#line 9757
      if ((int const   )*(z + i) > (int const   )*(zptr + i)) {
#line 9758
        *(zptr + i) = (unsigned short )*(z + i);
#line 9759
        passed ++;
      } else {
#line 9762
        *(mask + i) = (unsigned char)0;
      }
    }
#line 9755
    i ++;
  }
#line 9766
  return (passed);
}
}
#line 9771 "D:/a/test/177.c"
void gl_depth_test_pixels_generic(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                                  GLdepth const   *z , GLubyte *mask ) 
{ register GLdepth *zptr ;
  register GLuint i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 9777
  switch (ctx->Depth.Func) {
  case 513: 
#line 9779
  if (ctx->Depth.Mask) {
#line 9781
    i = 0U;
#line 9781
    while (i < n) {
#line 9782
      if (*(mask + i)) {
#line 9783
        tmp = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9783
        zptr = (GLdepth *)tmp;
#line 9784
        if ((int const   )*(z + i) < (int const   )*zptr) {
#line 9786
          *zptr = (unsigned short )*(z + i);
        } else {
#line 9790
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9781
      i ++;
    }
  } else {
#line 9797
    i = 0U;
#line 9797
    while (i < n) {
#line 9798
      if (*(mask + i)) {
#line 9799
        tmp___0 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9799
        zptr = (GLdepth *)tmp___0;
#line 9800
        if (! ((int const   )*(z + i) < (int const   )*zptr)) {
#line 9805
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9797
      i ++;
    }
  }
#line 9810
  break;
  case 515: 
#line 9812
  if (ctx->Depth.Mask) {
#line 9814
    i = 0U;
#line 9814
    while (i < n) {
#line 9815
      if (*(mask + i)) {
#line 9816
        tmp___1 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9816
        zptr = (GLdepth *)tmp___1;
#line 9817
        if ((int const   )*(z + i) <= (int const   )*zptr) {
#line 9819
          *zptr = (unsigned short )*(z + i);
        } else {
#line 9823
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9814
      i ++;
    }
  } else {
#line 9830
    i = 0U;
#line 9830
    while (i < n) {
#line 9831
      if (*(mask + i)) {
#line 9832
        tmp___2 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9832
        zptr = (GLdepth *)tmp___2;
#line 9833
        if (! ((int const   )*(z + i) <= (int const   )*zptr)) {
#line 9838
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9830
      i ++;
    }
  }
#line 9843
  break;
  case 518: 
#line 9845
  if (ctx->Depth.Mask) {
#line 9847
    i = 0U;
#line 9847
    while (i < n) {
#line 9848
      if (*(mask + i)) {
#line 9849
        tmp___3 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9849
        zptr = (GLdepth *)tmp___3;
#line 9850
        if ((int const   )*(z + i) >= (int const   )*zptr) {
#line 9852
          *zptr = (unsigned short )*(z + i);
        } else {
#line 9856
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9847
      i ++;
    }
  } else {
#line 9863
    i = 0U;
#line 9863
    while (i < n) {
#line 9864
      if (*(mask + i)) {
#line 9865
        tmp___4 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9865
        zptr = (GLdepth *)tmp___4;
#line 9866
        if (! ((int const   )*(z + i) >= (int const   )*zptr)) {
#line 9871
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9863
      i ++;
    }
  }
#line 9876
  break;
  case 516: 
#line 9878
  if (ctx->Depth.Mask) {
#line 9880
    i = 0U;
#line 9880
    while (i < n) {
#line 9881
      if (*(mask + i)) {
#line 9882
        tmp___5 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9882
        zptr = (GLdepth *)tmp___5;
#line 9883
        if ((int const   )*(z + i) > (int const   )*zptr) {
#line 9885
          *zptr = (unsigned short )*(z + i);
        } else {
#line 9889
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9880
      i ++;
    }
  } else {
#line 9896
    i = 0U;
#line 9896
    while (i < n) {
#line 9897
      if (*(mask + i)) {
#line 9898
        tmp___6 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9898
        zptr = (GLdepth *)tmp___6;
#line 9899
        if (! ((int const   )*(z + i) > (int const   )*zptr)) {
#line 9904
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9896
      i ++;
    }
  }
#line 9909
  break;
  case 517: 
#line 9911
  if (ctx->Depth.Mask) {
#line 9913
    i = 0U;
#line 9913
    while (i < n) {
#line 9914
      if (*(mask + i)) {
#line 9915
        tmp___7 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9915
        zptr = (GLdepth *)tmp___7;
#line 9916
        if ((int const   )*(z + i) != (int const   )*zptr) {
#line 9918
          *zptr = (unsigned short )*(z + i);
        } else {
#line 9922
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9913
      i ++;
    }
  } else {
#line 9929
    i = 0U;
#line 9929
    while (i < n) {
#line 9930
      if (*(mask + i)) {
#line 9931
        tmp___8 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9931
        zptr = (GLdepth *)tmp___8;
#line 9932
        if (! ((int const   )*(z + i) != (int const   )*zptr)) {
#line 9937
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9929
      i ++;
    }
  }
#line 9942
  break;
  case 514: 
#line 9944
  if (ctx->Depth.Mask) {
#line 9946
    i = 0U;
#line 9946
    while (i < n) {
#line 9947
      if (*(mask + i)) {
#line 9948
        tmp___9 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9948
        zptr = (GLdepth *)tmp___9;
#line 9949
        if ((int const   )*(z + i) == (int const   )*zptr) {
#line 9951
          *zptr = (unsigned short )*(z + i);
        } else {
#line 9955
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9946
      i ++;
    }
  } else {
#line 9962
    i = 0U;
#line 9962
    while (i < n) {
#line 9963
      if (*(mask + i)) {
#line 9964
        tmp___10 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9964
        zptr = (GLdepth *)tmp___10;
#line 9965
        if (! ((int const   )*(z + i) == (int const   )*zptr)) {
#line 9970
          *(mask + i) = (unsigned char)0;
        }
      }
#line 9962
      i ++;
    }
  }
#line 9975
  break;
  case 519: 
#line 9977
  if (ctx->Depth.Mask) {
#line 9979
    i = 0U;
#line 9979
    while (i < n) {
#line 9980
      if (*(mask + i)) {
#line 9981
        tmp___11 = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 9981
        zptr = (GLdepth *)tmp___11;
#line 9982
        *zptr = (unsigned short )*(z + i);
      }
#line 9979
      i ++;
    }
  }
#line 9989
  break;
  case 512: 
#line 9992
  i = 0U;
#line 9992
  while (i < n) {
#line 9993
    *(mask + i) = (unsigned char)0;
#line 9992
    i ++;
  }
#line 9995
  break;
  default: 
#line 9997
  gl_problem((GLcontext const   *)ctx, "Bad depth func in gl_depth_test_pixels_generic");
  }
#line 9999
  return;
}
}
#line 10000 "D:/a/test/177.c"
void gl_depth_test_pixels_less(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                               GLdepth const   *z , GLubyte *mask ) 
{ GLdepth *zptr ;
  GLuint i ;
  int tmp ;

  {
#line 10006
  i = 0U;
#line 10006
  while (i < n) {
#line 10007
    if (*(mask + i)) {
#line 10008
      tmp = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 10008
      zptr = (GLdepth *)tmp;
#line 10009
      if ((int const   )*(z + i) < (int const   )*zptr) {
#line 10010
        *zptr = (unsigned short )*(z + i);
      } else {
#line 10013
        *(mask + i) = (unsigned char)0;
      }
    }
#line 10006
    i ++;
  }
#line 10017
  return;
}
}
#line 10018 "D:/a/test/177.c"
void gl_depth_test_pixels_greater(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                                  GLdepth const   *z , GLubyte *mask ) 
{ GLdepth *zptr ;
  GLuint i ;
  int tmp ;

  {
#line 10024
  i = 0U;
#line 10024
  while (i < n) {
#line 10025
    if (*(mask + i)) {
#line 10026
      tmp = Z_ADDRESS(ctx, *(x + i), *(y + i));
#line 10026
      zptr = (GLdepth *)tmp;
#line 10027
      if ((int const   )*(z + i) > (int const   )*zptr) {
#line 10028
        *zptr = (unsigned short )*(z + i);
      } else {
#line 10031
        *(mask + i) = (unsigned char)0;
      }
    }
#line 10024
    i ++;
  }
#line 10035
  return;
}
}
#line 10036 "D:/a/test/177.c"
void gl_read_depth_span_float(GLcontext *ctx , GLuint n , GLint x , GLint y , float *depth ) 
{ GLdepth *zptr ;
  float scale ;
  GLuint i ;
  int tmp ;

  {
#line 10042
  scale = 1.0F / 65535.0F;
#line 10043
  if ((ctx->Buffer)->Depth) {
#line 10044
    tmp = Z_ADDRESS(ctx, x, y);
#line 10044
    zptr = (GLdepth *)tmp;
#line 10045
    i = 0U;
#line 10045
    while (i < n) {
#line 10046
      *(depth + i) = (float )*(zptr + i) * scale;
#line 10045
      i ++;
    }
  } else {
#line 10050
    i = 0U;
#line 10050
    while (i < n) {
#line 10051
      *(depth + i) = 0.0F;
#line 10050
      i ++;
    }
  }
#line 10054
  return;
}
}
#line 10055 "D:/a/test/177.c"
void gl_read_depth_span_int(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth *depth ) 
{ GLdepth *zptr ;
  int tmp ;
  GLuint i ;

  {
#line 10058
  if ((ctx->Buffer)->Depth) {
#line 10059
    tmp = Z_ADDRESS(ctx, x, y);
#line 10059
    zptr = (GLdepth *)tmp;
#line 10060
    memcpy((void *)depth, (void const   *)((void *)zptr), n * sizeof(GLdepth ));
  } else {
#line 10064
    i = 0U;
#line 10064
    while (i < n) {
#line 10065
      *(depth + i) = (unsigned short )0.0;
#line 10064
      i ++;
    }
  }
#line 10068
  return;
}
}
#line 10069 "D:/a/test/177.c"
GLuint gl_depth_test_span_generic(GLcontext *ctx , GLuint n , GLint x , GLint y ,
                                  GLdepth const   *z , GLubyte *mask ) 
{ GLdepth *zptr ;
  int tmp ;
  GLubyte *m ;
  GLuint i ;
  GLuint passed ;

  {
#line 10074
  tmp = Z_ADDRESS(ctx, x, y);
#line 10074
  zptr = (GLdepth *)tmp;
#line 10075
  m = mask;
#line 10077
  passed = (GLuint )0;
#line 10078
  switch (ctx->Depth.Func) {
  case 513: 
#line 10080
  if (ctx->Depth.Mask) {
#line 10082
    i = 0U;
#line 10082
    while (i < n) {
#line 10083
      if (*m) {
#line 10084
        if ((int const   )*(z + i) < (int const   )*zptr) {
#line 10086
          *zptr = (unsigned short )*(z + i);
#line 10087
          passed ++;
        } else {
#line 10091
          *m = (unsigned char)0;
        }
      }
#line 10082
      i ++;
#line 10082
      zptr ++;
#line 10082
      m ++;
    }
  } else {
#line 10098
    i = 0U;
#line 10098
    while (i < n) {
#line 10099
      if (*m) {
#line 10100
        if ((int const   )*(z + i) < (int const   )*zptr) {
#line 10102
          passed ++;
        } else {
#line 10105
          *m = (unsigned char)0;
        }
      }
#line 10098
      i ++;
#line 10098
      zptr ++;
#line 10098
      m ++;
    }
  }
#line 10110
  break;
  case 515: 
#line 10112
  if (ctx->Depth.Mask) {
#line 10114
    i = 0U;
#line 10114
    while (i < n) {
#line 10115
      if (*m) {
#line 10116
        if ((int const   )*(z + i) <= (int const   )*zptr) {
#line 10117
          *zptr = (unsigned short )*(z + i);
#line 10118
          passed ++;
        } else {
#line 10121
          *m = (unsigned char)0;
        }
      }
#line 10114
      i ++;
#line 10114
      zptr ++;
#line 10114
      m ++;
    }
  } else {
#line 10128
    i = 0U;
#line 10128
    while (i < n) {
#line 10129
      if (*m) {
#line 10130
        if ((int const   )*(z + i) <= (int const   )*zptr) {
#line 10132
          passed ++;
        } else {
#line 10135
          *m = (unsigned char)0;
        }
      }
#line 10128
      i ++;
#line 10128
      zptr ++;
#line 10128
      m ++;
    }
  }
#line 10140
  break;
  case 518: 
#line 10142
  if (ctx->Depth.Mask) {
#line 10144
    i = 0U;
#line 10144
    while (i < n) {
#line 10145
      if (*m) {
#line 10146
        if ((int const   )*(z + i) >= (int const   )*zptr) {
#line 10147
          *zptr = (unsigned short )*(z + i);
#line 10148
          passed ++;
        } else {
#line 10151
          *m = (unsigned char)0;
        }
      }
#line 10144
      i ++;
#line 10144
      zptr ++;
#line 10144
      m ++;
    }
  } else {
#line 10158
    i = 0U;
#line 10158
    while (i < n) {
#line 10159
      if (*m) {
#line 10160
        if ((int const   )*(z + i) >= (int const   )*zptr) {
#line 10162
          passed ++;
        } else {
#line 10165
          *m = (unsigned char)0;
        }
      }
#line 10158
      i ++;
#line 10158
      zptr ++;
#line 10158
      m ++;
    }
  }
#line 10170
  break;
  case 516: 
#line 10172
  if (ctx->Depth.Mask) {
#line 10174
    i = 0U;
#line 10174
    while (i < n) {
#line 10175
      if (*m) {
#line 10176
        if ((int const   )*(z + i) > (int const   )*zptr) {
#line 10177
          *zptr = (unsigned short )*(z + i);
#line 10178
          passed ++;
        } else {
#line 10181
          *m = (unsigned char)0;
        }
      }
#line 10174
      i ++;
#line 10174
      zptr ++;
#line 10174
      m ++;
    }
  } else {
#line 10188
    i = 0U;
#line 10188
    while (i < n) {
#line 10189
      if (*m) {
#line 10190
        if ((int const   )*(z + i) > (int const   )*zptr) {
#line 10192
          passed ++;
        } else {
#line 10195
          *m = (unsigned char)0;
        }
      }
#line 10188
      i ++;
#line 10188
      zptr ++;
#line 10188
      m ++;
    }
  }
#line 10200
  break;
  case 517: 
#line 10202
  if (ctx->Depth.Mask) {
#line 10204
    i = 0U;
#line 10204
    while (i < n) {
#line 10205
      if (*m) {
#line 10206
        if ((int const   )*(z + i) != (int const   )*zptr) {
#line 10207
          *zptr = (unsigned short )*(z + i);
#line 10208
          passed ++;
        } else {
#line 10211
          *m = (unsigned char)0;
        }
      }
#line 10204
      i ++;
#line 10204
      zptr ++;
#line 10204
      m ++;
    }
  } else {
#line 10218
    i = 0U;
#line 10218
    while (i < n) {
#line 10219
      if (*m) {
#line 10220
        if ((int const   )*(z + i) != (int const   )*zptr) {
#line 10222
          passed ++;
        } else {
#line 10225
          *m = (unsigned char)0;
        }
      }
#line 10218
      i ++;
#line 10218
      zptr ++;
#line 10218
      m ++;
    }
  }
#line 10230
  break;
  case 514: 
#line 10232
  if (ctx->Depth.Mask) {
#line 10234
    i = 0U;
#line 10234
    while (i < n) {
#line 10235
      if (*m) {
#line 10236
        if ((int const   )*(z + i) == (int const   )*zptr) {
#line 10237
          *zptr = (unsigned short )*(z + i);
#line 10238
          passed ++;
        } else {
#line 10241
          *m = (unsigned char)0;
        }
      }
#line 10234
      i ++;
#line 10234
      zptr ++;
#line 10234
      m ++;
    }
  } else {
#line 10248
    i = 0U;
#line 10248
    while (i < n) {
#line 10249
      if (*m) {
#line 10250
        if ((int const   )*(z + i) == (int const   )*zptr) {
#line 10252
          passed ++;
        } else {
#line 10255
          *m = (unsigned char)0;
        }
      }
#line 10248
      i ++;
#line 10248
      zptr ++;
#line 10248
      m ++;
    }
  }
#line 10260
  break;
  case 519: 
#line 10262
  if (ctx->Depth.Mask) {
#line 10264
    i = 0U;
#line 10264
    while (i < n) {
#line 10265
      if (*m) {
#line 10266
        *zptr = (unsigned short )*(z + i);
#line 10267
        passed ++;
      }
#line 10264
      i ++;
#line 10264
      zptr ++;
#line 10264
      m ++;
    }
  } else {
#line 10273
    passed = n;
  }
#line 10275
  break;
  case 512: 
#line 10277
  i = 0U;
#line 10277
  while (i < n) {
#line 10278
    *(mask + i) = (unsigned char)0;
#line 10277
    i ++;
  }
#line 10280
  break;
  default: 
#line 10282
  gl_problem((GLcontext const   *)ctx, "Bad depth func in gl_depth_test_span_generic");
  }
#line 10284
  return (passed);
}
}
#line 10300
void gl_update_lighting(GLcontext *ctx ) ;
#line 10301
void gl_set_color_function(GLcontext *ctx ) ;
#line 10304
void gl_update_texture_state(GLcontext *ctx ) ;
#line 10427
void gl_set_point_function(GLcontext *ctx ) ;
#line 10428
void gl_set_line_function(GLcontext *ctx ) ;
#line 10429
void gl_set_triangle_function(GLcontext *ctx ) ;
#line 10430
void gl_set_quad_function(GLcontext *ctx ) ;
#line 10431
void gl_set_vertex_function(GLcontext *ctx ) ;
#line 10286 "D:/a/test/177.c"
void gl_update_state(GLcontext *ctx ) 
{ GLboolean sphereGen ;
  int tmp ;
  int tmp___0 ;

  {
#line 10288
  if (ctx->NewState & 2U) {
#line 10289
    update_pixel_logic(ctx);
#line 10290
    update_pixel_masking(ctx);
#line 10291
    update_rasterflags(ctx);
#line 10292
    if (ctx->Driver.Dither) {
#line 10293
      (*(ctx->Driver.Dither))(ctx, ctx->Color.DitherFlag);
    }
  }
#line 10296
  if (ctx->NewState & 3U) {
#line 10297
    update_clipmask(ctx);
  }
#line 10299
  if (ctx->NewState & 1U) {
#line 10300
    gl_update_lighting(ctx);
#line 10301
    gl_set_color_function(ctx);
  }
#line 10303
  if (ctx->NewState & 4U) {
#line 10304
    gl_update_texture_state(ctx);
  }
#line 10306
  if (ctx->NewState & 5U) {
#line 10307
    if (ctx->Texture.Enabled) {
#line 10307
      if (ctx->Texture.GenModeS == 9218) {
#line 10307
        if (ctx->Texture.TexGenEnabled & 4U) {
#line 10307
          tmp = 1;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 10307
        if (ctx->Texture.GenModeT == 9218) {
#line 10307
          if (ctx->Texture.TexGenEnabled & 8U) {
#line 10307
            tmp = 1;
          } else {
#line 10307
            tmp = 0;
          }
        } else {
#line 10307
          tmp = 0;
        }
      }
    } else {
#line 10307
      tmp = 0;
    }
#line 10307
    sphereGen = (GLboolean )tmp;
#line 10312
    if (ctx->Light.Enabled) {
#line 10313
      ctx->NeedNormals = (unsigned char)1;
    } else {
#line 10312
      if (sphereGen) {
#line 10313
        ctx->NeedNormals = (unsigned char)1;
      } else {
#line 10316
        ctx->NeedNormals = (unsigned char)0;
      }
    }
  }
#line 10319
  if (ctx->NewState & 2U) {
#line 10320
    if (ctx->Fog.Enabled) {
#line 10325
      ctx->MutablePixels = (unsigned char)1;
    } else {
#line 10320
      if (ctx->Texture.Enabled) {
#line 10325
        ctx->MutablePixels = (unsigned char)1;
      } else {
#line 10320
        if (ctx->Color.BlendEnabled) {
#line 10325
          ctx->MutablePixels = (unsigned char)1;
        } else {
#line 10320
          if (ctx->Color.SWmasking) {
#line 10325
            ctx->MutablePixels = (unsigned char)1;
          } else {
#line 10320
            if (ctx->Color.SWLogicOpEnabled) {
#line 10325
              ctx->MutablePixels = (unsigned char)1;
            } else {
#line 10328
              ctx->MutablePixels = (unsigned char)0;
            }
          }
        }
      }
    }
  }
#line 10331
  if (ctx->NewState & 3U) {
#line 10332
    if (ctx->Light.ShadeModel == 7425) {
#line 10339
      ctx->MonoPixels = (unsigned char)0;
    } else {
#line 10332
      if (ctx->Light.Enabled) {
#line 10339
        ctx->MonoPixels = (unsigned char)0;
      } else {
#line 10332
        if (ctx->Fog.Enabled) {
#line 10339
          ctx->MonoPixels = (unsigned char)0;
        } else {
#line 10332
          if (ctx->Texture.Enabled) {
#line 10339
            ctx->MonoPixels = (unsigned char)0;
          } else {
#line 10332
            if (ctx->Color.BlendEnabled) {
#line 10339
              ctx->MonoPixels = (unsigned char)0;
            } else {
#line 10332
              if (ctx->Color.SWmasking) {
#line 10339
                ctx->MonoPixels = (unsigned char)0;
              } else {
#line 10332
                if (ctx->Color.SWLogicOpEnabled) {
#line 10339
                  ctx->MonoPixels = (unsigned char)0;
                } else {
#line 10342
                  ctx->MonoPixels = (unsigned char)1;
                }
              }
            }
          }
        }
      }
    }
  }
#line 10345
  if (ctx->NewState & 8U) {
#line 10346
    ctx->Polygon.CullBits = 0U;
#line 10347
    if (ctx->Polygon.CullFlag) {
#line 10348
      if (ctx->Polygon.CullFaceMode == 1028) {
#line 10350
        ctx->Polygon.CullBits |= 1U;
      } else {
#line 10348
        if (ctx->Polygon.CullFaceMode == 1032) {
#line 10350
          ctx->Polygon.CullBits |= 1U;
        }
      }
#line 10352
      if (ctx->Polygon.CullFaceMode == 1029) {
#line 10354
        ctx->Polygon.CullBits |= 2U;
      } else {
#line 10352
        if (ctx->Polygon.CullFaceMode == 1032) {
#line 10354
          ctx->Polygon.CullBits |= 2U;
        }
      }
    }
#line 10357
    if (ctx->Polygon.OffsetPoint) {
#line 10357
      tmp___0 = 1;
    } else {
#line 10357
      if (ctx->Polygon.OffsetLine) {
#line 10357
        tmp___0 = 1;
      } else {
#line 10357
        if (ctx->Polygon.OffsetFill) {
#line 10357
          tmp___0 = 1;
        } else {
#line 10357
          tmp___0 = 0;
        }
      }
    }
#line 10357
    ctx->Polygon.OffsetAny = (unsigned char )tmp___0;
#line 10360
    ctx->PointZoffset = (float )0.0;
#line 10361
    ctx->LineZoffset = (float )0.0;
#line 10362
    ctx->PolygonZoffset = (float )0.0;
  }
#line 10364
  if (ctx->NewState & 9U) {
#line 10365
    if (ctx->Polygon.Unfilled) {
#line 10370
      ctx->DirectTriangles = (unsigned char)0;
    } else {
#line 10365
      if (ctx->Polygon.OffsetAny) {
#line 10370
        ctx->DirectTriangles = (unsigned char)0;
      } else {
#line 10365
        if (ctx->Polygon.CullFlag) {
#line 10370
          ctx->DirectTriangles = (unsigned char)0;
        } else {
#line 10365
          if (ctx->Light.Model.TwoSide) {
#line 10370
            ctx->DirectTriangles = (unsigned char)0;
          } else {
#line 10365
            if (ctx->RenderMode != 7168) {
#line 10370
              ctx->DirectTriangles = (unsigned char)0;
            } else {
#line 10373
              ctx->DirectTriangles = (unsigned char)1;
            }
          }
        }
      }
    }
  }
#line 10376
  (ctx->Buffer)->Xmin = 0;
#line 10377
  (ctx->Buffer)->Ymin = 0;
#line 10378
  (ctx->Buffer)->Xmax = (ctx->Buffer)->Width - 1;
#line 10379
  (ctx->Buffer)->Ymax = (ctx->Buffer)->Height - 1;
#line 10380
  if (ctx->Scissor.Enabled) {
#line 10381
    if (ctx->Scissor.X > (ctx->Buffer)->Xmin) {
#line 10382
      (ctx->Buffer)->Xmin = ctx->Scissor.X;
    }
#line 10384
    if (ctx->Scissor.Y > (ctx->Buffer)->Ymin) {
#line 10385
      (ctx->Buffer)->Ymin = ctx->Scissor.Y;
    }
#line 10387
    if ((ctx->Scissor.X + ctx->Scissor.Width) - 1 < (ctx->Buffer)->Xmax) {
#line 10388
      (ctx->Buffer)->Xmax = (ctx->Scissor.X + ctx->Scissor.Width) - 1;
    }
#line 10390
    if ((ctx->Scissor.Y + ctx->Scissor.Height) - 1 < (ctx->Buffer)->Ymax) {
#line 10391
      (ctx->Buffer)->Ymax = (ctx->Scissor.Y + ctx->Scissor.Height) - 1;
    }
  }
#line 10394
  if (ctx->NewState & 2U) {
#line 10395
    ctx->Driver.AllocDepthBuffer = & gl_alloc_depth_buffer;
#line 10396
    ctx->Driver.ClearDepthBuffer = & gl_clear_depth_buffer;
#line 10397
    if (ctx->Depth.Mask) {
#line 10398
      switch (ctx->Depth.Func) {
      case 513: 
#line 10400
      ctx->Driver.DepthTestSpan = & gl_depth_test_span_less;
#line 10401
      ctx->Driver.DepthTestPixels = & gl_depth_test_pixels_less;
#line 10402
      break;
      case 516: 
#line 10404
      ctx->Driver.DepthTestSpan = & gl_depth_test_span_greater;
#line 10405
      ctx->Driver.DepthTestPixels = & gl_depth_test_pixels_greater;
#line 10406
      break;
      default: 
#line 10408
      ctx->Driver.DepthTestSpan = & gl_depth_test_span_generic;
#line 10409
      ctx->Driver.DepthTestPixels = & gl_depth_test_pixels_generic;
      }
    } else {
#line 10413
      ctx->Driver.DepthTestSpan = & gl_depth_test_span_generic;
#line 10414
      ctx->Driver.DepthTestPixels = & gl_depth_test_pixels_generic;
    }
#line 10416
    ctx->Driver.ReadDepthSpanFloat = & gl_read_depth_span_float;
#line 10417
    ctx->Driver.ReadDepthSpanInt = & gl_read_depth_span_int;
  }
#line 10419
  ctx->Driver.PointsFunc = (void (*)(GLcontext *ctx , GLuint first , GLuint last ))((void *)0);
#line 10420
  ctx->Driver.LineFunc = (void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ))((void *)0);
#line 10421
  ctx->Driver.TriangleFunc = (void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 ,
                                       GLuint pv ))((void *)0);
#line 10422
  ctx->Driver.QuadFunc = (void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 ,
                                   GLuint v4 , GLuint pv ))((void *)0);
#line 10423
  ctx->Driver.RectFunc = (void (*)(GLcontext *ctx , GLint x , GLint y , GLint width ,
                                   GLint height ))((void *)0);
#line 10424
  if (ctx->Driver.UpdateState) {
#line 10425
    (*(ctx->Driver.UpdateState))(ctx);
  }
#line 10427
  gl_set_point_function(ctx);
#line 10428
  gl_set_line_function(ctx);
#line 10429
  gl_set_triangle_function(ctx);
#line 10430
  gl_set_quad_function(ctx);
#line 10431
  gl_set_vertex_function(ctx);
#line 10432
  ctx->NewState = 0U;
#line 10433
  return;
}
}
#line 10535
void gl_write_zoomed_color_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth const   *z ,
                                GLubyte const   *red , GLubyte const   *green , GLubyte const   *blue___0 ,
                                GLubyte const   *alpha , GLint y0___0 ) ;
#line 10539
void gl_write_color_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth *z ,
                         GLubyte *r , GLubyte *g , GLubyte *b , GLubyte *a , GLenum primitive ) ;
#line 10439 "D:/a/test/177.c"
static void copy_rgb_pixels(GLcontext *ctx , GLint srcx , GLint srcy , GLint width ,
                            GLint height , GLint destx , GLint desty ) 
{ GLdepth zspan[640] ;
  GLubyte red[640] ;
  GLubyte green[640] ;
  GLubyte blue___0[640] ;
  GLubyte alpha[640] ;
  GLboolean scale_or_bias ;
  GLboolean quick_draw ;
  GLboolean zoom ;
  GLint sy ;
  GLint dy ;
  GLint stepy ;
  GLint i ;
  GLint j ;
  GLboolean setbuffer___0 ;
  int tmp ;
  GLint z ;
  float rbias ;
  float gbias ;
  float bbias ;
  float abias ;
  GLint rmax ;
  GLint gmax ;
  GLint bmax ;
  GLint amax ;
  GLint r ;
  GLint g ;
  GLint b ;
  GLint a ;
  GLint tmp___0 ;
  GLint tmp___1 ;
  GLint tmp___2 ;
  GLint tmp___3 ;
  float r___0 ;
  float g___0 ;
  float b___0 ;
  float a___0 ;
  GLint ir ;
  GLint ig ;
  GLint ib ;
  GLint ia ;

  {
#line 10452
  if (ctx->Pixel.ZoomX == 1.0F) {
#line 10452
    if (ctx->Pixel.ZoomY == 1.0F) {
#line 10453
      zoom = (unsigned char)0;
    } else {
#line 10456
      zoom = (unsigned char)1;
    }
  } else {
#line 10456
    zoom = (unsigned char)1;
  }
#line 10458
  if (srcy < desty) {
#line 10459
    sy = (srcy + height) - 1;
#line 10460
    dy = (desty + height) - 1;
#line 10461
    stepy = -1;
  } else {
#line 10464
    sy = srcy;
#line 10465
    dy = desty;
#line 10466
    stepy = 1;
  }
#line 10468
  if ((double )ctx->Pixel.RedScale != 1.0) {
#line 10468
    tmp = 1;
  } else {
#line 10468
    if ((double )ctx->Pixel.RedBias != 0.0) {
#line 10468
      tmp = 1;
    } else {
#line 10468
      if ((double )ctx->Pixel.GreenScale != 1.0) {
#line 10468
        tmp = 1;
      } else {
#line 10468
        if ((double )ctx->Pixel.GreenBias != 0.0) {
#line 10468
          tmp = 1;
        } else {
#line 10468
          if ((double )ctx->Pixel.BlueScale != 1.0) {
#line 10468
            tmp = 1;
          } else {
#line 10468
            if ((double )ctx->Pixel.BlueBias != 0.0) {
#line 10468
              tmp = 1;
            } else {
#line 10468
              if ((double )ctx->Pixel.AlphaScale != 1.0) {
#line 10468
                tmp = 1;
              } else {
#line 10468
                if ((double )ctx->Pixel.AlphaBias != 0.0) {
#line 10468
                  tmp = 1;
                } else {
#line 10468
                  tmp = 0;
                }
              }
            }
          }
        }
      }
    }
  }
#line 10468
  scale_or_bias = (unsigned char )tmp;
#line 10472
  if (ctx->Depth.Test) {
#line 10473
    z = (int )(ctx->Current.RasterPos[2] * 65535.0F);
#line 10474
    i = 0;
#line 10474
    while (i < width) {
#line 10475
      zspan[i] = (unsigned short )z;
#line 10474
      i ++;
    }
  }
#line 10478
  if (ctx->RasterMask == 0U) {
#line 10478
    if (! zoom) {
#line 10478
      if (destx >= 0) {
#line 10478
        if (destx + width <= (ctx->Buffer)->Width) {
#line 10480
          quick_draw = (unsigned char)1;
        } else {
#line 10483
          quick_draw = (unsigned char)0;
        }
      } else {
#line 10483
        quick_draw = (unsigned char)0;
      }
    } else {
#line 10483
      quick_draw = (unsigned char)0;
    }
  } else {
#line 10483
    quick_draw = (unsigned char)0;
  }
#line 10485
  setbuffer___0 = (unsigned char )(ctx->Pixel.ReadBuffer != ctx->Color.DrawBuffer);
#line 10486
  j = 0;
#line 10486
  while (j < height) {
#line 10487
    if (setbuffer___0) {
#line 10488
      (*(ctx->Driver.SetBuffer))(ctx, ctx->Pixel.ReadBuffer);
    }
#line 10490
    gl_read_color_span(ctx, width, srcx, sy, red, green, blue___0, alpha);
#line 10491
    if (scale_or_bias) {
#line 10492
      rbias = ctx->Pixel.RedBias * (ctx->Visual)->RedScale;
#line 10493
      gbias = ctx->Pixel.GreenBias * (ctx->Visual)->GreenScale;
#line 10494
      bbias = ctx->Pixel.BlueBias * (ctx->Visual)->BlueScale;
#line 10495
      abias = ctx->Pixel.AlphaBias * (ctx->Visual)->AlphaScale;
#line 10496
      rmax = (int )(ctx->Visual)->RedScale;
#line 10497
      gmax = (int )(ctx->Visual)->GreenScale;
#line 10498
      bmax = (int )(ctx->Visual)->BlueScale;
#line 10499
      amax = (int )(ctx->Visual)->AlphaScale;
#line 10500
      i = 0;
#line 10500
      while (i < width) {
#line 10501
        r = (GLint )((float )red[i] * ctx->Pixel.RedScale + rbias);
#line 10502
        g = (GLint )((float )green[i] * ctx->Pixel.GreenScale + gbias);
#line 10503
        b = (GLint )((float )blue___0[i] * ctx->Pixel.BlueScale + bbias);
#line 10504
        a = (GLint )((float )alpha[i] * ctx->Pixel.AlphaScale + abias);
#line 10505
        if (r < 0) {
#line 10505
          red[i] = (unsigned char)0;
        } else {
#line 10505
          if (r > rmax) {
#line 10505
            tmp___0 = rmax;
          } else {
#line 10505
            tmp___0 = r;
          }
#line 10505
          red[i] = (unsigned char )tmp___0;
        }
#line 10506
        if (g < 0) {
#line 10506
          green[i] = (unsigned char)0;
        } else {
#line 10506
          if (g > gmax) {
#line 10506
            tmp___1 = gmax;
          } else {
#line 10506
            tmp___1 = g;
          }
#line 10506
          green[i] = (unsigned char )tmp___1;
        }
#line 10507
        if (b < 0) {
#line 10507
          blue___0[i] = (unsigned char)0;
        } else {
#line 10507
          if (b > bmax) {
#line 10507
            tmp___2 = bmax;
          } else {
#line 10507
            tmp___2 = b;
          }
#line 10507
          blue___0[i] = (unsigned char )tmp___2;
        }
#line 10508
        if (a < 0) {
#line 10508
          alpha[i] = (unsigned char)0;
        } else {
#line 10508
          if (a > amax) {
#line 10508
            tmp___3 = amax;
          } else {
#line 10508
            tmp___3 = a;
          }
#line 10508
          alpha[i] = (unsigned char )tmp___3;
        }
#line 10500
        i ++;
      }
    }
#line 10511
    if (ctx->Pixel.MapColorFlag) {
#line 10512
      r___0 = (float )(ctx->Pixel.MapRtoRsize - 1) * (ctx->Visual)->InvRedScale;
#line 10513
      g___0 = (float )(ctx->Pixel.MapGtoGsize - 1) * (ctx->Visual)->InvGreenScale;
#line 10514
      b___0 = (float )(ctx->Pixel.MapBtoBsize - 1) * (ctx->Visual)->InvBlueScale;
#line 10515
      a___0 = (float )(ctx->Pixel.MapAtoAsize - 1) * (ctx->Visual)->InvAlphaScale;
#line 10516
      i = 0;
#line 10516
      while (i < width) {
#line 10517
        ir = (GLint )((float )red[i] * r___0);
#line 10518
        ig = (GLint )((float )green[i] * g___0);
#line 10519
        ib = (GLint )((float )blue___0[i] * b___0);
#line 10520
        ia = (GLint )((float )alpha[i] * a___0);
#line 10521
        red[i] = (unsigned char )((int )(ctx->Pixel.MapRtoR[ir] * (ctx->Visual)->RedScale));
#line 10522
        green[i] = (unsigned char )((int )(ctx->Pixel.MapGtoG[ig] * (ctx->Visual)->GreenScale));
#line 10523
        blue___0[i] = (unsigned char )((int )(ctx->Pixel.MapBtoB[ib] * (ctx->Visual)->BlueScale));
#line 10524
        alpha[i] = (unsigned char )((int )(ctx->Pixel.MapAtoA[ia] * (ctx->Visual)->AlphaScale));
#line 10516
        i ++;
      }
    }
#line 10527
    if (setbuffer___0) {
#line 10528
      (*(ctx->Driver.SetBuffer))(ctx, ctx->Color.DrawBuffer);
    }
#line 10530
    if (quick_draw) {
#line 10530
      if (dy >= 0) {
#line 10530
        if (dy < (ctx->Buffer)->Height) {
#line 10531
          (*(ctx->Driver.WriteColorSpan))(ctx, (unsigned int )width, destx, dy, (GLubyte const   *)(red),
                                          (GLubyte const   *)(green), (GLubyte const   *)(blue___0),
                                          (GLubyte const   *)(alpha), (GLubyte const   *)((void *)0));
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 10534
      if (zoom) {
#line 10535
        gl_write_zoomed_color_span(ctx, width, destx, dy, zspan, red, green, blue___0,
                                   alpha, desty);
      } else {
#line 10539
        gl_write_color_span(ctx, width, destx, dy, zspan, red, green, blue___0, alpha,
                            6656);
      }
    }
#line 10486
    j ++;
#line 10486
    sy += stepy;
#line 10486
    dy += stepy;
  }
#line 10548
  return;
}
}
#line 10585
void gl_read_index_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLuint *indx ) ;
#line 10611
void gl_write_zoomed_index_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth const   *z ,
                                GLuint const   *indexes , GLint y0___0 ) ;
#line 10614
void gl_write_index_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth *z ,
                         GLuint *index___0 , GLenum primitive ) ;
#line 10549 "D:/a/test/177.c"
static void copy_ci_pixels(GLcontext *ctx , GLint srcx , GLint srcy , GLint width ,
                           GLint height , GLint destx , GLint desty ) 
{ GLdepth zspan[640] ;
  GLuint indx[640] ;
  GLint sy ;
  GLint dy ;
  GLint stepy ;
  GLint i ;
  GLint j ;
  GLboolean setbuffer___0 ;
  GLboolean zoom ;
  GLint z ;

  {
#line 10558
  if (ctx->Pixel.ZoomX == 1.0F) {
#line 10558
    if (ctx->Pixel.ZoomY == 1.0F) {
#line 10559
      zoom = (unsigned char)0;
    } else {
#line 10562
      zoom = (unsigned char)1;
    }
  } else {
#line 10562
    zoom = (unsigned char)1;
  }
#line 10564
  if (srcy < desty) {
#line 10565
    sy = (srcy + height) - 1;
#line 10566
    dy = (desty + height) - 1;
#line 10567
    stepy = -1;
  } else {
#line 10570
    sy = srcy;
#line 10571
    dy = desty;
#line 10572
    stepy = 1;
  }
#line 10574
  if (ctx->Depth.Test) {
#line 10575
    z = (int )(ctx->Current.RasterPos[2] * 65535.0F);
#line 10576
    i = 0;
#line 10576
    while (i < width) {
#line 10577
      zspan[i] = (unsigned short )z;
#line 10576
      i ++;
    }
  }
#line 10580
  setbuffer___0 = (unsigned char )(ctx->Pixel.ReadBuffer != ctx->Color.DrawBuffer);
#line 10581
  j = 0;
#line 10581
  while (j < height) {
#line 10582
    if (setbuffer___0) {
#line 10583
      (*(ctx->Driver.SetBuffer))(ctx, ctx->Pixel.ReadBuffer);
    }
#line 10585
    gl_read_index_span(ctx, width, srcx, sy, indx);
#line 10586
    if (ctx->Pixel.IndexShift) {
      goto _L;
    } else {
#line 10586
      if (ctx->Pixel.IndexOffset) {
        _L: /* CIL Label */ 
#line 10587
        if (ctx->Pixel.IndexShift < 0) {
#line 10588
          i = 0;
#line 10588
          while (i < width) {
#line 10589
            indx[i] = (indx[i] >> - ctx->Pixel.IndexShift) + (GLuint )ctx->Pixel.IndexOffset;
#line 10588
            i ++;
          }
        } else {
#line 10594
          i = 0;
#line 10594
          while (i < width) {
#line 10595
            indx[i] = (indx[i] << ctx->Pixel.IndexShift) + (GLuint )ctx->Pixel.IndexOffset;
#line 10594
            i ++;
          }
        }
      }
    }
#line 10600
    if (ctx->Pixel.MapColorFlag) {
#line 10601
      i = 0;
#line 10601
      while (i < width) {
#line 10602
        if (indx[i] < (GLuint )ctx->Pixel.MapItoIsize) {
#line 10603
          indx[i] = (unsigned int )ctx->Pixel.MapItoI[indx[i]];
        }
#line 10601
        i ++;
      }
    }
#line 10607
    if (setbuffer___0) {
#line 10608
      (*(ctx->Driver.SetBuffer))(ctx, ctx->Color.DrawBuffer);
    }
#line 10610
    if (zoom) {
#line 10611
      gl_write_zoomed_index_span(ctx, width, destx, dy, zspan, indx, desty);
    } else {
#line 10614
      gl_write_index_span(ctx, width, destx, dy, zspan, indx, 6656);
    }
#line 10581
    j ++;
#line 10581
    sy += stepy;
#line 10581
    dy += stepy;
  }
#line 10617
  return;
}
}
#line 10618 "D:/a/test/177.c"
static void copy_depth_pixels(GLcontext *ctx , GLint srcx , GLint srcy , GLint width ,
                              GLint height , GLint destx , GLint desty ) 
{ float depth[640] ;
  GLdepth zspan[640] ;
  GLuint indx[640] ;
  GLubyte red[640] ;
  GLubyte green[640] ;
  GLubyte blue___0[640] ;
  GLubyte alpha[640] ;
  GLint sy ;
  GLint dy ;
  GLint stepy ;
  GLint i ;
  GLint j ;
  GLboolean zoom ;
  GLubyte r ;
  GLubyte g ;
  GLubyte b ;
  GLubyte a ;
  float d ;
  double tmp ;
  double tmp___0 ;

  {
#line 10630
  if (! (ctx->Buffer)->Depth) {
#line 10631
    gl_error(ctx, 1282, "glCopyPixels");
#line 10632
    return;
  }
#line 10634
  if (ctx->Pixel.ZoomX == 1.0F) {
#line 10634
    if (ctx->Pixel.ZoomY == 1.0F) {
#line 10635
      zoom = (unsigned char)0;
    } else {
#line 10638
      zoom = (unsigned char)1;
    }
  } else {
#line 10638
    zoom = (unsigned char)1;
  }
#line 10640
  if (srcy < desty) {
#line 10641
    sy = (srcy + height) - 1;
#line 10642
    dy = (desty + height) - 1;
#line 10643
    stepy = -1;
  } else {
#line 10646
    sy = srcy;
#line 10647
    dy = desty;
#line 10648
    stepy = 1;
  }
#line 10650
  if ((ctx->Visual)->RGBAflag) {
#line 10652
    r = ctx->Current.ByteColor[0];
#line 10653
    g = ctx->Current.ByteColor[1];
#line 10654
    b = ctx->Current.ByteColor[2];
#line 10655
    a = ctx->Current.ByteColor[3];
#line 10656
    memset((void *)(red), (int )r, (unsigned int )width);
#line 10657
    memset((void *)(green), (int )g, (unsigned int )width);
#line 10658
    memset((void *)(blue___0), (int )b, (unsigned int )width);
#line 10659
    memset((void *)(alpha), (int )a, (unsigned int )width);
  } else {
#line 10662
    i = 0;
#line 10662
    while (i < width) {
#line 10663
      indx[i] = ctx->Current.Index;
#line 10662
      i ++;
    }
  }
#line 10666
  j = 0;
#line 10666
  while (j < height) {
#line 10667
    (*(ctx->Driver.ReadDepthSpanFloat))(ctx, (unsigned int )width, srcx, sy, depth);
#line 10668
    i = 0;
#line 10668
    while (i < width) {
#line 10669
      d = depth[i] * ctx->Pixel.DepthScale + ctx->Pixel.DepthBias;
#line 10670
      if ((double )d < 0.0) {
#line 10670
        tmp___0 = 0.0;
      } else {
#line 10670
        if ((double )d > 1.0) {
#line 10670
          tmp = 1.0;
        } else {
#line 10670
          tmp = (double )d;
        }
#line 10670
        tmp___0 = tmp;
      }
#line 10670
      zspan[i] = (unsigned short )((int )(tmp___0 * (double )65535.0F));
#line 10668
      i ++;
    }
#line 10672
    if ((ctx->Visual)->RGBAflag) {
#line 10673
      if (zoom) {
#line 10674
        gl_write_zoomed_color_span(ctx, width, destx, dy, zspan, red, green, blue___0,
                                   alpha, desty);
      } else {
#line 10678
        gl_write_color_span(ctx, width, destx, dy, zspan, red, green, blue___0, alpha,
                            6656);
      }
    } else {
#line 10683
      if (zoom) {
#line 10684
        gl_write_zoomed_index_span(ctx, width, destx, dy, zspan, indx, desty);
      } else {
#line 10688
        gl_write_index_span(ctx, width, destx, dy, zspan, indx, 6656);
      }
    }
#line 10666
    j ++;
#line 10666
    sy += stepy;
#line 10666
    dy += stepy;
  }
#line 10693
  return;
}
}
#line 10723
void gl_read_stencil_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *stencil ) ;
#line 10744
void gl_write_zoomed_stencil_span(GLcontext *ctx , GLuint n , GLint x , GLint y ,
                                  GLubyte const   *stencil , GLint y0___0 ) ;
#line 10747
void gl_write_stencil_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte const   *stencil ) ;
#line 10694 "D:/a/test/177.c"
static void copy_stencil_pixels(GLcontext *ctx , GLint srcx , GLint srcy , GLint width ,
                                GLint height , GLint destx , GLint desty ) 
{ GLubyte stencil[640] ;
  GLint sy ;
  GLint dy ;
  GLint stepy ;
  GLint i ;
  GLint j ;
  GLboolean zoom ;

  {
#line 10702
  if (! (ctx->Buffer)->Stencil) {
#line 10703
    gl_error(ctx, 1282, "glCopyPixels");
#line 10704
    return;
  }
#line 10706
  if (ctx->Pixel.ZoomX == 1.0F) {
#line 10706
    if (ctx->Pixel.ZoomY == 1.0F) {
#line 10707
      zoom = (unsigned char)0;
    } else {
#line 10710
      zoom = (unsigned char)1;
    }
  } else {
#line 10710
    zoom = (unsigned char)1;
  }
#line 10712
  if (srcy < desty) {
#line 10713
    sy = (srcy + height) - 1;
#line 10714
    dy = (desty + height) - 1;
#line 10715
    stepy = -1;
  } else {
#line 10718
    sy = srcy;
#line 10719
    dy = desty;
#line 10720
    stepy = 1;
  }
#line 10722
  j = 0;
#line 10722
  while (j < height) {
#line 10723
    gl_read_stencil_span(ctx, width, srcx, sy, stencil);
#line 10724
    if (ctx->Pixel.IndexShift < 0) {
#line 10725
      i = 0;
#line 10725
      while (i < width) {
#line 10726
        stencil[i] = (unsigned char )(((int )stencil[i] >> - ctx->Pixel.IndexShift) + ctx->Pixel.IndexOffset);
#line 10725
        i ++;
      }
    } else {
#line 10731
      i = 0;
#line 10731
      while (i < width) {
#line 10732
        stencil[i] = (unsigned char )(((int )stencil[i] << ctx->Pixel.IndexShift) + ctx->Pixel.IndexOffset);
#line 10731
        i ++;
      }
    }
#line 10736
    if (ctx->Pixel.MapStencilFlag) {
#line 10737
      i = 0;
#line 10737
      while (i < width) {
#line 10738
        if ((int )stencil[i] < ctx->Pixel.MapStoSsize) {
#line 10739
          stencil[i] = (unsigned char )ctx->Pixel.MapStoS[stencil[i]];
        }
#line 10737
        i ++;
      }
    }
#line 10743
    if (zoom) {
#line 10744
      gl_write_zoomed_stencil_span(ctx, width, destx, dy, stencil, desty);
    } else {
#line 10747
      gl_write_stencil_span(ctx, width, destx, dy, stencil);
    }
#line 10722
    j ++;
#line 10722
    sy += stepy;
#line 10722
    dy += stepy;
  }
#line 10750
  return;
}
}
#line 10803
void gl_update_hitflag(GLcontext *ctx , float z ) ;
#line 10751 "D:/a/test/177.c"
void gl_CopyPixels(GLcontext *ctx , GLint srcx , GLint srcy , GLsizei width , GLsizei height ,
                   GLenum type ) 
{ GLint destx ;
  GLint desty ;
  float color[4] ;

  {
#line 10755
  if (ctx->Primitive != 6656) {
#line 10756
    gl_error(ctx, 1282, "glCopyPixels");
#line 10757
    return;
  }
#line 10759
  if (width < 0) {
#line 10760
    gl_error(ctx, 1281, "glCopyPixels");
#line 10761
    return;
  } else {
#line 10759
    if (height < 0) {
#line 10760
      gl_error(ctx, 1281, "glCopyPixels");
#line 10761
      return;
    }
  }
#line 10763
  if (ctx->NewState) {
#line 10764
    gl_update_state(ctx);
  }
#line 10766
  if (ctx->RenderMode == 7168) {
#line 10767
    if (! ctx->Current.RasterPosValid) {
#line 10768
      return;
    }
#line 10770
    destx = (int )(ctx->Current.RasterPos[0] + 0.5F);
#line 10771
    desty = (int )(ctx->Current.RasterPos[1] + 0.5F);
#line 10772
    if (type == 6144) {
#line 10772
      if ((ctx->Visual)->RGBAflag) {
#line 10773
        copy_rgb_pixels(ctx, srcx, srcy, width, height, destx, desty);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 10775
      if (type == 6144) {
#line 10775
        if (! (ctx->Visual)->RGBAflag) {
#line 10776
          copy_ci_pixels(ctx, srcx, srcy, width, height, destx, desty);
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 10778
        if (type == 6145) {
#line 10779
          copy_depth_pixels(ctx, srcx, srcy, width, height, destx, desty);
        } else {
#line 10781
          if (type == 6146) {
#line 10782
            copy_stencil_pixels(ctx, srcx, srcy, width, height, destx, desty);
          } else {
#line 10785
            gl_error(ctx, 1280, "glCopyPixels");
          }
        }
      }
    }
  } else {
#line 10788
    if (ctx->RenderMode == 7169) {
#line 10790
      color[0] = (float )ctx->Current.ByteColor[0] * (ctx->Visual)->InvRedScale;
#line 10791
      color[1] = (float )ctx->Current.ByteColor[1] * (ctx->Visual)->InvGreenScale;
#line 10792
      color[2] = (float )ctx->Current.ByteColor[2] * (ctx->Visual)->InvBlueScale;
#line 10793
      color[3] = (float )ctx->Current.ByteColor[3] * (ctx->Visual)->InvAlphaScale;
#line 10794
      FEEDBACK_TOKEN(ctx, (float )1798);
#line 10795
      gl_feedback_vertex(ctx, ctx->Current.RasterPos[0], ctx->Current.RasterPos[1],
                         ctx->Current.RasterPos[2], ctx->Current.RasterPos[3], color,
                         ctx->Current.Index, ctx->Current.TexCoord);
    } else {
#line 10802
      if (ctx->RenderMode == 7170) {
#line 10803
        gl_update_hitflag(ctx, ctx->Current.RasterPos[2]);
      }
    }
  }
#line 10805
  return;
}
}
#line 10811 "D:/a/test/177.c"
void gl_ClearDepth(GLcontext *ctx , GLclampd depth ) 
{ double tmp ;
  double tmp___0 ;

  {
#line 10813
  if (ctx->Primitive != 6656) {
#line 10814
    gl_error(ctx, 1282, "glClearDepth");
#line 10815
    return;
  }
#line 10817
  if (depth < 0.0) {
#line 10817
    tmp___0 = 0.0;
  } else {
#line 10817
    if (depth > 1.0) {
#line 10817
      tmp = 1.0;
    } else {
#line 10817
      tmp = depth;
    }
#line 10817
    tmp___0 = tmp;
  }
#line 10817
  ctx->Depth.Clear = (float )tmp___0;
#line 10818
  return;
}
}
#line 10819 "D:/a/test/177.c"
void gl_DepthFunc(GLcontext *ctx , GLenum func ) 
{ 

  {
#line 10821
  if (ctx->Primitive != 6656) {
#line 10822
    gl_error(ctx, 1282, "glDepthFunc");
#line 10823
    return;
  }
#line 10825
  switch (func) {
  case 512: 
  case 513: 
  case 518: 
  case 515: 
  case 516: 
  case 517: 
  case 514: 
  case 519: 
#line 10834
  ctx->Depth.Func = func;
#line 10835
  ctx->NewState |= 2U;
#line 10836
  break;
  default: 
#line 10838
  gl_error(ctx, 1280, "glDepth.Func");
  }
#line 10840
  return;
}
}
#line 10841 "D:/a/test/177.c"
void gl_DepthMask(GLcontext *ctx , GLboolean flag ) 
{ 

  {
#line 10843
  if (ctx->Primitive != 6656) {
#line 10844
    gl_error(ctx, 1282, "glDepthMask");
#line 10845
    return;
  }
#line 10847
  ctx->Depth.Mask = flag;
#line 10848
  ctx->NewState |= 2U;
#line 10849
  return;
}
}
#line 10850 "D:/a/test/177.c"
void gl_DepthRange(GLcontext *ctx , GLclampd nearval , GLclampd farval ) 
{ float n ;
  float f ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 10853
  if (ctx->Primitive != 6656) {
#line 10854
    gl_error(ctx, 1282, "glDepthRange");
#line 10855
    return;
  }
#line 10857
  if (nearval < 0.0) {
#line 10857
    tmp___0 = 0.0;
  } else {
#line 10857
    if (nearval > 1.0) {
#line 10857
      tmp = 1.0;
    } else {
#line 10857
      tmp = nearval;
    }
#line 10857
    tmp___0 = tmp;
  }
#line 10857
  n = (float )tmp___0;
#line 10858
  if (farval < 0.0) {
#line 10858
    tmp___2 = 0.0;
  } else {
#line 10858
    if (farval > 1.0) {
#line 10858
      tmp___1 = 1.0;
    } else {
#line 10858
      tmp___1 = farval;
    }
#line 10858
    tmp___2 = tmp___1;
  }
#line 10858
  f = (float )tmp___2;
#line 10859
  ctx->Viewport.Near = n;
#line 10860
  ctx->Viewport.Far = f;
#line 10861
  ctx->Viewport.Sz = (float )((double )65535.0F * ((double )(f - n) / 2.0));
#line 10862
  ctx->Viewport.Tz = (float )((double )65535.0F * ((double )(f - n) / 2.0 + (double )n));
#line 10863
  return;
}
}
#line 11006 "D:/a/test/177.c"
static GLuint InstSize[116]  ;
#line 11007 "D:/a/test/177.c"
static Node *CurrentListPtr  ;
#line 11008 "D:/a/test/177.c"
static GLuint CurrentListNum  ;
#line 11009 "D:/a/test/177.c"
static Node *CurrentBlock  ;
#line 11010 "D:/a/test/177.c"
static GLuint CurrentPos  ;
#line 11011 "D:/a/test/177.c"
static Node *alloc_instruction(GLcontext *ctx , OpCode opcode , GLint argcount ) 
{ Node *n ;
  Node *newblock ;
  GLuint count ;
  void *tmp ;

  {
#line 11014
  count = InstSize[opcode];
#line 11015
  ////assert(count == (GLuint )(argcount + 1));
#line 11016
  if ((CurrentPos + count) + 2U > 500U) {
#line 11017
    n = CurrentBlock + CurrentPos;
#line 11018
    (n + 0)->opcode = (enum __anonenum_OpCode_24 )114;
#line 11019
    tmp = malloc(sizeof(Node ) * 500U);//23
#line 11019
    newblock = (Node *)tmp;
#line 11020
    if (! newblock) {
#line 11021
      gl_error(ctx, 1285, "Building display list");
#line 11022
      return ((Node *)((void *)0));
    }
#line 11024
    (n + 1)->next = (void *)newblock;
#line 11025
    CurrentBlock = newblock;
#line 11026
    CurrentPos = 0U;
  }
#line 11028
  n = CurrentBlock + CurrentPos;
#line 11029
  CurrentPos += count;
#line 11030
  (n + 0)->opcode = opcode;
#line 11031
  return (n);
}
}
#line 11033 "D:/a/test/177.c"
static Node *make_empty_list(void) 
{ Node *n ;
  void *tmp ;

  {
#line 11035
  tmp = malloc(sizeof(Node ));//24
#line 11035
  n = (Node *)tmp;
#line 11036
  (n + 0)->opcode = (enum __anonenum_OpCode_24 )115;
#line 11037
  return (n);
  }
}
#line 11043
void *HashLookup(struct HashTable  const  *table , GLuint key ) ;
#line 11050
void gl_free_control_points(GLcontext *ctx , GLenum target , float *data ) ;
#line 11114
void HashRemove(struct HashTable *table , GLuint key ) ;
#line 11039 "D:/a/test/177.c"
void gl_destroy_list(GLcontext *ctx , GLuint list ) 
{ Node *n ;
  Node *block ;
  GLboolean done ;
  int tmp ;
  struct gl_image *image ;
  struct gl_image *image___0 ;

  {
#line 11043
  tmp = (int )HashLookup((ctx->Shared)->DisplayList, list);
#line 11043
  block = (Node *)tmp;
#line 11044
  n = block;
#line 11045
  if (block) {
#line 11045
    done = (unsigned char)0;
  } else {
#line 11045
    done = (unsigned char)1;
  }
#line 11046
  while (! done) {
#line 11047
    switch ((int )(n + 0)->opcode) {
    case 63: 
#line 11050
    gl_free_control_points(ctx, (n + 1)->e, (float *)(n + 6)->data);
#line 11051
    n += InstSize[(n + 0)->opcode];
#line 11052
    break;
    case 64: 
#line 11054
    gl_free_control_points(ctx, (n + 1)->e, (float *)(n + 10)->data);
#line 11055
    n += InstSize[(n + 0)->opcode];
#line 11056
    break;
    case 37: 
#line 11058
    free((n + 5)->data);
#line 11059
    n += InstSize[(n + 0)->opcode];
#line 11060
    break;
    case 4: 
#line 11062
    gl_free_image((struct gl_image *)(n + 7)->data);
#line 11063
    n += InstSize[(n + 0)->opcode];
#line 11064
    break;
    case 22: 
#line 11066
    gl_free_image((struct gl_image *)(n + 3)->data);
#line 11067
    n += InstSize[(n + 0)->opcode];
#line 11068
    break;
    case 23: 
#line 11070
    gl_free_image((struct gl_image *)(n + 3)->data);
#line 11071
    n += InstSize[(n + 0)->opcode];
#line 11072
    break;
    case 79: 
#line 11074
    free((n + 1)->data);
#line 11075
    n += InstSize[(n + 0)->opcode];
#line 11076
    break;
    case 102: 
#line 11078
    gl_free_image((struct gl_image *)(n + 8)->data);
#line 11079
    n += InstSize[(n + 0)->opcode];
#line 11080
    break;
    case 103: 
#line 11082
    gl_free_image((struct gl_image *)(n + 9)->data);
#line 11083
    n += InstSize[(n + 0)->opcode];
#line 11084
    break;
    case 105: 
#line 11088
    image = (struct gl_image *)(n + 7)->data;
#line 11089
    gl_free_image(image);
#line 11091
    break;
    case 106: 
#line 11095
    image___0 = (struct gl_image *)(n + 9)->data;
#line 11096
    gl_free_image(image___0);
#line 11098
    break;
    case 114: 
#line 11100
    n = (Node *)(n + 1)->next;
#line 11101
    free((void *)block);
#line 11102
    block = n;
#line 11103
    break;
    case 115: 
#line 11105
    free((void *)block);
#line 11106
    done = (unsigned char)1;
#line 11107
    break;
    default: 
#line 11110
    n += InstSize[(n + 0)->opcode];
#line 11111
    break;
    }
  }
#line 11114
  HashRemove((ctx->Shared)->DisplayList, list);
#line 11115
  return;
}
}
#line 11116 "D:/a/test/177.c"
static GLuint translate_id(GLsizei n , GLenum type , GLvoid const   *list ) 
{ GLbyte *bptr ;
  GLubyte *ubptr ;
  GLshort *sptr ;
  GLushort *usptr ;
  GLint *iptr ;
  GLuint *uiptr ;
  float *fptr ;

  {
#line 11125
  switch (type) {
  case 5120: 
#line 11127
  bptr = (GLbyte *)list;
#line 11128
  return ((unsigned int )*(bptr + n));
  case 5121: 
#line 11130
  ubptr = (GLubyte *)list;
#line 11131
  return ((unsigned int )*(ubptr + n));
  case 5122: 
#line 11133
  sptr = (GLshort *)list;
#line 11134
  return ((unsigned int )*(sptr + n));
  case 5123: 
#line 11136
  usptr = (GLushort *)list;
#line 11137
  return ((unsigned int )*(usptr + n));
  case 5124: 
#line 11139
  iptr = (GLint *)list;
#line 11140
  return ((unsigned int )*(iptr + n));
  case 5125: 
#line 11142
  uiptr = (GLuint *)list;
#line 11143
  return (*(uiptr + n));
  case 5126: 
#line 11145
  fptr = (float *)list;
#line 11146
  return ((unsigned int )*(fptr + n));
  case 5127: 
#line 11148
  ubptr = (GLubyte *)list + 2 * n;
#line 11149
  return ((unsigned int )*ubptr * 256U + (unsigned int )*(ubptr + 1));
  case 5128: 
#line 11151
  ubptr = (GLubyte *)list + 3 * n;
#line 11152
  return (((unsigned int )*ubptr * 65536U + (unsigned int )*(ubptr + 1) * 256U) + (unsigned int )*(ubptr + 2));
  case 5129: 
#line 11156
  ubptr = (GLubyte *)list + 4 * n;
#line 11157
  return ((((unsigned int )*ubptr * 16777216U + (unsigned int )*(ubptr + 1) * 65536U) + (unsigned int )*(ubptr + 2) * 256U) + (unsigned int )*(ubptr + 3));
  default: ;
#line 11162
  return (0U);
  }
}
}
#line 11167
void gl_init_lists(void) ;
#line 11167 "D:/a/test/177.c"
static int init_flag  =    0;
#line 11165 "D:/a/test/177.c"
void gl_init_lists(void) 
{ 

  {
#line 11168
  if (init_flag == 0) {
#line 11169
    CurrentBlock = (Node *)((void *)0);
#line 11169
    CurrentListPtr = CurrentBlock;
#line 11170
    CurrentListNum = 0U;
#line 11171
    InstSize[0] = 3U;
#line 11172
    InstSize[1] = 3U;
#line 11173
    InstSize[2] = 2U;
#line 11174
    InstSize[3] = 3U;
#line 11175
    InstSize[4] = 8U;
#line 11176
    InstSize[5] = 5U;
#line 11177
    InstSize[6] = 2U;
#line 11178
    InstSize[7] = 3U;
#line 11179
    InstSize[8] = 2U;
#line 11180
    InstSize[9] = 2U;
#line 11181
    InstSize[10] = 2U;
#line 11182
    InstSize[11] = 5U;
#line 11183
    InstSize[12] = 5U;
#line 11184
    InstSize[13] = 2U;
#line 11185
    InstSize[14] = 2U;
#line 11186
    InstSize[15] = 2U;
#line 11187
    InstSize[16] = 6U;
#line 11188
    InstSize[17] = 4U;
#line 11189
    InstSize[18] = 5U;
#line 11190
    InstSize[19] = 5U;
#line 11191
    InstSize[20] = 5U;
#line 11192
    InstSize[21] = 3U;
#line 11193
    InstSize[22] = 4U;
#line 11194
    InstSize[23] = 4U;
#line 11195
    InstSize[24] = 6U;
#line 11196
    InstSize[25] = 8U;
#line 11197
    InstSize[26] = 9U;
#line 11198
    InstSize[28] = 7U;
#line 11199
    InstSize[29] = 9U;
#line 11200
    InstSize[30] = 10U;
#line 11201
    InstSize[31] = 2U;
#line 11202
    InstSize[32] = 2U;
#line 11203
    InstSize[33] = 2U;
#line 11204
    InstSize[34] = 3U;
#line 11205
    InstSize[35] = 2U;
#line 11206
    InstSize[36] = 2U;
#line 11207
    InstSize[37] = 6U;
#line 11208
    InstSize[39] = 2U;
#line 11209
    InstSize[38] = 2U;
#line 11210
    InstSize[40] = 1U;
#line 11211
    InstSize[41] = 2U;
#line 11212
    InstSize[42] = 3U;
#line 11213
    InstSize[43] = 4U;
#line 11214
    InstSize[44] = 6U;
#line 11215
    InstSize[45] = 2U;
#line 11216
    InstSize[46] = 3U;
#line 11217
    InstSize[47] = 6U;
#line 11218
    InstSize[48] = 2U;
#line 11219
    InstSize[49] = 7U;
#line 11220
    InstSize[50] = 3U;
#line 11221
    InstSize[51] = 2U;
#line 11222
    InstSize[52] = 2U;
#line 11223
    InstSize[53] = 1U;
#line 11224
    InstSize[54] = 7U;
#line 11225
    InstSize[55] = 6U;
#line 11226
    InstSize[56] = 3U;
#line 11227
    InstSize[57] = 2U;
#line 11228
    InstSize[58] = 2U;
#line 11229
    InstSize[59] = 1U;
#line 11230
    InstSize[60] = 17U;
#line 11231
    InstSize[61] = 2U;
#line 11232
    InstSize[62] = 2U;
#line 11233
    InstSize[63] = 7U;
#line 11234
    InstSize[64] = 11U;
#line 11235
    InstSize[65] = 4U;
#line 11236
    InstSize[66] = 7U;
#line 11237
    InstSize[67] = 7U;
#line 11238
    InstSize[68] = 2U;
#line 11239
    InstSize[69] = 17U;
#line 11240
    InstSize[70] = 4U;
#line 11241
    InstSize[71] = 7U;
#line 11242
    InstSize[72] = 2U;
#line 11243
    InstSize[73] = 4U;
#line 11244
    InstSize[74] = 3U;
#line 11245
    InstSize[75] = 3U;
#line 11246
    InstSize[76] = 2U;
#line 11247
    InstSize[77] = 5U;
#line 11248
    InstSize[78] = 3U;
#line 11249
    InstSize[79] = 2U;
#line 11250
    InstSize[80] = 3U;
#line 11251
    InstSize[81] = 1U;
#line 11252
    InstSize[82] = 1U;
#line 11253
    InstSize[83] = 1U;
#line 11254
    InstSize[84] = 3U;
#line 11255
    InstSize[85] = 2U;
#line 11256
    InstSize[86] = 1U;
#line 11257
    InstSize[87] = 2U;
#line 11258
    InstSize[88] = 5U;
#line 11259
    InstSize[89] = 5U;
#line 11260
    InstSize[90] = 2U;
#line 11261
    InstSize[91] = 4U;
#line 11262
    InstSize[92] = 5U;
#line 11263
    InstSize[94] = 4U;
#line 11264
    InstSize[95] = 2U;
#line 11265
    InstSize[96] = 4U;
#line 11266
    InstSize[93] = 2U;
#line 11267
    InstSize[97] = 3U;
#line 11268
    InstSize[98] = 5U;
#line 11269
    InstSize[99] = 7U;
#line 11270
    InstSize[100] = 7U;
#line 11271
    InstSize[101] = 7U;
#line 11272
    InstSize[102] = 9U;
#line 11273
    InstSize[103] = 10U;
#line 11274
    InstSize[104] = 11U;
#line 11275
    InstSize[105] = 8U;
#line 11276
    InstSize[106] = 10U;
#line 11277
    InstSize[107] = 12U;
#line 11278
    InstSize[108] = 4U;
#line 11279
    InstSize[109] = 3U;
#line 11280
    InstSize[110] = 4U;
#line 11281
    InstSize[111] = 5U;
#line 11282
    InstSize[112] = 5U;
#line 11283
    InstSize[113] = 5U;
#line 11284
    InstSize[114] = 2U;
#line 11285
    InstSize[115] = 1U;
  }
#line 11287
  init_flag = 1;
#line 11288
  return;
}
}
#line 11289 "D:/a/test/177.c"
GLint gl_list_index(void) 
{ 

  {
#line 11291
  return ((int )CurrentListNum);
}
}
#line 11293 "D:/a/test/177.c"
void gl_save_Accum(GLcontext *ctx , GLenum op , float value ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11295
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )0, 2);
#line 11295
  n = tmp;
#line 11296
  if (n) {
#line 11297
    (n + 1)->e = op;
#line 11298
    (n + 2)->f = value;
  }
#line 11300
  if (ctx->ExecuteFlag) {
#line 11301
    (*(ctx->Exec.Accum))(ctx, op, value);
  }
#line 11303
  return;
}
}
#line 11304 "D:/a/test/177.c"
void gl_save_AlphaFunc(GLcontext *ctx , GLenum func , GLclampf ref ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11306
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )1, 2);
#line 11306
  n = tmp;
#line 11307
  if (n) {
#line 11308
    (n + 1)->e = func;
#line 11309
    (n + 2)->f = ref;
  }
#line 11311
  if (ctx->ExecuteFlag) {
#line 11312
    (*(ctx->Exec.AlphaFunc))(ctx, func, ref);
  }
#line 11314
  return;
}
}
#line 11315 "D:/a/test/177.c"
void gl_save_Begin(GLcontext *ctx , GLenum mode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11317
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )2, 1);
#line 11317
  n = tmp;
#line 11318
  if (n) {
#line 11319
    (n + 1)->e = mode;
  }
#line 11321
  if (ctx->ExecuteFlag) {
#line 11322
    (*(ctx->Exec.Begin))(ctx, mode);
  }
#line 11324
  return;
}
}
#line 11325 "D:/a/test/177.c"
void gl_save_BindTexture(GLcontext *ctx , GLenum target , GLuint texture ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11327
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )3, 2);
#line 11327
  n = tmp;
#line 11328
  if (n) {
#line 11329
    (n + 1)->e = target;
#line 11330
    (n + 2)->ui = texture;
  }
#line 11332
  if (ctx->ExecuteFlag) {
#line 11333
    (*(ctx->Exec.BindTexture))(ctx, target, texture);
  }
#line 11335
  return;
}
}
#line 11336 "D:/a/test/177.c"
void gl_save_Bitmap(GLcontext *ctx , GLsizei width , GLsizei height , float xorig ,
                    float yorig , float xmove , float ymove , struct gl_image  const  *bitmap ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11342
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )4, 7);
#line 11342
  n = tmp;
#line 11343
  if (n) {
#line 11344
    (n + 1)->i = width;
#line 11345
    (n + 2)->i = height;
#line 11346
    (n + 3)->f = xorig;
#line 11347
    (n + 4)->f = yorig;
#line 11348
    (n + 5)->f = xmove;
#line 11349
    (n + 6)->f = ymove;
#line 11350
    (n + 7)->data = (void *)bitmap;
  }
#line 11352
  if (ctx->ExecuteFlag) {
#line 11353
    (*(ctx->Exec.Bitmap))(ctx, width, height, xorig, yorig, xmove, ymove, bitmap);
  }
#line 11356
  return;
}
}
#line 11357 "D:/a/test/177.c"
void gl_save_BlendEquation(GLcontext *ctx , GLenum mode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11359
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )6, 1);
#line 11359
  n = tmp;
#line 11360
  if (n) {
#line 11361
    (n + 1)->e = mode;
  }
#line 11363
  if (ctx->ExecuteFlag) {
#line 11364
    (*(ctx->Exec.BlendEquation))(ctx, mode);
  }
#line 11366
  return;
}
}
#line 11367 "D:/a/test/177.c"
void gl_save_BlendFunc(GLcontext *ctx , GLenum sfactor , GLenum dfactor ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11369
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )7, 2);
#line 11369
  n = tmp;
#line 11370
  if (n) {
#line 11371
    (n + 1)->e = sfactor;
#line 11372
    (n + 2)->e = dfactor;
  }
#line 11374
  if (ctx->ExecuteFlag) {
#line 11375
    (*(ctx->Exec.BlendFunc))(ctx, sfactor, dfactor);
  }
#line 11377
  return;
}
}
#line 11378 "D:/a/test/177.c"
void gl_save_BlendColor(GLcontext *ctx , float red , float green , float blue___0 ,
                        float alpha ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11381
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )5, 4);
#line 11381
  n = tmp;
#line 11382
  if (n) {
#line 11383
    (n + 1)->f = red;
#line 11384
    (n + 2)->f = green;
#line 11385
    (n + 3)->f = blue___0;
#line 11386
    (n + 4)->f = alpha;
  }
#line 11388
  if (ctx->ExecuteFlag) {
#line 11389
    (*(ctx->Exec.BlendColor))(ctx, red, green, blue___0, alpha);
  }
#line 11391
  return;
}
}
#line 11392 "D:/a/test/177.c"
void gl_save_CallList(GLcontext *ctx , GLuint list ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11394
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )8, 1);
#line 11394
  n = tmp;
#line 11395
  if (n) {
#line 11396
    (n + 1)->ui = list;
  }
#line 11398
  if (ctx->ExecuteFlag) {
#line 11399
    (*(ctx->Exec.CallList))(ctx, list);
  }
#line 11401
  return;
}
}
#line 11402 "D:/a/test/177.c"
void gl_save_CallLists(GLcontext *ctx , GLsizei n , GLenum type , GLvoid const   *lists ) 
{ GLuint i ;
  GLuint list ;
  GLuint tmp ;
  Node *n___0 ;
  Node *tmp___0 ;

  {
#line 11406
  i = 0U;
#line 11406
  while (i < (GLuint )n) {
#line 11407
    tmp = translate_id((int )i, type, lists);
#line 11407
    list = tmp;
#line 11408
    tmp___0 = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )9, 1);
#line 11408
    n___0 = tmp___0;
#line 11409
    if (n___0) {
#line 11410
      (n___0 + 1)->ui = list;
    }
#line 11406
    i ++;
  }
#line 11413
  if (ctx->ExecuteFlag) {
#line 11414
    (*(ctx->Exec.CallLists))(ctx, n, type, lists);
  }
#line 11416
  return;
}
}
#line 11417 "D:/a/test/177.c"
void gl_save_Clear(GLcontext *ctx , GLbitfield mask ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11419
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )10, 1);
#line 11419
  n = tmp;
#line 11420
  if (n) {
#line 11421
    (n + 1)->bf = mask;
  }
#line 11423
  if (ctx->ExecuteFlag) {
#line 11424
    (*(ctx->Exec.Clear))(ctx, mask);
  }
#line 11426
  return;
}
}
#line 11427 "D:/a/test/177.c"
void gl_save_ClearAccum(GLcontext *ctx , float red , float green , float blue___0 ,
                        float alpha ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11430
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )11, 4);
#line 11430
  n = tmp;
#line 11431
  if (n) {
#line 11432
    (n + 1)->f = red;
#line 11433
    (n + 2)->f = green;
#line 11434
    (n + 3)->f = blue___0;
#line 11435
    (n + 4)->f = alpha;
  }
#line 11437
  if (ctx->ExecuteFlag) {
#line 11438
    (*(ctx->Exec.ClearAccum))(ctx, red, green, blue___0, alpha);
  }
#line 11440
  return;
}
}
#line 11441 "D:/a/test/177.c"
void gl_save_ClearColor(GLcontext *ctx , GLclampf red , GLclampf green , GLclampf blue___0 ,
                        GLclampf alpha ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11444
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )12, 4);
#line 11444
  n = tmp;
#line 11445
  if (n) {
#line 11446
    (n + 1)->f = red;
#line 11447
    (n + 2)->f = green;
#line 11448
    (n + 3)->f = blue___0;
#line 11449
    (n + 4)->f = alpha;
  }
#line 11451
  if (ctx->ExecuteFlag) {
#line 11452
    (*(ctx->Exec.ClearColor))(ctx, red, green, blue___0, alpha);
  }
#line 11454
  return;
}
}
#line 11455 "D:/a/test/177.c"
void gl_save_ClearDepth(GLcontext *ctx , GLclampd depth ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11457
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )13, 1);
#line 11457
  n = tmp;
#line 11458
  if (n) {
#line 11459
    (n + 1)->f = (float )depth;
  }
#line 11461
  if (ctx->ExecuteFlag) {
#line 11462
    (*(ctx->Exec.ClearDepth))(ctx, depth);
  }
#line 11464
  return;
}
}
#line 11465 "D:/a/test/177.c"
void gl_save_ClearIndex(GLcontext *ctx , float c ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11467
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )14, 1);
#line 11467
  n = tmp;
#line 11468
  if (n) {
#line 11469
    (n + 1)->f = c;
  }
#line 11471
  if (ctx->ExecuteFlag) {
#line 11472
    (*(ctx->Exec.ClearIndex))(ctx, c);
  }
#line 11474
  return;
}
}
#line 11475 "D:/a/test/177.c"
void gl_save_ClearStencil(GLcontext *ctx , GLint s ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11477
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )15, 1);
#line 11477
  n = tmp;
#line 11478
  if (n) {
#line 11479
    (n + 1)->i = s;
  }
#line 11481
  if (ctx->ExecuteFlag) {
#line 11482
    (*(ctx->Exec.ClearStencil))(ctx, s);
  }
#line 11484
  return;
}
}
#line 11485 "D:/a/test/177.c"
void gl_save_ClipPlane(GLcontext *ctx , GLenum plane , float const   *equ ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11487
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )16, 5);
#line 11487
  n = tmp;
#line 11488
  if (n) {
#line 11489
    (n + 1)->e = plane;
#line 11490
    (n + 2)->f = (float )*(equ + 0);
#line 11491
    (n + 3)->f = (float )*(equ + 1);
#line 11492
    (n + 4)->f = (float )*(equ + 2);
#line 11493
    (n + 5)->f = (float )*(equ + 3);
  }
#line 11495
  if (ctx->ExecuteFlag) {
#line 11496
    (*(ctx->Exec.ClipPlane))(ctx, plane, equ);
  }
#line 11498
  return;
}
}
#line 11499 "D:/a/test/177.c"
void gl_save_Color3f(GLcontext *ctx , float r , float g , float b ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11501
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )17, 3);
#line 11501
  n = tmp;
#line 11502
  if (n) {
#line 11503
    (n + 1)->f = r;
#line 11504
    (n + 2)->f = g;
#line 11505
    (n + 3)->f = b;
  }
#line 11507
  if (ctx->ExecuteFlag) {
#line 11508
    (*(ctx->Exec.Color3f))(ctx, r, g, b);
  }
#line 11510
  return;
}
}
#line 11511 "D:/a/test/177.c"
void gl_save_Color3fv(GLcontext *ctx , float const   *c ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11513
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )17, 3);
#line 11513
  n = tmp;
#line 11514
  if (n) {
#line 11515
    (n + 1)->f = (float )*(c + 0);
#line 11516
    (n + 2)->f = (float )*(c + 1);
#line 11517
    (n + 3)->f = (float )*(c + 2);
  }
#line 11519
  if (ctx->ExecuteFlag) {
#line 11520
    (*(ctx->Exec.Color3fv))(ctx, c);
  }
#line 11522
  return;
}
}
#line 11523 "D:/a/test/177.c"
void gl_save_Color4f(GLcontext *ctx , float r , float g , float b , float a ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11526
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )18, 4);
#line 11526
  n = tmp;
#line 11527
  if (n) {
#line 11528
    (n + 1)->f = r;
#line 11529
    (n + 2)->f = g;
#line 11530
    (n + 3)->f = b;
#line 11531
    (n + 4)->f = a;
  }
#line 11533
  if (ctx->ExecuteFlag) {
#line 11534
    (*(ctx->Exec.Color4f))(ctx, r, g, b, a);
  }
#line 11536
  return;
}
}
#line 11537 "D:/a/test/177.c"
void gl_save_Color4fv(GLcontext *ctx , float const   *c ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11539
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )18, 4);
#line 11539
  n = tmp;
#line 11540
  if (n) {
#line 11541
    (n + 1)->f = (float )*(c + 0);
#line 11542
    (n + 2)->f = (float )*(c + 1);
#line 11543
    (n + 3)->f = (float )*(c + 2);
#line 11544
    (n + 4)->f = (float )*(c + 3);
  }
#line 11546
  if (ctx->ExecuteFlag) {
#line 11547
    (*(ctx->Exec.Color4fv))(ctx, c);
  }
#line 11549
  return;
}
}
#line 11550 "D:/a/test/177.c"
void gl_save_Color4ub(GLcontext *ctx , GLubyte r , GLubyte g , GLubyte b , GLubyte a ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11553
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )19, 4);
#line 11553
  n = tmp;
#line 11554
  if (n) {
#line 11555
    (n + 1)->ub = r;
#line 11556
    (n + 2)->ub = g;
#line 11557
    (n + 3)->ub = b;
#line 11558
    (n + 4)->ub = a;
  }
#line 11560
  if (ctx->ExecuteFlag) {
#line 11561
    (*(ctx->Exec.Color4ub))(ctx, r, g, b, a);
  }
#line 11563
  return;
}
}
#line 11564 "D:/a/test/177.c"
void gl_save_Color4ubv(GLcontext *ctx , GLubyte const   *c ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11566
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )19, 4);
#line 11566
  n = tmp;
#line 11567
  if (n) {
#line 11568
    (n + 1)->ub = (unsigned char )*(c + 0);
#line 11569
    (n + 2)->ub = (unsigned char )*(c + 1);
#line 11570
    (n + 3)->ub = (unsigned char )*(c + 2);
#line 11571
    (n + 4)->ub = (unsigned char )*(c + 3);
  }
#line 11573
  if (ctx->ExecuteFlag) {
#line 11574
    (*(ctx->Exec.Color4ubv))(ctx, c);
  }
#line 11576
  return;
}
}
#line 11577 "D:/a/test/177.c"
void gl_save_ColorMask(GLcontext *ctx , GLboolean red , GLboolean green , GLboolean blue___0 ,
                       GLboolean alpha ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11580
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )20, 4);
#line 11580
  n = tmp;
#line 11581
  if (n) {
#line 11582
    (n + 1)->b = red;
#line 11583
    (n + 2)->b = green;
#line 11584
    (n + 3)->b = blue___0;
#line 11585
    (n + 4)->b = alpha;
  }
#line 11587
  if (ctx->ExecuteFlag) {
#line 11588
    (*(ctx->Exec.ColorMask))(ctx, red, green, blue___0, alpha);
  }
#line 11590
  return;
}
}
#line 11591 "D:/a/test/177.c"
void gl_save_ColorMaterial(GLcontext *ctx , GLenum face , GLenum mode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11593
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )21, 2);
#line 11593
  n = tmp;
#line 11594
  if (n) {
#line 11595
    (n + 1)->e = face;
#line 11596
    (n + 2)->e = mode;
  }
#line 11598
  if (ctx->ExecuteFlag) {
#line 11599
    (*(ctx->Exec.ColorMaterial))(ctx, face, mode);
  }
#line 11601
  return;
}
}
#line 11602 "D:/a/test/177.c"
void gl_save_ColorTable(GLcontext *ctx , GLenum target , GLenum internalFormat , struct gl_image *table ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11605
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )22, 3);
#line 11605
  n = tmp;
#line 11606
  if (n) {
#line 11607
    (n + 1)->e = target;
#line 11608
    (n + 2)->e = internalFormat;
#line 11609
    (n + 3)->data = (GLvoid *)table;
#line 11610
    if (table) {
#line 11611
      table->RefCount = 1;
    }
  }
#line 11614
  if (ctx->ExecuteFlag) {
#line 11615
    (*(ctx->Exec.ColorTable))(ctx, target, internalFormat, table);
  }
#line 11617
  return;
}
}
#line 11618 "D:/a/test/177.c"
void gl_save_ColorSubTable(GLcontext *ctx , GLenum target , GLsizei start , struct gl_image *data ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11621
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )23, 3);
#line 11621
  n = tmp;
#line 11622
  if (n) {
#line 11623
    (n + 1)->e = target;
#line 11624
    (n + 2)->i = start;
#line 11625
    (n + 3)->data = (GLvoid *)data;
#line 11626
    if (data) {
#line 11627
      data->RefCount = 1;
    }
  }
#line 11630
  if (ctx->ExecuteFlag) {
#line 11631
    (*(ctx->Exec.ColorSubTable))(ctx, target, start, data);
  }
#line 11633
  return;
}
}
#line 11634 "D:/a/test/177.c"
void gl_save_CopyPixels(GLcontext *ctx , GLint x , GLint y , GLsizei width , GLsizei height ,
                        GLenum type ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11637
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )24, 5);
#line 11637
  n = tmp;
#line 11638
  if (n) {
#line 11639
    (n + 1)->i = x;
#line 11640
    (n + 2)->i = y;
#line 11641
    (n + 3)->i = width;
#line 11642
    (n + 4)->i = height;
#line 11643
    (n + 5)->e = type;
  }
#line 11645
  if (ctx->ExecuteFlag) {
#line 11646
    (*(ctx->Exec.CopyPixels))(ctx, x, y, width, height, type);
  }
#line 11648
  return;
}
}
#line 11649 "D:/a/test/177.c"
void gl_save_CopyTexImage1D(GLcontext *ctx , GLenum target , GLint level , GLenum internalformat ,
                            GLint x , GLint y , GLsizei width , GLint border ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11655
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )25, 7);
#line 11655
  n = tmp;
#line 11656
  if (n) {
#line 11657
    (n + 1)->e = target;
#line 11658
    (n + 2)->i = level;
#line 11659
    (n + 3)->e = internalformat;
#line 11660
    (n + 4)->i = x;
#line 11661
    (n + 5)->i = y;
#line 11662
    (n + 6)->i = width;
#line 11663
    (n + 7)->i = border;
  }
#line 11665
  if (ctx->ExecuteFlag) {
#line 11666
    (*(ctx->Exec.CopyTexImage1D))(ctx, target, level, internalformat, x, y, width,
                                  border);
  }
#line 11669
  return;
}
}
#line 11670 "D:/a/test/177.c"
void gl_save_CopyTexImage2D(GLcontext *ctx , GLenum target , GLint level , GLenum internalformat ,
                            GLint x , GLint y , GLsizei width , GLsizei height , GLint border ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11676
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )26, 8);
#line 11676
  n = tmp;
#line 11677
  if (n) {
#line 11678
    (n + 1)->e = target;
#line 11679
    (n + 2)->i = level;
#line 11680
    (n + 3)->e = internalformat;
#line 11681
    (n + 4)->i = x;
#line 11682
    (n + 5)->i = y;
#line 11683
    (n + 6)->i = width;
#line 11684
    (n + 7)->i = height;
#line 11685
    (n + 8)->i = border;
  }
#line 11687
  if (ctx->ExecuteFlag) {
#line 11688
    (*(ctx->Exec.CopyTexImage2D))(ctx, target, level, internalformat, x, y, width,
                                  height, border);
  }
#line 11691
  return;
}
}
#line 11692 "D:/a/test/177.c"
void gl_save_CopyTexSubImage1D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                               GLint x , GLint y , GLsizei width ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11697
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )28, 6);
#line 11697
  n = tmp;
#line 11698
  if (n) {
#line 11699
    (n + 1)->e = target;
#line 11700
    (n + 2)->i = level;
#line 11701
    (n + 3)->i = xoffset;
#line 11702
    (n + 4)->i = x;
#line 11703
    (n + 5)->i = y;
#line 11704
    (n + 6)->i = width;
  }
#line 11706
  if (ctx->ExecuteFlag) {
#line 11707
    (*(ctx->Exec.CopyTexSubImage1D))(ctx, target, level, xoffset, x, y, width);
  }
#line 11709
  return;
}
}
#line 11710 "D:/a/test/177.c"
void gl_save_CopyTexSubImage2D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                               GLint yoffset , GLint x , GLint y , GLsizei width ,
                               GLint height ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11716
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )29, 8);
#line 11716
  n = tmp;
#line 11717
  if (n) {
#line 11718
    (n + 1)->e = target;
#line 11719
    (n + 2)->i = level;
#line 11720
    (n + 3)->i = xoffset;
#line 11721
    (n + 4)->i = yoffset;
#line 11722
    (n + 5)->i = x;
#line 11723
    (n + 6)->i = y;
#line 11724
    (n + 7)->i = width;
#line 11725
    (n + 8)->i = height;
  }
#line 11727
  if (ctx->ExecuteFlag) {
#line 11728
    (*(ctx->Exec.CopyTexSubImage2D))(ctx, target, level, xoffset, yoffset, x, y, width,
                                     height);
  }
#line 11731
  return;
}
}
#line 11732 "D:/a/test/177.c"
void gl_save_CopyTexSubImage3DEXT(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                                  GLint yoffset , GLint zoffset , GLint x , GLint y ,
                                  GLsizei width , GLint height ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11738
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )30, 9);
#line 11738
  n = tmp;
#line 11739
  if (n) {
#line 11740
    (n + 1)->e = target;
#line 11741
    (n + 2)->i = level;
#line 11742
    (n + 3)->i = xoffset;
#line 11743
    (n + 4)->i = yoffset;
#line 11744
    (n + 5)->i = zoffset;
#line 11745
    (n + 6)->i = x;
#line 11746
    (n + 7)->i = y;
#line 11747
    (n + 8)->i = width;
#line 11748
    (n + 9)->i = height;
  }
#line 11750
  if (ctx->ExecuteFlag) {
#line 11751
    (*(ctx->Exec.CopyTexSubImage3DEXT))(ctx, target, level, xoffset, yoffset, zoffset,
                                        x, y, width, height);
  }
#line 11754
  return;
}
}
#line 11755 "D:/a/test/177.c"
void gl_save_CullFace(GLcontext *ctx , GLenum mode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11757
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )31, 1);
#line 11757
  n = tmp;
#line 11758
  if (n) {
#line 11759
    (n + 1)->e = mode;
  }
#line 11761
  if (ctx->ExecuteFlag) {
#line 11762
    (*(ctx->Exec.CullFace))(ctx, mode);
  }
#line 11764
  return;
}
}
#line 11765 "D:/a/test/177.c"
void gl_save_DepthFunc(GLcontext *ctx , GLenum func ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11767
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )32, 1);
#line 11767
  n = tmp;
#line 11768
  if (n) {
#line 11769
    (n + 1)->e = func;
  }
#line 11771
  if (ctx->ExecuteFlag) {
#line 11772
    (*(ctx->Exec.DepthFunc))(ctx, func);
  }
#line 11774
  return;
}
}
#line 11775 "D:/a/test/177.c"
void gl_save_DepthMask(GLcontext *ctx , GLboolean mask ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11777
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )33, 1);
#line 11777
  n = tmp;
#line 11778
  if (n) {
#line 11779
    (n + 1)->b = mask;
  }
#line 11781
  if (ctx->ExecuteFlag) {
#line 11782
    (*(ctx->Exec.DepthMask))(ctx, mask);
  }
#line 11784
  return;
}
}
#line 11785 "D:/a/test/177.c"
void gl_save_DepthRange(GLcontext *ctx , GLclampd nearval , GLclampd farval ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11787
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )34, 2);
#line 11787
  n = tmp;
#line 11788
  if (n) {
#line 11789
    (n + 1)->f = (float )nearval;
#line 11790
    (n + 2)->f = (float )farval;
  }
#line 11792
  if (ctx->ExecuteFlag) {
#line 11793
    (*(ctx->Exec.DepthRange))(ctx, nearval, farval);
  }
#line 11795
  return;
}
}
#line 11796 "D:/a/test/177.c"
void gl_save_Disable(GLcontext *ctx , GLenum cap ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11798
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )35, 1);
#line 11798
  n = tmp;
#line 11799
  if (n) {
#line 11800
    (n + 1)->e = cap;
  }
#line 11802
  if (ctx->ExecuteFlag) {
#line 11803
    (*(ctx->Exec.Disable))(ctx, cap);
  }
#line 11805
  return;
}
}
#line 11806 "D:/a/test/177.c"
void gl_save_DrawBuffer(GLcontext *ctx , GLenum mode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11808
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )36, 1);
#line 11808
  n = tmp;
#line 11809
  if (n) {
#line 11810
    (n + 1)->e = mode;
  }
#line 11812
  if (ctx->ExecuteFlag) {
#line 11813
    (*(ctx->Exec.DrawBuffer))(ctx, mode);
  }
#line 11815
  return;
}
}
#line 11816 "D:/a/test/177.c"
void gl_save_DrawPixels(GLcontext *ctx , GLsizei width , GLsizei height , GLenum format ,
                        GLenum type , GLvoid const   *pixels ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11819
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )37, 5);
#line 11819
  n = tmp;
#line 11820
  if (n) {
#line 11821
    (n + 1)->i = width;
#line 11822
    (n + 2)->i = height;
#line 11823
    (n + 3)->e = format;
#line 11824
    (n + 4)->e = type;
#line 11825
    (n + 5)->data = (GLvoid *)pixels;
  }
#line 11827
  return;
}
}
#line 11828 "D:/a/test/177.c"
void gl_save_EdgeFlag(GLcontext *ctx , GLboolean flag ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11830
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )38, 1);
#line 11830
  n = tmp;
#line 11831
  if (n) {
#line 11832
    (n + 1)->b = flag;
  }
#line 11834
  if (ctx->ExecuteFlag) {
#line 11835
    (*(ctx->Exec.EdgeFlag))(ctx, flag);
  }
#line 11837
  return;
}
}
#line 11838 "D:/a/test/177.c"
void gl_save_Enable(GLcontext *ctx , GLenum cap ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11840
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )39, 1);
#line 11840
  n = tmp;
#line 11841
  if (n) {
#line 11842
    (n + 1)->e = cap;
  }
#line 11844
  if (ctx->ExecuteFlag) {
#line 11845
    (*(ctx->Exec.Enable))(ctx, cap);
  }
#line 11847
  return;
}
}
#line 11848 "D:/a/test/177.c"
void gl_save_End(GLcontext *ctx ) 
{ 

  {
#line 11850
  alloc_instruction(ctx, (enum __anonenum_OpCode_24 )40, 0);
#line 11851
  if (ctx->ExecuteFlag) {
#line 11852
    (*(ctx->Exec.End))(ctx);
  }
#line 11854
  return;
}
}
#line 11855 "D:/a/test/177.c"
void gl_save_EvalCoord1f(GLcontext *ctx , float u ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11857
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )41, 1);
#line 11857
  n = tmp;
#line 11858
  if (n) {
#line 11859
    (n + 1)->f = u;
  }
#line 11861
  if (ctx->ExecuteFlag) {
#line 11862
    (*(ctx->Exec.EvalCoord1f))(ctx, u);
  }
#line 11864
  return;
}
}
#line 11865 "D:/a/test/177.c"
void gl_save_EvalCoord2f(GLcontext *ctx , float u , float v ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11867
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )42, 2);
#line 11867
  n = tmp;
#line 11868
  if (n) {
#line 11869
    (n + 1)->f = u;
#line 11870
    (n + 2)->f = v;
  }
#line 11872
  if (ctx->ExecuteFlag) {
#line 11873
    (*(ctx->Exec.EvalCoord2f))(ctx, u, v);
  }
#line 11875
  return;
}
}
#line 11876 "D:/a/test/177.c"
void gl_save_EvalMesh1(GLcontext *ctx , GLenum mode , GLint i1 , GLint i2 ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11879
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )43, 3);
#line 11879
  n = tmp;
#line 11880
  if (n) {
#line 11881
    (n + 1)->e = mode;
#line 11882
    (n + 2)->i = i1;
#line 11883
    (n + 3)->i = i2;
  }
#line 11885
  if (ctx->ExecuteFlag) {
#line 11886
    (*(ctx->Exec.EvalMesh1))(ctx, mode, i1, i2);
  }
#line 11888
  return;
}
}
#line 11889 "D:/a/test/177.c"
void gl_save_EvalMesh2(GLcontext *ctx , GLenum mode , GLint i1 , GLint i2 , GLint j1___0 ,
                       GLint j2 ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11892
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )44, 5);
#line 11892
  n = tmp;
#line 11893
  if (n) {
#line 11894
    (n + 1)->e = mode;
#line 11895
    (n + 2)->i = i1;
#line 11896
    (n + 3)->i = i2;
#line 11897
    (n + 4)->i = j1___0;
#line 11898
    (n + 5)->i = j2;
  }
#line 11900
  if (ctx->ExecuteFlag) {
#line 11901
    (*(ctx->Exec.EvalMesh2))(ctx, mode, i1, i2, j1___0, j2);
  }
#line 11903
  return;
}
}
#line 11904 "D:/a/test/177.c"
void gl_save_EvalPoint1(GLcontext *ctx , GLint i ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11906
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )45, 1);
#line 11906
  n = tmp;
#line 11907
  if (n) {
#line 11908
    (n + 1)->i = i;
  }
#line 11910
  if (ctx->ExecuteFlag) {
#line 11911
    (*(ctx->Exec.EvalPoint1))(ctx, i);
  }
#line 11913
  return;
}
}
#line 11914 "D:/a/test/177.c"
void gl_save_EvalPoint2(GLcontext *ctx , GLint i , GLint j ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11916
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )46, 2);
#line 11916
  n = tmp;
#line 11917
  if (n) {
#line 11918
    (n + 1)->i = i;
#line 11919
    (n + 2)->i = j;
  }
#line 11921
  if (ctx->ExecuteFlag) {
#line 11922
    (*(ctx->Exec.EvalPoint2))(ctx, i, j);
  }
#line 11924
  return;
}
}
#line 11925 "D:/a/test/177.c"
void gl_save_Fogfv(GLcontext *ctx , GLenum pname , float const   *params ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11927
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )47, 5);
#line 11927
  n = tmp;
#line 11928
  if (n) {
#line 11929
    (n + 1)->e = pname;
#line 11930
    (n + 2)->f = (float )*(params + 0);
#line 11931
    (n + 3)->f = (float )*(params + 1);
#line 11932
    (n + 4)->f = (float )*(params + 2);
#line 11933
    (n + 5)->f = (float )*(params + 3);
  }
#line 11935
  if (ctx->ExecuteFlag) {
#line 11936
    (*(ctx->Exec.Fogfv))(ctx, pname, params);
  }
#line 11938
  return;
}
}
#line 11939 "D:/a/test/177.c"
void gl_save_FrontFace(GLcontext *ctx , GLenum mode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11941
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )48, 1);
#line 11941
  n = tmp;
#line 11942
  if (n) {
#line 11943
    (n + 1)->e = mode;
  }
#line 11945
  if (ctx->ExecuteFlag) {
#line 11946
    (*(ctx->Exec.FrontFace))(ctx, mode);
  }
#line 11948
  return;
}
}
#line 11949 "D:/a/test/177.c"
void gl_save_Frustum(GLcontext *ctx , GLdouble left , GLdouble right , GLdouble bottom ,
                     GLdouble top , GLdouble nearval , GLdouble farval ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11953
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )49, 6);
#line 11953
  n = tmp;
#line 11954
  if (n) {
#line 11955
    (n + 1)->f = (float )left;
#line 11956
    (n + 2)->f = (float )right;
#line 11957
    (n + 3)->f = (float )bottom;
#line 11958
    (n + 4)->f = (float )top;
#line 11959
    (n + 5)->f = (float )nearval;
#line 11960
    (n + 6)->f = (float )farval;
  }
#line 11962
  if (ctx->ExecuteFlag) {
#line 11963
    (*(ctx->Exec.Frustum))(ctx, left, right, bottom, top, nearval, farval);
  }
#line 11965
  return;
}
}
#line 11966 "D:/a/test/177.c"
void gl_save_Hint(GLcontext *ctx , GLenum target , GLenum mode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11968
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )50, 2);
#line 11968
  n = tmp;
#line 11969
  if (n) {
#line 11970
    (n + 1)->e = target;
#line 11971
    (n + 2)->e = mode;
  }
#line 11973
  if (ctx->ExecuteFlag) {
#line 11974
    (*(ctx->Exec.Hint))(ctx, target, mode);
  }
#line 11976
  return;
}
}
#line 11977 "D:/a/test/177.c"
void gl_save_Indexi(GLcontext *ctx , GLint index___0 ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11979
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )51, 1);
#line 11979
  n = tmp;
#line 11980
  if (n) {
#line 11981
    (n + 1)->i = index___0;
  }
#line 11983
  if (ctx->ExecuteFlag) {
#line 11984
    (*(ctx->Exec.Indexi))(ctx, index___0);
  }
#line 11986
  return;
}
}
#line 11987 "D:/a/test/177.c"
void gl_save_Indexf(GLcontext *ctx , float index___0 ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11989
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )51, 1);
#line 11989
  n = tmp;
#line 11990
  if (n) {
#line 11991
    (n + 1)->i = (int )index___0;
  }
#line 11993
  if (ctx->ExecuteFlag) {
#line 11994
    (*(ctx->Exec.Indexf))(ctx, index___0);
  }
#line 11996
  return;
}
}
#line 11997 "D:/a/test/177.c"
void gl_save_IndexMask(GLcontext *ctx , GLuint mask ) 
{ Node *n ;
  Node *tmp ;

  {
#line 11999
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )52, 1);
#line 11999
  n = tmp;
#line 12000
  if (n) {
#line 12001
    (n + 1)->ui = mask;
  }
#line 12003
  if (ctx->ExecuteFlag) {
#line 12004
    (*(ctx->Exec.IndexMask))(ctx, mask);
  }
#line 12006
  return;
}
}
#line 12007 "D:/a/test/177.c"
void gl_save_InitNames(GLcontext *ctx ) 
{ 

  {
#line 12009
  alloc_instruction(ctx, (enum __anonenum_OpCode_24 )53, 0);
#line 12010
  if (ctx->ExecuteFlag) {
#line 12011
    (*(ctx->Exec.InitNames))(ctx);
  }
#line 12013
  return;
}
}
#line 12014 "D:/a/test/177.c"
void gl_save_Lightfv(GLcontext *ctx , GLenum light , GLenum pname , float const   *params ,
                     GLint numparams ) 
{ Node *n ;
  Node *tmp ;
  GLint i ;

  {
#line 12017
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )54, 6);
#line 12017
  n = tmp;
#line 12020
  (n + 1)->e = light;
#line 12021
  (n + 2)->e = pname;
#line 12022
  i = 0;
#line 12022
  while (i < numparams) {
#line 12023
    (n + (3 + i))->f = (float )*(params + i);
#line 12022
    i ++;
  }
#line 12026
  if (ctx->ExecuteFlag) {
#line 12027
    (*(ctx->Exec.Lightfv))(ctx, light, pname, params, numparams);
  }
#line 12029
  return;
}
}
#line 12030 "D:/a/test/177.c"
void gl_save_LightModelfv(GLcontext *ctx , GLenum pname , float const   *params ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12033
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )55, 5);
#line 12033
  n = tmp;
#line 12034
  if (n) {
#line 12035
    (n + 1)->e = pname;
#line 12036
    (n + 2)->f = (float )*(params + 0);
#line 12037
    (n + 3)->f = (float )*(params + 1);
#line 12038
    (n + 4)->f = (float )*(params + 2);
#line 12039
    (n + 5)->f = (float )*(params + 3);
  }
#line 12041
  if (ctx->ExecuteFlag) {
#line 12042
    (*(ctx->Exec.LightModelfv))(ctx, pname, params);
  }
#line 12044
  return;
}
}
#line 12045 "D:/a/test/177.c"
void gl_save_LineStipple(GLcontext *ctx , GLint factor , GLushort pattern ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12047
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )56, 2);
#line 12047
  n = tmp;
#line 12048
  if (n) {
#line 12049
    (n + 1)->i = factor;
#line 12050
    (n + 2)->us = pattern;
  }
#line 12052
  if (ctx->ExecuteFlag) {
#line 12053
    (*(ctx->Exec.LineStipple))(ctx, factor, pattern);
  }
#line 12055
  return;
}
}
#line 12056 "D:/a/test/177.c"
void gl_save_LineWidth(GLcontext *ctx , float width ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12058
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )57, 1);
#line 12058
  n = tmp;
#line 12059
  if (n) {
#line 12060
    (n + 1)->f = width;
  }
#line 12062
  if (ctx->ExecuteFlag) {
#line 12063
    (*(ctx->Exec.LineWidth))(ctx, width);
  }
#line 12065
  return;
}
}
#line 12066 "D:/a/test/177.c"
void gl_save_ListBase(GLcontext *ctx , GLuint base ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12068
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )58, 1);
#line 12068
  n = tmp;
#line 12069
  if (n) {
#line 12070
    (n + 1)->ui = base;
  }
#line 12072
  if (ctx->ExecuteFlag) {
#line 12073
    (*(ctx->Exec.ListBase))(ctx, base);
  }
#line 12075
  return;
}
}
#line 12076 "D:/a/test/177.c"
void gl_save_LoadIdentity(GLcontext *ctx ) 
{ 

  {
#line 12078
  alloc_instruction(ctx, (enum __anonenum_OpCode_24 )59, 0);
#line 12079
  if (ctx->ExecuteFlag) {
#line 12080
    (*(ctx->Exec.LoadIdentity))(ctx);
  }
#line 12082
  return;
}
}
#line 12083 "D:/a/test/177.c"
void gl_save_LoadMatrixf(GLcontext *ctx , float const   *m ) 
{ Node *n ;
  Node *tmp ;
  GLuint i ;

  {
#line 12085
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )60, 16);
#line 12085
  n = tmp;
#line 12086
  if (n) {
#line 12088
    i = 0U;
#line 12088
    while (i < 16U) {
#line 12089
      (n + (1U + i))->f = (float )*(m + i);
#line 12088
      i ++;
    }
  }
#line 12092
  if (ctx->ExecuteFlag) {
#line 12093
    (*(ctx->Exec.LoadMatrixf))(ctx, m);
  }
#line 12095
  return;
}
}
#line 12096 "D:/a/test/177.c"
void gl_save_LoadName(GLcontext *ctx , GLuint name ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12098
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )61, 1);
#line 12098
  n = tmp;
#line 12099
  if (n) {
#line 12100
    (n + 1)->ui = name;
  }
#line 12102
  if (ctx->ExecuteFlag) {
#line 12103
    (*(ctx->Exec.LoadName))(ctx, name);
  }
#line 12105
  return;
}
}
#line 12106 "D:/a/test/177.c"
void gl_save_LogicOp(GLcontext *ctx , GLenum opcode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12108
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )62, 1);
#line 12108
  n = tmp;
#line 12109
  if (n) {
#line 12110
    (n + 1)->e = opcode;
  }
#line 12112
  if (ctx->ExecuteFlag) {
#line 12113
    (*(ctx->Exec.LogicOp))(ctx, opcode);
  }
#line 12115
  return;
}
}
#line 12116 "D:/a/test/177.c"
void gl_save_Map1f(GLcontext *ctx , GLenum target , float u1 , float u2 , GLint stride ,
                   GLint order , float const   *points , GLboolean retain ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12120
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )63, 6);
#line 12120
  n = tmp;
#line 12121
  if (n) {
#line 12122
    (n + 1)->e = target;
#line 12123
    (n + 2)->f = u1;
#line 12124
    (n + 3)->f = u2;
#line 12125
    (n + 4)->i = stride;
#line 12126
    (n + 5)->i = order;
#line 12127
    (n + 6)->data = (void *)points;
  }
#line 12129
  if (ctx->ExecuteFlag) {
#line 12130
    (*(ctx->Exec.Map1f))(ctx, target, u1, u2, stride, order, points, (unsigned char)1);
  }
#line 12132
  return;
}
}
#line 12133 "D:/a/test/177.c"
void gl_save_Map2f(GLcontext *ctx , GLenum target , float u1 , float u2 , GLint ustride ,
                   GLint uorder , float v1 , float v2 , GLint vstride , GLint vorder ,
                   float const   *points , GLboolean retain ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12138
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )64, 10);
#line 12138
  n = tmp;
#line 12139
  if (n) {
#line 12140
    (n + 1)->e = target;
#line 12141
    (n + 2)->f = u1;
#line 12142
    (n + 3)->f = u2;
#line 12143
    (n + 4)->f = v1;
#line 12144
    (n + 5)->f = v2;
#line 12145
    (n + 6)->i = ustride;
#line 12146
    (n + 7)->i = vstride;
#line 12147
    (n + 8)->i = uorder;
#line 12148
    (n + 9)->i = vorder;
#line 12149
    (n + 10)->data = (void *)points;
  }
#line 12151
  if (ctx->ExecuteFlag) {
#line 12152
    (*(ctx->Exec.Map2f))(ctx, target, u1, u2, ustride, uorder, v1, v2, vstride, vorder,
                         points, (unsigned char)1);
  }
#line 12156
  return;
}
}
#line 12157 "D:/a/test/177.c"
void gl_save_MapGrid1f(GLcontext *ctx , GLint un , float u1 , float u2 ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12159
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )65, 3);
#line 12159
  n = tmp;
#line 12160
  if (n) {
#line 12161
    (n + 1)->i = un;
#line 12162
    (n + 2)->f = u1;
#line 12163
    (n + 3)->f = u2;
  }
#line 12165
  if (ctx->ExecuteFlag) {
#line 12166
    (*(ctx->Exec.MapGrid1f))(ctx, un, u1, u2);
  }
#line 12168
  return;
}
}
#line 12169 "D:/a/test/177.c"
void gl_save_MapGrid2f(GLcontext *ctx , GLint un , float u1 , float u2 , GLint vn ,
                       float v1 , float v2 ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12173
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )66, 6);
#line 12173
  n = tmp;
#line 12174
  if (n) {
#line 12175
    (n + 1)->i = un;
#line 12176
    (n + 2)->f = u1;
#line 12177
    (n + 3)->f = u2;
#line 12178
    (n + 4)->i = vn;
#line 12179
    (n + 5)->f = v1;
#line 12180
    (n + 6)->f = v2;
  }
#line 12182
  if (ctx->ExecuteFlag) {
#line 12183
    (*(ctx->Exec.MapGrid2f))(ctx, un, u1, u2, vn, v1, v2);
  }
#line 12185
  return;
}
}
#line 12186 "D:/a/test/177.c"
void gl_save_Materialfv(GLcontext *ctx , GLenum face , GLenum pname , float const   *params ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12189
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )67, 6);
#line 12189
  n = tmp;
#line 12190
  if (n) {
#line 12191
    (n + 1)->e = face;
#line 12192
    (n + 2)->e = pname;
#line 12193
    (n + 3)->f = (float )*(params + 0);
#line 12194
    (n + 4)->f = (float )*(params + 1);
#line 12195
    (n + 5)->f = (float )*(params + 2);
#line 12196
    (n + 6)->f = (float )*(params + 3);
  }
#line 12198
  if (ctx->ExecuteFlag) {
#line 12199
    (*(ctx->Exec.Materialfv))(ctx, face, pname, params);
  }
#line 12201
  return;
}
}
#line 12202 "D:/a/test/177.c"
void gl_save_MatrixMode(GLcontext *ctx , GLenum mode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12204
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )68, 1);
#line 12204
  n = tmp;
#line 12205
  if (n) {
#line 12206
    (n + 1)->e = mode;
  }
#line 12208
  if (ctx->ExecuteFlag) {
#line 12209
    (*(ctx->Exec.MatrixMode))(ctx, mode);
  }
#line 12211
  return;
}
}
#line 12212 "D:/a/test/177.c"
void gl_save_MultMatrixf(GLcontext *ctx , float const   *m ) 
{ Node *n ;
  Node *tmp ;
  GLuint i ;

  {
#line 12214
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )69, 16);
#line 12214
  n = tmp;
#line 12215
  if (n) {
#line 12217
    i = 0U;
#line 12217
    while (i < 16U) {
#line 12218
      (n + (1U + i))->f = (float )*(m + i);
#line 12217
      i ++;
    }
  }
#line 12221
  if (ctx->ExecuteFlag) {
#line 12222
    (*(ctx->Exec.MultMatrixf))(ctx, m);
  }
#line 12224
  return;
}
}
#line 12225 "D:/a/test/177.c"
void gl_save_NewList(GLcontext *ctx , GLuint list , GLenum mode ) 
{ 

  {
#line 12227
  gl_error(ctx, 1282, "glNewList");
#line 12228
  return;
}
}
#line 12229 "D:/a/test/177.c"
void gl_save_Normal3fv(GLcontext *ctx , float const   *norm ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12231
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )70, 3);
#line 12231
  n = tmp;
#line 12232
  if (n) {
#line 12233
    (n + 1)->f = (float )*(norm + 0);
#line 12234
    (n + 2)->f = (float )*(norm + 1);
#line 12235
    (n + 3)->f = (float )*(norm + 2);
  }
#line 12237
  if (ctx->ExecuteFlag) {
#line 12238
    (*(ctx->Exec.Normal3fv))(ctx, (float const   *)norm);
  }
#line 12240
  return;
}
}
#line 12241 "D:/a/test/177.c"
void gl_save_Normal3f(GLcontext *ctx , float nx , float ny , float nz ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12243
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )70, 3);
#line 12243
  n = tmp;
#line 12244
  if (n) {
#line 12245
    (n + 1)->f = nx;
#line 12246
    (n + 2)->f = ny;
#line 12247
    (n + 3)->f = nz;
  }
#line 12249
  if (ctx->ExecuteFlag) {
#line 12250
    (*(ctx->Exec.Normal3f))(ctx, nx, ny, nz);
  }
#line 12252
  return;
}
}
#line 12253 "D:/a/test/177.c"
void gl_save_Ortho(GLcontext *ctx , GLdouble left , GLdouble right , GLdouble bottom ,
                   GLdouble top , GLdouble nearval , GLdouble farval ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12257
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )71, 6);
#line 12257
  n = tmp;
#line 12258
  if (n) {
#line 12259
    (n + 1)->f = (float )left;
#line 12260
    (n + 2)->f = (float )right;
#line 12261
    (n + 3)->f = (float )bottom;
#line 12262
    (n + 4)->f = (float )top;
#line 12263
    (n + 5)->f = (float )nearval;
#line 12264
    (n + 6)->f = (float )farval;
  }
#line 12266
  if (ctx->ExecuteFlag) {
#line 12267
    (*(ctx->Exec.Ortho))(ctx, left, right, bottom, top, nearval, farval);
  }
#line 12269
  return;
}
}
#line 12270 "D:/a/test/177.c"
void gl_save_PixelMapfv(GLcontext *ctx , GLenum map , GLint mapsize , float const   *values ) 
{ Node *n ;
  Node *tmp ;
  void *tmp___0 ;

  {
#line 12273
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )73, 3);
#line 12273
  n = tmp;
#line 12274
  if (n) {
#line 12275
    (n + 1)->e = map;
#line 12276
    (n + 2)->i = mapsize;
#line 12277
    tmp___0 = malloc((unsigned int )mapsize * sizeof(float ));//25
#line 12277
    (n + 3)->data = tmp___0;
#line 12278
    memcpy((n + 3)->data, (void const   *)((void *)values), (unsigned int )mapsize * sizeof(float ));
  }
#line 12280
  if (ctx->ExecuteFlag) {
#line 12281
    (*(ctx->Exec.PixelMapfv))(ctx, map, mapsize, values);
  }
#line 12283
  return;
}
}
#line 12284 "D:/a/test/177.c"
void gl_save_PixelTransferf(GLcontext *ctx , GLenum pname , float param ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12286
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )74, 2);
#line 12286
  n = tmp;
#line 12287
  if (n) {
#line 12288
    (n + 1)->e = pname;
#line 12289
    (n + 2)->f = param;
  }
#line 12291
  if (ctx->ExecuteFlag) {
#line 12292
    (*(ctx->Exec.PixelTransferf))(ctx, pname, param);
  }
#line 12294
  return;
}
}
#line 12295 "D:/a/test/177.c"
void gl_save_PixelZoom(GLcontext *ctx , float xfactor , float yfactor ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12297
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )75, 2);
#line 12297
  n = tmp;
#line 12298
  if (n) {
#line 12299
    (n + 1)->f = xfactor;
#line 12300
    (n + 2)->f = yfactor;
  }
#line 12302
  if (ctx->ExecuteFlag) {
#line 12303
    (*(ctx->Exec.PixelZoom))(ctx, xfactor, yfactor);
  }
#line 12305
  return;
}
}
#line 12306 "D:/a/test/177.c"
void gl_save_PointParameterfvEXT(GLcontext *ctx , GLenum pname , float const   *params ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12309
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )77, 4);
#line 12309
  n = tmp;
#line 12310
  if (n) {
#line 12311
    (n + 1)->e = pname;
#line 12312
    (n + 2)->f = (float )*(params + 0);
#line 12313
    (n + 3)->f = (float )*(params + 1);
#line 12314
    (n + 4)->f = (float )*(params + 2);
  }
#line 12316
  if (ctx->ExecuteFlag) {
#line 12317
    (*(ctx->Exec.PointParameterfvEXT))(ctx, pname, params);
  }
#line 12319
  return;
}
}
#line 12320 "D:/a/test/177.c"
void gl_save_PointSize(GLcontext *ctx , float size ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12322
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )76, 1);
#line 12322
  n = tmp;
#line 12323
  if (n) {
#line 12324
    (n + 1)->f = size;
  }
#line 12326
  if (ctx->ExecuteFlag) {
#line 12327
    (*(ctx->Exec.PointSize))(ctx, size);
  }
#line 12329
  return;
}
}
#line 12330 "D:/a/test/177.c"
void gl_save_PolygonMode(GLcontext *ctx , GLenum face , GLenum mode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12332
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )78, 2);
#line 12332
  n = tmp;
#line 12333
  if (n) {
#line 12334
    (n + 1)->e = face;
#line 12335
    (n + 2)->e = mode;
  }
#line 12337
  if (ctx->ExecuteFlag) {
#line 12338
    (*(ctx->Exec.PolygonMode))(ctx, face, mode);
  }
#line 12340
  return;
}
}
#line 12341 "D:/a/test/177.c"
void gl_save_PolygonStipple(GLcontext *ctx , GLubyte const   *mask ) 
{ Node *n ;
  Node *tmp ;
  void *data ;

  {
#line 12343
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )79, 1);
#line 12343
  n = tmp;
#line 12344
  if (n) {
#line 12346
    (n + 1)->data = malloc(128U);//26
#line 12347
    data = (n + 1)->data;
#line 12348
    memcpy(data, (void const   *)((void *)mask), 128U);
  }
#line 12350
  if (ctx->ExecuteFlag) {
#line 12351
    (*(ctx->Exec.PolygonStipple))(ctx, mask);
  }
#line 12353
  return;
}
}
#line 12354 "D:/a/test/177.c"
void gl_save_PolygonOffset(GLcontext *ctx , float factor , float units ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12356
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )80, 2);
#line 12356
  n = tmp;
#line 12357
  if (n) {
#line 12358
    (n + 1)->f = factor;
#line 12359
    (n + 2)->f = units;
  }
#line 12361
  if (ctx->ExecuteFlag) {
#line 12362
    (*(ctx->Exec.PolygonOffset))(ctx, factor, units);
  }
#line 12364
  return;
}
}
#line 12365 "D:/a/test/177.c"
void gl_save_PopAttrib(GLcontext *ctx ) 
{ 

  {
#line 12367
  alloc_instruction(ctx, (enum __anonenum_OpCode_24 )81, 0);
#line 12368
  if (ctx->ExecuteFlag) {
#line 12369
    (*(ctx->Exec.PopAttrib))(ctx);
  }
#line 12371
  return;
}
}
#line 12372 "D:/a/test/177.c"
void gl_save_PopMatrix(GLcontext *ctx ) 
{ 

  {
#line 12374
  alloc_instruction(ctx, (enum __anonenum_OpCode_24 )82, 0);
#line 12375
  if (ctx->ExecuteFlag) {
#line 12376
    (*(ctx->Exec.PopMatrix))(ctx);
  }
#line 12378
  return;
}
}
#line 12379 "D:/a/test/177.c"
void gl_save_PopName(GLcontext *ctx ) 
{ 

  {
#line 12381
  alloc_instruction(ctx, (enum __anonenum_OpCode_24 )83, 0);
#line 12382
  if (ctx->ExecuteFlag) {
#line 12383
    (*(ctx->Exec.PopName))(ctx);
  }
#line 12385
  return;
}
}
#line 12386 "D:/a/test/177.c"
void gl_save_PrioritizeTextures(GLcontext *ctx , GLsizei num , GLuint const   *textures ,
                                GLclampf const   *priorities ) 
{ GLint i ;
  Node *n ;
  Node *tmp ;

  {
#line 12391
  i = 0;
#line 12391
  while (i < num) {
#line 12392
    tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )84, 2);
#line 12392
    n = tmp;
#line 12393
    if (n) {
#line 12394
      (n + 1)->ui = (unsigned int )*(textures + i);
#line 12395
      (n + 2)->f = (float )*(priorities + i);
    }
#line 12391
    i ++;
  }
#line 12398
  if (ctx->ExecuteFlag) {
#line 12399
    (*(ctx->Exec.PrioritizeTextures))(ctx, num, textures, priorities);
  }
#line 12401
  return;
}
}
#line 12402 "D:/a/test/177.c"
void gl_save_PushAttrib(GLcontext *ctx , GLbitfield mask ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12404
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )85, 1);
#line 12404
  n = tmp;
#line 12405
  if (n) {
#line 12406
    (n + 1)->bf = mask;
  }
#line 12408
  if (ctx->ExecuteFlag) {
#line 12409
    (*(ctx->Exec.PushAttrib))(ctx, mask);
  }
#line 12411
  return;
}
}
#line 12412 "D:/a/test/177.c"
void gl_save_PushMatrix(GLcontext *ctx ) 
{ 

  {
#line 12414
  alloc_instruction(ctx, (enum __anonenum_OpCode_24 )86, 0);
#line 12415
  if (ctx->ExecuteFlag) {
#line 12416
    (*(ctx->Exec.PushMatrix))(ctx);
  }
#line 12418
  return;
}
}
#line 12419 "D:/a/test/177.c"
void gl_save_PushName(GLcontext *ctx , GLuint name ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12421
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )87, 1);
#line 12421
  n = tmp;
#line 12422
  if (n) {
#line 12423
    (n + 1)->ui = name;
  }
#line 12425
  if (ctx->ExecuteFlag) {
#line 12426
    (*(ctx->Exec.PushName))(ctx, name);
  }
#line 12428
  return;
}
}
#line 12429 "D:/a/test/177.c"
void gl_save_RasterPos4f(GLcontext *ctx , float x , float y , float z , float w ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12432
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )88, 4);
#line 12432
  n = tmp;
#line 12433
  if (n) {
#line 12434
    (n + 1)->f = x;
#line 12435
    (n + 2)->f = y;
#line 12436
    (n + 3)->f = z;
#line 12437
    (n + 4)->f = w;
  }
#line 12439
  if (ctx->ExecuteFlag) {
#line 12440
    (*(ctx->Exec.RasterPos4f))(ctx, x, y, z, w);
  }
#line 12442
  return;
}
}
#line 12443 "D:/a/test/177.c"
void gl_save_PassThrough(GLcontext *ctx , float token ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12445
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )72, 1);
#line 12445
  n = tmp;
#line 12446
  if (n) {
#line 12447
    (n + 1)->f = token;
  }
#line 12449
  if (ctx->ExecuteFlag) {
#line 12450
    (*(ctx->Exec.PassThrough))(ctx, token);
  }
#line 12452
  return;
}
}
#line 12453 "D:/a/test/177.c"
void gl_save_ReadBuffer(GLcontext *ctx , GLenum mode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12455
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )90, 1);
#line 12455
  n = tmp;
#line 12456
  if (n) {
#line 12457
    (n + 1)->e = mode;
  }
#line 12459
  if (ctx->ExecuteFlag) {
#line 12460
    (*(ctx->Exec.ReadBuffer))(ctx, mode);
  }
#line 12462
  return;
}
}
#line 12463 "D:/a/test/177.c"
void gl_save_Rectf(GLcontext *ctx , float x1 , float y1___0 , float x2 , float y2 ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12466
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )89, 4);
#line 12466
  n = tmp;
#line 12467
  if (n) {
#line 12468
    (n + 1)->f = x1;
#line 12469
    (n + 2)->f = y1___0;
#line 12470
    (n + 3)->f = x2;
#line 12471
    (n + 4)->f = y2;
  }
#line 12473
  if (ctx->ExecuteFlag) {
#line 12474
    (*(ctx->Exec.Rectf))(ctx, x1, y1___0, x2, y2);
  }
#line 12476
  return;
}
}
#line 12481
void gl_rotation_matrix(float angle , float x , float y , float z , float *m ) ;
#line 12477 "D:/a/test/177.c"
void gl_save_Rotatef(GLcontext *ctx , float angle , float x , float y , float z ) 
{ float m[16] ;

  {
#line 12481
  gl_rotation_matrix(angle, x, y, z, m);
#line 12482
  gl_save_MultMatrixf(ctx, (float const   *)(m));
#line 12483
  return;
}
}
#line 12484 "D:/a/test/177.c"
void gl_save_Scalef(GLcontext *ctx , float x , float y , float z ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12486
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )91, 3);
#line 12486
  n = tmp;
#line 12487
  if (n) {
#line 12488
    (n + 1)->f = x;
#line 12489
    (n + 2)->f = y;
#line 12490
    (n + 3)->f = z;
  }
#line 12492
  if (ctx->ExecuteFlag) {
#line 12493
    (*(ctx->Exec.Scalef))(ctx, x, y, z);
  }
#line 12495
  return;
}
}
#line 12496 "D:/a/test/177.c"
void gl_save_Scissor(GLcontext *ctx , GLint x , GLint y , GLsizei width , GLsizei height ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12499
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )92, 4);
#line 12499
  n = tmp;
#line 12500
  if (n) {
#line 12501
    (n + 1)->i = x;
#line 12502
    (n + 2)->i = y;
#line 12503
    (n + 3)->i = width;
#line 12504
    (n + 4)->i = height;
  }
#line 12506
  if (ctx->ExecuteFlag) {
#line 12507
    (*(ctx->Exec.Scissor))(ctx, x, y, width, height);
  }
#line 12509
  return;
}
}
#line 12510 "D:/a/test/177.c"
void gl_save_ShadeModel(GLcontext *ctx , GLenum mode ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12512
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )93, 1);
#line 12512
  n = tmp;
#line 12513
  if (n) {
#line 12514
    (n + 1)->e = mode;
  }
#line 12516
  if (ctx->ExecuteFlag) {
#line 12517
    (*(ctx->Exec.ShadeModel))(ctx, mode);
  }
#line 12519
  return;
}
}
#line 12520 "D:/a/test/177.c"
void gl_save_StencilFunc(GLcontext *ctx , GLenum func , GLint ref , GLuint mask ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12522
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )94, 3);
#line 12522
  n = tmp;
#line 12523
  if (n) {
#line 12524
    (n + 1)->e = func;
#line 12525
    (n + 2)->i = ref;
#line 12526
    (n + 3)->ui = mask;
  }
#line 12528
  if (ctx->ExecuteFlag) {
#line 12529
    (*(ctx->Exec.StencilFunc))(ctx, func, ref, mask);
  }
#line 12531
  return;
}
}
#line 12532 "D:/a/test/177.c"
void gl_save_StencilMask(GLcontext *ctx , GLuint mask ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12534
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )95, 1);
#line 12534
  n = tmp;
#line 12535
  if (n) {
#line 12536
    (n + 1)->ui = mask;
  }
#line 12538
  if (ctx->ExecuteFlag) {
#line 12539
    (*(ctx->Exec.StencilMask))(ctx, mask);
  }
#line 12541
  return;
}
}
#line 12542 "D:/a/test/177.c"
void gl_save_StencilOp(GLcontext *ctx , GLenum fail , GLenum zfail , GLenum zpass ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12545
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )96, 3);
#line 12545
  n = tmp;
#line 12546
  if (n) {
#line 12547
    (n + 1)->e = fail;
#line 12548
    (n + 2)->e = zfail;
#line 12549
    (n + 3)->e = zpass;
  }
#line 12551
  if (ctx->ExecuteFlag) {
#line 12552
    (*(ctx->Exec.StencilOp))(ctx, fail, zfail, zpass);
  }
#line 12554
  return;
}
}
#line 12555 "D:/a/test/177.c"
void gl_save_TexCoord2f(GLcontext *ctx , float s , float t ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12557
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )97, 2);
#line 12557
  n = tmp;
#line 12558
  if (n) {
#line 12559
    (n + 1)->f = s;
#line 12560
    (n + 2)->f = t;
  }
#line 12562
  if (ctx->ExecuteFlag) {
#line 12563
    (*(ctx->Exec.TexCoord2f))(ctx, s, t);
  }
#line 12565
  return;
}
}
#line 12566 "D:/a/test/177.c"
void gl_save_TexCoord4f(GLcontext *ctx , float s , float t , float r , float q ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12569
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )98, 4);
#line 12569
  n = tmp;
#line 12570
  if (n) {
#line 12571
    (n + 1)->f = s;
#line 12572
    (n + 2)->f = t;
#line 12573
    (n + 3)->f = r;
#line 12574
    (n + 4)->f = q;
  }
#line 12576
  if (ctx->ExecuteFlag) {
#line 12577
    (*(ctx->Exec.TexCoord4f))(ctx, s, t, r, q);
  }
#line 12579
  return;
}
}
#line 12580 "D:/a/test/177.c"
void gl_save_TexEnvfv(GLcontext *ctx , GLenum target , GLenum pname , float const   *params ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12583
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )99, 6);
#line 12583
  n = tmp;
#line 12584
  if (n) {
#line 12585
    (n + 1)->e = target;
#line 12586
    (n + 2)->e = pname;
#line 12587
    (n + 3)->f = (float )*(params + 0);
#line 12588
    (n + 4)->f = (float )*(params + 1);
#line 12589
    (n + 5)->f = (float )*(params + 2);
#line 12590
    (n + 6)->f = (float )*(params + 3);
  }
#line 12592
  if (ctx->ExecuteFlag) {
#line 12593
    (*(ctx->Exec.TexEnvfv))(ctx, target, pname, params);
  }
#line 12595
  return;
}
}
#line 12596 "D:/a/test/177.c"
void gl_save_TexGenfv(GLcontext *ctx , GLenum coord , GLenum pname , float const   *params ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12599
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )100, 6);
#line 12599
  n = tmp;
#line 12600
  if (n) {
#line 12601
    (n + 1)->e = coord;
#line 12602
    (n + 2)->e = pname;
#line 12603
    (n + 3)->f = (float )*(params + 0);
#line 12604
    (n + 4)->f = (float )*(params + 1);
#line 12605
    (n + 5)->f = (float )*(params + 2);
#line 12606
    (n + 6)->f = (float )*(params + 3);
  }
#line 12608
  if (ctx->ExecuteFlag) {
#line 12609
    (*(ctx->Exec.TexGenfv))(ctx, coord, pname, params);
  }
#line 12611
  return;
}
}
#line 12612 "D:/a/test/177.c"
void gl_save_TexParameterfv(GLcontext *ctx , GLenum target , GLenum pname , float const   *params ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12615
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )101, 6);
#line 12615
  n = tmp;
#line 12616
  if (n) {
#line 12617
    (n + 1)->e = target;
#line 12618
    (n + 2)->e = pname;
#line 12619
    (n + 3)->f = (float )*(params + 0);
#line 12620
    (n + 4)->f = (float )*(params + 1);
#line 12621
    (n + 5)->f = (float )*(params + 2);
#line 12622
    (n + 6)->f = (float )*(params + 3);
  }
#line 12624
  if (ctx->ExecuteFlag) {
#line 12625
    (*(ctx->Exec.TexParameterfv))(ctx, target, pname, params);
  }
#line 12627
  return;
}
}
#line 12628 "D:/a/test/177.c"
void gl_save_TexImage1D(GLcontext *ctx , GLenum target , GLint level , GLint components ,
                        GLsizei width , GLint border , GLenum format , GLenum type ,
                        struct gl_image *teximage ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12634
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )102, 8);
#line 12634
  n = tmp;
#line 12635
  if (n) {
#line 12636
    (n + 1)->e = target;
#line 12637
    (n + 2)->i = level;
#line 12638
    (n + 3)->i = components;
#line 12639
    (n + 4)->i = width;
#line 12640
    (n + 5)->i = border;
#line 12641
    (n + 6)->e = format;
#line 12642
    (n + 7)->e = type;
#line 12643
    (n + 8)->data = (GLvoid *)teximage;
#line 12644
    if (teximage) {
#line 12645
      teximage->RefCount = 1;
    }
  }
#line 12648
  if (ctx->ExecuteFlag) {
#line 12649
    (*(ctx->Exec.TexImage1D))(ctx, target, level, components, width, border, format,
                              type, teximage);
  }
#line 12652
  return;
}
}
#line 12653 "D:/a/test/177.c"
void gl_save_TexImage2D(GLcontext *ctx , GLenum target , GLint level , GLint components ,
                        GLsizei width , GLsizei height , GLint border , GLenum format ,
                        GLenum type , struct gl_image *teximage ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12659
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )103, 9);
#line 12659
  n = tmp;
#line 12660
  if (n) {
#line 12661
    (n + 1)->e = target;
#line 12662
    (n + 2)->i = level;
#line 12663
    (n + 3)->i = components;
#line 12664
    (n + 4)->i = width;
#line 12665
    (n + 5)->i = height;
#line 12666
    (n + 6)->i = border;
#line 12667
    (n + 7)->e = format;
#line 12668
    (n + 8)->e = type;
#line 12669
    (n + 9)->data = (GLvoid *)teximage;
#line 12670
    if (teximage) {
#line 12671
      teximage->RefCount = 1;
    }
  }
#line 12674
  if (ctx->ExecuteFlag) {
#line 12675
    (*(ctx->Exec.TexImage2D))(ctx, target, level, components, width, height, border,
                              format, type, teximage);
  }
#line 12678
  return;
}
}
#line 12679 "D:/a/test/177.c"
void gl_save_TexImage3DEXT(GLcontext *ctx , GLenum target , GLint level , GLint components ,
                           GLsizei width , GLsizei height , GLsizei depth , GLint border ,
                           GLenum format , GLenum type , struct gl_image *teximage ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12686
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )104, 10);
#line 12686
  n = tmp;
#line 12687
  if (n) {
#line 12688
    (n + 1)->e = target;
#line 12689
    (n + 2)->i = level;
#line 12690
    (n + 3)->i = components;
#line 12691
    (n + 4)->i = width;
#line 12692
    (n + 5)->i = height;
#line 12693
    (n + 6)->i = depth;
#line 12694
    (n + 7)->i = border;
#line 12695
    (n + 8)->e = format;
#line 12696
    (n + 9)->e = type;
#line 12697
    (n + 10)->data = (GLvoid *)teximage;
  }
#line 12699
  if (ctx->ExecuteFlag) {
#line 12700
    (*(ctx->Exec.TexImage3DEXT))(ctx, target, level, components, width, height, depth,
                                 border, format, type, teximage);
  }
#line 12703
  return;
}
}
#line 12704 "D:/a/test/177.c"
void gl_save_TexSubImage1D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                           GLsizei width , GLenum format , GLenum type , struct gl_image *image ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12709
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )105, 7);
#line 12709
  n = tmp;
#line 12710
  if (n) {
#line 12711
    (n + 1)->e = target;
#line 12712
    (n + 2)->i = level;
#line 12713
    (n + 3)->i = xoffset;
#line 12714
    (n + 4)->i = width;
#line 12715
    (n + 5)->e = format;
#line 12716
    (n + 6)->e = type;
#line 12717
    (n + 7)->data = (GLvoid *)image;
#line 12718
    if (image) {
#line 12719
      image->RefCount = 1;
    }
  }
#line 12721
  if (ctx->ExecuteFlag) {
#line 12722
    (*(ctx->Exec.TexSubImage1D))(ctx, target, level, xoffset, width, format, type,
                                 image);
  }
#line 12725
  return;
}
}
#line 12726 "D:/a/test/177.c"
void gl_save_TexSubImage2D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                           GLint yoffset , GLsizei width , GLsizei height , GLenum format ,
                           GLenum type , struct gl_image *image ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12733
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )106, 9);
#line 12733
  n = tmp;
#line 12734
  if (n) {
#line 12735
    (n + 1)->e = target;
#line 12736
    (n + 2)->i = level;
#line 12737
    (n + 3)->i = xoffset;
#line 12738
    (n + 4)->i = yoffset;
#line 12739
    (n + 5)->i = width;
#line 12740
    (n + 6)->i = height;
#line 12741
    (n + 7)->e = format;
#line 12742
    (n + 8)->e = type;
#line 12743
    (n + 9)->data = (GLvoid *)image;
#line 12744
    if (image) {
#line 12745
      image->RefCount = 1;
    }
  }
#line 12747
  if (ctx->ExecuteFlag) {
#line 12748
    (*(ctx->Exec.TexSubImage2D))(ctx, target, level, xoffset, yoffset, width, height,
                                 format, type, image);
  }
#line 12751
  return;
}
}
#line 12752 "D:/a/test/177.c"
void gl_save_TexSubImage3DEXT(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                              GLint yoffset , GLint zoffset , GLsizei width , GLsizei height ,
                              GLsizei depth , GLenum format , GLenum type , struct gl_image *image ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12759
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )107, 11);
#line 12759
  n = tmp;
#line 12760
  if (n) {
#line 12761
    (n + 1)->e = target;
#line 12762
    (n + 2)->i = level;
#line 12763
    (n + 3)->i = xoffset;
#line 12764
    (n + 4)->i = yoffset;
#line 12765
    (n + 5)->i = zoffset;
#line 12766
    (n + 6)->i = width;
#line 12767
    (n + 7)->i = height;
#line 12768
    (n + 8)->i = depth;
#line 12769
    (n + 9)->e = format;
#line 12770
    (n + 10)->e = type;
#line 12771
    (n + 11)->data = (GLvoid *)image;
#line 12772
    if (image) {
#line 12773
      image->RefCount = 1;
    }
  }
#line 12775
  if (ctx->ExecuteFlag) {
#line 12776
    (*(ctx->Exec.TexSubImage3DEXT))(ctx, target, level, xoffset, yoffset, zoffset,
                                    width, height, depth, format, type, image);
  }
#line 12779
  return;
}
}
#line 12780 "D:/a/test/177.c"
void gl_save_Translatef(GLcontext *ctx , float x , float y , float z ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12782
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )108, 3);
#line 12782
  n = tmp;
#line 12783
  if (n) {
#line 12784
    (n + 1)->f = x;
#line 12785
    (n + 2)->f = y;
#line 12786
    (n + 3)->f = z;
  }
#line 12788
  if (ctx->ExecuteFlag) {
#line 12789
    (*(ctx->Exec.Translatef))(ctx, x, y, z);
  }
#line 12791
  return;
}
}
#line 12792 "D:/a/test/177.c"
void gl_save_Vertex2f(GLcontext *ctx , float x , float y ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12794
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )109, 2);
#line 12794
  n = tmp;
#line 12795
  if (n) {
#line 12796
    (n + 1)->f = x;
#line 12797
    (n + 2)->f = y;
  }
#line 12799
  if (ctx->ExecuteFlag) {
#line 12800
    (*(ctx->Exec.Vertex2f))(ctx, x, y);
  }
#line 12802
  return;
}
}
#line 12803 "D:/a/test/177.c"
void gl_save_Vertex3f(GLcontext *ctx , float x , float y , float z ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12805
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )110, 3);
#line 12805
  n = tmp;
#line 12806
  if (n) {
#line 12807
    (n + 1)->f = x;
#line 12808
    (n + 2)->f = y;
#line 12809
    (n + 3)->f = z;
  }
#line 12811
  if (ctx->ExecuteFlag) {
#line 12812
    (*(ctx->Exec.Vertex3f))(ctx, x, y, z);
  }
#line 12814
  return;
}
}
#line 12815 "D:/a/test/177.c"
void gl_save_Vertex4f(GLcontext *ctx , float x , float y , float z , float w ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12818
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )111, 4);
#line 12818
  n = tmp;
#line 12819
  if (n) {
#line 12820
    (n + 1)->f = x;
#line 12821
    (n + 2)->f = y;
#line 12822
    (n + 3)->f = z;
#line 12823
    (n + 4)->f = w;
  }
#line 12825
  if (ctx->ExecuteFlag) {
#line 12826
    (*(ctx->Exec.Vertex4f))(ctx, x, y, z, w);
  }
#line 12828
  return;
}
}
#line 12829 "D:/a/test/177.c"
void gl_save_Vertex3fv(GLcontext *ctx , float const   *v ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12831
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )110, 3);
#line 12831
  n = tmp;
#line 12832
  if (n) {
#line 12833
    (n + 1)->f = (float )*(v + 0);
#line 12834
    (n + 2)->f = (float )*(v + 1);
#line 12835
    (n + 3)->f = (float )*(v + 2);
  }
#line 12837
  if (ctx->ExecuteFlag) {
#line 12838
    (*(ctx->Exec.Vertex3fv))(ctx, (float const   *)v);
  }
#line 12840
  return;
}
}
#line 12841 "D:/a/test/177.c"
void gl_save_Viewport(GLcontext *ctx , GLint x , GLint y , GLsizei width , GLsizei height ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12844
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )112, 4);
#line 12844
  n = tmp;
#line 12845
  if (n) {
#line 12846
    (n + 1)->i = x;
#line 12847
    (n + 2)->i = y;
#line 12848
    (n + 3)->i = width;
#line 12849
    (n + 4)->i = height;
  }
#line 12851
  if (ctx->ExecuteFlag) {
#line 12852
    (*(ctx->Exec.Viewport))(ctx, x, y, width, height);
  }
#line 12854
  return;
}
}
#line 12855 "D:/a/test/177.c"
void gl_save_WindowPos4fMESA(GLcontext *ctx , float x , float y , float z , float w ) 
{ Node *n ;
  Node *tmp ;

  {
#line 12858
  tmp = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )113, 4);
#line 12858
  n = tmp;
#line 12859
  if (n) {
#line 12860
    (n + 1)->f = x;
#line 12861
    (n + 2)->f = y;
#line 12862
    (n + 3)->f = z;
#line 12863
    (n + 4)->f = w;
  }
#line 12865
  if (ctx->ExecuteFlag) {
#line 12866
    (*(ctx->Exec.WindowPos4fMESA))(ctx, x, y, z, w);
  }
#line 12868
  return;
}
}
#line 12874
GLboolean gl_IsList(GLcontext *ctx , GLuint list ) ;
#line 12912
void gl_Begin(GLcontext *ctx , GLenum p ) ;
#line 12915
void gl_End(GLcontext *ctx ) ;
#line 12943
void gl_BindTexture(GLcontext *ctx , GLenum target , GLuint texName ) ;
#line 12973
void gl_Clear(GLcontext *ctx , GLbitfield mask ) ;
#line 12976
void gl_ClearColor(GLcontext *ctx , GLclampf red , GLclampf green , GLclampf blue___0 ,
                   GLclampf alpha ) ;
#line 12985
void gl_ClearIndex(GLcontext *ctx , float c ) ;
#line 12988
void gl_ClearStencil(GLcontext *ctx , GLint s ) ;
#line 13001
void gl_ColorMask(GLcontext *ctx , GLboolean red , GLboolean green , GLboolean blue___0 ,
                  GLboolean alpha ) ;
#line 13004
void gl_ColorMaterial(GLcontext *ctx , GLenum face , GLenum mode ) ;
#line 13018
void gl_CopyTexImage1D(GLcontext *ctx , GLenum target , GLint level , GLenum internalformat ,
                       GLint x , GLint y , GLsizei width , GLint border ) ;
#line 13022
void gl_CopyTexImage2D(GLcontext *ctx , GLenum target , GLint level , GLenum internalformat ,
                       GLint x , GLint y , GLsizei width , GLsizei height , GLint border ) ;
#line 13026
void gl_CopyTexSubImage1D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                          GLint x , GLint y , GLsizei width ) ;
#line 13030
void gl_CopyTexSubImage2D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                          GLint yoffset , GLint x , GLint y , GLsizei width , GLsizei height ) ;
#line 13034
void gl_CopyTexSubImage3DEXT(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                             GLint yoffset , GLint zoffset , GLint x , GLint y , GLsizei width ,
                             GLsizei height ) ;
#line 13038
void gl_CullFace(GLcontext *ctx , GLenum mode ) ;
#line 13050
void gl_Disable(GLcontext *ctx , GLenum cap ) ;
#line 13056
void gl_DrawPixels(GLcontext *ctx , GLsizei width , GLsizei height , GLenum format ,
                   GLenum type , GLvoid const   *pixels ) ;
#line 13063
void gl_Enable(GLcontext *ctx , GLenum cap ) ;
#line 13066
void gl_EvalCoord1f(GLcontext *ctx , float u ) ;
#line 13069
void gl_EvalCoord2f(GLcontext *ctx , float u , float v ) ;
#line 13072
void gl_EvalMesh1(GLcontext *ctx , GLenum mode , GLint i1 , GLint i2 ) ;
#line 13075
void gl_EvalMesh2(GLcontext *ctx , GLenum mode , GLint i1 , GLint i2 , GLint j1___0 ,
                  GLint j2 ) ;
#line 13078
void gl_EvalPoint1(GLcontext *ctx , GLint i ) ;
#line 13081
void gl_EvalPoint2(GLcontext *ctx , GLint i , GLint j ) ;
#line 13090
void gl_Fogfv(GLcontext *ctx , GLenum pname , float const   *params ) ;
#line 13094
void gl_FrontFace(GLcontext *ctx , GLenum mode ) ;
#line 13097
void gl_Frustum(GLcontext *ctx , GLdouble left , GLdouble right , GLdouble bottom ,
                GLdouble top , GLdouble nearval , GLdouble farval ) ;
#line 13100
void gl_Hint(GLcontext *ctx , GLenum target , GLenum mode ) ;
#line 13103
void gl_IndexMask(GLcontext *ctx , GLuint mask ) ;
#line 13106
void gl_InitNames(GLcontext *ctx ) ;
#line 13115
void gl_Lightfv(GLcontext *ctx , GLenum light , GLenum pname , float const   *params ,
                GLint nparams ) ;
#line 13125
void gl_LightModelfv(GLcontext *ctx , GLenum pname , float const   *params ) ;
#line 13129
void gl_LineStipple(GLcontext *ctx , GLint factor , GLushort pattern ) ;
#line 13132
void gl_LineWidth(GLcontext *ctx , float width ) ;
#line 13135
void gl_ListBase(GLcontext *ctx , GLuint base ) ;
#line 13138
void gl_LoadIdentity(GLcontext *ctx ) ;
#line 13142
void gl_LoadMatrixf(GLcontext *ctx , float const   *m ) ;
#line 13154
void gl_LoadName(GLcontext *ctx , GLuint name ) ;
#line 13157
void gl_LogicOp(GLcontext *ctx , GLenum opcode ) ;
#line 13160
void gl_Map1f(GLcontext *ctx , GLenum target , float u1 , float u2 , GLint stride ,
              GLint order , float const   *points , GLboolean retain ) ;
#line 13164
void gl_Map2f(GLcontext *ctx , GLenum target , float u1 , float u2 , GLint ustride ,
              GLint uorder , float v1 , float v2 , GLint vstride , GLint vorder ,
              float const   *points , GLboolean retain ) ;
#line 13173
void gl_MapGrid1f(GLcontext *ctx , GLint un , float u1 , float u2 ) ;
#line 13176
void gl_MapGrid2f(GLcontext *ctx , GLint un , float u1 , float u2 , GLint vn , float v1 ,
                  float v2 ) ;
#line 13185
void gl_Materialfv(GLcontext *ctx , GLenum face , GLenum pname , float const   *params ) ;
#line 13189
void gl_MatrixMode(GLcontext *ctx , GLenum mode ) ;
#line 13193
void gl_MultMatrixf(GLcontext *ctx , float const   *m ) ;
#line 13205
void gl_Ortho(GLcontext *ctx , GLdouble left , GLdouble right , GLdouble bottom ,
              GLdouble top , GLdouble nearval , GLdouble farval ) ;
#line 13208
void gl_PassThrough(GLcontext *ctx , float token ) ;
#line 13211
void gl_PixelMapfv(GLcontext *ctx , GLenum map , GLint mapsize , float const   *values ) ;
#line 13214
void gl_PixelTransferf(GLcontext *ctx , GLenum pname , float param ) ;
#line 13217
void gl_PixelZoom(GLcontext *ctx , float xfactor , float yfactor ) ;
#line 13220
void gl_PointSize(GLcontext *ctx , float size ) ;
#line 13228
void gl_PointParameterfvEXT(GLcontext *ctx , GLenum pname , float const   *params ) ;
#line 13232
void gl_PolygonMode(GLcontext *ctx , GLenum face , GLenum mode ) ;
#line 13235
void gl_PolygonStipple(GLcontext *ctx , GLubyte const   *mask ) ;
#line 13238
void gl_PolygonOffset(GLcontext *ctx , float factor , float units ) ;
#line 13244
void gl_PopMatrix(GLcontext *ctx ) ;
#line 13247
void gl_PopName(GLcontext *ctx ) ;
#line 13250
void gl_PrioritizeTextures(GLcontext *ctx , GLsizei n , GLuint const   *texName ,
                           GLclampf const   *priorities ) ;
#line 13256
void gl_PushMatrix(GLcontext *ctx ) ;
#line 13259
void gl_PushName(GLcontext *ctx , GLuint name ) ;
#line 13262
void gl_RasterPos4f(GLcontext *ctx , float x , float y , float z , float w ) ;
#line 13265
void gl_ReadBuffer(GLcontext *ctx , GLenum mode ) ;
#line 13268
void gl_Rectf(GLcontext *ctx , float x1 , float y1___0 , float x2 , float y2 ) ;
#line 13271
void gl_Scalef(GLcontext *ctx , float x , float y , float z ) ;
#line 13274
void gl_Scissor(GLcontext *ctx , GLint x , GLint y , GLsizei width , GLsizei height ) ;
#line 13277
void gl_ShadeModel(GLcontext *ctx , GLenum mode ) ;
#line 13280
void gl_StencilFunc(GLcontext *ctx , GLenum func , GLint ref , GLuint mask ) ;
#line 13283
void gl_StencilMask(GLcontext *ctx , GLuint mask ) ;
#line 13286
void gl_StencilOp(GLcontext *ctx , GLenum fail , GLenum zfail , GLenum zpass ) ;
#line 13295
void gl_TexEnvfv(GLcontext *ctx , GLenum target , GLenum pname , float const   *param ) ;
#line 13305
void gl_TexGenfv(GLcontext *ctx , GLenum coord , GLenum pname , float const   *params ) ;
#line 13315
void gl_TexParameterfv(GLcontext *ctx , GLenum target , GLenum pname , float const   *params ) ;
#line 13319
void gl_TexImage1D(GLcontext *ctx , GLenum target , GLint level , GLint internalformat ,
                   GLsizei width , GLint border , GLenum format , GLenum type , struct gl_image *image ) ;
#line 13330
void gl_TexImage2D(GLcontext *ctx , GLenum target , GLint level , GLint internalformat ,
                   GLsizei width , GLsizei height , GLint border , GLenum format ,
                   GLenum type , struct gl_image *image ) ;
#line 13342
void gl_TexImage3DEXT(GLcontext *ctx , GLenum target , GLint level , GLint internalformat ,
                      GLsizei width , GLsizei height , GLsizei depth , GLint border ,
                      GLenum format , GLenum type , struct gl_image *image ) ;
#line 13355
void gl_TexSubImage1D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                      GLsizei width , GLenum format , GLenum type , struct gl_image *image ) ;
#line 13359
void gl_TexSubImage2D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                      GLint yoffset , GLsizei width , GLsizei height , GLenum format ,
                      GLenum type , struct gl_image *image ) ;
#line 13364
void gl_TexSubImage3DEXT(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                         GLint yoffset , GLint zoffset , GLsizei width , GLsizei height ,
                         GLsizei depth , GLenum format , GLenum type , struct gl_image *image ) ;
#line 13369
void gl_Translatef(GLcontext *ctx , float x , float y , float z ) ;
#line 13372
void gl_Viewport(GLcontext *ctx , GLint x , GLint y , GLsizei width , GLsizei height ) ;
#line 13376
extern int ( /* missing proto */  gl_WindowPos4fMESA)(GLcontext * , float  , float  , float  , float  ) ;
#line 12869 "D:/a/test/177.c"
static void execute_list(GLcontext *ctx , GLuint list ) 
{ Node *n ;
  GLboolean done ;
  OpCode opcode ;
  int tmp ;
  int tmp___0 ;
  float equ[4] ;
  float p[4] ;
  float p___0[4] ;
  float p___1[4] ;
  float m[16] ;
  GLuint i ;
  float params[4] ;
  float m___0[16] ;
  GLuint i___0 ;
  float params___0[3] ;
  float params___1[4] ;
  float params___2[4] ;
  float params___3[4] ;
  char msg[1000] ;

  {
#line 12874
  tmp = (int )gl_IsList(ctx, list);
#line 12874
  if (! tmp) {
#line 12875
    return;
  }
#line 12876
  (ctx->CallDepth) ++;
#line 12877
  tmp___0 = (int )HashLookup((ctx->Shared)->DisplayList, list);
#line 12877
  n = (Node *)tmp___0;
#line 12878
  done = (unsigned char)0;
#line 12879
  while (! done) {
#line 12880
    opcode = (n + 0)->opcode;
#line 12881
    switch ((int )opcode) {
    case 109: 
#line 12884
    (*(ctx->Exec.Vertex2f))(ctx, (n + 1)->f, (n + 2)->f);
#line 12885
    break;
    case 110: 
#line 12887
    (*(ctx->Exec.Vertex3f))(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f);
#line 12888
    break;
    case 111: 
#line 12890
    (*(ctx->Exec.Vertex4f))(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 12891
    break;
    case 70: 
#line 12893
    ctx->Current.Normal[0] = (n + 1)->f;
#line 12894
    ctx->Current.Normal[1] = (n + 2)->f;
#line 12895
    ctx->Current.Normal[2] = (n + 3)->f;
#line 12896
    (ctx->VB)->MonoNormal = (unsigned char)0;
#line 12897
    break;
    case 19: 
#line 12899
    (*(ctx->Exec.Color4ub))(ctx, (n + 1)->ub, (n + 2)->ub, (n + 3)->ub, (n + 4)->ub);
#line 12900
    break;
    case 17: 
#line 12902
    (*(ctx->Exec.Color3f))(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f);
#line 12903
    break;
    case 18: 
#line 12905
    (*(ctx->Exec.Color4f))(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 12906
    break;
    case 51: 
#line 12908
    ctx->Current.Index = (n + 1)->ui;
#line 12909
    (ctx->VB)->MonoColor = (unsigned char)0;
#line 12910
    break;
    case 2: 
#line 12912
    gl_Begin(ctx, (n + 1)->e);
#line 12913
    break;
    case 40: 
#line 12915
    gl_End(ctx);
#line 12916
    break;
    case 97: 
#line 12918
    ctx->Current.TexCoord[0] = (n + 1)->f;
#line 12919
    ctx->Current.TexCoord[1] = (n + 2)->f;
#line 12920
    if ((ctx->VB)->TexCoordSize == 4U) {
#line 12921
      ctx->Current.TexCoord[2] = 0.0F;
#line 12922
      ctx->Current.TexCoord[3] = 1.0F;
    }
#line 12924
    break;
    case 98: 
#line 12926
    ctx->Current.TexCoord[0] = (n + 1)->f;
#line 12927
    ctx->Current.TexCoord[1] = (n + 2)->f;
#line 12928
    ctx->Current.TexCoord[2] = (n + 3)->f;
#line 12929
    ctx->Current.TexCoord[3] = (n + 4)->f;
#line 12930
    if ((ctx->VB)->TexCoordSize == 2U) {
#line 12931
      (ctx->VB)->TexCoordSize = 4U;
#line 12932
      gl_set_vertex_function(ctx);
    }
#line 12934
    break;
    case 0: 
#line 12937
    gl_Accum(ctx, (n + 1)->e, (n + 2)->f);
#line 12938
    break;
    case 1: 
#line 12940
    gl_AlphaFunc(ctx, (n + 1)->e, (n + 2)->f);
#line 12941
    break;
    case 3: 
#line 12943
    gl_BindTexture(ctx, (n + 1)->e, (n + 2)->ui);
#line 12944
    break;
    case 4: 
#line 12946
    gl_Bitmap(ctx, (n + 1)->i, (n + 2)->i, (n + 3)->f, (n + 4)->f, (n + 5)->f, (n + 6)->f,
              (struct gl_image  const  *)((struct gl_image *)(n + 7)->data));
#line 12950
    break;
    case 5: 
#line 12952
    gl_BlendColor(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 12953
    break;
    case 6: 
#line 12955
    gl_BlendEquation(ctx, (n + 1)->e);
#line 12956
    break;
    case 7: 
#line 12958
    gl_BlendFunc(ctx, (n + 1)->e, (n + 2)->e);
#line 12959
    break;
    case 8: 
#line 12962
    if (ctx->CallDepth < 64U) {
#line 12963
      execute_list(ctx, (n + 1)->ui);
    }
#line 12965
    break;
    case 9: 
#line 12968
    if (ctx->CallDepth < 64U) {
#line 12969
      execute_list(ctx, ctx->List.ListBase + (n + 1)->ui);
    }
#line 12971
    break;
    case 10: 
#line 12973
    gl_Clear(ctx, (n + 1)->bf);
#line 12974
    break;
    case 12: 
#line 12976
    gl_ClearColor(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 12977
    break;
    case 11: 
#line 12979
    gl_ClearAccum(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 12980
    break;
    case 13: 
#line 12982
    gl_ClearDepth(ctx, (double )(n + 1)->f);
#line 12983
    break;
    case 14: 
#line 12985
    gl_ClearIndex(ctx, (n + 1)->ui);
#line 12986
    break;
    case 15: 
#line 12988
    gl_ClearStencil(ctx, (n + 1)->i);
#line 12989
    break;
    case 16: 
#line 12993
    equ[0] = (n + 2)->f;
#line 12994
    equ[1] = (n + 3)->f;
#line 12995
    equ[2] = (n + 4)->f;
#line 12996
    equ[3] = (n + 5)->f;
#line 12997
    gl_ClipPlane(ctx, (n + 1)->e, (float const   *)(equ));
#line 12999
    break;
    case 20: 
#line 13001
    gl_ColorMask(ctx, (n + 1)->b, (n + 2)->b, (n + 3)->b, (n + 4)->b);
#line 13002
    break;
    case 21: 
#line 13004
    gl_ColorMaterial(ctx, (n + 1)->e, (n + 2)->e);
#line 13005
    break;
    case 22: 
#line 13007
    gl_ColorTable(ctx, (n + 1)->e, (n + 2)->e, (struct gl_image *)(n + 3)->data);
#line 13008
    break;
    case 23: 
#line 13010
    gl_ColorSubTable(ctx, (n + 1)->e, (n + 2)->i, (struct gl_image *)(n + 3)->data);
#line 13012
    break;
    case 24: 
#line 13014
    gl_CopyPixels(ctx, (n + 1)->i, (n + 2)->i, (n + 3)->i, (n + 4)->i, (n + 5)->e);
#line 13016
    break;
    case 25: 
#line 13018
    gl_CopyTexImage1D(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->e, (n + 4)->i, (n + 5)->i,
                      (n + 6)->i, (n + 7)->i);
#line 13020
    break;
    case 26: 
#line 13022
    gl_CopyTexImage2D(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->e, (n + 4)->i, (n + 5)->i,
                      (n + 6)->i, (n + 7)->i, (n + 8)->i);
#line 13024
    break;
    case 28: 
#line 13026
    gl_CopyTexSubImage1D(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->i, (n + 4)->i, (n + 5)->i,
                         (n + 6)->i);
#line 13028
    break;
    case 29: 
#line 13030
    gl_CopyTexSubImage2D(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->i, (n + 4)->i, (n + 5)->i,
                         (n + 6)->i, (n + 7)->i, (n + 8)->i);
#line 13032
    break;
    case 30: 
#line 13034
    gl_CopyTexSubImage3DEXT(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->i, (n + 4)->i, (n + 5)->i,
                            (n + 6)->i, (n + 7)->i, (n + 8)->i, (n + 9)->i);
#line 13036
    break;
    case 31: 
#line 13038
    gl_CullFace(ctx, (n + 1)->e);
#line 13039
    break;
    case 32: 
#line 13041
    gl_DepthFunc(ctx, (n + 1)->e);
#line 13042
    break;
    case 33: 
#line 13044
    gl_DepthMask(ctx, (n + 1)->b);
#line 13045
    break;
    case 34: 
#line 13047
    gl_DepthRange(ctx, (double )(n + 1)->f, (double )(n + 2)->f);
#line 13048
    break;
    case 35: 
#line 13050
    gl_Disable(ctx, (n + 1)->e);
#line 13051
    break;
    case 36: 
#line 13053
    gl_DrawBuffer(ctx, (n + 1)->e);
#line 13054
    break;
    case 37: 
#line 13056
    gl_DrawPixels(ctx, (n + 1)->i, (n + 2)->i, (n + 3)->e, (n + 4)->e, (n + 5)->data);
#line 13058
    break;
    case 38: 
#line 13060
    ctx->Current.EdgeFlag = (n + 1)->b;
#line 13061
    break;
    case 39: 
#line 13063
    gl_Enable(ctx, (n + 1)->e);
#line 13064
    break;
    case 41: 
#line 13066
    gl_EvalCoord1f(ctx, (n + 1)->f);
#line 13067
    break;
    case 42: 
#line 13069
    gl_EvalCoord2f(ctx, (n + 1)->f, (n + 2)->f);
#line 13070
    break;
    case 43: 
#line 13072
    gl_EvalMesh1(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->i);
#line 13073
    break;
    case 44: 
#line 13075
    gl_EvalMesh2(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->i, (n + 4)->i, (n + 5)->i);
#line 13076
    break;
    case 45: 
#line 13078
    gl_EvalPoint1(ctx, (n + 1)->i);
#line 13079
    break;
    case 46: 
#line 13081
    gl_EvalPoint2(ctx, (n + 1)->i, (n + 2)->i);
#line 13082
    break;
    case 47: 
#line 13086
    p[0] = (n + 2)->f;
#line 13087
    p[1] = (n + 3)->f;
#line 13088
    p[2] = (n + 4)->f;
#line 13089
    p[3] = (n + 5)->f;
#line 13090
    gl_Fogfv(ctx, (n + 1)->e, p);
#line 13092
    break;
    case 48: 
#line 13094
    gl_FrontFace(ctx, (n + 1)->e);
#line 13095
    break;
    case 49: 
#line 13097
    gl_Frustum(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f, (n + 5)->f, (n + 6)->f);
#line 13098
    break;
    case 50: 
#line 13100
    gl_Hint(ctx, (n + 1)->e, (n + 2)->e);
#line 13101
    break;
    case 52: 
#line 13103
    gl_IndexMask(ctx, (n + 1)->ui);
#line 13104
    break;
    case 53: 
#line 13106
    gl_InitNames(ctx);
#line 13107
    break;
    case 54: 
#line 13111
    p___0[0] = (n + 3)->f;
#line 13112
    p___0[1] = (n + 4)->f;
#line 13113
    p___0[2] = (n + 5)->f;
#line 13114
    p___0[3] = (n + 6)->f;
#line 13115
    gl_Lightfv(ctx, (n + 1)->e, (n + 2)->e, p___0, 4);
#line 13117
    break;
    case 55: 
#line 13121
    p___1[0] = (n + 2)->f;
#line 13122
    p___1[1] = (n + 3)->f;
#line 13123
    p___1[2] = (n + 4)->f;
#line 13124
    p___1[3] = (n + 5)->f;
#line 13125
    gl_LightModelfv(ctx, (n + 1)->e, p___1);
#line 13127
    break;
    case 56: 
#line 13129
    gl_LineStipple(ctx, (n + 1)->i, (n + 2)->us);
#line 13130
    break;
    case 57: 
#line 13132
    gl_LineWidth(ctx, (n + 1)->f);
#line 13133
    break;
    case 58: 
#line 13135
    gl_ListBase(ctx, (n + 1)->ui);
#line 13136
    break;
    case 59: 
#line 13138
    gl_LoadIdentity(ctx);
#line 13139
    break;
    case 60: 
#line 13141
    if (sizeof(Node ) == sizeof(float )) {
#line 13142
      gl_LoadMatrixf(ctx, & (n + 1)->f);
    } else {
#line 13147
      i = 0U;
#line 13147
      while (i < 16U) {
#line 13148
        m[i] = (n + (1U + i))->f;
#line 13147
        i ++;
      }
#line 13150
      gl_LoadMatrixf(ctx, m);
    }
#line 13152
    break;
    case 61: 
#line 13154
    gl_LoadName(ctx, (n + 1)->ui);
#line 13155
    break;
    case 62: 
#line 13157
    gl_LogicOp(ctx, (n + 1)->e);
#line 13158
    break;
    case 63: 
#line 13160
    gl_Map1f(ctx, (n + 1)->e, (n + 2)->f, (n + 3)->f, (n + 4)->i, (n + 5)->i, (float *)(n + 6)->data,
             1);
#line 13162
    break;
    case 64: 
#line 13164
    gl_Map2f(ctx, (n + 1)->e, (n + 2)->f, (n + 3)->f, (n + 6)->i, (n + 8)->i, (n + 4)->f,
             (n + 5)->f, (n + 7)->i, (n + 9)->i, (float *)(n + 10)->data, 1);
#line 13171
    break;
    case 65: 
#line 13173
    gl_MapGrid1f(ctx, (n + 1)->i, (n + 2)->f, (n + 3)->f);
#line 13174
    break;
    case 66: 
#line 13176
    gl_MapGrid2f(ctx, (n + 1)->i, (n + 2)->f, (n + 3)->f, (n + 4)->i, (n + 5)->f,
                 (n + 6)->f);
#line 13177
    break;
    case 67: 
#line 13181
    params[0] = (n + 3)->f;
#line 13182
    params[1] = (n + 4)->f;
#line 13183
    params[2] = (n + 5)->f;
#line 13184
    params[3] = (n + 6)->f;
#line 13185
    gl_Materialfv(ctx, (n + 1)->e, (n + 2)->e, params);
#line 13187
    break;
    case 68: 
#line 13189
    gl_MatrixMode(ctx, (n + 1)->e);
#line 13190
    break;
    case 69: 
#line 13192
    if (sizeof(Node ) == sizeof(float )) {
#line 13193
      gl_MultMatrixf(ctx, & (n + 1)->f);
    } else {
#line 13198
      i___0 = 0U;
#line 13198
      while (i___0 < 16U) {
#line 13199
        m___0[i___0] = (n + (1U + i___0))->f;
#line 13198
        i___0 ++;
      }
#line 13201
      gl_MultMatrixf(ctx, m___0);
    }
#line 13203
    break;
    case 71: 
#line 13205
    gl_Ortho(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f, (n + 5)->f, (n + 6)->f);
#line 13206
    break;
    case 72: 
#line 13208
    gl_PassThrough(ctx, (n + 1)->f);
#line 13209
    break;
    case 73: 
#line 13211
    gl_PixelMapfv(ctx, (n + 1)->e, (n + 2)->i, (float *)(n + 3)->data);
#line 13212
    break;
    case 74: 
#line 13214
    gl_PixelTransferf(ctx, (n + 1)->e, (n + 2)->f);
#line 13215
    break;
    case 75: 
#line 13217
    gl_PixelZoom(ctx, (n + 1)->f, (n + 2)->f);
#line 13218
    break;
    case 76: 
#line 13220
    gl_PointSize(ctx, (n + 1)->f);
#line 13221
    break;
    case 77: 
#line 13225
    params___0[0] = (n + 2)->f;
#line 13226
    params___0[1] = (n + 3)->f;
#line 13227
    params___0[2] = (n + 4)->f;
#line 13228
    gl_PointParameterfvEXT(ctx, (n + 1)->e, params___0);
#line 13230
    break;
    case 78: 
#line 13232
    gl_PolygonMode(ctx, (n + 1)->e, (n + 2)->e);
#line 13233
    break;
    case 79: 
#line 13235
    gl_PolygonStipple(ctx, (GLubyte *)(n + 1)->data);
#line 13236
    break;
    case 80: 
#line 13238
    gl_PolygonOffset(ctx, (n + 1)->f, (n + 2)->f);
#line 13239
    break;
    case 81: 
#line 13241
    gl_PopAttrib(ctx);
#line 13242
    break;
    case 82: 
#line 13244
    gl_PopMatrix(ctx);
#line 13245
    break;
    case 83: 
#line 13247
    gl_PopName(ctx);
#line 13248
    break;
    case 84: 
#line 13250
    gl_PrioritizeTextures(ctx, 1, & (n + 1)->ui, & (n + 2)->f);
#line 13251
    break;
    case 85: 
#line 13253
    gl_PushAttrib(ctx, (n + 1)->bf);
#line 13254
    break;
    case 86: 
#line 13256
    gl_PushMatrix(ctx);
#line 13257
    break;
    case 87: 
#line 13259
    gl_PushName(ctx, (n + 1)->ui);
#line 13260
    break;
    case 88: 
#line 13262
    gl_RasterPos4f(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 13263
    break;
    case 90: 
#line 13265
    gl_ReadBuffer(ctx, (n + 1)->e);
#line 13266
    break;
    case 89: 
#line 13268
    gl_Rectf(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 13269
    break;
    case 91: 
#line 13271
    gl_Scalef(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f);
#line 13272
    break;
    case 92: 
#line 13274
    gl_Scissor(ctx, (n + 1)->i, (n + 2)->i, (n + 3)->i, (n + 4)->i);
#line 13275
    break;
    case 93: 
#line 13277
    gl_ShadeModel(ctx, (n + 1)->e);
#line 13278
    break;
    case 94: 
#line 13280
    gl_StencilFunc(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->ui);
#line 13281
    break;
    case 95: 
#line 13283
    gl_StencilMask(ctx, (n + 1)->ui);
#line 13284
    break;
    case 96: 
#line 13286
    gl_StencilOp(ctx, (n + 1)->e, (n + 2)->e, (n + 3)->e);
#line 13287
    break;
    case 99: 
#line 13291
    params___1[0] = (n + 3)->f;
#line 13292
    params___1[1] = (n + 4)->f;
#line 13293
    params___1[2] = (n + 5)->f;
#line 13294
    params___1[3] = (n + 6)->f;
#line 13295
    gl_TexEnvfv(ctx, (n + 1)->e, (n + 2)->e, params___1);
#line 13297
    break;
    case 100: 
#line 13301
    params___2[0] = (n + 3)->f;
#line 13302
    params___2[1] = (n + 4)->f;
#line 13303
    params___2[2] = (n + 5)->f;
#line 13304
    params___2[3] = (n + 6)->f;
#line 13305
    gl_TexGenfv(ctx, (n + 1)->e, (n + 2)->e, params___2);
#line 13307
    break;
    case 101: 
#line 13311
    params___3[0] = (n + 3)->f;
#line 13312
    params___3[1] = (n + 4)->f;
#line 13313
    params___3[2] = (n + 5)->f;
#line 13314
    params___3[3] = (n + 6)->f;
#line 13315
    gl_TexParameterfv(ctx, (n + 1)->e, (n + 2)->e, params___3);
#line 13317
    break;
    case 102: 
#line 13319
    gl_TexImage1D(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->i, (n + 4)->i, (n + 5)->e,
                  (n + 6)->e, (n + 7)->e, (struct gl_image *)(n + 8)->data);
#line 13328
    break;
    case 103: 
#line 13330
    gl_TexImage2D(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->i, (n + 4)->i, (n + 5)->i,
                  (n + 6)->e, (n + 7)->e, (n + 8)->e, (struct gl_image *)(n + 9)->data);
#line 13340
    break;
    case 104: 
#line 13342
    gl_TexImage3DEXT(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->i, (n + 4)->i, (n + 5)->i,
                     (n + 6)->i, (n + 7)->e, (n + 8)->e, (n + 9)->e, (struct gl_image *)(n + 10)->data);
#line 13353
    break;
    case 105: 
#line 13355
    gl_TexSubImage1D(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->i, (n + 4)->i, (n + 5)->e,
                     (n + 6)->e, (struct gl_image *)(n + 7)->data);
#line 13357
    break;
    case 106: 
#line 13359
    gl_TexSubImage2D(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->i, (n + 4)->i, (n + 5)->e,
                     (n + 6)->i, (n + 7)->e, (n + 8)->e, (struct gl_image *)(n + 9)->data);
#line 13362
    break;
    case 107: 
#line 13364
    gl_TexSubImage3DEXT(ctx, (n + 1)->e, (n + 2)->i, (n + 3)->i, (n + 4)->i, (n + 5)->i,
                        (n + 6)->i, (n + 7)->i, (n + 8)->i, (n + 9)->e, (n + 10)->e,
                        (struct gl_image *)(n + 11)->data);
#line 13367
    break;
    case 108: 
#line 13369
    gl_Translatef(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f);
#line 13370
    break;
    case 112: 
#line 13372
    gl_Viewport(ctx, (n + 1)->i, (n + 2)->i, (n + 3)->i, (n + 4)->i);
#line 13374
    break;
    case 113: 
#line 13376
    gl_WindowPos4fMESA(ctx, (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 13377
    break;
    case 114: 
#line 13379
    n = (Node *)(n + 1)->next;
#line 13380
    break;
    case 115: 
#line 13382
    done = (unsigned char)1;
#line 13383
    break;
    default: 
#line 13387
    sprintf(msg, "Error in execute_list: opcode=%d", (int )opcode);
#line 13388
    gl_problem((GLcontext const   *)ctx, (char const   *)(msg));
#line 13390
    done = (unsigned char)1;
    }
#line 13392
    if ((unsigned int )opcode != 114U) {
#line 13393
      n += InstSize[opcode];
    }
  }
#line 13396
  (ctx->CallDepth) --;
#line 13397
  return;
}
}
#line 13398 "D:/a/test/177.c"
GLboolean gl_IsList(GLcontext *ctx , GLuint list ) 
{ int tmp ;

  {
#line 13400
  if (list > 0U) {
#line 13400
    tmp = (int )HashLookup((ctx->Shared)->DisplayList, list);
#line 13400
    if (tmp) {
#line 13401
      return ((unsigned char)1);
    } else {
#line 13404
      return ((unsigned char)0);
    }
  } else {
#line 13404
    return ((unsigned char)0);
  }
}
}
#line 13407 "D:/a/test/177.c"
void gl_DeleteLists(GLcontext *ctx , GLuint list , GLsizei range ) 
{ GLuint i ;

  {
#line 13410
  if (ctx->Primitive != 6656) {
#line 13411
    gl_error(ctx, 1282, "glDeleteLists");
#line 13412
    return;
  }
#line 13414
  if (range < 0) {
#line 13415
    gl_error(ctx, 1281, "glDeleteLists");
#line 13416
    return;
  }
#line 13418
  i = list;
#line 13418
  while (i < list + (GLuint )range) {
#line 13419
    gl_destroy_list(ctx, i);
#line 13418
    i ++;
  }
#line 13421
  return;
}
}
#line 13436
GLuint HashFindFreeKeyBlock(struct HashTable  const  *table , GLuint numKeys ) ;
#line 13440
void HashInsert(struct HashTable *table , GLuint key , void *data ) ;
#line 13422 "D:/a/test/177.c"
GLuint gl_GenLists(GLcontext *ctx , GLsizei range ) 
{ GLuint base ;
  int tmp ;
  GLuint i ;
  Node *tmp___0 ;

  {
#line 13425
  if (ctx->Primitive != 6656) {
#line 13426
    gl_error(ctx, 1282, "glGenLists");
#line 13427
    return (0U);
  }
#line 13429
  if (range < 0) {
#line 13430
    gl_error(ctx, 1281, "glGenLists");
#line 13431
    return (0U);
  }
#line 13433
  if (range == 0) {
#line 13434
    return (0U);
  }
#line 13436
  tmp = (int )HashFindFreeKeyBlock((ctx->Shared)->DisplayList, range);
#line 13436
  base = (unsigned int )tmp;
#line 13437
  if (base) {
#line 13439
    i = 0U;
#line 13439
    while (i < (GLuint )range) {
#line 13440
      tmp___0 = make_empty_list();
#line 13440
      HashInsert((ctx->Shared)->DisplayList, base + i, tmp___0);
#line 13439
      i ++;
    }
  }
#line 13443
  return (base);
}
}

#line 13445 "D:/a/test/177.c"
void *a[10];
void gl_NewList(GLcontext *ctx , GLuint list , GLenum mode ) 
{ void *tmp ;

  {
#line 13447
  if (ctx->Primitive != 6656) {
#line 13448
    gl_error(ctx, 1282, "glNewList");
#line 13449
    return;
  }
#line 13451
  if (list == 0U) {
#line 13452
    gl_error(ctx, 1281, "glNewList");
#line 13453
    return;
  }
#line 13455
  if (mode != 4864) {
#line 13455
    if (mode != 4865) {
#line 13456
      gl_error(ctx, 1280, "glNewList");
#line 13457
      return;
    }
  }
#line 13459
  if (CurrentListPtr) {
#line 13460
    gl_error(ctx, 1282, "glNewList");
#line 13461
    return;
  }
#line 13463
  CurrentListNum = list;
#line 13464
  tmp = malloc(sizeof(Node ) * 500U);//27
#line 13464
  CurrentBlock = (Node *)tmp;
#line 13464
  CurrentListPtr = CurrentBlock;
#line 13465
  CurrentPos = 0U;
#line 13466
  ctx->CompileFlag = (unsigned char)1;
#line 13467
  if (mode == 4864) {
#line 13468
    ctx->ExecuteFlag = (unsigned char)0;
  } else {
#line 13471
    ctx->ExecuteFlag = (unsigned char)1;
  }
#line 13473
  ctx->API = ctx->Save;
#line 13474
  return;
}
}
#line 13475 "D:/a/test/177.c"
void gl_EndList(GLcontext *ctx ) 
{ Node *n ;

  {
#line 13478
  if (! CurrentListPtr) {
#line 13479
    gl_error(ctx, 1282, "glEndList");
#line 13480
    return;
  }
#line 13482
  n = alloc_instruction(ctx, (enum __anonenum_OpCode_24 )115, 0);
#line 13483
  gl_destroy_list(ctx, CurrentListNum);
#line 13484
  HashInsert((ctx->Shared)->DisplayList, CurrentListNum, CurrentListPtr);
#line 13485
  CurrentListNum = 0U;
#line 13486
  CurrentListPtr = (Node *)((void *)0);
#line 13487
  ctx->ExecuteFlag = (unsigned char)1;
#line 13488
  ctx->CompileFlag = (unsigned char)0;
#line 13489
  ctx->API = ctx->Exec;
#line 13490
  return;
}
}
#line 13491 "D:/a/test/177.c"
void gl_CallList(GLcontext *ctx , GLuint list ) 
{ GLboolean save_compile_flag ;

  {
#line 13494
  save_compile_flag = ctx->CompileFlag;
#line 13495
  ctx->CompileFlag = (unsigned char)0;
#line 13496
  execute_list(ctx, list);
#line 13497
  ctx->CompileFlag = save_compile_flag;
#line 13498
  return;
}
}
#line 13499 "D:/a/test/177.c"
void gl_CallLists(GLcontext *ctx , GLsizei n , GLenum type , GLvoid const   *lists ) 
{ GLuint i ;
  GLuint list ;
  GLboolean save_compile_flag ;

  {
#line 13504
  save_compile_flag = ctx->CompileFlag;
#line 13505
  ctx->CompileFlag = (unsigned char)0;
#line 13506
  i = 0U;
#line 13506
  while (i < (GLuint )n) {
#line 13507
    list = translate_id((int )i, type, lists);
#line 13508
    execute_list(ctx, ctx->List.ListBase + list);
#line 13506
    i ++;
  }
#line 13510
  ctx->CompileFlag = save_compile_flag;
#line 13511
  return;
}
}
#line 13512 "D:/a/test/177.c"
void gl_ListBase(GLcontext *ctx , GLuint base ) 
{ 

  {
#line 13514
  if (ctx->Primitive != 6656) {
#line 13515
    gl_error(ctx, 1282, "glListBase");
#line 13516
    return;
  }
#line 13518
  ctx->List.ListBase = base;
#line 13519
  return;
}
}
#line 13520 "D:/a/test/177.c"
static char tmp[1000]  ;
#line 13521 "D:/a/test/177.c"
static char *enum_string(GLenum k ) 
{ 

  {
#line 13523
  switch (k) {
  case 0: 
#line 13524
  return ((char *)"GL_POINTS");
  case 1: 
#line 13525
  return ((char *)"GL_LINES");
  case 3: 
#line 13526
  return ((char *)"GL_LINE_STRIP");
  case 2: 
#line 13527
  return ((char *)"GL_LINE_LOOP");
  case 4: 
#line 13528
  return ((char *)"GL_TRIANGLES");
  case 5: 
#line 13529
  return ((char *)"GL_TRIANGLE_STRIP");
  case 6: 
#line 13530
  return ((char *)"GL_TRIANGLE_FAN");
  case 7: 
#line 13531
  return ((char *)"GL_QUADS");
  case 8: 
#line 13532
  return ((char *)"GL_QUAD_STRIP");
  case 9: 
#line 13533
  return ((char *)"GL_POLYGON");
  case 1028: 
#line 13534
  return ((char *)"GL_FRONT");
  case 1029: 
#line 13535
  return ((char *)"GL_BACK");
  case 1032: 
#line 13536
  return ((char *)"GL_FRONT_AND_BACK");
  case 4608: 
#line 13537
  return ((char *)"GL_AMBIENT");
  case 4609: 
#line 13538
  return ((char *)"GL_DIFFUSE");
  case 4610: 
#line 13539
  return ((char *)"GL_SPECULAR");
  case 5633: 
#line 13540
  return ((char *)"GL_SHININESS");
  default: 
#line 13542
  sprintf(tmp, "0x%X", k);
#line 13543
  return (tmp);
  }
}
}
#line 13546 "D:/a/test/177.c"
static void print_list(GLcontext *ctx , FILE *f , GLuint list ) 
{ Node *n ;
  GLboolean done ;
  OpCode opcode ;
  GLboolean tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 13551
  tmp___0 = glIsList(list);
#line 13551
  if (! tmp___0) {
#line 13552
    fprintf(f, "%d is not a display list ID\n", list);
#line 13553
    return;
  }
#line 13555
  tmp___1 = (int )HashLookup((ctx->Shared)->DisplayList, list);
#line 13555
  n = (Node *)tmp___1;
#line 13556
  fprintf(f, "START-LIST %d, address %p\n", list, (void *)n);
#line 13557
  if (n) {
#line 13557
    done = (unsigned char)0;
  } else {
#line 13557
    done = (unsigned char)1;
  }
#line 13558
  while (! done) {
#line 13559
    opcode = (n + 0)->opcode;
#line 13560
    switch ((int )opcode) {
    case 0: 
#line 13562
    fprintf(f, "accum %d %g\n", (n + 1)->e, (n + 2)->f);
#line 13563
    break;
    case 2: 
#line 13565
    tmp___2 = enum_string((n + 1)->e);
#line 13565
    fprintf(f, "Begin %s\n", tmp___2);
#line 13566
    break;
    case 4: 
#line 13568
    fprintf(f, "Bitmap %d %d %g %g %g %g %p\n", (n + 1)->i, (n + 2)->i, (n + 3)->f,
            (n + 4)->f, (n + 5)->f, (n + 6)->f, (n + 7)->data);
#line 13570
    break;
    case 8: 
#line 13572
    fprintf(f, "CallList %d\n", (n + 1)->ui);
#line 13573
    break;
    case 9: 
#line 13575
    fprintf(f, "CallList %d + offset %d = %d\n", (n + 1)->ui, ctx->List.ListBase,
            ctx->List.ListBase + (n + 1)->ui);
#line 13577
    break;
    case 17: 
#line 13579
    fprintf(f, "Color3f %g %g %gn", (n + 1)->f, (n + 2)->f, (n + 3)->f);
#line 13580
    break;
    case 18: 
#line 13582
    fprintf(f, "Color4f %g %g %g %g\n", (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 13583
    break;
    case 19: 
#line 13585
    fprintf(f, "Color4ub %d %d %d %d\n", (n + 1)->ub, (n + 2)->ub, (n + 3)->ub, (n + 4)->ub);
#line 13587
    break;
    case 35: 
#line 13589
    tmp___3 = enum_string((n + 1)->e);
#line 13589
    fprintf(f, "Disable %s\n", tmp___3);
#line 13590
    break;
    case 39: 
#line 13592
    tmp___4 = enum_string((n + 1)->e);
#line 13592
    fprintf(f, "Enable %s\n", tmp___4);
#line 13593
    break;
    case 40: 
#line 13595
    fprintf(f, "End\n");
#line 13596
    break;
    case 49: 
#line 13598
    fprintf(f, "Frustum %g %g %g %g %g %g\n", (n + 1)->f, (n + 2)->f, (n + 3)->f,
            (n + 4)->f, (n + 5)->f, (n + 6)->f);
#line 13600
    break;
    case 51: 
#line 13602
    fprintf(f, "Index %d\n", (n + 1)->ui);
#line 13603
    break;
    case 56: 
#line 13605
    fprintf(f, "LineStipple %d %x\n", (n + 1)->i, (int )(n + 2)->us);
#line 13606
    break;
    case 59: 
#line 13608
    fprintf(f, "LoadIdentity\n");
#line 13609
    break;
    case 60: 
#line 13611
    fprintf(f, "LoadMatrix\n");
#line 13612
    fprintf(f, "  %8f %8f %8f %8f\n", (n + 1)->f, (n + 5)->f, (n + 9)->f, (n + 13)->f);
#line 13613
    fprintf(f, "  %8f %8f %8f %8f\n", (n + 2)->f, (n + 6)->f, (n + 10)->f, (n + 14)->f);
#line 13614
    fprintf(f, "  %8f %8f %8f %8f\n", (n + 3)->f, (n + 7)->f, (n + 11)->f, (n + 15)->f);
#line 13615
    fprintf(f, "  %8f %8f %8f %8f\n", (n + 4)->f, (n + 8)->f, (n + 12)->f, (n + 16)->f);
#line 13616
    break;
    case 67: 
#line 13618
    tmp___5 = enum_string((n + 2)->e);
#line 13618
    tmp___6 = enum_string((n + 1)->e);
#line 13618
    fprintf(f, "Material %s %s %g %g %g %g\n", tmp___6, tmp___5, (n + 3)->f, (n + 4)->f,
            (n + 5)->f, (n + 6)->f);
#line 13620
    break;
    case 69: 
#line 13622
    fprintf(f, "MultMatrix (or Rotate)\n");
#line 13623
    fprintf(f, "  %8f %8f %8f %8f\n", (n + 1)->f, (n + 5)->f, (n + 9)->f, (n + 13)->f);
#line 13624
    fprintf(f, "  %8f %8f %8f %8f\n", (n + 2)->f, (n + 6)->f, (n + 10)->f, (n + 14)->f);
#line 13625
    fprintf(f, "  %8f %8f %8f %8f\n", (n + 3)->f, (n + 7)->f, (n + 11)->f, (n + 15)->f);
#line 13626
    fprintf(f, "  %8f %8f %8f %8f\n", (n + 4)->f, (n + 8)->f, (n + 12)->f, (n + 16)->f);
#line 13627
    break;
    case 70: 
#line 13629
    fprintf(f, "Normal %g %g %g\n", (n + 1)->f, (n + 2)->f, (n + 3)->f);
#line 13630
    break;
    case 71: 
#line 13632
    fprintf(f, "Ortho %g %g %g %g %g %g\n", (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f,
            (n + 5)->f, (n + 6)->f);
#line 13634
    break;
    case 81: 
#line 13636
    fprintf(f, "PopAttrib\n");
#line 13637
    break;
    case 82: 
#line 13639
    fprintf(f, "PopMatrix\n");
#line 13640
    break;
    case 83: 
#line 13642
    fprintf(f, "PopName\n");
#line 13643
    break;
    case 85: 
#line 13645
    fprintf(f, "PushAttrib %x\n", (n + 1)->bf);
#line 13646
    break;
    case 86: 
#line 13648
    fprintf(f, "PushMatrix\n");
#line 13649
    break;
    case 87: 
#line 13651
    fprintf(f, "PushName %d\n", (n + 1)->ui);
#line 13652
    break;
    case 88: 
#line 13654
    fprintf(f, "RasterPos %g %g %g %g\n", (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 13655
    break;
    case 89: 
#line 13657
    fprintf(f, "Rectf %g %g %g %g\n", (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 13658
    break;
    case 91: 
#line 13660
    fprintf(f, "Scale %g %g %g\n", (n + 1)->f, (n + 2)->f, (n + 3)->f);
#line 13661
    break;
    case 97: 
#line 13663
    fprintf(f, "TexCoord %g %g\n", (n + 1)->f, (n + 2)->f);
#line 13664
    break;
    case 98: 
#line 13666
    fprintf(f, "TexCoord %g %g %g %g\n", (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 13667
    break;
    case 108: 
#line 13669
    fprintf(f, "Translate %g %g %g\n", (n + 1)->f, (n + 2)->f, (n + 3)->f);
#line 13670
    break;
    case 109: 
#line 13672
    fprintf(f, "Vertex %g %g\n", (n + 1)->f, (n + 2)->f);
#line 13673
    break;
    case 110: 
#line 13675
    fprintf(f, "Vertex %g %g %g\n", (n + 1)->f, (n + 2)->f, (n + 3)->f);
#line 13676
    break;
    case 111: 
#line 13678
    fprintf(f, "Vertex %g %g %g %g\n", (n + 1)->f, (n + 2)->f, (n + 3)->f, (n + 4)->f);
#line 13679
    break;
    case 114: 
#line 13682
    fprintf(f, "DISPLAY-LIST-CONTINUE\n");
#line 13683
    n = (Node *)(n + 1)->next;
#line 13684
    break;
    case 115: 
#line 13686
    fprintf(f, "END-LIST %d\n", list);
#line 13687
    done = (unsigned char)1;
#line 13688
    break;
    default: ;
#line 13690
    if ((unsigned int )opcode < 0U) {
#line 13691
      fprintf(f, "ERROR IN DISPLAY LIST: opcode = %d, address = %p\n", opcode, (void *)n);
#line 13693
      return;
    } else {
#line 13690
      if ((unsigned int )opcode > 115U) {
#line 13691
        fprintf(f, "ERROR IN DISPLAY LIST: opcode = %d, address = %p\n", opcode, (void *)n);
#line 13693
        return;
      } else {
#line 13696
        fprintf(f, "command %d, %d operands\n", opcode, InstSize[opcode]);
      }
    }
    }
#line 13699
    if ((unsigned int )opcode != 114U) {
#line 13700
      n += InstSize[opcode];
    }
  }
#line 13703
  return;
}
}
#line 13704 "D:/a/test/177.c"
void mesa_print_display_list(GLuint list ) 
{ GLcontext *ctx ;
  struct _reent *tmp___0 ;

  {
#line 13710
  ctx = CC;
#line 13712
  tmp___0 = __getreent();
#line 13712
  print_list(ctx, tmp___0->_stdout, list);
#line 13713
  return;
}
}
#line 13719 "D:/a/test/177.c"
static void draw_index_pixels(GLcontext *ctx , GLsizei width , GLsizei height , GLenum type ,
                              GLvoid const   *pixels ) 
{ GLint x ;
  GLint y ;
  GLint desty ;
  GLuint i ;
  GLuint j ;
  GLdepth zspan[640] ;
  GLboolean zoom ;
  int tmp___0 ;
  GLdepth zval ;
  GLuint ispan[640] ;
  GLubyte *src ;
  GLubyte *tmp___1 ;
  GLbyte *src___0 ;
  GLbyte *tmp___2 ;
  GLushort *src___1 ;
  GLushort *tmp___3 ;
  GLshort *src___2 ;
  GLshort *tmp___4 ;
  GLuint *src___3 ;
  GLuint *tmp___5 ;
  GLint *src___4 ;
  GLint *tmp___6 ;
  float *src___5 ;
  float *tmp___7 ;
  GLubyte red[640] ;
  GLubyte green[640] ;
  GLubyte blue___0[640] ;
  GLubyte alpha[640] ;

  {
#line 13726
  if ((double )ctx->Pixel.ZoomX != 1.0) {
#line 13726
    tmp___0 = 1;
  } else {
#line 13726
    if ((double )ctx->Pixel.ZoomY != 1.0) {
#line 13726
      tmp___0 = 1;
    } else {
#line 13726
      tmp___0 = 0;
    }
  }
#line 13726
  zoom = (unsigned char )tmp___0;
#line 13727
  x = (int )(ctx->Current.RasterPos[0] + 0.5F);
#line 13728
  y = (int )(ctx->Current.RasterPos[1] + 0.5F);
#line 13729
  desty = y;
#line 13730
  if (ctx->Depth.Test) {
#line 13731
    zval = (unsigned short )(ctx->Current.RasterPos[2] * 65535.0F);
#line 13732
    i = 0U;
#line 13732
    while (i < (GLuint )width) {
#line 13733
      zspan[i] = zval;
#line 13732
      i ++;
    }
  }
#line 13736
  i = 0U;
#line 13736
  while (i < (GLuint )height) {
#line 13738
    switch (type) {
    case 5121: 
#line 13741
    src = (GLubyte *)pixels + i * (GLuint )width;
#line 13742
    j = 0U;
#line 13742
    while (j < (GLuint )width) {
#line 13743
      tmp___1 = src;
#line 13743
      src ++;
#line 13743
      ispan[j] = (unsigned int )*tmp___1;
#line 13742
      j ++;
    }
#line 13746
    break;
    case 5120: 
#line 13749
    src___0 = (GLbyte *)pixels + i * (GLuint )width;
#line 13750
    j = 0U;
#line 13750
    while (j < (GLuint )width) {
#line 13751
      tmp___2 = src___0;
#line 13751
      src___0 ++;
#line 13751
      ispan[j] = (unsigned int )*tmp___2;
#line 13750
      j ++;
    }
#line 13754
    break;
    case 5123: 
#line 13757
    src___1 = (GLushort *)pixels + i * (GLuint )width;
#line 13758
    j = 0U;
#line 13758
    while (j < (GLuint )width) {
#line 13759
      tmp___3 = src___1;
#line 13759
      src___1 ++;
#line 13759
      ispan[j] = (unsigned int )*tmp___3;
#line 13758
      j ++;
    }
#line 13762
    break;
    case 5122: 
#line 13765
    src___2 = (GLshort *)pixels + i * (GLuint )width;
#line 13766
    j = 0U;
#line 13766
    while (j < (GLuint )width) {
#line 13767
      tmp___4 = src___2;
#line 13767
      src___2 ++;
#line 13767
      ispan[j] = (unsigned int )*tmp___4;
#line 13766
      j ++;
    }
#line 13770
    break;
    case 5125: 
#line 13773
    src___3 = (GLuint *)pixels + i * (GLuint )width;
#line 13774
    j = 0U;
#line 13774
    while (j < (GLuint )width) {
#line 13775
      tmp___5 = src___3;
#line 13775
      src___3 ++;
#line 13775
      ispan[j] = *tmp___5;
#line 13774
      j ++;
    }
#line 13778
    break;
    case 5124: 
#line 13781
    src___4 = (GLint *)pixels + i * (GLuint )width;
#line 13782
    j = 0U;
#line 13782
    while (j < (GLuint )width) {
#line 13783
      tmp___6 = src___4;
#line 13783
      src___4 ++;
#line 13783
      ispan[j] = (unsigned int )*tmp___6;
#line 13782
      j ++;
    }
#line 13786
    break;
    case 6656: 
#line 13789
    break;
    case 5126: 
#line 13792
    src___5 = (float *)pixels + i * (GLuint )width;
#line 13793
    j = 0U;
#line 13793
    while (j < (GLuint )width) {
#line 13794
      tmp___7 = src___5;
#line 13794
      src___5 ++;
#line 13794
      ispan[j] = (unsigned int )((int )*tmp___7);
#line 13793
      j ++;
    }
#line 13797
    break;
    default: 
#line 13799
    gl_error(ctx, 1280, "Internal: draw_index_pixels");
    }
#line 13801
    if (ctx->Pixel.IndexOffset) {
      goto _L;
    } else {
#line 13801
      if (ctx->Pixel.IndexShift) {
        _L: /* CIL Label */ 
#line 13802
        if (ctx->Pixel.IndexShift >= 0) {
#line 13803
          j = 0U;
#line 13803
          while (j < (GLuint )width) {
#line 13804
            ispan[j] = (ispan[j] << ctx->Pixel.IndexShift) + (GLuint )ctx->Pixel.IndexOffset;
#line 13803
            j ++;
          }
        } else {
#line 13809
          j = 0U;
#line 13809
          while (j < (GLuint )width) {
#line 13810
            ispan[j] = (ispan[j] >> - ctx->Pixel.IndexShift) + (GLuint )ctx->Pixel.IndexOffset;
#line 13809
            j ++;
          }
        }
      }
    }
#line 13815
    if ((ctx->Visual)->RGBAflag) {
#line 13819
      j = 0U;
#line 13819
      while (j < (GLuint )width) {
#line 13820
        red[j] = (unsigned char )((int )(ctx->Pixel.MapItoR[ispan[j]] * (ctx->Visual)->RedScale));
#line 13821
        green[j] = (unsigned char )((int )(ctx->Pixel.MapItoG[ispan[j]] * (ctx->Visual)->GreenScale));
#line 13822
        blue___0[j] = (unsigned char )((int )(ctx->Pixel.MapItoB[ispan[j]] * (ctx->Visual)->BlueScale));
#line 13823
        alpha[j] = (unsigned char )((int )(ctx->Pixel.MapItoA[ispan[j]] * (ctx->Visual)->AlphaScale));
#line 13819
        j ++;
      }
#line 13825
      if (zoom) {
#line 13826
        gl_write_zoomed_color_span(ctx, width, x, y, zspan, red, green, blue___0,
                                   alpha, desty);
      } else {
#line 13830
        gl_write_color_span(ctx, width, x, y, zspan, red, green, blue___0, alpha,
                            6656);
      }
    } else {
#line 13836
      if (ctx->Pixel.MapColorFlag) {
#line 13837
        j = 0U;
#line 13837
        while (j < (GLuint )width) {
#line 13838
          ispan[j] = (unsigned int )ctx->Pixel.MapItoI[ispan[j]];
#line 13837
          j ++;
        }
      }
#line 13841
      if (zoom) {
#line 13842
        gl_write_zoomed_index_span(ctx, width, x, y, zspan, ispan, desty);
      } else {
#line 13845
        gl_write_index_span(ctx, width, x, y, zspan, ispan, 6656);
      }
    }
#line 13736
    i ++;
#line 13736
    y ++;
  }
#line 13849
  return;
}
}
#line 13850 "D:/a/test/177.c"
static void draw_stencil_pixels(GLcontext *ctx , GLsizei width , GLsizei height ,
                                GLenum type , GLvoid const   *pixels ) 
{ GLint x ;
  GLint y ;
  GLint desty ;
  GLuint i ;
  GLuint j ;
  GLboolean zoom ;
  int tmp___0 ;
  GLubyte stencil[640] ;
  GLubyte *src ;
  GLbyte *src___0 ;
  GLushort *src___1 ;
  GLushort *tmp___1 ;
  GLshort *src___2 ;
  GLshort *tmp___2 ;
  GLuint *src___3 ;
  GLuint *tmp___3 ;
  GLint *src___4 ;
  GLint *tmp___4 ;
  float *src___5 ;
  float *tmp___5 ;

  {
#line 13856
  if ((double )ctx->Pixel.ZoomX != 1.0) {
#line 13856
    tmp___0 = 1;
  } else {
#line 13856
    if ((double )ctx->Pixel.ZoomY != 1.0) {
#line 13856
      tmp___0 = 1;
    } else {
#line 13856
      tmp___0 = 0;
    }
  }
#line 13856
  zoom = (unsigned char )tmp___0;
#line 13857
  x = (int )(ctx->Current.RasterPos[0] + 0.5F);
#line 13858
  y = (int )(ctx->Current.RasterPos[1] + 0.5F);
#line 13859
  desty = y;
#line 13860
  i = 0U;
#line 13860
  while (i < (GLuint )height) {
#line 13862
    switch (type) {
    case 5121: 
#line 13865
    src = (GLubyte *)pixels + i * (GLuint )width;
#line 13866
    memcpy((void *)(stencil), (void const   *)((void *)src), (unsigned int )width);
#line 13868
    break;
    case 5120: 
#line 13871
    src___0 = (GLbyte *)pixels + i * (GLuint )width;
#line 13872
    memcpy((void *)(stencil), (void const   *)((void *)src___0), (unsigned int )width);
#line 13874
    break;
    case 5123: 
#line 13877
    src___1 = (GLushort *)pixels + i * (GLuint )width;
#line 13878
    j = 0U;
#line 13878
    while (j < (GLuint )width) {
#line 13879
      tmp___1 = src___1;
#line 13879
      src___1 ++;
#line 13879
      stencil[j] = (unsigned char )((int )*tmp___1 & 255);
#line 13878
      j ++;
    }
#line 13882
    break;
    case 5122: 
#line 13885
    src___2 = (GLshort *)pixels + i * (GLuint )width;
#line 13886
    j = 0U;
#line 13886
    while (j < (GLuint )width) {
#line 13887
      tmp___2 = src___2;
#line 13887
      src___2 ++;
#line 13887
      stencil[j] = (unsigned char )((int )*tmp___2 & 255);
#line 13886
      j ++;
    }
#line 13890
    break;
    case 5125: 
#line 13893
    src___3 = (GLuint *)pixels + i * (GLuint )width;
#line 13894
    j = 0U;
#line 13894
    while (j < (GLuint )width) {
#line 13895
      tmp___3 = src___3;
#line 13895
      src___3 ++;
#line 13895
      stencil[j] = (unsigned char )(*tmp___3 & 255U);
#line 13894
      j ++;
    }
#line 13898
    break;
    case 5124: 
#line 13901
    src___4 = (GLint *)pixels + i * (GLuint )width;
#line 13902
    j = 0U;
#line 13902
    while (j < (GLuint )width) {
#line 13903
      tmp___4 = src___4;
#line 13903
      src___4 ++;
#line 13903
      stencil[j] = (unsigned char )(*tmp___4 & 255);
#line 13902
      j ++;
    }
#line 13906
    break;
    case 6656: 
#line 13909
    break;
    case 5126: 
#line 13912
    src___5 = (float *)pixels + i * (GLuint )width;
#line 13913
    j = 0U;
#line 13913
    while (j < (GLuint )width) {
#line 13914
      tmp___5 = src___5;
#line 13914
      src___5 ++;
#line 13914
      stencil[j] = (unsigned char )((int )*tmp___5 & 255);
#line 13913
      j ++;
    }
#line 13917
    break;
    default: 
#line 13919
    gl_error(ctx, 1280, "Internal: draw_stencil_pixels");
    }
#line 13921
    if (ctx->Pixel.IndexOffset) {
      goto _L;
    } else {
#line 13921
      if (ctx->Pixel.IndexShift) {
        _L: /* CIL Label */ 
#line 13922
        if (ctx->Pixel.IndexShift >= 0) {
#line 13923
          j = 0U;
#line 13923
          while (j < (GLuint )width) {
#line 13924
            stencil[j] = (unsigned char )(((int )stencil[j] << ctx->Pixel.IndexShift) + ctx->Pixel.IndexOffset);
#line 13923
            j ++;
          }
        } else {
#line 13929
          j = 0U;
#line 13929
          while (j < (GLuint )width) {
#line 13930
            stencil[j] = (unsigned char )(((int )stencil[j] >> - ctx->Pixel.IndexShift) + ctx->Pixel.IndexOffset);
#line 13929
            j ++;
          }
        }
      }
    }
#line 13935
    if (ctx->Pixel.MapStencilFlag) {
#line 13936
      j = 0U;
#line 13936
      while (j < (GLuint )width) {
#line 13937
        stencil[j] = (unsigned char )ctx->Pixel.MapStoS[stencil[j]];
#line 13936
        j ++;
      }
    }
#line 13940
    if (zoom) {
#line 13941
      gl_write_zoomed_stencil_span(ctx, (unsigned int )width, x, y, stencil, desty);
    } else {
#line 13944
      gl_write_stencil_span(ctx, (unsigned int )width, x, y, stencil);
    }
#line 13860
    i ++;
#line 13860
    y ++;
  }
#line 13947
  return;
}
}
#line 13948 "D:/a/test/177.c"
static void draw_depth_pixels(GLcontext *ctx , GLsizei width , GLsizei height , GLenum type ,
                              GLvoid const   *pixels ) 
{ GLint x ;
  GLint y ;
  GLint desty ;
  GLubyte red[640] ;
  GLubyte green[640] ;
  GLubyte blue___0[640] ;
  GLubyte alpha[640] ;
  GLuint ispan[640] ;
  GLboolean bias_or_scale ;
  GLboolean zoom ;
  int tmp___0 ;
  int tmp___1 ;
  GLint r ;
  GLint g ;
  GLint b ;
  GLint a ;
  GLuint i ;
  GLuint j ;
  GLdepth *zptr ;
  GLuint i___0 ;
  GLuint j___0 ;
  GLuint shift ;
  GLuint max ;
  GLdepth zspan[640] ;
  GLuint *zptr___0 ;
  GLuint i___1 ;
  GLuint j___1 ;
  float depth[640] ;
  GLdepth zspan___0[640] ;
  GLubyte *src ;
  GLubyte *tmp___2 ;
  GLbyte *src___0 ;
  GLbyte *tmp___3 ;
  GLushort *src___1 ;
  GLushort *tmp___4 ;
  GLshort *src___2 ;
  GLshort *tmp___5 ;
  GLuint *src___3 ;
  GLuint *tmp___6 ;
  GLint *src___4 ;
  GLint *tmp___7 ;
  float *src___5 ;
  float *tmp___8 ;
  float tmp___9 ;
  float tmp___10 ;

  {
#line 13956
  if ((double )ctx->Pixel.DepthBias != 0.0) {
#line 13956
    tmp___0 = 1;
  } else {
#line 13956
    if ((double )ctx->Pixel.DepthScale != 1.0) {
#line 13956
      tmp___0 = 1;
    } else {
#line 13956
      tmp___0 = 0;
    }
  }
#line 13956
  bias_or_scale = (unsigned char )tmp___0;
#line 13957
  if ((double )ctx->Pixel.ZoomX != 1.0) {
#line 13957
    tmp___1 = 1;
  } else {
#line 13957
    if ((double )ctx->Pixel.ZoomY != 1.0) {
#line 13957
      tmp___1 = 1;
    } else {
#line 13957
      tmp___1 = 0;
    }
  }
#line 13957
  zoom = (unsigned char )tmp___1;
#line 13958
  x = (int )(ctx->Current.RasterPos[0] + 0.5F);
#line 13959
  y = (int )(ctx->Current.RasterPos[1] + 0.5F);
#line 13960
  desty = y;
#line 13961
  if ((ctx->Visual)->RGBAflag) {
#line 13963
    r = (int )(ctx->Current.RasterColor[0] * (ctx->Visual)->RedScale);
#line 13964
    g = (int )(ctx->Current.RasterColor[1] * (ctx->Visual)->GreenScale);
#line 13965
    b = (int )(ctx->Current.RasterColor[2] * (ctx->Visual)->BlueScale);
#line 13966
    a = (int )(ctx->Current.RasterColor[3] * (ctx->Visual)->AlphaScale);
#line 13967
    memset((void *)(red), r, (unsigned int )width);
#line 13968
    memset((void *)(green), g, (unsigned int )width);
#line 13969
    memset((void *)(blue___0), b, (unsigned int )width);
#line 13970
    memset((void *)(alpha), a, (unsigned int )width);
  } else {
#line 13974
    i = 0U;
#line 13974
    while (i < (GLuint )width) {
#line 13975
      ispan[i] = ctx->Current.RasterIndex;
#line 13974
      i ++;
    }
  }
#line 13978
  if (type == 5123) {
#line 13978
    if (sizeof(GLdepth ) == sizeof(GLushort )) {
#line 13978
      if (! bias_or_scale) {
#line 13978
        if (! zoom) {
#line 13978
          if ((ctx->Visual)->RGBAflag) {
#line 13981
            j = 0U;
#line 13981
            while (j < (GLuint )height) {
#line 13982
              zptr = (GLdepth *)pixels + j * (GLuint )width;
#line 13983
              gl_write_color_span(ctx, width, x, y, zptr, red, green, blue___0, alpha,
                                  6656);
#line 13981
              j ++;
#line 13981
              y ++;
            }
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else {
        goto _L___7;
      }
    } else {
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
#line 13987
    if (type == 5125) {
#line 13987
      if (sizeof(GLdepth ) == sizeof(GLuint )) {
#line 13987
        if (! bias_or_scale) {
#line 13987
          if (! zoom) {
#line 13987
            if ((ctx->Visual)->RGBAflag) {
#line 13990
              shift = (GLuint )0;
#line 13991
              max = (GLuint )65535;
#line 13992
              while ((max & 2147483648U) == 0U) {
#line 13993
                max <<= 1;
#line 13994
                shift ++;
              }
#line 13996
              j___0 = 0U;
#line 13996
              while (j___0 < (GLuint )height) {
#line 13998
                zptr___0 = (GLuint *)pixels + j___0 * (GLuint )width;
#line 13999
                i___0 = 0U;
#line 13999
                while (i___0 < (GLuint )width) {
#line 14000
                  zspan[i___0] = (unsigned short )(*(zptr___0 + i___0) >> shift);
#line 13999
                  i___0 ++;
                }
#line 14002
                gl_write_color_span(ctx, width, x, y, zspan, red, green, blue___0,
                                    alpha, 6656);
#line 13996
                j___0 ++;
#line 13996
                y ++;
              }
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        } else {
          goto _L___3;
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 14008
      i___1 = 0U;
#line 14008
      while (i___1 < (GLuint )height) {
#line 14011
        switch (type) {
        case 5121: 
#line 14014
        src = (GLubyte *)pixels + i___1 * (GLuint )width;
#line 14015
        j___1 = 0U;
#line 14015
        while (j___1 < (GLuint )width) {
#line 14016
          tmp___2 = src;
#line 14016
          src ++;
#line 14016
          depth[j___1] = (float )*tmp___2 * (1.0F / 255.0F);
#line 14015
          j___1 ++;
        }
#line 14019
        break;
        case 5120: 
#line 14022
        src___0 = (GLbyte *)pixels + i___1 * (GLuint )width;
#line 14023
        j___1 = 0U;
#line 14023
        while (j___1 < (GLuint )width) {
#line 14024
          tmp___3 = src___0;
#line 14024
          src___0 ++;
#line 14024
          depth[j___1] = (2.0F * (float )*tmp___3 + 1.0F) * (1.0F / 255.0F);
#line 14023
          j___1 ++;
        }
#line 14027
        break;
        case 5123: 
#line 14030
        src___1 = (GLushort *)pixels + i___1 * (GLuint )width;
#line 14031
        j___1 = 0U;
#line 14031
        while (j___1 < (GLuint )width) {
#line 14032
          tmp___4 = src___1;
#line 14032
          src___1 ++;
#line 14032
          depth[j___1] = (float )*tmp___4 * (1.0F / 65535.0F);
#line 14031
          j___1 ++;
        }
#line 14035
        break;
        case 5122: 
#line 14038
        src___2 = (GLshort *)pixels + i___1 * (GLuint )width;
#line 14039
        j___1 = 0U;
#line 14039
        while (j___1 < (GLuint )width) {
#line 14040
          tmp___5 = src___2;
#line 14040
          src___2 ++;
#line 14040
          depth[j___1] = (2.0F * (float )*tmp___5 + 1.0F) * (1.0F / 65535.0F);
#line 14039
          j___1 ++;
        }
#line 14043
        break;
        case 5125: 
#line 14046
        src___3 = (GLuint *)pixels + i___1 * (GLuint )width;
#line 14047
        j___1 = 0U;
#line 14047
        while (j___1 < (GLuint )width) {
#line 14048
          tmp___6 = src___3;
#line 14048
          src___3 ++;
#line 14048
          depth[j___1] = (float )*tmp___6 * (1.0F / 4294967295.0F);
#line 14047
          j___1 ++;
        }
#line 14051
        break;
        case 5124: 
#line 14054
        src___4 = (GLint *)pixels + i___1 * (GLuint )width;
#line 14055
        j___1 = 0U;
#line 14055
        while (j___1 < (GLuint )width) {
#line 14056
          tmp___7 = src___4;
#line 14056
          src___4 ++;
#line 14056
          depth[j___1] = (2.0F * (float )*tmp___7 + 1.0F) * (1.0F / 4294967294.0F);
#line 14055
          j___1 ++;
        }
#line 14059
        break;
        case 5126: 
#line 14062
        src___5 = (float *)pixels + i___1 * (GLuint )width;
#line 14063
        j___1 = 0U;
#line 14063
        while (j___1 < (GLuint )width) {
#line 14064
          tmp___8 = src___5;
#line 14064
          src___5 ++;
#line 14064
          depth[j___1] = *tmp___8;
#line 14063
          j___1 ++;
        }
#line 14067
        break;
        default: 
#line 14069
        gl_problem((GLcontext const   *)ctx, "Bad type in draw_depth_pixels");
#line 14070
        return;
        }
#line 14072
        if ((double )ctx->Pixel.DepthScale != 1.0) {
          goto _L;
        } else {
#line 14072
          if ((double )ctx->Pixel.DepthBias != 0.0) {
            _L: /* CIL Label */ 
#line 14073
            j___1 = 0U;
#line 14073
            while (j___1 < (GLuint )width) {
#line 14074
              depth[j___1] = depth[j___1] * ctx->Pixel.DepthScale + ctx->Pixel.DepthBias;
#line 14073
              j___1 ++;
            }
          }
        }
#line 14077
        j___1 = 0U;
#line 14077
        while (j___1 < (GLuint )width) {
#line 14078
          if (depth[j___1] < 0.0F) {
#line 14078
            tmp___10 = 0.0F;
          } else {
#line 14078
            if (depth[j___1] > 1.0F) {
#line 14078
              tmp___9 = 1.0F;
            } else {
#line 14078
              tmp___9 = depth[j___1];
            }
#line 14078
            tmp___10 = tmp___9;
          }
#line 14078
          zspan___0[j___1] = (unsigned short )(tmp___10 * 65535.0F);
#line 14077
          j___1 ++;
        }
#line 14080
        if ((ctx->Visual)->RGBAflag) {
#line 14081
          if (zoom) {
#line 14082
            gl_write_zoomed_color_span(ctx, width, x, y, zspan___0, red, green, blue___0,
                                       alpha, desty);
          } else {
#line 14086
            gl_write_color_span(ctx, width, x, y, zspan___0, red, green, blue___0,
                                alpha, 6656);
          }
        } else {
#line 14091
          if (zoom) {
#line 14092
            gl_write_zoomed_index_span(ctx, width, x, y, zspan___0, ispan, 6656);
          } else {
#line 14096
            gl_write_index_span(ctx, width, x, y, zspan___0, ispan, 6656);
          }
        }
#line 14008
        i___1 ++;
#line 14008
        y ++;
      }
    }
  }
#line 14101
  return;
}
}
#line 14102 "D:/a/test/177.c"
static void draw_color_pixels(GLcontext *ctx , GLsizei width , GLsizei height , GLenum format ,
                              GLenum type , GLvoid const   *pixels ) 
{ GLuint i ;
  GLuint j ;
  GLint x ;
  GLint y ;
  GLint desty ;
  GLdepth zspan[640] ;
  GLboolean scale_or_bias ;
  GLboolean quick_draw ;
  GLboolean zoom ;
  int tmp___0 ;
  GLdepth z ;
  GLubyte alpha[640] ;
  GLubyte *src ;
  GLubyte red[640] ;
  GLubyte green[640] ;
  GLubyte blue___0[640] ;
  GLubyte *tmp___1 ;
  GLubyte *tmp___2 ;
  GLubyte *tmp___3 ;
  GLubyte *lum ;
  GLboolean r_flag ;
  GLboolean g_flag ;
  GLboolean b_flag ;
  GLboolean a_flag ;
  GLboolean l_flag ;
  GLuint components ;
  float rf[640] ;
  float gf[640] ;
  float bf[640] ;
  float af[640] ;
  GLubyte red___0[640] ;
  GLubyte green___0[640] ;
  GLubyte blue___1[640] ;
  GLubyte alpha___0[640] ;
  GLubyte *src___0 ;
  float tmp___4 ;
  float tmp___5 ;
  GLubyte *tmp___6 ;
  GLubyte *tmp___7 ;
  GLubyte *tmp___8 ;
  GLubyte *tmp___9 ;
  GLubyte *tmp___10 ;
  GLbyte *src___1 ;
  float tmp___11 ;
  float tmp___12 ;
  GLbyte *tmp___13 ;
  GLbyte *tmp___14 ;
  GLbyte *tmp___15 ;
  GLbyte *tmp___16 ;
  GLbyte *tmp___17 ;
  GLushort *src___2 ;
  float tmp___18 ;
  float tmp___19 ;
  GLushort *tmp___20 ;
  GLushort *tmp___21 ;
  GLushort *tmp___22 ;
  GLushort *tmp___23 ;
  GLushort *tmp___24 ;
  GLshort *src___3 ;
  float tmp___25 ;
  float tmp___26 ;
  GLshort *tmp___27 ;
  GLshort *tmp___28 ;
  GLshort *tmp___29 ;
  GLshort *tmp___30 ;
  GLshort *tmp___31 ;
  GLuint *src___4 ;
  float tmp___32 ;
  float tmp___33 ;
  GLuint *tmp___34 ;
  GLuint *tmp___35 ;
  GLuint *tmp___36 ;
  GLuint *tmp___37 ;
  float tmp___38 ;
  GLuint *tmp___39 ;
  GLint *src___5 ;
  float tmp___40 ;
  float tmp___41 ;
  GLint *tmp___42 ;
  GLint *tmp___43 ;
  GLint *tmp___44 ;
  GLint *tmp___45 ;
  GLint *tmp___46 ;
  float *src___6 ;
  float tmp___47 ;
  float tmp___48 ;
  float *tmp___49 ;
  float *tmp___50 ;
  float *tmp___51 ;
  float *tmp___52 ;
  float *tmp___53 ;
  float r ;
  float g ;
  float b ;
  float a ;
  double tmp___54 ;
  double tmp___55 ;
  double tmp___56 ;
  double tmp___57 ;
  float rscale ;
  float gscale ;
  float bscale ;
  float ascale ;

  {
#line 14111
  if ((double )ctx->Pixel.ZoomX != 1.0) {
#line 14111
    tmp___0 = 1;
  } else {
#line 14111
    if ((double )ctx->Pixel.ZoomY != 1.0) {
#line 14111
      tmp___0 = 1;
    } else {
#line 14111
      tmp___0 = 0;
    }
  }
#line 14111
  zoom = (unsigned char )tmp___0;
#line 14112
  x = (int )(ctx->Current.RasterPos[0] + 0.5F);
#line 14113
  y = (int )(ctx->Current.RasterPos[1] + 0.5F);
#line 14114
  desty = y;
#line 14115
  if (ctx->Depth.Test) {
#line 14116
    z = (unsigned short )(ctx->Current.RasterPos[2] * 65535.0F);
#line 14117
    i = 0U;
#line 14117
    while (i < (GLuint )width) {
#line 14118
      zspan[i] = z;
#line 14117
      i ++;
    }
  }
#line 14121
  if (ctx->Pixel.RedScale != 1.0F) {
#line 14125
    scale_or_bias = (unsigned char)1;
  } else {
#line 14121
    if (ctx->Pixel.RedBias != 0.0F) {
#line 14125
      scale_or_bias = (unsigned char)1;
    } else {
#line 14121
      if (ctx->Pixel.GreenScale != 1.0F) {
#line 14125
        scale_or_bias = (unsigned char)1;
      } else {
#line 14121
        if (ctx->Pixel.GreenBias != 0.0F) {
#line 14125
          scale_or_bias = (unsigned char)1;
        } else {
#line 14121
          if (ctx->Pixel.BlueScale != 1.0F) {
#line 14125
            scale_or_bias = (unsigned char)1;
          } else {
#line 14121
            if (ctx->Pixel.BlueBias != 0.0F) {
#line 14125
              scale_or_bias = (unsigned char)1;
            } else {
#line 14121
              if (ctx->Pixel.AlphaScale != 1.0F) {
#line 14125
                scale_or_bias = (unsigned char)1;
              } else {
#line 14121
                if (ctx->Pixel.AlphaBias != 0.0F) {
#line 14125
                  scale_or_bias = (unsigned char)1;
                } else {
#line 14128
                  scale_or_bias = (unsigned char)0;
                }
              }
            }
          }
        }
      }
    }
  }
#line 14130
  if (ctx->RasterMask == 0U) {
#line 14130
    if (! zoom) {
#line 14130
      if (x >= 0) {
#line 14130
        if (y >= 0) {
#line 14130
          if (x + width <= (ctx->Buffer)->Width) {
#line 14130
            if (y + height <= (ctx->Buffer)->Height) {
#line 14132
              quick_draw = (unsigned char)1;
            } else {
#line 14135
              quick_draw = (unsigned char)0;
            }
          } else {
#line 14135
            quick_draw = (unsigned char)0;
          }
        } else {
#line 14135
          quick_draw = (unsigned char)0;
        }
      } else {
#line 14135
        quick_draw = (unsigned char)0;
      }
    } else {
#line 14135
      quick_draw = (unsigned char)0;
    }
  } else {
#line 14135
    quick_draw = (unsigned char)0;
  }
#line 14137
  if (type == 5121) {
#line 14137
    if (format == 6407) {
      goto _L___3;
    } else {
#line 14137
      if (format == 6409) {
        _L___3: /* CIL Label */ 
#line 14137
        if (! ctx->Pixel.MapColorFlag) {
#line 14137
          if (! scale_or_bias) {
#line 14137
            if ((ctx->Visual)->EightBitColor) {
#line 14141
              src = (GLubyte *)pixels;
#line 14142
              memset((void *)(alpha), (int )(ctx->Visual)->AlphaScale, (unsigned int )width);
#line 14143
              if (format == 6407) {
#line 14148
                i = 0U;
#line 14148
                while (i < (GLuint )height) {
#line 14149
                  j = 0U;
#line 14149
                  while (j < (GLuint )width) {
#line 14150
                    tmp___1 = src;
#line 14150
                    src ++;
#line 14150
                    red[j] = *tmp___1;
#line 14151
                    tmp___2 = src;
#line 14151
                    src ++;
#line 14151
                    green[j] = *tmp___2;
#line 14152
                    tmp___3 = src;
#line 14152
                    src ++;
#line 14152
                    blue___0[j] = *tmp___3;
#line 14149
                    j ++;
                  }
#line 14154
                  if (quick_draw) {
#line 14155
                    (*(ctx->Driver.WriteColorSpan))(ctx, (unsigned int )width, x,
                                                    y, (GLubyte const   *)(red), (GLubyte const   *)(green),
                                                    (GLubyte const   *)(blue___0),
                                                    (GLubyte const   *)(alpha), (GLubyte const   *)((void *)0));
                  } else {
#line 14158
                    if (zoom) {
#line 14159
                      gl_write_zoomed_color_span(ctx, (unsigned int )width, x, y,
                                                 zspan, red, green, blue___0, alpha,
                                                 desty);
                    } else {
#line 14163
                      gl_write_color_span(ctx, (unsigned int )width, x, y, zspan,
                                          red, green, blue___0, alpha, 6656);
                    }
                  }
#line 14148
                  i ++;
#line 14148
                  y ++;
                }
              } else {
#line 14173
                lum = (GLubyte *)pixels;
#line 14174
                i = 0U;
#line 14174
                while (i < (GLuint )height) {
#line 14175
                  if (quick_draw) {
#line 14176
                    (*(ctx->Driver.WriteColorSpan))(ctx, (unsigned int )width, x,
                                                    y, (GLubyte const   *)lum, (GLubyte const   *)lum,
                                                    (GLubyte const   *)lum, (GLubyte const   *)(alpha),
                                                    (GLubyte const   *)((void *)0));
                  } else {
#line 14179
                    if (zoom) {
#line 14180
                      gl_write_zoomed_color_span(ctx, (unsigned int )width, x, y,
                                                 zspan, lum, lum, lum, alpha, desty);
                    } else {
#line 14184
                      gl_write_color_span(ctx, (unsigned int )width, x, y, zspan,
                                          lum, lum, lum, alpha, 6656);
                    }
                  }
#line 14174
                  i ++;
#line 14174
                  y ++;
#line 14174
                  lum += width;
                }
              }
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    }
  } else {
    _L___2: /* CIL Label */ 
#line 14194
    l_flag = (unsigned char)0;
#line 14194
    a_flag = l_flag;
#line 14194
    b_flag = a_flag;
#line 14194
    g_flag = b_flag;
#line 14194
    r_flag = g_flag;
#line 14195
    switch (format) {
    case 6403: 
#line 14197
    r_flag = (unsigned char)1;
#line 14198
    components = 1U;
#line 14199
    break;
    case 6404: 
#line 14201
    g_flag = (unsigned char)1;
#line 14202
    components = 1U;
#line 14203
    break;
    case 6405: 
#line 14205
    b_flag = (unsigned char)1;
#line 14206
    components = 1U;
#line 14207
    break;
    case 6406: 
#line 14209
    a_flag = (unsigned char)1;
#line 14210
    components = 1U;
#line 14211
    break;
    case 6407: 
#line 14213
    b_flag = (unsigned char)1;
#line 14213
    g_flag = b_flag;
#line 14213
    r_flag = g_flag;
#line 14214
    components = 3U;
#line 14215
    break;
    case 6409: 
#line 14217
    l_flag = (unsigned char)1;
#line 14218
    components = 1U;
#line 14219
    break;
    case 6410: 
#line 14221
    a_flag = (unsigned char)1;
#line 14221
    l_flag = a_flag;
#line 14222
    components = 2U;
#line 14223
    break;
    case 6408: 
#line 14225
    a_flag = (unsigned char)1;
#line 14225
    b_flag = a_flag;
#line 14225
    g_flag = b_flag;
#line 14225
    r_flag = g_flag;
#line 14226
    components = 4U;
#line 14227
    break;
    default: 
#line 14229
    gl_problem((GLcontext const   *)ctx, "Bad type in draw_color_pixels");
#line 14230
    return;
    }
#line 14232
    i = 0U;
#line 14232
    while (i < (GLuint )height) {
#line 14242
      switch (type) {
      case 5121: 
#line 14245
      src___0 = (GLubyte *)pixels + (i * (GLuint )width) * components;
#line 14246
      j = 0U;
#line 14246
      while (j < (GLuint )width) {
#line 14247
        if (l_flag) {
#line 14248
          tmp___6 = src___0;
#line 14248
          src___0 ++;
#line 14248
          tmp___5 = (float )*tmp___6 * (1.0F / 255.0F);
#line 14248
          bf[j] = tmp___5;
#line 14248
          tmp___4 = tmp___5;
#line 14248
          gf[j] = tmp___4;
#line 14248
          rf[j] = tmp___4;
        } else {
#line 14251
          if (r_flag) {
#line 14251
            tmp___7 = src___0;
#line 14251
            src___0 ++;
#line 14251
            rf[j] = (float )*tmp___7 * (1.0F / 255.0F);
          } else {
#line 14251
            rf[j] = (float )0.0;
          }
#line 14252
          if (g_flag) {
#line 14252
            tmp___8 = src___0;
#line 14252
            src___0 ++;
#line 14252
            gf[j] = (float )*tmp___8 * (1.0F / 255.0F);
          } else {
#line 14252
            gf[j] = (float )0.0;
          }
#line 14253
          if (b_flag) {
#line 14253
            tmp___9 = src___0;
#line 14253
            src___0 ++;
#line 14253
            bf[j] = (float )*tmp___9 * (1.0F / 255.0F);
          } else {
#line 14253
            bf[j] = (float )0.0;
          }
        }
#line 14255
        if (a_flag) {
#line 14255
          tmp___10 = src___0;
#line 14255
          src___0 ++;
#line 14255
          af[j] = (float )*tmp___10 * (1.0F / 255.0F);
        } else {
#line 14255
          af[j] = (float )1.0;
        }
#line 14246
        j ++;
      }
#line 14258
      break;
      case 5120: 
#line 14261
      src___1 = (GLbyte *)pixels + (i * (GLuint )width) * components;
#line 14262
      j = 0U;
#line 14262
      while (j < (GLuint )width) {
#line 14263
        if (l_flag) {
#line 14264
          tmp___13 = src___1;
#line 14264
          src___1 ++;
#line 14264
          tmp___12 = (2.0F * (float )*tmp___13 + 1.0F) * (1.0F / 255.0F);
#line 14264
          bf[j] = tmp___12;
#line 14264
          tmp___11 = tmp___12;
#line 14264
          gf[j] = tmp___11;
#line 14264
          rf[j] = tmp___11;
        } else {
#line 14267
          if (r_flag) {
#line 14267
            tmp___14 = src___1;
#line 14267
            src___1 ++;
#line 14267
            rf[j] = (2.0F * (float )*tmp___14 + 1.0F) * (1.0F / 255.0F);
          } else {
#line 14267
            rf[j] = (float )0.0;
          }
#line 14268
          if (g_flag) {
#line 14268
            tmp___15 = src___1;
#line 14268
            src___1 ++;
#line 14268
            gf[j] = (2.0F * (float )*tmp___15 + 1.0F) * (1.0F / 255.0F);
          } else {
#line 14268
            gf[j] = (float )0.0;
          }
#line 14269
          if (b_flag) {
#line 14269
            tmp___16 = src___1;
#line 14269
            src___1 ++;
#line 14269
            bf[j] = (2.0F * (float )*tmp___16 + 1.0F) * (1.0F / 255.0F);
          } else {
#line 14269
            bf[j] = (float )0.0;
          }
        }
#line 14271
        if (a_flag) {
#line 14271
          tmp___17 = src___1;
#line 14271
          src___1 ++;
#line 14271
          af[j] = (2.0F * (float )*tmp___17 + 1.0F) * (1.0F / 255.0F);
        } else {
#line 14271
          af[j] = (float )1.0;
        }
#line 14262
        j ++;
      }
#line 14274
      break;
      case 6656: 
#line 14277
      break;
      case 5123: 
#line 14280
      src___2 = (GLushort *)pixels + (i * (GLuint )width) * components;
#line 14281
      j = 0U;
#line 14281
      while (j < (GLuint )width) {
#line 14282
        if (l_flag) {
#line 14283
          tmp___20 = src___2;
#line 14283
          src___2 ++;
#line 14283
          tmp___19 = (float )*tmp___20 * (1.0F / 65535.0F);
#line 14283
          bf[j] = tmp___19;
#line 14283
          tmp___18 = tmp___19;
#line 14283
          gf[j] = tmp___18;
#line 14283
          rf[j] = tmp___18;
        } else {
#line 14286
          if (r_flag) {
#line 14286
            tmp___21 = src___2;
#line 14286
            src___2 ++;
#line 14286
            rf[j] = (float )*tmp___21 * (1.0F / 65535.0F);
          } else {
#line 14286
            rf[j] = (float )0.0;
          }
#line 14287
          if (g_flag) {
#line 14287
            tmp___22 = src___2;
#line 14287
            src___2 ++;
#line 14287
            gf[j] = (float )*tmp___22 * (1.0F / 65535.0F);
          } else {
#line 14287
            gf[j] = (float )0.0;
          }
#line 14288
          if (b_flag) {
#line 14288
            tmp___23 = src___2;
#line 14288
            src___2 ++;
#line 14288
            bf[j] = (float )*tmp___23 * (1.0F / 65535.0F);
          } else {
#line 14288
            bf[j] = (float )0.0;
          }
        }
#line 14290
        if (a_flag) {
#line 14290
          tmp___24 = src___2;
#line 14290
          src___2 ++;
#line 14290
          af[j] = (float )*tmp___24 * (1.0F / 65535.0F);
        } else {
#line 14290
          af[j] = (float )1.0;
        }
#line 14281
        j ++;
      }
#line 14293
      break;
      case 5122: 
#line 14296
      src___3 = (GLshort *)pixels + (i * (GLuint )width) * components;
#line 14297
      j = 0U;
#line 14297
      while (j < (GLuint )width) {
#line 14298
        if (l_flag) {
#line 14299
          tmp___27 = src___3;
#line 14299
          src___3 ++;
#line 14299
          tmp___26 = (2.0F * (float )*tmp___27 + 1.0F) * (1.0F / 65535.0F);
#line 14299
          bf[j] = tmp___26;
#line 14299
          tmp___25 = tmp___26;
#line 14299
          gf[j] = tmp___25;
#line 14299
          rf[j] = tmp___25;
        } else {
#line 14302
          if (r_flag) {
#line 14302
            tmp___28 = src___3;
#line 14302
            src___3 ++;
#line 14302
            rf[j] = (2.0F * (float )*tmp___28 + 1.0F) * (1.0F / 65535.0F);
          } else {
#line 14302
            rf[j] = (float )0.0;
          }
#line 14303
          if (g_flag) {
#line 14303
            tmp___29 = src___3;
#line 14303
            src___3 ++;
#line 14303
            gf[j] = (2.0F * (float )*tmp___29 + 1.0F) * (1.0F / 65535.0F);
          } else {
#line 14303
            gf[j] = (float )0.0;
          }
#line 14304
          if (b_flag) {
#line 14304
            tmp___30 = src___3;
#line 14304
            src___3 ++;
#line 14304
            bf[j] = (2.0F * (float )*tmp___30 + 1.0F) * (1.0F / 65535.0F);
          } else {
#line 14304
            bf[j] = (float )0.0;
          }
        }
#line 14306
        if (a_flag) {
#line 14306
          tmp___31 = src___3;
#line 14306
          src___3 ++;
#line 14306
          af[j] = (2.0F * (float )*tmp___31 + 1.0F) * (1.0F / 65535.0F);
        } else {
#line 14306
          af[j] = (float )1.0;
        }
#line 14297
        j ++;
      }
#line 14309
      break;
      case 5125: 
#line 14312
      src___4 = (GLuint *)pixels + (i * (GLuint )width) * components;
#line 14313
      j = 0U;
#line 14313
      while (j < (GLuint )width) {
#line 14314
        if (l_flag) {
#line 14315
          tmp___34 = src___4;
#line 14315
          src___4 ++;
#line 14315
          tmp___33 = (float )*tmp___34 * (1.0F / 4294967295.0F);
#line 14315
          bf[j] = tmp___33;
#line 14315
          tmp___32 = tmp___33;
#line 14315
          gf[j] = tmp___32;
#line 14315
          rf[j] = tmp___32;
        } else {
#line 14318
          if (r_flag) {
#line 14318
            tmp___35 = src___4;
#line 14318
            src___4 ++;
#line 14318
            rf[j] = (float )*tmp___35 * (1.0F / 4294967295.0F);
          } else {
#line 14318
            rf[j] = (float )0.0;
          }
#line 14319
          if (g_flag) {
#line 14319
            tmp___36 = src___4;
#line 14319
            src___4 ++;
#line 14319
            gf[j] = (float )*tmp___36 * (1.0F / 4294967295.0F);
          } else {
#line 14319
            gf[j] = (float )0.0;
          }
#line 14320
          if (b_flag) {
#line 14320
            tmp___37 = src___4;
#line 14320
            src___4 ++;
#line 14320
            bf[j] = (float )*tmp___37 * (1.0F / 4294967295.0F);
          } else {
#line 14320
            bf[j] = (float )0.0;
          }
        }
#line 14322
        if (a_flag) {
#line 14322
          tmp___39 = src___4;
#line 14322
          src___4 ++;
#line 14322
          tmp___38 = (float )*tmp___39 * (1.0F / 4294967295.0F);
#line 14322
          af[j] = tmp___38;
#line 14322
          af[j] = tmp___38;
        } else {
#line 14322
          af[j] = (float )1.0;
        }
#line 14313
        j ++;
      }
#line 14325
      break;
      case 5124: 
#line 14328
      src___5 = (GLint *)pixels + (i * (GLuint )width) * components;
#line 14329
      j = 0U;
#line 14329
      while (j < (GLuint )width) {
#line 14330
        if (l_flag) {
#line 14331
          tmp___42 = src___5;
#line 14331
          src___5 ++;
#line 14331
          tmp___41 = (2.0F * (float )*tmp___42 + 1.0F) * (1.0F / 4294967294.0F);
#line 14331
          bf[j] = tmp___41;
#line 14331
          tmp___40 = tmp___41;
#line 14331
          gf[j] = tmp___40;
#line 14331
          rf[j] = tmp___40;
        } else {
#line 14334
          if (r_flag) {
#line 14334
            tmp___43 = src___5;
#line 14334
            src___5 ++;
#line 14334
            rf[j] = (2.0F * (float )*tmp___43 + 1.0F) * (1.0F / 4294967294.0F);
          } else {
#line 14334
            rf[j] = (float )0.0;
          }
#line 14335
          if (g_flag) {
#line 14335
            tmp___44 = src___5;
#line 14335
            src___5 ++;
#line 14335
            gf[j] = (2.0F * (float )*tmp___44 + 1.0F) * (1.0F / 4294967294.0F);
          } else {
#line 14335
            gf[j] = (float )0.0;
          }
#line 14336
          if (b_flag) {
#line 14336
            tmp___45 = src___5;
#line 14336
            src___5 ++;
#line 14336
            bf[j] = (2.0F * (float )*tmp___45 + 1.0F) * (1.0F / 4294967294.0F);
          } else {
#line 14336
            bf[j] = (float )0.0;
          }
        }
#line 14338
        if (a_flag) {
#line 14338
          tmp___46 = src___5;
#line 14338
          src___5 ++;
#line 14338
          af[j] = (2.0F * (float )*tmp___46 + 1.0F) * (1.0F / 4294967294.0F);
        } else {
#line 14338
          af[j] = (float )1.0;
        }
#line 14329
        j ++;
      }
#line 14341
      break;
      case 5126: 
#line 14344
      src___6 = (float *)pixels + (i * (GLuint )width) * components;
#line 14345
      j = 0U;
#line 14345
      while (j < (GLuint )width) {
#line 14346
        if (l_flag) {
#line 14347
          tmp___49 = src___6;
#line 14347
          src___6 ++;
#line 14347
          tmp___48 = *tmp___49;
#line 14347
          bf[j] = tmp___48;
#line 14347
          tmp___47 = tmp___48;
#line 14347
          gf[j] = tmp___47;
#line 14347
          rf[j] = tmp___47;
        } else {
#line 14350
          if (r_flag) {
#line 14350
            tmp___50 = src___6;
#line 14350
            src___6 ++;
#line 14350
            rf[j] = *tmp___50;
          } else {
#line 14350
            rf[j] = (float )0.0;
          }
#line 14351
          if (g_flag) {
#line 14351
            tmp___51 = src___6;
#line 14351
            src___6 ++;
#line 14351
            gf[j] = *tmp___51;
          } else {
#line 14351
            gf[j] = (float )0.0;
          }
#line 14352
          if (b_flag) {
#line 14352
            tmp___52 = src___6;
#line 14352
            src___6 ++;
#line 14352
            bf[j] = *tmp___52;
          } else {
#line 14352
            bf[j] = (float )0.0;
          }
        }
#line 14354
        if (a_flag) {
#line 14354
          tmp___53 = src___6;
#line 14354
          src___6 ++;
#line 14354
          af[j] = *tmp___53;
        } else {
#line 14354
          af[j] = (float )1.0;
        }
#line 14345
        j ++;
      }
#line 14357
      break;
      default: 
#line 14359
      gl_error(ctx, 1280, "glDrawPixels");
#line 14360
      return;
      }
#line 14363
      if (scale_or_bias) {
#line 14364
        j = 0U;
#line 14364
        while (j < (GLuint )width) {
#line 14366
          r = rf[j] * ctx->Pixel.RedScale + ctx->Pixel.RedBias;
#line 14367
          g = gf[j] * ctx->Pixel.GreenScale + ctx->Pixel.GreenBias;
#line 14368
          b = bf[j] * ctx->Pixel.BlueScale + ctx->Pixel.BlueBias;
#line 14369
          a = af[j] * ctx->Pixel.AlphaScale + ctx->Pixel.AlphaBias;
#line 14370
          if ((double )r < 0.0) {
#line 14370
            rf[j] = (float )0.0;
          } else {
#line 14370
            if ((double )r > 1.0) {
#line 14370
              tmp___54 = 1.0;
            } else {
#line 14370
              tmp___54 = (double )r;
            }
#line 14370
            rf[j] = (float )tmp___54;
          }
#line 14371
          if ((double )g < 0.0) {
#line 14371
            gf[j] = (float )0.0;
          } else {
#line 14371
            if ((double )g > 1.0) {
#line 14371
              tmp___55 = 1.0;
            } else {
#line 14371
              tmp___55 = (double )g;
            }
#line 14371
            gf[j] = (float )tmp___55;
          }
#line 14372
          if ((double )b < 0.0) {
#line 14372
            bf[j] = (float )0.0;
          } else {
#line 14372
            if ((double )b > 1.0) {
#line 14372
              tmp___56 = 1.0;
            } else {
#line 14372
              tmp___56 = (double )b;
            }
#line 14372
            bf[j] = (float )tmp___56;
          }
#line 14373
          if ((double )a < 0.0) {
#line 14373
            af[j] = (float )0.0;
          } else {
#line 14373
            if ((double )a > 1.0) {
#line 14373
              tmp___57 = 1.0;
            } else {
#line 14373
              tmp___57 = (double )a;
            }
#line 14373
            af[j] = (float )tmp___57;
          }
#line 14364
          j ++;
        }
      }
#line 14377
      if (ctx->Pixel.MapColorFlag) {
#line 14378
        rscale = (float )(ctx->Pixel.MapRtoRsize - 1);
#line 14379
        gscale = (float )(ctx->Pixel.MapGtoGsize - 1);
#line 14380
        bscale = (float )(ctx->Pixel.MapBtoBsize - 1);
#line 14381
        ascale = (float )(ctx->Pixel.MapAtoAsize - 1);
#line 14382
        j = 0U;
#line 14382
        while (j < (GLuint )width) {
#line 14383
          rf[j] = ctx->Pixel.MapRtoR[(int )(rf[j] * rscale)];
#line 14384
          gf[j] = ctx->Pixel.MapGtoG[(int )(gf[j] * gscale)];
#line 14385
          bf[j] = ctx->Pixel.MapBtoB[(int )(bf[j] * bscale)];
#line 14386
          af[j] = ctx->Pixel.MapAtoA[(int )(af[j] * ascale)];
#line 14382
          j ++;
        }
      }
#line 14390
      j = 0U;
#line 14390
      while (j < (GLuint )width) {
#line 14391
        red___0[j] = (unsigned char )((int )(rf[j] * (ctx->Visual)->RedScale));
#line 14392
        green___0[j] = (unsigned char )((int )(gf[j] * (ctx->Visual)->GreenScale));
#line 14393
        blue___1[j] = (unsigned char )((int )(bf[j] * (ctx->Visual)->BlueScale));
#line 14394
        alpha___0[j] = (unsigned char )((int )(af[j] * (ctx->Visual)->AlphaScale));
#line 14390
        j ++;
      }
#line 14397
      if (quick_draw) {
#line 14398
        (*(ctx->Driver.WriteColorSpan))(ctx, (unsigned int )width, x, y, (GLubyte const   *)(red___0),
                                        (GLubyte const   *)(green___0), (GLubyte const   *)(blue___1),
                                        (GLubyte const   *)(alpha___0), (GLubyte const   *)((void *)0));
      } else {
#line 14401
        if (zoom) {
#line 14402
          gl_write_zoomed_color_span(ctx, width, x, y, zspan, red___0, green___0,
                                     blue___1, alpha___0, desty);
        } else {
#line 14406
          gl_write_color_span(ctx, (unsigned int )width, x, y, zspan, red___0, green___0,
                              blue___1, alpha___0, 6656);
        }
      }
#line 14232
      i ++;
#line 14232
      y ++;
    }
  }
#line 14419
  return;
}
}
#line 14420 "D:/a/test/177.c"
static GLboolean quickdraw_rgb(GLcontext *ctx , GLsizei width , GLsizei height , void const   *pixels ) 
{ GLubyte red[640] ;
  GLubyte green[640] ;
  GLubyte blue___0[640] ;
  GLubyte alpha[640] ;
  GLint i ;
  GLint j ;
  GLint x ;
  GLint y ;
  GLint bytes_per_row ;
  GLboolean result ;
  GLubyte *src ;
  GLubyte *tmp___0 ;
  GLubyte *tmp___1 ;
  GLubyte *tmp___2 ;

  {
#line 14431
  bytes_per_row = width * 3 + width % ctx->Unpack.Alignment;
#line 14432
  if (! ctx->Current.RasterPosValid) {
#line 14433
    result = (unsigned char)1;
  } else {
#line 14436
    x = (int )(ctx->Current.RasterPos[0] + 0.5F);
#line 14437
    y = (int )(ctx->Current.RasterPos[1] + 0.5F);
#line 14438
    if (x < 0) {
#line 14440
      result = (unsigned char)0;
    } else {
#line 14438
      if (y < 0) {
#line 14440
        result = (unsigned char)0;
      } else {
#line 14438
        if (x + width > (ctx->Buffer)->Width) {
#line 14440
          result = (unsigned char)0;
        } else {
#line 14438
          if (y + height > (ctx->Buffer)->Height) {
#line 14440
            result = (unsigned char)0;
          } else {
#line 14443
            j = 0;
#line 14443
            while (j < width) {
#line 14444
              alpha[j] = (unsigned char )((int )(ctx->Visual)->AlphaScale);
#line 14443
              j ++;
            }
#line 14446
            i = 0;
#line 14446
            while (i < height) {
#line 14447
              src = (GLubyte *)pixels + i * bytes_per_row;
#line 14448
              j = 0;
#line 14448
              while (j < width) {
#line 14449
                tmp___0 = src;
#line 14449
                src ++;
#line 14449
                red[j] = *tmp___0;
#line 14450
                tmp___1 = src;
#line 14450
                src ++;
#line 14450
                green[j] = *tmp___1;
#line 14451
                tmp___2 = src;
#line 14451
                src ++;
#line 14451
                blue___0[j] = *tmp___2;
#line 14448
                j ++;
              }
#line 14453
              (*(ctx->Driver.WriteColorSpan))(ctx, (unsigned int )width, x, y + i,
                                              (GLubyte const   *)(red), (GLubyte const   *)(green),
                                              (GLubyte const   *)(blue___0), (GLubyte const   *)(alpha),
                                              (GLubyte const   *)((void *)0));
#line 14446
              i ++;
            }
#line 14456
            result = (unsigned char)1;
          }
        }
      }
    }
  }
#line 14463
  return (result);
}
}
#line 14465 "D:/a/test/177.c"
static void drawpixels(GLcontext *ctx , GLsizei width , GLsizei height , GLenum format ,
                       GLenum type , GLvoid const   *pixels ) 
{ float color[4] ;
  float texcoord[4] ;
  float invq ;

  {
#line 14468
  if (ctx->Primitive != 6656) {
#line 14469
    gl_error(ctx, 1282, "glDrawPixels");
#line 14470
    return;
  }
#line 14472
  if (ctx->RenderMode == 7168) {
#line 14473
    if (! ctx->Current.RasterPosValid) {
#line 14474
      return;
    }
#line 14476
    switch (format) {
    case 6400: 
#line 14478
    draw_index_pixels(ctx, width, height, type, pixels);
#line 14479
    break;
    case 6401: 
#line 14481
    draw_stencil_pixels(ctx, width, height, type, pixels);
#line 14482
    break;
    case 6402: 
#line 14484
    draw_depth_pixels(ctx, width, height, type, pixels);
#line 14485
    break;
    case 6403: 
    case 6404: 
    case 6405: 
    case 6406: 
    case 6407: 
    case 6409: 
    case 6410: 
    case 6408: 
#line 14494
    draw_color_pixels(ctx, width, height, format, type, pixels);
#line 14495
    break;
    default: 
#line 14497
    gl_error(ctx, 1280, "glDrawPixels");
    }
  } else {
#line 14500
    if (ctx->RenderMode == 7169) {
#line 14501
      if (ctx->Current.RasterPosValid) {
#line 14503
        color[0] = (float )ctx->Current.ByteColor[0] * (ctx->Visual)->InvRedScale;
#line 14504
        color[1] = (float )ctx->Current.ByteColor[1] * (ctx->Visual)->InvGreenScale;
#line 14505
        color[2] = (float )ctx->Current.ByteColor[2] * (ctx->Visual)->InvBlueScale;
#line 14506
        color[3] = (float )ctx->Current.ByteColor[3] * (ctx->Visual)->InvAlphaScale;
#line 14507
        invq = 1.0F / ctx->Current.TexCoord[3];
#line 14508
        texcoord[0] = ctx->Current.TexCoord[0] * invq;
#line 14509
        texcoord[1] = ctx->Current.TexCoord[1] * invq;
#line 14510
        texcoord[2] = ctx->Current.TexCoord[2] * invq;
#line 14511
        texcoord[3] = ctx->Current.TexCoord[3];
#line 14512
        FEEDBACK_TOKEN(ctx, (float )1797);
#line 14513
        gl_feedback_vertex(ctx, ctx->Current.RasterPos[0], ctx->Current.RasterPos[1],
                           ctx->Current.RasterPos[2], ctx->Current.RasterPos[3], color,
                           ctx->Current.Index, texcoord);
      }
    } else {
#line 14520
      if (ctx->RenderMode == 7170) {
#line 14521
        if (ctx->Current.RasterPosValid) {
#line 14522
          gl_update_hitflag(ctx, ctx->Current.RasterPos[2]);
        }
      }
    }
  }
#line 14525
  return;
}
}
#line 14553
GLvoid *gl_unpack_pixels(GLcontext *ctx , GLsizei width , GLsizei height , GLenum format ,
                         GLenum type , GLvoid const   *pixels ) ;
#line 14526 "D:/a/test/177.c"
void gl_DrawPixels(GLcontext *ctx , GLsizei width , GLsizei height , GLenum format ,
                   GLenum type , GLvoid const   *pixels ) 
{ GLvoid *image ;
  GLint x ;
  GLint y ;
  GLboolean tmp___0 ;
  GLboolean tmp___1 ;
  int tmp___2 ;

  {
#line 14530
  if (width < 0) {
#line 14531
    gl_error(ctx, 1281, "glDrawPixels");
#line 14532
    return;
  } else {
#line 14530
    if (height < 0) {
#line 14531
      gl_error(ctx, 1281, "glDrawPixels");
#line 14532
      return;
    }
  }
#line 14534
  if (ctx->NewState) {
#line 14535
    gl_update_state(ctx);
  }
#line 14537
  if (! ctx->CompileFlag) {
#line 14537
    if (ctx->Driver.DrawPixels) {
#line 14538
      x = (int )(ctx->Current.RasterPos[0] + 0.5F);
#line 14539
      y = (int )(ctx->Current.RasterPos[1] + 0.5F);
#line 14540
      tmp___0 = (*(ctx->Driver.DrawPixels))(ctx, x, y, width, height, format, type,
                                            (unsigned char)0, pixels);
#line 14540
      if (tmp___0) {
#line 14542
        return;
      }
    }
  }
#line 14545
  if (format == 6407) {
#line 14545
    if (type == 5121) {
#line 14545
      if (ctx->FastDrawPixels) {
#line 14545
        if (! ctx->CompileFlag) {
#line 14545
          if (ctx->RenderMode == 7168) {
#line 14545
            if (ctx->RasterMask == 0U) {
#line 14545
              if (ctx->CallDepth == 0U) {
#line 14548
                tmp___1 = quickdraw_rgb(ctx, width, height, pixels);
#line 14548
                if (tmp___1) {
#line 14549
                  return;
                }
              }
            }
          }
        }
      }
    }
  }
#line 14552
  if (ctx->CallDepth == 0U) {
#line 14553
    tmp___2 = (int )gl_unpack_pixels(ctx, width, height, format, type, pixels);
#line 14553
    image = (GLvoid *)tmp___2;
#line 14554
    if (! image) {
#line 14555
      gl_error(ctx, 1285, "glDrawPixels");
#line 14556
      return;
    }
  } else {
#line 14560
    image = (GLvoid *)pixels;
  }
#line 14562
  if (ctx->CompileFlag) {
#line 14563
    gl_save_DrawPixels(ctx, width, height, format, type, (GLvoid const   *)image);
  }
#line 14565
  if (ctx->ExecuteFlag) {
#line 14566
    drawpixels(ctx, width, height, format, type, (GLvoid const   *)image);
#line 14567
    if (! ctx->CompileFlag) {
#line 14568
      if ((unsigned int )image != (unsigned int )pixels) {
#line 14569
        free(image);
      }
    }
  }
#line 14572
  return;
}
}
#line 14637
void gl_set_material(GLcontext *ctx , GLuint bitmask , float const   *params ) ;
#line 14578 "D:/a/test/177.c"
static void gl_enable(GLcontext *ctx , GLenum cap , GLboolean state ) 
{ GLuint p ;
  float color[4] ;

  {
#line 14581
  if (ctx->Primitive != 6656) {
#line 14582
    if (state) {
#line 14583
      gl_error(ctx, 1282, "glEnable");
    } else {
#line 14586
      gl_error(ctx, 1282, "glDisable");
    }
#line 14588
    return;
  }
#line 14590
  switch (cap) {
  case 3008: 
#line 14592
  if ((int )ctx->Color.AlphaEnabled != (int )state) {
#line 14593
    ctx->Color.AlphaEnabled = state;
#line 14594
    ctx->NewState |= 2U;
  }
#line 14596
  break;
  case 3456: 
#line 14598
  ctx->Eval.AutoNormal = state;
#line 14599
  break;
  case 3042: 
#line 14601
  if ((int )ctx->Color.BlendEnabled != (int )state) {
#line 14602
    ctx->Color.BlendEnabled = state;
#line 14603
    if (ctx->Color.BlendEquation == 3057) {
#line 14603
      if (state) {
#line 14604
        ctx->Color.ColorLogicOpEnabled = (unsigned char)1;
      } else {
#line 14607
        ctx->Color.ColorLogicOpEnabled = (unsigned char)0;
      }
    } else {
#line 14607
      ctx->Color.ColorLogicOpEnabled = (unsigned char)0;
    }
#line 14609
    ctx->NewState |= 2U;
  }
#line 14611
  break;
  case 12288: 
  case 12289: 
  case 12290: 
  case 12291: 
  case 12292: 
  case 12293: 
#line 14618
  ctx->Transform.ClipEnabled[cap - 12288] = state;
#line 14620
  ctx->Transform.AnyClip = (unsigned char)0;
#line 14621
  p = 0U;
#line 14621
  while (p < 6U) {
#line 14622
    if (ctx->Transform.ClipEnabled[p]) {
#line 14623
      ctx->Transform.AnyClip = (unsigned char)1;
#line 14624
      break;
    }
#line 14621
    p ++;
  }
#line 14627
  break;
  case 2903: 
#line 14629
  if ((int )ctx->Light.ColorMaterialEnabled != (int )state) {
#line 14630
    ctx->Light.ColorMaterialEnabled = state;
#line 14631
    if (state) {
#line 14633
      color[0] = (float )ctx->Current.ByteColor[0] * (ctx->Visual)->InvRedScale;
#line 14634
      color[1] = (float )ctx->Current.ByteColor[1] * (ctx->Visual)->InvGreenScale;
#line 14635
      color[2] = (float )ctx->Current.ByteColor[2] * (ctx->Visual)->InvBlueScale;
#line 14636
      color[3] = (float )ctx->Current.ByteColor[3] * (ctx->Visual)->InvAlphaScale;
#line 14637
      gl_set_material(ctx, ctx->Light.ColorMaterialBitmask, color);
    }
#line 14639
    gl_set_color_function(ctx);
#line 14640
    ctx->NewState |= 1U;
  }
#line 14642
  break;
  case 2884: 
#line 14644
  if ((int )ctx->Polygon.CullFlag != (int )state) {
#line 14645
    ctx->Polygon.CullFlag = state;
#line 14646
    ctx->NewState |= 8U;
  }
#line 14648
  break;
  case 2929: 
#line 14650
  if (state) {
#line 14650
    if ((ctx->Visual)->DepthBits == 0) {
#line 14651
      gl_warning((GLcontext const   *)ctx, "glEnable(GL_DEPTH_TEST) but no depth buffer");
#line 14652
      return;
    }
  }
#line 14654
  if ((int )ctx->Depth.Test != (int )state) {
#line 14655
    ctx->Depth.Test = state;
#line 14656
    ctx->NewState |= 2U;
  }
#line 14658
  break;
  case 3024: 
#line 14660
  if (ctx->NoDither) {
#line 14661
    state = (unsigned char)0;
  }
#line 14663
  if ((int )ctx->Color.DitherFlag != (int )state) {
#line 14664
    ctx->Color.DitherFlag = state;
#line 14665
    ctx->NewState |= 2U;
  }
#line 14667
  break;
  case 2912: 
#line 14669
  if ((int )ctx->Fog.Enabled != (int )state) {
#line 14670
    ctx->Fog.Enabled = state;
#line 14671
    ctx->NewState |= 2U;
  }
#line 14673
  break;
  case 16384: 
  case 16385: 
  case 16386: 
  case 16387: 
  case 16388: 
  case 16389: 
  case 16390: 
  case 16391: 
#line 14682
  ctx->Light.Light[cap - 16384].Enabled = state;
#line 14683
  ctx->NewState |= 1U;
#line 14684
  break;
  case 2896: 
#line 14686
  if ((int )ctx->Light.Enabled != (int )state) {
#line 14687
    ctx->Light.Enabled = state;
#line 14688
    ctx->NewState |= 1U;
  }
#line 14690
  break;
  case 2848: 
#line 14692
  if ((int )ctx->Line.SmoothFlag != (int )state) {
#line 14693
    ctx->Line.SmoothFlag = state;
#line 14694
    ctx->NewState |= 2U;
  }
#line 14696
  break;
  case 2852: 
#line 14698
  if ((int )ctx->Line.StippleFlag != (int )state) {
#line 14699
    ctx->Line.StippleFlag = state;
#line 14700
    ctx->NewState |= 2U;
  }
#line 14702
  break;
  case 3057: 
#line 14704
  if ((int )ctx->Color.IndexLogicOpEnabled != (int )state) {
#line 14705
    ctx->NewState |= 2U;
  }
#line 14707
  ctx->Color.IndexLogicOpEnabled = state;
#line 14708
  break;
  case 3058: 
#line 14710
  if ((int )ctx->Color.ColorLogicOpEnabled != (int )state) {
#line 14711
    ctx->NewState |= 2U;
  }
#line 14713
  ctx->Color.ColorLogicOpEnabled = state;
#line 14714
  break;
  case 3472: 
#line 14716
  ctx->Eval.Map1Color4 = state;
#line 14717
  break;
  case 3473: 
#line 14719
  ctx->Eval.Map1Index = state;
#line 14720
  break;
  case 3474: 
#line 14722
  ctx->Eval.Map1Normal = state;
#line 14723
  break;
  case 3475: 
#line 14725
  ctx->Eval.Map1TextureCoord1 = state;
#line 14726
  break;
  case 3476: 
#line 14728
  ctx->Eval.Map1TextureCoord2 = state;
#line 14729
  break;
  case 3477: 
#line 14731
  ctx->Eval.Map1TextureCoord3 = state;
#line 14732
  break;
  case 3478: 
#line 14734
  ctx->Eval.Map1TextureCoord4 = state;
#line 14735
  break;
  case 3479: 
#line 14737
  ctx->Eval.Map1Vertex3 = state;
#line 14738
  break;
  case 3480: 
#line 14740
  ctx->Eval.Map1Vertex4 = state;
#line 14741
  break;
  case 3504: 
#line 14743
  ctx->Eval.Map2Color4 = state;
#line 14744
  break;
  case 3505: 
#line 14746
  ctx->Eval.Map2Index = state;
#line 14747
  break;
  case 3506: 
#line 14749
  ctx->Eval.Map2Normal = state;
#line 14750
  break;
  case 3507: 
#line 14752
  ctx->Eval.Map2TextureCoord1 = state;
#line 14753
  break;
  case 3508: 
#line 14755
  ctx->Eval.Map2TextureCoord2 = state;
#line 14756
  break;
  case 3509: 
#line 14758
  ctx->Eval.Map2TextureCoord3 = state;
#line 14759
  break;
  case 3510: 
#line 14761
  ctx->Eval.Map2TextureCoord4 = state;
#line 14762
  break;
  case 3511: 
#line 14764
  ctx->Eval.Map2Vertex3 = state;
#line 14765
  break;
  case 3512: 
#line 14767
  ctx->Eval.Map2Vertex4 = state;
#line 14768
  break;
  case 2977: 
#line 14770
  ctx->Transform.Normalize = state;
#line 14771
  break;
  case 2832: 
#line 14773
  if ((int )ctx->Point.SmoothFlag != (int )state) {
#line 14774
    ctx->Point.SmoothFlag = state;
#line 14775
    ctx->NewState |= 2U;
  }
#line 14777
  break;
  case 2881: 
#line 14779
  if ((int )ctx->Polygon.SmoothFlag != (int )state) {
#line 14780
    ctx->Polygon.SmoothFlag = state;
#line 14781
    ctx->NewState |= 2U;
  }
#line 14783
  break;
  case 2882: 
#line 14785
  if ((int )ctx->Polygon.StippleFlag != (int )state) {
#line 14786
    ctx->Polygon.StippleFlag = state;
#line 14787
    ctx->NewState |= 2U;
  }
#line 14789
  break;
  case 10753: 
#line 14791
  if ((int )ctx->Polygon.OffsetPoint != (int )state) {
#line 14792
    ctx->Polygon.OffsetPoint = state;
#line 14793
    ctx->NewState |= 8U;
  }
#line 14795
  break;
  case 10754: 
#line 14797
  if ((int )ctx->Polygon.OffsetLine != (int )state) {
#line 14798
    ctx->Polygon.OffsetLine = state;
#line 14799
    ctx->NewState |= 8U;
  }
#line 14801
  break;
  case 32823: 
#line 14803
  if ((int )ctx->Polygon.OffsetFill != (int )state) {
#line 14804
    ctx->Polygon.OffsetFill = state;
#line 14805
    ctx->NewState |= 8U;
  }
#line 14807
  break;
  case 3089: 
#line 14809
  if ((int )ctx->Scissor.Enabled != (int )state) {
#line 14810
    ctx->Scissor.Enabled = state;
#line 14811
    ctx->NewState |= 2U;
  }
#line 14813
  break;
  case 33275: 
#line 14815
  ctx->Texture.SharedPalette = state;
#line 14816
  if (ctx->Driver.UseGlobalTexturePalette) {
#line 14817
    (*(ctx->Driver.UseGlobalTexturePalette))(ctx, state);
  }
#line 14818
  break;
  case 2960: 
#line 14820
  if (state) {
#line 14820
    if ((ctx->Visual)->StencilBits == 0) {
#line 14821
      gl_warning((GLcontext const   *)ctx, "glEnable(GL_STENCIL_TEST) but no stencil buffer");
#line 14822
      return;
    }
  }
#line 14824
  if ((int )ctx->Stencil.Enabled != (int )state) {
#line 14825
    ctx->Stencil.Enabled = state;
#line 14826
    ctx->NewState |= 2U;
  }
#line 14828
  break;
  case 3552: 
#line 14830
  if ((ctx->Visual)->RGBAflag) {
#line 14831
    if (state) {
#line 14832
      ctx->Texture.Enabled |= 1U;
    } else {
#line 14835
      ctx->Texture.Enabled &= 4294967294U;
    }
#line 14837
    ctx->NewState |= 6U;
  }
#line 14839
  break;
  case 3553: 
#line 14841
  if ((ctx->Visual)->RGBAflag) {
#line 14842
    if (state) {
#line 14843
      ctx->Texture.Enabled |= 2U;
    } else {
#line 14846
      ctx->Texture.Enabled &= 4294967293U;
    }
#line 14848
    ctx->NewState |= 6U;
  }
#line 14850
  break;
  case 32879: 
#line 14852
  if ((ctx->Visual)->RGBAflag) {
#line 14853
    if (state) {
#line 14854
      ctx->Texture.Enabled |= 4U;
    } else {
#line 14857
      ctx->Texture.Enabled &= 4294967291U;
    }
#line 14859
    ctx->NewState |= 6U;
  }
#line 14861
  break;
  case 3171: 
#line 14863
  if (state) {
#line 14864
    ctx->Texture.TexGenEnabled |= 1U;
  } else {
#line 14867
    ctx->Texture.TexGenEnabled &= 4294967294U;
  }
#line 14869
  ctx->NewState |= 4U;
#line 14870
  break;
  case 3170: 
#line 14872
  if (state) {
#line 14873
    ctx->Texture.TexGenEnabled |= 2U;
  } else {
#line 14876
    ctx->Texture.TexGenEnabled &= 4294967293U;
  }
#line 14878
  ctx->NewState |= 4U;
#line 14879
  break;
  case 3168: 
#line 14881
  if (state) {
#line 14882
    ctx->Texture.TexGenEnabled |= 4U;
  } else {
#line 14885
    ctx->Texture.TexGenEnabled &= 4294967291U;
  }
#line 14887
  ctx->NewState |= 4U;
#line 14888
  break;
  case 3169: 
#line 14890
  if (state) {
#line 14891
    ctx->Texture.TexGenEnabled |= 8U;
  } else {
#line 14894
    ctx->Texture.TexGenEnabled &= 4294967287U;
  }
#line 14896
  ctx->NewState |= 4U;
#line 14897
  break;
  case 32884: 
#line 14899
  ctx->Array.VertexEnabled = state;
#line 14900
  break;
  case 32885: 
#line 14902
  ctx->Array.NormalEnabled = state;
#line 14903
  break;
  case 32886: 
#line 14905
  ctx->Array.ColorEnabled = state;
#line 14906
  break;
  case 32887: 
#line 14908
  ctx->Array.IndexEnabled = state;
#line 14909
  break;
  case 32888: 
#line 14911
  ctx->Array.TexCoordEnabled = state;
#line 14912
  break;
  case 32889: 
#line 14914
  ctx->Array.EdgeFlagEnabled = state;
#line 14915
  break;
  default: ;
#line 14917
  if (state) {
#line 14918
    gl_error(ctx, 1280, "glEnable");
  } else {
#line 14921
    gl_error(ctx, 1280, "glDisable");
  }
#line 14923
  break;
  }
#line 14925
  return;
}
}
#line 14926 "D:/a/test/177.c"
void gl_Enable(GLcontext *ctx , GLenum cap ) 
{ 

  {
#line 14928
  gl_enable(ctx, cap, (unsigned char)1);
#line 14929
  return;
}
}
#line 14930 "D:/a/test/177.c"
void gl_Disable(GLcontext *ctx , GLenum cap ) 
{ 

  {
#line 14932
  gl_enable(ctx, cap, (unsigned char)0);
#line 14933
  return;
}
}
#line 14934 "D:/a/test/177.c"
GLboolean gl_IsEnabled(GLcontext *ctx , GLenum cap ) 
{ int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 14936
  switch (cap) {
  case 3008: 
#line 14938
  return (ctx->Color.AlphaEnabled);
  case 3456: 
#line 14940
  return (ctx->Eval.AutoNormal);
  case 3042: 
#line 14942
  return (ctx->Color.BlendEnabled);
  case 12288: 
  case 12289: 
  case 12290: 
  case 12291: 
  case 12292: 
  case 12293: 
#line 14949
  return (ctx->Transform.ClipEnabled[cap - 12288]);
  case 2903: 
#line 14951
  return (ctx->Light.ColorMaterialEnabled);
  case 2884: 
#line 14953
  return (ctx->Polygon.CullFlag);
  case 2929: 
#line 14955
  return (ctx->Depth.Test);
  case 3024: 
#line 14957
  return (ctx->Color.DitherFlag);
  case 2912: 
#line 14959
  return (ctx->Fog.Enabled);
  case 2896: 
#line 14961
  return (ctx->Light.Enabled);
  case 16384: 
  case 16385: 
  case 16386: 
  case 16387: 
  case 16388: 
  case 16389: 
  case 16390: 
  case 16391: 
#line 14970
  return (ctx->Light.Light[cap - 16384].Enabled);
  case 2848: 
#line 14972
  return (ctx->Line.SmoothFlag);
  case 2852: 
#line 14974
  return (ctx->Line.StippleFlag);
  case 3057: 
#line 14976
  return (ctx->Color.IndexLogicOpEnabled);
  case 3058: 
#line 14978
  return (ctx->Color.ColorLogicOpEnabled);
  case 3472: 
#line 14980
  return (ctx->Eval.Map1Color4);
  case 3473: 
#line 14982
  return (ctx->Eval.Map1Index);
  case 3474: 
#line 14984
  return (ctx->Eval.Map1Normal);
  case 3475: 
#line 14986
  return (ctx->Eval.Map1TextureCoord1);
  case 3476: 
#line 14988
  return (ctx->Eval.Map1TextureCoord2);
  case 3477: 
#line 14990
  return (ctx->Eval.Map1TextureCoord3);
  case 3478: 
#line 14992
  return (ctx->Eval.Map1TextureCoord4);
  case 3479: 
#line 14994
  return (ctx->Eval.Map1Vertex3);
  case 3480: 
#line 14996
  return (ctx->Eval.Map1Vertex4);
  case 3504: 
#line 14998
  return (ctx->Eval.Map2Color4);
  case 3505: 
#line 15000
  return (ctx->Eval.Map2Index);
  case 3506: 
#line 15002
  return (ctx->Eval.Map2Normal);
  case 3507: 
#line 15004
  return (ctx->Eval.Map2TextureCoord1);
  case 3508: 
#line 15006
  return (ctx->Eval.Map2TextureCoord2);
  case 3509: 
#line 15008
  return (ctx->Eval.Map2TextureCoord3);
  case 3510: 
#line 15010
  return (ctx->Eval.Map2TextureCoord4);
  case 3511: 
#line 15012
  return (ctx->Eval.Map2Vertex3);
  case 3512: 
#line 15014
  return (ctx->Eval.Map2Vertex4);
  case 2977: 
#line 15016
  return (ctx->Transform.Normalize);
  case 2832: 
#line 15018
  return (ctx->Point.SmoothFlag);
  case 2881: 
#line 15020
  return (ctx->Polygon.SmoothFlag);
  case 2882: 
#line 15022
  return (ctx->Polygon.StippleFlag);
  case 10753: 
#line 15024
  return (ctx->Polygon.OffsetPoint);
  case 10754: 
#line 15026
  return (ctx->Polygon.OffsetLine);
  case 32823: 
#line 15028
  return (ctx->Polygon.OffsetFill);
  case 3089: 
#line 15030
  return (ctx->Scissor.Enabled);
  case 33275: 
#line 15032
  return (ctx->Texture.SharedPalette);
#line 15033
  break;
  case 2960: 
#line 15035
  return (ctx->Stencil.Enabled);
  case 3552: 
#line 15037
  if (ctx->Texture.Enabled & 1U) {
#line 15037
    tmp___0 = 1;
  } else {
#line 15037
    tmp___0 = 0;
  }
#line 15037
  return ((unsigned char )tmp___0);
  case 3553: 
#line 15039
  if (ctx->Texture.Enabled & 2U) {
#line 15039
    tmp___1 = 1;
  } else {
#line 15039
    tmp___1 = 0;
  }
#line 15039
  return ((unsigned char )tmp___1);
  case 32879: 
#line 15041
  if (ctx->Texture.Enabled & 4U) {
#line 15041
    tmp___2 = 1;
  } else {
#line 15041
    tmp___2 = 0;
  }
#line 15041
  return ((unsigned char )tmp___2);
  case 3171: 
#line 15043
  if (ctx->Texture.TexGenEnabled & 1U) {
#line 15043
    tmp___3 = 1;
  } else {
#line 15043
    tmp___3 = 0;
  }
#line 15043
  return ((unsigned char )tmp___3);
  case 3170: 
#line 15045
  if (ctx->Texture.TexGenEnabled & 2U) {
#line 15045
    tmp___4 = 1;
  } else {
#line 15045
    tmp___4 = 0;
  }
#line 15045
  return ((unsigned char )tmp___4);
  case 3168: 
#line 15047
  if (ctx->Texture.TexGenEnabled & 4U) {
#line 15047
    tmp___5 = 1;
  } else {
#line 15047
    tmp___5 = 0;
  }
#line 15047
  return ((unsigned char )tmp___5);
  case 3169: 
#line 15049
  if (ctx->Texture.TexGenEnabled & 8U) {
#line 15049
    tmp___6 = 1;
  } else {
#line 15049
    tmp___6 = 0;
  }
#line 15049
  return ((unsigned char )tmp___6);
  case 32884: 
#line 15051
  return (ctx->Array.VertexEnabled);
  case 32885: 
#line 15053
  return (ctx->Array.NormalEnabled);
  case 32886: 
#line 15055
  return (ctx->Array.ColorEnabled);
  case 32887: 
#line 15057
  return (ctx->Array.IndexEnabled);
  case 32888: 
#line 15059
  return (ctx->Array.TexCoordEnabled);
  case 32889: 
#line 15061
  return (ctx->Array.EdgeFlagEnabled);
  default: 
#line 15063
  gl_error(ctx, 1280, "glIsEnabled");
#line 15064
  return ((unsigned char)0);
  }
#line 15066
  return ((unsigned char)0);
}
}
#line 15067 "D:/a/test/177.c"
void gl_client_state(GLcontext *ctx , GLenum cap , GLboolean state ) 
{ 

  {
#line 15069
  switch (cap) {
  case 32884: 
#line 15071
  ctx->Array.VertexEnabled = state;
#line 15072
  break;
  case 32885: 
#line 15074
  ctx->Array.NormalEnabled = state;
#line 15075
  break;
  case 32886: 
#line 15077
  ctx->Array.ColorEnabled = state;
#line 15078
  break;
  case 32887: 
#line 15080
  ctx->Array.IndexEnabled = state;
#line 15081
  break;
  case 32888: 
#line 15083
  ctx->Array.TexCoordEnabled = state;
#line 15084
  break;
  case 32889: 
#line 15086
  ctx->Array.EdgeFlagEnabled = state;
#line 15087
  break;
  default: 
#line 15089
  gl_error(ctx, 1280, "glEnable/DisableClientState");
  }
#line 15091
  return;
}
}
#line 15092 "D:/a/test/177.c"
void gl_EnableClientState(GLcontext *ctx , GLenum cap ) 
{ 

  {
#line 15094
  gl_client_state(ctx, cap, (unsigned char)1);
#line 15095
  return;
}
}
#line 15096 "D:/a/test/177.c"
void gl_DisableClientState(GLcontext *ctx , GLenum cap ) 
{ 

  {
#line 15098
  gl_client_state(ctx, cap, (unsigned char)0);
#line 15099
  return;
}
}
#line 15107
void gl_init_eval(void) ;
#line 15107 "D:/a/test/177.c"
static int init_flag___0  =    0;
#line 15105 "D:/a/test/177.c"
void gl_init_eval(void) 
{ 

  {
#line 15108
  if (init_flag___0 == 0) {

  }
#line 15111
  init_flag___0 = 1;
#line 15112
  return;
}
}
#line 15113 "D:/a/test/177.c"
static void horner_bezier_curve(float *cp , float *out , float t , GLuint dim , GLuint order ) 
{ float s ;
  float powert ;
  GLuint i ;
  GLuint k ;
  GLuint bincoeff ;

  {
#line 15119
  if (order >= 2U) {
#line 15121
    bincoeff = order - 1U;
#line 15122
    s = (float )(1.0 - (double )t);
#line 15123
    k = 0U;
#line 15123
    while (k < dim) {
#line 15124
      *(out + k) = s * *(cp + k) + ((float )bincoeff * t) * *(cp + (dim + k));
#line 15123
      k ++;
    }
#line 15125
    i = 2U;
#line 15125
    cp += 2U * dim;
#line 15125
    powert = t * t;
#line 15125
    while (i < order) {
#line 15127
      bincoeff *= order - i;
#line 15128
      bincoeff /= i;
#line 15129
      k = 0U;
#line 15129
      while (k < dim) {
#line 15130
        *(out + k) = s * *(out + k) + ((float )bincoeff * powert) * *(cp + k);
#line 15129
        k ++;
      }
#line 15125
      i ++;
#line 15125
      powert *= t;
#line 15125
      cp += dim;
    }
  } else {
#line 15135
    k = 0U;
#line 15135
    while (k < dim) {
#line 15136
      *(out + k) = *(cp + k);
#line 15135
      k ++;
    }
  }
#line 15138
  return;
}
}
#line 15139 "D:/a/test/177.c"
static void horner_bezier_surf(float *cn , float *out , float u , float v , GLuint dim ,
                               GLuint uorder , GLuint vorder ) 
{ float *cp ;
  GLuint i ;
  GLuint uinc ;
  float s ;
  float poweru ;
  GLuint j ;
  GLuint k ;
  GLuint bincoeff ;
  float *ucp ;
  GLuint i___0 ;

  {
#line 15143
  cp = cn + (uorder * vorder) * dim;
#line 15144
  uinc = vorder * dim;
#line 15145
  if (vorder > uorder) {
#line 15147
    if (uorder >= 2U) {
#line 15151
      j = 0U;
#line 15151
      while (j < vorder) {
#line 15153
        ucp = cn + j * dim;
#line 15154
        bincoeff = uorder - 1U;
#line 15155
        s = (float )(1.0 - (double )u);
#line 15156
        k = 0U;
#line 15156
        while (k < dim) {
#line 15157
          *(cp + (j * dim + k)) = s * *(ucp + k) + ((float )bincoeff * u) * *(ucp + (uinc + k));
#line 15156
          k ++;
        }
#line 15158
        i = 2U;
#line 15158
        ucp += 2U * uinc;
#line 15158
        poweru = u * u;
#line 15158
        while (i < uorder) {
#line 15161
          bincoeff *= uorder - i;
#line 15162
          bincoeff /= i;
#line 15163
          k = 0U;
#line 15163
          while (k < dim) {
#line 15164
            *(cp + (j * dim + k)) = s * *(cp + (j * dim + k)) + ((float )bincoeff * poweru) * *(ucp + k);
#line 15163
            k ++;
          }
#line 15158
          i ++;
#line 15158
          poweru *= u;
#line 15158
          ucp += uinc;
        }
#line 15151
        j ++;
      }
#line 15167
      horner_bezier_curve(cp, out, v, dim, vorder);
    } else {
#line 15170
      horner_bezier_curve(cn, out, v, dim, vorder);
    }
  } else {
#line 15174
    if (vorder > 1U) {
#line 15177
      i___0 = 0U;
#line 15177
      while (i___0 < uorder) {
#line 15182
        horner_bezier_curve(cn, cp + i___0 * dim, v, dim, vorder);
#line 15177
        i___0 ++;
#line 15177
        cn += uinc;
      }
#line 15184
      horner_bezier_curve(cp, out, u, dim, uorder);
    } else {
#line 15187
      horner_bezier_curve(cn, out, u, dim, uorder);
    }
  }
#line 15189
  return;
}
}
#line 15190 "D:/a/test/177.c"
static void de_casteljau_surf(float *cn , float *out , float *du , float *dv , float u ,
                              float v , GLuint dim , GLuint uorder , GLuint vorder ) 
{ float *dcn ;
  float us ;
  float vs ;
  GLuint h ;
  GLuint i ;
  GLuint j ;
  GLuint k ;
  GLuint minorder ;
  GLuint tmp___0 ;
  GLuint uinc ;
  GLuint dcuinc ;

  {
#line 15195
  dcn = cn + (uorder * vorder) * dim;
#line 15196
  us = (float )(1.0 - (double )u);
#line 15196
  vs = (float )(1.0 - (double )v);
#line 15198
  if (uorder < vorder) {
#line 15198
    tmp___0 = uorder;
  } else {
#line 15198
    tmp___0 = vorder;
  }
#line 15198
  minorder = tmp___0;
#line 15199
  uinc = vorder * dim;
#line 15200
  dcuinc = vorder;
#line 15203
  if (minorder < 3U) {
#line 15205
    if (uorder == vorder) {
#line 15207
      k = 0U;
#line 15207
      while (k < dim) {
#line 15210
        *(du + k) = vs * (*(cn + (uinc + k)) - *(cn + k)) + v * (*(cn + ((uinc + dim) + k)) - *(cn + (dim + k)));
#line 15213
        *(dv + k) = us * (*(cn + (dim + k)) - *(cn + k)) + u * (*(cn + ((uinc + dim) + k)) - *(cn + (uinc + k)));
#line 15216
        *(out + k) = us * (vs * *(cn + k) + v * *(cn + (dim + k))) + u * (vs * *(cn + (uinc + k)) + v * *(cn + ((uinc + dim) + k)));
#line 15207
        k ++;
      }
    } else {
#line 15220
      if (minorder == uorder) {
#line 15222
        k = 0U;
#line 15222
        while (k < dim) {
#line 15225
          *(dcn + dcuinc) = *(cn + (uinc + k)) - *(cn + k);
#line 15226
          *(dcn + 0U) = us * *(cn + k) + u * *(cn + (uinc + k));
#line 15227
          j = 0U;
#line 15227
          while (j < vorder - 1U) {
#line 15230
            *(dcn + (dcuinc + (j + 1U))) = *(cn + ((uinc + (j + 1U) * dim) + k)) - *(cn + ((j + 1U) * dim + k));
#line 15231
            *(dcn + (dcuinc + j)) = vs * *(dcn + (dcuinc + j)) + v * *(dcn + (dcuinc + (j + 1U)));
#line 15233
            *(dcn + (j + 1U)) = us * *(cn + ((j + 1U) * dim + k)) + u * *(cn + ((uinc + (j + 1U) * dim) + k));
#line 15234
            *(dcn + j) = vs * *(dcn + j) + v * *(dcn + (j + 1U));
#line 15227
            j ++;
          }
#line 15237
          h = minorder;
#line 15237
          while (h < vorder - 1U) {
#line 15238
            j = 0U;
#line 15238
            while (j < vorder - h) {
#line 15241
              *(dcn + (dcuinc + j)) = vs * *(dcn + (dcuinc + j)) + v * *(dcn + (dcuinc + (j + 1U)));
#line 15243
              *(dcn + j) = vs * *(dcn + j) + v * *(dcn + (j + 1U));
#line 15238
              j ++;
            }
#line 15237
            h ++;
          }
#line 15246
          *(dv + k) = *(dcn + 1U) - *(dcn + 0U);
#line 15248
          *(du + k) = vs * *(dcn + dcuinc) + v * *(dcn + (dcuinc + 1U));
#line 15250
          *(out + k) = vs * *(dcn + 0U) + v * *(dcn + 1U);
#line 15222
          k ++;
        }
      } else {
#line 15255
        k = 0U;
#line 15255
        while (k < dim) {
#line 15258
          *(dcn + 1U) = *(cn + (dim + k)) - *(cn + k);
#line 15259
          *(dcn + 0U) = vs * *(cn + k) + v * *(cn + (dim + k));
#line 15260
          i = 0U;
#line 15260
          while (i < uorder - 1U) {
#line 15263
            *(dcn + ((i + 1U) * dcuinc + 1U)) = *(cn + (((i + 1U) * uinc + dim) + k)) - *(cn + ((i + 1U) * uinc + k));
#line 15264
            *(dcn + (i * dcuinc + 1U)) = us * *(dcn + (i * dcuinc + 1U)) + u * *(dcn + ((i + 1U) * dcuinc + 1U));
#line 15266
            *(dcn + (i + 1U) * dcuinc) = vs * *(cn + ((i + 1U) * uinc + k)) + v * *(cn + (((i + 1U) * uinc + dim) + k));
#line 15267
            *(dcn + i * dcuinc) = us * *(dcn + i * dcuinc) + u * *(dcn + (i + 1U) * dcuinc);
#line 15260
            i ++;
          }
#line 15270
          h = minorder;
#line 15270
          while (h < uorder - 1U) {
#line 15271
            i = 0U;
#line 15271
            while (i < uorder - h) {
#line 15274
              *(dcn + (i * dcuinc + 1U)) = us * *(dcn + (i * dcuinc + 1U)) + u * *(dcn + ((i + 1U) * dcuinc + 1U));
#line 15276
              *(dcn + i * dcuinc) = us * *(dcn + i * dcuinc) + u * *(dcn + (i + 1U) * dcuinc);
#line 15271
              i ++;
            }
#line 15270
            h ++;
          }
#line 15279
          *(du + k) = *(dcn + dcuinc) - *(dcn + 0U);
#line 15281
          *(dv + k) = us * *(dcn + 1U) + u * *(dcn + (dcuinc + 1U));
#line 15283
          *(out + k) = us * *(dcn + 0U) + u * *(dcn + dcuinc);
#line 15255
          k ++;
        }
      }
    }
  } else {
#line 15287
    if (uorder == vorder) {
#line 15289
      k = 0U;
#line 15289
      while (k < dim) {
#line 15291
        i = 0U;
#line 15291
        while (i < uorder - 1U) {
#line 15293
          *(dcn + i * dcuinc) = us * *(cn + (i * uinc + k)) + u * *(cn + ((i + 1U) * uinc + k));
#line 15294
          j = 0U;
#line 15294
          while (j < vorder - 1U) {
#line 15296
            *(dcn + (i * dcuinc + (j + 1U))) = us * *(cn + ((i * uinc + (j + 1U) * dim) + k)) + u * *(cn + (((i + 1U) * uinc + (j + 1U) * dim) + k));
#line 15297
            *(dcn + (i * dcuinc + j)) = vs * *(dcn + (i * dcuinc + j)) + v * *(dcn + (i * dcuinc + (j + 1U)));
#line 15294
            j ++;
          }
#line 15291
          i ++;
        }
#line 15300
        h = 2U;
#line 15300
        while (h < minorder - 1U) {
#line 15301
          i = 0U;
#line 15301
          while (i < uorder - h) {
#line 15303
            *(dcn + i * dcuinc) = us * *(dcn + i * dcuinc) + u * *(dcn + (i + 1U) * dcuinc);
#line 15304
            j = 0U;
#line 15304
            while (j < vorder - h) {
#line 15306
              *(dcn + (i * dcuinc + (j + 1U))) = us * *(dcn + (i * dcuinc + (j + 1U))) + u * *(dcn + ((i + 1U) * dcuinc + (j + 1U)));
#line 15307
              *(dcn + (i * dcuinc + j)) = vs * *(dcn + (i * dcuinc + j)) + v * *(dcn + (i * dcuinc + (j + 1U)));
#line 15304
              j ++;
            }
#line 15301
            i ++;
          }
#line 15300
          h ++;
        }
#line 15310
        *(du + k) = vs * (*(dcn + dcuinc) - *(dcn + 0U)) + v * (*(dcn + (dcuinc + 1U)) - *(dcn + 1U));
#line 15312
        *(dv + k) = us * (*(dcn + 1U) - *(dcn + 0U)) + u * (*(dcn + (dcuinc + 1U)) - *(dcn + dcuinc));
#line 15314
        *(out + k) = us * (vs * *(dcn + 0U) + v * *(dcn + 1U)) + u * (vs * *(dcn + dcuinc) + v * *(dcn + (dcuinc + 1U)));
#line 15289
        k ++;
      }
    } else {
#line 15318
      if (minorder == uorder) {
#line 15320
        k = 0U;
#line 15320
        while (k < dim) {
#line 15322
          i = 0U;
#line 15322
          while (i < uorder - 1U) {
#line 15324
            *(dcn + i * dcuinc) = us * *(cn + (i * uinc + k)) + u * *(cn + ((i + 1U) * uinc + k));
#line 15325
            j = 0U;
#line 15325
            while (j < vorder - 1U) {
#line 15327
              *(dcn + (i * dcuinc + (j + 1U))) = us * *(cn + ((i * uinc + (j + 1U) * dim) + k)) + u * *(cn + (((i + 1U) * uinc + (j + 1U) * dim) + k));
#line 15328
              *(dcn + (i * dcuinc + j)) = vs * *(dcn + (i * dcuinc + j)) + v * *(dcn + (i * dcuinc + (j + 1U)));
#line 15325
              j ++;
            }
#line 15322
            i ++;
          }
#line 15331
          h = 2U;
#line 15331
          while (h < minorder - 1U) {
#line 15332
            i = 0U;
#line 15332
            while (i < uorder - h) {
#line 15334
              *(dcn + i * dcuinc) = us * *(dcn + i * dcuinc) + u * *(dcn + (i + 1U) * dcuinc);
#line 15335
              j = 0U;
#line 15335
              while (j < vorder - h) {
#line 15337
                *(dcn + (i * dcuinc + (j + 1U))) = us * *(dcn + (i * dcuinc + (j + 1U))) + u * *(dcn + ((i + 1U) * dcuinc + (j + 1U)));
#line 15338
                *(dcn + (i * dcuinc + j)) = vs * *(dcn + (i * dcuinc + j)) + v * *(dcn + (i * dcuinc + (j + 1U)));
#line 15335
                j ++;
              }
#line 15332
              i ++;
            }
#line 15331
            h ++;
          }
#line 15341
          *(dcn + 2U * dcuinc) = *(dcn + dcuinc) - *(dcn + 0U);
#line 15342
          *(dcn + 0U) = us * *(dcn + 0U) + u * *(dcn + dcuinc);
#line 15343
          j = 0U;
#line 15343
          while (j < vorder - 1U) {
#line 15346
            *(dcn + (2U * dcuinc + (j + 1U))) = *(dcn + (dcuinc + (j + 1U))) - *(dcn + (j + 1U));
#line 15347
            *(dcn + (2U * dcuinc + j)) = vs * *(dcn + (2U * dcuinc + j)) + v * *(dcn + (2U * dcuinc + (j + 1U)));
#line 15350
            *(dcn + (j + 1U)) = us * *(dcn + (j + 1U)) + u * *(dcn + (dcuinc + (j + 1U)));
#line 15351
            *(dcn + j) = vs * *(dcn + j) + v * *(dcn + (j + 1U));
#line 15343
            j ++;
          }
#line 15353
          h = minorder;
#line 15353
          while (h < vorder - 1U) {
#line 15354
            j = 0U;
#line 15354
            while (j < vorder - h) {
#line 15357
              *(dcn + (2U * dcuinc + j)) = vs * *(dcn + (2U * dcuinc + j)) + v * *(dcn + (2U * dcuinc + (j + 1U)));
#line 15360
              *(dcn + j) = vs * *(dcn + j) + v * *(dcn + (j + 1U));
#line 15354
              j ++;
            }
#line 15353
            h ++;
          }
#line 15362
          *(dv + k) = *(dcn + 1U) - *(dcn + 0U);
#line 15363
          *(du + k) = vs * *(dcn + 2U * dcuinc) + v * *(dcn + (2U * dcuinc + 1U));
#line 15364
          *(out + k) = vs * *(dcn + 0U) + v * *(dcn + 1U);
#line 15320
          k ++;
        }
      } else {
#line 15369
        k = 0U;
#line 15369
        while (k < dim) {
#line 15371
          i = 0U;
#line 15371
          while (i < uorder - 1U) {
#line 15373
            *(dcn + i * dcuinc) = us * *(cn + (i * uinc + k)) + u * *(cn + ((i + 1U) * uinc + k));
#line 15374
            j = 0U;
#line 15374
            while (j < vorder - 1U) {
#line 15376
              *(dcn + (i * dcuinc + (j + 1U))) = us * *(cn + ((i * uinc + (j + 1U) * dim) + k)) + u * *(cn + (((i + 1U) * uinc + (j + 1U) * dim) + k));
#line 15377
              *(dcn + (i * dcuinc + j)) = vs * *(dcn + (i * dcuinc + j)) + v * *(dcn + (i * dcuinc + (j + 1U)));
#line 15374
              j ++;
            }
#line 15371
            i ++;
          }
#line 15380
          h = 2U;
#line 15380
          while (h < minorder - 1U) {
#line 15381
            i = 0U;
#line 15381
            while (i < uorder - h) {
#line 15383
              *(dcn + i * dcuinc) = us * *(dcn + i * dcuinc) + u * *(dcn + (i + 1U) * dcuinc);
#line 15384
              j = 0U;
#line 15384
              while (j < vorder - h) {
#line 15386
                *(dcn + (i * dcuinc + (j + 1U))) = us * *(dcn + (i * dcuinc + (j + 1U))) + u * *(dcn + ((i + 1U) * dcuinc + (j + 1U)));
#line 15387
                *(dcn + (i * dcuinc + j)) = vs * *(dcn + (i * dcuinc + j)) + v * *(dcn + (i * dcuinc + (j + 1U)));
#line 15384
                j ++;
              }
#line 15381
              i ++;
            }
#line 15380
            h ++;
          }
#line 15390
          *(dcn + 2U) = *(dcn + 1U) - *(dcn + 0U);
#line 15391
          *(dcn + 0U) = vs * *(dcn + 0U) + v * *(dcn + 1U);
#line 15392
          i = 0U;
#line 15392
          while (i < uorder - 1U) {
#line 15395
            *(dcn + ((i + 1U) * dcuinc + 2U)) = *(dcn + ((i + 1U) * dcuinc + 1U)) - *(dcn + (i + 1U) * dcuinc);
#line 15396
            *(dcn + (i * dcuinc + 2U)) = us * *(dcn + (i * dcuinc + 2U)) + u * *(dcn + ((i + 1U) * dcuinc + 2U));
#line 15399
            *(dcn + (i + 1U) * dcuinc) = vs * *(dcn + (i + 1U) * dcuinc) + v * *(dcn + ((i + 1U) * dcuinc + 1U));
#line 15400
            *(dcn + i * dcuinc) = us * *(dcn + i * dcuinc) + u * *(dcn + (i + 1U) * dcuinc);
#line 15392
            i ++;
          }
#line 15402
          h = minorder;
#line 15402
          while (h < uorder - 1U) {
#line 15403
            i = 0U;
#line 15403
            while (i < uorder - h) {
#line 15406
              *(dcn + (i * dcuinc + 2U)) = us * *(dcn + (i * dcuinc + 2U)) + u * *(dcn + ((i + 1U) * dcuinc + 2U));
#line 15409
              *(dcn + i * dcuinc) = us * *(dcn + i * dcuinc) + u * *(dcn + (i + 1U) * dcuinc);
#line 15403
              i ++;
            }
#line 15402
            h ++;
          }
#line 15411
          *(du + k) = *(dcn + dcuinc) - *(dcn + 0U);
#line 15412
          *(dv + k) = us * *(dcn + 2U) + u * *(dcn + (dcuinc + 2U));
#line 15413
          *(out + k) = us * *(dcn + 0U) + u * *(dcn + dcuinc);
#line 15369
          k ++;
        }
      }
    }
  }
#line 15418
  return;
}
}
#line 15419 "D:/a/test/177.c"
static GLint components(GLenum target ) 
{ 

  {
#line 15421
  switch (target) {
  case 3479: 
#line 15422
  return (3);
  case 3480: 
#line 15423
  return (4);
  case 3473: 
#line 15424
  return (1);
  case 3472: 
#line 15425
  return (4);
  case 3474: 
#line 15426
  return (3);
  case 3475: 
#line 15427
  return (1);
  case 3476: 
#line 15428
  return (2);
  case 3477: 
#line 15429
  return (3);
  case 3478: 
#line 15430
  return (4);
  case 3511: 
#line 15431
  return (3);
  case 3512: 
#line 15432
  return (4);
  case 3505: 
#line 15433
  return (1);
  case 3504: 
#line 15434
  return (4);
  case 3506: 
#line 15435
  return (3);
  case 3507: 
#line 15436
  return (1);
  case 3508: 
#line 15437
  return (2);
  case 3509: 
#line 15438
  return (3);
  case 3510: 
#line 15439
  return (4);
  default: ;
#line 15440
  return (0);
  }
}
}
#line 15443 "D:/a/test/177.c"
float *gl_copy_map_points1f(GLenum target , GLint ustride , GLint uorder , float const   *points ) 
{ float *buffer ;
  float *p ;
  GLuint i ;
  GLuint k ;
  GLuint size ;
  GLint tmp___0 ;
  void *tmp___1 ;
  float *tmp___2 ;

  {
#line 15448
  tmp___0 = components(target);
#line 15448
  size = (GLuint )tmp___0;
#line 15449
  if (! points) {
#line 15450
    return ((float *)((void *)0));
  } else {
#line 15449
    if ((unsigned int )(& components) == (unsigned int )((GLint (*)(GLenum target ))0)) {
#line 15450
      return ((float *)((void *)0));
    }
  }
#line 15452
  tmp___1 = malloc(((GLuint )uorder * size) * sizeof(float ));//28
#line 15452
  buffer = (float *)tmp___1;
#line 15453
  if (buffer) {
#line 15454
    i = 0U;
#line 15454
    p = buffer;
#line 15454
    while (i < (GLuint )uorder) {
#line 15455
      k = 0U;
#line 15455
      while (k < size) {
#line 15456
        tmp___2 = p;
#line 15456
        p ++;
#line 15456
        *tmp___2 = (float )*(points + k);
#line 15455
        k ++;
      }
#line 15454
      i ++;
#line 15454
      points += ustride;
    }
  }
#line 15457
  return (buffer);
}
}
#line 15459 "D:/a/test/177.c"
float *gl_copy_map_points1d(GLenum target , GLint ustride , GLint uorder , GLdouble const   *points ) 
{ float *buffer ;
  float *p ;
  GLuint i ;
  GLuint k ;
  GLuint size ;
  GLint tmp___0 ;
  void *tmp___1 ;
  float *tmp___2 ;

  {
#line 15464
  tmp___0 = components(target);
#line 15464
  size = (GLuint )tmp___0;
#line 15465
  tmp___1 = malloc(((GLuint )uorder * size) * sizeof(float ));//29
#line 15465
  buffer = (float *)tmp___1;
#line 15466
  if (buffer) {
#line 15467
    i = 0U;
#line 15467
    p = buffer;
#line 15467
    while (i < (GLuint )uorder) {
#line 15468
      k = 0U;
#line 15468
      while (k < size) {
#line 15469
        tmp___2 = p;
#line 15469
        p ++;
#line 15469
        *tmp___2 = (float )*(points + k);
#line 15468
        k ++;
      }
#line 15467
      i ++;
#line 15467
      points += ustride;
    }
  }
#line 15470
  return (buffer);
}
}
#line 15472 "D:/a/test/177.c"
float *gl_copy_map_points2f(GLenum target , GLint ustride , GLint uorder , GLint vstride ,
                            GLint vorder , float const   *points ) 
{ float *buffer ;
  float *p ;
  GLuint i ;
  GLuint j ;
  GLuint k ;
  GLuint size ;
  GLuint dsize ;
  GLuint hsize ;
  GLint uinc ;
  GLint tmp___0 ;
  GLint tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  float *tmp___4 ;

  {
#line 15480
  tmp___0 = components(target);
#line 15480
  size = (unsigned int )tmp___0;
#line 15481
  if (uorder == 2) {
#line 15481
    if (vorder == 2) {
#line 15481
      dsize = 0U;
    } else {
#line 15481
      dsize = (unsigned int )(uorder * vorder);
    }
  } else {
#line 15481
    dsize = (unsigned int )(uorder * vorder);
  }
#line 15482
  if (uorder > vorder) {
#line 15482
    tmp___1 = uorder;
  } else {
#line 15482
    tmp___1 = vorder;
  }
#line 15482
  hsize = (GLuint )tmp___1 * size;
#line 15483
  if (hsize > dsize) {
#line 15484
    tmp___2 = malloc(((GLuint )(uorder * vorder) * size + hsize) * sizeof(float ));//30
#line 15484
    buffer = (float *)tmp___2;
  } else {
#line 15486
    tmp___3 = malloc(((GLuint )(uorder * vorder) * size + dsize) * sizeof(float ));//31
#line 15486
    buffer = (float *)tmp___3;
  }
#line 15487
  uinc = ustride - vorder * vstride;
#line 15488
  if (buffer) {
#line 15489
    i = 0U;
#line 15489
    p = buffer;
#line 15489
    while (i < (GLuint )uorder) {
#line 15490
      j = 0U;
#line 15490
      while (j < (GLuint )vorder) {
#line 15491
        k = 0U;
#line 15491
        while (k < size) {
#line 15492
          tmp___4 = p;
#line 15492
          p ++;
#line 15492
          *tmp___4 = (float )*(points + k);
#line 15491
          k ++;
        }
#line 15490
        j ++;
#line 15490
        points += vstride;
      }
#line 15489
      i ++;
#line 15489
      points += uinc;
    }
  }
#line 15493
  return (buffer);
}
}
#line 15495 "D:/a/test/177.c"
float *gl_copy_map_points2d(GLenum target , GLint ustride , GLint uorder , GLint vstride ,
                            GLint vorder , GLdouble const   *points ) 
{ float *buffer ;
  float *p ;
  GLuint i ;
  GLuint j ;
  GLuint k ;
  GLuint size ;
  GLuint hsize ;
  GLuint dsize ;
  GLint uinc ;
  GLint tmp___0 ;
  GLint tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  float *tmp___4 ;

  {
#line 15503
  tmp___0 = components(target);
#line 15503
  size = (unsigned int )tmp___0;
#line 15504
  if (uorder == 2) {
#line 15504
    if (vorder == 2) {
#line 15504
      dsize = 0U;
    } else {
#line 15504
      dsize = (unsigned int )(uorder * vorder);
    }
  } else {
#line 15504
    dsize = (unsigned int )(uorder * vorder);
  }
#line 15505
  if (uorder > vorder) {
#line 15505
    tmp___1 = uorder;
  } else {
#line 15505
    tmp___1 = vorder;
  }
#line 15505
  hsize = (GLuint )tmp___1 * size;
#line 15506
  if (hsize > dsize) {
#line 15507
    tmp___2 = malloc(((GLuint )(uorder * vorder) * size + hsize) * sizeof(float ));//32
#line 15507
    buffer = (float *)tmp___2;
  } else {
#line 15509
    tmp___3 = malloc(((GLuint )(uorder * vorder) * size + dsize) * sizeof(float ));//33
#line 15509
    buffer = (float *)tmp___3;
  }
#line 15510
  uinc = ustride - vorder * vstride;
#line 15511
  if (buffer) {
#line 15512
    i = 0U;
#line 15512
    p = buffer;
#line 15512
    while (i < (GLuint )uorder) {
#line 15513
      j = 0U;
#line 15513
      while (j < (GLuint )vorder) {
#line 15514
        k = 0U;
#line 15514
        while (k < size) {
#line 15515
          tmp___4 = p;
#line 15515
          p ++;
#line 15515
          *tmp___4 = (float )*(points + k);
#line 15514
          k ++;
        }
#line 15513
        j ++;
#line 15513
        points += vstride;
      }
#line 15512
      i ++;
#line 15512
      points += uinc;
    }
  }
#line 15516
  return (buffer);
}
}
#line 15518 "D:/a/test/177.c"
void gl_free_control_points(GLcontext *ctx , GLenum target , float *data ) 
{ struct gl_1d_map *map1 ;
  struct gl_2d_map *map2 ;

  {
#line 15520
  map1 = (struct gl_1d_map *)((void *)0);
#line 15521
  map2 = (struct gl_2d_map *)((void *)0);
#line 15522
  switch (target) {
  case 3479: 
#line 15524
  map1 = & ctx->EvalMap.Map1Vertex3;
#line 15525
  break;
  case 3480: 
#line 15527
  map1 = & ctx->EvalMap.Map1Vertex4;
#line 15528
  break;
  case 3473: 
#line 15530
  map1 = & ctx->EvalMap.Map1Index;
#line 15531
  break;
  case 3472: 
#line 15533
  map1 = & ctx->EvalMap.Map1Color4;
#line 15534
  break;
  case 3474: 
#line 15536
  map1 = & ctx->EvalMap.Map1Normal;
#line 15537
  break;
  case 3475: 
#line 15539
  map1 = & ctx->EvalMap.Map1Texture1;
#line 15540
  break;
  case 3476: 
#line 15542
  map1 = & ctx->EvalMap.Map1Texture2;
#line 15543
  break;
  case 3477: 
#line 15545
  map1 = & ctx->EvalMap.Map1Texture3;
#line 15546
  break;
  case 3478: 
#line 15548
  map1 = & ctx->EvalMap.Map1Texture4;
#line 15549
  break;
  case 3511: 
#line 15551
  map2 = & ctx->EvalMap.Map2Vertex3;
#line 15552
  break;
  case 3512: 
#line 15554
  map2 = & ctx->EvalMap.Map2Vertex4;
#line 15555
  break;
  case 3505: 
#line 15557
  map2 = & ctx->EvalMap.Map2Index;
#line 15558
  break;
  case 3504: 
#line 15560
  map2 = & ctx->EvalMap.Map2Color4;
#line 15561
  break;
  case 3506: 
#line 15563
  map2 = & ctx->EvalMap.Map2Normal;
#line 15564
  break;
  case 3507: 
#line 15566
  map2 = & ctx->EvalMap.Map2Texture1;
#line 15567
  break;
  case 3508: 
#line 15569
  map2 = & ctx->EvalMap.Map2Texture2;
#line 15570
  break;
  case 3509: 
#line 15572
  map2 = & ctx->EvalMap.Map2Texture3;
#line 15573
  break;
  case 3510: 
#line 15575
  map2 = & ctx->EvalMap.Map2Texture4;
#line 15576
  break;
  default: 
#line 15578
  gl_error(ctx, 1280, "gl_free_control_points");
#line 15579
  return;
  }
#line 15581
  if (map1) {
#line 15582
    if ((unsigned int )data == (unsigned int )map1->Points) {
#line 15583
      map1->Retain = (unsigned char)0;
    } else {
#line 15586
      free((void *)data);
    }
  }
#line 15589
  if (map2) {
#line 15590
    if ((unsigned int )data == (unsigned int )map2->Points) {
#line 15591
      map2->Retain = (unsigned char)0;
    } else {
#line 15594
      free((void *)data);
    }
  }
#line 15597
  return;
}
}
#line 15598 "D:/a/test/177.c"
void gl_Map1f(GLcontext *ctx , GLenum target , float u1 , float u2 , GLint stride ,
              GLint order , float const   *points , GLboolean retain ) 
{ GLuint k ;
  GLint tmp___0 ;

  {
#line 15603
  if (! points) {
#line 15604
    gl_error(ctx, 1285, "glMap1f");
#line 15605
    return;
  }
#line 15607
  stride = components(target);
#line 15608
  if (ctx->Primitive != 6656) {
#line 15609
    gl_error(ctx, 1282, "glMap1");
#line 15610
    return;
  }
#line 15612
  if (u1 == u2) {
#line 15613
    gl_error(ctx, 1281, "glMap1(u1,u2)");
#line 15614
    return;
  }
#line 15616
  if (order < 1) {
#line 15617
    gl_error(ctx, 1281, "glMap1(order)");
#line 15618
    return;
  } else {
#line 15616
    if (order > 30) {
#line 15617
      gl_error(ctx, 1281, "glMap1(order)");
#line 15618
      return;
    }
  }
#line 15620
  tmp___0 = components(target);
#line 15620
  k = (unsigned int )tmp___0;
#line 15621
  if (k == 0U) {
#line 15622
    gl_error(ctx, 1280, "glMap1(target)");
  }
#line 15624
  if ((GLuint )stride < k) {
#line 15625
    gl_error(ctx, 1281, "glMap1(stride)");
#line 15626
    return;
  }
#line 15628
  switch (target) {
  case 3479: 
#line 15630
  ctx->EvalMap.Map1Vertex3.Order = (unsigned int )order;
#line 15631
  ctx->EvalMap.Map1Vertex3.u1 = u1;
#line 15632
  ctx->EvalMap.Map1Vertex3.u2 = u2;
#line 15633
  if (ctx->EvalMap.Map1Vertex3.Points) {
#line 15633
    if (! ctx->EvalMap.Map1Vertex3.Retain) {
#line 15635
      free((void *)ctx->EvalMap.Map1Vertex3.Points);
    }
  }
#line 15637
  ctx->EvalMap.Map1Vertex3.Points = (float *)points;
#line 15638
  ctx->EvalMap.Map1Vertex3.Retain = retain;
#line 15639
  break;
  case 3480: 
#line 15641
  ctx->EvalMap.Map1Vertex4.Order = (unsigned int )order;
#line 15642
  ctx->EvalMap.Map1Vertex4.u1 = u1;
#line 15643
  ctx->EvalMap.Map1Vertex4.u2 = u2;
#line 15644
  if (ctx->EvalMap.Map1Vertex4.Points) {
#line 15644
    if (! ctx->EvalMap.Map1Vertex4.Retain) {
#line 15646
      free((void *)ctx->EvalMap.Map1Vertex4.Points);
    }
  }
#line 15648
  ctx->EvalMap.Map1Vertex4.Points = (float *)points;
#line 15649
  ctx->EvalMap.Map1Vertex4.Retain = retain;
#line 15650
  break;
  case 3473: 
#line 15652
  ctx->EvalMap.Map1Index.Order = (unsigned int )order;
#line 15653
  ctx->EvalMap.Map1Index.u1 = u1;
#line 15654
  ctx->EvalMap.Map1Index.u2 = u2;
#line 15655
  if (ctx->EvalMap.Map1Index.Points) {
#line 15655
    if (! ctx->EvalMap.Map1Index.Retain) {
#line 15657
      free((void *)ctx->EvalMap.Map1Index.Points);
    }
  }
#line 15659
  ctx->EvalMap.Map1Index.Points = (float *)points;
#line 15660
  ctx->EvalMap.Map1Index.Retain = retain;
#line 15661
  break;
  case 3472: 
#line 15663
  ctx->EvalMap.Map1Color4.Order = (unsigned int )order;
#line 15664
  ctx->EvalMap.Map1Color4.u1 = u1;
#line 15665
  ctx->EvalMap.Map1Color4.u2 = u2;
#line 15666
  if (ctx->EvalMap.Map1Color4.Points) {
#line 15666
    if (! ctx->EvalMap.Map1Color4.Retain) {
#line 15668
      free((void *)ctx->EvalMap.Map1Color4.Points);
    }
  }
#line 15670
  ctx->EvalMap.Map1Color4.Points = (float *)points;
#line 15671
  ctx->EvalMap.Map1Color4.Retain = retain;
#line 15672
  break;
  case 3474: 
#line 15674
  ctx->EvalMap.Map1Normal.Order = (unsigned int )order;
#line 15675
  ctx->EvalMap.Map1Normal.u1 = u1;
#line 15676
  ctx->EvalMap.Map1Normal.u2 = u2;
#line 15677
  if (ctx->EvalMap.Map1Normal.Points) {
#line 15677
    if (! ctx->EvalMap.Map1Normal.Retain) {
#line 15679
      free((void *)ctx->EvalMap.Map1Normal.Points);
    }
  }
#line 15681
  ctx->EvalMap.Map1Normal.Points = (float *)points;
#line 15682
  ctx->EvalMap.Map1Normal.Retain = retain;
#line 15683
  break;
  case 3475: 
#line 15685
  ctx->EvalMap.Map1Texture1.Order = (unsigned int )order;
#line 15686
  ctx->EvalMap.Map1Texture1.u1 = u1;
#line 15687
  ctx->EvalMap.Map1Texture1.u2 = u2;
#line 15688
  if (ctx->EvalMap.Map1Texture1.Points) {
#line 15688
    if (! ctx->EvalMap.Map1Texture1.Retain) {
#line 15690
      free((void *)ctx->EvalMap.Map1Texture1.Points);
    }
  }
#line 15692
  ctx->EvalMap.Map1Texture1.Points = (float *)points;
#line 15693
  ctx->EvalMap.Map1Texture1.Retain = retain;
#line 15694
  break;
  case 3476: 
#line 15696
  ctx->EvalMap.Map1Texture2.Order = (unsigned int )order;
#line 15697
  ctx->EvalMap.Map1Texture2.u1 = u1;
#line 15698
  ctx->EvalMap.Map1Texture2.u2 = u2;
#line 15699
  if (ctx->EvalMap.Map1Texture2.Points) {
#line 15699
    if (! ctx->EvalMap.Map1Texture2.Retain) {
#line 15701
      free((void *)ctx->EvalMap.Map1Texture2.Points);
    }
  }
#line 15703
  ctx->EvalMap.Map1Texture2.Points = (float *)points;
#line 15704
  ctx->EvalMap.Map1Texture2.Retain = retain;
#line 15705
  break;
  case 3477: 
#line 15707
  ctx->EvalMap.Map1Texture3.Order = (unsigned int )order;
#line 15708
  ctx->EvalMap.Map1Texture3.u1 = u1;
#line 15709
  ctx->EvalMap.Map1Texture3.u2 = u2;
#line 15710
  if (ctx->EvalMap.Map1Texture3.Points) {
#line 15710
    if (! ctx->EvalMap.Map1Texture3.Retain) {
#line 15712
      free((void *)ctx->EvalMap.Map1Texture3.Points);
    }
  }
#line 15714
  ctx->EvalMap.Map1Texture3.Points = (float *)points;
#line 15715
  ctx->EvalMap.Map1Texture3.Retain = retain;
#line 15716
  break;
  case 3478: 
#line 15718
  ctx->EvalMap.Map1Texture4.Order = (unsigned int )order;
#line 15719
  ctx->EvalMap.Map1Texture4.u1 = u1;
#line 15720
  ctx->EvalMap.Map1Texture4.u2 = u2;
#line 15721
  if (ctx->EvalMap.Map1Texture4.Points) {
#line 15721
    if (! ctx->EvalMap.Map1Texture4.Retain) {
#line 15723
      free((void *)ctx->EvalMap.Map1Texture4.Points);
    }
  }
#line 15725
  ctx->EvalMap.Map1Texture4.Points = (float *)points;
#line 15726
  ctx->EvalMap.Map1Texture4.Retain = retain;
#line 15727
  break;
  default: 
#line 15729
  gl_error(ctx, 1280, "glMap1(target)");
  }
#line 15731
  return;
}
}
#line 15732 "D:/a/test/177.c"
void gl_Map2f(GLcontext *ctx , GLenum target , float u1 , float u2 , GLint ustride ,
              GLint uorder , float v1 , float v2 , GLint vstride , GLint vorder ,
              float const   *points , GLboolean retain ) 
{ GLuint k ;
  GLint tmp___0 ;

  {
#line 15738
  if (ctx->Primitive != 6656) {
#line 15739
    gl_error(ctx, 1282, "glMap2");
#line 15740
    return;
  }
#line 15742
  if (u1 == u2) {
#line 15743
    gl_error(ctx, 1281, "glMap2(u1,u2)");
#line 15744
    return;
  }
#line 15746
  if (v1 == v2) {
#line 15747
    gl_error(ctx, 1281, "glMap2(v1,v2)");
#line 15748
    return;
  }
#line 15750
  if (uorder < 1) {
#line 15751
    gl_error(ctx, 1281, "glMap2(uorder)");
#line 15752
    return;
  } else {
#line 15750
    if (uorder > 30) {
#line 15751
      gl_error(ctx, 1281, "glMap2(uorder)");
#line 15752
      return;
    }
  }
#line 15754
  if (vorder < 1) {
#line 15755
    gl_error(ctx, 1281, "glMap2(vorder)");
#line 15756
    return;
  } else {
#line 15754
    if (vorder > 30) {
#line 15755
      gl_error(ctx, 1281, "glMap2(vorder)");
#line 15756
      return;
    }
  }
#line 15758
  tmp___0 = components(target);
#line 15758
  k = (unsigned int )tmp___0;
#line 15759
  if (k == 0U) {
#line 15760
    gl_error(ctx, 1280, "glMap2(target)");
  }
#line 15762
  if ((GLuint )ustride < k) {
#line 15763
    gl_error(ctx, 1281, "glMap2(ustride)");
#line 15764
    return;
  }
#line 15766
  if ((GLuint )vstride < k) {
#line 15767
    gl_error(ctx, 1281, "glMap2(vstride)");
#line 15768
    return;
  }
#line 15770
  switch (target) {
  case 3511: 
#line 15772
  ctx->EvalMap.Map2Vertex3.Uorder = (unsigned int )uorder;
#line 15773
  ctx->EvalMap.Map2Vertex3.u1 = u1;
#line 15774
  ctx->EvalMap.Map2Vertex3.u2 = u2;
#line 15775
  ctx->EvalMap.Map2Vertex3.Vorder = (unsigned int )vorder;
#line 15776
  ctx->EvalMap.Map2Vertex3.v1 = v1;
#line 15777
  ctx->EvalMap.Map2Vertex3.v2 = v2;
#line 15778
  if (ctx->EvalMap.Map2Vertex3.Points) {
#line 15778
    if (! ctx->EvalMap.Map2Vertex3.Retain) {
#line 15780
      free((void *)ctx->EvalMap.Map2Vertex3.Points);
    }
  }
#line 15782
  ctx->EvalMap.Map2Vertex3.Retain = retain;
#line 15783
  ctx->EvalMap.Map2Vertex3.Points = (float *)points;
#line 15784
  break;
  case 3512: 
#line 15786
  ctx->EvalMap.Map2Vertex4.Uorder = (unsigned int )uorder;
#line 15787
  ctx->EvalMap.Map2Vertex4.u1 = u1;
#line 15788
  ctx->EvalMap.Map2Vertex4.u2 = u2;
#line 15789
  ctx->EvalMap.Map2Vertex4.Vorder = (unsigned int )vorder;
#line 15790
  ctx->EvalMap.Map2Vertex4.v1 = v1;
#line 15791
  ctx->EvalMap.Map2Vertex4.v2 = v2;
#line 15792
  if (ctx->EvalMap.Map2Vertex4.Points) {
#line 15792
    if (! ctx->EvalMap.Map2Vertex4.Retain) {
#line 15794
      free((void *)ctx->EvalMap.Map2Vertex4.Points);
    }
  }
#line 15796
  ctx->EvalMap.Map2Vertex4.Points = (float *)points;
#line 15797
  ctx->EvalMap.Map2Vertex4.Retain = retain;
#line 15798
  break;
  case 3505: 
#line 15800
  ctx->EvalMap.Map2Index.Uorder = (unsigned int )uorder;
#line 15801
  ctx->EvalMap.Map2Index.u1 = u1;
#line 15802
  ctx->EvalMap.Map2Index.u2 = u2;
#line 15803
  ctx->EvalMap.Map2Index.Vorder = (unsigned int )vorder;
#line 15804
  ctx->EvalMap.Map2Index.v1 = v1;
#line 15805
  ctx->EvalMap.Map2Index.v2 = v2;
#line 15806
  if (ctx->EvalMap.Map2Index.Points) {
#line 15806
    if (! ctx->EvalMap.Map2Index.Retain) {
#line 15808
      free((void *)ctx->EvalMap.Map2Index.Points);
    }
  }
#line 15810
  ctx->EvalMap.Map2Index.Retain = retain;
#line 15811
  ctx->EvalMap.Map2Index.Points = (float *)points;
#line 15812
  break;
  case 3504: 
#line 15814
  ctx->EvalMap.Map2Color4.Uorder = (unsigned int )uorder;
#line 15815
  ctx->EvalMap.Map2Color4.u1 = u1;
#line 15816
  ctx->EvalMap.Map2Color4.u2 = u2;
#line 15817
  ctx->EvalMap.Map2Color4.Vorder = (unsigned int )vorder;
#line 15818
  ctx->EvalMap.Map2Color4.v1 = v1;
#line 15819
  ctx->EvalMap.Map2Color4.v2 = v2;
#line 15820
  if (ctx->EvalMap.Map2Color4.Points) {
#line 15820
    if (! ctx->EvalMap.Map2Color4.Retain) {
#line 15822
      free((void *)ctx->EvalMap.Map2Color4.Points);
    }
  }
#line 15824
  ctx->EvalMap.Map2Color4.Retain = retain;
#line 15825
  ctx->EvalMap.Map2Color4.Points = (float *)points;
#line 15826
  break;
  case 3506: 
#line 15828
  ctx->EvalMap.Map2Normal.Uorder = (unsigned int )uorder;
#line 15829
  ctx->EvalMap.Map2Normal.u1 = u1;
#line 15830
  ctx->EvalMap.Map2Normal.u2 = u2;
#line 15831
  ctx->EvalMap.Map2Normal.Vorder = (unsigned int )vorder;
#line 15832
  ctx->EvalMap.Map2Normal.v1 = v1;
#line 15833
  ctx->EvalMap.Map2Normal.v2 = v2;
#line 15834
  if (ctx->EvalMap.Map2Normal.Points) {
#line 15834
    if (! ctx->EvalMap.Map2Normal.Retain) {
#line 15836
      free((void *)ctx->EvalMap.Map2Normal.Points);
    }
  }
#line 15838
  ctx->EvalMap.Map2Normal.Retain = retain;
#line 15839
  ctx->EvalMap.Map2Normal.Points = (float *)points;
#line 15840
  break;
  case 3507: 
#line 15842
  ctx->EvalMap.Map2Texture1.Uorder = (unsigned int )uorder;
#line 15843
  ctx->EvalMap.Map2Texture1.u1 = u1;
#line 15844
  ctx->EvalMap.Map2Texture1.u2 = u2;
#line 15845
  ctx->EvalMap.Map2Texture1.Vorder = (unsigned int )vorder;
#line 15846
  ctx->EvalMap.Map2Texture1.v1 = v1;
#line 15847
  ctx->EvalMap.Map2Texture1.v2 = v2;
#line 15848
  if (ctx->EvalMap.Map2Texture1.Points) {
#line 15848
    if (! ctx->EvalMap.Map2Texture1.Retain) {
#line 15850
      free((void *)ctx->EvalMap.Map2Texture1.Points);
    }
  }
#line 15852
  ctx->EvalMap.Map2Texture1.Retain = retain;
#line 15853
  ctx->EvalMap.Map2Texture1.Points = (float *)points;
#line 15854
  break;
  case 3508: 
#line 15856
  ctx->EvalMap.Map2Texture2.Uorder = (unsigned int )uorder;
#line 15857
  ctx->EvalMap.Map2Texture2.u1 = u1;
#line 15858
  ctx->EvalMap.Map2Texture2.u2 = u2;
#line 15859
  ctx->EvalMap.Map2Texture2.Vorder = (unsigned int )vorder;
#line 15860
  ctx->EvalMap.Map2Texture2.v1 = v1;
#line 15861
  ctx->EvalMap.Map2Texture2.v2 = v2;
#line 15862
  if (ctx->EvalMap.Map2Texture2.Points) {
#line 15862
    if (! ctx->EvalMap.Map2Texture2.Retain) {
#line 15864
      free((void *)ctx->EvalMap.Map2Texture2.Points);
    }
  }
#line 15866
  ctx->EvalMap.Map2Texture2.Retain = retain;
#line 15867
  ctx->EvalMap.Map2Texture2.Points = (float *)points;
#line 15868
  break;
  case 3509: 
#line 15870
  ctx->EvalMap.Map2Texture3.Uorder = (unsigned int )uorder;
#line 15871
  ctx->EvalMap.Map2Texture3.u1 = u1;
#line 15872
  ctx->EvalMap.Map2Texture3.u2 = u2;
#line 15873
  ctx->EvalMap.Map2Texture3.Vorder = (unsigned int )vorder;
#line 15874
  ctx->EvalMap.Map2Texture3.v1 = v1;
#line 15875
  ctx->EvalMap.Map2Texture3.v2 = v2;
#line 15876
  if (ctx->EvalMap.Map2Texture3.Points) {
#line 15876
    if (! ctx->EvalMap.Map2Texture3.Retain) {
#line 15878
      free((void *)ctx->EvalMap.Map2Texture3.Points);
    }
  }
#line 15880
  ctx->EvalMap.Map2Texture3.Retain = retain;
#line 15881
  ctx->EvalMap.Map2Texture3.Points = (float *)points;
#line 15882
  break;
  case 3510: 
#line 15884
  ctx->EvalMap.Map2Texture4.Uorder = (unsigned int )uorder;
#line 15885
  ctx->EvalMap.Map2Texture4.u1 = u1;
#line 15886
  ctx->EvalMap.Map2Texture4.u2 = u2;
#line 15887
  ctx->EvalMap.Map2Texture4.Vorder = (unsigned int )vorder;
#line 15888
  ctx->EvalMap.Map2Texture4.v1 = v1;
#line 15889
  ctx->EvalMap.Map2Texture4.v2 = v2;
#line 15890
  if (ctx->EvalMap.Map2Texture4.Points) {
#line 15890
    if (! ctx->EvalMap.Map2Texture4.Retain) {
#line 15892
      free((void *)ctx->EvalMap.Map2Texture4.Points);
    }
  }
#line 15894
  ctx->EvalMap.Map2Texture4.Retain = retain;
#line 15895
  ctx->EvalMap.Map2Texture4.Points = (float *)points;
#line 15896
  break;
  default: 
#line 15898
  gl_error(ctx, 1280, "glMap2(target)");
  }
#line 15900
  return;
}
}
#line 15901 "D:/a/test/177.c"
void gl_GetMapdv(GLcontext *ctx , GLenum target , GLenum query , GLdouble *v ) 
{ GLuint i ;
  GLuint n ;
  float *data ;

  {
#line 15905
  switch (query) {
  case 2560: 
#line 15907
  switch (target) {
  case 3472: 
#line 15909
  data = ctx->EvalMap.Map1Color4.Points;
#line 15910
  n = ctx->EvalMap.Map1Color4.Order * 4U;
#line 15911
  break;
  case 3473: 
#line 15913
  data = ctx->EvalMap.Map1Index.Points;
#line 15914
  n = ctx->EvalMap.Map1Index.Order;
#line 15915
  break;
  case 3474: 
#line 15917
  data = ctx->EvalMap.Map1Normal.Points;
#line 15918
  n = ctx->EvalMap.Map1Normal.Order * 3U;
#line 15919
  break;
  case 3475: 
#line 15921
  data = ctx->EvalMap.Map1Texture1.Points;
#line 15922
  n = ctx->EvalMap.Map1Texture1.Order;
#line 15923
  break;
  case 3476: 
#line 15925
  data = ctx->EvalMap.Map1Texture2.Points;
#line 15926
  n = ctx->EvalMap.Map1Texture2.Order * 2U;
#line 15927
  break;
  case 3477: 
#line 15929
  data = ctx->EvalMap.Map1Texture3.Points;
#line 15930
  n = ctx->EvalMap.Map1Texture3.Order * 3U;
#line 15931
  break;
  case 3478: 
#line 15933
  data = ctx->EvalMap.Map1Texture4.Points;
#line 15934
  n = ctx->EvalMap.Map1Texture4.Order * 4U;
#line 15935
  break;
  case 3479: 
#line 15937
  data = ctx->EvalMap.Map1Vertex3.Points;
#line 15938
  n = ctx->EvalMap.Map1Vertex3.Order * 3U;
#line 15939
  break;
  case 3480: 
#line 15941
  data = ctx->EvalMap.Map1Vertex4.Points;
#line 15942
  n = ctx->EvalMap.Map1Vertex4.Order * 4U;
#line 15943
  break;
  case 3504: 
#line 15945
  data = ctx->EvalMap.Map2Color4.Points;
#line 15946
  n = (ctx->EvalMap.Map2Color4.Uorder * ctx->EvalMap.Map2Color4.Vorder) * 4U;
#line 15948
  break;
  case 3505: 
#line 15950
  data = ctx->EvalMap.Map2Index.Points;
#line 15951
  n = ctx->EvalMap.Map2Index.Uorder * ctx->EvalMap.Map2Index.Vorder;
#line 15953
  break;
  case 3506: 
#line 15955
  data = ctx->EvalMap.Map2Normal.Points;
#line 15956
  n = (ctx->EvalMap.Map2Normal.Uorder * ctx->EvalMap.Map2Normal.Vorder) * 3U;
#line 15958
  break;
  case 3507: 
#line 15960
  data = ctx->EvalMap.Map2Texture1.Points;
#line 15961
  n = ctx->EvalMap.Map2Texture1.Uorder * ctx->EvalMap.Map2Texture1.Vorder;
#line 15963
  break;
  case 3508: 
#line 15965
  data = ctx->EvalMap.Map2Texture2.Points;
#line 15966
  n = (ctx->EvalMap.Map2Texture2.Uorder * ctx->EvalMap.Map2Texture2.Vorder) * 2U;
#line 15968
  break;
  case 3509: 
#line 15970
  data = ctx->EvalMap.Map2Texture3.Points;
#line 15971
  n = (ctx->EvalMap.Map2Texture3.Uorder * ctx->EvalMap.Map2Texture3.Vorder) * 3U;
#line 15973
  break;
  case 3510: 
#line 15975
  data = ctx->EvalMap.Map2Texture4.Points;
#line 15976
  n = (ctx->EvalMap.Map2Texture4.Uorder * ctx->EvalMap.Map2Texture4.Vorder) * 4U;
#line 15978
  break;
  case 3511: 
#line 15980
  data = ctx->EvalMap.Map2Vertex3.Points;
#line 15981
  n = (ctx->EvalMap.Map2Vertex3.Uorder * ctx->EvalMap.Map2Vertex3.Vorder) * 3U;
#line 15983
  break;
  case 3512: 
#line 15985
  data = ctx->EvalMap.Map2Vertex4.Points;
#line 15986
  n = (ctx->EvalMap.Map2Vertex4.Uorder * ctx->EvalMap.Map2Vertex4.Vorder) * 4U;
#line 15988
  break;
  default: 
#line 15990
  gl_error(ctx, 1280, "glGetMapdv(target)");
  }
#line 15992
  if (data) {
#line 15993
    i = 0U;
#line 15993
    while (i < n) {
#line 15994
      *(v + i) = (double )*(data + i);
#line 15993
      i ++;
    }
  }
#line 15997
  break;
  case 2561: 
#line 15999
  switch (target) {
  case 3472: 
#line 16001
  *v = (double )ctx->EvalMap.Map1Color4.Order;
#line 16002
  break;
  case 3473: 
#line 16004
  *v = (double )ctx->EvalMap.Map1Index.Order;
#line 16005
  break;
  case 3474: 
#line 16007
  *v = (double )ctx->EvalMap.Map1Normal.Order;
#line 16008
  break;
  case 3475: 
#line 16010
  *v = (double )ctx->EvalMap.Map1Texture1.Order;
#line 16011
  break;
  case 3476: 
#line 16013
  *v = (double )ctx->EvalMap.Map1Texture2.Order;
#line 16014
  break;
  case 3477: 
#line 16016
  *v = (double )ctx->EvalMap.Map1Texture3.Order;
#line 16017
  break;
  case 3478: 
#line 16019
  *v = (double )ctx->EvalMap.Map1Texture4.Order;
#line 16020
  break;
  case 3479: 
#line 16022
  *v = (double )ctx->EvalMap.Map1Vertex3.Order;
#line 16023
  break;
  case 3480: 
#line 16025
  *v = (double )ctx->EvalMap.Map1Vertex4.Order;
#line 16026
  break;
  case 3504: 
#line 16028
  *(v + 0) = (double )ctx->EvalMap.Map2Color4.Uorder;
#line 16029
  *(v + 1) = (double )ctx->EvalMap.Map2Color4.Vorder;
#line 16030
  break;
  case 3505: 
#line 16032
  *(v + 0) = (double )ctx->EvalMap.Map2Index.Uorder;
#line 16033
  *(v + 1) = (double )ctx->EvalMap.Map2Index.Vorder;
#line 16034
  break;
  case 3506: 
#line 16036
  *(v + 0) = (double )ctx->EvalMap.Map2Normal.Uorder;
#line 16037
  *(v + 1) = (double )ctx->EvalMap.Map2Normal.Vorder;
#line 16038
  break;
  case 3507: 
#line 16040
  *(v + 0) = (double )ctx->EvalMap.Map2Texture1.Uorder;
#line 16041
  *(v + 1) = (double )ctx->EvalMap.Map2Texture1.Vorder;
#line 16042
  break;
  case 3508: 
#line 16044
  *(v + 0) = (double )ctx->EvalMap.Map2Texture2.Uorder;
#line 16045
  *(v + 1) = (double )ctx->EvalMap.Map2Texture2.Vorder;
#line 16046
  break;
  case 3509: 
#line 16048
  *(v + 0) = (double )ctx->EvalMap.Map2Texture3.Uorder;
#line 16049
  *(v + 1) = (double )ctx->EvalMap.Map2Texture3.Vorder;
#line 16050
  break;
  case 3510: 
#line 16052
  *(v + 0) = (double )ctx->EvalMap.Map2Texture4.Uorder;
#line 16053
  *(v + 1) = (double )ctx->EvalMap.Map2Texture4.Vorder;
#line 16054
  break;
  case 3511: 
#line 16056
  *(v + 0) = (double )ctx->EvalMap.Map2Vertex3.Uorder;
#line 16057
  *(v + 1) = (double )ctx->EvalMap.Map2Vertex3.Vorder;
#line 16058
  break;
  case 3512: 
#line 16060
  *(v + 0) = (double )ctx->EvalMap.Map2Vertex4.Uorder;
#line 16061
  *(v + 1) = (double )ctx->EvalMap.Map2Vertex4.Vorder;
#line 16062
  break;
  default: 
#line 16064
  gl_error(ctx, 1280, "glGetMapdv(target)");
  }
#line 16066
  break;
  case 2562: 
#line 16068
  switch (target) {
  case 3472: 
#line 16070
  *(v + 0) = (double )ctx->EvalMap.Map1Color4.u1;
#line 16071
  *(v + 1) = (double )ctx->EvalMap.Map1Color4.u2;
#line 16072
  break;
  case 3473: 
#line 16074
  *(v + 0) = (double )ctx->EvalMap.Map1Index.u1;
#line 16075
  *(v + 1) = (double )ctx->EvalMap.Map1Index.u2;
#line 16076
  break;
  case 3474: 
#line 16078
  *(v + 0) = (double )ctx->EvalMap.Map1Normal.u1;
#line 16079
  *(v + 1) = (double )ctx->EvalMap.Map1Normal.u2;
#line 16080
  break;
  case 3475: 
#line 16082
  *(v + 0) = (double )ctx->EvalMap.Map1Texture1.u1;
#line 16083
  *(v + 1) = (double )ctx->EvalMap.Map1Texture1.u2;
#line 16084
  break;
  case 3476: 
#line 16086
  *(v + 0) = (double )ctx->EvalMap.Map1Texture2.u1;
#line 16087
  *(v + 1) = (double )ctx->EvalMap.Map1Texture2.u2;
#line 16088
  break;
  case 3477: 
#line 16090
  *(v + 0) = (double )ctx->EvalMap.Map1Texture3.u1;
#line 16091
  *(v + 1) = (double )ctx->EvalMap.Map1Texture3.u2;
#line 16092
  break;
  case 3478: 
#line 16094
  *(v + 0) = (double )ctx->EvalMap.Map1Texture4.u1;
#line 16095
  *(v + 1) = (double )ctx->EvalMap.Map1Texture4.u2;
#line 16096
  break;
  case 3479: 
#line 16098
  *(v + 0) = (double )ctx->EvalMap.Map1Vertex3.u1;
#line 16099
  *(v + 1) = (double )ctx->EvalMap.Map1Vertex3.u2;
#line 16100
  break;
  case 3480: 
#line 16102
  *(v + 0) = (double )ctx->EvalMap.Map1Vertex4.u1;
#line 16103
  *(v + 1) = (double )ctx->EvalMap.Map1Vertex4.u2;
#line 16104
  break;
  case 3504: 
#line 16106
  *(v + 0) = (double )ctx->EvalMap.Map2Color4.u1;
#line 16107
  *(v + 1) = (double )ctx->EvalMap.Map2Color4.u2;
#line 16108
  *(v + 2) = (double )ctx->EvalMap.Map2Color4.v1;
#line 16109
  *(v + 3) = (double )ctx->EvalMap.Map2Color4.v2;
#line 16110
  break;
  case 3505: 
#line 16112
  *(v + 0) = (double )ctx->EvalMap.Map2Index.u1;
#line 16113
  *(v + 1) = (double )ctx->EvalMap.Map2Index.u2;
#line 16114
  *(v + 2) = (double )ctx->EvalMap.Map2Index.v1;
#line 16115
  *(v + 3) = (double )ctx->EvalMap.Map2Index.v2;
#line 16116
  break;
  case 3506: 
#line 16118
  *(v + 0) = (double )ctx->EvalMap.Map2Normal.u1;
#line 16119
  *(v + 1) = (double )ctx->EvalMap.Map2Normal.u2;
#line 16120
  *(v + 2) = (double )ctx->EvalMap.Map2Normal.v1;
#line 16121
  *(v + 3) = (double )ctx->EvalMap.Map2Normal.v2;
#line 16122
  break;
  case 3507: 
#line 16124
  *(v + 0) = (double )ctx->EvalMap.Map2Texture1.u1;
#line 16125
  *(v + 1) = (double )ctx->EvalMap.Map2Texture1.u2;
#line 16126
  *(v + 2) = (double )ctx->EvalMap.Map2Texture1.v1;
#line 16127
  *(v + 3) = (double )ctx->EvalMap.Map2Texture1.v2;
#line 16128
  break;
  case 3508: 
#line 16130
  *(v + 0) = (double )ctx->EvalMap.Map2Texture2.u1;
#line 16131
  *(v + 1) = (double )ctx->EvalMap.Map2Texture2.u2;
#line 16132
  *(v + 2) = (double )ctx->EvalMap.Map2Texture2.v1;
#line 16133
  *(v + 3) = (double )ctx->EvalMap.Map2Texture2.v2;
#line 16134
  break;
  case 3509: 
#line 16136
  *(v + 0) = (double )ctx->EvalMap.Map2Texture3.u1;
#line 16137
  *(v + 1) = (double )ctx->EvalMap.Map2Texture3.u2;
#line 16138
  *(v + 2) = (double )ctx->EvalMap.Map2Texture3.v1;
#line 16139
  *(v + 3) = (double )ctx->EvalMap.Map2Texture3.v2;
#line 16140
  break;
  case 3510: 
#line 16142
  *(v + 0) = (double )ctx->EvalMap.Map2Texture4.u1;
#line 16143
  *(v + 1) = (double )ctx->EvalMap.Map2Texture4.u2;
#line 16144
  *(v + 2) = (double )ctx->EvalMap.Map2Texture4.v1;
#line 16145
  *(v + 3) = (double )ctx->EvalMap.Map2Texture4.v2;
#line 16146
  break;
  case 3511: 
#line 16148
  *(v + 0) = (double )ctx->EvalMap.Map2Vertex3.u1;
#line 16149
  *(v + 1) = (double )ctx->EvalMap.Map2Vertex3.u2;
#line 16150
  *(v + 2) = (double )ctx->EvalMap.Map2Vertex3.v1;
#line 16151
  *(v + 3) = (double )ctx->EvalMap.Map2Vertex3.v2;
#line 16152
  break;
  case 3512: 
#line 16154
  *(v + 0) = (double )ctx->EvalMap.Map2Vertex4.u1;
#line 16155
  *(v + 1) = (double )ctx->EvalMap.Map2Vertex4.u2;
#line 16156
  *(v + 2) = (double )ctx->EvalMap.Map2Vertex4.v1;
#line 16157
  *(v + 3) = (double )ctx->EvalMap.Map2Vertex4.v2;
#line 16158
  break;
  default: 
#line 16160
  gl_error(ctx, 1280, "glGetMapdv(target)");
  }
#line 16162
  break;
  default: 
#line 16164
  gl_error(ctx, 1280, "glGetMapdv(query)");
  }
#line 16166
  return;
}
}
#line 16167 "D:/a/test/177.c"
void gl_GetMapfv(GLcontext *ctx , GLenum target , GLenum query , float *v ) 
{ GLuint i ;
  GLuint n ;
  float *data ;

  {
#line 16171
  switch (query) {
  case 2560: 
#line 16173
  switch (target) {
  case 3472: 
#line 16175
  data = ctx->EvalMap.Map1Color4.Points;
#line 16176
  n = ctx->EvalMap.Map1Color4.Order * 4U;
#line 16177
  break;
  case 3473: 
#line 16179
  data = ctx->EvalMap.Map1Index.Points;
#line 16180
  n = ctx->EvalMap.Map1Index.Order;
#line 16181
  break;
  case 3474: 
#line 16183
  data = ctx->EvalMap.Map1Normal.Points;
#line 16184
  n = ctx->EvalMap.Map1Normal.Order * 3U;
#line 16185
  break;
  case 3475: 
#line 16187
  data = ctx->EvalMap.Map1Texture1.Points;
#line 16188
  n = ctx->EvalMap.Map1Texture1.Order;
#line 16189
  break;
  case 3476: 
#line 16191
  data = ctx->EvalMap.Map1Texture2.Points;
#line 16192
  n = ctx->EvalMap.Map1Texture2.Order * 2U;
#line 16193
  break;
  case 3477: 
#line 16195
  data = ctx->EvalMap.Map1Texture3.Points;
#line 16196
  n = ctx->EvalMap.Map1Texture3.Order * 3U;
#line 16197
  break;
  case 3478: 
#line 16199
  data = ctx->EvalMap.Map1Texture4.Points;
#line 16200
  n = ctx->EvalMap.Map1Texture4.Order * 4U;
#line 16201
  break;
  case 3479: 
#line 16203
  data = ctx->EvalMap.Map1Vertex3.Points;
#line 16204
  n = ctx->EvalMap.Map1Vertex3.Order * 3U;
#line 16205
  break;
  case 3480: 
#line 16207
  data = ctx->EvalMap.Map1Vertex4.Points;
#line 16208
  n = ctx->EvalMap.Map1Vertex4.Order * 4U;
#line 16209
  break;
  case 3504: 
#line 16211
  data = ctx->EvalMap.Map2Color4.Points;
#line 16212
  n = (ctx->EvalMap.Map2Color4.Uorder * ctx->EvalMap.Map2Color4.Vorder) * 4U;
#line 16214
  break;
  case 3505: 
#line 16216
  data = ctx->EvalMap.Map2Index.Points;
#line 16217
  n = ctx->EvalMap.Map2Index.Uorder * ctx->EvalMap.Map2Index.Vorder;
#line 16219
  break;
  case 3506: 
#line 16221
  data = ctx->EvalMap.Map2Normal.Points;
#line 16222
  n = (ctx->EvalMap.Map2Normal.Uorder * ctx->EvalMap.Map2Normal.Vorder) * 3U;
#line 16224
  break;
  case 3507: 
#line 16226
  data = ctx->EvalMap.Map2Texture1.Points;
#line 16227
  n = ctx->EvalMap.Map2Texture1.Uorder * ctx->EvalMap.Map2Texture1.Vorder;
#line 16229
  break;
  case 3508: 
#line 16231
  data = ctx->EvalMap.Map2Texture2.Points;
#line 16232
  n = (ctx->EvalMap.Map2Texture2.Uorder * ctx->EvalMap.Map2Texture2.Vorder) * 2U;
#line 16234
  break;
  case 3509: 
#line 16236
  data = ctx->EvalMap.Map2Texture3.Points;
#line 16237
  n = (ctx->EvalMap.Map2Texture3.Uorder * ctx->EvalMap.Map2Texture3.Vorder) * 3U;
#line 16239
  break;
  case 3510: 
#line 16241
  data = ctx->EvalMap.Map2Texture4.Points;
#line 16242
  n = (ctx->EvalMap.Map2Texture4.Uorder * ctx->EvalMap.Map2Texture4.Vorder) * 4U;
#line 16244
  break;
  case 3511: 
#line 16246
  data = ctx->EvalMap.Map2Vertex3.Points;
#line 16247
  n = (ctx->EvalMap.Map2Vertex3.Uorder * ctx->EvalMap.Map2Vertex3.Vorder) * 3U;
#line 16249
  break;
  case 3512: 
#line 16251
  data = ctx->EvalMap.Map2Vertex4.Points;
#line 16252
  n = (ctx->EvalMap.Map2Vertex4.Uorder * ctx->EvalMap.Map2Vertex4.Vorder) * 4U;
#line 16254
  break;
  default: 
#line 16256
  gl_error(ctx, 1280, "glGetMapfv(target)");
  }
#line 16258
  if (data) {
#line 16259
    i = 0U;
#line 16259
    while (i < n) {
#line 16260
      *(v + i) = *(data + i);
#line 16259
      i ++;
    }
  }
#line 16263
  break;
  case 2561: 
#line 16265
  switch (target) {
  case 3472: 
#line 16267
  *v = (float )ctx->EvalMap.Map1Color4.Order;
#line 16268
  break;
  case 3473: 
#line 16270
  *v = (float )ctx->EvalMap.Map1Index.Order;
#line 16271
  break;
  case 3474: 
#line 16273
  *v = (float )ctx->EvalMap.Map1Normal.Order;
#line 16274
  break;
  case 3475: 
#line 16276
  *v = (float )ctx->EvalMap.Map1Texture1.Order;
#line 16277
  break;
  case 3476: 
#line 16279
  *v = (float )ctx->EvalMap.Map1Texture2.Order;
#line 16280
  break;
  case 3477: 
#line 16282
  *v = (float )ctx->EvalMap.Map1Texture3.Order;
#line 16283
  break;
  case 3478: 
#line 16285
  *v = (float )ctx->EvalMap.Map1Texture4.Order;
#line 16286
  break;
  case 3479: 
#line 16288
  *v = (float )ctx->EvalMap.Map1Vertex3.Order;
#line 16289
  break;
  case 3480: 
#line 16291
  *v = (float )ctx->EvalMap.Map1Vertex4.Order;
#line 16292
  break;
  case 3504: 
#line 16294
  *(v + 0) = (float )ctx->EvalMap.Map2Color4.Uorder;
#line 16295
  *(v + 1) = (float )ctx->EvalMap.Map2Color4.Vorder;
#line 16296
  break;
  case 3505: 
#line 16298
  *(v + 0) = (float )ctx->EvalMap.Map2Index.Uorder;
#line 16299
  *(v + 1) = (float )ctx->EvalMap.Map2Index.Vorder;
#line 16300
  break;
  case 3506: 
#line 16302
  *(v + 0) = (float )ctx->EvalMap.Map2Normal.Uorder;
#line 16303
  *(v + 1) = (float )ctx->EvalMap.Map2Normal.Vorder;
#line 16304
  break;
  case 3507: 
#line 16306
  *(v + 0) = (float )ctx->EvalMap.Map2Texture1.Uorder;
#line 16307
  *(v + 1) = (float )ctx->EvalMap.Map2Texture1.Vorder;
#line 16308
  break;
  case 3508: 
#line 16310
  *(v + 0) = (float )ctx->EvalMap.Map2Texture2.Uorder;
#line 16311
  *(v + 1) = (float )ctx->EvalMap.Map2Texture2.Vorder;
#line 16312
  break;
  case 3509: 
#line 16314
  *(v + 0) = (float )ctx->EvalMap.Map2Texture3.Uorder;
#line 16315
  *(v + 1) = (float )ctx->EvalMap.Map2Texture3.Vorder;
#line 16316
  break;
  case 3510: 
#line 16318
  *(v + 0) = (float )ctx->EvalMap.Map2Texture4.Uorder;
#line 16319
  *(v + 1) = (float )ctx->EvalMap.Map2Texture4.Vorder;
#line 16320
  break;
  case 3511: 
#line 16322
  *(v + 0) = (float )ctx->EvalMap.Map2Vertex3.Uorder;
#line 16323
  *(v + 1) = (float )ctx->EvalMap.Map2Vertex3.Vorder;
#line 16324
  break;
  case 3512: 
#line 16326
  *(v + 0) = (float )ctx->EvalMap.Map2Vertex4.Uorder;
#line 16327
  *(v + 1) = (float )ctx->EvalMap.Map2Vertex4.Vorder;
#line 16328
  break;
  default: 
#line 16330
  gl_error(ctx, 1280, "glGetMapfv(target)");
  }
#line 16332
  break;
  case 2562: 
#line 16334
  switch (target) {
  case 3472: 
#line 16336
  *(v + 0) = ctx->EvalMap.Map1Color4.u1;
#line 16337
  *(v + 1) = ctx->EvalMap.Map1Color4.u2;
#line 16338
  break;
  case 3473: 
#line 16340
  *(v + 0) = ctx->EvalMap.Map1Index.u1;
#line 16341
  *(v + 1) = ctx->EvalMap.Map1Index.u2;
#line 16342
  break;
  case 3474: 
#line 16344
  *(v + 0) = ctx->EvalMap.Map1Normal.u1;
#line 16345
  *(v + 1) = ctx->EvalMap.Map1Normal.u2;
#line 16346
  break;
  case 3475: 
#line 16348
  *(v + 0) = ctx->EvalMap.Map1Texture1.u1;
#line 16349
  *(v + 1) = ctx->EvalMap.Map1Texture1.u2;
#line 16350
  break;
  case 3476: 
#line 16352
  *(v + 0) = ctx->EvalMap.Map1Texture2.u1;
#line 16353
  *(v + 1) = ctx->EvalMap.Map1Texture2.u2;
#line 16354
  break;
  case 3477: 
#line 16356
  *(v + 0) = ctx->EvalMap.Map1Texture3.u1;
#line 16357
  *(v + 1) = ctx->EvalMap.Map1Texture3.u2;
#line 16358
  break;
  case 3478: 
#line 16360
  *(v + 0) = ctx->EvalMap.Map1Texture4.u1;
#line 16361
  *(v + 1) = ctx->EvalMap.Map1Texture4.u2;
#line 16362
  break;
  case 3479: 
#line 16364
  *(v + 0) = ctx->EvalMap.Map1Vertex3.u1;
#line 16365
  *(v + 1) = ctx->EvalMap.Map1Vertex3.u2;
#line 16366
  break;
  case 3480: 
#line 16368
  *(v + 0) = ctx->EvalMap.Map1Vertex4.u1;
#line 16369
  *(v + 1) = ctx->EvalMap.Map1Vertex4.u2;
#line 16370
  break;
  case 3504: 
#line 16372
  *(v + 0) = ctx->EvalMap.Map2Color4.u1;
#line 16373
  *(v + 1) = ctx->EvalMap.Map2Color4.u2;
#line 16374
  *(v + 2) = ctx->EvalMap.Map2Color4.v1;
#line 16375
  *(v + 3) = ctx->EvalMap.Map2Color4.v2;
#line 16376
  break;
  case 3505: 
#line 16378
  *(v + 0) = ctx->EvalMap.Map2Index.u1;
#line 16379
  *(v + 1) = ctx->EvalMap.Map2Index.u2;
#line 16380
  *(v + 2) = ctx->EvalMap.Map2Index.v1;
#line 16381
  *(v + 3) = ctx->EvalMap.Map2Index.v2;
#line 16382
  break;
  case 3506: 
#line 16384
  *(v + 0) = ctx->EvalMap.Map2Normal.u1;
#line 16385
  *(v + 1) = ctx->EvalMap.Map2Normal.u2;
#line 16386
  *(v + 2) = ctx->EvalMap.Map2Normal.v1;
#line 16387
  *(v + 3) = ctx->EvalMap.Map2Normal.v2;
#line 16388
  break;
  case 3507: 
#line 16390
  *(v + 0) = ctx->EvalMap.Map2Texture1.u1;
#line 16391
  *(v + 1) = ctx->EvalMap.Map2Texture1.u2;
#line 16392
  *(v + 2) = ctx->EvalMap.Map2Texture1.v1;
#line 16393
  *(v + 3) = ctx->EvalMap.Map2Texture1.v2;
#line 16394
  break;
  case 3508: 
#line 16396
  *(v + 0) = ctx->EvalMap.Map2Texture2.u1;
#line 16397
  *(v + 1) = ctx->EvalMap.Map2Texture2.u2;
#line 16398
  *(v + 2) = ctx->EvalMap.Map2Texture2.v1;
#line 16399
  *(v + 3) = ctx->EvalMap.Map2Texture2.v2;
#line 16400
  break;
  case 3509: 
#line 16402
  *(v + 0) = ctx->EvalMap.Map2Texture3.u1;
#line 16403
  *(v + 1) = ctx->EvalMap.Map2Texture3.u2;
#line 16404
  *(v + 2) = ctx->EvalMap.Map2Texture3.v1;
#line 16405
  *(v + 3) = ctx->EvalMap.Map2Texture3.v2;
#line 16406
  break;
  case 3510: 
#line 16408
  *(v + 0) = ctx->EvalMap.Map2Texture4.u1;
#line 16409
  *(v + 1) = ctx->EvalMap.Map2Texture4.u2;
#line 16410
  *(v + 2) = ctx->EvalMap.Map2Texture4.v1;
#line 16411
  *(v + 3) = ctx->EvalMap.Map2Texture4.v2;
#line 16412
  break;
  case 3511: 
#line 16414
  *(v + 0) = ctx->EvalMap.Map2Vertex3.u1;
#line 16415
  *(v + 1) = ctx->EvalMap.Map2Vertex3.u2;
#line 16416
  *(v + 2) = ctx->EvalMap.Map2Vertex3.v1;
#line 16417
  *(v + 3) = ctx->EvalMap.Map2Vertex3.v2;
#line 16418
  break;
  case 3512: 
#line 16420
  *(v + 0) = ctx->EvalMap.Map2Vertex4.u1;
#line 16421
  *(v + 1) = ctx->EvalMap.Map2Vertex4.u2;
#line 16422
  *(v + 2) = ctx->EvalMap.Map2Vertex4.v1;
#line 16423
  *(v + 3) = ctx->EvalMap.Map2Vertex4.v2;
#line 16424
  break;
  default: 
#line 16426
  gl_error(ctx, 1280, "glGetMapfv(target)");
  }
#line 16428
  break;
  default: 
#line 16430
  gl_error(ctx, 1280, "glGetMapfv(query)");
  }
#line 16432
  return;
}
}
#line 16433 "D:/a/test/177.c"
void gl_GetMapiv(GLcontext *ctx , GLenum target , GLenum query , GLint *v ) 
{ GLuint i ;
  GLuint n ;
  float *data ;

  {
#line 16437
  switch (query) {
  case 2560: 
#line 16439
  switch (target) {
  case 3472: 
#line 16441
  data = ctx->EvalMap.Map1Color4.Points;
#line 16442
  n = ctx->EvalMap.Map1Color4.Order * 4U;
#line 16443
  break;
  case 3473: 
#line 16445
  data = ctx->EvalMap.Map1Index.Points;
#line 16446
  n = ctx->EvalMap.Map1Index.Order;
#line 16447
  break;
  case 3474: 
#line 16449
  data = ctx->EvalMap.Map1Normal.Points;
#line 16450
  n = ctx->EvalMap.Map1Normal.Order * 3U;
#line 16451
  break;
  case 3475: 
#line 16453
  data = ctx->EvalMap.Map1Texture1.Points;
#line 16454
  n = ctx->EvalMap.Map1Texture1.Order;
#line 16455
  break;
  case 3476: 
#line 16457
  data = ctx->EvalMap.Map1Texture2.Points;
#line 16458
  n = ctx->EvalMap.Map1Texture2.Order * 2U;
#line 16459
  break;
  case 3477: 
#line 16461
  data = ctx->EvalMap.Map1Texture3.Points;
#line 16462
  n = ctx->EvalMap.Map1Texture3.Order * 3U;
#line 16463
  break;
  case 3478: 
#line 16465
  data = ctx->EvalMap.Map1Texture4.Points;
#line 16466
  n = ctx->EvalMap.Map1Texture4.Order * 4U;
#line 16467
  break;
  case 3479: 
#line 16469
  data = ctx->EvalMap.Map1Vertex3.Points;
#line 16470
  n = ctx->EvalMap.Map1Vertex3.Order * 3U;
#line 16471
  break;
  case 3480: 
#line 16473
  data = ctx->EvalMap.Map1Vertex4.Points;
#line 16474
  n = ctx->EvalMap.Map1Vertex4.Order * 4U;
#line 16475
  break;
  case 3504: 
#line 16477
  data = ctx->EvalMap.Map2Color4.Points;
#line 16478
  n = (ctx->EvalMap.Map2Color4.Uorder * ctx->EvalMap.Map2Color4.Vorder) * 4U;
#line 16480
  break;
  case 3505: 
#line 16482
  data = ctx->EvalMap.Map2Index.Points;
#line 16483
  n = ctx->EvalMap.Map2Index.Uorder * ctx->EvalMap.Map2Index.Vorder;
#line 16485
  break;
  case 3506: 
#line 16487
  data = ctx->EvalMap.Map2Normal.Points;
#line 16488
  n = (ctx->EvalMap.Map2Normal.Uorder * ctx->EvalMap.Map2Normal.Vorder) * 3U;
#line 16490
  break;
  case 3507: 
#line 16492
  data = ctx->EvalMap.Map2Texture1.Points;
#line 16493
  n = ctx->EvalMap.Map2Texture1.Uorder * ctx->EvalMap.Map2Texture1.Vorder;
#line 16495
  break;
  case 3508: 
#line 16497
  data = ctx->EvalMap.Map2Texture2.Points;
#line 16498
  n = (ctx->EvalMap.Map2Texture2.Uorder * ctx->EvalMap.Map2Texture2.Vorder) * 2U;
#line 16500
  break;
  case 3509: 
#line 16502
  data = ctx->EvalMap.Map2Texture3.Points;
#line 16503
  n = (ctx->EvalMap.Map2Texture3.Uorder * ctx->EvalMap.Map2Texture3.Vorder) * 3U;
#line 16505
  break;
  case 3510: 
#line 16507
  data = ctx->EvalMap.Map2Texture4.Points;
#line 16508
  n = (ctx->EvalMap.Map2Texture4.Uorder * ctx->EvalMap.Map2Texture4.Vorder) * 4U;
#line 16510
  break;
  case 3511: 
#line 16512
  data = ctx->EvalMap.Map2Vertex3.Points;
#line 16513
  n = (ctx->EvalMap.Map2Vertex3.Uorder * ctx->EvalMap.Map2Vertex3.Vorder) * 3U;
#line 16515
  break;
  case 3512: 
#line 16517
  data = ctx->EvalMap.Map2Vertex4.Points;
#line 16518
  n = (ctx->EvalMap.Map2Vertex4.Uorder * ctx->EvalMap.Map2Vertex4.Vorder) * 4U;
#line 16520
  break;
  default: 
#line 16522
  gl_error(ctx, 1280, "glGetMapiv(target)");
  }
#line 16524
  if (data) {
#line 16525
    i = 0U;
#line 16525
    while (i < n) {
#line 16526
      if (*(data + i) < 0.0F) {
#line 16526
        *(v + i) = (int )(*(data + i) - 0.5F);
      } else {
#line 16526
        *(v + i) = (int )(*(data + i) + 0.5F);
      }
#line 16525
      i ++;
    }
  }
#line 16529
  break;
  case 2561: 
#line 16531
  switch (target) {
  case 3472: 
#line 16533
  *v = (int )ctx->EvalMap.Map1Color4.Order;
#line 16534
  break;
  case 3473: 
#line 16536
  *v = (int )ctx->EvalMap.Map1Index.Order;
#line 16537
  break;
  case 3474: 
#line 16539
  *v = (int )ctx->EvalMap.Map1Normal.Order;
#line 16540
  break;
  case 3475: 
#line 16542
  *v = (int )ctx->EvalMap.Map1Texture1.Order;
#line 16543
  break;
  case 3476: 
#line 16545
  *v = (int )ctx->EvalMap.Map1Texture2.Order;
#line 16546
  break;
  case 3477: 
#line 16548
  *v = (int )ctx->EvalMap.Map1Texture3.Order;
#line 16549
  break;
  case 3478: 
#line 16551
  *v = (int )ctx->EvalMap.Map1Texture4.Order;
#line 16552
  break;
  case 3479: 
#line 16554
  *v = (int )ctx->EvalMap.Map1Vertex3.Order;
#line 16555
  break;
  case 3480: 
#line 16557
  *v = (int )ctx->EvalMap.Map1Vertex4.Order;
#line 16558
  break;
  case 3504: 
#line 16560
  *(v + 0) = (int )ctx->EvalMap.Map2Color4.Uorder;
#line 16561
  *(v + 1) = (int )ctx->EvalMap.Map2Color4.Vorder;
#line 16562
  break;
  case 3505: 
#line 16564
  *(v + 0) = (int )ctx->EvalMap.Map2Index.Uorder;
#line 16565
  *(v + 1) = (int )ctx->EvalMap.Map2Index.Vorder;
#line 16566
  break;
  case 3506: 
#line 16568
  *(v + 0) = (int )ctx->EvalMap.Map2Normal.Uorder;
#line 16569
  *(v + 1) = (int )ctx->EvalMap.Map2Normal.Vorder;
#line 16570
  break;
  case 3507: 
#line 16572
  *(v + 0) = (int )ctx->EvalMap.Map2Texture1.Uorder;
#line 16573
  *(v + 1) = (int )ctx->EvalMap.Map2Texture1.Vorder;
#line 16574
  break;
  case 3508: 
#line 16576
  *(v + 0) = (int )ctx->EvalMap.Map2Texture2.Uorder;
#line 16577
  *(v + 1) = (int )ctx->EvalMap.Map2Texture2.Vorder;
#line 16578
  break;
  case 3509: 
#line 16580
  *(v + 0) = (int )ctx->EvalMap.Map2Texture3.Uorder;
#line 16581
  *(v + 1) = (int )ctx->EvalMap.Map2Texture3.Vorder;
#line 16582
  break;
  case 3510: 
#line 16584
  *(v + 0) = (int )ctx->EvalMap.Map2Texture4.Uorder;
#line 16585
  *(v + 1) = (int )ctx->EvalMap.Map2Texture4.Vorder;
#line 16586
  break;
  case 3511: 
#line 16588
  *(v + 0) = (int )ctx->EvalMap.Map2Vertex3.Uorder;
#line 16589
  *(v + 1) = (int )ctx->EvalMap.Map2Vertex3.Vorder;
#line 16590
  break;
  case 3512: 
#line 16592
  *(v + 0) = (int )ctx->EvalMap.Map2Vertex4.Uorder;
#line 16593
  *(v + 1) = (int )ctx->EvalMap.Map2Vertex4.Vorder;
#line 16594
  break;
  default: 
#line 16596
  gl_error(ctx, 1280, "glGetMapiv(target)");
  }
#line 16598
  break;
  case 2562: 
#line 16600
  switch (target) {
  case 3472: 
#line 16602
  if (ctx->EvalMap.Map1Color4.u1 < 0.0F) {
#line 16602
    *(v + 0) = (int )(ctx->EvalMap.Map1Color4.u1 - 0.5F);
  } else {
#line 16602
    *(v + 0) = (int )(ctx->EvalMap.Map1Color4.u1 + 0.5F);
  }
#line 16603
  if (ctx->EvalMap.Map1Color4.u2 < 0.0F) {
#line 16603
    *(v + 1) = (int )(ctx->EvalMap.Map1Color4.u2 - 0.5F);
  } else {
#line 16603
    *(v + 1) = (int )(ctx->EvalMap.Map1Color4.u2 + 0.5F);
  }
#line 16604
  break;
  case 3473: 
#line 16606
  if (ctx->EvalMap.Map1Index.u1 < 0.0F) {
#line 16606
    *(v + 0) = (int )(ctx->EvalMap.Map1Index.u1 - 0.5F);
  } else {
#line 16606
    *(v + 0) = (int )(ctx->EvalMap.Map1Index.u1 + 0.5F);
  }
#line 16607
  if (ctx->EvalMap.Map1Index.u2 < 0.0F) {
#line 16607
    *(v + 1) = (int )(ctx->EvalMap.Map1Index.u2 - 0.5F);
  } else {
#line 16607
    *(v + 1) = (int )(ctx->EvalMap.Map1Index.u2 + 0.5F);
  }
#line 16608
  break;
  case 3474: 
#line 16610
  if (ctx->EvalMap.Map1Normal.u1 < 0.0F) {
#line 16610
    *(v + 0) = (int )(ctx->EvalMap.Map1Normal.u1 - 0.5F);
  } else {
#line 16610
    *(v + 0) = (int )(ctx->EvalMap.Map1Normal.u1 + 0.5F);
  }
#line 16611
  if (ctx->EvalMap.Map1Normal.u2 < 0.0F) {
#line 16611
    *(v + 1) = (int )(ctx->EvalMap.Map1Normal.u2 - 0.5F);
  } else {
#line 16611
    *(v + 1) = (int )(ctx->EvalMap.Map1Normal.u2 + 0.5F);
  }
#line 16612
  break;
  case 3475: 
#line 16614
  if (ctx->EvalMap.Map1Texture1.u1 < 0.0F) {
#line 16614
    *(v + 0) = (int )(ctx->EvalMap.Map1Texture1.u1 - 0.5F);
  } else {
#line 16614
    *(v + 0) = (int )(ctx->EvalMap.Map1Texture1.u1 + 0.5F);
  }
#line 16615
  if (ctx->EvalMap.Map1Texture1.u2 < 0.0F) {
#line 16615
    *(v + 1) = (int )(ctx->EvalMap.Map1Texture1.u2 - 0.5F);
  } else {
#line 16615
    *(v + 1) = (int )(ctx->EvalMap.Map1Texture1.u2 + 0.5F);
  }
#line 16616
  break;
  case 3476: 
#line 16618
  if (ctx->EvalMap.Map1Texture2.u1 < 0.0F) {
#line 16618
    *(v + 0) = (int )(ctx->EvalMap.Map1Texture2.u1 - 0.5F);
  } else {
#line 16618
    *(v + 0) = (int )(ctx->EvalMap.Map1Texture2.u1 + 0.5F);
  }
#line 16619
  if (ctx->EvalMap.Map1Texture2.u2 < 0.0F) {
#line 16619
    *(v + 1) = (int )(ctx->EvalMap.Map1Texture2.u2 - 0.5F);
  } else {
#line 16619
    *(v + 1) = (int )(ctx->EvalMap.Map1Texture2.u2 + 0.5F);
  }
#line 16620
  break;
  case 3477: 
#line 16622
  if (ctx->EvalMap.Map1Texture3.u1 < 0.0F) {
#line 16622
    *(v + 0) = (int )(ctx->EvalMap.Map1Texture3.u1 - 0.5F);
  } else {
#line 16622
    *(v + 0) = (int )(ctx->EvalMap.Map1Texture3.u1 + 0.5F);
  }
#line 16623
  if (ctx->EvalMap.Map1Texture3.u2 < 0.0F) {
#line 16623
    *(v + 1) = (int )(ctx->EvalMap.Map1Texture3.u2 - 0.5F);
  } else {
#line 16623
    *(v + 1) = (int )(ctx->EvalMap.Map1Texture3.u2 + 0.5F);
  }
#line 16624
  break;
  case 3478: 
#line 16626
  if (ctx->EvalMap.Map1Texture4.u1 < 0.0F) {
#line 16626
    *(v + 0) = (int )(ctx->EvalMap.Map1Texture4.u1 - 0.5F);
  } else {
#line 16626
    *(v + 0) = (int )(ctx->EvalMap.Map1Texture4.u1 + 0.5F);
  }
#line 16627
  if (ctx->EvalMap.Map1Texture4.u2 < 0.0F) {
#line 16627
    *(v + 1) = (int )(ctx->EvalMap.Map1Texture4.u2 - 0.5F);
  } else {
#line 16627
    *(v + 1) = (int )(ctx->EvalMap.Map1Texture4.u2 + 0.5F);
  }
#line 16628
  break;
  case 3479: 
#line 16630
  if (ctx->EvalMap.Map1Vertex3.u1 < 0.0F) {
#line 16630
    *(v + 0) = (int )(ctx->EvalMap.Map1Vertex3.u1 - 0.5F);
  } else {
#line 16630
    *(v + 0) = (int )(ctx->EvalMap.Map1Vertex3.u1 + 0.5F);
  }
#line 16631
  if (ctx->EvalMap.Map1Vertex3.u2 < 0.0F) {
#line 16631
    *(v + 1) = (int )(ctx->EvalMap.Map1Vertex3.u2 - 0.5F);
  } else {
#line 16631
    *(v + 1) = (int )(ctx->EvalMap.Map1Vertex3.u2 + 0.5F);
  }
#line 16632
  break;
  case 3480: 
#line 16634
  if (ctx->EvalMap.Map1Vertex4.u1 < 0.0F) {
#line 16634
    *(v + 0) = (int )(ctx->EvalMap.Map1Vertex4.u1 - 0.5F);
  } else {
#line 16634
    *(v + 0) = (int )(ctx->EvalMap.Map1Vertex4.u1 + 0.5F);
  }
#line 16635
  if (ctx->EvalMap.Map1Vertex4.u2 < 0.0F) {
#line 16635
    *(v + 1) = (int )(ctx->EvalMap.Map1Vertex4.u2 - 0.5F);
  } else {
#line 16635
    *(v + 1) = (int )(ctx->EvalMap.Map1Vertex4.u2 + 0.5F);
  }
#line 16636
  break;
  case 3504: 
#line 16638
  if (ctx->EvalMap.Map2Color4.u1 < 0.0F) {
#line 16638
    *(v + 0) = (int )(ctx->EvalMap.Map2Color4.u1 - 0.5F);
  } else {
#line 16638
    *(v + 0) = (int )(ctx->EvalMap.Map2Color4.u1 + 0.5F);
  }
#line 16639
  if (ctx->EvalMap.Map2Color4.u2 < 0.0F) {
#line 16639
    *(v + 1) = (int )(ctx->EvalMap.Map2Color4.u2 - 0.5F);
  } else {
#line 16639
    *(v + 1) = (int )(ctx->EvalMap.Map2Color4.u2 + 0.5F);
  }
#line 16640
  if (ctx->EvalMap.Map2Color4.v1 < 0.0F) {
#line 16640
    *(v + 2) = (int )(ctx->EvalMap.Map2Color4.v1 - 0.5F);
  } else {
#line 16640
    *(v + 2) = (int )(ctx->EvalMap.Map2Color4.v1 + 0.5F);
  }
#line 16641
  if (ctx->EvalMap.Map2Color4.v2 < 0.0F) {
#line 16641
    *(v + 3) = (int )(ctx->EvalMap.Map2Color4.v2 - 0.5F);
  } else {
#line 16641
    *(v + 3) = (int )(ctx->EvalMap.Map2Color4.v2 + 0.5F);
  }
#line 16642
  break;
  case 3505: 
#line 16644
  if (ctx->EvalMap.Map2Index.u1 < 0.0F) {
#line 16644
    *(v + 0) = (int )(ctx->EvalMap.Map2Index.u1 - 0.5F);
  } else {
#line 16644
    *(v + 0) = (int )(ctx->EvalMap.Map2Index.u1 + 0.5F);
  }
#line 16645
  if (ctx->EvalMap.Map2Index.u2 < 0.0F) {
#line 16645
    *(v + 1) = (int )(ctx->EvalMap.Map2Index.u2 - 0.5F);
  } else {
#line 16645
    *(v + 1) = (int )(ctx->EvalMap.Map2Index.u2 + 0.5F);
  }
#line 16646
  if (ctx->EvalMap.Map2Index.v1 < 0.0F) {
#line 16646
    *(v + 2) = (int )(ctx->EvalMap.Map2Index.v1 - 0.5F);
  } else {
#line 16646
    *(v + 2) = (int )(ctx->EvalMap.Map2Index.v1 + 0.5F);
  }
#line 16647
  if (ctx->EvalMap.Map2Index.v2 < 0.0F) {
#line 16647
    *(v + 3) = (int )(ctx->EvalMap.Map2Index.v2 - 0.5F);
  } else {
#line 16647
    *(v + 3) = (int )(ctx->EvalMap.Map2Index.v2 + 0.5F);
  }
#line 16648
  break;
  case 3506: 
#line 16650
  if (ctx->EvalMap.Map2Normal.u1 < 0.0F) {
#line 16650
    *(v + 0) = (int )(ctx->EvalMap.Map2Normal.u1 - 0.5F);
  } else {
#line 16650
    *(v + 0) = (int )(ctx->EvalMap.Map2Normal.u1 + 0.5F);
  }
#line 16651
  if (ctx->EvalMap.Map2Normal.u2 < 0.0F) {
#line 16651
    *(v + 1) = (int )(ctx->EvalMap.Map2Normal.u2 - 0.5F);
  } else {
#line 16651
    *(v + 1) = (int )(ctx->EvalMap.Map2Normal.u2 + 0.5F);
  }
#line 16652
  if (ctx->EvalMap.Map2Normal.v1 < 0.0F) {
#line 16652
    *(v + 2) = (int )(ctx->EvalMap.Map2Normal.v1 - 0.5F);
  } else {
#line 16652
    *(v + 2) = (int )(ctx->EvalMap.Map2Normal.v1 + 0.5F);
  }
#line 16653
  if (ctx->EvalMap.Map2Normal.v2 < 0.0F) {
#line 16653
    *(v + 3) = (int )(ctx->EvalMap.Map2Normal.v2 - 0.5F);
  } else {
#line 16653
    *(v + 3) = (int )(ctx->EvalMap.Map2Normal.v2 + 0.5F);
  }
#line 16654
  break;
  case 3507: 
#line 16656
  if (ctx->EvalMap.Map2Texture1.u1 < 0.0F) {
#line 16656
    *(v + 0) = (int )(ctx->EvalMap.Map2Texture1.u1 - 0.5F);
  } else {
#line 16656
    *(v + 0) = (int )(ctx->EvalMap.Map2Texture1.u1 + 0.5F);
  }
#line 16657
  if (ctx->EvalMap.Map2Texture1.u2 < 0.0F) {
#line 16657
    *(v + 1) = (int )(ctx->EvalMap.Map2Texture1.u2 - 0.5F);
  } else {
#line 16657
    *(v + 1) = (int )(ctx->EvalMap.Map2Texture1.u2 + 0.5F);
  }
#line 16658
  if (ctx->EvalMap.Map2Texture1.v1 < 0.0F) {
#line 16658
    *(v + 2) = (int )(ctx->EvalMap.Map2Texture1.v1 - 0.5F);
  } else {
#line 16658
    *(v + 2) = (int )(ctx->EvalMap.Map2Texture1.v1 + 0.5F);
  }
#line 16659
  if (ctx->EvalMap.Map2Texture1.v2 < 0.0F) {
#line 16659
    *(v + 3) = (int )(ctx->EvalMap.Map2Texture1.v2 - 0.5F);
  } else {
#line 16659
    *(v + 3) = (int )(ctx->EvalMap.Map2Texture1.v2 + 0.5F);
  }
#line 16660
  break;
  case 3508: 
#line 16662
  if (ctx->EvalMap.Map2Texture2.u1 < 0.0F) {
#line 16662
    *(v + 0) = (int )(ctx->EvalMap.Map2Texture2.u1 - 0.5F);
  } else {
#line 16662
    *(v + 0) = (int )(ctx->EvalMap.Map2Texture2.u1 + 0.5F);
  }
#line 16663
  if (ctx->EvalMap.Map2Texture2.u2 < 0.0F) {
#line 16663
    *(v + 1) = (int )(ctx->EvalMap.Map2Texture2.u2 - 0.5F);
  } else {
#line 16663
    *(v + 1) = (int )(ctx->EvalMap.Map2Texture2.u2 + 0.5F);
  }
#line 16664
  if (ctx->EvalMap.Map2Texture2.v1 < 0.0F) {
#line 16664
    *(v + 2) = (int )(ctx->EvalMap.Map2Texture2.v1 - 0.5F);
  } else {
#line 16664
    *(v + 2) = (int )(ctx->EvalMap.Map2Texture2.v1 + 0.5F);
  }
#line 16665
  if (ctx->EvalMap.Map2Texture2.v2 < 0.0F) {
#line 16665
    *(v + 3) = (int )(ctx->EvalMap.Map2Texture2.v2 - 0.5F);
  } else {
#line 16665
    *(v + 3) = (int )(ctx->EvalMap.Map2Texture2.v2 + 0.5F);
  }
#line 16666
  break;
  case 3509: 
#line 16668
  if (ctx->EvalMap.Map2Texture3.u1 < 0.0F) {
#line 16668
    *(v + 0) = (int )(ctx->EvalMap.Map2Texture3.u1 - 0.5F);
  } else {
#line 16668
    *(v + 0) = (int )(ctx->EvalMap.Map2Texture3.u1 + 0.5F);
  }
#line 16669
  if (ctx->EvalMap.Map2Texture3.u2 < 0.0F) {
#line 16669
    *(v + 1) = (int )(ctx->EvalMap.Map2Texture3.u2 - 0.5F);
  } else {
#line 16669
    *(v + 1) = (int )(ctx->EvalMap.Map2Texture3.u2 + 0.5F);
  }
#line 16670
  if (ctx->EvalMap.Map2Texture3.v1 < 0.0F) {
#line 16670
    *(v + 2) = (int )(ctx->EvalMap.Map2Texture3.v1 - 0.5F);
  } else {
#line 16670
    *(v + 2) = (int )(ctx->EvalMap.Map2Texture3.v1 + 0.5F);
  }
#line 16671
  if (ctx->EvalMap.Map2Texture3.v2 < 0.0F) {
#line 16671
    *(v + 3) = (int )(ctx->EvalMap.Map2Texture3.v2 - 0.5F);
  } else {
#line 16671
    *(v + 3) = (int )(ctx->EvalMap.Map2Texture3.v2 + 0.5F);
  }
#line 16672
  break;
  case 3510: 
#line 16674
  if (ctx->EvalMap.Map2Texture4.u1 < 0.0F) {
#line 16674
    *(v + 0) = (int )(ctx->EvalMap.Map2Texture4.u1 - 0.5F);
  } else {
#line 16674
    *(v + 0) = (int )(ctx->EvalMap.Map2Texture4.u1 + 0.5F);
  }
#line 16675
  if (ctx->EvalMap.Map2Texture4.u2 < 0.0F) {
#line 16675
    *(v + 1) = (int )(ctx->EvalMap.Map2Texture4.u2 - 0.5F);
  } else {
#line 16675
    *(v + 1) = (int )(ctx->EvalMap.Map2Texture4.u2 + 0.5F);
  }
#line 16676
  if (ctx->EvalMap.Map2Texture4.v1 < 0.0F) {
#line 16676
    *(v + 2) = (int )(ctx->EvalMap.Map2Texture4.v1 - 0.5F);
  } else {
#line 16676
    *(v + 2) = (int )(ctx->EvalMap.Map2Texture4.v1 + 0.5F);
  }
#line 16677
  if (ctx->EvalMap.Map2Texture4.v2 < 0.0F) {
#line 16677
    *(v + 3) = (int )(ctx->EvalMap.Map2Texture4.v2 - 0.5F);
  } else {
#line 16677
    *(v + 3) = (int )(ctx->EvalMap.Map2Texture4.v2 + 0.5F);
  }
#line 16678
  break;
  case 3511: 
#line 16680
  if (ctx->EvalMap.Map2Vertex3.u1 < 0.0F) {
#line 16680
    *(v + 0) = (int )(ctx->EvalMap.Map2Vertex3.u1 - 0.5F);
  } else {
#line 16680
    *(v + 0) = (int )(ctx->EvalMap.Map2Vertex3.u1 + 0.5F);
  }
#line 16681
  if (ctx->EvalMap.Map2Vertex3.u2 < 0.0F) {
#line 16681
    *(v + 1) = (int )(ctx->EvalMap.Map2Vertex3.u2 - 0.5F);
  } else {
#line 16681
    *(v + 1) = (int )(ctx->EvalMap.Map2Vertex3.u2 + 0.5F);
  }
#line 16682
  if (ctx->EvalMap.Map2Vertex3.v1 < 0.0F) {
#line 16682
    *(v + 2) = (int )(ctx->EvalMap.Map2Vertex3.v1 - 0.5F);
  } else {
#line 16682
    *(v + 2) = (int )(ctx->EvalMap.Map2Vertex3.v1 + 0.5F);
  }
#line 16683
  if (ctx->EvalMap.Map2Vertex3.v2 < 0.0F) {
#line 16683
    *(v + 3) = (int )(ctx->EvalMap.Map2Vertex3.v2 - 0.5F);
  } else {
#line 16683
    *(v + 3) = (int )(ctx->EvalMap.Map2Vertex3.v2 + 0.5F);
  }
#line 16684
  break;
  case 3512: 
#line 16686
  if (ctx->EvalMap.Map2Vertex4.u1 < 0.0F) {
#line 16686
    *(v + 0) = (int )(ctx->EvalMap.Map2Vertex4.u1 - 0.5F);
  } else {
#line 16686
    *(v + 0) = (int )(ctx->EvalMap.Map2Vertex4.u1 + 0.5F);
  }
#line 16687
  if (ctx->EvalMap.Map2Vertex4.u2 < 0.0F) {
#line 16687
    *(v + 1) = (int )(ctx->EvalMap.Map2Vertex4.u2 - 0.5F);
  } else {
#line 16687
    *(v + 1) = (int )(ctx->EvalMap.Map2Vertex4.u2 + 0.5F);
  }
#line 16688
  if (ctx->EvalMap.Map2Vertex4.v1 < 0.0F) {
#line 16688
    *(v + 2) = (int )(ctx->EvalMap.Map2Vertex4.v1 - 0.5F);
  } else {
#line 16688
    *(v + 2) = (int )(ctx->EvalMap.Map2Vertex4.v1 + 0.5F);
  }
#line 16689
  if (ctx->EvalMap.Map2Vertex4.v2 < 0.0F) {
#line 16689
    *(v + 3) = (int )(ctx->EvalMap.Map2Vertex4.v2 - 0.5F);
  } else {
#line 16689
    *(v + 3) = (int )(ctx->EvalMap.Map2Vertex4.v2 + 0.5F);
  }
#line 16690
  break;
  default: 
#line 16692
  gl_error(ctx, 1280, "glGetMapiv(target)");
  }
#line 16694
  break;
  default: 
#line 16696
  gl_error(ctx, 1280, "glGetMapiv(query)");
  }
#line 16698
  return;
}
}
#line 16790
void gl_eval_vertex(GLcontext *ctx , float const   *vertex , float const   *normal ,
                    GLubyte const   *color , GLuint index___0 , float const   *texcoord ) ;
#line 16699 "D:/a/test/177.c"
void gl_EvalCoord1f(GLcontext *ctx , float u ) 
{ float vertex[4] ;
  float normal[3] ;
  float fcolor[4] ;
  GLubyte icolor[4] ;
  GLubyte *colorptr ;
  float texcoord[4] ;
  GLuint index___0 ;
  register float uu ;
  struct gl_1d_map *map ;
  struct gl_1d_map *map___0 ;
  struct gl_1d_map *map___1 ;
  float findex ;
  struct gl_1d_map *map___2 ;
  GLubyte col[4] ;
  struct gl_1d_map *map___3 ;
  struct gl_1d_map *map___4 ;
  struct gl_1d_map *map___5 ;
  struct gl_1d_map *map___6 ;
  struct gl_1d_map *map___7 ;

  {
#line 16709
  if (ctx->Eval.Map1Vertex4) {
#line 16711
    map = & ctx->EvalMap.Map1Vertex4;
#line 16712
    uu = (u - map->u1) / (map->u2 - map->u1);
#line 16713
    horner_bezier_curve(map->Points, vertex, uu, 4U, map->Order);
  } else {
#line 16715
    if (ctx->Eval.Map1Vertex3) {
#line 16717
      map___0 = & ctx->EvalMap.Map1Vertex3;
#line 16718
      uu = (u - map___0->u1) / (map___0->u2 - map___0->u1);
#line 16719
      horner_bezier_curve(map___0->Points, vertex, uu, 3U, map___0->Order);
#line 16720
      vertex[3] = (float )1.0;
    }
  }
#line 16722
  if (ctx->Eval.Map1Index) {
#line 16724
    map___1 = & ctx->EvalMap.Map1Index;
#line 16726
    uu = (u - map___1->u1) / (map___1->u2 - map___1->u1);
#line 16727
    horner_bezier_curve(map___1->Points, & findex, uu, 1U, map___1->Order);
#line 16728
    index___0 = (unsigned int )((int )findex);
  } else {
#line 16731
    index___0 = ctx->Current.Index;
  }
#line 16733
  if (ctx->Eval.Map1Color4) {
#line 16734
    map___2 = & ctx->EvalMap.Map1Color4;
#line 16735
    uu = (u - map___2->u1) / (map___2->u2 - map___2->u1);
#line 16736
    horner_bezier_curve(map___2->Points, fcolor, uu, 4U, map___2->Order);
#line 16737
    icolor[0] = (unsigned char )((int )(fcolor[0] * (ctx->Visual)->RedScale));
#line 16738
    icolor[1] = (unsigned char )((int )(fcolor[1] * (ctx->Visual)->GreenScale));
#line 16739
    icolor[2] = (unsigned char )((int )(fcolor[2] * (ctx->Visual)->BlueScale));
#line 16740
    icolor[3] = (unsigned char )((int )(fcolor[3] * (ctx->Visual)->AlphaScale));
#line 16741
    colorptr = icolor;
  } else {
#line 16745
    col[0] = ctx->Current.ByteColor[0];
#line 16745
    col[1] = ctx->Current.ByteColor[1];
#line 16745
    col[2] = ctx->Current.ByteColor[2];
#line 16745
    col[3] = ctx->Current.ByteColor[3];
#line 16746
    colorptr = col;
  }
#line 16748
  if (ctx->Eval.Map1Normal) {
#line 16749
    map___3 = & ctx->EvalMap.Map1Normal;
#line 16750
    uu = (u - map___3->u1) / (map___3->u2 - map___3->u1);
#line 16751
    horner_bezier_curve(map___3->Points, normal, uu, 3U, map___3->Order);
  } else {
#line 16754
    normal[0] = ctx->Current.Normal[0];
#line 16755
    normal[1] = ctx->Current.Normal[1];
#line 16756
    normal[2] = ctx->Current.Normal[2];
  }
#line 16758
  if (ctx->Eval.Map1TextureCoord4) {
#line 16759
    map___4 = & ctx->EvalMap.Map1Texture4;
#line 16760
    uu = (u - map___4->u1) / (map___4->u2 - map___4->u1);
#line 16761
    horner_bezier_curve(map___4->Points, texcoord, uu, 4U, map___4->Order);
  } else {
#line 16763
    if (ctx->Eval.Map1TextureCoord3) {
#line 16764
      map___5 = & ctx->EvalMap.Map1Texture3;
#line 16765
      uu = (u - map___5->u1) / (map___5->u2 - map___5->u1);
#line 16766
      horner_bezier_curve(map___5->Points, texcoord, uu, 3U, map___5->Order);
#line 16767
      texcoord[3] = (float )1.0;
    } else {
#line 16769
      if (ctx->Eval.Map1TextureCoord2) {
#line 16770
        map___6 = & ctx->EvalMap.Map1Texture2;
#line 16771
        uu = (u - map___6->u1) / (map___6->u2 - map___6->u1);
#line 16772
        horner_bezier_curve(map___6->Points, texcoord, uu, 2U, map___6->Order);
#line 16773
        texcoord[2] = (float )0.0;
#line 16774
        texcoord[3] = (float )1.0;
      } else {
#line 16776
        if (ctx->Eval.Map1TextureCoord1) {
#line 16777
          map___7 = & ctx->EvalMap.Map1Texture1;
#line 16778
          uu = (u - map___7->u1) / (map___7->u2 - map___7->u1);
#line 16779
          horner_bezier_curve(map___7->Points, texcoord, uu, 1U, map___7->Order);
#line 16780
          texcoord[1] = (float )0.0;
#line 16781
          texcoord[2] = (float )0.0;
#line 16782
          texcoord[3] = (float )1.0;
        } else {
#line 16785
          texcoord[0] = ctx->Current.TexCoord[0];
#line 16786
          texcoord[1] = ctx->Current.TexCoord[1];
#line 16787
          texcoord[2] = ctx->Current.TexCoord[2];
#line 16788
          texcoord[3] = ctx->Current.TexCoord[3];
        }
      }
    }
  }
#line 16790
  gl_eval_vertex(ctx, vertex, normal, colorptr, index___0, texcoord);
#line 16791
  return;
}
}
#line 16815
extern int ( /* missing proto */  NORMALIZE_3FV)(float normal[3]) ;
#line 16792 "D:/a/test/177.c"
void gl_EvalCoord2f(GLcontext *ctx , float u , float v ) 
{ float vertex[4] ;
  float normal[3] ;
  float fcolor[4] ;
  GLubyte icolor[4] ;
  GLubyte *colorptr ;
  float texcoord[4] ;
  GLuint index___0 ;
  register float uu ;
  register float vv ;
  struct gl_2d_map *map ;
  float du[4] ;
  float dv[4] ;
  struct gl_2d_map *map___0 ;
  float du___0[3] ;
  float dv___0[3] ;
  float findex ;
  struct gl_2d_map *map___1 ;
  struct gl_2d_map *map___2 ;
  GLubyte col[4] ;
  struct gl_2d_map *map___3 ;
  struct gl_2d_map *map___4 ;
  struct gl_2d_map *map___5 ;
  struct gl_2d_map *map___6 ;
  struct gl_2d_map *map___7 ;

  {
#line 16806
  if (ctx->Eval.Map2Vertex4) {
#line 16807
    map = & ctx->EvalMap.Map2Vertex4;
#line 16808
    uu = (u - map->u1) / (map->u2 - map->u1);
#line 16809
    vv = (v - map->v1) / (map->v2 - map->v1);
#line 16810
    if (ctx->Eval.AutoNormal) {
#line 16812
      de_casteljau_surf(map->Points, vertex, du, dv, uu, vv, 4U, map->Uorder, map->Vorder);
#line 16814
      normal[0] = du[1] * dv[2] - du[2] * dv[1];
#line 16814
      normal[1] = du[2] * dv[0] - du[0] * dv[2];
#line 16814
      normal[2] = du[0] * dv[1] - du[1] * dv[0];
#line 16815
      NORMALIZE_3FV(normal);
    } else {
#line 16818
      horner_bezier_surf(map->Points, vertex, uu, vv, 4U, map->Uorder, map->Vorder);
    }
  } else {
#line 16822
    if (ctx->Eval.Map2Vertex3) {
#line 16823
      map___0 = & ctx->EvalMap.Map2Vertex3;
#line 16824
      uu = (u - map___0->u1) / (map___0->u2 - map___0->u1);
#line 16825
      vv = (v - map___0->v1) / (map___0->v2 - map___0->v1);
#line 16826
      if (ctx->Eval.AutoNormal) {
#line 16828
        de_casteljau_surf(map___0->Points, vertex, du___0, dv___0, uu, vv, 3U, map___0->Uorder,
                          map___0->Vorder);
#line 16830
        normal[0] = du___0[1] * dv___0[2] - du___0[2] * dv___0[1];
#line 16830
        normal[1] = du___0[2] * dv___0[0] - du___0[0] * dv___0[2];
#line 16830
        normal[2] = du___0[0] * dv___0[1] - du___0[1] * dv___0[0];
#line 16831
        NORMALIZE_3FV(normal);
      } else {
#line 16834
        horner_bezier_surf(map___0->Points, vertex, uu, vv, 3U, map___0->Uorder, map___0->Vorder);
      }
#line 16837
      vertex[3] = (float )1.0;
    }
  }
#line 16840
  if (ctx->Eval.Map2Index) {
#line 16842
    map___1 = & ctx->EvalMap.Map2Index;
#line 16843
    uu = (u - map___1->u1) / (map___1->u2 - map___1->u1);
#line 16844
    vv = (v - map___1->v1) / (map___1->v2 - map___1->v1);
#line 16845
    horner_bezier_surf(map___1->Points, & findex, uu, vv, 1U, map___1->Uorder, map___1->Vorder);
#line 16847
    index___0 = (unsigned int )((int )findex);
  } else {
#line 16850
    index___0 = ctx->Current.Index;
  }
#line 16852
  if (ctx->Eval.Map2Color4) {
#line 16853
    map___2 = & ctx->EvalMap.Map2Color4;
#line 16854
    uu = (u - map___2->u1) / (map___2->u2 - map___2->u1);
#line 16855
    vv = (v - map___2->v1) / (map___2->v2 - map___2->v1);
#line 16856
    horner_bezier_surf(map___2->Points, fcolor, uu, vv, 4U, map___2->Uorder, map___2->Vorder);
#line 16858
    icolor[0] = (unsigned char )((int )(fcolor[0] * (ctx->Visual)->RedScale));
#line 16859
    icolor[1] = (unsigned char )((int )(fcolor[1] * (ctx->Visual)->GreenScale));
#line 16860
    icolor[2] = (unsigned char )((int )(fcolor[2] * (ctx->Visual)->BlueScale));
#line 16861
    icolor[3] = (unsigned char )((int )(fcolor[3] * (ctx->Visual)->AlphaScale));
#line 16862
    colorptr = icolor;
  } else {
#line 16866
    col[0] = ctx->Current.ByteColor[0];
#line 16866
    col[1] = ctx->Current.ByteColor[1];
#line 16866
    col[2] = ctx->Current.ByteColor[2];
#line 16866
    col[3] = ctx->Current.ByteColor[3];
#line 16867
    colorptr = col;
  }
#line 16869
  if (! ctx->Eval.AutoNormal) {
    goto _L;
  } else {
#line 16869
    if (! ctx->Eval.Map2Vertex3) {
#line 16869
      if (! ctx->Eval.Map2Vertex4) {
        _L: /* CIL Label */ 
#line 16871
        if (ctx->Eval.Map2Normal) {
#line 16872
          map___3 = & ctx->EvalMap.Map2Normal;
#line 16873
          uu = (u - map___3->u1) / (map___3->u2 - map___3->u1);
#line 16874
          vv = (v - map___3->v1) / (map___3->v2 - map___3->v1);
#line 16875
          horner_bezier_surf(map___3->Points, normal, uu, vv, 3U, map___3->Uorder,
                             map___3->Vorder);
        } else {
#line 16879
          normal[0] = ctx->Current.Normal[0];
#line 16880
          normal[1] = ctx->Current.Normal[1];
#line 16881
          normal[2] = ctx->Current.Normal[2];
        }
      }
    }
  }
#line 16884
  if (ctx->Eval.Map2TextureCoord4) {
#line 16885
    map___4 = & ctx->EvalMap.Map2Texture4;
#line 16886
    uu = (u - map___4->u1) / (map___4->u2 - map___4->u1);
#line 16887
    vv = (v - map___4->v1) / (map___4->v2 - map___4->v1);
#line 16888
    horner_bezier_surf(map___4->Points, texcoord, uu, vv, 4U, map___4->Uorder, map___4->Vorder);
  } else {
#line 16891
    if (ctx->Eval.Map2TextureCoord3) {
#line 16892
      map___5 = & ctx->EvalMap.Map2Texture3;
#line 16893
      uu = (u - map___5->u1) / (map___5->u2 - map___5->u1);
#line 16894
      vv = (v - map___5->v1) / (map___5->v2 - map___5->v1);
#line 16895
      horner_bezier_surf(map___5->Points, texcoord, uu, vv, 3U, map___5->Uorder, map___5->Vorder);
#line 16897
      texcoord[3] = (float )1.0;
    } else {
#line 16899
      if (ctx->Eval.Map2TextureCoord2) {
#line 16900
        map___6 = & ctx->EvalMap.Map2Texture2;
#line 16901
        uu = (u - map___6->u1) / (map___6->u2 - map___6->u1);
#line 16902
        vv = (v - map___6->v1) / (map___6->v2 - map___6->v1);
#line 16903
        horner_bezier_surf(map___6->Points, texcoord, uu, vv, 2U, map___6->Uorder,
                           map___6->Vorder);
#line 16905
        texcoord[2] = (float )0.0;
#line 16906
        texcoord[3] = (float )1.0;
      } else {
#line 16908
        if (ctx->Eval.Map2TextureCoord1) {
#line 16909
          map___7 = & ctx->EvalMap.Map2Texture1;
#line 16910
          uu = (u - map___7->u1) / (map___7->u2 - map___7->u1);
#line 16911
          vv = (v - map___7->v1) / (map___7->v2 - map___7->v1);
#line 16912
          horner_bezier_surf(map___7->Points, texcoord, uu, vv, 1U, map___7->Uorder,
                             map___7->Vorder);
#line 16914
          texcoord[1] = (float )0.0;
#line 16915
          texcoord[2] = (float )0.0;
#line 16916
          texcoord[3] = (float )1.0;
        } else {
#line 16920
          texcoord[0] = ctx->Current.TexCoord[0];
#line 16921
          texcoord[1] = ctx->Current.TexCoord[1];
#line 16922
          texcoord[2] = ctx->Current.TexCoord[2];
#line 16923
          texcoord[3] = ctx->Current.TexCoord[3];
        }
      }
    }
  }
#line 16925
  gl_eval_vertex(ctx, vertex, normal, colorptr, index___0, texcoord);
#line 16926
  return;
}
}
#line 16927 "D:/a/test/177.c"
void gl_MapGrid1f(GLcontext *ctx , GLint un , float u1 , float u2 ) 
{ 

  {
#line 16929
  if (ctx->Primitive != 6656) {
#line 16930
    gl_error(ctx, 1282, "glMapGrid1f");
#line 16931
    return;
  }
#line 16933
  if (un < 1) {
#line 16934
    gl_error(ctx, 1281, "glMapGrid1f");
#line 16935
    return;
  }
#line 16937
  ctx->Eval.MapGrid1un = (unsigned int )un;
#line 16938
  ctx->Eval.MapGrid1u1 = u1;
#line 16939
  ctx->Eval.MapGrid1u2 = u2;
#line 16940
  return;
}
}
#line 16941 "D:/a/test/177.c"
void gl_MapGrid2f(GLcontext *ctx , GLint un , float u1 , float u2 , GLint vn , float v1 ,
                  float v2 ) 
{ 

  {
#line 16944
  if (ctx->Primitive != 6656) {
#line 16945
    gl_error(ctx, 1282, "glMapGrid2f");
#line 16946
    return;
  }
#line 16948
  if (un < 1) {
#line 16949
    gl_error(ctx, 1281, "glMapGrid2f(un)");
#line 16950
    return;
  }
#line 16952
  if (vn < 1) {
#line 16953
    gl_error(ctx, 1281, "glMapGrid2f(vn)");
#line 16954
    return;
  }
#line 16956
  ctx->Eval.MapGrid2un = (unsigned int )un;
#line 16957
  ctx->Eval.MapGrid2u1 = u1;
#line 16958
  ctx->Eval.MapGrid2u2 = u2;
#line 16959
  ctx->Eval.MapGrid2vn = (unsigned int )vn;
#line 16960
  ctx->Eval.MapGrid2v1 = v1;
#line 16961
  ctx->Eval.MapGrid2v2 = v2;
#line 16962
  return;
}
}
#line 16963 "D:/a/test/177.c"
void gl_EvalPoint1(GLcontext *ctx , GLint i ) 
{ float u ;
  float du ;

  {
#line 16966
  if (i == 0) {
#line 16967
    u = ctx->Eval.MapGrid1u1;
  } else {
#line 16969
    if ((GLuint )i == ctx->Eval.MapGrid1un) {
#line 16970
      u = ctx->Eval.MapGrid1u2;
    } else {
#line 16973
      du = (ctx->Eval.MapGrid1u2 - ctx->Eval.MapGrid1u1) / (float )ctx->Eval.MapGrid1un;
#line 16975
      u = (float )i * du + ctx->Eval.MapGrid1u1;
    }
  }
#line 16977
  gl_EvalCoord1f(ctx, u);
#line 16978
  return;
}
}
#line 16979 "D:/a/test/177.c"
void gl_EvalPoint2(GLcontext *ctx , GLint i , GLint j ) 
{ float u ;
  float du ;
  float v ;
  float dv ;

  {
#line 16983
  if (i == 0) {
#line 16984
    u = ctx->Eval.MapGrid2u1;
  } else {
#line 16986
    if ((GLuint )i == ctx->Eval.MapGrid2un) {
#line 16987
      u = ctx->Eval.MapGrid2u2;
    } else {
#line 16990
      du = (ctx->Eval.MapGrid2u2 - ctx->Eval.MapGrid2u1) / (float )ctx->Eval.MapGrid2un;
#line 16992
      u = (float )i * du + ctx->Eval.MapGrid2u1;
    }
  }
#line 16994
  if (j == 0) {
#line 16995
    v = ctx->Eval.MapGrid2v1;
  } else {
#line 16997
    if ((GLuint )j == ctx->Eval.MapGrid2vn) {
#line 16998
      v = ctx->Eval.MapGrid2v2;
    } else {
#line 17001
      dv = (ctx->Eval.MapGrid2v2 - ctx->Eval.MapGrid2v1) / (float )ctx->Eval.MapGrid2vn;
#line 17003
      v = (float )j * dv + ctx->Eval.MapGrid2v1;
    }
  }
#line 17005
  gl_EvalCoord2f(ctx, u, v);
#line 17006
  return;
}
}
#line 17007 "D:/a/test/177.c"
void gl_EvalMesh1(GLcontext *ctx , GLenum mode , GLint i1 , GLint i2 ) 
{ GLint i ;
  float u ;
  float du ;
  GLenum prim ;

  {
#line 17012
  if (ctx->Primitive != 6656) {
#line 17013
    gl_error(ctx, 1282, "glEvalMesh1");
#line 17014
    return;
  }
#line 17016
  switch (mode) {
  case 6912: 
#line 17018
  prim = 0;
#line 17019
  break;
  case 6913: 
#line 17021
  prim = 3;
#line 17022
  break;
  default: 
#line 17024
  gl_error(ctx, 1280, "glEvalMesh1(mode)");
#line 17025
  return;
  }
#line 17027
  du = (ctx->Eval.MapGrid1u2 - ctx->Eval.MapGrid1u1) / (float )ctx->Eval.MapGrid1un;
#line 17029
  gl_Begin(ctx, prim);
#line 17030
  i = i1;
#line 17030
  while (i <= i2) {
#line 17031
    if (i == 0) {
#line 17032
      u = ctx->Eval.MapGrid1u1;
    } else {
#line 17034
      if ((GLuint )i == ctx->Eval.MapGrid1un) {
#line 17035
        u = ctx->Eval.MapGrid1u2;
      } else {
#line 17038
        u = (float )i * du + ctx->Eval.MapGrid1u1;
      }
    }
#line 17040
    gl_EvalCoord1f(ctx, u);
#line 17030
    i ++;
  }
#line 17042
  gl_End(ctx);
#line 17043
  return;
}
}
#line 17044 "D:/a/test/177.c"
void gl_EvalMesh2(GLcontext *ctx , GLenum mode , GLint i1 , GLint i2 , GLint j1___0 ,
                  GLint j2 ) 
{ GLint i ;
  GLint j ;
  float u ;
  float du ;
  float v ;
  float dv ;
  float v1 ;
  float v2 ;

  {
#line 17048
  if (ctx->Primitive != 6656) {
#line 17049
    gl_error(ctx, 1282, "glEvalMesh2");
#line 17050
    return;
  }
#line 17052
  du = (ctx->Eval.MapGrid2u2 - ctx->Eval.MapGrid2u1) / (float )ctx->Eval.MapGrid2un;
#line 17054
  dv = (ctx->Eval.MapGrid2v2 - ctx->Eval.MapGrid2v1) / (float )ctx->Eval.MapGrid2vn;
#line 17076
  switch (mode) {
  case 6912: 
#line 17078
  gl_Begin(ctx, 0);
#line 17079
  j = j1___0;
#line 17079
  while (j <= j2) {
#line 17080
    if (j == 0) {
#line 17080
      v = ctx->Eval.MapGrid2v1;
    } else {
#line 17080
      if ((GLuint )j == ctx->Eval.MapGrid2vn) {
#line 17080
        v = ctx->Eval.MapGrid2v2;
      } else {
#line 17080
        v = (float )j * dv + ctx->Eval.MapGrid2v1;
      }
    }
#line 17081
    i = i1;
#line 17081
    while (i <= i2) {
#line 17082
      if (i == 0) {
#line 17082
        u = ctx->Eval.MapGrid2u1;
      } else {
#line 17082
        if ((GLuint )i == ctx->Eval.MapGrid2un) {
#line 17082
          u = ctx->Eval.MapGrid2u2;
        } else {
#line 17082
          u = (float )i * du + ctx->Eval.MapGrid2u1;
        }
      }
#line 17083
      gl_EvalCoord2f(ctx, u, v);
#line 17081
      i ++;
    }
#line 17079
    j ++;
  }
#line 17086
  gl_End(ctx);
#line 17087
  break;
  case 6913: 
#line 17089
  j = j1___0;
#line 17089
  while (j <= j2) {
#line 17090
    if (j == 0) {
#line 17090
      v = ctx->Eval.MapGrid2v1;
    } else {
#line 17090
      if ((GLuint )j == ctx->Eval.MapGrid2vn) {
#line 17090
        v = ctx->Eval.MapGrid2v2;
      } else {
#line 17090
        v = (float )j * dv + ctx->Eval.MapGrid2v1;
      }
    }
#line 17091
    gl_Begin(ctx, 3);
#line 17092
    i = i1;
#line 17092
    while (i <= i2) {
#line 17093
      if (i == 0) {
#line 17093
        u = ctx->Eval.MapGrid2u1;
      } else {
#line 17093
        if ((GLuint )i == ctx->Eval.MapGrid2un) {
#line 17093
          u = ctx->Eval.MapGrid2u2;
        } else {
#line 17093
          u = (float )i * du + ctx->Eval.MapGrid2u1;
        }
      }
#line 17094
      gl_EvalCoord2f(ctx, u, v);
#line 17092
      i ++;
    }
#line 17096
    gl_End(ctx);
#line 17089
    j ++;
  }
#line 17098
  i = i1;
#line 17098
  while (i <= i2) {
#line 17099
    if (i == 0) {
#line 17099
      u = ctx->Eval.MapGrid2u1;
    } else {
#line 17099
      if ((GLuint )i == ctx->Eval.MapGrid2un) {
#line 17099
        u = ctx->Eval.MapGrid2u2;
      } else {
#line 17099
        u = (float )i * du + ctx->Eval.MapGrid2u1;
      }
    }
#line 17100
    gl_Begin(ctx, 3);
#line 17101
    j = j1___0;
#line 17101
    while (j <= j2) {
#line 17102
      if (j == 0) {
#line 17102
        v = ctx->Eval.MapGrid2v1;
      } else {
#line 17102
        if ((GLuint )j == ctx->Eval.MapGrid2vn) {
#line 17102
          v = ctx->Eval.MapGrid2v2;
        } else {
#line 17102
          v = (float )j * dv + ctx->Eval.MapGrid2v1;
        }
      }
#line 17103
      gl_EvalCoord2f(ctx, u, v);
#line 17101
      j ++;
    }
#line 17105
    gl_End(ctx);
#line 17098
    i ++;
  }
#line 17107
  break;
  case 6914: 
#line 17109
  j = j1___0;
#line 17109
  while (j < j2) {
#line 17112
    gl_Begin(ctx, 5);
#line 17113
    if (j == 0) {
#line 17113
      v1 = ctx->Eval.MapGrid2v1;
    } else {
#line 17113
      if ((GLuint )j == ctx->Eval.MapGrid2vn) {
#line 17113
        v1 = ctx->Eval.MapGrid2v2;
      } else {
#line 17113
        v1 = (float )j * dv + ctx->Eval.MapGrid2v1;
      }
    }
#line 17114
    if (j + 1 == 0) {
#line 17114
      v2 = ctx->Eval.MapGrid2v1;
    } else {
#line 17114
      if ((GLuint )(j + 1) == ctx->Eval.MapGrid2vn) {
#line 17114
        v2 = ctx->Eval.MapGrid2v2;
      } else {
#line 17114
        v2 = (float )(j + 1) * dv + ctx->Eval.MapGrid2v1;
      }
    }
#line 17115
    i = i1;
#line 17115
    while (i <= i2) {
#line 17116
      if (i == 0) {
#line 17116
        u = ctx->Eval.MapGrid2u1;
      } else {
#line 17116
        if ((GLuint )i == ctx->Eval.MapGrid2un) {
#line 17116
          u = ctx->Eval.MapGrid2u2;
        } else {
#line 17116
          u = (float )i * du + ctx->Eval.MapGrid2u1;
        }
      }
#line 17117
      gl_EvalCoord2f(ctx, u, v1);
#line 17118
      gl_EvalCoord2f(ctx, u, v2);
#line 17115
      i ++;
    }
#line 17120
    gl_End(ctx);
#line 17109
    j ++;
  }
#line 17122
  break;
  default: 
#line 17124
  gl_error(ctx, 1280, "glEvalMesh2(mode)");
#line 17125
  return;
  }
#line 17129
  return;
}
}
#line 17140 "D:/a/test/177.c"
void gl_FeedbackBuffer(GLcontext *ctx , GLsizei size , GLenum type , float *buffer ) 
{ int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 17143
  if (ctx->RenderMode == 7169) {
#line 17144
    gl_error(ctx, 1282, "glFeedbackBuffer");
#line 17145
    return;
  } else {
#line 17143
    if (ctx->Primitive != 6656) {
#line 17144
      gl_error(ctx, 1282, "glFeedbackBuffer");
#line 17145
      return;
    }
  }
#line 17147
  if (size < 0) {
#line 17148
    gl_error(ctx, 1281, "glFeedbackBuffer(size<0)");
#line 17149
    return;
  }
#line 17151
  if (! buffer) {
#line 17152
    gl_error(ctx, 1281, "glFeedbackBuffer(buffer==NULL)");
#line 17153
    ctx->Feedback.BufferSize = 0U;
#line 17154
    return;
  }
#line 17156
  switch (type) {
  case 1536: 
#line 17158
  ctx->Feedback.Mask = 0U;
#line 17159
  ctx->Feedback.Type = type;
#line 17160
  break;
  case 1537: 
#line 17162
  ctx->Feedback.Mask = 1U;
#line 17163
  ctx->Feedback.Type = type;
#line 17164
  break;
  case 1538: 
#line 17166
  if ((ctx->Visual)->RGBAflag) {
#line 17166
    tmp___0 = 8;
  } else {
#line 17166
    tmp___0 = 4;
  }
#line 17166
  ctx->Feedback.Mask = (unsigned int )(1 | tmp___0);
#line 17168
  ctx->Feedback.Type = type;
#line 17169
  break;
  case 1539: 
#line 17171
  if ((ctx->Visual)->RGBAflag) {
#line 17171
    tmp___1 = 8;
  } else {
#line 17171
    tmp___1 = 4;
  }
#line 17171
  ctx->Feedback.Mask = (unsigned int )((1 | tmp___1) | 16);
#line 17174
  ctx->Feedback.Type = type;
#line 17175
  break;
  case 1540: 
#line 17177
  if ((ctx->Visual)->RGBAflag) {
#line 17177
    tmp___2 = 8;
  } else {
#line 17177
    tmp___2 = 4;
  }
#line 17177
  ctx->Feedback.Mask = (unsigned int )((3 | tmp___2) | 16);
#line 17180
  ctx->Feedback.Type = type;
#line 17181
  break;
  default: 
#line 17183
  ctx->Feedback.Mask = 0U;
#line 17184
  gl_error(ctx, 1280, "glFeedbackBuffer");
  }
#line 17186
  ctx->Feedback.BufferSize = (unsigned int )size;
#line 17187
  ctx->Feedback.Buffer = buffer;
#line 17188
  ctx->Feedback.Count = 0U;
#line 17189
  return;
}
}
#line 17190 "D:/a/test/177.c"
void gl_PassThrough(GLcontext *ctx , float token ) 
{ 

  {
#line 17192
  if (ctx->Primitive != 6656) {
#line 17193
    gl_error(ctx, 1282, "glPassThrough");
#line 17194
    return;
  }
#line 17196
  if (ctx->RenderMode == 7169) {
#line 17197
    FEEDBACK_TOKEN(ctx, (float )1792);
#line 17198
    FEEDBACK_TOKEN(ctx, token);
  }
#line 17200
  return;
}
}
#line 17201 "D:/a/test/177.c"
void gl_feedback_vertex(GLcontext *ctx , float x , float y , float z , float w , float const   *color ,
                        float index___0 , float const   *texcoord ) 
{ 

  {
#line 17206
  FEEDBACK_TOKEN(ctx, x);
#line 17207
  FEEDBACK_TOKEN(ctx, y);
#line 17208
  if (ctx->Feedback.Mask & 1U) {
#line 17209
    FEEDBACK_TOKEN(ctx, z);
  }
#line 17211
  if (ctx->Feedback.Mask & 2U) {
#line 17212
    FEEDBACK_TOKEN(ctx, w);
  }
#line 17214
  if (ctx->Feedback.Mask & 4U) {
#line 17215
    FEEDBACK_TOKEN(ctx, index___0);
  }
#line 17217
  if (ctx->Feedback.Mask & 8U) {
#line 17218
    FEEDBACK_TOKEN(ctx, *(color + 0));
#line 17219
    FEEDBACK_TOKEN(ctx, *(color + 1));
#line 17220
    FEEDBACK_TOKEN(ctx, *(color + 2));
#line 17221
    FEEDBACK_TOKEN(ctx, *(color + 3));
  }
#line 17223
  if (ctx->Feedback.Mask & 16U) {
#line 17224
    FEEDBACK_TOKEN(ctx, *(texcoord + 0));
#line 17225
    FEEDBACK_TOKEN(ctx, *(texcoord + 1));
#line 17226
    FEEDBACK_TOKEN(ctx, *(texcoord + 2));
#line 17227
    FEEDBACK_TOKEN(ctx, *(texcoord + 3));
  }
#line 17229
  return;
}
}
#line 17230 "D:/a/test/177.c"
void gl_SelectBuffer(GLcontext *ctx , GLsizei size , GLuint *buffer ) 
{ 

  {
#line 17232
  if (ctx->Primitive != 6656) {
#line 17233
    gl_error(ctx, 1282, "glSelectBuffer");
  }
#line 17235
  if (ctx->RenderMode == 7170) {
#line 17236
    gl_error(ctx, 1282, "glSelectBuffer");
  }
#line 17238
  ctx->Select.Buffer = buffer;
#line 17239
  ctx->Select.BufferSize = (unsigned int )size;
#line 17240
  ctx->Select.BufferCount = 0U;
#line 17241
  ctx->Select.HitFlag = (unsigned char)0;
#line 17242
  ctx->Select.HitMinZ = (float )1.0;
#line 17243
  ctx->Select.HitMaxZ = (float )0.0;
#line 17244
  return;
}
}
#line 17245 "D:/a/test/177.c"
void gl_InitNames(GLcontext *ctx ) 
{ 

  {
#line 17247
  if (ctx->Primitive != 6656) {
#line 17248
    gl_error(ctx, 1282, "glInitNames");
  }
#line 17250
  ctx->Select.NameStackDepth = 0U;
#line 17251
  ctx->Select.HitFlag = (unsigned char)0;
#line 17252
  ctx->Select.HitMinZ = (float )1.0;
#line 17253
  ctx->Select.HitMaxZ = (float )0.0;
#line 17254
  return;
}
}
#line 17260 "D:/a/test/177.c"
void gl_update_hitflag(GLcontext *ctx , float z ) 
{ 

  {
#line 17262
  ctx->Select.HitFlag = (unsigned char)1;
#line 17263
  if (z < ctx->Select.HitMinZ) {
#line 17264
    ctx->Select.HitMinZ = z;
  }
#line 17266
  if (z > ctx->Select.HitMaxZ) {
#line 17267
    ctx->Select.HitMaxZ = z;
  }
#line 17269
  return;
}
}
#line 17270 "D:/a/test/177.c"
static void write_hit_record(GLcontext *ctx ) 
{ GLuint i ;
  GLuint zmin ;
  GLuint zmax ;
  GLuint zscale ;

  {
#line 17273
  zscale = ~ 0U;
#line 17274
 // assert((unsigned int )ctx != (unsigned int )((void *)0));
#line 17275
  zmin = (unsigned int )((float )zscale * ctx->Select.HitMinZ);
#line 17276
  zmax = (unsigned int )((float )zscale * ctx->Select.HitMaxZ);
#line 17277
  if (ctx->Select.BufferCount < ctx->Select.BufferSize) {
#line 17277
    *(ctx->Select.Buffer + ctx->Select.BufferCount) = ctx->Select.NameStackDepth;
  }
#line 17277
  (ctx->Select.BufferCount) ++;
#line 17278
  if (ctx->Select.BufferCount < ctx->Select.BufferSize) {
#line 17278
    *(ctx->Select.Buffer + ctx->Select.BufferCount) = zmin;
  }
#line 17278
  (ctx->Select.BufferCount) ++;
#line 17279
  if (ctx->Select.BufferCount < ctx->Select.BufferSize) {
#line 17279
    *(ctx->Select.Buffer + ctx->Select.BufferCount) = zmax;
  }
#line 17279
  (ctx->Select.BufferCount) ++;
#line 17280
  i = 0U;
#line 17280
  while (i < ctx->Select.NameStackDepth) {
#line 17281
    if (ctx->Select.BufferCount < ctx->Select.BufferSize) {
#line 17281
      *(ctx->Select.Buffer + ctx->Select.BufferCount) = ctx->Select.NameStack[i];
    }
#line 17281
    (ctx->Select.BufferCount) ++;
#line 17280
    i ++;
  }
#line 17283
  (ctx->Select.Hits) ++;
#line 17284
  ctx->Select.HitFlag = (unsigned char)0;
#line 17285
  ctx->Select.HitMinZ = (float )1.0;
#line 17286
  ctx->Select.HitMaxZ = (float )(- 1.0);
#line 17287
  return;
}
}
#line 17288 "D:/a/test/177.c"
void gl_LoadName(GLcontext *ctx , GLuint name ) 
{ 

  {
#line 17290
  if (ctx->Primitive != 6656) {
#line 17291
    gl_error(ctx, 1282, "glLoadName");
#line 17292
    return;
  }
#line 17294
  if (ctx->RenderMode != 7170) {
#line 17295
    return;
  }
#line 17297
  if (ctx->Select.NameStackDepth == 0U) {
#line 17298
    gl_error(ctx, 1282, "glLoadName");
#line 17299
    return;
  }
#line 17301
  if (ctx->Select.HitFlag) {
#line 17302
    write_hit_record(ctx);
  }
#line 17304
  if (ctx->Select.NameStackDepth < 64U) {
#line 17305
    ctx->Select.NameStack[ctx->Select.NameStackDepth - 1U] = name;
  } else {
#line 17308
    ctx->Select.NameStack[63] = name;
  }
#line 17310
  return;
}
}
#line 17311 "D:/a/test/177.c"
void gl_PushName(GLcontext *ctx , GLuint name ) 
{ GLuint tmp___0 ;

  {
#line 17313
  if (ctx->Primitive != 6656) {
#line 17314
    gl_error(ctx, 1282, "glPushName");
#line 17315
    return;
  }
#line 17317
  if (ctx->RenderMode != 7170) {
#line 17318
    return;
  }
#line 17320
  if (ctx->Select.HitFlag) {
#line 17321
    write_hit_record(ctx);
  }
#line 17323
  if (ctx->Select.NameStackDepth < 64U) {
#line 17324
    tmp___0 = ctx->Select.NameStackDepth;
#line 17324
    (ctx->Select.NameStackDepth) ++;
#line 17324
    ctx->Select.NameStack[tmp___0] = name;
  } else {
#line 17327
    gl_error(ctx, 1283, "glPushName");
  }
#line 17329
  return;
}
}
#line 17330 "D:/a/test/177.c"
void gl_PopName(GLcontext *ctx ) 
{ 

  {
#line 17332
  if (ctx->Primitive != 6656) {
#line 17333
    gl_error(ctx, 1282, "glPopName");
#line 17334
    return;
  }
#line 17336
  if (ctx->RenderMode != 7170) {
#line 17337
    return;
  }
#line 17339
  if (ctx->Select.HitFlag) {
#line 17340
    write_hit_record(ctx);
  }
#line 17342
  if (ctx->Select.NameStackDepth > 0U) {
#line 17343
    (ctx->Select.NameStackDepth) --;
  } else {
#line 17346
    gl_error(ctx, 1284, "glPopName");
  }
#line 17348
  return;
}
}
#line 17349 "D:/a/test/177.c"
GLint gl_RenderMode(GLcontext *ctx , GLenum mode ) 
{ GLint result ;

  {
#line 17352
  if (ctx->Primitive != 6656) {
#line 17353
    gl_error(ctx, 1282, "glRenderMode");
  }
#line 17355
  switch (ctx->RenderMode) {
  case 7168: 
#line 17357
  result = 0;
#line 17358
  break;
  case 7170: 
#line 17360
  if (ctx->Select.HitFlag) {
#line 17361
    write_hit_record(ctx);
  }
#line 17363
  if (ctx->Select.BufferCount > ctx->Select.BufferSize) {
#line 17368
    result = -1;
  } else {
#line 17371
    result = (int )ctx->Select.Hits;
  }
#line 17373
  ctx->Select.BufferCount = 0U;
#line 17374
  ctx->Select.Hits = 0U;
#line 17375
  ctx->Select.NameStackDepth = 0U;
#line 17376
  break;
  case 7169: 
#line 17378
  if (ctx->Feedback.Count > ctx->Feedback.BufferSize) {
#line 17380
    result = -1;
  } else {
#line 17383
    result = (int )ctx->Feedback.Count;
  }
#line 17385
  ctx->Feedback.Count = 0U;
#line 17386
  break;
  default: 
#line 17388
  gl_error(ctx, 1280, "glRenderMode");
#line 17389
  return (0);
  }
#line 17391
  switch (mode) {
  case 7168: 
#line 17393
  break;
  case 7170: 
#line 17395
  if (ctx->Select.BufferSize == 0U) {
#line 17397
    gl_error(ctx, 1282, "glRenderMode");
  }
#line 17399
  break;
  case 7169: 
#line 17401
  if (ctx->Feedback.BufferSize == 0U) {
#line 17403
    gl_error(ctx, 1282, "glRenderMode");
  }
#line 17405
  break;
  default: 
#line 17407
  gl_error(ctx, 1280, "glRenderMode");
#line 17408
  return (0);
  }
#line 17410
  ctx->RenderMode = mode;
#line 17411
  ctx->NewState |= 15U;
#line 17412
  return (result);
}
}
#line 17419 "D:/a/test/177.c"
void gl_Fogfv(GLcontext *ctx , GLenum pname , float const   *params ) 
{ GLenum m ;

  {
#line 17422
  switch (pname) {
  case 2917: 
#line 17424
  m = (int )*params;
#line 17425
  if (m == 9729) {
#line 17426
    ctx->Fog.Mode = m;
  } else {
#line 17425
    if (m == 2048) {
#line 17426
      ctx->Fog.Mode = m;
    } else {
#line 17425
      if (m == 2049) {
#line 17426
        ctx->Fog.Mode = m;
      } else {
#line 17429
        gl_error(ctx, 1280, "glFog");
      }
    }
  }
#line 17431
  break;
  case 2914: 
#line 17433
  if ((double )*params < 0.0) {
#line 17434
    gl_error(ctx, 1281, "glFog");
  } else {
#line 17437
    ctx->Fog.Density = (float )*params;
  }
#line 17439
  break;
  case 2915: 
#line 17442
  if (*params < (float const   )0.0F) {
#line 17443
    gl_error(ctx, 1281, "glFog(GL_FOG_START)");
#line 17444
    return;
  }
#line 17447
  ctx->Fog.Start = (float )*params;
#line 17448
  break;
  case 2916: 
#line 17451
  if (*params < (float const   )0.0F) {
#line 17452
    gl_error(ctx, 1281, "glFog(GL_FOG_END)");
#line 17453
    return;
  }
#line 17456
  ctx->Fog.End = (float )*params;
#line 17457
  break;
  case 2913: 
#line 17459
  ctx->Fog.Index = (float )*params;
#line 17460
  break;
  case 2918: 
#line 17462
  ctx->Fog.Color[0] = (float )*(params + 0);
#line 17463
  ctx->Fog.Color[1] = (float )*(params + 1);
#line 17464
  ctx->Fog.Color[2] = (float )*(params + 2);
#line 17465
  ctx->Fog.Color[3] = (float )*(params + 3);
#line 17466
  break;
  default: 
#line 17468
  gl_error(ctx, 1280, "glFog");
  }
#line 17470
  return;
}
}
#line 17471 "D:/a/test/177.c"
void gl_fog_color_vertices(GLcontext *ctx , GLuint n , float (*v)[4] , GLubyte (*color)[4] ) 
{ GLuint i ;
  float d ;
  float fogr ;
  float fogg ;
  float fogb ;
  float end ;
  float f ;
  float tmp___0 ;
  float tmp___1 ;
  float f___0 ;
  float tmp___2 ;
  double tmp___3 ;
  float tmp___4 ;
  float z ;
  float tmp___5 ;
  float f___1 ;
  double tmp___6 ;
  float tmp___7 ;

  {
#line 17476
  fogr = ctx->Fog.Color[0] * (ctx->Visual)->RedScale;
#line 17477
  fogg = ctx->Fog.Color[1] * (ctx->Visual)->GreenScale;
#line 17478
  fogb = ctx->Fog.Color[2] * (ctx->Visual)->BlueScale;
#line 17479
  end = ctx->Fog.End;
#line 17480
  switch (ctx->Fog.Mode) {
  case 9729: 
#line 17482
  d = 1.0F / (ctx->Fog.End - ctx->Fog.Start);
#line 17483
  i = 0U;
#line 17483
  while (i < n) {
#line 17484
    if ((*(v + i))[2] < 0.0F) {
#line 17484
      tmp___0 = - (*(v + i))[2];
    } else {
#line 17484
      tmp___0 = (*(v + i))[2];
    }
#line 17484
    f = (end - tmp___0) * d;
#line 17485
    if (f < 0.0F) {
#line 17485
      f = 0.0F;
    } else {
#line 17485
      if (f > 1.0F) {
#line 17485
        tmp___1 = 1.0F;
      } else {
#line 17485
        tmp___1 = f;
      }
#line 17485
      f = tmp___1;
    }
#line 17486
    (*(color + i))[0] = (unsigned char )(f * (float )(*(color + i))[0] + (1.0F - f) * fogr);
#line 17487
    (*(color + i))[1] = (unsigned char )(f * (float )(*(color + i))[1] + (1.0F - f) * fogg);
#line 17488
    (*(color + i))[2] = (unsigned char )(f * (float )(*(color + i))[2] + (1.0F - f) * fogb);
#line 17483
    i ++;
  }
#line 17490
  break;
  case 2048: 
#line 17492
  d = - ctx->Fog.Density;
#line 17493
  i = 0U;
#line 17493
  while (i < n) {
#line 17494
    if ((*(v + i))[2] < 0.0F) {
#line 17494
      tmp___2 = - (*(v + i))[2];
    } else {
#line 17494
      tmp___2 = (*(v + i))[2];
    }
#line 17494
    tmp___3 = exp((double )(d * tmp___2));
#line 17494
    f___0 = (float )tmp___3;
#line 17495
    if (f___0 < 0.0F) {
#line 17495
      f___0 = 0.0F;
    } else {
#line 17495
      if (f___0 > 1.0F) {
#line 17495
        tmp___4 = 1.0F;
      } else {
#line 17495
        tmp___4 = f___0;
      }
#line 17495
      f___0 = tmp___4;
    }
#line 17496
    (*(color + i))[0] = (unsigned char )(f___0 * (float )(*(color + i))[0] + (1.0F - f___0) * fogr);
#line 17497
    (*(color + i))[1] = (unsigned char )(f___0 * (float )(*(color + i))[1] + (1.0F - f___0) * fogg);
#line 17498
    (*(color + i))[2] = (unsigned char )(f___0 * (float )(*(color + i))[2] + (1.0F - f___0) * fogb);
#line 17493
    i ++;
  }
#line 17500
  break;
  case 2049: 
#line 17502
  d = - (ctx->Fog.Density * ctx->Fog.Density);
#line 17503
  i = 0U;
#line 17503
  while (i < n) {
#line 17504
    if ((*(v + i))[2] < 0.0F) {
#line 17504
      tmp___5 = - (*(v + i))[2];
    } else {
#line 17504
      tmp___5 = (*(v + i))[2];
    }
#line 17504
    z = tmp___5;
#line 17505
    tmp___6 = exp((double )((d * z) * z));
#line 17505
    f___1 = (float )tmp___6;
#line 17506
    if (f___1 < 0.0F) {
#line 17506
      f___1 = 0.0F;
    } else {
#line 17506
      if (f___1 > 1.0F) {
#line 17506
        tmp___7 = 1.0F;
      } else {
#line 17506
        tmp___7 = f___1;
      }
#line 17506
      f___1 = tmp___7;
    }
#line 17507
    (*(color + i))[0] = (unsigned char )(f___1 * (float )(*(color + i))[0] + (1.0F - f___1) * fogr);
#line 17508
    (*(color + i))[1] = (unsigned char )(f___1 * (float )(*(color + i))[1] + (1.0F - f___1) * fogg);
#line 17509
    (*(color + i))[2] = (unsigned char )(f___1 * (float )(*(color + i))[2] + (1.0F - f___1) * fogb);
#line 17503
    i ++;
  }
#line 17511
  break;
  default: 
#line 17513
  gl_problem((GLcontext const   *)ctx, "Bad fog mode in gl_fog_color_vertices");
#line 17514
  return;
  }
#line 17516
  return;
}
}
#line 17517 "D:/a/test/177.c"
void gl_fog_index_vertices(GLcontext *ctx , GLuint n , float (*v)[4] , GLuint *indx ) 
{ float d ;
  float fogindex ;
  float fogend ;
  GLuint i ;
  float f ;
  float tmp___0 ;
  float tmp___1 ;
  float d___0 ;
  float fogindex___0 ;
  GLuint i___0 ;
  float f___0 ;
  float tmp___2 ;
  double tmp___3 ;
  float tmp___4 ;
  float d___1 ;
  float fogindex___1 ;
  GLuint i___1 ;
  float z ;
  float tmp___5 ;
  float f___1 ;
  double tmp___6 ;
  float tmp___7 ;

  {
#line 17520
  switch (ctx->Fog.Mode) {
  case 9729: 
#line 17523
  d = 1.0F / (ctx->Fog.End - ctx->Fog.Start);
#line 17524
  fogindex = ctx->Fog.Index;
#line 17525
  fogend = ctx->Fog.End;
#line 17527
  i = 0U;
#line 17527
  while (i < n) {
#line 17528
    if ((*(v + i))[2] < 0.0F) {
#line 17528
      tmp___0 = - (*(v + i))[2];
    } else {
#line 17528
      tmp___0 = (*(v + i))[2];
    }
#line 17528
    f = (fogend - tmp___0) * d;
#line 17529
    if (f < 0.0F) {
#line 17529
      f = 0.0F;
    } else {
#line 17529
      if (f > 1.0F) {
#line 17529
        tmp___1 = 1.0F;
      } else {
#line 17529
        tmp___1 = f;
      }
#line 17529
      f = tmp___1;
    }
#line 17530
    *(indx + i) = (unsigned int )((int )((float )((int )*(indx + i)) + (1.0F - f) * fogindex));
#line 17527
    i ++;
  }
#line 17534
  break;
  case 2048: 
#line 17537
  d___0 = - ctx->Fog.Density;
#line 17538
  fogindex___0 = ctx->Fog.Index;
#line 17540
  i___0 = 0U;
#line 17540
  while (i___0 < n) {
#line 17541
    if ((*(v + i___0))[2] < 0.0F) {
#line 17541
      tmp___2 = - (*(v + i___0))[2];
    } else {
#line 17541
      tmp___2 = (*(v + i___0))[2];
    }
#line 17541
    tmp___3 = exp((double )(d___0 * tmp___2));
#line 17541
    f___0 = (float )tmp___3;
#line 17542
    if (f___0 < 0.0F) {
#line 17542
      f___0 = 0.0F;
    } else {
#line 17542
      if (f___0 > 1.0F) {
#line 17542
        tmp___4 = 1.0F;
      } else {
#line 17542
        tmp___4 = f___0;
      }
#line 17542
      f___0 = tmp___4;
    }
#line 17543
    *(indx + i___0) = (unsigned int )((int )((float )((int )*(indx + i___0)) + (1.0F - f___0) * fogindex___0));
#line 17540
    i___0 ++;
  }
#line 17547
  break;
  case 2049: 
#line 17550
  d___1 = - (ctx->Fog.Density * ctx->Fog.Density);
#line 17551
  fogindex___1 = ctx->Fog.Index;
#line 17553
  i___1 = 0U;
#line 17553
  while (i___1 < n) {
#line 17554
    if ((*(v + i___1))[2] < 0.0F) {
#line 17554
      tmp___5 = - (*(v + i___1))[2];
    } else {
#line 17554
      tmp___5 = (*(v + i___1))[2];
    }
#line 17554
    z = tmp___5;
#line 17555
    tmp___6 = exp((double )((- d___1 * z) * z));
#line 17555
    f___1 = (float )tmp___6;
#line 17556
    if (f___1 < 0.0F) {
#line 17556
      f___1 = 0.0F;
    } else {
#line 17556
      if (f___1 > 1.0F) {
#line 17556
        tmp___7 = 1.0F;
      } else {
#line 17556
        tmp___7 = f___1;
      }
#line 17556
      f___1 = tmp___7;
    }
#line 17557
    *(indx + i___1) = (unsigned int )((int )((float )((int )*(indx + i___1)) + (1.0F - f___1) * fogindex___1));
#line 17553
    i___1 ++;
  }
#line 17561
  break;
  default: 
#line 17563
  gl_problem((GLcontext const   *)ctx, "Bad fog mode in gl_fog_index_vertices");
#line 17564
  return;
  }
#line 17566
  return;
}
}
#line 17567 "D:/a/test/177.c"
void gl_fog_color_pixels(GLcontext *ctx , GLuint n , GLdepth const   *z , GLubyte *red ,
                         GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ float c ;
  float d ;
  GLuint i ;
  float fog_red ;
  float fog_green ;
  float fog_blue ;
  float tz ;
  float szInv ;
  float fogEnd ;
  float fogScale ;
  float ndcz ;
  float eyez ;
  float f ;
  float g ;
  float tmp___0 ;
  float ndcz___0 ;
  float eyez___0 ;
  float f___0 ;
  float g___0 ;
  double tmp___1 ;
  float tmp___2 ;
  float negDensitySquared ;
  float ndcz___1 ;
  float eyez___1 ;
  float f___1 ;
  float g___1 ;
  double tmp___3 ;
  float tmp___4 ;

  {
#line 17571
  c = ctx->ProjectionMatrix[10];
#line 17572
  d = ctx->ProjectionMatrix[14];
#line 17574
  fog_red = ctx->Fog.Color[0] * (ctx->Visual)->RedScale;
#line 17575
  fog_green = ctx->Fog.Color[1] * (ctx->Visual)->GreenScale;
#line 17576
  fog_blue = ctx->Fog.Color[2] * (ctx->Visual)->BlueScale;
#line 17577
  tz = ctx->Viewport.Tz;
#line 17578
  szInv = 1.0F / ctx->Viewport.Sz;
#line 17579
  switch (ctx->Fog.Mode) {
  case 9729: 
#line 17582
  fogEnd = ctx->Fog.End;
#line 17583
  fogScale = 1.0F / (ctx->Fog.End - ctx->Fog.Start);
#line 17584
  i = 0U;
#line 17584
  while (i < n) {
#line 17585
    ndcz = ((float )*(z + i) - tz) * szInv;
#line 17586
    eyez = - d / (c + ndcz);
#line 17588
    if ((double )eyez < 0.0) {
#line 17588
      eyez = - eyez;
    }
#line 17589
    f = (fogEnd - eyez) * fogScale;
#line 17590
    if (f < 0.0F) {
#line 17590
      f = 0.0F;
    } else {
#line 17590
      if (f > 1.0F) {
#line 17590
        tmp___0 = 1.0F;
      } else {
#line 17590
        tmp___0 = f;
      }
#line 17590
      f = tmp___0;
    }
#line 17591
    g = 1.0F - f;
#line 17592
    *(red + i) = (unsigned char )((int )(f * (float )*(red + i) + g * fog_red));
#line 17593
    *(green + i) = (unsigned char )((int )(f * (float )*(green + i) + g * fog_green));
#line 17594
    *(blue___0 + i) = (unsigned char )((int )(f * (float )*(blue___0 + i) + g * fog_blue));
#line 17584
    i ++;
  }
#line 17597
  break;
  case 2048: 
#line 17599
  i = 0U;
#line 17599
  while (i < n) {
#line 17600
    ndcz___0 = ((float )*(z + i) - tz) * szInv;
#line 17601
    eyez___0 = - d / (c + ndcz___0);
#line 17603
    if ((double )eyez___0 < 0.0) {
#line 17603
      eyez___0 = - eyez___0;
    }
#line 17604
    tmp___1 = exp((double )(- ctx->Fog.Density * eyez___0));
#line 17604
    f___0 = (float )tmp___1;
#line 17605
    if (f___0 < 0.0F) {
#line 17605
      f___0 = 0.0F;
    } else {
#line 17605
      if (f___0 > 1.0F) {
#line 17605
        tmp___2 = 1.0F;
      } else {
#line 17605
        tmp___2 = f___0;
      }
#line 17605
      f___0 = tmp___2;
    }
#line 17606
    g___0 = 1.0F - f___0;
#line 17607
    *(red + i) = (unsigned char )((int )(f___0 * (float )*(red + i) + g___0 * fog_red));
#line 17608
    *(green + i) = (unsigned char )((int )(f___0 * (float )*(green + i) + g___0 * fog_green));
#line 17609
    *(blue___0 + i) = (unsigned char )((int )(f___0 * (float )*(blue___0 + i) + g___0 * fog_blue));
#line 17599
    i ++;
  }
#line 17611
  break;
  case 2049: 
#line 17614
  negDensitySquared = - ctx->Fog.Density * ctx->Fog.Density;
#line 17615
  i = 0U;
#line 17615
  while (i < n) {
#line 17616
    ndcz___1 = ((float )*(z + i) - tz) * szInv;
#line 17617
    eyez___1 = - d / (c + ndcz___1);
#line 17619
    if ((double )eyez___1 < 0.0) {
#line 17619
      eyez___1 = - eyez___1;
    }
#line 17620
    tmp___3 = exp((double )((negDensitySquared * eyez___1) * eyez___1));
#line 17620
    f___1 = (float )tmp___3;
#line 17621
    if (f___1 < 0.0F) {
#line 17621
      f___1 = 0.0F;
    } else {
#line 17621
      if (f___1 > 1.0F) {
#line 17621
        tmp___4 = 1.0F;
      } else {
#line 17621
        tmp___4 = f___1;
      }
#line 17621
      f___1 = tmp___4;
    }
#line 17622
    g___1 = 1.0F - f___1;
#line 17623
    *(red + i) = (unsigned char )((int )(f___1 * (float )*(red + i) + g___1 * fog_red));
#line 17624
    *(green + i) = (unsigned char )((int )(f___1 * (float )*(green + i) + g___1 * fog_green));
#line 17625
    *(blue___0 + i) = (unsigned char )((int )(f___1 * (float )*(blue___0 + i) + g___1 * fog_blue));
#line 17615
    i ++;
  }
#line 17628
  break;
  default: 
#line 17630
  gl_problem((GLcontext const   *)ctx, "Bad fog mode in gl_fog_color_pixels");
#line 17631
  return;
  }
#line 17633
  return;
}
}
#line 17634 "D:/a/test/177.c"
void gl_fog_index_pixels(GLcontext *ctx , GLuint n , GLdepth const   *z , GLuint *index___0 ) 
{ float c ;
  float d ;
  GLuint i ;
  float tz ;
  float szInv ;
  float fogEnd ;
  float fogScale ;
  float ndcz ;
  float eyez ;
  float f ;
  float tmp___0 ;
  float ndcz___0 ;
  float eyez___0 ;
  float f___0 ;
  double tmp___1 ;
  float tmp___2 ;
  float negDensitySquared ;
  float ndcz___1 ;
  float eyez___1 ;
  float f___1 ;
  double tmp___3 ;
  float tmp___4 ;

  {
#line 17637
  c = ctx->ProjectionMatrix[10];
#line 17638
  d = ctx->ProjectionMatrix[14];
#line 17640
  tz = ctx->Viewport.Tz;
#line 17641
  szInv = 1.0F / ctx->Viewport.Sz;
#line 17642
  switch (ctx->Fog.Mode) {
  case 9729: 
#line 17645
  fogEnd = ctx->Fog.End;
#line 17646
  fogScale = 1.0F / (ctx->Fog.End - ctx->Fog.Start);
#line 17647
  i = 0U;
#line 17647
  while (i < n) {
#line 17648
    ndcz = ((float )*(z + i) - tz) * szInv;
#line 17649
    eyez = - d / (c + ndcz);
#line 17651
    if ((double )eyez < 0.0) {
#line 17651
      eyez = - eyez;
    }
#line 17652
    f = (fogEnd - eyez) * fogScale;
#line 17653
    if (f < 0.0F) {
#line 17653
      f = 0.0F;
    } else {
#line 17653
      if (f > 1.0F) {
#line 17653
        tmp___0 = 1.0F;
      } else {
#line 17653
        tmp___0 = f;
      }
#line 17653
      f = tmp___0;
    }
#line 17654
    *(index___0 + i) = (unsigned int )((float )*(index___0 + i) + (1.0F - f) * ctx->Fog.Index);
#line 17647
    i ++;
  }
#line 17657
  break;
  case 2048: 
#line 17659
  i = 0U;
#line 17659
  while (i < n) {
#line 17660
    ndcz___0 = ((float )*(z + i) - tz) * szInv;
#line 17661
    eyez___0 = - d / (c + ndcz___0);
#line 17663
    if ((double )eyez___0 < 0.0) {
#line 17663
      eyez___0 = - eyez___0;
    }
#line 17664
    tmp___1 = exp((double )(- ctx->Fog.Density * eyez___0));
#line 17664
    f___0 = (float )tmp___1;
#line 17665
    if (f___0 < 0.0F) {
#line 17665
      f___0 = 0.0F;
    } else {
#line 17665
      if (f___0 > 1.0F) {
#line 17665
        tmp___2 = 1.0F;
      } else {
#line 17665
        tmp___2 = f___0;
      }
#line 17665
      f___0 = tmp___2;
    }
#line 17666
    *(index___0 + i) = (unsigned int )((float )*(index___0 + i) + (1.0F - f___0) * ctx->Fog.Index);
#line 17659
    i ++;
  }
#line 17668
  break;
  case 2049: 
#line 17671
  negDensitySquared = - ctx->Fog.Density * ctx->Fog.Density;
#line 17672
  i = 0U;
#line 17672
  while (i < n) {
#line 17673
    ndcz___1 = ((float )*(z + i) - tz) * szInv;
#line 17674
    eyez___1 = - d / (c + ndcz___1);
#line 17676
    if ((double )eyez___1 < 0.0) {
#line 17676
      eyez___1 = - eyez___1;
    }
#line 17677
    tmp___3 = exp((double )((negDensitySquared * eyez___1) * eyez___1));
#line 17677
    f___1 = (float )tmp___3;
#line 17678
    if (f___1 < 0.0F) {
#line 17678
      f___1 = 0.0F;
    } else {
#line 17678
      if (f___1 > 1.0F) {
#line 17678
        tmp___4 = 1.0F;
      } else {
#line 17678
        tmp___4 = f___1;
      }
#line 17678
      f___1 = tmp___4;
    }
#line 17679
    *(index___0 + i) = (unsigned int )((float )*(index___0 + i) + (1.0F - f___1) * ctx->Fog.Index);
#line 17672
    i ++;
  }
#line 17682
  break;
  default: 
#line 17684
  gl_problem((GLcontext const   *)ctx, "Bad fog mode in gl_fog_index_pixels");
#line 17685
  return;
  }
#line 17687
  return;
}
}
#line 17696 "D:/a/test/177.c"
void gl_GetBooleanv(GLcontext *ctx , GLenum pname , GLboolean *params ) 
{ GLuint i ;
  GLint tmp___1 ;
  int tmp___3 ;

  {
#line 17699
  if (ctx->Primitive != 6656) {
#line 17700
    gl_error(ctx, 1282, "glGetBooleanv");
#line 17701
    return;
  }
#line 17703
  switch (pname) {
  case 3416: 
  case 3417: 
  case 3418: 
  case 3419: 
#line 17708
  if ((ctx->Visual)->AccumBits == 0) {
#line 17708
    *params = (unsigned char)0;
  } else {
#line 17708
    *params = (unsigned char)1;
  }
#line 17709
  break;
  case 2944: 
#line 17711
  if (ctx->Accum.ClearColor[0] == 0.0F) {
#line 17711
    *(params + 0) = (unsigned char)0;
  } else {
#line 17711
    *(params + 0) = (unsigned char)1;
  }
#line 17712
  if (ctx->Accum.ClearColor[1] == 0.0F) {
#line 17712
    *(params + 1) = (unsigned char)0;
  } else {
#line 17712
    *(params + 1) = (unsigned char)1;
  }
#line 17713
  if (ctx->Accum.ClearColor[2] == 0.0F) {
#line 17713
    *(params + 2) = (unsigned char)0;
  } else {
#line 17713
    *(params + 2) = (unsigned char)1;
  }
#line 17714
  if (ctx->Accum.ClearColor[3] == 0.0F) {
#line 17714
    *(params + 3) = (unsigned char)0;
  } else {
#line 17714
    *(params + 3) = (unsigned char)1;
  }
#line 17715
  break;
  case 3357: 
#line 17717
  if (ctx->Pixel.AlphaBias == 0.0F) {
#line 17717
    *params = (unsigned char)0;
  } else {
#line 17717
    *params = (unsigned char)1;
  }
#line 17718
  break;
  case 3413: 
#line 17720
  if ((ctx->Visual)->AlphaBits == 0) {
#line 17720
    *params = (unsigned char)0;
  } else {
#line 17720
    *params = (unsigned char)1;
  }
#line 17721
  break;
  case 3356: 
#line 17723
  if (ctx->Pixel.AlphaScale == 0.0F) {
#line 17723
    *params = (unsigned char)0;
  } else {
#line 17723
    *params = (unsigned char)1;
  }
#line 17724
  break;
  case 3008: 
#line 17726
  *params = ctx->Color.AlphaEnabled;
#line 17727
  break;
  case 3009: 
#line 17729
  if (ctx->Color.AlphaFunc == 0) {
#line 17729
    *params = (unsigned char)0;
  } else {
#line 17729
    *params = (unsigned char)1;
  }
#line 17730
  break;
  case 3010: 
#line 17732
  if (ctx->Color.AlphaRef == 0.0F) {
#line 17732
    *params = (unsigned char)0;
  } else {
#line 17732
    *params = (unsigned char)1;
  }
#line 17733
  break;
  case 2992: 
#line 17735
  if (ctx->AttribStackDepth == 0U) {
#line 17735
    *params = (unsigned char)0;
  } else {
#line 17735
    *params = (unsigned char)1;
  }
#line 17736
  break;
  case 3456: 
#line 17738
  *params = ctx->Eval.AutoNormal;
#line 17739
  break;
  case 3072: 
#line 17741
  *params = (unsigned char)0;
#line 17742
  break;
  case 3042: 
#line 17744
  *params = ctx->Color.BlendEnabled;
#line 17745
  break;
  case 3040: 
#line 17747
  if (ctx->Color.BlendDst == 0) {
#line 17747
    *params = (unsigned char)0;
  } else {
#line 17747
    *params = (unsigned char)1;
  }
#line 17748
  break;
  case 3041: 
#line 17750
  if (ctx->Color.BlendSrc == 0) {
#line 17750
    *params = (unsigned char)0;
  } else {
#line 17750
    *params = (unsigned char)1;
  }
#line 17751
  break;
  case 32777: 
#line 17753
  if (ctx->Color.BlendEquation == 0) {
#line 17753
    *params = (unsigned char)0;
  } else {
#line 17753
    *params = (unsigned char)1;
  }
#line 17754
  break;
  case 32773: 
#line 17756
  if (ctx->Color.BlendColor[0] == 0.0F) {
#line 17756
    *(params + 0) = (unsigned char)0;
  } else {
#line 17756
    *(params + 0) = (unsigned char)1;
  }
#line 17757
  if (ctx->Color.BlendColor[1] == 0.0F) {
#line 17757
    *(params + 1) = (unsigned char)0;
  } else {
#line 17757
    *(params + 1) = (unsigned char)1;
  }
#line 17758
  if (ctx->Color.BlendColor[2] == 0.0F) {
#line 17758
    *(params + 2) = (unsigned char)0;
  } else {
#line 17758
    *(params + 2) = (unsigned char)1;
  }
#line 17759
  if (ctx->Color.BlendColor[3] == 0.0F) {
#line 17759
    *(params + 3) = (unsigned char)0;
  } else {
#line 17759
    *(params + 3) = (unsigned char)1;
  }
#line 17760
  break;
  case 3355: 
#line 17762
  if (ctx->Pixel.BlueBias == 0.0F) {
#line 17762
    *params = (unsigned char)0;
  } else {
#line 17762
    *params = (unsigned char)1;
  }
#line 17763
  break;
  case 3412: 
#line 17765
  if ((ctx->Visual)->BlueBits == 0) {
#line 17765
    *params = (unsigned char)0;
  } else {
#line 17765
    *params = (unsigned char)1;
  }
#line 17766
  break;
  case 3354: 
#line 17768
  if (ctx->Pixel.BlueScale == 0.0F) {
#line 17768
    *params = (unsigned char)0;
  } else {
#line 17768
    *params = (unsigned char)1;
  }
#line 17769
  break;
  case 2993: 
#line 17771
  if (ctx->ClientAttribStackDepth == 0U) {
#line 17771
    *params = (unsigned char)0;
  } else {
#line 17771
    *params = (unsigned char)1;
  }
#line 17772
  break;
  case 12288: 
  case 12289: 
  case 12290: 
  case 12291: 
  case 12292: 
  case 12293: 
#line 17779
  *params = ctx->Transform.ClipEnabled[pname - 12288];
#line 17780
  break;
  case 3106: 
#line 17782
  if (ctx->Color.ClearColor[0] == 0.0F) {
#line 17782
    *(params + 0) = (unsigned char)0;
  } else {
#line 17782
    *(params + 0) = (unsigned char)1;
  }
#line 17783
  if (ctx->Color.ClearColor[1] == 0.0F) {
#line 17783
    *(params + 1) = (unsigned char)0;
  } else {
#line 17783
    *(params + 1) = (unsigned char)1;
  }
#line 17784
  if (ctx->Color.ClearColor[2] == 0.0F) {
#line 17784
    *(params + 2) = (unsigned char)0;
  } else {
#line 17784
    *(params + 2) = (unsigned char)1;
  }
#line 17785
  if (ctx->Color.ClearColor[3] == 0.0F) {
#line 17785
    *(params + 3) = (unsigned char)0;
  } else {
#line 17785
    *(params + 3) = (unsigned char)1;
  }
#line 17786
  break;
  case 2903: 
#line 17788
  *params = ctx->Light.ColorMaterialEnabled;
#line 17789
  break;
  case 2901: 
#line 17791
  if (ctx->Light.ColorMaterialFace == 0) {
#line 17791
    *params = (unsigned char)0;
  } else {
#line 17791
    *params = (unsigned char)1;
  }
#line 17792
  break;
  case 2902: 
#line 17794
  if (ctx->Light.ColorMaterialMode == 0) {
#line 17794
    *params = (unsigned char)0;
  } else {
#line 17794
    *params = (unsigned char)1;
  }
#line 17795
  break;
  case 3107: 
#line 17797
  if (ctx->Color.ColorMask & 8U) {
#line 17797
    *(params + 0) = (unsigned char)1;
  } else {
#line 17797
    *(params + 0) = (unsigned char)0;
  }
#line 17798
  if (ctx->Color.ColorMask & 4U) {
#line 17798
    *(params + 1) = (unsigned char)1;
  } else {
#line 17798
    *(params + 1) = (unsigned char)0;
  }
#line 17799
  if (ctx->Color.ColorMask & 2U) {
#line 17799
    *(params + 2) = (unsigned char)1;
  } else {
#line 17799
    *(params + 2) = (unsigned char)0;
  }
#line 17800
  if (ctx->Color.ColorMask & 1U) {
#line 17800
    *(params + 3) = (unsigned char)1;
  } else {
#line 17800
    *(params + 3) = (unsigned char)0;
  }
#line 17801
  break;
  case 2884: 
#line 17803
  *params = ctx->Polygon.CullFlag;
#line 17804
  break;
  case 2885: 
#line 17806
  if (ctx->Polygon.CullFaceMode == 0) {
#line 17806
    *params = (unsigned char)0;
  } else {
#line 17806
    *params = (unsigned char)1;
  }
#line 17807
  break;
  case 2816: 
#line 17809
  if ((int )ctx->Current.ByteColor[0] == 0) {
#line 17809
    *(params + 0) = (unsigned char)0;
  } else {
#line 17809
    *(params + 0) = (unsigned char)1;
  }
#line 17810
  if ((int )ctx->Current.ByteColor[1] == 0) {
#line 17810
    *(params + 1) = (unsigned char)0;
  } else {
#line 17810
    *(params + 1) = (unsigned char)1;
  }
#line 17811
  if ((int )ctx->Current.ByteColor[2] == 0) {
#line 17811
    *(params + 2) = (unsigned char)0;
  } else {
#line 17811
    *(params + 2) = (unsigned char)1;
  }
#line 17812
  if ((int )ctx->Current.ByteColor[3] == 0) {
#line 17812
    *(params + 3) = (unsigned char)0;
  } else {
#line 17812
    *(params + 3) = (unsigned char)1;
  }
#line 17813
  break;
  case 2817: 
#line 17815
  if (ctx->Current.Index == 0U) {
#line 17815
    *params = (unsigned char)0;
  } else {
#line 17815
    *params = (unsigned char)1;
  }
#line 17816
  break;
  case 2818: 
#line 17818
  if (ctx->Current.Normal[0] == 0.0F) {
#line 17818
    *(params + 0) = (unsigned char)0;
  } else {
#line 17818
    *(params + 0) = (unsigned char)1;
  }
#line 17819
  if (ctx->Current.Normal[1] == 0.0F) {
#line 17819
    *(params + 1) = (unsigned char)0;
  } else {
#line 17819
    *(params + 1) = (unsigned char)1;
  }
#line 17820
  if (ctx->Current.Normal[2] == 0.0F) {
#line 17820
    *(params + 2) = (unsigned char)0;
  } else {
#line 17820
    *(params + 2) = (unsigned char)1;
  }
#line 17821
  break;
  case 2820: 
#line 17823
  if (ctx->Current.RasterColor[0] == 0.0F) {
#line 17823
    *(params + 0) = (unsigned char)0;
  } else {
#line 17823
    *(params + 0) = (unsigned char)1;
  }
#line 17824
  if (ctx->Current.RasterColor[1] == 0.0F) {
#line 17824
    *(params + 1) = (unsigned char)0;
  } else {
#line 17824
    *(params + 1) = (unsigned char)1;
  }
#line 17825
  if (ctx->Current.RasterColor[2] == 0.0F) {
#line 17825
    *(params + 2) = (unsigned char)0;
  } else {
#line 17825
    *(params + 2) = (unsigned char)1;
  }
#line 17826
  if (ctx->Current.RasterColor[3] == 0.0F) {
#line 17826
    *(params + 3) = (unsigned char)0;
  } else {
#line 17826
    *(params + 3) = (unsigned char)1;
  }
#line 17827
  break;
  case 2825: 
#line 17829
  if (ctx->Current.RasterDistance == 0.0F) {
#line 17829
    *params = (unsigned char)0;
  } else {
#line 17829
    *params = (unsigned char)1;
  }
#line 17830
  break;
  case 2821: 
#line 17832
  if ((float )ctx->Current.RasterIndex == 0.0F) {
#line 17832
    *params = (unsigned char)0;
  } else {
#line 17832
    *params = (unsigned char)1;
  }
#line 17833
  break;
  case 2823: 
#line 17835
  if (ctx->Current.RasterPos[0] == 0.0F) {
#line 17835
    *(params + 0) = (unsigned char)0;
  } else {
#line 17835
    *(params + 0) = (unsigned char)1;
  }
#line 17836
  if (ctx->Current.RasterPos[1] == 0.0F) {
#line 17836
    *(params + 1) = (unsigned char)0;
  } else {
#line 17836
    *(params + 1) = (unsigned char)1;
  }
#line 17837
  if (ctx->Current.RasterPos[2] == 0.0F) {
#line 17837
    *(params + 2) = (unsigned char)0;
  } else {
#line 17837
    *(params + 2) = (unsigned char)1;
  }
#line 17838
  if (ctx->Current.RasterPos[3] == 0.0F) {
#line 17838
    *(params + 3) = (unsigned char)0;
  } else {
#line 17838
    *(params + 3) = (unsigned char)1;
  }
#line 17839
  break;
  case 2822: 
#line 17841
  if (ctx->Current.RasterTexCoord[0] == 0.0F) {
#line 17841
    *(params + 0) = (unsigned char)0;
  } else {
#line 17841
    *(params + 0) = (unsigned char)1;
  }
#line 17842
  if (ctx->Current.RasterTexCoord[1] == 0.0F) {
#line 17842
    *(params + 1) = (unsigned char)0;
  } else {
#line 17842
    *(params + 1) = (unsigned char)1;
  }
#line 17843
  if (ctx->Current.RasterTexCoord[2] == 0.0F) {
#line 17843
    *(params + 2) = (unsigned char)0;
  } else {
#line 17843
    *(params + 2) = (unsigned char)1;
  }
#line 17844
  if (ctx->Current.RasterTexCoord[3] == 0.0F) {
#line 17844
    *(params + 3) = (unsigned char)0;
  } else {
#line 17844
    *(params + 3) = (unsigned char)1;
  }
#line 17845
  break;
  case 2824: 
#line 17847
  *params = ctx->Current.RasterPosValid;
#line 17848
  break;
  case 2819: 
#line 17850
  if (ctx->Current.TexCoord[0] == 0.0F) {
#line 17850
    *(params + 0) = (unsigned char)0;
  } else {
#line 17850
    *(params + 0) = (unsigned char)1;
  }
#line 17851
  if (ctx->Current.TexCoord[1] == 0.0F) {
#line 17851
    *(params + 1) = (unsigned char)0;
  } else {
#line 17851
    *(params + 1) = (unsigned char)1;
  }
#line 17852
  if (ctx->Current.TexCoord[2] == 0.0F) {
#line 17852
    *(params + 2) = (unsigned char)0;
  } else {
#line 17852
    *(params + 2) = (unsigned char)1;
  }
#line 17853
  if (ctx->Current.TexCoord[3] == 0.0F) {
#line 17853
    *(params + 3) = (unsigned char)0;
  } else {
#line 17853
    *(params + 3) = (unsigned char)1;
  }
#line 17854
  break;
  case 3359: 
#line 17856
  if (ctx->Pixel.DepthBias == 0.0F) {
#line 17856
    *params = (unsigned char)0;
  } else {
#line 17856
    *params = (unsigned char)1;
  }
#line 17857
  break;
  case 3414: 
#line 17859
  if ((ctx->Visual)->DepthBits == 0) {
#line 17859
    *params = (unsigned char)0;
  } else {
#line 17859
    *params = (unsigned char)1;
  }
#line 17860
  break;
  case 2931: 
#line 17862
  if (ctx->Depth.Clear == 0.0F) {
#line 17862
    *params = (unsigned char)0;
  } else {
#line 17862
    *params = (unsigned char)1;
  }
#line 17863
  break;
  case 2932: 
#line 17865
  if (ctx->Depth.Func == 0) {
#line 17865
    *params = (unsigned char)0;
  } else {
#line 17865
    *params = (unsigned char)1;
  }
#line 17866
  break;
  case 2928: 
#line 17868
  if (ctx->Viewport.Near == 0.0F) {
#line 17868
    *(params + 0) = (unsigned char)0;
  } else {
#line 17868
    *(params + 0) = (unsigned char)1;
  }
#line 17869
  if (ctx->Viewport.Far == 0.0F) {
#line 17869
    *(params + 1) = (unsigned char)0;
  } else {
#line 17869
    *(params + 1) = (unsigned char)1;
  }
#line 17870
  break;
  case 3358: 
#line 17872
  if (ctx->Pixel.DepthScale == 0.0F) {
#line 17872
    *params = (unsigned char)0;
  } else {
#line 17872
    *params = (unsigned char)1;
  }
#line 17873
  break;
  case 2929: 
#line 17875
  *params = ctx->Depth.Test;
#line 17876
  break;
  case 2930: 
#line 17878
  *params = ctx->Depth.Mask;
#line 17879
  break;
  case 3024: 
#line 17881
  *params = ctx->Color.DitherFlag;
#line 17882
  break;
  case 3122: 
#line 17884
  *params = (ctx->Visual)->DBflag;
#line 17885
  break;
  case 3073: 
#line 17887
  if (ctx->Color.DrawBuffer == 0) {
#line 17887
    *params = (unsigned char)0;
  } else {
#line 17887
    *params = (unsigned char)1;
  }
#line 17888
  break;
  case 2883: 
#line 17890
  *params = ctx->Current.EdgeFlag;
#line 17891
  break;
  case 3569: 
#line 17893
  if (ctx->Feedback.BufferSize == 0U) {
#line 17893
    *params = (unsigned char)0;
  } else {
#line 17893
    *params = (unsigned char)1;
  }
#line 17894
  break;
  case 3570: 
#line 17896
  if (ctx->Feedback.Type == 0) {
#line 17896
    *params = (unsigned char)0;
  } else {
#line 17896
    *params = (unsigned char)1;
  }
#line 17897
  break;
  case 2912: 
#line 17899
  *params = ctx->Fog.Enabled;
#line 17900
  break;
  case 2918: 
#line 17902
  if (ctx->Fog.Color[0] == 0.0F) {
#line 17902
    *(params + 0) = (unsigned char)0;
  } else {
#line 17902
    *(params + 0) = (unsigned char)1;
  }
#line 17903
  if (ctx->Fog.Color[1] == 0.0F) {
#line 17903
    *(params + 1) = (unsigned char)0;
  } else {
#line 17903
    *(params + 1) = (unsigned char)1;
  }
#line 17904
  if (ctx->Fog.Color[2] == 0.0F) {
#line 17904
    *(params + 2) = (unsigned char)0;
  } else {
#line 17904
    *(params + 2) = (unsigned char)1;
  }
#line 17905
  if (ctx->Fog.Color[3] == 0.0F) {
#line 17905
    *(params + 3) = (unsigned char)0;
  } else {
#line 17905
    *(params + 3) = (unsigned char)1;
  }
#line 17906
  break;
  case 2914: 
#line 17908
  if (ctx->Fog.Density == 0.0F) {
#line 17908
    *params = (unsigned char)0;
  } else {
#line 17908
    *params = (unsigned char)1;
  }
#line 17909
  break;
  case 2916: 
#line 17911
  if (ctx->Fog.End == 0.0F) {
#line 17911
    *params = (unsigned char)0;
  } else {
#line 17911
    *params = (unsigned char)1;
  }
#line 17912
  break;
  case 3156: 
#line 17914
  if (ctx->Hint.Fog == 0) {
#line 17914
    *params = (unsigned char)0;
  } else {
#line 17914
    *params = (unsigned char)1;
  }
#line 17915
  break;
  case 2913: 
#line 17917
  if (ctx->Fog.Index == 0.0F) {
#line 17917
    *params = (unsigned char)0;
  } else {
#line 17917
    *params = (unsigned char)1;
  }
#line 17918
  break;
  case 2917: 
#line 17920
  if (ctx->Fog.Mode == 0) {
#line 17920
    *params = (unsigned char)0;
  } else {
#line 17920
    *params = (unsigned char)1;
  }
#line 17921
  break;
  case 2915: 
#line 17923
  if (ctx->Fog.End == 0.0F) {
#line 17923
    *params = (unsigned char)0;
  } else {
#line 17923
    *params = (unsigned char)1;
  }
#line 17924
  break;
  case 2886: 
#line 17926
  if (ctx->Polygon.FrontFace == 0) {
#line 17926
    *params = (unsigned char)0;
  } else {
#line 17926
    *params = (unsigned char)1;
  }
#line 17927
  break;
  case 3353: 
#line 17929
  if (ctx->Pixel.GreenBias == 0.0F) {
#line 17929
    *params = (unsigned char)0;
  } else {
#line 17929
    *params = (unsigned char)1;
  }
#line 17930
  break;
  case 3411: 
#line 17932
  if ((ctx->Visual)->GreenBits == 0) {
#line 17932
    *params = (unsigned char)0;
  } else {
#line 17932
    *params = (unsigned char)1;
  }
#line 17933
  break;
  case 3352: 
#line 17935
  if (ctx->Pixel.GreenScale == 0.0F) {
#line 17935
    *params = (unsigned char)0;
  } else {
#line 17935
    *params = (unsigned char)1;
  }
#line 17936
  break;
  case 3409: 
#line 17938
  if ((ctx->Visual)->IndexBits == 0) {
#line 17938
    *params = (unsigned char)0;
  } else {
#line 17938
    *params = (unsigned char)1;
  }
#line 17939
  break;
  case 3104: 
#line 17941
  if (ctx->Color.ClearIndex == 0U) {
#line 17941
    *params = (unsigned char)0;
  } else {
#line 17941
    *params = (unsigned char)1;
  }
#line 17942
  break;
  case 3120: 
#line 17944
  if ((ctx->Visual)->RGBAflag) {
#line 17944
    *params = (unsigned char)0;
  } else {
#line 17944
    *params = (unsigned char)1;
  }
#line 17945
  break;
  case 3347: 
#line 17947
  if (ctx->Pixel.IndexOffset == 0) {
#line 17947
    *params = (unsigned char)0;
  } else {
#line 17947
    *params = (unsigned char)1;
  }
#line 17948
  break;
  case 3346: 
#line 17950
  if (ctx->Pixel.IndexShift == 0) {
#line 17950
    *params = (unsigned char)0;
  } else {
#line 17950
    *params = (unsigned char)1;
  }
#line 17951
  break;
  case 3105: 
#line 17953
  if (ctx->Color.IndexMask == 0U) {
#line 17953
    *params = (unsigned char)0;
  } else {
#line 17953
    *params = (unsigned char)1;
  }
#line 17954
  break;
  case 16384: 
  case 16385: 
  case 16386: 
  case 16387: 
  case 16388: 
  case 16389: 
  case 16390: 
  case 16391: 
#line 17963
  *params = ctx->Light.Light[pname - 16384].Enabled;
#line 17964
  break;
  case 2896: 
#line 17966
  *params = ctx->Light.Enabled;
#line 17967
  break;
  case 2899: 
#line 17969
  if (ctx->Light.Model.Ambient[0] == 0.0F) {
#line 17969
    *(params + 0) = (unsigned char)0;
  } else {
#line 17969
    *(params + 0) = (unsigned char)1;
  }
#line 17970
  if (ctx->Light.Model.Ambient[1] == 0.0F) {
#line 17970
    *(params + 1) = (unsigned char)0;
  } else {
#line 17970
    *(params + 1) = (unsigned char)1;
  }
#line 17971
  if (ctx->Light.Model.Ambient[2] == 0.0F) {
#line 17971
    *(params + 2) = (unsigned char)0;
  } else {
#line 17971
    *(params + 2) = (unsigned char)1;
  }
#line 17972
  if (ctx->Light.Model.Ambient[3] == 0.0F) {
#line 17972
    *(params + 3) = (unsigned char)0;
  } else {
#line 17972
    *(params + 3) = (unsigned char)1;
  }
#line 17973
  break;
  case 2897: 
#line 17975
  *params = ctx->Light.Model.LocalViewer;
#line 17976
  break;
  case 2898: 
#line 17978
  *params = ctx->Light.Model.TwoSide;
#line 17979
  break;
  case 2848: 
#line 17981
  *params = ctx->Line.SmoothFlag;
#line 17982
  break;
  case 3154: 
#line 17984
  if (ctx->Hint.LineSmooth == 0) {
#line 17984
    *params = (unsigned char)0;
  } else {
#line 17984
    *params = (unsigned char)1;
  }
#line 17985
  break;
  case 2852: 
#line 17987
  *params = ctx->Line.StippleFlag;
#line 17988
  break;
  case 2853: 
#line 17990
  if ((int )ctx->Line.StipplePattern == 0) {
#line 17990
    *params = (unsigned char)0;
  } else {
#line 17990
    *params = (unsigned char)1;
  }
#line 17991
  break;
  case 2854: 
#line 17993
  if (ctx->Line.StippleFactor == 0) {
#line 17993
    *params = (unsigned char)0;
  } else {
#line 17993
    *params = (unsigned char)1;
  }
#line 17994
  break;
  case 2849: 
#line 17996
  if (ctx->Line.Width == 0.0F) {
#line 17996
    *params = (unsigned char)0;
  } else {
#line 17996
    *params = (unsigned char)1;
  }
#line 17997
  break;
  case 2851: 
#line 17999
  if (1.0 == (double )0.0F) {
#line 17999
    *params = (unsigned char)0;
  } else {
#line 17999
    *params = (unsigned char)1;
  }
#line 18000
  break;
  case 2850: 
#line 18002
  if (1.0 == (double )0.0F) {
#line 18002
    *(params + 0) = (unsigned char)0;
  } else {
#line 18002
    *(params + 0) = (unsigned char)1;
  }
#line 18003
  if (10.0 == (double )0.0F) {
#line 18003
    *(params + 1) = (unsigned char)0;
  } else {
#line 18003
    *(params + 1) = (unsigned char)1;
  }
#line 18004
  break;
  case 2866: 
#line 18006
  if (ctx->List.ListBase == 0U) {
#line 18006
    *params = (unsigned char)0;
  } else {
#line 18006
    *params = (unsigned char)1;
  }
#line 18007
  break;
  case 2867: 
#line 18009
  tmp___1 = gl_list_index();
#line 18009
  if (tmp___1 == 0) {
#line 18009
    *params = (unsigned char)0;
  } else {
#line 18009
    *params = (unsigned char)1;
  }
#line 18010
  break;
  case 2864: 
#line 18012
  if (ctx->ExecuteFlag) {
#line 18012
    tmp___3 = 4865;
  } else {
#line 18012
    tmp___3 = 4864;
  }
#line 18012
  if (tmp___3 == 0) {
#line 18012
    *params = (unsigned char)0;
  } else {
#line 18012
    *params = (unsigned char)1;
  }
#line 18014
  break;
  case 3057: 
#line 18016
  *params = ctx->Color.IndexLogicOpEnabled;
#line 18017
  break;
  case 3058: 
#line 18019
  *params = ctx->Color.ColorLogicOpEnabled;
#line 18020
  break;
  case 3056: 
#line 18022
  if (ctx->Color.LogicOp == 0) {
#line 18022
    *params = (unsigned char)0;
  } else {
#line 18022
    *params = (unsigned char)1;
  }
#line 18023
  break;
  case 3472: 
#line 18025
  *params = ctx->Eval.Map1Color4;
#line 18026
  break;
  case 3536: 
#line 18028
  if (ctx->Eval.MapGrid1u1 == 0.0F) {
#line 18028
    *(params + 0) = (unsigned char)0;
  } else {
#line 18028
    *(params + 0) = (unsigned char)1;
  }
#line 18029
  if (ctx->Eval.MapGrid1u2 == 0.0F) {
#line 18029
    *(params + 1) = (unsigned char)0;
  } else {
#line 18029
    *(params + 1) = (unsigned char)1;
  }
#line 18030
  break;
  case 3537: 
#line 18032
  if (ctx->Eval.MapGrid1un == 0U) {
#line 18032
    *params = (unsigned char)0;
  } else {
#line 18032
    *params = (unsigned char)1;
  }
#line 18033
  break;
  case 3473: 
#line 18035
  *params = ctx->Eval.Map1Index;
#line 18036
  break;
  case 3474: 
#line 18038
  *params = ctx->Eval.Map1Normal;
#line 18039
  break;
  case 3475: 
#line 18041
  *params = ctx->Eval.Map1TextureCoord1;
#line 18042
  break;
  case 3476: 
#line 18044
  *params = ctx->Eval.Map1TextureCoord2;
#line 18045
  break;
  case 3477: 
#line 18047
  *params = ctx->Eval.Map1TextureCoord3;
#line 18048
  break;
  case 3478: 
#line 18050
  *params = ctx->Eval.Map1TextureCoord4;
#line 18051
  break;
  case 3479: 
#line 18053
  *params = ctx->Eval.Map1Vertex3;
#line 18054
  break;
  case 3480: 
#line 18056
  *params = ctx->Eval.Map1Vertex4;
#line 18057
  break;
  case 3504: 
#line 18059
  *params = ctx->Eval.Map2Color4;
#line 18060
  break;
  case 3538: 
#line 18062
  if (ctx->Eval.MapGrid2u1 == 0.0F) {
#line 18062
    *(params + 0) = (unsigned char)0;
  } else {
#line 18062
    *(params + 0) = (unsigned char)1;
  }
#line 18063
  if (ctx->Eval.MapGrid2u2 == 0.0F) {
#line 18063
    *(params + 1) = (unsigned char)0;
  } else {
#line 18063
    *(params + 1) = (unsigned char)1;
  }
#line 18064
  if (ctx->Eval.MapGrid2v1 == 0.0F) {
#line 18064
    *(params + 2) = (unsigned char)0;
  } else {
#line 18064
    *(params + 2) = (unsigned char)1;
  }
#line 18065
  if (ctx->Eval.MapGrid2v2 == 0.0F) {
#line 18065
    *(params + 3) = (unsigned char)0;
  } else {
#line 18065
    *(params + 3) = (unsigned char)1;
  }
#line 18066
  break;
  case 3539: 
#line 18068
  if (ctx->Eval.MapGrid2un == 0U) {
#line 18068
    *(params + 0) = (unsigned char)0;
  } else {
#line 18068
    *(params + 0) = (unsigned char)1;
  }
#line 18069
  if (ctx->Eval.MapGrid2vn == 0U) {
#line 18069
    *(params + 1) = (unsigned char)0;
  } else {
#line 18069
    *(params + 1) = (unsigned char)1;
  }
#line 18070
  break;
  case 3505: 
#line 18072
  *params = ctx->Eval.Map2Index;
#line 18073
  break;
  case 3506: 
#line 18075
  *params = ctx->Eval.Map2Normal;
#line 18076
  break;
  case 3507: 
#line 18078
  *params = ctx->Eval.Map2TextureCoord1;
#line 18079
  break;
  case 3508: 
#line 18081
  *params = ctx->Eval.Map2TextureCoord2;
#line 18082
  break;
  case 3509: 
#line 18084
  *params = ctx->Eval.Map2TextureCoord3;
#line 18085
  break;
  case 3510: 
#line 18087
  *params = ctx->Eval.Map2TextureCoord4;
#line 18088
  break;
  case 3511: 
#line 18090
  *params = ctx->Eval.Map2Vertex3;
#line 18091
  break;
  case 3512: 
#line 18093
  *params = ctx->Eval.Map2Vertex4;
#line 18094
  break;
  case 3344: 
#line 18096
  *params = ctx->Pixel.MapColorFlag;
#line 18097
  break;
  case 3345: 
#line 18099
  *params = ctx->Pixel.MapStencilFlag;
#line 18100
  break;
  case 2976: 
#line 18102
  if (ctx->Transform.MatrixMode == 0) {
#line 18102
    *params = (unsigned char)0;
  } else {
#line 18102
    *params = (unsigned char)1;
  }
#line 18103
  break;
  case 3381: 
#line 18105
  *params = (unsigned char)1;
#line 18106
  break;
  case 3387: 
#line 18108
  *params = (unsigned char)1;
#line 18109
  break;
  case 3378: 
#line 18111
  *params = (unsigned char)1;
#line 18112
  break;
  case 3376: 
#line 18114
  *params = (unsigned char)1;
#line 18115
  break;
  case 3377: 
#line 18117
  *params = (unsigned char)1;
#line 18118
  break;
  case 2865: 
#line 18120
  *params = (unsigned char)1;
#line 18121
  break;
  case 3382: 
#line 18123
  *params = (unsigned char)1;
#line 18124
  break;
  case 3383: 
#line 18126
  *params = (unsigned char)1;
#line 18127
  break;
  case 3380: 
#line 18129
  *params = (unsigned char)1;
#line 18130
  break;
  case 3384: 
#line 18132
  *params = (unsigned char)1;
#line 18133
  break;
  case 3379: 
#line 18135
  if (1 << 10 == 0) {
#line 18135
    *params = (unsigned char)0;
  } else {
#line 18135
    *params = (unsigned char)1;
  }
#line 18136
  break;
  case 3385: 
#line 18138
  *params = (unsigned char)1;
#line 18139
  break;
  case 3386: 
#line 18141
  *(params + 0) = (unsigned char)1;
#line 18142
  *(params + 1) = (unsigned char)1;
#line 18143
  break;
  case 2982: 
#line 18145
  i = 0U;
#line 18145
  while (i < 16U) {
#line 18146
    if (ctx->ModelViewMatrix[i] == 0.0F) {
#line 18146
      *(params + i) = (unsigned char)0;
    } else {
#line 18146
      *(params + i) = (unsigned char)1;
    }
#line 18145
    i ++;
  }
#line 18148
  break;
  case 2979: 
#line 18150
  if (ctx->ModelViewStackDepth == 0U) {
#line 18150
    *params = (unsigned char)0;
  } else {
#line 18150
    *params = (unsigned char)1;
  }
#line 18151
  break;
  case 3440: 
#line 18153
  if (ctx->Select.NameStackDepth == 0U) {
#line 18153
    *params = (unsigned char)0;
  } else {
#line 18153
    *params = (unsigned char)1;
  }
#line 18154
  break;
  case 2977: 
#line 18156
  *params = ctx->Transform.Normalize;
#line 18157
  break;
  case 3333: 
#line 18159
  if (ctx->Pack.Alignment == 0) {
#line 18159
    *params = (unsigned char)0;
  } else {
#line 18159
    *params = (unsigned char)1;
  }
#line 18160
  break;
  case 3329: 
#line 18162
  *params = ctx->Pack.LsbFirst;
#line 18163
  break;
  case 3330: 
#line 18165
  if (ctx->Pack.RowLength == 0) {
#line 18165
    *params = (unsigned char)0;
  } else {
#line 18165
    *params = (unsigned char)1;
  }
#line 18166
  break;
  case 3332: 
#line 18168
  if (ctx->Pack.SkipPixels == 0) {
#line 18168
    *params = (unsigned char)0;
  } else {
#line 18168
    *params = (unsigned char)1;
  }
#line 18169
  break;
  case 3331: 
#line 18171
  if (ctx->Pack.SkipRows == 0) {
#line 18171
    *params = (unsigned char)0;
  } else {
#line 18171
    *params = (unsigned char)1;
  }
#line 18172
  break;
  case 3328: 
#line 18174
  *params = ctx->Pack.SwapBytes;
#line 18175
  break;
  case 32875: 
#line 18177
  *params = (unsigned char )ctx->Pack.SkipImages;
#line 18178
  break;
  case 32876: 
#line 18180
  *params = (unsigned char )ctx->Pack.ImageHeight;
#line 18181
  break;
  case 3152: 
#line 18183
  if (ctx->Hint.PerspectiveCorrection == 0) {
#line 18183
    *params = (unsigned char)0;
  } else {
#line 18183
    *params = (unsigned char)1;
  }
#line 18184
  break;
  case 3257: 
#line 18186
  if (ctx->Pixel.MapAtoAsize == 0) {
#line 18186
    *params = (unsigned char)0;
  } else {
#line 18186
    *params = (unsigned char)1;
  }
#line 18187
  break;
  case 3256: 
#line 18189
  if (ctx->Pixel.MapBtoBsize == 0) {
#line 18189
    *params = (unsigned char)0;
  } else {
#line 18189
    *params = (unsigned char)1;
  }
#line 18190
  break;
  case 3255: 
#line 18192
  if (ctx->Pixel.MapGtoGsize == 0) {
#line 18192
    *params = (unsigned char)0;
  } else {
#line 18192
    *params = (unsigned char)1;
  }
#line 18193
  break;
  case 3253: 
#line 18195
  if (ctx->Pixel.MapItoAsize == 0) {
#line 18195
    *params = (unsigned char)0;
  } else {
#line 18195
    *params = (unsigned char)1;
  }
#line 18196
  break;
  case 3252: 
#line 18198
  if (ctx->Pixel.MapItoBsize == 0) {
#line 18198
    *params = (unsigned char)0;
  } else {
#line 18198
    *params = (unsigned char)1;
  }
#line 18199
  break;
  case 3251: 
#line 18201
  if (ctx->Pixel.MapItoGsize == 0) {
#line 18201
    *params = (unsigned char)0;
  } else {
#line 18201
    *params = (unsigned char)1;
  }
#line 18202
  break;
  case 3248: 
#line 18204
  if (ctx->Pixel.MapItoIsize == 0) {
#line 18204
    *params = (unsigned char)0;
  } else {
#line 18204
    *params = (unsigned char)1;
  }
#line 18205
  break;
  case 3250: 
#line 18207
  if (ctx->Pixel.MapItoRsize == 0) {
#line 18207
    *params = (unsigned char)0;
  } else {
#line 18207
    *params = (unsigned char)1;
  }
#line 18208
  break;
  case 3254: 
#line 18210
  if (ctx->Pixel.MapRtoRsize == 0) {
#line 18210
    *params = (unsigned char)0;
  } else {
#line 18210
    *params = (unsigned char)1;
  }
#line 18211
  break;
  case 3249: 
#line 18213
  if (ctx->Pixel.MapStoSsize == 0) {
#line 18213
    *params = (unsigned char)0;
  } else {
#line 18213
    *params = (unsigned char)1;
  }
#line 18214
  break;
  case 2833: 
#line 18216
  if (ctx->Point.Size == 0.0F) {
#line 18216
    *params = (unsigned char)0;
  } else {
#line 18216
    *params = (unsigned char)1;
  }
#line 18217
  break;
  case 2835: 
#line 18219
  if (0.1 == (double )0.0F) {
#line 18219
    *params = (unsigned char)0;
  } else {
#line 18219
    *params = (unsigned char)1;
  }
#line 18220
  break;
  case 2834: 
#line 18222
  if (1.0 == (double )0.0F) {
#line 18222
    *(params + 0) = (unsigned char)0;
  } else {
#line 18222
    *(params + 0) = (unsigned char)1;
  }
#line 18223
  if (10.0 == (double )0.0F) {
#line 18223
    *(params + 1) = (unsigned char)0;
  } else {
#line 18223
    *(params + 1) = (unsigned char)1;
  }
#line 18224
  break;
  case 2832: 
#line 18226
  *params = ctx->Point.SmoothFlag;
#line 18227
  break;
  case 3153: 
#line 18229
  if (ctx->Hint.PointSmooth == 0) {
#line 18229
    *params = (unsigned char)0;
  } else {
#line 18229
    *params = (unsigned char)1;
  }
#line 18230
  break;
  case 33062: 
#line 18232
  if (ctx->Point.MinSize == 0.0F) {
#line 18232
    *params = (unsigned char)0;
  } else {
#line 18232
    *params = (unsigned char)1;
  }
#line 18233
  break;
  case 33063: 
#line 18235
  if (ctx->Point.MaxSize == 0.0F) {
#line 18235
    *params = (unsigned char)0;
  } else {
#line 18235
    *params = (unsigned char)1;
  }
#line 18236
  break;
  case 33064: 
#line 18238
  if (ctx->Point.Threshold == 0.0F) {
#line 18238
    *params = (unsigned char)0;
  } else {
#line 18238
    *params = (unsigned char)1;
  }
#line 18239
  break;
  case 33065: 
#line 18241
  if (ctx->Point.Params[0] == 0.0F) {
#line 18241
    *(params + 0) = (unsigned char)0;
  } else {
#line 18241
    *(params + 0) = (unsigned char)1;
  }
#line 18242
  if (ctx->Point.Params[1] == 0.0F) {
#line 18242
    *(params + 1) = (unsigned char)0;
  } else {
#line 18242
    *(params + 1) = (unsigned char)1;
  }
#line 18243
  if (ctx->Point.Params[2] == 0.0F) {
#line 18243
    *(params + 2) = (unsigned char)0;
  } else {
#line 18243
    *(params + 2) = (unsigned char)1;
  }
#line 18244
  break;
  case 2880: 
#line 18246
  if (ctx->Polygon.FrontMode == 0) {
#line 18246
    *(params + 0) = (unsigned char)0;
  } else {
#line 18246
    *(params + 0) = (unsigned char)1;
  }
#line 18247
  if (ctx->Polygon.BackMode == 0) {
#line 18247
    *(params + 1) = (unsigned char)0;
  } else {
#line 18247
    *(params + 1) = (unsigned char)1;
  }
#line 18248
  break;
  case 32824: 
#line 18255
  if (ctx->Polygon.OffsetFactor == 0.0F) {
#line 18255
    *params = (unsigned char)0;
  } else {
#line 18255
    *params = (unsigned char)1;
  }
#line 18256
  break;
  case 10752: 
#line 18258
  if (ctx->Polygon.OffsetUnits == 0.0F) {
#line 18258
    *params = (unsigned char)0;
  } else {
#line 18258
    *params = (unsigned char)1;
  }
#line 18259
  break;
  case 2881: 
#line 18261
  *params = ctx->Polygon.SmoothFlag;
#line 18262
  break;
  case 3155: 
#line 18264
  if (ctx->Hint.PolygonSmooth == 0) {
#line 18264
    *params = (unsigned char)0;
  } else {
#line 18264
    *params = (unsigned char)1;
  }
#line 18265
  break;
  case 2882: 
#line 18267
  *params = ctx->Polygon.StippleFlag;
#line 18268
  break;
  case 2983: 
#line 18270
  i = 0U;
#line 18270
  while (i < 16U) {
#line 18271
    if (ctx->ProjectionMatrix[i] == 0.0F) {
#line 18271
      *(params + i) = (unsigned char)0;
    } else {
#line 18271
      *(params + i) = (unsigned char)1;
    }
#line 18270
    i ++;
  }
#line 18273
  break;
  case 2980: 
#line 18275
  if (ctx->ProjectionStackDepth == 0U) {
#line 18275
    *params = (unsigned char)0;
  } else {
#line 18275
    *params = (unsigned char)1;
  }
#line 18276
  break;
  case 3074: 
#line 18278
  if (ctx->Pixel.ReadBuffer == 0) {
#line 18278
    *params = (unsigned char)0;
  } else {
#line 18278
    *params = (unsigned char)1;
  }
#line 18279
  break;
  case 3349: 
#line 18281
  if (ctx->Pixel.RedBias == 0.0F) {
#line 18281
    *params = (unsigned char)0;
  } else {
#line 18281
    *params = (unsigned char)1;
  }
#line 18282
  break;
  case 3410: 
#line 18284
  if ((ctx->Visual)->RedBits == 0) {
#line 18284
    *params = (unsigned char)0;
  } else {
#line 18284
    *params = (unsigned char)1;
  }
#line 18285
  break;
  case 3348: 
#line 18287
  if (ctx->Pixel.RedScale == 0.0F) {
#line 18287
    *params = (unsigned char)0;
  } else {
#line 18287
    *params = (unsigned char)1;
  }
#line 18288
  break;
  case 3136: 
#line 18290
  if (ctx->RenderMode == 0) {
#line 18290
    *params = (unsigned char)0;
  } else {
#line 18290
    *params = (unsigned char)1;
  }
#line 18291
  break;
  case 3121: 
#line 18293
  *params = (ctx->Visual)->RGBAflag;
#line 18294
  break;
  case 3088: 
#line 18296
  if (ctx->Scissor.X == 0) {
#line 18296
    *(params + 0) = (unsigned char)0;
  } else {
#line 18296
    *(params + 0) = (unsigned char)1;
  }
#line 18297
  if (ctx->Scissor.Y == 0) {
#line 18297
    *(params + 1) = (unsigned char)0;
  } else {
#line 18297
    *(params + 1) = (unsigned char)1;
  }
#line 18298
  if (ctx->Scissor.Width == 0) {
#line 18298
    *(params + 2) = (unsigned char)0;
  } else {
#line 18298
    *(params + 2) = (unsigned char)1;
  }
#line 18299
  if (ctx->Scissor.Height == 0) {
#line 18299
    *(params + 3) = (unsigned char)0;
  } else {
#line 18299
    *(params + 3) = (unsigned char)1;
  }
#line 18300
  break;
  case 3089: 
#line 18302
  *params = ctx->Scissor.Enabled;
#line 18303
  break;
  case 2900: 
#line 18305
  if (ctx->Light.ShadeModel == 0) {
#line 18305
    *params = (unsigned char)0;
  } else {
#line 18305
    *params = (unsigned char)1;
  }
#line 18306
  break;
  case 33275: 
#line 18308
  *params = ctx->Texture.SharedPalette;
#line 18309
  break;
  case 3415: 
#line 18311
  if ((ctx->Visual)->StencilBits == 0) {
#line 18311
    *params = (unsigned char)0;
  } else {
#line 18311
    *params = (unsigned char)1;
  }
#line 18312
  break;
  case 2961: 
#line 18314
  if ((int )ctx->Stencil.Clear == 0) {
#line 18314
    *params = (unsigned char)0;
  } else {
#line 18314
    *params = (unsigned char)1;
  }
#line 18315
  break;
  case 2964: 
#line 18317
  if (ctx->Stencil.FailFunc == 0) {
#line 18317
    *params = (unsigned char)0;
  } else {
#line 18317
    *params = (unsigned char)1;
  }
#line 18318
  break;
  case 2962: 
#line 18320
  if (ctx->Stencil.Function == 0) {
#line 18320
    *params = (unsigned char)0;
  } else {
#line 18320
    *params = (unsigned char)1;
  }
#line 18321
  break;
  case 2965: 
#line 18323
  if (ctx->Stencil.ZFailFunc == 0) {
#line 18323
    *params = (unsigned char)0;
  } else {
#line 18323
    *params = (unsigned char)1;
  }
#line 18324
  break;
  case 2966: 
#line 18326
  if (ctx->Stencil.ZPassFunc == 0) {
#line 18326
    *params = (unsigned char)0;
  } else {
#line 18326
    *params = (unsigned char)1;
  }
#line 18327
  break;
  case 2967: 
#line 18329
  if ((int )ctx->Stencil.Ref == 0) {
#line 18329
    *params = (unsigned char)0;
  } else {
#line 18329
    *params = (unsigned char)1;
  }
#line 18330
  break;
  case 2960: 
#line 18332
  *params = ctx->Stencil.Enabled;
#line 18333
  break;
  case 2963: 
#line 18335
  if ((int )ctx->Stencil.ValueMask == 0) {
#line 18335
    *params = (unsigned char)0;
  } else {
#line 18335
    *params = (unsigned char)1;
  }
#line 18336
  break;
  case 2968: 
#line 18338
  if ((int )ctx->Stencil.WriteMask == 0) {
#line 18338
    *params = (unsigned char)0;
  } else {
#line 18338
    *params = (unsigned char)1;
  }
#line 18339
  break;
  case 3123: 
#line 18341
  *params = (unsigned char)0;
#line 18342
  break;
  case 3408: 
#line 18344
  *params = (unsigned char)0;
#line 18345
  break;
  case 3552: 
#line 18347
  if (ctx->Texture.Enabled & 1U) {
#line 18347
    *params = (unsigned char)1;
  } else {
#line 18347
    *params = (unsigned char)0;
  }
#line 18348
  break;
  case 3553: 
#line 18350
  if (ctx->Texture.Enabled & 2U) {
#line 18350
    *params = (unsigned char)1;
  } else {
#line 18350
    *params = (unsigned char)0;
  }
#line 18351
  break;
  case 32879: 
#line 18353
  if (ctx->Texture.Enabled & 4U) {
#line 18353
    *params = (unsigned char)1;
  } else {
#line 18353
    *params = (unsigned char)0;
  }
#line 18354
  break;
  case 8705: 
#line 18356
  if (ctx->Texture.EnvColor[0] == 0.0F) {
#line 18356
    *(params + 0) = (unsigned char)0;
  } else {
#line 18356
    *(params + 0) = (unsigned char)1;
  }
#line 18357
  if (ctx->Texture.EnvColor[1] == 0.0F) {
#line 18357
    *(params + 1) = (unsigned char)0;
  } else {
#line 18357
    *(params + 1) = (unsigned char)1;
  }
#line 18358
  if (ctx->Texture.EnvColor[2] == 0.0F) {
#line 18358
    *(params + 2) = (unsigned char)0;
  } else {
#line 18358
    *(params + 2) = (unsigned char)1;
  }
#line 18359
  if (ctx->Texture.EnvColor[3] == 0.0F) {
#line 18359
    *(params + 3) = (unsigned char)0;
  } else {
#line 18359
    *(params + 3) = (unsigned char)1;
  }
#line 18360
  break;
  case 8704: 
#line 18362
  if (ctx->Texture.EnvMode == 0) {
#line 18362
    *params = (unsigned char)0;
  } else {
#line 18362
    *params = (unsigned char)1;
  }
#line 18363
  break;
  case 3168: 
#line 18365
  if (ctx->Texture.TexGenEnabled & 4U) {
#line 18365
    *params = (unsigned char)1;
  } else {
#line 18365
    *params = (unsigned char)0;
  }
#line 18366
  break;
  case 3169: 
#line 18368
  if (ctx->Texture.TexGenEnabled & 8U) {
#line 18368
    *params = (unsigned char)1;
  } else {
#line 18368
    *params = (unsigned char)0;
  }
#line 18369
  break;
  case 3170: 
#line 18371
  if (ctx->Texture.TexGenEnabled & 2U) {
#line 18371
    *params = (unsigned char)1;
  } else {
#line 18371
    *params = (unsigned char)0;
  }
#line 18372
  break;
  case 3171: 
#line 18374
  if (ctx->Texture.TexGenEnabled & 1U) {
#line 18374
    *params = (unsigned char)1;
  } else {
#line 18374
    *params = (unsigned char)0;
  }
#line 18375
  break;
  case 2984: 
#line 18377
  i = 0U;
#line 18377
  while (i < 16U) {
#line 18378
    if (ctx->TextureMatrix[i] == 0.0F) {
#line 18378
      *(params + i) = (unsigned char)0;
    } else {
#line 18378
      *(params + i) = (unsigned char)1;
    }
#line 18377
    i ++;
  }
#line 18380
  break;
  case 2981: 
#line 18382
  if (ctx->TextureStackDepth == 0U) {
#line 18382
    *params = (unsigned char)0;
  } else {
#line 18382
    *params = (unsigned char)1;
  }
#line 18383
  break;
  case 3317: 
#line 18385
  if (ctx->Unpack.Alignment == 0) {
#line 18385
    *params = (unsigned char)0;
  } else {
#line 18385
    *params = (unsigned char)1;
  }
#line 18386
  break;
  case 3313: 
#line 18388
  *params = ctx->Unpack.LsbFirst;
#line 18389
  break;
  case 3314: 
#line 18391
  if (ctx->Unpack.RowLength == 0) {
#line 18391
    *params = (unsigned char)0;
  } else {
#line 18391
    *params = (unsigned char)1;
  }
#line 18392
  break;
  case 3316: 
#line 18394
  if (ctx->Unpack.SkipPixels == 0) {
#line 18394
    *params = (unsigned char)0;
  } else {
#line 18394
    *params = (unsigned char)1;
  }
#line 18395
  break;
  case 3315: 
#line 18397
  if (ctx->Unpack.SkipRows == 0) {
#line 18397
    *params = (unsigned char)0;
  } else {
#line 18397
    *params = (unsigned char)1;
  }
#line 18398
  break;
  case 3312: 
#line 18400
  *params = ctx->Unpack.SwapBytes;
#line 18401
  break;
  case 32877: 
#line 18403
  *params = (unsigned char )ctx->Unpack.SkipImages;
#line 18404
  break;
  case 32878: 
#line 18406
  *params = (unsigned char )ctx->Unpack.ImageHeight;
#line 18407
  break;
  case 2978: 
#line 18409
  if (ctx->Viewport.X == 0) {
#line 18409
    *(params + 0) = (unsigned char)0;
  } else {
#line 18409
    *(params + 0) = (unsigned char)1;
  }
#line 18410
  if (ctx->Viewport.Y == 0) {
#line 18410
    *(params + 1) = (unsigned char)0;
  } else {
#line 18410
    *(params + 1) = (unsigned char)1;
  }
#line 18411
  if (ctx->Viewport.Width == 0) {
#line 18411
    *(params + 2) = (unsigned char)0;
  } else {
#line 18411
    *(params + 2) = (unsigned char)1;
  }
#line 18412
  if (ctx->Viewport.Height == 0) {
#line 18412
    *(params + 3) = (unsigned char)0;
  } else {
#line 18412
    *(params + 3) = (unsigned char)1;
  }
#line 18413
  break;
  case 3350: 
#line 18415
  if (ctx->Pixel.ZoomX == 0.0F) {
#line 18415
    *params = (unsigned char)0;
  } else {
#line 18415
    *params = (unsigned char)1;
  }
#line 18416
  break;
  case 3351: 
#line 18418
  if (ctx->Pixel.ZoomY == 0.0F) {
#line 18418
    *params = (unsigned char)0;
  } else {
#line 18418
    *params = (unsigned char)1;
  }
#line 18419
  break;
  case 32890: 
#line 18421
  if (ctx->Array.VertexSize == 0) {
#line 18421
    *params = (unsigned char)0;
  } else {
#line 18421
    *params = (unsigned char)1;
  }
#line 18422
  break;
  case 32891: 
#line 18424
  if (ctx->Array.VertexType == 0) {
#line 18424
    *params = (unsigned char)0;
  } else {
#line 18424
    *params = (unsigned char)1;
  }
#line 18425
  break;
  case 32892: 
#line 18427
  if (ctx->Array.VertexStride == 0) {
#line 18427
    *params = (unsigned char)0;
  } else {
#line 18427
    *params = (unsigned char)1;
  }
#line 18428
  break;
  case 32893: 
#line 18430
  *params = (unsigned char)0;
#line 18431
  break;
  case 32894: 
#line 18433
  if (ctx->Array.NormalType == 0) {
#line 18433
    *params = (unsigned char)0;
  } else {
#line 18433
    *params = (unsigned char)1;
  }
#line 18434
  break;
  case 32895: 
#line 18436
  if (ctx->Array.NormalStride == 0) {
#line 18436
    *params = (unsigned char)0;
  } else {
#line 18436
    *params = (unsigned char)1;
  }
#line 18437
  break;
  case 32896: 
#line 18439
  *params = (unsigned char)0;
#line 18440
  break;
  case 32897: 
#line 18442
  if (ctx->Array.ColorSize == 0) {
#line 18442
    *params = (unsigned char)0;
  } else {
#line 18442
    *params = (unsigned char)1;
  }
#line 18443
  break;
  case 32898: 
#line 18445
  if (ctx->Array.ColorType == 0) {
#line 18445
    *params = (unsigned char)0;
  } else {
#line 18445
    *params = (unsigned char)1;
  }
#line 18446
  break;
  case 32899: 
#line 18448
  if (ctx->Array.ColorStride == 0) {
#line 18448
    *params = (unsigned char)0;
  } else {
#line 18448
    *params = (unsigned char)1;
  }
#line 18449
  break;
  case 32900: 
#line 18451
  *params = (unsigned char)0;
#line 18452
  break;
  case 32901: 
#line 18454
  if (ctx->Array.IndexType == 0) {
#line 18454
    *params = (unsigned char)0;
  } else {
#line 18454
    *params = (unsigned char)1;
  }
#line 18455
  break;
  case 32902: 
#line 18457
  if (ctx->Array.IndexStride == 0) {
#line 18457
    *params = (unsigned char)0;
  } else {
#line 18457
    *params = (unsigned char)1;
  }
#line 18458
  break;
  case 32903: 
#line 18460
  *params = (unsigned char)0;
#line 18461
  break;
  case 32904: 
#line 18463
  if (ctx->Array.TexCoordSize == 0) {
#line 18463
    *params = (unsigned char)0;
  } else {
#line 18463
    *params = (unsigned char)1;
  }
#line 18464
  break;
  case 32905: 
#line 18466
  if (ctx->Array.TexCoordType == 0) {
#line 18466
    *params = (unsigned char)0;
  } else {
#line 18466
    *params = (unsigned char)1;
  }
#line 18467
  break;
  case 32906: 
#line 18469
  if (ctx->Array.TexCoordStride == 0) {
#line 18469
    *params = (unsigned char)0;
  } else {
#line 18469
    *params = (unsigned char)1;
  }
#line 18470
  break;
  case 32907: 
#line 18472
  *params = (unsigned char)0;
#line 18473
  break;
  case 32908: 
#line 18475
  if (ctx->Array.EdgeFlagStride == 0) {
#line 18475
    *params = (unsigned char)0;
  } else {
#line 18475
    *params = (unsigned char)1;
  }
#line 18476
  break;
  case 32889: 
#line 18478
  *params = (unsigned char)0;
#line 18479
  break;
  case 32872: 
#line 18481
  if ((ctx->Texture.Current1D)->Name == 0U) {
#line 18481
    *params = (unsigned char)0;
  } else {
#line 18481
    *params = (unsigned char)1;
  }
#line 18482
  break;
  case 32873: 
#line 18484
  if ((ctx->Texture.Current2D)->Name == 0U) {
#line 18484
    *params = (unsigned char)0;
  } else {
#line 18484
    *params = (unsigned char)1;
  }
#line 18485
  break;
  case 32874: 
#line 18487
  if ((ctx->Texture.Current2D)->Name == 0U) {
#line 18487
    *params = (unsigned char)0;
  } else {
#line 18487
    *params = (unsigned char)1;
  }
#line 18488
  break;
  default: 
#line 18490
  gl_error(ctx, 1280, "glGetBooleanv");
  }
#line 18492
  return;
}
}
#line 18493 "D:/a/test/177.c"
void gl_GetDoublev(GLcontext *ctx , GLenum pname , GLdouble *params ) 
{ GLuint i ;
  GLint tmp___0 ;

  {
#line 18496
  if (ctx->Primitive != 6656) {
#line 18497
    gl_error(ctx, 1282, "glGetDoublev");
#line 18498
    return;
  }
#line 18500
  switch (pname) {
  case 3416: 
  case 3417: 
  case 3418: 
  case 3419: 
#line 18505
  *params = (double )(ctx->Visual)->AccumBits;
#line 18506
  break;
  case 2944: 
#line 18508
  *(params + 0) = (double )ctx->Accum.ClearColor[0];
#line 18509
  *(params + 1) = (double )ctx->Accum.ClearColor[1];
#line 18510
  *(params + 2) = (double )ctx->Accum.ClearColor[2];
#line 18511
  *(params + 3) = (double )ctx->Accum.ClearColor[3];
#line 18512
  break;
  case 3357: 
#line 18514
  *params = (double )ctx->Pixel.AlphaBias;
#line 18515
  break;
  case 3413: 
#line 18517
  *params = (double )(ctx->Visual)->AlphaBits;
#line 18518
  break;
  case 3356: 
#line 18520
  *params = (double )ctx->Pixel.AlphaScale;
#line 18521
  break;
  case 3008: 
#line 18523
  *params = (double )ctx->Color.AlphaEnabled;
#line 18524
  break;
  case 3009: 
#line 18526
  *params = (double )ctx->Color.AlphaFunc;
#line 18527
  break;
  case 3010: 
#line 18529
  *params = (double )ctx->Color.AlphaRef;
#line 18530
  break;
  case 2992: 
#line 18532
  *params = (double )ctx->AttribStackDepth;
#line 18533
  break;
  case 3456: 
#line 18535
  *params = (double )ctx->Eval.AutoNormal;
#line 18536
  break;
  case 3072: 
#line 18538
  *params = (double )0;
#line 18539
  break;
  case 3042: 
#line 18541
  *params = (double )ctx->Color.BlendEnabled;
#line 18542
  break;
  case 3040: 
#line 18544
  *params = (double )ctx->Color.BlendDst;
#line 18545
  break;
  case 3041: 
#line 18547
  *params = (double )ctx->Color.BlendSrc;
#line 18548
  break;
  case 32777: 
#line 18550
  *params = (double )ctx->Color.BlendEquation;
#line 18551
  break;
  case 32773: 
#line 18553
  *(params + 0) = (double )ctx->Color.BlendColor[0];
#line 18554
  *(params + 1) = (double )ctx->Color.BlendColor[1];
#line 18555
  *(params + 2) = (double )ctx->Color.BlendColor[2];
#line 18556
  *(params + 3) = (double )ctx->Color.BlendColor[3];
#line 18557
  break;
  case 3355: 
#line 18559
  *params = (double )ctx->Pixel.BlueBias;
#line 18560
  break;
  case 3412: 
#line 18562
  *params = (double )(ctx->Visual)->BlueBits;
#line 18563
  break;
  case 3354: 
#line 18565
  *params = (double )ctx->Pixel.BlueScale;
#line 18566
  break;
  case 2993: 
#line 18568
  *params = (double )ctx->ClientAttribStackDepth;
#line 18569
  break;
  case 12288: 
  case 12289: 
  case 12290: 
  case 12291: 
  case 12292: 
  case 12293: 
#line 18576
  *params = (double )ctx->Transform.ClipEnabled[pname - 12288];
#line 18577
  break;
  case 3106: 
#line 18579
  *(params + 0) = (double )ctx->Color.ClearColor[0];
#line 18580
  *(params + 1) = (double )ctx->Color.ClearColor[1];
#line 18581
  *(params + 2) = (double )ctx->Color.ClearColor[2];
#line 18582
  *(params + 3) = (double )ctx->Color.ClearColor[3];
#line 18583
  break;
  case 2903: 
#line 18585
  *params = (double )ctx->Light.ColorMaterialEnabled;
#line 18586
  break;
  case 2901: 
#line 18588
  *params = (double )ctx->Light.ColorMaterialFace;
#line 18589
  break;
  case 2902: 
#line 18591
  *params = (double )ctx->Light.ColorMaterialMode;
#line 18592
  break;
  case 3107: 
#line 18594
  if (ctx->Color.ColorMask & 8U) {
#line 18594
    *(params + 0) = 1.0;
  } else {
#line 18594
    *(params + 0) = 0.0;
  }
#line 18595
  if (ctx->Color.ColorMask & 4U) {
#line 18595
    *(params + 1) = 1.0;
  } else {
#line 18595
    *(params + 1) = 0.0;
  }
#line 18596
  if (ctx->Color.ColorMask & 2U) {
#line 18596
    *(params + 2) = 1.0;
  } else {
#line 18596
    *(params + 2) = 0.0;
  }
#line 18597
  if (ctx->Color.ColorMask & 1U) {
#line 18597
    *(params + 3) = 1.0;
  } else {
#line 18597
    *(params + 3) = 0.0;
  }
#line 18598
  break;
  case 2884: 
#line 18600
  *params = (double )ctx->Polygon.CullFlag;
#line 18601
  break;
  case 2885: 
#line 18603
  *params = (double )ctx->Polygon.CullFaceMode;
#line 18604
  break;
  case 2816: 
#line 18606
  *(params + 0) = (double )((float )ctx->Current.ByteColor[0] * (ctx->Visual)->InvRedScale);
#line 18607
  *(params + 1) = (double )((float )ctx->Current.ByteColor[1] * (ctx->Visual)->InvGreenScale);
#line 18608
  *(params + 2) = (double )((float )ctx->Current.ByteColor[2] * (ctx->Visual)->InvBlueScale);
#line 18609
  *(params + 3) = (double )((float )ctx->Current.ByteColor[3] * (ctx->Visual)->InvAlphaScale);
#line 18610
  break;
  case 2817: 
#line 18612
  *params = (double )ctx->Current.Index;
#line 18613
  break;
  case 2818: 
#line 18615
  *(params + 0) = (double )ctx->Current.Normal[0];
#line 18616
  *(params + 1) = (double )ctx->Current.Normal[1];
#line 18617
  *(params + 2) = (double )ctx->Current.Normal[2];
#line 18618
  break;
  case 2820: 
#line 18620
  *(params + 0) = (double )ctx->Current.RasterColor[0];
#line 18621
  *(params + 1) = (double )ctx->Current.RasterColor[1];
#line 18622
  *(params + 2) = (double )ctx->Current.RasterColor[2];
#line 18623
  *(params + 3) = (double )ctx->Current.RasterColor[3];
#line 18624
  break;
  case 2825: 
#line 18626
  *(params + 0) = (double )ctx->Current.RasterDistance;
#line 18627
  break;
  case 2821: 
#line 18629
  *params = (double )ctx->Current.RasterIndex;
#line 18630
  break;
  case 2823: 
#line 18632
  *(params + 0) = (double )ctx->Current.RasterPos[0];
#line 18633
  *(params + 1) = (double )ctx->Current.RasterPos[1];
#line 18634
  *(params + 2) = (double )ctx->Current.RasterPos[2];
#line 18635
  *(params + 3) = (double )ctx->Current.RasterPos[3];
#line 18636
  break;
  case 2822: 
#line 18638
  *(params + 0) = (double )ctx->Current.RasterTexCoord[0];
#line 18639
  *(params + 1) = (double )ctx->Current.RasterTexCoord[1];
#line 18640
  *(params + 2) = (double )ctx->Current.RasterTexCoord[2];
#line 18641
  *(params + 3) = (double )ctx->Current.RasterTexCoord[3];
#line 18642
  break;
  case 2824: 
#line 18644
  *params = (double )ctx->Current.RasterPosValid;
#line 18645
  break;
  case 2819: 
#line 18647
  *(params + 0) = (double )ctx->Current.TexCoord[0];
#line 18648
  *(params + 1) = (double )ctx->Current.TexCoord[1];
#line 18649
  *(params + 2) = (double )ctx->Current.TexCoord[2];
#line 18650
  *(params + 3) = (double )ctx->Current.TexCoord[3];
#line 18651
  break;
  case 3359: 
#line 18653
  *params = (double )ctx->Pixel.DepthBias;
#line 18654
  break;
  case 3414: 
#line 18656
  *params = (double )(ctx->Visual)->DepthBits;
#line 18657
  break;
  case 2931: 
#line 18659
  *params = (double )ctx->Depth.Clear;
#line 18660
  break;
  case 2932: 
#line 18662
  *params = (double )ctx->Depth.Func;
#line 18663
  break;
  case 2928: 
#line 18665
  *(params + 0) = (double )ctx->Viewport.Near;
#line 18666
  *(params + 1) = (double )ctx->Viewport.Far;
#line 18667
  break;
  case 3358: 
#line 18669
  *params = (double )ctx->Pixel.DepthScale;
#line 18670
  break;
  case 2929: 
#line 18672
  *params = (double )ctx->Depth.Test;
#line 18673
  break;
  case 2930: 
#line 18675
  *params = (double )ctx->Depth.Mask;
#line 18676
  break;
  case 3024: 
#line 18678
  *params = (double )ctx->Color.DitherFlag;
#line 18679
  break;
  case 3122: 
#line 18681
  *params = (double )(ctx->Visual)->DBflag;
#line 18682
  break;
  case 3073: 
#line 18684
  *params = (double )ctx->Color.DrawBuffer;
#line 18685
  break;
  case 2883: 
#line 18687
  *params = (double )ctx->Current.EdgeFlag;
#line 18688
  break;
  case 3569: 
#line 18690
  *params = (double )ctx->Feedback.BufferSize;
#line 18691
  break;
  case 3570: 
#line 18693
  *params = (double )ctx->Feedback.Type;
#line 18694
  break;
  case 2912: 
#line 18696
  *params = (double )ctx->Fog.Enabled;
#line 18697
  break;
  case 2918: 
#line 18699
  *(params + 0) = (double )ctx->Fog.Color[0];
#line 18700
  *(params + 1) = (double )ctx->Fog.Color[1];
#line 18701
  *(params + 2) = (double )ctx->Fog.Color[2];
#line 18702
  *(params + 3) = (double )ctx->Fog.Color[3];
#line 18703
  break;
  case 2914: 
#line 18705
  *params = (double )ctx->Fog.Density;
#line 18706
  break;
  case 2916: 
#line 18708
  *params = (double )ctx->Fog.End;
#line 18709
  break;
  case 3156: 
#line 18711
  *params = (double )ctx->Hint.Fog;
#line 18712
  break;
  case 2913: 
#line 18714
  *params = (double )ctx->Fog.Index;
#line 18715
  break;
  case 2917: 
#line 18717
  *params = (double )ctx->Fog.Mode;
#line 18718
  break;
  case 2915: 
#line 18720
  *params = (double )ctx->Fog.Start;
#line 18721
  break;
  case 2886: 
#line 18723
  *params = (double )ctx->Polygon.FrontFace;
#line 18724
  break;
  case 3353: 
#line 18726
  *params = (double )ctx->Pixel.GreenBias;
#line 18727
  break;
  case 3411: 
#line 18729
  *params = (double )(ctx->Visual)->GreenBits;
#line 18730
  break;
  case 3352: 
#line 18732
  *params = (double )ctx->Pixel.GreenScale;
#line 18733
  break;
  case 3409: 
#line 18735
  *params = (double )(ctx->Visual)->IndexBits;
#line 18736
  break;
  case 3104: 
#line 18738
  *params = (double )ctx->Color.ClearIndex;
#line 18739
  break;
  case 3120: 
#line 18741
  if ((ctx->Visual)->RGBAflag) {
#line 18741
    *params = 0.0;
  } else {
#line 18741
    *params = 1.0;
  }
#line 18742
  break;
  case 3347: 
#line 18744
  *params = (double )ctx->Pixel.IndexOffset;
#line 18745
  break;
  case 3346: 
#line 18747
  *params = (double )ctx->Pixel.IndexShift;
#line 18748
  break;
  case 3105: 
#line 18750
  *params = (double )ctx->Color.IndexMask;
#line 18751
  break;
  case 16384: 
  case 16385: 
  case 16386: 
  case 16387: 
  case 16388: 
  case 16389: 
  case 16390: 
  case 16391: 
#line 18760
  *params = (double )ctx->Light.Light[pname - 16384].Enabled;
#line 18761
  break;
  case 2896: 
#line 18763
  *params = (double )ctx->Light.Enabled;
#line 18764
  break;
  case 2899: 
#line 18766
  *(params + 0) = (double )ctx->Light.Model.Ambient[0];
#line 18767
  *(params + 1) = (double )ctx->Light.Model.Ambient[1];
#line 18768
  *(params + 2) = (double )ctx->Light.Model.Ambient[2];
#line 18769
  *(params + 3) = (double )ctx->Light.Model.Ambient[3];
#line 18770
  break;
  case 2897: 
#line 18772
  *params = (double )ctx->Light.Model.LocalViewer;
#line 18773
  break;
  case 2898: 
#line 18775
  *params = (double )ctx->Light.Model.TwoSide;
#line 18776
  break;
  case 2848: 
#line 18778
  *params = (double )ctx->Line.SmoothFlag;
#line 18779
  break;
  case 3154: 
#line 18781
  *params = (double )ctx->Hint.LineSmooth;
#line 18782
  break;
  case 2852: 
#line 18784
  *params = (double )ctx->Line.StippleFlag;
#line 18785
  break;
  case 2853: 
#line 18787
  *params = (double )ctx->Line.StipplePattern;
#line 18788
  break;
  case 2854: 
#line 18790
  *params = (double )ctx->Line.StippleFactor;
#line 18791
  break;
  case 2849: 
#line 18793
  *params = (double )ctx->Line.Width;
#line 18794
  break;
  case 2851: 
#line 18796
  *params = 1.0;
#line 18797
  break;
  case 2850: 
#line 18799
  *(params + 0) = 1.0;
#line 18800
  *(params + 1) = 10.0;
#line 18801
  break;
  case 2866: 
#line 18803
  *params = (double )ctx->List.ListBase;
#line 18804
  break;
  case 2867: 
#line 18806
  tmp___0 = gl_list_index();
#line 18806
  *params = (double )tmp___0;
#line 18807
  break;
  case 2864: 
#line 18809
  if (ctx->ExecuteFlag) {
#line 18809
    *params = (double )4865;
  } else {
#line 18809
    *params = (double )4864;
  }
#line 18811
  break;
  case 3057: 
#line 18813
  *params = (double )ctx->Color.IndexLogicOpEnabled;
#line 18814
  break;
  case 3058: 
#line 18816
  *params = (double )ctx->Color.ColorLogicOpEnabled;
#line 18817
  break;
  case 3056: 
#line 18819
  *params = (double )ctx->Color.LogicOp;
#line 18820
  break;
  case 3472: 
#line 18822
  *params = (double )ctx->Eval.Map1Color4;
#line 18823
  break;
  case 3536: 
#line 18825
  *(params + 0) = (double )ctx->Eval.MapGrid1u1;
#line 18826
  *(params + 1) = (double )ctx->Eval.MapGrid1u2;
#line 18827
  break;
  case 3537: 
#line 18829
  *params = (double )ctx->Eval.MapGrid1un;
#line 18830
  break;
  case 3473: 
#line 18832
  *params = (double )ctx->Eval.Map1Index;
#line 18833
  break;
  case 3474: 
#line 18835
  *params = (double )ctx->Eval.Map1Normal;
#line 18836
  break;
  case 3475: 
#line 18838
  *params = (double )ctx->Eval.Map1TextureCoord1;
#line 18839
  break;
  case 3476: 
#line 18841
  *params = (double )ctx->Eval.Map1TextureCoord2;
#line 18842
  break;
  case 3477: 
#line 18844
  *params = (double )ctx->Eval.Map1TextureCoord3;
#line 18845
  break;
  case 3478: 
#line 18847
  *params = (double )ctx->Eval.Map1TextureCoord4;
#line 18848
  break;
  case 3479: 
#line 18850
  *params = (double )ctx->Eval.Map1Vertex3;
#line 18851
  break;
  case 3480: 
#line 18853
  *params = (double )ctx->Eval.Map1Vertex4;
#line 18854
  break;
  case 3504: 
#line 18856
  *params = (double )ctx->Eval.Map2Color4;
#line 18857
  break;
  case 3538: 
#line 18859
  *(params + 0) = (double )ctx->Eval.MapGrid2u1;
#line 18860
  *(params + 1) = (double )ctx->Eval.MapGrid2u2;
#line 18861
  *(params + 2) = (double )ctx->Eval.MapGrid2v1;
#line 18862
  *(params + 3) = (double )ctx->Eval.MapGrid2v2;
#line 18863
  break;
  case 3539: 
#line 18865
  *(params + 0) = (double )ctx->Eval.MapGrid2un;
#line 18866
  *(params + 1) = (double )ctx->Eval.MapGrid2vn;
#line 18867
  break;
  case 3505: 
#line 18869
  *params = (double )ctx->Eval.Map2Index;
#line 18870
  break;
  case 3506: 
#line 18872
  *params = (double )ctx->Eval.Map2Normal;
#line 18873
  break;
  case 3507: 
#line 18875
  *params = (double )ctx->Eval.Map2TextureCoord1;
#line 18876
  break;
  case 3508: 
#line 18878
  *params = (double )ctx->Eval.Map2TextureCoord2;
#line 18879
  break;
  case 3509: 
#line 18881
  *params = (double )ctx->Eval.Map2TextureCoord3;
#line 18882
  break;
  case 3510: 
#line 18884
  *params = (double )ctx->Eval.Map2TextureCoord4;
#line 18885
  break;
  case 3511: 
#line 18887
  *params = (double )ctx->Eval.Map2Vertex3;
#line 18888
  break;
  case 3512: 
#line 18890
  *params = (double )ctx->Eval.Map2Vertex4;
#line 18891
  break;
  case 3344: 
#line 18893
  *params = (double )ctx->Pixel.MapColorFlag;
#line 18894
  break;
  case 3345: 
#line 18896
  *params = (double )ctx->Pixel.MapStencilFlag;
#line 18897
  break;
  case 2976: 
#line 18899
  *params = (double )ctx->Transform.MatrixMode;
#line 18900
  break;
  case 3381: 
#line 18902
  *params = (double )16;
#line 18903
  break;
  case 3387: 
#line 18905
  *params = (double )16;
#line 18906
  break;
  case 3378: 
#line 18908
  *params = (double )6;
#line 18909
  break;
  case 3376: 
#line 18911
  *params = (double )30;
#line 18912
  break;
  case 3377: 
#line 18914
  *params = (double )8;
#line 18915
  break;
  case 2865: 
#line 18917
  *params = (double )64;
#line 18918
  break;
  case 3382: 
#line 18920
  *params = (double )32;
#line 18921
  break;
  case 3383: 
#line 18923
  *params = (double )64;
#line 18924
  break;
  case 3380: 
#line 18926
  *params = (double )256;
#line 18927
  break;
  case 3384: 
#line 18929
  *params = (double )32;
#line 18930
  break;
  case 3379: 
#line 18932
  *params = (double )(1 << 10);
#line 18933
  break;
  case 3385: 
#line 18935
  *params = (double )10;
#line 18936
  break;
  case 3386: 
#line 18938
  *(params + 0) = (double )640;
#line 18939
  *(params + 1) = (double )400;
#line 18940
  break;
  case 2982: 
#line 18942
  i = 0U;
#line 18942
  while (i < 16U) {
#line 18943
    *(params + i) = (double )ctx->ModelViewMatrix[i];
#line 18942
    i ++;
  }
#line 18945
  break;
  case 2979: 
#line 18947
  *params = (double )ctx->ModelViewStackDepth;
#line 18948
  break;
  case 3440: 
#line 18950
  *params = (double )ctx->Select.NameStackDepth;
#line 18951
  break;
  case 2977: 
#line 18953
  *params = (double )ctx->Transform.Normalize;
#line 18954
  break;
  case 3333: 
#line 18956
  *params = (double )ctx->Pack.Alignment;
#line 18957
  break;
  case 3329: 
#line 18959
  *params = (double )ctx->Pack.LsbFirst;
#line 18960
  break;
  case 3330: 
#line 18962
  *params = (double )ctx->Pack.RowLength;
#line 18963
  break;
  case 3332: 
#line 18965
  *params = (double )ctx->Pack.SkipPixels;
#line 18966
  break;
  case 3331: 
#line 18968
  *params = (double )ctx->Pack.SkipRows;
#line 18969
  break;
  case 3328: 
#line 18971
  *params = (double )ctx->Pack.SwapBytes;
#line 18972
  break;
  case 32875: 
#line 18974
  *params = (double )ctx->Pack.SkipImages;
#line 18975
  break;
  case 32876: 
#line 18977
  *params = (double )ctx->Pack.ImageHeight;
#line 18978
  break;
  case 3152: 
#line 18980
  *params = (double )ctx->Hint.PerspectiveCorrection;
#line 18981
  break;
  case 3257: 
#line 18983
  *params = (double )ctx->Pixel.MapAtoAsize;
#line 18984
  break;
  case 3256: 
#line 18986
  *params = (double )ctx->Pixel.MapBtoBsize;
#line 18987
  break;
  case 3255: 
#line 18989
  *params = (double )ctx->Pixel.MapGtoGsize;
#line 18990
  break;
  case 3253: 
#line 18992
  *params = (double )ctx->Pixel.MapItoAsize;
#line 18993
  break;
  case 3252: 
#line 18995
  *params = (double )ctx->Pixel.MapItoBsize;
#line 18996
  break;
  case 3251: 
#line 18998
  *params = (double )ctx->Pixel.MapItoGsize;
#line 18999
  break;
  case 3248: 
#line 19001
  *params = (double )ctx->Pixel.MapItoIsize;
#line 19002
  break;
  case 3250: 
#line 19004
  *params = (double )ctx->Pixel.MapItoRsize;
#line 19005
  break;
  case 3254: 
#line 19007
  *params = (double )ctx->Pixel.MapRtoRsize;
#line 19008
  break;
  case 3249: 
#line 19010
  *params = (double )ctx->Pixel.MapStoSsize;
#line 19011
  break;
  case 2833: 
#line 19013
  *params = (double )ctx->Point.Size;
#line 19014
  break;
  case 2835: 
#line 19016
  *params = 0.1;
#line 19017
  break;
  case 2834: 
#line 19019
  *(params + 0) = 1.0;
#line 19020
  *(params + 1) = 10.0;
#line 19021
  break;
  case 2832: 
#line 19023
  *params = (double )ctx->Point.SmoothFlag;
#line 19024
  break;
  case 3153: 
#line 19026
  *params = (double )ctx->Hint.PointSmooth;
#line 19027
  break;
  case 33062: 
#line 19029
  *params = (double )ctx->Point.MinSize;
#line 19030
  break;
  case 33063: 
#line 19032
  *params = (double )ctx->Point.MaxSize;
#line 19033
  break;
  case 33064: 
#line 19035
  *params = (double )ctx->Point.Threshold;
#line 19036
  break;
  case 33065: 
#line 19038
  *(params + 0) = (double )ctx->Point.Params[0];
#line 19039
  *(params + 1) = (double )ctx->Point.Params[1];
#line 19040
  *(params + 2) = (double )ctx->Point.Params[2];
#line 19041
  break;
  case 2880: 
#line 19043
  *(params + 0) = (double )ctx->Polygon.FrontMode;
#line 19044
  *(params + 1) = (double )ctx->Polygon.BackMode;
#line 19045
  break;
  case 32824: 
#line 19052
  *params = (double )ctx->Polygon.OffsetFactor;
#line 19053
  break;
  case 10752: 
#line 19055
  *params = (double )ctx->Polygon.OffsetUnits;
#line 19056
  break;
  case 2881: 
#line 19058
  *params = (double )ctx->Polygon.SmoothFlag;
#line 19059
  break;
  case 3155: 
#line 19061
  *params = (double )ctx->Hint.PolygonSmooth;
#line 19062
  break;
  case 2882: 
#line 19064
  i = 0U;
#line 19064
  while (i < 32U) {
#line 19065
    *(params + i) = (double )ctx->PolygonStipple[i];
#line 19064
    i ++;
  }
#line 19067
  break;
  case 2983: 
#line 19069
  i = 0U;
#line 19069
  while (i < 16U) {
#line 19070
    *(params + i) = (double )ctx->ProjectionMatrix[i];
#line 19069
    i ++;
  }
#line 19072
  break;
  case 2980: 
#line 19074
  *params = (double )ctx->ProjectionStackDepth;
#line 19075
  break;
  case 3074: 
#line 19077
  *params = (double )ctx->Pixel.ReadBuffer;
#line 19078
  break;
  case 3349: 
#line 19080
  *params = (double )ctx->Pixel.RedBias;
#line 19081
  break;
  case 3410: 
#line 19083
  *params = (double )(ctx->Visual)->RedBits;
#line 19084
  break;
  case 3348: 
#line 19086
  *params = (double )ctx->Pixel.RedScale;
#line 19087
  break;
  case 3136: 
#line 19089
  *params = (double )ctx->RenderMode;
#line 19090
  break;
  case 3121: 
#line 19092
  *params = (double )(ctx->Visual)->RGBAflag;
#line 19093
  break;
  case 3088: 
#line 19095
  *(params + 0) = (double )ctx->Scissor.X;
#line 19096
  *(params + 1) = (double )ctx->Scissor.Y;
#line 19097
  *(params + 2) = (double )ctx->Scissor.Width;
#line 19098
  *(params + 3) = (double )ctx->Scissor.Height;
#line 19099
  break;
  case 3089: 
#line 19101
  *params = (double )ctx->Scissor.Enabled;
#line 19102
  break;
  case 2900: 
#line 19104
  *params = (double )ctx->Light.ShadeModel;
#line 19105
  break;
  case 33275: 
#line 19107
  *params = (double )ctx->Texture.SharedPalette;
#line 19108
  break;
  case 3415: 
#line 19110
  *params = (double )(ctx->Visual)->StencilBits;
#line 19111
  break;
  case 2961: 
#line 19113
  *params = (double )ctx->Stencil.Clear;
#line 19114
  break;
  case 2964: 
#line 19116
  *params = (double )ctx->Stencil.FailFunc;
#line 19117
  break;
  case 2962: 
#line 19119
  *params = (double )ctx->Stencil.Function;
#line 19120
  break;
  case 2965: 
#line 19122
  *params = (double )ctx->Stencil.ZFailFunc;
#line 19123
  break;
  case 2966: 
#line 19125
  *params = (double )ctx->Stencil.ZPassFunc;
#line 19126
  break;
  case 2967: 
#line 19128
  *params = (double )ctx->Stencil.Ref;
#line 19129
  break;
  case 2960: 
#line 19131
  *params = (double )ctx->Stencil.Enabled;
#line 19132
  break;
  case 2963: 
#line 19134
  *params = (double )ctx->Stencil.ValueMask;
#line 19135
  break;
  case 2968: 
#line 19137
  *params = (double )ctx->Stencil.WriteMask;
#line 19138
  break;
  case 3123: 
#line 19140
  *params = 0.0;
#line 19141
  break;
  case 3408: 
#line 19143
  *params = 0.0;
#line 19144
  break;
  case 3552: 
#line 19146
  if (ctx->Texture.Enabled & 1U) {
#line 19146
    *params = 1.0;
  } else {
#line 19146
    *params = 0.0;
  }
#line 19147
  break;
  case 3553: 
#line 19149
  if (ctx->Texture.Enabled & 2U) {
#line 19149
    *params = 1.0;
  } else {
#line 19149
    *params = 0.0;
  }
#line 19150
  break;
  case 32879: 
#line 19152
  if (ctx->Texture.Enabled & 4U) {
#line 19152
    *params = 1.0;
  } else {
#line 19152
    *params = 0.0;
  }
#line 19153
  break;
  case 8705: 
#line 19155
  *(params + 0) = (double )ctx->Texture.EnvColor[0];
#line 19156
  *(params + 1) = (double )ctx->Texture.EnvColor[1];
#line 19157
  *(params + 2) = (double )ctx->Texture.EnvColor[2];
#line 19158
  *(params + 3) = (double )ctx->Texture.EnvColor[3];
#line 19159
  break;
  case 8704: 
#line 19161
  *params = (double )ctx->Texture.EnvMode;
#line 19162
  break;
  case 3168: 
#line 19164
  if (ctx->Texture.TexGenEnabled & 4U) {
#line 19164
    *params = 1.0;
  } else {
#line 19164
    *params = 0.0;
  }
#line 19165
  break;
  case 3169: 
#line 19167
  if (ctx->Texture.TexGenEnabled & 8U) {
#line 19167
    *params = 1.0;
  } else {
#line 19167
    *params = 0.0;
  }
#line 19168
  break;
  case 3170: 
#line 19170
  if (ctx->Texture.TexGenEnabled & 2U) {
#line 19170
    *params = 1.0;
  } else {
#line 19170
    *params = 0.0;
  }
#line 19171
  break;
  case 3171: 
#line 19173
  if (ctx->Texture.TexGenEnabled & 1U) {
#line 19173
    *params = 1.0;
  } else {
#line 19173
    *params = 0.0;
  }
#line 19174
  break;
  case 2984: 
#line 19176
  i = 0U;
#line 19176
  while (i < 16U) {
#line 19177
    *(params + i) = (double )ctx->TextureMatrix[i];
#line 19176
    i ++;
  }
#line 19179
  break;
  case 2981: 
#line 19181
  *params = (double )ctx->TextureStackDepth;
#line 19182
  break;
  case 3317: 
#line 19184
  *params = (double )ctx->Unpack.Alignment;
#line 19185
  break;
  case 3313: 
#line 19187
  *params = (double )ctx->Unpack.LsbFirst;
#line 19188
  break;
  case 3314: 
#line 19190
  *params = (double )ctx->Unpack.RowLength;
#line 19191
  break;
  case 3316: 
#line 19193
  *params = (double )ctx->Unpack.SkipPixels;
#line 19194
  break;
  case 3315: 
#line 19196
  *params = (double )ctx->Unpack.SkipRows;
#line 19197
  break;
  case 3312: 
#line 19199
  *params = (double )ctx->Unpack.SwapBytes;
#line 19200
  break;
  case 32877: 
#line 19202
  *params = (double )ctx->Unpack.SkipImages;
#line 19203
  break;
  case 32878: 
#line 19205
  *params = (double )ctx->Unpack.ImageHeight;
#line 19206
  break;
  case 2978: 
#line 19208
  *(params + 0) = (double )ctx->Viewport.X;
#line 19209
  *(params + 1) = (double )ctx->Viewport.Y;
#line 19210
  *(params + 2) = (double )ctx->Viewport.Width;
#line 19211
  *(params + 3) = (double )ctx->Viewport.Height;
#line 19212
  break;
  case 3350: 
#line 19214
  *params = (double )ctx->Pixel.ZoomX;
#line 19215
  break;
  case 3351: 
#line 19217
  *params = (double )ctx->Pixel.ZoomY;
#line 19218
  break;
  case 32890: 
#line 19220
  *params = (double )ctx->Array.VertexSize;
#line 19221
  break;
  case 32891: 
#line 19223
  *params = (double )ctx->Array.VertexType;
#line 19224
  break;
  case 32892: 
#line 19226
  *params = (double )ctx->Array.VertexStride;
#line 19227
  break;
  case 32893: 
#line 19229
  *params = 0.0;
#line 19230
  break;
  case 32894: 
#line 19232
  *params = (double )ctx->Array.NormalType;
#line 19233
  break;
  case 32895: 
#line 19235
  *params = (double )ctx->Array.NormalStride;
#line 19236
  break;
  case 32896: 
#line 19238
  *params = 0.0;
#line 19239
  break;
  case 32897: 
#line 19241
  *params = (double )ctx->Array.ColorSize;
#line 19242
  break;
  case 32898: 
#line 19244
  *params = (double )ctx->Array.ColorType;
#line 19245
  break;
  case 32899: 
#line 19247
  *params = (double )ctx->Array.ColorStride;
#line 19248
  break;
  case 32900: 
#line 19250
  *params = 0.0;
#line 19251
  break;
  case 32901: 
#line 19253
  *params = (double )ctx->Array.IndexType;
#line 19254
  break;
  case 32902: 
#line 19256
  *params = (double )ctx->Array.IndexStride;
#line 19257
  break;
  case 32903: 
#line 19259
  *params = 0.0;
#line 19260
  break;
  case 32904: 
#line 19262
  *params = (double )ctx->Array.TexCoordSize;
#line 19263
  break;
  case 32905: 
#line 19265
  *params = (double )ctx->Array.TexCoordType;
#line 19266
  break;
  case 32906: 
#line 19268
  *params = (double )ctx->Array.TexCoordStride;
#line 19269
  break;
  case 32907: 
#line 19271
  *params = 0.0;
#line 19272
  break;
  case 32908: 
#line 19274
  *params = (double )ctx->Array.EdgeFlagStride;
#line 19275
  break;
  case 32909: 
#line 19277
  *params = 0.0;
#line 19278
  break;
  case 32872: 
#line 19280
  *params = (double )(ctx->Texture.Current1D)->Name;
#line 19281
  break;
  case 32873: 
#line 19283
  *params = (double )(ctx->Texture.Current2D)->Name;
#line 19284
  break;
  case 32874: 
#line 19286
  *params = (double )(ctx->Texture.Current3D)->Name;
#line 19287
  break;
  default: 
#line 19289
  gl_error(ctx, 1280, "glGetDoublev");
  }
#line 19291
  return;
}
}
#line 19292 "D:/a/test/177.c"
void gl_GetFloatv(GLcontext *ctx , GLenum pname , float *params ) 
{ GLuint i ;
  GLint tmp___0 ;

  {
#line 19295
  if (ctx->Primitive != 6656) {
#line 19296
    gl_error(ctx, 1282, "glGetFloatv");
#line 19297
    return;
  }
#line 19299
  switch (pname) {
  case 3416: 
  case 3417: 
  case 3418: 
  case 3419: 
#line 19304
  *params = (float )(ctx->Visual)->AccumBits;
#line 19305
  break;
  case 2944: 
#line 19307
  *(params + 0) = ctx->Accum.ClearColor[0];
#line 19308
  *(params + 1) = ctx->Accum.ClearColor[1];
#line 19309
  *(params + 2) = ctx->Accum.ClearColor[2];
#line 19310
  *(params + 3) = ctx->Accum.ClearColor[3];
#line 19311
  break;
  case 3357: 
#line 19313
  *params = ctx->Pixel.AlphaBias;
#line 19314
  break;
  case 3413: 
#line 19316
  *params = (float )(ctx->Visual)->AlphaBits;
#line 19317
  break;
  case 3356: 
#line 19319
  *params = ctx->Pixel.AlphaScale;
#line 19320
  break;
  case 3008: 
#line 19322
  *params = (float )ctx->Color.AlphaEnabled;
#line 19323
  break;
  case 3009: 
#line 19325
  *params = (float )ctx->Color.AlphaFunc;
#line 19326
  break;
  case 3010: 
#line 19328
  *params = ctx->Color.AlphaRef;
#line 19329
  break;
  case 2992: 
#line 19331
  *params = (float )ctx->AttribStackDepth;
#line 19332
  break;
  case 3456: 
#line 19334
  *params = (float )ctx->Eval.AutoNormal;
#line 19335
  break;
  case 3072: 
#line 19337
  *params = (float )0;
#line 19338
  break;
  case 3042: 
#line 19340
  *params = (float )ctx->Color.BlendEnabled;
#line 19341
  break;
  case 3040: 
#line 19343
  *params = (float )ctx->Color.BlendDst;
#line 19344
  break;
  case 3041: 
#line 19346
  *params = (float )ctx->Color.BlendSrc;
#line 19347
  break;
  case 32777: 
#line 19349
  *params = (float )ctx->Color.BlendEquation;
#line 19350
  break;
  case 32773: 
#line 19352
  *(params + 0) = ctx->Color.BlendColor[0];
#line 19353
  *(params + 1) = ctx->Color.BlendColor[1];
#line 19354
  *(params + 2) = ctx->Color.BlendColor[2];
#line 19355
  *(params + 3) = ctx->Color.BlendColor[3];
#line 19356
  break;
  case 3355: 
#line 19358
  *params = ctx->Pixel.BlueBias;
#line 19359
  break;
  case 3412: 
#line 19361
  *params = (float )(ctx->Visual)->BlueBits;
#line 19362
  break;
  case 3354: 
#line 19364
  *params = ctx->Pixel.BlueScale;
#line 19365
  break;
  case 2993: 
#line 19367
  *params = (float )ctx->ClientAttribStackDepth;
#line 19368
  break;
  case 12288: 
  case 12289: 
  case 12290: 
  case 12291: 
  case 12292: 
  case 12293: 
#line 19375
  *params = (float )ctx->Transform.ClipEnabled[pname - 12288];
#line 19376
  break;
  case 3106: 
#line 19378
  *(params + 0) = ctx->Color.ClearColor[0];
#line 19379
  *(params + 1) = ctx->Color.ClearColor[1];
#line 19380
  *(params + 2) = ctx->Color.ClearColor[2];
#line 19381
  *(params + 3) = ctx->Color.ClearColor[3];
#line 19382
  break;
  case 2903: 
#line 19384
  *params = (float )ctx->Light.ColorMaterialEnabled;
#line 19385
  break;
  case 2901: 
#line 19387
  *params = (float )ctx->Light.ColorMaterialFace;
#line 19388
  break;
  case 2902: 
#line 19390
  *params = (float )ctx->Light.ColorMaterialMode;
#line 19391
  break;
  case 3107: 
#line 19393
  if (ctx->Color.ColorMask & 8U) {
#line 19393
    *(params + 0) = 1.0F;
  } else {
#line 19393
    *(params + 0) = 0.0F;
  }
#line 19394
  if (ctx->Color.ColorMask & 4U) {
#line 19394
    *(params + 1) = 1.0F;
  } else {
#line 19394
    *(params + 1) = 0.0F;
  }
#line 19395
  if (ctx->Color.ColorMask & 2U) {
#line 19395
    *(params + 2) = 1.0F;
  } else {
#line 19395
    *(params + 2) = 0.0F;
  }
#line 19396
  if (ctx->Color.ColorMask & 1U) {
#line 19396
    *(params + 3) = 1.0F;
  } else {
#line 19396
    *(params + 3) = 0.0F;
  }
#line 19397
  break;
  case 2884: 
#line 19399
  *params = (float )ctx->Polygon.CullFlag;
#line 19400
  break;
  case 2885: 
#line 19402
  *params = (float )ctx->Polygon.CullFaceMode;
#line 19403
  break;
  case 2816: 
#line 19405
  *(params + 0) = (float )ctx->Current.ByteColor[0] * (ctx->Visual)->InvRedScale;
#line 19406
  *(params + 1) = (float )ctx->Current.ByteColor[1] * (ctx->Visual)->InvGreenScale;
#line 19407
  *(params + 2) = (float )ctx->Current.ByteColor[2] * (ctx->Visual)->InvBlueScale;
#line 19408
  *(params + 3) = (float )ctx->Current.ByteColor[3] * (ctx->Visual)->InvAlphaScale;
#line 19409
  break;
  case 2817: 
#line 19411
  *params = (float )ctx->Current.Index;
#line 19412
  break;
  case 2818: 
#line 19414
  *(params + 0) = ctx->Current.Normal[0];
#line 19415
  *(params + 1) = ctx->Current.Normal[1];
#line 19416
  *(params + 2) = ctx->Current.Normal[2];
#line 19417
  break;
  case 2820: 
#line 19419
  *(params + 0) = ctx->Current.RasterColor[0];
#line 19420
  *(params + 1) = ctx->Current.RasterColor[1];
#line 19421
  *(params + 2) = ctx->Current.RasterColor[2];
#line 19422
  *(params + 3) = ctx->Current.RasterColor[3];
#line 19423
  break;
  case 2825: 
#line 19425
  *(params + 0) = ctx->Current.RasterDistance;
#line 19426
  break;
  case 2821: 
#line 19428
  *params = (float )ctx->Current.RasterIndex;
#line 19429
  break;
  case 2823: 
#line 19431
  *(params + 0) = ctx->Current.RasterPos[0];
#line 19432
  *(params + 1) = ctx->Current.RasterPos[1];
#line 19433
  *(params + 2) = ctx->Current.RasterPos[2];
#line 19434
  *(params + 3) = ctx->Current.RasterPos[3];
#line 19435
  break;
  case 2822: 
#line 19437
  *(params + 0) = ctx->Current.RasterTexCoord[0];
#line 19438
  *(params + 1) = ctx->Current.RasterTexCoord[1];
#line 19439
  *(params + 2) = ctx->Current.RasterTexCoord[2];
#line 19440
  *(params + 3) = ctx->Current.RasterTexCoord[3];
#line 19441
  break;
  case 2824: 
#line 19443
  *params = (float )ctx->Current.RasterPosValid;
#line 19444
  break;
  case 2819: 
#line 19446
  *(params + 0) = ctx->Current.TexCoord[0];
#line 19447
  *(params + 1) = ctx->Current.TexCoord[1];
#line 19448
  *(params + 2) = ctx->Current.TexCoord[2];
#line 19449
  *(params + 3) = ctx->Current.TexCoord[3];
#line 19450
  break;
  case 3359: 
#line 19452
  *params = ctx->Pixel.DepthBias;
#line 19453
  break;
  case 3414: 
#line 19455
  *params = (float )(ctx->Visual)->DepthBits;
#line 19456
  break;
  case 2931: 
#line 19458
  *params = ctx->Depth.Clear;
#line 19459
  break;
  case 2932: 
#line 19461
  *params = (float )ctx->Depth.Func;
#line 19462
  break;
  case 2928: 
#line 19464
  *(params + 0) = ctx->Viewport.Near;
#line 19465
  *(params + 1) = ctx->Viewport.Far;
#line 19466
  break;
  case 3358: 
#line 19468
  *params = ctx->Pixel.DepthScale;
#line 19469
  break;
  case 2929: 
#line 19471
  *params = (float )ctx->Depth.Test;
#line 19472
  break;
  case 2930: 
#line 19474
  *params = (float )ctx->Depth.Mask;
#line 19475
  break;
  case 3024: 
#line 19477
  *params = (float )ctx->Color.DitherFlag;
#line 19478
  break;
  case 3122: 
#line 19480
  *params = (float )(ctx->Visual)->DBflag;
#line 19481
  break;
  case 3073: 
#line 19483
  *params = (float )ctx->Color.DrawBuffer;
#line 19484
  break;
  case 2883: 
#line 19486
  *params = (float )ctx->Current.EdgeFlag;
#line 19487
  break;
  case 3569: 
#line 19489
  *params = (float )ctx->Feedback.BufferSize;
#line 19490
  break;
  case 3570: 
#line 19492
  *params = (float )ctx->Feedback.Type;
#line 19493
  break;
  case 2912: 
#line 19495
  *params = (float )ctx->Fog.Enabled;
#line 19496
  break;
  case 2918: 
#line 19498
  *(params + 0) = ctx->Fog.Color[0];
#line 19499
  *(params + 1) = ctx->Fog.Color[1];
#line 19500
  *(params + 2) = ctx->Fog.Color[2];
#line 19501
  *(params + 3) = ctx->Fog.Color[3];
#line 19502
  break;
  case 2914: 
#line 19504
  *params = ctx->Fog.Density;
#line 19505
  break;
  case 2916: 
#line 19507
  *params = ctx->Fog.End;
#line 19508
  break;
  case 3156: 
#line 19510
  *params = (float )ctx->Hint.Fog;
#line 19511
  break;
  case 2913: 
#line 19513
  *params = ctx->Fog.Index;
#line 19514
  break;
  case 2917: 
#line 19516
  *params = (float )ctx->Fog.Mode;
#line 19517
  break;
  case 2915: 
#line 19519
  *params = ctx->Fog.Start;
#line 19520
  break;
  case 2886: 
#line 19522
  *params = (float )ctx->Polygon.FrontFace;
#line 19523
  break;
  case 3353: 
#line 19525
  *params = ctx->Pixel.GreenBias;
#line 19526
  break;
  case 3411: 
#line 19528
  *params = (float )(ctx->Visual)->GreenBits;
#line 19529
  break;
  case 3352: 
#line 19531
  *params = ctx->Pixel.GreenScale;
#line 19532
  break;
  case 3409: 
#line 19534
  *params = (float )(ctx->Visual)->IndexBits;
#line 19535
  break;
  case 3104: 
#line 19537
  *params = (float )ctx->Color.ClearIndex;
#line 19538
  break;
  case 3120: 
#line 19540
  if ((ctx->Visual)->RGBAflag) {
#line 19540
    *params = 0.0F;
  } else {
#line 19540
    *params = 1.0F;
  }
#line 19541
  break;
  case 3347: 
#line 19543
  *params = (float )ctx->Pixel.IndexOffset;
#line 19544
  break;
  case 3346: 
#line 19546
  *params = (float )ctx->Pixel.IndexShift;
#line 19547
  break;
  case 3105: 
#line 19549
  *params = (float )ctx->Color.IndexMask;
#line 19550
  break;
  case 16384: 
  case 16385: 
  case 16386: 
  case 16387: 
  case 16388: 
  case 16389: 
  case 16390: 
  case 16391: 
#line 19559
  *params = (float )ctx->Light.Light[pname - 16384].Enabled;
#line 19560
  break;
  case 2896: 
#line 19562
  *params = (float )ctx->Light.Enabled;
#line 19563
  break;
  case 2899: 
#line 19565
  *(params + 0) = ctx->Light.Model.Ambient[0];
#line 19566
  *(params + 1) = ctx->Light.Model.Ambient[1];
#line 19567
  *(params + 2) = ctx->Light.Model.Ambient[2];
#line 19568
  *(params + 3) = ctx->Light.Model.Ambient[3];
#line 19569
  break;
  case 2897: 
#line 19571
  *params = (float )ctx->Light.Model.LocalViewer;
#line 19572
  break;
  case 2898: 
#line 19574
  *params = (float )ctx->Light.Model.TwoSide;
#line 19575
  break;
  case 2848: 
#line 19577
  *params = (float )ctx->Line.SmoothFlag;
#line 19578
  break;
  case 3154: 
#line 19580
  *params = (float )ctx->Hint.LineSmooth;
#line 19581
  break;
  case 2852: 
#line 19583
  *params = (float )ctx->Line.StippleFlag;
#line 19584
  break;
  case 2853: 
#line 19586
  *params = (float )ctx->Line.StipplePattern;
#line 19587
  break;
  case 2854: 
#line 19589
  *params = (float )ctx->Line.StippleFactor;
#line 19590
  break;
  case 2849: 
#line 19592
  *params = ctx->Line.Width;
#line 19593
  break;
  case 2851: 
#line 19595
  *params = (float )1.0;
#line 19596
  break;
  case 2850: 
#line 19598
  *(params + 0) = (float )1.0;
#line 19599
  *(params + 1) = (float )10.0;
#line 19600
  break;
  case 2866: 
#line 19602
  *params = (float )ctx->List.ListBase;
#line 19603
  break;
  case 2867: 
#line 19605
  tmp___0 = gl_list_index();
#line 19605
  *params = (float )tmp___0;
#line 19606
  break;
  case 2864: 
#line 19608
  if (ctx->ExecuteFlag) {
#line 19608
    *params = (float )4865;
  } else {
#line 19608
    *params = (float )4864;
  }
#line 19610
  break;
  case 3057: 
#line 19612
  *params = (float )ctx->Color.IndexLogicOpEnabled;
#line 19613
  break;
  case 3058: 
#line 19615
  *params = (float )ctx->Color.ColorLogicOpEnabled;
#line 19616
  break;
  case 3056: 
#line 19618
  *params = (float )ctx->Color.LogicOp;
#line 19619
  break;
  case 3472: 
#line 19621
  *params = (float )ctx->Eval.Map1Color4;
#line 19622
  break;
  case 3536: 
#line 19624
  *(params + 0) = ctx->Eval.MapGrid1u1;
#line 19625
  *(params + 1) = ctx->Eval.MapGrid1u2;
#line 19626
  break;
  case 3537: 
#line 19628
  *params = (float )ctx->Eval.MapGrid1un;
#line 19629
  break;
  case 3473: 
#line 19631
  *params = (float )ctx->Eval.Map1Index;
#line 19632
  break;
  case 3474: 
#line 19634
  *params = (float )ctx->Eval.Map1Normal;
#line 19635
  break;
  case 3475: 
#line 19637
  *params = (float )ctx->Eval.Map1TextureCoord1;
#line 19638
  break;
  case 3476: 
#line 19640
  *params = (float )ctx->Eval.Map1TextureCoord2;
#line 19641
  break;
  case 3477: 
#line 19643
  *params = (float )ctx->Eval.Map1TextureCoord3;
#line 19644
  break;
  case 3478: 
#line 19646
  *params = (float )ctx->Eval.Map1TextureCoord4;
#line 19647
  break;
  case 3479: 
#line 19649
  *params = (float )ctx->Eval.Map1Vertex3;
#line 19650
  break;
  case 3480: 
#line 19652
  *params = (float )ctx->Eval.Map1Vertex4;
#line 19653
  break;
  case 3504: 
#line 19655
  *params = (float )ctx->Eval.Map2Color4;
#line 19656
  break;
  case 3538: 
#line 19658
  *(params + 0) = ctx->Eval.MapGrid2u1;
#line 19659
  *(params + 1) = ctx->Eval.MapGrid2u2;
#line 19660
  *(params + 2) = ctx->Eval.MapGrid2v1;
#line 19661
  *(params + 3) = ctx->Eval.MapGrid2v2;
#line 19662
  break;
  case 3539: 
#line 19664
  *(params + 0) = (float )ctx->Eval.MapGrid2un;
#line 19665
  *(params + 1) = (float )ctx->Eval.MapGrid2vn;
#line 19666
  break;
  case 3505: 
#line 19668
  *params = (float )ctx->Eval.Map2Index;
#line 19669
  break;
  case 3506: 
#line 19671
  *params = (float )ctx->Eval.Map2Normal;
#line 19672
  break;
  case 3507: 
#line 19674
  *params = (float )ctx->Eval.Map2TextureCoord1;
#line 19675
  break;
  case 3508: 
#line 19677
  *params = (float )ctx->Eval.Map2TextureCoord2;
#line 19678
  break;
  case 3509: 
#line 19680
  *params = (float )ctx->Eval.Map2TextureCoord3;
#line 19681
  break;
  case 3510: 
#line 19683
  *params = (float )ctx->Eval.Map2TextureCoord4;
#line 19684
  break;
  case 3511: 
#line 19686
  *params = (float )ctx->Eval.Map2Vertex3;
#line 19687
  break;
  case 3512: 
#line 19689
  *params = (float )ctx->Eval.Map2Vertex4;
#line 19690
  break;
  case 3344: 
#line 19692
  *params = (float )ctx->Pixel.MapColorFlag;
#line 19693
  break;
  case 3345: 
#line 19695
  *params = (float )ctx->Pixel.MapStencilFlag;
#line 19696
  break;
  case 2976: 
#line 19698
  *params = (float )ctx->Transform.MatrixMode;
#line 19699
  break;
  case 3381: 
#line 19701
  *params = (float )16;
#line 19702
  break;
  case 3387: 
#line 19704
  *params = (float )16;
#line 19705
  break;
  case 3378: 
#line 19707
  *params = (float )6;
#line 19708
  break;
  case 3376: 
#line 19710
  *params = (float )30;
#line 19711
  break;
  case 3377: 
#line 19713
  *params = (float )8;
#line 19714
  break;
  case 2865: 
#line 19716
  *params = (float )64;
#line 19717
  break;
  case 3382: 
#line 19719
  *params = (float )32;
#line 19720
  break;
  case 3383: 
#line 19722
  *params = (float )64;
#line 19723
  break;
  case 3380: 
#line 19725
  *params = (float )256;
#line 19726
  break;
  case 3384: 
#line 19728
  *params = (float )32;
#line 19729
  break;
  case 3379: 
#line 19731
  *params = (float )(1 << 10);
#line 19732
  break;
  case 3385: 
#line 19734
  *params = (float )10;
#line 19735
  break;
  case 3386: 
#line 19737
  *(params + 0) = (float )640;
#line 19738
  *(params + 1) = (float )400;
#line 19739
  break;
  case 2982: 
#line 19741
  i = 0U;
#line 19741
  while (i < 16U) {
#line 19742
    *(params + i) = ctx->ModelViewMatrix[i];
#line 19741
    i ++;
  }
#line 19744
  break;
  case 2979: 
#line 19746
  *params = (float )ctx->ModelViewStackDepth;
#line 19747
  break;
  case 3440: 
#line 19749
  *params = (float )ctx->Select.NameStackDepth;
#line 19750
  break;
  case 2977: 
#line 19752
  *params = (float )ctx->Transform.Normalize;
#line 19753
  break;
  case 3333: 
#line 19755
  *params = (float )ctx->Pack.Alignment;
#line 19756
  break;
  case 3329: 
#line 19758
  *params = (float )ctx->Pack.LsbFirst;
#line 19759
  break;
  case 3330: 
#line 19761
  *params = (float )ctx->Pack.RowLength;
#line 19762
  break;
  case 3332: 
#line 19764
  *params = (float )ctx->Pack.SkipPixels;
#line 19765
  break;
  case 3331: 
#line 19767
  *params = (float )ctx->Pack.SkipRows;
#line 19768
  break;
  case 3328: 
#line 19770
  *params = (float )ctx->Pack.SwapBytes;
#line 19771
  break;
  case 32875: 
#line 19773
  *params = (float )ctx->Pack.SkipImages;
#line 19774
  break;
  case 32876: 
#line 19776
  *params = (float )ctx->Pack.ImageHeight;
#line 19777
  break;
  case 3152: 
#line 19779
  *params = (float )ctx->Hint.PerspectiveCorrection;
#line 19780
  break;
  case 3257: 
#line 19782
  *params = (float )ctx->Pixel.MapAtoAsize;
#line 19783
  break;
  case 3256: 
#line 19785
  *params = (float )ctx->Pixel.MapBtoBsize;
#line 19786
  break;
  case 3255: 
#line 19788
  *params = (float )ctx->Pixel.MapGtoGsize;
#line 19789
  break;
  case 3253: 
#line 19791
  *params = (float )ctx->Pixel.MapItoAsize;
#line 19792
  break;
  case 3252: 
#line 19794
  *params = (float )ctx->Pixel.MapItoBsize;
#line 19795
  break;
  case 3251: 
#line 19797
  *params = (float )ctx->Pixel.MapItoGsize;
#line 19798
  break;
  case 3248: 
#line 19800
  *params = (float )ctx->Pixel.MapItoIsize;
#line 19801
  break;
  case 3250: 
#line 19803
  *params = (float )ctx->Pixel.MapItoRsize;
#line 19804
  break;
  case 3254: 
#line 19806
  *params = (float )ctx->Pixel.MapRtoRsize;
#line 19807
  break;
  case 3249: 
#line 19809
  *params = (float )ctx->Pixel.MapStoSsize;
#line 19810
  break;
  case 2833: 
#line 19812
  *params = ctx->Point.Size;
#line 19813
  break;
  case 2835: 
#line 19815
  *params = (float )0.1;
#line 19816
  break;
  case 2834: 
#line 19818
  *(params + 0) = (float )1.0;
#line 19819
  *(params + 1) = (float )10.0;
#line 19820
  break;
  case 2832: 
#line 19822
  *params = (float )ctx->Point.SmoothFlag;
#line 19823
  break;
  case 3153: 
#line 19825
  *params = (float )ctx->Hint.PointSmooth;
#line 19826
  break;
  case 33062: 
#line 19828
  *params = ctx->Point.MinSize;
#line 19829
  break;
  case 33063: 
#line 19831
  *params = ctx->Point.MaxSize;
#line 19832
  break;
  case 33064: 
#line 19834
  *params = ctx->Point.Threshold;
#line 19835
  break;
  case 33065: 
#line 19837
  *(params + 0) = ctx->Point.Params[0];
#line 19838
  *(params + 1) = ctx->Point.Params[1];
#line 19839
  *(params + 2) = ctx->Point.Params[2];
#line 19840
  break;
  case 2880: 
#line 19842
  *(params + 0) = (float )ctx->Polygon.FrontMode;
#line 19843
  *(params + 1) = (float )ctx->Polygon.BackMode;
#line 19844
  break;
  case 32824: 
#line 19851
  *params = ctx->Polygon.OffsetFactor;
#line 19852
  break;
  case 10752: 
#line 19854
  *params = ctx->Polygon.OffsetUnits;
#line 19855
  break;
  case 2881: 
#line 19857
  *params = (float )ctx->Polygon.SmoothFlag;
#line 19858
  break;
  case 3155: 
#line 19860
  *params = (float )ctx->Hint.PolygonSmooth;
#line 19861
  break;
  case 2882: 
#line 19863
  i = 0U;
#line 19863
  while (i < 32U) {
#line 19864
    *(params + i) = (float )ctx->PolygonStipple[i];
#line 19863
    i ++;
  }
#line 19866
  break;
  case 2983: 
#line 19868
  i = 0U;
#line 19868
  while (i < 16U) {
#line 19869
    *(params + i) = ctx->ProjectionMatrix[i];
#line 19868
    i ++;
  }
#line 19871
  break;
  case 2980: 
#line 19873
  *params = (float )ctx->ProjectionStackDepth;
#line 19874
  break;
  case 3074: 
#line 19876
  *params = (float )ctx->Pixel.ReadBuffer;
#line 19877
  break;
  case 3349: 
#line 19879
  *params = ctx->Pixel.RedBias;
#line 19880
  break;
  case 3410: 
#line 19882
  *params = (float )(ctx->Visual)->RedBits;
#line 19883
  break;
  case 3348: 
#line 19885
  *params = ctx->Pixel.RedScale;
#line 19886
  break;
  case 3136: 
#line 19888
  *params = (float )ctx->RenderMode;
#line 19889
  break;
  case 3121: 
#line 19891
  *params = (float )(ctx->Visual)->RGBAflag;
#line 19892
  break;
  case 3088: 
#line 19894
  *(params + 0) = (float )ctx->Scissor.X;
#line 19895
  *(params + 1) = (float )ctx->Scissor.Y;
#line 19896
  *(params + 2) = (float )ctx->Scissor.Width;
#line 19897
  *(params + 3) = (float )ctx->Scissor.Height;
#line 19898
  break;
  case 3089: 
#line 19900
  *params = (float )ctx->Scissor.Enabled;
#line 19901
  break;
  case 2900: 
#line 19903
  *params = (float )ctx->Light.ShadeModel;
#line 19904
  break;
  case 33275: 
#line 19906
  *params = (float )ctx->Texture.SharedPalette;
#line 19907
  break;
  case 3415: 
#line 19909
  *params = (float )(ctx->Visual)->StencilBits;
#line 19910
  break;
  case 2961: 
#line 19912
  *params = (float )ctx->Stencil.Clear;
#line 19913
  break;
  case 2964: 
#line 19915
  *params = (float )ctx->Stencil.FailFunc;
#line 19916
  break;
  case 2962: 
#line 19918
  *params = (float )ctx->Stencil.Function;
#line 19919
  break;
  case 2965: 
#line 19921
  *params = (float )ctx->Stencil.ZFailFunc;
#line 19922
  break;
  case 2966: 
#line 19924
  *params = (float )ctx->Stencil.ZPassFunc;
#line 19925
  break;
  case 2967: 
#line 19927
  *params = (float )ctx->Stencil.Ref;
#line 19928
  break;
  case 2960: 
#line 19930
  *params = (float )ctx->Stencil.Enabled;
#line 19931
  break;
  case 2963: 
#line 19933
  *params = (float )ctx->Stencil.ValueMask;
#line 19934
  break;
  case 2968: 
#line 19936
  *params = (float )ctx->Stencil.WriteMask;
#line 19937
  break;
  case 3123: 
#line 19939
  *params = 0.0F;
#line 19940
  break;
  case 3408: 
#line 19942
  *params = 0.0F;
#line 19943
  break;
  case 3552: 
#line 19945
  if (ctx->Texture.Enabled & 1U) {
#line 19945
    *params = (float )1.0;
  } else {
#line 19945
    *params = (float )0.0;
  }
#line 19946
  break;
  case 3553: 
#line 19948
  if (ctx->Texture.Enabled & 2U) {
#line 19948
    *params = (float )1.0;
  } else {
#line 19948
    *params = (float )0.0;
  }
#line 19949
  break;
  case 32879: 
#line 19951
  if (ctx->Texture.Enabled & 4U) {
#line 19951
    *params = (float )1.0;
  } else {
#line 19951
    *params = (float )0.0;
  }
#line 19952
  break;
  case 8705: 
#line 19954
  *(params + 0) = ctx->Texture.EnvColor[0];
#line 19955
  *(params + 1) = ctx->Texture.EnvColor[1];
#line 19956
  *(params + 2) = ctx->Texture.EnvColor[2];
#line 19957
  *(params + 3) = ctx->Texture.EnvColor[3];
#line 19958
  break;
  case 8704: 
#line 19960
  *params = (float )ctx->Texture.EnvMode;
#line 19961
  break;
  case 3168: 
#line 19963
  if (ctx->Texture.TexGenEnabled & 4U) {
#line 19963
    *params = (float )1.0;
  } else {
#line 19963
    *params = (float )0.0;
  }
#line 19964
  break;
  case 3169: 
#line 19966
  if (ctx->Texture.TexGenEnabled & 8U) {
#line 19966
    *params = (float )1.0;
  } else {
#line 19966
    *params = (float )0.0;
  }
#line 19967
  break;
  case 3170: 
#line 19969
  if (ctx->Texture.TexGenEnabled & 2U) {
#line 19969
    *params = (float )1.0;
  } else {
#line 19969
    *params = (float )0.0;
  }
#line 19970
  break;
  case 3171: 
#line 19972
  if (ctx->Texture.TexGenEnabled & 1U) {
#line 19972
    *params = (float )1.0;
  } else {
#line 19972
    *params = (float )0.0;
  }
#line 19973
  break;
  case 2984: 
#line 19975
  i = 0U;
#line 19975
  while (i < 16U) {
#line 19976
    *(params + i) = ctx->TextureMatrix[i];
#line 19975
    i ++;
  }
#line 19978
  break;
  case 2981: 
#line 19980
  *params = (float )ctx->TextureStackDepth;
#line 19981
  break;
  case 3317: 
#line 19983
  *params = (float )ctx->Unpack.Alignment;
#line 19984
  break;
  case 3313: 
#line 19986
  *params = (float )ctx->Unpack.LsbFirst;
#line 19987
  break;
  case 3314: 
#line 19989
  *params = (float )ctx->Unpack.RowLength;
#line 19990
  break;
  case 3316: 
#line 19992
  *params = (float )ctx->Unpack.SkipPixels;
#line 19993
  break;
  case 3315: 
#line 19995
  *params = (float )ctx->Unpack.SkipRows;
#line 19996
  break;
  case 3312: 
#line 19998
  *params = (float )ctx->Unpack.SwapBytes;
#line 19999
  break;
  case 32877: 
#line 20001
  *params = (float )ctx->Unpack.SkipImages;
#line 20002
  break;
  case 32878: 
#line 20004
  *params = (float )ctx->Unpack.ImageHeight;
#line 20005
  break;
  case 2978: 
#line 20007
  *(params + 0) = (float )ctx->Viewport.X;
#line 20008
  *(params + 1) = (float )ctx->Viewport.Y;
#line 20009
  *(params + 2) = (float )ctx->Viewport.Width;
#line 20010
  *(params + 3) = (float )ctx->Viewport.Height;
#line 20011
  break;
  case 3350: 
#line 20013
  *params = ctx->Pixel.ZoomX;
#line 20014
  break;
  case 3351: 
#line 20016
  *params = ctx->Pixel.ZoomY;
#line 20017
  break;
  case 32890: 
#line 20019
  *params = (float )ctx->Array.VertexSize;
#line 20020
  break;
  case 32891: 
#line 20022
  *params = (float )ctx->Array.VertexType;
#line 20023
  break;
  case 32892: 
#line 20025
  *params = (float )ctx->Array.VertexStride;
#line 20026
  break;
  case 32893: 
#line 20028
  *params = (float )0.0;
#line 20029
  break;
  case 32894: 
#line 20031
  *params = (float )ctx->Array.NormalType;
#line 20032
  break;
  case 32895: 
#line 20034
  *params = (float )ctx->Array.NormalStride;
#line 20035
  break;
  case 32896: 
#line 20037
  *params = (float )0.0;
#line 20038
  break;
  case 32897: 
#line 20040
  *params = (float )ctx->Array.ColorSize;
#line 20041
  break;
  case 32898: 
#line 20043
  *params = (float )ctx->Array.ColorType;
#line 20044
  break;
  case 32899: 
#line 20046
  *params = (float )ctx->Array.ColorStride;
#line 20047
  break;
  case 32900: 
#line 20049
  *params = (float )0.0;
#line 20050
  break;
  case 32901: 
#line 20052
  *params = (float )ctx->Array.IndexType;
#line 20053
  break;
  case 32902: 
#line 20055
  *params = (float )ctx->Array.IndexStride;
#line 20056
  break;
  case 32903: 
#line 20058
  *params = (float )0.0;
#line 20059
  break;
  case 32904: 
#line 20061
  *params = (float )ctx->Array.TexCoordSize;
#line 20062
  break;
  case 32905: 
#line 20064
  *params = (float )ctx->Array.TexCoordType;
#line 20065
  break;
  case 32906: 
#line 20067
  *params = (float )ctx->Array.TexCoordStride;
#line 20068
  break;
  case 32907: 
#line 20070
  *params = (float )0.0;
#line 20071
  break;
  case 32908: 
#line 20073
  *params = (float )ctx->Array.EdgeFlagStride;
#line 20074
  break;
  case 32909: 
#line 20076
  *params = (float )0.0;
#line 20077
  break;
  case 32872: 
#line 20079
  *params = (float )(ctx->Texture.Current1D)->Name;
#line 20080
  break;
  case 32873: 
#line 20082
  *params = (float )(ctx->Texture.Current2D)->Name;
#line 20083
  break;
  case 32874: 
#line 20085
  *params = (float )(ctx->Texture.Current2D)->Name;
#line 20086
  break;
  default: 
#line 20088
  gl_error(ctx, 1280, "glGetFloatv");
  }
#line 20090
  return;
}
}
#line 20091 "D:/a/test/177.c"
void gl_GetIntegerv(GLcontext *ctx , GLenum pname , GLint *params ) 
{ GLuint i ;
  GLint tmp___0 ;

  {
#line 20094
  if (ctx->Primitive != 6656) {
#line 20095
    gl_error(ctx, 1282, "glGetIntegerv");
#line 20096
    return;
  }
#line 20098
  switch (pname) {
  case 3416: 
  case 3417: 
  case 3418: 
  case 3419: 
#line 20103
  *params = (ctx->Visual)->AccumBits;
#line 20104
  break;
  case 2944: 
#line 20106
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Accum.ClearColor[0]);
#line 20107
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Accum.ClearColor[1]);
#line 20108
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Accum.ClearColor[2]);
#line 20109
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Accum.ClearColor[3]);
#line 20110
  break;
  case 3357: 
#line 20112
  *params = (int )ctx->Pixel.AlphaBias;
#line 20113
  break;
  case 3413: 
#line 20115
  *params = (ctx->Visual)->AlphaBits;
#line 20116
  break;
  case 3356: 
#line 20118
  *params = (int )ctx->Pixel.AlphaScale;
#line 20119
  break;
  case 3008: 
#line 20121
  *params = (int )ctx->Color.AlphaEnabled;
#line 20122
  break;
  case 3010: 
#line 20124
  *params = (int )(2147483647.0 * (double )ctx->Color.AlphaRef);
#line 20125
  break;
  case 3009: 
#line 20127
  *params = ctx->Color.AlphaFunc;
#line 20128
  break;
  case 2992: 
#line 20130
  *params = (int )ctx->AttribStackDepth;
#line 20131
  break;
  case 3456: 
#line 20133
  *params = (int )ctx->Eval.AutoNormal;
#line 20134
  break;
  case 3072: 
#line 20136
  *params = 0;
#line 20137
  break;
  case 3042: 
#line 20139
  *params = (int )ctx->Color.BlendEnabled;
#line 20140
  break;
  case 3040: 
#line 20142
  *params = ctx->Color.BlendDst;
#line 20143
  break;
  case 3041: 
#line 20145
  *params = ctx->Color.BlendSrc;
#line 20146
  break;
  case 32777: 
#line 20148
  *params = ctx->Color.BlendEquation;
#line 20149
  break;
  case 32773: 
#line 20151
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Color.BlendColor[0]);
#line 20152
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Color.BlendColor[1]);
#line 20153
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Color.BlendColor[2]);
#line 20154
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Color.BlendColor[3]);
#line 20155
  break;
  case 3355: 
#line 20157
  *params = (int )ctx->Pixel.BlueBias;
#line 20158
  break;
  case 3412: 
#line 20160
  *params = (ctx->Visual)->BlueBits;
#line 20161
  break;
  case 3354: 
#line 20163
  *params = (int )ctx->Pixel.BlueScale;
#line 20164
  break;
  case 2993: 
#line 20166
  *params = (int )ctx->ClientAttribStackDepth;
#line 20167
  break;
  case 12288: 
  case 12289: 
  case 12290: 
  case 12291: 
  case 12292: 
  case 12293: 
#line 20174
  i = (unsigned int )(pname - 12288);
#line 20175
  *params = (int )ctx->Transform.ClipEnabled[i];
#line 20176
  break;
  case 3106: 
#line 20178
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Color.ClearColor[0]);
#line 20179
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Color.ClearColor[1]);
#line 20180
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Color.ClearColor[2]);
#line 20181
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Color.ClearColor[3]);
#line 20182
  break;
  case 2903: 
#line 20184
  *params = (int )ctx->Light.ColorMaterialEnabled;
#line 20185
  break;
  case 2901: 
#line 20187
  *params = ctx->Light.ColorMaterialFace;
#line 20188
  break;
  case 2902: 
#line 20190
  *params = ctx->Light.ColorMaterialMode;
#line 20191
  break;
  case 3107: 
#line 20193
  if (ctx->Color.ColorMask & 8U) {
#line 20193
    *(params + 0) = 1;
  } else {
#line 20193
    *(params + 0) = 0;
  }
#line 20194
  if (ctx->Color.ColorMask & 4U) {
#line 20194
    *(params + 1) = 1;
  } else {
#line 20194
    *(params + 1) = 0;
  }
#line 20195
  if (ctx->Color.ColorMask & 2U) {
#line 20195
    *(params + 2) = 1;
  } else {
#line 20195
    *(params + 2) = 0;
  }
#line 20196
  if (ctx->Color.ColorMask & 1U) {
#line 20196
    *(params + 3) = 1;
  } else {
#line 20196
    *(params + 3) = 0;
  }
#line 20197
  break;
  case 2884: 
#line 20199
  *params = (int )ctx->Polygon.CullFlag;
#line 20200
  break;
  case 2885: 
#line 20202
  *params = ctx->Polygon.CullFaceMode;
#line 20203
  break;
  case 2816: 
#line 20205
  *(params + 0) = (int )(2147483647.0 * (double )((float )ctx->Current.ByteColor[0] * (ctx->Visual)->InvRedScale));
#line 20206
  *(params + 1) = (int )(2147483647.0 * (double )((float )ctx->Current.ByteColor[1] * (ctx->Visual)->InvGreenScale));
#line 20207
  *(params + 2) = (int )(2147483647.0 * (double )((float )ctx->Current.ByteColor[2] * (ctx->Visual)->InvBlueScale));
#line 20208
  *(params + 3) = (int )(2147483647.0 * (double )((float )ctx->Current.ByteColor[3] * (ctx->Visual)->InvAlphaScale));
#line 20209
  break;
  case 2817: 
#line 20211
  *params = (int )ctx->Current.Index;
#line 20212
  break;
  case 2818: 
#line 20214
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Current.Normal[0]);
#line 20215
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Current.Normal[1]);
#line 20216
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Current.Normal[2]);
#line 20217
  break;
  case 2820: 
#line 20219
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Current.RasterColor[0]);
#line 20220
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Current.RasterColor[1]);
#line 20221
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Current.RasterColor[2]);
#line 20222
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Current.RasterColor[3]);
#line 20223
  break;
  case 2825: 
#line 20225
  *(params + 0) = (int )ctx->Current.RasterDistance;
#line 20226
  break;
  case 2821: 
#line 20228
  *params = (int )ctx->Current.RasterIndex;
#line 20229
  break;
  case 2823: 
#line 20231
  *(params + 0) = (int )ctx->Current.RasterPos[0];
#line 20232
  *(params + 1) = (int )ctx->Current.RasterPos[1];
#line 20233
  *(params + 2) = (int )ctx->Current.RasterPos[2];
#line 20234
  *(params + 3) = (int )ctx->Current.RasterPos[3];
#line 20235
  break;
  case 2822: 
#line 20237
  *(params + 0) = (int )ctx->Current.RasterTexCoord[0];
#line 20238
  *(params + 1) = (int )ctx->Current.RasterTexCoord[1];
#line 20239
  *(params + 2) = (int )ctx->Current.RasterTexCoord[2];
#line 20240
  *(params + 3) = (int )ctx->Current.RasterTexCoord[3];
#line 20241
  break;
  case 2824: 
#line 20243
  *params = (int )ctx->Current.RasterPosValid;
#line 20244
  break;
  case 2819: 
#line 20246
  *(params + 0) = (int )ctx->Current.TexCoord[0];
#line 20247
  *(params + 1) = (int )ctx->Current.TexCoord[1];
#line 20248
  *(params + 2) = (int )ctx->Current.TexCoord[2];
#line 20249
  *(params + 3) = (int )ctx->Current.TexCoord[3];
#line 20250
  break;
  case 3359: 
#line 20252
  *params = (int )ctx->Pixel.DepthBias;
#line 20253
  break;
  case 3414: 
#line 20255
  *params = (ctx->Visual)->DepthBits;
#line 20256
  break;
  case 2931: 
#line 20258
  *params = (int )ctx->Depth.Clear;
#line 20259
  break;
  case 2932: 
#line 20261
  *params = ctx->Depth.Func;
#line 20262
  break;
  case 2928: 
#line 20264
  *(params + 0) = (int )ctx->Viewport.Near;
#line 20265
  *(params + 1) = (int )ctx->Viewport.Far;
#line 20266
  break;
  case 3358: 
#line 20268
  *params = (int )ctx->Pixel.DepthScale;
#line 20269
  break;
  case 2929: 
#line 20271
  *params = (int )ctx->Depth.Test;
#line 20272
  break;
  case 2930: 
#line 20274
  *params = (int )ctx->Depth.Mask;
#line 20275
  break;
  case 3024: 
#line 20277
  *params = (int )ctx->Color.DitherFlag;
#line 20278
  break;
  case 3122: 
#line 20280
  *params = (int )(ctx->Visual)->DBflag;
#line 20281
  break;
  case 3073: 
#line 20283
  *params = ctx->Color.DrawBuffer;
#line 20284
  break;
  case 2883: 
#line 20286
  *params = (int )ctx->Current.EdgeFlag;
#line 20287
  break;
  case 3569: 
#line 20289
  *params = (int )ctx->Feedback.BufferSize;
#line 20290
  break;
  case 3570: 
#line 20292
  *params = ctx->Feedback.Type;
#line 20293
  break;
  case 2912: 
#line 20295
  *params = (int )ctx->Fog.Enabled;
#line 20296
  break;
  case 2918: 
#line 20298
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Fog.Color[0]);
#line 20299
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Fog.Color[1]);
#line 20300
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Fog.Color[2]);
#line 20301
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Fog.Color[3]);
#line 20302
  break;
  case 2914: 
#line 20304
  *params = (int )ctx->Fog.Density;
#line 20305
  break;
  case 2916: 
#line 20307
  *params = (int )ctx->Fog.End;
#line 20308
  break;
  case 3156: 
#line 20310
  *params = ctx->Hint.Fog;
#line 20311
  break;
  case 2913: 
#line 20313
  *params = (int )ctx->Fog.Index;
#line 20314
  break;
  case 2917: 
#line 20316
  *params = ctx->Fog.Mode;
#line 20317
  break;
  case 2915: 
#line 20319
  *params = (int )ctx->Fog.Start;
#line 20320
  break;
  case 2886: 
#line 20322
  *params = ctx->Polygon.FrontFace;
#line 20323
  break;
  case 3353: 
#line 20325
  *params = (int )ctx->Pixel.GreenBias;
#line 20326
  break;
  case 3411: 
#line 20328
  *params = (ctx->Visual)->GreenBits;
#line 20329
  break;
  case 3352: 
#line 20331
  *params = (int )ctx->Pixel.GreenScale;
#line 20332
  break;
  case 3409: 
#line 20334
  *params = (ctx->Visual)->IndexBits;
#line 20335
  break;
  case 3104: 
#line 20337
  *params = (int )ctx->Color.ClearIndex;
#line 20338
  break;
  case 3120: 
#line 20340
  if ((ctx->Visual)->RGBAflag) {
#line 20340
    *params = 0;
  } else {
#line 20340
    *params = 1;
  }
#line 20341
  break;
  case 3347: 
#line 20343
  *params = ctx->Pixel.IndexOffset;
#line 20344
  break;
  case 3346: 
#line 20346
  *params = ctx->Pixel.IndexShift;
#line 20347
  break;
  case 3105: 
#line 20349
  *params = (int )ctx->Color.IndexMask;
#line 20350
  break;
  case 16384: 
  case 16385: 
  case 16386: 
  case 16387: 
  case 16388: 
  case 16389: 
  case 16390: 
  case 16391: 
#line 20359
  *params = (int )ctx->Light.Light[pname - 16384].Enabled;
#line 20360
  break;
  case 2896: 
#line 20362
  *params = (int )ctx->Light.Enabled;
#line 20363
  break;
  case 2899: 
#line 20365
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Light.Model.Ambient[0]);
#line 20366
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Light.Model.Ambient[1]);
#line 20367
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Light.Model.Ambient[2]);
#line 20368
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Light.Model.Ambient[3]);
#line 20369
  break;
  case 2897: 
#line 20371
  *params = (int )ctx->Light.Model.LocalViewer;
#line 20372
  break;
  case 2898: 
#line 20374
  *params = (int )ctx->Light.Model.TwoSide;
#line 20375
  break;
  case 2848: 
#line 20377
  *params = (int )ctx->Line.SmoothFlag;
#line 20378
  break;
  case 3154: 
#line 20380
  *params = ctx->Hint.LineSmooth;
#line 20381
  break;
  case 2852: 
#line 20383
  *params = (int )ctx->Line.StippleFlag;
#line 20384
  break;
  case 2853: 
#line 20386
  *params = (int )ctx->Line.StipplePattern;
#line 20387
  break;
  case 2854: 
#line 20389
  *params = ctx->Line.StippleFactor;
#line 20390
  break;
  case 2849: 
#line 20392
  *params = (int )ctx->Line.Width;
#line 20393
  break;
  case 2851: 
#line 20395
  *params = (int )1.0;
#line 20396
  break;
  case 2850: 
#line 20398
  *(params + 0) = (int )1.0;
#line 20399
  *(params + 1) = (int )10.0;
#line 20400
  break;
  case 2866: 
#line 20402
  *params = (int )ctx->List.ListBase;
#line 20403
  break;
  case 2867: 
#line 20405
  tmp___0 = gl_list_index();
#line 20405
  *params = tmp___0;
#line 20406
  break;
  case 2864: 
#line 20408
  if (ctx->ExecuteFlag) {
#line 20408
    *params = 4865;
  } else {
#line 20408
    *params = 4864;
  }
#line 20410
  break;
  case 3057: 
#line 20412
  *params = (int )ctx->Color.IndexLogicOpEnabled;
#line 20413
  break;
  case 3058: 
#line 20415
  *params = (int )ctx->Color.ColorLogicOpEnabled;
#line 20416
  break;
  case 3056: 
#line 20418
  *params = ctx->Color.LogicOp;
#line 20419
  break;
  case 3472: 
#line 20421
  *params = (int )ctx->Eval.Map1Color4;
#line 20422
  break;
  case 3536: 
#line 20424
  *(params + 0) = (int )ctx->Eval.MapGrid1u1;
#line 20425
  *(params + 1) = (int )ctx->Eval.MapGrid1u2;
#line 20426
  break;
  case 3537: 
#line 20428
  *params = (int )ctx->Eval.MapGrid1un;
#line 20429
  break;
  case 3473: 
#line 20431
  *params = (int )ctx->Eval.Map1Index;
#line 20432
  break;
  case 3474: 
#line 20434
  *params = (int )ctx->Eval.Map1Normal;
#line 20435
  break;
  case 3475: 
#line 20437
  *params = (int )ctx->Eval.Map1TextureCoord1;
#line 20438
  break;
  case 3476: 
#line 20440
  *params = (int )ctx->Eval.Map1TextureCoord2;
#line 20441
  break;
  case 3477: 
#line 20443
  *params = (int )ctx->Eval.Map1TextureCoord3;
#line 20444
  break;
  case 3478: 
#line 20446
  *params = (int )ctx->Eval.Map1TextureCoord4;
#line 20447
  break;
  case 3479: 
#line 20449
  *params = (int )ctx->Eval.Map1Vertex3;
#line 20450
  break;
  case 3480: 
#line 20452
  *params = (int )ctx->Eval.Map1Vertex4;
#line 20453
  break;
  case 3504: 
#line 20455
  *params = (int )ctx->Eval.Map2Color4;
#line 20456
  break;
  case 3538: 
#line 20458
  *(params + 0) = (int )ctx->Eval.MapGrid2u1;
#line 20459
  *(params + 1) = (int )ctx->Eval.MapGrid2u2;
#line 20460
  *(params + 2) = (int )ctx->Eval.MapGrid2v1;
#line 20461
  *(params + 3) = (int )ctx->Eval.MapGrid2v2;
#line 20462
  break;
  case 3539: 
#line 20464
  *(params + 0) = (int )ctx->Eval.MapGrid2un;
#line 20465
  *(params + 1) = (int )ctx->Eval.MapGrid2vn;
#line 20466
  break;
  case 3505: 
#line 20468
  *params = (int )ctx->Eval.Map2Index;
#line 20469
  break;
  case 3506: 
#line 20471
  *params = (int )ctx->Eval.Map2Normal;
#line 20472
  break;
  case 3507: 
#line 20474
  *params = (int )ctx->Eval.Map2TextureCoord1;
#line 20475
  break;
  case 3508: 
#line 20477
  *params = (int )ctx->Eval.Map2TextureCoord2;
#line 20478
  break;
  case 3509: 
#line 20480
  *params = (int )ctx->Eval.Map2TextureCoord3;
#line 20481
  break;
  case 3510: 
#line 20483
  *params = (int )ctx->Eval.Map2TextureCoord4;
#line 20484
  break;
  case 3511: 
#line 20486
  *params = (int )ctx->Eval.Map2Vertex3;
#line 20487
  break;
  case 3512: 
#line 20489
  *params = (int )ctx->Eval.Map2Vertex4;
#line 20490
  break;
  case 3344: 
#line 20492
  *params = (int )ctx->Pixel.MapColorFlag;
#line 20493
  break;
  case 3345: 
#line 20495
  *params = (int )ctx->Pixel.MapStencilFlag;
#line 20496
  break;
  case 2976: 
#line 20498
  *params = ctx->Transform.MatrixMode;
#line 20499
  break;
  case 3381: 
#line 20501
  *params = 16;
#line 20502
  break;
  case 3387: 
#line 20504
  *params = 16;
#line 20505
  break;
  case 3378: 
#line 20507
  *params = 6;
#line 20508
  break;
  case 3376: 
#line 20510
  *params = 30;
#line 20511
  break;
  case 3377: 
#line 20513
  *params = 8;
#line 20514
  break;
  case 2865: 
#line 20516
  *params = 64;
#line 20517
  break;
  case 3382: 
#line 20519
  *params = 32;
#line 20520
  break;
  case 3383: 
#line 20522
  *params = 64;
#line 20523
  break;
  case 3380: 
#line 20525
  *params = 256;
#line 20526
  break;
  case 3384: 
#line 20528
  *params = 32;
#line 20529
  break;
  case 3379: 
#line 20531
  *params = 1 << 10;
#line 20532
  break;
  case 3385: 
#line 20534
  *params = 10;
#line 20535
  break;
  case 3386: 
#line 20537
  *(params + 0) = 640;
#line 20538
  *(params + 1) = 400;
#line 20539
  break;
  case 2982: 
#line 20541
  i = 0U;
#line 20541
  while (i < 16U) {
#line 20542
    *(params + i) = (int )ctx->ModelViewMatrix[i];
#line 20541
    i ++;
  }
#line 20544
  break;
  case 2979: 
#line 20546
  *params = (int )ctx->ModelViewStackDepth;
#line 20547
  break;
  case 3440: 
#line 20549
  *params = (int )ctx->Select.NameStackDepth;
#line 20550
  break;
  case 2977: 
#line 20552
  *params = (int )ctx->Transform.Normalize;
#line 20553
  break;
  case 3333: 
#line 20555
  *params = ctx->Pack.Alignment;
#line 20556
  break;
  case 3329: 
#line 20558
  *params = (int )ctx->Pack.LsbFirst;
#line 20559
  break;
  case 3330: 
#line 20561
  *params = ctx->Pack.RowLength;
#line 20562
  break;
  case 3332: 
#line 20564
  *params = ctx->Pack.SkipPixels;
#line 20565
  break;
  case 3331: 
#line 20567
  *params = ctx->Pack.SkipRows;
#line 20568
  break;
  case 3328: 
#line 20570
  *params = (int )ctx->Pack.SwapBytes;
#line 20571
  break;
  case 32875: 
#line 20573
  *params = ctx->Pack.SkipImages;
#line 20574
  break;
  case 32876: 
#line 20576
  *params = ctx->Pack.ImageHeight;
#line 20577
  break;
  case 3152: 
#line 20579
  *params = ctx->Hint.PerspectiveCorrection;
#line 20580
  break;
  case 3257: 
#line 20582
  *params = ctx->Pixel.MapAtoAsize;
#line 20583
  break;
  case 3256: 
#line 20585
  *params = ctx->Pixel.MapBtoBsize;
#line 20586
  break;
  case 3255: 
#line 20588
  *params = ctx->Pixel.MapGtoGsize;
#line 20589
  break;
  case 3253: 
#line 20591
  *params = ctx->Pixel.MapItoAsize;
#line 20592
  break;
  case 3252: 
#line 20594
  *params = ctx->Pixel.MapItoBsize;
#line 20595
  break;
  case 3251: 
#line 20597
  *params = ctx->Pixel.MapItoGsize;
#line 20598
  break;
  case 3248: 
#line 20600
  *params = ctx->Pixel.MapItoIsize;
#line 20601
  break;
  case 3250: 
#line 20603
  *params = ctx->Pixel.MapItoRsize;
#line 20604
  break;
  case 3254: 
#line 20606
  *params = ctx->Pixel.MapRtoRsize;
#line 20607
  break;
  case 3249: 
#line 20609
  *params = ctx->Pixel.MapStoSsize;
#line 20610
  break;
  case 2833: 
#line 20612
  *params = (int )ctx->Point.Size;
#line 20613
  break;
  case 2835: 
#line 20615
  *params = (int )0.1;
#line 20616
  break;
  case 2834: 
#line 20618
  *(params + 0) = (int )1.0;
#line 20619
  *(params + 1) = (int )10.0;
#line 20620
  break;
  case 2832: 
#line 20622
  *params = (int )ctx->Point.SmoothFlag;
#line 20623
  break;
  case 3153: 
#line 20625
  *params = ctx->Hint.PointSmooth;
#line 20626
  break;
  case 33062: 
#line 20628
  *params = (int )ctx->Point.MinSize;
#line 20629
  break;
  case 33063: 
#line 20631
  *params = (int )ctx->Point.MaxSize;
#line 20632
  break;
  case 33064: 
#line 20634
  *params = (int )ctx->Point.Threshold;
#line 20635
  break;
  case 33065: 
#line 20637
  *(params + 0) = (int )ctx->Point.Params[0];
#line 20638
  *(params + 1) = (int )ctx->Point.Params[1];
#line 20639
  *(params + 2) = (int )ctx->Point.Params[2];
#line 20640
  break;
  case 2880: 
#line 20642
  *(params + 0) = ctx->Polygon.FrontMode;
#line 20643
  *(params + 1) = ctx->Polygon.BackMode;
#line 20644
  break;
  case 32824: 
#line 20651
  *params = (int )ctx->Polygon.OffsetFactor;
#line 20652
  break;
  case 10752: 
#line 20654
  *params = (int )ctx->Polygon.OffsetUnits;
#line 20655
  break;
  case 2881: 
#line 20657
  *params = (int )ctx->Polygon.SmoothFlag;
#line 20658
  break;
  case 3155: 
#line 20660
  *params = ctx->Hint.PolygonSmooth;
#line 20661
  break;
  case 2882: 
#line 20663
  i = 0U;
#line 20663
  while (i < 32U) {
#line 20664
    *(params + i) = (int )ctx->PolygonStipple[i];
#line 20663
    i ++;
  }
#line 20666
  break;
  case 2983: 
#line 20668
  i = 0U;
#line 20668
  while (i < 16U) {
#line 20669
    *(params + i) = (int )ctx->ProjectionMatrix[i];
#line 20668
    i ++;
  }
#line 20671
  break;
  case 2980: 
#line 20673
  *params = (int )ctx->ProjectionStackDepth;
#line 20674
  break;
  case 3074: 
#line 20676
  *params = ctx->Pixel.ReadBuffer;
#line 20677
  break;
  case 3349: 
#line 20679
  *params = (int )ctx->Pixel.RedBias;
#line 20680
  break;
  case 3410: 
#line 20682
  *params = (ctx->Visual)->RedBits;
#line 20683
  break;
  case 3348: 
#line 20685
  *params = (int )ctx->Pixel.RedScale;
#line 20686
  break;
  case 3136: 
#line 20688
  *params = ctx->RenderMode;
#line 20689
  break;
  case 3121: 
#line 20691
  *params = (int )(ctx->Visual)->RGBAflag;
#line 20692
  break;
  case 3088: 
#line 20694
  *(params + 0) = ctx->Scissor.X;
#line 20695
  *(params + 1) = ctx->Scissor.Y;
#line 20696
  *(params + 2) = ctx->Scissor.Width;
#line 20697
  *(params + 3) = ctx->Scissor.Height;
#line 20698
  break;
  case 3089: 
#line 20700
  *params = (int )ctx->Scissor.Enabled;
#line 20701
  break;
  case 2900: 
#line 20703
  *params = ctx->Light.ShadeModel;
#line 20704
  break;
  case 33275: 
#line 20706
  *params = (int )ctx->Texture.SharedPalette;
#line 20707
  break;
  case 3415: 
#line 20709
  *params = (ctx->Visual)->StencilBits;
#line 20710
  break;
  case 2961: 
#line 20712
  *params = (int )ctx->Stencil.Clear;
#line 20713
  break;
  case 2964: 
#line 20715
  *params = ctx->Stencil.FailFunc;
#line 20716
  break;
  case 2962: 
#line 20718
  *params = ctx->Stencil.Function;
#line 20719
  break;
  case 2965: 
#line 20721
  *params = ctx->Stencil.ZFailFunc;
#line 20722
  break;
  case 2966: 
#line 20724
  *params = ctx->Stencil.ZPassFunc;
#line 20725
  break;
  case 2967: 
#line 20727
  *params = (int )ctx->Stencil.Ref;
#line 20728
  break;
  case 2960: 
#line 20730
  *params = (int )ctx->Stencil.Enabled;
#line 20731
  break;
  case 2963: 
#line 20733
  *params = (int )ctx->Stencil.ValueMask;
#line 20734
  break;
  case 2968: 
#line 20736
  *params = (int )ctx->Stencil.WriteMask;
#line 20737
  break;
  case 3123: 
#line 20739
  *params = 0;
#line 20740
  break;
  case 3408: 
#line 20742
  *params = 0;
#line 20743
  break;
  case 3552: 
#line 20745
  if (ctx->Texture.Enabled & 1U) {
#line 20745
    *params = (int )1.0;
  } else {
#line 20745
    *params = (int )0.0;
  }
#line 20746
  break;
  case 3553: 
#line 20748
  if (ctx->Texture.Enabled & 2U) {
#line 20748
    *params = (int )1.0;
  } else {
#line 20748
    *params = (int )0.0;
  }
#line 20749
  break;
  case 32879: 
#line 20751
  if (ctx->Texture.Enabled & 4U) {
#line 20751
    *params = (int )1.0;
  } else {
#line 20751
    *params = (int )0.0;
  }
#line 20752
  break;
  case 8705: 
#line 20754
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Texture.EnvColor[0]);
#line 20755
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Texture.EnvColor[1]);
#line 20756
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Texture.EnvColor[2]);
#line 20757
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Texture.EnvColor[3]);
#line 20758
  break;
  case 8704: 
#line 20760
  *params = ctx->Texture.EnvMode;
#line 20761
  break;
  case 3168: 
#line 20763
  if (ctx->Texture.TexGenEnabled & 4U) {
#line 20763
    *params = 1;
  } else {
#line 20763
    *params = 0;
  }
#line 20764
  break;
  case 3169: 
#line 20766
  if (ctx->Texture.TexGenEnabled & 8U) {
#line 20766
    *params = 1;
  } else {
#line 20766
    *params = 0;
  }
#line 20767
  break;
  case 3170: 
#line 20769
  if (ctx->Texture.TexGenEnabled & 2U) {
#line 20769
    *params = 1;
  } else {
#line 20769
    *params = 0;
  }
#line 20770
  break;
  case 3171: 
#line 20772
  if (ctx->Texture.TexGenEnabled & 1U) {
#line 20772
    *params = 1;
  } else {
#line 20772
    *params = 0;
  }
#line 20773
  break;
  case 2984: 
#line 20775
  i = 0U;
#line 20775
  while (i < 16U) {
#line 20776
    *(params + i) = (int )ctx->TextureMatrix[i];
#line 20775
    i ++;
  }
#line 20778
  break;
  case 2981: 
#line 20780
  *params = (int )ctx->TextureStackDepth;
#line 20781
  break;
  case 3317: 
#line 20783
  *params = ctx->Unpack.Alignment;
#line 20784
  break;
  case 3313: 
#line 20786
  *params = (int )ctx->Unpack.LsbFirst;
#line 20787
  break;
  case 3314: 
#line 20789
  *params = ctx->Unpack.RowLength;
#line 20790
  break;
  case 3316: 
#line 20792
  *params = ctx->Unpack.SkipPixels;
#line 20793
  break;
  case 3315: 
#line 20795
  *params = ctx->Unpack.SkipRows;
#line 20796
  break;
  case 3312: 
#line 20798
  *params = (int )ctx->Unpack.SwapBytes;
#line 20799
  break;
  case 32877: 
#line 20801
  *params = ctx->Unpack.SkipImages;
#line 20802
  break;
  case 32878: 
#line 20804
  *params = ctx->Unpack.ImageHeight;
#line 20805
  break;
  case 2978: 
#line 20807
  *(params + 0) = ctx->Viewport.X;
#line 20808
  *(params + 1) = ctx->Viewport.Y;
#line 20809
  *(params + 2) = ctx->Viewport.Width;
#line 20810
  *(params + 3) = ctx->Viewport.Height;
#line 20811
  break;
  case 3350: 
#line 20813
  *params = (int )ctx->Pixel.ZoomX;
#line 20814
  break;
  case 3351: 
#line 20816
  *params = (int )ctx->Pixel.ZoomY;
#line 20817
  break;
  case 32890: 
#line 20819
  *params = ctx->Array.VertexSize;
#line 20820
  break;
  case 32891: 
#line 20822
  *params = ctx->Array.VertexType;
#line 20823
  break;
  case 32892: 
#line 20825
  *params = ctx->Array.VertexStride;
#line 20826
  break;
  case 32893: 
#line 20828
  *params = 0;
#line 20829
  break;
  case 32894: 
#line 20831
  *params = ctx->Array.NormalType;
#line 20832
  break;
  case 32895: 
#line 20834
  *params = ctx->Array.NormalStride;
#line 20835
  break;
  case 32896: 
#line 20837
  *params = 0;
#line 20838
  break;
  case 32897: 
#line 20840
  *params = ctx->Array.ColorSize;
#line 20841
  break;
  case 32898: 
#line 20843
  *params = ctx->Array.ColorType;
#line 20844
  break;
  case 32899: 
#line 20846
  *params = ctx->Array.ColorStride;
#line 20847
  break;
  case 32900: 
#line 20849
  *params = 0;
#line 20850
  break;
  case 32901: 
#line 20852
  *params = ctx->Array.IndexType;
#line 20853
  break;
  case 32902: 
#line 20855
  *params = ctx->Array.IndexStride;
#line 20856
  break;
  case 32903: 
#line 20858
  *params = 0;
#line 20859
  break;
  case 32904: 
#line 20861
  *params = ctx->Array.TexCoordSize;
#line 20862
  break;
  case 32905: 
#line 20864
  *params = ctx->Array.TexCoordType;
#line 20865
  break;
  case 32906: 
#line 20867
  *params = ctx->Array.TexCoordStride;
#line 20868
  break;
  case 32907: 
#line 20870
  *params = 0;
#line 20871
  break;
  case 32908: 
#line 20873
  *params = ctx->Array.EdgeFlagStride;
#line 20874
  break;
  case 32909: 
#line 20876
  *params = 0;
#line 20877
  break;
  case 32872: 
#line 20879
  *params = (int )(ctx->Texture.Current1D)->Name;
#line 20880
  break;
  case 32873: 
#line 20882
  *params = (int )(ctx->Texture.Current2D)->Name;
#line 20883
  break;
  case 32874: 
#line 20885
  *params = (int )(ctx->Texture.Current3D)->Name;
#line 20886
  break;
  default: 
#line 20888
  gl_error(ctx, 1280, "glGetIntegerv");
  }
#line 20890
  return;
}
}
#line 20891 "D:/a/test/177.c"
void gl_GetPointerv(GLcontext *ctx , GLenum pname , GLvoid **params ) 
{ 

  {
#line 20893
  switch (pname) {
  case 32910: 
#line 20895
  *params = ctx->Array.VertexPtr;
#line 20896
  break;
  case 32911: 
#line 20898
  *params = ctx->Array.NormalPtr;
#line 20899
  break;
  case 32912: 
#line 20901
  *params = ctx->Array.ColorPtr;
#line 20902
  break;
  case 32913: 
#line 20904
  *params = ctx->Array.IndexPtr;
#line 20905
  break;
  case 32914: 
#line 20907
  *params = ctx->Array.TexCoordPtr;
#line 20908
  break;
  case 32915: 
#line 20910
  *params = (GLvoid *)ctx->Array.EdgeFlagPtr;
#line 20911
  break;
  case 3568: 
#line 20913
  *params = (GLvoid *)ctx->Feedback.Buffer;
#line 20914
  break;
  default: 
#line 20916
  gl_error(ctx, 1280, "glGetPointerv");
#line 20917
  return;
  }
#line 20919
  return;
}
}
#line 20935 "D:/a/test/177.c"
struct HashTable *NewHashTable(void) 
{ void *tmp___0 ;

  {
#line 20937
  tmp___0 = calloc(sizeof(struct HashTable ), 1U);
#line 20937
  return ((struct HashTable *)tmp___0);
}
}
#line 20939 "D:/a/test/177.c"
void DeleteHashTable(struct HashTable *table ) 
{ GLuint i ;
  struct HashEntry *entry ;
  struct HashEntry *next ;

  {
#line 20942
  ////assert(table);
#line 20943
  i = 0U;
#line 20943
  while (i < 1001U) {
#line 20944
    entry = table->Table[i];
#line 20945
    while (entry) {
#line 20946
      next = entry->Next;
#line 20947
      free((void *)entry);
#line 20948
      entry = next;
    }
#line 20943
    i ++;
  }
#line 20951
  free((void *)table);
#line 20952
  return;
}
}
#line 20953 "D:/a/test/177.c"
void *HashLookup(struct HashTable  const  *table , GLuint key ) 
{ GLuint pos ;
  struct HashEntry *entry ;

  {
#line 20957
  ////assert(table);
#line 20958
 // //assert(key);
#line 20959
  pos = key % 1001U;
#line 20960
  entry = table->Table[pos];
#line 20961
  while (entry) {
#line 20962
    if (entry->Key == key) {
#line 20963
      return (entry->Data);
    }
#line 20965
    entry = entry->Next;
  }
#line 20967
  return ((void *)0);
}
}
#line 20969 "D:/a/test/177.c"
void HashInsert(struct HashTable *table , GLuint key , void *data ) 
{ GLuint pos ;
  struct HashEntry *entry ;
  void *tmp___0 ;

  {
#line 20973
 // //assert(table);
#line 20974
 // //assert(key);
#line 20975
  if (key > table->MaxKey) {
#line 20976
    table->MaxKey = key;
  }
#line 20977
  pos = key % 1001U;
#line 20978
  entry = table->Table[pos];
#line 20979
  while (entry) {
#line 20980
    if (entry->Key == key) {
#line 20981
      entry->Data = data;
#line 20982
      return;
    }
#line 20984
    entry = entry->Next;
  }
#line 20986
  tmp___0 = calloc(sizeof(struct HashEntry ), 1U);
#line 20986
  entry = (struct HashEntry *)tmp___0;
#line 20987
  entry->Key = key;
#line 20988
  entry->Data = data;
#line 20989
  entry->Next = table->Table[pos];
#line 20990
  table->Table[pos] = entry;
#line 20991
  return;
}
}
#line 20992 "D:/a/test/177.c"
void HashRemove(struct HashTable *table , GLuint key ) 
{ GLuint pos ;
  struct HashEntry *entry ;
  struct HashEntry *prev ;

  {
#line 20996
//  //assert(table);
#line 20997
 // //assert(key);
#line 20998
  pos = key % 1001U;
#line 20999
  prev = (struct HashEntry *)((void *)0);
#line 21000
  entry = table->Table[pos];
#line 21001
  while (entry) {
#line 21002
    if (entry->Key == key) {
#line 21003
      if (prev) {
#line 21004
        prev->Next = entry->Next;
      } else {
#line 21007
        table->Table[pos] = entry->Next;
      }
#line 21009
      free((void *)entry);
#line 21010
      return;
    }
#line 21012
    prev = entry;
#line 21013
    entry = entry->Next;
  }
#line 21015
  return;
}
}
#line 21016 "D:/a/test/177.c"
GLuint HashFirstEntry(struct HashTable  const  *table ) 
{ GLuint pos ;

  {
#line 21019
//  //assert(table);
#line 21020
  pos = 0U;
#line 21020
  while (pos < 1001U) {
#line 21021
    if (table->Table[pos]) {
#line 21022
      return ((table->Table[pos])->Key);
    }
#line 21020
    pos ++;
  }
#line 21024
  return (0U);
}
}
#line 21026 "D:/a/test/177.c"
void HashPrint(struct HashTable  const  *table ) 
{ GLuint i ;
  struct HashEntry *entry ;

  {
#line 21029
  ////assert(table);
#line 21030
  i = 0U;
#line 21030
  while (i < 1001U) {
#line 21031
    entry = table->Table[i];
#line 21032
    while (entry) {
#line 21033
      printf("%u %p\n", entry->Key, entry->Data);
#line 21034
      entry = entry->Next;
    }
#line 21030
    i ++;
  }
#line 21037
  return;
}
}
#line 21038 "D:/a/test/177.c"
GLuint HashFindFreeKeyBlock(struct HashTable  const  *table , GLuint numKeys ) 
{ GLuint maxKey ;
  GLuint freeCount ;
  GLuint freeStart ;
  GLuint key ;
  void *tmp___0 ;

  {
#line 21040
  maxKey = (GLuint )(~ 0);
#line 21041
  if (maxKey - numKeys > (GLuint )table->MaxKey) {
#line 21042
    return ((unsigned int )(table->MaxKey + 1U));
  } else {
#line 21045
    freeCount = (GLuint )0;
#line 21046
    freeStart = (GLuint )0;
#line 21048
    key = 0U;
#line 21048
    while (key != maxKey) {
#line 21049
      tmp___0 = HashLookup(table, key);
#line 21049
      if (tmp___0) {
#line 21051
        freeCount = 0U;
#line 21052
        freeStart = key + 1U;
      } else {
#line 21056
        freeCount ++;
#line 21057
        if (freeCount == numKeys) {
#line 21058
          return (freeStart);
        }
      }
#line 21048
      key ++;
    }
#line 21062
    return (0U);
  }
}
}
#line 21071 "D:/a/test/177.c"
void gl_flip_bytes(GLubyte *p , GLuint n ) 
{ register GLuint i ;
  register GLuint a ;
  register GLuint b ;

  {
#line 21074
  i = 0U;
#line 21074
  while (i < n) {
#line 21075
    b = (unsigned int )*(p + i);
#line 21076
    a = ((((((((b & 1U) << 7) | ((b & 2U) << 5)) | ((b & 4U) << 3)) | ((b & 8U) << 1)) | ((b & 16U) >> 1)) | ((b & 32U) >> 3)) | ((b & 64U) >> 5)) | ((b & 128U) >> 7);
#line 21084
    *(p + i) = (unsigned char )a;
#line 21074
    i ++;
  }
#line 21086
  return;
}
}
#line 21087 "D:/a/test/177.c"
void gl_swap2(GLushort *p , GLuint n ) 
{ register GLuint i ;

  {
#line 21090
  i = 0U;
#line 21090
  while (i < n) {
#line 21091
    *(p + i) = (unsigned short )(((int )*(p + i) >> 8) | (((int )*(p + i) << 8) & 65280));
#line 21090
    i ++;
  }
#line 21093
  return;
}
}
#line 21094 "D:/a/test/177.c"
void gl_swap4(GLuint *p , GLuint n ) 
{ register GLuint i ;
  register GLuint a ;
  register GLuint b ;

  {
#line 21097
  i = 0U;
#line 21097
  while (i < n) {
#line 21098
    b = *(p + i);
#line 21099
    a = (((b >> 24) | ((b >> 8) & 65280U)) | ((b << 8) & 16711680U)) | ((b << 24) & 4278190080U);
#line 21103
    *(p + i) = a;
#line 21097
    i ++;
  }
#line 21105
  return;
}
}
#line 21106 "D:/a/test/177.c"
GLint gl_sizeof_type(GLenum type ) 
{ 

  {
#line 21108
  switch (type) {
  case 6656: 
#line 21110
  return (0);
  case 5121: 
#line 21112
  return ((int )sizeof(GLubyte ));
  case 5120: 
#line 21114
  return ((int )sizeof(GLbyte ));
  case 5123: 
#line 21116
  return ((int )sizeof(GLushort ));
  case 5122: 
#line 21118
  return ((int )sizeof(GLshort ));
  case 5125: 
#line 21120
  return ((int )sizeof(GLuint ));
  case 5124: 
#line 21122
  return ((int )sizeof(GLint ));
  case 5126: 
#line 21124
  return ((int )sizeof(float ));
  default: ;
#line 21126
  return (-1);
  }
}
}
#line 21129 "D:/a/test/177.c"
GLint gl_components_in_format(GLenum format ) 
{ 

  {
#line 21131
  switch (format) {
  case 6400: 
  case 6401: 
  case 6402: 
  case 6403: 
  case 6404: 
  case 6405: 
  case 6406: 
  case 6409: 
#line 21140
  return (1);
  case 6410: 
#line 21142
  return (2);
  case 6407: 
#line 21144
  return (3);
  case 6408: 
#line 21146
  return (4);
  default: ;
#line 21148
  return (-1);
  }
}
}
#line 21151 "D:/a/test/177.c"
GLvoid *gl_pixel_addr_in_image(struct gl_pixelstore_attrib *packing , GLvoid const   *image ,
                               GLsizei width , GLsizei height , GLenum format , GLenum type ,
                               GLint img , GLint row , GLint column ) 
{ GLint bytes_per_comp ;
  GLint comp_per_pixel ;
  GLint comps_per_row ;
  GLint pixels_per_row ;
  GLint bytes_per_image ;
  GLint rows_per_image ;
  GLint alignment ;
  GLint skiprows ;
  GLint skippixels ;
  GLint skipimages ;
  GLubyte *pixel_addr ;
  GLint bytes_per_row ;
  GLint tmp___0 ;
  GLint bytes_per_row___0 ;
  GLint tmp___1 ;

  {
#line 21167
  bytes_per_comp = gl_sizeof_type(type);
#line 21168
  if (bytes_per_comp < 0) {
#line 21169
    return ((void *)0);
  }
#line 21171
  comp_per_pixel = gl_components_in_format(format);
#line 21172
  if (comp_per_pixel < 0) {
#line 21173
    return ((void *)0);
  }
#line 21175
  alignment = packing->Alignment;
#line 21176
  if (packing->RowLength > 0) {
#line 21177
    pixels_per_row = packing->RowLength;
  } else {
#line 21180
    pixels_per_row = width;
  }
#line 21182
  if (packing->ImageHeight > 0) {
#line 21183
    rows_per_image = packing->ImageHeight;
  } else {
#line 21186
    rows_per_image = height;
  }
#line 21188
  skiprows = packing->SkipRows;
#line 21189
  skippixels = packing->SkipPixels;
#line 21190
  skipimages = packing->SkipImages;
#line 21191
  if (type == 6656) {
#line 21193
    if ((comp_per_pixel * pixels_per_row) % (8 * alignment) == 0) {
#line 21193
      tmp___0 = (comp_per_pixel * pixels_per_row) / (8 * alignment);
    } else {
#line 21193
      tmp___0 = (comp_per_pixel * pixels_per_row) / (8 * alignment) + 1;
    }
#line 21193
    bytes_per_row = alignment * tmp___0;
#line 21195
    bytes_per_image = bytes_per_row * rows_per_image;
#line 21196
    pixel_addr = (((GLubyte *)image + (skipimages + img) * bytes_per_image) + (skiprows + row) * bytes_per_row) + (skippixels + column) / 8;
  } else {
#line 21202
    if (bytes_per_comp >= alignment) {
#line 21203
      comps_per_row = comp_per_pixel * pixels_per_row;
    } else {
#line 21206
      bytes_per_row___0 = (bytes_per_comp * comp_per_pixel) * pixels_per_row;
#line 21208
      if (bytes_per_row___0 % alignment == 0) {
#line 21208
        tmp___1 = bytes_per_row___0 / alignment;
      } else {
#line 21208
        tmp___1 = bytes_per_row___0 / alignment + 1;
      }
#line 21208
      comps_per_row = (alignment / bytes_per_comp) * tmp___1;
    }
#line 21211
    bytes_per_image = (bytes_per_comp * comps_per_row) * rows_per_image;
#line 21212
    pixel_addr = (((GLubyte *)image + (skipimages + img) * bytes_per_image) + ((skiprows + row) * bytes_per_comp) * comps_per_row) + ((skippixels + column) * bytes_per_comp) * comp_per_pixel;
  }
#line 21217
  return ((GLvoid *)pixel_addr);
}
}
#line 21219 "D:/a/test/177.c"
struct gl_image *gl_unpack_image(GLcontext *ctx , GLint width , GLint height , GLenum srcFormat ,
                                 GLenum srcType , GLvoid const   *pixels ) 
{ int tmp___0 ;

  {
#line 21224
  tmp___0 = (int )gl_unpack_image3D(ctx, width, height, 1, srcFormat, srcType, pixels);
#line 21224
  return ((struct gl_image *)tmp___0);
}
}
#line 21227 "D:/a/test/177.c"
struct gl_image *gl_unpack_image3D(GLcontext *ctx , GLint width , GLint height , GLint depth ,
                                   GLenum srcFormat , GLenum srcType , GLvoid const   *pixels ) 
{ GLint components___0 ;
  GLenum destType ;
  struct gl_image *image ;
  GLint bytes ;
  GLint i ;
  GLint width_in_bytes ;
  GLint d ;
  GLubyte *buffer ;
  GLubyte *dst ;
  void *tmp___0 ;
  GLvoid *src ;
  GLvoid *tmp___1 ;
  void *tmp___2 ;
  struct gl_image *image___0 ;
  GLint width_in_bytes___0 ;
  GLubyte *buffer___0 ;
  GLubyte *dst___0 ;
  GLint i___0 ;
  GLint d___0 ;
  void *tmp___3 ;
  GLubyte *src___0 ;
  GLvoid *tmp___4 ;
  void *tmp___5 ;
  struct gl_image *image___1 ;
  float *buffer___1 ;
  float *dst___1 ;
  GLint elems_per_row ;
  GLint i___1 ;
  GLint j ;
  GLint d___1 ;
  GLboolean normalize ;
  void *tmp___6 ;
  int tmp___7 ;
  GLvoid *src___1 ;
  GLvoid *tmp___8 ;
  float *tmp___9 ;
  float *tmp___10 ;
  float *tmp___11 ;
  float *tmp___12 ;
  GLushort value ;
  float *tmp___13 ;
  float *tmp___14 ;
  float *tmp___15 ;
  float *tmp___16 ;
  GLshort value___0 ;
  float *tmp___17 ;
  float *tmp___18 ;
  float *tmp___19 ;
  float *tmp___20 ;
  GLuint value___1 ;
  float *tmp___21 ;
  float *tmp___22 ;
  float *tmp___23 ;
  float *tmp___24 ;
  GLint value___2 ;
  float *tmp___25 ;
  float *tmp___26 ;
  float *tmp___27 ;
  float *tmp___28 ;
  GLint value___3 ;
  float *tmp___29 ;
  void *tmp___30 ;

  {
#line 21234
  if (srcType == 5121) {
#line 21235
    destType = 5121;
  } else {
#line 21237
    if (srcType == 6656) {
#line 21238
      destType = 6656;
    } else {
#line 21241
      destType = 5126;
    }
  }
#line 21243
  components___0 = gl_components_in_format(srcFormat);
#line 21244
  if (components___0 < 0) {
#line 21245
    return ((struct gl_image *)((void *)0));
  }
#line 21246
  if (srcType == 6656) {
    goto _L;
  } else {
#line 21246
    if (destType == 6656) {
      _L: /* CIL Label */ 
#line 21250
      //assert(srcType == 6656);
#line 21251
      //assert(destType == 6656);
#line 21252
      if (width > 0) {
#line 21252
        if (height > 0) {
#line 21252
          if (depth > 0) {
#line 21253
            bytes = (((width + 7) / 8) * height) * depth;
          } else {
#line 21255
            bytes = 0;
          }
        } else {
#line 21255
          bytes = 0;
        }
      } else {
#line 21255
        bytes = 0;
      }
#line 21256
      if (bytes > 0) {
#line 21256
        if ((unsigned int )pixels != (unsigned int )((void *)0)) {
#line 21257
          tmp___0 = malloc((unsigned int )bytes);//34
#line 21257
          buffer = (GLubyte *)tmp___0;
#line 21258
          if (! buffer) {
#line 21259
            return ((struct gl_image *)((void *)0));
          }
#line 21261
          if (width % 8 == 0) {
#line 21261
            width_in_bytes = width / 8;
          } else {
#line 21261
            width_in_bytes = width / 8 + 1;
          }
#line 21262
          dst = buffer;
#line 21263
          d = 0;
#line 21263
          while (d < depth) {
#line 21264
            i = 0;
#line 21264
            while (i < height) {
#line 21265
              tmp___1 = gl_pixel_addr_in_image(& ctx->Unpack, pixels, width, height,
                                               6400, srcType, d, i, 0);
#line 21265
              src = tmp___1;
#line 21269
              if (! src) {
#line 21270
                free((void *)buffer);
#line 21271
                return ((struct gl_image *)((void *)0));
              }
#line 21273
              memcpy((void *)dst, (void const   *)src, (unsigned int )width_in_bytes);
#line 21274
              dst += width_in_bytes;
#line 21264
              i ++;
            }
#line 21263
            d ++;
          }
#line 21277
          if (ctx->Unpack.LsbFirst) {
#line 21278
            gl_flip_bytes(buffer, (unsigned int )bytes);
          }
        } else {
#line 21282
          buffer = (GLubyte *)((void *)0);
        }
      } else {
#line 21282
        buffer = (GLubyte *)((void *)0);
      }
#line 21284
      tmp___2 = malloc(sizeof(struct gl_image ));//35
#line 21284
      image = (struct gl_image *)tmp___2;
#line 21285
      if (image) {
#line 21286
        image->Width = width;
#line 21287
        image->Height = height;
#line 21288
        image->Depth = depth;
#line 21289
        image->Components = 0;
#line 21290
        image->Format = 6400;
#line 21291
        image->Type = 6656;
#line 21292
        image->Data = (GLvoid *)buffer;
#line 21293
        image->RefCount = 0;
      } else {
#line 21296
        if (buffer) {
#line 21297
          free((void *)buffer);
        }
#line 21298
        return ((struct gl_image *)((void *)0));
      }
#line 21300
      return (image);
    } else {
#line 21302
      if (! (srcFormat == 6402)) {
#line 21304
        if (! (srcFormat == 6401)) {
#line 21306
          if (destType == 5121) {
#line 21311
            //assert(srcType == 5121);
#line 21312
            width_in_bytes___0 = (int )((unsigned int )(width * components___0) * sizeof(GLubyte ));
#line 21313
            tmp___3 = malloc((unsigned int )((height * width_in_bytes___0) * depth));//36
#line 21313
            buffer___0 = (GLubyte *)tmp___3;
#line 21314
            if (! buffer___0) {
#line 21315
              return ((struct gl_image *)((void *)0));
            }
#line 21317
            dst___0 = buffer___0;
#line 21318
            d___0 = 0;
#line 21318
            while (d___0 < depth) {
#line 21319
              i___0 = 0;
#line 21319
              while (i___0 < height) {
#line 21320
                tmp___4 = gl_pixel_addr_in_image(& ctx->Unpack, pixels, width, height,
                                                 srcFormat, srcType, d___0, i___0,
                                                 0);
#line 21320
                src___0 = (GLubyte *)tmp___4;
#line 21322
                if (! src___0) {
#line 21323
                  free((void *)buffer___0);
#line 21324
                  return ((struct gl_image *)((void *)0));
                }
#line 21326
                memcpy((void *)dst___0, (void const   *)((void *)src___0), (unsigned int )width_in_bytes___0);
#line 21327
                dst___0 += width_in_bytes___0;
#line 21319
                i___0 ++;
              }
#line 21318
              d___0 ++;
            }
#line 21330
            if (ctx->Unpack.LsbFirst) {
#line 21331
              gl_flip_bytes(buffer___0, (unsigned int )((height * width_in_bytes___0) * depth));
            }
#line 21333
            tmp___5 = malloc(sizeof(struct gl_image ));//37
#line 21333
            image___0 = (struct gl_image *)tmp___5;
#line 21334
            if (image___0) {
#line 21335
              image___0->Width = width;
#line 21336
              image___0->Height = height;
#line 21337
              image___0->Depth = depth;
#line 21338
              image___0->Components = components___0;
#line 21339
              image___0->Format = srcFormat;
#line 21340
              image___0->Type = 5121;
#line 21341
              image___0->Data = (GLvoid *)buffer___0;
#line 21342
              image___0->RefCount = 0;
            } else {
#line 21345
              free((void *)buffer___0);
#line 21346
              return ((struct gl_image *)((void *)0));
            }
#line 21348
            return (image___0);
          }   else {
#line 21350
            if (destType == 5126) {
#line 21356
              elems_per_row = width * components___0;
#line 21357
              tmp___6 = malloc(((unsigned int )(height * elems_per_row) * sizeof(float )) * (unsigned int )depth);//37
#line 21357
              buffer___1 = (float *)tmp___6;
#line 21358
              if (! buffer___1) {
#line 21359
                return ((struct gl_image *)((void *)0));
              }
#line 21361
              if (srcFormat != 6400) {
#line 21361
                if (srcFormat != 6401) {
#line 21361
                  tmp___7 = 1;
                } else {
#line 21361
                  tmp___7 = 0;
                }
              } else {
#line 21361
                tmp___7 = 0;
              }
#line 21361
              normalize = (unsigned char )tmp___7;
#line 21363
              dst___1 = buffer___1;
#line 21364
              d___1 = 0;
#line 21364
              while (d___1 < depth) {
#line 21365
                i___1 = 0;
#line 21365
                while (i___1 < height) {
#line 21366
                  tmp___8 = gl_pixel_addr_in_image(& ctx->Unpack, pixels, width, height,
                                                   srcFormat, srcType, d___1, i___1,
                                                   0);
#line 21366
                  src___1 = tmp___8;
#line 21370
                  if (! src___1) {
#line 21371
                    free((void *)buffer___1);
#line 21372
                    return ((struct gl_image *)((void *)0));
                  }
#line 21374
                  switch (srcType) {
                  case 5121: 
#line 21376
                  if (normalize) {
#line 21377
                    j = 0;
#line 21377
                    while (j < elems_per_row) {
#line 21378
                      tmp___9 = dst___1;
#line 21378
                      dst___1 ++;
#line 21378
                      *tmp___9 = (float )*((GLubyte *)src___1 + j) * (1.0F / 255.0F);
#line 21377
                      j ++;
                    }
                  } else {
#line 21382
                    j = 0;
#line 21382
                    while (j < elems_per_row) {
#line 21383
                      tmp___10 = dst___1;
#line 21383
                      dst___1 ++;
#line 21383
                      *tmp___10 = (float )*((GLubyte *)src___1 + j);
#line 21382
                      j ++;
                    }
                  }
#line 21386
                  break;
                  case 5120: 
#line 21388
                  if (normalize) {
#line 21389
                    j = 0;
#line 21389
                    while (j < elems_per_row) {
#line 21390
                      tmp___11 = dst___1;
#line 21390
                      dst___1 ++;
#line 21390
                      *tmp___11 = (2.0F * (float )*((GLbyte *)src___1 + j) + 1.0F) * (1.0F / 255.0F);
#line 21389
                      j ++;
                    }
                  } else {
#line 21394
                    j = 0;
#line 21394
                    while (j < elems_per_row) {
#line 21395
                      tmp___12 = dst___1;
#line 21395
                      dst___1 ++;
#line 21395
                      *tmp___12 = (float )*((GLbyte *)src___1 + j);
#line 21394
                      j ++;
                    }
                  }
#line 21398
                  break;
                  case 5123: 
#line 21400
                  if (ctx->Unpack.SwapBytes) {
#line 21401
                    j = 0;
#line 21401
                    while (j < elems_per_row) {
#line 21402
                      value = *((GLushort *)src___1 + j);
#line 21403
                      value = (unsigned short )((((int )value >> 8) & 255) | (((int )value & 255) << 8));
#line 21404
                      if (normalize) {
#line 21405
                        tmp___13 = dst___1;
#line 21405
                        dst___1 ++;
#line 21405
                        *tmp___13 = (float )value * (1.0F / 65535.0F);
                      } else {
#line 21408
                        tmp___14 = dst___1;
#line 21408
                        dst___1 ++;
#line 21408
                        *tmp___14 = (float )value;
                      }
#line 21401
                      j ++;
                    }
                  } else {
#line 21413
                    if (normalize) {
#line 21414
                      j = 0;
#line 21414
                      while (j < elems_per_row) {
#line 21415
                        tmp___15 = dst___1;
#line 21415
                        dst___1 ++;
#line 21415
                        *tmp___15 = (float )*((GLushort *)src___1 + j) * (1.0F / 65535.0F);
#line 21414
                        j ++;
                      }
                    } else {
#line 21419
                      j = 0;
#line 21419
                      while (j < elems_per_row) {
#line 21420
                        tmp___16 = dst___1;
#line 21420
                        dst___1 ++;
#line 21420
                        *tmp___16 = (float )*((GLushort *)src___1 + j);
#line 21419
                        j ++;
                      }
                    }
                  }
#line 21424
                  break;
                  case 5122: 
#line 21426
                  if (ctx->Unpack.SwapBytes) {
#line 21427
                    j = 0;
#line 21427
                    while (j < elems_per_row) {
#line 21428
                      value___0 = *((GLshort *)src___1 + j);
#line 21429
                      value___0 = (short )((((int )value___0 >> 8) & 255) | (((int )value___0 & 255) << 8));
#line 21430
                      if (normalize) {
#line 21431
                        tmp___17 = dst___1;
#line 21431
                        dst___1 ++;
#line 21431
                        *tmp___17 = (2.0F * (float )value___0 + 1.0F) * (1.0F / 65535.0F);
                      } else {
#line 21434
                        tmp___18 = dst___1;
#line 21434
                        dst___1 ++;
#line 21434
                        *tmp___18 = (float )value___0;
                      }
#line 21427
                      j ++;
                    }
                  } else {
#line 21439
                    if (normalize) {
#line 21440
                      j = 0;
#line 21440
                      while (j < elems_per_row) {
#line 21441
                        tmp___19 = dst___1;
#line 21441
                        dst___1 ++;
#line 21441
                        *tmp___19 = (2.0F * (float )*((GLshort *)src___1 + j) + 1.0F) * (1.0F / 65535.0F);
#line 21440
                        j ++;
                      }
                    } else {
#line 21445
                      j = 0;
#line 21445
                      while (j < elems_per_row) {
#line 21446
                        tmp___20 = dst___1;
#line 21446
                        dst___1 ++;
#line 21446
                        *tmp___20 = (float )*((GLshort *)src___1 + j);
#line 21445
                        j ++;
                      }
                    }
                  }
#line 21450
                  break;
                  case 5125: 
#line 21452
                  if (ctx->Unpack.SwapBytes) {
#line 21454
                    j = 0;
#line 21454
                    while (j < elems_per_row) {
#line 21455
                      value___1 = *((GLuint *)src___1 + j);
#line 21456
                      value___1 = ((((value___1 & 4278190080U) >> 24) | ((value___1 & 16711680U) >> 8)) | ((value___1 & 65280U) << 8)) | ((value___1 & 255U) << 24);
#line 21460
                      if (normalize) {
#line 21461
                        tmp___21 = dst___1;
#line 21461
                        dst___1 ++;
#line 21461
                        *tmp___21 = (float )value___1 * (1.0F / 4294967295.0F);
                      } else {
#line 21464
                        tmp___22 = dst___1;
#line 21464
                        dst___1 ++;
#line 21464
                        *tmp___22 = (float )value___1;
                      }
#line 21454
                      j ++;
                    }
                  } else {
#line 21469
                    if (normalize) {
#line 21470
                      j = 0;
#line 21470
                      while (j < elems_per_row) {
#line 21471
                        tmp___23 = dst___1;
#line 21471
                        dst___1 ++;
#line 21471
                        *tmp___23 = (float )*((GLuint *)src___1 + j) * (1.0F / 4294967295.0F);
#line 21470
                        j ++;
                      }
                    } else {
#line 21475
                      j = 0;
#line 21475
                      while (j < elems_per_row) {
#line 21476
                        tmp___24 = dst___1;
#line 21476
                        dst___1 ++;
#line 21476
                        *tmp___24 = (float )*((GLuint *)src___1 + j);
#line 21475
                        j ++;
                      }
                    }
                  }
#line 21480
                  break;
                  case 5124: 
#line 21482
                  if (ctx->Unpack.SwapBytes) {
#line 21484
                    j = 0;
#line 21484
                    while (j < elems_per_row) {
#line 21485
                      value___2 = *((GLint *)src___1 + j);
#line 21486
                      value___2 = (int )((((((unsigned int )value___2 & 4278190080U) >> 24) | (unsigned int )((value___2 & 16711680) >> 8)) | (unsigned int )((value___2 & 65280) << 8)) | (unsigned int )((value___2 & 255) << 24));
#line 21490
                      if (normalize) {
#line 21491
                        tmp___25 = dst___1;
#line 21491
                        dst___1 ++;
#line 21491
                        *tmp___25 = (2.0F * (float )value___2 + 1.0F) * (1.0F / 4294967294.0F);
                      } else {
#line 21494
                        tmp___26 = dst___1;
#line 21494
                        dst___1 ++;
#line 21494
                        *tmp___26 = (float )value___2;
                      }
#line 21484
                      j ++;
                    }
                  } else {
#line 21499
                    if (normalize) {
#line 21500
                      j = 0;
#line 21500
                      while (j < elems_per_row) {
#line 21501
                        tmp___27 = dst___1;
#line 21501
                        dst___1 ++;
#line 21501
                        *tmp___27 = (2.0F * (float )*((GLint *)src___1 + j) + 1.0F) * (1.0F / 4294967294.0F);
#line 21500
                        j ++;
                      }
                    } else {
#line 21505
                      j = 0;
#line 21505
                      while (j < elems_per_row) {
#line 21506
                        tmp___28 = dst___1;
#line 21506
                        dst___1 ++;
#line 21506
                        *tmp___28 = (float )*((GLint *)src___1 + j);
#line 21505
                        j ++;
                      }
                    }
                  }
#line 21510
                  break;
                  case 5126: 
#line 21512
                  if (ctx->Unpack.SwapBytes) {
#line 21514
                    j = 0;
#line 21514
                    while (j < elems_per_row) {
#line 21515
                      value___3 = (int )*((GLuint *)src___1 + j);
#line 21516
                      value___3 = (int )((((((unsigned int )value___3 & 4278190080U) >> 24) | (unsigned int )((value___3 & 16711680) >> 8)) | (unsigned int )((value___3 & 65280) << 8)) | (unsigned int )((value___3 & 255) << 24));
#line 21520
                      tmp___29 = dst___1;
#line 21520
                      dst___1 ++;
#line 21520
                      *tmp___29 = *((float *)(& value___3));
#line 21514
                      j ++;
                    }
                  } else {
#line 21524
                    memcpy((void *)dst___1, (void const   *)src___1, (unsigned int )elems_per_row * sizeof(float ));
#line 21525
                    dst___1 += elems_per_row;
                  }
#line 21527
                  break;
                  default: 
#line 21529
                  gl_problem((GLcontext const   *)ctx, "Bad type in gl_unpack_image3D");
#line 21530
                  return ((struct gl_image *)((void *)0));
                  }
#line 21365
                  i___1 ++;
                }
#line 21364
                d___1 ++;
              }
#line 21534
              tmp___30 = malloc(sizeof(struct gl_image ));//38
#line 21534
              image___1 = (struct gl_image *)tmp___30;
#line 21535
              if (image___1) {
#line 21536
                image___1->Width = width;
#line 21537
                image___1->Height = height;
#line 21538
                image___1->Depth = depth;
#line 21539
                image___1->Components = components___0;
#line 21540
                image___1->Format = srcFormat;
#line 21541
                image___1->Type = 5126;
#line 21542
                image___1->Data = (GLvoid *)buffer___1;
#line 21543
                image___1->RefCount = 0;
              } else {
#line 21546
                free((void *)buffer___1);
#line 21547
                return ((struct gl_image *)((void *)0));
              }
#line 21549
              return (image___1);
            } else {
#line 21552
              gl_problem((GLcontext const   *)ctx, "Bad dest type in gl_unpack_image3D");
#line 21553
              return ((struct gl_image *)((void *)0));
            }
          }
        }
      }
    }
  }
#line 21555
  return ((struct gl_image *)((void *)0));
}
}
#line 21557 "D:/a/test/177.c"
void gl_free_image(struct gl_image *image ) 
{ 

  {
#line 21559
  if (image->Data) {
#line 21560
    free(image->Data);
  }
#line 21562
  free((void *)image);
#line 21563
  return;
}
}
#line 21569 "D:/a/test/177.c"
void gl_ShadeModel(GLcontext *ctx , GLenum mode ) 
{ 

  {
#line 21571
  if (ctx->Primitive != 6656) {
#line 21572
    gl_error(ctx, 1282, "glShadeModel");
#line 21573
    return;
  }
#line 21575
  switch (mode) {
  case 7424: 
  case 7425: 
#line 21578
  if (ctx->Light.ShadeModel != mode) {
#line 21579
    ctx->Light.ShadeModel = mode;
#line 21580
    ctx->NewState |= 2U;
  }
#line 21582
  break;
  default: 
#line 21584
  gl_error(ctx, 1280, "glShadeModel");
  }
#line 21586
  return;
}
}
#line 21613
extern int ( /* missing proto */  TRANSFORM_POINT)(float *a,float *b,float *c) ;
#line 21587 "D:/a/test/177.c"
void gl_Lightfv(GLcontext *ctx , GLenum light , GLenum pname , float const   *params ,
                GLint nparams ) 
{ GLint l ;
  float direction[4] ;
  double tmp___0 ;

  {
#line 21592
  if (ctx->Primitive != 6656) {
#line 21593
    gl_error(ctx, 1282, "glShadeModel");
#line 21594
    return;
  }
#line 21596
  l = light - 16384;
#line 21597
  if (l < 0) {
#line 21598
    gl_error(ctx, 1280, "glLight");
#line 21599
    return;
  } else {
#line 21597
    if (l >= 8) {
#line 21598
      gl_error(ctx, 1280, "glLight");
#line 21599
      return;
    }
  }
#line 21601
  switch (pname) {
  case 4608: 
#line 21603
  ctx->Light.Light[l].Ambient[0] = (float )*(params + 0);
#line 21603
  ctx->Light.Light[l].Ambient[1] = (float )*(params + 1);
#line 21603
  ctx->Light.Light[l].Ambient[2] = (float )*(params + 2);
#line 21603
  ctx->Light.Light[l].Ambient[3] = (float )*(params + 3);
#line 21604
  break;
  case 4609: 
#line 21606
  ctx->Light.Light[l].Diffuse[0] = (float )*(params + 0);
#line 21606
  ctx->Light.Light[l].Diffuse[1] = (float )*(params + 1);
#line 21606
  ctx->Light.Light[l].Diffuse[2] = (float )*(params + 2);
#line 21606
  ctx->Light.Light[l].Diffuse[3] = (float )*(params + 3);
#line 21607
  break;
  case 4610: 
#line 21609
  ctx->Light.Light[l].Specular[0] = (float )*(params + 0);
#line 21609
  ctx->Light.Light[l].Specular[1] = (float )*(params + 1);
#line 21609
  ctx->Light.Light[l].Specular[2] = (float )*(params + 2);
#line 21609
  ctx->Light.Light[l].Specular[3] = (float )*(params + 3);
#line 21610
  break;
  case 4611: 
#line 21613
  TRANSFORM_POINT(ctx->Light.Light[l].Position, ctx->ModelViewMatrix, params);
#line 21615
  break;
  case 4612: 
#line 21620
  direction[0] = (float )*(params + 0);
#line 21621
  direction[1] = (float )*(params + 1);
#line 21622
  direction[2] = (float )*(params + 2);
#line 21623
  direction[3] = (float )0.0;
#line 21624
  if (ctx->NewModelViewMatrix) {
#line 21625
    gl_analyze_modelview_matrix(ctx);
  }
#line 21627
  gl_transform_vector(ctx->Light.Light[l].Direction, direction, ctx->ModelViewInv);
#line 21630
  break;
  case 4613: 
#line 21632
  if ((double )*(params + 0) < 0.0) {
#line 21633
    gl_error(ctx, 1281, "glLight");
#line 21634
    return;
  } else {
#line 21632
    if ((double )*(params + 0) > 128.0) {
#line 21633
      gl_error(ctx, 1281, "glLight");
#line 21634
      return;
    }
  }
#line 21636
  if (ctx->Light.Light[l].SpotExponent != (float )*(params + 0)) {
#line 21637
    ctx->Light.Light[l].SpotExponent = (float )*(params + 0);
#line 21638
    gl_compute_spot_exp_table(& ctx->Light.Light[l]);
  }
#line 21640
  break;
  case 4614: 
#line 21642
  if ((double )*(params + 0) < 0.0) {
    goto _L;
  } else {
#line 21642
    if ((double )*(params + 0) > 90.0) {
      _L: /* CIL Label */ 
#line 21642
      if ((double )*(params + 0) != 180.0) {
#line 21643
        gl_error(ctx, 1281, "glLight");
#line 21644
        return;
      }
    }
  }
#line 21646
  ctx->Light.Light[l].SpotCutoff = (float )*(params + 0);
#line 21647
  tmp___0 = cos((double )*(params + 0) * (3.14159265358979323846 / 180.0));
#line 21647
  ctx->Light.Light[l].CosCutoff = (float )tmp___0;
#line 21648
  break;
  case 4615: 
#line 21650
  if ((double )*(params + 0) < 0.0) {
#line 21651
    gl_error(ctx, 1281, "glLight");
#line 21652
    return;
  }
#line 21654
  ctx->Light.Light[l].ConstantAttenuation = (float )*(params + 0);
#line 21655
  break;
  case 4616: 
#line 21657
  if ((double )*(params + 0) < 0.0) {
#line 21658
    gl_error(ctx, 1281, "glLight");
#line 21659
    return;
  }
#line 21661
  ctx->Light.Light[l].LinearAttenuation = (float )*(params + 0);
#line 21662
  break;
  case 4617: 
#line 21664
  if ((double )*(params + 0) < 0.0) {
#line 21665
    gl_error(ctx, 1281, "glLight");
#line 21666
    return;
  }
#line 21668
  ctx->Light.Light[l].QuadraticAttenuation = (float )*(params + 0);
#line 21669
  break;
  default: 
#line 21671
  gl_error(ctx, 1280, "glLight");
#line 21672
  break;
  }
#line 21674
  ctx->NewState |= 1U;
#line 21675
  return;
}
}
#line 21676 "D:/a/test/177.c"
void gl_GetLightfv(GLcontext *ctx , GLenum light , GLenum pname , float *params ) 
{ GLint l ;

  {
#line 21679
  l = light - 16384;
#line 21680
  if (l < 0) {
#line 21681
    gl_error(ctx, 1280, "glGetLightfv");
#line 21682
    return;
  } else {
#line 21680
    if (l >= 8) {
#line 21681
      gl_error(ctx, 1280, "glGetLightfv");
#line 21682
      return;
    }
  }
#line 21684
  switch (pname) {
  case 4608: 
#line 21686
  *(params + 0) = ctx->Light.Light[l].Ambient[0];
#line 21686
  *(params + 1) = ctx->Light.Light[l].Ambient[1];
#line 21686
  *(params + 2) = ctx->Light.Light[l].Ambient[2];
#line 21686
  *(params + 3) = ctx->Light.Light[l].Ambient[3];
#line 21687
  break;
  case 4609: 
#line 21689
  *(params + 0) = ctx->Light.Light[l].Diffuse[0];
#line 21689
  *(params + 1) = ctx->Light.Light[l].Diffuse[1];
#line 21689
  *(params + 2) = ctx->Light.Light[l].Diffuse[2];
#line 21689
  *(params + 3) = ctx->Light.Light[l].Diffuse[3];
#line 21690
  break;
  case 4610: 
#line 21692
  *(params + 0) = ctx->Light.Light[l].Specular[0];
#line 21692
  *(params + 1) = ctx->Light.Light[l].Specular[1];
#line 21692
  *(params + 2) = ctx->Light.Light[l].Specular[2];
#line 21692
  *(params + 3) = ctx->Light.Light[l].Specular[3];
#line 21693
  break;
  case 4611: 
#line 21695
  *(params + 0) = ctx->Light.Light[l].Position[0];
#line 21695
  *(params + 1) = ctx->Light.Light[l].Position[1];
#line 21695
  *(params + 2) = ctx->Light.Light[l].Position[2];
#line 21695
  *(params + 3) = ctx->Light.Light[l].Position[3];
#line 21696
  break;
  case 4612: 
#line 21698
  *(params + 0) = ctx->Light.Light[l].Direction[0];
#line 21698
  *(params + 1) = ctx->Light.Light[l].Direction[1];
#line 21698
  *(params + 2) = ctx->Light.Light[l].Direction[2];
#line 21699
  break;
  case 4613: 
#line 21701
  *(params + 0) = ctx->Light.Light[l].SpotExponent;
#line 21702
  break;
  case 4614: 
#line 21704
  *(params + 0) = ctx->Light.Light[l].SpotCutoff;
#line 21705
  break;
  case 4615: 
#line 21707
  *(params + 0) = ctx->Light.Light[l].ConstantAttenuation;
#line 21708
  break;
  case 4616: 
#line 21710
  *(params + 0) = ctx->Light.Light[l].LinearAttenuation;
#line 21711
  break;
  case 4617: 
#line 21713
  *(params + 0) = ctx->Light.Light[l].QuadraticAttenuation;
#line 21714
  break;
  default: 
#line 21716
  gl_error(ctx, 1280, "glGetLightfv");
#line 21717
  break;
  }
#line 21719
  return;
}
}
#line 21720 "D:/a/test/177.c"
void gl_GetLightiv(GLcontext *ctx , GLenum light , GLenum pname , GLint *params ) 
{ GLint l ;

  {
#line 21722
  l = light - 16384;
#line 21723
  if (l < 0) {
#line 21724
    gl_error(ctx, 1280, "glGetLightiv");
#line 21725
    return;
  } else {
#line 21723
    if (l >= 8) {
#line 21724
      gl_error(ctx, 1280, "glGetLightiv");
#line 21725
      return;
    }
  }
#line 21727
  switch (pname) {
  case 4608: 
#line 21729
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Ambient[0]);
#line 21730
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Ambient[1]);
#line 21731
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Ambient[2]);
#line 21732
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Ambient[3]);
#line 21733
  break;
  case 4609: 
#line 21735
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Diffuse[0]);
#line 21736
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Diffuse[1]);
#line 21737
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Diffuse[2]);
#line 21738
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Diffuse[3]);
#line 21739
  break;
  case 4610: 
#line 21741
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Specular[0]);
#line 21742
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Specular[1]);
#line 21743
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Specular[2]);
#line 21744
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Light.Light[l].Specular[3]);
#line 21745
  break;
  case 4611: 
#line 21747
  *(params + 0) = (int )ctx->Light.Light[l].Position[0];
#line 21748
  *(params + 1) = (int )ctx->Light.Light[l].Position[1];
#line 21749
  *(params + 2) = (int )ctx->Light.Light[l].Position[2];
#line 21750
  *(params + 3) = (int )ctx->Light.Light[l].Position[3];
#line 21751
  break;
  case 4612: 
#line 21753
  *(params + 0) = (int )ctx->Light.Light[l].Direction[0];
#line 21754
  *(params + 1) = (int )ctx->Light.Light[l].Direction[1];
#line 21755
  *(params + 2) = (int )ctx->Light.Light[l].Direction[2];
#line 21756
  break;
  case 4613: 
#line 21758
  *(params + 0) = (int )ctx->Light.Light[l].SpotExponent;
#line 21759
  break;
  case 4614: 
#line 21761
  *(params + 0) = (int )ctx->Light.Light[l].SpotCutoff;
#line 21762
  break;
  case 4615: 
#line 21764
  *(params + 0) = (int )ctx->Light.Light[l].ConstantAttenuation;
#line 21765
  break;
  case 4616: 
#line 21767
  *(params + 0) = (int )ctx->Light.Light[l].LinearAttenuation;
#line 21768
  break;
  case 4617: 
#line 21770
  *(params + 0) = (int )ctx->Light.Light[l].QuadraticAttenuation;
#line 21771
  break;
  default: 
#line 21773
  gl_error(ctx, 1280, "glGetLightiv");
#line 21774
  break;
  }
#line 21776
  return;
}
}
#line 21777 "D:/a/test/177.c"
void gl_LightModelfv(GLcontext *ctx , GLenum pname , float const   *params ) 
{ 

  {
#line 21779
  switch (pname) {
  case 2899: 
#line 21781
  ctx->Light.Model.Ambient[0] = (float )*(params + 0);
#line 21781
  ctx->Light.Model.Ambient[1] = (float )*(params + 1);
#line 21781
  ctx->Light.Model.Ambient[2] = (float )*(params + 2);
#line 21781
  ctx->Light.Model.Ambient[3] = (float )*(params + 3);
#line 21782
  break;
  case 2897: 
#line 21784
  if ((double )*(params + 0) == 0.0) {
#line 21785
    ctx->Light.Model.LocalViewer = (unsigned char)0;
  } else {
#line 21787
    ctx->Light.Model.LocalViewer = (unsigned char)1;
  }
#line 21788
  break;
  case 2898: 
#line 21790
  if ((double )*(params + 0) == 0.0) {
#line 21791
    ctx->Light.Model.TwoSide = (unsigned char)0;
  } else {
#line 21793
    ctx->Light.Model.TwoSide = (unsigned char)1;
  }
#line 21794
  break;
  default: 
#line 21796
  gl_error(ctx, 1280, "glLightModel");
#line 21797
  break;
  }
#line 21799
  ctx->NewState |= 1U;
#line 21800
  return;
}
}
#line 21801 "D:/a/test/177.c"
GLuint gl_material_bitmask(GLenum face , GLenum pname ) 
{ GLuint bitmask ;

  {
#line 21803
  bitmask = (GLuint )0;
#line 21804
  switch (pname) {
  case 5632: 
#line 21806
  bitmask |= 192U;
#line 21807
  break;
  case 4608: 
#line 21809
  bitmask |= 3U;
#line 21810
  break;
  case 4609: 
#line 21812
  bitmask |= 12U;
#line 21813
  break;
  case 4610: 
#line 21815
  bitmask |= 48U;
#line 21816
  break;
  case 5633: 
#line 21818
  bitmask |= 768U;
#line 21819
  break;
  case 5634: 
#line 21821
  bitmask |= 3U;
#line 21822
  bitmask |= 12U;
#line 21823
  break;
  case 5635: 
#line 21825
  bitmask |= 3072U;
#line 21826
  break;
  default: 
#line 21828
  gl_problem((GLcontext const   *)((void *)0), "Bad param in gl_material_bitmask");
#line 21829
  return (0U);
  }
#line 21832
  if (face == 1028) {
#line 21833
    bitmask &= 1365U;
  } else {
#line 21835
    if (face == 1029) {
#line 21836
      bitmask &= 2730U;
    }
  }
#line 21838
  return (bitmask);
}
}
#line 21840 "D:/a/test/177.c"
void gl_set_material(GLcontext *ctx , GLuint bitmask , float const   *params ) 
{ struct gl_material *mat ;
  struct vertex_buffer *VB ;
  float shininess ;
  float tmp___0 ;
  float tmp___1 ;
  float shininess___0 ;
  float tmp___2 ;
  float tmp___3 ;

  {
#line 21843
  if (ctx->Primitive != 6656) {
#line 21844
    VB = ctx->VB;
#line 21845
    mat = VB->Material[VB->Count];
#line 21846
    VB->MaterialMask[VB->Count] |= bitmask;
#line 21847
    VB->MonoMaterial = (unsigned char)0;
  } else {
#line 21850
    mat = ctx->Light.Material;
#line 21851
    ctx->NewState |= 1U;
  }
#line 21853
  if (bitmask & 1U) {
#line 21854
    (mat + 0)->Ambient[0] = (float )*(params + 0);
#line 21854
    (mat + 0)->Ambient[1] = (float )*(params + 1);
#line 21854
    (mat + 0)->Ambient[2] = (float )*(params + 2);
#line 21854
    (mat + 0)->Ambient[3] = (float )*(params + 3);
  }
#line 21856
  if (bitmask & 2U) {
#line 21857
    (mat + 1)->Ambient[0] = (float )*(params + 0);
#line 21857
    (mat + 1)->Ambient[1] = (float )*(params + 1);
#line 21857
    (mat + 1)->Ambient[2] = (float )*(params + 2);
#line 21857
    (mat + 1)->Ambient[3] = (float )*(params + 3);
  }
#line 21859
  if (bitmask & 4U) {
#line 21860
    (mat + 0)->Diffuse[0] = (float )*(params + 0);
#line 21860
    (mat + 0)->Diffuse[1] = (float )*(params + 1);
#line 21860
    (mat + 0)->Diffuse[2] = (float )*(params + 2);
#line 21860
    (mat + 0)->Diffuse[3] = (float )*(params + 3);
  }
#line 21862
  if (bitmask & 8U) {
#line 21863
    (mat + 1)->Diffuse[0] = (float )*(params + 0);
#line 21863
    (mat + 1)->Diffuse[1] = (float )*(params + 1);
#line 21863
    (mat + 1)->Diffuse[2] = (float )*(params + 2);
#line 21863
    (mat + 1)->Diffuse[3] = (float )*(params + 3);
  }
#line 21865
  if (bitmask & 16U) {
#line 21866
    (mat + 0)->Specular[0] = (float )*(params + 0);
#line 21866
    (mat + 0)->Specular[1] = (float )*(params + 1);
#line 21866
    (mat + 0)->Specular[2] = (float )*(params + 2);
#line 21866
    (mat + 0)->Specular[3] = (float )*(params + 3);
  }
#line 21868
  if (bitmask & 32U) {
#line 21869
    (mat + 1)->Specular[0] = (float )*(params + 0);
#line 21869
    (mat + 1)->Specular[1] = (float )*(params + 1);
#line 21869
    (mat + 1)->Specular[2] = (float )*(params + 2);
#line 21869
    (mat + 1)->Specular[3] = (float )*(params + 3);
  }
#line 21871
  if (bitmask & 64U) {
#line 21872
    (mat + 0)->Emission[0] = (float )*(params + 0);
#line 21872
    (mat + 0)->Emission[1] = (float )*(params + 1);
#line 21872
    (mat + 0)->Emission[2] = (float )*(params + 2);
#line 21872
    (mat + 0)->Emission[3] = (float )*(params + 3);
  }
#line 21874
  if (bitmask & 128U) {
#line 21875
    (mat + 1)->Emission[0] = (float )*(params + 0);
#line 21875
    (mat + 1)->Emission[1] = (float )*(params + 1);
#line 21875
    (mat + 1)->Emission[2] = (float )*(params + 2);
#line 21875
    (mat + 1)->Emission[3] = (float )*(params + 3);
  }
#line 21877
  if (bitmask & 256U) {
#line 21878
    if (*(params + 0) < (float const   )0.0F) {
#line 21878
      tmp___1 = 0.0F;
    } else {
#line 21878
      if (*(params + 0) > (float const   )128.0F) {
#line 21878
        tmp___0 = 128.0F;
      } else {
#line 21878
        tmp___0 = (float )*(params + 0);
      }
#line 21878
      tmp___1 = tmp___0;
    }
#line 21878
    shininess = tmp___1;
#line 21879
    if ((mat + 0)->Shininess != shininess) {
#line 21880
      (mat + 0)->Shininess = shininess;
#line 21881
      gl_compute_material_shine_table(mat + 0);
    }
  }
#line 21884
  if (bitmask & 512U) {
#line 21885
    if (*(params + 0) < (float const   )0.0F) {
#line 21885
      tmp___3 = 0.0F;
    } else {
#line 21885
      if (*(params + 0) > (float const   )128.0F) {
#line 21885
        tmp___2 = 128.0F;
      } else {
#line 21885
        tmp___2 = (float )*(params + 0);
      }
#line 21885
      tmp___3 = tmp___2;
    }
#line 21885
    shininess___0 = tmp___3;
#line 21886
    if ((mat + 1)->Shininess != shininess___0) {
#line 21887
      (mat + 1)->Shininess = shininess___0;
#line 21888
      gl_compute_material_shine_table(mat + 1);
    }
  }
#line 21891
  if (bitmask & 1024U) {
#line 21892
    (mat + 0)->AmbientIndex = (float )*(params + 0);
#line 21893
    (mat + 0)->DiffuseIndex = (float )*(params + 1);
#line 21894
    (mat + 0)->SpecularIndex = (float )*(params + 2);
  }
#line 21896
  if (bitmask & 2048U) {
#line 21897
    (mat + 1)->AmbientIndex = (float )*(params + 0);
#line 21898
    (mat + 1)->DiffuseIndex = (float )*(params + 1);
#line 21899
    (mat + 1)->SpecularIndex = (float )*(params + 2);
  }
#line 21901
  return;
}
}
#line 21902 "D:/a/test/177.c"
void gl_ColorMaterial(GLcontext *ctx , GLenum face , GLenum mode ) 
{ 

  {
#line 21904
  if (ctx->Primitive != 6656) {
#line 21905
    gl_error(ctx, 1282, "glColorMaterial");
#line 21906
    return;
  }
#line 21908
  switch (face) {
  case 1028: 
  case 1029: 
  case 1032: 
#line 21912
  ctx->Light.ColorMaterialFace = face;
#line 21913
  break;
  default: 
#line 21915
  gl_error(ctx, 1280, "glColorMaterial(face)");
#line 21916
  return;
  }
#line 21918
  switch (mode) {
  case 5632: 
  case 4608: 
  case 4609: 
  case 4610: 
  case 5634: 
#line 21924
  ctx->Light.ColorMaterialMode = mode;
#line 21925
  break;
  default: 
#line 21927
  gl_error(ctx, 1280, "glColorMaterial(mode)");
#line 21928
  return;
  }
#line 21930
  ctx->Light.ColorMaterialBitmask = gl_material_bitmask(face, mode);
#line 21931
  return;
}
}
#line 21932 "D:/a/test/177.c"
void gl_Materialfv(GLcontext *ctx , GLenum face , GLenum pname , float const   *params ) 
{ GLuint bitmask ;

  {
#line 21936
  if (face != 1028) {
#line 21936
    if (face != 1029) {
#line 21936
      if (face != 1032) {
#line 21937
        gl_error(ctx, 1280, "glMaterial(face)");
#line 21938
        return;
      }
    }
  }
#line 21940
  switch (pname) {
  case 5632: 
  case 4608: 
  case 4609: 
  case 4610: 
  case 5633: 
  case 5634: 
  case 5635: 
#line 21948
  break;
  default: 
#line 21950
  gl_error(ctx, 1280, "glMaterial(pname)");
#line 21951
  return;
  }
#line 21953
  bitmask = gl_material_bitmask(face, pname);
#line 21954
  if (ctx->Light.ColorMaterialEnabled) {
#line 21955
    bitmask &= ~ ctx->Light.ColorMaterialBitmask;
  }
#line 21957
  gl_set_material(ctx, bitmask, params);
#line 21958
  return;
}
}
#line 21959 "D:/a/test/177.c"
void gl_GetMaterialfv(GLcontext *ctx , GLenum face , GLenum pname , float *params ) 
{ GLuint f ;

  {
#line 21963
  if (ctx->Primitive != 6656) {
#line 21964
    gl_error(ctx, 1282, "glGetMaterialfv");
#line 21965
    return;
  }
#line 21967
  if (face == 1028) {
#line 21968
    f = 0U;
  } else {
#line 21970
    if (face == 1029) {
#line 21971
      f = 1U;
    } else {
#line 21974
      gl_error(ctx, 1280, "glGetMaterialfv(face)");
#line 21975
      return;
    }
  }
#line 21977
  switch (pname) {
  case 4608: 
#line 21979
  *(params + 0) = ctx->Light.Material[f].Ambient[0];
#line 21979
  *(params + 1) = ctx->Light.Material[f].Ambient[1];
#line 21979
  *(params + 2) = ctx->Light.Material[f].Ambient[2];
#line 21979
  *(params + 3) = ctx->Light.Material[f].Ambient[3];
#line 21980
  break;
  case 4609: 
#line 21982
  *(params + 0) = ctx->Light.Material[f].Diffuse[0];
#line 21982
  *(params + 1) = ctx->Light.Material[f].Diffuse[1];
#line 21982
  *(params + 2) = ctx->Light.Material[f].Diffuse[2];
#line 21982
  *(params + 3) = ctx->Light.Material[f].Diffuse[3];
#line 21983
  break;
  case 4610: 
#line 21985
  *(params + 0) = ctx->Light.Material[f].Specular[0];
#line 21985
  *(params + 1) = ctx->Light.Material[f].Specular[1];
#line 21985
  *(params + 2) = ctx->Light.Material[f].Specular[2];
#line 21985
  *(params + 3) = ctx->Light.Material[f].Specular[3];
#line 21986
  break;
  case 5632: 
#line 21988
  *(params + 0) = ctx->Light.Material[f].Emission[0];
#line 21988
  *(params + 1) = ctx->Light.Material[f].Emission[1];
#line 21988
  *(params + 2) = ctx->Light.Material[f].Emission[2];
#line 21988
  *(params + 3) = ctx->Light.Material[f].Emission[3];
#line 21989
  break;
  case 5633: 
#line 21991
  *params = ctx->Light.Material[f].Shininess;
#line 21992
  break;
  case 5635: 
#line 21994
  *(params + 0) = ctx->Light.Material[f].AmbientIndex;
#line 21995
  *(params + 1) = ctx->Light.Material[f].DiffuseIndex;
#line 21996
  *(params + 2) = ctx->Light.Material[f].SpecularIndex;
#line 21997
  break;
  default: 
#line 21999
  gl_error(ctx, 1280, "glGetMaterialfv(pname)");
  }
#line 22001
  return;
}
}
#line 22002 "D:/a/test/177.c"
void gl_GetMaterialiv(GLcontext *ctx , GLenum face , GLenum pname , GLint *params ) 
{ GLuint f ;

  {
#line 22006
  if (ctx->Primitive != 6656) {
#line 22007
    gl_error(ctx, 1282, "glGetMaterialiv");
#line 22008
    return;
  }
#line 22010
  if (face == 1028) {
#line 22011
    f = 0U;
  } else {
#line 22013
    if (face == 1029) {
#line 22014
      f = 1U;
    } else {
#line 22017
      gl_error(ctx, 1280, "glGetMaterialiv(face)");
#line 22018
      return;
    }
  }
#line 22020
  switch (pname) {
  case 4608: 
#line 22022
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Ambient[0]);
#line 22023
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Ambient[1]);
#line 22024
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Ambient[2]);
#line 22025
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Ambient[3]);
#line 22026
  break;
  case 4609: 
#line 22028
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Diffuse[0]);
#line 22029
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Diffuse[1]);
#line 22030
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Diffuse[2]);
#line 22031
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Diffuse[3]);
#line 22032
  break;
  case 4610: 
#line 22034
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Specular[0]);
#line 22035
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Specular[1]);
#line 22036
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Specular[2]);
#line 22037
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Specular[3]);
#line 22038
  break;
  case 5632: 
#line 22040
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Emission[0]);
#line 22041
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Emission[1]);
#line 22042
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Emission[2]);
#line 22043
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Light.Material[f].Emission[3]);
#line 22044
  break;
  case 5633: 
#line 22046
  if (ctx->Light.Material[f].Shininess < 0.0F) {
#line 22046
    *params = (int )(ctx->Light.Material[f].Shininess - 0.5F);
  } else {
#line 22046
    *params = (int )(ctx->Light.Material[f].Shininess + 0.5F);
  }
#line 22047
  break;
  case 5635: 
#line 22049
  if (ctx->Light.Material[f].AmbientIndex < 0.0F) {
#line 22049
    *(params + 0) = (int )(ctx->Light.Material[f].AmbientIndex - 0.5F);
  } else {
#line 22049
    *(params + 0) = (int )(ctx->Light.Material[f].AmbientIndex + 0.5F);
  }
#line 22050
  if (ctx->Light.Material[f].DiffuseIndex < 0.0F) {
#line 22050
    *(params + 1) = (int )(ctx->Light.Material[f].DiffuseIndex - 0.5F);
  } else {
#line 22050
    *(params + 1) = (int )(ctx->Light.Material[f].DiffuseIndex + 0.5F);
  }
#line 22051
  if (ctx->Light.Material[f].SpecularIndex < 0.0F) {
#line 22051
    *(params + 2) = (int )(ctx->Light.Material[f].SpecularIndex - 0.5F);
  } else {
#line 22051
    *(params + 2) = (int )(ctx->Light.Material[f].SpecularIndex + 0.5F);
  }
#line 22052
  break;
  default: 
#line 22054
  gl_error(ctx, 1280, "glGetMaterialfv(pname)");
  }
#line 22056
  return;
}
}
#line 22058 "D:/a/test/177.c"
void gl_compute_spot_exp_table(struct gl_light *l ) 
{ int i ;
  double exponent ;
  double tmp___0 ;
  int clamp ;

  {
#line 22061
  exponent = (double )l->SpotExponent;
#line 22063
  clamp = 0;
#line 22064
  l->SpotExpTable[0][0] = (float )0.0;
#line 22065
  i = 511;
#line 22065
  while (i > 0) {
#line 22066
    if (clamp == 0) {
#line 22067
      tmp___0 = pow((double )i / (double )511, exponent);
#line 22068
      if (tmp___0 < 1.175494e-38 * 100.0) {
#line 22069
        tmp___0 = 0.0;
#line 22070
        clamp = 1;
      }
    }
#line 22073
    l->SpotExpTable[i][0] = (float )tmp___0;
#line 22065
    i --;
  }
#line 22075
  i = 0;
#line 22075
  while (i < 511) {
#line 22076
    l->SpotExpTable[i][1] = l->SpotExpTable[i + 1][0] - l->SpotExpTable[i][0];
#line 22075
    i ++;
  }
#line 22078
  l->SpotExpTable[511][1] = (float )0.0;
#line 22079
  return;
}
}
#line 22080 "D:/a/test/177.c"
void gl_compute_material_shine_table(struct gl_material *m ) 
{ int i ;
  double exponent ;

  {
#line 22083
  exponent = (double )m->Shininess;
#line 22084
  m->ShineTable[0] = 0.0F;
#line 22085
  i = 1;
#line 22085
  while (i < 200) {
#line 22095
    m->ShineTable[i] = (float )(- 1.0);
#line 22085
    i ++;
  }
#line 22098
  return;
}
}
#line 22099 "D:/a/test/177.c"
void gl_update_lighting(GLcontext *ctx ) 
{ GLint i ;
  GLint side ;
  struct gl_light *prev_enabled ;
  struct gl_light *light ;
  struct gl_material *mat ;

  {
#line 22103
  if (! ctx->Light.Enabled) {
#line 22104
    return;
  }
#line 22106
  prev_enabled = (struct gl_light *)((void *)0);
#line 22107
  ctx->Light.FirstEnabled = (struct gl_light *)((void *)0);
#line 22108
  i = 0;
#line 22108
  while (i < 8) {
#line 22109
    ctx->Light.Light[i].NextEnabled = (struct gl_light *)((void *)0);
#line 22110
    if (ctx->Light.Light[i].Enabled) {
#line 22111
      if (prev_enabled) {
#line 22112
        prev_enabled->NextEnabled = & ctx->Light.Light[i];
      } else {
#line 22115
        ctx->Light.FirstEnabled = & ctx->Light.Light[i];
      }
#line 22117
      prev_enabled = & ctx->Light.Light[i];
    }
#line 22108
    i ++;
  }
#line 22120
  side = 0;
#line 22120
  while (side < 2) {
#line 22121
    ctx->Light.BaseColor[side][0] = ctx->Light.Material[side].Emission[0] + ctx->Light.Model.Ambient[0] * ctx->Light.Material[side].Ambient[0];
#line 22123
    ctx->Light.BaseColor[side][1] = ctx->Light.Material[side].Emission[1] + ctx->Light.Model.Ambient[1] * ctx->Light.Material[side].Ambient[1];
#line 22125
    ctx->Light.BaseColor[side][2] = ctx->Light.Material[side].Emission[2] + ctx->Light.Model.Ambient[2] * ctx->Light.Material[side].Ambient[2];
#line 22127
    if (ctx->Light.Material[side].Diffuse[3] < 1.0F) {
#line 22127
      ctx->Light.BaseColor[side][3] = ctx->Light.Material[side].Diffuse[3];
    } else {
#line 22127
      ctx->Light.BaseColor[side][3] = 1.0F;
    }
#line 22120
    side ++;
  }
#line 22130
  light = ctx->Light.FirstEnabled;
#line 22130
  while (light) {
#line 22131
    side = 0;
#line 22131
    while (side < 2) {
#line 22132
      mat = & ctx->Light.Material[side];
#line 22133
      ctx->Light.BaseColor[side][0] += light->Ambient[0] * mat->Ambient[0];
#line 22134
      ctx->Light.BaseColor[side][1] += light->Ambient[1] * mat->Ambient[1];
#line 22135
      ctx->Light.BaseColor[side][2] += light->Ambient[2] * mat->Ambient[2];
#line 22136
      light->MatAmbient[side][0] = light->Ambient[0] * mat->Ambient[0];
#line 22137
      light->MatAmbient[side][1] = light->Ambient[1] * mat->Ambient[1];
#line 22138
      light->MatAmbient[side][2] = light->Ambient[2] * mat->Ambient[2];
#line 22139
      light->MatDiffuse[side][0] = light->Diffuse[0] * mat->Diffuse[0];
#line 22140
      light->MatDiffuse[side][1] = light->Diffuse[1] * mat->Diffuse[1];
#line 22141
      light->MatDiffuse[side][2] = light->Diffuse[2] * mat->Diffuse[2];
#line 22142
      light->MatSpecular[side][0] = light->Specular[0] * mat->Specular[0];
#line 22143
      light->MatSpecular[side][1] = light->Specular[1] * mat->Specular[1];
#line 22144
      light->MatSpecular[side][2] = light->Specular[2] * mat->Specular[2];
#line 22145
      light->VP_inf_norm[0] = light->Position[0];
#line 22145
      light->VP_inf_norm[1] = light->Position[1];
#line 22145
      light->VP_inf_norm[2] = light->Position[2];
#line 22146
      NORMALIZE_3FV(light->VP_inf_norm);
#line 22147
      light->h_inf_norm[0] = light->VP_inf_norm[0];
#line 22147
      light->h_inf_norm[1] = light->VP_inf_norm[1];
#line 22147
      light->h_inf_norm[2] = light->VP_inf_norm[2];
#line 22148
      light->h_inf_norm[2] += 1.0F;
#line 22149
      NORMALIZE_3FV(light->h_inf_norm);
#line 22150
      light->NormDirection[0] = light->Direction[0];
#line 22150
      light->NormDirection[1] = light->Direction[1];
#line 22150
      light->NormDirection[2] = light->Direction[2];
#line 22151
      NORMALIZE_3FV(light->NormDirection);
#line 22152
      light->dli = (0.30F * light->Diffuse[0] + 0.59F * light->Diffuse[1]) + 0.11F * light->Diffuse[2];
#line 22155
      light->sli = (0.30F * light->Specular[0] + 0.59F * light->Specular[1]) + 0.11F * light->Specular[2];
#line 22131
      side ++;
    }
#line 22130
    light = light->NextEnabled;
  }
#line 22160
  ctx->Light.Fast = (unsigned char)1;
#line 22161
  if (ctx->Light.BaseColor[0][0] < 0.0F) {
#line 22171
    ctx->Light.Fast = (unsigned char)0;
  } else {
#line 22161
    if (ctx->Light.BaseColor[0][1] < 0.0F) {
#line 22171
      ctx->Light.Fast = (unsigned char)0;
    } else {
#line 22161
      if (ctx->Light.BaseColor[0][2] < 0.0F) {
#line 22171
        ctx->Light.Fast = (unsigned char)0;
      } else {
#line 22161
        if (ctx->Light.BaseColor[0][3] < 0.0F) {
#line 22171
          ctx->Light.Fast = (unsigned char)0;
        } else {
#line 22161
          if (ctx->Light.BaseColor[1][0] < 0.0F) {
#line 22171
            ctx->Light.Fast = (unsigned char)0;
          } else {
#line 22161
            if (ctx->Light.BaseColor[1][1] < 0.0F) {
#line 22171
              ctx->Light.Fast = (unsigned char)0;
            } else {
#line 22161
              if (ctx->Light.BaseColor[1][2] < 0.0F) {
#line 22171
                ctx->Light.Fast = (unsigned char)0;
              } else {
#line 22161
                if (ctx->Light.BaseColor[1][3] < 0.0F) {
#line 22171
                  ctx->Light.Fast = (unsigned char)0;
                } else {
#line 22161
                  if (ctx->Light.Model.LocalViewer) {
#line 22171
                    ctx->Light.Fast = (unsigned char)0;
                  } else {
#line 22161
                    if (ctx->Light.ColorMaterialEnabled) {
#line 22171
                      ctx->Light.Fast = (unsigned char)0;
                    } else {
#line 22174
                      light = ctx->Light.FirstEnabled;
#line 22174
                      while (light) {
#line 22175
                        if (light->Position[3] != 0.0F) {
#line 22189
                          ctx->Light.Fast = (unsigned char)0;
#line 22190
                          break;
                        } else {
#line 22175
                          if (light->SpotCutoff != 180.0F) {
#line 22189
                            ctx->Light.Fast = (unsigned char)0;
#line 22190
                            break;
                          } else {
#line 22175
                            if (light->MatDiffuse[0][0] < 0.0F) {
#line 22189
                              ctx->Light.Fast = (unsigned char)0;
#line 22190
                              break;
                            } else {
#line 22175
                              if (light->MatDiffuse[0][1] < 0.0F) {
#line 22189
                                ctx->Light.Fast = (unsigned char)0;
#line 22190
                                break;
                              } else {
#line 22175
                                if (light->MatDiffuse[0][2] < 0.0F) {
#line 22189
                                  ctx->Light.Fast = (unsigned char)0;
#line 22190
                                  break;
                                } else {
#line 22175
                                  if (light->MatSpecular[0][0] < 0.0F) {
#line 22189
                                    ctx->Light.Fast = (unsigned char)0;
#line 22190
                                    break;
                                  } else {
#line 22175
                                    if (light->MatSpecular[0][1] < 0.0F) {
#line 22189
                                      ctx->Light.Fast = (unsigned char)0;
#line 22190
                                      break;
                                    } else {
#line 22175
                                      if (light->MatSpecular[0][2] < 0.0F) {
#line 22189
                                        ctx->Light.Fast = (unsigned char)0;
#line 22190
                                        break;
                                      } else {
#line 22175
                                        if (light->MatDiffuse[1][0] < 0.0F) {
#line 22189
                                          ctx->Light.Fast = (unsigned char)0;
#line 22190
                                          break;
                                        } else {
#line 22175
                                          if (light->MatDiffuse[1][1] < 0.0F) {
#line 22189
                                            ctx->Light.Fast = (unsigned char)0;
#line 22190
                                            break;
                                          } else {
#line 22175
                                            if (light->MatDiffuse[1][2] < 0.0F) {
#line 22189
                                              ctx->Light.Fast = (unsigned char)0;
#line 22190
                                              break;
                                            } else {
#line 22175
                                              if (light->MatSpecular[1][0] < 0.0F) {
#line 22189
                                                ctx->Light.Fast = (unsigned char)0;
#line 22190
                                                break;
                                              } else {
#line 22175
                                                if (light->MatSpecular[1][1] < 0.0F) {
#line 22189
                                                  ctx->Light.Fast = (unsigned char)0;
#line 22190
                                                  break;
                                                } else {
#line 22175
                                                  if (light->MatSpecular[1][2] < 0.0F) {
#line 22189
                                                    ctx->Light.Fast = (unsigned char)0;
#line 22190
                                                    break;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
#line 22174
                        light = light->NextEnabled;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 22194
  return;
}
}
#line 22200 "D:/a/test/177.c"
void gl_LineWidth(GLcontext *ctx , float width ) 
{ 

  {
#line 22202
  if ((double )width <= 0.0) {
#line 22203
    gl_error(ctx, 1281, "glLineWidth");
#line 22204
    return;
  }
#line 22206
  if (ctx->Primitive != 6656) {
#line 22207
    gl_error(ctx, 1282, "glLineWidth");
#line 22208
    return;
  }
#line 22210
  ctx->Line.Width = width;
#line 22211
  ctx->NewState |= 2U;
#line 22212
  return;
}
}
#line 22213 "D:/a/test/177.c"
void gl_LineStipple(GLcontext *ctx , GLint factor , GLushort pattern ) 
{ int tmp___0 ;

  {
#line 22215
  if (ctx->Primitive != 6656) {
#line 22216
    gl_error(ctx, 1282, "glLineStipple");
#line 22217
    return;
  }
#line 22219
  if (factor < 1) {
#line 22219
    ctx->Line.StippleFactor = 1;
  } else {
#line 22219
    if (factor > 256) {
#line 22219
      tmp___0 = 256;
    } else {
#line 22219
      tmp___0 = factor;
    }
#line 22219
    ctx->Line.StippleFactor = tmp___0;
  }
#line 22220
  ctx->Line.StipplePattern = pattern;
#line 22221
  ctx->NewState |= 2U;
#line 22222
  return;
}
}
#line 22223 "D:/a/test/177.c"
static void feedback_line(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ) 
{ struct vertex_buffer *VB ;
  float x1 ;
  float y1___0 ;
  float z1 ;
  float w1 ;
  float x2 ;
  float y2 ;
  float z2 ;
  float w2 ;
  float tex1[4] ;
  float tex2[4] ;
  float invq ;
  float invRedScale ;
  float invGreenScale ;
  float invBlueScale ;
  float invAlphaScale ;
  float color[4] ;

  {
#line 22225
  VB = ctx->VB;
#line 22229
  invRedScale = (ctx->Visual)->InvRedScale;
#line 22230
  invGreenScale = (ctx->Visual)->InvGreenScale;
#line 22231
  invBlueScale = (ctx->Visual)->InvBlueScale;
#line 22232
  invAlphaScale = (ctx->Visual)->InvAlphaScale;
#line 22233
  x1 = VB->Win[v1][0];
#line 22234
  y1___0 = VB->Win[v1][1];
#line 22235
  z1 = VB->Win[v1][2] / 65535.0F;
#line 22236
  w1 = VB->Clip[v1][3];
#line 22237
  x2 = VB->Win[v2][0];
#line 22238
  y2 = VB->Win[v2][1];
#line 22239
  z2 = VB->Win[v2][2] / 65535.0F;
#line 22240
  w2 = VB->Clip[v2][3];
#line 22241
  if ((double )VB->TexCoord[v1][3] == 0.0) {
#line 22241
    invq = (float )1.0;
  } else {
#line 22241
    invq = 1.0F / VB->TexCoord[v1][3];
  }
#line 22242
  tex1[0] = VB->TexCoord[v1][0] * invq;
#line 22243
  tex1[1] = VB->TexCoord[v1][1] * invq;
#line 22244
  tex1[2] = VB->TexCoord[v1][2] * invq;
#line 22245
  tex1[3] = VB->TexCoord[v1][3];
#line 22246
  if ((double )VB->TexCoord[v2][3] == 0.0) {
#line 22246
    invq = (float )1.0;
  } else {
#line 22246
    invq = 1.0F / VB->TexCoord[v2][3];
  }
#line 22247
  tex2[0] = VB->TexCoord[v2][0] * invq;
#line 22248
  tex2[1] = VB->TexCoord[v2][1] * invq;
#line 22249
  tex2[2] = VB->TexCoord[v2][2] * invq;
#line 22250
  tex2[3] = VB->TexCoord[v2][3];
#line 22251
  if (ctx->StippleCounter == 0U) {
#line 22252
    FEEDBACK_TOKEN(ctx, (float )1799);
  } else {
#line 22255
    FEEDBACK_TOKEN(ctx, (float )1794);
  }
#line 22259
  color[0] = (float )(*(VB->Color + pv))[0] * invRedScale;
#line 22260
  color[1] = (float )(*(VB->Color + pv))[1] * invGreenScale;
#line 22261
  color[2] = (float )(*(VB->Color + pv))[2] * invBlueScale;
#line 22262
  color[3] = (float )(*(VB->Color + pv))[3] * invAlphaScale;
#line 22263
  gl_feedback_vertex(ctx, x1, y1___0, z1, w1, (float const   *)(color), (float )*(VB->Index + pv),
                     (float const   *)(tex1));
#line 22265
  gl_feedback_vertex(ctx, x2, y2, z2, w2, (float const   *)(color), (float )*(VB->Index + pv),
                     (float const   *)(tex2));
#line 22268
  (ctx->StippleCounter) ++;
#line 22269
  return;
}
}
#line 22270 "D:/a/test/177.c"
static void select_line(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ) 
{ 

  {
#line 22272
  gl_update_hitflag(ctx, (ctx->VB)->Win[v1][2] / 65535.0F);
#line 22273
  gl_update_hitflag(ctx, (ctx->VB)->Win[v2][2] / 65535.0F);
#line 22274
  return;
}
}
#line 22280 "D:/a/test/177.c"
static void flat_ci_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  struct vertex_buffer *VB ;
  GLint x0 ;
  GLint x1 ;
  GLint y0___0 ;
  GLint y1___0 ;
  GLint dx ;
  GLint dy ;
  GLint xstep ;
  GLint ystep ;
  GLint i ;
  GLint errorInc ;
  GLint error ;
  GLint errorDec ;
  GLint i___0 ;
  GLint errorInc___0 ;
  GLint error___0 ;
  GLint errorDec___0 ;

  {
#line 22284
  pbx = (ctx->PB)->x;
#line 22285
  pby = (ctx->PB)->y;
#line 22286
  PB_SET_INDEX(ctx, ctx->PB, *((ctx->VB)->Index + pvert));
#line 22287
  count = (int )(ctx->PB)->count;
#line 22296
  VB = ctx->VB;
#line 22297
  x0 = (int )VB->Win[vert0][0];
#line 22297
  x1 = (int )VB->Win[vert1][0];
#line 22298
  y0___0 = (int )VB->Win[vert0][1];
#line 22298
  y1___0 = (int )VB->Win[vert1][1];
#line 22365
  dx = x1 - x0;
#line 22366
  dy = y1___0 - y0___0;
#line 22367
  if (dx == 0) {
#line 22367
    if (dy == 0) {
#line 22368
      return;
    }
  }
#line 22386
  if (dx < 0) {
#line 22387
    dx = - dx;
#line 22389
    xstep = -1;
  } else {
#line 22400
    xstep = 1;
  }
#line 22409
  if (dy < 0) {
#line 22410
    dy = - dy;
#line 22412
    ystep = -1;
  } else {
#line 22423
    ystep = 1;
  }
#line 22432
  if (dx > dy) {
#line 22434
    errorInc = dy + dy;
#line 22435
    error = errorInc - dx;
#line 22436
    errorDec = error - dx;
#line 22467
    i = 0;
#line 22467
    while (i < dx) {
#line 22494
      *(pbx + count) = x0;
#line 22494
      *(pby + count) = y0___0;
#line 22494
      count ++;
#line 22502
      x0 += xstep;
#line 22535
      if (error < 0) {
#line 22536
        error += errorInc;
      } else {
#line 22539
        error += errorDec;
#line 22541
        y0___0 += ystep;
      }
#line 22467
      i ++;
    }
  } else {
#line 22554
    errorInc___0 = dx + dx;
#line 22555
    error___0 = errorInc___0 - dy;
#line 22556
    errorDec___0 = error___0 - dy;
#line 22587
    i___0 = 0;
#line 22587
    while (i___0 < dy) {
#line 22614
      *(pbx + count) = x0;
#line 22614
      *(pby + count) = y0___0;
#line 22614
      count ++;
#line 22622
      y0___0 += ystep;
#line 22655
      if (error___0 < 0) {
#line 22656
        error___0 += errorInc___0;
      } else {
#line 22659
        error___0 += errorDec___0;
#line 22661
        x0 += xstep;
      }
#line 22587
      i___0 ++;
    }
  }
#line 22688
  (ctx->PB)->count = (unsigned int )count;
#line 22689
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 22690
  return;
}
}
#line 22691 "D:/a/test/177.c"
static void flat_ci_z_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLdepth *pbz ;

  {
#line 22695
  pbx = (ctx->PB)->x;
#line 22696
  pby = (ctx->PB)->y;
#line 22697
  pbz = (ctx->PB)->z;
#line 22698
  PB_SET_INDEX(ctx, ctx->PB, *((ctx->VB)->Index + pvert));
#line 22699
  count = (int )(ctx->PB)->count;
#line 22707
  (ctx->PB)->count = (unsigned int )count;
#line 22708
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 22709
  return;
}
}
#line 22710 "D:/a/test/177.c"
static void flat_rgba_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLubyte *color ;

  {
#line 22714
  pbx = (ctx->PB)->x;
#line 22715
  pby = (ctx->PB)->y;
#line 22716
  color = *((ctx->VB)->Color + pvert);
#line 22717
  PB_SET_COLOR(ctx, ctx->PB, *(color + 0), *(color + 1), *(color + 2), *(color + 3));
#line 22718
  count = (int )(ctx->PB)->count;
#line 22724
  (ctx->PB)->count = (unsigned int )count;
#line 22725
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 22726
  return;
}
}
#line 22727 "D:/a/test/177.c"
static void flat_rgba_z_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLdepth *pbz ;
  GLubyte *color ;

  {
#line 22731
  pbx = (ctx->PB)->x;
#line 22732
  pby = (ctx->PB)->y;
#line 22733
  pbz = (ctx->PB)->z;
#line 22734
  color = *((ctx->VB)->Color + pvert);
#line 22735
  PB_SET_COLOR(ctx, ctx->PB, *(color + 0), *(color + 1), *(color + 2), *(color + 3));
#line 22736
  count = (int )(ctx->PB)->count;
#line 22744
  (ctx->PB)->count = (unsigned int )count;
#line 22745
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 22746
  return;
}
}
#line 22747 "D:/a/test/177.c"
static void smooth_ci_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLuint *pbi ;

  {
#line 22750
  count = (GLint )(ctx->PB)->count;
#line 22751
  pbx = (ctx->PB)->x;
#line 22752
  pby = (ctx->PB)->y;
#line 22753
  pbi = (ctx->PB)->i;
#line 22761
  (ctx->PB)->count = (unsigned int )count;
#line 22762
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 22763
  return;
}
}
#line 22764 "D:/a/test/177.c"
static void smooth_ci_z_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLdepth *pbz ;
  GLuint *pbi ;

  {
#line 22767
  count = (GLint )(ctx->PB)->count;
#line 22768
  pbx = (ctx->PB)->x;
#line 22769
  pby = (ctx->PB)->y;
#line 22770
  pbz = (ctx->PB)->z;
#line 22771
  pbi = (ctx->PB)->i;
#line 22781
  (ctx->PB)->count = (unsigned int )count;
#line 22782
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 22783
  return;
}
}
#line 22784 "D:/a/test/177.c"
static void smooth_rgba_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLubyte *pbr ;
  GLubyte *pbg ;
  GLubyte *pbb ;
  GLubyte *pba ;

  {
#line 22787
  count = (GLint )(ctx->PB)->count;
#line 22788
  pbx = (ctx->PB)->x;
#line 22789
  pby = (ctx->PB)->y;
#line 22790
  pbr = (ctx->PB)->r;
#line 22791
  pbg = (ctx->PB)->g;
#line 22792
  pbb = (ctx->PB)->b;
#line 22793
  pba = (ctx->PB)->a;
#line 22805
  (ctx->PB)->count = (unsigned int )count;
#line 22806
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 22807
  return;
}
}
#line 22808 "D:/a/test/177.c"
static void smooth_rgba_z_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLdepth *pbz ;
  GLubyte *pbr ;
  GLubyte *pbg ;
  GLubyte *pbb ;
  GLubyte *pba ;

  {
#line 22811
  count = (GLint )(ctx->PB)->count;
#line 22812
  pbx = (ctx->PB)->x;
#line 22813
  pby = (ctx->PB)->y;
#line 22814
  pbz = (ctx->PB)->z;
#line 22815
  pbr = (ctx->PB)->r;
#line 22816
  pbg = (ctx->PB)->g;
#line 22817
  pbb = (ctx->PB)->b;
#line 22818
  pba = (ctx->PB)->a;
#line 22832
  (ctx->PB)->count = (unsigned int )count;
#line 22833
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 22834
  return;
}
}
#line 22841 "D:/a/test/177.c"
static void general_smooth_ci_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 ,
                                   GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLdepth *pbz ;
  GLuint *pbi ;

  {
#line 22844
  count = (GLint )(ctx->PB)->count;
#line 22845
  pbx = (ctx->PB)->x;
#line 22846
  pby = (ctx->PB)->y;
#line 22847
  pbz = (ctx->PB)->z;
#line 22848
  pbi = (ctx->PB)->i;
#line 22849
  if (! ctx->Line.StippleFlag) {
#line 22864
    if (ctx->Line.Width == 2.0F) {

    }
  }
#line 22895
  (ctx->PB)->count = (unsigned int )count;
#line 22896
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 22897
  return;
}
}
#line 22898 "D:/a/test/177.c"
static void general_flat_ci_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLdepth *pbz ;

  {
#line 22902
  pbx = (ctx->PB)->x;
#line 22903
  pby = (ctx->PB)->y;
#line 22904
  pbz = (ctx->PB)->z;
#line 22905
  PB_SET_INDEX(ctx, ctx->PB, *((ctx->VB)->Index + pvert));
#line 22906
  count = (int )(ctx->PB)->count;
#line 22907
  if (! ctx->Line.StippleFlag) {
#line 22920
    if (ctx->Line.Width == 2.0F) {

    }
  }
#line 22946
  (ctx->PB)->count = (unsigned int )count;
#line 22947
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 22948
  return;
}
}
#line 22949 "D:/a/test/177.c"
static void general_smooth_rgba_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 ,
                                     GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLdepth *pbz ;
  GLubyte *pbr ;
  GLubyte *pbg ;
  GLubyte *pbb ;
  GLubyte *pba ;

  {
#line 22952
  count = (GLint )(ctx->PB)->count;
#line 22953
  pbx = (ctx->PB)->x;
#line 22954
  pby = (ctx->PB)->y;
#line 22955
  pbz = (ctx->PB)->z;
#line 22956
  pbr = (ctx->PB)->r;
#line 22957
  pbg = (ctx->PB)->g;
#line 22958
  pbb = (ctx->PB)->b;
#line 22959
  pba = (ctx->PB)->a;
#line 22960
  if (! ctx->Line.StippleFlag) {
#line 22979
    if (ctx->Line.Width == 2.0F) {

    }
  }
#line 23021
  (ctx->PB)->count = (unsigned int )count;
#line 23022
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 23023
  return;
}
}
#line 23024 "D:/a/test/177.c"
static void general_flat_rgba_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 ,
                                   GLuint pvert ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLdepth *pbz ;
  GLubyte *color ;

  {
#line 23028
  pbx = (ctx->PB)->x;
#line 23029
  pby = (ctx->PB)->y;
#line 23030
  pbz = (ctx->PB)->z;
#line 23031
  color = *((ctx->VB)->Color + pvert);
#line 23032
  PB_SET_COLOR(ctx, ctx->PB, *(color + 0), *(color + 1), *(color + 2), *(color + 3));
#line 23033
  count = (int )(ctx->PB)->count;
#line 23034
  if (! ctx->Line.StippleFlag) {
#line 23047
    if (ctx->Line.Width == 2.0F) {

    }
  }
#line 23073
  (ctx->PB)->count = (unsigned int )count;
#line 23074
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 23075
  return;
}
}
#line 23076 "D:/a/test/177.c"
static void flat_textured_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pv ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLdepth *pbz ;
  float *pbs ;
  float *pbt ;
  float *pbu ;
  GLubyte *color ;

  {
#line 23080
  pbx = (ctx->PB)->x;
#line 23081
  pby = (ctx->PB)->y;
#line 23082
  pbz = (ctx->PB)->z;
#line 23083
  pbs = (ctx->PB)->s;
#line 23084
  pbt = (ctx->PB)->t;
#line 23085
  pbu = (ctx->PB)->u;
#line 23086
  color = *((ctx->VB)->Color + pv);
#line 23087
  PB_SET_COLOR(ctx, ctx->PB, *(color + 0), *(color + 1), *(color + 2), *(color + 3));
#line 23088
  count = (int )(ctx->PB)->count;
#line 23089
  if (ctx->Line.StippleFlag) {

  }
#line 23122
  (ctx->PB)->count = (unsigned int )count;
#line 23123
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 23124
  return;
}
}
#line 23125 "D:/a/test/177.c"
static void smooth_textured_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pv ) 
{ GLint count ;
  GLint *pbx ;
  GLint *pby ;
  GLdepth *pbz ;
  float *pbs ;
  float *pbt ;
  float *pbu ;
  GLubyte *pbr ;
  GLubyte *pbg ;
  GLubyte *pbb ;
  GLubyte *pba ;

  {
#line 23128
  count = (GLint )(ctx->PB)->count;
#line 23129
  pbx = (ctx->PB)->x;
#line 23130
  pby = (ctx->PB)->y;
#line 23131
  pbz = (ctx->PB)->z;
#line 23132
  pbs = (ctx->PB)->s;
#line 23133
  pbt = (ctx->PB)->t;
#line 23134
  pbu = (ctx->PB)->u;
#line 23135
  pbr = (ctx->PB)->r;
#line 23136
  pbg = (ctx->PB)->g;
#line 23137
  pbb = (ctx->PB)->b;
#line 23138
  pba = (ctx->PB)->a;
#line 23139
  if (ctx->Line.StippleFlag) {

  }
#line 23184
  (ctx->PB)->count = (unsigned int )count;
#line 23185
  PB_CHECK_FLUSH(ctx, ctx->PB);
#line 23186
  return;
}
}
#line 23187 "D:/a/test/177.c"
static void null_line(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ) 
{ 

  {
#line 23189
  return;
}
}
#line 23190 "D:/a/test/177.c"
void gl_set_line_function(GLcontext *ctx ) 
{ GLboolean rgbmode ;

  {
#line 23192
  rgbmode = (ctx->Visual)->RGBAflag;
#line 23193
  if (ctx->RenderMode == 7168) {
#line 23194
    if (ctx->NoRaster) {
#line 23195
      ctx->Driver.LineFunc = & null_line;
#line 23196
      return;
    }
#line 23198
    if (ctx->Driver.LineFunc) {
#line 23199
      ctx->Driver.LineFunc = ctx->Driver.LineFunc;
    } else {
#line 23201
      if (ctx->Texture.Enabled) {
#line 23202
        if (ctx->Light.ShadeModel == 7425) {
#line 23203
          ctx->Driver.LineFunc = & smooth_textured_line;
        } else {
#line 23206
          ctx->Driver.LineFunc = & flat_textured_line;
        }
      } else {
#line 23209
        if ((double )ctx->Line.Width != 1.0) {
          goto _L___3;
        } else {
#line 23209
          if (ctx->Line.StippleFlag) {
            goto _L___3;
          } else {
#line 23209
            if (ctx->Line.SmoothFlag) {
              goto _L___3;
            } else {
#line 23209
              if (ctx->Texture.Enabled) {
                _L___3: /* CIL Label */ 
#line 23211
                if (ctx->Light.ShadeModel == 7425) {
#line 23212
                  if (rgbmode) {
#line 23212
                    ctx->Driver.LineFunc = & general_smooth_rgba_line;
                  } else {
#line 23212
                    ctx->Driver.LineFunc = & general_smooth_ci_line;
                  }
                } else {
#line 23216
                  if (rgbmode) {
#line 23216
                    ctx->Driver.LineFunc = & general_flat_rgba_line;
                  } else {
#line 23216
                    ctx->Driver.LineFunc = & general_flat_ci_line;
                  }
                }
              } else {
#line 23221
                if (ctx->Light.ShadeModel == 7425) {
#line 23223
                  if (ctx->Depth.Test) {
                    goto _L;
                  } else {
#line 23223
                    if (ctx->Fog.Enabled) {
#line 23223
                      if (ctx->Hint.Fog == 4354) {
                        _L: /* CIL Label */ 
#line 23225
                        if (rgbmode) {
#line 23225
                          ctx->Driver.LineFunc = & smooth_rgba_z_line;
                        } else {
#line 23225
                          ctx->Driver.LineFunc = & smooth_ci_z_line;
                        }
                      } else {
                        goto _L___0;
                      }
                    } else {
                      _L___0: /* CIL Label */ 
#line 23229
                      if (rgbmode) {
#line 23229
                        ctx->Driver.LineFunc = & smooth_rgba_line;
                      } else {
#line 23229
                        ctx->Driver.LineFunc = & smooth_ci_line;
                      }
                    }
                  }
                } else {
#line 23235
                  if (ctx->Depth.Test) {
                    goto _L___1;
                  } else {
#line 23235
                    if (ctx->Fog.Enabled) {
#line 23235
                      if (ctx->Hint.Fog == 4354) {
                        _L___1: /* CIL Label */ 
#line 23237
                        if (rgbmode) {
#line 23237
                          ctx->Driver.LineFunc = & flat_rgba_z_line;
                        } else {
#line 23237
                          ctx->Driver.LineFunc = & flat_ci_z_line;
                        }
                      } else {
                        goto _L___2;
                      }
                    } else {
                      _L___2: /* CIL Label */ 
#line 23241
                      if (rgbmode) {
#line 23241
                        ctx->Driver.LineFunc = & flat_rgba_line;
                      } else {
#line 23241
                        ctx->Driver.LineFunc = & flat_ci_line;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } else {
#line 23247
    if (ctx->RenderMode == 7169) {
#line 23248
      ctx->Driver.LineFunc = & feedback_line;
    } else {
#line 23251
      ctx->Driver.LineFunc = & select_line;
    }
  }
#line 23253
  return;
}
}
#line 23259 "D:/a/test/177.c"
void gl_LogicOp(GLcontext *ctx , GLenum opcode ) 
{ 

  {
#line 23261
  if (ctx->Primitive != 6656) {
#line 23262
    gl_error(ctx, 1282, "glLogicOp");
#line 23263
    return;
  }
#line 23265
  switch (opcode) {
  case 5376: 
  case 5391: 
  case 5379: 
  case 5388: 
  case 5381: 
  case 5386: 
  case 5377: 
  case 5390: 
  case 5383: 
  case 5384: 
  case 5382: 
  case 5385: 
  case 5378: 
  case 5380: 
  case 5387: 
  case 5389: 
#line 23282
  ctx->Color.LogicOp = opcode;
#line 23283
  ctx->NewState |= 2U;
#line 23284
  return;
  default: 
#line 23286
  gl_error(ctx, 1280, "glLogicOp");
#line 23287
  return;
  }
}
}
#line 23290 "D:/a/test/177.c"
void gl_logicop_ci_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLuint *index___0 ,
                        GLubyte *mask ) 
{ GLuint dest[640] ;
  GLuint i ;

  {
#line 23295
  (*(ctx->Driver.ReadIndexSpan))(ctx, n, x, y, dest);
#line 23296
  switch (ctx->Color.LogicOp) {
  case 5376: 
#line 23298
  i = 0U;
#line 23298
  while (i < n) {
#line 23299
    if (*(mask + i)) {
#line 23300
      *(index___0 + i) = 0U;
    }
#line 23298
    i ++;
  }
#line 23303
  break;
  case 5391: 
#line 23305
  i = 0U;
#line 23305
  while (i < n) {
#line 23306
    if (*(mask + i)) {
#line 23307
      *(index___0 + i) = 1U;
    }
#line 23305
    i ++;
  }
#line 23310
  break;
  case 5379: 
#line 23313
  break;
  case 5388: 
#line 23315
  i = 0U;
#line 23315
  while (i < n) {
#line 23316
    if (*(mask + i)) {
#line 23317
      *(index___0 + i) = ~ *(index___0 + i);
    }
#line 23315
    i ++;
  }
#line 23320
  break;
  case 5381: 
#line 23322
  i = 0U;
#line 23322
  while (i < n) {
#line 23323
    if (*(mask + i)) {
#line 23324
      *(index___0 + i) = dest[i];
    }
#line 23322
    i ++;
  }
#line 23327
  break;
  case 5386: 
#line 23329
  i = 0U;
#line 23329
  while (i < n) {
#line 23330
    if (*(mask + i)) {
#line 23331
      *(index___0 + i) = ~ dest[i];
    }
#line 23329
    i ++;
  }
#line 23334
  break;
  case 5377: 
#line 23336
  i = 0U;
#line 23336
  while (i < n) {
#line 23337
    if (*(mask + i)) {
#line 23338
      *(index___0 + i) &= dest[i];
    }
#line 23336
    i ++;
  }
#line 23341
  break;
  case 5390: 
#line 23343
  i = 0U;
#line 23343
  while (i < n) {
#line 23344
    if (*(mask + i)) {
#line 23345
      *(index___0 + i) = ~ (*(index___0 + i) & dest[i]);
    }
#line 23343
    i ++;
  }
#line 23348
  break;
  case 5383: 
#line 23350
  i = 0U;
#line 23350
  while (i < n) {
#line 23351
    if (*(mask + i)) {
#line 23352
      *(index___0 + i) |= dest[i];
    }
#line 23350
    i ++;
  }
#line 23355
  break;
  case 5384: 
#line 23357
  i = 0U;
#line 23357
  while (i < n) {
#line 23358
    if (*(mask + i)) {
#line 23359
      *(index___0 + i) = ~ (*(index___0 + i) | dest[i]);
    }
#line 23357
    i ++;
  }
#line 23362
  break;
  case 5382: 
#line 23364
  i = 0U;
#line 23364
  while (i < n) {
#line 23365
    if (*(mask + i)) {
#line 23366
      *(index___0 + i) ^= dest[i];
    }
#line 23364
    i ++;
  }
#line 23369
  break;
  case 5385: 
#line 23371
  i = 0U;
#line 23371
  while (i < n) {
#line 23372
    if (*(mask + i)) {
#line 23373
      *(index___0 + i) = ~ (*(index___0 + i) ^ dest[i]);
    }
#line 23371
    i ++;
  }
#line 23376
  break;
  case 5378: 
#line 23378
  i = 0U;
#line 23378
  while (i < n) {
#line 23379
    if (*(mask + i)) {
#line 23380
      *(index___0 + i) &= ~ dest[i];
    }
#line 23378
    i ++;
  }
#line 23383
  break;
  case 5380: 
#line 23385
  i = 0U;
#line 23385
  while (i < n) {
#line 23386
    if (*(mask + i)) {
#line 23387
      *(index___0 + i) = ~ *(index___0 + i) & dest[i];
    }
#line 23385
    i ++;
  }
#line 23390
  break;
  case 5387: 
#line 23392
  i = 0U;
#line 23392
  while (i < n) {
#line 23393
    if (*(mask + i)) {
#line 23394
      *(index___0 + i) |= ~ dest[i];
    }
#line 23392
    i ++;
  }
#line 23397
  break;
  case 5389: 
#line 23399
  i = 0U;
#line 23399
  while (i < n) {
#line 23400
    if (*(mask + i)) {
#line 23401
      *(index___0 + i) = ~ *(index___0 + i) | dest[i];
    }
#line 23399
    i ++;
  }
#line 23404
  break;
  default: 
#line 23406
  gl_error(ctx, 1280, "gl_logic error");
  }
#line 23408
  return;
}
}
#line 23409 "D:/a/test/177.c"
void gl_logicop_ci_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                          GLuint *index___0 , GLubyte *mask ) 
{ GLuint dest[1920] ;
  GLuint i ;

  {
#line 23415
  (*(ctx->Driver.ReadIndexPixels))(ctx, n, x, y, dest, (GLubyte const   *)mask);
#line 23416
  switch (ctx->Color.LogicOp) {
  case 5376: 
#line 23418
  i = 0U;
#line 23418
  while (i < n) {
#line 23419
    if (*(mask + i)) {
#line 23420
      *(index___0 + i) = 0U;
    }
#line 23418
    i ++;
  }
#line 23423
  break;
  case 5391: 
#line 23425
  i = 0U;
#line 23425
  while (i < n) {
#line 23426
    if (*(mask + i)) {
#line 23427
      *(index___0 + i) = 1U;
    }
#line 23425
    i ++;
  }
#line 23430
  break;
  case 5379: 
#line 23433
  break;
  case 5388: 
#line 23435
  i = 0U;
#line 23435
  while (i < n) {
#line 23436
    if (*(mask + i)) {
#line 23437
      *(index___0 + i) = ~ *(index___0 + i);
    }
#line 23435
    i ++;
  }
#line 23440
  break;
  case 5381: 
#line 23442
  i = 0U;
#line 23442
  while (i < n) {
#line 23443
    if (*(mask + i)) {
#line 23444
      *(index___0 + i) = dest[i];
    }
#line 23442
    i ++;
  }
#line 23447
  break;
  case 5386: 
#line 23449
  i = 0U;
#line 23449
  while (i < n) {
#line 23450
    if (*(mask + i)) {
#line 23451
      *(index___0 + i) = ~ dest[i];
    }
#line 23449
    i ++;
  }
#line 23454
  break;
  case 5377: 
#line 23456
  i = 0U;
#line 23456
  while (i < n) {
#line 23457
    if (*(mask + i)) {
#line 23458
      *(index___0 + i) &= dest[i];
    }
#line 23456
    i ++;
  }
#line 23461
  break;
  case 5390: 
#line 23463
  i = 0U;
#line 23463
  while (i < n) {
#line 23464
    if (*(mask + i)) {
#line 23465
      *(index___0 + i) = ~ (*(index___0 + i) & dest[i]);
    }
#line 23463
    i ++;
  }
#line 23468
  break;
  case 5383: 
#line 23470
  i = 0U;
#line 23470
  while (i < n) {
#line 23471
    if (*(mask + i)) {
#line 23472
      *(index___0 + i) |= dest[i];
    }
#line 23470
    i ++;
  }
#line 23475
  break;
  case 5384: 
#line 23477
  i = 0U;
#line 23477
  while (i < n) {
#line 23478
    if (*(mask + i)) {
#line 23479
      *(index___0 + i) = ~ (*(index___0 + i) | dest[i]);
    }
#line 23477
    i ++;
  }
#line 23482
  break;
  case 5382: 
#line 23484
  i = 0U;
#line 23484
  while (i < n) {
#line 23485
    if (*(mask + i)) {
#line 23486
      *(index___0 + i) ^= dest[i];
    }
#line 23484
    i ++;
  }
#line 23489
  break;
  case 5385: 
#line 23491
  i = 0U;
#line 23491
  while (i < n) {
#line 23492
    if (*(mask + i)) {
#line 23493
      *(index___0 + i) = ~ (*(index___0 + i) ^ dest[i]);
    }
#line 23491
    i ++;
  }
#line 23496
  break;
  case 5378: 
#line 23498
  i = 0U;
#line 23498
  while (i < n) {
#line 23499
    if (*(mask + i)) {
#line 23500
      *(index___0 + i) &= ~ dest[i];
    }
#line 23498
    i ++;
  }
#line 23503
  break;
  case 5380: 
#line 23505
  i = 0U;
#line 23505
  while (i < n) {
#line 23506
    if (*(mask + i)) {
#line 23507
      *(index___0 + i) = ~ *(index___0 + i) & dest[i];
    }
#line 23505
    i ++;
  }
#line 23510
  break;
  case 5387: 
#line 23512
  i = 0U;
#line 23512
  while (i < n) {
#line 23513
    if (*(mask + i)) {
#line 23514
      *(index___0 + i) |= ~ dest[i];
    }
#line 23512
    i ++;
  }
#line 23517
  break;
  case 5389: 
#line 23519
  i = 0U;
#line 23519
  while (i < n) {
#line 23520
    if (*(mask + i)) {
#line 23521
      *(index___0 + i) = ~ *(index___0 + i) | dest[i];
    }
#line 23519
    i ++;
  }
#line 23524
  break;
  default: 
#line 23526
  gl_error(ctx, 1280, "gl_logic_pixels error");
  }
#line 23528
  return;
}
}
#line 23529 "D:/a/test/177.c"
void gl_logicop_rgba_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *red ,
                          GLubyte *green , GLubyte *blue___0 , GLubyte *alpha , GLubyte *mask ) 
{ GLubyte rdest[640] ;
  GLubyte gdest[640] ;
  GLubyte bdest[640] ;
  GLubyte adest[640] ;
  GLuint i ;
  GLubyte tmp___0 ;
  GLubyte tmp___1 ;
  GLubyte tmp___2 ;
  GLubyte r ;
  GLubyte g ;
  GLubyte b ;
  GLubyte a ;

  {
#line 23538
  gl_read_color_span(ctx, n, x, y, rdest, gdest, bdest, adest);
#line 23539
  switch (ctx->Color.LogicOp) {
  case 5376: 
#line 23541
  i = 0U;
#line 23541
  while (i < n) {
#line 23542
    if (*(mask + i)) {
#line 23543
      tmp___2 = (unsigned char)0;
#line 23543
      *(alpha + i) = tmp___2;
#line 23543
      tmp___1 = tmp___2;
#line 23543
      *(blue___0 + i) = tmp___1;
#line 23543
      tmp___0 = tmp___1;
#line 23543
      *(green + i) = tmp___0;
#line 23543
      *(red + i) = tmp___0;
    }
#line 23541
    i ++;
  }
#line 23546
  break;
  case 5391: 
#line 23549
  r = (GLubyte )((int )(ctx->Visual)->RedScale);
#line 23550
  g = (GLubyte )((int )(ctx->Visual)->GreenScale);
#line 23551
  b = (GLubyte )((int )(ctx->Visual)->BlueScale);
#line 23552
  a = (GLubyte )((int )(ctx->Visual)->AlphaScale);
#line 23553
  i = 0U;
#line 23553
  while (i < n) {
#line 23554
    if (*(mask + i)) {
#line 23555
      *(red + i) = r;
#line 23556
      *(green + i) = g;
#line 23557
      *(blue___0 + i) = b;
#line 23558
      *(alpha + i) = a;
    }
#line 23553
    i ++;
  }
#line 23562
  break;
  case 5379: 
#line 23564
  break;
  case 5388: 
#line 23566
  i = 0U;
#line 23566
  while (i < n) {
#line 23567
    if (*(mask + i)) {
#line 23568
      *(red + i) = (unsigned char )(~ ((int )*(red + i)));
#line 23569
      *(green + i) = (unsigned char )(~ ((int )*(green + i)));
#line 23570
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i)));
#line 23571
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i)));
    }
#line 23566
    i ++;
  }
#line 23574
  break;
  case 5381: 
#line 23576
  i = 0U;
#line 23576
  while (i < n) {
#line 23577
    if (*(mask + i)) {
#line 23578
      *(red + i) = rdest[i];
#line 23579
      *(green + i) = gdest[i];
#line 23580
      *(blue___0 + i) = bdest[i];
#line 23581
      *(alpha + i) = adest[i];
    }
#line 23576
    i ++;
  }
#line 23584
  break;
  case 5386: 
#line 23586
  i = 0U;
#line 23586
  while (i < n) {
#line 23587
    if (*(mask + i)) {
#line 23588
      *(red + i) = (unsigned char )(~ ((int )rdest[i]));
#line 23589
      *(green + i) = (unsigned char )(~ ((int )gdest[i]));
#line 23590
      *(blue___0 + i) = (unsigned char )(~ ((int )bdest[i]));
#line 23591
      *(alpha + i) = (unsigned char )(~ ((int )adest[i]));
    }
#line 23586
    i ++;
  }
#line 23594
  break;
  case 5377: 
#line 23596
  i = 0U;
#line 23596
  while (i < n) {
#line 23597
    if (*(mask + i)) {
#line 23598
      *(red + i) = (unsigned char )((int )*(red + i) & (int )rdest[i]);
#line 23599
      *(green + i) = (unsigned char )((int )*(green + i) & (int )gdest[i]);
#line 23600
      *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) & (int )bdest[i]);
#line 23601
      *(alpha + i) = (unsigned char )((int )*(alpha + i) & (int )adest[i]);
    }
#line 23596
    i ++;
  }
#line 23604
  break;
  case 5390: 
#line 23606
  i = 0U;
#line 23606
  while (i < n) {
#line 23607
    if (*(mask + i)) {
#line 23608
      *(red + i) = (unsigned char )(~ ((int )*(red + i) & (int )rdest[i]));
#line 23609
      *(green + i) = (unsigned char )(~ ((int )*(green + i) & (int )gdest[i]));
#line 23610
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i) & (int )bdest[i]));
#line 23611
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i) & (int )adest[i]));
    }
#line 23606
    i ++;
  }
#line 23614
  break;
  case 5383: 
#line 23616
  i = 0U;
#line 23616
  while (i < n) {
#line 23617
    if (*(mask + i)) {
#line 23618
      *(red + i) = (unsigned char )((int )*(red + i) | (int )rdest[i]);
#line 23619
      *(green + i) = (unsigned char )((int )*(green + i) | (int )gdest[i]);
#line 23620
      *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) | (int )bdest[i]);
#line 23621
      *(alpha + i) = (unsigned char )((int )*(alpha + i) | (int )adest[i]);
    }
#line 23616
    i ++;
  }
#line 23624
  break;
  case 5384: 
#line 23626
  i = 0U;
#line 23626
  while (i < n) {
#line 23627
    if (*(mask + i)) {
#line 23628
      *(red + i) = (unsigned char )(~ ((int )*(red + i) | (int )rdest[i]));
#line 23629
      *(green + i) = (unsigned char )(~ ((int )*(green + i) | (int )gdest[i]));
#line 23630
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i) | (int )bdest[i]));
#line 23631
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i) | (int )adest[i]));
    }
#line 23626
    i ++;
  }
#line 23634
  break;
  case 5382: 
#line 23636
  i = 0U;
#line 23636
  while (i < n) {
#line 23637
    if (*(mask + i)) {
#line 23638
      *(red + i) = (unsigned char )((int )*(red + i) ^ (int )rdest[i]);
#line 23639
      *(green + i) = (unsigned char )((int )*(green + i) ^ (int )gdest[i]);
#line 23640
      *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) ^ (int )bdest[i]);
#line 23641
      *(alpha + i) = (unsigned char )((int )*(alpha + i) ^ (int )adest[i]);
    }
#line 23636
    i ++;
  }
#line 23644
  break;
  case 5385: 
#line 23646
  i = 0U;
#line 23646
  while (i < n) {
#line 23647
    if (*(mask + i)) {
#line 23648
      *(red + i) = (unsigned char )(~ ((int )*(red + i) ^ (int )rdest[i]));
#line 23649
      *(green + i) = (unsigned char )(~ ((int )*(green + i) ^ (int )gdest[i]));
#line 23650
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i) ^ (int )bdest[i]));
#line 23651
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i) ^ (int )adest[i]));
    }
#line 23646
    i ++;
  }
#line 23654
  break;
  case 5378: 
#line 23656
  i = 0U;
#line 23656
  while (i < n) {
#line 23657
    if (*(mask + i)) {
#line 23658
      *(red + i) = (unsigned char )((int )*(red + i) & ~ ((int )rdest[i]));
#line 23659
      *(green + i) = (unsigned char )((int )*(green + i) & ~ ((int )gdest[i]));
#line 23660
      *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) & ~ ((int )bdest[i]));
#line 23661
      *(alpha + i) = (unsigned char )((int )*(alpha + i) & ~ ((int )adest[i]));
    }
#line 23656
    i ++;
  }
#line 23664
  break;
  case 5380: 
#line 23666
  i = 0U;
#line 23666
  while (i < n) {
#line 23667
    if (*(mask + i)) {
#line 23668
      *(red + i) = (unsigned char )(~ ((int )*(red + i)) & (int )rdest[i]);
#line 23669
      *(green + i) = (unsigned char )(~ ((int )*(green + i)) & (int )gdest[i]);
#line 23670
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i)) & (int )bdest[i]);
#line 23671
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i)) & (int )adest[i]);
    }
#line 23666
    i ++;
  }
#line 23674
  break;
  case 5387: 
#line 23676
  i = 0U;
#line 23676
  while (i < n) {
#line 23677
    if (*(mask + i)) {
#line 23678
      *(red + i) = (unsigned char )((int )*(red + i) | ~ ((int )rdest[i]));
#line 23679
      *(green + i) = (unsigned char )((int )*(green + i) | ~ ((int )gdest[i]));
#line 23680
      *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) | ~ ((int )bdest[i]));
#line 23681
      *(alpha + i) = (unsigned char )((int )*(alpha + i) | ~ ((int )adest[i]));
    }
#line 23676
    i ++;
  }
#line 23684
  break;
  case 5389: 
#line 23686
  i = 0U;
#line 23686
  while (i < n) {
#line 23687
    if (*(mask + i)) {
#line 23688
      *(red + i) = (unsigned char )(~ ((int )*(red + i)) | (int )rdest[i]);
#line 23689
      *(green + i) = (unsigned char )(~ ((int )*(green + i)) | (int )gdest[i]);
#line 23690
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i)) | (int )bdest[i]);
#line 23691
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i)) | (int )adest[i]);
    }
#line 23686
    i ++;
  }
#line 23694
  break;
  default: 
#line 23696
  gl_problem((GLcontext const   *)ctx, "Bad function in gl_logicop_rgba_span");
#line 23697
  return;
  }
#line 23699
  return;
}
}
#line 23700 "D:/a/test/177.c"
void gl_logicop_rgba_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                            GLubyte *red , GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ,
                            GLubyte *mask ) 
{ GLubyte rdest[1920] ;
  GLubyte gdest[1920] ;
  GLubyte bdest[1920] ;
  GLubyte adest[1920] ;
  GLuint i ;
  GLubyte tmp___0 ;
  GLubyte tmp___1 ;
  GLubyte tmp___2 ;
  GLubyte r ;
  GLubyte g ;
  GLubyte b ;
  GLubyte a ;

  {
#line 23708
  (*(ctx->Driver.ReadColorPixels))(ctx, n, x, y, rdest, gdest, bdest, adest, (GLubyte const   *)mask);
#line 23709
  if (ctx->RasterMask & 256U) {
#line 23710
    gl_read_alpha_pixels(ctx, n, x, y, adest, (GLubyte const   *)mask);
  }
#line 23712
  switch (ctx->Color.LogicOp) {
  case 5376: 
#line 23714
  i = 0U;
#line 23714
  while (i < n) {
#line 23715
    if (*(mask + i)) {
#line 23716
      tmp___2 = (unsigned char)0;
#line 23716
      *(alpha + i) = tmp___2;
#line 23716
      tmp___1 = tmp___2;
#line 23716
      *(blue___0 + i) = tmp___1;
#line 23716
      tmp___0 = tmp___1;
#line 23716
      *(green + i) = tmp___0;
#line 23716
      *(red + i) = tmp___0;
    }
#line 23714
    i ++;
  }
#line 23719
  break;
  case 5391: 
#line 23722
  r = (GLubyte )((int )(ctx->Visual)->RedScale);
#line 23723
  g = (GLubyte )((int )(ctx->Visual)->GreenScale);
#line 23724
  b = (GLubyte )((int )(ctx->Visual)->BlueScale);
#line 23725
  a = (GLubyte )((int )(ctx->Visual)->AlphaScale);
#line 23726
  i = 0U;
#line 23726
  while (i < n) {
#line 23727
    if (*(mask + i)) {
#line 23728
      *(red + i) = r;
#line 23729
      *(green + i) = g;
#line 23730
      *(blue___0 + i) = b;
#line 23731
      *(alpha + i) = a;
    }
#line 23726
    i ++;
  }
#line 23735
  break;
  case 5379: 
#line 23737
  break;
  case 5388: 
#line 23739
  i = 0U;
#line 23739
  while (i < n) {
#line 23740
    if (*(mask + i)) {
#line 23741
      *(red + i) = (unsigned char )(~ ((int )*(red + i)));
#line 23742
      *(green + i) = (unsigned char )(~ ((int )*(green + i)));
#line 23743
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i)));
#line 23744
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i)));
    }
#line 23739
    i ++;
  }
#line 23747
  break;
  case 5381: 
#line 23749
  i = 0U;
#line 23749
  while (i < n) {
#line 23750
    if (*(mask + i)) {
#line 23751
      *(red + i) = rdest[i];
#line 23752
      *(green + i) = gdest[i];
#line 23753
      *(blue___0 + i) = bdest[i];
#line 23754
      *(alpha + i) = adest[i];
    }
#line 23749
    i ++;
  }
#line 23757
  break;
  case 5386: 
#line 23759
  i = 0U;
#line 23759
  while (i < n) {
#line 23760
    if (*(mask + i)) {
#line 23761
      *(red + i) = (unsigned char )(~ ((int )rdest[i]));
#line 23762
      *(green + i) = (unsigned char )(~ ((int )gdest[i]));
#line 23763
      *(blue___0 + i) = (unsigned char )(~ ((int )bdest[i]));
#line 23764
      *(alpha + i) = (unsigned char )(~ ((int )adest[i]));
    }
#line 23759
    i ++;
  }
#line 23767
  break;
  case 5377: 
#line 23769
  i = 0U;
#line 23769
  while (i < n) {
#line 23770
    if (*(mask + i)) {
#line 23771
      *(red + i) = (unsigned char )((int )*(red + i) & (int )rdest[i]);
#line 23772
      *(green + i) = (unsigned char )((int )*(green + i) & (int )gdest[i]);
#line 23773
      *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) & (int )bdest[i]);
#line 23774
      *(alpha + i) = (unsigned char )((int )*(alpha + i) & (int )adest[i]);
    }
#line 23769
    i ++;
  }
#line 23777
  break;
  case 5390: 
#line 23779
  i = 0U;
#line 23779
  while (i < n) {
#line 23780
    if (*(mask + i)) {
#line 23781
      *(red + i) = (unsigned char )(~ ((int )*(red + i) & (int )rdest[i]));
#line 23782
      *(green + i) = (unsigned char )(~ ((int )*(green + i) & (int )gdest[i]));
#line 23783
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i) & (int )bdest[i]));
#line 23784
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i) & (int )adest[i]));
    }
#line 23779
    i ++;
  }
#line 23787
  break;
  case 5383: 
#line 23789
  i = 0U;
#line 23789
  while (i < n) {
#line 23790
    if (*(mask + i)) {
#line 23791
      *(red + i) = (unsigned char )((int )*(red + i) | (int )rdest[i]);
#line 23792
      *(green + i) = (unsigned char )((int )*(green + i) | (int )gdest[i]);
#line 23793
      *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) | (int )bdest[i]);
#line 23794
      *(alpha + i) = (unsigned char )((int )*(alpha + i) | (int )adest[i]);
    }
#line 23789
    i ++;
  }
#line 23797
  break;
  case 5384: 
#line 23799
  i = 0U;
#line 23799
  while (i < n) {
#line 23800
    if (*(mask + i)) {
#line 23801
      *(red + i) = (unsigned char )(~ ((int )*(red + i) | (int )rdest[i]));
#line 23802
      *(green + i) = (unsigned char )(~ ((int )*(green + i) | (int )gdest[i]));
#line 23803
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i) | (int )bdest[i]));
#line 23804
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i) | (int )adest[i]));
    }
#line 23799
    i ++;
  }
#line 23807
  break;
  case 5382: 
#line 23809
  i = 0U;
#line 23809
  while (i < n) {
#line 23810
    if (*(mask + i)) {
#line 23811
      *(red + i) = (unsigned char )((int )*(red + i) ^ (int )rdest[i]);
#line 23812
      *(green + i) = (unsigned char )((int )*(green + i) ^ (int )gdest[i]);
#line 23813
      *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) ^ (int )bdest[i]);
#line 23814
      *(alpha + i) = (unsigned char )((int )*(alpha + i) ^ (int )adest[i]);
    }
#line 23809
    i ++;
  }
#line 23817
  break;
  case 5385: 
#line 23819
  i = 0U;
#line 23819
  while (i < n) {
#line 23820
    if (*(mask + i)) {
#line 23821
      *(red + i) = (unsigned char )(~ ((int )*(red + i) ^ (int )rdest[i]));
#line 23822
      *(green + i) = (unsigned char )(~ ((int )*(green + i) ^ (int )gdest[i]));
#line 23823
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i) ^ (int )bdest[i]));
#line 23824
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i) ^ (int )adest[i]));
    }
#line 23819
    i ++;
  }
#line 23827
  break;
  case 5378: 
#line 23829
  i = 0U;
#line 23829
  while (i < n) {
#line 23830
    if (*(mask + i)) {
#line 23831
      *(red + i) = (unsigned char )((int )*(red + i) & ~ ((int )rdest[i]));
#line 23832
      *(green + i) = (unsigned char )((int )*(green + i) & ~ ((int )gdest[i]));
#line 23833
      *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) & ~ ((int )bdest[i]));
#line 23834
      *(alpha + i) = (unsigned char )((int )*(alpha + i) & ~ ((int )adest[i]));
    }
#line 23829
    i ++;
  }
#line 23837
  break;
  case 5380: 
#line 23839
  i = 0U;
#line 23839
  while (i < n) {
#line 23840
    if (*(mask + i)) {
#line 23841
      *(red + i) = (unsigned char )(~ ((int )*(red + i)) & (int )rdest[i]);
#line 23842
      *(green + i) = (unsigned char )(~ ((int )*(green + i)) & (int )gdest[i]);
#line 23843
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i)) & (int )bdest[i]);
#line 23844
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i)) & (int )adest[i]);
    }
#line 23839
    i ++;
  }
#line 23847
  break;
  case 5387: 
#line 23849
  i = 0U;
#line 23849
  while (i < n) {
#line 23850
    if (*(mask + i)) {
#line 23851
      *(red + i) = (unsigned char )((int )*(red + i) | ~ ((int )rdest[i]));
#line 23852
      *(green + i) = (unsigned char )((int )*(green + i) | ~ ((int )gdest[i]));
#line 23853
      *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) | ~ ((int )bdest[i]));
#line 23854
      *(alpha + i) = (unsigned char )((int )*(alpha + i) | ~ ((int )adest[i]));
    }
#line 23849
    i ++;
  }
#line 23857
  break;
  case 5389: 
#line 23859
  i = 0U;
#line 23859
  while (i < n) {
#line 23860
    if (*(mask + i)) {
#line 23861
      *(red + i) = (unsigned char )(~ ((int )*(red + i)) | (int )rdest[i]);
#line 23862
      *(green + i) = (unsigned char )(~ ((int )*(green + i)) | (int )gdest[i]);
#line 23863
      *(blue___0 + i) = (unsigned char )(~ ((int )*(blue___0 + i)) | (int )bdest[i]);
#line 23864
      *(alpha + i) = (unsigned char )(~ ((int )*(alpha + i)) | (int )adest[i]);
    }
#line 23859
    i ++;
  }
#line 23867
  break;
  default: 
#line 23869
  gl_problem((GLcontext const   *)ctx, "Bad function in gl_logicop_rgba_pixels");
#line 23870
  return;
  }
#line 23872
  return;
}
}
#line 23964 "D:/a/test/177.c"
void gl_IndexMask(GLcontext *ctx , GLuint mask ) 
{ 

  {
#line 23966
  if (ctx->Primitive != 6656) {
#line 23967
    gl_error(ctx, 1282, "glIndexMask");
#line 23968
    return;
  }
#line 23970
  ctx->Color.IndexMask = mask;
#line 23971
  ctx->NewState |= 2U;
#line 23972
  return;
}
}
#line 23973 "D:/a/test/177.c"
void gl_ColorMask(GLcontext *ctx , GLboolean red , GLboolean green , GLboolean blue___0 ,
                  GLboolean alpha ) 
{ 

  {
#line 23976
  if (ctx->Primitive != 6656) {
#line 23977
    gl_error(ctx, 1282, "glColorMask");
#line 23978
    return;
  }
#line 23980
  ctx->Color.ColorMask = (unsigned int )(((((int )red << 3) | ((int )green << 2)) | ((int )blue___0 << 1)) | (int )alpha);
#line 23981
  ctx->NewState |= 2U;
#line 23982
  return;
}
}
#line 23983 "D:/a/test/177.c"
void gl_mask_color_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *red ,
                        GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLubyte r[640] ;
  GLubyte g[640] ;
  GLubyte b[640] ;
  GLubyte a[640] ;

  {
#line 23989
  gl_read_color_span(ctx, n, x, y, r, g, b, a);
#line 23990
  if ((ctx->Color.ColorMask & 8U) == 0U) {
#line 23991
    memcpy((void *)red, (void const   *)((void *)(r)), n);
  }
#line 23993
  if ((ctx->Color.ColorMask & 4U) == 0U) {
#line 23994
    memcpy((void *)green, (void const   *)((void *)(g)), n);
  }
#line 23996
  if ((ctx->Color.ColorMask & 2U) == 0U) {
#line 23997
    memcpy((void *)blue___0, (void const   *)((void *)(b)), n);
  }
#line 23999
  if ((ctx->Color.ColorMask & 1U) == 0U) {
#line 24000
    memcpy((void *)alpha, (void const   *)((void *)(a)), n);
  }
#line 24002
  return;
}
}
#line 24003 "D:/a/test/177.c"
void gl_mask_color_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                          GLubyte *red , GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ,
                          GLubyte const   *mask ) 
{ GLubyte r[1920] ;
  GLubyte g[1920] ;
  GLubyte b[1920] ;
  GLubyte a[1920] ;

  {
#line 24010
  (*(ctx->Driver.ReadColorPixels))(ctx, n, x, y, r, g, b, a, mask);
#line 24011
  if (ctx->RasterMask & 256U) {
#line 24012
    gl_read_alpha_pixels(ctx, n, x, y, a, mask);
  }
#line 24014
  if ((ctx->Color.ColorMask & 8U) == 0U) {
#line 24015
    memcpy((void *)red, (void const   *)((void *)(r)), n);
  }
#line 24017
  if ((ctx->Color.ColorMask & 4U) == 0U) {
#line 24018
    memcpy((void *)green, (void const   *)((void *)(g)), n);
  }
#line 24020
  if ((ctx->Color.ColorMask & 2U) == 0U) {
#line 24021
    memcpy((void *)blue___0, (void const   *)((void *)(b)), n);
  }
#line 24023
  if ((ctx->Color.ColorMask & 1U) == 0U) {
#line 24024
    memcpy((void *)alpha, (void const   *)((void *)(a)), n);
  }
#line 24026
  return;
}
}
#line 24027 "D:/a/test/177.c"
void gl_mask_index_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLuint *index___0 ) 
{ GLuint i ;
  GLuint fbindexes[640] ;
  GLuint msrc ;
  GLuint mdest ;

  {
#line 24033
  gl_read_index_span(ctx, n, x, y, fbindexes);
#line 24034
  msrc = ctx->Color.IndexMask;
#line 24035
  mdest = ~ msrc;
#line 24036
  i = 0U;
#line 24036
  while (i < n) {
#line 24037
    *(index___0 + i) = (*(index___0 + i) & msrc) | (fbindexes[i] & mdest);
#line 24036
    i ++;
  }
#line 24039
  return;
}
}
#line 24040 "D:/a/test/177.c"
void gl_mask_index_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                          GLuint *index___0 , GLubyte const   *mask ) 
{ GLuint i ;
  GLuint fbindexes[1920] ;
  GLuint msrc ;
  GLuint mdest ;

  {
#line 24047
  (*(ctx->Driver.ReadIndexPixels))(ctx, n, x, y, fbindexes, mask);
#line 24048
  msrc = ctx->Color.IndexMask;
#line 24049
  mdest = ~ msrc;
#line 24050
  i = 0U;
#line 24050
  while (i < n) {
#line 24051
    *(index___0 + i) = (*(index___0 + i) & msrc) | (fbindexes[i] & mdest);
#line 24050
    i ++;
  }
#line 24053
  return;
}
}
#line 24059 "D:/a/test/177.c"
static float Identity[16]  = 
#line 24059
  {      (float )1.0,      (float )0.0,      (float )0.0,      (float )0.0, 
        (float )0.0,      (float )1.0,      (float )0.0,      (float )0.0, 
        (float )0.0,      (float )0.0,      (float )1.0,      (float )0.0, 
        (float )0.0,      (float )0.0,      (float )0.0,      (float )1.0};
#line 24072 "D:/a/test/177.c"
static void matmul(float *product , float const   *a , float const   *b ) 
{ GLint i ;
  float ai0 ;
  float ai1 ;
  float ai2 ;
  float ai3 ;

  {
#line 24078
  i = 0;
#line 24078
  while (i < 4) {
#line 24079
    ai0 = (float )*(a + i);
#line 24079
    ai1 = (float )*(a + ((1 << 2) + i));
#line 24079
    ai2 = (float )*(a + ((2 << 2) + i));
#line 24079
    ai3 = (float )*(a + ((3 << 2) + i));
#line 24080
    *(product + i) = ((ai0 * (float )*(b + 0) + ai1 * (float )*(b + 1)) + ai2 * (float )*(b + 2)) + ai3 * (float )*(b + 3);
#line 24081
    *(product + ((1 << 2) + i)) = ((ai0 * (float )*(b + (1 << 2)) + ai1 * (float )*(b + ((1 << 2) + 1))) + ai2 * (float )*(b + ((1 << 2) + 2))) + ai3 * (float )*(b + ((1 << 2) + 3));
#line 24082
    *(product + ((2 << 2) + i)) = ((ai0 * (float )*(b + (2 << 2)) + ai1 * (float )*(b + ((2 << 2) + 1))) + ai2 * (float )*(b + ((2 << 2) + 2))) + ai3 * (float )*(b + ((2 << 2) + 3));
#line 24083
    *(product + ((3 << 2) + i)) = ((ai0 * (float )*(b + (3 << 2)) + ai1 * (float )*(b + ((3 << 2) + 1))) + ai2 * (float )*(b + ((3 << 2) + 2))) + ai3 * (float )*(b + ((3 << 2) + 3));
#line 24078
    i ++;
  }
#line 24088
  return;
}
}
#line 24096 "D:/a/test/177.c"
static void invert_matrix_general(float const   *m , float *out ) 
{ Mat2 r1 ;
  Mat2 r2 ;
  Mat2 r3 ;
  Mat2 r4 ;
  Mat2 r5 ;
  Mat2 r6 ;
  Mat2 r7 ;
  float const   *A ;
  float *C ;
  float one_over_det ;

  {
#line 24099
  A = m;
#line 24100
  C = out;
#line 24102
  one_over_det = 1.0f / (float )(*(A + 0) * *(A + 5) - *(A + 1) * *(A + 4));
#line 24103
  r1[0][0] = one_over_det * (float )*(A + 5);
#line 24104
  r1[0][1] = one_over_det * (float )(- *(A + 4));
#line 24105
  r1[1][0] = one_over_det * (float )(- *(A + 1));
#line 24106
  r1[1][1] = one_over_det * (float )*(A + 0);
#line 24107
  r2[0][0] = (float )(*(A + 2) * (float const   )r1[0][0] + *(A + 6) * (float const   )r1[1][0]);
#line 24108
  r2[0][1] = (float )(*(A + 2) * (float const   )r1[0][1] + *(A + 6) * (float const   )r1[1][1]);
#line 24109
  r2[1][0] = (float )(*(A + 3) * (float const   )r1[0][0] + *(A + 7) * (float const   )r1[1][0]);
#line 24110
  r2[1][1] = (float )(*(A + 3) * (float const   )r1[0][1] + *(A + 7) * (float const   )r1[1][1]);
#line 24111
  r3[0][0] = r1[0][0] * (float )*(A + 8) + r1[0][1] * (float )*(A + 9);
#line 24112
  r3[0][1] = r1[0][0] * (float )*(A + 12) + r1[0][1] * (float )*(A + 13);
#line 24113
  r3[1][0] = r1[1][0] * (float )*(A + 8) + r1[1][1] * (float )*(A + 9);
#line 24114
  r3[1][1] = r1[1][0] * (float )*(A + 12) + r1[1][1] * (float )*(A + 13);
#line 24115
  r4[0][0] = (float )(*(A + 2) * (float const   )r3[0][0] + *(A + 6) * (float const   )r3[1][0]);
#line 24116
  r4[0][1] = (float )(*(A + 2) * (float const   )r3[0][1] + *(A + 6) * (float const   )r3[1][1]);
#line 24117
  r4[1][0] = (float )(*(A + 3) * (float const   )r3[0][0] + *(A + 7) * (float const   )r3[1][0]);
#line 24118
  r4[1][1] = (float )(*(A + 3) * (float const   )r3[0][1] + *(A + 7) * (float const   )r3[1][1]);
#line 24119
  r5[0][0] = r4[0][0] - (float )*(A + 10);
#line 24120
  r5[0][1] = r4[0][1] - (float )*(A + 14);
#line 24121
  r5[1][0] = r4[1][0] - (float )*(A + 11);
#line 24122
  r5[1][1] = r4[1][1] - (float )*(A + 15);
#line 24123
  one_over_det = 1.0f / (r5[0][0] * r5[1][1] - r5[1][0] * r5[0][1]);
#line 24124
  r6[0][0] = one_over_det * r5[1][1];
#line 24125
  r6[0][1] = one_over_det * - r5[0][1];
#line 24126
  r6[1][0] = one_over_det * - r5[1][0];
#line 24127
  r6[1][1] = one_over_det * r5[0][0];
#line 24128
  *(C + 8) = r3[0][0] * r6[0][0] + r3[0][1] * r6[1][0];
#line 24129
  *(C + 12) = r3[0][0] * r6[0][1] + r3[0][1] * r6[1][1];
#line 24130
  *(C + 9) = r3[1][0] * r6[0][0] + r3[1][1] * r6[1][0];
#line 24131
  *(C + 13) = r3[1][0] * r6[0][1] + r3[1][1] * r6[1][1];
#line 24132
  *(C + 2) = r6[0][0] * r2[0][0] + r6[0][1] * r2[1][0];
#line 24133
  *(C + 6) = r6[0][0] * r2[0][1] + r6[0][1] * r2[1][1];
#line 24134
  *(C + 3) = r6[1][0] * r2[0][0] + r6[1][1] * r2[1][0];
#line 24135
  *(C + 7) = r6[1][0] * r2[0][1] + r6[1][1] * r2[1][1];
#line 24136
  r7[0][0] = r3[0][0] * *(C + 2) + r3[0][1] * *(C + 3);
#line 24137
  r7[0][1] = r3[0][0] * *(C + 6) + r3[0][1] * *(C + 7);
#line 24138
  r7[1][0] = r3[1][0] * *(C + 2) + r3[1][1] * *(C + 3);
#line 24139
  r7[1][1] = r3[1][0] * *(C + 6) + r3[1][1] * *(C + 7);
#line 24140
  *(C + 0) = r1[0][0] - r7[0][0];
#line 24141
  *(C + 4) = r1[0][1] - r7[0][1];
#line 24142
  *(C + 1) = r1[1][0] - r7[1][0];
#line 24143
  *(C + 5) = r1[1][1] - r7[1][1];
#line 24144
  *(C + 10) = - r6[0][0];
#line 24145
  *(C + 14) = - r6[0][1];
#line 24146
  *(C + 11) = - r6[1][0];
#line 24147
  *(C + 15) = - r6[1][1];
#line 24148
  return;
}
}
#line 24149 "D:/a/test/177.c"
static void invert_matrix(float const   *m , float *out ) 
{ register float det ;
  float tmp___0[16] ;
  float d12 ;
  float d13 ;
  float d23 ;
  float d24 ;
  float d34 ;
  float d41 ;
  register float im11 ;
  register float im12 ;
  register float im13 ;
  register float im14 ;

  {
#line 24170
  if ((double )*(m + 3) != 0.) {
#line 24171
    invert_matrix_general(m, out);
#line 24172
    return;
  } else {
#line 24170
    if ((double )*(m + 7) != 0.) {
#line 24171
      invert_matrix_general(m, out);
#line 24172
      return;
    } else {
#line 24170
      if ((double )*(m + 11) != 0.) {
#line 24171
        invert_matrix_general(m, out);
#line 24172
        return;
      } else {
#line 24170
        if ((double )*(m + 15) != 1.) {
#line 24171
          invert_matrix_general(m, out);
#line 24172
          return;
        }
      }
    }
  }
#line 24174
  tmp___0[0] = (float )(*(m + 5) * *(m + 10) - *(m + 9) * *(m + 6));
#line 24175
  tmp___0[1] = (float )(*(m + 9) * *(m + 2) - *(m + 1) * *(m + 10));
#line 24176
  tmp___0[2] = (float )(*(m + 1) * *(m + 6) - *(m + 5) * *(m + 2));
#line 24177
  det = (float )((*(m + 0) * (float const   )tmp___0[0] + *(m + 4) * (float const   )tmp___0[1]) + *(m + 8) * (float const   )tmp___0[2]);
#line 24178
  if (det == 0.0F) {
#line 24179
    memcpy((void *)out, (void const   *)((void *)(Identity)), 16U * sizeof(float ));
  } else {
#line 24184
    det = (float )(1. / (double )det);
#line 24185
    tmp___0[0] *= det;
#line 24186
    tmp___0[1] *= det;
#line 24187
    tmp___0[2] *= det;
#line 24188
    tmp___0[3] = (float )0.;
#line 24189
    im11 = (float )(*(m + 0) * (float const   )det);
#line 24190
    im12 = (float )(*(m + 4) * (float const   )det);
#line 24191
    im13 = (float )(*(m + 8) * (float const   )det);
#line 24192
    im14 = (float )(*(m + 12) * (float const   )det);
#line 24193
    tmp___0[4] = im13 * (float )*(m + 6) - im12 * (float )*(m + 10);
#line 24194
    tmp___0[5] = im11 * (float )*(m + 10) - im13 * (float )*(m + 2);
#line 24195
    tmp___0[6] = im12 * (float )*(m + 2) - im11 * (float )*(m + 6);
#line 24196
    tmp___0[7] = (float )0.;
#line 24197
    d12 = im11 * (float )*(m + 5) - (float )(*(m + 1) * (float const   )im12);
#line 24198
    d13 = im11 * (float )*(m + 9) - (float )(*(m + 1) * (float const   )im13);
#line 24199
    d23 = im12 * (float )*(m + 9) - (float )(*(m + 5) * (float const   )im13);
#line 24200
    d24 = im12 * (float )*(m + 13) - (float )(*(m + 5) * (float const   )im14);
#line 24201
    d34 = im13 * (float )*(m + 13) - (float )(*(m + 9) * (float const   )im14);
#line 24202
    d41 = im14 * (float )*(m + 1) - (float )(*(m + 13) * (float const   )im11);
#line 24203
    tmp___0[8] = d23;
#line 24204
    tmp___0[9] = - d13;
#line 24205
    tmp___0[10] = d12;
#line 24206
    tmp___0[11] = (float )0.;
#line 24207
    tmp___0[12] = (float )(- ((*(m + 6) * (float const   )d34 - *(m + 10) * (float const   )d24) + *(m + 14) * (float const   )d23));
#line 24208
    tmp___0[13] = (float )((*(m + 2) * (float const   )d34 + *(m + 10) * (float const   )d41) + *(m + 14) * (float const   )d13);
#line 24209
    tmp___0[14] = (float )(- ((*(m + 2) * (float const   )d24 + *(m + 6) * (float const   )d41) + *(m + 14) * (float const   )d12));
#line 24210
    tmp___0[15] = (float )1.;
#line 24211
    memcpy((void *)out, (void const   *)((void *)(tmp___0)), 16U * sizeof(float ));
  }
#line 24230
  return;
}
}
#line 24231 "D:/a/test/177.c"
static GLboolean is_identity(float const   *m ) 
{ 

  {
#line 24233
  if (*(m + 0) == (float const   )1.0F) {
#line 24233
    if (*(m + 4) == (float const   )0.0F) {
#line 24233
      if (*(m + 8) == (float const   )0.0F) {
#line 24233
        if (*(m + 12) == (float const   )0.0F) {
#line 24233
          if (*(m + 1) == (float const   )0.0F) {
#line 24233
            if (*(m + 5) == (float const   )1.0F) {
#line 24233
              if (*(m + 9) == (float const   )0.0F) {
#line 24233
                if (*(m + 13) == (float const   )0.0F) {
#line 24233
                  if (*(m + 2) == (float const   )0.0F) {
#line 24233
                    if (*(m + 6) == (float const   )0.0F) {
#line 24233
                      if (*(m + 10) == (float const   )1.0F) {
#line 24233
                        if (*(m + 14) == (float const   )0.0F) {
#line 24233
                          if (*(m + 3) == (float const   )0.0F) {
#line 24233
                            if (*(m + 7) == (float const   )0.0F) {
#line 24233
                              if (*(m + 11) == (float const   )0.0F) {
#line 24233
                                if (*(m + 15) == (float const   )1.0F) {
#line 24237
                                  return ((unsigned char)1);
                                } else {
#line 24240
                                  return ((unsigned char)0);
                                }
                              } else {
#line 24240
                                return ((unsigned char)0);
                              }
                            } else {
#line 24240
                              return ((unsigned char)0);
                            }
                          } else {
#line 24240
                            return ((unsigned char)0);
                          }
                        } else {
#line 24240
                          return ((unsigned char)0);
                        }
                      } else {
#line 24240
                        return ((unsigned char)0);
                      }
                    } else {
#line 24240
                      return ((unsigned char)0);
                    }
                  } else {
#line 24240
                    return ((unsigned char)0);
                  }
                } else {
#line 24240
                  return ((unsigned char)0);
                }
              } else {
#line 24240
                return ((unsigned char)0);
              }
            } else {
#line 24240
              return ((unsigned char)0);
            }
          } else {
#line 24240
            return ((unsigned char)0);
          }
        } else {
#line 24240
          return ((unsigned char)0);
        }
      } else {
#line 24240
        return ((unsigned char)0);
      }
    } else {
#line 24240
      return ((unsigned char)0);
    }
  } else {
#line 24240
    return ((unsigned char)0);
  }
}
}
#line 24243 "D:/a/test/177.c"
void gl_analyze_modelview_matrix(GLcontext *ctx ) 
{ float const   *m ;
  GLboolean tmp___0 ;

  {
#line 24245
  m = (float const   *)(ctx->ModelViewMatrix);
#line 24246
  tmp___0 = is_identity((float const   *)m);
#line 24246
  if (tmp___0) {
#line 24247
    ctx->ModelViewMatrixType = 1U;
  } else {
#line 24249
    if (*(m + 4) == (float const   )0.0F) {
#line 24249
      if (*(m + 8) == (float const   )0.0F) {
#line 24249
        if (*(m + 1) == (float const   )0.0F) {
#line 24249
          if (*(m + 9) == (float const   )0.0F) {
#line 24249
            if (*(m + 2) == (float const   )0.0F) {
#line 24249
              if (*(m + 6) == (float const   )0.0F) {
#line 24249
                if (*(m + 10) == (float const   )1.0F) {
#line 24249
                  if (*(m + 14) == (float const   )0.0F) {
#line 24249
                    if (*(m + 3) == (float const   )0.0F) {
#line 24249
                      if (*(m + 7) == (float const   )0.0F) {
#line 24249
                        if (*(m + 11) == (float const   )0.0F) {
#line 24249
                          if (*(m + 15) == (float const   )1.0F) {
#line 24253
                            ctx->ModelViewMatrixType = 5U;
                          } else {
                            goto _L___18;
                          }
                        } else {
                          goto _L___18;
                        }
                      } else {
                        goto _L___18;
                      }
                    } else {
                      goto _L___18;
                    }
                  } else {
                    goto _L___18;
                  }
                } else {
                  goto _L___18;
                }
              } else {
                goto _L___18;
              }
            } else {
              goto _L___18;
            }
          } else {
            goto _L___18;
          }
        } else {
          goto _L___18;
        }
      } else {
        goto _L___18;
      }
    } else {
      _L___18: /* CIL Label */ 
#line 24255
      if (*(m + 8) == (float const   )0.0F) {
#line 24255
        if (*(m + 9) == (float const   )0.0F) {
#line 24255
          if (*(m + 2) == (float const   )0.0F) {
#line 24255
            if (*(m + 6) == (float const   )0.0F) {
#line 24255
              if (*(m + 10) == (float const   )1.0F) {
#line 24255
                if (*(m + 14) == (float const   )0.0F) {
#line 24255
                  if (*(m + 3) == (float const   )0.0F) {
#line 24255
                    if (*(m + 7) == (float const   )0.0F) {
#line 24255
                      if (*(m + 11) == (float const   )0.0F) {
#line 24255
                        if (*(m + 15) == (float const   )1.0F) {
#line 24259
                          ctx->ModelViewMatrixType = 4U;
                        } else {
                          goto _L___7;
                        }
                      } else {
                        goto _L___7;
                      }
                    } else {
                      goto _L___7;
                    }
                  } else {
                    goto _L___7;
                  }
                } else {
                  goto _L___7;
                }
              } else {
                goto _L___7;
              }
            } else {
              goto _L___7;
            }
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else {
        _L___7: /* CIL Label */ 
#line 24261
        if (*(m + 3) == (float const   )0.0F) {
#line 24261
          if (*(m + 7) == (float const   )0.0F) {
#line 24261
            if (*(m + 11) == (float const   )0.0F) {
#line 24261
              if (*(m + 15) == (float const   )1.0F) {
#line 24262
                ctx->ModelViewMatrixType = 6U;
              } else {
#line 24265
                ctx->ModelViewMatrixType = 0U;
              }
            } else {
#line 24265
              ctx->ModelViewMatrixType = 0U;
            }
          } else {
#line 24265
            ctx->ModelViewMatrixType = 0U;
          }
        } else {
#line 24265
          ctx->ModelViewMatrixType = 0U;
        }
      }
    }
  }
#line 24267
  invert_matrix((float const   *)(ctx->ModelViewMatrix), ctx->ModelViewInv);
#line 24268
  ctx->NewModelViewMatrix = (unsigned char)0;
#line 24269
  return;
}
}
#line 24270 "D:/a/test/177.c"
void gl_analyze_projection_matrix(GLcontext *ctx ) 
{ float const   *m ;
  GLboolean tmp___0 ;

  {
#line 24272
  m = (float const   *)(ctx->ProjectionMatrix);
#line 24273
  tmp___0 = is_identity((float const   *)m);
#line 24273
  if (tmp___0) {
#line 24274
    ctx->ProjectionMatrixType = 1U;
  } else {
#line 24276
    if (*(m + 4) == (float const   )0.0F) {
#line 24276
      if (*(m + 8) == (float const   )0.0F) {
#line 24276
        if (*(m + 1) == (float const   )0.0F) {
#line 24276
          if (*(m + 9) == (float const   )0.0F) {
#line 24276
            if (*(m + 2) == (float const   )0.0F) {
#line 24276
              if (*(m + 6) == (float const   )0.0F) {
#line 24276
                if (*(m + 3) == (float const   )0.0F) {
#line 24276
                  if (*(m + 7) == (float const   )0.0F) {
#line 24276
                    if (*(m + 11) == (float const   )0.0F) {
#line 24276
                      if (*(m + 15) == (float const   )1.0F) {
#line 24280
                        ctx->ProjectionMatrixType = 2U;
                      } else {
                        goto _L___7;
                      }
                    } else {
                      goto _L___7;
                    }
                  } else {
                    goto _L___7;
                  }
                } else {
                  goto _L___7;
                }
              } else {
                goto _L___7;
              }
            } else {
              goto _L___7;
            }
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else {
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
#line 24282
      if (*(m + 4) == (float const   )0.0F) {
#line 24282
        if (*(m + 12) == (float const   )0.0F) {
#line 24282
          if (*(m + 1) == (float const   )0.0F) {
#line 24282
            if (*(m + 13) == (float const   )0.0F) {
#line 24282
              if (*(m + 2) == (float const   )0.0F) {
#line 24282
                if (*(m + 6) == (float const   )0.0F) {
#line 24282
                  if (*(m + 3) == (float const   )0.0F) {
#line 24282
                    if (*(m + 7) == (float const   )0.0F) {
#line 24282
                      if (*(m + 11) == (float const   )(- 1.0F)) {
#line 24282
                        if (*(m + 15) == (float const   )0.0F) {
#line 24286
                          ctx->ProjectionMatrixType = 3U;
                        } else {
#line 24289
                          ctx->ProjectionMatrixType = 0U;
                        }
                      } else {
#line 24289
                        ctx->ProjectionMatrixType = 0U;
                      }
                    } else {
#line 24289
                      ctx->ProjectionMatrixType = 0U;
                    }
                  } else {
#line 24289
                    ctx->ProjectionMatrixType = 0U;
                  }
                } else {
#line 24289
                  ctx->ProjectionMatrixType = 0U;
                }
              } else {
#line 24289
                ctx->ProjectionMatrixType = 0U;
              }
            } else {
#line 24289
              ctx->ProjectionMatrixType = 0U;
            }
          } else {
#line 24289
            ctx->ProjectionMatrixType = 0U;
          }
        } else {
#line 24289
          ctx->ProjectionMatrixType = 0U;
        }
      } else {
#line 24289
        ctx->ProjectionMatrixType = 0U;
      }
    }
  }
#line 24291
  ctx->NewProjectionMatrix = (unsigned char)0;
#line 24292
  return;
}
}
#line 24293 "D:/a/test/177.c"
void gl_analyze_texture_matrix(GLcontext *ctx ) 
{ float const   *m ;
  GLboolean tmp___0 ;

  {
#line 24295
  m = (float const   *)(ctx->TextureMatrix);
#line 24296
  tmp___0 = is_identity((float const   *)m);
#line 24296
  if (tmp___0) {
#line 24297
    ctx->TextureMatrixType = 1U;
  } else {
#line 24299
    if (*(m + 8) == (float const   )0.0F) {
#line 24299
      if (*(m + 9) == (float const   )0.0F) {
#line 24299
        if (*(m + 2) == (float const   )0.0F) {
#line 24299
          if (*(m + 6) == (float const   )0.0F) {
#line 24299
            if (*(m + 10) == (float const   )1.0F) {
#line 24299
              if (*(m + 14) == (float const   )0.0F) {
#line 24299
                if (*(m + 3) == (float const   )0.0F) {
#line 24299
                  if (*(m + 7) == (float const   )0.0F) {
#line 24299
                    if (*(m + 11) == (float const   )0.0F) {
#line 24299
                      if (*(m + 15) == (float const   )1.0F) {
#line 24303
                        ctx->TextureMatrixType = 4U;
                      } else {
                        goto _L___7;
                      }
                    } else {
                      goto _L___7;
                    }
                  } else {
                    goto _L___7;
                  }
                } else {
                  goto _L___7;
                }
              } else {
                goto _L___7;
              }
            } else {
              goto _L___7;
            }
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else {
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
#line 24305
      if (*(m + 3) == (float const   )0.0F) {
#line 24305
        if (*(m + 7) == (float const   )0.0F) {
#line 24305
          if (*(m + 11) == (float const   )0.0F) {
#line 24305
            if (*(m + 15) == (float const   )1.0F) {
#line 24306
              ctx->TextureMatrixType = 6U;
            } else {
#line 24309
              ctx->TextureMatrixType = 0U;
            }
          } else {
#line 24309
            ctx->TextureMatrixType = 0U;
          }
        } else {
#line 24309
          ctx->TextureMatrixType = 0U;
        }
      } else {
#line 24309
        ctx->TextureMatrixType = 0U;
      }
    }
  }
#line 24311
  ctx->NewTextureMatrix = (unsigned char)0;
#line 24312
  return;
}
}
#line 24313 "D:/a/test/177.c"
void gl_Frustum(GLcontext *ctx , GLdouble left , GLdouble right , GLdouble bottom ,
                GLdouble top , GLdouble nearval , GLdouble farval ) 
{ float x ;
  float y ;
  float a ;
  float b ;
  float c ;
  float d ;
  float m[16] ;

  {
#line 24320
  if (nearval <= 0.0) {
#line 24321
    gl_error(ctx, 1281, "glFrustum(near or far)");
  } else {
#line 24320
    if (farval <= 0.0) {
#line 24321
      gl_error(ctx, 1281, "glFrustum(near or far)");
    }
  }
#line 24323
  x = (float )((2.0 * nearval) / (right - left));
#line 24324
  y = (float )((2.0 * nearval) / (top - bottom));
#line 24325
  a = (float )((right + left) / (right - left));
#line 24326
  b = (float )((top + bottom) / (top - bottom));
#line 24327
  c = (float )(- (farval + nearval) / (farval - nearval));
#line 24328
  d = (float )(- ((2.0 * farval) * nearval) / (farval - nearval));
#line 24330
  m[0] = x;
#line 24330
  m[4] = 0.0F;
#line 24330
  m[8] = a;
#line 24330
  m[12] = 0.0F;
#line 24331
  m[1] = 0.0F;
#line 24331
  m[5] = y;
#line 24331
  m[9] = b;
#line 24331
  m[13] = 0.0F;
#line 24332
  m[2] = 0.0F;
#line 24332
  m[6] = 0.0F;
#line 24332
  m[10] = c;
#line 24332
  m[14] = d;
#line 24333
  m[3] = 0.0F;
#line 24333
  m[7] = 0.0F;
#line 24333
  m[11] = - 1.0F;
#line 24333
  m[15] = 0.0F;
#line 24335
  gl_MultMatrixf(ctx, m);
#line 24336
  ctx->NearFarStack[ctx->ProjectionStackDepth][0] = (float )nearval;
#line 24337
  ctx->NearFarStack[ctx->ProjectionStackDepth][1] = (float )farval;
#line 24338
  if (ctx->Driver.NearFar) {
#line 24339
    (*(ctx->Driver.NearFar))(ctx, (float )nearval, (float )farval);
  }
#line 24341
  return;
}
}
#line 24342 "D:/a/test/177.c"
void gl_Ortho(GLcontext *ctx , GLdouble left , GLdouble right , GLdouble bottom ,
              GLdouble top , GLdouble nearval , GLdouble farval ) 
{ float x ;
  float y ;
  float z ;
  float tx ;
  float ty ;
  float tz ;
  float m[16] ;

  {
#line 24350
  x = (float )(2.0 / (right - left));
#line 24351
  y = (float )(2.0 / (top - bottom));
#line 24352
  z = (float )(- 2.0 / (farval - nearval));
#line 24353
  tx = (float )(- (right + left) / (right - left));
#line 24354
  ty = (float )(- (top + bottom) / (top - bottom));
#line 24355
  tz = (float )(- (farval + nearval) / (farval - nearval));
#line 24357
  m[0] = x;
#line 24357
  m[4] = 0.0F;
#line 24357
  m[8] = 0.0F;
#line 24357
  m[12] = tx;
#line 24358
  m[1] = 0.0F;
#line 24358
  m[5] = y;
#line 24358
  m[9] = 0.0F;
#line 24358
  m[13] = ty;
#line 24359
  m[2] = 0.0F;
#line 24359
  m[6] = 0.0F;
#line 24359
  m[10] = z;
#line 24359
  m[14] = tz;
#line 24360
  m[3] = 0.0F;
#line 24360
  m[7] = 0.0F;
#line 24360
  m[11] = 0.0F;
#line 24360
  m[15] = 1.0F;
#line 24362
  gl_MultMatrixf(ctx, m);
#line 24363
  if (ctx->Driver.NearFar) {
#line 24364
    (*(ctx->Driver.NearFar))(ctx, (float )nearval, (float )farval);
  }
#line 24366
  return;
}
}
#line 24367 "D:/a/test/177.c"
void gl_MatrixMode(GLcontext *ctx , GLenum mode ) 
{ 

  {
#line 24369
  if (ctx->Primitive != 6656) {
#line 24370
    gl_error(ctx, 1282, "glMatrixMode");
#line 24371
    return;
  }
#line 24373
  switch (mode) {
  case 5888: 
  case 5889: 
  case 5890: 
#line 24377
  ctx->Transform.MatrixMode = mode;
#line 24378
  break;
  default: 
#line 24380
  gl_error(ctx, 1280, "glMatrixMode");
  }
#line 24382
  return;
}
}
#line 24383 "D:/a/test/177.c"
void gl_PushMatrix(GLcontext *ctx ) 
{ 

  {
#line 24385
  if (ctx->Primitive != 6656) {
#line 24386
    gl_error(ctx, 1282, "glPushMatrix");
#line 24387
    return;
  }
#line 24389
  switch (ctx->Transform.MatrixMode) {
  case 5888: 
#line 24391
  if (ctx->ModelViewStackDepth >= 31U) {
#line 24392
    gl_error(ctx, 1283, "glPushMatrix");
#line 24393
    return;
  }
#line 24395
  memcpy((void *)(ctx->ModelViewStack[ctx->ModelViewStackDepth]), (void const   *)((void *)(ctx->ModelViewMatrix)),
         16U * sizeof(float ));
#line 24398
  (ctx->ModelViewStackDepth) ++;
#line 24399
  break;
  case 5889: 
#line 24401
  if (ctx->ProjectionStackDepth >= 32U) {
#line 24402
    gl_error(ctx, 1283, "glPushMatrix");
#line 24403
    return;
  }
#line 24405
  memcpy((void *)(ctx->ProjectionStack[ctx->ProjectionStackDepth]), (void const   *)((void *)(ctx->ProjectionMatrix)),
         16U * sizeof(float ));
#line 24408
  (ctx->ProjectionStackDepth) ++;
#line 24409
  ctx->NearFarStack[ctx->ProjectionStackDepth][0] = ctx->NearFarStack[ctx->ProjectionStackDepth - 1U][0];
#line 24411
  ctx->NearFarStack[ctx->ProjectionStackDepth][1] = ctx->NearFarStack[ctx->ProjectionStackDepth - 1U][1];
#line 24413
  break;
  case 5890: 
#line 24415
  if (ctx->TextureStackDepth >= 10U) {
#line 24416
    gl_error(ctx, 1283, "glPushMatrix");
#line 24417
    return;
  }
#line 24419
  memcpy((void *)(ctx->TextureStack[ctx->TextureStackDepth]), (void const   *)((void *)(ctx->TextureMatrix)),
         16U * sizeof(float ));
#line 24422
  (ctx->TextureStackDepth) ++;
#line 24423
  break;
  default: 
#line 24425
  gl_problem((GLcontext const   *)ctx, "Bad matrix mode in gl_PushMatrix");
  }
#line 24427
  return;
}
}
#line 24428 "D:/a/test/177.c"
void gl_PopMatrix(GLcontext *ctx ) 
{ float nearVal ;
  float farVal ;

  {
#line 24430
  if (ctx->Primitive != 6656) {
#line 24431
    gl_error(ctx, 1282, "glPopMatrix");
#line 24432
    return;
  }
#line 24434
  switch (ctx->Transform.MatrixMode) {
  case 5888: 
#line 24436
  if (ctx->ModelViewStackDepth == 0U) {
#line 24437
    gl_error(ctx, 1284, "glPopMatrix");
#line 24438
    return;
  }
#line 24440
  (ctx->ModelViewStackDepth) --;
#line 24441
  memcpy((void *)(ctx->ModelViewMatrix), (void const   *)((void *)(ctx->ModelViewStack[ctx->ModelViewStackDepth])),
         16U * sizeof(float ));
#line 24444
  ctx->NewModelViewMatrix = (unsigned char)1;
#line 24445
  break;
  case 5889: 
#line 24447
  if (ctx->ProjectionStackDepth == 0U) {
#line 24448
    gl_error(ctx, 1284, "glPopMatrix");
#line 24449
    return;
  }
#line 24451
  (ctx->ProjectionStackDepth) --;
#line 24452
  memcpy((void *)(ctx->ProjectionMatrix), (void const   *)((void *)(ctx->ProjectionStack[ctx->ProjectionStackDepth])),
         16U * sizeof(float ));
#line 24455
  ctx->NewProjectionMatrix = (unsigned char)1;
#line 24457
  nearVal = ctx->NearFarStack[ctx->ProjectionStackDepth][0];
#line 24458
  farVal = ctx->NearFarStack[ctx->ProjectionStackDepth][1];
#line 24459
  if (ctx->Driver.NearFar) {
#line 24460
    (*(ctx->Driver.NearFar))(ctx, nearVal, farVal);
  }
#line 24463
  break;
  case 5890: 
#line 24465
  if (ctx->TextureStackDepth == 0U) {
#line 24466
    gl_error(ctx, 1284, "glPopMatrix");
#line 24467
    return;
  }
#line 24469
  (ctx->TextureStackDepth) --;
#line 24470
  memcpy((void *)(ctx->TextureMatrix), (void const   *)((void *)(ctx->TextureStack[ctx->TextureStackDepth])),
         16U * sizeof(float ));
#line 24473
  ctx->NewTextureMatrix = (unsigned char)1;
#line 24474
  break;
  default: 
#line 24476
  gl_problem((GLcontext const   *)ctx, "Bad matrix mode in gl_PopMatrix");
  }
#line 24478
  return;
}
}
#line 24479 "D:/a/test/177.c"
void gl_LoadIdentity(GLcontext *ctx ) 
{ 

  {
#line 24481
  if (ctx->Primitive != 6656) {
#line 24482
    gl_error(ctx, 1282, "glLoadIdentity");
#line 24483
    return;
  }
#line 24485
  switch (ctx->Transform.MatrixMode) {
  case 5888: 
#line 24487
  memcpy((void *)(ctx->ModelViewMatrix), (void const   *)((void *)(Identity)), 16U * sizeof(float ));
#line 24488
  memcpy((void *)(ctx->ModelViewInv), (void const   *)((void *)(Identity)), 16U * sizeof(float ));
#line 24489
  ctx->ModelViewMatrixType = 1U;
#line 24490
  ctx->NewModelViewMatrix = (unsigned char)0;
#line 24491
  break;
  case 5889: 
#line 24493
  memcpy((void *)(ctx->ProjectionMatrix), (void const   *)((void *)(Identity)), 16U * sizeof(float ));
#line 24494
  ctx->ProjectionMatrixType = 1U;
#line 24495
  ctx->NewProjectionMatrix = (unsigned char)0;
#line 24496
  break;
  case 5890: 
#line 24498
  memcpy((void *)(ctx->TextureMatrix), (void const   *)((void *)(Identity)), 16U * sizeof(float ));
#line 24499
  ctx->TextureMatrixType = 1U;
#line 24500
  ctx->NewTextureMatrix = (unsigned char)0;
#line 24501
  break;
  default: 
#line 24503
  gl_problem((GLcontext const   *)ctx, "Bad matrix mode in gl_LoadIdentity");
  }
#line 24505
  return;
}
}
#line 24506 "D:/a/test/177.c"
void gl_LoadMatrixf(GLcontext *ctx , float const   *m ) 
{ 

  {
#line 24508
  if (ctx->Primitive != 6656) {
#line 24509
    gl_error(ctx, 1282, "glLoadMatrix");
#line 24510
    return;
  }
#line 24512
  switch (ctx->Transform.MatrixMode) {
  case 5888: 
#line 24514
  memcpy((void *)(ctx->ModelViewMatrix), (void const   *)((void *)m), 16U * sizeof(float ));
#line 24515
  ctx->NewModelViewMatrix = (unsigned char)1;
#line 24516
  break;
  case 5889: 
#line 24518
  memcpy((void *)(ctx->ProjectionMatrix), (void const   *)((void *)m), 16U * sizeof(float ));
#line 24519
  ctx->NewProjectionMatrix = (unsigned char)1;
#line 24520
  break;
  case 5890: 
#line 24522
  memcpy((void *)(ctx->TextureMatrix), (void const   *)((void *)m), 16U * sizeof(float ));
#line 24523
  ctx->NewTextureMatrix = (unsigned char)1;
#line 24524
  break;
  default: 
#line 24526
  gl_problem((GLcontext const   *)ctx, "Bad matrix mode in gl_LoadMatrixf");
  }
#line 24528
  return;
}
}
#line 24529 "D:/a/test/177.c"
void gl_MultMatrixf(GLcontext *ctx , float const   *m ) 
{ 

  {
#line 24531
  if (ctx->Primitive != 6656) {
#line 24532
    gl_error(ctx, 1282, "glMultMatrix");
#line 24533
    return;
  }
#line 24535
  switch (ctx->Transform.MatrixMode) {
  case 5888: 
#line 24537
  matmul(ctx->ModelViewMatrix, (float const   *)(ctx->ModelViewMatrix), m);
#line 24538
  ctx->NewModelViewMatrix = (unsigned char)1;
#line 24539
  break;
  case 5889: 
#line 24541
  matmul(ctx->ProjectionMatrix, (float const   *)(ctx->ProjectionMatrix), m);
#line 24542
  ctx->NewProjectionMatrix = (unsigned char)1;
#line 24543
  break;
  case 5890: 
#line 24545
  matmul(ctx->TextureMatrix, (float const   *)(ctx->TextureMatrix), m);
#line 24546
  ctx->NewTextureMatrix = (unsigned char)1;
#line 24547
  break;
  default: 
#line 24549
  gl_problem((GLcontext const   *)ctx, "Bad matrix mode in gl_MultMatrixf");
  }
#line 24551
  return;
}
}
#line 24559
extern int ( /* missing proto */  GL_SQRT)(float x) ;
#line 24552 "D:/a/test/177.c"
void gl_rotation_matrix(float angle , float x , float y , float z , float *m ) 
{ float mag ;
  float s ;
  float c ;
  float xx ;
  float yy ;
  float zz ;
  float xy ;
  float yz ;
  float zx ;
  float xs ;
  float ys ;
  float zs ;
  float one_c ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;

  {
#line 24557
  tmp___0 = sin((double )angle * (3.14159265358979323846 / 180.0));
#line 24557
  s = (float )tmp___0;
#line 24558
  tmp___1 = cos((double )angle * (3.14159265358979323846 / 180.0));
#line 24558
  c = (float )tmp___1;
#line 24559
  tmp___2 = GL_SQRT((x * x + y * y) + z * z);
#line 24559
  mag = (float )tmp___2;
#line 24560
  if ((double )mag == 0.0) {
#line 24561
    memcpy((void *)m, (void const   *)((void *)(Identity)), sizeof(float ) * 16U);
#line 24562
    return;
  }
#line 24564
  x /= mag;
#line 24565
  y /= mag;
#line 24566
  z /= mag;
#line 24568
  xx = x * x;
#line 24569
  yy = y * y;
#line 24570
  zz = z * z;
#line 24571
  xy = x * y;
#line 24572
  yz = y * z;
#line 24573
  zx = z * x;
#line 24574
  xs = x * s;
#line 24575
  ys = y * s;
#line 24576
  zs = z * s;
#line 24577
  one_c = 1.0F - c;
#line 24578
  *(m + 0) = one_c * xx + c;
#line 24579
  *(m + 4) = one_c * xy - zs;
#line 24580
  *(m + 8) = one_c * zx + ys;
#line 24581
  *(m + 12) = 0.0F;
#line 24582
  *(m + 1) = one_c * xy + zs;
#line 24583
  *(m + 5) = one_c * yy + c;
#line 24584
  *(m + 9) = one_c * yz - xs;
#line 24585
  *(m + 13) = 0.0F;
#line 24586
  *(m + 2) = one_c * zx - ys;
#line 24587
  *(m + 6) = one_c * yz + xs;
#line 24588
  *(m + 10) = one_c * zz + c;
#line 24589
  *(m + 14) = 0.0F;
#line 24590
  *(m + 3) = 0.0F;
#line 24591
  *(m + 7) = 0.0F;
#line 24592
  *(m + 11) = 0.0F;
#line 24593
  *(m + 15) = 1.0F;
#line 24595
  return;
}
}
#line 24596 "D:/a/test/177.c"
void gl_Rotatef(GLcontext *ctx , float angle , float x , float y , float z ) 
{ float m[16] ;

  {
#line 24600
  gl_rotation_matrix(angle, x, y, z, m);
#line 24601
  gl_MultMatrixf(ctx, (float const   *)(m));
#line 24602
  return;
}
}
#line 24603 "D:/a/test/177.c"
void gl_Scalef(GLcontext *ctx , float x , float y , float z ) 
{ float *m ;

  {
#line 24606
  if (ctx->Primitive != 6656) {
#line 24607
    gl_error(ctx, 1282, "glScale");
#line 24608
    return;
  }
#line 24610
  switch (ctx->Transform.MatrixMode) {
  case 5888: 
#line 24612
  m = ctx->ModelViewMatrix;
#line 24613
  ctx->NewModelViewMatrix = (unsigned char)1;
#line 24614
  break;
  case 5889: 
#line 24616
  m = ctx->ProjectionMatrix;
#line 24617
  ctx->NewProjectionMatrix = (unsigned char)1;
#line 24618
  break;
  case 5890: 
#line 24620
  m = ctx->TextureMatrix;
#line 24621
  ctx->NewTextureMatrix = (unsigned char)1;
#line 24622
  break;
  default: 
#line 24624
  gl_problem((GLcontext const   *)ctx, "Bad matrix mode in gl_Scalef");
#line 24625
  return;
  }
#line 24627
  *(m + 0) *= x;
#line 24627
  *(m + 4) *= y;
#line 24627
  *(m + 8) *= z;
#line 24628
  *(m + 1) *= x;
#line 24628
  *(m + 5) *= y;
#line 24628
  *(m + 9) *= z;
#line 24629
  *(m + 2) *= x;
#line 24629
  *(m + 6) *= y;
#line 24629
  *(m + 10) *= z;
#line 24630
  *(m + 3) *= x;
#line 24630
  *(m + 7) *= y;
#line 24630
  *(m + 11) *= z;
#line 24631
  return;
}
}
#line 24632 "D:/a/test/177.c"
void gl_Translatef(GLcontext *ctx , float x , float y , float z ) 
{ float *m ;

  {
#line 24635
  if (ctx->Primitive != 6656) {
#line 24636
    gl_error(ctx, 1282, "glTranslate");
#line 24637
    return;
  }
#line 24639
  switch (ctx->Transform.MatrixMode) {
  case 5888: 
#line 24641
  m = ctx->ModelViewMatrix;
#line 24642
  ctx->NewModelViewMatrix = (unsigned char)1;
#line 24643
  break;
  case 5889: 
#line 24645
  m = ctx->ProjectionMatrix;
#line 24646
  ctx->NewProjectionMatrix = (unsigned char)1;
#line 24647
  break;
  case 5890: 
#line 24649
  m = ctx->TextureMatrix;
#line 24650
  ctx->NewTextureMatrix = (unsigned char)1;
#line 24651
  break;
  default: 
#line 24653
  gl_problem((GLcontext const   *)ctx, "Bad matrix mode in gl_Translatef");
#line 24654
  return;
  }
#line 24656
  *(m + 12) = ((*(m + 0) * x + *(m + 4) * y) + *(m + 8) * z) + *(m + 12);
#line 24657
  *(m + 13) = ((*(m + 1) * x + *(m + 5) * y) + *(m + 9) * z) + *(m + 13);
#line 24658
  *(m + 14) = ((*(m + 2) * x + *(m + 6) * y) + *(m + 10) * z) + *(m + 14);
#line 24659
  *(m + 15) = ((*(m + 3) * x + *(m + 7) * y) + *(m + 11) * z) + *(m + 15);
#line 24660
  return;
}
}
#line 24661 "D:/a/test/177.c"
void gl_Viewport(GLcontext *ctx , GLint x , GLint y , GLsizei width , GLsizei height ) 
{ int tmp___0 ;
  int tmp___1 ;

  {
#line 24664
  if (width < 0) {
#line 24665
    gl_error(ctx, 1281, "glViewport");
#line 24666
    return;
  } else {
#line 24664
    if (height < 0) {
#line 24665
      gl_error(ctx, 1281, "glViewport");
#line 24666
      return;
    }
  }
#line 24668
  if (ctx->Primitive != 6656) {
#line 24669
    gl_error(ctx, 1282, "glViewport");
#line 24670
    return;
  }
#line 24672
  if (width < 1) {
#line 24672
    width = 1;
  } else {
#line 24672
    if (width > 640) {
#line 24672
      tmp___0 = 640;
    } else {
#line 24672
      tmp___0 = width;
    }
#line 24672
    width = tmp___0;
  }
#line 24673
  if (height < 1) {
#line 24673
    height = 1;
  } else {
#line 24673
    if (height > 400) {
#line 24673
      tmp___1 = 400;
    } else {
#line 24673
      tmp___1 = height;
    }
#line 24673
    height = tmp___1;
  }
#line 24674
  ctx->Viewport.X = x;
#line 24675
  ctx->Viewport.Width = width;
#line 24676
  ctx->Viewport.Y = y;
#line 24677
  ctx->Viewport.Height = height;
#line 24678
  ctx->Viewport.Sx = (float )width / 2.0F;
#line 24679
  ctx->Viewport.Tx = ctx->Viewport.Sx + (float )x;
#line 24680
  ctx->Viewport.Sy = (float )height / 2.0F;
#line 24681
  ctx->Viewport.Ty = ctx->Viewport.Sy + (float )y;
#line 24682
  ctx->NewState |= 15U;
#line 24683
  gl_ResizeBuffersMESA(ctx);
#line 24684
  return;
}
}
#line 24690 "D:/a/test/177.c"
void gl_ClearIndex(GLcontext *ctx , float c ) 
{ 

  {
#line 24692
  if (ctx->Primitive != 6656) {
#line 24693
    gl_error(ctx, 1282, "glClearIndex");
#line 24694
    return;
  }
#line 24696
  ctx->Color.ClearIndex = (unsigned int )c;
#line 24697
  if (! (ctx->Visual)->RGBAflag) {
#line 24698
    (*(ctx->Driver.ClearIndex))(ctx, ctx->Color.ClearIndex);
  }
#line 24700
  return;
}
}
#line 24701 "D:/a/test/177.c"
void gl_ClearColor(GLcontext *ctx , GLclampf red , GLclampf green , GLclampf blue___0 ,
                   GLclampf alpha ) 
{ float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  GLubyte r ;
  GLubyte g ;
  GLubyte b ;
  GLubyte a ;

  {
#line 24704
  if (ctx->Primitive != 6656) {
#line 24705
    gl_error(ctx, 1282, "glClearColor");
#line 24706
    return;
  }
#line 24708
  if (red < 0.0F) {
#line 24708
    ctx->Color.ClearColor[0] = 0.0F;
  } else {
#line 24708
    if (red > 1.0F) {
#line 24708
      tmp___0 = 1.0F;
    } else {
#line 24708
      tmp___0 = red;
    }
#line 24708
    ctx->Color.ClearColor[0] = tmp___0;
  }
#line 24709
  if (green < 0.0F) {
#line 24709
    ctx->Color.ClearColor[1] = 0.0F;
  } else {
#line 24709
    if (green > 1.0F) {
#line 24709
      tmp___1 = 1.0F;
    } else {
#line 24709
      tmp___1 = green;
    }
#line 24709
    ctx->Color.ClearColor[1] = tmp___1;
  }
#line 24710
  if (blue___0 < 0.0F) {
#line 24710
    ctx->Color.ClearColor[2] = 0.0F;
  } else {
#line 24710
    if (blue___0 > 1.0F) {
#line 24710
      tmp___2 = 1.0F;
    } else {
#line 24710
      tmp___2 = blue___0;
    }
#line 24710
    ctx->Color.ClearColor[2] = tmp___2;
  }
#line 24711
  if (alpha < 0.0F) {
#line 24711
    ctx->Color.ClearColor[3] = 0.0F;
  } else {
#line 24711
    if (alpha > 1.0F) {
#line 24711
      tmp___3 = 1.0F;
    } else {
#line 24711
      tmp___3 = alpha;
    }
#line 24711
    ctx->Color.ClearColor[3] = tmp___3;
  }
#line 24712
  if ((ctx->Visual)->RGBAflag) {
#line 24713
    r = (GLubyte )((int )(ctx->Color.ClearColor[0] * (ctx->Visual)->RedScale));
#line 24714
    g = (GLubyte )((int )(ctx->Color.ClearColor[1] * (ctx->Visual)->GreenScale));
#line 24715
    b = (GLubyte )((int )(ctx->Color.ClearColor[2] * (ctx->Visual)->BlueScale));
#line 24716
    a = (GLubyte )((int )(ctx->Color.ClearColor[3] * (ctx->Visual)->AlphaScale));
#line 24717
    (*(ctx->Driver.ClearColor))(ctx, r, g, b, a);
  }
#line 24719
  return;
}
}
#line 24720 "D:/a/test/177.c"
static void clear_color_buffer_with_masking(GLcontext *ctx ) 
{ GLint x ;
  GLint y ;
  GLint height ;
  GLint width ;
  GLubyte red[640] ;
  GLubyte green[640] ;
  GLubyte blue___0[640] ;
  GLubyte alpha[640] ;
  GLubyte r ;
  GLubyte g ;
  GLubyte b ;
  GLubyte a ;
  GLint i ;
  GLuint indx[640] ;
  GLubyte mask[640] ;
  GLint i___0 ;
  GLint j ;

  {
#line 24723
  if (ctx->Scissor.Enabled) {
#line 24724
    x = (ctx->Buffer)->Xmin;
#line 24725
    y = (ctx->Buffer)->Ymin;
#line 24726
    height = ((ctx->Buffer)->Ymax - (ctx->Buffer)->Ymin) + 1;
#line 24727
    width = ((ctx->Buffer)->Xmax - (ctx->Buffer)->Xmin) + 1;
  } else {
#line 24730
    x = 0;
#line 24731
    y = 0;
#line 24732
    height = (ctx->Buffer)->Height;
#line 24733
    width = (ctx->Buffer)->Width;
  }
#line 24735
  if ((ctx->Visual)->RGBAflag) {
#line 24738
    r = (GLubyte )(ctx->Color.ClearColor[0] * (ctx->Visual)->RedScale);
#line 24739
    g = (GLubyte )(ctx->Color.ClearColor[1] * (ctx->Visual)->GreenScale);
#line 24740
    b = (GLubyte )(ctx->Color.ClearColor[2] * (ctx->Visual)->BlueScale);
#line 24741
    a = (GLubyte )(ctx->Color.ClearColor[3] * (ctx->Visual)->AlphaScale);
#line 24743
    i = 0;
#line 24743
    while (i < height) {
#line 24744
      memset((void *)(red), (int )r, (unsigned int )width);
#line 24745
      memset((void *)(green), (int )g, (unsigned int )width);
#line 24746
      memset((void *)(blue___0), (int )b, (unsigned int )width);
#line 24747
      memset((void *)(alpha), (int )a, (unsigned int )width);
#line 24748
      gl_mask_color_span(ctx, (unsigned int )width, x, y, red, green, blue___0, alpha);
#line 24749
      (*(ctx->Driver.WriteColorSpan))(ctx, (unsigned int )width, x, y, (GLubyte const   *)(red),
                                      (GLubyte const   *)(green), (GLubyte const   *)(blue___0),
                                      (GLubyte const   *)(alpha), (GLubyte const   *)((void *)0));
#line 24751
      if (ctx->RasterMask & 256U) {
#line 24752
        gl_write_alpha_span(ctx, (unsigned int )width, x, y, alpha, (GLubyte *)((void *)0));
      }
#line 24743
      i ++;
#line 24743
      y ++;
    }
  } else {
#line 24760
    memset((void *)(mask), 1, (unsigned int )width);
#line 24761
    i___0 = 0;
#line 24761
    while (i___0 < height) {
#line 24762
      j = 0;
#line 24762
      while (j < width) {
#line 24763
        indx[j] = ctx->Color.ClearIndex;
#line 24762
        j ++;
      }
#line 24765
      gl_mask_index_span(ctx, (unsigned int )width, x, y, indx);
#line 24766
      (*(ctx->Driver.WriteIndexSpan))(ctx, (unsigned int )width, x, y, (GLuint const   *)(indx),
                                      (GLubyte const   *)(mask));
#line 24761
      i___0 ++;
#line 24761
      y ++;
    }
  }
#line 24769
  return;
}
}
#line 24770 "D:/a/test/177.c"
static void clear_color_buffers(GLcontext *ctx ) 
{ GLint x ;
  GLint y ;
  GLint height ;
  GLint width ;
  GLint x___0 ;
  GLint y___0 ;
  GLint height___0 ;
  GLint width___0 ;

  {
#line 24772
  if (ctx->Color.SWmasking) {
#line 24773
    clear_color_buffer_with_masking(ctx);
  } else {
#line 24776
    x = (ctx->Buffer)->Xmin;
#line 24777
    y = (ctx->Buffer)->Ymin;
#line 24778
    height = ((ctx->Buffer)->Ymax - (ctx->Buffer)->Ymin) + 1;
#line 24779
    width = ((ctx->Buffer)->Xmax - (ctx->Buffer)->Xmin) + 1;
#line 24780
    (*(ctx->Driver.Clear))(ctx, (unsigned char )(! ctx->Scissor.Enabled), x, y, width,
                           height);
#line 24782
    if (ctx->RasterMask & 256U) {
#line 24783
      gl_clear_alpha_buffers(ctx);
    }
  }
#line 24786
  if (ctx->RasterMask & 1024U) {
#line 24787
    (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 24788
    if (ctx->Color.SWmasking) {
#line 24789
      clear_color_buffer_with_masking(ctx);
    } else {
#line 24792
      x___0 = (ctx->Buffer)->Xmin;
#line 24793
      y___0 = (ctx->Buffer)->Ymin;
#line 24794
      height___0 = ((ctx->Buffer)->Ymax - (ctx->Buffer)->Ymin) + 1;
#line 24795
      width___0 = ((ctx->Buffer)->Xmax - (ctx->Buffer)->Xmin) + 1;
#line 24796
      (*(ctx->Driver.Clear))(ctx, (unsigned char )(! ctx->Scissor.Enabled), x___0,
                             y___0, width___0, height___0);
    }
#line 24799
    (*(ctx->Driver.SetBuffer))(ctx, 1028);
  }
#line 24801
  return;
}
}
#line 24818
void gl_clear_stencil_buffer(GLcontext *ctx ) ;
#line 24802 "D:/a/test/177.c"
void gl_Clear(GLcontext *ctx , GLbitfield mask ) 
{ 

  {
#line 24807
  if (ctx->Primitive != 6656) {
#line 24808
    gl_error(ctx, 1282, "glClear");
#line 24809
    return;
  }
#line 24811
  if (ctx->RenderMode == 7168) {
#line 24812
    if (ctx->NewState) {
#line 24813
      gl_update_state(ctx);
    }
#line 24815
    if (mask & 16384U) {
#line 24815
      clear_color_buffers(ctx);
    }
#line 24816
    if (mask & 256U) {
#line 24816
      (*(ctx->Driver.ClearDepthBuffer))(ctx);
    }
#line 24817
    if (mask & 512U) {
#line 24817
      gl_clear_accum_buffer(ctx);
    }
#line 24818
    if (mask & 1024U) {
#line 24818
      gl_clear_stencil_buffer(ctx);
    }
  }
#line 24824
  return;
}
}
#line 24827 "D:/a/test/177.c"
static char renderer[1000]  ;
#line 24828
GLubyte const   *gl_GetString(GLcontext *ctx , GLenum name ) ;
#line 24828 "D:/a/test/177.c"
static char *vendor  =    (char *)"Brian Paul";
#line 24829
GLubyte const   *gl_GetString(GLcontext *ctx , GLenum name ) ;
#line 24829 "D:/a/test/177.c"
static char *version  =    (char *)"1.1 Mesa 2.5";
#line 24833
GLubyte const   *gl_GetString(GLcontext *ctx , GLenum name ) ;
#line 24833 "D:/a/test/177.c"
static char *extensions  =    (char *)"GL_EXT_blend_color GL_EXT_blend_minmax GL_EXT_blend_logic_op GL_EXT_blend_subtract GL_EXT_paletted_texture GL_EXT_point_parameters GL_EXT_polygon_offset GL_EXT_vertex_array GL_EXT_texture_object GL_EXT_texture3D GL_MESA_window_pos GL_MESA_resize_buffers GL_EXT_shared_texture_palette";
#line 24825 "D:/a/test/177.c"
GLubyte const   *gl_GetString(GLcontext *ctx , GLenum name ) 
{ char const   *tmp___0 ;

  {
#line 24835
  if (ctx->Primitive != 6656) {
#line 24836
    gl_error(ctx, 1282, "glGetString");
#line 24837
    return ((GLubyte const   *)((GLubyte *)0));
  }
#line 24839
  switch (name) {
  case 7936: 
#line 24841
  return ((GLubyte const   *)((GLubyte *)vendor));
  case 7937: 
#line 24843
  strcpy(renderer, "Mesa");
#line 24844
  if (ctx->Driver.RendererString) {
#line 24845
    strcat(renderer, " ");
#line 24846
    tmp___0 = (*(ctx->Driver.RendererString))();
#line 24846
    strcat(renderer, tmp___0);
  }
#line 24848
  return ((GLubyte const   *)((GLubyte *)(renderer)));
  case 7938: 
#line 24850
  return ((GLubyte const   *)((GLubyte *)version));
  case 7939: 
#line 24852
  return ((GLubyte const   *)((GLubyte *)extensions));
  default: 
#line 24854
  gl_error(ctx, 1280, "glGetString");
#line 24855
  return ((GLubyte const   *)((GLubyte *)0));
  }
}
}
#line 24858 "D:/a/test/177.c"
void gl_Finish(GLcontext *ctx ) 
{ 

  {
#line 24860
  if (ctx->Primitive != 6656) {
#line 24861
    gl_error(ctx, 1282, "glFinish");
#line 24862
    return;
  }
#line 24864
  if (ctx->Driver.Finish) {
#line 24865
    (*(ctx->Driver.Finish))(ctx);
  }
#line 24867
  return;
}
}
#line 24868 "D:/a/test/177.c"
void gl_Flush(GLcontext *ctx ) 
{ 

  {
#line 24870
  if (ctx->Primitive != 6656) {
#line 24871
    gl_error(ctx, 1282, "glFlush");
#line 24872
    return;
  }
#line 24874
  if (ctx->Driver.Flush) {
#line 24875
    (*(ctx->Driver.Flush))(ctx);
  }
#line 24877
  return;
}
}
#line 24878 "D:/a/test/177.c"
void gl_Hint(GLcontext *ctx , GLenum target , GLenum mode ) 
{ 

  {
#line 24880
  if (ctx->Primitive != 6656) {
#line 24881
    gl_error(ctx, 1282, "glHint");
#line 24882
    return;
  }
#line 24884
  if (mode != 4352) {
#line 24884
    if (mode != 4353) {
#line 24884
      if (mode != 4354) {
#line 24885
        gl_error(ctx, 1280, "glHint(mode)");
#line 24886
        return;
      }
    }
  }
#line 24888
  switch (target) {
  case 3156: 
#line 24890
  ctx->Hint.Fog = mode;
#line 24891
  break;
  case 3154: 
#line 24893
  ctx->Hint.LineSmooth = mode;
#line 24894
  break;
  case 3152: 
#line 24896
  ctx->Hint.PerspectiveCorrection = mode;
#line 24897
  break;
  case 3153: 
#line 24899
  ctx->Hint.PointSmooth = mode;
#line 24900
  break;
  case 3155: 
#line 24902
  ctx->Hint.PolygonSmooth = mode;
#line 24903
  break;
  default: 
#line 24905
  gl_error(ctx, 1280, "glHint(target)");
  }
#line 24907
  ctx->NewState |= 15U;
#line 24908
  return;
}
}
#line 24909 "D:/a/test/177.c"
void gl_DrawBuffer(GLcontext *ctx , GLenum mode ) 
{ GLboolean tmp___0 ;
  GLboolean tmp___1 ;

  {
#line 24911
  if (ctx->Primitive != 6656) {
#line 24912
    gl_error(ctx, 1282, "glDrawBuffer");
#line 24913
    return;
  }
#line 24915
  switch (mode) {
  case 1028: 
  case 1024: 
  case 1032: 
#line 24919
  tmp___0 = (*(ctx->Driver.SetBuffer))(ctx, 1028);
#line 24919
  if ((int )tmp___0 == 0) {
#line 24920
    gl_error(ctx, 1280, "glDrawBuffer");
#line 24921
    return;
  }
#line 24923
  ctx->Color.DrawBuffer = mode;
#line 24924
  (ctx->Buffer)->Alpha = (ctx->Buffer)->FrontAlpha;
#line 24925
  ctx->NewState |= 2U;
#line 24926
  break;
  case 1029: 
  case 1026: 
#line 24929
  tmp___1 = (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 24929
  if ((int )tmp___1 == 0) {
#line 24930
    gl_error(ctx, 1280, "glDrawBuffer");
#line 24931
    return;
  }
#line 24933
  ctx->Color.DrawBuffer = mode;
#line 24934
  (ctx->Buffer)->Alpha = (ctx->Buffer)->BackAlpha;
#line 24935
  ctx->NewState |= 2U;
#line 24936
  break;
  case 0: 
#line 24938
  ctx->Color.DrawBuffer = mode;
#line 24939
  (ctx->Buffer)->Alpha = (GLubyte *)((void *)0);
#line 24940
  ctx->NewState |= 2U;
#line 24941
  break;
  case 1025: 
  case 1027: 
  case 1030: 
  case 1031: 
  case 1033: 
#line 24947
  gl_error(ctx, 1282, "glDrawBuffer");
#line 24948
  break;
  default: 
#line 24950
  gl_error(ctx, 1280, "glDrawBuffer");
  }
#line 24952
  return;
}
}
#line 24953 "D:/a/test/177.c"
void gl_ReadBuffer(GLcontext *ctx , GLenum mode ) 
{ GLboolean tmp___0 ;
  GLboolean tmp___1 ;

  {
#line 24955
  if (ctx->Primitive != 6656) {
#line 24956
    gl_error(ctx, 1282, "glReadBuffer");
#line 24957
    return;
  }
#line 24959
  switch (mode) {
  case 1028: 
  case 1024: 
#line 24962
  tmp___0 = (*(ctx->Driver.SetBuffer))(ctx, 1028);
#line 24962
  if ((int )tmp___0 == 0) {
#line 24963
    gl_error(ctx, 1280, "glReadBuffer");
#line 24964
    return;
  }
#line 24966
  ctx->Pixel.ReadBuffer = mode;
#line 24967
  (ctx->Buffer)->Alpha = (ctx->Buffer)->FrontAlpha;
#line 24968
  ctx->NewState |= 2U;
#line 24969
  break;
  case 1029: 
  case 1026: 
#line 24972
  tmp___1 = (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 24972
  if ((int )tmp___1 == 0) {
#line 24973
    gl_error(ctx, 1280, "glReadBuffer");
#line 24974
    return;
  }
#line 24976
  ctx->Pixel.ReadBuffer = mode;
#line 24977
  (ctx->Buffer)->Alpha = (ctx->Buffer)->BackAlpha;
#line 24978
  ctx->NewState |= 2U;
#line 24979
  break;
  case 1025: 
  case 1027: 
  case 1030: 
  case 1031: 
  case 1033: 
#line 24985
  gl_error(ctx, 1282, "glReadBuffer");
#line 24986
  break;
  default: 
#line 24988
  gl_error(ctx, 1280, "glReadBuffer");
  }
#line 24990
  (*(ctx->Driver.SetBuffer))(ctx, ctx->Color.DrawBuffer);
#line 24991
  return;
}
}
#line 24998 "D:/a/test/177.c"
static void init_sqrt(void) 
{ 

  {
#line 25015
  return;
}
}
#line 25016 "D:/a/test/177.c"
float gl_sqrt(float x ) 
{ double tmp___0 ;

  {
#line 25029
  tmp___0 = sqrt((double )x);
#line 25029
  return ((float )tmp___0);
}
}
#line 25034
void gl_init_math(void) ;
#line 25034 "D:/a/test/177.c"
static GLboolean initialized  =    (GLboolean )0;
#line 25032 "D:/a/test/177.c"
void gl_init_math(void) 
{ 

  {
#line 25035
  if (! initialized) {
#line 25036
    init_sqrt();
#line 25037
    initialized = (unsigned char)1;
  }
#line 25039
  return;
}
}
#line 25048 "D:/a/test/177.c"
static OSMesaContext Current  =    (OSMesaContext )((void *)0);
#line 25050
static void osmesa_setup_DD_pointers(GLcontext *ctx ) ;
#line 25051 "D:/a/test/177.c"
OSMesaContext OSMesaCreateContext(GLenum format , OSMesaContext sharelist ) 
{ OSMesaContext osmesa ;
  float rscale ;
  float gscale ;
  float bscale ;
  float ascale ;
  GLint rshift ;
  GLint gshift ;
  GLint bshift ;
  GLint ashift ;
  GLint rind ;
  GLint gind ;
  GLint bind ;
  GLint index_bits ;
  GLboolean rgbmode ;
  GLboolean swalpha ;
  GLuint i4 ;
  GLubyte *i1 ;
  GLint little_endian ;
  void *tmp___0 ;
  GLcontext *tmp___1 ;

  {
#line 25060
  i4 = (GLuint )1;
#line 25061
  i1 = (GLubyte *)(& i4);
#line 25062
  little_endian = (GLint )*i1;
#line 25063
  swalpha = (unsigned char)0;
#line 25064
  bind = 0;
#line 25064
  gind = bind;
#line 25064
  rind = gind;
#line 25065
  if (format == 6400) {
#line 25066
    ascale = (float )0.0;
#line 25066
    bscale = ascale;
#line 25066
    gscale = bscale;
#line 25066
    rscale = gscale;
#line 25067
    index_bits = 8;
#line 25068
    ashift = 0;
#line 25068
    bshift = ashift;
#line 25068
    gshift = bshift;
#line 25068
    rshift = gshift;
#line 25069
    rgbmode = (unsigned char)0;
  } else {
#line 25071
    if (format == 6408) {
#line 25072
      ascale = (float )255.0;
#line 25072
      bscale = ascale;
#line 25072
      gscale = bscale;
#line 25072
      rscale = gscale;
#line 25073
      index_bits = 0;
#line 25074
      if (little_endian) {
#line 25075
        rshift = 0;
#line 25076
        gshift = 8;
#line 25077
        bshift = 16;
#line 25078
        ashift = 24;
      } else {
#line 25081
        rshift = 24;
#line 25082
        gshift = 16;
#line 25083
        bshift = 8;
#line 25084
        ashift = 0;
      }
#line 25086
      rgbmode = (unsigned char)1;
    } else {
#line 25088
      if (format == 1) {
#line 25089
        ascale = (float )255.0;
#line 25089
        bscale = ascale;
#line 25089
        gscale = bscale;
#line 25089
        rscale = gscale;
#line 25090
        index_bits = 0;
#line 25091
        if (little_endian) {
#line 25092
          ashift = 0;
#line 25093
          rshift = 8;
#line 25094
          gshift = 16;
#line 25095
          bshift = 24;
        } else {
#line 25098
          bshift = 24;
#line 25099
          gshift = 16;
#line 25100
          rshift = 8;
#line 25101
          ashift = 0;
        }
#line 25103
        rgbmode = (unsigned char)1;
      } else {
#line 25105
        if (format == 2) {
#line 25106
          ascale = (float )255.0;
#line 25106
          bscale = ascale;
#line 25106
          gscale = bscale;
#line 25106
          rscale = gscale;
#line 25107
          index_bits = 0;
#line 25108
          if (little_endian) {
#line 25109
            bshift = 0;
#line 25110
            gshift = 8;
#line 25111
            rshift = 16;
#line 25112
            ashift = 24;
          } else {
#line 25115
            ashift = 24;
#line 25116
            rshift = 16;
#line 25117
            gshift = 8;
#line 25118
            bshift = 0;
          }
#line 25120
          rgbmode = (unsigned char)1;
        } else {
#line 25122
          if (format == 6407) {
#line 25123
            ascale = (float )255.0;
#line 25123
            bscale = ascale;
#line 25123
            gscale = bscale;
#line 25123
            rscale = gscale;
#line 25124
            index_bits = 0;
#line 25125
            bshift = 0;
#line 25126
            gshift = 8;
#line 25127
            rshift = 16;
#line 25128
            ashift = 24;
#line 25129
            bind = 2;
#line 25130
            gind = 1;
#line 25131
            rind = 0;
#line 25132
            rgbmode = (unsigned char)1;
#line 25133
            swalpha = (unsigned char)1;
          } else {
#line 25135
            if (format == 4) {
#line 25136
              ascale = (float )255.0;
#line 25136
              bscale = ascale;
#line 25136
              gscale = bscale;
#line 25136
              rscale = gscale;
#line 25137
              index_bits = 0;
#line 25138
              bshift = 0;
#line 25139
              gshift = 8;
#line 25140
              rshift = 16;
#line 25141
              ashift = 24;
#line 25142
              bind = 0;
#line 25143
              gind = 1;
#line 25144
              rind = 2;
#line 25145
              rgbmode = (unsigned char)1;
#line 25146
              swalpha = (unsigned char)1;
            } else {
#line 25149
              return ((struct osmesa_context *)((void *)0));
            }
          }
        }
      }
    }
  }
#line 25151
  tmp___0 = calloc(1U, sizeof(struct osmesa_context ));
#line 25151
  osmesa = (struct osmesa_context *)tmp___0;
#line 25152
  if (osmesa) {
#line 25153
    osmesa->gl_visual = gl_create_visual(rgbmode, swalpha, (unsigned char)0, 16, 8,
                                         16, index_bits, rscale, gscale, bscale, ascale,
                                         8, 8, 8, 0);
#line 25162
    if (! osmesa->gl_visual) {
#line 25163
      if(osmesa!=0){
	    goto ERROR;
		ERROR:exit(0);
	  }
      return ((struct osmesa_context *)((void *)0));
    }
#line 25165
    if (sharelist) {
#line 25165
      tmp___1 = sharelist->gl_ctx;
    } else {
#line 25165
      tmp___1 = (GLcontext *)((void *)0);
    }
#line 25165
    osmesa->gl_ctx = gl_create_context(osmesa->gl_visual, tmp___1, (void *)osmesa);
#line 25168
    if (! osmesa->gl_ctx) {
#line 25169
      gl_destroy_visual(osmesa->gl_visual);
#line 25170
      free((void *)osmesa);
#line 25171
      return ((struct osmesa_context *)((void *)0));
    }
#line 25173
    osmesa->gl_buffer = gl_create_framebuffer(osmesa->gl_visual);
#line 25174
    if (! osmesa->gl_buffer) {
#line 25175
      gl_destroy_visual(osmesa->gl_visual);
#line 25176
      gl_destroy_context(osmesa->gl_ctx);
#line 25177
      free((void *)osmesa);
#line 25178
      return ((struct osmesa_context *)((void *)0));
    }
#line 25180
    osmesa->format = format;
#line 25181
    osmesa->buffer = (void *)0;
#line 25182
    osmesa->width = 0;
#line 25183
    osmesa->height = 0;
#line 25184
    osmesa->pixel = 0U;
#line 25185
    osmesa->clearpixel = 0U;
#line 25186
    osmesa->userRowLength = 0;
#line 25187
    osmesa->rowlength = 0;
#line 25188
    osmesa->yup = (unsigned char)1;
#line 25189
    osmesa->rshift = rshift;
#line 25190
    osmesa->gshift = gshift;
#line 25191
    osmesa->bshift = bshift;
#line 25192
    osmesa->ashift = ashift;
#line 25193
    osmesa->rind = rind;
#line 25194
    osmesa->gind = gind;
#line 25195
    osmesa->bind = bind;
  }
#line 25197
  return (osmesa);
}
}
#line 25199 "D:/a/test/177.c"
void OSMesaDestroyContext(OSMesaContext ctx ) 
{ 

  {
#line 25201
  if (ctx) {
#line 25202
    gl_destroy_visual(ctx->gl_visual);
#line 25203
    gl_destroy_framebuffer(ctx->gl_buffer);
#line 25204
    gl_destroy_context(ctx->gl_ctx);
#line 25205
    free((void *)ctx);
  }
#line 25207
  return;
}
}
#line 25208 "D:/a/test/177.c"
static void compute_row_addresses(OSMesaContext ctx ) 
{ GLint i ;
  GLubyte *origin ;
  GLubyte *origin___0 ;
  GLuint *origin___1 ;
  GLubyte *origin___2 ;
  GLubyte *origin___3 ;
  GLuint *origin___4 ;

  {
#line 25211
  if (ctx->yup) {
#line 25212
    if (ctx->format == 6400) {
#line 25213
      origin = (GLubyte *)ctx->buffer;
#line 25214
      i = 0;
#line 25214
      while (i < 400) {
#line 25215
        ctx->rowaddr[i] = (void *)(origin + i * ctx->rowlength);
#line 25214
        i ++;
      }
    } else {
#line 25219
      if (ctx->format == 6407) {
        goto _L;
      } else {
#line 25219
        if (ctx->format == 4) {
          _L: /* CIL Label */ 
#line 25220
          origin___0 = (GLubyte *)ctx->buffer;
#line 25221
          i = 0;
#line 25221
          while (i < 400) {
#line 25222
            ctx->rowaddr[i] = (void *)(origin___0 + i * (ctx->rowlength * 3));
#line 25221
            i ++;
          }
        } else {
#line 25225
          origin___1 = (GLuint *)ctx->buffer;
#line 25226
          i = 0;
#line 25226
          while (i < 400) {
#line 25227
            ctx->rowaddr[i] = (void *)(origin___1 + i * ctx->rowlength);
#line 25226
            i ++;
          }
        }
      }
    }
  } else {
#line 25233
    if (ctx->format == 6400) {
#line 25234
      origin___2 = (GLubyte *)ctx->buffer;
#line 25235
      i = 0;
#line 25235
      while (i < 400) {
#line 25236
        ctx->rowaddr[i] = (void *)(origin___2 + ((ctx->height - i) - 1) * ctx->rowlength);
#line 25235
        i ++;
      }
    } else {
#line 25240
      if (ctx->format == 6407) {
        goto _L___0;
      } else {
#line 25240
        if (ctx->format == 4) {
          _L___0: /* CIL Label */ 
#line 25241
          origin___3 = (GLubyte *)ctx->buffer;
#line 25242
          i = 0;
#line 25242
          while (i < 400) {
#line 25243
            ctx->rowaddr[i] = (void *)(origin___3 + ((ctx->height - i) - 1) * (ctx->rowlength * 3));
#line 25242
            i ++;
          }
        } else {
#line 25246
          origin___4 = (GLuint *)ctx->buffer;
#line 25247
          i = 0;
#line 25247
          while (i < 400) {
#line 25248
            ctx->rowaddr[i] = (void *)(origin___4 + ((ctx->height - i) - 1) * ctx->rowlength);
#line 25247
            i ++;
          }
        }
      }
    }
  }
#line 25253
  return;
}
}
#line 25254 "D:/a/test/177.c"
GLboolean OSMesaMakeCurrent(OSMesaContext ctx , void *buffer , GLenum type , GLsizei width ,
                            GLsizei height ) 
{ 

  {
#line 25257
  if (! ctx) {
#line 25259
    return ((unsigned char)0);
  } else {
#line 25257
    if (! buffer) {
#line 25259
      return ((unsigned char)0);
    } else {
#line 25257
      if (type != 5121) {
#line 25259
        return ((unsigned char)0);
      } else {
#line 25257
        if (width < 1) {
#line 25259
          return ((unsigned char)0);
        } else {
#line 25257
          if (height < 1) {
#line 25259
            return ((unsigned char)0);
          } else {
#line 25257
            if (width > 640) {
#line 25259
              return ((unsigned char)0);
            } else {
#line 25257
              if (height > 400) {
#line 25259
                return ((unsigned char)0);
              }
            }
          }
        }
      }
    }
  }
#line 25261
  gl_make_current(ctx->gl_ctx, ctx->gl_buffer);
#line 25262
  ctx->buffer = buffer;
#line 25263
  ctx->width = width;
#line 25264
  ctx->height = height;
#line 25265
  if (ctx->userRowLength) {
#line 25266
    ctx->rowlength = ctx->userRowLength;
  } else {
#line 25268
    ctx->rowlength = width;
  }
#line 25269
  osmesa_setup_DD_pointers(ctx->gl_ctx);
#line 25272
  Current = ctx;
#line 25274
  compute_row_addresses(ctx);
#line 25275
  if ((ctx->gl_ctx)->Viewport.Width == 0) {
#line 25276
    gl_Viewport(ctx->gl_ctx, 0, 0, width, height);
#line 25277
    (ctx->gl_ctx)->Scissor.Width = width;
#line 25278
    (ctx->gl_ctx)->Scissor.Height = height;
  }
#line 25280
  return ((unsigned char)1);
}
}
#line 25282 "D:/a/test/177.c"
OSMesaContext OSMesaGetCurrentContext(void) 
{ 

  {
#line 25286
  return (Current);
}
}
#line 25289 "D:/a/test/177.c"
void OSMesaPixelStore(GLint pname , GLint value ) 
{ OSMesaContext ctx ;
  OSMesaContext tmp___0 ;

  {
#line 25291
  tmp___0 = OSMesaGetCurrentContext();
#line 25291
  ctx = tmp___0;
#line 25292
  switch (pname) {
  case 16: 
#line 25294
  if (value < 0) {
#line 25295
    gl_error(ctx->gl_ctx, 1281, "OSMesaPixelStore(value)");
#line 25297
    return;
  }
#line 25299
  ctx->userRowLength = value;
#line 25300
  ctx->rowlength = value;
#line 25301
  break;
  case 17: 
#line 25303
  if (value) {
#line 25303
    ctx->yup = (unsigned char)1;
  } else {
#line 25303
    ctx->yup = (unsigned char)0;
  }
#line 25304
  break;
  default: 
#line 25306
  gl_error(ctx->gl_ctx, 1280, "OSMesaPixelStore(pname)");
#line 25307
  return;
  }
#line 25309
  compute_row_addresses(ctx);
#line 25310
  return;
}
}
#line 25311 "D:/a/test/177.c"
void OSMesaGetIntegerv(GLint pname , GLint *value ) 
{ OSMesaContext ctx ;
  OSMesaContext tmp___0 ;

  {
#line 25313
  tmp___0 = OSMesaGetCurrentContext();
#line 25313
  ctx = tmp___0;
#line 25314
  switch (pname) {
  case 32: 
#line 25316
  *value = ctx->width;
#line 25317
  return;
  case 33: 
#line 25319
  *value = ctx->height;
#line 25320
  return;
  case 34: 
#line 25322
  *value = ctx->format;
#line 25323
  return;
  case 35: 
#line 25325
  *value = 5121;
#line 25326
  return;
  case 16: 
#line 25328
  *value = ctx->rowlength;
#line 25329
  return;
  case 17: 
#line 25331
  *value = (int )ctx->yup;
#line 25332
  return;
  default: 
#line 25334
  gl_error(ctx->gl_ctx, 1280, "OSMesaGetIntergerv(pname)");
#line 25335
  return;
  }
}
}
#line 25338 "D:/a/test/177.c"
GLboolean OSMesaGetDepthBuffer(OSMesaContext c , GLint *width , GLint *height , GLint *bytesPerValue ,
                               void **buffer ) 
{ 

  {
#line 25341
  if (! c->gl_buffer) {
#line 25342
    *width = 0;
#line 25343
    *height = 0;
#line 25344
    *bytesPerValue = 0;
#line 25345
    *buffer = (void *)0;
#line 25346
    return ((unsigned char)0);
  } else {
#line 25341
    if (! (c->gl_buffer)->Depth) {
#line 25342
      *width = 0;
#line 25343
      *height = 0;
#line 25344
      *bytesPerValue = 0;
#line 25345
      *buffer = (void *)0;
#line 25346
      return ((unsigned char)0);
    } else {
#line 25349
      *width = (c->gl_buffer)->Width;
#line 25350
      *height = (c->gl_buffer)->Height;
#line 25351
      *bytesPerValue = (int )sizeof(GLdepth );
#line 25352
      *buffer = (void *)(c->gl_buffer)->Depth;
#line 25353
      return ((unsigned char)1);
    }
  }
}
}
#line 25371 "D:/a/test/177.c"
static GLboolean set_buffer(GLcontext *ctx , GLenum mode ) 
{ 

  {
#line 25373
  if (mode == 1028) {
#line 25374
    return ((unsigned char)1);
  } else {
#line 25377
    return ((unsigned char)0);
  }
}
}
#line 25380 "D:/a/test/177.c"
static void clear_index(GLcontext *ctx , GLuint index___0 ) 
{ OSMesaContext osmesa ;

  {
#line 25382
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25383
  osmesa->clearpixel = index___0;
#line 25384
  return;
}
}
#line 25385 "D:/a/test/177.c"
static void clear_color(GLcontext *ctx , GLubyte r , GLubyte g , GLubyte b , GLubyte a ) 
{ OSMesaContext osmesa ;

  {
#line 25388
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25389
  osmesa->clearpixel = (unsigned int )(((((int )r << osmesa->rshift) | ((int )g << osmesa->gshift)) | ((int )b << osmesa->bshift)) | ((int )a << osmesa->ashift));
#line 25390
  return;
}
}
#line 25391 "D:/a/test/177.c"
static void clear(GLcontext *ctx , GLboolean all , GLint x , GLint y , GLint width ,
                  GLint height ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLuint j ;
  GLubyte *ptr1 ;
  GLubyte *tmp___0 ;
  GLubyte rval ;
  GLubyte gval ;
  GLubyte bval ;
  GLint rind ;
  GLint gind ;
  GLint bind ;
  GLuint i___0 ;
  GLuint n ;
  GLubyte *ptr3 ;
  GLuint i___1 ;
  GLuint j___0 ;
  GLubyte *ptr3___0 ;
  GLuint i___2 ;
  GLuint n___0 ;
  GLuint *ptr4 ;
  GLuint *tmp___1 ;
  GLuint i___3 ;
  GLuint j___1 ;
  GLuint *ptr4___0 ;
  GLuint *tmp___2 ;

  {
#line 25394
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25395
  if (osmesa->format == 6400) {
#line 25396
    if (all) {
#line 25397
      memset(osmesa->buffer, (int )osmesa->clearpixel, (unsigned int )(osmesa->rowlength * osmesa->height));
    } else {
#line 25401
      i = 0U;
#line 25401
      while (i < (GLuint )height) {
#line 25402
        ptr1 = (GLubyte *)osmesa->rowaddr[(GLuint )y + i] + x;
#line 25403
        j = 0U;
#line 25403
        while (j < (GLuint )width) {
#line 25404
          tmp___0 = ptr1;
#line 25404
          ptr1 ++;
#line 25404
          *tmp___0 = (unsigned char )osmesa->clearpixel;
#line 25403
          j ++;
        }
#line 25401
        i ++;
      }
    }
  } else {
#line 25409
    if (osmesa->format == 6407) {
      goto _L;
    } else {
#line 25409
      if (osmesa->format == 4) {
        _L: /* CIL Label */ 
#line 25410
        rval = (GLubyte )((osmesa->clearpixel >> osmesa->rshift) & 255U);
#line 25411
        gval = (GLubyte )((osmesa->clearpixel >> osmesa->gshift) & 255U);
#line 25412
        bval = (GLubyte )((osmesa->clearpixel >> osmesa->bshift) & 255U);
#line 25413
        rind = osmesa->rind;
#line 25414
        gind = osmesa->gind;
#line 25415
        bind = osmesa->bind;
#line 25416
        if (all) {
#line 25418
          ptr3 = (GLubyte *)osmesa->buffer;
#line 25419
          n = (unsigned int )(osmesa->rowlength * osmesa->height);
#line 25420
          i___0 = 0U;
#line 25420
          while (i___0 < n) {
#line 25421
            *(ptr3 + rind) = rval;
#line 25422
            *(ptr3 + gind) = gval;
#line 25423
            *(ptr3 + bind) = bval;
#line 25424
            ptr3 += 3;
#line 25420
            i___0 ++;
          }
        } else {
#line 25429
          i___1 = 0U;
#line 25429
          while (i___1 < (GLuint )height) {
#line 25430
            ptr3___0 = (GLubyte *)osmesa->rowaddr[(GLuint )y + i___1] + x * 3;
#line 25431
            j___0 = 0U;
#line 25431
            while (j___0 < (GLuint )width) {
#line 25432
              *(ptr3___0 + rind) = rval;
#line 25433
              *(ptr3___0 + gind) = gval;
#line 25434
              *(ptr3___0 + bind) = bval;
#line 25435
              ptr3___0 += 3;
#line 25431
              j___0 ++;
            }
#line 25429
            i___1 ++;
          }
        }
      } else {
#line 25441
        if (all) {
#line 25443
          n___0 = (unsigned int )(osmesa->rowlength * osmesa->height);
#line 25444
          ptr4 = (GLuint *)osmesa->buffer;
#line 25445
          i___2 = 0U;
#line 25445
          while (i___2 < n___0) {
#line 25446
            tmp___1 = ptr4;
#line 25446
            ptr4 ++;
#line 25446
            *tmp___1 = osmesa->clearpixel;
#line 25445
            i___2 ++;
          }
        } else {
#line 25451
          i___3 = 0U;
#line 25451
          while (i___3 < (GLuint )height) {
#line 25452
            ptr4___0 = (GLuint *)osmesa->rowaddr[(GLuint )y + i___3] + x;
#line 25453
            j___1 = 0U;
#line 25453
            while (j___1 < (GLuint )width) {
#line 25454
              tmp___2 = ptr4___0;
#line 25454
              ptr4___0 ++;
#line 25454
              *tmp___2 = osmesa->clearpixel;
#line 25453
              j___1 ++;
            }
#line 25451
            i___3 ++;
          }
        }
      }
    }
  }
#line 25459
  return;
}
}
#line 25460 "D:/a/test/177.c"
static void set_index(GLcontext *ctx , GLuint index___0 ) 
{ OSMesaContext osmesa ;

  {
#line 25462
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25463
  osmesa->pixel = index___0;
#line 25464
  return;
}
}
#line 25465 "D:/a/test/177.c"
static void set_color(GLcontext *ctx , GLubyte r , GLubyte g , GLubyte b , GLubyte a ) 
{ OSMesaContext osmesa ;

  {
#line 25468
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25469
  osmesa->pixel = (unsigned int )(((((int )r << osmesa->rshift) | ((int )g << osmesa->gshift)) | ((int )b << osmesa->bshift)) | ((int )a << osmesa->ashift));
#line 25470
  return;
}
}
#line 25471 "D:/a/test/177.c"
static void buffer_size(GLcontext *ctx , GLuint *width , GLuint *height ) 
{ OSMesaContext osmesa ;

  {
#line 25473
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25474
  *width = (unsigned int )osmesa->width;
#line 25475
  *height = (unsigned int )osmesa->height;
#line 25476
  return;
}
}
#line 25477 "D:/a/test/177.c"
static void write_color_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte const   *red ,
                             GLubyte const   *green , GLubyte const   *blue___0 ,
                             GLubyte const   *alpha , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLuint *ptr4 ;
  GLuint i ;
  GLint rshift ;
  GLint gshift ;
  GLint bshift ;
  GLint ashift ;

  {
#line 25483
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25484
  ptr4 = (GLuint *)osmesa->rowaddr[y] + x;
#line 25486
  rshift = osmesa->rshift;
#line 25487
  gshift = osmesa->gshift;
#line 25488
  bshift = osmesa->bshift;
#line 25489
  ashift = osmesa->ashift;
#line 25490
  if (mask) {
#line 25491
    i = 0U;
#line 25491
    while (i < n) {
#line 25492
      if (*(mask + i)) {
#line 25493
        *ptr4 = (unsigned int )(((((int const   )*(red + i) << rshift) | ((int const   )*(green + i) << gshift)) | ((int const   )*(blue___0 + i) << bshift)) | ((int const   )*(alpha + i) << ashift));
      }
#line 25491
      i ++;
#line 25491
      ptr4 ++;
    }
  } else {
#line 25498
    i = 0U;
#line 25498
    while (i < n) {
#line 25499
      *ptr4 = (unsigned int )(((((int const   )*(red + i) << rshift) | ((int const   )*(green + i) << gshift)) | ((int const   )*(blue___0 + i) << bshift)) | ((int const   )*(alpha + i) << ashift));
#line 25498
      i ++;
#line 25498
      ptr4 ++;
    }
  }
#line 25502
  return;
}
}
#line 25503 "D:/a/test/177.c"
static void write_monocolor_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLuint *ptr4 ;
  GLuint i ;

  {
#line 25507
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25508
  ptr4 = (GLuint *)osmesa->rowaddr[y] + x;
#line 25510
  i = 0U;
#line 25510
  while (i < n) {
#line 25511
    if (*(mask + i)) {
#line 25512
      *ptr4 = osmesa->pixel;
    }
#line 25510
    i ++;
#line 25510
    ptr4 ++;
  }
#line 25515
  return;
}
}
#line 25516 "D:/a/test/177.c"
static void write_color_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                               GLubyte const   *red , GLubyte const   *green , GLubyte const   *blue___0 ,
                               GLubyte const   *alpha , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLint rshift ;
  GLint gshift ;
  GLint bshift ;
  GLint ashift ;
  GLuint *ptr4 ;

  {
#line 25522
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25524
  rshift = osmesa->rshift;
#line 25525
  gshift = osmesa->gshift;
#line 25526
  bshift = osmesa->bshift;
#line 25527
  ashift = osmesa->ashift;
#line 25528
  i = 0U;
#line 25528
  while (i < n) {
#line 25529
    if (*(mask + i)) {
#line 25530
      ptr4 = (GLuint *)osmesa->rowaddr[*(y + i)] + *(x + i);
#line 25531
      *ptr4 = (unsigned int )(((((int const   )*(red + i) << rshift) | ((int const   )*(green + i) << gshift)) | ((int const   )*(blue___0 + i) << bshift)) | ((int const   )*(alpha + i) << ashift));
    }
#line 25528
    i ++;
  }
#line 25534
  return;
}
}
#line 25535 "D:/a/test/177.c"
static void write_monocolor_pixels(GLcontext *ctx , GLuint n , GLint const   *x ,
                                   GLint const   *y , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLuint *ptr4 ;

  {
#line 25539
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25541
  i = 0U;
#line 25541
  while (i < n) {
#line 25542
    if (*(mask + i)) {
#line 25543
      ptr4 = (GLuint *)osmesa->rowaddr[*(y + i)] + *(x + i);
#line 25544
      *ptr4 = osmesa->pixel;
    }
#line 25541
    i ++;
  }
#line 25547
  return;
}
}
#line 25548 "D:/a/test/177.c"
static void write_index_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLuint const   *index___0 ,
                             GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLubyte *ptr1 ;
  GLuint i ;

  {
#line 25552
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25553
  ptr1 = (GLubyte *)osmesa->rowaddr[y] + x;
#line 25555
  i = 0U;
#line 25555
  while (i < n) {
#line 25556
    if (*(mask + i)) {
#line 25557
      *ptr1 = (unsigned char )*(index___0 + i);
    }
#line 25555
    i ++;
#line 25555
    ptr1 ++;
  }
#line 25560
  return;
}
}
#line 25561 "D:/a/test/177.c"
static void write_monoindex_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLubyte *ptr1 ;
  GLuint i ;

  {
#line 25565
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25566
  ptr1 = (GLubyte *)osmesa->rowaddr[y] + x;
#line 25568
  i = 0U;
#line 25568
  while (i < n) {
#line 25569
    if (*(mask + i)) {
#line 25570
      *ptr1 = (unsigned char )osmesa->pixel;
    }
#line 25568
    i ++;
#line 25568
    ptr1 ++;
  }
#line 25573
  return;
}
}
#line 25574 "D:/a/test/177.c"
static void write_index_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                               GLuint const   *index___0 , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLubyte *ptr1 ;

  {
#line 25578
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25580
  i = 0U;
#line 25580
  while (i < n) {
#line 25581
    if (*(mask + i)) {
#line 25582
      ptr1 = (GLubyte *)osmesa->rowaddr[*(y + i)] + *(x + i);
#line 25583
      *ptr1 = (unsigned char )*(index___0 + i);
    }
#line 25580
    i ++;
  }
#line 25586
  return;
}
}
#line 25587 "D:/a/test/177.c"
static void write_monoindex_pixels(GLcontext *ctx , GLuint n , GLint const   *x ,
                                   GLint const   *y , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLubyte *ptr1 ;

  {
#line 25591
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25593
  i = 0U;
#line 25593
  while (i < n) {
#line 25594
    if (*(mask + i)) {
#line 25595
      ptr1 = (GLubyte *)osmesa->rowaddr[*(y + i)] + *(x + i);
#line 25596
      *ptr1 = (unsigned char )osmesa->pixel;
    }
#line 25593
    i ++;
  }
#line 25599
  return;
}
}
#line 25600 "D:/a/test/177.c"
static void read_index_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLuint *index___0 ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLubyte *ptr1 ;

  {
#line 25603
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25605
  ptr1 = (GLubyte *)osmesa->rowaddr[y] + x;
#line 25606
  i = 0U;
#line 25606
  while (i < n) {
#line 25607
    *(index___0 + i) = (unsigned int )*ptr1;
#line 25606
    i ++;
#line 25606
    ptr1 ++;
  }
#line 25609
  return;
}
}
#line 25610 "D:/a/test/177.c"
static void read_color_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *red ,
                            GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLuint *ptr4 ;
  GLuint pixel ;
  GLuint *tmp___0 ;

  {
#line 25615
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25617
  ptr4 = (GLuint *)osmesa->rowaddr[y] + x;
#line 25618
  i = 0U;
#line 25618
  while (i < n) {
#line 25619
    tmp___0 = ptr4;
#line 25619
    ptr4 ++;
#line 25619
    pixel = *tmp___0;
#line 25620
    *(red + i) = (unsigned char )((pixel >> osmesa->rshift) & 255U);
#line 25621
    *(green + i) = (unsigned char )((pixel >> osmesa->gshift) & 255U);
#line 25622
    *(blue___0 + i) = (unsigned char )((pixel >> osmesa->bshift) & 255U);
#line 25623
    *(alpha + i) = (unsigned char )((pixel >> osmesa->ashift) & 255U);
#line 25618
    i ++;
  }
#line 25625
  return;
}
}
#line 25626 "D:/a/test/177.c"
static void read_index_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                              GLuint *index___0 , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLubyte *ptr1 ;

  {
#line 25630
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25632
  i = 0U;
#line 25632
  while (i < n) {
#line 25633
    if (*(mask + i)) {
#line 25634
      ptr1 = (GLubyte *)osmesa->rowaddr[*(y + i)] + *(x + i);
#line 25635
      *(index___0 + i) = (unsigned int )*ptr1;
    }
#line 25632
    i ++;
  }
#line 25638
  return;
}
}
#line 25639 "D:/a/test/177.c"
static void read_color_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                              GLubyte *red , GLubyte *green , GLubyte *blue___0 ,
                              GLubyte *alpha , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLuint *ptr4 ;
  GLuint pixel ;

  {
#line 25645
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25647
  i = 0U;
#line 25647
  while (i < n) {
#line 25648
    if (*(mask + i)) {
#line 25649
      ptr4 = (GLuint *)osmesa->rowaddr[*(y + i)] + *(x + i);
#line 25650
      pixel = *ptr4;
#line 25651
      *(red + i) = (unsigned char )((pixel >> osmesa->rshift) & 255U);
#line 25652
      *(green + i) = (unsigned char )((pixel >> osmesa->gshift) & 255U);
#line 25653
      *(blue___0 + i) = (unsigned char )((pixel >> osmesa->bshift) & 255U);
#line 25654
      *(alpha + i) = (unsigned char )((pixel >> osmesa->ashift) & 255U);
    }
#line 25647
    i ++;
  }
#line 25657
  return;
}
}
#line 25658 "D:/a/test/177.c"
static void write_color_span3(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte const   *red ,
                              GLubyte const   *green , GLubyte const   *blue___0 ,
                              GLubyte const   *alpha , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLubyte *ptr3 ;
  GLuint i ;
  GLint rind ;
  GLint gind ;
  GLint bind ;

  {
#line 25664
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25665
  ptr3 = (GLubyte *)osmesa->rowaddr[y] + x * 3;
#line 25667
  rind = osmesa->rind;
#line 25668
  gind = osmesa->gind;
#line 25669
  bind = osmesa->bind;
#line 25670
  if (mask) {
#line 25671
    i = 0U;
#line 25671
    while (i < n) {
#line 25672
      if (*(mask + i)) {
#line 25673
        *(ptr3 + rind) = (unsigned char )*(red + i);
#line 25674
        *(ptr3 + gind) = (unsigned char )*(green + i);
#line 25675
        *(ptr3 + bind) = (unsigned char )*(blue___0 + i);
      }
#line 25671
      i ++;
#line 25671
      ptr3 += 3;
    }
  } else {
#line 25680
    i = 0U;
#line 25680
    while (i < n) {
#line 25681
      *(ptr3 + rind) = (unsigned char )*(red + i);
#line 25682
      *(ptr3 + gind) = (unsigned char )*(green + i);
#line 25683
      *(ptr3 + bind) = (unsigned char )*(blue___0 + i);
#line 25680
      i ++;
#line 25680
      ptr3 += 3;
    }
  }
#line 25686
  return;
}
}
#line 25687 "D:/a/test/177.c"
static void write_monocolor_span3(GLcontext *ctx , GLuint n , GLint x , GLint y ,
                                  GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLubyte rval ;
  GLubyte gval ;
  GLubyte bval ;
  GLint rind ;
  GLint gind ;
  GLint bind ;
  GLubyte *ptr3 ;
  GLuint i ;

  {
#line 25691
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25692
  rval = (GLubyte )((osmesa->pixel >> osmesa->rshift) & 255U);
#line 25693
  gval = (GLubyte )((osmesa->pixel >> osmesa->gshift) & 255U);
#line 25694
  bval = (GLubyte )((osmesa->pixel >> osmesa->bshift) & 255U);
#line 25695
  rind = osmesa->rind;
#line 25696
  gind = osmesa->gind;
#line 25697
  bind = osmesa->bind;
#line 25698
  ptr3 = (GLubyte *)osmesa->rowaddr[y] + x * 3;
#line 25700
  i = 0U;
#line 25700
  while (i < n) {
#line 25701
    if (*(mask + i)) {
#line 25702
      *(ptr3 + rind) = rval;
#line 25703
      *(ptr3 + gind) = gval;
#line 25704
      *(ptr3 + bind) = bval;
    }
#line 25700
    i ++;
#line 25700
    ptr3 += 3;
  }
#line 25707
  return;
}
}
#line 25708 "D:/a/test/177.c"
static void write_color_pixels3(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                                GLubyte const   *red , GLubyte const   *green , GLubyte const   *blue___0 ,
                                GLubyte const   *alpha , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLint rind ;
  GLint gind ;
  GLint bind ;
  GLubyte *ptr3 ;

  {
#line 25714
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25716
  rind = osmesa->rind;
#line 25717
  gind = osmesa->gind;
#line 25718
  bind = osmesa->bind;
#line 25719
  i = 0U;
#line 25719
  while (i < n) {
#line 25720
    if (*(mask + i)) {
#line 25721
      ptr3 = (GLubyte *)osmesa->rowaddr[*(y + i)] + *(x + i) * 3;
#line 25722
      *(ptr3 + rind) = (unsigned char )*(red + i);
#line 25723
      *(ptr3 + gind) = (unsigned char )*(green + i);
#line 25724
      *(ptr3 + bind) = (unsigned char )*(blue___0 + i);
    }
#line 25719
    i ++;
  }
#line 25727
  return;
}
}
#line 25728 "D:/a/test/177.c"
static void write_monocolor_pixels3(GLcontext *ctx , GLuint n , GLint const   *x ,
                                    GLint const   *y , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLint rind ;
  GLint gind ;
  GLint bind ;
  GLubyte rval ;
  GLubyte gval ;
  GLubyte bval ;
  GLubyte *ptr3 ;

  {
#line 25732
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25734
  rind = osmesa->rind;
#line 25735
  gind = osmesa->gind;
#line 25736
  bind = osmesa->bind;
#line 25737
  rval = (GLubyte )((osmesa->pixel >> osmesa->rshift) & 255U);
#line 25738
  gval = (GLubyte )((osmesa->pixel >> osmesa->gshift) & 255U);
#line 25739
  bval = (GLubyte )((osmesa->pixel >> osmesa->bshift) & 255U);
#line 25740
  i = 0U;
#line 25740
  while (i < n) {
#line 25741
    if (*(mask + i)) {
#line 25742
      ptr3 = (GLubyte *)osmesa->rowaddr[*(y + i)] + *(x + i) * 3;
#line 25743
      *(ptr3 + rind) = rval;
#line 25744
      *(ptr3 + gind) = gval;
#line 25745
      *(ptr3 + bind) = bval;
    }
#line 25740
    i ++;
  }
#line 25748
  return;
}
}
#line 25749 "D:/a/test/177.c"
static void read_color_span3(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *red ,
                             GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLint rind ;
  GLint gind ;
  GLint bind ;
  GLubyte *ptr3 ;

  {
#line 25754
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25756
  rind = osmesa->rind;
#line 25757
  gind = osmesa->gind;
#line 25758
  bind = osmesa->bind;
#line 25759
  ptr3 = (GLubyte *)osmesa->rowaddr[y] + x * 3;
#line 25760
  i = 0U;
#line 25760
  while (i < n) {
#line 25761
    *(red + i) = *(ptr3 + rind);
#line 25762
    *(green + i) = *(ptr3 + gind);
#line 25763
    *(blue___0 + i) = *(ptr3 + bind);
#line 25764
    *(alpha + i) = (unsigned char)0;
#line 25760
    i ++;
#line 25760
    ptr3 += 3;
  }
#line 25766
  return;
}
}
#line 25767 "D:/a/test/177.c"
static void read_color_pixels3(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                               GLubyte *red , GLubyte *green , GLubyte *blue___0 ,
                               GLubyte *alpha , GLubyte const   *mask ) 
{ OSMesaContext osmesa ;
  GLuint i ;
  GLint rind ;
  GLint gind ;
  GLint bind ;
  GLubyte *ptr3 ;

  {
#line 25773
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25775
  rind = osmesa->rind;
#line 25776
  gind = osmesa->gind;
#line 25777
  bind = osmesa->bind;
#line 25778
  i = 0U;
#line 25778
  while (i < n) {
#line 25779
    if (*(mask + i)) {
#line 25780
      ptr3 = (GLubyte *)osmesa->rowaddr[*(y + i)] + *(x + i) * 3;
#line 25781
      *(red + i) = *(ptr3 + rind);
#line 25782
      *(green + i) = *(ptr3 + gind);
#line 25783
      *(blue___0 + i) = *(ptr3 + bind);
#line 25784
      *(alpha + i) = (unsigned char)0;
    }
#line 25778
    i ++;
  }
#line 25787
  return;
}
}
#line 25788 "D:/a/test/177.c"
static void flat_color_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ OSMesaContext osmesa ;
  GLubyte *color ;
  unsigned long pixel ;

  {
#line 25791
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25792
  color = *((ctx->VB)->Color + pvert);
#line 25793
  pixel = (unsigned long )(((((int )*(color + 0) << osmesa->rshift) | ((int )*(color + 1) << osmesa->gshift)) | ((int )*(color + 2) << osmesa->bshift)) | ((int )*(color + 3) << osmesa->ashift));
#line 25797
  return;
}
}
#line 25798 "D:/a/test/177.c"
static void flat_color_z_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ OSMesaContext osmesa ;
  GLubyte *color ;
  unsigned long pixel ;

  {
#line 25801
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25802
  color = *((ctx->VB)->Color + pvert);
#line 25803
  pixel = (unsigned long )(((((int )*(color + 0) << osmesa->rshift) | ((int )*(color + 1) << osmesa->gshift)) | ((int )*(color + 2) << osmesa->bshift)) | ((int )*(color + 3) << osmesa->ashift));
#line 25813
  return;
}
}
#line 25814 "D:/a/test/177.c"
static void flat_blend_color_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 , GLuint pvert ) 
{ OSMesaContext osmesa ;
  struct vertex_buffer *VB ;
  GLint rshift ;
  GLint gshift ;
  GLint bshift ;
  GLint avalue ;
  GLint msavalue ;
  GLint rvalue ;
  GLint gvalue ;
  GLint bvalue ;

  {
#line 25817
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25818
  VB = ctx->VB;
#line 25819
  rshift = osmesa->rshift;
#line 25820
  gshift = osmesa->gshift;
#line 25821
  bshift = osmesa->bshift;
#line 25822
  avalue = (GLint )(*(VB->Color + pvert))[3];
#line 25823
  msavalue = 255 - avalue;
#line 25824
  rvalue = (int )(*(VB->Color + pvert))[0] * avalue;
#line 25825
  gvalue = (int )(*(VB->Color + pvert))[1] * avalue;
#line 25826
  bvalue = (int )(*(VB->Color + pvert))[2] * avalue;
#line 25837
  return;
}
}
#line 25838 "D:/a/test/177.c"
static void flat_blend_color_z_line(GLcontext *ctx , GLuint vert0 , GLuint vert1 ,
                                    GLuint pvert ) 
{ OSMesaContext osmesa ;
  struct vertex_buffer *VB ;
  GLint rshift ;
  GLint gshift ;
  GLint bshift ;
  GLint avalue ;
  GLint msavalue ;
  GLint rvalue ;
  GLint gvalue ;
  GLint bvalue ;

  {
#line 25841
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25842
  VB = ctx->VB;
#line 25843
  rshift = osmesa->rshift;
#line 25844
  gshift = osmesa->gshift;
#line 25845
  bshift = osmesa->bshift;
#line 25846
  avalue = (GLint )(*(VB->Color + pvert))[3];
#line 25847
  msavalue = 256 - avalue;
#line 25848
  rvalue = (int )(*(VB->Color + pvert))[0] * avalue;
#line 25849
  gvalue = (int )(*(VB->Color + pvert))[1] * avalue;
#line 25850
  bvalue = (int )(*(VB->Color + pvert))[2] * avalue;
#line 25864
  return;
}
}
#line 25865 "D:/a/test/177.c"
static void flat_blend_color_z_line_write(GLcontext *ctx , GLuint vert0 , GLuint vert1 ,
                                          GLuint pvert ) 
{ OSMesaContext osmesa ;
  struct vertex_buffer *VB ;
  GLint rshift ;
  GLint gshift ;
  GLint bshift ;
  GLint avalue ;
  GLint msavalue ;
  GLint rvalue ;
  GLint gvalue ;
  GLint bvalue ;

  {
#line 25868
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25869
  VB = ctx->VB;
#line 25870
  rshift = osmesa->rshift;
#line 25871
  gshift = osmesa->gshift;
#line 25872
  bshift = osmesa->bshift;
#line 25873
  avalue = (GLint )(*(VB->Color + pvert))[3];
#line 25874
  msavalue = 256 - avalue;
#line 25875
  rvalue = (int )(*(VB->Color + pvert))[0] * avalue;
#line 25876
  gvalue = (int )(*(VB->Color + pvert))[1] * avalue;
#line 25877
  bvalue = (int )(*(VB->Color + pvert))[2] * avalue;
#line 25892
  return;
}
}
#line 25893 "D:/a/test/177.c"
static line_func choose_line_function(GLcontext *ctx ) 
{ OSMesaContext osmesa ;

  {
#line 25895
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25896
  if (ctx->Line.SmoothFlag) {
#line 25896
    return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ))((void *)0));
  }
#line 25897
  if (ctx->Texture.Enabled) {
#line 25897
    return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ))((void *)0));
  }
#line 25898
  if (ctx->Light.ShadeModel != 7424) {
#line 25898
    return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ))((void *)0));
  }
#line 25899
  if (ctx->Line.Width == 1.0F) {
#line 25899
    if ((int )ctx->Line.StippleFlag == 0) {
#line 25901
      if (ctx->RasterMask == 4U) {
#line 25901
        if (ctx->Depth.Func == 513) {
#line 25901
          if ((int )ctx->Depth.Mask == 1) {
#line 25904
            switch (osmesa->format) {
            case 6408: 
            case 1: 
            case 2: 
#line 25908
            return (& flat_color_z_line);
#line 25909
            break;
            default: ;
#line 25911
            return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ))((void *)0));
#line 25912
            break;
            }
          }
        }
      }
#line 25915
      if (ctx->RasterMask == 0U) {
#line 25916
        switch (osmesa->format) {
        case 6408: 
        case 1: 
        case 2: 
#line 25920
        return (& flat_color_line);
#line 25921
        break;
        default: ;
#line 25923
        return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ))((void *)0));
#line 25924
        break;
        }
      }
#line 25927
      if (ctx->RasterMask == 6U) {
#line 25927
        if (ctx->Depth.Func == 513) {
#line 25927
          if ((int )ctx->Depth.Mask == 1) {
#line 25927
            if (ctx->Color.BlendSrc == 770) {
#line 25927
              if (ctx->Color.BlendDst == 771) {
#line 25927
                if (ctx->Color.BlendEquation == 32774) {
#line 25933
                  switch (osmesa->format) {
                  case 6408: 
                  case 1: 
                  case 2: 
#line 25937
                  return (& flat_blend_color_z_line_write);
#line 25938
                  break;
                  default: ;
#line 25940
                  return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ))((void *)0));
#line 25941
                  break;
                  }
                }
              }
            }
          }
        }
      }
#line 25944
      if (ctx->RasterMask == 6U) {
#line 25944
        if (ctx->Depth.Func == 513) {
#line 25944
          if ((int )ctx->Depth.Mask == 0) {
#line 25944
            if (ctx->Color.BlendSrc == 770) {
#line 25944
              if (ctx->Color.BlendDst == 771) {
#line 25944
                if (ctx->Color.BlendEquation == 32774) {
#line 25950
                  switch (osmesa->format) {
                  case 6408: 
                  case 1: 
                  case 2: 
#line 25954
                  return (& flat_blend_color_z_line);
#line 25955
                  break;
                  default: ;
#line 25957
                  return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ))((void *)0));
#line 25958
                  break;
                  }
                }
              }
            }
          }
        }
      }
#line 25961
      if (ctx->RasterMask == 2U) {
#line 25961
        if (ctx->Color.BlendSrc == 770) {
#line 25961
          if (ctx->Color.BlendDst == 771) {
#line 25961
            if (ctx->Color.BlendEquation == 32774) {
#line 25965
              switch (osmesa->format) {
              case 6408: 
              case 1: 
              case 2: 
#line 25969
              return (& flat_blend_color_line);
#line 25970
              break;
              default: ;
#line 25972
              return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ))((void *)0));
#line 25973
              break;
              }
            }
          }
        }
      }
    }
  }
#line 25977
  return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint pv ))((void *)0));
}
}
#line 25980 "D:/a/test/177.c"
static void smooth_color_z_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 ,
                                    GLuint pv ) 
{ OSMesaContext osmesa ;
  GLint rshift ;
  GLint gshift ;
  GLint bshift ;
  GLint ashift ;
  struct vertex_buffer *VB ;
  EdgeT eMaj ;
  EdgeT eTop ;
  EdgeT eBot ;
  float oneOverArea ;
  int vMin ;
  int vMid ;
  int vMax ;
  float y0___0 ;
  float y1___0 ;
  float y2 ;
  float area ;
  int vMin_fx ;
  int vMin_fy ;
  int vMid_fx ;
  int vMid_fy ;
  int vMax_fy ;
  float dxdy ;
  float dxdy___0 ;
  float dxdy___1 ;
  GLint ltor ;
  float dzdx ;
  float dzdy ;
  int fdzdx ;
  float drdx ;
  float drdy ;
  int fdrdx ;
  float dgdx ;
  float dgdy ;
  int fdgdx ;
  float dbdx ;
  float dbdy ;
  int fdbdx ;
  float dadx ;
  float dady ;
  int fdadx ;
  float didx ;
  float didy ;
  int fdidx ;
  float dsdx ;
  float dsdy ;
  float dtdx ;
  float dtdy ;
  float dwdx ;
  float dwdy ;
  float dudx ;
  float dudy ;
  float dvdx ;
  float dvdy ;
  float eMaj_dz ;
  float eBot_dz ;
  float eMaj_dr ;
  float eBot_dr ;
  float eMaj_dg ;
  float eBot_dg ;
  float eMaj_db ;
  float eBot_db ;
  float eMaj_da ;
  float eBot_da ;
  float eMaj_di ;
  float eBot_di ;
  float wMax ;
  float wMin ;
  float wMid ;
  float eMaj_dw ;
  float eBot_dw ;
  float eMaj_ds ;
  float eBot_ds ;
  float eMaj_dt ;
  float eBot_dt ;
  float eMaj_du ;
  float eBot_du ;
  float eMaj_dv ;
  float eBot_dv ;
  int subTriangle ;
  int fx ;
  int fxLeftEdge ;
  int fxRightEdge ;
  int fdxLeftEdge ;
  int fdxRightEdge ;
  int fdxOuter ;
  int idxOuter ;
  float dxOuter ;
  int fError ;
  int fdError ;
  float adjx ;
  float adjy ;
  int fy ;
  int iy ;
  GLdepth *zRow ;
  int dZRowOuter ;
  int dZRowInner ;
  int fz ;
  int fdzOuter ;
  int fdzInner ;
  int fr ;
  int fdrOuter ;
  int fdrInner ;
  int fg ;
  int fdgOuter ;
  int fdgInner ;
  int fb ;
  int fdbOuter ;
  int fdbInner ;
  int fa ;
  int fdaOuter ;
  int fdaInner ;
  int fi ;
  int fdiOuter ;
  int fdiInner ;
  float sLeft ;
  float dsOuter ;
  float dsInner ;
  float tLeft ;
  float dtOuter ;
  float dtInner ;
  float wLeft ;
  float dwOuter ;
  float dwInner ;
  float uLeft ;
  float duOuter ;
  float duInner ;
  float vLeft ;
  float dvOuter ;
  float dvInner ;
  EdgeT *eLeft ;
  EdgeT *eRight ;
  int setupLeft ;
  int setupRight ;
  int lines ;
  GLint vLower ;
  int fsx ;
  float z0 ;
  float tmp___0 ;
  int tmp___1 ;
  float w0 ;
  float s0 ;
  float t0 ;
  float u0 ;
  float v0___0 ;
  int ffz ;
  int ffr ;
  int ffg ;
  int ffb ;
  int ffa ;
  int ffi ;
  float ss ;
  float tt ;
  float ww ;
  float uu ;
  float vv ;
  GLint left ;
  GLint right ;
  int ffrend ;
  int ffgend ;
  int ffbend ;
  int ffaend ;
  GLint i ;
  GLint len ;
  GLuint *img ;
  GLdepth z ;

  {
#line 25983
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 25984
  rshift = osmesa->rshift;
#line 25985
  gshift = osmesa->gshift;
#line 25986
  bshift = osmesa->bshift;
#line 25987
  ashift = osmesa->ashift;
#line 26043
  VB = ctx->VB;
#line 26048
  y0___0 = VB->Win[v0][1];
#line 26049
  y1___0 = VB->Win[v1][1];
#line 26050
  y2 = VB->Win[v2][1];
#line 26051
  if (y0___0 <= y1___0) {
#line 26052
    if (y1___0 <= y2) {
#line 26053
      vMin = (int )v0;
#line 26053
      vMid = (int )v1;
#line 26053
      vMax = (int )v2;
    } else {
#line 26055
      if (y2 <= y0___0) {
#line 26056
        vMin = (int )v2;
#line 26056
        vMid = (int )v0;
#line 26056
        vMax = (int )v1;
      } else {
#line 26059
        vMin = (int )v0;
#line 26059
        vMid = (int )v2;
#line 26059
        vMax = (int )v1;
      }
    }
  } else {
#line 26063
    if (y0___0 <= y2) {
#line 26064
      vMin = (int )v1;
#line 26064
      vMid = (int )v0;
#line 26064
      vMax = (int )v2;
    } else {
#line 26066
      if (y2 <= y1___0) {
#line 26067
        vMin = (int )v2;
#line 26067
        vMid = (int )v1;
#line 26067
        vMax = (int )v0;
      } else {
#line 26070
        vMin = (int )v1;
#line 26070
        vMid = (int )v2;
#line 26070
        vMax = (int )v0;
      }
    }
  }
#line 26074
  eMaj.v0 = vMin;
#line 26074
  eMaj.v1 = vMax;
#line 26075
  eTop.v0 = vMid;
#line 26075
  eTop.v1 = vMax;
#line 26076
  eBot.v0 = vMin;
#line 26076
  eBot.v1 = vMid;
#line 26077
  eMaj.dx = VB->Win[vMax][0] - VB->Win[vMin][0];
#line 26078
  eMaj.dy = VB->Win[vMax][1] - VB->Win[vMin][1];
#line 26079
  eTop.dx = VB->Win[vMax][0] - VB->Win[vMid][0];
#line 26080
  eTop.dy = VB->Win[vMax][1] - VB->Win[vMid][1];
#line 26081
  eBot.dx = VB->Win[vMid][0] - VB->Win[vMin][0];
#line 26082
  eBot.dy = VB->Win[vMid][1] - VB->Win[vMin][1];
#line 26084
  area = eMaj.dx * eBot.dy - eBot.dx * eMaj.dy;
#line 26085
  if (area > - 0.05f) {
#line 26085
    if (area < 0.05f) {
#line 26086
      return;
    }
  }
#line 26088
  oneOverArea = 1.0F / area;
#line 26091
  vMin_fx = (int )((VB->Win[vMin][0] + 0.5F) * 2048.0f);
#line 26092
  vMin_fy = (int )((VB->Win[vMin][1] - 0.5F) * 2048.0f);
#line 26093
  vMid_fx = (int )((VB->Win[vMid][0] + 0.5F) * 2048.0f);
#line 26094
  vMid_fy = (int )((VB->Win[vMid][1] - 0.5F) * 2048.0f);
#line 26095
  vMax_fy = (int )((VB->Win[vMax][1] - 0.5F) * 2048.0f);
#line 26096
  eMaj.fsy = ((vMin_fy + 2048) - 1) & -2048;
#line 26097
  eMaj.lines = (((vMax_fy + 2048) - 1) - eMaj.fsy) >> 11;
#line 26098
  if (eMaj.lines > 0) {
#line 26099
    dxdy = eMaj.dx / eMaj.dy;
#line 26100
    eMaj.fdxdy = (int )(dxdy * 2048.0f);
#line 26101
    eMaj.adjy = (float )(eMaj.fsy - vMin_fy);
#line 26102
    eMaj.fx0 = vMin_fx;
#line 26103
    eMaj.fsx = eMaj.fx0 + (int )(eMaj.adjy * dxdy);
  } else {
#line 26106
    return;
  }
#line 26108
  eTop.fsy = ((vMid_fy + 2048) - 1) & -2048;
#line 26109
  eTop.lines = (((vMax_fy + 2048) - 1) - eTop.fsy) >> 11;
#line 26110
  if (eTop.lines > 0) {
#line 26111
    dxdy___0 = eTop.dx / eTop.dy;
#line 26112
    eTop.fdxdy = (int )(dxdy___0 * 2048.0f);
#line 26113
    eTop.adjy = (float )(eTop.fsy - vMid_fy);
#line 26114
    eTop.fx0 = vMid_fx;
#line 26115
    eTop.fsx = eTop.fx0 + (int )(eTop.adjy * dxdy___0);
  }
#line 26117
  eBot.fsy = ((vMin_fy + 2048) - 1) & -2048;
#line 26118
  eBot.lines = (((vMid_fy + 2048) - 1) - eBot.fsy) >> 11;
#line 26119
  if (eBot.lines > 0) {
#line 26120
    dxdy___1 = eBot.dx / eBot.dy;
#line 26121
    eBot.fdxdy = (int )(dxdy___1 * 2048.0f);
#line 26122
    eBot.adjy = (float )(eBot.fsy - vMin_fy);
#line 26123
    eBot.fx0 = vMin_fx;
#line 26124
    eBot.fsx = eBot.fx0 + (int )(eBot.adjy * dxdy___1);
  }
#line 26159
  ltor = oneOverArea < 0.0F;
#line 26163
  eMaj_dz = VB->Win[vMax][2] - VB->Win[vMin][2];
#line 26164
  eBot_dz = VB->Win[vMid][2] - VB->Win[vMin][2];
#line 26165
  dzdx = oneOverArea * (eMaj_dz * eBot.dy - eMaj.dy * eBot_dz);
#line 26166
  if (dzdx > 65535.0F) {
#line 26167
    dzdx = (float )0.0;
#line 26168
    dzdy = (float )0.0;
  } else {
#line 26166
    if (dzdx < - 65535.0F) {
#line 26167
      dzdx = (float )0.0;
#line 26168
      dzdy = (float )0.0;
    } else {
#line 26171
      dzdy = oneOverArea * (eMaj.dx * eBot_dz - eMaj_dz * eBot.dx);
    }
  }
#line 26174
  fdzdx = (int )(dzdx * 2048.0f);
#line 26183
  eMaj_dr = (float )((int )(*(VB->Color + vMax))[0] - (int )(*(VB->Color + vMin))[0]);
#line 26184
  eBot_dr = (float )((int )(*(VB->Color + vMid))[0] - (int )(*(VB->Color + vMin))[0]);
#line 26185
  drdx = oneOverArea * (eMaj_dr * eBot.dy - eMaj.dy * eBot_dr);
#line 26186
  fdrdx = (int )(drdx * 2048.0f);
#line 26187
  drdy = oneOverArea * (eMaj.dx * eBot_dr - eMaj_dr * eBot.dx);
#line 26191
  eMaj_dg = (float )((int )(*(VB->Color + vMax))[1] - (int )(*(VB->Color + vMin))[1]);
#line 26192
  eBot_dg = (float )((int )(*(VB->Color + vMid))[1] - (int )(*(VB->Color + vMin))[1]);
#line 26193
  dgdx = oneOverArea * (eMaj_dg * eBot.dy - eMaj.dy * eBot_dg);
#line 26194
  fdgdx = (int )(dgdx * 2048.0f);
#line 26195
  dgdy = oneOverArea * (eMaj.dx * eBot_dg - eMaj_dg * eBot.dx);
#line 26199
  eMaj_db = (float )((int )(*(VB->Color + vMax))[2] - (int )(*(VB->Color + vMin))[2]);
#line 26200
  eBot_db = (float )((int )(*(VB->Color + vMid))[2] - (int )(*(VB->Color + vMin))[2]);
#line 26201
  dbdx = oneOverArea * (eMaj_db * eBot.dy - eMaj.dy * eBot_db);
#line 26202
  fdbdx = (int )(dbdx * 2048.0f);
#line 26203
  dbdy = oneOverArea * (eMaj.dx * eBot_db - eMaj_db * eBot.dx);
#line 26209
  eMaj_da = (float )((int )(*(VB->Color + vMax))[3] - (int )(*(VB->Color + vMin))[3]);
#line 26210
  eBot_da = (float )((int )(*(VB->Color + vMid))[3] - (int )(*(VB->Color + vMin))[3]);
#line 26211
  dadx = oneOverArea * (eMaj_da * eBot.dy - eMaj.dy * eBot_da);
#line 26212
  fdadx = (int )(dadx * 2048.0f);
#line 26213
  dady = oneOverArea * (eMaj.dx * eBot_da - eMaj_da * eBot.dx);
#line 26219
  eMaj_di = (float )((int )*(VB->Index + vMax) - (int )*(VB->Index + vMin));
#line 26220
  eBot_di = (float )((int )*(VB->Index + vMid) - (int )*(VB->Index + vMin));
#line 26221
  didx = oneOverArea * (eMaj_di * eBot.dy - eMaj.dy * eBot_di);
#line 26222
  fdidx = (int )(didx * 2048.0f);
#line 26223
  didy = oneOverArea * (eMaj.dx * eBot_di - eMaj_di * eBot.dx);
#line 26246
  wMax = 1.0F / VB->Clip[vMax][3];
#line 26247
  wMin = 1.0F / VB->Clip[vMin][3];
#line 26248
  wMid = 1.0F / VB->Clip[vMid][3];
#line 26256
  eMaj_dw = wMax - wMin;
#line 26257
  eBot_dw = wMid - wMin;
#line 26258
  dwdx = oneOverArea * (eMaj_dw * eBot.dy - eMaj.dy * eBot_dw);
#line 26259
  dwdy = oneOverArea * (eMaj.dx * eBot_dw - eMaj_dw * eBot.dx);
#line 26260
  eMaj_ds = VB->TexCoord[vMax][0] * wMax - VB->TexCoord[vMin][0] * wMin;
#line 26261
  eBot_ds = VB->TexCoord[vMid][0] * wMid - VB->TexCoord[vMin][0] * wMin;
#line 26262
  dsdx = oneOverArea * (eMaj_ds * eBot.dy - eMaj.dy * eBot_ds);
#line 26263
  dsdy = oneOverArea * (eMaj.dx * eBot_ds - eMaj_ds * eBot.dx);
#line 26264
  eMaj_dt = VB->TexCoord[vMax][1] * wMax - VB->TexCoord[vMin][1] * wMin;
#line 26265
  eBot_dt = VB->TexCoord[vMid][1] * wMid - VB->TexCoord[vMin][1] * wMin;
#line 26266
  dtdx = oneOverArea * (eMaj_dt * eBot.dy - eMaj.dy * eBot_dt);
#line 26267
  dtdy = oneOverArea * (eMaj.dx * eBot_dt - eMaj_dt * eBot.dx);
#line 26269
  eMaj_du = VB->TexCoord[vMax][2] * wMax - VB->TexCoord[vMin][2] * wMin;
#line 26270
  eBot_du = VB->TexCoord[vMid][2] * wMid - VB->TexCoord[vMin][2] * wMin;
#line 26271
  dudx = oneOverArea * (eMaj_du * eBot.dy - eMaj.dy * eBot_du);
#line 26272
  dudy = oneOverArea * (eMaj.dx * eBot_du - eMaj_du * eBot.dx);
#line 26273
  eMaj_dv = VB->TexCoord[vMax][3] - VB->TexCoord[vMin][3];
#line 26274
  eBot_dv = VB->TexCoord[vMid][3] - VB->TexCoord[vMin][3];
#line 26275
  dvdx = oneOverArea * (eMaj_dv * eBot.dy - eMaj.dy * eBot_dv);
#line 26276
  dvdy = oneOverArea * (eMaj.dx * eBot_dv - eMaj_dv * eBot.dx);
#line 26323
  subTriangle = 0;
#line 26323
  while (subTriangle <= 1) {
#line 26327
    if (subTriangle == 0) {
#line 26328
      if (ltor) {
#line 26329
        eLeft = & eMaj;
#line 26330
        eRight = & eBot;
#line 26331
        lines = eRight->lines;
#line 26332
        setupLeft = 1;
#line 26333
        setupRight = 1;
      } else {
#line 26336
        eLeft = & eBot;
#line 26337
        eRight = & eMaj;
#line 26338
        lines = eLeft->lines;
#line 26339
        setupLeft = 1;
#line 26340
        setupRight = 1;
      }
    } else {
#line 26344
      if (ltor) {
#line 26345
        eLeft = & eMaj;
#line 26346
        eRight = & eTop;
#line 26347
        lines = eRight->lines;
#line 26348
        setupLeft = 0;
#line 26349
        setupRight = 1;
      } else {
#line 26352
        eLeft = & eTop;
#line 26353
        eRight = & eMaj;
#line 26354
        lines = eLeft->lines;
#line 26355
        setupLeft = 1;
#line 26356
        setupRight = 0;
      }
#line 26358
      if (lines == 0) {
#line 26358
        return;
      }
    }
#line 26360
    if (setupLeft) {
#line 26360
      if (eLeft->lines > 0) {
#line 26362
        fsx = eLeft->fsx;
#line 26363
        fx = ((fsx + 2048) - 1) & -2048;
#line 26364
        fError = (fx - fsx) - 2048;
#line 26365
        fxLeftEdge = fsx - 1;
#line 26366
        fdxLeftEdge = eLeft->fdxdy;
#line 26367
        fdxOuter = (fdxLeftEdge - 1) & -2048;
#line 26368
        fdError = (fdxOuter - fdxLeftEdge) + 2048;
#line 26369
        idxOuter = fdxOuter >> 11;
#line 26370
        dxOuter = (float )idxOuter;
#line 26371
        fy = eLeft->fsy;
#line 26372
        iy = fy >> 11;
#line 26373
        adjx = (float )(fx - eLeft->fx0);
#line 26374
        adjy = eLeft->adjy;
#line 26375
        vLower = eLeft->v0;
#line 26385
        z0 = VB->Win[vLower][2] + ctx->PolygonZoffset;
#line 26387
        tmp___0 = ((z0 * 2048.0f + dzdx * adjx) + dzdy * adjy) + (float )1024;
#line 26388
        if (tmp___0 < (float )2147483647U) {
#line 26389
          fz = (int )tmp___0;
        } else {
#line 26391
          fz = 2147483647;
        }
#line 26392
        fdzOuter = (int )((dzdy + dxOuter * dzdx) * 2048.0f);
#line 26397
        tmp___1 = Z_ADDRESS(ctx, fxLeftEdge >> 11, iy);
#line 26397
        zRow = (GLdepth *)tmp___1;
#line 26398
        dZRowOuter = (int )((unsigned int )((ctx->Buffer)->Width + idxOuter) * sizeof(GLdepth ));
#line 26402
        fr = (int )(((float )((int )(*(VB->Color + vLower))[0] << 11) + drdx * adjx) + drdy * adjy) + 1024;
#line 26404
        fdrOuter = (int )((drdy + dxOuter * drdx) * 2048.0f);
#line 26405
        fg = (int )(((float )((int )(*(VB->Color + vLower))[1] << 11) + dgdx * adjx) + dgdy * adjy) + 1024;
#line 26407
        fdgOuter = (int )((dgdy + dxOuter * dgdx) * 2048.0f);
#line 26408
        fb = (int )(((float )((int )(*(VB->Color + vLower))[2] << 11) + dbdx * adjx) + dbdy * adjy) + 1024;
#line 26410
        fdbOuter = (int )((dbdy + dxOuter * dbdx) * 2048.0f);
#line 26413
        fa = (int )(((float )((int )(*(VB->Color + vLower))[3] << 11) + dadx * adjx) + dady * adjy) + 1024;
#line 26415
        fdaOuter = (int )((dady + dxOuter * dadx) * 2048.0f);
#line 26418
        fi = (int )(((float )*(VB->Index + vLower) * 2048.0f + didx * adjx) + didy * adjy) + 1024;
#line 26420
        fdiOuter = (int )((didy + dxOuter * didx) * 2048.0f);
#line 26435
        w0 = 1.0F / VB->Clip[vLower][3];
#line 26437
        wLeft = w0 + (dwdx * adjx + dwdy * adjy) * (1.0F / 2048.0f);
#line 26438
        dwOuter = dwdy + dxOuter * dwdx;
#line 26439
        s0 = VB->TexCoord[vLower][0] * w0;
#line 26440
        sLeft = s0 + (dsdx * adjx + dsdy * adjy) * (1.0F / 2048.0f);
#line 26441
        dsOuter = dsdy + dxOuter * dsdx;
#line 26442
        t0 = VB->TexCoord[vLower][1] * w0;
#line 26443
        tLeft = t0 + (dtdx * adjx + dtdy * adjy) * (1.0F / 2048.0f);
#line 26444
        dtOuter = dtdy + dxOuter * dtdx;
#line 26446
        u0 = VB->TexCoord[vLower][2] * w0;
#line 26447
        uLeft = u0 + (dudx * adjx + dudy * adjy) * (1.0F / 2048.0f);
#line 26448
        duOuter = dudy + dxOuter * dudx;
#line 26449
        v0___0 = VB->TexCoord[vLower][3];
#line 26450
        vLeft = v0___0 + (dvdx * adjx + dvdy * adjy) * (1.0F / 2048.0f);
#line 26451
        dvOuter = dvdy + dxOuter * dvdx;
      }
    }
#line 26456
    if (setupRight) {
#line 26456
      if (eRight->lines > 0) {
#line 26457
        fxRightEdge = eRight->fsx - 1;
#line 26458
        fdxRightEdge = eRight->fdxdy;
      }
    }
#line 26460
    if (lines == 0) {
      goto __Cont;
    }
#line 26467
    dZRowInner = (int )((unsigned int )dZRowOuter + sizeof(GLdepth ));
#line 26468
    fdzInner = fdzOuter + fdzdx;
#line 26471
    fdrInner = fdrOuter + fdrdx;
#line 26472
    fdgInner = fdgOuter + fdgdx;
#line 26473
    fdbInner = fdbOuter + fdbdx;
#line 26476
    fdaInner = fdaOuter + fdadx;
#line 26479
    fdiInner = fdiOuter + fdidx;
#line 26486
    dwInner = dwOuter + dwdx;
#line 26487
    dsInner = dsOuter + dsdx;
#line 26488
    dtInner = dtOuter + dtdx;
#line 26490
    duInner = duOuter + dudx;
#line 26491
    dvInner = dvOuter + dvdx;
#line 26494
    while (lines > 0) {
#line 26496
      ffz = fz;
#line 26499
      ffr = fr;
#line 26499
      ffg = fg;
#line 26499
      ffb = fb;
#line 26502
      ffa = fa;
#line 26505
      ffi = fi;
#line 26511
      ss = sLeft;
#line 26511
      tt = tLeft;
#line 26511
      ww = wLeft;
#line 26514
      uu = uLeft;
#line 26514
      vv = vLeft;
#line 26516
      left = fxLeftEdge >> 11;
#line 26517
      right = fxRightEdge >> 11;
#line 26520
      ffrend = ffr + ((right - left) - 1) * fdrdx;
#line 26521
      ffgend = ffg + ((right - left) - 1) * fdgdx;
#line 26522
      ffbend = ffb + ((right - left) - 1) * fdbdx;
#line 26523
      if (ffrend < 0) {
#line 26523
        ffr -= ffrend;
      }
#line 26524
      if (ffgend < 0) {
#line 26524
        ffg -= ffgend;
      }
#line 26525
      if (ffbend < 0) {
#line 26525
        ffb -= ffbend;
      }
#line 26526
      if (ffr < 0) {
#line 26526
        ffr = 0;
      }
#line 26527
      if (ffg < 0) {
#line 26527
        ffg = 0;
      }
#line 26528
      if (ffb < 0) {
#line 26528
        ffb = 0;
      }
#line 26533
      ffaend = ffa + ((right - left) - 1) * fdadx;
#line 26534
      if (ffaend < 0) {
#line 26534
        ffa -= ffaend;
      }
#line 26535
      if (ffa < 0) {
#line 26535
        ffa = 0;
      }
#line 26539
      if (ffi < 0) {
#line 26539
        ffi = 0;
      }
#line 26541
      len = right - left;
#line 26541
      img = (GLuint *)osmesa->rowaddr[iy] + left;
#line 26541
      i = 0;
#line 26541
      while (i < len) {
#line 26541
        z = (GLdepth )(ffz >> 11);
#line 26541
        if ((int )z < (int )*(zRow + i)) {
#line 26541
          *img = (unsigned int )(((((ffr >> 11) << rshift) | ((ffg >> 11) << gshift)) | ((ffb >> 11) << bshift)) | ((ffa >> 11) << ashift));
#line 26541
          *(zRow + i) = z;
        }
#line 26541
        ffr += fdrdx;
#line 26541
        ffg += fdgdx;
#line 26541
        ffb += fdbdx;
#line 26541
        ffa += fdadx;
#line 26541
        ffz += fdzdx;
#line 26541
        i ++;
#line 26541
        img ++;
      }
#line 26542
      iy ++;
#line 26543
      lines --;
#line 26544
      fxLeftEdge += fdxLeftEdge;
#line 26545
      fxRightEdge += fdxRightEdge;
#line 26546
      fError += fdError;
#line 26547
      if (fError >= 0) {
#line 26548
        fError -= 2048;
#line 26553
        zRow = (GLdepth *)((GLubyte *)zRow + dZRowOuter);
#line 26554
        fz += fdzOuter;
#line 26557
        fr += fdrOuter;
#line 26557
        fg += fdgOuter;
#line 26557
        fb += fdbOuter;
#line 26560
        fa += fdaOuter;
#line 26563
        fi += fdiOuter;
#line 26569
        sLeft += dsOuter;
#line 26570
        tLeft += dtOuter;
#line 26571
        wLeft += dwOuter;
#line 26574
        uLeft += duOuter;
#line 26575
        vLeft += dvOuter;
      } else {
#line 26583
        zRow = (GLdepth *)((GLubyte *)zRow + dZRowInner);
#line 26584
        fz += fdzInner;
#line 26587
        fr += fdrInner;
#line 26587
        fg += fdgInner;
#line 26587
        fb += fdbInner;
#line 26590
        fa += fdaInner;
#line 26593
        fi += fdiInner;
#line 26599
        sLeft += dsInner;
#line 26600
        tLeft += dtInner;
#line 26601
        wLeft += dwInner;
#line 26604
        uLeft += duInner;
#line 26605
        vLeft += dvInner;
      }
    }
    __Cont: /* CIL Label */ 
#line 26323
    subTriangle ++;
  }
#line 26627
  return;
}
}
#line 26628 "D:/a/test/177.c"
static void flat_color_z_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 ,
                                  GLuint pv ) 
{ OSMesaContext osmesa ;

  {
#line 26631
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 26652
  return;
}
}
#line 26653 "D:/a/test/177.c"
static triangle_func choose_triangle_function(GLcontext *ctx ) 
{ OSMesaContext osmesa ;

  {
#line 26655
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 26656
  if (osmesa->format == 6407) {
#line 26656
    return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 , GLuint pv ))((void *)0));
  } else {
#line 26656
    if (osmesa->format == 4) {
#line 26656
      return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 , GLuint pv ))((void *)0));
    }
  }
#line 26657
  if (ctx->Polygon.SmoothFlag) {
#line 26657
    return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 , GLuint pv ))((void *)0));
  }
#line 26658
  if (ctx->Polygon.StippleFlag) {
#line 26658
    return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 , GLuint pv ))((void *)0));
  }
#line 26659
  if (ctx->Texture.Enabled) {
#line 26659
    return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 , GLuint pv ))((void *)0));
  }
#line 26660
  if (ctx->RasterMask == 4U) {
#line 26660
    if (ctx->Depth.Func == 513) {
#line 26660
      if ((int )ctx->Depth.Mask == 1) {
#line 26660
        if (osmesa->format != 6400) {
#line 26664
          if (ctx->Light.ShadeModel == 7425) {
#line 26665
            return (& smooth_color_z_triangle);
          } else {
#line 26668
            return (& flat_color_z_triangle);
          }
        }
      }
    }
  }
#line 26671
  return ((void (*)(GLcontext *ctx , GLuint v1 , GLuint v2 , GLuint v3 , GLuint pv ))((void *)0));
}
}
#line 26673 "D:/a/test/177.c"
static char const   *renderer_string(void) 
{ 

  {
#line 26675
  return ("OffScreen");
}
}
#line 26677 "D:/a/test/177.c"
static void osmesa_setup_DD_pointers(GLcontext *ctx ) 
{ OSMesaContext osmesa ;

  {
#line 26679
  osmesa = (struct osmesa_context *)ctx->DriverCtx;
#line 26680
  ctx->Driver.RendererString = & renderer_string;
#line 26681
  ctx->Driver.UpdateState = & osmesa_setup_DD_pointers;
#line 26682
  ctx->Driver.SetBuffer = & set_buffer;
#line 26683
  ctx->Driver.Color = & set_color;
#line 26684
  ctx->Driver.Index = & set_index;
#line 26685
  ctx->Driver.ClearIndex = & clear_index;
#line 26686
  ctx->Driver.ClearColor = & clear_color;
#line 26687
  ctx->Driver.Clear = & clear;
#line 26688
  ctx->Driver.GetBufferSize = & buffer_size;
#line 26689
  ctx->Driver.PointsFunc = (void (*)(GLcontext *ctx , GLuint first , GLuint last ))((void *)0);
#line 26690
  ctx->Driver.LineFunc = choose_line_function(ctx);
#line 26691
  ctx->Driver.TriangleFunc = choose_triangle_function(ctx);
#line 26692
  if (osmesa->format == 6407) {
    goto _L;
  } else {
#line 26692
    if (osmesa->format == 4) {
      _L: /* CIL Label */ 
#line 26693
      ctx->Driver.WriteColorSpan = & write_color_span3;
#line 26694
      ctx->Driver.WriteColorPixels = & write_color_pixels3;
#line 26695
      ctx->Driver.WriteMonocolorSpan = & write_monocolor_span3;
#line 26696
      ctx->Driver.WriteMonocolorPixels = & write_monocolor_pixels3;
#line 26697
      ctx->Driver.ReadColorSpan = & read_color_span3;
#line 26698
      ctx->Driver.ReadColorPixels = & read_color_pixels3;
    } else {
#line 26701
      ctx->Driver.WriteColorSpan = & write_color_span;
#line 26702
      ctx->Driver.WriteColorPixels = & write_color_pixels;
#line 26703
      ctx->Driver.WriteMonocolorSpan = & write_monocolor_span;
#line 26704
      ctx->Driver.WriteMonocolorPixels = & write_monocolor_pixels;
#line 26705
      ctx->Driver.ReadColorSpan = & read_color_span;
#line 26706
      ctx->Driver.ReadColorPixels = & read_color_pixels;
    }
  }
#line 26708
  ctx->Driver.WriteIndexSpan = & write_index_span;
#line 26709
  ctx->Driver.WriteMonoindexSpan = & write_monoindex_span;
#line 26710
  ctx->Driver.WriteIndexPixels = & write_index_pixels;
#line 26711
  ctx->Driver.WriteMonoindexPixels = & write_monoindex_pixels;
#line 26712
  ctx->Driver.ReadIndexSpan = & read_index_span;
#line 26713
  ctx->Driver.ReadIndexPixels = & read_index_pixels;
#line 26714
  return;
}
}
#line 26720 "D:/a/test/177.c"
struct pixel_buffer *gl_alloc_pb(void) 
{ struct pixel_buffer *pb ;
  void *tmp___0 ;
  int i ;

  {
#line 26723
  tmp___0 = calloc(sizeof(struct pixel_buffer ), 1U);
#line 26723
  pb = (struct pixel_buffer *)tmp___0;
#line 26724
  if (pb) {
#line 26726
    pb->primitive = 6656;
#line 26727
    i = 0;
#line 26727
    while (i < 1920) {
#line 26728
      pb->lambda[i] = (float )0.0;
#line 26727
      i ++;
    }
  }
#line 26731
  return (pb);
}
}
#line 26764
void gl_texture_pixels(GLcontext *ctx , GLuint n , float const   *s , float const   *t ,
                       float const   *r , float const   *lambda , GLubyte *red , GLubyte *green ,
                       GLubyte *blue___0 , GLubyte *alpha ) ;
#line 26780
GLint gl_stencil_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                        GLubyte *mask ) ;
#line 26784
void gl_depth_stencil_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                             GLdepth const   *z , GLubyte *mask ) ;
#line 26733 "D:/a/test/177.c"
void gl_flush_pb(GLcontext *ctx ) 
{ struct pixel_buffer *PB ;
  GLubyte mask[1920] ;
  GLubyte rsave[1920] ;
  GLubyte gsave[1920] ;
  GLubyte bsave[1920] ;
  GLubyte asave[1920] ;
  GLint xmin ;
  GLint xmax ;
  GLint ymin ;
  GLint ymax ;
  GLint *x ;
  GLint *y ;
  GLuint i ;
  GLuint n ;
  GLint tmp___0 ;
  int tmp___1 ;
  GLint tmp___2 ;
  int tmp___3 ;
  GLubyte red ;
  GLubyte green ;
  GLubyte blue___0 ;
  GLubyte alpha ;
  GLuint n___0 ;
  GLuint indx ;
  GLuint *pbindex ;
  GLuint *tmp___4 ;
  GLuint isave[1920] ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 26735
  PB = ctx->PB;
#line 26741
  if (PB->count == 0U) {
    goto CleanUp;
  }
#line 26743
  xmin = (ctx->Buffer)->Xmin;
#line 26744
  xmax = (ctx->Buffer)->Xmax;
#line 26745
  ymin = (ctx->Buffer)->Ymin;
#line 26746
  ymax = (ctx->Buffer)->Ymax;
#line 26747
  x = PB->x;
#line 26748
  y = PB->y;
#line 26749
  n = PB->count;
#line 26750
  i = 0U;
#line 26750
  while (i < n) {
#line 26751
    mask[i] = (unsigned char )((((*(x + i) >= xmin) & (*(x + i) <= xmax)) & (*(y + i) >= ymin)) & (*(y + i) <= ymax));
#line 26750
    i ++;
  }
#line 26754
  if ((ctx->Visual)->RGBAflag) {
#line 26755
    if (PB->mono) {
#line 26755
      if (ctx->MutablePixels) {
#line 26757
        memset((void *)(PB->r), PB->color[0], PB->count);
#line 26758
        memset((void *)(PB->g), PB->color[1], PB->count);
#line 26759
        memset((void *)(PB->b), PB->color[2], PB->count);
#line 26760
        memset((void *)(PB->a), PB->color[3], PB->count);
      }
    }
#line 26762
    if (ctx->MutablePixels) {
      goto _L;
    } else {
#line 26762
      if (! PB->mono) {
        _L: /* CIL Label */ 
#line 26763
        if (ctx->Texture.Enabled) {
#line 26764
          gl_texture_pixels(ctx, PB->count, PB->s, PB->t, PB->u, PB->lambda, PB->r,
                            PB->g, PB->b, PB->a);
        }
#line 26767
        if (ctx->Fog.Enabled) {
#line 26767
          if (ctx->Hint.Fog == 4354) {
#line 26770
            gl_fog_color_pixels(ctx, PB->count, (GLdepth const   *)(PB->z), PB->r,
                                PB->g, PB->b, PB->a);
          } else {
#line 26767
            if (PB->primitive == 6656) {
#line 26770
              gl_fog_color_pixels(ctx, PB->count, (GLdepth const   *)(PB->z), PB->r,
                                  PB->g, PB->b, PB->a);
            } else {
#line 26767
              if (ctx->Texture.Enabled) {
#line 26770
                gl_fog_color_pixels(ctx, PB->count, (GLdepth const   *)(PB->z), PB->r,
                                    PB->g, PB->b, PB->a);
              }
            }
          }
        }
#line 26773
        if (ctx->Color.AlphaEnabled) {
#line 26774
          tmp___0 = gl_alpha_test(ctx, PB->count, (GLubyte const   *)(PB->a), mask);
#line 26774
          if (tmp___0 == 0) {
            goto CleanUp;
          }
        }
#line 26778
        if (ctx->Stencil.Enabled) {
#line 26780
          tmp___1 = gl_stencil_pixels(ctx, PB->count, PB->x, PB->y, mask);
#line 26780
          if (tmp___1 == 0) {
            goto CleanUp;
          }
#line 26784
          gl_depth_stencil_pixels(ctx, PB->count, PB->x, PB->y, PB->z, mask);
        } else {
#line 26786
          if (ctx->Depth.Test) {
#line 26788
            (*(ctx->Driver.DepthTestPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                             (GLint const   *)(PB->y), (GLdepth const   *)(PB->z),
                                             mask);
          }
        }
#line 26790
        if (ctx->RasterMask & 2048U) {
          goto CleanUp;
        }
#line 26793
        if (ctx->RasterMask & 1024U) {
#line 26794
          memcpy((void *)(rsave), (void const   *)((void *)(PB->r)), PB->count * sizeof(GLubyte ));
#line 26795
          memcpy((void *)(gsave), (void const   *)((void *)(PB->r)), PB->count * sizeof(GLubyte ));
#line 26796
          memcpy((void *)(bsave), (void const   *)((void *)(PB->r)), PB->count * sizeof(GLubyte ));
#line 26797
          memcpy((void *)(asave), (void const   *)((void *)(PB->r)), PB->count * sizeof(GLubyte ));
        }
#line 26799
        if (ctx->Color.SWLogicOpEnabled) {
#line 26800
          gl_logicop_rgba_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                                 PB->r, PB->g, PB->b, PB->a, mask);
        } else {
#line 26803
          if (ctx->Color.BlendEnabled) {
#line 26804
            gl_blend_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                            PB->r, PB->g, PB->b, PB->a, mask);
          }
        }
#line 26807
        if (ctx->Color.SWmasking) {
#line 26808
          gl_mask_color_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                               PB->r, PB->g, PB->b, PB->a, (GLubyte const   *)(mask));
        }
#line 26811
        (*(ctx->Driver.WriteColorPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                          (GLint const   *)(PB->y), (GLubyte const   *)(PB->r),
                                          (GLubyte const   *)(PB->g), (GLubyte const   *)(PB->b),
                                          (GLubyte const   *)(PB->a), (GLubyte const   *)(mask));
#line 26813
        if (ctx->RasterMask & 256U) {
#line 26814
          gl_write_alpha_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                                (GLubyte const   *)(PB->a), (GLubyte const   *)(mask));
        }
#line 26816
        if (ctx->RasterMask & 1024U) {
#line 26817
          (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 26818
          if (ctx->Color.SWLogicOpEnabled) {
#line 26819
            gl_logicop_rgba_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                                   PB->r, PB->g, PB->b, PB->a, mask);
          } else {
#line 26822
            if (ctx->Color.BlendEnabled) {
#line 26823
              gl_blend_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                              rsave, gsave, bsave, asave, mask);
            }
          }
#line 26826
          if (ctx->Color.SWmasking) {
#line 26827
            gl_mask_color_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                                 rsave, gsave, bsave, asave, (GLubyte const   *)(mask));
          }
#line 26830
          (*(ctx->Driver.WriteColorPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                            (GLint const   *)(PB->y), (GLubyte const   *)(rsave),
                                            (GLubyte const   *)(gsave), (GLubyte const   *)(bsave),
                                            (GLubyte const   *)(asave), (GLubyte const   *)(mask));
#line 26832
          if (ctx->RasterMask & 256U) {
#line 26833
            (ctx->Buffer)->Alpha = (ctx->Buffer)->BackAlpha;
#line 26834
            gl_write_alpha_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                                  (GLubyte const   *)(asave), (GLubyte const   *)(mask));
#line 26836
            (ctx->Buffer)->Alpha = (ctx->Buffer)->FrontAlpha;
          }
#line 26838
          (*(ctx->Driver.SetBuffer))(ctx, 1028);
        }
      } else {
#line 26843
        if (ctx->Color.AlphaEnabled) {
#line 26844
          tmp___2 = gl_alpha_test(ctx, PB->count, (GLubyte const   *)(PB->a), mask);
#line 26844
          if (tmp___2 == 0) {
            goto CleanUp;
          }
        }
#line 26848
        if (ctx->Stencil.Enabled) {
#line 26850
          tmp___3 = gl_stencil_pixels(ctx, PB->count, PB->x, PB->y, mask);
#line 26850
          if (tmp___3 == 0) {
            goto CleanUp;
          }
#line 26854
          gl_depth_stencil_pixels(ctx, PB->count, PB->x, PB->y, PB->z, mask);
        } else {
#line 26856
          if (ctx->Depth.Test) {
#line 26858
            (*(ctx->Driver.DepthTestPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                             (GLint const   *)(PB->y), (GLdepth const   *)(PB->z),
                                             mask);
          }
        }
#line 26860
        if (ctx->RasterMask & 2048U) {
          goto CleanUp;
        }
#line 26865
        red = (unsigned char )PB->color[0];
#line 26866
        green = (unsigned char )PB->color[1];
#line 26867
        blue___0 = (unsigned char )PB->color[2];
#line 26868
        alpha = (unsigned char )PB->color[3];
#line 26869
        (*(ctx->Driver.Color))(ctx, red, green, blue___0, alpha);
#line 26871
        (*(ctx->Driver.WriteMonocolorPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                              (GLint const   *)(PB->y), (GLubyte const   *)(mask));
#line 26872
        if (ctx->RasterMask & 256U) {
#line 26873
          gl_write_mono_alpha_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                                     (unsigned char )PB->color[3], (GLubyte const   *)(mask));
        }
#line 26876
        if (ctx->RasterMask & 1024U) {
#line 26877
          (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 26878
          (*(ctx->Driver.WriteMonocolorPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                                (GLint const   *)(PB->y), (GLubyte const   *)(mask));
#line 26879
          if (ctx->RasterMask & 256U) {
#line 26880
            (ctx->Buffer)->Alpha = (ctx->Buffer)->BackAlpha;
#line 26881
            gl_write_mono_alpha_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                                       (unsigned char )PB->color[3], (GLubyte const   *)(mask));
#line 26883
            (ctx->Buffer)->Alpha = (ctx->Buffer)->FrontAlpha;
          }
#line 26885
          (*(ctx->Driver.SetBuffer))(ctx, 1028);
        }
      }
    }
  } else {
#line 26890
    if (PB->mono) {
#line 26890
      if (ctx->MutablePixels) {
#line 26892
        n___0 = PB->count;
#line 26892
        indx = PB->index;
#line 26893
        pbindex = PB->i;
#line 26894
        while (1) {
#line 26895
          tmp___4 = pbindex;
#line 26895
          pbindex ++;
#line 26895
          *tmp___4 = indx;
#line 26896
          n___0 --;
#line 26894
          if (! n___0) {
#line 26894
            break;
          }
        }
      }
    }
#line 26899
    if (ctx->MutablePixels) {
      goto _L___0;
    } else {
#line 26899
      if (! PB->mono) {
        _L___0: /* CIL Label */ 
#line 26902
        if (ctx->Fog.Enabled) {
#line 26902
          if (ctx->Hint.Fog == 4354) {
#line 26904
            gl_fog_index_pixels(ctx, PB->count, (GLdepth const   *)(PB->z), PB->i);
          } else {
#line 26902
            if (PB->primitive == 6656) {
#line 26904
              gl_fog_index_pixels(ctx, PB->count, (GLdepth const   *)(PB->z), PB->i);
            }
          }
        }
#line 26906
        if (ctx->Stencil.Enabled) {
#line 26908
          tmp___5 = gl_stencil_pixels(ctx, PB->count, PB->x, PB->y, mask);
#line 26908
          if (tmp___5 == 0) {
            goto CleanUp;
          }
#line 26912
          gl_depth_stencil_pixels(ctx, PB->count, PB->x, PB->y, PB->z, mask);
        } else {
#line 26914
          if (ctx->Depth.Test) {
#line 26916
            (*(ctx->Driver.DepthTestPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                             (GLint const   *)(PB->y), (GLdepth const   *)(PB->z),
                                             mask);
          }
        }
#line 26918
        if (ctx->RasterMask & 2048U) {
          goto CleanUp;
        }
#line 26921
        if (ctx->RasterMask & 1024U) {
#line 26922
          memcpy((void *)(isave), (void const   *)((void *)(PB->i)), PB->count * sizeof(GLuint ));
        }
#line 26924
        if (ctx->Color.SWLogicOpEnabled) {
#line 26925
          gl_logicop_ci_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                               PB->i, mask);
        }
#line 26927
        if (ctx->Color.SWmasking) {
#line 26928
          gl_mask_index_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                               PB->i, (GLubyte const   *)(mask));
        }
#line 26930
        (*(ctx->Driver.WriteIndexPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                          (GLint const   *)(PB->y), (GLuint const   *)(PB->i),
                                          (GLubyte const   *)(mask));
#line 26932
        if (ctx->RasterMask & 1024U) {
#line 26933
          (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 26934
          memcpy((void *)(PB->i), (void const   *)((void *)(isave)), PB->count * sizeof(GLuint ));
#line 26935
          if (ctx->Color.SWLogicOpEnabled) {
#line 26936
            gl_logicop_ci_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                                 PB->i, mask);
          }
#line 26938
          if (ctx->Color.SWmasking) {
#line 26939
            gl_mask_index_pixels(ctx, PB->count, (GLint const   *)(PB->x), (GLint const   *)(PB->y),
                                 PB->i, (GLubyte const   *)(mask));
          }
#line 26942
          (*(ctx->Driver.WriteIndexPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                            (GLint const   *)(PB->y), (GLuint const   *)(PB->i),
                                            (GLubyte const   *)(mask));
#line 26944
          (*(ctx->Driver.SetBuffer))(ctx, 1028);
        }
      } else {
#line 26949
        if (ctx->Stencil.Enabled) {
#line 26951
          tmp___6 = gl_stencil_pixels(ctx, PB->count, PB->x, PB->y, mask);
#line 26951
          if (tmp___6 == 0) {
            goto CleanUp;
          }
#line 26955
          gl_depth_stencil_pixels(ctx, PB->count, PB->x, PB->y, PB->z, mask);
        } else {
#line 26957
          if (ctx->Depth.Test) {
#line 26959
            (*(ctx->Driver.DepthTestPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                             (GLint const   *)(PB->y), (GLdepth const   *)(PB->z),
                                             mask);
          }
        }
#line 26961
        if (ctx->RasterMask & 2048U) {
          goto CleanUp;
        }
#line 26964
        (*(ctx->Driver.Index))(ctx, PB->index);
#line 26965
        (*(ctx->Driver.WriteMonoindexPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                              (GLint const   *)(PB->y), (GLubyte const   *)(mask));
#line 26966
        if (ctx->RasterMask & 1024U) {
#line 26967
          (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 26968
          (*(ctx->Driver.WriteMonoindexPixels))(ctx, PB->count, (GLint const   *)(PB->x),
                                                (GLint const   *)(PB->y), (GLubyte const   *)(mask));
#line 26969
          (*(ctx->Driver.SetBuffer))(ctx, 1028);
        }
      }
    }
  }
  CleanUp: 
#line 26974
  PB->count = 0U;
#line 26980
  return;
}
}
#line 26986 "D:/a/test/177.c"
static void update_drawpixels_state(GLcontext *ctx ) 
{ 

  {
#line 26988
  if ((int )(ctx->Visual)->RGBAflag == 1) {
#line 26988
    if ((ctx->Visual)->EightBitColor) {
#line 26988
      if ((double )ctx->Pixel.RedBias == 0.0) {
#line 26988
        if ((double )ctx->Pixel.RedScale == 1.0) {
#line 26988
          if ((double )ctx->Pixel.GreenBias == 0.0) {
#line 26988
            if ((double )ctx->Pixel.GreenScale == 1.0) {
#line 26988
              if ((double )ctx->Pixel.BlueBias == 0.0) {
#line 26988
                if ((double )ctx->Pixel.BlueScale == 1.0) {
#line 26988
                  if ((double )ctx->Pixel.AlphaBias == 0.0) {
#line 26988
                    if ((double )ctx->Pixel.AlphaScale == 1.0) {
#line 26988
                      if ((int )ctx->Pixel.MapColorFlag == 0) {
#line 26988
                        if ((double )ctx->Pixel.ZoomX == 1.0) {
#line 26988
                          if ((double )ctx->Pixel.ZoomY == 1.0) {
#line 26988
                            if (ctx->Unpack.RowLength == 0) {
#line 26988
                              if (ctx->Unpack.SkipPixels == 0) {
#line 26988
                                if (ctx->Unpack.SkipRows == 0) {
#line 26988
                                  if ((int )ctx->Unpack.SwapBytes == 0) {
#line 26988
                                    if ((int )ctx->Unpack.LsbFirst == 0) {
#line 27001
                                      ctx->FastDrawPixels = (unsigned char)1;
                                    } else {
#line 27004
                                      ctx->FastDrawPixels = (unsigned char)0;
                                    }
                                  } else {
#line 27004
                                    ctx->FastDrawPixels = (unsigned char)0;
                                  }
                                } else {
#line 27004
                                  ctx->FastDrawPixels = (unsigned char)0;
                                }
                              } else {
#line 27004
                                ctx->FastDrawPixels = (unsigned char)0;
                              }
                            } else {
#line 27004
                              ctx->FastDrawPixels = (unsigned char)0;
                            }
                          } else {
#line 27004
                            ctx->FastDrawPixels = (unsigned char)0;
                          }
                        } else {
#line 27004
                          ctx->FastDrawPixels = (unsigned char)0;
                        }
                      } else {
#line 27004
                        ctx->FastDrawPixels = (unsigned char)0;
                      }
                    } else {
#line 27004
                      ctx->FastDrawPixels = (unsigned char)0;
                    }
                  } else {
#line 27004
                    ctx->FastDrawPixels = (unsigned char)0;
                  }
                } else {
#line 27004
                  ctx->FastDrawPixels = (unsigned char)0;
                }
              } else {
#line 27004
                ctx->FastDrawPixels = (unsigned char)0;
              }
            } else {
#line 27004
              ctx->FastDrawPixels = (unsigned char)0;
            }
          } else {
#line 27004
            ctx->FastDrawPixels = (unsigned char)0;
          }
        } else {
#line 27004
          ctx->FastDrawPixels = (unsigned char)0;
        }
      } else {
#line 27004
        ctx->FastDrawPixels = (unsigned char)0;
      }
    } else {
#line 27004
      ctx->FastDrawPixels = (unsigned char)0;
    }
  } else {
#line 27004
    ctx->FastDrawPixels = (unsigned char)0;
  }
#line 27006
  return;
}
}
#line 27007 "D:/a/test/177.c"
void gl_PixelZoom(GLcontext *ctx , float xfactor , float yfactor ) 
{ 

  {
#line 27009
  if (ctx->Primitive != 6656) {
#line 27010
    gl_error(ctx, 1282, "glPixelZoom");
#line 27011
    return;
  }
#line 27013
  ctx->Pixel.ZoomX = xfactor;
#line 27014
  ctx->Pixel.ZoomY = yfactor;
#line 27015
  update_drawpixels_state(ctx);
#line 27016
  return;
}
}
#line 27017 "D:/a/test/177.c"
void gl_write_zoomed_color_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth const   *z ,
                                GLubyte const   *red , GLubyte const   *green , GLubyte const   *blue___0 ,
                                GLubyte const   *alpha , GLint y0___0 ) 
{ GLint m ;
  GLint r0 ;
  GLint r1 ;
  GLint row ;
  GLint r ;
  GLint i ;
  GLint j ;
  GLint skipcol ;
  GLubyte zred[640] ;
  GLubyte zgreen[640] ;
  GLubyte zblue[640] ;
  GLubyte zalpha[640] ;
  GLdepth zdepth[640] ;
  GLint maxwidth ;
  GLint tmp___0 ;
  float tmp___1 ;
  GLint rtmp ;
  float xscale ;

  {
#line 27030
  if ((ctx->Buffer)->Width < 640) {
#line 27030
    tmp___0 = (ctx->Buffer)->Width;
  } else {
#line 27030
    tmp___0 = 640;
  }
#line 27030
  maxwidth = tmp___0;
#line 27031
  if ((float )n * ctx->Pixel.ZoomX < 0.0F) {
#line 27031
    tmp___1 = - ((float )n * ctx->Pixel.ZoomX);
  } else {
#line 27031
    tmp___1 = (float )n * ctx->Pixel.ZoomX;
  }
#line 27031
  m = (int )tmp___1;
#line 27032
  if (m == 0) {
#line 27033
    return;
  }
#line 27035
  if ((double )ctx->Pixel.ZoomX < 0.0) {
#line 27036
    x -= m;
  }
#line 27038
  row = y - y0___0;
#line 27039
  r0 = y0___0 + (int )((float )row * ctx->Pixel.ZoomY);
#line 27040
  r1 = y0___0 + (int )((float )(row + 1) * ctx->Pixel.ZoomY);
#line 27041
  if (r0 == r1) {
#line 27042
    return;
  } else {
#line 27044
    if (r1 < r0) {
#line 27045
      rtmp = r1;
#line 27046
      r1 = r0;
#line 27047
      r0 = rtmp;
    }
  }
#line 27049
  if (r0 < 0) {
#line 27049
    if (r1 < 0) {
#line 27050
      return;
    }
  }
#line 27052
  if (r0 >= (ctx->Buffer)->Height) {
#line 27052
    if (r1 >= (ctx->Buffer)->Height) {
#line 27053
      return;
    }
  }
#line 27055
  skipcol = 0;
#line 27056
  if (x < 0) {
#line 27057
    skipcol = - x;
#line 27058
    m += x;
  }
#line 27060
  if (m > maxwidth) {
#line 27061
    m = maxwidth;
  } else {
#line 27063
    if (m <= 0) {
#line 27064
      return;
    }
  }
#line 27066
  //assert(m <= 640);
#line 27067
  if (ctx->Pixel.ZoomX == - 1.0F) {
#line 27068
    j = 0;
#line 27068
    while (j < m) {
#line 27069
      i = (int )((n - (GLuint )(j + skipcol)) - 1U);
#line 27070
      zred[j] = (unsigned char )*(red + i);
#line 27071
      zgreen[j] = (unsigned char )*(green + i);
#line 27072
      zblue[j] = (unsigned char )*(blue___0 + i);
#line 27073
      zalpha[j] = (unsigned char )*(alpha + i);
#line 27074
      zdepth[j] = (unsigned short )*(z + i);
#line 27068
      j ++;
    }
  } else {
#line 27078
    xscale = 1.0F / ctx->Pixel.ZoomX;
#line 27079
    j = 0;
#line 27079
    while (j < m) {
#line 27080
      i = (int )((float )(j + skipcol) * xscale);
#line 27081
      if (i < 0) {
#line 27081
        i = (int )((n + (GLuint )i) - 1U);
      }
#line 27082
      zred[j] = (unsigned char )*(red + i);
#line 27083
      zgreen[j] = (unsigned char )*(green + i);
#line 27084
      zblue[j] = (unsigned char )*(blue___0 + i);
#line 27085
      zalpha[j] = (unsigned char )*(alpha + i);
#line 27086
      zdepth[j] = (unsigned short )*(z + i);
#line 27079
      j ++;
    }
  }
#line 27089
  r = r0;
#line 27089
  while (r < r1) {
#line 27090
    gl_write_color_span(ctx, m, x + skipcol, r, zdepth, zred, zgreen, zblue, zalpha,
                        6656);
#line 27089
    r ++;
  }
#line 27093
  return;
}
}
#line 27094 "D:/a/test/177.c"
void gl_write_zoomed_index_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth const   *z ,
                                GLuint const   *indexes , GLint y0___0 ) 
{ GLint m ;
  GLint r0 ;
  GLint r1 ;
  GLint row ;
  GLint r ;
  GLint i ;
  GLint j ;
  GLint skipcol ;
  GLuint zindexes[640] ;
  GLdepth zdepth[640] ;
  GLint maxwidth ;
  GLint tmp___0 ;
  float tmp___1 ;
  GLint rtmp ;
  float xscale ;

  {
#line 27104
  if ((ctx->Buffer)->Width < 640) {
#line 27104
    tmp___0 = (ctx->Buffer)->Width;
  } else {
#line 27104
    tmp___0 = 640;
  }
#line 27104
  maxwidth = tmp___0;
#line 27105
  if ((float )n * ctx->Pixel.ZoomX < 0.0F) {
#line 27105
    tmp___1 = - ((float )n * ctx->Pixel.ZoomX);
  } else {
#line 27105
    tmp___1 = (float )n * ctx->Pixel.ZoomX;
  }
#line 27105
  m = (int )tmp___1;
#line 27106
  if (m == 0) {
#line 27107
    return;
  }
#line 27109
  if ((double )ctx->Pixel.ZoomX < 0.0) {
#line 27110
    x -= m;
  }
#line 27112
  row = y - y0___0;
#line 27113
  r0 = y0___0 + (int )((float )row * ctx->Pixel.ZoomY);
#line 27114
  r1 = y0___0 + (int )((float )(row + 1) * ctx->Pixel.ZoomY);
#line 27115
  if (r0 == r1) {
#line 27116
    return;
  } else {
#line 27118
    if (r1 < r0) {
#line 27119
      rtmp = r1;
#line 27120
      r1 = r0;
#line 27121
      r0 = rtmp;
    }
  }
#line 27123
  if (r0 < 0) {
#line 27123
    if (r1 < 0) {
#line 27124
      return;
    }
  }
#line 27126
  if (r0 >= (ctx->Buffer)->Height) {
#line 27126
    if (r1 >= (ctx->Buffer)->Height) {
#line 27127
      return;
    }
  }
#line 27129
  skipcol = 0;
#line 27130
  if (x < 0) {
#line 27131
    skipcol = - x;
#line 27132
    m += x;
  }
#line 27134
  if (m > maxwidth) {
#line 27135
    m = maxwidth;
  } else {
#line 27137
    if (m <= 0) {
#line 27138
      return;
    }
  }
#line 27140
  //assert(m <= 640);
#line 27141
  if (ctx->Pixel.ZoomX == - 1.0F) {
#line 27142
    j = 0;
#line 27142
    while (j < m) {
#line 27143
      i = (int )((n - (GLuint )(j + skipcol)) - 1U);
#line 27144
      zindexes[j] = (unsigned int )*(indexes + i);
#line 27145
      zdepth[j] = (unsigned short )*(z + i);
#line 27142
      j ++;
    }
  } else {
#line 27149
    xscale = 1.0F / ctx->Pixel.ZoomX;
#line 27150
    j = 0;
#line 27150
    while (j < m) {
#line 27151
      i = (int )((float )(j + skipcol) * xscale);
#line 27152
      if (i < 0) {
#line 27152
        i = (int )((n + (GLuint )i) - 1U);
      }
#line 27153
      zindexes[j] = (unsigned int )*(indexes + i);
#line 27154
      zdepth[j] = (unsigned short )*(z + i);
#line 27150
      j ++;
    }
  }
#line 27157
  r = r0;
#line 27157
  while (r < r1) {
#line 27158
    gl_write_index_span(ctx, m, x + skipcol, r, zdepth, zindexes, 6656);
#line 27157
    r ++;
  }
#line 27160
  return;
}
}
#line 27161 "D:/a/test/177.c"
void gl_write_zoomed_stencil_span(GLcontext *ctx , GLuint n , GLint x , GLint y ,
                                  GLubyte const   *stencil , GLint y0___0 ) 
{ GLint m ;
  GLint r0 ;
  GLint r1 ;
  GLint row ;
  GLint r ;
  GLint i ;
  GLint j ;
  GLint skipcol ;
  GLubyte zstencil[640] ;
  GLint maxwidth ;
  GLint tmp___0 ;
  float tmp___1 ;
  GLint rtmp ;
  float xscale ;

  {
#line 27170
  if ((ctx->Buffer)->Width < 640) {
#line 27170
    tmp___0 = (ctx->Buffer)->Width;
  } else {
#line 27170
    tmp___0 = 640;
  }
#line 27170
  maxwidth = tmp___0;
#line 27171
  if ((float )n * ctx->Pixel.ZoomX < 0.0F) {
#line 27171
    tmp___1 = - ((float )n * ctx->Pixel.ZoomX);
  } else {
#line 27171
    tmp___1 = (float )n * ctx->Pixel.ZoomX;
  }
#line 27171
  m = (int )tmp___1;
#line 27172
  if (m == 0) {
#line 27173
    return;
  }
#line 27175
  if ((double )ctx->Pixel.ZoomX < 0.0) {
#line 27176
    x -= m;
  }
#line 27178
  row = y - y0___0;
#line 27179
  r0 = y0___0 + (int )((float )row * ctx->Pixel.ZoomY);
#line 27180
  r1 = y0___0 + (int )((float )(row + 1) * ctx->Pixel.ZoomY);
#line 27181
  if (r0 == r1) {
#line 27182
    return;
  } else {
#line 27184
    if (r1 < r0) {
#line 27185
      rtmp = r1;
#line 27186
      r1 = r0;
#line 27187
      r0 = rtmp;
    }
  }
#line 27189
  if (r0 < 0) {
#line 27189
    if (r1 < 0) {
#line 27190
      return;
    }
  }
#line 27192
  if (r0 >= (ctx->Buffer)->Height) {
#line 27192
    if (r1 >= (ctx->Buffer)->Height) {
#line 27193
      return;
    }
  }
#line 27195
  skipcol = 0;
#line 27196
  if (x < 0) {
#line 27197
    skipcol = - x;
#line 27198
    m += x;
  }
#line 27200
  if (m > maxwidth) {
#line 27201
    m = maxwidth;
  } else {
#line 27203
    if (m <= 0) {
#line 27204
      return;
    }
  }
#line 27206
  //assert(m <= 640);
#line 27207
  if (ctx->Pixel.ZoomX == - 1.0F) {
#line 27208
    j = 0;
#line 27208
    while (j < m) {
#line 27209
      i = (int )((n - (GLuint )(j + skipcol)) - 1U);
#line 27210
      zstencil[j] = (unsigned char )*(stencil + i);
#line 27208
      j ++;
    }
  } else {
#line 27214
    xscale = 1.0F / ctx->Pixel.ZoomX;
#line 27215
    j = 0;
#line 27215
    while (j < m) {
#line 27216
      i = (int )((float )(j + skipcol) * xscale);
#line 27217
      if (i < 0) {
#line 27217
        i = (int )((n + (GLuint )i) - 1U);
      }
#line 27218
      zstencil[j] = (unsigned char )*(stencil + i);
#line 27215
      j ++;
    }
  }
#line 27221
  r = r0;
#line 27221
  while (r < r1) {
#line 27222
    gl_write_stencil_span(ctx, m, x + skipcol, r, zstencil);
#line 27221
    r ++;
  }
#line 27224
  return;
}
}
#line 27225 "D:/a/test/177.c"
void gl_PixelStorei(GLcontext *ctx , GLenum pname , GLint param ) 
{ 

  {
#line 27227
  if (ctx->Primitive != 6656) {
#line 27228
    gl_error(ctx, 1282, "glPixelStore");
#line 27229
    return;
  }
#line 27231
  switch (pname) {
  case 3328: 
#line 27233
  if (param) {
#line 27233
    ctx->Pack.SwapBytes = (unsigned char)1;
  } else {
#line 27233
    ctx->Pack.SwapBytes = (unsigned char)0;
  }
#line 27234
  break;
  case 3329: 
#line 27236
  if (param) {
#line 27236
    ctx->Pack.LsbFirst = (unsigned char)1;
  } else {
#line 27236
    ctx->Pack.LsbFirst = (unsigned char)0;
  }
#line 27237
  break;
  case 3330: 
#line 27239
  if (param < 0) {
#line 27240
    gl_error(ctx, 1281, "glPixelStore(param)");
  } else {
#line 27243
    ctx->Pack.RowLength = param;
  }
#line 27245
  break;
  case 3332: 
#line 27247
  if (param < 0) {
#line 27248
    gl_error(ctx, 1281, "glPixelStore(param)");
  } else {
#line 27251
    ctx->Pack.SkipPixels = param;
  }
#line 27253
  break;
  case 3331: 
#line 27255
  if (param < 0) {
#line 27256
    gl_error(ctx, 1281, "glPixelStore(param)");
  } else {
#line 27259
    ctx->Pack.SkipRows = param;
  }
#line 27261
  break;
  case 3333: 
#line 27263
  if (param == 1) {
#line 27264
    ctx->Pack.Alignment = param;
  } else {
#line 27263
    if (param == 2) {
#line 27264
      ctx->Pack.Alignment = param;
    } else {
#line 27263
      if (param == 4) {
#line 27264
        ctx->Pack.Alignment = param;
      } else {
#line 27263
        if (param == 8) {
#line 27264
          ctx->Pack.Alignment = param;
        } else {
#line 27267
          gl_error(ctx, 1281, "glPixelStore(param)");
        }
      }
    }
  }
#line 27269
  break;
  case 3312: 
#line 27271
  if (param) {
#line 27271
    ctx->Unpack.SwapBytes = (unsigned char)1;
  } else {
#line 27271
    ctx->Unpack.SwapBytes = (unsigned char)0;
  }
#line 27272
  break;
  case 3313: 
#line 27274
  if (param) {
#line 27274
    ctx->Unpack.LsbFirst = (unsigned char)1;
  } else {
#line 27274
    ctx->Unpack.LsbFirst = (unsigned char)0;
  }
#line 27275
  break;
  case 3314: 
#line 27277
  if (param < 0) {
#line 27278
    gl_error(ctx, 1281, "glPixelStore(param)");
  } else {
#line 27281
    ctx->Unpack.RowLength = param;
  }
#line 27283
  break;
  case 3316: 
#line 27285
  if (param < 0) {
#line 27286
    gl_error(ctx, 1281, "glPixelStore(param)");
  } else {
#line 27289
    ctx->Unpack.SkipPixels = param;
  }
#line 27291
  break;
  case 3315: 
#line 27293
  if (param < 0) {
#line 27294
    gl_error(ctx, 1281, "glPixelStore(param)");
  } else {
#line 27297
    ctx->Unpack.SkipRows = param;
  }
#line 27299
  break;
  case 3317: 
#line 27301
  if (param == 1) {
#line 27302
    ctx->Unpack.Alignment = param;
  } else {
#line 27301
    if (param == 2) {
#line 27302
      ctx->Unpack.Alignment = param;
    } else {
#line 27301
      if (param == 4) {
#line 27302
        ctx->Unpack.Alignment = param;
      } else {
#line 27301
        if (param == 8) {
#line 27302
          ctx->Unpack.Alignment = param;
        } else {
#line 27305
          gl_error(ctx, 1281, "glPixelStore");
        }
      }
    }
  }
#line 27307
  break;
  default: 
#line 27309
  gl_error(ctx, 1280, "glPixelStore");
  }
#line 27311
  update_drawpixels_state(ctx);
#line 27312
  return;
}
}
#line 27313 "D:/a/test/177.c"
void gl_PixelMapfv(GLcontext *ctx , GLenum map , GLint mapsize , float const   *values ) 
{ GLuint i ;
  GLuint p ;
  GLboolean ok ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;

  {
#line 27317
  if (ctx->Primitive != 6656) {
#line 27318
    gl_error(ctx, 1282, "glPixelMapfv");
#line 27319
    return;
  }
#line 27321
  if (mapsize < 0) {
#line 27322
    gl_error(ctx, 1281, "glPixelMapfv(mapsize)");
#line 27323
    return;
  } else {
#line 27321
    if (mapsize > 256) {
#line 27322
      gl_error(ctx, 1281, "glPixelMapfv(mapsize)");
#line 27323
      return;
    }
  }
#line 27325
  if (map >= 3185) {
#line 27325
    if (map <= 3189) {
#line 27327
      ok = (GLboolean )0;
#line 27328
      p = 1U;
#line 27328
      while (p <= 256U) {
#line 27329
        if ((p & (unsigned int )mapsize) == p) {
#line 27330
          ok = (unsigned char)1;
#line 27331
          break;
        }
#line 27328
        p <<= 1;
      }
#line 27334
      if (! ok) {
#line 27335
        gl_error(ctx, 1281, "glPixelMapfv(mapsize)");
#line 27336
        return;
      }
    }
  }
#line 27339
  switch (map) {
  case 3185: 
#line 27341
  ctx->Pixel.MapStoSsize = mapsize;
#line 27342
  i = 0U;
#line 27342
  while (i < (GLuint )mapsize) {
#line 27343
    ctx->Pixel.MapStoS[i] = (int )*(values + i);
#line 27342
    i ++;
  }
#line 27345
  break;
  case 3184: 
#line 27347
  ctx->Pixel.MapItoIsize = mapsize;
#line 27348
  i = 0U;
#line 27348
  while (i < (GLuint )mapsize) {
#line 27349
    ctx->Pixel.MapItoI[i] = (int )*(values + i);
#line 27348
    i ++;
  }
#line 27351
  break;
  case 3186: 
#line 27353
  ctx->Pixel.MapItoRsize = mapsize;
#line 27354
  i = 0U;
#line 27354
  while (i < (GLuint )mapsize) {
#line 27355
    if ((double )*(values + i) < 0.0) {
#line 27355
      ctx->Pixel.MapItoR[i] = (float )0.0;
    } else {
#line 27355
      if ((double )*(values + i) > 1.0) {
#line 27355
        tmp___0 = 1.0;
      } else {
#line 27355
        tmp___0 = (double )*(values + i);
      }
#line 27355
      ctx->Pixel.MapItoR[i] = (float )tmp___0;
    }
#line 27354
    i ++;
  }
#line 27357
  break;
  case 3187: 
#line 27359
  ctx->Pixel.MapItoGsize = mapsize;
#line 27360
  i = 0U;
#line 27360
  while (i < (GLuint )mapsize) {
#line 27361
    if ((double )*(values + i) < 0.0) {
#line 27361
      ctx->Pixel.MapItoG[i] = (float )0.0;
    } else {
#line 27361
      if ((double )*(values + i) > 1.0) {
#line 27361
        tmp___1 = 1.0;
      } else {
#line 27361
        tmp___1 = (double )*(values + i);
      }
#line 27361
      ctx->Pixel.MapItoG[i] = (float )tmp___1;
    }
#line 27360
    i ++;
  }
#line 27363
  break;
  case 3188: 
#line 27365
  ctx->Pixel.MapItoBsize = mapsize;
#line 27366
  i = 0U;
#line 27366
  while (i < (GLuint )mapsize) {
#line 27367
    if ((double )*(values + i) < 0.0) {
#line 27367
      ctx->Pixel.MapItoB[i] = (float )0.0;
    } else {
#line 27367
      if ((double )*(values + i) > 1.0) {
#line 27367
        tmp___2 = 1.0;
      } else {
#line 27367
        tmp___2 = (double )*(values + i);
      }
#line 27367
      ctx->Pixel.MapItoB[i] = (float )tmp___2;
    }
#line 27366
    i ++;
  }
#line 27369
  break;
  case 3189: 
#line 27371
  ctx->Pixel.MapItoAsize = mapsize;
#line 27372
  i = 0U;
#line 27372
  while (i < (GLuint )mapsize) {
#line 27373
    if ((double )*(values + i) < 0.0) {
#line 27373
      ctx->Pixel.MapItoA[i] = (float )0.0;
    } else {
#line 27373
      if ((double )*(values + i) > 1.0) {
#line 27373
        tmp___3 = 1.0;
      } else {
#line 27373
        tmp___3 = (double )*(values + i);
      }
#line 27373
      ctx->Pixel.MapItoA[i] = (float )tmp___3;
    }
#line 27372
    i ++;
  }
#line 27375
  break;
  case 3190: 
#line 27377
  ctx->Pixel.MapRtoRsize = mapsize;
#line 27378
  i = 0U;
#line 27378
  while (i < (GLuint )mapsize) {
#line 27379
    if ((double )*(values + i) < 0.0) {
#line 27379
      ctx->Pixel.MapRtoR[i] = (float )0.0;
    } else {
#line 27379
      if ((double )*(values + i) > 1.0) {
#line 27379
        tmp___4 = 1.0;
      } else {
#line 27379
        tmp___4 = (double )*(values + i);
      }
#line 27379
      ctx->Pixel.MapRtoR[i] = (float )tmp___4;
    }
#line 27378
    i ++;
  }
#line 27381
  break;
  case 3191: 
#line 27383
  ctx->Pixel.MapGtoGsize = mapsize;
#line 27384
  i = 0U;
#line 27384
  while (i < (GLuint )mapsize) {
#line 27385
    if ((double )*(values + i) < 0.0) {
#line 27385
      ctx->Pixel.MapGtoG[i] = (float )0.0;
    } else {
#line 27385
      if ((double )*(values + i) > 1.0) {
#line 27385
        tmp___5 = 1.0;
      } else {
#line 27385
        tmp___5 = (double )*(values + i);
      }
#line 27385
      ctx->Pixel.MapGtoG[i] = (float )tmp___5;
    }
#line 27384
    i ++;
  }
#line 27387
  break;
  case 3192: 
#line 27389
  ctx->Pixel.MapBtoBsize = mapsize;
#line 27390
  i = 0U;
#line 27390
  while (i < (GLuint )mapsize) {
#line 27391
    if ((double )*(values + i) < 0.0) {
#line 27391
      ctx->Pixel.MapBtoB[i] = (float )0.0;
    } else {
#line 27391
      if ((double )*(values + i) > 1.0) {
#line 27391
        tmp___6 = 1.0;
      } else {
#line 27391
        tmp___6 = (double )*(values + i);
      }
#line 27391
      ctx->Pixel.MapBtoB[i] = (float )tmp___6;
    }
#line 27390
    i ++;
  }
#line 27393
  break;
  case 3193: 
#line 27395
  ctx->Pixel.MapAtoAsize = mapsize;
#line 27396
  i = 0U;
#line 27396
  while (i < (GLuint )mapsize) {
#line 27397
    if ((double )*(values + i) < 0.0) {
#line 27397
      ctx->Pixel.MapAtoA[i] = (float )0.0;
    } else {
#line 27397
      if ((double )*(values + i) > 1.0) {
#line 27397
        tmp___7 = 1.0;
      } else {
#line 27397
        tmp___7 = (double )*(values + i);
      }
#line 27397
      ctx->Pixel.MapAtoA[i] = (float )tmp___7;
    }
#line 27396
    i ++;
  }
#line 27399
  break;
  default: 
#line 27401
  gl_error(ctx, 1280, "glPixelMapfv(map)");
  }
#line 27403
  return;
}
}
#line 27404 "D:/a/test/177.c"
void gl_GetPixelMapfv(GLcontext *ctx , GLenum map , float *values ) 
{ GLuint i ;

  {
#line 27407
  if (ctx->Primitive != 6656) {
#line 27408
    gl_error(ctx, 1282, "glGetPixelMapfv");
#line 27409
    return;
  }
#line 27411
  switch (map) {
  case 3184: 
#line 27413
  i = 0U;
#line 27413
  while (i < (GLuint )ctx->Pixel.MapItoIsize) {
#line 27414
    *(values + i) = (float )ctx->Pixel.MapItoI[i];
#line 27413
    i ++;
  }
#line 27416
  break;
  case 3185: 
#line 27418
  i = 0U;
#line 27418
  while (i < (GLuint )ctx->Pixel.MapStoSsize) {
#line 27419
    *(values + i) = (float )ctx->Pixel.MapStoS[i];
#line 27418
    i ++;
  }
#line 27421
  break;
  case 3186: 
#line 27423
  memcpy((void *)values, (void const   *)((void *)(ctx->Pixel.MapItoR)), (unsigned int )ctx->Pixel.MapItoRsize * sizeof(float ));
#line 27424
  break;
  case 3187: 
#line 27426
  memcpy((void *)values, (void const   *)((void *)(ctx->Pixel.MapItoG)), (unsigned int )ctx->Pixel.MapItoGsize * sizeof(float ));
#line 27427
  break;
  case 3188: 
#line 27429
  memcpy((void *)values, (void const   *)((void *)(ctx->Pixel.MapItoB)), (unsigned int )ctx->Pixel.MapItoBsize * sizeof(float ));
#line 27430
  break;
  case 3189: 
#line 27432
  memcpy((void *)values, (void const   *)((void *)(ctx->Pixel.MapItoA)), (unsigned int )ctx->Pixel.MapItoAsize * sizeof(float ));
#line 27433
  break;
  case 3190: 
#line 27435
  memcpy((void *)values, (void const   *)((void *)(ctx->Pixel.MapRtoR)), (unsigned int )ctx->Pixel.MapRtoRsize * sizeof(float ));
#line 27436
  break;
  case 3191: 
#line 27438
  memcpy((void *)values, (void const   *)((void *)(ctx->Pixel.MapGtoG)), (unsigned int )ctx->Pixel.MapGtoGsize * sizeof(float ));
#line 27439
  break;
  case 3192: 
#line 27441
  memcpy((void *)values, (void const   *)((void *)(ctx->Pixel.MapBtoB)), (unsigned int )ctx->Pixel.MapBtoBsize * sizeof(float ));
#line 27442
  break;
  case 3193: 
#line 27444
  memcpy((void *)values, (void const   *)((void *)(ctx->Pixel.MapAtoA)), (unsigned int )ctx->Pixel.MapAtoAsize * sizeof(float ));
#line 27445
  break;
  default: 
#line 27447
  gl_error(ctx, 1280, "glGetPixelMapfv");
  }
#line 27449
  return;
}
}
#line 27450 "D:/a/test/177.c"
void gl_GetPixelMapuiv(GLcontext *ctx , GLenum map , GLuint *values ) 
{ GLuint i ;

  {
#line 27453
  if (ctx->Primitive != 6656) {
#line 27454
    gl_error(ctx, 1282, "glGetPixelMapfv");
#line 27455
    return;
  }
#line 27457
  switch (map) {
  case 3184: 
#line 27459
  memcpy((void *)values, (void const   *)((void *)(ctx->Pixel.MapItoI)), (unsigned int )ctx->Pixel.MapItoIsize * sizeof(GLint ));
#line 27460
  break;
  case 3185: 
#line 27462
  memcpy((void *)values, (void const   *)((void *)(ctx->Pixel.MapStoS)), (unsigned int )ctx->Pixel.MapStoSsize * sizeof(GLint ));
#line 27463
  break;
  case 3186: 
#line 27465
  i = 0U;
#line 27465
  while (i < (GLuint )ctx->Pixel.MapItoRsize) {
#line 27466
    *(values + i) = (unsigned int )((double )ctx->Pixel.MapItoR[i] * 4294967295.0);
#line 27465
    i ++;
  }
#line 27468
  break;
  case 3187: 
#line 27470
  i = 0U;
#line 27470
  while (i < (GLuint )ctx->Pixel.MapItoGsize) {
#line 27471
    *(values + i) = (unsigned int )((double )ctx->Pixel.MapItoG[i] * 4294967295.0);
#line 27470
    i ++;
  }
#line 27473
  break;
  case 3188: 
#line 27475
  i = 0U;
#line 27475
  while (i < (GLuint )ctx->Pixel.MapItoBsize) {
#line 27476
    *(values + i) = (unsigned int )((double )ctx->Pixel.MapItoB[i] * 4294967295.0);
#line 27475
    i ++;
  }
#line 27478
  break;
  case 3189: 
#line 27480
  i = 0U;
#line 27480
  while (i < (GLuint )ctx->Pixel.MapItoAsize) {
#line 27481
    *(values + i) = (unsigned int )((double )ctx->Pixel.MapItoA[i] * 4294967295.0);
#line 27480
    i ++;
  }
#line 27483
  break;
  case 3190: 
#line 27485
  i = 0U;
#line 27485
  while (i < (GLuint )ctx->Pixel.MapRtoRsize) {
#line 27486
    *(values + i) = (unsigned int )((double )ctx->Pixel.MapRtoR[i] * 4294967295.0);
#line 27485
    i ++;
  }
#line 27488
  break;
  case 3191: 
#line 27490
  i = 0U;
#line 27490
  while (i < (GLuint )ctx->Pixel.MapGtoGsize) {
#line 27491
    *(values + i) = (unsigned int )((double )ctx->Pixel.MapGtoG[i] * 4294967295.0);
#line 27490
    i ++;
  }
#line 27493
  break;
  case 3192: 
#line 27495
  i = 0U;
#line 27495
  while (i < (GLuint )ctx->Pixel.MapBtoBsize) {
#line 27496
    *(values + i) = (unsigned int )((double )ctx->Pixel.MapBtoB[i] * 4294967295.0);
#line 27495
    i ++;
  }
#line 27498
  break;
  case 3193: 
#line 27500
  i = 0U;
#line 27500
  while (i < (GLuint )ctx->Pixel.MapAtoAsize) {
#line 27501
    *(values + i) = (unsigned int )((double )ctx->Pixel.MapAtoA[i] * 4294967295.0);
#line 27500
    i ++;
  }
#line 27503
  break;
  default: 
#line 27505
  gl_error(ctx, 1280, "glGetPixelMapfv");
  }
#line 27507
  return;
}
}
#line 27508 "D:/a/test/177.c"
void gl_GetPixelMapusv(GLcontext *ctx , GLenum map , GLushort *values ) 
{ GLuint i ;

  {
#line 27511
  if (ctx->Primitive != 6656) {
#line 27512
    gl_error(ctx, 1282, "glGetPixelMapfv");
#line 27513
    return;
  }
#line 27515
  switch (map) {
  case 3184: 
#line 27517
  i = 0U;
#line 27517
  while (i < (GLuint )ctx->Pixel.MapItoIsize) {
#line 27518
    *(values + i) = (unsigned short )ctx->Pixel.MapItoI[i];
#line 27517
    i ++;
  }
#line 27520
  break;
  case 3185: 
#line 27522
  i = 0U;
#line 27522
  while (i < (GLuint )ctx->Pixel.MapStoSsize) {
#line 27523
    *(values + i) = (unsigned short )ctx->Pixel.MapStoS[i];
#line 27522
    i ++;
  }
#line 27525
  break;
  case 3186: 
#line 27527
  i = 0U;
#line 27527
  while (i < (GLuint )ctx->Pixel.MapItoRsize) {
#line 27528
    *(values + i) = (unsigned short )((int )(ctx->Pixel.MapItoR[i] * 65535.0F));
#line 27527
    i ++;
  }
#line 27530
  break;
  case 3187: 
#line 27532
  i = 0U;
#line 27532
  while (i < (GLuint )ctx->Pixel.MapItoGsize) {
#line 27533
    *(values + i) = (unsigned short )((int )(ctx->Pixel.MapItoG[i] * 65535.0F));
#line 27532
    i ++;
  }
#line 27535
  break;
  case 3188: 
#line 27537
  i = 0U;
#line 27537
  while (i < (GLuint )ctx->Pixel.MapItoBsize) {
#line 27538
    *(values + i) = (unsigned short )((int )(ctx->Pixel.MapItoB[i] * 65535.0F));
#line 27537
    i ++;
  }
#line 27540
  break;
  case 3189: 
#line 27542
  i = 0U;
#line 27542
  while (i < (GLuint )ctx->Pixel.MapItoAsize) {
#line 27543
    *(values + i) = (unsigned short )((int )(ctx->Pixel.MapItoA[i] * 65535.0F));
#line 27542
    i ++;
  }
#line 27545
  break;
  case 3190: 
#line 27547
  i = 0U;
#line 27547
  while (i < (GLuint )ctx->Pixel.MapRtoRsize) {
#line 27548
    *(values + i) = (unsigned short )((int )(ctx->Pixel.MapRtoR[i] * 65535.0F));
#line 27547
    i ++;
  }
#line 27550
  break;
  case 3191: 
#line 27552
  i = 0U;
#line 27552
  while (i < (GLuint )ctx->Pixel.MapGtoGsize) {
#line 27553
    *(values + i) = (unsigned short )((int )(ctx->Pixel.MapGtoG[i] * 65535.0F));
#line 27552
    i ++;
  }
#line 27555
  break;
  case 3192: 
#line 27557
  i = 0U;
#line 27557
  while (i < (GLuint )ctx->Pixel.MapBtoBsize) {
#line 27558
    *(values + i) = (unsigned short )((int )(ctx->Pixel.MapBtoB[i] * 65535.0F));
#line 27557
    i ++;
  }
#line 27560
  break;
  case 3193: 
#line 27562
  i = 0U;
#line 27562
  while (i < (GLuint )ctx->Pixel.MapAtoAsize) {
#line 27563
    *(values + i) = (unsigned short )((int )(ctx->Pixel.MapAtoA[i] * 65535.0F));
#line 27562
    i ++;
  }
#line 27565
  break;
  default: 
#line 27567
  gl_error(ctx, 1280, "glGetPixelMapfv");
  }
#line 27569
  return;
}
}
#line 27570 "D:/a/test/177.c"
void gl_PixelTransferf(GLcontext *ctx , GLenum pname , float param ) 
{ 

  {
#line 27572
  if (ctx->Primitive != 6656) {
#line 27573
    gl_error(ctx, 1282, "glPixelTransfer");
#line 27574
    return;
  }
#line 27576
  switch (pname) {
  case 3344: 
#line 27578
  if (param) {
#line 27578
    ctx->Pixel.MapColorFlag = (unsigned char)1;
  } else {
#line 27578
    ctx->Pixel.MapColorFlag = (unsigned char)0;
  }
#line 27579
  break;
  case 3345: 
#line 27581
  if (param) {
#line 27581
    ctx->Pixel.MapStencilFlag = (unsigned char)1;
  } else {
#line 27581
    ctx->Pixel.MapStencilFlag = (unsigned char)0;
  }
#line 27582
  break;
  case 3346: 
#line 27584
  ctx->Pixel.IndexShift = (int )param;
#line 27585
  break;
  case 3347: 
#line 27587
  ctx->Pixel.IndexOffset = (int )param;
#line 27588
  break;
  case 3348: 
#line 27590
  ctx->Pixel.RedScale = param;
#line 27591
  break;
  case 3349: 
#line 27593
  ctx->Pixel.RedBias = param;
#line 27594
  break;
  case 3352: 
#line 27596
  ctx->Pixel.GreenScale = param;
#line 27597
  break;
  case 3353: 
#line 27599
  ctx->Pixel.GreenBias = param;
#line 27600
  break;
  case 3354: 
#line 27602
  ctx->Pixel.BlueScale = param;
#line 27603
  break;
  case 3355: 
#line 27605
  ctx->Pixel.BlueBias = param;
#line 27606
  break;
  case 3356: 
#line 27608
  ctx->Pixel.AlphaScale = param;
#line 27609
  break;
  case 3357: 
#line 27611
  ctx->Pixel.AlphaBias = param;
#line 27612
  break;
  case 3358: 
#line 27614
  ctx->Pixel.DepthScale = param;
#line 27615
  break;
  case 3359: 
#line 27617
  ctx->Pixel.DepthBias = param;
#line 27618
  break;
  default: 
#line 27620
  gl_error(ctx, 1280, "glPixelTransfer(pname)");
#line 27621
  return;
  }
#line 27623
  update_drawpixels_state(ctx);
#line 27624
  return;
}
}
#line 27625 "D:/a/test/177.c"
GLvoid *gl_unpack_pixels(GLcontext *ctx , GLsizei width , GLsizei height , GLenum format ,
                         GLenum type , GLvoid const   *pixels ) 
{ GLint s ;
  GLint n ;
  GLint bytes ;
  GLint i ;
  GLint width_in_bytes ;
  GLubyte *buffer ;
  GLubyte *dst ;
  GLvoid *src ;
  void *tmp___0 ;
  GLint width_in_bytes___0 ;
  GLint bytes___0 ;
  GLint i___0 ;
  GLubyte *buffer___0 ;
  GLubyte *dst___0 ;
  GLvoid *src___0 ;
  void *tmp___1 ;

  {
#line 27631
  s = gl_sizeof_type(type);
#line 27632
  if (s < 0) {
#line 27633
    gl_error(ctx, 1280, "internal error in gl_unpack(type)");
#line 27634
    return ((void *)0);
  }
#line 27636
  n = gl_components_in_format(format);
#line 27637
  if (n < 0) {
#line 27638
    gl_error(ctx, 1280, "gl_unpack_pixels(format)");
#line 27639
    return ((void *)0);
  }
#line 27641
  if (type == 6656) {
#line 27645
    if ((width * height) % 8 == 0) {
#line 27645
      bytes = (width * height) / 8;
    } else {
#line 27645
      bytes = (width * height) / 8 + 1;
    }
#line 27646
    tmp___0 = malloc((unsigned int )bytes);//39
#line 27646
    buffer = (GLubyte *)tmp___0;
#line 27647
    if (! buffer) {
#line 27648
      return ((void *)0);
    }
#line 27650
    if (width % 8 == 0) {
#line 27650
      width_in_bytes = width / 8;
    } else {
#line 27650
      width_in_bytes = width / 8 + 1;
    }
#line 27651
    dst = buffer;
#line 27652
    i = 0;
#line 27652
    while (i < height) {
#line 27653
      src = gl_pixel_addr_in_image(& ctx->Unpack, pixels, width, height, format, type,
                                   0, i, 0);
#line 27655
      if (! src) {
#line 27656
        free((void *)buffer);
#line 27657
        return ((void *)0);
      }
#line 27659
      memcpy((void *)dst, (void const   *)src, (unsigned int )width_in_bytes);
#line 27660
      dst += width_in_bytes;
#line 27652
      i ++;
    }
#line 27662
    if (ctx->Unpack.LsbFirst) {
#line 27663
      gl_flip_bytes(buffer, (unsigned int )bytes);
    }
#line 27665
    return ((GLvoid *)buffer);
  } else {
#line 27671
    width_in_bytes___0 = (width * n) * s;
#line 27672
    bytes___0 = height * width_in_bytes___0;
#line 27673
    tmp___1 = malloc((unsigned int )bytes___0);//40
#line 27673
    buffer___0 = (GLubyte *)tmp___1;
#line 27674
    if (! buffer___0) {
#line 27675
      return ((void *)0);
    }
#line 27677
    dst___0 = buffer___0;
#line 27678
    i___0 = 0;
#line 27678
    while (i___0 < height) {
#line 27679
      src___0 = gl_pixel_addr_in_image(& ctx->Unpack, pixels, width, height, format,
                                       type, 0, i___0, 0);
#line 27681
      if (! src___0) {
#line 27682
        free((void *)buffer___0);
#line 27683
        return ((void *)0);
      }
#line 27685
      memcpy((void *)dst___0, (void const   *)src___0, (unsigned int )width_in_bytes___0);
#line 27686
      dst___0 += width_in_bytes___0;
#line 27678
      i___0 ++;
    }
#line 27688
    if (ctx->Unpack.SwapBytes) {
#line 27688
      if (s > 1) {
#line 27689
        if (s == 2) {
#line 27690
          gl_swap2((GLushort *)buffer___0, (unsigned int )(bytes___0 / 2));
        } else {
#line 27692
          if (s == 4) {
#line 27693
            gl_swap4((GLuint *)buffer___0, (unsigned int )(bytes___0 / 4));
          }
        }
      }
    }
#line 27696
    return ((GLvoid *)buffer___0);
  }
}
}
#line 27704 "D:/a/test/177.c"
static void check_pointers(struct gl_api_table *table ) 
{ void **entry ;
  int numentries ;
  int i ;

  {
#line 27707
  numentries = (int )(sizeof(struct gl_api_table ) / sizeof(void *));
#line 27709
  entry = (void **)table;
#line 27710
  i = 0;
#line 27710
  while (i < numentries) {
#line 27711
    if (! *(entry + i)) {
#line 27712
      printf("found uninitialized function pointer at %d\n", i);
#line 27713
      gl_problem((GLcontext const   *)((void *)0), "Missing pointer in pointers.c");
    }
#line 27710
    i ++;
  }
#line 27716
  return;
}
}
#line 27717 "D:/a/test/177.c"
GLboolean gl_AreTexturesResident(GLcontext *ctx , GLsizei n , GLuint const   *texName ,
                                 GLboolean *residences ) 
{ GLboolean resident ;
  GLuint i ;
  struct gl_texture_object *t ;
  void *tmp___0 ;

  {
#line 27721
  resident = (GLboolean )1;
#line 27723
  if (ctx->Primitive != 6656) {
#line 27724
    gl_error(ctx, 1282, "glAreTexturesResident");
#line 27725
    return ((unsigned char)0);
  }
#line 27727
  if (n < 0) {
#line 27728
    gl_error(ctx, 1281, "glAreTexturesResident(n)");
#line 27729
    return ((unsigned char)0);
  }
#line 27731
  i = 0U;
#line 27731
  while (i < (GLuint )n) {
#line 27733
    if (*(texName + i) == 0U) {
#line 27734
      gl_error(ctx, 1281, "glAreTexturesResident(textures)");
#line 27735
      return ((unsigned char)0);
    }
#line 27737
    tmp___0 = HashLookup((struct HashTable  const  *)(ctx->Shared)->TexObjects, (unsigned int )*(texName + i));
#line 27737
    t = (struct gl_texture_object *)tmp___0;
#line 27739
    if (t) {
#line 27740
      *(residences + i) = (unsigned char)1;
    } else {
#line 27743
      gl_error(ctx, 1281, "glAreTexturesResident(textures)");
#line 27744
      return ((unsigned char)0);
    }
#line 27731
    i ++;
  }
#line 27747
  return (resident);
}
}
#line 27749 "D:/a/test/177.c"
GLboolean gl_IsTexture(GLcontext *ctx , GLuint texture ) 
{ void *tmp___0 ;

  {
#line 27751
  if (ctx->Primitive != 6656) {
#line 27752
    gl_error(ctx, 1282, "glIsTextures");
#line 27753
    return ((unsigned char)0);
  }
#line 27755
  if (texture > 0U) {
#line 27755
    tmp___0 = HashLookup((struct HashTable  const  *)(ctx->Shared)->TexObjects, texture);
#line 27755
    if (tmp___0) {
#line 27756
      return ((unsigned char)1);
    } else {
#line 27759
      return ((unsigned char)0);
    }
  } else {
#line 27759
    return ((unsigned char)0);
  }
}
}
#line 27998
void gl_transform_vb_part1(GLcontext *ctx , GLboolean allDone ) ;
#line 27762 "D:/a/test/177.c"
void gl_ArrayElement(GLcontext *ctx , GLint i ) 
{ struct vertex_buffer *VB ;
  GLint count ;
  GLbyte *p ;
  GLbyte *p___0 ;
  float color[4] ;
  GLbyte *p___1 ;
  GLbyte *p___2 ;
  GLbyte *b ;
  GLbyte *b___0 ;

  {
#line 27764
  VB = ctx->VB;
#line 27765
  count = (GLint )VB->Count;
#line 27766
  if (ctx->Array.NormalEnabled) {
#line 27767
    p = (GLbyte *)ctx->Array.NormalPtr + i * ctx->Array.NormalStrideB;
#line 27769
    switch (ctx->Array.NormalType) {
    case 5120: 
#line 27771
    VB->Normal[count][0] = (2.0F * (float )*(p + 0) + 1.0F) * (1.0F / 255.0F);
#line 27772
    VB->Normal[count][1] = (2.0F * (float )*(p + 1) + 1.0F) * (1.0F / 255.0F);
#line 27773
    VB->Normal[count][2] = (2.0F * (float )*(p + 2) + 1.0F) * (1.0F / 255.0F);
#line 27774
    break;
    case 5122: 
#line 27776
    VB->Normal[count][0] = (2.0F * (float )*((GLshort *)p + 0) + 1.0F) * (1.0F / 65535.0F);
#line 27777
    VB->Normal[count][1] = (2.0F * (float )*((GLshort *)p + 1) + 1.0F) * (1.0F / 65535.0F);
#line 27778
    VB->Normal[count][2] = (2.0F * (float )*((GLshort *)p + 2) + 1.0F) * (1.0F / 65535.0F);
#line 27779
    break;
    case 5124: 
#line 27781
    VB->Normal[count][0] = (2.0F * (float )*((GLint *)p + 0) + 1.0F) * (1.0F / 4294967294.0F);
#line 27782
    VB->Normal[count][1] = (2.0F * (float )*((GLint *)p + 1) + 1.0F) * (1.0F / 4294967294.0F);
#line 27783
    VB->Normal[count][2] = (2.0F * (float )*((GLint *)p + 2) + 1.0F) * (1.0F / 4294967294.0F);
#line 27784
    break;
    case 5126: 
#line 27786
    VB->Normal[count][0] = *((float *)p + 0);
#line 27787
    VB->Normal[count][1] = *((float *)p + 1);
#line 27788
    VB->Normal[count][2] = *((float *)p + 2);
#line 27789
    break;
    case 5130: 
#line 27791
    VB->Normal[count][0] = (float )*((GLdouble *)p + 0);
#line 27792
    VB->Normal[count][1] = (float )*((GLdouble *)p + 1);
#line 27793
    VB->Normal[count][2] = (float )*((GLdouble *)p + 2);
#line 27794
    break;
    default: 
#line 27796
    gl_problem((GLcontext const   *)ctx, "Bad normal type in gl_ArrayElement");
#line 27797
    return;
    }
#line 27799
    VB->MonoNormal = (unsigned char)0;
  } else {
#line 27802
    VB->Normal[count][0] = ctx->Current.Normal[0];
#line 27803
    VB->Normal[count][1] = ctx->Current.Normal[1];
#line 27804
    VB->Normal[count][2] = ctx->Current.Normal[2];
  }
#line 27806
  if (ctx->Array.ColorEnabled) {
#line 27807
    p___0 = (GLbyte *)ctx->Array.ColorPtr + i * ctx->Array.ColorStrideB;
#line 27808
    switch (ctx->Array.ColorType) {
    case 5120: 
#line 27810
    switch (ctx->Array.ColorSize) {
    case 4: 
#line 27811
    glColor4bv((GLbyte const   *)p___0);
#line 27811
    break;
    case 3: 
#line 27812
    glColor3bv((GLbyte const   *)p___0);
#line 27812
    break;
    }
#line 27814
    break;
    case 5121: 
#line 27816
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 27817
    glColor3ubv((GLubyte const   *)((GLubyte *)p___0));
#line 27817
    break;
    case 4: 
#line 27818
    glColor4ubv((GLubyte const   *)((GLubyte *)p___0));
#line 27818
    break;
    }
#line 27820
    break;
    case 5122: 
#line 27822
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 27823
    glColor3sv((GLshort const   *)((GLshort *)p___0));
#line 27823
    break;
    case 4: 
#line 27824
    glColor4sv((GLshort const   *)((GLshort *)p___0));
#line 27824
    break;
    }
#line 27826
    break;
    case 5123: 
#line 27828
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 27829
    glColor3usv((GLushort const   *)((GLushort *)p___0));
#line 27829
    break;
    case 4: 
#line 27830
    glColor4usv((GLushort const   *)((GLushort *)p___0));
#line 27830
    break;
    }
#line 27832
    break;
    case 5124: 
#line 27834
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 27835
    glColor3iv((GLint const   *)((GLint *)p___0));
#line 27835
    break;
    case 4: 
#line 27836
    glColor4iv((GLint const   *)((GLint *)p___0));
#line 27836
    break;
    }
#line 27838
    break;
    case 5125: 
#line 27840
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 27841
    glColor3uiv((GLuint const   *)((GLuint *)p___0));
#line 27841
    break;
    case 4: 
#line 27842
    glColor4uiv((GLuint const   *)((GLuint *)p___0));
#line 27842
    break;
    }
#line 27844
    break;
    case 5126: 
#line 27846
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 27847
    glColor3fv((float const   *)((float *)p___0));
#line 27847
    break;
    case 4: 
#line 27848
    glColor4fv((float const   *)((float *)p___0));
#line 27848
    break;
    }
#line 27850
    break;
    case 5130: 
#line 27852
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 27853
    glColor3dv((GLdouble const   *)((GLdouble *)p___0));
#line 27853
    break;
    case 4: 
#line 27854
    glColor4dv((GLdouble const   *)((GLdouble *)p___0));
#line 27854
    break;
    }
#line 27856
    break;
    default: 
#line 27858
    gl_problem((GLcontext const   *)ctx, "Bad color type in gl_ArrayElement");
#line 27859
    return;
    }
#line 27861
    (ctx->VB)->MonoColor = (unsigned char)0;
  }
#line 27864
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 27864
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 27864
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 27864
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 27864
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 27864
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 27865
  if (ctx->Light.ColorMaterialEnabled) {
#line 27867
    color[0] = (float )ctx->Current.ByteColor[0] * (ctx->Visual)->InvRedScale;
#line 27868
    color[1] = (float )ctx->Current.ByteColor[1] * (ctx->Visual)->InvGreenScale;
#line 27869
    color[2] = (float )ctx->Current.ByteColor[2] * (ctx->Visual)->InvBlueScale;
#line 27870
    color[3] = (float )ctx->Current.ByteColor[3] * (ctx->Visual)->InvAlphaScale;
#line 27871
    gl_set_material(ctx, ctx->Light.ColorMaterialBitmask, (float const   *)(color));
  }
#line 27874
  if (ctx->Array.IndexEnabled) {
#line 27875
    p___1 = (GLbyte *)ctx->Array.IndexPtr + i * ctx->Array.IndexStrideB;
#line 27876
    switch (ctx->Array.IndexType) {
    case 5122: 
#line 27878
    VB->Findex[count] = (unsigned int )*((GLshort *)p___1);
#line 27879
    break;
    case 5124: 
#line 27881
    VB->Findex[count] = (unsigned int )*((GLint *)p___1);
#line 27882
    break;
    case 5126: 
#line 27884
    VB->Findex[count] = (unsigned int )*((float *)p___1);
#line 27885
    break;
    case 5130: 
#line 27887
    VB->Findex[count] = (unsigned int )*((GLdouble *)p___1);
#line 27888
    break;
    default: 
#line 27890
    gl_problem((GLcontext const   *)ctx, "Bad index type in gl_ArrayElement");
#line 27891
    return;
    }
#line 27893
    (ctx->VB)->MonoColor = (unsigned char)0;
  } else {
#line 27896
    VB->Findex[count] = ctx->Current.Index;
  }
#line 27898
  if (ctx->Array.TexCoordEnabled) {
#line 27899
    p___2 = (GLbyte *)ctx->Array.TexCoordPtr + i * ctx->Array.TexCoordStrideB;
#line 27901
    VB->TexCoord[count][1] = 0.0F;
#line 27902
    VB->TexCoord[count][2] = 0.0F;
#line 27903
    VB->TexCoord[count][3] = 1.0F;
#line 27904
    switch (ctx->Array.TexCoordType) {
    case 5122: 
#line 27906
    switch (ctx->Array.TexCoordSize) {
    case 4: 
#line 27907
    VB->TexCoord[count][3] = (float )*((GLshort *)p___2 + 3);
    case 3: 
#line 27908
    VB->TexCoord[count][2] = (float )*((GLshort *)p___2 + 2);
    case 2: 
#line 27909
    VB->TexCoord[count][1] = (float )*((GLshort *)p___2 + 1);
    case 1: 
#line 27910
    VB->TexCoord[count][0] = (float )*((GLshort *)p___2 + 0);
    }
#line 27912
    break;
    case 5124: 
#line 27914
    switch (ctx->Array.TexCoordSize) {
    case 4: 
#line 27915
    VB->TexCoord[count][3] = (float )*((GLint *)p___2 + 3);
    case 3: 
#line 27916
    VB->TexCoord[count][2] = (float )*((GLint *)p___2 + 2);
    case 2: 
#line 27917
    VB->TexCoord[count][1] = (float )*((GLint *)p___2 + 1);
    case 1: 
#line 27918
    VB->TexCoord[count][0] = (float )*((GLint *)p___2 + 0);
    }
#line 27920
    break;
    case 5126: 
#line 27922
    switch (ctx->Array.TexCoordSize) {
    case 4: 
#line 27923
    VB->TexCoord[count][3] = *((float *)p___2 + 3);
    case 3: 
#line 27924
    VB->TexCoord[count][2] = *((float *)p___2 + 2);
    case 2: 
#line 27925
    VB->TexCoord[count][1] = *((float *)p___2 + 1);
    case 1: 
#line 27926
    VB->TexCoord[count][0] = *((float *)p___2 + 0);
    }
#line 27928
    break;
    case 5130: 
#line 27930
    switch (ctx->Array.TexCoordSize) {
    case 4: 
#line 27931
    VB->TexCoord[count][3] = (float )*((GLdouble *)p___2 + 3);
    case 3: 
#line 27932
    VB->TexCoord[count][2] = (float )*((GLdouble *)p___2 + 2);
    case 2: 
#line 27933
    VB->TexCoord[count][1] = (float )*((GLdouble *)p___2 + 1);
    case 1: 
#line 27934
    VB->TexCoord[count][0] = (float )*((GLdouble *)p___2 + 0);
    }
#line 27936
    break;
    default: 
#line 27938
    gl_problem((GLcontext const   *)ctx, "Bad texcoord type in gl_ArrayElement");
#line 27939
    return;
    }
  } else {
#line 27943
    VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 27943
    VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 27943
    VB->TexCoord[count][2] = ctx->Current.TexCoord[2];
#line 27943
    VB->TexCoord[count][3] = ctx->Current.TexCoord[3];
  }
#line 27945
  if (ctx->Array.EdgeFlagEnabled) {
#line 27946
    b = (GLbyte *)ctx->Array.EdgeFlagPtr + i * ctx->Array.EdgeFlagStrideB;
#line 27948
    VB->Edgeflag[count] = *((GLboolean *)b);
  } else {
#line 27951
    VB->Edgeflag[count] = ctx->Current.EdgeFlag;
  }
#line 27953
  if (ctx->Array.VertexEnabled) {
#line 27954
    b___0 = (GLbyte *)ctx->Array.VertexPtr + i * ctx->Array.VertexStrideB;
#line 27956
    VB->Obj[count][2] = 0.0F;
#line 27957
    VB->Obj[count][3] = 1.0F;
#line 27958
    switch (ctx->Array.VertexType) {
    case 5122: 
#line 27960
    switch (ctx->Array.VertexSize) {
    case 4: 
#line 27961
    VB->Obj[count][3] = (float )*((GLshort *)b___0 + 3);
    case 3: 
#line 27962
    VB->Obj[count][2] = (float )*((GLshort *)b___0 + 2);
    case 2: 
#line 27963
    VB->Obj[count][1] = (float )*((GLshort *)b___0 + 1);
#line 27964
    VB->Obj[count][0] = (float )*((GLshort *)b___0 + 0);
    }
#line 27966
    break;
    case 5124: 
#line 27968
    switch (ctx->Array.VertexSize) {
    case 4: 
#line 27969
    VB->Obj[count][3] = (float )*((GLint *)b___0 + 3);
    case 3: 
#line 27970
    VB->Obj[count][2] = (float )*((GLint *)b___0 + 2);
    case 2: 
#line 27971
    VB->Obj[count][1] = (float )*((GLint *)b___0 + 1);
#line 27972
    VB->Obj[count][0] = (float )*((GLint *)b___0 + 0);
    }
#line 27974
    break;
    case 5126: 
#line 27976
    switch (ctx->Array.VertexSize) {
    case 4: 
#line 27977
    VB->Obj[count][3] = *((float *)b___0 + 3);
    case 3: 
#line 27978
    VB->Obj[count][2] = *((float *)b___0 + 2);
    case 2: 
#line 27979
    VB->Obj[count][1] = *((float *)b___0 + 1);
#line 27980
    VB->Obj[count][0] = *((float *)b___0 + 0);
    }
#line 27982
    break;
    case 5130: 
#line 27984
    switch (ctx->Array.VertexSize) {
    case 4: 
#line 27985
    VB->Obj[count][3] = (float )*((GLdouble *)b___0 + 3);
    case 3: 
#line 27986
    VB->Obj[count][2] = (float )*((GLdouble *)b___0 + 2);
    case 2: 
#line 27987
    VB->Obj[count][1] = (float )*((GLdouble *)b___0 + 1);
#line 27988
    VB->Obj[count][0] = (float )*((GLdouble *)b___0 + 0);
    }
#line 27990
    break;
    default: 
#line 27992
    gl_problem((GLcontext const   *)ctx, "Bad vertex type in gl_ArrayElement");
#line 27993
    return;
    }
#line 27995
    count ++;
#line 27996
    VB->Count = (unsigned int )count;
#line 27997
    if (count == 480) {
#line 27998
      gl_transform_vb_part1(ctx, 0);
    }
  }
#line 28003
  return;
}
}
#line 28004 "D:/a/test/177.c"
void gl_save_ArrayElement(GLcontext *ctx , GLint i ) 
{ GLbyte *p ;
  GLbyte *p___0 ;
  GLbyte *p___1 ;
  GLbyte *p___2 ;
  GLbyte *b ;
  GLbyte *b___0 ;

  {
#line 28006
  if (ctx->Array.NormalEnabled) {
#line 28007
    p = (GLbyte *)ctx->Array.NormalPtr + i * ctx->Array.NormalStrideB;
#line 28009
    switch (ctx->Array.NormalType) {
    case 5120: 
#line 28011
    glNormal3bv((GLbyte const   *)p);
#line 28012
    break;
    case 5122: 
#line 28014
    glNormal3sv((GLshort const   *)((GLshort *)p));
#line 28015
    break;
    case 5124: 
#line 28017
    glNormal3iv((GLint const   *)((GLint *)p));
#line 28018
    break;
    case 5126: 
#line 28020
    glNormal3fv((float const   *)((float *)p));
#line 28021
    break;
    case 5130: 
#line 28023
    glNormal3dv((GLdouble const   *)((GLdouble *)p));
#line 28024
    break;
    default: 
#line 28026
    gl_problem((GLcontext const   *)ctx, "Bad normal type in gl_save_ArrayElement");
#line 28027
    return;
    }
  }
#line 28030
  if (ctx->Array.ColorEnabled) {
#line 28031
    p___0 = (GLbyte *)ctx->Array.ColorPtr + i * ctx->Array.ColorStrideB;
#line 28032
    switch (ctx->Array.ColorType) {
    case 5120: 
#line 28034
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 28035
    glColor3bv((GLbyte const   *)p___0);
#line 28035
    break;
    case 4: 
#line 28036
    glColor4bv((GLbyte const   *)p___0);
#line 28036
    break;
    }
#line 28038
    break;
    case 5121: 
#line 28040
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 28041
    glColor3ubv((GLubyte const   *)((GLubyte *)p___0));
#line 28041
    break;
    case 4: 
#line 28042
    glColor4ubv((GLubyte const   *)((GLubyte *)p___0));
#line 28042
    break;
    }
#line 28044
    break;
    case 5122: 
#line 28046
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 28047
    glColor3sv((GLshort const   *)((GLshort *)p___0));
#line 28047
    break;
    case 4: 
#line 28048
    glColor4sv((GLshort const   *)((GLshort *)p___0));
#line 28048
    break;
    }
#line 28050
    break;
    case 5123: 
#line 28052
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 28053
    glColor3usv((GLushort const   *)((GLushort *)p___0));
#line 28053
    break;
    case 4: 
#line 28054
    glColor4usv((GLushort const   *)((GLushort *)p___0));
#line 28054
    break;
    }
#line 28056
    break;
    case 5124: 
#line 28058
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 28059
    glColor3iv((GLint const   *)((GLint *)p___0));
#line 28059
    break;
    case 4: 
#line 28060
    glColor4iv((GLint const   *)((GLint *)p___0));
#line 28060
    break;
    }
#line 28062
    break;
    case 5125: 
#line 28064
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 28065
    glColor3uiv((GLuint const   *)((GLuint *)p___0));
#line 28065
    break;
    case 4: 
#line 28066
    glColor4uiv((GLuint const   *)((GLuint *)p___0));
#line 28066
    break;
    }
#line 28068
    break;
    case 5126: 
#line 28070
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 28071
    glColor3fv((float const   *)((float *)p___0));
#line 28071
    break;
    case 4: 
#line 28072
    glColor4fv((float const   *)((float *)p___0));
#line 28072
    break;
    }
#line 28074
    break;
    case 5130: 
#line 28076
    switch (ctx->Array.ColorSize) {
    case 3: 
#line 28077
    glColor3dv((GLdouble const   *)((GLdouble *)p___0));
#line 28077
    break;
    case 4: 
#line 28078
    glColor4dv((GLdouble const   *)((GLdouble *)p___0));
#line 28078
    break;
    }
#line 28080
    break;
    default: 
#line 28082
    gl_problem((GLcontext const   *)ctx, "Bad color type in gl_save_ArrayElement");
#line 28083
    return;
    }
  }
#line 28086
  if (ctx->Array.IndexEnabled) {
#line 28087
    p___1 = (GLbyte *)ctx->Array.IndexPtr + i * ctx->Array.IndexStrideB;
#line 28088
    switch (ctx->Array.IndexType) {
    case 5122: 
#line 28090
    glIndexsv((GLshort const   *)((GLshort *)p___1));
#line 28091
    break;
    case 5124: 
#line 28093
    glIndexiv((GLint const   *)((GLint *)p___1));
#line 28094
    break;
    case 5126: 
#line 28096
    glIndexfv((float const   *)((float *)p___1));
#line 28097
    break;
    case 5130: 
#line 28099
    glIndexdv((GLdouble const   *)((GLdouble *)p___1));
#line 28100
    break;
    default: 
#line 28102
    gl_problem((GLcontext const   *)ctx, "Bad index type in gl_save_ArrayElement");
#line 28103
    return;
    }
  }
#line 28106
  if (ctx->Array.TexCoordEnabled) {
#line 28107
    p___2 = (GLbyte *)ctx->Array.TexCoordPtr + i * ctx->Array.TexCoordStrideB;
#line 28109
    switch (ctx->Array.TexCoordType) {
    case 5122: 
#line 28111
    switch (ctx->Array.TexCoordSize) {
    case 1: 
#line 28112
    glTexCoord1sv((GLshort const   *)((GLshort *)p___2));
#line 28112
    break;
    case 2: 
#line 28113
    glTexCoord2sv((GLshort const   *)((GLshort *)p___2));
#line 28113
    break;
    case 3: 
#line 28114
    glTexCoord3sv((GLshort const   *)((GLshort *)p___2));
#line 28114
    break;
    case 4: 
#line 28115
    glTexCoord4sv((GLshort const   *)((GLshort *)p___2));
#line 28115
    break;
    }
#line 28117
    break;
    case 5124: 
#line 28119
    switch (ctx->Array.TexCoordSize) {
    case 1: 
#line 28120
    glTexCoord1iv((GLint const   *)((GLint *)p___2));
#line 28120
    break;
    case 2: 
#line 28121
    glTexCoord2iv((GLint const   *)((GLint *)p___2));
#line 28121
    break;
    case 3: 
#line 28122
    glTexCoord3iv((GLint const   *)((GLint *)p___2));
#line 28122
    break;
    case 4: 
#line 28123
    glTexCoord4iv((GLint const   *)((GLint *)p___2));
#line 28123
    break;
    }
#line 28125
    break;
    case 5126: 
#line 28127
    switch (ctx->Array.TexCoordSize) {
    case 1: 
#line 28128
    glTexCoord1fv((float const   *)((float *)p___2));
#line 28128
    break;
    case 2: 
#line 28129
    glTexCoord2fv((float const   *)((float *)p___2));
#line 28129
    break;
    case 3: 
#line 28130
    glTexCoord3fv((float const   *)((float *)p___2));
#line 28130
    break;
    case 4: 
#line 28131
    glTexCoord4fv((float const   *)((float *)p___2));
#line 28131
    break;
    }
#line 28133
    break;
    case 5130: 
#line 28135
    switch (ctx->Array.TexCoordSize) {
    case 1: 
#line 28136
    glTexCoord1dv((GLdouble const   *)((GLdouble *)p___2));
#line 28136
    break;
    case 2: 
#line 28137
    glTexCoord2dv((GLdouble const   *)((GLdouble *)p___2));
#line 28137
    break;
    case 3: 
#line 28138
    glTexCoord3dv((GLdouble const   *)((GLdouble *)p___2));
#line 28138
    break;
    case 4: 
#line 28139
    glTexCoord4dv((GLdouble const   *)((GLdouble *)p___2));
#line 28139
    break;
    }
#line 28141
    break;
    default: 
#line 28143
    gl_problem((GLcontext const   *)ctx, "Bad texcoord type in gl_save_ArrayElement");
#line 28144
    return;
    }
  }
#line 28147
  if (ctx->Array.EdgeFlagEnabled) {
#line 28148
    b = (GLbyte *)ctx->Array.EdgeFlagPtr + i * ctx->Array.EdgeFlagStrideB;
#line 28149
    glEdgeFlagv((GLboolean const   *)((GLboolean *)b));
  }
#line 28151
  if (ctx->Array.VertexEnabled) {
#line 28152
    b___0 = (GLbyte *)ctx->Array.VertexPtr + i * ctx->Array.VertexStrideB;
#line 28154
    switch (ctx->Array.VertexType) {
    case 5122: 
#line 28156
    switch (ctx->Array.VertexSize) {
    case 2: 
#line 28157
    glVertex2sv((GLshort const   *)((GLshort *)b___0));
#line 28157
    break;
    case 3: 
#line 28158
    glVertex3sv((GLshort const   *)((GLshort *)b___0));
#line 28158
    break;
    case 4: 
#line 28159
    glVertex4sv((GLshort const   *)((GLshort *)b___0));
#line 28159
    break;
    }
#line 28161
    break;
    case 5124: 
#line 28163
    switch (ctx->Array.VertexSize) {
    case 2: 
#line 28164
    glVertex2iv((GLint const   *)((GLint *)b___0));
#line 28164
    break;
    case 3: 
#line 28165
    glVertex3iv((GLint const   *)((GLint *)b___0));
#line 28165
    break;
    case 4: 
#line 28166
    glVertex4iv((GLint const   *)((GLint *)b___0));
#line 28166
    break;
    }
#line 28168
    break;
    case 5126: 
#line 28170
    switch (ctx->Array.VertexSize) {
    case 2: 
#line 28171
    glVertex2fv((float const   *)((float *)b___0));
#line 28171
    break;
    case 3: 
#line 28172
    glVertex3fv((float const   *)((float *)b___0));
#line 28172
    break;
    case 4: 
#line 28173
    glVertex4fv((float const   *)((float *)b___0));
#line 28173
    break;
    }
#line 28175
    break;
    case 5130: 
#line 28177
    switch (ctx->Array.VertexSize) {
    case 2: 
#line 28178
    glVertex2dv((GLdouble const   *)((GLdouble *)b___0));
#line 28178
    break;
    case 3: 
#line 28179
    glVertex3dv((GLdouble const   *)((GLdouble *)b___0));
#line 28179
    break;
    case 4: 
#line 28180
    glVertex4dv((GLdouble const   *)((GLdouble *)b___0));
#line 28180
    break;
    }
#line 28182
    break;
    default: 
#line 28184
    gl_problem((GLcontext const   *)ctx, "Bad vertex type in gl_save_ArrayElement");
#line 28185
    return;
    }
  }
#line 28188
  return;
}
}
#line 28228
void gl_xform_points_3fv(GLuint n , float (*q)[4] , float const   *m , float (*p)[3] ) ;
#line 28244
void gl_transform_vb_part2(GLcontext *ctx , GLboolean allDone ) ;
#line 28270
void gl_xform_points_4fv(GLuint n , float (*q)[4] , float const   *m , float (*p)[4] ) ;
#line 28271
void gl_xform_normals_3fv(GLuint n , float (*v)[3] , float const   *m , float (*u)[3] ,
                          GLboolean normalize ) ;
#line 28189 "D:/a/test/177.c"
void gl_DrawArrays(GLcontext *ctx , GLenum mode , GLint first , GLsizei count ) 
{ struct vertex_buffer *VB ;
  GLint i ;
  GLboolean need_edges ;
  float (*vptr)[3] ;
  GLint remaining ;
  GLint vbspace ;
  GLint n ;
  GLint i___0 ;
  GLint start ;
  GLint i___1 ;
  int tmp___0 ;
  float (*vptr___0)[4] ;
  float (*nptr)[3] ;
  GLint remaining___0 ;
  GLint vbspace___0 ;
  GLint n___0 ;
  GLint i___2 ;
  int tmp___1 ;
  float (*vptr___1)[3] ;
  float (*nptr___0)[3] ;
  GLint remaining___1 ;
  GLint vbspace___1 ;
  GLint n___1 ;
  GLint i___3 ;
  int tmp___2 ;

  {
#line 28192
  VB = ctx->VB;
#line 28195
  if (ctx->Primitive != 6656) {
#line 28196
    gl_error(ctx, 1282, "glDrawArrays");
#line 28197
    return;
  }
#line 28199
  if (count < 0) {
#line 28200
    gl_error(ctx, 1281, "glDrawArrays(count)");
#line 28201
    return;
  }
#line 28203
  if (ctx->Primitive == 4) {
#line 28205
    need_edges = (unsigned char)1;
  } else {
#line 28203
    if (ctx->Primitive == 7) {
#line 28205
      need_edges = (unsigned char)1;
    } else {
#line 28203
      if (ctx->Primitive == 9) {
#line 28205
        need_edges = (unsigned char)1;
      } else {
#line 28208
        need_edges = (unsigned char)0;
      }
    }
  }
#line 28210
  if (! ctx->Light.Enabled) {
#line 28210
    if (! ctx->Texture.Enabled) {
#line 28210
      if (ctx->Array.VertexEnabled) {
#line 28210
        if (ctx->Array.VertexType == 5126) {
#line 28210
          if (ctx->Array.VertexStride == 0) {
#line 28210
            if (ctx->Array.VertexSize == 3) {
#line 28210
              if (! ctx->Array.NormalEnabled) {
#line 28210
                if (! ctx->Array.ColorEnabled) {
#line 28210
                  if (! ctx->Array.IndexEnabled) {
#line 28210
                    if (! ctx->Array.TexCoordEnabled) {
#line 28210
                      if (! ctx->Array.EdgeFlagEnabled) {
#line 28221
                        gl_Begin(ctx, mode);
#line 28222
                        remaining = count;
#line 28223
                        vptr = (float (*)[3])ctx->Array.VertexPtr + 3 * first;
#line 28224
                        while (remaining > 0) {
#line 28226
                          vbspace = (int )(480U - VB->Start);
#line 28227
                          if (vbspace < remaining) {
#line 28227
                            n = vbspace;
                          } else {
#line 28227
                            n = remaining;
                          }
#line 28228
                          gl_xform_points_3fv(n, VB->Eye + VB->Start, ctx->ModelViewMatrix,
                                              vptr);
#line 28230
                          start = (GLint )VB->Start;
#line 28231
                          i___0 = 0;
#line 28231
                          while (i___0 < n) {
#line 28232
                            if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28232
                              *((GLuint *)(VB->Fcolor[start + i___0])) = *((GLuint *)(ctx->Current.ByteColor));
                            } else {
#line 28232
                              VB->Fcolor[start + i___0][0] = ctx->Current.ByteColor[0];
#line 28232
                              VB->Fcolor[start + i___0][1] = ctx->Current.ByteColor[1];
#line 28232
                              VB->Fcolor[start + i___0][2] = ctx->Current.ByteColor[2];
#line 28232
                              VB->Fcolor[start + i___0][3] = ctx->Current.ByteColor[3];
                            }
#line 28231
                            i___0 ++;
                          }
#line 28235
                          if (need_edges) {
#line 28237
                            i___1 = 0;
#line 28237
                            while (i___1 < n) {
#line 28238
                              VB->Edgeflag[VB->Start + (GLuint )i___1] = ctx->Current.EdgeFlag;
#line 28237
                              i___1 ++;
                            }
                          }
#line 28241
                          remaining -= n;
#line 28242
                          VB->MonoNormal = (unsigned char)0;
#line 28243
                          VB->Count = VB->Start + (GLuint )n;
#line 28244
                          if (remaining == 0) {
#line 28244
                            tmp___0 = 1;
                          } else {
#line 28244
                            tmp___0 = 0;
                          }
#line 28244
                          gl_transform_vb_part2(ctx, tmp___0);
#line 28245
                          vptr += n;
                        }
#line 28247
                        gl_End(ctx);
                      } else {
                        goto _L___34;
                      }
                    } else {
                      goto _L___34;
                    }
                  } else {
                    goto _L___34;
                  }
                } else {
                  goto _L___34;
                }
              } else {
                goto _L___34;
              }
            } else {
              goto _L___34;
            }
          } else {
            goto _L___34;
          }
        } else {
          goto _L___34;
        }
      } else {
        goto _L___34;
      }
    } else {
      goto _L___34;
    }
  } else {
    _L___34: /* CIL Label */ 
#line 28249
    if (! ctx->CompileFlag) {
#line 28249
      if (ctx->Light.Enabled) {
#line 28249
        if (! ctx->Texture.Enabled) {
#line 28249
          if (ctx->Array.VertexEnabled) {
#line 28249
            if (ctx->Array.VertexType == 5126) {
#line 28249
              if (ctx->Array.VertexStride == 0) {
#line 28249
                if (ctx->Array.VertexSize == 4) {
#line 28249
                  if (ctx->Array.NormalEnabled) {
#line 28249
                    if (ctx->Array.NormalType == 5126) {
#line 28249
                      if (ctx->Array.NormalStride == 0) {
#line 28249
                        if (! ctx->Array.ColorEnabled) {
#line 28249
                          if (! ctx->Array.IndexEnabled) {
#line 28249
                            if (! ctx->Array.TexCoordEnabled) {
#line 28249
                              if (! ctx->Array.EdgeFlagEnabled) {
#line 28262
                                gl_Begin(ctx, mode);
#line 28263
                                remaining___0 = count;
#line 28264
                                vptr___0 = (float (*)[4])ctx->Array.VertexPtr + 4 * first;
#line 28265
                                nptr = (float (*)[3])ctx->Array.NormalPtr + 3 * first;
#line 28266
                                while (remaining___0 > 0) {
#line 28268
                                  vbspace___0 = (int )(480U - VB->Start);
#line 28269
                                  if (vbspace___0 < remaining___0) {
#line 28269
                                    n___0 = vbspace___0;
                                  } else {
#line 28269
                                    n___0 = remaining___0;
                                  }
#line 28270
                                  gl_xform_points_4fv(n___0, VB->Eye + VB->Start,
                                                      ctx->ModelViewMatrix, vptr___0);
#line 28271
                                  gl_xform_normals_3fv(n___0, VB->Normal + VB->Start,
                                                       ctx->ModelViewInv, nptr, ctx->Transform.Normalize);
#line 28273
                                  if (need_edges) {
#line 28275
                                    i___2 = 0;
#line 28275
                                    while (i___2 < n___0) {
#line 28276
                                      VB->Edgeflag[VB->Start + (GLuint )i___2] = ctx->Current.EdgeFlag;
#line 28275
                                      i___2 ++;
                                    }
                                  }
#line 28279
                                  remaining___0 -= n___0;
#line 28280
                                  VB->MonoNormal = (unsigned char)0;
#line 28281
                                  VB->Count = VB->Start + (GLuint )n___0;
#line 28282
                                  if (remaining___0 == 0) {
#line 28282
                                    tmp___1 = 1;
                                  } else {
#line 28282
                                    tmp___1 = 0;
                                  }
#line 28282
                                  gl_transform_vb_part2(ctx, tmp___1);
#line 28283
                                  vptr___0 += n___0;
#line 28284
                                  nptr += n___0;
                                }
#line 28286
                                gl_End(ctx);
                              } else {
                                goto _L___24;
                              }
                            } else {
                              goto _L___24;
                            }
                          } else {
                            goto _L___24;
                          }
                        } else {
                          goto _L___24;
                        }
                      } else {
                        goto _L___24;
                      }
                    } else {
                      goto _L___24;
                    }
                  } else {
                    goto _L___24;
                  }
                } else {
                  goto _L___24;
                }
              } else {
                goto _L___24;
              }
            } else {
              goto _L___24;
            }
          } else {
            goto _L___24;
          }
        } else {
          goto _L___24;
        }
      } else {
        goto _L___24;
      }
    } else {
      _L___24: /* CIL Label */ 
#line 28288
      if (! ctx->CompileFlag) {
#line 28288
        if (ctx->Light.Enabled) {
#line 28288
          if (! ctx->Texture.Enabled) {
#line 28288
            if (ctx->Array.VertexEnabled) {
#line 28288
              if (ctx->Array.VertexType == 5126) {
#line 28288
                if (ctx->Array.VertexStride == 0) {
#line 28288
                  if (ctx->Array.VertexSize == 3) {
#line 28288
                    if (ctx->Array.NormalEnabled) {
#line 28288
                      if (ctx->Array.NormalType == 5126) {
#line 28288
                        if (ctx->Array.NormalStride == 0) {
#line 28288
                          if (! ctx->Array.ColorEnabled) {
#line 28288
                            if (! ctx->Array.IndexEnabled) {
#line 28288
                              if (! ctx->Array.TexCoordEnabled) {
#line 28288
                                if (! ctx->Array.EdgeFlagEnabled) {
#line 28301
                                  gl_Begin(ctx, mode);
#line 28302
                                  remaining___1 = count;
#line 28303
                                  vptr___1 = (float (*)[3])ctx->Array.VertexPtr + 3 * first;
#line 28304
                                  nptr___0 = (float (*)[3])ctx->Array.NormalPtr + 3 * first;
#line 28305
                                  while (remaining___1 > 0) {
#line 28307
                                    vbspace___1 = (int )(480U - VB->Start);
#line 28308
                                    if (vbspace___1 < remaining___1) {
#line 28308
                                      n___1 = vbspace___1;
                                    } else {
#line 28308
                                      n___1 = remaining___1;
                                    }
#line 28309
                                    gl_xform_points_3fv(n___1, VB->Eye + VB->Start,
                                                        ctx->ModelViewMatrix, vptr___1);
#line 28310
                                    gl_xform_normals_3fv(n___1, VB->Normal + VB->Start,
                                                         ctx->ModelViewInv, nptr___0,
                                                         ctx->Transform.Normalize);
#line 28312
                                    if (need_edges) {
#line 28314
                                      i___3 = 0;
#line 28314
                                      while (i___3 < n___1) {
#line 28315
                                        VB->Edgeflag[VB->Start + (GLuint )i___3] = ctx->Current.EdgeFlag;
#line 28314
                                        i___3 ++;
                                      }
                                    }
#line 28318
                                    remaining___1 -= n___1;
#line 28319
                                    VB->MonoNormal = (unsigned char)0;
#line 28320
                                    VB->Count = VB->Start + (GLuint )n___1;
#line 28321
                                    if (remaining___1 == 0) {
#line 28321
                                      tmp___2 = 1;
                                    } else {
#line 28321
                                      tmp___2 = 0;
                                    }
#line 28321
                                    gl_transform_vb_part2(ctx, tmp___2);
#line 28322
                                    vptr___1 += n___1;
#line 28323
                                    nptr___0 += n___1;
                                  }
#line 28325
                                  gl_End(ctx);
                                } else {
                                  goto _L___11;
                                }
                              } else {
                                goto _L___11;
                              }
                            } else {
                              goto _L___11;
                            }
                          } else {
                            goto _L___11;
                          }
                        } else {
                          goto _L___11;
                        }
                      } else {
                        goto _L___11;
                      }
                    } else {
                      goto _L___11;
                    }
                  } else {
                    goto _L___11;
                  }
                } else {
                  goto _L___11;
                }
              } else {
                goto _L___11;
              }
            } else {
              goto _L___11;
            }
          } else {
            goto _L___11;
          }
        } else {
          goto _L___11;
        }
      } else {
        _L___11: /* CIL Label */ 
#line 28328
        gl_Begin(ctx, mode);
#line 28329
        i = 0;
#line 28329
        while (i < count) {
#line 28330
          gl_ArrayElement(ctx, first + i);
#line 28329
          i ++;
        }
#line 28332
        gl_End(ctx);
      }
    }
  }
#line 28334
  return;
}
}
#line 28335 "D:/a/test/177.c"
void gl_save_DrawArrays(GLcontext *ctx , GLenum mode , GLint first , GLsizei count ) 
{ GLint i ;

  {
#line 28339
  if (ctx->Primitive != 6656) {
#line 28340
    gl_error(ctx, 1282, "glDrawArrays");
#line 28341
    return;
  }
#line 28343
  if (count < 0) {
#line 28344
    gl_error(ctx, 1281, "glDrawArrays(count)");
#line 28345
    return;
  }
#line 28347
  switch (mode) {
  case 0: 
  case 1: 
  case 3: 
  case 2: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
  case 8: 
  case 9: 
#line 28358
  break;
  default: 
#line 28360
  gl_error(ctx, 1280, "glDrawArrays(mode)");
#line 28361
  return;
  }
#line 28363
  gl_save_Begin(ctx, mode);
#line 28364
  i = 0;
#line 28364
  while (i < count) {
#line 28365
    gl_save_ArrayElement(ctx, first + i);
#line 28364
    i ++;
  }
#line 28367
  gl_save_End(ctx);
#line 28368
  return;
}
}
#line 28369 "D:/a/test/177.c"
void gl_DrawElements(GLcontext *ctx , GLenum mode , GLsizei count , GLenum type ,
                     GLvoid const   *indices ) 
{ GLubyte *ub_indices ;
  GLint i ;
  GLushort *us_indices ;
  GLint i___0 ;
  GLuint *ui_indices ;
  GLint i___1 ;

  {
#line 28373
  if (ctx->Primitive != 6656) {
#line 28374
    gl_error(ctx, 1282, "glDrawElements");
#line 28375
    return;
  }
#line 28377
  if (count < 0) {
#line 28378
    gl_error(ctx, 1281, "glDrawElements(count)");
#line 28379
    return;
  }
#line 28381
  switch (mode) {
  case 0: 
  case 1: 
  case 3: 
  case 2: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
  case 8: 
  case 9: 
#line 28392
  break;
  default: 
#line 28394
  gl_error(ctx, 1280, "glDrawArrays(mode)");
#line 28395
  return;
  }
#line 28397
  switch (type) {
  case 5121: 
#line 28400
  ub_indices = (GLubyte *)indices;
#line 28402
  gl_Begin(ctx, mode);
#line 28403
  i = 0;
#line 28403
  while (i < count) {
#line 28404
    gl_ArrayElement(ctx, (int )*(ub_indices + i));
#line 28403
    i ++;
  }
#line 28406
  gl_End(ctx);
#line 28408
  break;
  case 5123: 
#line 28411
  us_indices = (GLushort *)indices;
#line 28413
  gl_Begin(ctx, mode);
#line 28414
  i___0 = 0;
#line 28414
  while (i___0 < count) {
#line 28415
    gl_ArrayElement(ctx, (int )*(us_indices + i___0));
#line 28414
    i___0 ++;
  }
#line 28417
  gl_End(ctx);
#line 28419
  break;
  case 5125: 
#line 28422
  ui_indices = (GLuint *)indices;
#line 28424
  gl_Begin(ctx, mode);
#line 28425
  i___1 = 0;
#line 28425
  while (i___1 < count) {
#line 28426
    gl_ArrayElement(ctx, (int )*(ui_indices + i___1));
#line 28425
    i___1 ++;
  }
#line 28428
  gl_End(ctx);
#line 28430
  break;
  default: 
#line 28432
  gl_error(ctx, 1280, "glDrawElements(type)");
#line 28433
  return;
  }
#line 28435
  return;
}
}
#line 28436 "D:/a/test/177.c"
void gl_save_DrawElements(GLcontext *ctx , GLenum mode , GLsizei count , GLenum type ,
                          GLvoid const   *indices ) 
{ GLubyte *ub_indices ;
  GLint i ;
  GLushort *us_indices ;
  GLint i___0 ;
  GLuint *ui_indices ;
  GLint i___1 ;

  {
#line 28440
  switch (type) {
  case 5121: 
#line 28443
  ub_indices = (GLubyte *)indices;
#line 28445
  gl_save_Begin(ctx, mode);
#line 28446
  i = 0;
#line 28446
  while (i < count) {
#line 28447
    gl_save_ArrayElement(ctx, (int )*(ub_indices + i));
#line 28446
    i ++;
  }
#line 28449
  gl_save_End(ctx);
#line 28451
  break;
  case 5123: 
#line 28454
  us_indices = (GLushort *)indices;
#line 28456
  gl_save_Begin(ctx, mode);
#line 28457
  i___0 = 0;
#line 28457
  while (i___0 < count) {
#line 28458
    gl_save_ArrayElement(ctx, (int )*(us_indices + i___0));
#line 28457
    i___0 ++;
  }
#line 28460
  gl_save_End(ctx);
#line 28462
  break;
  case 5125: 
#line 28465
  ui_indices = (GLuint *)indices;
#line 28467
  gl_save_Begin(ctx, mode);
#line 28468
  i___1 = 0;
#line 28468
  while (i___1 < count) {
#line 28469
    gl_save_ArrayElement(ctx, (int )*(ui_indices + i___1));
#line 28468
    i___1 ++;
  }
#line 28471
  gl_save_End(ctx);
#line 28473
  break;
  default: 
#line 28475
  gl_error(ctx, 1280, "glDrawElements(type)");
#line 28476
  return;
  }
#line 28478
  return;
}
}
#line 28612
void gl_TexCoordPointer(GLcontext *ctx , GLint size , GLenum type , GLsizei stride ,
                        GLvoid const   *ptr ) ;
#line 28619
void gl_ColorPointer(GLcontext *ctx , GLint size , GLenum type , GLsizei stride ,
                     GLvoid const   *ptr ) ;
#line 28627
void gl_NormalPointer(GLcontext *ctx , GLenum type , GLsizei stride , GLvoid const   *ptr ) ;
#line 28634
void gl_VertexPointer(GLcontext *ctx , GLint size , GLenum type , GLsizei stride ,
                      GLvoid const   *ptr ) ;
#line 28479 "D:/a/test/177.c"
void gl_InterleavedArrays(GLcontext *ctx , GLenum format , GLsizei stride , GLvoid const   *pointer ) 
{ GLboolean tflag ;
  GLboolean cflag ;
  GLboolean nflag ;
  GLint tcomps ;
  GLint ccomps ;
  GLint vcomps ;
  GLenum ctype ;
  GLint coffset ;
  GLint noffset ;
  GLint voffset ;
  GLint defstride ;
  GLint c ;
  GLint f ;

  {
#line 28489
  f = (int )sizeof(float );
#line 28490
  c = (int )((unsigned int )f * ((4U * sizeof(GLubyte ) + (unsigned int )(f - 1)) / (unsigned int )f));
#line 28491
  if (stride < 0) {
#line 28492
    gl_error(ctx, 1281, "glInterleavedArrays(stride)");
#line 28493
    return;
  }
#line 28495
  switch (format) {
  case 10784: 
#line 28497
  tflag = (unsigned char)0;
#line 28497
  cflag = (unsigned char)0;
#line 28497
  nflag = (unsigned char)0;
#line 28498
  tcomps = 0;
#line 28498
  ccomps = 0;
#line 28498
  vcomps = 2;
#line 28499
  voffset = 0;
#line 28500
  defstride = 2 * f;
#line 28501
  break;
  case 10785: 
#line 28503
  tflag = (unsigned char)0;
#line 28503
  cflag = (unsigned char)0;
#line 28503
  nflag = (unsigned char)0;
#line 28504
  tcomps = 0;
#line 28504
  ccomps = 0;
#line 28504
  vcomps = 3;
#line 28505
  voffset = 0;
#line 28506
  defstride = 3 * f;
#line 28507
  break;
  case 10786: 
#line 28509
  tflag = (unsigned char)0;
#line 28509
  cflag = (unsigned char)1;
#line 28509
  nflag = (unsigned char)0;
#line 28510
  tcomps = 0;
#line 28510
  ccomps = 4;
#line 28510
  vcomps = 2;
#line 28511
  ctype = 5121;
#line 28512
  coffset = 0;
#line 28513
  voffset = c;
#line 28514
  defstride = c + 2 * f;
#line 28515
  break;
  case 10787: 
#line 28517
  tflag = (unsigned char)0;
#line 28517
  cflag = (unsigned char)1;
#line 28517
  nflag = (unsigned char)0;
#line 28518
  tcomps = 0;
#line 28518
  ccomps = 4;
#line 28518
  vcomps = 3;
#line 28519
  ctype = 5121;
#line 28520
  coffset = 0;
#line 28521
  voffset = c;
#line 28522
  defstride = c + 3 * f;
#line 28523
  break;
  case 10788: 
#line 28525
  tflag = (unsigned char)0;
#line 28525
  cflag = (unsigned char)1;
#line 28525
  nflag = (unsigned char)0;
#line 28526
  tcomps = 0;
#line 28526
  ccomps = 3;
#line 28526
  vcomps = 3;
#line 28527
  ctype = 5126;
#line 28528
  coffset = 0;
#line 28529
  voffset = 3 * f;
#line 28530
  defstride = 6 * f;
#line 28531
  break;
  case 10789: 
#line 28533
  tflag = (unsigned char)0;
#line 28533
  cflag = (unsigned char)0;
#line 28533
  nflag = (unsigned char)1;
#line 28534
  tcomps = 0;
#line 28534
  ccomps = 0;
#line 28534
  vcomps = 3;
#line 28535
  noffset = 0;
#line 28536
  voffset = 3 * f;
#line 28537
  defstride = 6 * f;
#line 28538
  break;
  case 10790: 
#line 28540
  tflag = (unsigned char)0;
#line 28540
  cflag = (unsigned char)1;
#line 28540
  nflag = (unsigned char)1;
#line 28541
  tcomps = 0;
#line 28541
  ccomps = 4;
#line 28541
  vcomps = 3;
#line 28542
  ctype = 5126;
#line 28543
  coffset = 0;
#line 28544
  noffset = 4 * f;
#line 28545
  voffset = 7 * f;
#line 28546
  defstride = 10 * f;
#line 28547
  break;
  case 10791: 
#line 28549
  tflag = (unsigned char)1;
#line 28549
  cflag = (unsigned char)0;
#line 28549
  nflag = (unsigned char)0;
#line 28550
  tcomps = 2;
#line 28550
  ccomps = 0;
#line 28550
  vcomps = 3;
#line 28551
  voffset = 2 * f;
#line 28552
  defstride = 5 * f;
#line 28553
  break;
  case 10792: 
#line 28555
  tflag = (unsigned char)1;
#line 28555
  cflag = (unsigned char)0;
#line 28555
  nflag = (unsigned char)0;
#line 28556
  tcomps = 4;
#line 28556
  ccomps = 0;
#line 28556
  vcomps = 4;
#line 28557
  voffset = 4 * f;
#line 28558
  defstride = 8 * f;
#line 28559
  break;
  case 10793: 
#line 28561
  tflag = (unsigned char)1;
#line 28561
  cflag = (unsigned char)1;
#line 28561
  nflag = (unsigned char)0;
#line 28562
  tcomps = 2;
#line 28562
  ccomps = 4;
#line 28562
  vcomps = 3;
#line 28563
  ctype = 5121;
#line 28564
  coffset = 2 * f;
#line 28565
  voffset = c + 2 * f;
#line 28566
  defstride = c + 5 * f;
#line 28567
  break;
  case 10794: 
#line 28569
  tflag = (unsigned char)1;
#line 28569
  cflag = (unsigned char)1;
#line 28569
  nflag = (unsigned char)0;
#line 28570
  tcomps = 2;
#line 28570
  ccomps = 3;
#line 28570
  vcomps = 3;
#line 28571
  ctype = 5126;
#line 28572
  coffset = 2 * f;
#line 28573
  voffset = 5 * f;
#line 28574
  defstride = 8 * f;
#line 28575
  break;
  case 10795: 
#line 28577
  tflag = (unsigned char)1;
#line 28577
  cflag = (unsigned char)0;
#line 28577
  nflag = (unsigned char)1;
#line 28578
  tcomps = 2;
#line 28578
  ccomps = 0;
#line 28578
  vcomps = 3;
#line 28579
  noffset = 2 * f;
#line 28580
  voffset = 5 * f;
#line 28581
  defstride = 8 * f;
#line 28582
  break;
  case 10796: 
#line 28584
  tflag = (unsigned char)1;
#line 28584
  cflag = (unsigned char)1;
#line 28584
  nflag = (unsigned char)1;
#line 28585
  tcomps = 2;
#line 28585
  ccomps = 4;
#line 28585
  vcomps = 3;
#line 28586
  ctype = 5126;
#line 28587
  coffset = 2 * f;
#line 28588
  noffset = 6 * f;
#line 28589
  voffset = 9 * f;
#line 28590
  defstride = 12 * f;
#line 28591
  break;
  case 10797: 
#line 28593
  tflag = (unsigned char)1;
#line 28593
  cflag = (unsigned char)1;
#line 28593
  nflag = (unsigned char)1;
#line 28594
  tcomps = 4;
#line 28594
  ccomps = 4;
#line 28594
  vcomps = 4;
#line 28595
  ctype = 5126;
#line 28596
  coffset = 4 * f;
#line 28597
  noffset = 8 * f;
#line 28598
  voffset = 11 * f;
#line 28599
  defstride = 15 * f;
#line 28600
  break;
  default: 
#line 28602
  gl_error(ctx, 1280, "glInterleavedArrays(format)");
#line 28603
  return;
  }
#line 28605
  if (stride == 0) {
#line 28606
    stride = defstride;
  }
#line 28608
  gl_DisableClientState(ctx, 32889);
#line 28609
  gl_DisableClientState(ctx, 32887);
#line 28610
  if (tflag) {
#line 28611
    gl_EnableClientState(ctx, 32888);
#line 28612
    gl_TexCoordPointer(ctx, tcomps, 5126, stride, pointer);
  } else {
#line 28615
    gl_DisableClientState(ctx, 32888);
  }
#line 28617
  if (cflag) {
#line 28618
    gl_EnableClientState(ctx, 32886);
#line 28619
    gl_ColorPointer(ctx, ccomps, ctype, stride, (GLubyte *)pointer + coffset);
  } else {
#line 28623
    gl_DisableClientState(ctx, 32886);
  }
#line 28625
  if (nflag) {
#line 28626
    gl_EnableClientState(ctx, 32885);
#line 28627
    gl_NormalPointer(ctx, 5126, stride, (GLubyte *)pointer + noffset);
  } else {
#line 28631
    gl_DisableClientState(ctx, 32885);
  }
#line 28633
  gl_EnableClientState(ctx, 32884);
#line 28634
  gl_VertexPointer(ctx, vcomps, 5126, stride, (GLubyte *)pointer + voffset);
#line 28636
  return;
}
}
#line 28637 "D:/a/test/177.c"
void gl_save_InterleavedArrays(GLcontext *ctx , GLenum format , GLsizei stride , GLvoid const   *pointer ) 
{ 

  {
#line 28641
  gl_InterleavedArrays(ctx, format, stride, pointer);
#line 28642
  return;
}
}
#line 28643 "D:/a/test/177.c"
void gl_Color3f(GLcontext *ctx , float red , float green , float blue___0 ) 
{ float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;

  {
#line 28645
  if (red < 0.0F) {
#line 28645
    tmp___1 = 0.0F;
  } else {
#line 28645
    if (red > 1.0F) {
#line 28645
      tmp___0 = 1.0F;
    } else {
#line 28645
      tmp___0 = red;
    }
#line 28645
    tmp___1 = tmp___0;
  }
#line 28645
  ctx->Current.ByteColor[0] = (unsigned char )(tmp___1 * (ctx->Visual)->RedScale);
#line 28646
  if (green < 0.0F) {
#line 28646
    tmp___3 = 0.0F;
  } else {
#line 28646
    if (green > 1.0F) {
#line 28646
      tmp___2 = 1.0F;
    } else {
#line 28646
      tmp___2 = green;
    }
#line 28646
    tmp___3 = tmp___2;
  }
#line 28646
  ctx->Current.ByteColor[1] = (unsigned char )(tmp___3 * (ctx->Visual)->GreenScale);
#line 28647
  if (blue___0 < 0.0F) {
#line 28647
    tmp___5 = 0.0F;
  } else {
#line 28647
    if (blue___0 > 1.0F) {
#line 28647
      tmp___4 = 1.0F;
    } else {
#line 28647
      tmp___4 = blue___0;
    }
#line 28647
    tmp___5 = tmp___4;
  }
#line 28647
  ctx->Current.ByteColor[2] = (unsigned char )(tmp___5 * (ctx->Visual)->BlueScale);
#line 28648
  ctx->Current.ByteColor[3] = (unsigned char )(ctx->Visual)->AlphaScale;
#line 28650
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28651
  return;
}
}
#line 28652 "D:/a/test/177.c"
void gl_Color3fv(GLcontext *ctx , float const   *c ) 
{ float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;

  {
#line 28654
  if (*(c + 0) < (float const   )0.0F) {
#line 28654
    tmp___1 = 0.0F;
  } else {
#line 28654
    if (*(c + 0) > (float const   )1.0F) {
#line 28654
      tmp___0 = 1.0F;
    } else {
#line 28654
      tmp___0 = (float )*(c + 0);
    }
#line 28654
    tmp___1 = tmp___0;
  }
#line 28654
  ctx->Current.ByteColor[0] = (unsigned char )(tmp___1 * (ctx->Visual)->RedScale);
#line 28655
  if (*(c + 1) < (float const   )0.0F) {
#line 28655
    tmp___3 = 0.0F;
  } else {
#line 28655
    if (*(c + 1) > (float const   )1.0F) {
#line 28655
      tmp___2 = 1.0F;
    } else {
#line 28655
      tmp___2 = (float )*(c + 1);
    }
#line 28655
    tmp___3 = tmp___2;
  }
#line 28655
  ctx->Current.ByteColor[1] = (unsigned char )(tmp___3 * (ctx->Visual)->GreenScale);
#line 28656
  if (*(c + 2) < (float const   )0.0F) {
#line 28656
    tmp___5 = 0.0F;
  } else {
#line 28656
    if (*(c + 2) > (float const   )1.0F) {
#line 28656
      tmp___4 = 1.0F;
    } else {
#line 28656
      tmp___4 = (float )*(c + 2);
    }
#line 28656
    tmp___5 = tmp___4;
  }
#line 28656
  ctx->Current.ByteColor[2] = (unsigned char )(tmp___5 * (ctx->Visual)->BlueScale);
#line 28657
  ctx->Current.ByteColor[3] = (unsigned char )(ctx->Visual)->AlphaScale;
#line 28659
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28660
  return;
}
}
#line 28661 "D:/a/test/177.c"
void gl_Color4f(GLcontext *ctx , float red , float green , float blue___0 , float alpha ) 
{ float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;

  {
#line 28664
  if (red < 0.0F) {
#line 28664
    tmp___1 = 0.0F;
  } else {
#line 28664
    if (red > 1.0F) {
#line 28664
      tmp___0 = 1.0F;
    } else {
#line 28664
      tmp___0 = red;
    }
#line 28664
    tmp___1 = tmp___0;
  }
#line 28664
  ctx->Current.ByteColor[0] = (unsigned char )(tmp___1 * (ctx->Visual)->RedScale);
#line 28665
  if (green < 0.0F) {
#line 28665
    tmp___3 = 0.0F;
  } else {
#line 28665
    if (green > 1.0F) {
#line 28665
      tmp___2 = 1.0F;
    } else {
#line 28665
      tmp___2 = green;
    }
#line 28665
    tmp___3 = tmp___2;
  }
#line 28665
  ctx->Current.ByteColor[1] = (unsigned char )(tmp___3 * (ctx->Visual)->GreenScale);
#line 28666
  if (blue___0 < 0.0F) {
#line 28666
    tmp___5 = 0.0F;
  } else {
#line 28666
    if (blue___0 > 1.0F) {
#line 28666
      tmp___4 = 1.0F;
    } else {
#line 28666
      tmp___4 = blue___0;
    }
#line 28666
    tmp___5 = tmp___4;
  }
#line 28666
  ctx->Current.ByteColor[2] = (unsigned char )(tmp___5 * (ctx->Visual)->BlueScale);
#line 28667
  if (alpha < 0.0F) {
#line 28667
    tmp___7 = 0.0F;
  } else {
#line 28667
    if (alpha > 1.0F) {
#line 28667
      tmp___6 = 1.0F;
    } else {
#line 28667
      tmp___6 = alpha;
    }
#line 28667
    tmp___7 = tmp___6;
  }
#line 28667
  ctx->Current.ByteColor[3] = (unsigned char )(tmp___7 * (ctx->Visual)->AlphaScale);
#line 28669
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28670
  return;
}
}
#line 28671 "D:/a/test/177.c"
void gl_Color4fv(GLcontext *ctx , float const   *c ) 
{ float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;

  {
#line 28673
  if (*(c + 0) < (float const   )0.0F) {
#line 28673
    tmp___1 = 0.0F;
  } else {
#line 28673
    if (*(c + 0) > (float const   )1.0F) {
#line 28673
      tmp___0 = 1.0F;
    } else {
#line 28673
      tmp___0 = (float )*(c + 0);
    }
#line 28673
    tmp___1 = tmp___0;
  }
#line 28673
  ctx->Current.ByteColor[0] = (unsigned char )(tmp___1 * (ctx->Visual)->RedScale);
#line 28674
  if (*(c + 1) < (float const   )0.0F) {
#line 28674
    tmp___3 = 0.0F;
  } else {
#line 28674
    if (*(c + 1) > (float const   )1.0F) {
#line 28674
      tmp___2 = 1.0F;
    } else {
#line 28674
      tmp___2 = (float )*(c + 1);
    }
#line 28674
    tmp___3 = tmp___2;
  }
#line 28674
  ctx->Current.ByteColor[1] = (unsigned char )(tmp___3 * (ctx->Visual)->GreenScale);
#line 28675
  if (*(c + 2) < (float const   )0.0F) {
#line 28675
    tmp___5 = 0.0F;
  } else {
#line 28675
    if (*(c + 2) > (float const   )1.0F) {
#line 28675
      tmp___4 = 1.0F;
    } else {
#line 28675
      tmp___4 = (float )*(c + 2);
    }
#line 28675
    tmp___5 = tmp___4;
  }
#line 28675
  ctx->Current.ByteColor[2] = (unsigned char )(tmp___5 * (ctx->Visual)->BlueScale);
#line 28676
  if (*(c + 3) < (float const   )0.0F) {
#line 28676
    tmp___7 = 0.0F;
  } else {
#line 28676
    if (*(c + 3) > (float const   )1.0F) {
#line 28676
      tmp___6 = 1.0F;
    } else {
#line 28676
      tmp___6 = (float )*(c + 3);
    }
#line 28676
    tmp___7 = tmp___6;
  }
#line 28676
  ctx->Current.ByteColor[3] = (unsigned char )(tmp___7 * (ctx->Visual)->AlphaScale);
#line 28678
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28679
  return;
}
}
#line 28680 "D:/a/test/177.c"
void gl_Color4ub(GLcontext *ctx , GLubyte red , GLubyte green , GLubyte blue___0 ,
                 GLubyte alpha ) 
{ 

  {
#line 28683
  ctx->Current.ByteColor[0] = (unsigned char )(((float )red * (ctx->Visual)->RedScale) * (1.0F / 255.0F));
#line 28684
  ctx->Current.ByteColor[1] = (unsigned char )(((float )green * (ctx->Visual)->GreenScale) * (1.0F / 255.0F));
#line 28685
  ctx->Current.ByteColor[2] = (unsigned char )(((float )blue___0 * (ctx->Visual)->BlueScale) * (1.0F / 255.0F));
#line 28686
  ctx->Current.ByteColor[3] = (unsigned char )(((float )alpha * (ctx->Visual)->AlphaScale) * (1.0F / 255.0F));
#line 28688
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28689
  return;
}
}
#line 28690 "D:/a/test/177.c"
void gl_Color4ub8bit(GLcontext *ctx , GLubyte red , GLubyte green , GLubyte blue___0 ,
                     GLubyte alpha ) 
{ 

  {
#line 28693
  ctx->Current.ByteColor[0] = red;
#line 28693
  ctx->Current.ByteColor[1] = green;
#line 28693
  ctx->Current.ByteColor[2] = blue___0;
#line 28693
  ctx->Current.ByteColor[3] = alpha;
#line 28695
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28696
  return;
}
}
#line 28697 "D:/a/test/177.c"
void gl_Color4ubv(GLcontext *ctx , GLubyte const   *c ) 
{ 

  {
#line 28699
  ctx->Current.ByteColor[0] = (unsigned char )(((float )*(c + 0) * (ctx->Visual)->RedScale) * (1.0F / 255.0F));
#line 28700
  ctx->Current.ByteColor[1] = (unsigned char )(((float )*(c + 1) * (ctx->Visual)->GreenScale) * (1.0F / 255.0F));
#line 28701
  ctx->Current.ByteColor[2] = (unsigned char )(((float )*(c + 2) * (ctx->Visual)->BlueScale) * (1.0F / 255.0F));
#line 28702
  ctx->Current.ByteColor[3] = (unsigned char )(((float )*(c + 3) * (ctx->Visual)->AlphaScale) * (1.0F / 255.0F));
#line 28704
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28705
  return;
}
}
#line 28706 "D:/a/test/177.c"
void gl_Color4ubv8bit(GLcontext *ctx , GLubyte const   *c ) 
{ 

  {
#line 28708
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28708
    *((GLuint *)(ctx->Current.ByteColor)) = *((GLuint *)c);
  } else {
#line 28708
    ctx->Current.ByteColor[0] = (unsigned char )*(c + 0);
#line 28708
    ctx->Current.ByteColor[1] = (unsigned char )*(c + 1);
#line 28708
    ctx->Current.ByteColor[2] = (unsigned char )*(c + 2);
#line 28708
    ctx->Current.ByteColor[3] = (unsigned char )*(c + 3);
  }
#line 28710
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28711
  return;
}
}
#line 28712 "D:/a/test/177.c"
void gl_ColorMat3f(GLcontext *ctx , float red , float green , float blue___0 ) 
{ float color[4] ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;

  {
#line 28715
  if (red < 0.0F) {
#line 28715
    tmp___1 = 0.0F;
  } else {
#line 28715
    if (red > 1.0F) {
#line 28715
      tmp___0 = 1.0F;
    } else {
#line 28715
      tmp___0 = red;
    }
#line 28715
    tmp___1 = tmp___0;
  }
#line 28715
  ctx->Current.ByteColor[0] = (unsigned char )(tmp___1 * (ctx->Visual)->RedScale);
#line 28716
  if (green < 0.0F) {
#line 28716
    tmp___3 = 0.0F;
  } else {
#line 28716
    if (green > 1.0F) {
#line 28716
      tmp___2 = 1.0F;
    } else {
#line 28716
      tmp___2 = green;
    }
#line 28716
    tmp___3 = tmp___2;
  }
#line 28716
  ctx->Current.ByteColor[1] = (unsigned char )(tmp___3 * (ctx->Visual)->GreenScale);
#line 28717
  if (blue___0 < 0.0F) {
#line 28717
    tmp___5 = 0.0F;
  } else {
#line 28717
    if (blue___0 > 1.0F) {
#line 28717
      tmp___4 = 1.0F;
    } else {
#line 28717
      tmp___4 = blue___0;
    }
#line 28717
    tmp___5 = tmp___4;
  }
#line 28717
  ctx->Current.ByteColor[2] = (unsigned char )(tmp___5 * (ctx->Visual)->BlueScale);
#line 28718
  ctx->Current.ByteColor[3] = (unsigned char )(ctx->Visual)->AlphaScale;
#line 28720
  color[0] = red;
#line 28720
  color[1] = green;
#line 28720
  color[2] = blue___0;
#line 28720
  color[3] = 1.0F;
#line 28721
  gl_set_material(ctx, ctx->Light.ColorMaterialBitmask, (float const   *)(color));
#line 28722
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28723
  return;
}
}
#line 28724 "D:/a/test/177.c"
void gl_ColorMat3fv(GLcontext *ctx , float const   *c ) 
{ float color[4] ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;

  {
#line 28727
  if (*(c + 0) < (float const   )0.0F) {
#line 28727
    tmp___1 = 0.0F;
  } else {
#line 28727
    if (*(c + 0) > (float const   )1.0F) {
#line 28727
      tmp___0 = 1.0F;
    } else {
#line 28727
      tmp___0 = (float )*(c + 0);
    }
#line 28727
    tmp___1 = tmp___0;
  }
#line 28727
  ctx->Current.ByteColor[0] = (unsigned char )(tmp___1 * (ctx->Visual)->RedScale);
#line 28728
  if (*(c + 1) < (float const   )0.0F) {
#line 28728
    tmp___3 = 0.0F;
  } else {
#line 28728
    if (*(c + 1) > (float const   )1.0F) {
#line 28728
      tmp___2 = 1.0F;
    } else {
#line 28728
      tmp___2 = (float )*(c + 1);
    }
#line 28728
    tmp___3 = tmp___2;
  }
#line 28728
  ctx->Current.ByteColor[1] = (unsigned char )(tmp___3 * (ctx->Visual)->GreenScale);
#line 28729
  if (*(c + 2) < (float const   )0.0F) {
#line 28729
    tmp___5 = 0.0F;
  } else {
#line 28729
    if (*(c + 2) > (float const   )1.0F) {
#line 28729
      tmp___4 = 1.0F;
    } else {
#line 28729
      tmp___4 = (float )*(c + 2);
    }
#line 28729
    tmp___5 = tmp___4;
  }
#line 28729
  ctx->Current.ByteColor[2] = (unsigned char )(tmp___5 * (ctx->Visual)->BlueScale);
#line 28730
  ctx->Current.ByteColor[3] = (unsigned char )(ctx->Visual)->AlphaScale;
#line 28732
  color[0] = (float )*(c + 0);
#line 28732
  color[1] = (float )*(c + 1);
#line 28732
  color[2] = (float )*(c + 2);
#line 28732
  color[3] = 1.0F;
#line 28733
  gl_set_material(ctx, ctx->Light.ColorMaterialBitmask, (float const   *)(color));
#line 28734
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28735
  return;
}
}
#line 28736 "D:/a/test/177.c"
void gl_ColorMat4f(GLcontext *ctx , float red , float green , float blue___0 , float alpha ) 
{ float color[4] ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;

  {
#line 28740
  if (red < 0.0F) {
#line 28740
    tmp___1 = 0.0F;
  } else {
#line 28740
    if (red > 1.0F) {
#line 28740
      tmp___0 = 1.0F;
    } else {
#line 28740
      tmp___0 = red;
    }
#line 28740
    tmp___1 = tmp___0;
  }
#line 28740
  ctx->Current.ByteColor[0] = (unsigned char )(tmp___1 * (ctx->Visual)->RedScale);
#line 28741
  if (green < 0.0F) {
#line 28741
    tmp___3 = 0.0F;
  } else {
#line 28741
    if (green > 1.0F) {
#line 28741
      tmp___2 = 1.0F;
    } else {
#line 28741
      tmp___2 = green;
    }
#line 28741
    tmp___3 = tmp___2;
  }
#line 28741
  ctx->Current.ByteColor[1] = (unsigned char )(tmp___3 * (ctx->Visual)->GreenScale);
#line 28742
  if (blue___0 < 0.0F) {
#line 28742
    tmp___5 = 0.0F;
  } else {
#line 28742
    if (blue___0 > 1.0F) {
#line 28742
      tmp___4 = 1.0F;
    } else {
#line 28742
      tmp___4 = blue___0;
    }
#line 28742
    tmp___5 = tmp___4;
  }
#line 28742
  ctx->Current.ByteColor[2] = (unsigned char )(tmp___5 * (ctx->Visual)->BlueScale);
#line 28743
  if (alpha < 0.0F) {
#line 28743
    tmp___7 = 0.0F;
  } else {
#line 28743
    if (alpha > 1.0F) {
#line 28743
      tmp___6 = 1.0F;
    } else {
#line 28743
      tmp___6 = alpha;
    }
#line 28743
    tmp___7 = tmp___6;
  }
#line 28743
  ctx->Current.ByteColor[3] = (unsigned char )(tmp___7 * (ctx->Visual)->AlphaScale);
#line 28745
  color[0] = red;
#line 28745
  color[1] = green;
#line 28745
  color[2] = blue___0;
#line 28745
  color[3] = alpha;
#line 28746
  gl_set_material(ctx, ctx->Light.ColorMaterialBitmask, (float const   *)(color));
#line 28747
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28748
  return;
}
}
#line 28749 "D:/a/test/177.c"
void gl_ColorMat4fv(GLcontext *ctx , float const   *c ) 
{ float color[4] ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;

  {
#line 28752
  if (*(c + 0) < (float const   )0.0F) {
#line 28752
    tmp___1 = 0.0F;
  } else {
#line 28752
    if (*(c + 0) > (float const   )1.0F) {
#line 28752
      tmp___0 = 1.0F;
    } else {
#line 28752
      tmp___0 = (float )*(c + 0);
    }
#line 28752
    tmp___1 = tmp___0;
  }
#line 28752
  ctx->Current.ByteColor[0] = (unsigned char )(tmp___1 * (ctx->Visual)->RedScale);
#line 28753
  if (*(c + 1) < (float const   )0.0F) {
#line 28753
    tmp___3 = 0.0F;
  } else {
#line 28753
    if (*(c + 1) > (float const   )1.0F) {
#line 28753
      tmp___2 = 1.0F;
    } else {
#line 28753
      tmp___2 = (float )*(c + 1);
    }
#line 28753
    tmp___3 = tmp___2;
  }
#line 28753
  ctx->Current.ByteColor[1] = (unsigned char )(tmp___3 * (ctx->Visual)->GreenScale);
#line 28754
  if (*(c + 2) < (float const   )0.0F) {
#line 28754
    tmp___5 = 0.0F;
  } else {
#line 28754
    if (*(c + 2) > (float const   )1.0F) {
#line 28754
      tmp___4 = 1.0F;
    } else {
#line 28754
      tmp___4 = (float )*(c + 2);
    }
#line 28754
    tmp___5 = tmp___4;
  }
#line 28754
  ctx->Current.ByteColor[2] = (unsigned char )(tmp___5 * (ctx->Visual)->BlueScale);
#line 28755
  if (*(c + 3) < (float const   )0.0F) {
#line 28755
    tmp___7 = 0.0F;
  } else {
#line 28755
    if (*(c + 3) > (float const   )1.0F) {
#line 28755
      tmp___6 = 1.0F;
    } else {
#line 28755
      tmp___6 = (float )*(c + 3);
    }
#line 28755
    tmp___7 = tmp___6;
  }
#line 28755
  ctx->Current.ByteColor[3] = (unsigned char )(tmp___7 * (ctx->Visual)->AlphaScale);
#line 28757
  color[0] = (float )*(c + 0);
#line 28757
  color[1] = (float )*(c + 1);
#line 28757
  color[2] = (float )*(c + 2);
#line 28757
  color[3] = (float )*(c + 3);
#line 28758
  gl_set_material(ctx, ctx->Light.ColorMaterialBitmask, (float const   *)(color));
#line 28759
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28760
  return;
}
}
#line 28761 "D:/a/test/177.c"
void gl_ColorMat4ub(GLcontext *ctx , GLubyte red , GLubyte green , GLubyte blue___0 ,
                    GLubyte alpha ) 
{ float color[4] ;

  {
#line 28765
  if ((ctx->Visual)->EightBitColor) {
#line 28766
    ctx->Current.ByteColor[0] = red;
#line 28766
    ctx->Current.ByteColor[1] = green;
#line 28766
    ctx->Current.ByteColor[2] = blue___0;
#line 28766
    ctx->Current.ByteColor[3] = alpha;
  } else {
#line 28769
    ctx->Current.ByteColor[0] = (unsigned char )(((float )red * (ctx->Visual)->RedScale) * (1.0F / 255.0F));
#line 28770
    ctx->Current.ByteColor[1] = (unsigned char )(((float )green * (ctx->Visual)->GreenScale) * (1.0F / 255.0F));
#line 28771
    ctx->Current.ByteColor[2] = (unsigned char )(((float )blue___0 * (ctx->Visual)->BlueScale) * (1.0F / 255.0F));
#line 28772
    ctx->Current.ByteColor[3] = (unsigned char )(((float )alpha * (ctx->Visual)->AlphaScale) * (1.0F / 255.0F));
  }
#line 28775
  color[0] = (float )red * (1.0F / 255.0F);
#line 28776
  color[1] = (float )green * (1.0F / 255.0F);
#line 28777
  color[2] = (float )blue___0 * (1.0F / 255.0F);
#line 28778
  color[3] = (float )alpha * (1.0F / 255.0F);
#line 28779
  gl_set_material(ctx, ctx->Light.ColorMaterialBitmask, (float const   *)(color));
#line 28780
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 28781
  return;
}
}
#line 28782 "D:/a/test/177.c"
void gl_ColorMat4ubv(GLcontext *ctx , GLubyte const   *c ) 
{ 

  {
#line 28784
  gl_ColorMat4ub(ctx, (unsigned char )*(c + 0), (unsigned char )*(c + 1), (unsigned char )*(c + 2),
                 (unsigned char )*(c + 3));
#line 28785
  return;
}
}
#line 28786 "D:/a/test/177.c"
void gl_EdgeFlag(GLcontext *ctx , GLboolean flag ) 
{ 

  {
#line 28788
  ctx->Current.EdgeFlag = flag;
#line 28789
  return;
}
}
#line 28790 "D:/a/test/177.c"
static void vertex4f_feedback(GLcontext *ctx , float x , float y , float z , float w ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28793
  VB = ctx->VB;
#line 28794
  count = VB->Count;
#line 28795
  VB->Obj[count][0] = x;
#line 28795
  VB->Obj[count][1] = y;
#line 28795
  VB->Obj[count][2] = z;
#line 28795
  VB->Obj[count][3] = w;
#line 28796
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28796
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 28796
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 28796
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 28796
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 28796
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 28797
  VB->Findex[count] = ctx->Current.Index;
#line 28798
  VB->Normal[count][0] = ctx->Current.Normal[0];
#line 28798
  VB->Normal[count][1] = ctx->Current.Normal[1];
#line 28798
  VB->Normal[count][2] = ctx->Current.Normal[2];
#line 28799
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 28799
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 28799
  VB->TexCoord[count][2] = ctx->Current.TexCoord[2];
#line 28799
  VB->TexCoord[count][3] = ctx->Current.TexCoord[3];
#line 28800
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28801
  count ++;
#line 28802
  VB->Count = count;
#line 28803
  if (count == 480U) {
#line 28804
    gl_transform_vb_part1(ctx, 0);
  }
#line 28806
  return;
}
}
#line 28807 "D:/a/test/177.c"
static void vertex3f_feedback(GLcontext *ctx , float x , float y , float z ) 
{ 

  {
#line 28809
  vertex4f_feedback(ctx, x, y, z, 1.0F);
#line 28810
  return;
}
}
#line 28811 "D:/a/test/177.c"
static void vertex2f_feedback(GLcontext *ctx , float x , float y ) 
{ 

  {
#line 28813
  vertex4f_feedback(ctx, x, y, 0.0F, 1.0F);
#line 28814
  return;
}
}
#line 28815 "D:/a/test/177.c"
static void vertex3fv_feedback(GLcontext *ctx , float const   *v ) 
{ 

  {
#line 28817
  vertex4f_feedback(ctx, (float )*(v + 0), (float )*(v + 1), (float )*(v + 2), 1.0F);
#line 28818
  return;
}
}
#line 28819 "D:/a/test/177.c"
static void vertex4(GLcontext *ctx , float x , float y , float z , float w ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28822
  VB = ctx->VB;
#line 28823
  count = VB->Count;
#line 28824
  VB->Obj[count][0] = x;
#line 28824
  VB->Obj[count][1] = y;
#line 28824
  VB->Obj[count][2] = z;
#line 28824
  VB->Obj[count][3] = w;
#line 28825
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28825
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 28825
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 28825
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 28825
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 28825
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 28826
  VB->Normal[count][0] = ctx->Current.Normal[0];
#line 28826
  VB->Normal[count][1] = ctx->Current.Normal[1];
#line 28826
  VB->Normal[count][2] = ctx->Current.Normal[2];
#line 28827
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 28827
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 28827
  VB->TexCoord[count][2] = ctx->Current.TexCoord[2];
#line 28827
  VB->TexCoord[count][3] = ctx->Current.TexCoord[3];
#line 28828
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28829
  VB->VertexSizeMask = 4U;
#line 28830
  count ++;
#line 28831
  VB->Count = count;
#line 28832
  if (count == 480U) {
#line 28833
    gl_transform_vb_part1(ctx, 0);
  }
#line 28835
  return;
}
}
#line 28836 "D:/a/test/177.c"
static void vertex3f_normal_color_tex2(GLcontext *ctx , float x , float y , float z ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28839
  VB = ctx->VB;
#line 28840
  count = VB->Count;
#line 28841
  VB->Obj[count][0] = x;
#line 28841
  VB->Obj[count][1] = y;
#line 28841
  VB->Obj[count][2] = z;
#line 28842
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28842
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 28842
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 28842
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 28842
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 28842
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 28843
  VB->Normal[count][0] = ctx->Current.Normal[0];
#line 28843
  VB->Normal[count][1] = ctx->Current.Normal[1];
#line 28843
  VB->Normal[count][2] = ctx->Current.Normal[2];
#line 28844
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 28844
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 28845
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28846
  count ++;
#line 28847
  VB->Count = count;
#line 28848
  if (count == 480U) {
#line 28849
    gl_transform_vb_part1(ctx, 0);
  }
#line 28851
  return;
}
}
#line 28852 "D:/a/test/177.c"
static void vertex3f_normal_color_tex4(GLcontext *ctx , float x , float y , float z ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28855
  VB = ctx->VB;
#line 28856
  count = VB->Count;
#line 28857
  VB->Obj[count][0] = x;
#line 28857
  VB->Obj[count][1] = y;
#line 28857
  VB->Obj[count][2] = z;
#line 28858
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28858
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 28858
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 28858
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 28858
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 28858
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 28859
  VB->Normal[count][0] = ctx->Current.Normal[0];
#line 28859
  VB->Normal[count][1] = ctx->Current.Normal[1];
#line 28859
  VB->Normal[count][2] = ctx->Current.Normal[2];
#line 28860
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 28860
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 28860
  VB->TexCoord[count][2] = ctx->Current.TexCoord[2];
#line 28860
  VB->TexCoord[count][3] = ctx->Current.TexCoord[3];
#line 28861
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28862
  count ++;
#line 28863
  VB->Count = count;
#line 28864
  if (count == 480U) {
#line 28865
    gl_transform_vb_part1(ctx, 0);
  }
#line 28867
  return;
}
}
#line 28868 "D:/a/test/177.c"
static void vertex3f_normal(GLcontext *ctx , float x , float y , float z ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28870
  VB = ctx->VB;
#line 28871
  count = VB->Count;
#line 28872
  VB->Obj[count][0] = x;
#line 28872
  VB->Obj[count][1] = y;
#line 28872
  VB->Obj[count][2] = z;
#line 28873
  VB->Normal[count][0] = ctx->Current.Normal[0];
#line 28873
  VB->Normal[count][1] = ctx->Current.Normal[1];
#line 28873
  VB->Normal[count][2] = ctx->Current.Normal[2];
#line 28874
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28875
  count ++;
#line 28876
  VB->Count = count;
#line 28877
  if (count == 480U) {
#line 28878
    gl_transform_vb_part1(ctx, 0);
  }
#line 28880
  return;
}
}
#line 28881 "D:/a/test/177.c"
static void vertex3f_color_tex2(GLcontext *ctx , float x , float y , float z ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28884
  VB = ctx->VB;
#line 28885
  count = VB->Count;
#line 28886
  VB->Obj[count][0] = x;
#line 28886
  VB->Obj[count][1] = y;
#line 28886
  VB->Obj[count][2] = z;
#line 28887
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28887
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 28887
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 28887
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 28887
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 28887
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 28888
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 28888
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 28889
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28890
  count ++;
#line 28891
  VB->Count = count;
#line 28892
  if (count == 480U) {
#line 28893
    gl_transform_vb_part1(ctx, 0);
  }
#line 28895
  return;
}
}
#line 28896 "D:/a/test/177.c"
static void vertex3f_color_tex4(GLcontext *ctx , float x , float y , float z ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28899
  VB = ctx->VB;
#line 28900
  count = VB->Count;
#line 28901
  VB->Obj[count][0] = x;
#line 28901
  VB->Obj[count][1] = y;
#line 28901
  VB->Obj[count][2] = z;
#line 28902
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28902
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 28902
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 28902
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 28902
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 28902
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 28903
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 28903
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 28903
  VB->TexCoord[count][2] = ctx->Current.TexCoord[2];
#line 28903
  VB->TexCoord[count][3] = ctx->Current.TexCoord[3];
#line 28904
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28905
  count ++;
#line 28906
  VB->Count = count;
#line 28907
  if (count == 480U) {
#line 28908
    gl_transform_vb_part1(ctx, 0);
  }
#line 28910
  return;
}
}
#line 28911 "D:/a/test/177.c"
static void vertex3f_color(GLcontext *ctx , float x , float y , float z ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28913
  VB = ctx->VB;
#line 28914
  count = VB->Count;
#line 28915
  VB->Obj[count][0] = x;
#line 28915
  VB->Obj[count][1] = y;
#line 28915
  VB->Obj[count][2] = z;
#line 28916
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28916
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 28916
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 28916
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 28916
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 28916
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 28917
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28918
  count ++;
#line 28919
  VB->Count = count;
#line 28920
  if (count == 480U) {
#line 28921
    gl_transform_vb_part1(ctx, 0);
  }
#line 28923
  return;
}
}
#line 28924 "D:/a/test/177.c"
static void vertex3f_index(GLcontext *ctx , float x , float y , float z ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28926
  VB = ctx->VB;
#line 28927
  count = VB->Count;
#line 28928
  VB->Obj[count][0] = x;
#line 28928
  VB->Obj[count][1] = y;
#line 28928
  VB->Obj[count][2] = z;
#line 28929
  VB->Findex[count] = ctx->Current.Index;
#line 28930
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28931
  count ++;
#line 28932
  VB->Count = count;
#line 28933
  if (count == 480U) {
#line 28934
    gl_transform_vb_part1(ctx, 0);
  }
#line 28936
  return;
}
}
#line 28937 "D:/a/test/177.c"
static void vertex2f_normal_color_tex2(GLcontext *ctx , float x , float y ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28939
  VB = ctx->VB;
#line 28940
  count = VB->Count;
#line 28941
  VB->Obj[count][0] = x;
#line 28941
  VB->Obj[count][1] = y;
#line 28941
  VB->Obj[count][2] = 0.0F;
#line 28942
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28942
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 28942
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 28942
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 28942
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 28942
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 28943
  VB->Normal[count][0] = ctx->Current.Normal[0];
#line 28943
  VB->Normal[count][1] = ctx->Current.Normal[1];
#line 28943
  VB->Normal[count][2] = ctx->Current.Normal[2];
#line 28944
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 28944
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 28945
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28946
  count ++;
#line 28947
  VB->Count = count;
#line 28948
  if (count == 480U) {
#line 28949
    gl_transform_vb_part1(ctx, 0);
  }
#line 28951
  return;
}
}
#line 28952 "D:/a/test/177.c"
static void vertex2f_normal_color_tex4(GLcontext *ctx , float x , float y ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28954
  VB = ctx->VB;
#line 28955
  count = VB->Count;
#line 28956
  VB->Obj[count][0] = x;
#line 28956
  VB->Obj[count][1] = y;
#line 28956
  VB->Obj[count][2] = 0.0F;
#line 28957
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28957
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 28957
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 28957
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 28957
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 28957
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 28958
  VB->Normal[count][0] = ctx->Current.Normal[0];
#line 28958
  VB->Normal[count][1] = ctx->Current.Normal[1];
#line 28958
  VB->Normal[count][2] = ctx->Current.Normal[2];
#line 28959
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 28959
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 28959
  VB->TexCoord[count][2] = ctx->Current.TexCoord[2];
#line 28959
  VB->TexCoord[count][3] = ctx->Current.TexCoord[3];
#line 28960
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28961
  count ++;
#line 28962
  VB->Count = count;
#line 28963
  if (count == 480U) {
#line 28964
    gl_transform_vb_part1(ctx, 0);
  }
#line 28966
  return;
}
}
#line 28967 "D:/a/test/177.c"
static void vertex2f_normal(GLcontext *ctx , float x , float y ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28969
  VB = ctx->VB;
#line 28970
  count = VB->Count;
#line 28971
  VB->Obj[count][0] = x;
#line 28971
  VB->Obj[count][1] = y;
#line 28971
  VB->Obj[count][2] = 0.0F;
#line 28972
  VB->Normal[count][0] = ctx->Current.Normal[0];
#line 28972
  VB->Normal[count][1] = ctx->Current.Normal[1];
#line 28972
  VB->Normal[count][2] = ctx->Current.Normal[2];
#line 28973
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28974
  count ++;
#line 28975
  VB->Count = count;
#line 28976
  if (count == 480U) {
#line 28977
    gl_transform_vb_part1(ctx, 0);
  }
#line 28979
  return;
}
}
#line 28980 "D:/a/test/177.c"
static void vertex2f_color_tex2(GLcontext *ctx , float x , float y ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28982
  VB = ctx->VB;
#line 28983
  count = VB->Count;
#line 28984
  VB->Obj[count][0] = x;
#line 28984
  VB->Obj[count][1] = y;
#line 28984
  VB->Obj[count][2] = 0.0F;
#line 28985
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28985
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 28985
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 28985
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 28985
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 28985
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 28986
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 28986
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 28987
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 28988
  count ++;
#line 28989
  VB->Count = count;
#line 28990
  if (count == 480U) {
#line 28991
    gl_transform_vb_part1(ctx, 0);
  }
#line 28993
  return;
}
}
#line 28994 "D:/a/test/177.c"
static void vertex2f_color_tex4(GLcontext *ctx , float x , float y ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 28996
  VB = ctx->VB;
#line 28997
  count = VB->Count;
#line 28998
  VB->Obj[count][0] = x;
#line 28998
  VB->Obj[count][1] = y;
#line 28998
  VB->Obj[count][2] = 0.0F;
#line 28999
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 28999
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 28999
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 28999
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 28999
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 28999
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 29000
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 29000
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 29000
  VB->TexCoord[count][2] = ctx->Current.TexCoord[2];
#line 29000
  VB->TexCoord[count][3] = ctx->Current.TexCoord[3];
#line 29001
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 29002
  count ++;
#line 29003
  VB->Count = count;
#line 29004
  if (count == 480U) {
#line 29005
    gl_transform_vb_part1(ctx, 0);
  }
#line 29007
  return;
}
}
#line 29008 "D:/a/test/177.c"
static void vertex2f_color(GLcontext *ctx , float x , float y ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 29010
  VB = ctx->VB;
#line 29011
  count = VB->Count;
#line 29012
  VB->Obj[count][0] = x;
#line 29012
  VB->Obj[count][1] = y;
#line 29012
  VB->Obj[count][2] = 0.0F;
#line 29013
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 29013
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 29013
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 29013
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 29013
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 29013
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 29014
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 29015
  count ++;
#line 29016
  VB->Count = count;
#line 29017
  if (count == 480U) {
#line 29018
    gl_transform_vb_part1(ctx, 0);
  }
#line 29020
  return;
}
}
#line 29021 "D:/a/test/177.c"
static void vertex2f_index(GLcontext *ctx , float x , float y ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 29023
  VB = ctx->VB;
#line 29024
  count = VB->Count;
#line 29025
  VB->Obj[count][0] = x;
#line 29025
  VB->Obj[count][1] = y;
#line 29025
  VB->Obj[count][2] = 0.0F;
#line 29026
  VB->Findex[count] = ctx->Current.Index;
#line 29027
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 29028
  count ++;
#line 29029
  VB->Count = count;
#line 29030
  if (count == 480U) {
#line 29031
    gl_transform_vb_part1(ctx, 0);
  }
#line 29033
  return;
}
}
#line 29034 "D:/a/test/177.c"
static void vertex3fv_normal_color_tex2(GLcontext *ctx , float const   *v ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 29036
  VB = ctx->VB;
#line 29037
  count = VB->Count;
#line 29038
  VB->Obj[count][0] = (float )*(v + 0);
#line 29038
  VB->Obj[count][1] = (float )*(v + 1);
#line 29038
  VB->Obj[count][2] = (float )*(v + 2);
#line 29039
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 29039
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 29039
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 29039
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 29039
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 29039
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 29040
  VB->Normal[count][0] = ctx->Current.Normal[0];
#line 29040
  VB->Normal[count][1] = ctx->Current.Normal[1];
#line 29040
  VB->Normal[count][2] = ctx->Current.Normal[2];
#line 29041
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 29041
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 29042
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 29043
  count ++;
#line 29044
  VB->Count = count;
#line 29045
  if (count == 480U) {
#line 29046
    gl_transform_vb_part1(ctx, 0);
  }
#line 29048
  return;
}
}
#line 29049 "D:/a/test/177.c"
static void vertex3fv_normal_color_tex4(GLcontext *ctx , float const   *v ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 29051
  VB = ctx->VB;
#line 29052
  count = VB->Count;
#line 29053
  VB->Obj[count][0] = (float )*(v + 0);
#line 29053
  VB->Obj[count][1] = (float )*(v + 1);
#line 29053
  VB->Obj[count][2] = (float )*(v + 2);
#line 29054
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 29054
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 29054
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 29054
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 29054
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 29054
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 29055
  VB->Normal[count][0] = ctx->Current.Normal[0];
#line 29055
  VB->Normal[count][1] = ctx->Current.Normal[1];
#line 29055
  VB->Normal[count][2] = ctx->Current.Normal[2];
#line 29056
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 29056
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 29056
  VB->TexCoord[count][2] = ctx->Current.TexCoord[2];
#line 29056
  VB->TexCoord[count][3] = ctx->Current.TexCoord[3];
#line 29057
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 29058
  count ++;
#line 29059
  VB->Count = count;
#line 29060
  if (count == 480U) {
#line 29061
    gl_transform_vb_part1(ctx, 0);
  }
#line 29063
  return;
}
}
#line 29064 "D:/a/test/177.c"
static void vertex3fv_normal(GLcontext *ctx , float const   *v ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 29066
  VB = ctx->VB;
#line 29067
  count = VB->Count;
#line 29068
  VB->Obj[count][0] = (float )*(v + 0);
#line 29068
  VB->Obj[count][1] = (float )*(v + 1);
#line 29068
  VB->Obj[count][2] = (float )*(v + 2);
#line 29069
  VB->Normal[count][0] = ctx->Current.Normal[0];
#line 29069
  VB->Normal[count][1] = ctx->Current.Normal[1];
#line 29069
  VB->Normal[count][2] = ctx->Current.Normal[2];
#line 29070
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 29071
  count ++;
#line 29072
  VB->Count = count;
#line 29073
  if (count == 480U) {
#line 29074
    gl_transform_vb_part1(ctx, 0);
  }
#line 29076
  return;
}
}
#line 29077 "D:/a/test/177.c"
static void vertex3fv_color_tex2(GLcontext *ctx , float const   *v ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 29079
  VB = ctx->VB;
#line 29080
  count = VB->Count;
#line 29081
  VB->Obj[count][0] = (float )*(v + 0);
#line 29081
  VB->Obj[count][1] = (float )*(v + 1);
#line 29081
  VB->Obj[count][2] = (float )*(v + 2);
#line 29082
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 29082
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 29082
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 29082
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 29082
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 29082
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 29083
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 29083
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 29084
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 29085
  count ++;
#line 29086
  VB->Count = count;
#line 29087
  if (count == 480U) {
#line 29088
    gl_transform_vb_part1(ctx, 0);
  }
#line 29090
  return;
}
}
#line 29091 "D:/a/test/177.c"
static void vertex3fv_color_tex4(GLcontext *ctx , float const   *v ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 29093
  VB = ctx->VB;
#line 29094
  count = VB->Count;
#line 29095
  VB->Obj[count][0] = (float )*(v + 0);
#line 29095
  VB->Obj[count][1] = (float )*(v + 1);
#line 29095
  VB->Obj[count][2] = (float )*(v + 2);
#line 29096
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 29096
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 29096
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 29096
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 29096
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 29096
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 29097
  VB->TexCoord[count][0] = ctx->Current.TexCoord[0];
#line 29097
  VB->TexCoord[count][1] = ctx->Current.TexCoord[1];
#line 29097
  VB->TexCoord[count][2] = ctx->Current.TexCoord[2];
#line 29097
  VB->TexCoord[count][3] = ctx->Current.TexCoord[3];
#line 29098
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 29099
  count ++;
#line 29100
  VB->Count = count;
#line 29101
  if (count == 480U) {
#line 29102
    gl_transform_vb_part1(ctx, 0);
  }
#line 29104
  return;
}
}
#line 29105 "D:/a/test/177.c"
static void vertex3fv_color(GLcontext *ctx , float const   *v ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 29107
  VB = ctx->VB;
#line 29108
  count = VB->Count;
#line 29109
  VB->Obj[count][0] = (float )*(v + 0);
#line 29109
  VB->Obj[count][1] = (float )*(v + 1);
#line 29109
  VB->Obj[count][2] = (float )*(v + 2);
#line 29110
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 29110
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)(ctx->Current.ByteColor));
  } else {
#line 29110
    VB->Fcolor[count][0] = ctx->Current.ByteColor[0];
#line 29110
    VB->Fcolor[count][1] = ctx->Current.ByteColor[1];
#line 29110
    VB->Fcolor[count][2] = ctx->Current.ByteColor[2];
#line 29110
    VB->Fcolor[count][3] = ctx->Current.ByteColor[3];
  }
#line 29111
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 29112
  count ++;
#line 29113
  VB->Count = count;
#line 29114
  if (count == 480U) {
#line 29115
    gl_transform_vb_part1(ctx, 0);
  }
#line 29117
  return;
}
}
#line 29118 "D:/a/test/177.c"
static void vertex3fv_index(GLcontext *ctx , float const   *v ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 29120
  VB = ctx->VB;
#line 29121
  count = VB->Count;
#line 29122
  VB->Obj[count][0] = (float )*(v + 0);
#line 29122
  VB->Obj[count][1] = (float )*(v + 1);
#line 29122
  VB->Obj[count][2] = (float )*(v + 2);
#line 29123
  VB->Findex[count] = ctx->Current.Index;
#line 29124
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 29125
  count ++;
#line 29126
  VB->Count = count;
#line 29127
  if (count == 480U) {
#line 29128
    gl_transform_vb_part1(ctx, 0);
  }
#line 29130
  return;
}
}
#line 29131 "D:/a/test/177.c"
void gl_vertex4f_nop(GLcontext *ctx , float x , float y , float z , float w ) 
{ 

  {
#line 29134
  gl_error(ctx, 1282, "glVertex4");
#line 29135
  return;
}
}
#line 29136 "D:/a/test/177.c"
void gl_vertex3f_nop(GLcontext *ctx , float x , float y , float z ) 
{ 

  {
#line 29138
  gl_error(ctx, 1282, "glVertex3");
#line 29139
  return;
}
}
#line 29140 "D:/a/test/177.c"
void gl_vertex2f_nop(GLcontext *ctx , float x , float y ) 
{ 

  {
#line 29142
  gl_error(ctx, 1282, "glVertex2");
#line 29143
  return;
}
}
#line 29144 "D:/a/test/177.c"
void gl_vertex3fv_nop(GLcontext *ctx , float const   *v ) 
{ 

  {
#line 29146
  gl_error(ctx, 1282, "glVertex3v");
#line 29147
  return;
}
}
#line 29148 "D:/a/test/177.c"
void gl_TexCoord2f(GLcontext *ctx , float s , float t ) 
{ 

  {
#line 29150
  ctx->Current.TexCoord[0] = s;
#line 29151
  ctx->Current.TexCoord[1] = t;
#line 29152
  return;
}
}
#line 29153 "D:/a/test/177.c"
void gl_TexCoord2f4(GLcontext *ctx , float s , float t ) 
{ 

  {
#line 29155
  ctx->Current.TexCoord[0] = s;
#line 29156
  ctx->Current.TexCoord[1] = t;
#line 29157
  ctx->Current.TexCoord[2] = 0.0F;
#line 29158
  ctx->Current.TexCoord[3] = 1.0F;
#line 29159
  return;
}
}
#line 29160 "D:/a/test/177.c"
void gl_TexCoord4f(GLcontext *ctx , float s , float t , float r , float q ) 
{ void (*tmp___0)(GLcontext * , float  , float  ) ;

  {
#line 29162
  ctx->Current.TexCoord[0] = s;
#line 29163
  ctx->Current.TexCoord[1] = t;
#line 29164
  ctx->Current.TexCoord[2] = r;
#line 29165
  ctx->Current.TexCoord[3] = q;
#line 29166
  if ((ctx->VB)->TexCoordSize == 2U) {
#line 29167
    (ctx->VB)->TexCoordSize = 4U;
#line 29168
    gl_set_vertex_function(ctx);
#line 29169
    tmp___0 = & gl_TexCoord2f4;
#line 29169
    ctx->API.TexCoord2f = tmp___0;
#line 29169
    ctx->Exec.TexCoord2f = tmp___0;
  }
#line 29171
  return;
}
}
#line 29172 "D:/a/test/177.c"
void gl_set_vertex_function(GLcontext *ctx ) 
{ 

  {
#line 29174
  if (ctx->RenderMode == 7169) {
#line 29175
    ctx->Exec.Vertex4f = & vertex4f_feedback;
#line 29176
    ctx->Exec.Vertex3f = & vertex3f_feedback;
#line 29177
    ctx->Exec.Vertex2f = & vertex2f_feedback;
#line 29178
    ctx->Exec.Vertex3fv = (void (*)(GLcontext * , float const   * ))(& vertex3fv_feedback);
  } else {
#line 29181
    ctx->Exec.Vertex4f = & vertex4;
#line 29182
    if ((ctx->Visual)->RGBAflag) {
#line 29183
      if (ctx->NeedNormals) {
#line 29184
        if (ctx->Texture.Enabled) {
#line 29185
          if ((ctx->VB)->TexCoordSize == 2U) {
#line 29186
            ctx->Exec.Vertex2f = & vertex2f_normal_color_tex2;
#line 29187
            ctx->Exec.Vertex3f = & vertex3f_normal_color_tex2;
#line 29188
            ctx->Exec.Vertex3fv = (void (*)(GLcontext * , float const   * ))(& vertex3fv_normal_color_tex2);
          } else {
#line 29191
            ctx->Exec.Vertex2f = & vertex2f_normal_color_tex4;
#line 29192
            ctx->Exec.Vertex3f = & vertex3f_normal_color_tex4;
#line 29193
            ctx->Exec.Vertex3fv = (void (*)(GLcontext * , float const   * ))(& vertex3fv_normal_color_tex4);
          }
        } else {
#line 29197
          ctx->Exec.Vertex2f = & vertex2f_normal;
#line 29198
          ctx->Exec.Vertex3f = & vertex3f_normal;
#line 29199
          ctx->Exec.Vertex3fv = (void (*)(GLcontext * , float const   * ))(& vertex3fv_normal);
        }
      } else {
#line 29203
        if (ctx->Texture.Enabled) {
#line 29204
          if ((ctx->VB)->TexCoordSize == 2U) {
#line 29205
            ctx->Exec.Vertex2f = & vertex2f_color_tex2;
#line 29206
            ctx->Exec.Vertex3f = & vertex3f_color_tex2;
#line 29207
            ctx->Exec.Vertex3fv = (void (*)(GLcontext * , float const   * ))(& vertex3fv_color_tex2);
          } else {
#line 29210
            ctx->Exec.Vertex2f = & vertex2f_color_tex4;
#line 29211
            ctx->Exec.Vertex3f = & vertex3f_color_tex4;
#line 29212
            ctx->Exec.Vertex3fv = (void (*)(GLcontext * , float const   * ))(& vertex3fv_color_tex4);
          }
        } else {
#line 29216
          ctx->Exec.Vertex2f = & vertex2f_color;
#line 29217
          ctx->Exec.Vertex3f = & vertex3f_color;
#line 29218
          ctx->Exec.Vertex3fv = (void (*)(GLcontext * , float const   * ))(& vertex3fv_color);
        }
      }
    } else {
#line 29223
      if (ctx->Light.Enabled) {
#line 29224
        ctx->Exec.Vertex2f = & vertex2f_normal;
#line 29225
        ctx->Exec.Vertex3f = & vertex3f_normal;
#line 29226
        ctx->Exec.Vertex3fv = (void (*)(GLcontext * , float const   * ))(& vertex3fv_normal);
      } else {
#line 29229
        ctx->Exec.Vertex2f = & vertex2f_index;
#line 29230
        ctx->Exec.Vertex3f = & vertex3f_index;
#line 29231
        ctx->Exec.Vertex3fv = (void (*)(GLcontext * , float const   * ))(& vertex3fv_index);
      }
    }
  }
#line 29235
  if (! ctx->CompileFlag) {
#line 29236
    ctx->API.Vertex2f = ctx->Exec.Vertex2f;
#line 29237
    ctx->API.Vertex3f = ctx->Exec.Vertex3f;
#line 29238
    ctx->API.Vertex4f = ctx->Exec.Vertex4f;
#line 29239
    ctx->API.Vertex3fv = ctx->Exec.Vertex3fv;
  }
#line 29241
  return;
}
}
#line 29242 "D:/a/test/177.c"
void gl_set_color_function(GLcontext *ctx ) 
{ 

  {
#line 29245
  if (ctx->Light.ColorMaterialEnabled) {
#line 29246
    ctx->Exec.Color3f = & gl_ColorMat3f;
#line 29247
    ctx->Exec.Color3fv = & gl_ColorMat3fv;
#line 29248
    ctx->Exec.Color4f = & gl_ColorMat4f;
#line 29249
    ctx->Exec.Color4fv = & gl_ColorMat4fv;
#line 29250
    ctx->Exec.Color4ub = & gl_ColorMat4ub;
#line 29251
    ctx->Exec.Color4ubv = & gl_ColorMat4ubv;
  } else {
#line 29254
    ctx->Exec.Color3f = & gl_Color3f;
#line 29255
    ctx->Exec.Color3fv = & gl_Color3fv;
#line 29256
    ctx->Exec.Color4f = & gl_Color4f;
#line 29257
    ctx->Exec.Color4fv = & gl_Color4fv;
#line 29258
    if ((ctx->Visual)->EightBitColor) {
#line 29258
      ctx->Exec.Color4ub = & gl_Color4ub8bit;
    } else {
#line 29258
      ctx->Exec.Color4ub = & gl_Color4ub;
    }
#line 29260
    if ((ctx->Visual)->EightBitColor) {
#line 29260
      ctx->Exec.Color4ubv = & gl_Color4ubv8bit;
    } else {
#line 29260
      ctx->Exec.Color4ubv = & gl_Color4ubv;
    }
  }
#line 29263
  if (! ctx->CompileFlag) {
#line 29264
    ctx->API.Color3f = ctx->Exec.Color3f;
#line 29265
    ctx->API.Color3fv = ctx->Exec.Color3fv;
#line 29266
    ctx->API.Color4f = ctx->Exec.Color4f;
#line 29267
    ctx->API.Color4fv = ctx->Exec.Color4fv;
#line 29268
    ctx->API.Color4ub = ctx->Exec.Color4ub;
#line 29269
    ctx->API.Color4ubv = ctx->Exec.Color4ubv;
  }
#line 29271
  return;
}
}
#line 29272 "D:/a/test/177.c"
void gl_eval_vertex(GLcontext *ctx , float const   *vertex , float const   *normal ,
                    GLubyte const   *color , GLuint index___0 , float const   *texcoord ) 
{ struct vertex_buffer *VB ;
  GLuint count ;

  {
#line 29278
  VB = ctx->VB;
#line 29279
  count = VB->Count;
#line 29280
  VB->VertexSizeMask = 4U;
#line 29281
  VB->MonoNormal = (unsigned char)0;
#line 29282
  VB->Obj[count][0] = (float )*(vertex + 0);
#line 29282
  VB->Obj[count][1] = (float )*(vertex + 1);
#line 29282
  VB->Obj[count][2] = (float )*(vertex + 2);
#line 29282
  VB->Obj[count][3] = (float )*(vertex + 3);
#line 29283
  VB->Normal[count][0] = (float )*(normal + 0);
#line 29283
  VB->Normal[count][1] = (float )*(normal + 1);
#line 29283
  VB->Normal[count][2] = (float )*(normal + 2);
#line 29284
  if (sizeof(GLuint ) == 4U * sizeof(GLubyte )) {
#line 29284
    *((GLuint *)(VB->Fcolor[count])) = *((GLuint *)color);
  } else {
#line 29284
    VB->Fcolor[count][0] = (unsigned char )*(color + 0);
#line 29284
    VB->Fcolor[count][1] = (unsigned char )*(color + 1);
#line 29284
    VB->Fcolor[count][2] = (unsigned char )*(color + 2);
#line 29284
    VB->Fcolor[count][3] = (unsigned char )*(color + 3);
  }
#line 29296
  VB->Findex[count] = index___0;
#line 29297
  VB->TexCoord[count][0] = (float )*(texcoord + 0);
#line 29297
  VB->TexCoord[count][1] = (float )*(texcoord + 1);
#line 29297
  VB->TexCoord[count][2] = (float )*(texcoord + 2);
#line 29297
  VB->TexCoord[count][3] = (float )*(texcoord + 3);
#line 29298
  VB->Edgeflag[count] = ctx->Current.EdgeFlag;
#line 29299
  count ++;
#line 29300
  VB->Count = count;
#line 29301
  if (count == 480U) {
#line 29302
    gl_transform_vb_part1(ctx, 0);
  }
#line 29304
  return;
}
}
#line 29308 "D:/a/test/177.c"
void gl_Begin(GLcontext *ctx , GLenum p ) 
{ struct vertex_buffer *VB ;
  struct pixel_buffer *PB ;
  GLuint tmp___0 ;
  GLubyte r ;
  GLubyte g ;
  GLubyte b ;
  GLubyte a ;
  int tmp___1 ;

  {
#line 29310
  VB = ctx->VB;
#line 29311
  PB = ctx->PB;
#line 29315
  if (ctx->Primitive != 6656) {
#line 29316
    gl_error(ctx, 1282, "glBegin");
#line 29317
    return;
  }
#line 29319
  if (ctx->NewModelViewMatrix) {
#line 29320
    gl_analyze_modelview_matrix(ctx);
  }
#line 29322
  if (ctx->NewProjectionMatrix) {
#line 29323
    gl_analyze_projection_matrix(ctx);
  }
#line 29325
  if (ctx->NewState) {
#line 29326
    gl_update_state(ctx);
  } else {
#line 29328
    if ((unsigned int )ctx->Exec.Vertex3f == (unsigned int )(& gl_vertex3f_nop)) {
#line 29329
      gl_set_vertex_function(ctx);
    }
  }
#line 29331
  if (ctx->Driver.Begin) {
#line 29332
    (*(ctx->Driver.Begin))(ctx, p);
  }
#line 29334
  ctx->Primitive = p;
#line 29335
  tmp___0 = 0U;
#line 29335
  VB->Count = tmp___0;
#line 29335
  VB->Start = tmp___0;
#line 29336
  VB->MonoColor = ctx->MonoPixels;
#line 29337
  VB->MonoNormal = (unsigned char)1;
#line 29338
  if (VB->MonoColor) {
#line 29339
    if ((ctx->Visual)->RGBAflag) {
#line 29340
      r = ctx->Current.ByteColor[0];
#line 29341
      g = ctx->Current.ByteColor[1];
#line 29342
      b = ctx->Current.ByteColor[2];
#line 29343
      a = ctx->Current.ByteColor[3];
#line 29344
      (*(ctx->Driver.Color))(ctx, r, g, b, a);
    } else {
#line 29347
      (*(ctx->Driver.Index))(ctx, ctx->Current.Index);
    }
  }
#line 29350
  VB->Color = VB->Fcolor;
#line 29351
  VB->Index = VB->Findex;
#line 29352
  switch (ctx->Primitive) {
  case 0: 
#line 29354
  ctx->LightTwoSide = (unsigned char)0;
#line 29355
  PB_INIT(PB, 6912);
#line 29356
  break;
  case 1: 
  case 3: 
  case 2: 
#line 29360
  ctx->LightTwoSide = (unsigned char)0;
#line 29361
  ctx->StippleCounter = 0U;
#line 29362
  PB_INIT(PB, 6913);
#line 29363
  break;
  case 4: 
  case 5: 
  case 6: 
  case 7: 
  case 8: 
  case 9: 
#line 29370
  if (ctx->Light.Enabled) {
#line 29370
    if (ctx->Light.Model.TwoSide) {
#line 29370
      tmp___1 = 1;
    } else {
#line 29370
      tmp___1 = 0;
    }
  } else {
#line 29370
    tmp___1 = 0;
  }
#line 29370
  ctx->LightTwoSide = (unsigned char )tmp___1;
#line 29371
  PB_INIT(PB, 9);
#line 29372
  break;
  default: 
#line 29374
  gl_error(ctx, 1280, "glBegin");
#line 29375
  ctx->Primitive = 6656;
  }
#line 29377
  return;
}
}
#line 29378 "D:/a/test/177.c"
void gl_End(GLcontext *ctx ) 
{ struct pixel_buffer *PB ;
  struct vertex_buffer *VB ;
  GLenum tmp___0 ;

  {
#line 29380
  PB = ctx->PB;
#line 29381
  VB = ctx->VB;
#line 29382
  if (ctx->Primitive == 6656) {
#line 29383
    gl_error(ctx, 1282, "glEnd");
#line 29384
    return;
  }
#line 29386
  if (VB->Count > VB->Start) {
#line 29387
    gl_transform_vb_part1(ctx, 1);
  }
#line 29389
  if (PB->count > 0U) {
#line 29390
    gl_flush_pb(ctx);
  }
#line 29392
  if (ctx->Driver.End) {
#line 29393
    (*(ctx->Driver.End))(ctx);
  }
#line 29395
  tmp___0 = 6656;
#line 29395
  ctx->Primitive = tmp___0;
#line 29395
  PB->primitive = tmp___0;
#line 29400
  return;
}
}
#line 29401 "D:/a/test/177.c"
void gl_DeleteTextures(GLcontext *ctx , GLsizei n , GLuint const   *texName ) 
{ GLuint i ;
  struct gl_texture_object *t ;
  void *tmp___0 ;

  {
#line 29404
  if (ctx->Primitive != 6656) {
#line 29405
    gl_error(ctx, 1282, "glAreTexturesResident");
#line 29406
    return;
  }
#line 29408
  i = 0U;
#line 29408
  while (i < (GLuint )n) {
#line 29410
    if (*(texName + i) > 0U) {
#line 29411
      tmp___0 = HashLookup((struct HashTable  const  *)(ctx->Shared)->TexObjects,
                           (unsigned int )*(texName + i));
#line 29411
      t = (struct gl_texture_object *)tmp___0;
#line 29413
      if (t) {
#line 29414
        if ((unsigned int )ctx->Texture.Current1D == (unsigned int )t) {
#line 29415
          ctx->Texture.Current1D = (ctx->Shared)->Default1D;
#line 29416
          (t->RefCount) --;
#line 29417
          //assert(t->RefCount >= 0);
        } else {
#line 29419
          if ((unsigned int )ctx->Texture.Current2D == (unsigned int )t) {
#line 29420
            ctx->Texture.Current2D = (ctx->Shared)->Default2D;
#line 29421
            (t->RefCount) --;
#line 29422
            //assert(t->RefCount >= 0);
          } else {
#line 29424
            if ((unsigned int )ctx->Texture.Current3D == (unsigned int )t) {
#line 29425
              ctx->Texture.Current3D = (ctx->Shared)->Default3D;
#line 29426
              (t->RefCount) --;
#line 29427
              //assert(t->RefCount >= 0);
            }
          }
        }
#line 29429
        if (ctx->Driver.DeleteTexture) {
#line 29430
          (*(ctx->Driver.DeleteTexture))(ctx, t);
        }
#line 29432
        if (t->RefCount == 0) {
#line 29433
          gl_free_texture_object(ctx->Shared, t);
        }
      }
    }
#line 29408
    i ++;
  }
#line 29438
  return;
}
}
#line 29439 "D:/a/test/177.c"
void gl_BindTexture(GLcontext *ctx , GLenum target , GLuint texName ) 
{ struct gl_texture_object *oldTexObj ;
  struct gl_texture_object *newTexObj ;
  struct gl_texture_object **targetPointer ;
  GLuint targetDimensions ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 29445
  if (ctx->Primitive != 6656) {
#line 29446
    gl_error(ctx, 1282, "glAreTexturesResident");
#line 29447
    return;
  }
#line 29449
  switch (target) {
  case 3552: 
#line 29451
  oldTexObj = ctx->Texture.Current1D;
#line 29452
  targetPointer = & ctx->Texture.Current1D;
#line 29453
  targetDimensions = 1U;
#line 29454
  break;
  case 3553: 
#line 29456
  oldTexObj = ctx->Texture.Current2D;
#line 29457
  targetPointer = & ctx->Texture.Current2D;
#line 29458
  targetDimensions = 2U;
#line 29459
  break;
  case 32879: 
#line 29461
  oldTexObj = ctx->Texture.Current3D;
#line 29462
  targetPointer = & ctx->Texture.Current3D;
#line 29463
  targetDimensions = 3U;
#line 29464
  break;
  default: 
#line 29466
  gl_error(ctx, 1280, "glBindTexture");
#line 29467
  return;
  }
#line 29469
  if (texName == 0U) {
#line 29470
    switch (target) {
    case 3552: 
#line 29472
    newTexObj = (ctx->Shared)->Default1D;
#line 29473
    break;
    case 3553: 
#line 29475
    newTexObj = (ctx->Shared)->Default2D;
#line 29476
    break;
    case 32879: 
#line 29478
    newTexObj = (ctx->Shared)->Default3D;
#line 29479
    break;
    default: 
#line 29481
    gl_problem((GLcontext const   *)ctx, "Bad target in gl_BindTexture");
#line 29482
    return;
    }
  } else {
#line 29486
    tmp___0 = HashLookup((struct HashTable  const  *)(ctx->Shared)->TexObjects, texName);
#line 29486
    newTexObj = (struct gl_texture_object *)tmp___0;
#line 29488
    if (newTexObj) {
#line 29489
      if (newTexObj->Dimensions != targetDimensions) {
#line 29490
        gl_error(ctx, 1282, "glBindTextureEXT");
#line 29491
        return;
      }
    } else {
#line 29495
      tmp___1 = (int )gl_alloc_texture_object(ctx->Shared, texName, targetDimensions);
#line 29495
      newTexObj = (struct gl_texture_object *)tmp___1;
    }
  }
#line 29499
  *targetPointer = newTexObj;
#line 29500
  if ((unsigned int )*targetPointer != (unsigned int )oldTexObj) {
#line 29500
    if (oldTexObj->Name > 0U) {
#line 29501
      (oldTexObj->RefCount) --;
#line 29502
      //assert(oldTexObj->RefCount >= 0);
    }
  }
#line 29504
  if (newTexObj->Name > 0U) {
#line 29505
    (newTexObj->RefCount) ++;
  }
#line 29507
  if (oldTexObj->WrapS != newTexObj->WrapS) {
#line 29513
    ctx->NewState |= 2U;
  } else {
#line 29507
    if (oldTexObj->WrapT != newTexObj->WrapT) {
#line 29513
      ctx->NewState |= 2U;
    } else {
#line 29507
      if (oldTexObj->WrapR != newTexObj->WrapR) {
#line 29513
        ctx->NewState |= 2U;
      } else {
#line 29507
        if (oldTexObj->MinFilter != newTexObj->MinFilter) {
#line 29513
          ctx->NewState |= 2U;
        } else {
#line 29507
          if (oldTexObj->MagFilter != newTexObj->MagFilter) {
#line 29513
            ctx->NewState |= 2U;
          } else {
#line 29507
            if (! newTexObj->Complete) {
#line 29513
              ctx->NewState |= 2U;
            }
          }
        }
      }
    }
  }
#line 29515
  if ((unsigned int )oldTexObj == (unsigned int )ctx->Texture.Current) {
#line 29516
    ctx->Texture.Current = newTexObj;
  }
#line 29518
  //assert(*targetPointer);
#line 29519
  if (ctx->Driver.BindTexture) {
#line 29520
    (*(ctx->Driver.BindTexture))(ctx, target, newTexObj);
  }
#line 29522
  return;
}
}
#line 29523 "D:/a/test/177.c"
void gl_PrioritizeTextures(GLcontext *ctx , GLsizei n , GLuint const   *texName ,
                           GLclampf const   *priorities ) 
{ GLuint i ;
  struct gl_texture_object *t ;
  void *tmp___0 ;
  float tmp___1 ;

  {
#line 29528
  if (ctx->Primitive != 6656) {
#line 29529
    gl_error(ctx, 1282, "glAreTexturesResident");
#line 29530
    return;
  }
#line 29532
  if (n < 0) {
#line 29533
    gl_error(ctx, 1281, "glAreTexturesResident(n)");
#line 29534
    return;
  }
#line 29536
  i = 0U;
#line 29536
  while (i < (GLuint )n) {
#line 29538
    if (*(texName + i) > 0U) {
#line 29539
      tmp___0 = HashLookup((struct HashTable  const  *)(ctx->Shared)->TexObjects,
                           (unsigned int )*(texName + i));
#line 29539
      t = (struct gl_texture_object *)tmp___0;
#line 29541
      if (t) {
#line 29542
        if (*(priorities + i) < (GLclampf const   )0.0F) {
#line 29542
          t->Priority = 0.0F;
        } else {
#line 29542
          if (*(priorities + i) > (GLclampf const   )1.0F) {
#line 29542
            tmp___1 = 1.0F;
          } else {
#line 29542
            tmp___1 = (float )*(priorities + i);
          }
#line 29542
          t->Priority = tmp___1;
        }
      }
    }
#line 29536
    i ++;
  }
#line 29546
  return;
}
}
#line 29547 "D:/a/test/177.c"
void gl_EdgeFlagPointer(GLcontext *ctx , GLsizei stride , GLboolean const   *ptr ) 
{ 

  {
#line 29550
  if (stride < 0) {
#line 29551
    gl_error(ctx, 1281, "glEdgeFlagPointer(stride)");
#line 29552
    return;
  }
#line 29554
  ctx->Array.EdgeFlagStride = stride;
#line 29555
  if (stride) {
#line 29555
    ctx->Array.EdgeFlagStrideB = stride;
  } else {
#line 29555
    ctx->Array.EdgeFlagStrideB = (int )sizeof(GLboolean );
  }
#line 29556
  ctx->Array.EdgeFlagPtr = (GLboolean *)ptr;
#line 29557
  return;
}
}
#line 29561
static void init_exec_pointers(struct gl_api_table *table ) ;
#line 29562
static void init_dlist_pointers(struct gl_api_table *table ) ;
#line 29559 "D:/a/test/177.c"
void gl_init_api_function_pointers(GLcontext *ctx ) 
{ 

  {
#line 29561
  init_exec_pointers(& ctx->Exec);
#line 29562
  init_dlist_pointers(& ctx->Save);
#line 29563
  check_pointers(& ctx->Exec);
#line 29564
  check_pointers(& ctx->Save);
#line 29565
  return;
}
}
#line 29571 "D:/a/test/177.c"
void gl_PointSize(GLcontext *ctx , float size ) 
{ 

  {
#line 29573
  if ((double )size <= 0.0) {
#line 29574
    gl_error(ctx, 1281, "glPointSize");
#line 29575
    return;
  }
#line 29577
  if (ctx->Primitive != 6656) {
#line 29578
    gl_error(ctx, 1282, "glPointSize");
#line 29579
    return;
  }
#line 29581
  ctx->Point.Size = size;
#line 29582
  ctx->NewState |= 2U;
#line 29583
  return;
}
}
#line 29584 "D:/a/test/177.c"
void gl_PointParameterfvEXT(GLcontext *ctx , GLenum pname , float const   *params ) 
{ 

  {
#line 29587
  if (ctx->Primitive != 6656) {
#line 29588
    gl_error(ctx, 1282, "glPointParameterfvEXT");
#line 29589
    return;
  }
#line 29591
  if (pname == 33065) {
#line 29592
    ctx->Point.Params[0] = (float )*(params + 0);
#line 29592
    ctx->Point.Params[1] = (float )*(params + 1);
#line 29592
    ctx->Point.Params[2] = (float )*(params + 2);
  } else {
#line 29594
    if ((double )*params < 0.0) {
#line 29595
      gl_error(ctx, 1281, "glPointParameterfvEXT");
#line 29596
      return;
    }
#line 29598
    switch (pname) {
    case 33062: 
#line 29600
    ctx->Point.MinSize = (float )*params;
#line 29601
    break;
    case 33063: 
#line 29603
    ctx->Point.MaxSize = (float )*params;
#line 29604
    break;
    case 33064: 
#line 29606
    ctx->Point.Threshold = (float )*params;
#line 29607
    break;
    default: 
#line 29609
    gl_error(ctx, 1280, "glPointParameterfvEXT");
#line 29610
    return;
    }
  }
#line 29613
  ctx->NewState |= 2U;
#line 29614
  return;
}
}
#line 29615 "D:/a/test/177.c"
static void feedback_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  GLuint i ;
  float invRedScale ;
  float invGreenScale ;
  float invBlueScale ;
  float invAlphaScale ;
  float x ;
  float y ;
  float z ;
  float w ;
  float invq ;
  float color[4] ;
  float texcoord[4] ;

  {
#line 29617
  VB = ctx->VB;
#line 29619
  invRedScale = (ctx->Visual)->InvRedScale;
#line 29620
  invGreenScale = (ctx->Visual)->InvGreenScale;
#line 29621
  invBlueScale = (ctx->Visual)->InvBlueScale;
#line 29622
  invAlphaScale = (ctx->Visual)->InvAlphaScale;
#line 29623
  i = first;
#line 29623
  while (i <= last) {
#line 29624
    if ((int )VB->ClipMask[i] == 0) {
#line 29627
      x = VB->Win[i][0];
#line 29628
      y = VB->Win[i][1];
#line 29629
      z = VB->Win[i][2] / 65535.0F;
#line 29630
      w = VB->Clip[i][3];
#line 29631
      if (ctx->Light.ShadeModel == 7425) {
#line 29632
        color[0] = ((float )(*(VB->Color + i))[0] * 0.00048828125f) * invRedScale;
#line 29633
        color[1] = ((float )(*(VB->Color + i))[1] * 0.00048828125f) * invGreenScale;
#line 29634
        color[2] = ((float )(*(VB->Color + i))[2] * 0.00048828125f) * invBlueScale;
#line 29635
        color[3] = ((float )(*(VB->Color + i))[3] * 0.00048828125f) * invAlphaScale;
      } else {
#line 29638
        color[0] = (float )(*(VB->Color + i))[0] * invRedScale;
#line 29639
        color[1] = (float )(*(VB->Color + i))[1] * invGreenScale;
#line 29640
        color[2] = (float )(*(VB->Color + i))[2] * invBlueScale;
#line 29641
        color[3] = (float )(*(VB->Color + i))[3] * invAlphaScale;
      }
#line 29643
      invq = 1.0F / VB->TexCoord[i][3];
#line 29644
      texcoord[0] = VB->TexCoord[i][0] * invq;
#line 29645
      texcoord[1] = VB->TexCoord[i][1] * invq;
#line 29646
      texcoord[2] = VB->TexCoord[i][2] * invq;
#line 29647
      texcoord[3] = VB->TexCoord[i][3];
#line 29648
      FEEDBACK_TOKEN(ctx, (float )1793);
#line 29649
      gl_feedback_vertex(ctx, x, y, z, w, (float const   *)(color), (float )*(VB->Index + i),
                         (float const   *)(texcoord));
    }
#line 29623
    i ++;
  }
#line 29653
  return;
}
}
#line 29654 "D:/a/test/177.c"
static void select_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  GLuint i ;

  {
#line 29656
  VB = ctx->VB;
#line 29658
  i = first;
#line 29658
  while (i <= last) {
#line 29659
    if ((int )VB->ClipMask[i] == 0) {
#line 29660
      gl_update_hitflag(ctx, VB->Win[i][2] / 65535.0F);
    }
#line 29658
    i ++;
  }
#line 29663
  return;
}
}
#line 29664 "D:/a/test/177.c"
void size1_ci_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  struct pixel_buffer *PB ;
  float *win ;
  GLint *pbx ;
  GLint *pby ;
  GLdepth *pbz ;
  GLuint *pbi ;
  GLuint pbcount ;
  GLuint i ;

  {
#line 29666
  VB = ctx->VB;
#line 29667
  PB = ctx->PB;
#line 29669
  pbx = PB->x;
#line 29669
  pby = PB->y;
#line 29670
  pbz = PB->z;
#line 29671
  pbi = PB->i;
#line 29672
  pbcount = PB->count;
#line 29674
  win = & VB->Win[first][0];
#line 29675
  i = first;
#line 29675
  while (i <= last) {
#line 29676
    if ((int )VB->ClipMask[i] == 0) {
#line 29677
      *(pbx + pbcount) = (int )*(win + 0);
#line 29678
      *(pby + pbcount) = (int )*(win + 1);
#line 29679
      *(pbz + pbcount) = (unsigned short )((int )(*(win + 2) + ctx->PointZoffset));
#line 29680
      *(pbi + pbcount) = *(VB->Index + i);
#line 29681
      pbcount ++;
    }
#line 29683
    win += 3;
#line 29675
    i ++;
  }
#line 29685
  PB->count = pbcount;
#line 29686
  PB_CHECK_FLUSH(ctx, PB);
#line 29687
  return;
}
}
#line 29704
int ( /* missing proto */  PB_WRITE_RGBA_PIXEL)(struct pixel_buffer *PB,GLint x,GLint y,GLint z,GLint a,GLint b,GLint c,GLint d) ;
#line 29688 "D:/a/test/177.c"
static void size1_rgba_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  struct pixel_buffer *PB ;
  GLuint i ;
  GLint x ;
  GLint y ;
  GLint z ;
  GLint red ;
  GLint green ;
  GLint blue___0 ;
  GLint alpha ;

  {
#line 29690
  VB = ctx->VB;
#line 29691
  PB = ctx->PB;
#line 29693
  i = first;
#line 29693
  while (i <= last) {
#line 29694
    if ((int )VB->ClipMask[i] == 0) {
#line 29697
      x = (int )VB->Win[i][0];
#line 29698
      y = (int )VB->Win[i][1];
#line 29699
      z = (int )(VB->Win[i][2] + ctx->PointZoffset);
#line 29700
      red = (int )(*(VB->Color + i))[0];
#line 29701
      green = (int )(*(VB->Color + i))[1];
#line 29702
      blue___0 = (int )(*(VB->Color + i))[2];
#line 29703
      alpha = (int )(*(VB->Color + i))[3];
#line 29704
      PB_WRITE_RGBA_PIXEL(PB, x, y, z, red, green, blue___0, alpha);
    }
#line 29693
    i ++;
  }
#line 29707
  PB_CHECK_FLUSH(ctx, PB);
#line 29708
  return;
}
}
#line 29709 "D:/a/test/177.c"
static void general_ci_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  struct pixel_buffer *PB ;
  GLuint i ;
  GLint isize ;
  double tmp___0 ;
  double tmp___1 ;
  GLint x ;
  GLint y ;
  GLint z ;
  GLint x0 ;
  GLint x1 ;
  GLint y0___0 ;
  GLint y1___0 ;
  GLint ix ;
  GLint iy ;

  {
#line 29711
  VB = ctx->VB;
#line 29712
  PB = ctx->PB;
#line 29715
  if ((double )ctx->Point.Size < 1.0) {
#line 29715
    tmp___1 = 1.0;
  } else {
#line 29715
    if ((double )ctx->Point.Size > 10.0) {
#line 29715
      tmp___0 = 10.0;
    } else {
#line 29715
      tmp___0 = (double )ctx->Point.Size;
    }
#line 29715
    tmp___1 = tmp___0;
  }
#line 29715
  isize = (int )(tmp___1 + (double )0.5F);
#line 29716
  i = first;
#line 29716
  while (i <= last) {
#line 29717
    if ((int )VB->ClipMask[i] == 0) {
#line 29721
      x = (int )VB->Win[i][0];
#line 29722
      y = (int )VB->Win[i][1];
#line 29723
      z = (int )(VB->Win[i][2] + ctx->PointZoffset);
#line 29724
      if (isize & 1) {
#line 29725
        x0 = x - isize / 2;
#line 29726
        x1 = x + isize / 2;
#line 29727
        y0___0 = y - isize / 2;
#line 29728
        y1___0 = y + isize / 2;
      } else {
#line 29731
        x0 = (int )((float )x + 0.5F) - isize / 2;
#line 29732
        x1 = (x0 + isize) - 1;
#line 29733
        y0___0 = (int )((float )y + 0.5F) - isize / 2;
#line 29734
        y1___0 = (y0___0 + isize) - 1;
      }
#line 29736
      PB_SET_INDEX(ctx, PB, *(VB->Index + i));
#line 29737
      iy = y0___0;
#line 29737
      while (iy <= y1___0) {
#line 29738
        ix = x0;
#line 29738
        while (ix <= x1) {
#line 29739
          PB_WRITE_PIXEL(PB, ix, iy, z);
#line 29738
          ix ++;
        }
#line 29737
        iy ++;
      }
#line 29742
      PB_CHECK_FLUSH(ctx, PB);
    }
#line 29716
    i ++;
  }
#line 29745
  return;
}
}
#line 29746 "D:/a/test/177.c"
static void general_rgba_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  struct pixel_buffer *PB ;
  GLuint i ;
  GLint isize ;
  double tmp___0 ;
  double tmp___1 ;
  GLint x ;
  GLint y ;
  GLint z ;
  GLint x0 ;
  GLint x1 ;
  GLint y0___0 ;
  GLint y1___0 ;
  GLint ix ;
  GLint iy ;

  {
#line 29748
  VB = ctx->VB;
#line 29749
  PB = ctx->PB;
#line 29752
  if ((double )ctx->Point.Size < 1.0) {
#line 29752
    tmp___1 = 1.0;
  } else {
#line 29752
    if ((double )ctx->Point.Size > 10.0) {
#line 29752
      tmp___0 = 10.0;
    } else {
#line 29752
      tmp___0 = (double )ctx->Point.Size;
    }
#line 29752
    tmp___1 = tmp___0;
  }
#line 29752
  isize = (int )(tmp___1 + (double )0.5F);
#line 29753
  i = first;
#line 29753
  while (i <= last) {
#line 29754
    if ((int )VB->ClipMask[i] == 0) {
#line 29758
      x = (int )VB->Win[i][0];
#line 29759
      y = (int )VB->Win[i][1];
#line 29760
      z = (int )(VB->Win[i][2] + ctx->PointZoffset);
#line 29761
      if (isize & 1) {
#line 29762
        x0 = x - isize / 2;
#line 29763
        x1 = x + isize / 2;
#line 29764
        y0___0 = y - isize / 2;
#line 29765
        y1___0 = y + isize / 2;
      } else {
#line 29768
        x0 = (int )((float )x + 0.5F) - isize / 2;
#line 29769
        x1 = (x0 + isize) - 1;
#line 29770
        y0___0 = (int )((float )y + 0.5F) - isize / 2;
#line 29771
        y1___0 = (y0___0 + isize) - 1;
      }
#line 29773
      PB_SET_COLOR(ctx, PB, (*(VB->Color + i))[0], (*(VB->Color + i))[1], (*(VB->Color + i))[2],
                   (*(VB->Color + i))[3]);
#line 29778
      iy = y0___0;
#line 29778
      while (iy <= y1___0) {
#line 29779
        ix = x0;
#line 29779
        while (ix <= x1) {
#line 29780
          PB_WRITE_PIXEL(PB, ix, iy, z);
#line 29779
          ix ++;
        }
#line 29778
        iy ++;
      }
#line 29783
      PB_CHECK_FLUSH(ctx, PB);
    }
#line 29753
    i ++;
  }
#line 29786
  return;
}
}
#line 29829
extern int ( /* missing proto */  PB_WRITE_TEX_PIXEL)(struct pixel_buffer *PB,GLint x,GLint y,GLint z,GLint a,GLint b,GLint c,GLint d,float f,float t,float r) ;
#line 29787 "D:/a/test/177.c"
static void textured_rgba_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  struct pixel_buffer *PB ;
  GLuint i ;
  GLint x ;
  GLint y ;
  GLint z ;
  GLint x0 ;
  GLint x1 ;
  GLint y0___0 ;
  GLint y1___0 ;
  GLint ix ;
  GLint iy ;
  GLint isize ;
  GLint red ;
  GLint green ;
  GLint blue___0 ;
  GLint alpha ;
  float s ;
  float t ;
  float u ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 29789
  VB = ctx->VB;
#line 29790
  PB = ctx->PB;
#line 29792
  i = first;
#line 29792
  while (i <= last) {
#line 29793
    if ((int )VB->ClipMask[i] == 0) {
#line 29800
      x = (int )VB->Win[i][0];
#line 29801
      y = (int )VB->Win[i][1];
#line 29802
      z = (int )(VB->Win[i][2] + ctx->PointZoffset);
#line 29803
      if ((double )ctx->Point.Size < 1.0) {
#line 29803
        tmp___1 = 1.0;
      } else {
#line 29803
        if ((double )ctx->Point.Size > 10.0) {
#line 29803
          tmp___0 = 10.0;
        } else {
#line 29803
          tmp___0 = (double )ctx->Point.Size;
        }
#line 29803
        tmp___1 = tmp___0;
      }
#line 29803
      isize = (int )(tmp___1 + (double )0.5F);
#line 29805
      if (isize < 1) {
#line 29806
        isize = 1;
      }
#line 29808
      if (isize & 1) {
#line 29809
        x0 = x - isize / 2;
#line 29810
        x1 = x + isize / 2;
#line 29811
        y0___0 = y - isize / 2;
#line 29812
        y1___0 = y + isize / 2;
      } else {
#line 29815
        x0 = (int )((float )x + 0.5F) - isize / 2;
#line 29816
        x1 = (x0 + isize) - 1;
#line 29817
        y0___0 = (int )((float )y + 0.5F) - isize / 2;
#line 29818
        y1___0 = (y0___0 + isize) - 1;
      }
#line 29820
      red = (int )(*(VB->Color + i))[0];
#line 29821
      green = (int )(*(VB->Color + i))[1];
#line 29822
      blue___0 = (int )(*(VB->Color + i))[2];
#line 29823
      alpha = (int )(*(VB->Color + i))[3];
#line 29824
      s = VB->TexCoord[i][0] / VB->TexCoord[i][3];
#line 29825
      t = VB->TexCoord[i][1] / VB->TexCoord[i][3];
#line 29826
      u = VB->TexCoord[i][2] / VB->TexCoord[i][3];
#line 29827
      iy = y0___0;
#line 29827
      while (iy <= y1___0) {
#line 29828
        ix = x0;
#line 29828
        while (ix <= x1) {
#line 29829
          PB_WRITE_TEX_PIXEL(PB, ix, iy, z, red, green, blue___0, alpha, s, t, u);
#line 29828
          ix ++;
        }
#line 29827
        iy ++;
      }
#line 29832
      PB_CHECK_FLUSH(ctx, PB);
    }
#line 29792
    i ++;
  }
#line 29835
  return;
}
}
#line 29836 "D:/a/test/177.c"
static void antialiased_rgba_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  struct pixel_buffer *PB ;
  GLuint i ;
  float radius ;
  float rmin ;
  float rmax ;
  float rmin2 ;
  float rmax2 ;
  float cscale ;
  double tmp___0 ;
  double tmp___1 ;
  GLint xmin ;
  GLint ymin ;
  GLint xmax ;
  GLint ymax ;
  GLint x ;
  GLint y ;
  GLint z ;
  GLint red ;
  GLint green ;
  GLint blue___0 ;
  GLint alpha ;
  float s ;
  float t ;
  float u ;
  float dx ;
  float dy ;
  float dist2 ;
  GLint coverage ;
  GLint xmin___0 ;
  GLint ymin___0 ;
  GLint xmax___0 ;
  GLint ymax___0 ;
  GLint x___0 ;
  GLint y___0 ;
  GLint z___0 ;
  GLint red___0 ;
  GLint green___0 ;
  GLint blue___1 ;
  GLint alpha___0 ;
  float dx___0 ;
  float dy___0 ;
  float dist2___0 ;
  GLint coverage___0 ;

  {
#line 29839
  VB = ctx->VB;
#line 29840
  PB = ctx->PB;
#line 29843
  if ((double )ctx->Point.Size < 1.0) {
#line 29843
    tmp___1 = 1.0;
  } else {
#line 29843
    if ((double )ctx->Point.Size > 10.0) {
#line 29843
      tmp___0 = 10.0;
    } else {
#line 29843
      tmp___0 = (double )ctx->Point.Size;
    }
#line 29843
    tmp___1 = tmp___0;
  }
#line 29843
  radius = (float )(tmp___1 * (double )0.5F);
#line 29844
  rmin = radius - 0.7071F;
#line 29845
  rmax = radius + 0.7071F;
#line 29846
  rmin2 = rmin * rmin;
#line 29847
  rmax2 = rmax * rmax;
#line 29848
  cscale = 256.0F / (rmax2 - rmin2);
#line 29849
  if (ctx->Texture.Enabled) {
#line 29850
    i = first;
#line 29850
    while (i <= last) {
#line 29851
      if ((int )VB->ClipMask[i] == 0) {
#line 29856
        xmin = (int )(VB->Win[i][0] - radius);
#line 29857
        xmax = (int )(VB->Win[i][0] + radius);
#line 29858
        ymin = (int )(VB->Win[i][1] - radius);
#line 29859
        ymax = (int )(VB->Win[i][1] + radius);
#line 29860
        z = (int )(VB->Win[i][2] + ctx->PointZoffset);
#line 29861
        red = (int )(*(VB->Color + i))[0];
#line 29862
        green = (int )(*(VB->Color + i))[1];
#line 29863
        blue___0 = (int )(*(VB->Color + i))[2];
#line 29864
        s = VB->TexCoord[i][0] / VB->TexCoord[i][3];
#line 29865
        t = VB->TexCoord[i][1] / VB->TexCoord[i][3];
#line 29866
        u = VB->TexCoord[i][2] / VB->TexCoord[i][3];
#line 29867
        y = ymin;
#line 29867
        while (y <= ymax) {
#line 29868
          x = xmin;
#line 29868
          while (x <= xmax) {
#line 29869
            dx = (float )x - VB->Win[i][0];
#line 29870
            dy = (float )y - VB->Win[i][1];
#line 29871
            dist2 = dx * dx + dy * dy;
#line 29872
            if (dist2 < rmax2) {
#line 29873
              alpha = (int )(*(VB->Color + i))[3];
#line 29874
              if (dist2 >= rmin2) {
#line 29875
                coverage = (int )(256.0F - (dist2 - rmin2) * cscale);
#line 29876
                alpha = alpha * coverage >> 8;
              }
#line 29878
              PB_WRITE_TEX_PIXEL(PB, x, y, z, red, green, blue___0, alpha, s, t, u);
            }
#line 29868
            x ++;
          }
#line 29867
          y ++;
        }
#line 29882
        PB_CHECK_FLUSH(ctx, PB);
      }
#line 29850
      i ++;
    }
  } else {
#line 29887
    i = first;
#line 29887
    while (i <= last) {
#line 29888
      if ((int )VB->ClipMask[i] == 0) {
#line 29892
        xmin___0 = (int )(VB->Win[i][0] - radius);
#line 29893
        xmax___0 = (int )(VB->Win[i][0] + radius);
#line 29894
        ymin___0 = (int )(VB->Win[i][1] - radius);
#line 29895
        ymax___0 = (int )(VB->Win[i][1] + radius);
#line 29896
        z___0 = (int )(VB->Win[i][2] + ctx->PointZoffset);
#line 29897
        red___0 = (int )(*(VB->Color + i))[0];
#line 29898
        green___0 = (int )(*(VB->Color + i))[1];
#line 29899
        blue___1 = (int )(*(VB->Color + i))[2];
#line 29900
        y___0 = ymin___0;
#line 29900
        while (y___0 <= ymax___0) {
#line 29901
          x___0 = xmin___0;
#line 29901
          while (x___0 <= xmax___0) {
#line 29902
            dx___0 = (float )x___0 - VB->Win[i][0];
#line 29903
            dy___0 = (float )y___0 - VB->Win[i][1];
#line 29904
            dist2___0 = dx___0 * dx___0 + dy___0 * dy___0;
#line 29905
            if (dist2___0 < rmax2) {
#line 29906
              alpha___0 = (int )(*(VB->Color + i))[3];
#line 29907
              if (dist2___0 >= rmin2) {
#line 29908
                coverage___0 = (int )(256.0F - (dist2___0 - rmin2) * cscale);
#line 29909
                alpha___0 = alpha___0 * coverage___0 >> 8;
              }
#line 29911
              PB_WRITE_RGBA_PIXEL(PB, x___0, y___0, z___0, red___0, green___0, blue___1,
                                  alpha___0);
            }
#line 29901
            x___0 ++;
          }
#line 29900
          y___0 ++;
        }
#line 29915
        PB_CHECK_FLUSH(ctx, PB);
      }
#line 29887
      i ++;
    }
  }
#line 29919
  return;
}
}
#line 29920 "D:/a/test/177.c"
static void null_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ 

  {
#line 29922
  return;
}
}
#line 29923 "D:/a/test/177.c"
static float dist_attenuation(GLcontext *ctx , float const   *p ) 
{ float dist ;
  int tmp___0 ;

  {
#line 29926
  tmp___0 = GL_SQRT((*(p + 0) * *(p + 0) + *(p + 1) * *(p + 1)) + *(p + 2) * *(p + 2));
#line 29926
  dist = (float )tmp___0;
#line 29927
  return ((float )1 / ((ctx->Point.Params[0] + ctx->Point.Params[1] * dist) + (ctx->Point.Params[2] * dist) * dist));
}
}
#line 29930 "D:/a/test/177.c"
static void dist_atten_general_ci_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  struct pixel_buffer *PB ;
  GLuint i ;
  GLint isize ;
  float psize ;
  float dsize ;
  double tmp___0 ;
  GLint x ;
  GLint y ;
  GLint z ;
  GLint x0 ;
  GLint x1 ;
  GLint y0___0 ;
  GLint y1___0 ;
  GLint ix ;
  GLint iy ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;

  {
#line 29933
  VB = ctx->VB;
#line 29934
  PB = ctx->PB;
#line 29938
  if ((double )ctx->Point.Size < 1.0) {
#line 29938
    psize = (float )1.0;
  } else {
#line 29938
    if ((double )ctx->Point.Size > 10.0) {
#line 29938
      tmp___0 = 10.0;
    } else {
#line 29938
      tmp___0 = (double )ctx->Point.Size;
    }
#line 29938
    psize = (float )tmp___0;
  }
#line 29939
  i = first;
#line 29939
  while (i <= last) {
#line 29940
    if ((int )VB->ClipMask[i] == 0) {
#line 29944
      x = (int )VB->Win[i][0];
#line 29945
      y = (int )VB->Win[i][1];
#line 29946
      z = (int )(VB->Win[i][2] + ctx->PointZoffset);
#line 29947
      tmp___1 = dist_attenuation(ctx, (float const   *)(VB->Eye[i]));
#line 29947
      dsize = psize * tmp___1;
#line 29948
      if (dsize >= ctx->Point.Threshold) {
#line 29949
        if (dsize < ctx->Point.MaxSize) {
#line 29949
          tmp___2 = dsize;
        } else {
#line 29949
          tmp___2 = ctx->Point.MaxSize;
        }
#line 29949
        isize = (int )(tmp___2 + 0.5F);
      } else {
#line 29951
        if (ctx->Point.Threshold > ctx->Point.MinSize) {
#line 29951
          tmp___3 = ctx->Point.Threshold;
        } else {
#line 29951
          tmp___3 = ctx->Point.MinSize;
        }
#line 29951
        isize = (int )(tmp___3 + 0.5F);
      }
#line 29953
      if (isize & 1) {
#line 29954
        x0 = x - isize / 2;
#line 29955
        x1 = x + isize / 2;
#line 29956
        y0___0 = y - isize / 2;
#line 29957
        y1___0 = y + isize / 2;
      } else {
#line 29960
        x0 = (int )((float )x + 0.5F) - isize / 2;
#line 29961
        x1 = (x0 + isize) - 1;
#line 29962
        y0___0 = (int )((float )y + 0.5F) - isize / 2;
#line 29963
        y1___0 = (y0___0 + isize) - 1;
      }
#line 29965
      PB_SET_INDEX(ctx, PB, *(VB->Index + i));
#line 29966
      iy = y0___0;
#line 29966
      while (iy <= y1___0) {
#line 29967
        ix = x0;
#line 29967
        while (ix <= x1) {
#line 29968
          PB_WRITE_PIXEL(PB, ix, iy, z);
#line 29967
          ix ++;
        }
#line 29966
        iy ++;
      }
#line 29971
      PB_CHECK_FLUSH(ctx, PB);
    }
#line 29939
    i ++;
  }
#line 29974
  return;
}
}
#line 29975 "D:/a/test/177.c"
static void dist_atten_general_rgba_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  struct pixel_buffer *PB ;
  GLuint i ;
  GLubyte alpha ;
  GLint isize ;
  float psize ;
  float dsize ;
  double tmp___0 ;
  GLint x ;
  GLint y ;
  GLint z ;
  GLint x0 ;
  GLint x1 ;
  GLint y0___0 ;
  GLint y1___0 ;
  GLint ix ;
  GLint iy ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;

  {
#line 29978
  VB = ctx->VB;
#line 29979
  PB = ctx->PB;
#line 29984
  if ((double )ctx->Point.Size < 1.0) {
#line 29984
    psize = (float )1.0;
  } else {
#line 29984
    if ((double )ctx->Point.Size > 10.0) {
#line 29984
      tmp___0 = 10.0;
    } else {
#line 29984
      tmp___0 = (double )ctx->Point.Size;
    }
#line 29984
    psize = (float )tmp___0;
  }
#line 29985
  i = first;
#line 29985
  while (i <= last) {
#line 29986
    if ((int )VB->ClipMask[i] == 0) {
#line 29990
      x = (int )VB->Win[i][0];
#line 29991
      y = (int )VB->Win[i][1];
#line 29992
      z = (int )(VB->Win[i][2] + ctx->PointZoffset);
#line 29993
      tmp___1 = dist_attenuation(ctx, (float const   *)(VB->Eye[i]));
#line 29993
      dsize = psize * tmp___1;
#line 29994
      if (dsize >= ctx->Point.Threshold) {
#line 29995
        if (dsize < ctx->Point.MaxSize) {
#line 29995
          tmp___2 = dsize;
        } else {
#line 29995
          tmp___2 = ctx->Point.MaxSize;
        }
#line 29995
        isize = (int )(tmp___2 + 0.5F);
#line 29996
        alpha = (*(VB->Color + i))[3];
      } else {
#line 29998
        if (ctx->Point.Threshold > ctx->Point.MinSize) {
#line 29998
          tmp___3 = ctx->Point.Threshold;
        } else {
#line 29998
          tmp___3 = ctx->Point.MinSize;
        }
#line 29998
        isize = (int )(tmp___3 + 0.5F);
#line 29999
        dsize /= ctx->Point.Threshold;
#line 30000
        alpha = (unsigned char )((float )(*(VB->Color + i))[3] * (dsize * dsize));
      }
#line 30002
      if (isize & 1) {
#line 30003
        x0 = x - isize / 2;
#line 30004
        x1 = x + isize / 2;
#line 30005
        y0___0 = y - isize / 2;
#line 30006
        y1___0 = y + isize / 2;
      } else {
#line 30009
        x0 = (int )((float )x + 0.5F) - isize / 2;
#line 30010
        x1 = (x0 + isize) - 1;
#line 30011
        y0___0 = (int )((float )y + 0.5F) - isize / 2;
#line 30012
        y1___0 = (y0___0 + isize) - 1;
      }
#line 30014
      PB_SET_COLOR(ctx, PB, (*(VB->Color + i))[0], (*(VB->Color + i))[1], (*(VB->Color + i))[2],
                   alpha);
#line 30019
      iy = y0___0;
#line 30019
      while (iy <= y1___0) {
#line 30020
        ix = x0;
#line 30020
        while (ix <= x1) {
#line 30021
          PB_WRITE_PIXEL(PB, ix, iy, z);
#line 30020
          ix ++;
        }
#line 30019
        iy ++;
      }
#line 30024
      PB_CHECK_FLUSH(ctx, PB);
    }
#line 29985
    i ++;
  }
#line 30027
  return;
}
}
#line 30028 "D:/a/test/177.c"
static void dist_atten_textured_rgba_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  struct pixel_buffer *PB ;
  GLuint i ;
  float psize ;
  float dsize ;
  double tmp___0 ;
  GLint x ;
  GLint y ;
  GLint z ;
  GLint x0 ;
  GLint x1 ;
  GLint y0___0 ;
  GLint y1___0 ;
  GLint ix ;
  GLint iy ;
  GLint isize ;
  GLint red ;
  GLint green ;
  GLint blue___0 ;
  GLint alpha ;
  float s ;
  float t ;
  float u ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;

  {
#line 30031
  VB = ctx->VB;
#line 30032
  PB = ctx->PB;
#line 30035
  if ((double )ctx->Point.Size < 1.0) {
#line 30035
    psize = (float )1.0;
  } else {
#line 30035
    if ((double )ctx->Point.Size > 10.0) {
#line 30035
      tmp___0 = 10.0;
    } else {
#line 30035
      tmp___0 = (double )ctx->Point.Size;
    }
#line 30035
    psize = (float )tmp___0;
  }
#line 30036
  i = first;
#line 30036
  while (i <= last) {
#line 30037
    if ((int )VB->ClipMask[i] == 0) {
#line 30044
      x = (int )VB->Win[i][0];
#line 30045
      y = (int )VB->Win[i][1];
#line 30046
      z = (int )(VB->Win[i][2] + ctx->PointZoffset);
#line 30047
      tmp___1 = dist_attenuation(ctx, (float const   *)(VB->Eye[i]));
#line 30047
      dsize = psize * tmp___1;
#line 30048
      if (dsize >= ctx->Point.Threshold) {
#line 30049
        if (dsize < ctx->Point.MaxSize) {
#line 30049
          tmp___2 = dsize;
        } else {
#line 30049
          tmp___2 = ctx->Point.MaxSize;
        }
#line 30049
        isize = (int )(tmp___2 + 0.5F);
#line 30050
        alpha = (int )(*(VB->Color + i))[3];
      } else {
#line 30052
        if (ctx->Point.Threshold > ctx->Point.MinSize) {
#line 30052
          tmp___3 = ctx->Point.Threshold;
        } else {
#line 30052
          tmp___3 = ctx->Point.MinSize;
        }
#line 30052
        isize = (int )(tmp___3 + 0.5F);
#line 30053
        dsize /= ctx->Point.Threshold;
#line 30054
        alpha = (int )((float )(*(VB->Color + i))[3] * (dsize * dsize));
      }
#line 30056
      if (isize < 1) {
#line 30057
        isize = 1;
      }
#line 30059
      if (isize & 1) {
#line 30060
        x0 = x - isize / 2;
#line 30061
        x1 = x + isize / 2;
#line 30062
        y0___0 = y - isize / 2;
#line 30063
        y1___0 = y + isize / 2;
      } else {
#line 30066
        x0 = (int )((float )x + 0.5F) - isize / 2;
#line 30067
        x1 = (x0 + isize) - 1;
#line 30068
        y0___0 = (int )((float )y + 0.5F) - isize / 2;
#line 30069
        y1___0 = (y0___0 + isize) - 1;
      }
#line 30071
      red = (int )(*(VB->Color + i))[0];
#line 30072
      green = (int )(*(VB->Color + i))[1];
#line 30073
      blue___0 = (int )(*(VB->Color + i))[2];
#line 30074
      s = VB->TexCoord[i][0] / VB->TexCoord[i][3];
#line 30075
      t = VB->TexCoord[i][1] / VB->TexCoord[i][3];
#line 30076
      u = VB->TexCoord[i][2] / VB->TexCoord[i][3];
#line 30077
      iy = y0___0;
#line 30077
      while (iy <= y1___0) {
#line 30078
        ix = x0;
#line 30078
        while (ix <= x1) {
#line 30079
          PB_WRITE_TEX_PIXEL(PB, ix, iy, z, red, green, blue___0, alpha, s, t, u);
#line 30078
          ix ++;
        }
#line 30077
        iy ++;
      }
#line 30083
      PB_CHECK_FLUSH(ctx, PB);
    }
#line 30036
    i ++;
  }
#line 30086
  return;
}
}
#line 30087 "D:/a/test/177.c"
static void dist_atten_antialiased_rgba_points(GLcontext *ctx , GLuint first , GLuint last ) 
{ struct vertex_buffer *VB ;
  struct pixel_buffer *PB ;
  GLuint i ;
  float radius ;
  float rmin ;
  float rmax ;
  float rmin2 ;
  float rmax2 ;
  float cscale ;
  float psize ;
  float dsize ;
  float alphaf ;
  double tmp___0 ;
  GLint xmin ;
  GLint ymin ;
  GLint xmax ;
  GLint ymax ;
  GLint x ;
  GLint y ;
  GLint z ;
  GLint red ;
  GLint green ;
  GLint blue___0 ;
  GLint alpha ;
  float s ;
  float t ;
  float u ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float dx ;
  float dy ;
  float dist2 ;
  GLint coverage ;
  GLint xmin___0 ;
  GLint ymin___0 ;
  GLint xmax___0 ;
  GLint ymax___0 ;
  GLint x___0 ;
  GLint y___0 ;
  GLint z___0 ;
  GLint red___0 ;
  GLint green___0 ;
  GLint blue___1 ;
  GLint alpha___0 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float dx___0 ;
  float dy___0 ;
  float dist2___0 ;
  GLint coverage___0 ;

  {
#line 30090
  VB = ctx->VB;
#line 30091
  PB = ctx->PB;
#line 30095
  if ((double )ctx->Point.Size < 1.0) {
#line 30095
    psize = (float )1.0;
  } else {
#line 30095
    if ((double )ctx->Point.Size > 10.0) {
#line 30095
      tmp___0 = 10.0;
    } else {
#line 30095
      tmp___0 = (double )ctx->Point.Size;
    }
#line 30095
    psize = (float )tmp___0;
  }
#line 30096
  if (ctx->Texture.Enabled) {
#line 30097
    i = first;
#line 30097
    while (i <= last) {
#line 30098
      if ((int )VB->ClipMask[i] == 0) {
#line 30103
        tmp___1 = dist_attenuation(ctx, (float const   *)(VB->Eye[i]));
#line 30103
        dsize = psize * tmp___1;
#line 30104
        if (dsize >= ctx->Point.Threshold) {
#line 30105
          if (dsize < ctx->Point.MaxSize) {
#line 30105
            tmp___2 = dsize;
          } else {
#line 30105
            tmp___2 = ctx->Point.MaxSize;
          }
#line 30105
          radius = tmp___2 * 0.5F;
#line 30106
          alphaf = (float )1.0;
        } else {
#line 30108
          if (ctx->Point.Threshold > ctx->Point.MinSize) {
#line 30108
            tmp___3 = ctx->Point.Threshold;
          } else {
#line 30108
            tmp___3 = ctx->Point.MinSize;
          }
#line 30108
          radius = tmp___3 * 0.5F;
#line 30109
          dsize /= ctx->Point.Threshold;
#line 30110
          alphaf = dsize * dsize;
        }
#line 30112
        rmin = radius - 0.7071F;
#line 30113
        rmax = radius + 0.7071F;
#line 30114
        rmin2 = rmin * rmin;
#line 30115
        rmax2 = rmax * rmax;
#line 30116
        cscale = 256.0F / (rmax2 - rmin2);
#line 30117
        xmin = (int )(VB->Win[i][0] - radius);
#line 30118
        xmax = (int )(VB->Win[i][0] + radius);
#line 30119
        ymin = (int )(VB->Win[i][1] - radius);
#line 30120
        ymax = (int )(VB->Win[i][1] + radius);
#line 30121
        z = (int )(VB->Win[i][2] + ctx->PointZoffset);
#line 30122
        red = (int )(*(VB->Color + i))[0];
#line 30123
        green = (int )(*(VB->Color + i))[1];
#line 30124
        blue___0 = (int )(*(VB->Color + i))[2];
#line 30125
        s = VB->TexCoord[i][0] / VB->TexCoord[i][3];
#line 30126
        t = VB->TexCoord[i][1] / VB->TexCoord[i][3];
#line 30127
        u = VB->TexCoord[i][2] / VB->TexCoord[i][3];
#line 30128
        y = ymin;
#line 30128
        while (y <= ymax) {
#line 30129
          x = xmin;
#line 30129
          while (x <= xmax) {
#line 30130
            dx = (float )x - VB->Win[i][0];
#line 30131
            dy = (float )y - VB->Win[i][1];
#line 30132
            dist2 = dx * dx + dy * dy;
#line 30133
            if (dist2 < rmax2) {
#line 30134
              alpha = (int )(*(VB->Color + i))[3];
#line 30135
              if (dist2 >= rmin2) {
#line 30136
                coverage = (int )(256.0F - (dist2 - rmin2) * cscale);
#line 30137
                alpha = alpha * coverage >> 8;
              }
#line 30139
              alpha = (int )((float )alpha * alphaf);
#line 30140
              PB_WRITE_TEX_PIXEL(PB, x, y, z, red, green, blue___0, alpha, s, t, u);
            }
#line 30129
            x ++;
          }
#line 30128
          y ++;
        }
#line 30145
        PB_CHECK_FLUSH(ctx, PB);
      }
#line 30097
      i ++;
    }
  } else {
#line 30150
    i = first;
#line 30150
    while (i <= last) {
#line 30151
      if ((int )VB->ClipMask[i] == 0) {
#line 30155
        tmp___4 = dist_attenuation(ctx, (float const   *)(VB->Eye[i]));
#line 30155
        dsize = psize * tmp___4;
#line 30156
        if (dsize >= ctx->Point.Threshold) {
#line 30157
          if (dsize < ctx->Point.MaxSize) {
#line 30157
            tmp___5 = dsize;
          } else {
#line 30157
            tmp___5 = ctx->Point.MaxSize;
          }
#line 30157
          radius = tmp___5 * 0.5F;
#line 30158
          alphaf = (float )1.0;
        } else {
#line 30160
          if (ctx->Point.Threshold > ctx->Point.MinSize) {
#line 30160
            tmp___6 = ctx->Point.Threshold;
          } else {
#line 30160
            tmp___6 = ctx->Point.MinSize;
          }
#line 30160
          radius = tmp___6 * 0.5F;
#line 30161
          dsize /= ctx->Point.Threshold;
#line 30162
          alphaf = dsize * dsize;
        }
#line 30164
        rmin = radius - 0.7071F;
#line 30165
        rmax = radius + 0.7071F;
#line 30166
        rmin2 = rmin * rmin;
#line 30167
        rmax2 = rmax * rmax;
#line 30168
        cscale = 256.0F / (rmax2 - rmin2);
#line 30169
        xmin___0 = (int )(VB->Win[i][0] - radius);
#line 30170
        xmax___0 = (int )(VB->Win[i][0] + radius);
#line 30171
        ymin___0 = (int )(VB->Win[i][1] - radius);
#line 30172
        ymax___0 = (int )(VB->Win[i][1] + radius);
#line 30173
        z___0 = (int )(VB->Win[i][2] + ctx->PointZoffset);
#line 30174
        red___0 = (int )(*(VB->Color + i))[0];
#line 30175
        green___0 = (int )(*(VB->Color + i))[1];
#line 30176
        blue___1 = (int )(*(VB->Color + i))[2];
#line 30177
        y___0 = ymin___0;
#line 30177
        while (y___0 <= ymax___0) {
#line 30178
          x___0 = xmin___0;
#line 30178
          while (x___0 <= xmax___0) {
#line 30179
            dx___0 = (float )x___0 - VB->Win[i][0];
#line 30180
            dy___0 = (float )y___0 - VB->Win[i][1];
#line 30181
            dist2___0 = dx___0 * dx___0 + dy___0 * dy___0;
#line 30182
            if (dist2___0 < rmax2) {
#line 30183
              alpha___0 = (int )(*(VB->Color + i))[3];
#line 30184
              if (dist2___0 >= rmin2) {
#line 30185
                coverage___0 = (int )(256.0F - (dist2___0 - rmin2) * cscale);
#line 30186
                alpha___0 = alpha___0 * coverage___0 >> 8;
              }
#line 30188
              alpha___0 = (int )((float )alpha___0 * alphaf);
#line 30189
              PB_WRITE_RGBA_PIXEL(PB, x___0, y___0, z___0, red___0, green___0, blue___1,
                                  alpha___0);
            }
#line 30178
            x___0 ++;
          }
#line 30177
          y___0 ++;
        }
#line 30194
        PB_CHECK_FLUSH(ctx, PB);
      }
#line 30150
      i ++;
    }
  }
#line 30198
  return;
}
}
#line 30199 "D:/a/test/177.c"
void gl_set_point_function(GLcontext *ctx ) 
{ GLboolean rgbmode ;

  {
#line 30201
  rgbmode = (ctx->Visual)->RGBAflag;
#line 30202
  if (ctx->RenderMode == 7168) {
#line 30203
    if (ctx->NoRaster) {
#line 30204
      ctx->Driver.PointsFunc = & null_points;
#line 30205
      return;
    }
#line 30207
    if (ctx->Driver.PointsFunc) {
#line 30208
      ctx->Driver.PointsFunc = ctx->Driver.PointsFunc;
    } else {
#line 30210
      if ((double )ctx->Point.Params[0] == 1.0) {
#line 30210
        if ((double )ctx->Point.Params[1] == 0.0) {
#line 30210
          if ((double )ctx->Point.Params[2] == 0.0) {
#line 30212
            if (ctx->Point.SmoothFlag) {
#line 30212
              if (rgbmode) {
#line 30213
                ctx->Driver.PointsFunc = & antialiased_rgba_points;
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 30215
              if (ctx->Texture.Enabled) {
#line 30216
                ctx->Driver.PointsFunc = & textured_rgba_points;
              } else {
#line 30218
                if ((double )ctx->Point.Size == 1.0) {
#line 30219
                  if (rgbmode) {
#line 30219
                    ctx->Driver.PointsFunc = & size1_rgba_points;
                  } else {
#line 30219
                    ctx->Driver.PointsFunc = & size1_ci_points;
                  }
                } else {
#line 30224
                  if (rgbmode) {
#line 30224
                    ctx->Driver.PointsFunc = & general_rgba_points;
                  } else {
#line 30224
                    ctx->Driver.PointsFunc = & general_ci_points;
                  }
                }
              }
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 30228
        if (ctx->Point.SmoothFlag) {
#line 30228
          if (rgbmode) {
#line 30229
            ctx->Driver.PointsFunc = & dist_atten_antialiased_rgba_points;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 30231
          if (ctx->Texture.Enabled) {
#line 30232
            ctx->Driver.PointsFunc = & dist_atten_textured_rgba_points;
          } else {
#line 30235
            if (rgbmode) {
#line 30235
              ctx->Driver.PointsFunc = & dist_atten_general_rgba_points;
            } else {
#line 30235
              ctx->Driver.PointsFunc = & dist_atten_general_ci_points;
            }
          }
        }
      }
    }
  } else {
#line 30239
    if (ctx->RenderMode == 7169) {
#line 30240
      ctx->Driver.PointsFunc = & feedback_points;
    } else {
#line 30243
      ctx->Driver.PointsFunc = & select_points;
    }
  }
#line 30245
  return;
}
}
#line 30252 "D:/a/test/177.c"
void gl_CullFace(GLcontext *ctx , GLenum mode ) 
{ 

  {
#line 30254
  if (mode != 1028) {
#line 30254
    if (mode != 1029) {
#line 30254
      if (mode != 1032) {
#line 30255
        gl_error(ctx, 1280, "glCullFace");
#line 30256
        return;
      }
    }
  }
#line 30258
  if (ctx->Primitive != 6656) {
#line 30259
    gl_error(ctx, 1282, "glCullFace");
#line 30260
    return;
  }
#line 30262
  ctx->Polygon.CullFaceMode = mode;
#line 30263
  ctx->NewState |= 8U;
#line 30264
  return;
}
}
#line 30265 "D:/a/test/177.c"
void gl_FrontFace(GLcontext *ctx , GLenum mode ) 
{ 

  {
#line 30267
  if (ctx->Primitive != 6656) {
#line 30268
    gl_error(ctx, 1282, "glFrontFace");
#line 30269
    return;
  }
#line 30271
  if (mode != 2304) {
#line 30271
    if (mode != 2305) {
#line 30272
      gl_error(ctx, 1280, "glFrontFace");
#line 30273
      return;
    }
  }
#line 30275
  ctx->Polygon.FrontFace = mode;
#line 30276
  return;
}
}
#line 30277 "D:/a/test/177.c"
void gl_PolygonMode(GLcontext *ctx , GLenum face , GLenum mode ) 
{ 

  {
#line 30279
  if (ctx->Primitive != 6656) {
#line 30280
    gl_error(ctx, 1282, "glPolygonMode");
#line 30281
    return;
  }
#line 30283
  if (face != 1028) {
#line 30283
    if (face != 1029) {
#line 30283
      if (face != 1032) {
#line 30284
        gl_error(ctx, 1280, "glPolygonMode(face)");
#line 30285
        return;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 30287
    if (mode != 6912) {
#line 30287
      if (mode != 6913) {
#line 30287
        if (mode != 6914) {
#line 30288
          gl_error(ctx, 1280, "glPolygonMode(mode)");
#line 30289
          return;
        }
      }
    }
  }
#line 30291
  if (face == 1028) {
#line 30292
    ctx->Polygon.FrontMode = mode;
  } else {
#line 30291
    if (face == 1032) {
#line 30292
      ctx->Polygon.FrontMode = mode;
    }
  }
#line 30294
  if (face == 1029) {
#line 30295
    ctx->Polygon.BackMode = mode;
  } else {
#line 30294
    if (face == 1032) {
#line 30295
      ctx->Polygon.BackMode = mode;
    }
  }
#line 30297
  if (ctx->Polygon.FrontMode != 6914) {
#line 30298
    ctx->Polygon.Unfilled = (unsigned char)1;
  } else {
#line 30297
    if (ctx->Polygon.BackMode != 6914) {
#line 30298
      ctx->Polygon.Unfilled = (unsigned char)1;
    } else {
#line 30301
      ctx->Polygon.Unfilled = (unsigned char)0;
    }
  }
#line 30303
  ctx->NewState |= 8U;
#line 30304
  return;
}
}
#line 30305 "D:/a/test/177.c"
void gl_PolygonStipple(GLcontext *ctx , GLubyte const   *mask ) 
{ GLint i ;

  {
#line 30308
  if (ctx->Primitive != 6656) {
#line 30309
    gl_error(ctx, 1282, "glPolygonStipple");
#line 30310
    return;
  }
#line 30312
  i = 0;
#line 30312
  while (i < 32) {
#line 30313
    ctx->PolygonStipple[i] = (unsigned int )(((((int const   )*(mask + i * 4) << 24) | ((int const   )*(mask + (i * 4 + 1)) << 16)) | ((int const   )*(mask + (i * 4 + 2)) << 8)) | (int const   )*(mask + (i * 4 + 3)));
#line 30312
    i ++;
  }
#line 30318
  if (ctx->Polygon.StippleFlag) {
#line 30319
    ctx->NewState |= 2U;
  }
#line 30321
  return;
}
}
#line 30322 "D:/a/test/177.c"
void gl_GetPolygonStipple(GLcontext *ctx , GLubyte *mask ) 
{ 

  {
#line 30324
  return;
}
}
#line 30325 "D:/a/test/177.c"
void gl_PolygonOffset(GLcontext *ctx , float factor , float units ) 
{ 

  {
#line 30328
  if (ctx->Primitive != 6656) {
#line 30329
    gl_error(ctx, 1282, "glPolygonOffset");
#line 30330
    return;
  }
#line 30332
  ctx->Polygon.OffsetFactor = factor;
#line 30333
  ctx->Polygon.OffsetUnits = units;
#line 30334
  return;
}
}
#line 30340 "D:/a/test/177.c"
static void quad_t(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 , GLuint v3 ,
                   GLuint pv ) 
{ 

  {
#line 30343
  (*(ctx->Driver.TriangleFunc))(ctx, v0, v1, v3, pv);
#line 30344
  (*(ctx->Driver.TriangleFunc))(ctx, v1, v2, v3, pv);
#line 30345
  return;
}
}
#line 30346 "D:/a/test/177.c"
static void null_quad(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 , GLuint v3 ,
                      GLuint pv ) 
{ 

  {
#line 30349
  return;
}
}
#line 30350 "D:/a/test/177.c"
void gl_set_quad_function(GLcontext *ctx ) 
{ 

  {
#line 30352
  if (ctx->RenderMode == 7168) {
#line 30353
    if (ctx->NoRaster) {
#line 30354
      ctx->Driver.QuadFunc = & null_quad;
    } else {
#line 30356
      if (! ctx->Driver.QuadFunc) {
#line 30359
        ctx->Driver.QuadFunc = & quad_t;
      }
    }
  } else {
#line 30363
    ctx->Driver.QuadFunc = & quad_t;
  }
#line 30365
  return;
}
}
#line 30388
extern int ( /* missing proto */  TRANSFORM_NORMAL)(float x,float y,float z,float a[16],float b[3]) ;
#line 30392
void gl_color_shade_vertices(GLcontext *ctx , GLuint side , GLuint n , float (*vertex)[4] ,
                             float (*normal)[3] , GLubyte (*color)[4] ) ;
#line 30399
void gl_index_shade_vertices(GLcontext *ctx , GLuint side , GLuint n , float (*vertex)[4] ,
                             float (*normal)[3] , GLuint *indexResult ) ;
#line 30371 "D:/a/test/177.c"
void gl_RasterPos4f(GLcontext *ctx , float x , float y , float z , float w ) 
{ float v[4] ;
  float eye[4] ;
  float clip[4] ;
  float ndc[3] ;
  float d ;
  float eyenorm[3] ;
  GLubyte color[4] ;
  float *rc ;
  GLuint tmp___0 ;
  int tmp___1 ;
  GLuint tmp___2 ;

  {
#line 30375
  v[0] = x;
#line 30375
  v[1] = y;
#line 30375
  v[2] = z;
#line 30375
  v[3] = w;
#line 30376
  if (ctx->NewModelViewMatrix) {
#line 30377
    gl_analyze_modelview_matrix(ctx);
  }
#line 30379
  if (ctx->NewProjectionMatrix) {
#line 30380
    gl_analyze_projection_matrix(ctx);
  }
#line 30382
  if (ctx->NewTextureMatrix) {
#line 30383
    gl_analyze_texture_matrix(ctx);
  }
#line 30385
  TRANSFORM_POINT(eye, ctx->ModelViewMatrix, v);
#line 30386
  if (ctx->Light.Enabled) {
#line 30388
    TRANSFORM_NORMAL(eyenorm[0], eyenorm[1], eyenorm[2], ctx->Current.Normal, ctx->ModelViewInv);
#line 30390
    if ((ctx->Visual)->RGBAflag) {
#line 30392
      gl_color_shade_vertices(ctx, 0, 1, & eye, & eyenorm, & color);
#line 30393
      ctx->Current.RasterColor[0] = (float )color[0] * (ctx->Visual)->InvRedScale;
#line 30394
      ctx->Current.RasterColor[1] = (float )color[1] * (ctx->Visual)->InvGreenScale;
#line 30395
      ctx->Current.RasterColor[2] = (float )color[2] * (ctx->Visual)->InvBlueScale;
#line 30396
      ctx->Current.RasterColor[3] = (float )color[3] * (ctx->Visual)->InvAlphaScale;
    } else {
#line 30399
      gl_index_shade_vertices(ctx, 0, 1, & eye, & eyenorm, & ctx->Current.RasterIndex);
    }
  } else {
#line 30404
    if ((ctx->Visual)->RGBAflag) {
#line 30405
      rc = ctx->Current.RasterColor;
#line 30406
      *(rc + 0) = (float )ctx->Current.ByteColor[0] * (ctx->Visual)->InvRedScale;
#line 30407
      *(rc + 1) = (float )ctx->Current.ByteColor[1] * (ctx->Visual)->InvGreenScale;
#line 30408
      *(rc + 2) = (float )ctx->Current.ByteColor[2] * (ctx->Visual)->InvBlueScale;
#line 30409
      *(rc + 3) = (float )ctx->Current.ByteColor[3] * (ctx->Visual)->InvAlphaScale;
    } else {
#line 30412
      ctx->Current.RasterIndex = ctx->Current.Index;
    }
  }
#line 30415
  tmp___0 = gl_userclip_point(ctx, (float const   *)(eye));
#line 30415
  if (tmp___0 == 0U) {
#line 30416
    ctx->Current.RasterPosValid = (unsigned char)0;
#line 30417
    return;
  }
#line 30419
  tmp___1 = GL_SQRT((eye[0] * eye[0] + eye[1] * eye[1]) + eye[2] * eye[2]);
#line 30419
  ctx->Current.RasterDistance = (float )tmp___1;
#line 30421
  TRANSFORM_POINT(clip, ctx->ProjectionMatrix, eye);
#line 30422
  tmp___2 = gl_viewclip_point((float const   *)(clip));
#line 30422
  if (tmp___2 == 0U) {
#line 30423
    ctx->Current.RasterPosValid = (unsigned char)0;
#line 30424
    return;
  }
#line 30427
  d = 1.0F / clip[3];
#line 30428
  ndc[0] = clip[0] * d;
#line 30429
  ndc[1] = clip[1] * d;
#line 30430
  ndc[2] = clip[2] * d;
#line 30431
  ctx->Current.RasterPos[0] = ndc[0] * ctx->Viewport.Sx + ctx->Viewport.Tx;
#line 30432
  ctx->Current.RasterPos[1] = ndc[1] * ctx->Viewport.Sy + ctx->Viewport.Ty;
#line 30433
  ctx->Current.RasterPos[2] = (ndc[2] * ctx->Viewport.Sz + ctx->Viewport.Tz) / 65535.0F;
#line 30435
  ctx->Current.RasterPos[3] = clip[3];
#line 30436
  ctx->Current.RasterPosValid = (unsigned char)1;
#line 30437
  if (ctx->Texture.Enabled) {
#line 30438
    ctx->Current.RasterTexCoord[0] = ctx->Current.TexCoord[0];
#line 30438
    ctx->Current.RasterTexCoord[1] = ctx->Current.TexCoord[1];
#line 30438
    ctx->Current.RasterTexCoord[2] = ctx->Current.TexCoord[2];
#line 30438
    ctx->Current.RasterTexCoord[3] = ctx->Current.TexCoord[3];
  }
#line 30440
  if (ctx->RenderMode == 7170) {
#line 30441
    gl_update_hitflag(ctx, ctx->Current.RasterPos[2]);
  }
#line 30443
  return;
}
}
#line 30444 "D:/a/test/177.c"
void gl_windowpos(GLcontext *ctx , float x , float y , float z , float w ) 
{ float tmp___0 ;
  float eye[4] ;
  float eyenorm[3] ;
  GLubyte color[4] ;

  {
#line 30446
  ctx->Current.RasterPos[0] = x;
#line 30447
  ctx->Current.RasterPos[1] = y;
#line 30448
  if (z < 0.0F) {
#line 30448
    ctx->Current.RasterPos[2] = 0.0F;
  } else {
#line 30448
    if (z > 1.0F) {
#line 30448
      tmp___0 = 1.0F;
    } else {
#line 30448
      tmp___0 = z;
    }
#line 30448
    ctx->Current.RasterPos[2] = tmp___0;
  }
#line 30449
  ctx->Current.RasterPos[3] = w;
#line 30450
  ctx->Current.RasterPosValid = (unsigned char)1;
#line 30451
  if (ctx->Light.Enabled) {
#line 30454
    eye[0] = ctx->Current.RasterPos[0];
#line 30454
    eye[1] = ctx->Current.RasterPos[1];
#line 30454
    eye[2] = ctx->Current.RasterPos[2];
#line 30454
    eye[3] = ctx->Current.RasterPos[3];
#line 30455
    if (ctx->NewModelViewMatrix) {
#line 30456
      gl_analyze_modelview_matrix(ctx);
    }
#line 30458
    TRANSFORM_NORMAL(eyenorm[0], eyenorm[1], eyenorm[2], ctx->Current.Normal, ctx->ModelViewInv);
#line 30461
    if ((ctx->Visual)->RGBAflag) {
#line 30463
      gl_color_shade_vertices(ctx, 0, 1, & eye, & eyenorm, & color);
#line 30464
      ctx->Current.RasterColor[0] = (float )color[0] * (ctx->Visual)->InvRedScale;
#line 30464
      ctx->Current.RasterColor[1] = (float )color[1] * (ctx->Visual)->InvGreenScale;
#line 30464
      ctx->Current.RasterColor[2] = (float )color[2] * (ctx->Visual)->InvBlueScale;
#line 30464
      ctx->Current.RasterColor[3] = (float )color[3] * (ctx->Visual)->InvAlphaScale;
    } else {
#line 30471
      gl_index_shade_vertices(ctx, 0, 1, & eye, & eyenorm, & ctx->Current.RasterIndex);
    }
  } else {
#line 30476
    if ((ctx->Visual)->RGBAflag) {
#line 30477
      ctx->Current.RasterColor[0] = (float )ctx->Current.ByteColor[0] * (ctx->Visual)->InvRedScale;
#line 30477
      ctx->Current.RasterColor[1] = (float )ctx->Current.ByteColor[1] * (ctx->Visual)->InvGreenScale;
#line 30477
      ctx->Current.RasterColor[2] = (float )ctx->Current.ByteColor[2] * (ctx->Visual)->InvBlueScale;
#line 30477
      ctx->Current.RasterColor[3] = (float )ctx->Current.ByteColor[3] * (ctx->Visual)->InvAlphaScale;
    } else {
#line 30484
      ctx->Current.RasterIndex = ctx->Current.Index;
    }
  }
#line 30487
  ctx->Current.RasterDistance = (float )0.0;
#line 30488
  if (ctx->Texture.Enabled) {
#line 30489
    ctx->Current.RasterTexCoord[0] = ctx->Current.TexCoord[0];
#line 30489
    ctx->Current.RasterTexCoord[1] = ctx->Current.TexCoord[1];
#line 30489
    ctx->Current.RasterTexCoord[2] = ctx->Current.TexCoord[2];
#line 30489
    ctx->Current.RasterTexCoord[3] = ctx->Current.TexCoord[3];
  }
#line 30491
  if (ctx->RenderMode == 7170) {
#line 30492
    gl_update_hitflag(ctx, ctx->Current.RasterPos[2]);
  }
#line 30494
  return;
}
}
#line 30500 "D:/a/test/177.c"
static void read_index_pixels1(GLcontext *ctx , GLint x , GLint y , GLsizei width ,
                               GLsizei height , GLenum type , GLvoid *pixels ) 
{ GLint i ;
  GLint j ;
  GLuint a ;
  GLuint s ;
  GLuint k ;
  GLuint l ;
  GLuint start ;
  GLint tmp___0 ;
  GLuint tmp___1 ;
  GLuint index___0[640] ;
  GLuint s___0 ;
  GLubyte *dst ;
  GLubyte *tmp___2 ;
  GLbyte *dst___0 ;
  GLbyte *tmp___3 ;
  GLushort *dst___1 ;
  GLushort *tmp___4 ;
  GLshort *dst___2 ;
  GLshort *tmp___5 ;
  GLuint *dst___3 ;
  GLuint *tmp___6 ;
  GLint *dst___4 ;
  GLint *tmp___7 ;
  float *dst___5 ;
  float *tmp___8 ;

  {
#line 30507
  if ((ctx->Visual)->RGBAflag) {
#line 30508
    gl_error(ctx, 1282, "glReadPixels");
#line 30509
    return;
  }
#line 30511
  tmp___0 = gl_sizeof_type(type);
#line 30511
  s = (unsigned int )tmp___0;
#line 30512
  if (s <= 0U) {
#line 30513
    gl_error(ctx, 1280, "glReadPixels(type)");
#line 30514
    return;
  }
#line 30516
  a = (unsigned int )ctx->Pack.Alignment;
#line 30517
  if (ctx->Pack.RowLength > 0) {
#line 30518
    l = (unsigned int )ctx->Pack.RowLength;
  } else {
#line 30521
    l = (unsigned int )width;
  }
#line 30523
  if (s >= a) {
#line 30524
    k = l;
  } else {
#line 30527
    if ((s * l) % a == 0U) {
#line 30527
      tmp___1 = (s * l) / a;
    } else {
#line 30527
      tmp___1 = (s * l) / a + 1U;
    }
#line 30527
    k = (a / s) * tmp___1;
  }
#line 30529
  start = (GLuint )ctx->Pack.SkipRows * k + (GLuint )ctx->Pack.SkipPixels;
#line 30530
  j = 0;
#line 30530
  while (j < height) {
#line 30532
    (*(ctx->Driver.ReadIndexSpan))(ctx, (unsigned int )width, x, y, index___0);
#line 30533
    if (ctx->Pixel.IndexShift != 0) {
      goto _L;
    } else {
#line 30533
      if (ctx->Pixel.IndexOffset != 0) {
        _L: /* CIL Label */ 
#line 30535
        if (ctx->Pixel.IndexShift < 0) {
#line 30537
          s___0 = (unsigned int )(- ctx->Pixel.IndexShift);
#line 30538
          i = 0;
#line 30538
          while (i < width) {
#line 30539
            index___0[i] = (index___0[i] >> s___0) + (GLuint )ctx->Pixel.IndexOffset;
#line 30538
            i ++;
          }
        } else {
#line 30544
          s___0 = (unsigned int )ctx->Pixel.IndexShift;
#line 30545
          i = 0;
#line 30545
          while (i < width) {
#line 30546
            index___0[i] = (index___0[i] << s___0) + (GLuint )ctx->Pixel.IndexOffset;
#line 30545
            i ++;
          }
        }
      }
    }
#line 30550
    if (ctx->Pixel.MapColorFlag) {
#line 30551
      i = 0;
#line 30551
      while (i < width) {
#line 30552
        index___0[i] = (unsigned int )ctx->Pixel.MapItoI[index___0[i]];
#line 30551
        i ++;
      }
    }
#line 30555
    switch (type) {
    case 5121: 
#line 30558
    dst = ((GLubyte *)pixels + start) + (GLuint )j * k;
#line 30559
    i = 0;
#line 30559
    while (i < width) {
#line 30560
      tmp___2 = dst;
#line 30560
      dst ++;
#line 30560
      *tmp___2 = (unsigned char )index___0[i];
#line 30559
      i ++;
    }
#line 30563
    break;
    case 5120: 
#line 30566
    dst___0 = ((GLbyte *)pixels + start) + (GLuint )j * k;
#line 30567
    i = 0;
#line 30567
    while (i < width) {
#line 30568
      tmp___3 = dst___0;
#line 30568
      dst___0 ++;
#line 30568
      *tmp___3 = (signed char )index___0[i];
#line 30567
      i ++;
    }
#line 30571
    break;
    case 5123: 
#line 30574
    dst___1 = ((GLushort *)pixels + start) + (GLuint )j * k;
#line 30575
    i = 0;
#line 30575
    while (i < width) {
#line 30576
      tmp___4 = dst___1;
#line 30576
      dst___1 ++;
#line 30576
      *tmp___4 = (unsigned short )index___0[i];
#line 30575
      i ++;
    }
#line 30578
    if (ctx->Pack.SwapBytes) {
#line 30579
      gl_swap2(((GLushort *)pixels + start) + (GLuint )j * k, (unsigned int )width);
    }
#line 30582
    break;
    case 5122: 
#line 30585
    dst___2 = ((GLshort *)pixels + start) + (GLuint )j * k;
#line 30586
    i = 0;
#line 30586
    while (i < width) {
#line 30587
      tmp___5 = dst___2;
#line 30587
      dst___2 ++;
#line 30587
      *tmp___5 = (short )index___0[i];
#line 30586
      i ++;
    }
#line 30589
    if (ctx->Pack.SwapBytes) {
#line 30590
      gl_swap2(((GLushort *)pixels + start) + (GLuint )j * k, (unsigned int )width);
    }
#line 30593
    break;
    case 5125: 
#line 30596
    dst___3 = ((GLuint *)pixels + start) + (GLuint )j * k;
#line 30597
    i = 0;
#line 30597
    while (i < width) {
#line 30598
      tmp___6 = dst___3;
#line 30598
      dst___3 ++;
#line 30598
      *tmp___6 = index___0[i];
#line 30597
      i ++;
    }
#line 30600
    if (ctx->Pack.SwapBytes) {
#line 30601
      gl_swap4(((GLuint *)pixels + start) + (GLuint )j * k, (unsigned int )width);
    }
#line 30604
    break;
    case 5124: 
#line 30607
    dst___4 = ((GLint *)pixels + start) + (GLuint )j * k;
#line 30608
    i = 0;
#line 30608
    while (i < width) {
#line 30609
      tmp___7 = dst___4;
#line 30609
      dst___4 ++;
#line 30609
      *tmp___7 = (int )index___0[i];
#line 30608
      i ++;
    }
#line 30611
    if (ctx->Pack.SwapBytes) {
#line 30612
      gl_swap4(((GLuint *)pixels + start) + (GLuint )j * k, (unsigned int )width);
    }
#line 30615
    break;
    case 5126: 
#line 30618
    dst___5 = ((float *)pixels + start) + (GLuint )j * k;
#line 30619
    i = 0;
#line 30619
    while (i < width) {
#line 30620
      tmp___8 = dst___5;
#line 30620
      dst___5 ++;
#line 30620
      *tmp___8 = (float )index___0[i];
#line 30619
      i ++;
    }
#line 30622
    if (ctx->Pack.SwapBytes) {
#line 30623
      gl_swap4(((GLuint *)pixels + start) + (GLuint )j * k, (unsigned int )width);
    }
#line 30626
    break;
    default: 
#line 30628
    gl_error(ctx, 1280, "glReadPixels(type)");
    }
#line 30530
    j ++;
#line 30530
    y ++;
  }
#line 30631
  return;
}
}
#line 30632 "D:/a/test/177.c"
static void read_depth_pixels(GLcontext *ctx , GLint x , GLint y , GLsizei width ,
                              GLsizei height , GLenum type , GLvoid *pixels ) 
{ GLint i ;
  GLint j ;
  GLuint a ;
  GLuint s ;
  GLuint k ;
  GLuint l ;
  GLuint start ;
  GLboolean bias_or_scale ;
  int tmp___0 ;
  GLint tmp___1 ;
  GLuint tmp___2 ;
  GLushort *dst ;
  GLuint shift ;
  GLuint max ;
  GLuint *dst___0 ;
  float depth[640] ;
  float d ;
  double tmp___3 ;
  GLubyte *dst___1 ;
  GLubyte *tmp___4 ;
  GLbyte *dst___2 ;
  GLbyte *tmp___5 ;
  GLushort *dst___3 ;
  GLushort *tmp___6 ;
  GLshort *dst___4 ;
  GLshort *tmp___7 ;
  GLuint *dst___5 ;
  GLuint *tmp___8 ;
  GLint *dst___6 ;
  GLint *tmp___9 ;
  float *dst___7 ;
  float *tmp___10 ;

  {
#line 30640
  if ((ctx->Visual)->DepthBits <= 0) {
#line 30641
    gl_error(ctx, 1282, "glReadPixels");
#line 30642
    return;
  }
#line 30644
  if ((double )ctx->Pixel.DepthBias != 0.0) {
#line 30644
    tmp___0 = 1;
  } else {
#line 30644
    if ((double )ctx->Pixel.DepthScale != 1.0) {
#line 30644
      tmp___0 = 1;
    } else {
#line 30644
      tmp___0 = 0;
    }
  }
#line 30644
  bias_or_scale = (unsigned char )tmp___0;
#line 30645
  tmp___1 = gl_sizeof_type(type);
#line 30645
  s = (unsigned int )tmp___1;
#line 30646
  if (s <= 0U) {
#line 30647
    gl_error(ctx, 1280, "glReadPixels(type)");
#line 30648
    return;
  }
#line 30650
  a = (unsigned int )ctx->Pack.Alignment;
#line 30651
  if (ctx->Pack.RowLength > 0) {
#line 30652
    l = (unsigned int )ctx->Pack.RowLength;
  } else {
#line 30655
    l = (unsigned int )width;
  }
#line 30657
  if (s >= a) {
#line 30658
    k = l;
  } else {
#line 30661
    if ((s * l) % a == 0U) {
#line 30661
      tmp___2 = (s * l) / a;
    } else {
#line 30661
      tmp___2 = (s * l) / a + 1U;
    }
#line 30661
    k = (a / s) * tmp___2;
  }
#line 30663
  start = (GLuint )ctx->Pack.SkipRows * k + (GLuint )ctx->Pack.SkipPixels;
#line 30664
  if (type == 5123) {
#line 30664
    if (sizeof(GLdepth ) == sizeof(GLushort )) {
#line 30664
      if (! bias_or_scale) {
#line 30664
        if (! ctx->Pack.SwapBytes) {
#line 30666
          j = 0;
#line 30666
          while (j < height) {
#line 30667
            dst = ((GLushort *)pixels + start) + (GLuint )j * k;
#line 30668
            (*(ctx->Driver.ReadDepthSpanInt))(ctx, (unsigned int )width, x, y, dst);
#line 30666
            j ++;
#line 30666
            y ++;
          }
        } else {
          goto _L___4;
        }
      } else {
        goto _L___4;
      }
    } else {
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
#line 30671
    if (type == 5125) {
#line 30671
      if (sizeof(GLdepth ) == sizeof(GLuint )) {
#line 30671
        if (! bias_or_scale) {
#line 30671
          if (! ctx->Pack.SwapBytes) {
#line 30673
            shift = (GLuint )0;
#line 30674
            max = (GLuint )65535;
#line 30675
            while ((max & 2147483648U) == 0U) {
#line 30676
              max <<= 1;
#line 30677
              shift ++;
            }
#line 30679
            j = 0;
#line 30679
            while (j < height) {
#line 30680
              dst___0 = ((GLuint *)pixels + start) + (GLuint )j * k;
#line 30681
              (*(ctx->Driver.ReadDepthSpanInt))(ctx, (unsigned int )width, x, y, (GLdepth *)dst___0);
#line 30682
              i = 0;
#line 30682
              while (i < width) {
#line 30683
                *(dst___0 + i) <<= shift;
#line 30682
                i ++;
              }
#line 30679
              j ++;
#line 30679
              y ++;
            }
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 30688
      j = 0;
#line 30688
      while (j < height) {
#line 30690
        (*(ctx->Driver.ReadDepthSpanFloat))(ctx, (unsigned int )width, x, y, depth);
#line 30691
        if (bias_or_scale) {
#line 30692
          i = 0;
#line 30692
          while (i < width) {
#line 30694
            d = depth[i] * ctx->Pixel.DepthScale + ctx->Pixel.DepthBias;
#line 30695
            if ((double )d < 0.0) {
#line 30695
              depth[i] = (float )0.0;
            } else {
#line 30695
              if ((double )d > 1.0) {
#line 30695
                tmp___3 = 1.0;
              } else {
#line 30695
                tmp___3 = (double )d;
              }
#line 30695
              depth[i] = (float )tmp___3;
            }
#line 30692
            i ++;
          }
        }
#line 30698
        switch (type) {
        case 5121: 
#line 30701
        dst___1 = ((GLubyte *)pixels + start) + (GLuint )j * k;
#line 30702
        i = 0;
#line 30702
        while (i < width) {
#line 30703
          tmp___4 = dst___1;
#line 30703
          dst___1 ++;
#line 30703
          *tmp___4 = (unsigned char )((int )(depth[i] * 255.0F));
#line 30702
          i ++;
        }
#line 30706
        break;
        case 5120: 
#line 30709
        dst___2 = ((GLbyte *)pixels + start) + (GLuint )j * k;
#line 30710
        i = 0;
#line 30710
        while (i < width) {
#line 30711
          tmp___5 = dst___2;
#line 30711
          dst___2 ++;
#line 30711
          *tmp___5 = (signed char )(((int )(255.0F * depth[i]) - 1) / 2);
#line 30710
          i ++;
        }
#line 30714
        break;
        case 5123: 
#line 30717
        dst___3 = ((GLushort *)pixels + start) + (GLuint )j * k;
#line 30718
        i = 0;
#line 30718
        while (i < width) {
#line 30719
          tmp___6 = dst___3;
#line 30719
          dst___3 ++;
#line 30719
          *tmp___6 = (unsigned short )((int )(depth[i] * 65535.0F));
#line 30718
          i ++;
        }
#line 30721
        if (ctx->Pack.SwapBytes) {
#line 30722
          gl_swap2(((GLushort *)pixels + start) + (GLuint )j * k, (unsigned int )width);
        }
#line 30725
        break;
        case 5122: 
#line 30728
        dst___4 = ((GLshort *)pixels + start) + (GLuint )j * k;
#line 30729
        i = 0;
#line 30729
        while (i < width) {
#line 30730
          tmp___7 = dst___4;
#line 30730
          dst___4 ++;
#line 30730
          *tmp___7 = (short )(((int )(65535.0F * depth[i]) - 1) / 2);
#line 30729
          i ++;
        }
#line 30732
        if (ctx->Pack.SwapBytes) {
#line 30733
          gl_swap2(((GLushort *)pixels + start) + (GLuint )j * k, (unsigned int )width);
        }
#line 30736
        break;
        case 5125: 
#line 30739
        dst___5 = ((GLuint *)pixels + start) + (GLuint )j * k;
#line 30740
        i = 0;
#line 30740
        while (i < width) {
#line 30741
          tmp___8 = dst___5;
#line 30741
          dst___5 ++;
#line 30741
          *tmp___8 = (unsigned int )((double )depth[i] * 4294967295.0);
#line 30740
          i ++;
        }
#line 30743
        if (ctx->Pack.SwapBytes) {
#line 30744
          gl_swap4(((GLuint *)pixels + start) + (GLuint )j * k, (unsigned int )width);
        }
#line 30747
        break;
        case 5124: 
#line 30750
        dst___6 = ((GLint *)pixels + start) + (GLuint )j * k;
#line 30751
        i = 0;
#line 30751
        while (i < width) {
#line 30752
          tmp___9 = dst___6;
#line 30752
          dst___6 ++;
#line 30752
          *tmp___9 = (int )(2147483647.0 * (double )depth[i]);
#line 30751
          i ++;
        }
#line 30754
        if (ctx->Pack.SwapBytes) {
#line 30755
          gl_swap4(((GLuint *)pixels + start) + (GLuint )j * k, (unsigned int )width);
        }
#line 30758
        break;
        case 5126: 
#line 30761
        dst___7 = ((float *)pixels + start) + (GLuint )j * k;
#line 30762
        i = 0;
#line 30762
        while (i < width) {
#line 30763
          tmp___10 = dst___7;
#line 30763
          dst___7 ++;
#line 30763
          *tmp___10 = depth[i];
#line 30762
          i ++;
        }
#line 30765
        if (ctx->Pack.SwapBytes) {
#line 30766
          gl_swap4(((GLuint *)pixels + start) + (GLuint )j * k, (unsigned int )width);
        }
#line 30769
        break;
        default: 
#line 30771
        gl_error(ctx, 1280, "glReadPixels(type)");
        }
#line 30688
        j ++;
#line 30688
        y ++;
      }
    }
  }
#line 30775
  return;
}
}
#line 30776 "D:/a/test/177.c"
static void read_stencil_pixels(GLcontext *ctx , GLint x , GLint y , GLsizei width ,
                                GLsizei height , GLenum type , GLvoid *pixels ) 
{ GLint i ;
  GLint j ;
  GLuint a ;
  GLuint s ;
  GLuint k ;
  GLuint l ;
  GLuint start ;
  GLboolean shift_or_offset ;
  int tmp___0 ;
  GLint tmp___1 ;
  GLuint tmp___2 ;
  GLubyte stencil[640] ;
  GLuint s___0 ;
  GLubyte *dst ;
  GLbyte *dst___0 ;
  GLushort *dst___1 ;
  GLushort *tmp___3 ;
  GLshort *dst___2 ;
  GLshort *tmp___4 ;
  GLuint *dst___3 ;
  GLuint *tmp___5 ;
  GLint *dst___4 ;
  GLint *tmp___6 ;
  float *dst___5 ;
  float *tmp___7 ;

  {
#line 30784
  if ((ctx->Visual)->StencilBits <= 0) {
#line 30785
    gl_error(ctx, 1282, "glReadPixels");
#line 30786
    return;
  }
#line 30788
  if (ctx->Pixel.IndexShift != 0) {
#line 30788
    tmp___0 = 1;
  } else {
#line 30788
    if (ctx->Pixel.IndexOffset != 0) {
#line 30788
      tmp___0 = 1;
    } else {
#line 30788
      tmp___0 = 0;
    }
  }
#line 30788
  shift_or_offset = (unsigned char )tmp___0;
#line 30789
  tmp___1 = gl_sizeof_type(type);
#line 30789
  s = (unsigned int )tmp___1;
#line 30790
  if (s <= 0U) {
#line 30791
    gl_error(ctx, 1280, "glReadPixels(type)");
#line 30792
    return;
  }
#line 30794
  a = (unsigned int )ctx->Pack.Alignment;
#line 30795
  if (ctx->Pack.RowLength > 0) {
#line 30796
    l = (unsigned int )ctx->Pack.RowLength;
  } else {
#line 30799
    l = (unsigned int )width;
  }
#line 30801
  if (s >= a) {
#line 30802
    k = l;
  } else {
#line 30805
    if ((s * l) % a == 0U) {
#line 30805
      tmp___2 = (s * l) / a;
    } else {
#line 30805
      tmp___2 = (s * l) / a + 1U;
    }
#line 30805
    k = (a / s) * tmp___2;
  }
#line 30807
  start = (GLuint )ctx->Pack.SkipRows * k + (GLuint )ctx->Pack.SkipPixels;
#line 30808
  j = 0;
#line 30808
  while (j < height) {
#line 30810
    gl_read_stencil_span(ctx, width, x, y, stencil);
#line 30811
    if (shift_or_offset) {
#line 30813
      if (ctx->Pixel.IndexShift < 0) {
#line 30815
        s___0 = (unsigned int )(- ctx->Pixel.IndexShift);
#line 30816
        i = 0;
#line 30816
        while (i < width) {
#line 30817
          stencil[i] = (unsigned char )(((int )stencil[i] >> s___0) + ctx->Pixel.IndexOffset);
#line 30816
          i ++;
        }
      } else {
#line 30822
        s___0 = (unsigned int )ctx->Pixel.IndexShift;
#line 30823
        i = 0;
#line 30823
        while (i < width) {
#line 30824
          stencil[i] = (unsigned char )(((int )stencil[i] << s___0) + ctx->Pixel.IndexOffset);
#line 30823
          i ++;
        }
      }
    }
#line 30828
    if (ctx->Pixel.MapStencilFlag) {
#line 30829
      i = 0;
#line 30829
      while (i < width) {
#line 30830
        stencil[i] = (unsigned char )ctx->Pixel.MapStoS[stencil[i]];
#line 30829
        i ++;
      }
    }
#line 30833
    switch (type) {
    case 5121: 
#line 30836
    dst = ((GLubyte *)pixels + start) + (GLuint )j * k;
#line 30837
    memcpy((void *)dst, (void const   *)((void *)(stencil)), (unsigned int )width);
#line 30839
    break;
    case 5120: 
#line 30842
    dst___0 = ((GLbyte *)pixels + start) + (GLuint )j * k;
#line 30843
    memcpy((void *)dst___0, (void const   *)((void *)(stencil)), (unsigned int )width);
#line 30845
    break;
    case 5123: 
#line 30848
    dst___1 = ((GLushort *)pixels + start) + (GLuint )j * k;
#line 30849
    i = 0;
#line 30849
    while (i < width) {
#line 30850
      tmp___3 = dst___1;
#line 30850
      dst___1 ++;
#line 30850
      *tmp___3 = (unsigned short )stencil[i];
#line 30849
      i ++;
    }
#line 30852
    if (ctx->Pack.SwapBytes) {
#line 30853
      gl_swap2(((GLushort *)pixels + start) + (GLuint )j * k, (unsigned int )width);
    }
#line 30856
    break;
    case 5122: 
#line 30859
    dst___2 = ((GLshort *)pixels + start) + (GLuint )j * k;
#line 30860
    i = 0;
#line 30860
    while (i < width) {
#line 30861
      tmp___4 = dst___2;
#line 30861
      dst___2 ++;
#line 30861
      *tmp___4 = (short )stencil[i];
#line 30860
      i ++;
    }
#line 30863
    if (ctx->Pack.SwapBytes) {
#line 30864
      gl_swap2(((GLushort *)pixels + start) + (GLuint )j * k, (unsigned int )width);
    }
#line 30867
    break;
    case 5125: 
#line 30870
    dst___3 = ((GLuint *)pixels + start) + (GLuint )j * k;
#line 30871
    i = 0;
#line 30871
    while (i < width) {
#line 30872
      tmp___5 = dst___3;
#line 30872
      dst___3 ++;
#line 30872
      *tmp___5 = (unsigned int )stencil[i];
#line 30871
      i ++;
    }
#line 30874
    if (ctx->Pack.SwapBytes) {
#line 30875
      gl_swap4(((GLuint *)pixels + start) + (GLuint )j * k, (unsigned int )width);
    }
#line 30878
    break;
    case 5124: 
#line 30881
    dst___4 = ((GLint *)pixels + start) + (GLuint )j * k;
#line 30882
    i = 0;
#line 30882
    while (i < width) {
#line 30883
      tmp___6 = dst___4;
#line 30883
      dst___4 ++;
#line 30883
      *tmp___6 = (int )stencil[i];
#line 30882
      i ++;
    }
#line 30885
    if (ctx->Pack.SwapBytes) {
#line 30886
      gl_swap4(((GLuint *)pixels + start) + (GLuint )j * k, (unsigned int )width);
    }
#line 30889
    break;
    case 5126: 
#line 30892
    dst___5 = ((float *)pixels + start) + (GLuint )j * k;
#line 30893
    i = 0;
#line 30893
    while (i < width) {
#line 30894
      tmp___7 = dst___5;
#line 30894
      dst___5 ++;
#line 30894
      *tmp___7 = (float )stencil[i];
#line 30893
      i ++;
    }
#line 30896
    if (ctx->Pack.SwapBytes) {
#line 30897
      gl_swap4(((GLuint *)pixels + start) + (GLuint )j * k, (unsigned int )width);
    }
#line 30900
    break;
    default: 
#line 30902
    gl_error(ctx, 1280, "glReadPixels(type)");
    }
#line 30808
    j ++;
#line 30808
    y ++;
  }
#line 30905
  return;
}
}
#line 30906 "D:/a/test/177.c"
static GLboolean scale_or_bias_rgba(GLcontext *ctx ) 
{ 

  {
#line 30908
  if (ctx->Pixel.RedScale != 1.0F) {
#line 30912
    return ((unsigned char)1);
  } else {
#line 30908
    if (ctx->Pixel.RedBias != 0.0F) {
#line 30912
      return ((unsigned char)1);
    } else {
#line 30908
      if (ctx->Pixel.GreenScale != 1.0F) {
#line 30912
        return ((unsigned char)1);
      } else {
#line 30908
        if (ctx->Pixel.GreenBias != 0.0F) {
#line 30912
          return ((unsigned char)1);
        } else {
#line 30908
          if (ctx->Pixel.BlueScale != 1.0F) {
#line 30912
            return ((unsigned char)1);
          } else {
#line 30908
            if (ctx->Pixel.BlueBias != 0.0F) {
#line 30912
              return ((unsigned char)1);
            } else {
#line 30908
              if (ctx->Pixel.AlphaScale != 1.0F) {
#line 30912
                return ((unsigned char)1);
              } else {
#line 30908
                if (ctx->Pixel.AlphaBias != 0.0F) {
#line 30912
                  return ((unsigned char)1);
                } else {
#line 30915
                  return ((unsigned char)0);
                }
              }
            }
          }
        }
      }
    }
  }
}
}
#line 30918 "D:/a/test/177.c"
static void scale_and_bias_rgba(GLcontext *ctx , GLint n , float *red , float *green ,
                                float *blue___0 , float *alpha ) 
{ register GLint i ;
  register float r ;
  register float g ;
  register float b ;
  register float a ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;

  {
#line 30925
  i = 0;
#line 30925
  while (i < n) {
#line 30926
    r = *(red + i) * ctx->Pixel.RedScale + ctx->Pixel.RedBias;
#line 30927
    g = *(green + i) * ctx->Pixel.GreenScale + ctx->Pixel.GreenBias;
#line 30928
    b = *(blue___0 + i) * ctx->Pixel.BlueScale + ctx->Pixel.BlueBias;
#line 30929
    a = *(alpha + i) * ctx->Pixel.AlphaScale + ctx->Pixel.AlphaBias;
#line 30930
    if (r < 0.0F) {
#line 30930
      *(red + i) = 0.0F;
    } else {
#line 30930
      if (r > 1.0F) {
#line 30930
        tmp___0 = 1.0F;
      } else {
#line 30930
        tmp___0 = r;
      }
#line 30930
      *(red + i) = tmp___0;
    }
#line 30931
    if (g < 0.0F) {
#line 30931
      *(green + i) = 0.0F;
    } else {
#line 30931
      if (g > 1.0F) {
#line 30931
        tmp___1 = 1.0F;
      } else {
#line 30931
        tmp___1 = g;
      }
#line 30931
      *(green + i) = tmp___1;
    }
#line 30932
    if (b < 0.0F) {
#line 30932
      *(blue___0 + i) = 0.0F;
    } else {
#line 30932
      if (b > 1.0F) {
#line 30932
        tmp___2 = 1.0F;
      } else {
#line 30932
        tmp___2 = b;
      }
#line 30932
      *(blue___0 + i) = tmp___2;
    }
#line 30933
    if (a < 0.0F) {
#line 30933
      *(alpha + i) = 0.0F;
    } else {
#line 30933
      if (a > 1.0F) {
#line 30933
        tmp___3 = 1.0F;
      } else {
#line 30933
        tmp___3 = a;
      }
#line 30933
      *(alpha + i) = tmp___3;
    }
#line 30925
    i ++;
  }
#line 30935
  return;
}
}
#line 30936 "D:/a/test/177.c"
static void map_rgba(GLcontext *ctx , GLint n , float *red , float *green , float *blue___0 ,
                     float *alpha ) 
{ float rscale ;
  float gscale ;
  float bscale ;
  float ascale ;
  GLint i ;

  {
#line 30941
  rscale = (float )(ctx->Pixel.MapRtoRsize - 1);
#line 30942
  gscale = (float )(ctx->Pixel.MapGtoGsize - 1);
#line 30943
  bscale = (float )(ctx->Pixel.MapBtoBsize - 1);
#line 30944
  ascale = (float )(ctx->Pixel.MapAtoAsize - 1);
#line 30946
  i = 0;
#line 30946
  while (i < n) {
#line 30947
    *(red + i) = ctx->Pixel.MapRtoR[(int )(*(red + i) * rscale)];
#line 30948
    *(green + i) = ctx->Pixel.MapGtoG[(int )(*(green + i) * gscale)];
#line 30949
    *(blue___0 + i) = ctx->Pixel.MapBtoB[(int )(*(blue___0 + i) * bscale)];
#line 30950
    *(alpha + i) = ctx->Pixel.MapAtoA[(int )(*(alpha + i) * ascale)];
#line 30946
    i ++;
  }
#line 30952
  return;
}
}
#line 30953 "D:/a/test/177.c"
static void read_color_pixels1(GLcontext *ctx , GLint x , GLint y , GLsizei width ,
                               GLsizei height , GLenum format , GLenum type , GLvoid *pixels ) 
{ GLint i ;
  GLint j ;
  GLint n ;
  GLint a ;
  GLint s ;
  GLint l ;
  GLint k ;
  GLboolean scale_or_bias ;
  float red[640] ;
  float green[640] ;
  float blue___0[640] ;
  float alpha[640] ;
  float luminance[640] ;
  GLboolean r_flag ;
  GLboolean g_flag ;
  GLboolean b_flag ;
  GLboolean a_flag ;
  GLboolean l_flag ;
  GLuint start ;
  GLint tmp___0 ;
  GLubyte r[640] ;
  GLubyte g[640] ;
  GLubyte b[640] ;
  GLubyte a___0[640] ;
  float rscale ;
  float gscale ;
  float bscale ;
  float ascale ;
  GLuint index___0[640] ;
  GLuint s___0 ;
  float sum ;
  float tmp___1 ;
  GLubyte *dst ;
  GLubyte *tmp___2 ;
  GLubyte *tmp___3 ;
  GLubyte *tmp___4 ;
  GLubyte *tmp___5 ;
  GLubyte *tmp___6 ;
  GLbyte *dst___0 ;
  GLbyte *tmp___7 ;
  GLbyte *tmp___8 ;
  GLbyte *tmp___9 ;
  GLbyte *tmp___10 ;
  GLbyte *tmp___11 ;
  GLushort *dst___1 ;
  GLushort *tmp___12 ;
  GLushort *tmp___13 ;
  GLushort *tmp___14 ;
  GLushort *tmp___15 ;
  GLushort *tmp___16 ;
  GLshort *dst___2 ;
  GLshort *tmp___17 ;
  GLshort *tmp___18 ;
  GLshort *tmp___19 ;
  GLshort *tmp___20 ;
  GLshort *tmp___21 ;
  GLuint *dst___3 ;
  GLuint *tmp___22 ;
  GLuint *tmp___23 ;
  GLuint *tmp___24 ;
  GLuint *tmp___25 ;
  GLuint *tmp___26 ;
  GLint *dst___4 ;
  GLint *tmp___27 ;
  GLint *tmp___28 ;
  GLint *tmp___29 ;
  GLint *tmp___30 ;
  GLint *tmp___31 ;
  float *dst___5 ;
  float *tmp___32 ;
  float *tmp___33 ;
  float *tmp___34 ;
  float *tmp___35 ;
  float *tmp___36 ;

  {
#line 30967
  scale_or_bias = scale_or_bias_rgba(ctx);
#line 30968
  l_flag = (unsigned char)0;
#line 30968
  a_flag = l_flag;
#line 30968
  b_flag = a_flag;
#line 30968
  g_flag = b_flag;
#line 30968
  r_flag = g_flag;
#line 30969
  switch (format) {
  case 6403: 
#line 30970
  r_flag = (unsigned char)1;
#line 30970
  n = 1;
#line 30970
  break;
  case 6404: 
#line 30971
  g_flag = (unsigned char)1;
#line 30971
  n = 1;
#line 30971
  break;
  case 6405: 
#line 30972
  b_flag = (unsigned char)1;
#line 30972
  n = 1;
#line 30972
  break;
  case 6406: 
#line 30973
  a_flag = (unsigned char)1;
#line 30973
  n = 1;
#line 30973
  break;
  case 6409: 
#line 30974
  l_flag = (unsigned char)1;
#line 30974
  n = 1;
#line 30974
  break;
  case 6410: 
#line 30975
  a_flag = (unsigned char)1;
#line 30975
  l_flag = a_flag;
#line 30975
  n = 2;
#line 30975
  break;
  case 6407: 
#line 30976
  b_flag = (unsigned char)1;
#line 30976
  g_flag = b_flag;
#line 30976
  r_flag = g_flag;
#line 30976
  n = 3;
#line 30976
  break;
  case 6408: 
#line 30977
  a_flag = (unsigned char)1;
#line 30977
  b_flag = a_flag;
#line 30977
  g_flag = b_flag;
#line 30977
  r_flag = g_flag;
#line 30977
  n = 4;
#line 30977
  break;
  default: 
#line 30979
  gl_error(ctx, 1280, "glReadPixels(format)");
#line 30985
  return;
  }
#line 30987
  s = gl_sizeof_type(type);
#line 30988
  if (s <= 0) {
#line 30989
    gl_error(ctx, 1280, "glReadPixels(type)");
#line 30995
    return;
  }
#line 30997
  a = ctx->Pack.Alignment;
#line 30998
  if (ctx->Pack.RowLength > 0) {
#line 30999
    l = ctx->Pack.RowLength;
  } else {
#line 31002
    l = width;
  }
#line 31004
  if (s >= a) {
#line 31005
    k = n * l;
  } else {
#line 31008
    if (((s * n) * l) % a == 0) {
#line 31008
      tmp___0 = ((s * n) * l) / a;
    } else {
#line 31008
      tmp___0 = ((s * n) * l) / a + 1;
    }
#line 31008
    k = (a / s) * tmp___0;
  }
#line 31010
  start = (unsigned int )(ctx->Pack.SkipRows * k + ctx->Pack.SkipPixels * n);
#line 31011
  j = 0;
#line 31011
  while (j < height) {
#line 31012
    if ((ctx->Visual)->RGBAflag) {
#line 31017
      rscale = 1.0F * (ctx->Visual)->InvRedScale;
#line 31018
      gscale = 1.0F * (ctx->Visual)->InvGreenScale;
#line 31019
      bscale = 1.0F * (ctx->Visual)->InvBlueScale;
#line 31020
      ascale = 1.0F * (ctx->Visual)->InvAlphaScale;
#line 31022
      (*(ctx->Driver.ReadColorSpan))(ctx, (unsigned int )width, x, y, r, g, b, a___0);
#line 31023
      if (ctx->RasterMask & 256U) {
#line 31024
        gl_read_alpha_span(ctx, (unsigned int )width, x, y, a___0);
      }
#line 31026
      i = 0;
#line 31026
      while (i < width) {
#line 31027
        red[i] = (float )r[i] * rscale;
#line 31028
        green[i] = (float )g[i] * gscale;
#line 31029
        blue___0[i] = (float )b[i] * bscale;
#line 31030
        alpha[i] = (float )a___0[i] * ascale;
#line 31026
        i ++;
      }
#line 31032
      if (scale_or_bias) {
#line 31033
        scale_and_bias_rgba(ctx, width, red, green, blue___0, alpha);
      }
#line 31035
      if (ctx->Pixel.MapColorFlag) {
#line 31036
        map_rgba(ctx, width, red, green, blue___0, alpha);
      }
    } else {
#line 31046
      (*(ctx->Driver.ReadIndexSpan))(ctx, (unsigned int )width, x, y, index___0);
#line 31047
      if (ctx->Pixel.IndexShift != 0) {
        goto _L;
      } else {
#line 31047
        if (ctx->Pixel.IndexOffset != 0) {
          _L: /* CIL Label */ 
#line 31049
          if (ctx->Pixel.IndexShift < 0) {
#line 31051
            s___0 = (unsigned int )(- ctx->Pixel.IndexShift);
#line 31052
            i = 0;
#line 31052
            while (i < width) {
#line 31053
              index___0[i] = (index___0[i] >> s___0) + (GLuint )ctx->Pixel.IndexOffset;
#line 31052
              i ++;
            }
          } else {
#line 31058
            s___0 = (unsigned int )ctx->Pixel.IndexShift;
#line 31059
            i = 0;
#line 31059
            while (i < width) {
#line 31060
              index___0[i] = (index___0[i] << s___0) + (GLuint )ctx->Pixel.IndexOffset;
#line 31059
              i ++;
            }
          }
        }
      }
#line 31064
      i = 0;
#line 31064
      while (i < width) {
#line 31065
        red[i] = ctx->Pixel.MapItoR[index___0[i]];
#line 31066
        green[i] = ctx->Pixel.MapItoG[index___0[i]];
#line 31067
        blue___0[i] = ctx->Pixel.MapItoB[index___0[i]];
#line 31068
        alpha[i] = ctx->Pixel.MapItoA[index___0[i]];
#line 31064
        i ++;
      }
    }
#line 31071
    if (l_flag) {
#line 31072
      i = 0;
#line 31072
      while (i < width) {
#line 31073
        sum = (red[i] + green[i]) + blue___0[i];
#line 31074
        if (sum < 0.0F) {
#line 31074
          luminance[i] = 0.0F;
        } else {
#line 31074
          if (sum > 1.0F) {
#line 31074
            tmp___1 = 1.0F;
          } else {
#line 31074
            tmp___1 = sum;
          }
#line 31074
          luminance[i] = tmp___1;
        }
#line 31072
        i ++;
      }
    }
#line 31077
    switch (type) {
    case 5121: 
#line 31080
    dst = ((GLubyte *)pixels + start) + j * k;
#line 31081
    i = 0;
#line 31081
    while (i < width) {
#line 31082
      if (r_flag) {
#line 31082
        tmp___2 = dst;
#line 31082
        dst ++;
#line 31082
        *tmp___2 = (unsigned char )((int )(red[i] * 255.0F));
      }
#line 31083
      if (g_flag) {
#line 31083
        tmp___3 = dst;
#line 31083
        dst ++;
#line 31083
        *tmp___3 = (unsigned char )((int )(green[i] * 255.0F));
      }
#line 31084
      if (b_flag) {
#line 31084
        tmp___4 = dst;
#line 31084
        dst ++;
#line 31084
        *tmp___4 = (unsigned char )((int )(blue___0[i] * 255.0F));
      }
#line 31085
      if (l_flag) {
#line 31085
        tmp___5 = dst;
#line 31085
        dst ++;
#line 31085
        *tmp___5 = (unsigned char )((int )(luminance[i] * 255.0F));
      }
#line 31086
      if (a_flag) {
#line 31086
        tmp___6 = dst;
#line 31086
        dst ++;
#line 31086
        *tmp___6 = (unsigned char )((int )(alpha[i] * 255.0F));
      }
#line 31081
      i ++;
    }
#line 31089
    break;
    case 5120: 
#line 31092
    dst___0 = ((GLbyte *)pixels + start) + j * k;
#line 31093
    i = 0;
#line 31093
    while (i < width) {
#line 31094
      if (r_flag) {
#line 31094
        tmp___7 = dst___0;
#line 31094
        dst___0 ++;
#line 31094
        *tmp___7 = (signed char )(((int )(255.0F * red[i]) - 1) / 2);
      }
#line 31095
      if (g_flag) {
#line 31095
        tmp___8 = dst___0;
#line 31095
        dst___0 ++;
#line 31095
        *tmp___8 = (signed char )(((int )(255.0F * green[i]) - 1) / 2);
      }
#line 31096
      if (b_flag) {
#line 31096
        tmp___9 = dst___0;
#line 31096
        dst___0 ++;
#line 31096
        *tmp___9 = (signed char )(((int )(255.0F * blue___0[i]) - 1) / 2);
      }
#line 31097
      if (l_flag) {
#line 31097
        tmp___10 = dst___0;
#line 31097
        dst___0 ++;
#line 31097
        *tmp___10 = (signed char )(((int )(255.0F * luminance[i]) - 1) / 2);
      }
#line 31098
      if (a_flag) {
#line 31098
        tmp___11 = dst___0;
#line 31098
        dst___0 ++;
#line 31098
        *tmp___11 = (signed char )(((int )(255.0F * alpha[i]) - 1) / 2);
      }
#line 31093
      i ++;
    }
#line 31101
    break;
    case 5123: 
#line 31104
    dst___1 = ((GLushort *)pixels + start) + j * k;
#line 31105
    i = 0;
#line 31105
    while (i < width) {
#line 31106
      if (r_flag) {
#line 31106
        tmp___12 = dst___1;
#line 31106
        dst___1 ++;
#line 31106
        *tmp___12 = (unsigned short )((int )(red[i] * 65535.0F));
      }
#line 31107
      if (g_flag) {
#line 31107
        tmp___13 = dst___1;
#line 31107
        dst___1 ++;
#line 31107
        *tmp___13 = (unsigned short )((int )(green[i] * 65535.0F));
      }
#line 31108
      if (b_flag) {
#line 31108
        tmp___14 = dst___1;
#line 31108
        dst___1 ++;
#line 31108
        *tmp___14 = (unsigned short )((int )(blue___0[i] * 65535.0F));
      }
#line 31109
      if (l_flag) {
#line 31109
        tmp___15 = dst___1;
#line 31109
        dst___1 ++;
#line 31109
        *tmp___15 = (unsigned short )((int )(luminance[i] * 65535.0F));
      }
#line 31110
      if (a_flag) {
#line 31110
        tmp___16 = dst___1;
#line 31110
        dst___1 ++;
#line 31110
        *tmp___16 = (unsigned short )((int )(alpha[i] * 65535.0F));
      }
#line 31105
      i ++;
    }
#line 31113
    if (ctx->Pack.SwapBytes) {
#line 31114
      gl_swap2(((GLushort *)pixels + start) + j * k, (unsigned int )(width * n));
    }
#line 31116
    break;
    case 5122: 
#line 31119
    dst___2 = ((GLshort *)pixels + start) + j * k;
#line 31120
    i = 0;
#line 31120
    while (i < width) {
#line 31121
      if (r_flag) {
#line 31121
        tmp___17 = dst___2;
#line 31121
        dst___2 ++;
#line 31121
        *tmp___17 = (short )(((int )(65535.0F * red[i]) - 1) / 2);
      }
#line 31122
      if (g_flag) {
#line 31122
        tmp___18 = dst___2;
#line 31122
        dst___2 ++;
#line 31122
        *tmp___18 = (short )(((int )(65535.0F * green[i]) - 1) / 2);
      }
#line 31123
      if (b_flag) {
#line 31123
        tmp___19 = dst___2;
#line 31123
        dst___2 ++;
#line 31123
        *tmp___19 = (short )(((int )(65535.0F * blue___0[i]) - 1) / 2);
      }
#line 31124
      if (l_flag) {
#line 31124
        tmp___20 = dst___2;
#line 31124
        dst___2 ++;
#line 31124
        *tmp___20 = (short )(((int )(65535.0F * luminance[i]) - 1) / 2);
      }
#line 31125
      if (a_flag) {
#line 31125
        tmp___21 = dst___2;
#line 31125
        dst___2 ++;
#line 31125
        *tmp___21 = (short )(((int )(65535.0F * alpha[i]) - 1) / 2);
      }
#line 31120
      i ++;
    }
#line 31127
    if (ctx->Pack.SwapBytes) {
#line 31128
      gl_swap2(((GLushort *)pixels + start) + j * k, (unsigned int )(width * n));
    }
#line 31131
    break;
    case 5125: 
#line 31134
    dst___3 = ((GLuint *)pixels + start) + j * k;
#line 31135
    i = 0;
#line 31135
    while (i < width) {
#line 31136
      if (r_flag) {
#line 31136
        tmp___22 = dst___3;
#line 31136
        dst___3 ++;
#line 31136
        *tmp___22 = (unsigned int )((double )red[i] * 4294967295.0);
      }
#line 31137
      if (g_flag) {
#line 31137
        tmp___23 = dst___3;
#line 31137
        dst___3 ++;
#line 31137
        *tmp___23 = (unsigned int )((double )green[i] * 4294967295.0);
      }
#line 31138
      if (b_flag) {
#line 31138
        tmp___24 = dst___3;
#line 31138
        dst___3 ++;
#line 31138
        *tmp___24 = (unsigned int )((double )blue___0[i] * 4294967295.0);
      }
#line 31139
      if (l_flag) {
#line 31139
        tmp___25 = dst___3;
#line 31139
        dst___3 ++;
#line 31139
        *tmp___25 = (unsigned int )((double )luminance[i] * 4294967295.0);
      }
#line 31140
      if (a_flag) {
#line 31140
        tmp___26 = dst___3;
#line 31140
        dst___3 ++;
#line 31140
        *tmp___26 = (unsigned int )((double )alpha[i] * 4294967295.0);
      }
#line 31135
      i ++;
    }
#line 31142
    if (ctx->Pack.SwapBytes) {
#line 31143
      gl_swap4(((GLuint *)pixels + start) + j * k, (unsigned int )(width * n));
    }
#line 31146
    break;
    case 5124: 
#line 31149
    dst___4 = ((GLint *)pixels + start) + j * k;
#line 31150
    i = 0;
#line 31150
    while (i < width) {
#line 31151
      if (r_flag) {
#line 31151
        tmp___27 = dst___4;
#line 31151
        dst___4 ++;
#line 31151
        *tmp___27 = (int )(2147483647.0 * (double )red[i]);
      }
#line 31152
      if (g_flag) {
#line 31152
        tmp___28 = dst___4;
#line 31152
        dst___4 ++;
#line 31152
        *tmp___28 = (int )(2147483647.0 * (double )green[i]);
      }
#line 31153
      if (b_flag) {
#line 31153
        tmp___29 = dst___4;
#line 31153
        dst___4 ++;
#line 31153
        *tmp___29 = (int )(2147483647.0 * (double )blue___0[i]);
      }
#line 31154
      if (l_flag) {
#line 31154
        tmp___30 = dst___4;
#line 31154
        dst___4 ++;
#line 31154
        *tmp___30 = (int )(2147483647.0 * (double )luminance[i]);
      }
#line 31155
      if (a_flag) {
#line 31155
        tmp___31 = dst___4;
#line 31155
        dst___4 ++;
#line 31155
        *tmp___31 = (int )(2147483647.0 * (double )alpha[i]);
      }
#line 31150
      i ++;
    }
#line 31157
    if (ctx->Pack.SwapBytes) {
#line 31158
      gl_swap4(((GLuint *)pixels + start) + j * k, (unsigned int )(width * n));
    }
#line 31161
    break;
    case 5126: 
#line 31164
    dst___5 = ((float *)pixels + start) + j * k;
#line 31165
    i = 0;
#line 31165
    while (i < width) {
#line 31166
      if (r_flag) {
#line 31166
        tmp___32 = dst___5;
#line 31166
        dst___5 ++;
#line 31166
        *tmp___32 = red[i];
      }
#line 31167
      if (g_flag) {
#line 31167
        tmp___33 = dst___5;
#line 31167
        dst___5 ++;
#line 31167
        *tmp___33 = green[i];
      }
#line 31168
      if (b_flag) {
#line 31168
        tmp___34 = dst___5;
#line 31168
        dst___5 ++;
#line 31168
        *tmp___34 = blue___0[i];
      }
#line 31169
      if (l_flag) {
#line 31169
        tmp___35 = dst___5;
#line 31169
        dst___5 ++;
#line 31169
        *tmp___35 = luminance[i];
      }
#line 31170
      if (a_flag) {
#line 31170
        tmp___36 = dst___5;
#line 31170
        dst___5 ++;
#line 31170
        *tmp___36 = alpha[i];
      }
#line 31165
      i ++;
    }
#line 31172
    if (ctx->Pack.SwapBytes) {
#line 31173
      gl_swap4(((GLuint *)pixels + start) + j * k, (unsigned int )(width * n));
    }
#line 31176
    break;
    default: 
#line 31178
    gl_error(ctx, 1280, "glReadPixels(type)");
    }
#line 31011
    j ++;
#line 31011
    y ++;
  }
#line 31186
  return;
}
}
#line 31187 "D:/a/test/177.c"
void gl_ReadPixels(GLcontext *ctx , GLint x , GLint y , GLsizei width , GLsizei height ,
                   GLenum format , GLenum type , GLvoid *pixels ) 
{ 

  {
#line 31191
  if (ctx->Primitive != 6656) {
#line 31192
    gl_error(ctx, 1282, "glReadPixels");
#line 31193
    return;
  }
#line 31195
  (*(ctx->Driver.SetBuffer))(ctx, ctx->Pixel.ReadBuffer);
#line 31196
  switch (format) {
  case 6400: 
#line 31198
  read_index_pixels1(ctx, x, y, width, height, type, pixels);
#line 31199
  break;
  case 6401: 
#line 31201
  read_stencil_pixels(ctx, x, y, width, height, type, pixels);
#line 31202
  break;
  case 6402: 
#line 31204
  read_depth_pixels(ctx, x, y, width, height, type, pixels);
#line 31205
  break;
  case 6403: 
  case 6404: 
  case 6405: 
  case 6406: 
  case 6407: 
  case 6409: 
  case 6410: 
  case 6408: 
#line 31214
  read_color_pixels1(ctx, x, y, width, height, format, type, pixels);
#line 31215
  break;
  default: 
#line 31217
  gl_error(ctx, 1280, "glReadPixels(format)");
  }
#line 31219
  (*(ctx->Driver.SetBuffer))(ctx, ctx->Color.DrawBuffer);
#line 31220
  return;
}
}
#line 31226 "D:/a/test/177.c"
void gl_Rectf(GLcontext *ctx , float x1 , float y1___0 , float x2 , float y2 ) 
{ 

  {
#line 31228
  if (ctx->Primitive != 6656) {
#line 31229
    gl_error(ctx, 1282, "glRect");
#line 31230
    return;
  }
#line 31232
  gl_Begin(ctx, 7);
#line 31233
  (*(ctx->Exec.Vertex2f))(ctx, x1, y1___0);
#line 31234
  (*(ctx->Exec.Vertex2f))(ctx, x2, y1___0);
#line 31235
  (*(ctx->Exec.Vertex2f))(ctx, x2, y2);
#line 31236
  (*(ctx->Exec.Vertex2f))(ctx, x1, y2);
#line 31237
  gl_End(ctx);
#line 31238
  return;
}
}
#line 31244 "D:/a/test/177.c"
void gl_Scissor(GLcontext *ctx , GLint x , GLint y , GLsizei width , GLsizei height ) 
{ 

  {
#line 31247
  if (width < 0) {
#line 31248
    gl_error(ctx, 1281, "glScissor");
#line 31249
    return;
  } else {
#line 31247
    if (height < 0) {
#line 31248
      gl_error(ctx, 1281, "glScissor");
#line 31249
      return;
    }
  }
#line 31251
  if (ctx->Primitive != 6656) {
#line 31252
    gl_error(ctx, 1282, "glBegin");
#line 31253
    return;
  }
#line 31255
  ctx->Scissor.X = x;
#line 31256
  ctx->Scissor.Y = y;
#line 31257
  ctx->Scissor.Width = width;
#line 31258
  ctx->Scissor.Height = height;
#line 31259
  ctx->NewState |= 15U;
#line 31260
  return;
}
}
#line 31261 "D:/a/test/177.c"
GLint gl_scissor_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *mask ) 
{ GLint i ;
  GLint xMin ;
  GLint xMax ;

  {
#line 31264
  if (y < (ctx->Buffer)->Ymin) {
#line 31266
    return (0);
  } else {
#line 31264
    if (y > (ctx->Buffer)->Ymax) {
#line 31266
      return (0);
    } else {
#line 31264
      if (x > (ctx->Buffer)->Xmax) {
#line 31266
        return (0);
      } else {
#line 31264
        if ((x + (int )n) - 1 < (ctx->Buffer)->Xmin) {
#line 31266
          return (0);
        } else {
#line 31270
          xMin = (ctx->Buffer)->Xmin;
#line 31271
          xMax = (ctx->Buffer)->Xmax;
#line 31272
          i = 0;
#line 31272
          while (x + i < xMin) {
#line 31273
            *(mask + i) = (unsigned char)0;
#line 31272
            i ++;
          }
#line 31275
          i = (int )n - 1;
#line 31275
          while (x + i > xMax) {
#line 31276
            *(mask + i) = (unsigned char)0;
#line 31275
            i --;
          }
#line 31278
          return (1);
        }
      }
    }
  }
}
}
#line 31281 "D:/a/test/177.c"
GLuint gl_scissor_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                         GLubyte *mask ) 
{ GLint xmin ;
  GLint xmax ;
  GLint ymin ;
  GLint ymax ;
  GLuint i ;

  {
#line 31285
  xmin = (ctx->Buffer)->Xmin;
#line 31286
  xmax = (ctx->Buffer)->Xmax;
#line 31287
  ymin = (ctx->Buffer)->Ymin;
#line 31288
  ymax = (ctx->Buffer)->Ymax;
#line 31290
  i = 0U;
#line 31290
  while (i < n) {
#line 31291
    *(mask + i) = (unsigned char )((int )*(mask + i) & ((((*(x + i) >= (GLint const   )xmin) & (*(x + i) <= (GLint const   )xmax)) & (*(y + i) >= (GLint const   )ymin)) & (*(y + i) <= (GLint const   )ymax)));
#line 31290
    i ++;
  }
#line 31293
  return (1U);
}
}
#line 31300 "D:/a/test/177.c"
static float gl_pow(float x , float y ) 
{ GLdouble z ;
  double tmp___0 ;

  {
#line 31302
  tmp___0 = pow((double )x, (double )y);
#line 31302
  z = tmp___0;
#line 31303
  if (z < 1.0e-10) {
#line 31304
    return (0.0F);
  } else {
#line 31306
    return ((float )z);
  }
}
}
#line 31308 "D:/a/test/177.c"
void gl_color_shade_vertices(GLcontext *ctx , GLuint side , GLuint n , float (*vertex)[4] ,
                             float (*normal)[3] , GLubyte (*color)[4] ) 
{ GLint j ;
  float rscale ;
  float gscale ;
  float bscale ;
  float ascale ;
  float baseR ;
  float baseG ;
  float baseB ;
  float baseA ;
  GLint sumA ;
  struct gl_light *light ;
  struct gl_material *mat ;
  float tmp___0 ;
  float tmp___1 ;
  float sumR ;
  float sumG ;
  float sumB ;
  float nx ;
  float ny ;
  float nz ;
  float ambientR ;
  float ambientG ;
  float ambientB ;
  float attenuation ;
  float spot ;
  float VPx ;
  float VPy ;
  float VPz ;
  float n_dot_VP ;
  float d ;
  int tmp___2 ;
  float invd ;
  float PVx ;
  float PVy ;
  float PVz ;
  float PV_dot_dir ;
  double x ;
  int k ;
  float t ;
  float diffuseR ;
  float diffuseG ;
  float diffuseB ;
  float specularR ;
  float specularG ;
  float specularB ;
  float h_x ;
  float h_y ;
  float h_z ;
  float n_dot_h ;
  float t___0 ;
  float vx ;
  float vy ;
  float vz ;
  float vlen ;
  int tmp___3 ;
  float invlen ;
  float spec_coef ;
  int tmp___4 ;
  double tmp___5 ;
  int k___0 ;
  float tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  float tmp___9 ;
  float tmp___10 ;
  float tmp___11 ;

  {
#line 31321
  rscale = (ctx->Visual)->RedScale;
#line 31322
  gscale = (ctx->Visual)->GreenScale;
#line 31323
  bscale = (ctx->Visual)->BlueScale;
#line 31324
  ascale = (ctx->Visual)->AlphaScale;
#line 31325
  mat = & ctx->Light.Material[side];
#line 31326
  baseR = mat->Emission[0] + ctx->Light.Model.Ambient[0] * mat->Ambient[0];
#line 31327
  baseG = mat->Emission[1] + ctx->Light.Model.Ambient[1] * mat->Ambient[1];
#line 31328
  baseB = mat->Emission[2] + ctx->Light.Model.Ambient[2] * mat->Ambient[2];
#line 31329
  baseA = mat->Diffuse[3];
#line 31330
  if (baseA < 0.0F) {
#line 31330
    tmp___1 = 0.0F;
  } else {
#line 31330
    if (baseA > 1.0F) {
#line 31330
      tmp___0 = 1.0F;
    } else {
#line 31330
      tmp___0 = baseA;
    }
#line 31330
    tmp___1 = tmp___0;
  }
#line 31330
  sumA = (int )(tmp___1 * ascale);
#line 31331
  j = 0;
#line 31331
  while ((GLuint )j < n) {
#line 31334
    if (side == 0U) {
#line 31335
      nx = (*(normal + j))[0];
#line 31336
      ny = (*(normal + j))[1];
#line 31337
      nz = (*(normal + j))[2];
    } else {
#line 31340
      nx = - (*(normal + j))[0];
#line 31341
      ny = - (*(normal + j))[1];
#line 31342
      nz = - (*(normal + j))[2];
    }
#line 31344
    sumR = baseR;
#line 31345
    sumG = baseG;
#line 31346
    sumB = baseB;
#line 31347
    light = ctx->Light.FirstEnabled;
#line 31347
    while (light) {
#line 31352
      if ((double )light->Position[3] == 0.0) {
#line 31353
        VPx = light->VP_inf_norm[0];
#line 31354
        VPy = light->VP_inf_norm[1];
#line 31355
        VPz = light->VP_inf_norm[2];
#line 31356
        attenuation = 1.0F;
      } else {
#line 31360
        VPx = light->Position[0] - (*(vertex + j))[0];
#line 31361
        VPy = light->Position[1] - (*(vertex + j))[1];
#line 31362
        VPz = light->Position[2] - (*(vertex + j))[2];
#line 31363
        tmp___2 = GL_SQRT((VPx * VPx + VPy * VPy) + VPz * VPz);
#line 31363
        d = (float )tmp___2;
#line 31364
        if (d > 0.001F) {
#line 31365
          invd = 1.0F / d;
#line 31366
          VPx *= invd;
#line 31367
          VPy *= invd;
#line 31368
          VPz *= invd;
        }
#line 31370
        attenuation = 1.0F / (light->ConstantAttenuation + d * (light->LinearAttenuation + d * light->QuadraticAttenuation));
      }
#line 31374
      if (light->SpotCutoff == 180.0F) {
#line 31375
        spot = 1.0F;
      } else {
#line 31379
        PVx = - VPx;
#line 31380
        PVy = - VPy;
#line 31381
        PVz = - VPz;
#line 31382
        PV_dot_dir = (PVx * light->NormDirection[0] + PVy * light->NormDirection[1]) + PVz * light->NormDirection[2];
#line 31385
        if (PV_dot_dir <= 0.0F) {
#line 31386
          spot = 0.0F;
        } else {
#line 31385
          if (PV_dot_dir < light->CosCutoff) {
#line 31386
            spot = 0.0F;
          } else {
#line 31389
            x = (double )(PV_dot_dir * (float )511);
#line 31390
            k = (int )x;
#line 31391
            spot = (float )((double )light->SpotExpTable[k][0] + (x - (double )k) * (double )light->SpotExpTable[k][1]);
          }
        }
      }
#line 31395
      ambientR = mat->Ambient[0] * light->Ambient[0];
#line 31396
      ambientG = mat->Ambient[1] * light->Ambient[1];
#line 31397
      ambientB = mat->Ambient[2] * light->Ambient[2];
#line 31398
      n_dot_VP = (nx * VPx + ny * VPy) + nz * VPz;
#line 31399
      if (n_dot_VP <= 0.0F) {
#line 31400
        t = attenuation * spot;
#line 31401
        sumR += t * ambientR;
#line 31402
        sumG += t * ambientG;
#line 31403
        sumB += t * ambientB;
      } else {
#line 31409
        diffuseR = (n_dot_VP * mat->Diffuse[0]) * light->Diffuse[0];
#line 31410
        diffuseG = (n_dot_VP * mat->Diffuse[1]) * light->Diffuse[1];
#line 31411
        diffuseB = (n_dot_VP * mat->Diffuse[2]) * light->Diffuse[2];
#line 31412
        if (ctx->Light.Model.LocalViewer) {
#line 31414
          vx = (*(vertex + j))[0];
#line 31415
          vy = (*(vertex + j))[1];
#line 31416
          vz = (*(vertex + j))[2];
#line 31417
          tmp___3 = GL_SQRT((vx * vx + vy * vy) + vz * vz);
#line 31417
          vlen = (float )tmp___3;
#line 31418
          if (vlen > 0.0001F) {
#line 31419
            invlen = 1.0F / vlen;
#line 31420
            vx *= invlen;
#line 31421
            vy *= invlen;
#line 31422
            vz *= invlen;
          }
#line 31424
          h_x = VPx - vx;
#line 31425
          h_y = VPy - vy;
#line 31426
          h_z = VPz - vz;
        } else {
#line 31429
          h_x = VPx;
#line 31430
          h_y = VPy;
#line 31431
          h_z = VPz + 1.0F;
        }
#line 31433
        n_dot_h = (nx * h_x + ny * h_y) + nz * h_z;
#line 31434
        if (n_dot_h <= 0.0F) {
#line 31435
          specularR = 0.0F;
#line 31436
          specularG = 0.0F;
#line 31437
          specularB = 0.0F;
        } else {
#line 31441
          tmp___4 = GL_SQRT((h_x * h_x + h_y * h_y) + h_z * h_z);
#line 31441
          n_dot_h /= (float )tmp___4;
#line 31442
          if (n_dot_h > 1.0F) {
#line 31443
            tmp___5 = pow((double )n_dot_h, (double )mat->Shininess);
#line 31443
            spec_coef = (float )tmp___5;
          } else {
#line 31446
            k___0 = (int )(n_dot_h * (float )199);
#line 31447
            if (mat->ShineTable[k___0] < 0.0F) {
#line 31448
              mat->ShineTable[k___0] = gl_pow(n_dot_h, mat->Shininess);
            }
#line 31449
            spec_coef = mat->ShineTable[k___0];
          }
#line 31451
          if ((double )spec_coef < 1.0e-10) {
#line 31452
            specularR = 0.0F;
#line 31453
            specularG = 0.0F;
#line 31454
            specularB = 0.0F;
          } else {
#line 31457
            specularR = (spec_coef * mat->Specular[0]) * light->Specular[0];
#line 31458
            specularG = (spec_coef * mat->Specular[1]) * light->Specular[1];
#line 31459
            specularB = (spec_coef * mat->Specular[2]) * light->Specular[2];
          }
        }
#line 31462
        t___0 = attenuation * spot;
#line 31463
        sumR += t___0 * ((ambientR + diffuseR) + specularR);
#line 31464
        sumG += t___0 * ((ambientG + diffuseG) + specularG);
#line 31465
        sumB += t___0 * ((ambientB + diffuseB) + specularB);
      }
#line 31347
      light = light->NextEnabled;
    }
#line 31468
    if (sumR < 0.0F) {
#line 31468
      tmp___7 = 0.0F;
    } else {
#line 31468
      if (sumR > 1.0F) {
#line 31468
        tmp___6 = 1.0F;
      } else {
#line 31468
        tmp___6 = sumR;
      }
#line 31468
      tmp___7 = tmp___6;
    }
#line 31468
    (*(color + j))[0] = (unsigned char )((int )(tmp___7 * rscale));
#line 31469
    if (sumG < 0.0F) {
#line 31469
      tmp___9 = 0.0F;
    } else {
#line 31469
      if (sumG > 1.0F) {
#line 31469
        tmp___8 = 1.0F;
      } else {
#line 31469
        tmp___8 = sumG;
      }
#line 31469
      tmp___9 = tmp___8;
    }
#line 31469
    (*(color + j))[1] = (unsigned char )((int )(tmp___9 * gscale));
#line 31470
    if (sumB < 0.0F) {
#line 31470
      tmp___11 = 0.0F;
    } else {
#line 31470
      if (sumB > 1.0F) {
#line 31470
        tmp___10 = 1.0F;
      } else {
#line 31470
        tmp___10 = sumB;
      }
#line 31470
      tmp___11 = tmp___10;
    }
#line 31470
    (*(color + j))[2] = (unsigned char )((int )(tmp___11 * bscale));
#line 31471
    (*(color + j))[3] = (unsigned char )sumA;
#line 31331
    j ++;
  }
#line 31473
  return;
}
}
#line 31474 "D:/a/test/177.c"
void gl_color_shade_vertices_fast(GLcontext *ctx , GLuint side , GLuint n , float (*normal)[3] ,
                                  GLubyte (*color)[4] ) 
{ GLint j ;
  float rscale ;
  float gscale ;
  float bscale ;
  float ascale ;
  GLint sumA ;
  float *baseColor ;
  float sumR ;
  float sumG ;
  float sumB ;
  float nx ;
  float ny ;
  float nz ;
  struct gl_light *light ;
  float n_dot_VP ;
  float n_dot_h ;
  float *lightMatDiffuse ;
  float spec_coef ;
  double tmp___0 ;
  int k ;
  struct gl_material *m ;
  float spec_coef___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;

  {
#line 31483
  baseColor = ctx->Light.BaseColor[side];
#line 31484
  rscale = (ctx->Visual)->RedScale;
#line 31485
  gscale = (ctx->Visual)->GreenScale;
#line 31486
  bscale = (ctx->Visual)->BlueScale;
#line 31487
  ascale = (ctx->Visual)->AlphaScale;
#line 31488
  sumA = (int )(*(baseColor + 3) * ascale);
#line 31489
  j = 0;
#line 31489
  while ((GLuint )j < n) {
#line 31493
    if (side == 0U) {
#line 31494
      nx = (*(normal + j))[0];
#line 31495
      ny = (*(normal + j))[1];
#line 31496
      nz = (*(normal + j))[2];
    } else {
#line 31499
      nx = - (*(normal + j))[0];
#line 31500
      ny = - (*(normal + j))[1];
#line 31501
      nz = - (*(normal + j))[2];
    }
#line 31512
    sumR = *(baseColor + 0);
#line 31513
    sumG = *(baseColor + 1);
#line 31514
    sumB = *(baseColor + 2);
#line 31515
    light = ctx->Light.FirstEnabled;
#line 31515
    while (light) {
#line 31517
      n_dot_VP = (nx * light->VP_inf_norm[0] + ny * light->VP_inf_norm[1]) + nz * light->VP_inf_norm[2];
#line 31520
      if (n_dot_VP > 0.0F) {
#line 31522
        lightMatDiffuse = light->MatDiffuse[side];
#line 31523
        sumR += n_dot_VP * *(lightMatDiffuse + 0);
#line 31524
        sumG += n_dot_VP * *(lightMatDiffuse + 1);
#line 31525
        sumB += n_dot_VP * *(lightMatDiffuse + 2);
#line 31526
        n_dot_h = (nx * light->h_inf_norm[0] + ny * light->h_inf_norm[1]) + nz * light->h_inf_norm[2];
#line 31529
        if (n_dot_h > 0.0F) {
#line 31530
          if (n_dot_h > 1.0F) {
#line 31531
            tmp___0 = pow((double )n_dot_h, (double )ctx->Light.Material[side].Shininess);
#line 31531
            spec_coef = (float )tmp___0;
#line 31533
            if (spec_coef > 1.0e-10F) {
#line 31534
              sumR += spec_coef * light->MatSpecular[side][0];
#line 31535
              sumG += spec_coef * light->MatSpecular[side][1];
#line 31536
              sumB += spec_coef * light->MatSpecular[side][2];
            }
          } else {
#line 31540
            k = (int )(n_dot_h * (float )199);
#line 31541
            m = & ctx->Light.Material[side];
#line 31543
            if (m->ShineTable[k] < 0.0F) {
#line 31544
              m->ShineTable[k] = gl_pow(n_dot_h, m->Shininess);
            }
#line 31545
            spec_coef___0 = m->ShineTable[k];
#line 31546
            sumR += spec_coef___0 * light->MatSpecular[side][0];
#line 31547
            sumG += spec_coef___0 * light->MatSpecular[side][1];
#line 31548
            sumB += spec_coef___0 * light->MatSpecular[side][2];
          }
        }
      }
#line 31515
      light = light->NextEnabled;
    }
#line 31553
    if (sumR < 1.0F) {
#line 31553
      tmp___1 = sumR;
    } else {
#line 31553
      tmp___1 = 1.0F;
    }
#line 31553
    (*(color + j))[0] = (unsigned char )((int )(tmp___1 * rscale));
#line 31554
    if (sumG < 1.0F) {
#line 31554
      tmp___2 = sumG;
    } else {
#line 31554
      tmp___2 = 1.0F;
    }
#line 31554
    (*(color + j))[1] = (unsigned char )((int )(tmp___2 * gscale));
#line 31555
    if (sumB < 1.0F) {
#line 31555
      tmp___3 = sumB;
    } else {
#line 31555
      tmp___3 = 1.0F;
    }
#line 31555
    (*(color + j))[2] = (unsigned char )((int )(tmp___3 * bscale));
#line 31556
    (*(color + j))[3] = (unsigned char )sumA;
#line 31489
    j ++;
  }
#line 31558
  return;
}
}
#line 31559 "D:/a/test/177.c"
void gl_index_shade_vertices(GLcontext *ctx , GLuint side , GLuint n , float (*vertex)[4] ,
                             float (*normal)[3] , GLuint *indexResult ) 
{ struct gl_material *mat ;
  GLint j ;
  float index___0 ;
  float diffuse ;
  float specular ;
  float nx ;
  float ny ;
  float nz ;
  struct gl_light *light ;
  float attenuation ;
  float lx ;
  float ly ;
  float lz ;
  float l_dot_norm ;
  float d ;
  int tmp___0 ;
  float invd ;
  float spot_times_atten ;
  float v[3] ;
  float dot ;
  double x ;
  int k ;
  float spot ;
  float h_x ;
  float h_y ;
  float h_z ;
  float n_dot_h ;
  float spec_coef ;
  float vx ;
  float vy ;
  float vz ;
  float vlen ;
  int tmp___1 ;
  float invlen ;
  int tmp___2 ;
  double tmp___3 ;
  int k___0 ;
  float d_a ;
  float s_a ;

  {
#line 31566
  mat = & ctx->Light.Material[side];
#line 31568
  j = 0;
#line 31568
  while ((GLuint )j < n) {
#line 31573
    if (side == 0U) {
#line 31574
      nx = (*(normal + j))[0];
#line 31575
      ny = (*(normal + j))[1];
#line 31576
      nz = (*(normal + j))[2];
    } else {
#line 31579
      nx = - (*(normal + j))[0];
#line 31580
      ny = - (*(normal + j))[1];
#line 31581
      nz = - (*(normal + j))[2];
    }
#line 31583
    specular = 0.0F;
#line 31583
    diffuse = specular;
#line 31584
    light = ctx->Light.FirstEnabled;
#line 31584
    while (light) {
#line 31588
      if ((double )light->Position[3] == 0.0) {
#line 31589
        lx = light->VP_inf_norm[0];
#line 31590
        ly = light->VP_inf_norm[1];
#line 31591
        lz = light->VP_inf_norm[2];
#line 31592
        attenuation = 1.0F;
      } else {
#line 31596
        lx = light->Position[0] - (*(vertex + j))[0];
#line 31597
        ly = light->Position[1] - (*(vertex + j))[1];
#line 31598
        lz = light->Position[2] - (*(vertex + j))[2];
#line 31599
        tmp___0 = GL_SQRT((lx * lx + ly * ly) + lz * lz);
#line 31599
        d = (float )tmp___0;
#line 31600
        if (d > 0.001F) {
#line 31601
          invd = 1.0F / d;
#line 31602
          lx *= invd;
#line 31603
          ly *= invd;
#line 31604
          lz *= invd;
        }
#line 31606
        attenuation = 1.0F / (light->ConstantAttenuation + d * (light->LinearAttenuation + d * light->QuadraticAttenuation));
      }
#line 31610
      l_dot_norm = (lx * nx + ly * ny) + lz * nz;
#line 31611
      if (l_dot_norm > 0.0F) {
#line 31613
        if (light->SpotCutoff == 180.0F) {
#line 31614
          spot_times_atten = attenuation;
        } else {
#line 31618
          v[0] = - lx;
#line 31619
          v[1] = - ly;
#line 31620
          v[2] = - lz;
#line 31621
          dot = (v[0] * light->NormDirection[0] + v[1] * light->NormDirection[1]) + v[2] * light->NormDirection[2];
#line 31622
          if (dot <= 0.0F) {
#line 31623
            spot_times_atten = 0.0F;
          } else {
#line 31622
            if (dot < light->CosCutoff) {
#line 31623
              spot_times_atten = 0.0F;
            } else {
#line 31626
              x = (double )(dot * (float )511);
#line 31627
              k = (int )x;
#line 31628
              spot = (float )((double )light->SpotExpTable[k][0] + (x - (double )k) * (double )light->SpotExpTable[k][1]);
#line 31630
              spot_times_atten = spot * attenuation;
            }
          }
        }
#line 31633
        diffuse += (l_dot_norm * light->dli) * spot_times_atten;
#line 31636
        if (ctx->Light.Model.LocalViewer) {
#line 31638
          vx = (*(vertex + j))[0];
#line 31639
          vy = (*(vertex + j))[1];
#line 31640
          vz = (*(vertex + j))[2];
#line 31641
          tmp___1 = GL_SQRT((vx * vx + vy * vy) + vz * vz);
#line 31641
          vlen = (float )tmp___1;
#line 31642
          if (vlen > 0.0001F) {
#line 31643
            invlen = 1.0F / vlen;
#line 31644
            vx *= invlen;
#line 31645
            vy *= invlen;
#line 31646
            vz *= invlen;
          }
#line 31648
          h_x = lx - vx;
#line 31649
          h_y = ly - vy;
#line 31650
          h_z = lz - vz;
        } else {
#line 31653
          h_x = lx;
#line 31654
          h_y = ly;
#line 31655
          h_z = lz + 1.0F;
        }
#line 31657
        n_dot_h = (h_x * nx + h_y * ny) + h_z * nz;
#line 31658
        if (n_dot_h <= 0.0F) {
#line 31659
          spec_coef = 0.0F;
        } else {
#line 31662
          tmp___2 = GL_SQRT((h_x * h_x + h_y * h_y) + h_z * h_z);
#line 31662
          n_dot_h /= (float )tmp___2;
#line 31663
          if (n_dot_h > 1.0F) {
#line 31664
            tmp___3 = pow((double )n_dot_h, (double )mat->Shininess);
#line 31664
            spec_coef = (float )tmp___3;
          } else {
#line 31667
            k___0 = (int )(n_dot_h * (float )199);
#line 31668
            if (mat->ShineTable[k___0] < 0.0F) {
#line 31669
              mat->ShineTable[k___0] = gl_pow(n_dot_h, mat->Shininess);
            }
#line 31670
            spec_coef = mat->ShineTable[k___0];
          }
        }
#line 31673
        specular += (spec_coef * light->sli) * spot_times_atten;
      }
#line 31584
      light = light->NextEnabled;
    }
#line 31677
    if (specular > 1.0F) {
#line 31678
      index___0 = mat->SpecularIndex;
    } else {
#line 31682
      d_a = mat->DiffuseIndex - mat->AmbientIndex;
#line 31683
      s_a = mat->SpecularIndex - mat->AmbientIndex;
#line 31684
      index___0 = (mat->AmbientIndex + (diffuse * (1.0F - specular)) * d_a) + specular * s_a;
#line 31687
      if (index___0 > mat->SpecularIndex) {
#line 31688
        index___0 = mat->SpecularIndex;
      }
    }
#line 31691
    *(indexResult + j) = (unsigned int )((int )index___0);
#line 31568
    j ++;
  }
#line 31693
  return;
}
}
#line 31699 "D:/a/test/177.c"
static void stipple_polygon_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *mask ) 
{ register GLuint i ;
  register GLuint m ;
  register GLuint stipple ;
  register GLuint highbit ;

  {
#line 31702
  highbit = 2147483648U;
#line 31703
  stipple = ctx->PolygonStipple[y % 32];
#line 31704
  m = highbit >> (unsigned int )(x % 32);
#line 31705
  i = 0U;
#line 31705
  while (i < n) {
#line 31706
    if ((m & stipple) == 0U) {
#line 31707
      *(mask + i) = (unsigned char)0;
    }
#line 31709
    m >>= 1;
#line 31710
    if (m == 0U) {
#line 31711
      m = 2147483648U;
    }
#line 31705
    i ++;
  }
#line 31714
  return;
}
}
#line 31715 "D:/a/test/177.c"
static GLuint clip_span(GLcontext *ctx , GLint n , GLint x , GLint y , GLubyte *mask ) 
{ GLint i ;

  {
#line 31719
  if (y < 0) {
#line 31720
    return (0U);
  } else {
#line 31719
    if (y >= (ctx->Buffer)->Height) {
#line 31720
      return (0U);
    }
  }
#line 31722
  if (x >= 0) {
#line 31722
    if (x + n <= (ctx->Buffer)->Width) {
#line 31723
      return (1U);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 31725
    if (x + n <= 0) {
#line 31726
      return (0U);
    } else {
#line 31728
      if (x >= (ctx->Buffer)->Width) {
#line 31729
        return (0U);
      } else {
#line 31732
        i = 0;
#line 31732
        while (i < n) {
#line 31733
          if (x + i < 0) {
#line 31734
            *(mask + i) = (unsigned char)0;
          } else {
#line 31733
            if (x + i >= (ctx->Buffer)->Width) {
#line 31734
              *(mask + i) = (unsigned char)0;
            }
          }
#line 31732
          i ++;
        }
#line 31737
        return (1U);
      }
    }
  }
}
}
#line 31765
GLint gl_stencil_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *mask ) ;
#line 31768
void gl_depth_stencil_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth const   *z ,
                           GLubyte *mask ) ;
#line 31740 "D:/a/test/177.c"
void gl_write_index_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth *z ,
                         GLuint *index___0 , GLenum primitive ) 
{ GLubyte mask[640] ;
  GLuint index_save[640] ;
  GLuint tmp___0 ;
  GLint tmp___1 ;
  int tmp___2 ;
  GLuint tmp___3 ;

  {
#line 31746
  memset((void *)(mask), 1, n);
#line 31747
  if (ctx->RasterMask & 512U) {
    goto _L;
  } else {
#line 31747
    if (primitive == 6656) {
      _L: /* CIL Label */ 
#line 31748
      tmp___0 = clip_span(ctx, (int )n, x, y, mask);
#line 31748
      if (tmp___0 == 0U) {
#line 31749
        return;
      }
    }
  }
#line 31752
  if (ctx->Fog.Enabled) {
#line 31752
    if (ctx->Hint.Fog == 4354) {
#line 31754
      gl_fog_index_pixels(ctx, n, (GLdepth const   *)z, index___0);
    } else {
#line 31752
      if (primitive == 6656) {
#line 31754
        gl_fog_index_pixels(ctx, n, (GLdepth const   *)z, index___0);
      }
    }
  }
#line 31756
  if (ctx->Scissor.Enabled) {
#line 31757
    tmp___1 = gl_scissor_span(ctx, n, x, y, mask);
#line 31757
    if (tmp___1 == 0) {
#line 31758
      return;
    }
  }
#line 31761
  if (ctx->Polygon.StippleFlag) {
#line 31761
    if (primitive == 9) {
#line 31762
      stipple_polygon_span(ctx, n, x, y, mask);
    }
  }
#line 31764
  if (ctx->Stencil.Enabled) {
#line 31765
    tmp___2 = gl_stencil_span(ctx, n, x, y, mask);
#line 31765
    if (tmp___2 == 0) {
#line 31766
      return;
    }
#line 31768
    gl_depth_stencil_span(ctx, n, x, y, z, mask);
  } else {
#line 31770
    if (ctx->Depth.Test) {
#line 31771
      tmp___3 = (*(ctx->Driver.DepthTestSpan))(ctx, n, x, y, (GLdepth const   *)z,
                                               mask);
#line 31771
      if (tmp___3 == 0U) {
#line 31771
        return;
      }
    }
  }
#line 31773
  if (ctx->RasterMask & 2048U) {
#line 31774
    return;
  }
#line 31776
  if (ctx->RasterMask & 1024U) {
#line 31777
    memcpy((void *)(index_save), (void const   *)((void *)index___0), n * sizeof(GLuint ));
  }
#line 31779
  if (ctx->Color.SWLogicOpEnabled) {
#line 31780
    gl_logicop_ci_span(ctx, n, x, y, index___0, mask);
  }
#line 31782
  if (ctx->Color.SWmasking) {
#line 31783
    gl_mask_index_span(ctx, n, x, y, index___0);
  }
#line 31785
  (*(ctx->Driver.WriteIndexSpan))(ctx, n, x, y, (GLuint const   *)index___0, (GLubyte const   *)(mask));
#line 31786
  if (ctx->RasterMask & 1024U) {
#line 31787
    (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 31788
    memcpy((void *)index___0, (void const   *)((void *)(index_save)), n * sizeof(GLuint ));
#line 31789
    if (ctx->Color.SWLogicOpEnabled) {
#line 31790
      gl_logicop_ci_span(ctx, n, x, y, index___0, mask);
    }
#line 31792
    if (ctx->Color.SWmasking) {
#line 31793
      gl_mask_index_span(ctx, n, x, y, index___0);
    }
#line 31795
    (*(ctx->Driver.WriteIndexSpan))(ctx, n, x, y, (GLuint const   *)index___0, (GLubyte const   *)(mask));
#line 31796
    (*(ctx->Driver.SetBuffer))(ctx, 1028);
  }
#line 31798
  return;
}
}
#line 31799 "D:/a/test/177.c"
void gl_write_monoindex_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth *z ,
                             GLuint index___0 , GLenum primitive ) 
{ GLuint i ;
  GLubyte mask[640] ;
  GLuint index_save[640] ;
  GLuint tmp___0 ;
  GLint tmp___1 ;
  int tmp___2 ;
  GLuint tmp___3 ;
  GLuint ispan[640] ;

  {
#line 31806
  memset((void *)(mask), 1, n);
#line 31807
  if (ctx->RasterMask & 512U) {
    goto _L;
  } else {
#line 31807
    if (primitive == 6656) {
      _L: /* CIL Label */ 
#line 31808
      tmp___0 = clip_span(ctx, (int )n, x, y, mask);
#line 31808
      if (tmp___0 == 0U) {
#line 31809
        return;
      }
    }
  }
#line 31812
  if (ctx->Scissor.Enabled) {
#line 31813
    tmp___1 = gl_scissor_span(ctx, n, x, y, mask);
#line 31813
    if (tmp___1 == 0) {
#line 31814
      return;
    }
  }
#line 31817
  if (ctx->Polygon.StippleFlag) {
#line 31817
    if (primitive == 9) {
#line 31818
      stipple_polygon_span(ctx, n, x, y, mask);
    }
  }
#line 31820
  if (ctx->Stencil.Enabled) {
#line 31821
    tmp___2 = gl_stencil_span(ctx, n, x, y, mask);
#line 31821
    if (tmp___2 == 0) {
#line 31822
      return;
    }
#line 31824
    gl_depth_stencil_span(ctx, n, x, y, z, mask);
  } else {
#line 31826
    if (ctx->Depth.Test) {
#line 31827
      tmp___3 = (*(ctx->Driver.DepthTestSpan))(ctx, n, x, y, (GLdepth const   *)z,
                                               mask);
#line 31827
      if (tmp___3 == 0U) {
#line 31827
        return;
      }
    }
  }
#line 31829
  if (ctx->RasterMask & 2048U) {
#line 31830
    return;
  }
#line 31832
  if (ctx->Fog.Enabled) {
#line 31832
    if (ctx->Hint.Fog == 4354) {
      goto _L___0;
    } else {
#line 31832
      if (primitive == 6656) {
        goto _L___0;
      } else {
        goto _L___1;
      }
    }
  } else {
    _L___1: /* CIL Label */ 
#line 31832
    if (ctx->Color.SWLogicOpEnabled) {
      goto _L___0;
    } else {
#line 31832
      if (ctx->Color.SWmasking) {
        _L___0: /* CIL Label */ 
#line 31835
        i = 0U;
#line 31835
        while (i < n) {
#line 31836
          ispan[i] = index___0;
#line 31835
          i ++;
        }
#line 31838
        if (ctx->Fog.Enabled) {
#line 31838
          if (ctx->Hint.Fog == 4354) {
#line 31840
            gl_fog_index_pixels(ctx, n, (GLdepth const   *)z, ispan);
          } else {
#line 31838
            if (primitive == 6656) {
#line 31840
              gl_fog_index_pixels(ctx, n, (GLdepth const   *)z, ispan);
            }
          }
        }
#line 31842
        if (ctx->RasterMask & 1024U) {
#line 31843
          memcpy((void *)(index_save), (void const   *)((void *)index___0), n * sizeof(GLuint ));
        }
#line 31845
        if (ctx->Color.SWLogicOpEnabled) {
#line 31846
          gl_logicop_ci_span(ctx, n, x, y, ispan, mask);
        }
#line 31848
        if (ctx->Color.SWmasking) {
#line 31849
          gl_mask_index_span(ctx, n, x, y, ispan);
        }
#line 31851
        (*(ctx->Driver.WriteIndexSpan))(ctx, n, x, y, (GLuint const   *)(ispan), (GLubyte const   *)(mask));
#line 31852
        if (ctx->RasterMask & 1024U) {
#line 31853
          (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 31854
          i = 0U;
#line 31854
          while (i < n) {
#line 31855
            ispan[i] = index___0;
#line 31854
            i ++;
          }
#line 31857
          if (ctx->Color.SWLogicOpEnabled) {
#line 31858
            gl_logicop_ci_span(ctx, n, x, y, ispan, mask);
          }
#line 31860
          if (ctx->Color.SWmasking) {
#line 31861
            gl_mask_index_span(ctx, n, x, y, ispan);
          }
#line 31863
          (*(ctx->Driver.WriteIndexSpan))(ctx, n, x, y, (GLuint const   *)(ispan),
                                          (GLubyte const   *)(mask));
#line 31864
          (*(ctx->Driver.SetBuffer))(ctx, 1028);
        }
      } else {
#line 31868
        (*(ctx->Driver.WriteMonoindexSpan))(ctx, n, x, y, (GLubyte const   *)(mask));
#line 31869
        if (ctx->RasterMask & 1024U) {
#line 31870
          (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 31871
          (*(ctx->Driver.WriteMonoindexSpan))(ctx, n, x, y, (GLubyte const   *)(mask));
#line 31872
          (*(ctx->Driver.SetBuffer))(ctx, 1028);
        }
      }
    }
  }
#line 31875
  return;
}
}
#line 31876 "D:/a/test/177.c"
void gl_write_color_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth *z ,
                         GLubyte *r , GLubyte *g , GLubyte *b , GLubyte *a , GLenum primitive ) 
{ GLubyte mask[640] ;
  GLboolean write_all ;
  GLubyte rtmp[640] ;
  GLubyte gtmp[640] ;
  GLubyte btmp[640] ;
  GLubyte atmp[640] ;
  GLubyte *red ;
  GLubyte *green ;
  GLubyte *blue___0 ;
  GLubyte *alpha ;
  GLuint tmp___0 ;
  GLint tmp___1 ;
  GLint tmp___2 ;
  int tmp___3 ;
  GLuint m ;
  GLuint tmp___4 ;
  GLubyte *tmp___5 ;
  GLubyte *tmp___6 ;
  GLubyte *tmp___7 ;
  GLubyte *tmp___8 ;

  {
#line 31883
  write_all = (GLboolean )1;
#line 31886
  memset((void *)(mask), 1, n);
#line 31887
  if (ctx->RasterMask & 512U) {
    goto _L;
  } else {
#line 31887
    if (primitive == 6656) {
      _L: /* CIL Label */ 
#line 31888
      tmp___0 = clip_span(ctx, (int )n, x, y, mask);
#line 31888
      if (tmp___0 == 0U) {
#line 31889
        return;
      }
#line 31891
      write_all = (unsigned char)0;
    }
  }
#line 31893
  if (primitive == 6656) {
#line 31893
    if (ctx->MutablePixels) {
      goto _L___0;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 31893
    if (ctx->RasterMask & 1024U) {
      _L___0: /* CIL Label */ 
#line 31895
      memcpy((void *)(rtmp), (void const   *)((void *)r), n * sizeof(GLubyte ));
#line 31896
      memcpy((void *)(gtmp), (void const   *)((void *)g), n * sizeof(GLubyte ));
#line 31897
      memcpy((void *)(btmp), (void const   *)((void *)b), n * sizeof(GLubyte ));
#line 31898
      memcpy((void *)(atmp), (void const   *)((void *)a), n * sizeof(GLubyte ));
#line 31899
      red = rtmp;
#line 31900
      green = gtmp;
#line 31901
      blue___0 = btmp;
#line 31902
      alpha = atmp;
    } else {
#line 31905
      red = r;
#line 31906
      green = g;
#line 31907
      blue___0 = b;
#line 31908
      alpha = a;
    }
  }
#line 31910
  if (ctx->Fog.Enabled) {
#line 31910
    if (ctx->Hint.Fog == 4354) {
#line 31912
      gl_fog_color_pixels(ctx, n, (GLdepth const   *)z, red, green, blue___0, alpha);
    } else {
#line 31910
      if (primitive == 6656) {
#line 31912
        gl_fog_color_pixels(ctx, n, (GLdepth const   *)z, red, green, blue___0, alpha);
      } else {
#line 31910
        if (ctx->Texture.Enabled) {
#line 31912
          gl_fog_color_pixels(ctx, n, (GLdepth const   *)z, red, green, blue___0,
                              alpha);
        }
      }
    }
  }
#line 31914
  if (ctx->Scissor.Enabled) {
#line 31915
    tmp___1 = gl_scissor_span(ctx, n, x, y, mask);
#line 31915
    if (tmp___1 == 0) {
#line 31916
      return;
    }
#line 31918
    write_all = (unsigned char)0;
  }
#line 31920
  if (ctx->Polygon.StippleFlag) {
#line 31920
    if (primitive == 9) {
#line 31921
      stipple_polygon_span(ctx, n, x, y, mask);
#line 31922
      write_all = (unsigned char)0;
    }
  }
#line 31924
  if (ctx->Color.AlphaEnabled) {
#line 31925
    tmp___2 = gl_alpha_test(ctx, n, (GLubyte const   *)alpha, mask);
#line 31925
    if (tmp___2 == 0) {
#line 31926
      return;
    }
#line 31928
    write_all = (unsigned char)0;
  }
#line 31930
  if (ctx->Stencil.Enabled) {
#line 31931
    tmp___3 = gl_stencil_span(ctx, n, x, y, mask);
#line 31931
    if (tmp___3 == 0) {
#line 31932
      return;
    }
#line 31934
    gl_depth_stencil_span(ctx, n, x, y, z, mask);
#line 31935
    write_all = (unsigned char)0;
  } else {
#line 31937
    if (ctx->Depth.Test) {
#line 31938
      tmp___4 = (*(ctx->Driver.DepthTestSpan))(ctx, n, x, y, (GLdepth const   *)z,
                                               mask);
#line 31938
      m = tmp___4;
#line 31939
      if (m == 0U) {
#line 31940
        return;
      }
#line 31942
      if (m < n) {
#line 31943
        write_all = (unsigned char)0;
      }
    }
  }
#line 31946
  if (ctx->RasterMask & 2048U) {
#line 31947
    return;
  }
#line 31949
  if (ctx->Color.SWLogicOpEnabled) {
#line 31950
    gl_logicop_rgba_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
  } else {
#line 31952
    if (ctx->Color.BlendEnabled) {
#line 31953
      gl_blend_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
    }
  }
#line 31955
  if (ctx->Color.SWmasking) {
#line 31956
    gl_mask_color_span(ctx, n, x, y, red, green, blue___0, alpha);
  }
#line 31958
  if (write_all) {
#line 31958
    tmp___5 = (GLubyte *)((void *)0);
  } else {
#line 31958
    tmp___5 = mask;
  }
#line 31958
  (*(ctx->Driver.WriteColorSpan))(ctx, n, x, y, (GLubyte const   *)red, (GLubyte const   *)green,
                                  (GLubyte const   *)blue___0, (GLubyte const   *)alpha,
                                  (GLubyte const   *)tmp___5);
#line 31960
  if (ctx->RasterMask & 256U) {
#line 31961
    if (write_all) {
#line 31961
      tmp___6 = (GLubyte *)((void *)0);
    } else {
#line 31961
      tmp___6 = mask;
    }
#line 31961
    gl_write_alpha_span(ctx, n, x, y, alpha, tmp___6);
  }
#line 31963
  if (ctx->RasterMask & 1024U) {
#line 31964
    memcpy((void *)(rtmp), (void const   *)((void *)r), n * sizeof(GLubyte ));
#line 31965
    memcpy((void *)(gtmp), (void const   *)((void *)g), n * sizeof(GLubyte ));
#line 31966
    memcpy((void *)(btmp), (void const   *)((void *)b), n * sizeof(GLubyte ));
#line 31967
    memcpy((void *)(atmp), (void const   *)((void *)a), n * sizeof(GLubyte ));
#line 31968
    (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 31969
    if (ctx->Color.SWLogicOpEnabled) {
#line 31970
      gl_logicop_rgba_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
    } else {
#line 31972
      if (ctx->Color.BlendEnabled) {
#line 31973
        gl_blend_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
      }
    }
#line 31975
    if (ctx->Color.SWmasking) {
#line 31976
      gl_mask_color_span(ctx, n, x, y, red, green, blue___0, alpha);
    }
#line 31978
    if (write_all) {
#line 31978
      tmp___7 = (GLubyte *)((void *)0);
    } else {
#line 31978
      tmp___7 = mask;
    }
#line 31978
    (*(ctx->Driver.WriteColorSpan))(ctx, n, x, y, (GLubyte const   *)red, (GLubyte const   *)green,
                                    (GLubyte const   *)blue___0, (GLubyte const   *)alpha,
                                    (GLubyte const   *)tmp___7);
#line 31980
    if (ctx->RasterMask & 256U) {
#line 31981
      (ctx->Buffer)->Alpha = (ctx->Buffer)->BackAlpha;
#line 31982
      if (write_all) {
#line 31982
        tmp___8 = (GLubyte *)((void *)0);
      } else {
#line 31982
        tmp___8 = mask;
      }
#line 31982
      gl_write_alpha_span(ctx, n, x, y, alpha, tmp___8);
#line 31983
      (ctx->Buffer)->Alpha = (ctx->Buffer)->FrontAlpha;
    }
#line 31985
    (*(ctx->Driver.SetBuffer))(ctx, 1028);
  }
#line 31987
  return;
}
}
#line 31988 "D:/a/test/177.c"
void gl_write_monocolor_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth *z ,
                             GLint r , GLint g , GLint b , GLint a , GLenum primitive ) 
{ GLuint i ;
  GLubyte mask[640] ;
  GLboolean write_all ;
  GLubyte red[640] ;
  GLubyte green[640] ;
  GLubyte blue___0[640] ;
  GLubyte alpha[640] ;
  GLuint tmp___0 ;
  GLint tmp___1 ;
  GLubyte alpha___0[640] ;
  GLint tmp___2 ;
  int tmp___3 ;
  GLuint m ;
  GLuint tmp___4 ;
  GLubyte *tmp___5 ;
  GLubyte *tmp___6 ;
  GLubyte *tmp___7 ;
  GLubyte *tmp___8 ;
  GLubyte *tmp___9 ;
  GLubyte *tmp___10 ;

  {
#line 31995
  write_all = (GLboolean )1;
#line 31997
  memset((void *)(mask), 1, n);
#line 31998
  if (ctx->RasterMask & 512U) {
    goto _L;
  } else {
#line 31998
    if (primitive == 6656) {
      _L: /* CIL Label */ 
#line 31999
      tmp___0 = clip_span(ctx, (int )n, x, y, mask);
#line 31999
      if (tmp___0 == 0U) {
#line 32000
        return;
      }
#line 32002
      write_all = (unsigned char)0;
    }
  }
#line 32004
  if (ctx->Scissor.Enabled) {
#line 32005
    tmp___1 = gl_scissor_span(ctx, n, x, y, mask);
#line 32005
    if (tmp___1 == 0) {
#line 32006
      return;
    }
#line 32008
    write_all = (unsigned char)0;
  }
#line 32010
  if (ctx->Polygon.StippleFlag) {
#line 32010
    if (primitive == 9) {
#line 32011
      stipple_polygon_span(ctx, n, x, y, mask);
#line 32012
      write_all = (unsigned char)0;
    }
  }
#line 32014
  if (ctx->Color.AlphaEnabled) {
#line 32016
    i = 0U;
#line 32016
    while (i < n) {
#line 32017
      alpha___0[i] = (unsigned char )a;
#line 32016
      i ++;
    }
#line 32019
    tmp___2 = gl_alpha_test(ctx, n, (GLubyte const   *)(alpha___0), mask);
#line 32019
    if (tmp___2 == 0) {
#line 32020
      return;
    }
#line 32022
    write_all = (unsigned char)0;
  }
#line 32024
  if (ctx->Stencil.Enabled) {
#line 32025
    tmp___3 = gl_stencil_span(ctx, n, x, y, mask);
#line 32025
    if (tmp___3 == 0) {
#line 32026
      return;
    }
#line 32028
    gl_depth_stencil_span(ctx, n, x, y, z, mask);
#line 32029
    write_all = (unsigned char)0;
  } else {
#line 32031
    if (ctx->Depth.Test) {
#line 32032
      tmp___4 = (*(ctx->Driver.DepthTestSpan))(ctx, n, x, y, (GLdepth const   *)z,
                                               mask);
#line 32032
      m = tmp___4;
#line 32033
      if (m == 0U) {
#line 32034
        return;
      }
#line 32036
      if (m < n) {
#line 32037
        write_all = (unsigned char)0;
      }
    }
  }
#line 32040
  if (ctx->RasterMask & 2048U) {
#line 32041
    return;
  }
#line 32043
  if (ctx->Color.BlendEnabled) {
    goto _L___0;
  } else {
#line 32043
    if (ctx->Color.SWLogicOpEnabled) {
      goto _L___0;
    } else {
#line 32043
      if (ctx->Color.SWmasking) {
        _L___0: /* CIL Label */ 
#line 32045
        i = 0U;
#line 32045
        while (i < n) {
#line 32046
          if (mask[i]) {
#line 32047
            red[i] = (unsigned char )r;
#line 32048
            green[i] = (unsigned char )g;
#line 32049
            blue___0[i] = (unsigned char )b;
#line 32050
            alpha[i] = (unsigned char )a;
          }
#line 32045
          i ++;
        }
#line 32053
        if (ctx->Color.SWLogicOpEnabled) {
#line 32054
          gl_logicop_rgba_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
        } else {
#line 32056
          if (ctx->Color.BlendEnabled) {
#line 32057
            gl_blend_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
          }
        }
#line 32059
        if (ctx->Color.SWmasking) {
#line 32060
          gl_mask_color_span(ctx, n, x, y, red, green, blue___0, alpha);
        }
#line 32062
        if (write_all) {
#line 32062
          tmp___5 = (GLubyte *)((void *)0);
        } else {
#line 32062
          tmp___5 = mask;
        }
#line 32062
        (*(ctx->Driver.WriteColorSpan))(ctx, n, x, y, (GLubyte const   *)(red), (GLubyte const   *)(green),
                                        (GLubyte const   *)(blue___0), (GLubyte const   *)(alpha),
                                        (GLubyte const   *)tmp___5);
#line 32064
        if (ctx->RasterMask & 256U) {
#line 32065
          if (write_all) {
#line 32065
            tmp___6 = (GLubyte *)((void *)0);
          } else {
#line 32065
            tmp___6 = mask;
          }
#line 32065
          gl_write_alpha_span(ctx, n, x, y, alpha, tmp___6);
        }
#line 32067
        if (ctx->RasterMask & 1024U) {
#line 32068
          i = 0U;
#line 32068
          while (i < n) {
#line 32069
            if (mask[i]) {
#line 32070
              red[i] = (unsigned char )r;
#line 32071
              green[i] = (unsigned char )g;
#line 32072
              blue___0[i] = (unsigned char )b;
#line 32073
              alpha[i] = (unsigned char )a;
            }
#line 32068
            i ++;
          }
#line 32076
          (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 32077
          if (ctx->Color.SWLogicOpEnabled) {
#line 32078
            gl_logicop_rgba_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
          } else {
#line 32080
            if (ctx->Color.BlendEnabled) {
#line 32081
              gl_blend_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
            }
          }
#line 32083
          if (ctx->Color.SWmasking) {
#line 32084
            gl_mask_color_span(ctx, n, x, y, red, green, blue___0, alpha);
          }
#line 32086
          if (write_all) {
#line 32086
            tmp___7 = (GLubyte *)((void *)0);
          } else {
#line 32086
            tmp___7 = mask;
          }
#line 32086
          (*(ctx->Driver.WriteColorSpan))(ctx, n, x, y, (GLubyte const   *)(red),
                                          (GLubyte const   *)(green), (GLubyte const   *)(blue___0),
                                          (GLubyte const   *)(alpha), (GLubyte const   *)tmp___7);
#line 32088
          (*(ctx->Driver.SetBuffer))(ctx, 1028);
#line 32089
          if (ctx->RasterMask & 256U) {
#line 32090
            (ctx->Buffer)->Alpha = (ctx->Buffer)->BackAlpha;
#line 32091
            if (write_all) {
#line 32091
              tmp___8 = (GLubyte *)((void *)0);
            } else {
#line 32091
              tmp___8 = mask;
            }
#line 32091
            gl_write_alpha_span(ctx, n, x, y, alpha, tmp___8);
#line 32093
            (ctx->Buffer)->Alpha = (ctx->Buffer)->FrontAlpha;
          }
        }
      } else {
#line 32098
        (*(ctx->Driver.WriteMonocolorSpan))(ctx, n, x, y, (GLubyte const   *)(mask));
#line 32099
        if (ctx->RasterMask & 256U) {
#line 32100
          if (write_all) {
#line 32100
            tmp___9 = (GLubyte *)((void *)0);
          } else {
#line 32100
            tmp___9 = mask;
          }
#line 32100
          gl_write_mono_alpha_span(ctx, n, x, y, (unsigned char )a, tmp___9);
        }
#line 32102
        if (ctx->RasterMask & 1024U) {
#line 32103
          (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 32104
          (*(ctx->Driver.WriteMonocolorSpan))(ctx, n, x, y, (GLubyte const   *)(mask));
#line 32105
          (*(ctx->Driver.SetBuffer))(ctx, 1028);
#line 32106
          if (ctx->RasterMask & 256U) {
#line 32107
            (ctx->Buffer)->Alpha = (ctx->Buffer)->BackAlpha;
#line 32108
            if (write_all) {
#line 32108
              tmp___10 = (GLubyte *)((void *)0);
            } else {
#line 32108
              tmp___10 = mask;
            }
#line 32108
            gl_write_mono_alpha_span(ctx, n, x, y, (unsigned char )a, tmp___10);
#line 32110
            (ctx->Buffer)->Alpha = (ctx->Buffer)->FrontAlpha;
          }
        }
      }
    }
  }
#line 32114
  return;
}
}
#line 32115 "D:/a/test/177.c"
void gl_write_texture_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth *z ,
                           float *s , float *t , float *u , float *lambda , GLubyte *r ,
                           GLubyte *g , GLubyte *b , GLubyte *a , GLenum primitive ) 
{ GLubyte mask[640] ;
  GLboolean write_all ;
  GLubyte rtmp[640] ;
  GLubyte gtmp[640] ;
  GLubyte btmp[640] ;
  GLubyte atmp[640] ;
  GLubyte *red ;
  GLubyte *green ;
  GLubyte *blue___0 ;
  GLubyte *alpha ;
  GLuint tmp___0 ;
  GLint tmp___1 ;
  GLint tmp___2 ;
  int tmp___3 ;
  GLuint m ;
  GLuint tmp___4 ;
  GLubyte *tmp___5 ;
  GLubyte *tmp___6 ;
  GLubyte *tmp___7 ;
  GLubyte *tmp___8 ;

  {
#line 32124
  write_all = (GLboolean )1;
#line 32127
  memset((void *)(mask), 1, n);
#line 32128
  if (ctx->RasterMask & 512U) {
    goto _L;
  } else {
#line 32128
    if (primitive == 6656) {
      _L: /* CIL Label */ 
#line 32129
      tmp___0 = clip_span(ctx, (int )n, x, y, mask);
#line 32129
      if (tmp___0 == 0U) {
#line 32130
        return;
      }
#line 32132
      write_all = (unsigned char)0;
    }
  }
#line 32134
  if (primitive == 6656) {
    goto _L___0;
  } else {
#line 32134
    if (ctx->RasterMask & 1024U) {
      _L___0: /* CIL Label */ 
#line 32135
      memcpy((void *)(rtmp), (void const   *)((void *)r), n * sizeof(GLubyte ));
#line 32136
      memcpy((void *)(gtmp), (void const   *)((void *)g), n * sizeof(GLubyte ));
#line 32137
      memcpy((void *)(btmp), (void const   *)((void *)b), n * sizeof(GLubyte ));
#line 32138
      memcpy((void *)(atmp), (void const   *)((void *)a), n * sizeof(GLubyte ));
#line 32139
      red = rtmp;
#line 32140
      green = gtmp;
#line 32141
      blue___0 = btmp;
#line 32142
      alpha = atmp;
    } else {
#line 32145
      red = r;
#line 32146
      green = g;
#line 32147
      blue___0 = b;
#line 32148
      alpha = a;
    }
  }
#line 32151
  gl_texture_pixels(ctx, n, s, t, u, lambda, red, green, blue___0, alpha);
#line 32152
  if (ctx->Fog.Enabled) {
#line 32152
    if (ctx->Hint.Fog == 4354) {
#line 32154
      gl_fog_color_pixels(ctx, n, (GLdepth const   *)z, red, green, blue___0, alpha);
    } else {
#line 32152
      if (primitive == 6656) {
#line 32154
        gl_fog_color_pixels(ctx, n, (GLdepth const   *)z, red, green, blue___0, alpha);
      } else {
#line 32152
        if (ctx->Texture.Enabled) {
#line 32154
          gl_fog_color_pixels(ctx, n, (GLdepth const   *)z, red, green, blue___0,
                              alpha);
        }
      }
    }
  }
#line 32156
  if (ctx->Scissor.Enabled) {
#line 32157
    tmp___1 = gl_scissor_span(ctx, n, x, y, mask);
#line 32157
    if (tmp___1 == 0) {
#line 32158
      return;
    }
#line 32160
    write_all = (unsigned char)0;
  }
#line 32162
  if (ctx->Polygon.StippleFlag) {
#line 32162
    if (primitive == 9) {
#line 32163
      stipple_polygon_span(ctx, n, x, y, mask);
#line 32164
      write_all = (unsigned char)0;
    }
  }
#line 32166
  if (ctx->Color.AlphaEnabled) {
#line 32167
    tmp___2 = gl_alpha_test(ctx, n, (GLubyte const   *)alpha, mask);
#line 32167
    if (tmp___2 == 0) {
#line 32168
      return;
    }
#line 32170
    write_all = (unsigned char)0;
  }
#line 32172
  if (ctx->Stencil.Enabled) {
#line 32173
    tmp___3 = gl_stencil_span(ctx, n, x, y, mask);
#line 32173
    if (tmp___3 == 0) {
#line 32174
      return;
    }
#line 32176
    gl_depth_stencil_span(ctx, n, x, y, z, mask);
#line 32177
    write_all = (unsigned char)0;
  } else {
#line 32179
    if (ctx->Depth.Test) {
#line 32180
      tmp___4 = (*(ctx->Driver.DepthTestSpan))(ctx, n, x, y, (GLdepth const   *)z,
                                               mask);
#line 32180
      m = tmp___4;
#line 32181
      if (m == 0U) {
#line 32182
        return;
      }
#line 32184
      if (m < n) {
#line 32185
        write_all = (unsigned char)0;
      }
    }
  }
#line 32188
  if (ctx->RasterMask & 2048U) {
#line 32189
    return;
  }
#line 32191
  if (ctx->Color.SWLogicOpEnabled) {
#line 32192
    gl_logicop_rgba_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
  } else {
#line 32194
    if (ctx->Color.BlendEnabled) {
#line 32195
      gl_blend_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
    }
  }
#line 32197
  if (ctx->Color.SWmasking) {
#line 32198
    gl_mask_color_span(ctx, n, x, y, red, green, blue___0, alpha);
  }
#line 32200
  if (write_all) {
#line 32200
    tmp___5 = (GLubyte *)((void *)0);
  } else {
#line 32200
    tmp___5 = mask;
  }
#line 32200
  (*(ctx->Driver.WriteColorSpan))(ctx, n, x, y, (GLubyte const   *)red, (GLubyte const   *)green,
                                  (GLubyte const   *)blue___0, (GLubyte const   *)alpha,
                                  (GLubyte const   *)tmp___5);
#line 32202
  if (ctx->RasterMask & 256U) {
#line 32203
    if (write_all) {
#line 32203
      tmp___6 = (GLubyte *)((void *)0);
    } else {
#line 32203
      tmp___6 = mask;
    }
#line 32203
    gl_write_alpha_span(ctx, n, x, y, alpha, tmp___6);
  }
#line 32205
  if (ctx->RasterMask & 1024U) {
#line 32206
    memcpy((void *)(rtmp), (void const   *)((void *)r), n * sizeof(GLubyte ));
#line 32207
    memcpy((void *)(gtmp), (void const   *)((void *)g), n * sizeof(GLubyte ));
#line 32208
    memcpy((void *)(btmp), (void const   *)((void *)b), n * sizeof(GLubyte ));
#line 32209
    memcpy((void *)(atmp), (void const   *)((void *)a), n * sizeof(GLubyte ));
#line 32210
    (*(ctx->Driver.SetBuffer))(ctx, 1029);
#line 32211
    if (ctx->Color.SWLogicOpEnabled) {
#line 32212
      gl_logicop_rgba_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
    } else {
#line 32214
      if (ctx->Color.BlendEnabled) {
#line 32215
        gl_blend_span(ctx, n, x, y, red, green, blue___0, alpha, mask);
      }
    }
#line 32217
    if (ctx->Color.SWmasking) {
#line 32218
      gl_mask_color_span(ctx, n, x, y, red, green, blue___0, alpha);
    }
#line 32220
    if (write_all) {
#line 32220
      tmp___7 = (GLubyte *)((void *)0);
    } else {
#line 32220
      tmp___7 = mask;
    }
#line 32220
    (*(ctx->Driver.WriteColorSpan))(ctx, n, x, y, (GLubyte const   *)red, (GLubyte const   *)green,
                                    (GLubyte const   *)blue___0, (GLubyte const   *)alpha,
                                    (GLubyte const   *)tmp___7);
#line 32222
    (*(ctx->Driver.SetBuffer))(ctx, 1028);
#line 32223
    if (ctx->RasterMask & 256U) {
#line 32224
      (ctx->Buffer)->Alpha = (ctx->Buffer)->BackAlpha;
#line 32225
      if (write_all) {
#line 32225
        tmp___8 = (GLubyte *)((void *)0);
      } else {
#line 32225
        tmp___8 = mask;
      }
#line 32225
      gl_write_alpha_span(ctx, n, x, y, alpha, tmp___8);
#line 32226
      (ctx->Buffer)->Alpha = (ctx->Buffer)->FrontAlpha;
    }
  }
#line 32229
  return;
}
}
#line 32230 "D:/a/test/177.c"
void gl_read_color_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *red ,
                        GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ register GLuint i ;
  GLubyte tmp___0 ;
  GLubyte tmp___1 ;
  GLubyte tmp___2 ;
  GLubyte tmp___3 ;
  GLubyte tmp___4 ;
  GLubyte tmp___5 ;

  {
#line 32236
  if (y < 0) {
    goto _L___0;
  } else {
#line 32236
    if (y >= (ctx->Buffer)->Height) {
      goto _L___0;
    } else {
#line 32236
      if (x >= (ctx->Buffer)->Width) {
        _L___0: /* CIL Label */ 
#line 32237
        i = 0U;
#line 32237
        while (i < n) {
#line 32238
          tmp___2 = (unsigned char)0;
#line 32238
          *(alpha + i) = tmp___2;
#line 32238
          tmp___1 = tmp___2;
#line 32238
          *(blue___0 + i) = tmp___1;
#line 32238
          tmp___0 = tmp___1;
#line 32238
          *(green + i) = tmp___0;
#line 32238
          *(red + i) = tmp___0;
#line 32237
          i ++;
        }
      } else {
#line 32242
        if (x >= 0) {
#line 32242
          if ((GLuint )x + n <= (GLuint )(ctx->Buffer)->Width) {
#line 32244
            (*(ctx->Driver.ReadColorSpan))(ctx, n, x, y, red, green, blue___0, alpha);
#line 32245
            if (ctx->RasterMask & 256U) {
#line 32246
              gl_read_alpha_span(ctx, n, x, y, alpha);
            }
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 32250
          i = 0U;
#line 32251
          if (x < 0) {
#line 32252
            while (1) {
#line 32252
              if (x < 0) {
#line 32252
                if (! (n > 0U)) {
#line 32252
                  break;
                }
              } else {
#line 32252
                break;
              }
#line 32253
              tmp___5 = (unsigned char)0;
#line 32253
              *(alpha + i) = tmp___5;
#line 32253
              tmp___4 = tmp___5;
#line 32253
              *(blue___0 + i) = tmp___4;
#line 32253
              tmp___3 = tmp___4;
#line 32253
              *(green + i) = tmp___3;
#line 32253
              *(red + i) = tmp___3;
#line 32254
              x ++;
#line 32255
              n --;
#line 32256
              i ++;
            }
          }
#line 32259
          if (n < (GLuint )((ctx->Buffer)->Width - x)) {
#line 32259
            n = n;
          } else {
#line 32259
            n = (unsigned int )((ctx->Buffer)->Width - x);
          }
#line 32260
          (*(ctx->Driver.ReadColorSpan))(ctx, n, x, y, red + i, green + i, blue___0 + i,
                                         alpha + i);
#line 32261
          if (ctx->RasterMask & 256U) {
#line 32262
            gl_read_alpha_span(ctx, n, x, y, alpha + i);
          }
        }
      }
    }
  }
#line 32266
  return;
}
}
#line 32267 "D:/a/test/177.c"
void gl_read_index_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLuint *indx ) 
{ register GLuint i ;

  {
#line 32271
  if (y < 0) {
    goto _L___0;
  } else {
#line 32271
    if (y >= (ctx->Buffer)->Height) {
      goto _L___0;
    } else {
#line 32271
      if (x >= (ctx->Buffer)->Width) {
        _L___0: /* CIL Label */ 
#line 32272
        i = 0U;
#line 32272
        while (i < n) {
#line 32273
          *(indx + i) = 0U;
#line 32272
          i ++;
        }
      } else {
#line 32277
        if (x >= 0) {
#line 32277
          if ((GLuint )x + n <= (GLuint )(ctx->Buffer)->Width) {
#line 32279
            (*(ctx->Driver.ReadIndexSpan))(ctx, n, x, y, indx);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 32282
          i = 0U;
#line 32283
          if (x < 0) {
#line 32284
            while (1) {
#line 32284
              if (x < 0) {
#line 32284
                if (! (n > 0U)) {
#line 32284
                  break;
                }
              } else {
#line 32284
                break;
              }
#line 32285
              *(indx + i) = 0U;
#line 32286
              x ++;
#line 32287
              n --;
#line 32288
              i ++;
            }
          }
#line 32291
          if (n < (GLuint )((ctx->Buffer)->Width - x)) {
#line 32291
            n = n;
          } else {
#line 32291
            n = (unsigned int )((ctx->Buffer)->Width - x);
          }
#line 32292
          (*(ctx->Driver.ReadIndexSpan))(ctx, n, x, y, indx + i);
        }
      }
    }
  }
#line 32295
  return;
}
}
#line 32302 "D:/a/test/177.c"
void gl_ClearStencil(GLcontext *ctx , GLint s ) 
{ 

  {
#line 32304
  if (ctx->Primitive != 6656) {
#line 32305
    gl_error(ctx, 1282, "glClearStencil");
#line 32306
    return;
  }
#line 32308
  ctx->Stencil.Clear = (unsigned char )s;
#line 32309
  return;
}
}
#line 32310 "D:/a/test/177.c"
void gl_StencilFunc(GLcontext *ctx , GLenum func , GLint ref , GLuint mask ) 
{ GLint maxref ;
  GLint tmp___0 ;

  {
#line 32313
  if (ctx->Primitive != 6656) {
#line 32314
    gl_error(ctx, 1282, "glStencilFunc");
#line 32315
    return;
  }
#line 32317
  switch (func) {
  case 512: 
  case 513: 
  case 515: 
  case 516: 
  case 518: 
  case 514: 
  case 517: 
  case 519: 
#line 32326
  ctx->Stencil.Function = func;
#line 32327
  break;
  default: 
#line 32329
  gl_error(ctx, 1280, "glStencilFunc");
#line 32330
  return;
  }
#line 32332
  maxref = (1 << 8) - 1;
#line 32333
  if (ref < 0) {
#line 32333
    ctx->Stencil.Ref = (unsigned char)0;
  } else {
#line 32333
    if (ref > maxref) {
#line 32333
      tmp___0 = maxref;
    } else {
#line 32333
      tmp___0 = ref;
    }
#line 32333
    ctx->Stencil.Ref = (unsigned char )tmp___0;
  }
#line 32334
  ctx->Stencil.ValueMask = (unsigned char )mask;
#line 32335
  return;
}
}
#line 32336 "D:/a/test/177.c"
void gl_StencilMask(GLcontext *ctx , GLuint mask ) 
{ 

  {
#line 32338
  if (ctx->Primitive != 6656) {
#line 32339
    gl_error(ctx, 1282, "glStencilMask");
#line 32340
    return;
  }
#line 32342
  ctx->Stencil.WriteMask = (unsigned char )mask;
#line 32343
  return;
}
}
#line 32344 "D:/a/test/177.c"
void gl_StencilOp(GLcontext *ctx , GLenum fail , GLenum zfail , GLenum zpass ) 
{ 

  {
#line 32346
  if (ctx->Primitive != 6656) {
#line 32347
    gl_error(ctx, 1282, "glStencilOp");
#line 32348
    return;
  }
#line 32350
  switch (fail) {
  case 7680: 
  case 0: 
  case 7681: 
  case 7682: 
  case 7683: 
  case 5386: 
#line 32357
  ctx->Stencil.FailFunc = fail;
#line 32358
  break;
  default: 
#line 32360
  gl_error(ctx, 1280, "glStencilOp");
#line 32361
  return;
  }
#line 32363
  switch (zfail) {
  case 7680: 
  case 0: 
  case 7681: 
  case 7682: 
  case 7683: 
  case 5386: 
#line 32370
  ctx->Stencil.ZFailFunc = zfail;
#line 32371
  break;
  default: 
#line 32373
  gl_error(ctx, 1280, "glStencilOp");
#line 32374
  return;
  }
#line 32376
  switch (zpass) {
  case 7680: 
  case 0: 
  case 7681: 
  case 7682: 
  case 7683: 
  case 5386: 
#line 32383
  ctx->Stencil.ZPassFunc = zpass;
#line 32384
  break;
  default: 
#line 32386
  gl_error(ctx, 1280, "glStencilOp");
#line 32387
  return;
  }
#line 32389
  return;
}
}
#line 32390 "D:/a/test/177.c"
static void apply_stencil_op_to_span(GLcontext *ctx , GLuint n , GLint x , GLint y ,
                                     GLenum oper , GLubyte *mask ) 
{ GLint i ;
  GLstencil s ;
  GLstencil ref ;
  GLstencil wrtmask ;
  GLstencil invmask ;
  GLstencil *stencil ;

  {
#line 32398
  wrtmask = ctx->Stencil.WriteMask;
#line 32399
  invmask = (unsigned char )(~ ((int )ctx->Stencil.WriteMask));
#line 32400
  ref = ctx->Stencil.Ref;
#line 32401
  stencil = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * y) + x;
#line 32402
  switch (oper) {
  case 7680: 
#line 32404
  break;
  case 0: 
#line 32406
  if ((int )invmask == 0) {
#line 32407
    i = 0;
#line 32407
    while ((GLuint )i < n) {
#line 32408
      if (*(mask + i)) {
#line 32409
        *(stencil + i) = (unsigned char)0;
      }
#line 32407
      i ++;
    }
  } else {
#line 32414
    i = 0;
#line 32414
    while ((GLuint )i < n) {
#line 32415
      if (*(mask + i)) {
#line 32416
        *(stencil + i) = (unsigned char )((int )*(stencil + i) & (int )invmask);
      }
#line 32414
      i ++;
    }
  }
#line 32420
  break;
  case 7681: 
#line 32422
  if ((int )invmask == 0) {
#line 32423
    i = 0;
#line 32423
    while ((GLuint )i < n) {
#line 32424
      if (*(mask + i)) {
#line 32425
        *(stencil + i) = ref;
      }
#line 32423
      i ++;
    }
  } else {
#line 32430
    i = 0;
#line 32430
    while ((GLuint )i < n) {
#line 32431
      if (*(mask + i)) {
#line 32432
        s = *(stencil + i);
#line 32433
        *(stencil + i) = (unsigned char )(((int )invmask & (int )s) | ((int )wrtmask & (int )ref));
      }
#line 32430
      i ++;
    }
  }
#line 32437
  break;
  case 7682: 
#line 32439
  if ((int )invmask == 0) {
#line 32440
    i = 0;
#line 32440
    while ((GLuint )i < n) {
#line 32441
      if (*(mask + i)) {
#line 32442
        s = *(stencil + i);
#line 32443
        if ((int )s < 255) {
#line 32444
          *(stencil + i) = (unsigned char )((int )s + 1);
        }
      }
#line 32440
      i ++;
    }
  } else {
#line 32450
    i = 0;
#line 32450
    while ((GLuint )i < n) {
#line 32451
      if (*(mask + i)) {
#line 32453
        s = *(stencil + i);
#line 32454
        if ((int )s < 255) {
#line 32455
          *(stencil + i) = (unsigned char )(((int )invmask & (int )s) | ((int )wrtmask & ((int )s + 1)));
        }
      }
#line 32450
      i ++;
    }
  }
#line 32460
  break;
  case 7683: 
#line 32462
  if ((int )invmask == 0) {
#line 32463
    i = 0;
#line 32463
    while ((GLuint )i < n) {
#line 32464
      if (*(mask + i)) {
#line 32465
        s = *(stencil + i);
#line 32466
        if ((int )s > 0) {
#line 32467
          *(stencil + i) = (unsigned char )((int )s - 1);
        }
      }
#line 32463
      i ++;
    }
  } else {
#line 32473
    i = 0;
#line 32473
    while ((GLuint )i < n) {
#line 32474
      if (*(mask + i)) {
#line 32476
        s = *(stencil + i);
#line 32477
        if ((int )s > 0) {
#line 32478
          *(stencil + i) = (unsigned char )(((int )invmask & (int )s) | ((int )wrtmask & ((int )s - 1)));
        }
      }
#line 32473
      i ++;
    }
  }
#line 32483
  break;
  case 5386: 
#line 32485
  if ((int )invmask == 0) {
#line 32486
    i = 0;
#line 32486
    while ((GLuint )i < n) {
#line 32487
      if (*(mask + i)) {
#line 32488
        s = *(stencil + i);
#line 32489
        *(stencil + i) = (unsigned char )(~ ((int )s));
      }
#line 32486
      i ++;
    }
  } else {
#line 32494
    i = 0;
#line 32494
    while ((GLuint )i < n) {
#line 32495
      if (*(mask + i)) {
#line 32496
        s = *(stencil + i);
#line 32497
        *(stencil + i) = (unsigned char )(((int )invmask & (int )s) | ((int )wrtmask & ~ ((int )s)));
      }
#line 32494
      i ++;
    }
  }
#line 32501
  break;
  default: 
#line 32503
  gl_problem((GLcontext const   *)ctx, "Bad stencilop in apply_stencil_op_to_span");
  }
#line 32505
  return;
}
}
#line 32506 "D:/a/test/177.c"
GLint gl_stencil_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *mask ) 
{ GLubyte fail[640] ;
  GLint allfail ;
  GLuint i ;
  GLstencil r ;
  GLstencil s ;
  GLstencil *stencil ;
  int tmp___0 ;

  {
#line 32510
  allfail = 0;
#line 32514
  stencil = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * y) + x;
#line 32515
  switch (ctx->Stencil.Function) {
  case 512: 
#line 32517
  i = 0U;
#line 32517
  while (i < n) {
#line 32518
    if (*(mask + i)) {
#line 32519
      *(mask + i) = (unsigned char)0;
#line 32520
      fail[i] = (unsigned char)1;
    } else {
#line 32523
      fail[i] = (unsigned char)0;
    }
#line 32517
    i ++;
  }
#line 32526
  allfail = 1;
#line 32527
  break;
  case 513: 
#line 32529
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32530
  i = 0U;
#line 32530
  while (i < n) {
#line 32531
    if (*(mask + i)) {
#line 32532
      s = (unsigned char )((int )*(stencil + i) & (int )ctx->Stencil.ValueMask);
#line 32533
      if ((int )r < (int )s) {
#line 32535
        fail[i] = (unsigned char)0;
      } else {
#line 32538
        fail[i] = (unsigned char)1;
#line 32539
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32543
      fail[i] = (unsigned char)0;
    }
#line 32530
    i ++;
  }
#line 32546
  break;
  case 515: 
#line 32548
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32549
  i = 0U;
#line 32549
  while (i < n) {
#line 32550
    if (*(mask + i)) {
#line 32551
      s = (unsigned char )((int )*(stencil + i) & (int )ctx->Stencil.ValueMask);
#line 32552
      if ((int )r <= (int )s) {
#line 32554
        fail[i] = (unsigned char)0;
      } else {
#line 32557
        fail[i] = (unsigned char)1;
#line 32558
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32562
      fail[i] = (unsigned char)0;
    }
#line 32549
    i ++;
  }
#line 32565
  break;
  case 516: 
#line 32567
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32568
  i = 0U;
#line 32568
  while (i < n) {
#line 32569
    if (*(mask + i)) {
#line 32570
      s = (unsigned char )((int )*(stencil + i) & (int )ctx->Stencil.ValueMask);
#line 32571
      if ((int )r > (int )s) {
#line 32573
        fail[i] = (unsigned char)0;
      } else {
#line 32576
        fail[i] = (unsigned char)1;
#line 32577
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32581
      fail[i] = (unsigned char)0;
    }
#line 32568
    i ++;
  }
#line 32584
  break;
  case 518: 
#line 32586
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32587
  i = 0U;
#line 32587
  while (i < n) {
#line 32588
    if (*(mask + i)) {
#line 32589
      s = (unsigned char )((int )*(stencil + i) & (int )ctx->Stencil.ValueMask);
#line 32590
      if ((int )r >= (int )s) {
#line 32592
        fail[i] = (unsigned char)0;
      } else {
#line 32595
        fail[i] = (unsigned char)1;
#line 32596
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32600
      fail[i] = (unsigned char)0;
    }
#line 32587
    i ++;
  }
#line 32603
  break;
  case 514: 
#line 32605
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32606
  i = 0U;
#line 32606
  while (i < n) {
#line 32607
    if (*(mask + i)) {
#line 32608
      s = (unsigned char )((int )*(stencil + i) & (int )ctx->Stencil.ValueMask);
#line 32609
      if ((int )r == (int )s) {
#line 32611
        fail[i] = (unsigned char)0;
      } else {
#line 32614
        fail[i] = (unsigned char)1;
#line 32615
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32619
      fail[i] = (unsigned char)0;
    }
#line 32606
    i ++;
  }
#line 32622
  break;
  case 517: 
#line 32624
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32625
  i = 0U;
#line 32625
  while (i < n) {
#line 32626
    if (*(mask + i)) {
#line 32627
      s = (unsigned char )((int )*(stencil + i) & (int )ctx->Stencil.ValueMask);
#line 32628
      if ((int )r != (int )s) {
#line 32630
        fail[i] = (unsigned char)0;
      } else {
#line 32633
        fail[i] = (unsigned char)1;
#line 32634
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32638
      fail[i] = (unsigned char)0;
    }
#line 32625
    i ++;
  }
#line 32641
  break;
  case 519: 
#line 32644
  i = 0U;
#line 32644
  while (i < n) {
#line 32645
    fail[i] = (unsigned char)0;
#line 32644
    i ++;
  }
#line 32647
  break;
  default: 
#line 32649
  gl_problem((GLcontext const   *)ctx, "Bad stencil func in gl_stencil_span");
#line 32650
  return (0);
  }
#line 32652
  apply_stencil_op_to_span(ctx, n, x, y, ctx->Stencil.FailFunc, fail);
#line 32653
  if (allfail) {
#line 32653
    tmp___0 = 0;
  } else {
#line 32653
    tmp___0 = 1;
  }
#line 32653
  return (tmp___0);
}
}
#line 32655 "D:/a/test/177.c"
void gl_depth_stencil_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLdepth const   *z ,
                           GLubyte *mask ) 
{ GLubyte passmask[640] ;
  GLubyte failmask[640] ;
  GLubyte oldmask[640] ;
  GLuint i ;
  GLubyte tmp___0 ;

  {
#line 32659
  if ((int )ctx->Depth.Test == 0) {
#line 32660
    apply_stencil_op_to_span(ctx, n, x, y, ctx->Stencil.ZPassFunc, mask);
  } else {
#line 32665
    i = 0U;
#line 32665
    while (i < n) {
#line 32666
      tmp___0 = (unsigned char)0;
#line 32666
      failmask[i] = tmp___0;
#line 32666
      passmask[i] = tmp___0;
#line 32667
      oldmask[i] = *(mask + i);
#line 32665
      i ++;
    }
#line 32669
    (*(ctx->Driver.DepthTestSpan))(ctx, n, x, y, z, mask);
#line 32670
    i = 0U;
#line 32670
    while (i < n) {
#line 32671
      if (oldmask[i]) {
#line 32672
        if (*(mask + i)) {
#line 32673
          passmask[i] = (unsigned char)1;
        } else {
#line 32676
          failmask[i] = (unsigned char)1;
        }
      }
#line 32670
      i ++;
    }
#line 32680
    apply_stencil_op_to_span(ctx, n, x, y, ctx->Stencil.ZFailFunc, failmask);
#line 32681
    apply_stencil_op_to_span(ctx, n, x, y, ctx->Stencil.ZPassFunc, passmask);
  }
#line 32683
  return;
}
}
#line 32684 "D:/a/test/177.c"
static void apply_stencil_op_to_pixels(GLcontext *ctx , GLuint n , GLint const   *x ,
                                       GLint const   *y , GLenum oper , GLubyte *mask ) 
{ GLint i ;
  GLstencil ref ;
  GLstencil wrtmask ;
  GLstencil invmask ;
  GLstencil *sptr ;
  GLstencil *sptr___0 ;
  GLstencil *sptr___1 ;
  GLstencil *sptr___2 ;
  GLstencil *sptr___3 ;
  GLstencil *sptr___4 ;
  GLstencil *sptr___5 ;
  GLstencil *sptr___6 ;
  GLstencil *sptr___7 ;
  GLstencil *sptr___8 ;

  {
#line 32692
  wrtmask = ctx->Stencil.WriteMask;
#line 32693
  invmask = (unsigned char )(~ ((int )ctx->Stencil.WriteMask));
#line 32694
  ref = ctx->Stencil.Ref;
#line 32695
  switch (oper) {
  case 7680: 
#line 32697
  break;
  case 0: 
#line 32699
  if ((int )invmask == 0) {
#line 32700
    i = 0;
#line 32700
    while ((GLuint )i < n) {
#line 32701
      if (*(mask + i)) {
#line 32702
        sptr = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32703
        *sptr = (unsigned char)0;
      }
#line 32700
      i ++;
    }
  } else {
#line 32708
    i = 0;
#line 32708
    while ((GLuint )i < n) {
#line 32709
      if (*(mask + i)) {
#line 32710
        sptr___0 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32711
        *sptr___0 = (unsigned char )((int )invmask & (int )*sptr___0);
      }
#line 32708
      i ++;
    }
  }
#line 32715
  break;
  case 7681: 
#line 32717
  if ((int )invmask == 0) {
#line 32718
    i = 0;
#line 32718
    while ((GLuint )i < n) {
#line 32719
      if (*(mask + i)) {
#line 32720
        sptr___1 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32721
        *sptr___1 = ref;
      }
#line 32718
      i ++;
    }
  } else {
#line 32726
    i = 0;
#line 32726
    while ((GLuint )i < n) {
#line 32727
      if (*(mask + i)) {
#line 32728
        sptr___2 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32729
        *sptr___2 = (unsigned char )(((int )invmask & (int )*sptr___2) | ((int )wrtmask & (int )ref));
      }
#line 32726
      i ++;
    }
  }
#line 32733
  break;
  case 7682: 
#line 32735
  if ((int )invmask == 0) {
#line 32736
    i = 0;
#line 32736
    while ((GLuint )i < n) {
#line 32737
      if (*(mask + i)) {
#line 32738
        sptr___3 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32739
        if ((int )*sptr___3 < 255) {
#line 32740
          *sptr___3 = (unsigned char )((int )*sptr___3 + 1);
        }
      }
#line 32736
      i ++;
    }
  } else {
#line 32746
    i = 0;
#line 32746
    while ((GLuint )i < n) {
#line 32747
      if (*(mask + i)) {
#line 32748
        sptr___4 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32749
        if ((int )*sptr___4 < 255) {
#line 32750
          *sptr___4 = (unsigned char )(((int )invmask & (int )*sptr___4) | ((int )wrtmask & ((int )*sptr___4 + 1)));
        }
      }
#line 32746
      i ++;
    }
  }
#line 32755
  break;
  case 7683: 
#line 32757
  if ((int )invmask == 0) {
#line 32758
    i = 0;
#line 32758
    while ((GLuint )i < n) {
#line 32759
      if (*(mask + i)) {
#line 32760
        sptr___5 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32761
        if ((int )*sptr___5 > 0) {
#line 32762
          *sptr___5 = (unsigned char )((int )*sptr___5 - 1);
        }
      }
#line 32758
      i ++;
    }
  } else {
#line 32768
    i = 0;
#line 32768
    while ((GLuint )i < n) {
#line 32769
      if (*(mask + i)) {
#line 32770
        sptr___6 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32771
        if ((int )*sptr___6 > 0) {
#line 32772
          *sptr___6 = (unsigned char )(((int )invmask & (int )*sptr___6) | ((int )wrtmask & ((int )*sptr___6 - 1)));
        }
      }
#line 32768
      i ++;
    }
  }
#line 32777
  break;
  case 5386: 
#line 32779
  if ((int )invmask == 0) {
#line 32780
    i = 0;
#line 32780
    while ((GLuint )i < n) {
#line 32781
      if (*(mask + i)) {
#line 32782
        sptr___7 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32783
        *sptr___7 = (unsigned char )(~ ((int )*sptr___7));
      }
#line 32780
      i ++;
    }
  } else {
#line 32788
    i = 0;
#line 32788
    while ((GLuint )i < n) {
#line 32789
      if (*(mask + i)) {
#line 32790
        sptr___8 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32791
        *sptr___8 = (unsigned char )(((int )invmask & (int )*sptr___8) | ((int )wrtmask & ~ ((int )*sptr___8)));
      }
#line 32788
      i ++;
    }
  }
#line 32795
  break;
  default: 
#line 32797
  gl_problem((GLcontext const   *)ctx, "Bad stencilop in apply_stencil_op_to_pixels");
  }
#line 32799
  return;
}
}
#line 32800 "D:/a/test/177.c"
GLint gl_stencil_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                        GLubyte *mask ) 
{ GLubyte fail[1920] ;
  GLstencil r ;
  GLstencil s ;
  GLuint i ;
  GLint allfail ;
  GLstencil *sptr ;
  GLstencil *sptr___0 ;
  GLstencil *sptr___1 ;
  GLstencil *sptr___2 ;
  GLstencil *sptr___3 ;
  GLstencil *sptr___4 ;
  int tmp___0 ;

  {
#line 32807
  allfail = 0;
#line 32808
  switch (ctx->Stencil.Function) {
  case 512: 
#line 32810
  i = 0U;
#line 32810
  while (i < n) {
#line 32811
    if (*(mask + i)) {
#line 32812
      *(mask + i) = (unsigned char)0;
#line 32813
      fail[i] = (unsigned char)1;
    } else {
#line 32816
      fail[i] = (unsigned char)0;
    }
#line 32810
    i ++;
  }
#line 32819
  allfail = 1;
#line 32820
  break;
  case 513: 
#line 32822
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32823
  i = 0U;
#line 32823
  while (i < n) {
#line 32824
    if (*(mask + i)) {
#line 32825
      sptr = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32826
      s = (unsigned char )((int )*sptr & (int )ctx->Stencil.ValueMask);
#line 32827
      if ((int )r < (int )s) {
#line 32829
        fail[i] = (unsigned char)0;
      } else {
#line 32832
        fail[i] = (unsigned char)1;
#line 32833
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32837
      fail[i] = (unsigned char)0;
    }
#line 32823
    i ++;
  }
#line 32840
  break;
  case 515: 
#line 32842
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32843
  i = 0U;
#line 32843
  while (i < n) {
#line 32844
    if (*(mask + i)) {
#line 32845
      sptr___0 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32846
      s = (unsigned char )((int )*sptr___0 & (int )ctx->Stencil.ValueMask);
#line 32847
      if ((int )r <= (int )s) {
#line 32849
        fail[i] = (unsigned char)0;
      } else {
#line 32852
        fail[i] = (unsigned char)1;
#line 32853
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32857
      fail[i] = (unsigned char)0;
    }
#line 32843
    i ++;
  }
#line 32860
  break;
  case 516: 
#line 32862
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32863
  i = 0U;
#line 32863
  while (i < n) {
#line 32864
    if (*(mask + i)) {
#line 32865
      sptr___1 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32866
      s = (unsigned char )((int )*sptr___1 & (int )ctx->Stencil.ValueMask);
#line 32867
      if ((int )r > (int )s) {
#line 32869
        fail[i] = (unsigned char)0;
      } else {
#line 32872
        fail[i] = (unsigned char)1;
#line 32873
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32877
      fail[i] = (unsigned char)0;
    }
#line 32863
    i ++;
  }
#line 32880
  break;
  case 518: 
#line 32882
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32883
  i = 0U;
#line 32883
  while (i < n) {
#line 32884
    if (*(mask + i)) {
#line 32885
      sptr___2 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32886
      s = (unsigned char )((int )*sptr___2 & (int )ctx->Stencil.ValueMask);
#line 32887
      if ((int )r >= (int )s) {
#line 32889
        fail[i] = (unsigned char)0;
      } else {
#line 32892
        fail[i] = (unsigned char)1;
#line 32893
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32897
      fail[i] = (unsigned char)0;
    }
#line 32883
    i ++;
  }
#line 32900
  break;
  case 514: 
#line 32902
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32903
  i = 0U;
#line 32903
  while (i < n) {
#line 32904
    if (*(mask + i)) {
#line 32905
      sptr___3 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32906
      s = (unsigned char )((int )*sptr___3 & (int )ctx->Stencil.ValueMask);
#line 32907
      if ((int )r == (int )s) {
#line 32909
        fail[i] = (unsigned char)0;
      } else {
#line 32912
        fail[i] = (unsigned char)1;
#line 32913
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32917
      fail[i] = (unsigned char)0;
    }
#line 32903
    i ++;
  }
#line 32920
  break;
  case 517: 
#line 32922
  r = (unsigned char )((int )ctx->Stencil.Ref & (int )ctx->Stencil.ValueMask);
#line 32923
  i = 0U;
#line 32923
  while (i < n) {
#line 32924
    if (*(mask + i)) {
#line 32925
      sptr___4 = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * (GLint )*(y + i)) + *(x + i);
#line 32926
      s = (unsigned char )((int )*sptr___4 & (int )ctx->Stencil.ValueMask);
#line 32927
      if ((int )r != (int )s) {
#line 32929
        fail[i] = (unsigned char)0;
      } else {
#line 32932
        fail[i] = (unsigned char)1;
#line 32933
        *(mask + i) = (unsigned char)0;
      }
    } else {
#line 32937
      fail[i] = (unsigned char)0;
    }
#line 32923
    i ++;
  }
#line 32940
  break;
  case 519: 
#line 32943
  i = 0U;
#line 32943
  while (i < n) {
#line 32944
    fail[i] = (unsigned char)0;
#line 32943
    i ++;
  }
#line 32946
  break;
  default: 
#line 32948
  gl_problem((GLcontext const   *)ctx, "Bad stencil func in gl_stencil_pixels");
#line 32949
  return (0);
  }
#line 32951
  apply_stencil_op_to_pixels(ctx, n, x, y, ctx->Stencil.FailFunc, fail);
#line 32952
  if (allfail) {
#line 32952
    tmp___0 = 0;
  } else {
#line 32952
    tmp___0 = 1;
  }
#line 32952
  return (tmp___0);
}
}
#line 32954 "D:/a/test/177.c"
void gl_depth_stencil_pixels(GLcontext *ctx , GLuint n , GLint const   *x , GLint const   *y ,
                             GLdepth const   *z , GLubyte *mask ) 
{ GLubyte passmask[1920] ;
  GLubyte failmask[1920] ;
  GLubyte oldmask[1920] ;
  GLuint i ;
  GLubyte tmp___0 ;

  {
#line 32958
  if ((int )ctx->Depth.Test == 0) {
#line 32959
    apply_stencil_op_to_pixels(ctx, n, x, y, ctx->Stencil.ZPassFunc, mask);
  } else {
#line 32964
    i = 0U;
#line 32964
    while (i < n) {
#line 32965
      tmp___0 = (unsigned char)0;
#line 32965
      failmask[i] = tmp___0;
#line 32965
      passmask[i] = tmp___0;
#line 32966
      oldmask[i] = *(mask + i);
#line 32964
      i ++;
    }
#line 32968
    (*(ctx->Driver.DepthTestPixels))(ctx, n, x, y, z, mask);
#line 32969
    i = 0U;
#line 32969
    while (i < n) {
#line 32970
      if (oldmask[i]) {
#line 32971
        if (*(mask + i)) {
#line 32972
          passmask[i] = (unsigned char)1;
        } else {
#line 32975
          failmask[i] = (unsigned char)1;
        }
      }
#line 32969
      i ++;
    }
#line 32979
    apply_stencil_op_to_pixels(ctx, n, x, y, ctx->Stencil.ZFailFunc, failmask);
#line 32981
    apply_stencil_op_to_pixels(ctx, n, x, y, ctx->Stencil.ZPassFunc, passmask);
  }
#line 32984
  return;
}
}
#line 32985 "D:/a/test/177.c"
void gl_read_stencil_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte *stencil ) 
{ GLstencil *s ;

  {
#line 32989
  if ((ctx->Buffer)->Stencil) {
#line 32990
    s = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * y) + x;
#line 32991
    memcpy((void *)stencil, (void const   *)((void *)s), n * sizeof(GLubyte ));
  }
#line 32993
  return;
}
}
#line 32994 "D:/a/test/177.c"
void gl_write_stencil_span(GLcontext *ctx , GLuint n , GLint x , GLint y , GLubyte const   *stencil ) 
{ GLstencil *s ;

  {
#line 32999
  if ((ctx->Buffer)->Stencil) {
#line 33000
    s = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * y) + x;
#line 33001
    memcpy((void *)s, (void const   *)((void *)stencil), n * sizeof(GLubyte ));
  }
#line 33003
  return;
}
}
#line 33004 "D:/a/test/177.c"
void gl_alloc_stencil_buffer(GLcontext *ctx ) 
{ GLuint buffersize ;
  void *tmp___0 ;

  {
#line 33006
  buffersize = (GLuint )((ctx->Buffer)->Width * (ctx->Buffer)->Height);
#line 33007
  if ((ctx->Buffer)->Stencil) {
#line 33008
    free((void *)(ctx->Buffer)->Stencil);
#line 33009
    (ctx->Buffer)->Stencil = (GLstencil *)((void *)0);
  }
#line 33011
  tmp___0 = malloc(buffersize * sizeof(GLstencil ));//41
#line 33011
  (ctx->Buffer)->Stencil = (GLstencil *)tmp___0;
#line 33012
  if (! (ctx->Buffer)->Stencil) {
#line 33013
    ctx->Stencil.Enabled = (unsigned char)0;
#line 33014
    gl_error(ctx, 1285, "gl_alloc_stencil_buffer");
  }
#line 33016
  return;
}
}
#line 33017 "D:/a/test/177.c"
void gl_clear_stencil_buffer(GLcontext *ctx ) 
{ GLint y ;
  GLint width ;
  GLstencil *ptr ;

  {
#line 33019
  if ((ctx->Visual)->StencilBits == 0) {
#line 33020
    return;
  } else {
#line 33019
    if (! (ctx->Buffer)->Stencil) {
#line 33020
      return;
    }
  }
#line 33022
  if (ctx->Scissor.Enabled) {
#line 33024
    width = ((ctx->Buffer)->Xmax - (ctx->Buffer)->Xmin) + 1;
#line 33025
    y = (ctx->Buffer)->Ymin;
#line 33025
    while (y <= (ctx->Buffer)->Ymax) {
#line 33026
      ptr = ((ctx->Buffer)->Stencil + (ctx->Buffer)->Width * y) + (ctx->Buffer)->Xmin;
#line 33027
      memset((void *)ptr, (int )ctx->Stencil.Clear, (unsigned int )width * sizeof(GLstencil ));
#line 33025
      y ++;
    }
  } else {
#line 33031
    memset((void *)(ctx->Buffer)->Stencil, (int )ctx->Stencil.Clear, (unsigned int )((ctx->Buffer)->Width * (ctx->Buffer)->Height) * sizeof(GLstencil ));
  }
#line 33034
  return;
}
}
#line 33040 "D:/a/test/177.c"
static int logbase2(int n ) 
{ GLint i ;
  GLint log2 ;

  {
#line 33042
  i = 1;
#line 33043
  log2 = 0;
#line 33044
  if (n < 0) {
#line 33045
    return (-1);
  }
#line 33047
  while (n > i) {
#line 33048
    i *= 2;
#line 33049
    log2 ++;
  }
#line 33051
  if (i != n) {
#line 33052
    return (-1);
  } else {
#line 33055
    return (log2);
  }
}
}
#line 33058 "D:/a/test/177.c"
static GLint decode_internal_format1(GLint format ) 
{ 

  {
#line 33060
  switch (format) {
  case 6406: 
  case 32827: 
  case 32828: 
  case 32829: 
  case 32830: 
#line 33066
  return (6406);
  case 1: 
  case 6409: 
  case 32831: 
  case 32832: 
  case 32833: 
  case 32834: 
#line 33073
  return (6409);
  case 2: 
  case 6410: 
  case 32835: 
  case 32836: 
  case 32837: 
  case 32838: 
  case 32839: 
  case 32840: 
#line 33082
  return (6410);
  case 32841: 
  case 32842: 
  case 32843: 
  case 32844: 
  case 32845: 
#line 33088
  return (32841);
  case 3: 
  case 6407: 
  case 10768: 
  case 32847: 
  case 32848: 
  case 32849: 
  case 32850: 
  case 32851: 
  case 32852: 
#line 33098
  return (6407);
  case 4: 
  case 6408: 
  case 32853: 
  case 32854: 
  case 32855: 
  case 32856: 
  case 32857: 
  case 32858: 
  case 32859: 
#line 33108
  return (6408);
  case 32994: 
  case 32995: 
  case 32996: 
  case 32997: 
  case 32998: 
  case 32999: 
#line 33115
  return (6400);
  default: ;
#line 33117
  return (-1);
  }
}
}
#line 33120 "D:/a/test/177.c"
static GLint components_in_intformat(GLint format ) 
{ 

  {
#line 33122
  switch (format) {
  case 6406: 
  case 32827: 
  case 32828: 
  case 32829: 
  case 32830: 
#line 33128
  return (1);
  case 1: 
  case 6409: 
  case 32831: 
  case 32832: 
  case 32833: 
  case 32834: 
#line 33135
  return (1);
  case 2: 
  case 6410: 
  case 32835: 
  case 32836: 
  case 32837: 
  case 32838: 
  case 32839: 
  case 32840: 
#line 33144
  return (2);
  case 32841: 
  case 32842: 
  case 32843: 
  case 32844: 
  case 32845: 
#line 33150
  return (1);
  case 3: 
  case 6407: 
  case 10768: 
  case 32847: 
  case 32848: 
  case 32849: 
  case 32850: 
  case 32851: 
  case 32852: 
#line 33160
  return (3);
  case 4: 
  case 6408: 
  case 32853: 
  case 32854: 
  case 32855: 
  case 32856: 
  case 32857: 
  case 32858: 
  case 32859: 
#line 33170
  return (4);
  case 32994: 
  case 32995: 
  case 32996: 
  case 32997: 
  case 32998: 
  case 32999: 
#line 33177
  return (1);
  default: ;
#line 33179
  return (-1);
  }
}
}
#line 33182 "D:/a/test/177.c"
struct gl_texture_image *gl_alloc_texture_image(void) 
{ void *tmp___0 ;

  {
#line 33184
  tmp___0 = calloc(1U, sizeof(struct gl_texture_image ));
#line 33184
  return ((struct gl_texture_image *)tmp___0);
}
}
#line 33186 "D:/a/test/177.c"
void gl_free_texture_image(struct gl_texture_image *teximage ) 
{ 

  {
#line 33188
  if (teximage->Data) {
#line 33189
    free((void *)teximage->Data);
  }
#line 33191
  free((void *)teximage);
#line 33192
  return;
}
}
#line 33193 "D:/a/test/177.c"
static struct gl_texture_image *image_to_texture(GLcontext *ctx , struct gl_image  const  *image ,
                                                 GLenum internalFormat , GLint border ) 
{ GLint components___0 ;
  struct gl_texture_image *texImage ;
  GLint numPixels ;
  GLint pixel ;
  GLboolean scaleOrBias ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  GLint shift ;
  GLint offset ;
  GLint rMask ;
  GLint gMask ;
  GLint bMask ;
  GLint aMask ;
  GLint i ;
  GLint j ;
  GLubyte *srcPtr ;
  GLubyte bitMask ;
  GLint index___0 ;
  GLubyte red ;
  GLubyte green ;
  GLubyte blue___0 ;
  GLubyte alpha ;
  GLubyte red___0 ;
  GLubyte green___0 ;
  GLubyte blue___1 ;
  GLubyte alpha___0 ;
  GLint index___1 ;
  GLint index___2 ;
  GLint tmp___4 ;
  float r ;
  float g ;
  float b ;
  float a ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  float tmp___8 ;
  GLint ir ;
  GLint ig ;
  GLint ib ;
  GLint ia ;
  float red___1 ;
  float green___1 ;
  float blue___2 ;
  float alpha___1 ;
  GLint index___3 ;
  GLint shift___0 ;
  GLint offset___0 ;
  GLint rMask___0 ;
  GLint gMask___0 ;
  GLint bMask___0 ;
  GLint aMask___0 ;
  GLint index___4 ;
  GLint tmp___9 ;
  float tmp___10 ;
  float tmp___11 ;
  float tmp___12 ;
  float tmp___13 ;
  GLint ir___0 ;
  GLint ig___0 ;
  GLint ib___0 ;
  GLint ia___0 ;

  {
#line 33201
  //assert(image);
#line 33202
  //assert(image->Width > 0);
#line 33203
  //assert(image->Height > 0);
#line 33204
  //assert(image->Depth > 0);
#line 33205
  components___0 = components_in_intformat(internalFormat);
#line 33206
  numPixels = (int )((image->Width * image->Height) * image->Depth);
#line 33207
  texImage = gl_alloc_texture_image();
#line 33208
  if (! texImage) {
#line 33209
    return ((struct gl_texture_image *)((void *)0));
  }
#line 33210
  texImage->Format = decode_internal_format1(internalFormat);
#line 33211
  texImage->IntFormat = internalFormat;
#line 33212
  texImage->Border = (unsigned int )border;
#line 33213
  texImage->Width = (unsigned int )image->Width;
#line 33214
  texImage->Height = (unsigned int )image->Height;
#line 33215
  texImage->Depth = (unsigned int )image->Depth;
#line 33216
  tmp___0 = logbase2((int )(image->Width - (GLint const   )(2 * border)));
#line 33216
  texImage->WidthLog2 = (unsigned int )tmp___0;
#line 33217
  if (image->Height == 1) {
#line 33218
    texImage->HeightLog2 = 0U;
  } else {
#line 33220
    tmp___1 = logbase2((int )(image->Height - (GLint const   )(2 * border)));
#line 33220
    texImage->HeightLog2 = (unsigned int )tmp___1;
  }
#line 33221
  if (image->Depth == 1) {
#line 33222
    texImage->DepthLog2 = 0U;
  } else {
#line 33224
    tmp___2 = logbase2((int )(image->Depth - (GLint const   )(2 * border)));
#line 33224
    texImage->DepthLog2 = (unsigned int )tmp___2;
  }
#line 33225
  texImage->Width2 = (unsigned int )(1 << texImage->WidthLog2);
#line 33226
  texImage->Height2 = (unsigned int )(1 << texImage->HeightLog2);
#line 33227
  texImage->Depth2 = (unsigned int )(1 << texImage->DepthLog2);
#line 33228
  if (texImage->WidthLog2 > texImage->HeightLog2) {
#line 33228
    texImage->MaxLog2 = texImage->WidthLog2;
  } else {
#line 33228
    texImage->MaxLog2 = texImage->HeightLog2;
  }
#line 33229
  tmp___3 = malloc((unsigned int )(numPixels * components___0));//42
#line 33229
  texImage->Data = (GLubyte *)tmp___3;
#line 33230
  //assert(texImage->WidthLog2 >= 0U);
#line 33231
  //assert(texImage->HeightLog2 >= 0U);
#line 33232
  //assert(texImage->DepthLog2 >= 0U);
#line 33233
  if (! texImage->Data) {
#line 33234
    gl_free_texture_image(texImage);
#line 33235
    return ((struct gl_texture_image *)((void *)0));
  }
#line 33237
  if (ctx->Pixel.RedScale != 1.0F) {
#line 33241
    scaleOrBias = (unsigned char)1;
  } else {
#line 33237
    if (ctx->Pixel.RedBias != 0.0F) {
#line 33241
      scaleOrBias = (unsigned char)1;
    } else {
#line 33237
      if (ctx->Pixel.GreenScale != 1.0F) {
#line 33241
        scaleOrBias = (unsigned char)1;
      } else {
#line 33237
        if (ctx->Pixel.GreenBias != 0.0F) {
#line 33241
          scaleOrBias = (unsigned char)1;
        } else {
#line 33237
          if (ctx->Pixel.BlueScale != 1.0F) {
#line 33241
            scaleOrBias = (unsigned char)1;
          } else {
#line 33237
            if (ctx->Pixel.BlueBias != 0.0F) {
#line 33241
              scaleOrBias = (unsigned char)1;
            } else {
#line 33237
              if (ctx->Pixel.AlphaScale != 1.0F) {
#line 33241
                scaleOrBias = (unsigned char)1;
              } else {
#line 33237
                if (ctx->Pixel.AlphaBias != 0.0F) {
#line 33241
                  scaleOrBias = (unsigned char)1;
                } else {
#line 33244
                  scaleOrBias = (unsigned char)0;
                }
              }
            }
          }
        }
      }
    }
  }
#line 33246
  switch ((int )image->Type) {
  case 6656: 
#line 33249
  shift = ctx->Pixel.IndexShift;
#line 33250
  offset = ctx->Pixel.IndexOffset;
#line 33251
  rMask = ctx->Pixel.MapItoRsize - 1;
#line 33252
  gMask = ctx->Pixel.MapItoGsize - 1;
#line 33253
  bMask = ctx->Pixel.MapItoBsize - 1;
#line 33254
  aMask = ctx->Pixel.MapItoAsize - 1;
#line 33256
  srcPtr = (GLubyte *)image->Data;
#line 33257
  //assert(image->Format == 6400);
#line 33258
  j = 0;
#line 33258
  while (j < (GLint )image->Height) {
#line 33259
    bitMask = (GLubyte )128;
#line 33260
    i = 0;
#line 33260
    while (i < (GLint )image->Width) {
#line 33263
      if ((int )*srcPtr & (int )bitMask) {
#line 33263
        index___0 = 1;
      } else {
#line 33263
        index___0 = 0;
      }
#line 33264
      bitMask = (unsigned char )((int )bitMask >> 1);
#line 33265
      if ((int )bitMask == 0) {
#line 33266
        bitMask = (unsigned char)128;
#line 33267
        srcPtr ++;
      }
#line 33269
      if (shift >= 0) {
#line 33270
        index___0 = (index___0 << shift) + offset;
      } else {
#line 33273
        index___0 = (index___0 >> - shift) + offset;
      }
#line 33275
      red = (unsigned char )((int )(ctx->Pixel.MapItoR[index___0 & rMask] * 255.0F));
#line 33276
      green = (unsigned char )((int )(ctx->Pixel.MapItoG[index___0 & gMask] * 255.0F));
#line 33277
      blue___0 = (unsigned char )((int )(ctx->Pixel.MapItoB[index___0 & bMask] * 255.0F));
#line 33278
      alpha = (unsigned char )((int )(ctx->Pixel.MapItoA[index___0 & aMask] * 255.0F));
#line 33279
      pixel = j * (GLint )image->Width + i;
#line 33280
      switch (texImage->Format) {
      case 6406: 
#line 33282
      *(texImage->Data + pixel) = alpha;
#line 33283
      break;
      case 6409: 
#line 33285
      *(texImage->Data + pixel) = red;
#line 33286
      break;
      case 6410: 
#line 33288
      *(texImage->Data + pixel * 2) = red;
#line 33289
      *(texImage->Data + (pixel * 2 + 1)) = alpha;
#line 33290
      break;
      case 32841: 
#line 33292
      *(texImage->Data + pixel) = red;
#line 33293
      break;
      case 6407: 
#line 33295
      *(texImage->Data + pixel * 3) = red;
#line 33296
      *(texImage->Data + (pixel * 3 + 1)) = green;
#line 33297
      *(texImage->Data + (pixel * 3 + 2)) = blue___0;
#line 33298
      break;
      case 6408: 
#line 33300
      *(texImage->Data + pixel * 4) = red;
#line 33301
      *(texImage->Data + (pixel * 4 + 1)) = green;
#line 33302
      *(texImage->Data + (pixel * 4 + 2)) = blue___0;
#line 33303
      *(texImage->Data + (pixel * 4 + 3)) = alpha;
#line 33304
      break;
      default: 
#line 33306
      gl_problem((GLcontext const   *)ctx, "Bad format in image_to_texture");
#line 33307
      return ((struct gl_texture_image *)((void *)0));
      }
#line 33260
      i ++;
    }
#line 33310
    if ((int )bitMask != 128) {
#line 33311
      srcPtr ++;
    }
#line 33258
    j ++;
  }
#line 33315
  break;
  case 5121: 
#line 33317
  pixel = 0;
#line 33317
  while (pixel < numPixels) {
#line 33319
    switch ((int )image->Format) {
    case 6400: 
#line 33321
    tmp___4 = decode_internal_format1(internalFormat);
#line 33321
    if (tmp___4 == 6400) {
#line 33322
      index___1 = (GLint )*((GLubyte *)image->Data + pixel);
#line 33323
      red___0 = (unsigned char )index___1;
    } else {
#line 33326
      index___2 = (GLint )*((GLubyte *)image->Data + pixel);
#line 33327
      red___0 = (unsigned char )(255.0F * ctx->Pixel.MapItoR[index___2]);
#line 33328
      green___0 = (unsigned char )(255.0F * ctx->Pixel.MapItoG[index___2]);
#line 33329
      blue___1 = (unsigned char )(255.0F * ctx->Pixel.MapItoB[index___2]);
#line 33330
      alpha___0 = (unsigned char )(255.0F * ctx->Pixel.MapItoA[index___2]);
    }
#line 33332
    break;
    case 6407: 
#line 33334
    red___0 = *((GLubyte *)image->Data + pixel * 3);
#line 33335
    green___0 = *((GLubyte *)image->Data + (pixel * 3 + 1));
#line 33336
    blue___1 = *((GLubyte *)image->Data + (pixel * 3 + 2));
#line 33337
    alpha___0 = (unsigned char)255;
#line 33338
    break;
    case 6408: 
#line 33340
    red___0 = *((GLubyte *)image->Data + pixel * 4);
#line 33341
    green___0 = *((GLubyte *)image->Data + (pixel * 4 + 1));
#line 33342
    blue___1 = *((GLubyte *)image->Data + (pixel * 4 + 2));
#line 33343
    alpha___0 = *((GLubyte *)image->Data + (pixel * 4 + 3));
#line 33344
    break;
    case 6403: 
#line 33346
    red___0 = *((GLubyte *)image->Data + pixel);
#line 33347
    green___0 = (unsigned char)0;
#line 33348
    blue___1 = (unsigned char)0;
#line 33349
    alpha___0 = (unsigned char)255;
#line 33350
    break;
    case 6404: 
#line 33352
    red___0 = (unsigned char)0;
#line 33353
    green___0 = *((GLubyte *)image->Data + pixel);
#line 33354
    blue___1 = (unsigned char)0;
#line 33355
    alpha___0 = (unsigned char)255;
#line 33356
    break;
    case 6405: 
#line 33358
    red___0 = (unsigned char)0;
#line 33359
    green___0 = (unsigned char)0;
#line 33360
    blue___1 = *((GLubyte *)image->Data + pixel);
#line 33361
    alpha___0 = (unsigned char)255;
#line 33362
    break;
    case 6406: 
#line 33364
    red___0 = (unsigned char)0;
#line 33365
    green___0 = (unsigned char)0;
#line 33366
    blue___1 = (unsigned char)0;
#line 33367
    alpha___0 = *((GLubyte *)image->Data + pixel);
#line 33368
    break;
    case 6409: 
#line 33370
    red___0 = *((GLubyte *)image->Data + pixel);
#line 33371
    green___0 = red___0;
#line 33372
    blue___1 = red___0;
#line 33373
    alpha___0 = (unsigned char)255;
#line 33374
    break;
    case 6410: 
#line 33376
    red___0 = *((GLubyte *)image->Data + pixel * 2);
#line 33377
    green___0 = red___0;
#line 33378
    blue___1 = red___0;
#line 33379
    alpha___0 = *((GLubyte *)image->Data + (pixel * 2 + 1));
#line 33380
    break;
    default: 
#line 33382
    gl_problem((GLcontext const   *)ctx, "Bad format (2) in image_to_texture");
#line 33383
    return ((struct gl_texture_image *)((void *)0));
    }
#line 33385
    if (scaleOrBias) {
      goto _L;
    } else {
#line 33385
      if (ctx->Pixel.MapColorFlag) {
        _L: /* CIL Label */ 
#line 33386
        r = (float )red___0 * (1.0F / 255.0F);
#line 33387
        g = (float )green___0 * (1.0F / 255.0F);
#line 33388
        b = (float )blue___1 * (1.0F / 255.0F);
#line 33389
        a = (float )alpha___0 * (1.0F / 255.0F);
#line 33390
        if (scaleOrBias) {
#line 33391
          r = r * ctx->Pixel.RedScale + ctx->Pixel.RedBias;
#line 33392
          g = g * ctx->Pixel.GreenScale + ctx->Pixel.GreenBias;
#line 33393
          b = b * ctx->Pixel.BlueScale + ctx->Pixel.BlueBias;
#line 33394
          a = a * ctx->Pixel.AlphaScale + ctx->Pixel.AlphaBias;
#line 33395
          if (r < 0.0F) {
#line 33395
            r = 0.0F;
          } else {
#line 33395
            if (r > 1.0F) {
#line 33395
              tmp___5 = 1.0F;
            } else {
#line 33395
              tmp___5 = r;
            }
#line 33395
            r = tmp___5;
          }
#line 33396
          if (g < 0.0F) {
#line 33396
            g = 0.0F;
          } else {
#line 33396
            if (g > 1.0F) {
#line 33396
              tmp___6 = 1.0F;
            } else {
#line 33396
              tmp___6 = g;
            }
#line 33396
            g = tmp___6;
          }
#line 33397
          if (b < 0.0F) {
#line 33397
            b = 0.0F;
          } else {
#line 33397
            if (b > 1.0F) {
#line 33397
              tmp___7 = 1.0F;
            } else {
#line 33397
              tmp___7 = b;
            }
#line 33397
            b = tmp___7;
          }
#line 33398
          if (a < 0.0F) {
#line 33398
            a = 0.0F;
          } else {
#line 33398
            if (a > 1.0F) {
#line 33398
              tmp___8 = 1.0F;
            } else {
#line 33398
              tmp___8 = a;
            }
#line 33398
            a = tmp___8;
          }
        }
#line 33400
        if (ctx->Pixel.MapColorFlag) {
#line 33401
          ir = (int )(r * (float )ctx->Pixel.MapRtoRsize);
#line 33402
          ig = (int )(g * (float )ctx->Pixel.MapGtoGsize);
#line 33403
          ib = (int )(b * (float )ctx->Pixel.MapBtoBsize);
#line 33404
          ia = (int )(a * (float )ctx->Pixel.MapAtoAsize);
#line 33405
          r = ctx->Pixel.MapRtoR[ir];
#line 33406
          g = ctx->Pixel.MapGtoG[ig];
#line 33407
          b = ctx->Pixel.MapBtoB[ib];
#line 33408
          a = ctx->Pixel.MapAtoA[ia];
        }
#line 33410
        red___0 = (unsigned char )((int )(r * 255.0F));
#line 33411
        green___0 = (unsigned char )((int )(g * 255.0F));
#line 33412
        blue___1 = (unsigned char )((int )(b * 255.0F));
#line 33413
        alpha___0 = (unsigned char )((int )(a * 255.0F));
      }
    }
#line 33415
    switch (texImage->Format) {
    case 6400: 
#line 33417
    *(texImage->Data + pixel) = red___0;
#line 33418
    break;
    case 6406: 
#line 33420
    *(texImage->Data + pixel) = alpha___0;
#line 33421
    break;
    case 6409: 
#line 33423
    *(texImage->Data + pixel) = red___0;
#line 33424
    break;
    case 6410: 
#line 33426
    *(texImage->Data + pixel * 2) = red___0;
#line 33427
    *(texImage->Data + (pixel * 2 + 1)) = alpha___0;
#line 33428
    break;
    case 32841: 
#line 33430
    *(texImage->Data + pixel) = red___0;
#line 33431
    break;
    case 6407: 
#line 33433
    *(texImage->Data + pixel * 3) = red___0;
#line 33434
    *(texImage->Data + (pixel * 3 + 1)) = green___0;
#line 33435
    *(texImage->Data + (pixel * 3 + 2)) = blue___1;
#line 33436
    break;
    case 6408: 
#line 33438
    *(texImage->Data + pixel * 4) = red___0;
#line 33439
    *(texImage->Data + (pixel * 4 + 1)) = green___0;
#line 33440
    *(texImage->Data + (pixel * 4 + 2)) = blue___1;
#line 33441
    *(texImage->Data + (pixel * 4 + 3)) = alpha___0;
#line 33442
    break;
    default: 
#line 33444
    gl_problem((GLcontext const   *)ctx, "Bad format (3) in image_to_texture");
#line 33445
    return ((struct gl_texture_image *)((void *)0));
    }
#line 33317
    pixel ++;
  }
#line 33448
  break;
  case 5126: 
#line 33450
  pixel = 0;
#line 33450
  while (pixel < numPixels) {
#line 33452
    switch (texImage->Format) {
    case 6400: 
#line 33454
    tmp___9 = decode_internal_format1(internalFormat);
#line 33454
    if (tmp___9 == 6400) {
#line 33455
      index___3 = (int )*((float *)image->Data + pixel);
#line 33456
      red___1 = (float )index___3;
    } else {
#line 33459
      shift___0 = ctx->Pixel.IndexShift;
#line 33460
      offset___0 = ctx->Pixel.IndexOffset;
#line 33461
      rMask___0 = ctx->Pixel.MapItoRsize - 1;
#line 33462
      gMask___0 = ctx->Pixel.MapItoGsize - 1;
#line 33463
      bMask___0 = ctx->Pixel.MapItoBsize - 1;
#line 33464
      aMask___0 = ctx->Pixel.MapItoAsize - 1;
#line 33465
      index___4 = (int )*((float *)image->Data + pixel);
#line 33466
      if (shift___0 >= 0) {
#line 33467
        index___4 = (index___4 << shift___0) + offset___0;
      } else {
#line 33470
        index___4 = (index___4 >> - shift___0) + offset___0;
      }
#line 33472
      red___1 = ctx->Pixel.MapItoR[index___4 & rMask___0];
#line 33473
      green___1 = ctx->Pixel.MapItoG[index___4 & gMask___0];
#line 33474
      blue___2 = ctx->Pixel.MapItoB[index___4 & bMask___0];
#line 33475
      alpha___1 = ctx->Pixel.MapItoA[index___4 & aMask___0];
    }
#line 33477
    break;
    case 6407: 
#line 33479
    red___1 = *((float *)image->Data + pixel * 3);
#line 33480
    green___1 = *((float *)image->Data + (pixel * 3 + 1));
#line 33481
    blue___2 = *((float *)image->Data + (pixel * 3 + 2));
#line 33482
    alpha___1 = (float )1.0;
#line 33483
    break;
    case 6408: 
#line 33485
    red___1 = *((float *)image->Data + pixel * 4);
#line 33486
    green___1 = *((float *)image->Data + (pixel * 4 + 1));
#line 33487
    blue___2 = *((float *)image->Data + (pixel * 4 + 2));
#line 33488
    alpha___1 = *((float *)image->Data + (pixel * 4 + 3));
#line 33489
    break;
    case 6403: 
#line 33491
    red___1 = *((float *)image->Data + pixel);
#line 33492
    green___1 = (float )0.0;
#line 33493
    blue___2 = (float )0.0;
#line 33494
    alpha___1 = (float )1.0;
#line 33495
    break;
    case 6404: 
#line 33497
    red___1 = (float )0.0;
#line 33498
    green___1 = *((float *)image->Data + pixel);
#line 33499
    blue___2 = (float )0.0;
#line 33500
    alpha___1 = (float )1.0;
#line 33501
    break;
    case 6405: 
#line 33503
    red___1 = (float )0.0;
#line 33504
    green___1 = (float )0.0;
#line 33505
    blue___2 = *((float *)image->Data + pixel);
#line 33506
    alpha___1 = (float )1.0;
#line 33507
    break;
    case 6406: 
#line 33509
    red___1 = (float )0.0;
#line 33510
    green___1 = (float )0.0;
#line 33511
    blue___2 = (float )0.0;
#line 33512
    alpha___1 = *((float *)image->Data + pixel);
#line 33513
    break;
    case 6409: 
#line 33515
    red___1 = *((float *)image->Data + pixel);
#line 33516
    green___1 = red___1;
#line 33517
    blue___2 = red___1;
#line 33518
    alpha___1 = (float )1.0;
#line 33519
    break;
    case 6410: 
#line 33521
    red___1 = *((float *)image->Data + pixel * 2);
#line 33522
    green___1 = red___1;
#line 33523
    blue___2 = red___1;
#line 33524
    alpha___1 = *((float *)image->Data + (pixel * 2 + 1));
#line 33525
    break;
    default: 
#line 33527
    gl_problem((GLcontext const   *)ctx, "Bad format (4) in image_to_texture");
#line 33528
    return ((struct gl_texture_image *)((void *)0));
    }
#line 33530
    if (image->Format != 6400) {
#line 33531
      if (scaleOrBias) {
#line 33532
        red___1 = red___1 * ctx->Pixel.RedScale + ctx->Pixel.RedBias;
#line 33533
        green___1 = green___1 * ctx->Pixel.GreenScale + ctx->Pixel.GreenBias;
#line 33534
        blue___2 = blue___2 * ctx->Pixel.BlueScale + ctx->Pixel.BlueBias;
#line 33535
        alpha___1 = alpha___1 * ctx->Pixel.AlphaScale + ctx->Pixel.AlphaBias;
#line 33536
        if (red___1 < 0.0F) {
#line 33536
          red___1 = 0.0F;
        } else {
#line 33536
          if (red___1 > 1.0F) {
#line 33536
            tmp___10 = 1.0F;
          } else {
#line 33536
            tmp___10 = red___1;
          }
#line 33536
          red___1 = tmp___10;
        }
#line 33537
        if (green___1 < 0.0F) {
#line 33537
          green___1 = 0.0F;
        } else {
#line 33537
          if (green___1 > 1.0F) {
#line 33537
            tmp___11 = 1.0F;
          } else {
#line 33537
            tmp___11 = green___1;
          }
#line 33537
          green___1 = tmp___11;
        }
#line 33538
        if (blue___2 < 0.0F) {
#line 33538
          blue___2 = 0.0F;
        } else {
#line 33538
          if (blue___2 > 1.0F) {
#line 33538
            tmp___12 = 1.0F;
          } else {
#line 33538
            tmp___12 = blue___2;
          }
#line 33538
          blue___2 = tmp___12;
        }
#line 33539
        if (alpha___1 < 0.0F) {
#line 33539
          alpha___1 = 0.0F;
        } else {
#line 33539
          if (alpha___1 > 1.0F) {
#line 33539
            tmp___13 = 1.0F;
          } else {
#line 33539
            tmp___13 = alpha___1;
          }
#line 33539
          alpha___1 = tmp___13;
        }
      }
#line 33541
      if (ctx->Pixel.MapColorFlag) {
#line 33542
        ir___0 = (int )(red___1 * (float )ctx->Pixel.MapRtoRsize);
#line 33543
        ig___0 = (int )(green___1 * (float )ctx->Pixel.MapGtoGsize);
#line 33544
        ib___0 = (int )(blue___2 * (float )ctx->Pixel.MapBtoBsize);
#line 33545
        ia___0 = (int )(alpha___1 * (float )ctx->Pixel.MapAtoAsize);
#line 33546
        red___1 = ctx->Pixel.MapRtoR[ir___0];
#line 33547
        green___1 = ctx->Pixel.MapGtoG[ig___0];
#line 33548
        blue___2 = ctx->Pixel.MapBtoB[ib___0];
#line 33549
        alpha___1 = ctx->Pixel.MapAtoA[ia___0];
      }
    }
#line 33552
    switch (texImage->Format) {
    case 6400: 
#line 33554
    *(texImage->Data + pixel) = (unsigned char )((int )(red___1 * 255.0F));
#line 33555
    break;
    case 6406: 
#line 33557
    *(texImage->Data + pixel) = (unsigned char )((int )(alpha___1 * 255.0F));
#line 33558
    break;
    case 6409: 
#line 33560
    *(texImage->Data + pixel) = (unsigned char )((int )(red___1 * 255.0F));
#line 33561
    break;
    case 6410: 
#line 33563
    *(texImage->Data + pixel * 2) = (unsigned char )((int )(red___1 * 255.0F));
#line 33564
    *(texImage->Data + (pixel * 2 + 1)) = (unsigned char )((int )(alpha___1 * 255.0F));
#line 33565
    break;
    case 32841: 
#line 33567
    *(texImage->Data + pixel) = (unsigned char )((int )(red___1 * 255.0F));
#line 33568
    break;
    case 6407: 
#line 33570
    *(texImage->Data + pixel * 3) = (unsigned char )((int )(red___1 * 255.0F));
#line 33571
    *(texImage->Data + (pixel * 3 + 1)) = (unsigned char )((int )(green___1 * 255.0F));
#line 33572
    *(texImage->Data + (pixel * 3 + 2)) = (unsigned char )((int )(blue___2 * 255.0F));
#line 33573
    break;
    case 6408: 
#line 33575
    *(texImage->Data + pixel * 4) = (unsigned char )((int )(red___1 * 255.0F));
#line 33576
    *(texImage->Data + (pixel * 4 + 1)) = (unsigned char )((int )(green___1 * 255.0F));
#line 33577
    *(texImage->Data + (pixel * 4 + 2)) = (unsigned char )((int )(blue___2 * 255.0F));
#line 33578
    *(texImage->Data + (pixel * 4 + 3)) = (unsigned char )((int )(alpha___1 * 255.0F));
#line 33579
    break;
    default: 
#line 33581
    gl_problem((GLcontext const   *)ctx, "Bad format (5) in image_to_texture");
#line 33582
    return ((struct gl_texture_image *)((void *)0));
    }
#line 33450
    pixel ++;
  }
#line 33585
  break;
  default: 
#line 33587
  gl_problem((GLcontext const   *)ctx, "Bad image type in image_to_texture");
#line 33588
  return ((struct gl_texture_image *)((void *)0));
  }
#line 33590
  return (texImage);
}
}
#line 33592 "D:/a/test/177.c"
static struct gl_texture_image *make_null_texture(GLcontext *ctx , GLenum internalFormat ,
                                                  GLsizei width , GLsizei height ,
                                                  GLsizei depth , GLint border ) 
{ GLint components___0 ;
  struct gl_texture_image *texImage ;
  GLint numPixels ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  char message[8][32] ;
  GLubyte *imgPtr ;
  GLint i ;
  GLint j ;
  GLint k ;
  GLint srcRow ;
  GLint srcCol ;
  GLubyte texel ;
  int tmp___4 ;
  GLubyte *tmp___5 ;

  {
#line 33599
  components___0 = components_in_intformat(internalFormat);
#line 33600
  numPixels = (width * height) * depth;
#line 33601
  texImage = gl_alloc_texture_image();
#line 33602
  if (! texImage) {
#line 33603
    return ((struct gl_texture_image *)((void *)0));
  }
#line 33604
  texImage->Format = decode_internal_format1(internalFormat);
#line 33605
  texImage->IntFormat = internalFormat;
#line 33606
  texImage->Border = (unsigned int )border;
#line 33607
  texImage->Width = (unsigned int )width;
#line 33608
  texImage->Height = (unsigned int )height;
#line 33609
  texImage->Depth = (unsigned int )depth;
#line 33610
  tmp___0 = logbase2(width - 2 * border);
#line 33610
  texImage->WidthLog2 = (unsigned int )tmp___0;
#line 33611
  if (height == 1) {
#line 33612
    texImage->HeightLog2 = 0U;
  } else {
#line 33614
    tmp___1 = logbase2(height - 2 * border);
#line 33614
    texImage->HeightLog2 = (unsigned int )tmp___1;
  }
#line 33615
  if (depth == 1) {
#line 33616
    texImage->DepthLog2 = 0U;
  } else {
#line 33618
    tmp___2 = logbase2(depth - 2 * border);
#line 33618
    texImage->DepthLog2 = (unsigned int )tmp___2;
  }
#line 33619
  texImage->Width2 = (unsigned int )(1 << texImage->WidthLog2);
#line 33620
  texImage->Height2 = (unsigned int )(1 << texImage->HeightLog2);
#line 33621
  texImage->Depth2 = (unsigned int )(1 << texImage->DepthLog2);
#line 33622
  if (texImage->WidthLog2 > texImage->HeightLog2) {
#line 33622
    texImage->MaxLog2 = texImage->WidthLog2;
  } else {
#line 33622
    texImage->MaxLog2 = texImage->HeightLog2;
  }
#line 33623
  tmp___3 = malloc((unsigned int )(numPixels * components___0));//43
#line 33623
  texImage->Data = (GLubyte *)tmp___3;
#line 33624
  if (texImage->Data) {
#line 33625
    message[0][0] = (char )' ';
#line 33625
    message[0][1] = (char )' ';
#line 33625
    message[0][2] = (char )' ';
#line 33625
    message[0][3] = (char )'X';
#line 33625
    message[0][4] = (char )' ';
#line 33625
    message[0][5] = (char )' ';
#line 33625
    message[0][6] = (char )' ';
#line 33625
    message[0][7] = (char )'X';
#line 33625
    message[0][8] = (char )' ';
#line 33625
    message[0][9] = (char )' ';
#line 33625
    message[0][10] = (char )'X';
#line 33625
    message[0][11] = (char )'X';
#line 33625
    message[0][12] = (char )'X';
#line 33625
    message[0][13] = (char )'X';
#line 33625
    message[0][14] = (char )'X';
#line 33625
    message[0][15] = (char )' ';
#line 33625
    message[0][16] = (char )' ';
#line 33625
    message[0][17] = (char )' ';
#line 33625
    message[0][18] = (char )'X';
#line 33625
    message[0][19] = (char )'X';
#line 33625
    message[0][20] = (char )'X';
#line 33625
    message[0][21] = (char )' ';
#line 33625
    message[0][22] = (char )' ';
#line 33625
    message[0][23] = (char )' ';
#line 33625
    message[0][24] = (char )' ';
#line 33625
    message[0][25] = (char )' ';
#line 33625
    message[0][26] = (char )'X';
#line 33625
    message[0][27] = (char )' ';
#line 33625
    message[0][28] = (char )' ';
#line 33625
    message[0][29] = (char )' ';
#line 33625
    message[0][30] = (char )' ';
#line 33625
    message[0][31] = (char )'\000';
#line 33625
    message[1][0] = (char )' ';
#line 33625
    message[1][1] = (char )' ';
#line 33625
    message[1][2] = (char )' ';
#line 33625
    message[1][3] = (char )'X';
#line 33625
    message[1][4] = (char )'X';
#line 33625
    message[1][5] = (char )' ';
#line 33625
    message[1][6] = (char )'X';
#line 33625
    message[1][7] = (char )'X';
#line 33625
    message[1][8] = (char )' ';
#line 33625
    message[1][9] = (char )' ';
#line 33625
    message[1][10] = (char )'X';
#line 33625
    message[1][11] = (char )' ';
#line 33625
    message[1][12] = (char )' ';
#line 33625
    message[1][13] = (char )' ';
#line 33625
    message[1][14] = (char )' ';
#line 33625
    message[1][15] = (char )' ';
#line 33625
    message[1][16] = (char )' ';
#line 33625
    message[1][17] = (char )'X';
#line 33625
    message[1][18] = (char )' ';
#line 33625
    message[1][19] = (char )' ';
#line 33625
    message[1][20] = (char )' ';
#line 33625
    message[1][21] = (char )'X';
#line 33625
    message[1][22] = (char )' ';
#line 33625
    message[1][23] = (char )' ';
#line 33625
    message[1][24] = (char )' ';
#line 33625
    message[1][25] = (char )'X';
#line 33625
    message[1][26] = (char )' ';
#line 33625
    message[1][27] = (char )'X';
#line 33625
    message[1][28] = (char )' ';
#line 33625
    message[1][29] = (char )' ';
#line 33625
    message[1][30] = (char )' ';
#line 33625
    message[1][31] = (char )'\000';
#line 33625
    message[2][0] = (char )' ';
#line 33625
    message[2][1] = (char )' ';
#line 33625
    message[2][2] = (char )' ';
#line 33625
    message[2][3] = (char )'X';
#line 33625
    message[2][4] = (char )' ';
#line 33625
    message[2][5] = (char )'X';
#line 33625
    message[2][6] = (char )' ';
#line 33625
    message[2][7] = (char )'X';
#line 33625
    message[2][8] = (char )' ';
#line 33625
    message[2][9] = (char )' ';
#line 33625
    message[2][10] = (char )'X';
#line 33625
    message[2][11] = (char )' ';
#line 33625
    message[2][12] = (char )' ';
#line 33625
    message[2][13] = (char )' ';
#line 33625
    message[2][14] = (char )' ';
#line 33625
    message[2][15] = (char )' ';
#line 33625
    message[2][16] = (char )' ';
#line 33625
    message[2][17] = (char )'X';
#line 33625
    message[2][18] = (char )' ';
#line 33625
    message[2][19] = (char )' ';
#line 33625
    message[2][20] = (char )' ';
#line 33625
    message[2][21] = (char )' ';
#line 33625
    message[2][22] = (char )' ';
#line 33625
    message[2][23] = (char )' ';
#line 33625
    message[2][24] = (char )'X';
#line 33625
    message[2][25] = (char )' ';
#line 33625
    message[2][26] = (char )' ';
#line 33625
    message[2][27] = (char )' ';
#line 33625
    message[2][28] = (char )'X';
#line 33625
    message[2][29] = (char )' ';
#line 33625
    message[2][30] = (char )' ';
#line 33625
    message[2][31] = (char )'\000';
#line 33625
    message[3][0] = (char )' ';
#line 33625
    message[3][1] = (char )' ';
#line 33625
    message[3][2] = (char )' ';
#line 33625
    message[3][3] = (char )'X';
#line 33625
    message[3][4] = (char )' ';
#line 33625
    message[3][5] = (char )' ';
#line 33625
    message[3][6] = (char )' ';
#line 33625
    message[3][7] = (char )'X';
#line 33625
    message[3][8] = (char )' ';
#line 33625
    message[3][9] = (char )' ';
#line 33625
    message[3][10] = (char )'X';
#line 33625
    message[3][11] = (char )'X';
#line 33625
    message[3][12] = (char )'X';
#line 33625
    message[3][13] = (char )'X';
#line 33625
    message[3][14] = (char )' ';
#line 33625
    message[3][15] = (char )' ';
#line 33625
    message[3][16] = (char )' ';
#line 33625
    message[3][17] = (char )' ';
#line 33625
    message[3][18] = (char )'X';
#line 33625
    message[3][19] = (char )'X';
#line 33625
    message[3][20] = (char )'X';
#line 33625
    message[3][21] = (char )' ';
#line 33625
    message[3][22] = (char )' ';
#line 33625
    message[3][23] = (char )' ';
#line 33625
    message[3][24] = (char )'X';
#line 33625
    message[3][25] = (char )'X';
#line 33625
    message[3][26] = (char )'X';
#line 33625
    message[3][27] = (char )'X';
#line 33625
    message[3][28] = (char )'X';
#line 33625
    message[3][29] = (char )' ';
#line 33625
    message[3][30] = (char )' ';
#line 33625
    message[3][31] = (char )'\000';
#line 33625
    message[4][0] = (char )' ';
#line 33625
    message[4][1] = (char )' ';
#line 33625
    message[4][2] = (char )' ';
#line 33625
    message[4][3] = (char )'X';
#line 33625
    message[4][4] = (char )' ';
#line 33625
    message[4][5] = (char )' ';
#line 33625
    message[4][6] = (char )' ';
#line 33625
    message[4][7] = (char )'X';
#line 33625
    message[4][8] = (char )' ';
#line 33625
    message[4][9] = (char )' ';
#line 33625
    message[4][10] = (char )'X';
#line 33625
    message[4][11] = (char )' ';
#line 33625
    message[4][12] = (char )' ';
#line 33625
    message[4][13] = (char )' ';
#line 33625
    message[4][14] = (char )' ';
#line 33625
    message[4][15] = (char )' ';
#line 33625
    message[4][16] = (char )' ';
#line 33625
    message[4][17] = (char )' ';
#line 33625
    message[4][18] = (char )' ';
#line 33625
    message[4][19] = (char )' ';
#line 33625
    message[4][20] = (char )' ';
#line 33625
    message[4][21] = (char )'X';
#line 33625
    message[4][22] = (char )' ';
#line 33625
    message[4][23] = (char )' ';
#line 33625
    message[4][24] = (char )'X';
#line 33625
    message[4][25] = (char )' ';
#line 33625
    message[4][26] = (char )' ';
#line 33625
    message[4][27] = (char )' ';
#line 33625
    message[4][28] = (char )'X';
#line 33625
    message[4][29] = (char )' ';
#line 33625
    message[4][30] = (char )' ';
#line 33625
    message[4][31] = (char )'\000';
#line 33625
    message[5][0] = (char )' ';
#line 33625
    message[5][1] = (char )' ';
#line 33625
    message[5][2] = (char )' ';
#line 33625
    message[5][3] = (char )'X';
#line 33625
    message[5][4] = (char )' ';
#line 33625
    message[5][5] = (char )' ';
#line 33625
    message[5][6] = (char )' ';
#line 33625
    message[5][7] = (char )'X';
#line 33625
    message[5][8] = (char )' ';
#line 33625
    message[5][9] = (char )' ';
#line 33625
    message[5][10] = (char )'X';
#line 33625
    message[5][11] = (char )' ';
#line 33625
    message[5][12] = (char )' ';
#line 33625
    message[5][13] = (char )' ';
#line 33625
    message[5][14] = (char )' ';
#line 33625
    message[5][15] = (char )' ';
#line 33625
    message[5][16] = (char )' ';
#line 33625
    message[5][17] = (char )'X';
#line 33625
    message[5][18] = (char )' ';
#line 33625
    message[5][19] = (char )' ';
#line 33625
    message[5][20] = (char )' ';
#line 33625
    message[5][21] = (char )'X';
#line 33625
    message[5][22] = (char )' ';
#line 33625
    message[5][23] = (char )' ';
#line 33625
    message[5][24] = (char )'X';
#line 33625
    message[5][25] = (char )' ';
#line 33625
    message[5][26] = (char )' ';
#line 33625
    message[5][27] = (char )' ';
#line 33625
    message[5][28] = (char )'X';
#line 33625
    message[5][29] = (char )' ';
#line 33625
    message[5][30] = (char )' ';
#line 33625
    message[5][31] = (char )'\000';
#line 33625
    message[6][0] = (char )' ';
#line 33625
    message[6][1] = (char )' ';
#line 33625
    message[6][2] = (char )' ';
#line 33625
    message[6][3] = (char )'X';
#line 33625
    message[6][4] = (char )' ';
#line 33625
    message[6][5] = (char )' ';
#line 33625
    message[6][6] = (char )' ';
#line 33625
    message[6][7] = (char )'X';
#line 33625
    message[6][8] = (char )' ';
#line 33625
    message[6][9] = (char )' ';
#line 33625
    message[6][10] = (char )'X';
#line 33625
    message[6][11] = (char )'X';
#line 33625
    message[6][12] = (char )'X';
#line 33625
    message[6][13] = (char )'X';
#line 33625
    message[6][14] = (char )'X';
#line 33625
    message[6][15] = (char )' ';
#line 33625
    message[6][16] = (char )' ';
#line 33625
    message[6][17] = (char )' ';
#line 33625
    message[6][18] = (char )'X';
#line 33625
    message[6][19] = (char )'X';
#line 33625
    message[6][20] = (char )'X';
#line 33625
    message[6][21] = (char )' ';
#line 33625
    message[6][22] = (char )' ';
#line 33625
    message[6][23] = (char )' ';
#line 33625
    message[6][24] = (char )'X';
#line 33625
    message[6][25] = (char )' ';
#line 33625
    message[6][26] = (char )' ';
#line 33625
    message[6][27] = (char )' ';
#line 33625
    message[6][28] = (char )'X';
#line 33625
    message[6][29] = (char )' ';
#line 33625
    message[6][30] = (char )' ';
#line 33625
    message[6][31] = (char )'\000';
#line 33625
    message[7][0] = (char )' ';
#line 33625
    message[7][1] = (char )' ';
#line 33625
    message[7][2] = (char )' ';
#line 33625
    message[7][3] = (char )' ';
#line 33625
    message[7][4] = (char )' ';
#line 33625
    message[7][5] = (char )' ';
#line 33625
    message[7][6] = (char )' ';
#line 33625
    message[7][7] = (char )' ';
#line 33625
    message[7][8] = (char )' ';
#line 33625
    message[7][9] = (char )' ';
#line 33625
    message[7][10] = (char )' ';
#line 33625
    message[7][11] = (char )' ';
#line 33625
    message[7][12] = (char )' ';
#line 33625
    message[7][13] = (char )' ';
#line 33625
    message[7][14] = (char )' ';
#line 33625
    message[7][15] = (char )' ';
#line 33625
    message[7][16] = (char )' ';
#line 33625
    message[7][17] = (char )' ';
#line 33625
    message[7][18] = (char )' ';
#line 33625
    message[7][19] = (char )' ';
#line 33625
    message[7][20] = (char )' ';
#line 33625
    message[7][21] = (char )' ';
#line 33625
    message[7][22] = (char )' ';
#line 33625
    message[7][23] = (char )' ';
#line 33625
    message[7][24] = (char )' ';
#line 33625
    message[7][25] = (char )' ';
#line 33625
    message[7][26] = (char )' ';
#line 33625
    message[7][27] = (char )' ';
#line 33625
    message[7][28] = (char )' ';
#line 33625
    message[7][29] = (char )' ';
#line 33625
    message[7][30] = (char )' ';
#line 33625
    message[7][31] = (char )'\000';
#line 33635
    imgPtr = texImage->Data;
#line 33637
    i = 0;
#line 33637
    while (i < height) {
#line 33638
      srcRow = 7 - i % 8;
#line 33639
      j = 0;
#line 33639
      while (j < width) {
#line 33640
        srcCol = j % 32;
#line 33641
        if ((int )message[srcRow][srcCol] == 88) {
#line 33641
          tmp___4 = 255;
        } else {
#line 33641
          tmp___4 = 70;
        }
#line 33641
        texel = (GLubyte )tmp___4;
#line 33642
        k = 0;
#line 33642
        while (k < components___0) {
#line 33643
          tmp___5 = imgPtr;
#line 33643
          imgPtr ++;
#line 33643
          *tmp___5 = texel;
#line 33642
          k ++;
        }
#line 33639
        j ++;
      }
#line 33637
      i ++;
    }
  }
#line 33648
  return (texImage);
}
}
#line 33650 "D:/a/test/177.c"
static GLboolean texture_1d_error_check(GLcontext *ctx , GLenum target , GLint level ,
                                        GLenum internalFormat , GLenum format , GLenum type ,
                                        GLint width , GLint border ) 
{ GLint iformat ;
  int tmp___0 ;

  {
#line 33656
  if (target != 3552) {
#line 33656
    if (target != 32867) {
#line 33657
      gl_error(ctx, 1280, "glTexImage1D");
#line 33658
      return ((unsigned char)1);
    }
  }
#line 33660
  if (level < 0) {
#line 33661
    gl_error(ctx, 1281, "glTexImage1D(level)");
#line 33662
    return ((unsigned char)1);
  } else {
#line 33660
    if (level >= 11) {
#line 33661
      gl_error(ctx, 1281, "glTexImage1D(level)");
#line 33662
      return ((unsigned char)1);
    }
  }
#line 33664
  iformat = decode_internal_format1(internalFormat);
#line 33665
  if (iformat < 0) {
#line 33666
    gl_error(ctx, 1281, "glTexImage1D(internalFormat)");
#line 33667
    return ((unsigned char)1);
  }
#line 33669
  if (border != 0) {
#line 33669
    if (border != 1) {
#line 33670
      if (target != 32867) {
#line 33671
        gl_error(ctx, 1281, "glTexImage1D(border)");
      }
#line 33673
      return ((unsigned char)1);
    }
  }
#line 33675
  if (width < 2 * border) {
    goto _L;
  } else {
#line 33675
    if (width > 2 + (1 << 10)) {
      _L: /* CIL Label */ 
#line 33676
      if (target != 32867) {
#line 33677
        gl_error(ctx, 1281, "glTexImage1D(width)");
      }
#line 33679
      return ((unsigned char)1);
    }
  }
#line 33681
  tmp___0 = logbase2(width - 2 * border);
#line 33681
  if (tmp___0 < 0) {
#line 33682
    gl_error(ctx, 1281, "glTexImage1D(width != 2^k + 2*border)");
#line 33684
    return ((unsigned char)1);
  }
#line 33686
  switch (format) {
  case 6400: 
  case 6403: 
  case 6404: 
  case 6405: 
  case 6406: 
  case 6407: 
  case 6408: 
  case 6409: 
  case 6410: 
#line 33696
  break;
  default: 
#line 33698
  gl_error(ctx, 1280, "glTexImage1D(format)");
#line 33699
  return ((unsigned char)1);
  }
#line 33701
  switch (type) {
  case 5121: 
  case 5120: 
  case 5123: 
  case 5122: 
  case 5126: 
#line 33707
  break;
  default: 
#line 33709
  gl_error(ctx, 1280, "glTexImage1D(type)");
#line 33710
  return ((unsigned char)1);
  }
#line 33712
  return ((unsigned char)0);
}
}
#line 33714 "D:/a/test/177.c"
static GLboolean texture_2d_error_check(GLcontext *ctx , GLenum target , GLint level ,
                                        GLenum internalFormat , GLenum format , GLenum type ,
                                        GLint width , GLint height , GLint border ) 
{ GLint iformat ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 33721
  if (target != 3553) {
#line 33721
    if (target != 32868) {
#line 33722
      gl_error(ctx, 1280, "glTexImage2D(target)");
#line 33723
      return ((unsigned char)1);
    }
  }
#line 33725
  if (level < 0) {
#line 33726
    gl_error(ctx, 1281, "glTexImage2D(level)");
#line 33727
    return ((unsigned char)1);
  } else {
#line 33725
    if (level >= 11) {
#line 33726
      gl_error(ctx, 1281, "glTexImage2D(level)");
#line 33727
      return ((unsigned char)1);
    }
  }
#line 33729
  iformat = decode_internal_format1(internalFormat);
#line 33730
  if (iformat < 0) {
#line 33731
    gl_error(ctx, 1281, "glTexImage2D(internalFormat)");
#line 33732
    return ((unsigned char)1);
  }
#line 33734
  if (border != 0) {
#line 33734
    if (border != 1) {
#line 33735
      if (target != 32868) {
#line 33736
        gl_error(ctx, 1281, "glTexImage2D(border)");
      }
#line 33738
      return ((unsigned char)1);
    }
  }
#line 33740
  if (width < 2 * border) {
    goto _L;
  } else {
#line 33740
    if (width > 2 + (1 << 10)) {
      _L: /* CIL Label */ 
#line 33741
      if (target != 32868) {
#line 33742
        gl_error(ctx, 1281, "glTexImage2D(width)");
      }
#line 33744
      return ((unsigned char)1);
    }
  }
#line 33746
  if (height < 2 * border) {
    goto _L___0;
  } else {
#line 33746
    if (height > 2 + (1 << 10)) {
      _L___0: /* CIL Label */ 
#line 33747
      if (target != 32868) {
#line 33748
        gl_error(ctx, 1281, "glTexImage2D(height)");
      }
#line 33750
      return ((unsigned char)1);
    }
  }
#line 33752
  tmp___0 = logbase2(width - 2 * border);
#line 33752
  if (tmp___0 < 0) {
#line 33753
    gl_error(ctx, 1281, "glTexImage2D(width != 2^k + 2*border)");
#line 33755
    return ((unsigned char)1);
  }
#line 33757
  tmp___1 = logbase2(height - 2 * border);
#line 33757
  if (tmp___1 < 0) {
#line 33758
    gl_error(ctx, 1281, "glTexImage2D(height != 2^k + 2*border)");
#line 33760
    return ((unsigned char)1);
  }
#line 33762
  switch (format) {
  case 6400: 
  case 6403: 
  case 6404: 
  case 6405: 
  case 6406: 
  case 6407: 
  case 6408: 
  case 6409: 
  case 6410: 
#line 33772
  break;
  default: 
#line 33774
  gl_error(ctx, 1280, "glTexImage2D(format)");
#line 33775
  return ((unsigned char)1);
  }
#line 33777
  switch (type) {
  case 5121: 
  case 5120: 
  case 5123: 
  case 5122: 
  case 5125: 
  case 5124: 
  case 5126: 
#line 33785
  break;
  default: 
#line 33787
  gl_error(ctx, 1280, "glTexImage2D(type)");
#line 33788
  return ((unsigned char)1);
  }
#line 33790
  return ((unsigned char)0);
}
}
#line 33792 "D:/a/test/177.c"
static GLboolean texture_3d_error_check(GLcontext *ctx , GLenum target , GLint level ,
                                        GLenum internalFormat , GLenum format , GLenum type ,
                                        GLint width , GLint height , GLint depth ,
                                        GLint border ) 
{ GLint iformat ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 33799
  if (target != 32879) {
#line 33799
    if (target != 32880) {
#line 33800
      gl_error(ctx, 1280, "glTexImage3DEXT(target)");
#line 33801
      return ((unsigned char)1);
    }
  }
#line 33803
  if (level < 0) {
#line 33804
    gl_error(ctx, 1281, "glTexImage3DEXT(level)");
#line 33805
    return ((unsigned char)1);
  } else {
#line 33803
    if (level >= 11) {
#line 33804
      gl_error(ctx, 1281, "glTexImage3DEXT(level)");
#line 33805
      return ((unsigned char)1);
    }
  }
#line 33807
  iformat = decode_internal_format1(internalFormat);
#line 33808
  if (iformat < 0) {
#line 33809
    gl_error(ctx, 1281, "glTexImage3DEXT(internalFormat)");
#line 33810
    return ((unsigned char)1);
  }
#line 33812
  if (border != 0) {
#line 33812
    if (border != 1) {
#line 33813
      if (target != 32880) {
#line 33814
        gl_error(ctx, 1281, "glTexImage3DEXT(border)");
      }
#line 33816
      return ((unsigned char)1);
    }
  }
#line 33818
  if (width < 2 * border) {
    goto _L;
  } else {
#line 33818
    if (width > 2 + (1 << 10)) {
      _L: /* CIL Label */ 
#line 33819
      if (target != 32880) {
#line 33820
        gl_error(ctx, 1281, "glTexImage3DEXT(width)");
      }
#line 33822
      return ((unsigned char)1);
    }
  }
#line 33824
  if (height < 2 * border) {
    goto _L___0;
  } else {
#line 33824
    if (height > 2 + (1 << 10)) {
      _L___0: /* CIL Label */ 
#line 33825
      if (target != 32880) {
#line 33826
        gl_error(ctx, 1281, "glTexImage3DEXT(height)");
      }
#line 33828
      return ((unsigned char)1);
    }
  }
#line 33830
  if (depth < 2 * border) {
    goto _L___1;
  } else {
#line 33830
    if (depth > 2 + (1 << 10)) {
      _L___1: /* CIL Label */ 
#line 33831
      if (target != 32880) {
#line 33832
        gl_error(ctx, 1281, "glTexImage3DEXT(depth)");
      }
#line 33834
      return ((unsigned char)1);
    }
  }
#line 33836
  tmp___0 = logbase2(width - 2 * border);
#line 33836
  if (tmp___0 < 0) {
#line 33837
    gl_error(ctx, 1281, "glTexImage3DEXT(width != 2^k + 2*border))");
#line 33839
    return ((unsigned char)1);
  }
#line 33841
  tmp___1 = logbase2(height - 2 * border);
#line 33841
  if (tmp___1 < 0) {
#line 33842
    gl_error(ctx, 1281, "glTexImage3DEXT(height != 2^k + 2*border))");
#line 33844
    return ((unsigned char)1);
  }
#line 33846
  tmp___2 = logbase2(depth - 2 * border);
#line 33846
  if (tmp___2 < 0) {
#line 33847
    gl_error(ctx, 1281, "glTexImage3DEXT(depth  != 2^k + 2*border))");
#line 33849
    return ((unsigned char)1);
  }
#line 33851
  switch (format) {
  case 6400: 
  case 6403: 
  case 6404: 
  case 6405: 
  case 6406: 
  case 6407: 
  case 6408: 
  case 6409: 
  case 6410: 
#line 33861
  break;
  default: 
#line 33863
  gl_error(ctx, 1280, "glTexImage3DEXT(format)");
#line 33864
  return ((unsigned char)1);
  }
#line 33866
  switch (type) {
  case 5121: 
  case 5120: 
  case 5123: 
  case 5122: 
  case 5125: 
  case 5124: 
  case 5126: 
#line 33874
  break;
  default: 
#line 33876
  gl_error(ctx, 1280, "glTexImage3DEXT(type)");
#line 33877
  return ((unsigned char)1);
  }
#line 33879
  return ((unsigned char)0);
}
}
#line 33881 "D:/a/test/177.c"
void gl_TexImage1D(GLcontext *ctx , GLenum target , GLint level , GLint internalformat ,
                   GLsizei width , GLint border , GLenum format , GLenum type , struct gl_image *image ) 
{ struct gl_texture_image *teximage ;
  GLboolean tmp___0 ;
  GLboolean tmp___1 ;

  {
#line 33886
  if (ctx->Primitive != 6656) {
#line 33887
    gl_error(ctx, 1282, "glTexImage1D");
#line 33888
    return;
  }
#line 33890
  if (target == 3552) {
#line 33892
    tmp___0 = texture_1d_error_check(ctx, target, level, internalformat, format, type,
                                     width, border);
#line 33892
    if (tmp___0) {
#line 33894
      return;
    }
#line 33896
    if ((ctx->Texture.Current1D)->Image[level]) {
#line 33897
      gl_free_texture_image((ctx->Texture.Current1D)->Image[level]);
    }
#line 33899
    if (image) {
#line 33900
      teximage = image_to_texture(ctx, (struct gl_image  const  *)image, internalformat,
                                  border);
    } else {
#line 33903
      teximage = make_null_texture(ctx, internalformat, width, 1, 1, border);
    }
#line 33906
    (ctx->Texture.Current1D)->Image[level] = teximage;
#line 33907
    (ctx->Texture.Current1D)->Dirty = (unsigned char)1;
#line 33908
    ctx->NewState |= 4U;
#line 33909
    if (image) {
#line 33909
      if (image->RefCount == 0) {
#line 33910
        gl_free_image(image);
      }
    }
#line 33912
    if (ctx->Driver.TexImage) {
#line 33913
      (*(ctx->Driver.TexImage))(ctx, 3552, ctx->Texture.Current1D, level, internalformat,
                                (struct gl_texture_image  const  *)teximage);
    }
  } else {
#line 33918
    if (target == 32867) {
#line 33919
      tmp___1 = texture_1d_error_check(ctx, target, level, internalformat, format,
                                       type, width, border);
#line 33919
      if (tmp___1) {
#line 33921
        if (level >= 0) {
#line 33921
          if (level < 11) {
#line 33922
            memset((void *)(ctx->Texture.Proxy1D)->Image[level], 0, sizeof(struct gl_texture_image ));
          }
        }
      } else {
#line 33927
        ((ctx->Texture.Proxy1D)->Image[level])->Format = internalformat;
#line 33928
        ((ctx->Texture.Proxy1D)->Image[level])->Border = (unsigned int )border;
#line 33929
        ((ctx->Texture.Proxy1D)->Image[level])->Width = (unsigned int )width;
#line 33930
        ((ctx->Texture.Proxy1D)->Image[level])->Height = 1U;
      }
#line 33932
      if (image->RefCount == 0) {
#line 33933
        gl_free_image(image);
      }
    } else {
#line 33937
      gl_error(ctx, 1280, "glTexImage1D(target)");
#line 33938
      return;
    }
  }
#line 33940
  return;
}
}
#line 33941 "D:/a/test/177.c"
void gl_TexImage2D(GLcontext *ctx , GLenum target , GLint level , GLint internalformat ,
                   GLsizei width , GLsizei height , GLint border , GLenum format ,
                   GLenum type , struct gl_image *image ) 
{ struct gl_texture_image *teximage ;
  GLboolean tmp___0 ;
  GLboolean tmp___1 ;

  {
#line 33947
  if (ctx->Primitive != 6656) {
#line 33948
    gl_error(ctx, 1282, "glTexImage2D");
#line 33949
    return;
  }
#line 33951
  if (target == 3553) {
#line 33953
    tmp___0 = texture_2d_error_check(ctx, target, level, internalformat, format, type,
                                     width, height, border);
#line 33953
    if (tmp___0) {
#line 33955
      return;
    }
#line 33957
    if ((ctx->Texture.Current2D)->Image[level]) {
#line 33958
      gl_free_texture_image((ctx->Texture.Current2D)->Image[level]);
    }
#line 33960
    if (image) {
#line 33961
      teximage = image_to_texture(ctx, (struct gl_image  const  *)image, internalformat,
                                  border);
    } else {
#line 33964
      teximage = make_null_texture(ctx, internalformat, width, height, 1, border);
    }
#line 33967
    (ctx->Texture.Current2D)->Image[level] = teximage;
#line 33968
    (ctx->Texture.Current2D)->Dirty = (unsigned char)1;
#line 33969
    ctx->NewState |= 4U;
#line 33970
    if (image) {
#line 33970
      if (image->RefCount == 0) {
#line 33971
        gl_free_image(image);
      }
    }
#line 33973
    if (ctx->Driver.TexImage) {
#line 33974
      (*(ctx->Driver.TexImage))(ctx, 3553, ctx->Texture.Current2D, level, internalformat,
                                (struct gl_texture_image  const  *)teximage);
    }
  } else {
#line 33979
    if (target == 32868) {
#line 33980
      tmp___1 = texture_2d_error_check(ctx, target, level, internalformat, format,
                                       type, width, height, border);
#line 33980
      if (tmp___1) {
#line 33982
        if (level >= 0) {
#line 33982
          if (level < 11) {
#line 33983
            memset((void *)(ctx->Texture.Proxy2D)->Image[level], 0, sizeof(struct gl_texture_image ));
          }
        }
      } else {
#line 33988
        ((ctx->Texture.Proxy2D)->Image[level])->Format = internalformat;
#line 33989
        ((ctx->Texture.Proxy2D)->Image[level])->Border = (unsigned int )border;
#line 33990
        ((ctx->Texture.Proxy2D)->Image[level])->Width = (unsigned int )width;
#line 33991
        ((ctx->Texture.Proxy2D)->Image[level])->Height = (unsigned int )height;
      }
#line 33993
      if (image->RefCount == 0) {
#line 33994
        gl_free_image(image);
      }
    } else {
#line 33998
      gl_error(ctx, 1280, "glTexImage2D(target)");
#line 33999
      return;
    }
  }
#line 34001
  return;
}
}
#line 34002 "D:/a/test/177.c"
void gl_TexImage3DEXT(GLcontext *ctx , GLenum target , GLint level , GLint internalformat ,
                      GLsizei width , GLsizei height , GLsizei depth , GLint border ,
                      GLenum format , GLenum type , struct gl_image *image ) 
{ struct gl_texture_image *teximage ;
  GLboolean tmp___0 ;
  GLboolean tmp___1 ;

  {
#line 34008
  if (ctx->Primitive != 6656) {
#line 34009
    gl_error(ctx, 1282, "glTexImage3DEXT");
#line 34010
    return;
  }
#line 34012
  if (target == 32879) {
#line 34014
    tmp___0 = texture_3d_error_check(ctx, target, level, internalformat, format, type,
                                     width, height, depth, border);
#line 34014
    if (tmp___0) {
#line 34017
      return;
    }
#line 34019
    if ((ctx->Texture.Current3D)->Image[level]) {
#line 34020
      gl_free_texture_image((ctx->Texture.Current3D)->Image[level]);
    }
#line 34022
    if (image) {
#line 34023
      teximage = image_to_texture(ctx, (struct gl_image  const  *)image, internalformat,
                                  border);
    } else {
#line 34026
      teximage = make_null_texture(ctx, internalformat, width, height, depth, border);
    }
#line 34029
    (ctx->Texture.Current3D)->Image[level] = teximage;
#line 34030
    (ctx->Texture.Current3D)->Dirty = (unsigned char)1;
#line 34031
    ctx->NewState |= 4U;
#line 34032
    if (image) {
#line 34032
      if (image->RefCount == 0) {
#line 34033
        gl_free_image(image);
      }
    }
#line 34035
    if (ctx->Driver.TexImage) {
#line 34036
      (*(ctx->Driver.TexImage))(ctx, 32879, ctx->Texture.Current3D, level, internalformat,
                                (struct gl_texture_image  const  *)teximage);
    }
  } else {
#line 34041
    if (target == 32880) {
#line 34042
      tmp___1 = texture_3d_error_check(ctx, target, level, internalformat, format,
                                       type, width, height, depth, border);
#line 34042
      if (tmp___1) {
#line 34045
        if (level >= 0) {
#line 34045
          if (level < 11) {
#line 34046
            memset((void *)(ctx->Texture.Proxy3D)->Image[level], 0, sizeof(struct gl_texture_image ));
          }
        }
      } else {
#line 34051
        ((ctx->Texture.Proxy3D)->Image[level])->Format = internalformat;
#line 34052
        ((ctx->Texture.Proxy3D)->Image[level])->Border = (unsigned int )border;
#line 34053
        ((ctx->Texture.Proxy3D)->Image[level])->Width = (unsigned int )width;
#line 34054
        ((ctx->Texture.Proxy3D)->Image[level])->Height = (unsigned int )height;
#line 34055
        ((ctx->Texture.Proxy3D)->Image[level])->Depth = (unsigned int )depth;
      }
#line 34057
      if (image->RefCount == 0) {
#line 34058
        gl_free_image(image);
      }
    } else {
#line 34062
      gl_error(ctx, 1280, "glTexImage3DEXT(target)");
#line 34063
      return;
    }
  }
#line 34065
  return;
}
}
#line 34066 "D:/a/test/177.c"
void gl_GetTexImage(GLcontext *ctx , GLenum target , GLint level , GLenum format ,
                    GLenum type , GLvoid *pixels ) 
{ 

  {
#line 34069
  gl_problem((GLcontext const   *)ctx, "glGetTexImage not implemented");
#line 34070
  return;
}
}
#line 34071 "D:/a/test/177.c"
struct gl_image *gl_unpack_texsubimage(GLcontext *ctx , GLint width , GLint height ,
                                       GLint depth , GLenum format , GLenum type ,
                                       GLvoid const   *pixels ) 
{ GLint tmp___0 ;
  struct gl_image *tmp___1 ;

  {
#line 34075
  if (type == 6656) {
#line 34075
    if (format != 6400) {
#line 34076
      return ((struct gl_image *)((void *)0));
    }
  }
#line 34078
  if (format == 6401) {
#line 34079
    return ((struct gl_image *)((void *)0));
  } else {
#line 34078
    if (format == 6402) {
#line 34079
      return ((struct gl_image *)((void *)0));
    }
  }
#line 34081
  tmp___0 = gl_sizeof_type(type);
#line 34081
  if (tmp___0 <= 0) {
#line 34082
    return ((struct gl_image *)((void *)0));
  }
#line 34084
  tmp___1 = gl_unpack_image3D(ctx, width, height, depth, format, type, pixels);
#line 34084
  return (tmp___1);
}
}
#line 34086 "D:/a/test/177.c"
void gl_TexSubImage1D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                      GLsizei width , GLenum format , GLenum type , struct gl_image *image ) 
{ struct gl_texture_image *destTex ;
  GLint texcomponents ;
  GLint tmp___0 ;
  GLubyte *dst ;
  GLubyte *src ;
  struct gl_texture_image *subTexImg ;
  struct gl_texture_image *tmp___1 ;
  GLubyte *dst___0 ;
  GLubyte *src___0 ;
  GLint components___0 ;
  GLint size ;

  {
#line 34092
  if (target != 3552) {
#line 34093
    gl_error(ctx, 1280, "glTexSubImage1D(target)");
#line 34094
    return;
  }
#line 34096
  if (level < 0) {
#line 34097
    gl_error(ctx, 1280, "glTexSubImage1D(level)");
#line 34098
    return;
  } else {
#line 34096
    if (level >= 11) {
#line 34097
      gl_error(ctx, 1280, "glTexSubImage1D(level)");
#line 34098
      return;
    }
  }
#line 34100
  destTex = (ctx->Texture.Current1D)->Image[level];
#line 34101
  if (! destTex) {
#line 34102
    gl_error(ctx, 1282, "glTexSubImage1D");
#line 34103
    return;
  }
#line 34105
  if ((GLuint )xoffset < - destTex->Border) {
#line 34106
    gl_error(ctx, 1281, "glTexSubImage1D(xoffset)");
#line 34107
    return;
  }
#line 34109
  if ((GLuint )(xoffset + width) > destTex->Width + destTex->Border) {
#line 34110
    gl_error(ctx, 1281, "glTexSubImage1D(xoffset+width)");
#line 34111
    return;
  }
#line 34113
  if (image) {
#line 34114
    tmp___0 = components_in_intformat(destTex->Format);
#line 34114
    texcomponents = tmp___0;
#line 34115
    if (image->Type == 5121) {
#line 34115
      if (texcomponents == image->Components) {
#line 34116
        dst = destTex->Data + texcomponents * xoffset;
#line 34117
        src = (GLubyte *)image->Data;
#line 34118
        memcpy((void *)dst, (void const   *)((void *)src), (unsigned int )(width * texcomponents));
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 34121
      tmp___1 = image_to_texture(ctx, (struct gl_image  const  *)image, destTex->IntFormat,
                                 (int )destTex->Border);
#line 34121
      subTexImg = tmp___1;
#line 34123
      dst___0 = destTex->Data + texcomponents * xoffset;
#line 34124
      src___0 = subTexImg->Data;
#line 34125
      memcpy((void *)dst___0, (void const   *)((void *)src___0), (unsigned int )(width * texcomponents));
#line 34126
      gl_free_texture_image(subTexImg);
    }
#line 34128
    if (image->RefCount == 0) {
#line 34129
      gl_free_image(image);
    }
#line 34131
    (ctx->Texture.Current1D)->Dirty = (unsigned char)1;
#line 34132
    if (ctx->Driver.TexImage) {
#line 34133
      (*(ctx->Driver.TexImage))(ctx, 3552, ctx->Texture.Current1D, level, ((ctx->Texture.Current1D)->Image[level])->IntFormat,
                                (struct gl_texture_image  const  *)destTex);
    }
  } else {
#line 34141
    if (width < 0) {
#line 34142
      gl_error(ctx, 1281, "glTexSubImage1D(width)");
#line 34143
      return;
    }
#line 34145
    if (type == 6656) {
#line 34145
      if (format != 6400) {
#line 34146
        gl_error(ctx, 1280, "glTexSubImage1D(format)");
#line 34147
        return;
      }
    }
#line 34149
    components___0 = components_in_intformat(format);
#line 34150
    if (components___0 < 0) {
#line 34152
      gl_error(ctx, 1280, "glTexSubImage1D(format)");
#line 34153
      return;
    } else {
#line 34150
      if (format == 6401) {
#line 34152
        gl_error(ctx, 1280, "glTexSubImage1D(format)");
#line 34153
        return;
      } else {
#line 34150
        if (format == 6402) {
#line 34152
          gl_error(ctx, 1280, "glTexSubImage1D(format)");
#line 34153
          return;
        }
      }
    }
#line 34155
    size = gl_sizeof_type(type);
#line 34156
    if (size <= 0) {
#line 34157
      gl_error(ctx, 1280, "glTexSubImage1D(type)");
#line 34158
      return;
    }
#line 34160
    gl_error(ctx, 1285, "glTexSubImage1D");
  }
#line 34162
  return;
}
}
#line 34163 "D:/a/test/177.c"
void gl_TexSubImage2D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                      GLint yoffset , GLsizei width , GLsizei height , GLenum format ,
                      GLenum type , struct gl_image *image ) 
{ struct gl_texture_image *destTex ;
  GLint texcomponents ;
  GLint tmp___0 ;
  GLubyte *dst ;
  GLubyte *src ;
  GLint j ;
  struct gl_texture_image *subTexImg ;
  struct gl_texture_image *tmp___1 ;
  GLubyte *dst___0 ;
  GLubyte *src___0 ;
  GLint j___0 ;
  GLint components___0 ;
  GLint size ;

  {
#line 34171
  if (target != 3553) {
#line 34172
    gl_error(ctx, 1280, "glTexSubImage2D(target)");
#line 34173
    return;
  }
#line 34175
  if (level < 0) {
#line 34176
    gl_error(ctx, 1280, "glTexSubImage2D(level)");
#line 34177
    return;
  } else {
#line 34175
    if (level >= 11) {
#line 34176
      gl_error(ctx, 1280, "glTexSubImage2D(level)");
#line 34177
      return;
    }
  }
#line 34179
  destTex = (ctx->Texture.Current2D)->Image[level];
#line 34180
  if (! destTex) {
#line 34181
    gl_error(ctx, 1282, "glTexSubImage2D");
#line 34182
    return;
  }
#line 34184
  if ((GLuint )xoffset < - destTex->Border) {
#line 34185
    gl_error(ctx, 1281, "glTexSubImage2D(xoffset)");
#line 34186
    return;
  }
#line 34188
  if ((GLuint )yoffset < - destTex->Border) {
#line 34189
    gl_error(ctx, 1281, "glTexSubImage2D(yoffset)");
#line 34190
    return;
  }
#line 34192
  if ((GLuint )(xoffset + width) > destTex->Width + destTex->Border) {
#line 34193
    gl_error(ctx, 1281, "glTexSubImage2D(xoffset+width)");
#line 34194
    return;
  }
#line 34196
  if ((GLuint )(yoffset + height) > destTex->Height + destTex->Border) {
#line 34197
    gl_error(ctx, 1281, "glTexSubImage2D(yoffset+height)");
#line 34198
    return;
  }
#line 34200
  if (image) {
#line 34201
    tmp___0 = components_in_intformat(destTex->Format);
#line 34201
    texcomponents = tmp___0;
#line 34202
    if (image->Type == 5121) {
#line 34202
      if (texcomponents == image->Components) {
#line 34203
        dst = destTex->Data + ((GLuint )yoffset * destTex->Width + (GLuint )xoffset) * (GLuint )texcomponents;
#line 34205
        src = (GLubyte *)image->Data;
#line 34207
        j = 0;
#line 34207
        while (j < height) {
#line 34208
          memcpy((void *)dst, (void const   *)((void *)src), (unsigned int )(width * texcomponents));
#line 34209
          dst += (destTex->Width * (GLuint )texcomponents) * sizeof(GLubyte );
#line 34210
          src += (unsigned int )(width * texcomponents) * sizeof(GLubyte );
#line 34207
          j ++;
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 34214
      tmp___1 = image_to_texture(ctx, (struct gl_image  const  *)image, destTex->IntFormat,
                                 (int )destTex->Border);
#line 34214
      subTexImg = tmp___1;
#line 34216
      dst___0 = destTex->Data + ((GLuint )yoffset * destTex->Width + (GLuint )xoffset) * (GLuint )texcomponents;
#line 34218
      src___0 = subTexImg->Data;
#line 34220
      j___0 = 0;
#line 34220
      while (j___0 < height) {
#line 34221
        memcpy((void *)dst___0, (void const   *)((void *)src___0), (unsigned int )(width * texcomponents));
#line 34222
        dst___0 += (destTex->Width * (GLuint )texcomponents) * sizeof(GLubyte );
#line 34223
        src___0 += (unsigned int )(width * texcomponents) * sizeof(GLubyte );
#line 34220
        j___0 ++;
      }
#line 34225
      gl_free_texture_image(subTexImg);
    }
#line 34227
    if (image->RefCount == 0) {
#line 34228
      gl_free_image(image);
    }
#line 34230
    (ctx->Texture.Current2D)->Dirty = (unsigned char)1;
#line 34231
    if (ctx->Driver.TexImage) {
#line 34232
      (*(ctx->Driver.TexImage))(ctx, 3553, ctx->Texture.Current2D, level, ((ctx->Texture.Current2D)->Image[level])->IntFormat,
                                (struct gl_texture_image  const  *)destTex);
    }
  } else {
#line 34239
    if (width < 0) {
#line 34240
      gl_error(ctx, 1281, "glTexSubImage2D(width)");
#line 34241
      return;
    }
#line 34243
    if (height < 0) {
#line 34244
      gl_error(ctx, 1281, "glTexSubImage2D(height)");
#line 34245
      return;
    }
#line 34247
    if (type == 6656) {
#line 34247
      if (format != 6400) {
#line 34248
        gl_error(ctx, 1280, "glTexSubImage1D(format)");
#line 34249
        return;
      }
    }
#line 34251
    components___0 = gl_components_in_format(format);
#line 34252
    if (components___0 < 0) {
#line 34254
      gl_error(ctx, 1280, "glTexSubImage2D(format)");
#line 34255
      return;
    } else {
#line 34252
      if (format == 6401) {
#line 34254
        gl_error(ctx, 1280, "glTexSubImage2D(format)");
#line 34255
        return;
      } else {
#line 34252
        if (format == 6402) {
#line 34254
          gl_error(ctx, 1280, "glTexSubImage2D(format)");
#line 34255
          return;
        }
      }
    }
#line 34257
    size = gl_sizeof_type(type);
#line 34258
    if (size <= 0) {
#line 34259
      gl_error(ctx, 1280, "glTexSubImage2D(type)");
#line 34260
      return;
    }
#line 34262
    gl_error(ctx, 1285, "glTexSubImage2D");
  }
#line 34264
  return;
}
}
#line 34265 "D:/a/test/177.c"
void gl_TexSubImage3DEXT(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                         GLint yoffset , GLint zoffset , GLsizei width , GLsizei height ,
                         GLsizei depth , GLenum format , GLenum type , struct gl_image *image ) 
{ struct gl_texture_image *destTex ;
  GLint texcomponents ;
  GLint tmp___0 ;
  GLint dstRectArea ;
  GLint srcRectArea ;
  GLubyte *dst ;
  GLubyte *src ;
  GLint j ;
  GLint k ;
  struct gl_texture_image *subTexImg ;
  struct gl_texture_image *tmp___1 ;
  GLubyte *dst___0 ;
  GLubyte *src___0 ;
  GLint j___0 ;
  GLint k___0 ;
  GLint components___0 ;
  GLint size ;

  {
#line 34273
  if (target != 32879) {
#line 34274
    gl_error(ctx, 1280, "glTexSubImage3DEXT(target)");
#line 34275
    return;
  }
#line 34277
  if (level < 0) {
#line 34278
    gl_error(ctx, 1280, "glTexSubImage3DEXT(level)");
#line 34279
    return;
  } else {
#line 34277
    if (level >= 11) {
#line 34278
      gl_error(ctx, 1280, "glTexSubImage3DEXT(level)");
#line 34279
      return;
    }
  }
#line 34281
  destTex = (ctx->Texture.Current3D)->Image[level];
#line 34282
  if (! destTex) {
#line 34283
    gl_error(ctx, 1282, "glTexSubImage3DEXT");
#line 34284
    return;
  }
#line 34286
  if ((GLuint )xoffset < - destTex->Border) {
#line 34287
    gl_error(ctx, 1281, "glTexSubImage3DEXT(xoffset)");
#line 34288
    return;
  }
#line 34290
  if ((GLuint )yoffset < - destTex->Border) {
#line 34291
    gl_error(ctx, 1281, "glTexSubImage3DEXT(yoffset)");
#line 34292
    return;
  }
#line 34294
  if ((GLuint )zoffset < - destTex->Border) {
#line 34295
    gl_error(ctx, 1281, "glTexSubImage3DEXT(zoffset)");
#line 34296
    return;
  }
#line 34298
  if ((GLuint )(xoffset + width) > destTex->Width + destTex->Border) {
#line 34299
    gl_error(ctx, 1281, "glTexSubImage3DEXT(xoffset+width)");
#line 34300
    return;
  }
#line 34302
  if ((GLuint )(yoffset + height) > destTex->Height + destTex->Border) {
#line 34303
    gl_error(ctx, 1281, "glTexSubImage3DEXT(yoffset+height)");
#line 34304
    return;
  }
#line 34306
  if ((GLuint )(zoffset + depth) > destTex->Depth + destTex->Border) {
#line 34307
    gl_error(ctx, 1281, "glTexSubImage3DEXT(zoffset+depth)");
#line 34308
    return;
  }
#line 34310
  if (image) {
#line 34311
    tmp___0 = components_in_intformat(destTex->Format);
#line 34311
    texcomponents = tmp___0;
#line 34312
    dstRectArea = (GLint )(destTex->Width * destTex->Height);
#line 34313
    srcRectArea = width * height;
#line 34314
    if (image->Type == 5121) {
#line 34314
      if (texcomponents == image->Components) {
#line 34315
        dst = destTex->Data + (((GLuint )(zoffset * dstRectArea) + (GLuint )yoffset * destTex->Width) + (GLuint )xoffset) * (GLuint )texcomponents;
#line 34318
        src = (GLubyte *)image->Data;
#line 34320
        k = 0;
#line 34320
        while (k < depth) {
#line 34321
          j = 0;
#line 34321
          while (j < height) {
#line 34322
            memcpy((void *)dst, (void const   *)((void *)src), (unsigned int )(width * texcomponents));
#line 34323
            dst += destTex->Width * (GLuint )texcomponents;
#line 34324
            src += width * texcomponents;
#line 34321
            j ++;
          }
#line 34326
          dst += (unsigned int )(dstRectArea * texcomponents) * sizeof(GLubyte );
#line 34327
          src += (unsigned int )(srcRectArea * texcomponents) * sizeof(GLubyte );
#line 34320
          k ++;
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 34331
      tmp___1 = image_to_texture(ctx, (struct gl_image  const  *)image, destTex->IntFormat,
                                 (int )destTex->Border);
#line 34331
      subTexImg = tmp___1;
#line 34333
      dst___0 = destTex->Data + (((GLuint )(zoffset * dstRectArea) + (GLuint )yoffset * destTex->Width) + (GLuint )xoffset) * (GLuint )texcomponents;
#line 34336
      src___0 = subTexImg->Data;
#line 34338
      k___0 = 0;
#line 34338
      while (k___0 < depth) {
#line 34339
        j___0 = 0;
#line 34339
        while (j___0 < height) {
#line 34340
          memcpy((void *)dst___0, (void const   *)((void *)src___0), (unsigned int )(width * texcomponents));
#line 34341
          dst___0 += destTex->Width * (GLuint )texcomponents;
#line 34342
          src___0 += width * texcomponents;
#line 34339
          j___0 ++;
        }
#line 34344
        dst___0 += (unsigned int )(dstRectArea * texcomponents) * sizeof(GLubyte );
#line 34345
        src___0 += (unsigned int )(srcRectArea * texcomponents) * sizeof(GLubyte );
#line 34338
        k___0 ++;
      }
#line 34347
      gl_free_texture_image(subTexImg);
    }
#line 34349
    if (image->RefCount == 0) {
#line 34350
      gl_free_image(image);
    }
#line 34352
    (ctx->Texture.Current3D)->Dirty = (unsigned char)1;
#line 34353
    if (ctx->Driver.TexImage) {
#line 34354
      (*(ctx->Driver.TexImage))(ctx, 32879, ctx->Texture.Current3D, level, ((ctx->Texture.Current3D)->Image[level])->IntFormat,
                                (struct gl_texture_image  const  *)destTex);
    }
  } else {
#line 34362
    if (width < 0) {
#line 34363
      gl_error(ctx, 1281, "glTexSubImage3DEXT(width)");
#line 34364
      return;
    }
#line 34366
    if (height < 0) {
#line 34367
      gl_error(ctx, 1281, "glTexSubImage3DEXT(height)");
#line 34368
      return;
    }
#line 34370
    if (depth < 0) {
#line 34371
      gl_error(ctx, 1281, "glTexSubImage3DEXT(depth)");
#line 34372
      return;
    }
#line 34374
    if (type == 6656) {
#line 34374
      if (format != 6400) {
#line 34375
        gl_error(ctx, 1280, "glTexSubImage3DEXT(format)");
#line 34376
        return;
      }
    }
#line 34378
    components___0 = components_in_intformat(format);
#line 34379
    if (components___0 < 0) {
#line 34381
      gl_error(ctx, 1280, "glTexSubImage3DEXT(format)");
#line 34382
      return;
    } else {
#line 34379
      if (format == 6401) {
#line 34381
        gl_error(ctx, 1280, "glTexSubImage3DEXT(format)");
#line 34382
        return;
      } else {
#line 34379
        if (format == 6402) {
#line 34381
          gl_error(ctx, 1280, "glTexSubImage3DEXT(format)");
#line 34382
          return;
        }
      }
    }
#line 34384
    size = gl_sizeof_type(type);
#line 34385
    if (size <= 0) {
#line 34386
      gl_error(ctx, 1280, "glTexSubImage3DEXT(type)");
#line 34387
      return;
    }
#line 34389
    gl_error(ctx, 1285, "glTexSubImage3DEXT");
  }
#line 34391
  return;
}
}
#line 34392 "D:/a/test/177.c"
static struct gl_image *read_color_image(GLcontext *ctx , GLint x , GLint y , GLsizei width ,
                                         GLsizei height , GLint format ) 
{ struct gl_image *image ;
  GLubyte *imgptr ;
  GLint components___0 ;
  GLint i ;
  GLint j ;
  void *tmp___0 ;
  void *tmp___1 ;
  GLubyte red[640] ;
  GLubyte green[640] ;
  GLubyte blue___0[640] ;
  GLubyte alpha[640] ;
  float rscale ;
  float gscale ;
  float bscale ;
  float ascale ;
  GLubyte *tmp___2 ;
  GLubyte *tmp___3 ;
  GLubyte *tmp___4 ;
  GLubyte *tmp___5 ;
  GLubyte *tmp___6 ;
  GLubyte *tmp___7 ;
  GLubyte *tmp___8 ;
  GLubyte *tmp___9 ;
  GLubyte *tmp___10 ;
  GLubyte *tmp___11 ;
  GLubyte *tmp___12 ;
  GLubyte *tmp___13 ;

  {
#line 34400
  components___0 = components_in_intformat(format);
#line 34401
  tmp___0 = malloc(sizeof(struct gl_image ));//44
#line 34401
  image = (struct gl_image *)tmp___0;
#line 34402
  if (image) {
#line 34403
    image->Width = width;
#line 34404
    image->Height = height;
#line 34405
    image->Depth = 1;
#line 34406
    image->Components = components___0;
#line 34407
    image->Format = format;
#line 34408
    image->Type = 5121;
#line 34409
    image->RefCount = 0;
#line 34410
    tmp___1 = malloc((unsigned int )((width * height) * components___0));//45
#line 34410
    image->Data = (GLvoid *)((GLubyte *)tmp___1);
#line 34411
    if (! image->Data) {
#line 34412
      free((void *)image);
#line 34413
      return ((struct gl_image *)((void *)0));
    }
  } else {
#line 34417
    return ((struct gl_image *)((void *)0));
  }
#line 34419
  imgptr = (GLubyte *)image->Data;
#line 34420
  (*(ctx->Driver.SetBuffer))(ctx, ctx->Pixel.ReadBuffer);
#line 34421
  j = 0;
#line 34421
  while (j < height) {
#line 34424
    gl_read_color_span(ctx, (unsigned int )width, x, y + j, red, green, blue___0,
                       alpha);
#line 34425
    if (! (ctx->Visual)->EightBitColor) {
#line 34426
      rscale = 255.0f * (ctx->Visual)->InvRedScale;
#line 34427
      gscale = 255.0f * (ctx->Visual)->InvGreenScale;
#line 34428
      bscale = 255.0f * (ctx->Visual)->InvBlueScale;
#line 34429
      ascale = 255.0f * (ctx->Visual)->InvAlphaScale;
#line 34430
      i = 0;
#line 34430
      while (i < width) {
#line 34431
        red[i] = (unsigned char )((int )((float )red[i] * rscale));
#line 34432
        green[i] = (unsigned char )((int )((float )green[i] * gscale));
#line 34433
        blue___0[i] = (unsigned char )((int )((float )blue___0[i] * bscale));
#line 34434
        alpha[i] = (unsigned char )((int )((float )alpha[i] * ascale));
#line 34430
        i ++;
      }
    }
#line 34437
    switch (format) {
    case 6406: 
#line 34439
    i = 0;
#line 34439
    while (i < width) {
#line 34440
      tmp___2 = imgptr;
#line 34440
      imgptr ++;
#line 34440
      *tmp___2 = alpha[i];
#line 34439
      i ++;
    }
#line 34442
    break;
    case 6409: 
#line 34444
    i = 0;
#line 34444
    while (i < width) {
#line 34445
      tmp___3 = imgptr;
#line 34445
      imgptr ++;
#line 34445
      *tmp___3 = red[i];
#line 34444
      i ++;
    }
#line 34447
    break;
    case 6410: 
#line 34449
    i = 0;
#line 34449
    while (i < width) {
#line 34450
      tmp___4 = imgptr;
#line 34450
      imgptr ++;
#line 34450
      *tmp___4 = red[i];
#line 34451
      tmp___5 = imgptr;
#line 34451
      imgptr ++;
#line 34451
      *tmp___5 = alpha[i];
#line 34449
      i ++;
    }
#line 34453
    break;
    case 32841: 
#line 34455
    i = 0;
#line 34455
    while (i < width) {
#line 34456
      tmp___6 = imgptr;
#line 34456
      imgptr ++;
#line 34456
      *tmp___6 = red[i];
#line 34455
      i ++;
    }
#line 34458
    break;
    case 6407: 
#line 34460
    i = 0;
#line 34460
    while (i < width) {
#line 34461
      tmp___7 = imgptr;
#line 34461
      imgptr ++;
#line 34461
      *tmp___7 = red[i];
#line 34462
      tmp___8 = imgptr;
#line 34462
      imgptr ++;
#line 34462
      *tmp___8 = green[i];
#line 34463
      tmp___9 = imgptr;
#line 34463
      imgptr ++;
#line 34463
      *tmp___9 = blue___0[i];
#line 34460
      i ++;
    }
#line 34465
    break;
    case 6408: 
#line 34467
    i = 0;
#line 34467
    while (i < width) {
#line 34468
      tmp___10 = imgptr;
#line 34468
      imgptr ++;
#line 34468
      *tmp___10 = red[i];
#line 34469
      tmp___11 = imgptr;
#line 34469
      imgptr ++;
#line 34469
      *tmp___11 = green[i];
#line 34470
      tmp___12 = imgptr;
#line 34470
      imgptr ++;
#line 34470
      *tmp___12 = blue___0[i];
#line 34471
      tmp___13 = imgptr;
#line 34471
      imgptr ++;
#line 34471
      *tmp___13 = alpha[i];
#line 34467
      i ++;
    }
#line 34473
    break;
    }
#line 34421
    j ++;
  }
#line 34476
  (*(ctx->Driver.SetBuffer))(ctx, ctx->Color.DrawBuffer);
#line 34477
  return (image);
}
}
#line 34479 "D:/a/test/177.c"
void gl_CopyTexImage1D(GLcontext *ctx , GLenum target , GLint level , GLenum internalformat ,
                       GLint x , GLint y , GLsizei width , GLint border ) 
{ GLint format ;
  struct gl_image *teximage ;

  {
#line 34487
  if (ctx->Primitive != 6656) {
#line 34488
    gl_error(ctx, 1282, "glCopyTexImage1D");
#line 34489
    return;
  }
#line 34491
  if (target != 3552) {
#line 34492
    gl_error(ctx, 1280, "glCopyTexImage1D(target)");
#line 34493
    return;
  }
#line 34495
  if (level < 0) {
#line 34496
    gl_error(ctx, 1281, "glCopyTexImage1D(level)");
#line 34497
    return;
  } else {
#line 34495
    if (level >= 11) {
#line 34496
      gl_error(ctx, 1281, "glCopyTexImage1D(level)");
#line 34497
      return;
    }
  }
#line 34499
  if (border != 0) {
#line 34499
    if (border != 1) {
#line 34500
      gl_error(ctx, 1281, "glCopyTexImage1D(border)");
#line 34501
      return;
    }
  }
#line 34503
  if (width < 2 * border) {
#line 34504
    gl_error(ctx, 1281, "glCopyTexImage1D(width)");
#line 34505
    return;
  } else {
#line 34503
    if (width > 2 + (1 << 10)) {
#line 34504
      gl_error(ctx, 1281, "glCopyTexImage1D(width)");
#line 34505
      return;
    } else {
#line 34503
      if (width < 0) {
#line 34504
        gl_error(ctx, 1281, "glCopyTexImage1D(width)");
#line 34505
        return;
      }
    }
  }
#line 34507
  format = decode_internal_format1(internalformat);
#line 34508
  if (format < 0) {
#line 34509
    gl_error(ctx, 1281, "glCopyTexImage1D(format)");
#line 34510
    return;
  } else {
#line 34508
    if (internalformat >= 1) {
#line 34508
      if (internalformat <= 4) {
#line 34509
        gl_error(ctx, 1281, "glCopyTexImage1D(format)");
#line 34510
        return;
      }
    }
  }
#line 34512
  teximage = read_color_image(ctx, x, y, width, 1, format);
#line 34513
  if (! teximage) {
#line 34514
    gl_error(ctx, 1285, "glCopyTexImage1D");
#line 34515
    return;
  }
#line 34517
  gl_TexImage1D(ctx, target, level, internalformat, width, border, 6408, 5121, teximage);
#line 34519
  return;
}
}
#line 34520 "D:/a/test/177.c"
void gl_CopyTexImage2D(GLcontext *ctx , GLenum target , GLint level , GLenum internalformat ,
                       GLint x , GLint y , GLsizei width , GLsizei height , GLint border ) 
{ GLint format ;
  struct gl_image *teximage ;

  {
#line 34527
  if (ctx->Primitive != 6656) {
#line 34528
    gl_error(ctx, 1282, "glCopyTexImage2D");
#line 34529
    return;
  }
#line 34531
  if (target != 3553) {
#line 34532
    gl_error(ctx, 1280, "glCopyTexImage2D(target)");
#line 34533
    return;
  }
#line 34535
  if (level < 0) {
#line 34536
    gl_error(ctx, 1281, "glCopyTexImage2D(level)");
#line 34537
    return;
  } else {
#line 34535
    if (level >= 11) {
#line 34536
      gl_error(ctx, 1281, "glCopyTexImage2D(level)");
#line 34537
      return;
    }
  }
#line 34539
  if (border != 0) {
#line 34539
    if (border != 1) {
#line 34540
      gl_error(ctx, 1281, "glCopyTexImage2D(border)");
#line 34541
      return;
    }
  }
#line 34543
  if (width < 2 * border) {
#line 34544
    gl_error(ctx, 1281, "glCopyTexImage2D(width)");
#line 34545
    return;
  } else {
#line 34543
    if (width > 2 + (1 << 10)) {
#line 34544
      gl_error(ctx, 1281, "glCopyTexImage2D(width)");
#line 34545
      return;
    } else {
#line 34543
      if (width < 0) {
#line 34544
        gl_error(ctx, 1281, "glCopyTexImage2D(width)");
#line 34545
        return;
      }
    }
  }
#line 34547
  if (height < 2 * border) {
#line 34548
    gl_error(ctx, 1281, "glCopyTexImage2D(height)");
#line 34549
    return;
  } else {
#line 34547
    if (height > 2 + (1 << 10)) {
#line 34548
      gl_error(ctx, 1281, "glCopyTexImage2D(height)");
#line 34549
      return;
    } else {
#line 34547
      if (height < 0) {
#line 34548
        gl_error(ctx, 1281, "glCopyTexImage2D(height)");
#line 34549
        return;
      }
    }
  }
#line 34551
  format = decode_internal_format1(internalformat);
#line 34552
  if (format < 0) {
#line 34553
    gl_error(ctx, 1281, "glCopyTexImage2D(format)");
#line 34554
    return;
  } else {
#line 34552
    if (internalformat >= 1) {
#line 34552
      if (internalformat <= 4) {
#line 34553
        gl_error(ctx, 1281, "glCopyTexImage2D(format)");
#line 34554
        return;
      }
    }
  }
#line 34556
  teximage = read_color_image(ctx, x, y, width, height, format);
#line 34557
  if (! teximage) {
#line 34558
    gl_error(ctx, 1285, "glCopyTexImage2D");
#line 34559
    return;
  }
#line 34561
  gl_TexImage2D(ctx, target, level, internalformat, width, height, border, 6408, 5121,
                teximage);
#line 34563
  return;
}
}
#line 34564 "D:/a/test/177.c"
static void copy_tex_sub_image(GLcontext *ctx , struct gl_texture_image *dest , GLint width ,
                               GLint height , GLint srcx , GLint srcy , GLint dstx ,
                               GLint dsty , GLint zoffset ) 
{ GLint i ;
  GLint j ;
  GLint format ;
  GLint components___0 ;
  GLint rectarea ;
  GLubyte red[640] ;
  GLubyte green[640] ;
  GLubyte blue___0[640] ;
  GLubyte alpha[640] ;
  GLubyte *texptr ;
  float rscale ;
  float gscale ;
  float bscale ;
  float ascale ;
  GLubyte *tmp___0 ;
  GLubyte *tmp___1 ;
  GLubyte *tmp___2 ;
  GLubyte *tmp___3 ;
  GLubyte *tmp___4 ;
  GLubyte *tmp___5 ;
  GLubyte *tmp___6 ;
  GLubyte *tmp___7 ;
  GLubyte *tmp___8 ;
  GLubyte *tmp___9 ;
  GLubyte *tmp___10 ;
  GLubyte *tmp___11 ;

  {
#line 34571
  rectarea = width * height;
#line 34572
  zoffset *= rectarea;
#line 34573
  format = dest->Format;
#line 34574
  components___0 = components_in_intformat(format);
#line 34575
  j = 0;
#line 34575
  while (j < height) {
#line 34579
    gl_read_color_span(ctx, (unsigned int )width, srcx, srcy + j, red, green, blue___0,
                       alpha);
#line 34580
    if (! (ctx->Visual)->EightBitColor) {
#line 34581
      rscale = 255.0f * (ctx->Visual)->InvRedScale;
#line 34582
      gscale = 255.0f * (ctx->Visual)->InvGreenScale;
#line 34583
      bscale = 255.0f * (ctx->Visual)->InvBlueScale;
#line 34584
      ascale = 255.0f * (ctx->Visual)->InvAlphaScale;
#line 34585
      i = 0;
#line 34585
      while (i < width) {
#line 34586
        red[i] = (unsigned char )((int )((float )red[i] * rscale));
#line 34587
        green[i] = (unsigned char )((int )((float )green[i] * gscale));
#line 34588
        blue___0[i] = (unsigned char )((int )((float )blue___0[i] * bscale));
#line 34589
        alpha[i] = (unsigned char )((int )((float )alpha[i] * ascale));
#line 34585
        i ++;
      }
    }
#line 34592
    texptr = dest->Data + ((zoffset + (dsty + j) * width) + dstx) * components___0;
#line 34593
    switch (format) {
    case 6406: 
#line 34595
    i = 0;
#line 34595
    while (i < width) {
#line 34596
      tmp___0 = texptr;
#line 34596
      texptr ++;
#line 34596
      *tmp___0 = alpha[i];
#line 34595
      i ++;
    }
#line 34598
    break;
    case 6409: 
#line 34600
    i = 0;
#line 34600
    while (i < width) {
#line 34601
      tmp___1 = texptr;
#line 34601
      texptr ++;
#line 34601
      *tmp___1 = red[i];
#line 34600
      i ++;
    }
#line 34603
    break;
    case 6410: 
#line 34605
    i = 0;
#line 34605
    while (i < width) {
#line 34606
      tmp___2 = texptr;
#line 34606
      texptr ++;
#line 34606
      *tmp___2 = red[i];
#line 34607
      tmp___3 = texptr;
#line 34607
      texptr ++;
#line 34607
      *tmp___3 = alpha[i];
#line 34605
      i ++;
    }
#line 34609
    break;
    case 32841: 
#line 34611
    i = 0;
#line 34611
    while (i < width) {
#line 34612
      tmp___4 = texptr;
#line 34612
      texptr ++;
#line 34612
      *tmp___4 = red[i];
#line 34611
      i ++;
    }
#line 34614
    break;
    case 6407: 
#line 34616
    i = 0;
#line 34616
    while (i < width) {
#line 34617
      tmp___5 = texptr;
#line 34617
      texptr ++;
#line 34617
      *tmp___5 = red[i];
#line 34618
      tmp___6 = texptr;
#line 34618
      texptr ++;
#line 34618
      *tmp___6 = green[i];
#line 34619
      tmp___7 = texptr;
#line 34619
      texptr ++;
#line 34619
      *tmp___7 = blue___0[i];
#line 34616
      i ++;
    }
#line 34621
    break;
    case 6408: 
#line 34623
    i = 0;
#line 34623
    while (i < width) {
#line 34624
      tmp___8 = texptr;
#line 34624
      texptr ++;
#line 34624
      *tmp___8 = red[i];
#line 34625
      tmp___9 = texptr;
#line 34625
      texptr ++;
#line 34625
      *tmp___9 = green[i];
#line 34626
      tmp___10 = texptr;
#line 34626
      texptr ++;
#line 34626
      *tmp___10 = blue___0[i];
#line 34627
      tmp___11 = texptr;
#line 34627
      texptr ++;
#line 34627
      *tmp___11 = alpha[i];
#line 34623
      i ++;
    }
#line 34629
    break;
    }
#line 34575
    j ++;
  }
#line 34632
  return;
}
}
#line 34633 "D:/a/test/177.c"
void gl_CopyTexSubImage1D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                          GLint x , GLint y , GLsizei width ) 
{ struct gl_texture_image *teximage ;

  {
#line 34638
  if (ctx->Primitive != 6656) {
#line 34639
    gl_error(ctx, 1282, "glCopyTexSubImage1D");
#line 34640
    return;
  }
#line 34642
  if (target != 3552) {
#line 34643
    gl_error(ctx, 1280, "glCopyTexSubImage1D(target)");
#line 34644
    return;
  }
#line 34646
  if (level < 0) {
#line 34647
    gl_error(ctx, 1281, "glCopyTexSubImage1D(level)");
#line 34648
    return;
  } else {
#line 34646
    if (level >= 11) {
#line 34647
      gl_error(ctx, 1281, "glCopyTexSubImage1D(level)");
#line 34648
      return;
    }
  }
#line 34650
  if (width < 0) {
#line 34651
    gl_error(ctx, 1281, "glCopyTexSubImage1D(width)");
#line 34652
    return;
  }
#line 34654
  teximage = (ctx->Texture.Current1D)->Image[level];
#line 34655
  if (teximage) {
#line 34656
    if ((GLuint )xoffset < - teximage->Border) {
#line 34657
      gl_error(ctx, 1281, "glCopyTexSubImage1D(xoffset)");
#line 34658
      return;
    }
#line 34660
    if ((GLuint )(xoffset + width) > teximage->Width + teximage->Border) {
#line 34661
      gl_error(ctx, 1281, "glCopyTexSubImage1D(xoffset+width)");
#line 34663
      return;
    }
#line 34665
    if (teximage->Data) {
#line 34666
      copy_tex_sub_image(ctx, teximage, width, 1, x, y, xoffset, 0, 0);
    }
  } else {
#line 34670
    gl_error(ctx, 1282, "glCopyTexSubImage1D");
  }
#line 34672
  return;
}
}
#line 34673 "D:/a/test/177.c"
void gl_CopyTexSubImage2D(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                          GLint yoffset , GLint x , GLint y , GLsizei width , GLsizei height ) 
{ struct gl_texture_image *teximage ;

  {
#line 34679
  if (ctx->Primitive != 6656) {
#line 34680
    gl_error(ctx, 1282, "glCopyTexSubImage2D");
#line 34681
    return;
  }
#line 34683
  if (target != 3553) {
#line 34684
    gl_error(ctx, 1280, "glCopyTexSubImage2D(target)");
#line 34685
    return;
  }
#line 34687
  if (level < 0) {
#line 34688
    gl_error(ctx, 1281, "glCopyTexSubImage2D(level)");
#line 34689
    return;
  } else {
#line 34687
    if (level >= 11) {
#line 34688
      gl_error(ctx, 1281, "glCopyTexSubImage2D(level)");
#line 34689
      return;
    }
  }
#line 34691
  if (width < 0) {
#line 34692
    gl_error(ctx, 1281, "glCopyTexSubImage2D(width)");
#line 34693
    return;
  }
#line 34695
  if (height < 0) {
#line 34696
    gl_error(ctx, 1281, "glCopyTexSubImage2D(height)");
#line 34697
    return;
  }
#line 34699
  teximage = (ctx->Texture.Current2D)->Image[level];
#line 34700
  if (teximage) {
#line 34701
    if ((GLuint )xoffset < - teximage->Border) {
#line 34702
      gl_error(ctx, 1281, "glCopyTexSubImage2D(xoffset)");
#line 34703
      return;
    }
#line 34705
    if ((GLuint )yoffset < - teximage->Border) {
#line 34706
      gl_error(ctx, 1281, "glCopyTexSubImage2D(yoffset)");
#line 34707
      return;
    }
#line 34709
    if ((GLuint )(xoffset + width) > teximage->Width + teximage->Border) {
#line 34710
      gl_error(ctx, 1281, "glCopyTexSubImage2D(xoffset+width)");
#line 34712
      return;
    }
#line 34714
    if ((GLuint )(yoffset + height) > teximage->Height + teximage->Border) {
#line 34715
      gl_error(ctx, 1281, "glCopyTexSubImage2D(yoffset+height)");
#line 34717
      return;
    }
#line 34719
    if (teximage->Data) {
#line 34720
      copy_tex_sub_image(ctx, teximage, width, height, x, y, xoffset, yoffset, 0);
    }
  } else {
#line 34725
    gl_error(ctx, 1282, "glCopyTexSubImage2D");
  }
#line 34727
  return;
}
}
#line 34728 "D:/a/test/177.c"
void gl_CopyTexSubImage3DEXT(GLcontext *ctx , GLenum target , GLint level , GLint xoffset ,
                             GLint yoffset , GLint zoffset , GLint x , GLint y , GLsizei width ,
                             GLsizei height ) 
{ struct gl_texture_image *teximage ;

  {
#line 34734
  if (ctx->Primitive != 6656) {
#line 34735
    gl_error(ctx, 1282, "glCopyTexSubImage3DEXT");
#line 34736
    return;
  }
#line 34738
  if (target != 3553) {
#line 34739
    gl_error(ctx, 1280, "glCopyTexSubImage3DEXT(target)");
#line 34740
    return;
  }
#line 34742
  if (level < 0) {
#line 34743
    gl_error(ctx, 1281, "glCopyTexSubImage3DEXT(level)");
#line 34744
    return;
  } else {
#line 34742
    if (level >= 11) {
#line 34743
      gl_error(ctx, 1281, "glCopyTexSubImage3DEXT(level)");
#line 34744
      return;
    }
  }
#line 34746
  if (width < 0) {
#line 34747
    gl_error(ctx, 1281, "glCopyTexSubImage3DEXT(width)");
#line 34748
    return;
  }
#line 34750
  if (height < 0) {
#line 34751
    gl_error(ctx, 1281, "glCopyTexSubImage3DEXT(height)");
#line 34752
    return;
  }
#line 34754
  teximage = (ctx->Texture.Current3D)->Image[level];
#line 34755
  if (teximage) {
#line 34756
    if ((GLuint )xoffset < - teximage->Border) {
#line 34757
      gl_error(ctx, 1281, "glCopyTexSubImage3DEXT(xoffset)");
#line 34758
      return;
    }
#line 34760
    if ((GLuint )yoffset < - teximage->Border) {
#line 34761
      gl_error(ctx, 1281, "glCopyTexSubImage3DEXT(yoffset)");
#line 34762
      return;
    }
#line 34764
    if ((GLuint )zoffset < - teximage->Border) {
#line 34765
      gl_error(ctx, 1281, "glCopyTexSubImage3DEXT(zoffset)");
#line 34766
      return;
    }
#line 34768
    if ((GLuint )(xoffset + width) > teximage->Width + teximage->Border) {
#line 34769
      gl_error(ctx, 1281, "glCopyTexSubImage3DEXT(xoffset+width)");
#line 34771
      return;
    }
#line 34773
    if ((GLuint )(yoffset + height) > teximage->Height + teximage->Border) {
#line 34774
      gl_error(ctx, 1281, "glCopyTexSubImage3DEXT(yoffset+height)");
#line 34776
      return;
    }
#line 34778
    if ((GLuint )zoffset > teximage->Depth + teximage->Border) {
#line 34779
      gl_error(ctx, 1281, "glCopyTexSubImage3DEXT(zoffset+depth)");
#line 34781
      return;
    }
#line 34783
    if (teximage->Data) {
#line 34784
      copy_tex_sub_image(ctx, teximage, width, height, x, y, xoffset, yoffset, zoffset);
    }
  } else {
#line 34789
    gl_error(ctx, 1282, "glCopyTexSubImage3DEXT");
  }
#line 34791
  return;
}
}
#line 34797 "D:/a/test/177.c"
struct gl_texture_object *gl_alloc_texture_object(struct gl_shared_state *shared ,
                                                  GLuint name , GLuint dimensions ) 
{ struct gl_texture_object *obj ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 34802
  if (dimensions >= 1U) {
#line 34802
    if (dimensions <= 3U) {
#line 34802
      tmp___0 = 1;
    } else {
#line 34802
      tmp___0 = 0;
    }
  } else {
#line 34802
    tmp___0 = 0;
  }
#line 34802
  //assert(tmp___0);
#line 34803
  tmp___1 = calloc(1U, sizeof(struct gl_texture_object ));
#line 34803
  obj = (struct gl_texture_object *)tmp___1;
#line 34805
  if (obj) {
#line 34806
    obj->Name = name;
#line 34807
    obj->Dimensions = dimensions;
#line 34808
    obj->WrapS = 10497;
#line 34809
    obj->WrapT = 10497;
#line 34810
    obj->MinFilter = 9986;
#line 34811
    obj->MagFilter = 9729;
#line 34812
    obj->MinMagThresh = 0.0F;
#line 34813
    obj->Palette[0] = (unsigned char)255;
#line 34814
    obj->Palette[1] = (unsigned char)255;
#line 34815
    obj->Palette[2] = (unsigned char)255;
#line 34816
    obj->Palette[3] = (unsigned char)255;
#line 34817
    obj->PaletteSize = 1U;
#line 34818
    obj->PaletteIntFormat = 6408;
#line 34819
    obj->PaletteFormat = 6408;
#line 34820
    if (shared) {
#line 34821
      obj->Next = shared->TexObjectList;
#line 34822
      shared->TexObjectList = obj;
    }
#line 34824
    if (name > 0U) {
#line 34825
      HashInsert(shared->TexObjects, name, (void *)obj);
    }
  }
#line 34828
  return (obj);
}
}
#line 34830 "D:/a/test/177.c"
void gl_free_texture_object(struct gl_shared_state *shared , struct gl_texture_object *t ) 
{ struct gl_texture_object *tprev ;
  struct gl_texture_object *tcurr ;
  GLuint i ;

  {
#line 34834
  //assert(t);
#line 34835
  if (shared) {
#line 34836
    tprev = (struct gl_texture_object *)((void *)0);
#line 34837
    tcurr = shared->TexObjectList;
#line 34838
    while (tcurr) {
#line 34839
      if ((unsigned int )tcurr == (unsigned int )t) {
#line 34840
        if (tprev) {
#line 34841
          tprev->Next = t->Next;
        } else {
#line 34844
          shared->TexObjectList = t->Next;
        }
#line 34846
        break;
      }
#line 34848
      tprev = tcurr;
#line 34849
      tcurr = tcurr->Next;
    }
  }
#line 34852
  if (t->Name) {
#line 34853
    HashRemove(shared->TexObjects, t->Name);
  }
#line 34857
  i = 0U;
#line 34857
  while (i < 11U) {
#line 34858
    if (t->Image[i]) {
#line 34859
      gl_free_texture_image(t->Image[i]);
    }
#line 34857
    i ++;
  }
#line 34863
  free((void *)t);
#line 34864
  return;
}
}
#line 34865 "D:/a/test/177.c"
void gl_test_texture_object_completeness(struct gl_texture_object *t ) 
{ int i ;
  GLuint width ;
  GLuint width___0 ;
  GLuint height ;
  GLuint width___1 ;
  GLuint height___0 ;
  GLuint depth ;

  {
#line 34867
  t->Complete = (unsigned char)1;
#line 34868
  if (! t->Image[0]) {
#line 34869
    t->Complete = (unsigned char)0;
#line 34870
    return;
  } else {
#line 34868
    if (! (t->Image[0])->Data) {
#line 34869
      t->Complete = (unsigned char)0;
#line 34870
      return;
    }
  }
#line 34872
  if (t->MinFilter != 9728) {
#line 34872
    if (t->MinFilter != 9729) {
#line 34874
      i = 1;
#line 34874
      while (i < 11) {
#line 34875
        if (t->Image[i]) {
#line 34876
          if (! (t->Image[i])->Data) {
#line 34877
            t->Complete = (unsigned char)0;
#line 34878
            return;
          }
#line 34880
          if ((t->Image[i])->Format != (t->Image[0])->Format) {
#line 34881
            t->Complete = (unsigned char)0;
#line 34882
            return;
          }
#line 34884
          if ((t->Image[i])->Border != (t->Image[0])->Border) {
#line 34885
            t->Complete = (unsigned char)0;
#line 34886
            return;
          }
        }
#line 34874
        i ++;
      }
#line 34890
      if (t->Dimensions == 1U) {
#line 34891
        width = (t->Image[0])->Width2;
#line 34892
        i = 1;
#line 34892
        while (i < 11) {
#line 34893
          if (width > 1U) {
#line 34894
            width /= 2U;
          }
#line 34896
          if (! t->Image[i]) {
#line 34897
            t->Complete = (unsigned char)0;
#line 34898
            return;
          }
#line 34900
          if (! (t->Image[i])->Data) {
#line 34901
            t->Complete = (unsigned char)0;
#line 34902
            return;
          }
#line 34904
          if ((t->Image[i])->Format != (t->Image[0])->Format) {
#line 34905
            t->Complete = (unsigned char)0;
#line 34906
            return;
          }
#line 34908
          if ((t->Image[i])->Border != (t->Image[0])->Border) {
#line 34909
            t->Complete = (unsigned char)0;
#line 34910
            return;
          }
#line 34912
          if ((t->Image[i])->Width2 != width) {
#line 34913
            t->Complete = (unsigned char)0;
#line 34914
            return;
          }
#line 34916
          if (width == 1U) {
#line 34917
            return;
          }
#line 34892
          i ++;
        }
      } else {
#line 34921
        if (t->Dimensions == 2U) {
#line 34922
          width___0 = (t->Image[0])->Width2;
#line 34923
          height = (t->Image[0])->Height2;
#line 34924
          i = 1;
#line 34924
          while (i < 11) {
#line 34925
            if (width___0 > 1U) {
#line 34926
              width___0 /= 2U;
            }
#line 34928
            if (height > 1U) {
#line 34929
              height /= 2U;
            }
#line 34931
            if (! t->Image[i]) {
#line 34932
              t->Complete = (unsigned char)0;
#line 34933
              return;
            }
#line 34935
            if ((t->Image[i])->Width2 != width___0) {
#line 34936
              t->Complete = (unsigned char)0;
#line 34937
              return;
            }
#line 34939
            if ((t->Image[i])->Height2 != height) {
#line 34940
              t->Complete = (unsigned char)0;
#line 34941
              return;
            }
#line 34943
            if (width___0 == 1U) {
#line 34943
              if (height == 1U) {
#line 34944
                return;
              }
            }
#line 34924
            i ++;
          }
        } else {
#line 34948
          if (t->Dimensions == 3U) {
#line 34949
            width___1 = (t->Image[0])->Width2;
#line 34950
            height___0 = (t->Image[0])->Height2;
#line 34951
            depth = (t->Image[0])->Depth2;
#line 34952
            i = 1;
#line 34952
            while (i < 11) {
#line 34953
              if (width___1 > 1U) {
#line 34954
                width___1 /= 2U;
              }
#line 34956
              if (height___0 > 1U) {
#line 34957
                height___0 /= 2U;
              }
#line 34959
              if (depth > 1U) {
#line 34960
                depth /= 2U;
              }
#line 34962
              if (! t->Image[i]) {
#line 34963
                t->Complete = (unsigned char)0;
#line 34964
                return;
              }
#line 34966
              if ((t->Image[i])->Width2 != width___1) {
#line 34967
                t->Complete = (unsigned char)0;
#line 34968
                return;
              }
#line 34970
              if ((t->Image[i])->Height2 != height___0) {
#line 34971
                t->Complete = (unsigned char)0;
#line 34972
                return;
              }
#line 34974
              if ((t->Image[i])->Depth2 != depth) {
#line 34975
                t->Complete = (unsigned char)0;
#line 34976
                return;
              }
#line 34978
              if (width___1 == 1U) {
#line 34978
                if (height___0 == 1U) {
#line 34978
                  if (depth == 1U) {
#line 34979
                    return;
                  }
                }
              }
#line 34952
              i ++;
            }
          } else {
#line 34984
            gl_problem((GLcontext const   *)((void *)0), "Bug in gl_test_texture_object_completeness\n");
          }
        }
      }
    }
  }
#line 34987
  return;
}
}
#line 34988 "D:/a/test/177.c"
void gl_GenTextures(GLcontext *ctx , GLsizei n , GLuint *texName ) 
{ GLuint first ;
  GLuint i ;

  {
#line 34991
  if (ctx->Primitive != 6656) {
#line 34992
    gl_error(ctx, 1282, "glGenTextures");
#line 34993
    return;
  }
#line 34995
  if (n < 0) {
#line 34996
    gl_error(ctx, 1281, "glGenTextures");
#line 34997
    return;
  }
#line 34999
  first = HashFindFreeKeyBlock((struct HashTable  const  *)(ctx->Shared)->TexObjects,
                               (unsigned int )n);
#line 35000
  i = 0U;
#line 35000
  while (i < (GLuint )n) {
#line 35001
    *(texName + i) = first + i;
#line 35000
    i ++;
  }
#line 35003
  return;
}
}
#line 35011 "D:/a/test/177.c"
void gl_TexEnvfv(GLcontext *ctx , GLenum target , GLenum pname , float const   *param ) 
{ GLenum mode ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
#line 35014
  if (ctx->Primitive != 6656) {
#line 35015
    gl_error(ctx, 1282, "glTexEnv");
#line 35016
    return;
  }
#line 35018
  if (target != 8960) {
#line 35019
    gl_error(ctx, 1280, "glTexEnv(target)");
#line 35020
    return;
  }
#line 35022
  if (pname == 8704) {
#line 35023
    mode = (int )*param;
#line 35024
    switch (mode) {
    case 8448: 
    case 3042: 
    case 8449: 
    case 7681: 
#line 35029
    ctx->Texture.EnvMode = mode;
#line 35030
    break;
    default: 
#line 35032
    gl_error(ctx, 1280, "glTexEnv(param)");
#line 35033
    return;
    }
  } else {
#line 35036
    if (pname == 8705) {
#line 35037
      if ((double )*(param + 0) < 0.0) {
#line 35037
        ctx->Texture.EnvColor[0] = (float )0.0;
      } else {
#line 35037
        if ((double )*(param + 0) > 1.0) {
#line 35037
          tmp___0 = 1.0;
        } else {
#line 35037
          tmp___0 = (double )*(param + 0);
        }
#line 35037
        ctx->Texture.EnvColor[0] = (float )tmp___0;
      }
#line 35038
      if ((double )*(param + 1) < 0.0) {
#line 35038
        ctx->Texture.EnvColor[1] = (float )0.0;
      } else {
#line 35038
        if ((double )*(param + 1) > 1.0) {
#line 35038
          tmp___1 = 1.0;
        } else {
#line 35038
          tmp___1 = (double )*(param + 1);
        }
#line 35038
        ctx->Texture.EnvColor[1] = (float )tmp___1;
      }
#line 35039
      if ((double )*(param + 2) < 0.0) {
#line 35039
        ctx->Texture.EnvColor[2] = (float )0.0;
      } else {
#line 35039
        if ((double )*(param + 2) > 1.0) {
#line 35039
          tmp___2 = 1.0;
        } else {
#line 35039
          tmp___2 = (double )*(param + 2);
        }
#line 35039
        ctx->Texture.EnvColor[2] = (float )tmp___2;
      }
#line 35040
      if ((double )*(param + 3) < 0.0) {
#line 35040
        ctx->Texture.EnvColor[3] = (float )0.0;
      } else {
#line 35040
        if ((double )*(param + 3) > 1.0) {
#line 35040
          tmp___3 = 1.0;
        } else {
#line 35040
          tmp___3 = (double )*(param + 3);
        }
#line 35040
        ctx->Texture.EnvColor[3] = (float )tmp___3;
      }
    } else {
#line 35043
      gl_error(ctx, 1280, "glTexEnv(pname)");
#line 35044
      return;
    }
  }
#line 35046
  if (ctx->Driver.TexEnv) {
#line 35047
    (*(ctx->Driver.TexEnv))(ctx, pname, param);
  }
#line 35049
  return;
}
}
#line 35050 "D:/a/test/177.c"
void gl_GetTexEnvfv(GLcontext *ctx , GLenum target , GLenum pname , float *params ) 
{ 

  {
#line 35053
  if (target != 8960) {
#line 35054
    gl_error(ctx, 1280, "glGetTexEnvfv(target)");
#line 35055
    return;
  }
#line 35057
  switch (pname) {
  case 8704: 
#line 35059
  *params = (float )ctx->Texture.EnvMode;
#line 35060
  break;
  case 8705: 
#line 35062
  *(params + 0) = ctx->Texture.EnvColor[0];
#line 35062
  *(params + 1) = ctx->Texture.EnvColor[1];
#line 35062
  *(params + 2) = ctx->Texture.EnvColor[2];
#line 35062
  *(params + 3) = ctx->Texture.EnvColor[3];
#line 35063
  break;
  default: 
#line 35065
  gl_error(ctx, 1280, "glGetTexEnvfv(pname)");
  }
#line 35067
  return;
}
}
#line 35068 "D:/a/test/177.c"
void gl_GetTexEnviv(GLcontext *ctx , GLenum target , GLenum pname , GLint *params ) 
{ 

  {
#line 35071
  if (target != 8960) {
#line 35072
    gl_error(ctx, 1280, "glGetTexEnvfv(target)");
#line 35073
    return;
  }
#line 35075
  switch (pname) {
  case 8704: 
#line 35077
  *params = ctx->Texture.EnvMode;
#line 35078
  break;
  case 8705: 
#line 35080
  *(params + 0) = (int )(2147483647.0 * (double )ctx->Texture.EnvColor[0]);
#line 35081
  *(params + 1) = (int )(2147483647.0 * (double )ctx->Texture.EnvColor[1]);
#line 35082
  *(params + 2) = (int )(2147483647.0 * (double )ctx->Texture.EnvColor[2]);
#line 35083
  *(params + 3) = (int )(2147483647.0 * (double )ctx->Texture.EnvColor[3]);
#line 35084
  break;
  default: 
#line 35086
  gl_error(ctx, 1280, "glGetTexEnvfv(pname)");
  }
#line 35088
  return;
}
}
#line 35089 "D:/a/test/177.c"
void gl_TexParameterfv(GLcontext *ctx , GLenum target , GLenum pname , float const   *params ) 
{ GLenum eparam ;
  struct gl_texture_object *texObj ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 35092
  eparam = (int )*(params + 0);
#line 35094
  switch (target) {
  case 3552: 
#line 35096
  texObj = ctx->Texture.Current1D;
#line 35097
  break;
  case 3553: 
#line 35099
  texObj = ctx->Texture.Current2D;
#line 35100
  break;
  case 32879: 
#line 35102
  texObj = ctx->Texture.Current3D;
#line 35103
  break;
  default: 
#line 35105
  gl_error(ctx, 1280, "glTexParameter(target)");
#line 35106
  return;
  }
#line 35108
  switch (pname) {
  case 10241: 
#line 35110
  if (eparam == 9728) {
#line 35115
    texObj->MinFilter = eparam;
#line 35116
    ctx->NewState |= 4U;
  } else {
#line 35110
    if (eparam == 9729) {
#line 35115
      texObj->MinFilter = eparam;
#line 35116
      ctx->NewState |= 4U;
    } else {
#line 35110
      if (eparam == 9984) {
#line 35115
        texObj->MinFilter = eparam;
#line 35116
        ctx->NewState |= 4U;
      } else {
#line 35110
        if (eparam == 9985) {
#line 35115
          texObj->MinFilter = eparam;
#line 35116
          ctx->NewState |= 4U;
        } else {
#line 35110
          if (eparam == 9986) {
#line 35115
            texObj->MinFilter = eparam;
#line 35116
            ctx->NewState |= 4U;
          } else {
#line 35110
            if (eparam == 9987) {
#line 35115
              texObj->MinFilter = eparam;
#line 35116
              ctx->NewState |= 4U;
            } else {
#line 35119
              gl_error(ctx, 1281, "glTexParameter(param)");
#line 35120
              return;
            }
          }
        }
      }
    }
  }
#line 35122
  break;
  case 10240: 
#line 35124
  if (eparam == 9728) {
#line 35125
    texObj->MagFilter = eparam;
#line 35126
    ctx->NewState |= 4U;
  } else {
#line 35124
    if (eparam == 9729) {
#line 35125
      texObj->MagFilter = eparam;
#line 35126
      ctx->NewState |= 4U;
    } else {
#line 35129
      gl_error(ctx, 1281, "glTexParameter(param)");
#line 35130
      return;
    }
  }
#line 35132
  break;
  case 10242: 
#line 35134
  if (eparam == 10496) {
#line 35135
    texObj->WrapS = eparam;
  } else {
#line 35134
    if (eparam == 10497) {
#line 35135
      texObj->WrapS = eparam;
    } else {
#line 35138
      gl_error(ctx, 1281, "glTexParameter(param)");
#line 35139
      return;
    }
  }
#line 35141
  break;
  case 10243: 
#line 35143
  if (eparam == 10496) {
#line 35144
    texObj->WrapT = eparam;
  } else {
#line 35143
    if (eparam == 10497) {
#line 35144
      texObj->WrapT = eparam;
    } else {
#line 35147
      gl_error(ctx, 1281, "glTexParameter(param)");
#line 35148
      return;
    }
  }
#line 35150
  break;
  case 32882: 
#line 35152
  if (eparam == 10496) {
#line 35153
    texObj->WrapR = eparam;
  } else {
#line 35152
    if (eparam == 10497) {
#line 35153
      texObj->WrapR = eparam;
    } else {
#line 35156
      gl_error(ctx, 1281, "glTexParameter(param)");
    }
  }
#line 35158
  break;
  case 4100: 
#line 35160
  if ((int )((double )*(params + 0) * 255.0) < 0) {
#line 35160
    texObj->BorderColor[0] = 0;
  } else {
#line 35160
    if ((int )((double )*(params + 0) * 255.0) > 255) {
#line 35160
      tmp___0 = 255;
    } else {
#line 35160
      tmp___0 = (int )((double )*(params + 0) * 255.0);
    }
#line 35160
    texObj->BorderColor[0] = tmp___0;
  }
#line 35161
  if ((int )((double )*(params + 1) * 255.0) < 0) {
#line 35161
    texObj->BorderColor[1] = 0;
  } else {
#line 35161
    if ((int )((double )*(params + 1) * 255.0) > 255) {
#line 35161
      tmp___1 = 255;
    } else {
#line 35161
      tmp___1 = (int )((double )*(params + 1) * 255.0);
    }
#line 35161
    texObj->BorderColor[1] = tmp___1;
  }
#line 35162
  if ((int )((double )*(params + 2) * 255.0) < 0) {
#line 35162
    texObj->BorderColor[2] = 0;
  } else {
#line 35162
    if ((int )((double )*(params + 2) * 255.0) > 255) {
#line 35162
      tmp___2 = 255;
    } else {
#line 35162
      tmp___2 = (int )((double )*(params + 2) * 255.0);
    }
#line 35162
    texObj->BorderColor[2] = tmp___2;
  }
#line 35163
  if ((int )((double )*(params + 3) * 255.0) < 0) {
#line 35163
    texObj->BorderColor[3] = 0;
  } else {
#line 35163
    if ((int )((double )*(params + 3) * 255.0) > 255) {
#line 35163
      tmp___3 = 255;
    } else {
#line 35163
      tmp___3 = (int )((double )*(params + 3) * 255.0);
    }
#line 35163
    texObj->BorderColor[3] = tmp___3;
  }
#line 35164
  break;
  default: 
#line 35166
  gl_error(ctx, 1280, "glTexParameter(pname)");
#line 35167
  return;
  }
#line 35169
  texObj->Dirty = (unsigned char)1;
#line 35170
  if (ctx->Driver.TexParameter) {
#line 35171
    (*(ctx->Driver.TexParameter))(ctx, target, texObj, pname, params);
  }
#line 35173
  return;
}
}
#line 35178
void gl_GetTexLevelParameteriv(GLcontext *ctx , GLenum target , GLint level , GLenum pname ,
                               GLint *params ) ;
#line 35174 "D:/a/test/177.c"
void gl_GetTexLevelParameterfv(GLcontext *ctx , GLenum target , GLint level , GLenum pname ,
                               float *params ) 
{ GLint iparam ;

  {
#line 35178
  gl_GetTexLevelParameteriv(ctx, target, level, pname, & iparam);
#line 35179
  *params = (float )iparam;
#line 35180
  return;
}
}
#line 35181 "D:/a/test/177.c"
void gl_GetTexLevelParameteriv(GLcontext *ctx , GLenum target , GLint level , GLenum pname ,
                               GLint *params ) 
{ struct gl_texture_image *tex ;

  {
#line 35185
  if (level < 0) {
#line 35186
    gl_error(ctx, 1281, "glGetTexLevelParameter[if]v");
#line 35187
    return;
  } else {
#line 35185
    if (level >= 11) {
#line 35186
      gl_error(ctx, 1281, "glGetTexLevelParameter[if]v");
#line 35187
      return;
    }
  }
#line 35189
  switch (target) {
  case 3552: 
#line 35191
  tex = (ctx->Texture.Current1D)->Image[level];
#line 35192
  switch (pname) {
  case 4096: 
#line 35194
  *params = (int )tex->Width;
#line 35195
  break;
  case 4099: 
#line 35197
  *params = tex->Format;
#line 35198
  break;
  case 4101: 
#line 35200
  *params = (int )tex->Border;
#line 35201
  break;
  case 32860: 
  case 32861: 
  case 32862: 
  case 32863: 
  case 32865: 
  case 32864: 
#line 35208
  *params = 8;
#line 35209
  break;
  case 32993: 
#line 35211
  *params = 8;
#line 35212
  break;
  default: 
#line 35214
  gl_error(ctx, 1280, "glGetTexLevelParameter[if]v(pname)");
  }
#line 35217
  break;
  case 3553: 
#line 35219
  tex = (ctx->Texture.Current2D)->Image[level];
#line 35220
  switch (pname) {
  case 4096: 
#line 35222
  *params = (int )tex->Width;
#line 35223
  break;
  case 4097: 
#line 35225
  *params = (int )tex->Height;
#line 35226
  break;
  case 4099: 
#line 35228
  *params = tex->Format;
#line 35229
  break;
  case 4101: 
#line 35231
  *params = (int )tex->Border;
#line 35232
  break;
  case 32860: 
  case 32861: 
  case 32862: 
  case 32863: 
  case 32865: 
  case 32864: 
#line 35239
  *params = 8;
#line 35240
  break;
  case 32993: 
#line 35242
  *params = 8;
#line 35243
  break;
  default: 
#line 35245
  gl_error(ctx, 1280, "glGetTexLevelParameter[if]v(pname)");
  }
#line 35248
  break;
  case 32879: 
#line 35250
  tex = (ctx->Texture.Current3D)->Image[level];
#line 35251
  switch (pname) {
  case 4096: 
#line 35253
  *params = (int )tex->Width;
#line 35254
  break;
  case 4097: 
#line 35256
  *params = (int )tex->Height;
#line 35257
  break;
  case 32881: 
#line 35259
  *params = (int )tex->Depth;
#line 35260
  break;
  case 4099: 
#line 35262
  *params = tex->Format;
#line 35263
  break;
  case 4101: 
#line 35265
  *params = (int )tex->Border;
#line 35266
  break;
  case 32993: 
#line 35268
  *params = 8;
#line 35269
  break;
  default: 
#line 35271
  gl_error(ctx, 1280, "glGetTexLevelParameter[if]v(pname)");
  }
#line 35274
  break;
  case 32867: 
#line 35276
  tex = (ctx->Texture.Proxy1D)->Image[level];
#line 35277
  switch (pname) {
  case 4096: 
#line 35279
  *params = (int )tex->Width;
#line 35280
  break;
  case 4099: 
#line 35282
  *params = tex->Format;
#line 35283
  break;
  case 4101: 
#line 35285
  *params = (int )tex->Border;
#line 35286
  break;
  case 32860: 
  case 32861: 
  case 32862: 
  case 32863: 
  case 32865: 
  case 32864: 
#line 35293
  *params = 8;
#line 35294
  break;
  case 32993: 
#line 35296
  *params = 8;
#line 35297
  break;
  default: 
#line 35299
  gl_error(ctx, 1280, "glGetTexLevelParameter[if]v(pname)");
  }
#line 35302
  break;
  case 32868: 
#line 35304
  tex = (ctx->Texture.Proxy2D)->Image[level];
#line 35305
  switch (pname) {
  case 4096: 
#line 35307
  *params = (int )tex->Width;
#line 35308
  break;
  case 4097: 
#line 35310
  *params = (int )tex->Height;
#line 35311
  break;
  case 4099: 
#line 35313
  *params = tex->Format;
#line 35314
  break;
  case 4101: 
#line 35316
  *params = (int )tex->Border;
#line 35317
  break;
  case 32860: 
  case 32861: 
  case 32862: 
  case 32863: 
  case 32865: 
  case 32864: 
#line 35324
  *params = 8;
#line 35325
  break;
  case 32993: 
#line 35327
  *params = 8;
#line 35328
  break;
  default: 
#line 35330
  gl_error(ctx, 1280, "glGetTexLevelParameter[if]v(pname)");
  }
#line 35333
  break;
  case 32880: 
#line 35335
  tex = (ctx->Texture.Proxy3D)->Image[level];
#line 35336
  switch (pname) {
  case 4096: 
#line 35338
  *params = (int )tex->Width;
#line 35339
  break;
  case 4097: 
#line 35341
  *params = (int )tex->Height;
#line 35342
  break;
  case 32881: 
#line 35344
  *params = (int )tex->Depth;
#line 35345
  break;
  case 4099: 
#line 35347
  *params = tex->Format;
#line 35348
  break;
  case 4101: 
#line 35350
  *params = (int )tex->Border;
#line 35351
  break;
  case 32860: 
  case 32861: 
  case 32862: 
  case 32863: 
  case 32865: 
  case 32864: 
#line 35358
  *params = 8;
#line 35359
  break;
  case 32993: 
#line 35361
  *params = 8;
#line 35362
  break;
  default: 
#line 35364
  gl_error(ctx, 1280, "glGetTexLevelParameter[if]v(pname)");
  }
#line 35367
  break;
  default: 
#line 35369
  gl_error(ctx, 1280, "glGetTexLevelParameter[if]v(target)");
  }
#line 35371
  return;
}
}
#line 35372 "D:/a/test/177.c"
void gl_GetTexParameterfv(GLcontext *ctx , GLenum target , GLenum pname , float *params ) 
{ 

  {
#line 35375
  switch (target) {
  case 3552: 
#line 35377
  switch (pname) {
  case 10240: 
#line 35379
  *params = (float )(ctx->Texture.Current1D)->MagFilter;
#line 35380
  break;
  case 10241: 
#line 35382
  *params = (float )(ctx->Texture.Current1D)->MinFilter;
#line 35383
  break;
  case 10242: 
#line 35385
  *params = (float )(ctx->Texture.Current1D)->WrapS;
#line 35386
  break;
  case 10243: 
#line 35388
  *params = (float )(ctx->Texture.Current1D)->WrapT;
#line 35389
  break;
  case 4100: 
#line 35391
  *(params + 0) = (float )(ctx->Texture.Current1D)->BorderColor[0] / 255.0f;
#line 35392
  *(params + 1) = (float )(ctx->Texture.Current1D)->BorderColor[1] / 255.0f;
#line 35393
  *(params + 2) = (float )(ctx->Texture.Current1D)->BorderColor[2] / 255.0f;
#line 35394
  *(params + 3) = (float )(ctx->Texture.Current1D)->BorderColor[3] / 255.0f;
#line 35395
  break;
  case 32871: 
#line 35397
  *params = (float )1;
#line 35398
  break;
  case 32870: 
#line 35400
  *params = (ctx->Texture.Current1D)->Priority;
#line 35401
  break;
  default: 
#line 35403
  gl_error(ctx, 1280, "glGetTexParameterfv(pname)");
  }
#line 35405
  break;
  case 3553: 
#line 35407
  switch (pname) {
  case 10240: 
#line 35409
  *params = (float )(ctx->Texture.Current2D)->MagFilter;
#line 35410
  break;
  case 10241: 
#line 35412
  *params = (float )(ctx->Texture.Current2D)->MinFilter;
#line 35413
  break;
  case 10242: 
#line 35415
  *params = (float )(ctx->Texture.Current2D)->WrapS;
#line 35416
  break;
  case 10243: 
#line 35418
  *params = (float )(ctx->Texture.Current2D)->WrapT;
#line 35419
  break;
  case 4100: 
#line 35421
  *(params + 0) = (float )(ctx->Texture.Current2D)->BorderColor[0] / 255.0f;
#line 35422
  *(params + 1) = (float )(ctx->Texture.Current2D)->BorderColor[1] / 255.0f;
#line 35423
  *(params + 2) = (float )(ctx->Texture.Current2D)->BorderColor[2] / 255.0f;
#line 35424
  *(params + 3) = (float )(ctx->Texture.Current2D)->BorderColor[3] / 255.0f;
#line 35425
  break;
  case 32871: 
#line 35427
  *params = (float )1;
#line 35428
  break;
  case 32870: 
#line 35430
  *params = (ctx->Texture.Current2D)->Priority;
#line 35431
  break;
  default: 
#line 35433
  gl_error(ctx, 1280, "glGetTexParameterfv(pname)");
  }
#line 35435
  break;
  case 32879: 
#line 35437
  switch (pname) {
  case 10240: 
#line 35439
  *params = (float )(ctx->Texture.Current3D)->MagFilter;
#line 35440
  break;
  case 10241: 
#line 35442
  *params = (float )(ctx->Texture.Current3D)->MinFilter;
#line 35443
  break;
  case 10242: 
#line 35445
  *params = (float )(ctx->Texture.Current3D)->WrapS;
#line 35446
  break;
  case 10243: 
#line 35448
  *params = (float )(ctx->Texture.Current3D)->WrapT;
#line 35449
  break;
  case 32882: 
#line 35451
  *params = (float )(ctx->Texture.Current3D)->WrapR;
#line 35452
  break;
  case 4100: 
#line 35454
  *(params + 0) = (float )(ctx->Texture.Current3D)->BorderColor[0] / 255.0f;
#line 35455
  *(params + 1) = (float )(ctx->Texture.Current3D)->BorderColor[1] / 255.0f;
#line 35456
  *(params + 2) = (float )(ctx->Texture.Current3D)->BorderColor[2] / 255.0f;
#line 35457
  *(params + 3) = (float )(ctx->Texture.Current3D)->BorderColor[3] / 255.0f;
#line 35458
  break;
  case 32871: 
#line 35460
  *params = (float )1;
#line 35461
  break;
  case 32870: 
#line 35463
  *params = (ctx->Texture.Current3D)->Priority;
#line 35464
  break;
  default: 
#line 35466
  gl_error(ctx, 1280, "glGetTexParameterfv(pname)");
  }
#line 35468
  break;
  default: 
#line 35470
  gl_error(ctx, 1280, "glGetTexParameterfv(target)");
  }
#line 35472
  return;
}
}
#line 35473 "D:/a/test/177.c"
void gl_GetTexParameteriv(GLcontext *ctx , GLenum target , GLenum pname , GLint *params ) 
{ float color[4] ;
  float color___0[4] ;
  float color___1[4] ;

  {
#line 35476
  switch (target) {
  case 3552: 
#line 35478
  switch (pname) {
  case 10240: 
#line 35480
  *params = (ctx->Texture.Current1D)->MagFilter;
#line 35481
  break;
  case 10241: 
#line 35483
  *params = (ctx->Texture.Current1D)->MinFilter;
#line 35484
  break;
  case 10242: 
#line 35486
  *params = (ctx->Texture.Current1D)->WrapS;
#line 35487
  break;
  case 10243: 
#line 35489
  *params = (ctx->Texture.Current1D)->WrapT;
#line 35490
  break;
  case 4100: 
#line 35494
  color[0] = (float )((double )(ctx->Texture.Current1D)->BorderColor[0] / 255.0);
#line 35495
  color[1] = (float )((double )(ctx->Texture.Current1D)->BorderColor[1] / 255.0);
#line 35496
  color[2] = (float )((double )(ctx->Texture.Current1D)->BorderColor[2] / 255.0);
#line 35497
  color[3] = (float )((double )(ctx->Texture.Current1D)->BorderColor[3] / 255.0);
#line 35498
  *(params + 0) = (int )(2147483647.0 * (double )color[0]);
#line 35499
  *(params + 1) = (int )(2147483647.0 * (double )color[1]);
#line 35500
  *(params + 2) = (int )(2147483647.0 * (double )color[2]);
#line 35501
  *(params + 3) = (int )(2147483647.0 * (double )color[3]);
#line 35503
  break;
  case 32871: 
#line 35505
  *params = 1;
#line 35506
  break;
  case 32870: 
#line 35508
  *params = (int )(ctx->Texture.Current1D)->Priority;
#line 35509
  break;
  default: 
#line 35511
  gl_error(ctx, 1280, "glGetTexParameteriv(pname)");
  }
#line 35513
  break;
  case 3553: 
#line 35515
  switch (pname) {
  case 10240: 
#line 35517
  *params = (ctx->Texture.Current2D)->MagFilter;
#line 35518
  break;
  case 10241: 
#line 35520
  *params = (ctx->Texture.Current2D)->MinFilter;
#line 35521
  break;
  case 10242: 
#line 35523
  *params = (ctx->Texture.Current2D)->WrapS;
#line 35524
  break;
  case 10243: 
#line 35526
  *params = (ctx->Texture.Current2D)->WrapT;
#line 35527
  break;
  case 4100: 
#line 35531
  color___0[0] = (float )((double )(ctx->Texture.Current2D)->BorderColor[0] / 255.0);
#line 35532
  color___0[1] = (float )((double )(ctx->Texture.Current2D)->BorderColor[1] / 255.0);
#line 35533
  color___0[2] = (float )((double )(ctx->Texture.Current2D)->BorderColor[2] / 255.0);
#line 35534
  color___0[3] = (float )((double )(ctx->Texture.Current2D)->BorderColor[3] / 255.0);
#line 35535
  *(params + 0) = (int )(2147483647.0 * (double )color___0[0]);
#line 35536
  *(params + 1) = (int )(2147483647.0 * (double )color___0[1]);
#line 35537
  *(params + 2) = (int )(2147483647.0 * (double )color___0[2]);
#line 35538
  *(params + 3) = (int )(2147483647.0 * (double )color___0[3]);
#line 35540
  break;
  case 32871: 
#line 35542
  *params = 1;
#line 35543
  break;
  case 32870: 
#line 35545
  *params = (int )(ctx->Texture.Current2D)->Priority;
#line 35546
  break;
  default: 
#line 35548
  gl_error(ctx, 1280, "glGetTexParameteriv(pname)");
  }
#line 35550
  break;
  case 32879: 
#line 35552
  switch (pname) {
  case 10240: 
#line 35554
  *params = (ctx->Texture.Current3D)->MagFilter;
#line 35555
  break;
  case 10241: 
#line 35557
  *params = (ctx->Texture.Current3D)->MinFilter;
#line 35558
  break;
  case 10242: 
#line 35560
  *params = (ctx->Texture.Current3D)->WrapS;
#line 35561
  break;
  case 10243: 
#line 35563
  *params = (ctx->Texture.Current3D)->WrapT;
#line 35564
  break;
  case 32882: 
#line 35566
  *params = (ctx->Texture.Current3D)->WrapR;
#line 35567
  break;
  case 4100: 
#line 35571
  color___1[0] = (float )((double )(ctx->Texture.Current3D)->BorderColor[0] / 255.0);
#line 35572
  color___1[1] = (float )((double )(ctx->Texture.Current3D)->BorderColor[1] / 255.0);
#line 35573
  color___1[2] = (float )((double )(ctx->Texture.Current3D)->BorderColor[2] / 255.0);
#line 35574
  color___1[3] = (float )((double )(ctx->Texture.Current3D)->BorderColor[3] / 255.0);
#line 35575
  *(params + 0) = (int )(2147483647.0 * (double )color___1[0]);
#line 35576
  *(params + 1) = (int )(2147483647.0 * (double )color___1[1]);
#line 35577
  *(params + 2) = (int )(2147483647.0 * (double )color___1[2]);
#line 35578
  *(params + 3) = (int )(2147483647.0 * (double )color___1[3]);
#line 35580
  break;
  case 32871: 
#line 35582
  *params = 1;
#line 35583
  break;
  case 32870: 
#line 35585
  *params = (int )(ctx->Texture.Current3D)->Priority;
#line 35586
  break;
  default: 
#line 35588
  gl_error(ctx, 1280, "glGetTexParameteriv(pname)");
  }
#line 35590
  break;
  default: 
#line 35592
  gl_error(ctx, 1280, "glGetTexParameteriv(target)");
  }
#line 35594
  return;
}
}
#line 35595 "D:/a/test/177.c"
void gl_TexGenfv(GLcontext *ctx , GLenum coord , GLenum pname , float const   *params ) 
{ GLenum mode ;
  GLenum mode___0 ;
  GLenum mode___1 ;
  GLenum mode___2 ;

  {
#line 35598
  if (ctx->Primitive != 6656) {
#line 35599
    gl_error(ctx, 1282, "glTexGenfv");
#line 35600
    return;
  }
#line 35602
  switch (coord) {
  case 8192: 
#line 35604
  if (pname == 9472) {
#line 35605
    mode = (int )*params;
#line 35606
    if (mode == 9217) {
#line 35609
      ctx->Texture.GenModeS = mode;
    } else {
#line 35606
      if (mode == 9216) {
#line 35609
        ctx->Texture.GenModeS = mode;
      } else {
#line 35606
        if (mode == 9218) {
#line 35609
          ctx->Texture.GenModeS = mode;
        } else {
#line 35612
          gl_error(ctx, 1280, "glTexGenfv(param)");
#line 35613
          return;
        }
      }
    }
  } else {
#line 35616
    if (pname == 9473) {
#line 35617
      ctx->Texture.ObjectPlaneS[0] = (float )*(params + 0);
#line 35618
      ctx->Texture.ObjectPlaneS[1] = (float )*(params + 1);
#line 35619
      ctx->Texture.ObjectPlaneS[2] = (float )*(params + 2);
#line 35620
      ctx->Texture.ObjectPlaneS[3] = (float )*(params + 3);
    } else {
#line 35622
      if (pname == 9474) {
#line 35623
        if (ctx->NewModelViewMatrix) {
#line 35624
          gl_analyze_modelview_matrix(ctx);
        }
#line 35626
        gl_transform_vector(ctx->Texture.EyePlaneS, params, ctx->ModelViewInv);
      } else {
#line 35630
        gl_error(ctx, 1280, "glTexGenfv(pname)");
#line 35631
        return;
      }
    }
  }
#line 35633
  break;
  case 8193: 
#line 35635
  if (pname == 9472) {
#line 35636
    mode___0 = (int )*params;
#line 35637
    if (mode___0 == 9217) {
#line 35640
      ctx->Texture.GenModeT = mode___0;
    } else {
#line 35637
      if (mode___0 == 9216) {
#line 35640
        ctx->Texture.GenModeT = mode___0;
      } else {
#line 35637
        if (mode___0 == 9218) {
#line 35640
          ctx->Texture.GenModeT = mode___0;
        } else {
#line 35643
          gl_error(ctx, 1280, "glTexGenfv(param)");
#line 35644
          return;
        }
      }
    }
  } else {
#line 35647
    if (pname == 9473) {
#line 35648
      ctx->Texture.ObjectPlaneT[0] = (float )*(params + 0);
#line 35649
      ctx->Texture.ObjectPlaneT[1] = (float )*(params + 1);
#line 35650
      ctx->Texture.ObjectPlaneT[2] = (float )*(params + 2);
#line 35651
      ctx->Texture.ObjectPlaneT[3] = (float )*(params + 3);
    } else {
#line 35653
      if (pname == 9474) {
#line 35654
        if (ctx->NewModelViewMatrix) {
#line 35655
          gl_analyze_modelview_matrix(ctx);
        }
#line 35657
        gl_transform_vector(ctx->Texture.EyePlaneT, params, ctx->ModelViewInv);
      } else {
#line 35661
        gl_error(ctx, 1280, "glTexGenfv(pname)");
#line 35662
        return;
      }
    }
  }
#line 35664
  break;
  case 8194: 
#line 35666
  if (pname == 9472) {
#line 35667
    mode___1 = (int )*params;
#line 35668
    if (mode___1 == 9217) {
#line 35670
      ctx->Texture.GenModeR = mode___1;
    } else {
#line 35668
      if (mode___1 == 9216) {
#line 35670
        ctx->Texture.GenModeR = mode___1;
      } else {
#line 35673
        gl_error(ctx, 1280, "glTexGenfv(param)");
#line 35674
        return;
      }
    }
  } else {
#line 35677
    if (pname == 9473) {
#line 35678
      ctx->Texture.ObjectPlaneR[0] = (float )*(params + 0);
#line 35679
      ctx->Texture.ObjectPlaneR[1] = (float )*(params + 1);
#line 35680
      ctx->Texture.ObjectPlaneR[2] = (float )*(params + 2);
#line 35681
      ctx->Texture.ObjectPlaneR[3] = (float )*(params + 3);
    } else {
#line 35683
      if (pname == 9474) {
#line 35684
        if (ctx->NewModelViewMatrix) {
#line 35685
          gl_analyze_modelview_matrix(ctx);
        }
#line 35687
        gl_transform_vector(ctx->Texture.EyePlaneR, params, ctx->ModelViewInv);
      } else {
#line 35691
        gl_error(ctx, 1280, "glTexGenfv(pname)");
#line 35692
        return;
      }
    }
  }
#line 35694
  break;
  case 8195: 
#line 35696
  if (pname == 9472) {
#line 35697
    mode___2 = (int )*params;
#line 35698
    if (mode___2 == 9217) {
#line 35700
      ctx->Texture.GenModeQ = mode___2;
    } else {
#line 35698
      if (mode___2 == 9216) {
#line 35700
        ctx->Texture.GenModeQ = mode___2;
      } else {
#line 35703
        gl_error(ctx, 1280, "glTexGenfv(param)");
#line 35704
        return;
      }
    }
  } else {
#line 35707
    if (pname == 9473) {
#line 35708
      ctx->Texture.ObjectPlaneQ[0] = (float )*(params + 0);
#line 35709
      ctx->Texture.ObjectPlaneQ[1] = (float )*(params + 1);
#line 35710
      ctx->Texture.ObjectPlaneQ[2] = (float )*(params + 2);
#line 35711
      ctx->Texture.ObjectPlaneQ[3] = (float )*(params + 3);
    } else {
#line 35713
      if (pname == 9474) {
#line 35714
        if (ctx->NewModelViewMatrix) {
#line 35715
          gl_analyze_modelview_matrix(ctx);
        }
#line 35717
        gl_transform_vector(ctx->Texture.EyePlaneQ, params, ctx->ModelViewInv);
      } else {
#line 35721
        gl_error(ctx, 1280, "glTexGenfv(pname)");
#line 35722
        return;
      }
    }
  }
#line 35724
  break;
  default: 
#line 35726
  gl_error(ctx, 1280, "glTexGenfv(coord)");
#line 35727
  return;
  }
#line 35729
  ctx->NewState |= 4U;
#line 35730
  return;
}
}
#line 35731 "D:/a/test/177.c"
void gl_GetTexGendv(GLcontext *ctx , GLenum coord , GLenum pname , GLdouble *params ) 
{ 

  {
#line 35734
  if (ctx->Primitive != 6656) {
#line 35735
    gl_error(ctx, 1282, "glGetTexGendv");
#line 35736
    return;
  }
#line 35738
  switch (coord) {
  case 8192: 
#line 35740
  if (pname == 9472) {
#line 35741
    *(params + 0) = (double )ctx->Texture.GenModeS;
  } else {
#line 35743
    if (pname == 9473) {
#line 35744
      *(params + 0) = (double )ctx->Texture.ObjectPlaneS[0];
#line 35744
      *(params + 1) = (double )ctx->Texture.ObjectPlaneS[1];
#line 35744
      *(params + 2) = (double )ctx->Texture.ObjectPlaneS[2];
#line 35744
      *(params + 3) = (double )ctx->Texture.ObjectPlaneS[3];
    } else {
#line 35746
      if (pname == 9474) {
#line 35747
        *(params + 0) = (double )ctx->Texture.EyePlaneS[0];
#line 35747
        *(params + 1) = (double )ctx->Texture.EyePlaneS[1];
#line 35747
        *(params + 2) = (double )ctx->Texture.EyePlaneS[2];
#line 35747
        *(params + 3) = (double )ctx->Texture.EyePlaneS[3];
      } else {
#line 35750
        gl_error(ctx, 1280, "glGetTexGendv(pname)");
#line 35751
        return;
      }
    }
  }
#line 35753
  break;
  case 8193: 
#line 35755
  if (pname == 9472) {
#line 35756
    *(params + 0) = (double )ctx->Texture.GenModeT;
  } else {
#line 35758
    if (pname == 9473) {
#line 35759
      *(params + 0) = (double )ctx->Texture.ObjectPlaneT[0];
#line 35759
      *(params + 1) = (double )ctx->Texture.ObjectPlaneT[1];
#line 35759
      *(params + 2) = (double )ctx->Texture.ObjectPlaneT[2];
#line 35759
      *(params + 3) = (double )ctx->Texture.ObjectPlaneT[3];
    } else {
#line 35761
      if (pname == 9474) {
#line 35762
        *(params + 0) = (double )ctx->Texture.EyePlaneT[0];
#line 35762
        *(params + 1) = (double )ctx->Texture.EyePlaneT[1];
#line 35762
        *(params + 2) = (double )ctx->Texture.EyePlaneT[2];
#line 35762
        *(params + 3) = (double )ctx->Texture.EyePlaneT[3];
      } else {
#line 35765
        gl_error(ctx, 1280, "glGetTexGendv(pname)");
#line 35766
        return;
      }
    }
  }
#line 35768
  break;
  case 8194: 
#line 35770
  if (pname == 9472) {
#line 35771
    *(params + 0) = (double )ctx->Texture.GenModeR;
  } else {
#line 35773
    if (pname == 9473) {
#line 35774
      *(params + 0) = (double )ctx->Texture.ObjectPlaneR[0];
#line 35774
      *(params + 1) = (double )ctx->Texture.ObjectPlaneR[1];
#line 35774
      *(params + 2) = (double )ctx->Texture.ObjectPlaneR[2];
#line 35774
      *(params + 3) = (double )ctx->Texture.ObjectPlaneR[3];
    } else {
#line 35776
      if (pname == 9474) {
#line 35777
        *(params + 0) = (double )ctx->Texture.EyePlaneR[0];
#line 35777
        *(params + 1) = (double )ctx->Texture.EyePlaneR[1];
#line 35777
        *(params + 2) = (double )ctx->Texture.EyePlaneR[2];
#line 35777
        *(params + 3) = (double )ctx->Texture.EyePlaneR[3];
      } else {
#line 35780
        gl_error(ctx, 1280, "glGetTexGendv(pname)");
#line 35781
        return;
      }
    }
  }
#line 35783
  break;
  case 8195: 
#line 35785
  if (pname == 9472) {
#line 35786
    *(params + 0) = (double )ctx->Texture.GenModeQ;
  } else {
#line 35788
    if (pname == 9473) {
#line 35789
      *(params + 0) = (double )ctx->Texture.ObjectPlaneQ[0];
#line 35789
      *(params + 1) = (double )ctx->Texture.ObjectPlaneQ[1];
#line 35789
      *(params + 2) = (double )ctx->Texture.ObjectPlaneQ[2];
#line 35789
      *(params + 3) = (double )ctx->Texture.ObjectPlaneQ[3];
    } else {
#line 35791
      if (pname == 9474) {
#line 35792
        *(params + 0) = (double )ctx->Texture.EyePlaneQ[0];
#line 35792
        *(params + 1) = (double )ctx->Texture.EyePlaneQ[1];
#line 35792
        *(params + 2) = (double )ctx->Texture.EyePlaneQ[2];
#line 35792
        *(params + 3) = (double )ctx->Texture.EyePlaneQ[3];
      } else {
#line 35795
        gl_error(ctx, 1280, "glGetTexGendv(pname)");
#line 35796
        return;
      }
    }
  }
#line 35798
  break;
  default: 
#line 35800
  gl_error(ctx, 1280, "glGetTexGendv(coord)");
#line 35801
  return;
  }
#line 35803
  return;
}
}
#line 35804 "D:/a/test/177.c"
void gl_GetTexGenfv(GLcontext *ctx , GLenum coord , GLenum pname , float *params ) 
{ 

  {
#line 35807
  if (ctx->Primitive != 6656) {
#line 35808
    gl_error(ctx, 1282, "glGetTexGenfv");
#line 35809
    return;
  }
#line 35811
  switch (coord) {
  case 8192: 
#line 35813
  if (pname == 9472) {
#line 35814
    *(params + 0) = (float )ctx->Texture.GenModeS;
  } else {
#line 35816
    if (pname == 9473) {
#line 35817
      *(params + 0) = ctx->Texture.ObjectPlaneS[0];
#line 35817
      *(params + 1) = ctx->Texture.ObjectPlaneS[1];
#line 35817
      *(params + 2) = ctx->Texture.ObjectPlaneS[2];
#line 35817
      *(params + 3) = ctx->Texture.ObjectPlaneS[3];
    } else {
#line 35819
      if (pname == 9474) {
#line 35820
        *(params + 0) = ctx->Texture.EyePlaneS[0];
#line 35820
        *(params + 1) = ctx->Texture.EyePlaneS[1];
#line 35820
        *(params + 2) = ctx->Texture.EyePlaneS[2];
#line 35820
        *(params + 3) = ctx->Texture.EyePlaneS[3];
      } else {
#line 35823
        gl_error(ctx, 1280, "glGetTexGenfv(pname)");
#line 35824
        return;
      }
    }
  }
#line 35826
  break;
  case 8193: 
#line 35828
  if (pname == 9472) {
#line 35829
    *(params + 0) = (float )ctx->Texture.GenModeT;
  } else {
#line 35831
    if (pname == 9473) {
#line 35832
      *(params + 0) = ctx->Texture.ObjectPlaneT[0];
#line 35832
      *(params + 1) = ctx->Texture.ObjectPlaneT[1];
#line 35832
      *(params + 2) = ctx->Texture.ObjectPlaneT[2];
#line 35832
      *(params + 3) = ctx->Texture.ObjectPlaneT[3];
    } else {
#line 35834
      if (pname == 9474) {
#line 35835
        *(params + 0) = ctx->Texture.EyePlaneT[0];
#line 35835
        *(params + 1) = ctx->Texture.EyePlaneT[1];
#line 35835
        *(params + 2) = ctx->Texture.EyePlaneT[2];
#line 35835
        *(params + 3) = ctx->Texture.EyePlaneT[3];
      } else {
#line 35838
        gl_error(ctx, 1280, "glGetTexGenfv(pname)");
#line 35839
        return;
      }
    }
  }
#line 35841
  break;
  case 8194: 
#line 35843
  if (pname == 9472) {
#line 35844
    *(params + 0) = (float )ctx->Texture.GenModeR;
  } else {
#line 35846
    if (pname == 9473) {
#line 35847
      *(params + 0) = ctx->Texture.ObjectPlaneR[0];
#line 35847
      *(params + 1) = ctx->Texture.ObjectPlaneR[1];
#line 35847
      *(params + 2) = ctx->Texture.ObjectPlaneR[2];
#line 35847
      *(params + 3) = ctx->Texture.ObjectPlaneR[3];
    } else {
#line 35849
      if (pname == 9474) {
#line 35850
        *(params + 0) = ctx->Texture.EyePlaneR[0];
#line 35850
        *(params + 1) = ctx->Texture.EyePlaneR[1];
#line 35850
        *(params + 2) = ctx->Texture.EyePlaneR[2];
#line 35850
        *(params + 3) = ctx->Texture.EyePlaneR[3];
      } else {
#line 35853
        gl_error(ctx, 1280, "glGetTexGenfv(pname)");
#line 35854
        return;
      }
    }
  }
#line 35856
  break;
  case 8195: 
#line 35858
  if (pname == 9472) {
#line 35859
    *(params + 0) = (float )ctx->Texture.GenModeQ;
  } else {
#line 35861
    if (pname == 9473) {
#line 35862
      *(params + 0) = ctx->Texture.ObjectPlaneQ[0];
#line 35862
      *(params + 1) = ctx->Texture.ObjectPlaneQ[1];
#line 35862
      *(params + 2) = ctx->Texture.ObjectPlaneQ[2];
#line 35862
      *(params + 3) = ctx->Texture.ObjectPlaneQ[3];
    } else {
#line 35864
      if (pname == 9474) {
#line 35865
        *(params + 0) = ctx->Texture.EyePlaneQ[0];
#line 35865
        *(params + 1) = ctx->Texture.EyePlaneQ[1];
#line 35865
        *(params + 2) = ctx->Texture.EyePlaneQ[2];
#line 35865
        *(params + 3) = ctx->Texture.EyePlaneQ[3];
      } else {
#line 35868
        gl_error(ctx, 1280, "glGetTexGenfv(pname)");
#line 35869
        return;
      }
    }
  }
#line 35871
  break;
  default: 
#line 35873
  gl_error(ctx, 1280, "glGetTexGenfv(coord)");
#line 35874
  return;
  }
#line 35876
  return;
}
}
#line 35877 "D:/a/test/177.c"
void gl_GetTexGeniv(GLcontext *ctx , GLenum coord , GLenum pname , GLint *params ) 
{ 

  {
#line 35880
  if (ctx->Primitive != 6656) {
#line 35881
    gl_error(ctx, 1282, "glGetTexGeniv");
#line 35882
    return;
  }
#line 35884
  switch (coord) {
  case 8192: 
#line 35886
  if (pname == 9472) {
#line 35887
    *(params + 0) = ctx->Texture.GenModeS;
  } else {
#line 35889
    if (pname == 9473) {
#line 35890
      *(params + 0) = (int )ctx->Texture.ObjectPlaneS[0];
#line 35890
      *(params + 1) = (int )ctx->Texture.ObjectPlaneS[1];
#line 35890
      *(params + 2) = (int )ctx->Texture.ObjectPlaneS[2];
#line 35890
      *(params + 3) = (int )ctx->Texture.ObjectPlaneS[3];
    } else {
#line 35892
      if (pname == 9474) {
#line 35893
        *(params + 0) = (int )ctx->Texture.EyePlaneS[0];
#line 35893
        *(params + 1) = (int )ctx->Texture.EyePlaneS[1];
#line 35893
        *(params + 2) = (int )ctx->Texture.EyePlaneS[2];
#line 35893
        *(params + 3) = (int )ctx->Texture.EyePlaneS[3];
      } else {
#line 35896
        gl_error(ctx, 1280, "glGetTexGeniv(pname)");
#line 35897
        return;
      }
    }
  }
#line 35899
  break;
  case 8193: 
#line 35901
  if (pname == 9472) {
#line 35902
    *(params + 0) = ctx->Texture.GenModeT;
  } else {
#line 35904
    if (pname == 9473) {
#line 35905
      *(params + 0) = (int )ctx->Texture.ObjectPlaneT[0];
#line 35905
      *(params + 1) = (int )ctx->Texture.ObjectPlaneT[1];
#line 35905
      *(params + 2) = (int )ctx->Texture.ObjectPlaneT[2];
#line 35905
      *(params + 3) = (int )ctx->Texture.ObjectPlaneT[3];
    } else {
#line 35907
      if (pname == 9474) {
#line 35908
        *(params + 0) = (int )ctx->Texture.EyePlaneT[0];
#line 35908
        *(params + 1) = (int )ctx->Texture.EyePlaneT[1];
#line 35908
        *(params + 2) = (int )ctx->Texture.EyePlaneT[2];
#line 35908
        *(params + 3) = (int )ctx->Texture.EyePlaneT[3];
      } else {
#line 35911
        gl_error(ctx, 1280, "glGetTexGeniv(pname)");
#line 35912
        return;
      }
    }
  }
#line 35914
  break;
  case 8194: 
#line 35916
  if (pname == 9472) {
#line 35917
    *(params + 0) = ctx->Texture.GenModeR;
  } else {
#line 35919
    if (pname == 9473) {
#line 35920
      *(params + 0) = (int )ctx->Texture.ObjectPlaneR[0];
#line 35920
      *(params + 1) = (int )ctx->Texture.ObjectPlaneR[1];
#line 35920
      *(params + 2) = (int )ctx->Texture.ObjectPlaneR[2];
#line 35920
      *(params + 3) = (int )ctx->Texture.ObjectPlaneR[3];
    } else {
#line 35922
      if (pname == 9474) {
#line 35923
        *(params + 0) = (int )ctx->Texture.EyePlaneR[0];
#line 35923
        *(params + 1) = (int )ctx->Texture.EyePlaneR[1];
#line 35923
        *(params + 2) = (int )ctx->Texture.EyePlaneR[2];
#line 35923
        *(params + 3) = (int )ctx->Texture.EyePlaneR[3];
      } else {
#line 35926
        gl_error(ctx, 1280, "glGetTexGeniv(pname)");
#line 35927
        return;
      }
    }
  }
#line 35929
  break;
  case 8195: 
#line 35931
  if (pname == 9472) {
#line 35932
    *(params + 0) = ctx->Texture.GenModeQ;
  } else {
#line 35934
    if (pname == 9473) {
#line 35935
      *(params + 0) = (int )ctx->Texture.ObjectPlaneQ[0];
#line 35935
      *(params + 1) = (int )ctx->Texture.ObjectPlaneQ[1];
#line 35935
      *(params + 2) = (int )ctx->Texture.ObjectPlaneQ[2];
#line 35935
      *(params + 3) = (int )ctx->Texture.ObjectPlaneQ[3];
    } else {
#line 35937
      if (pname == 9474) {
#line 35938
        *(params + 0) = (int )ctx->Texture.EyePlaneQ[0];
#line 35938
        *(params + 1) = (int )ctx->Texture.EyePlaneQ[1];
#line 35938
        *(params + 2) = (int )ctx->Texture.EyePlaneQ[2];
#line 35938
        *(params + 3) = (int )ctx->Texture.EyePlaneQ[3];
      } else {
#line 35941
        gl_error(ctx, 1280, "glGetTexGeniv(pname)");
#line 35942
        return;
      }
    }
  }
#line 35944
  break;
  default: 
#line 35946
  gl_error(ctx, 1280, "glGetTexGeniv(coord)");
#line 35947
  return;
  }
#line 35949
  return;
}
}
#line 35964
void gl_set_texture_sampler(struct gl_texture_object *t ) ;
#line 35950 "D:/a/test/177.c"
void gl_update_texture_state(GLcontext *ctx ) 
{ struct gl_texture_object *t ;

  {
#line 35953
  if (ctx->Texture.Enabled & 4U) {
#line 35954
    ctx->Texture.Current = ctx->Texture.Current3D;
  } else {
#line 35955
    if (ctx->Texture.Enabled & 2U) {
#line 35956
      ctx->Texture.Current = ctx->Texture.Current2D;
    } else {
#line 35957
      if (ctx->Texture.Enabled & 1U) {
#line 35958
        ctx->Texture.Current = ctx->Texture.Current1D;
      } else {
#line 35960
        ctx->Texture.Current = (struct gl_texture_object *)((void *)0);
      }
    }
  }
#line 35961
  t = (ctx->Shared)->TexObjectList;
#line 35961
  while (t) {
#line 35962
    if (t->Dirty) {
#line 35963
      gl_test_texture_object_completeness(t);
#line 35964
      gl_set_texture_sampler(t);
#line 35965
      t->Dirty = (unsigned char)0;
    }
#line 35961
    t = t->Next;
  }
#line 35968
  return;
}
}
#line 35975 "D:/a/test/177.c"
void gl_texgen(GLcontext *ctx , GLint n , float (*obj)[4] , float (*eye)[4] , float (*normal)[3] ,
               float (*texcoord)[4] ) 
{ GLint i ;
  float u[3] ;
  float two_nu ;
  float m ;
  float fx ;
  float fy ;
  float fz ;
  int tmp___0 ;
  float mInv ;
  GLint i___0 ;
  float u___0[3] ;
  float two_nu___0 ;
  float m___0 ;
  float fx___0 ;
  float fy___0 ;
  float fz___0 ;
  int tmp___1 ;
  GLint i___1 ;
  float u___1[3] ;
  float two_nu___1 ;
  float m___1 ;
  float fx___1 ;
  float fy___1 ;
  float fz___1 ;
  int tmp___2 ;
  GLint i___2 ;
  GLint i___3 ;

  {
#line 35979
  if (ctx->Texture.TexGenEnabled == 12U) {
#line 35979
    if (ctx->Texture.GenModeS == 9218) {
#line 35979
      if (ctx->Texture.GenModeT == 9218) {
#line 35983
        i = 0;
#line 35983
        while (i < n) {
#line 35985
          u[0] = (*(eye + i))[0];
#line 35985
          u[1] = (*(eye + i))[1];
#line 35985
          u[2] = (*(eye + i))[2];
#line 35986
          NORMALIZE_3FV(u);
#line 35987
          two_nu = 2.0F * (((*(normal + i))[0] * u[0] + (*(normal + i))[1] * u[1]) + (*(normal + i))[2] * u[2]);
#line 35988
          fx = u[0] - (*(normal + i))[0] * two_nu;
#line 35989
          fy = u[1] - (*(normal + i))[1] * two_nu;
#line 35990
          fz = u[2] - (*(normal + i))[2] * two_nu;
#line 35991
          tmp___0 = GL_SQRT((fx * fx + fy * fy) + (fz + 1.0F) * (fz + 1.0F));
#line 35991
          m = 2.0F * (float )tmp___0;
#line 35992
          if (m == 0.0F) {
#line 35993
            (*(texcoord + i))[0] = 0.5F;
#line 35994
            (*(texcoord + i))[1] = 0.5F;
          } else {
#line 35997
            mInv = 1.0F / m;
#line 35998
            (*(texcoord + i))[0] = fx * mInv + 0.5F;
#line 35999
            (*(texcoord + i))[1] = fy * mInv + 0.5F;
          }
#line 35983
          i ++;
        }
#line 36002
        return;
      }
    }
  }
#line 36004
  if (ctx->Texture.TexGenEnabled & 4U) {
#line 36006
    switch (ctx->Texture.GenModeS) {
    case 9217: 
#line 36008
    i___0 = 0;
#line 36008
    while (i___0 < n) {
#line 36009
      (*(texcoord + i___0))[0] = (((*(obj + i___0))[0] * ctx->Texture.ObjectPlaneS[0] + (*(obj + i___0))[1] * ctx->Texture.ObjectPlaneS[1]) + (*(obj + i___0))[2] * ctx->Texture.ObjectPlaneS[2]) + (*(obj + i___0))[3] * ctx->Texture.ObjectPlaneS[3];
#line 36008
      i___0 ++;
    }
#line 36011
    break;
    case 9216: 
#line 36013
    i___0 = 0;
#line 36013
    while (i___0 < n) {
#line 36014
      (*(texcoord + i___0))[0] = (((*(eye + i___0))[0] * ctx->Texture.EyePlaneS[0] + (*(eye + i___0))[1] * ctx->Texture.EyePlaneS[1]) + (*(eye + i___0))[2] * ctx->Texture.EyePlaneS[2]) + (*(eye + i___0))[3] * ctx->Texture.EyePlaneS[3];
#line 36013
      i___0 ++;
    }
#line 36016
    break;
    case 9218: 
#line 36018
    i___0 = 0;
#line 36018
    while (i___0 < n) {
#line 36020
      u___0[0] = (*(eye + i___0))[0];
#line 36020
      u___0[1] = (*(eye + i___0))[1];
#line 36020
      u___0[2] = (*(eye + i___0))[2];
#line 36021
      NORMALIZE_3FV(u___0);
#line 36022
      two_nu___0 = (float )(2.0 * (double )(((*(normal + i___0))[0] * u___0[0] + (*(normal + i___0))[1] * u___0[1]) + (*(normal + i___0))[2] * u___0[2]));
#line 36023
      fx___0 = u___0[0] - (*(normal + i___0))[0] * two_nu___0;
#line 36024
      fy___0 = u___0[1] - (*(normal + i___0))[1] * two_nu___0;
#line 36025
      fz___0 = u___0[2] - (*(normal + i___0))[2] * two_nu___0;
#line 36026
      tmp___1 = GL_SQRT((double )(fx___0 * fx___0 + fy___0 * fy___0) + ((double )fz___0 + 1.0) * ((double )fz___0 + 1.0));
#line 36026
      m___0 = 2.0F * (float )tmp___1;
#line 36027
      if (m___0 == 0.0F) {
#line 36028
        (*(texcoord + i___0))[0] = 0.5F;
      } else {
#line 36031
        (*(texcoord + i___0))[0] = fx___0 / m___0 + 0.5F;
      }
#line 36018
      i___0 ++;
    }
#line 36034
    break;
    default: 
#line 36036
    gl_problem((GLcontext const   *)ctx, "Bad S texgen");
#line 36037
    return;
    }
  }
#line 36040
  if (ctx->Texture.TexGenEnabled & 8U) {
#line 36042
    switch (ctx->Texture.GenModeT) {
    case 9217: 
#line 36044
    i___1 = 0;
#line 36044
    while (i___1 < n) {
#line 36045
      (*(texcoord + i___1))[1] = (((*(obj + i___1))[0] * ctx->Texture.ObjectPlaneT[0] + (*(obj + i___1))[1] * ctx->Texture.ObjectPlaneT[1]) + (*(obj + i___1))[2] * ctx->Texture.ObjectPlaneT[2]) + (*(obj + i___1))[3] * ctx->Texture.ObjectPlaneT[3];
#line 36044
      i___1 ++;
    }
#line 36047
    break;
    case 9216: 
#line 36049
    i___1 = 0;
#line 36049
    while (i___1 < n) {
#line 36050
      (*(texcoord + i___1))[1] = (((*(eye + i___1))[0] * ctx->Texture.EyePlaneT[0] + (*(eye + i___1))[1] * ctx->Texture.EyePlaneT[1]) + (*(eye + i___1))[2] * ctx->Texture.EyePlaneT[2]) + (*(eye + i___1))[3] * ctx->Texture.EyePlaneT[3];
#line 36049
      i___1 ++;
    }
#line 36052
    break;
    case 9218: 
#line 36054
    i___1 = 0;
#line 36054
    while (i___1 < n) {
#line 36056
      u___1[0] = (*(eye + i___1))[0];
#line 36056
      u___1[1] = (*(eye + i___1))[1];
#line 36056
      u___1[2] = (*(eye + i___1))[2];
#line 36057
      NORMALIZE_3FV(u___1);
#line 36058
      two_nu___1 = (float )(2.0 * (double )(((*(normal + i___1))[0] * u___1[0] + (*(normal + i___1))[1] * u___1[1]) + (*(normal + i___1))[2] * u___1[2]));
#line 36059
      fx___1 = u___1[0] - (*(normal + i___1))[0] * two_nu___1;
#line 36060
      fy___1 = u___1[1] - (*(normal + i___1))[1] * two_nu___1;
#line 36061
      fz___1 = u___1[2] - (*(normal + i___1))[2] * two_nu___1;
#line 36062
      tmp___2 = GL_SQRT((double )(fx___1 * fx___1 + fy___1 * fy___1) + ((double )fz___1 + 1.0) * ((double )fz___1 + 1.0));
#line 36062
      m___1 = 2.0F * (float )tmp___2;
#line 36063
      if (m___1 == 0.0F) {
#line 36064
        (*(texcoord + i___1))[1] = 0.5F;
      } else {
#line 36067
        (*(texcoord + i___1))[1] = fy___1 / m___1 + 0.5F;
      }
#line 36054
      i___1 ++;
    }
#line 36070
    break;
    default: 
#line 36072
    gl_problem((GLcontext const   *)ctx, "Bad T texgen");
#line 36073
    return;
    }
  }
#line 36076
  if (ctx->Texture.TexGenEnabled & 2U) {
#line 36078
    switch (ctx->Texture.GenModeR) {
    case 9217: 
#line 36080
    i___2 = 0;
#line 36080
    while (i___2 < n) {
#line 36081
      (*(texcoord + i___2))[2] = (((*(obj + i___2))[0] * ctx->Texture.ObjectPlaneR[0] + (*(obj + i___2))[1] * ctx->Texture.ObjectPlaneR[1]) + (*(obj + i___2))[2] * ctx->Texture.ObjectPlaneR[2]) + (*(obj + i___2))[3] * ctx->Texture.ObjectPlaneR[3];
#line 36080
      i___2 ++;
    }
#line 36083
    break;
    case 9216: 
#line 36085
    i___2 = 0;
#line 36085
    while (i___2 < n) {
#line 36086
      (*(texcoord + i___2))[2] = (((*(eye + i___2))[0] * ctx->Texture.EyePlaneR[0] + (*(eye + i___2))[1] * ctx->Texture.EyePlaneR[1]) + (*(eye + i___2))[2] * ctx->Texture.EyePlaneR[2]) + (*(eye + i___2))[3] * ctx->Texture.EyePlaneR[3];
#line 36085
      i___2 ++;
    }
#line 36088
    break;
    default: 
#line 36090
    gl_problem((GLcontext const   *)ctx, "Bad R texgen");
#line 36091
    return;
    }
  }
#line 36094
  if (ctx->Texture.TexGenEnabled & 1U) {
#line 36096
    switch (ctx->Texture.GenModeQ) {
    case 9217: 
#line 36098
    i___3 = 0;
#line 36098
    while (i___3 < n) {
#line 36099
      (*(texcoord + i___3))[3] = (((*(obj + i___3))[0] * ctx->Texture.ObjectPlaneQ[0] + (*(obj + i___3))[1] * ctx->Texture.ObjectPlaneQ[1]) + (*(obj + i___3))[2] * ctx->Texture.ObjectPlaneQ[2]) + (*(obj + i___3))[3] * ctx->Texture.ObjectPlaneQ[3];
#line 36098
      i___3 ++;
    }
#line 36101
    break;
    case 9216: 
#line 36103
    i___3 = 0;
#line 36103
    while (i___3 < n) {
#line 36104
      (*(texcoord + i___3))[3] = (((*(eye + i___3))[0] * ctx->Texture.EyePlaneQ[0] + (*(eye + i___3))[1] * ctx->Texture.EyePlaneQ[1]) + (*(eye + i___3))[2] * ctx->Texture.EyePlaneQ[2]) + (*(eye + i___3))[3] * ctx->Texture.EyePlaneQ[3];
#line 36103
      i___3 ++;
    }
#line 36106
    break;
    default: 
#line 36108
    gl_problem((GLcontext const   *)ctx, "Bad Q texgen");
#line 36109
    return;
    }
  }
#line 36112
  return;
}
}
#line 36113 "D:/a/test/177.c"
static void palette_sample(struct gl_texture_object  const  *tObj , GLubyte index___0 ,
                           GLubyte *red , GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLcontext *ctx ;
  GLcontext *tmp___0 ;
  GLint i ;
  GLubyte const   *palette ;

  {
#line 36117
  tmp___0 = gl_get_current_context();
#line 36117
  ctx = tmp___0;
#line 36118
  i = (GLint )index___0;
#line 36120
  if (ctx->Texture.SharedPalette) {
#line 36121
    palette = (GLubyte const   *)(ctx->Texture.Palette);
  } else {
#line 36124
    palette = (GLubyte const   *)(tObj->Palette);
  }
#line 36126
  switch ((int )tObj->PaletteFormat) {
  case 6406: 
#line 36128
  *alpha = tObj->Palette[index___0];
#line 36129
  return;
  case 6409: 
  case 32841: 
#line 36132
  *red = (unsigned char )*(palette + index___0);
#line 36133
  return;
  case 6410: 
#line 36135
  *red = (unsigned char )*(palette + ((int )index___0 << 1));
#line 36136
  *alpha = (unsigned char )*(palette + (((int )index___0 << 1) + 1));
#line 36137
  return;
  case 6407: 
#line 36139
  *red = (unsigned char )*(palette + (int )index___0 * 3);
#line 36140
  *green = (unsigned char )*(palette + ((int )index___0 * 3 + 1));
#line 36141
  *blue___0 = (unsigned char )*(palette + ((int )index___0 * 3 + 2));
#line 36142
  return;
  case 6408: 
#line 36144
  *red = (unsigned char )*(palette + (i << 2));
#line 36145
  *green = (unsigned char )*(palette + ((i << 2) + 1));
#line 36146
  *blue___0 = (unsigned char )*(palette + ((i << 2) + 2));
#line 36147
  *alpha = (unsigned char )*(palette + ((i << 2) + 3));
#line 36148
  return;
  default: 
#line 36150
  gl_problem((GLcontext const   *)((void *)0), "Bad palette format in palette_sample");
  }
#line 36152
  return;
}
}
#line 36154 "D:/a/test/177.c"
static void get_1d_texel(struct gl_texture_object  const  *tObj , struct gl_texture_image  const  *img ,
                         GLint i , GLubyte *red , GLubyte *green , GLubyte *blue___0 ,
                         GLubyte *alpha ) 
{ GLubyte *texel ;
  GLubyte index___0 ;

  {
#line 36164
  switch ((int )img->Format) {
  case 6400: 
#line 36167
  index___0 = *(img->Data + i);
#line 36168
  palette_sample(tObj, index___0, red, green, blue___0, alpha);
#line 36169
  return;
#line 36171
  return;
  case 6406: 
#line 36173
  *alpha = *(img->Data + i);
#line 36174
  return;
  case 6409: 
  case 32841: 
#line 36177
  *red = *(img->Data + i);
#line 36178
  return;
  case 6410: 
#line 36180
  texel = (GLubyte *)(img->Data + i * 2);
#line 36181
  *red = *(texel + 0);
#line 36182
  *alpha = *(texel + 1);
#line 36183
  return;
  case 6407: 
#line 36185
  texel = (GLubyte *)(img->Data + i * 3);
#line 36186
  *red = *(texel + 0);
#line 36187
  *green = *(texel + 1);
#line 36188
  *blue___0 = *(texel + 2);
#line 36189
  return;
  case 6408: 
#line 36191
  texel = (GLubyte *)(img->Data + i * 4);
#line 36192
  *red = *(texel + 0);
#line 36193
  *green = *(texel + 1);
#line 36194
  *blue___0 = *(texel + 2);
#line 36195
  *alpha = *(texel + 3);
#line 36196
  return;
  default: 
#line 36198
  gl_problem((GLcontext const   *)((void *)0), "Bad format in get_1d_texel");
#line 36199
  return;
  }
}
}
#line 36202 "D:/a/test/177.c"
static void sample_1d_nearest(struct gl_texture_object  const  *tObj , struct gl_texture_image  const  *img ,
                              float s , GLubyte *red , GLubyte *green , GLubyte *blue___0 ,
                              GLubyte *alpha ) 
{ GLint width ;
  GLint i ;
  GLubyte *texel ;
  GLubyte index___0 ;

  {
#line 36208
  width = (GLint )img->Width2;
#line 36211
  if (tObj->WrapS == 10497) {
#line 36212
    i = (int )(s * (float )width);
#line 36213
    if (s < 0.0F) {
#line 36213
      i --;
    }
#line 36214
    i &= width - 1;
  } else {
#line 36217
    if (s < 0.0F) {
#line 36217
      i = 0;
    } else {
#line 36218
      if (s > 1.0F) {
#line 36218
        i = width - 1;
      } else {
#line 36219
        i = (int )(s * (float )width);
      }
    }
  }
#line 36221
  i = (int )((GLuint const   )i + img->Border);
#line 36222
  switch ((int )img->Format) {
  case 6400: 
#line 36225
  index___0 = *(img->Data + i);
#line 36226
  palette_sample(tObj, index___0, red, green, blue___0, alpha);
#line 36227
  return;
  case 6406: 
#line 36230
  *alpha = *(img->Data + i);
#line 36231
  return;
  case 6409: 
  case 32841: 
#line 36234
  *red = *(img->Data + i);
#line 36235
  return;
  case 6410: 
#line 36237
  texel = (GLubyte *)(img->Data + i * 2);
#line 36238
  *red = *(texel + 0);
#line 36239
  *alpha = *(texel + 1);
#line 36240
  return;
  case 6407: 
#line 36242
  texel = (GLubyte *)(img->Data + i * 3);
#line 36243
  *red = *(texel + 0);
#line 36244
  *green = *(texel + 1);
#line 36245
  *blue___0 = *(texel + 2);
#line 36246
  return;
  case 6408: 
#line 36248
  texel = (GLubyte *)(img->Data + i * 4);
#line 36249
  *red = *(texel + 0);
#line 36250
  *green = *(texel + 1);
#line 36251
  *blue___0 = *(texel + 2);
#line 36252
  *alpha = *(texel + 3);
#line 36253
  return;
  default: 
#line 36255
  gl_problem((GLcontext const   *)((void *)0), "Bad format in sample_1d_nearest");
  }
#line 36257
  return;
}
}
#line 36258 "D:/a/test/177.c"
static void sample_1d_linear(struct gl_texture_object  const  *tObj , struct gl_texture_image  const  *img ,
                             float s , GLubyte *red , GLubyte *green , GLubyte *blue___0 ,
                             GLubyte *alpha ) 
{ GLint width ;
  GLint i0 ;
  GLint i1 ;
  float u ;
  GLint i0border ;
  GLint i1border ;
  double tmp___0 ;
  double tmp___1 ;
  float a ;
  double tmp___2 ;
  GLint w0 ;
  GLint w1 ;
  GLubyte red0 ;
  GLubyte green0 ;
  GLubyte blue0 ;
  GLubyte alpha0 ;
  GLubyte red1 ;
  GLubyte green1 ;
  GLubyte blue1 ;
  GLubyte alpha1 ;

  {
#line 36264
  width = (GLint )img->Width2;
#line 36268
  u = s * (float )width;
#line 36269
  if (tObj->WrapS == 10497) {
#line 36270
    tmp___0 = floor((double )(u - 0.5F));
#line 36270
    i0 = (int )tmp___0 % width;
#line 36271
    i1 = (i0 + 1) & (width - 1);
#line 36272
    i1border = 0;
#line 36272
    i0border = i1border;
  } else {
#line 36275
    tmp___1 = floor((double )(u - 0.5F));
#line 36275
    i0 = (int )tmp___1;
#line 36276
    i1 = i0 + 1;
#line 36277
    i0border = (i0 < 0) | (i0 >= width);
#line 36278
    i1border = (i1 < 0) | (i1 >= width);
  }
#line 36280
  if (img->Border) {
#line 36281
    i0 = (int )((GLuint const   )i0 + img->Border);
#line 36282
    i1 = (int )((GLuint const   )i1 + img->Border);
#line 36283
    i1border = 0;
#line 36283
    i0border = i1border;
  } else {
#line 36286
    i0 &= width - 1;
  }
#line 36289
  tmp___2 = floor((double )(u - 0.5F));
#line 36289
  a = (float )((double )(u - 0.5F) - tmp___2);
#line 36290
  w0 = (int )((1.0F - a) * 256.0F);
#line 36291
  w1 = (int )(a * 256.0F);
#line 36294
  if (i0border) {
#line 36295
    red0 = (unsigned char )tObj->BorderColor[0];
#line 36296
    green0 = (unsigned char )tObj->BorderColor[1];
#line 36297
    blue0 = (unsigned char )tObj->BorderColor[2];
#line 36298
    alpha0 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 36301
    get_1d_texel(tObj, img, i0, & red0, & green0, & blue0, & alpha0);
  }
#line 36303
  if (i1border) {
#line 36304
    red1 = (unsigned char )tObj->BorderColor[0];
#line 36305
    green1 = (unsigned char )tObj->BorderColor[1];
#line 36306
    blue1 = (unsigned char )tObj->BorderColor[2];
#line 36307
    alpha1 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 36310
    get_1d_texel(tObj, img, i1, & red1, & green1, & blue1, & alpha1);
  }
#line 36312
  *red = (unsigned char )((w0 * (GLint )red0 + w1 * (GLint )red1) >> 8);
#line 36313
  *green = (unsigned char )((w0 * (GLint )green0 + w1 * (GLint )green1) >> 8);
#line 36314
  *blue___0 = (unsigned char )((w0 * (GLint )blue0 + w1 * (GLint )blue1) >> 8);
#line 36315
  *alpha = (unsigned char )((w0 * (GLint )alpha0 + w1 * (GLint )alpha1) >> 8);
#line 36317
  return;
}
}
#line 36318 "D:/a/test/177.c"
static void sample_1d_nearest_mipmap_nearest(struct gl_texture_object  const  *tObj ,
                                             float s , float lambda , GLubyte *red ,
                                             GLubyte *green , GLubyte *blue___0 ,
                                             GLubyte *alpha ) 
{ GLint level ;
  GLint widthlog2 ;

  {
#line 36325
  if (lambda <= 0.5F) {
#line 36326
    level = 0;
  } else {
#line 36329
    widthlog2 = (GLint )(tObj->Image[0])->WidthLog2;
#line 36330
    level = (int )(lambda + 0.499999F);
#line 36331
    if (level > widthlog2) {
#line 36332
      level = widthlog2;
    }
  }
#line 36335
  sample_1d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[level], s,
                    red, green, blue___0, alpha);
#line 36337
  return;
}
}
#line 36338 "D:/a/test/177.c"
static void sample_1d_linear_mipmap_nearest(struct gl_texture_object  const  *tObj ,
                                            float s , float lambda , GLubyte *red ,
                                            GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLint level ;
  GLint widthlog2 ;

  {
#line 36345
  if (lambda <= 0.5F) {
#line 36346
    level = 0;
  } else {
#line 36349
    widthlog2 = (GLint )(tObj->Image[0])->WidthLog2;
#line 36350
    level = (int )(lambda + 0.499999F);
#line 36351
    if (level > widthlog2) {
#line 36352
      level = widthlog2;
    }
  }
#line 36355
  sample_1d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[level], s,
                   red, green, blue___0, alpha);
#line 36357
  return;
}
}
#line 36358 "D:/a/test/177.c"
static void sample_1d_nearest_mipmap_linear(struct gl_texture_object  const  *tObj ,
                                            float s , float lambda , GLubyte *red ,
                                            GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLint max ;
  GLubyte red0 ;
  GLubyte green0 ;
  GLubyte blue0 ;
  GLubyte alpha0 ;
  GLubyte red1 ;
  GLubyte green1 ;
  GLubyte blue1 ;
  GLubyte alpha1 ;
  float f ;
  double tmp___0 ;
  GLint level ;
  GLint tmp___1 ;

  {
#line 36364
  max = (GLint )(tObj->Image[0])->MaxLog2;
#line 36365
  if (lambda >= (float )max) {
#line 36366
    sample_1d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[max], s,
                      red, green, blue___0, alpha);
  } else {
#line 36372
    tmp___0 = floor((double )lambda);
#line 36372
    f = (float )((double )lambda - tmp___0);
#line 36373
    level = (int )(lambda + 1.0F);
#line 36374
    if (level < 1) {
#line 36374
      level = 1;
    } else {
#line 36374
      if (level > max) {
#line 36374
        tmp___1 = max;
      } else {
#line 36374
        tmp___1 = level;
      }
#line 36374
      level = tmp___1;
    }
#line 36375
    sample_1d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[level - 1],
                      s, & red0, & green0, & blue0, & alpha0);
#line 36377
    sample_1d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[level],
                      s, & red1, & green1, & blue1, & alpha1);
#line 36379
    *red = (unsigned char )((1.0F - f) * (float )red0 + f * (float )red1);
#line 36380
    *green = (unsigned char )((1.0F - f) * (float )green0 + f * (float )green1);
#line 36381
    *blue___0 = (unsigned char )((1.0F - f) * (float )blue0 + f * (float )blue1);
#line 36382
    *alpha = (unsigned char )((1.0F - f) * (float )alpha0 + f * (float )alpha1);
  }
#line 36384
  return;
}
}
#line 36385 "D:/a/test/177.c"
static void sample_1d_linear_mipmap_linear(struct gl_texture_object  const  *tObj ,
                                           float s , float lambda , GLubyte *red ,
                                           GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLint max ;
  GLubyte red0 ;
  GLubyte green0 ;
  GLubyte blue0 ;
  GLubyte alpha0 ;
  GLubyte red1 ;
  GLubyte green1 ;
  GLubyte blue1 ;
  GLubyte alpha1 ;
  float f ;
  double tmp___0 ;
  GLint level ;
  GLint tmp___1 ;

  {
#line 36391
  max = (GLint )(tObj->Image[0])->MaxLog2;
#line 36392
  if (lambda >= (float )max) {
#line 36393
    sample_1d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[max], s,
                     red, green, blue___0, alpha);
  } else {
#line 36399
    tmp___0 = floor((double )lambda);
#line 36399
    f = (float )((double )lambda - tmp___0);
#line 36400
    level = (int )(lambda + 1.0F);
#line 36401
    if (level < 1) {
#line 36401
      level = 1;
    } else {
#line 36401
      if (level > max) {
#line 36401
        tmp___1 = max;
      } else {
#line 36401
        tmp___1 = level;
      }
#line 36401
      level = tmp___1;
    }
#line 36402
    sample_1d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[level - 1],
                     s, & red0, & green0, & blue0, & alpha0);
#line 36404
    sample_1d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[level],
                     s, & red1, & green1, & blue1, & alpha1);
#line 36406
    *red = (unsigned char )((1.0F - f) * (float )red0 + f * (float )red1);
#line 36407
    *green = (unsigned char )((1.0F - f) * (float )green0 + f * (float )green1);
#line 36408
    *blue___0 = (unsigned char )((1.0F - f) * (float )blue0 + f * (float )blue1);
#line 36409
    *alpha = (unsigned char )((1.0F - f) * (float )alpha0 + f * (float )alpha1);
  }
#line 36411
  return;
}
}
#line 36412 "D:/a/test/177.c"
static void sample_nearest_1d(struct gl_texture_object  const  *tObj , GLuint n ,
                              float const   *s , float const   *t , float const   *u ,
                              float const   *lambda , GLubyte *red , GLubyte *green ,
                              GLubyte *blue___0 , GLubyte *alpha ) 
{ GLuint i ;

  {
#line 36419
  i = 0U;
#line 36419
  while (i < n) {
#line 36420
    sample_1d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                      red + i, green + i, blue___0 + i, alpha + i);
#line 36419
    i ++;
  }
#line 36423
  return;
}
}
#line 36424 "D:/a/test/177.c"
static void sample_linear_1d(struct gl_texture_object  const  *tObj , GLuint n , float const   *s ,
                             float const   *t , float const   *u , float const   *lambda ,
                             GLubyte *red , GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLuint i ;

  {
#line 36431
  i = 0U;
#line 36431
  while (i < n) {
#line 36432
    sample_1d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                     red + i, green + i, blue___0 + i, alpha + i);
#line 36431
    i ++;
  }
#line 36435
  return;
}
}
#line 36436 "D:/a/test/177.c"
static void sample_lambda_1d(struct gl_texture_object  const  *tObj , GLuint n , float const   *s ,
                             float const   *t , float const   *u , float const   *lambda ,
                             GLubyte *red , GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLuint i ;

  {
#line 36443
  i = 0U;
#line 36443
  while (i < n) {
#line 36444
    if (*(lambda + i) > tObj->MinMagThresh) {
#line 36445
      switch ((int )tObj->MinFilter) {
      case 9728: 
#line 36447
      sample_1d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                        red + i, green + i, blue___0 + i, alpha + i);
#line 36449
      break;
      case 9729: 
#line 36451
      sample_1d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                       red + i, green + i, blue___0 + i, alpha + i);
#line 36453
      break;
      case 9984: 
#line 36455
      sample_1d_nearest_mipmap_nearest(tObj, (float )*(lambda + i), (float )*(s + i),
                                       red + i, green + i, blue___0 + i, alpha + i);
#line 36457
      break;
      case 9985: 
#line 36459
      sample_1d_linear_mipmap_nearest(tObj, (float )*(s + i), (float )*(lambda + i),
                                      red + i, green + i, blue___0 + i, alpha + i);
#line 36461
      break;
      case 9986: 
#line 36463
      sample_1d_nearest_mipmap_linear(tObj, (float )*(s + i), (float )*(lambda + i),
                                      red + i, green + i, blue___0 + i, alpha + i);
#line 36465
      break;
      case 9987: 
#line 36467
      sample_1d_linear_mipmap_linear(tObj, (float )*(s + i), (float )*(lambda + i),
                                     red + i, green + i, blue___0 + i, alpha + i);
#line 36469
      break;
      default: 
#line 36471
      gl_problem((GLcontext const   *)((void *)0), "Bad min filter in sample_1d_texture");
#line 36472
      return;
      }
    } else {
#line 36476
      switch ((int )tObj->MagFilter) {
      case 9728: 
#line 36478
      sample_1d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                        red + i, green + i, blue___0 + i, alpha + i);
#line 36480
      break;
      case 9729: 
#line 36482
      sample_1d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                       red + i, green + i, blue___0 + i, alpha + i);
#line 36484
      break;
      default: 
#line 36486
      gl_problem((GLcontext const   *)((void *)0), "Bad mag filter in sample_1d_texture");
#line 36487
      return;
      }
    }
#line 36443
    i ++;
  }
#line 36491
  return;
}
}
#line 36492 "D:/a/test/177.c"
static void get_2d_texel(struct gl_texture_object  const  *tObj , struct gl_texture_image  const  *img ,
                         GLint i , GLint j , GLubyte *red , GLubyte *green , GLubyte *blue___0 ,
                         GLubyte *alpha ) 
{ GLint width ;
  GLubyte *texel ;
  GLubyte index___0 ;

  {
#line 36497
  width = (GLint )img->Width;
#line 36504
  switch ((int )img->Format) {
  case 6400: 
#line 36507
  index___0 = *(img->Data + (width * j + i));
#line 36508
  palette_sample(tObj, index___0, red, green, blue___0, alpha);
#line 36509
  return;
  case 6406: 
#line 36512
  *alpha = *(img->Data + (width * j + i));
#line 36513
  return;
  case 6409: 
  case 32841: 
#line 36516
  *red = *(img->Data + (width * j + i));
#line 36517
  return;
  case 6410: 
#line 36519
  texel = (GLubyte *)(img->Data + (width * j + i) * 2);
#line 36520
  *red = *(texel + 0);
#line 36521
  *alpha = *(texel + 1);
#line 36522
  return;
  case 6407: 
#line 36524
  texel = (GLubyte *)(img->Data + (width * j + i) * 3);
#line 36525
  *red = *(texel + 0);
#line 36526
  *green = *(texel + 1);
#line 36527
  *blue___0 = *(texel + 2);
#line 36528
  return;
  case 6408: 
#line 36530
  texel = (GLubyte *)(img->Data + (width * j + i) * 4);
#line 36531
  *red = *(texel + 0);
#line 36532
  *green = *(texel + 1);
#line 36533
  *blue___0 = *(texel + 2);
#line 36534
  *alpha = *(texel + 3);
#line 36535
  return;
  default: 
#line 36537
  gl_problem((GLcontext const   *)((void *)0), "Bad format in get_2d_texel");
  }
#line 36539
  return;
}
}
#line 36540 "D:/a/test/177.c"
static void sample_2d_nearest(struct gl_texture_object  const  *tObj , struct gl_texture_image  const  *img ,
                              float s , float t , GLubyte *red , GLubyte *green ,
                              GLubyte *blue___0 , GLubyte *alpha ) 
{ GLint imgWidth ;
  GLint width ;
  GLint height ;
  GLint i ;
  GLint j ;
  GLubyte *texel ;
  GLubyte index___0 ;

  {
#line 36546
  imgWidth = (GLint )img->Width;
#line 36547
  width = (GLint )img->Width2;
#line 36548
  height = (GLint )img->Height2;
#line 36551
  if (tObj->WrapS == 10497) {
#line 36552
    i = (int )(s * (float )width);
#line 36553
    if (s < 0.0F) {
#line 36553
      i --;
    }
#line 36554
    i &= width - 1;
  } else {
#line 36557
    if (s <= 0.0F) {
#line 36557
      i = 0;
    } else {
#line 36558
      if (s > 1.0F) {
#line 36558
        i = width - 1;
      } else {
#line 36559
        i = (int )(s * (float )width);
      }
    }
  }
#line 36561
  if (tObj->WrapT == 10497) {
#line 36562
    j = (int )(t * (float )height);
#line 36563
    if (t < 0.0F) {
#line 36563
      j --;
    }
#line 36564
    j &= height - 1;
  } else {
#line 36567
    if (t <= 0.0F) {
#line 36567
      j = 0;
    } else {
#line 36568
      if (t > 1.0F) {
#line 36568
        j = height - 1;
      } else {
#line 36569
        j = (int )(t * (float )height);
      }
    }
  }
#line 36571
  i = (int )((GLuint const   )i + img->Border);
#line 36572
  j = (int )((GLuint const   )j + img->Border);
#line 36573
  switch ((int )img->Format) {
  case 6400: 
#line 36576
  index___0 = *(img->Data + (j * imgWidth + i));
#line 36577
  palette_sample(tObj, index___0, red, green, blue___0, alpha);
#line 36578
  return;
  case 6406: 
#line 36581
  *alpha = *(img->Data + (j * imgWidth + i));
#line 36582
  return;
  case 6409: 
  case 32841: 
#line 36585
  *red = *(img->Data + (j * imgWidth + i));
#line 36586
  return;
  case 6410: 
#line 36588
  texel = (GLubyte *)(img->Data + ((j * imgWidth + i) << 1));
#line 36589
  *red = *(texel + 0);
#line 36590
  *alpha = *(texel + 1);
#line 36591
  return;
  case 6407: 
#line 36593
  texel = (GLubyte *)(img->Data + (j * imgWidth + i) * 3);
#line 36594
  *red = *(texel + 0);
#line 36595
  *green = *(texel + 1);
#line 36596
  *blue___0 = *(texel + 2);
#line 36597
  return;
  case 6408: 
#line 36599
  texel = (GLubyte *)(img->Data + ((j * imgWidth + i) << 2));
#line 36600
  *red = *(texel + 0);
#line 36601
  *green = *(texel + 1);
#line 36602
  *blue___0 = *(texel + 2);
#line 36603
  *alpha = *(texel + 3);
#line 36604
  return;
  default: 
#line 36606
  gl_problem((GLcontext const   *)((void *)0), "Bad format in sample_2d_nearest");
  }
#line 36608
  return;
}
}
#line 36609 "D:/a/test/177.c"
static void sample_2d_linear(struct gl_texture_object  const  *tObj , struct gl_texture_image  const  *img ,
                             float s , float t , GLubyte *red , GLubyte *green , GLubyte *blue___0 ,
                             GLubyte *alpha ) 
{ GLint width ;
  GLint height ;
  GLint i0 ;
  GLint j0___0 ;
  GLint i1 ;
  GLint j1___0 ;
  GLint i0border ;
  GLint j0border ;
  GLint i1border ;
  GLint j1border ;
  float u ;
  float v ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  float a ;
  double tmp___4 ;
  float b ;
  double tmp___5 ;
  GLint w00 ;
  GLint w10 ;
  GLint w01 ;
  GLint w11 ;
  GLubyte red00 ;
  GLubyte green00 ;
  GLubyte blue00 ;
  GLubyte alpha00 ;
  GLubyte red10 ;
  GLubyte green10 ;
  GLubyte blue10 ;
  GLubyte alpha10 ;
  GLubyte red01 ;
  GLubyte green01 ;
  GLubyte blue01 ;
  GLubyte alpha01 ;
  GLubyte red11 ;
  GLubyte green11 ;
  GLubyte blue11 ;
  GLubyte alpha11 ;

  {
#line 36615
  width = (GLint )img->Width2;
#line 36616
  height = (GLint )img->Height2;
#line 36620
  u = s * (float )width;
#line 36621
  if (tObj->WrapS == 10497) {
#line 36622
    tmp___0 = floor((double )(u - 0.5F));
#line 36622
    i0 = (int )tmp___0 % width;
#line 36623
    i1 = (i0 + 1) & (width - 1);
#line 36624
    i1border = 0;
#line 36624
    i0border = i1border;
  } else {
#line 36627
    tmp___1 = floor((double )(u - 0.5F));
#line 36627
    i0 = (int )tmp___1;
#line 36628
    i1 = i0 + 1;
#line 36629
    i0border = (i0 < 0) | (i0 >= width);
#line 36630
    i1border = (i1 < 0) | (i1 >= width);
  }
#line 36632
  v = t * (float )height;
#line 36633
  if (tObj->WrapT == 10497) {
#line 36634
    tmp___2 = floor((double )(v - 0.5F));
#line 36634
    j0___0 = (int )tmp___2 % height;
#line 36635
    j1___0 = (j0___0 + 1) & (height - 1);
#line 36636
    j1border = 0;
#line 36636
    j0border = j1border;
  } else {
#line 36639
    tmp___3 = floor((double )(v - 0.5F));
#line 36639
    j0___0 = (int )tmp___3;
#line 36640
    j1___0 = j0___0 + 1;
#line 36641
    j0border = (j0___0 < 0) | (j0___0 >= height);
#line 36642
    j1border = (j1___0 < 0) | (j1___0 >= height);
  }
#line 36644
  if (img->Border) {
#line 36645
    i0 = (int )((GLuint const   )i0 + img->Border);
#line 36646
    i1 = (int )((GLuint const   )i1 + img->Border);
#line 36647
    j0___0 = (int )((GLuint const   )j0___0 + img->Border);
#line 36648
    j1___0 = (int )((GLuint const   )j1___0 + img->Border);
#line 36649
    i1border = 0;
#line 36649
    i0border = i1border;
#line 36650
    j1border = 0;
#line 36650
    j0border = j1border;
  } else {
#line 36653
    i0 &= width - 1;
#line 36654
    j0___0 &= height - 1;
  }
#line 36657
  tmp___4 = floor((double )(u - 0.5F));
#line 36657
  a = (float )((double )(u - 0.5F) - tmp___4);
#line 36658
  tmp___5 = floor((double )(v - 0.5F));
#line 36658
  b = (float )((double )(v - 0.5F) - tmp___5);
#line 36659
  w00 = (int )(((1.0F - a) * (1.0F - b)) * 256.0F);
#line 36660
  w10 = (int )((a * (1.0F - b)) * 256.0F);
#line 36661
  w01 = (int )(((1.0F - a) * b) * 256.0F);
#line 36662
  w11 = (int )((a * b) * 256.0F);
#line 36667
  if (i0border | j0border) {
#line 36668
    red00 = (unsigned char )tObj->BorderColor[0];
#line 36669
    green00 = (unsigned char )tObj->BorderColor[1];
#line 36670
    blue00 = (unsigned char )tObj->BorderColor[2];
#line 36671
    alpha00 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 36674
    get_2d_texel(tObj, img, i0, j0___0, & red00, & green00, & blue00, & alpha00);
  }
#line 36676
  if (i1border | j0border) {
#line 36677
    red10 = (unsigned char )tObj->BorderColor[0];
#line 36678
    green10 = (unsigned char )tObj->BorderColor[1];
#line 36679
    blue10 = (unsigned char )tObj->BorderColor[2];
#line 36680
    alpha10 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 36683
    get_2d_texel(tObj, img, i1, j0___0, & red10, & green10, & blue10, & alpha10);
  }
#line 36685
  if (i0border | j1border) {
#line 36686
    red01 = (unsigned char )tObj->BorderColor[0];
#line 36687
    green01 = (unsigned char )tObj->BorderColor[1];
#line 36688
    blue01 = (unsigned char )tObj->BorderColor[2];
#line 36689
    alpha01 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 36692
    get_2d_texel(tObj, img, i0, j1___0, & red01, & green01, & blue01, & alpha01);
  }
#line 36694
  if (i1border | j1border) {
#line 36695
    red11 = (unsigned char )tObj->BorderColor[0];
#line 36696
    green11 = (unsigned char )tObj->BorderColor[1];
#line 36697
    blue11 = (unsigned char )tObj->BorderColor[2];
#line 36698
    alpha11 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 36701
    get_2d_texel(tObj, img, i1, j1___0, & red11, & green11, & blue11, & alpha11);
  }
#line 36703
  *red = (unsigned char )((((w00 * (GLint )red00 + w10 * (GLint )red10) + w01 * (GLint )red01) + w11 * (GLint )red11) >> 8);
#line 36704
  *green = (unsigned char )((((w00 * (GLint )green00 + w10 * (GLint )green10) + w01 * (GLint )green01) + w11 * (GLint )green11) >> 8);
#line 36705
  *blue___0 = (unsigned char )((((w00 * (GLint )blue00 + w10 * (GLint )blue10) + w01 * (GLint )blue01) + w11 * (GLint )blue11) >> 8);
#line 36706
  *alpha = (unsigned char )((((w00 * (GLint )alpha00 + w10 * (GLint )alpha10) + w01 * (GLint )alpha01) + w11 * (GLint )alpha11) >> 8);
#line 36708
  return;
}
}
#line 36709 "D:/a/test/177.c"
static void sample_2d_nearest_mipmap_nearest(struct gl_texture_object  const  *tObj ,
                                             float s , float t , float lambda , GLubyte *red ,
                                             GLubyte *green , GLubyte *blue___0 ,
                                             GLubyte *alpha ) 
{ GLint level ;
  GLint max ;

  {
#line 36716
  if (lambda <= 0.5F) {
#line 36717
    level = 0;
  } else {
#line 36720
    max = (GLint )(tObj->Image[0])->MaxLog2;
#line 36721
    level = (int )(lambda + 0.499999F);
#line 36722
    if (level > max) {
#line 36723
      level = max;
    }
  }
#line 36726
  sample_2d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[level], s,
                    t, red, green, blue___0, alpha);
#line 36728
  return;
}
}
#line 36729 "D:/a/test/177.c"
static void sample_2d_linear_mipmap_nearest(struct gl_texture_object  const  *tObj ,
                                            float s , float t , float lambda , GLubyte *red ,
                                            GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLint level ;
  GLint max ;

  {
#line 36736
  if (lambda <= 0.5F) {
#line 36737
    level = 0;
  } else {
#line 36740
    max = (GLint )(tObj->Image[0])->MaxLog2;
#line 36741
    level = (int )(lambda + 0.499999F);
#line 36742
    if (level > max) {
#line 36743
      level = max;
    }
  }
#line 36746
  sample_2d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[level], s,
                   t, red, green, blue___0, alpha);
#line 36748
  return;
}
}
#line 36749 "D:/a/test/177.c"
static void sample_2d_nearest_mipmap_linear(struct gl_texture_object  const  *tObj ,
                                            float s , float t , float lambda , GLubyte *red ,
                                            GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLint max ;
  GLubyte red0 ;
  GLubyte green0 ;
  GLubyte blue0 ;
  GLubyte alpha0 ;
  GLubyte red1 ;
  GLubyte green1 ;
  GLubyte blue1 ;
  GLubyte alpha1 ;
  float f ;
  double tmp___0 ;
  GLint level ;
  GLint tmp___1 ;

  {
#line 36755
  max = (GLint )(tObj->Image[0])->MaxLog2;
#line 36756
  if (lambda >= (float )max) {
#line 36757
    sample_2d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[max], s,
                      t, red, green, blue___0, alpha);
  } else {
#line 36763
    tmp___0 = floor((double )lambda);
#line 36763
    f = (float )((double )lambda - tmp___0);
#line 36764
    level = (int )(lambda + 1.0F);
#line 36765
    if (level < 1) {
#line 36765
      level = 1;
    } else {
#line 36765
      if (level > max) {
#line 36765
        tmp___1 = max;
      } else {
#line 36765
        tmp___1 = level;
      }
#line 36765
      level = tmp___1;
    }
#line 36766
    sample_2d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[level - 1],
                      s, t, & red0, & green0, & blue0, & alpha0);
#line 36768
    sample_2d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[level],
                      s, t, & red1, & green1, & blue1, & alpha1);
#line 36770
    *red = (unsigned char )((1.0F - f) * (float )red0 + f * (float )red1);
#line 36771
    *green = (unsigned char )((1.0F - f) * (float )green0 + f * (float )green1);
#line 36772
    *blue___0 = (unsigned char )((1.0F - f) * (float )blue0 + f * (float )blue1);
#line 36773
    *alpha = (unsigned char )((1.0F - f) * (float )alpha0 + f * (float )alpha1);
  }
#line 36775
  return;
}
}
#line 36776 "D:/a/test/177.c"
static void sample_2d_linear_mipmap_linear(struct gl_texture_object  const  *tObj ,
                                           float s , float t , float lambda , GLubyte *red ,
                                           GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLint max ;
  GLubyte red0 ;
  GLubyte green0 ;
  GLubyte blue0 ;
  GLubyte alpha0 ;
  GLubyte red1 ;
  GLubyte green1 ;
  GLubyte blue1 ;
  GLubyte alpha1 ;
  float f ;
  double tmp___0 ;
  GLint level ;
  GLint tmp___1 ;

  {
#line 36782
  max = (GLint )(tObj->Image[0])->MaxLog2;
#line 36783
  if (lambda >= (float )max) {
#line 36784
    sample_2d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[max], s,
                     t, red, green, blue___0, alpha);
  } else {
#line 36790
    tmp___0 = floor((double )lambda);
#line 36790
    f = (float )((double )lambda - tmp___0);
#line 36791
    level = (int )(lambda + 1.0F);
#line 36792
    if (level < 1) {
#line 36792
      level = 1;
    } else {
#line 36792
      if (level > max) {
#line 36792
        tmp___1 = max;
      } else {
#line 36792
        tmp___1 = level;
      }
#line 36792
      level = tmp___1;
    }
#line 36793
    sample_2d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[level - 1],
                     s, t, & red0, & green0, & blue0, & alpha0);
#line 36795
    sample_2d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[level],
                     s, t, & red1, & green1, & blue1, & alpha1);
#line 36797
    *red = (unsigned char )((1.0F - f) * (float )red0 + f * (float )red1);
#line 36798
    *green = (unsigned char )((1.0F - f) * (float )green0 + f * (float )green1);
#line 36799
    *blue___0 = (unsigned char )((1.0F - f) * (float )blue0 + f * (float )blue1);
#line 36800
    *alpha = (unsigned char )((1.0F - f) * (float )alpha0 + f * (float )alpha1);
  }
#line 36802
  return;
}
}
#line 36803 "D:/a/test/177.c"
static void sample_nearest_2d(struct gl_texture_object  const  *tObj , GLuint n ,
                              float const   *s , float const   *t , float const   *u ,
                              float const   *lambda , GLubyte *red , GLubyte *green ,
                              GLubyte *blue___0 , GLubyte *alpha ) 
{ GLuint i ;

  {
#line 36810
  i = 0U;
#line 36810
  while (i < n) {
#line 36811
    sample_2d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                      (float )*(t + i), red + i, green + i, blue___0 + i, alpha + i);
#line 36810
    i ++;
  }
#line 36814
  return;
}
}
#line 36815 "D:/a/test/177.c"
static void sample_linear_2d(struct gl_texture_object  const  *tObj , GLuint n , float const   *s ,
                             float const   *t , float const   *u , float const   *lambda ,
                             GLubyte *red , GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLuint i ;

  {
#line 36822
  i = 0U;
#line 36822
  while (i < n) {
#line 36823
    sample_2d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                     (float )*(t + i), red + i, green + i, blue___0 + i, alpha + i);
#line 36822
    i ++;
  }
#line 36826
  return;
}
}
#line 36827 "D:/a/test/177.c"
static void sample_lambda_2d(struct gl_texture_object  const  *tObj , GLuint n , float const   *s ,
                             float const   *t , float const   *u , float const   *lambda ,
                             GLubyte *red , GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLuint i ;

  {
#line 36835
  i = 0U;
#line 36835
  while (i < n) {
#line 36836
    if (*(lambda + i) > tObj->MinMagThresh) {
#line 36837
      switch ((int )tObj->MinFilter) {
      case 9728: 
#line 36839
      sample_2d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                        (float )*(t + i), red + i, green + i, blue___0 + i, alpha + i);
#line 36841
      break;
      case 9729: 
#line 36843
      sample_2d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                       (float )*(t + i), red + i, green + i, blue___0 + i, alpha + i);
#line 36845
      break;
      case 9984: 
#line 36847
      sample_2d_nearest_mipmap_nearest(tObj, (float )*(s + i), (float )*(t + i), (float )*(lambda + i),
                                       red + i, green + i, blue___0 + i, alpha + i);
#line 36849
      break;
      case 9985: 
#line 36851
      sample_2d_linear_mipmap_nearest(tObj, (float )*(s + i), (float )*(t + i), (float )*(lambda + i),
                                      red + i, green + i, blue___0 + i, alpha + i);
#line 36853
      break;
      case 9986: 
#line 36855
      sample_2d_nearest_mipmap_linear(tObj, (float )*(s + i), (float )*(t + i), (float )*(lambda + i),
                                      red + i, green + i, blue___0 + i, alpha + i);
#line 36857
      break;
      case 9987: 
#line 36859
      sample_2d_linear_mipmap_linear(tObj, (float )*(s + i), (float )*(t + i), (float )*(lambda + i),
                                     red + i, green + i, blue___0 + i, alpha + i);
#line 36861
      break;
      default: 
#line 36863
      gl_problem((GLcontext const   *)((void *)0), "Bad min filter in sample_2d_texture");
#line 36864
      return;
      }
    } else {
#line 36868
      switch ((int )tObj->MagFilter) {
      case 9728: 
#line 36870
      sample_2d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                        (float )*(t + i), red + i, green + i, blue___0 + i, alpha + i);
#line 36872
      break;
      case 9729: 
#line 36874
      sample_2d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                       (float )*(t + i), red + i, green + i, blue___0 + i, alpha + i);
#line 36876
      break;
      default: 
#line 36878
      gl_problem((GLcontext const   *)((void *)0), "Bad mag filter in sample_2d_texture");
      }
    }
#line 36835
    i ++;
  }
#line 36882
  return;
}
}
#line 36883 "D:/a/test/177.c"
static void opt_sample_rgb_2d(struct gl_texture_object  const  *tObj , GLuint n ,
                              float const   *s , float const   *t , float const   *u ,
                              float const   *lamda , GLubyte *red , GLubyte *green ,
                              GLubyte *blue___0 , GLubyte *alpha ) 
{ struct gl_texture_image  const  *img ;
  float width ;
  float height ;
  GLint colMask ;
  GLint rowMask ;
  GLint shift ;
  GLuint k ;
  GLint i ;
  GLint j ;
  GLint pos ;
  GLubyte *texel ;

  {
#line 36889
  img = (struct gl_texture_image  const  *)tObj->Image[0];
#line 36890
  width = (float )img->Width;
#line 36890
  height = (float )img->Height;
#line 36891
  colMask = (GLint )(img->Width - 1U);
#line 36891
  rowMask = (GLint )(img->Height - 1U);
#line 36892
  shift = (GLint )img->WidthLog2;
#line 36898
  k = 0U;
#line 36898
  while (k < n) {
#line 36899
    i = (int )(*(s + k) * (float const   )width) & colMask;
#line 36900
    j = (int )(*(t + k) * (float const   )height) & rowMask;
#line 36901
    pos = (j << shift) | i;
#line 36902
    texel = (GLubyte *)(((img->Data + pos) + pos) + pos);
#line 36903
    *(red + k) = *(texel + 0);
#line 36904
    *(green + k) = *(texel + 1);
#line 36905
    *(blue___0 + k) = *(texel + 2);
#line 36898
    k ++;
  }
#line 36907
  return;
}
}
#line 36908 "D:/a/test/177.c"
static void opt_sample_rgba_2d(struct gl_texture_object  const  *tObj , GLuint n ,
                               float const   *s , float const   *t , float const   *u ,
                               float const   *lamda , GLubyte *red , GLubyte *green ,
                               GLubyte *blue___0 , GLubyte *alpha ) 
{ struct gl_texture_image  const  *img ;
  float width ;
  float height ;
  GLint colMask ;
  GLint rowMask ;
  GLint shift ;
  GLuint k ;
  GLint i ;
  GLint j ;
  GLint pos ;
  GLubyte *texel ;

  {
#line 36914
  img = (struct gl_texture_image  const  *)tObj->Image[0];
#line 36915
  width = (float )img->Width;
#line 36915
  height = (float )img->Height;
#line 36916
  colMask = (GLint )(img->Width - 1U);
#line 36916
  rowMask = (GLint )(img->Height - 1U);
#line 36917
  shift = (GLint )img->WidthLog2;
#line 36923
  k = 0U;
#line 36923
  while (k < n) {
#line 36924
    i = (int )(*(s + k) * (float const   )width) & colMask;
#line 36925
    j = (int )(*(t + k) * (float const   )height) & rowMask;
#line 36926
    pos = (j << shift) | i;
#line 36927
    texel = (GLubyte *)(img->Data + (pos << 2));
#line 36928
    *(red + k) = *(texel + 0);
#line 36929
    *(green + k) = *(texel + 1);
#line 36930
    *(blue___0 + k) = *(texel + 2);
#line 36931
    *(alpha + k) = *(texel + 3);
#line 36923
    k ++;
  }
#line 36933
  return;
}
}
#line 36934 "D:/a/test/177.c"
static void get_3d_texel(struct gl_texture_object  const  *tObj , struct gl_texture_image  const  *img ,
                         GLint i , GLint j , GLint k , GLubyte *red , GLubyte *green ,
                         GLubyte *blue___0 , GLubyte *alpha ) 
{ GLint width ;
  GLint height ;
  GLint depth ;
  GLint rectarea ;
  GLubyte *texel ;
  GLubyte index___0 ;

  {
#line 36940
  width = (GLint )img->Width;
#line 36941
  height = (GLint )img->Height;
#line 36942
  depth = (GLint )img->Depth;
#line 36945
  rectarea = width * height;
#line 36951
  switch ((int )img->Format) {
  case 6400: 
#line 36954
  index___0 = *(img->Data + ((rectarea * k + width * j) + i));
#line 36955
  palette_sample(tObj, index___0, red, green, blue___0, alpha);
#line 36956
  return;
  case 6406: 
#line 36959
  *alpha = *(img->Data + ((rectarea * k + width * j) + i));
#line 36960
  return;
  case 6409: 
  case 32841: 
#line 36963
  *red = *(img->Data + ((rectarea * k + width * j) + i));
#line 36964
  return;
  case 6410: 
#line 36966
  texel = (GLubyte *)(img->Data + ((rectarea * k + width * j) + i) * 2);
#line 36967
  *red = *(texel + 0);
#line 36968
  *alpha = *(texel + 1);
#line 36969
  return;
  case 6407: 
#line 36971
  texel = (GLubyte *)(img->Data + ((rectarea * k + width * j) + i) * 3);
#line 36972
  *red = *(texel + 0);
#line 36973
  *green = *(texel + 1);
#line 36974
  *blue___0 = *(texel + 2);
#line 36975
  return;
  case 6408: 
#line 36977
  texel = (GLubyte *)(img->Data + ((rectarea * k + width * j) + i) * 4);
#line 36978
  *red = *(texel + 0);
#line 36979
  *green = *(texel + 1);
#line 36980
  *blue___0 = *(texel + 2);
#line 36981
  *alpha = *(texel + 3);
#line 36982
  return;
  default: 
#line 36984
  gl_problem((GLcontext const   *)((void *)0), "Bad format in get_3d_texel");
  }
#line 36986
  return;
}
}
#line 36987 "D:/a/test/177.c"
static void sample_3d_nearest(struct gl_texture_object  const  *tObj , struct gl_texture_image  const  *img ,
                              float s , float t , float r , GLubyte *red , GLubyte *green ,
                              GLubyte *blue___0 , GLubyte *alpha ) 
{ GLint imgWidth ;
  GLint imgHeight ;
  GLint width ;
  GLint height ;
  GLint depth ;
  GLint rectarea ;
  GLint i ;
  GLint j ;
  GLint k ;
  GLubyte *texel ;
  GLubyte index___0 ;

  {
#line 36993
  imgWidth = (GLint )img->Width;
#line 36994
  imgHeight = (GLint )img->Height;
#line 36995
  width = (GLint )img->Width2;
#line 36996
  height = (GLint )img->Height2;
#line 36997
  depth = (GLint )img->Depth2;
#line 37001
  rectarea = imgWidth * imgHeight;
#line 37002
  if (tObj->WrapS == 10497) {
#line 37003
    i = (int )(s * (float )width);
#line 37004
    if (s < 0.0F) {
#line 37004
      i --;
    }
#line 37005
    i &= width - 1;
  } else {
#line 37008
    if (s < 0.0F) {
#line 37008
      i = 0;
    } else {
#line 37009
      if (s > 1.0F) {
#line 37009
        i = width - 1;
      } else {
#line 37010
        i = (int )(s * (float )width);
      }
    }
  }
#line 37012
  if (tObj->WrapT == 10497) {
#line 37013
    j = (int )(t * (float )height);
#line 37014
    if (t < 0.0F) {
#line 37014
      j --;
    }
#line 37015
    j &= height - 1;
  } else {
#line 37018
    if (t < 0.0F) {
#line 37018
      j = 0;
    } else {
#line 37019
      if (t > 1.0F) {
#line 37019
        j = height - 1;
      } else {
#line 37020
        j = (int )(t * (float )height);
      }
    }
  }
#line 37022
  if (tObj->WrapR == 10497) {
#line 37023
    k = (int )(r * (float )depth);
#line 37024
    if (r < 0.0F) {
#line 37024
      k --;
    }
#line 37025
    k &= depth - 1;
  } else {
#line 37028
    if (r < 0.0F) {
#line 37028
      k = 0;
    } else {
#line 37029
      if (r > 1.0F) {
#line 37029
        k = depth - 1;
      } else {
#line 37030
        k = (int )(r * (float )depth);
      }
    }
  }
#line 37032
  switch ((tObj->Image[0])->Format) {
  case 6400: 
#line 37035
  index___0 = *(img->Data + ((rectarea * k + j * imgWidth) + i));
#line 37036
  palette_sample(tObj, index___0, red, green, blue___0, alpha);
#line 37037
  return;
  case 6406: 
#line 37040
  *alpha = *(img->Data + ((rectarea * k + j * imgWidth) + i));
#line 37041
  return;
  case 6409: 
  case 32841: 
#line 37044
  *red = *(img->Data + ((rectarea * k + j * imgWidth) + i));
#line 37045
  return;
  case 6410: 
#line 37047
  texel = (GLubyte *)(img->Data + (((rectarea * k + j * imgWidth) + i) << 1));
#line 37048
  *red = *(texel + 0);
#line 37049
  *alpha = *(texel + 1);
#line 37050
  return;
  case 6407: 
#line 37052
  texel = (GLubyte *)(img->Data + ((rectarea * k + j * imgWidth) + i) * 3);
#line 37053
  *red = *(texel + 0);
#line 37054
  *green = *(texel + 1);
#line 37055
  *blue___0 = *(texel + 2);
#line 37056
  return;
  case 6408: 
#line 37058
  texel = (GLubyte *)(img->Data + (((rectarea * k + j * imgWidth) + i) << 2));
#line 37059
  *red = *(texel + 0);
#line 37060
  *green = *(texel + 1);
#line 37061
  *blue___0 = *(texel + 2);
#line 37062
  *alpha = *(texel + 3);
#line 37063
  return;
  default: 
#line 37065
  gl_problem((GLcontext const   *)((void *)0), "Bad format in sample_3d_nearest");
  }
#line 37067
  return;
}
}
#line 37068 "D:/a/test/177.c"
static void sample_3d_linear(struct gl_texture_object  const  *tObj , struct gl_texture_image  const  *img ,
                             float s , float t , float r , GLubyte *red , GLubyte *green ,
                             GLubyte *blue___0 , GLubyte *alpha ) 
{ GLint width ;
  GLint height ;
  GLint depth ;
  GLint i0 ;
  GLint j0___0 ;
  GLint k0 ;
  GLint i1 ;
  GLint j1___0 ;
  GLint k1 ;
  GLint i0border ;
  GLint j0border ;
  GLint k0border ;
  GLint i1border ;
  GLint j1border ;
  GLint k1border ;
  float u ;
  float v ;
  float w ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  float a ;
  double tmp___6 ;
  float b ;
  double tmp___7 ;
  float c ;
  double tmp___8 ;
  GLint w000 ;
  GLint w010 ;
  GLint w001 ;
  GLint w011 ;
  GLint w100 ;
  GLint w110 ;
  GLint w101 ;
  GLint w111 ;
  GLubyte red000 ;
  GLubyte green000 ;
  GLubyte blue000 ;
  GLubyte alpha000 ;
  GLubyte red010 ;
  GLubyte green010 ;
  GLubyte blue010 ;
  GLubyte alpha010 ;
  GLubyte red001 ;
  GLubyte green001 ;
  GLubyte blue001 ;
  GLubyte alpha001 ;
  GLubyte red011 ;
  GLubyte green011 ;
  GLubyte blue011 ;
  GLubyte alpha011 ;
  GLubyte red100 ;
  GLubyte green100 ;
  GLubyte blue100 ;
  GLubyte alpha100 ;
  GLubyte red110 ;
  GLubyte green110 ;
  GLubyte blue110 ;
  GLubyte alpha110 ;
  GLubyte red101 ;
  GLubyte green101 ;
  GLubyte blue101 ;
  GLubyte alpha101 ;
  GLubyte red111 ;
  GLubyte green111 ;
  GLubyte blue111 ;
  GLubyte alpha111 ;

  {
#line 37074
  width = (GLint )img->Width2;
#line 37075
  height = (GLint )img->Height2;
#line 37076
  depth = (GLint )img->Depth2;
#line 37080
  u = s * (float )width;
#line 37081
  if (tObj->WrapS == 10497) {
#line 37082
    tmp___0 = floor((double )(u - 0.5F));
#line 37082
    i0 = (int )tmp___0 % width;
#line 37083
    i1 = (i0 + 1) & (width - 1);
#line 37084
    i1border = 0;
#line 37084
    i0border = i1border;
  } else {
#line 37087
    tmp___1 = floor((double )(u - 0.5F));
#line 37087
    i0 = (int )tmp___1;
#line 37088
    i1 = i0 + 1;
#line 37089
    i0border = (i0 < 0) | (i0 >= width);
#line 37090
    i1border = (i1 < 0) | (i1 >= width);
  }
#line 37092
  v = t * (float )height;
#line 37093
  if (tObj->WrapT == 10497) {
#line 37094
    tmp___2 = floor((double )(v - 0.5F));
#line 37094
    j0___0 = (int )tmp___2 % height;
#line 37095
    j1___0 = (j0___0 + 1) & (height - 1);
#line 37096
    j1border = 0;
#line 37096
    j0border = j1border;
  } else {
#line 37099
    tmp___3 = floor((double )(v - 0.5F));
#line 37099
    j0___0 = (int )tmp___3;
#line 37100
    j1___0 = j0___0 + 1;
#line 37101
    j0border = (j0___0 < 0) | (j0___0 >= height);
#line 37102
    j1border = (j1___0 < 0) | (j1___0 >= height);
  }
#line 37104
  w = r * (float )depth;
#line 37105
  if (tObj->WrapR == 10497) {
#line 37106
    tmp___4 = floor((double )(w - 0.5F));
#line 37106
    k0 = (int )tmp___4 % depth;
#line 37107
    k1 = (k0 + 1) & (depth - 1);
#line 37108
    k1border = 0;
#line 37108
    k0border = k1border;
  } else {
#line 37111
    tmp___5 = floor((double )(v - 0.5F));
#line 37111
    k0 = (int )tmp___5;
#line 37112
    k1 = k0 + 1;
#line 37113
    k0border = (k0 < 0) | (k0 >= depth);
#line 37114
    k1border = (k1 < 0) | (k1 >= depth);
  }
#line 37116
  if (img->Border) {
#line 37117
    i0 = (int )((GLuint const   )i0 + img->Border);
#line 37118
    i1 = (int )((GLuint const   )i1 + img->Border);
#line 37119
    j0___0 = (int )((GLuint const   )j0___0 + img->Border);
#line 37120
    j1___0 = (int )((GLuint const   )j1___0 + img->Border);
#line 37121
    k0 = (int )((GLuint const   )k0 + img->Border);
#line 37122
    k1 = (int )((GLuint const   )k1 + img->Border);
#line 37123
    i1border = 0;
#line 37123
    i0border = i1border;
#line 37124
    j1border = 0;
#line 37124
    j0border = j1border;
#line 37125
    k1border = 0;
#line 37125
    k0border = k1border;
  } else {
#line 37128
    i0 &= width - 1;
#line 37129
    j0___0 &= height - 1;
#line 37130
    k0 &= depth - 1;
  }
#line 37133
  tmp___6 = floor((double )(u - 0.5F));
#line 37133
  a = (float )((double )(u - 0.5F) - tmp___6);
#line 37134
  tmp___7 = floor((double )(v - 0.5F));
#line 37134
  b = (float )((double )(v - 0.5F) - tmp___7);
#line 37135
  tmp___8 = floor((double )(w - 0.5F));
#line 37135
  c = (float )((double )(w - 0.5F) - tmp___8);
#line 37136
  w000 = (int )((((1.0F - a) * (1.0F - b)) * (1.0F - c)) * 256.0F);
#line 37137
  w010 = (int )(((a * (1.0F - b)) * (1.0F - c)) * 256.0F);
#line 37138
  w001 = (int )((((1.0F - a) * b) * (1.0F - c)) * 256.0F);
#line 37139
  w011 = (int )(((a * b) * (1.0F - c)) * 256.0F);
#line 37140
  w100 = (int )((((1.0F - a) * (1.0F - b)) * c) * 256.0F);
#line 37141
  w110 = (int )(((a * (1.0F - b)) * c) * 256.0F);
#line 37142
  w101 = (int )((((1.0F - a) * b) * c) * 256.0F);
#line 37143
  w111 = (int )(((a * b) * c) * 256.0F);
#line 37152
  if ((k0border | i0border) | j0border) {
#line 37153
    red000 = (unsigned char )tObj->BorderColor[0];
#line 37154
    green000 = (unsigned char )tObj->BorderColor[1];
#line 37155
    blue000 = (unsigned char )tObj->BorderColor[2];
#line 37156
    alpha000 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 37159
    get_3d_texel(tObj, img, i0, j0___0, k0, & red000, & green000, & blue000, & alpha000);
  }
#line 37161
  if ((k0border | i1border) | j0border) {
#line 37162
    red010 = (unsigned char )tObj->BorderColor[0];
#line 37163
    green010 = (unsigned char )tObj->BorderColor[1];
#line 37164
    blue010 = (unsigned char )tObj->BorderColor[2];
#line 37165
    alpha010 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 37168
    get_3d_texel(tObj, img, i1, j0___0, k0, & red010, & green010, & blue010, & alpha010);
  }
#line 37170
  if ((k0border | i0border) | j1border) {
#line 37171
    red001 = (unsigned char )tObj->BorderColor[0];
#line 37172
    green001 = (unsigned char )tObj->BorderColor[1];
#line 37173
    blue001 = (unsigned char )tObj->BorderColor[2];
#line 37174
    alpha001 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 37177
    get_3d_texel(tObj, img, i0, j1___0, k0, & red001, & green001, & blue001, & alpha001);
  }
#line 37179
  if ((k0border | i1border) | j1border) {
#line 37180
    red011 = (unsigned char )tObj->BorderColor[0];
#line 37181
    green011 = (unsigned char )tObj->BorderColor[1];
#line 37182
    blue011 = (unsigned char )tObj->BorderColor[2];
#line 37183
    alpha011 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 37186
    get_3d_texel(tObj, img, i1, j1___0, k0, & red011, & green011, & blue011, & alpha011);
  }
#line 37188
  if ((k1border | i0border) | j0border) {
#line 37189
    red100 = (unsigned char )tObj->BorderColor[0];
#line 37190
    green100 = (unsigned char )tObj->BorderColor[1];
#line 37191
    blue100 = (unsigned char )tObj->BorderColor[2];
#line 37192
    alpha100 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 37195
    get_3d_texel(tObj, img, i0, j0___0, k1, & red100, & green100, & blue100, & alpha100);
  }
#line 37197
  if ((k1border | i1border) | j0border) {
#line 37198
    red110 = (unsigned char )tObj->BorderColor[0];
#line 37199
    green110 = (unsigned char )tObj->BorderColor[1];
#line 37200
    blue110 = (unsigned char )tObj->BorderColor[2];
#line 37201
    alpha110 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 37204
    get_3d_texel(tObj, img, i1, j0___0, k1, & red110, & green110, & blue110, & alpha110);
  }
#line 37206
  if ((k1border | i0border) | j1border) {
#line 37207
    red101 = (unsigned char )tObj->BorderColor[0];
#line 37208
    green101 = (unsigned char )tObj->BorderColor[1];
#line 37209
    blue101 = (unsigned char )tObj->BorderColor[2];
#line 37210
    alpha101 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 37213
    get_3d_texel(tObj, img, i0, j1___0, k1, & red101, & green101, & blue101, & alpha101);
  }
#line 37215
  if ((k1border | i1border) | j1border) {
#line 37216
    red111 = (unsigned char )tObj->BorderColor[0];
#line 37217
    green111 = (unsigned char )tObj->BorderColor[1];
#line 37218
    blue111 = (unsigned char )tObj->BorderColor[2];
#line 37219
    alpha111 = (unsigned char )tObj->BorderColor[3];
  } else {
#line 37222
    get_3d_texel(tObj, img, i1, j1___0, k1, & red111, & green111, & blue111, & alpha111);
  }
#line 37224
  *red = (unsigned char )((((((((w000 * (GLint )red000 + w010 * (GLint )red010) + w001 * (GLint )red001) + w011 * (GLint )red011) + w100 * (GLint )red100) + w110 * (GLint )red110) + w101 * (GLint )red101) + w111 * (GLint )red111) >> 8);
#line 37227
  *green = (unsigned char )((((((((w000 * (GLint )green000 + w010 * (GLint )green010) + w001 * (GLint )green001) + w011 * (GLint )green011) + w100 * (GLint )green100) + w110 * (GLint )green110) + w101 * (GLint )green101) + w111 * (GLint )green111) >> 8);
#line 37230
  *blue___0 = (unsigned char )((((((((w000 * (GLint )blue000 + w010 * (GLint )blue010) + w001 * (GLint )blue001) + w011 * (GLint )blue011) + w100 * (GLint )blue100) + w110 * (GLint )blue110) + w101 * (GLint )blue101) + w111 * (GLint )blue111) >> 8);
#line 37233
  *alpha = (unsigned char )((((((((w000 * (GLint )alpha000 + w010 * (GLint )alpha010) + w001 * (GLint )alpha001) + w011 * (GLint )alpha011) + w100 * (GLint )alpha100) + w110 * (GLint )alpha110) + w101 * (GLint )alpha101) + w111 * (GLint )alpha111) >> 8);
#line 37237
  return;
}
}
#line 37238 "D:/a/test/177.c"
static void sample_3d_nearest_mipmap_nearest(struct gl_texture_object  const  *tObj ,
                                             float s , float t , float r , float lambda ,
                                             GLubyte *red , GLubyte *green , GLubyte *blue___0 ,
                                             GLubyte *alpha ) 
{ GLint level ;
  GLint widthlog2 ;

  {
#line 37246
  if (lambda <= 0.5F) {
#line 37247
    level = 0;
  } else {
#line 37250
    widthlog2 = (GLint )(tObj->Image[0])->WidthLog2;
#line 37251
    level = (int )(lambda + 0.499999F);
#line 37252
    if (level > widthlog2) {
#line 37253
      level = widthlog2;
    }
  }
#line 37256
  sample_3d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[level], s,
                    t, r, red, green, blue___0, alpha);
#line 37258
  return;
}
}
#line 37259 "D:/a/test/177.c"
static void sample_3d_linear_mipmap_nearest(struct gl_texture_object  const  *tObj ,
                                            float s , float t , float r , float lambda ,
                                            GLubyte *red , GLubyte *green , GLubyte *blue___0 ,
                                            GLubyte *alpha ) 
{ GLint level ;
  GLint widthlog2 ;

  {
#line 37267
  if (lambda <= 0.5F) {
#line 37268
    level = 0;
  } else {
#line 37271
    widthlog2 = (GLint )(tObj->Image[0])->WidthLog2;
#line 37272
    level = (int )(lambda + 0.499999F);
#line 37273
    if (level > widthlog2) {
#line 37274
      level = widthlog2;
    }
  }
#line 37277
  sample_3d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[level], s,
                   t, r, red, green, blue___0, alpha);
#line 37279
  return;
}
}
#line 37280 "D:/a/test/177.c"
static void sample_3d_nearest_mipmap_linear(struct gl_texture_object  const  *tObj ,
                                            float s , float t , float r , float lambda ,
                                            GLubyte *red , GLubyte *green , GLubyte *blue___0 ,
                                            GLubyte *alpha ) 
{ GLint max ;
  GLubyte red0 ;
  GLubyte green0 ;
  GLubyte blue0 ;
  GLubyte alpha0 ;
  GLubyte red1 ;
  GLubyte green1 ;
  GLubyte blue1 ;
  GLubyte alpha1 ;
  float f ;
  double tmp___0 ;
  GLint level ;
  GLint tmp___1 ;

  {
#line 37287
  max = (GLint )(tObj->Image[0])->MaxLog2;
#line 37288
  if (lambda >= (float )max) {
#line 37289
    sample_3d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[max], s,
                      t, r, red, green, blue___0, alpha);
  } else {
#line 37295
    tmp___0 = floor((double )lambda);
#line 37295
    f = (float )((double )lambda - tmp___0);
#line 37296
    level = (int )(lambda + 1.0F);
#line 37297
    if (level < 1) {
#line 37297
      level = 1;
    } else {
#line 37297
      if (level > max) {
#line 37297
        tmp___1 = max;
      } else {
#line 37297
        tmp___1 = level;
      }
#line 37297
      level = tmp___1;
    }
#line 37298
    sample_3d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[level - 1],
                      s, t, r, & red0, & green0, & blue0, & alpha0);
#line 37300
    sample_3d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[level],
                      s, t, r, & red1, & green1, & blue1, & alpha1);
#line 37302
    *red = (unsigned char )((1.0F - f) * (float )red1 + f * (float )red0);
#line 37303
    *green = (unsigned char )((1.0F - f) * (float )green1 + f * (float )green0);
#line 37304
    *blue___0 = (unsigned char )((1.0F - f) * (float )blue1 + f * (float )blue0);
#line 37305
    *alpha = (unsigned char )((1.0F - f) * (float )alpha1 + f * (float )alpha0);
  }
#line 37307
  return;
}
}
#line 37308 "D:/a/test/177.c"
static void sample_3d_linear_mipmap_linear(struct gl_texture_object  const  *tObj ,
                                           float s , float t , float r , float lambda ,
                                           GLubyte *red , GLubyte *green , GLubyte *blue___0 ,
                                           GLubyte *alpha ) 
{ GLint max ;
  GLubyte red0 ;
  GLubyte green0 ;
  GLubyte blue0 ;
  GLubyte alpha0 ;
  GLubyte red1 ;
  GLubyte green1 ;
  GLubyte blue1 ;
  GLubyte alpha1 ;
  float f ;
  double tmp___0 ;
  GLint level ;
  GLint tmp___1 ;

  {
#line 37315
  max = (GLint )(tObj->Image[0])->MaxLog2;
#line 37316
  if (lambda >= (float )max) {
#line 37317
    sample_3d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[max], s,
                     t, r, red, green, blue___0, alpha);
  } else {
#line 37323
    tmp___0 = floor((double )lambda);
#line 37323
    f = (float )((double )lambda - tmp___0);
#line 37324
    level = (int )(lambda + 1.0F);
#line 37325
    if (level < 1) {
#line 37325
      level = 1;
    } else {
#line 37325
      if (level > max) {
#line 37325
        tmp___1 = max;
      } else {
#line 37325
        tmp___1 = level;
      }
#line 37325
      level = tmp___1;
    }
#line 37326
    sample_3d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[level - 1],
                     s, t, r, & red0, & green0, & blue0, & alpha0);
#line 37328
    sample_3d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[level],
                     s, t, r, & red1, & green1, & blue1, & alpha1);
#line 37330
    *red = (unsigned char )((1.0F - f) * (float )red1 + f * (float )red0);
#line 37331
    *green = (unsigned char )((1.0F - f) * (float )green1 + f * (float )green0);
#line 37332
    *blue___0 = (unsigned char )((1.0F - f) * (float )blue1 + f * (float )blue0);
#line 37333
    *alpha = (unsigned char )((1.0F - f) * (float )alpha1 + f * (float )alpha0);
  }
#line 37335
  return;
}
}
#line 37336 "D:/a/test/177.c"
static void sample_nearest_3d(struct gl_texture_object  const  *tObj , GLuint n ,
                              float const   *s , float const   *t , float const   *u ,
                              float const   *lambda , GLubyte *red , GLubyte *green ,
                              GLubyte *blue___0 , GLubyte *alpha ) 
{ GLuint i ;

  {
#line 37343
  i = 0U;
#line 37343
  while (i < n) {
#line 37344
    sample_3d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                      (float )*(t + i), (float )*(u + i), red + i, green + i, blue___0 + i,
                      alpha + i);
#line 37343
    i ++;
  }
#line 37347
  return;
}
}
#line 37348 "D:/a/test/177.c"
static void sample_linear_3d(struct gl_texture_object  const  *tObj , GLuint n , float const   *s ,
                             float const   *t , float const   *u , float const   *lambda ,
                             GLubyte *red , GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLuint i ;

  {
#line 37355
  i = 0U;
#line 37355
  while (i < n) {
#line 37356
    sample_3d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                     (float )*(t + i), (float )*(u + i), red + i, green + i, blue___0 + i,
                     alpha + i);
#line 37355
    i ++;
  }
#line 37359
  return;
}
}
#line 37360 "D:/a/test/177.c"
static void sample_lambda_3d(struct gl_texture_object  const  *tObj , GLuint n , float const   *s ,
                             float const   *t , float const   *u , float const   *lambda ,
                             GLubyte *red , GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ) 
{ GLuint i ;

  {
#line 37367
  i = 0U;
#line 37367
  while (i < n) {
#line 37368
    if (*(lambda + i) > tObj->MinMagThresh) {
#line 37369
      switch ((int )tObj->MinFilter) {
      case 9728: 
#line 37371
      sample_3d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                        (float )*(t + i), (float )*(u + i), red + i, green + i, blue___0 + i,
                        alpha + i);
#line 37373
      break;
      case 9729: 
#line 37375
      sample_3d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                       (float )*(t + i), (float )*(u + i), red + i, green + i, blue___0 + i,
                       alpha + i);
#line 37377
      break;
      case 9984: 
#line 37379
      sample_3d_nearest_mipmap_nearest(tObj, (float )*(s + i), (float )*(t + i), (float )*(u + i),
                                       (float )*(lambda + i), red + i, green + i,
                                       blue___0 + i, alpha + i);
#line 37381
      break;
      case 9985: 
#line 37383
      sample_3d_linear_mipmap_nearest(tObj, (float )*(s + i), (float )*(t + i), (float )*(u + i),
                                      (float )*(lambda + i), red + i, green + i, blue___0 + i,
                                      alpha + i);
#line 37385
      break;
      case 9986: 
#line 37387
      sample_3d_nearest_mipmap_linear(tObj, (float )*(s + i), (float )*(t + i), (float )*(u + i),
                                      (float )*(lambda + i), red + i, green + i, blue___0 + i,
                                      alpha + i);
#line 37389
      break;
      case 9987: 
#line 37391
      sample_3d_linear_mipmap_linear(tObj, (float )*(s + i), (float )*(t + i), (float )*(u + i),
                                     (float )*(lambda + i), red + i, green + i, blue___0 + i,
                                     alpha + i);
#line 37393
      break;
      default: 
#line 37395
      gl_problem((GLcontext const   *)((void *)0), "Bad min filterin sample_3d_texture");
      }
    } else {
#line 37399
      switch ((int )tObj->MagFilter) {
      case 9728: 
#line 37401
      sample_3d_nearest(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                        (float )*(t + i), (float )*(u + i), red + i, green + i, blue___0 + i,
                        alpha + i);
#line 37403
      break;
      case 9729: 
#line 37405
      sample_3d_linear(tObj, (struct gl_texture_image  const  *)tObj->Image[0], (float )*(s + i),
                       (float )*(t + i), (float )*(u + i), red + i, green + i, blue___0 + i,
                       alpha + i);
#line 37407
      break;
      default: 
#line 37409
      gl_problem((GLcontext const   *)((void *)0), "Bad mag filterin sample_3d_texture");
      }
    }
#line 37367
    i ++;
  }
#line 37413
  return;
}
}
#line 37414 "D:/a/test/177.c"
void gl_set_texture_sampler(struct gl_texture_object *t ) 
{ GLboolean needLambda ;

  {
#line 37416
  if (! t->Complete) {
#line 37417
    t->SampleFunc = (void (*)(struct gl_texture_object  const  *tObj , GLuint n ,
                              float const   *s , float const   *t , float const   *u ,
                              float const   *lambda , GLubyte *r , GLubyte *g , GLubyte *b ,
                              GLubyte *a ))((void *)0);
  } else {
#line 37420
    needLambda = (GLboolean )(t->MinFilter != t->MagFilter);
#line 37421
    if (needLambda) {
#line 37422
      if (t->MagFilter == 9729) {
#line 37422
        if (t->MinFilter == 9984) {
#line 37425
          t->MinMagThresh = 0.5F;
        } else {
#line 37422
          if (t->MinFilter == 9985) {
#line 37425
            t->MinMagThresh = 0.5F;
          } else {
#line 37428
            t->MinMagThresh = 0.0F;
          }
        }
      } else {
#line 37428
        t->MinMagThresh = 0.0F;
      }
    }
#line 37431
    switch ((int )t->Dimensions) {
    case 1: 
#line 37433
    if (needLambda) {
#line 37434
      t->SampleFunc = & sample_lambda_1d;
    } else {
#line 37436
      if (t->MinFilter == 9729) {
#line 37437
        t->SampleFunc = & sample_linear_1d;
      } else {
#line 37441
        t->SampleFunc = & sample_nearest_1d;
      }
    }
#line 37443
    break;
    case 2: 
#line 37445
    if (needLambda) {
#line 37446
      t->SampleFunc = & sample_lambda_2d;
    } else {
#line 37448
      if (t->MinFilter == 9729) {
#line 37449
        t->SampleFunc = & sample_linear_2d;
      } else {
#line 37453
        if (t->WrapS == 10497) {
#line 37453
          if (t->WrapT == 10497) {
#line 37453
            if ((t->Image[0])->Border == 0U) {
#line 37453
              if ((t->Image[0])->Format == 6407) {
#line 37455
                t->SampleFunc = & opt_sample_rgb_2d;
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 37457
          if (t->WrapS == 10497) {
#line 37457
            if (t->WrapT == 10497) {
#line 37457
              if ((t->Image[0])->Border == 0U) {
#line 37457
                if ((t->Image[0])->Format == 6408) {
#line 37459
                  t->SampleFunc = & opt_sample_rgba_2d;
                } else {
#line 37462
                  t->SampleFunc = & sample_nearest_2d;
                }
              } else {
#line 37462
                t->SampleFunc = & sample_nearest_2d;
              }
            } else {
#line 37462
              t->SampleFunc = & sample_nearest_2d;
            }
          } else {
#line 37462
            t->SampleFunc = & sample_nearest_2d;
          }
        }
      }
    }
#line 37464
    break;
    case 3: 
#line 37466
    if (needLambda) {
#line 37467
      t->SampleFunc = & sample_lambda_3d;
    } else {
#line 37469
      if (t->MinFilter == 9729) {
#line 37470
        t->SampleFunc = & sample_linear_3d;
      } else {
#line 37474
        t->SampleFunc = & sample_nearest_3d;
      }
    }
#line 37476
    break;
    default: 
#line 37478
    gl_problem((GLcontext const   *)((void *)0), "invalid dimensions in gl_set_texture_sampler");
    }
  }
#line 37481
  return;
}
}
#line 37482 "D:/a/test/177.c"
static void apply_texture(GLcontext *ctx , GLuint n , GLint format , GLenum env_mode ,
                          GLubyte *red , GLubyte *green , GLubyte *blue___0 , GLubyte *alpha ,
                          GLubyte *Rt , GLubyte *Gt , GLubyte *Bt , GLubyte *At ) 
{ GLuint i ;
  GLint Rc ;
  GLint Gc ;
  GLint Bc ;
  GLint Ac ;
  float rscale ;
  float gscale ;
  float bscale ;
  float ascale ;
  GLint Lt ;
  GLubyte tmp___0 ;
  GLubyte tmp___1 ;
  GLint Lt___0 ;
  GLubyte tmp___2 ;
  GLubyte tmp___3 ;
  GLint It ;
  GLubyte tmp___4 ;
  GLubyte tmp___5 ;
  GLint Lt___1 ;
  GLint Lt___2 ;
  GLint It___0 ;
  GLint t ;
  GLint s ;
  GLint Lt___3 ;
  GLint s___0 ;
  GLint Lt___4 ;
  GLint s___1 ;
  GLint It___1 ;
  GLint s___2 ;
  float rscale___0 ;
  float gscale___0 ;
  float bscale___0 ;
  float ascale___0 ;

  {
#line 37489
  if (! (ctx->Visual)->EightBitColor) {
#line 37490
    rscale = (float )(255.0 * (double )(ctx->Visual)->InvRedScale);
#line 37491
    gscale = (float )(255.0 * (double )(ctx->Visual)->InvGreenScale);
#line 37492
    bscale = (float )(255.0 * (double )(ctx->Visual)->InvBlueScale);
#line 37493
    ascale = (float )(255.0 * (double )(ctx->Visual)->InvAlphaScale);
#line 37494
    i = 0U;
#line 37494
    while (i < n) {
#line 37495
      *(red + i) = (unsigned char )((int )((float )*(red + i) * rscale));
#line 37496
      *(green + i) = (unsigned char )((int )((float )*(green + i) * gscale));
#line 37497
      *(blue___0 + i) = (unsigned char )((int )((float )*(blue___0 + i) * bscale));
#line 37498
      *(alpha + i) = (unsigned char )((int )((float )*(alpha + i) * ascale));
#line 37494
      i ++;
    }
  }
#line 37502
  if (format == 6400) {
#line 37503
    format = 6408;
  }
#line 37505
  switch (env_mode) {
  case 7681: 
#line 37507
  switch (format) {
  case 6406: 
#line 37509
  i = 0U;
#line 37509
  while (i < n) {
#line 37511
    *(alpha + i) = *(At + i);
#line 37509
    i ++;
  }
#line 37513
  break;
  case 6409: 
#line 37515
  i = 0U;
#line 37515
  while (i < n) {
#line 37517
    Lt = (GLint )*(Rt + i);
#line 37518
    tmp___1 = (unsigned char )Lt;
#line 37518
    *(blue___0 + i) = tmp___1;
#line 37518
    tmp___0 = tmp___1;
#line 37518
    *(green + i) = tmp___0;
#line 37518
    *(red + i) = tmp___0;
#line 37515
    i ++;
  }
#line 37520
  break;
  case 6410: 
#line 37522
  i = 0U;
#line 37522
  while (i < n) {
#line 37523
    Lt___0 = (GLint )*(Rt + i);
#line 37525
    tmp___3 = (unsigned char )Lt___0;
#line 37525
    *(blue___0 + i) = tmp___3;
#line 37525
    tmp___2 = tmp___3;
#line 37525
    *(green + i) = tmp___2;
#line 37525
    *(red + i) = tmp___2;
#line 37527
    *(alpha + i) = *(At + i);
#line 37522
    i ++;
  }
#line 37529
  break;
  case 32841: 
#line 37531
  i = 0U;
#line 37531
  while (i < n) {
#line 37533
    It = (GLint )*(Rt + i);
#line 37534
    tmp___5 = (unsigned char )It;
#line 37534
    *(blue___0 + i) = tmp___5;
#line 37534
    tmp___4 = tmp___5;
#line 37534
    *(green + i) = tmp___4;
#line 37534
    *(red + i) = tmp___4;
#line 37535
    *(alpha + i) = (unsigned char )It;
#line 37531
    i ++;
  }
#line 37537
  break;
  case 6407: 
#line 37539
  i = 0U;
#line 37539
  while (i < n) {
#line 37541
    *(red + i) = *(Rt + i);
#line 37542
    *(green + i) = *(Gt + i);
#line 37543
    *(blue___0 + i) = *(Bt + i);
#line 37539
    i ++;
  }
#line 37546
  break;
  case 6408: 
#line 37548
  i = 0U;
#line 37548
  while (i < n) {
#line 37550
    *(red + i) = *(Rt + i);
#line 37551
    *(green + i) = *(Gt + i);
#line 37552
    *(blue___0 + i) = *(Bt + i);
#line 37554
    *(alpha + i) = *(At + i);
#line 37548
    i ++;
  }
#line 37556
  break;
  default: 
#line 37558
  gl_problem((GLcontext const   *)ctx, "Bad format in apply_texture");
#line 37559
  return;
  }
#line 37561
  break;
  case 8448: 
#line 37563
  switch (format) {
  case 6406: 
#line 37565
  i = 0U;
#line 37565
  while (i < n) {
#line 37568
    *(alpha + i) = (unsigned char )((int )*(alpha + i) * ((int )*(At + i) + 1) >> 8);
#line 37565
    i ++;
  }
#line 37570
  break;
  case 6409: 
#line 37572
  i = 0U;
#line 37572
  while (i < n) {
#line 37574
    Lt___1 = (GLint )*(Rt + i);
#line 37575
    *(red + i) = (unsigned char )((int )*(red + i) * (Lt___1 + 1) >> 8);
#line 37576
    *(green + i) = (unsigned char )((int )*(green + i) * (Lt___1 + 1) >> 8);
#line 37577
    *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) * (Lt___1 + 1) >> 8);
#line 37572
    i ++;
  }
#line 37580
  break;
  case 6410: 
#line 37582
  i = 0U;
#line 37582
  while (i < n) {
#line 37584
    Lt___2 = (GLint )*(Rt + i);
#line 37585
    *(red + i) = (unsigned char )((int )*(red + i) * (Lt___2 + 1) >> 8);
#line 37586
    *(green + i) = (unsigned char )((int )*(green + i) * (Lt___2 + 1) >> 8);
#line 37587
    *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) * (Lt___2 + 1) >> 8);
#line 37589
    *(alpha + i) = (unsigned char )((int )*(alpha + i) * ((int )*(At + i) + 1) >> 8);
#line 37582
    i ++;
  }
#line 37591
  break;
  case 32841: 
#line 37593
  i = 0U;
#line 37593
  while (i < n) {
#line 37595
    It___0 = (GLint )*(Rt + i);
#line 37596
    *(red + i) = (unsigned char )((int )*(red + i) * (It___0 + 1) >> 8);
#line 37597
    *(green + i) = (unsigned char )((int )*(green + i) * (It___0 + 1) >> 8);
#line 37598
    *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) * (It___0 + 1) >> 8);
#line 37600
    *(alpha + i) = (unsigned char )((int )*(alpha + i) * (It___0 + 1) >> 8);
#line 37593
    i ++;
  }
#line 37602
  break;
  case 6407: 
#line 37604
  i = 0U;
#line 37604
  while (i < n) {
#line 37606
    *(red + i) = (unsigned char )((int )*(red + i) * ((int )*(Rt + i) + 1) >> 8);
#line 37607
    *(green + i) = (unsigned char )((int )*(green + i) * ((int )*(Gt + i) + 1) >> 8);
#line 37608
    *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) * ((int )*(Bt + i) + 1) >> 8);
#line 37604
    i ++;
  }
#line 37611
  break;
  case 6408: 
#line 37613
  i = 0U;
#line 37613
  while (i < n) {
#line 37615
    *(red + i) = (unsigned char )((int )*(red + i) * ((int )*(Rt + i) + 1) >> 8);
#line 37616
    *(green + i) = (unsigned char )((int )*(green + i) * ((int )*(Gt + i) + 1) >> 8);
#line 37617
    *(blue___0 + i) = (unsigned char )((int )*(blue___0 + i) * ((int )*(Bt + i) + 1) >> 8);
#line 37619
    *(alpha + i) = (unsigned char )((int )*(alpha + i) * ((int )*(At + i) + 1) >> 8);
#line 37613
    i ++;
  }
#line 37621
  break;
  default: 
#line 37623
  gl_problem((GLcontext const   *)ctx, "Bad format (2) in apply_texture");
#line 37624
  return;
  }
#line 37626
  break;
  case 8449: 
#line 37628
  switch (format) {
  case 6406: 
  case 6409: 
  case 6410: 
  case 32841: 
#line 37633
  break;
  case 6407: 
#line 37635
  i = 0U;
#line 37635
  while (i < n) {
#line 37637
    *(red + i) = *(Rt + i);
#line 37638
    *(green + i) = *(Gt + i);
#line 37639
    *(blue___0 + i) = *(Bt + i);
#line 37635
    i ++;
  }
#line 37642
  break;
  case 6408: 
#line 37644
  i = 0U;
#line 37644
  while (i < n) {
#line 37646
    t = (GLint )*(At + i);
#line 37646
    s = 255 - t;
#line 37647
    *(red + i) = (unsigned char )(((int )*(red + i) * (s + 1) >> 8) + ((int )*(Rt + i) * (t + 1) >> 8));
#line 37648
    *(green + i) = (unsigned char )(((int )*(green + i) * (s + 1) >> 8) + ((int )*(Gt + i) * (t + 1) >> 8));
#line 37649
    *(blue___0 + i) = (unsigned char )(((int )*(blue___0 + i) * (s + 1) >> 8) + ((int )*(Bt + i) * (t + 1) >> 8));
#line 37644
    i ++;
  }
#line 37652
  break;
  default: 
#line 37654
  gl_problem((GLcontext const   *)ctx, "Bad format (3) in apply_texture");
#line 37655
  return;
  }
#line 37657
  break;
  case 3042: 
#line 37659
  Rc = (int )(ctx->Texture.EnvColor[0] * 255.0F);
#line 37660
  Gc = (int )(ctx->Texture.EnvColor[1] * 255.0F);
#line 37661
  Bc = (int )(ctx->Texture.EnvColor[2] * 255.0F);
#line 37662
  Ac = (int )(ctx->Texture.EnvColor[3] * 255.0F);
#line 37663
  switch (format) {
  case 6406: 
#line 37665
  i = 0U;
#line 37665
  while (i < n) {
#line 37668
    *(alpha + i) = (unsigned char )((int )*(alpha + i) * ((int )*(At + i) + 1) >> 8);
#line 37665
    i ++;
  }
#line 37670
  break;
  case 6409: 
#line 37672
  i = 0U;
#line 37672
  while (i < n) {
#line 37674
    Lt___3 = (GLint )*(Rt + i);
#line 37674
    s___0 = 255 - Lt___3;
#line 37675
    *(red + i) = (unsigned char )(((int )*(red + i) * (s___0 + 1) >> 8) + (Rc * (Lt___3 + 1) >> 8));
#line 37676
    *(green + i) = (unsigned char )(((int )*(green + i) * (s___0 + 1) >> 8) + (Gc * (Lt___3 + 1) >> 8));
#line 37677
    *(blue___0 + i) = (unsigned char )(((int )*(blue___0 + i) * (s___0 + 1) >> 8) + (Bc * (Lt___3 + 1) >> 8));
#line 37672
    i ++;
  }
#line 37680
  break;
  case 6410: 
#line 37682
  i = 0U;
#line 37682
  while (i < n) {
#line 37684
    Lt___4 = (GLint )*(Rt + i);
#line 37684
    s___1 = 255 - Lt___4;
#line 37685
    *(red + i) = (unsigned char )(((int )*(red + i) * (s___1 + 1) >> 8) + (Rc * (Lt___4 + 1) >> 8));
#line 37686
    *(green + i) = (unsigned char )(((int )*(green + i) * (s___1 + 1) >> 8) + (Gc * (Lt___4 + 1) >> 8));
#line 37687
    *(blue___0 + i) = (unsigned char )(((int )*(blue___0 + i) * (s___1 + 1) >> 8) + (Bc * (Lt___4 + 1) >> 8));
#line 37689
    *(alpha + i) = (unsigned char )((int )*(alpha + i) * ((int )*(At + i) + 1) >> 8);
#line 37682
    i ++;
  }
#line 37691
  break;
  case 32841: 
#line 37693
  i = 0U;
#line 37693
  while (i < n) {
#line 37695
    It___1 = (GLint )*(Rt + i);
#line 37695
    s___2 = 255 - It___1;
#line 37696
    *(red + i) = (unsigned char )(((int )*(red + i) * (s___2 + 1) >> 8) + (Rc * (It___1 + 1) >> 8));
#line 37697
    *(green + i) = (unsigned char )(((int )*(green + i) * (s___2 + 1) >> 8) + (Gc * (It___1 + 1) >> 8));
#line 37698
    *(blue___0 + i) = (unsigned char )(((int )*(blue___0 + i) * (s___2 + 1) >> 8) + (Bc * (It___1 + 1) >> 8));
#line 37699
    *(alpha + i) = (unsigned char )(((int )*(alpha + i) * (s___2 + 1) >> 8) + (Ac * (It___1 + 1) >> 8));
#line 37693
    i ++;
  }
#line 37701
  break;
  case 6407: 
#line 37703
  i = 0U;
#line 37703
  while (i < n) {
#line 37705
    *(red + i) = (unsigned char )(((int )*(red + i) * ((255 - (int )*(Rt + i)) + 1) >> 8) + (Rc * ((int )*(Rt + i) + 1) >> 8));
#line 37706
    *(green + i) = (unsigned char )(((int )*(green + i) * ((255 - (int )*(Gt + i)) + 1) >> 8) + (Gc * ((int )*(Gt + i) + 1) >> 8));
#line 37707
    *(blue___0 + i) = (unsigned char )(((int )*(blue___0 + i) * ((255 - (int )*(Bt + i)) + 1) >> 8) + (Bc * ((int )*(Bt + i) + 1) >> 8));
#line 37703
    i ++;
  }
#line 37710
  break;
  case 6408: 
#line 37712
  i = 0U;
#line 37712
  while (i < n) {
#line 37714
    *(red + i) = (unsigned char )(((int )*(red + i) * ((255 - (int )*(Rt + i)) + 1) >> 8) + (Rc * ((int )*(Rt + i) + 1) >> 8));
#line 37715
    *(green + i) = (unsigned char )(((int )*(green + i) * ((255 - (int )*(Gt + i)) + 1) >> 8) + (Gc * ((int )*(Gt + i) + 1) >> 8));
#line 37716
    *(blue___0 + i) = (unsigned char )(((int )*(blue___0 + i) * ((255 - (int )*(Bt + i)) + 1) >> 8) + (Bc * ((int )*(Bt + i) + 1) >> 8));
#line 37718
    *(alpha + i) = (unsigned char )((int )*(alpha + i) * ((int )*(At + i) + 1) >> 8);
#line 37712
    i ++;
  }
#line 37720
  break;
  }
#line 37722
  break;
  default: 
#line 37724
  gl_problem((GLcontext const   *)ctx, "Bad env mode in apply_texture");
#line 37725
  return;
  }
#line 37728
  if (! (ctx->Visual)->EightBitColor) {
#line 37729
    rscale___0 = (ctx->Visual)->RedScale * (1.0F / 255.0F);
#line 37730
    gscale___0 = (ctx->Visual)->GreenScale * (1.0F / 255.0F);
#line 37731
    bscale___0 = (ctx->Visual)->BlueScale * (1.0F / 255.0F);
#line 37732
    ascale___0 = (ctx->Visual)->AlphaScale * (1.0F / 255.0F);
#line 37733
    i = 0U;
#line 37733
    while (i < n) {
#line 37734
      *(red + i) = (unsigned char )((int )((float )*(red + i) * rscale___0));
#line 37735
      *(green + i) = (unsigned char )((int )((float )*(green + i) * gscale___0));
#line 37736
      *(blue___0 + i) = (unsigned char )((int )((float )*(blue___0 + i) * bscale___0));
#line 37737
      *(alpha + i) = (unsigned char )((int )((float )*(alpha + i) * ascale___0));
#line 37733
      i ++;
    }
  }
#line 37740
  return;
}
}
#line 37741 "D:/a/test/177.c"
void gl_texture_pixels(GLcontext *ctx , GLuint n , float const   *s , float const   *t ,
                       float const   *r , float const   *lambda , GLubyte *red , GLubyte *green ,
                       GLubyte *blue___0 , GLubyte *alpha ) 
{ GLubyte tred[1920] ;
  GLubyte tgreen[1920] ;
  GLubyte tblue[1920] ;
  GLubyte talpha[1920] ;

  {
#line 37751
  if (! ctx->Texture.Current) {
#line 37752
    return;
  } else {
#line 37751
    if (! (ctx->Texture.Current)->SampleFunc) {
#line 37752
      return;
    }
  }
#line 37753
  (*((ctx->Texture.Current)->SampleFunc))((struct gl_texture_object  const  *)ctx->Texture.Current,
                                          n, s, t, r, lambda, tred, tgreen, tblue,
                                          talpha);
#line 37756
  apply_texture(ctx, n, ((ctx->Texture.Current)->Image[0])->Format, ctx->Texture.EnvMode,
                red, green, blue___0, alpha, tred, tgreen, tblue, talpha);
#line 37761
  return;
}
}
#line 37767 "D:/a/test/177.c"
static void feedback_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 ,
                              GLuint pv ) 
{ struct vertex_buffer *VB ;
  float color[4] ;
  GLuint i ;
  float invRedScale ;
  float invGreenScale ;
  float invBlueScale ;
  float invAlphaScale ;
  float x ;
  float y ;
  float z ;
  float w ;
  float tc[4] ;
  GLuint v ;
  float invq ;

  {
#line 37770
  VB = ctx->VB;
#line 37773
  invRedScale = (ctx->Visual)->InvRedScale;
#line 37774
  invGreenScale = (ctx->Visual)->InvGreenScale;
#line 37775
  invBlueScale = (ctx->Visual)->InvBlueScale;
#line 37776
  invAlphaScale = (ctx->Visual)->InvAlphaScale;
#line 37777
  FEEDBACK_TOKEN(ctx, (float )1795);
#line 37778
  FEEDBACK_TOKEN(ctx, (float )3);
#line 37779
  if (ctx->Light.ShadeModel == 7424) {
#line 37780
    color[0] = (float )(*(VB->Color + pv))[0] * invRedScale;
#line 37781
    color[1] = (float )(*(VB->Color + pv))[1] * invGreenScale;
#line 37782
    color[2] = (float )(*(VB->Color + pv))[2] * invBlueScale;
#line 37783
    color[3] = (float )(*(VB->Color + pv))[3] * invAlphaScale;
  }
#line 37785
  i = 0U;
#line 37785
  while (i < 3U) {
#line 37790
    if (i == 0U) {
#line 37790
      v = v0;
    } else {
#line 37791
      if (i == 1U) {
#line 37791
        v = v1;
      } else {
#line 37792
        v = v2;
      }
    }
#line 37793
    x = VB->Win[v][0];
#line 37794
    y = VB->Win[v][1];
#line 37795
    z = VB->Win[v][2] / 65535.0F;
#line 37796
    w = VB->Clip[v][3];
#line 37797
    if (ctx->Light.ShadeModel == 7425) {
#line 37798
      color[0] = (float )(*(VB->Color + v))[0] * invRedScale;
#line 37799
      color[1] = (float )(*(VB->Color + v))[1] * invGreenScale;
#line 37800
      color[2] = (float )(*(VB->Color + v))[2] * invBlueScale;
#line 37801
      color[3] = (float )(*(VB->Color + v))[3] * invAlphaScale;
    }
#line 37803
    if ((double )VB->TexCoord[v][3] == 0.0) {
#line 37803
      invq = (float )1.0;
    } else {
#line 37803
      invq = 1.0F / VB->TexCoord[v][3];
    }
#line 37804
    tc[0] = VB->TexCoord[v][0] * invq;
#line 37805
    tc[1] = VB->TexCoord[v][1] * invq;
#line 37806
    tc[2] = VB->TexCoord[v][2] * invq;
#line 37807
    tc[3] = VB->TexCoord[v][3];
#line 37808
    gl_feedback_vertex(ctx, x, y, z, w, (float const   *)(color), (float )*(VB->Index + v),
                       (float const   *)(tc));
#line 37785
    i ++;
  }
#line 37810
  return;
}
}
#line 37811 "D:/a/test/177.c"
static void select_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 , GLuint pv ) 
{ struct vertex_buffer *VB ;

  {
#line 37814
  VB = ctx->VB;
#line 37815
  gl_update_hitflag(ctx, VB->Win[v0][2] / 65535.0F);
#line 37816
  gl_update_hitflag(ctx, VB->Win[v1][2] / 65535.0F);
#line 37817
  gl_update_hitflag(ctx, VB->Win[v2][2] / 65535.0F);
#line 37818
  return;
}
}
#line 37819 "D:/a/test/177.c"
static void flat_ci_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 ,
                             GLuint pv ) 
{ 

  {
#line 37842
  return;
}
}
#line 37843 "D:/a/test/177.c"
static void smooth_ci_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 ,
                               GLuint pv ) 
{ 

  {
#line 37864
  return;
}
}
#line 37865 "D:/a/test/177.c"
static void flat_rgba_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 ,
                               GLuint pv ) 
{ 

  {
#line 37893
  return;
}
}
#line 37894 "D:/a/test/177.c"
static void smooth_rgba_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 ,
                                 GLuint pv ) 
{ 

  {
#line 37924
  return;
}
}
#line 37925 "D:/a/test/177.c"
static void simple_textured_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 ,
                                     GLuint pv ) 
{ 

  {
#line 37960
  return;
}
}
#line 37961 "D:/a/test/177.c"
static void simple_z_textured_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 ,
                                       GLuint pv ) 
{ 

  {
#line 38007
  return;
}
}
#line 38008 "D:/a/test/177.c"
static void general_textured_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 ,
                                      GLuint pv ) 
{ 

  {
#line 38081
  return;
}
}
#line 38105 "D:/a/test/177.c"
static void lambda_textured_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 ,
                                     GLuint pv ) 
{ 

  {
#line 38203
  return;
}
}
#line 38204 "D:/a/test/177.c"
static void null_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 , GLuint pv ) 
{ 

  {
#line 38207
  return;
}
}
#line 38208 "D:/a/test/177.c"
void gl_set_triangle_function(GLcontext *ctx ) 
{ GLboolean rgbmode ;
  GLboolean needLambda ;

  {
#line 38210
  rgbmode = (ctx->Visual)->RGBAflag;
#line 38211
  if (ctx->RenderMode == 7168) {
#line 38212
    if (ctx->NoRaster) {
#line 38213
      ctx->Driver.TriangleFunc = & null_triangle;
#line 38214
      return;
    }
#line 38216
    if (! ctx->Driver.TriangleFunc) {
#line 38218
      if (ctx->Texture.Enabled) {
#line 38218
        if (ctx->Texture.Current) {
#line 38218
          if ((ctx->Texture.Current)->Complete) {
#line 38221
            if (ctx->Texture.Enabled == 2U) {
#line 38221
              if ((ctx->Texture.Current2D)->MinFilter == 9728) {
#line 38221
                if ((ctx->Texture.Current2D)->MagFilter == 9728) {
#line 38221
                  if ((ctx->Texture.Current2D)->WrapS == 10497) {
#line 38221
                    if ((ctx->Texture.Current2D)->WrapT == 10497) {
#line 38221
                      if (((ctx->Texture.Current2D)->Image[0])->Format == 6407) {
#line 38221
                        if (((ctx->Texture.Current2D)->Image[0])->Border == 0U) {
#line 38221
                          if (ctx->Texture.EnvMode == 8449) {
                            goto _L___8;
                          } else {
#line 38221
                            if (ctx->Texture.EnvMode == 7681) {
                              _L___8: /* CIL Label */ 
#line 38221
                              if (ctx->Hint.PerspectiveCorrection == 4353) {
#line 38221
                                if (ctx->TextureMatrixType == 1U) {
#line 38221
                                  if (ctx->RasterMask == 4U) {
#line 38221
                                    if (ctx->Depth.Func == 513) {
#line 38221
                                      if ((int )ctx->Depth.Mask == 1) {
                                        goto _L___2;
                                      } else {
                                        goto _L___4;
                                      }
                                    } else {
                                      goto _L___4;
                                    }
                                  } else {
                                    _L___4: /* CIL Label */ 
#line 38221
                                    if (ctx->RasterMask == 0U) {
                                      _L___2: /* CIL Label */ 
#line 38221
                                      if ((int )ctx->Polygon.StippleFlag == 0) {
#line 38221
                                        if ((ctx->Visual)->EightBitColor) {
#line 38238
                                          if (ctx->RasterMask == 4U) {
#line 38239
                                            ctx->Driver.TriangleFunc = & simple_z_textured_triangle;
                                          } else {
#line 38242
                                            ctx->Driver.TriangleFunc = & simple_textured_triangle;
                                          }
                                        } else {
                                          goto _L___14;
                                        }
                                      } else {
                                        goto _L___14;
                                      }
                                    } else {
                                      goto _L___14;
                                    }
                                  }
                                } else {
                                  goto _L___14;
                                }
                              } else {
                                goto _L___14;
                              }
                            } else {
                              goto _L___14;
                            }
                          }
                        } else {
                          goto _L___14;
                        }
                      } else {
                        goto _L___14;
                      }
                    } else {
                      goto _L___14;
                    }
                  } else {
                    goto _L___14;
                  }
                } else {
                  goto _L___14;
                }
              } else {
                goto _L___14;
              }
            } else {
              _L___14: /* CIL Label */ 
#line 38246
              needLambda = (GLboolean )1;
#line 38247
              if (ctx->Texture.Enabled & 4U) {
#line 38248
                if ((ctx->Texture.Current3D)->MinFilter == (ctx->Texture.Current3D)->MagFilter) {
#line 38250
                  needLambda = (unsigned char)0;
                }
              } else {
#line 38253
                if (ctx->Texture.Enabled & 2U) {
#line 38254
                  if ((ctx->Texture.Current2D)->MinFilter == (ctx->Texture.Current2D)->MagFilter) {
#line 38256
                    needLambda = (unsigned char)0;
                  }
                } else {
#line 38259
                  if (ctx->Texture.Enabled & 1U) {
#line 38260
                    if ((ctx->Texture.Current1D)->MinFilter == (ctx->Texture.Current1D)->MagFilter) {
#line 38262
                      needLambda = (unsigned char)0;
                    }
                  }
                }
              }
#line 38265
              if (needLambda) {
#line 38265
                ctx->Driver.TriangleFunc = & lambda_textured_triangle;
              } else {
#line 38265
                ctx->Driver.TriangleFunc = & general_textured_triangle;
              }
            }
          } else {
            goto _L___16;
          }
        } else {
          goto _L___16;
        }
      } else {
        _L___16: /* CIL Label */ 
#line 38270
        if (ctx->Light.ShadeModel == 7425) {
#line 38272
          if (rgbmode) {
#line 38272
            ctx->Driver.TriangleFunc = & smooth_rgba_triangle;
          } else {
#line 38272
            ctx->Driver.TriangleFunc = & smooth_ci_triangle;
          }
        } else {
#line 38277
          if (rgbmode) {
#line 38277
            ctx->Driver.TriangleFunc = & flat_rgba_triangle;
          } else {
#line 38277
            ctx->Driver.TriangleFunc = & flat_ci_triangle;
          }
        }
      }
    }
  } else {
#line 38282
    if (ctx->RenderMode == 7169) {
#line 38283
      ctx->Driver.TriangleFunc = & feedback_triangle;
    } else {
#line 38286
      ctx->Driver.TriangleFunc = & select_triangle;
    }
  }
#line 38288
  return;
}
}
#line 38294 "D:/a/test/177.c"
void gl_VertexPointer(GLcontext *ctx , GLint size , GLenum type , GLsizei stride ,
                      GLvoid const   *ptr ) 
{ 

  {
#line 38298
  if (size < 2) {
#line 38299
    gl_error(ctx, 1281, "glVertexPointer(size)");
#line 38300
    return;
  } else {
#line 38298
    if (size > 4) {
#line 38299
      gl_error(ctx, 1281, "glVertexPointer(size)");
#line 38300
      return;
    }
  }
#line 38302
  if (stride < 0) {
#line 38303
    gl_error(ctx, 1281, "glVertexPointer(stride)");
#line 38304
    return;
  }
#line 38306
  switch (type) {
  case 5122: 
#line 38308
  if (stride) {
#line 38308
    ctx->Array.VertexStrideB = stride;
  } else {
#line 38308
    ctx->Array.VertexStrideB = (int )((unsigned int )size * sizeof(GLshort ));
  }
#line 38309
  break;
  case 5124: 
#line 38311
  if (stride) {
#line 38311
    ctx->Array.VertexStrideB = stride;
  } else {
#line 38311
    ctx->Array.VertexStrideB = (int )((unsigned int )size * sizeof(GLint ));
  }
#line 38312
  break;
  case 5126: 
#line 38314
  if (stride) {
#line 38314
    ctx->Array.VertexStrideB = stride;
  } else {
#line 38314
    ctx->Array.VertexStrideB = (int )((unsigned int )size * sizeof(float ));
  }
#line 38315
  break;
  case 5130: 
#line 38317
  if (stride) {
#line 38317
    ctx->Array.VertexStrideB = stride;
  } else {
#line 38317
    ctx->Array.VertexStrideB = (int )((unsigned int )size * sizeof(GLdouble ));
  }
#line 38318
  break;
  default: 
#line 38320
  gl_error(ctx, 1280, "glVertexPointer(type)");
#line 38321
  return;
  }
#line 38323
  ctx->Array.VertexSize = size;
#line 38324
  ctx->Array.VertexType = type;
#line 38325
  ctx->Array.VertexStride = stride;
#line 38326
  ctx->Array.VertexPtr = (void *)ptr;
#line 38327
  return;
}
}
#line 38328 "D:/a/test/177.c"
void gl_NormalPointer(GLcontext *ctx , GLenum type , GLsizei stride , GLvoid const   *ptr ) 
{ 

  {
#line 38331
  if (stride < 0) {
#line 38332
    gl_error(ctx, 1281, "glNormalPointer(stride)");
#line 38333
    return;
  }
#line 38335
  switch (type) {
  case 5120: 
#line 38337
  if (stride) {
#line 38337
    ctx->Array.NormalStrideB = stride;
  } else {
#line 38337
    ctx->Array.NormalStrideB = (int )(3U * sizeof(GLbyte ));
  }
#line 38338
  break;
  case 5122: 
#line 38340
  if (stride) {
#line 38340
    ctx->Array.NormalStrideB = stride;
  } else {
#line 38340
    ctx->Array.NormalStrideB = (int )(3U * sizeof(GLshort ));
  }
#line 38341
  break;
  case 5124: 
#line 38343
  if (stride) {
#line 38343
    ctx->Array.NormalStrideB = stride;
  } else {
#line 38343
    ctx->Array.NormalStrideB = (int )(3U * sizeof(GLint ));
  }
#line 38344
  break;
  case 5126: 
#line 38346
  if (stride) {
#line 38346
    ctx->Array.NormalStrideB = stride;
  } else {
#line 38346
    ctx->Array.NormalStrideB = (int )(3U * sizeof(float ));
  }
#line 38347
  break;
  case 5130: 
#line 38349
  if (stride) {
#line 38349
    ctx->Array.NormalStrideB = stride;
  } else {
#line 38349
    ctx->Array.NormalStrideB = (int )(3U * sizeof(GLdouble ));
  }
#line 38350
  break;
  default: 
#line 38352
  gl_error(ctx, 1280, "glNormalPointer(type)");
#line 38353
  return;
  }
#line 38355
  ctx->Array.NormalType = type;
#line 38356
  ctx->Array.NormalStride = stride;
#line 38357
  ctx->Array.NormalPtr = (void *)ptr;
#line 38358
  return;
}
}
#line 38359 "D:/a/test/177.c"
void gl_ColorPointer(GLcontext *ctx , GLint size , GLenum type , GLsizei stride ,
                     GLvoid const   *ptr ) 
{ 

  {
#line 38363
  if (size < 3) {
#line 38364
    gl_error(ctx, 1281, "glColorPointer(size)");
#line 38365
    return;
  } else {
#line 38363
    if (size > 4) {
#line 38364
      gl_error(ctx, 1281, "glColorPointer(size)");
#line 38365
      return;
    }
  }
#line 38367
  if (stride < 0) {
#line 38368
    gl_error(ctx, 1281, "glColorPointer(stride)");
#line 38369
    return;
  }
#line 38371
  switch (type) {
  case 5120: 
#line 38373
  if (stride) {
#line 38373
    ctx->Array.ColorStrideB = stride;
  } else {
#line 38373
    ctx->Array.ColorStrideB = (int )((unsigned int )size * sizeof(GLbyte ));
  }
#line 38374
  break;
  case 5121: 
#line 38376
  if (stride) {
#line 38376
    ctx->Array.ColorStrideB = stride;
  } else {
#line 38376
    ctx->Array.ColorStrideB = (int )((unsigned int )size * sizeof(GLubyte ));
  }
#line 38377
  break;
  case 5122: 
#line 38379
  if (stride) {
#line 38379
    ctx->Array.ColorStrideB = stride;
  } else {
#line 38379
    ctx->Array.ColorStrideB = (int )((unsigned int )size * sizeof(GLshort ));
  }
#line 38380
  break;
  case 5123: 
#line 38382
  if (stride) {
#line 38382
    ctx->Array.ColorStrideB = stride;
  } else {
#line 38382
    ctx->Array.ColorStrideB = (int )((unsigned int )size * sizeof(GLushort ));
  }
#line 38383
  break;
  case 5124: 
#line 38385
  if (stride) {
#line 38385
    ctx->Array.ColorStrideB = stride;
  } else {
#line 38385
    ctx->Array.ColorStrideB = (int )((unsigned int )size * sizeof(GLint ));
  }
#line 38386
  break;
  case 5125: 
#line 38388
  if (stride) {
#line 38388
    ctx->Array.ColorStrideB = stride;
  } else {
#line 38388
    ctx->Array.ColorStrideB = (int )((unsigned int )size * sizeof(GLuint ));
  }
#line 38389
  break;
  case 5126: 
#line 38391
  if (stride) {
#line 38391
    ctx->Array.ColorStrideB = stride;
  } else {
#line 38391
    ctx->Array.ColorStrideB = (int )((unsigned int )size * sizeof(float ));
  }
#line 38392
  break;
  case 5130: 
#line 38394
  if (stride) {
#line 38394
    ctx->Array.ColorStrideB = stride;
  } else {
#line 38394
    ctx->Array.ColorStrideB = (int )((unsigned int )size * sizeof(GLdouble ));
  }
#line 38395
  break;
  default: 
#line 38397
  gl_error(ctx, 1280, "glColorPointer(type)");
#line 38398
  return;
  }
#line 38400
  ctx->Array.ColorSize = size;
#line 38401
  ctx->Array.ColorType = type;
#line 38402
  ctx->Array.ColorStride = stride;
#line 38403
  ctx->Array.ColorPtr = (void *)ptr;
#line 38404
  return;
}
}
#line 38405 "D:/a/test/177.c"
void gl_IndexPointer(GLcontext *ctx , GLenum type , GLsizei stride , GLvoid const   *ptr ) 
{ 

  {
#line 38408
  if (stride < 0) {
#line 38409
    gl_error(ctx, 1281, "glIndexPointer(stride)");
#line 38410
    return;
  }
#line 38412
  switch (type) {
  case 5122: 
#line 38414
  if (stride) {
#line 38414
    ctx->Array.IndexStrideB = stride;
  } else {
#line 38414
    ctx->Array.IndexStrideB = (int )sizeof(GLbyte );
  }
#line 38415
  break;
  case 5124: 
#line 38417
  if (stride) {
#line 38417
    ctx->Array.IndexStrideB = stride;
  } else {
#line 38417
    ctx->Array.IndexStrideB = (int )sizeof(GLint );
  }
#line 38418
  break;
  case 5126: 
#line 38420
  if (stride) {
#line 38420
    ctx->Array.IndexStrideB = stride;
  } else {
#line 38420
    ctx->Array.IndexStrideB = (int )sizeof(float );
  }
#line 38421
  break;
  case 5130: 
#line 38423
  if (stride) {
#line 38423
    ctx->Array.IndexStrideB = stride;
  } else {
#line 38423
    ctx->Array.IndexStrideB = (int )sizeof(GLdouble );
  }
#line 38424
  break;
  default: 
#line 38426
  gl_error(ctx, 1280, "glIndexPointer(type)");
#line 38427
  return;
  }
#line 38429
  ctx->Array.IndexType = type;
#line 38430
  ctx->Array.IndexStride = stride;
#line 38431
  ctx->Array.IndexPtr = (void *)ptr;
#line 38432
  return;
}
}
#line 38433 "D:/a/test/177.c"
void gl_TexCoordPointer(GLcontext *ctx , GLint size , GLenum type , GLsizei stride ,
                        GLvoid const   *ptr ) 
{ 

  {
#line 38437
  if (size < 1) {
#line 38438
    gl_error(ctx, 1281, "glTexCoordPointer(size)");
#line 38439
    return;
  } else {
#line 38437
    if (size > 4) {
#line 38438
      gl_error(ctx, 1281, "glTexCoordPointer(size)");
#line 38439
      return;
    }
  }
#line 38441
  switch (type) {
  case 5122: 
#line 38443
  if (stride) {
#line 38443
    ctx->Array.TexCoordStrideB = stride;
  } else {
#line 38443
    ctx->Array.TexCoordStrideB = (int )((unsigned int )size * sizeof(GLshort ));
  }
#line 38444
  break;
  case 5124: 
#line 38446
  if (stride) {
#line 38446
    ctx->Array.TexCoordStrideB = stride;
  } else {
#line 38446
    ctx->Array.TexCoordStrideB = (int )((unsigned int )size * sizeof(GLint ));
  }
#line 38447
  break;
  case 5126: 
#line 38449
  if (stride) {
#line 38449
    ctx->Array.TexCoordStrideB = stride;
  } else {
#line 38449
    ctx->Array.TexCoordStrideB = (int )((unsigned int )size * sizeof(float ));
  }
#line 38450
  break;
  case 5130: 
#line 38452
  if (stride) {
#line 38452
    ctx->Array.TexCoordStrideB = stride;
  } else {
#line 38452
    ctx->Array.TexCoordStrideB = (int )((unsigned int )size * sizeof(GLdouble ));
  }
#line 38453
  break;
  default: 
#line 38455
  gl_error(ctx, 1280, "glTexCoordPointer(type)");
#line 38456
  return;
  }
#line 38458
  if (stride < 0) {
#line 38459
    gl_error(ctx, 1281, "glTexCoordPointer(stride)");
#line 38460
    return;
  }
#line 38462
  ctx->Array.TexCoordSize = size;
#line 38463
  ctx->Array.TexCoordType = type;
#line 38464
  ctx->Array.TexCoordStride = stride;
#line 38465
  ctx->Array.TexCoordPtr = (void *)ptr;
#line 38466
  return;
}
}
#line 38475 "D:/a/test/177.c"
struct vertex_buffer *gl_alloc_vb(void) 
{ struct vertex_buffer *vb ;
  void *tmp___0 ;
  GLuint i ;

  {
#line 38478
  tmp___0 = calloc(sizeof(struct vertex_buffer ), 1U);
#line 38478
  vb = (struct vertex_buffer *)tmp___0;
#line 38479
  if (vb) {
#line 38481
    i = 0U;
#line 38481
    while (i < 504U) {
#line 38482
      vb->MaterialMask[i] = 0U;
#line 38483
      vb->ClipMask[i] = (unsigned char)0;
#line 38484
      vb->Obj[i][3] = 1.0F;
#line 38485
      vb->TexCoord[i][2] = 0.0F;
#line 38486
      vb->TexCoord[i][3] = 1.0F;
#line 38481
      i ++;
    }
#line 38488
    vb->VertexSizeMask = 2U;
#line 38489
    vb->TexCoordSize = 2U;
#line 38490
    vb->MonoColor = (unsigned char)1;
#line 38491
    vb->MonoMaterial = (unsigned char)1;
#line 38492
    vb->MonoNormal = (unsigned char)1;
#line 38493
    vb->ClipOrMask = (unsigned char)0;
#line 38494
    vb->ClipAndMask = (unsigned char)63;
  }
#line 38496
  return (vb);
}
}
#line 38503 "D:/a/test/177.c"
void gl_Normal3f(GLcontext *ctx , float nx , float ny , float nz ) 
{ 

  {
#line 38505
  ctx->Current.Normal[0] = nx;
#line 38506
  ctx->Current.Normal[1] = ny;
#line 38507
  ctx->Current.Normal[2] = nz;
#line 38508
  (ctx->VB)->MonoNormal = (unsigned char)0;
#line 38509
  return;
}
}
#line 38510 "D:/a/test/177.c"
void gl_Normal3fv(GLcontext *ctx , float const   *n ) 
{ 

  {
#line 38512
  ctx->Current.Normal[0] = (float )*(n + 0);
#line 38513
  ctx->Current.Normal[1] = (float )*(n + 1);
#line 38514
  ctx->Current.Normal[2] = (float )*(n + 2);
#line 38515
  (ctx->VB)->MonoNormal = (unsigned char)0;
#line 38516
  return;
}
}
#line 38517 "D:/a/test/177.c"
void gl_Indexf(GLcontext *ctx , float c ) 
{ 

  {
#line 38519
  ctx->Current.Index = (unsigned int )((int )c);
#line 38520
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 38521
  return;
}
}
#line 38522 "D:/a/test/177.c"
void gl_Indexi(GLcontext *ctx , GLint c ) 
{ 

  {
#line 38524
  ctx->Current.Index = (unsigned int )c;
#line 38525
  (ctx->VB)->MonoColor = (unsigned char)0;
#line 38526
  return;
}
}
#line 38545 "D:/a/test/177.c"
static void render_clipped_line(GLcontext *ctx , GLuint v1 , GLuint v2 ) 
{ float ndc_x ;
  float ndc_y ;
  float ndc_z ;
  GLuint provoking_vertex ;
  struct vertex_buffer *VB ;
  GLuint orig_v1 ;
  GLuint orig_v2 ;
  GLuint tmp___0 ;
  GLuint tmp___1 ;
  float wInv ;
  float wInv___0 ;

  {
#line 38549
  VB = ctx->VB;
#line 38550
  provoking_vertex = v2;
#line 38551
  VB->Free = 480U;
#line 38552
  if (ctx->Transform.AnyClip) {
#line 38553
    orig_v1 = v1;
#line 38553
    orig_v2 = v2;
#line 38554
    tmp___0 = gl_userclip_line(ctx, & v1, & v2);
#line 38554
    if (tmp___0 == 0U) {
#line 38555
      return;
    }
#line 38556
    if (v1 != orig_v1) {
#line 38557
      TRANSFORM_POINT(VB->Clip[v1], ctx->ProjectionMatrix, VB->Eye[v1]);
    }
#line 38559
    if (v2 != orig_v2) {
#line 38560
      TRANSFORM_POINT(VB->Clip[v2], ctx->ProjectionMatrix, VB->Eye[v2]);
    }
  }
#line 38563
  tmp___1 = gl_viewclip_line(ctx, & v1, & v2);
#line 38563
  if (tmp___1 == 0U) {
#line 38564
    return;
  }
#line 38565
  if (VB->Clip[v1][3] != 0.0F) {
#line 38566
    wInv = 1.0F / VB->Clip[v1][3];
#line 38567
    ndc_x = VB->Clip[v1][0] * wInv;
#line 38568
    ndc_y = VB->Clip[v1][1] * wInv;
#line 38569
    ndc_z = VB->Clip[v1][2] * wInv;
  } else {
#line 38572
    ndc_z = 0.0F;
#line 38572
    ndc_y = ndc_z;
#line 38572
    ndc_x = ndc_y;
  }
#line 38574
  VB->Win[v1][0] = ndc_x * ctx->Viewport.Sx + ctx->Viewport.Tx;
#line 38575
  VB->Win[v1][1] = ndc_y * ctx->Viewport.Sy + ctx->Viewport.Ty;
#line 38576
  VB->Win[v1][2] = ndc_z * ctx->Viewport.Sz + ctx->Viewport.Tz;
#line 38577
  if (VB->Clip[v2][3] != 0.0F) {
#line 38578
    wInv___0 = 1.0F / VB->Clip[v2][3];
#line 38579
    ndc_x = VB->Clip[v2][0] * wInv___0;
#line 38580
    ndc_y = VB->Clip[v2][1] * wInv___0;
#line 38581
    ndc_z = VB->Clip[v2][2] * wInv___0;
  } else {
#line 38584
    ndc_z = 0.0F;
#line 38584
    ndc_y = ndc_z;
#line 38584
    ndc_x = ndc_y;
  }
#line 38586
  VB->Win[v2][0] = ndc_x * ctx->Viewport.Sx + ctx->Viewport.Tx;
#line 38587
  VB->Win[v2][1] = ndc_y * ctx->Viewport.Sy + ctx->Viewport.Ty;
#line 38588
  VB->Win[v2][2] = ndc_z * ctx->Viewport.Sz + ctx->Viewport.Tz;
#line 38589
  if (ctx->Driver.RasterSetup) {
#line 38590
    (*(ctx->Driver.RasterSetup))(ctx, v1, v1 + 1U);
#line 38591
    (*(ctx->Driver.RasterSetup))(ctx, v2, v2 + 1U);
  }
#line 38594
  (*(ctx->Driver.LineFunc))(ctx, v1, v2, provoking_vertex);
#line 38596
  return;
}
}
#line 38597 "D:/a/test/177.c"
static void offset_polygon(GLcontext *ctx , float a , float b , float c ) 
{ float ac ;
  float bc ;
  float m ;
  float offset ;

  {
#line 38601
  if (c < 0.001F) {
#line 38601
    if (c > - 0.001F) {
#line 38602
      offset = 0.0F;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 38605
    ac = a / c;
#line 38606
    bc = b / c;
#line 38607
    if (ac < 0.0F) {
#line 38607
      ac = - ac;
    }
#line 38608
    if (bc < 0.0F) {
#line 38608
      bc = - bc;
    }
#line 38609
    if (ac > bc) {
#line 38609
      m = ac;
    } else {
#line 38609
      m = bc;
    }
#line 38610
    offset = m * ctx->Polygon.OffsetFactor + ctx->Polygon.OffsetUnits;
  }
#line 38612
  if (ctx->Polygon.OffsetPoint) {
#line 38612
    ctx->PointZoffset = offset;
  } else {
#line 38612
    ctx->PointZoffset = 0.0F;
  }
#line 38613
  if (ctx->Polygon.OffsetLine) {
#line 38613
    ctx->LineZoffset = offset;
  } else {
#line 38613
    ctx->LineZoffset = 0.0F;
  }
#line 38614
  if (ctx->Polygon.OffsetFill) {
#line 38614
    ctx->PolygonZoffset = offset;
  } else {
#line 38614
    ctx->PolygonZoffset = 0.0F;
  }
#line 38615
  return;
}
}
#line 38616 "D:/a/test/177.c"
static void unfilled_polygon(GLcontext *ctx , GLuint n , GLuint *vlist , GLuint pv ,
                             GLuint facing ) 
{ GLenum mode ;
  GLenum tmp___0 ;
  struct vertex_buffer *VB ;
  GLint i ;
  GLint j ;
  GLboolean edge ;
  GLuint i___0 ;
  GLuint j0___0 ;
  GLuint j1___0 ;
  GLboolean edge___0 ;
  GLuint j0___1 ;
  GLuint i___1 ;

  {
#line 38620
  if (facing) {
#line 38620
    tmp___0 = ctx->Polygon.BackMode;
  } else {
#line 38620
    tmp___0 = ctx->Polygon.FrontMode;
  }
#line 38620
  mode = tmp___0;
#line 38621
  VB = ctx->VB;
#line 38622
  if (mode == 6912) {
#line 38625
    if (ctx->Primitive == 4) {
#line 38628
      edge = (unsigned char)0;
    } else {
#line 38625
      if (ctx->Primitive == 7) {
#line 38628
        edge = (unsigned char)0;
      } else {
#line 38625
        if (ctx->Primitive == 9) {
#line 38628
          edge = (unsigned char)0;
        } else {
#line 38631
          edge = (unsigned char)1;
        }
      }
    }
#line 38633
    i = 0;
#line 38633
    while ((GLuint )i < n) {
#line 38634
      j = (int )*(vlist + i);
#line 38635
      if (edge) {
#line 38636
        (*(ctx->Driver.PointsFunc))(ctx, (unsigned int )j, (unsigned int )j);
      } else {
#line 38635
        if (VB->Edgeflag[j]) {
#line 38636
          (*(ctx->Driver.PointsFunc))(ctx, (unsigned int )j, (unsigned int )j);
        }
      }
#line 38633
      i ++;
    }
  } else {
#line 38640
    if (mode == 6913) {
#line 38643
      ctx->StippleCounter = 0U;
#line 38644
      if (ctx->Primitive == 4) {
#line 38647
        edge___0 = (unsigned char)0;
      } else {
#line 38644
        if (ctx->Primitive == 7) {
#line 38647
          edge___0 = (unsigned char)0;
        } else {
#line 38644
          if (ctx->Primitive == 9) {
#line 38647
            edge___0 = (unsigned char)0;
          } else {
#line 38650
            edge___0 = (unsigned char)1;
          }
        }
      }
#line 38652
      i___0 = 0U;
#line 38652
      while (i___0 < n) {
#line 38653
        if (i___0 == 0U) {
#line 38653
          j0___0 = *(vlist + (n - 1U));
        } else {
#line 38653
          j0___0 = *(vlist + (i___0 - 1U));
        }
#line 38654
        j1___0 = *(vlist + i___0);
#line 38655
        if (edge___0) {
#line 38657
          (*(ctx->Driver.LineFunc))(ctx, j0___0, j1___0, pv);
        } else {
#line 38655
          if (VB->Edgeflag[j0___0]) {
#line 38657
            (*(ctx->Driver.LineFunc))(ctx, j0___0, j1___0, pv);
          }
        }
#line 38652
        i___0 ++;
      }
    } else {
#line 38664
      j0___1 = *(vlist + 0);
#line 38665
      i___1 = 2U;
#line 38665
      while (i___1 < n) {
#line 38667
        (*(ctx->Driver.TriangleFunc))(ctx, j0___1, *(vlist + (i___1 - 1U)), *(vlist + i___1),
                                      pv);
#line 38665
        i___1 ++;
      }
    }
  }
#line 38671
  return;
}
}
#line 38672 "D:/a/test/177.c"
static float polygon_area(struct vertex_buffer  const  *vb , GLuint n , GLuint const   *vlist ) 
{ float area ;
  GLint i ;
  GLuint j0___0 ;
  GLuint j1___0 ;
  float x0 ;
  float y0___0 ;
  float x1 ;
  float y1___0 ;
  float trapArea ;

  {
#line 38675
  area = 0.0F;
#line 38677
  i = 0;
#line 38677
  while ((GLuint )i < n) {
#line 38678
    j0___0 = (GLuint )*(vlist + i);
#line 38679
    j1___0 = (GLuint )*(vlist + (unsigned int )(i + 1) % n);
#line 38680
    x0 = vb->Win[j0___0][0];
#line 38681
    y0___0 = vb->Win[j0___0][1];
#line 38682
    x1 = vb->Win[j1___0][0];
#line 38683
    y1___0 = vb->Win[j1___0][1];
#line 38684
    trapArea = (x0 - x1) * (y0___0 + y1___0);
#line 38685
    area += trapArea;
#line 38677
    i ++;
  }
#line 38687
  return (area * 0.5F);
}
}
#line 38689 "D:/a/test/177.c"
static void render_polygon(GLcontext *ctx , GLuint n , GLuint *vlist ) 
{ struct vertex_buffer *VB ;
  GLuint pv ;
  GLuint facing ;
  float area ;
  float tmp___0 ;
  GLuint j0___0 ;
  GLuint j1___0 ;
  GLuint j2 ;
  GLuint j3 ;
  int tmp___1 ;
  float ex ;
  float ey ;
  float ez ;
  float fx ;
  float fy ;
  float fz ;
  float a ;
  float b ;
  float c ;
  GLint i ;
  GLuint j0___1 ;

  {
#line 38691
  VB = ctx->VB;
#line 38693
  if (ctx->Primitive == 9) {
#line 38693
    pv = *(vlist + 0);
  } else {
#line 38693
    pv = *(vlist + (n - 1U));
  }
#line 38696
  tmp___0 = polygon_area((struct vertex_buffer  const  *)VB, n, (GLuint const   *)vlist);
#line 38696
  area = tmp___0;
#line 38697
  if (area == 0.0F) {
#line 38698
    return;
  }
#line 38700
  facing = (unsigned int )((area < 0.0F) ^ (ctx->Polygon.FrontFace == 2304));
#line 38701
  if ((facing + 1U) & ctx->Polygon.CullBits) {
#line 38702
    return;
  }
#line 38704
  if (ctx->Polygon.OffsetAny) {
#line 38705
    j0___0 = *(vlist + 0);
#line 38706
    j1___0 = *(vlist + 1);
#line 38707
    j2 = *(vlist + 2);
#line 38708
    if (n == 3U) {
#line 38708
      tmp___1 = 0;
    } else {
#line 38708
      tmp___1 = 3;
    }
#line 38708
    j3 = *(vlist + tmp___1);
#line 38709
    ex = VB->Win[j1___0][0] - VB->Win[j3][0];
#line 38710
    ey = VB->Win[j1___0][1] - VB->Win[j3][1];
#line 38711
    ez = VB->Win[j1___0][2] - VB->Win[j3][2];
#line 38712
    fx = VB->Win[j2][0] - VB->Win[j0___0][0];
#line 38713
    fy = VB->Win[j2][1] - VB->Win[j0___0][1];
#line 38714
    fz = VB->Win[j2][2] - VB->Win[j0___0][2];
#line 38715
    a = ey * fz - ez * fy;
#line 38716
    b = ez * fx - ex * fz;
#line 38717
    c = ex * fy - ey * fx;
#line 38718
    offset_polygon(ctx, a, b, c);
  }
#line 38720
  if (ctx->LightTwoSide) {
#line 38721
    if (facing == 1U) {
#line 38722
      VB->Color = VB->Bcolor;
#line 38723
      VB->Index = VB->Bindex;
    } else {
#line 38726
      VB->Color = VB->Fcolor;
#line 38727
      VB->Index = VB->Findex;
    }
  }
#line 38730
  if (ctx->Polygon.Unfilled) {
#line 38731
    unfilled_polygon(ctx, n, vlist, pv, facing);
  } else {
#line 38735
    j0___1 = *(vlist + 0);
#line 38736
    i = 2;
#line 38736
    while ((GLuint )i < n) {
#line 38738
      (*(ctx->Driver.TriangleFunc))(ctx, j0___1, *(vlist + (i - 1)), *(vlist + i),
                                    pv);
#line 38736
      i ++;
    }
  }
#line 38743
  return;
}
}
#line 38744 "D:/a/test/177.c"
static void render_clipped_polygon(GLcontext *ctx , GLuint n , GLuint *vlist ) 
{ GLuint pv ;
  struct vertex_buffer *VB ;
  float (*win)[3] ;
  float *proj ;
  GLuint i ;
  GLuint j ;
  float sx ;
  float tx ;
  float sy ;
  float ty ;
  float sz ;
  float tz ;
  GLuint i___0 ;
  GLuint j___0 ;
  float wInv ;
  float tmp___0 ;
  float tmp___1 ;
  GLuint facing ;
  float area ;
  float tmp___2 ;
  GLuint j0___0 ;
  GLuint j1___0 ;
  GLuint j2 ;
  GLuint j3 ;
  int tmp___3 ;
  float ex ;
  float ey ;
  float ez ;
  float fx ;
  float fy ;
  float fz ;
  float a ;
  float b ;
  float c ;
  GLint i___1 ;
  GLuint j0___1 ;

  {
#line 38747
  VB = ctx->VB;
#line 38748
  win = VB->Win;
#line 38749
  if (ctx->Primitive == 9) {
#line 38749
    pv = *(vlist + 0);
  } else {
#line 38749
    pv = *(vlist + (n - 1U));
  }
#line 38750
  VB->Free = 480U;
#line 38751
  if (ctx->Transform.AnyClip) {
#line 38752
    proj = ctx->ProjectionMatrix;
#line 38754
    n = gl_userclip_polygon(ctx, n, vlist);
#line 38755
    if (n < 3U) {
#line 38756
      return;
    }
#line 38757
    i = 0U;
#line 38757
    while (i < n) {
#line 38758
      j = *(vlist + i);
#line 38759
      TRANSFORM_POINT(VB->Clip[j], proj, VB->Eye[j]);
#line 38757
      i ++;
    }
  }
#line 38762
  n = gl_viewclip_polygon(ctx, n, vlist);
#line 38763
  if (n < 3U) {
#line 38764
    return;
  }
#line 38766
  sx = ctx->Viewport.Sx;
#line 38767
  tx = ctx->Viewport.Tx;
#line 38768
  sy = ctx->Viewport.Sy;
#line 38769
  ty = ctx->Viewport.Ty;
#line 38770
  sz = ctx->Viewport.Sz;
#line 38771
  tz = ctx->Viewport.Tz;
#line 38773
  i___0 = 0U;
#line 38773
  while (i___0 < n) {
#line 38774
    j___0 = *(vlist + i___0);
#line 38775
    if (VB->Clip[j___0][3] != 0.0F) {
#line 38776
      wInv = 1.0F / VB->Clip[j___0][3];
#line 38777
      (*(win + j___0))[0] = (VB->Clip[j___0][0] * wInv) * sx + tx;
#line 38778
      (*(win + j___0))[1] = (VB->Clip[j___0][1] * wInv) * sy + ty;
#line 38779
      (*(win + j___0))[2] = (VB->Clip[j___0][2] * wInv) * sz + tz;
    } else {
#line 38782
      tmp___1 = 0.0F;
#line 38782
      (*(win + j___0))[2] = tmp___1;
#line 38782
      tmp___0 = tmp___1;
#line 38782
      (*(win + j___0))[1] = tmp___0;
#line 38782
      (*(win + j___0))[0] = tmp___0;
    }
#line 38773
    i___0 ++;
  }
#line 38785
  if (ctx->Driver.RasterSetup) {
#line 38785
    if (VB->Free > 480U) {
#line 38786
      (*(ctx->Driver.RasterSetup))(ctx, 480U, VB->Free);
    }
  }
#line 38791
  tmp___2 = polygon_area((struct vertex_buffer  const  *)VB, n, (GLuint const   *)vlist);
#line 38791
  area = tmp___2;
#line 38792
  if (area == 0.0F) {
#line 38793
    return;
  }
#line 38795
  facing = (unsigned int )((area < 0.0F) ^ (ctx->Polygon.FrontFace == 2304));
#line 38796
  if ((facing + 1U) & ctx->Polygon.CullBits) {
#line 38797
    return;
  }
#line 38799
  if (ctx->Polygon.OffsetAny) {
#line 38800
    j0___0 = *(vlist + 0);
#line 38801
    j1___0 = *(vlist + 1);
#line 38802
    j2 = *(vlist + 2);
#line 38803
    if (n == 3U) {
#line 38803
      tmp___3 = 0;
    } else {
#line 38803
      tmp___3 = 3;
    }
#line 38803
    j3 = *(vlist + tmp___3);
#line 38804
    ex = (*(win + j1___0))[0] - (*(win + j3))[0];
#line 38805
    ey = (*(win + j1___0))[1] - (*(win + j3))[1];
#line 38806
    ez = (*(win + j1___0))[2] - (*(win + j3))[2];
#line 38807
    fx = (*(win + j2))[0] - (*(win + j0___0))[0];
#line 38808
    fy = (*(win + j2))[1] - (*(win + j0___0))[1];
#line 38809
    fz = (*(win + j2))[2] - (*(win + j0___0))[2];
#line 38810
    a = ey * fz - ez * fy;
#line 38811
    b = ez * fx - ex * fz;
#line 38812
    c = ex * fy - ey * fx;
#line 38813
    offset_polygon(ctx, a, b, c);
  }
#line 38815
  if (ctx->LightTwoSide) {
#line 38816
    if (facing == 1U) {
#line 38817
      VB->Color = VB->Bcolor;
#line 38818
      VB->Index = VB->Bindex;
    } else {
#line 38821
      VB->Color = VB->Fcolor;
#line 38822
      VB->Index = VB->Findex;
    }
  }
#line 38825
  if (ctx->Polygon.Unfilled) {
#line 38826
    unfilled_polygon(ctx, n, vlist, pv, facing);
  } else {
#line 38830
    j0___1 = *(vlist + 0);
#line 38831
    i___1 = 2;
#line 38831
    while ((GLuint )i___1 < n) {
#line 38833
      (*(ctx->Driver.TriangleFunc))(ctx, j0___1, *(vlist + (i___1 - 1)), *(vlist + i___1),
                                    pv);
#line 38831
      i___1 ++;
    }
  }
#line 38838
  return;
}
}
#line 38839 "D:/a/test/177.c"
static void render_triangle(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 , GLuint pv ) 
{ struct vertex_buffer *VB ;
  float ex ;
  float ey ;
  float fx ;
  float fy ;
  float c ;
  GLuint facing ;
  float (*win)[3] ;
  float fz ;
  float ez ;
  float a ;
  float b ;
  GLuint vlist[3] ;

  {
#line 38842
  VB = ctx->VB;
#line 38845
  win = VB->Win;
#line 38846
  ex = (*(win + v1))[0] - (*(win + v0))[0];
#line 38847
  ey = (*(win + v1))[1] - (*(win + v0))[1];
#line 38848
  fx = (*(win + v2))[0] - (*(win + v0))[0];
#line 38849
  fy = (*(win + v2))[1] - (*(win + v0))[1];
#line 38850
  c = ex * fy - ey * fx;
#line 38851
  if (c == 0.0F) {
#line 38852
    return;
  }
#line 38854
  facing = (unsigned int )((c < 0.0F) ^ (ctx->Polygon.FrontFace == 2304));
#line 38855
  if ((facing + 1U) & ctx->Polygon.CullBits) {
#line 38856
    return;
  }
#line 38858
  if (ctx->Polygon.OffsetAny) {
#line 38859
    fz = (*(win + v2))[2] - (*(win + v0))[2];
#line 38860
    ez = (*(win + v1))[2] - (*(win + v0))[2];
#line 38861
    a = ey * fz - ez * fy;
#line 38862
    b = ez * fx - ex * fz;
#line 38863
    offset_polygon(ctx, a, b, c);
  }
#line 38865
  if (ctx->LightTwoSide) {
#line 38866
    if (facing == 1U) {
#line 38867
      VB->Color = VB->Bcolor;
#line 38868
      VB->Index = VB->Bindex;
    } else {
#line 38871
      VB->Color = VB->Fcolor;
#line 38872
      VB->Index = VB->Findex;
    }
  }
#line 38875
  if (ctx->Polygon.Unfilled) {
#line 38877
    vlist[0] = v0;
#line 38878
    vlist[1] = v1;
#line 38879
    vlist[2] = v2;
#line 38880
    unfilled_polygon(ctx, 3U, vlist, pv, facing);
  } else {
#line 38884
    (*(ctx->Driver.TriangleFunc))(ctx, v0, v1, v2, pv);
  }
#line 38887
  return;
}
}
#line 38888 "D:/a/test/177.c"
static void render_quad(GLcontext *ctx , GLuint v0 , GLuint v1 , GLuint v2 , GLuint v3 ,
                        GLuint pv ) 
{ struct vertex_buffer *VB ;
  float ex ;
  float ey ;
  float fx ;
  float fy ;
  float c ;
  GLuint facing ;
  float (*win)[3] ;
  float ez ;
  float fz ;
  float a ;
  float b ;
  GLuint vlist[4] ;

  {
#line 38891
  VB = ctx->VB;
#line 38894
  win = VB->Win;
#line 38895
  ex = (*(win + v2))[0] - (*(win + v0))[0];
#line 38896
  ey = (*(win + v2))[1] - (*(win + v0))[1];
#line 38897
  fx = (*(win + v3))[0] - (*(win + v1))[0];
#line 38898
  fy = (*(win + v3))[1] - (*(win + v1))[1];
#line 38899
  c = ex * fy - ey * fx;
#line 38900
  if (c == 0.0F) {
#line 38901
    return;
  }
#line 38903
  facing = (unsigned int )((c < 0.0F) ^ (ctx->Polygon.FrontFace == 2304));
#line 38904
  if ((facing + 1U) & ctx->Polygon.CullBits) {
#line 38905
    return;
  }
#line 38907
  if (ctx->Polygon.OffsetAny) {
#line 38908
    ez = (*(win + v2))[2] - (*(win + v0))[2];
#line 38909
    fz = (*(win + v3))[2] - (*(win + v1))[2];
#line 38910
    a = ey * fz - ez * fy;
#line 38911
    b = ez * fx - ex * fz;
#line 38912
    offset_polygon(ctx, a, b, c);
  }
#line 38914
  if (ctx->LightTwoSide) {
#line 38915
    if (facing == 1U) {
#line 38916
      VB->Color = VB->Bcolor;
#line 38917
      VB->Index = VB->Bindex;
    } else {
#line 38920
      VB->Color = VB->Fcolor;
#line 38921
      VB->Index = VB->Findex;
    }
  }
#line 38924
  if (ctx->Polygon.Unfilled) {
#line 38926
    vlist[0] = v0;
#line 38927
    vlist[1] = v1;
#line 38928
    vlist[2] = v2;
#line 38929
    vlist[3] = v3;
#line 38930
    unfilled_polygon(ctx, 4U, vlist, pv, facing);
  } else {
#line 38934
    (*(ctx->Driver.QuadFunc))(ctx, v0, v1, v2, v3, pv);
  }
#line 38937
  return;
}
}
#line 38938 "D:/a/test/177.c"
static void copy_vertex(struct vertex_buffer *vb , GLuint dst , GLuint src ) 
{ 

  {
#line 38940
  vb->Clip[dst][0] = vb->Clip[src][0];
#line 38940
  vb->Clip[dst][1] = vb->Clip[src][1];
#line 38940
  vb->Clip[dst][2] = vb->Clip[src][2];
#line 38940
  vb->Clip[dst][3] = vb->Clip[src][3];
#line 38941
  vb->Eye[dst][0] = vb->Eye[src][0];
#line 38941
  vb->Eye[dst][1] = vb->Eye[src][1];
#line 38941
  vb->Eye[dst][2] = vb->Eye[src][2];
#line 38941
  vb->Eye[dst][3] = vb->Eye[src][3];
#line 38942
  vb->Win[dst][0] = vb->Win[src][0];
#line 38942
  vb->Win[dst][1] = vb->Win[src][1];
#line 38942
  vb->Win[dst][2] = vb->Win[src][2];
#line 38943
  vb->Fcolor[dst][0] = vb->Fcolor[src][0];
#line 38943
  vb->Fcolor[dst][1] = vb->Fcolor[src][1];
#line 38943
  vb->Fcolor[dst][2] = vb->Fcolor[src][2];
#line 38943
  vb->Fcolor[dst][3] = vb->Fcolor[src][3];
#line 38944
  vb->Bcolor[dst][0] = vb->Bcolor[src][0];
#line 38944
  vb->Bcolor[dst][1] = vb->Bcolor[src][1];
#line 38944
  vb->Bcolor[dst][2] = vb->Bcolor[src][2];
#line 38944
  vb->Bcolor[dst][3] = vb->Bcolor[src][3];
#line 38945
  vb->TexCoord[dst][0] = vb->TexCoord[src][0];
#line 38945
  vb->TexCoord[dst][1] = vb->TexCoord[src][1];
#line 38945
  vb->TexCoord[dst][2] = vb->TexCoord[src][2];
#line 38945
  vb->TexCoord[dst][3] = vb->TexCoord[src][3];
#line 38946
  vb->Findex[dst] = vb->Findex[src];
#line 38947
  vb->Bindex[dst] = vb->Bindex[src];
#line 38948
  vb->Edgeflag[dst] = vb->Edgeflag[src];
#line 38949
  vb->ClipMask[dst] = vb->ClipMask[src];
#line 38950
  return;
}
}
#line 39256
void gl_reset_vb(GLcontext *ctx , GLboolean allDone ) ;
#line 38951 "D:/a/test/177.c"
void gl_render_vb(GLcontext *ctx , GLboolean allDone ) 
{ struct vertex_buffer *VB ;
  GLuint vlist[504] ;
  GLuint i ;
  GLuint i___0 ;
  GLuint i___1 ;
  GLuint i___2 ;
  GLuint i___3 ;
  GLuint i___4 ;
  GLuint i___5 ;
  GLuint i___6 ;
  GLuint i___7 ;
  GLuint i___8 ;
  GLuint i___9 ;
  GLuint i___10 ;
  GLuint i___11 ;
  GLuint i___12 ;
  GLuint i___13 ;
  GLuint i___14 ;

  {
#line 38953
  VB = ctx->VB;
#line 38955
  switch (ctx->Primitive) {
  case 0: 
#line 38958
  (*(ctx->Driver.PointsFunc))(ctx, 0U, VB->Count - 1U);
#line 38960
  break;
  case 1: 
#line 38962
  if (VB->ClipOrMask) {
#line 38964
    i = 1U;
#line 38964
    while (i < VB->Count) {
#line 38965
      if ((int )VB->ClipMask[i - 1U] | (int )VB->ClipMask[i]) {
#line 38966
        render_clipped_line(ctx, i - 1U, i);
      } else {
#line 38970
        (*(ctx->Driver.LineFunc))(ctx, i - 1U, i, i);
      }
#line 38973
      ctx->StippleCounter = 0U;
#line 38964
      i += 2U;
    }
  } else {
#line 38978
    i___0 = 1U;
#line 38978
    while (i___0 < VB->Count) {
#line 38980
      (*(ctx->Driver.LineFunc))(ctx, i___0 - 1U, i___0, i___0);
#line 38982
      ctx->StippleCounter = 0U;
#line 38978
      i___0 += 2U;
    }
  }
#line 38985
  break;
  case 3: 
#line 38987
  if (VB->ClipOrMask) {
#line 38989
    i___1 = 1U;
#line 38989
    while (i___1 < VB->Count) {
#line 38990
      if ((int )VB->ClipMask[i___1 - 1U] | (int )VB->ClipMask[i___1]) {
#line 38991
        render_clipped_line(ctx, i___1 - 1U, i___1);
      } else {
#line 38995
        (*(ctx->Driver.LineFunc))(ctx, i___1 - 1U, i___1, i___1);
      }
#line 38989
      i___1 ++;
    }
  } else {
#line 39002
    i___2 = 1U;
#line 39002
    while (i___2 < VB->Count) {
#line 39004
      (*(ctx->Driver.LineFunc))(ctx, i___2 - 1U, i___2, i___2);
#line 39002
      i___2 ++;
    }
  }
#line 39008
  break;
  case 2: 
#line 39012
  if (VB->Start == 0U) {
#line 39013
    i___3 = 1U;
  } else {
#line 39016
    i___3 = 2U;
  }
#line 39018
  while (i___3 < VB->Count) {
#line 39019
    if ((int )VB->ClipMask[i___3 - 1U] | (int )VB->ClipMask[i___3]) {
#line 39020
      render_clipped_line(ctx, i___3 - 1U, i___3);
    } else {
#line 39024
      (*(ctx->Driver.LineFunc))(ctx, i___3 - 1U, i___3, i___3);
    }
#line 39027
    i___3 ++;
  }
#line 39030
  break;
  case 4: 
#line 39032
  if (VB->ClipOrMask) {
#line 39034
    i___4 = 2U;
#line 39034
    while (i___4 < VB->Count) {
#line 39035
      if (((int )VB->ClipMask[i___4 - 2U] | (int )VB->ClipMask[i___4 - 1U]) | (int )VB->ClipMask[i___4]) {
#line 39036
        vlist[0] = i___4 - 2U;
#line 39037
        vlist[1] = i___4 - 1U;
#line 39038
        vlist[2] = i___4 - 0U;
#line 39039
        render_clipped_polygon(ctx, 3U, vlist);
      } else {
#line 39042
        if (ctx->DirectTriangles) {
#line 39044
          (*(ctx->Driver.TriangleFunc))(ctx, i___4 - 2U, i___4 - 1U, i___4, i___4);
        } else {
#line 39048
          render_triangle(ctx, i___4 - 2U, i___4 - 1U, i___4, i___4);
        }
      }
#line 39034
      i___4 += 3U;
    }
  } else {
#line 39055
    if (ctx->DirectTriangles) {
#line 39056
      i___5 = 2U;
#line 39056
      while (i___5 < VB->Count) {
#line 39058
        (*(ctx->Driver.TriangleFunc))(ctx, i___5 - 2U, i___5 - 1U, i___5, i___5);
#line 39056
        i___5 += 3U;
      }
    } else {
#line 39063
      i___5 = 2U;
#line 39063
      while (i___5 < VB->Count) {
#line 39064
        render_triangle(ctx, i___5 - 2U, i___5 - 1U, i___5, i___5);
#line 39063
        i___5 += 3U;
      }
    }
  }
#line 39068
  break;
  case 5: 
#line 39070
  if (VB->ClipOrMask) {
#line 39072
    i___6 = 2U;
#line 39072
    while (i___6 < VB->Count) {
#line 39073
      if (((int )VB->ClipMask[i___6 - 2U] | (int )VB->ClipMask[i___6 - 1U]) | (int )VB->ClipMask[i___6]) {
#line 39074
        if (i___6 & 1U) {
#line 39075
          vlist[0] = i___6 - 1U;
#line 39076
          vlist[1] = i___6 - 2U;
#line 39077
          vlist[2] = i___6 - 0U;
#line 39078
          render_clipped_polygon(ctx, 3U, vlist);
        } else {
#line 39081
          vlist[0] = i___6 - 2U;
#line 39082
          vlist[1] = i___6 - 1U;
#line 39083
          vlist[2] = i___6 - 0U;
#line 39084
          render_clipped_polygon(ctx, 3U, vlist);
        }
      } else {
#line 39088
        if (ctx->DirectTriangles) {
#line 39090
          (*(ctx->Driver.TriangleFunc))(ctx, i___6 - 2U, i___6 - 1U, i___6, i___6);
        } else {
#line 39094
          if (i___6 & 1U) {
#line 39095
            render_triangle(ctx, i___6, i___6 - 1U, i___6 - 2U, i___6);
          } else {
#line 39097
            render_triangle(ctx, i___6 - 2U, i___6 - 1U, i___6, i___6);
          }
        }
      }
#line 39072
      i___6 ++;
    }
  } else {
#line 39104
    if (ctx->DirectTriangles) {
#line 39105
      i___7 = 2U;
#line 39105
      while (i___7 < VB->Count) {
#line 39107
        (*(ctx->Driver.TriangleFunc))(ctx, i___7 - 2U, i___7 - 1U, i___7, i___7);
#line 39105
        i___7 ++;
      }
    } else {
#line 39112
      i___7 = 2U;
#line 39112
      while (i___7 < VB->Count) {
#line 39113
        if (i___7 & 1U) {
#line 39114
          render_triangle(ctx, i___7, i___7 - 1U, i___7 - 2U, i___7);
        } else {
#line 39116
          render_triangle(ctx, i___7 - 2U, i___7 - 1U, i___7, i___7);
        }
#line 39112
        i___7 ++;
      }
    }
  }
#line 39120
  break;
  case 6: 
#line 39122
  if (VB->ClipOrMask) {
#line 39124
    i___8 = 2U;
#line 39124
    while (i___8 < VB->Count) {
#line 39125
      if (((int )VB->ClipMask[0] | (int )VB->ClipMask[i___8 - 1U]) | (int )VB->ClipMask[i___8]) {
#line 39126
        vlist[0] = 0U;
#line 39127
        vlist[1] = i___8 - 1U;
#line 39128
        vlist[2] = i___8;
#line 39129
        render_clipped_polygon(ctx, 3U, vlist);
      } else {
#line 39132
        if (ctx->DirectTriangles) {
#line 39134
          (*(ctx->Driver.TriangleFunc))(ctx, 0U, i___8 - 1U, i___8, i___8);
        } else {
#line 39138
          render_triangle(ctx, 0U, i___8 - 1U, i___8, i___8);
        }
      }
#line 39124
      i___8 ++;
    }
  } else {
#line 39145
    if (ctx->DirectTriangles) {
#line 39146
      i___9 = 2U;
#line 39146
      while (i___9 < VB->Count) {
#line 39148
        (*(ctx->Driver.TriangleFunc))(ctx, 0U, i___9 - 1U, i___9, i___9);
#line 39146
        i___9 ++;
      }
    } else {
#line 39153
      i___9 = 2U;
#line 39153
      while (i___9 < VB->Count) {
#line 39154
        render_triangle(ctx, 0U, i___9 - 1U, i___9, i___9);
#line 39153
        i___9 ++;
      }
    }
  }
#line 39158
  break;
  case 7: 
#line 39160
  if (VB->ClipOrMask) {
#line 39162
    i___10 = 3U;
#line 39162
    while (i___10 < VB->Count) {
#line 39163
      if ((((int )VB->ClipMask[i___10 - 3U] | (int )VB->ClipMask[i___10 - 2U]) | (int )VB->ClipMask[i___10 - 1U]) | (int )VB->ClipMask[i___10]) {
#line 39165
        vlist[0] = i___10 - 3U;
#line 39166
        vlist[1] = i___10 - 2U;
#line 39167
        vlist[2] = i___10 - 1U;
#line 39168
        vlist[3] = i___10 - 0U;
#line 39169
        render_clipped_polygon(ctx, 4U, vlist);
      } else {
#line 39172
        if (ctx->DirectTriangles) {
#line 39174
          (*(ctx->Driver.QuadFunc))(ctx, i___10 - 3U, i___10 - 2U, i___10 - 1U, i___10,
                                    i___10);
        } else {
#line 39178
          render_quad(ctx, i___10 - 3U, i___10 - 2U, i___10 - 1U, i___10, i___10);
        }
      }
#line 39162
      i___10 += 4U;
    }
  } else {
#line 39185
    if (ctx->DirectTriangles) {
#line 39186
      i___11 = 3U;
#line 39186
      while (i___11 < VB->Count) {
#line 39188
        (*(ctx->Driver.QuadFunc))(ctx, i___11 - 3U, i___11 - 2U, i___11 - 1U, i___11,
                                  i___11);
#line 39186
        i___11 += 4U;
      }
    } else {
#line 39193
      i___11 = 3U;
#line 39193
      while (i___11 < VB->Count) {
#line 39194
        render_quad(ctx, i___11 - 3U, i___11 - 2U, i___11 - 1U, i___11, i___11);
#line 39193
        i___11 += 4U;
      }
    }
  }
#line 39198
  break;
  case 8: 
#line 39200
  if (VB->ClipOrMask) {
#line 39202
    i___12 = 3U;
#line 39202
    while (i___12 < VB->Count) {
#line 39203
      if ((((int )VB->ClipMask[i___12 - 2U] | (int )VB->ClipMask[i___12 - 3U]) | (int )VB->ClipMask[i___12 - 1U]) | (int )VB->ClipMask[i___12]) {
#line 39205
        vlist[0] = i___12 - 1U;
#line 39206
        vlist[1] = i___12 - 3U;
#line 39207
        vlist[2] = i___12 - 2U;
#line 39208
        vlist[3] = i___12 - 0U;
#line 39209
        render_clipped_polygon(ctx, 4U, vlist);
      } else {
#line 39212
        if (ctx->DirectTriangles) {
#line 39214
          (*(ctx->Driver.QuadFunc))(ctx, i___12 - 3U, i___12 - 2U, i___12, i___12 - 1U,
                                    i___12);
        } else {
#line 39218
          render_quad(ctx, i___12 - 3U, i___12 - 2U, i___12, i___12 - 1U, i___12);
        }
      }
#line 39202
      i___12 += 2U;
    }
  } else {
#line 39225
    if (ctx->DirectTriangles) {
#line 39226
      i___13 = 3U;
#line 39226
      while (i___13 < VB->Count) {
#line 39228
        (*(ctx->Driver.QuadFunc))(ctx, i___13 - 3U, i___13 - 2U, i___13, i___13 - 1U,
                                  i___13);
#line 39226
        i___13 += 2U;
      }
    } else {
#line 39233
      i___13 = 3U;
#line 39233
      while (i___13 < VB->Count) {
#line 39234
        render_quad(ctx, i___13 - 3U, i___13 - 2U, i___13, i___13 - 1U, i___13);
#line 39233
        i___13 += 2U;
      }
    }
  }
#line 39238
  break;
  case 9: 
#line 39240
  if (VB->Count > 2U) {
#line 39242
    i___14 = 0U;
#line 39242
    while (i___14 < VB->Count) {
#line 39243
      vlist[i___14] = i___14;
#line 39242
      i___14 ++;
    }
#line 39245
    if (VB->ClipOrMask) {
#line 39246
      render_clipped_polygon(ctx, VB->Count, vlist);
    } else {
#line 39249
      render_polygon(ctx, VB->Count, vlist);
    }
  }
#line 39252
  break;
  default: 
#line 39254
  gl_problem((GLcontext const   *)ctx, "invalid mode in gl_render_vb");
  }
#line 39256
  gl_reset_vb(ctx, allDone);
#line 39257
  return;
}
}
#line 39259 "D:/a/test/177.c"
void gl_reset_vb(GLcontext *ctx , GLboolean allDone ) 
{ struct vertex_buffer *VB ;
  GLint i ;
  GLint n ;
  float (*obj)[4] ;
  GLint i___0 ;
  GLint n___0 ;

  {
#line 39261
  VB = ctx->VB;
#line 39262
  if (ctx->Primitive == 2) {
#line 39262
    if (allDone) {
#line 39263
      if ((int )VB->ClipMask[VB->Count - 1U] | (int )VB->ClipMask[0]) {
#line 39264
        render_clipped_line(ctx, VB->Count - 1U, 0U);
      } else {
#line 39268
        (*(ctx->Driver.LineFunc))(ctx, VB->Count - 1U, 0U, 0U);
      }
    }
  }
#line 39272
  if (VB->ClipOrMask) {
#line 39273
    memset((void *)(VB->ClipMask + VB->Start), 0, (VB->Count - VB->Start) * sizeof(VB->ClipMask[0]));
  }
#line 39276
  if (! VB->MonoMaterial) {
#line 39277
    memset((void *)(VB->MaterialMask + VB->Start), 0, (VB->Count - VB->Start) * sizeof(VB->MaterialMask[0]));
  }
#line 39280
  if (VB->VertexSizeMask != 2U) {
#line 39282
    obj = VB->Obj + VB->Start;
#line 39283
    n = (int )(VB->Count - VB->Start);
#line 39284
    i = 0;
#line 39284
    while (i < n) {
#line 39285
      (*(obj + i))[3] = 1.0F;
#line 39284
      i ++;
    }
  }
#line 39288
  if (allDone) {
#line 39289
    VB->MonoColor = (unsigned char)1;
#line 39290
    VB->VertexSizeMask = 2U;
#line 39291
    if (VB->TexCoordSize != 2U) {
#line 39292
      n___0 = (GLint )VB->Count;
#line 39293
      i___0 = 0;
#line 39293
      while (i___0 < n___0) {
#line 39294
        VB->TexCoord[i___0][2] = 0.0F;
#line 39295
        VB->TexCoord[i___0][3] = 1.0F;
#line 39293
        i___0 ++;
      }
    }
#line 39298
    if (ctx->Current.TexCoord[2] == 0.0F) {
#line 39298
      if (ctx->Current.TexCoord[3] == 1.0F) {
#line 39299
        VB->TexCoordSize = 2U;
      } else {
#line 39302
        VB->TexCoordSize = 4U;
      }
    } else {
#line 39302
      VB->TexCoordSize = 4U;
    }
  }
#line 39305
  switch (ctx->Primitive) {
  case 0: 
#line 39308
  VB->Count = 0U;
#line 39309
  VB->ClipOrMask = (unsigned char)0;
#line 39310
  VB->ClipAndMask = (unsigned char)63;
#line 39311
  VB->MonoMaterial = (unsigned char)1;
#line 39312
  VB->MonoNormal = (unsigned char)1;
#line 39313
  break;
  case 1: 
#line 39316
  VB->Count = 0U;
#line 39317
  VB->ClipOrMask = (unsigned char)0;
#line 39318
  VB->ClipAndMask = (unsigned char)63;
#line 39319
  VB->MonoMaterial = (unsigned char)1;
#line 39320
  VB->MonoNormal = (unsigned char)1;
#line 39321
  break;
  case 3: 
#line 39323
  if (allDone) {
#line 39324
    VB->Count = 0U;
#line 39325
    VB->ClipOrMask = (unsigned char)0;
#line 39326
    VB->ClipAndMask = (unsigned char)63;
#line 39327
    VB->MonoMaterial = (unsigned char)1;
#line 39328
    VB->MonoNormal = (unsigned char)1;
  } else {
#line 39331
    copy_vertex(VB, 0U, VB->Count - 1U);
#line 39332
    VB->Count = 1U;
#line 39333
    VB->ClipOrMask = VB->ClipMask[0];
#line 39334
    VB->ClipAndMask = VB->ClipMask[0];
#line 39335
    if (VB->MaterialMask[0]) {
#line 39335
      VB->MonoMaterial = (unsigned char)0;
    } else {
#line 39335
      VB->MonoMaterial = (unsigned char)1;
    }
  }
#line 39337
  break;
  case 2: 
#line 39339
  if (allDone) {
#line 39340
    VB->Count = 0U;
#line 39341
    VB->ClipOrMask = (unsigned char)0;
#line 39342
    VB->ClipAndMask = (unsigned char)63;
#line 39343
    VB->MonoMaterial = (unsigned char)1;
#line 39344
    VB->MonoNormal = (unsigned char)1;
  } else {
#line 39349
    copy_vertex(VB, 1U, 479U);
#line 39350
    VB->Count = 2U;
#line 39351
    VB->ClipOrMask = (unsigned char )((int )VB->ClipMask[0] | (int )VB->ClipMask[1]);
#line 39352
    VB->ClipAndMask = (unsigned char )((int )VB->ClipMask[0] & (int )VB->ClipMask[1]);
#line 39353
    VB->MonoMaterial = (unsigned char )(! (VB->MaterialMask[0] | VB->MaterialMask[1]));
  }
#line 39355
  break;
  case 4: 
#line 39358
  VB->Count = 0U;
#line 39359
  VB->ClipOrMask = (unsigned char)0;
#line 39360
  VB->ClipAndMask = (unsigned char)63;
#line 39361
  VB->MonoMaterial = (unsigned char)1;
#line 39362
  VB->MonoNormal = (unsigned char)1;
#line 39363
  break;
  case 5: 
#line 39365
  if (allDone) {
#line 39366
    VB->Count = 0U;
#line 39367
    VB->ClipOrMask = (unsigned char)0;
#line 39368
    VB->ClipAndMask = (unsigned char)63;
#line 39369
    VB->MonoMaterial = (unsigned char)1;
#line 39370
    VB->MonoNormal = (unsigned char)1;
  } else {
#line 39373
    copy_vertex(VB, 0U, 478U);
#line 39374
    copy_vertex(VB, 1U, 479U);
#line 39375
    VB->Count = 2U;
#line 39376
    VB->ClipOrMask = (unsigned char )((int )VB->ClipMask[0] | (int )VB->ClipMask[1]);
#line 39377
    VB->ClipAndMask = (unsigned char )((int )VB->ClipMask[0] & (int )VB->ClipMask[1]);
#line 39378
    VB->MonoMaterial = (unsigned char )(! (VB->MaterialMask[0] | VB->MaterialMask[1]));
  }
#line 39380
  break;
  case 6: 
#line 39382
  if (allDone) {
#line 39383
    VB->Count = 0U;
#line 39384
    VB->ClipOrMask = (unsigned char)0;
#line 39385
    VB->ClipAndMask = (unsigned char)63;
#line 39386
    VB->MonoMaterial = (unsigned char)1;
#line 39387
    VB->MonoNormal = (unsigned char)1;
  } else {
#line 39390
    copy_vertex(VB, 1U, 479U);
#line 39391
    VB->Count = 2U;
#line 39392
    VB->ClipOrMask = (unsigned char )((int )VB->ClipMask[0] | (int )VB->ClipMask[1]);
#line 39393
    VB->ClipAndMask = (unsigned char )((int )VB->ClipMask[0] & (int )VB->ClipMask[1]);
#line 39394
    VB->MonoMaterial = (unsigned char )(! (VB->MaterialMask[0] | VB->MaterialMask[1]));
  }
#line 39396
  break;
  case 7: 
#line 39399
  VB->Count = 0U;
#line 39400
  VB->ClipOrMask = (unsigned char)0;
#line 39401
  VB->ClipAndMask = (unsigned char)63;
#line 39402
  VB->MonoMaterial = (unsigned char)1;
#line 39403
  VB->MonoNormal = (unsigned char)1;
#line 39404
  break;
  case 8: 
#line 39406
  if (allDone) {
#line 39407
    VB->Count = 0U;
#line 39408
    VB->ClipOrMask = (unsigned char)0;
#line 39409
    VB->ClipAndMask = (unsigned char)63;
#line 39410
    VB->MonoMaterial = (unsigned char)1;
#line 39411
    VB->MonoNormal = (unsigned char)1;
  } else {
#line 39414
    copy_vertex(VB, 0U, 478U);
#line 39415
    copy_vertex(VB, 1U, 479U);
#line 39416
    VB->Count = 2U;
#line 39417
    VB->ClipOrMask = (unsigned char )((int )VB->ClipMask[0] | (int )VB->ClipMask[1]);
#line 39418
    VB->ClipAndMask = (unsigned char )((int )VB->ClipMask[0] & (int )VB->ClipMask[1]);
#line 39419
    VB->MonoMaterial = (unsigned char )(! (VB->MaterialMask[0] | VB->MaterialMask[1]));
  }
#line 39421
  break;
  case 9: 
#line 39423
  if (allDone) {
#line 39424
    VB->Count = 0U;
#line 39425
    VB->ClipOrMask = (unsigned char)0;
#line 39426
    VB->ClipAndMask = (unsigned char)63;
#line 39427
    VB->MonoMaterial = (unsigned char)1;
#line 39428
    VB->MonoNormal = (unsigned char)1;
  } else {
#line 39431
    copy_vertex(VB, 1U, 479U);
#line 39432
    VB->Count = 2U;
#line 39433
    VB->ClipOrMask = (unsigned char )((int )VB->ClipMask[0] | (int )VB->ClipMask[1]);
#line 39434
    VB->ClipAndMask = (unsigned char )((int )VB->ClipMask[0] & (int )VB->ClipMask[1]);
#line 39435
    VB->MonoMaterial = (unsigned char )(! (VB->MaterialMask[0] | VB->MaterialMask[1]));
  }
#line 39437
  break;
  default: 
#line 39439
  gl_problem((GLcontext const   *)ctx, "invalid mode in gl_reset_vb");
  }
#line 39441
  VB->Start = VB->Count;
#line 39442
  return;
}
}
#line 39533 "D:/a/test/177.c"
static void transform_points3(GLcontext *ctx , GLuint n , float (*vObj)[4] , float (*vEye)[4] ) 
{ float const   *m ;
  float m0 ;
  float m4 ;
  float m8 ;
  float m12 ;
  float m1 ;
  float m5 ;
  float m9 ;
  float m13 ;
  float m2 ;
  float m6 ;
  float m10 ;
  float m14 ;
  float m3 ;
  float m7 ;
  float m11 ;
  float m15 ;
  GLuint i ;
  float ox ;
  float oy ;
  float oz ;
  GLuint i___0 ;
  float const   *m___0 ;
  float m0___0 ;
  float m1___0 ;
  float m4___0 ;
  float m5___0 ;
  float m12___0 ;
  float m13___0 ;
  GLuint i___1 ;
  float ox___0 ;
  float oy___0 ;
  float oz___0 ;
  float const   *m___1 ;
  float m0___1 ;
  float m5___1 ;
  float m12___1 ;
  float m13___1 ;
  GLuint i___2 ;
  float ox___1 ;
  float oy___1 ;
  float oz___1 ;
  float const   *m___2 ;
  float m0___2 ;
  float m1___1 ;
  float m2___0 ;
  float m4___1 ;
  float m5___2 ;
  float m6___0 ;
  float m8___0 ;
  float m9___0 ;
  float m10___0 ;
  float m12___2 ;
  float m13___2 ;
  float m14___0 ;
  GLuint i___3 ;
  float ox___2 ;
  float oy___2 ;
  float oz___2 ;

  {
#line 39538
  switch ((int )ctx->ModelViewMatrixType) {
  case 0: 
#line 39541
  m = (float const   *)(ctx->ModelViewMatrix);
#line 39542
  m0 = (float )*(m + 0);
#line 39542
  m4 = (float )*(m + 4);
#line 39542
  m8 = (float )*(m + 8);
#line 39542
  m12 = (float )*(m + 12);
#line 39543
  m1 = (float )*(m + 1);
#line 39543
  m5 = (float )*(m + 5);
#line 39543
  m9 = (float )*(m + 9);
#line 39543
  m13 = (float )*(m + 13);
#line 39544
  m2 = (float )*(m + 2);
#line 39544
  m6 = (float )*(m + 6);
#line 39544
  m10 = (float )*(m + 10);
#line 39544
  m14 = (float )*(m + 14);
#line 39545
  m3 = (float )*(m + 3);
#line 39545
  m7 = (float )*(m + 7);
#line 39545
  m11 = (float )*(m + 11);
#line 39545
  m15 = (float )*(m + 15);
#line 39547
  i = 0U;
#line 39547
  while (i < n) {
#line 39548
    ox = (*(vObj + i))[0];
#line 39548
    oy = (*(vObj + i))[1];
#line 39548
    oz = (*(vObj + i))[2];
#line 39549
    (*(vEye + i))[0] = ((m0 * ox + m4 * oy) + m8 * oz) + m12;
#line 39550
    (*(vEye + i))[1] = ((m1 * ox + m5 * oy) + m9 * oz) + m13;
#line 39551
    (*(vEye + i))[2] = ((m2 * ox + m6 * oy) + m10 * oz) + m14;
#line 39552
    (*(vEye + i))[3] = ((m3 * ox + m7 * oy) + m11 * oz) + m15;
#line 39547
    i ++;
  }
#line 39555
  break;
  case 1: 
#line 39559
  i___0 = 0U;
#line 39559
  while (i___0 < n) {
#line 39560
    (*(vEye + i___0))[0] = (*(vObj + i___0))[0];
#line 39561
    (*(vEye + i___0))[1] = (*(vObj + i___0))[1];
#line 39562
    (*(vEye + i___0))[2] = (*(vObj + i___0))[2];
#line 39563
    (*(vEye + i___0))[3] = 1.0F;
#line 39559
    i___0 ++;
  }
#line 39566
  break;
  case 4: 
#line 39569
  m___0 = (float const   *)(ctx->ModelViewMatrix);
#line 39570
  m0___0 = (float )*(m___0 + 0);
#line 39570
  m1___0 = (float )*(m___0 + 1);
#line 39570
  m4___0 = (float )*(m___0 + 4);
#line 39570
  m5___0 = (float )*(m___0 + 5);
#line 39571
  m12___0 = (float )*(m___0 + 12);
#line 39571
  m13___0 = (float )*(m___0 + 13);
#line 39573
  i___1 = 0U;
#line 39573
  while (i___1 < n) {
#line 39574
    ox___0 = (*(vObj + i___1))[0];
#line 39574
    oy___0 = (*(vObj + i___1))[1];
#line 39574
    oz___0 = (*(vObj + i___1))[2];
#line 39575
    (*(vEye + i___1))[0] = (m0___0 * ox___0 + m4___0 * oy___0) + m12___0;
#line 39576
    (*(vEye + i___1))[1] = (m1___0 * ox___0 + m5___0 * oy___0) + m13___0;
#line 39577
    (*(vEye + i___1))[2] = oz___0;
#line 39578
    (*(vEye + i___1))[3] = 1.0F;
#line 39573
    i___1 ++;
  }
#line 39581
  break;
  case 5: 
#line 39584
  m___1 = (float const   *)(ctx->ModelViewMatrix);
#line 39585
  m0___1 = (float )*(m___1 + 0);
#line 39585
  m5___1 = (float )*(m___1 + 5);
#line 39585
  m12___1 = (float )*(m___1 + 12);
#line 39585
  m13___1 = (float )*(m___1 + 13);
#line 39587
  i___2 = 0U;
#line 39587
  while (i___2 < n) {
#line 39588
    ox___1 = (*(vObj + i___2))[0];
#line 39588
    oy___1 = (*(vObj + i___2))[1];
#line 39588
    oz___1 = (*(vObj + i___2))[2];
#line 39589
    (*(vEye + i___2))[0] = m0___1 * ox___1 + m12___1;
#line 39590
    (*(vEye + i___2))[1] = m5___1 * oy___1 + m13___1;
#line 39591
    (*(vEye + i___2))[2] = oz___1;
#line 39592
    (*(vEye + i___2))[3] = 1.0F;
#line 39587
    i___2 ++;
  }
#line 39595
  break;
  case 6: 
#line 39598
  m___2 = (float const   *)(ctx->ModelViewMatrix);
#line 39599
  m0___2 = (float )*(m___2 + 0);
#line 39599
  m1___1 = (float )*(m___2 + 1);
#line 39599
  m2___0 = (float )*(m___2 + 2);
#line 39599
  m4___1 = (float )*(m___2 + 4);
#line 39599
  m5___2 = (float )*(m___2 + 5);
#line 39600
  m6___0 = (float )*(m___2 + 6);
#line 39600
  m8___0 = (float )*(m___2 + 8);
#line 39600
  m9___0 = (float )*(m___2 + 9);
#line 39600
  m10___0 = (float )*(m___2 + 10);
#line 39601
  m12___2 = (float )*(m___2 + 12);
#line 39601
  m13___2 = (float )*(m___2 + 13);
#line 39601
  m14___0 = (float )*(m___2 + 14);
#line 39603
  i___3 = 0U;
#line 39603
  while (i___3 < n) {
#line 39604
    ox___2 = (*(vObj + i___3))[0];
#line 39604
    oy___2 = (*(vObj + i___3))[1];
#line 39604
    oz___2 = (*(vObj + i___3))[2];
#line 39605
    (*(vEye + i___3))[0] = ((m0___2 * ox___2 + m4___1 * oy___2) + m8___0 * oz___2) + m12___2;
#line 39606
    (*(vEye + i___3))[1] = ((m1___1 * ox___2 + m5___2 * oy___2) + m9___0 * oz___2) + m13___2;
#line 39607
    (*(vEye + i___3))[2] = ((m2___0 * ox___2 + m6___0 * oy___2) + m10___0 * oz___2) + m14___0;
#line 39608
    (*(vEye + i___3))[3] = 1.0F;
#line 39603
    i___3 ++;
  }
#line 39611
  break;
  default: 
#line 39613
  gl_problem((GLcontext const   *)((void *)0), "invalid matrix type in transform_points3()");
  }
#line 39639
  return;
}
}
#line 39640 "D:/a/test/177.c"
static void transform_points4(GLcontext *ctx , GLuint n , float (*vObj)[4] , float (*vEye)[4] ) 
{ float const   *m ;
  float m0 ;
  float m4 ;
  float m8 ;
  float m12 ;
  float m1 ;
  float m5 ;
  float m9 ;
  float m13 ;
  float m2 ;
  float m6 ;
  float m10 ;
  float m14 ;
  float m3 ;
  float m7 ;
  float m11 ;
  float m15 ;
  GLuint i ;
  float ox ;
  float oy ;
  float oz ;
  float ow ;
  GLuint i___0 ;
  float const   *m___0 ;
  float m0___0 ;
  float m1___0 ;
  float m4___0 ;
  float m5___0 ;
  float m12___0 ;
  float m13___0 ;
  GLuint i___1 ;
  float ox___0 ;
  float oy___0 ;
  float oz___0 ;
  float ow___0 ;
  float const   *m___1 ;
  float m0___1 ;
  float m5___1 ;
  float m12___1 ;
  float m13___1 ;
  GLuint i___2 ;
  float ox___1 ;
  float oy___1 ;
  float oz___1 ;
  float ow___1 ;
  float const   *m___2 ;
  float m0___2 ;
  float m1___1 ;
  float m2___0 ;
  float m4___1 ;
  float m5___2 ;
  float m6___0 ;
  float m8___0 ;
  float m9___0 ;
  float m10___0 ;
  float m12___2 ;
  float m13___2 ;
  float m14___0 ;
  GLuint i___3 ;
  float ox___2 ;
  float oy___2 ;
  float oz___2 ;
  float ow___2 ;

  {
#line 39645
  switch ((int )ctx->ModelViewMatrixType) {
  case 0: 
#line 39648
  m = (float const   *)(ctx->ModelViewMatrix);
#line 39649
  m0 = (float )*(m + 0);
#line 39649
  m4 = (float )*(m + 4);
#line 39649
  m8 = (float )*(m + 8);
#line 39649
  m12 = (float )*(m + 12);
#line 39650
  m1 = (float )*(m + 1);
#line 39650
  m5 = (float )*(m + 5);
#line 39650
  m9 = (float )*(m + 9);
#line 39650
  m13 = (float )*(m + 13);
#line 39651
  m2 = (float )*(m + 2);
#line 39651
  m6 = (float )*(m + 6);
#line 39651
  m10 = (float )*(m + 10);
#line 39651
  m14 = (float )*(m + 14);
#line 39652
  m3 = (float )*(m + 3);
#line 39652
  m7 = (float )*(m + 7);
#line 39652
  m11 = (float )*(m + 11);
#line 39652
  m15 = (float )*(m + 15);
#line 39654
  i = 0U;
#line 39654
  while (i < n) {
#line 39655
    ox = (*(vObj + i))[0];
#line 39655
    oy = (*(vObj + i))[1];
#line 39656
    oz = (*(vObj + i))[2];
#line 39656
    ow = (*(vObj + i))[3];
#line 39657
    (*(vEye + i))[0] = ((m0 * ox + m4 * oy) + m8 * oz) + m12 * ow;
#line 39658
    (*(vEye + i))[1] = ((m1 * ox + m5 * oy) + m9 * oz) + m13 * ow;
#line 39659
    (*(vEye + i))[2] = ((m2 * ox + m6 * oy) + m10 * oz) + m14 * ow;
#line 39660
    (*(vEye + i))[3] = ((m3 * ox + m7 * oy) + m11 * oz) + m15 * ow;
#line 39654
    i ++;
  }
#line 39663
  break;
  case 1: 
#line 39667
  i___0 = 0U;
#line 39667
  while (i___0 < n) {
#line 39668
    (*(vEye + i___0))[0] = (*(vObj + i___0))[0];
#line 39669
    (*(vEye + i___0))[1] = (*(vObj + i___0))[1];
#line 39670
    (*(vEye + i___0))[2] = (*(vObj + i___0))[2];
#line 39671
    (*(vEye + i___0))[3] = (*(vObj + i___0))[3];
#line 39667
    i___0 ++;
  }
#line 39674
  break;
  case 4: 
#line 39677
  m___0 = (float const   *)(ctx->ModelViewMatrix);
#line 39678
  m0___0 = (float )*(m___0 + 0);
#line 39678
  m1___0 = (float )*(m___0 + 1);
#line 39678
  m4___0 = (float )*(m___0 + 4);
#line 39678
  m5___0 = (float )*(m___0 + 5);
#line 39679
  m12___0 = (float )*(m___0 + 12);
#line 39679
  m13___0 = (float )*(m___0 + 13);
#line 39681
  i___1 = 0U;
#line 39681
  while (i___1 < n) {
#line 39682
    ox___0 = (*(vObj + i___1))[0];
#line 39682
    oy___0 = (*(vObj + i___1))[1];
#line 39683
    oz___0 = (*(vObj + i___1))[2];
#line 39683
    ow___0 = (*(vObj + i___1))[3];
#line 39684
    (*(vEye + i___1))[0] = (m0___0 * ox___0 + m4___0 * oy___0) + m12___0 * ow___0;
#line 39685
    (*(vEye + i___1))[1] = (m1___0 * ox___0 + m5___0 * oy___0) + m13___0 * ow___0;
#line 39686
    (*(vEye + i___1))[2] = oz___0;
#line 39687
    (*(vEye + i___1))[3] = ow___0;
#line 39681
    i___1 ++;
  }
#line 39690
  break;
  case 5: 
#line 39693
  m___1 = (float const   *)(ctx->ModelViewMatrix);
#line 39694
  m0___1 = (float )*(m___1 + 0);
#line 39694
  m5___1 = (float )*(m___1 + 5);
#line 39694
  m12___1 = (float )*(m___1 + 12);
#line 39694
  m13___1 = (float )*(m___1 + 13);
#line 39696
  i___2 = 0U;
#line 39696
  while (i___2 < n) {
#line 39697
    ox___1 = (*(vObj + i___2))[0];
#line 39697
    oy___1 = (*(vObj + i___2))[1];
#line 39698
    oz___1 = (*(vObj + i___2))[2];
#line 39698
    ow___1 = (*(vObj + i___2))[3];
#line 39699
    (*(vEye + i___2))[0] = m0___1 * ox___1 + m12___1 * ow___1;
#line 39700
    (*(vEye + i___2))[1] = m5___1 * oy___1 + m13___1 * ow___1;
#line 39701
    (*(vEye + i___2))[2] = oz___1;
#line 39702
    (*(vEye + i___2))[3] = ow___1;
#line 39696
    i___2 ++;
  }
#line 39705
  break;
  case 6: 
#line 39708
  m___2 = (float const   *)(ctx->ModelViewMatrix);
#line 39709
  m0___2 = (float )*(m___2 + 0);
#line 39709
  m1___1 = (float )*(m___2 + 1);
#line 39709
  m2___0 = (float )*(m___2 + 2);
#line 39709
  m4___1 = (float )*(m___2 + 4);
#line 39709
  m5___2 = (float )*(m___2 + 5);
#line 39710
  m6___0 = (float )*(m___2 + 6);
#line 39710
  m8___0 = (float )*(m___2 + 8);
#line 39710
  m9___0 = (float )*(m___2 + 9);
#line 39710
  m10___0 = (float )*(m___2 + 10);
#line 39711
  m12___2 = (float )*(m___2 + 12);
#line 39711
  m13___2 = (float )*(m___2 + 13);
#line 39711
  m14___0 = (float )*(m___2 + 14);
#line 39713
  i___3 = 0U;
#line 39713
  while (i___3 < n) {
#line 39714
    ox___2 = (*(vObj + i___3))[0];
#line 39714
    oy___2 = (*(vObj + i___3))[1];
#line 39715
    oz___2 = (*(vObj + i___3))[2];
#line 39715
    ow___2 = (*(vObj + i___3))[3];
#line 39716
    (*(vEye + i___3))[0] = ((m0___2 * ox___2 + m4___1 * oy___2) + m8___0 * oz___2) + m12___2 * ow___2;
#line 39717
    (*(vEye + i___3))[1] = ((m1___1 * ox___2 + m5___2 * oy___2) + m9___0 * oz___2) + m13___2 * ow___2;
#line 39718
    (*(vEye + i___3))[2] = ((m2___0 * ox___2 + m6___0 * oy___2) + m10___0 * oz___2) + m14___0 * ow___2;
#line 39719
    (*(vEye + i___3))[3] = ow___2;
#line 39713
    i___3 ++;
  }
#line 39722
  break;
  default: 
#line 39724
  gl_problem((GLcontext const   *)((void *)0), "invalid matrix type in transform_points4()");
  }
#line 39750
  return;
}
}
#line 39751 "D:/a/test/177.c"
static void transform_texcoords(GLcontext *ctx , GLuint n , float (*t)[4] ) 
{ float const   *m ;
  float m0 ;
  float m4 ;
  float m8 ;
  float m12 ;
  float m1 ;
  float m5 ;
  float m9 ;
  float m13 ;
  float m2 ;
  float m6 ;
  float m10 ;
  float m14 ;
  float m3 ;
  float m7 ;
  float m11 ;
  float m15 ;
  GLuint i ;
  float t0 ;
  float t1 ;
  float t2 ;
  float t3 ;
  float const   *m___0 ;
  float m0___0 ;
  float m1___0 ;
  float m4___0 ;
  float m5___0 ;
  float m12___0 ;
  float m13___0 ;
  GLuint i___0 ;
  float t0___0 ;
  float t1___0 ;
  float t2___0 ;
  float t3___0 ;
  float const   *m___1 ;
  float m0___1 ;
  float m1___1 ;
  float m2___0 ;
  float m4___1 ;
  float m5___1 ;
  float m6___0 ;
  float m8___0 ;
  float m9___0 ;
  float m10___0 ;
  float m12___1 ;
  float m13___1 ;
  float m14___0 ;
  GLuint i___1 ;
  float t0___1 ;
  float t1___1 ;
  float t2___1 ;
  float t3___1 ;

  {
#line 39755
  switch ((int )ctx->TextureMatrixType) {
  case 0: 
#line 39758
  m = (float const   *)(ctx->TextureMatrix);
#line 39759
  m0 = (float )*(m + 0);
#line 39759
  m4 = (float )*(m + 4);
#line 39759
  m8 = (float )*(m + 8);
#line 39759
  m12 = (float )*(m + 12);
#line 39760
  m1 = (float )*(m + 1);
#line 39760
  m5 = (float )*(m + 5);
#line 39760
  m9 = (float )*(m + 9);
#line 39760
  m13 = (float )*(m + 13);
#line 39761
  m2 = (float )*(m + 2);
#line 39761
  m6 = (float )*(m + 6);
#line 39761
  m10 = (float )*(m + 10);
#line 39761
  m14 = (float )*(m + 14);
#line 39762
  m3 = (float )*(m + 3);
#line 39762
  m7 = (float )*(m + 7);
#line 39762
  m11 = (float )*(m + 11);
#line 39762
  m15 = (float )*(m + 15);
#line 39764
  i = 0U;
#line 39764
  while (i < n) {
#line 39765
    t0 = (*(t + i))[0];
#line 39765
    t1 = (*(t + i))[1];
#line 39765
    t2 = (*(t + i))[2];
#line 39765
    t3 = (*(t + i))[3];
#line 39766
    (*(t + i))[0] = ((m0 * t0 + m4 * t1) + m8 * t2) + m12 * t3;
#line 39767
    (*(t + i))[1] = ((m1 * t0 + m5 * t1) + m9 * t2) + m13 * t3;
#line 39768
    (*(t + i))[2] = ((m2 * t0 + m6 * t1) + m10 * t2) + m14 * t3;
#line 39769
    (*(t + i))[3] = ((m3 * t0 + m7 * t1) + m11 * t2) + m15 * t3;
#line 39764
    i ++;
  }
#line 39772
  break;
  case 1: 
#line 39774
  break;
  case 4: 
#line 39777
  m___0 = (float const   *)(ctx->TextureMatrix);
#line 39778
  m0___0 = (float )*(m___0 + 0);
#line 39778
  m1___0 = (float )*(m___0 + 1);
#line 39778
  m4___0 = (float )*(m___0 + 4);
#line 39778
  m5___0 = (float )*(m___0 + 5);
#line 39779
  m12___0 = (float )*(m___0 + 12);
#line 39779
  m13___0 = (float )*(m___0 + 13);
#line 39781
  i___0 = 0U;
#line 39781
  while (i___0 < n) {
#line 39782
    t0___0 = (*(t + i___0))[0];
#line 39782
    t1___0 = (*(t + i___0))[1];
#line 39782
    t2___0 = (*(t + i___0))[2];
#line 39782
    t3___0 = (*(t + i___0))[3];
#line 39783
    (*(t + i___0))[0] = (m0___0 * t0___0 + m4___0 * t1___0) + m12___0 * t3___0;
#line 39784
    (*(t + i___0))[1] = (m1___0 * t0___0 + m5___0 * t1___0) + m13___0 * t3___0;
#line 39785
    (*(t + i___0))[2] = t2___0;
#line 39781
    i___0 ++;
  }
#line 39788
  break;
  case 6: 
#line 39791
  m___1 = (float const   *)(ctx->TextureMatrix);
#line 39792
  m0___1 = (float )*(m___1 + 0);
#line 39792
  m1___1 = (float )*(m___1 + 1);
#line 39792
  m2___0 = (float )*(m___1 + 2);
#line 39792
  m4___1 = (float )*(m___1 + 4);
#line 39792
  m5___1 = (float )*(m___1 + 5);
#line 39793
  m6___0 = (float )*(m___1 + 6);
#line 39793
  m8___0 = (float )*(m___1 + 8);
#line 39793
  m9___0 = (float )*(m___1 + 9);
#line 39793
  m10___0 = (float )*(m___1 + 10);
#line 39794
  m12___1 = (float )*(m___1 + 12);
#line 39794
  m13___1 = (float )*(m___1 + 13);
#line 39794
  m14___0 = (float )*(m___1 + 14);
#line 39796
  i___1 = 0U;
#line 39796
  while (i___1 < n) {
#line 39797
    t0___1 = (*(t + i___1))[0];
#line 39797
    t1___1 = (*(t + i___1))[1];
#line 39797
    t2___1 = (*(t + i___1))[2];
#line 39797
    t3___1 = (*(t + i___1))[3];
#line 39798
    (*(t + i___1))[0] = ((m0___1 * t0___1 + m4___1 * t1___1) + m8___0 * t2___1) + m12___1 * t3___1;
#line 39799
    (*(t + i___1))[1] = ((m1___1 * t0___1 + m5___1 * t1___1) + m9___0 * t2___1) + m13___1 * t3___1;
#line 39800
    (*(t + i___1))[2] = ((m2___0 * t0___1 + m6___0 * t1___1) + m10___0 * t2___1) + m14___0 * t3___1;
#line 39796
    i___1 ++;
  }
#line 39803
  break;
  default: 
#line 39805
  gl_problem((GLcontext const   *)((void *)0), "invalid matrix type in transform_texcoords()");
  }
#line 39826
  return;
}
}
#line 39838 "D:/a/test/177.c"
static void project_and_cliptest(GLcontext *ctx , GLuint n , float (*vEye)[4] , float (*vClip)[4] ,
                                 GLubyte *clipMask , GLubyte *orMask , GLubyte *andMask ) 
{ GLubyte tmpOrMask ;
  GLubyte tmpAndMask ;
  float const   *m ;
  float m0 ;
  float m4 ;
  float m8 ;
  float m12 ;
  float m1 ;
  float m5 ;
  float m9 ;
  float m13 ;
  float m2 ;
  float m6 ;
  float m10 ;
  float m14 ;
  float m3 ;
  float m7 ;
  float m11 ;
  float m15 ;
  GLuint i ;
  float ex ;
  float ey ;
  float ez ;
  float ew ;
  float cx ;
  float cy ;
  float cz ;
  float cw ;
  GLubyte mask ;
  GLuint i___0 ;
  float cx___0 ;
  float tmp___0 ;
  float cy___0 ;
  float tmp___1 ;
  float cz___0 ;
  float tmp___2 ;
  float cw___0 ;
  float tmp___3 ;
  GLubyte mask___0 ;
  float const   *m___0 ;
  float m0___0 ;
  float m5___0 ;
  float m10___0 ;
  float m12___0 ;
  float m13___0 ;
  float m14___0 ;
  GLuint i___1 ;
  float ex___0 ;
  float ey___0 ;
  float ez___0 ;
  float ew___0 ;
  float cx___1 ;
  float cy___1 ;
  float cz___1 ;
  float cw___1 ;
  GLubyte mask___1 ;
  float const   *m___1 ;
  float m0___1 ;
  float m5___1 ;
  float m8___0 ;
  float m9___0 ;
  float m10___1 ;
  float m14___1 ;
  GLuint i___2 ;
  float ex___1 ;
  float ey___1 ;
  float ez___1 ;
  float ew___1 ;
  float cx___2 ;
  float cy___2 ;
  float cz___2 ;
  float cw___2 ;
  GLubyte mask___2 ;

  {
#line 39844
  tmpOrMask = *orMask;
#line 39845
  tmpAndMask = *andMask;
#line 39847
  switch ((int )ctx->ProjectionMatrixType) {
  case 0: 
#line 39850
  m = (float const   *)(ctx->ProjectionMatrix);
#line 39851
  m0 = (float )*(m + 0);
#line 39851
  m4 = (float )*(m + 4);
#line 39851
  m8 = (float )*(m + 8);
#line 39851
  m12 = (float )*(m + 12);
#line 39852
  m1 = (float )*(m + 1);
#line 39852
  m5 = (float )*(m + 5);
#line 39852
  m9 = (float )*(m + 9);
#line 39852
  m13 = (float )*(m + 13);
#line 39853
  m2 = (float )*(m + 2);
#line 39853
  m6 = (float )*(m + 6);
#line 39853
  m10 = (float )*(m + 10);
#line 39853
  m14 = (float )*(m + 14);
#line 39854
  m3 = (float )*(m + 3);
#line 39854
  m7 = (float )*(m + 7);
#line 39854
  m11 = (float )*(m + 11);
#line 39854
  m15 = (float )*(m + 15);
#line 39856
  i = 0U;
#line 39856
  while (i < n) {
#line 39857
    ex = (*(vEye + i))[0];
#line 39857
    ey = (*(vEye + i))[1];
#line 39858
    ez = (*(vEye + i))[2];
#line 39858
    ew = (*(vEye + i))[3];
#line 39859
    cx = ((m0 * ex + m4 * ey) + m8 * ez) + m12 * ew;
#line 39860
    cy = ((m1 * ex + m5 * ey) + m9 * ez) + m13 * ew;
#line 39861
    cz = ((m2 * ex + m6 * ey) + m10 * ez) + m14 * ew;
#line 39862
    cw = ((m3 * ex + m7 * ey) + m11 * ez) + m15 * ew;
#line 39863
    mask = (GLubyte )0;
#line 39864
    (*(vClip + i))[0] = cx;
#line 39865
    (*(vClip + i))[1] = cy;
#line 39866
    (*(vClip + i))[2] = cz;
#line 39867
    (*(vClip + i))[3] = cw;
#line 39868
    if (cx > cw) {
#line 39868
      mask = (unsigned char )((int )mask | 1);
    } else {
#line 39869
      if (cx < - cw) {
#line 39869
        mask = (unsigned char )((int )mask | 2);
      }
    }
#line 39870
    if (cy > cw) {
#line 39870
      mask = (unsigned char )((int )mask | 4);
    } else {
#line 39871
      if (cy < - cw) {
#line 39871
        mask = (unsigned char )((int )mask | 8);
      }
    }
#line 39872
    if (cz > cw) {
#line 39872
      mask = (unsigned char )((int )mask | 32);
    } else {
#line 39873
      if (cz < - cw) {
#line 39873
        mask = (unsigned char )((int )mask | 16);
      }
    }
#line 39874
    if (mask) {
#line 39875
      *(clipMask + i) = (unsigned char )((int )*(clipMask + i) | (int )mask);
#line 39876
      tmpOrMask = (unsigned char )((int )tmpOrMask | (int )mask);
    }
#line 39878
    tmpAndMask = (unsigned char )((int )tmpAndMask & (int )mask);
#line 39856
    i ++;
  }
#line 39881
  break;
  case 1: 
#line 39885
  i___0 = 0U;
#line 39885
  while (i___0 < n) {
#line 39886
    tmp___0 = (*(vEye + i___0))[0];
#line 39886
    (*(vClip + i___0))[0] = tmp___0;
#line 39886
    cx___0 = tmp___0;
#line 39887
    tmp___1 = (*(vEye + i___0))[1];
#line 39887
    (*(vClip + i___0))[1] = tmp___1;
#line 39887
    cy___0 = tmp___1;
#line 39888
    tmp___2 = (*(vEye + i___0))[2];
#line 39888
    (*(vClip + i___0))[2] = tmp___2;
#line 39888
    cz___0 = tmp___2;
#line 39889
    tmp___3 = (*(vEye + i___0))[3];
#line 39889
    (*(vClip + i___0))[3] = tmp___3;
#line 39889
    cw___0 = tmp___3;
#line 39890
    mask___0 = (GLubyte )0;
#line 39891
    if (cx___0 > cw___0) {
#line 39891
      mask___0 = (unsigned char )((int )mask___0 | 1);
    } else {
#line 39892
      if (cx___0 < - cw___0) {
#line 39892
        mask___0 = (unsigned char )((int )mask___0 | 2);
      }
    }
#line 39893
    if (cy___0 > cw___0) {
#line 39893
      mask___0 = (unsigned char )((int )mask___0 | 4);
    } else {
#line 39894
      if (cy___0 < - cw___0) {
#line 39894
        mask___0 = (unsigned char )((int )mask___0 | 8);
      }
    }
#line 39895
    if (cz___0 > cw___0) {
#line 39895
      mask___0 = (unsigned char )((int )mask___0 | 32);
    } else {
#line 39896
      if (cz___0 < - cw___0) {
#line 39896
        mask___0 = (unsigned char )((int )mask___0 | 16);
      }
    }
#line 39897
    if (mask___0) {
#line 39898
      *(clipMask + i___0) = (unsigned char )((int )*(clipMask + i___0) | (int )mask___0);
#line 39899
      tmpOrMask = (unsigned char )((int )tmpOrMask | (int )mask___0);
    }
#line 39901
    tmpAndMask = (unsigned char )((int )tmpAndMask & (int )mask___0);
#line 39885
    i___0 ++;
  }
#line 39904
  break;
  case 2: 
#line 39907
  m___0 = (float const   *)(ctx->ProjectionMatrix);
#line 39908
  m0___0 = (float )*(m___0 + 0);
#line 39908
  m5___0 = (float )*(m___0 + 5);
#line 39908
  m10___0 = (float )*(m___0 + 10);
#line 39908
  m12___0 = (float )*(m___0 + 12);
#line 39909
  m13___0 = (float )*(m___0 + 13);
#line 39909
  m14___0 = (float )*(m___0 + 14);
#line 39911
  i___1 = 0U;
#line 39911
  while (i___1 < n) {
#line 39912
    ex___0 = (*(vEye + i___1))[0];
#line 39912
    ey___0 = (*(vEye + i___1))[1];
#line 39913
    ez___0 = (*(vEye + i___1))[2];
#line 39913
    ew___0 = (*(vEye + i___1))[3];
#line 39914
    cx___1 = m0___0 * ex___0 + m12___0 * ew___0;
#line 39915
    cy___1 = m5___0 * ey___0 + m13___0 * ew___0;
#line 39916
    cz___1 = m10___0 * ez___0 + m14___0 * ew___0;
#line 39917
    cw___1 = ew___0;
#line 39918
    mask___1 = (GLubyte )0;
#line 39919
    (*(vClip + i___1))[0] = cx___1;
#line 39920
    (*(vClip + i___1))[1] = cy___1;
#line 39921
    (*(vClip + i___1))[2] = cz___1;
#line 39922
    (*(vClip + i___1))[3] = cw___1;
#line 39923
    if (cx___1 > cw___1) {
#line 39923
      mask___1 = (unsigned char )((int )mask___1 | 1);
    } else {
#line 39924
      if (cx___1 < - cw___1) {
#line 39924
        mask___1 = (unsigned char )((int )mask___1 | 2);
      }
    }
#line 39925
    if (cy___1 > cw___1) {
#line 39925
      mask___1 = (unsigned char )((int )mask___1 | 4);
    } else {
#line 39926
      if (cy___1 < - cw___1) {
#line 39926
        mask___1 = (unsigned char )((int )mask___1 | 8);
      }
    }
#line 39927
    if (cz___1 > cw___1) {
#line 39927
      mask___1 = (unsigned char )((int )mask___1 | 32);
    } else {
#line 39928
      if (cz___1 < - cw___1) {
#line 39928
        mask___1 = (unsigned char )((int )mask___1 | 16);
      }
    }
#line 39929
    if (mask___1) {
#line 39930
      *(clipMask + i___1) = (unsigned char )((int )*(clipMask + i___1) | (int )mask___1);
#line 39931
      tmpOrMask = (unsigned char )((int )tmpOrMask | (int )mask___1);
    }
#line 39933
    tmpAndMask = (unsigned char )((int )tmpAndMask & (int )mask___1);
#line 39911
    i___1 ++;
  }
#line 39936
  break;
  case 3: 
#line 39939
  m___1 = (float const   *)(ctx->ProjectionMatrix);
#line 39940
  m0___1 = (float )*(m___1 + 0);
#line 39940
  m5___1 = (float )*(m___1 + 5);
#line 39940
  m8___0 = (float )*(m___1 + 8);
#line 39940
  m9___0 = (float )*(m___1 + 9);
#line 39941
  m10___1 = (float )*(m___1 + 10);
#line 39941
  m14___1 = (float )*(m___1 + 14);
#line 39943
  i___2 = 0U;
#line 39943
  while (i___2 < n) {
#line 39944
    ex___1 = (*(vEye + i___2))[0];
#line 39944
    ey___1 = (*(vEye + i___2))[1];
#line 39945
    ez___1 = (*(vEye + i___2))[2];
#line 39945
    ew___1 = (*(vEye + i___2))[3];
#line 39946
    cx___2 = m0___1 * ex___1 + m8___0 * ez___1;
#line 39947
    cy___2 = m5___1 * ey___1 + m9___0 * ez___1;
#line 39948
    cz___2 = m10___1 * ez___1 + m14___1 * ew___1;
#line 39949
    cw___2 = - ez___1;
#line 39950
    mask___2 = (GLubyte )0;
#line 39951
    (*(vClip + i___2))[0] = cx___2;
#line 39952
    (*(vClip + i___2))[1] = cy___2;
#line 39953
    (*(vClip + i___2))[2] = cz___2;
#line 39954
    (*(vClip + i___2))[3] = cw___2;
#line 39955
    if (cx___2 > cw___2) {
#line 39955
      mask___2 = (unsigned char )((int )mask___2 | 1);
    } else {
#line 39956
      if (cx___2 < - cw___2) {
#line 39956
        mask___2 = (unsigned char )((int )mask___2 | 2);
      }
    }
#line 39957
    if (cy___2 > cw___2) {
#line 39957
      mask___2 = (unsigned char )((int )mask___2 | 4);
    } else {
#line 39958
      if (cy___2 < - cw___2) {
#line 39958
        mask___2 = (unsigned char )((int )mask___2 | 8);
      }
    }
#line 39959
    if (cz___2 > cw___2) {
#line 39959
      mask___2 = (unsigned char )((int )mask___2 | 32);
    } else {
#line 39960
      if (cz___2 < - cw___2) {
#line 39960
        mask___2 = (unsigned char )((int )mask___2 | 16);
      }
    }
#line 39961
    if (mask___2) {
#line 39962
      *(clipMask + i___2) = (unsigned char )((int )*(clipMask + i___2) | (int )mask___2);
#line 39963
      tmpOrMask = (unsigned char )((int )tmpOrMask | (int )mask___2);
    }
#line 39965
    tmpAndMask = (unsigned char )((int )tmpAndMask & (int )mask___2);
#line 39943
    i___2 ++;
  }
#line 39968
  break;
  default: 
#line 39970
  gl_problem((GLcontext const   *)((void *)0), "invalid matrix type in project_and_cliptest()");
  }
#line 39972
  *orMask = tmpOrMask;
#line 39973
  *andMask = tmpAndMask;
#line 39997
  return;
}
}
#line 39998 "D:/a/test/177.c"
static GLuint userclip_vertices(GLcontext *ctx , GLuint n , float (*vEye)[4] , GLubyte *clipMask ) 
{ GLboolean anyClipped ;
  GLuint p ;
  float a ;
  float b ;
  float c ;
  float d ;
  GLboolean allClipped ;
  GLuint i ;
  float dot ;
  int tmp___0 ;

  {
#line 40002
  anyClipped = (GLboolean )0;
#line 40006
  p = 0U;
#line 40006
  while (p < 6U) {
#line 40007
    if (ctx->Transform.ClipEnabled[p]) {
#line 40008
      a = ctx->Transform.ClipEquation[p][0];
#line 40009
      b = ctx->Transform.ClipEquation[p][1];
#line 40010
      c = ctx->Transform.ClipEquation[p][2];
#line 40011
      d = ctx->Transform.ClipEquation[p][3];
#line 40012
      allClipped = (GLboolean )1;
#line 40014
      i = 0U;
#line 40014
      while (i < n) {
#line 40015
        dot = (((*(vEye + i))[0] * a + (*(vEye + i))[1] * b) + (*(vEye + i))[2] * c) + (*(vEye + i))[3] * d;
#line 40017
        if (dot < 0.0F) {
#line 40018
          *(clipMask + i) = (unsigned char)64;
#line 40019
          anyClipped = (unsigned char)1;
        } else {
#line 40022
          allClipped = (unsigned char)0;
        }
#line 40014
        i ++;
      }
#line 40025
      if (allClipped) {
#line 40026
        return (1U);
      }
    }
#line 40006
    p ++;
  }
#line 40031
  if (anyClipped) {
#line 40031
    tmp___0 = 3;
  } else {
#line 40031
    tmp___0 = 2;
  }
#line 40031
  return ((unsigned int )tmp___0);
}
}
#line 40033 "D:/a/test/177.c"
static void viewport_map_vertices(GLcontext *ctx , GLuint n , float (*vClip)[4] ,
                                  GLubyte const   *clipMask , float (*vWin)[3] ) 
{ float sx ;
  float tx ;
  float sy ;
  float ty ;
  float sz ;
  float tz ;
  GLuint i ;
  GLuint i___0 ;
  GLuint i___1 ;
  float wInv ;
  GLuint i___2 ;
  float wInv___0 ;

  {
#line 40037
  sx = ctx->Viewport.Sx;
#line 40038
  tx = ctx->Viewport.Tx;
#line 40039
  sy = ctx->Viewport.Sy;
#line 40040
  ty = ctx->Viewport.Ty;
#line 40041
  sz = ctx->Viewport.Sz;
#line 40042
  tz = ctx->Viewport.Tz;
#line 40044
  if (ctx->ProjectionMatrixType == 2U) {
    goto _L___1;
  } else {
#line 40044
    if (ctx->ProjectionMatrixType == 1U) {
      _L___1: /* CIL Label */ 
#line 40044
      if (ctx->ModelViewMatrixType != 0U) {
#line 40044
        if (((ctx->VB)->VertexSizeMask & 4U) == 0U) {
#line 40048
          if (clipMask) {
#line 40050
            i = 0U;
#line 40050
            while (i < n) {
#line 40051
              if ((int const   )*(clipMask + i) == 0) {
#line 40052
                (*(vWin + i))[0] = (*(vClip + i))[0] * sx + tx;
#line 40053
                (*(vWin + i))[1] = (*(vClip + i))[1] * sy + ty;
#line 40054
                (*(vWin + i))[2] = (*(vClip + i))[2] * sz + tz;
              }
#line 40050
              i ++;
            }
          } else {
#line 40060
            i___0 = 0U;
#line 40060
            while (i___0 < n) {
#line 40061
              (*(vWin + i___0))[0] = (*(vClip + i___0))[0] * sx + tx;
#line 40062
              (*(vWin + i___0))[1] = (*(vClip + i___0))[1] * sy + ty;
#line 40063
              (*(vWin + i___0))[2] = (*(vClip + i___0))[2] * sz + tz;
#line 40060
              i___0 ++;
            }
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 40068
      if (clipMask) {
#line 40070
        i___1 = 0U;
#line 40070
        while (i___1 < n) {
#line 40071
          if ((int const   )*(clipMask + i___1) == 0) {
#line 40072
            if ((*(vClip + i___1))[3] != 0.0F) {
#line 40073
              wInv = 1.0F / (*(vClip + i___1))[3];
#line 40074
              (*(vWin + i___1))[0] = ((*(vClip + i___1))[0] * wInv) * sx + tx;
#line 40075
              (*(vWin + i___1))[1] = ((*(vClip + i___1))[1] * wInv) * sy + ty;
#line 40076
              (*(vWin + i___1))[2] = ((*(vClip + i___1))[2] * wInv) * sz + tz;
            } else {
#line 40079
              (*(vWin + i___1))[0] = 0.0F;
#line 40080
              (*(vWin + i___1))[1] = 0.0F;
#line 40081
              (*(vWin + i___1))[2] = 0.0F;
            }
          }
#line 40070
          i___1 ++;
        }
      } else {
#line 40088
        i___2 = 0U;
#line 40088
        while (i___2 < n) {
#line 40089
          if ((*(vClip + i___2))[3] != 0.0F) {
#line 40090
            wInv___0 = 1.0F / (*(vClip + i___2))[3];
#line 40091
            (*(vWin + i___2))[0] = ((*(vClip + i___2))[0] * wInv___0) * sx + tx;
#line 40092
            (*(vWin + i___2))[1] = ((*(vClip + i___2))[1] * wInv___0) * sy + ty;
#line 40093
            (*(vWin + i___2))[2] = ((*(vClip + i___2))[2] * wInv___0) * sz + tz;
          } else {
#line 40096
            (*(vWin + i___2))[0] = 0.0F;
#line 40097
            (*(vWin + i___2))[1] = 0.0F;
#line 40098
            (*(vWin + i___2))[2] = 0.0F;
          }
#line 40088
          i___2 ++;
        }
      }
    }
  }
#line 40104
  return;
}
}
#line 40105 "D:/a/test/177.c"
static void update_material(GLcontext *ctx , GLuint i ) 
{ struct vertex_buffer *VB ;

  {
#line 40107
  VB = ctx->VB;
#line 40108
  if (VB->MaterialMask[i]) {
#line 40109
    if (VB->MaterialMask[i] & 1U) {
#line 40110
      ctx->Light.Material[0].Ambient[0] = VB->Material[i][0].Ambient[0];
#line 40110
      ctx->Light.Material[0].Ambient[1] = VB->Material[i][0].Ambient[1];
#line 40110
      ctx->Light.Material[0].Ambient[2] = VB->Material[i][0].Ambient[2];
#line 40110
      ctx->Light.Material[0].Ambient[3] = VB->Material[i][0].Ambient[3];
    }
#line 40112
    if (VB->MaterialMask[i] & 2U) {
#line 40113
      ctx->Light.Material[1].Ambient[0] = VB->Material[i][1].Ambient[0];
#line 40113
      ctx->Light.Material[1].Ambient[1] = VB->Material[i][1].Ambient[1];
#line 40113
      ctx->Light.Material[1].Ambient[2] = VB->Material[i][1].Ambient[2];
#line 40113
      ctx->Light.Material[1].Ambient[3] = VB->Material[i][1].Ambient[3];
    }
#line 40115
    if (VB->MaterialMask[i] & 4U) {
#line 40116
      ctx->Light.Material[0].Diffuse[0] = VB->Material[i][0].Diffuse[0];
#line 40116
      ctx->Light.Material[0].Diffuse[1] = VB->Material[i][0].Diffuse[1];
#line 40116
      ctx->Light.Material[0].Diffuse[2] = VB->Material[i][0].Diffuse[2];
#line 40116
      ctx->Light.Material[0].Diffuse[3] = VB->Material[i][0].Diffuse[3];
    }
#line 40118
    if (VB->MaterialMask[i] & 8U) {
#line 40119
      ctx->Light.Material[1].Diffuse[0] = VB->Material[i][1].Diffuse[0];
#line 40119
      ctx->Light.Material[1].Diffuse[1] = VB->Material[i][1].Diffuse[1];
#line 40119
      ctx->Light.Material[1].Diffuse[2] = VB->Material[i][1].Diffuse[2];
#line 40119
      ctx->Light.Material[1].Diffuse[3] = VB->Material[i][1].Diffuse[3];
    }
#line 40121
    if (VB->MaterialMask[i] & 16U) {
#line 40122
      ctx->Light.Material[0].Specular[0] = VB->Material[i][0].Specular[0];
#line 40122
      ctx->Light.Material[0].Specular[1] = VB->Material[i][0].Specular[1];
#line 40122
      ctx->Light.Material[0].Specular[2] = VB->Material[i][0].Specular[2];
#line 40122
      ctx->Light.Material[0].Specular[3] = VB->Material[i][0].Specular[3];
    }
#line 40124
    if (VB->MaterialMask[i] & 32U) {
#line 40125
      ctx->Light.Material[1].Specular[0] = VB->Material[i][1].Specular[0];
#line 40125
      ctx->Light.Material[1].Specular[1] = VB->Material[i][1].Specular[1];
#line 40125
      ctx->Light.Material[1].Specular[2] = VB->Material[i][1].Specular[2];
#line 40125
      ctx->Light.Material[1].Specular[3] = VB->Material[i][1].Specular[3];
    }
#line 40127
    if (VB->MaterialMask[i] & 64U) {
#line 40128
      ctx->Light.Material[0].Emission[0] = VB->Material[i][0].Emission[0];
#line 40128
      ctx->Light.Material[0].Emission[1] = VB->Material[i][0].Emission[1];
#line 40128
      ctx->Light.Material[0].Emission[2] = VB->Material[i][0].Emission[2];
#line 40128
      ctx->Light.Material[0].Emission[3] = VB->Material[i][0].Emission[3];
    }
#line 40130
    if (VB->MaterialMask[i] & 128U) {
#line 40131
      ctx->Light.Material[1].Emission[0] = VB->Material[i][1].Emission[0];
#line 40131
      ctx->Light.Material[1].Emission[1] = VB->Material[i][1].Emission[1];
#line 40131
      ctx->Light.Material[1].Emission[2] = VB->Material[i][1].Emission[2];
#line 40131
      ctx->Light.Material[1].Emission[3] = VB->Material[i][1].Emission[3];
    }
#line 40133
    if (VB->MaterialMask[i] & 256U) {
#line 40134
      ctx->Light.Material[0].Shininess = VB->Material[i][0].Shininess;
#line 40135
      gl_compute_material_shine_table(& ctx->Light.Material[0]);
    }
#line 40137
    if (VB->MaterialMask[i] & 512U) {
#line 40138
      ctx->Light.Material[1].Shininess = VB->Material[i][1].Shininess;
#line 40139
      gl_compute_material_shine_table(& ctx->Light.Material[1]);
    }
#line 40141
    if (VB->MaterialMask[i] & 1024U) {
#line 40142
      ctx->Light.Material[0].AmbientIndex = VB->Material[i][0].AmbientIndex;
#line 40143
      ctx->Light.Material[0].DiffuseIndex = VB->Material[i][0].DiffuseIndex;
#line 40144
      ctx->Light.Material[0].SpecularIndex = VB->Material[i][0].SpecularIndex;
    }
#line 40146
    if (VB->MaterialMask[i] & 2048U) {
#line 40147
      ctx->Light.Material[1].AmbientIndex = VB->Material[i][1].AmbientIndex;
#line 40148
      ctx->Light.Material[1].DiffuseIndex = VB->Material[i][1].DiffuseIndex;
#line 40149
      ctx->Light.Material[1].SpecularIndex = VB->Material[i][1].SpecularIndex;
    }
#line 40151
    VB->MaterialMask[i] = 0U;
  }
#line 40153
  return;
}
}
#line 40154 "D:/a/test/177.c"
static void shade_vertices(GLcontext *ctx ) 
{ struct vertex_buffer *VB ;
  GLuint i ;
  GLubyte color[1][4] ;
  GLuint i___0 ;
  GLuint i___1 ;

  {
#line 40156
  VB = ctx->VB;
#line 40157
  if ((ctx->Visual)->RGBAflag) {
#line 40158
    if (! VB->MonoMaterial) {
#line 40160
      i = VB->Start;
#line 40160
      while (i < VB->Count) {
#line 40161
        update_material(ctx, i);
#line 40162
        gl_color_shade_vertices(ctx, 0U, 1U, & VB->Eye[i], & VB->Normal[i], & VB->Fcolor[i]);
#line 40164
        if (ctx->Light.Model.TwoSide) {
#line 40165
          gl_color_shade_vertices(ctx, 1U, 1U, & VB->Eye[i], & VB->Normal[i], & VB->Bcolor[i]);
        }
#line 40160
        i ++;
      }
#line 40169
      update_material(ctx, VB->Count);
    } else {
#line 40172
      if (ctx->Light.Fast) {
#line 40173
        if (VB->MonoNormal) {
#line 40176
          gl_color_shade_vertices_fast(ctx, 0U, 1U, VB->Normal + VB->Start, color);
#line 40180
          i___0 = VB->Start;
#line 40180
          while (i___0 < VB->Count) {
#line 40181
            VB->Fcolor[i___0][0] = color[0][0];
#line 40181
            VB->Fcolor[i___0][1] = color[0][1];
#line 40181
            VB->Fcolor[i___0][2] = color[0][2];
#line 40181
            VB->Fcolor[i___0][3] = color[0][3];
#line 40180
            i___0 ++;
          }
#line 40183
          if (ctx->Light.Model.TwoSide) {
#line 40184
            gl_color_shade_vertices_fast(ctx, 1U, 1U, VB->Normal + VB->Start, color);
#line 40188
            i___0 = VB->Start;
#line 40188
            while (i___0 < VB->Count) {
#line 40189
              VB->Bcolor[i___0][0] = color[0][0];
#line 40189
              VB->Bcolor[i___0][1] = color[0][1];
#line 40189
              VB->Bcolor[i___0][2] = color[0][2];
#line 40189
              VB->Bcolor[i___0][3] = color[0][3];
#line 40188
              i___0 ++;
            }
          }
        } else {
#line 40194
          gl_color_shade_vertices_fast(ctx, 0U, VB->Count - VB->Start, VB->Normal + VB->Start,
                                       VB->Fcolor + VB->Start);
#line 40198
          if (ctx->Light.Model.TwoSide) {
#line 40199
            gl_color_shade_vertices_fast(ctx, 1U, VB->Count - VB->Start, VB->Normal + VB->Start,
                                         VB->Bcolor + VB->Start);
          }
        }
      } else {
#line 40207
        gl_color_shade_vertices(ctx, 0U, VB->Count - VB->Start, VB->Eye + VB->Start,
                                VB->Normal + VB->Start, VB->Fcolor + VB->Start);
#line 40212
        if (ctx->Light.Model.TwoSide) {
#line 40213
          gl_color_shade_vertices(ctx, 1U, VB->Count - VB->Start, VB->Eye + VB->Start,
                                  VB->Normal + VB->Start, VB->Bcolor + VB->Start);
        }
      }
    }
  } else {
#line 40223
    if (! VB->MonoMaterial) {
#line 40225
      i___1 = VB->Start;
#line 40225
      while (i___1 < VB->Count) {
#line 40226
        update_material(ctx, i___1);
#line 40227
        gl_index_shade_vertices(ctx, 0U, 1U, & VB->Eye[i___1], & VB->Normal[i___1],
                                & VB->Findex[i___1]);
#line 40229
        if (ctx->Light.Model.TwoSide) {
#line 40230
          gl_index_shade_vertices(ctx, 1U, 1U, & VB->Eye[i___1], & VB->Normal[i___1],
                                  & VB->Bindex[i___1]);
        }
#line 40225
        i___1 ++;
      }
#line 40234
      update_material(ctx, VB->Count);
    } else {
#line 40237
      gl_index_shade_vertices(ctx, 0U, VB->Count - VB->Start, VB->Eye + VB->Start,
                              VB->Normal + VB->Start, VB->Findex + VB->Start);
#line 40242
      if (ctx->Light.Model.TwoSide) {
#line 40243
        gl_index_shade_vertices(ctx, 1U, VB->Count - VB->Start, VB->Eye + VB->Start,
                                VB->Normal + VB->Start, VB->Bindex + VB->Start);
      }
    }
  }
#line 40251
  return;
}
}
#line 40252 "D:/a/test/177.c"
static void fog_vertices(GLcontext *ctx ) 
{ struct vertex_buffer *VB ;

  {
#line 40254
  VB = ctx->VB;
#line 40255
  if ((ctx->Visual)->RGBAflag) {
#line 40256
    gl_fog_color_vertices(ctx, VB->Count - VB->Start, VB->Eye + VB->Start, VB->Fcolor + VB->Start);
#line 40259
    if (ctx->LightTwoSide) {
#line 40260
      gl_fog_color_vertices(ctx, VB->Count - VB->Start, VB->Eye + VB->Start, VB->Bcolor + VB->Start);
    }
  } else {
#line 40266
    gl_fog_index_vertices(ctx, VB->Count - VB->Start, VB->Eye + VB->Start, VB->Findex + VB->Start);
#line 40269
    if (ctx->LightTwoSide) {
#line 40270
      gl_fog_index_vertices(ctx, VB->Count - VB->Start, VB->Eye + VB->Start, VB->Bindex + VB->Start);
    }
  }
#line 40275
  return;
}
}
#line 40276 "D:/a/test/177.c"
void gl_transform_vb_part1(GLcontext *ctx , GLboolean allDone ) 
{ struct vertex_buffer *VB ;

  {
#line 40278
  VB = ctx->VB;
#line 40283
  if (VB->VertexSizeMask == 4U) {
#line 40284
    transform_points4(ctx, VB->Count - VB->Start, VB->Obj + VB->Start, VB->Eye + VB->Start);
  } else {
#line 40288
    transform_points3(ctx, VB->Count - VB->Start, VB->Obj + VB->Start, VB->Eye + VB->Start);
  }
#line 40291
  if (ctx->NeedNormals) {
#line 40292
    gl_xform_normals_3fv(VB->Count - VB->Start, VB->Normal + VB->Start, ctx->ModelViewInv,
                         VB->Normal + VB->Start, ctx->Transform.Normalize);
  }
#line 40299
  gl_transform_vb_part2(ctx, allDone);
#line 40300
  return;
}
}
#line 40301 "D:/a/test/177.c"
void gl_transform_vb_part2(GLcontext *ctx , GLboolean allDone ) 
{ struct vertex_buffer *VB ;
  GLuint result ;
  GLuint tmp___0 ;
  GLubyte *tmp___1 ;
  GLboolean tmp___2 ;

  {
#line 40303
  VB = ctx->VB;
#line 40308
  if (ctx->Transform.AnyClip) {
#line 40309
    tmp___0 = userclip_vertices(ctx, VB->Count - VB->Start, VB->Eye + VB->Start, VB->ClipMask + VB->Start);
#line 40309
    result = tmp___0;
#line 40312
    if (result == 1U) {
#line 40313
      gl_reset_vb(ctx, allDone);
#line 40314
      return;
    } else {
#line 40316
      if (result == 3U) {
#line 40317
        VB->ClipOrMask = (unsigned char)64;
      } else {
#line 40320
        VB->ClipAndMask = (unsigned char)0;
      }
    }
  }
#line 40323
  project_and_cliptest(ctx, VB->Count - VB->Start, VB->Eye + VB->Start, VB->Clip + VB->Start,
                       VB->ClipMask + VB->Start, & VB->ClipOrMask, & VB->ClipAndMask);
#line 40326
  if (VB->ClipAndMask) {
#line 40327
    gl_reset_vb(ctx, allDone);
#line 40328
    return;
  }
#line 40330
  if (ctx->Light.Enabled) {
#line 40331
    shade_vertices(ctx);
  }
#line 40333
  if (ctx->Fog.Enabled) {
#line 40333
    if (ctx->Hint.Fog != 4354) {
#line 40334
      fog_vertices(ctx);
    }
  }
#line 40336
  if (ctx->Texture.Enabled) {
    goto _L;
  } else {
#line 40336
    if (ctx->RenderMode == 7169) {
      _L: /* CIL Label */ 
#line 40337
      if (ctx->Texture.TexGenEnabled) {
#line 40338
        gl_texgen(ctx, (int )(VB->Count - VB->Start), VB->Obj + VB->Start, VB->Eye + VB->Start,
                  VB->Normal + VB->Start, VB->TexCoord + VB->Start);
      }
#line 40344
      if (ctx->NewTextureMatrix) {
#line 40345
        gl_analyze_texture_matrix(ctx);
      }
#line 40347
      if (ctx->TextureMatrixType != 1U) {
#line 40348
        transform_texcoords(ctx, VB->Count - VB->Start, VB->TexCoord + VB->Start);
      }
    }
  }
#line 40352
  if (VB->ClipOrMask) {
#line 40352
    tmp___1 = VB->ClipMask + VB->Start;
  } else {
#line 40352
    tmp___1 = (GLubyte *)((void *)0);
  }
#line 40352
  viewport_map_vertices(ctx, VB->Count - VB->Start, VB->Clip + VB->Start, (GLubyte const   *)tmp___1,
                        VB->Win + VB->Start);
#line 40355
  if (ctx->Driver.RasterSetup) {
#line 40356
    (*(ctx->Driver.RasterSetup))(ctx, 0U, VB->Count);
  }
#line 40362
  if (! ctx->Driver.RenderVB) {
#line 40363
    gl_render_vb(ctx, allDone);
  } else {
#line 40362
    tmp___2 = (*(ctx->Driver.RenderVB))(ctx, allDone);
#line 40362
    if (! tmp___2) {
#line 40363
      gl_render_vb(ctx, allDone);
    }
  }
#line 40365
  return;
}
}
#line 40380 "D:/a/test/177.c"
void glWindowPos4fMESA(float x , float y , float z , float w ) 
{ float fx ;
  float fy ;

  {
#line 40383
  glPushAttrib(6144U);
#line 40384
  glMatrixMode(5889);
#line 40385
  glPushMatrix();
#line 40386
  glLoadIdentity();
#line 40387
  glMatrixMode(5888);
#line 40388
  glPushMatrix();
#line 40389
  glLoadIdentity();
#line 40390
  glDepthRange((double )z, (double )z);
#line 40391
  glViewport((int )x - 1, (int )y - 1, 2, 2);
#line 40392
  fx = x - (float )((int )x);
#line 40393
  fy = y - (float )((int )y);
#line 40394
  glRasterPos4f(fx, fy, (float )0.0, w);
#line 40395
  glPopMatrix();
#line 40396
  glMatrixMode(5889);
#line 40397
  glPopMatrix();
#line 40398
  glPopAttrib();
#line 40399
  return;
}
}
#line 40406 "D:/a/test/177.c"
void gl_xform_points_4fv(GLuint n , float (*q)[4] , float const   *m , float (*p)[4] ) 
{ GLuint i ;
  float m0 ;
  float m4 ;
  float m8 ;
  float m12 ;
  float m1 ;
  float m5 ;
  float m9 ;
  float m13 ;
  float p0 ;
  float p1 ;
  float p2 ;
  float p0___0 ;
  float p1___0 ;
  float p2___0 ;
  float p3 ;
  GLuint i___0 ;
  float m2 ;
  float m6 ;
  float m10 ;
  float m14 ;
  float m3 ;
  float m7 ;
  float m11 ;
  float m15 ;
  float p0___1 ;
  float p1___1 ;
  float p2___1 ;
  float p3___0 ;
  float p0___2 ;
  float p1___2 ;
  float p2___2 ;
  float p3___1 ;

  {
#line 40411
  m0 = (float )*(m + 0);
#line 40411
  m4 = (float )*(m + 4);
#line 40411
  m8 = (float )*(m + 8);
#line 40411
  m12 = (float )*(m + 12);
#line 40412
  m1 = (float )*(m + 1);
#line 40412
  m5 = (float )*(m + 5);
#line 40412
  m9 = (float )*(m + 9);
#line 40412
  m13 = (float )*(m + 13);
#line 40413
  if (m12 == 0.0F) {
#line 40413
    if (m13 == 0.0F) {
#line 40414
      i = 0U;
#line 40414
      while (i < n) {
#line 40415
        p0 = (*(p + i))[0];
#line 40415
        p1 = (*(p + i))[1];
#line 40415
        p2 = (*(p + i))[2];
#line 40416
        (*(q + i))[0] = (m0 * p0 + m4 * p1) + m8 * p2;
#line 40417
        (*(q + i))[1] = (m1 * p0 + m5 * p1) + m9 * p2;
#line 40414
        i ++;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 40421
    i = 0U;
#line 40421
    while (i < n) {
#line 40422
      p0___0 = (*(p + i))[0];
#line 40422
      p1___0 = (*(p + i))[1];
#line 40422
      p2___0 = (*(p + i))[2];
#line 40422
      p3 = (*(p + i))[3];
#line 40423
      (*(q + i))[0] = ((m0 * p0___0 + m4 * p1___0) + m8 * p2___0) + m12 * p3;
#line 40424
      (*(q + i))[1] = ((m1 * p0___0 + m5 * p1___0) + m9 * p2___0) + m13 * p3;
#line 40421
      i ++;
    }
  }
#line 40430
  m2 = (float )*(m + 2);
#line 40430
  m6 = (float )*(m + 6);
#line 40430
  m10 = (float )*(m + 10);
#line 40430
  m14 = (float )*(m + 14);
#line 40431
  m3 = (float )*(m + 3);
#line 40431
  m7 = (float )*(m + 7);
#line 40431
  m11 = (float )*(m + 11);
#line 40431
  m15 = (float )*(m + 15);
#line 40432
  if (m3 == 0.0F) {
#line 40432
    if (m7 == 0.0F) {
#line 40432
      if (m11 == 0.0F) {
#line 40432
        if (m15 == 1.0F) {
#line 40433
          i___0 = 0U;
#line 40433
          while (i___0 < n) {
#line 40434
            p0___1 = (*(p + i___0))[0];
#line 40434
            p1___1 = (*(p + i___0))[1];
#line 40434
            p2___1 = (*(p + i___0))[2];
#line 40434
            p3___0 = (*(p + i___0))[3];
#line 40435
            (*(q + i___0))[2] = ((m2 * p0___1 + m6 * p1___1) + m10 * p2___1) + m14 * p3___0;
#line 40436
            (*(q + i___0))[3] = p3___0;
#line 40433
            i___0 ++;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 40440
    i___0 = 0U;
#line 40440
    while (i___0 < n) {
#line 40441
      p0___2 = (*(p + i___0))[0];
#line 40441
      p1___2 = (*(p + i___0))[1];
#line 40441
      p2___2 = (*(p + i___0))[2];
#line 40441
      p3___1 = (*(p + i___0))[3];
#line 40442
      (*(q + i___0))[2] = ((m2 * p0___2 + m6 * p1___2) + m10 * p2___2) + m14 * p3___1;
#line 40443
      (*(q + i___0))[3] = ((m3 * p0___2 + m7 * p1___2) + m11 * p2___2) + m15 * p3___1;
#line 40440
      i___0 ++;
    }
  }
#line 40447
  return;
}
}
#line 40448 "D:/a/test/177.c"
void gl_xform_points_3fv(GLuint n , float (*q)[4] , float const   *m , float (*p)[3] ) 
{ GLuint i ;
  float m0 ;
  float m4 ;
  float m8 ;
  float m12 ;
  float m1 ;
  float m5 ;
  float m9 ;
  float m13 ;
  float p0 ;
  float p1 ;
  float p2 ;
  GLuint i___0 ;
  float m2 ;
  float m6 ;
  float m10 ;
  float m14 ;
  float m3 ;
  float m7 ;
  float m11 ;
  float m15 ;
  float p0___0 ;
  float p1___0 ;
  float p2___0 ;
  float p0___1 ;
  float p1___1 ;
  float p2___1 ;

  {
#line 40453
  m0 = (float )*(m + 0);
#line 40453
  m4 = (float )*(m + 4);
#line 40453
  m8 = (float )*(m + 8);
#line 40453
  m12 = (float )*(m + 12);
#line 40454
  m1 = (float )*(m + 1);
#line 40454
  m5 = (float )*(m + 5);
#line 40454
  m9 = (float )*(m + 9);
#line 40454
  m13 = (float )*(m + 13);
#line 40455
  i = 0U;
#line 40455
  while (i < n) {
#line 40456
    p0 = (*(p + i))[0];
#line 40456
    p1 = (*(p + i))[1];
#line 40456
    p2 = (*(p + i))[2];
#line 40457
    (*(q + i))[0] = ((m0 * p0 + m4 * p1) + m8 * p2) + m12;
#line 40458
    (*(q + i))[1] = ((m1 * p0 + m5 * p1) + m9 * p2) + m13;
#line 40455
    i ++;
  }
#line 40463
  m2 = (float )*(m + 2);
#line 40463
  m6 = (float )*(m + 6);
#line 40463
  m10 = (float )*(m + 10);
#line 40463
  m14 = (float )*(m + 14);
#line 40464
  m3 = (float )*(m + 3);
#line 40464
  m7 = (float )*(m + 7);
#line 40464
  m11 = (float )*(m + 11);
#line 40464
  m15 = (float )*(m + 15);
#line 40465
  if (m3 == 0.0F) {
#line 40465
    if (m7 == 0.0F) {
#line 40465
      if (m11 == 0.0F) {
#line 40465
        if (m15 == 1.0F) {
#line 40466
          i___0 = 0U;
#line 40466
          while (i___0 < n) {
#line 40467
            p0___0 = (*(p + i___0))[0];
#line 40467
            p1___0 = (*(p + i___0))[1];
#line 40467
            p2___0 = (*(p + i___0))[2];
#line 40468
            (*(q + i___0))[2] = ((m2 * p0___0 + m6 * p1___0) + m10 * p2___0) + m14;
#line 40469
            (*(q + i___0))[3] = 1.0F;
#line 40466
            i___0 ++;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 40473
    i___0 = 0U;
#line 40473
    while (i___0 < n) {
#line 40474
      p0___1 = (*(p + i___0))[0];
#line 40474
      p1___1 = (*(p + i___0))[1];
#line 40474
      p2___1 = (*(p + i___0))[2];
#line 40475
      (*(q + i___0))[2] = ((m2 * p0___1 + m6 * p1___1) + m10 * p2___1) + m14;
#line 40476
      (*(q + i___0))[3] = ((m3 * p0___1 + m7 * p1___1) + m11 * p2___1) + m15;
#line 40473
      i___0 ++;
    }
  }
#line 40480
  return;
}
}
#line 40482 "D:/a/test/177.c"
void gl_xform_normals_3fv(GLuint n , float (*v)[3] , float const   *m , float (*u)[3] ,
                          GLboolean normalize ) 
{ GLuint i ;
  float m0 ;
  float m4 ;
  float m8 ;
  float m1 ;
  float m5 ;
  float m9 ;
  float m2 ;
  float m6 ;
  float m10 ;
  GLdouble tx ;
  GLdouble ty ;
  GLdouble tz ;
  float ux ;
  float uy ;
  float uz ;
  GLdouble len ;
  GLdouble scale ;
  int tmp___0 ;
  GLuint i___0 ;
  float m0___0 ;
  float m4___0 ;
  float m8___0 ;
  float m1___0 ;
  float m5___0 ;
  float m9___0 ;
  float m2___0 ;
  float m6___0 ;
  float m10___0 ;
  float ux___0 ;
  float uy___0 ;
  float uz___0 ;

  {
#line 40485
  if (normalize) {
#line 40487
    m0 = (float )*(m + 0);
#line 40487
    m4 = (float )*(m + 4);
#line 40487
    m8 = (float )*(m + 8);
#line 40488
    m1 = (float )*(m + 1);
#line 40488
    m5 = (float )*(m + 5);
#line 40488
    m9 = (float )*(m + 9);
#line 40489
    m2 = (float )*(m + 2);
#line 40489
    m6 = (float )*(m + 6);
#line 40489
    m10 = (float )*(m + 10);
#line 40490
    i = 0U;
#line 40490
    while (i < n) {
#line 40493
      ux = (*(u + i))[0];
#line 40493
      uy = (*(u + i))[1];
#line 40493
      uz = (*(u + i))[2];
#line 40494
      tx = (double )((ux * m0 + uy * m1) + uz * m2);
#line 40495
      ty = (double )((ux * m4 + uy * m5) + uz * m6);
#line 40496
      tz = (double )((ux * m8 + uy * m9) + uz * m10);
#line 40500
      tmp___0 = GL_SQRT((tx * tx + ty * ty) + tz * tz);
#line 40500
      len = (double )tmp___0;
#line 40501
      if (len > 1E-30) {
#line 40501
        scale = 1.0 / len;
      } else {
#line 40501
        scale = 1.0;
      }
#line 40502
      (*(v + i))[0] = (float )(tx * scale);
#line 40503
      (*(v + i))[1] = (float )(ty * scale);
#line 40504
      (*(v + i))[2] = (float )(tz * scale);
#line 40490
      i ++;
    }
  } else {
#line 40510
    m0___0 = (float )*(m + 0);
#line 40510
    m4___0 = (float )*(m + 4);
#line 40510
    m8___0 = (float )*(m + 8);
#line 40511
    m1___0 = (float )*(m + 1);
#line 40511
    m5___0 = (float )*(m + 5);
#line 40511
    m9___0 = (float )*(m + 9);
#line 40512
    m2___0 = (float )*(m + 2);
#line 40512
    m6___0 = (float )*(m + 6);
#line 40512
    m10___0 = (float )*(m + 10);
#line 40513
    i___0 = 0U;
#line 40513
    while (i___0 < n) {
#line 40514
      ux___0 = (*(u + i___0))[0];
#line 40514
      uy___0 = (*(u + i___0))[1];
#line 40514
      uz___0 = (*(u + i___0))[2];
#line 40515
      (*(v + i___0))[0] = (ux___0 * m0___0 + uy___0 * m1___0) + uz___0 * m2___0;
#line 40516
      (*(v + i___0))[1] = (ux___0 * m4___0 + uy___0 * m5___0) + uz___0 * m6___0;
#line 40517
      (*(v + i___0))[2] = (ux___0 * m8___0 + uy___0 * m9___0) + uz___0 * m10___0;
#line 40513
      i___0 ++;
    }
  }
#line 40520
  return;
}
}
#line 40522 "D:/a/test/177.c"
void gl_transform_vector(float *u , float const   *v , float const   *m ) 
{ float v0 ;
  float v1 ;
  float v2 ;
  float v3 ;

  {
#line 40524
  v0 = (float )*(v + 0);
#line 40524
  v1 = (float )*(v + 1);
#line 40524
  v2 = (float )*(v + 2);
#line 40524
  v3 = (float )*(v + 3);
#line 40526
  *(u + 0) = ((v0 * (float )*(m + 0) + v1 * (float )*(m + 1)) + v2 * (float )*(m + 2)) + v3 * (float )*(m + 3);
#line 40527
  *(u + 1) = ((v0 * (float )*(m + 4) + v1 * (float )*(m + 5)) + v2 * (float )*(m + 6)) + v3 * (float )*(m + 7);
#line 40528
  *(u + 2) = ((v0 * (float )*(m + 8) + v1 * (float )*(m + 9)) + v2 * (float )*(m + 10)) + v3 * (float )*(m + 11);
#line 40529
  *(u + 3) = ((v0 * (float )*(m + 12) + v1 * (float )*(m + 13)) + v2 * (float )*(m + 14)) + v3 * (float )*(m + 15);
#line 40531
  return;
}
}
#line 40532 "D:/a/test/177.c"
int main(int argc , char **argv ) 
{ OSMesaContext ctx ;
  void *buffer ;
  int frames ;
  char *ppmFile ;
  char *meshFile ;
  char *intermediateResultsFile ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 40536
  frames = 1000;
#line 40537
  ppmFile = (char *)"mesa.ppm";
#line 40538
  meshFile = (char *)"mesa.mesh";
#line 40539
  intermediateResultsFile = (char *)"mesa.log";
#line 40541
  i = 1;
#line 40541
  while (i < argc) {
#line 40542
    tmp___2 = strcmp((char const   *)*(argv + i), "-frames");
#line 40542
    if (tmp___2 == 0) {
#line 40543
      if (i + 1 >= argc) {
#line 40544
        printf("Error:  missing argument after -frames\n");
#line 40545
        return (1);
      }
#line 40547
      frames = atoi((char const   *)*(argv + (i + 1)));
#line 40548
      i ++;
#line 40549
      if (frames <= 0) {
#line 40550
        printf("Error:  number of frames must be >= 1\n");
#line 40551
        return (1);
      }
    } else {
#line 40554
      tmp___1 = strcmp((char const   *)*(argv + i), "-ppmfile");
#line 40554
      if (tmp___1 == 0) {
#line 40555
        if (i + 1 >= argc) {
#line 40556
          printf("Error:  missing argument after -ppmfile\n");
#line 40557
          return (1);
        }
#line 40559
        ppmFile = *(argv + (i + 1));
#line 40560
        i ++;
      } else {
#line 40562
        tmp___0 = strcmp((char const   *)*(argv + i), "-meshfile");
#line 40562
        if (tmp___0 == 0) {
#line 40563
          if (i + 1 >= argc) {
#line 40564
            printf("Error:  missing argument after -meshfile\n");
#line 40565
            return (1);
          }
#line 40567
          meshFile = *(argv + (i + 1));
#line 40568
          i ++;
        } else {
#line 40571
          printf("Error:  unexpect command line parameter: %s\n", *(argv + i));
#line 40572
          return (1);
        }
      }
    }
#line 40541
    i ++;
  }
#line 40575
  ctx = OSMesaCreateContext(6408, (struct osmesa_context *)((void *)0));
#line 40576
  buffer = malloc(5242880U);//46
#line 40577
  OSMesaMakeCurrent(ctx, buffer, 5121, 1280, 1024);
#line 40578
  Init();
#line 40579
  ReadMesh((char const   *)meshFile);
#line 40580
  Render(frames, 1280, 1024, (void const   *)buffer);
#line 40581
  WriteImage((char const   *)ppmFile, 1280, 1024, (void const   *)buffer);
#line 40582
  free(buffer);
#line 40583
  OSMesaDestroyContext(ctx);
#line 40584
  return (0);
}
}
#line 40586 "D:/a/test/177.c"
static void init_exec_pointers(struct gl_api_table *table ) 
{ 

  {
#line 40588
  table->Accum = & gl_Accum;
#line 40589
  table->AlphaFunc = & gl_AlphaFunc;
#line 40590
  table->AreTexturesResident = & gl_AreTexturesResident;
#line 40591
  table->ArrayElement = & gl_ArrayElement;
#line 40592
  table->Begin = & gl_Begin;
#line 40593
  table->BindTexture = & gl_BindTexture;
#line 40594
  table->Bitmap = & gl_Bitmap;
#line 40595
  table->BlendColor = & gl_BlendColor;
#line 40596
  table->BlendEquation = & gl_BlendEquation;
#line 40597
  table->BlendFunc = & gl_BlendFunc;
#line 40598
  table->CallList = & gl_CallList;
#line 40599
  table->CallLists = & gl_CallLists;
#line 40600
  table->Clear = & gl_Clear;
#line 40601
  table->ClearAccum = & gl_ClearAccum;
#line 40602
  table->ClearColor = & gl_ClearColor;
#line 40603
  table->ClearDepth = & gl_ClearDepth;
#line 40604
  table->ClearIndex = & gl_ClearIndex;
#line 40605
  table->ClearStencil = & gl_ClearStencil;
#line 40606
  table->ClipPlane = & gl_ClipPlane;
#line 40607
  table->Color3f = & gl_Color3f;
#line 40608
  table->Color3fv = & gl_Color3fv;
#line 40609
  table->Color4f = & gl_Color4f;
#line 40610
  table->Color4fv = & gl_Color4fv;
#line 40611
  table->Color4ub = & gl_Color4ub;
#line 40612
  table->Color4ubv = & gl_Color4ubv;
#line 40613
  table->ColorMask = & gl_ColorMask;
#line 40614
  table->ColorMaterial = & gl_ColorMaterial;
#line 40615
  table->ColorPointer = & gl_ColorPointer;
#line 40616
  table->ColorTable = & gl_ColorTable;
#line 40617
  table->ColorSubTable = & gl_ColorSubTable;
#line 40618
  table->CopyPixels = & gl_CopyPixels;
#line 40619
  table->CopyTexImage1D = & gl_CopyTexImage1D;
#line 40620
  table->CopyTexImage2D = & gl_CopyTexImage2D;
#line 40621
  table->CopyTexSubImage1D = & gl_CopyTexSubImage1D;
#line 40622
  table->CopyTexSubImage2D = & gl_CopyTexSubImage2D;
#line 40623
  table->CopyTexSubImage3DEXT = & gl_CopyTexSubImage3DEXT;
#line 40624
  table->CullFace = & gl_CullFace;
#line 40625
  table->DeleteLists = & gl_DeleteLists;
#line 40626
  table->DeleteTextures = & gl_DeleteTextures;
#line 40627
  table->DepthFunc = & gl_DepthFunc;
#line 40628
  table->DepthMask = & gl_DepthMask;
#line 40629
  table->DepthRange = & gl_DepthRange;
#line 40630
  table->Disable = & gl_Disable;
#line 40631
  table->DisableClientState = & gl_DisableClientState;
#line 40632
  table->DrawArrays = & gl_DrawArrays;
#line 40633
  table->DrawBuffer = & gl_DrawBuffer;
#line 40634
  table->DrawElements = & gl_DrawElements;
#line 40635
  table->DrawPixels = & gl_DrawPixels;
#line 40636
  table->EdgeFlag = & gl_EdgeFlag;
#line 40637
  table->EdgeFlagPointer = & gl_EdgeFlagPointer;
#line 40638
  table->Enable = & gl_Enable;
#line 40639
  table->EnableClientState = & gl_EnableClientState;
#line 40640
  table->End = & gl_End;
#line 40641
  table->EndList = & gl_EndList;
#line 40642
  table->EvalCoord1f = & gl_EvalCoord1f;
#line 40643
  table->EvalCoord2f = & gl_EvalCoord2f;
#line 40644
  table->EvalMesh1 = & gl_EvalMesh1;
#line 40645
  table->EvalMesh2 = & gl_EvalMesh2;
#line 40646
  table->EvalPoint1 = & gl_EvalPoint1;
#line 40647
  table->EvalPoint2 = & gl_EvalPoint2;
#line 40648
  table->FeedbackBuffer = & gl_FeedbackBuffer;
#line 40649
  table->Finish = & gl_Finish;
#line 40650
  table->Flush = & gl_Flush;
#line 40651
  table->Fogfv = & gl_Fogfv;
#line 40652
  table->FrontFace = & gl_FrontFace;
#line 40653
  table->Frustum = & gl_Frustum;
#line 40654
  table->GenLists = & gl_GenLists;
#line 40655
  table->GenTextures = & gl_GenTextures;
#line 40656
  table->GetBooleanv = & gl_GetBooleanv;
#line 40657
  table->GetClipPlane = & gl_GetClipPlane;
#line 40658
  table->GetColorTable = & gl_GetColorTable;
#line 40659
  table->GetColorTableParameteriv = & gl_GetColorTableParameteriv;
#line 40660
  table->GetDoublev = & gl_GetDoublev;
#line 40661
  table->GetError = & gl_GetError;
#line 40662
  table->GetFloatv = & gl_GetFloatv;
#line 40663
  table->GetIntegerv = & gl_GetIntegerv;
#line 40664
  table->GetPointerv = & gl_GetPointerv;
#line 40665
  table->GetLightfv = & gl_GetLightfv;
#line 40666
  table->GetLightiv = & gl_GetLightiv;
#line 40667
  table->GetMapdv = & gl_GetMapdv;
#line 40668
  table->GetMapfv = & gl_GetMapfv;
#line 40669
  table->GetMapiv = & gl_GetMapiv;
#line 40670
  table->GetMaterialfv = & gl_GetMaterialfv;
#line 40671
  table->GetMaterialiv = & gl_GetMaterialiv;
#line 40672
  table->GetPixelMapfv = & gl_GetPixelMapfv;
#line 40673
  table->GetPixelMapuiv = & gl_GetPixelMapuiv;
#line 40674
  table->GetPixelMapusv = & gl_GetPixelMapusv;
#line 40675
  table->GetPolygonStipple = & gl_GetPolygonStipple;
#line 40676
  table->GetString = & gl_GetString;
#line 40677
  table->GetTexEnvfv = & gl_GetTexEnvfv;
#line 40678
  table->GetTexEnviv = & gl_GetTexEnviv;
#line 40679
  table->GetTexGendv = & gl_GetTexGendv;
#line 40680
  table->GetTexGenfv = & gl_GetTexGenfv;
#line 40681
  table->GetTexGeniv = & gl_GetTexGeniv;
#line 40682
  table->GetTexImage = & gl_GetTexImage;
#line 40683
  table->GetTexLevelParameterfv = & gl_GetTexLevelParameterfv;
#line 40684
  table->GetTexLevelParameteriv = & gl_GetTexLevelParameteriv;
#line 40685
  table->GetTexParameterfv = & gl_GetTexParameterfv;
#line 40686
  table->GetTexParameteriv = & gl_GetTexParameteriv;
#line 40687
  table->Hint = & gl_Hint;
#line 40688
  table->Indexf = & gl_Indexf;
#line 40689
  table->Indexi = & gl_Indexi;
#line 40690
  table->IndexMask = & gl_IndexMask;
#line 40691
  table->IndexPointer = & gl_IndexPointer;
#line 40692
  table->InitNames = & gl_InitNames;
#line 40693
  table->InterleavedArrays = & gl_InterleavedArrays;
#line 40694
  table->IsEnabled = & gl_IsEnabled;
#line 40695
  table->IsList = & gl_IsList;
#line 40696
  table->IsTexture = & gl_IsTexture;
#line 40697
  table->LightModelfv = & gl_LightModelfv;
#line 40698
  table->Lightfv = & gl_Lightfv;
#line 40699
  table->LineStipple = & gl_LineStipple;
#line 40700
  table->LineWidth = & gl_LineWidth;
#line 40701
  table->ListBase = & gl_ListBase;
#line 40702
  table->LoadIdentity = & gl_LoadIdentity;
#line 40703
  table->LoadMatrixf = & gl_LoadMatrixf;
#line 40704
  table->LoadName = & gl_LoadName;
#line 40705
  table->LogicOp = & gl_LogicOp;
#line 40706
  table->Map1f = & gl_Map1f;
#line 40707
  table->Map2f = & gl_Map2f;
#line 40708
  table->MapGrid1f = & gl_MapGrid1f;
#line 40709
  table->MapGrid2f = & gl_MapGrid2f;
#line 40710
  table->Materialfv = & gl_Materialfv;
#line 40711
  table->MatrixMode = & gl_MatrixMode;
#line 40712
  table->MultMatrixf = & gl_MultMatrixf;
#line 40713
  table->NewList = & gl_NewList;
#line 40714
  table->Normal3f = & gl_Normal3f;
#line 40715
  table->NormalPointer = & gl_NormalPointer;
#line 40716
  table->Normal3fv = & gl_Normal3fv;
#line 40717
  table->Ortho = & gl_Ortho;
#line 40718
  table->PassThrough = & gl_PassThrough;
#line 40719
  table->PixelMapfv = & gl_PixelMapfv;
#line 40720
  table->PixelStorei = & gl_PixelStorei;
#line 40721
  table->PixelTransferf = & gl_PixelTransferf;
#line 40722
  table->PixelZoom = & gl_PixelZoom;
#line 40723
  table->PointSize = & gl_PointSize;
#line 40724
  table->PolygonMode = & gl_PolygonMode;
#line 40725
  table->PolygonOffset = & gl_PolygonOffset;
#line 40726
  table->PolygonStipple = & gl_PolygonStipple;
#line 40727
  table->PopAttrib = & gl_PopAttrib;
#line 40728
  table->PopClientAttrib = & gl_PopClientAttrib;
#line 40729
  table->PopMatrix = & gl_PopMatrix;
#line 40730
  table->PopName = & gl_PopName;
#line 40731
  table->PrioritizeTextures = & gl_PrioritizeTextures;
#line 40732
  table->PushAttrib = & gl_PushAttrib;
#line 40733
  table->PushClientAttrib = & gl_PushClientAttrib;
#line 40734
  table->PushMatrix = & gl_PushMatrix;
#line 40735
  table->PushName = & gl_PushName;
#line 40736
  table->RasterPos4f = & gl_RasterPos4f;
#line 40737
  table->ReadBuffer = & gl_ReadBuffer;
#line 40738
  table->ReadPixels = & gl_ReadPixels;
#line 40739
  table->Rectf = & gl_Rectf;
#line 40740
  table->RenderMode = & gl_RenderMode;
#line 40741
  table->Rotatef = & gl_Rotatef;
#line 40742
  table->Scalef = & gl_Scalef;
#line 40743
  table->Scissor = & gl_Scissor;
#line 40744
  table->SelectBuffer = & gl_SelectBuffer;
#line 40745
  table->ShadeModel = & gl_ShadeModel;
#line 40746
  table->StencilFunc = & gl_StencilFunc;
#line 40747
  table->StencilMask = & gl_StencilMask;
#line 40748
  table->StencilOp = & gl_StencilOp;
#line 40749
  table->TexCoord2f = & gl_TexCoord2f;
#line 40750
  table->TexCoord4f = & gl_TexCoord4f;
#line 40751
  table->TexCoordPointer = & gl_TexCoordPointer;
#line 40752
  table->TexEnvfv = & gl_TexEnvfv;
#line 40753
  table->TexGenfv = & gl_TexGenfv;
#line 40754
  table->TexImage1D = & gl_TexImage1D;
#line 40755
  table->TexImage2D = & gl_TexImage2D;
#line 40756
  table->TexImage3DEXT = & gl_TexImage3DEXT;
#line 40757
  table->TexSubImage1D = & gl_TexSubImage1D;
#line 40758
  table->TexSubImage2D = & gl_TexSubImage2D;
#line 40759
  table->TexSubImage3DEXT = & gl_TexSubImage3DEXT;
#line 40760
  table->PointParameterfvEXT = & gl_PointParameterfvEXT;
#line 40761
  table->TexParameterfv = & gl_TexParameterfv;
#line 40762
  table->Translatef = & gl_Translatef;
#line 40763
  table->Vertex2f = & gl_vertex2f_nop;
#line 40764
  table->Vertex3f = & gl_vertex3f_nop;
#line 40765
  table->Vertex4f = & gl_vertex4f_nop;
#line 40766
  table->Vertex3fv = (void (*)(GLcontext * , float const   * ))(& gl_vertex3fv_nop);
#line 40767
  table->VertexPointer = & gl_VertexPointer;
#line 40768
  table->Viewport = & gl_Viewport;
#line 40769
  table->WindowPos4fMESA = (void (*)(GLcontext * , float  , float  , float  , float  ))(& gl_WindowPos4fMESA);
#line 40770
  table->ResizeBuffersMESA = & gl_ResizeBuffersMESA;
#line 40771
  return;
}
}
#line 40772 "D:/a/test/177.c"
static void init_dlist_pointers(struct gl_api_table *table ) 
{ 

  {
#line 40774
  table->Accum = & gl_save_Accum;
#line 40775
  table->AlphaFunc = & gl_save_AlphaFunc;
#line 40776
  table->AreTexturesResident = & gl_AreTexturesResident;
#line 40777
  table->ArrayElement = & gl_save_ArrayElement;
#line 40778
  table->Begin = & gl_save_Begin;
#line 40779
  table->BindTexture = & gl_save_BindTexture;
#line 40780
  table->Bitmap = & gl_save_Bitmap;
#line 40781
  table->BlendColor = & gl_save_BlendColor;
#line 40782
  table->BlendEquation = & gl_save_BlendEquation;
#line 40783
  table->BlendFunc = & gl_save_BlendFunc;
#line 40784
  table->CallList = & gl_save_CallList;
#line 40785
  table->CallLists = & gl_save_CallLists;
#line 40786
  table->Clear = & gl_save_Clear;
#line 40787
  table->ClearAccum = & gl_save_ClearAccum;
#line 40788
  table->ClearColor = & gl_save_ClearColor;
#line 40789
  table->ClearDepth = & gl_save_ClearDepth;
#line 40790
  table->ClearIndex = & gl_save_ClearIndex;
#line 40791
  table->ClearStencil = & gl_save_ClearStencil;
#line 40792
  table->ClipPlane = & gl_save_ClipPlane;
#line 40793
  table->Color3f = & gl_save_Color3f;
#line 40794
  table->Color3fv = & gl_save_Color3fv;
#line 40795
  table->Color4f = & gl_save_Color4f;
#line 40796
  table->Color4fv = & gl_save_Color4fv;
#line 40797
  table->Color4ub = & gl_save_Color4ub;
#line 40798
  table->Color4ubv = & gl_save_Color4ubv;
#line 40799
  table->ColorMask = & gl_save_ColorMask;
#line 40800
  table->ColorMaterial = & gl_save_ColorMaterial;
#line 40801
  table->ColorPointer = & gl_ColorPointer;
#line 40802
  table->ColorTable = & gl_save_ColorTable;
#line 40803
  table->ColorSubTable = & gl_save_ColorSubTable;
#line 40804
  table->CopyPixels = & gl_save_CopyPixels;
#line 40805
  table->CopyTexImage1D = & gl_save_CopyTexImage1D;
#line 40806
  table->CopyTexImage2D = & gl_save_CopyTexImage2D;
#line 40807
  table->CopyTexSubImage1D = & gl_save_CopyTexSubImage1D;
#line 40808
  table->CopyTexSubImage2D = & gl_save_CopyTexSubImage2D;
#line 40809
  table->CopyTexSubImage3DEXT = & gl_save_CopyTexSubImage3DEXT;
#line 40810
  table->CullFace = & gl_save_CullFace;
#line 40811
  table->DeleteLists = & gl_DeleteLists;
#line 40812
  table->DeleteTextures = & gl_DeleteTextures;
#line 40813
  table->DepthFunc = & gl_save_DepthFunc;
#line 40814
  table->DepthMask = & gl_save_DepthMask;
#line 40815
  table->DepthRange = & gl_save_DepthRange;
#line 40816
  table->Disable = & gl_save_Disable;
#line 40817
  table->DisableClientState = & gl_DisableClientState;
#line 40818
  table->DrawArrays = & gl_save_DrawArrays;
#line 40819
  table->DrawBuffer = & gl_save_DrawBuffer;
#line 40820
  table->DrawElements = & gl_save_DrawElements;
#line 40821
  table->DrawPixels = & gl_DrawPixels;
#line 40822
  table->EdgeFlag = & gl_save_EdgeFlag;
#line 40823
  table->EdgeFlagPointer = & gl_EdgeFlagPointer;
#line 40824
  table->Enable = & gl_save_Enable;
#line 40825
  table->EnableClientState = & gl_EnableClientState;
#line 40826
  table->End = & gl_save_End;
#line 40827
  table->EndList = & gl_EndList;
#line 40828
  table->EvalCoord1f = & gl_save_EvalCoord1f;
#line 40829
  table->EvalCoord2f = & gl_save_EvalCoord2f;
#line 40830
  table->EvalMesh1 = & gl_save_EvalMesh1;
#line 40831
  table->EvalMesh2 = & gl_save_EvalMesh2;
#line 40832
  table->EvalPoint1 = & gl_save_EvalPoint1;
#line 40833
  table->EvalPoint2 = & gl_save_EvalPoint2;
#line 40834
  table->FeedbackBuffer = & gl_FeedbackBuffer;
#line 40835
  table->Finish = & gl_Finish;
#line 40836
  table->Flush = & gl_Flush;
#line 40837
  table->Fogfv = & gl_save_Fogfv;
#line 40838
  table->FrontFace = & gl_save_FrontFace;
#line 40839
  table->Frustum = & gl_save_Frustum;
#line 40840
  table->GenLists = & gl_GenLists;
#line 40841
  table->GenTextures = & gl_GenTextures;
#line 40842
  table->GetBooleanv = & gl_GetBooleanv;
#line 40843
  table->GetClipPlane = & gl_GetClipPlane;
#line 40844
  table->GetColorTable = & gl_GetColorTable;
#line 40845
  table->GetColorTableParameteriv = & gl_GetColorTableParameteriv;
#line 40846
  table->GetDoublev = & gl_GetDoublev;
#line 40847
  table->GetError = & gl_GetError;
#line 40848
  table->GetFloatv = & gl_GetFloatv;
#line 40849
  table->GetIntegerv = & gl_GetIntegerv;
#line 40850
  table->GetString = & gl_GetString;
#line 40851
  table->GetLightfv = & gl_GetLightfv;
#line 40852
  table->GetLightiv = & gl_GetLightiv;
#line 40853
  table->GetMapdv = & gl_GetMapdv;
#line 40854
  table->GetMapfv = & gl_GetMapfv;
#line 40855
  table->GetMapiv = & gl_GetMapiv;
#line 40856
  table->GetMaterialfv = & gl_GetMaterialfv;
#line 40857
  table->GetMaterialiv = & gl_GetMaterialiv;
#line 40858
  table->GetPixelMapfv = & gl_GetPixelMapfv;
#line 40859
  table->GetPixelMapuiv = & gl_GetPixelMapuiv;
#line 40860
  table->GetPixelMapusv = & gl_GetPixelMapusv;
#line 40861
  table->GetPointerv = & gl_GetPointerv;
#line 40862
  table->GetPolygonStipple = & gl_GetPolygonStipple;
#line 40863
  table->GetTexEnvfv = & gl_GetTexEnvfv;
#line 40864
  table->GetTexEnviv = & gl_GetTexEnviv;
#line 40865
  table->GetTexGendv = & gl_GetTexGendv;
#line 40866
  table->GetTexGenfv = & gl_GetTexGenfv;
#line 40867
  table->GetTexGeniv = & gl_GetTexGeniv;
#line 40868
  table->GetTexImage = & gl_GetTexImage;
#line 40869
  table->GetTexLevelParameterfv = & gl_GetTexLevelParameterfv;
#line 40870
  table->GetTexLevelParameteriv = & gl_GetTexLevelParameteriv;
#line 40871
  table->GetTexParameterfv = & gl_GetTexParameterfv;
#line 40872
  table->GetTexParameteriv = & gl_GetTexParameteriv;
#line 40873
  table->Hint = & gl_save_Hint;
#line 40874
  table->IndexMask = & gl_save_IndexMask;
#line 40875
  table->Indexf = & gl_save_Indexf;
#line 40876
  table->Indexi = & gl_save_Indexi;
#line 40877
  table->IndexPointer = & gl_IndexPointer;
#line 40878
  table->InitNames = & gl_save_InitNames;
#line 40879
  table->InterleavedArrays = & gl_save_InterleavedArrays;
#line 40880
  table->IsEnabled = & gl_IsEnabled;
#line 40881
  table->IsTexture = & gl_IsTexture;
#line 40882
  table->IsList = & gl_IsList;
#line 40883
  table->LightModelfv = & gl_save_LightModelfv;
#line 40884
  table->Lightfv = & gl_save_Lightfv;
#line 40885
  table->LineStipple = & gl_save_LineStipple;
#line 40886
  table->LineWidth = & gl_save_LineWidth;
#line 40887
  table->ListBase = & gl_save_ListBase;
#line 40888
  table->LoadIdentity = & gl_save_LoadIdentity;
#line 40889
  table->LoadMatrixf = & gl_save_LoadMatrixf;
#line 40890
  table->LoadName = & gl_save_LoadName;
#line 40891
  table->LogicOp = & gl_save_LogicOp;
#line 40892
  table->Map1f = & gl_save_Map1f;
#line 40893
  table->Map2f = & gl_save_Map2f;
#line 40894
  table->MapGrid1f = & gl_save_MapGrid1f;
#line 40895
  table->MapGrid2f = & gl_save_MapGrid2f;
#line 40896
  table->Materialfv = & gl_save_Materialfv;
#line 40897
  table->MatrixMode = & gl_save_MatrixMode;
#line 40898
  table->MultMatrixf = & gl_save_MultMatrixf;
#line 40899
  table->NewList = & gl_save_NewList;
#line 40900
  table->Normal3f = & gl_save_Normal3f;
#line 40901
  table->Normal3fv = (void (*)(GLcontext * , float const   * ))(& gl_save_Normal3fv);
#line 40902
  table->NormalPointer = & gl_NormalPointer;
#line 40903
  table->Ortho = & gl_save_Ortho;
#line 40904
  table->PointParameterfvEXT = & gl_save_PointParameterfvEXT;
#line 40905
  table->PassThrough = & gl_save_PassThrough;
#line 40906
  table->PixelMapfv = & gl_save_PixelMapfv;
#line 40907
  table->PixelStorei = & gl_PixelStorei;
#line 40908
  table->PixelTransferf = & gl_save_PixelTransferf;
#line 40909
  table->PixelZoom = & gl_save_PixelZoom;
#line 40910
  table->PointSize = & gl_save_PointSize;
#line 40911
  table->PolygonMode = & gl_save_PolygonMode;
#line 40912
  table->PolygonOffset = & gl_save_PolygonOffset;
#line 40913
  table->PolygonStipple = & gl_save_PolygonStipple;
#line 40914
  table->PopAttrib = & gl_save_PopAttrib;
#line 40915
  table->PopClientAttrib = & gl_PopClientAttrib;
#line 40916
  table->PopMatrix = & gl_save_PopMatrix;
#line 40917
  table->PopName = & gl_save_PopName;
#line 40918
  table->PrioritizeTextures = & gl_save_PrioritizeTextures;
#line 40919
  table->PushAttrib = & gl_save_PushAttrib;
#line 40920
  table->PushClientAttrib = & gl_PushClientAttrib;
#line 40921
  table->PushMatrix = & gl_save_PushMatrix;
#line 40922
  table->PushName = & gl_save_PushName;
#line 40923
  table->RasterPos4f = & gl_save_RasterPos4f;
#line 40924
  table->ReadBuffer = & gl_save_ReadBuffer;
#line 40925
  table->ReadPixels = & gl_ReadPixels;
#line 40926
  table->Rectf = & gl_save_Rectf;
#line 40927
  table->RenderMode = & gl_RenderMode;
#line 40928
  table->Rotatef = & gl_save_Rotatef;
#line 40929
  table->Scalef = & gl_save_Scalef;
#line 40930
  table->Scissor = & gl_save_Scissor;
#line 40931
  table->SelectBuffer = & gl_SelectBuffer;
#line 40932
  table->ShadeModel = & gl_save_ShadeModel;
#line 40933
  table->StencilFunc = & gl_save_StencilFunc;
#line 40934
  table->StencilMask = & gl_save_StencilMask;
#line 40935
  table->StencilOp = & gl_save_StencilOp;
#line 40936
  table->TexCoord2f = & gl_save_TexCoord2f;
#line 40937
  table->TexCoord4f = & gl_save_TexCoord4f;
#line 40938
  table->TexCoordPointer = & gl_TexCoordPointer;
#line 40939
  table->TexEnvfv = & gl_save_TexEnvfv;
#line 40940
  table->TexGenfv = & gl_save_TexGenfv;
#line 40941
  table->TexImage1D = & gl_save_TexImage1D;
#line 40942
  table->TexImage2D = & gl_save_TexImage2D;
#line 40943
  table->TexImage3DEXT = & gl_save_TexImage3DEXT;
#line 40944
  table->TexSubImage1D = & gl_save_TexSubImage1D;
#line 40945
  table->TexSubImage2D = & gl_save_TexSubImage2D;
#line 40946
  table->TexSubImage3DEXT = & gl_save_TexSubImage3DEXT;
#line 40947
  table->TexParameterfv = & gl_save_TexParameterfv;
#line 40948
  table->Translatef = & gl_save_Translatef;
#line 40949
  table->Vertex2f = & gl_save_Vertex2f;
#line 40950
  table->Vertex3f = & gl_save_Vertex3f;
#line 40951
  table->Vertex4f = & gl_save_Vertex4f;
#line 40952
  table->Vertex3fv = (void (*)(GLcontext * , float const   * ))(& gl_save_Vertex3fv);
#line 40953
  table->VertexPointer = & gl_VertexPointer;
#line 40954
  table->Viewport = & gl_save_Viewport;
#line 40955
  table->WindowPos4fMESA = & gl_save_WindowPos4fMESA;
#line 40956
  table->ResizeBuffersMESA = & gl_ResizeBuffersMESA;
#line 40957
  return;
}
}
