/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
#line 14 "/usr/include/sys/lock.h"
typedef void *_LOCK_T;
#line 36 "/usr/include/sys/_types.h"
typedef long long _off64_t;
#line 44 "/usr/include/sys/_types.h"
typedef long _fpos_t;
#line 50 "/usr/include/sys/_types.h"
typedef _off64_t _fpos64_t;
#line 56 "/usr/include/sys/_types.h"
typedef int _ssize_t;
#line 354 "/usr/lib/gcc/i686-pc-cygwin/3.4.4/include/stddef.h"
typedef unsigned int wint_t;
#line 67 "/usr/include/sys/_types.h"
union __anonunion___value_2 {
   wint_t __wch ;
   unsigned char __wchb[4] ;
};
#line 67 "/usr/include/sys/_types.h"
struct __anonstruct__mbstate_t_1 {
   int __count ;
   union __anonunion___value_2 __value ;
};
#line 67 "/usr/include/sys/_types.h"
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
#line 79 "/usr/include/sys/_types.h"
typedef _LOCK_T _flock_t;
#line 21 "/usr/include/sys/reent.h"
typedef unsigned long __ULong;
#line 37
struct _reent;
#line 37
struct _reent;
#line 44 "/usr/include/sys/reent.h"
struct _Bigint {
   struct _Bigint *_next ;
   int _k ;
   int _maxwds ;
   int _sign ;
   int _wds ;
   __ULong _x[1] ;
};
#line 52 "/usr/include/sys/reent.h"
struct __tm {
   int __tm_sec ;
   int __tm_min ;
   int __tm_hour ;
   int __tm_mday ;
   int __tm_mon ;
   int __tm_year ;
   int __tm_wday ;
   int __tm_yday ;
   int __tm_isdst ;
};
#line 71 "/usr/include/sys/reent.h"
struct _on_exit_args {
   void *_fnargs[32] ;
   void *_dso_handle[32] ;
   __ULong _fntypes ;
   __ULong _is_cxa ;
};
#line 89 "/usr/include/sys/reent.h"
struct _atexit {
   struct _atexit *_next ;
   int _ind ;
   void (*_fns[32])(void) ;
   struct _on_exit_args _on_exit_args ;
};
#line 105 "/usr/include/sys/reent.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 226 "/usr/include/sys/reent.h"
struct __sFILE64 {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   struct _reent *_data ;
   void *_cookie ;
   _ssize_t ( __attribute__((__cdecl__)) (*_read))(struct _reent * , void * , char * ,
                                                   int  ) ;
   _ssize_t ( __attribute__((__cdecl__)) (*_write))(struct _reent * , void * , char const   * ,
                                                    int  ) ;
   _fpos_t ( __attribute__((__cdecl__)) (*_seek))(struct _reent * , void * , _fpos_t  ,
                                                  int  ) ;
   int ( __attribute__((__cdecl__)) (*_close))(struct _reent * , void * ) ;
   struct __sbuf _ub ;
   unsigned char *_up ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   int _flags2 ;
   _off64_t _offset ;
   _fpos64_t ( __attribute__((__cdecl__)) (*_seek64))(struct _reent * , void * , _fpos64_t  ,
                                                      int  ) ;
   _flock_t _lock ;
   _mbstate_t _mbstate ;
};
#line 271 "/usr/include/sys/reent.h"
typedef struct __sFILE64 __FILE;
#line 277 "/usr/include/sys/reent.h"
struct _glue {
   struct _glue *_next ;
   int _niobs ;
   __FILE *_iobs ;
};
#line 305 "/usr/include/sys/reent.h"
struct _rand48 {
   unsigned short _seed[3] ;
   unsigned short _mult[3] ;
   unsigned short _add ;
};
#line 580 "/usr/include/sys/reent.h"
struct __anonstruct__reent_4 {
   unsigned int _unused_rand ;
   char *_strtok_last ;
   char _asctime_buf[26] ;
   struct __tm _localtime_buf ;
   int _gamma_signgam ;
   unsigned long long _rand_next ;
   struct _rand48 _r48 ;
   _mbstate_t _mblen_state ;
   _mbstate_t _mbtowc_state ;
   _mbstate_t _wctomb_state ;
   char _l64a_buf[8] ;
   char _signal_buf[24] ;
   int _getdate_err ;
   _mbstate_t _mbrlen_state ;
   _mbstate_t _mbrtowc_state ;
   _mbstate_t _mbsrtowcs_state ;
   _mbstate_t _wcrtomb_state ;
   _mbstate_t _wcsrtombs_state ;
   int _h_errno ;
};
#line 580 "/usr/include/sys/reent.h"
struct __anonstruct__unused_5 {
   unsigned char *_nextf[30] ;
   unsigned int _nmalloc[30] ;
};
#line 580 "/usr/include/sys/reent.h"
union __anonunion__new_3 {
   struct __anonstruct__reent_4 _reent ;
   struct __anonstruct__unused_5 _unused ;
};
#line 580 "/usr/include/sys/reent.h"
struct _reent {
   int _errno ;
   __FILE *_stdin ;
   __FILE *_stdout ;
   __FILE *_stderr ;
   int _inc ;
   char _emergency[25] ;
   int _current_category ;
   char const   *_current_locale ;
   int __sdidinit ;
   void ( __attribute__((__cdecl__)) (*__cleanup))(struct _reent * ) ;
   struct _Bigint *_result ;
   int _result_k ;
   struct _Bigint *_p5s ;
   struct _Bigint **_freelist ;
   int _cvtlen ;
   char *_cvtbuf ;
   union __anonunion__new_3 _new ;
   struct _atexit *_atexit ;
   struct _atexit _atexit0 ;
   void (**_sig_func)(int  ) ;
   struct _glue __sglue ;
   __FILE __sf[3] ;
};
#line 50 "/usr/include/stdio.h"
typedef __FILE FILE;
#line 77 "/usr/include/cygwin/signal.h"
#pragma pack(push,4)
#line 134
#pragma pack(pop)
#line 19 "/usr/include/signal.h"
struct _reent;
#line 46 "scanner.c"
/*user-defined struct start*/
struct __anonstruct_f1_neuron_22 {
   double *I ;
   double W ;
   double X ;
   double V ;
   double U ;
   double P ;
   double Q ;
   double R ;
};
#line 46 "scanner.c"
typedef struct __anonstruct_f1_neuron_22 f1_neuron;
#line 59 "scanner.c"
struct __anonstruct_xyz_23 {
   double y ;
   int reset ;
};
#line 59 "scanner.c"
typedef struct __anonstruct_xyz_23 xyz;
/*user-defined struct end*/

#line 829 "/usr/include/sys/reent.h"
//extern struct _reent *( __attribute__((__cdecl__)) __getreent)(void) ;
#line 178 "/usr/include/stdio.h"
//extern int ( /* format attribute */ __attribute__((__cdecl__)) //fprintf)(FILE * , char const   * , ...) ;
#line 180
extern int ( /* format attribute */ __attribute__((__cdecl__)) fscanf)(FILE * , char const   * 
                                                                       , ...) ;
#line 182
extern int ( /* format attribute */ __attribute__((__cdecl__)) printf)(char const   * 
                                                                       , ...) ;
#line 204
extern int ( __attribute__((__cdecl__)) ungetc)(int  , FILE * ) ;
#line 225
extern FILE *( __attribute__((__cdecl__)) fopen)(char const   *_name , char const   *_type ) ;
#line 515
extern int ( __attribute__((__cdecl__)) __srget_r)(struct _reent * , FILE * ) ;
#line 595
__inline extern int ( __attribute__((__always_inline__)) __sgetc_r)(struct _reent *__ptr ,
                                                                    FILE *__p ) ;
#line 597 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__always_inline__)) __sgetc_r)(struct _reent *__ptr ,
                                                                    FILE *__p ) 
{ int __c ;
  int tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int __c2 ;
  int tmp___2 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;

  {
#line 599
  (__p->_r) --;
#line 599
  if (__p->_r < 0) {
#line 599
    tmp = __srget_r(__ptr, __p);
#line 599
    tmp___1 = tmp;
  } else {
#line 599
    tmp___0 = __p->_p;
#line 599
    (__p->_p) ++;
#line 599
    tmp___1 = (int )*tmp___0;
  }
#line 599
  __c = tmp___1;
#line 600
  if ((int )__p->_flags & 16384) {
#line 600
    if (__c == 13) {
#line 602
      (__p->_r) --;
#line 602
      if (__p->_r < 0) {
#line 602
        tmp___2 = __srget_r(__ptr, __p);
#line 602
        tmp___4 = tmp___2;
      } else {
#line 602
        tmp___3 = __p->_p;
#line 602
        (__p->_p) ++;
#line 602
        tmp___4 = (int )*tmp___3;
      }
#line 602
      __c2 = tmp___4;
#line 603
      if (__c2 == 10) {
#line 604
        __c = __c2;
      } else {
#line 606
        ungetc(__c2, __p);
      }
    }
  }
#line 608
  return (__c);
}
}
#line 69 "/usr/include/stdlib.h"
extern int ( __attribute__((__cdecl__)) atoi)(char const   *__nptr ) ;
#line 80
//extern  __attribute__((__noreturn__)) void ( __attribute__((__cdecl__)) //exit(0))(int __status ) ;
#line 81
extern void ( __attribute__((__cdecl__)) free)(void * ) ;
#line 92
//extern void *( __attribute__((__cdecl__)) malloc)(unsigned int __size ) ;
#line 120
extern int ( __attribute__((__cdecl__)) rand)(void) ;
#line 125
extern void ( __attribute__((__cdecl__)) srand)(unsigned int __seed ) ;
#line 119 "/usr/include/math.h"
extern double fabs(double  ) ;
#line 137
extern double sqrt(double  ) ;
#line 182 "/usr/include/sys/_default_fcntl.h"
extern int open(char const   * , int   , ...) ;
#line 20 "scanner.c"
void alloc_td_bu(void) ;
#line 23 "scanner.c"
unsigned char **cimage  ;
#line 24 "scanner.c"
double **tds  ;
#line 25 "scanner.c"
double **bus  ;
#line 26 "scanner.c"
int lwidth  ;
#line 26 "scanner.c"
int lheight  ;
#line 27 "scanner.c"
int width  ;
#line 27 "scanner.c"
int height  ;
#line 27 "scanner.c"
int numinputs  ;
#line 28 "scanner.c"
long i  ;
#line 28 "scanner.c"
long j  ;
#line 30 "scanner.c"
int pass_flag  ;
#line 31 "scanner.c"
int highx[2]  ;
#line 31 "scanner.c"
int highy[2]  ;
#line 32 "scanner.c"
double highest_confidence[2]  ;
#line 33 "scanner.c"
int set_high[2]  ;
#line 39 "scanner.c"
FILE *fp;
#line 41 "scanner.c"
int winner  ;
#line 41 "scanner.c"
int numf1s  ;
#line 41 "scanner.c"
int numf2s  ;
#line 41 "scanner.c"
int resonant  ;
#line 41 "scanner.c"
int cp  ;
#line 41 "scanner.c"
int numpatterns  ;
#line 43 "scanner.c"
double a  ;
#line 43 "scanner.c"
double b  ;
#line 43 "scanner.c"
double c  ;
#line 43 "scanner.c"
double d  ;
#line 43 "scanner.c"
double theta  ;
#line 43 "scanner.c"
double delta_t  ;
#line 44 "scanner.c"
double rho  ;
#line 57 "scanner.c"
f1_neuron *f1_layer  ;
#line 64 "scanner.c"
xyz *Y  ;
#line 67 "scanner.c"
double g(int i___0 ) 
{ double result ;

  {
#line 70
  if (i___0 != winner) {
#line 71
    result = (double )0;
  } else {
#line 73
    if ((Y + i___0)->y > (double )0) {
#line 74
      result = d;
    } else {
#line 76
      result = (double )0;
    }
  }
#line 77
  return (result);
}
}
#line 80 "scanner.c"
void find_match(void) 
{ int i___0 ;

  {
#line 82
  winner = 0;
#line 83
  i___0 = 0;
#line 83
  while (i___0 < numf2s) {
#line 84
    if ((Y + i___0)->y > (Y + winner)->y) {
#line 85
      winner = i___0;
    }
#line 83
    i___0 ++;
  }
#line 86
  return;
}
}
#line 88 "scanner.c"
double simtest(void) 
{ int j___0 ;
  double sum ;
  double norm ;
  double temp_sum ;

  {
#line 93
  norm = (double )0;
#line 93
  sum = norm;
#line 94
  j___0 = 0;
#line 94
  while (j___0 < numf1s) {
#line 96
    norm += (f1_layer + j___0)->P * (f1_layer + j___0)->P;
#line 94
    j___0 ++;
  }
#line 98
  norm = sqrt(norm);
#line 99
  norm *= c;
#line 100
  sum += norm;
#line 101
  norm = (double )0;
#line 102
  j___0 = 0;
#line 102
  while (j___0 < numf1s) {
#line 104
    temp_sum = (f1_layer + j___0)->U * (f1_layer + j___0)->U;
#line 105
    norm += temp_sum;
#line 102
    j___0 ++;
  }
#line 107
  norm = sqrt(norm);
#line 108
  sum += norm;
#line 109
  j___0 = 0;
#line 109
  while (j___0 < numf1s) {
#line 110
    (f1_layer + j___0)->R = ((f1_layer + j___0)->U + c * (f1_layer + j___0)->P) / sum;
#line 109
    j___0 ++;
  }
#line 111
  norm = (double )0;
#line 112
  j___0 = 0;
#line 112
  while (j___0 < numf1s) {
#line 113
    norm += (f1_layer + j___0)->R * (f1_layer + j___0)->R;
#line 112
    j___0 ++;
  }
#line 114
  norm = sqrt(norm);
#line 118
  return (norm);
}
}
#line 122 "scanner.c"
double simtest2(void) 
{ int j___0 ;
  double Su ;
  double Sp ;
  double numerator ;
  double denom ;
  double su ;
  double sp ;
  double su2 ;
  double sp2 ;
  double sup ;
  double r ;
  double e ;
  double tmp ;
  double tmp___0 ;
  struct _reent *tmp___1 ;
  struct _reent *tmp___2 ;

  {
#line 129
  e = 0.0000000001;
#line 131
  numerator = 0.0;
#line 131
  sp2 = numerator;
#line 131
  su2 = sp2;
#line 131
  sup = su2;
#line 131
  sp = sup;
#line 131
  su = sp;
#line 132
  j___0 = 0;
#line 132
  while (j___0 < numf1s) {
#line 134
    su += (f1_layer + j___0)->U;
#line 135
    sp += (f1_layer + j___0)->P;
#line 136
    su2 += (f1_layer + j___0)->U * (f1_layer + j___0)->U;
#line 137
    sp2 += (f1_layer + j___0)->P * (f1_layer + j___0)->P;
#line 138
    sup += (f1_layer + j___0)->U * (f1_layer + j___0)->P;
#line 132
    j___0 ++;
  }
#line 140
  Su = ((double )numf1s * su2 - su * su) / ((double )numf1s * ((double )numf1s - 1.0));
#line 141
  Su = sqrt(Su);
#line 142
  Sp = ((double )numf1s * sp2 - sp * sp) / ((double )numf1s * ((double )numf1s - 1.0));
#line 143
  Sp = sqrt(Sp);
#line 144
  numerator = (double )numf1s * sup - su * sp;
#line 145
  tmp = sqrt((double )numf1s * su2 - su * su);
#line 145
  tmp___0 = sqrt((double )numf1s * sp2 - sp * sp);
#line 145
  denom = tmp * tmp___0;
#line 146
  r = (numerator + e) / (denom + e);
#line 148
  if (numerator == (double )0) {
#line 150
    //tmp___1 = __getreent();
#line 150
    //fprintf(tmp___1->_stderr, "potential div by zero");
#line 151
    r = (double )1;
  } else {
#line 148
    if (denom == (double )0) {
#line 150
      //tmp___1 = __getreent();
#line 150
      //fprintf(tmp___1->_stderr, "potential div by zero");
#line 151
      r = (double )1;
    }
  }
#line 153
  if (numerator != (double )0) {
#line 153
    if (denom == (double )0) {
#line 155
      //tmp___2 = __getreent();
#line 155
      //fprintf(tmp___2->_stderr, "div by zero");
#line 156
      r = (double )1;
    }
  }
#line 158
  r *= r;
#line 163
  return (r);
}
}
#line 166 "scanner.c"
void weightadj(void) 
{ int i___0 ;
  int j___0 ;
  int k ;
  double temp ;
  double er ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 169
  er = 0.000000001;
#line 175
  i___0 = winner;
#line 179
  k = 0;
#line 179
  while (k < 1) {
#line 180
    resonant = 0;
#line 181
    j___0 = 0;
#line 181
    while (j___0 < numf1s) {
#line 182
      temp = *(*(tds + j___0) + i___0);
#line 183
      tmp = g(i___0);
#line 183
      *(*(tds + j___0) + i___0) += (tmp * ((f1_layer + j___0)->P - *(*(tds + j___0) + i___0))) * delta_t;
#line 184
      tmp___0 = fabs(temp - *(*(tds + j___0) + i___0));
#line 184
      if (tmp___0 <= er) {
#line 185
        resonant = 1;
      }
#line 181
      j___0 ++;
    }
#line 191
    j___0 = 0;
#line 191
    while (j___0 < numf1s) {
#line 192
      temp = *(*(bus + j___0) + i___0);
#line 193
      tmp___1 = g(i___0);
#line 193
      *(*(bus + j___0) + i___0) += (tmp___1 * ((f1_layer + j___0)->P - *(*(bus + j___0) + i___0))) * delta_t;
#line 194
      tmp___2 = fabs(temp - *(*(bus + j___0) + i___0));
#line 194
      if (tmp___2 <= er) {
#line 194
        if (resonant) {
#line 199
          resonant = 1;
        } else {
#line 206
          resonant = 0;
        }
      } else {
#line 206
        resonant = 0;
      }
#line 191
      j___0 ++;
    }
#line 179
    k ++;
  }
#line 213
  return;
}
}
#line 219 "scanner.c"
void init_globs(int mode ) 
{ double tmp ;
  double tmp___0 ;

  {
#line 221
  if (mode == 0) {
#line 223
    a = (double )255;
#line 224
    b = 0.0;
#line 225
    c = 0.11;
#line 226
    d = 0.9;
#line 227
    tmp = sqrt((double )numf1s);
#line 227
    theta = (double )1 / tmp;
#line 228
    delta_t = 0.1;
#line 229
    rho = 0.70;
  } else {
#line 233
    a = (double )255;
#line 234
    b = 10.0;
#line 235
    c = 0.11;
#line 236
    d = 0.9;
#line 237
    tmp___0 = sqrt((double )numf1s);
#line 237
    theta = (double )1 / tmp___0;
#line 238
    delta_t = 0.7;
#line 239
    rho = 0.95;
  }
#line 241
  return;
}
}
#line 243 "scanner.c"
void init_net(void) 
{ int i___0 ;
  void *tmp ;
  struct _reent *tmp___0 ;
  void *tmp___1 ;
  struct _reent *tmp___2 ;
  void *tmp___3 ;
  struct _reent *tmp___4 ;

  {
#line 247
  tmp = malloc((unsigned int )numf1s * sizeof(f1_neuron ));
#line 247
  f1_layer = (f1_neuron *)tmp;
#line 248
  if ((unsigned int )f1_layer == (unsigned int )((void *)0)) {
#line 250
    //tmp___0 = __getreent();
#line 250
    //fprintf(tmp___0->_stderr, "malloc error in init_net\n");
#line 251
    ////exit(0)(1);
  }
#line 253
  i___0 = 0;
#line 253
  while (i___0 < numf1s) {
#line 256
    tmp___1 = malloc(2U * sizeof(double ));
#line 256
    (f1_layer + i___0)->I = (double *)tmp___1;
#line 257
    if ((unsigned int )(f1_layer + i___0)->I == (unsigned int )((void *)0)) {
#line 259
      //tmp___2 = __getreent();
#line 259
      //fprintf(tmp___2->_stderr, "malloc error in init_net\n");
#line 260
      ////exit(0)(1);
    }
#line 262
    (f1_layer + i___0)->W = (double )0;
#line 263
    (f1_layer + i___0)->X = (double )0;
#line 264
    (f1_layer + i___0)->V = (double )0;
#line 265
    (f1_layer + i___0)->U = (double )0;
#line 266
    (f1_layer + i___0)->P = (double )0;
#line 267
    (f1_layer + i___0)->Q = (double )0;
#line 268
    (f1_layer + i___0)->R = (double )0;
#line 253
    i___0 ++;
  }
#line 271
  tmp___3 = malloc((unsigned int )numf2s * sizeof(xyz ));
#line 271
  Y = (xyz *)tmp___3;
#line 272
  if ((unsigned int )Y == (unsigned int )((void *)0)) {
#line 274
    //tmp___4 = __getreent();
#line 274
    //fprintf(tmp___4->_stdout, "Malloc error for Y\n");
#line 275
    ////exit(0)(1);
  }
#line 278
  return;
}
}
#line 280 "scanner.c"
void analog_conv(void) 
{ int j___0 ;
  int lines ;
  int k ;
  int x1 ;
  int x2 ;
  double y1___0 ;
  double y2 ;

  {
#line 285
  fscanf(fp, "%i", & lines);
#line 286
  j___0 = 0;
#line 286
  while (j___0 < lines) {
#line 287
    fscanf(fp, "%i %f %i %f", & x1, & y1___0, & x2, & y2);
#line 288
    k = x1;
#line 288
    while (k <= x2) {
#line 289
      *((f1_layer + k)->I + cp) = ((y2 - y1___0) / (double )(x2 - x1)) * (double )(k - x2) + y2;
#line 288
      k ++;
    }
#line 286
    j___0 ++;
  }
#line 293
  return;
}
}
#line 295 "scanner.c"
void get_pat(void) 
{ int i___0 ;

  {
#line 298
  i___0 = 0;
#line 298
  while (i___0 < numf1s) {
#line 299
    fscanf(fp, "%f", (f1_layer + i___0)->I + cp);
#line 298
    i___0 ++;
  }
#line 300
  return;
}
}
#line 302 "scanner.c"
void show_pat(void) 
{ int i___0 ;

  {
#line 305
  i___0 = 0;
#line 305
  while (i___0 < numf1s) {
#line 306
    if (i___0 % 5 == 0) {
#line 307
      printf("\n");
    }
#line 308
    printf(" %8.5f ", *((f1_layer + i___0)->I + cp));
#line 305
    i___0 ++;
  }
#line 310
  printf("\n\n");
#line 312
  return;
}
}
#line 314 "scanner.c"
void reset_nodes(void) 
{ int i___0 ;

  {
#line 317
  i___0 = 0;
#line 317
  while (i___0 < numf1s) {
#line 319
    (f1_layer + i___0)->W = 0.0;
#line 320
    (f1_layer + i___0)->X = 0.0;
#line 321
    (f1_layer + i___0)->V = 0.0;
#line 322
    (f1_layer + i___0)->U = 0.0;
#line 323
    (f1_layer + i___0)->P = 0.0;
#line 324
    (f1_layer + i___0)->Q = 0.0;
#line 325
    (f1_layer + i___0)->R = 0.0;
#line 317
    i___0 ++;
  }
#line 327
  i___0 = 0;
#line 327
  while (i___0 < numf2s) {
#line 328
    (Y + i___0)->y = 0.0;
#line 329
    (Y + i___0)->reset = 0;
#line 327
    i___0 ++;
  }
#line 331
  winner = 0;
#line 332
  resonant = 0;
#line 333
  return;
}
}
#line 336 "scanner.c"
void reset_nodes2(void) 
{ int i___0 ;

  {
#line 339
  i___0 = 0;
#line 339
  while (i___0 < numf1s) {
#line 341
    (f1_layer + i___0)->W = 0.0;
#line 342
    (f1_layer + i___0)->X = 0.0;
#line 343
    (f1_layer + i___0)->V = 0.0;
#line 344
    (f1_layer + i___0)->U = 0.0;
#line 345
    (f1_layer + i___0)->P = 0.0;
#line 346
    (f1_layer + i___0)->Q = 0.0;
#line 347
    (f1_layer + i___0)->R = 0.0;
#line 339
    i___0 ++;
  }
#line 349
  i___0 = 0;
#line 349
  while (i___0 < numf2s) {
#line 350
    (Y + i___0)->y = 0.0;
#line 349
    i___0 ++;
  }
#line 351
  winner = 0;
#line 352
  resonant = 0;
#line 353
  return;
}
}
#line 357 "scanner.c"
void print_weights(void) 
{ int i___0 ;
  int j___0 ;

  {
#line 361
  printf("============  TOP down WEIGHTS ==============\n");
#line 362
  i___0 = 0;
#line 362
  while (i___0 < numf1s) {
#line 363
    j___0 = 0;
#line 363
    while (j___0 < numf2s) {
#line 364
      if (j___0 == numf2s - 1) {
#line 365
        printf(" %8.16f\n", *(*(tds + i___0) + j___0));
      } else {
#line 367
        printf(" %8.16f ", *(*(tds + i___0) + j___0));
      }
#line 363
      j___0 ++;
    }
#line 362
    i___0 ++;
  }
#line 369
  printf("============  BOTTOM up WEIGHTS ==============\n");
#line 370
  i___0 = 0;
#line 370
  while (i___0 < numf1s) {
#line 371
    j___0 = 0;
#line 371
    while (j___0 < numf2s) {
#line 372
      if (j___0 == numf2s - 1) {
#line 373
        printf(" %8.16f\n", *(*(bus + i___0) + j___0));
      } else {
#line 375
        printf(" %8.16f ", *(*(bus + i___0) + j___0));
      }
#line 371
      j___0 ++;
    }
#line 370
    i___0 ++;
  }
#line 376
  return;
}
}
#line 379 "scanner.c"
void print_f12(void) 
{ int j___0 ;

  {
#line 381
  printf("\n\n");
#line 382
  j___0 = 0;
#line 382
  while (j___0 < numf2s) {
#line 383
    printf(" j = %i  Y= %9.7f\n", j___0, (Y + j___0)->y);
#line 382
    j___0 ++;
  }
#line 384
  return;
}
}
#line 386 "scanner.c"
void train_match(int spot ) 
{ int j___0 ;
  int matched ;
  int f1res ;
  int mt ;
  int ti ;
  int tj ;
  int tresult ;
  double tnorm ;
  double xr ;
  double qr ;
  double tsum ;
  double ttemp ;
  char matchtest ;
  double match_confidence ;

  {
#line 393
  f1res = 0;
#line 394
  reset_nodes();
#line 395
  cp = spot;
#line 396
  matched = 0;
#line 397
  while (! matched) {
#line 399
    f1res = 0;
#line 400
    j___0 = 0;
#line 400
    while (1) {
#line 400
      if (j___0 < 9) {
#line 400
        if (! (! f1res)) {
#line 400
          break;
        }
      } else {
#line 400
        break;
      }
#line 404
      tnorm = (double )0;
#line 405
      ti = 0;
#line 405
      while (ti < numf1s) {
#line 407
        (f1_layer + ti)->W = *((f1_layer + ti)->I + cp) + a * (f1_layer + ti)->U;
#line 408
        tnorm += (f1_layer + ti)->W * (f1_layer + ti)->W;
#line 405
        ti ++;
      }
#line 410
      tnorm = sqrt(tnorm);
#line 413
      tj = 0;
#line 413
      while (tj < numf1s) {
#line 414
        (f1_layer + tj)->X = (f1_layer + tj)->W / tnorm;
#line 413
        tj ++;
      }
#line 418
      tnorm = (double )0;
#line 419
      ti = 0;
#line 419
      while (ti < numf1s) {
#line 421
        if ((f1_layer + ti)->X < theta) {
#line 422
          xr = (double )0;
        } else {
#line 424
          xr = (f1_layer + ti)->X;
        }
#line 425
        if ((f1_layer + ti)->Q < theta) {
#line 426
          qr = (double )0;
        } else {
#line 428
          qr = (f1_layer + ti)->Q;
        }
#line 429
        (f1_layer + ti)->V = xr + b * qr;
#line 430
        tnorm += (f1_layer + ti)->V * (f1_layer + ti)->V;
#line 419
        ti ++;
      }
#line 434
      tnorm = sqrt(tnorm);
#line 435
      tj = 0;
#line 435
      while (tj < numf1s) {
#line 436
        (f1_layer + tj)->U = (f1_layer + tj)->V / tnorm;
#line 435
        tj ++;
      }
#line 441
      tnorm = (double )0;
#line 442
      tsum = (double )0;
#line 443
      tresult = 1;
#line 444
      ti = 0;
#line 444
      while (ti < numf1s) {
#line 446
        tsum = (double )0;
#line 447
        ttemp = (f1_layer + ti)->P;
#line 449
        tj = spot;
#line 449
        while (tj < numf2s) {
#line 451
          if (tj == winner) {
#line 451
            if ((Y + tj)->y > (double )0) {
#line 452
              tsum += *(*(tds + ti) + tj) * d;
            }
          }
#line 449
          tj ++;
        }
#line 455
        (f1_layer + ti)->P = (f1_layer + ti)->U + tsum;
#line 457
        tnorm += (f1_layer + ti)->P * (f1_layer + ti)->P;
#line 459
        if (ttemp != (f1_layer + ti)->P) {
#line 460
          tresult = 0;
        }
#line 444
        ti ++;
      }
#line 462
      f1res = tresult;
#line 466
      tnorm = sqrt(tnorm);
#line 467
      tj = 0;
#line 467
      while (tj < numf1s) {
#line 468
        (f1_layer + tj)->Q = (f1_layer + tj)->P;
#line 467
        tj ++;
      }
#line 471
      tj = spot;
#line 471
      while (tj < numf2s) {
#line 473
        (Y + tj)->y = (double )0;
#line 474
        if (! (Y + tj)->reset) {
#line 475
          ti = 0;
#line 475
          while (ti < numf1s) {
#line 476
            (Y + tj)->y += (f1_layer + ti)->P * *(*(bus + ti) + tj);
#line 475
            ti ++;
          }
        }
#line 471
        tj ++;
      }
#line 480
      winner = 0;
#line 481
      ti = spot;
#line 481
      while (ti < numf2s) {
#line 483
        if ((Y + ti)->y > (Y + winner)->y) {
#line 484
          winner = ti;
        }
#line 481
        ti ++;
      }
#line 400
      j___0 ++;
    }
#line 493
    match_confidence = simtest();
#line 497
    if (match_confidence > rho) {
#line 502
      weightadj();
#line 503
      matched = 1;
    } else {
#line 506
      (Y + winner)->y = (double )0;
#line 507
      (Y + winner)->reset = 1;
#line 511
      matchtest = (char)0;
#line 512
      mt = spot;
#line 512
      while (mt < numf2s) {
#line 513
        if ((Y + mt)->reset == 0) {
#line 514
          matchtest = (char)1;
        }
#line 512
        mt ++;
      }
#line 515
      if (matchtest) {
#line 516
        find_match();
      } else {
#line 518
        matched = 1;
      }
    }
  }
#line 521
  return;
}
}
#line 523 "scanner.c"
void match(void) 
{ int j___0 ;
  int matched ;
  int f1res ;
  int mt ;
  int ti ;
  int tj ;
  int tresult ;
  double tnorm ;
  double xr ;
  double qr ;
  double tsum ;
  double ttemp ;
  char matchtest ;
  double match_confidence ;
  struct _reent *tmp ;

  {
#line 530
  f1res = 0;
#line 532
  cp = 0;
#line 533
  reset_nodes();
#line 535
  matched = 0;
#line 536
  while (! matched) {
#line 538
    reset_nodes2();
#line 539
    f1res = 0;
#line 540
    j___0 = 0;
#line 540
    while (1) {
#line 540
      if (j___0 < 9) {
#line 540
        if (! (! f1res)) {
#line 540
          break;
        }
      } else {
#line 540
        break;
      }
#line 544
      tnorm = (double )0;
#line 545
      ti = 0;
#line 545
      while (ti < numf1s) {
#line 547
        (f1_layer + ti)->W = *((f1_layer + ti)->I + cp) + a * (f1_layer + ti)->U;
#line 548
        tnorm += (f1_layer + ti)->W * (f1_layer + ti)->W;
#line 545
        ti ++;
      }
#line 550
      tnorm = sqrt(tnorm);
#line 553
      tj = 0;
#line 553
      while (tj < numf1s) {
#line 554
        (f1_layer + tj)->X = (f1_layer + tj)->W / tnorm;
#line 553
        tj ++;
      }
#line 558
      tnorm = (double )0;
#line 559
      ti = 0;
#line 559
      while (ti < numf1s) {
#line 561
        if ((f1_layer + ti)->X < theta) {
#line 562
          xr = (double )0;
        } else {
#line 564
          xr = (f1_layer + ti)->X;
        }
#line 565
        if ((f1_layer + ti)->Q < theta) {
#line 566
          qr = (double )0;
        } else {
#line 568
          qr = (f1_layer + ti)->Q;
        }
#line 569
        (f1_layer + ti)->V = xr + b * qr;
#line 570
        tnorm += (f1_layer + ti)->V * (f1_layer + ti)->V;
#line 559
        ti ++;
      }
#line 574
      tnorm = sqrt(tnorm);
#line 575
      tj = 0;
#line 575
      while (tj < numf1s) {
#line 576
        (f1_layer + tj)->U = (f1_layer + tj)->V / tnorm;
#line 575
        tj ++;
      }
#line 581
      tnorm = (double )0;
#line 582
      tsum = (double )0;
#line 583
      tresult = 1;
#line 584
      ti = 0;
#line 584
      while (ti < numf1s) {
#line 586
        tsum = (double )0;
#line 587
        ttemp = (f1_layer + ti)->P;
#line 589
        tj = 0;
#line 589
        while (tj < numf2s) {
#line 591
          if (tj == winner) {
#line 591
            if ((Y + tj)->y > (double )0) {
#line 592
              tsum += *(*(tds + ti) + tj) * d;
            }
          }
#line 589
          tj ++;
        }
#line 595
        (f1_layer + ti)->P = (f1_layer + ti)->U + tsum;
#line 597
        tnorm += (f1_layer + ti)->P * (f1_layer + ti)->P;
#line 599
        if (ttemp != (f1_layer + ti)->P) {
#line 600
          tresult = 0;
        }
#line 584
        ti ++;
      }
#line 602
      f1res = tresult;
#line 606
      tnorm = sqrt(tnorm);
#line 607
      tj = 0;
#line 607
      while (tj < numf1s) {
#line 608
        (f1_layer + tj)->Q = (f1_layer + tj)->P;
#line 607
        tj ++;
      }
#line 611
      tj = 0;
#line 611
      while (tj < numf2s) {
#line 613
        (Y + tj)->y = (double )0;
#line 614
        if (! (Y + tj)->reset) {
#line 615
          ti = 0;
#line 615
          while (ti < numf1s) {
#line 616
            (Y + tj)->y += (f1_layer + ti)->P * *(*(bus + ti) + tj);
#line 615
            ti ++;
          }
        }
#line 611
        tj ++;
      }
#line 620
      winner = 0;
#line 621
      ti = 0;
#line 621
      while (ti < numf2s) {
#line 623
        if ((Y + ti)->y > (Y + winner)->y) {
#line 624
          winner = ti;
        }
#line 621
        ti ++;
      }
#line 540
      j___0 ++;
    }
#line 633
    match_confidence = simtest2();
#line 634
    if (match_confidence > rho) {
#line 639
      if (winner != numf2s - 1) {
#line 641
        pass_flag = 1;
#line 642
        //tmp = __getreent();
#line 642
        //fprintf(tmp->_stdout, "F2 neuron %d passes vigilance with a value of %0.4f\n",
                //winner, match_confidence);
#line 643
        print_f12();
#line 644
        if (match_confidence > highest_confidence[winner]) {
#line 646
          highest_confidence[winner] = match_confidence;
#line 647
          set_high[winner] = 1;
        }
      }
#line 650
      matched = 1;
    } else {
#line 653
      (Y + winner)->y = (double )0;
#line 654
      (Y + winner)->reset = 1;
#line 658
      matchtest = (char)0;
#line 659
      mt = 0;
#line 659
      while (mt < numf2s) {
#line 660
        if ((Y + mt)->reset == 0) {
#line 661
          matchtest = (char)1;
        }
#line 659
        mt ++;
      }
#line 662
      if (matchtest) {
#line 663
        find_match();
      } else {
#line 665
        matched = 1;
      }
    }
  }
#line 668
  return;
}
}
#line 698
extern int ( /* missing proto */  read)() ;
#line 682 "scanner.c"
void loadimage(char *input_file ) 
{ int i___0 ;
  int j___0 ;
  int fd ;
  char buffer[64] ;
  char *superbuffer ;
  struct _reent *tmp ;
  void *tmp___0 ;
  struct _reent *tmp___1 ;
  void *tmp___2 ;
  struct _reent *tmp___3 ;
  void *tmp___4 ;
  struct _reent *tmp___5 ;

  {
#line 688
  fd = fopen((char const   *)input_file, 0);
#line 688
  if (fd == -1) {
#line 690
    //tmp = __getreent();
#line 690
    //fprintf(tmp->_stderr, "Error opening %s\n", input_file);
#line 691
    ////exit(0)(1);
  }
#line 698
  ////read(fd, buffer, 8);
#line 700
  ////read(fd, buffer, 4);
  //fread(buffer,8,);
#line 701
  i___0 = 0;
#line 701
 // while (i___0 < 4) {
#line 702
    //if ((int )buffer[i___0] != 32) {
#line 703
   ////   width = (width * 10 + (int )buffer[i___0]) - 48;
   // }
#line 701
  //  i___0 ++;
  //}
#line 706
  ////read(fd, buffer, 4);
#line 707
  i___0 = 0;
#line 707
  while (i___0 < 4) {
#line 708
    if ((int )buffer[i___0] != 32) {
#line 709
      height = (height * 10 + (int )buffer[i___0]) - 48;
    }
#line 707
    i___0 ++;
  }
#line 715
  tmp___0 = malloc((unsigned int )(width * height) * sizeof(char ));
#line 715
  superbuffer = (char *)tmp___0;
#line 716
  //if ((unsigned int )superbuffer == (unsigned int )((void *)0)) {
#line 718
      //return 0;
    //tmp___1 = __getreent();
#line 718
    //fprintf(tmp___1->_stderr, "Problems with malloc in loadimage()\n");
#line 719
    ////exit(0)(1);
  //}
#line 721
  tmp___2 = malloc(sizeof(unsigned char *) * (unsigned int )height);
#line 721
  cimage = (unsigned char **)tmp___2;
#line 722
  if ((unsigned int )cimage == (unsigned int )((void *)0)) {
#line 724
    tmp___3 = __getreent();
#line 724
    //fprintf(tmp___3->_stderr, "Problems with malloc in loadimage()\n");
#line 725
    ////exit(0)(1);
  }
#line 728
  i___0 = 0;
#line 728
  while (i___0 < height) {
#line 730
    tmp___4 = malloc((unsigned int )width * sizeof(unsigned char ));
#line 730
    *(cimage + i___0) = (unsigned char *)tmp___4;
#line 731
    if ((unsigned int )*(cimage + i___0) == (unsigned int )((void *)0)) {
#line 733
      //tmp___5 = __getreent();
#line 733
      //fprintf(tmp___5->_stderr, "Problems with malloc in loadimage()\n");
#line 734
      ////exit(0)(1);
    }
#line 728
    i___0 ++;
  }
#line 738
  ////read(fd, superbuffer, width * height);
#line 739
  i___0 = 0;
#line 739
  while (i___0 < height) {
#line 741
    j___0 = 0;
#line 741
    while (j___0 < width) {
#line 743
      *(*(cimage + i___0) + j___0) = (unsigned char )*(superbuffer + (i___0 * width + j___0));
#line 741
      j___0 ++;
    }
#line 739
    i___0 ++;
  }
#line 758
  return;
}
}
#line 767 "scanner.c"
void load_weights(char *weightfile ) 
{ double a___0 ;
  long i___0 ;
  long j___0 ;
  FILE *inp ;
  struct _reent *tmp ;
  double tmp___0 ;

  {
#line 773
  inp = fopen((char const   *)weightfile, "r");
#line 773
  if ((unsigned int )inp == (unsigned int )((void *)0)) {
#line 775
    //tmp = __getreent();
#line 775
    //fprintf(tmp->_stderr, "Unable to open %s\n", weightfile);
#line 776
    ////exit(0)(1);
  }
#line 779
  printf("made it to load_weights\n");
#line 780
  fscanf(inp, "%d %d", & lwidth, & lheight);
#line 781
  numinputs = lwidth * lheight;
#line 781
  numf1s = numinputs;
#line 782
  numf2s = numpatterns + 1;
#line 784
  alloc_td_bu();
#line 786
  j___0 = 0L;
#line 787
  i___0 = 0L;
#line 787
  while (i___0 < (long )numf1s) {
#line 788
    fscanf(inp, "%le", & a___0);
#line 789
    tmp___0 = a___0;
#line 789
    *(*(tds + i___0) + j___0) = tmp___0;
#line 789
    *(*(bus + i___0) + j___0) = tmp___0;
#line 787
    i___0 ++;
  }
#line 791
  return;
}
}
#line 796 "scanner.c"
void alloc_td_bu(void) 
{ void *tmp ;
  void *tmp___0 ;
  struct _reent *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 798
  tmp = malloc((unsigned int )numf1s * sizeof(double *));
#line 798
  bus = (double **)tmp;
#line 799
  tmp___0 = malloc((unsigned int )numf1s * sizeof(double *));
#line 799
  tds = (double **)tmp___0;
#line 800
  if ((unsigned int )bus == (unsigned int )((void *)0)) {
#line 802
    //tmp___1 = __getreent();
#line 802
    //fprintf(tmp___1->_stderr, "Malloc problem in load_weights\n");
#line 803
    ////exit(0)(1);
  } else {
#line 800
    if ((unsigned int )tds == (unsigned int )((void *)0)) {
#line 802
      //tmp___1 = __getreent();
#line 802
      //fprintf(tmp___1->_stderr, "Malloc problem in load_weights\n");
#line 803
      ////exit(0)(1);
    }
  }
#line 805
  i = 0L;
#line 805
  while (i < (long )numf1s) {
#line 807
    tmp___2 = malloc((unsigned int )numf2s * sizeof(double ));
#line 807
    *(bus + i) = (double *)tmp___2;
#line 808
    tmp___3 = malloc((unsigned int )numf2s * sizeof(double ));
#line 808
    *(tds + i) = (double *)tmp___3;
#line 805
    i ++;
  }
#line 810
  return;
}
}
#line 816 "scanner.c"
void init_td(int start ) 
{ int i___0 ;
  int j___0 ;

  {
#line 819
  i___0 = 0;
#line 819
  while (i___0 < numf1s) {
#line 820
    j___0 = start;
#line 820
    while (j___0 < numf2s) {
#line 821
      *(*(tds + i___0) + j___0) = 0.0;
#line 820
      j___0 ++;
    }
#line 819
    i___0 ++;
  }
#line 822
  return;
}
}
#line 826 "scanner.c"
void init_bu(int start ) 
{ int i___0 ;
  int j___0 ;
  double tmp ;

  {
#line 829
  i___0 = 0;
#line 829
  while (i___0 < numf1s) {
#line 830
    j___0 = start;
#line 830
    while (j___0 < numf2s) {
#line 831
      tmp = sqrt((double )numf1s);
#line 831
      *(*(bus + i___0) + j___0) = ((double )1 / (1.0 - d)) / tmp;
#line 830
      j___0 ++;
    }
#line 829
    i___0 ++;
  }
#line 832
  return;
}
}
#line 837 "scanner.c"
void load_train(char *trainfile , int mode , int objects ) 
{ int i___0 ;
  int fd ;
  char buffer[64] ;
  char *superbuffer ;
  unsigned char t ;
  int spot ;
  struct _reent *tmp ;
  struct _reent *tmp___0 ;
  struct _reent *tmp___1 ;
  void *tmp___2 ;
  struct _reent *tmp___3 ;

  {
#line 846
  if (mode == 1) {
#line 848
    spot = 0;
  } else {
#line 852
    spot = 1;
  }
#line 855
  fd = open((char const   *)trainfile, 0);
#line 855
  if (fd == -1) {
#line 857
    //tmp = __getreent();
#line 857
    //fprintf(tmp->_stderr, "Error opening %s\n", trainfile);
#line 858
    ////exit(0)(1);
  }
#line 864
  lwidth = 0;
#line 865
  lheight = 0;
#line 868
  ////read(fd, buffer, 8);
#line 870
  ////read(fd, buffer, 4);
#line 871
  i___0 = 0;
#line 871
  while (i___0 < 4) {
#line 872
    if ((int )buffer[i___0] != 32) {
#line 873
      lwidth = (lwidth * 10 + (int )buffer[i___0]) - 48;
    }
#line 871
    i___0 ++;
  }
#line 875
  ////read(fd, buffer, 4);
#line 876
  i___0 = 0;
#line 876
  while (i___0 < 4) {
#line 877
    if ((int )buffer[i___0] != 32) {
#line 878
      lheight = (lheight * 10 + (int )buffer[i___0]) - 48;
    }
#line 876
    i___0 ++;
  }
#line 891
  if (mode == 1) {
#line 893
    numinputs = lwidth * lheight;
#line 893
    numf1s = numinputs;
#line 894
    numf2s = objects + 1;
#line 895
    init_globs(1);
#line 896
    init_net();
  } else {
#line 900
    if (lwidth * lheight != numf1s) {
#line 902
      //tmp___0 = __getreent();
#line 902
      //fprintf(tmp___0->_stderr, "Dimensions of first image do not match");
#line 903
      //tmp___1 = __getreent();
#line 903
      //fprintf(tmp___1->_stderr, " dimensions of second.\n");
#line 904
      ////exit(0)(1);
    }
  }
#line 908
  tmp___2 = malloc((unsigned int )(lwidth * lheight) * sizeof(char ));
#line 908
  superbuffer = (char *)tmp___2;
#line 909
  if ((unsigned int )superbuffer == (unsigned int )((void *)0)) {
#line 911
    //tmp___3 = __getreent();
#line 911
    //fprintf(tmp___3->_stderr, "Problems with malloc in loadimage()\n");
#line 912
    //exit(0)(1);
  }
#line 915
  //read(fd, superbuffer, lwidth * lheight);
#line 916
  i___0 = 0;
#line 916
  while (i___0 < lheight * lwidth) {
#line 918
    t = (unsigned char )*(superbuffer + i___0);
#line 919
    *((f1_layer + i___0)->I + spot) = (double )t;
#line 916
    i___0 ++;
  }
#line 922
  free((void *)superbuffer);
#line 924
  return;
}
}
#line 934 "scanner.c"
void sim_other_objects(int low , int high , int stop ) 
{ int i___0 ;
  int j___0 ;
  int noise1 ;
  double noise2 ;
  int tmp ;

  {
#line 943
  if (high <= low) {
#line 944
    return;
  }
#line 946
  srand(10U);
#line 947
  i___0 = low;
#line 947
  while (i___0 < high) {
#line 948
    j___0 = 0;
#line 948
    while (j___0 < numf1s) {
#line 949
      if (i___0 % low) {
#line 950
        *(*(tds + j___0) + i___0) = *(*(tds + j___0) + 0);
#line 951
        *(*(tds + j___0) + i___0) = *(*(bus + j___0) + 0);
      } else {
#line 953
        *(*(tds + j___0) + i___0) = *(*(tds + j___0) + 1);
#line 954
        *(*(tds + j___0) + i___0) = *(*(bus + j___0) + 1);
      }
#line 948
      j___0 ++;
    }
#line 947
    i___0 ++;
  }
#line 958
  i___0 = low;
#line 958
  while (i___0 < high) {
#line 959
    j___0 = 0;
#line 959
    while (j___0 < numf1s) {
#line 960
      tmp = rand();
#line 960
      noise1 = tmp & 65535;
#line 961
      noise2 = (double )noise1 / (double )65535;
#line 962
      *(*(tds + j___0) + i___0) += noise2;
#line 963
      *(*(bus + j___0) + i___0) += noise2;
#line 959
      j___0 ++;
    }
#line 958
    i___0 ++;
  }
#line 973
  return;
}
}
#line 975 "scanner.c"
void setup_base_pattern(int spot ) 
{ int i___0 ;
  int j___0 ;
  double tmp ;
  double tmp___0 ;

  {
#line 978
  i___0 = 0;
#line 978
  while (i___0 < numf1s) {
#line 980
    j___0 = spot;
#line 980
    while (j___0 < numf2s) {
#line 982
      tmp___0 = sqrt((double )numf1s);
#line 982
      tmp = (1.0 / tmp___0) / ((double )1 - d);
#line 982
      *(*(bus + i___0) + j___0) = tmp;
#line 982
      *(*(tds + i___0) + j___0) = tmp;
#line 980
      j___0 ++;
    }
#line 978
    i___0 ++;
  }
#line 985
  return;
}
}
#line 987 "scanner.c"
void scan_recognize(int startx , int starty , int endx , int endy , int stride ) 
{ int i___0 ;
  int j___0 ;
  int m ;
  int n ;
  long k ;
  struct _reent *tmp ;
  struct _reent *tmp___0 ;
  long tmp___1 ;

  {
#line 993
  if (starty > (height - lheight) + 1) {
#line 995
    //tmp = __getreent();
#line 995
    //fprintf(tmp->_stderr, "Startx %d or Starty %d is out of range\n", startx, starty);
#line 996
    //exit(0)(1);
  } else {
#line 993
    if (startx > (width - lwidth) + 1) {
#line 995
      //tmp = __getreent();
#line 995
      //fprintf(tmp->_stderr, "Startx %d or Starty %d is out of range\n", startx, starty);
#line 996
      //exit(0)(1);
    }
  }
#line 998
  if (endy > (height - lheight) + 1) {
#line 1000
    //tmp___0 = __getreent();
#line 1000
    //fprintf(tmp___0->_stderr, "endx %d or endy %d is out of range\n", endx, endy);
#line 1001
    //exit(0)(1);
  } else {
#line 998
    if (endx > (width - lwidth) + 1) {
#line 1000
      //tmp___0 = __getreent();
#line 1000
      //fprintf(tmp___0->_stderr, "endx %d or endy %d is out of range\n", endx, endy);
#line 1001
      //exit(0)(1);
    }
  }
#line 1010
  j___0 = starty;
#line 1010
  while (j___0 < endy) {
#line 1011
    i___0 = startx;
#line 1011
    while (i___0 < endx) {
#line 1013
      k = 0L;
#line 1014
      m = j___0;
#line 1014
      while (m < lheight + j___0) {
#line 1015
        n = i___0;
#line 1015
        while (n < lwidth + i___0) {
#line 1016
          tmp___1 = k;
#line 1016
          k ++;
#line 1016
          *((f1_layer + tmp___1)->I + 0) = (double )*(*(cimage + m) + n);
#line 1015
          n ++;
        }
#line 1014
        m ++;
      }
#line 1017
      pass_flag = 0;
#line 1018
      match();
#line 1019
      if (pass_flag == 1) {
#line 1024
        if (set_high[0] == 1) {
#line 1026
          highx[0] = i___0;
#line 1027
          highy[0] = j___0;
#line 1028
          set_high[0] = 0;
        }
#line 1030
        if (set_high[1] == 1) {
#line 1032
          highx[1] = i___0;
#line 1033
          highy[1] = j___0;
#line 1034
          set_high[1] = 0;
        }
      }
#line 1011
      i___0 += stride;
    }
#line 1010
    j___0 += stride;
  }
#line 1042
  return;
}
}
#line 1068
//extern int ( /* missing proto */  strcmp)() ;
#line 1046 "scanner.c"
int main(int argc , char **argv ) 
{ int k ;
  int startx ;
  int starty ;
  int endx ;
  int endy ;
  int stride ;
  int objects ;
  int arg_index ;
  char *scanfile ;
  char *weightfile ;
  char *trainfile1 ;
  char *trainfile2 ;
  int tmp ;
  int tmp___0 ;
  struct _reent *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  struct _reent *tmp___12 ;
  struct _reent *tmp___13 ;
  struct _reent *tmp___14 ;
  struct _reent *tmp___15 ;
  struct _reent *tmp___16 ;
  struct _reent *tmp___17 ;
  struct _reent *tmp___18 ;

  {
#line 1055
  scanfile = (char *)((void *)0);
#line 1056
  weightfile = (char *)((void *)0);
#line 1057
  trainfile1 = (char *)((void *)0);
#line 1058
  trainfile2 = (char *)((void *)0);
#line 1060
  if (argc < 2) {
    //exit(0)(0);
  }
#line 1064
  if (argc == 2) {
#line 1066
    //tmp___0 = strcmp(*(argv + 1), "-v");
#line 1066
    if (tmp___0 == 0) {
      goto Version;
    } else {
#line 1068
      //tmp = strcmp(*(argv + 1), "-h");
#line 1068
      if (tmp == 0) {
        ////exit(0)(0);
      }
    }
  }
#line 1072
  stride = 0;
#line 1073
  startx = 0;
#line 1074
  starty = 0;
#line 1075
  endy = 0;
#line 1076
  endx = 0;
#line 1077
  objects = 0;
#line 1080
  arg_index = 1;
#line 1081
  while (arg_index < argc - 1) {
#line 1083
    //tmp___11 = strcmp(*(argv + arg_index), "-scanfile");
#line 1083
    if (tmp___11 == 0) {
#line 1085
      scanfile = *(argv + (arg_index + 1));
    } else {
#line 1087
      //tmp___10 = strcmp(*(argv + arg_index), "-weightfile");
#line 1087
      if (tmp___10 == 0) {
#line 1089
        weightfile = *(argv + (arg_index + 1));
      } else {
#line 1091
        //tmp___9 = strcmp(*(argv + arg_index), "-trainfile1");
#line 1091
        if (tmp___9 == 0) {
#line 1093
          trainfile1 = *(argv + (arg_index + 1));
        } else {
#line 1095
          //tmp___8 = strcmp(*(argv + arg_index), "-trainfile2");
#line 1095
          if (tmp___8 == 0) {
#line 1097
            trainfile2 = *(argv + (arg_index + 1));
          } else {
#line 1099
            //tmp___7 = strcmp(*(argv + arg_index), "-startx");
#line 1099
            if (tmp___7 == 0) {
#line 1101
              startx = atoi((char const   *)*(argv + (arg_index + 1)));
            } else {
#line 1103
              //tmp___6 = strcmp(*(argv + arg_index), "-starty");
#line 1103
              if (tmp___6 == 0) {
#line 1105
                starty = atoi((char const   *)*(argv + (arg_index + 1)));
              } else {
#line 1107
                //tmp___5 = strcmp(*(argv + arg_index), "-endx");
#line 1107
                if (tmp___5 == 0) {
#line 1109
                  endx = atoi((char const   *)*(argv + (arg_index + 1)));
                } else {
#line 1111
                  //tmp___4 = strcmp(*(argv + arg_index), "-endy");
#line 1111
                  if (tmp___4 == 0) {
#line 1113
                    endy = atoi((char const   *)*(argv + (arg_index + 1)));
                  } else {
#line 1115
//tmp___3 = strcmp(*(argv + arg_index), "-stride");
#line 1115
                    if (tmp___3 == 0) {
#line 1117
                      stride = atoi((char const   *)*(argv + (arg_index + 1)));
                    } else {
#line 1119
                      //tmp___2 = strcmp(*(argv + arg_index), "-objects");
#line 1119
                      if (tmp___2 == 0) {
#line 1121
                        objects = atoi((char const   *)*(argv + (arg_index + 1)));
                      } else {
#line 1125
                        //tmp___1 = __getreent();
#line 1125
                        //fprintf(tmp___1->_stderr, "ERROR: Unknown option -> %s\n",
                                //*(argv + arg_index));
                        //exit(0)(0);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1128
    arg_index += 2;
  }
#line 1133
  if ((unsigned int )scanfile == (unsigned int )((void *)0)) {
#line 1135
    //tmp___12 = __getreent();
#line 1135
    //fprintf(tmp___12->_stderr, "ERROR: Must specify input files\n");
    ////exit(0)(0);
  }
#line 1138
  if ((unsigned int )weightfile == (unsigned int )((void *)0)) {
#line 1138
    if ((unsigned int )trainfile1 == (unsigned int )((void *)0)) {
#line 1140
      //tmp___13 = __getreent();
#line 1140
      //fprintf(tmp___13->_stderr, "ERROR: Must specify weightfile or trainfile1\n");
      ////exit(0)(0);
    }
  }
#line 1143
  if ((unsigned int )weightfile != (unsigned int )((void *)0)) {
#line 1143
    if ((unsigned int )trainfile1 != (unsigned int )((void *)0)) {
#line 1145
      //tmp___14 = __getreent();
#line 1145
      //fprintf(tmp___14->_stderr, "ERROR: Cannot specify weightfile and trainfile1\n");
      //exit(0)(0);
    }
  }
#line 1153
  loadimage(scanfile);
#line 1160
  if ((unsigned int )weightfile != (unsigned int )((void *)0)) {
#line 1162
    numpatterns = 1;
#line 1163
    if (objects == 0) {
#line 1165
      objects = numpatterns;
    }
#line 1167
    load_weights(weightfile);
#line 1168
    init_globs(0);
#line 1169
    init_net();
  } else {
#line 1173
    if ((unsigned int )trainfile2 != (unsigned int )((void *)0)) {
#line 1175
      numpatterns = 2;
#line 1176
      if (objects < numpatterns) {
#line 1178
        objects = numpatterns;
      }
#line 1180
      load_train(trainfile1, 1, objects);
#line 1181
      alloc_td_bu();
#line 1182
      init_td(0);
#line 1183
      init_bu(0);
#line 1184
      k = 0;
#line 1184
      resonant = k;
#line 1185
      while (! resonant) {
#line 1190
        train_match(0);
#line 1191
        k ++;
      }
#line 1193
      load_train(trainfile2, 2, objects);
#line 1194
      init_globs(2);
#line 1195
      init_td(1);
#line 1196
      init_bu(1);
#line 1197
      k = 0;
#line 1197
      resonant = k;
#line 1198
      while (! resonant) {
#line 1203
        train_match(1);
#line 1204
        k ++;
      }
#line 1206
      init_globs(0);
#line 1207
      init_td(objects);
#line 1208
      init_bu(objects);
#line 1209
      sim_other_objects(numpatterns, objects, numf2s);
#line 1210
      setup_base_pattern(objects);
    } else {
#line 1214
      numpatterns = 1;
#line 1215
      if (objects < numpatterns) {
#line 1217
        objects = numpatterns;
      }
#line 1219
      load_train(trainfile1, 1, objects);
#line 1220
      alloc_td_bu();
#line 1221
      init_td(0);
#line 1222
      init_bu(0);
#line 1223
      k = 0;
#line 1223
      resonant = k;
#line 1224
      while (! resonant) {
#line 1229
        train_match(0);
#line 1230
        k ++;
      }
#line 1232
      init_globs(0);
#line 1233
      init_td(1);
#line 1234
      init_bu(1);
#line 1235
      setup_base_pattern(1);
    }
  }
#line 1239
  if (endy == 0) {
#line 1241
    endy = height - lheight;
  }
#line 1243
  if (endx == 0) {
#line 1245
    endx = width - lwidth;
  }
#line 1247
  highest_confidence[0] = 0.0;
#line 1248
  highest_confidence[1] = 0.0;
#line 1249
  highx[0] = 0;
#line 1250
  highx[1] = 0;
#line 1251
  highy[0] = 0;
#line 1252
  highy[1] = 0;
#line 1253
  set_high[0] = 0;
#line 1254
  set_high[1] = 0;
#line 1256
  scan_recognize(startx, starty, endx, endy, stride);
#line 1258
  //tmp___15 = __getreent();
#line 1258
  //fprintf(tmp___15->_stdout, "Highest vigilance for 1 = %0.4f for object at X = %d, Y = %d\n",
          //highest_confidence[0], highx[0], highy[0]);
#line 1259
  if (numpatterns == 2) {
#line 1260
    //tmp___16 = __getreent();
#line 1260
    //fprintf(tmp___16->_stdout, "Highest vigilance for 2 = %0.4f for object at X = %d, Y = %d\n",
            //highest_confidence[1], highx[1], highy[1]);
  }
#line 1262
  return (0);
  //Usage: 
#line 1264
  //tmp___17 = __getreent();
#line 1264
  //fprintf(tmp___17->_stderr, "Usage: scanner [-startx <num>] [-starty <num>] [-endx <num>] [-endy <num>] [-stride <num>] -scanfile <filename> -trainfile1 <filename> [-trainfile2 <filename>]\n");
#line 1265
  //exit(0)(1);
  Version: 
#line 1267
  //tmp___18 = __getreent();
#line 1267
  //fprintf(tmp___18->_stderr, "Version 1.00 \n");
#line 1268
  //exit(0)(1);
  return 0;
}
}
